head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.2
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2016.08.09.18.59.55;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	6HLO5qdN5N4nPDjW;

1.14
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	s0SI41sEunLdyFfd;

1.13
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	Te1daavkBLskZ8gc;

1.12
date	2015.02.11.20.58.47;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	dgcmwPGRv39E4MF9;

1.11
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2014.05.02.19.27.51;	author matthieu;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2013.06.07.17.28.56;	author matthieu;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.21.20.10.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.11;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.25;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.28;	author matthieu;	state Exp;
branches;
next	;

1.9.4.1
date	2015.02.12.07.28.44;	author matthieu;	state Exp;
branches;
next	;
commitid	h7u4QlHbZBFDevHf;

1.10.2.1
date	2015.02.12.07.29.20;	author matthieu;	state Exp;
branches;
next	;
commitid	QrBQ2oyktmnC4uSq;


desc
@@


1.15
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include "extnsionst.h"
#include "extinit.h"
#include "xace.h"
#include "xkb.h"
#include "protocol-versions.h"

#include <X11/extensions/XI.h>
#include <X11/extensions/XKMformat.h>

int XkbEventBase;
static int XkbErrorBase;
int XkbReqCode;
int XkbKeyboardErrorCode;
CARD32 xkbDebugFlags = 0;
static CARD32 xkbDebugCtrls = 0;

static RESTYPE RT_XKBCLIENT;

/***====================================================================***/

#define	CHK_DEVICE(dev, id, client, access_mode, lf) {\
    int why;\
    int tmprc = lf(&(dev), id, client, access_mode, &why);\
    if (tmprc != Success) {\
	client->errorValue = _XkbErrCode2(why, id);\
	return tmprc;\
    }\
}

#define	CHK_KBD_DEVICE(dev, id, client, mode) \
    CHK_DEVICE(dev, id, client, mode, _XkbLookupKeyboard)
#define	CHK_LED_DEVICE(dev, id, client, mode) \
    CHK_DEVICE(dev, id, client, mode, _XkbLookupLedDevice)
#define	CHK_BELL_DEVICE(dev, id, client, mode) \
    CHK_DEVICE(dev, id, client, mode, _XkbLookupBellDevice)
#define	CHK_ANY_DEVICE(dev, id, client, mode) \
    CHK_DEVICE(dev, id, client, mode, _XkbLookupAnyDevice)

#define	CHK_ATOM_ONLY2(a,ev,er) {\
	if (((a)==None)||(!ValidAtom((a)))) {\
	    (ev)= (XID)(a);\
	    return er;\
	}\
}
#define	CHK_ATOM_ONLY(a) \
	CHK_ATOM_ONLY2(a,client->errorValue,BadAtom)

#define	CHK_ATOM_OR_NONE3(a,ev,er,ret) {\
	if (((a)!=None)&&(!ValidAtom((a)))) {\
	    (ev)= (XID)(a);\
	    (er)= BadAtom;\
	    return ret;\
	}\
}
#define	CHK_ATOM_OR_NONE2(a,ev,er) {\
	if (((a)!=None)&&(!ValidAtom((a)))) {\
	    (ev)= (XID)(a);\
	    return er;\
	}\
}
#define	CHK_ATOM_OR_NONE(a) \
	CHK_ATOM_OR_NONE2(a,client->errorValue,BadAtom)

#define	CHK_MASK_LEGAL3(err,mask,legal,ev,er,ret)	{\
	if ((mask)&(~(legal))) { \
	    (ev)= _XkbErrCode2((err),((mask)&(~(legal))));\
	    (er)= BadValue;\
	    return ret;\
	}\
}
#define	CHK_MASK_LEGAL2(err,mask,legal,ev,er)	{\
	if ((mask)&(~(legal))) { \
	    (ev)= _XkbErrCode2((err),((mask)&(~(legal))));\
	    return er;\
	}\
}
#define	CHK_MASK_LEGAL(err,mask,legal) \
	CHK_MASK_LEGAL2(err,mask,legal,client->errorValue,BadValue)

#define	CHK_MASK_MATCH(err,affect,value) {\
	if ((value)&(~(affect))) { \
	    client->errorValue= _XkbErrCode2((err),((value)&(~(affect))));\
	    return BadMatch;\
	}\
}
#define	CHK_MASK_OVERLAP(err,m1,m2) {\
	if ((m1)&(m2)) { \
	    client->errorValue= _XkbErrCode2((err),((m1)&(m2)));\
	    return BadMatch;\
	}\
}
#define	CHK_KEY_RANGE2(err,first,num,x,ev,er) {\
	if (((unsigned)(first)+(num)-1)>(x)->max_key_code) {\
	    (ev)=_XkbErrCode4(err,(first),(num),(x)->max_key_code);\
	    return er;\
	}\
	else if ( (first)<(x)->min_key_code ) {\
	    (ev)=_XkbErrCode3(err+1,(first),xkb->min_key_code);\
	    return er;\
	}\
}
#define	CHK_KEY_RANGE(err,first,num,x)  \
	CHK_KEY_RANGE2(err,first,num,x,client->errorValue,BadValue)

#define	CHK_REQ_KEY_RANGE2(err,first,num,r,ev,er) {\
	if (((unsigned)(first)+(num)-1)>(r)->maxKeyCode) {\
	    (ev)=_XkbErrCode4(err,(first),(num),(r)->maxKeyCode);\
	    return er;\
	}\
	else if ( (first)<(r)->minKeyCode ) {\
	    (ev)=_XkbErrCode3(err+1,(first),(r)->minKeyCode);\
	    return er;\
	}\
}
#define	CHK_REQ_KEY_RANGE(err,first,num,r)  \
	CHK_REQ_KEY_RANGE2(err,first,num,r,client->errorValue,BadValue)

/***====================================================================***/

int
ProcXkbUseExtension(ClientPtr client)
{
    REQUEST(xkbUseExtensionReq);
    xkbUseExtensionReply rep;
    int supported;

    REQUEST_SIZE_MATCH(xkbUseExtensionReq);
    if (stuff->wantedMajor != SERVER_XKB_MAJOR_VERSION) {
        /* pre-release version 0.65 is compatible with 1.00 */
        supported = ((SERVER_XKB_MAJOR_VERSION == 1) &&
                     (stuff->wantedMajor == 0) && (stuff->wantedMinor == 65));
    }
    else
        supported = 1;

    if ((supported) && (!(client->xkbClientFlags & _XkbClientInitialized))) {
        client->xkbClientFlags = _XkbClientInitialized;
        client->vMajor = stuff->wantedMajor;
        client->vMinor = stuff->wantedMinor;
    }
    else if (xkbDebugFlags & 0x1) {
        ErrorF
            ("[xkb] Rejecting client %d (0x%lx) (wants %d.%02d, have %d.%02d)\n",
             client->index, (long) client->clientAsMask, stuff->wantedMajor,
             stuff->wantedMinor, SERVER_XKB_MAJOR_VERSION,
             SERVER_XKB_MINOR_VERSION);
    }
    rep = (xkbUseExtensionReply) {
        .type = X_Reply,
        .supported = supported,
        .sequenceNumber = client->sequence,
        .length = 0,
        .serverMajor = SERVER_XKB_MAJOR_VERSION,
        .serverMinor = SERVER_XKB_MINOR_VERSION
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swaps(&rep.serverMajor);
        swaps(&rep.serverMinor);
    }
    WriteToClient(client, SIZEOF(xkbUseExtensionReply), &rep);
    return Success;
}

/***====================================================================***/

int
ProcXkbSelectEvents(ClientPtr client)
{
    unsigned legal;
    DeviceIntPtr dev;
    XkbInterestPtr masks;

    REQUEST(xkbSelectEventsReq);

    REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_ANY_DEVICE(dev, stuff->deviceSpec, client, DixUseAccess);

    if (((stuff->affectWhich & XkbMapNotifyMask) != 0) && (stuff->affectMap)) {
        client->mapNotifyMask &= ~stuff->affectMap;
        client->mapNotifyMask |= (stuff->affectMap & stuff->map);
    }
    if ((stuff->affectWhich & (~XkbMapNotifyMask)) == 0)
        return Success;

    masks = XkbFindClientResource((DevicePtr) dev, client);
    if (!masks) {
        XID id = FakeClientID(client->index);

        if (!AddResource(id, RT_XKBCLIENT, dev))
            return BadAlloc;
        masks = XkbAddClientResource((DevicePtr) dev, client, id);
    }
    if (masks) {
        union {
            CARD8 *c8;
            CARD16 *c16;
            CARD32 *c32;
        } from, to;
        register unsigned bit, ndx, maskLeft, dataLeft, size;

        from.c8 = (CARD8 *) &stuff[1];
        dataLeft = (stuff->length * 4) - SIZEOF(xkbSelectEventsReq);
        maskLeft = (stuff->affectWhich & (~XkbMapNotifyMask));
        for (ndx = 0, bit = 1; (maskLeft != 0); ndx++, bit <<= 1) {
            if ((bit & maskLeft) == 0)
                continue;
            maskLeft &= ~bit;
            switch (ndx) {
            case XkbNewKeyboardNotify:
                to.c16 = &client->newKeyboardNotifyMask;
                legal = XkbAllNewKeyboardEventsMask;
                size = 2;
                break;
            case XkbStateNotify:
                to.c16 = &masks->stateNotifyMask;
                legal = XkbAllStateEventsMask;
                size = 2;
                break;
            case XkbControlsNotify:
                to.c32 = &masks->ctrlsNotifyMask;
                legal = XkbAllControlEventsMask;
                size = 4;
                break;
            case XkbIndicatorStateNotify:
                to.c32 = &masks->iStateNotifyMask;
                legal = XkbAllIndicatorEventsMask;
                size = 4;
                break;
            case XkbIndicatorMapNotify:
                to.c32 = &masks->iMapNotifyMask;
                legal = XkbAllIndicatorEventsMask;
                size = 4;
                break;
            case XkbNamesNotify:
                to.c16 = &masks->namesNotifyMask;
                legal = XkbAllNameEventsMask;
                size = 2;
                break;
            case XkbCompatMapNotify:
                to.c8 = &masks->compatNotifyMask;
                legal = XkbAllCompatMapEventsMask;
                size = 1;
                break;
            case XkbBellNotify:
                to.c8 = &masks->bellNotifyMask;
                legal = XkbAllBellEventsMask;
                size = 1;
                break;
            case XkbActionMessage:
                to.c8 = &masks->actionMessageMask;
                legal = XkbAllActionMessagesMask;
                size = 1;
                break;
            case XkbAccessXNotify:
                to.c16 = &masks->accessXNotifyMask;
                legal = XkbAllAccessXEventsMask;
                size = 2;
                break;
            case XkbExtensionDeviceNotify:
                to.c16 = &masks->extDevNotifyMask;
                legal = XkbAllExtensionDeviceEventsMask;
                size = 2;
                break;
            default:
                client->errorValue = _XkbErrCode2(33, bit);
                return BadValue;
            }

            if (stuff->clear & bit) {
                if (size == 2)
                    to.c16[0] = 0;
                else if (size == 4)
                    to.c32[0] = 0;
                else
                    to.c8[0] = 0;
            }
            else if (stuff->selectAll & bit) {
                if (size == 2)
                    to.c16[0] = ~0;
                else if (size == 4)
                    to.c32[0] = ~0;
                else
                    to.c8[0] = ~0;
            }
            else {
                if (dataLeft < (size * 2))
                    return BadLength;
                if (size == 2) {
                    CHK_MASK_MATCH(ndx, from.c16[0], from.c16[1]);
                    CHK_MASK_LEGAL(ndx, from.c16[0], legal);
                    to.c16[0] &= ~from.c16[0];
                    to.c16[0] |= (from.c16[0] & from.c16[1]);
                }
                else if (size == 4) {
                    CHK_MASK_MATCH(ndx, from.c32[0], from.c32[1]);
                    CHK_MASK_LEGAL(ndx, from.c32[0], legal);
                    to.c32[0] &= ~from.c32[0];
                    to.c32[0] |= (from.c32[0] & from.c32[1]);
                }
                else {
                    CHK_MASK_MATCH(ndx, from.c8[0], from.c8[1]);
                    CHK_MASK_LEGAL(ndx, from.c8[0], legal);
                    to.c8[0] &= ~from.c8[0];
                    to.c8[0] |= (from.c8[0] & from.c8[1]);
                    size = 2;
                }
                from.c8 += (size * 2);
                dataLeft -= (size * 2);
            }
        }
        if (dataLeft > 2) {
            ErrorF("[xkb] Extra data (%d bytes) after SelectEvents\n",
                   dataLeft);
            return BadLength;
        }
        return Success;
    }
    return BadAlloc;
}

/***====================================================================***/
/**
 * Ring a bell on the given device for the given client.
 */
static int
_XkbBell(ClientPtr client, DeviceIntPtr dev, WindowPtr pWin,
         int bellClass, int bellID, int pitch, int duration,
         int percent, int forceSound, int eventOnly, Atom name)
{
    int base;
    void *ctrl;
    int oldPitch, oldDuration;
    int newPercent;

    if (bellClass == KbdFeedbackClass) {
        KbdFeedbackPtr k;

        if (bellID == XkbDfltXIId)
            k = dev->kbdfeed;
        else {
            for (k = dev->kbdfeed; k; k = k->next) {
                if (k->ctrl.id == bellID)
                    break;
            }
        }
        if (!k) {
            client->errorValue = _XkbErrCode2(0x5, bellID);
            return BadValue;
        }
        base = k->ctrl.bell;
        ctrl = (void *) &(k->ctrl);
        oldPitch = k->ctrl.bell_pitch;
        oldDuration = k->ctrl.bell_duration;
        if (pitch != 0) {
            if (pitch == -1)
                k->ctrl.bell_pitch = defaultKeyboardControl.bell_pitch;
            else
                k->ctrl.bell_pitch = pitch;
        }
        if (duration != 0) {
            if (duration == -1)
                k->ctrl.bell_duration = defaultKeyboardControl.bell_duration;
            else
                k->ctrl.bell_duration = duration;
        }
    }
    else if (bellClass == BellFeedbackClass) {
        BellFeedbackPtr b;

        if (bellID == XkbDfltXIId)
            b = dev->bell;
        else {
            for (b = dev->bell; b; b = b->next) {
                if (b->ctrl.id == bellID)
                    break;
            }
        }
        if (!b) {
            client->errorValue = _XkbErrCode2(0x6, bellID);
            return BadValue;
        }
        base = b->ctrl.percent;
        ctrl = (void *) &(b->ctrl);
        oldPitch = b->ctrl.pitch;
        oldDuration = b->ctrl.duration;
        if (pitch != 0) {
            if (pitch == -1)
                b->ctrl.pitch = defaultKeyboardControl.bell_pitch;
            else
                b->ctrl.pitch = pitch;
        }
        if (duration != 0) {
            if (duration == -1)
                b->ctrl.duration = defaultKeyboardControl.bell_duration;
            else
                b->ctrl.duration = duration;
        }
    }
    else {
        client->errorValue = _XkbErrCode2(0x7, bellClass);
        return BadValue;
    }

    newPercent = (base * percent) / 100;
    if (percent < 0)
        newPercent = base + newPercent;
    else
        newPercent = base - newPercent + percent;

    XkbHandleBell(forceSound, eventOnly,
                  dev, newPercent, ctrl, bellClass, name, pWin, client);
    if ((pitch != 0) || (duration != 0)) {
        if (bellClass == KbdFeedbackClass) {
            KbdFeedbackPtr k;

            k = (KbdFeedbackPtr) ctrl;
            if (pitch != 0)
                k->ctrl.bell_pitch = oldPitch;
            if (duration != 0)
                k->ctrl.bell_duration = oldDuration;
        }
        else {
            BellFeedbackPtr b;

            b = (BellFeedbackPtr) ctrl;
            if (pitch != 0)
                b->ctrl.pitch = oldPitch;
            if (duration != 0)
                b->ctrl.duration = oldDuration;
        }
    }

    return Success;
}

int
ProcXkbBell(ClientPtr client)
{
    REQUEST(xkbBellReq);
    DeviceIntPtr dev;
    WindowPtr pWin;
    int rc;

    REQUEST_SIZE_MATCH(xkbBellReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_BELL_DEVICE(dev, stuff->deviceSpec, client, DixBellAccess);
    CHK_ATOM_OR_NONE(stuff->name);

    /* device-independent checks request for sane values */
    if ((stuff->forceSound) && (stuff->eventOnly)) {
        client->errorValue =
            _XkbErrCode3(0x1, stuff->forceSound, stuff->eventOnly);
        return BadMatch;
    }
    if (stuff->percent < -100 || stuff->percent > 100) {
        client->errorValue = _XkbErrCode2(0x2, stuff->percent);
        return BadValue;
    }
    if (stuff->duration < -1) {
        client->errorValue = _XkbErrCode2(0x3, stuff->duration);
        return BadValue;
    }
    if (stuff->pitch < -1) {
        client->errorValue = _XkbErrCode2(0x4, stuff->pitch);
        return BadValue;
    }

    if (stuff->bellClass == XkbDfltXIClass) {
        if (dev->kbdfeed != NULL)
            stuff->bellClass = KbdFeedbackClass;
        else
            stuff->bellClass = BellFeedbackClass;
    }

    if (stuff->window != None) {
        rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
        if (rc != Success) {
            client->errorValue = stuff->window;
            return rc;
        }
    }
    else
        pWin = NULL;

    /* Client wants to ring a bell on the core keyboard?
       Ring the bell on the core keyboard (which does nothing, but if that
       fails the client is screwed anyway), and then on all extension devices.
       Fail if the core keyboard fails but not the extension devices.  this
       may cause some keyboards to ding and others to stay silent. Fix
       your client to use explicit keyboards to avoid this.

       dev is the device the client requested.
     */
    rc = _XkbBell(client, dev, pWin, stuff->bellClass, stuff->bellID,
                  stuff->pitch, stuff->duration, stuff->percent,
                  stuff->forceSound, stuff->eventOnly, stuff->name);

    if ((rc == Success) && ((stuff->deviceSpec == XkbUseCoreKbd) ||
                            (stuff->deviceSpec == XkbUseCorePtr))) {
        DeviceIntPtr other;

        for (other = inputInfo.devices; other; other = other->next) {
            if ((other != dev) && other->key && !IsMaster(other) &&
                GetMaster(other, MASTER_KEYBOARD) == dev) {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixBellAccess);
                if (rc == Success)
                    _XkbBell(client, other, pWin, stuff->bellClass,
                             stuff->bellID, stuff->pitch, stuff->duration,
                             stuff->percent, stuff->forceSound,
                             stuff->eventOnly, stuff->name);
            }
        }
        rc = Success;           /* reset to success, that's what we got for the VCK */
    }

    return rc;
}

/***====================================================================***/

int
ProcXkbGetState(ClientPtr client)
{
    REQUEST(xkbGetStateReq);
    DeviceIntPtr dev;
    xkbGetStateReply rep;
    XkbStateRec *xkb;

    REQUEST_SIZE_MATCH(xkbGetStateReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);

    xkb = &dev->key->xkbInfo->state;
    rep = (xkbGetStateReply) {
        .type = X_Reply,
        .deviceID = dev->id,
        .sequenceNumber = client->sequence,
        .length = 0,
        .mods = XkbStateFieldFromRec(xkb) & 0xff,
        .baseMods = xkb->base_mods,
        .latchedMods = xkb->latched_mods,
        .lockedMods = xkb->locked_mods,
        .group = xkb->group,
        .lockedGroup = xkb->locked_group,
        .baseGroup = xkb->base_group,
        .latchedGroup = xkb->latched_group,
        .compatState = xkb->compat_state,
        .ptrBtnState = xkb->ptr_buttons
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swaps(&rep.ptrBtnState);
    }
    WriteToClient(client, SIZEOF(xkbGetStateReply), &rep);
    return Success;
}

/***====================================================================***/

int
ProcXkbLatchLockState(ClientPtr client)
{
    int status;
    DeviceIntPtr dev, tmpd;
    XkbStateRec oldState, *newState;
    CARD16 changed;
    xkbStateNotify sn;
    XkbEventCauseRec cause;

    REQUEST(xkbLatchLockStateReq);
    REQUEST_SIZE_MATCH(xkbLatchLockStateReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixSetAttrAccess);
    CHK_MASK_MATCH(0x01, stuff->affectModLocks, stuff->modLocks);
    CHK_MASK_MATCH(0x01, stuff->affectModLatches, stuff->modLatches);

    status = Success;

    for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) {
        if ((tmpd == dev) ||
            (!IsMaster(tmpd) && GetMaster(tmpd, MASTER_KEYBOARD) == dev)) {
            if (!tmpd->key || !tmpd->key->xkbInfo)
                continue;

            oldState = tmpd->key->xkbInfo->state;
            newState = &tmpd->key->xkbInfo->state;
            if (stuff->affectModLocks) {
                newState->locked_mods &= ~stuff->affectModLocks;
                newState->locked_mods |=
                    (stuff->affectModLocks & stuff->modLocks);
            }
            if (status == Success && stuff->lockGroup)
                newState->locked_group = stuff->groupLock;
            if (status == Success && stuff->affectModLatches)
                status = XkbLatchModifiers(tmpd, stuff->affectModLatches,
                                           stuff->modLatches);
            if (status == Success && stuff->latchGroup)
                status = XkbLatchGroup(tmpd, stuff->groupLatch);

            if (status != Success)
                return status;

            XkbComputeDerivedState(tmpd->key->xkbInfo);

            changed = XkbStateChangedFlags(&oldState, newState);
            if (changed) {
                sn.keycode = 0;
                sn.eventType = 0;
                sn.requestMajor = XkbReqCode;
                sn.requestMinor = X_kbLatchLockState;
                sn.changed = changed;
                XkbSendStateNotify(tmpd, &sn);
                changed = XkbIndicatorsToUpdate(tmpd, changed, FALSE);
                if (changed) {
                    XkbSetCauseXkbReq(&cause, X_kbLatchLockState, client);
                    XkbUpdateIndicators(tmpd, changed, TRUE, NULL, &cause);
                }
            }
        }
    }

    return Success;
}

/***====================================================================***/

int
ProcXkbGetControls(ClientPtr client)
{
    xkbGetControlsReply rep;
    XkbControlsPtr xkb;
    DeviceIntPtr dev;

    REQUEST(xkbGetControlsReq);
    REQUEST_SIZE_MATCH(xkbGetControlsReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);

    xkb = dev->key->xkbInfo->desc->ctrls;
    rep = (xkbGetControlsReply) {
        .type = X_Reply,
        .deviceID = ((DeviceIntPtr) dev)->id,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(SIZEOF(xkbGetControlsReply) -
                                 SIZEOF(xGenericReply)),
        .mkDfltBtn = xkb->mk_dflt_btn,
        .numGroups = xkb->num_groups,
        .groupsWrap = xkb->groups_wrap,
        .internalMods = xkb->internal.mask,
        .ignoreLockMods = xkb->ignore_lock.mask,
        .internalRealMods = xkb->internal.real_mods,
        .ignoreLockRealMods = xkb->ignore_lock.real_mods,
        .internalVMods = xkb->internal.vmods,
        .ignoreLockVMods = xkb->ignore_lock.vmods,
        .repeatDelay = xkb->repeat_delay,
        .repeatInterval = xkb->repeat_interval,
        .slowKeysDelay = xkb->slow_keys_delay,
        .debounceDelay = xkb->debounce_delay,
        .mkDelay = xkb->mk_delay,
        .mkInterval = xkb->mk_interval,
        .mkTimeToMax = xkb->mk_time_to_max,
        .mkMaxSpeed = xkb->mk_max_speed,
        .mkCurve = xkb->mk_curve,
        .axOptions = xkb->ax_options,
        .axTimeout = xkb->ax_timeout,
        .axtOptsMask = xkb->axt_opts_mask,
        .axtOptsValues = xkb->axt_opts_values,
        .axtCtrlsMask = xkb->axt_ctrls_mask,
        .axtCtrlsValues = xkb->axt_ctrls_values,
        .enabledCtrls = xkb->enabled_ctrls,
    };
    memcpy(rep.perKeyRepeat, xkb->per_key_repeat, XkbPerKeyBitArraySize);
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.internalVMods);
        swaps(&rep.ignoreLockVMods);
        swapl(&rep.enabledCtrls);
        swaps(&rep.repeatDelay);
        swaps(&rep.repeatInterval);
        swaps(&rep.slowKeysDelay);
        swaps(&rep.debounceDelay);
        swaps(&rep.mkDelay);
        swaps(&rep.mkInterval);
        swaps(&rep.mkTimeToMax);
        swaps(&rep.mkMaxSpeed);
        swaps(&rep.mkCurve);
        swaps(&rep.axTimeout);
        swapl(&rep.axtCtrlsMask);
        swapl(&rep.axtCtrlsValues);
        swaps(&rep.axtOptsMask);
        swaps(&rep.axtOptsValues);
        swaps(&rep.axOptions);
    }
    WriteToClient(client, SIZEOF(xkbGetControlsReply), &rep);
    return Success;
}

int
ProcXkbSetControls(ClientPtr client)
{
    DeviceIntPtr dev, tmpd;
    XkbSrvInfoPtr xkbi;
    XkbControlsPtr ctrl;
    XkbControlsRec new, old;
    xkbControlsNotify cn;
    XkbEventCauseRec cause;
    XkbSrvLedInfoPtr sli;

    REQUEST(xkbSetControlsReq);
    REQUEST_SIZE_MATCH(xkbSetControlsReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
    CHK_MASK_LEGAL(0x01, stuff->changeCtrls, XkbAllControlsMask);

    for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) {
        if (!tmpd->key || !tmpd->key->xkbInfo)
            continue;
        if ((tmpd == dev) ||
            (!IsMaster(tmpd) && GetMaster(tmpd, MASTER_KEYBOARD) == dev)) {
            xkbi = tmpd->key->xkbInfo;
            ctrl = xkbi->desc->ctrls;
            new = *ctrl;
            XkbSetCauseXkbReq(&cause, X_kbSetControls, client);

            if (stuff->changeCtrls & XkbInternalModsMask) {
                CHK_MASK_MATCH(0x02, stuff->affectInternalMods,
                               stuff->internalMods);
                CHK_MASK_MATCH(0x03, stuff->affectInternalVMods,
                               stuff->internalVMods);

                new.internal.real_mods &= ~(stuff->affectInternalMods);
                new.internal.real_mods |= (stuff->affectInternalMods &
                                           stuff->internalMods);
                new.internal.vmods &= ~(stuff->affectInternalVMods);
                new.internal.vmods |= (stuff->affectInternalVMods &
                                       stuff->internalVMods);
                new.internal.mask = new.internal.real_mods |
                    XkbMaskForVMask(xkbi->desc, new.internal.vmods);
            }

            if (stuff->changeCtrls & XkbIgnoreLockModsMask) {
                CHK_MASK_MATCH(0x4, stuff->affectIgnoreLockMods,
                               stuff->ignoreLockMods);
                CHK_MASK_MATCH(0x5, stuff->affectIgnoreLockVMods,
                               stuff->ignoreLockVMods);

                new.ignore_lock.real_mods &= ~(stuff->affectIgnoreLockMods);
                new.ignore_lock.real_mods |= (stuff->affectIgnoreLockMods &
                                              stuff->ignoreLockMods);
                new.ignore_lock.vmods &= ~(stuff->affectIgnoreLockVMods);
                new.ignore_lock.vmods |= (stuff->affectIgnoreLockVMods &
                                          stuff->ignoreLockVMods);
                new.ignore_lock.mask = new.ignore_lock.real_mods |
                    XkbMaskForVMask(xkbi->desc, new.ignore_lock.vmods);
            }

            CHK_MASK_MATCH(0x06, stuff->affectEnabledCtrls,
                           stuff->enabledCtrls);
            if (stuff->affectEnabledCtrls) {
                CHK_MASK_LEGAL(0x07, stuff->affectEnabledCtrls,
                               XkbAllBooleanCtrlsMask);

                new.enabled_ctrls &= ~(stuff->affectEnabledCtrls);
                new.enabled_ctrls |= (stuff->affectEnabledCtrls &
                                      stuff->enabledCtrls);
            }

            if (stuff->changeCtrls & XkbRepeatKeysMask) {
                if (stuff->repeatDelay < 1 || stuff->repeatInterval < 1) {
                    client->errorValue = _XkbErrCode3(0x08, stuff->repeatDelay,
                                                      stuff->repeatInterval);
                    return BadValue;
                }

                new.repeat_delay = stuff->repeatDelay;
                new.repeat_interval = stuff->repeatInterval;
            }

            if (stuff->changeCtrls & XkbSlowKeysMask) {
                if (stuff->slowKeysDelay < 1) {
                    client->errorValue = _XkbErrCode2(0x09,
                                                      stuff->slowKeysDelay);
                    return BadValue;
                }

                new.slow_keys_delay = stuff->slowKeysDelay;
            }

            if (stuff->changeCtrls & XkbBounceKeysMask) {
                if (stuff->debounceDelay < 1) {
                    client->errorValue = _XkbErrCode2(0x0A,
                                                      stuff->debounceDelay);
                    return BadValue;
                }

                new.debounce_delay = stuff->debounceDelay;
            }

            if (stuff->changeCtrls & XkbMouseKeysMask) {
                if (stuff->mkDfltBtn > XkbMaxMouseKeysBtn) {
                    client->errorValue = _XkbErrCode2(0x0B, stuff->mkDfltBtn);
                    return BadValue;
                }

                new.mk_dflt_btn = stuff->mkDfltBtn;
            }

            if (stuff->changeCtrls & XkbMouseKeysAccelMask) {
                if (stuff->mkDelay < 1 || stuff->mkInterval < 1 ||
                    stuff->mkTimeToMax < 1 || stuff->mkMaxSpeed < 1 ||
                    stuff->mkCurve < -1000) {
                    client->errorValue = _XkbErrCode2(0x0C, 0);
                    return BadValue;
                }

                new.mk_delay = stuff->mkDelay;
                new.mk_interval = stuff->mkInterval;
                new.mk_time_to_max = stuff->mkTimeToMax;
                new.mk_max_speed = stuff->mkMaxSpeed;
                new.mk_curve = stuff->mkCurve;
                AccessXComputeCurveFactor(xkbi, &new);
            }

            if (stuff->changeCtrls & XkbGroupsWrapMask) {
                unsigned act, num;

                act = XkbOutOfRangeGroupAction(stuff->groupsWrap);
                switch (act) {
                case XkbRedirectIntoRange:
                    num = XkbOutOfRangeGroupNumber(stuff->groupsWrap);
                    if (num >= new.num_groups) {
                        client->errorValue = _XkbErrCode3(0x0D, new.num_groups,
                                                          num);
                        return BadValue;
                    }
                case XkbWrapIntoRange:
                case XkbClampIntoRange:
                    break;
                default:
                    client->errorValue = _XkbErrCode2(0x0E, act);
                    return BadValue;
                }

                new.groups_wrap = stuff->groupsWrap;
            }

            CHK_MASK_LEGAL(0x0F, stuff->axOptions, XkbAX_AllOptionsMask);
            if (stuff->changeCtrls & XkbAccessXKeysMask) {
                new.ax_options = stuff->axOptions & XkbAX_AllOptionsMask;
            }
            else {
                if (stuff->changeCtrls & XkbStickyKeysMask) {
                    new.ax_options &= ~(XkbAX_SKOptionsMask);
                    new.ax_options |= (stuff->axOptions & XkbAX_SKOptionsMask);
                }

                if (stuff->changeCtrls & XkbAccessXFeedbackMask) {
                    new.ax_options &= ~(XkbAX_FBOptionsMask);
                    new.ax_options |= (stuff->axOptions & XkbAX_FBOptionsMask);
                }
            }

            if (stuff->changeCtrls & XkbAccessXTimeoutMask) {
                if (stuff->axTimeout < 1) {
                    client->errorValue = _XkbErrCode2(0x10, stuff->axTimeout);
                    return BadValue;
                }
                CHK_MASK_MATCH(0x11, stuff->axtCtrlsMask,
                               stuff->axtCtrlsValues);
                CHK_MASK_LEGAL(0x12, stuff->axtCtrlsMask,
                               XkbAllBooleanCtrlsMask);
                CHK_MASK_MATCH(0x13, stuff->axtOptsMask, stuff->axtOptsValues);
                CHK_MASK_LEGAL(0x14, stuff->axtOptsMask, XkbAX_AllOptionsMask);
                new.ax_timeout = stuff->axTimeout;
                new.axt_ctrls_mask = stuff->axtCtrlsMask;
                new.axt_ctrls_values = (stuff->axtCtrlsValues &
                                        stuff->axtCtrlsMask);
                new.axt_opts_mask = stuff->axtOptsMask;
                new.axt_opts_values = (stuff->axtOptsValues &
                                       stuff->axtOptsMask);
            }

            if (stuff->changeCtrls & XkbPerKeyRepeatMask) {
                memcpy(new.per_key_repeat, stuff->perKeyRepeat,
                       XkbPerKeyBitArraySize);
                if (xkbi->repeatKey &&
                    !BitIsOn(new.per_key_repeat, xkbi->repeatKey)) {
                    AccessXCancelRepeatKey(xkbi, xkbi->repeatKey);
                }
            }

            old = *ctrl;
            *ctrl = new;
            XkbDDXChangeControls(tmpd, &old, ctrl);

            if (XkbComputeControlsNotify(tmpd, &old, ctrl, &cn, FALSE)) {
                cn.keycode = 0;
                cn.eventType = 0;
                cn.requestMajor = XkbReqCode;
                cn.requestMinor = X_kbSetControls;
                XkbSendControlsNotify(tmpd, &cn);
            }

            sli = XkbFindSrvLedInfo(tmpd, XkbDfltXIClass, XkbDfltXIId, 0);
            if (sli)
                XkbUpdateIndicators(tmpd, sli->usesControls, TRUE, NULL,
                                    &cause);

            /* If sticky keys were disabled, clear all locks and latches */
            if ((old.enabled_ctrls & XkbStickyKeysMask) &&
                !(ctrl->enabled_ctrls & XkbStickyKeysMask))
                XkbClearAllLatchesAndLocks(tmpd, xkbi, TRUE, &cause);
        }
    }

    return Success;
}

/***====================================================================***/

static int
XkbSizeKeyTypes(XkbDescPtr xkb, xkbGetMapReply * rep)
{
    XkbKeyTypeRec *type;
    unsigned i, len;

    len = 0;
    if (((rep->present & XkbKeyTypesMask) == 0) || (rep->nTypes < 1) ||
        (!xkb) || (!xkb->map) || (!xkb->map->types)) {
        rep->present &= ~XkbKeyTypesMask;
        rep->firstType = rep->nTypes = 0;
        return 0;
    }
    type = &xkb->map->types[rep->firstType];
    for (i = 0; i < rep->nTypes; i++, type++) {
        len += SIZEOF(xkbKeyTypeWireDesc);
        if (type->map_count > 0) {
            len += (type->map_count * SIZEOF(xkbKTMapEntryWireDesc));
            if (type->preserve)
                len += (type->map_count * SIZEOF(xkbModsWireDesc));
        }
    }
    return len;
}

static char *
XkbWriteKeyTypes(XkbDescPtr xkb,
                 xkbGetMapReply * rep, char *buf, ClientPtr client)
{
    XkbKeyTypePtr type;
    unsigned i;
    xkbKeyTypeWireDesc *wire;

    type = &xkb->map->types[rep->firstType];
    for (i = 0; i < rep->nTypes; i++, type++) {
        register unsigned n;

        wire = (xkbKeyTypeWireDesc *) buf;
        wire->mask = type->mods.mask;
        wire->realMods = type->mods.real_mods;
        wire->virtualMods = type->mods.vmods;
        wire->numLevels = type->num_levels;
        wire->nMapEntries = type->map_count;
        wire->preserve = (type->preserve != NULL);
        if (client->swapped) {
            swaps(&wire->virtualMods);
        }

        buf = (char *) &wire[1];
        if (wire->nMapEntries > 0) {
            xkbKTMapEntryWireDesc *ewire;
            XkbKTMapEntryPtr entry;

            ewire = (xkbKTMapEntryWireDesc *) buf;
            entry = type->map;
            for (n = 0; n < type->map_count; n++, ewire++, entry++) {
                ewire->active = entry->active;
                ewire->mask = entry->mods.mask;
                ewire->level = entry->level;
                ewire->realMods = entry->mods.real_mods;
                ewire->virtualMods = entry->mods.vmods;
                if (client->swapped) {
                    swaps(&ewire->virtualMods);
                }
            }
            buf = (char *) ewire;
            if (type->preserve != NULL) {
                xkbModsWireDesc *pwire;
                XkbModsPtr preserve;

                pwire = (xkbModsWireDesc *) buf;
                preserve = type->preserve;
                for (n = 0; n < type->map_count; n++, pwire++, preserve++) {
                    pwire->mask = preserve->mask;
                    pwire->realMods = preserve->real_mods;
                    pwire->virtualMods = preserve->vmods;
                    if (client->swapped) {
                        swaps(&pwire->virtualMods);
                    }
                }
                buf = (char *) pwire;
            }
        }
    }
    return buf;
}

static int
XkbSizeKeySyms(XkbDescPtr xkb, xkbGetMapReply * rep)
{
    XkbSymMapPtr symMap;
    unsigned i, len;
    unsigned nSyms, nSymsThisKey;

    if (((rep->present & XkbKeySymsMask) == 0) || (rep->nKeySyms < 1) ||
        (!xkb) || (!xkb->map) || (!xkb->map->key_sym_map)) {
        rep->present &= ~XkbKeySymsMask;
        rep->firstKeySym = rep->nKeySyms = 0;
        rep->totalSyms = 0;
        return 0;
    }
    len = rep->nKeySyms * SIZEOF(xkbSymMapWireDesc);
    symMap = &xkb->map->key_sym_map[rep->firstKeySym];
    for (i = nSyms = 0; i < rep->nKeySyms; i++, symMap++) {
        if (symMap->offset != 0) {
            nSymsThisKey = XkbNumGroups(symMap->group_info) * symMap->width;
            nSyms += nSymsThisKey;
        }
    }
    len += nSyms * 4;
    rep->totalSyms = nSyms;
    return len;
}

static int
XkbSizeVirtualMods(XkbDescPtr xkb, xkbGetMapReply * rep)
{
    register unsigned i, nMods, bit;

    if (((rep->present & XkbVirtualModsMask) == 0) || (rep->virtualMods == 0) ||
        (!xkb) || (!xkb->server)) {
        rep->present &= ~XkbVirtualModsMask;
        rep->virtualMods = 0;
        return 0;
    }
    for (i = nMods = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) {
        if (rep->virtualMods & bit)
            nMods++;
    }
    return XkbPaddedSize(nMods);
}

static char *
XkbWriteKeySyms(XkbDescPtr xkb, xkbGetMapReply * rep, char *buf,
                ClientPtr client)
{
    register KeySym *pSym;
    XkbSymMapPtr symMap;
    xkbSymMapWireDesc *outMap;
    register unsigned i;

    symMap = &xkb->map->key_sym_map[rep->firstKeySym];
    for (i = 0; i < rep->nKeySyms; i++, symMap++) {
        outMap = (xkbSymMapWireDesc *) buf;
        outMap->ktIndex[0] = symMap->kt_index[0];
        outMap->ktIndex[1] = symMap->kt_index[1];
        outMap->ktIndex[2] = symMap->kt_index[2];
        outMap->ktIndex[3] = symMap->kt_index[3];
        outMap->groupInfo = symMap->group_info;
        outMap->width = symMap->width;
        outMap->nSyms = symMap->width * XkbNumGroups(symMap->group_info);
        buf = (char *) &outMap[1];
        if (outMap->nSyms == 0)
            continue;

        pSym = &xkb->map->syms[symMap->offset];
        memcpy((char *) buf, (char *) pSym, outMap->nSyms * 4);
        if (client->swapped) {
            register int nSyms = outMap->nSyms;

            swaps(&outMap->nSyms);
            while (nSyms-- > 0) {
                swapl((int *) buf);
                buf += 4;
            }
        }
        else
            buf += outMap->nSyms * 4;
    }
    return buf;
}

static int
XkbSizeKeyActions(XkbDescPtr xkb, xkbGetMapReply * rep)
{
    unsigned i, len, nActs;
    register KeyCode firstKey;

    if (((rep->present & XkbKeyActionsMask) == 0) || (rep->nKeyActs < 1) ||
        (!xkb) || (!xkb->server) || (!xkb->server->key_acts)) {
        rep->present &= ~XkbKeyActionsMask;
        rep->firstKeyAct = rep->nKeyActs = 0;
        rep->totalActs = 0;
        return 0;
    }
    firstKey = rep->firstKeyAct;
    for (nActs = i = 0; i < rep->nKeyActs; i++) {
        if (xkb->server->key_acts[i + firstKey] != 0)
            nActs += XkbKeyNumActions(xkb, i + firstKey);
    }
    len = XkbPaddedSize(rep->nKeyActs) + (nActs * SIZEOF(xkbActionWireDesc));
    rep->totalActs = nActs;
    return len;
}

static char *
XkbWriteKeyActions(XkbDescPtr xkb, xkbGetMapReply * rep, char *buf,
                   ClientPtr client)
{
    unsigned i;
    CARD8 *numDesc;
    XkbAnyAction *actDesc;

    numDesc = (CARD8 *) buf;
    for (i = 0; i < rep->nKeyActs; i++) {
        if (xkb->server->key_acts[i + rep->firstKeyAct] == 0)
            numDesc[i] = 0;
        else
            numDesc[i] = XkbKeyNumActions(xkb, (i + rep->firstKeyAct));
    }
    buf += XkbPaddedSize(rep->nKeyActs);

    actDesc = (XkbAnyAction *) buf;
    for (i = 0; i < rep->nKeyActs; i++) {
        if (xkb->server->key_acts[i + rep->firstKeyAct] != 0) {
            unsigned int num;

            num = XkbKeyNumActions(xkb, (i + rep->firstKeyAct));
            memcpy((char *) actDesc,
                   (char *) XkbKeyActionsPtr(xkb, (i + rep->firstKeyAct)),
                   num * SIZEOF(xkbActionWireDesc));
            actDesc += num;
        }
    }
    buf = (char *) actDesc;
    return buf;
}

static int
XkbSizeKeyBehaviors(XkbDescPtr xkb, xkbGetMapReply * rep)
{
    unsigned i, len, nBhvr;
    XkbBehavior *bhv;

    if (((rep->present & XkbKeyBehaviorsMask) == 0) || (rep->nKeyBehaviors < 1)
        || (!xkb) || (!xkb->server) || (!xkb->server->behaviors)) {
        rep->present &= ~XkbKeyBehaviorsMask;
        rep->firstKeyBehavior = rep->nKeyBehaviors = 0;
        rep->totalKeyBehaviors = 0;
        return 0;
    }
    bhv = &xkb->server->behaviors[rep->firstKeyBehavior];
    for (nBhvr = i = 0; i < rep->nKeyBehaviors; i++, bhv++) {
        if (bhv->type != XkbKB_Default)
            nBhvr++;
    }
    len = nBhvr * SIZEOF(xkbBehaviorWireDesc);
    rep->totalKeyBehaviors = nBhvr;
    return len;
}

static char *
XkbWriteKeyBehaviors(XkbDescPtr xkb, xkbGetMapReply * rep, char *buf,
                     ClientPtr client)
{
    unsigned i;
    xkbBehaviorWireDesc *wire;
    XkbBehavior *pBhvr;

    wire = (xkbBehaviorWireDesc *) buf;
    pBhvr = &xkb->server->behaviors[rep->firstKeyBehavior];
    for (i = 0; i < rep->nKeyBehaviors; i++, pBhvr++) {
        if (pBhvr->type != XkbKB_Default) {
            wire->key = i + rep->firstKeyBehavior;
            wire->type = pBhvr->type;
            wire->data = pBhvr->data;
            wire++;
        }
    }
    buf = (char *) wire;
    return buf;
}

static int
XkbSizeExplicit(XkbDescPtr xkb, xkbGetMapReply * rep)
{
    unsigned i, len, nRtrn;

    if (((rep->present & XkbExplicitComponentsMask) == 0) ||
        (rep->nKeyExplicit < 1) || (!xkb) || (!xkb->server) ||
        (!xkb->server->explicit)) {
        rep->present &= ~XkbExplicitComponentsMask;
        rep->firstKeyExplicit = rep->nKeyExplicit = 0;
        rep->totalKeyExplicit = 0;
        return 0;
    }
    for (nRtrn = i = 0; i < rep->nKeyExplicit; i++) {
        if (xkb->server->explicit[i + rep->firstKeyExplicit] != 0)
            nRtrn++;
    }
    rep->totalKeyExplicit = nRtrn;
    len = XkbPaddedSize(nRtrn * 2);     /* two bytes per non-zero explicit component */
    return len;
}

static char *
XkbWriteExplicit(XkbDescPtr xkb, xkbGetMapReply * rep, char *buf,
                 ClientPtr client)
{
    unsigned i;
    char *start;
    unsigned char *pExp;

    start = buf;
    pExp = &xkb->server->explicit[rep->firstKeyExplicit];
    for (i = 0; i < rep->nKeyExplicit; i++, pExp++) {
        if (*pExp != 0) {
            *buf++ = i + rep->firstKeyExplicit;
            *buf++ = *pExp;
        }
    }
    i = XkbPaddedSize(buf - start) - (buf - start);     /* pad to word boundary */
    return buf + i;
}

static int
XkbSizeModifierMap(XkbDescPtr xkb, xkbGetMapReply * rep)
{
    unsigned i, len, nRtrn;

    if (((rep->present & XkbModifierMapMask) == 0) || (rep->nModMapKeys < 1) ||
        (!xkb) || (!xkb->map) || (!xkb->map->modmap)) {
        rep->present &= ~XkbModifierMapMask;
        rep->firstModMapKey = rep->nModMapKeys = 0;
        rep->totalModMapKeys = 0;
        return 0;
    }
    for (nRtrn = i = 0; i < rep->nModMapKeys; i++) {
        if (xkb->map->modmap[i + rep->firstModMapKey] != 0)
            nRtrn++;
    }
    rep->totalModMapKeys = nRtrn;
    len = XkbPaddedSize(nRtrn * 2);     /* two bytes per non-zero modmap component */
    return len;
}

static char *
XkbWriteModifierMap(XkbDescPtr xkb, xkbGetMapReply * rep, char *buf,
                    ClientPtr client)
{
    unsigned i;
    char *start;
    unsigned char *pMap;

    start = buf;
    pMap = &xkb->map->modmap[rep->firstModMapKey];
    for (i = 0; i < rep->nModMapKeys; i++, pMap++) {
        if (*pMap != 0) {
            *buf++ = i + rep->firstModMapKey;
            *buf++ = *pMap;
        }
    }
    i = XkbPaddedSize(buf - start) - (buf - start);     /* pad to word boundary */
    return buf + i;
}

static int
XkbSizeVirtualModMap(XkbDescPtr xkb, xkbGetMapReply * rep)
{
    unsigned i, len, nRtrn;

    if (((rep->present & XkbVirtualModMapMask) == 0) || (rep->nVModMapKeys < 1)
        || (!xkb) || (!xkb->server) || (!xkb->server->vmodmap)) {
        rep->present &= ~XkbVirtualModMapMask;
        rep->firstVModMapKey = rep->nVModMapKeys = 0;
        rep->totalVModMapKeys = 0;
        return 0;
    }
    for (nRtrn = i = 0; i < rep->nVModMapKeys; i++) {
        if (xkb->server->vmodmap[i + rep->firstVModMapKey] != 0)
            nRtrn++;
    }
    rep->totalVModMapKeys = nRtrn;
    len = nRtrn * SIZEOF(xkbVModMapWireDesc);
    return len;
}

static char *
XkbWriteVirtualModMap(XkbDescPtr xkb, xkbGetMapReply * rep, char *buf,
                      ClientPtr client)
{
    unsigned i;
    xkbVModMapWireDesc *wire;
    unsigned short *pMap;

    wire = (xkbVModMapWireDesc *) buf;
    pMap = &xkb->server->vmodmap[rep->firstVModMapKey];
    for (i = 0; i < rep->nVModMapKeys; i++, pMap++) {
        if (*pMap != 0) {
            wire->key = i + rep->firstVModMapKey;
            wire->vmods = *pMap;
            wire++;
        }
    }
    return (char *) wire;
}

static Status
XkbComputeGetMapReplySize(XkbDescPtr xkb, xkbGetMapReply * rep)
{
    int len;

    rep->minKeyCode = xkb->min_key_code;
    rep->maxKeyCode = xkb->max_key_code;
    len = XkbSizeKeyTypes(xkb, rep);
    len += XkbSizeKeySyms(xkb, rep);
    len += XkbSizeKeyActions(xkb, rep);
    len += XkbSizeKeyBehaviors(xkb, rep);
    len += XkbSizeVirtualMods(xkb, rep);
    len += XkbSizeExplicit(xkb, rep);
    len += XkbSizeModifierMap(xkb, rep);
    len += XkbSizeVirtualModMap(xkb, rep);
    rep->length += (len / 4);
    return Success;
}

static int
XkbSendMap(ClientPtr client, XkbDescPtr xkb, xkbGetMapReply * rep)
{
    unsigned i, len;
    char *desc, *start;

    len = (rep->length * 4) - (SIZEOF(xkbGetMapReply) - SIZEOF(xGenericReply));
    start = desc = calloc(1, len);
    if (!start)
        return BadAlloc;
    if (rep->nTypes > 0)
        desc = XkbWriteKeyTypes(xkb, rep, desc, client);
    if (rep->nKeySyms > 0)
        desc = XkbWriteKeySyms(xkb, rep, desc, client);
    if (rep->nKeyActs > 0)
        desc = XkbWriteKeyActions(xkb, rep, desc, client);
    if (rep->totalKeyBehaviors > 0)
        desc = XkbWriteKeyBehaviors(xkb, rep, desc, client);
    if (rep->virtualMods) {
        register int sz, bit;

        for (i = sz = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) {
            if (rep->virtualMods & bit) {
                desc[sz++] = xkb->server->vmods[i];
            }
        }
        desc += XkbPaddedSize(sz);
    }
    if (rep->totalKeyExplicit > 0)
        desc = XkbWriteExplicit(xkb, rep, desc, client);
    if (rep->totalModMapKeys > 0)
        desc = XkbWriteModifierMap(xkb, rep, desc, client);
    if (rep->totalVModMapKeys > 0)
        desc = XkbWriteVirtualModMap(xkb, rep, desc, client);
    if ((desc - start) != (len)) {
        ErrorF
            ("[xkb] BOGUS LENGTH in write keyboard desc, expected %d, got %ld\n",
             len, (unsigned long) (desc - start));
    }
    if (client->swapped) {
        swaps(&rep->sequenceNumber);
        swapl(&rep->length);
        swaps(&rep->present);
        swaps(&rep->totalSyms);
        swaps(&rep->totalActs);
    }
    WriteToClient(client, (i = SIZEOF(xkbGetMapReply)), rep);
    WriteToClient(client, len, start);
    free((char *) start);
    return Success;
}

int
ProcXkbGetMap(ClientPtr client)
{
    DeviceIntPtr dev;
    xkbGetMapReply rep;
    XkbDescRec *xkb;
    int n, status;

    REQUEST(xkbGetMapReq);
    REQUEST_SIZE_MATCH(xkbGetMapReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
    CHK_MASK_OVERLAP(0x01, stuff->full, stuff->partial);
    CHK_MASK_LEGAL(0x02, stuff->full, XkbAllMapComponentsMask);
    CHK_MASK_LEGAL(0x03, stuff->partial, XkbAllMapComponentsMask);

    xkb = dev->key->xkbInfo->desc;
    rep = (xkbGetMapReply) {
        .type = X_Reply,
        .deviceID = dev->id,
        .sequenceNumber = client->sequence,
        .length = (SIZEOF(xkbGetMapReply) - SIZEOF(xGenericReply)) >> 2,
        .present = stuff->partial | stuff->full,
        .minKeyCode = xkb->min_key_code,
        .maxKeyCode = xkb->max_key_code
    };

    if (stuff->full & XkbKeyTypesMask) {
        rep.firstType = 0;
        rep.nTypes = xkb->map->num_types;
    }
    else if (stuff->partial & XkbKeyTypesMask) {
        if (((unsigned) stuff->firstType + stuff->nTypes) > xkb->map->num_types) {
            client->errorValue = _XkbErrCode4(0x04, xkb->map->num_types,
                                              stuff->firstType, stuff->nTypes);
            return BadValue;
        }
        rep.firstType = stuff->firstType;
        rep.nTypes = stuff->nTypes;
    }
    else
        rep.nTypes = 0;
    rep.totalTypes = xkb->map->num_types;

    n = XkbNumKeys(xkb);
    if (stuff->full & XkbKeySymsMask) {
        rep.firstKeySym = xkb->min_key_code;
        rep.nKeySyms = n;
    }
    else if (stuff->partial & XkbKeySymsMask) {
        CHK_KEY_RANGE(0x05, stuff->firstKeySym, stuff->nKeySyms, xkb);
        rep.firstKeySym = stuff->firstKeySym;
        rep.nKeySyms = stuff->nKeySyms;
    }
    else
        rep.nKeySyms = 0;
    rep.totalSyms = 0;

    if (stuff->full & XkbKeyActionsMask) {
        rep.firstKeyAct = xkb->min_key_code;
        rep.nKeyActs = n;
    }
    else if (stuff->partial & XkbKeyActionsMask) {
        CHK_KEY_RANGE(0x07, stuff->firstKeyAct, stuff->nKeyActs, xkb);
        rep.firstKeyAct = stuff->firstKeyAct;
        rep.nKeyActs = stuff->nKeyActs;
    }
    else
        rep.nKeyActs = 0;
    rep.totalActs = 0;

    if (stuff->full & XkbKeyBehaviorsMask) {
        rep.firstKeyBehavior = xkb->min_key_code;
        rep.nKeyBehaviors = n;
    }
    else if (stuff->partial & XkbKeyBehaviorsMask) {
        CHK_KEY_RANGE(0x09, stuff->firstKeyBehavior, stuff->nKeyBehaviors, xkb);
        rep.firstKeyBehavior = stuff->firstKeyBehavior;
        rep.nKeyBehaviors = stuff->nKeyBehaviors;
    }
    else
        rep.nKeyBehaviors = 0;
    rep.totalKeyBehaviors = 0;

    if (stuff->full & XkbVirtualModsMask)
        rep.virtualMods = ~0;
    else if (stuff->partial & XkbVirtualModsMask)
        rep.virtualMods = stuff->virtualMods;

    if (stuff->full & XkbExplicitComponentsMask) {
        rep.firstKeyExplicit = xkb->min_key_code;
        rep.nKeyExplicit = n;
    }
    else if (stuff->partial & XkbExplicitComponentsMask) {
        CHK_KEY_RANGE(0x0B, stuff->firstKeyExplicit, stuff->nKeyExplicit, xkb);
        rep.firstKeyExplicit = stuff->firstKeyExplicit;
        rep.nKeyExplicit = stuff->nKeyExplicit;
    }
    else
        rep.nKeyExplicit = 0;
    rep.totalKeyExplicit = 0;

    if (stuff->full & XkbModifierMapMask) {
        rep.firstModMapKey = xkb->min_key_code;
        rep.nModMapKeys = n;
    }
    else if (stuff->partial & XkbModifierMapMask) {
        CHK_KEY_RANGE(0x0D, stuff->firstModMapKey, stuff->nModMapKeys, xkb);
        rep.firstModMapKey = stuff->firstModMapKey;
        rep.nModMapKeys = stuff->nModMapKeys;
    }
    else
        rep.nModMapKeys = 0;
    rep.totalModMapKeys = 0;

    if (stuff->full & XkbVirtualModMapMask) {
        rep.firstVModMapKey = xkb->min_key_code;
        rep.nVModMapKeys = n;
    }
    else if (stuff->partial & XkbVirtualModMapMask) {
        CHK_KEY_RANGE(0x0F, stuff->firstVModMapKey, stuff->nVModMapKeys, xkb);
        rep.firstVModMapKey = stuff->firstVModMapKey;
        rep.nVModMapKeys = stuff->nVModMapKeys;
    }
    else
        rep.nVModMapKeys = 0;
    rep.totalVModMapKeys = 0;

    if ((status = XkbComputeGetMapReplySize(xkb, &rep)) != Success)
        return status;
    return XkbSendMap(client, xkb, &rep);
}

/***====================================================================***/

static int
CheckKeyTypes(ClientPtr client,
              XkbDescPtr xkb,
              xkbSetMapReq * req,
              xkbKeyTypeWireDesc ** wireRtrn,
              int *nMapsRtrn, CARD8 *mapWidthRtrn)
{
    unsigned nMaps;
    register unsigned i, n;
    register CARD8 *map;
    register xkbKeyTypeWireDesc *wire = *wireRtrn;

    if (req->firstType > ((unsigned) xkb->map->num_types)) {
        *nMapsRtrn = _XkbErrCode3(0x01, req->firstType, xkb->map->num_types);
        return 0;
    }
    if (req->flags & XkbSetMapResizeTypes) {
        nMaps = req->firstType + req->nTypes;
        if (nMaps < XkbNumRequiredTypes) {      /* canonical types must be there */
            *nMapsRtrn = _XkbErrCode4(0x02, req->firstType, req->nTypes, 4);
            return 0;
        }
    }
    else if (req->present & XkbKeyTypesMask) {
        nMaps = xkb->map->num_types;
        if ((req->firstType + req->nTypes) > nMaps) {
            *nMapsRtrn = req->firstType + req->nTypes;
            return 0;
        }
    }
    else {
        *nMapsRtrn = xkb->map->num_types;
        for (i = 0; i < xkb->map->num_types; i++) {
            mapWidthRtrn[i] = xkb->map->types[i].num_levels;
        }
        return 1;
    }

    for (i = 0; i < req->firstType; i++) {
        mapWidthRtrn[i] = xkb->map->types[i].num_levels;
    }
    for (i = 0; i < req->nTypes; i++) {
        unsigned width;

        if (client->swapped) {
            swaps(&wire->virtualMods);
        }
        n = i + req->firstType;
        width = wire->numLevels;
        if (width < 1) {
            *nMapsRtrn = _XkbErrCode3(0x04, n, width);
            return 0;
        }
        else if ((n == XkbOneLevelIndex) && (width != 1)) {     /* must be width 1 */
            *nMapsRtrn = _XkbErrCode3(0x05, n, width);
            return 0;
        }
        else if ((width != 2) &&
                 ((n == XkbTwoLevelIndex) || (n == XkbKeypadIndex) ||
                  (n == XkbAlphabeticIndex))) {
            /* TWO_LEVEL, ALPHABETIC and KEYPAD must be width 2 */
            *nMapsRtrn = _XkbErrCode3(0x05, n, width);
            return 0;
        }
        if (wire->nMapEntries > 0) {
            xkbKTSetMapEntryWireDesc *mapWire;
            xkbModsWireDesc *preWire;

            mapWire = (xkbKTSetMapEntryWireDesc *) &wire[1];
            preWire = (xkbModsWireDesc *) &mapWire[wire->nMapEntries];
            for (n = 0; n < wire->nMapEntries; n++) {
                if (client->swapped) {
                    swaps(&mapWire[n].virtualMods);
                }
                if (mapWire[n].realMods & (~wire->realMods)) {
                    *nMapsRtrn = _XkbErrCode4(0x06, n, mapWire[n].realMods,
                                              wire->realMods);
                    return 0;
                }
                if (mapWire[n].virtualMods & (~wire->virtualMods)) {
                    *nMapsRtrn = _XkbErrCode3(0x07, n, mapWire[n].virtualMods);
                    return 0;
                }
                if (mapWire[n].level >= wire->numLevels) {
                    *nMapsRtrn = _XkbErrCode4(0x08, n, wire->numLevels,
                                              mapWire[n].level);
                    return 0;
                }
                if (wire->preserve) {
                    if (client->swapped) {
                        swaps(&preWire[n].virtualMods);
                    }
                    if (preWire[n].realMods & (~mapWire[n].realMods)) {
                        *nMapsRtrn = _XkbErrCode4(0x09, n, preWire[n].realMods,
                                                  mapWire[n].realMods);
                        return 0;
                    }
                    if (preWire[n].virtualMods & (~mapWire[n].virtualMods)) {
                        *nMapsRtrn =
                            _XkbErrCode3(0x0a, n, preWire[n].virtualMods);
                        return 0;
                    }
                }
            }
            if (wire->preserve)
                map = (CARD8 *) &preWire[wire->nMapEntries];
            else
                map = (CARD8 *) &mapWire[wire->nMapEntries];
        }
        else
            map = (CARD8 *) &wire[1];
        mapWidthRtrn[i + req->firstType] = wire->numLevels;
        wire = (xkbKeyTypeWireDesc *) map;
    }
    for (i = req->firstType + req->nTypes; i < nMaps; i++) {
        mapWidthRtrn[i] = xkb->map->types[i].num_levels;
    }
    *nMapsRtrn = nMaps;
    *wireRtrn = wire;
    return 1;
}

static int
CheckKeySyms(ClientPtr client,
             XkbDescPtr xkb,
             xkbSetMapReq * req,
             int nTypes,
             CARD8 *mapWidths,
             CARD16 *symsPerKey, xkbSymMapWireDesc ** wireRtrn, int *errorRtrn)
{
    register unsigned i;
    XkbSymMapPtr map;
    xkbSymMapWireDesc *wire = *wireRtrn;

    if (!(XkbKeySymsMask & req->present))
        return 1;
    CHK_REQ_KEY_RANGE2(0x11, req->firstKeySym, req->nKeySyms, req, (*errorRtrn),
                       0);
    for (i = 0; i < req->nKeySyms; i++) {
        KeySym *pSyms;
        register unsigned nG;

        if (client->swapped) {
            swaps(&wire->nSyms);
        }
        nG = XkbNumGroups(wire->groupInfo);
        if (nG > XkbNumKbdGroups) {
            *errorRtrn = _XkbErrCode3(0x14, i + req->firstKeySym, nG);
            return 0;
        }
        if (nG > 0) {
            register int g, w;

            for (g = w = 0; g < nG; g++) {
                if (wire->ktIndex[g] >= (unsigned) nTypes) {
                    *errorRtrn = _XkbErrCode4(0x15, i + req->firstKeySym, g,
                                              wire->ktIndex[g]);
                    return 0;
                }
                if (mapWidths[wire->ktIndex[g]] > w)
                    w = mapWidths[wire->ktIndex[g]];
            }
            if (wire->width != w) {
                *errorRtrn =
                    _XkbErrCode3(0x16, i + req->firstKeySym, wire->width);
                return 0;
            }
            w *= nG;
            symsPerKey[i + req->firstKeySym] = w;
            if (w != wire->nSyms) {
                *errorRtrn =
                    _XkbErrCode4(0x16, i + req->firstKeySym, wire->nSyms, w);
                return 0;
            }
        }
        else if (wire->nSyms != 0) {
            *errorRtrn = _XkbErrCode3(0x17, i + req->firstKeySym, wire->nSyms);
            return 0;
        }
        pSyms = (KeySym *) &wire[1];
        wire = (xkbSymMapWireDesc *) &pSyms[wire->nSyms];
    }

    map = &xkb->map->key_sym_map[i];
    for (; i <= (unsigned) xkb->max_key_code; i++, map++) {
        register int g, nG, w;

        nG = XkbKeyNumGroups(xkb, i);
        for (w = g = 0; g < nG; g++) {
            if (map->kt_index[g] >= (unsigned) nTypes) {
                *errorRtrn = _XkbErrCode4(0x18, i, g, map->kt_index[g]);
                return 0;
            }
            if (mapWidths[map->kt_index[g]] > w)
                w = mapWidths[map->kt_index[g]];
        }
        symsPerKey[i] = w * nG;
    }
    *wireRtrn = wire;
    return 1;
}

static int
CheckKeyActions(XkbDescPtr xkb,
                xkbSetMapReq * req,
                int nTypes,
                CARD8 *mapWidths,
                CARD16 *symsPerKey, CARD8 **wireRtrn, int *nActsRtrn)
{
    int nActs;
    CARD8 *wire = *wireRtrn;
    register unsigned i;

    if (!(XkbKeyActionsMask & req->present))
        return 1;
    CHK_REQ_KEY_RANGE2(0x21, req->firstKeyAct, req->nKeyActs, req, (*nActsRtrn),
                       0);
    for (nActs = i = 0; i < req->nKeyActs; i++) {
        if (wire[0] != 0) {
            if (wire[0] == symsPerKey[i + req->firstKeyAct])
                nActs += wire[0];
            else {
                *nActsRtrn = _XkbErrCode3(0x23, i + req->firstKeyAct, wire[0]);
                return 0;
            }
        }
        wire++;
    }
    if (req->nKeyActs % 4)
        wire += 4 - (req->nKeyActs % 4);
    *wireRtrn = (CARD8 *) (((XkbAnyAction *) wire) + nActs);
    *nActsRtrn = nActs;
    return 1;
}

static int
CheckKeyBehaviors(XkbDescPtr xkb,
                  xkbSetMapReq * req,
                  xkbBehaviorWireDesc ** wireRtrn, int *errorRtrn)
{
    register xkbBehaviorWireDesc *wire = *wireRtrn;
    register XkbServerMapPtr server = xkb->server;
    register unsigned i;
    unsigned first, last;

    if (((req->present & XkbKeyBehaviorsMask) == 0) || (req->nKeyBehaviors < 1)) {
        req->present &= ~XkbKeyBehaviorsMask;
        req->nKeyBehaviors = 0;
        return 1;
    }
    first = req->firstKeyBehavior;
    last = req->firstKeyBehavior + req->nKeyBehaviors - 1;
    if (first < req->minKeyCode) {
        *errorRtrn = _XkbErrCode3(0x31, first, req->minKeyCode);
        return 0;
    }
    if (last > req->maxKeyCode) {
        *errorRtrn = _XkbErrCode3(0x32, last, req->maxKeyCode);
        return 0;
    }

    for (i = 0; i < req->totalKeyBehaviors; i++, wire++) {
        if ((wire->key < first) || (wire->key > last)) {
            *errorRtrn = _XkbErrCode4(0x33, first, last, wire->key);
            return 0;
        }
        if ((wire->type & XkbKB_Permanent) &&
            ((server->behaviors[wire->key].type != wire->type) ||
             (server->behaviors[wire->key].data != wire->data))) {
            *errorRtrn = _XkbErrCode3(0x33, wire->key, wire->type);
            return 0;
        }
        if ((wire->type == XkbKB_RadioGroup) &&
            ((wire->data & (~XkbKB_RGAllowNone)) > XkbMaxRadioGroups)) {
            *errorRtrn = _XkbErrCode4(0x34, wire->key, wire->data,
                                      XkbMaxRadioGroups);
            return 0;
        }
        if ((wire->type == XkbKB_Overlay1) || (wire->type == XkbKB_Overlay2)) {
            CHK_KEY_RANGE2(0x35, wire->key, 1, xkb, *errorRtrn, 0);
        }
    }
    *wireRtrn = wire;
    return 1;
}

static int
CheckVirtualMods(XkbDescRec * xkb,
                 xkbSetMapReq * req, CARD8 **wireRtrn, int *errorRtrn)
{
    register CARD8 *wire = *wireRtrn;
    register unsigned i, nMods, bit;

    if (((req->present & XkbVirtualModsMask) == 0) || (req->virtualMods == 0))
        return 1;
    for (i = nMods = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) {
        if (req->virtualMods & bit)
            nMods++;
    }
    *wireRtrn = (wire + XkbPaddedSize(nMods));
    return 1;
}

static int
CheckKeyExplicit(XkbDescPtr xkb,
                 xkbSetMapReq * req, CARD8 **wireRtrn, int *errorRtrn)
{
    register CARD8 *wire = *wireRtrn;
    CARD8 *start;
    register unsigned i;
    int first, last;

    if (((req->present & XkbExplicitComponentsMask) == 0) ||
        (req->nKeyExplicit < 1)) {
        req->present &= ~XkbExplicitComponentsMask;
        req->nKeyExplicit = 0;
        return 1;
    }
    first = req->firstKeyExplicit;
    last = first + req->nKeyExplicit - 1;
    if (first < req->minKeyCode) {
        *errorRtrn = _XkbErrCode3(0x51, first, req->minKeyCode);
        return 0;
    }
    if (last > req->maxKeyCode) {
        *errorRtrn = _XkbErrCode3(0x52, last, req->maxKeyCode);
        return 0;
    }
    start = wire;
    for (i = 0; i < req->totalKeyExplicit; i++, wire += 2) {
        if ((wire[0] < first) || (wire[0] > last)) {
            *errorRtrn = _XkbErrCode4(0x53, first, last, wire[0]);
            return 0;
        }
        if (wire[1] & (~XkbAllExplicitMask)) {
            *errorRtrn = _XkbErrCode3(0x52, ~XkbAllExplicitMask, wire[1]);
            return 0;
        }
    }
    wire += XkbPaddedSize(wire - start) - (wire - start);
    *wireRtrn = wire;
    return 1;
}

static int
CheckModifierMap(XkbDescPtr xkb, xkbSetMapReq * req, CARD8 **wireRtrn,
                 int *errRtrn)
{
    register CARD8 *wire = *wireRtrn;
    CARD8 *start;
    register unsigned i;
    int first, last;

    if (((req->present & XkbModifierMapMask) == 0) || (req->nModMapKeys < 1)) {
        req->present &= ~XkbModifierMapMask;
        req->nModMapKeys = 0;
        return 1;
    }
    first = req->firstModMapKey;
    last = first + req->nModMapKeys - 1;
    if (first < req->minKeyCode) {
        *errRtrn = _XkbErrCode3(0x61, first, req->minKeyCode);
        return 0;
    }
    if (last > req->maxKeyCode) {
        *errRtrn = _XkbErrCode3(0x62, last, req->maxKeyCode);
        return 0;
    }
    start = wire;
    for (i = 0; i < req->totalModMapKeys; i++, wire += 2) {
        if ((wire[0] < first) || (wire[0] > last)) {
            *errRtrn = _XkbErrCode4(0x63, first, last, wire[0]);
            return 0;
        }
    }
    wire += XkbPaddedSize(wire - start) - (wire - start);
    *wireRtrn = wire;
    return 1;
}

static int
CheckVirtualModMap(XkbDescPtr xkb,
                   xkbSetMapReq * req,
                   xkbVModMapWireDesc ** wireRtrn, int *errRtrn)
{
    register xkbVModMapWireDesc *wire = *wireRtrn;
    register unsigned i;
    int first, last;

    if (((req->present & XkbVirtualModMapMask) == 0) || (req->nVModMapKeys < 1)) {
        req->present &= ~XkbVirtualModMapMask;
        req->nVModMapKeys = 0;
        return 1;
    }
    first = req->firstVModMapKey;
    last = first + req->nVModMapKeys - 1;
    if (first < req->minKeyCode) {
        *errRtrn = _XkbErrCode3(0x71, first, req->minKeyCode);
        return 0;
    }
    if (last > req->maxKeyCode) {
        *errRtrn = _XkbErrCode3(0x72, last, req->maxKeyCode);
        return 0;
    }
    for (i = 0; i < req->totalVModMapKeys; i++, wire++) {
        if ((wire->key < first) || (wire->key > last)) {
            *errRtrn = _XkbErrCode4(0x73, first, last, wire->key);
            return 0;
        }
    }
    *wireRtrn = wire;
    return 1;
}

static char *
SetKeyTypes(XkbDescPtr xkb,
            xkbSetMapReq * req,
            xkbKeyTypeWireDesc * wire, XkbChangesPtr changes)
{
    register unsigned i;
    unsigned first, last;
    CARD8 *map;

    if ((unsigned) (req->firstType + req->nTypes) > xkb->map->size_types) {
        i = req->firstType + req->nTypes;
        if (XkbAllocClientMap(xkb, XkbKeyTypesMask, i) != Success) {
            return NULL;
        }
    }
    if ((unsigned) (req->firstType + req->nTypes) > xkb->map->num_types)
        xkb->map->num_types = req->firstType + req->nTypes;

    for (i = 0; i < req->nTypes; i++) {
        XkbKeyTypePtr pOld;
        register unsigned n;

        if (XkbResizeKeyType(xkb, i + req->firstType, wire->nMapEntries,
                             wire->preserve, wire->numLevels) != Success) {
            return NULL;
        }
        pOld = &xkb->map->types[i + req->firstType];
        map = (CARD8 *) &wire[1];

        pOld->mods.real_mods = wire->realMods;
        pOld->mods.vmods = wire->virtualMods;
        pOld->num_levels = wire->numLevels;
        pOld->map_count = wire->nMapEntries;

        pOld->mods.mask = pOld->mods.real_mods |
            XkbMaskForVMask(xkb, pOld->mods.vmods);

        if (wire->nMapEntries) {
            xkbKTSetMapEntryWireDesc *mapWire;
            xkbModsWireDesc *preWire;
            unsigned tmp;

            mapWire = (xkbKTSetMapEntryWireDesc *) map;
            preWire = (xkbModsWireDesc *) &mapWire[wire->nMapEntries];
            for (n = 0; n < wire->nMapEntries; n++) {
                pOld->map[n].active = 1;
                pOld->map[n].mods.mask = mapWire[n].realMods;
                pOld->map[n].mods.real_mods = mapWire[n].realMods;
                pOld->map[n].mods.vmods = mapWire[n].virtualMods;
                pOld->map[n].level = mapWire[n].level;
                if (mapWire[n].virtualMods != 0) {
                    tmp = XkbMaskForVMask(xkb, mapWire[n].virtualMods);
                    pOld->map[n].active = (tmp != 0);
                    pOld->map[n].mods.mask |= tmp;
                }
                if (wire->preserve) {
                    pOld->preserve[n].real_mods = preWire[n].realMods;
                    pOld->preserve[n].vmods = preWire[n].virtualMods;
                    tmp = XkbMaskForVMask(xkb, preWire[n].virtualMods);
                    pOld->preserve[n].mask = preWire[n].realMods | tmp;
                }
            }
            if (wire->preserve)
                map = (CARD8 *) &preWire[wire->nMapEntries];
            else
                map = (CARD8 *) &mapWire[wire->nMapEntries];
        }
        else
            map = (CARD8 *) &wire[1];
        wire = (xkbKeyTypeWireDesc *) map;
    }
    first = req->firstType;
    last = first + req->nTypes - 1;     /* last changed type */
    if (changes->map.changed & XkbKeyTypesMask) {
        int oldLast;

        oldLast = changes->map.first_type + changes->map.num_types - 1;
        if (changes->map.first_type < first)
            first = changes->map.first_type;
        if (oldLast > last)
            last = oldLast;
    }
    changes->map.changed |= XkbKeyTypesMask;
    changes->map.first_type = first;
    changes->map.num_types = (last - first) + 1;
    return (char *) wire;
}

static char *
SetKeySyms(ClientPtr client,
           XkbDescPtr xkb,
           xkbSetMapReq * req,
           xkbSymMapWireDesc * wire, XkbChangesPtr changes, DeviceIntPtr dev)
{
    register unsigned i, s;
    XkbSymMapPtr oldMap;
    KeySym *newSyms;
    KeySym *pSyms;
    unsigned first, last;

    oldMap = &xkb->map->key_sym_map[req->firstKeySym];
    for (i = 0; i < req->nKeySyms; i++, oldMap++) {
        pSyms = (KeySym *) &wire[1];
        if (wire->nSyms > 0) {
            newSyms = XkbResizeKeySyms(xkb, i + req->firstKeySym, wire->nSyms);
            for (s = 0; s < wire->nSyms; s++) {
                newSyms[s] = pSyms[s];
            }
            if (client->swapped) {
                for (s = 0; s < wire->nSyms; s++) {
                    swapl(&newSyms[s]);
                }
            }
        }
        oldMap->kt_index[0] = wire->ktIndex[0];
        oldMap->kt_index[1] = wire->ktIndex[1];
        oldMap->kt_index[2] = wire->ktIndex[2];
        oldMap->kt_index[3] = wire->ktIndex[3];
        oldMap->group_info = wire->groupInfo;
        oldMap->width = wire->width;
        wire = (xkbSymMapWireDesc *) &pSyms[wire->nSyms];
    }
    first = req->firstKeySym;
    last = first + req->nKeySyms - 1;
    if (changes->map.changed & XkbKeySymsMask) {
        int oldLast =
            (changes->map.first_key_sym + changes->map.num_key_syms - 1);
        if (changes->map.first_key_sym < first)
            first = changes->map.first_key_sym;
        if (oldLast > last)
            last = oldLast;
    }
    changes->map.changed |= XkbKeySymsMask;
    changes->map.first_key_sym = first;
    changes->map.num_key_syms = (last - first + 1);

    s = 0;
    for (i = xkb->min_key_code; i <= xkb->max_key_code; i++) {
        if (XkbKeyNumGroups(xkb, i) > s)
            s = XkbKeyNumGroups(xkb, i);
    }
    if (s != xkb->ctrls->num_groups) {
        xkbControlsNotify cn;
        XkbControlsRec old;

        cn.keycode = 0;
        cn.eventType = 0;
        cn.requestMajor = XkbReqCode;
        cn.requestMinor = X_kbSetMap;
        old = *xkb->ctrls;
        xkb->ctrls->num_groups = s;
        if (XkbComputeControlsNotify(dev, &old, xkb->ctrls, &cn, FALSE))
            XkbSendControlsNotify(dev, &cn);
    }
    return (char *) wire;
}

static char *
SetKeyActions(XkbDescPtr xkb,
              xkbSetMapReq * req, CARD8 *wire, XkbChangesPtr changes)
{
    register unsigned i, first, last;
    CARD8 *nActs = wire;
    XkbAction *newActs;

    wire += XkbPaddedSize(req->nKeyActs);
    for (i = 0; i < req->nKeyActs; i++) {
        if (nActs[i] == 0)
            xkb->server->key_acts[i + req->firstKeyAct] = 0;
        else {
            newActs = XkbResizeKeyActions(xkb, i + req->firstKeyAct, nActs[i]);
            memcpy((char *) newActs, (char *) wire,
                   nActs[i] * SIZEOF(xkbActionWireDesc));
            wire += nActs[i] * SIZEOF(xkbActionWireDesc);
        }
    }
    first = req->firstKeyAct;
    last = (first + req->nKeyActs - 1);
    if (changes->map.changed & XkbKeyActionsMask) {
        int oldLast;

        oldLast = changes->map.first_key_act + changes->map.num_key_acts - 1;
        if (changes->map.first_key_act < first)
            first = changes->map.first_key_act;
        if (oldLast > last)
            last = oldLast;
    }
    changes->map.changed |= XkbKeyActionsMask;
    changes->map.first_key_act = first;
    changes->map.num_key_acts = (last - first + 1);
    return (char *) wire;
}

static char *
SetKeyBehaviors(XkbSrvInfoPtr xkbi,
                xkbSetMapReq * req,
                xkbBehaviorWireDesc * wire, XkbChangesPtr changes)
{
    register unsigned i;
    int maxRG = -1;
    XkbDescPtr xkb = xkbi->desc;
    XkbServerMapPtr server = xkb->server;
    unsigned first, last;

    first = req->firstKeyBehavior;
    last = req->firstKeyBehavior + req->nKeyBehaviors - 1;
    memset(&server->behaviors[first], 0,
           req->nKeyBehaviors * sizeof(XkbBehavior));
    for (i = 0; i < req->totalKeyBehaviors; i++) {
        if ((server->behaviors[wire->key].type & XkbKB_Permanent) == 0) {
            server->behaviors[wire->key].type = wire->type;
            server->behaviors[wire->key].data = wire->data;
            if ((wire->type == XkbKB_RadioGroup) &&
                (((int) wire->data) > maxRG))
                maxRG = wire->data + 1;
        }
        wire++;
    }

    if (maxRG > (int) xkbi->nRadioGroups) {
        if (xkbi->radioGroups)
            xkbi->radioGroups = reallocarray(xkbi->radioGroups, maxRG,
                                             sizeof(XkbRadioGroupRec));
        else
            xkbi->radioGroups = calloc(maxRG, sizeof(XkbRadioGroupRec));
        if (xkbi->radioGroups) {
            if (xkbi->nRadioGroups)
                memset(&xkbi->radioGroups[xkbi->nRadioGroups], 0,
                       (maxRG - xkbi->nRadioGroups) * sizeof(XkbRadioGroupRec));
            xkbi->nRadioGroups = maxRG;
        }
        else
            xkbi->nRadioGroups = 0;
        /* should compute members here */
    }
    if (changes->map.changed & XkbKeyBehaviorsMask) {
        unsigned oldLast;

        oldLast = changes->map.first_key_behavior +
            changes->map.num_key_behaviors - 1;
        if (changes->map.first_key_behavior < req->firstKeyBehavior)
            first = changes->map.first_key_behavior;
        if (oldLast > last)
            last = oldLast;
    }
    changes->map.changed |= XkbKeyBehaviorsMask;
    changes->map.first_key_behavior = first;
    changes->map.num_key_behaviors = (last - first + 1);
    return (char *) wire;
}

static char *
SetVirtualMods(XkbSrvInfoPtr xkbi, xkbSetMapReq * req, CARD8 *wire,
               XkbChangesPtr changes)
{
    register int i, bit, nMods;
    XkbServerMapPtr srv = xkbi->desc->server;

    if (((req->present & XkbVirtualModsMask) == 0) || (req->virtualMods == 0))
        return (char *) wire;
    for (i = nMods = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) {
        if (req->virtualMods & bit) {
            if (srv->vmods[i] != wire[nMods]) {
                changes->map.changed |= XkbVirtualModsMask;
                changes->map.vmods |= bit;
                srv->vmods[i] = wire[nMods];
            }
            nMods++;
        }
    }
    return (char *) (wire + XkbPaddedSize(nMods));
}

static char *
SetKeyExplicit(XkbSrvInfoPtr xkbi, xkbSetMapReq * req, CARD8 *wire,
               XkbChangesPtr changes)
{
    register unsigned i, first, last;
    XkbServerMapPtr xkb = xkbi->desc->server;
    CARD8 *start;

    start = wire;
    first = req->firstKeyExplicit;
    last = req->firstKeyExplicit + req->nKeyExplicit - 1;
    memset(&xkb->explicit[first], 0, req->nKeyExplicit);
    for (i = 0; i < req->totalKeyExplicit; i++, wire += 2) {
        xkb->explicit[wire[0]] = wire[1];
    }
    if (first > 0) {
        if (changes->map.changed & XkbExplicitComponentsMask) {
            int oldLast;

            oldLast = changes->map.first_key_explicit +
                changes->map.num_key_explicit - 1;
            if (changes->map.first_key_explicit < first)
                first = changes->map.first_key_explicit;
            if (oldLast > last)
                last = oldLast;
        }
        changes->map.first_key_explicit = first;
        changes->map.num_key_explicit = (last - first) + 1;
    }
    wire += XkbPaddedSize(wire - start) - (wire - start);
    return (char *) wire;
}

static char *
SetModifierMap(XkbSrvInfoPtr xkbi,
               xkbSetMapReq * req, CARD8 *wire, XkbChangesPtr changes)
{
    register unsigned i, first, last;
    XkbClientMapPtr xkb = xkbi->desc->map;
    CARD8 *start;

    start = wire;
    first = req->firstModMapKey;
    last = req->firstModMapKey + req->nModMapKeys - 1;
    memset(&xkb->modmap[first], 0, req->nModMapKeys);
    for (i = 0; i < req->totalModMapKeys; i++, wire += 2) {
        xkb->modmap[wire[0]] = wire[1];
    }
    if (first > 0) {
        if (changes->map.changed & XkbModifierMapMask) {
            int oldLast;

            oldLast = changes->map.first_modmap_key +
                changes->map.num_modmap_keys - 1;
            if (changes->map.first_modmap_key < first)
                first = changes->map.first_modmap_key;
            if (oldLast > last)
                last = oldLast;
        }
        changes->map.first_modmap_key = first;
        changes->map.num_modmap_keys = (last - first) + 1;
    }
    wire += XkbPaddedSize(wire - start) - (wire - start);
    return (char *) wire;
}

static char *
SetVirtualModMap(XkbSrvInfoPtr xkbi,
                 xkbSetMapReq * req,
                 xkbVModMapWireDesc * wire, XkbChangesPtr changes)
{
    register unsigned i, first, last;
    XkbServerMapPtr srv = xkbi->desc->server;

    first = req->firstVModMapKey;
    last = req->firstVModMapKey + req->nVModMapKeys - 1;
    memset(&srv->vmodmap[first], 0, req->nVModMapKeys * sizeof(unsigned short));
    for (i = 0; i < req->totalVModMapKeys; i++, wire++) {
        srv->vmodmap[wire->key] = wire->vmods;
    }
    if (first > 0) {
        if (changes->map.changed & XkbVirtualModMapMask) {
            int oldLast;

            oldLast = changes->map.first_vmodmap_key +
                changes->map.num_vmodmap_keys - 1;
            if (changes->map.first_vmodmap_key < first)
                first = changes->map.first_vmodmap_key;
            if (oldLast > last)
                last = oldLast;
        }
        changes->map.first_vmodmap_key = first;
        changes->map.num_vmodmap_keys = (last - first) + 1;
    }
    return (char *) wire;
}

/**
 * Check if the given request can be applied to the given device but don't
 * actually do anything..
 */
static int
_XkbSetMapChecks(ClientPtr client, DeviceIntPtr dev, xkbSetMapReq * req,
                 char *values)
{
    XkbSrvInfoPtr xkbi;
    XkbDescPtr xkb;
    int error;
    int nTypes = 0, nActions;
    CARD8 mapWidths[XkbMaxLegalKeyCode + 1] = { 0 };
    CARD16 symsPerKey[XkbMaxLegalKeyCode + 1] = { 0 };
    XkbSymMapPtr map;
    int i;

    xkbi = dev->key->xkbInfo;
    xkb = xkbi->desc;

    if ((xkb->min_key_code != req->minKeyCode) ||
        (xkb->max_key_code != req->maxKeyCode)) {
        if (client->vMajor != 1) {      /* pre 1.0 versions of Xlib have a bug */
            req->minKeyCode = xkb->min_key_code;
            req->maxKeyCode = xkb->max_key_code;
        }
        else {
            if (!XkbIsLegalKeycode(req->minKeyCode)) {
                client->errorValue =
                    _XkbErrCode3(2, req->minKeyCode, req->maxKeyCode);
                return BadValue;
            }
            if (req->minKeyCode > req->maxKeyCode) {
                client->errorValue =
                    _XkbErrCode3(3, req->minKeyCode, req->maxKeyCode);
                return BadMatch;
            }
        }
    }

    if ((req->present & XkbKeyTypesMask) &&
        (!CheckKeyTypes(client, xkb, req, (xkbKeyTypeWireDesc **) &values,
                        &nTypes, mapWidths))) {
        client->errorValue = nTypes;
        return BadValue;
    }

    /* symsPerKey/mapWidths must be filled regardless of client-side flags */
    map = &xkb->map->key_sym_map[xkb->min_key_code];
    for (i = xkb->min_key_code; i < xkb->max_key_code; i++, map++) {
        register int g, ng, w;

        ng = XkbNumGroups(map->group_info);
        for (w = g = 0; g < ng; g++) {
            if (map->kt_index[g] >= (unsigned) nTypes) {
                client->errorValue = _XkbErrCode4(0x13, i, g, map->kt_index[g]);
                return 0;
            }
            if (mapWidths[map->kt_index[g]] > w)
                w = mapWidths[map->kt_index[g]];
        }
        symsPerKey[i] = w * ng;
    }

    if ((req->present & XkbKeySymsMask) &&
        (!CheckKeySyms(client, xkb, req, nTypes, mapWidths, symsPerKey,
                       (xkbSymMapWireDesc **) &values, &error))) {
        client->errorValue = error;
        return BadValue;
    }

    if ((req->present & XkbKeyActionsMask) &&
        (!CheckKeyActions(xkb, req, nTypes, mapWidths, symsPerKey,
                          (CARD8 **) &values, &nActions))) {
        client->errorValue = nActions;
        return BadValue;
    }

    if ((req->present & XkbKeyBehaviorsMask) &&
        (!CheckKeyBehaviors
         (xkb, req, (xkbBehaviorWireDesc **) &values, &error))) {
        client->errorValue = error;
        return BadValue;
    }

    if ((req->present & XkbVirtualModsMask) &&
        (!CheckVirtualMods(xkb, req, (CARD8 **) &values, &error))) {
        client->errorValue = error;
        return BadValue;
    }
    if ((req->present & XkbExplicitComponentsMask) &&
        (!CheckKeyExplicit(xkb, req, (CARD8 **) &values, &error))) {
        client->errorValue = error;
        return BadValue;
    }
    if ((req->present & XkbModifierMapMask) &&
        (!CheckModifierMap(xkb, req, (CARD8 **) &values, &error))) {
        client->errorValue = error;
        return BadValue;
    }
    if ((req->present & XkbVirtualModMapMask) &&
        (!CheckVirtualModMap
         (xkb, req, (xkbVModMapWireDesc **) &values, &error))) {
        client->errorValue = error;
        return BadValue;
    }

    if (((values - ((char *) req)) / 4) != req->length) {
        ErrorF("[xkb] Internal error! Bad length in XkbSetMap (after check)\n");
        client->errorValue = values - ((char *) &req[1]);
        return BadLength;
    }

    return Success;
}

/**
 * Apply the given request on the given device.
 */
static int
_XkbSetMap(ClientPtr client, DeviceIntPtr dev, xkbSetMapReq * req, char *values)
{
    XkbEventCauseRec cause;
    XkbChangesRec change;
    Bool sentNKN;
    XkbSrvInfoPtr xkbi;
    XkbDescPtr xkb;

    xkbi = dev->key->xkbInfo;
    xkb = xkbi->desc;

    XkbSetCauseXkbReq(&cause, X_kbSetMap, client);
    memset(&change, 0, sizeof(change));
    sentNKN = FALSE;
    if ((xkb->min_key_code != req->minKeyCode) ||
        (xkb->max_key_code != req->maxKeyCode)) {
        Status status;
        xkbNewKeyboardNotify nkn;

        nkn.deviceID = nkn.oldDeviceID = dev->id;
        nkn.oldMinKeyCode = xkb->min_key_code;
        nkn.oldMaxKeyCode = xkb->max_key_code;
        status = XkbChangeKeycodeRange(xkb, req->minKeyCode,
                                       req->maxKeyCode, &change);
        if (status != Success)
            return status;      /* oh-oh. what about the other keyboards? */
        nkn.minKeyCode = xkb->min_key_code;
        nkn.maxKeyCode = xkb->max_key_code;
        nkn.requestMajor = XkbReqCode;
        nkn.requestMinor = X_kbSetMap;
        nkn.changed = XkbNKN_KeycodesMask;
        XkbSendNewKeyboardNotify(dev, &nkn);
        sentNKN = TRUE;
    }

    if (req->present & XkbKeyTypesMask) {
        values = SetKeyTypes(xkb, req, (xkbKeyTypeWireDesc *) values, &change);
        if (!values)
            goto allocFailure;
    }
    if (req->present & XkbKeySymsMask) {
        values =
            SetKeySyms(client, xkb, req, (xkbSymMapWireDesc *) values, &change,
                       dev);
        if (!values)
            goto allocFailure;
    }
    if (req->present & XkbKeyActionsMask) {
        values = SetKeyActions(xkb, req, (CARD8 *) values, &change);
        if (!values)
            goto allocFailure;
    }
    if (req->present & XkbKeyBehaviorsMask) {
        values =
            SetKeyBehaviors(xkbi, req, (xkbBehaviorWireDesc *) values, &change);
        if (!values)
            goto allocFailure;
    }
    if (req->present & XkbVirtualModsMask)
        values = SetVirtualMods(xkbi, req, (CARD8 *) values, &change);
    if (req->present & XkbExplicitComponentsMask)
        values = SetKeyExplicit(xkbi, req, (CARD8 *) values, &change);
    if (req->present & XkbModifierMapMask)
        values = SetModifierMap(xkbi, req, (CARD8 *) values, &change);
    if (req->present & XkbVirtualModMapMask)
        values =
            SetVirtualModMap(xkbi, req, (xkbVModMapWireDesc *) values, &change);
    if (((values - ((char *) req)) / 4) != req->length) {
        ErrorF("[xkb] Internal error! Bad length in XkbSetMap (after set)\n");
        client->errorValue = values - ((char *) &req[1]);
        return BadLength;
    }
    if (req->flags & XkbSetMapRecomputeActions) {
        KeyCode first, last, firstMM, lastMM;

        if (change.map.num_key_syms > 0) {
            first = change.map.first_key_sym;
            last = first + change.map.num_key_syms - 1;
        }
        else
            first = last = 0;
        if (change.map.num_modmap_keys > 0) {
            firstMM = change.map.first_modmap_key;
            lastMM = first + change.map.num_modmap_keys - 1;
        }
        else
            firstMM = lastMM = 0;
        if ((last > 0) && (lastMM > 0)) {
            if (firstMM < first)
                first = firstMM;
            if (lastMM > last)
                last = lastMM;
        }
        else if (lastMM > 0) {
            first = firstMM;
            last = lastMM;
        }
        if (last > 0) {
            unsigned check = 0;

            XkbUpdateActions(dev, first, (last - first + 1), &change, &check,
                             &cause);
            if (check)
                XkbCheckSecondaryEffects(xkbi, check, &change, &cause);
        }
    }
    if (!sentNKN)
        XkbSendNotification(dev, &change, &cause);

    return Success;
 allocFailure:
    return BadAlloc;
}

int
ProcXkbSetMap(ClientPtr client)
{
    DeviceIntPtr dev;
    char *tmp;
    int rc;

    REQUEST(xkbSetMapReq);
    REQUEST_AT_LEAST_SIZE(xkbSetMapReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
    CHK_MASK_LEGAL(0x01, stuff->present, XkbAllMapComponentsMask);

    tmp = (char *) &stuff[1];

    /* Check if we can to the SetMap on the requested device. If this
       succeeds, do the same thing for all extension devices (if needed).
       If any of them fails, fail.  */
    rc = _XkbSetMapChecks(client, dev, stuff, tmp);

    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd) {
        DeviceIntPtr other;

        for (other = inputInfo.devices; other; other = other->next) {
            if ((other != dev) && other->key && !IsMaster(other) &&
                GetMaster(other, MASTER_KEYBOARD) == dev) {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other,
                              DixManageAccess);
                if (rc == Success) {
                    rc = _XkbSetMapChecks(client, other, stuff, tmp);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    /* We know now that we will succed with the SetMap. In theory anyway. */
    rc = _XkbSetMap(client, dev, stuff, tmp);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd) {
        DeviceIntPtr other;

        for (other = inputInfo.devices; other; other = other->next) {
            if ((other != dev) && other->key && !IsMaster(other) &&
                GetMaster(other, MASTER_KEYBOARD) == dev) {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other,
                              DixManageAccess);
                if (rc == Success)
                    _XkbSetMap(client, other, stuff, tmp);
                /* ignore rc. if the SetMap failed although the check above
                   reported true there isn't much we can do. we still need to
                   set all other devices, hoping that at least they stay in
                   sync. */
            }
        }
    }

    return Success;
}

/***====================================================================***/

static Status
XkbComputeGetCompatMapReplySize(XkbCompatMapPtr compat,
                                xkbGetCompatMapReply * rep)
{
    unsigned size, nGroups;

    nGroups = 0;
    if (rep->groups != 0) {
        register int i, bit;

        for (i = 0, bit = 1; i < XkbNumKbdGroups; i++, bit <<= 1) {
            if (rep->groups & bit)
                nGroups++;
        }
    }
    size = nGroups * SIZEOF(xkbModsWireDesc);
    size += (rep->nSI * SIZEOF(xkbSymInterpretWireDesc));
    rep->length = size / 4;
    return Success;
}

static int
XkbSendCompatMap(ClientPtr client,
                 XkbCompatMapPtr compat, xkbGetCompatMapReply * rep)
{
    char *data;
    int size;

    if (rep->length > 0) {
        data = xallocarray(rep->length, 4);
        if (data) {
            register unsigned i, bit;
            xkbModsWireDesc *grp;
            XkbSymInterpretPtr sym = &compat->sym_interpret[rep->firstSI];
            xkbSymInterpretWireDesc *wire = (xkbSymInterpretWireDesc *) data;

            size = rep->length * 4;

            for (i = 0; i < rep->nSI; i++, sym++, wire++) {
                wire->sym = sym->sym;
                wire->mods = sym->mods;
                wire->match = sym->match;
                wire->virtualMod = sym->virtual_mod;
                wire->flags = sym->flags;
                memcpy((char *) &wire->act, (char *) &sym->act,
                       sz_xkbActionWireDesc);
                if (client->swapped) {
                    swapl(&wire->sym);
                }
            }
            if (rep->groups) {
                grp = (xkbModsWireDesc *) wire;
                for (i = 0, bit = 1; i < XkbNumKbdGroups; i++, bit <<= 1) {
                    if (rep->groups & bit) {
                        grp->mask = compat->groups[i].mask;
                        grp->realMods = compat->groups[i].real_mods;
                        grp->virtualMods = compat->groups[i].vmods;
                        if (client->swapped) {
                            swaps(&grp->virtualMods);
                        }
                        grp++;
                    }
                }
                wire = (xkbSymInterpretWireDesc *) grp;
            }
        }
        else
            return BadAlloc;
    }
    else
        data = NULL;

    if (client->swapped) {
        swaps(&rep->sequenceNumber);
        swapl(&rep->length);
        swaps(&rep->firstSI);
        swaps(&rep->nSI);
        swaps(&rep->nTotalSI);
    }

    WriteToClient(client, SIZEOF(xkbGetCompatMapReply), rep);
    if (data) {
        WriteToClient(client, size, data);
        free((char *) data);
    }
    return Success;
}

int
ProcXkbGetCompatMap(ClientPtr client)
{
    xkbGetCompatMapReply rep;
    DeviceIntPtr dev;
    XkbDescPtr xkb;
    XkbCompatMapPtr compat;

    REQUEST(xkbGetCompatMapReq);
    REQUEST_SIZE_MATCH(xkbGetCompatMapReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);

    xkb = dev->key->xkbInfo->desc;
    compat = xkb->compat;

    rep = (xkbGetCompatMapReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .deviceID = dev->id,
        .firstSI = stuff->firstSI,
        .nSI = stuff->nSI
    };
    if (stuff->getAllSI) {
        rep.firstSI = 0;
        rep.nSI = compat->num_si;
    }
    else if ((((unsigned) stuff->nSI) > 0) &&
             ((unsigned) (stuff->firstSI + stuff->nSI - 1) >= compat->num_si)) {
        client->errorValue = _XkbErrCode2(0x05, compat->num_si);
        return BadValue;
    }
    rep.nTotalSI = compat->num_si;
    rep.groups = stuff->groups;
    XkbComputeGetCompatMapReplySize(compat, &rep);
    return XkbSendCompatMap(client, compat, &rep);
}

/**
 * Apply the given request on the given device.
 * If dryRun is TRUE, then value checks are performed, but the device isn't
 * modified.
 */
static int
_XkbSetCompatMap(ClientPtr client, DeviceIntPtr dev,
                 xkbSetCompatMapReq * req, char *data, BOOL dryRun)
{
    XkbSrvInfoPtr xkbi;
    XkbDescPtr xkb;
    XkbCompatMapPtr compat;
    int nGroups;
    unsigned i, bit;

    xkbi = dev->key->xkbInfo;
    xkb = xkbi->desc;
    compat = xkb->compat;

    if ((req->nSI > 0) || (req->truncateSI)) {
        xkbSymInterpretWireDesc *wire;

        if (req->firstSI > compat->num_si) {
            client->errorValue = _XkbErrCode2(0x02, compat->num_si);
            return BadValue;
        }
        wire = (xkbSymInterpretWireDesc *) data;
        wire += req->nSI;
        data = (char *) wire;
    }

    nGroups = 0;
    if (req->groups != 0) {
        for (i = 0, bit = 1; i < XkbNumKbdGroups; i++, bit <<= 1) {
            if (req->groups & bit)
                nGroups++;
        }
    }
    data += nGroups * SIZEOF(xkbModsWireDesc);
    if (((data - ((char *) req)) / 4) != req->length) {
        return BadLength;
    }

    /* Done all the checks we can do */
    if (dryRun)
        return Success;

    data = (char *) &req[1];
    if (req->nSI > 0) {
        xkbSymInterpretWireDesc *wire = (xkbSymInterpretWireDesc *) data;
        XkbSymInterpretPtr sym;
        unsigned int skipped = 0;

        if ((unsigned) (req->firstSI + req->nSI) > compat->num_si) {
            compat->num_si = req->firstSI + req->nSI;
            compat->sym_interpret = reallocarray(compat->sym_interpret,
                                                 compat->num_si,
                                                 sizeof(XkbSymInterpretRec));
            if (!compat->sym_interpret) {
                compat->num_si = 0;
                return BadAlloc;
            }
        }
        else if (req->truncateSI) {
            compat->num_si = req->firstSI + req->nSI;
        }
        sym = &compat->sym_interpret[req->firstSI];
        for (i = 0; i < req->nSI; i++, wire++) {
            if (client->swapped) {
                swapl(&wire->sym);
            }
            if (wire->sym == NoSymbol && wire->match == XkbSI_AnyOfOrNone &&
                (wire->mods & 0xff) == 0xff &&
                wire->act.type == XkbSA_XFree86Private) {
                ErrorF("XKB: Skipping broken Any+AnyOfOrNone(All) -> Private "
                       "action from client\n");
                skipped++;
                continue;
            }
            sym->sym = wire->sym;
            sym->mods = wire->mods;
            sym->match = wire->match;
            sym->flags = wire->flags;
            sym->virtual_mod = wire->virtualMod;
            memcpy((char *) &sym->act, (char *) &wire->act,
                   SIZEOF(xkbActionWireDesc));
            sym++;
        }
        if (skipped) {
            if (req->firstSI + req->nSI < compat->num_si)
                memmove(sym, sym + skipped,
                        (compat->num_si - req->firstSI - req->nSI) *
                        sizeof(*sym));
            compat->num_si -= skipped;
        }
        data = (char *) wire;
    }
    else if (req->truncateSI) {
        compat->num_si = req->firstSI;
    }

    if (req->groups != 0) {
        xkbModsWireDesc *wire = (xkbModsWireDesc *) data;

        for (i = 0, bit = 1; i < XkbNumKbdGroups; i++, bit <<= 1) {
            if (req->groups & bit) {
                if (client->swapped) {
                    swaps(&wire->virtualMods);
                }
                compat->groups[i].mask = wire->realMods;
                compat->groups[i].real_mods = wire->realMods;
                compat->groups[i].vmods = wire->virtualMods;
                if (wire->virtualMods != 0) {
                    unsigned tmp;

                    tmp = XkbMaskForVMask(xkb, wire->virtualMods);
                    compat->groups[i].mask |= tmp;
                }
                data += SIZEOF(xkbModsWireDesc);
                wire = (xkbModsWireDesc *) data;
            }
        }
    }
    i = XkbPaddedSize((data - ((char *) req)));
    if ((i / 4) != req->length) {
        ErrorF("[xkb] Internal length error on read in _XkbSetCompatMap\n");
        return BadLength;
    }

    if (dev->xkb_interest) {
        xkbCompatMapNotify ev;

        ev.deviceID = dev->id;
        ev.changedGroups = req->groups;
        ev.firstSI = req->firstSI;
        ev.nSI = req->nSI;
        ev.nTotalSI = compat->num_si;
        XkbSendCompatMapNotify(dev, &ev);
    }

    if (req->recomputeActions) {
        XkbChangesRec change;
        unsigned check;
        XkbEventCauseRec cause;

        XkbSetCauseXkbReq(&cause, X_kbSetCompatMap, client);
        memset(&change, 0, sizeof(XkbChangesRec));
        XkbUpdateActions(dev, xkb->min_key_code, XkbNumKeys(xkb), &change,
                         &check, &cause);
        if (check)
            XkbCheckSecondaryEffects(xkbi, check, &change, &cause);
        XkbSendNotification(dev, &change, &cause);
    }
    return Success;
}

int
ProcXkbSetCompatMap(ClientPtr client)
{
    DeviceIntPtr dev;
    char *data;
    int rc;

    REQUEST(xkbSetCompatMapReq);
    REQUEST_AT_LEAST_SIZE(xkbSetCompatMapReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);

    data = (char *) &stuff[1];

    /* check first using a dry-run */
    rc = _XkbSetCompatMap(client, dev, stuff, data, TRUE);
    if (rc != Success)
        return rc;
    if (stuff->deviceSpec == XkbUseCoreKbd) {
        DeviceIntPtr other;

        for (other = inputInfo.devices; other; other = other->next) {
            if ((other != dev) && other->key && !IsMaster(other) &&
                GetMaster(other, MASTER_KEYBOARD) == dev) {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other,
                              DixManageAccess);
                if (rc == Success) {
                    /* dry-run */
                    rc = _XkbSetCompatMap(client, other, stuff, data, TRUE);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    /* Yay, the dry-runs succeed. Let's apply */
    rc = _XkbSetCompatMap(client, dev, stuff, data, FALSE);
    if (rc != Success)
        return rc;
    if (stuff->deviceSpec == XkbUseCoreKbd) {
        DeviceIntPtr other;

        for (other = inputInfo.devices; other; other = other->next) {
            if ((other != dev) && other->key && !IsMaster(other) &&
                GetMaster(other, MASTER_KEYBOARD) == dev) {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other,
                              DixManageAccess);
                if (rc == Success) {
                    rc = _XkbSetCompatMap(client, other, stuff, data, FALSE);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    return Success;
}

/***====================================================================***/

int
ProcXkbGetIndicatorState(ClientPtr client)
{
    xkbGetIndicatorStateReply rep;
    XkbSrvLedInfoPtr sli;
    DeviceIntPtr dev;

    REQUEST(xkbGetIndicatorStateReq);
    REQUEST_SIZE_MATCH(xkbGetIndicatorStateReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixReadAccess);

    sli = XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId,
                            XkbXI_IndicatorStateMask);
    if (!sli)
        return BadAlloc;

    rep = (xkbGetIndicatorStateReply) {
        .type = X_Reply,
        .deviceID = dev->id,
        .sequenceNumber = client->sequence,
        .length = 0,
        .state = sli->effectiveState
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.state);
    }
    WriteToClient(client, SIZEOF(xkbGetIndicatorStateReply), &rep);
    return Success;
}

/***====================================================================***/

static Status
XkbComputeGetIndicatorMapReplySize(XkbIndicatorPtr indicators,
                                   xkbGetIndicatorMapReply * rep)
{
    register int i, bit;
    int nIndicators;

    rep->realIndicators = indicators->phys_indicators;
    for (i = nIndicators = 0, bit = 1; i < XkbNumIndicators; i++, bit <<= 1) {
        if (rep->which & bit)
            nIndicators++;
    }
    rep->length = (nIndicators * SIZEOF(xkbIndicatorMapWireDesc)) / 4;
    rep->nIndicators = nIndicators;
    return Success;
}

static int
XkbSendIndicatorMap(ClientPtr client,
                    XkbIndicatorPtr indicators, xkbGetIndicatorMapReply * rep)
{
    int length;
    CARD8 *map;
    register int i;
    register unsigned bit;

    if (rep->length > 0) {
        CARD8 *to;

        to = map = xallocarray(rep->length, 4);
        if (map) {
            xkbIndicatorMapWireDesc *wire = (xkbIndicatorMapWireDesc *) to;

            length = rep->length * 4;

            for (i = 0, bit = 1; i < XkbNumIndicators; i++, bit <<= 1) {
                if (rep->which & bit) {
                    wire->flags = indicators->maps[i].flags;
                    wire->whichGroups = indicators->maps[i].which_groups;
                    wire->groups = indicators->maps[i].groups;
                    wire->whichMods = indicators->maps[i].which_mods;
                    wire->mods = indicators->maps[i].mods.mask;
                    wire->realMods = indicators->maps[i].mods.real_mods;
                    wire->virtualMods = indicators->maps[i].mods.vmods;
                    wire->ctrls = indicators->maps[i].ctrls;
                    if (client->swapped) {
                        swaps(&wire->virtualMods);
                        swapl(&wire->ctrls);
                    }
                    wire++;
                }
            }
            to = (CARD8 *) wire;
            if ((to - map) != length) {
                client->errorValue = _XkbErrCode2(0xff, length);
                free(map);
                return BadLength;
            }
        }
        else
            return BadAlloc;
    }
    else
        map = NULL;
    if (client->swapped) {
        swaps(&rep->sequenceNumber);
        swapl(&rep->length);
        swapl(&rep->which);
        swapl(&rep->realIndicators);
    }
    WriteToClient(client, SIZEOF(xkbGetIndicatorMapReply), rep);
    if (map) {
        WriteToClient(client, length, map);
        free((char *) map);
    }
    return Success;
}

int
ProcXkbGetIndicatorMap(ClientPtr client)
{
    xkbGetIndicatorMapReply rep;
    DeviceIntPtr dev;
    XkbDescPtr xkb;
    XkbIndicatorPtr leds;

    REQUEST(xkbGetIndicatorMapReq);
    REQUEST_SIZE_MATCH(xkbGetIndicatorMapReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);

    xkb = dev->key->xkbInfo->desc;
    leds = xkb->indicators;

    rep = (xkbGetIndicatorMapReply) {
        .type = X_Reply,
        .deviceID = dev->id,
        .sequenceNumber = client->sequence,
        .length = 0,
        .which = stuff->which
    };
    XkbComputeGetIndicatorMapReplySize(leds, &rep);
    return XkbSendIndicatorMap(client, leds, &rep);
}

/**
 * Apply the given map to the given device. Which specifies which components
 * to apply.
 */
static int
_XkbSetIndicatorMap(ClientPtr client, DeviceIntPtr dev,
                    int which, xkbIndicatorMapWireDesc * desc)
{
    XkbSrvInfoPtr xkbi;
    XkbSrvLedInfoPtr sli;
    XkbEventCauseRec cause;
    int i, bit;

    xkbi = dev->key->xkbInfo;

    sli = XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId,
                            XkbXI_IndicatorMapsMask);
    if (!sli)
        return BadAlloc;

    for (i = 0, bit = 1; i < XkbNumIndicators; i++, bit <<= 1) {
        if (which & bit) {
            sli->maps[i].flags = desc->flags;
            sli->maps[i].which_groups = desc->whichGroups;
            sli->maps[i].groups = desc->groups;
            sli->maps[i].which_mods = desc->whichMods;
            sli->maps[i].mods.mask = desc->mods;
            sli->maps[i].mods.real_mods = desc->mods;
            sli->maps[i].mods.vmods = desc->virtualMods;
            sli->maps[i].ctrls = desc->ctrls;
            if (desc->virtualMods != 0) {
                unsigned tmp;

                tmp = XkbMaskForVMask(xkbi->desc, desc->virtualMods);
                sli->maps[i].mods.mask = desc->mods | tmp;
            }
            desc++;
        }
    }

    XkbSetCauseXkbReq(&cause, X_kbSetIndicatorMap, client);
    XkbApplyLedMapChanges(dev, sli, which, NULL, NULL, &cause);

    return Success;
}

int
ProcXkbSetIndicatorMap(ClientPtr client)
{
    int i, bit;
    int nIndicators;
    DeviceIntPtr dev;
    xkbIndicatorMapWireDesc *from;
    int rc;

    REQUEST(xkbSetIndicatorMapReq);
    REQUEST_AT_LEAST_SIZE(xkbSetIndicatorMapReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixSetAttrAccess);

    if (stuff->which == 0)
        return Success;

    for (nIndicators = i = 0, bit = 1; i < XkbNumIndicators; i++, bit <<= 1) {
        if (stuff->which & bit)
            nIndicators++;
    }
    if (stuff->length != ((SIZEOF(xkbSetIndicatorMapReq) +
                           (nIndicators * SIZEOF(xkbIndicatorMapWireDesc))) /
                          4)) {
        return BadLength;
    }

    from = (xkbIndicatorMapWireDesc *) &stuff[1];
    for (i = 0, bit = 1; i < XkbNumIndicators; i++, bit <<= 1) {
        if (stuff->which & bit) {
            if (client->swapped) {
                swaps(&from->virtualMods);
                swapl(&from->ctrls);
            }
            CHK_MASK_LEGAL(i, from->whichGroups, XkbIM_UseAnyGroup);
            CHK_MASK_LEGAL(i, from->whichMods, XkbIM_UseAnyMods);
            from++;
        }
    }

    from = (xkbIndicatorMapWireDesc *) &stuff[1];
    rc = _XkbSetIndicatorMap(client, dev, stuff->which, from);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd) {
        DeviceIntPtr other;

        for (other = inputInfo.devices; other; other = other->next) {
            if ((other != dev) && other->key && !IsMaster(other) &&
                GetMaster(other, MASTER_KEYBOARD) == dev) {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other,
                              DixSetAttrAccess);
                if (rc == Success)
                    _XkbSetIndicatorMap(client, other, stuff->which, from);
            }
        }
    }

    return Success;
}

/***====================================================================***/

int
ProcXkbGetNamedIndicator(ClientPtr client)
{
    DeviceIntPtr dev;
    xkbGetNamedIndicatorReply rep;
    register int i = 0;
    XkbSrvLedInfoPtr sli;
    XkbIndicatorMapPtr map = NULL;

    REQUEST(xkbGetNamedIndicatorReq);
    REQUEST_SIZE_MATCH(xkbGetNamedIndicatorReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_LED_DEVICE(dev, stuff->deviceSpec, client, DixReadAccess);
    CHK_ATOM_ONLY(stuff->indicator);

    sli = XkbFindSrvLedInfo(dev, stuff->ledClass, stuff->ledID, 0);
    if (!sli)
        return BadAlloc;

    i = 0;
    map = NULL;
    if ((sli->names) && (sli->maps)) {
        for (i = 0; i < XkbNumIndicators; i++) {
            if (stuff->indicator == sli->names[i]) {
                map = &sli->maps[i];
                break;
            }
        }
    }

    rep = (xkbGetNamedIndicatorReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .deviceID = dev->id,
        .indicator = stuff->indicator
    };
    if (map != NULL) {
        rep.found = TRUE;
        rep.on = ((sli->effectiveState & (1 << i)) != 0);
        rep.realIndicator = ((sli->physIndicators & (1 << i)) != 0);
        rep.ndx = i;
        rep.flags = map->flags;
        rep.whichGroups = map->which_groups;
        rep.groups = map->groups;
        rep.whichMods = map->which_mods;
        rep.mods = map->mods.mask;
        rep.realMods = map->mods.real_mods;
        rep.virtualMods = map->mods.vmods;
        rep.ctrls = map->ctrls;
        rep.supported = TRUE;
    }
    else {
        rep.found = FALSE;
        rep.on = FALSE;
        rep.realIndicator = FALSE;
        rep.ndx = XkbNoIndicator;
        rep.flags = 0;
        rep.whichGroups = 0;
        rep.groups = 0;
        rep.whichMods = 0;
        rep.mods = 0;
        rep.realMods = 0;
        rep.virtualMods = 0;
        rep.ctrls = 0;
        rep.supported = TRUE;
    }
    if (client->swapped) {
        swapl(&rep.length);
        swaps(&rep.sequenceNumber);
        swapl(&rep.indicator);
        swaps(&rep.virtualMods);
        swapl(&rep.ctrls);
    }

    WriteToClient(client, SIZEOF(xkbGetNamedIndicatorReply), &rep);
    return Success;
}

/**
 * Find the IM on the device.
 * Returns the map, or NULL if the map doesn't exist.
 * If the return value is NULL, led_return is undefined. Otherwise, led_return
 * is set to the led index of the map.
 */
static XkbIndicatorMapPtr
_XkbFindNamedIndicatorMap(XkbSrvLedInfoPtr sli, Atom indicator, int *led_return)
{
    XkbIndicatorMapPtr map;

    /* search for the right indicator */
    map = NULL;
    if (sli->names && sli->maps) {
        int led;

        for (led = 0; (led < XkbNumIndicators) && (map == NULL); led++) {
            if (sli->names[led] == indicator) {
                map = &sli->maps[led];
                *led_return = led;
                break;
            }
        }
    }

    return map;
}

/**
 * Creates an indicator map on the device. If dryRun is TRUE, it only checks
 * if creation is possible, but doesn't actually create it.
 */
static int
_XkbCreateIndicatorMap(DeviceIntPtr dev, Atom indicator,
                       int ledClass, int ledID,
                       XkbIndicatorMapPtr * map_return, int *led_return,
                       Bool dryRun)
{
    XkbSrvLedInfoPtr sli;
    XkbIndicatorMapPtr map;
    int led;

    sli = XkbFindSrvLedInfo(dev, ledClass, ledID, XkbXI_IndicatorsMask);
    if (!sli)
        return BadAlloc;

    map = _XkbFindNamedIndicatorMap(sli, indicator, &led);

    if (!map) {
        /* find first unused indicator maps and assign the name to it */
        for (led = 0, map = NULL; (led < XkbNumIndicators) && (map == NULL);
             led++) {
            if ((sli->names) && (sli->maps) && (sli->names[led] == None) &&
                (!XkbIM_InUse(&sli->maps[led]))) {
                map = &sli->maps[led];
                if (!dryRun)
                    sli->names[led] = indicator;
                break;
            }
        }
    }

    if (!map)
        return BadAlloc;

    *led_return = led;
    *map_return = map;
    return Success;
}

static int
_XkbSetNamedIndicator(ClientPtr client, DeviceIntPtr dev,
                      xkbSetNamedIndicatorReq * stuff)
{
    unsigned int extDevReason;
    unsigned int statec, namec, mapc;
    XkbSrvLedInfoPtr sli;
    int led = 0;
    XkbIndicatorMapPtr map;
    DeviceIntPtr kbd;
    XkbEventCauseRec cause;
    xkbExtensionDeviceNotify ed;
    XkbChangesRec changes;
    int rc;

    rc = _XkbCreateIndicatorMap(dev, stuff->indicator, stuff->ledClass,
                                stuff->ledID, &map, &led, FALSE);
    if (rc != Success || !map)  /* oh-oh */
        return rc;

    sli = XkbFindSrvLedInfo(dev, stuff->ledClass, stuff->ledID,
                            XkbXI_IndicatorsMask);
    if (!sli)
        return BadAlloc;

    namec = mapc = statec = 0;
    extDevReason = 0;

    namec |= (1 << led);
    sli->namesPresent |= ((stuff->indicator != None) ? (1 << led) : 0);
    extDevReason |= XkbXI_IndicatorNamesMask;

    if (stuff->setMap) {
        map->flags = stuff->flags;
        map->which_groups = stuff->whichGroups;
        map->groups = stuff->groups;
        map->which_mods = stuff->whichMods;
        map->mods.mask = stuff->realMods;
        map->mods.real_mods = stuff->realMods;
        map->mods.vmods = stuff->virtualMods;
        map->ctrls = stuff->ctrls;
        mapc |= (1 << led);
    }

    if ((stuff->setState) && ((map->flags & XkbIM_NoExplicit) == 0)) {
        if (stuff->on)
            sli->explicitState |= (1 << led);
        else
            sli->explicitState &= ~(1 << led);
        statec |= ((sli->effectiveState ^ sli->explicitState) & (1 << led));
    }

    memset((char *) &ed, 0, sizeof(xkbExtensionDeviceNotify));
    memset((char *) &changes, 0, sizeof(XkbChangesRec));
    XkbSetCauseXkbReq(&cause, X_kbSetNamedIndicator, client);
    if (namec)
        XkbApplyLedNameChanges(dev, sli, namec, &ed, &changes, &cause);
    if (mapc)
        XkbApplyLedMapChanges(dev, sli, mapc, &ed, &changes, &cause);
    if (statec)
        XkbApplyLedStateChanges(dev, sli, statec, &ed, &changes, &cause);

    kbd = dev;
    if ((sli->flags & XkbSLI_HasOwnState) == 0)
        kbd = inputInfo.keyboard;
    XkbFlushLedEvents(dev, kbd, sli, &ed, &changes, &cause);

    return Success;
}

int
ProcXkbSetNamedIndicator(ClientPtr client)
{
    int rc;
    DeviceIntPtr dev;
    int led = 0;
    XkbIndicatorMapPtr map;

    REQUEST(xkbSetNamedIndicatorReq);
    REQUEST_SIZE_MATCH(xkbSetNamedIndicatorReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_LED_DEVICE(dev, stuff->deviceSpec, client, DixSetAttrAccess);
    CHK_ATOM_ONLY(stuff->indicator);
    CHK_MASK_LEGAL(0x10, stuff->whichGroups, XkbIM_UseAnyGroup);
    CHK_MASK_LEGAL(0x11, stuff->whichMods, XkbIM_UseAnyMods);

    /* Dry-run for checks */
    rc = _XkbCreateIndicatorMap(dev, stuff->indicator,
                                stuff->ledClass, stuff->ledID,
                                &map, &led, TRUE);
    if (rc != Success || !map)  /* couldn't be created or didn't exist */
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd ||
        stuff->deviceSpec == XkbUseCorePtr) {
        DeviceIntPtr other;

        for (other = inputInfo.devices; other; other = other->next) {
            if ((other != dev) && !IsMaster(other) &&
                GetMaster(other, MASTER_KEYBOARD) == dev && (other->kbdfeed ||
                                                             other->leds) &&
                (XaceHook(XACE_DEVICE_ACCESS, client, other, DixSetAttrAccess)
                 == Success)) {
                rc = _XkbCreateIndicatorMap(other, stuff->indicator,
                                            stuff->ledClass, stuff->ledID, &map,
                                            &led, TRUE);
                if (rc != Success || !map)
                    return rc;
            }
        }
    }

    /* All checks passed, let's do it */
    rc = _XkbSetNamedIndicator(client, dev, stuff);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd ||
        stuff->deviceSpec == XkbUseCorePtr) {
        DeviceIntPtr other;

        for (other = inputInfo.devices; other; other = other->next) {
            if ((other != dev) && !IsMaster(other) &&
                GetMaster(other, MASTER_KEYBOARD) == dev && (other->kbdfeed ||
                                                             other->leds) &&
                (XaceHook(XACE_DEVICE_ACCESS, client, other, DixSetAttrAccess)
                 == Success)) {
                _XkbSetNamedIndicator(client, other, stuff);
            }
        }
    }

    return Success;
}

/***====================================================================***/

static CARD32
_XkbCountAtoms(Atom *atoms, int maxAtoms, int *count)
{
    register unsigned int i, bit, nAtoms;
    register CARD32 atomsPresent;

    for (i = nAtoms = atomsPresent = 0, bit = 1; i < maxAtoms; i++, bit <<= 1) {
        if (atoms[i] != None) {
            atomsPresent |= bit;
            nAtoms++;
        }
    }
    if (count)
        *count = nAtoms;
    return atomsPresent;
}

static char *
_XkbWriteAtoms(char *wire, Atom *atoms, int maxAtoms, int swap)
{
    register unsigned int i;
    Atom *atm;

    atm = (Atom *) wire;
    for (i = 0; i < maxAtoms; i++) {
        if (atoms[i] != None) {
            *atm = atoms[i];
            if (swap) {
                swapl(atm);
            }
            atm++;
        }
    }
    return (char *) atm;
}

static Status
XkbComputeGetNamesReplySize(XkbDescPtr xkb, xkbGetNamesReply * rep)
{
    register unsigned which, length;
    register int i;

    rep->minKeyCode = xkb->min_key_code;
    rep->maxKeyCode = xkb->max_key_code;
    which = rep->which;
    length = 0;
    if (xkb->names != NULL) {
        if (which & XkbKeycodesNameMask)
            length++;
        if (which & XkbGeometryNameMask)
            length++;
        if (which & XkbSymbolsNameMask)
            length++;
        if (which & XkbPhysSymbolsNameMask)
            length++;
        if (which & XkbTypesNameMask)
            length++;
        if (which & XkbCompatNameMask)
            length++;
    }
    else
        which &= ~XkbComponentNamesMask;

    if (xkb->map != NULL) {
        if (which & XkbKeyTypeNamesMask)
            length += xkb->map->num_types;
        rep->nTypes = xkb->map->num_types;
        if (which & XkbKTLevelNamesMask) {
            XkbKeyTypePtr pType = xkb->map->types;
            int nKTLevels = 0;

            length += XkbPaddedSize(xkb->map->num_types) / 4;
            for (i = 0; i < xkb->map->num_types; i++, pType++) {
                if (pType->level_names != NULL)
                    nKTLevels += pType->num_levels;
            }
            rep->nKTLevels = nKTLevels;
            length += nKTLevels;
        }
    }
    else {
        rep->nTypes = 0;
        rep->nKTLevels = 0;
        which &= ~(XkbKeyTypeNamesMask | XkbKTLevelNamesMask);
    }

    rep->minKeyCode = xkb->min_key_code;
    rep->maxKeyCode = xkb->max_key_code;
    rep->indicators = 0;
    rep->virtualMods = 0;
    rep->groupNames = 0;
    if (xkb->names != NULL) {
        if (which & XkbIndicatorNamesMask) {
            int nLeds;

            rep->indicators =
                _XkbCountAtoms(xkb->names->indicators, XkbNumIndicators,
                               &nLeds);
            length += nLeds;
            if (nLeds == 0)
                which &= ~XkbIndicatorNamesMask;
        }

        if (which & XkbVirtualModNamesMask) {
            int nVMods;

            rep->virtualMods =
                _XkbCountAtoms(xkb->names->vmods, XkbNumVirtualMods, &nVMods);
            length += nVMods;
            if (nVMods == 0)
                which &= ~XkbVirtualModNamesMask;
        }

        if (which & XkbGroupNamesMask) {
            int nGroups;

            rep->groupNames =
                _XkbCountAtoms(xkb->names->groups, XkbNumKbdGroups, &nGroups);
            length += nGroups;
            if (nGroups == 0)
                which &= ~XkbGroupNamesMask;
        }

        if ((which & XkbKeyNamesMask) && (xkb->names->keys))
            length += rep->nKeys;
        else
            which &= ~XkbKeyNamesMask;

        if ((which & XkbKeyAliasesMask) &&
            (xkb->names->key_aliases) && (xkb->names->num_key_aliases > 0)) {
            rep->nKeyAliases = xkb->names->num_key_aliases;
            length += rep->nKeyAliases * 2;
        }
        else {
            which &= ~XkbKeyAliasesMask;
            rep->nKeyAliases = 0;
        }

        if ((which & XkbRGNamesMask) && (xkb->names->num_rg > 0))
            length += xkb->names->num_rg;
        else
            which &= ~XkbRGNamesMask;
    }
    else {
        which &= ~(XkbIndicatorNamesMask | XkbVirtualModNamesMask);
        which &= ~(XkbGroupNamesMask | XkbKeyNamesMask | XkbKeyAliasesMask);
        which &= ~XkbRGNamesMask;
    }

    rep->length = length;
    rep->which = which;
    return Success;
}

static int
XkbSendNames(ClientPtr client, XkbDescPtr xkb, xkbGetNamesReply * rep)
{
    register unsigned i, length, which;
    char *start;
    char *desc;

    length = rep->length * 4;
    which = rep->which;
    if (client->swapped) {
        swaps(&rep->sequenceNumber);
        swapl(&rep->length);
        swapl(&rep->which);
        swaps(&rep->virtualMods);
        swapl(&rep->indicators);
    }

    start = desc = calloc(1, length);
    if (!start)
        return BadAlloc;
    if (xkb->names) {
        if (which & XkbKeycodesNameMask) {
            *((CARD32 *) desc) = xkb->names->keycodes;
            if (client->swapped) {
                swapl((int *) desc);
            }
            desc += 4;
        }
        if (which & XkbGeometryNameMask) {
            *((CARD32 *) desc) = xkb->names->geometry;
            if (client->swapped) {
                swapl((int *) desc);
            }
            desc += 4;
        }
        if (which & XkbSymbolsNameMask) {
            *((CARD32 *) desc) = xkb->names->symbols;
            if (client->swapped) {
                swapl((int *) desc);
            }
            desc += 4;
        }
        if (which & XkbPhysSymbolsNameMask) {
            register CARD32 *atm = (CARD32 *) desc;

            atm[0] = (CARD32) xkb->names->phys_symbols;
            if (client->swapped) {
                swapl(&atm[0]);
            }
            desc += 4;
        }
        if (which & XkbTypesNameMask) {
            *((CARD32 *) desc) = (CARD32) xkb->names->types;
            if (client->swapped) {
                swapl((int *) desc);
            }
            desc += 4;
        }
        if (which & XkbCompatNameMask) {
            *((CARD32 *) desc) = (CARD32) xkb->names->compat;
            if (client->swapped) {
                swapl((int *) desc);
            }
            desc += 4;
        }
        if (which & XkbKeyTypeNamesMask) {
            register CARD32 *atm = (CARD32 *) desc;
            register XkbKeyTypePtr type = xkb->map->types;

            for (i = 0; i < xkb->map->num_types; i++, atm++, type++) {
                *atm = (CARD32) type->name;
                if (client->swapped) {
                    swapl(atm);
                }
            }
            desc = (char *) atm;
        }
        if (which & XkbKTLevelNamesMask && xkb->map) {
            XkbKeyTypePtr type = xkb->map->types;
            register CARD32 *atm;

            for (i = 0; i < rep->nTypes; i++, type++) {
                *desc++ = type->num_levels;
            }
            desc += XkbPaddedSize(rep->nTypes) - rep->nTypes;

            atm = (CARD32 *) desc;
            type = xkb->map->types;
            for (i = 0; i < xkb->map->num_types; i++, type++) {
                register unsigned l;

                if (type->level_names) {
                    for (l = 0; l < type->num_levels; l++, atm++) {
                        *atm = type->level_names[l];
                        if (client->swapped) {
                            swapl(atm);
                        }
                    }
                    desc += type->num_levels * 4;
                }
            }
        }
        if (which & XkbIndicatorNamesMask) {
            desc =
                _XkbWriteAtoms(desc, xkb->names->indicators, XkbNumIndicators,
                               client->swapped);
        }
        if (which & XkbVirtualModNamesMask) {
            desc = _XkbWriteAtoms(desc, xkb->names->vmods, XkbNumVirtualMods,
                                  client->swapped);
        }
        if (which & XkbGroupNamesMask) {
            desc = _XkbWriteAtoms(desc, xkb->names->groups, XkbNumKbdGroups,
                                  client->swapped);
        }
        if (which & XkbKeyNamesMask) {
            for (i = 0; i < rep->nKeys; i++, desc += sizeof(XkbKeyNameRec)) {
                *((XkbKeyNamePtr) desc) = xkb->names->keys[i + rep->firstKey];
            }
        }
        if (which & XkbKeyAliasesMask) {
            XkbKeyAliasPtr pAl;

            pAl = xkb->names->key_aliases;
            for (i = 0; i < rep->nKeyAliases;
                 i++, pAl++, desc += 2 * XkbKeyNameLength) {
                *((XkbKeyAliasPtr) desc) = *pAl;
            }
        }
        if ((which & XkbRGNamesMask) && (rep->nRadioGroups > 0)) {
            register CARD32 *atm = (CARD32 *) desc;

            for (i = 0; i < rep->nRadioGroups; i++, atm++) {
                *atm = (CARD32) xkb->names->radio_groups[i];
                if (client->swapped) {
                    swapl(atm);
                }
            }
            desc += rep->nRadioGroups * 4;
        }
    }

    if ((desc - start) != (length)) {
        ErrorF("[xkb] BOGUS LENGTH in write names, expected %d, got %ld\n",
               length, (unsigned long) (desc - start));
    }
    WriteToClient(client, SIZEOF(xkbGetNamesReply), rep);
    WriteToClient(client, length, start);
    free((char *) start);
    return Success;
}

int
ProcXkbGetNames(ClientPtr client)
{
    DeviceIntPtr dev;
    XkbDescPtr xkb;
    xkbGetNamesReply rep;

    REQUEST(xkbGetNamesReq);
    REQUEST_SIZE_MATCH(xkbGetNamesReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
    CHK_MASK_LEGAL(0x01, stuff->which, XkbAllNamesMask);

    xkb = dev->key->xkbInfo->desc;
    rep = (xkbGetNamesReply) {
        .type = X_Reply,
        .deviceID = dev->id,
        .sequenceNumber = client->sequence,
        .length = 0,
        .which = stuff->which,
        .nTypes = xkb->map->num_types,
        .firstKey = xkb->min_key_code,
        .nKeys = XkbNumKeys(xkb),
        .nKeyAliases = xkb->names ? xkb->names->num_key_aliases : 0,
        .nRadioGroups = xkb->names ? xkb->names->num_rg : 0
    };
    XkbComputeGetNamesReplySize(xkb, &rep);
    return XkbSendNames(client, xkb, &rep);
}

/***====================================================================***/

static CARD32 *
_XkbCheckAtoms(CARD32 *wire, int nAtoms, int swapped, Atom *pError)
{
    register int i;

    for (i = 0; i < nAtoms; i++, wire++) {
        if (swapped) {
            swapl(wire);
        }
        if ((((Atom) *wire) != None) && (!ValidAtom((Atom) *wire))) {
            *pError = ((Atom) *wire);
            return NULL;
        }
    }
    return wire;
}

static CARD32 *
_XkbCheckMaskedAtoms(CARD32 *wire, int nAtoms, CARD32 present, int swapped,
                     Atom *pError)
{
    register unsigned i, bit;

    for (i = 0, bit = 1; (i < nAtoms) && (present); i++, bit <<= 1) {
        if ((present & bit) == 0)
            continue;
        if (swapped) {
            swapl(wire);
        }
        if ((((Atom) *wire) != None) && (!ValidAtom(((Atom) *wire)))) {
            *pError = (Atom) *wire;
            return NULL;
        }
        wire++;
    }
    return wire;
}

static Atom *
_XkbCopyMaskedAtoms(Atom *wire, Atom *dest, int nAtoms, CARD32 present)
{
    register int i, bit;

    for (i = 0, bit = 1; (i < nAtoms) && (present); i++, bit <<= 1) {
        if ((present & bit) == 0)
            continue;
        dest[i] = *wire++;
    }
    return wire;
}

static Bool
_XkbCheckTypeName(Atom name, int typeNdx)
{
    const char *str;

    str = NameForAtom(name);
    if ((strcmp(str, "ONE_LEVEL") == 0) || (strcmp(str, "TWO_LEVEL") == 0) ||
        (strcmp(str, "ALPHABETIC") == 0) || (strcmp(str, "KEYPAD") == 0))
        return FALSE;
    return TRUE;
}

/**
 * Check the device-dependent data in the request against the device. Returns
 * Success, or the appropriate error code.
 */
static int
_XkbSetNamesCheck(ClientPtr client, DeviceIntPtr dev,
                  xkbSetNamesReq * stuff, CARD32 *data)
{
    XkbDescRec *xkb;
    CARD32 *tmp;
    Atom bad = None;

    tmp = data;
    xkb = dev->key->xkbInfo->desc;

    if (stuff->which & XkbKeyTypeNamesMask) {
        int i;
        CARD32 *old;

        if (stuff->nTypes < 1) {
            client->errorValue = _XkbErrCode2(0x02, stuff->nTypes);
            return BadValue;
        }
        if ((unsigned) (stuff->firstType + stuff->nTypes - 1) >=
            xkb->map->num_types) {
            client->errorValue =
                _XkbErrCode4(0x03, stuff->firstType, stuff->nTypes,
                             xkb->map->num_types);
            return BadValue;
        }
        if (((unsigned) stuff->firstType) <= XkbLastRequiredType) {
            client->errorValue = _XkbErrCode2(0x04, stuff->firstType);
            return BadAccess;
        }
        old = tmp;
        tmp = _XkbCheckAtoms(tmp, stuff->nTypes, client->swapped, &bad);
        if (!tmp) {
            client->errorValue = bad;
            return BadAtom;
        }
        for (i = 0; i < stuff->nTypes; i++, old++) {
            if (!_XkbCheckTypeName((Atom) *old, stuff->firstType + i))
                client->errorValue = _XkbErrCode2(0x05, i);
        }
    }
    if (stuff->which & XkbKTLevelNamesMask) {
        unsigned i;
        XkbKeyTypePtr type;
        CARD8 *width;

        if (stuff->nKTLevels < 1) {
            client->errorValue = _XkbErrCode2(0x05, stuff->nKTLevels);
            return BadValue;
        }
        if ((unsigned) (stuff->firstKTLevel + stuff->nKTLevels - 1) >=
            xkb->map->num_types) {
            client->errorValue = _XkbErrCode4(0x06, stuff->firstKTLevel,
                                              stuff->nKTLevels,
                                              xkb->map->num_types);
            return BadValue;
        }
        width = (CARD8 *) tmp;
        tmp = (CARD32 *) (((char *) tmp) + XkbPaddedSize(stuff->nKTLevels));
        type = &xkb->map->types[stuff->firstKTLevel];
        for (i = 0; i < stuff->nKTLevels; i++, type++) {
            if (width[i] == 0)
                continue;
            else if (width[i] != type->num_levels) {
                client->errorValue = _XkbErrCode4(0x07, i + stuff->firstKTLevel,
                                                  type->num_levels, width[i]);
                return BadMatch;
            }
            tmp = _XkbCheckAtoms(tmp, width[i], client->swapped, &bad);
            if (!tmp) {
                client->errorValue = bad;
                return BadAtom;
            }
        }
    }
    if (stuff->which & XkbIndicatorNamesMask) {
        if (stuff->indicators == 0) {
            client->errorValue = 0x08;
            return BadMatch;
        }
        tmp = _XkbCheckMaskedAtoms(tmp, XkbNumIndicators, stuff->indicators,
                                   client->swapped, &bad);
        if (!tmp) {
            client->errorValue = bad;
            return BadAtom;
        }
    }
    if (stuff->which & XkbVirtualModNamesMask) {
        if (stuff->virtualMods == 0) {
            client->errorValue = 0x09;
            return BadMatch;
        }
        tmp = _XkbCheckMaskedAtoms(tmp, XkbNumVirtualMods,
                                   (CARD32) stuff->virtualMods,
                                   client->swapped, &bad);
        if (!tmp) {
            client->errorValue = bad;
            return BadAtom;
        }
    }
    if (stuff->which & XkbGroupNamesMask) {
        if (stuff->groupNames == 0) {
            client->errorValue = 0x0a;
            return BadMatch;
        }
        tmp = _XkbCheckMaskedAtoms(tmp, XkbNumKbdGroups,
                                   (CARD32) stuff->groupNames,
                                   client->swapped, &bad);
        if (!tmp) {
            client->errorValue = bad;
            return BadAtom;
        }
    }
    if (stuff->which & XkbKeyNamesMask) {
        if (stuff->firstKey < (unsigned) xkb->min_key_code) {
            client->errorValue = _XkbErrCode3(0x0b, xkb->min_key_code,
                                              stuff->firstKey);
            return BadValue;
        }
        if (((unsigned) (stuff->firstKey + stuff->nKeys - 1) >
             xkb->max_key_code) || (stuff->nKeys < 1)) {
            client->errorValue =
                _XkbErrCode4(0x0c, xkb->max_key_code, stuff->firstKey,
                             stuff->nKeys);
            return BadValue;
        }
        tmp += stuff->nKeys;
    }
    if ((stuff->which & XkbKeyAliasesMask) && (stuff->nKeyAliases > 0)) {
        tmp += stuff->nKeyAliases * 2;
    }
    if (stuff->which & XkbRGNamesMask) {
        if (stuff->nRadioGroups < 1) {
            client->errorValue = _XkbErrCode2(0x0d, stuff->nRadioGroups);
            return BadValue;
        }
        tmp = _XkbCheckAtoms(tmp, stuff->nRadioGroups, client->swapped, &bad);
        if (!tmp) {
            client->errorValue = bad;
            return BadAtom;
        }
    }
    if ((tmp - ((CARD32 *) stuff)) != stuff->length) {
        client->errorValue = stuff->length;
        return BadLength;
    }

    return Success;
}

static int
_XkbSetNames(ClientPtr client, DeviceIntPtr dev, xkbSetNamesReq * stuff)
{
    XkbDescRec *xkb;
    XkbNamesRec *names;
    CARD32 *tmp;
    xkbNamesNotify nn;

    tmp = (CARD32 *) &stuff[1];
    xkb = dev->key->xkbInfo->desc;
    names = xkb->names;

    if (XkbAllocNames(xkb, stuff->which, stuff->nRadioGroups,
                      stuff->nKeyAliases) != Success) {
        return BadAlloc;
    }

    memset(&nn, 0, sizeof(xkbNamesNotify));
    nn.changed = stuff->which;
    tmp = (CARD32 *) &stuff[1];
    if (stuff->which & XkbKeycodesNameMask)
        names->keycodes = *tmp++;
    if (stuff->which & XkbGeometryNameMask)
        names->geometry = *tmp++;
    if (stuff->which & XkbSymbolsNameMask)
        names->symbols = *tmp++;
    if (stuff->which & XkbPhysSymbolsNameMask)
        names->phys_symbols = *tmp++;
    if (stuff->which & XkbTypesNameMask)
        names->types = *tmp++;
    if (stuff->which & XkbCompatNameMask)
        names->compat = *tmp++;
    if ((stuff->which & XkbKeyTypeNamesMask) && (stuff->nTypes > 0)) {
        register unsigned i;
        register XkbKeyTypePtr type;

        type = &xkb->map->types[stuff->firstType];
        for (i = 0; i < stuff->nTypes; i++, type++) {
            type->name = *tmp++;
        }
        nn.firstType = stuff->firstType;
        nn.nTypes = stuff->nTypes;
    }
    if (stuff->which & XkbKTLevelNamesMask) {
        register XkbKeyTypePtr type;
        register unsigned i;
        CARD8 *width;

        width = (CARD8 *) tmp;
        tmp = (CARD32 *) (((char *) tmp) + XkbPaddedSize(stuff->nKTLevels));
        type = &xkb->map->types[stuff->firstKTLevel];
        for (i = 0; i < stuff->nKTLevels; i++, type++) {
            if (width[i] > 0) {
                if (type->level_names) {
                    register unsigned n;

                    for (n = 0; n < width[i]; n++) {
                        type->level_names[n] = tmp[n];
                    }
                }
                tmp += width[i];
            }
        }
        nn.firstLevelName = 0;
        nn.nLevelNames = stuff->nTypes;
    }
    if (stuff->which & XkbIndicatorNamesMask) {
        tmp = _XkbCopyMaskedAtoms(tmp, names->indicators, XkbNumIndicators,
                                  stuff->indicators);
        nn.changedIndicators = stuff->indicators;
    }
    if (stuff->which & XkbVirtualModNamesMask) {
        tmp = _XkbCopyMaskedAtoms(tmp, names->vmods, XkbNumVirtualMods,
                                  stuff->virtualMods);
        nn.changedVirtualMods = stuff->virtualMods;
    }
    if (stuff->which & XkbGroupNamesMask) {
        tmp = _XkbCopyMaskedAtoms(tmp, names->groups, XkbNumKbdGroups,
                                  stuff->groupNames);
        nn.changedVirtualMods = stuff->groupNames;
    }
    if (stuff->which & XkbKeyNamesMask) {
        memcpy((char *) &names->keys[stuff->firstKey], (char *) tmp,
               stuff->nKeys * XkbKeyNameLength);
        tmp += stuff->nKeys;
        nn.firstKey = stuff->firstKey;
        nn.nKeys = stuff->nKeys;
    }
    if (stuff->which & XkbKeyAliasesMask) {
        if (stuff->nKeyAliases > 0) {
            register int na = stuff->nKeyAliases;

            if (XkbAllocNames(xkb, XkbKeyAliasesMask, 0, na) != Success)
                return BadAlloc;
            memcpy((char *) names->key_aliases, (char *) tmp,
                   stuff->nKeyAliases * sizeof(XkbKeyAliasRec));
            tmp += stuff->nKeyAliases * 2;
        }
        else if (names->key_aliases != NULL) {
            free(names->key_aliases);
            names->key_aliases = NULL;
            names->num_key_aliases = 0;
        }
        nn.nAliases = names->num_key_aliases;
    }
    if (stuff->which & XkbRGNamesMask) {
        if (stuff->nRadioGroups > 0) {
            register unsigned i, nrg;

            nrg = stuff->nRadioGroups;
            if (XkbAllocNames(xkb, XkbRGNamesMask, nrg, 0) != Success)
                return BadAlloc;

            for (i = 0; i < stuff->nRadioGroups; i++) {
                names->radio_groups[i] = tmp[i];
            }
            tmp += stuff->nRadioGroups;
        }
        else if (names->radio_groups) {
            free(names->radio_groups);
            names->radio_groups = NULL;
            names->num_rg = 0;
        }
        nn.nRadioGroups = names->num_rg;
    }
    if (nn.changed) {
        Bool needExtEvent;

        needExtEvent = (nn.changed & XkbIndicatorNamesMask) != 0;
        XkbSendNamesNotify(dev, &nn);
        if (needExtEvent) {
            XkbSrvLedInfoPtr sli;
            xkbExtensionDeviceNotify edev;
            register int i;
            register unsigned bit;

            sli = XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId,
                                    XkbXI_IndicatorsMask);
            sli->namesPresent = 0;
            for (i = 0, bit = 1; i < XkbNumIndicators; i++, bit <<= 1) {
                if (names->indicators[i] != None)
                    sli->namesPresent |= bit;
            }
            memset(&edev, 0, sizeof(xkbExtensionDeviceNotify));
            edev.reason = XkbXI_IndicatorNamesMask;
            edev.ledClass = KbdFeedbackClass;
            edev.ledID = dev->kbdfeed->ctrl.id;
            edev.ledsDefined = sli->namesPresent | sli->mapsPresent;
            edev.ledState = sli->effectiveState;
            edev.firstBtn = 0;
            edev.nBtns = 0;
            edev.supported = XkbXI_AllFeaturesMask;
            edev.unsupported = 0;
            XkbSendExtensionDeviceNotify(dev, client, &edev);
        }
    }
    return Success;
}

int
ProcXkbSetNames(ClientPtr client)
{
    DeviceIntPtr dev;
    CARD32 *tmp;
    Atom bad;
    int rc;

    REQUEST(xkbSetNamesReq);
    REQUEST_AT_LEAST_SIZE(xkbSetNamesReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
    CHK_MASK_LEGAL(0x01, stuff->which, XkbAllNamesMask);

    /* check device-independent stuff */
    tmp = (CARD32 *) &stuff[1];

    if (stuff->which & XkbKeycodesNameMask) {
        tmp = _XkbCheckAtoms(tmp, 1, client->swapped, &bad);
        if (!tmp) {
            client->errorValue = bad;
            return BadAtom;
        }
    }
    if (stuff->which & XkbGeometryNameMask) {
        tmp = _XkbCheckAtoms(tmp, 1, client->swapped, &bad);
        if (!tmp) {
            client->errorValue = bad;
            return BadAtom;
        }
    }
    if (stuff->which & XkbSymbolsNameMask) {
        tmp = _XkbCheckAtoms(tmp, 1, client->swapped, &bad);
        if (!tmp) {
            client->errorValue = bad;
            return BadAtom;
        }
    }
    if (stuff->which & XkbPhysSymbolsNameMask) {
        tmp = _XkbCheckAtoms(tmp, 1, client->swapped, &bad);
        if (!tmp) {
            client->errorValue = bad;
            return BadAtom;
        }
    }
    if (stuff->which & XkbTypesNameMask) {
        tmp = _XkbCheckAtoms(tmp, 1, client->swapped, &bad);
        if (!tmp) {
            client->errorValue = bad;
            return BadAtom;
        }
    }
    if (stuff->which & XkbCompatNameMask) {
        tmp = _XkbCheckAtoms(tmp, 1, client->swapped, &bad);
        if (!tmp) {
            client->errorValue = bad;
            return BadAtom;
        }
    }

    /* start of device-dependent tests */
    rc = _XkbSetNamesCheck(client, dev, stuff, tmp);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd) {
        DeviceIntPtr other;

        for (other = inputInfo.devices; other; other = other->next) {
            if ((other != dev) && other->key && !IsMaster(other) &&
                GetMaster(other, MASTER_KEYBOARD) == dev) {

                rc = XaceHook(XACE_DEVICE_ACCESS, client, other,
                              DixManageAccess);
                if (rc == Success) {
                    rc = _XkbSetNamesCheck(client, other, stuff, tmp);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    /* everything is okay -- update names */

    rc = _XkbSetNames(client, dev, stuff);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd) {
        DeviceIntPtr other;

        for (other = inputInfo.devices; other; other = other->next) {
            if ((other != dev) && other->key && !IsMaster(other) &&
                GetMaster(other, MASTER_KEYBOARD) == dev) {

                rc = XaceHook(XACE_DEVICE_ACCESS, client, other,
                              DixManageAccess);
                if (rc == Success)
                    _XkbSetNames(client, other, stuff);
            }
        }
    }

    /* everything is okay -- update names */

    return Success;
}

/***====================================================================***/

#include "xkbgeom.h"

#define	XkbSizeCountedString(s)  ((s)?((((2+strlen(s))+3)/4)*4):4)

/**
 * Write the zero-terminated string str into wire as a pascal string with a
 * 16-bit length field prefixed before the actual string.
 *
 * @@param wire The destination array, usually the wire struct
 * @@param str The source string as zero-terminated C string
 * @@param swap If TRUE, the length field is swapped.
 *
 * @@return The input string in the format <string length><string> with a
 * (swapped) 16 bit string length, non-zero terminated.
 */
static char *
XkbWriteCountedString(char *wire, const char *str, Bool swap)
{
    CARD16 len, *pLen, paddedLen;

    if (!str)
        return wire;

    len = strlen(str);
    pLen = (CARD16 *) wire;
    *pLen = len;
    if (swap) {
        swaps(pLen);
    }
    paddedLen = pad_to_int32(sizeof(len) + len) - sizeof(len);
    strncpy(&wire[sizeof(len)], str, paddedLen);
    wire += sizeof(len) + paddedLen;
    return wire;
}

static int
XkbSizeGeomProperties(XkbGeometryPtr geom)
{
    register int i, size;
    XkbPropertyPtr prop;

    for (size = i = 0, prop = geom->properties; i < geom->num_properties;
         i++, prop++) {
        size += XkbSizeCountedString(prop->name);
        size += XkbSizeCountedString(prop->value);
    }
    return size;
}

static char *
XkbWriteGeomProperties(char *wire, XkbGeometryPtr geom, Bool swap)
{
    register int i;
    register XkbPropertyPtr prop;

    for (i = 0, prop = geom->properties; i < geom->num_properties; i++, prop++) {
        wire = XkbWriteCountedString(wire, prop->name, swap);
        wire = XkbWriteCountedString(wire, prop->value, swap);
    }
    return wire;
}

static int
XkbSizeGeomKeyAliases(XkbGeometryPtr geom)
{
    return geom->num_key_aliases * (2 * XkbKeyNameLength);
}

static char *
XkbWriteGeomKeyAliases(char *wire, XkbGeometryPtr geom, Bool swap)
{
    register int sz;

    sz = geom->num_key_aliases * (XkbKeyNameLength * 2);
    if (sz > 0) {
        memcpy(wire, (char *) geom->key_aliases, sz);
        wire += sz;
    }
    return wire;
}

static int
XkbSizeGeomColors(XkbGeometryPtr geom)
{
    register int i, size;
    register XkbColorPtr color;

    for (i = size = 0, color = geom->colors; i < geom->num_colors; i++, color++) {
        size += XkbSizeCountedString(color->spec);
    }
    return size;
}

static char *
XkbWriteGeomColors(char *wire, XkbGeometryPtr geom, Bool swap)
{
    register int i;
    register XkbColorPtr color;

    for (i = 0, color = geom->colors; i < geom->num_colors; i++, color++) {
        wire = XkbWriteCountedString(wire, color->spec, swap);
    }
    return wire;
}

static int
XkbSizeGeomShapes(XkbGeometryPtr geom)
{
    register int i, size;
    register XkbShapePtr shape;

    for (i = size = 0, shape = geom->shapes; i < geom->num_shapes; i++, shape++) {
        register int n;
        register XkbOutlinePtr ol;

        size += SIZEOF(xkbShapeWireDesc);
        for (n = 0, ol = shape->outlines; n < shape->num_outlines; n++, ol++) {
            size += SIZEOF(xkbOutlineWireDesc);
            size += ol->num_points * SIZEOF(xkbPointWireDesc);
        }
    }
    return size;
}

static char *
XkbWriteGeomShapes(char *wire, XkbGeometryPtr geom, Bool swap)
{
    int i;
    XkbShapePtr shape;
    xkbShapeWireDesc *shapeWire;

    for (i = 0, shape = geom->shapes; i < geom->num_shapes; i++, shape++) {
        register int o;
        XkbOutlinePtr ol;
        xkbOutlineWireDesc *olWire;

        shapeWire = (xkbShapeWireDesc *) wire;
        shapeWire->name = shape->name;
        shapeWire->nOutlines = shape->num_outlines;
        if (shape->primary != NULL)
            shapeWire->primaryNdx = XkbOutlineIndex(shape, shape->primary);
        else
            shapeWire->primaryNdx = XkbNoShape;
        if (shape->approx != NULL)
            shapeWire->approxNdx = XkbOutlineIndex(shape, shape->approx);
        else
            shapeWire->approxNdx = XkbNoShape;
        shapeWire->pad = 0;
        if (swap) {
            swapl(&shapeWire->name);
        }
        wire = (char *) &shapeWire[1];
        for (o = 0, ol = shape->outlines; o < shape->num_outlines; o++, ol++) {
            register int p;
            XkbPointPtr pt;
            xkbPointWireDesc *ptWire;

            olWire = (xkbOutlineWireDesc *) wire;
            olWire->nPoints = ol->num_points;
            olWire->cornerRadius = ol->corner_radius;
            olWire->pad = 0;
            wire = (char *) &olWire[1];
            ptWire = (xkbPointWireDesc *) wire;
            for (p = 0, pt = ol->points; p < ol->num_points; p++, pt++) {
                ptWire[p].x = pt->x;
                ptWire[p].y = pt->y;
                if (swap) {
                    swaps(&ptWire[p].x);
                    swaps(&ptWire[p].y);
                }
            }
            wire = (char *) &ptWire[ol->num_points];
        }
    }
    return wire;
}

static int
XkbSizeGeomDoodads(int num_doodads, XkbDoodadPtr doodad)
{
    register int i, size;

    for (i = size = 0; i < num_doodads; i++, doodad++) {
        size += SIZEOF(xkbAnyDoodadWireDesc);
        if (doodad->any.type == XkbTextDoodad) {
            size += XkbSizeCountedString(doodad->text.text);
            size += XkbSizeCountedString(doodad->text.font);
        }
        else if (doodad->any.type == XkbLogoDoodad) {
            size += XkbSizeCountedString(doodad->logo.logo_name);
        }
    }
    return size;
}

static char *
XkbWriteGeomDoodads(char *wire, int num_doodads, XkbDoodadPtr doodad, Bool swap)
{
    register int i;
    xkbDoodadWireDesc *doodadWire;

    for (i = 0; i < num_doodads; i++, doodad++) {
        doodadWire = (xkbDoodadWireDesc *) wire;
        wire = (char *) &doodadWire[1];
        memset(doodadWire, 0, SIZEOF(xkbDoodadWireDesc));
        doodadWire->any.name = doodad->any.name;
        doodadWire->any.type = doodad->any.type;
        doodadWire->any.priority = doodad->any.priority;
        doodadWire->any.top = doodad->any.top;
        doodadWire->any.left = doodad->any.left;
        if (swap) {
            swapl(&doodadWire->any.name);
            swaps(&doodadWire->any.top);
            swaps(&doodadWire->any.left);
        }
        switch (doodad->any.type) {
        case XkbOutlineDoodad:
        case XkbSolidDoodad:
            doodadWire->shape.angle = doodad->shape.angle;
            doodadWire->shape.colorNdx = doodad->shape.color_ndx;
            doodadWire->shape.shapeNdx = doodad->shape.shape_ndx;
            if (swap) {
                swaps(&doodadWire->shape.angle);
            }
            break;
        case XkbTextDoodad:
            doodadWire->text.angle = doodad->text.angle;
            doodadWire->text.width = doodad->text.width;
            doodadWire->text.height = doodad->text.height;
            doodadWire->text.colorNdx = doodad->text.color_ndx;
            if (swap) {
                swaps(&doodadWire->text.angle);
                swaps(&doodadWire->text.width);
                swaps(&doodadWire->text.height);
            }
            wire = XkbWriteCountedString(wire, doodad->text.text, swap);
            wire = XkbWriteCountedString(wire, doodad->text.font, swap);
            break;
        case XkbIndicatorDoodad:
            doodadWire->indicator.shapeNdx = doodad->indicator.shape_ndx;
            doodadWire->indicator.onColorNdx = doodad->indicator.on_color_ndx;
            doodadWire->indicator.offColorNdx = doodad->indicator.off_color_ndx;
            break;
        case XkbLogoDoodad:
            doodadWire->logo.angle = doodad->logo.angle;
            doodadWire->logo.colorNdx = doodad->logo.color_ndx;
            doodadWire->logo.shapeNdx = doodad->logo.shape_ndx;
            wire = XkbWriteCountedString(wire, doodad->logo.logo_name, swap);
            break;
        default:
            ErrorF("[xkb] Unknown doodad type %d in XkbWriteGeomDoodads\n",
                   doodad->any.type);
            ErrorF("[xkb] Ignored\n");
            break;
        }
    }
    return wire;
}

static char *
XkbWriteGeomOverlay(char *wire, XkbOverlayPtr ol, Bool swap)
{
    register int r;
    XkbOverlayRowPtr row;
    xkbOverlayWireDesc *olWire;

    olWire = (xkbOverlayWireDesc *) wire;
    olWire->name = ol->name;
    olWire->nRows = ol->num_rows;
    olWire->pad1 = 0;
    olWire->pad2 = 0;
    if (swap) {
        swapl(&olWire->name);
    }
    wire = (char *) &olWire[1];
    for (r = 0, row = ol->rows; r < ol->num_rows; r++, row++) {
        unsigned int k;
        XkbOverlayKeyPtr key;
        xkbOverlayRowWireDesc *rowWire;

        rowWire = (xkbOverlayRowWireDesc *) wire;
        rowWire->rowUnder = row->row_under;
        rowWire->nKeys = row->num_keys;
        rowWire->pad1 = 0;
        wire = (char *) &rowWire[1];
        for (k = 0, key = row->keys; k < row->num_keys; k++, key++) {
            xkbOverlayKeyWireDesc *keyWire;

            keyWire = (xkbOverlayKeyWireDesc *) wire;
            memcpy(keyWire->over, key->over.name, XkbKeyNameLength);
            memcpy(keyWire->under, key->under.name, XkbKeyNameLength);
            wire = (char *) &keyWire[1];
        }
    }
    return wire;
}

static int
XkbSizeGeomSections(XkbGeometryPtr geom)
{
    register int i, size;
    XkbSectionPtr section;

    for (i = size = 0, section = geom->sections; i < geom->num_sections;
         i++, section++) {
        size += SIZEOF(xkbSectionWireDesc);
        if (section->rows) {
            int r;
            XkbRowPtr row;

            for (r = 0, row = section->rows; r < section->num_rows; row++, r++) {
                size += SIZEOF(xkbRowWireDesc);
                size += row->num_keys * SIZEOF(xkbKeyWireDesc);
            }
        }
        if (section->doodads)
            size += XkbSizeGeomDoodads(section->num_doodads, section->doodads);
        if (section->overlays) {
            int o;
            XkbOverlayPtr ol;

            for (o = 0, ol = section->overlays; o < section->num_overlays;
                 o++, ol++) {
                int r;
                XkbOverlayRowPtr row;

                size += SIZEOF(xkbOverlayWireDesc);
                for (r = 0, row = ol->rows; r < ol->num_rows; r++, row++) {
                    size += SIZEOF(xkbOverlayRowWireDesc);
                    size += row->num_keys * SIZEOF(xkbOverlayKeyWireDesc);
                }
            }
        }
    }
    return size;
}

static char *
XkbWriteGeomSections(char *wire, XkbGeometryPtr geom, Bool swap)
{
    register int i;
    XkbSectionPtr section;
    xkbSectionWireDesc *sectionWire;

    for (i = 0, section = geom->sections; i < geom->num_sections;
         i++, section++) {
        sectionWire = (xkbSectionWireDesc *) wire;
        sectionWire->name = section->name;
        sectionWire->top = section->top;
        sectionWire->left = section->left;
        sectionWire->width = section->width;
        sectionWire->height = section->height;
        sectionWire->angle = section->angle;
        sectionWire->priority = section->priority;
        sectionWire->nRows = section->num_rows;
        sectionWire->nDoodads = section->num_doodads;
        sectionWire->nOverlays = section->num_overlays;
        sectionWire->pad = 0;
        if (swap) {
            swapl(&sectionWire->name);
            swaps(&sectionWire->top);
            swaps(&sectionWire->left);
            swaps(&sectionWire->width);
            swaps(&sectionWire->height);
            swaps(&sectionWire->angle);
        }
        wire = (char *) &sectionWire[1];
        if (section->rows) {
            int r;
            XkbRowPtr row;
            xkbRowWireDesc *rowWire;

            for (r = 0, row = section->rows; r < section->num_rows; r++, row++) {
                rowWire = (xkbRowWireDesc *) wire;
                rowWire->top = row->top;
                rowWire->left = row->left;
                rowWire->nKeys = row->num_keys;
                rowWire->vertical = row->vertical;
                rowWire->pad = 0;
                if (swap) {
                    swaps(&rowWire->top);
                    swaps(&rowWire->left);
                }
                wire = (char *) &rowWire[1];
                if (row->keys) {
                    int k;
                    XkbKeyPtr key;
                    xkbKeyWireDesc *keyWire;

                    keyWire = (xkbKeyWireDesc *) wire;
                    for (k = 0, key = row->keys; k < row->num_keys; k++, key++) {
                        memcpy(keyWire[k].name, key->name.name,
                               XkbKeyNameLength);
                        keyWire[k].gap = key->gap;
                        keyWire[k].shapeNdx = key->shape_ndx;
                        keyWire[k].colorNdx = key->color_ndx;
                        if (swap) {
                            swaps(&keyWire[k].gap);
                        }
                    }
                    wire = (char *) &keyWire[row->num_keys];
                }
            }
        }
        if (section->doodads) {
            wire = XkbWriteGeomDoodads(wire,
                                       section->num_doodads, section->doodads,
                                       swap);
        }
        if (section->overlays) {
            register int o;

            for (o = 0; o < section->num_overlays; o++) {
                wire = XkbWriteGeomOverlay(wire, &section->overlays[o], swap);
            }
        }
    }
    return wire;
}

static Status
XkbComputeGetGeometryReplySize(XkbGeometryPtr geom,
                               xkbGetGeometryReply * rep, Atom name)
{
    int len;

    if (geom != NULL) {
        len = XkbSizeCountedString(geom->label_font);
        len += XkbSizeGeomProperties(geom);
        len += XkbSizeGeomColors(geom);
        len += XkbSizeGeomShapes(geom);
        len += XkbSizeGeomSections(geom);
        len += XkbSizeGeomDoodads(geom->num_doodads, geom->doodads);
        len += XkbSizeGeomKeyAliases(geom);
        rep->length = len / 4;
        rep->found = TRUE;
        rep->name = geom->name;
        rep->widthMM = geom->width_mm;
        rep->heightMM = geom->height_mm;
        rep->nProperties = geom->num_properties;
        rep->nColors = geom->num_colors;
        rep->nShapes = geom->num_shapes;
        rep->nSections = geom->num_sections;
        rep->nDoodads = geom->num_doodads;
        rep->nKeyAliases = geom->num_key_aliases;
        rep->baseColorNdx = XkbGeomColorIndex(geom, geom->base_color);
        rep->labelColorNdx = XkbGeomColorIndex(geom, geom->label_color);
    }
    else {
        rep->length = 0;
        rep->found = FALSE;
        rep->name = name;
        rep->widthMM = rep->heightMM = 0;
        rep->nProperties = rep->nColors = rep->nShapes = 0;
        rep->nSections = rep->nDoodads = 0;
        rep->nKeyAliases = 0;
        rep->labelColorNdx = rep->baseColorNdx = 0;
    }
    return Success;
}
static int
XkbSendGeometry(ClientPtr client,
                XkbGeometryPtr geom, xkbGetGeometryReply * rep, Bool freeGeom)
{
    char *desc, *start;
    int len;

    if (geom != NULL) {
        start = desc = xallocarray(rep->length, 4);
        if (!start)
            return BadAlloc;
        len = rep->length * 4;
        desc = XkbWriteCountedString(desc, geom->label_font, client->swapped);
        if (rep->nProperties > 0)
            desc = XkbWriteGeomProperties(desc, geom, client->swapped);
        if (rep->nColors > 0)
            desc = XkbWriteGeomColors(desc, geom, client->swapped);
        if (rep->nShapes > 0)
            desc = XkbWriteGeomShapes(desc, geom, client->swapped);
        if (rep->nSections > 0)
            desc = XkbWriteGeomSections(desc, geom, client->swapped);
        if (rep->nDoodads > 0)
            desc = XkbWriteGeomDoodads(desc, geom->num_doodads, geom->doodads,
                                       client->swapped);
        if (rep->nKeyAliases > 0)
            desc = XkbWriteGeomKeyAliases(desc, geom, client->swapped);
        if ((desc - start) != (len)) {
            ErrorF
                ("[xkb] BOGUS LENGTH in XkbSendGeometry, expected %d, got %ld\n",
                 len, (unsigned long) (desc - start));
        }
    }
    else {
        len = 0;
        start = NULL;
    }
    if (client->swapped) {
        swaps(&rep->sequenceNumber);
        swapl(&rep->length);
        swapl(&rep->name);
        swaps(&rep->widthMM);
        swaps(&rep->heightMM);
        swaps(&rep->nProperties);
        swaps(&rep->nColors);
        swaps(&rep->nShapes);
        swaps(&rep->nSections);
        swaps(&rep->nDoodads);
        swaps(&rep->nKeyAliases);
    }
    WriteToClient(client, SIZEOF(xkbGetGeometryReply), rep);
    if (len > 0)
        WriteToClient(client, len, start);
    if (start != NULL)
        free((char *) start);
    if (freeGeom)
        XkbFreeGeometry(geom, XkbGeomAllMask, TRUE);
    return Success;
}

int
ProcXkbGetGeometry(ClientPtr client)
{
    DeviceIntPtr dev;
    xkbGetGeometryReply rep;
    XkbGeometryPtr geom;
    Bool shouldFree;
    Status status;

    REQUEST(xkbGetGeometryReq);
    REQUEST_SIZE_MATCH(xkbGetGeometryReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
    CHK_ATOM_OR_NONE(stuff->name);

    geom = XkbLookupNamedGeometry(dev, stuff->name, &shouldFree);
    rep = (xkbGetGeometryReply) {
        .type = X_Reply,
        .deviceID = dev->id,
        .sequenceNumber = client->sequence,
        .length = 0
    };
    status = XkbComputeGetGeometryReplySize(geom, &rep, stuff->name);
    if (status != Success)
        return status;
    else
        return XkbSendGeometry(client, geom, &rep, shouldFree);
}

/***====================================================================***/

static Status
_GetCountedString(char **wire_inout, ClientPtr client, char **str)
{
    char *wire, *next;
    CARD16 len;

    wire = *wire_inout;
    len = *(CARD16 *) wire;
    if (client->swapped) {
        swaps(&len);
    }
    next = wire + XkbPaddedSize(len + 2);
    /* Check we're still within the size of the request */
    if (client->req_len <
        bytes_to_int32(next - (char *) client->requestBuffer))
        return BadValue;
    *str = malloc(len + 1);
    if (!*str)
        return BadAlloc;
    memcpy(*str, &wire[2], len);
    *(*str + len) = '\0';
    *wire_inout = next;
    return Success;
}

static Status
_CheckSetDoodad(char **wire_inout,
                XkbGeometryPtr geom, XkbSectionPtr section, ClientPtr client)
{
    char *wire;
    xkbDoodadWireDesc *dWire;
    xkbAnyDoodadWireDesc any;
    xkbTextDoodadWireDesc text;
    XkbDoodadPtr doodad;
    Status status;

    dWire = (xkbDoodadWireDesc *) (*wire_inout);
    any = dWire->any;
    wire = (char *) &dWire[1];
    if (client->swapped) {
        swapl(&any.name);
        swaps(&any.top);
        swaps(&any.left);
        swaps(&any.angle);
    }
    CHK_ATOM_ONLY(dWire->any.name);
    doodad = XkbAddGeomDoodad(geom, section, any.name);
    if (!doodad)
        return BadAlloc;
    doodad->any.type = dWire->any.type;
    doodad->any.priority = dWire->any.priority;
    doodad->any.top = any.top;
    doodad->any.left = any.left;
    doodad->any.angle = any.angle;
    switch (doodad->any.type) {
    case XkbOutlineDoodad:
    case XkbSolidDoodad:
        if (dWire->shape.colorNdx >= geom->num_colors) {
            client->errorValue = _XkbErrCode3(0x40, geom->num_colors,
                                              dWire->shape.colorNdx);
            return BadMatch;
        }
        if (dWire->shape.shapeNdx >= geom->num_shapes) {
            client->errorValue = _XkbErrCode3(0x41, geom->num_shapes,
                                              dWire->shape.shapeNdx);
            return BadMatch;
        }
        doodad->shape.color_ndx = dWire->shape.colorNdx;
        doodad->shape.shape_ndx = dWire->shape.shapeNdx;
        break;
    case XkbTextDoodad:
        if (dWire->text.colorNdx >= geom->num_colors) {
            client->errorValue = _XkbErrCode3(0x42, geom->num_colors,
                                              dWire->text.colorNdx);
            return BadMatch;
        }
        text = dWire->text;
        if (client->swapped) {
            swaps(&text.width);
            swaps(&text.height);
        }
        doodad->text.width = text.width;
        doodad->text.height = text.height;
        doodad->text.color_ndx = dWire->text.colorNdx;
        status = _GetCountedString(&wire, client, &doodad->text.text);
        if (status != Success)
            return status;
        status = _GetCountedString(&wire, client, &doodad->text.font);
        if (status != Success) {
            free (doodad->text.text);
            return status;
        }
        break;
    case XkbIndicatorDoodad:
        if (dWire->indicator.onColorNdx >= geom->num_colors) {
            client->errorValue = _XkbErrCode3(0x43, geom->num_colors,
                                              dWire->indicator.onColorNdx);
            return BadMatch;
        }
        if (dWire->indicator.offColorNdx >= geom->num_colors) {
            client->errorValue = _XkbErrCode3(0x44, geom->num_colors,
                                              dWire->indicator.offColorNdx);
            return BadMatch;
        }
        if (dWire->indicator.shapeNdx >= geom->num_shapes) {
            client->errorValue = _XkbErrCode3(0x45, geom->num_shapes,
                                              dWire->indicator.shapeNdx);
            return BadMatch;
        }
        doodad->indicator.shape_ndx = dWire->indicator.shapeNdx;
        doodad->indicator.on_color_ndx = dWire->indicator.onColorNdx;
        doodad->indicator.off_color_ndx = dWire->indicator.offColorNdx;
        break;
    case XkbLogoDoodad:
        if (dWire->logo.colorNdx >= geom->num_colors) {
            client->errorValue = _XkbErrCode3(0x46, geom->num_colors,
                                              dWire->logo.colorNdx);
            return BadMatch;
        }
        if (dWire->logo.shapeNdx >= geom->num_shapes) {
            client->errorValue = _XkbErrCode3(0x47, geom->num_shapes,
                                              dWire->logo.shapeNdx);
            return BadMatch;
        }
        doodad->logo.color_ndx = dWire->logo.colorNdx;
        doodad->logo.shape_ndx = dWire->logo.shapeNdx;
        status = _GetCountedString(&wire, client, &doodad->logo.logo_name);
        if (status != Success)
            return status;
        break;
    default:
        client->errorValue = _XkbErrCode2(0x4F, dWire->any.type);
        return BadValue;
    }
    *wire_inout = wire;
    return Success;
}

static Status
_CheckSetOverlay(char **wire_inout,
                 XkbGeometryPtr geom, XkbSectionPtr section, ClientPtr client)
{
    register int r;
    char *wire;
    XkbOverlayPtr ol;
    xkbOverlayWireDesc *olWire;
    xkbOverlayRowWireDesc *rWire;

    wire = *wire_inout;
    olWire = (xkbOverlayWireDesc *) wire;
    if (client->swapped) {
        swapl(&olWire->name);
    }
    CHK_ATOM_ONLY(olWire->name);
    ol = XkbAddGeomOverlay(section, olWire->name, olWire->nRows);
    rWire = (xkbOverlayRowWireDesc *) &olWire[1];
    for (r = 0; r < olWire->nRows; r++) {
        register int k;
        xkbOverlayKeyWireDesc *kWire;
        XkbOverlayRowPtr row;

        if (rWire->rowUnder > section->num_rows) {
            client->errorValue = _XkbErrCode4(0x20, r, section->num_rows,
                                              rWire->rowUnder);
            return BadMatch;
        }
        row = XkbAddGeomOverlayRow(ol, rWire->rowUnder, rWire->nKeys);
        kWire = (xkbOverlayKeyWireDesc *) &rWire[1];
        for (k = 0; k < rWire->nKeys; k++, kWire++) {
            if (XkbAddGeomOverlayKey(ol, row,
                                     (char *) kWire->over,
                                     (char *) kWire->under) == NULL) {
                client->errorValue = _XkbErrCode3(0x21, r, k);
                return BadMatch;
            }
        }
        rWire = (xkbOverlayRowWireDesc *) kWire;
    }
    olWire = (xkbOverlayWireDesc *) rWire;
    wire = (char *) olWire;
    *wire_inout = wire;
    return Success;
}

static Status
_CheckSetSections(XkbGeometryPtr geom,
                  xkbSetGeometryReq * req, char **wire_inout, ClientPtr client)
{
    Status status;
    register int s;
    char *wire;
    xkbSectionWireDesc *sWire;
    XkbSectionPtr section;

    wire = *wire_inout;
    if (req->nSections < 1)
        return Success;
    sWire = (xkbSectionWireDesc *) wire;
    for (s = 0; s < req->nSections; s++) {
        register int r;
        xkbRowWireDesc *rWire;

        if (client->swapped) {
            swapl(&sWire->name);
            swaps(&sWire->top);
            swaps(&sWire->left);
            swaps(&sWire->width);
            swaps(&sWire->height);
            swaps(&sWire->angle);
        }
        CHK_ATOM_ONLY(sWire->name);
        section = XkbAddGeomSection(geom, sWire->name, sWire->nRows,
                                    sWire->nDoodads, sWire->nOverlays);
        if (!section)
            return BadAlloc;
        section->priority = sWire->priority;
        section->top = sWire->top;
        section->left = sWire->left;
        section->width = sWire->width;
        section->height = sWire->height;
        section->angle = sWire->angle;
        rWire = (xkbRowWireDesc *) &sWire[1];
        for (r = 0; r < sWire->nRows; r++) {
            register int k;
            XkbRowPtr row;
            xkbKeyWireDesc *kWire;

            if (client->swapped) {
                swaps(&rWire->top);
                swaps(&rWire->left);
            }
            row = XkbAddGeomRow(section, rWire->nKeys);
            if (!row)
                return BadAlloc;
            row->top = rWire->top;
            row->left = rWire->left;
            row->vertical = rWire->vertical;
            kWire = (xkbKeyWireDesc *) &rWire[1];
            for (k = 0; k < rWire->nKeys; k++) {
                XkbKeyPtr key;

                key = XkbAddGeomKey(row);
                if (!key)
                    return BadAlloc;
                memcpy(key->name.name, kWire[k].name, XkbKeyNameLength);
                key->gap = kWire[k].gap;
                key->shape_ndx = kWire[k].shapeNdx;
                key->color_ndx = kWire[k].colorNdx;
                if (key->shape_ndx >= geom->num_shapes) {
                    client->errorValue = _XkbErrCode3(0x10, key->shape_ndx,
                                                      geom->num_shapes);
                    return BadMatch;
                }
                if (key->color_ndx >= geom->num_colors) {
                    client->errorValue = _XkbErrCode3(0x11, key->color_ndx,
                                                      geom->num_colors);
                    return BadMatch;
                }
            }
            rWire = (xkbRowWireDesc *) &kWire[rWire->nKeys];
        }
        wire = (char *) rWire;
        if (sWire->nDoodads > 0) {
            register int d;

            for (d = 0; d < sWire->nDoodads; d++) {
                status = _CheckSetDoodad(&wire, geom, section, client);
                if (status != Success)
                    return status;
            }
        }
        if (sWire->nOverlays > 0) {
            register int o;

            for (o = 0; o < sWire->nOverlays; o++) {
                status = _CheckSetOverlay(&wire, geom, section, client);
                if (status != Success)
                    return status;
            }
        }
        sWire = (xkbSectionWireDesc *) wire;
    }
    wire = (char *) sWire;
    *wire_inout = wire;
    return Success;
}

static Status
_CheckSetShapes(XkbGeometryPtr geom,
                xkbSetGeometryReq * req, char **wire_inout, ClientPtr client)
{
    register int i;
    char *wire;

    wire = *wire_inout;
    if (req->nShapes < 1) {
        client->errorValue = _XkbErrCode2(0x06, req->nShapes);
        return BadValue;
    }
    else {
        xkbShapeWireDesc *shapeWire;
        XkbShapePtr shape;
        register int o;

        shapeWire = (xkbShapeWireDesc *) wire;
        for (i = 0; i < req->nShapes; i++) {
            xkbOutlineWireDesc *olWire;
            XkbOutlinePtr ol;

            shape =
                XkbAddGeomShape(geom, shapeWire->name, shapeWire->nOutlines);
            if (!shape)
                return BadAlloc;
            olWire = (xkbOutlineWireDesc *) (&shapeWire[1]);
            for (o = 0; o < shapeWire->nOutlines; o++) {
                register int p;
                XkbPointPtr pt;
                xkbPointWireDesc *ptWire;

                ol = XkbAddGeomOutline(shape, olWire->nPoints);
                if (!ol)
                    return BadAlloc;
                ol->corner_radius = olWire->cornerRadius;
                ptWire = (xkbPointWireDesc *) &olWire[1];
                for (p = 0, pt = ol->points; p < olWire->nPoints; p++, pt++) {
                    pt->x = ptWire[p].x;
                    pt->y = ptWire[p].y;
                    if (client->swapped) {
                        swaps(&pt->x);
                        swaps(&pt->y);
                    }
                }
                ol->num_points = olWire->nPoints;
                olWire = (xkbOutlineWireDesc *) (&ptWire[olWire->nPoints]);
            }
            if (shapeWire->primaryNdx != XkbNoShape)
                shape->primary = &shape->outlines[shapeWire->primaryNdx];
            if (shapeWire->approxNdx != XkbNoShape)
                shape->approx = &shape->outlines[shapeWire->approxNdx];
            shapeWire = (xkbShapeWireDesc *) olWire;
        }
        wire = (char *) shapeWire;
    }
    if (geom->num_shapes != req->nShapes) {
        client->errorValue = _XkbErrCode3(0x07, geom->num_shapes, req->nShapes);
        return BadMatch;
    }

    *wire_inout = wire;
    return Success;
}

static Status
_CheckSetGeom(XkbGeometryPtr geom, xkbSetGeometryReq * req, ClientPtr client)
{
    register int i;
    Status status;
    char *wire;

    wire = (char *) &req[1];
    status = _GetCountedString(&wire, client, &geom->label_font);
    if (status != Success)
        return status;

    for (i = 0; i < req->nProperties; i++) {
        char *name, *val;

        status = _GetCountedString(&wire, client, &name);
        if (status != Success)
            return status;
        status = _GetCountedString(&wire, client, &val);
        if (status != Success) {
            free(name);
            return status;
        }
        if (XkbAddGeomProperty(geom, name, val) == NULL) {
            free(name);
            free(val);
            return BadAlloc;
        }
        free(name);
        free(val);
    }

    if (req->nColors < 2) {
        client->errorValue = _XkbErrCode3(0x01, 2, req->nColors);
        return BadValue;
    }
    if (req->baseColorNdx > req->nColors) {
        client->errorValue =
            _XkbErrCode3(0x03, req->nColors, req->baseColorNdx);
        return BadMatch;
    }
    if (req->labelColorNdx > req->nColors) {
        client->errorValue =
            _XkbErrCode3(0x03, req->nColors, req->labelColorNdx);
        return BadMatch;
    }
    if (req->labelColorNdx == req->baseColorNdx) {
        client->errorValue = _XkbErrCode3(0x04, req->baseColorNdx,
                                          req->labelColorNdx);
        return BadMatch;
    }

    for (i = 0; i < req->nColors; i++) {
        char *name;

        status = _GetCountedString(&wire, client, &name);
        if (status != Success)
            return status;
        if (!XkbAddGeomColor(geom, name, geom->num_colors)) {
            free(name);
            return BadAlloc;
        }
        free(name);
    }
    if (req->nColors != geom->num_colors) {
        client->errorValue = _XkbErrCode3(0x05, req->nColors, geom->num_colors);
        return BadMatch;
    }
    geom->label_color = &geom->colors[req->labelColorNdx];
    geom->base_color = &geom->colors[req->baseColorNdx];

    if ((status = _CheckSetShapes(geom, req, &wire, client)) != Success)
        return status;

    if ((status = _CheckSetSections(geom, req, &wire, client)) != Success)
        return status;

    for (i = 0; i < req->nDoodads; i++) {
        status = _CheckSetDoodad(&wire, geom, NULL, client);
        if (status != Success)
            return status;
    }

    for (i = 0; i < req->nKeyAliases; i++) {
        if (XkbAddGeomKeyAlias(geom, &wire[XkbKeyNameLength], wire) == NULL)
            return BadAlloc;
        wire += 2 * XkbKeyNameLength;
    }
    return Success;
}

static int
_XkbSetGeometry(ClientPtr client, DeviceIntPtr dev, xkbSetGeometryReq * stuff)
{
    XkbDescPtr xkb;
    Bool new_name;
    xkbNewKeyboardNotify nkn;
    XkbGeometryPtr geom, old;
    XkbGeometrySizesRec sizes;
    Status status;

    xkb = dev->key->xkbInfo->desc;
    old = xkb->geom;
    xkb->geom = NULL;

    sizes.which = XkbGeomAllMask;
    sizes.num_properties = stuff->nProperties;
    sizes.num_colors = stuff->nColors;
    sizes.num_shapes = stuff->nShapes;
    sizes.num_sections = stuff->nSections;
    sizes.num_doodads = stuff->nDoodads;
    sizes.num_key_aliases = stuff->nKeyAliases;
    if ((status = XkbAllocGeometry(xkb, &sizes)) != Success) {
        xkb->geom = old;
        return status;
    }
    geom = xkb->geom;
    geom->name = stuff->name;
    geom->width_mm = stuff->widthMM;
    geom->height_mm = stuff->heightMM;
    if ((status = _CheckSetGeom(geom, stuff, client)) != Success) {
        XkbFreeGeometry(geom, XkbGeomAllMask, TRUE);
        xkb->geom = old;
        return status;
    }
    new_name = (xkb->names->geometry != geom->name);
    xkb->names->geometry = geom->name;
    if (old)
        XkbFreeGeometry(old, XkbGeomAllMask, TRUE);
    if (new_name) {
        xkbNamesNotify nn;

        memset(&nn, 0, sizeof(xkbNamesNotify));
        nn.changed = XkbGeometryNameMask;
        XkbSendNamesNotify(dev, &nn);
    }
    nkn.deviceID = nkn.oldDeviceID = dev->id;
    nkn.minKeyCode = nkn.oldMinKeyCode = xkb->min_key_code;
    nkn.maxKeyCode = nkn.oldMaxKeyCode = xkb->max_key_code;
    nkn.requestMajor = XkbReqCode;
    nkn.requestMinor = X_kbSetGeometry;
    nkn.changed = XkbNKN_GeometryMask;
    XkbSendNewKeyboardNotify(dev, &nkn);
    return Success;
}

int
ProcXkbSetGeometry(ClientPtr client)
{
    DeviceIntPtr dev;
    int rc;

    REQUEST(xkbSetGeometryReq);
    REQUEST_AT_LEAST_SIZE(xkbSetGeometryReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
    CHK_ATOM_OR_NONE(stuff->name);

    rc = _XkbSetGeometry(client, dev, stuff);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd) {
        DeviceIntPtr other;

        for (other = inputInfo.devices; other; other = other->next) {
            if ((other != dev) && other->key && !IsMaster(other) &&
                GetMaster(other, MASTER_KEYBOARD) == dev) {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other,
                              DixManageAccess);
                if (rc == Success)
                    _XkbSetGeometry(client, other, stuff);
            }
        }
    }

    return Success;
}

/***====================================================================***/

int
ProcXkbPerClientFlags(ClientPtr client)
{
    DeviceIntPtr dev;
    xkbPerClientFlagsReply rep;
    XkbInterestPtr interest;
    Mask access_mode = DixGetAttrAccess | DixSetAttrAccess;

    REQUEST(xkbPerClientFlagsReq);
    REQUEST_SIZE_MATCH(xkbPerClientFlagsReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, access_mode);
    CHK_MASK_LEGAL(0x01, stuff->change, XkbPCF_AllFlagsMask);
    CHK_MASK_MATCH(0x02, stuff->change, stuff->value);

    interest = XkbFindClientResource((DevicePtr) dev, client);
    if (stuff->change) {
        client->xkbClientFlags &= ~stuff->change;
        client->xkbClientFlags |= stuff->value;
    }
    if (stuff->change & XkbPCF_AutoResetControlsMask) {
        Bool want;

        want = stuff->value & XkbPCF_AutoResetControlsMask;
        if (interest && !want) {
            interest->autoCtrls = interest->autoCtrlValues = 0;
        }
        else if (want && (!interest)) {
            XID id = FakeClientID(client->index);

            if (!AddResource(id, RT_XKBCLIENT, dev))
                return BadAlloc;
            interest = XkbAddClientResource((DevicePtr) dev, client, id);
            if (!interest)
                return BadAlloc;
        }
        if (interest && want) {
            register unsigned affect;

            affect = stuff->ctrlsToChange;

            CHK_MASK_LEGAL(0x03, affect, XkbAllBooleanCtrlsMask);
            CHK_MASK_MATCH(0x04, affect, stuff->autoCtrls);
            CHK_MASK_MATCH(0x05, stuff->autoCtrls, stuff->autoCtrlValues);

            interest->autoCtrls &= ~affect;
            interest->autoCtrlValues &= ~affect;
            interest->autoCtrls |= stuff->autoCtrls & affect;
            interest->autoCtrlValues |= stuff->autoCtrlValues & affect;
        }
    }

    rep = (xkbPerClientFlagsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .supported = XkbPCF_AllFlagsMask,
        .value = client->xkbClientFlags & XkbPCF_AllFlagsMask,
        .autoCtrls = interest ? interest->autoCtrls : 0,
        .autoCtrlValues =  interest ? interest->autoCtrlValues : 0,
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.supported);
        swapl(&rep.value);
        swapl(&rep.autoCtrls);
        swapl(&rep.autoCtrlValues);
    }
    WriteToClient(client, SIZEOF(xkbPerClientFlagsReply), &rep);
    return Success;
}

/***====================================================================***/

/* all latin-1 alphanumerics, plus parens, minus, underscore, slash */
/* and wildcards */
static unsigned char componentSpecLegal[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0xa7, 0xff, 0x87,
    0xfe, 0xff, 0xff, 0x87, 0xfe, 0xff, 0xff, 0x07,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0x7f, 0xff
};

/* same as above but accepts percent, plus and bar too */
static unsigned char componentExprLegal[] = {
    0x00, 0x00, 0x00, 0x00, 0x20, 0xaf, 0xff, 0x87,
    0xfe, 0xff, 0xff, 0x87, 0xfe, 0xff, 0xff, 0x17,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0x7f, 0xff
};

static char *
GetComponentSpec(unsigned char **pWire, Bool allowExpr, int *errRtrn)
{
    int len;
    register int i;
    unsigned char *wire, *str, *tmp, *legal;

    if (allowExpr)
        legal = &componentExprLegal[0];
    else
        legal = &componentSpecLegal[0];

    wire = *pWire;
    len = (*(unsigned char *) wire++);
    if (len > 0) {
        str = calloc(1, len + 1);
        if (str) {
            tmp = str;
            for (i = 0; i < len; i++) {
                if (legal[(*wire) / 8] & (1 << ((*wire) % 8)))
                    *tmp++ = *wire++;
                else
                    wire++;
            }
            if (tmp != str)
                *tmp++ = '\0';
            else {
                free(str);
                str = NULL;
            }
        }
        else {
            *errRtrn = BadAlloc;
        }
    }
    else {
        str = NULL;
    }
    *pWire = wire;
    return (char *) str;
}

/***====================================================================***/

int
ProcXkbListComponents(ClientPtr client)
{
    DeviceIntPtr dev;
    xkbListComponentsReply rep;
    unsigned len;
    unsigned char *str;
    uint8_t size;
    int i;

    REQUEST(xkbListComponentsReq);
    REQUEST_AT_LEAST_SIZE(xkbListComponentsReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);

    /* The request is followed by six Pascal strings (i.e. size in characters
     * followed by a string pattern) describing what the client wants us to
     * list.  We don't care, but might as well check they haven't got the
     * length wrong. */
    str = (unsigned char *) &stuff[1];
    for (i = 0; i < 6; i++) {
        size = *((uint8_t *)str);
        len = (str + size + 1) - ((unsigned char *) stuff);
        if ((XkbPaddedSize(len) / 4) > stuff->length)
            return BadLength;
        str += (size + 1);
    }
    if ((XkbPaddedSize(len) / 4) != stuff->length)
        return BadLength;
    rep = (xkbListComponentsReply) {
        .type = X_Reply,
        .deviceID = dev->id,
        .sequenceNumber = client->sequence,
        .length = 0,
        .nKeymaps = 0,
        .nKeycodes = 0,
        .nTypes = 0,
        .nCompatMaps = 0,
        .nSymbols = 0,
        .nGeometries = 0,
        .extra = 0
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.nKeymaps);
        swaps(&rep.nKeycodes);
        swaps(&rep.nTypes);
        swaps(&rep.nCompatMaps);
        swaps(&rep.nSymbols);
        swaps(&rep.nGeometries);
        swaps(&rep.extra);
    }
    WriteToClient(client, SIZEOF(xkbListComponentsReply), &rep);
    return Success;
}

/***====================================================================***/
int
ProcXkbGetKbdByName(ClientPtr client)
{
    DeviceIntPtr dev;
    DeviceIntPtr tmpd;
    DeviceIntPtr master;
    xkbGetKbdByNameReply rep = { 0 };
    xkbGetMapReply mrep = { 0 };
    xkbGetCompatMapReply crep = { 0 };
    xkbGetIndicatorMapReply irep = { 0 };
    xkbGetNamesReply nrep = { 0 };
    xkbGetGeometryReply grep = { 0 };
    XkbComponentNamesRec names = { 0 };
    XkbDescPtr xkb, new;
    XkbEventCauseRec cause;
    unsigned char *str;
    char mapFile[PATH_MAX];
    unsigned len;
    unsigned fwant, fneed, reported;
    int status;
    Bool geom_changed;
    XkbSrvLedInfoPtr old_sli;
    XkbSrvLedInfoPtr sli;
    Mask access_mode = DixGetAttrAccess | DixManageAccess;

    REQUEST(xkbGetKbdByNameReq);
    REQUEST_AT_LEAST_SIZE(xkbGetKbdByNameReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, access_mode);
    master = GetMaster(dev, MASTER_KEYBOARD);

    xkb = dev->key->xkbInfo->desc;
    status = Success;
    str = (unsigned char *) &stuff[1];
    if (GetComponentSpec(&str, TRUE, &status))  /* keymap, unsupported */
        return BadMatch;
    names.keycodes = GetComponentSpec(&str, TRUE, &status);
    names.types = GetComponentSpec(&str, TRUE, &status);
    names.compat = GetComponentSpec(&str, TRUE, &status);
    names.symbols = GetComponentSpec(&str, TRUE, &status);
    names.geometry = GetComponentSpec(&str, TRUE, &status);
    if (status != Success)
        return status;
    len = str - ((unsigned char *) stuff);
    if ((XkbPaddedSize(len) / 4) != stuff->length)
        return BadLength;

    CHK_MASK_LEGAL(0x01, stuff->want, XkbGBN_AllComponentsMask);
    CHK_MASK_LEGAL(0x02, stuff->need, XkbGBN_AllComponentsMask);

    if (stuff->load)
        fwant = XkbGBN_AllComponentsMask;
    else
        fwant = stuff->want | stuff->need;
    if ((!names.compat) &&
        (fwant & (XkbGBN_CompatMapMask | XkbGBN_IndicatorMapMask))) {
        names.compat = Xstrdup("%");
    }
    if ((!names.types) && (fwant & (XkbGBN_TypesMask))) {
        names.types = Xstrdup("%");
    }
    if ((!names.symbols) && (fwant & XkbGBN_SymbolsMask)) {
        names.symbols = Xstrdup("%");
    }
    geom_changed = ((names.geometry != NULL) &&
                    (strcmp(names.geometry, "%") != 0));
    if ((!names.geometry) && (fwant & XkbGBN_GeometryMask)) {
        names.geometry = Xstrdup("%");
        geom_changed = FALSE;
    }

    memset(mapFile, 0, PATH_MAX);
    rep.type = X_Reply;
    rep.deviceID = dev->id;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.minKeyCode = xkb->min_key_code;
    rep.maxKeyCode = xkb->max_key_code;
    rep.loaded = FALSE;
    fwant =
        XkbConvertGetByNameComponents(TRUE, stuff->want) | XkmVirtualModsMask;
    fneed = XkbConvertGetByNameComponents(TRUE, stuff->need);
    rep.reported = XkbConvertGetByNameComponents(FALSE, fwant | fneed);
    if (stuff->load) {
        fneed |= XkmKeymapRequired;
        fwant |= XkmKeymapLegal;
    }
    if ((fwant | fneed) & XkmSymbolsMask) {
        fneed |= XkmKeyNamesIndex | XkmTypesIndex;
        fwant |= XkmIndicatorsIndex;
    }

    /* We pass dev in here so we can get the old names out if needed. */
    rep.found = XkbDDXLoadKeymapByNames(dev, &names, fwant, fneed, &new,
                                        mapFile, PATH_MAX);
    rep.newKeyboard = FALSE;
    rep.pad1 = rep.pad2 = rep.pad3 = rep.pad4 = 0;

    stuff->want |= stuff->need;
    if (new == NULL)
        rep.reported = 0;
    else {
        if (stuff->load)
            rep.loaded = TRUE;
        if (stuff->load ||
            ((rep.reported & XkbGBN_SymbolsMask) && (new->compat))) {
            XkbChangesRec changes;

            memset(&changes, 0, sizeof(changes));
            XkbUpdateDescActions(new,
                                 new->min_key_code, XkbNumKeys(new), &changes);
        }

        if (new->map == NULL)
            rep.reported &= ~(XkbGBN_SymbolsMask | XkbGBN_TypesMask);
        else if (rep.reported & (XkbGBN_SymbolsMask | XkbGBN_TypesMask)) {
            mrep.type = X_Reply;
            mrep.deviceID = dev->id;
            mrep.sequenceNumber = client->sequence;
            mrep.length =
                ((SIZEOF(xkbGetMapReply) - SIZEOF(xGenericReply)) >> 2);
            mrep.minKeyCode = new->min_key_code;
            mrep.maxKeyCode = new->max_key_code;
            mrep.present = 0;
            mrep.totalSyms = mrep.totalActs =
                mrep.totalKeyBehaviors = mrep.totalKeyExplicit =
                mrep.totalModMapKeys = mrep.totalVModMapKeys = 0;
            if (rep.reported & (XkbGBN_TypesMask | XkbGBN_ClientSymbolsMask)) {
                mrep.present |= XkbKeyTypesMask;
                mrep.firstType = 0;
                mrep.nTypes = mrep.totalTypes = new->map->num_types;
            }
            else {
                mrep.firstType = mrep.nTypes = 0;
                mrep.totalTypes = 0;
            }
            if (rep.reported & XkbGBN_ClientSymbolsMask) {
                mrep.present |= (XkbKeySymsMask | XkbModifierMapMask);
                mrep.firstKeySym = mrep.firstModMapKey = new->min_key_code;
                mrep.nKeySyms = mrep.nModMapKeys = XkbNumKeys(new);
            }
            else {
                mrep.firstKeySym = mrep.firstModMapKey = 0;
                mrep.nKeySyms = mrep.nModMapKeys = 0;
            }
            if (rep.reported & XkbGBN_ServerSymbolsMask) {
                mrep.present |= XkbAllServerInfoMask;
                mrep.virtualMods = ~0;
                mrep.firstKeyAct = mrep.firstKeyBehavior =
                    mrep.firstKeyExplicit = new->min_key_code;
                mrep.nKeyActs = mrep.nKeyBehaviors =
                    mrep.nKeyExplicit = XkbNumKeys(new);
                mrep.firstVModMapKey = new->min_key_code;
                mrep.nVModMapKeys = XkbNumKeys(new);
            }
            else {
                mrep.virtualMods = 0;
                mrep.firstKeyAct = mrep.firstKeyBehavior =
                    mrep.firstKeyExplicit = 0;
                mrep.nKeyActs = mrep.nKeyBehaviors = mrep.nKeyExplicit = 0;
            }
            XkbComputeGetMapReplySize(new, &mrep);
            rep.length += SIZEOF(xGenericReply) / 4 + mrep.length;
        }
        if (new->compat == NULL)
            rep.reported &= ~XkbGBN_CompatMapMask;
        else if (rep.reported & XkbGBN_CompatMapMask) {
            crep.type = X_Reply;
            crep.deviceID = dev->id;
            crep.sequenceNumber = client->sequence;
            crep.length = 0;
            crep.groups = XkbAllGroupsMask;
            crep.firstSI = 0;
            crep.nSI = crep.nTotalSI = new->compat->num_si;
            XkbComputeGetCompatMapReplySize(new->compat, &crep);
            rep.length += SIZEOF(xGenericReply) / 4 + crep.length;
        }
        if (new->indicators == NULL)
            rep.reported &= ~XkbGBN_IndicatorMapMask;
        else if (rep.reported & XkbGBN_IndicatorMapMask) {
            irep.type = X_Reply;
            irep.deviceID = dev->id;
            irep.sequenceNumber = client->sequence;
            irep.length = 0;
            irep.which = XkbAllIndicatorsMask;
            XkbComputeGetIndicatorMapReplySize(new->indicators, &irep);
            rep.length += SIZEOF(xGenericReply) / 4 + irep.length;
        }
        if (new->names == NULL)
            rep.reported &= ~(XkbGBN_OtherNamesMask | XkbGBN_KeyNamesMask);
        else if (rep.reported & (XkbGBN_OtherNamesMask | XkbGBN_KeyNamesMask)) {
            nrep.type = X_Reply;
            nrep.deviceID = dev->id;
            nrep.sequenceNumber = client->sequence;
            nrep.length = 0;
            nrep.minKeyCode = new->min_key_code;
            nrep.maxKeyCode = new->max_key_code;
            if (rep.reported & XkbGBN_OtherNamesMask) {
                nrep.which = XkbAllNamesMask;
                if (new->map != NULL)
                    nrep.nTypes = new->map->num_types;
                else
                    nrep.nTypes = 0;
                nrep.nKTLevels = 0;
                nrep.groupNames = XkbAllGroupsMask;
                nrep.virtualMods = XkbAllVirtualModsMask;
                nrep.indicators = XkbAllIndicatorsMask;
                nrep.nRadioGroups = new->names->num_rg;
            }
            else {
                nrep.which = 0;
                nrep.nTypes = 0;
                nrep.nKTLevels = 0;
                nrep.groupNames = 0;
                nrep.virtualMods = 0;
                nrep.indicators = 0;
                nrep.nRadioGroups = 0;
            }
            if (rep.reported & XkbGBN_KeyNamesMask) {
                nrep.which |= XkbKeyNamesMask;
                nrep.firstKey = new->min_key_code;
                nrep.nKeys = XkbNumKeys(new);
                nrep.nKeyAliases = new->names->num_key_aliases;
                if (nrep.nKeyAliases)
                    nrep.which |= XkbKeyAliasesMask;
            }
            else {
                nrep.which &= ~(XkbKeyNamesMask | XkbKeyAliasesMask);
                nrep.firstKey = nrep.nKeys = 0;
                nrep.nKeyAliases = 0;
            }
            XkbComputeGetNamesReplySize(new, &nrep);
            rep.length += SIZEOF(xGenericReply) / 4 + nrep.length;
        }
        if (new->geom == NULL)
            rep.reported &= ~XkbGBN_GeometryMask;
        else if (rep.reported & XkbGBN_GeometryMask) {
            grep.type = X_Reply;
            grep.deviceID = dev->id;
            grep.sequenceNumber = client->sequence;
            grep.length = 0;
            grep.found = TRUE;
            grep.pad = 0;
            grep.widthMM = grep.heightMM = 0;
            grep.nProperties = grep.nColors = grep.nShapes = 0;
            grep.nSections = grep.nDoodads = 0;
            grep.baseColorNdx = grep.labelColorNdx = 0;
            XkbComputeGetGeometryReplySize(new->geom, &grep, None);
            rep.length += SIZEOF(xGenericReply) / 4 + grep.length;
        }
    }

    reported = rep.reported;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.found);
        swaps(&rep.reported);
    }
    WriteToClient(client, SIZEOF(xkbGetKbdByNameReply), &rep);
    if (reported & (XkbGBN_SymbolsMask | XkbGBN_TypesMask))
        XkbSendMap(client, new, &mrep);
    if (reported & XkbGBN_CompatMapMask)
        XkbSendCompatMap(client, new->compat, &crep);
    if (reported & XkbGBN_IndicatorMapMask)
        XkbSendIndicatorMap(client, new->indicators, &irep);
    if (reported & (XkbGBN_KeyNamesMask | XkbGBN_OtherNamesMask))
        XkbSendNames(client, new, &nrep);
    if (reported & XkbGBN_GeometryMask)
        XkbSendGeometry(client, new->geom, &grep, FALSE);
    if (rep.loaded) {
        XkbDescPtr old_xkb;
        xkbNewKeyboardNotify nkn;

        old_xkb = xkb;
        xkb = new;
        dev->key->xkbInfo->desc = xkb;
        new = old_xkb;          /* so it'll get freed automatically */

        XkbCopyControls(xkb, old_xkb);

        nkn.deviceID = nkn.oldDeviceID = dev->id;
        nkn.minKeyCode = new->min_key_code;
        nkn.maxKeyCode = new->max_key_code;
        nkn.oldMinKeyCode = xkb->min_key_code;
        nkn.oldMaxKeyCode = xkb->max_key_code;
        nkn.requestMajor = XkbReqCode;
        nkn.requestMinor = X_kbGetKbdByName;
        nkn.changed = XkbNKN_KeycodesMask;
        if (geom_changed)
            nkn.changed |= XkbNKN_GeometryMask;
        XkbSendNewKeyboardNotify(dev, &nkn);

        /* Update the map and LED info on the device itself, as well as
         * any slaves if it's an MD, or its MD if it's an SD and was the
         * last device used on that MD. */
        for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) {
            if (tmpd != dev && GetMaster(tmpd, MASTER_KEYBOARD) != dev &&
                (tmpd != master || dev != master->lastSlave))
                continue;

            if (tmpd != dev)
                XkbDeviceApplyKeymap(tmpd, xkb);

            if (tmpd->kbdfeed && tmpd->kbdfeed->xkb_sli) {
                old_sli = tmpd->kbdfeed->xkb_sli;
                tmpd->kbdfeed->xkb_sli = NULL;
                sli = XkbAllocSrvLedInfo(tmpd, tmpd->kbdfeed, NULL, 0);
                if (sli) {
                    sli->explicitState = old_sli->explicitState;
                    sli->effectiveState = old_sli->effectiveState;
                }
                tmpd->kbdfeed->xkb_sli = sli;
                XkbFreeSrvLedInfo(old_sli);
            }
        }
    }
    if ((new != NULL) && (new != xkb)) {
        XkbFreeKeyboard(new, XkbAllComponentsMask, TRUE);
        new = NULL;
    }
    XkbFreeComponentNames(&names, FALSE);
    XkbSetCauseXkbReq(&cause, X_kbGetKbdByName, client);
    XkbUpdateAllDeviceIndicators(NULL, &cause);

    return Success;
}

/***====================================================================***/

static int
ComputeDeviceLedInfoSize(DeviceIntPtr dev,
                         unsigned int what, XkbSrvLedInfoPtr sli)
{
    int nNames, nMaps;
    register unsigned n, bit;

    if (sli == NULL)
        return 0;
    nNames = nMaps = 0;
    if ((what & XkbXI_IndicatorNamesMask) == 0)
        sli->namesPresent = 0;
    if ((what & XkbXI_IndicatorMapsMask) == 0)
        sli->mapsPresent = 0;

    for (n = 0, bit = 1; n < XkbNumIndicators; n++, bit <<= 1) {
        if (sli->names && sli->names[n] != None) {
            sli->namesPresent |= bit;
            nNames++;
        }
        if (sli->maps && XkbIM_InUse(&sli->maps[n])) {
            sli->mapsPresent |= bit;
            nMaps++;
        }
    }
    return (nNames * 4) + (nMaps * SIZEOF(xkbIndicatorMapWireDesc));
}

static int
CheckDeviceLedFBs(DeviceIntPtr dev,
                  int class,
                  int id, xkbGetDeviceInfoReply * rep, ClientPtr client)
{
    int nFBs = 0;
    int length = 0;
    Bool classOk;

    if (class == XkbDfltXIClass) {
        if (dev->kbdfeed)
            class = KbdFeedbackClass;
        else if (dev->leds)
            class = LedFeedbackClass;
        else {
            client->errorValue = _XkbErrCode2(XkbErr_BadClass, class);
            return XkbKeyboardErrorCode;
        }
    }
    classOk = FALSE;
    if ((dev->kbdfeed) &&
        ((class == KbdFeedbackClass) || (class == XkbAllXIClasses))) {
        KbdFeedbackPtr kf;

        classOk = TRUE;
        for (kf = dev->kbdfeed; (kf); kf = kf->next) {
            if ((id != XkbAllXIIds) && (id != XkbDfltXIId) &&
                (id != kf->ctrl.id))
                continue;
            nFBs++;
            length += SIZEOF(xkbDeviceLedsWireDesc);
            if (!kf->xkb_sli)
                kf->xkb_sli = XkbAllocSrvLedInfo(dev, kf, NULL, 0);
            length += ComputeDeviceLedInfoSize(dev, rep->present, kf->xkb_sli);
            if (id != XkbAllXIIds)
                break;
        }
    }
    if ((dev->leds) &&
        ((class == LedFeedbackClass) || (class == XkbAllXIClasses))) {
        LedFeedbackPtr lf;

        classOk = TRUE;
        for (lf = dev->leds; (lf); lf = lf->next) {
            if ((id != XkbAllXIIds) && (id != XkbDfltXIId) &&
                (id != lf->ctrl.id))
                continue;
            nFBs++;
            length += SIZEOF(xkbDeviceLedsWireDesc);
            if (!lf->xkb_sli)
                lf->xkb_sli = XkbAllocSrvLedInfo(dev, NULL, lf, 0);
            length += ComputeDeviceLedInfoSize(dev, rep->present, lf->xkb_sli);
            if (id != XkbAllXIIds)
                break;
        }
    }
    if (nFBs > 0) {
        rep->nDeviceLedFBs = nFBs;
        rep->length += (length / 4);
        return Success;
    }
    if (classOk)
        client->errorValue = _XkbErrCode2(XkbErr_BadId, id);
    else
        client->errorValue = _XkbErrCode2(XkbErr_BadClass, class);
    return XkbKeyboardErrorCode;
}

static int
SendDeviceLedInfo(XkbSrvLedInfoPtr sli, ClientPtr client)
{
    xkbDeviceLedsWireDesc wire;
    int length;

    length = 0;
    wire.ledClass = sli->class;
    wire.ledID = sli->id;
    wire.namesPresent = sli->namesPresent;
    wire.mapsPresent = sli->mapsPresent;
    wire.physIndicators = sli->physIndicators;
    wire.state = sli->effectiveState;
    if (client->swapped) {
        swaps(&wire.ledClass);
        swaps(&wire.ledID);
        swapl(&wire.namesPresent);
        swapl(&wire.mapsPresent);
        swapl(&wire.physIndicators);
        swapl(&wire.state);
    }
    WriteToClient(client, SIZEOF(xkbDeviceLedsWireDesc), &wire);
    length += SIZEOF(xkbDeviceLedsWireDesc);
    if (sli->namesPresent | sli->mapsPresent) {
        register unsigned i, bit;

        if (sli->namesPresent) {
            CARD32 awire;

            for (i = 0, bit = 1; i < XkbNumIndicators; i++, bit <<= 1) {
                if (sli->namesPresent & bit) {
                    awire = (CARD32) sli->names[i];
                    if (client->swapped) {
                        swapl(&awire);
                    }
                    WriteToClient(client, 4, &awire);
                    length += 4;
                }
            }
        }
        if (sli->mapsPresent) {
            for (i = 0, bit = 1; i < XkbNumIndicators; i++, bit <<= 1) {
                xkbIndicatorMapWireDesc iwire;

                if (sli->mapsPresent & bit) {
                    iwire.flags = sli->maps[i].flags;
                    iwire.whichGroups = sli->maps[i].which_groups;
                    iwire.groups = sli->maps[i].groups;
                    iwire.whichMods = sli->maps[i].which_mods;
                    iwire.mods = sli->maps[i].mods.mask;
                    iwire.realMods = sli->maps[i].mods.real_mods;
                    iwire.virtualMods = sli->maps[i].mods.vmods;
                    iwire.ctrls = sli->maps[i].ctrls;
                    if (client->swapped) {
                        swaps(&iwire.virtualMods);
                        swapl(&iwire.ctrls);
                    }
                    WriteToClient(client, SIZEOF(xkbIndicatorMapWireDesc),
                                  &iwire);
                    length += SIZEOF(xkbIndicatorMapWireDesc);
                }
            }
        }
    }
    return length;
}

static int
SendDeviceLedFBs(DeviceIntPtr dev,
                 int class, int id, unsigned wantLength, ClientPtr client)
{
    int length = 0;

    if (class == XkbDfltXIClass) {
        if (dev->kbdfeed)
            class = KbdFeedbackClass;
        else if (dev->leds)
            class = LedFeedbackClass;
    }
    if ((dev->kbdfeed) &&
        ((class == KbdFeedbackClass) || (class == XkbAllXIClasses))) {
        KbdFeedbackPtr kf;

        for (kf = dev->kbdfeed; (kf); kf = kf->next) {
            if ((id == XkbAllXIIds) || (id == XkbDfltXIId) ||
                (id == kf->ctrl.id)) {
                length += SendDeviceLedInfo(kf->xkb_sli, client);
                if (id != XkbAllXIIds)
                    break;
            }
        }
    }
    if ((dev->leds) &&
        ((class == LedFeedbackClass) || (class == XkbAllXIClasses))) {
        LedFeedbackPtr lf;

        for (lf = dev->leds; (lf); lf = lf->next) {
            if ((id == XkbAllXIIds) || (id == XkbDfltXIId) ||
                (id == lf->ctrl.id)) {
                length += SendDeviceLedInfo(lf->xkb_sli, client);
                if (id != XkbAllXIIds)
                    break;
            }
        }
    }
    if (length == wantLength)
        return Success;
    else
        return BadLength;
}

int
ProcXkbGetDeviceInfo(ClientPtr client)
{
    DeviceIntPtr dev;
    xkbGetDeviceInfoReply rep;
    int status, nDeviceLedFBs;
    unsigned length, nameLen;
    CARD16 ledClass, ledID;
    unsigned wanted;
    char *str;

    REQUEST(xkbGetDeviceInfoReq);
    REQUEST_SIZE_MATCH(xkbGetDeviceInfoReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    wanted = stuff->wanted;

    CHK_ANY_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
    CHK_MASK_LEGAL(0x01, wanted, XkbXI_AllDeviceFeaturesMask);

    if ((!dev->button) || ((stuff->nBtns < 1) && (!stuff->allBtns)))
        wanted &= ~XkbXI_ButtonActionsMask;
    if ((!dev->kbdfeed) && (!dev->leds))
        wanted &= ~XkbXI_IndicatorsMask;

    nameLen = XkbSizeCountedString(dev->name);
    rep = (xkbGetDeviceInfoReply) {
        .type = X_Reply,
        .deviceID = dev->id,
        .sequenceNumber = client->sequence,
        .length = nameLen / 4,
        .present = wanted,
        .supported = XkbXI_AllDeviceFeaturesMask,
        .unsupported = 0,
        .nDeviceLedFBs = 0,
        .firstBtnWanted = 0,
        .nBtnsWanted = 0,
        .firstBtnRtrn = 0,
        .nBtnsRtrn = 0,
        .totalBtns = dev->button ? dev->button->numButtons : 0,
        .hasOwnState = (dev->key && dev->key->xkbInfo),
        .dfltKbdFB = dev->kbdfeed ? dev->kbdfeed->ctrl.id : XkbXINone,
        .dfltLedFB = dev->leds ? dev->leds->ctrl.id : XkbXINone,
        .devType = dev->xinput_type
    };

    ledClass = stuff->ledClass;
    ledID = stuff->ledID;

    if (wanted & XkbXI_ButtonActionsMask) {
        if (stuff->allBtns) {
            stuff->firstBtn = 0;
            stuff->nBtns = dev->button->numButtons;
        }

        if ((stuff->firstBtn + stuff->nBtns) > dev->button->numButtons) {
            client->errorValue = _XkbErrCode4(0x02, dev->button->numButtons,
                                              stuff->firstBtn, stuff->nBtns);
            return BadValue;
        }
        else {
            rep.firstBtnWanted = stuff->firstBtn;
            rep.nBtnsWanted = stuff->nBtns;
            if (dev->button->xkb_acts != NULL) {
                XkbAction *act;
                register int i;

                rep.firstBtnRtrn = stuff->firstBtn;
                rep.nBtnsRtrn = stuff->nBtns;
                act = &dev->button->xkb_acts[rep.firstBtnWanted];
                for (i = 0; i < rep.nBtnsRtrn; i++, act++) {
                    if (act->type != XkbSA_NoAction)
                        break;
                }
                rep.firstBtnRtrn += i;
                rep.nBtnsRtrn -= i;
                act =
                    &dev->button->xkb_acts[rep.firstBtnRtrn + rep.nBtnsRtrn -
                                           1];
                for (i = 0; i < rep.nBtnsRtrn; i++, act--) {
                    if (act->type != XkbSA_NoAction)
                        break;
                }
                rep.nBtnsRtrn -= i;
            }
            rep.length += (rep.nBtnsRtrn * SIZEOF(xkbActionWireDesc)) / 4;
        }
    }

    if (wanted & XkbXI_IndicatorsMask) {
        status = CheckDeviceLedFBs(dev, ledClass, ledID, &rep, client);
        if (status != Success)
            return status;
    }
    length = rep.length * 4;
    nDeviceLedFBs = rep.nDeviceLedFBs;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.present);
        swaps(&rep.supported);
        swaps(&rep.unsupported);
        swaps(&rep.nDeviceLedFBs);
        swaps(&rep.dfltKbdFB);
        swaps(&rep.dfltLedFB);
        swapl(&rep.devType);
    }
    WriteToClient(client, SIZEOF(xkbGetDeviceInfoReply), &rep);

    str = malloc(nameLen);
    if (!str)
        return BadAlloc;
    XkbWriteCountedString(str, dev->name, client->swapped);
    WriteToClient(client, nameLen, str);
    free(str);
    length -= nameLen;

    if (rep.nBtnsRtrn > 0) {
        int sz;
        xkbActionWireDesc *awire;

        sz = rep.nBtnsRtrn * SIZEOF(xkbActionWireDesc);
        awire = (xkbActionWireDesc *) &dev->button->xkb_acts[rep.firstBtnRtrn];
        WriteToClient(client, sz, awire);
        length -= sz;
    }
    if (nDeviceLedFBs > 0) {
        status = SendDeviceLedFBs(dev, ledClass, ledID, length, client);
        if (status != Success)
            return status;
    }
    else if (length != 0) {
        ErrorF("[xkb] Internal Error!  BadLength in ProcXkbGetDeviceInfo\n");
        ErrorF("[xkb]                  Wrote %d fewer bytes than expected\n",
               length);
        return BadLength;
    }
    return Success;
}

static char *
CheckSetDeviceIndicators(char *wire,
                         DeviceIntPtr dev,
                         int num, int *status_rtrn, ClientPtr client)
{
    xkbDeviceLedsWireDesc *ledWire;
    int i;
    XkbSrvLedInfoPtr sli;

    ledWire = (xkbDeviceLedsWireDesc *) wire;
    for (i = 0; i < num; i++) {
        if (client->swapped) {
            swaps(&ledWire->ledClass);
            swaps(&ledWire->ledID);
            swapl(&ledWire->namesPresent);
            swapl(&ledWire->mapsPresent);
            swapl(&ledWire->physIndicators);
        }

        sli = XkbFindSrvLedInfo(dev, ledWire->ledClass, ledWire->ledID,
                                XkbXI_IndicatorsMask);
        if (sli != NULL) {
            register int n;
            register unsigned bit;
            int nMaps, nNames;
            CARD32 *atomWire;
            xkbIndicatorMapWireDesc *mapWire;

            nMaps = nNames = 0;
            for (n = 0, bit = 1; n < XkbNumIndicators; n++, bit <<= 1) {
                if (ledWire->namesPresent & bit)
                    nNames++;
                if (ledWire->mapsPresent & bit)
                    nMaps++;
            }
            atomWire = (CARD32 *) &ledWire[1];
            if (nNames > 0) {
                for (n = 0; n < nNames; n++) {
                    if (client->swapped) {
                        swapl(atomWire);
                    }
                    CHK_ATOM_OR_NONE3(((Atom) (*atomWire)), client->errorValue,
                                      *status_rtrn, NULL);
                    atomWire++;
                }
            }
            mapWire = (xkbIndicatorMapWireDesc *) atomWire;
            if (nMaps > 0) {
                for (n = 0; n < nMaps; n++) {
                    if (client->swapped) {
                        swaps(&mapWire->virtualMods);
                        swapl(&mapWire->ctrls);
                    }
                    CHK_MASK_LEGAL3(0x21, mapWire->whichGroups,
                                    XkbIM_UseAnyGroup,
                                    client->errorValue, *status_rtrn, NULL);
                    CHK_MASK_LEGAL3(0x22, mapWire->whichMods, XkbIM_UseAnyMods,
                                    client->errorValue, *status_rtrn, NULL);
                    mapWire++;
                }
            }
            ledWire = (xkbDeviceLedsWireDesc *) mapWire;
        }
        else {
            /* SHOULD NEVER HAPPEN */
            return (char *) ledWire;
        }
    }
    return (char *) ledWire;
}

static char *
SetDeviceIndicators(char *wire,
                    DeviceIntPtr dev,
                    unsigned changed,
                    int num,
                    int *status_rtrn,
                    ClientPtr client, xkbExtensionDeviceNotify * ev)
{
    xkbDeviceLedsWireDesc *ledWire;
    int i;
    XkbEventCauseRec cause;
    unsigned namec, mapc, statec;
    xkbExtensionDeviceNotify ed;
    XkbChangesRec changes;
    DeviceIntPtr kbd;

    memset((char *) &ed, 0, sizeof(xkbExtensionDeviceNotify));
    memset((char *) &changes, 0, sizeof(XkbChangesRec));
    XkbSetCauseXkbReq(&cause, X_kbSetDeviceInfo, client);
    ledWire = (xkbDeviceLedsWireDesc *) wire;
    for (i = 0; i < num; i++) {
        register int n;
        register unsigned bit;
        CARD32 *atomWire;
        xkbIndicatorMapWireDesc *mapWire;
        XkbSrvLedInfoPtr sli;

        namec = mapc = statec = 0;
        sli = XkbFindSrvLedInfo(dev, ledWire->ledClass, ledWire->ledID,
                                XkbXI_IndicatorMapsMask);
        if (!sli) {
            /* SHOULD NEVER HAPPEN!! */
            return (char *) ledWire;
        }

        atomWire = (CARD32 *) &ledWire[1];
        if (changed & XkbXI_IndicatorNamesMask) {
            namec = sli->namesPresent | ledWire->namesPresent;
            memset((char *) sli->names, 0, XkbNumIndicators * sizeof(Atom));
        }
        if (ledWire->namesPresent) {
            sli->namesPresent = ledWire->namesPresent;
            memset((char *) sli->names, 0, XkbNumIndicators * sizeof(Atom));
            for (n = 0, bit = 1; n < XkbNumIndicators; n++, bit <<= 1) {
                if (ledWire->namesPresent & bit) {
                    sli->names[n] = (Atom) *atomWire;
                    if (sli->names[n] == None)
                        ledWire->namesPresent &= ~bit;
                    atomWire++;
                }
            }
        }
        mapWire = (xkbIndicatorMapWireDesc *) atomWire;
        if (changed & XkbXI_IndicatorMapsMask) {
            mapc = sli->mapsPresent | ledWire->mapsPresent;
            sli->mapsPresent = ledWire->mapsPresent;
            memset((char *) sli->maps, 0,
                   XkbNumIndicators * sizeof(XkbIndicatorMapRec));
        }
        if (ledWire->mapsPresent) {
            for (n = 0, bit = 1; n < XkbNumIndicators; n++, bit <<= 1) {
                if (ledWire->mapsPresent & bit) {
                    sli->maps[n].flags = mapWire->flags;
                    sli->maps[n].which_groups = mapWire->whichGroups;
                    sli->maps[n].groups = mapWire->groups;
                    sli->maps[n].which_mods = mapWire->whichMods;
                    sli->maps[n].mods.mask = mapWire->mods;
                    sli->maps[n].mods.real_mods = mapWire->realMods;
                    sli->maps[n].mods.vmods = mapWire->virtualMods;
                    sli->maps[n].ctrls = mapWire->ctrls;
                    mapWire++;
                }
            }
        }
        if (changed & XkbXI_IndicatorStateMask) {
            statec = sli->effectiveState ^ ledWire->state;
            sli->explicitState &= ~statec;
            sli->explicitState |= (ledWire->state & statec);
        }
        if (namec)
            XkbApplyLedNameChanges(dev, sli, namec, &ed, &changes, &cause);
        if (mapc)
            XkbApplyLedMapChanges(dev, sli, mapc, &ed, &changes, &cause);
        if (statec)
            XkbApplyLedStateChanges(dev, sli, statec, &ed, &changes, &cause);

        kbd = dev;
        if ((sli->flags & XkbSLI_HasOwnState) == 0)
            kbd = inputInfo.keyboard;

        XkbFlushLedEvents(dev, kbd, sli, &ed, &changes, &cause);
        ledWire = (xkbDeviceLedsWireDesc *) mapWire;
    }
    return (char *) ledWire;
}

static int
_XkbSetDeviceInfo(ClientPtr client, DeviceIntPtr dev,
                  xkbSetDeviceInfoReq * stuff)
{
    char *wire;

    wire = (char *) &stuff[1];
    if (stuff->change & XkbXI_ButtonActionsMask) {
        if (!dev->button) {
            client->errorValue = _XkbErrCode2(XkbErr_BadClass, ButtonClass);
            return XkbKeyboardErrorCode;
        }
        if ((stuff->firstBtn + stuff->nBtns) > dev->button->numButtons) {
            client->errorValue =
                _XkbErrCode4(0x02, stuff->firstBtn, stuff->nBtns,
                             dev->button->numButtons);
            return BadMatch;
        }
        wire += (stuff->nBtns * SIZEOF(xkbActionWireDesc));
    }
    if (stuff->change & XkbXI_IndicatorsMask) {
        int status = Success;

        wire = CheckSetDeviceIndicators(wire, dev, stuff->nDeviceLedFBs,
                                        &status, client);
        if (status != Success)
            return status;
    }
    if (((wire - ((char *) stuff)) / 4) != stuff->length)
        return BadLength;

    return Success;
}

static int
_XkbSetDeviceInfoCheck(ClientPtr client, DeviceIntPtr dev,
                       xkbSetDeviceInfoReq * stuff)
{
    char *wire;
    xkbExtensionDeviceNotify ed;

    memset((char *) &ed, 0, SIZEOF(xkbExtensionDeviceNotify));
    ed.deviceID = dev->id;
    wire = (char *) &stuff[1];
    if (stuff->change & XkbXI_ButtonActionsMask) {
        int nBtns, sz, i;
        XkbAction *acts;
        DeviceIntPtr kbd;

        nBtns = dev->button->numButtons;
        acts = dev->button->xkb_acts;
        if (acts == NULL) {
            acts = calloc(nBtns, sizeof(XkbAction));
            if (!acts)
                return BadAlloc;
            dev->button->xkb_acts = acts;
        }
        sz = stuff->nBtns * SIZEOF(xkbActionWireDesc);
        memcpy((char *) &acts[stuff->firstBtn], (char *) wire, sz);
        wire += sz;
        ed.reason |= XkbXI_ButtonActionsMask;
        ed.firstBtn = stuff->firstBtn;
        ed.nBtns = stuff->nBtns;

        if (dev->key)
            kbd = dev;
        else
            kbd = inputInfo.keyboard;
        acts = &dev->button->xkb_acts[stuff->firstBtn];
        for (i = 0; i < stuff->nBtns; i++, acts++) {
            if (acts->type != XkbSA_NoAction)
                XkbSetActionKeyMods(kbd->key->xkbInfo->desc, acts, 0);
        }
    }
    if (stuff->change & XkbXI_IndicatorsMask) {
        int status = Success;

        wire = SetDeviceIndicators(wire, dev, stuff->change,
                                   stuff->nDeviceLedFBs, &status, client, &ed);
        if (status != Success)
            return status;
    }
    if ((stuff->change) && (ed.reason))
        XkbSendExtensionDeviceNotify(dev, client, &ed);
    return Success;
}

int
ProcXkbSetDeviceInfo(ClientPtr client)
{
    DeviceIntPtr dev;
    int rc;

    REQUEST(xkbSetDeviceInfoReq);
    REQUEST_AT_LEAST_SIZE(xkbSetDeviceInfoReq);

    if (!(client->xkbClientFlags & _XkbClientInitialized))
        return BadAccess;

    CHK_ANY_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);
    CHK_MASK_LEGAL(0x01, stuff->change, XkbXI_AllFeaturesMask);

    rc = _XkbSetDeviceInfoCheck(client, dev, stuff);

    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd ||
        stuff->deviceSpec == XkbUseCorePtr) {
        DeviceIntPtr other;

        for (other = inputInfo.devices; other; other = other->next) {
            if (((other != dev) && !IsMaster(other) &&
                 GetMaster(other, MASTER_KEYBOARD) == dev) &&
                ((stuff->deviceSpec == XkbUseCoreKbd && other->key) ||
                 (stuff->deviceSpec == XkbUseCorePtr && other->button))) {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other,
                              DixManageAccess);
                if (rc == Success) {
                    rc = _XkbSetDeviceInfoCheck(client, other, stuff);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    /* checks done, apply */
    rc = _XkbSetDeviceInfo(client, dev, stuff);
    if (rc != Success)
        return rc;

    if (stuff->deviceSpec == XkbUseCoreKbd ||
        stuff->deviceSpec == XkbUseCorePtr) {
        DeviceIntPtr other;

        for (other = inputInfo.devices; other; other = other->next) {
            if (((other != dev) && !IsMaster(other) &&
                 GetMaster(other, MASTER_KEYBOARD) == dev) &&
                ((stuff->deviceSpec == XkbUseCoreKbd && other->key) ||
                 (stuff->deviceSpec == XkbUseCorePtr && other->button))) {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other,
                              DixManageAccess);
                if (rc == Success) {
                    rc = _XkbSetDeviceInfo(client, other, stuff);
                    if (rc != Success)
                        return rc;
                }
            }
        }
    }

    return Success;
}

/***====================================================================***/

int
ProcXkbSetDebuggingFlags(ClientPtr client)
{
    CARD32 newFlags, newCtrls, extraLength;
    xkbSetDebuggingFlagsReply rep;
    int rc;

    REQUEST(xkbSetDebuggingFlagsReq);
    REQUEST_AT_LEAST_SIZE(xkbSetDebuggingFlagsReq);

    rc = XaceHook(XACE_SERVER_ACCESS, client, DixDebugAccess);
    if (rc != Success)
        return rc;

    newFlags = xkbDebugFlags & (~stuff->affectFlags);
    newFlags |= (stuff->flags & stuff->affectFlags);
    newCtrls = xkbDebugCtrls & (~stuff->affectCtrls);
    newCtrls |= (stuff->ctrls & stuff->affectCtrls);
    if (xkbDebugFlags || newFlags || stuff->msgLength) {
        ErrorF("[xkb] XkbDebug: Setting debug flags to 0x%lx\n",
               (long) newFlags);
        if (newCtrls != xkbDebugCtrls)
            ErrorF("[xkb] XkbDebug: Setting debug controls to 0x%lx\n",
                   (long) newCtrls);
    }
    extraLength = (stuff->length << 2) - sz_xkbSetDebuggingFlagsReq;
    if (stuff->msgLength > 0) {
        char *msg;

        if (extraLength < XkbPaddedSize(stuff->msgLength)) {
            ErrorF
                ("[xkb] XkbDebug: msgLength= %d, length= %ld (should be %d)\n",
                 stuff->msgLength, (long) extraLength,
                 XkbPaddedSize(stuff->msgLength));
            return BadLength;
        }
        msg = (char *) &stuff[1];
        if (msg[stuff->msgLength - 1] != '\0') {
            ErrorF("[xkb] XkbDebug: message not null-terminated\n");
            return BadValue;
        }
        ErrorF("[xkb] XkbDebug: %s\n", msg);
    }
    xkbDebugFlags = newFlags;
    xkbDebugCtrls = newCtrls;

    rep = (xkbSetDebuggingFlagsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .currentFlags = newFlags,
        .currentCtrls = newCtrls,
        .supportedFlags = ~0,
        .supportedCtrls = ~0
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.currentFlags);
        swapl(&rep.currentCtrls);
        swapl(&rep.supportedFlags);
        swapl(&rep.supportedCtrls);
    }
    WriteToClient(client, SIZEOF(xkbSetDebuggingFlagsReply), &rep);
    return Success;
}

/***====================================================================***/

static int
ProcXkbDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_kbUseExtension:
        return ProcXkbUseExtension(client);
    case X_kbSelectEvents:
        return ProcXkbSelectEvents(client);
    case X_kbBell:
        return ProcXkbBell(client);
    case X_kbGetState:
        return ProcXkbGetState(client);
    case X_kbLatchLockState:
        return ProcXkbLatchLockState(client);
    case X_kbGetControls:
        return ProcXkbGetControls(client);
    case X_kbSetControls:
        return ProcXkbSetControls(client);
    case X_kbGetMap:
        return ProcXkbGetMap(client);
    case X_kbSetMap:
        return ProcXkbSetMap(client);
    case X_kbGetCompatMap:
        return ProcXkbGetCompatMap(client);
    case X_kbSetCompatMap:
        return ProcXkbSetCompatMap(client);
    case X_kbGetIndicatorState:
        return ProcXkbGetIndicatorState(client);
    case X_kbGetIndicatorMap:
        return ProcXkbGetIndicatorMap(client);
    case X_kbSetIndicatorMap:
        return ProcXkbSetIndicatorMap(client);
    case X_kbGetNamedIndicator:
        return ProcXkbGetNamedIndicator(client);
    case X_kbSetNamedIndicator:
        return ProcXkbSetNamedIndicator(client);
    case X_kbGetNames:
        return ProcXkbGetNames(client);
    case X_kbSetNames:
        return ProcXkbSetNames(client);
    case X_kbGetGeometry:
        return ProcXkbGetGeometry(client);
    case X_kbSetGeometry:
        return ProcXkbSetGeometry(client);
    case X_kbPerClientFlags:
        return ProcXkbPerClientFlags(client);
    case X_kbListComponents:
        return ProcXkbListComponents(client);
    case X_kbGetKbdByName:
        return ProcXkbGetKbdByName(client);
    case X_kbGetDeviceInfo:
        return ProcXkbGetDeviceInfo(client);
    case X_kbSetDeviceInfo:
        return ProcXkbSetDeviceInfo(client);
    case X_kbSetDebuggingFlags:
        return ProcXkbSetDebuggingFlags(client);
    default:
        return BadRequest;
    }
}

static int
XkbClientGone(void *data, XID id)
{
    DevicePtr pXDev = (DevicePtr) data;

    if (!XkbRemoveResourceClient(pXDev, id)) {
        ErrorF
            ("[xkb] Internal Error! bad RemoveResourceClient in XkbClientGone\n");
    }
    return 1;
}

void
XkbExtensionInit(void)
{
    ExtensionEntry *extEntry;

    RT_XKBCLIENT = CreateNewResourceType(XkbClientGone, "XkbClient");
    if (!RT_XKBCLIENT)
        return;

    if (!XkbInitPrivates())
        return;

    if ((extEntry = AddExtension(XkbName, XkbNumberEvents, XkbNumberErrors,
                                 ProcXkbDispatch, SProcXkbDispatch,
                                 NULL, StandardMinorOpcode))) {
        XkbReqCode = (unsigned char) extEntry->base;
        XkbEventBase = (unsigned char) extEntry->eventBase;
        XkbErrorBase = (unsigned char) extEntry->errorBase;
        XkbKeyboardErrorCode = XkbErrorBase + XkbKeyboard;
    }
    return;
}
@


1.14
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@a5694 1

d5709 1
d6020 3
@


1.13
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a2218 2
        int sz = maxRG * sizeof(XkbRadioGroupRec);

d2220 2
a2221 1
            xkbi->radioGroups = realloc(xkbi->radioGroups, sz);
d2223 1
a2223 1
            xkbi->radioGroups = calloc(1, sz);
d2702 2
a2703 3
    size = rep->length * 4;
    if (size > 0) {
        data = malloc(size);
d2710 2
d2859 3
a2861 3
            compat->sym_interpret = realloc(compat->sym_interpret,
                                            compat->num_si *
                                            sizeof(XkbSymInterpretRec));
d3089 1
a3089 2
    length = rep->length * 4;
    if (length > 0) {
d3092 1
a3092 1
        to = map = malloc(length);
d3096 2
a4866 1

d4875 1
a4875 2
        len = rep->length * 4;
        start = desc = malloc(len);
d4878 1
@


1.12
log
@Update to xserver 1.16.4.
Contains fix for CVE-2015-0255. ok dcoppa@@
@
text
@d9 2
a10 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d12 1
a12 1
Silicon Graphics makes no representation about the suitability 
d16 2
a17 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d19 3
a21 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
d3989 1
a3989 1
    Atom bad;
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d4960 2
a4961 2
static char *
_GetCountedString(char **wire_inout, Bool swap)
d4963 2
a4964 2
    char *wire, *str;
    CARD16 len, *plen;
d4967 3
a4969 9
    plen = (CARD16 *) wire;
    if (swap) {
        swaps(plen);
    }
    len = *plen;
    str = malloc(len + 1);
    if (str) {
        memcpy(str, &wire[2], len);
        str[len] = '\0';
d4971 12
a4982 3
    wire += XkbPaddedSize(len + 2);
    *wire_inout = wire;
    return str;
d4991 2
d4994 1
d4997 1
d5000 4
a5003 4
        swapl(&dWire->any.name);
        swaps(&dWire->any.top);
        swaps(&dWire->any.left);
        swaps(&dWire->any.angle);
d5006 1
a5006 1
    doodad = XkbAddGeomDoodad(geom, section, dWire->any.name);
d5011 3
a5013 3
    doodad->any.top = dWire->any.top;
    doodad->any.left = dWire->any.left;
    doodad->any.angle = dWire->any.angle;
d5036 1
d5038 2
a5039 2
            swaps(&dWire->text.width);
            swaps(&dWire->text.height);
d5041 2
a5042 2
        doodad->text.width = dWire->text.width;
        doodad->text.height = dWire->text.height;
d5044 8
a5051 2
        doodad->text.text = _GetCountedString(&wire, client->swapped);
        doodad->text.font = _GetCountedString(&wire, client->swapped);
d5086 3
a5088 1
        doodad->logo.logo_name = _GetCountedString(&wire, client->swapped);
d5320 3
a5322 1
    geom->label_font = _GetCountedString(&wire, client->swapped);
d5327 5
a5331 5
        name = _GetCountedString(&wire, client->swapped);
        if (!name)
            return BadAlloc;
        val = _GetCountedString(&wire, client->swapped);
        if (!val) {
d5333 1
a5333 1
            return BadAlloc;
d5367 3
a5369 3
        name = _GetCountedString(&wire, client->swapped);
        if (!name)
            return BadAlloc;
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d373 1
a373 1
    pointer ctrl;
d393 1
a393 1
        ctrl = (pointer) &(k->ctrl);
d425 1
a425 1
        ctrl = (pointer) &(b->ctrl);
d4422 1
a4422 1
XkbWriteCountedString(char *wire, char *str, Bool swap)
a5952 1
        int i, nG, nTG;
d5959 1
a5959 12
        *xkb->ctrls = *old_xkb->ctrls;
        for (nG = nTG = 0, i = xkb->min_key_code; i <= xkb->max_key_code; i++) {
            nG = XkbKeyNumGroups(xkb, i);
            if (nG >= XkbNumKbdGroups) {
                nTG = XkbNumKbdGroups;
                break;
            }
            if (nG > nTG) {
                nTG = nG;
            }
        }
        xkb->ctrls->num_groups = nTG;
d5982 1
a5982 1
                XkbCopyDeviceKeymap(tmpd, dev);
d6811 1
a6811 1
XkbClientGone(pointer data, XID id)
@


1.10.2.1
log
@Fix for CVE-2015-0255. Check strings length against request size.
@
text
@d4960 2
a4961 2
static Status
_GetCountedString(char **wire_inout, ClientPtr client, char **str)
d4963 2
a4964 2
    char *wire, *next;
    CARD16 len;
d4967 9
a4975 3
    len = *(CARD16 *) wire;
    if (client->swapped) {
        swaps(&len);
d4977 3
a4979 12
    next = wire + XkbPaddedSize(len + 2);
    /* Check we're still within the size of the request */
    if (client->req_len <
        bytes_to_int32(next - (char *) client->requestBuffer))
        return BadValue;
    *str = malloc(len + 1);
    if (!*str)
        return BadAlloc;
    memcpy(*str, &wire[2], len);
    *(*str + len) = '\0';
    *wire_inout = next;
    return Success;
a4987 2
    xkbAnyDoodadWireDesc any;
    xkbTextDoodadWireDesc text;
a4988 1
    Status status;
a4990 1
    any = dWire->any;
d4993 4
a4996 4
        swapl(&any.name);
        swaps(&any.top);
        swaps(&any.left);
        swaps(&any.angle);
d4999 1
a4999 1
    doodad = XkbAddGeomDoodad(geom, section, any.name);
d5004 3
a5006 3
    doodad->any.top = any.top;
    doodad->any.left = any.left;
    doodad->any.angle = any.angle;
a5028 1
        text = dWire->text;
d5030 2
a5031 2
            swaps(&text.width);
            swaps(&text.height);
d5033 2
a5034 2
        doodad->text.width = text.width;
        doodad->text.height = text.height;
d5036 2
a5037 8
        status = _GetCountedString(&wire, client, &doodad->text.text);
        if (status != Success)
            return status;
        status = _GetCountedString(&wire, client, &doodad->text.font);
        if (status != Success) {
            free (doodad->text.text);
            return status;
        }
d5072 1
a5072 3
        status = _GetCountedString(&wire, client, &doodad->logo.logo_name);
        if (status != Success)
            return status;
d5304 1
a5304 3
    status = _GetCountedString(&wire, client, &geom->label_font);
    if (status != Success)
        return status;
d5309 5
a5313 5
        status = _GetCountedString(&wire, client, &name);
        if (status != Success)
            return status;
        status = _GetCountedString(&wire, client, &val);
        if (status != Success) {
d5315 1
a5315 1
            return status;
d5349 3
a5351 3
        status = _GetCountedString(&wire, client, &name);
        if (status != Success)
            return status;
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d3076 1
a3987 1
    XkbNamesRec *names;
a3992 1
    names = xkb->names;
@


1.9.4.1
log
@Fix for CVE-2015-0255. Check strings length against request size.
@
text
@d4961 2
a4962 2
static Status
_GetCountedString(char **wire_inout, ClientPtr client, char **str)
d4964 2
a4965 2
    char *wire, *next;
    CARD16 len;
d4968 9
a4976 3
    len = *(CARD16 *) wire;
    if (client->swapped) {
        swaps(&len);
d4978 3
a4980 12
    next = wire + XkbPaddedSize(len + 2);
    /* Check we're still within the size of the request */
    if (client->req_len <
        bytes_to_int32(next - (char *) client->requestBuffer))
        return BadValue;
    *str = malloc(len + 1);
    if (!*str)
        return BadAlloc;
    memcpy(*str, &wire[2], len);
    *(*str + len) = '\0';
    *wire_inout = next;
    return Success;
a4988 2
    xkbAnyDoodadWireDesc any;
    xkbTextDoodadWireDesc text;
a4989 1
    Status status;
a4991 1
    any = dWire->any;
d4994 4
a4997 4
        swapl(&any.name);
        swaps(&any.top);
        swaps(&any.left);
        swaps(&any.angle);
d5000 1
a5000 1
    doodad = XkbAddGeomDoodad(geom, section, any.name);
d5005 3
a5007 3
    doodad->any.top = any.top;
    doodad->any.left = any.left;
    doodad->any.angle = any.angle;
a5029 1
        text = dWire->text;
d5031 2
a5032 2
            swaps(&text.width);
            swaps(&text.height);
d5034 2
a5035 2
        doodad->text.width = text.width;
        doodad->text.height = text.height;
d5037 2
a5038 8
        status = _GetCountedString(&wire, client, &doodad->text.text);
        if (status != Success)
            return status;
        status = _GetCountedString(&wire, client, &doodad->text.font);
        if (status != Success) {
            free (doodad->text.text);
            return status;
        }
d5073 1
a5073 3
        status = _GetCountedString(&wire, client, &doodad->logo.logo_name);
        if (status != Success)
            return status;
d5305 1
a5305 3
    status = _GetCountedString(&wire, client, &geom->label_font);
    if (status != Success)
        return status;
d5310 5
a5314 5
        status = _GetCountedString(&wire, client, &name);
        if (status != Success)
            return status;
        status = _GetCountedString(&wire, client, &val);
        if (status != Success) {
d5316 1
a5316 1
            return status;
d5350 3
a5352 3
        status = _GetCountedString(&wire, client, &name);
        if (status != Success)
            return status;
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d39 1
d60 2
a61 2
    int rc = lf(&(dev), id, client, access_mode, &why);\
    if (rc != Success) {\
d63 1
a63 1
	return rc;\
d185 8
a192 7
    memset(&rep, 0, sizeof(xkbUseExtensionReply));
    rep.type = X_Reply;
    rep.supported = supported;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.serverMajor = SERVER_XKB_MAJOR_VERSION;
    rep.serverMinor = SERVER_XKB_MINOR_VERSION;
d198 1
a198 1
    WriteToClient(client, SIZEOF(xkbUseExtensionReply), (char *) &rep);
d582 16
a597 15
    memset(&rep, 0, sizeof(xkbGetStateReply));
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.deviceID = dev->id;
    rep.mods = XkbStateFieldFromRec(xkb) & 0xff;
    rep.baseMods = xkb->base_mods;
    rep.lockedMods = xkb->locked_mods;
    rep.latchedMods = xkb->latched_mods;
    rep.group = xkb->group;
    rep.baseGroup = xkb->base_group;
    rep.latchedGroup = xkb->latched_group;
    rep.lockedGroup = xkb->locked_group;
    rep.compatState = xkb->compat_state;
    rep.ptrBtnState = xkb->ptr_buttons;
d602 1
a602 1
    WriteToClient(client, SIZEOF(xkbGetStateReply), (char *) &rep);
d694 32
a725 30
    rep.type = X_Reply;
    rep.length = bytes_to_int32(SIZEOF(xkbGetControlsReply) -
                                SIZEOF(xGenericReply));
    rep.sequenceNumber = client->sequence;
    rep.deviceID = ((DeviceIntPtr) dev)->id;
    rep.numGroups = xkb->num_groups;
    rep.groupsWrap = xkb->groups_wrap;
    rep.internalMods = xkb->internal.mask;
    rep.ignoreLockMods = xkb->ignore_lock.mask;
    rep.internalRealMods = xkb->internal.real_mods;
    rep.ignoreLockRealMods = xkb->ignore_lock.real_mods;
    rep.internalVMods = xkb->internal.vmods;
    rep.ignoreLockVMods = xkb->ignore_lock.vmods;
    rep.enabledCtrls = xkb->enabled_ctrls;
    rep.repeatDelay = xkb->repeat_delay;
    rep.repeatInterval = xkb->repeat_interval;
    rep.slowKeysDelay = xkb->slow_keys_delay;
    rep.debounceDelay = xkb->debounce_delay;
    rep.mkDelay = xkb->mk_delay;
    rep.mkInterval = xkb->mk_interval;
    rep.mkTimeToMax = xkb->mk_time_to_max;
    rep.mkMaxSpeed = xkb->mk_max_speed;
    rep.mkCurve = xkb->mk_curve;
    rep.mkDfltBtn = xkb->mk_dflt_btn;
    rep.axTimeout = xkb->ax_timeout;
    rep.axtCtrlsMask = xkb->axt_ctrls_mask;
    rep.axtCtrlsValues = xkb->axt_ctrls_values;
    rep.axtOptsMask = xkb->axt_opts_mask;
    rep.axtOptsValues = xkb->axt_opts_values;
    rep.axOptions = xkb->ax_options;
d749 1
a749 1
    WriteToClient(client, SIZEOF(xkbGetControlsReply), (char *) &rep);
d1029 1
a1029 1
            xkbKTMapEntryWireDesc *wire;
d1032 1
a1032 1
            wire = (xkbKTMapEntryWireDesc *) buf;
d1034 6
a1039 6
            for (n = 0; n < type->map_count; n++, wire++, entry++) {
                wire->active = entry->active;
                wire->mask = entry->mods.mask;
                wire->level = entry->level;
                wire->realMods = entry->mods.real_mods;
                wire->virtualMods = entry->mods.vmods;
d1041 1
a1041 1
                    swaps(&wire->virtualMods);
d1044 1
a1044 1
            buf = (char *) wire;
d1441 1
a1441 1
    WriteToClient(client, (i = SIZEOF(xkbGetMapReply)), (char *) rep);
d1467 10
a1476 8
    memset(&rep, 0, sizeof(xkbGetMapReply));
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = (SIZEOF(xkbGetMapReply) - SIZEOF(xGenericReply)) >> 2;
    rep.deviceID = dev->id;
    rep.present = stuff->partial | stuff->full;
    rep.minKeyCode = xkb->min_key_code;
    rep.maxKeyCode = xkb->max_key_code;
d1653 2
a1654 2
            mapWire = (xkbKTSetMapEntryWireDesc *) & wire[1];
            preWire = (xkbModsWireDesc *) & mapWire[wire->nMapEntries];
d1764 2
a1765 2
        pSyms = (KeySym *) & wire[1];
        wire = (xkbSymMapWireDesc *) & pSyms[wire->nSyms];
d2042 1
a2042 1
            preWire = (xkbModsWireDesc *) & mapWire[wire->nMapEntries];
d2101 1
a2101 1
        pSyms = (KeySym *) & wire[1];
d2119 1
a2119 1
        wire = (xkbSymMapWireDesc *) & pSyms[wire->nSyms];
d2411 1
a2411 1
        (!CheckKeyTypes(client, xkb, req, (xkbKeyTypeWireDesc **) & values,
d2436 1
a2436 1
                       (xkbSymMapWireDesc **) & values, &error))) {
d2450 1
a2450 1
         (xkb, req, (xkbBehaviorWireDesc **) & values, &error))) {
d2472 1
a2472 1
         (xkb, req, (xkbVModMapWireDesc **) & values, &error))) {
d2754 1
a2754 1
    WriteToClient(client, SIZEOF(xkbGetCompatMapReply), (char *) rep);
d2781 8
a2788 6
    rep.type = X_Reply;
    rep.deviceID = dev->id;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.firstSI = stuff->firstSI;
    rep.nSI = stuff->nSI;
a2905 1
        unsigned i, bit;
d3045 7
a3051 5
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.deviceID = dev->id;
    rep.state = sli->effectiveState;
d3057 1
a3057 1
    WriteToClient(client, SIZEOF(xkbGetIndicatorStateReply), (char *) &rep);
d3131 1
a3131 1
    WriteToClient(client, SIZEOF(xkbGetIndicatorMapReply), (char *) rep);
d3133 1
a3133 1
        WriteToClient(client, length, (char *) map);
d3158 7
a3164 5
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.deviceID = dev->id;
    rep.which = stuff->which;
d3315 7
a3321 5
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.deviceID = dev->id;
    rep.indicator = stuff->indicator;
d3360 1
a3360 1
    WriteToClient(client, SIZEOF(xkbGetNamedIndicatorReply), (char *) &rep);
d3874 1
a3874 1
    WriteToClient(client, SIZEOF(xkbGetNamesReply), (char *) rep);
d3897 12
a3908 16
    memset(&rep, 0, sizeof(xkbGetNamesReply));
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.deviceID = dev->id;
    rep.which = stuff->which;
    rep.nTypes = xkb->map->num_types;
    rep.firstKey = xkb->min_key_code;
    rep.nKeys = XkbNumKeys(xkb);
    if (xkb->names != NULL) {
        rep.nKeyAliases = xkb->names->num_key_aliases;
        rep.nRadioGroups = xkb->names->num_rg;
    }
    else {
        rep.nKeyAliases = rep.nRadioGroups = 0;
    }
d4917 1
a4917 1
    WriteToClient(client, SIZEOF(xkbGetGeometryReply), (char *) rep);
d4946 6
a4951 4
    rep.type = X_Reply;
    rep.deviceID = dev->id;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
d5100 1
a5100 1
    rWire = (xkbOverlayRowWireDesc *) & olWire[1];
d5112 1
a5112 1
        kWire = (xkbOverlayKeyWireDesc *) & rWire[1];
d5166 1
a5166 1
        rWire = (xkbRowWireDesc *) & sWire[1];
d5182 1
a5182 1
            kWire = (xkbKeyWireDesc *) & rWire[1];
d5204 1
a5204 1
            rWire = (xkbRowWireDesc *) & kWire[rWire->nKeys];
d5268 1
a5268 1
                ptWire = (xkbPointWireDesc *) & olWire[1];
a5497 4
    memset(&rep, 0, sizeof(xkbPerClientFlagsReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
d5533 10
a5542 9
    rep.supported = XkbPCF_AllFlagsMask;
    rep.value = client->xkbClientFlags & XkbPCF_AllFlagsMask;
    if (interest) {
        rep.autoCtrls = interest->autoCtrls;
        rep.autoCtrlValues = interest->autoCtrlValues;
    }
    else {
        rep.autoCtrls = rep.autoCtrlValues = 0;
    }
d5550 1
a5550 1
    WriteToClient(client, SIZEOF(xkbPerClientFlagsReply), (char *) &rep);
a5622 1
    int status;
d5624 2
a5625 1
    XkbSrvListInfoRec list;
d5635 4
a5638 1
    status = Success;
d5640 7
a5646 10
    memset(&list, 0, sizeof(XkbSrvListInfoRec));
    list.maxRtrn = stuff->maxNames;
    list.pattern[_XkbListKeycodes] = GetComponentSpec(&str, FALSE, &status);
    list.pattern[_XkbListTypes] = GetComponentSpec(&str, FALSE, &status);
    list.pattern[_XkbListCompat] = GetComponentSpec(&str, FALSE, &status);
    list.pattern[_XkbListSymbols] = GetComponentSpec(&str, FALSE, &status);
    list.pattern[_XkbListGeometry] = GetComponentSpec(&str, FALSE, &status);
    if (status != Success)
        return status;
    len = str - ((unsigned char *) stuff);
d5649 13
a5661 19
    if ((status = XkbDDXList(dev, &list, client)) != Success) {
        free(list.pool);
        list.pool = NULL;
        return status;
    }
    memset(&rep, 0, sizeof(xkbListComponentsReply));
    rep.type = X_Reply;
    rep.deviceID = dev->id;
    rep.sequenceNumber = client->sequence;
    rep.length = XkbPaddedSize(list.nPool) / 4;
    rep.nKeymaps = 0;
    rep.nKeycodes = list.nFound[_XkbListKeycodes];
    rep.nTypes = list.nFound[_XkbListTypes];
    rep.nCompatMaps = list.nFound[_XkbListCompat];
    rep.nSymbols = list.nFound[_XkbListSymbols];
    rep.nGeometries = list.nFound[_XkbListGeometry];
    rep.extra = 0;
    if (list.nTotal > list.maxRtrn)
        rep.extra = (list.nTotal - list.maxRtrn);
d5673 1
a5673 6
    WriteToClient(client, SIZEOF(xkbListComponentsReply), (char *) &rep);
    if (list.nPool && list.pool) {
        WriteToClient(client, XkbPaddedSize(list.nPool), (char *) list.pool);
        free(list.pool);
        list.pool = NULL;
    }
d5940 1
a5940 1
    WriteToClient(client, SIZEOF(xkbGetKbdByNameReply), (char *) &rep);
d6137 1
a6137 1
    WriteToClient(client, SIZEOF(xkbDeviceLedsWireDesc), (char *) &wire);
d6151 1
a6151 1
                    WriteToClient(client, 4, (char *) &awire);
d6174 1
a6174 1
                                  (char *) &iwire);
d6255 19
a6273 25
    memset((char *) &rep, 0, SIZEOF(xkbGetDeviceInfoReply));
    rep.type = X_Reply;
    rep.deviceID = dev->id;
    rep.sequenceNumber = client->sequence;
    rep.length = nameLen / 4;
    rep.present = wanted;
    rep.supported = XkbXI_AllDeviceFeaturesMask;
    rep.unsupported = 0;
    rep.firstBtnWanted = rep.nBtnsWanted = 0;
    rep.firstBtnRtrn = rep.nBtnsRtrn = 0;
    if (dev->button)
        rep.totalBtns = dev->button->numButtons;
    else
        rep.totalBtns = 0;
    rep.devType = dev->xinput_type;
    rep.hasOwnState = (dev->key && dev->key->xkbInfo);
    rep.nDeviceLedFBs = 0;
    if (dev->kbdfeed)
        rep.dfltKbdFB = dev->kbdfeed->ctrl.id;
    else
        rep.dfltKbdFB = XkbXINone;
    if (dev->leds)
        rep.dfltLedFB = dev->leds->ctrl.id;
    else
        rep.dfltLedFB = XkbXINone;
a6277 2
    rep.firstBtnWanted = rep.nBtnsWanted = 0;
    rep.firstBtnRtrn = rep.nBtnsRtrn = 0;
d6336 1
a6336 1
    WriteToClient(client, SIZEOF(xkbGetDeviceInfoReply), (char *) &rep);
d6351 2
a6352 2
        awire = (xkbActionWireDesc *) & dev->button->xkb_acts[rep.firstBtnRtrn];
        WriteToClient(client, sz, (char *) awire);
d6739 9
a6747 7
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.currentFlags = newFlags;
    rep.currentCtrls = newCtrls;
    rep.supportedFlags = ~0;
    rep.supportedCtrls = ~0;
d6755 1
a6755 1
    WriteToClient(client, SIZEOF(xkbSetDebuggingFlagsReply), (char *) &rep);
@


1.7
log
@Update to xserver 1.11.2
@
text
@d46 6
a51 6
int		XkbEventBase;
static	int	XkbErrorBase;
int		XkbReqCode;
int		XkbKeyboardErrorCode;
CARD32		xkbDebugFlags = 0;
static CARD32	xkbDebugCtrls = 0;
d53 1
a53 1
static RESTYPE	RT_XKBCLIENT;
d160 2
a161 3
    xkbUseExtensionReply	rep;
    register int n;
    int	supported;
d165 18
a182 17
	/* pre-release version 0.65 is compatible with 1.00 */
	supported= ((SERVER_XKB_MAJOR_VERSION==1)&&
		    (stuff->wantedMajor==0)&&(stuff->wantedMinor==65));
    }
    else supported = 1;

    if ((supported) && (!(client->xkbClientFlags&_XkbClientInitialized))) {
	client->xkbClientFlags= _XkbClientInitialized;
	client->vMajor= stuff->wantedMajor;
	client->vMinor= stuff->wantedMinor;
    }
    else if (xkbDebugFlags&0x1) {
	ErrorF("[xkb] Rejecting client %d (0x%lx) (wants %d.%02d, have %d.%02d)\n",
					client->index,
					(long)client->clientAsMask,
					stuff->wantedMajor,stuff->wantedMinor,
					SERVER_XKB_MAJOR_VERSION,SERVER_XKB_MINOR_VERSION);
d191 4
a194 4
    if ( client->swapped ) {
	swaps(&rep.sequenceNumber, n);
	swaps(&rep.serverMajor, n);
	swaps(&rep.serverMinor, n);
d196 1
a196 1
    WriteToClient(client,SIZEOF(xkbUseExtensionReply), (char *)&rep);
d205 4
a208 3
    unsigned		legal;
    DeviceIntPtr 	dev;
    XkbInterestPtr	masks;
d213 2
a214 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d218 14
a231 13
    if (((stuff->affectWhich&XkbMapNotifyMask)!=0)&&(stuff->affectMap)) {
	client->mapNotifyMask&= ~stuff->affectMap;
	client->mapNotifyMask|= (stuff->affectMap&stuff->map);
    }
    if ((stuff->affectWhich&(~XkbMapNotifyMask))==0) 
	return Success;

    masks = XkbFindClientResource((DevicePtr)dev,client);
    if (!masks){
	XID id = FakeClientID(client->index);
	if (!AddResource(id,RT_XKBCLIENT,dev))
	    return BadAlloc;
	masks= XkbAddClientResource((DevicePtr)dev,client,id);
d234 123
a356 116
	union {
	    CARD8	*c8;
	    CARD16	*c16;
	    CARD32	*c32;
	} from,to;
	register unsigned bit,ndx,maskLeft,dataLeft,size;

	from.c8= (CARD8 *)&stuff[1];
	dataLeft= (stuff->length*4)-SIZEOF(xkbSelectEventsReq);
	maskLeft= (stuff->affectWhich&(~XkbMapNotifyMask));
	for (ndx=0,bit=1; (maskLeft!=0); ndx++, bit<<=1) {
	    if ((bit&maskLeft)==0)
		continue;
	    maskLeft&= ~bit;
	    switch (ndx) {
		case XkbNewKeyboardNotify:
		    to.c16= &client->newKeyboardNotifyMask;
		    legal= XkbAllNewKeyboardEventsMask;
		    size= 2;
		    break;
		case XkbStateNotify:
		    to.c16= &masks->stateNotifyMask;
		    legal= XkbAllStateEventsMask;
		    size= 2;
		    break;
		case XkbControlsNotify:
		    to.c32= &masks->ctrlsNotifyMask;
		    legal= XkbAllControlEventsMask;
		    size= 4;
		    break;
		case XkbIndicatorStateNotify:
		    to.c32= &masks->iStateNotifyMask;
		    legal= XkbAllIndicatorEventsMask;
		    size= 4;
		    break;
		case XkbIndicatorMapNotify:
		    to.c32= &masks->iMapNotifyMask;
		    legal= XkbAllIndicatorEventsMask;
		    size= 4;
		    break;
		case XkbNamesNotify:
		    to.c16= &masks->namesNotifyMask;
		    legal= XkbAllNameEventsMask;
		    size= 2;
		    break;
		case XkbCompatMapNotify:
		    to.c8= &masks->compatNotifyMask;
		    legal= XkbAllCompatMapEventsMask;
		    size= 1;
		    break;
		case XkbBellNotify:
		    to.c8= &masks->bellNotifyMask;
		    legal= XkbAllBellEventsMask;
		    size= 1;
		    break;
		case XkbActionMessage:
		    to.c8= &masks->actionMessageMask;
		    legal= XkbAllActionMessagesMask;
		    size= 1;
		    break;
		case XkbAccessXNotify:
		    to.c16= &masks->accessXNotifyMask;
		    legal= XkbAllAccessXEventsMask;
		    size= 2;
		    break;
		case XkbExtensionDeviceNotify:
		    to.c16= &masks->extDevNotifyMask;
		    legal= XkbAllExtensionDeviceEventsMask;
		    size= 2;
		    break;
		default:
		    client->errorValue = _XkbErrCode2(33,bit);
		    return BadValue;
	    }

	    if (stuff->clear&bit) {
		if (size==2)		to.c16[0]= 0;
		else if (size==4)	to.c32[0]= 0;
		else			to.c8[0]=  0;
	    }
	    else if (stuff->selectAll&bit) {
		if (size==2)		to.c16[0]= ~0;
		else if (size==4)	to.c32[0]= ~0;
		else			to.c8[0]=  ~0;
	    }
	    else {
		if (dataLeft<(size*2))
		    return BadLength;
		if (size==2) {
		    CHK_MASK_MATCH(ndx,from.c16[0],from.c16[1]);
		    CHK_MASK_LEGAL(ndx,from.c16[0],legal);
		    to.c16[0]&= ~from.c16[0];
		    to.c16[0]|= (from.c16[0]&from.c16[1]);
		}
		else if (size==4) {
		    CHK_MASK_MATCH(ndx,from.c32[0],from.c32[1]);
		    CHK_MASK_LEGAL(ndx,from.c32[0],legal);
		    to.c32[0]&= ~from.c32[0];
		    to.c32[0]|= (from.c32[0]&from.c32[1]);
		}
		else  {
		    CHK_MASK_MATCH(ndx,from.c8[0],from.c8[1]);
		    CHK_MASK_LEGAL(ndx,from.c8[0],legal);
		    to.c8[0]&= ~from.c8[0];
		    to.c8[0]|= (from.c8[0]&from.c8[1]);
		    size= 2;
		}
		from.c8+= (size*2);
		dataLeft-= (size*2);
	    }
	}
	if (dataLeft>2) {
	    ErrorF("[xkb] Extra data (%d bytes) after SelectEvents\n",dataLeft);
	    return BadLength;
	}
	return Success;
d370 4
a373 4
    int         base;
    pointer     ctrl;
    int         oldPitch, oldDuration;
    int         newPercent;
d376 4
a379 3
        KbdFeedbackPtr	k;
        if (bellID==XkbDfltXIId)
            k= dev->kbdfeed;
d381 1
a381 1
            for (k=dev->kbdfeed; k; k=k->next) {
d387 1
a387 1
            client->errorValue = _XkbErrCode2(0x5,bellID);
d392 13
a404 11
        oldPitch= k->ctrl.bell_pitch;
        oldDuration= k->ctrl.bell_duration;
        if (pitch!=0) {
            if (pitch==-1)
                k->ctrl.bell_pitch= defaultKeyboardControl.bell_pitch;
            else k->ctrl.bell_pitch= pitch;
        }
        if (duration!=0) {
            if (duration==-1)
                k->ctrl.bell_duration= defaultKeyboardControl.bell_duration;
            else k->ctrl.bell_duration= duration;
d408 4
a411 3
        BellFeedbackPtr	b;
        if (bellID==XkbDfltXIId)
            b= dev->bell;
d413 1
a413 1
            for (b=dev->bell; b; b=b->next) {
d419 1
a419 1
            client->errorValue = _XkbErrCode2(0x6,bellID);
d424 13
a436 11
        oldPitch= b->ctrl.pitch;
        oldDuration= b->ctrl.duration;
        if (pitch!=0) {
            if (pitch==-1)
                b->ctrl.pitch= defaultKeyboardControl.bell_pitch;
            else b->ctrl.pitch= pitch;
        }
        if (duration!=0) {
            if (duration==-1)
                b->ctrl.duration= defaultKeyboardControl.bell_duration;
            else b->ctrl.duration= duration;
d444 1
a444 1
    newPercent = (base * percent)/100;
d446 3
a448 2
         newPercent = base + newPercent;
    else newPercent = base - newPercent + percent;
d451 2
a452 3
                  dev, newPercent, ctrl, bellClass,
                  name, pWin, client);
    if ((pitch!=0)||(duration!=0)) {
d454 7
a460 6
            KbdFeedbackPtr      k;
            k= (KbdFeedbackPtr)ctrl;
            if (pitch!=0)
                k->ctrl.bell_pitch= oldPitch;
            if (duration!=0)
                k->ctrl.bell_duration= oldDuration;
d463 7
a469 6
            BellFeedbackPtr     b;
            b= (BellFeedbackPtr)ctrl;
            if (pitch!=0)
                b->ctrl.pitch= oldPitch;
            if (duration!=0)
                b->ctrl.duration= oldDuration;
d481 1
a481 1
    WindowPtr	 pWin;
d486 2
a487 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d493 4
a496 3
    if ((stuff->forceSound)&&(stuff->eventOnly)) {
	client->errorValue=_XkbErrCode3(0x1,stuff->forceSound,stuff->eventOnly);
	return BadMatch;
d499 6
a504 2
	client->errorValue = _XkbErrCode2(0x2,stuff->percent);
	return BadValue;
d506 3
a508 7
    if (stuff->duration<-1) {
	client->errorValue = _XkbErrCode2(0x3,stuff->duration);
	return BadValue;
    }
    if (stuff->pitch<-1) {
	client->errorValue = _XkbErrCode2(0x4,stuff->pitch);
	return BadValue;
d512 4
a515 3
	if (dev->kbdfeed!=NULL)
	     stuff->bellClass= KbdFeedbackClass;
	else stuff->bellClass= BellFeedbackClass;
d518 6
a523 6
    if (stuff->window!=None) {
	rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
	if (rc != Success) {
	    client->errorValue= stuff->window;
	    return rc;
	}
d525 2
a526 1
    else pWin= NULL;
d542 1
a542 2
                            (stuff->deviceSpec == XkbUseCorePtr)))
    {
d544 4
a547 4
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
d556 1
a556 1
        rc = Success; /* reset to success, that's what we got for the VCK */
d568 3
a570 3
    DeviceIntPtr	dev;
    xkbGetStateReply	 rep;
    XkbStateRec		*xkb;
d574 2
a575 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d579 1
a579 1
    xkb= &dev->key->xkbInfo->state;
d581 2
a582 2
    rep.type= X_Reply;
    rep.sequenceNumber= client->sequence;
d596 2
a597 3
	register int n;
	swaps(&rep.sequenceNumber,n);
	swaps(&rep.ptrBtnState,n);
d599 1
a599 1
    WriteToClient(client, SIZEOF(xkbGetStateReply), (char *)&rep);
d610 1
a610 1
    XkbStateRec	oldState,*newState;
d619 1
a619 1
	return BadAccess;
d628 2
a629 1
        if ((tmpd == dev) || (!IsMaster(tmpd) && GetMaster(tmpd, MASTER_KEYBOARD) == dev)) {
d637 2
a638 1
                newState->locked_mods |= (stuff->affectModLocks & stuff->modLocks);
d665 1
a665 1
	        }
d679 2
a680 3
    XkbControlsPtr	xkb;
    DeviceIntPtr 	dev;
    register int 	n;
d685 2
a686 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d689 1
a689 1
    
d692 2
a693 2
    rep.length = bytes_to_int32(SIZEOF(xkbGetControlsReply)-
		  SIZEOF(xGenericReply));
d695 1
a695 1
    rep.deviceID = ((DeviceIntPtr)dev)->id;
d721 1
a721 1
    memcpy(rep.perKeyRepeat,xkb->per_key_repeat,XkbPerKeyBitArraySize);
d723 20
a742 20
    	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length,n);
	swaps(&rep.internalVMods, n);
	swaps(&rep.ignoreLockVMods, n);
	swapl(&rep.enabledCtrls, n);
	swaps(&rep.repeatDelay, n);
	swaps(&rep.repeatInterval, n);
	swaps(&rep.slowKeysDelay, n);
	swaps(&rep.debounceDelay, n);
	swaps(&rep.mkDelay, n);
	swaps(&rep.mkInterval, n);
	swaps(&rep.mkTimeToMax, n);
	swaps(&rep.mkMaxSpeed, n);
	swaps(&rep.mkCurve, n);
	swaps(&rep.axTimeout, n);
	swapl(&rep.axtCtrlsMask, n);
	swapl(&rep.axtCtrlsValues, n);
	swaps(&rep.axtOptsMask, n);
	swaps(&rep.axtOptsValues, n);
	swaps(&rep.axOptions, n);
d744 1
a744 1
    WriteToClient(client, SIZEOF(xkbGetControlsReply), (char *)&rep);
d751 7
a757 7
    DeviceIntPtr 	dev, tmpd;
    XkbSrvInfoPtr	xkbi;
    XkbControlsPtr	ctrl;
    XkbControlsRec	new,old;
    xkbControlsNotify	cn;
    XkbEventCauseRec	cause;
    XkbSrvLedInfoPtr	sli;
d763 1
a763 1
	return BadAccess;
d771 2
a772 1
        if ((tmpd == dev) || (!IsMaster(tmpd) && GetMaster(tmpd, MASTER_KEYBOARD) == dev)) {
d791 1
a791 2
                                    XkbMaskForVMask(xkbi->desc,
                                                    new.internal.vmods);
d807 1
a807 2
                                       XkbMaskForVMask(xkbi->desc,
                                                       new.ignore_lock.vmods);
d865 1
a865 1
                    client->errorValue = _XkbErrCode2(0x0C,0);
d897 1
a897 1
                new.groups_wrap= stuff->groupsWrap;
d909 1
a909 1
            
d945 2
a946 2
            old= *ctrl;
            *ctrl= new;
d975 1
a975 1
XkbSizeKeyTypes(XkbDescPtr xkb,xkbGetMapReply *rep)
d977 2
a978 2
    XkbKeyTypeRec 	*type;
    unsigned		i,len;
d980 15
a994 15
    len= 0;
    if (((rep->present&XkbKeyTypesMask)==0)||(rep->nTypes<1)||
	(!xkb)||(!xkb->map)||(!xkb->map->types)) {
	rep->present&= ~XkbKeyTypesMask;
	rep->firstType= rep->nTypes= 0;
	return 0;
    }
    type= &xkb->map->types[rep->firstType];
    for (i=0;i<rep->nTypes;i++,type++){
	len+= SIZEOF(xkbKeyTypeWireDesc);
	if (type->map_count>0) {
	    len+= (type->map_count*SIZEOF(xkbKTMapEntryWireDesc));
	    if (type->preserve)
		len+= (type->map_count*SIZEOF(xkbModsWireDesc));
	}
d1000 2
a1001 4
XkbWriteKeyTypes(	XkbDescPtr		xkb,
			xkbGetMapReply *	rep,
			char *			buf,
			ClientPtr 		client)
d1003 2
a1004 2
    XkbKeyTypePtr	type;
    unsigned		i;
d1007 50
a1056 50
    type= &xkb->map->types[rep->firstType];
    for (i=0;i<rep->nTypes;i++,type++) {
	register unsigned n;
	wire= (xkbKeyTypeWireDesc *)buf;
	wire->mask = type->mods.mask;
	wire->realMods = type->mods.real_mods;
	wire->virtualMods = type->mods.vmods;
	wire->numLevels = type->num_levels;
	wire->nMapEntries = type->map_count;
	wire->preserve = (type->preserve!=NULL);
	if (client->swapped) {
	    register int n;
	    swaps(&wire->virtualMods,n);
	}	

	buf= (char *)&wire[1];
	if (wire->nMapEntries>0) {
	    xkbKTMapEntryWireDesc *	wire;
	    XkbKTMapEntryPtr		entry;
	    wire= (xkbKTMapEntryWireDesc *)buf;
	    entry= type->map;
	    for (n=0;n<type->map_count;n++,wire++,entry++) {
		wire->active= entry->active;
		wire->mask= entry->mods.mask;
		wire->level= entry->level;
		wire->realMods= entry->mods.real_mods;
		wire->virtualMods= entry->mods.vmods;
		if (client->swapped) {
		    register int n;
		    swaps(&wire->virtualMods,n);
		}
	    }
	    buf= (char *)wire;
	    if (type->preserve!=NULL) {
		xkbModsWireDesc *	pwire;
		XkbModsPtr		preserve;
		pwire= (xkbModsWireDesc *)buf;
		preserve= type->preserve;
		for (n=0;n<type->map_count;n++,pwire++,preserve++) {
		    pwire->mask= preserve->mask;
		    pwire->realMods= preserve->real_mods;
		    pwire->virtualMods= preserve->vmods;
		    if (client->swapped) {
			register int n;
			swaps(&pwire->virtualMods,n);
		    }
		}
		buf= (char *)pwire;
	    }
	}
d1062 1
a1062 1
XkbSizeKeySyms(XkbDescPtr xkb,xkbGetMapReply *rep)
d1064 10
a1073 10
    XkbSymMapPtr	symMap;
    unsigned		i,len;
    unsigned		nSyms,nSymsThisKey;

    if (((rep->present&XkbKeySymsMask)==0)||(rep->nKeySyms<1)||
	(!xkb)||(!xkb->map)||(!xkb->map->key_sym_map)) {
	rep->present&= ~XkbKeySymsMask;
	rep->firstKeySym= rep->nKeySyms= 0;
	rep->totalSyms= 0;
	return 0;
d1075 1
a1075 1
    len= rep->nKeySyms*SIZEOF(xkbSymMapWireDesc);
d1077 5
a1081 5
    for (i=nSyms=0;i<rep->nKeySyms;i++,symMap++) {
	if (symMap->offset!=0) {
	    nSymsThisKey= XkbNumGroups(symMap->group_info)*symMap->width;
	    nSyms+= nSymsThisKey;
	}
d1083 2
a1084 2
    len+= nSyms*4;
    rep->totalSyms= nSyms;
d1089 1
a1089 1
XkbSizeVirtualMods(XkbDescPtr xkb,xkbGetMapReply *rep)
d1091 1
a1091 1
register unsigned i,nMods,bit;
d1093 9
a1101 9
    if (((rep->present&XkbVirtualModsMask)==0)||(rep->virtualMods==0)||
	(!xkb)||(!xkb->server)) {
	rep->present&= ~XkbVirtualModsMask;
	rep->virtualMods= 0;
	return 0;
    }
    for (i=nMods=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
        if (rep->virtualMods&bit)
	    nMods++;
d1107 2
a1108 1
XkbWriteKeySyms(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,ClientPtr client)
d1110 4
a1113 4
register KeySym *	pSym;
XkbSymMapPtr		symMap;
xkbSymMapWireDesc *	outMap;
register unsigned	i;
d1116 26
a1141 24
    for (i=0;i<rep->nKeySyms;i++,symMap++) {
	outMap = (xkbSymMapWireDesc *)buf;
	outMap->ktIndex[0] = symMap->kt_index[0];
	outMap->ktIndex[1] = symMap->kt_index[1];
	outMap->ktIndex[2] = symMap->kt_index[2];
	outMap->ktIndex[3] = symMap->kt_index[3];
	outMap->groupInfo = symMap->group_info;
	outMap->width= symMap->width;
	outMap->nSyms = symMap->width*XkbNumGroups(symMap->group_info);
	buf= (char *)&outMap[1];
	if (outMap->nSyms==0)
	    continue;

	pSym = &xkb->map->syms[symMap->offset];
	memcpy((char *)buf,(char *)pSym,outMap->nSyms*4);
	if (client->swapped) {
	    register int n,nSyms= outMap->nSyms;
	    swaps(&outMap->nSyms,n);
	    while (nSyms-->0) {
		swapl(buf,n);
		buf+= 4;
	    }
	}
	else buf+= outMap->nSyms*4;
d1147 1
a1147 1
XkbSizeKeyActions(XkbDescPtr xkb,xkbGetMapReply *rep)
d1149 2
a1150 2
    unsigned		i,len,nActs;
    register KeyCode	firstKey;
d1152 11
a1162 11
    if (((rep->present&XkbKeyActionsMask)==0)||(rep->nKeyActs<1)||
	(!xkb)||(!xkb->server)||(!xkb->server->key_acts)) {
	rep->present&= ~XkbKeyActionsMask;
	rep->firstKeyAct= rep->nKeyActs= 0;
	rep->totalActs= 0;
	return 0;
    }
    firstKey= rep->firstKeyAct;
    for (nActs=i=0;i<rep->nKeyActs;i++) {
	if (xkb->server->key_acts[i+firstKey]!=0)
	    nActs+= XkbKeyNumActions(xkb,i+firstKey);
d1164 2
a1165 2
    len= XkbPaddedSize(rep->nKeyActs)+(nActs*SIZEOF(xkbActionWireDesc));
    rep->totalActs= nActs;
d1170 2
a1171 2
XkbWriteKeyActions(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,
							ClientPtr client)
d1173 24
a1196 22
    unsigned		i;
    CARD8 *		numDesc;
    XkbAnyAction *	actDesc;

    numDesc = (CARD8 *)buf;
    for (i=0;i<rep->nKeyActs;i++) {
	if (xkb->server->key_acts[i+rep->firstKeyAct]==0)
	     numDesc[i] = 0;
	else numDesc[i] = XkbKeyNumActions(xkb,(i+rep->firstKeyAct));
    }
    buf+= XkbPaddedSize(rep->nKeyActs);

    actDesc = (XkbAnyAction *)buf;
    for (i=0;i<rep->nKeyActs;i++) {
	if (xkb->server->key_acts[i+rep->firstKeyAct]!=0) {
	    unsigned int num;
	    num = XkbKeyNumActions(xkb,(i+rep->firstKeyAct));
	    memcpy((char *)actDesc,
		   (char*)XkbKeyActionsPtr(xkb,(i+rep->firstKeyAct)),
		   num*SIZEOF(xkbActionWireDesc));
	    actDesc+= num;
	}
d1198 1
a1198 1
    buf = (char *)actDesc;
d1203 1
a1203 1
XkbSizeKeyBehaviors(XkbDescPtr xkb,xkbGetMapReply *rep)
d1205 2
a1206 2
    unsigned		i,len,nBhvr;
    XkbBehavior *	bhv;
d1208 11
a1218 11
    if (((rep->present&XkbKeyBehaviorsMask)==0)||(rep->nKeyBehaviors<1)||
	(!xkb)||(!xkb->server)||(!xkb->server->behaviors)) {
	rep->present&= ~XkbKeyBehaviorsMask;
	rep->firstKeyBehavior= rep->nKeyBehaviors= 0;
	rep->totalKeyBehaviors= 0;
	return 0;
    }
    bhv= &xkb->server->behaviors[rep->firstKeyBehavior];
    for (nBhvr=i=0;i<rep->nKeyBehaviors;i++,bhv++) {
	if (bhv->type!=XkbKB_Default)
	    nBhvr++;
d1220 2
a1221 2
    len= nBhvr*SIZEOF(xkbBehaviorWireDesc);
    rep->totalKeyBehaviors= nBhvr;
d1226 2
a1227 2
XkbWriteKeyBehaviors(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,
							ClientPtr client)
d1229 13
a1241 13
    unsigned		i;
    xkbBehaviorWireDesc	*wire;
    XkbBehavior		*pBhvr;

    wire = (xkbBehaviorWireDesc *)buf;
    pBhvr= &xkb->server->behaviors[rep->firstKeyBehavior];
    for (i=0;i<rep->nKeyBehaviors;i++,pBhvr++) {
	if (pBhvr->type!=XkbKB_Default) {
	    wire->key=  i+rep->firstKeyBehavior;
	    wire->type= pBhvr->type;
	    wire->data= pBhvr->data;
	    wire++;
	}
d1243 1
a1243 1
    buf = (char *)wire;
d1248 1
a1248 1
XkbSizeExplicit(XkbDescPtr xkb,xkbGetMapReply *rep)
d1250 1
a1250 1
    unsigned	i,len,nRtrn;
d1252 11
a1262 10
    if (((rep->present&XkbExplicitComponentsMask)==0)||(rep->nKeyExplicit<1)||
	(!xkb)||(!xkb->server)||(!xkb->server->explicit)) {
	rep->present&= ~XkbExplicitComponentsMask;
	rep->firstKeyExplicit= rep->nKeyExplicit= 0;
	rep->totalKeyExplicit= 0;
	return 0;
    }
    for (nRtrn=i=0;i<rep->nKeyExplicit;i++) {
	if (xkb->server->explicit[i+rep->firstKeyExplicit]!=0)
	    nRtrn++;
d1264 2
a1265 2
    rep->totalKeyExplicit= nRtrn;
    len= XkbPaddedSize(nRtrn*2); /* two bytes per non-zero explicit component */
d1270 2
a1271 1
XkbWriteExplicit(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,ClientPtr client)
d1273 3
a1275 3
unsigned	i;
char *		start;
unsigned char *	pExp;
d1277 7
a1283 7
    start= buf;
    pExp= &xkb->server->explicit[rep->firstKeyExplicit];
    for (i=0;i<rep->nKeyExplicit;i++,pExp++) {
	if (*pExp!=0) {
	    *buf++= i+rep->firstKeyExplicit;
	    *buf++= *pExp;
	}
d1285 2
a1286 2
    i= XkbPaddedSize(buf-start)-(buf-start); /* pad to word boundary */
    return buf+i;
d1290 1
a1290 1
XkbSizeModifierMap(XkbDescPtr xkb,xkbGetMapReply *rep)
d1292 1
a1292 1
    unsigned	i,len,nRtrn;
d1294 6
a1299 6
    if (((rep->present&XkbModifierMapMask)==0)||(rep->nModMapKeys<1)||
	(!xkb)||(!xkb->map)||(!xkb->map->modmap)) {
	rep->present&= ~XkbModifierMapMask;
	rep->firstModMapKey= rep->nModMapKeys= 0;
	rep->totalModMapKeys= 0;
	return 0;
d1301 3
a1303 3
    for (nRtrn=i=0;i<rep->nModMapKeys;i++) {
	if (xkb->map->modmap[i+rep->firstModMapKey]!=0)
	    nRtrn++;
d1305 2
a1306 2
    rep->totalModMapKeys= nRtrn;
    len= XkbPaddedSize(nRtrn*2); /* two bytes per non-zero modmap component */
d1311 2
a1312 2
XkbWriteModifierMap(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,
							ClientPtr client)
d1314 3
a1316 3
unsigned	i;
char *		start;
unsigned char *	pMap;
d1318 7
a1324 7
    start= buf;
    pMap= &xkb->map->modmap[rep->firstModMapKey];
    for (i=0;i<rep->nModMapKeys;i++,pMap++) {
	if (*pMap!=0) {
	    *buf++= i+rep->firstModMapKey;
	    *buf++= *pMap;
	}
d1326 2
a1327 2
    i= XkbPaddedSize(buf-start)-(buf-start); /* pad to word boundary */
    return buf+i;
d1331 1
a1331 1
XkbSizeVirtualModMap(XkbDescPtr xkb,xkbGetMapReply *rep)
d1333 1
a1333 1
    unsigned	i,len,nRtrn;
d1335 6
a1340 6
    if (((rep->present&XkbVirtualModMapMask)==0)||(rep->nVModMapKeys<1)||
	(!xkb)||(!xkb->server)||(!xkb->server->vmodmap)) {
	rep->present&= ~XkbVirtualModMapMask;
	rep->firstVModMapKey= rep->nVModMapKeys= 0;
	rep->totalVModMapKeys= 0;
	return 0;
d1342 3
a1344 3
    for (nRtrn=i=0;i<rep->nVModMapKeys;i++) {
	if (xkb->server->vmodmap[i+rep->firstVModMapKey]!=0)
	    nRtrn++;
d1346 2
a1347 2
    rep->totalVModMapKeys= nRtrn;
    len= nRtrn*SIZEOF(xkbVModMapWireDesc);
d1352 2
a1353 2
XkbWriteVirtualModMap(XkbDescPtr xkb,xkbGetMapReply *rep,char *buf,
							ClientPtr client)
d1355 12
a1366 12
unsigned		i;
xkbVModMapWireDesc *	wire;
unsigned short *	pMap;

    wire= (xkbVModMapWireDesc *)buf;
    pMap= &xkb->server->vmodmap[rep->firstVModMapKey];
    for (i=0;i<rep->nVModMapKeys;i++,pMap++) {
	if (*pMap!=0) {
	    wire->key= i+rep->firstVModMapKey;
	    wire->vmods= *pMap;
	    wire++;
	}
d1368 1
a1368 1
    return (char *)wire;
d1372 1
a1372 1
XkbComputeGetMapReplySize(XkbDescPtr xkb,xkbGetMapReply *rep)
d1374 1
a1374 1
int	len;
d1376 11
a1386 11
    rep->minKeyCode= xkb->min_key_code;
    rep->maxKeyCode= xkb->max_key_code;
    len= XkbSizeKeyTypes(xkb,rep);
    len+= XkbSizeKeySyms(xkb,rep);
    len+= XkbSizeKeyActions(xkb,rep);
    len+= XkbSizeKeyBehaviors(xkb,rep);
    len+= XkbSizeVirtualMods(xkb,rep);
    len+= XkbSizeExplicit(xkb,rep);
    len+= XkbSizeModifierMap(xkb,rep);
    len+= XkbSizeVirtualModMap(xkb,rep);
    rep->length+= (len/4);
d1391 1
a1391 1
XkbSendMap(ClientPtr client,XkbDescPtr xkb,xkbGetMapReply *rep)
d1393 2
a1394 2
unsigned	i,len;
char		*desc,*start;
d1396 2
a1397 2
    len= (rep->length*4)-(SIZEOF(xkbGetMapReply)-SIZEOF(xGenericReply));
    start= desc= calloc(1, len);
d1399 29
a1427 27
	return BadAlloc;
    if ( rep->nTypes>0 )
	desc = XkbWriteKeyTypes(xkb,rep,desc,client);
    if ( rep->nKeySyms>0 )
	desc = XkbWriteKeySyms(xkb,rep,desc,client);
    if ( rep->nKeyActs>0 )
	desc = XkbWriteKeyActions(xkb,rep,desc,client);
    if ( rep->totalKeyBehaviors>0 )
	desc = XkbWriteKeyBehaviors(xkb,rep,desc,client);
    if ( rep->virtualMods ) {
	register int sz,bit;
	for (i=sz=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	    if (rep->virtualMods&bit) {
		desc[sz++]= xkb->server->vmods[i];
	    }
	}
	desc+= XkbPaddedSize(sz);
    }
    if ( rep->totalKeyExplicit>0 )
	desc= XkbWriteExplicit(xkb,rep,desc,client);
    if ( rep->totalModMapKeys>0 )
	desc= XkbWriteModifierMap(xkb,rep,desc,client);
    if ( rep->totalVModMapKeys>0 )
	desc= XkbWriteVirtualModMap(xkb,rep,desc,client);
    if ((desc-start)!=(len)) {
	ErrorF("[xkb] BOGUS LENGTH in write keyboard desc, expected %d, got %ld\n",
					len, (unsigned long)(desc-start));
d1430 5
a1434 6
	register int n;
	swaps(&rep->sequenceNumber,n);
	swapl(&rep->length,n);
	swaps(&rep->present,n);
	swaps(&rep->totalSyms,n);
	swaps(&rep->totalActs,n);
d1436 1
a1436 1
    WriteToClient(client, (i=SIZEOF(xkbGetMapReply)), (char *)rep);
d1438 1
a1438 1
    free((char *)start);
d1445 4
a1448 4
    DeviceIntPtr	 dev;
    xkbGetMapReply	 rep;
    XkbDescRec		*xkb;
    int			 n,status;
d1452 3
a1454 3
    
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d1457 3
a1459 3
    CHK_MASK_OVERLAP(0x01,stuff->full,stuff->partial);
    CHK_MASK_LEGAL(0x02,stuff->full,XkbAllMapComponentsMask);
    CHK_MASK_LEGAL(0x03,stuff->partial,XkbAllMapComponentsMask);
d1461 1
a1461 1
    xkb= dev->key->xkbInfo->desc;
d1463 3
a1465 3
    rep.type= X_Reply;
    rep.sequenceNumber= client->sequence;
    rep.length = (SIZEOF(xkbGetMapReply)-SIZEOF(xGenericReply))>>2;
d1467 1
a1467 1
    rep.present = stuff->partial|stuff->full;
d1470 12
a1481 12
    if ( stuff->full&XkbKeyTypesMask ) {
	rep.firstType = 0;
	rep.nTypes = xkb->map->num_types;
    }
    else if (stuff->partial&XkbKeyTypesMask) {
	if (((unsigned)stuff->firstType+stuff->nTypes)>xkb->map->num_types) {
	    client->errorValue = _XkbErrCode4(0x04,xkb->map->num_types,
					stuff->firstType,stuff->nTypes);
	    return BadValue;
	}
	rep.firstType = stuff->firstType;
	rep.nTypes = stuff->nTypes;
d1483 2
a1484 1
    else rep.nTypes = 0;
d1487 87
a1573 81
    n= XkbNumKeys(xkb);
    if ( stuff->full&XkbKeySymsMask ) {
	rep.firstKeySym = xkb->min_key_code;
	rep.nKeySyms = n;
    }
    else if (stuff->partial&XkbKeySymsMask) {
	CHK_KEY_RANGE(0x05,stuff->firstKeySym,stuff->nKeySyms,xkb);
	rep.firstKeySym = stuff->firstKeySym;
	rep.nKeySyms = stuff->nKeySyms;
    }
    else rep.nKeySyms = 0;
    rep.totalSyms= 0;

    if ( stuff->full&XkbKeyActionsMask ) {
	rep.firstKeyAct= xkb->min_key_code;
	rep.nKeyActs= n;
    }
    else if (stuff->partial&XkbKeyActionsMask) {
	CHK_KEY_RANGE(0x07,stuff->firstKeyAct,stuff->nKeyActs,xkb);
	rep.firstKeyAct= stuff->firstKeyAct;
	rep.nKeyActs= stuff->nKeyActs;
    }
    else rep.nKeyActs= 0;
    rep.totalActs= 0;

    if ( stuff->full&XkbKeyBehaviorsMask ) {
	rep.firstKeyBehavior = xkb->min_key_code;
	rep.nKeyBehaviors = n;
    }
    else if (stuff->partial&XkbKeyBehaviorsMask) {
	CHK_KEY_RANGE(0x09,stuff->firstKeyBehavior,stuff->nKeyBehaviors,xkb);
	rep.firstKeyBehavior= stuff->firstKeyBehavior;
	rep.nKeyBehaviors= stuff->nKeyBehaviors;
    }
    else rep.nKeyBehaviors = 0;
    rep.totalKeyBehaviors= 0;

    if (stuff->full&XkbVirtualModsMask)
	rep.virtualMods= ~0;
    else if (stuff->partial&XkbVirtualModsMask)
	rep.virtualMods= stuff->virtualMods;
    
    if (stuff->full&XkbExplicitComponentsMask) {
	rep.firstKeyExplicit= xkb->min_key_code;
	rep.nKeyExplicit= n;
    }
    else if (stuff->partial&XkbExplicitComponentsMask) {
	CHK_KEY_RANGE(0x0B,stuff->firstKeyExplicit,stuff->nKeyExplicit,xkb);
	rep.firstKeyExplicit= stuff->firstKeyExplicit;
	rep.nKeyExplicit= stuff->nKeyExplicit;
    }
    else rep.nKeyExplicit = 0;
    rep.totalKeyExplicit=  0;

    if (stuff->full&XkbModifierMapMask) {
	rep.firstModMapKey= xkb->min_key_code;
	rep.nModMapKeys= n;
    }
    else if (stuff->partial&XkbModifierMapMask) {
	CHK_KEY_RANGE(0x0D,stuff->firstModMapKey,stuff->nModMapKeys,xkb);
	rep.firstModMapKey= stuff->firstModMapKey;
	rep.nModMapKeys= stuff->nModMapKeys;
    }
    else rep.nModMapKeys = 0;
    rep.totalModMapKeys= 0;

    if (stuff->full&XkbVirtualModMapMask) {
	rep.firstVModMapKey= xkb->min_key_code;
	rep.nVModMapKeys= n;
    }
    else if (stuff->partial&XkbVirtualModMapMask) {
	CHK_KEY_RANGE(0x0F,stuff->firstVModMapKey,stuff->nVModMapKeys,xkb);
	rep.firstVModMapKey= stuff->firstVModMapKey;
	rep.nVModMapKeys= stuff->nVModMapKeys;
    }
    else rep.nVModMapKeys = 0;
    rep.totalVModMapKeys= 0;

    if ((status=XkbComputeGetMapReplySize(xkb,&rep))!=Success)
	return status;
    return XkbSendMap(client,xkb,&rep);
d1579 28
a1606 29
CheckKeyTypes(	ClientPtr	client,
		XkbDescPtr	xkb,
		xkbSetMapReq *	req,
		xkbKeyTypeWireDesc **wireRtrn,
		int	 *	nMapsRtrn,
		CARD8 *		mapWidthRtrn)
{
unsigned		nMaps;
register unsigned	i,n;
register CARD8 *	map;
register xkbKeyTypeWireDesc	*wire = *wireRtrn;

    if (req->firstType>((unsigned)xkb->map->num_types)) {
	*nMapsRtrn = _XkbErrCode3(0x01,req->firstType,xkb->map->num_types);
	return 0;
    }
    if (req->flags&XkbSetMapResizeTypes) {
	nMaps = req->firstType+req->nTypes;
	if (nMaps<XkbNumRequiredTypes) {  /* canonical types must be there */
	    *nMapsRtrn= _XkbErrCode4(0x02,req->firstType,req->nTypes,4);
	    return 0;
	}
    }
    else if (req->present&XkbKeyTypesMask) {
	nMaps = xkb->map->num_types;
	if ((req->firstType+req->nTypes)>nMaps) {
	    *nMapsRtrn = req->firstType+req->nTypes;
	    return 0;
	}
d1609 82
a1690 80
	*nMapsRtrn = xkb->map->num_types;
	for (i=0;i<xkb->map->num_types;i++) {
	    mapWidthRtrn[i] = xkb->map->types[i].num_levels;
	}
	return 1;
    }

    for (i=0;i<req->firstType;i++) {
	mapWidthRtrn[i] = xkb->map->types[i].num_levels;
    }
    for (i=0;i<req->nTypes;i++) {
	unsigned	width;
	if (client->swapped) {
	    register int s;
	    swaps(&wire->virtualMods,s);
	}
	n= i+req->firstType;
	width= wire->numLevels;
	if (width<1) {
	    *nMapsRtrn= _XkbErrCode3(0x04,n,width);
	    return 0;
	}
	else if ((n==XkbOneLevelIndex)&&(width!=1)) { /* must be width 1 */
	    *nMapsRtrn= _XkbErrCode3(0x05,n,width);
	    return 0;
	}
	else if ((width!=2)&&
		 ((n==XkbTwoLevelIndex)||(n==XkbKeypadIndex)||
		  (n==XkbAlphabeticIndex))) {
	    /* TWO_LEVEL, ALPHABETIC and KEYPAD must be width 2 */
	    *nMapsRtrn= _XkbErrCode3(0x05,n,width);
	    return 0;
	}
	if (wire->nMapEntries>0) {
	    xkbKTSetMapEntryWireDesc *	mapWire;
	    xkbModsWireDesc *		preWire;
	    mapWire= (xkbKTSetMapEntryWireDesc *)&wire[1];
	    preWire= (xkbModsWireDesc *)&mapWire[wire->nMapEntries];
	    for (n=0;n<wire->nMapEntries;n++) {
		if (client->swapped) {
		    register int s;
		    swaps(&mapWire[n].virtualMods,s);
		}
		if (mapWire[n].realMods&(~wire->realMods)) {
		    *nMapsRtrn= _XkbErrCode4(0x06,n,mapWire[n].realMods,
						 wire->realMods);
		    return 0;
		}
		if (mapWire[n].virtualMods&(~wire->virtualMods)) {
		    *nMapsRtrn= _XkbErrCode3(0x07,n,mapWire[n].virtualMods);
		    return 0;
		}
		if (mapWire[n].level>=wire->numLevels) {
		    *nMapsRtrn= _XkbErrCode4(0x08,n,wire->numLevels,
						 mapWire[n].level);
		    return 0;
		}
		if (wire->preserve) {
		    if (client->swapped) {
			register int s;
			swaps(&preWire[n].virtualMods,s);
		    }
		    if (preWire[n].realMods&(~mapWire[n].realMods)) {
			*nMapsRtrn= _XkbErrCode4(0x09,n,preWire[n].realMods,
							mapWire[n].realMods);
			return 0;
		    }
		    if (preWire[n].virtualMods&(~mapWire[n].virtualMods)) {
			*nMapsRtrn=_XkbErrCode3(0x0a,n,preWire[n].virtualMods);
			return 0;
		    }
		}
	    }
	    if (wire->preserve)
		 map= (CARD8 *)&preWire[wire->nMapEntries];
	    else map= (CARD8 *)&mapWire[wire->nMapEntries];
	}
	else map= (CARD8 *)&wire[1];
	mapWidthRtrn[i+req->firstType] = wire->numLevels;
	wire= (xkbKeyTypeWireDesc *)map;
d1692 2
a1693 2
    for (i=req->firstType+req->nTypes;i<nMaps;i++) {
	mapWidthRtrn[i] = xkb->map->types[i].num_levels;
d1701 58
a1758 55
CheckKeySyms(	ClientPtr		client,
		XkbDescPtr		xkb,
		xkbSetMapReq *		req,
		int			nTypes,
		CARD8 *	 		mapWidths,
		CARD16 *	 	symsPerKey,
		xkbSymMapWireDesc **	wireRtrn,
		int *			errorRtrn)
{
register unsigned	i;
XkbSymMapPtr		map;
xkbSymMapWireDesc*	wire = *wireRtrn;

    if (!(XkbKeySymsMask&req->present))
	return 1;
    CHK_REQ_KEY_RANGE2(0x11,req->firstKeySym,req->nKeySyms,req,(*errorRtrn),0);
    for (i=0;i<req->nKeySyms;i++) {
	KeySym *pSyms;
	register unsigned nG;
	if (client->swapped) {
	    swaps(&wire->nSyms,nG);
	}
	nG = XkbNumGroups(wire->groupInfo);
	if (nG>XkbNumKbdGroups) {
	    *errorRtrn = _XkbErrCode3(0x14,i+req->firstKeySym,nG);
	    return 0;
	}
	if (nG>0) {
	    register int g,w;
	    for (g=w=0;g<nG;g++) {
		if (wire->ktIndex[g]>=(unsigned)nTypes) {
		    *errorRtrn= _XkbErrCode4(0x15,i+req->firstKeySym,g,
		    					   wire->ktIndex[g]);
		    return 0;
		}
		if (mapWidths[wire->ktIndex[g]]>w)
		    w= mapWidths[wire->ktIndex[g]];
	    }
	    if (wire->width!=w) {
		*errorRtrn= _XkbErrCode3(0x16,i+req->firstKeySym,wire->width);
		return 0;
	    }
	    w*= nG;
	    symsPerKey[i+req->firstKeySym] = w;
	    if (w!=wire->nSyms) {
		*errorRtrn=_XkbErrCode4(0x16,i+req->firstKeySym,wire->nSyms,w);
		return 0;
	    }
	}
	else if (wire->nSyms!=0) {
	    *errorRtrn = _XkbErrCode3(0x17,i+req->firstKeySym,wire->nSyms);
	    return 0;
	}
	pSyms = (KeySym *)&wire[1];
	wire = (xkbSymMapWireDesc *)&pSyms[wire->nSyms];
d1762 13
a1774 12
    for (;i<=(unsigned)xkb->max_key_code;i++,map++) {
	register int g,nG,w;
	nG= XkbKeyNumGroups(xkb,i);
	for (w=g=0;g<nG;g++)  {
	    if (map->kt_index[g]>=(unsigned)nTypes) {
		*errorRtrn = _XkbErrCode4(0x18,i,g,map->kt_index[g]);
		return 0;
	    }
	    if (mapWidths[map->kt_index[g]]>w)
		    w= mapWidths[map->kt_index[g]];
	}
	symsPerKey[i] = w*nG;
d1781 28
a1808 29
CheckKeyActions(	XkbDescPtr	xkb,
			xkbSetMapReq *	req,
			int		nTypes,
			CARD8 *		mapWidths,
			CARD16 *	symsPerKey,
			CARD8 **	wireRtrn,
			int *		nActsRtrn)
{
int			 nActs;
CARD8 *			 wire = *wireRtrn;
register unsigned	 i;

    if (!(XkbKeyActionsMask&req->present))
	return 1;
    CHK_REQ_KEY_RANGE2(0x21,req->firstKeyAct,req->nKeyActs,req,(*nActsRtrn),0);
    for (nActs=i=0;i<req->nKeyActs;i++) {
	if (wire[0]!=0) {
	    if (wire[0]==symsPerKey[i+req->firstKeyAct])
		nActs+= wire[0];
	    else {
		*nActsRtrn= _XkbErrCode3(0x23,i+req->firstKeyAct,wire[0]);
		return 0;
	    }
	}
	wire++;
    }
    if (req->nKeyActs%4)
	wire+= 4-(req->nKeyActs%4);
    *wireRtrn = (CARD8 *)(((XkbAnyAction *)wire)+nActs);
d1814 45
a1858 46
CheckKeyBehaviors(	XkbDescPtr 		xkb,
			xkbSetMapReq *		req,
			xkbBehaviorWireDesc **	wireRtrn,
			int *			errorRtrn)
{
register xkbBehaviorWireDesc *	wire = *wireRtrn;
register XkbServerMapPtr	server = xkb->server;
register unsigned	 	i;
unsigned			first,last;

    if (((req->present&XkbKeyBehaviorsMask)==0)||(req->nKeyBehaviors<1)) {
	req->present&= ~XkbKeyBehaviorsMask;
	req->nKeyBehaviors= 0;
	return 1;
    }
    first= req->firstKeyBehavior;
    last=  req->firstKeyBehavior+req->nKeyBehaviors-1;
    if (first<req->minKeyCode) {
	*errorRtrn = _XkbErrCode3(0x31,first,req->minKeyCode);
	return 0;
    }
    if (last>req->maxKeyCode) {
	*errorRtrn = _XkbErrCode3(0x32,last,req->maxKeyCode);
	return 0;
    }
	
    for (i=0;i<req->totalKeyBehaviors;i++,wire++) {
	if ((wire->key<first)||(wire->key>last)) {
	    *errorRtrn = _XkbErrCode4(0x33,first,last,wire->key);
	    return 0;
	}
	if ((wire->type&XkbKB_Permanent)&&
	    ((server->behaviors[wire->key].type!=wire->type)||
	     (server->behaviors[wire->key].data!=wire->data))) {
	    *errorRtrn = _XkbErrCode3(0x33,wire->key,wire->type);
	    return 0;
	}
	if ((wire->type==XkbKB_RadioGroup)&&
		((wire->data&(~XkbKB_RGAllowNone))>XkbMaxRadioGroups)) {
	    *errorRtrn= _XkbErrCode4(0x34,wire->key,wire->data,
							XkbMaxRadioGroups);
	    return 0;
	}
	if ((wire->type==XkbKB_Overlay1)||(wire->type==XkbKB_Overlay2)) {
	    CHK_KEY_RANGE2(0x35,wire->key,1,xkb,*errorRtrn,0);
	}
d1865 11
a1875 13
CheckVirtualMods(	XkbDescRec *	xkb,
			xkbSetMapReq *	req,
			CARD8 **	wireRtrn,
			int *		errorRtrn)
{
register CARD8		*wire = *wireRtrn;
register unsigned 	 i,nMods,bit;

    if (((req->present&XkbVirtualModsMask)==0)||(req->virtualMods==0))
	return 1;
    for (i=nMods=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (req->virtualMods&bit)
	    nMods++;
d1877 1
a1877 1
    *wireRtrn= (wire+XkbPaddedSize(nMods));
d1882 34
a1915 35
CheckKeyExplicit(	XkbDescPtr	xkb,
			xkbSetMapReq *	req,
			CARD8 **	wireRtrn,
			int	*	errorRtrn)
{
register CARD8 *	wire = *wireRtrn;
CARD8	*		start;
register unsigned 	i;
int			first,last;

    if (((req->present&XkbExplicitComponentsMask)==0)||(req->nKeyExplicit<1)) {
	req->present&= ~XkbExplicitComponentsMask;
	req->nKeyExplicit= 0;
	return 1;
    }
    first= req->firstKeyExplicit;
    last=  first+req->nKeyExplicit-1;
    if (first<req->minKeyCode) {
	*errorRtrn = _XkbErrCode3(0x51,first,req->minKeyCode);
	return 0;
    }
    if (last>req->maxKeyCode) {
	*errorRtrn = _XkbErrCode3(0x52,last,req->maxKeyCode);
	return 0;
    }
    start= wire; 
    for (i=0;i<req->totalKeyExplicit;i++,wire+=2) {
	if ((wire[0]<first)||(wire[0]>last)) {
	    *errorRtrn = _XkbErrCode4(0x53,first,last,wire[0]);
	    return 0;
	}
	if (wire[1]&(~XkbAllExplicitMask)) {
	     *errorRtrn= _XkbErrCode3(0x52,~XkbAllExplicitMask,wire[1]);
	     return 0;
	}
d1917 2
a1918 2
    wire+= XkbPaddedSize(wire-start)-(wire-start);
    *wireRtrn= wire;
d1923 2
a1924 1
CheckModifierMap(XkbDescPtr xkb,xkbSetMapReq *req,CARD8 **wireRtrn,int *errRtrn)
d1926 26
a1951 26
register CARD8 *	wire = *wireRtrn;
CARD8	*		start;
register unsigned 	i;
int			first,last;

    if (((req->present&XkbModifierMapMask)==0)||(req->nModMapKeys<1)) {
	req->present&= ~XkbModifierMapMask;
	req->nModMapKeys= 0;
	return 1;
    }
    first= req->firstModMapKey;
    last=  first+req->nModMapKeys-1;
    if (first<req->minKeyCode) {
	*errRtrn = _XkbErrCode3(0x61,first,req->minKeyCode);
	return 0;
    }
    if (last>req->maxKeyCode) {
	*errRtrn = _XkbErrCode3(0x62,last,req->maxKeyCode);
	return 0;
    }
    start= wire; 
    for (i=0;i<req->totalModMapKeys;i++,wire+=2) {
	if ((wire[0]<first)||(wire[0]>last)) {
	    *errRtrn = _XkbErrCode4(0x63,first,last,wire[0]);
	    return 0;
	}
d1953 2
a1954 2
    wire+= XkbPaddedSize(wire-start)-(wire-start);
    *wireRtrn= wire;
d1959 28
a1986 29
CheckVirtualModMap(	XkbDescPtr xkb,
			xkbSetMapReq *req,
			xkbVModMapWireDesc **wireRtrn,
			int *errRtrn)
{
register xkbVModMapWireDesc *	wire = *wireRtrn;
register unsigned 		i;
int				first,last;

    if (((req->present&XkbVirtualModMapMask)==0)||(req->nVModMapKeys<1)) {
	req->present&= ~XkbVirtualModMapMask;
	req->nVModMapKeys= 0;
	return 1;
    }
    first= req->firstVModMapKey;
    last=  first+req->nVModMapKeys-1;
    if (first<req->minKeyCode) {
	*errRtrn = _XkbErrCode3(0x71,first,req->minKeyCode);
	return 0;
    }
    if (last>req->maxKeyCode) {
	*errRtrn = _XkbErrCode3(0x72,last,req->maxKeyCode);
	return 0;
    }
    for (i=0;i<req->totalVModMapKeys;i++,wire++) {
	if ((wire->key<first)||(wire->key>last)) {
	    *errRtrn = _XkbErrCode4(0x73,first,last,wire->key);
	    return 0;
	}
d1988 1
a1988 1
    *wireRtrn= wire;
d1993 80
a2072 77
SetKeyTypes(	XkbDescPtr		xkb,
		xkbSetMapReq *		req,
		xkbKeyTypeWireDesc *	wire,
		XkbChangesPtr		changes)
{
register unsigned	i;
unsigned		first,last;
CARD8			*map;

    if ((unsigned)(req->firstType+req->nTypes)>xkb->map->size_types) {
	i= req->firstType+req->nTypes;
	if (XkbAllocClientMap(xkb,XkbKeyTypesMask,i)!=Success) {
	    return NULL;
	}
    }
    if ((unsigned)(req->firstType+req->nTypes)>xkb->map->num_types)
	xkb->map->num_types= req->firstType+req->nTypes;

    for (i=0;i<req->nTypes;i++) {
	XkbKeyTypePtr		pOld;
	register unsigned 	n;

	if (XkbResizeKeyType(xkb,i+req->firstType,wire->nMapEntries,
				wire->preserve,wire->numLevels)!=Success) {
	    return NULL;
	}
	pOld = &xkb->map->types[i+req->firstType];
	map = (CARD8 *)&wire[1];

	pOld->mods.real_mods = wire->realMods;
	pOld->mods.vmods= wire->virtualMods;
	pOld->num_levels = wire->numLevels;
	pOld->map_count= wire->nMapEntries;

	pOld->mods.mask= pOld->mods.real_mods|
					XkbMaskForVMask(xkb,pOld->mods.vmods);

	if (wire->nMapEntries) {
	    xkbKTSetMapEntryWireDesc *mapWire;
	    xkbModsWireDesc *preWire;
	    unsigned tmp;
	    mapWire= (xkbKTSetMapEntryWireDesc *)map;
	    preWire= (xkbModsWireDesc *)&mapWire[wire->nMapEntries];
	    for (n=0;n<wire->nMapEntries;n++) {
		pOld->map[n].active= 1;
		pOld->map[n].mods.mask= mapWire[n].realMods;
		pOld->map[n].mods.real_mods= mapWire[n].realMods;
		pOld->map[n].mods.vmods= mapWire[n].virtualMods;
		pOld->map[n].level= mapWire[n].level;
		if (mapWire[n].virtualMods!=0) {
		    tmp= XkbMaskForVMask(xkb,mapWire[n].virtualMods);
		    pOld->map[n].active= (tmp!=0);
		    pOld->map[n].mods.mask|= tmp;
		}
		if (wire->preserve) {
		    pOld->preserve[n].real_mods= preWire[n].realMods;
		    pOld->preserve[n].vmods= preWire[n].virtualMods;
		    tmp= XkbMaskForVMask(xkb,preWire[n].virtualMods);
		    pOld->preserve[n].mask= preWire[n].realMods|tmp;
		}
	    }
	    if (wire->preserve)
		 map= (CARD8 *)&preWire[wire->nMapEntries];
	    else map= (CARD8 *)&mapWire[wire->nMapEntries];
	}
	else map= (CARD8 *)&wire[1];
	wire = (xkbKeyTypeWireDesc *)map;
    }
    first= req->firstType;
    last= first+req->nTypes-1; /* last changed type */
    if (changes->map.changed&XkbKeyTypesMask) {
	int oldLast;
	oldLast= changes->map.first_type+changes->map.num_types-1;
	if (changes->map.first_type<first)
	    first= changes->map.first_type;
	if (oldLast>last)
	    last= oldLast;
d2074 1
a2074 1
    changes->map.changed|= XkbKeyTypesMask;
d2076 2
a2077 2
    changes->map.num_types = (last-first)+1;
    return (char *)wire;
d2081 10
a2090 12
SetKeySyms(	ClientPtr		client,
		XkbDescPtr		xkb,
		xkbSetMapReq *		req,
		xkbSymMapWireDesc *	wire,
		XkbChangesPtr 		changes,
		DeviceIntPtr		dev)
{
register unsigned 	i,s;
XkbSymMapPtr		oldMap;
KeySym *		newSyms;
KeySym *		pSyms;
unsigned		first,last;
d2093 30
a2122 30
    for (i=0;i<req->nKeySyms;i++,oldMap++) {
	pSyms = (KeySym *)&wire[1];
	if (wire->nSyms>0) {
	    newSyms = XkbResizeKeySyms(xkb,i+req->firstKeySym,wire->nSyms);
	    for (s=0;s<wire->nSyms;s++) {
		newSyms[s]= pSyms[s];
	    }
	    if (client->swapped) {
		int n;
		for (s=0;s<wire->nSyms;s++) {
		    swapl(&newSyms[s],n);
		}
	    }
	}
	oldMap->kt_index[0] = wire->ktIndex[0];
	oldMap->kt_index[1] = wire->ktIndex[1];
	oldMap->kt_index[2] = wire->ktIndex[2];
	oldMap->kt_index[3] = wire->ktIndex[3];
	oldMap->group_info = wire->groupInfo;
	oldMap->width = wire->width;
	wire= (xkbSymMapWireDesc *)&pSyms[wire->nSyms];
    }
    first= req->firstKeySym;
    last= first+req->nKeySyms-1;
    if (changes->map.changed&XkbKeySymsMask) {
	int oldLast= (changes->map.first_key_sym+changes->map.num_key_syms-1);
	if (changes->map.first_key_sym<first)
	    first= changes->map.first_key_sym;
	if (oldLast>last)
	    last= oldLast;
d2124 1
a2124 1
    changes->map.changed|= XkbKeySymsMask;
d2126 1
a2126 1
    changes->map.num_key_syms = (last-first+1);
d2128 17
a2144 16
    s= 0;
    for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	if (XkbKeyNumGroups(xkb,i)>s)
	    s= XkbKeyNumGroups(xkb,i);
    }
    if (s!=xkb->ctrls->num_groups) {
	xkbControlsNotify	cn;
	XkbControlsRec		old;
	cn.keycode= 0;
	cn.eventType= 0;
	cn.requestMajor= XkbReqCode;
	cn.requestMinor= X_kbSetMap;
	old= *xkb->ctrls;
	xkb->ctrls->num_groups= s;
	if (XkbComputeControlsNotify(dev,&old,xkb->ctrls,&cn,FALSE))
	    XkbSendControlsNotify(dev,&cn);
d2146 1
a2146 1
    return (char *)wire;
d2150 33
a2182 34
SetKeyActions(	XkbDescPtr	xkb,
		xkbSetMapReq *	req,
		CARD8 *		wire,
		XkbChangesPtr	changes)
{
register unsigned	i,first,last;
CARD8 *			nActs = wire;
XkbAction *		newActs;
    
    wire+= XkbPaddedSize(req->nKeyActs);
    for (i=0;i<req->nKeyActs;i++) {
	if (nActs[i]==0)
	    xkb->server->key_acts[i+req->firstKeyAct]= 0;
	else {
	    newActs= XkbResizeKeyActions(xkb,i+req->firstKeyAct,nActs[i]);
	    memcpy((char *)newActs,(char *)wire,
					nActs[i]*SIZEOF(xkbActionWireDesc));
	    wire+= nActs[i]*SIZEOF(xkbActionWireDesc);
	}
    }
    first= req->firstKeyAct;
    last= (first+req->nKeyActs-1);
    if (changes->map.changed&XkbKeyActionsMask) {
	int oldLast;
	oldLast= changes->map.first_key_act+changes->map.num_key_acts-1;
	if (changes->map.first_key_act<first)
	    first= changes->map.first_key_act;
	if (oldLast>last)
	    last= oldLast;
    }
    changes->map.changed|= XkbKeyActionsMask;
    changes->map.first_key_act= first;
    changes->map.num_key_acts= (last-first+1);
    return (char *)wire;
d2186 23
a2208 22
SetKeyBehaviors(	XkbSrvInfoPtr	 xkbi,
    			xkbSetMapReq	*req,
    			xkbBehaviorWireDesc	*wire,
    			XkbChangesPtr	 changes)
{
register unsigned i;
int maxRG = -1;
XkbDescPtr       xkb = xkbi->desc;
XkbServerMapPtr	 server = xkb->server;
unsigned	 first,last;

    first= req->firstKeyBehavior;
    last= req->firstKeyBehavior+req->nKeyBehaviors-1;
    memset(&server->behaviors[first], 0, req->nKeyBehaviors*sizeof(XkbBehavior));
    for (i=0;i<req->totalKeyBehaviors;i++) {
	if ((server->behaviors[wire->key].type&XkbKB_Permanent)==0) {
	    server->behaviors[wire->key].type= wire->type;
	    server->behaviors[wire->key].data= wire->data;
	    if ((wire->type==XkbKB_RadioGroup)&&(((int)wire->data)>maxRG))
		maxRG= wire->data + 1;
	}
	wire++;
d2211 3
a2213 2
    if (maxRG>(int)xkbi->nRadioGroups) {
        int sz = maxRG*sizeof(XkbRadioGroupRec);
d2215 3
a2217 2
             xkbi->radioGroups= realloc(xkbi->radioGroups,sz);
        else xkbi->radioGroups= calloc(1, sz);
d2219 4
a2222 4
             if (xkbi->nRadioGroups)
                 memset(&xkbi->radioGroups[xkbi->nRadioGroups], 0,
                        (maxRG-xkbi->nRadioGroups)*sizeof(XkbRadioGroupRec));
             xkbi->nRadioGroups= maxRG;
d2224 2
a2225 1
        else xkbi->nRadioGroups= 0;
d2228 9
a2236 8
    if (changes->map.changed&XkbKeyBehaviorsMask) {
	unsigned oldLast;
	oldLast= changes->map.first_key_behavior+
					changes->map.num_key_behaviors-1;
        if (changes->map.first_key_behavior<req->firstKeyBehavior)
             first= changes->map.first_key_behavior;
        if (oldLast>last)
            last= oldLast;
d2238 1
a2238 1
    changes->map.changed|= XkbKeyBehaviorsMask;
d2240 2
a2241 2
    changes->map.num_key_behaviors = (last-first+1);
    return (char *)wire;
d2245 2
a2246 2
SetVirtualMods(XkbSrvInfoPtr xkbi,xkbSetMapReq *req,CARD8 *wire,
						XkbChangesPtr changes)
d2248 2
a2249 2
register int 		i,bit,nMods;
XkbServerMapPtr		srv = xkbi->desc->server;
d2251 11
a2261 11
    if (((req->present&XkbVirtualModsMask)==0)||(req->virtualMods==0))
	return (char *)wire;
    for (i=nMods=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (req->virtualMods&bit) {
	    if (srv->vmods[i]!=wire[nMods]) {
		changes->map.changed|= XkbVirtualModsMask;
		changes->map.vmods|= bit;
		srv->vmods[i]= wire[nMods];
	    }
	    nMods++;
	}
d2263 1
a2263 1
    return (char *)(wire+XkbPaddedSize(nMods));
d2267 2
a2268 2
SetKeyExplicit(XkbSrvInfoPtr xkbi,xkbSetMapReq *req,CARD8 *wire,
							XkbChangesPtr changes)
d2270 7
a2276 7
register unsigned	i,first,last;
XkbServerMapPtr		xkb = xkbi->desc->server;
CARD8 *			start;

    start= wire;
    first= req->firstKeyExplicit;
    last=  req->firstKeyExplicit+req->nKeyExplicit-1;
d2278 2
a2279 2
    for (i=0;i<req->totalKeyExplicit;i++,wire+= 2) {
	xkb->explicit[wire[0]]= wire[1];
d2281 13
a2293 12
    if (first>0) {
	if (changes->map.changed&XkbExplicitComponentsMask) {
	    int oldLast;
	    oldLast= changes->map.first_key_explicit+
					changes->map.num_key_explicit-1;
	    if (changes->map.first_key_explicit<first)
		first= changes->map.first_key_explicit;
	    if (oldLast>last)
		last= oldLast;
	}
	changes->map.first_key_explicit= first;
	changes->map.num_key_explicit= (last-first)+1;
d2295 2
a2296 2
    wire+= XkbPaddedSize(wire-start)-(wire-start);
    return (char *)wire;
d2300 10
a2309 12
SetModifierMap(	XkbSrvInfoPtr	xkbi,
		xkbSetMapReq *	req,
		CARD8 *		wire,
		XkbChangesPtr	changes)
{
register unsigned	i,first,last;
XkbClientMapPtr		xkb = xkbi->desc->map;
CARD8 *			start;

    start= wire;
    first= req->firstModMapKey;
    last=  req->firstModMapKey+req->nModMapKeys-1;
d2311 2
a2312 2
    for (i=0;i<req->totalModMapKeys;i++,wire+= 2) {
	xkb->modmap[wire[0]]= wire[1];
d2314 13
a2326 12
    if (first>0) {
	if (changes->map.changed&XkbModifierMapMask) {
	    int oldLast;
	    oldLast= changes->map.first_modmap_key+
						changes->map.num_modmap_keys-1;
	    if (changes->map.first_modmap_key<first)
		first= changes->map.first_modmap_key;
	    if (oldLast>last)
		last= oldLast;
	}
	changes->map.first_modmap_key= first;
	changes->map.num_modmap_keys= (last-first)+1;
d2328 2
a2329 2
    wire+= XkbPaddedSize(wire-start)-(wire-start);
    return (char *)wire;
d2333 26
a2358 26
SetVirtualModMap(	XkbSrvInfoPtr		xkbi,
			xkbSetMapReq *		req,
			xkbVModMapWireDesc *	wire,
			XkbChangesPtr 		changes)
{
register unsigned	i,first,last;
XkbServerMapPtr		srv = xkbi->desc->server;

    first= req->firstVModMapKey;
    last=  req->firstVModMapKey+req->nVModMapKeys-1;
    memset(&srv->vmodmap[first], 0, req->nVModMapKeys*sizeof(unsigned short));
    for (i=0;i<req->totalVModMapKeys;i++,wire++) {
	srv->vmodmap[wire->key]= wire->vmods;
    }
    if (first>0) {
	if (changes->map.changed&XkbVirtualModMapMask) {
	    int oldLast;
	    oldLast= changes->map.first_vmodmap_key+
					changes->map.num_vmodmap_keys-1;
	    if (changes->map.first_vmodmap_key<first)
		first= changes->map.first_vmodmap_key;
	    if (oldLast>last)
		last= oldLast;
	}
	changes->map.first_vmodmap_key= first;
	changes->map.num_vmodmap_keys= (last-first)+1;
d2360 1
a2360 1
    return (char *)wire;
d2368 2
a2369 1
_XkbSetMapChecks(ClientPtr client, DeviceIntPtr dev, xkbSetMapReq *req, char* values)
d2371 8
a2378 8
    XkbSrvInfoPtr       xkbi;
    XkbDescPtr          xkb;
    int                 error;
    int                 nTypes = 0, nActions;
    CARD8               mapWidths[XkbMaxLegalKeyCode + 1] = {0};
    CARD16              symsPerKey[XkbMaxLegalKeyCode + 1] = {0};
    XkbSymMapPtr        map;
    int                 i;
d2380 1
a2380 1
    xkbi= dev->key->xkbInfo;
d2383 1
a2383 1
    if ((xkb->min_key_code != req->minKeyCode)||
d2385 16
a2400 14
	if (client->vMajor!=1) { /* pre 1.0 versions of Xlib have a bug */
	    req->minKeyCode= xkb->min_key_code;
	    req->maxKeyCode= xkb->max_key_code;
	}
	else {
	    if (!XkbIsLegalKeycode(req->minKeyCode)) {
		client->errorValue = _XkbErrCode3(2, req->minKeyCode, req->maxKeyCode);
		return BadValue;
	    }
	    if (req->minKeyCode > req->maxKeyCode) {
		client->errorValue = _XkbErrCode3(3, req->minKeyCode, req->maxKeyCode);
		return BadMatch;
	    }
	}
d2404 4
a2407 4
	(!CheckKeyTypes(client,xkb,req,(xkbKeyTypeWireDesc **)&values,
						&nTypes,mapWidths))) {
	client->errorValue = nTypes;
	return BadValue;
d2412 13
a2424 12
    for (i=xkb->min_key_code;i<xkb->max_key_code;i++,map++) {
	register int g,ng,w;
	ng= XkbNumGroups(map->group_info);
	for (w=g=0;g<ng;g++) {
	    if (map->kt_index[g]>=(unsigned)nTypes) {
		client->errorValue = _XkbErrCode4(0x13,i,g,map->kt_index[g]);
		return 0;
	    }
	    if (mapWidths[map->kt_index[g]]>w)
		w= mapWidths[map->kt_index[g]];
	}
	symsPerKey[i] = w*ng;
d2428 4
a2431 4
	(!CheckKeySyms(client,xkb,req,nTypes,mapWidths,symsPerKey,
					(xkbSymMapWireDesc **)&values,&error))) {
	client->errorValue = error;
	return BadValue;
d2435 4
a2438 4
	(!CheckKeyActions(xkb,req,nTypes,mapWidths,symsPerKey,
						(CARD8 **)&values,&nActions))) {
	client->errorValue = nActions;
	return BadValue;
d2442 4
a2445 3
	(!CheckKeyBehaviors(xkb,req,(xkbBehaviorWireDesc**)&values,&error))) {
	client->errorValue = error;
	return BadValue;
d2449 25
a2473 24
	(!CheckVirtualMods(xkb,req,(CARD8 **)&values,&error))) {
	client->errorValue= error;
	return BadValue;
    }
    if ((req->present&XkbExplicitComponentsMask) &&
	(!CheckKeyExplicit(xkb,req,(CARD8 **)&values,&error))) {
	client->errorValue= error;
	return BadValue;
    }
    if ((req->present&XkbModifierMapMask) &&
	(!CheckModifierMap(xkb,req,(CARD8 **)&values,&error))) {
	client->errorValue= error;
	return BadValue;
    }
    if ((req->present&XkbVirtualModMapMask) &&
	(!CheckVirtualModMap(xkb,req,(xkbVModMapWireDesc **)&values,&error))) {
	client->errorValue= error;
	return BadValue;
    }

    if (((values-((char *)req))/4)!= req->length) {
	ErrorF("[xkb] Internal error! Bad length in XkbSetMap (after check)\n");
	client->errorValue = values-((char *)&req[1]);
	return BadLength;
d2483 1
a2483 1
_XkbSetMap(ClientPtr client, DeviceIntPtr dev, xkbSetMapReq *req, char *values)
d2485 5
a2489 5
    XkbEventCauseRec	cause;
    XkbChangesRec	change;
    Bool		sentNKN;
    XkbSrvInfoPtr       xkbi;
    XkbDescPtr          xkb;
d2491 1
a2491 1
    xkbi= dev->key->xkbInfo;
d2494 1
a2494 1
    XkbSetCauseXkbReq(&cause,X_kbSetMap,client);
d2497 91
a2587 77
    if ((xkb->min_key_code!=req->minKeyCode)||
        (xkb->max_key_code!=req->maxKeyCode)) {
	Status			status;
	xkbNewKeyboardNotify	nkn;
	nkn.deviceID = nkn.oldDeviceID = dev->id;
	nkn.oldMinKeyCode = xkb->min_key_code;
	nkn.oldMaxKeyCode = xkb->max_key_code;
	status= XkbChangeKeycodeRange(xkb, req->minKeyCode,
                                      req->maxKeyCode, &change);
	if (status != Success)
	    return status; /* oh-oh. what about the other keyboards? */
	nkn.minKeyCode = xkb->min_key_code;
	nkn.maxKeyCode = xkb->max_key_code;
	nkn.requestMajor = XkbReqCode;
	nkn.requestMinor = X_kbSetMap;
	nkn.changed = XkbNKN_KeycodesMask;
	XkbSendNewKeyboardNotify(dev,&nkn);
	sentNKN = TRUE;
    }

    if (req->present&XkbKeyTypesMask) {
	values = SetKeyTypes(xkb,req,(xkbKeyTypeWireDesc *)values,&change);
	if (!values)	goto allocFailure;
    }
    if (req->present&XkbKeySymsMask) {
	values = SetKeySyms(client,xkb,req,(xkbSymMapWireDesc *)values,&change,dev);
	if (!values)	goto allocFailure;
    }
    if (req->present&XkbKeyActionsMask) {
	values = SetKeyActions(xkb,req,(CARD8 *)values,&change);
	if (!values)	goto allocFailure;
    }
    if (req->present&XkbKeyBehaviorsMask) {
	values= SetKeyBehaviors(xkbi,req,(xkbBehaviorWireDesc *)values,&change);
	if (!values)	goto allocFailure;
    }
    if (req->present&XkbVirtualModsMask)
	values= SetVirtualMods(xkbi,req,(CARD8 *)values,&change);
    if (req->present&XkbExplicitComponentsMask)
	values= SetKeyExplicit(xkbi,req,(CARD8 *)values,&change);
    if (req->present&XkbModifierMapMask)
	values= SetModifierMap(xkbi,req,(CARD8 *)values,&change);
    if (req->present&XkbVirtualModMapMask)
	values= SetVirtualModMap(xkbi,req,(xkbVModMapWireDesc *)values,&change);
    if (((values-((char *)req))/4)!=req->length) {
	ErrorF("[xkb] Internal error! Bad length in XkbSetMap (after set)\n");
	client->errorValue = values-((char *)&req[1]);
	return BadLength;
    }
    if (req->flags&XkbSetMapRecomputeActions) {
	KeyCode		first,last,firstMM,lastMM;
	if (change.map.num_key_syms>0) {
	    first= change.map.first_key_sym;
	    last= first+change.map.num_key_syms-1;
	}
	else first= last= 0;
	if (change.map.num_modmap_keys>0) {
	    firstMM= change.map.first_modmap_key;
	    lastMM= first+change.map.num_modmap_keys-1;
	}
	else firstMM= lastMM= 0;
	if ((last>0) && (lastMM>0)) {
	    if (firstMM<first)
		first= firstMM;
	    if (lastMM>last)
		last= lastMM;
	}
	else if (lastMM>0) {
	    first= firstMM;
	    last= lastMM;
	}
	if (last>0) {
	    unsigned check= 0;
	    XkbUpdateActions(dev,first,(last-first+1),&change,&check,&cause);
	    if (check)
		XkbCheckSecondaryEffects(xkbi,check,&change,&cause);
	}
d2590 1
a2590 1
	XkbSendNotification(dev,&change,&cause);
d2593 1
a2593 1
allocFailure:
a2596 1

d2600 3
a2602 3
    DeviceIntPtr	dev;
    char *		tmp;
    int                 rc;
d2607 2
a2608 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d2611 1
a2611 1
    CHK_MASK_LEGAL(0x01,stuff->present,XkbAllMapComponentsMask);
d2613 1
a2613 1
    tmp = (char *)&stuff[1];
d2623 1
a2623 2
    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
d2625 7
a2631 7
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
d2645 1
a2645 2
    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
d2647 6
a2652 5
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
d2669 23
a2691 2
XkbComputeGetCompatMapReplySize(	XkbCompatMapPtr 	compat,
					xkbGetCompatMapReply *	rep)
d2693 2
a2694 1
unsigned	 size,nGroups;
d2696 39
a2734 60
    nGroups= 0;
    if (rep->groups!=0) {
	register int i,bit;
	for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
	    if (rep->groups&bit)
		nGroups++;
	}
    }
    size= nGroups*SIZEOF(xkbModsWireDesc);
    size+= (rep->nSI*SIZEOF(xkbSymInterpretWireDesc));
    rep->length= size/4;
    return Success;
}

static int
XkbSendCompatMap(	ClientPtr 		client,
			XkbCompatMapPtr 	compat,
			xkbGetCompatMapReply *	rep)
{
char	*	data;
int		size;

    size= rep->length*4;
    if (size>0) {
	data = malloc(size);
	if (data) {
	    register unsigned i,bit;
	    xkbModsWireDesc *	grp;
	    XkbSymInterpretPtr	sym= &compat->sym_interpret[rep->firstSI];
	    xkbSymInterpretWireDesc *wire = (xkbSymInterpretWireDesc *)data;
	    for (i=0;i<rep->nSI;i++,sym++,wire++) {
		wire->sym= sym->sym;
		wire->mods= sym->mods;
		wire->match= sym->match;
		wire->virtualMod= sym->virtual_mod;
		wire->flags= sym->flags;
		memcpy((char*)&wire->act,(char*)&sym->act,sz_xkbActionWireDesc);
		if (client->swapped) {
		    register int n;
		    swapl(&wire->sym,n);
		}
	    }
	    if (rep->groups) {
		grp = (xkbModsWireDesc *)wire;
		for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
		    if (rep->groups&bit) {
			grp->mask= compat->groups[i].mask;
			grp->realMods= compat->groups[i].real_mods;
			grp->virtualMods= compat->groups[i].vmods;
			if (client->swapped) {
			    register int n;
			    swaps(&grp->virtualMods,n);
			}
			grp++;
		    }
		}
		wire= (xkbSymInterpretWireDesc*)grp;
	    }
	}
	else return BadAlloc;
d2736 2
a2737 1
    else data= NULL;
d2740 5
a2744 6
	register int n;
	swaps(&rep->sequenceNumber,n);
	swapl(&rep->length,n);
	swaps(&rep->firstSI,n);
	swaps(&rep->nSI,n);
	swaps(&rep->nTotalSI,n);
d2747 1
a2747 1
    WriteToClient(client, SIZEOF(xkbGetCompatMapReply), (char *)rep);
d2749 2
a2750 2
	WriteToClient(client, size, data);
	free((char *)data);
d2758 4
a2761 4
    xkbGetCompatMapReply 	rep;
    DeviceIntPtr 		dev;
    XkbDescPtr			xkb;
    XkbCompatMapPtr		compat;
d2766 2
a2767 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d2772 1
a2772 1
    compat= xkb->compat;
d2781 2
a2782 2
	rep.firstSI = 0;
	rep.nSI = compat->num_si;
d2784 4
a2787 4
    else if ((((unsigned)stuff->nSI)>0)&&
		((unsigned)(stuff->firstSI+stuff->nSI-1)>=compat->num_si)) {
	client->errorValue = _XkbErrCode2(0x05,compat->num_si);
	return BadValue;
d2790 3
a2792 3
    rep.groups= stuff->groups;
    XkbComputeGetCompatMapReplySize(compat,&rep);
    return XkbSendCompatMap(client,compat,&rep);
d2802 1
a2802 1
                 xkbSetCompatMapReq *req, char* data, BOOL dryRun)
d2804 5
a2808 5
    XkbSrvInfoPtr       xkbi;
    XkbDescPtr          xkb;
    XkbCompatMapPtr     compat;
    int                 nGroups;
    unsigned            i,bit;
d2814 22
a2835 21
    if ((req->nSI>0)||(req->truncateSI)) {
	xkbSymInterpretWireDesc *wire;
	if (req->firstSI>compat->num_si) {
	    client->errorValue = _XkbErrCode2(0x02,compat->num_si);
	    return BadValue;
	}
	wire= (xkbSymInterpretWireDesc *)data;
	wire+= req->nSI;
	data = (char *)wire;
    }

    nGroups= 0;
    if (req->groups!=0) {
	for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
	    if ( req->groups&bit )
		nGroups++;
	}
    }
    data+= nGroups*SIZEOF(xkbModsWireDesc);
    if (((data-((char *)req))/4)!=req->length) {
	return BadLength;
d2842 38
a2879 37
    data = (char *)&req[1];
    if (req->nSI>0) {
	xkbSymInterpretWireDesc *wire = (xkbSymInterpretWireDesc *)data;
	XkbSymInterpretPtr	sym;
	unsigned int		skipped = 0;
	if ((unsigned)(req->firstSI+req->nSI)>compat->num_si) {
	    compat->num_si= req->firstSI+req->nSI;
	    compat->sym_interpret= realloc(compat->sym_interpret,
					    compat->num_si * sizeof(XkbSymInterpretRec));
	    if (!compat->sym_interpret) {
		compat->num_si= 0;
		return BadAlloc;
	    }
	}
	else if (req->truncateSI) {
	    compat->num_si = req->firstSI+req->nSI;
	}
	sym = &compat->sym_interpret[req->firstSI];
	for (i=0;i<req->nSI;i++,wire++) {
	    if (client->swapped) {
		int n;
		swapl(&wire->sym,n);
	    }
	    if (wire->sym == NoSymbol && wire->match == XkbSI_AnyOfOrNone &&
		(wire->mods & 0xff) == 0xff &&
		wire->act.type == XkbSA_XFree86Private) {
		ErrorF("XKB: Skipping broken Any+AnyOfOrNone(All) -> Private "
		       "action from client\n");
		skipped++;
		continue;
	    }
	    sym->sym= wire->sym;
	    sym->mods= wire->mods;
	    sym->match= wire->match;
	    sym->flags= wire->flags;
	    sym->virtual_mod= wire->virtualMod;
	    memcpy((char *)&sym->act,(char *)&wire->act,
d2882 9
a2890 9
	}
	if (skipped) {
	    if (req->firstSI + req->nSI < compat->num_si)
		memmove(sym, sym + skipped,
	                (compat->num_si - req->firstSI - req->nSI) *
			 sizeof(*sym));
	    compat->num_si -= skipped;
	}
	data = (char *)wire;
d2893 1
a2893 1
	compat->num_si = req->firstSI;
d2896 27
a2922 26
    if (req->groups!=0) {
	unsigned i, bit;
	xkbModsWireDesc *wire = (xkbModsWireDesc *)data;
	for (i = 0, bit = 1; i < XkbNumKbdGroups; i++, bit <<= 1) {
	    if (req->groups & bit) {
		if (client->swapped) {
		    int n;
		    swaps(&wire->virtualMods,n);
		}
		compat->groups[i].mask= wire->realMods;
		compat->groups[i].real_mods= wire->realMods;
		compat->groups[i].vmods= wire->virtualMods;
		if (wire->virtualMods!=0) {
		    unsigned tmp;
		    tmp= XkbMaskForVMask(xkb,wire->virtualMods);
		    compat->groups[i].mask|= tmp;
		}
		data+= SIZEOF(xkbModsWireDesc);
		wire= (xkbModsWireDesc *)data;
	    }
	}
    }
    i= XkbPaddedSize((data-((char *)req)));
    if ((i/4)!=req->length) {
	ErrorF("[xkb] Internal length error on read in _XkbSetCompatMap\n");
	return BadLength;
d2926 8
a2933 7
	xkbCompatMapNotify ev;
	ev.deviceID = dev->id;
	ev.changedGroups = req->groups;
	ev.firstSI = req->firstSI;
	ev.nSI = req->nSI;
	ev.nTotalSI = compat->num_si;
	XkbSendCompatMapNotify(dev,&ev);
d2937 11
a2947 11
	XkbChangesRec		change;
	unsigned		check;
	XkbEventCauseRec	cause;

	XkbSetCauseXkbReq(&cause,X_kbSetCompatMap,client);
	memset(&change, 0, sizeof(XkbChangesRec));
	XkbUpdateActions(dev,xkb->min_key_code,XkbNumKeys(xkb),&change,&check,
									&cause);
	if (check)
	    XkbCheckSecondaryEffects(xkbi,check,&change,&cause);
	XkbSendNotification(dev,&change,&cause);
d2955 3
a2957 3
    DeviceIntPtr        dev;
    char                *data;
    int                 rc;
d2962 2
a2963 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d2967 1
a2967 1
    data = (char *)&stuff[1];
d2973 1
a2973 2
    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
d2975 7
a2981 7
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
d2995 1
a2995 2
    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
d2997 7
a3003 7
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
d3020 3
a3022 4
    xkbGetIndicatorStateReply 	rep;
    XkbSrvLedInfoPtr		sli;
    DeviceIntPtr 		dev;
    register int 		i;
d3027 2
a3028 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d3032 2
a3033 2
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,
						XkbXI_IndicatorStateMask);
d3035 1
a3035 1
	return BadAlloc;
d3044 2
a3045 2
	swaps(&rep.sequenceNumber,i);
	swapl(&rep.state,i);
d3047 1
a3047 1
    WriteToClient(client, SIZEOF(xkbGetIndicatorStateReply), (char *)&rep);
d3054 2
a3055 3
XkbComputeGetIndicatorMapReplySize(
    XkbIndicatorPtr		indicators,
    xkbGetIndicatorMapReply	*rep)
d3057 2
a3058 2
register int 	i,bit;
int		nIndicators;
d3061 5
a3065 5
    for (i=nIndicators=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
	if (rep->which&bit)
	    nIndicators++;
    }
    rep->length = (nIndicators*SIZEOF(xkbIndicatorMapWireDesc))/4;
d3070 42
a3111 41
XkbSendIndicatorMap(	ClientPtr			client,
			XkbIndicatorPtr			indicators,
			xkbGetIndicatorMapReply *	rep)
{
int 			length;
CARD8 *			map;
register int		i;
register unsigned	bit;

    length = rep->length*4;
    if (length>0) {
	CARD8 *to;
	to= map= malloc(length);
	if (map) {
	    xkbIndicatorMapWireDesc  *wire = (xkbIndicatorMapWireDesc *)to;
	    for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
		if (rep->which&bit) {
		    wire->flags= indicators->maps[i].flags;
		    wire->whichGroups= indicators->maps[i].which_groups;
		    wire->groups= indicators->maps[i].groups;
		    wire->whichMods= indicators->maps[i].which_mods;
		    wire->mods= indicators->maps[i].mods.mask;
		    wire->realMods= indicators->maps[i].mods.real_mods;
		    wire->virtualMods= indicators->maps[i].mods.vmods;
		    wire->ctrls= indicators->maps[i].ctrls;
		    if (client->swapped) {
			register int n;
			swaps(&wire->virtualMods,n);
			swapl(&wire->ctrls,n);
		    }
		    wire++;
		}
	    }
	    to = (CARD8 *)wire;
	    if ((to-map)!=length) {
		client->errorValue = _XkbErrCode2(0xff,length);
		free(map);
		return BadLength;
	    }
	}
	else return BadAlloc;
d3113 2
a3114 1
    else map = NULL;
d3116 4
a3119 4
	swaps(&rep->sequenceNumber,i);
	swapl(&rep->length,i);
	swapl(&rep->which,i);
	swapl(&rep->realIndicators,i);
d3121 1
a3121 1
    WriteToClient(client, SIZEOF(xkbGetIndicatorMapReply), (char *)rep);
d3123 2
a3124 2
	WriteToClient(client, length, (char *)map);
	free((char *)map);
d3132 4
a3135 4
xkbGetIndicatorMapReply rep;
DeviceIntPtr		dev;
XkbDescPtr		xkb;
XkbIndicatorPtr		leds;
d3140 2
a3141 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d3145 2
a3146 2
    xkb= dev->key->xkbInfo->desc;
    leds= xkb->indicators;
d3153 2
a3154 2
    XkbComputeGetIndicatorMapReplySize(leds,&rep);
    return XkbSendIndicatorMap(client,leds,&rep);
d3163 1
a3163 1
                    int which, xkbIndicatorMapWireDesc *desc)
d3165 4
a3168 4
    XkbSrvInfoPtr       xkbi;
    XkbSrvLedInfoPtr    sli;
    XkbEventCauseRec    cause;
    int                 i, bit;
d3172 2
a3173 2
    sli= XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId,
						XkbXI_IndicatorMapsMask);
d3175 1
a3175 1
	return BadAlloc;
d3178 17
a3194 16
	if (which & bit) {
	    sli->maps[i].flags = desc->flags;
	    sli->maps[i].which_groups = desc->whichGroups;
	    sli->maps[i].groups = desc->groups;
	    sli->maps[i].which_mods = desc->whichMods;
	    sli->maps[i].mods.mask = desc->mods;
	    sli->maps[i].mods.real_mods = desc->mods;
	    sli->maps[i].mods.vmods= desc->virtualMods;
	    sli->maps[i].ctrls = desc->ctrls;
	    if (desc->virtualMods!=0) {
		unsigned tmp;
		tmp= XkbMaskForVMask(xkbi->desc,desc->virtualMods);
		sli->maps[i].mods.mask= desc->mods|tmp;
	    }
	    desc++;
	}
d3197 2
a3198 2
    XkbSetCauseXkbReq(&cause,X_kbSetIndicatorMap,client);
    XkbApplyLedMapChanges(dev,sli,which,NULL,NULL,&cause);
d3206 5
a3210 5
    int                 i, bit;
    int                 nIndicators;
    DeviceIntPtr        dev;
    xkbIndicatorMapWireDesc     *from;
    int                 rc;
d3215 2
a3216 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d3220 2
a3221 2
    if (stuff->which==0)
	return Success;
d3223 8
a3230 21
    for (nIndicators=i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
	if (stuff->which&bit)
	    nIndicators++;
    }
    if (stuff->length!=((SIZEOF(xkbSetIndicatorMapReq)+
			(nIndicators*SIZEOF(xkbIndicatorMapWireDesc)))/4)) {
	return BadLength;
    }

    from = (xkbIndicatorMapWireDesc *)&stuff[1];
    for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
	if (stuff->which&bit) {
	    if (client->swapped) {
		int n;
		swaps(&from->virtualMods,n);
		swapl(&from->ctrls,n);
	    }
	    CHK_MASK_LEGAL(i,from->whichGroups,XkbIM_UseAnyGroup);
	    CHK_MASK_LEGAL(i,from->whichMods,XkbIM_UseAnyMods);
	    from++;
	}
d3233 14
a3246 1
    from = (xkbIndicatorMapWireDesc *)&stuff[1];
d3251 1
a3251 2
    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
d3253 6
a3258 5
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixSetAttrAccess);
d3273 5
a3277 5
    DeviceIntPtr 		dev;
    xkbGetNamedIndicatorReply 	rep;
    register int		i = 0;
    XkbSrvLedInfoPtr		sli;
    XkbIndicatorMapPtr		map = NULL;
d3282 2
a3283 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d3288 1
a3288 1
    sli= XkbFindSrvLedInfo(dev,stuff->ledClass,stuff->ledID,0);
d3290 1
a3290 1
	return BadAlloc;
d3292 6
a3297 6
    i= 0;
    map= NULL;
    if ((sli->names)&&(sli->maps)) {
        for (i=0;i<XkbNumIndicators;i++) {
            if (stuff->indicator==sli->names[i]) {
                map= &sli->maps[i];
d3303 1
a3303 1
    rep.type= X_Reply;
d3307 37
a3343 38
    rep.indicator= stuff->indicator;
    if (map!=NULL) {
	rep.found= 		TRUE;
	rep.on=			((sli->effectiveState&(1<<i))!=0);
	rep.realIndicator=	((sli->physIndicators&(1<<i))!=0);
	rep.ndx= 		i;
	rep.flags= 		map->flags;
	rep.whichGroups= 	map->which_groups;
	rep.groups= 		map->groups;
	rep.whichMods= 		map->which_mods;
	rep.mods= 		map->mods.mask;
	rep.realMods= 		map->mods.real_mods;
	rep.virtualMods= 	map->mods.vmods;
	rep.ctrls= 		map->ctrls;
	rep.supported= 		TRUE;
    }
    else  {
	rep.found= 		FALSE;
	rep.on= 		FALSE;
	rep.realIndicator= 	FALSE;
	rep.ndx= 		XkbNoIndicator;
	rep.flags= 		0;
	rep.whichGroups= 	0;
	rep.groups= 		0;
	rep.whichMods= 		0;
	rep.mods=		0;
	rep.realMods= 		0;
	rep.virtualMods= 	0;
	rep.ctrls= 		0;
	rep.supported= 		TRUE;
    }
    if ( client->swapped ) {
	register int n;
	swapl(&rep.length,n);
	swaps(&rep.sequenceNumber,n);
	swapl(&rep.indicator,n);
	swaps(&rep.virtualMods,n);
	swapl(&rep.ctrls,n);
d3346 1
a3346 1
    WriteToClient(client,SIZEOF(xkbGetNamedIndicatorReply), (char *)&rep);
a3349 1

d3357 1
a3357 2
_XkbFindNamedIndicatorMap(XkbSrvLedInfoPtr sli, Atom indicator,
                          int *led_return)
d3359 1
a3359 1
    XkbIndicatorMapPtr  map;
d3364 1
a3364 1
	int led;
d3366 7
a3372 7
	for (led = 0; (led < XkbNumIndicators) && (map == NULL); led++) {
	    if (sli->names[led] == indicator) {
		map= &sli->maps[led];
		*led_return = led;
		break;
	    }
	}
d3385 1
a3385 1
                       XkbIndicatorMapPtr *map_return, int *led_return,
d3388 3
a3390 3
    XkbSrvLedInfoPtr    sli;
    XkbIndicatorMapPtr  map;
    int                 led;
d3398 1
a3398 2
    if (!map)
    {
d3400 2
a3401 1
        for (led = 0, map = NULL; (led < XkbNumIndicators) && (map == NULL); led++) {
d3403 1
a3403 2
                    (!XkbIM_InUse(&sli->maps[led])))
            {
d3422 1
a3422 1
                      xkbSetNamedIndicatorReq *stuff)
d3424 10
a3433 10
    unsigned int                extDevReason;
    unsigned int                statec, namec, mapc;
    XkbSrvLedInfoPtr            sli;
    int                         led = 0;
    XkbIndicatorMapPtr          map;
    DeviceIntPtr                kbd;
    XkbEventCauseRec            cause;
    xkbExtensionDeviceNotify    ed;
    XkbChangesRec               changes;
    int                         rc;
d3437 1
a3437 1
    if (rc != Success || !map) /* oh-oh */
d3448 1
a3448 1
    namec |= (1<<led);
d3459 1
a3459 1
        map->mods.vmods= stuff->virtualMods;
d3461 1
a3461 1
        mapc|= (1<<led);
d3464 5
a3468 4
    if ((stuff->setState) && ((map->flags & XkbIM_NoExplicit) == 0))
    {
        if (stuff->on)	sli->explicitState |=  (1<<led);
        else		sli->explicitState &= ~(1<<led);
d3472 3
a3474 3
    memset((char *)&ed, 0, sizeof(xkbExtensionDeviceNotify));
    memset((char *)&changes, 0, sizeof(XkbChangesRec));
    XkbSetCauseXkbReq(&cause,X_kbSetNamedIndicator,client);
d3476 1
a3476 1
        XkbApplyLedNameChanges(dev,sli,namec,&ed,&changes,&cause);
d3478 1
a3478 1
        XkbApplyLedMapChanges(dev,sli,mapc,&ed,&changes,&cause);
d3480 1
a3480 1
        XkbApplyLedStateChanges(dev,sli,statec,&ed,&changes,&cause);
d3483 1
a3483 1
    if ((sli->flags&XkbSLI_HasOwnState)==0)
d3493 4
a3496 4
    int                         rc;
    DeviceIntPtr                dev;
    int                         led = 0;
    XkbIndicatorMapPtr          map;
d3501 2
a3502 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d3506 2
a3507 2
    CHK_MASK_LEGAL(0x10,stuff->whichGroups,XkbIM_UseAnyGroup);
    CHK_MASK_LEGAL(0x11,stuff->whichMods,XkbIM_UseAnyMods);
d3513 1
a3513 1
    if (rc != Success || !map) /* couldn't be created or didn't exist */
d3517 1
a3517 2
        stuff->deviceSpec == XkbUseCorePtr)
    {
d3519 7
a3525 6
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev &&
                (other->kbdfeed || other->leds) &&
                (XaceHook(XACE_DEVICE_ACCESS, client, other, DixSetAttrAccess) == Success))
            {
d3527 2
a3528 2
                                            stuff->ledClass, stuff->ledID,
                                            &map, &led, TRUE);
d3541 1
a3541 2
        stuff->deviceSpec == XkbUseCorePtr)
    {
d3543 7
a3549 6
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev &&
                (other->kbdfeed || other->leds) &&
                (XaceHook(XACE_DEVICE_ACCESS, client, other, DixSetAttrAccess) == Success))
            {
d3561 1
a3561 1
_XkbCountAtoms(Atom *atoms,int maxAtoms,int *count)
d3563 2
a3564 2
register unsigned int i,bit,nAtoms;
register CARD32 atomsPresent;
d3566 5
a3570 5
    for (i=nAtoms=atomsPresent=0,bit=1;i<maxAtoms;i++,bit<<=1) {
	if (atoms[i]!=None) {
	    atomsPresent|= bit;
	    nAtoms++;
	}
d3573 1
a3573 1
	*count= nAtoms;
d3578 1
a3578 1
_XkbWriteAtoms(char *wire,Atom *atoms,int maxAtoms,int swap)
d3580 2
a3581 2
register unsigned int i;
Atom *atm;
d3583 9
a3591 10
    atm = (Atom *)wire;
    for (i=0;i<maxAtoms;i++) {
	if (atoms[i]!=None) {
	    *atm= atoms[i];
	    if (swap) {
		register int n;
		swapl(atm,n);
	    }
	    atm++;
	}
d3593 1
a3593 1
    return (char *)atm;
d3597 1
a3597 1
XkbComputeGetNamesReplySize(XkbDescPtr xkb,xkbGetNamesReply *rep)
d3599 2
a3600 2
register unsigned	which,length;
register int		i;
d3602 37
a3638 30
    rep->minKeyCode= xkb->min_key_code;
    rep->maxKeyCode= xkb->max_key_code;
    which= rep->which;
    length= 0;
    if (xkb->names!=NULL) {
	 if (which&XkbKeycodesNameMask)		length++;
	 if (which&XkbGeometryNameMask)		length++;
	 if (which&XkbSymbolsNameMask)		length++;
	 if (which&XkbPhysSymbolsNameMask)	length++;
	 if (which&XkbTypesNameMask)		length++;
	 if (which&XkbCompatNameMask)		length++;
    }
    else which&= ~XkbComponentNamesMask;

    if (xkb->map!=NULL) {
	if (which&XkbKeyTypeNamesMask)
	    length+= xkb->map->num_types;
	rep->nTypes= xkb->map->num_types;
	if (which&XkbKTLevelNamesMask) {
	    XkbKeyTypePtr	pType = xkb->map->types;
	    int			nKTLevels = 0;

	    length+= XkbPaddedSize(xkb->map->num_types)/4;
	    for (i=0;i<xkb->map->num_types;i++,pType++) {
		if (pType->level_names!=NULL)
		    nKTLevels+= pType->num_levels;
	    }
	    rep->nKTLevels= nKTLevels;
	    length+= nKTLevels;
	}
d3641 61
a3701 55
	rep->nTypes=    0;
	rep->nKTLevels= 0;
	which&= ~(XkbKeyTypeNamesMask|XkbKTLevelNamesMask);
    }

    rep->minKeyCode= xkb->min_key_code;
    rep->maxKeyCode= xkb->max_key_code;
    rep->indicators= 0;
    rep->virtualMods= 0;
    rep->groupNames= 0;
    if (xkb->names!=NULL) {
	if (which&XkbIndicatorNamesMask) {
	    int nLeds;
	    rep->indicators= 
		_XkbCountAtoms(xkb->names->indicators,XkbNumIndicators,&nLeds);
	    length+= nLeds;
	    if (nLeds==0)
		which&= ~XkbIndicatorNamesMask;
	}

	if (which&XkbVirtualModNamesMask) {
	    int nVMods;
	    rep->virtualMods= 
		_XkbCountAtoms(xkb->names->vmods,XkbNumVirtualMods,&nVMods);
	    length+= nVMods;
	    if (nVMods==0)
		which&= ~XkbVirtualModNamesMask;
	}

	if (which&XkbGroupNamesMask) {
	    int nGroups;
	    rep->groupNames=
		_XkbCountAtoms(xkb->names->groups,XkbNumKbdGroups,&nGroups);
	    length+= nGroups;
	    if (nGroups==0)
		which&= ~XkbGroupNamesMask;
	}

	if ((which&XkbKeyNamesMask)&&(xkb->names->keys))
	     length+= rep->nKeys;
	else which&= ~XkbKeyNamesMask;

	if ((which&XkbKeyAliasesMask)&&
	    (xkb->names->key_aliases)&&(xkb->names->num_key_aliases>0)) {
	    rep->nKeyAliases= xkb->names->num_key_aliases;
	    length+= rep->nKeyAliases*2;
	} 
	else {
	    which&= ~XkbKeyAliasesMask;
	    rep->nKeyAliases= 0;
	}

	if ((which&XkbRGNamesMask)&&(xkb->names->num_rg>0))
	     length+= xkb->names->num_rg;
	else which&= ~XkbRGNamesMask;
d3704 3
a3706 3
	which&= ~(XkbIndicatorNamesMask|XkbVirtualModNamesMask);
	which&= ~(XkbGroupNamesMask|XkbKeyNamesMask|XkbKeyAliasesMask);
	which&= ~XkbRGNamesMask;
d3709 2
a3710 2
    rep->length= length;
    rep->which= which;
d3715 1
a3715 1
XkbSendNames(ClientPtr client,XkbDescPtr xkb,xkbGetNamesReply *rep)
d3717 3
a3719 4
register unsigned 	i,length,which;
char *			start;
char *			desc;
register int            n;
d3721 2
a3722 2
    length= rep->length*4;
    which= rep->which;
d3724 5
a3728 5
	swaps(&rep->sequenceNumber,n);
	swapl(&rep->length,n);
	swapl(&rep->which,n);
	swaps(&rep->virtualMods,n);
	swapl(&rep->indicators,n);
d3732 2
a3733 2
    if ( !start )
	return BadAlloc;
d3735 2
a3736 2
        if (which&XkbKeycodesNameMask) {
            *((CARD32 *)desc)= xkb->names->keycodes;
d3738 1
a3738 1
                swapl(desc,n);
d3740 1
a3740 1
            desc+= 4;
d3742 2
a3743 2
        if (which&XkbGeometryNameMask)  {
            *((CARD32 *)desc)= xkb->names->geometry;
d3745 1
a3745 1
                swapl(desc,n);
d3747 1
a3747 1
            desc+= 4;
d3749 2
a3750 2
        if (which&XkbSymbolsNameMask) {
            *((CARD32 *)desc)= xkb->names->symbols;
d3752 1
a3752 1
                swapl(desc,n);
d3754 1
a3754 1
            desc+= 4;
d3756 4
a3759 3
        if (which&XkbPhysSymbolsNameMask) {
            register CARD32 *atm= (CARD32 *)desc;
            atm[0]= (CARD32)xkb->names->phys_symbols;
d3761 1
a3761 1
                swapl(&atm[0],n);
d3763 1
a3763 1
            desc+= 4;
d3765 2
a3766 2
        if (which&XkbTypesNameMask) {
            *((CARD32 *)desc)= (CARD32)xkb->names->types;
d3768 1
a3768 1
                swapl(desc,n);
d3770 1
a3770 1
            desc+= 4;
d3772 2
a3773 2
        if (which&XkbCompatNameMask) {
            *((CARD32 *)desc)= (CARD32)xkb->names->compat;
d3775 1
a3775 1
                swapl(desc,n);
d3777 1
a3777 1
            desc+= 4;
d3779 3
a3781 3
        if (which&XkbKeyTypeNamesMask) {
            register CARD32 *atm= (CARD32 *)desc;
            register XkbKeyTypePtr type= xkb->map->types;
d3783 2
a3784 2
            for (i=0;i<xkb->map->num_types;i++,atm++,type++) {
                *atm= (CARD32)type->name;
d3786 1
a3786 1
                    swapl(atm,n);
d3789 1
a3789 1
            desc= (char *)atm;
d3791 1
a3791 1
        if (which&XkbKTLevelNamesMask && xkb->map) {
d3794 2
a3795 1
            for (i=0;i<rep->nTypes;i++,type++) {
d3798 1
a3798 1
            desc+= XkbPaddedSize(rep->nTypes)-rep->nTypes;
d3800 1
a3800 1
            atm= (CARD32 *)desc;
d3802 1
a3802 1
            for (i=0;i<xkb->map->num_types;i++,type++) {
d3804 1
d3806 2
a3807 2
                    for (l=0;l<type->num_levels;l++,atm++) {
                        *atm= type->level_names[l];
d3809 1
a3809 1
                            swapl(atm,n);
d3812 1
a3812 1
                    desc+= type->num_levels*4;
d3816 4
a3819 3
        if (which&XkbIndicatorNamesMask) {
            desc= _XkbWriteAtoms(desc,xkb->names->indicators,XkbNumIndicators,
                                 client->swapped);
d3821 3
a3823 3
        if (which&XkbVirtualModNamesMask) {
            desc= _XkbWriteAtoms(desc,xkb->names->vmods,XkbNumVirtualMods,
                                 client->swapped);
d3825 3
a3827 3
        if (which&XkbGroupNamesMask) {
            desc= _XkbWriteAtoms(desc,xkb->names->groups,XkbNumKbdGroups,
                                 client->swapped);
d3829 3
a3831 3
        if (which&XkbKeyNamesMask) {
            for (i=0;i<rep->nKeys;i++,desc+= sizeof(XkbKeyNameRec)) {
                *((XkbKeyNamePtr)desc)= xkb->names->keys[i+rep->firstKey];
d3834 7
a3840 5
        if (which&XkbKeyAliasesMask) {
            XkbKeyAliasPtr	pAl;
            pAl= xkb->names->key_aliases;
            for (i=0;i<rep->nKeyAliases;i++,pAl++,desc+=2*XkbKeyNameLength) {
                *((XkbKeyAliasPtr)desc)= *pAl;
d3843 5
a3847 4
        if ((which&XkbRGNamesMask)&&(rep->nRadioGroups>0)) {
            register CARD32	*atm= (CARD32 *)desc;
            for (i=0;i<rep->nRadioGroups;i++,atm++) {
                *atm= (CARD32)xkb->names->radio_groups[i];
d3849 1
a3849 1
                    swapl(atm,n);
d3852 1
a3852 1
            desc+= rep->nRadioGroups*4;
d3856 3
a3858 3
    if ((desc-start)!=(length)) {
	ErrorF("[xkb] BOGUS LENGTH in write names, expected %d, got %ld\n",
					length, (unsigned long)(desc-start));
d3860 1
a3860 1
    WriteToClient(client, SIZEOF(xkbGetNamesReply), (char *)rep);
d3862 1
a3862 1
    free((char *)start);
d3869 3
a3871 3
    DeviceIntPtr	dev;
    XkbDescPtr		xkb;
    xkbGetNamesReply 	rep;
d3876 2
a3877 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d3880 1
a3880 1
    CHK_MASK_LEGAL(0x01,stuff->which,XkbAllNamesMask);
d3884 2
a3885 2
    rep.type= X_Reply;
    rep.sequenceNumber= client->sequence;
d3892 3
a3894 3
    if (xkb->names!=NULL) {
	rep.nKeyAliases= xkb->names->num_key_aliases;
	rep.nRadioGroups = xkb->names->num_rg;
d3897 1
a3897 1
	rep.nKeyAliases= rep.nRadioGroups= 0;
d3899 2
a3900 2
    XkbComputeGetNamesReplySize(xkb,&rep);
    return XkbSendNames(client,xkb,&rep);
d3906 1
a3906 1
_XkbCheckAtoms(CARD32 *wire,int nAtoms,int swapped,Atom *pError)
d3908 1
a3908 1
register int i;
d3910 8
a3917 9
    for (i=0;i<nAtoms;i++,wire++) {
	if (swapped) {
	    register int n;
	    swapl(wire,n);
	}
	if ((((Atom)*wire)!=None)&&(!ValidAtom((Atom)*wire))) {
	    *pError= ((Atom)*wire);
	    return NULL;
	}
d3923 2
a3924 2
_XkbCheckMaskedAtoms(CARD32 *wire,int nAtoms,CARD32 present,int swapped,
								Atom *pError)
d3926 1
a3926 1
register unsigned i,bit;
d3928 11
a3938 12
    for (i=0,bit=1;(i<nAtoms)&&(present);i++,bit<<=1) {
	if ((present&bit)==0)
	    continue;
	if (swapped) {
	    register int n;
	    swapl(wire,n);
	}
	if ((((Atom)*wire)!=None)&&(!ValidAtom(((Atom)*wire)))) {
	    *pError= (Atom)*wire;
	    return NULL;
	}
	wire++;
d3944 8
a3951 11
_XkbCopyMaskedAtoms(	Atom	*wire,
    			Atom	*dest,
			int   	 nAtoms,
			CARD32	 present)
{
register int i,bit;

    for (i=0,bit=1;(i<nAtoms)&&(present);i++,bit<<=1) {
	if ((present&bit)==0)
	    continue;
	dest[i]= *wire++;
d3957 1
a3957 1
_XkbCheckTypeName(Atom name,int typeNdx)
d3959 1
a3959 1
const char *	str;
d3961 4
a3964 4
    str= NameForAtom(name);
    if ((strcmp(str,"ONE_LEVEL")==0)||(strcmp(str,"TWO_LEVEL")==0)||
	(strcmp(str,"ALPHABETIC")==0)||(strcmp(str,"KEYPAD")==0))
	return FALSE;
d3974 1
a3974 1
                  xkbSetNamesReq *stuff, CARD32 *data)
d3976 4
a3979 4
    XkbDescRec		*xkb;
    XkbNamesRec		*names;
    CARD32		*tmp;
    Atom		 bad;
a3984 1

d3987 4
a3990 3
        CARD32	*old;
        if ( stuff->nTypes<1 ) {
            client->errorValue = _XkbErrCode2(0x02,stuff->nTypes);
d3993 5
a3997 4
        if ((unsigned)(stuff->firstType+stuff->nTypes-1)>=xkb->map->num_types) {
            client->errorValue = _XkbErrCode4(0x03,stuff->firstType,
                    stuff->nTypes,
                    xkb->map->num_types);
d4000 2
a4001 2
        if (((unsigned)stuff->firstType)<=XkbLastRequiredType) {
            client->errorValue = _XkbErrCode2(0x04,stuff->firstType);
d4004 2
a4005 2
        old= tmp;
        tmp= _XkbCheckAtoms(tmp,stuff->nTypes,client->swapped,&bad);
d4007 1
a4007 1
            client->errorValue= bad;
d4010 3
a4012 3
        for (i=0;i<stuff->nTypes;i++,old++) {
            if (!_XkbCheckTypeName((Atom)*old,stuff->firstType+i))
                client->errorValue= _XkbErrCode2(0x05,i);
d4015 1
a4015 1
    if (stuff->which&XkbKTLevelNamesMask) {
d4017 5
a4021 4
        XkbKeyTypePtr	type;
        CARD8 *		width;
        if ( stuff->nKTLevels<1 ) {
            client->errorValue = _XkbErrCode2(0x05,stuff->nKTLevels);
d4024 5
a4028 4
        if ((unsigned)(stuff->firstKTLevel+stuff->nKTLevels-1)>=
                xkb->map->num_types) {
            client->errorValue = _XkbErrCode4(0x06,stuff->firstKTLevel,
                    stuff->nKTLevels,xkb->map->num_types);
d4031 2
a4032 2
        width = (CARD8 *)tmp;
        tmp= (CARD32 *)(((char *)tmp)+XkbPaddedSize(stuff->nKTLevels));
d4034 2
a4035 2
        for (i=0;i<stuff->nKTLevels;i++,type++) {
            if (width[i]==0)
d4037 3
a4039 3
            else if (width[i]!=type->num_levels) {
                client->errorValue= _XkbErrCode4(0x07,i+stuff->firstKTLevel,
                        type->num_levels,width[i]);
d4042 1
a4042 1
            tmp= _XkbCheckAtoms(tmp,width[i],client->swapped,&bad);
d4044 1
a4044 1
                client->errorValue= bad;
d4049 3
a4051 3
    if (stuff->which&XkbIndicatorNamesMask) {
        if (stuff->indicators==0) {
            client->errorValue= 0x08;
d4054 2
a4055 2
        tmp= _XkbCheckMaskedAtoms(tmp,XkbNumIndicators,stuff->indicators,
                client->swapped,&bad);
d4057 1
a4057 1
            client->errorValue= bad;
d4061 3
a4063 3
    if (stuff->which&XkbVirtualModNamesMask) {
        if (stuff->virtualMods==0) {
            client->errorValue= 0x09;
d4066 3
a4068 3
        tmp= _XkbCheckMaskedAtoms(tmp,XkbNumVirtualMods,
                (CARD32)stuff->virtualMods,
                client->swapped,&bad);
d4074 3
a4076 3
    if (stuff->which&XkbGroupNamesMask) {
        if (stuff->groupNames==0) {
            client->errorValue= 0x0a;
d4079 3
a4081 3
        tmp= _XkbCheckMaskedAtoms(tmp,XkbNumKbdGroups,
                (CARD32)stuff->groupNames,
                client->swapped,&bad);
d4087 4
a4090 4
    if (stuff->which&XkbKeyNamesMask) {
        if (stuff->firstKey<(unsigned)xkb->min_key_code) {
            client->errorValue= _XkbErrCode3(0x0b,xkb->min_key_code,
                    stuff->firstKey);
d4093 5
a4097 4
        if (((unsigned)(stuff->firstKey+stuff->nKeys-1)>xkb->max_key_code)||
                (stuff->nKeys<1)) {
            client->errorValue= _XkbErrCode4(0x0c,xkb->max_key_code,
                    stuff->firstKey,stuff->nKeys);
d4100 1
a4100 1
        tmp+= stuff->nKeys;
d4102 2
a4103 2
    if ((stuff->which&XkbKeyAliasesMask)&&(stuff->nKeyAliases>0)) {
        tmp+= stuff->nKeyAliases*2;
d4105 3
a4107 3
    if (stuff->which&XkbRGNamesMask) {
        if ( stuff->nRadioGroups<1 ) {
            client->errorValue= _XkbErrCode2(0x0d,stuff->nRadioGroups);
d4110 1
a4110 1
        tmp= _XkbCheckAtoms(tmp,stuff->nRadioGroups,client->swapped,&bad);
d4112 1
a4112 1
            client->errorValue= bad;
d4116 1
a4116 1
    if ((tmp-((CARD32 *)stuff))!=stuff->length) {
a4120 2


d4125 1
a4125 1
_XkbSetNames(ClientPtr client, DeviceIntPtr dev, xkbSetNamesReq *stuff)
d4127 4
a4130 4
    XkbDescRec		*xkb;
    XkbNamesRec		*names;
    CARD32		*tmp;
    xkbNamesNotify	 nn;
d4132 1
a4132 1
    tmp = (CARD32 *)&stuff[1];
d4136 2
a4137 2
    if (XkbAllocNames(xkb,stuff->which,stuff->nRadioGroups,
                stuff->nKeyAliases)!=Success) {
d4142 15
a4156 15
    nn.changed= stuff->which;
    tmp = (CARD32 *)&stuff[1];
    if (stuff->which&XkbKeycodesNameMask)
        names->keycodes= *tmp++;
    if (stuff->which&XkbGeometryNameMask)
        names->geometry= *tmp++;
    if (stuff->which&XkbSymbolsNameMask)
        names->symbols= *tmp++;
    if (stuff->which&XkbPhysSymbolsNameMask)
        names->phys_symbols= *tmp++;
    if (stuff->which&XkbTypesNameMask)
        names->types= *tmp++;
    if (stuff->which&XkbCompatNameMask)
        names->compat= *tmp++;
    if ((stuff->which&XkbKeyTypeNamesMask)&&(stuff->nTypes>0)) {
d4160 3
a4162 3
        type= &xkb->map->types[stuff->firstType];
        for (i=0;i<stuff->nTypes;i++,type++) {
            type->name= *tmp++;
d4164 2
a4165 2
        nn.firstType= stuff->firstType;
        nn.nTypes= stuff->nTypes;
d4167 2
a4168 2
    if (stuff->which&XkbKTLevelNamesMask) {
        register XkbKeyTypePtr	type;
d4172 5
a4176 5
        width = (CARD8 *)tmp;
        tmp= (CARD32 *)(((char *)tmp)+XkbPaddedSize(stuff->nKTLevels));
        type= &xkb->map->types[stuff->firstKTLevel];
        for (i=0;i<stuff->nKTLevels;i++,type++) {
            if (width[i]>0) {
d4179 3
a4181 2
                    for (n=0;n<width[i];n++) {
                        type->level_names[n]= tmp[n];
d4184 1
a4184 1
                tmp+= width[i];
d4187 2
a4188 2
        nn.firstLevelName= 0;
        nn.nLevelNames= stuff->nTypes;
d4190 27
a4216 26
    if (stuff->which&XkbIndicatorNamesMask) {
        tmp= _XkbCopyMaskedAtoms(tmp,names->indicators,XkbNumIndicators,
                stuff->indicators);
        nn.changedIndicators= stuff->indicators;
    }
    if (stuff->which&XkbVirtualModNamesMask) {
        tmp= _XkbCopyMaskedAtoms(tmp,names->vmods,XkbNumVirtualMods,
                stuff->virtualMods);
        nn.changedVirtualMods= stuff->virtualMods;
    }
    if (stuff->which&XkbGroupNamesMask) {
        tmp= _XkbCopyMaskedAtoms(tmp,names->groups,XkbNumKbdGroups,
                stuff->groupNames);
        nn.changedVirtualMods= stuff->groupNames;
    }
    if (stuff->which&XkbKeyNamesMask) {
        memcpy((char*)&names->keys[stuff->firstKey],(char *)tmp,
                stuff->nKeys*XkbKeyNameLength);
        tmp+= stuff->nKeys;
        nn.firstKey= stuff->firstKey;
        nn.nKeys= stuff->nKeys;
    }
    if (stuff->which&XkbKeyAliasesMask) {
        if (stuff->nKeyAliases>0) {
            register int na= stuff->nKeyAliases;	
            if (XkbAllocNames(xkb,XkbKeyAliasesMask,0,na)!=Success)
d4218 3
a4220 3
            memcpy((char *)names->key_aliases,(char *)tmp,
                    stuff->nKeyAliases*sizeof(XkbKeyAliasRec));
            tmp+= stuff->nKeyAliases*2;
d4222 1
a4222 1
        else if (names->key_aliases!=NULL) {
d4224 2
a4225 2
            names->key_aliases= NULL;
            names->num_key_aliases= 0;
d4227 1
a4227 1
        nn.nAliases= names->num_key_aliases;
d4229 6
a4234 5
    if (stuff->which&XkbRGNamesMask) {
        if (stuff->nRadioGroups>0) {
            register unsigned i,nrg;
            nrg= stuff->nRadioGroups;
            if (XkbAllocNames(xkb,XkbRGNamesMask,nrg,0)!=Success)
d4237 2
a4238 2
            for (i=0;i<stuff->nRadioGroups;i++) {
                names->radio_groups[i]= tmp[i];
d4240 1
a4240 1
            tmp+= stuff->nRadioGroups;
d4244 2
a4245 2
            names->radio_groups= NULL;
            names->num_rg= 0;
d4247 1
a4247 1
        nn.nRadioGroups= names->num_rg;
d4251 3
a4253 2
        needExtEvent= (nn.changed&XkbIndicatorNamesMask)!=0;
        XkbSendNamesNotify(dev,&nn);
d4255 11
a4265 11
            XkbSrvLedInfoPtr		sli;
            xkbExtensionDeviceNotify	edev;
            register int		i;
            register unsigned		bit;

            sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,
                    XkbXI_IndicatorsMask);
            sli->namesPresent= 0;
            for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
                if (names->indicators[i]!=None)
                    sli->namesPresent|= bit;
d4268 10
a4277 10
            edev.reason=	XkbXI_IndicatorNamesMask;
            edev.ledClass=	KbdFeedbackClass;
            edev.ledID=		dev->kbdfeed->ctrl.id;
            edev.ledsDefined= 	sli->namesPresent|sli->mapsPresent;
            edev.ledState=	sli->effectiveState;
            edev.firstBtn=	0;
            edev.nBtns=		0;
            edev.supported=	XkbXI_AllFeaturesMask;
            edev.unsupported=	0;
            XkbSendExtensionDeviceNotify(dev,client,&edev);
d4286 4
a4289 4
    DeviceIntPtr	 dev;
    CARD32		*tmp;
    Atom                 bad;
    int                  rc;
d4294 2
a4295 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d4298 1
a4298 1
    CHK_MASK_LEGAL(0x01,stuff->which,XkbAllNamesMask);
d4301 1
a4301 1
    tmp = (CARD32 *)&stuff[1];
d4303 41
a4343 41
    if (stuff->which&XkbKeycodesNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbGeometryNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbSymbolsNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbPhysSymbolsNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue= bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbTypesNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbCompatNameMask) {
	tmp= _XkbCheckAtoms(tmp,1,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
d4351 1
a4351 2
    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
a4352 4
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
d4354 7
a4360 3
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
d4375 1
a4375 2
    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
a4376 4
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
d4378 6
a4383 1
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
d4413 1
a4413 1
XkbWriteCountedString(char *wire,char *str,Bool swap)
d4415 1
a4415 1
    CARD16 len,*pLen, paddedLen;
d4420 3
a4422 3
    len= strlen(str);
    pLen= (CARD16 *)wire;
    *pLen= len;
d4424 1
a4424 2
	register int n;
	swaps(pLen,n);
d4426 3
a4428 3
    paddedLen= pad_to_int32(sizeof(len)+len)-sizeof(len);
    strncpy(&wire[sizeof(len)],str,paddedLen);
    wire+= sizeof(len)+paddedLen;
d4435 7
a4441 6
register int 	i,size;
XkbPropertyPtr	prop;
    
    for (size=i=0,prop=geom->properties;i<geom->num_properties;i++,prop++) {
	size+= XkbSizeCountedString(prop->name);
	size+= XkbSizeCountedString(prop->value);
d4447 1
a4447 1
XkbWriteGeomProperties(char *wire,XkbGeometryPtr geom,Bool swap)
d4449 6
a4454 6
register int 	i;
register XkbPropertyPtr	prop;
    
    for (i=0,prop=geom->properties;i<geom->num_properties;i++,prop++) {
	wire= XkbWriteCountedString(wire,prop->name,swap);
	wire= XkbWriteCountedString(wire,prop->value,swap);
d4462 1
a4462 1
    return geom->num_key_aliases*(2*XkbKeyNameLength);
d4466 1
a4466 1
XkbWriteGeomKeyAliases(char *wire,XkbGeometryPtr geom,Bool swap)
d4468 6
a4473 6
register int sz;
    
    sz= geom->num_key_aliases*(XkbKeyNameLength*2);
    if (sz>0) {
	memcpy(wire,(char *)geom->key_aliases,sz);
	wire+= sz;
d4481 2
a4482 2
register int 		i,size;
register XkbColorPtr	color;
d4484 2
a4485 2
    for (i=size=0,color=geom->colors;i<geom->num_colors;i++,color++) {
	size+= XkbSizeCountedString(color->spec);
d4491 1
a4491 1
XkbWriteGeomColors(char *wire,XkbGeometryPtr geom,Bool swap)
d4493 2
a4494 2
register int		i;
register XkbColorPtr	color;
d4496 2
a4497 2
    for (i=0,color=geom->colors;i<geom->num_colors;i++,color++) {
	wire= XkbWriteCountedString(wire,color->spec,swap);
d4505 2
a4506 2
register int		i,size;
register XkbShapePtr	shape;
d4508 9
a4516 8
    for (i=size=0,shape=geom->shapes;i<geom->num_shapes;i++,shape++) {
	register int		n;
	register XkbOutlinePtr	ol;
	size+= SIZEOF(xkbShapeWireDesc);
	for (n=0,ol=shape->outlines;n<shape->num_outlines;n++,ol++) {
	    size+= SIZEOF(xkbOutlineWireDesc);
	    size+= ol->num_points*SIZEOF(xkbPointWireDesc);
	}
d4522 1
a4522 1
XkbWriteGeomShapes(char *wire,XkbGeometryPtr geom,Bool swap)
d4524 46
a4569 44
int			i;
XkbShapePtr		shape;
xkbShapeWireDesc *	shapeWire;

    for (i=0,shape=geom->shapes;i<geom->num_shapes;i++,shape++) {
	register int 		o;
	XkbOutlinePtr		ol;
	xkbOutlineWireDesc *	olWire;
	shapeWire= (xkbShapeWireDesc *)wire;
	shapeWire->name= shape->name;
	shapeWire->nOutlines= shape->num_outlines;
	if (shape->primary!=NULL)
	     shapeWire->primaryNdx= XkbOutlineIndex(shape,shape->primary);
	else shapeWire->primaryNdx= XkbNoShape;
	if (shape->approx!=NULL)
	     shapeWire->approxNdx= XkbOutlineIndex(shape,shape->approx);
	else shapeWire->approxNdx= XkbNoShape;
	shapeWire->pad= 0;
	if (swap) {
	    register int n;
	    swapl(&shapeWire->name,n);
	}
	wire= (char *)&shapeWire[1];
	for (o=0,ol=shape->outlines;o<shape->num_outlines;o++,ol++) {
	    register int	p;
	    XkbPointPtr		pt;
	    xkbPointWireDesc *	ptWire;
	    olWire= (xkbOutlineWireDesc *)wire;
	    olWire->nPoints= ol->num_points;
	    olWire->cornerRadius= ol->corner_radius;
	    olWire->pad= 0;
	    wire= (char *)&olWire[1];
	    ptWire= (xkbPointWireDesc *)wire;
	    for (p=0,pt=ol->points;p<ol->num_points;p++,pt++) {
		ptWire[p].x= pt->x;
		ptWire[p].y= pt->y;
		if (swap) {
		    register int n;
		    swaps(&ptWire[p].x,n);
		    swaps(&ptWire[p].y,n);
		}
	    }
	    wire= (char *)&ptWire[ol->num_points];
	}
d4575 1
a4575 1
XkbSizeGeomDoodads(int num_doodads,XkbDoodadPtr doodad)
d4577 1
a4577 1
register int	i,size;
d4579 9
a4587 9
    for (i=size=0;i<num_doodads;i++,doodad++) {
	size+= SIZEOF(xkbAnyDoodadWireDesc);
	if (doodad->any.type==XkbTextDoodad) {
	    size+= XkbSizeCountedString(doodad->text.text);
	    size+= XkbSizeCountedString(doodad->text.font);
	}
	else if (doodad->any.type==XkbLogoDoodad) {
	    size+= XkbSizeCountedString(doodad->logo.logo_name);
	}
d4593 1
a4593 1
XkbWriteGeomDoodads(char *wire,int num_doodads,XkbDoodadPtr doodad,Bool swap)
d4595 2
a4596 2
register int		i;
xkbDoodadWireDesc *	doodadWire;
d4598 54
a4651 58
    for (i=0;i<num_doodads;i++,doodad++) {
	doodadWire= (xkbDoodadWireDesc *)wire;
	wire= (char *)&doodadWire[1];
	memset(doodadWire, 0, SIZEOF(xkbDoodadWireDesc));
	doodadWire->any.name= doodad->any.name;
	doodadWire->any.type= doodad->any.type;
	doodadWire->any.priority= doodad->any.priority;
	doodadWire->any.top= doodad->any.top;
	doodadWire->any.left= doodad->any.left;
	if (swap) {
	    register int n;
	    swapl(&doodadWire->any.name,n);
	    swaps(&doodadWire->any.top,n);
	    swaps(&doodadWire->any.left,n);
	}
	switch (doodad->any.type) {
	    case XkbOutlineDoodad:
	    case XkbSolidDoodad:
		doodadWire->shape.angle= doodad->shape.angle;
		doodadWire->shape.colorNdx= doodad->shape.color_ndx;
		doodadWire->shape.shapeNdx= doodad->shape.shape_ndx;
		if (swap) {
		    register int n;
		    swaps(&doodadWire->shape.angle,n);
		}
		break;
	    case XkbTextDoodad:
		doodadWire->text.angle= doodad->text.angle;
		doodadWire->text.width= doodad->text.width;
		doodadWire->text.height= doodad->text.height;
		doodadWire->text.colorNdx= doodad->text.color_ndx;
		if (swap) {
		    register int n;
		    swaps(&doodadWire->text.angle,n);
		    swaps(&doodadWire->text.width,n);
		    swaps(&doodadWire->text.height,n);
		}
		wire= XkbWriteCountedString(wire,doodad->text.text,swap);
		wire= XkbWriteCountedString(wire,doodad->text.font,swap);
		break;
	    case XkbIndicatorDoodad:
		doodadWire->indicator.shapeNdx= doodad->indicator.shape_ndx;
		doodadWire->indicator.onColorNdx=doodad->indicator.on_color_ndx;
		doodadWire->indicator.offColorNdx=
						doodad->indicator.off_color_ndx;
		break;
	    case XkbLogoDoodad:
		doodadWire->logo.angle= doodad->logo.angle;
		doodadWire->logo.colorNdx= doodad->logo.color_ndx;
		doodadWire->logo.shapeNdx= doodad->logo.shape_ndx;
		wire= XkbWriteCountedString(wire,doodad->logo.logo_name,swap);
		break;
	    default:
		ErrorF("[xkb] Unknown doodad type %d in XkbWriteGeomDoodads\n",
			doodad->any.type);
		ErrorF("[xkb] Ignored\n");
		break;
	}
d4657 1
a4657 1
XkbWriteGeomOverlay(char *wire,XkbOverlayPtr ol,Bool swap)
d4659 33
a4691 32
register int		r;
XkbOverlayRowPtr	row;
xkbOverlayWireDesc *	olWire;

   olWire= (xkbOverlayWireDesc *)wire;
   olWire->name= ol->name;
   olWire->nRows= ol->num_rows;
   olWire->pad1= 0;
   olWire->pad2= 0;
   if (swap) {
	register int n;
	swapl(&olWire->name,n);
   }
   wire= (char *)&olWire[1];
   for (r=0,row=ol->rows;r<ol->num_rows;r++,row++) {
   	unsigned int		k;
	XkbOverlayKeyPtr	key;
	xkbOverlayRowWireDesc *	rowWire;
	rowWire= (xkbOverlayRowWireDesc *)wire;
	rowWire->rowUnder= row->row_under;
	rowWire->nKeys= row->num_keys;
	rowWire->pad1= 0;
	wire= (char *)&rowWire[1];
	for (k=0,key=row->keys;k<row->num_keys;k++,key++) {
	    xkbOverlayKeyWireDesc *	keyWire;
	    keyWire= (xkbOverlayKeyWireDesc *)wire;
	    memcpy(keyWire->over,key->over.name,XkbKeyNameLength);
	    memcpy(keyWire->under,key->under.name,XkbKeyNameLength);
	    wire= (char *)&keyWire[1];
	}
   }
   return wire;
d4697 2
a4698 2
register int 	i,size;
XkbSectionPtr	section;
d4700 30
a4729 25
    for (i=size=0,section=geom->sections;i<geom->num_sections;i++,section++) {
	size+= SIZEOF(xkbSectionWireDesc);
	if (section->rows) {
	    int		r;
	    XkbRowPtr	row;
	    for (r=0,row=section->rows;r<section->num_rows;row++,r++) {
		size+= SIZEOF(xkbRowWireDesc);
		size+= row->num_keys*SIZEOF(xkbKeyWireDesc);
	    }
	}
	if (section->doodads)
	    size+= XkbSizeGeomDoodads(section->num_doodads,section->doodads);
	if (section->overlays) {
	    int			o;
	    XkbOverlayPtr	ol;
	    for (o=0,ol=section->overlays;o<section->num_overlays;o++,ol++) {
		int			r;
		XkbOverlayRowPtr	row;
		size+= SIZEOF(xkbOverlayWireDesc);
		for (r=0,row=ol->rows;r<ol->num_rows;r++,row++) {
		   size+= SIZEOF(xkbOverlayRowWireDesc);
		   size+= row->num_keys*SIZEOF(xkbOverlayKeyWireDesc);
		}
	    }
	}
d4735 1
a4735 1
XkbWriteGeomSections(char *wire,XkbGeometryPtr geom,Bool swap)
d4737 76
a4812 74
register int		i;
XkbSectionPtr		section;
xkbSectionWireDesc *	sectionWire;

    for (i=0,section=geom->sections;i<geom->num_sections;i++,section++) {
	sectionWire= (xkbSectionWireDesc *)wire;
	sectionWire->name= section->name;
	sectionWire->top= section->top;
	sectionWire->left= section->left;
	sectionWire->width= section->width;
	sectionWire->height= section->height;
	sectionWire->angle= section->angle;
	sectionWire->priority= section->priority;
	sectionWire->nRows= section->num_rows;
	sectionWire->nDoodads= section->num_doodads;
	sectionWire->nOverlays= section->num_overlays;
	sectionWire->pad= 0;
	if (swap) {
	    register int n;
	    swapl(&sectionWire->name,n);
	    swaps(&sectionWire->top,n);
	    swaps(&sectionWire->left,n);
	    swaps(&sectionWire->width,n);
	    swaps(&sectionWire->height,n);
	    swaps(&sectionWire->angle,n);
	}
	wire= (char *)&sectionWire[1];
	if (section->rows) {
	    int			r;
	    XkbRowPtr		row;
	    xkbRowWireDesc *	rowWire;
	    for (r=0,row=section->rows;r<section->num_rows;r++,row++) {
		rowWire= (xkbRowWireDesc *)wire;
		rowWire->top= row->top;
		rowWire->left= row->left;
		rowWire->nKeys= row->num_keys;
		rowWire->vertical= row->vertical;
		rowWire->pad= 0;
		if (swap) {
		    register int n;
		    swaps(&rowWire->top,n);
		    swaps(&rowWire->left,n);
		}
		wire= (char *)&rowWire[1];
		if (row->keys) {
		    int			k;
		    XkbKeyPtr		key;
		    xkbKeyWireDesc *	keyWire;
		    keyWire= (xkbKeyWireDesc *)wire;
		    for (k=0,key=row->keys;k<row->num_keys;k++,key++) {
			memcpy(keyWire[k].name,key->name.name,XkbKeyNameLength);
			keyWire[k].gap= key->gap;
			keyWire[k].shapeNdx= key->shape_ndx;
			keyWire[k].colorNdx= key->color_ndx;
			if (swap) {
			    register int n;
			    swaps(&keyWire[k].gap,n);
			}
		    }
		    wire= (char *)&keyWire[row->num_keys];
		}
	    }
	}
	if (section->doodads) {
	    wire= XkbWriteGeomDoodads(wire,
	    			      section->num_doodads,section->doodads,
				      swap);
	}
	if (section->overlays) {
	    register int o;
	    for (o=0;o<section->num_overlays;o++) {
		wire= XkbWriteGeomOverlay(wire,&section->overlays[o],swap);
	    }
	}
d4818 26
a4843 27
XkbComputeGetGeometryReplySize(	XkbGeometryPtr		geom,
				xkbGetGeometryReply *	rep,
				Atom			name)
{
int	len;

    if (geom!=NULL) {
	len= XkbSizeCountedString(geom->label_font);
	len+= XkbSizeGeomProperties(geom);
	len+= XkbSizeGeomColors(geom);
	len+= XkbSizeGeomShapes(geom);
	len+= XkbSizeGeomSections(geom);
	len+= XkbSizeGeomDoodads(geom->num_doodads,geom->doodads);
	len+= XkbSizeGeomKeyAliases(geom);
	rep->length= len/4;
	rep->found= TRUE;
	rep->name= geom->name;
	rep->widthMM= geom->width_mm;
	rep->heightMM= geom->height_mm;
	rep->nProperties= geom->num_properties;
	rep->nColors= geom->num_colors;
	rep->nShapes= geom->num_shapes;
	rep->nSections= geom->num_sections;
	rep->nDoodads= geom->num_doodads;
	rep->nKeyAliases= geom->num_key_aliases;
	rep->baseColorNdx= XkbGeomColorIndex(geom,geom->base_color);
	rep->labelColorNdx= XkbGeomColorIndex(geom,geom->label_color);
d4846 8
a4853 8
	rep->length= 0;
	rep->found= FALSE;
	rep->name= name;
	rep->widthMM= rep->heightMM= 0;
	rep->nProperties= rep->nColors= rep->nShapes= 0;
	rep->nSections= rep->nDoodads= 0;
	rep->nKeyAliases= 0;
	rep->labelColorNdx= rep->baseColorNdx= 0;
d4859 30
a4888 31
XkbSendGeometry(	ClientPtr		client,
			XkbGeometryPtr		geom,
			xkbGetGeometryReply *	rep,
			Bool			freeGeom)
{
    char	*desc,*start;
    int		 len;

    if (geom!=NULL) {
	len= rep->length*4;
	start= desc= malloc(len);
	if (!start)
	    return BadAlloc;
	desc=  XkbWriteCountedString(desc,geom->label_font,client->swapped);
	if ( rep->nProperties>0 )
	    desc = XkbWriteGeomProperties(desc,geom,client->swapped);
	if ( rep->nColors>0 )
	    desc = XkbWriteGeomColors(desc,geom,client->swapped);
	if ( rep->nShapes>0 )
	    desc = XkbWriteGeomShapes(desc,geom,client->swapped);
	if ( rep->nSections>0 )
	    desc = XkbWriteGeomSections(desc,geom,client->swapped);
	if ( rep->nDoodads>0 )
	    desc = XkbWriteGeomDoodads(desc,geom->num_doodads,geom->doodads,
							  client->swapped);
	if ( rep->nKeyAliases>0 )
	    desc = XkbWriteGeomKeyAliases(desc,geom,client->swapped);
	if ((desc-start)!=(len)) {
	    ErrorF("[xkb] BOGUS LENGTH in XkbSendGeometry, expected %d, got %ld\n",
			len, (unsigned long)(desc-start));
	}
d4891 2
a4892 2
	len= 0;
	start= NULL;
d4895 17
a4911 18
	register int n;
	swaps(&rep->sequenceNumber,n);
	swapl(&rep->length,n);
	swapl(&rep->name,n);
	swaps(&rep->widthMM,n);
	swaps(&rep->heightMM,n);
	swaps(&rep->nProperties,n);
	swaps(&rep->nColors,n);
	swaps(&rep->nShapes,n);
	swaps(&rep->nSections,n);
	swaps(&rep->nDoodads,n);
	swaps(&rep->nKeyAliases,n);
    }
    WriteToClient(client, SIZEOF(xkbGetGeometryReply), (char *)rep);
    if (len>0)
	WriteToClient(client, len, start);
    if (start!=NULL)
	free((char *)start);
d4913 1
a4913 1
	XkbFreeGeometry(geom,XkbGeomAllMask,TRUE);
d4920 1
a4920 1
    DeviceIntPtr 	dev;
d4922 3
a4924 3
    XkbGeometryPtr	geom;
    Bool		shouldFree;
    Status		status;
d4929 2
a4930 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d4935 10
a4944 9
    geom= XkbLookupNamedGeometry(dev,stuff->name,&shouldFree);
    rep.type= X_Reply;
    rep.deviceID= dev->id;
    rep.sequenceNumber= client->sequence;
    rep.length= 0;
    status= XkbComputeGetGeometryReplySize(geom,&rep,stuff->name);
    if (status!=Success)
	 return status;
    else return XkbSendGeometry(client,geom,&rep,shouldFree);
d4950 1
a4950 1
_GetCountedString(char **wire_inout,Bool swap)
d4952 2
a4953 2
char *	wire,*str;
CARD16	len,*plen;
d4955 2
a4956 2
    wire= *wire_inout;
    plen= (CARD16 *)wire;
d4958 1
a4958 2
	register int n;
	swaps(plen,n);
d4960 2
a4961 2
    len= *plen;
    str= malloc(len+1);
d4963 2
a4964 2
	memcpy(str,&wire[2],len);
	str[len]= '\0';
d4966 2
a4967 2
    wire+= XkbPaddedSize(len+2);
    *wire_inout= wire;
d4972 6
a4977 8
_CheckSetDoodad(	char **		wire_inout,
			XkbGeometryPtr	geom,
			XkbSectionPtr	section,
			ClientPtr	client)
{
char *			wire;
xkbDoodadWireDesc *	dWire;
XkbDoodadPtr		doodad;
d4979 2
a4980 2
    dWire= (xkbDoodadWireDesc *)(*wire_inout);
    wire= (char *)&dWire[1];
d4982 4
a4985 5
	register int n;
	swapl(&dWire->any.name,n);
	swaps(&dWire->any.top,n);
	swaps(&dWire->any.left,n);
	swaps(&dWire->any.angle,n);
d4988 1
a4988 1
    doodad= XkbAddGeomDoodad(geom,section,dWire->any.name);
d4990 6
a4995 6
	return BadAlloc;
    doodad->any.type= dWire->any.type;
    doodad->any.priority= dWire->any.priority;
    doodad->any.top= dWire->any.top;
    doodad->any.left= dWire->any.left;
    doodad->any.angle= dWire->any.angle;
d4997 69
a5065 70
	case XkbOutlineDoodad:
	case XkbSolidDoodad:
	    if (dWire->shape.colorNdx>=geom->num_colors) {
		client->errorValue= _XkbErrCode3(0x40,geom->num_colors,
							dWire->shape.colorNdx);
		return BadMatch;
	    }
	    if (dWire->shape.shapeNdx>=geom->num_shapes) {
		client->errorValue= _XkbErrCode3(0x41,geom->num_shapes,
							dWire->shape.shapeNdx);
		return BadMatch;
	    }
	    doodad->shape.color_ndx= dWire->shape.colorNdx;
	    doodad->shape.shape_ndx= dWire->shape.shapeNdx;
	    break;
	case XkbTextDoodad:
	    if (dWire->text.colorNdx>=geom->num_colors) {
		client->errorValue= _XkbErrCode3(0x42,geom->num_colors,
							dWire->text.colorNdx);
		return BadMatch;
	    }
	    if (client->swapped) {
		register int n;
		swaps(&dWire->text.width,n);
		swaps(&dWire->text.height,n);
	    }
	    doodad->text.width= dWire->text.width;
	    doodad->text.height= dWire->text.height;
	    doodad->text.color_ndx= dWire->text.colorNdx;
	    doodad->text.text= _GetCountedString(&wire,client->swapped);
	    doodad->text.font= _GetCountedString(&wire,client->swapped);
	    break;
	case XkbIndicatorDoodad:
	    if (dWire->indicator.onColorNdx>=geom->num_colors) {
		client->errorValue= _XkbErrCode3(0x43,geom->num_colors,
						dWire->indicator.onColorNdx);
		return BadMatch;
	    }
	    if (dWire->indicator.offColorNdx>=geom->num_colors) {
		client->errorValue= _XkbErrCode3(0x44,geom->num_colors,
						dWire->indicator.offColorNdx);
		return BadMatch;
	    }
	    if (dWire->indicator.shapeNdx>=geom->num_shapes) {
		client->errorValue= _XkbErrCode3(0x45,geom->num_shapes,
						dWire->indicator.shapeNdx);
		return BadMatch;
	    }
	    doodad->indicator.shape_ndx= dWire->indicator.shapeNdx;
	    doodad->indicator.on_color_ndx= dWire->indicator.onColorNdx;
	    doodad->indicator.off_color_ndx= dWire->indicator.offColorNdx;
	    break;
	case XkbLogoDoodad:
	    if (dWire->logo.colorNdx>=geom->num_colors) {
		client->errorValue= _XkbErrCode3(0x46,geom->num_colors,
							dWire->logo.colorNdx);
		return BadMatch;
	    }
	    if (dWire->logo.shapeNdx>=geom->num_shapes) {
		client->errorValue= _XkbErrCode3(0x47,geom->num_shapes,
							dWire->logo.shapeNdx);
		return BadMatch;
	    }
	    doodad->logo.color_ndx= dWire->logo.colorNdx;
	    doodad->logo.shape_ndx= dWire->logo.shapeNdx;
	    doodad->logo.logo_name= _GetCountedString(&wire,client->swapped);
	    break;
	default:
	    client->errorValue= _XkbErrCode2(0x4F,dWire->any.type);
	    return BadValue;
d5067 1
a5067 1
    *wire_inout= wire;
d5072 8
a5079 10
_CheckSetOverlay(	char **		wire_inout,
			XkbGeometryPtr	geom,
			XkbSectionPtr	section,
			ClientPtr	client)
{
register int		r;
char *			wire;
XkbOverlayPtr		ol;
xkbOverlayWireDesc *	olWire;
xkbOverlayRowWireDesc *	rWire;
d5081 2
a5082 2
    wire= *wire_inout;
    olWire= (xkbOverlayWireDesc *)wire;
d5084 1
a5084 2
	register int n;
	swapl(&olWire->name,n);
d5087 27
a5113 26
    ol= XkbAddGeomOverlay(section,olWire->name,olWire->nRows);
    rWire= (xkbOverlayRowWireDesc *)&olWire[1];
    for (r=0;r<olWire->nRows;r++) {
	register int		k;
	xkbOverlayKeyWireDesc *	kWire;
	XkbOverlayRowPtr	row;

	if (rWire->rowUnder>section->num_rows) {
	    client->errorValue= _XkbErrCode4(0x20,r,section->num_rows,
							rWire->rowUnder);
	    return BadMatch;
	}
	row= XkbAddGeomOverlayRow(ol,rWire->rowUnder,rWire->nKeys);
	kWire= (xkbOverlayKeyWireDesc *)&rWire[1];
	for (k=0;k<rWire->nKeys;k++,kWire++) {
	    if (XkbAddGeomOverlayKey(ol,row,
	    		(char *)kWire->over,(char *)kWire->under)==NULL) {
		client->errorValue= _XkbErrCode3(0x21,r,k);
		return BadMatch;
	    }	
	}
	rWire= (xkbOverlayRowWireDesc *)kWire;
    }
    olWire= (xkbOverlayWireDesc *)rWire;
    wire= (char *)olWire;
    *wire_inout= wire;
d5118 96
a5213 95
_CheckSetSections( 	XkbGeometryPtr		geom,
			xkbSetGeometryReq *	req,
			char **			wire_inout,
			ClientPtr		client)
{
Status			status;
register int		s;
char *			wire;
xkbSectionWireDesc *	sWire;
XkbSectionPtr		section;

    wire= *wire_inout;
    if (req->nSections<1)
	return Success;
    sWire= (xkbSectionWireDesc *)wire;
    for (s=0;s<req->nSections;s++) {
	register int		r;
	xkbRowWireDesc *	rWire;
	if (client->swapped) {
	    register int n;
	    swapl(&sWire->name,n);
	    swaps(&sWire->top,n);
	    swaps(&sWire->left,n);
	    swaps(&sWire->width,n);
	    swaps(&sWire->height,n);
	    swaps(&sWire->angle,n);
	}
	CHK_ATOM_ONLY(sWire->name);
	section= XkbAddGeomSection(geom,sWire->name,sWire->nRows,
					sWire->nDoodads,sWire->nOverlays);
	if (!section)
	    return BadAlloc;
	section->priority=	sWire->priority;
	section->top=		sWire->top;
	section->left=		sWire->left;
	section->width=		sWire->width;
	section->height=	sWire->height;
	section->angle=		sWire->angle;
	rWire= (xkbRowWireDesc *)&sWire[1];
	for (r=0;r<sWire->nRows;r++) {
	    register int	k;
	    XkbRowPtr		row;
	    xkbKeyWireDesc *	kWire;
	    if (client->swapped) {
		register int n;
		swaps(&rWire->top,n);
		swaps(&rWire->left,n);
	    }
	    row= XkbAddGeomRow(section,rWire->nKeys);
	    if (!row)
		return BadAlloc;
	    row->top= rWire->top;
	    row->left= rWire->left;
	    row->vertical= rWire->vertical;
	    kWire= (xkbKeyWireDesc *)&rWire[1];
	    for (k=0;k<rWire->nKeys;k++) {
		XkbKeyPtr	key;
		key= XkbAddGeomKey(row);
		if (!key)
		    return BadAlloc;
		memcpy(key->name.name,kWire[k].name,XkbKeyNameLength);
		key->gap= kWire[k].gap;
		key->shape_ndx= kWire[k].shapeNdx;
		key->color_ndx= kWire[k].colorNdx;
		if (key->shape_ndx>=geom->num_shapes) {
		    client->errorValue= _XkbErrCode3(0x10,key->shape_ndx,
							  geom->num_shapes);
		    return BadMatch;
		}
		if (key->color_ndx>=geom->num_colors) {
		    client->errorValue= _XkbErrCode3(0x11,key->color_ndx,
							  geom->num_colors);
		    return BadMatch;
		}
	    }
	    rWire= (xkbRowWireDesc *)&kWire[rWire->nKeys];
	}
	wire= (char *)rWire;
	if (sWire->nDoodads>0) {
	    register int d;
	    for (d=0;d<sWire->nDoodads;d++) {
		status=_CheckSetDoodad(&wire,geom,section,client);
		if (status!=Success)
		    return status;
	    }
	}
	if (sWire->nOverlays>0) {
	    register int o;
	    for (o=0;o<sWire->nOverlays;o++) {
		status= _CheckSetOverlay(&wire,geom,section,client);
		if (status!=Success)
		    return status;
	    }
	}
	sWire= (xkbSectionWireDesc *)wire;
d5215 2
a5216 2
    wire= (char *)sWire;
    *wire_inout= wire;
d5221 10
a5230 12
_CheckSetShapes( 	XkbGeometryPtr		geom,
			xkbSetGeometryReq *	req,
			char **			wire_inout,
			ClientPtr		client)
{
register int	i;
char *		wire;

    wire= *wire_inout;
    if (req->nShapes<1) {
	client->errorValue= _XkbErrCode2(0x06,req->nShapes);
	return BadValue;
d5233 46
a5278 44
	xkbShapeWireDesc *	shapeWire;
	XkbShapePtr		shape;
	register int		o;
	shapeWire= (xkbShapeWireDesc *)wire;
	for (i=0;i<req->nShapes;i++) {
	    xkbOutlineWireDesc *	olWire;
	    XkbOutlinePtr		ol;
	    shape= XkbAddGeomShape(geom,shapeWire->name,shapeWire->nOutlines);
	    if (!shape)
		return BadAlloc;
	    olWire= (xkbOutlineWireDesc *)(&shapeWire[1]);
	    for (o=0;o<shapeWire->nOutlines;o++) {
		register int		p;
		XkbPointPtr		pt;
		xkbPointWireDesc *	ptWire;

		ol= XkbAddGeomOutline(shape,olWire->nPoints);
		if (!ol)
		    return BadAlloc;
		ol->corner_radius=	olWire->cornerRadius;
		ptWire= (xkbPointWireDesc *)&olWire[1];
		for (p=0,pt=ol->points;p<olWire->nPoints;p++,pt++) {
		    pt->x= ptWire[p].x;
		    pt->y= ptWire[p].y;
		    if (client->swapped) {
			register int n;
			swaps(&pt->x,n);
			swaps(&pt->y,n);
		    }
		}
		ol->num_points= olWire->nPoints;
		olWire= (xkbOutlineWireDesc *)(&ptWire[olWire->nPoints]);
	    }
	    if (shapeWire->primaryNdx!=XkbNoShape)
		shape->primary= &shape->outlines[shapeWire->primaryNdx];
	    if (shapeWire->approxNdx!=XkbNoShape)
		shape->approx= &shape->outlines[shapeWire->approxNdx];
	    shapeWire= (xkbShapeWireDesc *)olWire;
	}
	wire= (char *)shapeWire;
    }
    if (geom->num_shapes!=req->nShapes) {
	client->errorValue= _XkbErrCode3(0x07,geom->num_shapes,req->nShapes);
	return BadMatch;
d5281 1
a5281 1
    *wire_inout= wire;
d5286 13
a5298 14
_CheckSetGeom(	XkbGeometryPtr		geom,
		xkbSetGeometryReq *	req,
		ClientPtr 		client)
{
register int	i;
Status		status;
char *		wire;

    wire= (char *)&req[1];
    geom->label_font= _GetCountedString(&wire,client->swapped);

    for (i=0;i<req->nProperties;i++) {
	char *name,*val;
	name= _GetCountedString(&wire,client->swapped);
d5301 1
a5301 1
	val= _GetCountedString(&wire,client->swapped);
d5306 1
a5306 1
	if (XkbAddGeomProperty(geom,name,val)==NULL) {
d5309 1
a5309 1
	    return BadAlloc;
d5315 25
a5339 22
    if (req->nColors<2) {
	client->errorValue= _XkbErrCode3(0x01,2,req->nColors);
	return BadValue;
    }
    if (req->baseColorNdx>req->nColors) {
	client->errorValue=_XkbErrCode3(0x03,req->nColors,req->baseColorNdx);
	return BadMatch;
    }
    if (req->labelColorNdx>req->nColors) {
	client->errorValue= _XkbErrCode3(0x03,req->nColors,req->labelColorNdx);
	return BadMatch;
    }
    if (req->labelColorNdx==req->baseColorNdx) {
	client->errorValue= _XkbErrCode3(0x04,req->baseColorNdx,
                                         req->labelColorNdx);
	return BadMatch;
    }

    for (i=0;i<req->nColors;i++) {
	char *name;
	name= _GetCountedString(&wire,client->swapped);
	if (!name)
d5341 1
a5341 1
        if (!XkbAddGeomColor(geom,name,geom->num_colors)) {
d5343 1
a5343 1
	    return BadAlloc;
d5347 3
a5349 3
    if (req->nColors!=geom->num_colors) {
	client->errorValue= _XkbErrCode3(0x05,req->nColors,geom->num_colors);
	return BadMatch;
d5351 2
a5352 2
    geom->label_color= &geom->colors[req->labelColorNdx];
    geom->base_color= &geom->colors[req->baseColorNdx];
d5354 2
a5355 2
    if ((status=_CheckSetShapes(geom,req,&wire,client))!=Success)
	return status;
d5357 2
a5358 2
    if ((status=_CheckSetSections(geom,req,&wire,client))!=Success)
	return status;
d5360 4
a5363 4
    for (i=0;i<req->nDoodads;i++) {
	status=_CheckSetDoodad(&wire,geom,NULL,client);
	if (status!=Success)
	    return status;
d5366 4
a5369 4
    for (i=0;i<req->nKeyAliases;i++) {
	if (XkbAddGeomKeyAlias(geom,&wire[XkbKeyNameLength],wire)==NULL)
	    return BadAlloc;
	wire+= 2*XkbKeyNameLength;
d5375 1
a5375 1
_XkbSetGeometry(ClientPtr client, DeviceIntPtr dev, xkbSetGeometryReq *stuff)
d5377 6
a5382 6
    XkbDescPtr		xkb;
    Bool		new_name;
    xkbNewKeyboardNotify	nkn;
    XkbGeometryPtr	geom,old;
    XkbGeometrySizesRec	sizes;
    Status		status;
d5384 3
a5386 3
    xkb= dev->key->xkbInfo->desc;
    old= xkb->geom;
    xkb->geom= NULL;
d5388 9
a5396 9
    sizes.which=		XkbGeomAllMask;
    sizes.num_properties=	stuff->nProperties;
    sizes.num_colors=	stuff->nColors;
    sizes.num_shapes=	stuff->nShapes;
    sizes.num_sections=	stuff->nSections;
    sizes.num_doodads=	stuff->nDoodads;
    sizes.num_key_aliases=	stuff->nKeyAliases;
    if ((status= XkbAllocGeometry(xkb,&sizes))!=Success) {
        xkb->geom= old;
d5399 7
a5405 7
    geom= xkb->geom;
    geom->name= stuff->name;
    geom->width_mm= stuff->widthMM;
    geom->height_mm= stuff->heightMM;
    if ((status= _CheckSetGeom(geom,stuff,client))!=Success) {
        XkbFreeGeometry(geom,XkbGeomAllMask,TRUE);
        xkb->geom= old;
d5408 2
a5409 2
    new_name= (xkb->names->geometry!=geom->name);
    xkb->names->geometry= geom->name;
d5411 1
a5411 1
        XkbFreeGeometry(old,XkbGeomAllMask,TRUE);
d5413 2
a5414 1
        xkbNamesNotify	nn;
d5416 2
a5417 2
        nn.changed= XkbGeometryNameMask;
        XkbSendNamesNotify(dev,&nn);
d5419 7
a5425 7
    nkn.deviceID= nkn.oldDeviceID= dev->id;
    nkn.minKeyCode= nkn.oldMinKeyCode= xkb->min_key_code;
    nkn.maxKeyCode= nkn.oldMaxKeyCode= xkb->max_key_code;
    nkn.requestMajor=	XkbReqCode;
    nkn.requestMinor=	X_kbSetGeometry;
    nkn.changed=	XkbNKN_GeometryMask;
    XkbSendNewKeyboardNotify(dev,&nkn);
d5432 2
a5433 2
    DeviceIntPtr        dev;
    int                 rc;
d5438 2
a5439 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d5448 1
a5448 2
    if (stuff->deviceSpec == XkbUseCoreKbd)
    {
d5450 6
a5455 5
        for (other = inputInfo.devices; other; other = other->next)
        {
            if ((other != dev) && other->key && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev)
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
d5470 3
a5472 3
    DeviceIntPtr 		dev;
    xkbPerClientFlagsReply 	rep;
    XkbInterestPtr		interest;
d5478 2
a5479 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d5482 2
a5483 2
    CHK_MASK_LEGAL(0x01,stuff->change,XkbPCF_AllFlagsMask);
    CHK_MASK_MATCH(0x02,stuff->change,stuff->value);
d5485 1
a5485 1
    interest = XkbFindClientResource((DevicePtr)dev,client);
d5487 1
a5487 1
    rep.type= X_Reply;
d5491 2
a5492 2
	client->xkbClientFlags&= ~stuff->change;
	client->xkbClientFlags|= stuff->value;
d5494 30
a5523 27
    if (stuff->change&XkbPCF_AutoResetControlsMask) {
	Bool	want;
	want= stuff->value&XkbPCF_AutoResetControlsMask;
	if (interest && !want) {
	    interest->autoCtrls= interest->autoCtrlValues= 0;
	}
	else if (want && (!interest)) {
	    XID id = FakeClientID(client->index);
	    if (!AddResource(id,RT_XKBCLIENT,dev))
		return BadAlloc;
	    interest= XkbAddClientResource((DevicePtr)dev,client,id);
	    if (!interest)
		return BadAlloc;
	}
	if (interest && want ) {
	    register unsigned affect;
	    affect= stuff->ctrlsToChange;

	    CHK_MASK_LEGAL(0x03,affect,XkbAllBooleanCtrlsMask);
	    CHK_MASK_MATCH(0x04,affect,stuff->autoCtrls);
	    CHK_MASK_MATCH(0x05,stuff->autoCtrls,stuff->autoCtrlValues);

	    interest->autoCtrls&= ~affect;
	    interest->autoCtrlValues&= ~affect;
	    interest->autoCtrls|= stuff->autoCtrls&affect;
	    interest->autoCtrlValues|= stuff->autoCtrlValues&affect;
	}
d5526 1
a5526 1
    rep.value= client->xkbClientFlags&XkbPCF_AllFlagsMask;
d5528 2
a5529 2
	rep.autoCtrls= interest->autoCtrls;
	rep.autoCtrlValues= interest->autoCtrlValues;
d5532 1
a5532 1
	rep.autoCtrls= rep.autoCtrlValues= 0;
d5534 6
a5539 7
    if ( client->swapped ) {
	register int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.supported,n);
	swapl(&rep.value,n);
	swapl(&rep.autoCtrls,n);
	swapl(&rep.autoCtrlValues,n);
d5541 1
a5541 1
    WriteToClient(client,SIZEOF(xkbPerClientFlagsReply), (char *)&rep);
d5550 4
a5553 4
        0x00, 0x00, 0x00, 0x00, 0x00, 0xa7, 0xff, 0x87,
        0xfe, 0xff, 0xff, 0x87, 0xfe, 0xff, 0xff, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0x7f, 0xff
d5558 4
a5561 4
        0x00, 0x00, 0x00, 0x00, 0x20, 0xaf, 0xff, 0x87,
        0xfe, 0xff, 0xff, 0x87, 0xfe, 0xff, 0xff, 0x17,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0x7f, 0xff
d5565 1
a5565 1
GetComponentSpec(unsigned char **pWire,Bool allowExpr,int *errRtrn)
d5567 31
a5597 28
int		len;
register int	i;
unsigned char	*wire,*str,*tmp,*legal;

    if (allowExpr)	legal= &componentExprLegal[0];
    else		legal= &componentSpecLegal[0];

    wire= *pWire;
    len= (*(unsigned char *)wire++);
    if (len>0) {
	str= calloc(1, len+1);
	if (str) {
	    tmp= str;
	    for (i=0;i<len;i++) {
		if (legal[(*wire)/8]&(1<<((*wire)%8)))
		    *tmp++= *wire++;
		else wire++;
	    }
	    if (tmp!=str)
		*tmp++= '\0';
	    else {
		free(str);
		str= NULL;
	    }
	}
	else {
	    *errRtrn= BadAlloc;
	}
d5600 1
a5600 1
	str= NULL;
d5602 2
a5603 2
    *pWire= wire;
    return (char *)str;
d5611 6
a5616 6
    DeviceIntPtr 		dev;
    xkbListComponentsReply 	rep;
    unsigned			len;
    int				status;
    unsigned char *		str;
    XkbSrvListInfoRec		list;
d5621 2
a5622 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d5626 2
a5627 2
    status= Success;
    str= (unsigned char *)&stuff[1];
d5629 15
a5643 15
    list.maxRtrn= stuff->maxNames;
    list.pattern[_XkbListKeycodes]= GetComponentSpec(&str,FALSE,&status);
    list.pattern[_XkbListTypes]= GetComponentSpec(&str,FALSE,&status);
    list.pattern[_XkbListCompat]= GetComponentSpec(&str,FALSE,&status);
    list.pattern[_XkbListSymbols]= GetComponentSpec(&str,FALSE,&status);
    list.pattern[_XkbListGeometry]= GetComponentSpec(&str,FALSE,&status);
    if (status!=Success)
	return status;
    len= str-((unsigned char *)stuff);
    if ((XkbPaddedSize(len)/4)!=stuff->length)
	return BadLength;
    if ((status=XkbDDXList(dev,&list,client))!=Success) {
	free(list.pool);
	list.pool = NULL;
	return status;
d5646 1
a5646 1
    rep.type= X_Reply;
d5649 1
a5649 1
    rep.length = XkbPaddedSize(list.nPool)/4;
d5656 3
a5658 3
    rep.extra=	0;
    if (list.nTotal>list.maxRtrn)
	rep.extra = (list.nTotal-list.maxRtrn);
d5660 9
a5668 10
	register int n;
	swaps(&rep.sequenceNumber,n);
	swapl(&rep.length,n);
	swaps(&rep.nKeymaps,n);
	swaps(&rep.nKeycodes,n);
	swaps(&rep.nTypes,n);
	swaps(&rep.nCompatMaps,n);
	swaps(&rep.nSymbols,n);
	swaps(&rep.nGeometries,n);
	swaps(&rep.extra,n);
d5670 1
a5670 1
    WriteToClient(client,SIZEOF(xkbListComponentsReply),(char *)&rep);
d5672 3
a5674 3
	WriteToClient(client,XkbPaddedSize(list.nPool), (char *)list.pool);
	free(list.pool);
	list.pool= NULL;
d5684 19
a5702 19
    DeviceIntPtr 		dev;
    DeviceIntPtr                tmpd;
    DeviceIntPtr                master;
    xkbGetKbdByNameReply 	rep = {0};
    xkbGetMapReply		mrep = {0};
    xkbGetCompatMapReply	crep = {0};
    xkbGetIndicatorMapReply	irep = {0};
    xkbGetNamesReply		nrep = {0};
    xkbGetGeometryReply		grep = {0};
    XkbComponentNamesRec	names = {0};
    XkbDescPtr			xkb, new;
    unsigned char *		str;
    char 			mapFile[PATH_MAX];
    unsigned			len;
    unsigned			fwant,fneed,reported;
    int				status;
    Bool			geom_changed;
    XkbSrvLedInfoPtr            old_sli;
    XkbSrvLedInfoPtr            sli;
d5708 2
a5709 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d5715 3
a5717 3
    status= Success;
    str= (unsigned char *)&stuff[1];
    if (GetComponentSpec(&str,TRUE,&status)) /* keymap, unsupported */
d5719 14
a5732 14
    names.keycodes= GetComponentSpec(&str,TRUE,&status);
    names.types= GetComponentSpec(&str,TRUE,&status);
    names.compat= GetComponentSpec(&str,TRUE,&status);
    names.symbols= GetComponentSpec(&str,TRUE,&status);
    names.geometry= GetComponentSpec(&str,TRUE,&status);
    if (status!=Success)
	return status;
    len= str-((unsigned char *)stuff);
    if ((XkbPaddedSize(len)/4)!=stuff->length)
	return BadLength;

    CHK_MASK_LEGAL(0x01,stuff->want,XkbGBN_AllComponentsMask);
    CHK_MASK_LEGAL(0x02,stuff->need,XkbGBN_AllComponentsMask);
    
d5734 18
a5751 16
	 fwant= XkbGBN_AllComponentsMask;
    else fwant= stuff->want|stuff->need;
    if ((!names.compat)&&
        (fwant&(XkbGBN_CompatMapMask|XkbGBN_IndicatorMapMask))) {
        names.compat= Xstrdup("%");
    }
    if ((!names.types)&&(fwant&(XkbGBN_TypesMask))) {
        names.types= Xstrdup("%");
    }
    if ((!names.symbols)&&(fwant&XkbGBN_SymbolsMask)) {
        names.symbols= Xstrdup("%");
    }
    geom_changed= ((names.geometry!=NULL)&&(strcmp(names.geometry,"%")!=0));
    if ((!names.geometry)&&(fwant&XkbGBN_GeometryMask)) {
        names.geometry= Xstrdup("%");
        geom_changed= FALSE;
d5755 1
a5755 1
    rep.type= X_Reply;
d5761 5
a5765 4
    rep.loaded=	FALSE;
    fwant= XkbConvertGetByNameComponents(TRUE,stuff->want)|XkmVirtualModsMask;
    fneed= XkbConvertGetByNameComponents(TRUE,stuff->need);
    rep.reported= XkbConvertGetByNameComponents(FALSE,fwant|fneed);
d5767 2
a5768 2
	fneed|= XkmKeymapRequired;
	fwant|= XkmKeymapLegal;
d5770 3
a5772 3
    if ((fwant|fneed)&XkmSymbolsMask) {
	fneed|= XkmKeyNamesIndex|XkmTypesIndex;
	fwant|= XkmIndicatorsIndex;
d5776 8
a5783 8
    rep.found = XkbDDXLoadKeymapByNames(dev,&names,fwant,fneed,&new,
                                        mapFile,PATH_MAX);
    rep.newKeyboard= FALSE;
    rep.pad1= rep.pad2= rep.pad3= rep.pad4= 0;

    stuff->want|= stuff->need;
    if (new==NULL)
	rep.reported= 0;
d5785 168
a5952 167
	if (stuff->load)
	    rep.loaded= TRUE;
	if (stuff->load || 
		((rep.reported&XkbGBN_SymbolsMask) && (new->compat))) {
	    XkbChangesRec changes;
	    memset(&changes, 0, sizeof(changes));
	    XkbUpdateDescActions(new,
			new->min_key_code,XkbNumKeys(new),
			&changes);
	}

	if (new->map==NULL)
	    rep.reported&= ~(XkbGBN_SymbolsMask|XkbGBN_TypesMask);
	else if (rep.reported&(XkbGBN_SymbolsMask|XkbGBN_TypesMask)) {
	    mrep.type= X_Reply;
	    mrep.deviceID = dev->id;
	    mrep.sequenceNumber= client->sequence;
	    mrep.length = ((SIZEOF(xkbGetMapReply)-SIZEOF(xGenericReply))>>2);
	    mrep.minKeyCode = new->min_key_code;
	    mrep.maxKeyCode = new->max_key_code;
	    mrep.present = 0;
	    mrep.totalSyms = mrep.totalActs =
		mrep.totalKeyBehaviors= mrep.totalKeyExplicit= 
		mrep.totalModMapKeys= mrep.totalVModMapKeys= 0;
	    if (rep.reported&(XkbGBN_TypesMask|XkbGBN_ClientSymbolsMask)) {
		mrep.present|= XkbKeyTypesMask;
		mrep.firstType = 0;
		mrep.nTypes = mrep.totalTypes= new->map->num_types;
	    }
	    else {
		mrep.firstType = mrep.nTypes= 0;
		mrep.totalTypes= 0;
	    }
	    if (rep.reported&XkbGBN_ClientSymbolsMask) {
		mrep.present|= (XkbKeySymsMask|XkbModifierMapMask);
		mrep.firstKeySym = mrep.firstModMapKey= new->min_key_code;
		mrep.nKeySyms = mrep.nModMapKeys= XkbNumKeys(new);
	    }
	    else {
		mrep.firstKeySym= mrep.firstModMapKey= 0;
		mrep.nKeySyms= mrep.nModMapKeys= 0;
	    }
	    if (rep.reported&XkbGBN_ServerSymbolsMask) {
		mrep.present|= XkbAllServerInfoMask;
		mrep.virtualMods= ~0;
		mrep.firstKeyAct = mrep.firstKeyBehavior = 
			mrep.firstKeyExplicit = new->min_key_code;
		mrep.nKeyActs = mrep.nKeyBehaviors = 
			mrep.nKeyExplicit = XkbNumKeys(new);
		mrep.firstVModMapKey= new->min_key_code;
		mrep.nVModMapKeys= XkbNumKeys(new);
	    }
	    else {
		mrep.virtualMods= 0;
		mrep.firstKeyAct= mrep.firstKeyBehavior= 
			mrep.firstKeyExplicit = 0;
		mrep.nKeyActs= mrep.nKeyBehaviors= mrep.nKeyExplicit= 0;
	    }
	    XkbComputeGetMapReplySize(new,&mrep);
	    rep.length+= SIZEOF(xGenericReply)/4+mrep.length;
	}
	if (new->compat==NULL)
	    rep.reported&= ~XkbGBN_CompatMapMask;
	else if (rep.reported&XkbGBN_CompatMapMask) {
	    crep.type= X_Reply;
	    crep.deviceID= dev->id;
	    crep.sequenceNumber= client->sequence;
	    crep.length= 0;
	    crep.groups= XkbAllGroupsMask;
	    crep.firstSI= 0;
	    crep.nSI= crep.nTotalSI= new->compat->num_si;
	    XkbComputeGetCompatMapReplySize(new->compat,&crep);
	    rep.length+= SIZEOF(xGenericReply)/4+crep.length;
	}
	if (new->indicators==NULL)
	    rep.reported&= ~XkbGBN_IndicatorMapMask;
	else if (rep.reported&XkbGBN_IndicatorMapMask) {
	    irep.type= X_Reply;
	    irep.deviceID= dev->id;
	    irep.sequenceNumber= client->sequence;
	    irep.length= 0;
	    irep.which= XkbAllIndicatorsMask;
	    XkbComputeGetIndicatorMapReplySize(new->indicators,&irep);
	    rep.length+= SIZEOF(xGenericReply)/4+irep.length;
	}
	if (new->names==NULL)
	    rep.reported&= ~(XkbGBN_OtherNamesMask|XkbGBN_KeyNamesMask);
	else if (rep.reported&(XkbGBN_OtherNamesMask|XkbGBN_KeyNamesMask)) {
	    nrep.type= X_Reply;
	    nrep.deviceID= dev->id;
	    nrep.sequenceNumber= client->sequence;
	    nrep.length= 0;
	    nrep.minKeyCode= new->min_key_code;
	    nrep.maxKeyCode= new->max_key_code;
	    if (rep.reported&XkbGBN_OtherNamesMask) {
		nrep.which= XkbAllNamesMask;
		if (new->map!=NULL)
		     nrep.nTypes= new->map->num_types;
		else nrep.nTypes= 0;
		nrep.nKTLevels= 0;
		nrep.groupNames= XkbAllGroupsMask;
		nrep.virtualMods= XkbAllVirtualModsMask;
		nrep.indicators= XkbAllIndicatorsMask;
		nrep.nRadioGroups= new->names->num_rg;
	    }
	    else {
		nrep.which= 0;
		nrep.nTypes= 0;
		nrep.nKTLevels= 0;
		nrep.groupNames= 0;
		nrep.virtualMods= 0;
		nrep.indicators= 0;
		nrep.nRadioGroups= 0;
	    }
	    if (rep.reported&XkbGBN_KeyNamesMask) {
		nrep.which|= XkbKeyNamesMask;
		nrep.firstKey= new->min_key_code;
		nrep.nKeys= XkbNumKeys(new);
		nrep.nKeyAliases= new->names->num_key_aliases;
		if (nrep.nKeyAliases)
		    nrep.which|= XkbKeyAliasesMask;
	    }
	    else {
		nrep.which&= ~(XkbKeyNamesMask|XkbKeyAliasesMask);
		nrep.firstKey= nrep.nKeys= 0;
		nrep.nKeyAliases= 0;
	    }
	    XkbComputeGetNamesReplySize(new,&nrep);
	    rep.length+= SIZEOF(xGenericReply)/4+nrep.length;
	}
	if (new->geom==NULL)
	    rep.reported&= ~XkbGBN_GeometryMask;
	else if (rep.reported&XkbGBN_GeometryMask) {
	    grep.type= X_Reply;
	    grep.deviceID= dev->id;
	    grep.sequenceNumber= client->sequence;
	    grep.length= 0;
	    grep.found= TRUE;
	    grep.pad= 0;
	    grep.widthMM= grep.heightMM= 0;
	    grep.nProperties= grep.nColors= grep.nShapes= 0;
	    grep.nSections= grep.nDoodads= 0;
	    grep.baseColorNdx= grep.labelColorNdx= 0;
	    XkbComputeGetGeometryReplySize(new->geom,&grep,None);
	    rep.length+= SIZEOF(xGenericReply)/4+grep.length;
	}
    }

    reported= rep.reported;
    if ( client->swapped ) {
	register int n;
	swaps(&rep.sequenceNumber,n);
	swapl(&rep.length,n);
	swaps(&rep.found,n);
	swaps(&rep.reported,n);
    }
    WriteToClient(client,SIZEOF(xkbGetKbdByNameReply), (char *)&rep);
    if (reported&(XkbGBN_SymbolsMask|XkbGBN_TypesMask))
	XkbSendMap(client,new,&mrep);
    if (reported&XkbGBN_CompatMapMask)
	XkbSendCompatMap(client,new->compat,&crep);
    if (reported&XkbGBN_IndicatorMapMask)
	XkbSendIndicatorMap(client,new->indicators,&irep);
    if (reported&(XkbGBN_KeyNamesMask|XkbGBN_OtherNamesMask))
	XkbSendNames(client,new,&nrep);
    if (reported&XkbGBN_GeometryMask)
	XkbSendGeometry(client,new->geom,&grep,FALSE);
d5954 33
a5986 32
	XkbDescPtr		old_xkb;
	xkbNewKeyboardNotify 	nkn;
	int 			i,nG,nTG;
	old_xkb= xkb;
	xkb= new;
	dev->key->xkbInfo->desc= xkb;
	new= old_xkb; /* so it'll get freed automatically */

	*xkb->ctrls= *old_xkb->ctrls;
	for (nG=nTG=0,i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	    nG= XkbKeyNumGroups(xkb,i);
	    if (nG>=XkbNumKbdGroups) {
		nTG= XkbNumKbdGroups;
		break;
	    }
	    if (nG>nTG) {
		nTG= nG;
	    }
	}
	xkb->ctrls->num_groups= nTG;

	nkn.deviceID= nkn.oldDeviceID= dev->id;
	nkn.minKeyCode= new->min_key_code;
	nkn.maxKeyCode= new->max_key_code;
	nkn.oldMinKeyCode= xkb->min_key_code;
	nkn.oldMaxKeyCode= xkb->max_key_code;
	nkn.requestMajor= XkbReqCode;
	nkn.requestMinor= X_kbGetKbdByName;
	nkn.changed= XkbNKN_KeycodesMask;
	if (geom_changed)
	    nkn.changed|= XkbNKN_GeometryMask;
	XkbSendNewKeyboardNotify(dev,&nkn);
d6012 3
a6014 3
    if ((new!=NULL)&&(new!=xkb)) {
	XkbFreeKeyboard(new,XkbAllComponentsMask,TRUE);
	new= NULL;
d6023 45
a6067 82
ComputeDeviceLedInfoSize(	DeviceIntPtr		dev,
				unsigned int		what,
				XkbSrvLedInfoPtr	sli)
{
int			nNames,nMaps;
register unsigned 	n,bit;

    if (sli==NULL)
	return 0;
    nNames= nMaps= 0;
    if ((what&XkbXI_IndicatorNamesMask)==0)
	sli->namesPresent= 0;
    if ((what&XkbXI_IndicatorMapsMask)==0)
	sli->mapsPresent= 0;

    for (n=0,bit=1;n<XkbNumIndicators;n++,bit<<=1) {
	if (sli->names && sli->names[n]!=None) {
	    sli->namesPresent|= bit;
	    nNames++;
	}
	if (sli->maps && XkbIM_InUse(&sli->maps[n])) {
	    sli->mapsPresent|= bit;
	    nMaps++;
	}
    }
    return (nNames*4)+(nMaps*SIZEOF(xkbIndicatorMapWireDesc));
}

static int 
CheckDeviceLedFBs(	DeviceIntPtr			dev,
			int				class,
			int				id,
			xkbGetDeviceInfoReply *		rep,
			ClientPtr			client)
{
int			nFBs= 0;
int			length= 0;
Bool			classOk;

    if (class==XkbDfltXIClass) {
	if (dev->kbdfeed)	class= KbdFeedbackClass;
	else if (dev->leds)	class= LedFeedbackClass;
	else {
	    client->errorValue= _XkbErrCode2(XkbErr_BadClass,class);
	    return XkbKeyboardErrorCode;
	}
    }
    classOk= FALSE;
    if ((dev->kbdfeed)&&((class==KbdFeedbackClass)||(class==XkbAllXIClasses))) {
	KbdFeedbackPtr kf;
	classOk= TRUE;
	for (kf= dev->kbdfeed;(kf);kf=kf->next) {
	    if ((id!=XkbAllXIIds)&&(id!=XkbDfltXIId)&&(id!=kf->ctrl.id))
		continue;
	    nFBs++;
	    length+= SIZEOF(xkbDeviceLedsWireDesc);
	    if (!kf->xkb_sli)
		kf->xkb_sli= XkbAllocSrvLedInfo(dev,kf,NULL,0);
	    length+= ComputeDeviceLedInfoSize(dev,rep->present,kf->xkb_sli);
	    if (id!=XkbAllXIIds)
		break;
	}
    }
    if ((dev->leds)&&((class==LedFeedbackClass)||(class==XkbAllXIClasses))) {
	LedFeedbackPtr lf;
	classOk= TRUE;
	for (lf= dev->leds;(lf);lf=lf->next) {
	    if ((id!=XkbAllXIIds)&&(id!=XkbDfltXIId)&&(id!=lf->ctrl.id))
		continue;
	    nFBs++;
	    length+= SIZEOF(xkbDeviceLedsWireDesc);
	    if (!lf->xkb_sli)
		lf->xkb_sli= XkbAllocSrvLedInfo(dev,NULL,lf,0);
	    length+= ComputeDeviceLedInfoSize(dev,rep->present,lf->xkb_sli);
	    if (id!=XkbAllXIIds)
		break;
	}
    }
    if (nFBs>0) {
        rep->nDeviceLedFBs= nFBs;
        rep->length+= (length/4);
	return Success;
d6069 46
a6114 2
    if (classOk) client->errorValue= _XkbErrCode2(XkbErr_BadId,id);
    else	 client->errorValue= _XkbErrCode2(XkbErr_BadClass,class);
d6119 1
a6119 2
SendDeviceLedInfo(	XkbSrvLedInfoPtr	sli,
			ClientPtr		client)
d6121 2
a6122 2
xkbDeviceLedsWireDesc	wire;
int			length;
d6124 7
a6130 7
    length= 0;
    wire.ledClass= 		sli->class;
    wire.ledID= 		sli->id;
    wire.namesPresent= 		sli->namesPresent;
    wire.mapsPresent=   	sli->mapsPresent;
    wire.physIndicators= 	sli->physIndicators;
    wire.state=			sli->effectiveState;
d6132 49
a6180 49
	register int n;
	swaps(&wire.ledClass,n);
	swaps(&wire.ledID,n);
	swapl(&wire.namesPresent,n);
	swapl(&wire.mapsPresent,n);
	swapl(&wire.physIndicators,n);
	swapl(&wire.state,n);
    }
    WriteToClient(client,SIZEOF(xkbDeviceLedsWireDesc),(char *)&wire);
    length+= SIZEOF(xkbDeviceLedsWireDesc);
    if (sli->namesPresent|sli->mapsPresent) {
	register unsigned i,bit;
	if (sli->namesPresent) {
	    CARD32	awire;
	    for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
		if (sli->namesPresent&bit) {
		    awire= (CARD32)sli->names[i];
		    if (client->swapped) {
			register int n;
			swapl(&awire,n);
		    }
		    WriteToClient(client,4,(char *)&awire);
		    length+= 4;
		}
	    }
	}
	if (sli->mapsPresent) {
	    for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
		xkbIndicatorMapWireDesc	iwire;
		if (sli->mapsPresent&bit) {
		    iwire.flags= 	sli->maps[i].flags;
		    iwire.whichGroups=	sli->maps[i].which_groups;
		    iwire.groups=	sli->maps[i].groups;
		    iwire.whichMods=	sli->maps[i].which_mods;
		    iwire.mods=		sli->maps[i].mods.mask;
		    iwire.realMods=	sli->maps[i].mods.real_mods;
		    iwire.virtualMods=	sli->maps[i].mods.vmods;
		    iwire.ctrls= 	sli->maps[i].ctrls;
		    if (client->swapped) {
			register int n;
			swaps(&iwire.virtualMods,n);
			swapl(&iwire.ctrls,n);
		    }
		    WriteToClient(client,SIZEOF(xkbIndicatorMapWireDesc),
								(char *)&iwire);
		    length+= SIZEOF(xkbIndicatorMapWireDesc);
		}
	    }
	}
d6186 41
a6226 37
SendDeviceLedFBs(	DeviceIntPtr	dev,
			int		class,
			int		id,
			unsigned	wantLength,
			ClientPtr	client)
{
int			length= 0;

    if (class==XkbDfltXIClass) {
	if (dev->kbdfeed)	class= KbdFeedbackClass;
	else if (dev->leds)	class= LedFeedbackClass;
    }
    if ((dev->kbdfeed)&&
	((class==KbdFeedbackClass)||(class==XkbAllXIClasses))) {
	KbdFeedbackPtr kf;
	for (kf= dev->kbdfeed;(kf);kf=kf->next) {
	    if ((id==XkbAllXIIds)||(id==XkbDfltXIId)||(id==kf->ctrl.id)) {
		length+= SendDeviceLedInfo(kf->xkb_sli,client);
		if (id!=XkbAllXIIds)
		    break;
	    }
	}
    }
    if ((dev->leds)&&
	((class==LedFeedbackClass)||(class==XkbAllXIClasses))) {
	LedFeedbackPtr lf;
	for (lf= dev->leds;(lf);lf=lf->next) {
	    if ((id==XkbAllXIIds)||(id==XkbDfltXIId)||(id==lf->ctrl.id)) {
		length+= SendDeviceLedInfo(lf->xkb_sli,client);
		if (id!=XkbAllXIIds)
		    break;
	    }
	}
    }
    if (length==wantLength)
	 return Success;
    else return BadLength;
d6232 7
a6238 7
DeviceIntPtr		dev;
xkbGetDeviceInfoReply	rep;
int			status,nDeviceLedFBs;
unsigned		length,nameLen;
CARD16			ledClass,ledID;
unsigned		wanted;
char *			str;
d6243 2
a6244 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d6246 1
a6246 1
    wanted= stuff->wanted;
d6249 1
a6249 1
    CHK_MASK_LEGAL(0x01,wanted,XkbXI_AllDeviceFeaturesMask);
d6251 4
a6254 4
    if ((!dev->button)||((stuff->nBtns<1)&&(!stuff->allBtns)))
	wanted&= ~XkbXI_ButtonActionsMask;
    if ((!dev->kbdfeed)&&(!dev->leds))
	wanted&= ~XkbXI_IndicatorsMask;
d6256 2
a6257 2
    nameLen= XkbSizeCountedString(dev->name);
    memset((char *)&rep, 0, SIZEOF(xkbGetDeviceInfoReply));
d6259 1
a6259 1
    rep.deviceID= dev->id;
d6261 1
a6261 1
    rep.length = nameLen/4;
d6268 5
a6272 4
	 rep.totalBtns= dev->button->numButtons;
    else rep.totalBtns= 0;
    rep.devType=	dev->xinput_type;
    rep.hasOwnState=	(dev->key && dev->key->xkbInfo);
d6274 52
a6325 53
    if (dev->kbdfeed)	rep.dfltKbdFB= dev->kbdfeed->ctrl.id;
    else		rep.dfltKbdFB= XkbXINone;
    if (dev->leds)	rep.dfltLedFB= dev->leds->ctrl.id;
    else		rep.dfltLedFB= XkbXINone;

    ledClass= stuff->ledClass;
    ledID= stuff->ledID;

    rep.firstBtnWanted= rep.nBtnsWanted= 0;
    rep.firstBtnRtrn= rep.nBtnsRtrn= 0;
    if (wanted&XkbXI_ButtonActionsMask) {
	if (stuff->allBtns) {
	    stuff->firstBtn= 0;
	    stuff->nBtns= dev->button->numButtons;
	}

	if ((stuff->firstBtn+stuff->nBtns)>dev->button->numButtons) {
	    client->errorValue = _XkbErrCode4(0x02,dev->button->numButtons,
							stuff->firstBtn,
							stuff->nBtns);
	    return BadValue;
	}
	else {
	    rep.firstBtnWanted= stuff->firstBtn;
	    rep.nBtnsWanted= stuff->nBtns;
	    if (dev->button->xkb_acts!=NULL) {
		XkbAction *act;
		register int i;

		rep.firstBtnRtrn= stuff->firstBtn;
		rep.nBtnsRtrn= stuff->nBtns;
		act= &dev->button->xkb_acts[rep.firstBtnWanted];
		for (i=0;i<rep.nBtnsRtrn;i++,act++) {
		    if (act->type!=XkbSA_NoAction)
			break;
		}
		rep.firstBtnRtrn+=	i;
		rep.nBtnsRtrn-=		i;
		act= &dev->button->xkb_acts[rep.firstBtnRtrn+rep.nBtnsRtrn-1];
		for (i=0;i<rep.nBtnsRtrn;i++,act--) {
		    if (act->type!=XkbSA_NoAction)
			break;
		}
		rep.nBtnsRtrn-=		i;
	    }
	    rep.length+= (rep.nBtnsRtrn*SIZEOF(xkbActionWireDesc))/4;
	}
    }

    if (wanted&XkbXI_IndicatorsMask) {
	status= CheckDeviceLedFBs(dev,ledClass,ledID,&rep,client);
	if (status!=Success)
	    return status;
d6327 7
a6333 1
    length= rep.length*4;
d6336 17
a6352 19
	register int n;
	swaps(&rep.sequenceNumber,n);
	swapl(&rep.length,n);
	swaps(&rep.present,n);
	swaps(&rep.supported,n);
	swaps(&rep.unsupported,n);
	swaps(&rep.nDeviceLedFBs,n);
	swapl(&rep.type,n);
	swaps(&rep.dfltKbdFB, n);
	swaps(&rep.dfltLedFB, n);
	swapl(&rep.devType, n);
    }
    WriteToClient(client,SIZEOF(xkbGetDeviceInfoReply), (char *)&rep);

    str= malloc(nameLen);
    if (!str) 
	return BadAlloc;
    XkbWriteCountedString(str,dev->name,client->swapped);
    WriteToClient(client,nameLen,str);
d6354 1
a6354 1
    length-= nameLen;
d6356 19
a6374 17
    if (rep.nBtnsRtrn>0) {
	int			sz;
	xkbActionWireDesc *	awire;
	sz= rep.nBtnsRtrn*SIZEOF(xkbActionWireDesc);
	awire= (xkbActionWireDesc *)&dev->button->xkb_acts[rep.firstBtnRtrn];
	WriteToClient(client,sz,(char *)awire);
	length-= sz;
    }
    if (nDeviceLedFBs>0) {
	status= SendDeviceLedFBs(dev,ledClass,ledID,length,client);
	if (status!=Success)
	    return status;
    }
    else if (length!=0)  {
	ErrorF("[xkb] Internal Error!  BadLength in ProcXkbGetDeviceInfo\n");
	ErrorF("[xkb]                  Wrote %d fewer bytes than expected\n",length);
	return BadLength;
d6380 66
a6445 73
CheckSetDeviceIndicators(	char *		wire,
				DeviceIntPtr	dev,
				int		num,
				int *		status_rtrn,
				ClientPtr	client)
{
xkbDeviceLedsWireDesc *	ledWire;
int			i;
XkbSrvLedInfoPtr 	sli;

    ledWire= (xkbDeviceLedsWireDesc *)wire;
    for (i=0;i<num;i++) {
	if (client->swapped) {
	   register int n;
	   swaps(&ledWire->ledClass,n);
	   swaps(&ledWire->ledID,n);
	   swapl(&ledWire->namesPresent,n);
	   swapl(&ledWire->mapsPresent,n);
	   swapl(&ledWire->physIndicators,n);
	}

        sli= XkbFindSrvLedInfo(dev,ledWire->ledClass,ledWire->ledID,
							XkbXI_IndicatorsMask);
	if (sli!=NULL) {
	    register int n;
	    register unsigned bit;
	    int nMaps,nNames;
	    CARD32 *atomWire;
	    xkbIndicatorMapWireDesc *mapWire;

	    nMaps= nNames= 0;
	    for (n=0,bit=1;n<XkbNumIndicators;n++,bit<<=1) {
		if (ledWire->namesPresent&bit)
		    nNames++;
		if (ledWire->mapsPresent&bit)
		    nMaps++;
	    }
	    atomWire= (CARD32 *)&ledWire[1];
	    if (nNames>0) {
		for (n=0;n<nNames;n++) {
		    if (client->swapped) {
			register int t;
			swapl(atomWire,t);
		    }
		    CHK_ATOM_OR_NONE3(((Atom)(*atomWire)),client->errorValue,
							*status_rtrn,NULL);
		    atomWire++;
		}
	    }
	    mapWire= (xkbIndicatorMapWireDesc *)atomWire;
	    if (nMaps>0) {
		for (n=0;n<nMaps;n++) {
		    if (client->swapped) {
			register int t;
			swaps(&mapWire->virtualMods,t);
			swapl(&mapWire->ctrls,t);
		    }
		    CHK_MASK_LEGAL3(0x21,mapWire->whichGroups,
						XkbIM_UseAnyGroup,
						client->errorValue,
						*status_rtrn,NULL);
		    CHK_MASK_LEGAL3(0x22,mapWire->whichMods,XkbIM_UseAnyMods,
						client->errorValue,
						*status_rtrn,NULL);
		    mapWire++;
		}
	    }
	    ledWire= (xkbDeviceLedsWireDesc *)mapWire;
	}
	else {
	    /* SHOULD NEVER HAPPEN */
	    return (char *)ledWire;
	}
d6447 1
a6447 1
    return (char *)ledWire;
d6451 88
a6538 88
SetDeviceIndicators(	char *			wire,
			DeviceIntPtr		dev,
			unsigned		changed,
			int			num,
			int *			status_rtrn,
			ClientPtr		client,
			xkbExtensionDeviceNotify *ev)
{
xkbDeviceLedsWireDesc *		ledWire;
int				i;
XkbEventCauseRec		cause;
unsigned			namec,mapc,statec;
xkbExtensionDeviceNotify	ed;
XkbChangesRec			changes;
DeviceIntPtr			kbd;

    memset((char *)&ed, 0, sizeof(xkbExtensionDeviceNotify));
    memset((char *)&changes, 0, sizeof(XkbChangesRec));
    XkbSetCauseXkbReq(&cause,X_kbSetDeviceInfo,client);
    ledWire= (xkbDeviceLedsWireDesc *)wire;
    for (i=0;i<num;i++) {
	register int			n;
	register unsigned 		bit;
	CARD32 *			atomWire;
	xkbIndicatorMapWireDesc *	mapWire;
	XkbSrvLedInfoPtr		sli;

	namec= mapc= statec= 0;
    	sli= XkbFindSrvLedInfo(dev,ledWire->ledClass,ledWire->ledID,
						XkbXI_IndicatorMapsMask);
	if (!sli) {
	    /* SHOULD NEVER HAPPEN!! */
	    return (char *)ledWire;
	}

	atomWire= (CARD32 *)&ledWire[1];
	if (changed&XkbXI_IndicatorNamesMask) {
	    namec= sli->namesPresent|ledWire->namesPresent;
	    memset((char *)sli->names, 0, XkbNumIndicators*sizeof(Atom));
	}
	if (ledWire->namesPresent) {
	    sli->namesPresent= ledWire->namesPresent;
	    memset((char *)sli->names, 0, XkbNumIndicators*sizeof(Atom));
	    for (n=0,bit=1;n<XkbNumIndicators;n++,bit<<=1) {
		if (ledWire->namesPresent&bit) {
		     sli->names[n]= (Atom)*atomWire;
		     if (sli->names[n]==None)
			ledWire->namesPresent&= ~bit;
		     atomWire++; 
		}
	    }
	}
	mapWire= (xkbIndicatorMapWireDesc *)atomWire;
	if (changed&XkbXI_IndicatorMapsMask) {
	    mapc= sli->mapsPresent|ledWire->mapsPresent;
	    sli->mapsPresent= ledWire->mapsPresent;
	    memset((char*)sli->maps, 0, XkbNumIndicators*sizeof(XkbIndicatorMapRec));
	}
	if (ledWire->mapsPresent) {
	    for (n=0,bit=1;n<XkbNumIndicators;n++,bit<<=1) {
		if (ledWire->mapsPresent&bit) {
		    sli->maps[n].flags=		mapWire->flags;
		    sli->maps[n].which_groups=	mapWire->whichGroups;
		    sli->maps[n].groups=	mapWire->groups;
		    sli->maps[n].which_mods=	mapWire->whichMods;
		    sli->maps[n].mods.mask=	mapWire->mods;
		    sli->maps[n].mods.real_mods=mapWire->realMods;
		    sli->maps[n].mods.vmods=	mapWire->virtualMods;
		    sli->maps[n].ctrls=		mapWire->ctrls;
		    mapWire++; 
		}
	    }
	}
	if (changed&XkbXI_IndicatorStateMask) {
	    statec= sli->effectiveState^ledWire->state;
	    sli->explicitState&= ~statec;
	    sli->explicitState|= (ledWire->state&statec);
	}
	if (namec)
	    XkbApplyLedNameChanges(dev,sli,namec,&ed,&changes,&cause);
	if (mapc)
	    XkbApplyLedMapChanges(dev,sli,mapc,&ed,&changes,&cause);
	if (statec)
	    XkbApplyLedStateChanges(dev,sli,statec,&ed,&changes,&cause);

	kbd= dev;
	if ((sli->flags&XkbSLI_HasOwnState)==0)
	    kbd = inputInfo.keyboard;
d6540 2
a6541 2
	XkbFlushLedEvents(dev,kbd,sli,&ed,&changes,&cause);
	ledWire= (xkbDeviceLedsWireDesc *)mapWire;
d6543 1
a6543 1
    return (char *)ledWire;
a6545 1

d6548 1
a6548 1
                  xkbSetDeviceInfoReq *stuff)
d6550 1
a6550 1
    char                       *wire;
d6552 21
a6572 19
    wire= (char *)&stuff[1];
    if (stuff->change&XkbXI_ButtonActionsMask) {
	if (!dev->button) {
	    client->errorValue = _XkbErrCode2(XkbErr_BadClass,ButtonClass);
	    return XkbKeyboardErrorCode;
	}
	if ((stuff->firstBtn+stuff->nBtns)>dev->button->numButtons) {
	    client->errorValue= _XkbErrCode4(0x02,stuff->firstBtn,stuff->nBtns,
						dev->button->numButtons);
	    return BadMatch;
	}
	wire+= (stuff->nBtns*SIZEOF(xkbActionWireDesc));
    }
    if (stuff->change&XkbXI_IndicatorsMask) {
	int status= Success;
	wire= CheckSetDeviceIndicators(wire,dev,stuff->nDeviceLedFBs,
							&status,client);
	if (status!=Success)
	    return status;
d6574 2
a6575 2
    if (((wire-((char *)stuff))/4)!=stuff->length)
	return BadLength;
d6582 1
a6582 1
                       xkbSetDeviceInfoReq *stuff)
d6584 2
a6585 2
    char                       *wire;
    xkbExtensionDeviceNotify    ed;
d6587 40
a6626 37
    memset((char *)&ed, 0, SIZEOF(xkbExtensionDeviceNotify));
    ed.deviceID=	dev->id;
    wire= (char *)&stuff[1];
    if (stuff->change&XkbXI_ButtonActionsMask) {
	int			nBtns,sz,i;
	XkbAction *		acts;
	DeviceIntPtr		kbd;

	nBtns= dev->button->numButtons;
	acts= dev->button->xkb_acts;
	if (acts==NULL) {
	    acts= calloc(nBtns, sizeof(XkbAction));
	    if (!acts)
		return BadAlloc;
	    dev->button->xkb_acts= acts;
	}
	sz= stuff->nBtns*SIZEOF(xkbActionWireDesc);
	memcpy((char *)&acts[stuff->firstBtn],(char *)wire,sz);
	wire+= sz;
	ed.reason|=	XkbXI_ButtonActionsMask;
	ed.firstBtn=	stuff->firstBtn;
	ed.nBtns=	stuff->nBtns;

	if (dev->key)	kbd= dev;
	else		kbd= inputInfo.keyboard;
	acts= &dev->button->xkb_acts[stuff->firstBtn];
	for (i=0;i<stuff->nBtns;i++,acts++) {
	    if (acts->type!=XkbSA_NoAction)
		XkbSetActionKeyMods(kbd->key->xkbInfo->desc,acts,0);
	}
    }
    if (stuff->change&XkbXI_IndicatorsMask) {
	int status= Success;
	wire= SetDeviceIndicators(wire,dev,stuff->change,
				  stuff->nDeviceLedFBs, &status,client,&ed);
	if (status!=Success)
	    return status;
d6628 2
a6629 2
    if ((stuff->change)&&(ed.reason))
	XkbSendExtensionDeviceNotify(dev,client,&ed);
d6636 2
a6637 2
    DeviceIntPtr        dev;
    int                 rc;
d6642 2
a6643 2
    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
d6646 1
a6646 1
    CHK_MASK_LEGAL(0x01,stuff->change,XkbXI_AllFeaturesMask);
d6653 2
a6654 2
    if (stuff->deviceSpec == XkbUseCoreKbd || stuff->deviceSpec == XkbUseCorePtr)
    {
d6656 4
a6659 3
        for (other = inputInfo.devices; other; other = other->next)
        {
            if (((other != dev) && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev) &&
d6661 4
a6664 5
                (stuff->deviceSpec == XkbUseCorePtr && other->button)))
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
d6678 2
a6679 2
    if (stuff->deviceSpec == XkbUseCoreKbd || stuff->deviceSpec == XkbUseCorePtr)
    {
d6681 4
a6684 3
        for (other = inputInfo.devices; other; other = other->next)
        {
            if (((other != dev) && !IsMaster(other) && GetMaster(other, MASTER_KEYBOARD) == dev) &&
d6686 4
a6689 5
                (stuff->deviceSpec == XkbUseCorePtr && other->button)))
            {
                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixManageAccess);
                if (rc == Success)
                {
d6706 3
a6708 3
CARD32 				newFlags,newCtrls,extraLength;
xkbSetDebuggingFlagsReply 	rep;
int rc;
d6715 1
a6715 1
	return rc;
d6717 4
a6720 4
    newFlags=  xkbDebugFlags&(~stuff->affectFlags);
    newFlags|= (stuff->flags&stuff->affectFlags);
    newCtrls=  xkbDebugCtrls&(~stuff->affectCtrls);
    newCtrls|= (stuff->ctrls&stuff->affectCtrls);
d6722 23
a6744 19
	ErrorF("[xkb] XkbDebug: Setting debug flags to 0x%lx\n",(long)newFlags);
	if (newCtrls!=xkbDebugCtrls)
	    ErrorF("[xkb] XkbDebug: Setting debug controls to 0x%lx\n",(long)newCtrls);
    }
    extraLength= (stuff->length<<2)-sz_xkbSetDebuggingFlagsReq;
    if (stuff->msgLength>0) {
	char *msg;
	if (extraLength<XkbPaddedSize(stuff->msgLength)) {
	    ErrorF("[xkb] XkbDebug: msgLength= %d, length= %ld (should be %d)\n",
			stuff->msgLength,(long)extraLength,
			XkbPaddedSize(stuff->msgLength));
	    return BadLength;
	}
	msg= (char *)&stuff[1];
	if (msg[stuff->msgLength-1]!='\0') {
	    ErrorF("[xkb] XkbDebug: message not null-terminated\n");
	    return BadValue;
	}
	ErrorF("[xkb] XkbDebug: %s\n",msg);
d6749 1
a6749 1
    rep.type= X_Reply;
d6756 6
a6761 7
    if ( client->swapped ) {
	register int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.currentFlags, n);
	swapl(&rep.currentCtrls, n);
	swapl(&rep.supportedFlags, n);
	swapl(&rep.supportedCtrls, n);
d6763 1
a6763 1
    WriteToClient(client,SIZEOF(xkbSetDebuggingFlagsReply), (char *)&rep);
d6770 1
a6770 1
ProcXkbDispatch (ClientPtr client)
d6773 1
a6773 2
    switch (stuff->data)
    {
d6775 1
a6775 1
	return ProcXkbUseExtension(client);
d6777 1
a6777 1
	return ProcXkbSelectEvents(client);
d6779 1
a6779 1
	return ProcXkbBell(client);
d6781 1
a6781 1
	return ProcXkbGetState(client);
d6783 1
a6783 1
	return ProcXkbLatchLockState(client);
d6785 1
a6785 1
	return ProcXkbGetControls(client);
d6787 1
a6787 1
	return ProcXkbSetControls(client);
d6789 1
a6789 1
	return ProcXkbGetMap(client);
d6791 1
a6791 1
	return ProcXkbSetMap(client);
d6793 1
a6793 1
	return ProcXkbGetCompatMap(client);
d6795 1
a6795 1
	return ProcXkbSetCompatMap(client);
d6797 1
a6797 1
	return ProcXkbGetIndicatorState(client);
d6799 1
a6799 1
	return ProcXkbGetIndicatorMap(client);
d6801 1
a6801 1
	return ProcXkbSetIndicatorMap(client);
d6803 1
a6803 1
	return ProcXkbGetNamedIndicator(client);
d6805 1
a6805 1
	return ProcXkbSetNamedIndicator(client);
d6807 1
a6807 1
	return ProcXkbGetNames(client);
d6809 1
a6809 1
	return ProcXkbSetNames(client);
d6811 1
a6811 1
	return ProcXkbGetGeometry(client);
d6813 1
a6813 1
	return ProcXkbSetGeometry(client);
d6815 1
a6815 1
	return ProcXkbPerClientFlags(client);
d6817 1
a6817 1
	return ProcXkbListComponents(client);
d6819 1
a6819 1
	return ProcXkbGetKbdByName(client);
d6821 1
a6821 1
	return ProcXkbGetDeviceInfo(client);
d6823 1
a6823 1
	return ProcXkbSetDeviceInfo(client);
d6825 1
a6825 1
	return ProcXkbSetDebuggingFlags(client);
d6827 1
a6827 1
	return BadRequest;
d6832 1
a6832 1
XkbClientGone(pointer data,XID id)
d6834 1
a6834 1
    DevicePtr	pXDev = (DevicePtr)data;
d6836 3
a6838 2
    if (!XkbRemoveResourceClient(pXDev,id)) {
	ErrorF("[xkb] Internal Error! bad RemoveResourceClient in XkbClientGone\n");
d6850 1
a6850 1
	return;
d6853 1
a6853 1
	return;
d6856 6
a6861 6
				 ProcXkbDispatch, SProcXkbDispatch,
				 NULL, StandardMinorOpcode))) {
	XkbReqCode = (unsigned char)extEntry->base;
	XkbEventBase = (unsigned char)extEntry->eventBase;
	XkbErrorBase = (unsigned char)extEntry->errorBase;
	XkbKeyboardErrorCode = XkbErrorBase+XkbKeyboard;
a6864 2


@


1.6
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d918 1
a918 1
            if (stuff->changeCtrls & XkbPerKeyRepeatMask)
d921 5
a1684 14
    map = &xkb->map->key_sym_map[xkb->min_key_code];
    for (i=xkb->min_key_code;i<(unsigned)req->firstKeySym;i++,map++) {
	register int g,ng,w;
	ng= XkbNumGroups(map->group_info);
	for (w=g=0;g<ng;g++) {
	    if (map->kt_index[g]>=(unsigned)nTypes) {
		*errorRtrn = _XkbErrCode4(0x13,i,g,map->kt_index[g]);
		return 0;
	    }
	    if (mapWidths[map->kt_index[g]]>w)
		w= mapWidths[map->kt_index[g]];
	}
	symsPerKey[i] = w*ng;
    }
d2339 2
d2369 17
d2789 1
d2803 1
a2803 1
	for (i=0;i<req->nSI;i++,wire++,sym++) {
d2808 8
d2823 8
d3664 1
a3664 1
    start = desc = malloc(length);
d4327 11
d4341 1
a4341 1
    CARD16 len,*pLen;
d4353 3
a4355 2
    memcpy(&wire[2],str,len);
    wire+= ((2+len+3)/4)*4;
d4466 1
d4479 1
d4593 2
d4607 1
d5606 8
a5613 7
    xkbGetKbdByNameReply 	rep;
    xkbGetMapReply		mrep;
    xkbGetCompatMapReply	crep;
    xkbGetIndicatorMapReply	irep;
    xkbGetNamesReply		nrep;
    xkbGetGeometryReply		grep;
    XkbComponentNamesRec	names;
d5632 1
d5658 1
a5658 1
        names.compat= _XkbDupString("%");
d5661 1
a5661 1
        names.types= _XkbDupString("%");
d5664 1
a5664 1
        names.symbols= _XkbDupString("%");
d5668 1
a5668 1
        names.geometry= _XkbDupString("%");
a5890 19
        for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) {
            if ((tmpd == dev) || (!IsMaster(tmpd) && GetMaster(tmpd, MASTER_KEYBOARD) == dev)) {
                if (tmpd != dev)
                    XkbCopyDeviceKeymap(tmpd, dev);

                if (tmpd->kbdfeed && tmpd->kbdfeed->xkb_sli) {
                    old_sli = tmpd->kbdfeed->xkb_sli;
                    tmpd->kbdfeed->xkb_sli = NULL;
                    sli = XkbAllocSrvLedInfo(tmpd, tmpd->kbdfeed, NULL, 0);
                    if (sli) {
                        sli->explicitState = old_sli->explicitState;
                        sli->effectiveState = old_sli->effectiveState;
                    }
                    tmpd->kbdfeed->xkb_sli = sli;
                    XkbFreeSrvLedInfo(old_sli);
                }
            }
        }

d5903 23
a5925 9
	if (!IsMaster(dev) && dev->u.master)
	{
	    DeviceIntPtr master = dev->u.master;
	    if (master->u.lastSlave == dev)
	    {
		XkbCopyDeviceKeymap(dev->u.master, dev);
		XkbSendNewKeyboardNotify(dev,&nkn);
	    }
	}
d5931 1
a5931 10
    free(names.keycodes);
    names.keycodes = NULL;
    free(names.types);
    names.types = NULL;
    free(names.compat);
    names.compat = NULL;
    free(names.symbols);
    names.symbols = NULL;
    free(names.geometry);
    names.geometry = NULL;
d6243 3
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d2346 2
a2347 2
    CARD8               mapWidths[XkbMaxLegalKeyCode + 1];
    CARD16              symsPerKey[XkbMaxLegalKeyCode + 1];
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d197 1
a197 1
    return client->noClientException;
d222 1
a222 1
	return client->noClientException;
d227 2
a228 1
	AddResource(id,RT_XKBCLIENT,dev);
d347 1
a347 1
	return client->noClientException;
d527 1
a527 1
            if ((other != dev) && other->key && !IsMaster(other) && (other->u.master == dev))
d561 1
a561 1
    bzero(&rep,sizeof(xkbGetStateReply));
d582 1
a582 1
    return client->noClientException;
d610 1
a610 1
        if ((tmpd == dev) || (!IsMaster(tmpd) && tmpd->u.master == dev)) {
d650 1
a650 1
    return client->noClientException;
d726 1
a726 1
    return(client->noClientException);
d752 1
a752 1
        if ((tmpd == dev) || (!IsMaster(tmpd) && tmpd->u.master == dev)) {
d946 1
a946 1
    return client->noClientException;
d1369 1
a1369 1
    start= desc= xcalloc(1, len);
d1409 2
a1410 2
    xfree((char *)start);
    return client->noClientException;
d1433 1
a1433 1
    bzero(&rep,sizeof(xkbGetMapReply));
d2176 1
a2176 1
    bzero(&server->behaviors[first],req->nKeyBehaviors*sizeof(XkbBehavior));
d2190 2
a2191 2
             xkbi->radioGroups= xrealloc(xkbi->radioGroups,sz);
        else xkbi->radioGroups= xcalloc(1, sz);
d2194 1
a2194 1
                bzero(&xkbi->radioGroups[xkbi->nRadioGroups],
d2249 1
a2249 1
    bzero(&xkb->explicit[first],req->nKeyExplicit);
d2283 1
a2283 1
    bzero(&xkb->modmap[first],req->nModMapKeys);
d2315 1
a2315 1
    bzero(&srv->vmodmap[first],req->nVModMapKeys*sizeof(unsigned short));
d2442 1
a2442 1
    bzero(&change, sizeof(change));
d2562 1
a2562 1
            if ((other != dev) && other->key && !IsMaster(other) && (other->u.master == dev))
d2585 1
a2585 1
            if ((other != dev) && other->key && !IsMaster(other) && (other->u.master == dev))
d2598 1
a2598 1
    return client->noClientException;
d2633 1
a2633 1
	data = xalloc(size);
d2684 1
a2684 1
	xfree((char *)data);
d2686 1
a2686 1
    return client->noClientException;
d2781 1
a2781 1
	    compat->sym_interpret= xrealloc(compat->sym_interpret,
d2855 1
a2855 1
	bzero(&change,sizeof(XkbChangesRec));
d2891 1
a2891 1
            if ((other != dev) && other->key && !IsMaster(other) && (other->u.master == dev))
d2914 1
a2914 1
            if ((other != dev) && other->key && !IsMaster(other) && (other->u.master == dev))
d2927 1
a2927 1
    return client->noClientException;
d2964 1
a2964 1
    return client->noClientException;
d2999 1
a2999 1
	to= map= xalloc(length);
d3023 1
d3039 1
a3039 1
	xfree((char *)map);
d3041 1
a3041 1
    return client->noClientException;
d3135 1
a3135 1
	return client->noClientException;
d3170 1
a3170 1
            if ((other != dev) && other->key && !IsMaster(other) && (other->u.master == dev))
d3262 1
a3262 1
    return client->noClientException;
d3389 2
a3390 2
    bzero((char *)&ed,sizeof(xkbExtensionDeviceNotify));
    bzero((char *)&changes,sizeof(XkbChangesRec));
d3439 1
a3439 1
            if ((other != dev) && !IsMaster(other) && (other->u.master == dev) &&
d3463 1
a3463 1
            if ((other != dev) && !IsMaster(other) && (other->u.master == dev) &&
d3472 1
a3472 1
    return client->noClientException;
d3637 1
a3637 1
    start = desc = xalloc(length);
d3761 2
a3762 2
    xfree((char *)start);
    return client->noClientException;
d4043 1
a4043 1
    bzero(&nn,sizeof(xkbNamesNotify));
d4123 1
a4123 1
            xfree(names->key_aliases);
d4142 1
a4142 1
            xfree(names->radio_groups);
d4165 1
a4165 1
            bzero(&edev,sizeof(xkbExtensionDeviceNotify));
d4254 1
a4254 1
            if ((other != dev) && other->key && !IsMaster(other) && (other->u.master == dev))
d4279 1
a4279 1
            if ((other != dev) && other->key && !IsMaster(other) && (other->u.master == dev))
d4291 1
a4291 1
    return client->noClientException;
d4483 1
a4483 1
	bzero(doodadWire,SIZEOF(xkbDoodadWireDesc));
d4745 1
a4745 1
	start= desc= xalloc(len);
d4789 1
a4789 1
	xfree((char *)start);
d4792 1
a4792 1
    return client->noClientException;
d4839 1
a4839 1
    str= xalloc(len+1);
d5187 1
a5187 1
            xfree(name);
d5191 2
a5192 2
            xfree(name);
            xfree(val);
d5195 2
a5196 2
        xfree(name);
        xfree(val);
d5223 1
a5223 1
            xfree(name);
d5226 1
a5226 1
        xfree(name);
d5295 1
a5295 1
        bzero(&nn,sizeof(xkbNamesNotify));
d5333 1
a5333 1
            if ((other != dev) && other->key && !IsMaster(other) && (other->u.master == dev))
d5382 2
a5383 1
	    AddResource(id,RT_XKBCLIENT,dev);
d5420 1
a5420 1
    return client->noClientException;
d5455 1
a5455 1
	str= xcalloc(1, len+1);
d5466 1
a5466 1
		xfree(str);
d5503 1
a5503 1
    bzero(&list,sizeof(XkbSrvListInfoRec));
d5516 2
a5517 4
	if (list.pool) {
	    xfree(list.pool);
	    list.pool= NULL;
	}
d5520 1
a5520 1
    bzero(&rep,sizeof(xkbListComponentsReply));
d5549 1
a5549 1
	xfree(list.pool);
d5552 1
a5552 1
    return client->noClientException;
d5626 1
a5626 1
    bzero(mapFile,PATH_MAX);
d5661 1
a5661 1
	    bzero(&changes,sizeof(changes));
d5846 1
a5846 1
            if ((tmpd == dev) || (!IsMaster(tmpd) && tmpd->u.master == dev)) {
d5890 11
a5900 6
    if (names.keycodes)	{ xfree(names.keycodes); names.keycodes= NULL; }
    if (names.types)	{ xfree(names.types); names.types= NULL; }
    if (names.compat)	{ xfree(names.compat); names.compat= NULL; }
    if (names.symbols)	{ xfree(names.symbols); names.symbols= NULL; }
    if (names.geometry)	{ xfree(names.geometry); names.geometry= NULL; }
    return client->noClientException;
d6130 1
a6130 1
    bzero((char *)&rep,SIZEOF(xkbGetDeviceInfoReply));
d6214 1
a6214 1
    str= xalloc(nameLen);
d6219 1
a6219 1
    xfree(str);
d6240 1
a6240 1
    return client->noClientException;
d6338 2
a6339 2
    bzero((char *)&ed,sizeof(xkbExtensionDeviceNotify));
    bzero((char *)&changes,sizeof(XkbChangesRec));
d6360 1
a6360 1
	    bzero((char *)sli->names,XkbNumIndicators*sizeof(Atom));
d6364 1
a6364 1
	    bzero((char *)sli->names,XkbNumIndicators*sizeof(Atom));
d6378 1
a6378 1
	    bzero((char*)sli->maps,XkbNumIndicators*sizeof(XkbIndicatorMapRec));
d6457 1
a6457 1
    bzero((char *)&ed,SIZEOF(xkbExtensionDeviceNotify));
d6468 1
a6468 1
	    acts= xcalloc(nBtns, sizeof(XkbAction));
d6525 1
a6525 1
            if (((other != dev) && !IsMaster(other) && (other->u.master == dev)) &&
d6550 1
a6550 1
            if (((other != dev) && !IsMaster(other) && (other->u.master == dev)) &&
d6565 1
a6565 1
    return client->noClientException;
d6628 1
a6628 1
    return client->noClientException;
d6714 3
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a32 2
#define	NEED_EVENTS
#define	NEED_REPLIES
d41 1
d44 1
d46 1
a46 1
	int	XkbEventBase;
d48 3
a50 3
	int	XkbReqCode;
	int	XkbKeyboardErrorCode;
CARD32	xkbDebugFlags = 0;
d165 1
a165 1
    if (stuff->wantedMajor != XkbMajorVersion) {
d167 1
a167 1
	supported= ((XkbMajorVersion==1)&&
d182 1
a182 1
					XkbMajorVersion,XkbMinorVersion);
d184 1
d189 2
a190 2
    rep.serverMajor = XkbMajorVersion;
    rep.serverMinor = XkbMinorVersion;
d526 1
a526 1
            if ((other != dev) && other->key && !other->isMaster && (other->u.master == dev))
d557 1
a557 1
    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixReadAccess);
d565 1
a565 1
    rep.mods = dev->key->state&0xff;
d609 2
a610 3
        if ((dev == inputInfo.keyboard && tmpd->key && tmpd->coreEvents) ||
            tmpd == dev) {
            if (!tmpd->key->xkbInfo)
a630 1
            tmpd->key->state = XkbStateFieldFromRec(newState);
d640 1
a640 1
                changed = XkbIndicatorsToUpdate(tmpd, changed, False);
d643 1
a643 1
                    XkbUpdateIndicators(tmpd, changed, True, NULL, &cause);
d672 2
a673 2
    rep.length = (SIZEOF(xkbGetControlsReply)-
		  SIZEOF(xGenericReply)) >> 2;
d748 4
a751 4
    for (tmpd = inputInfo.keyboard; tmpd; tmpd = tmpd->next) {
        if ((dev == inputInfo.keyboard && tmpd->key && tmpd->coreEvents) ||
            tmpd == dev) {

d925 1
a925 1
            if (XkbComputeControlsNotify(tmpd, &old, ctrl, &cn, False)) {
d935 1
a935 1
                XkbUpdateIndicators(tmpd, sli->usesControls, True, NULL,
d941 1
a941 1
                XkbClearAllLatchesAndLocks(tmpd, xkbi, True, &cause);
d1368 1
a1368 1
    start= desc= (char *)xalloc(len);
d2118 1
a2118 1
	if (XkbComputeControlsNotify(dev,&old,xkb->ctrls,&cn,False))
d2189 2
a2190 2
             xkbi->radioGroups=(XkbRadioGroupPtr)_XkbRealloc(xkbi->radioGroups,sz);
        else xkbi->radioGroups= (XkbRadioGroupPtr)_XkbCalloc(1, sz);
d2442 1
a2442 1
    sentNKN = False;
d2460 1
a2460 1
	sentNKN = True;
a2523 1
    XkbUpdateCoreDescription(dev,False);
d2561 1
a2561 1
            if ((other != dev) && other->key && !other->isMaster && (other->u.master == dev))
d2584 1
a2584 1
            if ((other != dev) && other->key && !other->isMaster && (other->u.master == dev))
d2632 1
a2632 1
	data = (char *)xalloc(size);
d2730 1
a2730 1
 * If dryRun is True, then value checks are performed, but the device isn't
d2780 2
a2781 3
	    compat->sym_interpret= _XkbTypedRealloc(compat->sym_interpret,
						   compat->num_si,
						   XkbSymInterpretRec);
a2858 1
	XkbUpdateCoreDescription(dev,False);
d2890 1
a2890 1
            if ((other != dev) && other->key && !other->isMaster && (other->u.master == dev))
d2913 1
a2913 1
            if ((other != dev) && other->key && !other->isMaster && (other->u.master == dev))
d2998 1
a2998 1
	to= map= (CARD8 *)xalloc(length);
d3168 1
a3168 1
            if ((other != dev) && other->key && !other->isMaster && (other->u.master == dev))
d3221 1
a3221 1
	rep.found= 		True;
d3233 1
a3233 1
	rep.supported= 		True;
d3236 3
a3238 3
	rep.found= 		False;
	rep.on= 		False;
	rep.realIndicator= 	False;
d3248 1
a3248 1
	rep.supported= 		True;
a3274 1
    int                 led;
d3279 2
d3284 1
a3289 1
    *led_return = led;
d3294 1
a3294 1
 * Creates an indicator map on the device. If dryRun is True, it only checks
d3437 1
a3437 1
            if ((other != dev) && !other->isMaster && (other->u.master == dev) &&
d3461 1
a3461 1
            if ((other != dev) && !other->isMaster && (other->u.master == dev) &&
d3635 1
a3635 1
    start = desc = (char *)xalloc(length);
d3780 1
d3861 1
a3861 1
char *	str;
d3866 2
a3867 2
	return False;
    return True;
d4121 1
a4121 1
            _XkbFree(names->key_aliases);
d4140 1
a4140 1
            _XkbFree(names->radio_groups);
d4252 1
a4252 1
            if ((other != dev) && other->key && !other->isMaster && (other->u.master == dev))
d4277 1
a4277 1
            if ((other != dev) && other->key && !other->isMaster && (other->u.master == dev))
d4301 1
a4301 1
CARD16	len,*pLen;
d4303 4
a4306 1
    len= (str?strlen(str):0);
d4706 1
a4706 1
	rep->found= True;
d4721 1
a4721 1
	rep->found= False;
d4743 1
a4743 1
	start= desc= (char *)xalloc(len);
d4789 1
a4789 1
	XkbFreeGeometry(geom,XkbGeomAllMask,True);
d4837 1
a4837 1
    str= (char *)_XkbAlloc(len+1);
d5283 1
a5283 1
        XkbFreeGeometry(geom,XkbGeomAllMask,True);
d5290 1
a5290 1
        XkbFreeGeometry(old,XkbGeomAllMask,True);
d5331 1
a5331 1
            if ((other != dev) && other->key && !other->isMaster && (other->u.master == dev))
d5364 1
d5452 1
a5452 1
	str= (unsigned char *)_XkbCalloc(1, len+1);
d5463 1
a5463 1
		_XkbFree(str);
d5502 5
a5506 6
    list.pattern[_XkbListKeymaps]= GetComponentSpec(&str,False,&status);
    list.pattern[_XkbListKeycodes]= GetComponentSpec(&str,False,&status);
    list.pattern[_XkbListTypes]= GetComponentSpec(&str,False,&status);
    list.pattern[_XkbListCompat]= GetComponentSpec(&str,False,&status);
    list.pattern[_XkbListSymbols]= GetComponentSpec(&str,False,&status);
    list.pattern[_XkbListGeometry]= GetComponentSpec(&str,False,&status);
d5514 1
a5514 1
	    _XkbFree(list.pool);
d5524 1
a5524 1
    rep.nKeymaps = list.nFound[_XkbListKeymaps];
d5548 1
a5548 1
	_XkbFree(list.pool);
d5590 7
a5596 6
    names.keymap= GetComponentSpec(&str,True,&status);
    names.keycodes= GetComponentSpec(&str,True,&status);
    names.types= GetComponentSpec(&str,True,&status);
    names.compat= GetComponentSpec(&str,True,&status);
    names.symbols= GetComponentSpec(&str,True,&status);
    names.geometry= GetComponentSpec(&str,True,&status);
d5622 1
a5622 1
        geom_changed= False;
d5632 4
a5635 4
    rep.loaded=	False;
    fwant= XkbConvertGetByNameComponents(True,stuff->want)|XkmVirtualModsMask;
    fneed= XkbConvertGetByNameComponents(True,stuff->need);
    rep.reported= XkbConvertGetByNameComponents(False,fwant|fneed);
d5648 1
a5648 1
    rep.newKeyboard= False;
d5656 1
a5656 1
	    rep.loaded= True;
d5792 1
a5792 1
	    grep.found= True;
d5821 1
a5821 1
	XkbSendGeometry(client,new->geom,&grep,False);
d5845 1
a5845 6
            if (tmpd == dev ||
                (dev->id == inputInfo.keyboard->id && tmpd->key &&
                 tmpd->coreEvents)) {

                memcpy(tmpd->key->modifierMap, xkb->map->modmap,
                       xkb->max_key_code + 1);
d5847 1
a5847 3
                    XkbCopyKeymap(dev->key->xkbInfo->desc,
                                  tmpd->key->xkbInfo->desc, True);
                XkbUpdateCoreDescription(tmpd, True);
a5862 2
        /* this should be either a MN or an NKN, depending on whether or not
         * the keycode range changed? */
d5874 10
d5886 1
a5886 1
	XkbFreeKeyboard(new,XkbAllComponentsMask,True);
d5889 5
a5893 6
    if (names.keymap)	{ _XkbFree(names.keymap); names.keymap= NULL; }
    if (names.keycodes)	{ _XkbFree(names.keycodes); names.keycodes= NULL; }
    if (names.types)	{ _XkbFree(names.types); names.types= NULL; }
    if (names.compat)	{ _XkbFree(names.compat); names.compat= NULL; }
    if (names.symbols)	{ _XkbFree(names.symbols); names.symbols= NULL; }
    if (names.geometry)	{ _XkbFree(names.geometry); names.geometry= NULL; }
d5947 1
a5947 1
    classOk= False;
d5950 1
a5950 1
	classOk= True;
d5965 1
a5965 1
	classOk= True;
d5979 2
a5980 4
	if (rep->supported&XkbXI_IndicatorsMask) {
	    rep->nDeviceLedFBs= nFBs;
	    rep->length+= (length/4);
	}
d6104 1
a6104 1
unsigned		wanted,supported;
d6137 1
a6137 1
    rep.devType=	dev->type;
a6194 1
    supported= rep.supported;
d6208 1
a6208 1
    str= (char*) xalloc(nameLen);
a6233 13
    if (stuff->wanted&(~supported)) {
	xkbExtensionDeviceNotify ed;
	bzero((char *)&ed,SIZEOF(xkbExtensionDeviceNotify));
	ed.ledClass=		ledClass;
	ed.ledID=		ledID;
	ed.ledsDefined= 	0;
	ed.ledState=		0;
	ed.firstBtn= ed.nBtns=	0;
	ed.reason=		XkbXI_UnsupportedFeatureMask;
	ed.supported=		supported;
	ed.unsupported=		stuff->wanted&(~supported);
	XkbSendExtensionDeviceNotify(dev,client,&ed);
    }
d6462 1
a6462 1
	    acts= _XkbTypedCalloc(nBtns,XkbAction);
d6519 1
a6519 1
            if (((other != dev) && !other->isMaster && (other->u.master == dev)) &&
d6544 1
a6544 1
            if (((other != dev) && !other->isMaster && (other->u.master == dev)) &&
a6605 2
    XkbDisableLockActions= (xkbDebugCtrls&XkbDF_DisableLocks);

d6706 4
a6716 1
	RT_XKBCLIENT = CreateNewResourceType(XkbClientGone);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d178 1
a178 1
	ErrorF("Rejecting client %d (0x%lx) (wants %d.%02d, have %d.%02d)\n",
d342 1
a342 1
	    ErrorF("Extra data (%d bytes) after SelectEvents\n",dataLeft);
d423 1
a423 1
        client->errorValue = _XkbErrCode2(0x7, bellClass);;
d525 1
a525 1
            if ((other != dev) && other->key && other->coreEvents)
d1314 1
a1314 1
    for (nRtrn=i=0;i<rep->nVModMapKeys-1;i++) {
d1333 1
a1333 1
    for (i=0;i<rep->nVModMapKeys-1;i++,pMap++) {
d1396 1
a1396 1
	ErrorF("BOGUS LENGTH in write keyboard desc, expected %d, got %ld\n",
d2563 1
a2563 1
            if ((other != dev) && other->key && other->coreEvents)
d2586 1
a2586 1
            if ((other != dev) && other->key && other->coreEvents)
d2894 1
a2894 1
            if ((other != dev) && other->key && other->coreEvents)
d2909 1
a2909 1
    rc = _XkbSetCompatMap(client, dev, stuff, data, TRUE);
d2917 1
a2917 1
            if ((other != dev) && other->key && other->coreEvents)
d2922 1
a2922 1
                    rc = _XkbSetCompatMap(client, other, stuff, data, TRUE);
d3172 1
a3172 1
            if ((other != dev) && other->key && other->coreEvents)
d3440 2
a3441 1
            if ((other != dev) && other->coreEvents &&
d3464 2
a3465 1
            if ((other != dev) && other->coreEvents &&
d3757 1
a3757 1
	ErrorF("BOGUS LENGTH in write names, expected %d, got %ld\n",
d4254 1
a4254 1
            if ((other != dev) && other->key && other->coreEvents)
d4279 1
a4279 1
            if ((other != dev) && other->key && other->coreEvents)
d4530 1
a4530 1
		ErrorF("Unknown doodad type %d in XkbWriteGeomDoodads\n",
d4532 1
a4532 1
		ErrorF("Ignored\n");
d4760 1
a4760 1
	    ErrorF("BOGUS LENGTH in XkbSendGeometry, expected %d, got %ld\n",
d5330 1
a5330 1
            if ((other != dev) && other->key && other->coreEvents)
d5676 1
a5676 1
		mrep.totalModMapKeys= 0;
d5702 2
d6231 2
a6232 2
	ErrorF("Internal Error!  BadLength in ProcXkbGetDeviceInfo\n");
	ErrorF("                 Wrote %d fewer bytes than expected\n",length);
d6533 1
a6533 1
            if (((other != dev) && other->coreEvents) &&
d6558 1
a6558 1
            if (((other != dev) && other->coreEvents) &&
d6597 1
a6597 1
	ErrorF("XkbDebug: Setting debug flags to 0x%lx\n",(long)newFlags);
d6599 1
a6599 1
	    ErrorF("XkbDebug: Setting debug controls to 0x%lx\n",(long)newCtrls);
d6605 1
a6605 1
	    ErrorF("XkbDebug: msgLength= %d, length= %ld (should be %d)\n",
d6612 1
a6612 1
	    ErrorF("XkbDebug: message not null-terminated\n");
d6615 1
a6615 1
	ErrorF("XkbDebug: %s\n",msg);
d6712 1
a6712 1
	ErrorF("Internal Error! bad RemoveResourceClient in XkbClientGone\n");
a6716 6
/*ARGSUSED*/
static void
XkbResetProc(ExtensionEntry *extEntry)
{
}

d6724 1
a6724 1
				 XkbResetProc, StandardMinorOpcode))) {
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
#include <X11/extensions/XKBsrv.h>
d41 1
d47 1
a47 1
	int	XkbErrorBase;
a49 3
Atom	xkbONE_LEVEL;
Atom	xkbTWO_LEVEL;
Atom	xkbKEYPAD;
d51 1
a51 1
CARD32	xkbDebugCtrls = 0;
d53 1
a53 1
RESTYPE	RT_XKBCLIENT;
d57 1
a57 1
#define	CHK_DEVICE(d,sp,lf) {\
d59 4
a62 4
    d = (DeviceIntPtr)lf((sp),&why);\
    if  (!dev) {\
	client->errorValue = _XkbErrCode2(why,(sp));\
	return XkbKeyboardErrorCode;\
d66 8
a73 4
#define	CHK_KBD_DEVICE(d,sp) 	CHK_DEVICE(d,sp,_XkbLookupKeyboard)
#define	CHK_LED_DEVICE(d,sp) 	CHK_DEVICE(d,sp,_XkbLookupLedDevice)
#define	CHK_BELL_DEVICE(d,sp) 	CHK_DEVICE(d,sp,_XkbLookupBellDevice)
#define	CHK_ANY_DEVICE(d,sp) 	CHK_DEVICE(d,sp,_XkbLookupAnyDevice)
d214 1
a214 1
    CHK_ANY_DEVICE(dev,stuff->deviceSpec);
d351 105
d463 1
a463 3
    int base;
    int newPercent,oldPitch,oldDuration;
    pointer ctrl;
d470 1
a470 1
    CHK_BELL_DEVICE(dev,stuff->deviceSpec);
d473 1
d496 1
a496 62
    if (stuff->bellClass == KbdFeedbackClass) {
	KbdFeedbackPtr	k;
	if (stuff->bellID==XkbDfltXIId) 
	    k= dev->kbdfeed;
	else {
	    for (k=dev->kbdfeed; k; k=k->next) {
		if (k->ctrl.id == stuff->bellID)
		    break;
	    }
	}
	if (!k) {
	    client->errorValue= _XkbErrCode2(0x5,stuff->bellID);
	    return BadValue;
	}
	base = k->ctrl.bell;
	ctrl = (pointer) &(k->ctrl);
	oldPitch= k->ctrl.bell_pitch;
	oldDuration= k->ctrl.bell_duration;
	if (stuff->pitch!=0) {
	    if (stuff->pitch==-1)
		 k->ctrl.bell_pitch= defaultKeyboardControl.bell_pitch;
	    else k->ctrl.bell_pitch= stuff->pitch;
	}
	if (stuff->duration!=0) {
	    if (stuff->duration==-1)
		 k->ctrl.bell_duration= defaultKeyboardControl.bell_duration;
	    else k->ctrl.bell_duration= stuff->duration;
	}
    }
    else if (stuff->bellClass == BellFeedbackClass) {
	BellFeedbackPtr	b;
	if (stuff->bellID==XkbDfltXIId)
	    b= dev->bell;
	else {
	    for (b=dev->bell; b; b=b->next) {
		if (b->ctrl.id == stuff->bellID)
		    break;
	    }
	}
	if (!b) {
	    client->errorValue = _XkbErrCode2(0x6,stuff->bellID);
	    return BadValue;
	}
	base = b->ctrl.percent;
	ctrl = (pointer) &(b->ctrl);
	oldPitch= b->ctrl.pitch;
	oldDuration= b->ctrl.duration;
	if (stuff->pitch!=0) {
	    if (stuff->pitch==-1)
		 b->ctrl.pitch= defaultKeyboardControl.bell_pitch;
	    else b->ctrl.pitch= stuff->pitch;
	}
	if (stuff->duration!=0) {
	    if (stuff->duration==-1)
		 b->ctrl.duration= defaultKeyboardControl.bell_duration;
	    else b->ctrl.duration= stuff->duration;
	}
    }
    else {
	client->errorValue = _XkbErrCode2(0x7,stuff->bellClass);;
	return BadValue;
    }
d498 2
a499 2
	pWin= (WindowPtr)LookupIDByType(stuff->window,RT_WINDOW);
	if (pWin==NULL) {
d501 1
a501 1
	    return BadValue;
d506 30
a535 24
    newPercent= (base*stuff->percent)/100;
    if (stuff->percent < 0)
         newPercent= base+newPercent;
    else newPercent= base-newPercent+stuff->percent;
    XkbHandleBell(stuff->forceSound, stuff->eventOnly,
				dev, newPercent, ctrl, stuff->bellClass, 
				stuff->name, pWin, client);
    if ((stuff->pitch!=0)||(stuff->duration!=0)) {
	if (stuff->bellClass == KbdFeedbackClass) {
	    KbdFeedbackPtr	k;
	    k= (KbdFeedbackPtr)ctrl;
	    if (stuff->pitch!=0)
		k->ctrl.bell_pitch= oldPitch;
	    if (stuff->duration!=0)
		k->ctrl.bell_duration= oldDuration;
	}
	else {
	    BellFeedbackPtr	b;
	    b= (BellFeedbackPtr)ctrl;
	    if (stuff->pitch!=0)
		b->ctrl.pitch= oldPitch;
	    if (stuff->duration!=0)
		b->ctrl.duration= oldDuration;
	}
d537 2
a538 1
    return Success;
d556 1
a556 1
    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
d589 1
a589 1
    DeviceIntPtr dev;
d592 2
d598 1
a598 1
    if (!(client->xkbClientFlags&_XkbClientInitialized))
d601 3
a603 3
    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
    CHK_MASK_MATCH(0x01,stuff->affectModLocks,stuff->modLocks);
    CHK_MASK_MATCH(0x01,stuff->affectModLatches,stuff->modLatches);
a605 12
    oldState= dev->key->xkbInfo->state;
    newState= &dev->key->xkbInfo->state;
    if ( stuff->affectModLocks ) {
	newState->locked_mods&= ~stuff->affectModLocks;
	newState->locked_mods|= (stuff->affectModLocks&stuff->modLocks);
    }
    if (( status == Success ) && stuff->lockGroup )
	newState->locked_group = stuff->groupLock;
    if (( status == Success ) && stuff->affectModLatches )
	status=XkbLatchModifiers(dev,stuff->affectModLatches,stuff->modLatches);
    if (( status == Success ) && stuff->latchGroup )
	status=XkbLatchGroup(dev,stuff->groupLatch);
d607 42
a648 5
    if ( status != Success )
	return status;

    XkbComputeDerivedState(dev->key->xkbInfo);
    dev->key->state= XkbStateFieldFromRec(newState);
a649 16
    changed = XkbStateChangedFlags(&oldState,newState);
    if (changed) {
	xkbStateNotify	sn;
	sn.keycode= 0;
	sn.eventType= 0;
	sn.requestMajor = XkbReqCode;
	sn.requestMinor = X_kbLatchLockState;
	sn.changed= changed;
	XkbSendStateNotify(dev,&sn);
	changed= XkbIndicatorsToUpdate(dev,changed,False);
	if (changed) {
	    XkbEventCauseRec	cause;
	    XkbSetCauseXkbReq(&cause,X_kbLatchLockState,client);
	    XkbUpdateIndicators(dev,changed,True,NULL,&cause);
	}
    }
d669 1
a669 1
    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
d732 1
a732 1
    DeviceIntPtr 	dev;
d743 1
a743 1
    if (!(client->xkbClientFlags&_XkbClientInitialized))
d746 135
a880 2
    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
    CHK_MASK_LEGAL(0x01,stuff->changeCtrls,XkbAllControlsMask);
d882 15
a896 108
    xkbi = dev->key->xkbInfo;
    ctrl = xkbi->desc->ctrls;
    new = *ctrl;
    XkbSetCauseXkbReq(&cause,X_kbSetControls,client);
    if (stuff->changeCtrls&XkbInternalModsMask) {
	CHK_MASK_MATCH(0x02,stuff->affectInternalMods,stuff->internalMods);
	CHK_MASK_MATCH(0x03,stuff->affectInternalVMods,stuff->internalVMods);
	new.internal.real_mods&=~stuff->affectInternalMods;
	new.internal.real_mods|=(stuff->affectInternalMods&stuff->internalMods);
	new.internal.vmods&=~stuff->affectInternalVMods;
	new.internal.vmods|= (stuff->affectInternalVMods&stuff->internalVMods);
	new.internal.mask= new.internal.real_mods|
	      XkbMaskForVMask(xkbi->desc,new.internal.vmods);
    }
    if (stuff->changeCtrls&XkbIgnoreLockModsMask) {
	CHK_MASK_MATCH(0x4,stuff->affectIgnoreLockMods,stuff->ignoreLockMods);
	CHK_MASK_MATCH(0x5,stuff->affectIgnoreLockVMods,stuff->ignoreLockVMods);
	new.ignore_lock.real_mods&=~stuff->affectIgnoreLockMods;
	new.ignore_lock.real_mods|=
	      (stuff->affectIgnoreLockMods&stuff->ignoreLockMods);
	new.ignore_lock.vmods&= ~stuff->affectIgnoreLockVMods;
	new.ignore_lock.vmods|=
	      (stuff->affectIgnoreLockVMods&stuff->ignoreLockVMods);
	new.ignore_lock.mask= new.ignore_lock.real_mods|
	      XkbMaskForVMask(xkbi->desc,new.ignore_lock.vmods);
    }
    CHK_MASK_MATCH(0x06,stuff->affectEnabledCtrls,stuff->enabledCtrls);
    if (stuff->affectEnabledCtrls) {
	CHK_MASK_LEGAL(0x07,stuff->affectEnabledCtrls,XkbAllBooleanCtrlsMask);
	new.enabled_ctrls&= ~stuff->affectEnabledCtrls;
	new.enabled_ctrls|= (stuff->affectEnabledCtrls&stuff->enabledCtrls);
    }
    if (stuff->changeCtrls&XkbRepeatKeysMask) {
	if ((stuff->repeatDelay<1)||(stuff->repeatInterval<1)) {
	   client->errorValue = _XkbErrCode3(0x08,stuff->repeatDelay,
							stuff->repeatInterval);
	   return BadValue;
	}
	new.repeat_delay = stuff->repeatDelay;
	new.repeat_interval = stuff->repeatInterval;
    }
    if (stuff->changeCtrls&XkbSlowKeysMask) {
	if (stuff->slowKeysDelay<1) {
	    client->errorValue = _XkbErrCode2(0x09,stuff->slowKeysDelay);
	    return BadValue;
	}
	new.slow_keys_delay = stuff->slowKeysDelay;
    }
    if (stuff->changeCtrls&XkbBounceKeysMask) {
	if (stuff->debounceDelay<1) {
	    client->errorValue = _XkbErrCode2(0x0A,stuff->debounceDelay);
	    return BadValue;
	}
	new.debounce_delay = stuff->debounceDelay;
    }
    if (stuff->changeCtrls&XkbMouseKeysMask) {
	if (stuff->mkDfltBtn>XkbMaxMouseKeysBtn) {
	    client->errorValue = _XkbErrCode2(0x0B,stuff->mkDfltBtn);
	    return BadValue;
	}
	new.mk_dflt_btn = stuff->mkDfltBtn;
    }
    if (stuff->changeCtrls&XkbMouseKeysAccelMask) {
	if ((stuff->mkDelay<1) || (stuff->mkInterval<1) ||
	    (stuff->mkTimeToMax<1) || (stuff->mkMaxSpeed<1)||
	    (stuff->mkCurve<-1000)) {
	    client->errorValue = _XkbErrCode2(0x0C,0);
	    return BadValue;
	}
	new.mk_delay = stuff->mkDelay;
	new.mk_interval = stuff->mkInterval;
	new.mk_time_to_max = stuff->mkTimeToMax;
	new.mk_max_speed = stuff->mkMaxSpeed;
	new.mk_curve = stuff->mkCurve;
	AccessXComputeCurveFactor(xkbi,&new);
    }
    if (stuff->changeCtrls&XkbGroupsWrapMask) {
	unsigned act,num;
	act= XkbOutOfRangeGroupAction(stuff->groupsWrap);
	switch (act) {
	    case XkbRedirectIntoRange:
		num= XkbOutOfRangeGroupNumber(stuff->groupsWrap);
		if (num>=new.num_groups) {
		    client->errorValue= _XkbErrCode3(0x0D,new.num_groups,num);
		    return BadValue;
		}
	    case XkbWrapIntoRange:
	    case XkbClampIntoRange:
		break;
	    default:
		client->errorValue= _XkbErrCode2(0x0E,act);
		return BadValue;
	}
	new.groups_wrap= stuff->groupsWrap;
    }
    CHK_MASK_LEGAL(0x0F,stuff->axOptions,XkbAX_AllOptionsMask);
    if (stuff->changeCtrls&XkbAccessXKeysMask)
	new.ax_options = stuff->axOptions&XkbAX_AllOptionsMask;
    else {
	if (stuff->changeCtrls&XkbStickyKeysMask) {
	   new.ax_options&= ~XkbAX_SKOptionsMask;
	   new.ax_options|= stuff->axOptions&XkbAX_SKOptionsMask;
	}
	if (stuff->changeCtrls&XkbAccessXFeedbackMask) {
	   new.ax_options&= ~XkbAX_FBOptionsMask;
	   new.ax_options|= stuff->axOptions&XkbAX_FBOptionsMask;
	}
    }
d898 19
a916 39
    if (stuff->changeCtrls&XkbAccessXTimeoutMask) {
	if (stuff->axTimeout<1) {
	    client->errorValue = _XkbErrCode2(0x10,stuff->axTimeout);
	    return BadValue;
	}
	CHK_MASK_MATCH(0x11,stuff->axtCtrlsMask,stuff->axtCtrlsValues);
	CHK_MASK_LEGAL(0x12,stuff->axtCtrlsMask,XkbAllBooleanCtrlsMask);
	CHK_MASK_MATCH(0x13,stuff->axtOptsMask,stuff->axtOptsValues);
	CHK_MASK_LEGAL(0x14,stuff->axtOptsMask,XkbAX_AllOptionsMask);
	new.ax_timeout = stuff->axTimeout;
	new.axt_ctrls_mask = stuff->axtCtrlsMask;
	new.axt_ctrls_values = (stuff->axtCtrlsValues&stuff->axtCtrlsMask);
	new.axt_opts_mask = stuff->axtOptsMask;
	new.axt_opts_values= (stuff->axtOptsValues&stuff->axtOptsMask);
    }
    if (stuff->changeCtrls&XkbPerKeyRepeatMask) {
	memcpy(new.per_key_repeat,stuff->perKeyRepeat,XkbPerKeyBitArraySize);
    }
    old= *ctrl;
    *ctrl= new;
    XkbDDXChangeControls(dev,&old,ctrl);
    if (XkbComputeControlsNotify(dev,&old,ctrl,&cn,False)) {
	cn.keycode= 0;
	cn.eventType = 0;
	cn.requestMajor = XkbReqCode;
	cn.requestMinor = X_kbSetControls;
	XkbSendControlsNotify(dev,&cn);
    }
    if ((sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0))!=NULL)
	XkbUpdateIndicators(dev,sli->usesControls,True,NULL,&cause);
#ifndef NO_CLEAR_LATCHES_FOR_STICKY_KEYS_OFF
    /* If sticky keys were disabled, clear all locks and latches */
    if ((old.enabled_ctrls&XkbStickyKeysMask)&&
	(!(ctrl->enabled_ctrls&XkbStickyKeysMask))) {
	XkbClearAllLatchesAndLocks(dev,xkbi,True,&cause);
    }
#endif
    return client->noClientException;
}
d918 15
a932 5
int
XkbSetRepeatRate(DeviceIntPtr dev,int timeout,int interval,int major,int minor)
{
int	changed= 0;
XkbControlsRec old,*xkb;
d934 10
a943 22
    if ((!dev)||(!dev->key)||(!dev->key->xkbInfo))
	return 0;
    xkb= dev->key->xkbInfo->desc->ctrls;
    old= *xkb;
    if ((timeout!=0) && (xkb->repeat_delay!=timeout)) {
	xkb->repeat_delay= timeout;
	changed++;
    }
    if ((interval!=0) && (xkb->repeat_interval!=interval)) {
	xkb->repeat_interval= interval;
	changed++;
    }
    if (changed) {
	xkbControlsNotify	cn;
	XkbDDXChangeControls(dev,&old,xkb);
	if (XkbComputeControlsNotify(dev,&old,xkb,&cn,False)) {
	    cn.keycode= 0;
	    cn.eventType = 0;
	    cn.requestMajor = major;
	    cn.requestMinor = minor;
	    XkbSendControlsNotify(dev,&cn);
	}
a944 2
    return 1;
}
d946 1
a946 11
int
XkbGetRepeatRate(DeviceIntPtr dev,int *timeout,int *interval)
{
XkbControlsPtr	xkb;

    if ((!dev)||(!dev->key)||(!dev->key->xkbInfo))
	return 0;
    xkb= dev->key->xkbInfo->desc->ctrls;
    if (timeout)	*timeout= xkb->repeat_delay;
    if (interval)	*interval= xkb->repeat_interval;
    return 1;
d1333 1
a1333 1
    for (i=0;i<rep->nVModMapKeys;i++,pMap++) {
d1369 1
a1369 1
    start= desc= (char *)ALLOCATE_LOCAL(len);
d1409 1
a1409 1
    DEALLOCATE_LOCAL((char *)start);
d1427 1
a1427 1
    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
d2335 6
a2340 2
int
ProcXkbSetMap(ClientPtr client)
d2342 6
a2347 16
    DeviceIntPtr	dev;
    XkbSrvInfoPtr	xkbi;
    XkbDescPtr		xkb;
    XkbChangesRec	change;
    XkbEventCauseRec	cause;
    int			nTypes = 0,nActions,error;
    char *		tmp;
    CARD8	 	mapWidths[XkbMaxLegalKeyCode+1];
    CARD16	 	symsPerKey[XkbMaxLegalKeyCode+1];
    Bool		sentNKN;

    REQUEST(xkbSetMapReq);
    REQUEST_AT_LEAST_SIZE(xkbSetMapReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;
a2348 4
    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
    CHK_MASK_LEGAL(0x01,stuff->present,XkbAllMapComponentsMask);

    XkbSetCauseXkbReq(&cause,X_kbSetMap,client);
d2352 2
a2353 2
    if ((xkb->min_key_code!=stuff->minKeyCode)||
    				(xkb->max_key_code!=stuff->maxKeyCode)) {
d2355 2
a2356 2
	    stuff->minKeyCode= xkb->min_key_code;
	    stuff->maxKeyCode= xkb->max_key_code;
d2359 2
a2360 3
	    if (!XkbIsLegalKeycode(stuff->minKeyCode)) {
		client->errorValue= _XkbErrCode3(2,stuff->minKeyCode,
							stuff->maxKeyCode);
d2363 2
a2364 3
	    if (stuff->minKeyCode>stuff->maxKeyCode) {
		client->errorValue= _XkbErrCode3(3,stuff->minKeyCode,
							stuff->maxKeyCode);
d2370 2
a2371 3
    tmp = (char *)&stuff[1];
    if ((stuff->present&XkbKeyTypesMask)&&
	(!CheckKeyTypes(client,xkb,stuff,(xkbKeyTypeWireDesc **)&tmp,
d2376 3
a2378 3
    if ((stuff->present&XkbKeySymsMask)&&
	(!CheckKeySyms(client,xkb,stuff,nTypes,mapWidths,symsPerKey,
					(xkbSymMapWireDesc **)&tmp,&error))) {
d2383 3
a2385 3
    if ((stuff->present&XkbKeyActionsMask)&&
	(!CheckKeyActions(xkb,stuff,nTypes,mapWidths,symsPerKey,
						(CARD8 **)&tmp,&nActions))) {
d2390 2
a2391 2
    if ((stuff->present&XkbKeyBehaviorsMask)&&
	(!CheckKeyBehaviors(xkb,stuff,(xkbBehaviorWireDesc**)&tmp,&error))) {
d2396 2
a2397 2
    if ((stuff->present&XkbVirtualModsMask)&&
	(!CheckVirtualMods(xkb,stuff,(CARD8 **)&tmp,&error))) {
d2401 2
a2402 2
    if ((stuff->present&XkbExplicitComponentsMask)&&
	(!CheckKeyExplicit(xkb,stuff,(CARD8 **)&tmp,&error))) {
d2406 2
a2407 2
    if ((stuff->present&XkbModifierMapMask)&&
	(!CheckModifierMap(xkb,stuff,(CARD8 **)&tmp,&error))) {
d2411 2
a2412 2
    if ((stuff->present&XkbVirtualModMapMask)&&
	(!CheckVirtualModMap(xkb,stuff,(xkbVModMapWireDesc **)&tmp,&error))) {
d2416 4
a2419 3
    if (((tmp-((char *)stuff))/4)!=stuff->length) {
	ErrorF("Internal error! Bad length in XkbSetMap (after check)\n");
	client->errorValue = tmp-((char *)&stuff[1]);
d2422 24
a2445 4
    bzero(&change,sizeof(change));
    sentNKN= False;
    if ((xkb->min_key_code!=stuff->minKeyCode)||
    				(xkb->max_key_code!=stuff->maxKeyCode)) {
d2448 12
a2459 12
	nkn.deviceID= nkn.oldDeviceID= dev->id;
	nkn.oldMinKeyCode= xkb->min_key_code;
	nkn.oldMaxKeyCode= xkb->max_key_code;
	status= XkbChangeKeycodeRange(xkb,stuff->minKeyCode,stuff->maxKeyCode,
								&change);
	if (status!=Success)
	    return status;
	nkn.minKeyCode= xkb->min_key_code;
	nkn.maxKeyCode= xkb->max_key_code;
	nkn.requestMajor= XkbReqCode;
	nkn.requestMinor= X_kbSetMap;
	nkn.changed= XkbNKN_KeycodesMask;
d2461 1
a2461 1
	sentNKN= True;
d2463 28
a2490 28
    tmp = (char *)&stuff[1];
    if (stuff->present&XkbKeyTypesMask) {
	tmp = SetKeyTypes(xkb,stuff,(xkbKeyTypeWireDesc *)tmp,&change);
	if (!tmp)	goto allocFailure;
    }
    if (stuff->present&XkbKeySymsMask) {
	tmp = SetKeySyms(client,xkb,stuff,(xkbSymMapWireDesc *)tmp,&change,dev);
	if (!tmp)	goto allocFailure;
    }
    if (stuff->present&XkbKeyActionsMask) {
	tmp = SetKeyActions(xkb,stuff,(CARD8 *)tmp,&change);
	if (!tmp)	goto allocFailure;
    }
    if (stuff->present&XkbKeyBehaviorsMask) {
	tmp= SetKeyBehaviors(xkbi,stuff,(xkbBehaviorWireDesc *)tmp,&change);
	if (!tmp)	goto allocFailure;
    }
    if (stuff->present&XkbVirtualModsMask)
	tmp= SetVirtualMods(xkbi,stuff,(CARD8 *)tmp,&change);
    if (stuff->present&XkbExplicitComponentsMask)
	tmp= SetKeyExplicit(xkbi,stuff,(CARD8 *)tmp,&change);
    if (stuff->present&XkbModifierMapMask)
	tmp= SetModifierMap(xkbi,stuff,(CARD8 *)tmp,&change);
    if (stuff->present&XkbVirtualModMapMask)
	tmp= SetVirtualModMap(xkbi,stuff,(xkbVModMapWireDesc *)tmp,&change);
    if (((tmp-((char *)stuff))/4)!=stuff->length) {
	ErrorF("Internal error! Bad length in XkbSetMap (after set)\n");
	client->errorValue = tmp-((char *)&stuff[1]);
d2493 1
a2493 1
    if (stuff->flags&XkbSetMapRecomputeActions) {
d2526 1
a2526 1
    return client->noClientException;
d2531 71
d2634 1
a2634 1
	data = (char *)ALLOCATE_LOCAL(size);
d2685 1
a2685 1
	DEALLOCATE_LOCAL((char *)data);
d2704 1
a2704 1
    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
d2730 8
a2737 2
int
ProcXkbSetCompatMap(ClientPtr client)
d2739 5
a2743 7
    DeviceIntPtr 	dev;
    XkbSrvInfoPtr 	xkbi;
    XkbDescPtr		xkb;
    XkbCompatMapPtr 	compat;
    char	*	data;
    int		 	nGroups;
    register unsigned	i,bit;
d2745 3
a2747 7
    REQUEST(xkbSetCompatMapReq);
    REQUEST_AT_LEAST_SIZE(xkbSetCompatMapReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
d2749 1
a2749 5
    data = (char *)&stuff[1];
    xkbi = dev->key->xkbInfo;
    xkb= xkbi->desc;
    compat= xkb->compat;
    if ((stuff->nSI>0)||(stuff->truncateSI)) {
d2751 1
a2751 1
	if (stuff->firstSI>compat->num_si) {
d2756 1
a2756 1
	wire+= stuff->nSI;
d2759 1
d2761 1
a2761 1
    if (stuff->groups!=0) {
d2763 1
a2763 1
	    if ( stuff->groups&bit )
d2768 1
a2768 1
    if (((data-((char *)stuff))/4)!=stuff->length) {
d2771 7
a2777 2
    data = (char *)&stuff[1];
    if (stuff->nSI>0) {
d2780 2
a2781 2
	if ((unsigned)(stuff->firstSI+stuff->nSI)>compat->num_si) {
	    compat->num_si= stuff->firstSI+stuff->nSI;
d2790 2
a2791 2
	else if (stuff->truncateSI) {
	    compat->num_si = stuff->firstSI+stuff->nSI;
d2793 2
a2794 2
	sym = &compat->sym_interpret[stuff->firstSI];
	for (i=0;i<stuff->nSI;i++,wire++,sym++) {
d2796 1
a2796 1
		register int n;
d2805 1
a2805 1
	    					SIZEOF(xkbActionWireDesc));
d2809 2
a2810 2
    else if (stuff->truncateSI) {
	compat->num_si = stuff->firstSI;
d2813 2
a2814 2
    if (stuff->groups!=0) {
	register unsigned i,bit;
d2816 2
a2817 2
	for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
	    if (stuff->groups&bit) {
d2819 1
a2819 1
		    register int n;
d2835 3
a2837 3
    i= XkbPaddedSize((data-((char *)stuff)));
    if ((i/4)!=stuff->length) {
	ErrorF("Internal length error on read in ProcXkbSetCompatMap\n");
d2840 1
a2840 1
    
d2844 3
a2846 3
	ev.changedGroups = stuff->groups;
	ev.firstSI = stuff->firstSI;
	ev.nSI = stuff->nSI;
d2851 1
a2851 1
    if (stuff->recomputeActions) {
d2865 1
a2865 1
    return client->noClientException;
a2867 2
/***====================================================================***/

d2869 1
a2869 1
ProcXkbGetIndicatorState(ClientPtr client)
d2871 71
a2941 4
    xkbGetIndicatorStateReply 	rep;
    XkbSrvLedInfoPtr		sli;
    DeviceIntPtr 		dev;
    register int 		i;
d2949 1
a2949 1
    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
d2972 1
a2972 1
Status
d2989 1
a2989 1
int
d3002 1
a3002 1
	to= map= (CARD8 *)ALLOCATE_LOCAL(length);
d3041 1
a3041 1
	DEALLOCATE_LOCAL((char *)map);
d3060 1
a3060 1
    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
d3074 45
d3122 5
a3126 7
    register int 	i,bit;
    int			nIndicators,why;
    DeviceIntPtr 	dev;
    XkbSrvInfoPtr	xkbi;
    xkbIndicatorMapWireDesc *from;
    XkbSrvLedInfoPtr	sli;
    XkbEventCauseRec	cause;
d3134 1
a3134 6
    dev = _XkbLookupKeyboard(stuff->deviceSpec,&why);
    if (!dev) {
	client->errorValue = _XkbErrCode2(why,stuff->deviceSpec);
	return XkbKeyboardErrorCode;
    }
    xkbi= dev->key->xkbInfo;
a3147 5
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,
						XkbXI_IndicatorMapsMask);
    if (!sli)
	return BadAlloc;

d3152 1
a3152 1
		register int n;
d3163 16
a3178 17
    for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
	if (stuff->which&bit) {
	    sli->maps[i].flags = from->flags;
	    sli->maps[i].which_groups = from->whichGroups;
	    sli->maps[i].groups = from->groups;
	    sli->maps[i].which_mods = from->whichMods;
	    sli->maps[i].mods.mask = from->mods;
	    sli->maps[i].mods.real_mods = from->mods;
	    sli->maps[i].mods.vmods= from->virtualMods;
	    sli->maps[i].ctrls = from->ctrls;
	    if (from->virtualMods!=0) {
		unsigned tmp;
		tmp= XkbMaskForVMask(xkbi->desc,from->virtualMods);
		sli->maps[i].mods.mask= from->mods|tmp;
	    }
	    from++;
	}
d3181 1
a3181 3
    XkbSetCauseXkbReq(&cause,X_kbSetIndicatorMap,client);
    XkbApplyLedMapChanges(dev,sli,stuff->which,NULL,NULL,&cause);
    return client->noClientException;
d3201 1
a3201 1
    CHK_LED_DEVICE(dev,stuff->deviceSpec);
d3267 10
a3276 2
int
ProcXkbSetNamedIndicator(ClientPtr client)
d3278 2
a3279 22
    DeviceIntPtr 		dev,kbd;
    XkbIndicatorMapPtr		map;
    XkbSrvLedInfoPtr 		sli;
    register int		led = 0;
    unsigned			extDevReason;
    unsigned			statec,namec,mapc;
    XkbEventCauseRec		cause;
    xkbExtensionDeviceNotify	ed;
    XkbChangesRec		changes;

    REQUEST(xkbSetNamedIndicatorReq);
    REQUEST_SIZE_MATCH(xkbSetNamedIndicatorReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_LED_DEVICE(dev,stuff->deviceSpec);
    CHK_ATOM_ONLY(stuff->indicator);
    CHK_MASK_LEGAL(0x10,stuff->whichGroups,XkbIM_UseAnyGroup);
    CHK_MASK_LEGAL(0x11,stuff->whichMods,XkbIM_UseAnyMods);

    extDevReason= 0;
d3281 2
a3282 7
    sli= XkbFindSrvLedInfo(dev,stuff->ledClass,stuff->ledID,
							XkbXI_IndicatorsMask);
    if (!sli)
	return BadAlloc;

    statec= mapc= namec= 0;
    map= NULL;
d3284 2
a3285 2
	for (led=0;(led<XkbNumIndicators)&&(map==NULL);led++) {
	    if (sli->names[led]==stuff->indicator) {
d3291 38
a3328 16
    if (map==NULL) {
	if (!stuff->createMap)
	    return client->noClientException;
	for (led=0,map=NULL;(led<XkbNumIndicators)&&(map==NULL);led++) {
	    if ((sli->names)&&(sli->maps)&&(sli->names[led]==None)&&
                (!XkbIM_InUse(&sli->maps[led]))) {
		map= &sli->maps[led];
		sli->names[led]= stuff->indicator;
		break;
	    }
	}
	if (map==NULL)
	    return client->noClientException;
	namec|= (1<<led);
	sli->namesPresent|= ((stuff->indicator!=None)?(1<<led):0);
	extDevReason|= XkbXI_IndicatorNamesMask;
d3331 40
d3372 16
a3387 14
	map->flags = stuff->flags;
	map->which_groups = stuff->whichGroups;
	map->groups = stuff->groups;
	map->which_mods = stuff->whichMods;
	map->mods.mask = stuff->realMods;
	map->mods.real_mods = stuff->realMods;
	map->mods.vmods= stuff->virtualMods;
	map->ctrls = stuff->ctrls;
	mapc|= (1<<led);
    }
    if ((stuff->setState)&&((map->flags&XkbIM_NoExplicit)==0)) {
	if (stuff->on)	sli->explicitState|=  (1<<led);
	else		sli->explicitState&= ~(1<<led);
	statec|= ((sli->effectiveState^sli->explicitState)&(1<<led));
d3389 1
d3394 1
a3394 1
	XkbApplyLedNameChanges(dev,sli,namec,&ed,&changes,&cause);
d3396 1
a3396 1
	XkbApplyLedMapChanges(dev,sli,mapc,&ed,&changes,&cause);
d3398 1
a3398 1
	XkbApplyLedStateChanges(dev,sli,statec,&ed,&changes,&cause);
d3400 1
a3400 1
    kbd= dev;
d3402 69
a3470 2
	kbd= (DeviceIntPtr)LookupKeyboardDevice();
    XkbFlushLedEvents(dev,kbd,sli,&ed,&changes,&cause);
d3636 1
a3636 1
    start = desc = (char *)ALLOCATE_LOCAL(length);
d3760 1
a3760 1
    DEALLOCATE_LOCAL((char *)start);
d3777 1
a3777 1
    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
d3835 291
a4125 3
	    return NULL;
	}
	wire++;
d4127 6
a4132 2
    return wire;
}
d4134 41
a4174 12
static Atom *
_XkbCopyMaskedAtoms(	Atom	*wire,
    			Atom	*dest,
			int   	 nAtoms,
			CARD32	 present)
{
register int i,bit;

    for (i=0,bit=1;(i<nAtoms)&&(present);i++,bit<<=1) {
	if ((present&bit)==0)
	    continue;
	dest[i]= *wire++;
d4176 1
a4176 13
    return wire;
}

static Bool
_XkbCheckTypeName(Atom name,int typeNdx)
{
char *	str;

    str= NameForAtom(name);
    if ((strcmp(str,"ONE_LEVEL")==0)||(strcmp(str,"TWO_LEVEL")==0)||
	(strcmp(str,"ALPHABETIC")==0)||(strcmp(str,"KEYPAD")==0))
	return False;
    return True;
a4182 3
    XkbDescRec		*xkb;
    XkbNamesRec		*names;
    xkbNamesNotify	 nn;
d4184 2
a4185 1
    Atom		 bad;
d4193 1
a4193 1
    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
d4196 1
a4196 2
    xkb = dev->key->xkbInfo->desc;
    names = xkb->names;
d4241 23
a4263 133
    if (stuff->which&XkbKeyTypeNamesMask) {
	register int i;
	CARD32	*old;
	if ( stuff->nTypes<1 ) {
	    client->errorValue = _XkbErrCode2(0x02,stuff->nTypes);
	    return BadValue;
	}
	if ((unsigned)(stuff->firstType+stuff->nTypes-1)>=xkb->map->num_types) {
	    client->errorValue = _XkbErrCode4(0x03,stuff->firstType,
							stuff->nTypes,
							xkb->map->num_types);
	    return BadValue;
	}
	if (((unsigned)stuff->firstType)<=XkbLastRequiredType) {
	    client->errorValue = _XkbErrCode2(0x04,stuff->firstType);
	    return BadAccess;
	}
	old= tmp;
	tmp= _XkbCheckAtoms(tmp,stuff->nTypes,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue= bad;
	    return BadAtom;
	}
	for (i=0;i<stuff->nTypes;i++,old++) {
	    if (!_XkbCheckTypeName((Atom)*old,stuff->firstType+i))
		client->errorValue= _XkbErrCode2(0x05,i);
	}
    }
    if (stuff->which&XkbKTLevelNamesMask) {
	register unsigned i;
	XkbKeyTypePtr	type;
	CARD8 *		width;
	if ( stuff->nKTLevels<1 ) {
	    client->errorValue = _XkbErrCode2(0x05,stuff->nKTLevels);
	    return BadValue;
	}
	if ((unsigned)(stuff->firstKTLevel+stuff->nKTLevels-1)>=
							xkb->map->num_types) {
	    client->errorValue = _XkbErrCode4(0x06,stuff->firstKTLevel,
				stuff->nKTLevels,xkb->map->num_types);
	    return BadValue;
	}
	width = (CARD8 *)tmp;
	tmp= (CARD32 *)(((char *)tmp)+XkbPaddedSize(stuff->nKTLevels));
	type = &xkb->map->types[stuff->firstKTLevel];
	for (i=0;i<stuff->nKTLevels;i++,type++) {
	    if (width[i]==0)
		continue;
	    else if (width[i]!=type->num_levels) {
		client->errorValue= _XkbErrCode4(0x07,i+stuff->firstKTLevel,
						type->num_levels,width[i]);
		return BadMatch;
	    }
	    tmp= _XkbCheckAtoms(tmp,width[i],client->swapped,&bad);
	    if (!tmp) {
		client->errorValue= bad;
		return BadAtom;
	    }
	}
    }
    if (stuff->which&XkbIndicatorNamesMask) {
	if (stuff->indicators==0) {
	    client->errorValue= 0x08;
	    return BadMatch;
	}
	tmp= _XkbCheckMaskedAtoms(tmp,XkbNumIndicators,stuff->indicators,
							client->swapped,&bad);
	if (!tmp) {
	    client->errorValue= bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbVirtualModNamesMask) {
	if (stuff->virtualMods==0) {
	    client->errorValue= 0x09;
	    return BadMatch;
	}
	tmp= _XkbCheckMaskedAtoms(tmp,XkbNumVirtualMods,
						(CARD32)stuff->virtualMods,
						client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbGroupNamesMask) {
	if (stuff->groupNames==0) {
	    client->errorValue= 0x0a;
	    return BadMatch;
	}
	tmp= _XkbCheckMaskedAtoms(tmp,XkbNumKbdGroups,
						(CARD32)stuff->groupNames,
						client->swapped,&bad);
	if (!tmp) {
	    client->errorValue = bad;
	    return BadAtom;
	}
    }
    if (stuff->which&XkbKeyNamesMask) {
	if (stuff->firstKey<(unsigned)xkb->min_key_code) {
	    client->errorValue= _XkbErrCode3(0x0b,xkb->min_key_code,
							stuff->firstKey);
	    return BadValue;
	}
	if (((unsigned)(stuff->firstKey+stuff->nKeys-1)>xkb->max_key_code)||
							(stuff->nKeys<1)) {
	    client->errorValue= _XkbErrCode4(0x0c,xkb->max_key_code,
						stuff->firstKey,stuff->nKeys);
	    return BadValue;
	}
	tmp+= stuff->nKeys;
    }
    if ((stuff->which&XkbKeyAliasesMask)&&(stuff->nKeyAliases>0)) {
	tmp+= stuff->nKeyAliases*2;
    }
    if (stuff->which&XkbRGNamesMask) {
	if ( stuff->nRadioGroups<1 ) {
	    client->errorValue= _XkbErrCode2(0x0d,stuff->nRadioGroups);
	    return BadValue;
	}
	tmp= _XkbCheckAtoms(tmp,stuff->nRadioGroups,client->swapped,&bad);
	if (!tmp) {
	    client->errorValue= bad;
	    return BadAtom;
	}
    }
    if ((tmp-((CARD32 *)stuff))!=stuff->length) {
	client->errorValue = stuff->length;
	return BadLength;
    }
    if (XkbAllocNames(xkb,stuff->which,stuff->nRadioGroups,
					stuff->nKeyAliases)!=Success) {
	return BadAlloc;
a4266 18
    bzero(&nn,sizeof(xkbNamesNotify));
    nn.changed= stuff->which;
    tmp = (CARD32 *)&stuff[1];
    if (stuff->which&XkbKeycodesNameMask)
	names->keycodes= *tmp++;
    if (stuff->which&XkbGeometryNameMask)
	names->geometry= *tmp++;
    if (stuff->which&XkbSymbolsNameMask)
	names->symbols= *tmp++;
    if (stuff->which&XkbPhysSymbolsNameMask)
	names->phys_symbols= *tmp++;
    if (stuff->which&XkbTypesNameMask)
	names->types= *tmp++;
    if (stuff->which&XkbCompatNameMask) 
	names->compat= *tmp++;
    if ((stuff->which&XkbKeyTypeNamesMask)&&(stuff->nTypes>0)) {
	register unsigned i;
	register XkbKeyTypePtr type;
d4268 17
a4284 6
	type= &xkb->map->types[stuff->firstType];
	for (i=0;i<stuff->nTypes;i++,type++) {
	    type->name= *tmp++;
	}
	nn.firstType= stuff->firstType;
	nn.nTypes= stuff->nTypes;
a4285 66
    if (stuff->which&XkbKTLevelNamesMask) {
	register XkbKeyTypePtr	type;
	register unsigned i;
	CARD8 *width;

	width = (CARD8 *)tmp;
	tmp= (CARD32 *)(((char *)tmp)+XkbPaddedSize(stuff->nKTLevels));
	type= &xkb->map->types[stuff->firstKTLevel];
	for (i=0;i<stuff->nKTLevels;i++,type++) {
	    if (width[i]>0) {
		if (type->level_names) {
		    register unsigned n;
		    for (n=0;n<width[i];n++) {
			type->level_names[n]= tmp[n];
		    }
		}
		tmp+= width[i];
	    }
	}
	nn.firstLevelName= 0;
	nn.nLevelNames= stuff->nTypes;
    }
    if (stuff->which&XkbIndicatorNamesMask) {
	tmp= _XkbCopyMaskedAtoms(tmp,names->indicators,XkbNumIndicators,
							stuff->indicators);
	nn.changedIndicators= stuff->indicators;
    }
    if (stuff->which&XkbVirtualModNamesMask) {
	tmp= _XkbCopyMaskedAtoms(tmp,names->vmods,XkbNumVirtualMods,
							stuff->virtualMods);
	nn.changedVirtualMods= stuff->virtualMods;
    }
    if (stuff->which&XkbGroupNamesMask) {
	tmp= _XkbCopyMaskedAtoms(tmp,names->groups,XkbNumKbdGroups,
							stuff->groupNames);
	nn.changedVirtualMods= stuff->groupNames;
    }
    if (stuff->which&XkbKeyNamesMask) {
	memcpy((char*)&names->keys[stuff->firstKey],(char *)tmp,
						stuff->nKeys*XkbKeyNameLength);
	tmp+= stuff->nKeys;
	nn.firstKey= stuff->firstKey;
	nn.nKeys= stuff->nKeys;
    }
    if (stuff->which&XkbKeyAliasesMask) {
	if (stuff->nKeyAliases>0) {
	    register int na= stuff->nKeyAliases;	
	    if (XkbAllocNames(xkb,XkbKeyAliasesMask,0,na)!=Success)
		return BadAlloc;
	    memcpy((char *)names->key_aliases,(char *)tmp,
				stuff->nKeyAliases*sizeof(XkbKeyAliasRec));
	    tmp+= stuff->nKeyAliases*2;
	}
	else if (names->key_aliases!=NULL) {
	    _XkbFree(names->key_aliases);
	    names->key_aliases= NULL;
	    names->num_key_aliases= 0;
	}
	nn.nAliases= names->num_key_aliases;
    }
    if (stuff->which&XkbRGNamesMask) {
	if (stuff->nRadioGroups>0) {
	    register unsigned i,nrg;
	    nrg= stuff->nRadioGroups;
	    if (XkbAllocNames(xkb,XkbRGNamesMask,nrg,0)!=Success)
		return BadAlloc;
d4287 1
a4287 21
	    for (i=0;i<stuff->nRadioGroups;i++) {
		names->radio_groups[i]= tmp[i];
	    }
	    tmp+= stuff->nRadioGroups;
	}
	else if (names->radio_groups) {
	    _XkbFree(names->radio_groups);
	    names->radio_groups= NULL;
	    names->num_rg= 0;
	}
	nn.nRadioGroups= names->num_rg;
    }
    if (nn.changed) {
	Bool needExtEvent;
	needExtEvent= (nn.changed&XkbIndicatorNamesMask)!=0;
	XkbSendNamesNotify(dev,&nn);
	if (needExtEvent) {
	    XkbSrvLedInfoPtr		sli;
	    xkbExtensionDeviceNotify	edev;
	    register int		i;
	    register unsigned		bit;
a4288 20
	    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,
							XkbXI_IndicatorsMask);
	    sli->namesPresent= 0;
	    for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
		if (names->indicators[i]!=None)
		    sli->namesPresent|= bit;
	    }
	    bzero(&edev,sizeof(xkbExtensionDeviceNotify));
	    edev.reason=	XkbXI_IndicatorNamesMask;
	    edev.ledClass=	KbdFeedbackClass;
	    edev.ledID=		dev->kbdfeed->ctrl.id;
	    edev.ledsDefined= 	sli->namesPresent|sli->mapsPresent;
	    edev.ledState=	sli->effectiveState;
	    edev.firstBtn=	0;
	    edev.nBtns=		0;
	    edev.supported=	XkbXI_AllFeaturesMask;
	    edev.unsupported=	0;
	    XkbSendExtensionDeviceNotify(dev,client,&edev);
	}
    }
d4294 1
a4294 1
#include <X11/extensions/XKBgeom.h>
d4740 1
a4740 1
	start= desc= (char *)ALLOCATE_LOCAL(len);
d4784 1
a4784 1
	DEALLOCATE_LOCAL((char *)start);
d4805 1
a4805 1
    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
d5250 2
a5251 2
int
ProcXkbSetGeometry(ClientPtr client)
d5253 3
a5255 1
    DeviceIntPtr 	dev;
a5258 12
    XkbDescPtr		xkb;
    Bool		new_name;
    xkbNewKeyboardNotify	nkn;

    REQUEST(xkbSetGeometryReq);
    REQUEST_AT_LEAST_SIZE(xkbSetGeometryReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
    CHK_ATOM_OR_NONE(stuff->name);
d5264 1
a5264 1
    sizes.which= 		XkbGeomAllMask;
d5266 4
a5269 4
    sizes.num_colors=	  	stuff->nColors;
    sizes.num_shapes=	  	stuff->nShapes;
    sizes.num_sections=	  	stuff->nSections;
    sizes.num_doodads=	  	stuff->nDoodads;
d5272 2
a5273 2
	xkb->geom= old;
	return status;
d5280 3
a5282 3
	XkbFreeGeometry(geom,XkbGeomAllMask,True);
	xkb->geom= old;
	return status;
d5287 1
a5287 1
    	XkbFreeGeometry(old,XkbGeomAllMask,True);
d5289 4
a5292 4
	xkbNamesNotify	nn;
	bzero(&nn,sizeof(xkbNamesNotify));
	nn.changed= XkbGeometryNameMask;
	XkbSendNamesNotify(dev,&nn);
d5304 36
d5348 1
d5356 1
a5356 1
    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
d5492 1
a5492 1
    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
d5557 1
a5557 1
    XkbFileInfo			finfo;
d5565 1
a5565 1
    XkbDescPtr			xkb;
d5572 3
d5582 1
a5582 1
    CHK_KBD_DEVICE(dev,stuff->deviceSpec);
d5605 14
a5618 19
    if (!names.keymap) {
	if ((!names.compat)&&
    		(fwant&(XkbGBN_CompatMapMask|XkbGBN_IndicatorMapMask))) {
	    names.compat= _XkbDupString("%");
	}
	if ((!names.types)&&(fwant&(XkbGBN_TypesMask))) {
	    names.types= _XkbDupString("%");
	}
	if ((!names.symbols)&&(fwant&XkbGBN_SymbolsMask)) {
	    names.symbols= _XkbDupString("%");
	}
	geom_changed= ((names.geometry!=NULL)&&(strcmp(names.geometry,"%")!=0));
	if ((!names.geometry)&&(fwant&XkbGBN_GeometryMask)) {
	    names.geometry= _XkbDupString("%");
	    geom_changed= False;
	}
    }
    else {
	geom_changed= True;
d5640 4
a5643 2
    rep.found = XkbDDXLoadKeymapByNames(dev,&names,fwant,fneed,&finfo,
							mapFile,PATH_MAX);
d5648 1
a5648 1
    if (finfo.xkb==NULL)
d5654 1
a5654 1
		((rep.reported&XkbGBN_SymbolsMask) && (finfo.xkb->compat))) {
d5657 2
a5658 2
	    XkbUpdateDescActions(finfo.xkb,
			finfo.xkb->min_key_code,XkbNumKeys(finfo.xkb),
d5662 1
a5662 1
	if (finfo.xkb->map==NULL)
d5669 2
a5670 2
	    mrep.minKeyCode = finfo.xkb->min_key_code;
	    mrep.maxKeyCode = finfo.xkb->max_key_code;
d5678 1
a5678 1
		mrep.nTypes = mrep.totalTypes= finfo.xkb->map->num_types;
d5686 2
a5687 2
		mrep.firstKeySym = mrep.firstModMapKey= finfo.xkb->min_key_code;
		mrep.nKeySyms = mrep.nModMapKeys= XkbNumKeys(finfo.xkb);
d5697 1
a5697 1
			mrep.firstKeyExplicit = finfo.xkb->min_key_code;
d5699 1
a5699 1
			mrep.nKeyExplicit = XkbNumKeys(finfo.xkb);
d5707 1
a5707 1
	    XkbComputeGetMapReplySize(finfo.xkb,&mrep);
d5710 1
a5710 1
	if (finfo.xkb->compat==NULL)
d5719 2
a5720 2
	    crep.nSI= crep.nTotalSI= finfo.xkb->compat->num_si;
	    XkbComputeGetCompatMapReplySize(finfo.xkb->compat,&crep);
d5723 1
a5723 1
	if (finfo.xkb->indicators==NULL)
d5731 1
a5731 1
	    XkbComputeGetIndicatorMapReplySize(finfo.xkb->indicators,&irep);
d5734 1
a5734 1
	if (finfo.xkb->names==NULL)
d5741 2
a5742 2
	    nrep.minKeyCode= finfo.xkb->min_key_code;
	    nrep.maxKeyCode= finfo.xkb->max_key_code;
d5745 2
a5746 2
		if (finfo.xkb->map!=NULL)
		     nrep.nTypes= finfo.xkb->map->num_types;
d5752 1
a5752 1
		nrep.nRadioGroups= finfo.xkb->names->num_rg;
d5765 3
a5767 3
		nrep.firstKey= finfo.xkb->min_key_code;
		nrep.nKeys= XkbNumKeys(finfo.xkb);
		nrep.nKeyAliases= finfo.xkb->names->num_key_aliases;
d5776 1
a5776 1
	    XkbComputeGetNamesReplySize(finfo.xkb,&nrep);
d5779 1
a5779 1
	if (finfo.xkb->geom==NULL)
d5792 1
a5792 1
	    XkbComputeGetGeometryReplySize(finfo.xkb->geom,&grep,None);
d5807 1
a5807 1
	XkbSendMap(client,finfo.xkb,&mrep);
d5809 1
a5809 1
	XkbSendCompatMap(client,finfo.xkb->compat,&crep);
d5811 1
a5811 1
	XkbSendIndicatorMap(client,finfo.xkb->indicators,&irep);
d5813 1
a5813 1
	XkbSendNames(client,finfo.xkb,&nrep);
d5815 1
a5815 1
	XkbSendGeometry(client,finfo.xkb->geom,&grep,False);
d5821 1
a5821 1
	xkb= finfo.xkb;
d5823 1
a5823 1
	finfo.xkb= old_xkb; /* so it'll get freed automatically */
d5838 23
a5860 12
	memcpy(dev->key->modifierMap,xkb->map->modmap,xkb->max_key_code+1);
	XkbUpdateCoreDescription(dev,True);

	if (dev->kbdfeed && dev->kbdfeed->xkb_sli) {
            XkbSrvLedInfoPtr	old_sli;
            XkbSrvLedInfoPtr	sli;
            old_sli = dev->kbdfeed->xkb_sli;
            dev->kbdfeed->xkb_sli = NULL;
	    sli = XkbAllocSrvLedInfo(dev,dev->kbdfeed,NULL,0);
            if (sli) {
               sli->explicitState = old_sli->explicitState;
               sli->effectiveState = old_sli->effectiveState;
d5862 1
a5862 3
            dev->kbdfeed->xkb_sli = sli;
	    XkbFreeSrvLedInfo(old_sli);
	}
d5864 2
d5867 2
a5868 2
	nkn.minKeyCode= finfo.xkb->min_key_code;
	nkn.maxKeyCode= finfo.xkb->max_key_code;
d5878 3
a5880 3
    if ((finfo.xkb!=NULL)&&(finfo.xkb!=xkb)) {
	XkbFreeKeyboard(finfo.xkb,XkbAllComponentsMask,True);
	finfo.xkb= NULL;
d6111 1
a6111 1
    CHK_ANY_DEVICE(dev,stuff->deviceSpec);
a6117 1
    wanted&= ~XkbXI_KeyboardsMask;
d6126 2
a6127 2
    rep.supported = XkbXI_AllDeviceFeaturesMask&(~XkbXI_KeyboardsMask);
    rep.unsupported = XkbXI_KeyboardsMask;
d6205 1
a6205 1
    str= (char*) ALLOCATE_LOCAL(nameLen);
d6210 1
a6210 1
    DEALLOCATE_LOCAL(str);
a6226 1
#ifdef DEBUG
a6228 1
#endif
d6413 1
a6413 1
	    kbd= (DeviceIntPtr)LookupKeyboardDevice();
d6421 4
a6424 2
int
ProcXkbSetDeviceInfo(ClientPtr client)
d6426 1
a6426 15
DeviceIntPtr		dev;
unsigned		change;
char *			wire;
xkbExtensionDeviceNotify ed;

    REQUEST(xkbSetDeviceInfoReq);
    REQUEST_AT_LEAST_SIZE(xkbSetDeviceInfoReq);

    if (!(client->xkbClientFlags&_XkbClientInitialized))
	return BadAccess;

    change= stuff->change;

    CHK_ANY_DEVICE(dev,stuff->deviceSpec);
    CHK_MASK_LEGAL(0x01,change,(XkbXI_AllFeaturesMask&(~XkbXI_KeyboardsMask)));
d6429 1
a6429 1
    if (change&XkbXI_ButtonActionsMask) {
d6451 10
d6464 1
a6464 1
    if (change&XkbXI_ButtonActionsMask) {
d6485 1
a6485 1
	else		kbd= (DeviceIntPtr)LookupKeyboardDevice();
d6494 2
a6495 2
	wire= SetDeviceIndicators(wire,dev,change,stuff->nDeviceLedFBs,
							&status,client,&ed);
d6501 68
d6579 1
d6583 4
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d39 1
a39 1
#include <xkbsrv.h>
d46 1
a46 1
static	int	XkbErrorBase;
d48 4
a51 1
static  int	XkbKeyboardErrorCode;
d53 1
a53 1
static CARD32	xkbDebugCtrls = 0;
d55 1
a55 1
static RESTYPE	RT_XKBCLIENT;
a349 1
/* FIXME: Needs to ding on all core-sending devices. */
d537 1
a537 1
    DeviceIntPtr dev, tmpd;
a539 2
    xkbStateNotify sn;
    XkbEventCauseRec cause;
d544 1
a544 1
    if (!(client->xkbClientFlags & _XkbClientInitialized))
d547 3
a549 3
    CHK_KBD_DEVICE(dev, stuff->deviceSpec);
    CHK_MASK_MATCH(0x01, stuff->affectModLocks, stuff->modLocks);
    CHK_MASK_MATCH(0x01, stuff->affectModLatches, stuff->modLatches);
d552 12
d565 21
a585 41
    for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) {
        if ((dev == inputInfo.keyboard && tmpd->key && tmpd->coreEvents) ||
            tmpd == dev) {
            if (!tmpd->key->xkbInfo)
                continue;

            oldState = tmpd->key->xkbInfo->state;
            newState = &tmpd->key->xkbInfo->state;
            if (stuff->affectModLocks) {
                newState->locked_mods &= ~stuff->affectModLocks;
                newState->locked_mods |= (stuff->affectModLocks & stuff->modLocks);
            }
            if (status == Success && stuff->lockGroup)
                newState->locked_group = stuff->groupLock;
            if (status == Success && stuff->affectModLatches)
                status = XkbLatchModifiers(tmpd, stuff->affectModLatches,
                                           stuff->modLatches);
            if (status == Success && stuff->latchGroup)
                status = XkbLatchGroup(tmpd, stuff->groupLatch);

            if (status != Success)
                return status;

            XkbComputeDerivedState(tmpd->key->xkbInfo);
            tmpd->key->state = XkbStateFieldFromRec(newState);

            changed = XkbStateChangedFlags(&oldState, newState);
            if (changed) {
                sn.keycode = 0;
                sn.eventType = 0;
                sn.requestMajor = XkbReqCode;
                sn.requestMinor = X_kbLatchLockState;
                sn.changed = changed;
                XkbSendStateNotify(tmpd, &sn);
                changed = XkbIndicatorsToUpdate(tmpd, changed, False);
                if (changed) {
                    XkbSetCauseXkbReq(&cause, X_kbLatchLockState, client);
                    XkbUpdateIndicators(tmpd, changed, True, NULL, &cause);
	        }
            }
        }
a586 1

d669 1
a669 1
    DeviceIntPtr 	dev, tmpd;
d680 1
a680 1
    if (!(client->xkbClientFlags & _XkbClientInitialized))
d683 2
a684 2
    CHK_KBD_DEVICE(dev, stuff->deviceSpec);
    CHK_MASK_LEGAL(0x01, stuff->changeCtrls, XkbAllControlsMask);
d686 108
a793 25
    for (tmpd = inputInfo.keyboard; tmpd; tmpd = tmpd->next) {
        if ((dev == inputInfo.keyboard && tmpd->key && tmpd->coreEvents) ||
            tmpd == dev) {

            xkbi = tmpd->key->xkbInfo;
            ctrl = xkbi->desc->ctrls;
            new = *ctrl;
            XkbSetCauseXkbReq(&cause, X_kbSetControls, client);

            if (stuff->changeCtrls & XkbInternalModsMask) {
                CHK_MASK_MATCH(0x02, stuff->affectInternalMods,
                               stuff->internalMods);
                CHK_MASK_MATCH(0x03, stuff->affectInternalVMods,
                               stuff->internalVMods);

                new.internal.real_mods &= ~(stuff->affectInternalMods);
                new.internal.real_mods |= (stuff->affectInternalMods &
                                           stuff->internalMods);
                new.internal.vmods &= ~(stuff->affectInternalVMods);
                new.internal.vmods |= (stuff->affectInternalVMods &
                                       stuff->internalVMods);
                new.internal.mask = new.internal.real_mods |
                                    XkbMaskForVMask(xkbi->desc,
                                                    new.internal.vmods);
            }
d795 39
a833 16
            if (stuff->changeCtrls & XkbIgnoreLockModsMask) {
                CHK_MASK_MATCH(0x4, stuff->affectIgnoreLockMods,
                               stuff->ignoreLockMods);
                CHK_MASK_MATCH(0x5, stuff->affectIgnoreLockVMods,
                               stuff->ignoreLockVMods);

                new.ignore_lock.real_mods &= ~(stuff->affectIgnoreLockMods);
                new.ignore_lock.real_mods |= (stuff->affectIgnoreLockMods &
                                              stuff->ignoreLockMods);
                new.ignore_lock.vmods &= ~(stuff->affectIgnoreLockVMods);
                new.ignore_lock.vmods |= (stuff->affectIgnoreLockVMods &
                                          stuff->ignoreLockVMods);
                new.ignore_lock.mask = new.ignore_lock.real_mods |
                                       XkbMaskForVMask(xkbi->desc,
                                                       new.ignore_lock.vmods);
            }
d835 5
a839 10
            CHK_MASK_MATCH(0x06, stuff->affectEnabledCtrls,
                           stuff->enabledCtrls);
            if (stuff->affectEnabledCtrls) {
                CHK_MASK_LEGAL(0x07, stuff->affectEnabledCtrls,
                               XkbAllBooleanCtrlsMask);

                new.enabled_ctrls &= ~(stuff->affectEnabledCtrls);
                new.enabled_ctrls |= (stuff->affectEnabledCtrls &
                                      stuff->enabledCtrls);
            }
d841 25
a865 6
            if (stuff->changeCtrls & XkbRepeatKeysMask) {
                if (stuff->repeatDelay < 1 || stuff->repeatInterval < 1) {
                    client->errorValue = _XkbErrCode3(0x08, stuff->repeatDelay,
                                                      stuff->repeatInterval);
                    return BadValue;
                }
d867 4
a870 3
                new.repeat_delay = stuff->repeatDelay;
                new.repeat_interval = stuff->repeatInterval;
            }
d872 6
a877 133
            if (stuff->changeCtrls & XkbSlowKeysMask) {
                if (stuff->slowKeysDelay < 1) {
                    client->errorValue = _XkbErrCode2(0x09,
                                                      stuff->slowKeysDelay);
                    return BadValue;
                }

                new.slow_keys_delay = stuff->slowKeysDelay;
            }

            if (stuff->changeCtrls & XkbBounceKeysMask) {
                if (stuff->debounceDelay < 1) {
                    client->errorValue = _XkbErrCode2(0x0A,
                                                      stuff->debounceDelay);
                    return BadValue;
                }

                new.debounce_delay = stuff->debounceDelay;
            }

            if (stuff->changeCtrls & XkbMouseKeysMask) {
                if (stuff->mkDfltBtn > XkbMaxMouseKeysBtn) {
                    client->errorValue = _XkbErrCode2(0x0B, stuff->mkDfltBtn);
                    return BadValue;
                }

                new.mk_dflt_btn = stuff->mkDfltBtn;
            }

            if (stuff->changeCtrls & XkbMouseKeysAccelMask) {
                if (stuff->mkDelay < 1 || stuff->mkInterval < 1 ||
                    stuff->mkTimeToMax < 1 || stuff->mkMaxSpeed < 1 ||
                    stuff->mkCurve < -1000) {
                    client->errorValue = _XkbErrCode2(0x0C,0);
                    return BadValue;
                }

                new.mk_delay = stuff->mkDelay;
                new.mk_interval = stuff->mkInterval;
                new.mk_time_to_max = stuff->mkTimeToMax;
                new.mk_max_speed = stuff->mkMaxSpeed;
                new.mk_curve = stuff->mkCurve;
                AccessXComputeCurveFactor(xkbi, &new);
            }

            if (stuff->changeCtrls & XkbGroupsWrapMask) {
                unsigned act, num;

                act = XkbOutOfRangeGroupAction(stuff->groupsWrap);
                switch (act) {
                case XkbRedirectIntoRange:
                    num = XkbOutOfRangeGroupNumber(stuff->groupsWrap);
                    if (num >= new.num_groups) {
                        client->errorValue = _XkbErrCode3(0x0D, new.num_groups,
                                                          num);
                        return BadValue;
                    }
                case XkbWrapIntoRange:
                case XkbClampIntoRange:
                    break;
                default:
                    client->errorValue = _XkbErrCode2(0x0E, act);
                    return BadValue;
                }

                new.groups_wrap= stuff->groupsWrap;
            }

            CHK_MASK_LEGAL(0x0F, stuff->axOptions, XkbAX_AllOptionsMask);
            if (stuff->changeCtrls & XkbAccessXKeysMask) {
                new.ax_options = stuff->axOptions & XkbAX_AllOptionsMask;
            }
            else {
                if (stuff->changeCtrls & XkbStickyKeysMask) {
                    new.ax_options &= ~(XkbAX_SKOptionsMask);
                    new.ax_options |= (stuff->axOptions & XkbAX_SKOptionsMask);
                }
            
                if (stuff->changeCtrls & XkbAccessXFeedbackMask) {
                    new.ax_options &= ~(XkbAX_FBOptionsMask);
                    new.ax_options |= (stuff->axOptions & XkbAX_FBOptionsMask);
                }
            }

            if (stuff->changeCtrls & XkbAccessXTimeoutMask) {
                if (stuff->axTimeout < 1) {
                    client->errorValue = _XkbErrCode2(0x10, stuff->axTimeout);
                    return BadValue;
                }
                CHK_MASK_MATCH(0x11, stuff->axtCtrlsMask,
                               stuff->axtCtrlsValues);
                CHK_MASK_LEGAL(0x12, stuff->axtCtrlsMask,
                               XkbAllBooleanCtrlsMask);
                CHK_MASK_MATCH(0x13, stuff->axtOptsMask, stuff->axtOptsValues);
                CHK_MASK_LEGAL(0x14, stuff->axtOptsMask, XkbAX_AllOptionsMask);
                new.ax_timeout = stuff->axTimeout;
                new.axt_ctrls_mask = stuff->axtCtrlsMask;
                new.axt_ctrls_values = (stuff->axtCtrlsValues &
                                        stuff->axtCtrlsMask);
                new.axt_opts_mask = stuff->axtOptsMask;
                new.axt_opts_values = (stuff->axtOptsValues &
                                       stuff->axtOptsMask);
            }

            if (stuff->changeCtrls & XkbPerKeyRepeatMask)
                memcpy(new.per_key_repeat, stuff->perKeyRepeat,
                       XkbPerKeyBitArraySize);

            old= *ctrl;
            *ctrl= new;
            XkbDDXChangeControls(tmpd, &old, ctrl);

            if (XkbComputeControlsNotify(tmpd, &old, ctrl, &cn, False)) {
                cn.keycode = 0;
                cn.eventType = 0;
                cn.requestMajor = XkbReqCode;
                cn.requestMinor = X_kbSetControls;
                XkbSendControlsNotify(tmpd, &cn);
            }

            sli = XkbFindSrvLedInfo(tmpd, XkbDfltXIClass, XkbDfltXIId, 0);
            if (sli)
                XkbUpdateIndicators(tmpd, sli->usesControls, True, NULL,
                                    &cause);

            /* If sticky keys were disabled, clear all locks and latches */
            if ((old.enabled_ctrls & XkbStickyKeysMask) &&
                !(ctrl->enabled_ctrls & XkbStickyKeysMask))
                XkbClearAllLatchesAndLocks(tmpd, xkbi, True, &cause);
        }
    }

    return client->noClientException;
d1264 1
a1264 1
    for (i=0;i<rep->nVModMapKeys-1;i++,pMap++) {
a2265 1
/* FIXME: Needs to set map on all core-sending devices. */
a2581 1
/* FIXME: Needs to set compat map on all core-sending devices. */
d2757 1
a2757 1
static Status
d2774 1
a2774 1
static int
a2858 1
/* FIXME: Needs to set indicator map on all core-sending devices. */
a3021 1
/* FIXME: Needs to set indicator on all core-sending devices. */
a3509 1
/* FIXME: Needs to set names on all core-sending devices. */
a4806 1
/* FIXME: Needs to set geom on all core-sending devices. */
a5086 1
    DeviceIntPtr                tmpd;
a5101 2
    XkbSrvLedInfoPtr            old_sli;
    XkbSrvLedInfoPtr            sli;
a5171 2

    /* We pass dev in here so we can get the old names out if needed. */
d5173 1
a5173 1
                                        mapFile,PATH_MAX);
d5368 12
a5379 23
        for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) {
            if (tmpd == dev ||
                (dev->id == inputInfo.keyboard->id && tmpd->key &&
                 tmpd->coreEvents)) {

                memcpy(tmpd->key->modifierMap, xkb->map->modmap,
                       xkb->max_key_code + 1);
                if (tmpd != dev)
                    XkbCopyKeymap(dev->key->xkbInfo->desc,
                                  tmpd->key->xkbInfo->desc, True);
                XkbUpdateCoreDescription(tmpd, True);

                if (tmpd->kbdfeed && tmpd->kbdfeed->xkb_sli) {
                    old_sli = tmpd->kbdfeed->xkb_sli;
                    tmpd->kbdfeed->xkb_sli = NULL;
                    sli = XkbAllocSrvLedInfo(tmpd, tmpd->kbdfeed, NULL, 0);
                    if (sli) {
                        sli->explicitState = old_sli->explicitState;
                        sli->effectiveState = old_sli->effectiveState;
                    }
                    tmpd->kbdfeed->xkb_sli = sli;
                    XkbFreeSrvLedInfo(old_sli);
                }
d5381 3
a5383 1
        }
a5384 2
        /* this should be either a MN or an NKN, depending on whether or not
         * the keycode range changed? */
d5637 1
d5646 2
a5647 2
    rep.supported = XkbXI_AllDeviceFeaturesMask;
    rep.unsupported = 0;
a5942 1
/* FIXME: Needs to set info on all core-sending devices. */
d5960 1
a5960 1
    CHK_MASK_LEGAL(0x01,change,XkbXI_AllFeaturesMask);
@

