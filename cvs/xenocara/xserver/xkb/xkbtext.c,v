head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.8
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2013.06.07.17.28.56;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.32;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.34;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/************************************************************
 Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.

 Permission to use, copy, modify, and distribute this
 software and its documentation for any purpose and without
 fee is hereby granted, provided that the above copyright
 notice appear in all copies and that both that copyright
 notice and this permission notice appear in supporting
 documentation, and that the name of Silicon Graphics not be
 used in advertising or publicity pertaining to distribution
 of the software without specific prior written permission.
 Silicon Graphics makes no representation about the suitability
 of this software for any purpose. It is provided "as is"
 without any express or implied warranty.

 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
 THE USE OR PERFORMANCE OF THIS SOFTWARE.

 ********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

#include <X11/Xos.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XKMformat.h>
#include "misc.h"
#include "inputstr.h"
#include "dix.h"
#include "xkbstr.h"
#define XKBSRV_NEED_FILE_FUNCS	1
#include <xkbsrv.h>
#include "xkbgeom.h"

/***====================================================================***/

#define	BUFFER_SIZE	512

static char textBuffer[BUFFER_SIZE];
static int tbNext = 0;

static char *
tbGetBuffer(unsigned size)
{
    char *rtrn;

    if (size >= BUFFER_SIZE)
        return NULL;
    if ((BUFFER_SIZE - tbNext) <= size)
        tbNext = 0;
    rtrn = &textBuffer[tbNext];
    tbNext += size;
    return rtrn;
}

/***====================================================================***/

char *
XkbAtomText(Atom atm, unsigned format)
{
    const char *atmstr;
    char *rtrn, *tmp;

    atmstr = NameForAtom(atm);
    if (atmstr != NULL) {
        int len;

        len = strlen(atmstr) + 1;
        if (len > BUFFER_SIZE)
            len = BUFFER_SIZE - 2;
        rtrn = tbGetBuffer(len);
        strlcpy(rtrn, atmstr, len);
    }
    else {
        rtrn = tbGetBuffer(1);
        rtrn[0] = '\0';
    }
    if (format == XkbCFile) {
        for (tmp = rtrn; *tmp != '\0'; tmp++) {
            if ((tmp == rtrn) && (!isalpha(*tmp)))
                *tmp = '_';
            else if (!isalnum(*tmp))
                *tmp = '_';
        }
    }
    return XkbStringText(rtrn, format);
}

/***====================================================================***/

char *
XkbVModIndexText(XkbDescPtr xkb, unsigned ndx, unsigned format)
{
    register int len;
    register Atom *vmodNames;
    char *rtrn;
    const char *tmp;
    char numBuf[20];

    if (xkb && xkb->names)
        vmodNames = xkb->names->vmods;
    else
        vmodNames = NULL;

    tmp = NULL;
    if (ndx >= XkbNumVirtualMods)
        tmp = "illegal";
    else if (vmodNames && (vmodNames[ndx] != None))
        tmp = NameForAtom(vmodNames[ndx]);
    if (tmp == NULL) {
        snprintf(numBuf, sizeof(numBuf), "%d", ndx);
        tmp = numBuf;
    }

    len = strlen(tmp) + 1;
    if (format == XkbCFile)
        len += 4;
    if (len >= BUFFER_SIZE)
        len = BUFFER_SIZE - 1;
    rtrn = tbGetBuffer(len);
    if (format == XkbCFile) {
        strcpy(rtrn, "vmod_");
        strncpy(&rtrn[5], tmp, len - 4);
    }
    else
        strncpy(rtrn, tmp, len);
    return rtrn;
}

char *
XkbVModMaskText(XkbDescPtr xkb,
                unsigned modMask, unsigned mask, unsigned format)
{
    register int i, bit;
    int len;
    char *mm, *rtrn;
    char *str, buf[BUFFER_SIZE];

    if ((modMask == 0) && (mask == 0)) {
        rtrn = tbGetBuffer(5);
        if (format == XkbCFile)
            snprintf(rtrn, 5, "0");
        else
            snprintf(rtrn, 5, "none");
        return rtrn;
    }
    if (modMask != 0)
        mm = XkbModMaskText(modMask, format);
    else
        mm = NULL;

    str = buf;
    buf[0] = '\0';
    if (mask) {
        char *tmp;

        for (i = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) {
            if (mask & bit) {
                tmp = XkbVModIndexText(xkb, i, format);
                len = strlen(tmp) + 1 + (str == buf ? 0 : 1);
                if (format == XkbCFile)
                    len += 4;
                if ((str - (buf + len)) <= BUFFER_SIZE) {
                    if (str != buf) {
                        if (format == XkbCFile)
                            *str++ = '|';
                        else
                            *str++ = '+';
                        len--;
                    }
                }
                if (format == XkbCFile)
                    snprintf(str, BUFFER_SIZE - len, "%sMask", tmp);
                else
                    strcpy(str, tmp);
                str = &str[len - 1];
            }
        }
        str = buf;
    }
    else
        str = NULL;
    if (mm)
        len = strlen(mm);
    else
        len = 0;
    if (str)
        len += strlen(str) + (mm == NULL ? 0 : 1);
    if (len >= BUFFER_SIZE)
        len = BUFFER_SIZE - 1;
    rtrn = tbGetBuffer(len + 1);
    rtrn[0] = '\0';

    if (mm != NULL) {
        i = strlen(mm);
        if (i > len)
            i = len;
        strcpy(rtrn, mm);
    }
    else {
        i = 0;
    }
    if (str != NULL) {
        if (mm != NULL) {
            if (format == XkbCFile)
                strcat(rtrn, "|");
            else
                strcat(rtrn, "+");
        }
        strncat(rtrn, str, len - i);
    }
    rtrn[len] = '\0';
    return rtrn;
}

static const char *modNames[XkbNumModifiers] = {
    "Shift", "Lock", "Control", "Mod1", "Mod2", "Mod3", "Mod4", "Mod5"
};

char *
XkbModIndexText(unsigned ndx, unsigned format)
{
    char *rtrn;
    char buf[100];

    if (format == XkbCFile) {
        if (ndx < XkbNumModifiers)
            snprintf(buf, sizeof(buf), "%sMapIndex", modNames[ndx]);
        else if (ndx == XkbNoModifier)
            snprintf(buf, sizeof(buf), "XkbNoModifier");
        else
            snprintf(buf, sizeof(buf), "0x%02x", ndx);
    }
    else {
        if (ndx < XkbNumModifiers)
            strcpy(buf, modNames[ndx]);
        else if (ndx == XkbNoModifier)
            strcpy(buf, "none");
        else
            snprintf(buf, sizeof(buf), "ILLEGAL_%02x", ndx);
    }
    rtrn = tbGetBuffer(strlen(buf) + 1);
    strcpy(rtrn, buf);
    return rtrn;
}

char *
XkbModMaskText(unsigned mask, unsigned format)
{
    register int i, bit;
    char buf[64], *rtrn;

    if ((mask & 0xff) == 0xff) {
        if (format == XkbCFile)
            strcpy(buf, "0xff");
        else
            strcpy(buf, "all");
    }
    else if ((mask & 0xff) == 0) {
        if (format == XkbCFile)
            strcpy(buf, "0");
        else
            strcpy(buf, "none");
    }
    else {
        char *str = buf;

        buf[0] = '\0';
        for (i = 0, bit = 1; i < XkbNumModifiers; i++, bit <<= 1) {
            if (mask & bit) {
                if (str != buf) {
                    if (format == XkbCFile)
                        *str++ = '|';
                    else
                        *str++ = '+';
                }
                strcpy(str, modNames[i]);
                str = &str[strlen(str)];
                if (format == XkbCFile) {
                    strcpy(str, "Mask");
                    str += 4;
                }
            }
        }
    }
    rtrn = tbGetBuffer(strlen(buf) + 1);
    strcpy(rtrn, buf);
    return rtrn;
}

/***====================================================================***/

 /*ARGSUSED*/ char *
XkbConfigText(unsigned config, unsigned format)
{
    static char *buf;

    buf = tbGetBuffer(32);
    switch (config) {
    case XkmSemanticsFile:
        strcpy(buf, "Semantics");
        break;
    case XkmLayoutFile:
        strcpy(buf, "Layout");
        break;
    case XkmKeymapFile:
        strcpy(buf, "Keymap");
        break;
    case XkmGeometryFile:
    case XkmGeometryIndex:
        strcpy(buf, "Geometry");
        break;
    case XkmTypesIndex:
        strcpy(buf, "Types");
        break;
    case XkmCompatMapIndex:
        strcpy(buf, "CompatMap");
        break;
    case XkmSymbolsIndex:
        strcpy(buf, "Symbols");
        break;
    case XkmIndicatorsIndex:
        strcpy(buf, "Indicators");
        break;
    case XkmKeyNamesIndex:
        strcpy(buf, "KeyNames");
        break;
    case XkmVirtualModsIndex:
        strcpy(buf, "VirtualMods");
        break;
    default:
        sprintf(buf, "unknown(%d)", config);
        break;
    }
    return buf;
}

/***====================================================================***/

char *
XkbKeysymText(KeySym sym, unsigned format)
{
    static char buf[32];

    if (sym == NoSymbol)
        strcpy(buf, "NoSymbol");
    else
        snprintf(buf, sizeof(buf), "0x%lx", (long) sym);
    return buf;
}

char *
XkbKeyNameText(char *name, unsigned format)
{
    char *buf;

    if (format == XkbCFile) {
        buf = tbGetBuffer(5);
        memcpy(buf, name, 4);
        buf[4] = '\0';
    }
    else {
        int len;

        buf = tbGetBuffer(7);
        buf[0] = '<';
        memcpy(&buf[1], name, 4);
        buf[5] = '\0';
        len = strlen(buf);
        buf[len++] = '>';
        buf[len] = '\0';
    }
    return buf;
}

/***====================================================================***/

static const char *siMatchText[5] = {
    "NoneOf", "AnyOfOrNone", "AnyOf", "AllOf", "Exactly"
};

const char *
XkbSIMatchText(unsigned type, unsigned format)
{
    static char buf[40];
    const char *rtrn;

    switch (type & XkbSI_OpMask) {
    case XkbSI_NoneOf:
        rtrn = siMatchText[0];
        break;
    case XkbSI_AnyOfOrNone:
        rtrn = siMatchText[1];
        break;
    case XkbSI_AnyOf:
        rtrn = siMatchText[2];
        break;
    case XkbSI_AllOf:
        rtrn = siMatchText[3];
        break;
    case XkbSI_Exactly:
        rtrn = siMatchText[4];
        break;
    default:
        snprintf(buf, sizeof(buf), "0x%x", type & XkbSI_OpMask);
        return buf;
    }
    if (format == XkbCFile) {
        if (type & XkbSI_LevelOneOnly)
            snprintf(buf, sizeof(buf), "XkbSI_LevelOneOnly|XkbSI_%s", rtrn);
        else
            snprintf(buf, sizeof(buf), "XkbSI_%s", rtrn);
        rtrn = buf;
    }
    return rtrn;
}

/***====================================================================***/

static const char *imWhichNames[] = {
    "base",
    "latched",
    "locked",
    "effective",
    "compat"
};

char *
XkbIMWhichStateMaskText(unsigned use_which, unsigned format)
{
    int len;
    unsigned i, bit, tmp;
    char *buf;

    if (use_which == 0) {
        buf = tbGetBuffer(2);
        strcpy(buf, "0");
        return buf;
    }
    tmp = use_which & XkbIM_UseAnyMods;
    for (len = i = 0, bit = 1; tmp != 0; i++, bit <<= 1) {
        if (tmp & bit) {
            tmp &= ~bit;
            len += strlen(imWhichNames[i]) + 1;
            if (format == XkbCFile)
                len += 9;
        }
    }
    buf = tbGetBuffer(len + 1);
    tmp = use_which & XkbIM_UseAnyMods;
    for (len = i = 0, bit = 1; tmp != 0; i++, bit <<= 1) {
        if (tmp & bit) {
            tmp &= ~bit;
            if (format == XkbCFile) {
                if (len != 0)
                    buf[len++] = '|';
                sprintf(&buf[len], "XkbIM_Use%s", imWhichNames[i]);
                buf[len + 9] = toupper(buf[len + 9]);
            }
            else {
                if (len != 0)
                    buf[len++] = '+';
                sprintf(&buf[len], "%s", imWhichNames[i]);
            }
            len += strlen(&buf[len]);
        }
    }
    return buf;
}

static const char *ctrlNames[] = {
    "repeatKeys",
    "slowKeys",
    "bounceKeys",
    "stickyKeys",
    "mouseKeys",
    "mouseKeysAccel",
    "accessXKeys",
    "accessXTimeout",
    "accessXFeedback",
    "audibleBell",
    "overlay1",
    "overlay2",
    "ignoreGroupLock"
};

char *
XkbControlsMaskText(unsigned ctrls, unsigned format)
{
    int len;
    unsigned i, bit, tmp;
    char *buf;

    if (ctrls == 0) {
        buf = tbGetBuffer(5);
        if (format == XkbCFile)
            strcpy(buf, "0");
        else
            strcpy(buf, "none");
        return buf;
    }
    tmp = ctrls & XkbAllBooleanCtrlsMask;
    for (len = i = 0, bit = 1; tmp != 0; i++, bit <<= 1) {
        if (tmp & bit) {
            tmp &= ~bit;
            len += strlen(ctrlNames[i]) + 1;
            if (format == XkbCFile)
                len += 7;
        }
    }
    buf = tbGetBuffer(len + 1);
    tmp = ctrls & XkbAllBooleanCtrlsMask;
    for (len = i = 0, bit = 1; tmp != 0; i++, bit <<= 1) {
        if (tmp & bit) {
            tmp &= ~bit;
            if (format == XkbCFile) {
                if (len != 0)
                    buf[len++] = '|';
                sprintf(&buf[len], "Xkb%sMask", ctrlNames[i]);
                buf[len + 3] = toupper(buf[len + 3]);
            }
            else {
                if (len != 0)
                    buf[len++] = '+';
                sprintf(&buf[len], "%s", ctrlNames[i]);
            }
            len += strlen(&buf[len]);
        }
    }
    return buf;
}

/***====================================================================***/

char *
XkbStringText(char *str, unsigned format)
{
    char *buf;
    register char *in, *out;
    int len;
    Bool ok;

    if (str == NULL) {
        buf = tbGetBuffer(2);
        buf[0] = '\0';
        return buf;
    }
    else if (format == XkbXKMFile)
        return str;
    for (ok = TRUE, len = 0, in = str; *in != '\0'; in++, len++) {
        if (!isprint(*in)) {
            ok = FALSE;
            switch (*in) {
            case '\n':
            case '\t':
            case '\v':
            case '\b':
            case '\r':
            case '\f':
                len++;
                break;
            default:
                len += 4;
                break;
            }
        }
    }
    if (ok)
        return str;
    buf = tbGetBuffer(len + 1);
    for (in = str, out = buf; *in != '\0'; in++) {
        if (isprint(*in))
            *out++ = *in;
        else {
            *out++ = '\\';
            if (*in == '\n')
                *out++ = 'n';
            else if (*in == '\t')
                *out++ = 't';
            else if (*in == '\v')
                *out++ = 'v';
            else if (*in == '\b')
                *out++ = 'b';
            else if (*in == '\r')
                *out++ = 'r';
            else if (*in == '\f')
                *out++ = 'f';
            else if ((*in == '\033') && (format == XkbXKMFile)) {
                *out++ = 'e';
            }
            else {
                *out++ = '0';
                sprintf(out, "%o", *in);
                while (*out != '\0')
                    out++;
            }
        }
    }
    *out++ = '\0';
    return buf;
}

/***====================================================================***/

char *
XkbGeomFPText(int val, unsigned format)
{
    int whole, frac;
    char *buf;

    buf = tbGetBuffer(12);
    if (format == XkbCFile) {
        sprintf(buf, "%d", val);
    }
    else {
        whole = val / XkbGeomPtsPerMM;
        frac = val % XkbGeomPtsPerMM;
        if (frac != 0)
            sprintf(buf, "%d.%d", whole, frac);
        else
            sprintf(buf, "%d", whole);
    }
    return buf;
}

char *
XkbDoodadTypeText(unsigned type, unsigned format)
{
    char *buf;

    if (format == XkbCFile) {
        buf = tbGetBuffer(24);
        if (type == XkbOutlineDoodad)
            strcpy(buf, "XkbOutlineDoodad");
        else if (type == XkbSolidDoodad)
            strcpy(buf, "XkbSolidDoodad");
        else if (type == XkbTextDoodad)
            strcpy(buf, "XkbTextDoodad");
        else if (type == XkbIndicatorDoodad)
            strcpy(buf, "XkbIndicatorDoodad");
        else if (type == XkbLogoDoodad)
            strcpy(buf, "XkbLogoDoodad");
        else
            sprintf(buf, "UnknownDoodad%d", type);
    }
    else {
        buf = tbGetBuffer(12);
        if (type == XkbOutlineDoodad)
            strcpy(buf, "outline");
        else if (type == XkbSolidDoodad)
            strcpy(buf, "solid");
        else if (type == XkbTextDoodad)
            strcpy(buf, "text");
        else if (type == XkbIndicatorDoodad)
            strcpy(buf, "indicator");
        else if (type == XkbLogoDoodad)
            strcpy(buf, "logo");
        else
            sprintf(buf, "unknown%d", type);
    }
    return buf;
}

static const char *actionTypeNames[XkbSA_NumActions] = {
    "NoAction",
    "SetMods", "LatchMods", "LockMods",
    "SetGroup", "LatchGroup", "LockGroup",
    "MovePtr",
    "PtrBtn", "LockPtrBtn",
    "SetPtrDflt",
    "ISOLock",
    "Terminate", "SwitchScreen",
    "SetControls", "LockControls",
    "ActionMessage",
    "RedirectKey",
    "DeviceBtn", "LockDeviceBtn"
};

const char *
XkbActionTypeText(unsigned type, unsigned format)
{
    static char buf[32];
    const char *rtrn;

    if (type <= XkbSA_LastAction) {
        rtrn = actionTypeNames[type];
        if (format == XkbCFile) {
            snprintf(buf, sizeof(buf), "XkbSA_%s", rtrn);
            return buf;
        }
        return rtrn;
    }
    snprintf(buf, sizeof(buf), "Private");
    return buf;
}

/***====================================================================***/

static int
TryCopyStr(char *to, const char *from, int *pLeft)
{
    register int len;

    if (*pLeft > 0) {
        len = strlen(from);
        if (len < ((*pLeft) - 3)) {
            strcat(to, from);
            *pLeft -= len;
            return TRUE;
        }
    }
    *pLeft = -1;
    return FALSE;
}

 /*ARGSUSED*/ static Bool
CopyNoActionArgs(XkbDescPtr xkb, XkbAction *action, char *buf, int *sz)
{
    return TRUE;
}

static Bool
CopyModActionArgs(XkbDescPtr xkb, XkbAction *action, char *buf, int *sz)
{
    XkbModAction *act;
    unsigned tmp;

    act = &action->mods;
    tmp = XkbModActionVMods(act);
    TryCopyStr(buf, "modifiers=", sz);
    if (act->flags & XkbSA_UseModMapMods)
        TryCopyStr(buf, "modMapMods", sz);
    else if (act->real_mods || tmp) {
        TryCopyStr(buf,
                   XkbVModMaskText(xkb, act->real_mods, tmp, XkbXKBFile), sz);
    }
    else
        TryCopyStr(buf, "none", sz);
    if (act->type == XkbSA_LockMods)
        return TRUE;
    if (act->flags & XkbSA_ClearLocks)
        TryCopyStr(buf, ",clearLocks", sz);
    if (act->flags & XkbSA_LatchToLock)
        TryCopyStr(buf, ",latchToLock", sz);
    return TRUE;
}

 /*ARGSUSED*/ static Bool
CopyGroupActionArgs(XkbDescPtr xkb, XkbAction *action, char *buf, int *sz)
{
    XkbGroupAction *act;
    char tbuf[32];

    act = &action->group;
    TryCopyStr(buf, "group=", sz);
    if (act->flags & XkbSA_GroupAbsolute)
        snprintf(tbuf, sizeof(tbuf), "%d", XkbSAGroup(act) + 1);
    else if (XkbSAGroup(act) < 0)
        snprintf(tbuf, sizeof(tbuf), "%d", XkbSAGroup(act));
    else
        snprintf(tbuf, sizeof(tbuf), "+%d", XkbSAGroup(act));
    TryCopyStr(buf, tbuf, sz);
    if (act->type == XkbSA_LockGroup)
        return TRUE;
    if (act->flags & XkbSA_ClearLocks)
        TryCopyStr(buf, ",clearLocks", sz);
    if (act->flags & XkbSA_LatchToLock)
        TryCopyStr(buf, ",latchToLock", sz);
    return TRUE;
}

 /*ARGSUSED*/ static Bool
CopyMovePtrArgs(XkbDescPtr xkb, XkbAction *action, char *buf, int *sz)
{
    XkbPtrAction *act;
    int x, y;
    char tbuf[32];

    act = &action->ptr;
    x = XkbPtrActionX(act);
    y = XkbPtrActionY(act);
    if ((act->flags & XkbSA_MoveAbsoluteX) || (x < 0))
        snprintf(tbuf, sizeof(tbuf), "x=%d", x);
    else
        snprintf(tbuf, sizeof(tbuf), "x=+%d", x);
    TryCopyStr(buf, tbuf, sz);

    if ((act->flags & XkbSA_MoveAbsoluteY) || (y < 0))
        snprintf(tbuf, sizeof(tbuf), ",y=%d", y);
    else
        snprintf(tbuf, sizeof(tbuf), ",y=+%d", y);
    TryCopyStr(buf, tbuf, sz);
    if (act->flags & XkbSA_NoAcceleration)
        TryCopyStr(buf, ",!accel", sz);
    return TRUE;
}

 /*ARGSUSED*/ static Bool
CopyPtrBtnArgs(XkbDescPtr xkb, XkbAction *action, char *buf, int *sz)
{
    XkbPtrBtnAction *act;
    char tbuf[32];

    act = &action->btn;
    TryCopyStr(buf, "button=", sz);
    if ((act->button > 0) && (act->button < 6)) {
        snprintf(tbuf, sizeof(tbuf), "%d", act->button);
        TryCopyStr(buf, tbuf, sz);
    }
    else
        TryCopyStr(buf, "default", sz);
    if (act->count > 0) {
        snprintf(tbuf, sizeof(tbuf), ",count=%d", act->count);
        TryCopyStr(buf, tbuf, sz);
    }
    if (action->type == XkbSA_LockPtrBtn) {
        switch (act->flags & (XkbSA_LockNoUnlock | XkbSA_LockNoLock)) {
        case XkbSA_LockNoLock:
            TryCopyStr(buf, ",affect=unlock", sz);
            break;
        case XkbSA_LockNoUnlock:
            TryCopyStr(buf, ",affect=lock", sz);
            break;
        case XkbSA_LockNoUnlock | XkbSA_LockNoLock:
            TryCopyStr(buf, ",affect=neither", sz);
            break;
        default:
            TryCopyStr(buf, ",affect=both", sz);
            break;
        }
    }
    return TRUE;
}

 /*ARGSUSED*/ static Bool
CopySetPtrDfltArgs(XkbDescPtr xkb, XkbAction *action, char *buf, int *sz)
{
    XkbPtrDfltAction *act;
    char tbuf[32];

    act = &action->dflt;
    if (act->affect == XkbSA_AffectDfltBtn) {
        TryCopyStr(buf, "affect=button,button=", sz);
        if ((act->flags & XkbSA_DfltBtnAbsolute) ||
            (XkbSAPtrDfltValue(act) < 0))
            snprintf(tbuf, sizeof(tbuf), "%d", XkbSAPtrDfltValue(act));
        else
            snprintf(tbuf, sizeof(tbuf), "+%d", XkbSAPtrDfltValue(act));
        TryCopyStr(buf, tbuf, sz);
    }
    return TRUE;
}

static Bool
CopyISOLockArgs(XkbDescPtr xkb, XkbAction *action, char *buf, int *sz)
{
    XkbISOAction *act;
    char tbuf[64];

    act = &action->iso;
    if (act->flags & XkbSA_ISODfltIsGroup) {
        TryCopyStr(tbuf, "group=", sz);
        if (act->flags & XkbSA_GroupAbsolute)
            snprintf(tbuf, sizeof(tbuf), "%d", XkbSAGroup(act) + 1);
        else if (XkbSAGroup(act) < 0)
            snprintf(tbuf, sizeof(tbuf), "%d", XkbSAGroup(act));
        else
            snprintf(tbuf, sizeof(tbuf), "+%d", XkbSAGroup(act));
        TryCopyStr(buf, tbuf, sz);
    }
    else {
        unsigned tmp;

        tmp = XkbModActionVMods(act);
        TryCopyStr(buf, "modifiers=", sz);
        if (act->flags & XkbSA_UseModMapMods)
            TryCopyStr(buf, "modMapMods", sz);
        else if (act->real_mods || tmp) {
            if (act->real_mods) {
                TryCopyStr(buf, XkbModMaskText(act->real_mods, XkbXKBFile), sz);
                if (tmp)
                    TryCopyStr(buf, "+", sz);
            }
            if (tmp)
                TryCopyStr(buf, XkbVModMaskText(xkb, 0, tmp, XkbXKBFile), sz);
        }
        else
            TryCopyStr(buf, "none", sz);
    }
    TryCopyStr(buf, ",affect=", sz);
    if ((act->affect & XkbSA_ISOAffectMask) == 0)
        TryCopyStr(buf, "all", sz);
    else {
        int nOut = 0;

        if ((act->affect & XkbSA_ISONoAffectMods) == 0) {
            TryCopyStr(buf, "mods", sz);
            nOut++;
        }
        if ((act->affect & XkbSA_ISONoAffectGroup) == 0) {
            snprintf(tbuf, sizeof(tbuf), "%sgroups", (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
        if ((act->affect & XkbSA_ISONoAffectPtr) == 0) {
            snprintf(tbuf, sizeof(tbuf), "%spointer", (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
        if ((act->affect & XkbSA_ISONoAffectCtrls) == 0) {
            snprintf(tbuf, sizeof(tbuf), "%scontrols", (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
    }
    return TRUE;
}

 /*ARGSUSED*/ static Bool
CopySwitchScreenArgs(XkbDescPtr xkb, XkbAction *action, char *buf, int *sz)
{
    XkbSwitchScreenAction *act;
    char tbuf[32];

    act = &action->screen;
    if ((act->flags & XkbSA_SwitchAbsolute) || (XkbSAScreen(act) < 0))
        snprintf(tbuf, sizeof(tbuf), "screen=%d", XkbSAScreen(act));
    else
        snprintf(tbuf, sizeof(tbuf), "screen=+%d", XkbSAScreen(act));
    TryCopyStr(buf, tbuf, sz);
    if (act->flags & XkbSA_SwitchApplication)
        TryCopyStr(buf, ",!same", sz);
    else
        TryCopyStr(buf, ",same", sz);
    return TRUE;
}

 /*ARGSUSED*/ static Bool
CopySetLockControlsArgs(XkbDescPtr xkb, XkbAction *action, char *buf, int *sz)
{
    XkbCtrlsAction *act;
    unsigned tmp;
    char tbuf[32];

    act = &action->ctrls;
    tmp = XkbActionCtrls(act);
    TryCopyStr(buf, "controls=", sz);
    if (tmp == 0)
        TryCopyStr(buf, "none", sz);
    else if ((tmp & XkbAllBooleanCtrlsMask) == XkbAllBooleanCtrlsMask)
        TryCopyStr(buf, "all", sz);
    else {
        int nOut = 0;

        if (tmp & XkbRepeatKeysMask) {
            snprintf(tbuf, sizeof(tbuf), "%sRepeatKeys", (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
        if (tmp & XkbSlowKeysMask) {
            snprintf(tbuf, sizeof(tbuf), "%sSlowKeys", (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
        if (tmp & XkbBounceKeysMask) {
            snprintf(tbuf, sizeof(tbuf), "%sBounceKeys", (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
        if (tmp & XkbStickyKeysMask) {
            snprintf(tbuf, sizeof(tbuf), "%sStickyKeys", (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
        if (tmp & XkbMouseKeysMask) {
            snprintf(tbuf, sizeof(tbuf), "%sMouseKeys", (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
        if (tmp & XkbMouseKeysAccelMask) {
            snprintf(tbuf, sizeof(tbuf), "%sMouseKeysAccel",
                     (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
        if (tmp & XkbAccessXKeysMask) {
            snprintf(tbuf, sizeof(tbuf), "%sAccessXKeys",
                     (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
        if (tmp & XkbAccessXTimeoutMask) {
            snprintf(tbuf, sizeof(tbuf), "%sAccessXTimeout",
                     (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
        if (tmp & XkbAccessXFeedbackMask) {
            snprintf(tbuf, sizeof(tbuf), "%sAccessXFeedback",
                     (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
        if (tmp & XkbAudibleBellMask) {
            snprintf(tbuf, sizeof(tbuf), "%sAudibleBell",
                     (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
        if (tmp & XkbOverlay1Mask) {
            snprintf(tbuf, sizeof(tbuf), "%sOverlay1", (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
        if (tmp & XkbOverlay2Mask) {
            snprintf(tbuf, sizeof(tbuf), "%sOverlay2", (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
        if (tmp & XkbIgnoreGroupLockMask) {
            snprintf(tbuf, sizeof(tbuf), "%sIgnoreGroupLock",
                     (nOut > 0 ? "+" : ""));
            TryCopyStr(buf, tbuf, sz);
            nOut++;
        }
    }
    return TRUE;
}

 /*ARGSUSED*/ static Bool
CopyActionMessageArgs(XkbDescPtr xkb, XkbAction *action, char *buf, int *sz)
{
    XkbMessageAction *act;
    unsigned all;
    char tbuf[32];

    act = &action->msg;
    all = XkbSA_MessageOnPress | XkbSA_MessageOnRelease;
    TryCopyStr(buf, "report=", sz);
    if ((act->flags & all) == 0)
        TryCopyStr(buf, "none", sz);
    else if ((act->flags & all) == all)
        TryCopyStr(buf, "all", sz);
    else if (act->flags & XkbSA_MessageOnPress)
        TryCopyStr(buf, "KeyPress", sz);
    else
        TryCopyStr(buf, "KeyRelease", sz);
    snprintf(tbuf, sizeof(tbuf), ",data[0]=0x%02x", act->message[0]);
    TryCopyStr(buf, tbuf, sz);
    snprintf(tbuf, sizeof(tbuf), ",data[1]=0x%02x", act->message[1]);
    TryCopyStr(buf, tbuf, sz);
    snprintf(tbuf, sizeof(tbuf), ",data[2]=0x%02x", act->message[2]);
    TryCopyStr(buf, tbuf, sz);
    snprintf(tbuf, sizeof(tbuf), ",data[3]=0x%02x", act->message[3]);
    TryCopyStr(buf, tbuf, sz);
    snprintf(tbuf, sizeof(tbuf), ",data[4]=0x%02x", act->message[4]);
    TryCopyStr(buf, tbuf, sz);
    snprintf(tbuf, sizeof(tbuf), ",data[5]=0x%02x", act->message[5]);
    TryCopyStr(buf, tbuf, sz);
    return TRUE;
}

static Bool
CopyRedirectKeyArgs(XkbDescPtr xkb, XkbAction *action, char *buf, int *sz)
{
    XkbRedirectKeyAction *act;
    char tbuf[32], *tmp;
    unsigned kc;
    unsigned vmods, vmods_mask;

    act = &action->redirect;
    kc = act->new_key;
    vmods = XkbSARedirectVMods(act);
    vmods_mask = XkbSARedirectVModsMask(act);
    if (xkb && xkb->names && xkb->names->keys && (kc <= xkb->max_key_code) &&
        (xkb->names->keys[kc].name[0] != '\0')) {
        char *kn;

        kn = XkbKeyNameText(xkb->names->keys[kc].name, XkbXKBFile);
        snprintf(tbuf, sizeof(tbuf), "key=%s", kn);
    }
    else
        snprintf(tbuf, sizeof(tbuf), "key=%d", kc);
    TryCopyStr(buf, tbuf, sz);
    if ((act->mods_mask == 0) && (vmods_mask == 0))
        return TRUE;
    if ((act->mods_mask == XkbAllModifiersMask) &&
        (vmods_mask == XkbAllVirtualModsMask)) {
        tmp = XkbVModMaskText(xkb, act->mods, vmods, XkbXKBFile);
        TryCopyStr(buf, ",mods=", sz);
        TryCopyStr(buf, tmp, sz);
    }
    else {
        if ((act->mods_mask & act->mods) || (vmods_mask & vmods)) {
            tmp = XkbVModMaskText(xkb, act->mods_mask & act->mods,
                                  vmods_mask & vmods, XkbXKBFile);
            TryCopyStr(buf, ",mods= ", sz);
            TryCopyStr(buf, tmp, sz);
        }
        if ((act->mods_mask & (~act->mods)) || (vmods_mask & (~vmods))) {
            tmp = XkbVModMaskText(xkb, act->mods_mask & (~act->mods),
                                  vmods_mask & (~vmods), XkbXKBFile);
            TryCopyStr(buf, ",clearMods= ", sz);
            TryCopyStr(buf, tmp, sz);
        }
    }
    return TRUE;
}

 /*ARGSUSED*/ static Bool
CopyDeviceBtnArgs(XkbDescPtr xkb, XkbAction *action, char *buf, int *sz)
{
    XkbDeviceBtnAction *act;
    char tbuf[32];

    act = &action->devbtn;
    snprintf(tbuf, sizeof(tbuf), "device= %d", act->device);
    TryCopyStr(buf, tbuf, sz);
    TryCopyStr(buf, ",button=", sz);
    snprintf(tbuf, sizeof(tbuf), "%d", act->button);
    TryCopyStr(buf, tbuf, sz);
    if (act->count > 0) {
        snprintf(tbuf, sizeof(tbuf), ",count=%d", act->count);
        TryCopyStr(buf, tbuf, sz);
    }
    if (action->type == XkbSA_LockDeviceBtn) {
        switch (act->flags & (XkbSA_LockNoUnlock | XkbSA_LockNoLock)) {
        case XkbSA_LockNoLock:
            TryCopyStr(buf, ",affect=unlock", sz);
            break;
        case XkbSA_LockNoUnlock:
            TryCopyStr(buf, ",affect=lock", sz);
            break;
        case XkbSA_LockNoUnlock | XkbSA_LockNoLock:
            TryCopyStr(buf, ",affect=neither", sz);
            break;
        default:
            TryCopyStr(buf, ",affect=both", sz);
            break;
        }
    }
    return TRUE;
}

 /*ARGSUSED*/ static Bool
CopyOtherArgs(XkbDescPtr xkb, XkbAction *action, char *buf, int *sz)
{
    XkbAnyAction *act;
    char tbuf[32];

    act = &action->any;
    snprintf(tbuf, sizeof(tbuf), "type=0x%02x", act->type);
    TryCopyStr(buf, tbuf, sz);
    snprintf(tbuf, sizeof(tbuf), ",data[0]=0x%02x", act->data[0]);
    TryCopyStr(buf, tbuf, sz);
    snprintf(tbuf, sizeof(tbuf), ",data[1]=0x%02x", act->data[1]);
    TryCopyStr(buf, tbuf, sz);
    snprintf(tbuf, sizeof(tbuf), ",data[2]=0x%02x", act->data[2]);
    TryCopyStr(buf, tbuf, sz);
    snprintf(tbuf, sizeof(tbuf), ",data[3]=0x%02x", act->data[3]);
    TryCopyStr(buf, tbuf, sz);
    snprintf(tbuf, sizeof(tbuf), ",data[4]=0x%02x", act->data[4]);
    TryCopyStr(buf, tbuf, sz);
    snprintf(tbuf, sizeof(tbuf), ",data[5]=0x%02x", act->data[5]);
    TryCopyStr(buf, tbuf, sz);
    snprintf(tbuf, sizeof(tbuf), ",data[6]=0x%02x", act->data[6]);
    TryCopyStr(buf, tbuf, sz);
    return TRUE;
}

typedef Bool (*actionCopy) (XkbDescPtr /* xkb */ ,
                            XkbAction * /* action */ ,
                            char * /* buf */ ,
                            int *       /* sz */
    );

static actionCopy copyActionArgs[XkbSA_NumActions] = {
    CopyNoActionArgs /* NoAction     */ ,
    CopyModActionArgs /* SetMods      */ ,
    CopyModActionArgs /* LatchMods    */ ,
    CopyModActionArgs /* LockMods     */ ,
    CopyGroupActionArgs /* SetGroup     */ ,
    CopyGroupActionArgs /* LatchGroup   */ ,
    CopyGroupActionArgs /* LockGroup    */ ,
    CopyMovePtrArgs /* MovePtr      */ ,
    CopyPtrBtnArgs /* PtrBtn       */ ,
    CopyPtrBtnArgs /* LockPtrBtn   */ ,
    CopySetPtrDfltArgs /* SetPtrDflt   */ ,
    CopyISOLockArgs /* ISOLock      */ ,
    CopyNoActionArgs /* Terminate    */ ,
    CopySwitchScreenArgs /* SwitchScreen */ ,
    CopySetLockControlsArgs /* SetControls  */ ,
    CopySetLockControlsArgs /* LockControls */ ,
    CopyActionMessageArgs /* ActionMessage */ ,
    CopyRedirectKeyArgs /* RedirectKey  */ ,
    CopyDeviceBtnArgs /* DeviceBtn    */ ,
    CopyDeviceBtnArgs           /* LockDeviceBtn */
};

#define	ACTION_SZ	256

char *
XkbActionText(XkbDescPtr xkb, XkbAction *action, unsigned format)
{
    char buf[ACTION_SZ], *tmp;
    int sz;

    if (format == XkbCFile) {
        snprintf(buf, sizeof(buf),
                 "{ %20s, { 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x } }",
                 XkbActionTypeText(action->type, XkbCFile),
                 action->any.data[0], action->any.data[1], action->any.data[2],
                 action->any.data[3], action->any.data[4], action->any.data[5],
                 action->any.data[6]);
    }
    else {
        snprintf(buf, sizeof(buf), "%s(",
                 XkbActionTypeText(action->type, XkbXKBFile));
        sz = ACTION_SZ - strlen(buf) + 2;       /* room for close paren and NULL */
        if (action->type < (unsigned) XkbSA_NumActions)
            (*copyActionArgs[action->type]) (xkb, action, buf, &sz);
        else
            CopyOtherArgs(xkb, action, buf, &sz);
        TryCopyStr(buf, ")", &sz);
    }
    tmp = tbGetBuffer(strlen(buf) + 1);
    if (tmp != NULL)
        strcpy(tmp, buf);
    return tmp;
}

char *
XkbBehaviorText(XkbDescPtr xkb, XkbBehavior * behavior, unsigned format)
{
    char buf[256], *tmp;

    if (format == XkbCFile) {
        if (behavior->type == XkbKB_Default)
            snprintf(buf, sizeof(buf), "{   0,    0 }");
        else
            snprintf(buf, sizeof(buf), "{ %3d, 0x%02x }", behavior->type,
                     behavior->data);
    }
    else {
        unsigned type, permanent;

        type = behavior->type & XkbKB_OpMask;
        permanent = ((behavior->type & XkbKB_Permanent) != 0);

        if (type == XkbKB_Lock) {
            snprintf(buf, sizeof(buf), "lock= %s",
                     (permanent ? "Permanent" : "TRUE"));
        }
        else if (type == XkbKB_RadioGroup) {
            int g;

            g = ((behavior->data) & (~XkbKB_RGAllowNone)) + 1;
            if (XkbKB_RGAllowNone & behavior->data) {
                snprintf(buf, sizeof(buf), "allowNone,");
                tmp = &buf[strlen(buf)];
            }
            else
                tmp = buf;
            if (permanent)
                sprintf(tmp, "permanentRadioGroup= %d", g);
            else
                sprintf(tmp, "radioGroup= %d", g);
        }
        else if ((type == XkbKB_Overlay1) || (type == XkbKB_Overlay2)) {
            int ndx, kc;
            char *kn;

            ndx = ((type == XkbKB_Overlay1) ? 1 : 2);
            kc = behavior->data;
            if ((xkb) && (xkb->names) && (xkb->names->keys))
                kn = XkbKeyNameText(xkb->names->keys[kc].name, XkbXKBFile);
            else {
                static char tbuf[8];

                snprintf(tbuf, sizeof(tbuf), "%d", kc);
                kn = tbuf;
            }
            if (permanent)
                snprintf(buf, sizeof(buf), "permanentOverlay%d= %s", ndx, kn);
            else
                snprintf(buf, sizeof(buf), "overlay%d= %s", ndx, kn);
        }
    }
    tmp = tbGetBuffer(strlen(buf) + 1);
    if (tmp != NULL)
        strcpy(tmp, buf);
    return tmp;
}

/***====================================================================***/

char *
XkbIndentText(unsigned size)
{
    static char buf[32];
    register int i;

    if (size > 31)
        size = 31;

    for (i = 0; i < size; i++) {
        buf[i] = ' ';
    }
    buf[size] = '\0';
    return buf;
}
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d9 2
a10 2
 documentation, and that the name of Silicon Graphics not be 
 used in advertising or publicity pertaining to distribution 
d12 1
a12 1
 Silicon Graphics makes no representation about the suitability 
d15 3
a17 3
 
 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d19 3
a21 3
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d9 2
a10 2
 documentation, and that the name of Silicon Graphics not be
 used in advertising or publicity pertaining to distribution
d12 1
a12 1
 Silicon Graphics makes no representation about the suitability
d15 3
a17 3

 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
d19 3
a21 3
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
d147 12
a158 12
register int i,bit;
int	 len;
char *mm,*rtrn;
char *str,buf[BUFFER_SIZE];

if ((modMask == 0) && (mask == 0)) {
    rtrn = tbGetBuffer(5);
    if (format == XkbCFile)
        snprintf(rtrn, 5, "0");
    else
        snprintf(rtrn, 5, "none");
    return rtrn;
d168 11
a178 10
	char *tmp;
	for (i = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) {
	    if (mask&bit) {
		tmp = XkbVModIndexText(xkb, i, format);
		len = strlen(tmp) + 1 + (str == buf ? 0 : 1);
		if (format == XkbCFile)
		    len += 4;
		if ((str - (buf + len)) <= BUFFER_SIZE) {
		    if (str != buf) {
			if (format == XkbCFile)
d180 1
a180 1
			else
d182 6
a187 6
			len--;
		    }
		}
		if (format == XkbCFile)
		    snprintf(str, BUFFER_SIZE - len, "%sMask", tmp);
		else
d189 4
a192 4
		str = &str[len-1];
	    }
	}
	str = buf;
d194 2
a195 1
    else str = NULL;
d197 1
a197 1
	len = strlen(mm);
d199 1
a199 1
	len= 0;
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d9 2
a10 2
 documentation, and that the name of Silicon Graphics not be 
 used in advertising or publicity pertaining to distribution 
d12 1
a12 1
 Silicon Graphics makes no representation about the suitability 
d15 3
a17 3
 
 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d19 3
a21 3
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
d147 4
a150 4
    register int i, bit;
    int len;
    char *mm, *rtrn;
    char *str, buf[BUFFER_SIZE];
d152 7
a158 7
    if ((modMask == 0) && (mask == 0)) {
        rtrn = tbGetBuffer(5);
        if (format == XkbCFile)
            sprintf(rtrn, "0");
        else
            sprintf(rtrn, "none");
        return rtrn;
d168 10
a177 11
        char *tmp;

        for (i = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) {
            if (mask & bit) {
                tmp = XkbVModIndexText(xkb, i, format);
                len = strlen(tmp) + 1 + (str == buf ? 0 : 1);
                if (format == XkbCFile)
                    len += 4;
                if ((str - (buf + len)) <= BUFFER_SIZE) {
                    if (str != buf) {
                        if (format == XkbCFile)
d179 1
a179 1
                        else
d181 6
a186 6
                        len--;
                    }
                }
                if (format == XkbCFile)
                    sprintf(str, "%sMask", tmp);
                else
d188 4
a191 4
                str = &str[len - 1];
            }
        }
        str = buf;
d193 1
a193 2
    else
        str = NULL;
d195 1
a195 1
        len = strlen(mm);
d197 1
a197 1
        len = 0;
a1266 1
            char *tmp;
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d53 1
a53 1
static int  tbNext= 0;
d58 1
a58 1
char *rtrn;
d60 6
a65 6
    if (size>=BUFFER_SIZE)
	return NULL;
    if ((BUFFER_SIZE-tbNext)<=size)
	tbNext= 0;
    rtrn= &textBuffer[tbNext];
    tbNext+= size;
d72 1
a72 1
XkbAtomText(Atom atm,unsigned format)
d74 2
a75 2
const char	*atmstr;
char	*rtrn,*tmp;
d79 7
a85 7
	int	len;
	len= strlen(atmstr)+1;
	if (len>BUFFER_SIZE)
	    len= BUFFER_SIZE-2;
	rtrn= tbGetBuffer(len);
	strncpy(rtrn,atmstr,len);
	rtrn[len]= '\0';
d88 2
a89 2
	rtrn= tbGetBuffer(1);
	rtrn[0]= '\0';
d91 7
a97 7
    if (format==XkbCFile) {
	for (tmp=rtrn;*tmp!='\0';tmp++) {
	    if ((tmp==rtrn)&&(!isalpha(*tmp)))
		*tmp= '_';
	    else if (!isalnum(*tmp))
		*tmp= '_';
	}
d99 1
a99 1
    return XkbStringText(rtrn,format);
d105 1
a105 1
XkbVModIndexText(XkbDescPtr xkb,unsigned ndx,unsigned format)
d107 5
a111 5
register int len;
register Atom *vmodNames;
char *rtrn;
const char *tmp;
char  numBuf[20];
d114 23
a136 22
	 vmodNames= xkb->names->vmods;
    else vmodNames= NULL;

    tmp= NULL;
    if (ndx>=XkbNumVirtualMods)
	 tmp= "illegal";
    else if (vmodNames&&(vmodNames[ndx]!=None))
	 tmp= NameForAtom(vmodNames[ndx]);
    if (tmp==NULL) {
	snprintf(numBuf,sizeof(numBuf),"%d",ndx);
	tmp = numBuf;
    }

    len= strlen(tmp)+1;
    if (format==XkbCFile)
	len+= 4;
    if (len>=BUFFER_SIZE)
	len= BUFFER_SIZE-1;
    rtrn= tbGetBuffer(len);
    if (format==XkbCFile) {
	 strcpy(rtrn,"vmod_");
	 strncpy(&rtrn[5],tmp,len-4);
d138 2
a139 1
    else strncpy(rtrn,tmp,len);
d144 20
a163 20
XkbVModMaskText(        XkbDescPtr	xkb,
			unsigned	modMask,
			unsigned	mask,
			unsigned	format)
{
register int i,bit;
int	 len;
char *mm,*rtrn;
char *str,buf[BUFFER_SIZE];

    if ((modMask==0)&&(mask==0)) {
	rtrn= tbGetBuffer(5);
	if (format==XkbCFile)
	    snprintf(rtrn,5,"0");
	else snprintf(rtrn,5,"none");
	return rtrn;
    }
    if (modMask!=0)
	 mm= XkbModMaskText(modMask,format);
    else mm= NULL;
d165 2
a166 2
    str= buf;
    buf[0]= '\0';
d168 32
a199 26
	char *tmp;
	for (i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	    if (mask&bit) {
		tmp= XkbVModIndexText(xkb,i,format);
		len= strlen(tmp)+1+(str==buf?0:1);
		if (format==XkbCFile)
		    len+= 4;
		if ((str-(buf+len))<=BUFFER_SIZE) {
		    if (str!=buf) {
			if (format==XkbCFile)	*str++= '|';
			else			*str++= '+';
			len--;
		    }
		}
		if (format==XkbCFile)
		    snprintf(str,BUFFER_SIZE-len,"%sMask",tmp);
		else strcpy(str,tmp);
		str= &str[len-1];
	    }
	}
	str= buf;
    }
    else str= NULL;
    if (mm)	
	len= strlen(mm);
    else	len= 0;
d201 11
a211 11
	len+= strlen(str)+(mm==NULL?0:1);
    if (len>=BUFFER_SIZE)
	len= BUFFER_SIZE-1;
    rtrn= tbGetBuffer(len+1);
    rtrn[0]= '\0';

    if (mm!=NULL) {
	i= strlen(mm);
	if (i>len)
	    i= len;
	strcpy(rtrn,mm);
d214 1
a214 1
	i=0;
d216 8
a223 6
    if (str!=NULL) {
	if (mm!=NULL) {
	    if (format==XkbCFile)	strcat(rtrn,"|");
	    else			strcat(rtrn,"+");
	}
	strncat(rtrn,str,len-i);
d225 1
a225 1
    rtrn[len]= '\0';
d229 1
a229 1
static char *modNames[XkbNumModifiers] = {
d234 1
a234 1
XkbModIndexText(unsigned ndx,unsigned format)
d236 2
a237 2
char *	rtrn;
char	buf[100];
d239 7
a245 6
    if (format==XkbCFile) {
	if (ndx<XkbNumModifiers)
	     snprintf(buf,sizeof(buf),"%sMapIndex",modNames[ndx]);
	else if (ndx==XkbNoModifier)
	     snprintf(buf,sizeof(buf),"XkbNoModifier");
	else snprintf(buf,sizeof(buf),"0x%02x",ndx);
d248 6
a253 5
	if (ndx<XkbNumModifiers)
	     strcpy(buf,modNames[ndx]);
	else if (ndx==XkbNoModifier)
	     strcpy(buf,"none");
	else snprintf(buf,sizeof(buf),"ILLEGAL_%02x",ndx);
d255 2
a256 2
    rtrn= tbGetBuffer(strlen(buf)+1);
    strcpy(rtrn,buf);
d261 1
a261 1
XkbModMaskText(unsigned mask,unsigned format)
d263 2
a264 2
register int i,bit;
char buf[64],*rtrn;
d266 11
a276 7
    if ((mask&0xff)==0xff) {
	if (format==XkbCFile) 		strcpy(buf,"0xff");
	else				strcpy(buf,"all");
    }
    else if ((mask&0xff)==0) {
	if (format==XkbCFile)		strcpy(buf,"0");
	else				strcpy(buf,"none");
d279 19
a297 16
	char *str= buf;
	buf[0]= '\0';
	for (i=0,bit=1;i<XkbNumModifiers;i++,bit<<=1) {
	    if (mask&bit) {
		if (str!=buf) {
		    if (format==XkbCFile)	*str++= '|';
		    else			*str++= '+';
		}
		strcpy(str,modNames[i]);
		str= &str[strlen(str)];
		if (format==XkbCFile) {
		    strcpy(str,"Mask");
		    str+= 4;
		}
	    }
	}
d299 2
a300 2
    rtrn= tbGetBuffer(strlen(buf)+1);
    strcpy(rtrn,buf);
d306 2
a307 3
/*ARGSUSED*/
char *
XkbConfigText(unsigned config,unsigned format)
d309 1
a309 1
static char *buf;
d311 1
a311 1
    buf= tbGetBuffer(32);
d313 34
a346 34
	case XkmSemanticsFile:
	    strcpy(buf,"Semantics");
	    break;
	case XkmLayoutFile:
	    strcpy(buf,"Layout");
	    break;
	case XkmKeymapFile:
	    strcpy(buf,"Keymap");
	    break;
	case XkmGeometryFile:
	case XkmGeometryIndex:
	    strcpy(buf,"Geometry");
	    break;
	case XkmTypesIndex:
	    strcpy(buf,"Types");
	    break;
	case XkmCompatMapIndex:
	    strcpy(buf,"CompatMap");
	    break;
	case XkmSymbolsIndex:
	    strcpy(buf,"Symbols");
	    break;
	case XkmIndicatorsIndex:
	    strcpy(buf,"Indicators");
	    break;
	case XkmKeyNamesIndex:
	    strcpy(buf,"KeyNames");
	    break;
	case XkmVirtualModsIndex:
	    strcpy(buf,"VirtualMods");
	    break;
	default:
	    snprintf(buf,32,"unknown(%d)",config);
	    break;
d354 1
a354 1
XkbKeysymText(KeySym sym,unsigned format)
d356 1
a356 1
static char buf[32],*rtrn;
d358 5
a362 4
    if (sym==NoSymbol)
	 strcpy(rtrn=buf,"NoSymbol");
    else snprintf(rtrn=buf, sizeof(buf), "0x%lx", (long)sym);
    return rtrn;
d366 1
a366 1
XkbKeyNameText(char *name,unsigned format)
d368 1
a368 1
char *buf;
d370 4
a373 4
    if (format==XkbCFile) {
	buf= tbGetBuffer(5);
	memcpy(buf,name,4);
	buf[4]= '\0';
d376 9
a384 8
	int len;
	buf= tbGetBuffer(7);
	buf[0]= '<';
	memcpy(&buf[1],name,4);
	buf[5]= '\0';
	len= strlen(buf);
	buf[len++]= '>';
	buf[len]= '\0';
d391 2
a392 2
static char *siMatchText[5] = {
	"NoneOf", "AnyOfOrNone", "AnyOf", "AllOf", "Exactly"
d395 2
a396 2
char *
XkbSIMatchText(unsigned type,unsigned format)
d398 2
a399 2
static char buf[40];
char *rtrn;
d401 26
a426 14
    switch (type&XkbSI_OpMask) {
	case XkbSI_NoneOf:	rtrn= siMatchText[0]; break;
	case XkbSI_AnyOfOrNone:	rtrn= siMatchText[1]; break;
	case XkbSI_AnyOf:	rtrn= siMatchText[2]; break;
	case XkbSI_AllOf:	rtrn= siMatchText[3]; break;
	case XkbSI_Exactly:	rtrn= siMatchText[4]; break;
        default:		snprintf(buf,sizeof(buf),"0x%x",type&XkbSI_OpMask);
				return buf;
    }
    if (format==XkbCFile) {
	if (type&XkbSI_LevelOneOnly)
	     snprintf(buf,sizeof(buf),"XkbSI_LevelOneOnly|XkbSI_%s",rtrn);
	else snprintf(buf,sizeof(buf),"XkbSI_%s",rtrn);
	rtrn= buf;
d433 6
a438 6
static char *imWhichNames[]= {
	"base",
	"latched",
	"locked",
	"effective",
	"compat"
d442 1
a442 1
XkbIMWhichStateMaskText(unsigned use_which,unsigned format)
d444 36
a479 37
int		len,olen;
unsigned	i,bit,tmp;
char *		buf;

    if (use_which==0) {
	buf= tbGetBuffer(2);
	strcpy(buf,"0");
	return buf;
    }
    tmp= use_which&XkbIM_UseAnyMods;
    for (len=i=0,bit=1;tmp!=0;i++,bit<<=1) {
	if (tmp&bit) {
	    tmp&= ~bit;
	    len+= strlen(imWhichNames[i])+1;
	    if (format==XkbCFile)
		len+= 9;
	}
    }
    olen= len+1;
    buf= tbGetBuffer(len+1);
    tmp= use_which&XkbIM_UseAnyMods;
    for (len=i=0,bit=1;tmp!=0;i++,bit<<=1) {
	if (tmp&bit) {
	    tmp&= ~bit;
	    if (format==XkbCFile) {
		if (len!=0)
		    buf[len++]= '|';
		snprintf(&buf[len],olen-len,"XkbIM_Use%s",imWhichNames[i]);
		buf[len+9]= toupper(buf[len+9]);
	    }
	    else {
		if (len!=0)
		    buf[len++]= '+';
		snprintf(&buf[len],olen-len,"%s",imWhichNames[i]);
	    }
	    len+= strlen(&buf[len]);
	}
d484 14
a497 14
static char *ctrlNames[] = {
	"repeatKeys",
	"slowKeys",
	"bounceKeys",
	"stickyKeys",
	"mouseKeys",
	"mouseKeysAccel",
	"accessXKeys",
	"accessXTimeout",
	"accessXFeedback",
	"audibleBell",
	"overlay1",
	"overlay2",
	"ignoreGroupLock"
d501 1
a501 1
XkbControlsMaskText(unsigned ctrls,unsigned format)
d503 39
a541 39
int		len,olen;
unsigned	i,bit,tmp;
char *		buf;

    if (ctrls==0) {
	buf= tbGetBuffer(5);
	if (format==XkbCFile)
	     strcpy(buf,"0");
	else strcpy(buf,"none");
	return buf;
    }
    tmp= ctrls&XkbAllBooleanCtrlsMask;
    for (len=i=0,bit=1;tmp!=0;i++,bit<<=1) {
	if (tmp&bit) {
	    tmp&= ~bit;
	    len+= strlen(ctrlNames[i])+1;
	    if (format==XkbCFile)
		len+= 7;
	}
    }
    olen= len+1;
    buf= tbGetBuffer(len+1);
    tmp= ctrls&XkbAllBooleanCtrlsMask;
    for (len=i=0,bit=1;tmp!=0;i++,bit<<=1) {
	if (tmp&bit) {
	    tmp&= ~bit;
	    if (format==XkbCFile) {
		if (len!=0)
		    buf[len++]= '|';
		snprintf(&buf[len],olen-len,"Xkb%sMask",ctrlNames[i]);
		buf[len+3]= toupper(buf[len+3]);
	    }
	    else {
		if (len!=0)
		    buf[len++]= '+';
		snprintf(&buf[len],olen-len,"%s",ctrlNames[i]);
	    }
	    len+= strlen(&buf[len]);
	}
d549 1
a549 1
XkbStringText(char *str,unsigned format)
d551 29
a579 25
char *	buf;
register char *in,*out;
int	len;
Bool	ok;

    if (str==NULL) {
	buf= tbGetBuffer(2);
	buf[0]='\0';
	return buf;
    }
    else if (format==XkbXKMFile)
	return str;
    for (ok= TRUE,len=0,in=str;*in!='\0';in++,len++) {
	if (!isprint(*in)) {
	    ok= FALSE;
	    switch (*in) {
		case '\n': case '\t': case '\v':
		case '\b': case '\r': case '\f':
		    len++;
		    break;
		default:
		    len+= 4;
		    break;
	    }
	}
d582 29
a610 23
	return str;
    buf= tbGetBuffer(len+1);
    for (in=str,out=buf;*in!='\0';in++) {
	if (isprint(*in))
	    *out++= *in;
	else {
	    *out++= '\\';
	    if (*in=='\n')	*out++= 'n';
	    else if (*in=='\t')	*out++= 't';
	    else if (*in=='\v')	*out++= 'v';
	    else if (*in=='\b')	*out++= 'b';
	    else if (*in=='\r')	*out++= 'r';
	    else if (*in=='\f')	*out++= 'f';
	    else if ((*in=='\033')&&(format==XkbXKMFile)) {
		*out++= 'e';
	    }
	    else {
		*out++= '0';
		snprintf(out,len-(out-buf)+1,"%o",*in);
		while (*out!='\0')
		    out++;
	    }
	}
d612 1
a612 1
    *out++= '\0';
d619 1
a619 1
XkbGeomFPText(int val,unsigned format)
d621 2
a622 2
int	whole,frac;
char *	buf;
d624 3
a626 3
    buf= tbGetBuffer(12);
    if (format==XkbCFile) {
	snprintf(buf,12,"%d",val);
d629 6
a634 5
	whole= val/XkbGeomPtsPerMM;
	frac= val%XkbGeomPtsPerMM;
	if (frac!=0)
	     snprintf(buf,12,"%d.%d",whole,frac);
	else snprintf(buf,12,"%d",whole);
d640 1
a640 1
XkbDoodadTypeText(unsigned type,unsigned format)
d642 16
a657 9
char *	buf;
    if (format==XkbCFile) {
	buf= tbGetBuffer(24);
	if (type==XkbOutlineDoodad)	   strcpy(buf,"XkbOutlineDoodad");
	else if (type==XkbSolidDoodad)	   strcpy(buf,"XkbSolidDoodad");
	else if (type==XkbTextDoodad)	   strcpy(buf,"XkbTextDoodad");
	else if (type==XkbIndicatorDoodad) strcpy(buf,"XkbIndicatorDoodad");
	else if (type==XkbLogoDoodad)	   strcpy(buf,"XkbLogoDoodad");
	else				   snprintf(buf,24,"UnknownDoodad%d",type);
d660 13
a672 7
	buf= tbGetBuffer(12);
	if (type==XkbOutlineDoodad)	   strcpy(buf,"outline");
	else if (type==XkbSolidDoodad)	   strcpy(buf,"solid");
	else if (type==XkbTextDoodad)	   strcpy(buf,"text");
	else if (type==XkbIndicatorDoodad) strcpy(buf,"indicator");
	else if (type==XkbLogoDoodad)	   strcpy(buf,"logo");
	else				   snprintf(buf,12,"unknown%d",type);
d677 4
a680 4
static char *actionTypeNames[XkbSA_NumActions]= {
    "NoAction", 
    "SetMods",      "LatchMods",    "LockMods", 
    "SetGroup",     "LatchGroup",   "LockGroup",
d682 1
a682 1
    "PtrBtn",       "LockPtrBtn",
d685 2
a686 2
    "Terminate",    "SwitchScreen", 
    "SetControls",  "LockControls",
d689 1
a689 1
    "DeviceBtn",    "LockDeviceBtn"
d692 2
a693 2
char *
XkbActionTypeText(unsigned type,unsigned format)
d695 2
a696 2
static char buf[32];
char *rtrn;
d698 7
a704 7
    if (type<=XkbSA_LastAction) {
	rtrn= actionTypeNames[type];
	if (format==XkbCFile) {
	    snprintf(buf,sizeof(buf),"XkbSA_%s",rtrn);
	    return buf;
	}
	return rtrn;
d706 1
a706 1
    snprintf(buf,sizeof(buf),"Private");
d713 1
a713 1
TryCopyStr(char *to,char *from,int *pLeft)
d715 9
a723 8
register int len;
    if (*pLeft>0) {
	len= strlen(from);
	if (len<((*pLeft)-3)) {
	    strcat(to,from);
	    *pLeft-= len;
	    return TRUE;
	}
d725 1
a725 1
    *pLeft= -1;
d729 2
a730 3
/*ARGSUSED*/
static Bool
CopyNoActionArgs(XkbDescPtr xkb,XkbAction *action,char *buf,int*sz)
d736 1
a736 2
CopyModActionArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int* sz)
d738 2
a739 2
XkbModAction *	act;
unsigned	tmp;
d741 5
a745 5
    act= &action->mods;
    tmp= XkbModActionVMods(act);
    TryCopyStr(buf,"modifiers=",sz);
    if (act->flags&XkbSA_UseModMapMods)
	  TryCopyStr(buf,"modMapMods",sz);
d747 11
a757 11
	 TryCopyStr(buf,
		     XkbVModMaskText(xkb,act->real_mods,tmp,XkbXKBFile),
		     sz);
    }
    else TryCopyStr(buf,"none",sz);
    if (act->type==XkbSA_LockMods)
	return TRUE;
    if (act->flags&XkbSA_ClearLocks)
	TryCopyStr(buf,",clearLocks",sz);
    if (act->flags&XkbSA_LatchToLock)
	TryCopyStr(buf,",latchToLock",sz);
d761 2
a762 4
/*ARGSUSED*/
static Bool
CopyGroupActionArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
d764 2
a765 2
XkbGroupAction *	act;
char			tbuf[32];
d767 15
a781 14
    act= &action->group;
    TryCopyStr(buf,"group=",sz);
    if (act->flags&XkbSA_GroupAbsolute)
	 snprintf(tbuf,sizeof(tbuf),"%d",XkbSAGroup(act)+1);
    else if (XkbSAGroup(act)<0)
	 snprintf(tbuf,sizeof(tbuf),"%d",XkbSAGroup(act));
    else snprintf(tbuf,sizeof(tbuf),"+%d",XkbSAGroup(act));
    TryCopyStr(buf,tbuf,sz);
    if (act->type==XkbSA_LockGroup)
	return TRUE;
    if (act->flags&XkbSA_ClearLocks)
	TryCopyStr(buf,",clearLocks",sz);
    if (act->flags&XkbSA_LatchToLock)
	TryCopyStr(buf,",latchToLock",sz);
d785 2
a786 3
/*ARGSUSED*/
static Bool
CopyMovePtrArgs(XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
d788 20
a807 18
XkbPtrAction *	act;
int		x,y;
char		tbuf[32];

    act= &action->ptr;
    x= XkbPtrActionX(act);
    y= XkbPtrActionY(act);
    if ((act->flags&XkbSA_MoveAbsoluteX)||(x<0))
	 snprintf(tbuf,sizeof(tbuf),"x=%d",x);
    else snprintf(tbuf,sizeof(tbuf),"x=+%d",x);
    TryCopyStr(buf,tbuf,sz);

    if ((act->flags&XkbSA_MoveAbsoluteY)||(y<0))
	 snprintf(tbuf,sizeof(tbuf),",y=%d",y);
    else snprintf(tbuf,sizeof(tbuf),",y=+%d",y);
    TryCopyStr(buf,tbuf,sz);
    if (act->flags&XkbSA_NoAcceleration)
	TryCopyStr(buf,",!accel",sz);
d811 2
a812 3
/*ARGSUSED*/
static Bool
CopyPtrBtnArgs(XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
d814 2
a815 2
XkbPtrBtnAction *	act;
char			tbuf[32];
d817 27
a843 23
    act= &action->btn;
    TryCopyStr(buf,"button=",sz);
    if ((act->button>0)&&(act->button<6)) {
	 snprintf(tbuf,sizeof(tbuf),"%d",act->button);
	 TryCopyStr(buf,tbuf,sz);
    }
    else TryCopyStr(buf,"default",sz);
    if (act->count>0) {
	snprintf(tbuf,sizeof(tbuf),",count=%d",act->count);
	TryCopyStr(buf,tbuf,sz);
    }
    if (action->type==XkbSA_LockPtrBtn) {
	switch (act->flags&(XkbSA_LockNoUnlock|XkbSA_LockNoLock)) {
	    case XkbSA_LockNoLock:
	        snprintf(tbuf,sizeof(tbuf),",affect=unlock"); break;
	    case XkbSA_LockNoUnlock:
	        snprintf(tbuf,sizeof(tbuf),",affect=lock"); break;
	    case XkbSA_LockNoUnlock|XkbSA_LockNoLock:
	        snprintf(tbuf,sizeof(tbuf),",affect=neither"); break;
	    default:
	        snprintf(tbuf,sizeof(tbuf),",affect=both"); break;
	}
	TryCopyStr(buf,tbuf,sz);
d848 2
a849 4
/*ARGSUSED*/
static Bool
CopySetPtrDfltArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
d851 2
a852 2
XkbPtrDfltAction *	act;
char			tbuf[32];
d854 9
a862 7
    act= &action->dflt;
    if (act->affect==XkbSA_AffectDfltBtn) {
	TryCopyStr(buf,"affect=button,button=",sz);
	if ((act->flags&XkbSA_DfltBtnAbsolute)||(XkbSAPtrDfltValue(act)<0))
	     snprintf(tbuf,sizeof(tbuf),"%d",XkbSAPtrDfltValue(act));
	else snprintf(tbuf,sizeof(tbuf),"+%d",XkbSAPtrDfltValue(act));
	TryCopyStr(buf,tbuf,sz);
d868 1
a868 1
CopyISOLockArgs(XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
d870 2
a871 2
XkbISOAction *	act;
char		tbuf[64];
d873 10
a882 9
    act= &action->iso;
    if (act->flags&XkbSA_ISODfltIsGroup) {
	TryCopyStr(tbuf,"group=",sz);
	if (act->flags&XkbSA_GroupAbsolute)
	     snprintf(tbuf,sizeof(tbuf),"%d",XkbSAGroup(act)+1);
	else if (XkbSAGroup(act)<0)
	     snprintf(tbuf,sizeof(tbuf),"%d",XkbSAGroup(act));
	else snprintf(tbuf,sizeof(tbuf),"+%d",XkbSAGroup(act));
	TryCopyStr(buf,tbuf,sz);
d885 21
a905 19
	unsigned tmp;
	tmp= XkbModActionVMods(act);
	TryCopyStr(buf,"modifiers=",sz);
	if (act->flags&XkbSA_UseModMapMods)
	     TryCopyStr(buf,"modMapMods",sz);
	else if (act->real_mods || tmp) {
	    if (act->real_mods) {
		TryCopyStr(buf,XkbModMaskText(act->real_mods,XkbXKBFile),sz);
		if (tmp)
		    TryCopyStr(buf,"+",sz);
	    }
	    if (tmp)
		TryCopyStr(buf,XkbVModMaskText(xkb,0,tmp,XkbXKBFile),sz);
	}
	else TryCopyStr(buf,"none",sz);
    }
    TryCopyStr(buf,",affect=",sz);
    if ((act->affect&XkbSA_ISOAffectMask)==0)
	TryCopyStr(buf,"all",sz);
d907 21
a927 20
	int nOut= 0;
	if ((act->affect&XkbSA_ISONoAffectMods)==0) {
	    TryCopyStr(buf,"mods",sz);
	    nOut++;
	}
	if ((act->affect&XkbSA_ISONoAffectGroup)==0) {
	    snprintf(tbuf,sizeof(tbuf),"%sgroups",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if ((act->affect&XkbSA_ISONoAffectPtr)==0) {
	    snprintf(tbuf,sizeof(tbuf),"%spointer",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if ((act->affect&XkbSA_ISONoAffectCtrls)==0) {
	    snprintf(tbuf,sizeof(tbuf),"%scontrols",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
d932 2
a933 4
/*ARGSUSED*/
static Bool
CopySwitchScreenArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
d935 2
a936 2
XkbSwitchScreenAction *	act;
char			tbuf[32];
d938 10
a947 8
    act= &action->screen;
    if ((act->flags&XkbSA_SwitchAbsolute)||(XkbSAScreen(act)<0))
	 snprintf(tbuf,sizeof(tbuf),"screen=%d",XkbSAScreen(act));
    else snprintf(tbuf,sizeof(tbuf),"screen=+%d",XkbSAScreen(act));
    TryCopyStr(buf,tbuf,sz);
    if (act->flags&XkbSA_SwitchApplication)
	 TryCopyStr(buf,",!same",sz);
    else TryCopyStr(buf,",same",sz);
d951 2
a952 4
/*ARGSUSED*/
static Bool
CopySetLockControlsArgs(XkbDescPtr xkb,XkbAction *action,
							char *buf,int *sz)
d954 11
a964 11
XkbCtrlsAction *	act;
unsigned		tmp;
char			tbuf[32];

    act= &action->ctrls;
    tmp= XkbActionCtrls(act);
    TryCopyStr(buf,"controls=",sz);
    if (tmp==0)
	TryCopyStr(buf,"none",sz);
    else if ((tmp&XkbAllBooleanCtrlsMask)==XkbAllBooleanCtrlsMask)
	TryCopyStr(buf,"all",sz);
d966 73
a1038 66
	int nOut= 0;
	if (tmp&XkbRepeatKeysMask) {
	    snprintf(tbuf,sizeof(tbuf),"%sRepeatKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbSlowKeysMask) {
	    snprintf(tbuf,sizeof(tbuf),"%sSlowKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbBounceKeysMask) {
	    snprintf(tbuf,sizeof(tbuf),"%sBounceKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbStickyKeysMask) {
	    snprintf(tbuf,sizeof(tbuf),"%sStickyKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbMouseKeysMask) {
	    snprintf(tbuf,sizeof(tbuf),"%sMouseKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbMouseKeysAccelMask) {
	    snprintf(tbuf,sizeof(tbuf),"%sMouseKeysAccel",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbAccessXKeysMask) {
	    snprintf(tbuf,sizeof(tbuf),"%sAccessXKeys",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbAccessXTimeoutMask) {
	    snprintf(tbuf,sizeof(tbuf),"%sAccessXTimeout",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbAccessXFeedbackMask) {
	    snprintf(tbuf,sizeof(tbuf),"%sAccessXFeedback",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbAudibleBellMask) {
	    snprintf(tbuf,sizeof(tbuf),"%sAudibleBell",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbOverlay1Mask) {
	    snprintf(tbuf,sizeof(tbuf),"%sOverlay1",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbOverlay2Mask) {
	    snprintf(tbuf,sizeof(tbuf),"%sOverlay2",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
	if (tmp&XkbIgnoreGroupLockMask) {
	    snprintf(tbuf,sizeof(tbuf),"%sIgnoreGroupLock",(nOut>0?"+":""));
	    TryCopyStr(buf,tbuf,sz);
	    nOut++;
	}
d1043 2
a1044 4
/*ARGSUSED*/
static Bool
CopyActionMessageArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
d1046 27
a1072 20
XkbMessageAction *	act;
unsigned		all;
char			tbuf[32];

    act= &action->msg;
    all= XkbSA_MessageOnPress|XkbSA_MessageOnRelease;
    TryCopyStr(buf,"report=",sz);
    if ((act->flags&all)==0)
	TryCopyStr(buf,"none",sz);
    else if ((act->flags&all)==all)
	TryCopyStr(buf,"all",sz);
    else if (act->flags&XkbSA_MessageOnPress)
	 TryCopyStr(buf,"KeyPress",sz);
    else TryCopyStr(buf,"KeyRelease",sz);
    snprintf(tbuf,sizeof(tbuf),",data[0]=0x%02x",act->message[0]); TryCopyStr(buf,tbuf,sz);
    snprintf(tbuf,sizeof(tbuf),",data[1]=0x%02x",act->message[1]); TryCopyStr(buf,tbuf,sz);
    snprintf(tbuf,sizeof(tbuf),",data[2]=0x%02x",act->message[2]); TryCopyStr(buf,tbuf,sz);
    snprintf(tbuf,sizeof(tbuf),",data[3]=0x%02x",act->message[3]); TryCopyStr(buf,tbuf,sz);
    snprintf(tbuf,sizeof(tbuf),",data[4]=0x%02x",act->message[4]); TryCopyStr(buf,tbuf,sz);
    snprintf(tbuf,sizeof(tbuf),",data[5]=0x%02x",act->message[5]); TryCopyStr(buf,tbuf,sz);
d1077 1
a1077 2
CopyRedirectKeyArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
d1079 26
a1104 24
XkbRedirectKeyAction *	act;
char			tbuf[32],*tmp;
unsigned		kc;
unsigned		vmods,vmods_mask;

    act= &action->redirect;
    kc= act->new_key;
    vmods= XkbSARedirectVMods(act);
    vmods_mask= XkbSARedirectVModsMask(act);
    if (xkb && xkb->names && xkb->names->keys && (kc<=xkb->max_key_code) &&
				(xkb->names->keys[kc].name[0]!='\0')) {
	char *kn;
	kn= XkbKeyNameText(xkb->names->keys[kc].name,XkbXKBFile);
	snprintf(tbuf,sizeof(tbuf),"key=%s",kn);
    }
    else snprintf(tbuf,sizeof(tbuf),"key=%d",kc);
    TryCopyStr(buf,tbuf,sz);
    if ((act->mods_mask==0)&&(vmods_mask==0))
	return TRUE;
    if ((act->mods_mask==XkbAllModifiersMask)&&
	(vmods_mask==XkbAllVirtualModsMask)) {
	tmp= XkbVModMaskText(xkb,act->mods,vmods,XkbXKBFile);
	TryCopyStr(buf,",mods=",sz);
	TryCopyStr(buf,tmp,sz);
d1107 12
a1118 12
	if ((act->mods_mask&act->mods)||(vmods_mask&vmods)) {
	    tmp= XkbVModMaskText(xkb,act->mods_mask&act->mods,
					 vmods_mask&vmods,XkbXKBFile);
	    TryCopyStr(buf,",mods= ",sz);
	    TryCopyStr(buf,tmp,sz);
	}
	if ((act->mods_mask&(~act->mods))||(vmods_mask&(~vmods))) {
	    tmp= XkbVModMaskText(xkb,act->mods_mask&(~act->mods),
					 vmods_mask&(~vmods),XkbXKBFile);
	    TryCopyStr(buf,",clearMods= ",sz);
	    TryCopyStr(buf,tmp,sz);
	}
d1123 2
a1124 4
/*ARGSUSED*/
static Bool
CopyDeviceBtnArgs(XkbDescPtr xkb,XkbAction *action,char *buf,
								int *sz)
d1126 2
a1127 2
XkbDeviceBtnAction *	act;
char			tbuf[32];
d1129 25
a1153 21
    act= &action->devbtn;
    snprintf(tbuf,sizeof(tbuf),"device= %d",act->device); TryCopyStr(buf,tbuf,sz);
    TryCopyStr(buf,",button=",sz);
    snprintf(tbuf,sizeof(tbuf),"%d",act->button);
    TryCopyStr(buf,tbuf,sz);
    if (act->count>0) {
	snprintf(tbuf,sizeof(tbuf),",count=%d",act->count);
	TryCopyStr(buf,tbuf,sz);
    }
    if (action->type==XkbSA_LockDeviceBtn) {
	switch (act->flags&(XkbSA_LockNoUnlock|XkbSA_LockNoLock)) {
	    case XkbSA_LockNoLock:
	        snprintf(tbuf,sizeof(tbuf),",affect=unlock"); break;
	    case XkbSA_LockNoUnlock:
	        snprintf(tbuf,sizeof(tbuf),",affect=lock"); break;
	    case XkbSA_LockNoUnlock|XkbSA_LockNoLock:
	        snprintf(tbuf,sizeof(tbuf),",affect=neither"); break;
	    default:
	        snprintf(tbuf,sizeof(tbuf),",affect=both"); break;
	}
	TryCopyStr(buf,tbuf,sz);
d1158 2
a1159 3
/*ARGSUSED*/
static Bool
CopyOtherArgs(XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
d1161 2
a1162 2
XkbAnyAction *	act;
char		tbuf[32];
d1164 17
a1180 9
    act= &action->any;
    snprintf(tbuf,sizeof(tbuf),"type=0x%02x",act->type); TryCopyStr(buf,tbuf,sz);
    snprintf(tbuf,sizeof(tbuf),",data[0]=0x%02x",act->data[0]); TryCopyStr(buf,tbuf,sz);
    snprintf(tbuf,sizeof(tbuf),",data[1]=0x%02x",act->data[1]); TryCopyStr(buf,tbuf,sz);
    snprintf(tbuf,sizeof(tbuf),",data[2]=0x%02x",act->data[2]); TryCopyStr(buf,tbuf,sz);
    snprintf(tbuf,sizeof(tbuf),",data[3]=0x%02x",act->data[3]); TryCopyStr(buf,tbuf,sz);
    snprintf(tbuf,sizeof(tbuf),",data[4]=0x%02x",act->data[4]); TryCopyStr(buf,tbuf,sz);
    snprintf(tbuf,sizeof(tbuf),",data[5]=0x%02x",act->data[5]); TryCopyStr(buf,tbuf,sz);
    snprintf(tbuf,sizeof(tbuf),",data[6]=0x%02x",act->data[6]); TryCopyStr(buf,tbuf,sz);
d1184 27
a1210 27
typedef	Bool	(*actionCopy)(
	XkbDescPtr 	/* xkb */,
	XkbAction *	/* action */,
	char *		/* buf */,
	int*		/* sz */
);
static actionCopy	copyActionArgs[XkbSA_NumActions] = {
	CopyNoActionArgs		/* NoAction	*/,
	CopyModActionArgs		/* SetMods	*/,
	CopyModActionArgs		/* LatchMods	*/,
	CopyModActionArgs		/* LockMods	*/,
	CopyGroupActionArgs		/* SetGroup	*/,
	CopyGroupActionArgs		/* LatchGroup	*/,
	CopyGroupActionArgs		/* LockGroup	*/,
	CopyMovePtrArgs			/* MovePtr	*/,
	CopyPtrBtnArgs			/* PtrBtn	*/,
	CopyPtrBtnArgs			/* LockPtrBtn	*/,
	CopySetPtrDfltArgs		/* SetPtrDflt	*/,
	CopyISOLockArgs			/* ISOLock	*/,
	CopyNoActionArgs		/* Terminate	*/,
	CopySwitchScreenArgs		/* SwitchScreen	*/,
	CopySetLockControlsArgs		/* SetControls	*/,
	CopySetLockControlsArgs		/* LockControls	*/,
	CopyActionMessageArgs		/* ActionMessage*/,
	CopyRedirectKeyArgs		/* RedirectKey	*/,
	CopyDeviceBtnArgs		/* DeviceBtn	*/,
	CopyDeviceBtnArgs		/* LockDeviceBtn*/
d1216 1
a1216 1
XkbActionText(XkbDescPtr xkb,XkbAction *action,unsigned format)
d1218 2
a1219 2
char	buf[ACTION_SZ],*tmp;
int	sz;
d1221 7
a1227 7
    if (format==XkbCFile) {
	snprintf(buf, sizeof(buf),
	    "{ %20s, { 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x } }",
	    XkbActionTypeText(action->type,XkbCFile),
	    action->any.data[0],action->any.data[1],action->any.data[2],
	    action->any.data[3],action->any.data[4],action->any.data[5],
	    action->any.data[6]);
d1230 12
a1241 10
	snprintf(buf,sizeof(buf),"%s(",XkbActionTypeText(action->type,XkbXKBFile));
	sz= ACTION_SZ-strlen(buf)+2; /* room for close paren and NULL */
	if (action->type<(unsigned)XkbSA_NumActions)
	     (*copyActionArgs[action->type])(xkb,action,buf,&sz);
	else CopyOtherArgs(xkb,action,buf,&sz);
	TryCopyStr(buf,")",&sz);
    }
    tmp= tbGetBuffer(strlen(buf)+1);
    if (tmp!=NULL)
	strcpy(tmp,buf);
d1246 1
a1246 1
XkbBehaviorText(XkbDescPtr xkb,XkbBehavior *behavior,unsigned format)
d1248 1
a1248 1
char	buf[256],*tmp;
d1250 6
a1255 4
    if (format==XkbCFile) {
	if (behavior->type==XkbKB_Default)
	     snprintf(buf,sizeof(buf),"{   0,    0 }");
	else snprintf(buf,sizeof(buf),"{ %3d, 0x%02x }",behavior->type,behavior->data);
d1258 48
a1305 41
	unsigned 	type,permanent;
	type= behavior->type&XkbKB_OpMask;
	permanent=((behavior->type&XkbKB_Permanent)!=0);

	if (type==XkbKB_Lock) {
	    snprintf(buf,sizeof(buf),"lock= %s",(permanent?"Permanent":"TRUE"));
	}
	else if (type==XkbKB_RadioGroup) {
	    int 	g;
	    char	*tmp;
	    g= ((behavior->data)&(~XkbKB_RGAllowNone))+1;
	    if (XkbKB_RGAllowNone&behavior->data) {
		snprintf(buf,sizeof(buf),"allowNone,");
		tmp= &buf[strlen(buf)];
	    }
	    else tmp= buf;
	    if (permanent)
		 snprintf(tmp,sizeof(buf),"permanentRadioGroup= %d",g);
	    else snprintf(tmp,sizeof(buf),"radioGroup= %d",g);
	}
	else if ((type==XkbKB_Overlay1)||(type==XkbKB_Overlay2)) {
	    int ndx,kc;
	    char *kn;

	    ndx= ((type==XkbKB_Overlay1)?1:2);
	    kc= behavior->data;
	    if ((xkb)&&(xkb->names)&&(xkb->names->keys))
		kn= XkbKeyNameText(xkb->names->keys[kc].name,XkbXKBFile);
	    else {
		static char tbuf[8];
		snprintf(tbuf,sizeof(tbuf),"%d",kc);
		kn= tbuf;
	    }
	    if (permanent)
		 snprintf(buf,sizeof(buf),"permanentOverlay%d= %s",ndx,kn);
	    else snprintf(buf,sizeof(buf),"overlay%d= %s",ndx,kn);
	}
    }
    tmp= tbGetBuffer(strlen(buf)+1);
    if (tmp!=NULL)
	strcpy(tmp,buf);
d1314 2
a1315 2
static char buf[32];
register int i;
d1317 2
a1318 2
    if (size>31)
	size= 31;
d1320 2
a1321 2
    for (i=0;i<size;i++) {
	buf[i]= ' ';
d1323 1
a1323 1
    buf[size]= '\0';
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a37 1
#define	NEED_EVENTS
d39 1
d74 1
d77 2
a78 2
    tmp= XkbAtomGetString(atm);
    if (tmp!=NULL) {
d80 1
a80 1
	len= strlen(tmp)+1;
d84 1
a84 1
	strncpy(rtrn,tmp,len);
d109 2
a110 1
char *rtrn,*tmp;
d121 5
a125 3
	 tmp= XkbAtomGetString(vmodNames[ndx]);
    if (tmp==NULL)
	snprintf(tmp=numBuf,sizeof(numBuf),"%d",ndx);
d532 1
a532 1
    for (ok= True,len=0,in=str;*in!='\0';in++,len++) {
d534 1
a534 1
	    ok= False;
d666 1
a666 1
	    return True;
d670 1
a670 1
    return False;
d677 1
a677 1
    return True;
d699 1
a699 1
	return True;
d704 1
a704 1
    return True;
d724 1
a724 1
	return True;
d729 1
a729 1
    return True;
d754 1
a754 1
    return True;
d788 1
a788 1
    return True;
d807 1
a807 1
    return True;
d868 1
a868 1
    return True;
d887 1
a887 1
    return True;
d974 1
a974 1
    return True;
d1002 1
a1002 1
    return True;
d1027 1
a1027 1
	return True;
d1048 1
a1048 1
    return True;
d1081 1
a1081 1
    return True;
d1100 1
a1100 1
    return True;
d1178 1
a1178 1
	    snprintf(buf,sizeof(buf),"lock= %s",(permanent?"Permanent":"True"));
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d121 1
a121 1
	sprintf(tmp=numBuf,"%d",ndx);
d151 2
a152 2
	     sprintf(rtrn,"0");
	else sprintf(rtrn,"none");
d177 1
a177 1
		     sprintf(str,"%sMask",tmp);
d227 1
a227 1
	     sprintf(buf,"%sMapIndex",modNames[ndx]);
d229 2
a230 2
	     sprintf(buf,"XkbNoModifier");
	else sprintf(buf,"0x%02x",ndx);
d237 1
a237 1
	else sprintf(buf,"ILLEGAL_%02x",ndx);
d323 1
a323 1
	    sprintf(buf,"unknown(%d)",config);
d338 1
a338 1
    else sprintf(rtrn=buf, "0x%lx", (long)sym);
d383 1
a383 1
	default:		sprintf(buf,"0x%x",type&XkbSI_OpMask);
d388 2
a389 2
	     sprintf(buf,"XkbSI_LevelOneOnly|XkbSI_%s",rtrn);
	else sprintf(buf,"XkbSI_%s",rtrn);
d408 1
a408 1
int		len;
d426 1
d435 1
a435 1
		sprintf(&buf[len],"XkbIM_Use%s",imWhichNames[i]);
d441 1
a441 1
		sprintf(&buf[len],"%s",imWhichNames[i]);
d468 1
a468 1
int		len;
d488 1
d497 1
a497 1
		sprintf(&buf[len],"Xkb%sMask",ctrlNames[i]);
d503 1
a503 1
		sprintf(&buf[len],"%s",ctrlNames[i]);
d561 1
a561 1
		sprintf(out,"%o",*in);
d581 1
a581 1
	sprintf(buf,"%d",val);
d587 2
a588 2
	     sprintf(buf,"%d.%d",whole,frac);
	else sprintf(buf,"%d",whole);
d604 1
a604 1
	else				   sprintf(buf,"UnknownDoodad%d",type);
d613 1
a613 1
	else				   sprintf(buf,"unknown%d",type);
d642 1
a642 1
	    sprintf(buf,"XkbSA_%s",rtrn);
d647 1
a647 1
    sprintf(buf,"Private");
d714 1
a714 1
	 sprintf(tbuf,"%d",XkbSAGroup(act)+1);
d716 2
a717 2
	 sprintf(tbuf,"%d",XkbSAGroup(act));
    else sprintf(tbuf,"+%d",XkbSAGroup(act));
d740 2
a741 2
	 sprintf(tbuf,"x=%d",x);
    else sprintf(tbuf,"x=+%d",x);
d745 2
a746 2
	 sprintf(tbuf,",y=%d",y);
    else sprintf(tbuf,",y=+%d",y);
d763 1
a763 1
	 sprintf(tbuf,"%d",act->button);
d768 1
a768 1
	sprintf(tbuf,",count=%d",act->count);
d774 1
a774 1
		sprintf(tbuf,",affect=unlock"); break;
d776 1
a776 1
		sprintf(tbuf,",affect=lock"); break;
d778 1
a778 1
		sprintf(tbuf,",affect=neither"); break;
d780 1
a780 1
		sprintf(tbuf,",affect=both"); break;
d799 2
a800 2
	     sprintf(tbuf,"%d",XkbSAPtrDfltValue(act));
	else sprintf(tbuf,"+%d",XkbSAPtrDfltValue(act));
d816 1
a816 1
	     sprintf(tbuf,"%d",XkbSAGroup(act)+1);
d818 2
a819 2
	     sprintf(tbuf,"%d",XkbSAGroup(act));
	else sprintf(tbuf,"+%d",XkbSAGroup(act));
d849 1
a849 1
	    sprintf(tbuf,"%sgroups",(nOut>0?"+":""));
d854 1
a854 1
	    sprintf(tbuf,"%spointer",(nOut>0?"+":""));
d859 1
a859 1
	    sprintf(tbuf,"%scontrols",(nOut>0?"+":""));
d877 2
a878 2
	 sprintf(tbuf,"screen=%d",XkbSAScreen(act));
    else sprintf(tbuf,"screen=+%d",XkbSAScreen(act));
d905 1
a905 1
	    sprintf(tbuf,"%sRepeatKeys",(nOut>0?"+":""));
d910 1
a910 1
	    sprintf(tbuf,"%sSlowKeys",(nOut>0?"+":""));
d915 1
a915 1
	    sprintf(tbuf,"%sBounceKeys",(nOut>0?"+":""));
d920 1
a920 1
	    sprintf(tbuf,"%sStickyKeys",(nOut>0?"+":""));
d925 1
a925 1
	    sprintf(tbuf,"%sMouseKeys",(nOut>0?"+":""));
d930 1
a930 1
	    sprintf(tbuf,"%sMouseKeysAccel",(nOut>0?"+":""));
d935 1
a935 1
	    sprintf(tbuf,"%sAccessXKeys",(nOut>0?"+":""));
d940 1
a940 1
	    sprintf(tbuf,"%sAccessXTimeout",(nOut>0?"+":""));
d945 1
a945 1
	    sprintf(tbuf,"%sAccessXFeedback",(nOut>0?"+":""));
d950 1
a950 1
	    sprintf(tbuf,"%sAudibleBell",(nOut>0?"+":""));
d955 1
a955 1
	    sprintf(tbuf,"%sOverlay1",(nOut>0?"+":""));
d960 1
a960 1
	    sprintf(tbuf,"%sOverlay2",(nOut>0?"+":""));
d965 1
a965 1
	    sprintf(tbuf,"%sIgnoreGroupLock",(nOut>0?"+":""));
d992 6
a997 6
    sprintf(tbuf,",data[0]=0x%02x",act->message[0]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[1]=0x%02x",act->message[1]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[2]=0x%02x",act->message[2]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[3]=0x%02x",act->message[3]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[4]=0x%02x",act->message[4]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[5]=0x%02x",act->message[5]); TryCopyStr(buf,tbuf,sz);
d1018 1
a1018 1
	sprintf(tbuf,"key=%s",kn);
d1020 1
a1020 1
    else sprintf(tbuf,"key=%d",kc);
d1056 1
a1056 1
    sprintf(tbuf,"device= %d",act->device); TryCopyStr(buf,tbuf,sz);
d1058 1
a1058 1
    sprintf(tbuf,"%d",act->button);
d1061 1
a1061 1
	sprintf(tbuf,",count=%d",act->count);
d1067 1
a1067 1
		sprintf(tbuf,",affect=unlock"); break;
d1069 1
a1069 1
		sprintf(tbuf,",affect=lock"); break;
d1071 1
a1071 1
		sprintf(tbuf,",affect=neither"); break;
d1073 1
a1073 1
		sprintf(tbuf,",affect=both"); break;
d1088 8
a1095 8
    sprintf(tbuf,"type=0x%02x",act->type); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[0]=0x%02x",act->data[0]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[1]=0x%02x",act->data[1]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[2]=0x%02x",act->data[2]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[3]=0x%02x",act->data[3]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[4]=0x%02x",act->data[4]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[5]=0x%02x",act->data[5]); TryCopyStr(buf,tbuf,sz);
    sprintf(tbuf,",data[6]=0x%02x",act->data[6]); TryCopyStr(buf,tbuf,sz);
d1137 1
a1137 1
	sprintf(buf,
d1145 1
a1145 1
	sprintf(buf,"%s(",XkbActionTypeText(action->type,XkbXKBFile));
d1165 2
a1166 2
	     sprintf(buf,"{   0,    0 }");
	else sprintf(buf,"{ %3d, 0x%02x }",behavior->type,behavior->data);
d1174 1
a1174 1
	    sprintf(buf,"lock= %s",(permanent?"Permanent":"True"));
d1181 1
a1181 1
		sprintf(buf,"allowNone,");
d1186 2
a1187 2
		 sprintf(tmp,"permanentRadioGroup= %d",g);
	    else sprintf(tmp,"radioGroup= %d",g);
d1199 1
a1199 1
		sprintf(tbuf,"%d",kc);
d1203 2
a1204 2
		 sprintf(buf,"permanentOverlay%d= %s",ndx,kn);
	    else sprintf(buf,"overlay%d= %s",ndx,kn);
@


1.1
log
@Initial revision
@
text
@a0 1
/* $Xorg: xkbtext.c,v 1.3 2000/08/17 19:46:44 cpqbld Exp $ */
a25 1
/* $XFree86: xc/lib/xkbfile/xkbtext.c,v 3.11 2002/12/21 18:49:02 paulo Exp $ */
d43 1
a43 1
#include <X11/extensions/XKBstr.h>
d45 2
a46 2
#include <X11/extensions/XKBsrv.h>
#include <X11/extensions/XKBgeom.h>
d72 1
a72 1
XkbAtomText(Display *dpy,Atom atm,unsigned format)
d76 1
a76 1
    tmp= XkbAtomGetString(dpy,atm);
d104 1
a104 1
XkbVModIndexText(Display *dpy,XkbDescPtr xkb,unsigned ndx,unsigned format)
d119 1
a119 1
	 tmp= XkbAtomGetString(dpy,vmodNames[ndx]);
d138 1
a138 2
XkbVModMaskText(	Display *	dpy,
			XkbDescPtr	xkb,
d165 1
a165 1
		tmp= XkbVModIndexText(dpy,xkb,i,format);
a447 94
char *
XkbAccessXDetailText(unsigned state,unsigned format)
{
char *buf,*prefix;

    buf= tbGetBuffer(32);
    if (format==XkbMessage)	prefix= "";
    else			prefix= "XkbAXN_";
    switch (state){
	case XkbAXN_SKPress:	sprintf(buf,"%sSKPress",prefix); break;
	case XkbAXN_SKAccept:	sprintf(buf,"%sSKAccept",prefix); break;
	case XkbAXN_SKRelease:	sprintf(buf,"%sSKRelease",prefix); break;
	case XkbAXN_SKReject:	sprintf(buf,"%sSKReject",prefix); break;
	case XkbAXN_BKAccept:	sprintf(buf,"%sBKAccept",prefix); break;
	case XkbAXN_BKReject:	sprintf(buf,"%sBKReject",prefix); break;
	case XkbAXN_AXKWarning:	sprintf(buf,"%sAXKWarning",prefix); break;
	default:		sprintf(buf,"ILLEGAL"); break;
    }
    return buf;
}

static char *nknNames[] = {
	"keycodes", "geometry", "deviceID"
};
#define	NUM_NKN	(sizeof(nknNames)/sizeof(char *))

char *
XkbNKNDetailMaskText(unsigned detail,unsigned format)
{
char *buf,*prefix,*suffix;
register int 		i;
register unsigned	bit;
int			len,plen,slen;


    if ((detail&XkbAllNewKeyboardEventsMask)==0) {
	char *tmp = "";
	if (format==XkbCFile)			tmp= "0";
	else if (format==XkbMessage)		tmp= "none";
	buf=  tbGetBuffer(strlen(tmp)+1);
	strcpy(buf,tmp);
	return buf;
    }
    else if ((detail&XkbAllNewKeyboardEventsMask)==XkbAllNewKeyboardEventsMask){
	char *	tmp;
	if (format==XkbCFile)		tmp= "XkbAllNewKeyboardEventsMask";
	else 				tmp= "all";
	buf=  tbGetBuffer(strlen(tmp)+1);
	strcpy(buf,tmp);
	return buf;
    }
    if (format==XkbMessage) {
	prefix= "";
	suffix= "";
	slen= plen= 0;
    }
    else {
	prefix= "XkbNKN_";
	plen= 7;
	if (format==XkbCFile)
	     suffix= "Mask";
	else suffix= "";
	slen= strlen(suffix);
    }
    for (len=0,i=0,bit=1;i<NUM_NKN;i++,bit<<=1) {
	if (detail&bit) {
	    if (len!=0)	len+= 1;	/* room for '+' or '|' */
	    len+= plen+slen+strlen(nknNames[i]);
	}
    }
    buf= tbGetBuffer(len+1);
    buf[0]= '\0';
    for (len=0,i=0,bit=1;i<NUM_NKN;i++,bit<<=1) {
	if (detail&bit) {
	    if (len!=0) {
		if (format==XkbCFile)	buf[len++]= '|';
		else			buf[len++]= '+';
	    }
	    if (plen) {
		strcpy(&buf[len],prefix);
		len+= plen;
	    }
	    strcpy(&buf[len],nknNames[i]);
	    len+= strlen(nknNames[i]);
	    if (slen) {
		strcpy(&buf[len],suffix);
		len+= slen;
	    }
	}
    }
    buf[len++]= '\0';
    return buf;
}

d669 1
a669 1
CopyNoActionArgs(Display *dpy,XkbDescPtr xkb,XkbAction *action,char *buf,int*sz)
d675 1
a675 1
CopyModActionArgs(Display *dpy,XkbDescPtr xkb,XkbAction *action,char *buf,
d688 1
a688 1
		     XkbVModMaskText(dpy,xkb,act->real_mods,tmp,XkbXKBFile),
d703 1
a703 1
CopyGroupActionArgs(Display *dpy,XkbDescPtr xkb,XkbAction *action,char *buf,
d728 1
a728 1
CopyMovePtrArgs(Display *dpy,XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
d753 1
a753 1
CopyPtrBtnArgs(Display *dpy,XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
d787 1
a787 1
CopySetPtrDfltArgs(Display *dpy,XkbDescPtr xkb,XkbAction *action,char *buf,
d805 1
a805 1
CopyISOLockArgs(Display *dpy,XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
d833 1
a833 1
		TryCopyStr(buf,XkbVModMaskText(dpy,xkb,0,tmp,XkbXKBFile),sz);
d867 1
a867 1
CopySwitchScreenArgs(Display *dpy,XkbDescPtr xkb,XkbAction *action,char *buf,
d886 1
a886 1
CopySetLockControlsArgs(Display *dpy,XkbDescPtr xkb,XkbAction *action,
d973 1
a973 1
CopyActionMessageArgs(Display *dpy,XkbDescPtr xkb,XkbAction *action,char *buf,
d1000 1
a1000 1
CopyRedirectKeyArgs(Display *dpy,XkbDescPtr xkb,XkbAction *action,char *buf,
d1024 1
a1024 1
	tmp= XkbVModMaskText(dpy,xkb,act->mods,vmods,XkbXKBFile);
d1030 1
a1030 1
	    tmp= XkbVModMaskText(dpy,xkb,act->mods_mask&act->mods,
d1036 1
a1036 1
	    tmp= XkbVModMaskText(dpy,xkb,act->mods_mask&(~act->mods),
d1047 1
a1047 1
CopyDeviceBtnArgs(Display *dpy,XkbDescPtr xkb,XkbAction *action,char *buf,
d1080 1
a1080 1
CopyOtherArgs(Display *dpy,XkbDescPtr xkb,XkbAction *action,char *buf,int *sz)
a1097 1
	Display *	/* dpy */,
d1129 1
a1129 1
XkbActionText(Display *dpy,XkbDescPtr xkb,XkbAction *action,unsigned format)
d1146 2
a1147 2
	     (*copyActionArgs[action->type])(dpy,xkb,action,buf,&sz);
	else CopyOtherArgs(dpy,xkb,action,buf,&sz);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
d27 1
d47 1
a47 1
#include <xkbsrv.h>
d448 94
@

