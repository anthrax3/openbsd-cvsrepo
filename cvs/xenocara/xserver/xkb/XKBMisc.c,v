head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.6
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.14
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.12
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.10
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.8
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.11;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.20;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.35;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#elif defined(HAVE_CONFIG_H)
#include <config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include <X11/keysym.h>
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>

/***====================================================================***/

#define	CORE_SYM(i)	(i<map_width?core_syms[i]:NoSymbol)
#define	XKB_OFFSET(g,l)	(((g)*groupsWidth)+(l))

int
XkbKeyTypesForCoreSymbols(XkbDescPtr xkb,
                          int map_width,
                          KeySym * core_syms,
                          unsigned int protected,
                          int *types_inout, KeySym * xkb_syms_rtrn)
{
    register int i;
    unsigned int empty;
    int nSyms[XkbNumKbdGroups];
    int nGroups, tmp, groupsWidth;
    BOOL replicated = FALSE;

    /* Section 12.2 of the protocol describes this process in more detail */
    /* Step 1:  find the # of symbols in the core mapping per group */
    groupsWidth = 2;
    for (i = 0; i < XkbNumKbdGroups; i++) {
        if ((protected & (1 << i)) && (types_inout[i] < xkb->map->num_types)) {
            nSyms[i] = xkb->map->types[types_inout[i]].num_levels;
            if (nSyms[i] > groupsWidth)
                groupsWidth = nSyms[i];
        }
        else {
            types_inout[i] = XkbTwoLevelIndex;  /* don't really know, yet */
            nSyms[i] = 2;
        }
    }
    if (nSyms[XkbGroup1Index] < 2)
        nSyms[XkbGroup1Index] = 2;
    if (nSyms[XkbGroup2Index] < 2)
        nSyms[XkbGroup2Index] = 2;
    /* Step 2:  Copy the symbols from the core ordering to XKB ordering */
    /*          symbols in the core are in the order:                   */
    /*          G1L1 G1L2 G2L1 G2L2 [G1L[3-n]] [G2L[3-n]] [G3L*] [G3L*] */
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup1Index, 0)] = CORE_SYM(0);
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup1Index, 1)] = CORE_SYM(1);
    for (i = 2; i < nSyms[XkbGroup1Index]; i++) {
        xkb_syms_rtrn[XKB_OFFSET(XkbGroup1Index, i)] = CORE_SYM(2 + i);
    }
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup2Index, 0)] = CORE_SYM(2);
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup2Index, 1)] = CORE_SYM(3);
    tmp = 2 + (nSyms[XkbGroup1Index] - 2);      /* offset to extra group2 syms */
    for (i = 2; i < nSyms[XkbGroup2Index]; i++) {
        xkb_syms_rtrn[XKB_OFFSET(XkbGroup2Index, i)] = CORE_SYM(tmp + i);
    }

    /* Special case: if only the first group is explicit, and the symbols
     * replicate across all groups, then we have a Section 12.4 replication */
    if ((protected & ~XkbExplicitKeyType1Mask) == 0) {
        int j, width = nSyms[XkbGroup1Index];

        replicated = TRUE;

        /* Check ABAB in ABABCDECDEABCDE */
        if ((width > 0 && CORE_SYM(0) != CORE_SYM(2)) ||
            (width > 1 && CORE_SYM(1) != CORE_SYM(3)))
            replicated = FALSE;

        /* Check CDECDE in ABABCDECDEABCDE */
        for (i = 2; i < width && replicated; i++) {
            if (CORE_SYM(2 + i) != CORE_SYM(i + width))
                replicated = FALSE;
        }

        /* Check ABCDE in ABABCDECDEABCDE */
        for (j = 2; replicated &&
             j < XkbNumKbdGroups && map_width >= width * (j + 1); j++) {
            for (i = 0; i < width && replicated; i++) {
                if (CORE_SYM(((i < 2) ? i : 2 + i)) != CORE_SYM(i + width * j))
                    replicated = FALSE;
            }
        }
    }

    if (replicated) {
        nSyms[XkbGroup2Index] = 0;
        nSyms[XkbGroup3Index] = 0;
        nSyms[XkbGroup4Index] = 0;
        nGroups = 1;
    }
    else {
        tmp = nSyms[XkbGroup1Index] + nSyms[XkbGroup2Index];
        if ((tmp >= map_width) &&
            ((protected & (XkbExplicitKeyType3Mask | XkbExplicitKeyType4Mask))
             == 0)) {
            nSyms[XkbGroup3Index] = 0;
            nSyms[XkbGroup4Index] = 0;
            nGroups = 2;
        }
        else {
            nGroups = 3;
            for (i = 0; i < nSyms[XkbGroup3Index]; i++, tmp++) {
                xkb_syms_rtrn[XKB_OFFSET(XkbGroup3Index, i)] = CORE_SYM(tmp);
            }
            if ((tmp < map_width) || (protected & XkbExplicitKeyType4Mask)) {
                nGroups = 4;
                for (i = 0; i < nSyms[XkbGroup4Index]; i++, tmp++) {
                    xkb_syms_rtrn[XKB_OFFSET(XkbGroup4Index, i)] =
                        CORE_SYM(tmp);
                }
            }
            else {
                nSyms[XkbGroup4Index] = 0;
            }
        }
    }
    /* steps 3&4: alphanumeric expansion,  assign canonical types */
    empty = 0;
    for (i = 0; i < nGroups; i++) {
        KeySym *syms;

        syms = &xkb_syms_rtrn[XKB_OFFSET(i, 0)];
        if ((nSyms[i] > 1) && (syms[1] == NoSymbol) && (syms[0] != NoSymbol)) {
            KeySym upper, lower;

            XkbConvertCase(syms[0], &lower, &upper);
            if (upper != lower) {
                xkb_syms_rtrn[XKB_OFFSET(i, 0)] = lower;
                xkb_syms_rtrn[XKB_OFFSET(i, 1)] = upper;
                if ((protected & (1 << i)) == 0)
                    types_inout[i] = XkbAlphabeticIndex;
            }
            else if ((protected & (1 << i)) == 0) {
                types_inout[i] = XkbOneLevelIndex;
                /*      nSyms[i]=       1; */
            }
        }
        if (((protected & (1 << i)) == 0) &&
            (types_inout[i] == XkbTwoLevelIndex)) {
            if (XkbKSIsKeypad(syms[0]) || XkbKSIsKeypad(syms[1]))
                types_inout[i] = XkbKeypadIndex;
            else {
                KeySym upper, lower;

                XkbConvertCase(syms[0], &lower, &upper);
                if ((syms[0] == lower) && (syms[1] == upper))
                    types_inout[i] = XkbAlphabeticIndex;
            }
        }
        if (syms[0] == NoSymbol) {
            register int n;
            Bool found;

            for (n = 1, found = FALSE; (!found) && (n < nSyms[i]); n++) {
                found = (syms[n] != NoSymbol);
            }
            if (!found)
                empty |= (1 << i);
        }
    }
    /* step 5: squoosh out empty groups */
    if (empty) {
        for (i = nGroups - 1; i >= 0; i--) {
            if (((empty & (1 << i)) == 0) || (protected & (1 << i)))
                break;
            nGroups--;
        }
    }
    if (nGroups < 1)
        return 0;

    /* step 6: replicate group 1 into group two, if necessary */
    if ((nGroups > 1) &&
        ((empty & (XkbGroup1Mask | XkbGroup2Mask)) == XkbGroup2Mask)) {
        if ((protected & (XkbExplicitKeyType1Mask | XkbExplicitKeyType2Mask)) ==
            0) {
            nSyms[XkbGroup2Index] = nSyms[XkbGroup1Index];
            types_inout[XkbGroup2Index] = types_inout[XkbGroup1Index];
            memcpy((char *) &xkb_syms_rtrn[2], (char *) xkb_syms_rtrn,
                   2 * sizeof(KeySym));
        }
        else if (types_inout[XkbGroup1Index] == types_inout[XkbGroup2Index]) {
            memcpy((char *) &xkb_syms_rtrn[nSyms[XkbGroup1Index]],
                   (char *) xkb_syms_rtrn,
                   nSyms[XkbGroup1Index] * sizeof(KeySym));
        }
    }

    /* step 7: check for all groups identical or all width 1
     *
     * Special feature: if group 1 has an explicit type and all other groups
     * have canonical types with same symbols, we assume it's info lost from
     * the core replication.
     */
    if (nGroups > 1) {
        Bool sameType, allOneLevel, canonical = TRUE;

        allOneLevel = (xkb->map->types[types_inout[0]].num_levels == 1);
        for (i = 1, sameType = TRUE; (allOneLevel || sameType) && (i < nGroups);
             i++) {
            sameType = (sameType &&
                        (types_inout[i] == types_inout[XkbGroup1Index]));
            if (allOneLevel)
                allOneLevel = (xkb->map->types[types_inout[i]].num_levels == 1);
            if (types_inout[i] > XkbLastRequiredType)
                canonical = FALSE;
        }
        if (((sameType) || canonical) &&
            (!(protected &
               (XkbExplicitKeyTypesMask & ~XkbExplicitKeyType1Mask)))) {
            register int s;
            Bool identical;

            for (i = 1, identical = TRUE; identical && (i < nGroups); i++) {
                KeySym *syms;

                if (nSyms[i] != nSyms[XkbGroup1Index])
                    identical = FALSE;
                syms = &xkb_syms_rtrn[XKB_OFFSET(i, 0)];
                for (s = 0; identical && (s < nSyms[i]); s++) {
                    if (syms[s] != xkb_syms_rtrn[s])
                        identical = FALSE;
                }
            }
            if (identical)
                nGroups = 1;
        }
        if (allOneLevel && (nGroups > 1)) {
            KeySym *syms;

            syms = &xkb_syms_rtrn[nSyms[XkbGroup1Index]];
            nSyms[XkbGroup1Index] = 1;
            for (i = 1; i < nGroups; i++) {
                xkb_syms_rtrn[i] = syms[0];
                syms += nSyms[i];
                nSyms[i] = 1;
            }
        }
    }
    return nGroups;
}

static XkbSymInterpretPtr
_XkbFindMatchingInterp(XkbDescPtr xkb,
                       KeySym sym, unsigned int real_mods, unsigned int level)
{
    register unsigned i;
    XkbSymInterpretPtr interp, rtrn;
    CARD8 mods;

    rtrn = NULL;
    interp = xkb->compat->sym_interpret;
    for (i = 0; i < xkb->compat->num_si; i++, interp++) {
        if ((interp->sym == NoSymbol) || (sym == interp->sym)) {
            int match;

            if ((level == 0) || ((interp->match & XkbSI_LevelOneOnly) == 0))
                mods = real_mods;
            else
                mods = 0;
            switch (interp->match & XkbSI_OpMask) {
            case XkbSI_NoneOf:
                match = ((interp->mods & mods) == 0);
                break;
            case XkbSI_AnyOfOrNone:
                match = ((mods == 0) || ((interp->mods & mods) != 0));
                break;
            case XkbSI_AnyOf:
                match = ((interp->mods & mods) != 0);
                break;
            case XkbSI_AllOf:
                match = ((interp->mods & mods) == interp->mods);
                break;
            case XkbSI_Exactly:
                match = (interp->mods == mods);
                break;
            default:
                match = 0;
                break;
            }
            if (match) {
                if (interp->sym != NoSymbol) {
                    return interp;
                }
                else if (rtrn == NULL) {
                    rtrn = interp;
                }
            }
        }
    }
    return rtrn;
}

static void
_XkbAddKeyChange(KeyCode *pFirst, unsigned char *pNum, KeyCode newKey)
{
    KeyCode last;

    last = (*pFirst) + (*pNum);
    if (newKey < *pFirst) {
        *pFirst = newKey;
        *pNum = (last - newKey) + 1;
    }
    else if (newKey > last) {
        *pNum = (last - *pFirst) + 1;
    }
    return;
}

static void
_XkbSetActionKeyMods(XkbDescPtr xkb, XkbAction *act, unsigned mods)
{
    unsigned tmp;

    switch (act->type) {
    case XkbSA_SetMods:
    case XkbSA_LatchMods:
    case XkbSA_LockMods:
        if (act->mods.flags & XkbSA_UseModMapMods)
            act->mods.real_mods = act->mods.mask = mods;
        if ((tmp = XkbModActionVMods(&act->mods)) != 0) {
            XkbVirtualModsToReal(xkb, tmp, &tmp);
            act->mods.mask |= tmp;
        }
        break;
    case XkbSA_ISOLock:
        if (act->iso.flags & XkbSA_UseModMapMods)
            act->iso.real_mods = act->iso.mask = mods;
        if ((tmp = XkbModActionVMods(&act->iso)) != 0) {
            XkbVirtualModsToReal(xkb, tmp, &tmp);
            act->iso.mask |= tmp;
        }
        break;
    }
    return;
}

#define	IBUF_SIZE	8

Bool
XkbApplyCompatMapToKey(XkbDescPtr xkb, KeyCode key, XkbChangesPtr changes)
{
    KeySym *syms;
    unsigned char explicit, mods;
    XkbSymInterpretPtr *interps, ibuf[IBUF_SIZE];
    int n, nSyms, found;
    unsigned changed, tmp;

    if ((!xkb) || (!xkb->map) || (!xkb->map->key_sym_map) ||
        (!xkb->compat) || (!xkb->compat->sym_interpret) ||
        (key < xkb->min_key_code) || (key > xkb->max_key_code)) {
        return FALSE;
    }
    if (((!xkb->server) || (!xkb->server->key_acts)) &&
        (XkbAllocServerMap(xkb, XkbAllServerInfoMask, 0) != Success)) {
        return FALSE;
    }
    changed = 0;                /* keeps track of what has changed in _this_ call */
    explicit = xkb->server->explicit[key];
    if (explicit & XkbExplicitInterpretMask)    /* nothing to do */
        return TRUE;
    mods = (xkb->map->modmap ? xkb->map->modmap[key] : 0);
    nSyms = XkbKeyNumSyms(xkb, key);
    syms = XkbKeySymsPtr(xkb, key);
    if (nSyms > IBUF_SIZE) {
        interps = calloc(nSyms, sizeof(XkbSymInterpretPtr));
        if (interps == NULL) {
            interps = ibuf;
            nSyms = IBUF_SIZE;
        }
    }
    else {
        interps = ibuf;
    }
    found = 0;
    for (n = 0; n < nSyms; n++) {
        unsigned level = (n % XkbKeyGroupsWidth(xkb, key));

        interps[n] = NULL;
        if (syms[n] != NoSymbol) {
            interps[n] = _XkbFindMatchingInterp(xkb, syms[n], mods, level);
            if (interps[n] && interps[n]->act.type != XkbSA_NoAction)
                found++;
            else
                interps[n] = NULL;
        }
    }
    /* 1/28/96 (ef) -- XXX! WORKING HERE */
    if (!found) {
        if (xkb->server->key_acts[key] != 0) {
            xkb->server->key_acts[key] = 0;
            changed |= XkbKeyActionsMask;
        }
    }
    else {
        XkbAction *pActs;
        unsigned int new_vmodmask;

        changed |= XkbKeyActionsMask;
        pActs = XkbResizeKeyActions(xkb, key, nSyms);
        if (!pActs) {
            if (nSyms > IBUF_SIZE)
                free(interps);
            return FALSE;
        }
        new_vmodmask = 0;
        for (n = 0; n < nSyms; n++) {
            if (interps[n]) {
                unsigned effMods;

                pActs[n] = *((XkbAction *) &interps[n]->act);
                if ((n == 0) || ((interps[n]->match & XkbSI_LevelOneOnly) == 0)) {
                    effMods = mods;
                    if (interps[n]->virtual_mod != XkbNoModifier)
                        new_vmodmask |= (1 << interps[n]->virtual_mod);
                }
                else
                    effMods = 0;
                _XkbSetActionKeyMods(xkb, &pActs[n], effMods);
            }
            else
                pActs[n].type = XkbSA_NoAction;
        }
        if (((explicit & XkbExplicitVModMapMask) == 0) &&
            (xkb->server->vmodmap[key] != new_vmodmask)) {
            changed |= XkbVirtualModMapMask;
            xkb->server->vmodmap[key] = new_vmodmask;
        }
        if (interps[0]) {
            if ((interps[0]->flags & XkbSI_LockingKey) &&
                ((explicit & XkbExplicitBehaviorMask) == 0)) {
                xkb->server->behaviors[key].type = XkbKB_Lock;
                changed |= XkbKeyBehaviorsMask;
            }
            if (((explicit & XkbExplicitAutoRepeatMask) == 0) && (xkb->ctrls)) {
                CARD8 old;

                old = BitIsOn(xkb->ctrls->per_key_repeat, key);
                if (interps[0]->flags & XkbSI_AutoRepeat)
                    SetBit(xkb->ctrls->per_key_repeat, key);
                else
                    ClearBit(xkb->ctrls->per_key_repeat, key);
                if (changes && old != BitIsOn(xkb->ctrls->per_key_repeat, key))
                    changes->ctrls.changed_ctrls |= XkbPerKeyRepeatMask;
            }
        }
    }
    if ((!found) || (interps[0] == NULL)) {
        if (((explicit & XkbExplicitAutoRepeatMask) == 0) && (xkb->ctrls)) {
            CARD8 old;

            old = BitIsOn(xkb->ctrls->per_key_repeat, key);
            SetBit(xkb->ctrls->per_key_repeat, key);
            if (changes && (old != BitIsOn(xkb->ctrls->per_key_repeat, key)))
                changes->ctrls.changed_ctrls |= XkbPerKeyRepeatMask;
        }
        if (((explicit & XkbExplicitBehaviorMask) == 0) &&
            (xkb->server->behaviors[key].type == XkbKB_Lock)) {
            xkb->server->behaviors[key].type = XkbKB_Default;
            changed |= XkbKeyBehaviorsMask;
        }
    }
    if (changes) {
        XkbMapChangesPtr mc;

        mc = &changes->map;
        tmp = (changed & mc->changed);
        if (tmp & XkbKeyActionsMask)
            _XkbAddKeyChange(&mc->first_key_act, &mc->num_key_acts, key);
        else if (changed & XkbKeyActionsMask) {
            mc->changed |= XkbKeyActionsMask;
            mc->first_key_act = key;
            mc->num_key_acts = 1;
        }
        if (tmp & XkbKeyBehaviorsMask) {
            _XkbAddKeyChange(&mc->first_key_behavior, &mc->num_key_behaviors,
                             key);
        }
        else if (changed & XkbKeyBehaviorsMask) {
            mc->changed |= XkbKeyBehaviorsMask;
            mc->first_key_behavior = key;
            mc->num_key_behaviors = 1;
        }
        if (tmp & XkbVirtualModMapMask)
            _XkbAddKeyChange(&mc->first_vmodmap_key, &mc->num_vmodmap_keys,
                             key);
        else if (changed & XkbVirtualModMapMask) {
            mc->changed |= XkbVirtualModMapMask;
            mc->first_vmodmap_key = key;
            mc->num_vmodmap_keys = 1;
        }
        mc->changed |= changed;
    }
    if (interps != ibuf)
        free(interps);
    return TRUE;
}

Status
XkbChangeTypesOfKey(XkbDescPtr xkb,
                    int key,
                    int nGroups,
                    unsigned groups, int *newTypesIn, XkbMapChangesPtr changes)
{
    XkbKeyTypePtr pOldType, pNewType;
    register int i;
    int width, nOldGroups, oldWidth, newTypes[XkbNumKbdGroups];

    if ((!xkb) || (!XkbKeycodeInRange(xkb, key)) || (!xkb->map) ||
        (!xkb->map->types) || (!newTypesIn) ||
        ((groups & XkbAllGroupsMask) == 0) || (nGroups > XkbNumKbdGroups)) {
        return BadMatch;
    }
    if (nGroups == 0) {
        for (i = 0; i < XkbNumKbdGroups; i++) {
            xkb->map->key_sym_map[key].kt_index[i] = XkbOneLevelIndex;
        }
        i = xkb->map->key_sym_map[key].group_info;
        i = XkbSetNumGroups(i, 0);
        xkb->map->key_sym_map[key].group_info = i;
        XkbResizeKeySyms(xkb, key, 0);
        return Success;
    }

    nOldGroups = XkbKeyNumGroups(xkb, key);
    oldWidth = XkbKeyGroupsWidth(xkb, key);
    for (width = i = 0; i < nGroups; i++) {
        if (groups & (1 << i))
            newTypes[i] = newTypesIn[i];
        else if (i < nOldGroups)
            newTypes[i] = XkbKeyKeyTypeIndex(xkb, key, i);
        else if (nOldGroups > 0)
            newTypes[i] = XkbKeyKeyTypeIndex(xkb, key, XkbGroup1Index);
        else
            newTypes[i] = XkbTwoLevelIndex;
        if (newTypes[i] > xkb->map->num_types)
            return BadMatch;
        pNewType = &xkb->map->types[newTypes[i]];
        if (pNewType->num_levels > width)
            width = pNewType->num_levels;
    }
    if ((xkb->ctrls) && (nGroups > xkb->ctrls->num_groups))
        xkb->ctrls->num_groups = nGroups;
    if ((width != oldWidth) || (nGroups != nOldGroups)) {
        KeySym oldSyms[XkbMaxSymsPerKey], *pSyms;
        int nCopy;

        if (nOldGroups == 0) {
            pSyms = XkbResizeKeySyms(xkb, key, width * nGroups);
            if (pSyms != NULL) {
                i = xkb->map->key_sym_map[key].group_info;
                i = XkbSetNumGroups(i, nGroups);
                xkb->map->key_sym_map[key].group_info = i;
                xkb->map->key_sym_map[key].width = width;
                for (i = 0; i < nGroups; i++) {
                    xkb->map->key_sym_map[key].kt_index[i] = newTypes[i];
                }
                return Success;
            }
            return BadAlloc;
        }
        pSyms = XkbKeySymsPtr(xkb, key);
        memcpy(oldSyms, pSyms, XkbKeyNumSyms(xkb, key) * sizeof(KeySym));
        pSyms = XkbResizeKeySyms(xkb, key, width * nGroups);
        if (pSyms == NULL)
            return BadAlloc;
        memset(pSyms, 0, width * nGroups * sizeof(KeySym));
        for (i = 0; (i < nGroups) && (i < nOldGroups); i++) {
            pOldType = XkbKeyKeyType(xkb, key, i);
            pNewType = &xkb->map->types[newTypes[i]];
            if (pNewType->num_levels > pOldType->num_levels)
                nCopy = pOldType->num_levels;
            else
                nCopy = pNewType->num_levels;
            memcpy(&pSyms[i * width], &oldSyms[i * oldWidth],
                   nCopy * sizeof(KeySym));
        }
        if (XkbKeyHasActions(xkb, key)) {
            XkbAction oldActs[XkbMaxSymsPerKey], *pActs;

            pActs = XkbKeyActionsPtr(xkb, key);
            memcpy(oldActs, pActs, XkbKeyNumSyms(xkb, key) * sizeof(XkbAction));
            pActs = XkbResizeKeyActions(xkb, key, width * nGroups);
            if (pActs == NULL)
                return BadAlloc;
            memset(pActs, 0, width * nGroups * sizeof(XkbAction));
            for (i = 0; (i < nGroups) && (i < nOldGroups); i++) {
                pOldType = XkbKeyKeyType(xkb, key, i);
                pNewType = &xkb->map->types[newTypes[i]];
                if (pNewType->num_levels > pOldType->num_levels)
                    nCopy = pOldType->num_levels;
                else
                    nCopy = pNewType->num_levels;
                memcpy(&pActs[i * width], &oldActs[i * oldWidth],
                       nCopy * sizeof(XkbAction));
            }
        }
        i = xkb->map->key_sym_map[key].group_info;
        i = XkbSetNumGroups(i, nGroups);
        xkb->map->key_sym_map[key].group_info = i;
        xkb->map->key_sym_map[key].width = width;
    }
    width = 0;
    for (i = 0; i < nGroups; i++) {
        xkb->map->key_sym_map[key].kt_index[i] = newTypes[i];
        if (xkb->map->types[newTypes[i]].num_levels > width)
            width = xkb->map->types[newTypes[i]].num_levels;
    }
    xkb->map->key_sym_map[key].width = width;
    if (changes != NULL) {
        if (changes->changed & XkbKeySymsMask) {
            _XkbAddKeyChange(&changes->first_key_sym, &changes->num_key_syms,
                             key);
        }
        else {
            changes->changed |= XkbKeySymsMask;
            changes->first_key_sym = key;
            changes->num_key_syms = 1;
        }
    }
    return Success;
}

/***====================================================================***/

Bool
XkbVirtualModsToReal(XkbDescPtr xkb, unsigned virtual_mask, unsigned *mask_rtrn)
{
    register int i, bit;
    register unsigned mask;

    if (xkb == NULL)
        return FALSE;
    if (virtual_mask == 0) {
        *mask_rtrn = 0;
        return TRUE;
    }
    if (xkb->server == NULL)
        return FALSE;
    for (i = mask = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) {
        if (virtual_mask & bit)
            mask |= xkb->server->vmods[i];
    }
    *mask_rtrn = mask;
    return TRUE;
}

/***====================================================================***/

static Bool
XkbUpdateActionVirtualMods(XkbDescPtr xkb, XkbAction *act, unsigned changed)
{
    unsigned int tmp;

    switch (act->type) {
    case XkbSA_SetMods:
    case XkbSA_LatchMods:
    case XkbSA_LockMods:
        if (((tmp = XkbModActionVMods(&act->mods)) & changed) != 0) {
            XkbVirtualModsToReal(xkb, tmp, &tmp);
            act->mods.mask = act->mods.real_mods;
            act->mods.mask |= tmp;
            return TRUE;
        }
        break;
    case XkbSA_ISOLock:
        if ((((tmp = XkbModActionVMods(&act->iso)) != 0) & changed) != 0) {
            XkbVirtualModsToReal(xkb, tmp, &tmp);
            act->iso.mask = act->iso.real_mods;
            act->iso.mask |= tmp;
            return TRUE;
        }
        break;
    }
    return FALSE;
}

static void
XkbUpdateKeyTypeVirtualMods(XkbDescPtr xkb,
                            XkbKeyTypePtr type,
                            unsigned int changed, XkbChangesPtr changes)
{
    register unsigned int i;
    unsigned int mask;

    XkbVirtualModsToReal(xkb, type->mods.vmods, &mask);
    type->mods.mask = type->mods.real_mods | mask;
    if ((type->map_count > 0) && (type->mods.vmods != 0)) {
        XkbKTMapEntryPtr entry;

        for (i = 0, entry = type->map; i < type->map_count; i++, entry++) {
            if (entry->mods.vmods != 0) {
                XkbVirtualModsToReal(xkb, entry->mods.vmods, &mask);
                entry->mods.mask = entry->mods.real_mods | mask;
                /* entry is active if vmods are bound */
                entry->active = (mask != 0);
            }
            else
                entry->active = 1;
        }
    }
    if (changes) {
        int type_ndx;

        type_ndx = type - xkb->map->types;
        if ((type_ndx < 0) || (type_ndx > xkb->map->num_types))
            return;
        if (changes->map.changed & XkbKeyTypesMask) {
            int last;

            last = changes->map.first_type + changes->map.num_types - 1;
            if (type_ndx < changes->map.first_type) {
                changes->map.first_type = type_ndx;
                changes->map.num_types = (last - type_ndx) + 1;
            }
            else if (type_ndx > last) {
                changes->map.num_types =
                    (type_ndx - changes->map.first_type) + 1;
            }
        }
        else {
            changes->map.changed |= XkbKeyTypesMask;
            changes->map.first_type = type_ndx;
            changes->map.num_types = 1;
        }
    }
    return;
}

Bool
XkbApplyVirtualModChanges(XkbDescPtr xkb, unsigned changed,
                          XkbChangesPtr changes)
{
    register int i;
    unsigned int checkState = 0;

    if ((!xkb) || (!xkb->map) || (changed == 0))
        return FALSE;
    for (i = 0; i < xkb->map->num_types; i++) {
        if (xkb->map->types[i].mods.vmods & changed)
            XkbUpdateKeyTypeVirtualMods(xkb, &xkb->map->types[i], changed,
                                        changes);
    }
    if (changed & xkb->ctrls->internal.vmods) {
        unsigned int newMask;

        XkbVirtualModsToReal(xkb, xkb->ctrls->internal.vmods, &newMask);
        newMask |= xkb->ctrls->internal.real_mods;
        if (xkb->ctrls->internal.mask != newMask) {
            xkb->ctrls->internal.mask = newMask;
            if (changes) {
                changes->ctrls.changed_ctrls |= XkbInternalModsMask;
                checkState = TRUE;
            }
        }
    }
    if (changed & xkb->ctrls->ignore_lock.vmods) {
        unsigned int newMask;

        XkbVirtualModsToReal(xkb, xkb->ctrls->ignore_lock.vmods, &newMask);
        newMask |= xkb->ctrls->ignore_lock.real_mods;
        if (xkb->ctrls->ignore_lock.mask != newMask) {
            xkb->ctrls->ignore_lock.mask = newMask;
            if (changes) {
                changes->ctrls.changed_ctrls |= XkbIgnoreLockModsMask;
                checkState = TRUE;
            }
        }
    }
    if (xkb->indicators != NULL) {
        XkbIndicatorMapPtr map;

        map = &xkb->indicators->maps[0];
        for (i = 0; i < XkbNumIndicators; i++, map++) {
            if (map->mods.vmods & changed) {
                unsigned int newMask;

                XkbVirtualModsToReal(xkb, map->mods.vmods, &newMask);
                newMask |= map->mods.real_mods;
                if (newMask != map->mods.mask) {
                    map->mods.mask = newMask;
                    if (changes) {
                        changes->indicators.map_changes |= (1 << i);
                        checkState = TRUE;
                    }
                }
            }
        }
    }
    if (xkb->compat != NULL) {
        XkbCompatMapPtr compat;

        compat = xkb->compat;
        for (i = 0; i < XkbNumKbdGroups; i++) {
            unsigned int newMask;

            XkbVirtualModsToReal(xkb, compat->groups[i].vmods, &newMask);
            newMask |= compat->groups[i].real_mods;
            if (compat->groups[i].mask != newMask) {
                compat->groups[i].mask = newMask;
                if (changes) {
                    changes->compat.changed_groups |= (1 << i);
                    checkState = TRUE;
                }
            }
        }
    }
    if (xkb->map && xkb->server) {
        int highChange = 0, lowChange = -1;

        for (i = xkb->min_key_code; i <= xkb->max_key_code; i++) {
            if (XkbKeyHasActions(xkb, i)) {
                register XkbAction *pAct;
                register int n;

                pAct = XkbKeyActionsPtr(xkb, i);
                for (n = XkbKeyNumActions(xkb, i); n > 0; n--, pAct++) {
                    if ((pAct->type != XkbSA_NoAction) &&
                        XkbUpdateActionVirtualMods(xkb, pAct, changed)) {
                        if (lowChange < 0)
                            lowChange = i;
                        highChange = i;
                    }
                }
            }
        }
        if (changes && (lowChange > 0)) {       /* something changed */
            if (changes->map.changed & XkbKeyActionsMask) {
                int last;

                if (changes->map.first_key_act < lowChange)
                    lowChange = changes->map.first_key_act;
                last =
                    changes->map.first_key_act + changes->map.num_key_acts - 1;
                if (last > highChange)
                    highChange = last;
            }
            changes->map.changed |= XkbKeyActionsMask;
            changes->map.first_key_act = lowChange;
            changes->map.num_key_acts = (highChange - lowChange) + 1;
        }
    }
    return checkState;
}
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d9 2
a10 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d12 1
a12 1
Silicon Graphics makes no representation about the suitability 
d16 2
a17 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d19 3
a21 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
@


1.6
log
@Update to xserver 1.11.2
@
text
@d48 5
a52 6
XkbKeyTypesForCoreSymbols(	XkbDescPtr	xkb,
				int		map_width,
				KeySym *	core_syms,
				unsigned int 	protected,
    				int *		types_inout,
				KeySym *	xkb_syms_rtrn)
d54 5
a58 5
register int	i;
unsigned int	empty;
int		nSyms[XkbNumKbdGroups];
int		nGroups,tmp,groupsWidth;
BOOL		replicated = FALSE;
d62 29
a90 29
    groupsWidth= 2;
    for (i=0;i<XkbNumKbdGroups;i++) {
	if ((protected&(1<<i))&&(types_inout[i]<xkb->map->num_types)) {
	    nSyms[i]= xkb->map->types[types_inout[i]].num_levels;
	    if (nSyms[i]>groupsWidth)
		groupsWidth= nSyms[i];
	}
	else {
	    types_inout[i]= XkbTwoLevelIndex;	/* don't really know, yet */
	    nSyms[i]= 2;
	}
    }
    if (nSyms[XkbGroup1Index]<2)
	nSyms[XkbGroup1Index]= 2;
    if (nSyms[XkbGroup2Index]<2)
	nSyms[XkbGroup2Index]= 2;
    /* Step 2:	Copy the symbols from the core ordering to XKB ordering	*/
    /*		symbols in the core are in the order:			*/
    /*		G1L1 G1L2 G2L1 G2L2 [G1L[3-n]] [G2L[3-n]] [G3L*] [G3L*]	*/
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup1Index,0)]= CORE_SYM(0);
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup1Index,1)]= CORE_SYM(1);
    for (i=2;i<nSyms[XkbGroup1Index];i++) {
	xkb_syms_rtrn[XKB_OFFSET(XkbGroup1Index,i)]= CORE_SYM(2+i);
    }
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup2Index,0)]= CORE_SYM(2);
    xkb_syms_rtrn[XKB_OFFSET(XkbGroup2Index,1)]= CORE_SYM(3);
    tmp= 2+(nSyms[XkbGroup1Index]-2); /* offset to extra group2 syms */
    for (i=2;i<nSyms[XkbGroup2Index];i++) {
	xkb_syms_rtrn[XKB_OFFSET(XkbGroup2Index,i)]= CORE_SYM(tmp+i);
d95 1
a95 2
    if ((protected & ~XkbExplicitKeyType1Mask) == 0)
    {
d106 1
a106 2
        for (i = 2; i < width && replicated; i++)
        {
d113 2
a114 5
                    j < XkbNumKbdGroups &&
                    map_width >= width * (j + 1); j++)
        {
            for (i = 0; i < width && replicated; i++)
            {
d121 25
a145 24
    if (replicated)
    {
	nSyms[XkbGroup2Index]= 0;
	nSyms[XkbGroup3Index]= 0;
	nSyms[XkbGroup4Index]= 0;
	nGroups= 1;
    } else
    {
        tmp= nSyms[XkbGroup1Index]+nSyms[XkbGroup2Index];
        if ((tmp>=map_width)&&
                ((protected&(XkbExplicitKeyType3Mask|XkbExplicitKeyType4Mask))==0)) {
            nSyms[XkbGroup3Index]= 0;
            nSyms[XkbGroup4Index]= 0;
            nGroups= 2;
        } else
        {
            nGroups= 3;
            for (i=0;i<nSyms[XkbGroup3Index];i++,tmp++) {
                xkb_syms_rtrn[XKB_OFFSET(XkbGroup3Index,i)]= CORE_SYM(tmp);
            }
            if ((tmp<map_width)||(protected&XkbExplicitKeyType4Mask)) {
                nGroups= 4;
                for (i=0;i<nSyms[XkbGroup4Index];i++,tmp++) {
                    xkb_syms_rtrn[XKB_OFFSET(XkbGroup4Index,i)]= CORE_SYM(tmp);
d149 1
a149 1
                nSyms[XkbGroup4Index]= 0;
d154 42
a195 37
    empty= 0;
    for (i=0;i<nGroups;i++) {
	KeySym *syms;
	syms= &xkb_syms_rtrn[XKB_OFFSET(i,0)];
	if ((nSyms[i]>1)&&(syms[1]==NoSymbol)&&(syms[0]!=NoSymbol)) {
	    KeySym upper,lower;
	    XkbConvertCase(syms[0],&lower,&upper);
	    if (upper!=lower) {
		xkb_syms_rtrn[XKB_OFFSET(i,0)]= lower;
		xkb_syms_rtrn[XKB_OFFSET(i,1)]= upper;
		if ((protected&(1<<i))==0)
		    types_inout[i]= XkbAlphabeticIndex;
	    }
	    else if ((protected&(1<<i))==0) {
		types_inout[i]= XkbOneLevelIndex;
	/*	nSyms[i]=	1;*/
	    }
	}
	if (((protected&(1<<i))==0)&&(types_inout[i]==XkbTwoLevelIndex)) {
	    if (XkbKSIsKeypad(syms[0])||XkbKSIsKeypad(syms[1]))
		types_inout[i]= XkbKeypadIndex;
	    else {
		KeySym upper,lower;
		XkbConvertCase(syms[0],&lower,&upper);
		if ((syms[0]==lower)&&(syms[1]==upper))
		    types_inout[i]= XkbAlphabeticIndex;
	    }
	}
	if (syms[0]==NoSymbol) {
	    register int n;
	    Bool	found;
	    for (n=1,found=FALSE;(!found)&&(n<nSyms[i]);n++) {
		found= (syms[n]!=NoSymbol);
	    }
	    if (!found)
		empty|= (1<<i);
	}
d199 5
a203 5
	for (i=nGroups-1;i>=0;i--) {
	    if (((empty&(1<<i))==0)||(protected&(1<<i)))
		break;
	    nGroups--;
	}
d205 2
a206 2
    if (nGroups<1)
	return 0;
d209 14
a222 12
    if ((nGroups>1)&&((empty&(XkbGroup1Mask|XkbGroup2Mask))==XkbGroup2Mask)) {
	if ((protected&(XkbExplicitKeyType1Mask|XkbExplicitKeyType2Mask))==0) {
	    nSyms[XkbGroup2Index]= nSyms[XkbGroup1Index];
	    types_inout[XkbGroup2Index]= types_inout[XkbGroup1Index];
	    memcpy((char *)&xkb_syms_rtrn[2],(char *)xkb_syms_rtrn,
							2*sizeof(KeySym));
	}
	else if (types_inout[XkbGroup1Index]==types_inout[XkbGroup2Index]) {
	    memcpy((char *)&xkb_syms_rtrn[nSyms[XkbGroup1Index]],
	    				(char *)xkb_syms_rtrn,
					nSyms[XkbGroup1Index]*sizeof(KeySym));
	}
d231 22
a252 16
    if (nGroups>1) {
	Bool sameType,allOneLevel, canonical = TRUE;
	allOneLevel= (xkb->map->types[types_inout[0]].num_levels==1);
	for (i=1,sameType=TRUE;(allOneLevel||sameType)&&(i<nGroups);i++) {
	    sameType=(sameType&&(types_inout[i]==types_inout[XkbGroup1Index]));
	    if (allOneLevel)
		allOneLevel= (xkb->map->types[types_inout[i]].num_levels==1);
	    if (types_inout[i] > XkbLastRequiredType)
		canonical = FALSE;
	}
	if (((sameType) || canonical)&&
	    (!(protected&(XkbExplicitKeyTypesMask&~XkbExplicitKeyType1Mask)))){
	    register int s;
	    Bool	identical;
	    for (i=1,identical=TRUE;identical&&(i<nGroups);i++) {
		KeySym *syms;
d255 20
a274 19
		syms= &xkb_syms_rtrn[XKB_OFFSET(i,0)];
		for (s=0;identical&&(s<nSyms[i]);s++) {
		    if (syms[s]!=xkb_syms_rtrn[s])
			identical= FALSE;
		}
	    }
	    if (identical)
		nGroups= 1;
	}
	if (allOneLevel && (nGroups>1)) {
	    KeySym *syms;
	    syms= &xkb_syms_rtrn[nSyms[XkbGroup1Index]];
	    nSyms[XkbGroup1Index]= 1;
	    for (i=1;i<nGroups;i++) {
		xkb_syms_rtrn[i]= syms[0];
		syms+= nSyms[i];
		nSyms[i]= 1;
	    }
	}
d280 2
a281 4
_XkbFindMatchingInterp(	XkbDescPtr	xkb,
			KeySym 		sym,
			unsigned int	real_mods,
			unsigned int	level)
d283 43
a325 41
register unsigned	 i;
XkbSymInterpretPtr	 interp,rtrn;
CARD8			 mods;

    rtrn= NULL;
    interp= xkb->compat->sym_interpret;
    for (i=0;i<xkb->compat->num_si;i++,interp++) {
	if ((interp->sym==NoSymbol)||(sym==interp->sym)) {
	    int match;
	    if ((level==0)||((interp->match&XkbSI_LevelOneOnly)==0))
		 mods= real_mods;
	    else mods= 0;
	    switch (interp->match&XkbSI_OpMask) {
		case XkbSI_NoneOf:
		    match= ((interp->mods&mods)==0);
		    break;
		case XkbSI_AnyOfOrNone:
		    match= ((mods==0)||((interp->mods&mods)!=0));
		    break;
		case XkbSI_AnyOf:
		    match= ((interp->mods&mods)!=0);
		    break;
		case XkbSI_AllOf:
		    match= ((interp->mods&mods)==interp->mods);
		    break;
		case XkbSI_Exactly:
		    match= (interp->mods==mods);
		    break;
		default:
		    match= 0;
		    break;
	    }
	    if (match) {
		if (interp->sym!=NoSymbol) {
		    return interp;
		}
		else if (rtrn==NULL) {
		    rtrn= interp;
		}
	    }
	}
d331 1
a331 1
_XkbAddKeyChange(KeyCode *pFirst,unsigned char *pNum,KeyCode newKey)
d333 1
a333 1
KeyCode	last;
d335 4
a338 4
    last= (*pFirst)+(*pNum);
    if (newKey<*pFirst) {
	*pFirst= newKey;
	*pNum= (last-newKey)+1;
d340 2
a341 2
    else if (newKey>last) {
	*pNum= (last-*pFirst)+1;
d347 1
a347 1
_XkbSetActionKeyMods(XkbDescPtr xkb,XkbAction *act,unsigned mods)
d349 1
a349 1
unsigned	tmp;
d352 18
a369 16
	case XkbSA_SetMods: case XkbSA_LatchMods: case XkbSA_LockMods:
	    if (act->mods.flags&XkbSA_UseModMapMods)
		act->mods.real_mods= act->mods.mask= mods;
	    if ((tmp= XkbModActionVMods(&act->mods))!=0) {
		XkbVirtualModsToReal(xkb,tmp,&tmp);
		act->mods.mask|= tmp;
	    }
	    break;
	case XkbSA_ISOLock:
	    if (act->iso.flags&XkbSA_UseModMapMods)
		act->iso.real_mods= act->iso.mask= mods;
	    if ((tmp= XkbModActionVMods(&act->iso))!=0) {
		XkbVirtualModsToReal(xkb,tmp,&tmp);
		act->iso.mask|= tmp;
	    }
	    break;
d377 1
a377 1
XkbApplyCompatMapToKey(XkbDescPtr xkb,KeyCode key,XkbChangesPtr changes)
d379 28
a406 28
KeySym *		syms;
unsigned char 		explicit,mods;
XkbSymInterpretPtr	*interps,ibuf[IBUF_SIZE]; 
int			n,nSyms,found;
unsigned		changed,tmp;

    if ((!xkb)||(!xkb->map)||(!xkb->map->key_sym_map)||
    			(!xkb->compat)||(!xkb->compat->sym_interpret)||
			(key<xkb->min_key_code)||(key>xkb->max_key_code)) {
	return FALSE;
    }
    if (((!xkb->server)||(!xkb->server->key_acts))&&
		(XkbAllocServerMap(xkb,XkbAllServerInfoMask,0)!=Success)) {
	return FALSE;
    }
    changed= 0;	/* keeps track of what has changed in _this_ call */
    explicit= xkb->server->explicit[key];
    if (explicit&XkbExplicitInterpretMask) /* nothing to do */
	return TRUE;
    mods= (xkb->map->modmap?xkb->map->modmap[key]:0);
    nSyms= XkbKeyNumSyms(xkb,key);
    syms= XkbKeySymsPtr(xkb,key);
    if (nSyms>IBUF_SIZE) {
	interps= calloc(nSyms, sizeof(XkbSymInterpretPtr));
	if (interps==NULL) {
	    interps= ibuf;
	    nSyms= IBUF_SIZE;
	}
d409 1
a409 1
	interps= ibuf;
d411 12
a422 10
    found= 0;
    for (n=0;n<nSyms;n++) {
	unsigned level= (n%XkbKeyGroupsWidth(xkb,key));
	interps[n]= NULL;
	if (syms[n]!=NoSymbol) {
	    interps[n]= _XkbFindMatchingInterp(xkb,syms[n],mods,level);
	    if (interps[n]&&interps[n]->act.type!=XkbSA_NoAction)
		found++;
	    else interps[n]= NULL;
	}
d426 4
a429 4
	if (xkb->server->key_acts[key]!=0) {
	    xkb->server->key_acts[key]= 0;
	    changed|= XkbKeyActionsMask;
	}
d432 6
a437 5
	XkbAction *pActs;
	unsigned int	new_vmodmask;
	changed|= XkbKeyActionsMask;
	pActs= XkbResizeKeyActions(xkb,key,nSyms);
	if (!pActs) {
d440 57
a496 1
	    return FALSE;
a497 52
	new_vmodmask= 0;
	for (n=0;n<nSyms;n++) {
	    if (interps[n]) {
		unsigned effMods;

		pActs[n]= *((XkbAction *)&interps[n]->act);
		if ((n==0)||((interps[n]->match&XkbSI_LevelOneOnly)==0)) {
		     effMods= mods;
		     if (interps[n]->virtual_mod!=XkbNoModifier)
			new_vmodmask|= (1<<interps[n]->virtual_mod);
		}
		else effMods= 0;
		_XkbSetActionKeyMods(xkb,&pActs[n],effMods);
	    }
	    else pActs[n].type= XkbSA_NoAction;
	}
	if (((explicit&XkbExplicitVModMapMask)==0)&&
				(xkb->server->vmodmap[key]!=new_vmodmask)) {
	    changed|= XkbVirtualModMapMask;
	    xkb->server->vmodmap[key]= new_vmodmask;
	}
	if (interps[0]) {
	    if ((interps[0]->flags&XkbSI_LockingKey)&&
				((explicit&XkbExplicitBehaviorMask)==0)) {
		xkb->server->behaviors[key].type= XkbKB_Lock;
		changed|= XkbKeyBehaviorsMask;
	    }
	    if (((explicit&XkbExplicitAutoRepeatMask)==0)&&(xkb->ctrls)) {
		CARD8 old;
		old= BitIsOn(xkb->ctrls->per_key_repeat, key);
		if (interps[0]->flags&XkbSI_AutoRepeat)
		    SetBit(xkb->ctrls->per_key_repeat, key);
		else
		    ClearBit(xkb->ctrls->per_key_repeat, key);
		if (changes && old != BitIsOn(xkb->ctrls->per_key_repeat, key))
		    changes->ctrls.changed_ctrls|= XkbPerKeyRepeatMask;
	    }
	}
    }
    if ((!found)||(interps[0]==NULL)) {
	if (((explicit&XkbExplicitAutoRepeatMask)==0)&&(xkb->ctrls)) {
	    CARD8 old;
	    old = BitIsOn(xkb->ctrls->per_key_repeat, key);
	    SetBit(xkb->ctrls->per_key_repeat, key);
	    if (changes && (old != BitIsOn(xkb->ctrls->per_key_repeat, key)))
		changes->ctrls.changed_ctrls|= XkbPerKeyRepeatMask;
	}
	if (((explicit&XkbExplicitBehaviorMask)==0)&&
		(xkb->server->behaviors[key].type==XkbKB_Lock)) {
		xkb->server->behaviors[key].type= XkbKB_Default;
		changed|= XkbKeyBehaviorsMask;
	}
d500 29
a528 27
	XkbMapChangesPtr	mc;
	mc= &changes->map;
	tmp= (changed&mc->changed);
	if (tmp&XkbKeyActionsMask)
	    _XkbAddKeyChange(&mc->first_key_act,&mc->num_key_acts,key);
	else if (changed&XkbKeyActionsMask) {
	    mc->changed|= XkbKeyActionsMask;
	    mc->first_key_act= key;
	    mc->num_key_acts= 1;
	}
	if (tmp&XkbKeyBehaviorsMask) {
	    _XkbAddKeyChange(&mc->first_key_behavior,&mc->num_key_behaviors,
	    								key);
	}
	else if (changed&XkbKeyBehaviorsMask) {
	    mc->changed|= XkbKeyBehaviorsMask;
	    mc->first_key_behavior= key;
	    mc->num_key_behaviors= 1;
	}
	if (tmp&XkbVirtualModMapMask)
	    _XkbAddKeyChange(&mc->first_vmodmap_key,&mc->num_vmodmap_keys,key);
	else if (changed&XkbVirtualModMapMask) {
	    mc->changed|= XkbVirtualModMapMask;
	    mc->first_vmodmap_key= key;
	    mc->num_vmodmap_keys= 1;
	}
	mc->changed|= changed;
d530 2
a531 2
    if (interps!=ibuf)
	free(interps);
d536 4
a539 6
XkbChangeTypesOfKey(	XkbDescPtr		 xkb,
			int		 	 key,
			int			 nGroups,
			unsigned	 	 groups,
			int	* 	 	 newTypesIn,
			XkbMapChangesPtr	 changes)
d541 115
a655 110
XkbKeyTypePtr	pOldType,pNewType;
register int	i;
int		width,nOldGroups,oldWidth,newTypes[XkbNumKbdGroups];

    if ((!xkb) || (!XkbKeycodeInRange(xkb,key)) || (!xkb->map) ||
	(!xkb->map->types)||(!newTypesIn)||((groups&XkbAllGroupsMask)==0)||
	(nGroups>XkbNumKbdGroups)) {
	return BadMatch;
    }
    if (nGroups==0) {
	for (i=0;i<XkbNumKbdGroups;i++) {
	    xkb->map->key_sym_map[key].kt_index[i]= XkbOneLevelIndex;
	}
	i= xkb->map->key_sym_map[key].group_info;
	i= XkbSetNumGroups(i,0);
	xkb->map->key_sym_map[key].group_info= i;
	XkbResizeKeySyms(xkb,key,0);
	return Success;
    }

    nOldGroups= XkbKeyNumGroups(xkb,key);
    oldWidth= XkbKeyGroupsWidth(xkb,key);
    for (width=i=0;i<nGroups;i++) {
	if (groups&(1<<i))
	     newTypes[i]=  newTypesIn[i];
	else if (i<nOldGroups)
	     newTypes[i]= XkbKeyKeyTypeIndex(xkb,key,i);
	else if (nOldGroups>0)
	     newTypes[i]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup1Index);
	else newTypes[i]= XkbTwoLevelIndex;
	if (newTypes[i]>xkb->map->num_types)
	    return BadMatch;
	pNewType= &xkb->map->types[newTypes[i]];
	if (pNewType->num_levels>width)
	    width= pNewType->num_levels;
    }
    if ((xkb->ctrls)&&(nGroups>xkb->ctrls->num_groups))
	xkb->ctrls->num_groups= nGroups;
    if ((width!=oldWidth)||(nGroups!=nOldGroups)) {
	KeySym		oldSyms[XkbMaxSymsPerKey],*pSyms;
	int		nCopy;

	if (nOldGroups==0) {
	    pSyms= XkbResizeKeySyms(xkb,key,width*nGroups);
	    if (pSyms!=NULL) {
		i= xkb->map->key_sym_map[key].group_info;
		i= XkbSetNumGroups(i,nGroups);
		xkb->map->key_sym_map[key].group_info= i;
		xkb->map->key_sym_map[key].width= width;
		for (i=0;i<nGroups;i++) {
		    xkb->map->key_sym_map[key].kt_index[i]= newTypes[i];
		}
		return Success;
	    }
	    return BadAlloc;
	}
	pSyms= XkbKeySymsPtr(xkb,key);
	memcpy(oldSyms,pSyms,XkbKeyNumSyms(xkb,key)*sizeof(KeySym));
	pSyms= XkbResizeKeySyms(xkb,key,width*nGroups);
	if (pSyms==NULL)
	    return BadAlloc;
	memset(pSyms, 0, width*nGroups*sizeof(KeySym));
	for (i=0;(i<nGroups)&&(i<nOldGroups);i++) {
	    pOldType= XkbKeyKeyType(xkb,key,i);
	    pNewType= &xkb->map->types[newTypes[i]];
	    if (pNewType->num_levels>pOldType->num_levels)
		 nCopy= pOldType->num_levels;
	    else nCopy= pNewType->num_levels;
	    memcpy(&pSyms[i*width],&oldSyms[i*oldWidth],nCopy*sizeof(KeySym));
	}
	if (XkbKeyHasActions(xkb,key)) {
	    XkbAction	oldActs[XkbMaxSymsPerKey],*pActs;
	    pActs= XkbKeyActionsPtr(xkb,key);
	    memcpy(oldActs,pActs,XkbKeyNumSyms(xkb,key)*sizeof(XkbAction));
	    pActs= XkbResizeKeyActions(xkb,key,width*nGroups);
	    if (pActs==NULL)
		return BadAlloc;
	    memset(pActs, 0, width*nGroups*sizeof(XkbAction));
	    for (i=0;(i<nGroups)&&(i<nOldGroups);i++) {
		pOldType= XkbKeyKeyType(xkb,key,i);
		pNewType= &xkb->map->types[newTypes[i]];
		if (pNewType->num_levels>pOldType->num_levels)
		     nCopy= pOldType->num_levels;
		else nCopy= pNewType->num_levels;
		memcpy(&pActs[i*width],&oldActs[i*oldWidth],
						nCopy*sizeof(XkbAction));
	    }
	}
	i= xkb->map->key_sym_map[key].group_info;
	i= XkbSetNumGroups(i,nGroups);
	xkb->map->key_sym_map[key].group_info= i;
	xkb->map->key_sym_map[key].width= width;
    }
    width= 0;
    for (i=0;i<nGroups;i++) {
	xkb->map->key_sym_map[key].kt_index[i]= newTypes[i];
	if (xkb->map->types[newTypes[i]].num_levels>width)
	    width= xkb->map->types[newTypes[i]].num_levels;
    }
    xkb->map->key_sym_map[key].width= width;
    if (changes!=NULL) {
	if (changes->changed&XkbKeySymsMask) {
	    _XkbAddKeyChange(&changes->first_key_sym,&changes->num_key_syms,
	    								key);
	}
	else {
	    changes->changed|= XkbKeySymsMask;
	    changes->first_key_sym= key;
	    changes->num_key_syms= 1;
	}
d663 1
a663 1
XkbVirtualModsToReal(XkbDescPtr xkb,unsigned virtual_mask,unsigned *mask_rtrn)
d665 2
a666 2
register int i,bit;
register unsigned mask;
d668 11
a678 11
    if (xkb==NULL)
	return FALSE;
    if (virtual_mask==0) {
	*mask_rtrn= 0;
	return TRUE;
    }
    if (xkb->server==NULL)
	return FALSE;
    for (i=mask=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (virtual_mask&bit)
	    mask|= xkb->server->vmods[i];
d680 1
a680 1
    *mask_rtrn= mask;
d687 1
a687 1
XkbUpdateActionVirtualMods(XkbDescPtr xkb,XkbAction *act,unsigned changed)
d689 1
a689 1
unsigned int	tmp;
d692 18
a709 16
	case XkbSA_SetMods: case XkbSA_LatchMods: case XkbSA_LockMods:
	    if (((tmp= XkbModActionVMods(&act->mods))&changed)!=0) {
		XkbVirtualModsToReal(xkb,tmp,&tmp);
		act->mods.mask= act->mods.real_mods;
		act->mods.mask|= tmp;
		return TRUE;
	    }
	    break;
	case XkbSA_ISOLock:
	    if ((((tmp= XkbModActionVMods(&act->iso))!=0)&changed)!=0) {
		XkbVirtualModsToReal(xkb,tmp,&tmp);
		act->iso.mask= act->iso.real_mods;
		act->iso.mask|= tmp;
		return TRUE;
	    }
	    break;
d715 3
a717 4
XkbUpdateKeyTypeVirtualMods(	XkbDescPtr	xkb,
				XkbKeyTypePtr	type,
				unsigned int	changed,
				XkbChangesPtr 	changes)
d719 2
a720 2
register unsigned int	i;
unsigned int		mask;
d722 15
a736 13
    XkbVirtualModsToReal(xkb,type->mods.vmods,&mask);
    type->mods.mask= type->mods.real_mods|mask;
    if ((type->map_count>0)&&(type->mods.vmods!=0)) {
	XkbKTMapEntryPtr entry;
	for (i=0,entry=type->map;i<type->map_count;i++,entry++) {
	    if (entry->mods.vmods!=0) {
		XkbVirtualModsToReal(xkb,entry->mods.vmods,&mask);
		entry->mods.mask=entry->mods.real_mods|mask;
		/* entry is active if vmods are bound*/
	    	entry->active= (mask!=0);
	    }
	    else entry->active= 1;
	}
d739 23
a761 20
	int	type_ndx;
	type_ndx= type-xkb->map->types;
	if ((type_ndx<0)||(type_ndx>xkb->map->num_types))
	    return;
	if (changes->map.changed&XkbKeyTypesMask) {
	    int last;
	    last= changes->map.first_type+changes->map.num_types-1;
	    if (type_ndx<changes->map.first_type) {
		changes->map.first_type= type_ndx;
		changes->map.num_types= (last-type_ndx)+1;
	    }
	    else if (type_ndx>last) {
		changes->map.num_types= (type_ndx-changes->map.first_type)+1;
	    }
	}
	else {
	    changes->map.changed|= XkbKeyTypesMask;
	    changes->map.first_type= type_ndx;
	    changes->map.num_types= 1;
	}
d767 2
a768 1
XkbApplyVirtualModChanges(XkbDescPtr xkb,unsigned changed,XkbChangesPtr changes)
d770 58
a827 2
register int	i;
unsigned int	checkState = 0;
d829 14
a842 63
    if ((!xkb) || (!xkb->map) || (changed==0))
	return FALSE;
    for (i=0;i<xkb->map->num_types;i++) {
	if (xkb->map->types[i].mods.vmods & changed)
	XkbUpdateKeyTypeVirtualMods(xkb,&xkb->map->types[i],changed,changes);
    }
    if (changed&xkb->ctrls->internal.vmods) {
	unsigned int	newMask;
	XkbVirtualModsToReal(xkb,xkb->ctrls->internal.vmods,&newMask);
	newMask|= xkb->ctrls->internal.real_mods;
	if (xkb->ctrls->internal.mask!=newMask) {
	    xkb->ctrls->internal.mask= newMask;
	    if (changes) {
		changes->ctrls.changed_ctrls|= XkbInternalModsMask;
		checkState= TRUE;
	    }
	}
    }
    if (changed&xkb->ctrls->ignore_lock.vmods) {
	unsigned int	newMask;
	XkbVirtualModsToReal(xkb,xkb->ctrls->ignore_lock.vmods,&newMask);
	newMask|= xkb->ctrls->ignore_lock.real_mods;
	if (xkb->ctrls->ignore_lock.mask!=newMask) {
	    xkb->ctrls->ignore_lock.mask= newMask;
	    if (changes) {
		changes->ctrls.changed_ctrls|= XkbIgnoreLockModsMask;
		checkState= TRUE;
	    }
	}
    }
    if (xkb->indicators!=NULL) {
	XkbIndicatorMapPtr map;
	map= &xkb->indicators->maps[0];
	for (i=0;i<XkbNumIndicators;i++,map++) {
	    if (map->mods.vmods&changed) {
		unsigned int newMask;
		XkbVirtualModsToReal(xkb,map->mods.vmods,&newMask);
		newMask|= map->mods.real_mods;
		if (newMask!=map->mods.mask) {
		    map->mods.mask= newMask;
		    if (changes) {
			changes->indicators.map_changes|= (1<<i);
			checkState= TRUE;
		    }
		}
	    }
	}
    }
    if (xkb->compat!=NULL) {
	XkbCompatMapPtr	compat;
	compat= xkb->compat;
	for (i=0;i<XkbNumKbdGroups;i++) {
	    unsigned int newMask;
	    XkbVirtualModsToReal(xkb,compat->groups[i].vmods,&newMask);
	    newMask|= compat->groups[i].real_mods;
	    if (compat->groups[i].mask!=newMask) {
		compat->groups[i].mask= newMask;
		if (changes) {
		    changes->compat.changed_groups|= (1<<i);
		    checkState= TRUE;
		}
	    }
	}
d845 33
a877 30
	int highChange = 0, lowChange = -1;
	for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	    if (XkbKeyHasActions(xkb,i)) {
		register XkbAction *pAct;
		register int n;

		pAct= XkbKeyActionsPtr(xkb,i);
		for (n=XkbKeyNumActions(xkb,i);n>0;n--,pAct++) {
		    if ((pAct->type!=XkbSA_NoAction)&&
			XkbUpdateActionVirtualMods(xkb,pAct,changed)) {
			if (lowChange<0)
			    lowChange= i;
			highChange= i;
		    }
		}
	    }
	}
	if (changes && (lowChange>0)) { /* something changed */
	    if (changes->map.changed&XkbKeyActionsMask) {
		int last;
		if (changes->map.first_key_act<lowChange)
		    lowChange= changes->map.first_key_act;
		last= changes->map.first_key_act+changes->map.num_key_acts-1;
		if (last>highChange)
		    highChange= last;
	    }
	    changes->map.changed|= 	XkbKeyActionsMask;
	    changes->map.first_key_act=	lowChange;
	    changes->map.num_key_acts=	(highChange-lowChange)+1;
	}
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d457 1
a457 1
		old= xkb->ctrls->per_key_repeat[key/8];
d459 4
a462 3
		     xkb->ctrls->per_key_repeat[key/8]|= (1<<(key%8));
		else xkb->ctrls->per_key_repeat[key/8]&= ~(1<<(key%8));
		if (changes && (old!=xkb->ctrls->per_key_repeat[key/8]))
d470 3
a472 3
	    old= xkb->ctrls->per_key_repeat[key/8];
            xkb->ctrls->per_key_repeat[key/8]|= (1<<(key%8));
	    if (changes && (old!=xkb->ctrls->per_key_repeat[key/8]))
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d391 1
a391 1
	interps= xcalloc(nSyms, sizeof(XkbSymInterpretPtr));
d425 1
a425 1
                xfree(interps);
d510 1
a510 1
	xfree(interps);
d583 1
a583 1
	bzero(pSyms,width*nGroups*sizeof(KeySym));
d599 1
a599 1
	    bzero(pActs,width*nGroups*sizeof(XkbAction));
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a34 2
#define	NEED_EVENTS
#define	NEED_REPLIES
d59 1
d93 37
a129 3
    tmp= nSyms[XkbGroup1Index]+nSyms[XkbGroup2Index];
    if ((tmp>=map_width)&&
	 ((protected&(XkbExplicitKeyType3Mask|XkbExplicitKeyType4Mask))==0)) {
d132 25
a156 16
	nGroups= 2;
    }
    else {
    	nGroups= 3;
	for (i=0;i<nSyms[XkbGroup3Index];i++,tmp++) {
	    xkb_syms_rtrn[XKB_OFFSET(XkbGroup3Index,i)]= CORE_SYM(tmp);
	}
	if ((tmp<map_width)||(protected&XkbExplicitKeyType4Mask)) {
	    nGroups= 4;
	    for (i=0;i<nSyms[XkbGroup4Index];i++,tmp++) {
		xkb_syms_rtrn[XKB_OFFSET(XkbGroup4Index,i)]= CORE_SYM(tmp);
	    }
	}
	else {
	    nSyms[XkbGroup4Index]= 0;
	}
d165 1
a165 1
	    XConvertCase(syms[0],&lower,&upper);
d178 1
a178 1
	    if (IsKeypadKey(syms[0])||IsKeypadKey(syms[1]))
d182 1
a182 1
		XConvertCase(syms[0],&lower,&upper);
d190 1
a190 1
	    for (n=1,found=False;(!found)&&(n<nSyms[i]);n++) {
d230 1
a230 1
	Bool sameType,allOneLevel, canonical = True;
d232 1
a232 1
	for (i=1,sameType=True;(allOneLevel||sameType)&&(i<nGroups);i++) {
d237 1
a237 1
		canonical = False;
d243 1
a243 1
	    for (i=1,identical=True;identical&&(i<nGroups);i++) {
d245 2
d250 1
a250 1
			identical= False;
d377 1
a377 1
	return False;
d381 1
a381 1
	return False;
d386 1
a386 1
	return True;
d391 1
a391 1
	interps= _XkbTypedCalloc(nSyms,XkbSymInterpretPtr);
d426 1
a426 1
	    return False;
d510 2
a511 2
	_XkbFree(interps);
    return True;
d645 1
a645 1
	return False;
d648 1
a648 1
	return True;
d651 1
a651 1
	return False;
d657 1
a657 1
    return True;
d673 1
a673 1
		return True;
d681 1
a681 1
		return True;
d685 1
a685 1
    return False;
d743 1
a743 1
	return False;
d756 1
a756 1
		checkState= True;
d768 1
a768 1
		checkState= True;
d784 1
a784 1
			checkState= True;
d801 1
a801 1
		    checkState= True;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d483 1
a483 1
	(!xkb->map->types)||(!newTypes)||((groups&XkbAllGroupsMask)==0)||
@


1.1
log
@Initial revision
@
text
@d42 1
a42 96
#include <X11/extensions/XKBsrv.h>

/***====================================================================***/

#define	mapSize(m)	(sizeof(m)/sizeof(XkbKTMapEntryRec))
static  XkbKTMapEntryRec map2Level[]= { 
  { True, ShiftMask, {1, ShiftMask, 0} }
};

static  XkbKTMapEntryRec mapAlpha[]= { 
  { True, ShiftMask, { 1, ShiftMask, 0 } },
  { True, LockMask,  { 0,  LockMask, 0 } }
};

static	XkbModsRec preAlpha[]= {
	{        0,        0, 0 },
	{ LockMask, LockMask, 0 }
};

#define	NL_VMOD_MASK	0
static  XkbKTMapEntryRec mapKeypad[]= { 
	{ True,	ShiftMask, { 1, ShiftMask,            0 } },
	{ False,        0, { 1,         0, NL_VMOD_MASK } }
};

static	XkbKeyTypeRec	canonicalTypes[XkbNumRequiredTypes] = {
	{ { 0, 0, 0 }, 
	  1,	/* num_levels */
	  0,	/* map_count */
	  NULL,		NULL,
	  None,		NULL
	},
	{ { ShiftMask, ShiftMask, 0 }, 
	  2,	/* num_levels */
	  mapSize(map2Level),	/* map_count */
	  map2Level,	NULL,
	  None,		NULL
	},
	{ { ShiftMask|LockMask, ShiftMask|LockMask, 0 }, 
	  2,				/* num_levels */
	  mapSize(mapAlpha),		/* map_count */
	  mapAlpha,	preAlpha,
	  None,		NULL
	},
	{ { ShiftMask, ShiftMask, NL_VMOD_MASK },
	  2,				/* num_levels */
	  mapSize(mapKeypad),		/* map_count */
	  mapKeypad,	NULL,
	  None,		NULL
	}
};

Status
XkbInitCanonicalKeyTypes(XkbDescPtr xkb,unsigned which,int keypadVMod)
{
XkbClientMapPtr	map;
XkbKeyTypePtr	from,to;
Status		rtrn;

    if (!xkb)
	return BadMatch;
    rtrn= XkbAllocClientMap(xkb,XkbKeyTypesMask,XkbNumRequiredTypes);
    if (rtrn!=Success)
	return rtrn;
    map= xkb->map;
    if ((which&XkbAllRequiredTypes)==0)
	return Success;
    rtrn= Success;
    from= canonicalTypes;
    to= map->types;
    if (which&XkbOneLevelMask)
	rtrn= XkbCopyKeyType(&from[XkbOneLevelIndex],&to[XkbOneLevelIndex]);
    if ((which&XkbTwoLevelMask)&&(rtrn==Success))
	rtrn= XkbCopyKeyType(&from[XkbTwoLevelIndex],&to[XkbTwoLevelIndex]);
    if ((which&XkbAlphabeticMask)&&(rtrn==Success))
	rtrn= XkbCopyKeyType(&from[XkbAlphabeticIndex],&to[XkbAlphabeticIndex]);
    if ((which&XkbKeypadMask)&&(rtrn==Success)) {
	XkbKeyTypePtr type;
	rtrn= XkbCopyKeyType(&from[XkbKeypadIndex],&to[XkbKeypadIndex]);
	type= &to[XkbKeypadIndex];
	if ((keypadVMod>=0)&&(keypadVMod<XkbNumVirtualMods)&&(rtrn==Success)) {
	    type->mods.vmods= (1<<keypadVMod);
	    type->map[0].active= True;
	    type->map[0].mods.mask= ShiftMask;
	    type->map[0].mods.real_mods= ShiftMask;
	    type->map[0].mods.vmods= 0;
	    type->map[0].level= 1;
	    type->map[1].active= False;
	    type->map[1].mods.mask= 0;
	    type->map[1].mods.real_mods= 0;
	    type->map[1].mods.vmods= (1<<keypadVMod);
	    type->map[1].level= 1;
	}
    }
    return Success;
}
d181 6
a186 1
    /* step 7: check for all groups identical or all width 1 */
d188 1
a188 1
	Bool sameType,allOneLevel;
d194 2
d197 1
a197 1
	if ((sameType)&&
d426 1
a426 4
#ifdef RETURN_SHOULD_REPEAT
	    if (*XkbKeySymsPtr(xkb,key) != XK_Return)
#endif
		xkb->ctrls->per_key_repeat[key/8]|= (1<<(key%8));
a469 82
Bool
XkbUpdateMapFromCore(	XkbDescPtr	xkb,
			KeyCode		first_key,
			int		num_keys,
			int		map_width,
			KeySym *	core_keysyms,
			XkbChangesPtr	changes)
{
register int	key,last_key;
KeySym *	syms;

    syms= &core_keysyms[(first_key-xkb->min_key_code)*map_width];
    if (changes) {
	if (changes->map.changed&XkbKeySymsMask) {
	    _XkbAddKeyChange(&changes->map.first_key_sym,
	    			&changes->map.num_key_syms,first_key);
	    if (num_keys>1) {
		_XkbAddKeyChange(&changes->map.first_key_sym,
						&changes->map.num_key_syms,
						first_key+num_keys-1);
	    }
	}
	else {
	    changes->map.changed|= XkbKeySymsMask;
	    changes->map.first_key_sym= first_key;
	    changes->map.num_key_syms= num_keys;
	}
    }
    last_key= first_key+num_keys-1;
    for (key=first_key;key<=last_key;key++,syms+= map_width) {
	XkbMapChangesPtr	mc;
	unsigned		explicit;
	KeySym			tsyms[XkbMaxSymsPerKey];
	int	 		types[XkbNumKbdGroups];
	int			nG;

	explicit= xkb->server->explicit[key]&XkbExplicitKeyTypesMask;
	types[XkbGroup1Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup1Index);
	types[XkbGroup2Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup2Index);
	types[XkbGroup3Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup3Index);
	types[XkbGroup4Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup4Index);
	nG= XkbKeyTypesForCoreSymbols(xkb,map_width,syms,explicit,types,tsyms);
	if (changes)
	     mc= &changes->map;
	else mc= NULL;
	XkbChangeTypesOfKey(xkb,key,nG,XkbAllGroupsMask,types,mc);
	memcpy((char *)XkbKeySymsPtr(xkb,key),(char *)tsyms,
					XkbKeyNumSyms(xkb,key)*sizeof(KeySym));
	XkbApplyCompatMapToKey(xkb,key,changes);
    }

    if ((xkb->server->vmods!=NULL)&&(xkb->map->modmap!=NULL)&&(changes)&&
	(changes->map.changed&(XkbVirtualModMapMask|XkbModifierMapMask))) {
	unsigned char		newVMods[XkbNumVirtualMods];
	register  unsigned 	bit,i;
	unsigned		present;

	bzero(newVMods,XkbNumVirtualMods);
	present= 0;
	for (key=xkb->min_key_code;key<=xkb->max_key_code;key++) {
	    if (xkb->server->vmodmap[key]==0)
		continue;
	    for (i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
		if (bit&xkb->server->vmodmap[key]) {
		    present|= bit;
		    newVMods[i]|= xkb->map->modmap[key];
		}
	    }
	}
	for (i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	    if ((bit&present)&&(newVMods[i]!=xkb->server->vmods[i])) {
		changes->map.changed|= XkbVirtualModsMask;
		changes->map.vmods|= bit;
		xkb->server->vmods[i]= newVMods[i];
	    }
	}
    }
    if (changes && (changes->map.changed&XkbVirtualModsMask))
	XkbApplyVirtualModChanges(xkb,changes->map.vmods,changes);
    return True;
}

d618 1
a618 1
Bool
d644 1
a644 1
void
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d42 96
a137 1
#include <xkbsrv.h>
d561 82
d791 1
a791 1
static Bool
d817 1
a817 1
static void
@

