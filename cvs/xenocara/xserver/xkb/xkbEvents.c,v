head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.2
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.08.09.18.59.55;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	6HLO5qdN5N4nPDjW;

1.11
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2013.06.07.17.28.56;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.32;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.11;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.29;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.30;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.13.21.06.51;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "inputstr.h"
#include "exevents.h"
#include "exglobals.h"
#include "windowstr.h"
#include <xkbsrv.h>
#include "xkb.h"

/***====================================================================***/

/*
 * This function sends out two kinds of notification:
 *   - Core mapping notify events sent to clients for whom kbd is the
 *     current core ('picked') keyboard _and_ have not explicitly
 *     selected for XKB mapping notify events;
 *   - Xi mapping events, sent unconditionally to all clients who have
 *     explicitly selected for them (including those who have explicitly
 *     selected for XKB mapping notify events!).
 */
static void
XkbSendLegacyMapNotify(DeviceIntPtr kbd, CARD16 xkb_event, CARD16 changed,
                       int first_key, int num_keys)
{
    int i;
    int keymap_changed = 0;
    int modmap_changed = 0;
    CARD32 time = GetTimeInMillis();

    if (xkb_event == XkbNewKeyboardNotify) {
        if (changed & XkbNKN_KeycodesMask) {
            keymap_changed = 1;
            modmap_changed = 1;
        }
    }
    else if (xkb_event == XkbMapNotify) {
        if (changed & XkbKeySymsMask)
            keymap_changed = 1;
        if (changed & XkbModifierMapMask)
            modmap_changed = 1;
    }
    if (!keymap_changed && !modmap_changed)
        return;

    /* 0 is serverClient. */
    for (i = 1; i < currentMaxClients; i++) {
        if (!clients[i] || clients[i]->clientState != ClientStateRunning)
            continue;

        /* XKB allows clients to restrict the MappingNotify events sent to
         * them.  This was broken for three years.  Sorry. */
        if (xkb_event == XkbMapNotify &&
            (clients[i]->xkbClientFlags & _XkbClientInitialized) &&
            !(clients[i]->mapNotifyMask & changed))
            continue;
        /* Emulate previous server behaviour: any client which has activated
         * XKB will not receive core events emulated from a NewKeyboardNotify
         * at all. */
        if (xkb_event == XkbNewKeyboardNotify &&
            (clients[i]->xkbClientFlags & _XkbClientInitialized))
            continue;

        /* Don't send core events to clients who don't know about us. */
        if (!XIShouldNotify(clients[i], kbd))
            continue;

        if (keymap_changed) {
            xEvent core_mn = { .u.u.type = MappingNotify };
            core_mn.u.mappingNotify.request = MappingKeyboard;

            /* Clip the keycode range to what the client knows about, so it
             * doesn't freak out. */
            if (first_key >= clients[i]->minKC)
                core_mn.u.mappingNotify.firstKeyCode = first_key;
            else
                core_mn.u.mappingNotify.firstKeyCode = clients[i]->minKC;
            if (first_key + num_keys - 1 <= clients[i]->maxKC)
                core_mn.u.mappingNotify.count = num_keys;
            else
                core_mn.u.mappingNotify.count = clients[i]->maxKC -
                    clients[i]->minKC + 1;

            WriteEventsToClient(clients[i], 1, &core_mn);
        }
        if (modmap_changed) {
            xEvent core_mn = {
                .u.mappingNotify.request = MappingModifier,
                .u.mappingNotify.firstKeyCode = 0,
                .u.mappingNotify.count = 0
            };
            core_mn.u.u.type = MappingNotify;
            WriteEventsToClient(clients[i], 1, &core_mn);
        }
    }

    /* Hmm, maybe we can accidentally generate Xi events for core devices
     * here? Clients might be upset, but that seems better than the
     * alternative of stale keymaps. -ds */
    if (keymap_changed) {
        deviceMappingNotify xi_mn = {
            .type = DeviceMappingNotify,
            .deviceid = kbd->id,
            .request = MappingKeyboard,
            .firstKeyCode = first_key,
            .count = num_keys,
            .time = time
        };
        SendEventToAllWindows(kbd, DeviceMappingNotifyMask, (xEvent *) &xi_mn,
                              1);
    }
    if (modmap_changed) {
        deviceMappingNotify xi_mn = {
            .type = DeviceMappingNotify,
            .deviceid = kbd->id,
            .request = MappingModifier,
            .firstKeyCode = 0,
            .count = 0,
            .time = time
        };
        SendEventToAllWindows(kbd, DeviceMappingNotifyMask, (xEvent *) &xi_mn,
                              1);
    }
}

/***====================================================================***/

void
XkbSendNewKeyboardNotify(DeviceIntPtr kbd, xkbNewKeyboardNotify * pNKN)
{
    int i;
    Time time = GetTimeInMillis();
    CARD16 changed = pNKN->changed;

    pNKN->type = XkbEventCode + XkbEventBase;
    pNKN->xkbType = XkbNewKeyboardNotify;

    for (i = 1; i < currentMaxClients; i++) {
        if (!clients[i] || clients[i]->clientState != ClientStateRunning)
            continue;

        if (!(clients[i]->newKeyboardNotifyMask & changed))
            continue;

        pNKN->sequenceNumber = clients[i]->sequence;
        pNKN->time = time;
        pNKN->changed = changed;
        if (clients[i]->swapped) {
            swaps(&pNKN->sequenceNumber);
            swapl(&pNKN->time);
            swaps(&pNKN->changed);
        }
        WriteToClient(clients[i], sizeof(xEvent), pNKN);

        if (changed & XkbNKN_KeycodesMask) {
            clients[i]->minKC = pNKN->minKeyCode;
            clients[i]->maxKC = pNKN->maxKeyCode;
        }
    }

    XkbSendLegacyMapNotify(kbd, XkbNewKeyboardNotify, changed, pNKN->minKeyCode,
                           pNKN->maxKeyCode - pNKN->minKeyCode + 1);

    return;
}

/***====================================================================***/

void
XkbSendStateNotify(DeviceIntPtr kbd, xkbStateNotify * pSN)
{
    XkbSrvInfoPtr xkbi;
    XkbStatePtr state;
    XkbInterestPtr interest;
    Time time;
    register CARD16 changed, bState;

    interest = kbd->xkb_interest;
    if (!interest || !kbd->key || !kbd->key->xkbInfo)
        return;
    xkbi = kbd->key->xkbInfo;
    state = &xkbi->state;

    pSN->type = XkbEventCode + XkbEventBase;
    pSN->xkbType = XkbStateNotify;
    pSN->deviceID = kbd->id;
    pSN->time = time = GetTimeInMillis();
    pSN->mods = state->mods;
    pSN->baseMods = state->base_mods;
    pSN->latchedMods = state->latched_mods;
    pSN->lockedMods = state->locked_mods;
    pSN->group = state->group;
    pSN->baseGroup = state->base_group;
    pSN->latchedGroup = state->latched_group;
    pSN->lockedGroup = state->locked_group;
    pSN->compatState = state->compat_state;
    pSN->grabMods = state->grab_mods;
    pSN->compatGrabMods = state->compat_grab_mods;
    pSN->lookupMods = state->lookup_mods;
    pSN->compatLookupMods = state->compat_lookup_mods;
    pSN->ptrBtnState = state->ptr_buttons;
    changed = pSN->changed;
    bState = pSN->ptrBtnState;

    while (interest) {
        if ((!interest->client->clientGone) &&
            (interest->client->xkbClientFlags & _XkbClientInitialized) &&
            (interest->stateNotifyMask & changed)) {
            pSN->sequenceNumber = interest->client->sequence;
            pSN->time = time;
            pSN->changed = changed;
            pSN->ptrBtnState = bState;
            if (interest->client->swapped) {
                swaps(&pSN->sequenceNumber);
                swapl(&pSN->time);
                swaps(&pSN->changed);
                swaps(&pSN->ptrBtnState);
            }
            WriteToClient(interest->client, sizeof(xEvent), pSN);
        }
        interest = interest->next;
    }
    return;
}

/***====================================================================***/

/*
 * This function sends out XKB mapping notify events to clients which
 * have explicitly selected for them.  Core and Xi events are handled by
 * XkbSendLegacyMapNotify. */
void
XkbSendMapNotify(DeviceIntPtr kbd, xkbMapNotify * pMN)
{
    int i;
    CARD32 time = GetTimeInMillis();
    CARD16 changed = pMN->changed;
    XkbSrvInfoPtr xkbi = kbd->key->xkbInfo;

    pMN->minKeyCode = xkbi->desc->min_key_code;
    pMN->maxKeyCode = xkbi->desc->max_key_code;
    pMN->type = XkbEventCode + XkbEventBase;
    pMN->xkbType = XkbMapNotify;
    pMN->deviceID = kbd->id;

    /* 0 is serverClient. */
    for (i = 1; i < currentMaxClients; i++) {
        if (!clients[i] || clients[i]->clientState != ClientStateRunning)
            continue;

        if (!(clients[i]->mapNotifyMask & changed))
            continue;

        pMN->time = time;
        pMN->sequenceNumber = clients[i]->sequence;
        pMN->changed = changed;

        if (clients[i]->swapped) {
            swaps(&pMN->sequenceNumber);
            swapl(&pMN->time);
            swaps(&pMN->changed);
        }
        WriteToClient(clients[i], sizeof(xEvent), pMN);
    }

    XkbSendLegacyMapNotify(kbd, XkbMapNotify, changed, pMN->firstKeySym,
                           pMN->nKeySyms);
}

int
XkbComputeControlsNotify(DeviceIntPtr kbd,
                         XkbControlsPtr old,
                         XkbControlsPtr new,
                         xkbControlsNotify * pCN, Bool forceCtrlProc)
{
    int i;
    CARD32 changedControls;

    changedControls = 0;

    if (!kbd || !kbd->kbdfeed)
        return 0;

    if (old->enabled_ctrls != new->enabled_ctrls)
        changedControls |= XkbControlsEnabledMask;
    if ((old->repeat_delay != new->repeat_delay) ||
        (old->repeat_interval != new->repeat_interval))
        changedControls |= XkbRepeatKeysMask;
    for (i = 0; i < XkbPerKeyBitArraySize; i++)
        if (old->per_key_repeat[i] != new->per_key_repeat[i])
            changedControls |= XkbPerKeyRepeatMask;
    if (old->slow_keys_delay != new->slow_keys_delay)
        changedControls |= XkbSlowKeysMask;
    if (old->debounce_delay != new->debounce_delay)
        changedControls |= XkbBounceKeysMask;
    if ((old->mk_delay != new->mk_delay) ||
        (old->mk_interval != new->mk_interval) ||
        (old->mk_dflt_btn != new->mk_dflt_btn))
        changedControls |= XkbMouseKeysMask;
    if ((old->mk_time_to_max != new->mk_time_to_max) ||
        (old->mk_curve != new->mk_curve) ||
        (old->mk_max_speed != new->mk_max_speed))
        changedControls |= XkbMouseKeysAccelMask;
    if (old->ax_options != new->ax_options)
        changedControls |= XkbAccessXKeysMask;
    if ((old->ax_options ^ new->ax_options) & XkbAX_SKOptionsMask)
        changedControls |= XkbStickyKeysMask;
    if ((old->ax_options ^ new->ax_options) & XkbAX_FBOptionsMask)
        changedControls |= XkbAccessXFeedbackMask;
    if ((old->ax_timeout != new->ax_timeout) ||
        (old->axt_ctrls_mask != new->axt_ctrls_mask) ||
        (old->axt_ctrls_values != new->axt_ctrls_values) ||
        (old->axt_opts_mask != new->axt_opts_mask) ||
        (old->axt_opts_values != new->axt_opts_values)) {
        changedControls |= XkbAccessXTimeoutMask;
    }
    if ((old->internal.mask != new->internal.mask) ||
        (old->internal.real_mods != new->internal.real_mods) ||
        (old->internal.vmods != new->internal.vmods))
        changedControls |= XkbInternalModsMask;
    if ((old->ignore_lock.mask != new->ignore_lock.mask) ||
        (old->ignore_lock.real_mods != new->ignore_lock.real_mods) ||
        (old->ignore_lock.vmods != new->ignore_lock.vmods))
        changedControls |= XkbIgnoreLockModsMask;

    if (new->enabled_ctrls & XkbRepeatKeysMask)
        kbd->kbdfeed->ctrl.autoRepeat = TRUE;
    else
        kbd->kbdfeed->ctrl.autoRepeat = FALSE;

    if (kbd->kbdfeed && kbd->kbdfeed->CtrlProc &&
        (changedControls || forceCtrlProc))
        (*kbd->kbdfeed->CtrlProc) (kbd, &kbd->kbdfeed->ctrl);

    if ((!changedControls) && (old->num_groups == new->num_groups))
        return 0;

    if (!kbd->xkb_interest)
        return 0;

    pCN->changedControls = changedControls;
    pCN->enabledControls = new->enabled_ctrls;
    pCN->enabledControlChanges = (new->enabled_ctrls ^ old->enabled_ctrls);
    pCN->numGroups = new->num_groups;

    return 1;
}

void
XkbSendControlsNotify(DeviceIntPtr kbd, xkbControlsNotify * pCN)
{
    int initialized;
    CARD32 changedControls, enabledControls, enabledChanges = 0;
    XkbSrvInfoPtr xkbi;
    XkbInterestPtr interest;
    Time time = 0;

    interest = kbd->xkb_interest;
    if (!interest || !kbd->key || !kbd->key->xkbInfo)
        return;
    xkbi = kbd->key->xkbInfo;

    initialized = 0;
    enabledControls = xkbi->desc->ctrls->enabled_ctrls;
    changedControls = pCN->changedControls;
    pCN->numGroups = xkbi->desc->ctrls->num_groups;
    while (interest) {
        if ((!interest->client->clientGone) &&
            (interest->client->xkbClientFlags & _XkbClientInitialized) &&
            (interest->ctrlsNotifyMask & changedControls)) {
            if (!initialized) {
                pCN->type = XkbEventCode + XkbEventBase;
                pCN->xkbType = XkbControlsNotify;
                pCN->deviceID = kbd->id;
                pCN->time = time = GetTimeInMillis();
                enabledChanges = pCN->enabledControlChanges;
                initialized = 1;
            }
            pCN->changedControls = changedControls;
            pCN->enabledControls = enabledControls;
            pCN->enabledControlChanges = enabledChanges;
            pCN->sequenceNumber = interest->client->sequence;
            pCN->time = time;
            if (interest->client->swapped) {
                swaps(&pCN->sequenceNumber);
                swapl(&pCN->changedControls);
                swapl(&pCN->enabledControls);
                swapl(&pCN->enabledControlChanges);
                swapl(&pCN->time);
            }
            WriteToClient(interest->client, sizeof(xEvent), pCN);
        }
        interest = interest->next;
    }
    return;
}

static void
XkbSendIndicatorNotify(DeviceIntPtr kbd, int xkbType, xkbIndicatorNotify * pEv)
{
    int initialized;
    XkbInterestPtr interest;
    Time time = 0;
    CARD32 state, changed;

    interest = kbd->xkb_interest;
    if (!interest)
        return;

    initialized = 0;
    state = pEv->state;
    changed = pEv->changed;
    while (interest) {
        if ((!interest->client->clientGone) &&
            (interest->client->xkbClientFlags & _XkbClientInitialized) &&
            (((xkbType == XkbIndicatorStateNotify) &&
              (interest->iStateNotifyMask & changed)) ||
             ((xkbType == XkbIndicatorMapNotify) &&
              (interest->iMapNotifyMask & changed)))) {
            if (!initialized) {
                pEv->type = XkbEventCode + XkbEventBase;
                pEv->xkbType = xkbType;
                pEv->deviceID = kbd->id;
                pEv->time = time = GetTimeInMillis();
                initialized = 1;
            }
            pEv->sequenceNumber = interest->client->sequence;
            pEv->time = time;
            pEv->changed = changed;
            pEv->state = state;
            if (interest->client->swapped) {
                swaps(&pEv->sequenceNumber);
                swapl(&pEv->time);
                swapl(&pEv->changed);
                swapl(&pEv->state);
            }
            WriteToClient(interest->client, sizeof(xEvent), pEv);
        }
        interest = interest->next;
    }
    return;
}

void
XkbHandleBell(BOOL force,
              BOOL eventOnly,
              DeviceIntPtr kbd,
              CARD8 percent,
              void *pCtrl,
              CARD8 class, Atom name, WindowPtr pWin, ClientPtr pClient)
{
    xkbBellNotify bn;
    int initialized;
    XkbSrvInfoPtr xkbi;
    XkbInterestPtr interest;
    CARD8 id;
    CARD16 pitch, duration;
    Time time = 0;
    XID winID = 0;

    if (!kbd->key || !kbd->key->xkbInfo)
        return;

    xkbi = kbd->key->xkbInfo;

    if ((force || (xkbi->desc->ctrls->enabled_ctrls & XkbAudibleBellMask)) &&
        (!eventOnly)) {
        if (kbd->kbdfeed->BellProc)
            (*kbd->kbdfeed->BellProc) (percent, kbd, (void *) pCtrl, class);
    }
    interest = kbd->xkb_interest;
    if ((!interest) || (force))
        return;

    if (class == KbdFeedbackClass) {
        KeybdCtrl *pKeyCtrl = (KeybdCtrl *) pCtrl;

        id = pKeyCtrl->id;
        pitch = pKeyCtrl->bell_pitch;
        duration = pKeyCtrl->bell_duration;
    }
    else if (class == BellFeedbackClass) {
        BellCtrl *pBellCtrl = (BellCtrl *) pCtrl;

        id = pBellCtrl->id;
        pitch = pBellCtrl->pitch;
        duration = pBellCtrl->duration;
    }
    else
        return;

    initialized = 0;
    while (interest) {
        if ((!interest->client->clientGone) &&
            (interest->client->xkbClientFlags & _XkbClientInitialized) &&
            (interest->bellNotifyMask)) {
            if (!initialized) {
                time = GetTimeInMillis();
                bn.type = XkbEventCode + XkbEventBase;
                bn.xkbType = XkbBellNotify;
                bn.deviceID = kbd->id;
                bn.bellClass = class;
                bn.bellID = id;
                bn.percent = percent;
                bn.eventOnly = (eventOnly != 0);
                winID = (pWin ? pWin->drawable.id : None);
                initialized = 1;
            }
            bn.sequenceNumber = interest->client->sequence;
            bn.time = time;
            bn.pitch = pitch;
            bn.duration = duration;
            bn.name = name;
            bn.window = winID;
            if (interest->client->swapped) {
                swaps(&bn.sequenceNumber);
                swapl(&bn.time);
                swaps(&bn.pitch);
                swaps(&bn.duration);
                swapl(&bn.name);
                swapl(&bn.window);
            }
            WriteToClient(interest->client, sizeof(xEvent), &bn);
        }
        interest = interest->next;
    }
    return;
}

void
XkbSendAccessXNotify(DeviceIntPtr kbd, xkbAccessXNotify * pEv)
{
    int initialized;
    XkbInterestPtr interest;
    Time time = 0;
    CARD16 sk_delay, db_delay;

    interest = kbd->xkb_interest;
    if (!interest)
        return;

    initialized = 0;
    sk_delay = pEv->slowKeysDelay;
    db_delay = pEv->debounceDelay;
    while (interest) {
        if ((!interest->client->clientGone) &&
            (interest->client->xkbClientFlags & _XkbClientInitialized) &&
            (interest->accessXNotifyMask & (1 << pEv->detail))) {
            if (!initialized) {
                pEv->type = XkbEventCode + XkbEventBase;
                pEv->xkbType = XkbAccessXNotify;
                pEv->deviceID = kbd->id;
                pEv->time = time = GetTimeInMillis();
                initialized = 1;
            }
            pEv->sequenceNumber = interest->client->sequence;
            pEv->time = time;
            pEv->slowKeysDelay = sk_delay;
            pEv->debounceDelay = db_delay;
            if (interest->client->swapped) {
                swaps(&pEv->sequenceNumber);
                swapl(&pEv->time);
                swaps(&pEv->slowKeysDelay);
                swaps(&pEv->debounceDelay);
            }
            WriteToClient(interest->client, sizeof(xEvent), pEv);
        }
        interest = interest->next;
    }
    return;
}

void
XkbSendNamesNotify(DeviceIntPtr kbd, xkbNamesNotify * pEv)
{
    int initialized;
    XkbInterestPtr interest;
    Time time = 0;
    CARD16 changed, changedVirtualMods;
    CARD32 changedIndicators;

    interest = kbd->xkb_interest;
    if (!interest)
        return;

    initialized = 0;
    changed = pEv->changed;
    changedIndicators = pEv->changedIndicators;
    changedVirtualMods = pEv->changedVirtualMods;
    while (interest) {
        if ((!interest->client->clientGone) &&
            (interest->client->xkbClientFlags & _XkbClientInitialized) &&
            (interest->namesNotifyMask & pEv->changed)) {
            if (!initialized) {
                pEv->type = XkbEventCode + XkbEventBase;
                pEv->xkbType = XkbNamesNotify;
                pEv->deviceID = kbd->id;
                pEv->time = time = GetTimeInMillis();
                initialized = 1;
            }
            pEv->sequenceNumber = interest->client->sequence;
            pEv->time = time;
            pEv->changed = changed;
            pEv->changedIndicators = changedIndicators;
            pEv->changedVirtualMods = changedVirtualMods;
            if (interest->client->swapped) {
                swaps(&pEv->sequenceNumber);
                swapl(&pEv->time);
                swaps(&pEv->changed);
                swapl(&pEv->changedIndicators);
                swaps(&pEv->changedVirtualMods);
            }
            WriteToClient(interest->client, sizeof(xEvent), pEv);
        }
        interest = interest->next;
    }
    return;
}

void
XkbSendCompatMapNotify(DeviceIntPtr kbd, xkbCompatMapNotify * pEv)
{
    int initialized;
    XkbInterestPtr interest;
    Time time = 0;
    CARD16 firstSI = 0, nSI = 0, nTotalSI = 0;

    interest = kbd->xkb_interest;
    if (!interest)
        return;

    initialized = 0;
    while (interest) {
        if ((!interest->client->clientGone) &&
            (interest->client->xkbClientFlags & _XkbClientInitialized) &&
            (interest->compatNotifyMask)) {
            if (!initialized) {
                pEv->type = XkbEventCode + XkbEventBase;
                pEv->xkbType = XkbCompatMapNotify;
                pEv->deviceID = kbd->id;
                pEv->time = time = GetTimeInMillis();
                firstSI = pEv->firstSI;
                nSI = pEv->nSI;
                nTotalSI = pEv->nTotalSI;
                initialized = 1;
            }
            pEv->sequenceNumber = interest->client->sequence;
            pEv->time = time;
            pEv->firstSI = firstSI;
            pEv->nSI = nSI;
            pEv->nTotalSI = nTotalSI;
            if (interest->client->swapped) {
                swaps(&pEv->sequenceNumber);
                swapl(&pEv->time);
                swaps(&pEv->firstSI);
                swaps(&pEv->nSI);
                swaps(&pEv->nTotalSI);
            }
            WriteToClient(interest->client, sizeof(xEvent), pEv);
        }
        interest = interest->next;
    }
    return;
}

void
XkbSendActionMessage(DeviceIntPtr kbd, xkbActionMessage * pEv)
{
    int initialized;
    XkbSrvInfoPtr xkbi;
    XkbInterestPtr interest;
    Time time = 0;

    interest = kbd->xkb_interest;
    if (!interest || !kbd->key || !kbd->key->xkbInfo)
        return;

    xkbi = kbd->key->xkbInfo;

    initialized = 0;
    pEv->mods = xkbi->state.mods;
    pEv->group = xkbi->state.group;
    while (interest) {
        if ((!interest->client->clientGone) &&
            (interest->client->xkbClientFlags & _XkbClientInitialized) &&
            (interest->actionMessageMask)) {
            if (!initialized) {
                pEv->type = XkbEventCode + XkbEventBase;
                pEv->xkbType = XkbActionMessage;
                pEv->deviceID = kbd->id;
                pEv->sequenceNumber = interest->client->sequence;
                pEv->time = time = GetTimeInMillis();
                initialized = 1;
            }
            pEv->sequenceNumber = interest->client->sequence;
            pEv->time = time;
            if (interest->client->swapped) {
                swaps(&pEv->sequenceNumber);
                swapl(&pEv->time);
            }
            WriteToClient(interest->client, sizeof(xEvent), pEv);
        }
        interest = interest->next;
    }
    return;
}

void
XkbSendExtensionDeviceNotify(DeviceIntPtr dev,
                             ClientPtr client, xkbExtensionDeviceNotify * pEv)
{
    int initialized;
    XkbInterestPtr interest;
    Time time = 0;
    CARD32 defined, state;
    CARD16 reason;

    interest = dev->xkb_interest;
    if (!interest)
        return;

    initialized = 0;
    reason = pEv->reason;
    defined = pEv->ledsDefined;
    state = pEv->ledState;
    while (interest) {
        if ((!interest->client->clientGone) &&
            (interest->client->xkbClientFlags & _XkbClientInitialized) &&
            (interest->extDevNotifyMask & reason)) {
            if (!initialized) {
                pEv->type = XkbEventCode + XkbEventBase;
                pEv->xkbType = XkbExtensionDeviceNotify;
                pEv->deviceID = dev->id;
                pEv->sequenceNumber = interest->client->sequence;
                pEv->time = time = GetTimeInMillis();
                initialized = 1;
            }
            else {
                pEv->sequenceNumber = interest->client->sequence;
                pEv->time = time;
                pEv->ledsDefined = defined;
                pEv->ledState = state;
                pEv->reason = reason;
                pEv->supported = XkbXI_AllFeaturesMask;
            }
            if (interest->client->swapped) {
                swaps(&pEv->sequenceNumber);
                swapl(&pEv->time);
                swapl(&pEv->ledsDefined);
                swapl(&pEv->ledState);
                swaps(&pEv->reason);
                swaps(&pEv->supported);
            }
            WriteToClient(interest->client, sizeof(xEvent), pEv);
        }
        interest = interest->next;
    }
    return;
}

void
XkbSendNotification(DeviceIntPtr kbd,
                    XkbChangesPtr pChanges, XkbEventCausePtr cause)
{
    XkbSrvLedInfoPtr sli;

    sli = NULL;
    if (pChanges->state_changes) {
        xkbStateNotify sn;

        sn.changed = pChanges->state_changes;
        sn.keycode = cause->kc;
        sn.eventType = cause->event;
        sn.requestMajor = cause->mjr;
        sn.requestMinor = cause->mnr;
        XkbSendStateNotify(kbd, &sn);
    }
    if (pChanges->map.changed) {
        xkbMapNotify mn;

        memset(&mn, 0, sizeof(xkbMapNotify));
        mn.changed = pChanges->map.changed;
        mn.firstType = pChanges->map.first_type;
        mn.nTypes = pChanges->map.num_types;
        mn.firstKeySym = pChanges->map.first_key_sym;
        mn.nKeySyms = pChanges->map.num_key_syms;
        mn.firstKeyAct = pChanges->map.first_key_act;
        mn.nKeyActs = pChanges->map.num_key_acts;
        mn.firstKeyBehavior = pChanges->map.first_key_behavior;
        mn.nKeyBehaviors = pChanges->map.num_key_behaviors;
        mn.virtualMods = pChanges->map.vmods;
        mn.firstKeyExplicit = pChanges->map.first_key_explicit;
        mn.nKeyExplicit = pChanges->map.num_key_explicit;
        mn.firstModMapKey = pChanges->map.first_modmap_key;
        mn.nModMapKeys = pChanges->map.num_modmap_keys;
        mn.firstVModMapKey = pChanges->map.first_vmodmap_key;
        mn.nVModMapKeys = pChanges->map.num_vmodmap_keys;
        XkbSendMapNotify(kbd, &mn);
    }
    if ((pChanges->ctrls.changed_ctrls) ||
        (pChanges->ctrls.enabled_ctrls_changes)) {
        xkbControlsNotify cn;

        memset(&cn, 0, sizeof(xkbControlsNotify));
        cn.changedControls = pChanges->ctrls.changed_ctrls;
        cn.enabledControlChanges = pChanges->ctrls.enabled_ctrls_changes;
        cn.keycode = cause->kc;
        cn.eventType = cause->event;
        cn.requestMajor = cause->mjr;
        cn.requestMinor = cause->mnr;
        XkbSendControlsNotify(kbd, &cn);
    }
    if (pChanges->indicators.map_changes) {
        xkbIndicatorNotify in;

        if (sli == NULL)
            sli = XkbFindSrvLedInfo(kbd, XkbDfltXIClass, XkbDfltXIId, 0);
        memset(&in, 0, sizeof(xkbIndicatorNotify));
        in.state = sli->effectiveState;
        in.changed = pChanges->indicators.map_changes;
        XkbSendIndicatorNotify(kbd, XkbIndicatorMapNotify, &in);
    }
    if (pChanges->indicators.state_changes) {
        xkbIndicatorNotify in;

        if (sli == NULL)
            sli = XkbFindSrvLedInfo(kbd, XkbDfltXIClass, XkbDfltXIId, 0);
        memset(&in, 0, sizeof(xkbIndicatorNotify));
        in.state = sli->effectiveState;
        in.changed = pChanges->indicators.state_changes;
        XkbSendIndicatorNotify(kbd, XkbIndicatorStateNotify, &in);
    }
    if (pChanges->names.changed) {
        xkbNamesNotify nn;

        memset(&nn, 0, sizeof(xkbNamesNotify));
        nn.changed = pChanges->names.changed;
        nn.firstType = pChanges->names.first_type;
        nn.nTypes = pChanges->names.num_types;
        nn.firstLevelName = pChanges->names.first_lvl;
        nn.nLevelNames = pChanges->names.num_lvls;
        nn.nRadioGroups = pChanges->names.num_rg;
        nn.changedVirtualMods = pChanges->names.changed_vmods;
        nn.changedIndicators = pChanges->names.changed_indicators;
        XkbSendNamesNotify(kbd, &nn);
    }
    if ((pChanges->compat.changed_groups) || (pChanges->compat.num_si > 0)) {
        xkbCompatMapNotify cmn;

        memset(&cmn, 0, sizeof(xkbCompatMapNotify));
        cmn.changedGroups = pChanges->compat.changed_groups;
        cmn.firstSI = pChanges->compat.first_si;
        cmn.nSI = pChanges->compat.num_si;
        cmn.nTotalSI = kbd->key->xkbInfo->desc->compat->num_si;
        XkbSendCompatMapNotify(kbd, &cmn);
    }
    return;
}

/***====================================================================***/

void
XkbFilterEvents(ClientPtr client, int nEvents, xEvent *xE)
{
    DeviceIntPtr dev = NULL;
    XkbSrvInfoPtr xkbi;
    CARD8 type = xE[0].u.u.type;

    if (xE->u.u.type & EXTENSION_EVENT_BASE)
        dev = XIGetDevice(xE);

    if (!dev)
        dev = PickKeyboard(client);

    if (!dev->key)
        return;

    xkbi = dev->key->xkbInfo;

    if (client->xkbClientFlags & _XkbClientInitialized) {
        if ((xkbDebugFlags & 0x10) &&
            (type == KeyPress || type == KeyRelease ||
             type == DeviceKeyPress || type == DeviceKeyRelease))
            DebugF("[xkb] XkbFilterWriteEvents (XKB client): state 0x%04x\n",
                   xE[0].u.keyButtonPointer.state);

        if (dev->deviceGrab.grab != NullGrab && dev->deviceGrab.fromPassiveGrab
            && (type == KeyPress || type == KeyRelease || type == DeviceKeyPress
                || type == DeviceKeyRelease)) {
            unsigned int state, flags;

            flags = client->xkbClientFlags;
            state = xkbi->state.compat_grab_mods;
            if (flags & XkbPCF_GrabsUseXKBStateMask) {
                int group;

                if (flags & XkbPCF_LookupStateWhenGrabbed) {
                    group = xkbi->state.group;
                    state = xkbi->state.lookup_mods;
                }
                else {
                    state = xkbi->state.grab_mods;
                    group = xkbi->state.base_group + xkbi->state.latched_group;
                    if (group < 0 || group >= xkbi->desc->ctrls->num_groups)
                        group = XkbAdjustGroup(group, xkbi->desc->ctrls);
                }
                state = XkbBuildCoreState(state, group);
            }
            else if (flags & XkbPCF_LookupStateWhenGrabbed) {
                state = xkbi->state.compat_lookup_mods;
            }
            xE[0].u.keyButtonPointer.state = state;
        }
    }
    else {
        if ((xkbDebugFlags & 0x4) &&
            (xE[0].u.u.type == KeyPress || xE[0].u.u.type == KeyRelease ||
             xE[0].u.u.type == DeviceKeyPress ||
             xE[0].u.u.type == DeviceKeyRelease)) {
            DebugF("[xkb] XKbFilterWriteEvents (non-XKB):\n");
            DebugF("[xkb] event= 0x%04x\n", xE[0].u.keyButtonPointer.state);
            DebugF("[xkb] lookup= 0x%02x, grab= 0x%02x\n",
                   xkbi->state.lookup_mods, xkbi->state.grab_mods);
            DebugF("[xkb] compat lookup= 0x%02x, grab= 0x%02x\n",
                   xkbi->state.compat_lookup_mods,
                   xkbi->state.compat_grab_mods);
        }
        if (type >= KeyPress && type <= MotionNotify) {
            CARD16 old, new;

            old = xE[0].u.keyButtonPointer.state & ~0x1f00;
            new = xE[0].u.keyButtonPointer.state & 0x1F00;

            if (old == XkbStateFieldFromRec(&xkbi->state))
                new |= xkbi->state.compat_lookup_mods;
            else
                new |= xkbi->state.compat_grab_mods;
            xE[0].u.keyButtonPointer.state = new;
        }
        else if (type == EnterNotify || type == LeaveNotify) {
            xE[0].u.enterLeave.state &= 0x1F00;
            xE[0].u.enterLeave.state |= xkbi->state.compat_grab_mods;
        }
        else if (type >= DeviceKeyPress && type <= DeviceMotionNotify) {
            CARD16 old, new;
            deviceKeyButtonPointer *kbp = (deviceKeyButtonPointer *) &xE[0];

            old = kbp->state & ~0x1F00;
            new = kbp->state & 0x1F00;
            if (old == XkbStateFieldFromRec(&xkbi->state))
                new |= xkbi->state.compat_lookup_mods;
            else
                new |= xkbi->state.compat_grab_mods;
            kbp->state = new;
        }
    }
}

/***====================================================================***/

XkbInterestPtr
XkbFindClientResource(DevicePtr inDev, ClientPtr client)
{
    DeviceIntPtr dev = (DeviceIntPtr) inDev;
    XkbInterestPtr interest;

    if (dev->xkb_interest) {
        interest = dev->xkb_interest;
        while (interest) {
            if (interest->client == client) {
                return interest;
            }
            interest = interest->next;
        }
    }
    return NULL;
}

XkbInterestPtr
XkbAddClientResource(DevicePtr inDev, ClientPtr client, XID id)
{
    DeviceIntPtr dev = (DeviceIntPtr) inDev;
    XkbInterestPtr interest;

    interest = dev->xkb_interest;
    while (interest) {
        if (interest->client == client)
            return ((interest->resource == id) ? interest : NULL);
        interest = interest->next;
    }
    interest = calloc(1, sizeof(XkbInterestRec));
    if (interest) {
        interest->dev = dev;
        interest->client = client;
        interest->resource = id;
        interest->next = dev->xkb_interest;
        dev->xkb_interest = interest;
        return interest;
    }
    return NULL;
}

int
XkbRemoveResourceClient(DevicePtr inDev, XID id)
{
    XkbSrvInfoPtr xkbi;
    DeviceIntPtr dev = (DeviceIntPtr) inDev;
    XkbInterestPtr interest;
    Bool found;
    unsigned long autoCtrls, autoValues;
    ClientPtr client = NULL;

    found = FALSE;

    if (!dev->key || !dev->key->xkbInfo)
        return found;

    autoCtrls = autoValues = 0;
    if (dev->xkb_interest) {
        interest = dev->xkb_interest;
        if (interest && (interest->resource == id)) {
            dev->xkb_interest = interest->next;
            autoCtrls = interest->autoCtrls;
            autoValues = interest->autoCtrlValues;
            client = interest->client;
            free(interest);
            found = TRUE;
        }
        while ((!found) && (interest->next)) {
            if (interest->next->resource == id) {
                XkbInterestPtr victim = interest->next;

                interest->next = victim->next;
                autoCtrls = victim->autoCtrls;
                autoValues = victim->autoCtrlValues;
                client = victim->client;
                free(victim);
                found = TRUE;
            }
            interest = interest->next;
        }
    }
    if (found && autoCtrls && dev->key && dev->key->xkbInfo) {
        XkbEventCauseRec cause;

        xkbi = dev->key->xkbInfo;
        XkbSetCauseXkbReq(&cause, X_kbPerClientFlags, client);
        XkbEnableDisableControls(xkbi, autoCtrls, autoValues, NULL, &cause);
    }
    return found;
}
@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d508 1
a508 1
    if ((class == 0) || (class == KbdFeedbackClass)) {
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d9 2
a10 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d12 1
a12 1
Silicon Graphics makes no representation about the suitability 
d16 2
a17 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d19 3
a21 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
a239 1
            (interest->client->requestVector != InitialVector) &&
a401 1
            (interest->client->requestVector != InitialVector) &&
a447 1
            (interest->client->requestVector != InitialVector) &&
a527 1
            (interest->client->requestVector != InitialVector) &&
a579 1
            (interest->client->requestVector != InitialVector) &&
a624 1
            (interest->client->requestVector != InitialVector) &&
a667 1
            (interest->client->requestVector != InitialVector) &&
a717 1
            (interest->client->requestVector != InitialVector) &&
a760 1
            (interest->client->requestVector != InitialVector) &&
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d485 1
a485 1
              pointer pCtrl,
d505 1
a505 1
            (*kbd->kbdfeed->BellProc) (percent, kbd, (pointer) pCtrl, class);
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a61 2
    xEvent core_mn;
    deviceMappingNotify xi_mn;
a78 5
    core_mn.u.u.type = MappingNotify;
    xi_mn.type = DeviceMappingNotify;
    xi_mn.deviceid = kbd->id;
    xi_mn.time = time;

d102 1
d120 6
a125 3
            core_mn.u.mappingNotify.request = MappingModifier;
            core_mn.u.mappingNotify.firstKeyCode = 0;
            core_mn.u.mappingNotify.count = 0;
d134 8
a141 3
        xi_mn.request = MappingKeyboard;
        xi_mn.firstKeyCode = first_key;
        xi_mn.count = num_keys;
d146 8
a153 3
        xi_mn.request = MappingModifier;
        xi_mn.firstKeyCode = 0;
        xi_mn.count = 0;
d253 1
a253 1
            WriteToClient(interest->client, sizeof(xEvent), (char *) pSN);
d426 1
a426 1
            WriteToClient(interest->client, sizeof(xEvent), (char *) pCN);
d473 1
a473 1
            WriteToClient(interest->client, sizeof(xEvent), (char *) pEv);
d560 1
a560 1
            WriteToClient(interest->client, sizeof(xEvent), (char *) &bn);
d604 1
a604 1
            WriteToClient(interest->client, sizeof(xEvent), (char *) pEv);
d652 1
a652 1
            WriteToClient(interest->client, sizeof(xEvent), (char *) pEv);
d699 1
a699 1
            WriteToClient(interest->client, sizeof(xEvent), (char *) pEv);
d742 1
a742 1
            WriteToClient(interest->client, sizeof(xEvent), (char *) pEv);
d796 1
a796 1
            WriteToClient(interest->client, sizeof(xEvent), (char *) pEv);
@


1.7
log
@Update to xserver 1.11.2
@
text
@d121 1
a121 1
                                                 clients[i]->minKC + 1;
d155 1
a155 1
XkbSendNewKeyboardNotify(DeviceIntPtr kbd,xkbNewKeyboardNotify *pNKN)
d164 1
a164 1
    for (i=1; i<currentMaxClients; i++) {
d175 3
a177 4
            int n;
            swaps(&pNKN->sequenceNumber,n);
            swapl(&pNKN->time,n);
            swaps(&pNKN->changed,n);
d196 1
a196 1
XkbSendStateNotify(DeviceIntPtr kbd,xkbStateNotify *pSN)
d198 5
a202 5
XkbSrvInfoPtr	xkbi;
XkbStatePtr	state;
XkbInterestPtr	interest;
Time 		time;
register CARD16	changed,bState;
d206 1
a206 1
	return;
d208 1
a208 1
    state= &xkbi->state;
d229 1
a229 1
    bState= pSN->ptrBtnState;
d232 17
a248 18
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->stateNotifyMask&changed)) {
	    pSN->sequenceNumber = interest->client->sequence;
	    pSN->time = time;
	    pSN->changed = changed;
	    pSN->ptrBtnState = bState;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pSN->sequenceNumber,n);
		swapl(&pSN->time,n);
		swaps(&pSN->changed,n);
		swaps(&pSN->ptrBtnState,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pSN);
	}
	interest= interest->next;
d260 1
a260 1
XkbSendMapNotify(DeviceIntPtr kbd, xkbMapNotify *pMN)
d286 3
a288 4
            int n;
            swaps(&pMN->sequenceNumber, n);
            swapl(&pMN->time, n);
            swaps(&pMN->changed, n);
d298 4
a301 5
XkbComputeControlsNotify(	DeviceIntPtr	 	kbd,
				XkbControlsPtr		old,
				XkbControlsPtr		new,
				xkbControlsNotify *	pCN,
				Bool			forceCtrlProc)
d303 2
a304 2
int		i;
CARD32 		changedControls;
d306 1
a306 1
    changedControls= 0;
d310 6
a315 6
    
    if (old->enabled_ctrls!=new->enabled_ctrls)
	changedControls|= XkbControlsEnabledMask;
    if ((old->repeat_delay!=new->repeat_delay)||
	(old->repeat_interval!=new->repeat_interval))
	changedControls|= XkbRepeatKeysMask;
d317 40
a356 39
	if (old->per_key_repeat[i] != new->per_key_repeat[i])
	    changedControls|= XkbPerKeyRepeatMask;
    if (old->slow_keys_delay!=new->slow_keys_delay)
	changedControls|= XkbSlowKeysMask;
    if (old->debounce_delay!=new->debounce_delay)
	changedControls|= XkbBounceKeysMask;
    if ((old->mk_delay!=new->mk_delay)||
	(old->mk_interval!=new->mk_interval)||
	(old->mk_dflt_btn!=new->mk_dflt_btn))
	changedControls|= XkbMouseKeysMask;
    if ((old->mk_time_to_max!=new->mk_time_to_max)||
	(old->mk_curve!=new->mk_curve)||
	(old->mk_max_speed!=new->mk_max_speed))
	changedControls|= XkbMouseKeysAccelMask;
    if (old->ax_options!=new->ax_options)
	changedControls|= XkbAccessXKeysMask;
    if ((old->ax_options^new->ax_options) & XkbAX_SKOptionsMask)
	changedControls|= XkbStickyKeysMask;
    if ((old->ax_options^new->ax_options) & XkbAX_FBOptionsMask)
	changedControls|= XkbAccessXFeedbackMask;
    if ((old->ax_timeout!=new->ax_timeout)||
	(old->axt_ctrls_mask!=new->axt_ctrls_mask)||
	(old->axt_ctrls_values!=new->axt_ctrls_values)||
	(old->axt_opts_mask!=new->axt_opts_mask)||
	(old->axt_opts_values!= new->axt_opts_values)) {
	changedControls|= XkbAccessXTimeoutMask;
    }
    if ((old->internal.mask!=new->internal.mask)||
	(old->internal.real_mods!=new->internal.real_mods)||
	(old->internal.vmods!=new->internal.vmods))
	changedControls|= XkbInternalModsMask;
    if ((old->ignore_lock.mask!=new->ignore_lock.mask)||
	(old->ignore_lock.real_mods!=new->ignore_lock.real_mods)||
	(old->ignore_lock.vmods!=new->ignore_lock.vmods))
	changedControls|= XkbIgnoreLockModsMask;

    if (new->enabled_ctrls&XkbRepeatKeysMask)
	 kbd->kbdfeed->ctrl.autoRepeat=TRUE;
    else kbd->kbdfeed->ctrl.autoRepeat=FALSE;
d359 2
a360 2
	(changedControls || forceCtrlProc))
	(*kbd->kbdfeed->CtrlProc)(kbd, &kbd->kbdfeed->ctrl);
d362 2
a363 2
    if ((!changedControls)&&(old->num_groups==new->num_groups))
	return 0;
d366 1
a366 1
	return 0;
d370 1
a370 1
    pCN->enabledControlChanges = (new->enabled_ctrls^old->enabled_ctrls);
d377 1
a377 1
XkbSendControlsNotify(DeviceIntPtr kbd,xkbControlsNotify *pCN)
d379 5
a383 5
int			initialized;
CARD32 		 	changedControls, enabledControls, enabledChanges = 0;
XkbSrvInfoPtr		xkbi;
XkbInterestPtr		interest;
Time 		 	time = 0;
d387 1
a387 1
	return;
d389 1
a389 1
 
d393 1
a393 1
    pCN->numGroups= xkbi->desc->ctrls->num_groups;
d395 27
a421 28
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->ctrlsNotifyMask&changedControls)) {
	    if (!initialized) {
		pCN->type = XkbEventCode + XkbEventBase;
		pCN->xkbType = XkbControlsNotify;
		pCN->deviceID = kbd->id;
		pCN->time = time = GetTimeInMillis();
		enabledChanges = pCN->enabledControlChanges;
		initialized= 1;
	    }
	    pCN->changedControls = changedControls;
	    pCN->enabledControls = enabledControls;
	    pCN->enabledControlChanges = enabledChanges;
	    pCN->sequenceNumber = interest->client->sequence;
	    pCN->time = time;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pCN->sequenceNumber,n);
		swapl(&pCN->changedControls,n);
		swapl(&pCN->enabledControls,n);
		swapl(&pCN->enabledControlChanges,n);
		swapl(&pCN->time,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pCN);
	}
	interest= interest->next;
d427 1
a427 1
XkbSendIndicatorNotify(DeviceIntPtr kbd,int xkbType,xkbIndicatorNotify *pEv)
d429 4
a432 4
int		initialized;
XkbInterestPtr	interest;
Time 		time = 0;
CARD32		state,changed;
d436 2
a437 2
	return;
 
d442 27
a468 28
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (((xkbType==XkbIndicatorStateNotify)&&
				(interest->iStateNotifyMask&changed))||
	     ((xkbType==XkbIndicatorMapNotify)&&
	    			(interest->iMapNotifyMask&changed)))) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = xkbType;
		pEv->deviceID = kbd->id;
		pEv->time = time = GetTimeInMillis();
		initialized= 1;
	    }
	    pEv->sequenceNumber = interest->client->sequence;
	    pEv->time = time;
	    pEv->changed = changed;
	    pEv->state = state;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
		swapl(&pEv->changed,n);
		swapl(&pEv->state,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
a472 1

d474 15
a488 18
XkbHandleBell(	BOOL		 force,
		BOOL		 eventOnly,
		DeviceIntPtr	 kbd,
		CARD8		 percent,
		pointer		 pCtrl,
		CARD8		 class,
		Atom		 name,
		WindowPtr	 pWin,
		ClientPtr	 pClient)
{
xkbBellNotify	bn;
int		initialized;
XkbSrvInfoPtr	xkbi;
XkbInterestPtr	interest;
CARD8		id;
CARD16		pitch,duration;
Time 		time = 0;
XID		winID = 0;
d495 2
a496 2
    if ((force||(xkbi->desc->ctrls->enabled_ctrls&XkbAudibleBellMask))&&
							(!eventOnly)) {
d498 1
a498 1
            (*kbd->kbdfeed->BellProc)(percent,kbd,(pointer)pCtrl,class);
d501 5
a505 2
    if ((!interest)||(force))
	return;
d507 3
a509 11
    if ((class==0)||(class==KbdFeedbackClass)) {
	KeybdCtrl *pKeyCtrl= (KeybdCtrl *)pCtrl;
	id= pKeyCtrl->id;
	pitch= pKeyCtrl->bell_pitch;
	duration= pKeyCtrl->bell_duration;
    }
    else if (class==BellFeedbackClass) {
	BellCtrl *pBellCtrl= (BellCtrl *)pCtrl;
	id= pBellCtrl->id;
	pitch= pBellCtrl->pitch;
	duration= pBellCtrl->duration;
d511 10
a520 2
    else return;
 
d523 33
a555 34
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->bellNotifyMask)) {
	    if (!initialized) {
		time = GetTimeInMillis();
		bn.type = XkbEventCode + XkbEventBase;
		bn.xkbType = XkbBellNotify;
		bn.deviceID = kbd->id;
		bn.bellClass = class;
		bn.bellID = id;
		bn.percent= percent;
		bn.eventOnly = (eventOnly!=0);
		winID= (pWin?pWin->drawable.id:None);
		initialized= 1;
	    }
	    bn.sequenceNumber = interest->client->sequence;
	    bn.time = time;
	    bn.pitch = pitch;
	    bn.duration = duration;
	    bn.name = name;
	    bn.window=  winID;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&bn.sequenceNumber,n);
		swapl(&bn.time,n);
		swaps(&bn.pitch,n);
		swaps(&bn.duration,n);
		swapl(&bn.name,n);
		swapl(&bn.window,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)&bn);
	}
	interest= interest->next;
d561 6
a566 6
XkbSendAccessXNotify(DeviceIntPtr kbd,xkbAccessXNotify *pEv)
{
int		initialized;
XkbInterestPtr	interest;
Time 		time = 0;
CARD16		sk_delay,db_delay;
d570 2
a571 2
	return;
 
d573 2
a574 2
    sk_delay= pEv->slowKeysDelay;
    db_delay= pEv->debounceDelay;
d576 24
a599 25
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->accessXNotifyMask&(1<<pEv->detail))) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = XkbAccessXNotify;
		pEv->deviceID = kbd->id;
		pEv->time = time = GetTimeInMillis();
		initialized= 1;
	    }
	    pEv->sequenceNumber = interest->client->sequence;
	    pEv->time = time;
	    pEv->slowKeysDelay = sk_delay;
	    pEv->debounceDelay = db_delay;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
		swaps(&pEv->slowKeysDelay,n);
		swaps(&pEv->debounceDelay,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
d605 7
a611 7
XkbSendNamesNotify(DeviceIntPtr kbd,xkbNamesNotify *pEv)
{
int		initialized;
XkbInterestPtr	interest;
Time 		time = 0;
CARD16		changed,changedVirtualMods;
CARD32		changedIndicators;
d615 2
a616 2
	return;
 
d618 3
a620 3
    changed= pEv->changed;
    changedIndicators= pEv->changedIndicators;
    changedVirtualMods= pEv->changedVirtualMods;
d622 26
a647 27
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->namesNotifyMask&pEv->changed)) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = XkbNamesNotify;
		pEv->deviceID = kbd->id;
		pEv->time = time = GetTimeInMillis();
		initialized= 1;
	    }
	    pEv->sequenceNumber = interest->client->sequence;
	    pEv->time = time;
	    pEv->changed = changed;
	    pEv->changedIndicators = changedIndicators;
	    pEv->changedVirtualMods= changedVirtualMods;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
		swaps(&pEv->changed,n);
		swapl(&pEv->changedIndicators,n);
		swaps(&pEv->changedVirtualMods,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
d653 6
a658 6
XkbSendCompatMapNotify(DeviceIntPtr kbd,xkbCompatMapNotify *pEv)
{
int		initialized;
XkbInterestPtr	interest;
Time 		time = 0;
CARD16		firstSI = 0, nSI = 0, nTotalSI = 0;
d662 2
a663 2
	return;
 
d666 29
a694 30
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->compatNotifyMask)) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = XkbCompatMapNotify;
		pEv->deviceID = kbd->id;
		pEv->time = time = GetTimeInMillis();
		firstSI= pEv->firstSI;
		nSI= pEv->nSI;
		nTotalSI= pEv->nTotalSI;
		initialized= 1;
	    }
	    pEv->sequenceNumber = interest->client->sequence;
	    pEv->time = time;
	    pEv->firstSI = firstSI;
	    pEv->nSI = nSI;
	    pEv->nTotalSI = nTotalSI;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
		swaps(&pEv->firstSI,n);
		swaps(&pEv->nSI,n);
		swaps(&pEv->nTotalSI,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
d700 6
a705 6
XkbSendActionMessage(DeviceIntPtr kbd,xkbActionMessage *pEv)
{
int		 initialized;
XkbSrvInfoPtr	 xkbi;
XkbInterestPtr	 interest;
Time 		 time = 0;
d709 2
a710 2
	return;
 
d714 2
a715 2
    pEv->mods= xkbi->state.mods;
    pEv->group= xkbi->state.group;
d717 21
a737 22
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->actionMessageMask)) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = XkbActionMessage;
		pEv->deviceID = kbd->id;
		pEv->sequenceNumber = interest->client->sequence;
		pEv->time = time = GetTimeInMillis();
		initialized= 1;
	    }
	    pEv->sequenceNumber = interest->client->sequence;
	    pEv->time = time;
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
d743 8
a750 9
XkbSendExtensionDeviceNotify(	DeviceIntPtr 			dev,
				ClientPtr			client,
				xkbExtensionDeviceNotify *	pEv)
{
int		 initialized;
XkbInterestPtr	 interest;
Time 		 time = 0;
CARD32		 defined, state;
CARD16		 reason;
d754 2
a755 2
	return;
 
d757 3
a759 3
    reason= pEv->reason;
    defined= pEv->ledsDefined;
    state= pEv->ledState;
d761 31
a791 32
	if ((!interest->client->clientGone) &&
	    (interest->client->requestVector != InitialVector) &&
	    (interest->client->xkbClientFlags&_XkbClientInitialized) &&
	    (interest->extDevNotifyMask&reason)) {
	    if (!initialized) {
		pEv->type = XkbEventCode + XkbEventBase;
		pEv->xkbType = XkbExtensionDeviceNotify;
		pEv->deviceID = dev->id;
		pEv->sequenceNumber = interest->client->sequence;
		pEv->time = time = GetTimeInMillis();
		initialized= 1;
	    }
	    else {
		pEv->sequenceNumber = interest->client->sequence;
		pEv->time = time;
		pEv->ledsDefined= defined;
		pEv->ledState= state;
		pEv->reason= reason;
		pEv->supported= XkbXI_AllFeaturesMask;
	    }
	    if ( interest->client->swapped ) {
		register int n;
		swaps(&pEv->sequenceNumber,n);
		swapl(&pEv->time,n);
		swapl(&pEv->ledsDefined,n);
		swapl(&pEv->ledState,n);
		swaps(&pEv->reason,n);
		swaps(&pEv->supported,n);
	    }
	    WriteToClient(interest->client, sizeof(xEvent), (char *)pEv);
	}
	interest= interest->next;
d797 2
a798 3
XkbSendNotification(	DeviceIntPtr		kbd,
			XkbChangesPtr		pChanges,
			XkbEventCausePtr	cause)
d800 1
a800 1
XkbSrvLedInfoPtr	sli;
d802 1
a802 1
    sli= NULL;
d804 8
a811 7
	xkbStateNotify sn;
	sn.changed= pChanges->state_changes;
	sn.keycode= cause->kc;
	sn.eventType= cause->event;
	sn.requestMajor= cause->mjr;
	sn.requestMinor= cause->mnr;
	XkbSendStateNotify(kbd,&sn);
d814 33
a846 31
	xkbMapNotify mn;
	memset(&mn, 0, sizeof(xkbMapNotify));
	mn.changed= pChanges->map.changed;
	mn.firstType= pChanges->map.first_type;
	mn.nTypes= pChanges->map.num_types;
	mn.firstKeySym= pChanges->map.first_key_sym;
	mn.nKeySyms= pChanges->map.num_key_syms;
	mn.firstKeyAct= pChanges->map.first_key_act;
	mn.nKeyActs= pChanges->map.num_key_acts;
	mn.firstKeyBehavior= pChanges->map.first_key_behavior;
	mn.nKeyBehaviors= pChanges->map.num_key_behaviors;
	mn.virtualMods= pChanges->map.vmods;
	mn.firstKeyExplicit= pChanges->map.first_key_explicit;
	mn.nKeyExplicit= pChanges->map.num_key_explicit;
	mn.firstModMapKey= pChanges->map.first_modmap_key;
	mn.nModMapKeys= pChanges->map.num_modmap_keys;
	mn.firstVModMapKey= pChanges->map.first_vmodmap_key;
	mn.nVModMapKeys= pChanges->map.num_vmodmap_keys;
	XkbSendMapNotify(kbd,&mn);
    }
    if ((pChanges->ctrls.changed_ctrls)||
	(pChanges->ctrls.enabled_ctrls_changes)) {
	xkbControlsNotify cn;
	memset(&cn, 0, sizeof(xkbControlsNotify));
	cn.changedControls= pChanges->ctrls.changed_ctrls;
	cn.enabledControlChanges= pChanges->ctrls.enabled_ctrls_changes;
	cn.keycode= cause->kc;
	cn.eventType= cause->event;
	cn.requestMajor= cause->mjr;
	cn.requestMinor= cause->mnr;
	XkbSendControlsNotify(kbd,&cn);
d849 8
a856 7
	xkbIndicatorNotify in;
	if (sli==NULL)
	    sli= XkbFindSrvLedInfo(kbd,XkbDfltXIClass,XkbDfltXIId,0);
	memset(&in, 0, sizeof(xkbIndicatorNotify));
	in.state= sli->effectiveState;
	in.changed= pChanges->indicators.map_changes;
	XkbSendIndicatorNotify(kbd,XkbIndicatorMapNotify,&in);
d859 8
a866 7
	xkbIndicatorNotify in;
	if (sli==NULL)
	    sli= XkbFindSrvLedInfo(kbd,XkbDfltXIClass,XkbDfltXIId,0);
	memset(&in, 0, sizeof(xkbIndicatorNotify));
	in.state= sli->effectiveState;
	in.changed= pChanges->indicators.state_changes;
	XkbSendIndicatorNotify(kbd,XkbIndicatorStateNotify,&in);
d869 22
a890 20
	xkbNamesNotify nn;
	memset(&nn, 0, sizeof(xkbNamesNotify));
	nn.changed= pChanges->names.changed;
	nn.firstType= pChanges->names.first_type;
	nn.nTypes= pChanges->names.num_types;
	nn.firstLevelName= pChanges->names.first_lvl;
	nn.nLevelNames= pChanges->names.num_lvls;
	nn.nRadioGroups= pChanges->names.num_rg;
	nn.changedVirtualMods= pChanges->names.changed_vmods;
	nn.changedIndicators= pChanges->names.changed_indicators;
	XkbSendNamesNotify(kbd,&nn);
    }
    if ((pChanges->compat.changed_groups)||(pChanges->compat.num_si>0)) {
	xkbCompatMapNotify cmn;
	memset(&cmn, 0, sizeof(xkbCompatMapNotify));
	cmn.changedGroups= pChanges->compat.changed_groups;
	cmn.firstSI= pChanges->compat.first_si;
	cmn.nSI= pChanges->compat.num_si;
	cmn.nTotalSI= kbd->key->xkbInfo->desc->compat->num_si;
	XkbSendCompatMapNotify(kbd,&cmn);
d898 1
a898 1
XkbFilterEvents(ClientPtr client,int nEvents,xEvent *xE)
d916 1
a916 1
	if ((xkbDebugFlags&0x10)&&
d919 1
a919 1
	    DebugF("[xkb] XkbFilterWriteEvents (XKB client): state 0x%04x\n",
d922 24
a945 23
	if (dev->deviceGrab.grab != NullGrab && dev->deviceGrab.fromPassiveGrab &&
	    (type == KeyPress || type == KeyRelease ||
             type == DeviceKeyPress || type == DeviceKeyRelease)) {
	    unsigned int state, flags;

	    flags = client->xkbClientFlags;
	    state = xkbi->state.compat_grab_mods;
	    if (flags & XkbPCF_GrabsUseXKBStateMask) {
		int group;
		if (flags & XkbPCF_LookupStateWhenGrabbed) {
		     group = xkbi->state.group;
		     state = xkbi->state.lookup_mods;
		}
		else {
		    state = xkbi->state.grab_mods;
		    group = xkbi->state.base_group + xkbi->state.latched_group;
		    if (group < 0 || group >= xkbi->desc->ctrls->num_groups)
			group = XkbAdjustGroup(group, xkbi->desc->ctrls);
		}
		state = XkbBuildCoreState(state, group);
	    }
	    else if (flags & XkbPCF_LookupStateWhenGrabbed) {
		state = xkbi->state.compat_lookup_mods;
d947 2
a948 2
	    xE[0].u.keyButtonPointer.state = state;
	}
d952 1
a952 1
	    (xE[0].u.u.type == KeyPress || xE[0].u.u.type==KeyRelease ||
d955 3
a957 3
	    DebugF("[xkb] XKbFilterWriteEvents (non-XKB):\n");
	    DebugF("[xkb] event= 0x%04x\n",xE[0].u.keyButtonPointer.state);
	    DebugF("[xkb] lookup= 0x%02x, grab= 0x%02x\n",
d959 13
a971 12
	    DebugF("[xkb] compat lookup= 0x%02x, grab= 0x%02x\n",
		   xkbi->state.compat_lookup_mods, xkbi->state.compat_grab_mods);
	}
	if (type >= KeyPress && type <= MotionNotify) {
	    CARD16 old, new;

	    old = xE[0].u.keyButtonPointer.state & ~0x1f00;
	    new = xE[0].u.keyButtonPointer.state & 0x1F00;

	    if (old == XkbStateFieldFromRec(&xkbi->state))
		new |= xkbi->state.compat_lookup_mods;
	    else
d973 6
a978 6
	    xE[0].u.keyButtonPointer.state = new;
	}
	else if (type == EnterNotify || type == LeaveNotify) {
	    xE[0].u.enterLeave.state &= 0x1F00;
	    xE[0].u.enterLeave.state |= xkbi->state.compat_grab_mods;
	}
d981 1
a981 1
            deviceKeyButtonPointer *kbp = (deviceKeyButtonPointer*) &xE[0];
d985 3
a987 3
	    if (old == XkbStateFieldFromRec(&xkbi->state))
		new |= xkbi->state.compat_lookup_mods;
	    else
d997 1
a997 1
XkbFindClientResource(DevicePtr inDev,ClientPtr client)
d999 2
a1000 2
DeviceIntPtr	dev = (DeviceIntPtr)inDev;
XkbInterestPtr	interest;
d1002 8
a1009 8
    if ( dev->xkb_interest ) {
	interest = dev->xkb_interest;
	while (interest){
	    if (interest->client==client) {
		return interest;
	    }
	    interest = interest->next;
	}
d1015 1
a1015 1
XkbAddClientResource(DevicePtr inDev,ClientPtr client,XID id)
d1017 2
a1018 2
DeviceIntPtr	dev = (DeviceIntPtr)inDev;
XkbInterestPtr	interest;
d1022 3
a1024 3
	if (interest->client==client)
	    return ((interest->resource==id)?interest:NULL);
	interest = interest->next;
d1028 6
a1033 6
	interest->dev = dev;
	interest->client = client;
	interest->resource = id;
	interest->next = dev->xkb_interest;
	dev->xkb_interest= interest;
	return interest;
d1039 1
a1039 1
XkbRemoveResourceClient(DevicePtr inDev,XID id) 
d1041 6
a1046 6
XkbSrvInfoPtr	xkbi;
DeviceIntPtr	dev = (DeviceIntPtr)inDev;
XkbInterestPtr	interest;
Bool		found;
unsigned long	autoCtrls,autoValues;
ClientPtr	client = NULL;
d1048 1
a1048 1
    found= FALSE;
d1053 31
a1083 30
    autoCtrls= autoValues= 0;
    if ( dev->xkb_interest ) {
	interest = dev->xkb_interest;
	if (interest && (interest->resource==id)){
	    dev->xkb_interest = interest->next;
	    autoCtrls= interest->autoCtrls;
	    autoValues= interest->autoCtrlValues;
	    client= interest->client;
	    free(interest);
	    found= TRUE;
	}
	while ((!found)&&(interest->next)) {
	    if (interest->next->resource==id) {
		XkbInterestPtr	victim = interest->next;
		interest->next = victim->next;
		autoCtrls= victim->autoCtrls;
		autoValues= victim->autoCtrlValues;
		client= victim->client;
		free(victim);
		found= TRUE;
	    }
	    interest = interest->next;
	}
    }
    if (found && autoCtrls && dev->key && dev->key->xkbInfo ) {
	XkbEventCauseRec cause;

	xkbi= dev->key->xkbInfo;
	XkbSetCauseXkbReq(&cause,X_kbPerClientFlags,client);
	XkbEnableDisableControls(xkbi,autoCtrls,autoValues,NULL,&cause);
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a40 1
#include "exevents.h"
d91 5
a95 4
        /* Ignore clients which will have already received this.
         * Inconsistent with themselves, but consistent with previous
         * behaviour.*/
        if (xkb_event == XkbMapNotify && (clients[i]->mapNotifyMask & changed))
d97 3
a170 3
        if (!XIShouldNotify(clients[i], kbd))
            continue;

d236 1
a236 2
	    (interest->stateNotifyMask&changed) &&
            XIShouldNotify(interest->client,kbd)) {
a282 3
        if (!XIShouldNotify(clients[i], kbd))
            continue;

d401 1
a401 2
	    (interest->ctrlsNotifyMask&changedControls) &&
            XIShouldNotify(interest->client, kbd)) {
a448 1
            XIShouldNotify(interest->client, kbd) &&
d532 1
a532 2
	    (interest->bellNotifyMask) &&
            XIShouldNotify(interest->client,kbd)) {
d586 1
a586 2
	    (interest->accessXNotifyMask&(1<<pEv->detail)) &&
            XIShouldNotify(interest->client, kbd)) {
d633 1
a633 2
	    (interest->namesNotifyMask&pEv->changed) &&
            XIShouldNotify(interest->client, kbd)) {
d678 1
a678 2
	    (interest->compatNotifyMask) &&
            XIShouldNotify(interest->client, kbd)) {
d730 1
a730 2
	    (interest->actionMessageMask) &&
            XIShouldNotify(interest->client, kbd)) {
d776 1
a776 2
	    (interest->extDevNotifyMask&reason) &&
            XIShouldNotify(interest->client, dev)) {
a1035 9
	interest->stateNotifyMask= 0;
	interest->ctrlsNotifyMask= 0;
	interest->namesNotifyMask= 0;
	interest->compatNotifyMask= 0;
	interest->bellNotifyMask= FALSE;
	interest->accessXNotifyMask= 0;
	interest->iStateNotifyMask= 0;
	interest->iMapNotifyMask= 0;
	interest->altSymsNotifyMask= 0;
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a104 1
        core_mn.u.u.sequenceNumber = clients[i]->sequence;
d1043 1
a1043 2
    interest = xalloc(sizeof(XkbInterestRec));
    bzero(interest,sizeof(XkbInterestRec));
d1087 1
a1087 1
	    xfree(interest);
d1097 1
a1097 1
		xfree(victim);
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a31 1
#define NEED_EVENTS 1
d38 2
d47 105
d154 4
a157 4
{		
register int	i;
Time 		time;
CARD16		changed;
a160 2
    pNKN->time = time = GetTimeInMillis();
    changed = pNKN->changed;
d163 19
a181 4
        if ((!clients[i]) || clients[i]->clientGone ||
				(clients[i]->requestVector==InitialVector)) {
	    continue;
	}
d183 4
a186 33
	if (clients[i]->xkbClientFlags&_XkbClientInitialized)  {
	    if (clients[i]->newKeyboardNotifyMask&changed) {
		pNKN->sequenceNumber = clients[i]->sequence;
		pNKN->time = time;
		pNKN->changed = changed;
		if ( clients[i]->swapped ) {
		    register int n;
		    swaps(&pNKN->sequenceNumber,n);
		    swapl(&pNKN->time,n);
		    swaps(&pNKN->changed,n);
		}
		WriteToClient(clients[i],sizeof(xEvent),(char *)pNKN);
		if (changed&XkbNKN_KeycodesMask) {
		    clients[i]->minKC= pNKN->minKeyCode;
		    clients[i]->maxKC= pNKN->maxKeyCode;
		}
	    }
	}
	else if (changed&XkbNKN_KeycodesMask) {
	    xEvent	event;
	    event.u.u.type= MappingNotify;
	    event.u.mappingNotify.request= MappingKeyboard;
	    event.u.mappingNotify.firstKeyCode= clients[i]->minKC;
	    event.u.mappingNotify.count= clients[i]->maxKC-clients[i]->minKC+1;
	    event.u.u.sequenceNumber= clients[i]->sequence;
	    if (clients[i]->swapped) {
		int n;
		swaps(&event.u.u.sequenceNumber,n);
	    }
	    WriteToClient(clients[i],SIZEOF(xEvent), (char *)&event);
	    event.u.mappingNotify.request= MappingModifier;
	    WriteToClient(clients[i],SIZEOF(xEvent), (char *)&event);
	}
d188 4
d237 2
a238 1
	    (interest->stateNotifyMask&changed)) {
d259 4
d264 1
a264 1
XkbSendMapNotify(DeviceIntPtr kbd,xkbMapNotify *pMN)
d266 34
a299 4
int 		i;
XkbSrvInfoPtr	xkbi;
unsigned	time = 0,initialized;
CARD16		changed;
d301 2
a302 35
    if (!kbd->key || !kbd->key->xkbInfo)
        return;

    xkbi = kbd->key->xkbInfo;
    initialized= 0;

    changed = pMN->changed;
    pMN->minKeyCode= xkbi->desc->min_key_code;
    pMN->maxKeyCode= xkbi->desc->max_key_code;
    for (i=1; i<currentMaxClients; i++) {
        if (clients[i] && ! clients[i]->clientGone &&
	    (clients[i]->requestVector != InitialVector) &&
	    (clients[i]->xkbClientFlags&_XkbClientInitialized) &&
	    (clients[i]->mapNotifyMask&changed))
	{
	    if (!initialized) {
		pMN->type = XkbEventCode + XkbEventBase;
		pMN->xkbType = XkbMapNotify;
		pMN->deviceID = kbd->id;
		time = GetTimeInMillis();
		initialized= 1;
	    }
	    pMN->time= time;
	    pMN->sequenceNumber = clients[i]->sequence;
	    pMN->changed = changed;
	    if ( clients[i]->swapped ) {
		register int n;
		swaps(&pMN->sequenceNumber,n);
		swapl(&pMN->time,n);
		swaps(&pMN->changed,n);
	    }
	    WriteToClient(clients[i],sizeof(xEvent),(char *)pMN);
	}
    }
    return;
d406 2
a407 1
	    (interest->ctrlsNotifyMask&changedControls)) {
d455 1
d539 2
a540 1
	    (interest->bellNotifyMask)) {
d594 2
a595 1
	    (interest->accessXNotifyMask&(1<<pEv->detail))) {
d642 2
a643 1
	    (interest->namesNotifyMask&pEv->changed)) {
d688 2
a689 1
	    (interest->compatNotifyMask)) {
d741 2
a742 1
	    (interest->actionMessageMask)) {
d774 1
a774 1
CARD16		 reason, supported = 0;
d788 2
a789 1
	    (interest->extDevNotifyMask&reason)) {
a795 1
		supported= pEv->supported;
d804 1
a804 8
		pEv->supported= supported;
	    }
	    if (client!=interest->client) {
		/* only report UnsupportedFeature to the client that */
		/* issued the failing request */
		pEv->reason&= ~XkbXI_UnsupportedFeatureMask;
		if ((interest->extDevNotifyMask&reason)==0)
		    continue;
d841 1
d863 1
d876 1
d885 1
d892 1
d905 1
d917 2
a918 2
Bool
XkbFilterEvents(ClientPtr pClient,int nEvents,xEvent *xE)
d920 3
a922 3
int	i, button_mask;
DeviceIntPtr pXDev = inputInfo.keyboard;
XkbSrvInfoPtr	xkbi;
d925 7
a931 5
    {
        pXDev = XIGetDevice(xE);
        if (!pXDev)
            pXDev = inputInfo.keyboard;
    }
d933 1
a933 1
    xkbi= (pXDev->key) ? pXDev->key->xkbInfo : NULL;
d935 1
a935 1
    if ( pClient->xkbClientFlags & _XkbClientInitialized ) {
d937 9
a945 29
		((xE[0].u.u.type==KeyPress)||(xE[0].u.u.type==KeyRelease)||
                 (xE[0].u.u.type==DeviceKeyPress)||
                 (xE[0].u.u.type == DeviceKeyRelease))) {
	    DebugF("[xkb] XKbFilterWriteEvents:\n");
	    DebugF("[xkb]    Event state= 0x%04x\n",xE[0].u.keyButtonPointer.state);
	    DebugF("[xkb]    XkbLastRepeatEvent!=xE (0x%p!=0x%p) %s\n",
			XkbLastRepeatEvent,xE,
			((XkbLastRepeatEvent!=(pointer)xE)?"True":"False"));
	    DebugF("[xkb]   (xkbClientEventsFlags&XWDA)==0 (0x%x) %s\n",
		pClient->xkbClientFlags,
		(_XkbWantsDetectableAutoRepeat(pClient)?"True":"False"));
	    DebugF("[xkb]   !IsRelease(%d) %s\n",xE[0].u.u.type,
			(!_XkbIsReleaseEvent(xE[0].u.u.type))?"True":"False");
	}
	if (	(XkbLastRepeatEvent==(pointer)xE) &&
	     	(_XkbWantsDetectableAutoRepeat(pClient)) &&
	     	(_XkbIsReleaseEvent(xE[0].u.u.type)) ) {
	    return False;
	}

        if (!xkbi)
            return True;

	if ((pXDev->deviceGrab.grab != NullGrab) 
                && pXDev->deviceGrab.fromPassiveGrab &&
	    ((xE[0].u.u.type==KeyPress)||(xE[0].u.u.type==KeyRelease)||
             (xE[0].u.u.type==DeviceKeyPress)||
             (xE[0].u.u.type == DeviceKeyRelease))) {
	    register unsigned state,flags;
d947 2
a948 2
	    flags= pClient->xkbClientFlags;
	    state= xkbi->state.compat_grab_mods;
d951 3
a953 3
		if (flags&XkbPCF_LookupStateWhenGrabbed) {
		     group= xkbi->state.group;
		     state= xkbi->state.lookup_mods;
d956 4
a959 5
		    state= xkbi->state.grab_mods;
		    group= xkbi->state.base_group+xkbi->state.latched_group;
		    if ((group<0)||(group>=xkbi->desc->ctrls->num_groups)) {
			group= XkbAdjustGroup(group,xkbi->desc->ctrls);
		    }
d963 5
a967 15
	    else if (flags&XkbPCF_LookupStateWhenGrabbed)
		state= xkbi->state.compat_lookup_mods;
	    xE[0].u.keyButtonPointer.state= state;
	}
	button_mask = 1 << xE[0].u.u.detail;
	if (xE[0].u.u.type == ButtonPress &&
	    ((xE[0].u.keyButtonPointer.state >> 7) & button_mask) == button_mask &&
	    (xkbi->lockedPtrButtons & button_mask) == button_mask) {
	    /* If the MouseKeys is pressed, and the "real" mouse is also pressed
	     * when the mouse is released, the server does not behave properly.
	     * Faking a release of the button here solves the problem.
	     */
	    DebugF("[xkb] Faking release of button %d\n", xE[0].u.u.detail);
	    XkbDDXFakeDeviceButton(xkbi->device, 0, xE[0].u.u.detail);
        }
d970 13
a982 1
	register CARD8 	type;
d984 2
a985 2
        if (!xkbi)
            return True;
d987 9
a995 50
	for (i=0;i<nEvents;i++) {
	    type= xE[i].u.u.type;
	    if ((xkbDebugFlags&0x4)&&
		((xE[i].u.u.type==KeyPress)||(xE[i].u.u.type==KeyRelease)||
                 (xE[i].u.u.type==DeviceKeyPress)||
                 (xE[i].u.u.type == DeviceKeyRelease))) {
		DebugF("[xkb] XKbFilterWriteEvents (non-XKB):\n");
		DebugF("[xkb] event= 0x%04x\n",xE[i].u.keyButtonPointer.state);
		DebugF("[xkb] lookup= 0x%02x, grab= 0x%02x\n",xkbi->state.lookup_mods,
							xkbi->state.grab_mods);
		DebugF("[xkb] compat lookup= 0x%02x, grab= 0x%02x\n",
							xkbi->state.compat_lookup_mods,
							xkbi->state.compat_grab_mods);
	    }
	    if ( (type>=KeyPress)&&(type<=MotionNotify) ) {
		CARD16	old,new;

		old= xE[i].u.keyButtonPointer.state&(~0x1f00);
		new= xE[i].u.keyButtonPointer.state&0x1F00;

		if (old==XkbStateFieldFromRec(&xkbi->state))
		     new|= xkbi->state.compat_lookup_mods;
		else new|= xkbi->state.compat_grab_mods;
		xE[i].u.keyButtonPointer.state= new;
	    }
	    else if ((type==EnterNotify)||(type==LeaveNotify)) {
		xE[i].u.enterLeave.state&= 0x1F00;
		xE[i].u.enterLeave.state|= xkbi->state.compat_grab_mods;
	    } else if ((type>=DeviceKeyPress)&&(type<=DeviceMotionNotify)) {
                CARD16  old, new;
                deviceKeyButtonPointer *kbp = (deviceKeyButtonPointer*)&xE[i];
                old= kbp->state&(~0x1F00);
                new= kbp->state&0x1F00;
		if (old==XkbStateFieldFromRec(&xkbi->state))
		     new|= xkbi->state.compat_lookup_mods;
		else new|= xkbi->state.compat_grab_mods;
                kbp->state= new;
            }
	    button_mask = 1 << xE[i].u.u.detail;
	    if (type == ButtonPress &&
		((xE[i].u.keyButtonPointer.state >> 7) & button_mask) == button_mask &&
		(xkbi->lockedPtrButtons & button_mask) == button_mask) {
		DebugF("[xkb] Faking release of button %d\n", xE[i].u.u.detail);
		XkbDDXFakeDeviceButton(xkbi->device, 0, xE[i].u.u.detail);
	    } else if (type == DeviceButtonPress &&
                    ((((deviceKeyButtonPointer*)&xE[i])->state >> 7) & button_mask) == button_mask &&
                    (xkbi->lockedPtrButtons & button_mask) == button_mask) {
		DebugF("[xkb] Faking release of button %d\n", ((deviceKeyButtonPointer*)&xE[i])->state);
		XkbDDXFakeDeviceButton(xkbi->device, 0, ((deviceKeyButtonPointer*)&xE[i])->state);
            }
d997 12
a1009 1
    return True;
d1014 1
a1014 1
XkbInterestPtr	
d1032 1
a1032 1
XkbInterestPtr	
d1044 1
a1044 1
    interest = _XkbTypedAlloc(XkbInterestRec);
d1076 1
a1076 1
    found= False;
d1089 2
a1090 2
	    _XkbFree(interest);
	    found= True;
d1099 2
a1100 2
		_XkbFree(victim);
		found= True;
@


1.3
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d40 1
d822 9
a830 1
    xkbi= pXDev->key->xkbInfo;
d836 3
a838 3
	    DebugF("XKbFilterWriteEvents:\n");
	    DebugF("   Event state= 0x%04x\n",xE[0].u.keyButtonPointer.state);
	    DebugF("   XkbLastRepeatEvent!=xE (0x%p!=0x%p) %s\n",
d841 1
a841 1
	    DebugF("   (xkbClientEventsFlags&XWDA)==0 (0x%x) %s\n",
d844 1
a844 1
	    DebugF("   !IsRelease(%d) %s\n",xE[0].u.u.type,
d852 6
a857 1
	if ((pXDev->grab != NullGrab) && pXDev->fromPassiveGrab &&
d892 2
a893 2
	    DebugF("Faking release of button %d\n", xE[0].u.u.detail);
	    XkbDDXFakePointerButton(ButtonRelease, xE[0].u.u.detail);
d899 3
d908 7
a914 8
		XkbStatePtr s= &xkbi->state;
		DebugF("XKbFilterWriteEvents (non-XKB):\n");
		DebugF("event= 0x%04x\n",xE[i].u.keyButtonPointer.state);
		DebugF("lookup= 0x%02x, grab= 0x%02x\n",s->lookup_mods,
							s->grab_mods);
		DebugF("compat lookup= 0x%02x, grab= 0x%02x\n",
							s->compat_lookup_mods,
							s->compat_grab_mods);
d944 2
a945 2
		DebugF("Faking release of button %d\n", xE[i].u.u.detail);
		XkbDDXFakePointerButton(ButtonRelease, xE[i].u.u.detail);
d949 2
a950 2
		DebugF("Faking release of button %d\n", ((deviceKeyButtonPointer*)&xE[i])->state);
		XkbDDXFakePointerButton(DeviceButtonRelease, ((deviceKeyButtonPointer*)&xE[i])->state);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d112 1
a112 1
    if (!interest)
d171 3
d297 1
a297 1
    if (!interest)
d407 3
a624 1
    xkbi = kbd->key->xkbInfo;
d626 1
a626 1
    if (!interest)
d629 2
d1006 4
@


1.1
log
@Initial revision
@
text
@d37 1
d40 1
a40 1
#include <X11/extensions/XKBsrv.h>
d335 1
a335 1
void
d408 2
a409 1
	(*kbd->kbdfeed->BellProc)(percent,kbd,(pointer)pCtrl,class);
d811 1
a811 1
DeviceIntPtr pXDev = (DeviceIntPtr)LookupKeyboardDevice();
a815 1
#ifdef DEBUG
d817 6
a822 4
		((xE[0].u.u.type==KeyPress)||(xE[0].u.u.type==KeyRelease))) {
	    ErrorF("XKbFilterWriteEvents:\n");
	    ErrorF("   Event state= 0x%04x\n",xE[0].u.keyButtonPointer.state);
	    ErrorF("   XkbLastRepeatEvent!=xE (0x%x!=0x%x) %s\n",
d825 1
a825 1
	    ErrorF("   (xkbClientEventsFlags&XWDA)==0 (0x%x) %s\n",
d828 1
a828 1
	    ErrorF("   !IsRelease(%d) %s\n",xE[0].u.u.type,
a830 1
#endif /* DEBUG */
d837 3
a839 1
	    ((xE[0].u.u.type==KeyPress)||(xE[0].u.u.type==KeyRelease))) {
a866 1
#ifdef DEBUG
d871 1
a871 2
	    ErrorF("Faking release of button %d\n", xE[0].u.u.detail);
#endif
a879 1
#ifdef DEBUG
d881 3
a883 1
		((xE[0].u.u.type==KeyPress)||(xE[0].u.u.type==KeyRelease))) {
d885 3
a887 3
		ErrorF("XKbFilterWriteEvents (non-XKB):\n");
		ErrorF("event= 0x%04x\n",xE[0].u.keyButtonPointer.state);
		ErrorF("lookup= 0x%02x, grab= 0x%02x\n",s->lookup_mods,
d889 1
a889 1
		ErrorF("compat lookup= 0x%02x, grab= 0x%02x\n",
a892 1
#endif
d905 12
a916 3
		xE->u.enterLeave.state&= 0x1F00;
		xE->u.enterLeave.state|= xkbi->state.compat_grab_mods;
	    }
d921 1
a921 3
#ifdef DEBUG
		ErrorF("Faking release of button %d\n", xE[i].u.u.detail);
#endif
d923 6
a928 1
	    }
a985 42
}

int
XkbRemoveClient(DevicePtr inDev,ClientPtr client)
{
XkbSrvInfoPtr	xkbi;
DeviceIntPtr	dev = (DeviceIntPtr)inDev;
XkbInterestPtr	interest;
unsigned long	autoCtrls,autoValues;
Bool		found;

    found= False;
    autoCtrls= autoValues= 0;
    if ( dev->xkb_interest ) {
	interest = dev->xkb_interest;
	if (interest && (interest->client==client)){
	    dev->xkb_interest = interest->next;
	    autoCtrls= interest->autoCtrls;
	    autoValues= interest->autoCtrlValues;
	    _XkbFree(interest);
	    found= True;
	}
	while ((!found)&&(interest->next)) {
	    if (interest->next->client==client) {
		XkbInterestPtr	victim = interest->next;
		interest->next = victim->next;
		autoCtrls= victim->autoCtrls;
		autoValues= victim->autoCtrlValues;
		_XkbFree(victim);
		found= True;
	    }
	    interest = interest->next;
	}
    }
    if (found && autoCtrls && dev->key && dev->key->xkbInfo ) {
	XkbEventCauseRec cause;

	xkbi= dev->key->xkbInfo;
	XkbSetCauseXkbReq(&cause,X_kbPerClientFlags,client);
	XkbEnableDisableControls(xkbi,autoCtrls,autoValues,NULL,&cause);
    }
    return found;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d39 1
a39 1
#include <xkbsrv.h>
d334 1
a334 1
static void
d819 1
a819 1
	    ErrorF("   XkbLastRepeatEvent!=xE (0x%p!=0x%p) %s\n",
d972 42
@


1.1.1.3
log
@xserver 1.4.0.90
@
text
@a36 1
#include <X11/extensions/XIproto.h>
d407 1
a407 2
        if (kbd->kbdfeed->BellProc)
            (*kbd->kbdfeed->BellProc)(percent,kbd,(pointer)pCtrl,class);
d816 1
a816 3
		((xE[0].u.u.type==KeyPress)||(xE[0].u.u.type==KeyRelease)||
                 (xE[0].u.u.type==DeviceKeyPress)||
                 (xE[0].u.u.type == DeviceKeyRelease))) {
d835 1
a835 3
	    ((xE[0].u.u.type==KeyPress)||(xE[0].u.u.type==KeyRelease)||
             (xE[0].u.u.type==DeviceKeyPress)||
             (xE[0].u.u.type == DeviceKeyRelease))) {
d880 1
a880 3
		((xE[i].u.u.type==KeyPress)||(xE[i].u.u.type==KeyRelease)||
                 (xE[i].u.u.type==DeviceKeyPress)||
                 (xE[i].u.u.type == DeviceKeyRelease))) {
d883 1
a883 1
		ErrorF("event= 0x%04x\n",xE[i].u.keyButtonPointer.state);
d903 3
a905 12
		xE[i].u.enterLeave.state&= 0x1F00;
		xE[i].u.enterLeave.state|= xkbi->state.compat_grab_mods;
	    } else if ((type>=DeviceKeyPress)&&(type<=DeviceMotionNotify)) {
                CARD16  old, new;
                deviceKeyButtonPointer *kbp = (deviceKeyButtonPointer*)&xE[i];
                old= kbp->state&(~0x1F00);
                new= kbp->state&0x1F00;
		if (old==XkbStateFieldFromRec(&xkbi->state))
		     new|= xkbi->state.compat_lookup_mods;
		else new|= xkbi->state.compat_grab_mods;
                kbp->state= new;
            }
d914 1
a914 8
	    } else if (type == DeviceButtonPress &&
                    ((((deviceKeyButtonPointer*)&xE[i])->state >> 7) & button_mask) == button_mask &&
                    (xkbi->lockedPtrButtons & button_mask) == button_mask) {
#ifdef DEBUG
		ErrorF("Faking release of button %d\n", ((deviceKeyButtonPointer*)&xE[i])->state);
#endif
		XkbDDXFakePointerButton(DeviceButtonRelease, ((deviceKeyButtonPointer*)&xE[i])->state);
            }
@


