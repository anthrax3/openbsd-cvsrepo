head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.2
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.14
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.12
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.10
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.8
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.6
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.08.09.18.59.55;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	6HLO5qdN5N4nPDjW;

1.9
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2012.06.10.13.21.32;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.11;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.20.21.32.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.19;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.19;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/************************************************************
Copyright (c) 1995 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"

#include <X11/extensions/XI.h>
#include <xkbsrv.h>
#include "xkb.h"

/***====================================================================***/

        /*
         * unsigned
         * XkbIndicatorsToUpdate(dev,changed,check_devs_rtrn)
         *
         * Given a keyboard and a set of state components that have changed,
         * this function returns the indicators on the default keyboard
         * feedback that might be affected.   It also reports whether or not
         * any extension devices might be affected in check_devs_rtrn.
         */

unsigned
XkbIndicatorsToUpdate(DeviceIntPtr dev,
                      unsigned long state_changes, Bool enable_changes)
{
    register unsigned update = 0;
    XkbSrvLedInfoPtr sli;

    sli = XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId, 0);

    if (!sli)
        return update;

    if (state_changes & (XkbModifierStateMask | XkbGroupStateMask))
        update |= sli->usesEffective;
    if (state_changes & (XkbModifierBaseMask | XkbGroupBaseMask))
        update |= sli->usesBase;
    if (state_changes & (XkbModifierLatchMask | XkbGroupLatchMask))
        update |= sli->usesLatched;
    if (state_changes & (XkbModifierLockMask | XkbGroupLockMask))
        update |= sli->usesLocked;
    if (state_changes & XkbCompatStateMask)
        update |= sli->usesCompat;
    if (enable_changes)
        update |= sli->usesControls;
    return update;
}

/***====================================================================***/

        /*
         * Bool
         *XkbApplyLEDChangeToKeyboard(xkbi,map,on,change)
         *
         * Some indicators "drive" the keyboard when their state is explicitly
         * changed, as described in section 9.2.1 of the XKB protocol spec.
         * This function updates the state and controls for the keyboard
         * specified by 'xkbi' to reflect any changes that are required
         * when the indicator described by 'map' is turned on or off.  The
         * extent of the changes is reported in change, which must be defined.
         */
static Bool
XkbApplyLEDChangeToKeyboard(XkbSrvInfoPtr xkbi,
                            XkbIndicatorMapPtr map,
                            Bool on, XkbChangesPtr change)
{
    Bool ctrlChange, stateChange;
    XkbStatePtr state;

    if ((map->flags & XkbIM_NoExplicit) ||
        ((map->flags & XkbIM_LEDDrivesKB) == 0))
        return FALSE;
    ctrlChange = stateChange = FALSE;
    if (map->ctrls) {
        XkbControlsPtr ctrls = xkbi->desc->ctrls;
        unsigned old;

        old = ctrls->enabled_ctrls;
        if (on)
            ctrls->enabled_ctrls |= map->ctrls;
        else
            ctrls->enabled_ctrls &= ~map->ctrls;
        if (old != ctrls->enabled_ctrls) {
            change->ctrls.changed_ctrls = XkbControlsEnabledMask;
            change->ctrls.enabled_ctrls_changes = old ^ ctrls->enabled_ctrls;
            ctrlChange = TRUE;
        }
    }
    state = &xkbi->state;
    if ((map->groups) && ((map->which_groups & (~XkbIM_UseBase)) != 0)) {
        register int i;
        register unsigned bit, match;

        if (on)
            match = (map->groups) & XkbAllGroupsMask;
        else
            match = (~map->groups) & XkbAllGroupsMask;
        if (map->which_groups & (XkbIM_UseLocked | XkbIM_UseEffective)) {
            for (i = 0, bit = 1; i < XkbNumKbdGroups; i++, bit <<= 1) {
                if (bit & match)
                    break;
            }
            if (map->which_groups & XkbIM_UseLatched)
                XkbLatchGroup(xkbi->device, 0); /* unlatch group */
            state->locked_group = i;
            stateChange = TRUE;
        }
        else if (map->which_groups & (XkbIM_UseLatched | XkbIM_UseEffective)) {
            for (i = 0, bit = 1; i < XkbNumKbdGroups; i++, bit <<= 1) {
                if (bit & match)
                    break;
            }
            state->locked_group = 0;
            XkbLatchGroup(xkbi->device, i);
            stateChange = TRUE;
        }
    }
    if ((map->mods.mask) && ((map->which_mods & (~XkbIM_UseBase)) != 0)) {
        if (map->which_mods & (XkbIM_UseLocked | XkbIM_UseEffective)) {
            register unsigned long old;

            old = state->locked_mods;
            if (on)
                state->locked_mods |= map->mods.mask;
            else
                state->locked_mods &= ~map->mods.mask;
            if (state->locked_mods != old)
                stateChange = TRUE;
        }
        if (map->which_mods & (XkbIM_UseLatched | XkbIM_UseEffective)) {
            register unsigned long newmods;

            newmods = state->latched_mods;
            if (on)
                newmods |= map->mods.mask;
            else
                newmods &= ~map->mods.mask;
            if (newmods != state->locked_mods) {
                newmods &= map->mods.mask;
                XkbLatchModifiers(xkbi->device, map->mods.mask, newmods);
                stateChange = TRUE;
            }
        }
    }
    return stateChange || ctrlChange;
}

        /*
         * Bool
         * ComputeAutoState(map,state,ctrls)
         *
         * This function reports the effect of applying the specified
         * indicator map given the specified state and controls, as
         * described in section 9.2 of the XKB protocol specification.
         */

static Bool
ComputeAutoState(XkbIndicatorMapPtr map,
                 XkbStatePtr state, XkbControlsPtr ctrls)
{
    Bool on;
    CARD8 mods, group;

    on = FALSE;
    mods = group = 0;
    if (map->which_mods & XkbIM_UseAnyMods) {
        if (map->which_mods & XkbIM_UseBase)
            mods |= state->base_mods;
        if (map->which_mods & XkbIM_UseLatched)
            mods |= state->latched_mods;
        if (map->which_mods & XkbIM_UseLocked)
            mods |= state->locked_mods;
        if (map->which_mods & XkbIM_UseEffective)
            mods |= state->mods;
        if (map->which_mods & XkbIM_UseCompat)
            mods |= state->compat_state;
        on = ((map->mods.mask & mods) != 0);
        on = on || ((mods == 0) && (map->mods.mask == 0) &&
                    (map->mods.vmods == 0));
    }
    if (map->which_groups & XkbIM_UseAnyGroup) {
        if (map->which_groups & XkbIM_UseBase)
            group |= (1L << state->base_group);
        if (map->which_groups & XkbIM_UseLatched)
            group |= (1L << state->latched_group);
        if (map->which_groups & XkbIM_UseLocked)
            group |= (1L << state->locked_group);
        if (map->which_groups & XkbIM_UseEffective)
            group |= (1L << state->group);
        on = on || (((map->groups & group) != 0) || (map->groups == 0));
    }
    if (map->ctrls)
        on = on || (ctrls->enabled_ctrls & map->ctrls);
    return on;
}

static void
XkbUpdateLedAutoState(DeviceIntPtr dev,
                      XkbSrvLedInfoPtr sli,
                      unsigned maps_to_check,
                      xkbExtensionDeviceNotify * ed,
                      XkbChangesPtr changes, XkbEventCausePtr cause)
{
    DeviceIntPtr kbd;
    XkbStatePtr state;
    XkbControlsPtr ctrls;
    XkbChangesRec my_changes;
    xkbExtensionDeviceNotify my_ed;
    register unsigned i, bit, affected;
    register XkbIndicatorMapPtr map;
    unsigned oldState;

    if ((maps_to_check == 0) || (sli->maps == NULL) || (sli->mapsPresent == 0))
        return;

    if (dev->key && dev->key->xkbInfo)
        kbd = dev;
    else
        kbd = inputInfo.keyboard;

    state = &kbd->key->xkbInfo->state;
    ctrls = kbd->key->xkbInfo->desc->ctrls;
    affected = maps_to_check;
    oldState = sli->effectiveState;
    sli->autoState &= ~affected;
    for (i = 0, bit = 1; (i < XkbNumIndicators) && (affected); i++, bit <<= 1) {
        if ((affected & bit) == 0)
            continue;
        affected &= ~bit;
        map = &sli->maps[i];
        if ((!(map->flags & XkbIM_NoAutomatic)) &&
            ComputeAutoState(map, state, ctrls))
            sli->autoState |= bit;
    }
    sli->effectiveState = (sli->autoState | sli->explicitState);
    affected = sli->effectiveState ^ oldState;
    if (affected == 0)
        return;

    if (ed == NULL) {
        ed = &my_ed;
        memset((char *) ed, 0, sizeof(xkbExtensionDeviceNotify));
    }
    else if ((ed->reason & XkbXI_IndicatorsMask) &&
             ((ed->ledClass != sli->class) || (ed->ledID != sli->id))) {
        XkbFlushLedEvents(dev, kbd, sli, ed, changes, cause);
    }

    if ((kbd == dev) && (sli->flags & XkbSLI_IsDefault)) {
        if (changes == NULL) {
            changes = &my_changes;
            memset((char *) changes, 0, sizeof(XkbChangesRec));
        }
        changes->indicators.state_changes |= affected;
    }

    ed->reason |= XkbXI_IndicatorStateMask;
    ed->ledClass = sli->class;
    ed->ledID = sli->id;
    ed->ledsDefined = sli->namesPresent | sli->mapsPresent;
    ed->ledState = sli->effectiveState;
    ed->unsupported = 0;
    ed->supported = XkbXI_AllFeaturesMask;

    if (changes != &my_changes)
        changes = NULL;
    if (ed != &my_ed)
        ed = NULL;
    if (changes || ed)
        XkbFlushLedEvents(dev, kbd, sli, ed, changes, cause);
    return;
}

void
XkbUpdateAllDeviceIndicators(XkbChangesPtr changes, XkbEventCausePtr cause)
{
    DeviceIntPtr edev;
    XkbSrvLedInfoPtr sli;

    for (edev = inputInfo.devices; edev != NULL; edev = edev->next) {
        if (edev->kbdfeed) {
            KbdFeedbackPtr kf;

            for (kf = edev->kbdfeed; kf != NULL; kf = kf->next) {
                if ((kf->xkb_sli == NULL) || (kf->xkb_sli->maps == NULL))
                    continue;
                sli = kf->xkb_sli;
                XkbUpdateLedAutoState(edev, sli, sli->mapsPresent, NULL,
                                      changes, cause);

            }
        }
        if (edev->leds) {
            LedFeedbackPtr lf;

            for (lf = edev->leds; lf != NULL; lf = lf->next) {
                if ((lf->xkb_sli == NULL) || (lf->xkb_sli->maps == NULL))
                    continue;
                sli = lf->xkb_sli;
                XkbUpdateLedAutoState(edev, sli, sli->mapsPresent, NULL,
                                      changes, cause);

            }
        }
    }
    return;
}

/***====================================================================***/

        /*
         * void
         * XkbSetIndicators(dev,affect,values,cause)
         *
         * Attempts to change the indicators specified in 'affect' to the
         * states specified in 'values' for the default keyboard feedback
         * on the keyboard specified by 'dev.'   Attempts to change indicator
         * state might be ignored or have no affect, depending on the XKB
         * indicator map for any affected indicators, as described in section
         * 9.2 of the XKB protocol specification.
         *
         * If 'changes' is non-NULL, this function notes any changes to the
         * keyboard state, controls, or indicator state that result from this
         * attempted change.   If 'changes' is NULL, this function generates
         * XKB events to report any such changes to interested clients.
         *
         * If 'cause' is non-NULL, it specifies the reason for the change,
         * as reported in some XKB events.   If it is NULL, this function
         * assumes that the change is the result of a core protocol
         * ChangeKeyboardMapping request.
         */

void
XkbSetIndicators(DeviceIntPtr dev,
                 CARD32 affect, CARD32 values, XkbEventCausePtr cause)
{
    XkbSrvLedInfoPtr sli;
    XkbChangesRec changes;
    xkbExtensionDeviceNotify ed;
    unsigned side_affected;

    memset((char *) &changes, 0, sizeof(XkbChangesRec));
    memset((char *) &ed, 0, sizeof(xkbExtensionDeviceNotify));
    sli = XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId, 0);
    sli->explicitState &= ~affect;
    sli->explicitState |= (affect & values);
    XkbApplyLedStateChanges(dev, sli, affect, &ed, &changes, cause);

    side_affected = 0;
    if (changes.state_changes != 0)
        side_affected |=
            XkbIndicatorsToUpdate(dev, changes.state_changes, FALSE);
    if (changes.ctrls.enabled_ctrls_changes)
        side_affected |= sli->usesControls;

    if (side_affected) {
        XkbUpdateLedAutoState(dev, sli, side_affected, &ed, &changes, cause);
        affect |= side_affected;
    }
    if (changes.state_changes || changes.ctrls.enabled_ctrls_changes)
        XkbUpdateAllDeviceIndicators(NULL, cause);

    XkbFlushLedEvents(dev, dev, sli, &ed, &changes, cause);
    return;
}

/***====================================================================***/

/***====================================================================***/

        /*
         * void
         * XkbUpdateIndicators(dev,update,check_edevs,changes,cause)
         *
         * Applies the indicator maps for any indicators specified in
         * 'update' from the default keyboard feedback on the device
         * specified by 'dev.'
         *
         * If 'changes' is NULL, this function generates and XKB events
         * required to report the necessary changes, otherwise it simply
         * notes the indicators with changed state.
         *
         * If 'check_edevs' is TRUE, this function also checks the indicator
         * maps for any open extension devices that have them, and updates
         * the state of any extension device indicators as necessary.
         */

void
XkbUpdateIndicators(DeviceIntPtr dev,
                    register CARD32 update,
                    Bool check_edevs,
                    XkbChangesPtr changes, XkbEventCausePtr cause)
{
    XkbSrvLedInfoPtr sli;

    sli = XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId, 0);
    XkbUpdateLedAutoState(dev, sli, update, NULL, changes, cause);
    if (check_edevs)
        XkbUpdateAllDeviceIndicators(changes, cause);
    return;
}

/***====================================================================***/

/***====================================================================***/

        /*
         * void
         * XkbCheckIndicatorMaps(dev,sli,which)
         *
         * Updates the 'indicator accelerators' for the indicators specified
         * by 'which' in the feedback specified by 'sli.' The indicator
         * accelerators are internal to the server and are used to simplify
         * and speed up the process of figuring out which indicators might
         * be affected by a particular change in keyboard state or controls.
         */

void
XkbCheckIndicatorMaps(DeviceIntPtr dev, XkbSrvLedInfoPtr sli, unsigned which)
{
    register unsigned i, bit;
    XkbIndicatorMapPtr map;
    XkbDescPtr xkb;

    if ((sli->flags & XkbSLI_HasOwnState) == 0)
        return;

    sli->usesBase &= ~which;
    sli->usesLatched &= ~which;
    sli->usesLocked &= ~which;
    sli->usesEffective &= ~which;
    sli->usesCompat &= ~which;
    sli->usesControls &= ~which;
    sli->mapsPresent &= ~which;

    xkb = dev->key->xkbInfo->desc;
    for (i = 0, bit = 1, map = sli->maps; i < XkbNumIndicators;
         i++, bit <<= 1, map++) {
        if (which & bit) {
            CARD8 what;

            if (!map || !XkbIM_InUse(map))
                continue;
            sli->mapsPresent |= bit;

            what = (map->which_mods | map->which_groups);
            if (what & XkbIM_UseBase)
                sli->usesBase |= bit;
            if (what & XkbIM_UseLatched)
                sli->usesLatched |= bit;
            if (what & XkbIM_UseLocked)
                sli->usesLocked |= bit;
            if (what & XkbIM_UseEffective)
                sli->usesEffective |= bit;
            if (what & XkbIM_UseCompat)
                sli->usesCompat |= bit;
            if (map->ctrls)
                sli->usesControls |= bit;

            map->mods.mask = map->mods.real_mods;
            if (map->mods.vmods != 0) {
                map->mods.mask |= XkbMaskForVMask(xkb, map->mods.vmods);
            }
        }
    }
    sli->usedComponents = 0;
    if (sli->usesBase)
        sli->usedComponents |= XkbModifierBaseMask | XkbGroupBaseMask;
    if (sli->usesLatched)
        sli->usedComponents |= XkbModifierLatchMask | XkbGroupLatchMask;
    if (sli->usesLocked)
        sli->usedComponents |= XkbModifierLockMask | XkbGroupLockMask;
    if (sli->usesEffective)
        sli->usedComponents |= XkbModifierStateMask | XkbGroupStateMask;
    if (sli->usesCompat)
        sli->usedComponents |= XkbCompatStateMask;
    return;
}

/***====================================================================***/

        /*
         * XkbSrvLedInfoPtr
         * XkbAllocSrvLedInfo(dev,kf,lf,needed_parts)
         *
         * Allocates an XkbSrvLedInfoPtr for the feedback specified by either
         * 'kf' or 'lf' on the keyboard specified by 'dev.'
         *
         * If 'needed_parts' is non-zero, this function makes sure that any
         * of the parts speicified therein are allocated.
         */
XkbSrvLedInfoPtr
XkbAllocSrvLedInfo(DeviceIntPtr dev,
                   KbdFeedbackPtr kf, LedFeedbackPtr lf, unsigned needed_parts)
{
    XkbSrvLedInfoPtr sli;
    Bool checkAccel;
    Bool checkNames;

    sli = NULL;
    checkAccel = checkNames = FALSE;
    if ((kf != NULL) && (kf->xkb_sli == NULL)) {
        kf->xkb_sli = sli = calloc(1, sizeof(XkbSrvLedInfoRec));
        if (sli == NULL)
            return NULL;        /* ALLOCATION ERROR */
        if (dev->key && dev->key->xkbInfo)
            sli->flags = XkbSLI_HasOwnState;
        else
            sli->flags = 0;
        sli->class = KbdFeedbackClass;
        sli->id = kf->ctrl.id;
        sli->fb.kf = kf;

        sli->autoState = 0;
        sli->explicitState = kf->ctrl.leds;
        sli->effectiveState = kf->ctrl.leds;

        if ((kf == dev->kbdfeed) && (dev->key) && (dev->key->xkbInfo)) {
            XkbDescPtr xkb;

            xkb = dev->key->xkbInfo->desc;
            sli->flags |= XkbSLI_IsDefault;
            sli->physIndicators = xkb->indicators->phys_indicators;
            sli->names = xkb->names->indicators;
            sli->maps = xkb->indicators->maps;
            checkNames = checkAccel = TRUE;
        }
        else {
            sli->physIndicators = XkbAllIndicatorsMask;
            sli->names = NULL;
            sli->maps = NULL;
        }
    }
    else if ((kf != NULL) && ((kf->xkb_sli->flags & XkbSLI_IsDefault) != 0)) {
        XkbDescPtr xkb;

        xkb = dev->key->xkbInfo->desc;
        sli = kf->xkb_sli;
        sli->physIndicators = xkb->indicators->phys_indicators;
        if (xkb->names->indicators != sli->names) {
            checkNames = TRUE;
            sli->names = xkb->names->indicators;
        }
        if (xkb->indicators->maps != sli->maps) {
            checkAccel = TRUE;
            sli->maps = xkb->indicators->maps;
        }
    }
    else if ((lf != NULL) && (lf->xkb_sli == NULL)) {
        lf->xkb_sli = sli = calloc(1, sizeof(XkbSrvLedInfoRec));
        if (sli == NULL)
            return NULL;        /* ALLOCATION ERROR */
        if (dev->key && dev->key->xkbInfo)
            sli->flags = XkbSLI_HasOwnState;
        else
            sli->flags = 0;
        sli->class = LedFeedbackClass;
        sli->id = lf->ctrl.id;
        sli->fb.lf = lf;

        sli->physIndicators = lf->ctrl.led_mask;
        sli->autoState = 0;
        sli->explicitState = lf->ctrl.led_values;
        sli->effectiveState = lf->ctrl.led_values;
        sli->maps = NULL;
        sli->names = NULL;
    }
    else
        return NULL;
    if ((sli->names == NULL) && (needed_parts & XkbXI_IndicatorNamesMask))
        sli->names = calloc(XkbNumIndicators, sizeof(Atom));
    if ((sli->maps == NULL) && (needed_parts & XkbXI_IndicatorMapsMask))
        sli->maps = calloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
    if (checkNames) {
        register unsigned i, bit;

        sli->namesPresent = 0;
        for (i = 0, bit = 1; i < XkbNumIndicators; i++, bit <<= 1) {
            if (sli->names[i] != None)
                sli->namesPresent |= bit;
        }
    }
    if (checkAccel)
        XkbCheckIndicatorMaps(dev, sli, XkbAllIndicatorsMask);
    return sli;
}

void
XkbFreeSrvLedInfo(XkbSrvLedInfoPtr sli)
{
    if ((sli->flags & XkbSLI_IsDefault) == 0) {
        free(sli->maps);
        free(sli->names);
    }
    sli->maps = NULL;
    sli->names = NULL;
    free(sli);
    return;
}

/*
 * XkbSrvLedInfoPtr
 * XkbCopySrvLedInfo(dev,src,kf,lf)
 *
 * Takes the given XkbSrvLedInfoPtr and duplicates it. A deep copy is made,
 * thus the new copy behaves like the original one and can be freed with
 * XkbFreeSrvLedInfo.
 */
XkbSrvLedInfoPtr
XkbCopySrvLedInfo(DeviceIntPtr from,
                  XkbSrvLedInfoPtr src, KbdFeedbackPtr kf, LedFeedbackPtr lf)
{
    XkbSrvLedInfoPtr sli_new = NULL;

    if (!src)
        goto finish;

    sli_new = calloc(1, sizeof(XkbSrvLedInfoRec));
    if (!sli_new)
        goto finish;

    memcpy(sli_new, src, sizeof(XkbSrvLedInfoRec));
    if (sli_new->class == KbdFeedbackClass)
        sli_new->fb.kf = kf;
    else
        sli_new->fb.lf = lf;

    if (!(sli_new->flags & XkbSLI_IsDefault)) {
        sli_new->names = calloc(XkbNumIndicators, sizeof(Atom));
        sli_new->maps = calloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
    }                           /* else sli_new->names/maps is pointing to
                                   dev->key->xkbInfo->desc->names->indicators;
                                   dev->key->xkbInfo->desc->names->indicators; */

 finish:
    return sli_new;
}

/***====================================================================***/

        /*
         * XkbSrvLedInfoPtr
         * XkbFindSrvLedInfo(dev,class,id,needed_parts)
         *
         * Finds the XkbSrvLedInfoPtr for the specified 'class' and 'id'
         * on the device specified by 'dev.'   If the class and id specify
         * a valid device feedback, this function returns the existing
         * feedback or allocates a new one.
         *
         */

XkbSrvLedInfoPtr
XkbFindSrvLedInfo(DeviceIntPtr dev,
                  unsigned class, unsigned id, unsigned needed_parts)
{
    XkbSrvLedInfoPtr sli;

    /* optimization to check for most common case */
    if (((class == XkbDfltXIClass) && (id == XkbDfltXIId)) && (dev->kbdfeed)) {
        if (dev->kbdfeed->xkb_sli == NULL) {
            dev->kbdfeed->xkb_sli =
                XkbAllocSrvLedInfo(dev, dev->kbdfeed, NULL, needed_parts);
        }
        return dev->kbdfeed->xkb_sli;
    }

    sli = NULL;
    if (class == XkbDfltXIClass) {
        if (dev->kbdfeed)
            class = KbdFeedbackClass;
        else if (dev->leds)
            class = LedFeedbackClass;
        else
            return NULL;
    }
    if (class == KbdFeedbackClass) {
        KbdFeedbackPtr kf;

        for (kf = dev->kbdfeed; kf != NULL; kf = kf->next) {
            if ((id == XkbDfltXIId) || (id == kf->ctrl.id)) {
                if (kf->xkb_sli == NULL)
                    kf->xkb_sli =
                        XkbAllocSrvLedInfo(dev, kf, NULL, needed_parts);
                sli = kf->xkb_sli;
                break;
            }
        }
    }
    else if (class == LedFeedbackClass) {
        LedFeedbackPtr lf;

        for (lf = dev->leds; lf != NULL; lf = lf->next) {
            if ((id == XkbDfltXIId) || (id == lf->ctrl.id)) {
                if (lf->xkb_sli == NULL)
                    lf->xkb_sli =
                        XkbAllocSrvLedInfo(dev, NULL, lf, needed_parts);
                sli = lf->xkb_sli;
                break;
            }
        }
    }
    if (sli) {
        if ((sli->names == NULL) && (needed_parts & XkbXI_IndicatorNamesMask))
            sli->names = calloc(XkbNumIndicators, sizeof(Atom));
        if ((sli->maps == NULL) && (needed_parts & XkbXI_IndicatorMapsMask))
            sli->maps = calloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
    }
    return sli;
}

/***====================================================================***/

void
XkbFlushLedEvents(DeviceIntPtr dev,
                  DeviceIntPtr kbd,
                  XkbSrvLedInfoPtr sli,
                  xkbExtensionDeviceNotify * ed,
                  XkbChangesPtr changes, XkbEventCausePtr cause)
{
    if (changes) {
        if (changes->indicators.state_changes)
            XkbDDXUpdateDeviceIndicators(dev, sli, sli->effectiveState);
        XkbSendNotification(kbd, changes, cause);
        memset((char *) changes, 0, sizeof(XkbChangesRec));

        if (XkbAX_NeedFeedback
            (kbd->key->xkbInfo->desc->ctrls, XkbAX_IndicatorFBMask)) {
            if (sli->effectiveState)
                /* it appears that the which parameter is not used */
                XkbDDXAccessXBeep(dev, _BEEP_LED_ON, XkbAccessXFeedbackMask);
            else
                XkbDDXAccessXBeep(dev, _BEEP_LED_OFF, XkbAccessXFeedbackMask);
        }
    }
    if (ed) {
        if (ed->reason) {
            if ((dev != kbd) && (ed->reason & XkbXI_IndicatorStateMask))
                XkbDDXUpdateDeviceIndicators(dev, sli, sli->effectiveState);
            XkbSendExtensionDeviceNotify(dev, cause->client, ed);
        }
        memset((char *) ed, 0, sizeof(XkbExtensionDeviceNotify));
    }
    return;
}

/***====================================================================***/

void
XkbApplyLedNameChanges(DeviceIntPtr dev,
                       XkbSrvLedInfoPtr sli,
                       unsigned changed_names,
                       xkbExtensionDeviceNotify * ed,
                       XkbChangesPtr changes, XkbEventCausePtr cause)
{
    DeviceIntPtr kbd;
    XkbChangesRec my_changes;
    xkbExtensionDeviceNotify my_ed;

    if (changed_names == 0)
        return;
    if (dev->key && dev->key->xkbInfo)
        kbd = dev;
    else
        kbd = inputInfo.keyboard;

    if (ed == NULL) {
        ed = &my_ed;
        memset((char *) ed, 0, sizeof(xkbExtensionDeviceNotify));
    }
    else if ((ed->reason & XkbXI_IndicatorsMask) &&
             ((ed->ledClass != sli->class) || (ed->ledID != sli->id))) {
        XkbFlushLedEvents(dev, kbd, sli, ed, changes, cause);
    }

    if ((kbd == dev) && (sli->flags & XkbSLI_IsDefault)) {
        if (changes == NULL) {
            changes = &my_changes;
            memset((char *) changes, 0, sizeof(XkbChangesRec));
        }
        changes->names.changed |= XkbIndicatorNamesMask;
        changes->names.changed_indicators |= changed_names;
    }

    ed->reason |= XkbXI_IndicatorNamesMask;
    ed->ledClass = sli->class;
    ed->ledID = sli->id;
    ed->ledsDefined = sli->namesPresent | sli->mapsPresent;
    ed->ledState = sli->effectiveState;
    ed->unsupported = 0;
    ed->supported = XkbXI_AllFeaturesMask;

    if (changes != &my_changes)
        changes = NULL;
    if (ed != &my_ed)
        ed = NULL;
    if (changes || ed)
        XkbFlushLedEvents(dev, kbd, sli, ed, changes, cause);
    return;
}

/***====================================================================***/

        /*
         * void
         * XkbApplyLedMapChanges(dev,sli,changed_maps,changes,cause)
         *
         * Handles all of the secondary effects of the changes to the
         * feedback specified by 'sli' on the device specified by 'dev.'
         *
         * If 'changed_maps' specifies any indicators, this function generates
         * XkbExtensionDeviceNotify events and possibly IndicatorMapNotify
         * events to report the changes, and recalculates the effective
         * state of each indicator with a changed map.  If any indicators
         * change state, the server generates XkbExtensionDeviceNotify and
         * XkbIndicatorStateNotify events as appropriate.
         *
         * If 'changes' is non-NULL, this function updates it to reflect
         * any changes to the keyboard state or controls or to the 'core'
         * indicator names, maps, or state.   If 'changes' is NULL, this
         * function generates XKB events as needed to report the changes.
         * If 'dev' is not a keyboard device, any changes are reported
         * for the core keyboard.
         *
         * The 'cause' specifies the reason for the event (key event or
         * request) for the change, as reported in some XKB events.
         */

void
XkbApplyLedMapChanges(DeviceIntPtr dev,
                      XkbSrvLedInfoPtr sli,
                      unsigned changed_maps,
                      xkbExtensionDeviceNotify * ed,
                      XkbChangesPtr changes, XkbEventCausePtr cause)
{
    DeviceIntPtr kbd;
    XkbChangesRec my_changes;
    xkbExtensionDeviceNotify my_ed;

    if (changed_maps == 0)
        return;
    if (dev->key && dev->key->xkbInfo)
        kbd = dev;
    else
        kbd = inputInfo.keyboard;

    if (ed == NULL) {
        ed = &my_ed;
        memset((char *) ed, 0, sizeof(xkbExtensionDeviceNotify));
    }
    else if ((ed->reason & XkbXI_IndicatorsMask) &&
             ((ed->ledClass != sli->class) || (ed->ledID != sli->id))) {
        XkbFlushLedEvents(dev, kbd, sli, ed, changes, cause);
    }

    if ((kbd == dev) && (sli->flags & XkbSLI_IsDefault)) {
        if (changes == NULL) {
            changes = &my_changes;
            memset((char *) changes, 0, sizeof(XkbChangesRec));
        }
        changes->indicators.map_changes |= changed_maps;
    }

    XkbCheckIndicatorMaps(dev, sli, changed_maps);

    ed->reason |= XkbXI_IndicatorMapsMask;
    ed->ledClass = sli->class;
    ed->ledID = sli->id;
    ed->ledsDefined = sli->namesPresent | sli->mapsPresent;
    ed->ledState = sli->effectiveState;
    ed->unsupported = 0;
    ed->supported = XkbXI_AllFeaturesMask;

    XkbUpdateLedAutoState(dev, sli, changed_maps, ed, changes, cause);

    if (changes != &my_changes)
        changes = NULL;
    if (ed != &my_ed)
        ed = NULL;
    if (changes || ed)
        XkbFlushLedEvents(dev, kbd, sli, ed, changes, cause);
    return;
}

/***====================================================================***/

void
XkbApplyLedStateChanges(DeviceIntPtr dev,
                        XkbSrvLedInfoPtr sli,
                        unsigned changed_leds,
                        xkbExtensionDeviceNotify * ed,
                        XkbChangesPtr changes, XkbEventCausePtr cause)
{
    XkbSrvInfoPtr xkbi;
    DeviceIntPtr kbd;
    XkbChangesRec my_changes;
    xkbExtensionDeviceNotify my_ed;
    register unsigned i, bit, affected;
    XkbIndicatorMapPtr map;
    unsigned oldState;
    Bool kb_changed;

    if (changed_leds == 0)
        return;
    if (dev->key && dev->key->xkbInfo)
        kbd = dev;
    else
        kbd = inputInfo.keyboard;
    xkbi = kbd->key->xkbInfo;

    if (changes == NULL) {
        changes = &my_changes;
        memset((char *) changes, 0, sizeof(XkbChangesRec));
    }

    kb_changed = FALSE;
    affected = changed_leds;
    oldState = sli->effectiveState;
    for (i = 0, bit = 1; (i < XkbNumIndicators) && (affected); i++, bit <<= 1) {
        if ((affected & bit) == 0)
            continue;
        affected &= ~bit;
        map = &sli->maps[i];
        if (map->flags & XkbIM_NoExplicit) {
            sli->explicitState &= ~bit;
            continue;
        }
        if (map->flags & XkbIM_LEDDrivesKB) {
            Bool on = ((sli->explicitState & bit) != 0);

            if (XkbApplyLEDChangeToKeyboard(xkbi, map, on, changes))
                kb_changed = TRUE;
        }
    }
    sli->effectiveState = (sli->autoState | sli->explicitState);
    affected = sli->effectiveState ^ oldState;

    if (ed == NULL) {
        ed = &my_ed;
        memset((char *) ed, 0, sizeof(xkbExtensionDeviceNotify));
    }
    else if (affected && (ed->reason & XkbXI_IndicatorsMask) &&
             ((ed->ledClass != sli->class) || (ed->ledID != sli->id))) {
        XkbFlushLedEvents(dev, kbd, sli, ed, changes, cause);
    }

    if ((kbd == dev) && (sli->flags & XkbSLI_IsDefault))
        changes->indicators.state_changes |= affected;
    if (affected) {
        ed->reason |= XkbXI_IndicatorStateMask;
        ed->ledClass = sli->class;
        ed->ledID = sli->id;
        ed->ledsDefined = sli->namesPresent | sli->mapsPresent;
        ed->ledState = sli->effectiveState;
        ed->unsupported = 0;
        ed->supported = XkbXI_AllFeaturesMask;
    }

    if (kb_changed) {
        XkbComputeDerivedState(kbd->key->xkbInfo);
        XkbUpdateLedAutoState(dev, sli, sli->mapsPresent, ed, changes, cause);
    }

    if (changes != &my_changes)
        changes = NULL;
    if (ed != &my_ed)
        ed = NULL;
    if (changes || ed)
        XkbFlushLedEvents(dev, kbd, sli, ed, changes, cause);
    if (kb_changed)
        XkbUpdateAllDeviceIndicators(NULL, cause);
    return;
}
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d307 1
a307 1
static void
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d9 2
a10 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d12 1
a12 1
Silicon Graphics makes no representation about the suitability 
d16 2
a17 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d19 3
a21 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
d50 2
a51 2
         * this function returns the indicators on the default keyboard 
         * feedback that might be affected.   It also reports whether or not 
d88 1
a88 1
         * Some indicators "drive" the keyboard when their state is explicitly 
d90 2
a91 2
         * This function updates the state and controls for the keyboard 
         * specified by 'xkbi' to reflect any changes that are required 
d360 3
a362 3
         * If 'cause' is non-NULL, it specifies the reason for the change, 
         * as reported in some XKB events.   If it is NULL, this function 
         * assumes that the change is the result of a core protocol 
d410 1
a410 1
         * specified by 'dev.' 
d445 3
a447 3
         * by 'which' in the feedback specified by 'sli.' The indicator 
         * accelerators are internal to the server and are used to simplify 
         * and speed up the process of figuring out which indicators might 
d680 1
a680 1
         * a valid device feedback, this function returns the existing 
d842 1
a842 1
         * 
@


1.7
log
@Update to xserver 1.11.2
@
text
@d45 9
a53 9
	/*
	 * unsigned
	 * XkbIndicatorsToUpdate(dev,changed,check_devs_rtrn)
	 *
	 * Given a keyboard and a set of state components that have changed,
	 * this function returns the indicators on the default keyboard 
	 * feedback that might be affected.   It also reports whether or not 
	 * any extension devices might be affected in check_devs_rtrn.
	 */
d56 2
a57 3
XkbIndicatorsToUpdate(	DeviceIntPtr	dev,
			unsigned long 	state_changes,
			Bool		enable_changes)
d59 2
a60 2
register unsigned	update=	0;
XkbSrvLedInfoPtr	sli;
d62 1
a62 1
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
d67 10
a76 10
    if (state_changes&(XkbModifierStateMask|XkbGroupStateMask))
	update|= sli->usesEffective;
    if (state_changes&(XkbModifierBaseMask|XkbGroupBaseMask))
	update|= sli->usesBase;
    if (state_changes&(XkbModifierLatchMask|XkbGroupLatchMask))
	update|= sli->usesLatched;
    if (state_changes&(XkbModifierLockMask|XkbGroupLockMask))
	update|= sli->usesLocked;
    if (state_changes&XkbCompatStateMask)
	update|= sli->usesCompat;
d78 1
a78 1
	update|= sli->usesControls;
d84 11
a94 11
	/*
	 * Bool
	 *XkbApplyLEDChangeToKeyboard(xkbi,map,on,change)
	 *
	 * Some indicators "drive" the keyboard when their state is explicitly 
	 * changed, as described in section 9.2.1 of the XKB protocol spec.
	 * This function updates the state and controls for the keyboard 
	 * specified by 'xkbi' to reflect any changes that are required 
	 * when the indicator described by 'map' is turned on or off.  The
	 * extent of the changes is reported in change, which must be defined.
	 */
d96 11
a106 11
XkbApplyLEDChangeToKeyboard(	XkbSrvInfoPtr		xkbi,
				XkbIndicatorMapPtr	map,
				Bool			on,
				XkbChangesPtr		change)
{
Bool		ctrlChange,stateChange;
XkbStatePtr	state;

    if ((map->flags&XkbIM_NoExplicit)||((map->flags&XkbIM_LEDDrivesKB)==0))
	return FALSE;
    ctrlChange= stateChange= FALSE;
d108 2
a109 2
	XkbControlsPtr	ctrls= xkbi->desc->ctrls;
	unsigned 	old;
d111 66
a176 56
	old= ctrls->enabled_ctrls;
	if (on)	ctrls->enabled_ctrls|= map->ctrls;
	else	ctrls->enabled_ctrls&= ~map->ctrls;
	if (old!=ctrls->enabled_ctrls) {
	    change->ctrls.changed_ctrls= XkbControlsEnabledMask;
	    change->ctrls.enabled_ctrls_changes= old^ctrls->enabled_ctrls;
	    ctrlChange= TRUE;
	}
    }
    state= &xkbi->state;
    if ((map->groups)&&((map->which_groups&(~XkbIM_UseBase))!=0)) {
	register int i;
	register unsigned bit,match;

	if (on)	match= (map->groups)&XkbAllGroupsMask;
	else 	match= (~map->groups)&XkbAllGroupsMask;
	if (map->which_groups&(XkbIM_UseLocked|XkbIM_UseEffective)) {
	    for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
		if (bit&match)
		    break;
	    }
	    if (map->which_groups&XkbIM_UseLatched)
		XkbLatchGroup(xkbi->device,0); /* unlatch group */
	    state->locked_group= i;
	    stateChange= TRUE;
	}
	else if (map->which_groups&(XkbIM_UseLatched|XkbIM_UseEffective)) {
	    for (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {
		if (bit&match)
		    break;
	    }
	    state->locked_group= 0;
	    XkbLatchGroup(xkbi->device,i);
	    stateChange= TRUE;
	}
    }
    if ((map->mods.mask)&&((map->which_mods&(~XkbIM_UseBase))!=0)) {
	if (map->which_mods&(XkbIM_UseLocked|XkbIM_UseEffective)) {
	    register unsigned long old;
	    old= state->locked_mods;
	    if (on)	state->locked_mods|= map->mods.mask;
	    else	state->locked_mods&= ~map->mods.mask;
	    if (state->locked_mods!=old)
		stateChange= TRUE;
	}
	if (map->which_mods&(XkbIM_UseLatched|XkbIM_UseEffective)) {
	    register unsigned long newmods;
	    newmods= state->latched_mods;
	    if (on)	newmods|=  map->mods.mask;
	    else	newmods&= ~map->mods.mask;
	    if (newmods!=state->locked_mods) {
		newmods&= map->mods.mask;
		XkbLatchModifiers(xkbi->device,map->mods.mask,newmods);
		stateChange= TRUE;
	    }
	}
d180 9
a188 9
	
	/*
	 * Bool
	 * ComputeAutoState(map,state,ctrls)
	 *
	 * This function reports the effect of applying the specified
	 * indicator map given the specified state and controls, as
	 * described in section 9.2 of the XKB protocol specification.
	 */
d191 33
a223 33
ComputeAutoState(	XkbIndicatorMapPtr	map,
			XkbStatePtr 		state,
			XkbControlsPtr 		ctrls)
{
Bool 			on;
CARD8 			mods,group;

    on= FALSE;
    mods= group= 0;
    if (map->which_mods&XkbIM_UseAnyMods) {
	if (map->which_mods&XkbIM_UseBase)
	    mods|= state->base_mods;
	if (map->which_mods&XkbIM_UseLatched)
	    mods|= state->latched_mods;
	if (map->which_mods&XkbIM_UseLocked)
	    mods|= state->locked_mods;
	if (map->which_mods&XkbIM_UseEffective)
	    mods|= state->mods;
	if (map->which_mods&XkbIM_UseCompat)
	    mods|= state->compat_state;
	on = ((map->mods.mask&mods)!=0);
	on = on||((mods==0)&&(map->mods.mask==0)&&(map->mods.vmods==0));
    }
    if (map->which_groups&XkbIM_UseAnyGroup) {
	if (map->which_groups&XkbIM_UseBase)
	    group|= (1L << state->base_group);
	if (map->which_groups&XkbIM_UseLatched)
	    group|= (1L << state->latched_group);
	if (map->which_groups&XkbIM_UseLocked)
	    group|= (1L << state->locked_group);
	if (map->which_groups&XkbIM_UseEffective)
	    group|= (1L << state->group);
	on = on||(((map->groups&group)!=0)||(map->groups==0));
d226 1
a226 1
	on = on||(ctrls->enabled_ctrls&map->ctrls);
a229 1

d231 14
a244 15
XkbUpdateLedAutoState(	DeviceIntPtr			dev,
			XkbSrvLedInfoPtr		sli,
			unsigned			maps_to_check,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
DeviceIntPtr			kbd;
XkbStatePtr			state;
XkbControlsPtr			ctrls;
XkbChangesRec			my_changes;
xkbExtensionDeviceNotify	my_ed;
register unsigned		i,bit,affected;
register XkbIndicatorMapPtr	map;
unsigned			oldState;
d246 2
a247 2
    if ((maps_to_check==0)||(sli->maps==NULL)||(sli->mapsPresent==0))
	return;
d250 3
a252 2
	 kbd= dev;
    else kbd= inputInfo.keyboard;
d254 18
a271 42
    state= &kbd->key->xkbInfo->state;
    ctrls= kbd->key->xkbInfo->desc->ctrls;
    affected= maps_to_check;
    oldState= sli->effectiveState;
    sli->autoState&= ~affected;
    for (i=0,bit=1;(i<XkbNumIndicators)&&(affected);i++,bit<<=1) {
	if ((affected&bit)==0)
	    continue;
	affected&= ~bit;
	map= &sli->maps[i];
	if((!(map->flags&XkbIM_NoAutomatic))&&ComputeAutoState(map,state,ctrls))
	    sli->autoState|= bit;
    }
    sli->effectiveState= (sli->autoState|sli->explicitState);
    affected= sli->effectiveState^oldState;
    if (affected==0)
	return;

    if (ed==NULL) {
	ed= &my_ed;
	memset((char *)ed, 0, sizeof(xkbExtensionDeviceNotify));
    }
    else if ((ed->reason&XkbXI_IndicatorsMask)&&
	     ((ed->ledClass!=sli->class)||(ed->ledID!=sli->id))) {
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    }

    if ((kbd==dev)&&(sli->flags&XkbSLI_IsDefault)) {
	if (changes==NULL) {
	    changes= &my_changes;
	    memset((char *)changes, 0, sizeof(XkbChangesRec));
	}
	changes->indicators.state_changes|= affected;
    }

    ed->reason|=	XkbXI_IndicatorStateMask;
    ed->ledClass= 	sli->class;
    ed->ledID=		sli->id;
    ed->ledsDefined=	sli->namesPresent|sli->mapsPresent;
    ed->ledState=	sli->effectiveState;
    ed->unsupported=	0;
    ed->supported=	XkbXI_AllFeaturesMask;
d273 29
a301 2
    if (changes!=&my_changes)	changes= NULL;
    if (ed!=&my_ed)		ed= NULL;
d303 1
a303 1
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
d308 1
a308 1
XkbUpdateAllDeviceIndicators(XkbChangesPtr changes,XkbEventCausePtr cause)
d310 25
a334 2
DeviceIntPtr		edev;
XkbSrvLedInfoPtr	sli;
d336 2
a337 23
    for (edev=inputInfo.devices;edev!=NULL;edev=edev->next) {
	if (edev->kbdfeed) {
	    KbdFeedbackPtr	kf;
	    for (kf=edev->kbdfeed;kf!=NULL;kf=kf->next) {
		if ((kf->xkb_sli==NULL)||(kf->xkb_sli->maps==NULL))
		    continue;
		sli= kf->xkb_sli;
		XkbUpdateLedAutoState(edev,sli,sli->mapsPresent,NULL,
								changes,cause);
			
	    }
	}
	if (edev->leds) {
	    LedFeedbackPtr	lf;
	    for (lf=edev->leds;lf!=NULL;lf=lf->next) {
		if ((lf->xkb_sli==NULL)||(lf->xkb_sli->maps==NULL))
		    continue;
		sli= lf->xkb_sli;
		XkbUpdateLedAutoState(edev,sli,sli->mapsPresent,NULL,
								changes,cause);
			
	    }
	}
a341 1

d344 21
a364 21
	/*
	 * void
	 * XkbSetIndicators(dev,affect,values,cause)
	 *
	 * Attempts to change the indicators specified in 'affect' to the
	 * states specified in 'values' for the default keyboard feedback
	 * on the keyboard specified by 'dev.'   Attempts to change indicator
	 * state might be ignored or have no affect, depending on the XKB
	 * indicator map for any affected indicators, as described in section
	 * 9.2 of the XKB protocol specification.
	 *
	 * If 'changes' is non-NULL, this function notes any changes to the
	 * keyboard state, controls, or indicator state that result from this
	 * attempted change.   If 'changes' is NULL, this function generates
	 * XKB events to report any such changes to interested clients.
	 *
	 * If 'cause' is non-NULL, it specifies the reason for the change, 
	 * as reported in some XKB events.   If it is NULL, this function 
	 * assumes that the change is the result of a core protocol 
	 * ChangeKeyboardMapping request.
	 */
d367 19
a385 20
XkbSetIndicators(	DeviceIntPtr		dev,
			CARD32			affect,
			CARD32			values,
			XkbEventCausePtr	cause)
{
XkbSrvLedInfoPtr		sli;
XkbChangesRec			changes;
xkbExtensionDeviceNotify	ed;
unsigned 			side_affected;

    memset((char *)&changes, 0, sizeof(XkbChangesRec));
    memset((char *)&ed, 0, sizeof(xkbExtensionDeviceNotify));
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    sli->explicitState&= ~affect;
    sli->explicitState|= (affect&values);
    XkbApplyLedStateChanges(dev,sli,affect,&ed,&changes,cause);

    side_affected= 0;
    if (changes.state_changes!=0)
	side_affected|= XkbIndicatorsToUpdate(dev,changes.state_changes,FALSE);
d387 1
a387 1
	side_affected|= sli->usesControls;
d390 2
a391 2
	XkbUpdateLedAutoState(dev,sli,side_affected,&ed,&changes,cause);
	affect|= side_affected;
d394 1
a394 1
	XkbUpdateAllDeviceIndicators(NULL,cause);
d396 1
a396 1
    XkbFlushLedEvents(dev,dev,sli,&ed,&changes,cause);
d404 16
a419 16
	/*
	 * void
	 * XkbUpdateIndicators(dev,update,check_edevs,changes,cause)
	 *
	 * Applies the indicator maps for any indicators specified in
	 * 'update' from the default keyboard feedback on the device
	 * specified by 'dev.' 
	 *
	 * If 'changes' is NULL, this function generates and XKB events
	 * required to report the necessary changes, otherwise it simply
	 * notes the indicators with changed state.
	 *
	 * If 'check_edevs' is TRUE, this function also checks the indicator
	 * maps for any open extension devices that have them, and updates
	 * the state of any extension device indicators as necessary.
	 */
d422 4
a425 5
XkbUpdateIndicators(	DeviceIntPtr		dev,
			register CARD32		update,
			Bool			check_edevs,
			XkbChangesPtr		changes,
			XkbEventCausePtr	cause)
d427 1
a427 1
XkbSrvLedInfoPtr	sli;
d429 2
a430 2
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateLedAutoState(dev,sli,update,NULL,changes,cause);
d432 1
a432 1
	XkbUpdateAllDeviceIndicators(changes,cause);
d440 10
a449 10
	/*
	 * void
	 * XkbCheckIndicatorMaps(dev,sli,which)
	 *
	 * Updates the 'indicator accelerators' for the indicators specified
	 * by 'which' in the feedback specified by 'sli.' The indicator 
	 * accelerators are internal to the server and are used to simplify 
	 * and speed up the process of figuring out which indicators might 
	 * be affected by a particular change in keyboard state or controls.
	 */
d452 1
a452 1
XkbCheckIndicatorMaps(DeviceIntPtr dev,XkbSrvLedInfoPtr sli,unsigned which)
d454 3
a456 3
register unsigned	i,bit;
XkbIndicatorMapPtr	map;
XkbDescPtr		xkb;
d458 1
a458 1
    if ((sli->flags&XkbSLI_HasOwnState)==0)
d461 37
a497 36
    sli->usesBase&=	 ~which;
    sli->usesLatched&=	 ~which;
    sli->usesLocked&=	 ~which;
    sli->usesEffective&= ~which;
    sli->usesCompat&=	 ~which;
    sli->usesControls&=	 ~which;
    sli->mapsPresent&=	 ~which;

    xkb= dev->key->xkbInfo->desc;
    for (i=0,bit=1,map=sli->maps;i<XkbNumIndicators;i++,bit<<=1,map++) {
	if (which&bit) {
	    CARD8		what;

	    if (!map || !XkbIM_InUse(map))
		continue;
	    sli->mapsPresent|= bit;

	    what= (map->which_mods|map->which_groups);
	    if (what&XkbIM_UseBase)
		 sli->usesBase|= bit;
	    if (what&XkbIM_UseLatched)
		 sli->usesLatched|= bit;
	    if (what&XkbIM_UseLocked)
		 sli->usesLocked|= bit;
	    if (what&XkbIM_UseEffective)
		 sli->usesEffective|= bit;
	    if (what&XkbIM_UseCompat)
		 sli->usesCompat|= bit;
	    if (map->ctrls)
		 sli->usesControls|= bit;

	    map->mods.mask= map->mods.real_mods;
	    if (map->mods.vmods!=0) {
		map->mods.mask|= XkbMaskForVMask(xkb,map->mods.vmods);
	    }
	}
d499 1
a499 1
    sli->usedComponents= 0;
d501 1
a501 1
	sli->usedComponents|= XkbModifierBaseMask|XkbGroupBaseMask;
d503 1
a503 1
	sli->usedComponents|= XkbModifierLatchMask|XkbGroupLatchMask;
d505 1
a505 1
	sli->usedComponents|= XkbModifierLockMask|XkbGroupLockMask;
d507 1
a507 1
	sli->usedComponents|= XkbModifierStateMask|XkbGroupStateMask;
d509 1
a509 1
	sli->usedComponents|= XkbCompatStateMask;
d515 10
a524 10
	/*
	 * XkbSrvLedInfoPtr
	 * XkbAllocSrvLedInfo(dev,kf,lf,needed_parts)
	 *
	 * Allocates an XkbSrvLedInfoPtr for the feedback specified by either
	 * 'kf' or 'lf' on the keyboard specified by 'dev.'
	 *
	 * If 'needed_parts' is non-zero, this function makes sure that any
	 * of the parts speicified therein are allocated.
	 */
d526 74
a599 72
XkbAllocSrvLedInfo(	DeviceIntPtr		dev,
			KbdFeedbackPtr		kf,
			LedFeedbackPtr		lf,
			unsigned		needed_parts)
{
XkbSrvLedInfoPtr	sli;
Bool			checkAccel;
Bool			checkNames;

    sli= NULL;
    checkAccel= checkNames= FALSE;
    if ((kf!=NULL)&&(kf->xkb_sli==NULL)) {
	kf->xkb_sli= sli= calloc(1, sizeof(XkbSrvLedInfoRec));
	if (sli==NULL)
	    return NULL; /* ALLOCATION ERROR */
	if (dev->key && dev->key->xkbInfo)
	     sli->flags= XkbSLI_HasOwnState;
	else sli->flags= 0;	
	sli->class=	KbdFeedbackClass;
	sli->id=	kf->ctrl.id;
	sli->fb.kf=	kf;

	sli->autoState=		0;
	sli->explicitState=	kf->ctrl.leds;
	sli->effectiveState=	kf->ctrl.leds;

	if ((kf==dev->kbdfeed) && (dev->key) && (dev->key->xkbInfo)) {
	    XkbDescPtr	xkb;
	    xkb= dev->key->xkbInfo->desc;
	    sli->flags|= 		XkbSLI_IsDefault;
	    sli->physIndicators=	xkb->indicators->phys_indicators;
	    sli->names=			xkb->names->indicators;
	    sli->maps=			xkb->indicators->maps;
	    checkNames= checkAccel=	TRUE;
	}
	else {
	    sli->physIndicators=	XkbAllIndicatorsMask;
	    sli->names=			NULL;
	    sli->maps=			NULL;
	}
    }
    else if ((kf!=NULL)&&((kf->xkb_sli->flags&XkbSLI_IsDefault)!=0)) {
	XkbDescPtr	xkb;
	xkb= dev->key->xkbInfo->desc;
	sli= kf->xkb_sli;
	sli->physIndicators=	xkb->indicators->phys_indicators;
	if (xkb->names->indicators!=sli->names) {
	    checkNames= TRUE;
	    sli->names= xkb->names->indicators;
	}
	if (xkb->indicators->maps!=sli->maps) {
	    checkAccel= TRUE;
	    sli->maps= xkb->indicators->maps;
	}
    }
    else if ((lf!=NULL)&&(lf->xkb_sli==NULL)) {
	lf->xkb_sli= sli= calloc(1, sizeof(XkbSrvLedInfoRec));
	if (sli==NULL)
	    return NULL; /* ALLOCATION ERROR */
	if (dev->key && dev->key->xkbInfo)
	     sli->flags= XkbSLI_HasOwnState;
	else sli->flags= 0;	
	sli->class=	LedFeedbackClass;
	sli->id=	lf->ctrl.id;
	sli->fb.lf=	lf;

	sli->physIndicators=	lf->ctrl.led_mask;
	sli->autoState=		0;
	sli->explicitState=	lf->ctrl.led_values;
	sli->effectiveState=	lf->ctrl.led_values;
	sli->maps=		NULL;
	sli->names=		NULL;
d602 5
a606 5
	return NULL;
    if ((sli->names==NULL)&&(needed_parts&XkbXI_IndicatorNamesMask))
	sli->names= calloc(XkbNumIndicators, sizeof(Atom));
    if ((sli->maps==NULL)&&(needed_parts&XkbXI_IndicatorMapsMask))
	sli->maps= calloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
d608 7
a614 6
	register unsigned i,bit;
	sli->namesPresent=	0;
	for (i=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {
	    if (sli->names[i]!=None)
		sli->namesPresent|= bit;
	}
d617 1
a617 1
	 XkbCheckIndicatorMaps(dev,sli,XkbAllIndicatorsMask);
d624 3
a626 3
    if ((sli->flags&XkbSLI_IsDefault)==0) {
	free(sli->maps);
	free(sli->names);
d628 2
a629 2
    sli->maps= NULL;
    sli->names= NULL;
d643 2
a644 4
XkbCopySrvLedInfo(	DeviceIntPtr		from,
			XkbSrvLedInfoPtr	src,
			KbdFeedbackPtr		kf,
			LedFeedbackPtr		lf)
d649 1
a649 1
	goto finish;
d651 1
a651 1
    sli_new = calloc(1, sizeof( XkbSrvLedInfoRec));
d653 1
a653 1
	goto finish;
d657 1
a657 1
	sli_new->fb.kf = kf;
d659 1
a659 1
	sli_new->fb.lf = lf;
d662 5
a666 5
	sli_new->names= calloc(XkbNumIndicators, sizeof(Atom));
	sli_new->maps= calloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
    } /* else sli_new->names/maps is pointing to
	dev->key->xkbInfo->desc->names->indicators;
	dev->key->xkbInfo->desc->names->indicators; */
d668 1
a668 1
finish:
d674 10
a683 10
	/*
	 * XkbSrvLedInfoPtr
	 * XkbFindSrvLedInfo(dev,class,id,needed_parts)
	 *
	 * Finds the XkbSrvLedInfoPtr for the specified 'class' and 'id'
	 * on the device specified by 'dev.'   If the class and id specify
	 * a valid device feedback, this function returns the existing 
	 * feedback or allocates a new one.
	 *
	 */
d686 2
a687 4
XkbFindSrvLedInfo(	DeviceIntPtr		dev,
			unsigned		class,
			unsigned		id,
			unsigned		needed_parts)
d689 1
a689 1
XkbSrvLedInfoPtr	sli;
d692 42
a733 37
    if (((class==XkbDfltXIClass)&&(id==XkbDfltXIId))&&(dev->kbdfeed)) {
	XkbSrvLedInfoPtr	sli;
	sli= dev->kbdfeed->xkb_sli;
	if (dev->kbdfeed->xkb_sli==NULL) {
	    sli= XkbAllocSrvLedInfo(dev,dev->kbdfeed,NULL,needed_parts);
	    dev->kbdfeed->xkb_sli= sli;
	}
	return dev->kbdfeed->xkb_sli;
    }

    sli= NULL;
    if (class==XkbDfltXIClass) {
	if (dev->kbdfeed)	class= KbdFeedbackClass;
	else if (dev->leds)	class= LedFeedbackClass;
	else 			return NULL;
    }
    if (class==KbdFeedbackClass) {
	KbdFeedbackPtr	kf;
	for (kf=dev->kbdfeed;kf!=NULL;kf=kf->next) {
	    if ((id==XkbDfltXIId)||(id==kf->ctrl.id)) {
		if (kf->xkb_sli==NULL)
		    kf->xkb_sli= XkbAllocSrvLedInfo(dev,kf,NULL,needed_parts);
		sli= kf->xkb_sli;
		break;
	    }	
	}
    }
    else if (class==LedFeedbackClass) {
	LedFeedbackPtr	lf;
	for (lf=dev->leds;lf!=NULL;lf=lf->next) {
	    if ((id==XkbDfltXIId)||(id==lf->ctrl.id)) {
		if (lf->xkb_sli==NULL)
		    lf->xkb_sli= XkbAllocSrvLedInfo(dev,NULL,lf,needed_parts);
		sli= lf->xkb_sli;
		break;
	    }	
	}
d736 4
a739 4
	if ((sli->names==NULL)&&(needed_parts&XkbXI_IndicatorNamesMask))
	    sli->names= calloc(XkbNumIndicators, sizeof(Atom));
	if ((sli->maps==NULL)&&(needed_parts&XkbXI_IndicatorMapsMask))
	    sli->maps= calloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
d747 5
a751 6
XkbFlushLedEvents(	DeviceIntPtr			dev,
			DeviceIntPtr			kbd,
			XkbSrvLedInfoPtr		sli,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
d754 13
a766 12
	if (changes->indicators.state_changes)
	    XkbDDXUpdateDeviceIndicators(dev,sli,sli->effectiveState);
	XkbSendNotification(kbd,changes,cause);
	memset((char *)changes, 0, sizeof(XkbChangesRec));

	if (XkbAX_NeedFeedback(kbd->key->xkbInfo->desc->ctrls, XkbAX_IndicatorFBMask)) {
		if (sli->effectiveState)
			/* it appears that the which parameter is not used */
			XkbDDXAccessXBeep(dev, _BEEP_LED_ON, XkbAccessXFeedbackMask);
		else
			XkbDDXAccessXBeep(dev, _BEEP_LED_OFF, XkbAccessXFeedbackMask);
	}
d769 6
a774 6
	if (ed->reason) {
	    if ((dev!=kbd)&&(ed->reason&XkbXI_IndicatorStateMask))
		XkbDDXUpdateDeviceIndicators(dev,sli,sli->effectiveState);
	    XkbSendExtensionDeviceNotify(dev,cause->client,ed);
	}
	memset((char *)ed, 0, sizeof(XkbExtensionDeviceNotify));
d782 9
a790 10
XkbApplyLedNameChanges(	DeviceIntPtr 			dev,
			XkbSrvLedInfoPtr		sli,
			unsigned			changed_names,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
DeviceIntPtr			kbd;
XkbChangesRec			my_changes;
xkbExtensionDeviceNotify	my_ed;
d792 2
a793 2
    if (changed_names==0)
	return;
d795 3
a797 2
	 kbd= dev;
    else kbd= inputInfo.keyboard;
d799 30
a828 28
    if (ed==NULL) {
	ed= &my_ed;
	memset((char *)ed, 0, sizeof(xkbExtensionDeviceNotify));
    }
    else if ((ed->reason&XkbXI_IndicatorsMask)&&
	     ((ed->ledClass!=sli->class)||(ed->ledID!=sli->id))) {
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    }

    if ((kbd==dev)&&(sli->flags&XkbSLI_IsDefault)) { 
	if (changes==NULL) {
	   changes= &my_changes;
	   memset((char *)changes, 0, sizeof(XkbChangesRec));
	}
	changes->names.changed|= XkbIndicatorNamesMask;
	changes->names.changed_indicators|= changed_names;
    }

    ed->reason|=	XkbXI_IndicatorNamesMask;
    ed->ledClass= 	sli->class;
    ed->ledID=		sli->id;
    ed->ledsDefined=	sli->namesPresent|sli->mapsPresent;
    ed->ledState=	sli->effectiveState;
    ed->unsupported=	0;
    ed->supported=	XkbXI_AllFeaturesMask;

    if (changes!=&my_changes)	changes= NULL;
    if (ed!=&my_ed)		ed= NULL;
d830 1
a830 1
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
d833 1
d836 24
a859 24
	/*
	 * void
	 * XkbApplyLedMapChanges(dev,sli,changed_maps,changes,cause)
	 *
	 * Handles all of the secondary effects of the changes to the
	 * feedback specified by 'sli' on the device specified by 'dev.'
	 * 
	 * If 'changed_maps' specifies any indicators, this function generates
	 * XkbExtensionDeviceNotify events and possibly IndicatorMapNotify
	 * events to report the changes, and recalculates the effective
	 * state of each indicator with a changed map.  If any indicators
	 * change state, the server generates XkbExtensionDeviceNotify and
	 * XkbIndicatorStateNotify events as appropriate.
	 *
	 * If 'changes' is non-NULL, this function updates it to reflect
	 * any changes to the keyboard state or controls or to the 'core'
	 * indicator names, maps, or state.   If 'changes' is NULL, this
	 * function generates XKB events as needed to report the changes.
	 * If 'dev' is not a keyboard device, any changes are reported
	 * for the core keyboard.
	 *
	 * The 'cause' specifies the reason for the event (key event or
	 * request) for the change, as reported in some XKB events.
	 */
d862 9
a870 10
XkbApplyLedMapChanges(	DeviceIntPtr 			dev,
			XkbSrvLedInfoPtr		sli,
			unsigned			changed_maps,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
DeviceIntPtr			kbd;
XkbChangesRec			my_changes;
xkbExtensionDeviceNotify	my_ed;
d872 2
a873 2
    if (changed_maps==0)
	return;
d875 3
a877 2
	 kbd= dev;
    else kbd= inputInfo.keyboard;
d879 3
a881 3
    if (ed==NULL) {
	ed= &my_ed;
	memset((char *)ed, 0, sizeof(xkbExtensionDeviceNotify));
d883 3
a885 3
    else if ((ed->reason&XkbXI_IndicatorsMask)&&
	     ((ed->ledClass!=sli->class)||(ed->ledID!=sli->id))) {
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
d888 6
a893 6
    if ((kbd==dev)&&(sli->flags&XkbSLI_IsDefault)) {
	if (changes==NULL) {
	    changes= &my_changes;
	    memset((char *)changes, 0, sizeof(XkbChangesRec));
	}
	changes->indicators.map_changes|= changed_maps;
d896 1
a896 1
    XkbCheckIndicatorMaps(dev,sli,changed_maps);
d898 7
a904 7
    ed->reason|=	XkbXI_IndicatorMapsMask;
    ed->ledClass= 	sli->class;
    ed->ledID=		sli->id;
    ed->ledsDefined=	sli->namesPresent|sli->mapsPresent;
    ed->ledState=	sli->effectiveState;
    ed->unsupported=	0;
    ed->supported=	XkbXI_AllFeaturesMask;
d906 1
a906 1
    XkbUpdateLedAutoState(dev,sli,changed_maps,ed,changes,cause);
d908 4
a911 2
    if (changes!=&my_changes)	changes= NULL;
    if (ed!=&my_ed)		ed= NULL;
d913 1
a913 1
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
d920 14
a933 15
XkbApplyLedStateChanges(DeviceIntPtr 			dev,
			XkbSrvLedInfoPtr		sli,
			unsigned			changed_leds,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
XkbSrvInfoPtr			xkbi;
DeviceIntPtr			kbd;
XkbChangesRec			my_changes;
xkbExtensionDeviceNotify	my_ed;
register unsigned		i,bit,affected;
XkbIndicatorMapPtr		map;
unsigned			oldState;
Bool				kb_changed;
d935 2
a936 2
    if (changed_leds==0)
	return;
d938 39
a976 37
	 kbd= dev;
    else kbd= inputInfo.keyboard;
    xkbi= kbd->key->xkbInfo;

    if (changes==NULL) {
	changes= &my_changes;
	memset((char *)changes, 0, sizeof(XkbChangesRec));
    }

    kb_changed= FALSE;
    affected= changed_leds;
    oldState= sli->effectiveState;
    for (i=0,bit=1;(i<XkbNumIndicators)&&(affected);i++,bit<<=1) {
	if ((affected&bit)==0)
	    continue;
	affected&= ~bit;
	map= &sli->maps[i];
	if (map->flags&XkbIM_NoExplicit) {
	    sli->explicitState&= ~bit;
	    continue;
	}
	if (map->flags&XkbIM_LEDDrivesKB) {
	    Bool on= ((sli->explicitState&bit)!=0);
	    if (XkbApplyLEDChangeToKeyboard(xkbi,map,on,changes))
		kb_changed= TRUE;
	}
    }
    sli->effectiveState= (sli->autoState|sli->explicitState);
    affected= sli->effectiveState^oldState;

    if (ed==NULL) {
	ed= &my_ed;
	memset((char *)ed, 0, sizeof(xkbExtensionDeviceNotify));
    }
    else if (affected&&(ed->reason&XkbXI_IndicatorsMask)&&
	     ((ed->ledClass!=sli->class)||(ed->ledID!=sli->id))) {
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
d979 2
a980 2
    if ((kbd==dev)&&(sli->flags&XkbSLI_IsDefault))
	changes->indicators.state_changes|= affected;
d982 7
a988 7
	ed->reason|=		XkbXI_IndicatorStateMask;
	ed->ledClass= 		sli->class;
	ed->ledID=		sli->id;
	ed->ledsDefined=	sli->namesPresent|sli->mapsPresent;
	ed->ledState=		sli->effectiveState;
	ed->unsupported=	0;
	ed->supported=		XkbXI_AllFeaturesMask;
d992 2
a993 2
	XkbComputeDerivedState(kbd->key->xkbInfo);
	XkbUpdateLedAutoState(dev,sli,sli->mapsPresent,ed,changes,cause);
d996 4
a999 2
    if (changes!=&my_changes)	changes= NULL;
    if (ed!=&my_ed)		ed= NULL;
d1001 1
a1001 1
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
d1003 1
a1003 1
	XkbUpdateAllDeviceIndicators(NULL,cause);
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d559 1
d588 2
d720 6
a725 4
    if ((sli->names==NULL)&&(needed_parts&XkbXI_IndicatorNamesMask))
	sli->names= calloc(XkbNumIndicators, sizeof(Atom));
    if ((sli->maps==NULL)&&(needed_parts&XkbXI_IndicatorMapsMask))
	sli->maps= calloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d169 1
a169 1
    return (stateChange || ctrlChange);
d266 1
a266 1
	bzero((char *)ed,sizeof(xkbExtensionDeviceNotify));
d276 1
a276 1
	    bzero((char *)changes,sizeof(XkbChangesRec));
d365 2
a366 2
    bzero((char *)&changes,sizeof(XkbChangesRec));
    bzero((char *)&ed,sizeof(xkbExtensionDeviceNotify));
d527 1
a527 1
	kf->xkb_sli= sli= xcalloc(1, sizeof(XkbSrvLedInfoRec));
d570 1
a570 1
	lf->xkb_sli= sli= xcalloc(1, sizeof(XkbSrvLedInfoRec));
d588 1
a588 1
	sli->names= xcalloc(XkbNumIndicators, sizeof(Atom));
d590 1
a590 1
	sli->maps= xcalloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
d608 2
a609 2
	if (sli->maps)	xfree(sli->maps);
	if (sli->names)	xfree(sli->names);
d613 1
a613 1
    xfree(sli);
d636 1
a636 1
    sli_new = xcalloc(1, sizeof( XkbSrvLedInfoRec));
d647 2
a648 2
	sli_new->names= xcalloc(XkbNumIndicators, sizeof(Atom));
	sli_new->maps= xcalloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
d718 1
a718 1
	sli->names= xcalloc(XkbNumIndicators, sizeof(Atom));
d720 1
a720 1
	sli->maps= xcalloc(XkbNumIndicators, sizeof(XkbIndicatorMapRec));
d738 1
a738 1
	bzero((char *)changes,sizeof(XkbChangesRec));
d754 1
a754 1
	bzero((char *)ed,sizeof(XkbExtensionDeviceNotify));
d781 1
a781 1
	bzero((char *)ed,sizeof(xkbExtensionDeviceNotify));
d791 1
a791 1
	   bzero((char *)changes,sizeof(XkbChangesRec));
d858 1
a858 1
	bzero((char *)ed,sizeof(xkbExtensionDeviceNotify));
d868 1
a868 1
	    bzero((char *)changes,sizeof(XkbChangesRec));
d920 1
a920 1
	bzero((char *)changes,sizeof(XkbChangesRec));
d946 1
a946 1
	bzero((char *)ed,sizeof(xkbExtensionDeviceNotify));
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a33 1
#define NEED_EVENTS 1
d106 2
a107 2
	return False;
    ctrlChange= stateChange= False;
d118 1
a118 1
	    ctrlChange= True;
d136 1
a136 1
	    stateChange= True;
d145 1
a145 1
	    stateChange= True;
d155 1
a155 1
		stateChange= True;
d165 1
a165 1
		stateChange= True;
d189 1
a189 1
    on= False;
d286 1
a286 1
    ed->unsupported|=	XkbXI_IndicatorStateMask;
d374 1
a374 1
	side_affected|= XkbIndicatorsToUpdate(dev,changes.state_changes,False);
d405 1
a405 1
	 * If 'check_edevs' is True, this function also checks the indicator
d525 1
a525 1
    checkAccel= checkNames= False;
d527 1
a527 1
	kf->xkb_sli= sli= _XkbTypedCalloc(1,XkbSrvLedInfoRec);
d548 1
a548 1
	    checkNames= checkAccel=	True;
d561 1
a561 1
	    checkNames= True;
d565 1
a565 1
	    checkAccel= True;
d570 1
a570 1
	lf->xkb_sli= sli= _XkbTypedCalloc(1,XkbSrvLedInfoRec);
d588 1
a588 1
	sli->names= _XkbTypedCalloc(XkbNumIndicators,Atom);
d590 1
a590 1
	sli->maps= _XkbTypedCalloc(XkbNumIndicators,XkbIndicatorMapRec);
d608 2
a609 2
	if (sli->maps)	_XkbFree(sli->maps);
	if (sli->names)	_XkbFree(sli->names);
d613 1
a613 1
    _XkbFree(sli);
d636 1
a636 1
    sli_new = _XkbTypedCalloc(1, XkbSrvLedInfoRec);
d646 3
a648 3
    if (sli_new->flags & XkbSLI_IsDefault) {
	sli_new->names= _XkbTypedCalloc(XkbNumIndicators,Atom);
	sli_new->maps= _XkbTypedCalloc(XkbNumIndicators,XkbIndicatorMapRec);
d670 1
a670 1
XkbSrvLedInfoPtr 
d718 1
a718 1
	sli->names= _XkbTypedCalloc(XkbNumIndicators,Atom);
d720 1
a720 1
	sli->maps= _XkbTypedCalloc(XkbNumIndicators,XkbIndicatorMapRec);
d748 7
a754 4
    if (ed && (ed->reason)) {
	if ((dev!=kbd)&&(ed->reason&XkbXI_IndicatorStateMask))
	    XkbDDXUpdateDeviceIndicators(dev,sli,sli->effectiveState);
	XkbSendExtensionDeviceNotify(dev,cause->client,ed);
a755 1
    bzero((char *)ed,sizeof(XkbExtensionDeviceNotify));
d880 1
a880 1
    ed->unsupported|=	XkbXI_IndicatorMapsMask;
d923 1
a923 1
    kb_changed= False;
d938 1
a938 1
		kb_changed= True;
d961 1
a961 1
	ed->unsupported|=	XkbXI_IndicatorStateMask;
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d450 1
a450 1
	dev= inputInfo.keyboard;
d465 1
a465 1
	    if (!XkbIM_InUse(map)) 
d618 39
@


1.2
log
@Fix from X.Org repository:
xkb: don't update LEDs if they don't exist (which would trigger an NULL
pointer dereference).
@
text
@d245 1
a245 1
    else kbd= (DeviceIntPtr)LookupKeyboardDevice();
d450 1
a450 1
	dev= (DeviceIntPtr)LookupKeyboardDevice();
d737 1
a737 1
    else kbd= (DeviceIntPtr)LookupKeyboardDevice();
d814 1
a814 1
    else kbd= (DeviceIntPtr)LookupKeyboardDevice();
d875 1
a875 1
    else kbd= (DeviceIntPtr)LookupKeyboardDevice();
@


1.1
log
@Initial revision
@
text
@d41 1
a41 1
#include <X11/extensions/XKBsrv.h>
d66 3
d88 1
a88 1
	 * XkbApplyLEDChangeToKeyboard(xkbi,map,on,change)
d97 1
a97 1
Bool
d172 158
a391 49
	/*
	 * Bool
	 * ComputeAutoState(map,state,ctrls)
	 *
	 * This function reports the effect of applying the specified
	 * indicator map given the specified state and controls, as
	 * described in section 9.2 of the XKB protocol specification.
	 */

static Bool
ComputeAutoState(	XkbIndicatorMapPtr	map,
			XkbStatePtr 		state,
			XkbControlsPtr 		ctrls)
{
Bool 			on;
CARD8 			mods,group;

    on= False;
    mods= group= 0;
    if (map->which_mods&XkbIM_UseAnyMods) {
	if (map->which_mods&XkbIM_UseBase)
	    mods|= state->base_mods;
	if (map->which_mods&XkbIM_UseLatched)
	    mods|= state->latched_mods;
	if (map->which_mods&XkbIM_UseLocked)
	    mods|= state->locked_mods;
	if (map->which_mods&XkbIM_UseEffective)
	    mods|= state->mods;
	if (map->which_mods&XkbIM_UseCompat)
	    mods|= state->compat_state;
	on = ((map->mods.mask&mods)!=0);
	on = on||((mods==0)&&(map->mods.mask==0)&&(map->mods.vmods==0));
    }
    if (map->which_groups&XkbIM_UseAnyGroup) {
	if (map->which_groups&XkbIM_UseBase)
	    group|= (1L << state->base_group);
	if (map->which_groups&XkbIM_UseLatched)
	    group|= (1L << state->latched_group);
	if (map->which_groups&XkbIM_UseLocked)
	    group|= (1L << state->locked_group);
	if (map->which_groups&XkbIM_UseEffective)
	    group|= (1L << state->group);
	on = on||(((map->groups&group)!=0)||(map->groups==0));
    }
    if (map->ctrls)
	on = on||(ctrls->enabled_ctrls&map->ctrls);
    return on;
}

a428 33
void
XkbUpdateAllDeviceIndicators(XkbChangesPtr changes,XkbEventCausePtr cause)
{
DeviceIntPtr		edev;
XkbSrvLedInfoPtr	sli;

    for (edev=inputInfo.devices;edev!=NULL;edev=edev->next) {
	if (edev->kbdfeed) {
	    KbdFeedbackPtr	kf;
	    for (kf=edev->kbdfeed;kf!=NULL;kf=kf->next) {
		if ((kf->xkb_sli==NULL)||(kf->xkb_sli->maps==NULL))
		    continue;
		sli= kf->xkb_sli;
		XkbUpdateLedAutoState(edev,sli,sli->mapsPresent,NULL,
								changes,cause);
			
	    }
	}
	if (edev->leds) {
	    LedFeedbackPtr	lf;
	    for (lf=edev->leds;lf!=NULL;lf=lf->next) {
		if ((lf->xkb_sli==NULL)||(lf->xkb_sli->maps==NULL))
		    continue;
		sli= lf->xkb_sli;
		XkbUpdateLedAutoState(edev,sli,sli->mapsPresent,NULL,
								changes,cause);
			
	    }
	}
    }
    return;
}

d757 1
a757 1
    ed->reason|=	(XkbXI_IndicatorNamesMask&(~XkbXI_KeyboardsMask));
d762 2
a763 2
    ed->unsupported=	XkbXI_KeyboardsMask;
    ed->supported=	XkbXI_AllFeaturesMask&(~XkbXI_KeyboardsMask);
d835 1
a835 1
    ed->reason|=	(XkbXI_IndicatorMapsMask&(~XkbXI_KeyboardsMask));
d840 2
a841 2
    ed->unsupported|=	XkbXI_KeyboardsMask&XkbXI_IndicatorMapsMask;
    ed->supported=	XkbXI_AllFeaturesMask&(~XkbXI_KeyboardsMask);
d916 1
a916 1
	ed->reason|=		(XkbXI_IndicatorStateMask&(~XkbXI_KeyboardsMask));
d921 2
a922 2
	ed->unsupported|=	XkbXI_KeyboardsMask&XkbXI_IndicatorStateMask;
	ed->supported=		XkbXI_AllFeaturesMask&(~XkbXI_KeyboardsMask);
a935 207
    return;
}

/***====================================================================***/

void
XkbUpdateLedAutoState(	DeviceIntPtr			dev,
			XkbSrvLedInfoPtr		sli,
			unsigned			maps_to_check,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
DeviceIntPtr			kbd;
XkbStatePtr			state;
XkbControlsPtr			ctrls;
XkbChangesRec			my_changes;
xkbExtensionDeviceNotify	my_ed;
register unsigned		i,bit,affected;
register XkbIndicatorMapPtr	map;
unsigned			oldState;

    if ((maps_to_check==0)||(sli->maps==NULL)||(sli->mapsPresent==0))
	return;

    if (dev->key && dev->key->xkbInfo)
	 kbd= dev;
    else kbd= (DeviceIntPtr)LookupKeyboardDevice();

    state= &kbd->key->xkbInfo->state;
    ctrls= kbd->key->xkbInfo->desc->ctrls;
    affected= maps_to_check;
    oldState= sli->effectiveState;
    sli->autoState&= ~affected;
    for (i=0,bit=1;(i<XkbNumIndicators)&&(affected);i++,bit<<=1) {
	if ((affected&bit)==0)
	    continue;
	affected&= ~bit;
	map= &sli->maps[i];
	if((!(map->flags&XkbIM_NoAutomatic))&&ComputeAutoState(map,state,ctrls))
	    sli->autoState|= bit;
    }
    sli->effectiveState= (sli->autoState|sli->explicitState);
    affected= sli->effectiveState^oldState;
    if (affected==0)
	return;

    if (ed==NULL) {
	ed= &my_ed;
	bzero((char *)ed,sizeof(xkbExtensionDeviceNotify));
    }
    else if ((ed->reason&XkbXI_IndicatorsMask)&&
	     ((ed->ledClass!=sli->class)||(ed->ledID!=sli->id))) {
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    }

    if ((kbd==dev)&&(sli->flags&XkbSLI_IsDefault)) {
	if (changes==NULL) {
	    changes= &my_changes;
	    bzero((char *)changes,sizeof(XkbChangesRec));
	}
	changes->indicators.state_changes|= affected;
    }

    ed->reason|=	(XkbXI_IndicatorStateMask&(~XkbXI_KeyboardsMask));
    ed->ledClass= 	sli->class;
    ed->ledID=		sli->id;
    ed->ledsDefined=	sli->namesPresent|sli->mapsPresent;
    ed->ledState=	sli->effectiveState;
    ed->unsupported|=	XkbXI_KeyboardsMask&XkbXI_IndicatorStateMask;
    ed->supported=	XkbXI_AllFeaturesMask&(~XkbXI_KeyboardsMask);

    if (changes!=&my_changes)	changes= NULL;
    if (ed!=&my_ed)		ed= NULL;
    if (changes || ed)
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    return;
}

/***====================================================================***/

static void
_UpdateButtonVMods(	XkbDescPtr			xkb,
			unsigned			num_btns,
			XkbAction *			acts,
			unsigned			changed,
			xkbExtensionDeviceNotify *	ed_inout)
{
register int i;

    for (i=0;i<num_btns;i++,acts++) {
	if ((acts->any.type!=XkbSA_NoAction)&&
				XkbUpdateActionVirtualMods(xkb,acts,changed)) {
	    if ((ed_inout->reason&XkbXI_ButtonActionsMask)==0) {
		ed_inout->reason|= XkbXI_ButtonActionsMask;
		ed_inout->firstBtn= i;
		ed_inout->nBtns= 1;
	    }
	    else {
		ed_inout->nBtns= (i-ed_inout->firstBtn)+1;
	    }
	}
    }
    return;
}

static void
_UpdateMapVMods(	XkbDescPtr	xkb,
			register	XkbIndicatorMapPtr map,
			unsigned	changed_vmods,
			unsigned *	changed_maps_rtrn)
{
register int i;

    *changed_maps_rtrn= 0;
    for (i=0;i<XkbNumIndicators;i++,map++) {
	if (map->mods.vmods&changed_vmods) {
	    map->mods.mask= map->mods.real_mods;
	    map->mods.mask|= XkbMaskForVMask(xkb,map->mods.vmods);
	    *changed_maps_rtrn|= (1L<<i);
	}	
    }
    return;
}

static void
_UpdateDeviceVMods(	DeviceIntPtr		dev,
			XkbDescPtr		xkb,
			unsigned		changed,
			XkbEventCausePtr	cause)
{
xkbExtensionDeviceNotify	ed;
XkbSrvLedInfoPtr		sli;
unsigned			changed_maps;

    bzero((char *)&ed,sizeof(xkbExtensionDeviceNotify));
    ed.deviceID= dev->id;
    if ((dev->button)&&(dev->button->xkb_acts)) {
	_UpdateButtonVMods(xkb,dev->button->numButtons,
					dev->button->xkb_acts,changed,&ed);
    }
    if (dev->kbdfeed) {
	KbdFeedbackPtr	kf;
	for (kf=dev->kbdfeed;kf!=NULL;kf=kf->next) {
	    if ((kf->xkb_sli==NULL)||(kf->xkb_sli->maps==NULL))
		continue;
	    sli= kf->xkb_sli;
	    _UpdateMapVMods(xkb,sli->maps,changed,&changed_maps);
	    if (changed_maps) {
		if (ed.reason&XkbXI_IndicatorsMask) {
		    XkbSendExtensionDeviceNotify(dev,NULL,&ed);
		    ed.reason= 0;
		    ed.firstBtn= ed.nBtns;
		}
		ed.ledClass= 	sli->class;
		ed.ledID=	sli->id;
		ed.ledsDefined= sli->namesPresent|sli->mapsPresent;
		ed.reason|= 	XkbXI_IndicatorMapsMask;
		XkbUpdateLedAutoState(dev,sli,changed_maps,&ed,NULL,cause);
	    }
	}
    }
    if (dev->leds) {
	LedFeedbackPtr	lf;
	for (lf=dev->leds;lf!=NULL;lf=lf->next) {
	    if ((lf->xkb_sli==NULL)||(lf->xkb_sli->maps==NULL))
		continue;
	    sli= lf->xkb_sli;
	    _UpdateMapVMods(xkb,sli->maps,changed,&changed_maps);
	    if (changed_maps) {
		if (ed.reason&XkbXI_IndicatorsMask) {
		    XkbSendExtensionDeviceNotify(dev,NULL,&ed);
		    ed.reason= 0;
		    ed.firstBtn= ed.nBtns;
		}
		ed.ledClass= 	sli->class;
		ed.ledID=	sli->id;
		ed.ledsDefined= sli->namesPresent|sli->mapsPresent;
		ed.reason|= 	XkbXI_IndicatorMapsMask;
		XkbUpdateLedAutoState(dev,sli,changed_maps,&ed,NULL,cause);
	    }
	}
    }
    if (ed.reason!=0)
	XkbSendExtensionDeviceNotify(dev,NULL,&ed);
    return;
}

void
XkbApplyVModChangesToAllDevices(	DeviceIntPtr		dev,
					XkbDescPtr 		xkb,
					unsigned 		changed,
					XkbEventCausePtr	cause)
{
DeviceIntPtr			edev;
    if (dev!=(DeviceIntPtr)LookupKeyboardDevice())
	return;
    for (edev=inputInfo.devices;edev!=NULL;edev=edev->next) {
	if (edev->key)
	    continue;
	_UpdateDeviceVMods(edev,xkb,changed,cause);
    }
    for (edev=inputInfo.off_devices;edev!=NULL;edev=edev->next) {
	if (edev->key)
	    continue;
	_UpdateDeviceVMods(edev,xkb,changed,cause);
    }
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d41 1
a41 1
#include <xkbsrv.h>
d85 1
a85 1
	 *XkbApplyLEDChangeToKeyboard(xkbi,map,on,change)
d94 1
a94 1
static Bool
a168 158
	
	/*
	 * Bool
	 * ComputeAutoState(map,state,ctrls)
	 *
	 * This function reports the effect of applying the specified
	 * indicator map given the specified state and controls, as
	 * described in section 9.2 of the XKB protocol specification.
	 */

static Bool
ComputeAutoState(	XkbIndicatorMapPtr	map,
			XkbStatePtr 		state,
			XkbControlsPtr 		ctrls)
{
Bool 			on;
CARD8 			mods,group;

    on= False;
    mods= group= 0;
    if (map->which_mods&XkbIM_UseAnyMods) {
	if (map->which_mods&XkbIM_UseBase)
	    mods|= state->base_mods;
	if (map->which_mods&XkbIM_UseLatched)
	    mods|= state->latched_mods;
	if (map->which_mods&XkbIM_UseLocked)
	    mods|= state->locked_mods;
	if (map->which_mods&XkbIM_UseEffective)
	    mods|= state->mods;
	if (map->which_mods&XkbIM_UseCompat)
	    mods|= state->compat_state;
	on = ((map->mods.mask&mods)!=0);
	on = on||((mods==0)&&(map->mods.mask==0)&&(map->mods.vmods==0));
    }
    if (map->which_groups&XkbIM_UseAnyGroup) {
	if (map->which_groups&XkbIM_UseBase)
	    group|= (1L << state->base_group);
	if (map->which_groups&XkbIM_UseLatched)
	    group|= (1L << state->latched_group);
	if (map->which_groups&XkbIM_UseLocked)
	    group|= (1L << state->locked_group);
	if (map->which_groups&XkbIM_UseEffective)
	    group|= (1L << state->group);
	on = on||(((map->groups&group)!=0)||(map->groups==0));
    }
    if (map->ctrls)
	on = on||(ctrls->enabled_ctrls&map->ctrls);
    return on;
}


static void
XkbUpdateLedAutoState(	DeviceIntPtr			dev,
			XkbSrvLedInfoPtr		sli,
			unsigned			maps_to_check,
			xkbExtensionDeviceNotify *	ed,
			XkbChangesPtr			changes,
			XkbEventCausePtr		cause)
{
DeviceIntPtr			kbd;
XkbStatePtr			state;
XkbControlsPtr			ctrls;
XkbChangesRec			my_changes;
xkbExtensionDeviceNotify	my_ed;
register unsigned		i,bit,affected;
register XkbIndicatorMapPtr	map;
unsigned			oldState;

    if ((maps_to_check==0)||(sli->maps==NULL)||(sli->mapsPresent==0))
	return;

    if (dev->key && dev->key->xkbInfo)
	 kbd= dev;
    else kbd= (DeviceIntPtr)LookupKeyboardDevice();

    state= &kbd->key->xkbInfo->state;
    ctrls= kbd->key->xkbInfo->desc->ctrls;
    affected= maps_to_check;
    oldState= sli->effectiveState;
    sli->autoState&= ~affected;
    for (i=0,bit=1;(i<XkbNumIndicators)&&(affected);i++,bit<<=1) {
	if ((affected&bit)==0)
	    continue;
	affected&= ~bit;
	map= &sli->maps[i];
	if((!(map->flags&XkbIM_NoAutomatic))&&ComputeAutoState(map,state,ctrls))
	    sli->autoState|= bit;
    }
    sli->effectiveState= (sli->autoState|sli->explicitState);
    affected= sli->effectiveState^oldState;
    if (affected==0)
	return;

    if (ed==NULL) {
	ed= &my_ed;
	bzero((char *)ed,sizeof(xkbExtensionDeviceNotify));
    }
    else if ((ed->reason&XkbXI_IndicatorsMask)&&
	     ((ed->ledClass!=sli->class)||(ed->ledID!=sli->id))) {
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    }

    if ((kbd==dev)&&(sli->flags&XkbSLI_IsDefault)) {
	if (changes==NULL) {
	    changes= &my_changes;
	    bzero((char *)changes,sizeof(XkbChangesRec));
	}
	changes->indicators.state_changes|= affected;
    }

    ed->reason|=	XkbXI_IndicatorStateMask;
    ed->ledClass= 	sli->class;
    ed->ledID=		sli->id;
    ed->ledsDefined=	sli->namesPresent|sli->mapsPresent;
    ed->ledState=	sli->effectiveState;
    ed->unsupported|=	XkbXI_IndicatorStateMask;
    ed->supported=	XkbXI_AllFeaturesMask;

    if (changes!=&my_changes)	changes= NULL;
    if (ed!=&my_ed)		ed= NULL;
    if (changes || ed)
	XkbFlushLedEvents(dev,kbd,sli,ed,changes,cause);
    return;
}

static void
XkbUpdateAllDeviceIndicators(XkbChangesPtr changes,XkbEventCausePtr cause)
{
DeviceIntPtr		edev;
XkbSrvLedInfoPtr	sli;

    for (edev=inputInfo.devices;edev!=NULL;edev=edev->next) {
	if (edev->kbdfeed) {
	    KbdFeedbackPtr	kf;
	    for (kf=edev->kbdfeed;kf!=NULL;kf=kf->next) {
		if ((kf->xkb_sli==NULL)||(kf->xkb_sli->maps==NULL))
		    continue;
		sli= kf->xkb_sli;
		XkbUpdateLedAutoState(edev,sli,sli->mapsPresent,NULL,
								changes,cause);
			
	    }
	}
	if (edev->leds) {
	    LedFeedbackPtr	lf;
	    for (lf=edev->leds;lf!=NULL;lf=lf->next) {
		if ((lf->xkb_sli==NULL)||(lf->xkb_sli->maps==NULL))
		    continue;
		sli= lf->xkb_sli;
		XkbUpdateLedAutoState(edev,sli,sli->mapsPresent,NULL,
								changes,cause);
			
	    }
	}
    }
    return;
}

d231 49
d317 33
d678 1
a678 1
    ed->reason|=	XkbXI_IndicatorNamesMask;
d683 2
a684 2
    ed->unsupported=	0;
    ed->supported=	XkbXI_AllFeaturesMask;
d756 1
a756 1
    ed->reason|=	XkbXI_IndicatorMapsMask;
d761 2
a762 2
    ed->unsupported|=	XkbXI_IndicatorMapsMask;
    ed->supported=	XkbXI_AllFeaturesMask;
d837 1
a837 1
	ed->reason|=		XkbXI_IndicatorStateMask;
d842 2
a843 2
	ed->unsupported|=	XkbXI_IndicatorStateMask;
	ed->supported=		XkbXI_AllFeaturesMask;
d857 207
@

