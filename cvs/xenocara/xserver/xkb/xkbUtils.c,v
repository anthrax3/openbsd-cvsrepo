head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2013.06.07.17.28.56;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.32;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.11;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.26;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.29;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/
/*

Copyright Â© 2008 Red Hat Inc.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "os.h"
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#define	XK_CYRILLIC
#include <X11/keysym.h>
#include "misc.h"
#include "inputstr.h"
#include "eventstr.h"

#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include "xkbgeom.h"
#include "xkb.h"

/***====================================================================***/

int
_XkbLookupAnyDevice(DeviceIntPtr *pDev, int id, ClientPtr client,
                    Mask access_mode, int *xkb_err)
{
    int rc = XkbKeyboardErrorCode;

    if (id == XkbUseCoreKbd)
        id = PickKeyboard(client)->id;
    else if (id == XkbUseCorePtr)
        id = PickPointer(client)->id;

    rc = dixLookupDevice(pDev, id, client, access_mode);
    if (rc != Success)
        *xkb_err = XkbErr_BadDevice;

    return rc;
}

int
_XkbLookupKeyboard(DeviceIntPtr *pDev, int id, ClientPtr client,
                   Mask access_mode, int *xkb_err)
{
    DeviceIntPtr dev;
    int rc;

    if (id == XkbDfltXIId)
        id = XkbUseCoreKbd;

    rc = _XkbLookupAnyDevice(pDev, id, client, access_mode, xkb_err);
    if (rc != Success)
        return rc;

    dev = *pDev;
    if (!dev->key || !dev->key->xkbInfo) {
        *pDev = NULL;
        *xkb_err = XkbErr_BadClass;
        return XkbKeyboardErrorCode;
    }
    return Success;
}

int
_XkbLookupBellDevice(DeviceIntPtr *pDev, int id, ClientPtr client,
                     Mask access_mode, int *xkb_err)
{
    DeviceIntPtr dev;
    int rc;

    rc = _XkbLookupAnyDevice(pDev, id, client, access_mode, xkb_err);
    if (rc != Success)
        return rc;

    dev = *pDev;
    if (!dev->kbdfeed && !dev->bell) {
        *pDev = NULL;
        *xkb_err = XkbErr_BadClass;
        return XkbKeyboardErrorCode;
    }
    return Success;
}

int
_XkbLookupLedDevice(DeviceIntPtr *pDev, int id, ClientPtr client,
                    Mask access_mode, int *xkb_err)
{
    DeviceIntPtr dev;
    int rc;

    if (id == XkbDfltXIId)
        id = XkbUseCorePtr;

    rc = _XkbLookupAnyDevice(pDev, id, client, access_mode, xkb_err);
    if (rc != Success)
        return rc;

    dev = *pDev;
    if (!dev->kbdfeed && !dev->leds) {
        *pDev = NULL;
        *xkb_err = XkbErr_BadClass;
        return XkbKeyboardErrorCode;
    }
    return Success;
}

int
_XkbLookupButtonDevice(DeviceIntPtr *pDev, int id, ClientPtr client,
                       Mask access_mode, int *xkb_err)
{
    DeviceIntPtr dev;
    int rc;

    rc = _XkbLookupAnyDevice(pDev, id, client, access_mode, xkb_err);
    if (rc != Success)
        return rc;

    dev = *pDev;
    if (!dev->button) {
        *pDev = NULL;
        *xkb_err = XkbErr_BadClass;
        return XkbKeyboardErrorCode;
    }
    return Success;
}

void
XkbSetActionKeyMods(XkbDescPtr xkb, XkbAction *act, unsigned mods)
{
    register unsigned tmp;

    switch (act->type) {
    case XkbSA_SetMods:
    case XkbSA_LatchMods:
    case XkbSA_LockMods:
        if (act->mods.flags & XkbSA_UseModMapMods)
            act->mods.real_mods = act->mods.mask = mods;
        if ((tmp = XkbModActionVMods(&act->mods)) != 0)
            act->mods.mask |= XkbMaskForVMask(xkb, tmp);
        break;
    case XkbSA_ISOLock:
        if (act->iso.flags & XkbSA_UseModMapMods)
            act->iso.real_mods = act->iso.mask = mods;
        if ((tmp = XkbModActionVMods(&act->iso)) != 0)
            act->iso.mask |= XkbMaskForVMask(xkb, tmp);
        break;
    }
    return;
}

unsigned
XkbMaskForVMask(XkbDescPtr xkb, unsigned vmask)
{
    register int i, bit;
    register unsigned mask;

    for (mask = i = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) {
        if (vmask & bit)
            mask |= xkb->server->vmods[i];
    }
    return mask;
}

/***====================================================================***/

void
XkbUpdateKeyTypesFromCore(DeviceIntPtr pXDev,
                          KeySymsPtr pCore,
                          KeyCode first, CARD8 num, XkbChangesPtr changes)
{
    XkbDescPtr xkb;
    unsigned key, nG, explicit;
    int types[XkbNumKbdGroups];
    KeySym tsyms[XkbMaxSymsPerKey], *syms;
    XkbMapChangesPtr mc;

    xkb = pXDev->key->xkbInfo->desc;
    if (first + num - 1 > xkb->max_key_code) {
        /* 1/12/95 (ef) -- XXX! should allow XKB structures to grow */
        num = xkb->max_key_code - first + 1;
    }

    mc = (changes ? (&changes->map) : NULL);

    syms = &pCore->map[(first - pCore->minKeyCode) * pCore->mapWidth];
    for (key = first; key < (first + num); key++, syms += pCore->mapWidth) {
        explicit = xkb->server->explicit[key] & XkbExplicitKeyTypesMask;
        types[XkbGroup1Index] = XkbKeyKeyTypeIndex(xkb, key, XkbGroup1Index);
        types[XkbGroup2Index] = XkbKeyKeyTypeIndex(xkb, key, XkbGroup2Index);
        types[XkbGroup3Index] = XkbKeyKeyTypeIndex(xkb, key, XkbGroup3Index);
        types[XkbGroup4Index] = XkbKeyKeyTypeIndex(xkb, key, XkbGroup4Index);
        nG = XkbKeyTypesForCoreSymbols(xkb, pCore->mapWidth, syms, explicit,
                                       types, tsyms);
        XkbChangeTypesOfKey(xkb, key, nG, XkbAllGroupsMask, types, mc);
        memcpy((char *) XkbKeySymsPtr(xkb, key), (char *) tsyms,
               XkbKeyNumSyms(xkb, key) * sizeof(KeySym));
    }
    if (changes->map.changed & XkbKeySymsMask) {
        CARD8 oldLast, newLast;

        oldLast = changes->map.first_key_sym + changes->map.num_key_syms - 1;
        newLast = first + num - 1;

        if (first < changes->map.first_key_sym)
            changes->map.first_key_sym = first;
        if (oldLast > newLast)
            newLast = oldLast;
        changes->map.num_key_syms = newLast - changes->map.first_key_sym + 1;
    }
    else {
        changes->map.changed |= XkbKeySymsMask;
        changes->map.first_key_sym = first;
        changes->map.num_key_syms = num;
    }
    return;
}

void
XkbUpdateDescActions(XkbDescPtr xkb,
                     KeyCode first, CARD8 num, XkbChangesPtr changes)
{
    register unsigned key;

    for (key = first; key < (first + num); key++) {
        XkbApplyCompatMapToKey(xkb, key, changes);
    }

    if (changes->map.changed & (XkbVirtualModMapMask | XkbModifierMapMask)) {
        unsigned char newVMods[XkbNumVirtualMods];
        register unsigned bit, i;
        unsigned present;

        memset(newVMods, 0, XkbNumVirtualMods);
        present = 0;
        for (key = xkb->min_key_code; key <= xkb->max_key_code; key++) {
            if (xkb->server->vmodmap[key] == 0)
                continue;
            for (i = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) {
                if (bit & xkb->server->vmodmap[key]) {
                    present |= bit;
                    newVMods[i] |= xkb->map->modmap[key];
                }
            }
        }
        for (i = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) {
            if ((bit & present) && (newVMods[i] != xkb->server->vmods[i])) {
                changes->map.changed |= XkbVirtualModsMask;
                changes->map.vmods |= bit;
                xkb->server->vmods[i] = newVMods[i];
            }
        }
    }
    if (changes->map.changed & XkbVirtualModsMask)
        XkbApplyVirtualModChanges(xkb, changes->map.vmods, changes);

    if (changes->map.changed & XkbKeyActionsMask) {
        CARD8 oldLast, newLast;

        oldLast = changes->map.first_key_act + changes->map.num_key_acts - 1;
        newLast = first + num - 1;

        if (first < changes->map.first_key_act)
            changes->map.first_key_act = first;
        if (newLast > oldLast)
            newLast = oldLast;
        changes->map.num_key_acts = newLast - changes->map.first_key_act + 1;
    }
    else {
        changes->map.changed |= XkbKeyActionsMask;
        changes->map.first_key_act = first;
        changes->map.num_key_acts = num;
    }
    return;
}

void
XkbUpdateActions(DeviceIntPtr pXDev,
                 KeyCode first,
                 CARD8 num,
                 XkbChangesPtr changes,
                 unsigned *needChecksRtrn, XkbEventCausePtr cause)
{
    XkbSrvInfoPtr xkbi;
    XkbDescPtr xkb;
    CARD8 *repeat;

    if (needChecksRtrn)
        *needChecksRtrn = 0;
    xkbi = pXDev->key->xkbInfo;
    xkb = xkbi->desc;
    repeat = xkb->ctrls->per_key_repeat;

    /* before letting XKB do any changes, copy the current core values */
    if (pXDev->kbdfeed)
        memcpy(repeat, pXDev->kbdfeed->ctrl.autoRepeats, XkbPerKeyBitArraySize);

    XkbUpdateDescActions(xkb, first, num, changes);

    if ((pXDev->kbdfeed) &&
        (changes->ctrls.changed_ctrls & XkbPerKeyRepeatMask)) {
        /* now copy the modified changes back to core */
        memcpy(pXDev->kbdfeed->ctrl.autoRepeats, repeat, XkbPerKeyBitArraySize);
        if (pXDev->kbdfeed->CtrlProc)
            (*pXDev->kbdfeed->CtrlProc) (pXDev, &pXDev->kbdfeed->ctrl);
    }
    return;
}

KeySymsPtr
XkbGetCoreMap(DeviceIntPtr keybd)
{
    register int key, tmp;
    int maxSymsPerKey, maxGroup1Width;
    XkbDescPtr xkb;
    KeySymsPtr syms;
    int maxNumberOfGroups;

    if (!keybd || !keybd->key || !keybd->key->xkbInfo)
        return NULL;

    xkb = keybd->key->xkbInfo->desc;
    maxSymsPerKey = maxGroup1Width = 0;
    maxNumberOfGroups = 0;

    /* determine sizes */
    for (key = xkb->min_key_code; key <= xkb->max_key_code; key++) {
        if (XkbKeycodeInRange(xkb, key)) {
            int nGroups;
            int w;

            nGroups = XkbKeyNumGroups(xkb, key);
            tmp = 0;
            if (nGroups > 0) {
                if ((w = XkbKeyGroupWidth(xkb, key, XkbGroup1Index)) <= 2)
                    tmp += 2;
                else
                    tmp += w + 2;
                /* remember highest G1 width */
                if (w > maxGroup1Width)
                    maxGroup1Width = w;
            }
            if (nGroups > 1) {
                if (tmp <= 2) {
                    if ((w = XkbKeyGroupWidth(xkb, key, XkbGroup2Index)) < 2)
                        tmp += 2;
                    else
                        tmp += w;
                }
                else {
                    if ((w = XkbKeyGroupWidth(xkb, key, XkbGroup2Index)) > 2)
                        tmp += w - 2;
                }
            }
            if (nGroups > 2)
                tmp += XkbKeyGroupWidth(xkb, key, XkbGroup3Index);
            if (nGroups > 3)
                tmp += XkbKeyGroupWidth(xkb, key, XkbGroup4Index);
            if (tmp > maxSymsPerKey)
                maxSymsPerKey = tmp;
            if (nGroups > maxNumberOfGroups)
                maxNumberOfGroups = nGroups;
        }
    }

    if (maxSymsPerKey <= 0)
        return NULL;

    syms = calloc(1, sizeof(*syms));
    if (!syms)
        return NULL;

    /* See Section 12.4 of the XKB Protocol spec. Because of the
     * single-group distribution for multi-group keyboards, we have to
     * have enough symbols for the largest group 1 to replicate across the
     * number of groups on the keyboard. e.g. a single-group key with 4
     * symbols on a keyboard that has 3 groups -> 12 syms per key */
    if (maxSymsPerKey < maxNumberOfGroups * maxGroup1Width)
        maxSymsPerKey = maxNumberOfGroups * maxGroup1Width;

    syms->mapWidth = maxSymsPerKey;
    syms->minKeyCode = xkb->min_key_code;
    syms->maxKeyCode = xkb->max_key_code;

    tmp = syms->mapWidth * (xkb->max_key_code - xkb->min_key_code + 1);
    syms->map = calloc(tmp, sizeof(*syms->map));
    if (!syms->map) {
        free(syms);
        return NULL;
    }

    for (key = xkb->min_key_code; key <= xkb->max_key_code; key++) {
        KeySym *pCore, *pXKB;
        unsigned nGroups, groupWidth, n, nOut;

        nGroups = XkbKeyNumGroups(xkb, key);
        n = (key - xkb->min_key_code) * syms->mapWidth;
        pCore = &syms->map[n];
        pXKB = XkbKeySymsPtr(xkb, key);
        nOut = 2;
        if (nGroups > 0) {
            groupWidth = XkbKeyGroupWidth(xkb, key, XkbGroup1Index);
            if (groupWidth > 0)
                pCore[0] = pXKB[0];
            if (groupWidth > 1)
                pCore[1] = pXKB[1];
            for (n = 2; n < groupWidth; n++)
                pCore[2 + n] = pXKB[n];
            if (groupWidth > 2)
                nOut = groupWidth;
        }

        /* See XKB Protocol Sec, Section 12.4.
           A 1-group key with ABCDE on a 2 group keyboard must be
           duplicated across all groups as ABABCDECDE.
         */
        if (nGroups == 1) {
            int idx, j;

            groupWidth = XkbKeyGroupWidth(xkb, key, XkbGroup1Index);

            /* AB..CDE... -> ABABCDE... */
            if (groupWidth > 0 && syms->mapWidth >= 3)
                pCore[2] = pCore[0];
            if (groupWidth > 1 && syms->mapWidth >= 4)
                pCore[3] = pCore[1];

            /* ABABCDE... -> ABABCDECDE */
            idx = 2 + groupWidth;
            while (groupWidth > 2 && idx < syms->mapWidth &&
                   idx < groupWidth * 2) {
                pCore[idx] = pCore[idx - groupWidth + 2];
                idx++;
            }
            idx = 2 * groupWidth;
            if (idx < 4)
                idx = 4;
            /* 3 or more groups: ABABCDECDEABCDEABCDE */
            for (j = 3; j <= maxNumberOfGroups; j++)
                for (n = 0; n < groupWidth && idx < maxSymsPerKey; n++)
                    pCore[idx++] = pXKB[n];
        }

        pXKB += XkbKeyGroupsWidth(xkb, key);
        nOut += 2;
        if (nGroups > 1) {
            groupWidth = XkbKeyGroupWidth(xkb, key, XkbGroup2Index);
            if (groupWidth > 0)
                pCore[2] = pXKB[0];
            if (groupWidth > 1)
                pCore[3] = pXKB[1];
            for (n = 2; n < groupWidth; n++) {
                pCore[nOut + (n - 2)] = pXKB[n];
            }
            if (groupWidth > 2)
                nOut += (groupWidth - 2);
        }
        pXKB += XkbKeyGroupsWidth(xkb, key);
        for (n = XkbGroup3Index; n < nGroups; n++) {
            register int s;

            groupWidth = XkbKeyGroupWidth(xkb, key, n);
            for (s = 0; s < groupWidth; s++) {
                pCore[nOut++] = pXKB[s];
            }
            pXKB += XkbKeyGroupsWidth(xkb, key);
        }
    }

    return syms;
}

void
XkbSetRepeatKeys(DeviceIntPtr pXDev, int key, int onoff)
{
    if (pXDev && pXDev->key && pXDev->key->xkbInfo) {
        xkbControlsNotify cn;
        XkbControlsPtr ctrls = pXDev->key->xkbInfo->desc->ctrls;
        XkbControlsRec old;

        old = *ctrls;

        if (key == -1) {        /* global autorepeat setting changed */
            if (onoff)
                ctrls->enabled_ctrls |= XkbRepeatKeysMask;
            else
                ctrls->enabled_ctrls &= ~XkbRepeatKeysMask;
        }
        else if (pXDev->kbdfeed) {
            ctrls->per_key_repeat[key / 8] =
                pXDev->kbdfeed->ctrl.autoRepeats[key / 8];
        }

        if (XkbComputeControlsNotify(pXDev, &old, ctrls, &cn, TRUE))
            XkbSendControlsNotify(pXDev, &cn);
    }
    return;
}

/* Applies a change to a single device, does not traverse the device tree. */
void
XkbApplyMappingChange(DeviceIntPtr kbd, KeySymsPtr map, KeyCode first_key,
                      CARD8 num_keys, CARD8 *modmap, ClientPtr client)
{
    XkbDescPtr xkb = kbd->key->xkbInfo->desc;
    XkbEventCauseRec cause;
    XkbChangesRec changes;
    unsigned int check;

    memset(&changes, 0, sizeof(changes));
    memset(&cause, 0, sizeof(cause));

    if (map && first_key && num_keys) {
        check = 0;
        XkbSetCauseCoreReq(&cause, X_ChangeKeyboardMapping, client);

        XkbUpdateKeyTypesFromCore(kbd, map, first_key, num_keys, &changes);
        XkbUpdateActions(kbd, first_key, num_keys, &changes, &check, &cause);

        if (check)
            XkbCheckSecondaryEffects(kbd->key->xkbInfo, 1, &changes, &cause);
    }

    if (modmap) {
        /* A keymap change can imply a modmap change, se we prefer the
         * former. */
        if (!cause.mjr)
            XkbSetCauseCoreReq(&cause, X_SetModifierMapping, client);

        check = 0;
        num_keys = xkb->max_key_code - xkb->min_key_code + 1;
        changes.map.changed |= XkbModifierMapMask;
        changes.map.first_modmap_key = xkb->min_key_code;
        changes.map.num_modmap_keys = num_keys;
        memcpy(kbd->key->xkbInfo->desc->map->modmap, modmap, MAP_LENGTH);
        XkbUpdateActions(kbd, xkb->min_key_code, num_keys, &changes, &check,
                         &cause);

        if (check)
            XkbCheckSecondaryEffects(kbd->key->xkbInfo, 1, &changes, &cause);
    }

    XkbSendNotification(kbd, &changes, &cause);
}

void
XkbDisableComputedAutoRepeats(DeviceIntPtr dev, unsigned key)
{
    XkbSrvInfoPtr xkbi = dev->key->xkbInfo;
    xkbMapNotify mn;

    xkbi->desc->server->explicit[key] |= XkbExplicitAutoRepeatMask;
    memset(&mn, 0, sizeof(mn));
    mn.changed = XkbExplicitComponentsMask;
    mn.firstKeyExplicit = key;
    mn.nKeyExplicit = 1;
    XkbSendMapNotify(dev, &mn);
    return;
}

unsigned
XkbStateChangedFlags(XkbStatePtr old, XkbStatePtr new)
{
    int changed;

    changed = (old->group != new->group ? XkbGroupStateMask : 0);
    changed |= (old->base_group != new->base_group ? XkbGroupBaseMask : 0);
    changed |=
        (old->latched_group != new->latched_group ? XkbGroupLatchMask : 0);
    changed |= (old->locked_group != new->locked_group ? XkbGroupLockMask : 0);
    changed |= (old->mods != new->mods ? XkbModifierStateMask : 0);
    changed |= (old->base_mods != new->base_mods ? XkbModifierBaseMask : 0);
    changed |=
        (old->latched_mods != new->latched_mods ? XkbModifierLatchMask : 0);
    changed |= (old->locked_mods != new->locked_mods ? XkbModifierLockMask : 0);
    changed |=
        (old->compat_state != new->compat_state ? XkbCompatStateMask : 0);
    changed |= (old->grab_mods != new->grab_mods ? XkbGrabModsMask : 0);
    if (old->compat_grab_mods != new->compat_grab_mods)
        changed |= XkbCompatGrabModsMask;
    changed |= (old->lookup_mods != new->lookup_mods ? XkbLookupModsMask : 0);
    if (old->compat_lookup_mods != new->compat_lookup_mods)
        changed |= XkbCompatLookupModsMask;
    changed |=
        (old->ptr_buttons != new->ptr_buttons ? XkbPointerButtonMask : 0);
    return changed;
}

static void
XkbComputeCompatState(XkbSrvInfoPtr xkbi)
{
    CARD16 grp_mask;
    XkbStatePtr state = &xkbi->state;
    XkbCompatMapPtr map;
    XkbControlsPtr ctrls;

    if (!state || !xkbi->desc || !xkbi->desc->ctrls || !xkbi->desc->compat)
        return;

    map = xkbi->desc->compat;
    grp_mask = map->groups[state->group].mask;
    state->compat_state = state->mods | grp_mask;
    state->compat_lookup_mods = state->lookup_mods | grp_mask;
    ctrls= xkbi->desc->ctrls;

    if (ctrls->enabled_ctrls & XkbIgnoreGroupLockMask) {
	unsigned char grp = state->base_group+state->latched_group;
	if (grp >= ctrls->num_groups)
	    grp = XkbAdjustGroup(XkbCharToInt(grp), ctrls);
        grp_mask = map->groups[grp].mask;
    }
    state->compat_grab_mods = state->grab_mods | grp_mask;
    return;
}

unsigned
XkbAdjustGroup(int group, XkbControlsPtr ctrls)
{
    unsigned act;

    act = XkbOutOfRangeGroupAction(ctrls->groups_wrap);
    if (group < 0) {
        while (group < 0) {
            if (act == XkbClampIntoRange) {
                group = XkbGroup1Index;
            }
            else if (act == XkbRedirectIntoRange) {
                int newGroup;

                newGroup = XkbOutOfRangeGroupNumber(ctrls->groups_wrap);
                if (newGroup >= ctrls->num_groups)
                    group = XkbGroup1Index;
                else
                    group = newGroup;
            }
            else {
                group += ctrls->num_groups;
            }
        }
    }
    else if (group >= ctrls->num_groups) {
        if (act == XkbClampIntoRange) {
            group = ctrls->num_groups - 1;
        }
        else if (act == XkbRedirectIntoRange) {
            int newGroup;

            newGroup = XkbOutOfRangeGroupNumber(ctrls->groups_wrap);
            if (newGroup >= ctrls->num_groups)
                group = XkbGroup1Index;
            else
                group = newGroup;
        }
        else {
            group %= ctrls->num_groups;
        }
    }
    return group;
}

void
XkbComputeDerivedState(XkbSrvInfoPtr xkbi)
{
    XkbStatePtr state = &xkbi->state;
    XkbControlsPtr ctrls = xkbi->desc->ctrls;
    unsigned char grp;

    if (!state || !ctrls)
        return;

    state->mods = (state->base_mods | state->latched_mods | state->locked_mods);
    state->lookup_mods = state->mods & (~ctrls->internal.mask);
    state->grab_mods = state->lookup_mods & (~ctrls->ignore_lock.mask);
    state->grab_mods |=
        ((state->base_mods | state->latched_mods) & ctrls->ignore_lock.mask);

    grp = state->locked_group;
    if (grp >= ctrls->num_groups)
        state->locked_group = XkbAdjustGroup(XkbCharToInt(grp), ctrls);

    grp = state->locked_group + state->base_group + state->latched_group;
    if (grp >= ctrls->num_groups)
        state->group = XkbAdjustGroup(XkbCharToInt(grp), ctrls);
    else
        state->group = grp;
    XkbComputeCompatState(xkbi);
    return;
}

/***====================================================================***/

void
XkbCheckSecondaryEffects(XkbSrvInfoPtr xkbi,
                         unsigned which,
                         XkbChangesPtr changes, XkbEventCausePtr cause)
{
    if (which & XkbStateNotifyMask) {
        XkbStateRec old;

        old = xkbi->state;
        changes->state_changes |= XkbStateChangedFlags(&old, &xkbi->state);
        XkbComputeDerivedState(xkbi);
    }
    if (which & XkbIndicatorStateNotifyMask)
        XkbUpdateIndicators(xkbi->device, XkbAllIndicatorsMask, TRUE, changes,
                            cause);
    return;
}

/***====================================================================***/

Bool
XkbEnableDisableControls(XkbSrvInfoPtr xkbi,
                         unsigned long change,
                         unsigned long newValues,
                         XkbChangesPtr changes, XkbEventCausePtr cause)
{
    XkbControlsPtr ctrls;
    unsigned old;
    XkbSrvLedInfoPtr sli;

    ctrls = xkbi->desc->ctrls;
    old = ctrls->enabled_ctrls;
    ctrls->enabled_ctrls &= ~change;
    ctrls->enabled_ctrls |= (change & newValues);
    if (old == ctrls->enabled_ctrls)
        return FALSE;
    if (cause != NULL) {
        xkbControlsNotify cn;

        cn.numGroups = ctrls->num_groups;
        cn.changedControls = XkbControlsEnabledMask;
        cn.enabledControls = ctrls->enabled_ctrls;
        cn.enabledControlChanges = (ctrls->enabled_ctrls ^ old);
        cn.keycode = cause->kc;
        cn.eventType = cause->event;
        cn.requestMajor = cause->mjr;
        cn.requestMinor = cause->mnr;
        XkbSendControlsNotify(xkbi->device, &cn);
    }
    else {
        /* Yes, this really should be an XOR.  If ctrls->enabled_ctrls_changes */
        /* is non-zero, the controls in question changed already in "this" */
        /* request and this change merely undoes the previous one.  By the */
        /* same token, we have to figure out whether or not ControlsEnabled */
        /* should be set or not in the changes structure */
        changes->ctrls.enabled_ctrls_changes ^= (ctrls->enabled_ctrls ^ old);
        if (changes->ctrls.enabled_ctrls_changes)
            changes->ctrls.changed_ctrls |= XkbControlsEnabledMask;
        else
            changes->ctrls.changed_ctrls &= ~XkbControlsEnabledMask;
    }
    sli = XkbFindSrvLedInfo(xkbi->device, XkbDfltXIClass, XkbDfltXIId, 0);
    XkbUpdateIndicators(xkbi->device, sli->usesControls, TRUE, changes, cause);
    return TRUE;
}

/***====================================================================***/

#define	MAX_TOC	16

XkbGeometryPtr
XkbLookupNamedGeometry(DeviceIntPtr dev, Atom name, Bool *shouldFree)
{
    XkbSrvInfoPtr xkbi = dev->key->xkbInfo;
    XkbDescPtr xkb = xkbi->desc;

    *shouldFree = 0;
    if (name == None) {
        if (xkb->geom != NULL)
            return xkb->geom;
        name = xkb->names->geometry;
    }
    if ((xkb->geom != NULL) && (xkb->geom->name == name))
        return xkb->geom;
    *shouldFree = 1;
    return NULL;
}

void
XkbConvertCase(register KeySym sym, KeySym * lower, KeySym * upper)
{
    *lower = sym;
    *upper = sym;
    switch (sym >> 8) {
    case 0:                    /* Latin 1 */
        if ((sym >= XK_A) && (sym <= XK_Z))
            *lower += (XK_a - XK_A);
        else if ((sym >= XK_a) && (sym <= XK_z))
            *upper -= (XK_a - XK_A);
        else if ((sym >= XK_Agrave) && (sym <= XK_Odiaeresis))
            *lower += (XK_agrave - XK_Agrave);
        else if ((sym >= XK_agrave) && (sym <= XK_odiaeresis))
            *upper -= (XK_agrave - XK_Agrave);
        else if ((sym >= XK_Ooblique) && (sym <= XK_Thorn))
            *lower += (XK_oslash - XK_Ooblique);
        else if ((sym >= XK_oslash) && (sym <= XK_thorn))
            *upper -= (XK_oslash - XK_Ooblique);
        break;
    case 1:                    /* Latin 2 */
        /* Assume the KeySym is a legal value (ignore discontinuities) */
        if (sym == XK_Aogonek)
            *lower = XK_aogonek;
        else if (sym >= XK_Lstroke && sym <= XK_Sacute)
            *lower += (XK_lstroke - XK_Lstroke);
        else if (sym >= XK_Scaron && sym <= XK_Zacute)
            *lower += (XK_scaron - XK_Scaron);
        else if (sym >= XK_Zcaron && sym <= XK_Zabovedot)
            *lower += (XK_zcaron - XK_Zcaron);
        else if (sym == XK_aogonek)
            *upper = XK_Aogonek;
        else if (sym >= XK_lstroke && sym <= XK_sacute)
            *upper -= (XK_lstroke - XK_Lstroke);
        else if (sym >= XK_scaron && sym <= XK_zacute)
            *upper -= (XK_scaron - XK_Scaron);
        else if (sym >= XK_zcaron && sym <= XK_zabovedot)
            *upper -= (XK_zcaron - XK_Zcaron);
        else if (sym >= XK_Racute && sym <= XK_Tcedilla)
            *lower += (XK_racute - XK_Racute);
        else if (sym >= XK_racute && sym <= XK_tcedilla)
            *upper -= (XK_racute - XK_Racute);
        break;
    case 2:                    /* Latin 3 */
        /* Assume the KeySym is a legal value (ignore discontinuities) */
        if (sym >= XK_Hstroke && sym <= XK_Hcircumflex)
            *lower += (XK_hstroke - XK_Hstroke);
        else if (sym >= XK_Gbreve && sym <= XK_Jcircumflex)
            *lower += (XK_gbreve - XK_Gbreve);
        else if (sym >= XK_hstroke && sym <= XK_hcircumflex)
            *upper -= (XK_hstroke - XK_Hstroke);
        else if (sym >= XK_gbreve && sym <= XK_jcircumflex)
            *upper -= (XK_gbreve - XK_Gbreve);
        else if (sym >= XK_Cabovedot && sym <= XK_Scircumflex)
            *lower += (XK_cabovedot - XK_Cabovedot);
        else if (sym >= XK_cabovedot && sym <= XK_scircumflex)
            *upper -= (XK_cabovedot - XK_Cabovedot);
        break;
    case 3:                    /* Latin 4 */
        /* Assume the KeySym is a legal value (ignore discontinuities) */
        if (sym >= XK_Rcedilla && sym <= XK_Tslash)
            *lower += (XK_rcedilla - XK_Rcedilla);
        else if (sym >= XK_rcedilla && sym <= XK_tslash)
            *upper -= (XK_rcedilla - XK_Rcedilla);
        else if (sym == XK_ENG)
            *lower = XK_eng;
        else if (sym == XK_eng)
            *upper = XK_ENG;
        else if (sym >= XK_Amacron && sym <= XK_Umacron)
            *lower += (XK_amacron - XK_Amacron);
        else if (sym >= XK_amacron && sym <= XK_umacron)
            *upper -= (XK_amacron - XK_Amacron);
        break;
    case 6:                    /* Cyrillic */
        /* Assume the KeySym is a legal value (ignore discontinuities) */
        if (sym >= XK_Serbian_DJE && sym <= XK_Serbian_DZE)
            *lower -= (XK_Serbian_DJE - XK_Serbian_dje);
        else if (sym >= XK_Serbian_dje && sym <= XK_Serbian_dze)
            *upper += (XK_Serbian_DJE - XK_Serbian_dje);
        else if (sym >= XK_Cyrillic_YU && sym <= XK_Cyrillic_HARDSIGN)
            *lower -= (XK_Cyrillic_YU - XK_Cyrillic_yu);
        else if (sym >= XK_Cyrillic_yu && sym <= XK_Cyrillic_hardsign)
            *upper += (XK_Cyrillic_YU - XK_Cyrillic_yu);
        break;
    case 7:                    /* Greek */
        /* Assume the KeySym is a legal value (ignore discontinuities) */
        if (sym >= XK_Greek_ALPHAaccent && sym <= XK_Greek_OMEGAaccent)
            *lower += (XK_Greek_alphaaccent - XK_Greek_ALPHAaccent);
        else if (sym >= XK_Greek_alphaaccent && sym <= XK_Greek_omegaaccent &&
                 sym != XK_Greek_iotaaccentdieresis &&
                 sym != XK_Greek_upsilonaccentdieresis)
            *upper -= (XK_Greek_alphaaccent - XK_Greek_ALPHAaccent);
        else if (sym >= XK_Greek_ALPHA && sym <= XK_Greek_OMEGA)
            *lower += (XK_Greek_alpha - XK_Greek_ALPHA);
        else if (sym >= XK_Greek_alpha && sym <= XK_Greek_omega &&
                 sym != XK_Greek_finalsmallsigma)
            *upper -= (XK_Greek_alpha - XK_Greek_ALPHA);
        break;
    }
}

static Bool
_XkbCopyClientMap(XkbDescPtr src, XkbDescPtr dst)
{
    void *tmp = NULL;
    int i;
    XkbKeyTypePtr stype = NULL, dtype = NULL;

    /* client map */
    if (src->map) {
        if (!dst->map) {
            tmp = calloc(1, sizeof(XkbClientMapRec));
            if (!tmp)
                return FALSE;
            dst->map = tmp;
        }

        if (src->map->syms) {
            if (src->map->size_syms != dst->map->size_syms) {
                tmp = reallocarray(dst->map->syms,
                                   src->map->size_syms, sizeof(KeySym));
                if (!tmp)
                    return FALSE;
                dst->map->syms = tmp;

            }
            memcpy(dst->map->syms, src->map->syms,
                   src->map->size_syms * sizeof(KeySym));
        }
        else {
            free(dst->map->syms);
            dst->map->syms = NULL;
        }
        dst->map->num_syms = src->map->num_syms;
        dst->map->size_syms = src->map->size_syms;

        if (src->map->key_sym_map) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = reallocarray(dst->map->key_sym_map,
                                   src->max_key_code + 1, sizeof(XkbSymMapRec));
                if (!tmp)
                    return FALSE;
                dst->map->key_sym_map = tmp;
            }
            memcpy(dst->map->key_sym_map, src->map->key_sym_map,
                   (src->max_key_code + 1) * sizeof(XkbSymMapRec));
        }
        else {
            free(dst->map->key_sym_map);
            dst->map->key_sym_map = NULL;
        }

        if (src->map->types && src->map->num_types) {
            if (src->map->num_types > dst->map->size_types ||
                !dst->map->types || !dst->map->size_types) {
                if (dst->map->types && dst->map->size_types) {
                    tmp = reallocarray(dst->map->types, src->map->num_types,
                                       sizeof(XkbKeyTypeRec));
                    if (!tmp)
                        return FALSE;
                    dst->map->types = tmp;
                    memset(dst->map->types + dst->map->num_types, 0,
                           (src->map->num_types - dst->map->num_types) *
                           sizeof(XkbKeyTypeRec));
                }
                else {
                    tmp = calloc(src->map->num_types, sizeof(XkbKeyTypeRec));
                    if (!tmp)
                        return FALSE;
                    dst->map->types = tmp;
                }
            }
            else if (src->map->num_types < dst->map->num_types &&
                     dst->map->types) {
                for (i = src->map->num_types, dtype = (dst->map->types + i);
                     i < dst->map->num_types; i++, dtype++) {
                    free(dtype->level_names);
                    dtype->level_names = NULL;
                    dtype->num_levels = 0;
                    if (dtype->map_count) {
                        free(dtype->map);
                        free(dtype->preserve);
                    }
                }
            }

            stype = src->map->types;
            dtype = dst->map->types;
            for (i = 0; i < src->map->num_types; i++, dtype++, stype++) {
                if (stype->num_levels && stype->level_names) {
                    if (stype->num_levels != dtype->num_levels &&
                        dtype->num_levels && dtype->level_names &&
                        i < dst->map->num_types) {
                        tmp = reallocarray(dtype->level_names,
                                           stype->num_levels, sizeof(Atom));
                        if (!tmp)
                            continue;
                        dtype->level_names = tmp;
                    }
                    else if (!dtype->num_levels || !dtype->level_names ||
                             i >= dst->map->num_types) {
                        tmp = malloc(stype->num_levels * sizeof(Atom));
                        if (!tmp)
                            continue;
                        dtype->level_names = tmp;
                    }
                    dtype->num_levels = stype->num_levels;
                    memcpy(dtype->level_names, stype->level_names,
                           stype->num_levels * sizeof(Atom));
                }
                else {
                    if (dtype->num_levels && dtype->level_names &&
                        i < dst->map->num_types)
                        free(dtype->level_names);
                    dtype->num_levels = 0;
                    dtype->level_names = NULL;
                }

                dtype->name = stype->name;
                memcpy(&dtype->mods, &stype->mods, sizeof(XkbModsRec));

                if (stype->map_count) {
                    if (stype->map) {
                        if (stype->map_count != dtype->map_count &&
                            dtype->map_count && dtype->map &&
                            i < dst->map->num_types) {
                            tmp = reallocarray(dtype->map,
                                               stype->map_count,
                                               sizeof(XkbKTMapEntryRec));
                            if (!tmp)
                                return FALSE;
                            dtype->map = tmp;
                        }
                        else if (!dtype->map_count || !dtype->map ||
                                 i >= dst->map->num_types) {
                            tmp = xallocarray(stype->map_count,
                                              sizeof(XkbKTMapEntryRec));
                            if (!tmp)
                                return FALSE;
                            dtype->map = tmp;
                        }

                        memcpy(dtype->map, stype->map,
                               stype->map_count * sizeof(XkbKTMapEntryRec));
                    }
                    else {
                        if (dtype->map && i < dst->map->num_types)
                            free(dtype->map);
                        dtype->map = NULL;
                    }

                    if (stype->preserve) {
                        if (stype->map_count != dtype->map_count &&
                            dtype->map_count && dtype->preserve &&
                            i < dst->map->num_types) {
                            tmp = reallocarray(dtype->preserve,
                                               stype->map_count,
                                               sizeof(XkbModsRec));
                            if (!tmp)
                                return FALSE;
                            dtype->preserve = tmp;
                        }
                        else if (!dtype->preserve || !dtype->map_count ||
                                 i >= dst->map->num_types) {
                            tmp = xallocarray(stype->map_count,
                                              sizeof(XkbModsRec));
                            if (!tmp)
                                return FALSE;
                            dtype->preserve = tmp;
                        }

                        memcpy(dtype->preserve, stype->preserve,
                               stype->map_count * sizeof(XkbModsRec));
                    }
                    else {
                        if (dtype->preserve && i < dst->map->num_types)
                            free(dtype->preserve);
                        dtype->preserve = NULL;
                    }

                    dtype->map_count = stype->map_count;
                }
                else {
                    if (dtype->map_count && i < dst->map->num_types) {
                        free(dtype->map);
                        free(dtype->preserve);
                    }
                    dtype->map_count = 0;
                    dtype->map = NULL;
                    dtype->preserve = NULL;
                }
            }

            dst->map->size_types = src->map->num_types;
            dst->map->num_types = src->map->num_types;
        }
        else {
            if (dst->map->types) {
                for (i = 0, dtype = dst->map->types; i < dst->map->num_types;
                     i++, dtype++) {
                    free(dtype->level_names);
                    if (dtype->map && dtype->map_count)
                        free(dtype->map);
                    if (dtype->preserve && dtype->map_count)
                        free(dtype->preserve);
                }
            }
            free(dst->map->types);
            dst->map->types = NULL;
            dst->map->num_types = 0;
            dst->map->size_types = 0;
        }

        if (src->map->modmap) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->map->modmap, src->max_key_code + 1);
                if (!tmp)
                    return FALSE;
                dst->map->modmap = tmp;
            }
            memcpy(dst->map->modmap, src->map->modmap, src->max_key_code + 1);
        }
        else {
            free(dst->map->modmap);
            dst->map->modmap = NULL;
        }
    }
    else {
        if (dst->map)
            XkbFreeClientMap(dst, XkbAllClientInfoMask, TRUE);
    }

    return TRUE;
}

static Bool
_XkbCopyServerMap(XkbDescPtr src, XkbDescPtr dst)
{
    void *tmp = NULL;

    /* server map */
    if (src->server) {
        if (!dst->server) {
            tmp = calloc(1, sizeof(XkbServerMapRec));
            if (!tmp)
                return FALSE;
            dst->server = tmp;
        }

        if (src->server->explicit) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = realloc(dst->server->explicit, src->max_key_code + 1);
                if (!tmp)
                    return FALSE;
                dst->server->explicit = tmp;
            }
            memcpy(dst->server->explicit, src->server->explicit,
                   src->max_key_code + 1);
        }
        else {
            free(dst->server->explicit);
            dst->server->explicit = NULL;
        }

        if (src->server->acts) {
            if (src->server->size_acts != dst->server->size_acts) {
                tmp = reallocarray(dst->server->acts,
                                   src->server->size_acts, sizeof(XkbAction));
                if (!tmp)
                    return FALSE;
                dst->server->acts = tmp;
            }
            memcpy(dst->server->acts, src->server->acts,
                   src->server->size_acts * sizeof(XkbAction));
        }
        else {
            free(dst->server->acts);
            dst->server->acts = NULL;
        }
        dst->server->size_acts = src->server->size_acts;
        dst->server->num_acts = src->server->num_acts;

        if (src->server->key_acts) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = reallocarray(dst->server->key_acts,
                                   src->max_key_code + 1, sizeof(unsigned short));
                if (!tmp)
                    return FALSE;
                dst->server->key_acts = tmp;
            }
            memcpy(dst->server->key_acts, src->server->key_acts,
                   (src->max_key_code + 1) * sizeof(unsigned short));
        }
        else {
            free(dst->server->key_acts);
            dst->server->key_acts = NULL;
        }

        if (src->server->behaviors) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = reallocarray(dst->server->behaviors,
                                   src->max_key_code + 1, sizeof(XkbBehavior));
                if (!tmp)
                    return FALSE;
                dst->server->behaviors = tmp;
            }
            memcpy(dst->server->behaviors, src->server->behaviors,
                   (src->max_key_code + 1) * sizeof(XkbBehavior));
        }
        else {
            free(dst->server->behaviors);
            dst->server->behaviors = NULL;
        }

        memcpy(dst->server->vmods, src->server->vmods, XkbNumVirtualMods);

        if (src->server->vmodmap) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = reallocarray(dst->server->vmodmap,
                                   src->max_key_code + 1, sizeof(unsigned short));
                if (!tmp)
                    return FALSE;
                dst->server->vmodmap = tmp;
            }
            memcpy(dst->server->vmodmap, src->server->vmodmap,
                   (src->max_key_code + 1) * sizeof(unsigned short));
        }
        else {
            free(dst->server->vmodmap);
            dst->server->vmodmap = NULL;
        }
    }
    else {
        if (dst->server)
            XkbFreeServerMap(dst, XkbAllServerInfoMask, TRUE);
    }

    return TRUE;
}

static Bool
_XkbCopyNames(XkbDescPtr src, XkbDescPtr dst)
{
    void *tmp = NULL;

    /* names */
    if (src->names) {
        if (!dst->names) {
            dst->names = calloc(1, sizeof(XkbNamesRec));
            if (!dst->names)
                return FALSE;
        }

        if (src->names->keys) {
            if (src->max_key_code != dst->max_key_code) {
                tmp = reallocarray(dst->names->keys, src->max_key_code + 1,
                                   sizeof(XkbKeyNameRec));
                if (!tmp)
                    return FALSE;
                dst->names->keys = tmp;
            }
            memcpy(dst->names->keys, src->names->keys,
                   (src->max_key_code + 1) * sizeof(XkbKeyNameRec));
        }
        else {
            free(dst->names->keys);
            dst->names->keys = NULL;
        }

        if (src->names->num_key_aliases) {
            if (src->names->num_key_aliases != dst->names->num_key_aliases) {
                tmp = reallocarray(dst->names->key_aliases,
                                   src->names->num_key_aliases,
                                   sizeof(XkbKeyAliasRec));
                if (!tmp)
                    return FALSE;
                dst->names->key_aliases = tmp;
            }
            memcpy(dst->names->key_aliases, src->names->key_aliases,
                   src->names->num_key_aliases * sizeof(XkbKeyAliasRec));
        }
        else {
            free(dst->names->key_aliases);
            dst->names->key_aliases = NULL;
        }
        dst->names->num_key_aliases = src->names->num_key_aliases;

        if (src->names->num_rg) {
            if (src->names->num_rg != dst->names->num_rg) {
                tmp = reallocarray(dst->names->radio_groups,
                                   src->names->num_rg, sizeof(Atom));
                if (!tmp)
                    return FALSE;
                dst->names->radio_groups = tmp;
            }
            memcpy(dst->names->radio_groups, src->names->radio_groups,
                   src->names->num_rg * sizeof(Atom));
        }
        else {
            free(dst->names->radio_groups);
        }
        dst->names->num_rg = src->names->num_rg;

        dst->names->keycodes = src->names->keycodes;
        dst->names->geometry = src->names->geometry;
        dst->names->symbols = src->names->symbols;
        dst->names->types = src->names->types;
        dst->names->compat = src->names->compat;
        dst->names->phys_symbols = src->names->phys_symbols;

        memcpy(dst->names->vmods, src->names->vmods,
               XkbNumVirtualMods * sizeof(Atom));
        memcpy(dst->names->indicators, src->names->indicators,
               XkbNumIndicators * sizeof(Atom));
        memcpy(dst->names->groups, src->names->groups,
               XkbNumKbdGroups * sizeof(Atom));
    }
    else {
        if (dst->names)
            XkbFreeNames(dst, XkbAllNamesMask, TRUE);
    }

    return TRUE;
}

static Bool
_XkbCopyCompat(XkbDescPtr src, XkbDescPtr dst)
{
    void *tmp = NULL;

    /* compat */
    if (src->compat) {
        if (!dst->compat) {
            dst->compat = calloc(1, sizeof(XkbCompatMapRec));
            if (!dst->compat)
                return FALSE;
        }

        if (src->compat->sym_interpret && src->compat->num_si) {
            if (src->compat->num_si != dst->compat->size_si) {
                tmp = reallocarray(dst->compat->sym_interpret,
                                   src->compat->num_si,
                                   sizeof(XkbSymInterpretRec));
                if (!tmp)
                    return FALSE;
                dst->compat->sym_interpret = tmp;
            }
            memcpy(dst->compat->sym_interpret, src->compat->sym_interpret,
                   src->compat->num_si * sizeof(XkbSymInterpretRec));

            dst->compat->num_si = src->compat->num_si;
            dst->compat->size_si = src->compat->num_si;
        }
        else {
            if (dst->compat->sym_interpret && dst->compat->size_si)
                free(dst->compat->sym_interpret);

            dst->compat->sym_interpret = NULL;
            dst->compat->num_si = 0;
            dst->compat->size_si = 0;
        }

        memcpy(dst->compat->groups, src->compat->groups,
               XkbNumKbdGroups * sizeof(XkbModsRec));
    }
    else {
        if (dst->compat)
            XkbFreeCompatMap(dst, XkbAllCompatMask, TRUE);
    }

    return TRUE;
}

static Bool
_XkbCopyGeom(XkbDescPtr src, XkbDescPtr dst)
{
    void *tmp = NULL;
    int i = 0, j = 0, k = 0;
    XkbColorPtr scolor = NULL, dcolor = NULL;
    XkbDoodadPtr sdoodad = NULL, ddoodad = NULL;
    XkbOutlinePtr soutline = NULL, doutline = NULL;
    XkbPropertyPtr sprop = NULL, dprop = NULL;
    XkbRowPtr srow = NULL, drow = NULL;
    XkbSectionPtr ssection = NULL, dsection = NULL;
    XkbShapePtr sshape = NULL, dshape = NULL;

    /* geometry */
    if (src->geom) {
        if (!dst->geom) {
            dst->geom = calloc(sizeof(XkbGeometryRec), 1);
            if (!dst->geom)
                return FALSE;
        }

        /* properties */
        if (src->geom->num_properties) {
            /* If we've got more properties in the destination than
             * the source, run through and free all the excess ones
             * first. */
            if (src->geom->num_properties < dst->geom->sz_properties) {
                for (i = src->geom->num_properties, dprop =
                     dst->geom->properties + i; i < dst->geom->num_properties;
                     i++, dprop++) {
                    free(dprop->name);
                    free(dprop->value);
                }
            }

            /* Reallocate and clear all new items if the buffer grows. */
            if (!XkbGeomRealloc
                ((void **) &dst->geom->properties, dst->geom->sz_properties,
                 src->geom->num_properties, sizeof(XkbPropertyRec),
                 XKB_GEOM_CLEAR_EXCESS))
                return FALSE;
            /* We don't set num_properties as we need it to try and avoid
             * too much reallocing. */
            dst->geom->sz_properties = src->geom->num_properties;

            for (i = 0,
                 sprop = src->geom->properties,
                 dprop = dst->geom->properties;
                 i < src->geom->num_properties; i++, sprop++, dprop++) {
                if (i < dst->geom->num_properties) {
                    if (strlen(sprop->name) != strlen(dprop->name)) {
                        tmp = realloc(dprop->name, strlen(sprop->name) + 1);
                        if (!tmp)
                            return FALSE;
                        dprop->name = tmp;
                    }
                    if (strlen(sprop->value) != strlen(dprop->value)) {
                        tmp = realloc(dprop->value, strlen(sprop->value) + 1);
                        if (!tmp)
                            return FALSE;
                        dprop->value = tmp;
                    }
                    strcpy(dprop->name, sprop->name);
                    strcpy(dprop->value, sprop->value);
                }
                else {
                    dprop->name = xstrdup(sprop->name);
                    dprop->value = xstrdup(sprop->value);
                }
            }

            /* ... which is already src->geom->num_properties. */
            dst->geom->num_properties = dst->geom->sz_properties;
        }
        else {
            if (dst->geom->sz_properties) {
                for (i = 0, dprop = dst->geom->properties;
                     i < dst->geom->num_properties; i++, dprop++) {
                    free(dprop->name);
                    free(dprop->value);
                }
                free(dst->geom->properties);
                dst->geom->properties = NULL;
            }

            dst->geom->num_properties = 0;
            dst->geom->sz_properties = 0;
        }

        /* colors */
        if (src->geom->num_colors) {
            if (src->geom->num_colors < dst->geom->sz_colors) {
                for (i = src->geom->num_colors, dcolor = dst->geom->colors + i;
                     i < dst->geom->num_colors; i++, dcolor++) {
                    free(dcolor->spec);
                }
            }

            /* Reallocate and clear all new items if the buffer grows. */
            if (!XkbGeomRealloc
                ((void **) &dst->geom->colors, dst->geom->sz_colors,
                 src->geom->num_colors, sizeof(XkbColorRec),
                 XKB_GEOM_CLEAR_EXCESS))
                return FALSE;
            dst->geom->sz_colors = src->geom->num_colors;

            for (i = 0,
                 scolor = src->geom->colors,
                 dcolor = dst->geom->colors;
                 i < src->geom->num_colors; i++, scolor++, dcolor++) {
                if (i < dst->geom->num_colors) {
                    if (strlen(scolor->spec) != strlen(dcolor->spec)) {
                        tmp = realloc(dcolor->spec, strlen(scolor->spec) + 1);
                        if (!tmp)
                            return FALSE;
                        dcolor->spec = tmp;
                    }
                    strcpy(dcolor->spec, scolor->spec);
                }
                else {
                    dcolor->spec = xstrdup(scolor->spec);
                }
                dcolor->pixel = scolor->pixel;
            }

            dst->geom->num_colors = dst->geom->sz_colors;
        }
        else {
            if (dst->geom->sz_colors) {
                for (i = 0, dcolor = dst->geom->colors;
                     i < dst->geom->num_colors; i++, dcolor++) {
                    free(dcolor->spec);
                }
                free(dst->geom->colors);
                dst->geom->colors = NULL;
            }

            dst->geom->num_colors = 0;
            dst->geom->sz_colors = 0;
        }

        /* shapes */
        /* shapes break down into outlines, which break down into points. */
        if (dst->geom->num_shapes) {
            for (i = 0, dshape = dst->geom->shapes;
                 i < dst->geom->num_shapes; i++, dshape++) {
                for (j = 0, doutline = dshape->outlines;
                     j < dshape->num_outlines; j++, doutline++) {
                    if (doutline->sz_points)
                        free(doutline->points);
                }

                if (dshape->sz_outlines) {
                    free(dshape->outlines);
                    dshape->outlines = NULL;
                }

                dshape->num_outlines = 0;
                dshape->sz_outlines = 0;
            }
        }

        if (src->geom->num_shapes) {
            /* Reallocate and clear all items. */
            if (!XkbGeomRealloc
                ((void **) &dst->geom->shapes, dst->geom->sz_shapes,
                 src->geom->num_shapes, sizeof(XkbShapeRec),
                 XKB_GEOM_CLEAR_ALL))
                return FALSE;

            for (i = 0, sshape = src->geom->shapes, dshape = dst->geom->shapes;
                 i < src->geom->num_shapes; i++, sshape++, dshape++) {
                if (sshape->num_outlines) {
                    tmp = calloc(sshape->num_outlines, sizeof(XkbOutlineRec));
                    if (!tmp)
                        return FALSE;
                    dshape->outlines = tmp;

                    for (j = 0,
                         soutline = sshape->outlines,
                         doutline = dshape->outlines;
                         j < sshape->num_outlines;
                         j++, soutline++, doutline++) {
                        if (soutline->num_points) {
                            tmp = xallocarray(soutline->num_points,
                                              sizeof(XkbPointRec));
                            if (!tmp)
                                return FALSE;
                            doutline->points = tmp;

                            memcpy(doutline->points, soutline->points,
                                   soutline->num_points * sizeof(XkbPointRec));

                            doutline->corner_radius = soutline->corner_radius;
                        }

                        doutline->num_points = soutline->num_points;
                        doutline->sz_points = soutline->num_points;
                    }
                }

                dshape->num_outlines = sshape->num_outlines;
                dshape->sz_outlines = sshape->num_outlines;
                dshape->name = sshape->name;
                dshape->bounds = sshape->bounds;

                dshape->approx = NULL;
                if (sshape->approx && sshape->num_outlines > 0) {

                    const ptrdiff_t approx_idx =
                        sshape->approx - sshape->outlines;

                    if (approx_idx < dshape->num_outlines) {
                        dshape->approx = dshape->outlines + approx_idx;
                    }
                    else {
                        LogMessage(X_WARNING, "XKB: approx outline "
                                   "index is out of range\n");
                    }
                }

                dshape->primary = NULL;
                if (sshape->primary && sshape->num_outlines > 0) {

                    const ptrdiff_t primary_idx =
                        sshape->primary - sshape->outlines;

                    if (primary_idx < dshape->num_outlines) {
                        dshape->primary = dshape->outlines + primary_idx;
                    }
                    else {
                        LogMessage(X_WARNING, "XKB: primary outline "
                                   "index is out of range\n");
                    }
                }
            }

            dst->geom->num_shapes = src->geom->num_shapes;
            dst->geom->sz_shapes = src->geom->num_shapes;
        }
        else {
            if (dst->geom->sz_shapes) {
                free(dst->geom->shapes);
            }
            dst->geom->shapes = NULL;
            dst->geom->num_shapes = 0;
            dst->geom->sz_shapes = 0;
        }

        /* sections */
        /* sections break down into doodads, and also into rows, which break
         * down into keys. */
        if (dst->geom->num_sections) {
            for (i = 0, dsection = dst->geom->sections;
                 i < dst->geom->num_sections; i++, dsection++) {
                for (j = 0, drow = dsection->rows;
                     j < dsection->num_rows; j++, drow++) {
                    if (drow->num_keys)
                        free(drow->keys);
                }

                if (dsection->num_rows)
                    free(dsection->rows);

                /* cut and waste from geom/doodad below. */
                for (j = 0, ddoodad = dsection->doodads;
                     j < dsection->num_doodads; j++, ddoodad++) {
                    if (ddoodad->any.type == XkbTextDoodad) {
                        free(ddoodad->text.text);
                        ddoodad->text.text = NULL;
                        free(ddoodad->text.font);
                        ddoodad->text.font = NULL;
                    }
                    else if (ddoodad->any.type == XkbLogoDoodad) {
                        free(ddoodad->logo.logo_name);
                        ddoodad->logo.logo_name = NULL;
                    }
                }

                free(dsection->doodads);
            }

            dst->geom->num_sections = 0;
        }

        if (src->geom->num_sections) {
            /* Reallocate and clear all items. */
            if (!XkbGeomRealloc
                ((void **) &dst->geom->sections, dst->geom->sz_sections,
                 src->geom->num_sections, sizeof(XkbSectionRec),
                 XKB_GEOM_CLEAR_ALL))
                return FALSE;
            dst->geom->num_sections = src->geom->num_sections;
            dst->geom->sz_sections = src->geom->num_sections;

            for (i = 0,
                 ssection = src->geom->sections,
                 dsection = dst->geom->sections;
                 i < src->geom->num_sections; i++, ssection++, dsection++) {
                *dsection = *ssection;
                if (ssection->num_rows) {
                    tmp = calloc(ssection->num_rows, sizeof(XkbRowRec));
                    if (!tmp)
                        return FALSE;
                    dsection->rows = tmp;
                }
                dsection->num_rows = ssection->num_rows;
                dsection->sz_rows = ssection->num_rows;

                for (j = 0, srow = ssection->rows, drow = dsection->rows;
                     j < ssection->num_rows; j++, srow++, drow++) {
                    if (srow->num_keys) {
                        tmp = xallocarray(srow->num_keys, sizeof(XkbKeyRec));
                        if (!tmp)
                            return FALSE;
                        drow->keys = tmp;
                        memcpy(drow->keys, srow->keys,
                               srow->num_keys * sizeof(XkbKeyRec));
                    }
                    drow->num_keys = srow->num_keys;
                    drow->sz_keys = srow->num_keys;
                    drow->top = srow->top;
                    drow->left = srow->left;
                    drow->vertical = srow->vertical;
                    drow->bounds = srow->bounds;
                }

                if (ssection->num_doodads) {
                    tmp = calloc(ssection->num_doodads, sizeof(XkbDoodadRec));
                    if (!tmp)
                        return FALSE;
                    dsection->doodads = tmp;
                }
                else {
                    dsection->doodads = NULL;
                }

                dsection->sz_doodads = ssection->num_doodads;
                for (k = 0,
                     sdoodad = ssection->doodads,
                     ddoodad = dsection->doodads;
                     k < ssection->num_doodads; k++, sdoodad++, ddoodad++) {
                    memcpy(ddoodad, sdoodad, sizeof(XkbDoodadRec));
                    if (sdoodad->any.type == XkbTextDoodad) {
                        if (sdoodad->text.text)
                            ddoodad->text.text = strdup(sdoodad->text.text);
                        if (sdoodad->text.font)
                            ddoodad->text.font = strdup(sdoodad->text.font);
                    }
                    else if (sdoodad->any.type == XkbLogoDoodad) {
                        if (sdoodad->logo.logo_name)
                            ddoodad->logo.logo_name =
                                strdup(sdoodad->logo.logo_name);
                    }
                }
                dsection->overlays = NULL;
                dsection->sz_overlays = 0;
                dsection->num_overlays = 0;
            }
        }
        else {
            if (dst->geom->sz_sections) {
                free(dst->geom->sections);
            }

            dst->geom->sections = NULL;
            dst->geom->num_sections = 0;
            dst->geom->sz_sections = 0;
        }

        /* doodads */
        if (dst->geom->num_doodads) {
            for (i = src->geom->num_doodads,
                 ddoodad = dst->geom->doodads +
                 src->geom->num_doodads;
                 i < dst->geom->num_doodads; i++, ddoodad++) {
                if (ddoodad->any.type == XkbTextDoodad) {
                    free(ddoodad->text.text);
                    ddoodad->text.text = NULL;
                    free(ddoodad->text.font);
                    ddoodad->text.font = NULL;
                }
                else if (ddoodad->any.type == XkbLogoDoodad) {
                    free(ddoodad->logo.logo_name);
                    ddoodad->logo.logo_name = NULL;
                }
            }
            dst->geom->num_doodads = 0;
        }

        if (src->geom->num_doodads) {
            /* Reallocate and clear all items. */
            if (!XkbGeomRealloc
                ((void **) &dst->geom->doodads, dst->geom->sz_doodads,
                 src->geom->num_doodads, sizeof(XkbDoodadRec),
                 XKB_GEOM_CLEAR_ALL))
                return FALSE;

            dst->geom->sz_doodads = src->geom->num_doodads;

            for (i = 0,
                 sdoodad = src->geom->doodads,
                 ddoodad = dst->geom->doodads;
                 i < src->geom->num_doodads; i++, sdoodad++, ddoodad++) {
                memcpy(ddoodad, sdoodad, sizeof(XkbDoodadRec));
                if (sdoodad->any.type == XkbTextDoodad) {
                    if (sdoodad->text.text)
                        ddoodad->text.text = strdup(sdoodad->text.text);
                    if (sdoodad->text.font)
                        ddoodad->text.font = strdup(sdoodad->text.font);
                }
                else if (sdoodad->any.type == XkbLogoDoodad) {
                    if (sdoodad->logo.logo_name)
                        ddoodad->logo.logo_name =
                            strdup(sdoodad->logo.logo_name);
                }
            }

            dst->geom->num_doodads = dst->geom->sz_doodads;
        }
        else {
            if (dst->geom->sz_doodads) {
                free(dst->geom->doodads);
            }

            dst->geom->doodads = NULL;
            dst->geom->num_doodads = 0;
            dst->geom->sz_doodads = 0;
        }

        /* key aliases */
        if (src->geom->num_key_aliases) {
            /* Reallocate but don't clear any items. There is no need
             * to clear anything because data is immediately copied
             * over the whole memory area with memcpy. */
            if (!XkbGeomRealloc
                ((void **) &dst->geom->key_aliases, dst->geom->sz_key_aliases,
                 src->geom->num_key_aliases, 2 * XkbKeyNameLength,
                 XKB_GEOM_CLEAR_NONE))
                return FALSE;

            dst->geom->sz_key_aliases = src->geom->num_key_aliases;

            memcpy(dst->geom->key_aliases, src->geom->key_aliases,
                   src->geom->num_key_aliases * 2 * XkbKeyNameLength);

            dst->geom->num_key_aliases = dst->geom->sz_key_aliases;
        }
        else {
            free(dst->geom->key_aliases);
            dst->geom->key_aliases = NULL;
            dst->geom->num_key_aliases = 0;
            dst->geom->sz_key_aliases = 0;
        }

        /* font */
        if (src->geom->label_font) {
            if (!dst->geom->label_font) {
                tmp = malloc(strlen(src->geom->label_font) + 1);
                if (!tmp)
                    return FALSE;
                dst->geom->label_font = tmp;
            }
            else if (strlen(src->geom->label_font) !=
                     strlen(dst->geom->label_font)) {
                tmp = realloc(dst->geom->label_font,
                              strlen(src->geom->label_font) + 1);
                if (!tmp)
                    return FALSE;
                dst->geom->label_font = tmp;
            }

            strcpy(dst->geom->label_font, src->geom->label_font);
            i = XkbGeomColorIndex(src->geom, src->geom->label_color);
            dst->geom->label_color = &(dst->geom->colors[i]);
            i = XkbGeomColorIndex(src->geom, src->geom->base_color);
            dst->geom->base_color = &(dst->geom->colors[i]);
        }
        else {
            free(dst->geom->label_font);
            dst->geom->label_font = NULL;
            dst->geom->label_color = NULL;
            dst->geom->base_color = NULL;
        }

        dst->geom->name = src->geom->name;
        dst->geom->width_mm = src->geom->width_mm;
        dst->geom->height_mm = src->geom->height_mm;
    }
    else {
        if (dst->geom) {
            /* I LOVE THE DIFFERENT CALL SIGNATURE.  REALLY, I DO. */
            XkbFreeGeometry(dst->geom, XkbGeomAllMask, TRUE);
            dst->geom = NULL;
        }
    }

    return TRUE;
}

static Bool
_XkbCopyIndicators(XkbDescPtr src, XkbDescPtr dst)
{
    /* indicators */
    if (src->indicators) {
        if (!dst->indicators) {
            dst->indicators = malloc(sizeof(XkbIndicatorRec));
            if (!dst->indicators)
                return FALSE;
        }
        memcpy(dst->indicators, src->indicators, sizeof(XkbIndicatorRec));
    }
    else {
        free(dst->indicators);
        dst->indicators = NULL;
    }
    return TRUE;
}

static Bool
_XkbCopyControls(XkbDescPtr src, XkbDescPtr dst)
{
    /* controls */
    if (src->ctrls) {
        if (!dst->ctrls) {
            dst->ctrls = malloc(sizeof(XkbControlsRec));
            if (!dst->ctrls)
                return FALSE;
        }
        memcpy(dst->ctrls, src->ctrls, sizeof(XkbControlsRec));
    }
    else {
        free(dst->ctrls);
        dst->ctrls = NULL;
    }
    return TRUE;
}

/**
 * Copy an XKB map from src to dst, reallocating when necessary: if some
 * map components are present in one, but not in the other, the destination
 * components will be allocated or freed as necessary.
 *
 * Basic map consistency is assumed on both sides, so maps with random
 * uninitialised data (e.g. names->radio_grous == NULL, names->num_rg == 19)
 * _will_ cause failures.  You've been warned.
 *
 * Returns TRUE on success, or FALSE on failure.  If this function fails,
 * dst may be in an inconsistent state: all its pointers are guaranteed
 * to remain valid, but part of the map may be from src and part from dst.
 *
 */

Bool
XkbCopyKeymap(XkbDescPtr dst, XkbDescPtr src)
{

    if (!src || !dst) {
        DebugF("XkbCopyKeymap: src (%p) or dst (%p) is NULL\n", src, dst);
        return FALSE;
    }

    if (src == dst)
        return TRUE;

    if (!_XkbCopyClientMap(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy client map\n");
        return FALSE;
    }
    if (!_XkbCopyServerMap(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy server map\n");
        return FALSE;
    }
    if (!_XkbCopyIndicators(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy indicators\n");
        return FALSE;
    }
    if (!_XkbCopyControls(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy controls\n");
        return FALSE;
    }
    if (!_XkbCopyNames(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy names\n");
        return FALSE;
    }
    if (!_XkbCopyCompat(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy compat map\n");
        return FALSE;
    }
    if (!_XkbCopyGeom(src, dst)) {
        DebugF("XkbCopyKeymap: failed to copy geometry\n");
        return FALSE;
    }

    dst->min_key_code = src->min_key_code;
    dst->max_key_code = src->max_key_code;

    return TRUE;
}

Bool
XkbDeviceApplyKeymap(DeviceIntPtr dst, XkbDescPtr desc)
{
    xkbNewKeyboardNotify nkn;
    Bool ret;

    if (!dst->key || !desc)
        return FALSE;

    memset(&nkn, 0, sizeof(xkbNewKeyboardNotify));
    nkn.oldMinKeyCode = dst->key->xkbInfo->desc->min_key_code;
    nkn.oldMaxKeyCode = dst->key->xkbInfo->desc->max_key_code;
    nkn.deviceID = dst->id;
    nkn.oldDeviceID = dst->id;
    nkn.minKeyCode = desc->min_key_code;
    nkn.maxKeyCode = desc->max_key_code;
    nkn.requestMajor = XkbReqCode;
    nkn.requestMinor = X_kbSetMap;      /* Near enough's good enough. */
    nkn.changed = XkbNKN_KeycodesMask;
    if (desc->geom)
        nkn.changed |= XkbNKN_GeometryMask;

    ret = XkbCopyKeymap(dst->key->xkbInfo->desc, desc);
    if (ret)
        XkbSendNewKeyboardNotify(dst, &nkn);

    return ret;
}

Bool
XkbCopyDeviceKeymap(DeviceIntPtr dst, DeviceIntPtr src)
{
    return XkbDeviceApplyKeymap(dst, src->key->xkbInfo->desc);
}

int
XkbGetEffectiveGroup(XkbSrvInfoPtr xkbi, XkbStatePtr xkbState, CARD8 keycode)
{
    XkbDescPtr xkb = xkbi->desc;
    int effectiveGroup = xkbState->group;

    if (!XkbKeycodeInRange(xkb, keycode))
        return -1;

    if (effectiveGroup == XkbGroup1Index)
        return effectiveGroup;

    if (XkbKeyNumGroups(xkb, keycode) > 1U) {
        if (effectiveGroup >= XkbKeyNumGroups(xkb, keycode)) {
            unsigned int gi = XkbKeyGroupInfo(xkb, keycode);

            switch (XkbOutOfRangeGroupAction(gi)) {
            default:
            case XkbWrapIntoRange:
                effectiveGroup %= XkbKeyNumGroups(xkb, keycode);
                break;
            case XkbClampIntoRange:
                effectiveGroup = XkbKeyNumGroups(xkb, keycode) - 1;
                break;
            case XkbRedirectIntoRange:
                effectiveGroup = XkbOutOfRangeGroupInfo(gi);
                if (effectiveGroup >= XkbKeyNumGroups(xkb, keycode))
                    effectiveGroup = 0;
                break;
            }
        }
    }
    else
        effectiveGroup = XkbGroup1Index;

    return effectiveGroup;
}

/* Merge the lockedPtrButtons from all attached SDs for the given master
 * device into the MD's state.
 */
void
XkbMergeLockedPtrBtns(DeviceIntPtr master)
{
    DeviceIntPtr d = inputInfo.devices;
    XkbSrvInfoPtr xkbi = NULL;

    if (!IsMaster(master))
        return;

    if (!master->key)
        return;

    xkbi = master->key->xkbInfo;
    xkbi->lockedPtrButtons = 0;

    for (; d; d = d->next) {
        if (IsMaster(d) || GetMaster(d, MASTER_KEYBOARD) != master || !d->key)
            continue;

        xkbi->lockedPtrButtons |= d->key->xkbInfo->lockedPtrButtons;
    }
}

void
XkbCopyControls(XkbDescPtr dst, XkbDescPtr src)
{
    int i, nG, nTG;

    if (!dst || !src)
        return;

    *dst->ctrls = *src->ctrls;

    for (nG = nTG = 0, i = dst->min_key_code; i <= dst->max_key_code; i++) {
        nG = XkbKeyNumGroups(dst, i);
        if (nG >= XkbNumKbdGroups) {
            nTG = XkbNumKbdGroups;
            break;
        }
        if (nG > nTG) {
            nTG = nG;
        }
    }
    dst->ctrls->num_groups = nTG;
}
@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d949 2
a950 2
                tmp = realloc(dst->map->syms,
                              src->map->size_syms * sizeof(KeySym));
d968 2
a969 2
                tmp = realloc(dst->map->key_sym_map,
                              (src->max_key_code + 1) * sizeof(XkbSymMapRec));
d986 2
a987 2
                    tmp = realloc(dst->map->types,
                                  src->map->num_types * sizeof(XkbKeyTypeRec));
d1023 2
a1024 2
                        tmp = realloc(dtype->level_names,
                                      stype->num_levels * sizeof(Atom));
d1056 3
a1058 3
                            tmp = realloc(dtype->map,
                                          stype->map_count *
                                          sizeof(XkbKTMapEntryRec));
d1065 2
a1066 2
                            tmp = malloc(stype->map_count *
                                         sizeof(XkbKTMapEntryRec));
d1085 3
a1087 3
                            tmp = realloc(dtype->preserve,
                                          stype->map_count *
                                          sizeof(XkbModsRec));
d1094 2
a1095 1
                            tmp = malloc(stype->map_count * sizeof(XkbModsRec));
d1196 2
a1197 2
                tmp = realloc(dst->server->acts,
                              src->server->size_acts * sizeof(XkbAction));
d1214 2
a1215 2
                tmp = realloc(dst->server->key_acts,
                              (src->max_key_code + 1) * sizeof(unsigned short));
d1230 2
a1231 2
                tmp = realloc(dst->server->behaviors,
                              (src->max_key_code + 1) * sizeof(XkbBehavior));
d1248 2
a1249 2
                tmp = realloc(dst->server->vmodmap,
                              (src->max_key_code + 1) * sizeof(unsigned short));
d1285 2
a1286 2
                tmp = realloc(dst->names->keys,
                              (src->max_key_code + 1) * sizeof(XkbKeyNameRec));
d1301 3
a1303 3
                tmp = realloc(dst->names->key_aliases,
                              src->names->num_key_aliases *
                              sizeof(XkbKeyAliasRec));
d1319 2
a1320 2
                tmp = realloc(dst->names->radio_groups,
                              src->names->num_rg * sizeof(Atom));
d1370 3
a1372 2
                tmp = realloc(dst->compat->sym_interpret,
                              src->compat->num_si * sizeof(XkbSymInterpretRec));
d1587 2
a1588 2
                            tmp = malloc(soutline->num_points *
                                         sizeof(XkbPointRec));
d1715 1
a1715 1
                        tmp = malloc(srow->num_keys * sizeof(XkbKeyRec));
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d9 2
a10 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d12 1
a12 1
Silicon Graphics makes no representation about the suitability 
d16 2
a17 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d19 3
a21 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d2002 1
a2002 1
XkbCopyDeviceKeymap(DeviceIntPtr dst, DeviceIntPtr src)
d2007 1
a2007 1
    if (!dst->key || !src->key)
d2014 3
a2016 3
    nkn.oldDeviceID = dst->id;  /* maybe src->id? */
    nkn.minKeyCode = src->key->xkbInfo->desc->min_key_code;
    nkn.maxKeyCode = src->key->xkbInfo->desc->max_key_code;
d2020 1
a2020 1
    if (src->key->xkbInfo->desc->geom)
d2023 1
a2023 1
    ret = XkbCopyKeymap(dst->key->xkbInfo->desc, src->key->xkbInfo->desc);
d2030 6
d2098 23
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d645 1
d654 1
d656 6
a661 2
    if (xkbi->desc->ctrls->enabled_ctrls & XkbIgnoreGroupLockMask)
        grp_mask = map->groups[state->base_group].mask;
@


1.7
log
@Update to xserver 1.11.2
@
text
@d76 1
a76 1
		    Mask access_mode, int *xkb_err)
d87 1
a87 1
	*xkb_err = XkbErr_BadDevice;
d94 1
a94 1
		   Mask access_mode, int *xkb_err)
d104 1
a104 1
	return rc;
d108 3
a110 3
	*pDev = NULL;
	*xkb_err= XkbErr_BadClass;
	return XkbKeyboardErrorCode;
d117 1
a117 1
		     Mask access_mode, int *xkb_err)
d124 1
a124 1
	return rc;
d128 3
a130 3
	*pDev = NULL;
	*xkb_err= XkbErr_BadClass;
	return XkbKeyboardErrorCode;
d137 1
a137 1
		    Mask access_mode, int *xkb_err)
d147 1
a147 1
	return rc;
d151 3
a153 3
	*pDev = NULL;
	*xkb_err= XkbErr_BadClass;
	return XkbKeyboardErrorCode;
d160 1
a160 1
		       Mask access_mode, int *xkb_err)
d167 1
a167 1
	return rc;
d171 3
a173 3
	*pDev = NULL;
	*xkb_err= XkbErr_BadClass;
	return XkbKeyboardErrorCode;
d179 1
a179 1
XkbSetActionKeyMods(XkbDescPtr xkb,XkbAction *act,unsigned mods)
d181 1
a181 1
register unsigned	tmp;
d184 14
a197 12
	case XkbSA_SetMods: case XkbSA_LatchMods: case XkbSA_LockMods:
	    if (act->mods.flags&XkbSA_UseModMapMods)
		act->mods.real_mods= act->mods.mask= mods;
	    if ((tmp= XkbModActionVMods(&act->mods))!=0)
		act->mods.mask|= XkbMaskForVMask(xkb,tmp);
	    break;
	case XkbSA_ISOLock:
	    if (act->iso.flags&XkbSA_UseModMapMods)
		act->iso.real_mods= act->iso.mask= mods;
	    if ((tmp= XkbModActionVMods(&act->iso))!=0)
		act->iso.mask|= XkbMaskForVMask(xkb,tmp);
	    break;
d203 1
a203 1
XkbMaskForVMask(XkbDescPtr xkb,unsigned vmask)
d205 6
a210 6
register int i,bit;
register unsigned mask;
    
    for (mask=i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if (vmask&bit)
	    mask|= xkb->server->vmods[i];
d218 42
a259 43
XkbUpdateKeyTypesFromCore(	DeviceIntPtr	pXDev,
                                KeySymsPtr      pCore,
				KeyCode	 	first,
				CARD8	 	num,
				XkbChangesPtr	changes)
{
XkbDescPtr		xkb;
unsigned		key,nG,explicit;
int			types[XkbNumKbdGroups];
KeySym			tsyms[XkbMaxSymsPerKey],*syms;
XkbMapChangesPtr	mc;

    xkb= pXDev->key->xkbInfo->desc;
    if (first+num-1>xkb->max_key_code) {
	/* 1/12/95 (ef) -- XXX! should allow XKB structures to grow */
	num= xkb->max_key_code-first+1;
    }

    mc= (changes?(&changes->map):NULL);

    syms= &pCore->map[(first - pCore->minKeyCode) * pCore->mapWidth];
    for (key=first; key<(first+num); key++,syms+= pCore->mapWidth) {
        explicit= xkb->server->explicit[key]&XkbExplicitKeyTypesMask;
        types[XkbGroup1Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup1Index);
        types[XkbGroup2Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup2Index);
        types[XkbGroup3Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup3Index);
        types[XkbGroup4Index]= XkbKeyKeyTypeIndex(xkb,key,XkbGroup4Index);
        nG= XkbKeyTypesForCoreSymbols(xkb,pCore->mapWidth,syms,explicit,types,
									tsyms);
	XkbChangeTypesOfKey(xkb,key,nG,XkbAllGroupsMask,types,mc);
	memcpy((char *)XkbKeySymsPtr(xkb,key),(char *)tsyms,
					XkbKeyNumSyms(xkb,key)*sizeof(KeySym));
    }
    if (changes->map.changed&XkbKeySymsMask) {
	CARD8 oldLast,newLast;
	oldLast = changes->map.first_key_sym+changes->map.num_key_syms-1;
	newLast = first+num-1;

	if (first<changes->map.first_key_sym)
	    changes->map.first_key_sym = first;
	if (oldLast>newLast)
	    newLast= oldLast;
	changes->map.num_key_syms = newLast-changes->map.first_key_sym+1;
d262 3
a264 3
	changes->map.changed|= XkbKeySymsMask;
	changes->map.first_key_sym = first;
	changes->map.num_key_syms = num;
d270 2
a271 4
XkbUpdateDescActions(	XkbDescPtr		xkb,
			KeyCode		 	first,
			CARD8		 	num,
			XkbChangesPtr	 	changes)
d273 1
a273 1
register unsigned	key;
d275 2
a276 2
    for (key=first;key<(first+num);key++) {
	XkbApplyCompatMapToKey(xkb,key,changes);
d279 4
a282 4
    if (changes->map.changed&(XkbVirtualModMapMask|XkbModifierMapMask)) {
        unsigned char           newVMods[XkbNumVirtualMods];
        register  unsigned      bit,i;
        unsigned                present;
d285 3
a287 3
        present= 0;
        for (key=xkb->min_key_code;key<=xkb->max_key_code;key++) {
            if (xkb->server->vmodmap[key]==0)
d289 4
a292 4
            for (i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
                if (bit&xkb->server->vmodmap[key]) {
                    present|= bit;
                    newVMods[i]|= xkb->map->modmap[key];
d296 5
a300 5
        for (i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
            if ((bit&present)&&(newVMods[i]!=xkb->server->vmods[i])) {
                changes->map.changed|= XkbVirtualModsMask;
                changes->map.vmods|= bit;
                xkb->server->vmods[i]= newVMods[i];
d304 5
a308 2
    if (changes->map.changed&XkbVirtualModsMask)
        XkbApplyVirtualModChanges(xkb,changes->map.vmods,changes);
d310 2
a311 4
    if (changes->map.changed&XkbKeyActionsMask) {
	CARD8 oldLast,newLast;
	oldLast= changes->map.first_key_act+changes->map.num_key_acts-1;
	newLast = first+num-1;
d313 5
a317 5
	if (first<changes->map.first_key_act)
	    changes->map.first_key_act = first;
	if (newLast>oldLast)
	    newLast= oldLast;
	changes->map.num_key_acts= newLast-changes->map.first_key_act+1;
d320 3
a322 3
	changes->map.changed|= XkbKeyActionsMask;
	changes->map.first_key_act = first;
	changes->map.num_key_acts = num;
d328 9
a336 10
XkbUpdateActions(	DeviceIntPtr	 	pXDev,
			KeyCode		 	first,
			CARD8		 	num,
			XkbChangesPtr	 	changes,
			unsigned *	 	needChecksRtrn,
			XkbEventCausePtr	cause)
{
XkbSrvInfoPtr		xkbi;
XkbDescPtr		xkb;
CARD8 *			repeat;
d339 4
a342 4
	*needChecksRtrn= 0;
    xkbi= pXDev->key->xkbInfo;
    xkb= xkbi->desc;
    repeat= xkb->ctrls->per_key_repeat;
d346 1
a346 1
	memcpy(repeat,pXDev->kbdfeed->ctrl.autoRepeats,XkbPerKeyBitArraySize);
d348 1
a348 1
    XkbUpdateDescActions(xkb,first,num,changes);
d350 6
a355 6
    if ((pXDev->kbdfeed)&&
	(changes->ctrls.changed_ctrls&XkbPerKeyRepeatMask)) {
	/* now copy the modified changes back to core */
	memcpy(pXDev->kbdfeed->ctrl.autoRepeats,repeat, XkbPerKeyBitArraySize);
	if (pXDev->kbdfeed->CtrlProc)
	    (*pXDev->kbdfeed->CtrlProc)(pXDev, &pXDev->kbdfeed->ctrl);
d363 5
a367 5
register int		key,tmp;
int			maxSymsPerKey, maxGroup1Width;
XkbDescPtr		xkb;
KeySymsPtr              syms;
int			maxNumberOfGroups;
d370 1
a370 1
	return NULL;
d372 2
a373 2
    xkb= keybd->key->xkbInfo->desc;
    maxSymsPerKey= maxGroup1Width= 0;
d377 12
a388 10
    for (key=xkb->min_key_code;key<=xkb->max_key_code;key++) {
	if (XkbKeycodeInRange(xkb,key)) {
	    int	nGroups;
	    int	w;
	    nGroups= XkbKeyNumGroups(xkb,key);
	    tmp= 0;
	    if (nGroups>0) {
		if ((w=XkbKeyGroupWidth(xkb,key,XkbGroup1Index))<=2)
		     tmp+= 2;
		else tmp+= w + 2;
d392 2
a393 2
	    }
	    if (nGroups>1) {
d395 16
a410 14
		     if ((w=XkbKeyGroupWidth(xkb,key,XkbGroup2Index))<2)
		          tmp+= 2;
		     else tmp+= w;
                } else {
                     if ((w=XkbKeyGroupWidth(xkb,key,XkbGroup2Index))>2)
                          tmp+= w - 2;
                }
	    }
	    if (nGroups>2)
		tmp+= XkbKeyGroupWidth(xkb,key,XkbGroup3Index);
	    if (nGroups>3)
		tmp+= XkbKeyGroupWidth(xkb,key,XkbGroup4Index);
	    if (tmp>maxSymsPerKey)
		maxSymsPerKey= tmp;
d412 2
a413 2
		maxNumberOfGroups = nGroups;
	}
d442 19
a460 17
    for (key=xkb->min_key_code;key<=xkb->max_key_code;key++) {
        KeySym *pCore,*pXKB;
        unsigned nGroups,groupWidth,n,nOut;

        nGroups= XkbKeyNumGroups(xkb,key);
        n= (key-xkb->min_key_code)*syms->mapWidth;
        pCore= &syms->map[n];
        pXKB= XkbKeySymsPtr(xkb,key);
        nOut= 2;
        if (nGroups>0) {
            groupWidth= XkbKeyGroupWidth(xkb,key,XkbGroup1Index);
            if (groupWidth>0)   pCore[0]= pXKB[0];
            if (groupWidth>1)   pCore[1]= pXKB[1];
            for (n=2;n<groupWidth;n++)
                pCore[2+n]= pXKB[n];
            if (groupWidth>2)
                nOut= groupWidth;
d463 1
a463 1
	/* See XKB Protocol Sec, Section 12.4.
d465 53
a517 52
	   duplicated across all groups as ABABCDECDE.
	 */
	if (nGroups == 1)
	{
	    int idx, j;

	    groupWidth = XkbKeyGroupWidth(xkb, key, XkbGroup1Index);

	    /* AB..CDE... -> ABABCDE... */
	    if (groupWidth > 0 && syms->mapWidth >= 3)
	        pCore[2] = pCore[0];
	    if (groupWidth > 1 && syms->mapWidth >= 4)
	        pCore[3] = pCore[1];

	    /* ABABCDE... -> ABABCDECDE */
	    idx = 2 + groupWidth;
	    while (groupWidth > 2 && idx < syms->mapWidth &&
		   idx < groupWidth * 2)
	    {
		pCore[idx] = pCore[idx - groupWidth + 2];
		idx++;
	    }
	    idx = 2 * groupWidth;
	    if (idx < 4)
		idx = 4;
	    /* 3 or more groups: ABABCDECDEABCDEABCDE */
	    for (j = 3; j <= maxNumberOfGroups; j++)
		for (n = 0; n < groupWidth && idx < maxSymsPerKey; n++)
		    pCore[idx++] = pXKB[n];
	}

	pXKB+= XkbKeyGroupsWidth(xkb,key);
	nOut+= 2;
	if (nGroups>1) {
	    groupWidth= XkbKeyGroupWidth(xkb,key,XkbGroup2Index);
	    if (groupWidth>0)	pCore[2]= pXKB[0];
	    if (groupWidth>1)	pCore[3]= pXKB[1];
	    for (n=2;n<groupWidth;n++) {
		pCore[nOut+(n-2)]= pXKB[n];
	    }
	    if (groupWidth>2)
		nOut+= (groupWidth-2);
	}
	pXKB+= XkbKeyGroupsWidth(xkb,key);
	for (n=XkbGroup3Index;n<nGroups;n++) {
	    register int s;
	    groupWidth= XkbKeyGroupWidth(xkb,key,n);
	    for (s=0;s<groupWidth;s++) {
		pCore[nOut++]= pXKB[s];
	    }
	    pXKB+= XkbKeyGroupsWidth(xkb,key);
	}
d524 1
a524 1
XkbSetRepeatKeys(DeviceIntPtr pXDev,int key,int onoff)
d527 19
a545 16
	xkbControlsNotify	cn;
	XkbControlsPtr		ctrls = pXDev->key->xkbInfo->desc->ctrls;
	XkbControlsRec 		old;
	old = *ctrls;

	if (key== -1) {	/* global autorepeat setting changed */
	    if (onoff)	ctrls->enabled_ctrls |= XkbRepeatKeysMask;
	    else	ctrls->enabled_ctrls &= ~XkbRepeatKeysMask;
	}
	else if (pXDev->kbdfeed) {
	    ctrls->per_key_repeat[key/8] = 
		pXDev->kbdfeed->ctrl.autoRepeats[key/8];
	}
	
	if (XkbComputeControlsNotify(pXDev,&old,ctrls,&cn,TRUE))
	    XkbSendControlsNotify(pXDev,&cn);
d578 1
a578 1
            XkbSetCauseCoreReq(&cause,X_SetModifierMapping,client);
d597 1
a597 1
XkbDisableComputedAutoRepeats(DeviceIntPtr dev,unsigned key)
d599 2
a600 2
XkbSrvInfoPtr	xkbi = dev->key->xkbInfo;
xkbMapNotify	mn;
d602 1
a602 1
    xkbi->desc->server->explicit[key]|= XkbExplicitAutoRepeatMask;
d604 4
a607 4
    mn.changed= XkbExplicitComponentsMask;
    mn.firstKeyExplicit= key;
    mn.nKeyExplicit= 1;
    XkbSendMapNotify(dev,&mn);
d612 1
a612 1
XkbStateChangedFlags(XkbStatePtr old,XkbStatePtr new)
d614 1
a614 1
int		changed;
d616 20
a635 16
    changed=(old->group!=new->group?XkbGroupStateMask:0);
    changed|=(old->base_group!=new->base_group?XkbGroupBaseMask:0);
    changed|=(old->latched_group!=new->latched_group?XkbGroupLatchMask:0);
    changed|=(old->locked_group!=new->locked_group?XkbGroupLockMask:0);
    changed|=(old->mods!=new->mods?XkbModifierStateMask:0);
    changed|=(old->base_mods!=new->base_mods?XkbModifierBaseMask:0);
    changed|=(old->latched_mods!=new->latched_mods?XkbModifierLatchMask:0);
    changed|=(old->locked_mods!=new->locked_mods?XkbModifierLockMask:0);
    changed|=(old->compat_state!=new->compat_state?XkbCompatStateMask:0);
    changed|=(old->grab_mods!=new->grab_mods?XkbGrabModsMask:0);
    if (old->compat_grab_mods!=new->compat_grab_mods)
	changed|= XkbCompatGrabModsMask;
    changed|=(old->lookup_mods!=new->lookup_mods?XkbLookupModsMask:0);
    if (old->compat_lookup_mods!=new->compat_lookup_mods)
	changed|= XkbCompatLookupModsMask;
    changed|=(old->ptr_buttons!=new->ptr_buttons?XkbPointerButtonMask:0);
d642 3
a644 3
CARD16 		grp_mask;
XkbStatePtr	state= &xkbi->state;
XkbCompatMapPtr	map;
d649 8
a656 8
    map= xkbi->desc->compat;
    grp_mask= map->groups[state->group].mask;
    state->compat_state = state->mods|grp_mask;
    state->compat_lookup_mods= state->lookup_mods|grp_mask;

    if (xkbi->desc->ctrls->enabled_ctrls&XkbIgnoreGroupLockMask)
	 grp_mask= map->groups[state->base_group].mask;
    state->compat_grab_mods= state->grab_mods|grp_mask;
d661 1
a661 1
XkbAdjustGroup(int group,XkbControlsPtr ctrls)
d663 28
a690 1
unsigned	act;
d692 9
a700 32
    act= XkbOutOfRangeGroupAction(ctrls->groups_wrap);
    if (group<0) {
	while ( group < 0 )  {
	    if (act==XkbClampIntoRange) {
		group= XkbGroup1Index;
	    }
	    else if (act==XkbRedirectIntoRange) {
		int newGroup;
		newGroup= XkbOutOfRangeGroupNumber(ctrls->groups_wrap);
		if (newGroup>=ctrls->num_groups)
		     group= XkbGroup1Index;
		else group= newGroup;
	    }
	    else {
		group+= ctrls->num_groups;
	    }
	}
    }
    else if (group>=ctrls->num_groups) {
	if (act==XkbClampIntoRange) {
	    group= ctrls->num_groups-1;
	}
	else if (act==XkbRedirectIntoRange) {
	    int newGroup;
	    newGroup= XkbOutOfRangeGroupNumber(ctrls->groups_wrap);
	    if (newGroup>=ctrls->num_groups)
		 group= XkbGroup1Index;
	    else group= newGroup;
	}
	else {
	    group%= ctrls->num_groups;
	}
d708 3
a710 3
XkbStatePtr	state= &xkbi->state;
XkbControlsPtr	ctrls= xkbi->desc->ctrls;
unsigned char	grp;
d715 15
a729 15
    state->mods= (state->base_mods|state->latched_mods|state->locked_mods);
    state->lookup_mods= state->mods&(~ctrls->internal.mask);
    state->grab_mods= state->lookup_mods&(~ctrls->ignore_lock.mask);
    state->grab_mods|= 
	((state->base_mods|state->latched_mods)&ctrls->ignore_lock.mask);


    grp= state->locked_group;
    if (grp>=ctrls->num_groups)
	state->locked_group= XkbAdjustGroup(XkbCharToInt(grp),ctrls);

    grp= state->locked_group+state->base_group+state->latched_group;
    if (grp>=ctrls->num_groups)
	 state->group= XkbAdjustGroup(XkbCharToInt(grp),ctrls);
    else state->group= grp;
d737 14
a750 14
XkbCheckSecondaryEffects(	XkbSrvInfoPtr		xkbi,
				unsigned		which,
				XkbChangesPtr 		changes,
				XkbEventCausePtr	cause)
{
    if (which&XkbStateNotifyMask) {
	XkbStateRec old;
	old= xkbi->state;
	changes->state_changes|= XkbStateChangedFlags(&old,&xkbi->state);
	XkbComputeDerivedState(xkbi);
    }
    if (which&XkbIndicatorStateNotifyMask)
	XkbUpdateIndicators(xkbi->device,XkbAllIndicatorsMask,TRUE,changes,
									cause);
d757 27
a783 27
XkbEnableDisableControls(	XkbSrvInfoPtr		xkbi,
				unsigned long		change,
				unsigned long		newValues,
				XkbChangesPtr		changes,
				XkbEventCausePtr	cause)
{
XkbControlsPtr		ctrls;
unsigned 		old;
XkbSrvLedInfoPtr	sli;

    ctrls= xkbi->desc->ctrls;
    old= ctrls->enabled_ctrls;
    ctrls->enabled_ctrls&= ~change;
    ctrls->enabled_ctrls|= (change&newValues);
    if (old==ctrls->enabled_ctrls)
	return FALSE;
    if (cause!=NULL) {
	xkbControlsNotify cn;
	cn.numGroups= ctrls->num_groups;
	cn.changedControls= XkbControlsEnabledMask;
	cn.enabledControls= ctrls->enabled_ctrls;
	cn.enabledControlChanges= (ctrls->enabled_ctrls^old);
	cn.keycode= cause->kc;
	cn.eventType= cause->event;
	cn.requestMajor= cause->mjr;
	cn.requestMinor= cause->mnr;
	XkbSendControlsNotify(xkbi->device,&cn);
d786 10
a795 9
	/* Yes, this really should be an XOR.  If ctrls->enabled_ctrls_changes*/
	/* is non-zero, the controls in question changed already in "this" */
	/* request and this change merely undoes the previous one.  By the */
	/* same token, we have to figure out whether or not ControlsEnabled */
	/* should be set or not in the changes structure */
	changes->ctrls.enabled_ctrls_changes^= (ctrls->enabled_ctrls^old);
	if (changes->ctrls.enabled_ctrls_changes)
	     changes->ctrls.changed_ctrls|= XkbControlsEnabledMask;
	else changes->ctrls.changed_ctrls&= ~XkbControlsEnabledMask;
d797 2
a798 2
    sli= XkbFindSrvLedInfo(xkbi->device,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(xkbi->device,sli->usesControls,TRUE,changes,cause);
d807 1
a807 1
XkbLookupNamedGeometry(DeviceIntPtr dev,Atom name,Bool *shouldFree)
d809 2
a810 2
XkbSrvInfoPtr	xkbi=	dev->key->xkbInfo;
XkbDescPtr	xkb=	xkbi->desc;
d812 9
a820 9
    *shouldFree= 0;
    if (name==None) {
	if (xkb->geom!=NULL)
	    return xkb->geom;
	name= xkb->names->geometry;
    }
    if ((xkb->geom!=NULL)&&(xkb->geom->name==name))
	return xkb->geom;
    *shouldFree= 1;
d825 1
a825 1
XkbConvertCase(register KeySym sym, KeySym *lower, KeySym *upper)
d829 78
a906 78
    switch(sym >> 8) {
    case 0: /* Latin 1 */
	if ((sym >= XK_A) && (sym <= XK_Z))
	    *lower += (XK_a - XK_A);
	else if ((sym >= XK_a) && (sym <= XK_z))
	    *upper -= (XK_a - XK_A);
	else if ((sym >= XK_Agrave) && (sym <= XK_Odiaeresis))
	    *lower += (XK_agrave - XK_Agrave);
	else if ((sym >= XK_agrave) && (sym <= XK_odiaeresis))
	    *upper -= (XK_agrave - XK_Agrave);
	else if ((sym >= XK_Ooblique) && (sym <= XK_Thorn))
	    *lower += (XK_oslash - XK_Ooblique);
	else if ((sym >= XK_oslash) && (sym <= XK_thorn))
	    *upper -= (XK_oslash - XK_Ooblique);
	break;
    case 1: /* Latin 2 */
	/* Assume the KeySym is a legal value (ignore discontinuities) */
	if (sym == XK_Aogonek)
	    *lower = XK_aogonek;
	else if (sym >= XK_Lstroke && sym <= XK_Sacute)
	    *lower += (XK_lstroke - XK_Lstroke);
	else if (sym >= XK_Scaron && sym <= XK_Zacute)
	    *lower += (XK_scaron - XK_Scaron);
	else if (sym >= XK_Zcaron && sym <= XK_Zabovedot)
	    *lower += (XK_zcaron - XK_Zcaron);
	else if (sym == XK_aogonek)
	    *upper = XK_Aogonek;
	else if (sym >= XK_lstroke && sym <= XK_sacute)
	    *upper -= (XK_lstroke - XK_Lstroke);
	else if (sym >= XK_scaron && sym <= XK_zacute)
	    *upper -= (XK_scaron - XK_Scaron);
	else if (sym >= XK_zcaron && sym <= XK_zabovedot)
	    *upper -= (XK_zcaron - XK_Zcaron);
	else if (sym >= XK_Racute && sym <= XK_Tcedilla)
	    *lower += (XK_racute - XK_Racute);
	else if (sym >= XK_racute && sym <= XK_tcedilla)
	    *upper -= (XK_racute - XK_Racute);
	break;
    case 2: /* Latin 3 */
	/* Assume the KeySym is a legal value (ignore discontinuities) */
	if (sym >= XK_Hstroke && sym <= XK_Hcircumflex)
	    *lower += (XK_hstroke - XK_Hstroke);
	else if (sym >= XK_Gbreve && sym <= XK_Jcircumflex)
	    *lower += (XK_gbreve - XK_Gbreve);
	else if (sym >= XK_hstroke && sym <= XK_hcircumflex)
	    *upper -= (XK_hstroke - XK_Hstroke);
	else if (sym >= XK_gbreve && sym <= XK_jcircumflex)
	    *upper -= (XK_gbreve - XK_Gbreve);
	else if (sym >= XK_Cabovedot && sym <= XK_Scircumflex)
	    *lower += (XK_cabovedot - XK_Cabovedot);
	else if (sym >= XK_cabovedot && sym <= XK_scircumflex)
	    *upper -= (XK_cabovedot - XK_Cabovedot);
	break;
    case 3: /* Latin 4 */
	/* Assume the KeySym is a legal value (ignore discontinuities) */
	if (sym >= XK_Rcedilla && sym <= XK_Tslash)
	    *lower += (XK_rcedilla - XK_Rcedilla);
	else if (sym >= XK_rcedilla && sym <= XK_tslash)
	    *upper -= (XK_rcedilla - XK_Rcedilla);
	else if (sym == XK_ENG)
	    *lower = XK_eng;
	else if (sym == XK_eng)
	    *upper = XK_ENG;
	else if (sym >= XK_Amacron && sym <= XK_Umacron)
	    *lower += (XK_amacron - XK_Amacron);
	else if (sym >= XK_amacron && sym <= XK_umacron)
	    *upper -= (XK_amacron - XK_Amacron);
	break;
    case 6: /* Cyrillic */
	/* Assume the KeySym is a legal value (ignore discontinuities) */
	if (sym >= XK_Serbian_DJE && sym <= XK_Serbian_DZE)
	    *lower -= (XK_Serbian_DJE - XK_Serbian_dje);
	else if (sym >= XK_Serbian_dje && sym <= XK_Serbian_dze)
	    *upper += (XK_Serbian_DJE - XK_Serbian_dje);
	else if (sym >= XK_Cyrillic_YU && sym <= XK_Cyrillic_HARDSIGN)
	    *lower -= (XK_Cyrillic_YU - XK_Cyrillic_yu);
	else if (sym >= XK_Cyrillic_yu && sym <= XK_Cyrillic_hardsign)
	    *upper += (XK_Cyrillic_YU - XK_Cyrillic_yu);
d908 13
a920 13
    case 7: /* Greek */
	/* Assume the KeySym is a legal value (ignore discontinuities) */
	if (sym >= XK_Greek_ALPHAaccent && sym <= XK_Greek_OMEGAaccent)
	    *lower += (XK_Greek_alphaaccent - XK_Greek_ALPHAaccent);
	else if (sym >= XK_Greek_alphaaccent && sym <= XK_Greek_omegaaccent &&
		 sym != XK_Greek_iotaaccentdieresis &&
		 sym != XK_Greek_upsilonaccentdieresis)
	    *upper -= (XK_Greek_alphaaccent - XK_Greek_ALPHAaccent);
	else if (sym >= XK_Greek_ALPHA && sym <= XK_Greek_OMEGA)
	    *lower += (XK_Greek_alpha - XK_Greek_ALPHA);
	else if (sym >= XK_Greek_alpha && sym <= XK_Greek_omega &&
		 sym != XK_Greek_finalsmallsigma)
	    *upper -= (XK_Greek_alpha - XK_Greek_ALPHA);
d981 1
a981 1
                                   src->map->num_types * sizeof(XkbKeyTypeRec));
d986 2
a987 2
                          (src->map->num_types - dst->map->num_types) *
                            sizeof(XkbKeyTypeRec));
d1018 1
a1018 1
                                       stype->num_levels * sizeof(Atom));
d1051 2
a1052 2
                                           stype->map_count *
                                             sizeof(XkbKTMapEntryRec));
d1060 1
a1060 1
                                           sizeof(XkbKTMapEntryRec));
d1080 2
a1081 2
                                           stype->map_count *
                                             sizeof(XkbModsRec));
d1088 1
a1088 2
                            tmp = malloc(stype->map_count *
                                         sizeof(XkbModsRec));
d1202 2
a1203 2
       dst->server->size_acts = src->server->size_acts;
       dst->server->num_acts = src->server->num_acts;
d1422 2
a1423 2
                for (i = src->geom->num_properties, dprop = dst->geom->properties + i;
                     i < dst->geom->num_properties;
d1431 4
a1434 2
            if (!XkbGeomRealloc((void **)&dst->geom->properties, dst->geom->sz_properties, src->geom->num_properties,
                                sizeof(XkbPropertyRec), XKB_GEOM_CLEAR_EXCESS))
d1441 3
a1443 4
                  sprop = src->geom->properties,
                  dprop = dst->geom->properties;
                 i < src->geom->num_properties;
                 i++, sprop++, dprop++) {
d1472 1
a1472 2
                     i < dst->geom->num_properties;
                     i++, dprop++) {
d1488 1
a1488 2
                     i < dst->geom->num_colors;
                     i++, dcolor++) {
d1494 4
a1497 2
            if (!XkbGeomRealloc((void **)&dst->geom->colors, dst->geom->sz_colors, src->geom->num_colors,
                                sizeof(XkbColorRec), XKB_GEOM_CLEAR_EXCESS))
d1502 3
a1504 4
                  scolor = src->geom->colors,
                  dcolor = dst->geom->colors;
                 i < src->geom->num_colors;
                 i++, scolor++, dcolor++) {
d1525 1
a1525 2
                     i < dst->geom->num_colors;
                     i++, dcolor++) {
d1540 1
a1540 2
                 i < dst->geom->num_shapes;
                 i++, dshape++) {
d1542 1
a1542 2
                     j < dshape->num_outlines;
                     j++, doutline++) {
d1559 4
a1562 2
            if (!XkbGeomRealloc((void **)&dst->geom->shapes, dst->geom->sz_shapes, src->geom->num_shapes,
                                sizeof(XkbShapeRec), XKB_GEOM_CLEAR_ALL))
d1566 1
a1566 2
                 i < src->geom->num_shapes;
                 i++, sshape++, dshape++) {
d1572 1
a1572 1
                    
d1574 2
a1575 2
                          soutline = sshape->outlines,
                          doutline = dshape->outlines;
d1580 1
a1580 1
                                          sizeof(XkbPointRec));
d1605 1
a1605 1
                            sshape->approx - sshape->outlines;
d1608 5
a1612 4
                            dshape->approx = dshape->outlines + approx_idx;
                    } else {
                            LogMessage(X_WARNING, "XKB: approx outline "
                                            "index is out of range\n");
d1620 1
a1620 1
                            sshape->primary - sshape->outlines;
d1623 5
a1627 4
                            dshape->primary = dshape->outlines + primary_idx;
                    } else {
                            LogMessage(X_WARNING, "XKB: primary outline "
                                            "index is out of range\n");
d1649 1
a1649 2
                 i < dst->geom->num_sections;
                 i++, dsection++) {
d1651 1
a1651 2
                     j < dsection->num_rows;
                     j++, drow++) {
d1661 1
a1661 2
                     j < dsection->num_doodads;
                     j++, ddoodad++) {
d1667 4
a1670 4
                     }
                     else if (ddoodad->any.type == XkbLogoDoodad) {
                         free(ddoodad->logo.logo_name);
                         ddoodad->logo.logo_name = NULL;
d1682 4
a1685 2
            if (!XkbGeomRealloc((void **)&dst->geom->sections, dst->geom->sz_sections, src->geom->num_sections,
                                sizeof(XkbSectionRec), XKB_GEOM_CLEAR_ALL))
d1691 3
a1693 4
                  ssection = src->geom->sections,
                  dsection = dst->geom->sections;
                 i < src->geom->num_sections;
                 i++, ssection++, dsection++) {
d1705 1
a1705 2
                     j < ssection->num_rows;
                     j++, srow++, drow++) {
d1734 4
a1737 5
                      sdoodad = ssection->doodads,
                      ddoodad = dsection->doodads;
                     k < ssection->num_doodads;
                     k++, sdoodad++, ddoodad++) {
                    memcpy(ddoodad , sdoodad, sizeof(XkbDoodadRec));
d1740 1
a1740 2
                            ddoodad->text.text =
                             strdup(sdoodad->text.text);
d1742 1
a1742 2
                            ddoodad->text.font =
                             strdup(sdoodad->text.font);
d1747 1
a1747 1
                             strdup(sdoodad->logo.logo_name);
d1768 12
a1779 13
                  ddoodad = dst->geom->doodads +
                             src->geom->num_doodads;
                 i < dst->geom->num_doodads;
                 i++, ddoodad++) {
                 if (ddoodad->any.type == XkbTextDoodad) {
                     free(ddoodad->text.text);
                     ddoodad->text.text = NULL;
                     free(ddoodad->text.font);
                     ddoodad->text.font = NULL;
                 }
                 else if (ddoodad->any.type == XkbLogoDoodad) {
                     free(ddoodad->logo.logo_name);
                     ddoodad->logo.logo_name = NULL;
d1787 4
a1790 2
            if (!XkbGeomRealloc((void **)&dst->geom->doodads, dst->geom->sz_doodads, src->geom->num_doodads,
                                sizeof(XkbDoodadRec), XKB_GEOM_CLEAR_ALL))
d1796 4
a1799 5
                  sdoodad = src->geom->doodads,
                  ddoodad = dst->geom->doodads;
                 i < src->geom->num_doodads;
                 i++, sdoodad++, ddoodad++) {
                memcpy(ddoodad , sdoodad, sizeof(XkbDoodadRec));
d1809 1
a1809 1
                          strdup(sdoodad->logo.logo_name);
d1830 4
a1833 2
            if (!XkbGeomRealloc((void **)&dst->geom->key_aliases, dst->geom->sz_key_aliases, src->geom->num_key_aliases,
                                2 * XkbKeyNameLength, XKB_GEOM_CLEAR_NONE))
d1849 1
a1849 1
        
d1859 1
a1859 1
                strlen(dst->geom->label_font)) {
d1861 1
a1861 1
                               strlen(src->geom->label_font) + 1);
d1884 1
a1884 2
    else
    {
d2008 1
a2008 1
    nkn.oldDeviceID = dst->id; /* maybe src->id? */
d2012 1
a2012 1
    nkn.requestMinor = X_kbSetMap; /* Near enough's good enough. */
d2036 4
a2039 3
    if (XkbKeyNumGroups(xkb,keycode) > 1U) {
        if (effectiveGroup >= XkbKeyNumGroups(xkb,keycode)) {
            unsigned int gi = XkbKeyGroupInfo(xkb,keycode);
d2041 12
a2052 12
                default:
                case XkbWrapIntoRange:
                    effectiveGroup %= XkbKeyNumGroups(xkb, keycode);
                    break;
                case XkbClampIntoRange:
                    effectiveGroup = XkbKeyNumGroups(xkb, keycode) - 1;
                    break;
                case XkbRedirectIntoRange:
                    effectiveGroup = XkbOutOfRangeGroupInfo(gi);
                    if (effectiveGroup >= XkbKeyNumGroups(xkb, keycode))
                        effectiveGroup = 0;
                    break;
d2056 2
a2057 1
    else effectiveGroup = XkbGroup1Index;
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d345 1
d352 5
a356 3
	(changes->ctrls.enabled_ctrls_changes&XkbPerKeyRepeatMask)) {
        memcpy(pXDev->kbdfeed->ctrl.autoRepeats,repeat, XkbPerKeyBitArraySize);
	(*pXDev->kbdfeed->CtrlProc)(pXDev, &pXDev->kbdfeed->ctrl);
d1401 9
a1409 12
            if (src->geom->num_properties != dst->geom->sz_properties) {
                /* If we've got more properties in the destination than
                 * the source, run through and free all the excess ones
                 * first. */
                if (src->geom->num_properties < dst->geom->sz_properties) {
                    for (i = src->geom->num_properties,
                         dprop = dst->geom->properties + i;
                         i < dst->geom->num_properties;
                         i++, dprop++) {
                        free(dprop->name);
                        free(dprop->value);
                    }
a1410 11

                if (dst->geom->sz_properties)
                    tmp = realloc(dst->geom->properties,
                                   src->geom->num_properties *
                                    sizeof(XkbPropertyRec));
                else
                    tmp = malloc(src->geom->num_properties *
                                  sizeof(XkbPropertyRec));
                if (!tmp)
                    return FALSE;
                dst->geom->properties = tmp;
d1413 4
a1420 6
            if (dst->geom->sz_properties > dst->geom->num_properties) {
                memset(dst->geom->properties + dst->geom->num_properties, 0,
                      (dst->geom->sz_properties - dst->geom->num_properties) *
                      sizeof(XkbPropertyRec));
            }

d1469 5
a1473 8
            if (src->geom->num_colors != dst->geom->sz_colors) {
                if (src->geom->num_colors < dst->geom->sz_colors) {
                    for (i = src->geom->num_colors,
                         dcolor = dst->geom->colors + i;
                         i < dst->geom->num_colors;
                         i++, dcolor++) {
                        free(dcolor->spec);
                    }
a1474 11

                if (dst->geom->sz_colors)
                    tmp = realloc(dst->geom->colors,
                                   src->geom->num_colors *
                                    sizeof(XkbColorRec));
                else
                    tmp = malloc(src->geom->num_colors *
                                  sizeof(XkbColorRec));
                if (!tmp)
                    return FALSE;
                dst->geom->colors = tmp;
d1477 4
a1482 6
            if (dst->geom->sz_colors > dst->geom->num_colors) {
                memset(dst->geom->colors + dst->geom->num_colors, 0,
                      (dst->geom->sz_colors - dst->geom->num_colors) *
                      sizeof(XkbColorRec));
            }

d1544 3
a1546 2
            tmp = calloc(src->geom->num_shapes, sizeof(XkbShapeRec));
            if (!tmp)
a1547 1
            dst->geom->shapes = tmp;
a1663 1
            dst->geom->sections = NULL;
d1667 3
a1669 7
            if (dst->geom->sz_sections)
                tmp = realloc(dst->geom->sections,
                               src->geom->num_sections *
                                sizeof(XkbSectionRec));
            else
                tmp = malloc(src->geom->num_sections * sizeof(XkbSectionRec));
            if (!tmp)
a1670 2
            memset(tmp, 0, src->geom->num_sections * sizeof(XkbSectionRec));
            dst->geom->sections = tmp;
a1772 1
            dst->geom->doodads = NULL;
d1776 3
a1778 8
            if (dst->geom->sz_doodads)
                tmp = realloc(dst->geom->doodads,
                               src->geom->num_doodads *
                                sizeof(XkbDoodadRec));
            else
                tmp = malloc(src->geom->num_doodads *
                              sizeof(XkbDoodadRec));
            if (!tmp)
a1779 2
            memset(tmp, 0, src->geom->num_doodads * sizeof(XkbDoodadRec));
            dst->geom->doodads = tmp;
d1816 6
a1821 11
            if (src->geom->num_key_aliases != dst->geom->sz_key_aliases) {
                if (dst->geom->sz_key_aliases)
                    tmp = realloc(dst->geom->key_aliases,
                                   src->geom->num_key_aliases *
                                    2 * XkbKeyNameLength);
                else
                    tmp = malloc(src->geom->num_key_aliases *
                                  2 * XkbKeyNameLength);
                if (!tmp)
                    return FALSE;
                dst->geom->key_aliases = tmp;
d1823 1
a1823 2
                dst->geom->sz_key_aliases = src->geom->num_key_aliases;
            }
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d285 1
a285 1
        bzero(newVMods,XkbNumVirtualMods);
d413 1
a413 1
    syms = xcalloc(1, sizeof(*syms));
d430 1
a430 1
    syms->map = xcalloc(tmp, sizeof(*syms->map));
d432 1
a432 1
        xfree(syms);
d591 1
a591 1
    bzero(&mn,sizeof(mn));
d914 1
a914 1
            tmp = xcalloc(1, sizeof(XkbClientMapRec));
d922 2
a923 5
                if (dst->map->syms)
                    tmp = xrealloc(dst->map->syms,
                                   src->map->size_syms * sizeof(KeySym));
                else
                    tmp = xalloc(src->map->size_syms * sizeof(KeySym));
d933 2
a934 4
            if (dst->map->syms) {
                xfree(dst->map->syms);
                dst->map->syms = NULL;
            }
d941 2
a942 7
                if (dst->map->key_sym_map)
                    tmp = xrealloc(dst->map->key_sym_map,
                                   (src->max_key_code + 1) *
                                     sizeof(XkbSymMapRec));
                else
                    tmp = xalloc((src->max_key_code + 1) *
                                 sizeof(XkbSymMapRec));
d951 2
a952 4
            if (dst->map->key_sym_map) {
                xfree(dst->map->key_sym_map);
                dst->map->key_sym_map = NULL;
            }
d959 1
a959 1
                    tmp = xrealloc(dst->map->types,
d964 1
a964 1
                    bzero(dst->map->types + dst->map->num_types,
d969 1
a969 1
                    tmp = xcalloc(src->map->num_types, sizeof(XkbKeyTypeRec));
d979 1
a979 2
                    if (dtype->level_names)
                        xfree(dtype->level_names);
d983 2
a984 4
                        if (dtype->map)
                            xfree(dtype->map);
                        if (dtype->preserve)
                            xfree(dtype->preserve);
d996 1
a996 1
                        tmp = xrealloc(dtype->level_names,
d1004 1
a1004 1
                        tmp = xalloc(stype->num_levels * sizeof(Atom));
d1016 1
a1016 1
                        xfree(dtype->level_names);
d1029 1
a1029 1
                            tmp = xrealloc(dtype->map,
d1038 1
a1038 1
                            tmp = xalloc(stype->map_count *
d1050 1
a1050 1
                            xfree(dtype->map);
d1058 1
a1058 1
                            tmp = xrealloc(dtype->preserve,
d1067 1
a1067 1
                            tmp = xalloc(stype->map_count *
d1079 1
a1079 1
                            xfree(dtype->preserve);
d1087 2
a1088 4
                        if (dtype->map)
                            xfree(dtype->map);
                        if (dtype->preserve)
                            xfree(dtype->preserve);
d1103 1
a1103 2
                    if (dtype->level_names)
                        xfree(dtype->level_names);
d1105 1
a1105 1
                        xfree(dtype->map);
d1107 1
a1107 1
                        xfree(dtype->preserve);
a1108 2
                xfree(dst->map->types);
                dst->map->types = NULL;
d1110 2
d1118 1
a1118 4
                if (dst->map->modmap)
                    tmp = xrealloc(dst->map->modmap, src->max_key_code + 1);
                else
                    tmp = xalloc(src->max_key_code + 1);
d1126 2
a1127 4
            if (dst->map->modmap) {
                xfree(dst->map->modmap);
                dst->map->modmap = NULL;
            }
d1146 1
a1146 1
            tmp = xcalloc(1, sizeof(XkbServerMapRec));
d1154 1
a1154 4
                if (dst->server->explicit)
                    tmp = xrealloc(dst->server->explicit, src->max_key_code + 1);
                else
                    tmp = xalloc(src->max_key_code + 1);
d1163 2
a1164 4
            if (dst->server->explicit) {
                xfree(dst->server->explicit);
                dst->server->explicit = NULL;
            }
d1169 2
a1170 5
                if (dst->server->acts)
                    tmp = xrealloc(dst->server->acts,
                                   src->server->size_acts * sizeof(XkbAction));
                else
                    tmp = xalloc(src->server->size_acts * sizeof(XkbAction));
d1179 2
a1180 4
            if (dst->server->acts) {
                xfree(dst->server->acts);
                dst->server->acts = NULL;
            }
d1187 2
a1188 7
                if (dst->server->key_acts)
                    tmp = xrealloc(dst->server->key_acts,
                                   (src->max_key_code + 1) *
                                     sizeof(unsigned short));
                else
                    tmp = xalloc((src->max_key_code + 1) *
                                 sizeof(unsigned short));
d1197 2
a1198 4
            if (dst->server->key_acts) {
                xfree(dst->server->key_acts);
                dst->server->key_acts = NULL;
            }
d1203 2
a1204 7
                if (dst->server->behaviors)
                    tmp = xrealloc(dst->server->behaviors,
                                   (src->max_key_code + 1) *
                                   sizeof(XkbBehavior));
                else
                    tmp = xalloc((src->max_key_code + 1) *
                                 sizeof(XkbBehavior));
d1213 2
a1214 4
            if (dst->server->behaviors) {
                xfree(dst->server->behaviors);
                dst->server->behaviors = NULL;
            }
d1221 2
a1222 7
                if (dst->server->vmodmap)
                    tmp = xrealloc(dst->server->vmodmap,
                                   (src->max_key_code + 1) *
                                   sizeof(unsigned short));
                else
                    tmp = xalloc((src->max_key_code + 1) *
                                 sizeof(unsigned short));
d1231 2
a1232 4
            if (dst->server->vmodmap) {
                xfree(dst->server->vmodmap);
                dst->server->vmodmap = NULL;
            }
d1251 1
a1251 1
            dst->names = xcalloc(1, sizeof(XkbNamesRec));
d1258 2
a1259 6
                if (dst->names->keys)
                    tmp = xrealloc(dst->names->keys, (src->max_key_code + 1) *
                                   sizeof(XkbKeyNameRec));
                else
                    tmp = xalloc((src->max_key_code + 1) *
                                 sizeof(XkbKeyNameRec));
d1268 2
a1269 4
            if (dst->names->keys) {
                xfree(dst->names->keys);
                dst->names->keys = NULL;
            }
d1274 3
a1276 7
                if (dst->names->key_aliases)
                    tmp = xrealloc(dst->names->key_aliases,
                                   src->names->num_key_aliases *
                                     sizeof(XkbKeyAliasRec));
                else
                    tmp = xalloc(src->names->num_key_aliases *
                                 sizeof(XkbKeyAliasRec));
d1285 2
a1286 4
            if (dst->names->key_aliases) {
                xfree(dst->names->key_aliases);
                dst->names->key_aliases = NULL;
            }
d1292 2
a1293 5
                if (dst->names->radio_groups)
                    tmp = xrealloc(dst->names->radio_groups,
                                   src->names->num_rg * sizeof(Atom));
                else
                    tmp = xalloc(src->names->num_rg * sizeof(Atom));
d1302 1
a1302 2
            if (dst->names->radio_groups)
                xfree(dst->names->radio_groups);
d1336 1
a1336 1
            dst->compat = xcalloc(1, sizeof(XkbCompatMapRec));
d1343 2
a1344 7
                if (dst->compat->sym_interpret)
                    tmp = xrealloc(dst->compat->sym_interpret,
                                   src->compat->num_si *
                                     sizeof(XkbSymInterpretRec));
                else
                    tmp = xalloc(src->compat->num_si *
                                 sizeof(XkbSymInterpretRec));
d1357 1
a1357 1
                xfree(dst->compat->sym_interpret);
d1391 1
a1391 1
            dst->geom = xcalloc(sizeof(XkbGeometryRec), 1);
d1407 2
a1408 2
                        xfree(dprop->name);
                        xfree(dprop->value);
d1413 1
a1413 1
                    tmp = xrealloc(dst->geom->properties,
d1417 1
a1417 1
                    tmp = xalloc(src->geom->num_properties *
d1429 1
a1429 1
                bzero(dst->geom->properties + dst->geom->num_properties,
d1441 1
a1441 1
                        tmp = xrealloc(dprop->name, strlen(sprop->name) + 1);
d1447 1
a1447 1
                        tmp = xrealloc(dprop->value, strlen(sprop->value) + 1);
d1469 2
a1470 2
                    xfree(dprop->name);
                    xfree(dprop->value);
d1472 1
a1472 1
                xfree(dst->geom->properties);
d1488 1
a1488 1
                        xfree(dcolor->spec);
d1493 1
a1493 1
                    tmp = xrealloc(dst->geom->colors,
d1497 1
a1497 1
                    tmp = xalloc(src->geom->num_colors *
d1507 1
a1507 1
                bzero(dst->geom->colors + dst->geom->num_colors,
d1519 1
a1519 1
                        tmp = xrealloc(dcolor->spec, strlen(scolor->spec) + 1);
d1539 1
a1539 1
                    xfree(dcolor->spec);
d1541 1
a1541 1
                xfree(dst->geom->colors);
d1559 1
a1559 1
                        xfree(doutline->points);
d1563 1
a1563 1
                    xfree(dshape->outlines);
d1573 1
a1573 1
            tmp = xcalloc(src->geom->num_shapes, sizeof(XkbShapeRec));
d1582 1
a1582 1
                    tmp = xcalloc(sshape->num_outlines, sizeof(XkbOutlineRec));
d1593 1
a1593 1
                            tmp = xalloc(soutline->num_points *
d1649 1
a1649 1
                xfree(dst->geom->shapes);
d1667 1
a1667 1
                        xfree(drow->keys);
d1671 1
a1671 1
                    xfree(dsection->rows);
d1678 4
a1681 8
                        if (ddoodad->text.text) {
                            xfree(ddoodad->text.text);
                            ddoodad->text.text = NULL;
                        }
                        if (ddoodad->text.font) {
                            xfree(ddoodad->text.font);
                            ddoodad->text.font = NULL;
                        }
d1684 2
a1685 4
                        if (ddoodad->logo.logo_name) {
                            xfree(ddoodad->logo.logo_name);
                            ddoodad->logo.logo_name = NULL;
                        }
d1689 1
a1689 2
                if (dsection->num_doodads)
                    xfree(dsection->doodads);
d1698 1
a1698 1
                tmp = xrealloc(dst->geom->sections,
d1702 1
a1702 1
                tmp = xalloc(src->geom->num_sections * sizeof(XkbSectionRec));
d1717 1
a1717 1
                    tmp = xcalloc(ssection->num_rows, sizeof(XkbRowRec));
d1729 1
a1729 1
                        tmp = xalloc(srow->num_keys * sizeof(XkbKeyRec));
d1745 1
a1745 1
                    tmp = xcalloc(ssection->num_doodads, sizeof(XkbDoodadRec));
d1764 1
a1764 1
                             xstrdup(sdoodad->text.text);
d1767 1
a1767 1
                             xstrdup(sdoodad->text.font);
d1772 1
a1772 1
                             xstrdup(sdoodad->logo.logo_name);
d1782 1
a1782 1
                xfree(dst->geom->sections);
d1798 4
a1801 8
                    if (ddoodad->text.text) {
                        xfree(ddoodad->text.text);
                        ddoodad->text.text = NULL;
                    }
                    if (ddoodad->text.font) {
                        xfree(ddoodad->text.font);
                        ddoodad->text.font = NULL;
                    }
d1804 2
a1805 4
                    if (ddoodad->logo.logo_name) {
                        xfree(ddoodad->logo.logo_name);
                        ddoodad->logo.logo_name = NULL;
                    }
d1814 1
a1814 1
                tmp = xrealloc(dst->geom->doodads,
d1818 1
a1818 1
                tmp = xalloc(src->geom->num_doodads *
d1835 1
a1835 1
                        ddoodad->text.text = xstrdup(sdoodad->text.text);
d1837 1
a1837 1
                        ddoodad->text.font = xstrdup(sdoodad->text.font);
d1842 1
a1842 1
                          xstrdup(sdoodad->logo.logo_name);
d1850 1
a1850 1
                xfree(dst->geom->doodads);
d1862 1
a1862 1
                    tmp = xrealloc(dst->geom->key_aliases,
d1866 1
a1866 1
                    tmp = xalloc(src->geom->num_key_aliases *
d1881 1
a1881 3
            if (dst->geom->key_aliases) {
                xfree(dst->geom->key_aliases);
            }
d1890 1
a1890 1
                tmp = xalloc(strlen(src->geom->label_font) + 1);
d1897 1
a1897 1
                tmp = xrealloc(dst->geom->label_font,
d1911 1
a1911 3
            if (dst->geom->label_font) {
                xfree(dst->geom->label_font);
            }
d1939 1
a1939 1
            dst->indicators = xalloc(sizeof(XkbIndicatorRec));
d1946 2
a1947 4
        if (dst->indicators) {
            xfree(dst->indicators);
            dst->indicators = NULL;
        }
d1958 1
a1958 1
            dst->ctrls = xalloc(sizeof(XkbControlsRec));
d1965 2
a1966 4
        if (dst->ctrls) {
            xfree(dst->ctrls);
            dst->ctrls = NULL;
        }
d2096 26
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a58 1
#define NEED_EVENTS 1
d65 1
a71 2
int	XkbDisableLockActions = 0;

d217 1
a223 1
KeySymsPtr		pCore;
d236 1
a236 2
    pCore= &pXDev->key->curKeySyms;
    syms= &pCore->map[(first-xkb->min_key_code)*pCore->mapWidth];
d346 1
a346 1
	memcpy(repeat,pXDev->kbdfeed->ctrl.autoRepeats,32);
d352 1
a352 1
        memcpy(pXDev->kbdfeed->ctrl.autoRepeats,repeat, 32);
d358 2
a359 2
void
XkbUpdateCoreDescription(DeviceIntPtr keybd,Bool resize)
d362 1
a362 2
int			maxSymsPerKey,maxKeysPerMod;
int			first,last,firstCommon,lastCommon;
d364 2
a365 2
KeyClassPtr		keyc;
CARD8			keysPerMod[XkbNumModifiers];
d368 2
a369 1
	return;
d371 2
a372 37
    keyc= keybd->key;
    maxSymsPerKey= maxKeysPerMod= 0;
    bzero(keysPerMod,sizeof(keysPerMod));
    memcpy(keyc->modifierMap,xkb->map->modmap,xkb->max_key_code+1);
    if ((xkb->min_key_code==keyc->curKeySyms.minKeyCode)&&
	(xkb->max_key_code==keyc->curKeySyms.maxKeyCode)) {
	first= firstCommon= xkb->min_key_code;
	last= lastCommon= xkb->max_key_code;
    }
    else if (resize) {
	keyc->curKeySyms.minKeyCode= xkb->min_key_code;
	keyc->curKeySyms.maxKeyCode= xkb->max_key_code;
	tmp= keyc->curKeySyms.mapWidth*_XkbCoreNumKeys(keyc);
	keyc->curKeySyms.map= _XkbTypedRealloc(keyc->curKeySyms.map,tmp,KeySym);
	if (!keyc->curKeySyms.map)
	   FatalError("Couldn't allocate keysyms\n");
	first= firstCommon= xkb->min_key_code;
	last= lastCommon= xkb->max_key_code;
    }
    else {
	if (xkb->min_key_code<keyc->curKeySyms.minKeyCode) {
	    first= xkb->min_key_code;
	    firstCommon= keyc->curKeySyms.minKeyCode;
	}
	else {
	    firstCommon= xkb->min_key_code;
	    first= keyc->curKeySyms.minKeyCode;
	}
	if (xkb->max_key_code>keyc->curKeySyms.maxKeyCode) {
	    lastCommon= keyc->curKeySyms.maxKeyCode;
	    last= xkb->max_key_code;
	}
	else {
	    lastCommon= xkb->max_key_code;
	    last= keyc->curKeySyms.maxKeyCode;
	}
    }
d375 1
a375 1
    for (key=first;key<=last;key++) {
d385 3
d405 2
a406 13
	}
	if (_XkbCoreKeycodeInRange(keyc,key)) {
	    if (keyc->modifierMap[key]!=0) {
		register unsigned bit,i,mask;
		mask= keyc->modifierMap[key];
		for (i=0,bit=1;i<XkbNumModifiers;i++,bit<<=1) {
		    if (mask&bit) {
			keysPerMod[i]++;
			if (keysPerMod[i]>maxKeysPerMod)
			    maxKeysPerMod= keysPerMod[i];
		    }
		}
	    }
d410 2
a411 33
    if (maxKeysPerMod>0) {
	tmp= maxKeysPerMod*XkbNumModifiers;
	if (keyc->modifierKeyMap==NULL)
	    keyc->modifierKeyMap= (KeyCode *)_XkbCalloc(1, tmp);
	else if (keyc->maxKeysPerModifier<maxKeysPerMod)
	    keyc->modifierKeyMap= (KeyCode *)_XkbRealloc(keyc->modifierKeyMap,tmp);
	if (keyc->modifierKeyMap==NULL)
	    FatalError("Couldn't allocate modifierKeyMap in UpdateCore\n");
	bzero(keyc->modifierKeyMap,tmp);
    }
    else if ((keyc->maxKeysPerModifier>0)&&(keyc->modifierKeyMap!=NULL)) {
	_XkbFree(keyc->modifierKeyMap);
	keyc->modifierKeyMap= NULL;
    }
    keyc->maxKeysPerModifier= maxKeysPerMod;

    if (maxSymsPerKey>0) {
	tmp= maxSymsPerKey*_XkbCoreNumKeys(keyc);
	keyc->curKeySyms.map= _XkbTypedRealloc(keyc->curKeySyms.map,tmp,KeySym);
	if (keyc->curKeySyms.map==NULL)
	    FatalError("Couldn't allocate symbols map in UpdateCore\n");
    }
    else if ((keyc->curKeySyms.mapWidth>0)&&(keyc->curKeySyms.map!=NULL)) {
	_XkbFree(keyc->curKeySyms.map);
	keyc->curKeySyms.map= NULL;
    }
    keyc->curKeySyms.mapWidth= maxSymsPerKey;

    bzero(keysPerMod,sizeof(keysPerMod));
    for (key=firstCommon;key<=lastCommon;key++) {
	if (keyc->curKeySyms.map!=NULL) {
	    KeySym *pCore,*pXKB;
	    unsigned nGroups,groupWidth,n,nOut;
d413 65
a477 15
	    nGroups= XkbKeyNumGroups(xkb,key);
	    n= (key-keyc->curKeySyms.minKeyCode)*maxSymsPerKey;
	    pCore= &keyc->curKeySyms.map[n];
	    bzero(pCore,maxSymsPerKey*sizeof(KeySym));
	    pXKB= XkbKeySymsPtr(xkb,key);
	    nOut= 2;
	    if (nGroups>0) {
		groupWidth= XkbKeyGroupWidth(xkb,key,XkbGroup1Index);
		if (groupWidth>0)	pCore[0]= pXKB[0];
		if (groupWidth>1)	pCore[1]= pXKB[1];
		for (n=2;n<groupWidth;n++) {
		    pCore[2+n]= pXKB[n];
		}
		if (groupWidth>2)
		    nOut= groupWidth;
d479 5
a483 30

	    /* See XKB Protocol Sec, Section 12.4.
	       A 1-group key with ABCDE on a 2 group keyboard must be
	       duplicated across all groups as ABABCDECDE.
	     */
	    if (nGroups == 1)
	    {
		int idx;

		groupWidth = XkbKeyGroupWidth(xkb, key, XkbGroup1Index);

		/* AB..CDE... -> ABABCDE... */
		if (groupWidth > 0 && maxSymsPerKey >= 3)
		    pCore[2] = pCore[0];
		if (groupWidth > 1 && maxSymsPerKey >= 4)
		    pCore[3] = pCore[1];

		/* ABABCDE... -> ABABCDECDE */
		idx = 2 + groupWidth;
		while (groupWidth > 2 &&
			idx < maxSymsPerKey &&
			idx < groupWidth * 2)
		{
		    pCore[idx] = pCore[idx - groupWidth + 2];
		    idx++;
		}
		idx = 2 * groupWidth;
		if (idx < 4)
		    idx = 4;
		/* 3 or more groups: ABABCDECDEABCDEABCDE */
d486 1
a486 1
	    }
d488 8
a495 20
	    pXKB+= XkbKeyGroupsWidth(xkb,key);
	    nOut+= 2;
	    if (nGroups>1) {
		groupWidth= XkbKeyGroupWidth(xkb,key,XkbGroup2Index);
		if (groupWidth>0)	pCore[2]= pXKB[0];
		if (groupWidth>1)	pCore[3]= pXKB[1];
		for (n=2;n<groupWidth;n++) {
		    pCore[nOut+(n-2)]= pXKB[n];
		}
		if (groupWidth>2)
		    nOut+= (groupWidth-2);
	    }
	    pXKB+= XkbKeyGroupsWidth(xkb,key);
	    for (n=XkbGroup3Index;n<nGroups;n++) {
		register int s;
		groupWidth= XkbKeyGroupWidth(xkb,key,n);
		for (s=0;s<groupWidth;s++) {
		    pCore[nOut++]= pXKB[s];
		}
		pXKB+= XkbKeyGroupsWidth(xkb,key);
d497 2
d500 6
a505 9
	if (keyc->modifierMap[key]!=0) {
	    register unsigned bit,i,mask;
	    mask= keyc->modifierMap[key];
	    for (i=0,bit=1;i<XkbNumModifiers;i++,bit<<=1) {
		if (mask&bit) {
		    tmp= i*maxKeysPerMod+keysPerMod[i];
		    keyc->modifierKeyMap[tmp]= key;
		    keysPerMod[i]++;
		}
d507 1
d510 2
a511 1
    return;
d532 1
a532 1
	if (XkbComputeControlsNotify(pXDev,&old,ctrls,&cn,True))
d538 1
d540 20
a559 35
XkbApplyMappingChange(	DeviceIntPtr	kbd,
			CARD8		 request,
			KeyCode		 firstKey,
			CARD8		 num,
			ClientPtr	 client)
{
XkbEventCauseRec	cause;
XkbChangesRec	 	changes;
unsigned	 	check;

    if (kbd->key->xkbInfo==NULL)
	XkbInitDevice(kbd);
    bzero(&changes,sizeof(XkbChangesRec));
    check= 0;
    if (request==MappingKeyboard) {
	XkbSetCauseCoreReq(&cause,X_ChangeKeyboardMapping,client);
	XkbUpdateKeyTypesFromCore(kbd,firstKey,num,&changes);
	XkbUpdateActions(kbd,firstKey,num,&changes,&check,&cause);
	if (check)
	    XkbCheckSecondaryEffects(kbd->key->xkbInfo,check,&changes,&cause);
    }
    else if (request==MappingModifier) {
	XkbDescPtr	xkb= kbd->key->xkbInfo->desc;

	XkbSetCauseCoreReq(&cause,X_SetModifierMapping,client);

	num = xkb->max_key_code-xkb->min_key_code+1;
	memcpy(xkb->map->modmap,kbd->key->modifierMap,xkb->max_key_code+1);

	changes.map.changed|= XkbModifierMapMask;
	changes.map.first_modmap_key= xkb->min_key_code;
	changes.map.num_modmap_keys= num;
	XkbUpdateActions(kbd,xkb->min_key_code,num,&changes,&check,&cause);
	if (check)
	    XkbCheckSecondaryEffects(kbd->key->xkbInfo,check,&changes,&cause);
d561 21
a581 3
    /* 3/26/94 (ef) -- XXX! Doesn't deal with input extension requests */
    XkbSendNotification(kbd,&changes,&cause);
    return;
d695 1
a695 2
    state->mods= (state->base_mods|state->latched_mods);
    state->mods|= state->locked_mods;
d729 1
a729 1
	XkbUpdateIndicators(xkbi->device,XkbAllIndicatorsMask,True,changes,
d752 1
a752 1
	return False;
d756 1
a756 1
	cn.changedControls|= XkbControlsEnabledMask;
d777 2
a778 2
    XkbUpdateIndicators(xkbi->device,sli->usesControls,True,changes,cause);
    return True;
d785 1
a785 1
XkbGeometryPtr 
d1155 1
a1155 1
            XkbFreeClientMap(dst, XkbAllClientInfoMask, True);
d1291 1
a1291 1
            XkbFreeServerMap(dst, XkbAllServerInfoMask, True);
d1392 1
a1392 1
            XkbFreeNames(dst, XkbAllNamesMask, True);
d1444 1
a1444 1
            XkbFreeCompatMap(dst, XkbAllCompatMask, True);
d1604 1
d1676 2
d1687 30
d1820 4
d1842 1
a1855 1
                    ddoodad->any.type = sdoodad->any.type;
d1920 1
a1920 1
                ddoodad->any.type = sdoodad->any.type;
d1980 1
a1980 1
                tmp = xalloc(strlen(src->geom->label_font));
d1988 1
a1988 1
                               strlen(src->geom->label_font));
d2017 1
a2017 1
            XkbFreeGeometry(dst->geom, XkbGeomAllMask, True);
d2083 1
a2083 1
XkbCopyKeymap(XkbDescPtr src, XkbDescPtr dst, Bool sendNotifies)
a2084 3
    DeviceIntPtr pDev = NULL, tmpDev = NULL;
    xkbMapNotify mn;
    xkbNewKeyboardNotify nkn;
d2086 2
a2087 1
    if (!src || !dst || src == dst)
d2089 4
d2094 2
a2095 1
    if (!_XkbCopyClientMap(src, dst))
d2097 3
a2099 1
    if (!_XkbCopyServerMap(src, dst))
d2101 3
a2103 1
    if (!_XkbCopyIndicators(src, dst))
d2105 3
a2107 1
    if (!_XkbCopyControls(src, dst))
d2109 3
a2111 1
    if (!_XkbCopyNames(src, dst))
d2113 3
a2115 1
    if (!_XkbCopyCompat(src, dst))
d2117 3
a2119 1
    if (!_XkbCopyGeom(src, dst))
d2121 7
d2129 37
a2165 22
    if (inputInfo.keyboard->key->xkbInfo &&
        inputInfo.keyboard->key->xkbInfo->desc == dst) {
        pDev = inputInfo.keyboard;
    }
    else {
        for (tmpDev = inputInfo.devices; tmpDev && !pDev;
             tmpDev = tmpDev->next) {
            if (tmpDev->key && tmpDev->key->xkbInfo &&
                tmpDev->key->xkbInfo->desc == dst) {
                pDev = tmpDev;
                break;
            }
        }
        for (tmpDev = inputInfo.off_devices; tmpDev && !pDev;
                tmpDev = tmpDev->next) {
            if (tmpDev->key && tmpDev->key->xkbInfo &&
                    tmpDev->key->xkbInfo->desc == dst) {
                pDev = tmpDev;
                break;
            }
        }
    }
d2167 19
a2185 42
    if (sendNotifies) {
        if (!pDev) {
            ErrorF("[xkb] XkbCopyKeymap: asked for notifies, but can't find device!\n");
        }
        else {
            /* send NewKeyboardNotify if the keycode range changed, else
             * just MapNotify.  we also need to send NKN if the geometry
             * changed (obviously ...). */
            if ((src->min_key_code != dst->min_key_code ||
                 src->max_key_code != dst->max_key_code)) {
                nkn.oldMinKeyCode = dst->min_key_code;
                nkn.oldMaxKeyCode = dst->max_key_code;
                nkn.deviceID = nkn.oldDeviceID = pDev->id;
                nkn.minKeyCode = src->min_key_code;
                nkn.maxKeyCode = src->max_key_code;
                nkn.requestMajor = XkbReqCode;
                nkn.requestMinor = X_kbSetMap; /* XXX bare-faced lie */
                nkn.changed = XkbAllNewKeyboardEventsMask;
                XkbSendNewKeyboardNotify(pDev, &nkn);
            } else
            {
                mn.deviceID = pDev->id;
                mn.minKeyCode = src->min_key_code;
                mn.maxKeyCode = src->max_key_code;
                mn.firstType = 0;
                mn.nTypes = src->map->num_types;
                mn.firstKeySym = src->min_key_code;
                mn.nKeySyms = XkbNumKeys(src);
                mn.firstKeyAct = src->min_key_code;
                mn.nKeyActs = XkbNumKeys(src);
                /* Cargo-culted from ProcXkbGetMap. */
                mn.firstKeyBehavior = src->min_key_code;
                mn.nKeyBehaviors = XkbNumKeys(src);
                mn.firstKeyExplicit = src->min_key_code;
                mn.nKeyExplicit = XkbNumKeys(src);
                mn.firstModMapKey = src->min_key_code;
                mn.nModMapKeys = XkbNumKeys(src);
                mn.firstVModMapKey = src->min_key_code;
                mn.nVModMapKeys = XkbNumKeys(src);
                mn.virtualMods = ~0; /* ??? */
                mn.changed = XkbAllMapComponentsMask;                
                XkbSendMapNotify(pDev, &mn);
d2189 1
d2191 1
a2191 4
    dst->min_key_code = src->min_key_code;
    dst->max_key_code = src->max_key_code;

    return TRUE;
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d26 24
d82 5
a86 12
    if (id == XkbUseCoreKbd) {
	if (inputInfo.keyboard)
	    id = inputInfo.keyboard->id;
	else
	    goto out;
    }
    if (id == XkbUseCorePtr) {
	if (inputInfo.pointer)
	    id = inputInfo.pointer->id;
	else
	    goto out;
    }
a87 1
out:
d90 1
d964 2
a965 18

/**
 * Copy an XKB map from src to dst, reallocating when necessary: if some
 * map components are present in one, but not in the other, the destination
 * components will be allocated or freed as necessary.
 *
 * Basic map consistency is assumed on both sides, so maps with random
 * uninitialised data (e.g. names->radio_grous == NULL, names->num_rg == 19)
 * _will_ cause failures.  You've been warned.
 *
 * Returns TRUE on success, or FALSE on failure.  If this function fails,
 * dst may be in an inconsistent state: all its pointers are guaranteed
 * to remain valid, but part of the map may be from src and part from dst.
 *
 * FIXME: This function wants to be broken up into multiple functions.
 */
Bool
XkbCopyKeymap(XkbDescPtr src, XkbDescPtr dst, Bool sendNotifies)
a966 1
    int i = 0, j = 0, k = 0;
d968 1
a968 2
    XkbColorPtr scolor = NULL, dcolor = NULL;
    XkbDoodadPtr sdoodad = NULL, ddoodad = NULL;
a969 11
    XkbOutlinePtr soutline = NULL, doutline = NULL;
    XkbPropertyPtr sprop = NULL, dprop = NULL;
    XkbRowPtr srow = NULL, drow = NULL;
    XkbSectionPtr ssection = NULL, dsection = NULL;
    XkbShapePtr sshape = NULL, dshape = NULL;
    DeviceIntPtr pDev = NULL, tmpDev = NULL;
    xkbMapNotify mn;
    xkbNewKeyboardNotify nkn;

    if (!src || !dst || src == dst)
        return FALSE;
d1218 8
d1354 2
a1355 15
    /* indicators */
    if (src->indicators) {
        if (!dst->indicators) {
            dst->indicators = xalloc(sizeof(XkbIndicatorRec));
            if (!dst->indicators)
                return FALSE;
        }
        memcpy(dst->indicators, src->indicators, sizeof(XkbIndicatorRec));
    }
    else {
        if (dst->indicators) {
            xfree(dst->indicators);
            dst->indicators = NULL;
        }
    }
d1357 4
a1360 15
    /* controls */
    if (src->ctrls) {
        if (!dst->ctrls) {
            dst->ctrls = xalloc(sizeof(XkbControlsRec));
            if (!dst->ctrls)
                return FALSE;
        }
        memcpy(dst->ctrls, src->ctrls, sizeof(XkbControlsRec));
    }
    else {
        if (dst->ctrls) {
            xfree(dst->ctrls);
            dst->ctrls = NULL;
        }
    }
d1455 8
d1507 16
d2019 1
a2019 1
            dst->geom->label_color = &(src->geom->colors[i]);
d2021 1
a2021 1
            dst->geom->base_color = &(src->geom->colors[i]);
d2045 85
d2144 1
a2144 1
             tmpDev = tmpDev->next) {
d2146 1
a2146 1
                tmpDev->key->xkbInfo->desc == dst) {
d2155 1
a2155 1
            ErrorF("XkbCopyKeymap: asked for notifies, but can't find device!\n");
d2162 1
a2162 1
                 src->max_key_code != dst->max_key_code) && sendNotifies) {
d2172 2
a2173 2
            }
            else if (sendNotifies) {
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d45 1
a45 1
#include <X11/extensions/XKBgeom.h>
d52 28
a79 2
DeviceIntPtr
_XkbLookupAnyDevice(int id,int *why_rtrn)
d81 2
a82 1
DeviceIntPtr dev = NULL;
d84 2
a85 3
    dev= (DeviceIntPtr)LookupKeyboardDevice();
    if ((id==XkbUseCoreKbd)||(dev->id==id))
	return dev;
d87 3
a89 3
    dev= (DeviceIntPtr)LookupPointerDevice();
    if ((id==XkbUseCorePtr)||(dev->id==id))
	return dev;
d91 7
a97 9
    if (id&(~0xff))
	 dev = NULL;

    dev= (DeviceIntPtr)LookupDevice(id);
    if (dev!=NULL) 
	return dev;
    if ((!dev)&&(why_rtrn))
	*why_rtrn= XkbErr_BadDevice;
    return dev;
d100 3
a102 2
DeviceIntPtr
_XkbLookupKeyboard(int id,int *why_rtrn)
d104 2
a105 13
DeviceIntPtr dev = NULL;

    if (id == XkbDfltXIId)
        id = XkbUseCoreKbd;
    if ((dev= _XkbLookupAnyDevice(id,why_rtrn))==NULL)
	return NULL;
    else if ((!dev->key)||(!dev->key->xkbInfo)) {
	if (why_rtrn)
	   *why_rtrn= XkbErr_BadClass;
	return NULL;
    }
    return dev;
}
d107 3
a109 4
DeviceIntPtr
_XkbLookupBellDevice(int id,int *why_rtrn)
{
DeviceIntPtr dev = NULL;
d111 5
a115 6
    if ((dev= _XkbLookupAnyDevice(id,why_rtrn))==NULL)
	return NULL;
    else if ((!dev->kbdfeed)&&(!dev->bell)) {
	if (why_rtrn)
	   *why_rtrn= XkbErr_BadClass;
	return NULL;
d117 1
a117 1
    return dev;
d120 3
a122 2
DeviceIntPtr
_XkbLookupLedDevice(int id,int *why_rtrn)
d124 2
a125 1
DeviceIntPtr dev = NULL;
d129 10
a138 6
    if ((dev= _XkbLookupAnyDevice(id,why_rtrn))==NULL)
	return NULL;
    else if ((!dev->kbdfeed)&&(!dev->leds)) {
	if (why_rtrn)
	   *why_rtrn= XkbErr_BadClass;
	return NULL;
d140 1
a140 1
    return dev;
d143 3
a145 2
DeviceIntPtr
_XkbLookupButtonDevice(int id,int *why_rtrn)
d147 2
a148 1
DeviceIntPtr dev = NULL;
d150 9
a158 6
    if ((dev= _XkbLookupAnyDevice(id,why_rtrn))==NULL)
	return NULL;
    else if (!dev->button) {
	if (why_rtrn)
	   *why_rtrn= XkbErr_BadClass;
	return NULL;
d160 1
a160 1
    return dev;
a213 10
#ifdef NOTYET
    if (first<xkb->min_key_code) {
	if (first>=XkbMinLegalKeyCode) {
	    xkb->min_key_code= first;
	    /* 1/12/95 (ef) -- XXX! should zero out the new maps */
	    changes->map.changed|= XkbKeycodesMask;
/* generate a NewKeyboard notify here? */
	}
    }
#endif
d489 34
a543 5
	    if (!pCore[2] && !pCore[3] && maxSymsPerKey >= 6 &&
                (pCore[4] || pCore[5])) {
                pCore[2] = pCore[4];
                pCore[3] = pCore[5];
	    }
d1538 3
d1543 1
a1543 2
                          dprop = dst->geom->properties +
                                  src->geom->num_properties;
d1563 2
d1600 1
d1624 1
a1624 2
                          dcolor = dst->geom->colors +
                                   src->geom->num_colors;
d1742 1
a1742 1
                        doutline->sz_points = soutline->sz_points;
d1821 1
d1828 1
d1835 3
d1863 1
d1884 3
a1886 2
                dsection->num_doodads = ssection->num_doodads;
                dsection->sz_doodads = ssection->num_doodads;
@


1.1
log
@Initial revision
@
text
@d31 1
d44 1
a44 1
#include <X11/extensions/XKBsrv.h>
a47 4
#ifdef MODE_SWITCH
extern Bool noKME; /* defined in os/utils.c */
#endif

a51 10
#ifndef RETURN_SHOULD_REPEAT
#if (defined(__osf__) && defined(__alpha))
#define RETURN_SHOULD_REPEAT 1
#else
#define	RETURN_SHOULD_REPEAT 0
#endif
#endif

/***====================================================================***/

d81 2
d113 2
a174 38

Bool
XkbApplyVModChanges(	XkbSrvInfoPtr		xkbi,
			unsigned		changed,
			XkbChangesPtr		changes,
			unsigned *		needChecksRtrn,
			XkbEventCausePtr	cause)
{
XkbDescPtr		xkb;
Bool			check;

    xkb= xkbi->desc;
#ifdef DEBUG
{
register unsigned i,bit;
    for (i=0,bit=1;i<XkbNumVirtualMods;i++,bit<<=1) {
	if ((changed&bit)==0)
	    continue;
	if (xkbDebugFlags)
	    ErrorF("Should be applying: change vmod %d to 0x%x\n",i,
					xkb->server->vmods[i]);
    }
}
#endif
    check= XkbApplyVirtualModChanges(xkb,changed,changes);
    XkbApplyVModChangesToAllDevices(xkbi->device,xkb,changed,cause);

    if (needChecksRtrn!=NULL)  {
	if (check)
	     *needChecksRtrn= XkbStateNotifyMask|XkbIndicatorStateNotifyMask;
	else *needChecksRtrn= 0;
    }
    else if (check) {
	/* 7/12/95 (ef) -- XXX check compatibility and/or indicator state */
    }
    return 1;
}

d197 1
a197 1
generate a NewKeyboard notify here?
a514 6
#ifdef MODE_SWITCH
    /* Fix up any of the KME stuff if we changed the core description.
     */
    if (!noKME)
	HandleKeyBinding(keyc, &keyc->curKeySyms);
#endif
d623 1
a623 1
void
a736 15
void
XkbSetPhysicalLockingKey(DeviceIntPtr dev,unsigned key)
{
XkbDescPtr	xkb;

    xkb= dev->key->xkbInfo->desc;
    if ((key>=xkb->min_key_code) && (key<=xkb->max_key_code)) {
	xkb->server->behaviors[key].type= XkbKB_Lock|XkbKB_Permanent;
    }
    else ErrorF("Internal Error!  Bad XKB info in SetPhysicalLockingKey\n");
    return;
}

/***====================================================================***/

d903 1166
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a30 1
#include "os.h"
d43 1
a43 1
#include <xkbsrv.h>
d47 4
d55 10
a93 2
    if (id == XkbDfltXIId)
        id = XkbUseCoreKbd;
a123 2
    if (id == XkbDfltXIId)
        id = XkbUseCorePtr;
d184 38
d244 1
a244 1
/* generate a NewKeyboard notify here? */
d562 6
d676 1
a676 1
static void
d790 15
a970 1158
}


/**
 * Copy an XKB map from src to dst, reallocating when necessary: if some
 * map components are present in one, but not in the other, the destination
 * components will be allocated or freed as necessary.
 *
 * Basic map consistency is assumed on both sides, so maps with random
 * uninitialised data (e.g. names->radio_grous == NULL, names->num_rg == 19)
 * _will_ cause failures.  You've been warned.
 *
 * Returns TRUE on success, or FALSE on failure.  If this function fails,
 * dst may be in an inconsistent state: all its pointers are guaranteed
 * to remain valid, but part of the map may be from src and part from dst.
 *
 * FIXME: This function wants to be broken up into multiple functions.
 */
Bool
XkbCopyKeymap(XkbDescPtr src, XkbDescPtr dst, Bool sendNotifies)
{
    int i = 0, j = 0, k = 0;
    void *tmp = NULL;
    XkbColorPtr scolor = NULL, dcolor = NULL;
    XkbDoodadPtr sdoodad = NULL, ddoodad = NULL;
    XkbKeyTypePtr stype = NULL, dtype = NULL;
    XkbOutlinePtr soutline = NULL, doutline = NULL;
    XkbPropertyPtr sprop = NULL, dprop = NULL;
    XkbRowPtr srow = NULL, drow = NULL;
    XkbSectionPtr ssection = NULL, dsection = NULL;
    XkbShapePtr sshape = NULL, dshape = NULL;
    DeviceIntPtr pDev = NULL, tmpDev = NULL;
    xkbMapNotify mn;
    xkbNewKeyboardNotify nkn;

    if (!src || !dst || src == dst)
        return FALSE;

    /* client map */
    if (src->map) {
        if (!dst->map) {
            tmp = xcalloc(1, sizeof(XkbClientMapRec));
            if (!tmp)
                return FALSE;
            dst->map = tmp;
        }

        if (src->map->syms) {
            if (src->map->size_syms != dst->map->size_syms) {
                if (dst->map->syms)
                    tmp = xrealloc(dst->map->syms,
                                   src->map->size_syms * sizeof(KeySym));
                else
                    tmp = xalloc(src->map->size_syms * sizeof(KeySym));
                if (!tmp)
                    return FALSE;
                dst->map->syms = tmp;

            }
            memcpy(dst->map->syms, src->map->syms,
                   src->map->size_syms * sizeof(KeySym));
        }
        else {
            if (dst->map->syms) {
                xfree(dst->map->syms);
                dst->map->syms = NULL;
            }
        }
        dst->map->num_syms = src->map->num_syms;
        dst->map->size_syms = src->map->size_syms;

        if (src->map->key_sym_map) {
            if (src->max_key_code != dst->max_key_code) {
                if (dst->map->key_sym_map)
                    tmp = xrealloc(dst->map->key_sym_map,
                                   (src->max_key_code + 1) *
                                     sizeof(XkbSymMapRec));
                else
                    tmp = xalloc((src->max_key_code + 1) *
                                 sizeof(XkbSymMapRec));
                if (!tmp)
                    return FALSE;
                dst->map->key_sym_map = tmp;
            }
            memcpy(dst->map->key_sym_map, src->map->key_sym_map,
                   (src->max_key_code + 1) * sizeof(XkbSymMapRec));
        }
        else {
            if (dst->map->key_sym_map) {
                xfree(dst->map->key_sym_map);
                dst->map->key_sym_map = NULL;
            }
        }

        if (src->map->types && src->map->num_types) {
            if (src->map->num_types > dst->map->size_types ||
                !dst->map->types || !dst->map->size_types) {
                if (dst->map->types && dst->map->size_types) {
                    tmp = xrealloc(dst->map->types,
                                   src->map->num_types * sizeof(XkbKeyTypeRec));
                    if (!tmp)
                        return FALSE;
                    dst->map->types = tmp;
                    bzero(dst->map->types + dst->map->num_types,
                          (src->map->num_types - dst->map->num_types) *
                            sizeof(XkbKeyTypeRec));
                }
                else {
                    tmp = xcalloc(src->map->num_types, sizeof(XkbKeyTypeRec));
                    if (!tmp)
                        return FALSE;
                    dst->map->types = tmp;
                }
            }
            else if (src->map->num_types < dst->map->num_types &&
                     dst->map->types) {
                for (i = src->map->num_types, dtype = (dst->map->types + i);
                     i < dst->map->num_types; i++, dtype++) {
                    if (dtype->level_names)
                        xfree(dtype->level_names);
                    dtype->level_names = NULL;
                    dtype->num_levels = 0;
                    if (dtype->map_count) {
                        if (dtype->map)
                            xfree(dtype->map);
                        if (dtype->preserve)
                            xfree(dtype->preserve);
                    }
                }
            }

            stype = src->map->types;
            dtype = dst->map->types;
            for (i = 0; i < src->map->num_types; i++, dtype++, stype++) {
                if (stype->num_levels && stype->level_names) {
                    if (stype->num_levels != dtype->num_levels &&
                        dtype->num_levels && dtype->level_names &&
                        i < dst->map->num_types) {
                        tmp = xrealloc(dtype->level_names,
                                       stype->num_levels * sizeof(Atom));
                        if (!tmp)
                            continue;
                        dtype->level_names = tmp;
                    }
                    else if (!dtype->num_levels || !dtype->level_names ||
                             i >= dst->map->num_types) {
                        tmp = xalloc(stype->num_levels * sizeof(Atom));
                        if (!tmp)
                            continue;
                        dtype->level_names = tmp;
                    }
                    dtype->num_levels = stype->num_levels;
                    memcpy(dtype->level_names, stype->level_names,
                           stype->num_levels * sizeof(Atom));
                }
                else {
                    if (dtype->num_levels && dtype->level_names &&
                        i < dst->map->num_types)
                        xfree(dtype->level_names);
                    dtype->num_levels = 0;
                    dtype->level_names = NULL;
                }

                dtype->name = stype->name;
                memcpy(&dtype->mods, &stype->mods, sizeof(XkbModsRec));

                if (stype->map_count) {
                    if (stype->map) {
                        if (stype->map_count != dtype->map_count &&
                            dtype->map_count && dtype->map &&
                            i < dst->map->num_types) {
                            tmp = xrealloc(dtype->map,
                                           stype->map_count *
                                             sizeof(XkbKTMapEntryRec));
                            if (!tmp)
                                return FALSE;
                            dtype->map = tmp;
                        }
                        else if (!dtype->map_count || !dtype->map ||
                                 i >= dst->map->num_types) {
                            tmp = xalloc(stype->map_count *
                                           sizeof(XkbKTMapEntryRec));
                            if (!tmp)
                                return FALSE;
                            dtype->map = tmp;
                        }

                        memcpy(dtype->map, stype->map,
                               stype->map_count * sizeof(XkbKTMapEntryRec));
                    }
                    else {
                        if (dtype->map && i < dst->map->num_types)
                            xfree(dtype->map);
                        dtype->map = NULL;
                    }

                    if (stype->preserve) {
                        if (stype->map_count != dtype->map_count &&
                            dtype->map_count && dtype->preserve &&
                            i < dst->map->num_types) {
                            tmp = xrealloc(dtype->preserve,
                                           stype->map_count *
                                             sizeof(XkbModsRec));
                            if (!tmp)
                                return FALSE;
                            dtype->preserve = tmp;
                        }
                        else if (!dtype->preserve || !dtype->map_count ||
                                 i >= dst->map->num_types) {
                            tmp = xalloc(stype->map_count *
                                         sizeof(XkbModsRec));
                            if (!tmp)
                                return FALSE;
                            dtype->preserve = tmp;
                        }

                        memcpy(dtype->preserve, stype->preserve,
                               stype->map_count * sizeof(XkbModsRec));
                    }
                    else {
                        if (dtype->preserve && i < dst->map->num_types)
                            xfree(dtype->preserve);
                        dtype->preserve = NULL;
                    }

                    dtype->map_count = stype->map_count;
                }
                else {
                    if (dtype->map_count && i < dst->map->num_types) {
                        if (dtype->map)
                            xfree(dtype->map);
                        if (dtype->preserve)
                            xfree(dtype->preserve);
                    }
                    dtype->map_count = 0;
                    dtype->map = NULL;
                    dtype->preserve = NULL;
                }
            }

            dst->map->size_types = src->map->num_types;
            dst->map->num_types = src->map->num_types;
        }
        else {
            if (dst->map->types) {
                for (i = 0, dtype = dst->map->types; i < dst->map->num_types;
                     i++, dtype++) {
                    if (dtype->level_names)
                        xfree(dtype->level_names);
                    if (dtype->map && dtype->map_count)
                        xfree(dtype->map);
                    if (dtype->preserve && dtype->map_count)
                        xfree(dtype->preserve);
                }
                xfree(dst->map->types);
                dst->map->types = NULL;
            }
            dst->map->num_types = 0;
            dst->map->size_types = 0;
        }

        if (src->map->modmap) {
            if (src->max_key_code != dst->max_key_code) {
                if (dst->map->modmap)
                    tmp = xrealloc(dst->map->modmap, src->max_key_code + 1);
                else
                    tmp = xalloc(src->max_key_code + 1);
                if (!tmp)
                    return FALSE;
                dst->map->modmap = tmp;
            }
            memcpy(dst->map->modmap, src->map->modmap, src->max_key_code + 1);
        }
        else {
            if (dst->map->modmap) {
                xfree(dst->map->modmap);
                dst->map->modmap = NULL;
            }
        }
    }
    else {
        if (dst->map)
            XkbFreeClientMap(dst, XkbAllClientInfoMask, True);
    }

    /* server map */
    if (src->server) {
        if (!dst->server) {
            tmp = xcalloc(1, sizeof(XkbServerMapRec));
            if (!tmp)
                return FALSE;
            dst->server = tmp;
        }

        if (src->server->explicit) {
            if (src->max_key_code != dst->max_key_code) {
                if (dst->server->explicit)
                    tmp = xrealloc(dst->server->explicit, src->max_key_code + 1);
                else
                    tmp = xalloc(src->max_key_code + 1);
                if (!tmp)
                    return FALSE;
                dst->server->explicit = tmp;
            }
            memcpy(dst->server->explicit, src->server->explicit,
                   src->max_key_code + 1);
        }
        else {
            if (dst->server->explicit) {
                xfree(dst->server->explicit);
                dst->server->explicit = NULL;
            }
        }

        if (src->server->acts) {
            if (src->server->size_acts != dst->server->size_acts) {
                if (dst->server->acts)
                    tmp = xrealloc(dst->server->acts,
                                   src->server->size_acts * sizeof(XkbAction));
                else
                    tmp = xalloc(src->server->size_acts * sizeof(XkbAction));
                if (!tmp)
                    return FALSE;
                dst->server->acts = tmp;
            }
            memcpy(dst->server->acts, src->server->acts,
                   src->server->size_acts * sizeof(XkbAction));
        }
        else {
            if (dst->server->acts) {
                xfree(dst->server->acts);
                dst->server->acts = NULL;
            }
        }
       dst->server->size_acts = src->server->size_acts;
       dst->server->num_acts = src->server->num_acts;

        if (src->server->key_acts) {
            if (src->max_key_code != dst->max_key_code) {
                if (dst->server->key_acts)
                    tmp = xrealloc(dst->server->key_acts,
                                   (src->max_key_code + 1) *
                                     sizeof(unsigned short));
                else
                    tmp = xalloc((src->max_key_code + 1) *
                                 sizeof(unsigned short));
                if (!tmp)
                    return FALSE;
                dst->server->key_acts = tmp;
            }
            memcpy(dst->server->key_acts, src->server->key_acts,
                   (src->max_key_code + 1) * sizeof(unsigned short));
        }
        else {
            if (dst->server->key_acts) {
                xfree(dst->server->key_acts);
                dst->server->key_acts = NULL;
            }
        }

        if (src->server->behaviors) {
            if (src->max_key_code != dst->max_key_code) {
                if (dst->server->behaviors)
                    tmp = xrealloc(dst->server->behaviors,
                                   (src->max_key_code + 1) *
                                   sizeof(XkbBehavior));
                else
                    tmp = xalloc((src->max_key_code + 1) *
                                 sizeof(XkbBehavior));
                if (!tmp)
                    return FALSE;
                dst->server->behaviors = tmp;
            }
            memcpy(dst->server->behaviors, src->server->behaviors,
                   (src->max_key_code + 1) * sizeof(XkbBehavior));
        }
        else {
            if (dst->server->behaviors) {
                xfree(dst->server->behaviors);
                dst->server->behaviors = NULL;
            }
        }

        memcpy(dst->server->vmods, src->server->vmods, XkbNumVirtualMods);

        if (src->server->vmodmap) {
            if (src->max_key_code != dst->max_key_code) {
                if (dst->server->vmodmap)
                    tmp = xrealloc(dst->server->vmodmap,
                                   (src->max_key_code + 1) *
                                   sizeof(unsigned short));
                else
                    tmp = xalloc((src->max_key_code + 1) *
                                 sizeof(unsigned short));
                if (!tmp)
                    return FALSE;
                dst->server->vmodmap = tmp;
            }
            memcpy(dst->server->vmodmap, src->server->vmodmap,
                   (src->max_key_code + 1) * sizeof(unsigned short));
        }
        else {
            if (dst->server->vmodmap) {
                xfree(dst->server->vmodmap);
                dst->server->vmodmap = NULL;
            }
        }
    }
    else {
        if (dst->server)
            XkbFreeServerMap(dst, XkbAllServerInfoMask, True);
    }

    /* indicators */
    if (src->indicators) {
        if (!dst->indicators) {
            dst->indicators = xalloc(sizeof(XkbIndicatorRec));
            if (!dst->indicators)
                return FALSE;
        }
        memcpy(dst->indicators, src->indicators, sizeof(XkbIndicatorRec));
    }
    else {
        if (dst->indicators) {
            xfree(dst->indicators);
            dst->indicators = NULL;
        }
    }

    /* controls */
    if (src->ctrls) {
        if (!dst->ctrls) {
            dst->ctrls = xalloc(sizeof(XkbControlsRec));
            if (!dst->ctrls)
                return FALSE;
        }
        memcpy(dst->ctrls, src->ctrls, sizeof(XkbControlsRec));
    }
    else {
        if (dst->ctrls) {
            xfree(dst->ctrls);
            dst->ctrls = NULL;
        }
    }

    /* names */
    if (src->names) {
        if (!dst->names) {
            dst->names = xcalloc(1, sizeof(XkbNamesRec));
            if (!dst->names)
                return FALSE;
        }

        if (src->names->keys) {
            if (src->max_key_code != dst->max_key_code) {
                if (dst->names->keys)
                    tmp = xrealloc(dst->names->keys, (src->max_key_code + 1) *
                                   sizeof(XkbKeyNameRec));
                else
                    tmp = xalloc((src->max_key_code + 1) *
                                 sizeof(XkbKeyNameRec));
                if (!tmp)
                    return FALSE;
                dst->names->keys = tmp;
            }
            memcpy(dst->names->keys, src->names->keys,
                   (src->max_key_code + 1) * sizeof(XkbKeyNameRec));
        }
        else {
            if (dst->names->keys) {
                xfree(dst->names->keys);
                dst->names->keys = NULL;
            }
        }

        if (src->names->num_key_aliases) {
            if (src->names->num_key_aliases != dst->names->num_key_aliases) {
                if (dst->names->key_aliases)
                    tmp = xrealloc(dst->names->key_aliases,
                                   src->names->num_key_aliases *
                                     sizeof(XkbKeyAliasRec));
                else
                    tmp = xalloc(src->names->num_key_aliases *
                                 sizeof(XkbKeyAliasRec));
                if (!tmp)
                    return FALSE;
                dst->names->key_aliases = tmp;
            }
            memcpy(dst->names->key_aliases, src->names->key_aliases,
                   src->names->num_key_aliases * sizeof(XkbKeyAliasRec));
        }
        else {
            if (dst->names->key_aliases) {
                xfree(dst->names->key_aliases);
                dst->names->key_aliases = NULL;
            }
        }
        dst->names->num_key_aliases = src->names->num_key_aliases;

        if (src->names->num_rg) {
            if (src->names->num_rg != dst->names->num_rg) {
                if (dst->names->radio_groups)
                    tmp = xrealloc(dst->names->radio_groups,
                                   src->names->num_rg * sizeof(Atom));
                else
                    tmp = xalloc(src->names->num_rg * sizeof(Atom));
                if (!tmp)
                    return FALSE;
                dst->names->radio_groups = tmp;
            }
            memcpy(dst->names->radio_groups, src->names->radio_groups,
                   src->names->num_rg * sizeof(Atom));
        }
        else {
            if (dst->names->radio_groups)
                xfree(dst->names->radio_groups);
        }
        dst->names->num_rg = src->names->num_rg;

        dst->names->keycodes = src->names->keycodes;
        dst->names->geometry = src->names->geometry;
        dst->names->symbols = src->names->symbols;
        dst->names->types = src->names->types;
        dst->names->compat = src->names->compat;
        dst->names->phys_symbols = src->names->phys_symbols;

        memcpy(dst->names->vmods, src->names->vmods,
               XkbNumVirtualMods * sizeof(Atom));
        memcpy(dst->names->indicators, src->names->indicators,
               XkbNumIndicators * sizeof(Atom));
        memcpy(dst->names->groups, src->names->groups,
               XkbNumKbdGroups * sizeof(Atom));
    }
    else {
        if (dst->names)
            XkbFreeNames(dst, XkbAllNamesMask, True);
    }

    /* compat */
    if (src->compat) {
        if (!dst->compat) {
            dst->compat = xcalloc(1, sizeof(XkbCompatMapRec));
            if (!dst->compat)
                return FALSE;
        }

        if (src->compat->sym_interpret && src->compat->num_si) {
            if (src->compat->num_si != dst->compat->size_si) {
                if (dst->compat->sym_interpret)
                    tmp = xrealloc(dst->compat->sym_interpret,
                                   src->compat->num_si *
                                     sizeof(XkbSymInterpretRec));
                else
                    tmp = xalloc(src->compat->num_si *
                                 sizeof(XkbSymInterpretRec));
                if (!tmp)
                    return FALSE;
                dst->compat->sym_interpret = tmp;
            }
            memcpy(dst->compat->sym_interpret, src->compat->sym_interpret,
                   src->compat->num_si * sizeof(XkbSymInterpretRec));

            dst->compat->num_si = src->compat->num_si;
            dst->compat->size_si = src->compat->num_si;
        }
        else {
            if (dst->compat->sym_interpret && dst->compat->size_si)
                xfree(dst->compat->sym_interpret);

            dst->compat->sym_interpret = NULL;
            dst->compat->num_si = 0;
            dst->compat->size_si = 0;
        }

        memcpy(dst->compat->groups, src->compat->groups,
               XkbNumKbdGroups * sizeof(XkbModsRec));
    }
    else {
        if (dst->compat)
            XkbFreeCompatMap(dst, XkbAllCompatMask, True);
    }

    /* geometry */
    if (src->geom) {
        if (!dst->geom) {
            dst->geom = xcalloc(sizeof(XkbGeometryRec), 1);
            if (!dst->geom)
                return FALSE;
        }

        /* properties */
        if (src->geom->num_properties) {
            if (src->geom->num_properties != dst->geom->sz_properties) {
                if (src->geom->num_properties < dst->geom->sz_properties) {
                    for (i = src->geom->num_properties,
                          dprop = dst->geom->properties +
                                  src->geom->num_properties;
                         i < dst->geom->num_properties;
                         i++, dprop++) {
                        xfree(dprop->name);
                        xfree(dprop->value);
                    }
                }

                if (dst->geom->sz_properties)
                    tmp = xrealloc(dst->geom->properties,
                                   src->geom->num_properties *
                                    sizeof(XkbPropertyRec));
                else
                    tmp = xalloc(src->geom->num_properties *
                                  sizeof(XkbPropertyRec));
                if (!tmp)
                    return FALSE;
                dst->geom->properties = tmp;
            }

            dst->geom->sz_properties = src->geom->num_properties;

            if (dst->geom->sz_properties > dst->geom->num_properties) {
                bzero(dst->geom->properties + dst->geom->num_properties,
                      (dst->geom->sz_properties - dst->geom->num_properties) *
                      sizeof(XkbPropertyRec));
            }

            for (i = 0,
                  sprop = src->geom->properties,
                  dprop = dst->geom->properties;
                 i < src->geom->num_properties;
                 i++, sprop++, dprop++) {
                if (i < dst->geom->num_properties) {
                    if (strlen(sprop->name) != strlen(dprop->name)) {
                        tmp = xrealloc(dprop->name, strlen(sprop->name) + 1);
                        if (!tmp)
                            return FALSE;
                        dprop->name = tmp;
                    }
                    if (strlen(sprop->value) != strlen(dprop->value)) {
                        tmp = xrealloc(dprop->value, strlen(sprop->value) + 1);
                        if (!tmp)
                            return FALSE;
                        dprop->value = tmp;
                    }
                    strcpy(dprop->name, sprop->name);
                    strcpy(dprop->value, sprop->value);
                }
                else {
                    dprop->name = xstrdup(sprop->name);
                    dprop->value = xstrdup(sprop->value);
                }
            }

            dst->geom->num_properties = dst->geom->sz_properties;
        }
        else {
            if (dst->geom->sz_properties) {
                for (i = 0, dprop = dst->geom->properties;
                     i < dst->geom->num_properties;
                     i++, dprop++) {
                    xfree(dprop->name);
                    xfree(dprop->value);
                }
                xfree(dst->geom->properties);
                dst->geom->properties = NULL;
            }

            dst->geom->num_properties = 0;
            dst->geom->sz_properties = 0;
        }

        /* colors */
        if (src->geom->num_colors) {
            if (src->geom->num_colors != dst->geom->sz_colors) {
                if (src->geom->num_colors < dst->geom->sz_colors) {
                    for (i = src->geom->num_colors,
                          dcolor = dst->geom->colors +
                                   src->geom->num_colors;
                         i < dst->geom->num_colors;
                         i++, dcolor++) {
                        xfree(dcolor->spec);
                    }
                }

                if (dst->geom->sz_colors)
                    tmp = xrealloc(dst->geom->colors,
                                   src->geom->num_colors *
                                    sizeof(XkbColorRec));
                else
                    tmp = xalloc(src->geom->num_colors *
                                  sizeof(XkbColorRec));
                if (!tmp)
                    return FALSE;
                dst->geom->colors = tmp;
            }

            dst->geom->sz_colors = src->geom->num_colors;

            if (dst->geom->sz_colors > dst->geom->num_colors) {
                bzero(dst->geom->colors + dst->geom->num_colors,
                      (dst->geom->sz_colors - dst->geom->num_colors) *
                      sizeof(XkbColorRec));
            }

            for (i = 0,
                  scolor = src->geom->colors,
                  dcolor = dst->geom->colors;
                 i < src->geom->num_colors;
                 i++, scolor++, dcolor++) {
                if (i < dst->geom->num_colors) {
                    if (strlen(scolor->spec) != strlen(dcolor->spec)) {
                        tmp = xrealloc(dcolor->spec, strlen(scolor->spec) + 1);
                        if (!tmp)
                            return FALSE;
                        dcolor->spec = tmp;
                    }
                    strcpy(dcolor->spec, scolor->spec);
                }
                else {
                    dcolor->spec = xstrdup(scolor->spec);
                }
            }

            dst->geom->num_colors = dst->geom->sz_colors;
        }
        else {
            if (dst->geom->sz_colors) {
                for (i = 0, dcolor = dst->geom->colors;
                     i < dst->geom->num_colors;
                     i++, dcolor++) {
                    xfree(dcolor->spec);
                }
                xfree(dst->geom->colors);
                dst->geom->colors = NULL;
            }

            dst->geom->num_colors = 0;
            dst->geom->sz_colors = 0;
        }

        /* shapes */
        /* shapes break down into outlines, which break down into points. */
        if (dst->geom->num_shapes) {
            for (i = 0, dshape = dst->geom->shapes;
                 i < dst->geom->num_shapes;
                 i++, dshape++) {
                for (j = 0, doutline = dshape->outlines;
                     j < dshape->num_outlines;
                     j++, doutline++) {
                    if (doutline->sz_points)
                        xfree(doutline->points);
                }

                if (dshape->sz_outlines) {
                    xfree(dshape->outlines);
                    dshape->outlines = NULL;
                }

                dshape->num_outlines = 0;
                dshape->sz_outlines = 0;
            }
        }

        if (src->geom->num_shapes) {
            tmp = xcalloc(src->geom->num_shapes, sizeof(XkbShapeRec));
            if (!tmp)
                return FALSE;
            dst->geom->shapes = tmp;

            for (i = 0, sshape = src->geom->shapes, dshape = dst->geom->shapes;
                 i < src->geom->num_shapes;
                 i++, sshape++, dshape++) {
                if (sshape->num_outlines) {
                    tmp = xcalloc(sshape->num_outlines, sizeof(XkbOutlineRec));
                    if (!tmp)
                        return FALSE;
                    dshape->outlines = tmp;
                    
                    for (j = 0,
                          soutline = sshape->outlines,
                          doutline = dshape->outlines;
                         j < sshape->num_outlines;
                         j++, soutline++, doutline++) {
                        if (soutline->num_points) {
                            tmp = xalloc(soutline->num_points *
                                          sizeof(XkbPointRec));
                            if (!tmp)
                                return FALSE;
                            doutline->points = tmp;

                            memcpy(doutline->points, soutline->points,
                                   soutline->num_points * sizeof(XkbPointRec));
                        }

                        doutline->num_points = soutline->num_points;
                        doutline->sz_points = soutline->sz_points;
                    }
                }

                dshape->num_outlines = sshape->num_outlines;
                dshape->sz_outlines = sshape->num_outlines;
            }

            dst->geom->num_shapes = src->geom->num_shapes;
            dst->geom->sz_shapes = src->geom->num_shapes;
        }
        else {
            if (dst->geom->sz_shapes) {
                xfree(dst->geom->shapes);
                dst->geom->shapes = NULL;
            }
            
            dst->geom->num_shapes = 0;
            dst->geom->sz_shapes = 0;
        }

        /* sections */
        /* sections break down into doodads, and also into rows, which break
         * down into keys. */
        if (dst->geom->num_sections) {
            for (i = 0, dsection = dst->geom->sections;
                 i < dst->geom->num_sections;
                 i++, dsection++) {
                for (j = 0, drow = dsection->rows;
                     j < dsection->num_rows;
                     j++, drow++) {
                    if (drow->num_keys)
                        xfree(drow->keys);
                }

                if (dsection->num_rows)
                    xfree(dsection->rows);

                /* cut and waste from geom/doodad below. */
                for (j = 0, ddoodad = dsection->doodads;
                     j < dsection->num_doodads;
                     j++, ddoodad++) {
                    if (ddoodad->any.type == XkbTextDoodad) {
                        if (ddoodad->text.text) {
                            xfree(ddoodad->text.text);
                            ddoodad->text.text = NULL;
                        }
                        if (ddoodad->text.font) {
                            xfree(ddoodad->text.font);
                            ddoodad->text.font = NULL;
                        }
                     }
                     else if (ddoodad->any.type == XkbLogoDoodad) {
                        if (ddoodad->logo.logo_name) {
                            xfree(ddoodad->logo.logo_name);
                            ddoodad->logo.logo_name = NULL;
                        }
                    }
                }

                if (dsection->num_doodads)
                    xfree(dsection->doodads);
            }

            dst->geom->num_sections = 0;
        }

        if (src->geom->num_sections) {
            if (dst->geom->sz_sections)
                tmp = xrealloc(dst->geom->sections,
                               src->geom->num_sections *
                                sizeof(XkbSectionRec));
            else
                tmp = xalloc(src->geom->num_sections * sizeof(XkbSectionRec));
            if (!tmp)
                return FALSE;
            dst->geom->sections = tmp;

            for (i = 0,
                  ssection = src->geom->sections,
                  dsection = dst->geom->sections;
                 i < src->geom->num_sections;
                 i++, ssection++, dsection++) {
                if (ssection->num_rows) {
                    tmp = xcalloc(ssection->num_rows, sizeof(XkbRowRec));
                    if (!tmp)
                        return FALSE;
                    dsection->rows = tmp;
                }
                for (j = 0, srow = ssection->rows, drow = dsection->rows;
                     j < ssection->num_rows;
                     j++, srow++, drow++) {
                    if (srow->num_keys) {
                        tmp = xalloc(srow->num_keys * sizeof(XkbKeyRec));
                        if (!tmp)
                            return FALSE;
                        drow->keys = tmp;
                        memcpy(drow->keys, srow->keys,
                               srow->num_keys * sizeof(XkbKeyRec));
                    }
                    drow->num_keys = srow->num_keys;
                    drow->sz_keys = srow->num_keys;
                }

                if (ssection->num_doodads) {
                    tmp = xcalloc(ssection->num_doodads, sizeof(XkbDoodadRec));
                    if (!tmp)
                        return FALSE;
                    dsection->doodads = tmp;
                }
                for (k = 0,
                      sdoodad = ssection->doodads,
                      ddoodad = dsection->doodads;
                     k < ssection->num_doodads;
                     k++, sdoodad++, ddoodad++) {
                    if (sdoodad->any.type == XkbTextDoodad) {
                        if (sdoodad->text.text)
                            ddoodad->text.text =
                             xstrdup(sdoodad->text.text);
                        if (sdoodad->text.font)
                            ddoodad->text.font =
                             xstrdup(sdoodad->text.font);
                    }
                    else if (sdoodad->any.type == XkbLogoDoodad) {
                        if (sdoodad->logo.logo_name)
                            ddoodad->logo.logo_name =
                             xstrdup(sdoodad->logo.logo_name);
                    }
                    ddoodad->any.type = sdoodad->any.type;
                }
                dsection->num_doodads = ssection->num_doodads;
                dsection->sz_doodads = ssection->num_doodads;
            }
        }
        else {
            if (dst->geom->sz_sections) {
                xfree(dst->geom->sections);
                dst->geom->sections = NULL;
            }

            dst->geom->num_sections = 0;
            dst->geom->sz_sections = 0;
        }

        /* doodads */
        if (dst->geom->num_doodads) {
            for (i = src->geom->num_doodads,
                  ddoodad = dst->geom->doodads +
                             src->geom->num_doodads;
                 i < dst->geom->num_doodads;
                 i++, ddoodad++) {
                 if (ddoodad->any.type == XkbTextDoodad) {
                    if (ddoodad->text.text) {
                        xfree(ddoodad->text.text);
                        ddoodad->text.text = NULL;
                    }
                    if (ddoodad->text.font) {
                        xfree(ddoodad->text.font);
                        ddoodad->text.font = NULL;
                    }
                 }
                 else if (ddoodad->any.type == XkbLogoDoodad) {
                    if (ddoodad->logo.logo_name) {
                        xfree(ddoodad->logo.logo_name);
                        ddoodad->logo.logo_name = NULL;
                    }
                }
            }
        }

        if (src->geom->num_doodads) {
            if (dst->geom->sz_doodads)
                tmp = xrealloc(dst->geom->doodads,
                               src->geom->num_doodads *
                                sizeof(XkbDoodadRec));
            else
                tmp = xalloc(src->geom->num_doodads *
                              sizeof(XkbDoodadRec));
            if (!tmp)
                return FALSE;
            bzero(tmp, src->geom->num_doodads * sizeof(XkbDoodadRec));
            dst->geom->doodads = tmp;

            dst->geom->sz_doodads = src->geom->num_doodads;

            for (i = 0,
                  sdoodad = src->geom->doodads,
                  ddoodad = dst->geom->doodads;
                 i < src->geom->num_doodads;
                 i++, sdoodad++, ddoodad++) {
                ddoodad->any.type = sdoodad->any.type;
                if (sdoodad->any.type == XkbTextDoodad) {
                    if (sdoodad->text.text)
                        ddoodad->text.text = xstrdup(sdoodad->text.text);
                    if (sdoodad->text.font)
                        ddoodad->text.font = xstrdup(sdoodad->text.font);
                }
                else if (sdoodad->any.type == XkbLogoDoodad) {
                    if (sdoodad->logo.logo_name)
                        ddoodad->logo.logo_name =
                          xstrdup(sdoodad->logo.logo_name);
                }
            }

            dst->geom->num_doodads = dst->geom->sz_doodads;
        }
        else {
            if (dst->geom->sz_doodads) {
                xfree(dst->geom->doodads);
                dst->geom->doodads = NULL;
            }

            dst->geom->num_doodads = 0;
            dst->geom->sz_doodads = 0;
        }

        /* key aliases */
        if (src->geom->num_key_aliases) {
            if (src->geom->num_key_aliases != dst->geom->sz_key_aliases) {
                if (dst->geom->sz_key_aliases)
                    tmp = xrealloc(dst->geom->key_aliases,
                                   src->geom->num_key_aliases *
                                    2 * XkbKeyNameLength);
                else
                    tmp = xalloc(src->geom->num_key_aliases *
                                  2 * XkbKeyNameLength);
                if (!tmp)
                    return FALSE;
                dst->geom->key_aliases = tmp;

                dst->geom->sz_key_aliases = src->geom->num_key_aliases;
            }

            memcpy(dst->geom->key_aliases, src->geom->key_aliases,
                   src->geom->num_key_aliases * 2 * XkbKeyNameLength);

            dst->geom->num_key_aliases = dst->geom->sz_key_aliases;
        }
        else {
            if (dst->geom->sz_key_aliases && dst->geom->key_aliases) {
                xfree(dst->geom->key_aliases);
                dst->geom->key_aliases = NULL;
            }
            dst->geom->num_key_aliases = 0;
            dst->geom->sz_key_aliases = 0;
        }
        
        /* font */
        if (src->geom->label_font) {
            if (!dst->geom->label_font) {
                tmp = xalloc(strlen(src->geom->label_font));
                if (!tmp)
                    return FALSE;
                dst->geom->label_font = tmp;
            }
            else if (strlen(src->geom->label_font) !=
                strlen(dst->geom->label_font)) {
                tmp = xrealloc(dst->geom->label_font,
                               strlen(src->geom->label_font));
                if (!tmp)
                    return FALSE;
                dst->geom->label_font = tmp;
            }

            strcpy(dst->geom->label_font, src->geom->label_font);
            i = XkbGeomColorIndex(src->geom, src->geom->label_color);
            dst->geom->label_color = &(src->geom->colors[i]);
            i = XkbGeomColorIndex(src->geom, src->geom->base_color);
            dst->geom->base_color = &(src->geom->colors[i]);
        }
        else {
            if (dst->geom->label_font) {
                xfree(dst->geom->label_font);
                dst->geom->label_font = NULL;
            }
            dst->geom->label_color = NULL;
            dst->geom->base_color = NULL;
        }

        dst->geom->name = src->geom->name;
        dst->geom->width_mm = src->geom->width_mm;
        dst->geom->height_mm = src->geom->height_mm;
    }
    else
    {
        if (dst->geom) {
            /* I LOVE THE DIFFERENT CALL SIGNATURE.  REALLY, I DO. */
            XkbFreeGeometry(dst->geom, XkbGeomAllMask, True);
            dst->geom = NULL;
        }
    }

    if (inputInfo.keyboard->key->xkbInfo &&
        inputInfo.keyboard->key->xkbInfo->desc == dst) {
        pDev = inputInfo.keyboard;
    }
    else {
        for (tmpDev = inputInfo.devices; tmpDev && !pDev;
             tmpDev = tmpDev->next) {
            if (tmpDev->key && tmpDev->key->xkbInfo &&
                tmpDev->key->xkbInfo->desc == dst) {
                pDev = tmpDev;
                break;
            }
        }
        for (tmpDev = inputInfo.off_devices; tmpDev && !pDev;
             tmpDev = tmpDev->next) {
            if (tmpDev->key && tmpDev->key->xkbInfo &&
                tmpDev->key->xkbInfo->desc == dst) {
                pDev = tmpDev;
                break;
            }
        }
    }

    if (sendNotifies) {
        if (!pDev) {
            ErrorF("XkbCopyKeymap: asked for notifies, but can't find device!\n");
        }
        else {
            /* send NewKeyboardNotify if the keycode range changed, else
             * just MapNotify.  we also need to send NKN if the geometry
             * changed (obviously ...). */
            if ((src->min_key_code != dst->min_key_code ||
                 src->max_key_code != dst->max_key_code) && sendNotifies) {
                nkn.oldMinKeyCode = dst->min_key_code;
                nkn.oldMaxKeyCode = dst->max_key_code;
                nkn.deviceID = nkn.oldDeviceID = pDev->id;
                nkn.minKeyCode = src->min_key_code;
                nkn.maxKeyCode = src->max_key_code;
                nkn.requestMajor = XkbReqCode;
                nkn.requestMinor = X_kbSetMap; /* XXX bare-faced lie */
                nkn.changed = XkbAllNewKeyboardEventsMask;
                XkbSendNewKeyboardNotify(pDev, &nkn);
            }
            else if (sendNotifies) {
                mn.deviceID = pDev->id;
                mn.minKeyCode = src->min_key_code;
                mn.maxKeyCode = src->max_key_code;
                mn.firstType = 0;
                mn.nTypes = src->map->num_types;
                mn.firstKeySym = src->min_key_code;
                mn.nKeySyms = XkbNumKeys(src);
                mn.firstKeyAct = src->min_key_code;
                mn.nKeyActs = XkbNumKeys(src);
                /* Cargo-culted from ProcXkbGetMap. */
                mn.firstKeyBehavior = src->min_key_code;
                mn.nKeyBehaviors = XkbNumKeys(src);
                mn.firstKeyExplicit = src->min_key_code;
                mn.nKeyExplicit = XkbNumKeys(src);
                mn.firstModMapKey = src->min_key_code;
                mn.nModMapKeys = XkbNumKeys(src);
                mn.firstVModMapKey = src->min_key_code;
                mn.nVModMapKeys = XkbNumKeys(src);
                mn.virtualMods = ~0; /* ??? */
                mn.changed = XkbAllMapComponentsMask;                
                XkbSendMapNotify(pDev, &mn);
            }
        }
    }

    dst->min_key_code = src->min_key_code;
    dst->max_key_code = src->max_key_code;

    return TRUE;
@

