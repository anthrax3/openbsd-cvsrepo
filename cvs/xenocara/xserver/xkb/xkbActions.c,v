head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	s0SI41sEunLdyFfd;

1.12
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2014.05.02.19.27.51;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.56;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.32;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.11;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.21;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.21;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.32;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.13.21.06.44;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "misc.h"
#include "inputstr.h"
#include "exevents.h"
#include "eventstr.h"
#include <xkbsrv.h>
#include "xkb.h"
#include <ctype.h>
#include "mi.h"
#include "mipointer.h"
#include "inpututils.h"
#define EXTENSION_EVENT_BASE 64

DevPrivateKeyRec xkbDevicePrivateKeyRec;

static void XkbFakePointerMotion(DeviceIntPtr dev, unsigned flags, int x,
                                 int y);

void
xkbUnwrapProc(DeviceIntPtr device, DeviceHandleProc proc, void *data)
{
    xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(device);
    ProcessInputProc backupproc;

    if (xkbPrivPtr->unwrapProc)
        xkbPrivPtr->unwrapProc = NULL;

    UNWRAP_PROCESS_INPUT_PROC(device, xkbPrivPtr, backupproc);
    proc(device, data);
    COND_WRAP_PROCESS_INPUT_PROC(device, xkbPrivPtr, backupproc, xkbUnwrapProc);
}

Bool
XkbInitPrivates(void)
{
    return dixRegisterPrivateKey(&xkbDevicePrivateKeyRec, PRIVATE_DEVICE,
                                 sizeof(xkbDeviceInfoRec));
}

void
XkbSetExtension(DeviceIntPtr device, ProcessInputProc proc)
{
    xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(device);

    WRAP_PROCESS_INPUT_PROC(device, xkbPrivPtr, proc, xkbUnwrapProc);
}

/***====================================================================***/

static XkbAction
_FixUpAction(XkbDescPtr xkb, XkbAction *act)
{
    static XkbAction fake;

    if (XkbIsPtrAction(act) &&
        (!(xkb->ctrls->enabled_ctrls & XkbMouseKeysMask))) {
        fake.type = XkbSA_NoAction;
        return fake;
    }
    if (xkb->ctrls->enabled_ctrls & XkbStickyKeysMask) {
        if (act->any.type == XkbSA_SetMods) {
            fake.mods.type = XkbSA_LatchMods;
            fake.mods.mask = act->mods.mask;
            if (XkbAX_NeedOption(xkb->ctrls, XkbAX_LatchToLockMask))
                fake.mods.flags = XkbSA_ClearLocks | XkbSA_LatchToLock;
            else
                fake.mods.flags = XkbSA_ClearLocks;
            return fake;
        }
        if (act->any.type == XkbSA_SetGroup) {
            fake.group.type = XkbSA_LatchGroup;
            if (XkbAX_NeedOption(xkb->ctrls, XkbAX_LatchToLockMask))
                fake.group.flags = XkbSA_ClearLocks | XkbSA_LatchToLock;
            else
                fake.group.flags = XkbSA_ClearLocks;
            XkbSASetGroup(&fake.group, XkbSAGroup(&act->group));
            return fake;
        }
    }
    return *act;
}

static XkbAction
XkbGetKeyAction(XkbSrvInfoPtr xkbi, XkbStatePtr xkbState, CARD8 key)
{
    int effectiveGroup;
    int col;
    XkbDescPtr xkb;
    XkbKeyTypePtr type;
    XkbAction *pActs;
    static XkbAction fake;

    xkb = xkbi->desc;
    if (!XkbKeyHasActions(xkb, key) || !XkbKeycodeInRange(xkb, key)) {
        fake.type = XkbSA_NoAction;
        return fake;
    }
    pActs = XkbKeyActionsPtr(xkb, key);
    col = 0;

    effectiveGroup = XkbGetEffectiveGroup(xkbi, xkbState, key);
    if (effectiveGroup != XkbGroup1Index)
        col += (effectiveGroup * XkbKeyGroupsWidth(xkb, key));

    type = XkbKeyKeyType(xkb, key, effectiveGroup);
    if (type->map != NULL) {
        register unsigned i, mods;
        register XkbKTMapEntryPtr entry;

        mods = xkbState->mods & type->mods.mask;
        for (entry = type->map, i = 0; i < type->map_count; i++, entry++) {
            if ((entry->active) && (entry->mods.mask == mods)) {
                col += entry->level;
                break;
            }
        }
    }
    if (pActs[col].any.type == XkbSA_NoAction)
        return pActs[col];
    fake = _FixUpAction(xkb, &pActs[col]);
    return fake;
}

static XkbAction
XkbGetButtonAction(DeviceIntPtr kbd, DeviceIntPtr dev, int button)
{
    XkbAction fake;

    if ((dev->button) && (dev->button->xkb_acts)) {
        if (dev->button->xkb_acts[button - 1].any.type != XkbSA_NoAction) {
            fake = _FixUpAction(kbd->key->xkbInfo->desc,
                                &dev->button->xkb_acts[button - 1]);
            return fake;
        }
    }
    fake.any.type = XkbSA_NoAction;
    return fake;
}

/***====================================================================***/

#define	SYNTHETIC_KEYCODE	1
#define	BTN_ACT_FLAG		0x100

static int
_XkbFilterSetState(XkbSrvInfoPtr xkbi,
                   XkbFilterPtr filter, unsigned keycode, XkbAction *pAction)
{
    if (filter->keycode == 0) { /* initial press */
        AccessXCancelRepeatKey(xkbi, keycode);
        filter->keycode = keycode;
        filter->active = 1;
        filter->filterOthers = ((pAction->mods.mask & XkbSA_ClearLocks) != 0);
        filter->priv = 0;
        filter->filter = _XkbFilterSetState;
        if (pAction->type == XkbSA_SetMods) {
            filter->upAction = *pAction;
            xkbi->setMods = pAction->mods.mask;
        }
        else {
            xkbi->groupChange = XkbSAGroup(&pAction->group);
            if (pAction->group.flags & XkbSA_GroupAbsolute)
                xkbi->groupChange -= xkbi->state.base_group;
            filter->upAction = *pAction;
            XkbSASetGroup(&filter->upAction.group, xkbi->groupChange);
        }
    }
    else if (filter->keycode == keycode) {
        if (filter->upAction.type == XkbSA_SetMods) {
            xkbi->clearMods = filter->upAction.mods.mask;
            if (filter->upAction.mods.flags & XkbSA_ClearLocks) {
                xkbi->state.locked_mods &= ~filter->upAction.mods.mask;
            }
        }
        else {
            if (filter->upAction.group.flags & XkbSA_ClearLocks) {
                xkbi->state.locked_group = 0;
            }
            xkbi->groupChange = -XkbSAGroup(&filter->upAction.group);
        }
        filter->active = 0;
    }
    else {
        filter->upAction.mods.flags &= ~XkbSA_ClearLocks;
        filter->filterOthers = 0;
    }
    return 1;
}

#define	LATCH_KEY_DOWN	1
#define	LATCH_PENDING	2

static int
_XkbFilterLatchState(XkbSrvInfoPtr xkbi,
                     XkbFilterPtr filter, unsigned keycode, XkbAction *pAction)
{

    if (filter->keycode == 0) { /* initial press */
        AccessXCancelRepeatKey(xkbi,keycode);
        filter->keycode = keycode;
        filter->active = 1;
        filter->filterOthers = 1;
        filter->priv = LATCH_KEY_DOWN;
        filter->filter = _XkbFilterLatchState;
        if (pAction->type == XkbSA_LatchMods) {
            filter->upAction = *pAction;
            xkbi->setMods = pAction->mods.mask;
        }
        else {
            xkbi->groupChange = XkbSAGroup(&pAction->group);
            if (pAction->group.flags & XkbSA_GroupAbsolute)
                xkbi->groupChange -= xkbi->state.base_group;
            filter->upAction = *pAction;
            XkbSASetGroup(&filter->upAction.group, xkbi->groupChange);
        }
    }
    else if (pAction && (filter->priv == LATCH_PENDING)) {
        if (((1 << pAction->type) & XkbSA_BreakLatch) != 0) {
            filter->active = 0;
            /* If one latch is broken, all latches are broken, so it's no use
               to find out which particular latch this filter tracks. */
            xkbi->state.latched_mods = 0;
            xkbi->state.latched_group = 0;
        }
    }
    else if (filter->keycode == keycode && filter->priv != LATCH_PENDING){
        /* The test above for LATCH_PENDING skips subsequent releases of the
           key after it has been released first time and the latch became
           pending. */
        XkbControlsPtr ctrls = xkbi->desc->ctrls;
        int needBeep = ((ctrls->enabled_ctrls & XkbStickyKeysMask) &&
                        XkbAX_NeedFeedback(ctrls, XkbAX_StickyKeysFBMask));

        if (filter->upAction.type == XkbSA_LatchMods) {
            unsigned char mask = filter->upAction.mods.mask;
            unsigned char common;

            xkbi->clearMods = mask;

            /* ClearLocks */
            common = mask & xkbi->state.locked_mods;
            if ((filter->upAction.mods.flags & XkbSA_ClearLocks) && common) {
                mask &= ~common;
                xkbi->state.locked_mods &= ~common;
                if (needBeep)
                    XkbDDXAccessXBeep(xkbi->device, _BEEP_STICKY_UNLOCK,
                                      XkbStickyKeysMask);
            }
            /* LatchToLock */
            common = mask & xkbi->state.latched_mods;
            if ((filter->upAction.mods.flags & XkbSA_LatchToLock) && common) {
                unsigned char newlocked;

                mask &= ~common;
                newlocked = common & ~xkbi->state.locked_mods;
                if(newlocked){
                    xkbi->state.locked_mods |= newlocked;
                    if (needBeep)
                        XkbDDXAccessXBeep(xkbi->device, _BEEP_STICKY_LOCK,
                                          XkbStickyKeysMask);

                }
                xkbi->state.latched_mods &= ~common;
            }
            /* Latch remaining modifiers, if any. */
            if (mask) {
                xkbi->state.latched_mods |= mask;
                filter->priv = LATCH_PENDING;
                if (needBeep)
                    XkbDDXAccessXBeep(xkbi->device, _BEEP_STICKY_LATCH,
                                      XkbStickyKeysMask);
            }
        }
        else {
            xkbi->groupChange = -XkbSAGroup(&filter->upAction.group);
            /* ClearLocks */
            if ((filter->upAction.group.flags & XkbSA_ClearLocks) &&
                (xkbi->state.locked_group)) {
                xkbi->state.locked_group = 0;
                if (needBeep)
                    XkbDDXAccessXBeep(xkbi->device, _BEEP_STICKY_UNLOCK,
                                      XkbStickyKeysMask);
            }
            /* LatchToLock */
            else if ((filter->upAction.group.flags & XkbSA_LatchToLock)
                     && (xkbi->state.latched_group)) {
                xkbi->state.locked_group  += XkbSAGroup(&filter->upAction.group);
                xkbi->state.latched_group -= XkbSAGroup(&filter->upAction.group);
                if(XkbSAGroup(&filter->upAction.group) && needBeep)
                    XkbDDXAccessXBeep(xkbi->device, _BEEP_STICKY_LOCK,
                                      XkbStickyKeysMask);
            }
            /* Latch group */
            else if(XkbSAGroup(&filter->upAction.group)){
                xkbi->state.latched_group += XkbSAGroup(&filter->upAction.group);
                filter->priv = LATCH_PENDING;
                if (needBeep)
                    XkbDDXAccessXBeep(xkbi->device, _BEEP_STICKY_LATCH,
                                      XkbStickyKeysMask);
            }
        }

        if (filter->priv != LATCH_PENDING)
            filter->active = 0;
    }
    else if (pAction && (filter->priv == LATCH_KEY_DOWN)) {
        /* Latch was broken before it became pending: degrade to a
           SetMods/SetGroup. */
        if (filter->upAction.type == XkbSA_LatchMods)
            filter->upAction.type = XkbSA_SetMods;
        else
            filter->upAction.type = XkbSA_SetGroup;
        filter->filter = _XkbFilterSetState;
        filter->priv = 0;
        return filter->filter(xkbi, filter, keycode, pAction);
    }
    return 1;
}

static int
_XkbFilterLockState(XkbSrvInfoPtr xkbi,
                    XkbFilterPtr filter, unsigned keycode, XkbAction *pAction)
{
    if (filter->keycode == 0) /* initial press */
        AccessXCancelRepeatKey(xkbi, keycode);

    if (pAction && (pAction->type == XkbSA_LockGroup)) {
        if (pAction->group.flags & XkbSA_GroupAbsolute)
            xkbi->state.locked_group = XkbSAGroup(&pAction->group);
        else
            xkbi->state.locked_group += XkbSAGroup(&pAction->group);
        return 1;
    }
    if (filter->keycode == 0) { /* initial press */
        filter->keycode = keycode;
        filter->active = 1;
        filter->filterOthers = 0;
        filter->priv = xkbi->state.locked_mods & pAction->mods.mask;
        filter->filter = _XkbFilterLockState;
        filter->upAction = *pAction;
        if (!(filter->upAction.mods.flags & XkbSA_LockNoLock))
            xkbi->state.locked_mods |= pAction->mods.mask;
        xkbi->setMods = pAction->mods.mask;
    }
    else if (filter->keycode == keycode) {
        filter->active = 0;
        xkbi->clearMods = filter->upAction.mods.mask;
        if (!(filter->upAction.mods.flags & XkbSA_LockNoUnlock))
            xkbi->state.locked_mods &= ~filter->priv;
    }
    return 1;
}

#define	ISO_KEY_DOWN		0
#define	NO_ISO_LOCK		1

static int
_XkbFilterISOLock(XkbSrvInfoPtr xkbi,
                  XkbFilterPtr filter, unsigned keycode, XkbAction *pAction)
{

    if (filter->keycode == 0) { /* initial press */
        CARD8 flags = pAction->iso.flags;

        filter->keycode = keycode;
        filter->active = 1;
        filter->filterOthers = 1;
        filter->priv = ISO_KEY_DOWN;
        filter->upAction = *pAction;
        filter->filter = _XkbFilterISOLock;
        if (flags & XkbSA_ISODfltIsGroup) {
            xkbi->groupChange = XkbSAGroup(&pAction->iso);
            xkbi->setMods = 0;
        }
        else {
            xkbi->setMods = pAction->iso.mask;
            xkbi->groupChange = 0;
        }
        if ((!(flags & XkbSA_ISONoAffectMods)) && (xkbi->state.base_mods)) {
            filter->priv = NO_ISO_LOCK;
            xkbi->state.locked_mods ^= xkbi->state.base_mods;
        }
        if ((!(flags & XkbSA_ISONoAffectGroup)) && (xkbi->state.base_group)) {
/* 6/22/93 (ef) -- lock groups if group key is down first */
        }
        if (!(flags & XkbSA_ISONoAffectPtr)) {
/* 6/22/93 (ef) -- lock mouse buttons if they're down */
        }
    }
    else if (filter->keycode == keycode) {
        CARD8 flags = filter->upAction.iso.flags;

        if (flags & XkbSA_ISODfltIsGroup) {
            xkbi->groupChange = -XkbSAGroup(&filter->upAction.iso);
            xkbi->clearMods = 0;
            if (filter->priv == ISO_KEY_DOWN)
                xkbi->state.locked_group += XkbSAGroup(&filter->upAction.iso);
        }
        else {
            xkbi->clearMods = filter->upAction.iso.mask;
            xkbi->groupChange = 0;
            if (filter->priv == ISO_KEY_DOWN)
                xkbi->state.locked_mods ^= filter->upAction.iso.mask;
        }
        filter->active = 0;
    }
    else if (pAction) {
        CARD8 flags = filter->upAction.iso.flags;

        switch (pAction->type) {
        case XkbSA_SetMods:
        case XkbSA_LatchMods:
            if (!(flags & XkbSA_ISONoAffectMods)) {
                pAction->type = XkbSA_LockMods;
                filter->priv = NO_ISO_LOCK;
            }
            break;
        case XkbSA_SetGroup:
        case XkbSA_LatchGroup:
            if (!(flags & XkbSA_ISONoAffectGroup)) {
                pAction->type = XkbSA_LockGroup;
                filter->priv = NO_ISO_LOCK;
            }
            break;
        case XkbSA_PtrBtn:
            if (!(flags & XkbSA_ISONoAffectPtr)) {
                pAction->type = XkbSA_LockPtrBtn;
                filter->priv = NO_ISO_LOCK;
            }
            break;
        case XkbSA_SetControls:
            if (!(flags & XkbSA_ISONoAffectCtrls)) {
                pAction->type = XkbSA_LockControls;
                filter->priv = NO_ISO_LOCK;
            }
            break;
        }
    }
    return 1;
}

static CARD32
_XkbPtrAccelExpire(OsTimerPtr timer, CARD32 now, void *arg)
{
    XkbSrvInfoPtr xkbi = (XkbSrvInfoPtr) arg;
    XkbControlsPtr ctrls = xkbi->desc->ctrls;
    int dx, dy;

    if (xkbi->mouseKey == 0)
        return 0;

    if (xkbi->mouseKeysAccel) {
        if ((xkbi->mouseKeysCounter) < ctrls->mk_time_to_max) {
            double step;

            xkbi->mouseKeysCounter++;
            step = xkbi->mouseKeysCurveFactor *
                pow((double) xkbi->mouseKeysCounter, xkbi->mouseKeysCurve);
            if (xkbi->mouseKeysDX < 0)
                dx = floor(((double) xkbi->mouseKeysDX) * step);
            else
                dx = ceil(((double) xkbi->mouseKeysDX) * step);
            if (xkbi->mouseKeysDY < 0)
                dy = floor(((double) xkbi->mouseKeysDY) * step);
            else
                dy = ceil(((double) xkbi->mouseKeysDY) * step);
        }
        else {
            dx = xkbi->mouseKeysDX * ctrls->mk_max_speed;
            dy = xkbi->mouseKeysDY * ctrls->mk_max_speed;
        }
        if (xkbi->mouseKeysFlags & XkbSA_MoveAbsoluteX)
            dx = xkbi->mouseKeysDX;
        if (xkbi->mouseKeysFlags & XkbSA_MoveAbsoluteY)
            dy = xkbi->mouseKeysDY;
    }
    else {
        dx = xkbi->mouseKeysDX;
        dy = xkbi->mouseKeysDY;
    }
    XkbFakePointerMotion(xkbi->device, xkbi->mouseKeysFlags, dx, dy);
    return xkbi->desc->ctrls->mk_interval;
}

static int
_XkbFilterPointerMove(XkbSrvInfoPtr xkbi,
                      XkbFilterPtr filter, unsigned keycode, XkbAction *pAction)
{
    int x, y;
    Bool accel;

    if (filter->keycode == 0) { /* initial press */
        filter->keycode = keycode;
        filter->active = 1;
        filter->filterOthers = 0;
        filter->priv = 0;
        filter->filter = _XkbFilterPointerMove;
        filter->upAction = *pAction;
        xkbi->mouseKeysCounter = 0;
        xkbi->mouseKey = keycode;
        accel = ((pAction->ptr.flags & XkbSA_NoAcceleration) == 0);
        x = XkbPtrActionX(&pAction->ptr);
        y = XkbPtrActionY(&pAction->ptr);
        XkbFakePointerMotion(xkbi->device, pAction->ptr.flags, x, y);
        AccessXCancelRepeatKey(xkbi, keycode);
        xkbi->mouseKeysAccel = accel &&
            (xkbi->desc->ctrls->enabled_ctrls & XkbMouseKeysAccelMask);
        xkbi->mouseKeysFlags = pAction->ptr.flags;
        xkbi->mouseKeysDX = XkbPtrActionX(&pAction->ptr);
        xkbi->mouseKeysDY = XkbPtrActionY(&pAction->ptr);
        xkbi->mouseKeyTimer = TimerSet(xkbi->mouseKeyTimer, 0,
                                       xkbi->desc->ctrls->mk_delay,
                                       _XkbPtrAccelExpire, (void *) xkbi);
    }
    else if (filter->keycode == keycode) {
        filter->active = 0;
        if (xkbi->mouseKey == keycode) {
            xkbi->mouseKey = 0;
            xkbi->mouseKeyTimer = TimerSet(xkbi->mouseKeyTimer, 0, 0,
                                           NULL, NULL);
        }
    }
    return 0;
}

static int
_XkbFilterPointerBtn(XkbSrvInfoPtr xkbi,
                     XkbFilterPtr filter, unsigned keycode, XkbAction *pAction)
{
    if (filter->keycode == 0) { /* initial press */
        int button = pAction->btn.button;

        if (button == XkbSA_UseDfltButton)
            button = xkbi->desc->ctrls->mk_dflt_btn;

        filter->keycode = keycode;
        filter->active = 1;
        filter->filterOthers = 0;
        filter->priv = 0;
        filter->filter = _XkbFilterPointerBtn;
        filter->upAction = *pAction;
        filter->upAction.btn.button = button;
        switch (pAction->type) {
        case XkbSA_LockPtrBtn:
            if (((xkbi->lockedPtrButtons & (1 << button)) == 0) &&
                ((pAction->btn.flags & XkbSA_LockNoLock) == 0)) {
                xkbi->lockedPtrButtons |= (1 << button);
                AccessXCancelRepeatKey(xkbi, keycode);
                XkbFakeDeviceButton(xkbi->device, 1, button);
                filter->upAction.type = XkbSA_NoAction;
            }
            break;
        case XkbSA_PtrBtn:
        {
            register int i, nClicks;

            AccessXCancelRepeatKey(xkbi, keycode);
            if (pAction->btn.count > 0) {
                nClicks = pAction->btn.count;
                for (i = 0; i < nClicks; i++) {
                    XkbFakeDeviceButton(xkbi->device, 1, button);
                    XkbFakeDeviceButton(xkbi->device, 0, button);
                }
                filter->upAction.type = XkbSA_NoAction;
            }
            else
                XkbFakeDeviceButton(xkbi->device, 1, button);
        }
            break;
        case XkbSA_SetPtrDflt:
        {
            XkbControlsPtr ctrls = xkbi->desc->ctrls;
            XkbControlsRec old;
            xkbControlsNotify cn;

            old = *ctrls;
            AccessXCancelRepeatKey(xkbi, keycode);
            switch (pAction->dflt.affect) {
            case XkbSA_AffectDfltBtn:
                if (pAction->dflt.flags & XkbSA_DfltBtnAbsolute)
                    ctrls->mk_dflt_btn = XkbSAPtrDfltValue(&pAction->dflt);
                else {
                    ctrls->mk_dflt_btn += XkbSAPtrDfltValue(&pAction->dflt);
                    if (ctrls->mk_dflt_btn > 5)
                        ctrls->mk_dflt_btn = 5;
                    else if (ctrls->mk_dflt_btn < 1)
                        ctrls->mk_dflt_btn = 1;
                }
                break;
            default:
                ErrorF
                    ("Attempt to change unknown pointer default (%d) ignored\n",
                     pAction->dflt.affect);
                break;
            }
            if (XkbComputeControlsNotify(xkbi->device,
                                         &old, xkbi->desc->ctrls, &cn, FALSE)) {
                cn.keycode = keycode;
                /* XXX: what about DeviceKeyPress? */
                cn.eventType = KeyPress;
                cn.requestMajor = 0;
                cn.requestMinor = 0;
                XkbSendControlsNotify(xkbi->device, &cn);
            }
        }
            break;
        }
        return 0;
    }
    else if (filter->keycode == keycode) {
        int button = filter->upAction.btn.button;

        switch (filter->upAction.type) {
        case XkbSA_LockPtrBtn:
            if (((filter->upAction.btn.flags & XkbSA_LockNoUnlock) != 0) ||
                ((xkbi->lockedPtrButtons & (1 << button)) == 0)) {
                break;
            }
            xkbi->lockedPtrButtons &= ~(1 << button);

            if (IsMaster(xkbi->device)) {
                XkbMergeLockedPtrBtns(xkbi->device);
                /* One SD still has lock set, don't post event */
                if ((xkbi->lockedPtrButtons & (1 << button)) != 0)
                    break;
            }

            /* fallthrough */
        case XkbSA_PtrBtn:
            XkbFakeDeviceButton(xkbi->device, 0, button);
            break;
        }
        filter->active = 0;
        return 0;
    }
    return 1;
}

static int
_XkbFilterControls(XkbSrvInfoPtr xkbi,
                   XkbFilterPtr filter, unsigned keycode, XkbAction *pAction)
{
    XkbControlsRec old;
    XkbControlsPtr ctrls;
    DeviceIntPtr kbd;
    unsigned int change;
    XkbEventCauseRec cause;

    kbd = xkbi->device;
    ctrls = xkbi->desc->ctrls;
    old = *ctrls;
    if (filter->keycode == 0) { /* initial press */
        AccessXCancelRepeatKey(xkbi, keycode);
        filter->keycode = keycode;
        filter->active = 1;
        filter->filterOthers = 0;
        change = XkbActionCtrls(&pAction->ctrls);
        filter->priv = change;
        filter->filter = _XkbFilterControls;
        filter->upAction = *pAction;

        if (pAction->type == XkbSA_LockControls) {
            filter->priv = (ctrls->enabled_ctrls & change);
            change &= ~ctrls->enabled_ctrls;
        }

        if (change) {
            xkbControlsNotify cn;
            XkbSrvLedInfoPtr sli;

            ctrls->enabled_ctrls |= change;
            if (XkbComputeControlsNotify(kbd, &old, ctrls, &cn, FALSE)) {
                cn.keycode = keycode;
                /* XXX: what about DeviceKeyPress? */
                cn.eventType = KeyPress;
                cn.requestMajor = 0;
                cn.requestMinor = 0;
                XkbSendControlsNotify(kbd, &cn);
            }

            XkbSetCauseKey(&cause, keycode, KeyPress);

            /* If sticky keys were disabled, clear all locks and latches */
            if ((old.enabled_ctrls & XkbStickyKeysMask) &&
                (!(ctrls->enabled_ctrls & XkbStickyKeysMask))) {
                XkbClearAllLatchesAndLocks(kbd, xkbi, FALSE, &cause);
            }
            sli = XkbFindSrvLedInfo(kbd, XkbDfltXIClass, XkbDfltXIId, 0);
            XkbUpdateIndicators(kbd, sli->usesControls, TRUE, NULL, &cause);
            if (XkbAX_NeedFeedback(ctrls, XkbAX_FeatureFBMask))
                XkbDDXAccessXBeep(kbd, _BEEP_FEATURE_ON, change);
        }
    }
    else if (filter->keycode == keycode) {
        change = filter->priv;
        if (change) {
            xkbControlsNotify cn;
            XkbSrvLedInfoPtr sli;

            ctrls->enabled_ctrls &= ~change;
            if (XkbComputeControlsNotify(kbd, &old, ctrls, &cn, FALSE)) {
                cn.keycode = keycode;
                cn.eventType = KeyRelease;
                cn.requestMajor = 0;
                cn.requestMinor = 0;
                XkbSendControlsNotify(kbd, &cn);
            }

            XkbSetCauseKey(&cause, keycode, KeyRelease);
            /* If sticky keys were disabled, clear all locks and latches */
            if ((old.enabled_ctrls & XkbStickyKeysMask) &&
                (!(ctrls->enabled_ctrls & XkbStickyKeysMask))) {
                XkbClearAllLatchesAndLocks(kbd, xkbi, FALSE, &cause);
            }
            sli = XkbFindSrvLedInfo(kbd, XkbDfltXIClass, XkbDfltXIId, 0);
            XkbUpdateIndicators(kbd, sli->usesControls, TRUE, NULL, &cause);
            if (XkbAX_NeedFeedback(ctrls, XkbAX_FeatureFBMask))
                XkbDDXAccessXBeep(kbd, _BEEP_FEATURE_OFF, change);
        }
        filter->keycode = 0;
        filter->active = 0;
    }
    return 1;
}

static int
_XkbFilterActionMessage(XkbSrvInfoPtr xkbi,
                        XkbFilterPtr filter,
                        unsigned keycode, XkbAction *pAction)
{
    XkbMessageAction *pMsg;
    DeviceIntPtr kbd;

    if ((filter->keycode != 0) && (filter->keycode != keycode))
	return 1;

    /* This can happen if the key repeats, and the state (modifiers or group)
       changes meanwhile. */
    if ((filter->keycode == keycode) && pAction &&
	(pAction->type != XkbSA_ActionMessage))
	return 1;

    kbd = xkbi->device;
    if (filter->keycode == 0) { /* initial press */
        pMsg = &pAction->msg;
        if ((pMsg->flags & XkbSA_MessageOnRelease) ||
            ((pMsg->flags & XkbSA_MessageGenKeyEvent) == 0)) {
            filter->keycode = keycode;
            filter->active = 1;
            filter->filterOthers = 0;
            filter->priv = 0;
            filter->filter = _XkbFilterActionMessage;
            filter->upAction = *pAction;
        }
        if (pMsg->flags & XkbSA_MessageOnPress) {
            xkbActionMessage msg;

            msg.keycode = keycode;
            msg.press = 1;
            msg.keyEventFollows =
                ((pMsg->flags & XkbSA_MessageGenKeyEvent) != 0);
            memcpy((char *) msg.message, (char *) pMsg->message,
                   XkbActionMessageLength);
            XkbSendActionMessage(kbd, &msg);
        }
        return ((pAction->msg.flags & XkbSA_MessageGenKeyEvent) != 0);
    }
    else if (filter->keycode == keycode) {
        pMsg = &filter->upAction.msg;
	if (pAction == NULL) {
	    if (pMsg->flags & XkbSA_MessageOnRelease) {
		xkbActionMessage msg;

		msg.keycode = keycode;
		msg.press = 0;
		msg.keyEventFollows =
		    ((pMsg->flags & XkbSA_MessageGenKeyEvent) != 0);
		memcpy((char *) msg.message, (char *) pMsg->message,
		       XkbActionMessageLength);
		XkbSendActionMessage(kbd, &msg);
	    }
	    filter->keycode = 0;
	    filter->active = 0;
	    return ((pMsg->flags & XkbSA_MessageGenKeyEvent) != 0);
	} else if (memcmp(pMsg, pAction, 8) == 0) {
	    /* Repeat: If we send the same message, avoid multiple messages
	       on release from piling up. */
	    filter->keycode = 0;
	    filter->active = 0;
        }
    }
    return 1;
}

static int
_XkbFilterRedirectKey(XkbSrvInfoPtr xkbi,
                      XkbFilterPtr filter, unsigned keycode, XkbAction *pAction)
{
    DeviceEvent ev;
    int x, y;
    XkbStateRec old, old_prev;
    unsigned mods, mask;
    xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(xkbi->device);
    ProcessInputProc backupproc;

    if ((filter->keycode != 0) && (filter->keycode != keycode))
        return 1;

    /* This can happen if the key repeats, and the state (modifiers or group)
       changes meanwhile. */
    if ((filter->keycode == keycode) && pAction &&
	(pAction->type != XkbSA_RedirectKey))
	return 1;

    /* never actually used uninitialised, but gcc isn't smart enough
     * to work that out. */
    memset(&old, 0, sizeof(old));
    memset(&old_prev, 0, sizeof(old_prev));
    memset(&ev, 0, sizeof(ev));

    GetSpritePosition(xkbi->device, &x, &y);
    ev.header = ET_Internal;
    ev.length = sizeof(DeviceEvent);
    ev.time = GetTimeInMillis();
    ev.root_x = x;
    ev.root_y = y;
    /* redirect actions do not work across devices, therefore the following is
     * correct: */
    ev.deviceid = xkbi->device->id;
    /* filter->priv must be set up by the caller for the initial press. */
    ev.sourceid = filter->priv;

    if (filter->keycode == 0) { /* initial press */
        if ((pAction->redirect.new_key < xkbi->desc->min_key_code) ||
            (pAction->redirect.new_key > xkbi->desc->max_key_code)) {
            return 1;
        }
        filter->keycode = keycode;
        filter->active = 1;
        filter->filterOthers = 0;
        filter->filter = _XkbFilterRedirectKey;
        filter->upAction = *pAction;

        ev.type = ET_KeyPress;
        ev.detail.key = pAction->redirect.new_key;

        mask = XkbSARedirectVModsMask(&pAction->redirect);
        mods = XkbSARedirectVMods(&pAction->redirect);
        if (mask)
            XkbVirtualModsToReal(xkbi->desc, mask, &mask);
        if (mods)
            XkbVirtualModsToReal(xkbi->desc, mods, &mods);
        mask |= pAction->redirect.mods_mask;
        mods |= pAction->redirect.mods;

        if (mask || mods) {
            old = xkbi->state;
            old_prev = xkbi->prev_state;
            xkbi->state.base_mods &= ~mask;
            xkbi->state.base_mods |= (mods & mask);
            xkbi->state.latched_mods &= ~mask;
            xkbi->state.latched_mods |= (mods & mask);
            xkbi->state.locked_mods &= ~mask;
            xkbi->state.locked_mods |= (mods & mask);
            XkbComputeDerivedState(xkbi);
            xkbi->prev_state = xkbi->state;
        }

        UNWRAP_PROCESS_INPUT_PROC(xkbi->device, xkbPrivPtr, backupproc);
        xkbi->device->public.processInputProc((InternalEvent *) &ev,
                                              xkbi->device);
        COND_WRAP_PROCESS_INPUT_PROC(xkbi->device, xkbPrivPtr, backupproc,
                                     xkbUnwrapProc);

        if (mask || mods) {
            xkbi->state = old;
            xkbi->prev_state = old_prev;
        }
	return 0;
    }
    else {
	/* If it is a key release, or we redirect to another key, release the
	   previous new_key.  Otherwise, repeat. */
	ev.detail.key = filter->upAction.redirect.new_key;
	if (pAction == NULL ||  ev.detail.key != pAction->redirect.new_key) {
	    ev.type = ET_KeyRelease;
	    filter->active = 0;
	}
	else {
	    ev.type = ET_KeyPress;
	    ev.key_repeat = TRUE;
	}

	mask = XkbSARedirectVModsMask(&filter->upAction.redirect);
	mods = XkbSARedirectVMods(&filter->upAction.redirect);
	if (mask)
	    XkbVirtualModsToReal(xkbi->desc, mask, &mask);
	if (mods)
	    XkbVirtualModsToReal(xkbi->desc, mods, &mods);
	mask |= filter->upAction.redirect.mods_mask;
	mods |= filter->upAction.redirect.mods;

	if (mask || mods) {
	    old = xkbi->state;
	    old_prev = xkbi->prev_state;
	    xkbi->state.base_mods &= ~mask;
	    xkbi->state.base_mods |= (mods & mask);
	    xkbi->state.latched_mods &= ~mask;
	    xkbi->state.latched_mods |= (mods & mask);
	    xkbi->state.locked_mods &= ~mask;
	    xkbi->state.locked_mods |= (mods & mask);
	    XkbComputeDerivedState(xkbi);
	    xkbi->prev_state = xkbi->state;
	}

	UNWRAP_PROCESS_INPUT_PROC(xkbi->device, xkbPrivPtr, backupproc);
	xkbi->device->public.processInputProc((InternalEvent *) &ev,
					      xkbi->device);
	COND_WRAP_PROCESS_INPUT_PROC(xkbi->device, xkbPrivPtr, backupproc,
				     xkbUnwrapProc);

	if (mask || mods) {
	    xkbi->state = old;
	    xkbi->prev_state = old_prev;
	}

	/* We return 1 in case we have sent a release event because the new_key
	   has changed.  Then, subsequently, we will call this function again
	   with the same pAction, which will create the press for the new
	   new_key. */
	return (pAction && ev.detail.key != pAction->redirect.new_key);
    }
}

static int
_XkbFilterSwitchScreen(XkbSrvInfoPtr xkbi,
                       XkbFilterPtr filter,
                       unsigned keycode, XkbAction *pAction)
{
    DeviceIntPtr dev = xkbi->device;

    if (dev == inputInfo.keyboard)
        return 0;

    if (filter->keycode == 0) { /* initial press */
        filter->keycode = keycode;
        filter->active = 1;
        filter->filterOthers = 0;
        filter->filter = _XkbFilterSwitchScreen;
        AccessXCancelRepeatKey(xkbi, keycode);
        XkbDDXSwitchScreen(dev, keycode, pAction);
        return 0;
    }
    else if (filter->keycode == keycode) {
        filter->active = 0;
        return 0;
    }
    return 1;
}

static int
_XkbFilterXF86Private(XkbSrvInfoPtr xkbi,
                      XkbFilterPtr filter, unsigned keycode, XkbAction *pAction)
{
    DeviceIntPtr dev = xkbi->device;

    if (dev == inputInfo.keyboard)
        return 0;

    if (filter->keycode == 0) { /* initial press */
        filter->keycode = keycode;
        filter->active = 1;
        filter->filterOthers = 0;
        filter->filter = _XkbFilterXF86Private;
        XkbDDXPrivate(dev, keycode, pAction);
        return 0;
    }
    else if (filter->keycode == keycode) {
        filter->active = 0;
        return 0;
    }
    return 1;
}

static int
_XkbFilterDeviceBtn(XkbSrvInfoPtr xkbi,
                    XkbFilterPtr filter, unsigned keycode, XkbAction *pAction)
{
    if (xkbi->device == inputInfo.keyboard)
        return 0;

    if (filter->keycode == 0) { /* initial press */
        DeviceIntPtr dev;
        int button;

        _XkbLookupButtonDevice(&dev, pAction->devbtn.device, serverClient,
                               DixUnknownAccess, &button);
        if (!dev || !dev->public.on)
            return 1;

        button = pAction->devbtn.button;
        if ((button < 1) || (button > dev->button->numButtons))
            return 1;

        filter->keycode = keycode;
        filter->active = 1;
        filter->filterOthers = 0;
        filter->priv = 0;
        filter->filter = _XkbFilterDeviceBtn;
        filter->upAction = *pAction;
        switch (pAction->type) {
        case XkbSA_LockDeviceBtn:
            if ((pAction->devbtn.flags & XkbSA_LockNoLock) ||
                BitIsOn(dev->button->down, button))
                return 0;
            XkbFakeDeviceButton(dev, TRUE, button);
            filter->upAction.type = XkbSA_NoAction;
            break;
        case XkbSA_DeviceBtn:
            if (pAction->devbtn.count > 0) {
                int nClicks, i;

                nClicks = pAction->btn.count;
                for (i = 0; i < nClicks; i++) {
                    XkbFakeDeviceButton(dev, TRUE, button);
                    XkbFakeDeviceButton(dev, FALSE, button);
                }
                filter->upAction.type = XkbSA_NoAction;
            }
            else
                XkbFakeDeviceButton(dev, TRUE, button);
            break;
        }
    }
    else if (filter->keycode == keycode) {
        DeviceIntPtr dev;
        int button;

        filter->active = 0;
        _XkbLookupButtonDevice(&dev, filter->upAction.devbtn.device,
                               serverClient, DixUnknownAccess, &button);
        if (!dev || !dev->public.on)
            return 1;

        button = filter->upAction.btn.button;
        switch (filter->upAction.type) {
        case XkbSA_LockDeviceBtn:
            if ((filter->upAction.devbtn.flags & XkbSA_LockNoUnlock) ||
                !BitIsOn(dev->button->down, button))
                return 0;
            XkbFakeDeviceButton(dev, FALSE, button);
            break;
        case XkbSA_DeviceBtn:
            XkbFakeDeviceButton(dev, FALSE, button);
            break;
        }
        filter->active = 0;
    }
    return 0;
}

static XkbFilterPtr
_XkbNextFreeFilter(XkbSrvInfoPtr xkbi)
{
    register int i;

    if (xkbi->szFilters == 0) {
        xkbi->szFilters = 4;
        xkbi->filters = calloc(xkbi->szFilters, sizeof(XkbFilterRec));
        /* 6/21/93 (ef) -- XXX! deal with allocation failure */
    }
    for (i = 0; i < xkbi->szFilters; i++) {
        if (!xkbi->filters[i].active) {
            xkbi->filters[i].keycode = 0;
            return &xkbi->filters[i];
        }
    }
    xkbi->szFilters *= 2;
    xkbi->filters = reallocarray(xkbi->filters,
                                 xkbi->szFilters, sizeof(XkbFilterRec));
    /* 6/21/93 (ef) -- XXX! deal with allocation failure */
    memset(&xkbi->filters[xkbi->szFilters / 2], 0,
           (xkbi->szFilters / 2) * sizeof(XkbFilterRec));
    return &xkbi->filters[xkbi->szFilters / 2];
}

static int
_XkbApplyFilters(XkbSrvInfoPtr xkbi, unsigned kc, XkbAction *pAction)
{
    register int i, send;

    send = 1;
    for (i = 0; i < xkbi->szFilters; i++) {
        if ((xkbi->filters[i].active) && (xkbi->filters[i].filter))
            send =
                ((*xkbi->filters[i].filter) (xkbi, &xkbi->filters[i], kc,
                                             pAction)
                 && send);
    }
    return send;
}

static int
_XkbEnsureStateChange(XkbSrvInfoPtr xkbi)
{
    Bool genStateNotify = FALSE;

    /* The state may change, so if we're not in the middle of sending a state
     * notify, prepare for it */
    if ((xkbi->flags & _XkbStateNotifyInProgress) == 0) {
        xkbi->prev_state = xkbi->state;
        xkbi->flags |= _XkbStateNotifyInProgress;
        genStateNotify = TRUE;
    }

    return genStateNotify;
}

static void
_XkbApplyState(DeviceIntPtr dev, Bool genStateNotify, int evtype, int key)
{
    XkbSrvInfoPtr xkbi = dev->key->xkbInfo;
    int changed;

    XkbComputeDerivedState(xkbi);

    changed = XkbStateChangedFlags(&xkbi->prev_state, &xkbi->state);
    if (genStateNotify) {
        if (changed) {
            xkbStateNotify sn;

            sn.keycode = key;
            sn.eventType = evtype;
            sn.requestMajor = sn.requestMinor = 0;
            sn.changed = changed;
            XkbSendStateNotify(dev, &sn);
        }
        xkbi->flags &= ~_XkbStateNotifyInProgress;
    }

    changed = XkbIndicatorsToUpdate(dev, changed, FALSE);
    if (changed) {
        XkbEventCauseRec cause;
        XkbSetCauseKey(&cause, key, evtype);
        XkbUpdateIndicators(dev, changed, FALSE, NULL, &cause);
    }
}

void
XkbPushLockedStateToSlaves(DeviceIntPtr master, int evtype, int key)
{
    DeviceIntPtr dev;
    Bool genStateNotify;

    nt_list_for_each_entry(dev, inputInfo.devices, next) {
        if (!dev->key || GetMaster(dev, MASTER_KEYBOARD) != master)
            continue;

        genStateNotify = _XkbEnsureStateChange(dev->key->xkbInfo);

        dev->key->xkbInfo->state.locked_mods =
            master->key->xkbInfo->state.locked_mods;

        _XkbApplyState(dev, genStateNotify, evtype, key);
    }
}

void
XkbHandleActions(DeviceIntPtr dev, DeviceIntPtr kbd, DeviceEvent *event)
{
    int key, bit, i;
    XkbSrvInfoPtr xkbi;
    KeyClassPtr keyc;
    int sendEvent;
    Bool genStateNotify;
    XkbAction act;
    XkbFilterPtr filter;
    Bool keyEvent;
    Bool pressEvent;
    ProcessInputProc backupproc;

    xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(dev);

    keyc = kbd->key;
    xkbi = keyc->xkbInfo;
    key = event->detail.key;

    genStateNotify = _XkbEnsureStateChange(xkbi);

    xkbi->clearMods = xkbi->setMods = 0;
    xkbi->groupChange = 0;

    sendEvent = 1;
    keyEvent = ((event->type == ET_KeyPress) || (event->type == ET_KeyRelease));
    pressEvent = ((event->type == ET_KeyPress) ||
                  (event->type == ET_ButtonPress));

    if (pressEvent) {
        if (keyEvent)
            act = XkbGetKeyAction(xkbi, &xkbi->state, key);
        else {
            act = XkbGetButtonAction(kbd, dev, key);
            key |= BTN_ACT_FLAG;
        }
        sendEvent = _XkbApplyFilters(xkbi, key, &act);
        if (sendEvent) {
            switch (act.type) {
            case XkbSA_SetMods:
            case XkbSA_SetGroup:
                filter = _XkbNextFreeFilter(xkbi);
                sendEvent = _XkbFilterSetState(xkbi, filter, key, &act);
                break;
            case XkbSA_LatchMods:
            case XkbSA_LatchGroup:
                filter = _XkbNextFreeFilter(xkbi);
                sendEvent = _XkbFilterLatchState(xkbi, filter, key, &act);
                break;
            case XkbSA_LockMods:
            case XkbSA_LockGroup:
                filter = _XkbNextFreeFilter(xkbi);
                sendEvent = _XkbFilterLockState(xkbi, filter, key, &act);
                break;
            case XkbSA_ISOLock:
                filter = _XkbNextFreeFilter(xkbi);
                sendEvent = _XkbFilterISOLock(xkbi, filter, key, &act);
                break;
            case XkbSA_MovePtr:
                filter = _XkbNextFreeFilter(xkbi);
                sendEvent = _XkbFilterPointerMove(xkbi, filter, key, &act);
                break;
            case XkbSA_PtrBtn:
            case XkbSA_LockPtrBtn:
            case XkbSA_SetPtrDflt:
                filter = _XkbNextFreeFilter(xkbi);
                sendEvent = _XkbFilterPointerBtn(xkbi, filter, key, &act);
                break;
            case XkbSA_Terminate:
                sendEvent = XkbDDXTerminateServer(dev, key, &act);
                break;
            case XkbSA_SwitchScreen:
                filter = _XkbNextFreeFilter(xkbi);
                sendEvent = _XkbFilterSwitchScreen(xkbi, filter, key, &act);
                break;
            case XkbSA_SetControls:
            case XkbSA_LockControls:
                filter = _XkbNextFreeFilter(xkbi);
                sendEvent = _XkbFilterControls(xkbi, filter, key, &act);
                break;
            case XkbSA_ActionMessage:
                filter = _XkbNextFreeFilter(xkbi);
                sendEvent = _XkbFilterActionMessage(xkbi, filter, key, &act);
                break;
            case XkbSA_RedirectKey:
                filter = _XkbNextFreeFilter(xkbi);
                /* redirect actions must create a new DeviceEvent.  The
                 * source device id for this event cannot be obtained from
                 * xkbi, so we pass it here explicitly. The field deviceid
                 * equals to xkbi->device->id. */
                filter->priv = event->sourceid;
                sendEvent = _XkbFilterRedirectKey(xkbi, filter, key, &act);
                break;
            case XkbSA_DeviceBtn:
            case XkbSA_LockDeviceBtn:
                filter = _XkbNextFreeFilter(xkbi);
                sendEvent = _XkbFilterDeviceBtn(xkbi, filter, key, &act);
                break;
            case XkbSA_XFree86Private:
                filter = _XkbNextFreeFilter(xkbi);
                sendEvent = _XkbFilterXF86Private(xkbi, filter, key, &act);
                break;
            }
        }
    }
    else {
        if (!keyEvent)
            key |= BTN_ACT_FLAG;
        sendEvent = _XkbApplyFilters(xkbi, key, NULL);
    }

    if (xkbi->groupChange != 0)
        xkbi->state.base_group += xkbi->groupChange;
    if (xkbi->setMods) {
        for (i = 0, bit = 1; xkbi->setMods; i++, bit <<= 1) {
            if (xkbi->setMods & bit) {
                keyc->modifierKeyCount[i]++;
                xkbi->state.base_mods |= bit;
                xkbi->setMods &= ~bit;
            }
        }
    }
    if (xkbi->clearMods) {
        for (i = 0, bit = 1; xkbi->clearMods; i++, bit <<= 1) {
            if (xkbi->clearMods & bit) {
                keyc->modifierKeyCount[i]--;
                if (keyc->modifierKeyCount[i] <= 0) {
                    xkbi->state.base_mods &= ~bit;
                    keyc->modifierKeyCount[i] = 0;
                }
                xkbi->clearMods &= ~bit;
            }
        }
    }

    if (sendEvent) {
        DeviceIntPtr tmpdev;

        if (keyEvent)
            tmpdev = dev;
        else
            tmpdev = GetMaster(dev, POINTER_OR_FLOAT);

        UNWRAP_PROCESS_INPUT_PROC(tmpdev, xkbPrivPtr, backupproc);
        dev->public.processInputProc((InternalEvent *) event, tmpdev);
        COND_WRAP_PROCESS_INPUT_PROC(tmpdev, xkbPrivPtr,
                                     backupproc, xkbUnwrapProc);
    }
    else if (keyEvent) {
        FixKeyState(event, dev);
    }

    _XkbApplyState(dev, genStateNotify, event->type, key);
    XkbPushLockedStateToSlaves(dev, event->type, key);
}

int
XkbLatchModifiers(DeviceIntPtr pXDev, CARD8 mask, CARD8 latches)
{
    XkbSrvInfoPtr xkbi;
    XkbFilterPtr filter;
    XkbAction act;
    unsigned clear;

    if (pXDev && pXDev->key && pXDev->key->xkbInfo) {
        xkbi = pXDev->key->xkbInfo;
        clear = (mask & (~latches));
        xkbi->state.latched_mods &= ~clear;
        /* Clear any pending latch to locks.
         */
        act.type = XkbSA_NoAction;
        _XkbApplyFilters(xkbi, SYNTHETIC_KEYCODE, &act);
        act.type = XkbSA_LatchMods;
        act.mods.flags = 0;
        act.mods.mask = mask & latches;
        filter = _XkbNextFreeFilter(xkbi);
        _XkbFilterLatchState(xkbi, filter, SYNTHETIC_KEYCODE, &act);
        _XkbFilterLatchState(xkbi, filter, SYNTHETIC_KEYCODE,
                             (XkbAction *) NULL);
        return Success;
    }
    return BadValue;
}

int
XkbLatchGroup(DeviceIntPtr pXDev, int group)
{
    XkbSrvInfoPtr xkbi;
    XkbFilterPtr filter;
    XkbAction act;

    if (pXDev && pXDev->key && pXDev->key->xkbInfo) {
        xkbi = pXDev->key->xkbInfo;
        act.type = XkbSA_LatchGroup;
        act.group.flags = 0;
        XkbSASetGroup(&act.group, group);
        filter = _XkbNextFreeFilter(xkbi);
        _XkbFilterLatchState(xkbi, filter, SYNTHETIC_KEYCODE, &act);
        _XkbFilterLatchState(xkbi, filter, SYNTHETIC_KEYCODE,
                             (XkbAction *) NULL);
        return Success;
    }
    return BadValue;
}

/***====================================================================***/

void
XkbClearAllLatchesAndLocks(DeviceIntPtr dev,
                           XkbSrvInfoPtr xkbi,
                           Bool genEv, XkbEventCausePtr cause)
{
    XkbStateRec os;
    xkbStateNotify sn;

    sn.changed = 0;
    os = xkbi->state;
    if (os.latched_mods) {      /* clear all latches */
        XkbLatchModifiers(dev, ~0, 0);
        sn.changed |= XkbModifierLatchMask;
    }
    if (os.latched_group) {
        XkbLatchGroup(dev, 0);
        sn.changed |= XkbGroupLatchMask;
    }
    if (os.locked_mods) {
        xkbi->state.locked_mods = 0;
        sn.changed |= XkbModifierLockMask;
    }
    if (os.locked_group) {
        xkbi->state.locked_group = 0;
        sn.changed |= XkbGroupLockMask;
    }
    if (genEv && sn.changed) {
        CARD32 changed;

        XkbComputeDerivedState(xkbi);
        sn.keycode = cause->kc;
        sn.eventType = cause->event;
        sn.requestMajor = cause->mjr;
        sn.requestMinor = cause->mnr;
        sn.changed = XkbStateChangedFlags(&os, &xkbi->state);
        XkbSendStateNotify(dev, &sn);
        changed = XkbIndicatorsToUpdate(dev, sn.changed, FALSE);
        if (changed) {
            XkbUpdateIndicators(dev, changed, TRUE, NULL, cause);
        }
    }
    return;
}

/*
 * The event is injected into the event processing, not the EQ. Thus,
 * ensure that we restore the master after the event sequence to the
 * original set of classes. Otherwise, the master remains on the XTEST
 * classes and drops events that don't fit into the XTEST layout (e.g.
 * events with more than 2 valuators).
 *
 * FIXME: EQ injection in the processing stage is not designed for, so this
 * is a rather awkward hack. The event list returned by GetPointerEvents()
 * and friends is always prefixed with a DCE if the last _posted_ device was
 * different. For normal events, this sequence then resets the master during
 * the processing stage. Since we inject the PointerKey events in the
 * processing stage though, we need to manually reset to restore the
 * previous order, because the events already in the EQ must be sent for the
 * right device.
 * So we post-fix the event list we get from GPE with a DCE back to the
 * previous slave device.
 *
 * First one on drinking island wins!
 */
static void
InjectPointerKeyEvents(DeviceIntPtr dev, int type, int button, int flags,
                       ValuatorMask *mask)
{
    ScreenPtr pScreen;
    InternalEvent *events;
    int nevents, i;
    DeviceIntPtr ptr, mpointer, lastSlave = NULL;
    Bool saveWait;

    if (IsMaster(dev)) {
        mpointer = GetMaster(dev, MASTER_POINTER);
        lastSlave = mpointer->lastSlave;
        ptr = GetXTestDevice(mpointer);
    }
    else if (IsFloating(dev))
        ptr = dev;
    else
        return;

    events = InitEventList(GetMaximumEventsNum() + 1);
    OsBlockSignals();
    pScreen = miPointerGetScreen(ptr);
    saveWait = miPointerSetWaitForUpdate(pScreen, FALSE);
    nevents = GetPointerEvents(events, ptr, type, button, flags, mask);
    if (IsMaster(dev) && (lastSlave && lastSlave != ptr))
        UpdateFromMaster(&events[nevents], lastSlave, DEVCHANGE_POINTER_EVENT,
                         &nevents);
    miPointerSetWaitForUpdate(pScreen, saveWait);
    OsReleaseSignals();

    for (i = 0; i < nevents; i++)
        mieqProcessDeviceEvent(ptr, &events[i], NULL);

    FreeEventList(events, GetMaximumEventsNum());

}

static void
XkbFakePointerMotion(DeviceIntPtr dev, unsigned flags, int x, int y)
{
    ValuatorMask mask;
    int gpe_flags = 0;

    /* ignore attached SDs */
    if (!IsMaster(dev) && !IsFloating(dev))
        return;

    if (flags & XkbSA_MoveAbsoluteX || flags & XkbSA_MoveAbsoluteY)
        gpe_flags = POINTER_ABSOLUTE;
    else
        gpe_flags = POINTER_RELATIVE;

    valuator_mask_set_range(&mask, 0, 2, (int[]) {
                            x, y});

    InjectPointerKeyEvents(dev, MotionNotify, 0, gpe_flags, &mask);
}

void
XkbFakeDeviceButton(DeviceIntPtr dev, Bool press, int button)
{
    DeviceIntPtr ptr;
    int down;

    /* If dev is a slave device, and the SD is attached, do nothing. If we'd
     * post through the attached master pointer we'd get duplicate events.
     *
     * if dev is a master keyboard, post through the XTEST device
     *
     * if dev is a floating slave, post through the device itself.
     */

    if (IsMaster(dev)) {
        DeviceIntPtr mpointer = GetMaster(dev, MASTER_POINTER);

        ptr = GetXTestDevice(mpointer);
    }
    else if (IsFloating(dev))
        ptr = dev;
    else
        return;

    down = button_is_down(ptr, button, BUTTON_PROCESSED);
    if (press == down)
        return;

    InjectPointerKeyEvents(dev, press ? ButtonPress : ButtonRelease,
                           button, 0, NULL);
}
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d184 1
d358 3
d642 1
d668 1
d670 1
a670 1
    return 0;
d687 1
d1113 2
a1114 2
    xkbi->filters = realloc(xkbi->filters,
                            xkbi->szFilters * sizeof(XkbFilterRec));
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d9 2
a10 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d12 1
a12 1
Silicon Graphics makes no representation about the suitability 
d16 2
a17 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d19 3
a21 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d54 1
a54 1
xkbUnwrapProc(DeviceIntPtr device, DeviceHandleProc proc, pointer data)
d473 1
a473 1
_XkbPtrAccelExpire(OsTimerPtr timer, CARD32 now, pointer arg)
d543 1
a543 1
                                       _XkbPtrAccelExpire, (pointer) xkbi);
d1130 65
d1201 1
a1201 1
    int changed, sendEvent;
d1214 2
a1215 9
    /* The state may change, so if we're not in the middle of sending a state
     * notify, prepare for it */
    if ((xkbi->flags & _XkbStateNotifyInProgress) == 0) {
        xkbi->prev_state = xkbi->state;
        xkbi->flags |= _XkbStateNotifyInProgress;
        genStateNotify = TRUE;
    }
    else
        genStateNotify = FALSE;
d1348 2
a1349 22
    XkbComputeDerivedState(xkbi);
    changed = XkbStateChangedFlags(&xkbi->prev_state, &xkbi->state);
    if (genStateNotify) {
        if (changed) {
            xkbStateNotify sn;

            sn.keycode = key;
            sn.eventType = event->type;
            sn.requestMajor = sn.requestMinor = 0;
            sn.changed = changed;
            XkbSendStateNotify(dev, &sn);
        }
        xkbi->flags &= ~_XkbStateNotifyInProgress;
    }
    changed = XkbIndicatorsToUpdate(dev, changed, FALSE);
    if (changed) {
        XkbEventCauseRec cause;

        XkbSetCauseKey(&cause, key, event->type);
        XkbUpdateIndicators(dev, changed, FALSE, NULL, &cause);
    }
    return;
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a224 1
#define	NO_LATCH	3
d232 1
d253 4
a256 34
            if (filter->upAction.type == XkbSA_LatchMods)
                xkbi->state.latched_mods &= ~filter->upAction.mods.mask;
            else
                xkbi->state.latched_group -=
                    XkbSAGroup(&filter->upAction.group);
        }
        else if ((pAction->type == filter->upAction.type) &&
                 (pAction->mods.flags == filter->upAction.mods.flags) &&
                 (pAction->mods.mask == filter->upAction.mods.mask)) {
            if (filter->upAction.mods.flags & XkbSA_LatchToLock) {
                XkbControlsPtr ctrls = xkbi->desc->ctrls;

                if (filter->upAction.type == XkbSA_LatchMods)
                    pAction->mods.type = XkbSA_LockMods;
                else
                    pAction->group.type = XkbSA_LockGroup;
                if (XkbAX_NeedFeedback(ctrls, XkbAX_StickyKeysFBMask) &&
                    (ctrls->enabled_ctrls & XkbStickyKeysMask)) {
                    XkbDDXAccessXBeep(xkbi->device, _BEEP_STICKY_LOCK,
                                      XkbStickyKeysMask);
                }
            }
            else {
                if (filter->upAction.type == XkbSA_LatchMods)
                    pAction->mods.type = XkbSA_SetMods;
                else
                    pAction->group.type = XkbSA_SetGroup;
            }
            if (filter->upAction.type == XkbSA_LatchMods)
                xkbi->state.latched_mods &= ~filter->upAction.mods.mask;
            else
                xkbi->state.latched_group -=
                    XkbSAGroup(&filter->upAction.group);
            filter->active = 0;
d259 4
a262 1
    else if (filter->keycode == keycode) {      /* release */
d264 2
a265 2
        int needBeep;
        int beepType = _BEEP_NONE;
a266 2
        needBeep = ((ctrls->enabled_ctrls & XkbStickyKeysMask) &&
                    XkbAX_NeedFeedback(ctrls, XkbAX_StickyKeysFBMask));
d268 37
a304 7
            xkbi->clearMods = filter->upAction.mods.mask;
            if ((filter->upAction.mods.flags & XkbSA_ClearLocks) &&
                (xkbi->clearMods & xkbi->state.locked_mods) ==
                xkbi->clearMods) {
                xkbi->state.locked_mods &= ~xkbi->clearMods;
                filter->priv = NO_LATCH;
                beepType = _BEEP_STICKY_UNLOCK;
d309 1
d313 20
a332 2
                filter->priv = NO_LATCH;
                beepType = _BEEP_STICKY_UNLOCK;
d335 2
a336 1
        if (filter->priv == NO_LATCH) {
a337 17
        }
        else {
            filter->priv = LATCH_PENDING;
            if (filter->upAction.type == XkbSA_LatchMods) {
                xkbi->state.latched_mods |= filter->upAction.mods.mask;
                needBeep = xkbi->state.latched_mods ? needBeep : 0;
                xkbi->state.latched_mods |= filter->upAction.mods.mask;
            }
            else {
                xkbi->state.latched_group +=
                    XkbSAGroup(&filter->upAction.group);
            }
            if (needBeep && (beepType == _BEEP_NONE))
                beepType = _BEEP_STICKY_LATCH;
        }
        if (needBeep && (beepType != _BEEP_NONE))
            XkbDDXAccessXBeep(xkbi->device, beepType, XkbStickyKeysMask);
d339 10
a348 3
    else if (filter->priv == LATCH_KEY_DOWN) {
        filter->priv = NO_LATCH;
        filter->filterOthers = 0;
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a49 1
void XkbFakeDeviceButton(DeviceIntPtr dev, Bool press, int button);
d750 9
d786 20
a805 10
        if (pMsg->flags & XkbSA_MessageOnRelease) {
            xkbActionMessage msg;

            msg.keycode = keycode;
            msg.press = 0;
            msg.keyEventFollows =
                ((pMsg->flags & XkbSA_MessageGenKeyEvent) != 0);
            memcpy((char *) msg.message, (char *) pMsg->message,
                   XkbActionMessageLength);
            XkbSendActionMessage(kbd, &msg);
a806 3
        filter->keycode = 0;
        filter->active = 0;
        return ((pMsg->flags & XkbSA_MessageGenKeyEvent) != 0);
d822 9
a836 3
    if ((filter->keycode != 0) && (filter->keycode != keycode))
        return 1;

d895 1
d897 51
a947 40
    else if (filter->keycode == keycode) {

        ev.type = ET_KeyRelease;
        ev.detail.key = filter->upAction.redirect.new_key;

        mask = XkbSARedirectVModsMask(&filter->upAction.redirect);
        mods = XkbSARedirectVMods(&filter->upAction.redirect);
        if (mask)
            XkbVirtualModsToReal(xkbi->desc, mask, &mask);
        if (mods)
            XkbVirtualModsToReal(xkbi->desc, mods, &mods);
        mask |= filter->upAction.redirect.mods_mask;
        mods |= filter->upAction.redirect.mods;

        if (mask || mods) {
            old = xkbi->state;
            old_prev = xkbi->prev_state;
            xkbi->state.base_mods &= ~mask;
            xkbi->state.base_mods |= (mods & mask);
            xkbi->state.latched_mods &= ~mask;
            xkbi->state.latched_mods |= (mods & mask);
            xkbi->state.locked_mods &= ~mask;
            xkbi->state.locked_mods |= (mods & mask);
            XkbComputeDerivedState(xkbi);
            xkbi->prev_state = xkbi->state;
        }

        UNWRAP_PROCESS_INPUT_PROC(xkbi->device, xkbPrivPtr, backupproc);
        xkbi->device->public.processInputProc((InternalEvent *) &ev,
                                              xkbi->device);
        COND_WRAP_PROCESS_INPUT_PROC(xkbi->device, xkbPrivPtr, backupproc,
                                     xkbUnwrapProc);

        if (mask || mods) {
            xkbi->state = old;
            xkbi->prev_state = old_prev;
        }

        filter->keycode = 0;
        filter->active = 0;
a948 1
    return 0;
@


1.7
log
@Update to xserver 1.11.2
@
text
@d50 3
a52 2
void XkbFakeDeviceButton(DeviceIntPtr dev,Bool press,int button);
static void XkbFakePointerMotion(DeviceIntPtr dev, unsigned flags,int x,int y);
d55 1
a55 2
xkbUnwrapProc(DeviceIntPtr device, DeviceHandleProc proc,
                   pointer data)
a58 2
    if(xkbPrivPtr->unwrapProc)
	xkbPrivPtr->unwrapProc = NULL;
d60 6
a65 4
    UNWRAP_PROCESS_INPUT_PROC(device,xkbPrivPtr, backupproc);
    proc(device,data);
    COND_WRAP_PROCESS_INPUT_PROC(device,xkbPrivPtr,
				 backupproc,xkbUnwrapProc);
d71 2
a72 1
    return dixRegisterPrivateKey(&xkbDevicePrivateKeyRec, PRIVATE_DEVICE, sizeof(xkbDeviceInfoRec));
d79 1
d86 1
a86 1
_FixUpAction(XkbDescPtr xkb,XkbAction *act)
d88 1
a88 1
static XkbAction	fake;
d90 24
a113 21
    if (XkbIsPtrAction(act)&&(!(xkb->ctrls->enabled_ctrls&XkbMouseKeysMask))) {
	fake.type = XkbSA_NoAction;
	return fake;
    }
    if (xkb->ctrls->enabled_ctrls&XkbStickyKeysMask) {
	if (act->any.type==XkbSA_SetMods) {
	    fake.mods.type = XkbSA_LatchMods;
	    fake.mods.mask = act->mods.mask;
	    if (XkbAX_NeedOption(xkb->ctrls,XkbAX_LatchToLockMask))
		 fake.mods.flags= XkbSA_ClearLocks|XkbSA_LatchToLock;
	    else fake.mods.flags= XkbSA_ClearLocks;
	    return fake;
	}
	if (act->any.type==XkbSA_SetGroup) {
	    fake.group.type = XkbSA_LatchGroup;
	    if (XkbAX_NeedOption(xkb->ctrls,XkbAX_LatchToLockMask))
		 fake.group.flags= XkbSA_ClearLocks|XkbSA_LatchToLock;
	    else fake.group.flags= XkbSA_ClearLocks;
	    XkbSASetGroup(&fake.group,XkbSAGroup(&act->group));
	    return fake;
	}
d119 1
a119 1
XkbGetKeyAction(XkbSrvInfoPtr xkbi,XkbStatePtr xkbState,CARD8 key)
d121 11
a131 11
int			effectiveGroup;
int			col;
XkbDescPtr		xkb;
XkbKeyTypePtr		type;
XkbAction *		pActs;
static XkbAction 	fake;

    xkb= xkbi->desc;
    if (!XkbKeyHasActions(xkb,key) || !XkbKeycodeInRange(xkb,key)) {
	fake.type = XkbSA_NoAction;
	return fake;
d133 2
a134 2
    pActs= XkbKeyActionsPtr(xkb,key);
    col= 0;
d140 16
a155 15
    type= XkbKeyKeyType(xkb,key,effectiveGroup);
    if (type->map!=NULL) {
	register unsigned		i,mods;
	register XkbKTMapEntryPtr	entry;
	mods= xkbState->mods&type->mods.mask;
	for (entry= type->map,i=0;i<type->map_count;i++,entry++) {
	    if ((entry->active)&&(entry->mods.mask==mods)) {
		col+= entry->level;
		break;
	    }
	}
    }
    if (pActs[col].any.type==XkbSA_NoAction)
	return pActs[col];
    fake= _FixUpAction(xkb,&pActs[col]);
d160 1
a160 1
XkbGetButtonAction(DeviceIntPtr kbd,DeviceIntPtr dev,int button)
d162 11
a172 10
XkbAction fake;
   if ((dev->button)&&(dev->button->xkb_acts)) {
	if (dev->button->xkb_acts[button-1].any.type!=XkbSA_NoAction) {
	    fake= _FixUpAction(kbd->key->xkbInfo->desc,
					&dev->button->xkb_acts[button-1]);
	    return fake;
	}
   }
   fake.any.type= XkbSA_NoAction;
   return fake;
d181 35
a215 37
_XkbFilterSetState(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *pAction)
{
    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = ((pAction->mods.mask&XkbSA_ClearLocks)!=0);
	filter->priv = 0;
	filter->filter = _XkbFilterSetState;
	if (pAction->type==XkbSA_SetMods) {
	    filter->upAction = *pAction;
	    xkbi->setMods= pAction->mods.mask;
	}
	else {
	    xkbi->groupChange = XkbSAGroup(&pAction->group);
	    if (pAction->group.flags&XkbSA_GroupAbsolute)
		xkbi->groupChange-= xkbi->state.base_group;
	    filter->upAction= *pAction;
	    XkbSASetGroup(&filter->upAction.group,xkbi->groupChange);
	}
    }
    else if (filter->keycode==keycode) {
	if (filter->upAction.type==XkbSA_SetMods) {
	    xkbi->clearMods = filter->upAction.mods.mask;
	    if (filter->upAction.mods.flags&XkbSA_ClearLocks) {
		xkbi->state.locked_mods&= ~filter->upAction.mods.mask;
	    }
	}
	else {
	    if (filter->upAction.group.flags&XkbSA_ClearLocks) {
		xkbi->state.locked_group = 0;
	    }
	    xkbi->groupChange = -XkbSAGroup(&filter->upAction.group);
	}
	filter->active = 0;
d218 2
a219 2
	filter->upAction.mods.flags&= ~XkbSA_ClearLocks;
	filter->filterOthers = 0;
d229 110
a338 103
_XkbFilterLatchState(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{

    if (filter->keycode==0) {			/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 1;
	filter->priv = LATCH_KEY_DOWN;
	filter->filter = _XkbFilterLatchState;
	if (pAction->type==XkbSA_LatchMods) {
	    filter->upAction = *pAction;
	    xkbi->setMods = pAction->mods.mask;
	}
	else {
	    xkbi->groupChange = XkbSAGroup(&pAction->group);
	    if (pAction->group.flags&XkbSA_GroupAbsolute)
		 xkbi->groupChange-= xkbi->state.base_group;
	    filter->upAction= *pAction;
	    XkbSASetGroup(&filter->upAction.group,xkbi->groupChange);
	}
    }
    else if ( pAction && (filter->priv==LATCH_PENDING) ) {
	if (((1<<pAction->type)&XkbSA_BreakLatch)!=0) {
	    filter->active = 0;
	    if (filter->upAction.type==XkbSA_LatchMods)
		 xkbi->state.latched_mods&= ~filter->upAction.mods.mask;
	    else xkbi->state.latched_group-=XkbSAGroup(&filter->upAction.group);
	}
	else if ((pAction->type==filter->upAction.type)&&
		 (pAction->mods.flags==filter->upAction.mods.flags)&&
		 (pAction->mods.mask==filter->upAction.mods.mask)) {
	    if (filter->upAction.mods.flags&XkbSA_LatchToLock) {
		XkbControlsPtr ctrls= xkbi->desc->ctrls;
		if (filter->upAction.type==XkbSA_LatchMods)
		     pAction->mods.type= XkbSA_LockMods;
		else pAction->group.type= XkbSA_LockGroup;
		if (XkbAX_NeedFeedback(ctrls,XkbAX_StickyKeysFBMask)&&
		    		(ctrls->enabled_ctrls&XkbStickyKeysMask)) {
		    XkbDDXAccessXBeep(xkbi->device,_BEEP_STICKY_LOCK,
						XkbStickyKeysMask);
		}
	    }
	    else {
		if (filter->upAction.type==XkbSA_LatchMods)
		     pAction->mods.type= XkbSA_SetMods;
		else pAction->group.type= XkbSA_SetGroup;
	    }
	    if (filter->upAction.type==XkbSA_LatchMods)
		 xkbi->state.latched_mods&= ~filter->upAction.mods.mask;
	    else xkbi->state.latched_group-=XkbSAGroup(&filter->upAction.group);
	    filter->active = 0;
	}
    }
    else if (filter->keycode==keycode) {	/* release */
	XkbControlsPtr	ctrls= xkbi->desc->ctrls;
	int		needBeep;
	int		beepType= _BEEP_NONE;

	needBeep= ((ctrls->enabled_ctrls&XkbStickyKeysMask)&&
			XkbAX_NeedFeedback(ctrls,XkbAX_StickyKeysFBMask));
	if (filter->upAction.type==XkbSA_LatchMods) {
	    xkbi->clearMods = filter->upAction.mods.mask;
	    if ((filter->upAction.mods.flags&XkbSA_ClearLocks)&&
		 (xkbi->clearMods&xkbi->state.locked_mods)==xkbi->clearMods) {
		xkbi->state.locked_mods&= ~xkbi->clearMods;
		filter->priv= NO_LATCH;
		beepType= _BEEP_STICKY_UNLOCK;
	    }
	}
	else {
	    xkbi->groupChange = -XkbSAGroup(&filter->upAction.group);
	    if ((filter->upAction.group.flags&XkbSA_ClearLocks)&&
						(xkbi->state.locked_group)) {
		xkbi->state.locked_group = 0;
		filter->priv = NO_LATCH;
		beepType= _BEEP_STICKY_UNLOCK;
	    }
	}
	if (filter->priv==NO_LATCH) {
	    filter->active= 0;
	}
	else {
	    filter->priv= LATCH_PENDING;
	    if (filter->upAction.type==XkbSA_LatchMods) {
		xkbi->state.latched_mods |= filter->upAction.mods.mask;
		needBeep = xkbi->state.latched_mods ? needBeep : 0;
		xkbi->state.latched_mods |= filter->upAction.mods.mask;
	    }
	    else {
		xkbi->state.latched_group+= XkbSAGroup(&filter->upAction.group);
	    }
	    if (needBeep && (beepType==_BEEP_NONE))
		beepType= _BEEP_STICKY_LATCH;
	}
	if (needBeep && (beepType!=_BEEP_NONE))
	    XkbDDXAccessXBeep(xkbi->device,beepType,XkbStickyKeysMask);
    }
    else if (filter->priv==LATCH_KEY_DOWN) {
	filter->priv= NO_LATCH;
	filter->filterOthers = 0;
d344 26
a369 24
_XkbFilterLockState(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
    if (pAction&&(pAction->type==XkbSA_LockGroup)) {
	if (pAction->group.flags&XkbSA_GroupAbsolute)
	     xkbi->state.locked_group= XkbSAGroup(&pAction->group);
	else xkbi->state.locked_group+= XkbSAGroup(&pAction->group);
	return 1;
    }
    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->priv = 0;
	filter->filter = _XkbFilterLockState;
	filter->upAction = *pAction;
	xkbi->state.locked_mods^= pAction->mods.mask;
	xkbi->setMods = pAction->mods.mask;
    }
    else if (filter->keycode==keycode) {
	filter->active = 0;
	xkbi->clearMods = filter->upAction.mods.mask;
d378 26
a403 28
_XkbFilterISOLock(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{

    if (filter->keycode==0) {		/* initial press */
	CARD8	flags= pAction->iso.flags;

	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 1;
	filter->priv = ISO_KEY_DOWN;
	filter->upAction = *pAction;
	filter->filter = _XkbFilterISOLock;
	if (flags&XkbSA_ISODfltIsGroup) {
	    xkbi->groupChange = XkbSAGroup(&pAction->iso);
	    xkbi->setMods = 0;
	}
	else {
	    xkbi->setMods = pAction->iso.mask;
	    xkbi->groupChange = 0;
	}
	if ((!(flags&XkbSA_ISONoAffectMods))&&(xkbi->state.base_mods)) {
	    filter->priv= NO_ISO_LOCK;
	    xkbi->state.locked_mods^= xkbi->state.base_mods;
	}
	if ((!(flags&XkbSA_ISONoAffectGroup))&&(xkbi->state.base_group)) {
d405 2
a406 2
	}
	if (!(flags&XkbSA_ISONoAffectPtr)) {
d408 1
a408 1
	}
d410 2
a411 2
    else if (filter->keycode==keycode) {
	CARD8	flags= filter->upAction.iso.flags;
d413 13
a425 13
	if (flags&XkbSA_ISODfltIsGroup) {
	    xkbi->groupChange = -XkbSAGroup(&filter->upAction.iso);
	    xkbi->clearMods = 0;
	    if (filter->priv==ISO_KEY_DOWN)
		xkbi->state.locked_group+= XkbSAGroup(&filter->upAction.iso);
	}
	else {
	    xkbi->clearMods= filter->upAction.iso.mask;
	    xkbi->groupChange= 0;
	    if (filter->priv==ISO_KEY_DOWN)
		xkbi->state.locked_mods^= filter->upAction.iso.mask;
	}
	filter->active = 0;
d428 1
a428 1
	CARD8	flags= filter->upAction.iso.flags;
d430 28
a457 26
	switch (pAction->type) {
	    case XkbSA_SetMods: case XkbSA_LatchMods:
		if (!(flags&XkbSA_ISONoAffectMods)) {
		    pAction->type= XkbSA_LockMods;
		    filter->priv= NO_ISO_LOCK;
		}
		break;
	    case XkbSA_SetGroup: case XkbSA_LatchGroup:
		if (!(flags&XkbSA_ISONoAffectGroup)) {
		    pAction->type= XkbSA_LockGroup;
		    filter->priv= NO_ISO_LOCK;
		}
		break;
	    case XkbSA_PtrBtn:
		if (!(flags&XkbSA_ISONoAffectPtr)) {
		     pAction->type= XkbSA_LockPtrBtn;
		     filter->priv= NO_ISO_LOCK;
		}
		break;
	    case XkbSA_SetControls:
		if (!(flags&XkbSA_ISONoAffectCtrls)) {
		    pAction->type= XkbSA_LockControls;
		    filter->priv= NO_ISO_LOCK;
		}
		break;
	}
a461 1

d463 1
a463 1
_XkbPtrAccelExpire(OsTimerPtr timer,CARD32 now,pointer arg)
d465 3
a467 3
XkbSrvInfoPtr	xkbi= (XkbSrvInfoPtr)arg;
XkbControlsPtr	ctrls= xkbi->desc->ctrls;
int		dx,dy;
d469 2
a470 2
    if (xkbi->mouseKey==0)
	return 0;
d473 23
a495 20
	if ((xkbi->mouseKeysCounter)<ctrls->mk_time_to_max) {
	    double step;
	    xkbi->mouseKeysCounter++;
	    step= xkbi->mouseKeysCurveFactor*
		 pow((double)xkbi->mouseKeysCounter,xkbi->mouseKeysCurve);
	    if (xkbi->mouseKeysDX<0)
		 dx= floor( ((double)xkbi->mouseKeysDX)*step );
	    else dx=  ceil( ((double)xkbi->mouseKeysDX)*step );
	    if (xkbi->mouseKeysDY<0)
		 dy= floor( ((double)xkbi->mouseKeysDY)*step );
	    else dy=  ceil( ((double)xkbi->mouseKeysDY)*step );
	}
	else {
	    dx= xkbi->mouseKeysDX*ctrls->mk_max_speed;
	    dy= xkbi->mouseKeysDY*ctrls->mk_max_speed;
	}
	if (xkbi->mouseKeysFlags&XkbSA_MoveAbsoluteX)
	    dx= xkbi->mouseKeysDX;
	if (xkbi->mouseKeysFlags&XkbSA_MoveAbsoluteY)
	    dy= xkbi->mouseKeysDY;
d498 2
a499 2
	dx= xkbi->mouseKeysDX;
	dy= xkbi->mouseKeysDY;
d501 1
a501 1
    XkbFakePointerMotion(xkbi->device, xkbi->mouseKeysFlags,dx,dy);
d506 36
a541 38
_XkbFilterPointerMove(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
int	x,y;
Bool	accel;

    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->priv=0;
	filter->filter = _XkbFilterPointerMove;
	filter->upAction= *pAction;
	xkbi->mouseKeysCounter= 0;
	xkbi->mouseKey= keycode;
	accel= ((pAction->ptr.flags&XkbSA_NoAcceleration)==0);
	x= XkbPtrActionX(&pAction->ptr);
	y= XkbPtrActionY(&pAction->ptr);
	XkbFakePointerMotion(xkbi->device, pAction->ptr.flags,x,y);
	AccessXCancelRepeatKey(xkbi,keycode);
	xkbi->mouseKeysAccel= accel&&
		(xkbi->desc->ctrls->enabled_ctrls&XkbMouseKeysAccelMask);
	xkbi->mouseKeysFlags= pAction->ptr.flags;
	xkbi->mouseKeysDX= XkbPtrActionX(&pAction->ptr);
	xkbi->mouseKeysDY= XkbPtrActionY(&pAction->ptr);
	xkbi->mouseKeyTimer= TimerSet(xkbi->mouseKeyTimer, 0,
				xkbi->desc->ctrls->mk_delay,
				_XkbPtrAccelExpire,(pointer)xkbi);
    }
    else if (filter->keycode==keycode) {
	filter->active = 0;
	if (xkbi->mouseKey==keycode) {
	    xkbi->mouseKey= 0;
	    xkbi->mouseKeyTimer= TimerSet(xkbi->mouseKeyTimer, 0, 0,
							NULL, NULL);
	}
d547 106
a652 110
_XkbFilterPointerBtn(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
    if (filter->keycode==0) {		/* initial press */
	int	button= pAction->btn.button;

	if (button==XkbSA_UseDfltButton)
	    button = xkbi->desc->ctrls->mk_dflt_btn;

	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->priv=0;
	filter->filter = _XkbFilterPointerBtn;
	filter->upAction= *pAction;
	filter->upAction.btn.button= button;
	switch (pAction->type) {
	    case XkbSA_LockPtrBtn:
		if (((xkbi->lockedPtrButtons&(1<<button))==0)&&
			((pAction->btn.flags&XkbSA_LockNoLock)==0)) {
		    xkbi->lockedPtrButtons|= (1<<button);
		    AccessXCancelRepeatKey(xkbi,keycode);
		    XkbFakeDeviceButton(xkbi->device, 1, button);
		    filter->upAction.type= XkbSA_NoAction;
		}
		break;
	    case XkbSA_PtrBtn:
		{
		    register int i,nClicks;
		    AccessXCancelRepeatKey(xkbi,keycode);
		    if (pAction->btn.count>0) {
			nClicks= pAction->btn.count;
			for (i=0;i<nClicks;i++) {
			    XkbFakeDeviceButton(xkbi->device, 1, button);
			    XkbFakeDeviceButton(xkbi->device, 0, button);
			}
			filter->upAction.type= XkbSA_NoAction;
		    }
		    else XkbFakeDeviceButton(xkbi->device, 1, button);
		}
		break;
	    case XkbSA_SetPtrDflt:
		{
		    XkbControlsPtr	ctrls= xkbi->desc->ctrls;
		    XkbControlsRec	old;
		    xkbControlsNotify	cn;

		    old= *ctrls;
		    AccessXCancelRepeatKey(xkbi,keycode);
		    switch (pAction->dflt.affect) {
			case XkbSA_AffectDfltBtn:
			    if (pAction->dflt.flags&XkbSA_DfltBtnAbsolute)
				ctrls->mk_dflt_btn= 
					XkbSAPtrDfltValue(&pAction->dflt);
			    else {
				ctrls->mk_dflt_btn+=
					XkbSAPtrDfltValue(&pAction->dflt);
				if (ctrls->mk_dflt_btn>5)
				    ctrls->mk_dflt_btn= 5;
				else if (ctrls->mk_dflt_btn<1)
				    ctrls->mk_dflt_btn= 1;
			    }
			    break;
			default:
			    ErrorF(
		"Attempt to change unknown pointer default (%d) ignored\n",
							pAction->dflt.affect);
			    break;
		    }
		    if (XkbComputeControlsNotify(xkbi->device,
						&old,xkbi->desc->ctrls,
						&cn,FALSE)) {
			cn.keycode = keycode;
                        /* XXX: what about DeviceKeyPress? */
			cn.eventType = KeyPress;
			cn.requestMajor = 0;
			cn.requestMinor = 0;
			XkbSendControlsNotify(xkbi->device,&cn);
		    }
		}
		break;
	}
    }
    else if (filter->keycode==keycode) {
	int	button= filter->upAction.btn.button;

	switch (filter->upAction.type) {
	    case XkbSA_LockPtrBtn:
		if (((filter->upAction.btn.flags&XkbSA_LockNoUnlock)!=0)||
				((xkbi->lockedPtrButtons&(1<<button))==0)) {
		    break;
		}
		xkbi->lockedPtrButtons&= ~(1<<button);

		if (IsMaster(xkbi->device))
		{
		    XkbMergeLockedPtrBtns(xkbi->device);
                    /* One SD still has lock set, don't post event */
		    if ((xkbi->lockedPtrButtons & (1 << button)) != 0)
			break;
		}

		/* fallthrough */
	    case XkbSA_PtrBtn:
		XkbFakeDeviceButton(xkbi->device, 0, button);
		break;
	}
	filter->active = 0;
d658 33
a690 35
_XkbFilterControls(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
XkbControlsRec		old;
XkbControlsPtr		ctrls;
DeviceIntPtr		kbd;
unsigned int		change;
XkbEventCauseRec	cause;

    kbd= xkbi->device;
    ctrls= xkbi->desc->ctrls;
    old= *ctrls;
    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	change= XkbActionCtrls(&pAction->ctrls);
	filter->priv = change;
	filter->filter = _XkbFilterControls;
	filter->upAction = *pAction;

	if (pAction->type==XkbSA_LockControls) {
	    filter->priv= (ctrls->enabled_ctrls&change);
	    change&= ~ctrls->enabled_ctrls;
	}

	if (change) {
	    xkbControlsNotify	cn;
	    XkbSrvLedInfoPtr	sli;

	    ctrls->enabled_ctrls|= change;
	    if (XkbComputeControlsNotify(kbd,&old,ctrls,&cn,FALSE)) {
		cn.keycode = keycode;
d692 47
a738 47
		cn.eventType = KeyPress;
		cn.requestMajor = 0;
		cn.requestMinor = 0;
		XkbSendControlsNotify(kbd,&cn);
	    }

	    XkbSetCauseKey(&cause,keycode,KeyPress);

	    /* If sticky keys were disabled, clear all locks and latches */
	    if ((old.enabled_ctrls&XkbStickyKeysMask)&&
		(!(ctrls->enabled_ctrls&XkbStickyKeysMask))) {
		XkbClearAllLatchesAndLocks(kbd,xkbi,FALSE,&cause);
    	    }
	    sli= XkbFindSrvLedInfo(kbd,XkbDfltXIClass,XkbDfltXIId,0);
	    XkbUpdateIndicators(kbd,sli->usesControls,TRUE,NULL,&cause);
	    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask))
		XkbDDXAccessXBeep(kbd,_BEEP_FEATURE_ON,change);
	}
    }
    else if (filter->keycode==keycode) {
	change= filter->priv;
	if (change) {
	    xkbControlsNotify 	cn;
	    XkbSrvLedInfoPtr	sli;

	    ctrls->enabled_ctrls&= ~change;
	    if (XkbComputeControlsNotify(kbd,&old,ctrls,&cn,FALSE)) {
		cn.keycode = keycode;
		cn.eventType = KeyRelease;
		cn.requestMajor = 0;
		cn.requestMinor = 0;
		XkbSendControlsNotify(kbd,&cn);
	    }

	    XkbSetCauseKey(&cause,keycode,KeyRelease);
	    /* If sticky keys were disabled, clear all locks and latches */
	    if ((old.enabled_ctrls&XkbStickyKeysMask)&&
		(!(ctrls->enabled_ctrls&XkbStickyKeysMask))) {
		XkbClearAllLatchesAndLocks(kbd,xkbi,FALSE,&cause);
    	    }
	    sli= XkbFindSrvLedInfo(kbd,XkbDfltXIClass,XkbDfltXIId,0);
	    XkbUpdateIndicators(kbd,sli->usesControls,TRUE,NULL,&cause);
	    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask))
		XkbDDXAccessXBeep(kbd,_BEEP_FEATURE_OFF,change);
	}
	filter->keycode= 0;
	filter->active= 0;
d744 48
a791 47
_XkbFilterActionMessage(XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
XkbMessageAction *	pMsg;
DeviceIntPtr		kbd;

    kbd= xkbi->device;
    if (filter->keycode==0) {		/* initial press */
	pMsg= &pAction->msg;
	if ((pMsg->flags&XkbSA_MessageOnRelease)||
	    ((pMsg->flags&XkbSA_MessageGenKeyEvent)==0)) {
	    filter->keycode = keycode;
	    filter->active = 1;
	    filter->filterOthers = 0;
	    filter->priv = 0;
	    filter->filter = _XkbFilterActionMessage;
	    filter->upAction = *pAction;
	}
	if (pMsg->flags&XkbSA_MessageOnPress)  {
	    xkbActionMessage	msg;

	    msg.keycode= keycode;
	    msg.press= 1;
	    msg.keyEventFollows=((pMsg->flags&XkbSA_MessageGenKeyEvent)!=0);
	    memcpy((char *)msg.message,
				(char *)pMsg->message,XkbActionMessageLength);
	    XkbSendActionMessage(kbd,&msg);
	}
	return ((pAction->msg.flags&XkbSA_MessageGenKeyEvent)!=0);
    }
    else if (filter->keycode==keycode) {
	pMsg= &filter->upAction.msg;
	if (pMsg->flags&XkbSA_MessageOnRelease) {
	    xkbActionMessage	msg;

	    msg.keycode= keycode;
	    msg.press= 0;
	    msg.keyEventFollows=((pMsg->flags&XkbSA_MessageGenKeyEvent)!=0);
	    memcpy((char *)msg.message,(char *)pMsg->message,
						XkbActionMessageLength);
	    XkbSendActionMessage(kbd,&msg);
	}
	filter->keycode= 0;
	filter->active= 0;
	return ((pMsg->flags&XkbSA_MessageGenKeyEvent)!=0);
d793 1
a793 1
    return 0;
d797 9
a805 11
_XkbFilterRedirectKey(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
{
DeviceEvent	ev;
int		x,y;
XkbStateRec	old;
unsigned	mods,mask;
xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(xkbi->device);
ProcessInputProc backupproc;
d810 1
d813 2
a814 2
    if ((filter->keycode!=0)&&(filter->keycode!=keycode))
	return 1;
d816 1
a816 1
    GetSpritePosition(xkbi->device, &x,&y);
d822 16
a837 12

    if (filter->keycode==0) {		/* initial press */
	if ((pAction->redirect.new_key<xkbi->desc->min_key_code)||
	    (pAction->redirect.new_key>xkbi->desc->max_key_code)) {
	    return 1;
	}
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->priv = 0;
	filter->filter = _XkbFilterRedirectKey;
	filter->upAction = *pAction;
d842 32
a873 25
        mask= XkbSARedirectVModsMask(&pAction->redirect);
        mods= XkbSARedirectVMods(&pAction->redirect);
        if (mask) XkbVirtualModsToReal(xkbi->desc,mask,&mask);
        if (mods) XkbVirtualModsToReal(xkbi->desc,mods,&mods);
        mask|= pAction->redirect.mods_mask;
        mods|= pAction->redirect.mods;

	if ( mask || mods ) {
	    old= xkbi->state;
	    xkbi->state.base_mods&= ~mask;
	    xkbi->state.base_mods|= (mods&mask);
	    xkbi->state.latched_mods&= ~mask;
	    xkbi->state.latched_mods|= (mods&mask);
	    xkbi->state.locked_mods&= ~mask;
	    xkbi->state.locked_mods|= (mods&mask);
	    XkbComputeDerivedState(xkbi);
	}

	UNWRAP_PROCESS_INPUT_PROC(xkbi->device,xkbPrivPtr, backupproc);
	xkbi->device->public.processInputProc((InternalEvent*)&ev, xkbi->device);
	COND_WRAP_PROCESS_INPUT_PROC(xkbi->device, xkbPrivPtr,
				     backupproc,xkbUnwrapProc);
	
	if ( mask || mods )
	    xkbi->state= old;
d875 1
a875 1
    else if (filter->keycode==keycode) {
d880 32
a911 22
        mask= XkbSARedirectVModsMask(&filter->upAction.redirect);
        mods= XkbSARedirectVMods(&filter->upAction.redirect);
        if (mask) XkbVirtualModsToReal(xkbi->desc,mask,&mask);
        if (mods) XkbVirtualModsToReal(xkbi->desc,mods,&mods);
        mask|= filter->upAction.redirect.mods_mask;
        mods|= filter->upAction.redirect.mods;

	if ( mask || mods ) {
	    old= xkbi->state;
	    xkbi->state.base_mods&= ~mask;
	    xkbi->state.base_mods|= (mods&mask);
	    xkbi->state.latched_mods&= ~mask;
	    xkbi->state.latched_mods|= (mods&mask);
	    xkbi->state.locked_mods&= ~mask;
	    xkbi->state.locked_mods|= (mods&mask);
	    XkbComputeDerivedState(xkbi);
	}

	UNWRAP_PROCESS_INPUT_PROC(xkbi->device,xkbPrivPtr, backupproc);
	xkbi->device->public.processInputProc((InternalEvent*)&ev, xkbi->device);
	COND_WRAP_PROCESS_INPUT_PROC(xkbi->device, xkbPrivPtr,
				     backupproc,xkbUnwrapProc);
d913 2
a914 5
	if ( mask || mods )
	    xkbi->state= old;

	filter->keycode= 0;
	filter->active= 0;
d920 3
a922 4
_XkbFilterSwitchScreen(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
d925 1
d929 12
a940 12
    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->filter = _XkbFilterSwitchScreen;
	AccessXCancelRepeatKey(xkbi, keycode);
	XkbDDXSwitchScreen(dev,keycode,pAction);
        return 0; 
    }
    else if (filter->keycode==keycode) {
	filter->active= 0;
        return 0; 
d946 2
a947 4
_XkbFilterXF86Private(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
d950 1
d954 11
a964 11
    if (filter->keycode==0) {		/* initial press */
	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->filter = _XkbFilterXF86Private;
	XkbDDXPrivate(dev,keycode,pAction);
        return 0; 
    }
    else if (filter->keycode==keycode) {
	filter->active= 0;
        return 0; 
a968 1

d970 2
a971 4
_XkbFilterDeviceBtn(	XkbSrvInfoPtr	xkbi,
			XkbFilterPtr	filter,
			unsigned	keycode,
			XkbAction *	pAction)
a972 3
DeviceIntPtr	dev;
int		button;

d976 66
a1041 60
    if (filter->keycode==0) {		/* initial press */
	_XkbLookupButtonDevice(&dev, pAction->devbtn.device, serverClient,
			       DixUnknownAccess, &button);
	if (!dev || !dev->public.on)
	    return 1;

	button= pAction->devbtn.button;
	if ((button<1)||(button>dev->button->numButtons))
	    return 1;

	filter->keycode = keycode;
	filter->active = 1;
	filter->filterOthers = 0;
	filter->priv=0;
	filter->filter = _XkbFilterDeviceBtn;
	filter->upAction= *pAction;
	switch (pAction->type) {
	    case XkbSA_LockDeviceBtn:
		if ((pAction->devbtn.flags&XkbSA_LockNoLock)||
		    BitIsOn(dev->button->down, button))
		    return 0;
		XkbFakeDeviceButton(dev,TRUE,button);
		filter->upAction.type= XkbSA_NoAction;
		break;
	    case XkbSA_DeviceBtn:
		if (pAction->devbtn.count>0) {
		    int nClicks,i;
		    nClicks= pAction->btn.count;
		    for (i=0;i<nClicks;i++) {
			XkbFakeDeviceButton(dev,TRUE,button);
			XkbFakeDeviceButton(dev,FALSE,button);
		    }
		    filter->upAction.type= XkbSA_NoAction;
		}
		else XkbFakeDeviceButton(dev,TRUE,button);
		break;
	}
    }
    else if (filter->keycode==keycode) {
	int	button;

	filter->active= 0;
	_XkbLookupButtonDevice(&dev, filter->upAction.devbtn.device,
			       serverClient, DixUnknownAccess, &button);
	if (!dev || !dev->public.on)
	    return 1;

	button= filter->upAction.btn.button;
	switch (filter->upAction.type) {
	    case XkbSA_LockDeviceBtn:
		if ((filter->upAction.devbtn.flags&XkbSA_LockNoUnlock)||
		    !BitIsOn(dev->button->down, button))
		    return 0;
		XkbFakeDeviceButton(dev,FALSE,button);
		break;
	    case XkbSA_DeviceBtn:
		XkbFakeDeviceButton(dev,FALSE,button);
		break;
	}
	filter->active = 0;
d1047 14
a1060 16
_XkbNextFreeFilter(
	XkbSrvInfoPtr xkbi
)
{
register int	i;

    if (xkbi->szFilters==0) {
	xkbi->szFilters = 4;
	xkbi->filters = calloc(xkbi->szFilters, sizeof(XkbFilterRec));
	/* 6/21/93 (ef) -- XXX! deal with allocation failure */
    }
    for (i=0;i<xkbi->szFilters;i++) {
	if (!xkbi->filters[i].active) {
	    xkbi->filters[i].keycode = 0;
	    return &xkbi->filters[i];
	}
d1062 2
a1063 2
    xkbi->szFilters*=2;
    xkbi->filters= realloc(xkbi->filters,
d1066 3
a1068 3
    memset(&xkbi->filters[xkbi->szFilters/2], 0,
            (xkbi->szFilters/2)*sizeof(XkbFilterRec));
    return &xkbi->filters[xkbi->szFilters/2];
d1072 1
a1072 1
_XkbApplyFilters(XkbSrvInfoPtr xkbi,unsigned kc,XkbAction *pAction)
d1074 1
a1074 1
register int	i,send;
d1076 7
a1082 5
    send= 1;
    for (i=0;i<xkbi->szFilters;i++) {
	if ((xkbi->filters[i].active)&&(xkbi->filters[i].filter))
	    send= ((*xkbi->filters[i].filter)(xkbi,&xkbi->filters[i],kc,pAction) 
                    && send);
d1088 1
a1088 1
XkbHandleActions(DeviceIntPtr dev, DeviceIntPtr kbd, DeviceEvent* event)
d1090 16
a1105 16
int		key,bit,i;
XkbSrvInfoPtr	xkbi;
KeyClassPtr	keyc;
int		changed,sendEvent;
Bool		genStateNotify;
XkbAction	act;
XkbFilterPtr	filter;
Bool		keyEvent;
Bool		pressEvent;
ProcessInputProc backupproc;
    
xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(dev);

    keyc= kbd->key;
    xkbi= keyc->xkbInfo;
    key= event->detail.key;
d1108 4
a1111 4
    if ((xkbi->flags&_XkbStateNotifyInProgress)==0) {
	xkbi->prev_state = xkbi->state;
	xkbi->flags|= _XkbStateNotifyInProgress;
	genStateNotify= TRUE;
d1113 2
a1114 1
    else genStateNotify= FALSE;
d1120 3
a1122 2
    keyEvent= ((event->type == ET_KeyPress) || (event->type == ET_KeyRelease));
    pressEvent= ((event->type == ET_KeyPress)|| (event->type == ET_ButtonPress));
d1125 74
a1198 69
	if (keyEvent)	
	    act = XkbGetKeyAction(xkbi,&xkbi->state,key);
	else {
	    act = XkbGetButtonAction(kbd,dev,key);
	    key|= BTN_ACT_FLAG;
	}
	sendEvent = _XkbApplyFilters(xkbi,key,&act);
	if (sendEvent) {
	    switch (act.type) {
		case XkbSA_SetMods:
		case XkbSA_SetGroup:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent = _XkbFilterSetState(xkbi,filter,key,&act);
		    break;
		case XkbSA_LatchMods:
		case XkbSA_LatchGroup:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterLatchState(xkbi,filter,key,&act);
		    break;
		case XkbSA_LockMods:
		case XkbSA_LockGroup:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterLockState(xkbi,filter,key,&act);
		    break;
		case XkbSA_ISOLock:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterISOLock(xkbi,filter,key,&act);
		    break;
		case XkbSA_MovePtr:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent= _XkbFilterPointerMove(xkbi,filter,key,&act);
		    break;
		case XkbSA_PtrBtn:
		case XkbSA_LockPtrBtn:
		case XkbSA_SetPtrDflt:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent= _XkbFilterPointerBtn(xkbi,filter,key,&act);
		    break;
		case XkbSA_Terminate:
		    sendEvent= XkbDDXTerminateServer(dev,key,&act);
		    break;
		case XkbSA_SwitchScreen:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterSwitchScreen(xkbi,filter,key,&act);
		    break;
		case XkbSA_SetControls:
		case XkbSA_LockControls:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterControls(xkbi,filter,key,&act);
		    break;
		case XkbSA_ActionMessage:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent=_XkbFilterActionMessage(xkbi,filter,key,&act);
		    break;
		case XkbSA_RedirectKey:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent= _XkbFilterRedirectKey(xkbi,filter,key,&act);
		    break;
		case XkbSA_DeviceBtn:
		case XkbSA_LockDeviceBtn:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent= _XkbFilterDeviceBtn(xkbi,filter,key,&act);
		    break;
		case XkbSA_XFree86Private:
		    filter = _XkbNextFreeFilter(xkbi);
		    sendEvent= _XkbFilterXF86Private(xkbi,filter,key,&act);
		    break;
	    }
	}
d1201 3
a1203 3
	if (!keyEvent)
	    key|= BTN_ACT_FLAG;
	sendEvent = _XkbApplyFilters(xkbi,key,NULL);
d1206 2
a1207 2
    if (xkbi->groupChange!=0)
	xkbi->state.base_group+= xkbi->groupChange;
d1209 7
a1215 7
	for (i=0,bit=1; xkbi->setMods; i++,bit<<=1 ) {
	    if (xkbi->setMods&bit) {
		keyc->modifierKeyCount[i]++;
		xkbi->state.base_mods|= bit;
		xkbi->setMods&= ~bit;
	    }
	}
d1218 10
a1227 10
	for (i=0,bit=1; xkbi->clearMods; i++,bit<<=1 ) {
	    if (xkbi->clearMods&bit) {
		keyc->modifierKeyCount[i]--;
		if (keyc->modifierKeyCount[i]<=0) {
		    xkbi->state.base_mods&= ~bit;
		    keyc->modifierKeyCount[i] = 0;
		}
		xkbi->clearMods&= ~bit;
	    }
	}
d1232 2
a1233 1
	if (keyEvent)
d1236 1
a1236 1
            tmpdev = GetPairedDevice(dev);
d1238 2
a1239 2
        UNWRAP_PROCESS_INPUT_PROC(tmpdev,xkbPrivPtr, backupproc);
        dev->public.processInputProc((InternalEvent*)event, tmpdev);
d1241 1
a1241 1
                                     backupproc,xkbUnwrapProc);
d1244 1
a1244 1
	FixKeyState(event, dev);
d1248 1
a1248 1
    changed = XkbStateChangedFlags(&xkbi->prev_state,&xkbi->state);
d1250 10
a1259 9
	if (changed) {
	    xkbStateNotify	sn;
	    sn.keycode= key;
	    sn.eventType= event->type;
	    sn.requestMajor = sn.requestMinor = 0;
	    sn.changed= changed;
	    XkbSendStateNotify(dev,&sn);
	}
	xkbi->flags&= ~_XkbStateNotifyInProgress;
d1261 1
a1261 1
    changed= XkbIndicatorsToUpdate(dev,changed,FALSE);
d1263 4
a1266 3
	XkbEventCauseRec	cause;
	XkbSetCauseKey(&cause, key, event->type);
	XkbUpdateIndicators(dev,changed,FALSE,NULL,&cause);
d1272 1
a1272 1
XkbLatchModifiers(DeviceIntPtr pXDev,CARD8 mask,CARD8 latches)
d1274 21
a1294 20
XkbSrvInfoPtr	xkbi;
XkbFilterPtr	filter;
XkbAction	act;
unsigned	clear;

    if ( pXDev && pXDev->key && pXDev->key->xkbInfo ) {
	xkbi = pXDev->key->xkbInfo;
	clear= (mask&(~latches));
	xkbi->state.latched_mods&= ~clear;
	/* Clear any pending latch to locks.
	 */
	act.type = XkbSA_NoAction;
	_XkbApplyFilters(xkbi,SYNTHETIC_KEYCODE,&act);
	act.type = XkbSA_LatchMods;
	act.mods.flags = 0;
	act.mods.mask  = mask&latches;
	filter = _XkbNextFreeFilter(xkbi);
	_XkbFilterLatchState(xkbi,filter,SYNTHETIC_KEYCODE,&act);
	_XkbFilterLatchState(xkbi,filter,SYNTHETIC_KEYCODE,(XkbAction *)NULL);
	return Success;
d1300 1
a1300 1
XkbLatchGroup(DeviceIntPtr pXDev,int group)
d1302 14
a1315 13
XkbSrvInfoPtr	xkbi;
XkbFilterPtr	filter;
XkbAction	act;

    if ( pXDev && pXDev->key && pXDev->key->xkbInfo ) {
	xkbi = pXDev->key->xkbInfo;
	act.type = XkbSA_LatchGroup;
	act.group.flags = 0;
	XkbSASetGroup(&act.group,group);
	filter = _XkbNextFreeFilter(xkbi);
	_XkbFilterLatchState(xkbi,filter,SYNTHETIC_KEYCODE,&act);
	_XkbFilterLatchState(xkbi,filter,SYNTHETIC_KEYCODE,(XkbAction *)NULL);
	return Success;
d1323 12
a1334 13
XkbClearAllLatchesAndLocks(	DeviceIntPtr		dev,
				XkbSrvInfoPtr		xkbi,
				Bool			genEv,
				XkbEventCausePtr	cause)
{
XkbStateRec	os;
xkbStateNotify	sn;

    sn.changed= 0;
    os= xkbi->state;
    if (os.latched_mods) { /* clear all latches */
	XkbLatchModifiers(dev,~0,0);
	sn.changed|= XkbModifierLatchMask;
d1337 2
a1338 2
	XkbLatchGroup(dev,0);
	sn.changed|= XkbGroupLatchMask;
d1341 2
a1342 2
	xkbi->state.locked_mods= 0;
	sn.changed|= XkbModifierLockMask;
d1345 2
a1346 2
	xkbi->state.locked_group= 0;
	sn.changed|= XkbGroupLockMask;
d1348 2
a1349 2
    if ( genEv && sn.changed) {
	CARD32 	changed;
d1351 11
a1361 11
	XkbComputeDerivedState(xkbi);
	sn.keycode= 		cause->kc;
	sn.eventType=		cause->event;
	sn.requestMajor= 	cause->mjr;
	sn.requestMinor= 	cause->mnr;
	sn.changed= XkbStateChangedFlags(&os,&xkbi->state);
	XkbSendStateNotify(dev,&sn);
	changed= XkbIndicatorsToUpdate(dev,sn.changed,FALSE);
	if (changed) {
	    XkbUpdateIndicators(dev,changed,TRUE,NULL,cause);
	}
d1387 2
a1388 1
InjectPointerKeyEvents(DeviceIntPtr dev, int type, int button, int flags, ValuatorMask *mask)
d1390 5
a1394 5
    ScreenPtr           pScreen;
    InternalEvent*      events;
    int                 nevents, i;
    DeviceIntPtr        ptr, mpointer, lastSlave = NULL;
    Bool                saveWait;
d1400 2
a1401 1
    } else if (IsFloating(dev))
a1405 1

d1412 2
a1413 1
        UpdateFromMaster(&events[nevents], lastSlave, DEVCHANGE_POINTER_EVENT, &nevents);
d1425 1
a1425 1
XkbFakePointerMotion(DeviceIntPtr dev, unsigned flags,int x,int y)
d1427 2
a1428 2
    ValuatorMask        mask;
    int                 gpe_flags = 0;
d1439 2
a1440 1
    valuator_mask_set_range(&mask, 0, 2, (int[]){x, y});
d1446 1
a1446 1
XkbFakeDeviceButton(DeviceIntPtr dev,Bool press,int button)
d1448 2
a1449 2
    DeviceIntPtr        ptr;
    int                 down;
d1461 1
d1463 2
a1464 1
    } else if (IsFloating(dev))
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d45 1
d71 1
a71 1
    return dixRegisterPrivateKey(&xkbDevicePrivateKeyRec, PRIVATE_DEVICE, 0);
d77 1
a77 8
    xkbDeviceInfoPtr xkbPrivPtr;

    xkbPrivPtr = (xkbDeviceInfoPtr) calloc(1, sizeof(xkbDeviceInfoRec));
    if (!xkbPrivPtr)
	return;
    xkbPrivPtr->unwrapProc = NULL;

    dixSetPrivate(&device->devPrivates, xkbDevicePrivateKey, xkbPrivPtr);
d1351 1
a1351 1
InjectPointerKeyEvents(DeviceIntPtr dev, int type, int button, int flags, int num_valuators, int *valuators)
d1354 1
a1354 1
    EventListPtr        events;
d1361 1
a1361 1
        lastSlave = mpointer->u.lastSlave;
d1363 1
a1363 1
    } else if (!dev->u.master)
d1373 1
a1373 2
    nevents = GetPointerEvents(events, ptr, type, button, flags, 0,
                               num_valuators, valuators);
d1380 1
a1380 1
        mieqProcessDeviceEvent(ptr, (InternalEvent*)events[i].event, NULL);
d1389 1
a1390 1
    int			motion[2];
d1393 1
a1393 1
    if (!IsMaster(dev) && GetMaster(dev, MASTER_POINTER) != NULL)
d1401 3
a1403 3
    motion[0] = x;
    motion[1] = y;
    InjectPointerKeyEvents(dev, MotionNotify, 0, gpe_flags, 2, motion);
d1423 1
a1423 1
    } else if (!dev->u.master)
d1433 1
a1433 1
                           button, 0, 0, NULL);
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d43 2
d47 4
a50 2
static int xkbDevicePrivateKeyIndex;
DevPrivateKey xkbDevicePrivateKey = &xkbDevicePrivateKeyIndex;
d67 5
d78 1
a78 1
    xkbPrivPtr = (xkbDeviceInfoPtr) xcalloc(1, sizeof(xkbDeviceInfoRec));
d491 1
a491 1
    XkbDDXFakePointerMotion(xkbi->device, xkbi->mouseKeysFlags,dx,dy);
a503 3
    if (xkbi->device == inputInfo.keyboard)
        return 0;

d516 1
a516 1
	XkbDDXFakePointerMotion(xkbi->device, pAction->ptr.flags,x,y);
d563 1
a563 1
		    XkbDDXFakeDeviceButton(xkbi->device, 1, button);
d574 2
a575 2
			    XkbDDXFakeDeviceButton(xkbi->device, 1, button);
			    XkbDDXFakeDeviceButton(xkbi->device, 0, button);
d579 1
a579 1
		    else XkbDDXFakeDeviceButton(xkbi->device, 1, button);
d634 10
d645 1
a645 1
		XkbDDXFakeDeviceButton(xkbi->device, 0, button);
d809 1
d984 1
a984 1
		XkbDDXFakeDeviceButton(dev,TRUE,button);
d992 2
a993 2
			XkbDDXFakeDeviceButton(dev,TRUE,button);
			XkbDDXFakeDeviceButton(dev,FALSE,button);
d997 1
a997 1
		else XkbDDXFakeDeviceButton(dev,TRUE,button);
d1016 1
a1016 1
		XkbDDXFakeDeviceButton(dev,FALSE,button);
d1019 1
a1019 1
		XkbDDXFakeDeviceButton(dev,FALSE,button);
d1036 1
a1036 1
	xkbi->filters = xcalloc(xkbi->szFilters, sizeof(XkbFilterRec));
d1046 1
a1046 1
    xkbi->filters= xrealloc(xkbi->filters,
d1049 1
a1049 1
    bzero(&xkbi->filters[xkbi->szFilters/2],
d1336 106
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a32 1
#define NEED_EVENTS 1
d39 1
a77 6
extern	void	ProcessOtherEvent(
    xEvent *		/* xE */,
    DeviceIntPtr 	/* dev */,
    int 		/* count */
);

a88 35
    if (XkbDisableLockActions) {
	switch (act->type) {
	    case XkbSA_LockMods:
		fake.mods.type  = XkbSA_SetMods;
		fake.mods.flags = 0;
		fake.mods.mask  = act->mods.mask;
		return fake;
	    case XkbSA_LatchMods:
		fake.mods.type  = XkbSA_SetMods;
		fake.mods.flags = 0;
		fake.mods.mask  = act->mods.mask;
		return fake;
	    case XkbSA_ISOLock:
		if (act->iso.flags&XkbSA_ISODfltIsGroup) {
		     fake.group.type = XkbSA_SetGroup;
		     fake.group.flags = act->iso.flags&XkbSA_GroupAbsolute;
		     XkbSASetGroup(&fake.group,XkbSAGroup(&act->iso));
		}
		else {
		     fake.mods.type  = XkbSA_SetMods;
		     fake.mods.flags = 0;
		     fake.mods.mask  = act->iso.mask;
		}
		return fake;
	    case XkbSA_LockGroup:
	    case XkbSA_LatchGroup:
		/* We want everything from the latch/lock action except the
		 * type should be changed to set.
		 */
		fake = *act;
		fake.group.type = XkbSA_SetGroup;
		return fake;
	}
    }
    else 
d127 5
a131 24
    effectiveGroup= xkbState->group;
    if (effectiveGroup!=XkbGroup1Index) {
	if (XkbKeyNumGroups(xkb,key)>(unsigned)1) {
	    if (effectiveGroup>=XkbKeyNumGroups(xkb,key)) {
		unsigned gi= XkbKeyGroupInfo(xkb,key);
		switch (XkbOutOfRangeGroupAction(gi)) {
		    default:
		    case XkbWrapIntoRange:
			effectiveGroup %= XkbKeyNumGroups(xkb,key);
			break;
		    case XkbClampIntoRange:
			effectiveGroup = XkbKeyNumGroups(xkb,key)-1;
			break;
		    case XkbRedirectIntoRange:
			effectiveGroup= XkbOutOfRangeGroupInfo(gi);
			if (effectiveGroup>=XkbKeyNumGroups(xkb,key))
			    effectiveGroup= 0;
			break;
		}
	    }
	}
	else effectiveGroup= XkbGroup1Index;
	col+= (effectiveGroup*XkbKeyGroupsWidth(xkb,key));
    }
d482 1
a482 1
    XkbDDXFakePointerMotion(xkbi->mouseKeysFlags,dx,dy);
d510 1
a510 1
	XkbDDXFakePointerMotion(pAction->ptr.flags,x,y);
d606 1
a606 1
						&cn,False)) {
d671 1
a671 1
	    if (XkbComputeControlsNotify(kbd,&old,ctrls,&cn,False)) {
d685 1
a685 1
		XkbClearAllLatchesAndLocks(kbd,xkbi,False,&cause);
d688 1
a688 1
	    XkbUpdateIndicators(kbd,sli->usesControls,True,NULL,&cause);
d700 1
a700 1
	    if (XkbComputeControlsNotify(kbd,&old,ctrls,&cn,False)) {
d712 1
a712 1
		XkbClearAllLatchesAndLocks(kbd,xkbi,False,&cause);
d715 1
a715 1
	    XkbUpdateIndicators(kbd,sli->usesControls,True,NULL,&cause);
d783 1
a783 2
unsigned	realMods = 0;
xEvent 		ev;
d786 1
a786 1
unsigned	mods,mask,oldCoreState = 0,oldCorePrevState = 0;
d797 6
a802 4
    GetSpritePosition(inputInfo.pointer, &x,&y);
    ev.u.keyButtonPointer.time = GetTimeInMillis();
    ev.u.keyButtonPointer.rootX = x;
    ev.u.keyButtonPointer.rootY = y;
d816 2
a817 3
        /* XXX: what about DeviceKeyPress */
	ev.u.u.type = KeyPress;
	ev.u.u.detail = pAction->redirect.new_key;
a827 2
	    oldCoreState= xkbi->device->key->state;
	    oldCorePrevState= xkbi->device->key->prev_state;
a834 2
	    xkbi->device->key->state= xkbi->device->key->prev_state= 
							xkbi->state.mods;
a836 2
	realMods = xkbi->device->key->modifierMap[ev.u.u.detail];
	xkbi->device->key->modifierMap[ev.u.u.detail] = 0;
d838 1
a838 1
	xkbi->device->public.processInputProc(&ev,xkbi->device,1);
a840 1
	xkbi->device->key->modifierMap[ev.u.u.detail] = realMods;
d842 1
a842 3
	if ( mask || mods ) {
	    xkbi->device->key->state= oldCoreState;
	    xkbi->device->key->prev_state= oldCorePrevState;
a843 1
	}
d847 2
a848 3
        /* XXX: what about DeviceKeyRelease */
	ev.u.u.type = KeyRelease;
	ev.u.u.detail = filter->upAction.redirect.new_key;
a858 2
	    oldCoreState= xkbi->device->key->state;
	    oldCorePrevState= xkbi->device->key->prev_state;
a865 2
	    xkbi->device->key->state= xkbi->device->key->prev_state= 
							xkbi->state.mods;
a867 2
	realMods = xkbi->device->key->modifierMap[ev.u.u.detail];
	xkbi->device->key->modifierMap[ev.u.u.detail] = 0;
d869 1
a869 1
	xkbi->device->public.processInputProc(&ev,xkbi->device,1);
a871 1
	xkbi->device->key->modifierMap[ev.u.u.detail] = realMods;
d873 1
a873 3
	if ( mask || mods ) {
	    xkbi->device->key->state= oldCoreState;
	    xkbi->device->key->prev_state= oldCorePrevState;
a874 1
	}
d949 1
a949 1
	if (!dev || !dev->public.on || dev == inputInfo.pointer)
d967 1
a967 1
		XkbDDXFakeDeviceButton(dev,True,button);
d975 2
a976 2
			XkbDDXFakeDeviceButton(dev,True,button);
			XkbDDXFakeDeviceButton(dev,False,button);
d980 1
a980 1
		else XkbDDXFakeDeviceButton(dev,True,button);
d990 1
a990 1
	if (!dev || !dev->public.on || dev == inputInfo.pointer)
d999 1
a999 1
		XkbDDXFakeDeviceButton(dev,False,button);
d1002 1
a1002 1
		XkbDDXFakeDeviceButton(dev,False,button);
d1019 1
a1019 1
	xkbi->filters = _XkbTypedCalloc(xkbi->szFilters,XkbFilterRec);
d1029 2
a1030 3
    xkbi->filters= _XkbTypedRealloc(xkbi->filters,
                                    xkbi->szFilters,
                                    XkbFilterRec);
d1052 1
a1052 1
XkbHandleActions(DeviceIntPtr dev,DeviceIntPtr kbd,xEvent *xE,int count)
a1054 1
CARD8		realMods = 0;
a1058 1
XkbStateRec	oldState;
d1069 1
a1069 1
    key= xE->u.u.detail;
d1073 1
a1073 1
	oldState= xkbi->state;
d1075 1
a1075 1
	genStateNotify= True;
d1077 1
a1077 1
    else genStateNotify= False;
d1083 2
a1084 4
    keyEvent= ((xE->u.u.type==KeyPress)||(xE->u.u.type==DeviceKeyPress)||
		(xE->u.u.type==KeyRelease)||(xE->u.u.type==DeviceKeyRelease));
    pressEvent= (xE->u.u.type==KeyPress)||(xE->u.u.type==DeviceKeyPress)||
		 (xE->u.u.type==ButtonPress)||(xE->u.u.type==DeviceButtonPress);
d1189 1
a1189 3
	if (keyEvent) {
	    realMods = keyc->modifierMap[key];
	    keyc->modifierMap[key] = 0;
d1191 1
a1191 1
        } else
d1195 1
a1195 1
        dev->public.processInputProc(xE,tmpdev,count);
a1197 2
        if (keyEvent)
	    keyc->modifierMap[key] = realMods;
d1200 1
a1200 1
	FixKeyState(xE,dev);
a1202 1
    xkbi->prev_state= oldState;
d1204 1
a1204 3
    keyc->prev_state= keyc->state;
    keyc->state= XkbStateFieldFromRec(&xkbi->state);
    changed = XkbStateChangedFlags(&oldState,&xkbi->state);
d1209 1
a1209 1
	    sn.eventType= xE->u.u.type;
d1216 1
a1216 1
    changed= XkbIndicatorsToUpdate(dev,changed,False);
d1219 2
a1220 2
	XkbSetCauseKey(&cause,key,xE->u.u.type);
	XkbUpdateIndicators(dev,changed,False,NULL,&cause);
d1311 1
a1311 1
	changed= XkbIndicatorsToUpdate(dev,sn.changed,False);
d1313 1
a1313 1
	    XkbUpdateIndicators(dev,changed,True,NULL,cause);
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d45 2
a46 1
DevPrivateKey xkbDevicePrivateKey = &xkbDevicePrivateKey;
a597 3
    if (xkbi->device == inputInfo.keyboard)
        return 0;

d617 1
a617 1
		    XkbDDXFakePointerButton(ButtonPress,button);
d628 2
a629 2
			    XkbDDXFakePointerButton(ButtonPress,button);
			    XkbDDXFakePointerButton(ButtonRelease,button);
d633 1
a633 1
		    else XkbDDXFakePointerButton(ButtonPress,button);
d689 1
a689 1
		XkbDDXFakePointerButton(ButtonRelease,button);
d858 1
a858 1
    GetSpritePosition(&x,&y);
a902 4
        /* XXX: Bad! Since the switch to XI devices xkbi->device will be the
         * XI device. Sending a core event through ProcessOtherEvent will
         * cause trouble. Somebody should fix this. 
         */
a944 4
        /* XXX: Bad! Since the switch to XI devices xkbi->device will be the
         * XI device. Sending a core event through ProcessOtherEvent will
         * cause trouble. Somebody should fix this. 
         */
d1024 1
a1024 1
    if (dev == inputInfo.keyboard)
d1046 1
a1046 1
		    (dev->button->down[button/8]&(1L<<(button%8))))
d1078 1
a1078 1
		    ((dev->button->down[button/8]&(1L<<(button%8)))==0))
d1274 1
d1278 7
a1284 5
        }

        UNWRAP_PROCESS_INPUT_PROC(dev,xkbPrivPtr, backupproc);
        dev->public.processInputProc(xE,dev,count);
        COND_WRAP_PROCESS_INPUT_PROC(dev, xkbPrivPtr,
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d45 1
a45 2
static unsigned int _xkbServerGeneration;
int xkbDevicePrivateIndex = -1;
a67 8
    if (serverGeneration != _xkbServerGeneration) {
	if ((xkbDevicePrivateIndex = AllocateDevicePrivateIndex()) == -1)
	    return;
	_xkbServerGeneration = serverGeneration;
    }
    if (!AllocateDevicePrivate(device, xkbDevicePrivateIndex))
	return;

d73 1
a73 1
    device->devPrivates[xkbDevicePrivateIndex].ptr = xkbPrivPtr;
d845 1
a845 1
unsigned	realMods;
d1038 3
a1040 2
	dev= _XkbLookupButtonDevice(pAction->devbtn.device,NULL);
	if ((!dev)||(!dev->public.on)||(&dev->public==LookupPointerDevice()))
d1079 3
a1081 2
	dev= _XkbLookupButtonDevice(filter->upAction.devbtn.device,NULL);
	if ((!dev)||(!dev->public.on)||(&dev->public==LookupPointerDevice()))
d1147 1
a1147 1
CARD8		realMods;
@


1.1
log
@Initial revision
@
text
@d39 2
a40 1
#include <X11/extensions/XKBsrv.h>
d43 1
d53 1
a53 1
    ProcessInputProc tmp = device->public.processInputProc;
d57 1
a57 1
    UNWRAP_PROCESS_INPUT_PROC(device,xkbPrivPtr);
d59 2
a60 2
    WRAP_PROCESS_INPUT_PROC(device,xkbPrivPtr,
			    tmp,xkbUnwrapProc);
d77 1
a77 1
    xkbPrivPtr = (xkbDeviceInfoPtr) xalloc(sizeof(xkbDeviceInfoRec));
d83 1
a83 2
    WRAP_PROCESS_INPUT_PROC(device,xkbPrivPtr,
			    proc,xkbUnwrapProc);
a85 1
#ifdef XINPUT
a90 1
#endif
d218 1
a218 1
XkbAction
a237 16
typedef struct _XkbFilter {
	CARD16			  keycode;
	CARD8			  what;
	CARD8			  active;
	CARD8			  filterOthers;
	CARD32			  priv;
	XkbAction		  upAction;
	int			(*filter)(
					XkbSrvInfoPtr 		/* xkbi */,
					struct _XkbFilter *	/* filter */,
					unsigned		/* keycode */,
					XkbAction *		/* action */
				  );
	struct _XkbFilter	 *next;
} XkbFilterRec,*XkbFilterPtr;

a401 1

d563 3
d606 3
d679 1
d744 1
d860 5
d886 1
d914 5
a918 1
	UNWRAP_PROCESS_INPUT_PROC(xkbi->device,xkbPrivPtr);
d921 1
a921 1
				     ProcessKeyboardEvent,xkbUnwrapProc);
d932 1
d960 5
a964 1
	UNWRAP_PROCESS_INPUT_PROC(xkbi->device,xkbPrivPtr);
d967 1
a967 1
				     ProcessKeyboardEvent,xkbUnwrapProc);
d988 4
a992 1
        DeviceIntPtr	dev = xkbi->device;
d1014 4
a1018 1
        DeviceIntPtr	dev = xkbi->device;
a1032 1
#ifdef XINPUT
d1043 3
a1106 4
#endif

static	int		szFilters = 0;
static	XkbFilterPtr	filters = NULL;
d1110 1
a1110 1
	void
d1115 3
a1117 3
    if (szFilters==0) {
	szFilters = 4;
	filters = _XkbTypedCalloc(szFilters,XkbFilterRec);
d1120 4
a1123 4
    for (i=0;i<szFilters;i++) {
	if (!filters[i].active) {
	    filters[i].keycode = 0;
	    return &filters[i];
d1126 4
a1129 2
    szFilters*=2;
    filters= _XkbTypedRealloc(filters,szFilters,XkbFilterRec);
d1131 3
a1133 2
    bzero(&filters[szFilters/2],(szFilters/2)*sizeof(XkbFilterRec));
    return &filters[szFilters/2];
d1142 4
a1145 3
    for (i=0;i<szFilters;i++) {
	if ((filters[i].active)&&(filters[i].filter))
	    send= ((*filters[i].filter)(xkbi,&filters[i],kc,pAction)&&send);
d1164 1
a1164 3
#ifdef XINPUT
Bool		xiEvent;
#endif
d1171 2
a1183 1
#ifdef XINPUT
a1187 7
    xiEvent= (xE->u.u.type==DeviceKeyPress)||(xE->u.u.type==DeviceKeyRelease)||
	     (xE->u.u.type==DeviceButtonPress)||
	     (xE->u.u.type==DeviceButtonRelease);
#else
    keyEvent= (xE->u.u.type==KeyPress)||(xE->u.u.type==KeyRelease);
    pressEvent= (xE->u.u.type==KeyPress)||(xE->u.u.type==ButtonPress);
#endif
d1201 1
a1201 1
		    filter = _XkbNextFreeFilter();
d1206 1
a1206 1
		    filter = _XkbNextFreeFilter();
d1211 1
a1211 1
		    filter = _XkbNextFreeFilter();
d1215 1
a1215 1
		    filter = _XkbNextFreeFilter();
d1219 1
a1219 1
		    filter = _XkbNextFreeFilter();
d1225 1
a1225 1
		    filter = _XkbNextFreeFilter();
d1232 1
a1232 1
		    filter = _XkbNextFreeFilter();
d1237 1
a1237 1
		    filter = _XkbNextFreeFilter();
d1241 1
a1241 1
		    filter = _XkbNextFreeFilter();
d1245 1
a1245 1
		    filter = _XkbNextFreeFilter();
a1247 1
#ifdef XINPUT
d1250 1
a1250 1
		    filter = _XkbNextFreeFilter();
a1252 1
#endif
d1254 1
a1254 1
		    filter = _XkbNextFreeFilter();
a1290 5
#ifdef XINPUT
	if (xiEvent)
	    ProcessOtherEvent(xE,dev,count);
	else 
#endif
d1294 7
a1300 4
	    UNWRAP_PROCESS_INPUT_PROC(dev,xkbPrivPtr);
	    dev->public.processInputProc(xE,dev,count);
	    COND_WRAP_PROCESS_INPUT_PROC(dev, xkbPrivPtr,
					 ProcessKeyboardEvent,xkbUnwrapProc);
a1301 2
	}
	else CoreProcessPointerEvent(xE,dev,count);
d1303 1
a1303 1
    else if (keyEvent)
d1305 1
d1327 1
a1327 1
	XkbUpdateIndicators(dev,changed,True,NULL,&cause);
d1351 1
a1351 1
	filter = _XkbNextFreeFilter();
d1371 1
a1371 1
	filter = _XkbNextFreeFilter();
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d39 1
a39 1
#include <xkbsrv.h>
d44 1
a44 1
static int xkbDevicePrivateIndex = -1;
d46 1
a46 1
static void
d219 1
a219 1
static XkbAction
a869 4

    /* never actually used uninitialised, but gcc isn't smart enough
     * to work that out. */
    memset(&old, 0, sizeof(old));
@


1.1.1.3
log
@xserver 1.4.0.90
@
text
@a38 1
#include "exevents.h"
a41 1
#define EXTENSION_EVENT_BASE 64
d44 1
a44 1
int xkbDevicePrivateIndex = -1;
d46 1
a46 1
void
a51 1
    ProcessInputProc dummy; /* unused, but neede for macro */
d55 1
a55 1
    UNWRAP_PROCESS_INPUT_PROC(device,xkbPrivPtr, dummy);
d75 1
a75 1
    xkbPrivPtr = (xkbDeviceInfoPtr) xcalloc(1, sizeof(xkbDeviceInfoRec));
d81 2
a82 1
    WRAP_PROCESS_INPUT_PROC(device, xkbPrivPtr, proc, xkbUnwrapProc);
d85 1
d91 1
d239 16
d419 1
a580 3
    if (xkbi->device == inputInfo.keyboard)
        return 0;

a620 3
    if (xkbi->device == inputInfo.keyboard)
        return 0;

a690 1
                        /* XXX: what about DeviceKeyPress? */
a754 1
                /* XXX: what about DeviceKeyPress? */
a869 1
ProcessInputProc backupproc;
a894 1
        /* XXX: what about DeviceKeyPress */
d922 1
a922 5
        /* XXX: Bad! Since the switch to XI devices xkbi->device will be the
         * XI device. Sending a core event through ProcessOtherEvent will
         * cause trouble. Somebody should fix this. 
         */
	UNWRAP_PROCESS_INPUT_PROC(xkbi->device,xkbPrivPtr, backupproc);
d925 1
a925 1
				     backupproc,xkbUnwrapProc);
a935 1
        /* XXX: what about DeviceKeyRelease */
d963 1
a963 5
        /* XXX: Bad! Since the switch to XI devices xkbi->device will be the
         * XI device. Sending a core event through ProcessOtherEvent will
         * cause trouble. Somebody should fix this. 
         */
	UNWRAP_PROCESS_INPUT_PROC(xkbi->device,xkbPrivPtr, backupproc);
d966 1
a966 1
				     backupproc,xkbUnwrapProc);
a986 4
    DeviceIntPtr dev = xkbi->device;
    if (dev == inputInfo.keyboard)
        return 0;

d988 1
a1009 4
    DeviceIntPtr dev = xkbi->device;
    if (dev == inputInfo.keyboard)
        return 0;

d1011 1
d1026 1
a1036 3
    if (dev == inputInfo.keyboard)
        return 0;

d1098 4
d1105 1
a1105 1
	XkbSrvInfoPtr xkbi
d1110 3
a1112 3
    if (xkbi->szFilters==0) {
	xkbi->szFilters = 4;
	xkbi->filters = _XkbTypedCalloc(xkbi->szFilters,XkbFilterRec);
d1115 4
a1118 4
    for (i=0;i<xkbi->szFilters;i++) {
	if (!xkbi->filters[i].active) {
	    xkbi->filters[i].keycode = 0;
	    return &xkbi->filters[i];
d1121 2
a1122 4
    xkbi->szFilters*=2;
    xkbi->filters= _XkbTypedRealloc(xkbi->filters,
                                    xkbi->szFilters,
                                    XkbFilterRec);
d1124 2
a1125 3
    bzero(&xkbi->filters[xkbi->szFilters/2],
            (xkbi->szFilters/2)*sizeof(XkbFilterRec));
    return &xkbi->filters[xkbi->szFilters/2];
d1134 3
a1136 4
    for (i=0;i<xkbi->szFilters;i++) {
	if ((xkbi->filters[i].active)&&(xkbi->filters[i].filter))
	    send= ((*xkbi->filters[i].filter)(xkbi,&xkbi->filters[i],kc,pAction) 
                    && send);
d1155 3
a1157 1
ProcessInputProc backupproc;
a1163 2
    /* The state may change, so if we're not in the middle of sending a state
     * notify, prepare for it */
d1175 1
d1180 7
d1200 1
a1200 1
		    filter = _XkbNextFreeFilter(xkbi);
d1205 1
a1205 1
		    filter = _XkbNextFreeFilter(xkbi);
d1210 1
a1210 1
		    filter = _XkbNextFreeFilter(xkbi);
d1214 1
a1214 1
		    filter = _XkbNextFreeFilter(xkbi);
d1218 1
a1218 1
		    filter = _XkbNextFreeFilter(xkbi);
d1224 1
a1224 1
		    filter = _XkbNextFreeFilter(xkbi);
d1231 1
a1231 1
		    filter = _XkbNextFreeFilter(xkbi);
d1236 1
a1236 1
		    filter = _XkbNextFreeFilter(xkbi);
d1240 1
a1240 1
		    filter = _XkbNextFreeFilter(xkbi);
d1244 1
a1244 1
		    filter = _XkbNextFreeFilter(xkbi);
d1247 1
d1250 1
a1250 1
		    filter = _XkbNextFreeFilter(xkbi);
d1253 1
d1255 1
a1255 1
		    filter = _XkbNextFreeFilter(xkbi);
d1292 5
d1300 4
a1303 7
        }

        UNWRAP_PROCESS_INPUT_PROC(dev,xkbPrivPtr, backupproc);
        dev->public.processInputProc(xE,dev,count);
        COND_WRAP_PROCESS_INPUT_PROC(dev, xkbPrivPtr,
                                     backupproc,xkbUnwrapProc);
        if (keyEvent)
d1305 2
d1308 1
a1308 1
    else if (keyEvent) {
a1309 1
    }
d1331 1
a1331 1
	XkbUpdateIndicators(dev,changed,False,NULL,&cause);
d1355 1
a1355 1
	filter = _XkbNextFreeFilter(xkbi);
d1375 1
a1375 1
	filter = _XkbNextFreeFilter(xkbi);
@


