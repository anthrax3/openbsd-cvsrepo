head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2013.06.07.17.28.56;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.11;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.29;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.25;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <xkb-config.h>

#include <stdio.h>
#include <ctype.h>
#include <X11/X.h>
#include <X11/Xos.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/extensions/XKM.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include <X11/extensions/XI.h>
#include "xkb.h"

        /*
         * If XKM_OUTPUT_DIR specifies a path without a leading slash, it is
         * relative to the top-level XKB configuration directory.
         * Making the server write to a subdirectory of that directory
         * requires some work in the general case (install procedure
         * has to create links to /var or somesuch on many machines),
         * so we just compile into /usr/tmp for now.
         */
#ifndef XKM_OUTPUT_DIR
#define	XKM_OUTPUT_DIR	"compiled/"
#endif

#define	PRE_ERROR_MSG "\"The XKEYBOARD keymap compiler (xkbcomp) reports:\""
#define	ERROR_PREFIX	"\"> \""
#define	POST_ERROR_MSG1 "\"Errors from xkbcomp are not fatal to the X server\""
#define	POST_ERROR_MSG2 "\"End of messages from xkbcomp\""

#if defined(WIN32)
#define PATHSEPARATOR "\\"
#else
#define PATHSEPARATOR "/"
#endif

static unsigned
LoadXKM(unsigned want, unsigned need, const char *keymap, XkbDescPtr *xkbRtrn);

static void
OutputDirectory(char *outdir, size_t size)
{
#ifndef WIN32
    /* Can we write an xkm and then open it too? */
    if (access(XKM_OUTPUT_DIR, W_OK | X_OK) == 0 &&
        (strlen(XKM_OUTPUT_DIR) < size)) {
        (void) strcpy(outdir, XKM_OUTPUT_DIR);
    }
    else
#else
    if (strlen(Win32TempDir()) + 1 < size) {
        (void) strcpy(outdir, Win32TempDir());
        (void) strcat(outdir, "\\");
    }
    else
#endif
    if (strlen("/tmp/") < size) {
        (void) strcpy(outdir, "/tmp/");
    }
}

/**
 * Callback invoked by XkbRunXkbComp. Write to out to talk to xkbcomp.
 */
typedef void (*xkbcomp_buffer_callback)(FILE *out, void *userdata);

/**
 * Start xkbcomp, let the callback write into xkbcomp's stdin. When done,
 * return a strdup'd copy of the file name we've written to.
 */
static char *
RunXkbComp(xkbcomp_buffer_callback callback, void *userdata)
{
    FILE *out;
    char *buf = NULL, keymap[PATH_MAX], xkm_output_dir[PATH_MAX];

    const char *emptystring = "";
    char *xkbbasedirflag = NULL;
    const char *xkbbindir = emptystring;
    const char *xkbbindirsep = emptystring;

#ifdef WIN32
    /* WIN32 has no popen. The input must be stored in a file which is
       used as input for xkbcomp. xkbcomp does not read from stdin. */
    char tmpname[PATH_MAX];
    const char *xkmfile = tmpname;
#else
    const char *xkmfile = "-";
#endif

    snprintf(keymap, sizeof(keymap), "server-%s", display);

    OutputDirectory(xkm_output_dir, sizeof(xkm_output_dir));

#ifdef WIN32
    strcpy(tmpname, Win32TempDir());
    strcat(tmpname, "\\xkb_XXXXXX");
    (void) mktemp(tmpname);
#endif

    if (XkbBaseDirectory != NULL) {
        if (asprintf(&xkbbasedirflag, "\"-R%s\"", XkbBaseDirectory) == -1)
            xkbbasedirflag = NULL;
    }

    if (XkbBinDirectory != NULL) {
        int ld = strlen(XkbBinDirectory);
        int lps = strlen(PATHSEPARATOR);

        xkbbindir = XkbBinDirectory;

        if ((ld >= lps) && (strcmp(xkbbindir + ld - lps, PATHSEPARATOR) != 0)) {
            xkbbindirsep = PATHSEPARATOR;
        }
    }

    if (asprintf(&buf,
                 "\"%s%sxkbcomp\" -w %d %s -xkm \"%s\" "
                 "-em1 %s -emp %s -eml %s \"%s%s.xkm\"",
                 xkbbindir, xkbbindirsep,
                 ((xkbDebugFlags < 2) ? 1 :
                  ((xkbDebugFlags > 10) ? 10 : (int) xkbDebugFlags)),
                 xkbbasedirflag ? xkbbasedirflag : "", xkmfile,
                 PRE_ERROR_MSG, ERROR_PREFIX, POST_ERROR_MSG1,
                 xkm_output_dir, keymap) == -1)
        buf = NULL;

    free(xkbbasedirflag);

    if (!buf) {
        LogMessage(X_ERROR,
                   "XKB: Could not invoke xkbcomp: not enough memory\n");
        return NULL;
    }

#ifndef WIN32
    out = Popen(buf, "w");
#else
    out = fopen(tmpname, "w");
#endif

    if (out != NULL) {
        /* Now write to xkbcomp */
        (*callback)(out, userdata);

#ifndef WIN32
        if (Pclose(out) == 0)
#else
        if (fclose(out) == 0 && System(buf) >= 0)
#endif
        {
            if (xkbDebugFlags)
                DebugF("[xkb] xkb executes: %s\n", buf);
            free(buf);
#ifdef WIN32
            unlink(tmpname);
#endif
            return xnfstrdup(keymap);
        }
        else
            LogMessage(X_ERROR, "Error compiling keymap (%s)\n", keymap);
#ifdef WIN32
        /* remove the temporary file */
        unlink(tmpname);
#endif
    }
    else {
#ifndef WIN32
        LogMessage(X_ERROR, "XKB: Could not invoke xkbcomp\n");
#else
        LogMessage(X_ERROR, "Could not open file %s\n", tmpname);
#endif
    }
    free(buf);
    return NULL;
}

typedef struct {
    XkbDescPtr xkb;
    XkbComponentNamesPtr names;
    unsigned int want;
    unsigned int need;
} XkbKeymapNamesCtx;

static void
xkb_write_keymap_for_names_cb(FILE *out, void *userdata)
{
    XkbKeymapNamesCtx *ctx = userdata;
#ifdef DEBUG
    if (xkbDebugFlags) {
        ErrorF("[xkb] XkbDDXCompileKeymapByNames compiling keymap:\n");
        XkbWriteXKBKeymapForNames(stderr, ctx->names, ctx->xkb, ctx->want, ctx->need);
    }
#endif
    XkbWriteXKBKeymapForNames(out, ctx->names, ctx->xkb, ctx->want, ctx->need);
}

static Bool
XkbDDXCompileKeymapByNames(XkbDescPtr xkb,
                           XkbComponentNamesPtr names,
                           unsigned want,
                           unsigned need, char *nameRtrn, int nameRtrnLen)
{
    char *keymap;
    Bool rc = FALSE;
    XkbKeymapNamesCtx ctx = {
        .xkb = xkb,
        .names = names,
        .want = want,
        .need = need
    };

    keymap = RunXkbComp(xkb_write_keymap_for_names_cb, &ctx);

    if (keymap) {
        if(nameRtrn)
            strlcpy(nameRtrn, keymap, nameRtrnLen);

        free(keymap);
        rc = TRUE;
    } else if (nameRtrn)
        *nameRtrn = '\0';

    return rc;
}

typedef struct {
    const char *keymap;
    size_t len;
} XkbKeymapString;

static void
xkb_write_keymap_string_cb(FILE *out, void *userdata)
{
    XkbKeymapString *s = userdata;
    fwrite(s->keymap, s->len, 1, out);
}

static unsigned int
XkbDDXLoadKeymapFromString(DeviceIntPtr keybd,
                          const char *keymap, int keymap_length,
                          unsigned int want,
                          unsigned int need,
                          XkbDescPtr *xkbRtrn)
{
    unsigned int have;
    char *map_name;
    XkbKeymapString map = {
        .keymap = keymap,
        .len = keymap_length
    };

    *xkbRtrn = NULL;

    map_name = RunXkbComp(xkb_write_keymap_string_cb, &map);
    if (!map_name) {
        LogMessage(X_ERROR, "XKB: Couldn't compile keymap\n");
        return 0;
    }

    have = LoadXKM(want, need, map_name, xkbRtrn);
    free(map_name);

    return have;
}

static FILE *
XkbDDXOpenConfigFile(const char *mapName, char *fileNameRtrn, int fileNameRtrnLen)
{
    char buf[PATH_MAX], xkm_output_dir[PATH_MAX];
    FILE *file;

    buf[0] = '\0';
    if (mapName != NULL) {
        OutputDirectory(xkm_output_dir, sizeof(xkm_output_dir));
        if ((XkbBaseDirectory != NULL) && (xkm_output_dir[0] != '/')
#ifdef WIN32
            && (!isalpha(xkm_output_dir[0]) || xkm_output_dir[1] != ':')
#endif
            ) {
            if (snprintf(buf, PATH_MAX, "%s/%s%s.xkm", XkbBaseDirectory,
                         xkm_output_dir, mapName) >= PATH_MAX)
                buf[0] = '\0';
        }
        else {
            if (snprintf(buf, PATH_MAX, "%s%s.xkm", xkm_output_dir, mapName)
                >= PATH_MAX)
                buf[0] = '\0';
        }
        if (buf[0] != '\0')
            file = fopen(buf, "rb");
        else
            file = NULL;
    }
    else
        file = NULL;
    if ((fileNameRtrn != NULL) && (fileNameRtrnLen > 0)) {
        strlcpy(fileNameRtrn, buf, fileNameRtrnLen);
    }
    return file;
}

static unsigned
LoadXKM(unsigned want, unsigned need, const char *keymap, XkbDescPtr *xkbRtrn)
{
    FILE *file;
    char fileName[PATH_MAX];
    unsigned missing;

    file = XkbDDXOpenConfigFile(keymap, fileName, PATH_MAX);
    if (file == NULL) {
        LogMessage(X_ERROR, "Couldn't open compiled keymap file %s\n",
                   fileName);
        return 0;
    }
    missing = XkmReadFile(file, need, want, xkbRtrn);
    if (*xkbRtrn == NULL) {
        LogMessage(X_ERROR, "Error loading keymap %s\n", fileName);
        fclose(file);
        (void) unlink(fileName);
        return 0;
    }
    else {
        DebugF("Loaded XKB keymap %s, defined=0x%x\n", fileName,
               (*xkbRtrn)->defined);
    }
    fclose(file);
    (void) unlink(fileName);
    return (need | want) & (~missing);
}

unsigned
XkbDDXLoadKeymapByNames(DeviceIntPtr keybd,
                        XkbComponentNamesPtr names,
                        unsigned want,
                        unsigned need,
                        XkbDescPtr *xkbRtrn, char *nameRtrn, int nameRtrnLen)
{
    XkbDescPtr xkb;

    *xkbRtrn = NULL;
    if ((keybd == NULL) || (keybd->key == NULL) ||
        (keybd->key->xkbInfo == NULL))
        xkb = NULL;
    else
        xkb = keybd->key->xkbInfo->desc;
    if ((names->keycodes == NULL) && (names->types == NULL) &&
        (names->compat == NULL) && (names->symbols == NULL) &&
        (names->geometry == NULL)) {
        LogMessage(X_ERROR, "XKB: No components provided for device %s\n",
                   keybd->name ? keybd->name : "(unnamed keyboard)");
        return 0;
    }
    else if (!XkbDDXCompileKeymapByNames(xkb, names, want, need,
                                         nameRtrn, nameRtrnLen)) {
        LogMessage(X_ERROR, "XKB: Couldn't compile keymap\n");
        return 0;
    }

    return LoadXKM(want, need, nameRtrn, xkbRtrn);
}

Bool
XkbDDXNamesFromRules(DeviceIntPtr keybd,
                     const char *rules_name,
                     XkbRF_VarDefsPtr defs, XkbComponentNamesPtr names)
{
    char buf[PATH_MAX];
    FILE *file;
    Bool complete;
    XkbRF_RulesPtr rules;

    if (!rules_name)
        return FALSE;

    if (snprintf(buf, PATH_MAX, "%s/rules/%s", XkbBaseDirectory, rules_name)
        >= PATH_MAX) {
        LogMessage(X_ERROR, "XKB: Rules name is too long\n");
        return FALSE;
    }

    file = fopen(buf, "r");
    if (!file) {
        LogMessage(X_ERROR, "XKB: Couldn't open rules file %s\n", buf);
        return FALSE;
    }

    rules = XkbRF_Create();
    if (!rules) {
        LogMessage(X_ERROR, "XKB: Couldn't create rules struct\n");
        fclose(file);
        return FALSE;
    }

    if (!XkbRF_LoadRules(file, rules)) {
        LogMessage(X_ERROR, "XKB: Couldn't parse rules file %s\n", rules_name);
        fclose(file);
        XkbRF_Free(rules, TRUE);
        return FALSE;
    }

    memset(names, 0, sizeof(*names));
    complete = XkbRF_GetComponents(rules, defs, names);
    fclose(file);
    XkbRF_Free(rules, TRUE);

    if (!complete)
        LogMessage(X_ERROR, "XKB: Rules returned no components\n");

    return complete;
}

static Bool
XkbRMLVOtoKcCGST(DeviceIntPtr dev, XkbRMLVOSet * rmlvo,
                 XkbComponentNamesPtr kccgst)
{
    XkbRF_VarDefsRec mlvo;

    mlvo.model = rmlvo->model;
    mlvo.layout = rmlvo->layout;
    mlvo.variant = rmlvo->variant;
    mlvo.options = rmlvo->options;

    return XkbDDXNamesFromRules(dev, rmlvo->rules, &mlvo, kccgst);
}

/**
 * Compile the given RMLVO keymap and return it. Returns the XkbDescPtr on
 * success or NULL on failure. If the components compiled are not a superset
 * or equal to need, the compiliation is treated as failure.
 */
static XkbDescPtr
XkbCompileKeymapForDevice(DeviceIntPtr dev, XkbRMLVOSet * rmlvo, int need)
{
    XkbDescPtr xkb = NULL;
    unsigned int provided;
    XkbComponentNamesRec kccgst = { 0 };
    char name[PATH_MAX];

    if (XkbRMLVOtoKcCGST(dev, rmlvo, &kccgst)) {
        provided =
            XkbDDXLoadKeymapByNames(dev, &kccgst, XkmAllIndicesMask, need, &xkb,
                                    name, PATH_MAX);
        if ((need & provided) != need) {
            if (xkb) {
                XkbFreeKeyboard(xkb, 0, TRUE);
                xkb = NULL;
            }
        }
    }

    XkbFreeComponentNames(&kccgst, FALSE);
    return xkb;
}

static XkbDescPtr
KeymapOrDefaults(DeviceIntPtr dev, XkbDescPtr xkb)
{
    XkbRMLVOSet dflts;

    if (xkb)
        return xkb;

    /* we didn't get what we really needed. And that will likely leave
     * us with a keyboard that doesn't work. Use the defaults instead */
    LogMessage(X_ERROR, "XKB: Failed to load keymap. Loading default "
                        "keymap instead.\n");

    XkbGetRulesDflts(&dflts);

    xkb = XkbCompileKeymapForDevice(dev, &dflts, 0);

    XkbFreeRMLVOSet(&dflts, FALSE);

    return xkb;
}


XkbDescPtr
XkbCompileKeymap(DeviceIntPtr dev, XkbRMLVOSet * rmlvo)
{
    XkbDescPtr xkb;
    unsigned int need;

    if (!dev || !rmlvo) {
        LogMessage(X_ERROR, "XKB: No device or RMLVO specified\n");
        return NULL;
    }

    /* These are the components we really really need */
    need = XkmSymbolsMask | XkmCompatMapMask | XkmTypesMask |
        XkmKeyNamesMask | XkmVirtualModsMask;

    xkb = XkbCompileKeymapForDevice(dev, rmlvo, need);

    return KeymapOrDefaults(dev, xkb);
}

XkbDescPtr
XkbCompileKeymapFromString(DeviceIntPtr dev,
                           const char *keymap, int keymap_length)
{
    XkbDescPtr xkb;
    unsigned int need, provided;

    if (!dev || !keymap) {
        LogMessage(X_ERROR, "XKB: No device or keymap specified\n");
        return NULL;
    }

    /* These are the components we really really need */
    need = XkmSymbolsMask | XkmCompatMapMask | XkmTypesMask |
           XkmKeyNamesMask | XkmVirtualModsMask;

    provided =
        XkbDDXLoadKeymapFromString(dev, keymap, keymap_length,
                                   XkmAllIndicesMask, need, &xkb);
    if ((need & provided) != need) {
        if (xkb) {
            XkbFreeKeyboard(xkb, 0, TRUE);
            xkb = NULL;
        }
    }

    return KeymapOrDefaults(dev, xkb);
}
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d9 2
a10 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d12 1
a12 1
Silicon Graphics makes no representation about the suitability 
d16 2
a17 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d19 3
a21 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d71 3
d96 11
a106 5
static Bool
XkbDDXCompileKeymapByNames(XkbDescPtr xkb,
                           XkbComponentNamesPtr names,
                           unsigned want,
                           unsigned need, char *nameRtrn, int nameRtrnLen)
d167 1
a167 1
        return FALSE;
d177 3
a179 7
#ifdef DEBUG
        if (xkbDebugFlags) {
            ErrorF("[xkb] XkbDDXCompileKeymapByNames compiling keymap:\n");
            XkbWriteXKBKeymapForNames(stderr, names, xkb, want, need);
        }
#endif
        XkbWriteXKBKeymapForNames(out, names, xkb, want, need);
a187 3
            if (nameRtrn) {
                strlcpy(nameRtrn, keymap, nameRtrnLen);
            }
d192 1
a192 1
            return TRUE;
a207 2
    if (nameRtrn)
        nameRtrn[0] = '\0';
d209 90
a298 1
    return FALSE;
d302 1
a302 1
XkbDDXOpenConfigFile(char *mapName, char *fileNameRtrn, int fileNameRtrnLen)
d337 29
a373 3
    FILE *file;
    char fileName[PATH_MAX];
    unsigned missing;
d393 2
a394 20
    file = XkbDDXOpenConfigFile(nameRtrn, fileName, PATH_MAX);
    if (file == NULL) {
        LogMessage(X_ERROR, "Couldn't open compiled keymap file %s\n",
                   fileName);
        return 0;
    }
    missing = XkmReadFile(file, need, want, xkbRtrn);
    if (*xkbRtrn == NULL) {
        LogMessage(X_ERROR, "Error loading keymap %s\n", fileName);
        fclose(file);
        (void) unlink(fileName);
        return 0;
    }
    else {
        DebugF("Loaded XKB keymap %s, defined=0x%x\n", fileName,
               (*xkbRtrn)->defined);
    }
    fclose(file);
    (void) unlink(fileName);
    return (need | want) & (~missing);
d399 1
a399 1
                     char *rules_name,
d490 23
d530 2
a531 2
    if (!xkb) {
        XkbRMLVOSet dflts;
d533 6
a538 4
        /* we didn't get what we really needed. And that will likely leave
         * us with a keyboard that doesn't work. Use the defaults instead */
        LogMessage(X_ERROR, "XKB: Failed to load keymap. Loading default "
                   "keymap instead.\n");
d540 4
a543 1
        XkbGetRulesDflts(&dflts);
d545 3
a547 1
        xkb = XkbCompileKeymapForDevice(dev, &dflts, 0);
d549 8
a556 1
        XkbFreeRMLVOSet(&dflts, FALSE);
d559 1
a559 1
    return xkb;
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a70 75
#ifdef WIN32

#include <X11/Xwindows.h>
const char *
Win32TempDir()
{
    static char buffer[PATH_MAX];

    if (GetTempPath(sizeof(buffer), buffer)) {
        int len;

        buffer[sizeof(buffer) - 1] = 0;
        len = strlen(buffer);
        if (len > 0)
            if (buffer[len - 1] == '\\')
                buffer[len - 1] = 0;
        return buffer;
    }
    if (getenv("TEMP") != NULL)
        return getenv("TEMP");
    else if (getenv("TMP") != NULL)
        return getenv("TEMP");
    else
        return "/tmp";
}

int
Win32System(const char *cmdline)
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD dwExitCode;
    char *cmd = strdup(cmdline);

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
        LPVOID buffer;

        if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_FROM_SYSTEM |
                           FORMAT_MESSAGE_IGNORE_INSERTS,
                           NULL,
                           GetLastError(),
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPTSTR) & buffer, 0, NULL)) {
            ErrorF("[xkb] Starting '%s' failed!\n", cmdline);
        }
        else {
            ErrorF("[xkb] Starting '%s' failed: %s", cmdline, (char *) buffer);
            LocalFree(buffer);
        }

        free(cmd);
        return -1;
    }
    /* Wait until child process exits. */
    WaitForSingleObject(pi.hProcess, INFINITE);

    GetExitCodeProcess(pi.hProcess, &dwExitCode);

    /* Close process and thread handles. */
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    free(cmd);

    return dwExitCode;
}

#undef System
#define System(x) Win32System(x)
#endif

@


1.7
log
@Update to xserver 1.11.2
@
text
@d48 8
a55 8
	/*
	 * If XKM_OUTPUT_DIR specifies a path without a leading slash, it is
	 * relative to the top-level XKB configuration directory.
	 * Making the server write to a subdirectory of that directory
	 * requires some work in the general case (install procedure
	 * has to create links to /var or somesuch on many machines),
	 * so we just compile into /usr/tmp for now.
	 */
d74 1
a74 1
const char* 
d78 2
a79 2
    if (GetTempPath(sizeof(buffer), buffer))
    {
d81 2
a82 1
        buffer[sizeof(buffer)-1] = 0;
d85 2
a86 2
            if (buffer[len-1] == '\\')
                buffer[len-1] = 0;
d97 1
a97 1
int 
d105 1
a105 1
    ZeroMemory( &si, sizeof(si) );
d107 4
a110 1
    ZeroMemory( &pi, sizeof(pi) );
d112 13
a124 21
    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) 
    {
	LPVOID buffer;
	if (!FormatMessage( 
		    FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		    FORMAT_MESSAGE_FROM_SYSTEM | 
		    FORMAT_MESSAGE_IGNORE_INSERTS,
		    NULL,
		    GetLastError(),
		    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		    (LPTSTR) &buffer,
		    0,
		    NULL ))
	{
	    ErrorF("[xkb] Starting '%s' failed!\n", cmdline); 
	}
	else
	{
	    ErrorF("[xkb] Starting '%s' failed: %s", cmdline, (char *)buffer); 
	    LocalFree(buffer);
	}
d126 2
a127 2
	free(cmd);
	return -1;
d130 3
a132 1
    WaitForSingleObject( pi.hProcess, INFINITE );
a133 2
    GetExitCodeProcess( pi.hProcess, &dwExitCode);
    
d135 2
a136 2
    CloseHandle( pi.hProcess );
    CloseHandle( pi.hThread );
d141 1
d147 1
a147 3
OutputDirectory(
    char* outdir,
    size_t size)
d151 5
a155 4
    if (access(XKM_OUTPUT_DIR, W_OK | X_OK) == 0 && (strlen(XKM_OUTPUT_DIR) < size))
    {
	(void) strcpy (outdir, XKM_OUTPUT_DIR);
    } else
d157 8
a164 9
    if (strlen(Win32TempDir()) + 1 < size)
    {
	(void) strcpy(outdir, Win32TempDir());
	(void) strcat(outdir, "\\");
    } else 
#endif
    if (strlen("/tmp/") < size)
    {
	(void) strcpy (outdir, "/tmp/");
d169 4
a172 6
XkbDDXCompileKeymapByNames(	XkbDescPtr		xkb,
				XkbComponentNamesPtr	names,
				unsigned		want,
				unsigned		need,
				char *			nameRtrn,
				int			nameRtrnLen)
d174 2
a175 2
    FILE *	out;
    char	*buf = NULL, keymap[PATH_MAX], xkm_output_dir[PATH_MAX];
d177 1
a177 1
    const char	*emptystring = "";
d179 2
a180 2
    const char	*xkbbindir = emptystring;
    const char	*xkbbindirsep = emptystring;
d202 2
a203 2
	if (asprintf(&xkbbasedirflag, "\"-R%s\"", XkbBaseDirectory) == -1)
	    xkbbasedirflag = NULL;
d207 2
a208 2
	int ld = strlen(XkbBinDirectory);
	int lps = strlen(PATHSEPARATOR);
d210 1
a210 1
	xkbbindir = XkbBinDirectory;
d212 3
a214 4
	if ((ld >= lps) &&
	    (strcmp(xkbbindir + ld - lps, PATHSEPARATOR) != 0)) {
	    xkbbindirsep = PATHSEPARATOR;
	}
d218 9
a226 9
		 "\"%s%sxkbcomp\" -w %d %s -xkm \"%s\" "
		  "-em1 %s -emp %s -eml %s \"%s%s.xkm\"",
		 xkbbindir, xkbbindirsep,
		 ((xkbDebugFlags < 2) ? 1 :
		  ((xkbDebugFlags > 10) ? 10 : (int) xkbDebugFlags)),
		 xkbbasedirflag ? xkbbasedirflag : "", xkmfile,
		 PRE_ERROR_MSG, ERROR_PREFIX, POST_ERROR_MSG1,
		 xkm_output_dir, keymap) == -1)
	buf = NULL;
d231 2
a232 1
        LogMessage(X_ERROR, "XKB: Could not invoke xkbcomp: not enough memory\n");
d235 1
a235 1
    
d237 1
a237 1
    out= Popen(buf,"w");
d239 1
a239 1
    out= fopen(tmpname, "w");
d241 2
a242 2
    
    if (out!=NULL) {
d244 4
a247 4
    if (xkbDebugFlags) {
       ErrorF("[xkb] XkbDDXCompileKeymapByNames compiling keymap:\n");
       XkbWriteXKBKeymapForNames(stderr,names,xkb,want,need);
    }
d249 1
a249 1
	XkbWriteXKBKeymapForNames(out,names,xkb,want,need);
d251 1
a251 1
	if (Pclose(out)==0)
d253 1
a253 1
	if (fclose(out)==0 && System(buf) >= 0)
d255 1
a255 1
	{
d257 4
a260 5
                DebugF("[xkb] xkb executes: %s\n",buf);
	    if (nameRtrn) {
		strncpy(nameRtrn,keymap,nameRtrnLen);
		nameRtrn[nameRtrnLen-1]= '\0';
	    }
d262 7
a268 4
	    return TRUE;
	}
	else
	    LogMessage(X_ERROR, "Error compiling keymap (%s)\n", keymap);
d276 1
a276 1
	LogMessage(X_ERROR, "XKB: Could not invoke xkbcomp\n");
d278 1
a278 1
	LogMessage(X_ERROR, "Could not open file %s\n", tmpname);
d282 1
a282 1
	nameRtrn[0]= '\0';
d288 1
a288 1
XkbDDXOpenConfigFile(char *mapName,char *fileNameRtrn,int fileNameRtrnLen)
d290 2
a291 2
char	buf[PATH_MAX],xkm_output_dir[PATH_MAX];
FILE *	file;
d293 4
a296 4
    buf[0]= '\0';
    if (mapName!=NULL) {
	OutputDirectory(xkm_output_dir, sizeof(xkm_output_dir));
	if ((XkbBaseDirectory!=NULL)&&(xkm_output_dir[0]!='/')
d298 1
a298 1
                &&(!isalpha(xkm_output_dir[0]) || xkm_output_dir[1]!=':')
d300 1
a300 1
                ) {
d304 2
a305 3
	}
	else
	{
d309 10
a318 9
	}
	if (buf[0] != '\0')
	    file= fopen(buf,"rb");
	else file= NULL;
    }
    else file= NULL;
    if ((fileNameRtrn!=NULL)&&(fileNameRtrnLen>0)) {
	strncpy(fileNameRtrn,buf,fileNameRtrnLen);
	buf[fileNameRtrnLen-1]= '\0';
d324 5
a328 7
XkbDDXLoadKeymapByNames(	DeviceIntPtr		keybd,
				XkbComponentNamesPtr	names,
				unsigned		want,
				unsigned		need,
				XkbDescPtr *		xkbRtrn,
				char *			nameRtrn,
				int 			nameRtrnLen)
d330 4
a333 4
XkbDescPtr      xkb;
FILE	*	file;
char		fileName[PATH_MAX];
unsigned	missing;
d336 8
a343 6
    if ((keybd==NULL)||(keybd->key==NULL)||(keybd->key->xkbInfo==NULL))
	 xkb= NULL;
    else xkb= keybd->key->xkbInfo->desc;
    if ((names->keycodes==NULL)&&(names->types==NULL)&&
	(names->compat==NULL)&&(names->symbols==NULL)&&
	(names->geometry==NULL)) {
d348 17
a364 16
    else if (!XkbDDXCompileKeymapByNames(xkb,names,want,need,
                                         nameRtrn,nameRtrnLen)){
	LogMessage(X_ERROR, "XKB: Couldn't compile keymap\n");
	return 0;
    }
    file= XkbDDXOpenConfigFile(nameRtrn,fileName,PATH_MAX);
    if (file==NULL) {
	LogMessage(X_ERROR, "Couldn't open compiled keymap file %s\n",fileName);
	return 0;
    }
    missing= XkmReadFile(file,need,want,xkbRtrn);
    if (*xkbRtrn==NULL) {
	LogMessage(X_ERROR, "Error loading keymap %s\n",fileName);
	fclose(file);
	(void) unlink (fileName);
	return 0;
d367 2
a368 1
	DebugF("Loaded XKB keymap %s, defined=0x%x\n",fileName,(*xkbRtrn)->defined);
d371 2
a372 2
    (void) unlink (fileName);
    return (need|want)&(~missing);
d376 3
a378 4
XkbDDXNamesFromRules(	DeviceIntPtr		keybd,
			char *			rules_name,
			XkbRF_VarDefsPtr	defs,
			XkbComponentNamesPtr	names)
d380 4
a383 4
char 		buf[PATH_MAX];
FILE *		file;
Bool		complete;
XkbRF_RulesPtr	rules;
d386 1
a386 1
	return FALSE;
d397 1
a397 1
	return FALSE;
d403 2
a404 2
	fclose(file);
	return FALSE;
d409 3
a411 3
	fclose(file);
	XkbRF_Free(rules,TRUE);
	return FALSE;
d415 1
a415 1
    complete = XkbRF_GetComponents(rules,defs,names);
d426 2
a427 1
XkbRMLVOtoKcCGST(DeviceIntPtr dev, XkbRMLVOSet *rmlvo, XkbComponentNamesPtr kccgst)
d445 1
a445 1
XkbCompileKeymapForDevice(DeviceIntPtr dev, XkbRMLVOSet *rmlvo, int need)
d449 1
a449 1
    XkbComponentNamesRec kccgst = {0};
d453 3
a455 2
        provided = XkbDDXLoadKeymapByNames(dev, &kccgst, XkmAllIndicesMask, need,
                                           &xkb, name, PATH_MAX);
d469 1
a469 1
XkbCompileKeymap(DeviceIntPtr dev, XkbRMLVOSet *rmlvo)
d481 1
a481 2
           XkmKeyNamesMask | XkmVirtualModsMask;

@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a47 4
#if defined(CSRG_BASED) || defined(linux) || defined(__GNU__)
#include <paths.h>
#endif

d209 2
a210 1
	xkbbasedirflag = Xprintf("\"-R%s\"", XkbBaseDirectory);
d225 2
a226 1
    buf = Xprintf("\"%s%sxkbcomp\" -w %d %s -xkm \"%s\" "
d228 7
a234 6
		  xkbbindir, xkbbindirsep,
		  ( (xkbDebugFlags < 2) ? 1 :
		    ((xkbDebugFlags > 10) ? 10 : (int)xkbDebugFlags) ),
		  xkbbasedirflag ? xkbbasedirflag : "", xkmfile,
		  PRE_ERROR_MSG, ERROR_PREFIX, POST_ERROR_MSG1,
		  xkm_output_dir, keymap);
d269 1
a269 2
            if (buf != NULL)
                free(buf);
d288 1
a288 2
    if (buf != NULL)
        free(buf);
d306 9
a314 6
	    if (strlen(XkbBaseDirectory)+strlen(xkm_output_dir)
		     +strlen(mapName)+6 <= PATH_MAX)
	    {
		snprintf(buf,sizeof(buf),"%s/%s%s.xkm",XkbBaseDirectory,
					xkm_output_dir,mapName);
	    }
a315 2
	else if (strlen(xkm_output_dir)+strlen(mapName)+5 <= PATH_MAX)
	    snprintf(buf,sizeof(buf),"%s%s.xkm",xkm_output_dir,mapName);
d392 2
a393 1
    if (strlen(XkbBaseDirectory) + strlen(rules_name) + 8 > PATH_MAX) {
a396 1
    snprintf(buf,sizeof(buf),"%s/rules/%s", XkbBaseDirectory, rules_name);
d429 41
a472 2
    XkbComponentNamesRec kccgst;
    XkbRF_VarDefsRec mlvo;
d474 1
a474 1
    char name[PATH_MAX];
d481 16
a496 4
    mlvo.model = rmlvo->model;
    mlvo.layout = rmlvo->layout;
    mlvo.variant = rmlvo->variant;
    mlvo.options = rmlvo->options;
d498 1
a498 3
    /* XDNFR already logs for us. */
    if (!XkbDDXNamesFromRules(dev, rmlvo->rules, &mlvo, &kccgst))
        return NULL;
d500 1
a500 6
    /* XDLKBN too, but it might return 0 as well as allocating. */
    if (!XkbDDXLoadKeymapByNames(dev, &kccgst, XkmAllIndicesMask, 0, &xkb, name,
                                 PATH_MAX)) {
        if (xkb)
            XkbFreeKeyboard(xkb, 0, TRUE);
        return NULL;
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d106 1
a106 1
    char *cmd = xstrdup(cmdline);
d134 1
a134 1
	xfree(cmd);
d145 1
a145 1
    xfree(cmd);
d189 1
a189 1
    const char	*xkbbasedirflag = emptystring;
d233 1
a233 1
		  xkbbasedirflag, xkmfile,
d237 5
a241 2
    if (xkbbasedirflag != emptystring) {
	xfree(xkbbasedirflag);
d271 1
a271 1
                xfree (buf);
d291 1
a291 1
        xfree (buf);
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a30 1
#ifdef HAVE_XKB_CONFIG_H
a31 1
#endif
a34 1
#define	NEED_EVENTS 1
d159 2
a160 1
    if (getuid() == 0 && (strlen(XKM_OUTPUT_DIR) < size))
a161 2
	/* if server running as root it *may* be able to write */
	/* FIXME: check whether directory is writable at all */
d177 1
a177 1
static Bool    	
a203 1
    XkbEnsureSafeMapName(keymap);
d269 1
a269 1
	    return True;
d289 1
a289 1
    return False;
d389 1
a389 1
	return False;
d393 1
a393 1
        return False;
d400 1
a400 1
	return False;
d403 1
a403 1
    rules = XkbRF_Create(0, 0);
d407 1
a407 1
	return False;
d413 2
a414 2
	XkbRF_Free(rules,True);
	return False;
d420 1
a420 1
    XkbRF_Free(rules, True);
d426 33
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d51 1
a51 1
#if defined(CSRG_BASED) || defined(linux) || defined(__sgi) || defined(AIXV3) || defined(__osf__) || defined(__GNU__)
d129 1
a129 1
	    ErrorF("Starting '%s' failed!\n", cmdline); 
d133 1
a133 1
	    ErrorF("Starting '%s' failed: %s", cmdline, (char *)buffer); 
d189 7
a195 2
FILE *	out;
char	*buf = NULL, keymap[PATH_MAX],xkm_output_dir[PATH_MAX];
d198 9
a206 12
char tmpname[PATH_MAX];
#endif    
    if ((names->keymap==NULL)||(names->keymap[0]=='\0')) {
	sprintf(keymap,"server-%s",display);
    }
    else {
	if (strlen(names->keymap) > PATH_MAX - 1) {
	    ErrorF("name of keymap (%s) exceeds max length\n", names->keymap);
	    return False;
	}
	strcpy(keymap,names->keymap);
    }
d210 1
d216 15
a230 18
    if (XkbBaseDirectory!=NULL) {
#ifndef WIN32
        char *xkmfile = "-";
#else
        /* WIN32 has no popen. The input must be stored in a file which is used as input
           for xkbcomp. xkbcomp does not read from stdin. */
        char *xkmfile = tmpname;
#endif
        char *xkbbasedir = XkbBaseDirectory;
        char *xkbbindir = XkbBinDirectory;
        
	buf = Xprintf(
	   "\"%s" PATHSEPARATOR "xkbcomp\" -w %d \"-R%s\" -xkm \"%s\" -em1 %s -emp %s -eml %s \"%s%s.xkm\"",
		xkbbindir,
		((xkbDebugFlags<2)?1:((xkbDebugFlags>10)?10:(int)xkbDebugFlags)),
		xkbbasedir, xkmfile,
		PRE_ERROR_MSG,ERROR_PREFIX,POST_ERROR_MSG1,
		xkm_output_dir,keymap);
d232 12
a243 12
    else {
#ifndef WIN32
        char *xkmfile = "-";
#else
        char *xkmfile = tmpname;
#endif
	buf = Xprintf(
		"xkbcomp -w %d -xkm \"%s\" -em1 %s -emp %s -eml %s \"%s%s.xkm\"",
		((xkbDebugFlags<2)?1:((xkbDebugFlags>10)?10:(int)xkbDebugFlags)),
                xkmfile,
		PRE_ERROR_MSG,ERROR_PREFIX,POST_ERROR_MSG1,
		xkm_output_dir,keymap);
d255 1
a255 1
       ErrorF("XkbDDXCompileKeymapByNames compiling keymap:\n");
d267 1
a267 1
                DebugF("xkb executes: %s\n",buf);
d314 1
a314 1
	        sprintf(buf,"%s/%s%s.xkm",XkbBaseDirectory,
d319 1
a319 1
	    sprintf(buf,"%s%s.xkm",xkm_output_dir,mapName);
d400 1
a400 1
    sprintf(buf,"%s/rules/%s", XkbBaseDirectory, rules_name);
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@a54 8
#ifndef PATH_MAX
#ifdef MAXPATHLEN
#define	PATH_MAX MAXPATHLEN
#else
#define	PATH_MAX 1024
#endif
#endif

a155 12
#ifdef MAKE_XKM_OUTPUT_DIR
/* Borrow trans_mkdir from Xtransutil.c to more safely make directories */
# undef X11_t
# define TRANS_SERVER
# define PRMSG(lvl,x,a,b,c) \
	if (lvl <= 1) { LogMessage(X_ERROR,x,a,b,c); } else ((void)0)
# include <X11/Xtrans/Xtransutil.c>
# ifndef XKM_OUTPUT_DIR_MODE
#  define XKM_OUTPUT_DIR_MODE 0755
# endif
#endif

d162 1
a162 5
    if (getuid() == 0 && (strlen(XKM_OUTPUT_DIR) < size)
#ifdef MAKE_XKM_OUTPUT_DIR    
	&& (trans_mkdir(XKM_OUTPUT_DIR, XKM_OUTPUT_DIR_MODE) == 0)
#endif
	)
d168 1
a168 10
#endif
#ifdef _PATH_VARTMP
    if ((strlen(_PATH_VARTMP) + 1) < size) 
    {
	(void) strcpy (outdir, _PATH_VARTMP);
	if (outdir[strlen(outdir) - 1] != '/')	/* Hi IBM, Digital */
	    (void) strcat (outdir, "/");
    } else
#endif
#ifdef WIN32
a180 75
static Bool
XkbDDXCompileNamedKeymap(	XkbDescPtr		xkb,
				XkbComponentNamesPtr	names,
				char *			nameRtrn,
				int			nameRtrnLen)
{
char 	*cmd = NULL,file[PATH_MAX],xkm_output_dir[PATH_MAX],*map,*outFile;

    if (names->keymap==NULL)
	return False;
    strncpy(file,names->keymap,PATH_MAX); file[PATH_MAX-1]= '\0';
    if ((map= strrchr(file,'('))!=NULL) {
	char *tmp;
	if ((tmp= strrchr(map,')'))!=NULL) {
	    *map++= '\0';
	    *tmp= '\0';
	}
	else {
	    map= NULL;
	}
    }
    if ((outFile= strrchr(file,'/'))!=NULL)
	 outFile= _XkbDupString(&outFile[1]);
    else outFile= _XkbDupString(file);
    XkbEnsureSafeMapName(outFile);
    OutputDirectory(xkm_output_dir, sizeof(xkm_output_dir));

    if (XkbBaseDirectory!=NULL) {
        char *xkbbasedir = XkbBaseDirectory;
        char *xkbbindir = XkbBinDirectory;

	cmd = Xprintf("\"%s" PATHSEPARATOR "xkbcomp\" -w %d \"-R%s\" -xkm %s%s -em1 %s -emp %s -eml %s keymap/%s \"%s%s.xkm\"",
		xkbbindir,
		((xkbDebugFlags<2)?1:((xkbDebugFlags>10)?10:(int)xkbDebugFlags)),
		xkbbasedir,(map?"-m ":""),(map?map:""),
		PRE_ERROR_MSG,ERROR_PREFIX,POST_ERROR_MSG1,file,
		xkm_output_dir,outFile);
    }
    else {
	cmd = Xprintf("xkbcomp -w %d -xkm %s%s -em1 %s -emp %s -eml %s keymap/%s \"%s%s.xkm\"",
		((xkbDebugFlags<2)?1:((xkbDebugFlags>10)?10:(int)xkbDebugFlags)),
		(map?"-m ":""),(map?map:""),
		PRE_ERROR_MSG,ERROR_PREFIX,POST_ERROR_MSG1,file,
		xkm_output_dir,outFile);
    }
#ifdef DEBUG
    if (xkbDebugFlags) {
	ErrorF("XkbDDXCompileNamedKeymap compiling keymap using:\n");
	ErrorF("    \"cmd\"\n");
    }
#endif
#ifdef DEBUG_CMD
    ErrorF("xkb executes: %s\n",cmd);
#endif
    if (System(cmd)==0) {
	if (nameRtrn) {
	    strncpy(nameRtrn,outFile,nameRtrnLen);
	    nameRtrn[nameRtrnLen-1]= '\0';
	}
	if (outFile!=NULL)
	    _XkbFree(outFile);
        if (cmd!=NULL)
            xfree(cmd);
	return True;
    } 
#ifdef DEBUG
    ErrorF("Error compiling keymap (%s)\n",names->keymap);
#endif
    if (outFile!=NULL)
	_XkbFree(outFile);
    if (cmd!=NULL)
        xfree(cmd);
    return False;
}

d256 1
a256 1
       XkbWriteXKBKeymapForNames(stderr,names,NULL,xkb,want,need);
d259 1
a259 1
	XkbWriteXKBKeymapForNames(out,names,NULL,xkb,want,need);
d266 2
a267 6
#ifdef DEBUG_CMD
	    ErrorF("xkb executes: %s\n",buf);
	    ErrorF("xkbcomp input:\n");
	    XkbWriteXKBKeymapForNames(stderr,names,NULL,xkb,want,need);
	    ErrorF("end xkbcomp input\n");
#endif
d337 1
a337 1
				XkbFileInfo *		finfoRtrn,
d341 1
a341 1
XkbDescPtr	xkb;
d346 1
a346 1
    bzero(finfoRtrn,sizeof(XkbFileInfo));
d353 3
a355 15
	if (names->keymap==NULL) {
	    bzero(finfoRtrn,sizeof(XkbFileInfo));
	    if (xkb && XkbDetermineFileType(finfoRtrn,XkbXKMFile,NULL) &&
	   				((finfoRtrn->defined&need)==need) ) {
		finfoRtrn->xkb= xkb;
		nameRtrn[0]= '\0';
		return finfoRtrn->defined;
	    }
	    return 0;
	}
	else if (!XkbDDXCompileNamedKeymap(xkb,names,nameRtrn,nameRtrnLen)) {
            LogMessage(X_ERROR, "Couldn't compile keymap file %s\n",
                       names->keymap);
	    return 0;
	}
d367 2
a368 2
    missing= XkmReadFile(file,need,want,finfoRtrn);
    if (finfoRtrn->xkb==NULL) {
d375 1
a375 1
	DebugF("XKB: Loaded %s, defined=0x%x\n",fileName,finfoRtrn->defined);
@


1.1
log
@Initial revision
@
text
@d47 1
a47 1
#include <X11/extensions/XKBsrv.h>
d80 1
a80 1
#if defined(__UNIXOS2__) || defined(WIN32)
d214 1
a214 1
Bool
a241 1
#ifndef __UNIXOS2__
a243 11
#else
        /* relocate the basedir and replace the slashes with backslashes */
        char *xkbbasedir = (char*)__XOS2RedirRoot(XkbBaseDirectory);
        char *xkbbindir = (char*)__XOS2RedirRoot(XkbBinDirectory);
        int i;

	for (i=0; i<strlen(xkbbasedir); i++) 
            if (xkbbasedir[i]=='/') xkbbasedir[i]='\\';
	for (i=0; i<strlen(xkbbindir); i++) 
            if (xkbbindir[i]=='/') xkbbindir[i]='\\';
#endif
d289 1
a289 1
Bool    	
a328 1
#ifndef __UNIXOS2__
a330 9
#else
        int i;
        char *xkbbasedir = (char*)__XOS2RedirRoot(XkbBaseDirectory);
        char *xkbbindir = (char*)__XOS2RedirRoot(XkbBinDirectory);
	for (i=0; i<strlen(xkbbasedir); i++) 
            if (xkbbasedir[i]=='/') xkbbasedir[i]='\\';
	for (i=0; i<strlen(xkbbindir); i++) 
            if (xkbbindir[i]=='/') xkbbindir[i]='\\';
#endif
a383 24
#if defined(Lynx) && defined(__i386__) && defined(NEED_POPEN_WORKAROUND)
	/* somehow popen/pclose is broken on LynxOS AT 2.3.0/2.4.0!
	 * the problem usually shows up with XF86Setup
	 * this hack waits at max 5 seconds after pclose() returns
	 * for the output of the xkbcomp output file.
	 * I didn't manage to get a patch in time for the 3.2 release
	 */
            {
		int i;
		char name[PATH_MAX];
                if (XkbBaseDirectory!=NULL)
		    sprintf(name,"%s/%s%s.xkm", XkbBaseDirectory
			,xkm_output_dir, keymap);
		else
                    sprintf(name,"%s%s.xkm", xkm_output_dir, keymap);
		for (i = 0; i < 10; i++) {
	            if (access(name, 0) == 0) break;
		    usleep(500000);
		}
#ifdef DEBUG
		if (i) ErrorF(">>>> Waited %d times for %s\n", i, name);
#endif
	    }
#endif
a387 1
#ifdef DEBUG
d389 1
a389 2
	    ErrorF("Error compiling keymap (%s)\n",keymap);
#endif
a394 1
#ifdef DEBUG
d397 1
a397 1
	ErrorF("Could not invoke keymap compiler\n");
d399 1
a399 1
	ErrorF("Could not open file %s\n", tmpname);
a401 1
#endif
d409 1
a409 1
FILE *
d476 2
a477 3
#ifdef NOISY
	    ErrorF("Couldn't compile keymap file\n");
#endif
d482 2
a483 4
						nameRtrn,nameRtrnLen)){
#ifdef NOISY
	ErrorF("Couldn't compile keymap file\n");
#endif
d498 2
a499 3
#ifdef DEBUG
    else if (xkbDebugFlags) {
	ErrorF("Loaded %s, defined=0x%x\n",fileName,finfoRtrn->defined);
a500 1
#endif
d519 11
a529 4
    if (XkbBaseDirectory==NULL) {
	if (strlen(rules_name)+7 > PATH_MAX)
	    return False;
	sprintf(buf,"rules/%s",rules_name);
d531 4
a534 8
    else {
	if (strlen(XkbBaseDirectory)+strlen(rules_name)+8 > PATH_MAX)
	    return False;
        sprintf(buf,"%s/rules/%s",XkbBaseDirectory,rules_name);
    }
    if ((file= fopen(buf,"r"))==NULL)
	return False;
    if ((rules= XkbRF_Create(0,0))==NULL) {
d538 3
a540 1
    if (!XkbRF_LoadRules(file,rules)) {
d545 3
a547 2
    bzero((char *)names,sizeof(XkbComponentNamesRec));
    complete= XkbRF_GetComponents(rules,defs,names);
d549 5
a553 1
    XkbRF_Free(rules,True);
a555 2


@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d47 1
a47 1
#include <xkbsrv.h>
d80 1
a80 1
#if defined(WIN32)
d214 1
a214 1
static Bool
d242 1
d245 11
d301 1
a301 1
static Bool    	
d341 1
d344 9
d406 24
d459 1
a459 1
static FILE *
@

