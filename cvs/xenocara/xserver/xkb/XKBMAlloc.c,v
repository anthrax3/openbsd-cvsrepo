head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.12
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.10
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.8
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2012.08.05.18.11.38;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.11;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.22;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.22;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.35;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#elif defined(HAVE_CONFIG_H)
#include <config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include <X11/keysym.h>
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>

/***====================================================================***/

Status
XkbAllocClientMap(XkbDescPtr xkb, unsigned which, unsigned nTotalTypes)
{
    register int i;
    XkbClientMapPtr map;

    if ((xkb == NULL) ||
        ((nTotalTypes > 0) && (nTotalTypes < XkbNumRequiredTypes)))
        return BadValue;
    if ((which & XkbKeySymsMask) &&
        ((!XkbIsLegalKeycode(xkb->min_key_code)) ||
         (!XkbIsLegalKeycode(xkb->max_key_code)) ||
         (xkb->max_key_code < xkb->min_key_code))) {
        DebugF("bad keycode (%d,%d) in XkbAllocClientMap\n",
               xkb->min_key_code, xkb->max_key_code);
        return BadValue;
    }

    if (xkb->map == NULL) {
        map = calloc(1, sizeof(XkbClientMapRec));
        if (map == NULL)
            return BadAlloc;
        xkb->map = map;
    }
    else
        map = xkb->map;

    if ((which & XkbKeyTypesMask) && (nTotalTypes > 0)) {
        if (map->types == NULL) {
            map->types = calloc(nTotalTypes, sizeof(XkbKeyTypeRec));
            if (map->types == NULL)
                return BadAlloc;
            map->num_types = 0;
            map->size_types = nTotalTypes;
        }
        else if (map->size_types < nTotalTypes) {
            XkbKeyTypeRec *prev_types = map->types;

            map->types =
                reallocarray(map->types, nTotalTypes, sizeof(XkbKeyTypeRec));
            if (map->types == NULL) {
                free(prev_types);
                map->num_types = map->size_types = 0;
                return BadAlloc;
            }
            map->size_types = nTotalTypes;
            memset(&map->types[map->num_types], 0,
                   ((map->size_types -
                     map->num_types) * sizeof(XkbKeyTypeRec)));
        }
    }
    if (which & XkbKeySymsMask) {
        int nKeys = XkbNumKeys(xkb);

        if (map->syms == NULL) {
            map->size_syms = (nKeys * 15) / 10;
            map->syms = calloc(map->size_syms, sizeof(KeySym));
            if (!map->syms) {
                map->size_syms = 0;
                return BadAlloc;
            }
            map->num_syms = 1;
            map->syms[0] = NoSymbol;
        }
        if (map->key_sym_map == NULL) {
            i = xkb->max_key_code + 1;
            map->key_sym_map = calloc(i, sizeof(XkbSymMapRec));
            if (map->key_sym_map == NULL)
                return BadAlloc;
        }
    }
    if (which & XkbModifierMapMask) {
        if ((!XkbIsLegalKeycode(xkb->min_key_code)) ||
            (!XkbIsLegalKeycode(xkb->max_key_code)) ||
            (xkb->max_key_code < xkb->min_key_code))
            return BadMatch;
        if (map->modmap == NULL) {
            i = xkb->max_key_code + 1;
            map->modmap = calloc(i, sizeof(unsigned char));
            if (map->modmap == NULL)
                return BadAlloc;
        }
    }
    return Success;
}

Status
XkbAllocServerMap(XkbDescPtr xkb, unsigned which, unsigned nNewActions)
{
    register int i;
    XkbServerMapPtr map;

    if (xkb == NULL)
        return BadMatch;
    if (xkb->server == NULL) {
        map = calloc(1, sizeof(XkbServerMapRec));
        if (map == NULL)
            return BadAlloc;
        for (i = 0; i < XkbNumVirtualMods; i++) {
            map->vmods[i] = XkbNoModifierMask;
        }
        xkb->server = map;
    }
    else
        map = xkb->server;
    if (which & XkbExplicitComponentsMask) {
        if ((!XkbIsLegalKeycode(xkb->min_key_code)) ||
            (!XkbIsLegalKeycode(xkb->max_key_code)) ||
            (xkb->max_key_code < xkb->min_key_code))
            return BadMatch;
        if (map->explicit == NULL) {
            i = xkb->max_key_code + 1;
            map->explicit = calloc(i, sizeof(unsigned char));
            if (map->explicit == NULL)
                return BadAlloc;
        }
    }
    if (which & XkbKeyActionsMask) {
        if ((!XkbIsLegalKeycode(xkb->min_key_code)) ||
            (!XkbIsLegalKeycode(xkb->max_key_code)) ||
            (xkb->max_key_code < xkb->min_key_code))
            return BadMatch;
        if (nNewActions < 1)
            nNewActions = 1;
        if (map->acts == NULL) {
            map->acts = calloc((nNewActions + 1), sizeof(XkbAction));
            if (map->acts == NULL)
                return BadAlloc;
            map->num_acts = 1;
            map->size_acts = nNewActions + 1;
        }
        else if ((map->size_acts - map->num_acts) < nNewActions) {
            unsigned need;
            XkbAction *prev_acts = map->acts;

            need = map->num_acts + nNewActions;
            map->acts = reallocarray(map->acts, need, sizeof(XkbAction));
            if (map->acts == NULL) {
                free(prev_acts);
                map->num_acts = map->size_acts = 0;
                return BadAlloc;
            }
            map->size_acts = need;
            memset(&map->acts[map->num_acts], 0,
                   ((map->size_acts - map->num_acts) * sizeof(XkbAction)));
        }
        if (map->key_acts == NULL) {
            i = xkb->max_key_code + 1;
            map->key_acts = calloc(i, sizeof(unsigned short));
            if (map->key_acts == NULL)
                return BadAlloc;
        }
    }
    if (which & XkbKeyBehaviorsMask) {
        if ((!XkbIsLegalKeycode(xkb->min_key_code)) ||
            (!XkbIsLegalKeycode(xkb->max_key_code)) ||
            (xkb->max_key_code < xkb->min_key_code))
            return BadMatch;
        if (map->behaviors == NULL) {
            i = xkb->max_key_code + 1;
            map->behaviors = calloc(i, sizeof(XkbBehavior));
            if (map->behaviors == NULL)
                return BadAlloc;
        }
    }
    if (which & XkbVirtualModMapMask) {
        if ((!XkbIsLegalKeycode(xkb->min_key_code)) ||
            (!XkbIsLegalKeycode(xkb->max_key_code)) ||
            (xkb->max_key_code < xkb->min_key_code))
            return BadMatch;
        if (map->vmodmap == NULL) {
            i = xkb->max_key_code + 1;
            map->vmodmap = calloc(i, sizeof(unsigned short));
            if (map->vmodmap == NULL)
                return BadAlloc;
        }
    }
    return Success;
}

/***====================================================================***/

static Status
XkbCopyKeyType(XkbKeyTypePtr from, XkbKeyTypePtr into)
{
    if ((!from) || (!into))
        return BadMatch;
    free(into->map);
    into->map = NULL;
    free(into->preserve);
    into->preserve = NULL;
    free(into->level_names);
    into->level_names = NULL;
    *into = *from;
    if ((from->map) && (into->map_count > 0)) {
        into->map = calloc(into->map_count, sizeof(XkbKTMapEntryRec));
        if (!into->map)
            return BadAlloc;
        memcpy(into->map, from->map,
               into->map_count * sizeof(XkbKTMapEntryRec));
    }
    if ((from->preserve) && (into->map_count > 0)) {
        into->preserve = calloc(into->map_count, sizeof(XkbModsRec));
        if (!into->preserve)
            return BadAlloc;
        memcpy(into->preserve, from->preserve,
               into->map_count * sizeof(XkbModsRec));
    }
    if ((from->level_names) && (into->num_levels > 0)) {
        into->level_names = calloc(into->num_levels, sizeof(Atom));
        if (!into->level_names)
            return BadAlloc;
        memcpy(into->level_names, from->level_names,
               into->num_levels * sizeof(Atom));
    }
    return Success;
}

Status
XkbCopyKeyTypes(XkbKeyTypePtr from, XkbKeyTypePtr into, int num_types)
{
    register int i, rtrn;

    if ((!from) || (!into) || (num_types < 0))
        return BadMatch;
    for (i = 0; i < num_types; i++) {
        if ((rtrn = XkbCopyKeyType(from++, into++)) != Success)
            return rtrn;
    }
    return Success;
}

Status
XkbResizeKeyType(XkbDescPtr xkb,
                 int type_ndx,
                 int map_count, Bool want_preserve, int new_num_lvls)
{
    XkbKeyTypePtr type;
    KeyCode matchingKeys[XkbMaxKeyCount], nMatchingKeys;

    if ((type_ndx < 0) || (type_ndx >= xkb->map->num_types) || (map_count < 0)
        || (new_num_lvls < 1))
        return BadValue;
    switch (type_ndx) {
    case XkbOneLevelIndex:
        if (new_num_lvls != 1)
            return BadMatch;
        break;
    case XkbTwoLevelIndex:
    case XkbAlphabeticIndex:
    case XkbKeypadIndex:
        if (new_num_lvls != 2)
            return BadMatch;
        break;
    }
    type = &xkb->map->types[type_ndx];
    if (map_count == 0) {
        free(type->map);
        type->map = NULL;
        free(type->preserve);
        type->preserve = NULL;
        type->map_count = 0;
    }
    else {
        XkbKTMapEntryRec *prev_map = type->map;

        if ((map_count > type->map_count) || (type->map == NULL))
            type->map =
                reallocarray(type->map, map_count, sizeof(XkbKTMapEntryRec));
        if (!type->map) {
            free(prev_map);
            return BadAlloc;
        }
        if (want_preserve) {
            XkbModsRec *prev_preserve = type->preserve;

            if ((map_count > type->map_count) || (type->preserve == NULL)) {
                type->preserve = reallocarray(type->preserve,
                                              map_count, sizeof(XkbModsRec));
            }
            if (!type->preserve) {
                free(prev_preserve);
                return BadAlloc;
            }
        }
        else {
            free(type->preserve);
            type->preserve = NULL;
        }
        type->map_count = map_count;
    }

    if ((new_num_lvls > type->num_levels) || (type->level_names == NULL)) {
        Atom *prev_level_names = type->level_names;

        type->level_names = reallocarray(type->level_names,
                                         new_num_lvls, sizeof(Atom));
        if (!type->level_names) {
            free(prev_level_names);
            return BadAlloc;
        }
    }
    /*
     * Here's the theory:
     *    If the width of the type changed, we might have to resize the symbol
     * maps for any keys that use the type for one or more groups.  This is
     * expensive, so we'll try to cull out any keys that are obviously okay:
     * In any case:
     *    - keys that have a group width <= the old width are okay (because
     *      they could not possibly have been associated with the old type)
     * If the key type increased in size:
     *    - keys that already have a group width >= to the new width are okay
     *    + keys that have a group width >= the old width but < the new width
     *      might have to be enlarged.
     * If the key type decreased in size:
     *    - keys that have a group width > the old width don't have to be
     *      resized (because they must have some other wider type associated
     *      with some group).
     *    + keys that have a group width == the old width might have to be
     *      shrunk.
     * The possibilities marked with '+' require us to examine the key types
     * associated with each group for the key.
     */
    memset(matchingKeys, 0, XkbMaxKeyCount * sizeof(KeyCode));
    nMatchingKeys = 0;
    if (new_num_lvls > type->num_levels) {
        int nTotal;
        KeySym *newSyms;
        int width, match, nResize;
        register int i, g, nSyms;

        nResize = 0;
        for (nTotal = 1, i = xkb->min_key_code; i <= xkb->max_key_code; i++) {
            width = XkbKeyGroupsWidth(xkb, i);
            if (width < type->num_levels || width >= new_num_lvls) {
                nTotal += XkbKeyNumSyms(xkb,i);
                continue;
            }
            for (match = 0, g = XkbKeyNumGroups(xkb, i) - 1;
                 (g >= 0) && (!match); g--) {
                if (XkbKeyKeyTypeIndex(xkb, i, g) == type_ndx) {
                    matchingKeys[nMatchingKeys++] = i;
                    match = 1;
                }
            }
            if (!match)
                nTotal += XkbKeyNumSyms(xkb, i);
            else {
                nTotal += XkbKeyNumGroups(xkb, i) * new_num_lvls;
                nResize++;
            }
        }
        if (nResize > 0) {
            int nextMatch;

            xkb->map->size_syms = (nTotal * 15) / 10;
            newSyms = calloc(xkb->map->size_syms, sizeof(KeySym));
            if (newSyms == NULL)
                return BadAlloc;
            nextMatch = 0;
            nSyms = 1;
            for (i = xkb->min_key_code; i <= xkb->max_key_code; i++) {
                if (matchingKeys[nextMatch] == i) {
                    KeySym *pOld;

                    nextMatch++;
                    width = XkbKeyGroupsWidth(xkb, i);
                    pOld = XkbKeySymsPtr(xkb, i);
                    for (g = XkbKeyNumGroups(xkb, i) - 1; g >= 0; g--) {
                        memcpy(&newSyms[nSyms + (new_num_lvls * g)],
                               &pOld[width * g], width * sizeof(KeySym));
                    }
                    xkb->map->key_sym_map[i].offset = nSyms;
                    nSyms += XkbKeyNumGroups(xkb, i) * new_num_lvls;
                }
                else {
                    memcpy(&newSyms[nSyms], XkbKeySymsPtr(xkb, i),
                           XkbKeyNumSyms(xkb, i) * sizeof(KeySym));
                    xkb->map->key_sym_map[i].offset = nSyms;
                    nSyms += XkbKeyNumSyms(xkb, i);
                }
            }
            type->num_levels = new_num_lvls;
            free(xkb->map->syms);
            xkb->map->syms = newSyms;
            xkb->map->num_syms = nSyms;
            return Success;
        }
    }
    else if (new_num_lvls < type->num_levels) {
        int width, match;
        register int g, i;

        for (i = xkb->min_key_code; i <= xkb->max_key_code; i++) {
            width = XkbKeyGroupsWidth(xkb, i);
            if (width < type->num_levels)
                continue;
            for (match = 0, g = XkbKeyNumGroups(xkb, i) - 1;
                 (g >= 0) && (!match); g--) {
                if (XkbKeyKeyTypeIndex(xkb, i, g) == type_ndx) {
                    matchingKeys[nMatchingKeys++] = i;
                    match = 1;
                }
            }
        }
    }
    if (nMatchingKeys > 0) {
        int key, firstClear;
        register int i, g;

        if (new_num_lvls > type->num_levels)
            firstClear = type->num_levels;
        else
            firstClear = new_num_lvls;
        for (i = 0; i < nMatchingKeys; i++) {
            KeySym *pSyms;
            int width, nClear;

            key = matchingKeys[i];
            width = XkbKeyGroupsWidth(xkb, key);
            nClear = width - firstClear;
            pSyms = XkbKeySymsPtr(xkb, key);
            for (g = XkbKeyNumGroups(xkb, key) - 1; g >= 0; g--) {
                if (XkbKeyKeyTypeIndex(xkb, key, g) == type_ndx) {
                    if (nClear > 0)
                        memset(&pSyms[g * width + firstClear], 0,
                               nClear * sizeof(KeySym));
                }
            }
        }
    }
    type->num_levels = new_num_lvls;
    return Success;
}

KeySym *
XkbResizeKeySyms(XkbDescPtr xkb, int key, int needed)
{
    register int i, nSyms, nKeySyms;
    unsigned nOldSyms;
    KeySym *newSyms;

    if (needed == 0) {
        xkb->map->key_sym_map[key].offset = 0;
        return xkb->map->syms;
    }
    nOldSyms = XkbKeyNumSyms(xkb, key);
    if (nOldSyms >= (unsigned) needed) {
        return XkbKeySymsPtr(xkb, key);
    }
    if (xkb->map->size_syms - xkb->map->num_syms >= (unsigned) needed) {
        if (nOldSyms > 0) {
            memcpy(&xkb->map->syms[xkb->map->num_syms], XkbKeySymsPtr(xkb, key),
                   nOldSyms * sizeof(KeySym));
        }
        if ((needed - nOldSyms) > 0) {
            memset(&xkb->map->
                   syms[xkb->map->num_syms + XkbKeyNumSyms(xkb, key)], 0,
                   (needed - nOldSyms) * sizeof(KeySym));
        }
        xkb->map->key_sym_map[key].offset = xkb->map->num_syms;
        xkb->map->num_syms += needed;
        return &xkb->map->syms[xkb->map->key_sym_map[key].offset];
    }
    xkb->map->size_syms += (needed > 32 ? needed : 32);
    newSyms = calloc(xkb->map->size_syms, sizeof(KeySym));
    if (newSyms == NULL)
        return NULL;
    newSyms[0] = NoSymbol;
    nSyms = 1;
    for (i = xkb->min_key_code; i <= (int) xkb->max_key_code; i++) {
        int nCopy;

        nCopy = nKeySyms = XkbKeyNumSyms(xkb, i);
        if ((nKeySyms == 0) && (i != key))
            continue;
        if (i == key)
            nKeySyms = needed;
        if (nCopy != 0)
            memcpy(&newSyms[nSyms], XkbKeySymsPtr(xkb, i),
                   nCopy * sizeof(KeySym));
        if (nKeySyms > nCopy)
            memset(&newSyms[nSyms + nCopy], 0,
                   (nKeySyms - nCopy) * sizeof(KeySym));
        xkb->map->key_sym_map[i].offset = nSyms;
        nSyms += nKeySyms;
    }
    free(xkb->map->syms);
    xkb->map->syms = newSyms;
    xkb->map->num_syms = nSyms;
    return &xkb->map->syms[xkb->map->key_sym_map[key].offset];
}

static unsigned
_ExtendRange(unsigned int old_flags,
             unsigned int flag,
             KeyCode newKC, KeyCode *old_min, unsigned char *old_num)
{
    if ((old_flags & flag) == 0) {
        old_flags |= flag;
        *old_min = newKC;
        *old_num = 1;
    }
    else {
        int last = (*old_min) + (*old_num) - 1;

        if (newKC < *old_min) {
            *old_min = newKC;
            *old_num = (last - newKC) + 1;
        }
        else if (newKC > last) {
            *old_num = (newKC - (*old_min)) + 1;
        }
    }
    return old_flags;
}

Status
XkbChangeKeycodeRange(XkbDescPtr xkb,
                      int minKC, int maxKC, XkbChangesPtr changes)
{
    int tmp;

    if ((!xkb) || (minKC < XkbMinLegalKeyCode) || (maxKC > XkbMaxLegalKeyCode))
        return BadValue;
    if (minKC > maxKC)
        return BadMatch;
    if (minKC < xkb->min_key_code) {
        if (changes)
            changes->map.min_key_code = minKC;
        tmp = xkb->min_key_code - minKC;
        if (xkb->map) {
            if (xkb->map->key_sym_map) {
                memset((char *) &xkb->map->key_sym_map[minKC], 0,
                       tmp * sizeof(XkbSymMapRec));
                if (changes) {
                    changes->map.changed = _ExtendRange(changes->map.changed,
                                                        XkbKeySymsMask, minKC,
                                                        &changes->map.
                                                        first_key_sym,
                                                        &changes->map.
                                                        num_key_syms);
                }
            }
            if (xkb->map->modmap) {
                memset((char *) &xkb->map->modmap[minKC], 0, tmp);
                if (changes) {
                    changes->map.changed = _ExtendRange(changes->map.changed,
                                                        XkbModifierMapMask,
                                                        minKC,
                                                        &changes->map.
                                                        first_modmap_key,
                                                        &changes->map.
                                                        num_modmap_keys);
                }
            }
        }
        if (xkb->server) {
            if (xkb->server->behaviors) {
                memset((char *) &xkb->server->behaviors[minKC], 0,
                       tmp * sizeof(XkbBehavior));
                if (changes) {
                    changes->map.changed = _ExtendRange(changes->map.changed,
                                                        XkbKeyBehaviorsMask,
                                                        minKC,
                                                        &changes->map.
                                                        first_key_behavior,
                                                        &changes->map.
                                                        num_key_behaviors);
                }
            }
            if (xkb->server->key_acts) {
                memset((char *) &xkb->server->key_acts[minKC], 0,
                       tmp * sizeof(unsigned short));
                if (changes) {
                    changes->map.changed = _ExtendRange(changes->map.changed,
                                                        XkbKeyActionsMask,
                                                        minKC,
                                                        &changes->map.
                                                        first_key_act,
                                                        &changes->map.
                                                        num_key_acts);
                }
            }
            if (xkb->server->vmodmap) {
                memset((char *) &xkb->server->vmodmap[minKC], 0,
                       tmp * sizeof(unsigned short));
                if (changes) {
                    changes->map.changed = _ExtendRange(changes->map.changed,
                                                        XkbVirtualModMapMask,
                                                        minKC,
                                                        &changes->map.
                                                        first_modmap_key,
                                                        &changes->map.
                                                        num_vmodmap_keys);
                }
            }
        }
        if ((xkb->names) && (xkb->names->keys)) {
            memset((char *) &xkb->names->keys[minKC], 0,
                   tmp * sizeof(XkbKeyNameRec));
            if (changes) {
                changes->names.changed = _ExtendRange(changes->names.changed,
                                                      XkbKeyNamesMask, minKC,
                                                      &changes->names.first_key,
                                                      &changes->names.num_keys);
            }
        }
        xkb->min_key_code = minKC;
    }
    if (maxKC > xkb->max_key_code) {
        if (changes)
            changes->map.max_key_code = maxKC;
        tmp = maxKC - xkb->max_key_code;
        if (xkb->map) {
            if (xkb->map->key_sym_map) {
                XkbSymMapRec *prev_key_sym_map = xkb->map->key_sym_map;

                xkb->map->key_sym_map = reallocarray(xkb->map->key_sym_map,
                                                     maxKC + 1,
                                                     sizeof(XkbSymMapRec));
                if (!xkb->map->key_sym_map) {
                    free(prev_key_sym_map);
                    return BadAlloc;
                }
                memset((char *) &xkb->map->key_sym_map[xkb->max_key_code], 0,
                       tmp * sizeof(XkbSymMapRec));
                if (changes) {
                    changes->map.changed = _ExtendRange(changes->map.changed,
                                                        XkbKeySymsMask, maxKC,
                                                        &changes->map.
                                                        first_key_sym,
                                                        &changes->map.
                                                        num_key_syms);
                }
            }
            if (xkb->map->modmap) {
                unsigned char *prev_modmap = xkb->map->modmap;

                xkb->map->modmap = reallocarray(xkb->map->modmap,
                                                maxKC + 1,
                                                sizeof(unsigned char));
                if (!xkb->map->modmap) {
                    free(prev_modmap);
                    return BadAlloc;
                }
                memset((char *) &xkb->map->modmap[xkb->max_key_code], 0, tmp);
                if (changes) {
                    changes->map.changed = _ExtendRange(changes->map.changed,
                                                        XkbModifierMapMask,
                                                        maxKC,
                                                        &changes->map.
                                                        first_modmap_key,
                                                        &changes->map.
                                                        num_modmap_keys);
                }
            }
        }
        if (xkb->server) {
            if (xkb->server->behaviors) {
                XkbBehavior *prev_behaviors = xkb->server->behaviors;

                xkb->server->behaviors = reallocarray(xkb->server->behaviors,
                                                      maxKC + 1,
                                                      sizeof(XkbBehavior));
                if (!xkb->server->behaviors) {
                    free(prev_behaviors);
                    return BadAlloc;
                }
                memset((char *) &xkb->server->behaviors[xkb->max_key_code], 0,
                       tmp * sizeof(XkbBehavior));
                if (changes) {
                    changes->map.changed = _ExtendRange(changes->map.changed,
                                                        XkbKeyBehaviorsMask,
                                                        maxKC,
                                                        &changes->map.
                                                        first_key_behavior,
                                                        &changes->map.
                                                        num_key_behaviors);
                }
            }
            if (xkb->server->key_acts) {
                unsigned short *prev_key_acts = xkb->server->key_acts;

                xkb->server->key_acts = reallocarray(xkb->server->key_acts,
                                                     maxKC + 1,
                                                     sizeof(unsigned short));
                if (!xkb->server->key_acts) {
                    free(prev_key_acts);
                    return BadAlloc;
                }
                memset((char *) &xkb->server->key_acts[xkb->max_key_code], 0,
                       tmp * sizeof(unsigned short));
                if (changes) {
                    changes->map.changed = _ExtendRange(changes->map.changed,
                                                        XkbKeyActionsMask,
                                                        maxKC,
                                                        &changes->map.
                                                        first_key_act,
                                                        &changes->map.
                                                        num_key_acts);
                }
            }
            if (xkb->server->vmodmap) {
                unsigned short *prev_vmodmap = xkb->server->vmodmap;

                xkb->server->vmodmap = reallocarray(xkb->server->vmodmap,
                                                    maxKC + 1,
                                                    sizeof(unsigned short));
                if (!xkb->server->vmodmap) {
                    free(prev_vmodmap);
                    return BadAlloc;
                }
                memset((char *) &xkb->server->vmodmap[xkb->max_key_code], 0,
                       tmp * sizeof(unsigned short));
                if (changes) {
                    changes->map.changed = _ExtendRange(changes->map.changed,
                                                        XkbVirtualModMapMask,
                                                        maxKC,
                                                        &changes->map.
                                                        first_modmap_key,
                                                        &changes->map.
                                                        num_vmodmap_keys);
                }
            }
        }
        if ((xkb->names) && (xkb->names->keys)) {
            XkbKeyNameRec *prev_keys = xkb->names->keys;

            xkb->names->keys = reallocarray(xkb->names->keys,
                                            maxKC + 1, sizeof(XkbKeyNameRec));
            if (!xkb->names->keys) {
                free(prev_keys);
                return BadAlloc;
            }
            memset((char *) &xkb->names->keys[xkb->max_key_code], 0,
                   tmp * sizeof(XkbKeyNameRec));
            if (changes) {
                changes->names.changed = _ExtendRange(changes->names.changed,
                                                      XkbKeyNamesMask, maxKC,
                                                      &changes->names.first_key,
                                                      &changes->names.num_keys);
            }
        }
        xkb->max_key_code = maxKC;
    }
    return Success;
}

XkbAction *
XkbResizeKeyActions(XkbDescPtr xkb, int key, int needed)
{
    register int i, nActs;
    XkbAction *newActs;

    if (needed == 0) {
        xkb->server->key_acts[key] = 0;
        return NULL;
    }
    if (XkbKeyHasActions(xkb, key) &&
        (XkbKeyNumSyms(xkb, key) >= (unsigned) needed))
        return XkbKeyActionsPtr(xkb, key);
    if (xkb->server->size_acts - xkb->server->num_acts >= (unsigned) needed) {
        xkb->server->key_acts[key] = xkb->server->num_acts;
        xkb->server->num_acts += needed;
        return &xkb->server->acts[xkb->server->key_acts[key]];
    }
    xkb->server->size_acts = xkb->server->num_acts + needed + 8;
    newActs = calloc(xkb->server->size_acts, sizeof(XkbAction));
    if (newActs == NULL)
        return NULL;
    newActs[0].type = XkbSA_NoAction;
    nActs = 1;
    for (i = xkb->min_key_code; i <= (int) xkb->max_key_code; i++) {
        int nKeyActs, nCopy;

        if ((xkb->server->key_acts[i] == 0) && (i != key))
            continue;

        nCopy = nKeyActs = XkbKeyNumActions(xkb, i);
        if (i == key) {
            nKeyActs = needed;
            if (needed < nCopy)
                nCopy = needed;
        }

        if (nCopy > 0)
            memcpy(&newActs[nActs], XkbKeyActionsPtr(xkb, i),
                   nCopy * sizeof(XkbAction));
        if (nCopy < nKeyActs)
            memset(&newActs[nActs + nCopy], 0,
                   (nKeyActs - nCopy) * sizeof(XkbAction));
        xkb->server->key_acts[i] = nActs;
        nActs += nKeyActs;
    }
    free(xkb->server->acts);
    xkb->server->acts = newActs;
    xkb->server->num_acts = nActs;
    return &xkb->server->acts[xkb->server->key_acts[key]];
}

void
XkbFreeClientMap(XkbDescPtr xkb, unsigned what, Bool freeMap)
{
    XkbClientMapPtr map;

    if ((xkb == NULL) || (xkb->map == NULL))
        return;
    if (freeMap)
        what = XkbAllClientInfoMask;
    map = xkb->map;
    if (what & XkbKeyTypesMask) {
        if (map->types != NULL) {
            if (map->num_types > 0) {
                register int i;
                XkbKeyTypePtr type;

                for (i = 0, type = map->types; i < map->num_types; i++, type++) {
                    free(type->map);
                    type->map = NULL;
                    free(type->preserve);
                    type->preserve = NULL;
                    type->map_count = 0;
                    free(type->level_names);
                    type->level_names = NULL;
                }
            }
            free(map->types);
            map->num_types = map->size_types = 0;
            map->types = NULL;
        }
    }
    if (what & XkbKeySymsMask) {
        free(map->key_sym_map);
        map->key_sym_map = NULL;
        if (map->syms != NULL) {
            free(map->syms);
            map->size_syms = map->num_syms = 0;
            map->syms = NULL;
        }
    }
    if ((what & XkbModifierMapMask) && (map->modmap != NULL)) {
        free(map->modmap);
        map->modmap = NULL;
    }
    if (freeMap) {
        free(xkb->map);
        xkb->map = NULL;
    }
    return;
}

void
XkbFreeServerMap(XkbDescPtr xkb, unsigned what, Bool freeMap)
{
    XkbServerMapPtr map;

    if ((xkb == NULL) || (xkb->server == NULL))
        return;
    if (freeMap)
        what = XkbAllServerInfoMask;
    map = xkb->server;
    if ((what & XkbExplicitComponentsMask) && (map->explicit != NULL)) {
        free(map->explicit);
        map->explicit = NULL;
    }
    if (what & XkbKeyActionsMask) {
        free(map->key_acts);
        map->key_acts = NULL;
        if (map->acts != NULL) {
            free(map->acts);
            map->num_acts = map->size_acts = 0;
            map->acts = NULL;
        }
    }
    if ((what & XkbKeyBehaviorsMask) && (map->behaviors != NULL)) {
        free(map->behaviors);
        map->behaviors = NULL;
    }
    if ((what & XkbVirtualModMapMask) && (map->vmodmap != NULL)) {
        free(map->vmodmap);
        map->vmodmap = NULL;
    }

    if (freeMap) {
        free(xkb->server);
        xkb->server = NULL;
    }
    return;
}
@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d83 1
a83 1
                realloc(map->types, nTotalTypes * sizeof(XkbKeyTypeRec));
d180 1
a180 1
            map->acts = realloc(map->acts, need * sizeof(XkbAction));
d312 1
a312 1
                realloc(type->map, map_count * sizeof(XkbKTMapEntryRec));
d321 2
a322 2
                type->preserve = realloc(type->preserve,
                                         map_count * sizeof(XkbModsRec));
d339 2
a340 2
        type->level_names = realloc(type->level_names,
                                    new_num_lvls * sizeof(Atom));
d662 3
a664 3
                xkb->map->key_sym_map = realloc(xkb->map->key_sym_map,
                                                (maxKC +
                                                 1) * sizeof(XkbSymMapRec));
d683 3
a685 2
                xkb->map->modmap = realloc(xkb->map->modmap,
                                           (maxKC + 1) * sizeof(unsigned char));
d706 3
a708 3
                xkb->server->behaviors = realloc(xkb->server->behaviors,
                                                 (maxKC +
                                                  1) * sizeof(XkbBehavior));
d728 3
a730 3
                xkb->server->key_acts = realloc(xkb->server->key_acts,
                                                (maxKC +
                                                 1) * sizeof(unsigned short));
d750 3
a752 3
                xkb->server->vmodmap = realloc(xkb->server->vmodmap,
                                               (maxKC +
                                                1) * sizeof(unsigned short));
d773 2
a774 2
            xkb->names->keys = realloc(xkb->names->keys,
                                       (maxKC + 1) * sizeof(XkbKeyNameRec));
@


1.7
log
@Update to xserver 1.12.3.
@
text
@d9 2
a10 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d12 1
a12 1
Silicon Graphics makes no representation about the suitability 
d16 2
a17 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d19 3
a21 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
d360 1
a360 1
     *      resized (because they must have some other wider type associated 
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d378 2
a379 1
            if (width < type->num_levels)
d381 1
d389 1
a389 1
            if ((!match) || (width >= new_num_lvls))
@


1.5
log
@Update to xserver 1.11.2
@
text
@d45 1
a45 1
XkbAllocClientMap(XkbDescPtr xkb,unsigned which,unsigned nTotalTypes)
d47 2
a48 2
register int	i;
XkbClientMapPtr map;
d50 7
a56 6
    if ((xkb==NULL)||((nTotalTypes>0)&&(nTotalTypes<XkbNumRequiredTypes)))
	return BadValue;
    if ((which&XkbKeySymsMask)&&
	((!XkbIsLegalKeycode(xkb->min_key_code))||
	 (!XkbIsLegalKeycode(xkb->max_key_code))||
	 (xkb->max_key_code<xkb->min_key_code))) {
d58 2
a59 2
				xkb->min_key_code,xkb->max_key_code);
	return BadValue;
d62 64
a125 60
    if (xkb->map==NULL) {
	map= calloc(1, sizeof(XkbClientMapRec));
	if (map==NULL)
	    return BadAlloc;
	xkb->map= map;
    }
    else map= xkb->map;

    if ((which&XkbKeyTypesMask)&&(nTotalTypes>0)) {
	if (map->types==NULL) {
	    map->types= calloc(nTotalTypes, sizeof(XkbKeyTypeRec));
	    if (map->types==NULL)
		return BadAlloc;
	    map->num_types= 0;
	    map->size_types= nTotalTypes;
	}
	else if (map->size_types<nTotalTypes) {
	    XkbKeyTypeRec *prev_types = map->types;

	    map->types= realloc(map->types,nTotalTypes * sizeof(XkbKeyTypeRec));
	    if (map->types==NULL) {
		free(prev_types);
		map->num_types= map->size_types= 0;
		return BadAlloc;
	    }
	    map->size_types= nTotalTypes;
	    memset(&map->types[map->num_types], 0,
		  ((map->size_types-map->num_types)*sizeof(XkbKeyTypeRec)));
	}
    }
    if (which&XkbKeySymsMask) {
	int nKeys= XkbNumKeys(xkb);
	if (map->syms==NULL) {
	    map->size_syms= (nKeys*15)/10;
	    map->syms= calloc(map->size_syms, sizeof(KeySym));
	    if (!map->syms) {
		map->size_syms= 0;
		return BadAlloc;
	    }
	    map->num_syms= 1;
	    map->syms[0]= NoSymbol;
	}
	if (map->key_sym_map==NULL) {
	    i= xkb->max_key_code+1;
	    map->key_sym_map= calloc(i, sizeof(XkbSymMapRec));
	    if (map->key_sym_map==NULL)
		return BadAlloc;
	}
    }
    if (which&XkbModifierMapMask) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code))
	    return BadMatch;
	if (map->modmap==NULL) {
	    i= xkb->max_key_code+1;
	    map->modmap= calloc(i, sizeof(unsigned char));
	    if (map->modmap==NULL)
		return BadAlloc;
	}
d131 1
a131 1
XkbAllocServerMap(XkbDescPtr xkb,unsigned which,unsigned nNewActions)
d133 2
a134 2
register int	i;
XkbServerMapPtr map;
d136 84
a219 82
    if (xkb==NULL)
	return BadMatch;
    if (xkb->server==NULL) {
	map= calloc(1, sizeof(XkbServerMapRec));
	if (map==NULL)
	    return BadAlloc;
	for (i=0;i<XkbNumVirtualMods;i++) {
	    map->vmods[i]= XkbNoModifierMask;
	}
	xkb->server= map;
    }
    else map= xkb->server;
    if (which&XkbExplicitComponentsMask) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code))
	    return BadMatch;
	if (map->explicit==NULL) {
	    i= xkb->max_key_code+1;
	    map->explicit= calloc(i, sizeof(unsigned char));
	    if (map->explicit==NULL)
		return BadAlloc;
	}
    }
    if (which&XkbKeyActionsMask) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code))
	    return BadMatch;
        if (nNewActions<1)
	    nNewActions= 1;
	if (map->acts==NULL) {
	    map->acts= calloc((nNewActions+1), sizeof(XkbAction));
	    if (map->acts==NULL)
		return BadAlloc;
	    map->num_acts= 1;
	    map->size_acts= nNewActions+1;
	}
	else if ((map->size_acts-map->num_acts)<nNewActions) {
	    unsigned need;
	    XkbAction *prev_acts = map->acts;
	    need= map->num_acts+nNewActions;
	    map->acts= realloc(map->acts,need * sizeof(XkbAction));
	    if (map->acts==NULL) {
		free(prev_acts);
	        map->num_acts= map->size_acts= 0;
	        return BadAlloc;
	    }
	    map->size_acts= need;
	    memset(&map->acts[map->num_acts], 0,
		    ((map->size_acts-map->num_acts)*sizeof(XkbAction)));
	}
	if (map->key_acts==NULL) {
	    i= xkb->max_key_code+1;
	    map->key_acts= calloc(i, sizeof(unsigned short));
	    if (map->key_acts==NULL)
		return BadAlloc;
	}
    }
    if (which&XkbKeyBehaviorsMask) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code))
	    return BadMatch;
	if (map->behaviors==NULL) {
	    i= xkb->max_key_code+1;
	    map->behaviors= calloc(i, sizeof(XkbBehavior));
	    if (map->behaviors==NULL)
		return BadAlloc;
	}
    }
    if (which&XkbVirtualModMapMask) {
	if ((!XkbIsLegalKeycode(xkb->min_key_code))||
	    (!XkbIsLegalKeycode(xkb->max_key_code))||
	    (xkb->max_key_code<xkb->min_key_code))
	    return BadMatch;
	if (map->vmodmap==NULL) {
	    i= xkb->max_key_code+1;
	    map->vmodmap= calloc(i, sizeof(unsigned short));
	    if (map->vmodmap==NULL)
		return BadAlloc;
	}
d227 1
a227 1
XkbCopyKeyType(XkbKeyTypePtr from,XkbKeyTypePtr into)
d229 2
a230 2
    if ((!from)||(!into))
	return BadMatch;
d237 21
a257 20
    *into= *from;
    if ((from->map)&&(into->map_count>0)) {
	into->map= calloc(into->map_count, sizeof(XkbKTMapEntryRec));
	if (!into->map)
	    return BadAlloc;
	memcpy(into->map,from->map,into->map_count*sizeof(XkbKTMapEntryRec));
    }
    if ((from->preserve)&&(into->map_count>0)) {
	into->preserve= calloc(into->map_count, sizeof(XkbModsRec));
	if (!into->preserve)
	    return BadAlloc;
	memcpy(into->preserve,from->preserve,
				into->map_count*sizeof(XkbModsRec));
    }
    if ((from->level_names)&&(into->num_levels>0)) {
	into->level_names= calloc(into->num_levels, sizeof(Atom));
	if (!into->level_names)
	    return BadAlloc;
	memcpy(into->level_names,from->level_names,
				 into->num_levels*sizeof(Atom));
d263 1
a263 1
XkbCopyKeyTypes(XkbKeyTypePtr from,XkbKeyTypePtr into,int num_types)
d265 1
a265 1
register int i,rtrn;
d267 5
a271 5
    if ((!from)||(!into)||(num_types<0))
	return BadMatch;
    for (i=0;i<num_types;i++) {
	if ((rtrn= XkbCopyKeyType(from++,into++))!=Success)
	    return rtrn;
d277 10
a286 12
XkbResizeKeyType(	XkbDescPtr	xkb,
			int		type_ndx,
			int		map_count,
			Bool		want_preserve,
			int		new_num_lvls)
{
XkbKeyTypePtr	type;
KeyCode		matchingKeys[XkbMaxKeyCount],nMatchingKeys;

    if ((type_ndx<0)||(type_ndx>=xkb->map->num_types)||(map_count<0)||
    							(new_num_lvls<1))
	return BadValue;
d288 18
a305 18
	case XkbOneLevelIndex:
	    if (new_num_lvls!=1)
		return BadMatch;
	    break;
	case XkbTwoLevelIndex:
	case XkbAlphabeticIndex:
	case XkbKeypadIndex:
	    if (new_num_lvls!=2)
		return BadMatch;
	    break;
    }
    type= &xkb->map->types[type_ndx];
    if (map_count==0) {
	free(type->map);
	type->map= NULL;
	free(type->preserve);
	type->preserve= NULL;
	type->map_count= 0;
d308 1
a308 1
	XkbKTMapEntryRec *prev_map = type->map;
d310 35
a344 34
	if ((map_count>type->map_count)||(type->map==NULL))
	    type->map = realloc(type->map,map_count * sizeof(XkbKTMapEntryRec));
	if (!type->map) {
	    free(prev_map);
	    return BadAlloc;
	}
	if (want_preserve) {
	    XkbModsRec *prev_preserve = type->preserve;

	    if ((map_count>type->map_count)||(type->preserve==NULL)) {
		type->preserve = realloc(type->preserve,
					  map_count * sizeof(XkbModsRec));
	    }
	    if (!type->preserve) {
		free(prev_preserve);
		return BadAlloc;
	    }
	}
	else {
	    free(type->preserve);
	    type->preserve = NULL;
	}
	type->map_count= map_count;
    }

    if ((new_num_lvls>type->num_levels)||(type->level_names==NULL)) {
	Atom * prev_level_names = type->level_names;

	type->level_names = realloc(type->level_names,
				     new_num_lvls * sizeof(Atom));
	if (!type->level_names) {
	    free(prev_level_names);
	    return BadAlloc;
	}
d367 105
a471 97
    memset(matchingKeys, 0, XkbMaxKeyCount*sizeof(KeyCode));
    nMatchingKeys= 0;
    if (new_num_lvls>type->num_levels) {
	int	 		nTotal;
	KeySym	*		newSyms;
	int			width,match,nResize;
	register int		i,g,nSyms;

	nResize= 0;
	for (nTotal=1,i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	    width= XkbKeyGroupsWidth(xkb,i);
	    if (width<type->num_levels)
		continue;
	    for (match=0,g=XkbKeyNumGroups(xkb,i)-1;(g>=0)&&(!match);g--) {
		if (XkbKeyKeyTypeIndex(xkb,i,g)==type_ndx) {
		    matchingKeys[nMatchingKeys++]= i;
		    match= 1;
		}
	    }
	    if ((!match)||(width>=new_num_lvls))
		nTotal+= XkbKeyNumSyms(xkb,i);
	    else {
		nTotal+= XkbKeyNumGroups(xkb,i)*new_num_lvls;
		nResize++;
	    }
	}
	if (nResize>0) {
	    int nextMatch;
	    xkb->map->size_syms= (nTotal*15)/10;
	    newSyms = calloc(xkb->map->size_syms, sizeof(KeySym));
	    if (newSyms==NULL)
		return BadAlloc;
	    nextMatch= 0;
	    nSyms= 1;
	    for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
		if (matchingKeys[nextMatch]==i) {
		    KeySym *pOld;
		    nextMatch++;
		    width= XkbKeyGroupsWidth(xkb,i);
		    pOld= XkbKeySymsPtr(xkb,i);
		    for (g=XkbKeyNumGroups(xkb,i)-1;g>=0;g--) {
			memcpy(&newSyms[nSyms+(new_num_lvls*g)],&pOld[width*g],
							width*sizeof(KeySym));
		    }
		    xkb->map->key_sym_map[i].offset= nSyms;
		    nSyms+= XkbKeyNumGroups(xkb,i)*new_num_lvls;
		}
		else {
		    memcpy(&newSyms[nSyms],XkbKeySymsPtr(xkb,i),
					XkbKeyNumSyms(xkb,i)*sizeof(KeySym));
		    xkb->map->key_sym_map[i].offset= nSyms;
		    nSyms+= XkbKeyNumSyms(xkb,i);
		}
	    }
	    type->num_levels= new_num_lvls;
	    free(xkb->map->syms);
	    xkb->map->syms= newSyms;
	    xkb->map->num_syms= nSyms;
	    return Success;
	}
    }
    else if (new_num_lvls<type->num_levels) {
	int 		width,match;
	register int	g,i;
	for (i=xkb->min_key_code;i<=xkb->max_key_code;i++) {
	    width= XkbKeyGroupsWidth(xkb,i);
	    if (width<type->num_levels)
		continue;
	    for (match=0,g=XkbKeyNumGroups(xkb,i)-1;(g>=0)&&(!match);g--) {
		if (XkbKeyKeyTypeIndex(xkb,i,g)==type_ndx) {
		    matchingKeys[nMatchingKeys++]= i;
		    match= 1;
		}
	    }
	}
    }
    if (nMatchingKeys>0) {
	int 		key,firstClear;
	register int	i,g;
	if (new_num_lvls>type->num_levels)
	     firstClear= type->num_levels;
	else firstClear= new_num_lvls;
	for (i=0;i<nMatchingKeys;i++) {
	    KeySym *	pSyms;
	    int		width,nClear;

	    key= matchingKeys[i];
	    width= XkbKeyGroupsWidth(xkb,key);
	    nClear= width-firstClear;
	    pSyms= XkbKeySymsPtr(xkb,key);
	    for (g=XkbKeyNumGroups(xkb,key)-1;g>=0;g--) {
		if (XkbKeyKeyTypeIndex(xkb,key,g)==type_ndx) {
		    if (nClear>0)
			memset(&pSyms[g*width+firstClear], 0, nClear*sizeof(KeySym));
		}
	    }
	}
d473 1
a473 1
    type->num_levels= new_num_lvls;
d478 1
a478 1
XkbResizeKeySyms(XkbDescPtr xkb,int key,int needed)
d480 25
a504 24
register int i,nSyms,nKeySyms;
unsigned nOldSyms;
KeySym	*newSyms;

    if (needed==0) {
	xkb->map->key_sym_map[key].offset= 0;
	return xkb->map->syms;
    }
    nOldSyms= XkbKeyNumSyms(xkb,key);
    if (nOldSyms>=(unsigned)needed) {
	return XkbKeySymsPtr(xkb,key);
    }
    if (xkb->map->size_syms-xkb->map->num_syms>=(unsigned)needed) {
	if (nOldSyms>0) {
	    memcpy(&xkb->map->syms[xkb->map->num_syms],XkbKeySymsPtr(xkb,key),
						nOldSyms*sizeof(KeySym));
	}
	if ((needed-nOldSyms)>0) {
	    memset(&xkb->map->syms[xkb->map->num_syms+XkbKeyNumSyms(xkb, key)],
                   0, (needed-nOldSyms)*sizeof(KeySym));
	}
	xkb->map->key_sym_map[key].offset = xkb->map->num_syms;
	xkb->map->num_syms+= needed;
	return &xkb->map->syms[xkb->map->key_sym_map[key].offset];
d506 1
a506 1
    xkb->map->size_syms+= (needed>32?needed:32);
d508 3
a510 3
    if (newSyms==NULL)
	return NULL;
    newSyms[0]= NoSymbol;
d512 2
a513 2
    for (i=xkb->min_key_code;i<=(int)xkb->max_key_code;i++) {
	int nCopy;
d515 13
a527 11
	nCopy= nKeySyms= XkbKeyNumSyms(xkb,i);
	if ((nKeySyms==0)&&(i!=key))
	    continue;
	if (i==key)
	    nKeySyms= needed;
	if (nCopy!=0)
	   memcpy(&newSyms[nSyms],XkbKeySymsPtr(xkb,i),nCopy*sizeof(KeySym));
	if (nKeySyms>nCopy)
	    memset(&newSyms[nSyms+nCopy], 0, (nKeySyms-nCopy)*sizeof(KeySym));
	xkb->map->key_sym_map[i].offset = nSyms;
	nSyms+= nKeySyms;
d536 8
a543 10
_ExtendRange(	unsigned int 	old_flags,
		unsigned int	flag,
		KeyCode		newKC,
		KeyCode *	old_min,
		unsigned char *	old_num)
{
    if ((old_flags&flag)==0) {
	old_flags|= flag;
	*old_min= newKC;
	*old_num= 1;
d546 9
a554 8
	int	last= (*old_min)+(*old_num)-1;
	if (newKC<*old_min) {
	    *old_min= newKC;
	    *old_num= (last-newKC)+1;
	}
	else if (newKC>last) {
	    *old_num= (newKC-(*old_min))+1;
	}
d560 226
a785 195
XkbChangeKeycodeRange(	XkbDescPtr	xkb,
			int 		minKC,
			int 		maxKC,
			XkbChangesPtr	changes)
{
int	tmp;

    if ((!xkb)||(minKC<XkbMinLegalKeyCode)||(maxKC>XkbMaxLegalKeyCode))
	return BadValue;
    if (minKC>maxKC)
	return BadMatch;
    if (minKC<xkb->min_key_code) {
	if (changes)
	    changes->map.min_key_code= minKC;
	tmp= xkb->min_key_code-minKC;
	if (xkb->map)  {
	    if (xkb->map->key_sym_map) {
		memset((char *)&xkb->map->key_sym_map[minKC], 0,
					tmp*sizeof(XkbSymMapRec));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    				XkbKeySymsMask,minKC,
	    					&changes->map.first_key_sym,
	    					&changes->map.num_key_syms);
		}
	    }
	    if (xkb->map->modmap) {
		memset((char *)&xkb->map->modmap[minKC], 0, tmp);
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    				XkbModifierMapMask,minKC,
	    					&changes->map.first_modmap_key,
	    					&changes->map.num_modmap_keys);
		}
	    }
	}
	if (xkb->server) {
	    if (xkb->server->behaviors) {
		memset((char *)&xkb->server->behaviors[minKC], 0,
						tmp*sizeof(XkbBehavior));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbKeyBehaviorsMask,minKC,
    					&changes->map.first_key_behavior,
    					&changes->map.num_key_behaviors);
		}
	    }
	    if (xkb->server->key_acts) {
		memset((char *)&xkb->server->key_acts[minKC], 0,
						tmp*sizeof(unsigned short));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbKeyActionsMask,minKC,
    					&changes->map.first_key_act,
    					&changes->map.num_key_acts);
		}
	    }
	    if (xkb->server->vmodmap) {
		memset((char *)&xkb->server->vmodmap[minKC], 0,
						tmp*sizeof(unsigned short));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbVirtualModMapMask,minKC,
		    			&changes->map.first_modmap_key,
    					&changes->map.num_vmodmap_keys);
		}
	    }
	}
	if ((xkb->names)&&(xkb->names->keys)) {
	    memset((char *)&xkb->names->keys[minKC], 0, tmp*sizeof(XkbKeyNameRec));
	    if (changes) {
		changes->names.changed= _ExtendRange(changes->names.changed,
					XkbKeyNamesMask,minKC,
					&changes->names.first_key,
    					&changes->names.num_keys);
	    }
	}
	xkb->min_key_code= minKC;
    }
    if (maxKC>xkb->max_key_code) {
	if (changes)
	    changes->map.max_key_code= maxKC;
	tmp= maxKC-xkb->max_key_code;
	if (xkb->map)  {
	    if (xkb->map->key_sym_map) {
		XkbSymMapRec *prev_key_sym_map = xkb->map->key_sym_map;

		xkb->map->key_sym_map = realloc(xkb->map->key_sym_map,
						(maxKC+1) * sizeof(XkbSymMapRec));
		if (!xkb->map->key_sym_map) {
		    free(prev_key_sym_map);
		    return BadAlloc;
		}
		memset((char *)&xkb->map->key_sym_map[xkb->max_key_code], 0,
					tmp*sizeof(XkbSymMapRec));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    				XkbKeySymsMask,maxKC,
	    					&changes->map.first_key_sym,
	    					&changes->map.num_key_syms);
		}
	    }
	    if (xkb->map->modmap) {
		unsigned char *prev_modmap = xkb->map->modmap;

		xkb->map->modmap = realloc(xkb->map->modmap,
					    (maxKC+1) * sizeof(unsigned char));
		if (!xkb->map->modmap) {
		    free(prev_modmap);
		    return BadAlloc;
		}
		memset((char *)&xkb->map->modmap[xkb->max_key_code], 0, tmp);
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    				XkbModifierMapMask,maxKC,
	    					&changes->map.first_modmap_key,
	    					&changes->map.num_modmap_keys);
		}
	    }
	}
	if (xkb->server) {
	    if (xkb->server->behaviors) {
		XkbBehavior *prev_behaviors = xkb->server->behaviors;

		xkb->server->behaviors = realloc(xkb->server->behaviors,
						(maxKC+1) * sizeof(XkbBehavior));
		if (!xkb->server->behaviors) {
		    free(prev_behaviors);
		    return BadAlloc;
		}
		memset((char *)&xkb->server->behaviors[xkb->max_key_code], 0,
						tmp*sizeof(XkbBehavior));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbKeyBehaviorsMask,maxKC,
    					&changes->map.first_key_behavior,
    					&changes->map.num_key_behaviors);
		}
	    }
	    if (xkb->server->key_acts) {
		unsigned short *prev_key_acts = xkb->server->key_acts;

		xkb->server->key_acts= realloc(xkb->server->key_acts,
						(maxKC+1) * sizeof(unsigned short));
		if (!xkb->server->key_acts) {
		    free(prev_key_acts);
		    return BadAlloc;
		}
		memset((char *)&xkb->server->key_acts[xkb->max_key_code], 0,
						tmp*sizeof(unsigned short));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbKeyActionsMask,maxKC,
    					&changes->map.first_key_act,
    					&changes->map.num_key_acts);
		}
	    }
	    if (xkb->server->vmodmap) {
		unsigned short *prev_vmodmap = xkb->server->vmodmap;

		xkb->server->vmodmap= realloc(xkb->server->vmodmap,
						(maxKC+1) * sizeof(unsigned short));
		if (!xkb->server->vmodmap) {
		    free(prev_vmodmap);
		    return BadAlloc;
		}
		memset((char *)&xkb->server->vmodmap[xkb->max_key_code], 0,
						tmp*sizeof(unsigned short));
		if (changes) {
		    changes->map.changed= _ExtendRange(changes->map.changed,
		    			XkbVirtualModMapMask,maxKC,
		    			&changes->map.first_modmap_key,
    					&changes->map.num_vmodmap_keys);
		}
	    }
	}
	if ((xkb->names)&&(xkb->names->keys)) {
	    XkbKeyNameRec *prev_keys = xkb->names->keys;

	    xkb->names->keys = realloc(xkb->names->keys,
					(maxKC+1) * sizeof(XkbKeyNameRec));
	    if (!xkb->names->keys) {
		free(prev_keys);
		return BadAlloc;
	    }
	    memset((char *)&xkb->names->keys[xkb->max_key_code], 0,
	    					tmp*sizeof(XkbKeyNameRec));
	    if (changes) {
		changes->names.changed= _ExtendRange(changes->names.changed,
					XkbKeyNamesMask,maxKC,
					&changes->names.first_key,
    					&changes->names.num_keys);
	    }
	}
	xkb->max_key_code= maxKC;
d791 1
a791 1
XkbResizeKeyActions(XkbDescPtr xkb,int key,int needed)
d793 2
a794 2
register int i,nActs;
XkbAction *newActs;
d796 11
a806 10
    if (needed==0) {
	xkb->server->key_acts[key]= 0;
	return NULL;
    }
    if (XkbKeyHasActions(xkb,key)&&(XkbKeyNumSyms(xkb,key)>=(unsigned)needed))
	return XkbKeyActionsPtr(xkb,key);
    if (xkb->server->size_acts-xkb->server->num_acts>=(unsigned)needed) {
	xkb->server->key_acts[key]= xkb->server->num_acts;
	xkb->server->num_acts+= needed;
	return &xkb->server->acts[xkb->server->key_acts[key]];
d808 1
a808 1
    xkb->server->size_acts= xkb->server->num_acts+needed+8;
d810 2
a811 2
    if (newActs==NULL)
	return NULL;
d814 2
a815 2
    for (i=xkb->min_key_code;i<=(int)xkb->max_key_code;i++) {
	int nKeyActs,nCopy;
d817 2
a818 2
	if ((xkb->server->key_acts[i]==0)&&(i!=key))
	    continue;
d820 15
a834 14
	nCopy= nKeyActs= XkbKeyNumActions(xkb,i);
	if (i==key) {
	    nKeyActs= needed;
	    if (needed<nCopy)
		nCopy= needed;
	}

	if (nCopy>0)
	    memcpy(&newActs[nActs],XkbKeyActionsPtr(xkb,i),
						nCopy*sizeof(XkbAction));
	if (nCopy<nKeyActs)
	    memset(&newActs[nActs+nCopy], 0, (nKeyActs-nCopy)*sizeof(XkbAction));
	xkb->server->key_acts[i]= nActs;
	nActs+= nKeyActs;
d838 1
a838 1
    xkb->server->num_acts= nActs;
d843 1
a843 1
XkbFreeClientMap(XkbDescPtr xkb,unsigned what,Bool freeMap)
d845 1
a845 1
XkbClientMapPtr	map;
d847 2
a848 2
    if ((xkb==NULL)||(xkb->map==NULL))
	return;
d850 35
a884 34
	what= XkbAllClientInfoMask;
    map= xkb->map;
    if (what&XkbKeyTypesMask) {
	if (map->types!=NULL) {
	    if (map->num_types>0) {
		register int 	i;
		XkbKeyTypePtr	type;
		for (i=0,type=map->types;i<map->num_types;i++,type++) {
		    free(type->map);
		    type->map = NULL;
		    free(type->preserve);
		    type->preserve = NULL;
		    type->map_count= 0;
		    free(type->level_names);
		    type->level_names = NULL;
		}
	    }
	    free(map->types);
	    map->num_types= map->size_types= 0;
	    map->types= NULL;
	}
    }
    if (what&XkbKeySymsMask) {
	free(map->key_sym_map);
	map->key_sym_map = NULL;
	if (map->syms!=NULL) {
	    free(map->syms);
	    map->size_syms= map->num_syms= 0;
	    map->syms= NULL;
	}
    }
    if ((what&XkbModifierMapMask)&&(map->modmap!=NULL)) {
	free(map->modmap);
	map->modmap= NULL;
d887 2
a888 2
	free(xkb->map);
	xkb->map= NULL;
d894 1
a894 1
XkbFreeServerMap(XkbDescPtr xkb,unsigned what,Bool freeMap)
d896 1
a896 1
XkbServerMapPtr	map;
d898 2
a899 2
    if ((xkb==NULL)||(xkb->server==NULL))
	return;
d901 22
a922 22
	what= XkbAllServerInfoMask;
    map= xkb->server;
    if ((what&XkbExplicitComponentsMask)&&(map->explicit!=NULL)) {
	free(map->explicit);
	map->explicit= NULL;
    }
    if (what&XkbKeyActionsMask) {
	free(map->key_acts);
	map->key_acts = NULL;
	if (map->acts!=NULL) {
	    free(map->acts);
	    map->num_acts= map->size_acts= 0;
	    map->acts= NULL;
	}
    }
    if ((what&XkbKeyBehaviorsMask)&&(map->behaviors!=NULL)) {
	free(map->behaviors);
	map->behaviors= NULL;
    }
    if ((what&XkbVirtualModMapMask)&&(map->vmodmap!=NULL)) {
	free(map->vmodmap);
	map->vmodmap= NULL;
d926 2
a927 2
	free(xkb->server);
	xkb->server= NULL;
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d295 1
a295 2
	if (type->map!=NULL)
	    free(type->map);
d297 1
a297 2
	if (type->preserve!=NULL)
	    free(type->preserve);
d322 1
a322 1
	else if (type->preserve!=NULL) {
d324 1
a324 1
	    type->preserve= NULL;
d808 4
a811 8
		    if (type->map!=NULL) {
			free(type->map);
			type->map= NULL;
		    }
		    if (type->preserve!=NULL) {
			free(type->preserve);
			type->preserve= NULL;
		    }
d813 2
a814 4
		    if (type->level_names!=NULL) {
			free(type->level_names);
			type->level_names= NULL;
		    }
d823 2
a824 4
	if (map->key_sym_map!=NULL) {
	    free(map->key_sym_map);
	    map->key_sym_map= NULL;
	}
d857 2
a858 4
	if (map->key_acts!=NULL) {
	    free(map->key_acts);
	    map->key_acts= NULL;
	}
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d62 1
a62 1
	map= xcalloc(1, sizeof(XkbClientMapRec));
d71 1
a71 1
	    map->types= xcalloc(nTotalTypes, sizeof(XkbKeyTypeRec));
d80 1
a80 1
	    map->types= xrealloc(map->types,nTotalTypes * sizeof(XkbKeyTypeRec));
d82 1
a82 1
		xfree(prev_types);
d87 1
a87 1
	    bzero(&map->types[map->num_types], 
d95 1
a95 1
	    map->syms= xcalloc(map->size_syms, sizeof(KeySym));
d105 1
a105 1
	    map->key_sym_map= xcalloc(i, sizeof(XkbSymMapRec));
d117 1
a117 1
	    map->modmap= xcalloc(i, sizeof(unsigned char));
d134 1
a134 1
	map= xcalloc(1, sizeof(XkbServerMapRec));
d150 1
a150 1
	    map->explicit= xcalloc(i, sizeof(unsigned char));
d163 1
a163 1
	    map->acts= xcalloc((nNewActions+1), sizeof(XkbAction));
d173 1
a173 1
	    map->acts= xrealloc(map->acts,need * sizeof(XkbAction));
d175 1
a175 1
		xfree(prev_acts);
d180 1
a180 1
	    bzero(&map->acts[map->num_acts], 
d185 1
a185 1
	    map->key_acts= xcalloc(i, sizeof(unsigned short));
d197 1
a197 1
	    map->behaviors= xcalloc(i, sizeof(XkbBehavior));
d209 1
a209 1
	    map->vmodmap= xcalloc(i, sizeof(unsigned short));
d224 6
a229 12
    if (into->map) {
	xfree(into->map);
	into->map= NULL;
    }
    if (into->preserve) {
	xfree(into->preserve);
	into->preserve= NULL;
    }
    if (into->level_names) {
	xfree(into->level_names);
	into->level_names= NULL;
    }
d232 1
a232 1
	into->map= xcalloc(into->map_count, sizeof(XkbKTMapEntryRec));
d238 1
a238 1
	into->preserve= xcalloc(into->map_count, sizeof(XkbModsRec));
d245 1
a245 1
	into->level_names= xcalloc(into->num_levels, sizeof(Atom));
d296 1
a296 1
	    xfree(type->map);
d299 1
a299 1
	    xfree(type->preserve);
d307 1
a307 1
	    type->map = xrealloc(type->map,map_count * sizeof(XkbKTMapEntryRec));
d309 1
a309 2
	    if (prev_map) 
		xfree(prev_map);
d316 1
a316 1
		type->preserve = xrealloc(type->preserve,
d320 1
a320 2
		if (prev_preserve) 
		    xfree(prev_preserve);
d325 1
a325 1
	    xfree(type->preserve);
d334 1
a334 1
	type->level_names = xrealloc(type->level_names,
d337 1
a337 2
	    if (prev_level_names) 
		xfree(prev_level_names);
d362 1
a362 1
    bzero(matchingKeys,XkbMaxKeyCount*sizeof(KeyCode));
d391 1
a391 1
	    newSyms = xcalloc(xkb->map->size_syms, sizeof(KeySym));
d417 1
a417 1
	    xfree(xkb->map->syms);
d455 1
a455 1
			bzero(&pSyms[g*width+firstClear],nClear*sizeof(KeySym));
d485 2
a486 2
	    bzero(&xkb->map->syms[xkb->map->num_syms+XkbKeyNumSyms(xkb,key)],
					(needed-nOldSyms)*sizeof(KeySym));
d493 1
a493 1
    newSyms = xcalloc(xkb->map->size_syms, sizeof(KeySym));
d509 1
a509 1
	    bzero(&newSyms[nSyms+nCopy],(nKeySyms-nCopy)*sizeof(KeySym));
d513 1
a513 1
    xfree(xkb->map->syms);
d562 1
a562 1
		bzero((char *)&xkb->map->key_sym_map[minKC],
d572 1
a572 1
		bzero((char *)&xkb->map->modmap[minKC],tmp);
d583 1
a583 1
		bzero((char *)&xkb->server->behaviors[minKC],
d593 1
a593 1
		bzero((char *)&xkb->server->key_acts[minKC],
d603 1
a603 1
		bzero((char *)&xkb->server->vmodmap[minKC],
d614 1
a614 1
	    bzero((char *)&xkb->names->keys[minKC],tmp*sizeof(XkbKeyNameRec));
d632 1
a632 1
		xkb->map->key_sym_map = xrealloc(xkb->map->key_sym_map,
d635 1
a635 1
		    xfree(prev_key_sym_map);
d638 1
a638 1
		bzero((char *)&xkb->map->key_sym_map[xkb->max_key_code],
d650 1
a650 1
		xkb->map->modmap = xrealloc(xkb->map->modmap,
d653 1
a653 1
		    xfree(prev_modmap);
d656 1
a656 1
		bzero((char *)&xkb->map->modmap[xkb->max_key_code],tmp);
d669 1
a669 1
		xkb->server->behaviors = xrealloc(xkb->server->behaviors,
d672 1
a672 1
		    xfree(prev_behaviors);
d675 1
a675 1
		bzero((char *)&xkb->server->behaviors[xkb->max_key_code],
d687 1
a687 1
		xkb->server->key_acts= xrealloc(xkb->server->key_acts,
d690 1
a690 1
		    xfree(prev_key_acts);
d693 1
a693 1
		bzero((char *)&xkb->server->key_acts[xkb->max_key_code],
d705 1
a705 1
		xkb->server->vmodmap= xrealloc(xkb->server->vmodmap,
d708 1
a708 1
		    xfree(prev_vmodmap);
d711 1
a711 1
		bzero((char *)&xkb->server->vmodmap[xkb->max_key_code],
d724 1
a724 1
	    xkb->names->keys = xrealloc(xkb->names->keys,
d727 1
a727 1
		xfree(prev_keys);
d730 1
a730 1
	    bzero((char *)&xkb->names->keys[xkb->max_key_code],
d762 1
a762 1
    newActs = xcalloc(xkb->server->size_acts, sizeof(XkbAction));
d784 1
a784 1
	    bzero(&newActs[nActs+nCopy],(nKeyActs-nCopy)*sizeof(XkbAction));
d788 1
a788 1
    xfree(xkb->server->acts);
d811 1
a811 1
			xfree(type->map);
d815 1
a815 1
			xfree(type->preserve);
d820 1
a820 1
			xfree(type->level_names);
d825 1
a825 1
	    xfree(map->types);
d832 1
a832 1
	    xfree(map->key_sym_map);
d836 1
a836 1
	    xfree(map->syms);
d842 1
a842 1
	xfree(map->modmap);
d846 1
a846 1
	xfree(xkb->map);
d863 1
a863 1
	xfree(map->explicit);
d868 1
a868 1
	    xfree(map->key_acts);
d872 1
a872 1
	    xfree(map->acts);
d878 1
a878 1
	xfree(map->behaviors);
d882 1
a882 1
	xfree(map->vmodmap);
d887 1
a887 1
	xfree(xkb->server);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a34 2
#define	NEED_EVENTS
#define	NEED_REPLIES
d62 1
a62 1
	map= _XkbTypedCalloc(1,XkbClientMapRec);
d71 1
a71 1
	    map->types= _XkbTypedCalloc(nTotalTypes,XkbKeyTypeRec);
d80 1
a80 1
	    map->types= _XkbTypedRealloc(map->types,nTotalTypes,XkbKeyTypeRec);
d82 1
a82 1
		_XkbFree(prev_types);
d95 1
a95 1
	    map->syms= _XkbTypedCalloc(map->size_syms,KeySym);
d105 1
a105 1
	    map->key_sym_map= _XkbTypedCalloc(i,XkbSymMapRec);
d117 1
a117 1
	    map->modmap= _XkbTypedCalloc(i,unsigned char);
d134 1
a134 1
	map= _XkbTypedCalloc(1,XkbServerMapRec);
d150 1
a150 1
	    map->explicit= _XkbTypedCalloc(i,unsigned char);
d163 1
a163 1
	    map->acts= _XkbTypedCalloc((nNewActions+1),XkbAction);
d173 1
a173 1
	    map->acts= _XkbTypedRealloc(map->acts,need,XkbAction);
d175 1
a175 1
		_XkbFree(prev_acts);
d185 1
a185 1
	    map->key_acts= _XkbTypedCalloc(i,unsigned short);
d197 1
a197 1
	    map->behaviors= _XkbTypedCalloc(i,XkbBehavior);
d209 1
a209 1
	    map->vmodmap= _XkbTypedCalloc(i,unsigned short);
d225 1
a225 1
	_XkbFree(into->map);
d229 1
a229 1
	_XkbFree(into->preserve);
d233 1
a233 1
	_XkbFree(into->level_names);
d238 1
a238 1
	into->map= _XkbTypedCalloc(into->map_count,XkbKTMapEntryRec);
d244 1
a244 1
	into->preserve= _XkbTypedCalloc(into->map_count,XkbModsRec);
d251 1
a251 1
	into->level_names= _XkbTypedCalloc(into->num_levels,Atom);
d302 1
a302 1
	    _XkbFree(type->map);
d305 1
a305 1
	    _XkbFree(type->preserve);
d313 1
a313 1
	    type->map=_XkbTypedRealloc(type->map,map_count,XkbKTMapEntryRec);
d316 1
a316 1
		_XkbFree(prev_map);
d323 2
a324 2
		type->preserve= _XkbTypedRealloc(type->preserve,map_count,
	     						    XkbModsRec);
d328 1
a328 1
		    _XkbFree(prev_preserve);
d333 1
a333 1
	    _XkbFree(type->preserve);
d342 2
a343 1
	type->level_names=_XkbTypedRealloc(type->level_names,new_num_lvls,Atom);
d346 1
a346 1
		_XkbFree(prev_level_names);
d400 1
a400 1
	    newSyms = _XkbTypedCalloc(xkb->map->size_syms,KeySym);
d426 1
a426 1
	    _XkbFree(xkb->map->syms);
d502 1
a502 1
    newSyms = _XkbTypedCalloc(xkb->map->size_syms,KeySym);
d522 1
a522 1
    _XkbFree(xkb->map->syms);
d641 2
a642 2
		xkb->map->key_sym_map= _XkbTypedRealloc(xkb->map->key_sym_map,
						(maxKC+1),XkbSymMapRec);
d644 1
a644 1
		    _XkbFree(prev_key_sym_map);
d659 2
a660 2
		xkb->map->modmap= _XkbTypedRealloc(xkb->map->modmap,
						(maxKC+1),unsigned char);
d662 1
a662 1
		    _XkbFree(prev_modmap);
d678 2
a679 2
		xkb->server->behaviors=_XkbTypedRealloc(xkb->server->behaviors,
						(maxKC+1),XkbBehavior);
d681 1
a681 1
		    _XkbFree(prev_behaviors);
d696 2
a697 2
		xkb->server->key_acts= _XkbTypedRealloc(xkb->server->key_acts,
						(maxKC+1),unsigned short);
d699 1
a699 1
		    _XkbFree(prev_key_acts);
d714 2
a715 2
		xkb->server->vmodmap= _XkbTypedRealloc(xkb->server->vmodmap,
						(maxKC+1),unsigned short);
d717 1
a717 1
		    _XkbFree(prev_vmodmap);
d733 2
a734 2
	    xkb->names->keys= _XkbTypedRealloc(xkb->names->keys,
	    					(maxKC+1),XkbKeyNameRec);
d736 1
a736 1
		_XkbFree(prev_keys);
d771 1
a771 1
    newActs = _XkbTypedCalloc(xkb->server->size_acts,XkbAction);
d797 1
a797 1
    _XkbFree(xkb->server->acts);
d820 1
a820 1
			_XkbFree(type->map);
d824 1
a824 1
			_XkbFree(type->preserve);
d829 1
a829 1
			_XkbFree(type->level_names);
d834 1
a834 1
	    _XkbFree(map->types);
d841 1
a841 1
	    _XkbFree(map->key_sym_map);
d845 1
a845 1
	    _XkbFree(map->syms);
d851 1
a851 1
	_XkbFree(map->modmap);
d855 1
a855 1
	_XkbFree(xkb->map);
d872 1
a872 1
	_XkbFree(map->explicit);
d877 1
a877 1
	    _XkbFree(map->key_acts);
d881 1
a881 1
	    _XkbFree(map->acts);
d887 1
a887 1
	_XkbFree(map->behaviors);
d891 1
a891 1
	_XkbFree(map->vmodmap);
d896 1
a896 1
	_XkbFree(xkb->server);
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
#include <X11/extensions/XKBsrv.h>
d58 1
a58 2
#ifdef DEBUG
fprintf(stderr,"bad keycode (%d,%d) in XkbAllocClientMap\n",
a59 1
#endif
d221 1
a221 1
Status
a275 76
XkbKeyTypePtr
XkbAddKeyType(	XkbDescPtr	xkb,
		Atom 		name,
		int 		map_count,
		Bool 		want_preserve,
		int		num_lvls)
{
register int 	i;
unsigned	tmp;
XkbKeyTypePtr	type;
XkbClientMapPtr	map;

    if ((!xkb)||(num_lvls<1))
	return NULL;
    map= xkb->map;
    if ((map)&&(map->types)) {
	for (i=0;i<map->num_types;i++) {
	    if (map->types[i].name==name) {
		Status status;
		status=XkbResizeKeyType(xkb,i,map_count,want_preserve,num_lvls);
		return (status==Success?&map->types[i]:NULL);
	    }
	}
    }
    if ((!map)||(!map->types)||(!map->num_types<XkbNumRequiredTypes)) {
	tmp= XkbNumRequiredTypes+1;
	if (XkbAllocClientMap(xkb,XkbKeyTypesMask,tmp)!=Success)
	    return NULL;
        map = xkb->map;
	tmp= 0;
	if (map->num_types<=XkbKeypadIndex)
	    tmp|= XkbKeypadMask;
	if (map->num_types<=XkbAlphabeticIndex)
	    tmp|= XkbAlphabeticMask;
	if (map->num_types<=XkbTwoLevelIndex)
	    tmp|= XkbTwoLevelMask;
	if (map->num_types<=XkbOneLevelIndex)
	    tmp|= XkbOneLevelMask;
	if (XkbInitCanonicalKeyTypes(xkb,tmp,XkbNoModifier)==Success) {
	    for (i=0;i<map->num_types;i++) {
		Status status;
		if (map->types[i].name!=name)
		    continue;
		status=XkbResizeKeyType(xkb,i,map_count,want_preserve,num_lvls);
		return (status==Success?&map->types[i]:NULL);
	    }
	}
    }
    if ((map->num_types<=map->size_types)&&
	(XkbAllocClientMap(xkb,XkbKeyTypesMask,map->num_types+1)!=Success)) {
	return NULL;
    }
    type= &map->types[map->num_types];
    map->num_types++;
    bzero((char *)type,sizeof(XkbKeyTypeRec));
    type->num_levels=	num_lvls;
    type->map_count=	map_count;
    type->name=		name;
    if (map_count>0) {
	type->map=	_XkbTypedCalloc(map_count,XkbKTMapEntryRec);
	if (!type->map) {
	    map->num_types--;
	    return NULL;
	}
	if (want_preserve) {
	    type->preserve=	_XkbTypedCalloc(map_count,XkbModsRec);
	    if (!type->preserve) {
		_XkbFree(type->map);
		map->num_types--;
		return NULL;
	    }
	}
    }
    return type;
}

d400 1
a400 1
	    xkb->map->size_syms= (nTotal*12)/10;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d42 1
a42 1
#include <xkbsrv.h>
d223 1
a223 1
static Status
d278 76
d478 1
a478 1
	    xkb->map->size_syms= (nTotal*15)/10;
@

