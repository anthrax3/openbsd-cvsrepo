head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.6
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2013.06.07.17.28.56;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.05.18.11.38;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.32;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.11;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.27;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.30;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.13.21.06.49;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include "exglobals.h"
#include <X11/extensions/XIproto.h>
#include "inputstr.h"
#include "eventstr.h"
#include "inpututils.h"
#include <xkbsrv.h>
#if !defined(WIN32)
#include <sys/time.h>
#endif

int XkbDfltRepeatDelay = 660;
int XkbDfltRepeatInterval = 40;

#define	DFLT_TIMEOUT_CTRLS (XkbAX_KRGMask|XkbStickyKeysMask|XkbMouseKeysMask)
#define	DFLT_TIMEOUT_OPTS  (XkbAX_IndicatorFBMask)

unsigned short XkbDfltAccessXTimeout = 120;
unsigned int XkbDfltAccessXTimeoutMask = DFLT_TIMEOUT_CTRLS;
static unsigned int XkbDfltAccessXTimeoutValues = 0;
static unsigned int XkbDfltAccessXTimeoutOptionsMask = DFLT_TIMEOUT_OPTS;
static unsigned int XkbDfltAccessXTimeoutOptionsValues = 0;
unsigned int XkbDfltAccessXFeedback = XkbAccessXFeedbackMask;
unsigned short XkbDfltAccessXOptions =
    XkbAX_AllOptionsMask & ~(XkbAX_IndicatorFBMask | XkbAX_SKReleaseFBMask |
                             XkbAX_SKRejectFBMask);

void
AccessXComputeCurveFactor(XkbSrvInfoPtr xkbi, XkbControlsPtr ctrls)
{
    xkbi->mouseKeysCurve = 1.0 + (((double) ctrls->mk_curve) * 0.001);
    xkbi->mouseKeysCurveFactor = (((double) ctrls->mk_max_speed) /
                                  pow((double) ctrls->mk_time_to_max,
                                      xkbi->mouseKeysCurve));
    return;
}

void
AccessXInit(DeviceIntPtr keybd)
{
    XkbSrvInfoPtr xkbi = keybd->key->xkbInfo;
    XkbControlsPtr ctrls = xkbi->desc->ctrls;

    xkbi->shiftKeyCount = 0;
    xkbi->mouseKeysCounter = 0;
    xkbi->inactiveKey = 0;
    xkbi->slowKey = 0;
    xkbi->repeatKey = 0;
    xkbi->krgTimerActive = _OFF_TIMER;
    xkbi->beepType = _BEEP_NONE;
    xkbi->beepCount = 0;
    xkbi->mouseKeyTimer = NULL;
    xkbi->slowKeysTimer = NULL;
    xkbi->bounceKeysTimer = NULL;
    xkbi->repeatKeyTimer = NULL;
    xkbi->krgTimer = NULL;
    xkbi->beepTimer = NULL;
    ctrls->repeat_delay = XkbDfltRepeatDelay;
    ctrls->repeat_interval = XkbDfltRepeatInterval;
    ctrls->debounce_delay = 300;
    ctrls->slow_keys_delay = 300;
    ctrls->mk_delay = 160;
    ctrls->mk_interval = 40;
    ctrls->mk_time_to_max = 30;
    ctrls->mk_max_speed = 30;
    ctrls->mk_curve = 500;
    ctrls->mk_dflt_btn = 1;
    ctrls->ax_timeout = XkbDfltAccessXTimeout;
    ctrls->axt_ctrls_mask = XkbDfltAccessXTimeoutMask;
    ctrls->axt_ctrls_values = XkbDfltAccessXTimeoutValues;
    ctrls->axt_opts_mask = XkbDfltAccessXTimeoutOptionsMask;
    ctrls->axt_opts_values = XkbDfltAccessXTimeoutOptionsValues;
    if (XkbDfltAccessXTimeout)
        ctrls->enabled_ctrls |= XkbAccessXTimeoutMask;
    else
        ctrls->enabled_ctrls &= ~XkbAccessXTimeoutMask;
    ctrls->enabled_ctrls |= XkbDfltAccessXFeedback;
    ctrls->ax_options = XkbDfltAccessXOptions;
    AccessXComputeCurveFactor(xkbi, ctrls);
    return;
}

/************************************************************************/
/*									*/
/* AccessXKeyboardEvent							*/
/*									*/
/*	Generate a synthetic keyboard event.				*/
/*									*/
/************************************************************************/
static void
AccessXKeyboardEvent(DeviceIntPtr keybd, int type, BYTE keyCode, Bool isRepeat)
{
    DeviceEvent event;

    init_device_event(&event, keybd, GetTimeInMillis());
    event.type = type;
    event.detail.key = keyCode;
    event.key_repeat = isRepeat;

    if (xkbDebugFlags & 0x8) {
        DebugF("[xkb] AXKE: Key %d %s\n", keyCode,
               (event.type == ET_KeyPress ? "down" : "up"));
    }

    XkbProcessKeyboardEvent(&event, keybd);
    return;
}                               /* AccessXKeyboardEvent */

/************************************************************************/
/*									*/
/* AccessXKRGTurnOn							*/
/*									*/
/*	Turn the keyboard response group on.				*/
/*									*/
/************************************************************************/
static void
AccessXKRGTurnOn(DeviceIntPtr dev, CARD16 KRGControl, xkbControlsNotify * pCN)
{
    XkbSrvInfoPtr xkbi = dev->key->xkbInfo;
    XkbControlsPtr ctrls = xkbi->desc->ctrls;
    XkbControlsRec old;
    XkbEventCauseRec cause;
    XkbSrvLedInfoPtr sli;

    old = *ctrls;
    ctrls->enabled_ctrls |= (KRGControl & XkbAX_KRGMask);
    if (XkbComputeControlsNotify(dev, &old, ctrls, pCN, FALSE))
        XkbSendControlsNotify(dev, pCN);
    cause.kc = pCN->keycode;
    cause.event = pCN->eventType;
    cause.mjr = pCN->requestMajor;
    cause.mnr = pCN->requestMinor;
    sli = XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId, 0);
    XkbUpdateIndicators(dev, sli->usesControls, TRUE, NULL, &cause);
    if (XkbAX_NeedFeedback(ctrls, XkbAX_FeatureFBMask))
        XkbDDXAccessXBeep(dev, _BEEP_FEATURE_ON, KRGControl);
    return;

}                               /* AccessXKRGTurnOn */

/************************************************************************/
/*									*/
/* AccessXKRGTurnOff							*/
/*									*/
/*	Turn the keyboard response group off.				*/
/*									*/
/************************************************************************/
static void
AccessXKRGTurnOff(DeviceIntPtr dev, xkbControlsNotify * pCN)
{
    XkbSrvInfoPtr xkbi = dev->key->xkbInfo;
    XkbControlsPtr ctrls = xkbi->desc->ctrls;
    XkbControlsRec old;
    XkbEventCauseRec cause;
    XkbSrvLedInfoPtr sli;

    old = *ctrls;
    ctrls->enabled_ctrls &= ~XkbAX_KRGMask;
    if (XkbComputeControlsNotify(dev, &old, ctrls, pCN, FALSE))
        XkbSendControlsNotify(dev, pCN);
    cause.kc = pCN->keycode;
    cause.event = pCN->eventType;
    cause.mjr = pCN->requestMajor;
    cause.mnr = pCN->requestMinor;
    sli = XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId, 0);
    XkbUpdateIndicators(dev, sli->usesControls, TRUE, NULL, &cause);
    if (XkbAX_NeedFeedback(ctrls, XkbAX_FeatureFBMask)) {
        unsigned changes = old.enabled_ctrls ^ ctrls->enabled_ctrls;

        XkbDDXAccessXBeep(dev, _BEEP_FEATURE_OFF, changes);
    }
    return;

}                               /* AccessXKRGTurnOff */

/************************************************************************/
/*									*/
/* AccessXStickyKeysTurnOn						*/
/*									*/
/*	Turn StickyKeys on.						*/
/*									*/
/************************************************************************/
static void
AccessXStickyKeysTurnOn(DeviceIntPtr dev, xkbControlsNotify * pCN)
{
    XkbSrvInfoPtr xkbi = dev->key->xkbInfo;
    XkbControlsPtr ctrls = xkbi->desc->ctrls;
    XkbControlsRec old;
    XkbEventCauseRec cause;
    XkbSrvLedInfoPtr sli;

    old = *ctrls;
    ctrls->enabled_ctrls |= XkbStickyKeysMask;
    xkbi->shiftKeyCount = 0;
    if (XkbComputeControlsNotify(dev, &old, ctrls, pCN, FALSE))
        XkbSendControlsNotify(dev, pCN);
    cause.kc = pCN->keycode;
    cause.event = pCN->eventType;
    cause.mjr = pCN->requestMajor;
    cause.mnr = pCN->requestMinor;
    sli = XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId, 0);
    XkbUpdateIndicators(dev, sli->usesControls, TRUE, NULL, &cause);
    if (XkbAX_NeedFeedback(ctrls, XkbAX_FeatureFBMask)) {
        XkbDDXAccessXBeep(dev, _BEEP_FEATURE_ON, XkbStickyKeysMask);
    }
    return;

}                               /* AccessXStickyKeysTurnOn */

/************************************************************************/
/*									*/
/* AccessXStickyKeysTurnOff						*/
/*									*/
/*	Turn StickyKeys off.						*/
/*									*/
/************************************************************************/
static void
AccessXStickyKeysTurnOff(DeviceIntPtr dev, xkbControlsNotify * pCN)
{
    XkbSrvInfoPtr xkbi = dev->key->xkbInfo;
    XkbControlsPtr ctrls = xkbi->desc->ctrls;
    XkbControlsRec old;
    XkbEventCauseRec cause;
    XkbSrvLedInfoPtr sli;

    old = *ctrls;
    ctrls->enabled_ctrls &= ~XkbStickyKeysMask;
    xkbi->shiftKeyCount = 0;
    if (XkbComputeControlsNotify(dev, &old, ctrls, pCN, FALSE))
        XkbSendControlsNotify(dev, pCN);

    cause.kc = pCN->keycode;
    cause.event = pCN->eventType;
    cause.mjr = pCN->requestMajor;
    cause.mnr = pCN->requestMinor;
    sli = XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId, 0);
    XkbUpdateIndicators(dev, sli->usesControls, TRUE, NULL, &cause);
    if (XkbAX_NeedFeedback(ctrls, XkbAX_FeatureFBMask)) {
        XkbDDXAccessXBeep(dev, _BEEP_FEATURE_OFF, XkbStickyKeysMask);
    }
#ifndef NO_CLEAR_LATCHES_FOR_STICKY_KEYS_OFF
    XkbClearAllLatchesAndLocks(dev, xkbi, FALSE, &cause);
#endif
    return;
}                               /* AccessXStickyKeysTurnOff */

static CARD32
AccessXKRGExpire(OsTimerPtr timer, CARD32 now, void *arg)
{
    xkbControlsNotify cn;
    DeviceIntPtr dev = arg;
    XkbSrvInfoPtr xkbi = dev->key->xkbInfo;

    if (xkbi->krgTimerActive == _KRG_WARN_TIMER) {
        XkbDDXAccessXBeep(dev, _BEEP_SLOW_WARN, XkbStickyKeysMask);
        xkbi->krgTimerActive = _KRG_TIMER;
        return 4000;
    }
    xkbi->krgTimerActive = _OFF_TIMER;
    cn.keycode = xkbi->slowKeyEnableKey;
    cn.eventType = KeyPress;
    cn.requestMajor = 0;
    cn.requestMinor = 0;
    if (xkbi->desc->ctrls->enabled_ctrls & XkbSlowKeysMask) {
        AccessXKRGTurnOff(dev, &cn);
        LogMessage(X_INFO, "XKB SlowKeys are disabled.\n");
    }
    else {
        AccessXKRGTurnOn(dev, XkbSlowKeysMask, &cn);
        LogMessage(X_INFO, "XKB SlowKeys are now enabled. Hold shift to disable.\n");
    }

    xkbi->slowKeyEnableKey = 0;
    return 0;
}

static CARD32
AccessXRepeatKeyExpire(OsTimerPtr timer, CARD32 now, void *arg)
{
    DeviceIntPtr dev = (DeviceIntPtr) arg;
    XkbSrvInfoPtr xkbi = dev->key->xkbInfo;

    if (xkbi->repeatKey == 0)
        return 0;

    AccessXKeyboardEvent(dev, ET_KeyPress, xkbi->repeatKey, TRUE);

    return xkbi->desc->ctrls->repeat_interval;
}

void
AccessXCancelRepeatKey(XkbSrvInfoPtr xkbi, KeyCode key)
{
    if (xkbi->repeatKey == key)
        xkbi->repeatKey = 0;
    return;
}

static CARD32
AccessXSlowKeyExpire(OsTimerPtr timer, CARD32 now, void *arg)
{
    DeviceIntPtr keybd;
    XkbSrvInfoPtr xkbi;
    XkbDescPtr xkb;
    XkbControlsPtr ctrls;

    keybd = (DeviceIntPtr) arg;
    xkbi = keybd->key->xkbInfo;
    xkb = xkbi->desc;
    ctrls = xkb->ctrls;
    if (xkbi->slowKey != 0) {
        xkbAccessXNotify ev;
        KeySym *sym = XkbKeySymsPtr(xkb, xkbi->slowKey);

        ev.detail = XkbAXN_SKAccept;
        ev.keycode = xkbi->slowKey;
        ev.slowKeysDelay = ctrls->slow_keys_delay;
        ev.debounceDelay = ctrls->debounce_delay;
        XkbSendAccessXNotify(keybd, &ev);
        if (XkbAX_NeedFeedback(ctrls, XkbAX_SKAcceptFBMask))
            XkbDDXAccessXBeep(keybd, _BEEP_SLOW_ACCEPT, XkbSlowKeysMask);
        AccessXKeyboardEvent(keybd, ET_KeyPress, xkbi->slowKey, FALSE);
        /* check for magic sequences */
        if ((ctrls->enabled_ctrls & XkbAccessXKeysMask) &&
            ((sym[0] == XK_Shift_R) || (sym[0] == XK_Shift_L)))
            xkbi->shiftKeyCount++;

        /* Start repeating if necessary.  Stop autorepeating if the user
         * presses a non-modifier key that doesn't autorepeat.
         */
        if (keybd->kbdfeed->ctrl.autoRepeat &&
            ((xkbi->slowKey != xkbi->mouseKey) || (!xkbi->mouseKeysAccel)) &&
            (ctrls->enabled_ctrls & XkbRepeatKeysMask)) {
            if (BitIsOn(keybd->kbdfeed->ctrl.autoRepeats, xkbi->slowKey)) {
                xkbi->repeatKey = xkbi->slowKey;
                xkbi->repeatKeyTimer = TimerSet(xkbi->repeatKeyTimer,
                                                0, ctrls->repeat_delay,
                                                AccessXRepeatKeyExpire,
                                                (void *) keybd);
            }
        }
    }
    return 0;
}

static CARD32
AccessXBounceKeyExpire(OsTimerPtr timer, CARD32 now, void *arg)
{
    XkbSrvInfoPtr xkbi = ((DeviceIntPtr) arg)->key->xkbInfo;

    xkbi->inactiveKey = 0;
    return 0;
}

static CARD32
AccessXTimeoutExpire(OsTimerPtr timer, CARD32 now, void *arg)
{
    DeviceIntPtr dev = (DeviceIntPtr) arg;
    XkbSrvInfoPtr xkbi = dev->key->xkbInfo;
    XkbControlsPtr ctrls = xkbi->desc->ctrls;
    XkbControlsRec old;
    xkbControlsNotify cn;
    XkbEventCauseRec cause;
    XkbSrvLedInfoPtr sli;

    if (xkbi->lastPtrEventTime) {
        unsigned timeToWait = (ctrls->ax_timeout * 1000);
        unsigned timeElapsed = (now - xkbi->lastPtrEventTime);

        if (timeToWait > timeElapsed)
            return timeToWait - timeElapsed;
    }
    old = *ctrls;
    xkbi->shiftKeyCount = 0;
    ctrls->enabled_ctrls &= ~ctrls->axt_ctrls_mask;
    ctrls->enabled_ctrls |= (ctrls->axt_ctrls_values & ctrls->axt_ctrls_mask);
    if (ctrls->axt_opts_mask) {
        ctrls->ax_options &= ~ctrls->axt_opts_mask;
        ctrls->ax_options |= (ctrls->axt_opts_values & ctrls->axt_opts_mask);
    }
    if (XkbComputeControlsNotify(dev, &old, ctrls, &cn, FALSE)) {
        cn.keycode = 0;
        cn.eventType = 0;
        cn.requestMajor = 0;
        cn.requestMinor = 0;
        XkbSendControlsNotify(dev, &cn);
    }
    XkbSetCauseUnknown(&cause);
    sli = XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId, 0);
    XkbUpdateIndicators(dev, sli->usesControls, TRUE, NULL, &cause);
    if (ctrls->ax_options != old.ax_options) {
        unsigned set, cleared, bell;

        set = ctrls->ax_options & (~old.ax_options);
        cleared = (~ctrls->ax_options) & old.ax_options;
        if (set && cleared)
            bell = _BEEP_FEATURE_CHANGE;
        else if (set)
            bell = _BEEP_FEATURE_ON;
        else
            bell = _BEEP_FEATURE_OFF;
        XkbDDXAccessXBeep(dev, bell, XkbAccessXTimeoutMask);
    }
    xkbi->krgTimerActive = _OFF_TIMER;
    return 0;
}

/************************************************************************/
/*									*/
/* AccessXFilterPressEvent						*/
/*									*/
/* Filter events before they get any further if SlowKeys is turned on.	*/
/* In addition, this routine handles the ever so popular magic key	*/
/* acts for turning various accessibility features on/off.		*/
/*									*/
/* Returns TRUE if this routine has discarded the event.		*/
/* Returns FALSE if the event needs further processing.			*/
/*									*/
/************************************************************************/
Bool
AccessXFilterPressEvent(DeviceEvent *event, DeviceIntPtr keybd)
{
    XkbSrvInfoPtr xkbi = keybd->key->xkbInfo;
    XkbControlsPtr ctrls = xkbi->desc->ctrls;
    Bool ignoreKeyEvent = FALSE;
    KeyCode key = event->detail.key;
    KeySym *sym = XkbKeySymsPtr(xkbi->desc, key);

    if (ctrls->enabled_ctrls & XkbAccessXKeysMask) {
        /* check for magic sequences */
        if ((sym[0] == XK_Shift_R) || (sym[0] == XK_Shift_L)) {
            xkbi->slowKeyEnableKey = key;
            if (XkbAX_NeedFeedback(ctrls, XkbAX_SlowWarnFBMask)) {
                xkbi->krgTimerActive = _KRG_WARN_TIMER;
                xkbi->krgTimer = TimerSet(xkbi->krgTimer, 0, 4000,
                                          AccessXKRGExpire, (void *) keybd);
            }
            else {
                xkbi->krgTimerActive = _KRG_TIMER;
                xkbi->krgTimer = TimerSet(xkbi->krgTimer, 0, 8000,
                                          AccessXKRGExpire, (void *) keybd);
            }
            if (!(ctrls->enabled_ctrls & XkbSlowKeysMask)) {
                CARD32 now = GetTimeInMillis();

                if ((now - xkbi->lastShiftEventTime) > 15000)
                    xkbi->shiftKeyCount = 1;
                else
                    xkbi->shiftKeyCount++;
                xkbi->lastShiftEventTime = now;
            }
        }
        else {
            if (xkbi->krgTimerActive) {
                xkbi->krgTimer = TimerSet(xkbi->krgTimer, 0, 0, NULL, NULL);
                xkbi->krgTimerActive = _OFF_TIMER;
            }
        }
    }

    /* Don't transmit the KeyPress if SlowKeys is turned on;
     * The wakeup handler will synthesize one for us if the user
     * has held the key long enough.
     */
    if (ctrls->enabled_ctrls & XkbSlowKeysMask) {
        xkbAccessXNotify ev;

        /* If key was already pressed, ignore subsequent press events
         * from the server's autorepeat
         */
        if (xkbi->slowKey == key)
            return TRUE;
        ev.detail = XkbAXN_SKPress;
        ev.keycode = key;
        ev.slowKeysDelay = ctrls->slow_keys_delay;
        ev.debounceDelay = ctrls->debounce_delay;
        XkbSendAccessXNotify(keybd, &ev);
        if (XkbAX_NeedFeedback(ctrls, XkbAX_SKPressFBMask))
            XkbDDXAccessXBeep(keybd, _BEEP_SLOW_PRESS, XkbSlowKeysMask);
        xkbi->slowKey = key;
        xkbi->slowKeysTimer = TimerSet(xkbi->slowKeysTimer,
                                       0, ctrls->slow_keys_delay,
                                       AccessXSlowKeyExpire, (void *) keybd);
        ignoreKeyEvent = TRUE;
    }

    /* Don't transmit the KeyPress if BounceKeys is turned on
     * and the user pressed the same key within a given time period
     * from the last release.
     */
    else if ((ctrls->enabled_ctrls & XkbBounceKeysMask) &&
             (key == xkbi->inactiveKey)) {
        if (XkbAX_NeedFeedback(ctrls, XkbAX_BKRejectFBMask))
            XkbDDXAccessXBeep(keybd, _BEEP_BOUNCE_REJECT, XkbBounceKeysMask);
        ignoreKeyEvent = TRUE;
    }

    /* Start repeating if necessary.  Stop autorepeating if the user
     * presses a non-modifier key that doesn't autorepeat.
     */
    if (XkbDDXUsesSoftRepeat(keybd)) {
        if ((keybd->kbdfeed->ctrl.autoRepeat) &&
            ((ctrls->enabled_ctrls & (XkbSlowKeysMask | XkbRepeatKeysMask)) ==
             XkbRepeatKeysMask)) {
            if (BitIsOn(keybd->kbdfeed->ctrl.autoRepeats, key)) {
                if (xkbDebugFlags & 0x10)
                    DebugF("Starting software autorepeat...\n");
                if (xkbi->repeatKey == key)
                    ignoreKeyEvent = TRUE;
                else {
                    xkbi->repeatKey = key;
                    xkbi->repeatKeyTimer = TimerSet(xkbi->repeatKeyTimer,
                                                    0, ctrls->repeat_delay,
                                                    AccessXRepeatKeyExpire,
                                                    (void *) keybd);
                }
            }
        }
    }

    /* Check for two keys being pressed at the same time.  This section
     * essentially says the following:
     *
     *  If StickyKeys is on, and a modifier is currently being held down,
     *  and one of the following is true:  the current key is not a modifier
     *  or the currentKey is a modifier, but not the only modifier being
     *  held down, turn StickyKeys off if the TwoKeys off ctrl is set.
     */
    if ((ctrls->enabled_ctrls & XkbStickyKeysMask) &&
        (xkbi->state.base_mods != 0) &&
        (XkbAX_NeedOption(ctrls, XkbAX_TwoKeysMask))) {
        xkbControlsNotify cn;

        cn.keycode = key;
        cn.eventType = KeyPress;
        cn.requestMajor = 0;
        cn.requestMinor = 0;
        AccessXStickyKeysTurnOff(keybd, &cn);
    }

    if (!ignoreKeyEvent)
        XkbProcessKeyboardEvent(event, keybd);
    return ignoreKeyEvent;
}                               /* AccessXFilterPressEvent */

/************************************************************************/
/*									*/
/* AccessXFilterReleaseEvent						*/
/*									*/
/* Filter events before they get any further if SlowKeys is turned on.	*/
/* In addition, this routine handles the ever so popular magic key	*/
/* acts for turning various accessibility features on/off.		*/
/*									*/
/* Returns TRUE if this routine has discarded the event.		*/
/* Returns FALSE if the event needs further processing.			*/
/*									*/
/************************************************************************/
Bool
AccessXFilterReleaseEvent(DeviceEvent *event, DeviceIntPtr keybd)
{
    XkbSrvInfoPtr xkbi = keybd->key->xkbInfo;
    XkbControlsPtr ctrls = xkbi->desc->ctrls;
    KeyCode key = event->detail.key;
    Bool ignoreKeyEvent = FALSE;

    /* Don't transmit the KeyRelease if BounceKeys is on and
     * this is the release of a key that was ignored due to
     * BounceKeys.
     */
    if (ctrls->enabled_ctrls & XkbBounceKeysMask) {
        if ((key != xkbi->mouseKey) && (!BitIsOn(keybd->key->down, key)))
            ignoreKeyEvent = TRUE;
        xkbi->inactiveKey = key;
        xkbi->bounceKeysTimer = TimerSet(xkbi->bounceKeysTimer, 0,
                                         ctrls->debounce_delay,
                                         AccessXBounceKeyExpire,
                                         (void *) keybd);
    }

    /* Don't transmit the KeyRelease if SlowKeys is turned on and
     * the user didn't hold the key long enough.  We know we passed
     * the key if the down bit was set by CoreProcessKeyboadEvent.
     */
    if (ctrls->enabled_ctrls & XkbSlowKeysMask) {
        xkbAccessXNotify ev;
        unsigned beep_type;

        ev.keycode = key;
        ev.slowKeysDelay = ctrls->slow_keys_delay;
        ev.debounceDelay = ctrls->debounce_delay;
        if (BitIsOn(keybd->key->down, key) || (xkbi->mouseKey == key)) {
            ev.detail = XkbAXN_SKRelease;
            beep_type = _BEEP_SLOW_RELEASE;
        }
        else {
            ev.detail = XkbAXN_SKReject;
            beep_type = _BEEP_SLOW_REJECT;
            ignoreKeyEvent = TRUE;
        }
        XkbSendAccessXNotify(keybd, &ev);
        if (XkbAX_NeedFeedback(ctrls, XkbAX_SKRejectFBMask)) {
            XkbDDXAccessXBeep(keybd, beep_type, XkbSlowKeysMask);
        }
        if (xkbi->slowKey == key)
            xkbi->slowKey = 0;
    }

    /* Stop Repeating if the user releases the key that is currently
     * repeating.
     */
    if (xkbi->repeatKey == key) {
        xkbi->repeatKey = 0;
    }

    if ((ctrls->enabled_ctrls & XkbAccessXTimeoutMask) &&
        (ctrls->ax_timeout > 0)) {
        xkbi->lastPtrEventTime = 0;
        xkbi->krgTimer = TimerSet(xkbi->krgTimer, 0,
                                  ctrls->ax_timeout * 1000,
                                  AccessXTimeoutExpire, (void *) keybd);
        xkbi->krgTimerActive = _ALL_TIMEOUT_TIMER;
    }
    else if (xkbi->krgTimerActive != _OFF_TIMER) {
        xkbi->krgTimer = TimerSet(xkbi->krgTimer, 0, 0, NULL, NULL);
        xkbi->krgTimerActive = _OFF_TIMER;
    }

    /* Keep track of how many times the Shift key has been pressed.
     * If it has been pressed and released 5 times in a row, toggle
     * the state of StickyKeys.
     */
    if ((!ignoreKeyEvent) && (xkbi->shiftKeyCount)) {
        KeySym *pSym = XkbKeySymsPtr(xkbi->desc, key);

        if ((pSym[0] != XK_Shift_L) && (pSym[0] != XK_Shift_R)) {
            xkbi->shiftKeyCount = 0;
        }
        else if (xkbi->shiftKeyCount >= 5) {
            xkbControlsNotify cn;

            cn.keycode = key;
            cn.eventType = KeyPress;
            cn.requestMajor = 0;
            cn.requestMinor = 0;
            if (ctrls->enabled_ctrls & XkbStickyKeysMask)
                AccessXStickyKeysTurnOff(keybd, &cn);
            else
                AccessXStickyKeysTurnOn(keybd, &cn);
            xkbi->shiftKeyCount = 0;
        }
    }

    if (!ignoreKeyEvent)
        XkbProcessKeyboardEvent(event, keybd);
    return ignoreKeyEvent;

}                               /* AccessXFilterReleaseEvent */

/************************************************************************/
/*									*/
/* ProcessPointerEvent							*/
/*									*/
/* This routine merely sets the shiftKeyCount and clears the keyboard   */
/* response group timer (if necessary) on a mouse event.  This is so	*/
/* multiple shifts with just the mouse and shift-drags with the mouse	*/
/* don't accidentally turn on StickyKeys or the Keyboard Response Group.*/
/*									*/
/************************************************************************/
extern int xkbDevicePrivateIndex;
void
ProcessPointerEvent(InternalEvent *ev, DeviceIntPtr mouse)
{
    DeviceIntPtr dev;
    XkbSrvInfoPtr xkbi = NULL;
    unsigned changed = 0;
    ProcessInputProc backupproc;
    xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(mouse);
    DeviceEvent *event = &ev->device_event;

    dev = IsFloating(mouse) ? mouse : GetMaster(mouse, MASTER_KEYBOARD);

    if (dev && dev->key) {
        xkbi = dev->key->xkbInfo;
        xkbi->shiftKeyCount = 0;
        xkbi->lastPtrEventTime = event->time;
    }

    if (event->type == ET_ButtonPress) {
        changed |= XkbPointerButtonMask;
    }
    else if (event->type == ET_ButtonRelease) {
        if (IsMaster(dev)) {
            DeviceIntPtr source;
            int rc;

            rc = dixLookupDevice(&source, event->sourceid, serverClient,
                    DixWriteAccess);
            if (rc != Success)
                ErrorF("[xkb] bad sourceid '%d' on button release event.\n",
                        event->sourceid);
            else if (!IsXTestDevice(source, GetMaster(dev, MASTER_POINTER))) {
                DeviceIntPtr xtest_device;

                xtest_device = GetXTestDevice(GetMaster(dev, MASTER_POINTER));
                if (button_is_down(xtest_device, ev->device_event.detail.button, BUTTON_PROCESSED))
                    XkbFakeDeviceButton(dev, FALSE, event->detail.key);
            }
        }

        if (xkbi)
            xkbi->lockedPtrButtons &= ~(1 << (event->detail.key & 0x7));

        changed |= XkbPointerButtonMask;
    }

    UNWRAP_PROCESS_INPUT_PROC(mouse, xkbPrivPtr, backupproc);
    mouse->public.processInputProc(ev, mouse);
    COND_WRAP_PROCESS_INPUT_PROC(mouse, xkbPrivPtr, backupproc, xkbUnwrapProc);

    if (!xkbi)
        return;

    xkbi->state.ptr_buttons = (mouse->button) ? mouse->button->state : 0;

    /* clear any latched modifiers */
    if (xkbi->state.latched_mods && (event->type == ET_ButtonRelease)) {
        unsigned changed_leds;
        XkbStateRec oldState;
        XkbSrvLedInfoPtr sli;

        sli = XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId, 0);
        oldState = xkbi->state;
        XkbLatchModifiers(dev, 0xFF, 0x00);

        XkbComputeDerivedState(xkbi);
        changed |= XkbStateChangedFlags(&oldState, &xkbi->state);
        if (changed & sli->usedComponents) {
            changed_leds = XkbIndicatorsToUpdate(dev, changed, FALSE);
            if (changed_leds) {
                XkbEventCauseRec cause;

                XkbSetCauseKey(&cause, (event->detail.key & 0x7), event->type);
                XkbUpdateIndicators(dev, changed_leds, TRUE, NULL, &cause);
            }
        }
    }

    if (((xkbi->flags & _XkbStateNotifyInProgress) == 0) && (changed != 0)) {
        xkbStateNotify sn;

        sn.keycode = event->detail.key;
        sn.eventType = event->type;
        sn.requestMajor = sn.requestMinor = 0;
        sn.changed = changed;
        XkbSendStateNotify(dev, &sn);
    }

}                               /* ProcessPointerEvent */
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d9 2
a10 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d12 1
a12 1
Silicon Graphics makes no representation about the suitability 
d16 2
a17 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d19 3
a21 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
d601 1
a601 1
     * this is the release of a key that was ignored due to 
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d282 1
a282 1
AccessXKRGExpire(OsTimerPtr timer, CARD32 now, pointer arg)
d312 1
a312 1
AccessXRepeatKeyExpire(OsTimerPtr timer, CARD32 now, pointer arg)
d334 1
a334 1
AccessXSlowKeyExpire(OsTimerPtr timer, CARD32 now, pointer arg)
d373 1
a373 1
                                                (pointer) keybd);
d381 1
a381 1
AccessXBounceKeyExpire(OsTimerPtr timer, CARD32 now, pointer arg)
d390 1
a390 1
AccessXTimeoutExpire(OsTimerPtr timer, CARD32 now, pointer arg)
d470 1
a470 1
                                          AccessXKRGExpire, (pointer) keybd);
d475 1
a475 1
                                          AccessXKRGExpire, (pointer) keybd);
d517 1
a517 1
                                       AccessXSlowKeyExpire, (pointer) keybd);
d549 1
a549 1
                                                    (pointer) keybd);
d611 1
a611 1
                                         (pointer) keybd);
d654 1
a654 1
                                  AccessXTimeoutExpire, (pointer) keybd);
d714 1
a714 1
    dev = (IsMaster(mouse) || IsFloating(mouse)) ? mouse : GetMaster(mouse, MASTER_KEYBOARD);
@


1.8
log
@Update to xserver 1.12.3.
@
text
@a283 1
    XkbSrvInfoPtr xkbi = ((DeviceIntPtr) arg)->key->xkbInfo;
d285 2
d289 1
a289 2
        XkbDDXAccessXBeep((DeviceIntPtr) arg, _BEEP_SLOW_WARN,
                          XkbStickyKeysMask);
d294 2
a295 2
    cn.keycode = 0;
    cn.eventType = 0;
d299 1
a299 1
        AccessXKRGTurnOff((DeviceIntPtr) arg, &cn);
d303 1
a303 1
        AccessXKRGTurnOn((DeviceIntPtr) arg, XkbSlowKeysMask, &cn);
d307 1
d466 1
a703 1
extern void xkbUnwrapProc(DeviceIntPtr, DeviceHandleProc, pointer);
d714 1
a714 1
    dev = IsFloating(mouse) ? mouse : GetMaster(mouse, MASTER_KEYBOARD);
d726 11
a736 2
        if (xkbi) {
            xkbi->lockedPtrButtons &= ~(1 << (event->detail.key & 0x7));
d738 2
a739 10
            if (IsMaster(dev)) {
                DeviceIntPtr source;
                int rc;

                rc = dixLookupDevice(&source, event->sourceid, serverClient,
                                     DixWriteAccess);
                if (rc != Success)
                    ErrorF("[xkb] bad sourceid '%d' on button release event.\n",
                           event->sourceid);
                else if (!IsXTestDevice(source, GetMaster(dev, MASTER_POINTER)))
d743 3
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d298 1
a298 1
    if (xkbi->desc->ctrls->enabled_ctrls & XkbSlowKeysMask)
d300 3
a302 1
    else
d304 3
@


1.6
log
@Update to xserver 1.11.2
@
text
@d40 1
d46 2
a47 2
int	XkbDfltRepeatDelay=	660;
int	XkbDfltRepeatInterval=	40;
d52 9
a60 7
unsigned short	XkbDfltAccessXTimeout= 	120;
unsigned int	XkbDfltAccessXTimeoutMask= DFLT_TIMEOUT_CTRLS;
static unsigned int XkbDfltAccessXTimeoutValues= 0;
static unsigned int XkbDfltAccessXTimeoutOptionsMask= DFLT_TIMEOUT_OPTS;
static unsigned int XkbDfltAccessXTimeoutOptionsValues= 0;
unsigned int	XkbDfltAccessXFeedback= XkbAccessXFeedbackMask;
unsigned short	XkbDfltAccessXOptions=  XkbAX_AllOptionsMask & ~(XkbAX_IndicatorFBMask|XkbAX_SKReleaseFBMask|XkbAX_SKRejectFBMask);
d63 1
a63 1
AccessXComputeCurveFactor(XkbSrvInfoPtr xkbi,XkbControlsPtr ctrls)
d65 4
a68 3
    xkbi->mouseKeysCurve= 1.0+(((double)ctrls->mk_curve)*0.001);
    xkbi->mouseKeysCurveFactor= ( ((double)ctrls->mk_max_speed)/
	pow((double)ctrls->mk_time_to_max,xkbi->mouseKeysCurve));
d75 2
a76 2
XkbSrvInfoPtr	xkbi = keybd->key->xkbInfo;
XkbControlsPtr	ctrls = xkbi->desc->ctrls;
d78 14
a91 14
    xkbi->shiftKeyCount= 0;
    xkbi->mouseKeysCounter= 0;
    xkbi->inactiveKey= 0;
    xkbi->slowKey= 0;
    xkbi->repeatKey= 0;
    xkbi->krgTimerActive= _OFF_TIMER;
    xkbi->beepType= _BEEP_NONE;
    xkbi->beepCount= 0;
    xkbi->mouseKeyTimer= NULL;
    xkbi->slowKeysTimer= NULL;
    xkbi->bounceKeysTimer= NULL;
    xkbi->repeatKeyTimer= NULL;
    xkbi->krgTimer= NULL;
    xkbi->beepTimer= NULL;
d108 1
a108 1
	ctrls->enabled_ctrls |= XkbAccessXTimeoutMask;
d110 1
a110 1
	ctrls->enabled_ctrls &= ~XkbAccessXTimeoutMask;
d112 2
a113 2
    ctrls->ax_options = XkbDfltAccessXOptions; 
    AccessXComputeCurveFactor(xkbi,ctrls);
d124 2
a125 5
static void 
AccessXKeyboardEvent(DeviceIntPtr	keybd,
				 int		type,
				 BYTE		keyCode,
				 Bool		isRepeat)
d128 2
a129 2
    memset(&event, 0, sizeof(DeviceEvent));
    event.header = ET_Internal;
a131 2
    event.time = GetTimeInMillis();
    event.length = sizeof(DeviceEvent);
a132 2
    event.sourceid = keybd->id;
    event.deviceid = keybd->id;
d134 2
a135 2
    if (xkbDebugFlags&0x8) {
	DebugF("[xkb] AXKE: Key %d %s\n", keyCode,
d141 1
a141 1
} /* AccessXKeyboardEvent */
d151 1
a151 1
AccessXKRGTurnOn(DeviceIntPtr dev,CARD16 KRGControl,xkbControlsNotify	*pCN)
d153 18
a170 18
XkbSrvInfoPtr		xkbi = dev->key->xkbInfo;
XkbControlsPtr		ctrls = xkbi->desc->ctrls;
XkbControlsRec		old;
XkbEventCauseRec	cause;
XkbSrvLedInfoPtr	sli;

    old= *ctrls;
    ctrls->enabled_ctrls |= (KRGControl&XkbAX_KRGMask);
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,FALSE))
	XkbSendControlsNotify(dev,pCN);
    cause.kc=		pCN->keycode;
    cause.event=	pCN->eventType;
    cause.mjr=		pCN->requestMajor;
    cause.mnr=		pCN->requestMinor;
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(dev,sli->usesControls,TRUE,NULL,&cause);
    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask))
	XkbDDXAccessXBeep(dev,_BEEP_FEATURE_ON,KRGControl);
d172 2
a173 2
    
} /* AccessXKRGTurnOn */
d182 2
a183 2
static void 
AccessXKRGTurnOff(DeviceIntPtr dev,xkbControlsNotify *pCN)
d185 5
a189 5
XkbSrvInfoPtr		xkbi = dev->key->xkbInfo;
XkbControlsPtr		ctrls = xkbi->desc->ctrls;
XkbControlsRec		old;
XkbEventCauseRec	cause;
XkbSrvLedInfoPtr	sli;
d193 12
a204 11
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,FALSE))
	XkbSendControlsNotify(dev,pCN);
    cause.kc=		pCN->keycode;
    cause.event=	pCN->eventType;
    cause.mjr=		pCN->requestMajor;
    cause.mnr=		pCN->requestMinor;
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(dev,sli->usesControls,TRUE,NULL,&cause);
    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask)) {
	unsigned changes= old.enabled_ctrls^ctrls->enabled_ctrls;
	XkbDDXAccessXBeep(dev,_BEEP_FEATURE_OFF,changes);
d207 2
a208 2
    
} /* AccessXKRGTurnOff */
d218 1
a218 1
AccessXStickyKeysTurnOn(DeviceIntPtr dev,xkbControlsNotify *pCN)
d220 5
a224 5
XkbSrvInfoPtr		xkbi = dev->key->xkbInfo;
XkbControlsPtr		ctrls = xkbi->desc->ctrls;
XkbControlsRec		old;
XkbEventCauseRec	cause;
XkbSrvLedInfoPtr	sli;
d229 10
a238 10
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,FALSE))
	XkbSendControlsNotify(dev,pCN);
    cause.kc=		pCN->keycode;
    cause.event=	pCN->eventType;
    cause.mjr=		pCN->requestMajor;
    cause.mnr=		pCN->requestMinor;
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(dev,sli->usesControls,TRUE,NULL,&cause);
    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask)) {
	XkbDDXAccessXBeep(dev,_BEEP_FEATURE_ON,XkbStickyKeysMask);
d241 2
a242 2
    
} /* AccessXStickyKeysTurnOn */
d252 1
a252 1
AccessXStickyKeysTurnOff(DeviceIntPtr dev,xkbControlsNotify *pCN)
d254 5
a258 5
XkbSrvInfoPtr		xkbi = dev->key->xkbInfo;
XkbControlsPtr		ctrls = xkbi->desc->ctrls;
XkbControlsRec		old;
XkbEventCauseRec	cause;
XkbSrvLedInfoPtr	sli;
d263 2
a264 2
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,FALSE))
	XkbSendControlsNotify(dev,pCN);
d266 8
a273 8
    cause.kc=		pCN->keycode;
    cause.event=	pCN->eventType;
    cause.mjr=		pCN->requestMajor;
    cause.mnr=		pCN->requestMinor;
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(dev,sli->usesControls,TRUE,NULL,&cause);
    if (XkbAX_NeedFeedback(ctrls,XkbAX_FeatureFBMask)) {
	XkbDDXAccessXBeep(dev,_BEEP_FEATURE_OFF,XkbStickyKeysMask);
d276 1
a276 1
    XkbClearAllLatchesAndLocks(dev,xkbi,FALSE,&cause);
d279 1
a279 1
} /* AccessXStickyKeysTurnOff */
d282 1
a282 1
AccessXKRGExpire(OsTimerPtr timer,CARD32 now,pointer arg)
d284 2
a285 2
XkbSrvInfoPtr		xkbi= ((DeviceIntPtr)arg)->key->xkbInfo;
xkbControlsNotify	cn;
d287 5
a291 4
    if (xkbi->krgTimerActive==_KRG_WARN_TIMER) {
	XkbDDXAccessXBeep((DeviceIntPtr)arg,_BEEP_SLOW_WARN,XkbStickyKeysMask);
	xkbi->krgTimerActive= _KRG_TIMER;
	return 4000;
d293 1
a293 1
    xkbi->krgTimerActive= _OFF_TIMER;
d298 4
a301 3
    if (xkbi->desc->ctrls->enabled_ctrls&XkbSlowKeysMask)
	 AccessXKRGTurnOff((DeviceIntPtr)arg,&cn);
    else AccessXKRGTurnOn((DeviceIntPtr)arg,XkbSlowKeysMask,&cn);
d306 1
a306 1
AccessXRepeatKeyExpire(OsTimerPtr timer,CARD32 now,pointer arg)
d308 2
a309 2
DeviceIntPtr    dev = (DeviceIntPtr) arg;
XkbSrvInfoPtr	xkbi = dev->key->xkbInfo;
d312 1
a312 1
	return 0;
d320 1
a320 1
AccessXCancelRepeatKey(XkbSrvInfoPtr xkbi,KeyCode key)
d322 2
a323 2
    if (xkbi->repeatKey==key)
	xkbi->repeatKey= 0;
d328 1
a328 1
AccessXSlowKeyExpire(OsTimerPtr timer,CARD32 now,pointer arg)
d330 40
a369 38
DeviceIntPtr	keybd;
XkbSrvInfoPtr	xkbi;
XkbDescPtr	xkb;
XkbControlsPtr	ctrls;

    keybd= 	(DeviceIntPtr)arg;
    xkbi= 	keybd->key->xkbInfo;
    xkb= 	xkbi->desc;
    ctrls= 	xkb->ctrls;
    if (xkbi->slowKey!=0) {
	xkbAccessXNotify ev;
	KeySym *sym= XkbKeySymsPtr(xkb,xkbi->slowKey);
	ev.detail= XkbAXN_SKAccept;
	ev.keycode= xkbi->slowKey;
	ev.slowKeysDelay= ctrls->slow_keys_delay;
	ev.debounceDelay= ctrls->debounce_delay;
	XkbSendAccessXNotify(keybd,&ev);
	if (XkbAX_NeedFeedback(ctrls,XkbAX_SKAcceptFBMask))
	    XkbDDXAccessXBeep(keybd,_BEEP_SLOW_ACCEPT,XkbSlowKeysMask);
	AccessXKeyboardEvent(keybd, ET_KeyPress,xkbi->slowKey,FALSE);
	/* check for magic sequences */
	if ((ctrls->enabled_ctrls&XkbAccessXKeysMask) &&
	    ((sym[0]==XK_Shift_R)||(sym[0]==XK_Shift_L)))
	    xkbi->shiftKeyCount++;

	/* Start repeating if necessary.  Stop autorepeating if the user
	 * presses a non-modifier key that doesn't autorepeat.
	 */
	if (keybd->kbdfeed->ctrl.autoRepeat && 
	    ((xkbi->slowKey != xkbi->mouseKey) || (!xkbi->mouseKeysAccel)) &&
	     (ctrls->enabled_ctrls&XkbRepeatKeysMask)) {
	    if (BitIsOn(keybd->kbdfeed->ctrl.autoRepeats,xkbi->slowKey)) {
		xkbi->repeatKey = xkbi->slowKey;
		xkbi->repeatKeyTimer= TimerSet(xkbi->repeatKeyTimer,
					0, ctrls->repeat_delay,
					AccessXRepeatKeyExpire, (pointer)keybd);
	    }
	}
d375 1
a375 1
AccessXBounceKeyExpire(OsTimerPtr timer,CARD32 now,pointer arg)
d377 1
a377 1
XkbSrvInfoPtr	xkbi= ((DeviceIntPtr)arg)->key->xkbInfo;
d379 1
a379 1
    xkbi->inactiveKey= 0;
d384 1
a384 1
AccessXTimeoutExpire(OsTimerPtr timer,CARD32 now,pointer arg)
d386 7
a392 7
DeviceIntPtr		dev = (DeviceIntPtr)arg;
XkbSrvInfoPtr		xkbi= dev->key->xkbInfo;
XkbControlsPtr		ctrls= xkbi->desc->ctrls;
XkbControlsRec		old;
xkbControlsNotify	cn;
XkbEventCauseRec	cause;
XkbSrvLedInfoPtr	sli;
d395 2
a396 2
	unsigned timeToWait = (ctrls->ax_timeout*1000);
	unsigned timeElapsed = (now-xkbi->lastPtrEventTime);
d398 2
a399 2
	if (timeToWait > timeElapsed)
	    return timeToWait - timeElapsed;
d401 4
a404 5
    old= *ctrls;
    xkbi->shiftKeyCount= 0;
    ctrls->enabled_ctrls&= ~ctrls->axt_ctrls_mask;
    ctrls->enabled_ctrls|= 
	(ctrls->axt_ctrls_values&ctrls->axt_ctrls_mask);
d406 2
a407 2
	ctrls->ax_options&= ~ctrls->axt_opts_mask;
	ctrls->ax_options|= (ctrls->axt_opts_values&ctrls->axt_opts_mask);
d409 6
a414 6
    if (XkbComputeControlsNotify(dev,&old,ctrls,&cn,FALSE)) {
	cn.keycode = 0;
	cn.eventType = 0;
	cn.requestMajor = 0;
	cn.requestMinor = 0;
	XkbSendControlsNotify(dev,&cn);
d417 14
a430 10
    sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
    XkbUpdateIndicators(dev,sli->usesControls,TRUE,NULL,&cause);
    if (ctrls->ax_options!=old.ax_options) {
	unsigned set,cleared,bell;
	set= ctrls->ax_options&(~old.ax_options);
	cleared= (~ctrls->ax_options)&old.ax_options;
	if (set && cleared)	bell= _BEEP_FEATURE_CHANGE;
	else if (set)		bell= _BEEP_FEATURE_ON;
	else 			bell= _BEEP_FEATURE_OFF;
	XkbDDXAccessXBeep(dev,bell,XkbAccessXTimeoutMask);
d432 1
a432 1
    xkbi->krgTimerActive= _OFF_TIMER;
a435 1

d449 1
a449 2
AccessXFilterPressEvent(	DeviceEvent*	event,
				DeviceIntPtr	keybd)
d451 35
a485 33
XkbSrvInfoPtr	xkbi = keybd->key->xkbInfo;
XkbControlsPtr	ctrls = xkbi->desc->ctrls;
Bool		ignoreKeyEvent = FALSE;
KeyCode		key = event->detail.key;
KeySym *	sym = XkbKeySymsPtr(xkbi->desc,key);

    if (ctrls->enabled_ctrls&XkbAccessXKeysMask) {
	/* check for magic sequences */
	if ((sym[0]==XK_Shift_R)||(sym[0]==XK_Shift_L)) {
	    if (XkbAX_NeedFeedback(ctrls,XkbAX_SlowWarnFBMask)) {
		xkbi->krgTimerActive = _KRG_WARN_TIMER;
		xkbi->krgTimer= TimerSet(xkbi->krgTimer, 0, 4000,
					AccessXKRGExpire, (pointer)keybd);
	    }
	    else {
		xkbi->krgTimerActive = _KRG_TIMER;
		xkbi->krgTimer= TimerSet(xkbi->krgTimer, 0, 8000,
					AccessXKRGExpire, (pointer)keybd);
	    }
	    if (!(ctrls->enabled_ctrls & XkbSlowKeysMask)) {
		CARD32 now= GetTimeInMillis();
		if ((now-xkbi->lastShiftEventTime)>15000)
		     xkbi->shiftKeyCount= 1;
		else xkbi->shiftKeyCount++;
		xkbi->lastShiftEventTime= now;
	    }
	}
	else {
	    if (xkbi->krgTimerActive) {
		xkbi->krgTimer= TimerSet(xkbi->krgTimer,0, 0, NULL, NULL);
		xkbi->krgTimerActive= _OFF_TIMER;
	    }
	}
d487 1
a487 1
	
d493 19
a511 18
	xkbAccessXNotify	ev;
	/* If key was already pressed, ignore subsequent press events
	 * from the server's autorepeat
	 */
	if(xkbi->slowKey == key)
	    return TRUE;
	ev.detail= XkbAXN_SKPress;
	ev.keycode= key;
	ev.slowKeysDelay= ctrls->slow_keys_delay;
	ev.debounceDelay= ctrls->debounce_delay;
	XkbSendAccessXNotify(keybd,&ev);
	if (XkbAX_NeedFeedback(ctrls,XkbAX_SKPressFBMask))
	    XkbDDXAccessXBeep(keybd,_BEEP_SLOW_PRESS,XkbSlowKeysMask);
	xkbi->slowKey= key;
	xkbi->slowKeysTimer = TimerSet(xkbi->slowKeysTimer,
				 0, ctrls->slow_keys_delay,
				 AccessXSlowKeyExpire, (pointer)keybd);
	ignoreKeyEvent = TRUE;
d518 5
a522 5
    else if ((ctrls->enabled_ctrls & XkbBounceKeysMask) && 
					(key == xkbi->inactiveKey)) {
	if (XkbAX_NeedFeedback(ctrls,XkbAX_BKRejectFBMask))
	    XkbDDXAccessXBeep(keybd,_BEEP_BOUNCE_REJECT,XkbBounceKeysMask);
	ignoreKeyEvent = TRUE;
d529 17
a545 16
	if ((keybd->kbdfeed->ctrl.autoRepeat) &&
		((ctrls->enabled_ctrls&(XkbSlowKeysMask|XkbRepeatKeysMask))==
							XkbRepeatKeysMask)) {
	    if (BitIsOn(keybd->kbdfeed->ctrl.autoRepeats,key)) {
		if (xkbDebugFlags&0x10)
		    DebugF("Starting software autorepeat...\n");
		if (xkbi->repeatKey == key)
		    ignoreKeyEvent = TRUE;
		else {
		    xkbi->repeatKey = key;
		    xkbi->repeatKeyTimer= TimerSet(xkbi->repeatKeyTimer,
			    0, ctrls->repeat_delay,
			    AccessXRepeatKeyExpire, (pointer)keybd);
		}
	    }
	}
d547 1
a547 1
    
d551 1
a551 1
     *	If StickyKeys is on, and a modifier is currently being held down,
d556 10
a565 9
    if ((ctrls->enabled_ctrls & XkbStickyKeysMask) && 
				(xkbi->state.base_mods!=0) &&
				(XkbAX_NeedOption(ctrls,XkbAX_TwoKeysMask))) {
	xkbControlsNotify cn;
	cn.keycode = key;
	cn.eventType = KeyPress;
	cn.requestMajor = 0;
	cn.requestMinor = 0;
	AccessXStickyKeysTurnOff(keybd,&cn);
d567 1
a567 1
    
d569 1
a569 1
	XkbProcessKeyboardEvent(event, keybd);
d571 1
a571 1
} /* AccessXFilterPressEvent */
d586 1
a586 2
AccessXFilterReleaseEvent(	DeviceEvent*	event,
				DeviceIntPtr	keybd)
d588 5
a592 5
XkbSrvInfoPtr	xkbi = keybd->key->xkbInfo;
XkbControlsPtr	ctrls = xkbi->desc->ctrls;
KeyCode		key = event->detail.key;
Bool		ignoreKeyEvent = FALSE;
    
d598 7
a604 6
	if ((key!=xkbi->mouseKey)&&(!BitIsOn(keybd->key->down,key)))
	    ignoreKeyEvent = TRUE;
	xkbi->inactiveKey= key;
	xkbi->bounceKeysTimer= TimerSet(xkbi->bounceKeysTimer, 0,
					ctrls->debounce_delay,
					AccessXBounceKeyExpire, (pointer)keybd);
d612 21
a632 20
	xkbAccessXNotify	ev;
	unsigned		beep_type;
	ev.keycode= key;
	ev.slowKeysDelay= ctrls->slow_keys_delay;
	ev.debounceDelay= ctrls->debounce_delay;
	if (BitIsOn(keybd->key->down,key) || (xkbi->mouseKey == key)) {
	    ev.detail= XkbAXN_SKRelease;
	    beep_type= _BEEP_SLOW_RELEASE;
	}
	else {
	    ev.detail= XkbAXN_SKReject;
	    beep_type= _BEEP_SLOW_REJECT;
	    ignoreKeyEvent = TRUE;
	}
	XkbSendAccessXNotify(keybd,&ev);
	if (XkbAX_NeedFeedback(ctrls,XkbAX_SKRejectFBMask)) {
	    XkbDDXAccessXBeep(keybd,beep_type,XkbSlowKeysMask);
	}
	if (xkbi->slowKey==key)
	    xkbi->slowKey= 0;
d638 2
a639 2
    if (xkbi->repeatKey==key) {
	xkbi->repeatKey= 0;
d642 11
a652 10
    if ((ctrls->enabled_ctrls&XkbAccessXTimeoutMask)&&(ctrls->ax_timeout>0)) {
	xkbi->lastPtrEventTime= 0;
	xkbi->krgTimer= TimerSet(xkbi->krgTimer, 0, 
					ctrls->ax_timeout*1000,
					AccessXTimeoutExpire, (pointer)keybd);
	xkbi->krgTimerActive= _ALL_TIMEOUT_TIMER;
    }
    else if (xkbi->krgTimerActive!=_OFF_TIMER) {
	xkbi->krgTimer= TimerSet(xkbi->krgTimer, 0, 0, NULL, NULL);
	xkbi->krgTimerActive= _OFF_TIMER;
d654 1
a654 1
	
d659 19
a677 17
    if ((!ignoreKeyEvent)&&(xkbi->shiftKeyCount)) {
	KeySym *pSym= XkbKeySymsPtr(xkbi->desc,key);
	if ((pSym[0]!=XK_Shift_L)&&(pSym[0]!=XK_Shift_R)) {
	    xkbi->shiftKeyCount= 0;
	}
	else if (xkbi->shiftKeyCount>=5) {
	     xkbControlsNotify cn;
	     cn.keycode = key;
	     cn.eventType = KeyPress;
	     cn.requestMajor = 0;
	     cn.requestMinor = 0;
	     if (ctrls->enabled_ctrls & XkbStickyKeysMask)
		AccessXStickyKeysTurnOff(keybd,&cn);
	     else
		AccessXStickyKeysTurnOn(keybd,&cn);
	     xkbi->shiftKeyCount= 0;
	}
d679 1
a679 1
    
d681 1
a681 1
	XkbProcessKeyboardEvent(event, keybd);
d683 2
a684 2
    
} /* AccessXFilterReleaseEvent */
d699 1
a699 2
ProcessPointerEvent(	InternalEvent   *ev,
			DeviceIntPtr    mouse)
d701 6
a706 6
DeviceIntPtr	dev;
XkbSrvInfoPtr	xkbi = NULL;
unsigned 	changed = 0;
ProcessInputProc backupproc;
xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(mouse);
DeviceEvent     *event = &ev->device_event;
d710 4
a713 5
    if (dev && dev->key)
    {
	xkbi = dev->key->xkbInfo;
	xkbi->shiftKeyCount = 0;
	xkbi->lastPtrEventTime= event->time;
d717 1
a717 1
	    changed |= XkbPointerButtonMask;
d720 2
a721 2
	if (xkbi) {
	    xkbi->lockedPtrButtons&= ~(1 << (event->detail.key & 0x7));
d723 1
a723 2
            if (IsMaster(dev))
            {
d726 3
a728 1
                rc = dixLookupDevice(&source, event->sourceid, serverClient, DixWriteAccess);
d730 2
a731 1
                    ErrorF("[xkb] bad sourceid '%d' on button release event.\n", event->sourceid);
d735 1
a735 1
	}
d737 1
a737 1
	changed |= XkbPointerButtonMask;
d742 1
a742 2
    COND_WRAP_PROCESS_INPUT_PROC(mouse, xkbPrivPtr,
				     backupproc, xkbUnwrapProc);
d745 1
a745 1
	return;
d748 1
a748 1
    
d750 20
a769 28
    if ( xkbi->state.latched_mods && (event->type == ET_ButtonRelease) ) {
	unsigned 		changed_leds;
	XkbStateRec		oldState;
	XkbSrvLedInfoPtr	sli;

	sli= XkbFindSrvLedInfo(dev,XkbDfltXIClass,XkbDfltXIId,0);
	oldState= xkbi->state;
	XkbLatchModifiers(dev,0xFF,0x00);

	XkbComputeDerivedState(xkbi);
	changed |= XkbStateChangedFlags(&oldState,&xkbi->state);
	if (changed&sli->usedComponents) {
	    changed_leds= XkbIndicatorsToUpdate(dev,changed,FALSE);
	    if (changed_leds) {
		XkbEventCauseRec	cause;
		XkbSetCauseKey(&cause,(event->detail.key & 0x7), event->type);
		XkbUpdateIndicators(dev,changed_leds,TRUE,NULL,&cause);
	    }
	}
    }

    if (((xkbi->flags&_XkbStateNotifyInProgress)==0)&&(changed!=0)) {
	xkbStateNotify	sn;
	sn.keycode= event->detail.key;
	sn.eventType= event->type;
	sn.requestMajor = sn.requestMinor = 0;
	sn.changed= changed;
	XkbSendStateNotify(dev,&sn);
d772 2
a773 3
} /* ProcessPointerEvent */


d775 6
d782 1
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d697 1
a697 1
    dev = (IsMaster(mouse) || mouse->u.master) ? GetMaster(mouse, MASTER_KEYBOARD) : mouse;
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d397 1
a397 1
	    return (timeToWait - timeElapsed);
d710 1
a710 1
	if (xkbi)
d712 13
a726 16

    /* Guesswork. mostly. 
     * xkb actuall goes through some effort to transparently wrap the
     * processInputProcs (see XkbSetExtension). But we all love fun, so the
     * previous XKB implementation just hardcoded the CPPE call here instead
     * of unwrapping like anybody with any sense of decency would do. 
     * I got no clue what the correct thing to do is, but my guess is that
     * it's not hardcoding. I may be wrong. whatever it is, don't come whining
     * to me. I just work here. 
     *
     * Anyway. here's the old call, if you don't like the wrapping, revert it.
     *
     * CoreProcessPointerEvent(xE,mouse,count);
     *
     *          see. it's still steaming. told you. (whot)
     */
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a32 1
#define NEED_EVENTS 1
d36 2
d39 1
d45 2
a46 3
_X_EXPORT int	XkbDfltRepeatDelay=	660;
_X_EXPORT int	XkbDfltRepeatInterval=	40;
pointer	XkbLastRepeatEvent=	NULL;
d122 1
a122 1
				 BYTE		type,
d126 11
a136 5
xEvent		xE;
    
    xE.u.u.type = type;
    xE.u.u.detail = keyCode;
    xE.u.keyButtonPointer.time = GetTimeInMillis();	    
d138 2
a139 1
	DebugF("[xkb] AXKE: Key %d %s\n",keyCode,(xE.u.u.type==KeyPress?"down":"up"));
d142 1
a142 6
    if (_XkbIsPressEvent(type))
	XkbDDXKeyClick(keybd,keyCode,TRUE);
    else if (isRepeat)
	XkbLastRepeatEvent=	(pointer)&xE;
    XkbProcessKeyboardEvent(&xE,keybd,1L);
    XkbLastRepeatEvent= NULL;
a143 1
    
d164 1
a164 1
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,False))
d171 1
a171 1
    XkbUpdateIndicators(dev,sli->usesControls,True,NULL,&cause);
d196 1
a196 1
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,False))
d203 1
a203 1
    XkbUpdateIndicators(dev,sli->usesControls,True,NULL,&cause);
d231 1
a231 1
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,False)) 
d238 1
a238 1
    XkbUpdateIndicators(dev,sli->usesControls,True,NULL,&cause);
d265 1
a265 1
    if (XkbComputeControlsNotify(dev,&old,ctrls,pCN,False))
d273 1
a273 1
    XkbUpdateIndicators(dev,sli->usesControls,True,NULL,&cause);
d278 1
a278 1
    XkbClearAllLatchesAndLocks(dev,xkbi,False,&cause);
a309 1
KeyCode		key;
d314 1
a314 3
    key = xkbi->repeatKey;
    AccessXKeyboardEvent(dev, DeviceKeyRelease, key, True);
    AccessXKeyboardEvent(dev, DeviceKeyPress, key, True);
d349 1
a349 1
	AccessXKeyboardEvent(keybd,DeviceKeyPress,xkbi->slowKey,False);
d408 1
a408 1
    if (XkbComputeControlsNotify(dev,&old,ctrls,&cn,False)) {
d417 1
a417 1
    XkbUpdateIndicators(dev,sli->usesControls,True,NULL,&cause);
d445 2
a446 3
AccessXFilterPressEvent(	register xEvent *	xE, 
				register DeviceIntPtr	keybd, 
				int			count)
d451 1
a451 1
KeyCode		key = xE->u.u.detail;
d529 8
a536 4
		xkbi->repeatKey = key;
		xkbi->repeatKeyTimer= TimerSet(xkbi->repeatKeyTimer,
					0, ctrls->repeat_delay,
					AccessXRepeatKeyExpire, (pointer)keybd);
d561 1
a561 1
	XkbProcessKeyboardEvent(xE,keybd,count);
d578 2
a579 3
AccessXFilterReleaseEvent(	register xEvent *	xE, 
				register DeviceIntPtr	keybd, 
				int			count)
d583 1
a583 1
KeyCode		key = xE->u.u.detail;
d609 1
a609 1
	if (BitIsOn(keybd->key->down,key) | (xkbi->mouseKey == key)) {
d669 1
a669 1
	XkbProcessKeyboardEvent(xE,keybd,count);
d687 2
a688 3
ProcessPointerEvent(	register xEvent  *	xE, 
			register DeviceIntPtr	mouse, 
			int		        count)
d690 2
a691 2
DeviceIntPtr	dev = GetPairedDevice(mouse);
XkbSrvInfoPtr	xkbi = dev->key->xkbInfo;
d695 3
d699 6
a704 2
    xkbi->shiftKeyCount = 0;
    xkbi->lastPtrEventTime= xE->u.keyButtonPointer.time;
d706 1
a706 1
    if (xE->u.u.type==ButtonPress) {
d709 3
a711 2
    else if (xE->u.u.type==ButtonRelease) {
	xkbi->lockedPtrButtons&= ~(1<<(xE->u.u.detail&0x7));
d730 1
d732 1
a732 1
    mouse->public.processInputProc(xE, mouse, count);
d736 4
a739 1
    xkbi->state.ptr_buttons = mouse->button->state;
d742 1
a742 1
    if ( xkbi->state.latched_mods && (xE->u.u.type==ButtonRelease) ) {
d754 1
a754 1
	    changed_leds= XkbIndicatorsToUpdate(dev,changed,False);
d757 2
a758 2
		XkbSetCauseKey(&cause,(xE->u.u.detail&0x7),xE->u.u.type);
		XkbUpdateIndicators(dev,changed_leds,True,NULL,&cause);
a760 1
	dev->key->state= XkbStateFieldFromRec(&xkbi->state);
d765 2
a766 2
	sn.keycode= xE->u.u.detail;
	sn.eventType= xE->u.u.type;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a32 3
#ifdef __QNX__
#include <limits.h>
#endif
d39 1
a39 1
#if !defined(WIN32) && !defined(Lynx)
d131 1
a131 1
	DebugF("AXKE: Key %d %s\n",keyCode,(xE.u.u.type==KeyPress?"down":"up"));
a308 1
BOOL            is_core;
a312 1
    is_core = (dev == inputInfo.keyboard);
d314 3
a316 3
    AccessXKeyboardEvent(dev, is_core ? KeyRelease : DeviceKeyRelease, key,
                         True);
    AccessXKeyboardEvent(dev, is_core ? KeyPress : DeviceKeyPress, key, True);
d350 1
a350 3
	AccessXKeyboardEvent(keybd,
                (keybd == inputInfo.keyboard) ?  KeyPress : DeviceKeyPress,
                xkbi->slowKey,False);
d683 2
d690 1
a690 1
DeviceIntPtr	dev = inputInfo.keyboard;
@


1.1
log
@Initial revision
@
text
@d41 1
a41 1
#include <X11/extensions/XKBsrv.h>
d55 3
a57 3
unsigned int	XkbDfltAccessXTimeoutValues= 0;
unsigned int	XkbDfltAccessXTimeoutOptionsMask= DFLT_TIMEOUT_OPTS;
unsigned int	XkbDfltAccessXTimeoutOptionsValues= 0;
a132 1
#ifdef DEBUG
d134 1
a134 1
	ErrorF("AXKE: Key %d %s\n",keyCode,(xE.u.u.type==KeyPress?"down":"up"));
a135 1
#endif
d309 2
a310 1
XkbSrvInfoPtr	xkbi= ((DeviceIntPtr)arg)->key->xkbInfo;
d312 1
d314 1
a314 1
    if (xkbi->repeatKey==0)
d316 6
a321 3
    key= xkbi->repeatKey;
    AccessXKeyboardEvent((DeviceIntPtr)arg,KeyRelease,key,True);
    AccessXKeyboardEvent((DeviceIntPtr)arg,KeyPress,key,True);
d355 3
a357 1
	AccessXKeyboardEvent(keybd,KeyPress,xkbi->slowKey,False);
d369 1
a369 4
#ifndef AIXV3
	    if (BitIsOn(keybd->kbdfeed->ctrl.autoRepeats,xkbi->slowKey))
#endif
	    {
d535 1
a535 5
#ifndef AIXV3
	    if (BitIsOn(keybd->kbdfeed->ctrl.autoRepeats,key))
#endif
	    {
#ifdef DEBUG
d537 1
a537 2
		    ErrorF("Starting software autorepeat...\n");
#endif	    
d695 1
a695 1
DeviceIntPtr	dev = (DeviceIntPtr)LookupKeyboardDevice();
d698 2
d711 20
a730 1
    CoreProcessPointerEvent(xE,mouse,count);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d41 1
a41 1
#include <xkbsrv.h>
d55 3
a57 3
static unsigned int XkbDfltAccessXTimeoutValues= 0;
static unsigned int XkbDfltAccessXTimeoutOptionsMask= DFLT_TIMEOUT_OPTS;
static unsigned int XkbDfltAccessXTimeoutOptionsValues= 0;
d364 4
a367 1
	    if (BitIsOn(keybd->kbdfeed->ctrl.autoRepeats,xkbi->slowKey)) {
d533 4
a536 1
	    if (BitIsOn(keybd->kbdfeed->ctrl.autoRepeats,key)) {
@


1.1.1.3
log
@xserver 1.4.0.90
@
text
@d311 1
a311 2
DeviceIntPtr    dev = (DeviceIntPtr) arg;
XkbSrvInfoPtr	xkbi = dev->key->xkbInfo;
a312 1
BOOL            is_core;
d314 1
a314 1
    if (xkbi->repeatKey == 0)
d316 3
a318 6

    is_core = (dev == inputInfo.keyboard);
    key = xkbi->repeatKey;
    AccessXKeyboardEvent(dev, is_core ? KeyRelease : DeviceKeyRelease, key,
                         True);
    AccessXKeyboardEvent(dev, is_core ? KeyPress : DeviceKeyPress, key, True);
a694 2
ProcessInputProc backupproc;
xkbDeviceInfoPtr xkbPrivPtr = XKBDEVICEINFO(mouse);
d706 1
a706 20

    /* Guesswork. mostly. 
     * xkb actuall goes through some effort to transparently wrap the
     * processInputProcs (see XkbSetExtension). But we all love fun, so the
     * previous XKB implementation just hardcoded the CPPE call here instead
     * of unwrapping like anybody with any sense of decency would do. 
     * I got no clue what the correct thing to do is, but my guess is that
     * it's not hardcoding. I may be wrong. whatever it is, don't come whining
     * to me. I just work here. 
     *
     * Anyway. here's the old call, if you don't like the wrapping, revert it.
     *
     * CoreProcessPointerEvent(xE,mouse,count);
     *
     *          see. it's still steaming. told you. (whot)
     */
    UNWRAP_PROCESS_INPUT_PROC(mouse, xkbPrivPtr, backupproc);
    mouse->public.processInputProc(xE, mouse, count);
    COND_WRAP_PROCESS_INPUT_PROC(mouse, xkbPrivPtr,
				     backupproc, xkbUnwrapProc);
@


