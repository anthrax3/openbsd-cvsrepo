head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.8
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.6
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2014.05.02.19.27.51;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.08.24.19.44.52;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.32;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.11;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.27;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/************************************************************
Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.

Permission to use, copy, modify, and distribute this
software and its documentation for any purpose and without
fee is hereby granted, provided that the above copyright
notice appear in all copies and that both that copyright
notice and this permission notice appear in supporting
documentation, and that the name of Silicon Graphics not be
used in advertising or publicity pertaining to distribution
of the software without specific prior written permission.
Silicon Graphics makes no representation about the suitability
of this software for any purpose. It is provided "as is"
without any express or implied warranty.

SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <xkb-config.h>

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>
#include <math.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/keysym.h>
#include <X11/Xatom.h>
#include "misc.h"
#include "inputstr.h"
#include "opaque.h"
#include "property.h"
#include "scrnintstr.h"
#define	XKBSRV_NEED_FILE_FUNCS
#include <xkbsrv.h>
#include "xkbgeom.h"
#include <X11/extensions/XKMformat.h>
#include "xkbfile.h"
#include "xkb.h"

#define	CREATE_ATOM(s)	MakeAtom(s,sizeof(s)-1,1)

#if defined(__alpha) || defined(__alpha__)
#define	LED_COMPOSE	2
#define LED_CAPS	3
#define	LED_SCROLL	4
#define	LED_NUM		5
#define	PHYS_LEDS	0x1f
#else
#ifdef sun
#define LED_NUM		1
#define	LED_SCROLL	2
#define	LED_COMPOSE	3
#define LED_CAPS	4
#define	PHYS_LEDS	0x0f
#else
#define	LED_CAPS	1
#define	LED_NUM		2
#define	LED_SCROLL	3
#define	PHYS_LEDS	0x07
#endif
#endif

#define	MAX_TOC	16
typedef struct _SrvXkmInfo {
    DeviceIntPtr dev;
    FILE *file;
    XkbDescPtr xkb;
} SrvXkmInfo;

/***====================================================================***/

#ifndef XKB_DFLT_RULES_PROP
#define	XKB_DFLT_RULES_PROP	TRUE
#endif

const char *XkbBaseDirectory = XKB_BASE_DIRECTORY;
const char *XkbBinDirectory = XKB_BIN_DIRECTORY;
static int XkbWantAccessX = 0;

static char *XkbRulesDflt = NULL;
static char *XkbModelDflt = NULL;
static char *XkbLayoutDflt = NULL;
static char *XkbVariantDflt = NULL;
static char *XkbOptionsDflt = NULL;

static char *XkbRulesUsed = NULL;
static char *XkbModelUsed = NULL;
static char *XkbLayoutUsed = NULL;
static char *XkbVariantUsed = NULL;
static char *XkbOptionsUsed = NULL;

static XkbDescPtr xkb_cached_map = NULL;

static Bool XkbWantRulesProp = XKB_DFLT_RULES_PROP;

/***====================================================================***/

/**
 * Get the current default XKB rules.
 * Caller must free the data in rmlvo.
 */
void
XkbGetRulesDflts(XkbRMLVOSet * rmlvo)
{
    rmlvo->rules = strdup(XkbRulesDflt ? XkbRulesDflt : XKB_DFLT_RULES);
    rmlvo->model = strdup(XkbModelDflt ? XkbModelDflt : XKB_DFLT_MODEL);
    rmlvo->layout = strdup(XkbLayoutDflt ? XkbLayoutDflt : XKB_DFLT_LAYOUT);
    rmlvo->variant = strdup(XkbVariantDflt ? XkbVariantDflt : XKB_DFLT_VARIANT);
    rmlvo->options = strdup(XkbOptionsDflt ? XkbOptionsDflt : XKB_DFLT_OPTIONS);
}

void
XkbFreeRMLVOSet(XkbRMLVOSet * rmlvo, Bool freeRMLVO)
{
    if (!rmlvo)
        return;

    free(rmlvo->rules);
    free(rmlvo->model);
    free(rmlvo->layout);
    free(rmlvo->variant);
    free(rmlvo->options);

    if (freeRMLVO)
        free(rmlvo);
    else
        memset(rmlvo, 0, sizeof(XkbRMLVOSet));
}

static Bool
XkbWriteRulesProp(ClientPtr client, void *closure)
{
    int len, out;
    Atom name;
    char *pval;

    len = (XkbRulesUsed ? strlen(XkbRulesUsed) : 0);
    len += (XkbModelUsed ? strlen(XkbModelUsed) : 0);
    len += (XkbLayoutUsed ? strlen(XkbLayoutUsed) : 0);
    len += (XkbVariantUsed ? strlen(XkbVariantUsed) : 0);
    len += (XkbOptionsUsed ? strlen(XkbOptionsUsed) : 0);
    if (len < 1)
        return TRUE;

    len += 5;                   /* trailing NULs */

    name =
        MakeAtom(_XKB_RF_NAMES_PROP_ATOM, strlen(_XKB_RF_NAMES_PROP_ATOM), 1);
    if (name == None) {
        ErrorF("[xkb] Atom error: %s not created\n", _XKB_RF_NAMES_PROP_ATOM);
        return TRUE;
    }
    pval = (char *) malloc(len);
    if (!pval) {
        ErrorF("[xkb] Allocation error: %s proprerty not created\n",
               _XKB_RF_NAMES_PROP_ATOM);
        return TRUE;
    }
    out = 0;
    if (XkbRulesUsed) {
        strcpy(&pval[out], XkbRulesUsed);
        out += strlen(XkbRulesUsed);
    }
    pval[out++] = '\0';
    if (XkbModelUsed) {
        strcpy(&pval[out], XkbModelUsed);
        out += strlen(XkbModelUsed);
    }
    pval[out++] = '\0';
    if (XkbLayoutUsed) {
        strcpy(&pval[out], XkbLayoutUsed);
        out += strlen(XkbLayoutUsed);
    }
    pval[out++] = '\0';
    if (XkbVariantUsed) {
        strcpy(&pval[out], XkbVariantUsed);
        out += strlen(XkbVariantUsed);
    }
    pval[out++] = '\0';
    if (XkbOptionsUsed) {
        strcpy(&pval[out], XkbOptionsUsed);
        out += strlen(XkbOptionsUsed);
    }
    pval[out++] = '\0';
    if (out != len) {
        ErrorF("[xkb] Internal Error! bad size (%d!=%d) for _XKB_RULES_NAMES\n",
               out, len);
    }
    dixChangeWindowProperty(serverClient, screenInfo.screens[0]->root, name,
                            XA_STRING, 8, PropModeReplace, len, pval, TRUE);
    free(pval);
    return TRUE;
}

void
XkbInitRules(XkbRMLVOSet *rmlvo,
             const char *rules,
             const char *model,
             const char *layout,
             const char *variant,
             const char *options)
{
    rmlvo->rules = rules ? xnfstrdup(rules) : NULL;
    rmlvo->model = model ? xnfstrdup(model) : NULL;
    rmlvo->layout = layout ? xnfstrdup(layout) : NULL;
    rmlvo->variant = variant ? xnfstrdup(variant) : NULL;
    rmlvo->options = options ? xnfstrdup(options) : NULL;
}

static void
XkbSetRulesUsed(XkbRMLVOSet * rmlvo)
{
    free(XkbRulesUsed);
    XkbRulesUsed = (rmlvo->rules ? Xstrdup(rmlvo->rules) : NULL);
    free(XkbModelUsed);
    XkbModelUsed = (rmlvo->model ? Xstrdup(rmlvo->model) : NULL);
    free(XkbLayoutUsed);
    XkbLayoutUsed = (rmlvo->layout ? Xstrdup(rmlvo->layout) : NULL);
    free(XkbVariantUsed);
    XkbVariantUsed = (rmlvo->variant ? Xstrdup(rmlvo->variant) : NULL);
    free(XkbOptionsUsed);
    XkbOptionsUsed = (rmlvo->options ? Xstrdup(rmlvo->options) : NULL);
    if (XkbWantRulesProp)
        QueueWorkProc(XkbWriteRulesProp, NULL, NULL);
    return;
}

void
XkbSetRulesDflts(XkbRMLVOSet * rmlvo)
{
    if (rmlvo->rules) {
        free(XkbRulesDflt);
        XkbRulesDflt = Xstrdup(rmlvo->rules);
    }
    if (rmlvo->model) {
        free(XkbModelDflt);
        XkbModelDflt = Xstrdup(rmlvo->model);
    }
    if (rmlvo->layout) {
        free(XkbLayoutDflt);
        XkbLayoutDflt = Xstrdup(rmlvo->layout);
    }
    if (rmlvo->variant) {
        free(XkbVariantDflt);
        XkbVariantDflt = Xstrdup(rmlvo->variant);
    }
    if (rmlvo->options) {
        free(XkbOptionsDflt);
        XkbOptionsDflt = Xstrdup(rmlvo->options);
    }
    return;
}

void
XkbDeleteRulesUsed(void)
{
    free(XkbRulesUsed);
    XkbRulesUsed = NULL;
    free(XkbModelUsed);
    XkbModelUsed = NULL;
    free(XkbLayoutUsed);
    XkbLayoutUsed = NULL;
    free(XkbVariantUsed);
    XkbVariantUsed = NULL;
    free(XkbOptionsUsed);
    XkbOptionsUsed = NULL;
}

void
XkbDeleteRulesDflts(void)
{
    free(XkbRulesDflt);
    XkbRulesDflt = NULL;
    free(XkbModelDflt);
    XkbModelDflt = NULL;
    free(XkbLayoutDflt);
    XkbLayoutDflt = NULL;
    free(XkbVariantDflt);
    XkbVariantDflt = NULL;
    free(XkbOptionsDflt);
    XkbOptionsDflt = NULL;

    XkbFreeKeyboard(xkb_cached_map, XkbAllComponentsMask, TRUE);
    xkb_cached_map = NULL;
}

#define DIFFERS(a, b) (strcmp((a) ? (a) : "", (b) ? (b) : "") != 0)

static Bool
XkbCompareUsedRMLVO(XkbRMLVOSet * rmlvo)
{
    if (DIFFERS(rmlvo->rules, XkbRulesUsed) ||
        DIFFERS(rmlvo->model, XkbModelUsed) ||
        DIFFERS(rmlvo->layout, XkbLayoutUsed) ||
        DIFFERS(rmlvo->variant, XkbVariantUsed) ||
        DIFFERS(rmlvo->options, XkbOptionsUsed))
        return FALSE;
    return TRUE;
}

#undef DIFFERS

/***====================================================================***/

#include "xkbDflts.h"

static Bool
XkbInitKeyTypes(XkbDescPtr xkb)
{
    if (xkb->defined & XkmTypesMask)
        return TRUE;

    initTypeNames(NULL);
    if (XkbAllocClientMap(xkb, XkbKeyTypesMask, num_dflt_types) != Success)
        return FALSE;
    if (XkbCopyKeyTypes(dflt_types, xkb->map->types, num_dflt_types) != Success) {
        return FALSE;
    }
    xkb->map->size_types = xkb->map->num_types = num_dflt_types;
    return TRUE;
}

static void
XkbInitRadioGroups(XkbSrvInfoPtr xkbi)
{
    xkbi->nRadioGroups = 0;
    xkbi->radioGroups = NULL;
    return;
}

static Status
XkbInitCompatStructs(XkbDescPtr xkb)
{
    register int i;
    XkbCompatMapPtr compat;

    if (xkb->defined & XkmCompatMapMask)
        return TRUE;

    if (XkbAllocCompatMap(xkb, XkbAllCompatMask, num_dfltSI) != Success)
        return BadAlloc;
    compat = xkb->compat;
    if (compat->sym_interpret) {
        compat->num_si = num_dfltSI;
        memcpy((char *) compat->sym_interpret, (char *) dfltSI, sizeof(dfltSI));
    }
    for (i = 0; i < XkbNumKbdGroups; i++) {
        compat->groups[i] = compatMap.groups[i];
        if (compat->groups[i].vmods != 0) {
            unsigned mask;

            mask = XkbMaskForVMask(xkb, compat->groups[i].vmods);
            compat->groups[i].mask = compat->groups[i].real_mods | mask;
        }
        else
            compat->groups[i].mask = compat->groups[i].real_mods;
    }
    return Success;
}

static void
XkbInitSemantics(XkbDescPtr xkb)
{
    XkbInitKeyTypes(xkb);
    XkbInitCompatStructs(xkb);
    return;
}

/***====================================================================***/

static Status
XkbInitNames(XkbSrvInfoPtr xkbi)
{
    XkbDescPtr xkb;
    XkbNamesPtr names;
    Status rtrn;
    Atom unknown;

    xkb = xkbi->desc;
    if ((rtrn = XkbAllocNames(xkb, XkbAllNamesMask, 0, 0)) != Success)
        return rtrn;
    unknown = CREATE_ATOM("unknown");
    names = xkb->names;
    if (names->keycodes == None)
        names->keycodes = unknown;
    if (names->geometry == None)
        names->geometry = unknown;
    if (names->phys_symbols == None)
        names->phys_symbols = unknown;
    if (names->symbols == None)
        names->symbols = unknown;
    if (names->types == None)
        names->types = unknown;
    if (names->compat == None)
        names->compat = unknown;
    if (!(xkb->defined & XkmVirtualModsMask)) {
        if (names->vmods[vmod_NumLock] == None)
            names->vmods[vmod_NumLock] = CREATE_ATOM("NumLock");
        if (names->vmods[vmod_Alt] == None)
            names->vmods[vmod_Alt] = CREATE_ATOM("Alt");
        if (names->vmods[vmod_AltGr] == None)
            names->vmods[vmod_AltGr] = CREATE_ATOM("ModeSwitch");
    }

    if (!(xkb->defined & XkmIndicatorsMask) ||
        !(xkb->defined & XkmGeometryMask)) {
        initIndicatorNames(NULL, xkb);
        if (names->indicators[LED_CAPS - 1] == None)
            names->indicators[LED_CAPS - 1] = CREATE_ATOM("Caps Lock");
        if (names->indicators[LED_NUM - 1] == None)
            names->indicators[LED_NUM - 1] = CREATE_ATOM("Num Lock");
        if (names->indicators[LED_SCROLL - 1] == None)
            names->indicators[LED_SCROLL - 1] = CREATE_ATOM("Scroll Lock");
#ifdef LED_COMPOSE
        if (names->indicators[LED_COMPOSE - 1] == None)
            names->indicators[LED_COMPOSE - 1] = CREATE_ATOM("Compose");
#endif
    }

    if (xkb->geom != NULL)
        names->geometry = xkb->geom->name;
    else
        names->geometry = unknown;

    return Success;
}

static Status
XkbInitIndicatorMap(XkbSrvInfoPtr xkbi)
{
    XkbDescPtr xkb;
    XkbIndicatorPtr map;
    XkbSrvLedInfoPtr sli;

    xkb = xkbi->desc;
    if (XkbAllocIndicatorMaps(xkb) != Success)
        return BadAlloc;

    if (!(xkb->defined & XkmIndicatorsMask)) {
        map = xkb->indicators;
        map->phys_indicators = PHYS_LEDS;
        map->maps[LED_CAPS - 1].flags = XkbIM_NoExplicit;
        map->maps[LED_CAPS - 1].which_mods = XkbIM_UseLocked;
        map->maps[LED_CAPS - 1].mods.mask = LockMask;
        map->maps[LED_CAPS - 1].mods.real_mods = LockMask;

        map->maps[LED_NUM - 1].flags = XkbIM_NoExplicit;
        map->maps[LED_NUM - 1].which_mods = XkbIM_UseLocked;
        map->maps[LED_NUM - 1].mods.mask = 0;
        map->maps[LED_NUM - 1].mods.real_mods = 0;
        map->maps[LED_NUM - 1].mods.vmods = vmod_NumLockMask;

        map->maps[LED_SCROLL - 1].flags = XkbIM_NoExplicit;
        map->maps[LED_SCROLL - 1].which_mods = XkbIM_UseLocked;
        map->maps[LED_SCROLL - 1].mods.mask = Mod3Mask;
        map->maps[LED_SCROLL - 1].mods.real_mods = Mod3Mask;
    }

    sli = XkbFindSrvLedInfo(xkbi->device, XkbDfltXIClass, XkbDfltXIId, 0);
    if (sli)
        XkbCheckIndicatorMaps(xkbi->device, sli, XkbAllIndicatorsMask);

    return Success;
}

static Status
XkbInitControls(DeviceIntPtr pXDev, XkbSrvInfoPtr xkbi)
{
    XkbDescPtr xkb;
    XkbControlsPtr ctrls;

    xkb = xkbi->desc;
    /* 12/31/94 (ef) -- XXX! Should check if controls loaded from file */
    if (XkbAllocControls(xkb, XkbAllControlsMask) != Success)
        FatalError("Couldn't allocate keyboard controls\n");
    ctrls = xkb->ctrls;
    if (!(xkb->defined & XkmSymbolsMask))
        ctrls->num_groups = 1;
    ctrls->groups_wrap = XkbSetGroupInfo(1, XkbWrapIntoRange, 0);
    ctrls->internal.mask = 0;
    ctrls->internal.real_mods = 0;
    ctrls->internal.vmods = 0;
    ctrls->ignore_lock.mask = 0;
    ctrls->ignore_lock.real_mods = 0;
    ctrls->ignore_lock.vmods = 0;
    ctrls->enabled_ctrls = XkbAccessXTimeoutMask | XkbRepeatKeysMask |
        XkbMouseKeysAccelMask | XkbAudibleBellMask | XkbIgnoreGroupLockMask;
    if (XkbWantAccessX)
        ctrls->enabled_ctrls |= XkbAccessXKeysMask;
    AccessXInit(pXDev);
    return Success;
}

static Bool
InitKeyboardDeviceStructInternal(DeviceIntPtr dev, XkbRMLVOSet * rmlvo,
                                 const char *keymap, int keymap_length,
                                 BellProcPtr bell_func, KbdCtrlProcPtr ctrl_func)
{
    int i;
    unsigned int check;
    XkbSrvInfoPtr xkbi;
    XkbDescPtr xkb;
    XkbSrvLedInfoPtr sli;
    XkbChangesRec changes;
    XkbEventCauseRec cause;
    XkbRMLVOSet rmlvo_dflts = { NULL };

    BUG_RETURN_VAL(dev == NULL, FALSE);
    BUG_RETURN_VAL(dev->key != NULL, FALSE);
    BUG_RETURN_VAL(dev->kbdfeed != NULL, FALSE);
    BUG_RETURN_VAL(rmlvo && keymap, FALSE);

    if (!rmlvo && !keymap) {
        rmlvo = &rmlvo_dflts;
        XkbGetRulesDflts(rmlvo);
    }

    memset(&changes, 0, sizeof(changes));
    XkbSetCauseUnknown(&cause);

    dev->key = calloc(1, sizeof(*dev->key));
    if (!dev->key) {
        ErrorF("XKB: Failed to allocate key class\n");
        return FALSE;
    }
    dev->key->sourceid = dev->id;

    dev->kbdfeed = calloc(1, sizeof(*dev->kbdfeed));
    if (!dev->kbdfeed) {
        ErrorF("XKB: Failed to allocate key feedback class\n");
        goto unwind_key;
    }

    xkbi = calloc(1, sizeof(*xkbi));
    if (!xkbi) {
        ErrorF("XKB: Failed to allocate XKB info\n");
        goto unwind_kbdfeed;
    }
    dev->key->xkbInfo = xkbi;

    if (xkb_cached_map && (keymap || (rmlvo && !XkbCompareUsedRMLVO(rmlvo)))) {
        XkbFreeKeyboard(xkb_cached_map, XkbAllComponentsMask, TRUE);
        xkb_cached_map = NULL;
    }

    if (xkb_cached_map)
        LogMessageVerb(X_INFO, 4, "XKB: Reusing cached keymap\n");
    else {
        if (rmlvo)
            xkb_cached_map = XkbCompileKeymap(dev, rmlvo);
        else
            xkb_cached_map = XkbCompileKeymapFromString(dev, keymap, keymap_length);

        if (!xkb_cached_map) {
            ErrorF("XKB: Failed to compile keymap\n");
            goto unwind_info;
        }
    }

    xkb = XkbAllocKeyboard();
    if (!xkb) {
        ErrorF("XKB: Failed to allocate keyboard description\n");
        goto unwind_info;
    }

    if (!XkbCopyKeymap(xkb, xkb_cached_map)) {
        ErrorF("XKB: Failed to copy keymap\n");
        goto unwind_desc;
    }
    xkb->defined = xkb_cached_map->defined;
    xkb->flags = xkb_cached_map->flags;
    xkb->device_spec = xkb_cached_map->device_spec;
    xkbi->desc = xkb;

    if (xkb->min_key_code == 0)
        xkb->min_key_code = 8;
    if (xkb->max_key_code == 0)
        xkb->max_key_code = 255;

    i = XkbNumKeys(xkb) / 3 + 1;
    if (XkbAllocClientMap(xkb, XkbAllClientInfoMask, 0) != Success)
        goto unwind_desc;
    if (XkbAllocServerMap(xkb, XkbAllServerInfoMask, i) != Success)
        goto unwind_desc;

    xkbi->dfltPtrDelta = 1;
    xkbi->device = dev;

    XkbInitSemantics(xkb);
    XkbInitNames(xkbi);
    XkbInitRadioGroups(xkbi);

    XkbInitControls(dev, xkbi);

    XkbInitIndicatorMap(xkbi);

    XkbUpdateActions(dev, xkb->min_key_code, XkbNumKeys(xkb), &changes,
                     &check, &cause);

    if (!dev->focus)
        InitFocusClassDeviceStruct(dev);

    xkbi->kbdProc = ctrl_func;
    dev->kbdfeed->BellProc = bell_func;
    dev->kbdfeed->CtrlProc = XkbDDXKeybdCtrlProc;

    dev->kbdfeed->ctrl = defaultKeyboardControl;
    if (dev->kbdfeed->ctrl.autoRepeat)
        xkb->ctrls->enabled_ctrls |= XkbRepeatKeysMask;

    memcpy(dev->kbdfeed->ctrl.autoRepeats, xkb->ctrls->per_key_repeat,
           XkbPerKeyBitArraySize);

    sli = XkbFindSrvLedInfo(dev, XkbDfltXIClass, XkbDfltXIId, 0);
    if (sli)
        XkbCheckIndicatorMaps(dev, sli, XkbAllIndicatorsMask);
    else
        DebugF("XKB: No indicator feedback in XkbFinishInit!\n");

    dev->kbdfeed->CtrlProc(dev, &dev->kbdfeed->ctrl);

    if (rmlvo) {
        XkbSetRulesDflts(rmlvo);
        XkbSetRulesUsed(rmlvo);
    }
    XkbFreeRMLVOSet(&rmlvo_dflts, FALSE);

    return TRUE;

 unwind_desc:
    XkbFreeKeyboard(xkb, 0, TRUE);
 unwind_info:
    free(xkbi);
    dev->key->xkbInfo = NULL;
 unwind_kbdfeed:
    free(dev->kbdfeed);
    dev->kbdfeed = NULL;
 unwind_key:
    free(dev->key);
    dev->key = NULL;
    return FALSE;
}

_X_EXPORT Bool
InitKeyboardDeviceStruct(DeviceIntPtr dev, XkbRMLVOSet * rmlvo,
                         BellProcPtr bell_func, KbdCtrlProcPtr ctrl_func)
{
    return InitKeyboardDeviceStructInternal(dev, rmlvo,
                                            NULL, 0, bell_func, ctrl_func);
}

_X_EXPORT Bool
InitKeyboardDeviceStructFromString(DeviceIntPtr dev,
                                   const char *keymap, int keymap_length,
                                   BellProcPtr bell_func, KbdCtrlProcPtr ctrl_func)
{
    return InitKeyboardDeviceStructInternal(dev, NULL,
                                            keymap, keymap_length,
                                            bell_func, ctrl_func);
}

/***====================================================================***/

        /*
         * Be very careful about what does and doesn't get freed by this
         * function.  To reduce fragmentation, XkbInitDevice allocates a
         * single huge block per device and divides it up into most of the
         * fixed-size structures for the device.   Don't free anything that
         * is part of this larger block.
         */
void
XkbFreeInfo(XkbSrvInfoPtr xkbi)
{
    free(xkbi->radioGroups);
    xkbi->radioGroups = NULL;
    if (xkbi->mouseKeyTimer) {
        TimerFree(xkbi->mouseKeyTimer);
        xkbi->mouseKeyTimer = NULL;
    }
    if (xkbi->slowKeysTimer) {
        TimerFree(xkbi->slowKeysTimer);
        xkbi->slowKeysTimer = NULL;
    }
    if (xkbi->bounceKeysTimer) {
        TimerFree(xkbi->bounceKeysTimer);
        xkbi->bounceKeysTimer = NULL;
    }
    if (xkbi->repeatKeyTimer) {
        TimerFree(xkbi->repeatKeyTimer);
        xkbi->repeatKeyTimer = NULL;
    }
    if (xkbi->krgTimer) {
        TimerFree(xkbi->krgTimer);
        xkbi->krgTimer = NULL;
    }
    xkbi->beepType = _BEEP_NONE;
    if (xkbi->beepTimer) {
        TimerFree(xkbi->beepTimer);
        xkbi->beepTimer = NULL;
    }
    if (xkbi->desc) {
        XkbFreeKeyboard(xkbi->desc, XkbAllComponentsMask, TRUE);
        xkbi->desc = NULL;
    }
    free(xkbi);
    return;
}

/***====================================================================***/

extern int XkbDfltRepeatDelay;
extern int XkbDfltRepeatInterval;

extern unsigned short XkbDfltAccessXTimeout;
extern unsigned int XkbDfltAccessXTimeoutMask;
extern unsigned int XkbDfltAccessXFeedback;
extern unsigned char XkbDfltAccessXOptions;

int
XkbProcessArguments(int argc, char *argv[], int i)
{
    if (strncmp(argv[i], "-xkbdir", 7) == 0) {
        if (++i < argc) {
#if !defined(WIN32) && !defined(__CYGWIN__)
            if (getuid() != geteuid()) {
                LogMessage(X_WARNING,
                           "-xkbdir is not available for setuid X servers\n");
                return -1;
            }
            else
#endif
            {
                if (strlen(argv[i]) < PATH_MAX) {
                    XkbBaseDirectory = argv[i];
                    return 2;
                }
                else {
                    LogMessage(X_ERROR, "-xkbdir pathname too long\n");
                    return -1;
                }
            }
        }
        else {
            return -1;
        }
    }
    else if ((strncmp(argv[i], "-accessx", 8) == 0) ||
             (strncmp(argv[i], "+accessx", 8) == 0)) {
        int j = 1;

        if (argv[i][0] == '-')
            XkbWantAccessX = 0;
        else {
            XkbWantAccessX = 1;

            if (((i + 1) < argc) && (isdigit(argv[i + 1][0]))) {
                XkbDfltAccessXTimeout = atoi(argv[++i]);
                j++;

                if (((i + 1) < argc) && (isdigit(argv[i + 1][0]))) {
                    /*
                     * presumption that the reasonably useful range of
                     * values fits in 0..MAXINT since SunOS 4 doesn't
                     * have strtoul.
                     */
                    XkbDfltAccessXTimeoutMask = (unsigned int)
                        strtol(argv[++i], NULL, 16);
                    j++;
                }
                if (((i + 1) < argc) && (isdigit(argv[i + 1][0]))) {
                    if (argv[++i][0] == '1')
                        XkbDfltAccessXFeedback = XkbAccessXFeedbackMask;
                    else
                        XkbDfltAccessXFeedback = 0;
                    j++;
                }
                if (((i + 1) < argc) && (isdigit(argv[i + 1][0]))) {
                    XkbDfltAccessXOptions = (unsigned char)
                        strtol(argv[++i], NULL, 16);
                    j++;
                }
            }
        }
        return j;
    }
    if ((strcmp(argv[i], "-ardelay") == 0) || (strcmp(argv[i], "-ar1") == 0)) { /* -ardelay int */
        if (++i >= argc)
            UseMsg();
        else
            XkbDfltRepeatDelay = (long) atoi(argv[i]);
        return 2;
    }
    if ((strcmp(argv[i], "-arinterval") == 0) || (strcmp(argv[i], "-ar2") == 0)) {      /* -arinterval int */
        if (++i >= argc)
            UseMsg();
        else
            XkbDfltRepeatInterval = (long) atoi(argv[i]);
        return 2;
    }
    return 0;
}

void
XkbUseMsg(void)
{
    ErrorF
        ("[+-]accessx [ timeout [ timeout_mask [ feedback [ options_mask] ] ] ]\n");
    ErrorF("                       enable/disable accessx key sequences\n");
    ErrorF("-ardelay               set XKB autorepeat delay\n");
    ErrorF("-arinterval            set XKB autorepeat interval\n");
}
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d9 2
a10 2
documentation, and that the name of Silicon Graphics not be 
used in advertising or publicity pertaining to distribution 
d12 1
a12 1
Silicon Graphics makes no representation about the suitability 
d16 2
a17 2
SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d19 3
a21 3
GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
d679 3
a681 3
         * Be very careful about what does and doesn't get freed by this 
         * function.  To reduce fragmentation, XkbInitDevice allocates a 
         * single huge block per device and divides it up into most of the 
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d145 1
a145 1
XkbWriteRulesProp(ClientPtr client, pointer closure)
d209 15
d508 4
a511 3
_X_EXPORT Bool
InitKeyboardDeviceStruct(DeviceIntPtr dev, XkbRMLVOSet * rmlvo,
                         BellProcPtr bell_func, KbdCtrlProcPtr ctrl_func)
d525 1
d527 1
a527 1
    if (!rmlvo) {
d555 1
a555 1
    if (xkb_cached_map && !XkbCompareUsedRMLVO(rmlvo)) {
d563 5
a567 1
        xkb_cached_map = XkbCompileKeymap(dev, rmlvo);
d636 4
a639 2
    XkbSetRulesDflts(rmlvo);
    XkbSetRulesUsed(rmlvo);
d656 18
@


1.8
log
@Uodate to xserver 1.14.2. Tested by krw@@, shadchin@@, todd@@
@
text
@d254 15
d506 3
a508 2
    if (dev->key || dev->kbdfeed)
        return FALSE;
d762 2
a763 1
        XkbDfltRepeatDelay = (long) atoi(argv[i]);
d769 2
a770 1
        XkbDfltRepeatInterval = (long) atoi(argv[i]);
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d577 2
a578 1
    InitFocusClassDeviceStruct(dev);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d78 4
a81 4
typedef struct	_SrvXkmInfo {
	DeviceIntPtr	dev;
	FILE *		file;
	XkbDescPtr	xkb;
a83 1

d90 15
a104 15
char	*		XkbBaseDirectory=	XKB_BASE_DIRECTORY;
char	*		XkbBinDirectory=	XKB_BIN_DIRECTORY;
static int	 	XkbWantAccessX=		0;	

static char *		XkbRulesDflt=		NULL;
static char *		XkbModelDflt=		NULL;
static char *		XkbLayoutDflt=		NULL;
static char *		XkbVariantDflt=		NULL;
static char *		XkbOptionsDflt=		NULL;

static char *           XkbRulesUsed=   NULL;
static char *		XkbModelUsed=	NULL;
static char *		XkbLayoutUsed=	NULL;
static char *		XkbVariantUsed=	NULL;
static char *		XkbOptionsUsed=	NULL;
d106 1
a106 1
static XkbDescPtr	xkb_cached_map = NULL;
d108 1
a108 1
static Bool		XkbWantRulesProp=	XKB_DFLT_RULES_PROP;
d117 1
a117 1
XkbGetRulesDflts(XkbRMLVOSet *rmlvo)
d119 5
a123 16
    if (XkbRulesDflt)   rmlvo->rules = XkbRulesDflt;
    else                rmlvo->rules = XKB_DFLT_RULES;
    if (XkbModelDflt)	rmlvo->model= XkbModelDflt;
    else		rmlvo->model= XKB_DFLT_MODEL;
    if (XkbLayoutDflt)	rmlvo->layout= XkbLayoutDflt;
    else		rmlvo->layout= XKB_DFLT_LAYOUT;
    if (XkbVariantDflt)	rmlvo->variant= XkbVariantDflt;
    else		rmlvo->variant= XKB_DFLT_VARIANT;
    if (XkbOptionsDflt)	rmlvo->options= XkbOptionsDflt;
    else		rmlvo->options= XKB_DFLT_OPTIONS;

    rmlvo->rules = strdup(rmlvo->rules);
    rmlvo->model = strdup(rmlvo->model);
    rmlvo->layout = strdup(rmlvo->layout);
    rmlvo->variant = strdup(rmlvo->variant);
    rmlvo->options = strdup(rmlvo->options);
d127 1
a127 1
XkbFreeRMLVOSet(XkbRMLVOSet *rmlvo, Bool freeRMLVO)
d147 19
a165 18
int 			len,out;
Atom			name;
char *			pval;

    len= (XkbRulesUsed?strlen(XkbRulesUsed):0);
    len+= (XkbModelUsed?strlen(XkbModelUsed):0);
    len+= (XkbLayoutUsed?strlen(XkbLayoutUsed):0);
    len+= (XkbVariantUsed?strlen(XkbVariantUsed):0);
    len+= (XkbOptionsUsed?strlen(XkbOptionsUsed):0);
    if (len<1)
	return TRUE;

    len+= 5; /* trailing NULs */

    name= MakeAtom(_XKB_RF_NAMES_PROP_ATOM,strlen(_XKB_RF_NAMES_PROP_ATOM),1);
    if (name==None) {
	ErrorF("[xkb] Atom error: %s not created\n",_XKB_RF_NAMES_PROP_ATOM);
	return TRUE;
d167 1
a167 1
    pval= (char*) malloc(len);
d169 3
a171 3
	ErrorF("[xkb] Allocation error: %s proprerty not created\n",
						_XKB_RF_NAMES_PROP_ATOM);
	return TRUE;
d173 1
a173 1
    out= 0;
d175 2
a176 2
	strcpy(&pval[out],XkbRulesUsed);
	out+= strlen(XkbRulesUsed);
d178 1
a178 1
    pval[out++]= '\0';
d180 4
a183 4
	strcpy(&pval[out],XkbModelUsed);
	out+= strlen(XkbModelUsed);
    } 
    pval[out++]= '\0';
d185 2
a186 2
	strcpy(&pval[out],XkbLayoutUsed);
	out+= strlen(XkbLayoutUsed);
d188 1
a188 1
    pval[out++]= '\0';
d190 2
a191 2
	strcpy(&pval[out],XkbVariantUsed);
	out+= strlen(XkbVariantUsed);
d193 1
a193 1
    pval[out++]= '\0';
d195 2
a196 2
	strcpy(&pval[out],XkbOptionsUsed);
	out+= strlen(XkbOptionsUsed);
d198 4
a201 4
    pval[out++]= '\0';
    if (out!=len) {
	ErrorF("[xkb] Internal Error! bad size (%d!=%d) for _XKB_RULES_NAMES\n",
								out,len);
d203 2
a204 2
    dixChangeWindowProperty(serverClient, screenInfo.screens[0]->root, name, XA_STRING, 8,
			    PropModeReplace, len, pval, TRUE);
d210 1
a210 1
XkbSetRulesUsed(XkbRMLVOSet *rmlvo)
d213 1
a213 1
    XkbRulesUsed= (rmlvo->rules?Xstrdup(rmlvo->rules):NULL);
d215 1
a215 1
    XkbModelUsed= (rmlvo->model?Xstrdup(rmlvo->model):NULL);
d217 1
a217 1
    XkbLayoutUsed= (rmlvo->layout?Xstrdup(rmlvo->layout):NULL);
d219 1
a219 1
    XkbVariantUsed= (rmlvo->variant?Xstrdup(rmlvo->variant):NULL);
d221 1
a221 1
    XkbOptionsUsed= (rmlvo->options?Xstrdup(rmlvo->options):NULL);
d223 1
a223 1
	QueueWorkProc(XkbWriteRulesProp,NULL,NULL);
d228 1
a228 1
XkbSetRulesDflts(XkbRMLVOSet *rmlvo)
d232 1
a232 1
        XkbRulesDflt= Xstrdup(rmlvo->rules);
d235 2
a236 2
	free(XkbModelDflt);
	XkbModelDflt= Xstrdup(rmlvo->model);
d239 2
a240 2
	free(XkbLayoutDflt);
	XkbLayoutDflt= Xstrdup(rmlvo->layout);
d243 2
a244 2
	free(XkbVariantDflt);
	XkbVariantDflt= Xstrdup(rmlvo->variant);
d247 2
a248 2
	free(XkbOptionsDflt);
	XkbOptionsDflt= Xstrdup(rmlvo->options);
d274 1
a274 1
XkbCompareUsedRMLVO(XkbRMLVOSet *rmlvo)
d298 4
a301 5
    if (XkbAllocClientMap(xkb,XkbKeyTypesMask,num_dflt_types)!=Success)
	return FALSE;
    if (XkbCopyKeyTypes(dflt_types,xkb->map->types,num_dflt_types)!=
    								 Success) {
	return FALSE;
d303 1
a303 1
    xkb->map->size_types= xkb->map->num_types= num_dflt_types;
a314 1

d318 2
a319 2
register int 	i;
XkbCompatMapPtr	compat;
d324 2
a325 2
    if (XkbAllocCompatMap(xkb,XkbAllCompatMask,num_dfltSI)!=Success)
	return BadAlloc;
d328 2
a329 2
	compat->num_si = num_dfltSI;
	memcpy((char *)compat->sym_interpret,(char *)dfltSI,sizeof(dfltSI));
d331 10
a340 8
    for (i=0;i<XkbNumKbdGroups;i++) {
	compat->groups[i]= compatMap.groups[i];
	if (compat->groups[i].vmods!=0) {
	    unsigned mask;
	    mask= XkbMaskForVMask(xkb,compat->groups[i].vmods);
	    compat->groups[i].mask= compat->groups[i].real_mods|mask;
	}
	else compat->groups[i].mask= compat->groups[i].real_mods;
d358 9
a366 9
XkbDescPtr	xkb;
XkbNamesPtr	names;
Status		rtrn;
Atom		unknown;

    xkb= xkbi->desc;
    if ((rtrn=XkbAllocNames(xkb,XkbAllNamesMask,0,0))!=Success)
	return rtrn;
    unknown= CREATE_ATOM("unknown");
d368 12
a379 6
    if (names->keycodes==None)		names->keycodes= unknown;
    if (names->geometry==None)		names->geometry= unknown;
    if (names->phys_symbols==None)	names->phys_symbols= unknown;
    if (names->symbols==None)		names->symbols= unknown;
    if (names->types==None)		names->types= unknown;
    if (names->compat==None)		names->compat= unknown;
d381 6
a386 6
        if (names->vmods[vmod_NumLock]==None)
            names->vmods[vmod_NumLock]= CREATE_ATOM("NumLock");
        if (names->vmods[vmod_Alt]==None)
            names->vmods[vmod_Alt]= CREATE_ATOM("Alt");
        if (names->vmods[vmod_AltGr]==None)
            names->vmods[vmod_AltGr]= CREATE_ATOM("ModeSwitch");
d391 7
a397 7
        initIndicatorNames(NULL,xkb);
        if (names->indicators[LED_CAPS-1]==None)
            names->indicators[LED_CAPS-1] = CREATE_ATOM("Caps Lock");
        if (names->indicators[LED_NUM-1]==None)
            names->indicators[LED_NUM-1] = CREATE_ATOM("Num Lock");
        if (names->indicators[LED_SCROLL-1]==None)
            names->indicators[LED_SCROLL-1] = CREATE_ATOM("Scroll Lock");
d399 2
a400 2
        if (names->indicators[LED_COMPOSE-1]==None)
            names->indicators[LED_COMPOSE-1] = CREATE_ATOM("Compose");
d404 4
a407 3
    if (xkb->geom!=NULL)
	 names->geometry= xkb->geom->name;
    else names->geometry= unknown;
d415 7
a421 7
XkbDescPtr		xkb;
XkbIndicatorPtr		map;
XkbSrvLedInfoPtr	sli;

    xkb= xkbi->desc;
    if (XkbAllocIndicatorMaps(xkb)!=Success)
	return BadAlloc;
d424 1
a424 1
        map= xkb->indicators;
d426 15
a440 15
        map->maps[LED_CAPS-1].flags= XkbIM_NoExplicit;
        map->maps[LED_CAPS-1].which_mods= XkbIM_UseLocked;
        map->maps[LED_CAPS-1].mods.mask= LockMask;
        map->maps[LED_CAPS-1].mods.real_mods= LockMask;

        map->maps[LED_NUM-1].flags= XkbIM_NoExplicit;
        map->maps[LED_NUM-1].which_mods= XkbIM_UseLocked;
        map->maps[LED_NUM-1].mods.mask= 0;
        map->maps[LED_NUM-1].mods.real_mods= 0;
        map->maps[LED_NUM-1].mods.vmods= vmod_NumLockMask;

        map->maps[LED_SCROLL-1].flags= XkbIM_NoExplicit;
        map->maps[LED_SCROLL-1].which_mods= XkbIM_UseLocked;
        map->maps[LED_SCROLL-1].mods.mask= Mod3Mask;
        map->maps[LED_SCROLL-1].mods.real_mods= Mod3Mask;
d443 1
a443 1
    sli= XkbFindSrvLedInfo(xkbi->device,XkbDfltXIClass,XkbDfltXIId,0);
d445 1
a445 1
	XkbCheckIndicatorMaps(xkbi->device,sli,XkbAllIndicatorsMask);
d451 1
a451 1
XkbInitControls(DeviceIntPtr pXDev,XkbSrvInfoPtr xkbi)
d453 2
a454 2
XkbDescPtr	xkb;
XkbControlsPtr	ctrls;
d456 1
a456 1
    xkb= xkbi->desc;
d458 3
a460 3
    if (XkbAllocControls(xkb,XkbAllControlsMask)!=Success)
	FatalError("Couldn't allocate keyboard controls\n");
    ctrls= xkb->ctrls;
d463 1
a463 1
    ctrls->groups_wrap = XkbSetGroupInfo(1,XkbWrapIntoRange,0);
d470 2
a471 3
    ctrls->enabled_ctrls = XkbAccessXTimeoutMask|XkbRepeatKeysMask|
				XkbMouseKeysAccelMask|XkbAudibleBellMask|
				XkbIgnoreGroupLockMask;
d473 1
a473 1
	ctrls->enabled_ctrls|= XkbAccessXKeysMask;
d479 1
a479 1
InitKeyboardDeviceStruct(DeviceIntPtr dev, XkbRMLVOSet *rmlvo,
d482 1
a482 1
    int	i;
d492 1
a492 1
	return FALSE;
d494 1
a494 2
    if (!rmlvo)
    {
a498 1

d592 1
a592 1
	XkbCheckIndicatorMaps(dev, sli, XkbAllIndicatorsMask);
d596 1
a596 1
    dev->kbdfeed->CtrlProc(dev,&dev->kbdfeed->ctrl);
d604 1
a604 1
unwind_desc:
d606 1
a606 1
unwind_info:
d609 1
a609 1
unwind_kbdfeed:
d612 1
a612 1
unwind_key:
a617 1

d620 7
a626 7
	/*
	 * Be very careful about what does and doesn't get freed by this 
	 * function.  To reduce fragmentation, XkbInitDevice allocates a 
	 * single huge block per device and divides it up into most of the 
	 * fixed-size structures for the device.   Don't free anything that
	 * is part of this larger block.
	 */
d633 2
a634 2
	TimerFree(xkbi->mouseKeyTimer);
	xkbi->mouseKeyTimer= NULL;
d637 2
a638 2
	TimerFree(xkbi->slowKeysTimer);
	xkbi->slowKeysTimer= NULL;
d641 2
a642 2
	TimerFree(xkbi->bounceKeysTimer);
	xkbi->bounceKeysTimer= NULL;
d645 2
a646 2
	TimerFree(xkbi->repeatKeyTimer);
	xkbi->repeatKeyTimer= NULL;
d649 2
a650 2
	TimerFree(xkbi->krgTimer);
	xkbi->krgTimer= NULL;
d652 1
a652 1
    xkbi->beepType= _BEEP_NONE;
d654 2
a655 2
	TimerFree(xkbi->beepTimer);
	xkbi->beepTimer= NULL;
d658 2
a659 2
	XkbFreeKeyboard(xkbi->desc,XkbAllComponentsMask,TRUE);
	xkbi->desc= NULL;
d667 2
a668 2
extern int	XkbDfltRepeatDelay;
extern int	XkbDfltRepeatInterval;
d670 4
a673 4
extern unsigned short	XkbDfltAccessXTimeout;
extern unsigned int	XkbDfltAccessXTimeoutMask;
extern unsigned int	XkbDfltAccessXFeedback;
extern unsigned char	XkbDfltAccessXOptions;
d676 1
a676 1
XkbProcessArguments(int argc,char *argv[],int i)
d679 1
a679 1
	if(++i < argc) {
d681 6
a686 4
	    if (getuid() != geteuid()) {
		LogMessage(X_WARNING, "-xkbdir is not available for setuid X servers\n");
		return -1;
	    } else
d688 65
a752 63
	    {
		if (strlen(argv[i]) < PATH_MAX) {
		    XkbBaseDirectory= argv[i];
		    return 2;
	        } else {
		    LogMessage(X_ERROR, "-xkbdir pathname too long\n");
		    return -1;
		}
	    }
	}
	else {
	    return -1;
	}
    }
    else if ((strncmp(argv[i],"-accessx",8)==0)||
                 (strncmp(argv[i],"+accessx",8)==0)) {
	int j=1;	    
	if (argv[i][0]=='-')        
	    XkbWantAccessX= 0;
	else {
	    XkbWantAccessX= 1;
	    
	    if ( ((i+1)<argc) && (isdigit(argv[i+1][0])) ) {
		XkbDfltAccessXTimeout = atoi(argv[++i]);
		j++;

		if ( ((i+1)<argc) && (isdigit(argv[i+1][0])) ) {
		    /*
		     * presumption that the reasonably useful range of
		     * values fits in 0..MAXINT since SunOS 4 doesn't
		     * have strtoul.
		     */
		    XkbDfltAccessXTimeoutMask=(unsigned int)
					      strtol(argv[++i],NULL,16); 
		    j++;
		}
		if ( ((i+1)<argc) && (isdigit(argv[i+1][0])) ) {
		    if (argv[++i][0] == '1' ) 
			XkbDfltAccessXFeedback=XkbAccessXFeedbackMask;
		    else
			XkbDfltAccessXFeedback=0;
		    j++;
		}
		if ( ((i+1)<argc) && (isdigit(argv[i+1][0])) ) {
		    XkbDfltAccessXOptions=(unsigned char)
					   strtol(argv[++i],NULL,16);
		    j++;
		}
	    }
	}
	return j;
    }
    if ((strcmp(argv[i], "-ardelay") == 0) ||
        (strcmp (argv[i], "-ar1") == 0)) {	/* -ardelay int */
	if (++i >= argc) UseMsg ();
	XkbDfltRepeatDelay = (long)atoi(argv[i]);
	return 2;
    }
    if ((strcmp(argv[i], "-arinterval") == 0) ||
        (strcmp (argv[i], "-ar2") == 0)) {	/* -arinterval int */
	if (++i >= argc) UseMsg ();
	XkbDfltRepeatInterval = (long)atoi(argv[i]);
	return 2;
d760 2
a761 1
    ErrorF("[+-]accessx [ timeout [ timeout_mask [ feedback [ options_mask] ] ] ]\n");
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d224 1
a224 1
    XkbRulesUsed= (rmlvo->rules?_XkbDupString(rmlvo->rules):NULL);
d226 1
a226 1
    XkbModelUsed= (rmlvo->model?_XkbDupString(rmlvo->model):NULL);
d228 1
a228 1
    XkbLayoutUsed= (rmlvo->layout?_XkbDupString(rmlvo->layout):NULL);
d230 1
a230 1
    XkbVariantUsed= (rmlvo->variant?_XkbDupString(rmlvo->variant):NULL);
d232 1
a232 1
    XkbOptionsUsed= (rmlvo->options?_XkbDupString(rmlvo->options):NULL);
d243 1
a243 1
        XkbRulesDflt= _XkbDupString(rmlvo->rules);
d247 1
a247 1
	XkbModelDflt= _XkbDupString(rmlvo->model);
d251 1
a251 1
	XkbLayoutDflt= _XkbDupString(rmlvo->layout);
d255 1
a255 1
	XkbVariantDflt= _XkbDupString(rmlvo->variant);
d259 1
a259 1
	XkbOptionsDflt= _XkbDupString(rmlvo->options);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d46 1
d144 5
a148 5
    xfree(rmlvo->rules);
    xfree(rmlvo->model);
    xfree(rmlvo->layout);
    xfree(rmlvo->variant);
    xfree(rmlvo->options);
d151 1
a151 1
        xfree(rmlvo);
d178 1
a178 1
    pval= (char*) xalloc(len);
d214 1
a214 1
    dixChangeWindowProperty(serverClient, WindowTable[0], name, XA_STRING, 8,
d216 1
a216 1
    xfree(pval);
d223 1
a223 2
    if (XkbRulesUsed)
        xfree(XkbRulesUsed);
d225 1
a225 2
    if (XkbModelUsed)
	xfree(XkbModelUsed);
d227 1
a227 2
    if (XkbLayoutUsed)
	xfree(XkbLayoutUsed);
d229 1
a229 2
    if (XkbVariantUsed)
	xfree(XkbVariantUsed);
d231 1
a231 2
    if (XkbOptionsUsed)
	xfree(XkbOptionsUsed);
d242 1
a242 2
        if (XkbRulesDflt)
	    xfree(XkbRulesDflt);
d246 1
a246 2
	if (XkbModelDflt)
	    xfree(XkbModelDflt);
d250 1
a250 2
	if (XkbLayoutDflt)
	    xfree(XkbLayoutDflt);
d254 1
a254 2
	if (XkbVariantDflt)
	    xfree(XkbVariantDflt);
d258 1
a258 2
	if (XkbOptionsDflt)
	    xfree(XkbOptionsDflt);
d267 1
a267 1
    xfree(XkbRulesDflt);
d269 1
a269 1
    xfree(XkbModelDflt);
d271 1
a271 1
    xfree(XkbLayoutDflt);
d273 1
a273 1
    xfree(XkbVariantDflt);
d275 1
a275 1
    xfree(XkbOptionsDflt);
d509 1
a509 1
    dev->key = xcalloc(1, sizeof(*dev->key));
d516 1
a516 1
    dev->kbdfeed = xcalloc(1, sizeof(*dev->kbdfeed));
d522 1
a522 1
    xkbi = xcalloc(1, sizeof(*xkbi));
d614 1
a614 1
    xfree(xkbi);
d617 1
a617 1
    xfree(dev->kbdfeed);
d620 1
a620 1
    xfree(dev->key);
d638 2
a639 4
    if (xkbi->radioGroups) {
	xfree(xkbi->radioGroups);
	xkbi->radioGroups= NULL;
    }
d669 1
a669 1
    xfree(xkbi);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a30 1
#ifdef HAVE_XKB_CONFIG_H
a31 1
#endif
a37 1
#define NEED_EVENTS 1
a85 24
#ifndef XKB_BASE_DIRECTORY
#define	XKB_BASE_DIRECTORY	"/usr/lib/X11/xkb"
#endif
#ifndef XKB_BIN_DIRECTORY
#define	XKB_BIN_DIRECTORY	XKB_BASE_DIRECTORY
#endif
#ifndef XKB_DFLT_RULES_FILE
#define	XKB_DFLT_RULES_FILE	"xorg"
#endif
#ifndef XKB_DFLT_KB_LAYOUT
#define	XKB_DFLT_KB_LAYOUT	"us"
#endif
#ifndef XKB_DFLT_KB_MODEL
#define	XKB_DFLT_KB_MODEL	"dflt"
#endif
#ifndef XKB_DFLT_KB_VARIANT
#define	XKB_DFLT_KB_VARIANT	NULL
#endif
#ifndef XKB_DFLT_KB_OPTIONS
#define	XKB_DFLT_KB_OPTIONS	NULL
#endif
#ifndef XKB_DFLT_DISABLED
#define	XKB_DFLT_DISABLED	True
#endif
d87 1
a87 1
#define	XKB_DFLT_RULES_PROP	True
d94 1
a94 2
static Bool		rulesDefined=		False;
static char *		XkbRulesFile=		NULL;
d100 1
d106 1
a106 1
static XkbDescPtr       xkb_cached_map = NULL;
a107 1
_X_EXPORT Bool		noXkbExtension=		XKB_DFLT_DISABLED;
d112 27
a138 2
static char *
XkbGetRulesDflts(XkbRF_VarDefsPtr defs)
d140 13
a152 9
    if (XkbModelDflt)	defs->model= XkbModelDflt;
    else		defs->model= XKB_DFLT_KB_MODEL;
    if (XkbLayoutDflt)	defs->layout= XkbLayoutDflt;
    else		defs->layout= XKB_DFLT_KB_LAYOUT;
    if (XkbVariantDflt)	defs->variant= XkbVariantDflt;
    else		defs->variant= XKB_DFLT_KB_VARIANT;
    if (XkbOptionsDflt)	defs->options= XkbOptionsDflt;
    else		defs->options= XKB_DFLT_KB_OPTIONS;
    return (rulesDefined?XkbRulesFile:XKB_DFLT_RULES_FILE);
d162 1
a162 3
    if (rulesDefined && (!XkbRulesFile))
	return False;
    len= (XkbRulesFile?strlen(XkbRulesFile):strlen(XKB_DFLT_RULES_FILE));
d168 1
a168 1
	return True;
d175 1
a175 1
	return True;
d181 1
a181 1
	return True;
d184 3
a186 6
    if (XkbRulesFile) {
	strcpy(&pval[out],XkbRulesFile);
	out+= strlen(XkbRulesFile);
    } else {
	strcpy(&pval[out],XKB_DFLT_RULES_FILE);
	out+= strlen(XKB_DFLT_RULES_FILE);
d214 1
a214 1
			    PropModeReplace, len, pval, True);
d216 1
a216 1
    return True;
d220 1
a220 1
XkbSetRulesUsed(XkbRF_VarDefsPtr defs)
d222 3
d226 2
a227 2
	_XkbFree(XkbModelUsed);
    XkbModelUsed= (defs->model?_XkbDupString(defs->model):NULL);
d229 2
a230 2
	_XkbFree(XkbLayoutUsed);
    XkbLayoutUsed= (defs->layout?_XkbDupString(defs->layout):NULL);
d232 2
a233 2
	_XkbFree(XkbVariantUsed);
    XkbVariantUsed= (defs->variant?_XkbDupString(defs->variant):NULL);
d235 2
a236 2
	_XkbFree(XkbOptionsUsed);
    XkbOptionsUsed= (defs->options?_XkbDupString(defs->options):NULL);
d242 2
a243 11
/**
 * Set the default RMLVO for the next device to be initialised.
 * If a parameter is NULL, the previous setting will be used. Use empty
 * strings if you want to delete a previous setting.
 *
 * If @@rulesFile is NULL and no previous @@rulesFile has been set, the
 * built-in default is chosen as default.
 */
_X_EXPORT void
XkbSetRulesDflts(char *rulesFile,char *model,char *layout,
					char *variant,char *options)
d245 4
a248 13
    if (!rulesFile && !XkbRulesFile)
    {
	LogMessage(X_WARNING, "[xkb] No rule given, and no previous rule "
		              "defined. Defaulting to '%s'.\n",
                              XKB_DFLT_RULES_FILE);
	rulesFile = XKB_DFLT_RULES_FILE;
    }

    if (rulesFile) {
	if (XkbRulesFile)
	    _XkbFree(XkbRulesFile);
	XkbRulesFile= _XkbDupString(rulesFile);
	rulesDefined= True;
d250 1
a250 2

    if (model) {
d252 2
a253 2
	    _XkbFree(XkbModelDflt);
	XkbModelDflt= _XkbDupString(model);
d255 1
a255 1
    if (layout) {
d257 2
a258 2
	    _XkbFree(XkbLayoutDflt);
	XkbLayoutDflt= _XkbDupString(layout);
d260 1
a260 1
    if (variant) {
d262 2
a263 2
	    _XkbFree(XkbVariantDflt);
	XkbVariantDflt= _XkbDupString(variant);
d265 1
a265 1
    if (options) {
d267 2
a268 2
	    _XkbFree(XkbOptionsDflt);
	XkbOptionsDflt= _XkbDupString(options);
d274 1
a274 1
XkbDeleteRulesDflts()
d276 3
a278 3
    _XkbFree(XkbRulesFile);
    XkbRulesFile = NULL;
    _XkbFree(XkbModelDflt);
d280 1
a280 1
    _XkbFree(XkbLayoutDflt);
d282 1
a282 1
    _XkbFree(XkbVariantDflt);
d284 1
a284 1
    _XkbFree(XkbOptionsDflt);
d287 1
a287 1
    XkbFreeKeyboard(xkb_cached_map, XkbAllComponentsMask, True);
d291 16
d315 1
a315 1
        return True;
d319 1
a319 1
	return False;
d322 1
a322 1
	return False;
d325 1
a325 1
    return True;
d344 1
a344 1
        return True;
d492 3
a494 2
void
XkbInitDevice(DeviceIntPtr pXDev)
d496 11
a506 10
int			i;
XkbSrvInfoPtr		xkbi;
XkbChangesRec		changes;
unsigned		check;
XkbEventCauseRec	cause;

    bzero(&changes,sizeof(XkbChangesRec));
    pXDev->key->xkbInfo= xkbi= _XkbTypedCalloc(1,XkbSrvInfoRec);
    if ( xkbi ) {
	XkbDescPtr	xkb;
d508 4
a511 69
        if (xkb_cached_map) {
            xkbi->desc = xkb_cached_map;
            xkb_cached_map = NULL;
        }
        else {
            xkbi->desc= XkbAllocKeyboard();
            if (!xkbi->desc)
                FatalError("Couldn't allocate keyboard description\n");
            xkbi->desc->min_key_code = pXDev->key->curKeySyms.minKeyCode;
            xkbi->desc->max_key_code = pXDev->key->curKeySyms.maxKeyCode;
        }
	xkb= xkbi->desc;
	if (xkb->min_key_code == 0)
	    xkb->min_key_code = pXDev->key->curKeySyms.minKeyCode;
	if (xkb->max_key_code == 0)
	    xkb->max_key_code = pXDev->key->curKeySyms.maxKeyCode;
	if ((pXDev->key->curKeySyms.minKeyCode!=xkbi->desc->min_key_code)||
	    (pXDev->key->curKeySyms.maxKeyCode!=xkbi->desc->max_key_code)) {
	    /* 12/9/95 (ef) -- XXX! Maybe we should try to fix up one or */
	    /*                 the other here, but for now just complain */
	    /*                 can't just update the core range without */
	    /*                 reallocating the KeySymsRec (pain)       */
	    ErrorF("[xkb] Internal Error!! XKB and core keymap have different range\n");
	}
	if (XkbAllocClientMap(xkb,XkbAllClientInfoMask,0)!=Success)
	    FatalError("Couldn't allocate client map in XkbInitDevice\n");
	i= XkbNumKeys(xkb)/3+1;
	if (XkbAllocServerMap(xkb,XkbAllServerInfoMask,i)!=Success)
	    FatalError("Couldn't allocate server map in XkbInitDevice\n");

	xkbi->dfltPtrDelta=1;
	xkbi->device = pXDev;

	XkbInitSemantics(xkb);
	XkbInitNames(xkbi);
	XkbInitRadioGroups(xkbi);

	/* 12/31/94 (ef) -- XXX! Should check if state loaded from file */
	bzero(&xkbi->state,sizeof(XkbStateRec));

	XkbInitControls(pXDev,xkbi);

        if (xkb->defined & XkmSymbolsMask)
            memcpy(pXDev->key->modifierMap, xkb->map->modmap,
                   xkb->max_key_code + 1);
        else
            memcpy(xkb->map->modmap, pXDev->key->modifierMap,
                   xkb->max_key_code + 1);

	XkbInitIndicatorMap(xkbi);

	XkbDDXInitDevice(pXDev);

        if (xkb->defined & XkmSymbolsMask)
            XkbUpdateCoreDescription(pXDev, True);
        else
            XkbUpdateKeyTypesFromCore(pXDev, xkb->min_key_code,
                                      XkbNumKeys(xkb), &changes);

	XkbSetCauseUnknown(&cause);
	XkbUpdateActions(pXDev,xkb->min_key_code, XkbNumKeys(xkb),&changes,
								&check,&cause);
        /* For sanity.  The first time the connection
         * is opened, the client side min and max are set
         * using QueryMinMaxKeyCodes() which grabs them 
	 * from pXDev.
	 */
	pXDev->key->curKeySyms.minKeyCode = xkb->min_key_code;
	pXDev->key->curKeySyms.maxKeyCode = xkb->max_key_code;
a512 2
    return;
}
a513 4
#if MAP_LENGTH > XkbMaxKeyCount
#undef  XkbMaxKeyCount
#define XkbMaxKeyCount MAP_LENGTH
#endif
d515 7
a521 74
_X_EXPORT Bool
XkbInitKeyboardDeviceStruct(
    DeviceIntPtr		dev,
    XkbComponentNamesPtr	names,
    KeySymsPtr                  pSymsIn,
    CARD8                       pModsIn[],
    void                        (*bellProc)(
        int /*percent*/,
        DeviceIntPtr /*device*/,
        pointer /*ctrl*/,
        int),
    void                        (*ctrlProc)(
        DeviceIntPtr /*device*/,
        KeybdCtrl * /*ctrl*/))
{
KeySymsRec		tmpSyms,*pSyms;
CARD8			tmpMods[XkbMaxLegalKeyCode+1],*pMods;
char			name[PATH_MAX],*rules;
Bool			ok=False;
XkbRF_VarDefsRec	defs;
XkbDescPtr              xkb;

    if ((dev->key!=NULL)||(dev->kbdfeed!=NULL))
	return False;
    pSyms= pSymsIn;
    pMods= pModsIn;
    bzero(&defs,sizeof(XkbRF_VarDefsRec));
    rules= XkbGetRulesDflts(&defs);

    /*
     * The strings are duplicated because it is not guaranteed that
     * they are allocated, or that they are allocated for every server
     * generation. Eventually they will be freed at the end of this
     * function.
     */
    names->keymap = NULL;
    if (names->keycodes) names->keycodes = _XkbDupString(names->keycodes);
    if (names->types) names->types = _XkbDupString(names->types);
    if (names->compat) names->compat = _XkbDupString(names->compat);
    if (names->geometry) names->geometry = _XkbDupString(names->geometry);
    if (names->symbols) names->symbols = _XkbDupString(names->symbols);

    if (defs.model && defs.layout && rules) {
	XkbComponentNamesRec	rNames;
	bzero(&rNames,sizeof(XkbComponentNamesRec));
	if (XkbDDXNamesFromRules(dev,rules,&defs,&rNames)) {
	    if (rNames.keycodes) {
		if (!names->keycodes)
		    names->keycodes =  rNames.keycodes;
		else
		    _XkbFree(rNames.keycodes);
	    }
	    if (rNames.types) {
		if (!names->types)
		    names->types = rNames.types;
		else  _XkbFree(rNames.types);
	    }
	    if (rNames.compat) {
		if (!names->compat) 
		    names->compat =  rNames.compat;
		else  _XkbFree(rNames.compat);
	    }
	    if (rNames.symbols) {
		if (!names->symbols)
		    names->symbols =  rNames.symbols;
		else _XkbFree(rNames.symbols);
	    }
	    if (rNames.geometry) {
		if (!names->geometry)
		    names->geometry = rNames.geometry;
		else _XkbFree(rNames.geometry);
	    }
	    XkbSetRulesUsed(&defs);
	}
d523 1
d525 5
a529 2
    ok = (Bool) XkbDDXLoadKeymapByNames(dev,names,XkmAllIndicesMask,0,
                                        &xkb,name,PATH_MAX);
d531 6
a536 2
    if (ok && (xkb!=NULL)) {
	KeyCode		minKC,maxKC;
d538 3
a540 32
	minKC= xkb->min_key_code;
	maxKC= xkb->max_key_code;
	if (XkbIsLegalKeycode(minKC)&&XkbIsLegalKeycode(maxKC)&&(minKC<=maxKC)&&
	    ((minKC!=pSyms->minKeyCode)||(maxKC!=pSyms->maxKeyCode))) {
	    if (xkb->map!=NULL) {
		KeySym	*inSym,*outSym;
		int	width= pSymsIn->mapWidth;

		tmpSyms.minKeyCode= minKC;
		tmpSyms.maxKeyCode= maxKC;

		if (minKC<pSymsIn->minKeyCode)
		    minKC= pSymsIn->minKeyCode;
		if (maxKC>pSymsIn->maxKeyCode)
		    maxKC= pSymsIn->maxKeyCode;

		tmpSyms.mapWidth= width;
		tmpSyms.map= _XkbTypedCalloc(width*XkbNumKeys(xkb),KeySym);
		inSym= &pSymsIn->map[(minKC-pSymsIn->minKeyCode)*width];
		outSym= &tmpSyms.map[(minKC-tmpSyms.minKeyCode)*width];
		memcpy(outSym,inSym,((maxKC-minKC+1)*width)*sizeof(KeySym));
		pSyms= &tmpSyms;
	    }
	    if ((xkb->map!=NULL)&&(xkb->map->modmap!=NULL)) {
		bzero(tmpMods,XkbMaxKeyCount);
		memcpy(tmpMods,xkb->map->modmap,maxKC+1);
		pMods= tmpMods;
	    }
	}
        /* Store the map here so we can pick it back up in XkbInitDevice.
         * Sigh. */
        xkb_cached_map = xkb;
d542 3
d546 16
a561 1
	LogMessage(X_WARNING, "Couldn't load XKB keymap, falling back to pre-XKB keymap\n");
d563 31
a593 17
    ok= InitKeyboardDeviceStruct((DevicePtr)dev,pSyms,pMods,bellProc,ctrlProc);
    xkb_cached_map = NULL;
    if ((pSyms==&tmpSyms)&&(pSyms->map!=NULL)) {
	_XkbFree(pSyms->map);
	pSyms->map= NULL;
    }

    if (names->keycodes) _XkbFree(names->keycodes);
    names->keycodes = NULL;
    if (names->types) _XkbFree(names->types);
    names->types = NULL;
    if (names->compat) _XkbFree(names->compat);
    names->compat = NULL;
    if (names->geometry) _XkbFree(names->geometry);
    names->geometry = NULL;
    if (names->symbols) _XkbFree(names->symbols);
    names->symbols = NULL;
d595 3
a597 2
    return ok;
}
d599 3
a601 1
/***====================================================================***/
d603 2
a604 24
	/*
	 * InitKeyClassDeviceStruct initializes the key class before it
	 * initializes the keyboard feedback class for a device. 
	 * UpdateActions can't set up the correct autorepeat for keyboard 
	 * initialization because the keyboard feedback isn't created yet.   
	 * Instead, UpdateActions notes the "correct" autorepeat in the 
	 * SrvInfo structure and InitKbdFeedbackClass calls UpdateAutoRepeat 
	 * to apply the computed autorepeat once the feedback class exists.
	 *
	 * DIX will apply the changed autorepeat, so there's no need to
	 * do so here.   This function returns True if both RepeatKeys and
	 * the core protocol autorepeat ctrls are set (i.e. should use 
	 * software autorepeat), false otherwise.
	 *
	 * This function also computes the autorepeat accelerators for the
	 * default indicator feedback.
	 */
int
XkbFinishDeviceInit(DeviceIntPtr pXDev)
{
XkbSrvInfoPtr		xkbi;
XkbDescPtr		xkb;
int			softRepeat;
XkbSrvLedInfoPtr	sli;
d606 26
a631 26
    xkbi = NULL;
    if (pXDev && pXDev->key && pXDev->key->xkbInfo && pXDev->kbdfeed) {
	xkbi= pXDev->key->xkbInfo;
	xkb= xkbi->desc;
        /* If we come from DeepCopyDeviceClasses, the CtrlProc was already set
         * to XkbDDXKeybdCtrlProc, overwriting it leads to happy recursion.
         */
	if (pXDev->kbdfeed && pXDev->kbdfeed->CtrlProc != XkbDDXKeybdCtrlProc) {
	    xkbi->kbdProc= pXDev->kbdfeed->CtrlProc;
	    pXDev->kbdfeed->CtrlProc= XkbDDXKeybdCtrlProc;
	}
	if (pXDev->kbdfeed->ctrl.autoRepeat)
	    xkb->ctrls->enabled_ctrls|= XkbRepeatKeysMask;
	softRepeat= (xkb->ctrls->enabled_ctrls&XkbRepeatKeysMask)!=0;
	if (pXDev->kbdfeed) {
	    memcpy(pXDev->kbdfeed->ctrl.autoRepeats,
		   xkb->ctrls->per_key_repeat,XkbPerKeyBitArraySize);
	    softRepeat= softRepeat&&pXDev->kbdfeed->ctrl.autoRepeat;
	}
    }
    else softRepeat= 0;
    sli= XkbFindSrvLedInfo(pXDev,XkbDfltXIClass,XkbDfltXIId,0);
    if (sli && xkbi)
	XkbCheckIndicatorMaps(xkbi->device,sli,XkbAllIndicatorsMask);
    else DebugF("[xkb] No indicator feedback in XkbFinishInit (shouldn't happen)!\n");
    return softRepeat;
d634 3
d648 1
a648 1
	_XkbFree(xkbi->radioGroups);
d677 1
a677 1
	XkbFreeKeyboard(xkbi->desc,XkbAllComponentsMask,True);
d680 1
a680 1
    _XkbFree(xkbi);
d697 1
a697 9
    if (strcmp(argv[i],"-kb")==0) {
	noXkbExtension= True;
	return 1;
    }
    else if (strcmp(argv[i],"+kb")==0) {
	noXkbExtension= False;
	return 1;
    }
    else if (strncmp(argv[i], "-xkbdir", 7) == 0) {
a774 2
    ErrorF("-kb                    disable the X Keyboard Extension\n");
    ErrorF("+kb                    enable the X Keyboard Extension\n");
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d58 1
a58 8
#ifdef sgi
#define LED_CAPS	5
#define	LED_NUM		6
#define	LED_SCROLL	7
#define	PHYS_LEDS	0x7f
#define	LED_COMPOSE	8
#else
#if defined(ultrix) || defined(__osf__) || defined(__alpha) || defined(__alpha__)
a77 1
#endif
d96 1
a96 1
#define	XKB_DFLT_RULES_FILE	"rules"
d175 1
a175 1
	ErrorF("Atom error: %s not created\n",_XKB_RF_NAMES_PROP_ATOM);
d180 1
a180 1
	ErrorF("Allocation error: %s proprerty not created\n",
d214 1
a214 1
	ErrorF("Internal Error! bad size (%d!=%d) for _XKB_RULES_NAMES\n",
d243 8
d255 15
a269 4
    if (XkbRulesFile)
	_XkbFree(XkbRulesFile);
    XkbRulesFile= _XkbDupString(rulesFile);
    rulesDefined= True;
d293 18
d532 1
a532 1
	    ErrorF("Internal Error!! XKB and core keymap have different range\n");
d758 4
a761 1
	if (pXDev->kbdfeed) {
d778 1
a778 1
    else DebugF("No indicator feedback in XkbFinishInit (shouldn't happen)!\n");
@


1.1
log
@Initial revision
@
text
@d50 2
a51 2
#include <X11/extensions/XKBsrv.h>
#include <X11/extensions/XKBgeom.h>
d53 1
a53 1
#include <X11/extensions/XKBfile.h>
d91 1
a91 1
	XkbFileInfo	xkbinfo;
d127 1
a127 2
int	 		XkbWantAccessX=		0;	
static XkbFileInfo *	_XkbInitFileInfo=	NULL;
d136 4
a139 4
char *			XkbModelUsed=	NULL;
char *			XkbLayoutUsed=	NULL;
char *			XkbVariantUsed=	NULL;
char *			XkbOptionsUsed=	NULL;
d141 1
a141 2
int			_XkbClientMajor=	XkbMajorVersion;
int			_XkbClientMinor=	XkbMinorVersion;
d144 1
a144 1
Bool			XkbWantRulesProp=	XKB_DFLT_RULES_PROP;
d148 1
a148 1
char *
d162 1
a162 1
Bool
d186 1
a186 1
    pval= (char*) ALLOCATE_LOCAL(len);
d225 3
a227 3
    ChangeWindowProperty(WindowTable[0],name,XA_STRING,8,PropModeReplace,
							len,pval,True);
    DEALLOCATE_LOCAL(pval);
d231 1
a231 1
void
a283 4
#if defined(luna)
#define	XKB_DDX_PERMANENT_LOCK	1
#endif

a285 3
/* A dummy to keep the compiler quiet */
pointer xkbBogus = &indicators;

d287 1
a287 1
XkbInitKeyTypes(XkbDescPtr xkb,SrvXkmInfo *file)
d289 3
a291 2
    if (file->xkbinfo.defined&XkmTypesMask)
	return True;
d304 1
a304 1
XkbInitRadioGroups(XkbSrvInfoPtr xkbi,SrvXkmInfo *file)
d313 1
a313 1
XkbInitCompatStructs(XkbDescPtr xkb,SrvXkmInfo *file)
d318 3
a320 2
    if (file->xkbinfo.defined&XkmCompatMapMask)
	return Success;
d341 1
a341 1
XkbInitSemantics(XkbDescPtr xkb,SrvXkmInfo *file)
d343 2
a344 2
    XkbInitKeyTypes(xkb,file);
    XkbInitCompatStructs(xkb,file);
d351 1
a351 1
XkbInitNames(XkbSrvInfoPtr xkbi,SrvXkmInfo *file)
d369 18
a386 18
    if ((file->xkbinfo.defined&XkmVirtualModsMask)==0) {
	if (names->vmods[vmod_NumLock]==None)
	    names->vmods[vmod_NumLock]= CREATE_ATOM("NumLock");
	if (names->vmods[vmod_Alt]==None)
	    names->vmods[vmod_Alt]= CREATE_ATOM("Alt");
	if (names->vmods[vmod_AltGr]==None)
	    names->vmods[vmod_AltGr]= CREATE_ATOM("ModeSwitch");
    }

    if (((file->xkbinfo.defined&XkmIndicatorsMask)==0)||
	((file->xkbinfo.defined&XkmGeometryMask)==0)) {
	initIndicatorNames(NULL,xkb);
	if (names->indicators[LED_CAPS-1]==None)
	    names->indicators[LED_CAPS-1] = CREATE_ATOM("Caps Lock");
	if (names->indicators[LED_NUM-1]==None)
	    names->indicators[LED_NUM-1] = CREATE_ATOM("Num Lock");
	if (names->indicators[LED_SCROLL-1]==None)
	    names->indicators[LED_SCROLL-1] = CREATE_ATOM("Scroll Lock");
d388 2
a389 2
	if (names->indicators[LED_COMPOSE-1]==None)
	    names->indicators[LED_COMPOSE-1] = CREATE_ATOM("Compose");
d392 1
a392 9
#ifdef DEBUG_RADIO_GROUPS
    if (names->num_rg<1) {
	names->radio_groups= (Atom *)_XkbCalloc(RG_COUNT, sizeof(Atom));
	if (names->radio_groups) {
	    names->num_rg = RG_COUNT;
	    names->radio_groups[RG_BOGUS_FUNCTION_GROUP]= CREATE_ATOM("BOGUS");
	}
    }
#endif
d396 1
d401 1
a401 1
XkbInitIndicatorMap(XkbSrvInfoPtr xkbi,SrvXkmInfo *file)
d410 19
a428 20
    if ((file->xkbinfo.defined&XkmIndicatorsMask)==0) {
	map= xkb->indicators;
	map->phys_indicators = PHYS_LEDS;
	map->maps[LED_CAPS-1].flags= XkbIM_NoExplicit;
	map->maps[LED_CAPS-1].which_mods= XkbIM_UseLocked;
	map->maps[LED_CAPS-1].mods.mask= LockMask;
	map->maps[LED_CAPS-1].mods.real_mods= LockMask;

	map->maps[LED_NUM-1].flags= XkbIM_NoExplicit;
	map->maps[LED_NUM-1].which_mods= XkbIM_UseLocked;
	map->maps[LED_NUM-1].mods.mask= 0;
	map->maps[LED_NUM-1].mods.real_mods= 0;
	map->maps[LED_NUM-1].mods.vmods= vmod_NumLockMask;

/* Metro Link */
	map->maps[LED_SCROLL-1].flags= XkbIM_NoExplicit;
	map->maps[LED_SCROLL-1].which_mods= XkbIM_UseLocked;
	map->maps[LED_SCROLL-1].mods.mask= Mod3Mask;
	map->maps[LED_SCROLL-1].mods.real_mods= Mod3Mask;
/* Metro Link */
d430 1
d434 1
d439 1
a439 1
XkbInitControls(DeviceIntPtr pXDev,XkbSrvInfoPtr xkbi,SrvXkmInfo *file)
d449 2
a450 2
    if ((file->xkbinfo.defined&XkmSymbolsMask)==0)
	ctrls->num_groups = 1;
a472 1
SrvXkmInfo		file;
a475 3
    file.dev= pXDev;
    file.file=NULL;
    bzero(&file.xkbinfo,sizeof(XkbFileInfo));
d480 12
a491 12
	if ((_XkbInitFileInfo!=NULL)&&(_XkbInitFileInfo->xkb!=NULL)) {
	    file.xkbinfo= *_XkbInitFileInfo;
	    xkbi->desc= _XkbInitFileInfo->xkb;
	    _XkbInitFileInfo= NULL;
	}
	else {
	    xkbi->desc= XkbAllocKeyboard();
	    if (!xkbi->desc)
		FatalError("Couldn't allocate keyboard description\n");
	    xkbi->desc->min_key_code = pXDev->key->curKeySyms.minKeyCode;
	    xkbi->desc->max_key_code = pXDev->key->curKeySyms.maxKeyCode;
	}
d514 3
a516 4
	file.xkbinfo.xkb= xkb;
	XkbInitSemantics(xkb,&file);
	XkbInitNames(xkbi,&file);
	XkbInitRadioGroups(xkbi,&file);
d521 1
a521 1
	XkbInitControls(pXDev,xkbi,&file);
d523 6
a528 4
	if (file.xkbinfo.defined&XkmSymbolsMask)
	   memcpy(pXDev->key->modifierMap,xkb->map->modmap,xkb->max_key_code+1);
	else
	   memcpy(xkb->map->modmap,pXDev->key->modifierMap,xkb->max_key_code+1);
d530 1
a530 1
	XkbInitIndicatorMap(xkbi,&file);
d534 6
a539 7
	if (!(file.xkbinfo.defined&XkmSymbolsMask)) {
	    XkbUpdateKeyTypesFromCore(pXDev,xkb->min_key_code,XkbNumKeys(xkb),
								&changes);
	}
	else {
	    XkbUpdateCoreDescription(pXDev,True);
	}
a550 2
    if (file.file!=NULL)
	fclose(file.file);
a573 1
XkbFileInfo		finfo;
d579 1
d594 1
a594 1
    if (names->keymap) names->keymap = _XkbDupString(names->keymap);
a604 5
	    if (rNames.keymap) {
		if (!names->keymap)
		    names->keymap = rNames.keymap;
		else _XkbFree(rNames.keymap);
	    }
d635 2
a636 10
    if (names->keymap) {
        XkbComponentNamesRec	tmpNames;
	bzero(&tmpNames,sizeof(XkbComponentNamesRec));
	tmpNames.keymap = names->keymap;
        ok = (Bool) XkbDDXLoadKeymapByNames(dev,&tmpNames,XkmAllIndicesMask,0,
					    &finfo,name,PATH_MAX);
    }
    if (!(ok && (finfo.xkb!=NULL)))
        ok = (Bool) XkbDDXLoadKeymapByNames(dev,names,XkmAllIndicesMask,0,
					    &finfo,name,PATH_MAX);
d638 1
a638 2
    if (ok && (finfo.xkb!=NULL)) {
	XkbDescPtr	xkb;
a640 1
	xkb= finfo.xkb;
d670 3
a672 1
	_XkbInitFileInfo= &finfo;
d678 1
a678 1
    _XkbInitFileInfo= NULL;
a683 2
    if (names->keymap) _XkbFree(names->keymap);
    names->keymap = NULL;
d746 1
a746 3
#ifdef DEBUG
    else ErrorF("No indicator feedback in XkbFinishInit (shouldn't happen)!\n");
#endif
d820 1
a820 1
#if !defined(WIN32) && !defined(__UNIXOS2__) && !defined(__CYGWIN__)
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d50 1
a50 1
#include <xkbsrv.h>
d127 1
a127 1
static int	 	XkbWantAccessX=		0;	
d137 7
a143 4
static char *		XkbModelUsed=	NULL;
static char *		XkbLayoutUsed=	NULL;
static char *		XkbVariantUsed=	NULL;
static char *		XkbOptionsUsed=	NULL;
d146 1
a146 1
static Bool		XkbWantRulesProp=	XKB_DFLT_RULES_PROP;
d150 1
a150 1
static char *
d164 1
a164 1
static Bool
d233 1
a233 1
static void
d292 3
d856 1
a856 1
#if !defined(WIN32) && !defined(__CYGWIN__)
@

