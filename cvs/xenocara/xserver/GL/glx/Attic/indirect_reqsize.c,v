head	1.2;
access;
symbols
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2008.11.02.15.26.10;	author matthieu;	state dead;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.01;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.01;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.11.59;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.18.06.22;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@/* DO NOT EDIT - This file generated automatically by glX_proto_size.py (from Mesa) script */

/*
 * (C) Copyright IBM Corporation 2005
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sub license,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
 * IBM,
 * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


#include <GL/gl.h>
#include "glxserver.h"
#include "indirect_size.h"
#include "indirect_reqsize.h"

#if defined(linux)
#  include <byteswap.h>
#  define SWAP_32(v)  do { (v) = bswap_32(v); } while(0)
#else
#  define SWAP_32(v)  do { char tmp; swapl(&v, tmp); } while(0)
#endif

#define __GLX_PAD(x)  (((x) + 3) & ~3)

#if defined(__CYGWIN__) || defined(__MINGW32__)
#  undef HAVE_ALIAS
#endif
#ifdef HAVE_ALIAS
#  define ALIAS2(from,to) \
    GLint __glX ## from ## ReqSize( const GLbyte * pc, Bool swap ) \
        __attribute__ ((alias( # to )));
#  define ALIAS(from,to) ALIAS2( from, __glX ## to ## ReqSize )
#else
#  define ALIAS(from,to) \
    GLint __glX ## from ## ReqSize( const GLbyte * pc, Bool swap ) \
    { return __glX ## to ## ReqSize( pc, swap ); }
#endif


int
__glXCallListsReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei n          = *(GLsizei *)(pc + 0);
    GLenum type        = * (GLenum *)(pc + 4);
    GLsizei compsize;

    if (swap) {
        SWAP_32( n );
        SWAP_32( type );
    }

    compsize = __glCallLists_size(type);
    return __GLX_PAD((compsize * n));
}

int
__glXBitmapReqSize( const GLbyte * pc, Bool swap )
{
    GLint row_length   = *  (GLint *)(pc +  4);
    GLint image_height = 0;
    GLint skip_images  = 0;
    GLint skip_rows    = *  (GLint *)(pc +  8);
    GLint alignment    = *  (GLint *)(pc + 16);
    GLsizei width      = *(GLsizei *)(pc + 20);
    GLsizei height     = *(GLsizei *)(pc + 24);

    if (swap) {
        SWAP_32( row_length );
        SWAP_32( skip_rows );
        SWAP_32( alignment );
        SWAP_32( width );
        SWAP_32( height );
    }

    return __glXImageSize(GL_COLOR_INDEX, GL_BITMAP, 0, width, height, 1,
                          image_height, row_length, skip_images,
                          skip_rows, alignment);
}

int
__glXFogfvReqSize( const GLbyte * pc, Bool swap )
{
    GLenum pname       = * (GLenum *)(pc + 0);
    GLsizei compsize;

    if (swap) {
        SWAP_32( pname );
    }

    compsize = __glFogfv_size(pname);
    return __GLX_PAD((compsize * 4));
}

int
__glXLightfvReqSize( const GLbyte * pc, Bool swap )
{
    GLenum pname       = * (GLenum *)(pc + 4);
    GLsizei compsize;

    if (swap) {
        SWAP_32( pname );
    }

    compsize = __glLightfv_size(pname);
    return __GLX_PAD((compsize * 4));
}

int
__glXLightModelfvReqSize( const GLbyte * pc, Bool swap )
{
    GLenum pname       = * (GLenum *)(pc + 0);
    GLsizei compsize;

    if (swap) {
        SWAP_32( pname );
    }

    compsize = __glLightModelfv_size(pname);
    return __GLX_PAD((compsize * 4));
}

int
__glXMaterialfvReqSize( const GLbyte * pc, Bool swap )
{
    GLenum pname       = * (GLenum *)(pc + 4);
    GLsizei compsize;

    if (swap) {
        SWAP_32( pname );
    }

    compsize = __glMaterialfv_size(pname);
    return __GLX_PAD((compsize * 4));
}

int
__glXPolygonStippleReqSize( const GLbyte * pc, Bool swap )
{
    GLint row_length   = *  (GLint *)(pc +  4);
    GLint image_height = 0;
    GLint skip_images  = 0;
    GLint skip_rows    = *  (GLint *)(pc +  8);
    GLint alignment    = *  (GLint *)(pc + 16);

    if (swap) {
        SWAP_32( row_length );
        SWAP_32( skip_rows );
        SWAP_32( alignment );
    }

    return __glXImageSize(GL_COLOR_INDEX, GL_BITMAP, 0, 32, 32, 1,
                          image_height, row_length, skip_images,
                          skip_rows, alignment);
}

int
__glXTexParameterfvReqSize( const GLbyte * pc, Bool swap )
{
    GLenum pname       = * (GLenum *)(pc + 4);
    GLsizei compsize;

    if (swap) {
        SWAP_32( pname );
    }

    compsize = __glTexParameterfv_size(pname);
    return __GLX_PAD((compsize * 4));
}

int
__glXTexImage1DReqSize( const GLbyte * pc, Bool swap )
{
    GLint row_length   = *  (GLint *)(pc +  4);
    GLint image_height = 0;
    GLint skip_images  = 0;
    GLint skip_rows    = *  (GLint *)(pc +  8);
    GLint alignment    = *  (GLint *)(pc + 16);
    GLenum target      = * (GLenum *)(pc + 20);
    GLsizei width      = *(GLsizei *)(pc + 32);
    GLenum format      = * (GLenum *)(pc + 44);
    GLenum type        = * (GLenum *)(pc + 48);

    if (swap) {
        SWAP_32( row_length );
        SWAP_32( skip_rows );
        SWAP_32( alignment );
        SWAP_32( target );
        SWAP_32( width );
        SWAP_32( format );
        SWAP_32( type );
    }

    return __glXImageSize(format, type, target, width, 1, 1,
                          image_height, row_length, skip_images,
                          skip_rows, alignment);
}

int
__glXTexImage2DReqSize( const GLbyte * pc, Bool swap )
{
    GLint row_length   = *  (GLint *)(pc +  4);
    GLint image_height = 0;
    GLint skip_images  = 0;
    GLint skip_rows    = *  (GLint *)(pc +  8);
    GLint alignment    = *  (GLint *)(pc + 16);
    GLenum target      = * (GLenum *)(pc + 20);
    GLsizei width      = *(GLsizei *)(pc + 32);
    GLsizei height     = *(GLsizei *)(pc + 36);
    GLenum format      = * (GLenum *)(pc + 44);
    GLenum type        = * (GLenum *)(pc + 48);

    if (swap) {
        SWAP_32( row_length );
        SWAP_32( skip_rows );
        SWAP_32( alignment );
        SWAP_32( target );
        SWAP_32( width );
        SWAP_32( height );
        SWAP_32( format );
        SWAP_32( type );
    }

    return __glXImageSize(format, type, target, width, height, 1,
                          image_height, row_length, skip_images,
                          skip_rows, alignment);
}

int
__glXTexEnvfvReqSize( const GLbyte * pc, Bool swap )
{
    GLenum pname       = * (GLenum *)(pc + 4);
    GLsizei compsize;

    if (swap) {
        SWAP_32( pname );
    }

    compsize = __glTexEnvfv_size(pname);
    return __GLX_PAD((compsize * 4));
}

int
__glXTexGendvReqSize( const GLbyte * pc, Bool swap )
{
    GLenum pname       = * (GLenum *)(pc + 4);
    GLsizei compsize;

    if (swap) {
        SWAP_32( pname );
    }

    compsize = __glTexGendv_size(pname);
    return __GLX_PAD((compsize * 8));
}

int
__glXTexGenfvReqSize( const GLbyte * pc, Bool swap )
{
    GLenum pname       = * (GLenum *)(pc + 4);
    GLsizei compsize;

    if (swap) {
        SWAP_32( pname );
    }

    compsize = __glTexGenfv_size(pname);
    return __GLX_PAD((compsize * 4));
}

int
__glXPixelMapfvReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei mapsize    = *(GLsizei *)(pc + 4);

    if (swap) {
        SWAP_32( mapsize );
    }

    return __GLX_PAD((mapsize * 4));
}

int
__glXPixelMapusvReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei mapsize    = *(GLsizei *)(pc + 4);

    if (swap) {
        SWAP_32( mapsize );
    }

    return __GLX_PAD((mapsize * 2));
}

int
__glXDrawPixelsReqSize( const GLbyte * pc, Bool swap )
{
    GLint row_length   = *  (GLint *)(pc +  4);
    GLint image_height = 0;
    GLint skip_images  = 0;
    GLint skip_rows    = *  (GLint *)(pc +  8);
    GLint alignment    = *  (GLint *)(pc + 16);
    GLsizei width      = *(GLsizei *)(pc + 20);
    GLsizei height     = *(GLsizei *)(pc + 24);
    GLenum format      = * (GLenum *)(pc + 28);
    GLenum type        = * (GLenum *)(pc + 32);

    if (swap) {
        SWAP_32( row_length );
        SWAP_32( skip_rows );
        SWAP_32( alignment );
        SWAP_32( width );
        SWAP_32( height );
        SWAP_32( format );
        SWAP_32( type );
    }

    return __glXImageSize(format, type, 0, width, height, 1,
                          image_height, row_length, skip_images,
                          skip_rows, alignment);
}

int
__glXPrioritizeTexturesReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei n          = *(GLsizei *)(pc + 0);

    if (swap) {
        SWAP_32( n );
    }

    return __GLX_PAD((n * 4) + (n * 4));
}

int
__glXTexSubImage1DReqSize( const GLbyte * pc, Bool swap )
{
    GLint row_length   = *  (GLint *)(pc +  4);
    GLint image_height = 0;
    GLint skip_images  = 0;
    GLint skip_rows    = *  (GLint *)(pc +  8);
    GLint alignment    = *  (GLint *)(pc + 16);
    GLenum target      = * (GLenum *)(pc + 20);
    GLsizei width      = *(GLsizei *)(pc + 36);
    GLenum format      = * (GLenum *)(pc + 44);
    GLenum type        = * (GLenum *)(pc + 48);

    if (swap) {
        SWAP_32( row_length );
        SWAP_32( skip_rows );
        SWAP_32( alignment );
        SWAP_32( target );
        SWAP_32( width );
        SWAP_32( format );
        SWAP_32( type );
    }

    return __glXImageSize(format, type, target, width, 1, 1,
                          image_height, row_length, skip_images,
                          skip_rows, alignment);
}

int
__glXTexSubImage2DReqSize( const GLbyte * pc, Bool swap )
{
    GLint row_length   = *  (GLint *)(pc +  4);
    GLint image_height = 0;
    GLint skip_images  = 0;
    GLint skip_rows    = *  (GLint *)(pc +  8);
    GLint alignment    = *  (GLint *)(pc + 16);
    GLenum target      = * (GLenum *)(pc + 20);
    GLsizei width      = *(GLsizei *)(pc + 36);
    GLsizei height     = *(GLsizei *)(pc + 40);
    GLenum format      = * (GLenum *)(pc + 44);
    GLenum type        = * (GLenum *)(pc + 48);

    if (swap) {
        SWAP_32( row_length );
        SWAP_32( skip_rows );
        SWAP_32( alignment );
        SWAP_32( target );
        SWAP_32( width );
        SWAP_32( height );
        SWAP_32( format );
        SWAP_32( type );
    }

    return __glXImageSize(format, type, target, width, height, 1,
                          image_height, row_length, skip_images,
                          skip_rows, alignment);
}

int
__glXColorTableReqSize( const GLbyte * pc, Bool swap )
{
    GLint row_length   = *  (GLint *)(pc +  4);
    GLint image_height = 0;
    GLint skip_images  = 0;
    GLint skip_rows    = *  (GLint *)(pc +  8);
    GLint alignment    = *  (GLint *)(pc + 16);
    GLenum target      = * (GLenum *)(pc + 20);
    GLsizei width      = *(GLsizei *)(pc + 28);
    GLenum format      = * (GLenum *)(pc + 32);
    GLenum type        = * (GLenum *)(pc + 36);

    if (swap) {
        SWAP_32( row_length );
        SWAP_32( skip_rows );
        SWAP_32( alignment );
        SWAP_32( target );
        SWAP_32( width );
        SWAP_32( format );
        SWAP_32( type );
    }

    return __glXImageSize(format, type, target, width, 1, 1,
                          image_height, row_length, skip_images,
                          skip_rows, alignment);
}

int
__glXColorTableParameterfvReqSize( const GLbyte * pc, Bool swap )
{
    GLenum pname       = * (GLenum *)(pc + 4);
    GLsizei compsize;

    if (swap) {
        SWAP_32( pname );
    }

    compsize = __glColorTableParameterfv_size(pname);
    return __GLX_PAD((compsize * 4));
}

int
__glXColorSubTableReqSize( const GLbyte * pc, Bool swap )
{
    GLint row_length   = *  (GLint *)(pc +  4);
    GLint image_height = 0;
    GLint skip_images  = 0;
    GLint skip_rows    = *  (GLint *)(pc +  8);
    GLint alignment    = *  (GLint *)(pc + 16);
    GLenum target      = * (GLenum *)(pc + 20);
    GLsizei count      = *(GLsizei *)(pc + 28);
    GLenum format      = * (GLenum *)(pc + 32);
    GLenum type        = * (GLenum *)(pc + 36);

    if (swap) {
        SWAP_32( row_length );
        SWAP_32( skip_rows );
        SWAP_32( alignment );
        SWAP_32( target );
        SWAP_32( count );
        SWAP_32( format );
        SWAP_32( type );
    }

    return __glXImageSize(format, type, target, count, 1, 1,
                          image_height, row_length, skip_images,
                          skip_rows, alignment);
}

int
__glXConvolutionFilter1DReqSize( const GLbyte * pc, Bool swap )
{
    GLint row_length   = *  (GLint *)(pc +  4);
    GLint image_height = 0;
    GLint skip_images  = 0;
    GLint skip_rows    = *  (GLint *)(pc +  8);
    GLint alignment    = *  (GLint *)(pc + 16);
    GLenum target      = * (GLenum *)(pc + 20);
    GLsizei width      = *(GLsizei *)(pc + 28);
    GLenum format      = * (GLenum *)(pc + 36);
    GLenum type        = * (GLenum *)(pc + 40);

    if (swap) {
        SWAP_32( row_length );
        SWAP_32( skip_rows );
        SWAP_32( alignment );
        SWAP_32( target );
        SWAP_32( width );
        SWAP_32( format );
        SWAP_32( type );
    }

    return __glXImageSize(format, type, target, width, 1, 1,
                          image_height, row_length, skip_images,
                          skip_rows, alignment);
}

int
__glXConvolutionFilter2DReqSize( const GLbyte * pc, Bool swap )
{
    GLint row_length   = *  (GLint *)(pc +  4);
    GLint image_height = 0;
    GLint skip_images  = 0;
    GLint skip_rows    = *  (GLint *)(pc +  8);
    GLint alignment    = *  (GLint *)(pc + 16);
    GLenum target      = * (GLenum *)(pc + 20);
    GLsizei width      = *(GLsizei *)(pc + 28);
    GLsizei height     = *(GLsizei *)(pc + 32);
    GLenum format      = * (GLenum *)(pc + 36);
    GLenum type        = * (GLenum *)(pc + 40);

    if (swap) {
        SWAP_32( row_length );
        SWAP_32( skip_rows );
        SWAP_32( alignment );
        SWAP_32( target );
        SWAP_32( width );
        SWAP_32( height );
        SWAP_32( format );
        SWAP_32( type );
    }

    return __glXImageSize(format, type, target, width, height, 1,
                          image_height, row_length, skip_images,
                          skip_rows, alignment);
}

int
__glXConvolutionParameterfvReqSize( const GLbyte * pc, Bool swap )
{
    GLenum pname       = * (GLenum *)(pc + 4);
    GLsizei compsize;

    if (swap) {
        SWAP_32( pname );
    }

    compsize = __glConvolutionParameterfv_size(pname);
    return __GLX_PAD((compsize * 4));
}

int
__glXTexImage3DReqSize( const GLbyte * pc, Bool swap )
{
    GLint row_length   = *  (GLint *)(pc +  4);
    GLint image_height = *  (GLint *)(pc +  8);
    GLint skip_rows    = *  (GLint *)(pc + 16);
    GLint skip_images  = *  (GLint *)(pc + 20);
    GLint alignment    = *  (GLint *)(pc + 32);
    GLenum target      = * (GLenum *)(pc + 36);
    GLsizei width      = *(GLsizei *)(pc + 48);
    GLsizei height     = *(GLsizei *)(pc + 52);
    GLsizei depth      = *(GLsizei *)(pc + 56);
    GLenum format      = * (GLenum *)(pc + 68);
    GLenum type        = * (GLenum *)(pc + 72);

    if (swap) {
        SWAP_32( row_length );
        SWAP_32( image_height );
        SWAP_32( skip_rows );
        SWAP_32( skip_images );
        SWAP_32( alignment );
        SWAP_32( target );
        SWAP_32( width );
        SWAP_32( height );
        SWAP_32( depth );
        SWAP_32( format );
        SWAP_32( type );
    }

    return __glXImageSize(format, type, target, width, height, depth,
                          image_height, row_length, skip_images,
                          skip_rows, alignment);
}

int
__glXTexSubImage3DReqSize( const GLbyte * pc, Bool swap )
{
    GLint row_length   = *  (GLint *)(pc +  4);
    GLint image_height = *  (GLint *)(pc +  8);
    GLint skip_rows    = *  (GLint *)(pc + 16);
    GLint skip_images  = *  (GLint *)(pc + 20);
    GLint alignment    = *  (GLint *)(pc + 32);
    GLenum target      = * (GLenum *)(pc + 36);
    GLsizei width      = *(GLsizei *)(pc + 60);
    GLsizei height     = *(GLsizei *)(pc + 64);
    GLsizei depth      = *(GLsizei *)(pc + 68);
    GLenum format      = * (GLenum *)(pc + 76);
    GLenum type        = * (GLenum *)(pc + 80);

    if (swap) {
        SWAP_32( row_length );
        SWAP_32( image_height );
        SWAP_32( skip_rows );
        SWAP_32( skip_images );
        SWAP_32( alignment );
        SWAP_32( target );
        SWAP_32( width );
        SWAP_32( height );
        SWAP_32( depth );
        SWAP_32( format );
        SWAP_32( type );
    }

    return __glXImageSize(format, type, target, width, height, depth,
                          image_height, row_length, skip_images,
                          skip_rows, alignment);
}

int
__glXDrawBuffersARBReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei n          = *(GLsizei *)(pc + 0);

    if (swap) {
        SWAP_32( n );
    }

    return __GLX_PAD((n * 4));
}

int
__glXPointParameterfvEXTReqSize( const GLbyte * pc, Bool swap )
{
    GLenum pname       = * (GLenum *)(pc + 0);
    GLsizei compsize;

    if (swap) {
        SWAP_32( pname );
    }

    compsize = __glPointParameterfvEXT_size(pname);
    return __GLX_PAD((compsize * 4));
}

int
__glXCompressedTexImage3DARBReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei imageSize  = *(GLsizei *)(pc + 28);

    if (swap) {
        SWAP_32( imageSize );
    }

    return __GLX_PAD(imageSize);
}

int
__glXCompressedTexImage2DARBReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei imageSize  = *(GLsizei *)(pc + 24);

    if (swap) {
        SWAP_32( imageSize );
    }

    return __GLX_PAD(imageSize);
}

int
__glXCompressedTexImage1DARBReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei imageSize  = *(GLsizei *)(pc + 20);

    if (swap) {
        SWAP_32( imageSize );
    }

    return __GLX_PAD(imageSize);
}

int
__glXCompressedTexSubImage3DARBReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei imageSize  = *(GLsizei *)(pc + 36);

    if (swap) {
        SWAP_32( imageSize );
    }

    return __GLX_PAD(imageSize);
}

int
__glXLoadProgramNVReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei len        = *(GLsizei *)(pc + 8);

    if (swap) {
        SWAP_32( len );
    }

    return __GLX_PAD(len);
}

int
__glXProgramParameters4dvNVReqSize( const GLbyte * pc, Bool swap )
{
    GLuint num         = * (GLuint *)(pc + 8);

    if (swap) {
        SWAP_32( num );
    }

    return __GLX_PAD((num * 32));
}

int
__glXProgramParameters4fvNVReqSize( const GLbyte * pc, Bool swap )
{
    GLuint num         = * (GLuint *)(pc + 8);

    if (swap) {
        SWAP_32( num );
    }

    return __GLX_PAD((num * 16));
}

int
__glXVertexAttribs1dvNVReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei n          = *(GLsizei *)(pc + 4);

    if (swap) {
        SWAP_32( n );
    }

    return __GLX_PAD((n * 8));
}

int
__glXVertexAttribs2dvNVReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei n          = *(GLsizei *)(pc + 4);

    if (swap) {
        SWAP_32( n );
    }

    return __GLX_PAD((n * 16));
}

int
__glXVertexAttribs3dvNVReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei n          = *(GLsizei *)(pc + 4);

    if (swap) {
        SWAP_32( n );
    }

    return __GLX_PAD((n * 24));
}

int
__glXVertexAttribs3fvNVReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei n          = *(GLsizei *)(pc + 4);

    if (swap) {
        SWAP_32( n );
    }

    return __GLX_PAD((n * 12));
}

int
__glXVertexAttribs3svNVReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei n          = *(GLsizei *)(pc + 4);

    if (swap) {
        SWAP_32( n );
    }

    return __GLX_PAD((n * 6));
}

int
__glXVertexAttribs4dvNVReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei n          = *(GLsizei *)(pc + 4);

    if (swap) {
        SWAP_32( n );
    }

    return __GLX_PAD((n * 32));
}

int
__glXProgramNamedParameter4fvNVReqSize( const GLbyte * pc, Bool swap )
{
    GLsizei len        = *(GLsizei *)(pc + 4);

    if (swap) {
        SWAP_32( len );
    }

    return __GLX_PAD(len);
}

ALIAS( Fogiv, Fogfv )
ALIAS( Lightiv, Lightfv )
ALIAS( LightModeliv, LightModelfv )
ALIAS( Materialiv, Materialfv )
ALIAS( TexParameteriv, TexParameterfv )
ALIAS( TexEnviv, TexEnvfv )
ALIAS( TexGeniv, TexGenfv )
ALIAS( PixelMapuiv, PixelMapfv )
ALIAS( ColorTableParameteriv, ColorTableParameterfv )
ALIAS( ConvolutionParameteriv, ConvolutionParameterfv )
ALIAS( CompressedTexSubImage2DARB, CompressedTexImage3DARB )
ALIAS( CompressedTexSubImage1DARB, CompressedTexImage1DARB )
ALIAS( RequestResidentProgramsNV, DrawBuffersARB )
ALIAS( VertexAttribs1fvNV, PixelMapfv )
ALIAS( VertexAttribs1svNV, PixelMapusv )
ALIAS( VertexAttribs2fvNV, VertexAttribs1dvNV )
ALIAS( VertexAttribs2svNV, PixelMapfv )
ALIAS( VertexAttribs4fvNV, VertexAttribs2dvNV )
ALIAS( VertexAttribs4svNV, VertexAttribs1dvNV )
ALIAS( VertexAttribs4ubvNV, PixelMapfv )
ALIAS( PointParameterivNV, PointParameterfvEXT )
ALIAS( ProgramStringARB, LoadProgramNV )
ALIAS( ProgramNamedParameter4dvNV, CompressedTexSubImage3DARB )
ALIAS( DeleteRenderbuffersEXT, DrawBuffersARB )
ALIAS( DeleteFramebuffersEXT, DrawBuffersARB )
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@Import xserver version 1.2.0 (X.Org 7.2 final).
@
text
@d34 1
a34 1
#if defined(__linux__) || defined (__GLIBC__) || defined(__GNU__)
@


1.1.1.3
log
@xserver 1.4
@
text
@a30 1
#include "glxbyteorder.h"
d34 7
d59 1
a59 1
__glXCallListsReqSize(const GLbyte *pc, Bool swap)
d61 2
a62 2
    GLsizei n = *(GLsizei *) (pc + 0);
    GLenum type = *(GLenum *) (pc + 4);
d66 2
a67 2
        n = bswap_32(n);
        type = bswap_32(type);
d75 1
a75 1
__glXBitmapReqSize(const GLbyte *pc, Bool swap)
d77 1
a77 1
    GLint row_length = *(GLint *) (pc + 4);
d79 12
a90 12
    GLint skip_images = 0;
    GLint skip_rows = *(GLint *) (pc + 8);
    GLint alignment = *(GLint *) (pc + 16);
    GLsizei width = *(GLsizei *) (pc + 20);
    GLsizei height = *(GLsizei *) (pc + 24);

    if (swap) {
        row_length = bswap_32(row_length);
        skip_rows = bswap_32(skip_rows);
        alignment = bswap_32(alignment);
        width = bswap_32(width);
        height = bswap_32(height);
d99 1
a99 1
__glXFogfvReqSize(const GLbyte *pc, Bool swap)
d101 1
a101 1
    GLenum pname = *(GLenum *) (pc + 0);
d105 1
a105 1
        pname = bswap_32(pname);
d113 1
a113 1
__glXLightfvReqSize(const GLbyte *pc, Bool swap)
d115 1
a115 1
    GLenum pname = *(GLenum *) (pc + 4);
d119 1
a119 1
        pname = bswap_32(pname);
d127 1
a127 1
__glXLightModelfvReqSize(const GLbyte *pc, Bool swap)
d129 1
a129 1
    GLenum pname = *(GLenum *) (pc + 0);
d133 1
a133 1
        pname = bswap_32(pname);
d141 1
a141 1
__glXMaterialfvReqSize(const GLbyte *pc, Bool swap)
d143 1
a143 1
    GLenum pname = *(GLenum *) (pc + 4);
d147 1
a147 1
        pname = bswap_32(pname);
d155 1
a155 1
__glXPolygonStippleReqSize(const GLbyte *pc, Bool swap)
d157 1
a157 1
    GLint row_length = *(GLint *) (pc + 4);
d159 3
a161 3
    GLint skip_images = 0;
    GLint skip_rows = *(GLint *) (pc + 8);
    GLint alignment = *(GLint *) (pc + 16);
d164 3
a166 3
        row_length = bswap_32(row_length);
        skip_rows = bswap_32(skip_rows);
        alignment = bswap_32(alignment);
d175 1
a175 1
__glXTexParameterfvReqSize(const GLbyte *pc, Bool swap)
d177 1
a177 1
    GLenum pname = *(GLenum *) (pc + 4);
d181 1
a181 1
        pname = bswap_32(pname);
d189 1
a189 1
__glXTexImage1DReqSize(const GLbyte *pc, Bool swap)
d191 1
a191 1
    GLint row_length = *(GLint *) (pc + 4);
d193 16
a208 16
    GLint skip_images = 0;
    GLint skip_rows = *(GLint *) (pc + 8);
    GLint alignment = *(GLint *) (pc + 16);
    GLenum target = *(GLenum *) (pc + 20);
    GLsizei width = *(GLsizei *) (pc + 32);
    GLenum format = *(GLenum *) (pc + 44);
    GLenum type = *(GLenum *) (pc + 48);

    if (swap) {
        row_length = bswap_32(row_length);
        skip_rows = bswap_32(skip_rows);
        alignment = bswap_32(alignment);
        target = bswap_32(target);
        width = bswap_32(width);
        format = bswap_32(format);
        type = bswap_32(type);
d217 1
a217 1
__glXTexImage2DReqSize(const GLbyte *pc, Bool swap)
d219 1
a219 1
    GLint row_length = *(GLint *) (pc + 4);
d221 18
a238 18
    GLint skip_images = 0;
    GLint skip_rows = *(GLint *) (pc + 8);
    GLint alignment = *(GLint *) (pc + 16);
    GLenum target = *(GLenum *) (pc + 20);
    GLsizei width = *(GLsizei *) (pc + 32);
    GLsizei height = *(GLsizei *) (pc + 36);
    GLenum format = *(GLenum *) (pc + 44);
    GLenum type = *(GLenum *) (pc + 48);

    if (swap) {
        row_length = bswap_32(row_length);
        skip_rows = bswap_32(skip_rows);
        alignment = bswap_32(alignment);
        target = bswap_32(target);
        width = bswap_32(width);
        height = bswap_32(height);
        format = bswap_32(format);
        type = bswap_32(type);
d247 1
a247 1
__glXTexEnvfvReqSize(const GLbyte *pc, Bool swap)
d249 1
a249 1
    GLenum pname = *(GLenum *) (pc + 4);
d253 1
a253 1
        pname = bswap_32(pname);
d261 1
a261 1
__glXTexGendvReqSize(const GLbyte *pc, Bool swap)
d263 1
a263 1
    GLenum pname = *(GLenum *) (pc + 4);
d267 1
a267 1
        pname = bswap_32(pname);
d275 1
a275 1
__glXTexGenfvReqSize(const GLbyte *pc, Bool swap)
d277 1
a277 1
    GLenum pname = *(GLenum *) (pc + 4);
d281 1
a281 1
        pname = bswap_32(pname);
d289 1
a289 1
__glXPixelMapfvReqSize(const GLbyte *pc, Bool swap)
d291 1
a291 1
    GLsizei mapsize = *(GLsizei *) (pc + 4);
d294 1
a294 1
        mapsize = bswap_32(mapsize);
d301 1
a301 1
__glXPixelMapusvReqSize(const GLbyte *pc, Bool swap)
d303 1
a303 1
    GLsizei mapsize = *(GLsizei *) (pc + 4);
d306 1
a306 1
        mapsize = bswap_32(mapsize);
d313 1
a313 1
__glXDrawPixelsReqSize(const GLbyte *pc, Bool swap)
d315 1
a315 1
    GLint row_length = *(GLint *) (pc + 4);
d317 16
a332 16
    GLint skip_images = 0;
    GLint skip_rows = *(GLint *) (pc + 8);
    GLint alignment = *(GLint *) (pc + 16);
    GLsizei width = *(GLsizei *) (pc + 20);
    GLsizei height = *(GLsizei *) (pc + 24);
    GLenum format = *(GLenum *) (pc + 28);
    GLenum type = *(GLenum *) (pc + 32);

    if (swap) {
        row_length = bswap_32(row_length);
        skip_rows = bswap_32(skip_rows);
        alignment = bswap_32(alignment);
        width = bswap_32(width);
        height = bswap_32(height);
        format = bswap_32(format);
        type = bswap_32(type);
d341 1
a341 1
__glXPrioritizeTexturesReqSize(const GLbyte *pc, Bool swap)
d343 1
a343 1
    GLsizei n = *(GLsizei *) (pc + 0);
d346 1
a346 1
        n = bswap_32(n);
d353 1
a353 1
__glXTexSubImage1DReqSize(const GLbyte *pc, Bool swap)
d355 1
a355 1
    GLint row_length = *(GLint *) (pc + 4);
d357 16
a372 16
    GLint skip_images = 0;
    GLint skip_rows = *(GLint *) (pc + 8);
    GLint alignment = *(GLint *) (pc + 16);
    GLenum target = *(GLenum *) (pc + 20);
    GLsizei width = *(GLsizei *) (pc + 36);
    GLenum format = *(GLenum *) (pc + 44);
    GLenum type = *(GLenum *) (pc + 48);

    if (swap) {
        row_length = bswap_32(row_length);
        skip_rows = bswap_32(skip_rows);
        alignment = bswap_32(alignment);
        target = bswap_32(target);
        width = bswap_32(width);
        format = bswap_32(format);
        type = bswap_32(type);
d381 1
a381 1
__glXTexSubImage2DReqSize(const GLbyte *pc, Bool swap)
d383 1
a383 1
    GLint row_length = *(GLint *) (pc + 4);
d385 18
a402 18
    GLint skip_images = 0;
    GLint skip_rows = *(GLint *) (pc + 8);
    GLint alignment = *(GLint *) (pc + 16);
    GLenum target = *(GLenum *) (pc + 20);
    GLsizei width = *(GLsizei *) (pc + 36);
    GLsizei height = *(GLsizei *) (pc + 40);
    GLenum format = *(GLenum *) (pc + 44);
    GLenum type = *(GLenum *) (pc + 48);

    if (swap) {
        row_length = bswap_32(row_length);
        skip_rows = bswap_32(skip_rows);
        alignment = bswap_32(alignment);
        target = bswap_32(target);
        width = bswap_32(width);
        height = bswap_32(height);
        format = bswap_32(format);
        type = bswap_32(type);
d411 1
a411 1
__glXColorTableReqSize(const GLbyte *pc, Bool swap)
d413 1
a413 1
    GLint row_length = *(GLint *) (pc + 4);
d415 16
a430 16
    GLint skip_images = 0;
    GLint skip_rows = *(GLint *) (pc + 8);
    GLint alignment = *(GLint *) (pc + 16);
    GLenum target = *(GLenum *) (pc + 20);
    GLsizei width = *(GLsizei *) (pc + 28);
    GLenum format = *(GLenum *) (pc + 32);
    GLenum type = *(GLenum *) (pc + 36);

    if (swap) {
        row_length = bswap_32(row_length);
        skip_rows = bswap_32(skip_rows);
        alignment = bswap_32(alignment);
        target = bswap_32(target);
        width = bswap_32(width);
        format = bswap_32(format);
        type = bswap_32(type);
d439 1
a439 1
__glXColorTableParameterfvReqSize(const GLbyte *pc, Bool swap)
d441 1
a441 1
    GLenum pname = *(GLenum *) (pc + 4);
d445 1
a445 1
        pname = bswap_32(pname);
d453 1
a453 1
__glXColorSubTableReqSize(const GLbyte *pc, Bool swap)
d455 1
a455 1
    GLint row_length = *(GLint *) (pc + 4);
d457 16
a472 16
    GLint skip_images = 0;
    GLint skip_rows = *(GLint *) (pc + 8);
    GLint alignment = *(GLint *) (pc + 16);
    GLenum target = *(GLenum *) (pc + 20);
    GLsizei count = *(GLsizei *) (pc + 28);
    GLenum format = *(GLenum *) (pc + 32);
    GLenum type = *(GLenum *) (pc + 36);

    if (swap) {
        row_length = bswap_32(row_length);
        skip_rows = bswap_32(skip_rows);
        alignment = bswap_32(alignment);
        target = bswap_32(target);
        count = bswap_32(count);
        format = bswap_32(format);
        type = bswap_32(type);
d481 1
a481 1
__glXConvolutionFilter1DReqSize(const GLbyte *pc, Bool swap)
d483 1
a483 1
    GLint row_length = *(GLint *) (pc + 4);
d485 16
a500 16
    GLint skip_images = 0;
    GLint skip_rows = *(GLint *) (pc + 8);
    GLint alignment = *(GLint *) (pc + 16);
    GLenum target = *(GLenum *) (pc + 20);
    GLsizei width = *(GLsizei *) (pc + 28);
    GLenum format = *(GLenum *) (pc + 36);
    GLenum type = *(GLenum *) (pc + 40);

    if (swap) {
        row_length = bswap_32(row_length);
        skip_rows = bswap_32(skip_rows);
        alignment = bswap_32(alignment);
        target = bswap_32(target);
        width = bswap_32(width);
        format = bswap_32(format);
        type = bswap_32(type);
d509 1
a509 1
__glXConvolutionFilter2DReqSize(const GLbyte *pc, Bool swap)
d511 1
a511 1
    GLint row_length = *(GLint *) (pc + 4);
d513 18
a530 18
    GLint skip_images = 0;
    GLint skip_rows = *(GLint *) (pc + 8);
    GLint alignment = *(GLint *) (pc + 16);
    GLenum target = *(GLenum *) (pc + 20);
    GLsizei width = *(GLsizei *) (pc + 28);
    GLsizei height = *(GLsizei *) (pc + 32);
    GLenum format = *(GLenum *) (pc + 36);
    GLenum type = *(GLenum *) (pc + 40);

    if (swap) {
        row_length = bswap_32(row_length);
        skip_rows = bswap_32(skip_rows);
        alignment = bswap_32(alignment);
        target = bswap_32(target);
        width = bswap_32(width);
        height = bswap_32(height);
        format = bswap_32(format);
        type = bswap_32(type);
d539 1
a539 1
__glXConvolutionParameterfvReqSize(const GLbyte *pc, Bool swap)
d541 1
a541 1
    GLenum pname = *(GLenum *) (pc + 4);
d545 1
a545 1
        pname = bswap_32(pname);
d553 1
a553 1
__glXTexImage3DReqSize(const GLbyte *pc, Bool swap)
d555 24
a578 24
    GLint row_length = *(GLint *) (pc + 4);
    GLint image_height = *(GLint *) (pc + 8);
    GLint skip_rows = *(GLint *) (pc + 16);
    GLint skip_images = *(GLint *) (pc + 20);
    GLint alignment = *(GLint *) (pc + 32);
    GLenum target = *(GLenum *) (pc + 36);
    GLsizei width = *(GLsizei *) (pc + 48);
    GLsizei height = *(GLsizei *) (pc + 52);
    GLsizei depth = *(GLsizei *) (pc + 56);
    GLenum format = *(GLenum *) (pc + 68);
    GLenum type = *(GLenum *) (pc + 72);

    if (swap) {
        row_length = bswap_32(row_length);
        image_height = bswap_32(image_height);
        skip_rows = bswap_32(skip_rows);
        skip_images = bswap_32(skip_images);
        alignment = bswap_32(alignment);
        target = bswap_32(target);
        width = bswap_32(width);
        height = bswap_32(height);
        depth = bswap_32(depth);
        format = bswap_32(format);
        type = bswap_32(type);
d587 1
a587 1
__glXTexSubImage3DReqSize(const GLbyte *pc, Bool swap)
d589 24
a612 24
    GLint row_length = *(GLint *) (pc + 4);
    GLint image_height = *(GLint *) (pc + 8);
    GLint skip_rows = *(GLint *) (pc + 16);
    GLint skip_images = *(GLint *) (pc + 20);
    GLint alignment = *(GLint *) (pc + 32);
    GLenum target = *(GLenum *) (pc + 36);
    GLsizei width = *(GLsizei *) (pc + 60);
    GLsizei height = *(GLsizei *) (pc + 64);
    GLsizei depth = *(GLsizei *) (pc + 68);
    GLenum format = *(GLenum *) (pc + 76);
    GLenum type = *(GLenum *) (pc + 80);

    if (swap) {
        row_length = bswap_32(row_length);
        image_height = bswap_32(image_height);
        skip_rows = bswap_32(skip_rows);
        skip_images = bswap_32(skip_images);
        alignment = bswap_32(alignment);
        target = bswap_32(target);
        width = bswap_32(width);
        height = bswap_32(height);
        depth = bswap_32(depth);
        format = bswap_32(format);
        type = bswap_32(type);
d621 1
a621 1
__glXCompressedTexImage1DARBReqSize(const GLbyte *pc, Bool swap)
d623 1
a623 1
    GLsizei imageSize = *(GLsizei *) (pc + 20);
d626 1
a626 1
        imageSize = bswap_32(imageSize);
d629 1
a629 1
    return __GLX_PAD(imageSize);
d633 1
a633 1
__glXCompressedTexImage2DARBReqSize(const GLbyte *pc, Bool swap)
d635 2
a636 1
    GLsizei imageSize = *(GLsizei *) (pc + 24);
d639 1
a639 1
        imageSize = bswap_32(imageSize);
d642 2
a643 1
    return __GLX_PAD(imageSize);
d647 1
a647 1
__glXCompressedTexImage3DARBReqSize(const GLbyte *pc, Bool swap)
d649 1
a649 1
    GLsizei imageSize = *(GLsizei *) (pc + 28);
d652 1
a652 1
        imageSize = bswap_32(imageSize);
d659 1
a659 1
__glXCompressedTexSubImage3DARBReqSize(const GLbyte *pc, Bool swap)
d661 1
a661 1
    GLsizei imageSize = *(GLsizei *) (pc + 36);
d664 1
a664 1
        imageSize = bswap_32(imageSize);
d671 1
a671 1
__glXProgramStringARBReqSize(const GLbyte *pc, Bool swap)
d673 1
a673 1
    GLsizei len = *(GLsizei *) (pc + 8);
d676 1
a676 1
        len = bswap_32(len);
d679 1
a679 1
    return __GLX_PAD(len);
d683 1
a683 1
__glXDrawBuffersARBReqSize(const GLbyte *pc, Bool swap)
d685 1
a685 1
    GLsizei n = *(GLsizei *) (pc + 0);
d688 1
a688 1
        n = bswap_32(n);
d691 1
a691 1
    return __GLX_PAD((n * 4));
d695 1
a695 1
__glXPointParameterfvEXTReqSize(const GLbyte *pc, Bool swap)
d697 1
a697 2
    GLenum pname = *(GLenum *) (pc + 0);
    GLsizei compsize;
d700 1
a700 1
        pname = bswap_32(pname);
d703 1
a703 2
    compsize = __glPointParameterfvEXT_size(pname);
    return __GLX_PAD((compsize * 4));
d707 1
a707 1
__glXProgramParameters4dvNVReqSize(const GLbyte *pc, Bool swap)
d709 1
a709 1
    GLuint num = *(GLuint *) (pc + 8);
d712 1
a712 1
        num = bswap_32(num);
d719 1
a719 1
__glXProgramParameters4fvNVReqSize(const GLbyte *pc, Bool swap)
d721 1
a721 1
    GLuint num = *(GLuint *) (pc + 8);
d724 1
a724 1
        num = bswap_32(num);
d731 1
a731 1
__glXVertexAttribs1dvNVReqSize(const GLbyte *pc, Bool swap)
d733 1
a733 1
    GLsizei n = *(GLsizei *) (pc + 4);
d736 1
a736 1
        n = bswap_32(n);
d743 1
a743 1
__glXVertexAttribs2dvNVReqSize(const GLbyte *pc, Bool swap)
d745 1
a745 1
    GLsizei n = *(GLsizei *) (pc + 4);
d748 1
a748 1
        n = bswap_32(n);
d755 1
a755 1
__glXVertexAttribs3dvNVReqSize(const GLbyte *pc, Bool swap)
d757 1
a757 1
    GLsizei n = *(GLsizei *) (pc + 4);
d760 1
a760 1
        n = bswap_32(n);
d767 1
a767 1
__glXVertexAttribs3fvNVReqSize(const GLbyte *pc, Bool swap)
d769 1
a769 1
    GLsizei n = *(GLsizei *) (pc + 4);
d772 1
a772 1
        n = bswap_32(n);
d779 1
a779 1
__glXVertexAttribs3svNVReqSize(const GLbyte *pc, Bool swap)
d781 1
a781 1
    GLsizei n = *(GLsizei *) (pc + 4);
d784 1
a784 1
        n = bswap_32(n);
d791 1
a791 1
__glXVertexAttribs4dvNVReqSize(const GLbyte *pc, Bool swap)
d793 1
a793 1
    GLsizei n = *(GLsizei *) (pc + 4);
d796 1
a796 1
        n = bswap_32(n);
d803 1
a803 1
__glXProgramNamedParameter4fvNVReqSize(const GLbyte *pc, Bool swap)
d805 1
a805 1
    GLsizei len = *(GLsizei *) (pc + 4);
d808 1
a808 1
        len = bswap_32(len);
d814 25
a838 25
ALIAS(Fogiv, Fogfv)
    ALIAS(Lightiv, Lightfv)
    ALIAS(LightModeliv, LightModelfv)
    ALIAS(Materialiv, Materialfv)
    ALIAS(TexParameteriv, TexParameterfv)
    ALIAS(TexEnviv, TexEnvfv)
    ALIAS(TexGeniv, TexGenfv)
    ALIAS(PixelMapuiv, PixelMapfv)
    ALIAS(ColorTableParameteriv, ColorTableParameterfv)
    ALIAS(ConvolutionParameteriv, ConvolutionParameterfv)
    ALIAS(CompressedTexSubImage1DARB, CompressedTexImage1DARB)
    ALIAS(CompressedTexSubImage2DARB, CompressedTexImage3DARB)
    ALIAS(LoadProgramNV, ProgramStringARB)
    ALIAS(RequestResidentProgramsNV, DrawBuffersARB)
    ALIAS(VertexAttribs1fvNV, PixelMapfv)
    ALIAS(VertexAttribs1svNV, PixelMapusv)
    ALIAS(VertexAttribs2fvNV, VertexAttribs1dvNV)
    ALIAS(VertexAttribs2svNV, PixelMapfv)
    ALIAS(VertexAttribs4fvNV, VertexAttribs2dvNV)
    ALIAS(VertexAttribs4svNV, VertexAttribs1dvNV)
    ALIAS(VertexAttribs4ubvNV, PixelMapfv)
    ALIAS(PointParameterivNV, PointParameterfvEXT)
    ALIAS(ProgramNamedParameter4dvNV, CompressedTexSubImage3DARB)
    ALIAS(DeleteFramebuffersEXT, DrawBuffersARB)
    ALIAS(DeleteRenderbuffersEXT, DrawBuffersARB)
@


