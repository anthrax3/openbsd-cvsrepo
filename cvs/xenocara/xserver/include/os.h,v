head	1.17;
access;
symbols
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.2
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2017.02.28.18.24.48;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	KVkYmnzwAoL0WgJg;

1.16
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	s0SI41sEunLdyFfd;

1.15
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	Te1daavkBLskZ8gc;

1.14
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	cVXoV5PxI8YrEaVA;

1.13
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.06.19.44.36;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.15.26.32;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.19.04.06;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.29.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.20;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.11;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@MFC: Use timingsafe_memcmp() to compare MIT-MAGIC-COOKIES
Advisory X41-2017-001: Multiple Vulnerabilities in X.Org.
@
text
@/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#ifndef OS_H
#define OS_H

#include "misc.h"
#include <stdarg.h>
#include <stdint.h>
#include <string.h>

#define SCREEN_SAVER_ON   0
#define SCREEN_SAVER_OFF  1
#define SCREEN_SAVER_FORCER 2
#define SCREEN_SAVER_CYCLE  3

#ifndef MAX_REQUEST_SIZE
#define MAX_REQUEST_SIZE 65535
#endif
#ifndef MAX_BIG_REQUEST_SIZE
#define MAX_BIG_REQUEST_SIZE 4194303
#endif

typedef struct _FontPathRec *FontPathPtr;
typedef struct _NewClientRec *NewClientPtr;

#ifndef xnfalloc
#define xnfalloc(size) XNFalloc((unsigned long)(size))
#define xnfcalloc(_num, _size) XNFcallocarray((_num), (_size))
#define xnfrealloc(ptr, size) XNFrealloc((void *)(ptr), (unsigned long)(size))

#define xstrdup(s) Xstrdup(s)
#define xnfstrdup(s) XNFstrdup(s)

#define xallocarray(num, size) reallocarray(NULL, (num), (size))
#define xnfallocarray(num, size) XNFreallocarray(NULL, (num), (size))
#define xnfreallocarray(ptr, num, size) XNFreallocarray((ptr), (num), (size))
#endif

#include <stdio.h>
#include <stdarg.h>

#ifdef DDXBEFORERESET
extern void ddxBeforeReset(void);
#endif

#ifdef DDXOSVERRORF
extern _X_EXPORT void (*OsVendorVErrorFProc) (const char *,
                                              va_list args)
_X_ATTRIBUTE_PRINTF(1, 0);
#endif

extern _X_EXPORT int WaitForSomething(int *     /*pClientsReady */
    );

extern _X_EXPORT int ReadRequestFromClient(ClientPtr /*client */ );

#if XTRANS_SEND_FDS
extern _X_EXPORT int ReadFdFromClient(ClientPtr client);

extern _X_EXPORT int WriteFdToClient(ClientPtr client, int fd, Bool do_close);
#endif

extern _X_EXPORT Bool InsertFakeRequest(ClientPtr /*client */ ,
                                        char * /*data */ ,
                                        int /*count */ );

extern _X_EXPORT void ResetCurrentRequest(ClientPtr /*client */ );

extern _X_EXPORT void FlushAllOutput(void);

extern _X_EXPORT void FlushIfCriticalOutputPending(void);

extern _X_EXPORT void SetCriticalOutputPending(void);

extern _X_EXPORT int WriteToClient(ClientPtr /*who */ , int /*count */ ,
                                   const void * /*buf */ );

extern _X_EXPORT void ResetOsBuffers(void);

extern _X_EXPORT void InitConnectionLimits(void);

extern _X_EXPORT void NotifyParentProcess(void);

extern _X_EXPORT void CreateWellKnownSockets(void);

extern _X_EXPORT void ResetWellKnownSockets(void);

extern _X_EXPORT void CloseWellKnownConnections(void);

extern _X_EXPORT XID AuthorizationIDOfClient(ClientPtr /*client */ );

extern _X_EXPORT const char *ClientAuthorized(ClientPtr /*client */ ,
                                              unsigned int /*proto_n */ ,
                                              char * /*auth_proto */ ,
                                              unsigned int /*string_n */ ,
                                              char * /*auth_string */ );

extern _X_EXPORT Bool EstablishNewConnections(ClientPtr clientUnused,
                                              void *closure);

extern _X_EXPORT void CheckConnections(void);

extern _X_EXPORT void CloseDownConnection(ClientPtr /*client */ );

extern _X_EXPORT void AddGeneralSocket(int /*fd */ );

extern _X_EXPORT void RemoveGeneralSocket(int /*fd */ );

extern _X_EXPORT void AddEnabledDevice(int /*fd */ );

extern _X_EXPORT void RemoveEnabledDevice(int /*fd */ );

extern _X_EXPORT int OnlyListenToOneClient(ClientPtr /*client */ );

extern _X_EXPORT void ListenToAllClients(void);

extern _X_EXPORT void IgnoreClient(ClientPtr /*client */ );

extern _X_EXPORT void AttendClient(ClientPtr /*client */ );

extern _X_EXPORT void MakeClientGrabImpervious(ClientPtr /*client */ );

extern _X_EXPORT void MakeClientGrabPervious(ClientPtr /*client */ );

extern _X_EXPORT void ListenOnOpenFD(int /* fd */ , int /* noxauth */ );

extern _X_EXPORT Bool AddClientOnOpenFD(int /* fd */ );

extern _X_EXPORT CARD32 GetTimeInMillis(void);
extern _X_EXPORT CARD64 GetTimeInMicros(void);

extern _X_EXPORT void AdjustWaitForDelay(void *waitTime,
                                         unsigned long newdelay);

typedef struct _OsTimerRec *OsTimerPtr;

typedef CARD32 (*OsTimerCallback) (OsTimerPtr timer,
                                   CARD32 time,
                                   void *arg);

extern _X_EXPORT void TimerInit(void);

extern _X_EXPORT Bool TimerForce(OsTimerPtr /* timer */ );

#define TimerAbsolute (1<<0)
#define TimerForceOld (1<<1)

extern _X_EXPORT OsTimerPtr TimerSet(OsTimerPtr timer,
                                     int flags,
                                     CARD32 millis,
                                     OsTimerCallback func,
                                     void *arg);

extern _X_EXPORT void TimerCheck(void);
extern _X_EXPORT void TimerCancel(OsTimerPtr /* pTimer */ );
extern _X_EXPORT void TimerFree(OsTimerPtr /* pTimer */ );

extern _X_EXPORT void SetScreenSaverTimer(void);
extern _X_EXPORT void FreeScreenSaverTimer(void);

extern _X_EXPORT void AutoResetServer(int /*sig */ );

extern _X_EXPORT void GiveUp(int /*sig */ );

extern _X_EXPORT void UseMsg(void);

extern _X_EXPORT void ProcessCommandLine(int /*argc */ , char * /*argv */ []);

extern _X_EXPORT int set_font_authorizations(char **authorizations,
                                             int *authlen,
                                             void *client);

/*
 * This function malloc(3)s buffer, terminating the server if there is not
 * enough memory.
 */
extern _X_EXPORT void *
XNFalloc(unsigned long /*amount */ );

/*
 * This function calloc(3)s buffer, terminating the server if there is not
 * enough memory.
 */
extern _X_EXPORT void *
XNFcalloc(unsigned long /*amount */ ) _X_DEPRECATED;

/*
 * This function calloc(3)s buffer, terminating the server if there is not
 * enough memory or the arguments overflow when multiplied
 */
extern _X_EXPORT void *
XNFcallocarray(size_t nmemb, size_t size);

/*
 * This function realloc(3)s passed buffer, terminating the server if there is
 * not enough memory.
 */
extern _X_EXPORT void *
XNFrealloc(void * /*ptr */ , unsigned long /*amount */ );

/*
 * This function reallocarray(3)s passed buffer, terminating the server if
 * there is not enough memory or the arguments overflow when multiplied.
 */
extern _X_EXPORT void *
XNFreallocarray(void *ptr, size_t nmemb, size_t size);

/*
 * This function strdup(3)s passed string. The only difference from the library
 * function that it is safe to pass NULL, as NULL will be returned.
 */
extern _X_EXPORT char *
Xstrdup(const char *s);

/*
 * This function strdup(3)s passed string, terminating the server if there is
 * not enough memory. If NULL is passed to this function, NULL is returned.
 */
extern _X_EXPORT char *
XNFstrdup(const char *s);

/* Include new X*asprintf API */
#include "Xprintf.h"

/* Older api deprecated in favor of the asprintf versions */
extern _X_EXPORT char *
Xprintf(const char *fmt, ...)
_X_ATTRIBUTE_PRINTF(1, 2)
    _X_DEPRECATED;
extern _X_EXPORT char *
Xvprintf(const char *fmt, va_list va)
_X_ATTRIBUTE_PRINTF(1, 0)
    _X_DEPRECATED;
extern _X_EXPORT char *
XNFprintf(const char *fmt, ...)
_X_ATTRIBUTE_PRINTF(1, 2)
    _X_DEPRECATED;
extern _X_EXPORT char *
XNFvprintf(const char *fmt, va_list va)
_X_ATTRIBUTE_PRINTF(1, 0)
    _X_DEPRECATED;

typedef void (*OsSigHandlerPtr) (int /* sig */ );
typedef int (*OsSigWrapperPtr) (int /* sig */ );

extern _X_EXPORT OsSigHandlerPtr
OsSignal(int /* sig */ , OsSigHandlerPtr /* handler */ );
extern _X_EXPORT OsSigWrapperPtr
OsRegisterSigWrapper(OsSigWrapperPtr newWrap);

extern _X_EXPORT int auditTrailLevel;

extern _X_EXPORT void
LockServer(void);
extern _X_EXPORT void
UnlockServer(void);

#ifdef X_PRIVSEP
extern _X_EXPORT int
ChownLock(uid_t, gid_t);
extern _X_EXPORT int
priv_open_device(const char *);
#endif

extern _X_EXPORT int
OsLookupColor(int /*screen */ ,
              char * /*name */ ,
              unsigned /*len */ ,
              unsigned short * /*pred */ ,
              unsigned short * /*pgreen */ ,
              unsigned short * /*pblue */ );

extern _X_EXPORT void
OsInit(void);

extern _X_EXPORT void
OsCleanup(Bool);

extern _X_EXPORT void
OsVendorFatalError(const char *f, va_list args)
_X_ATTRIBUTE_PRINTF(1, 0);

extern _X_EXPORT void
OsVendorInit(void);

extern _X_EXPORT void
OsBlockSignals(void);

extern _X_EXPORT void
OsReleaseSignals(void);

extern _X_EXPORT int
OsBlockSIGIO(void);

extern _X_EXPORT void
OsReleaseSIGIO(void);

extern void
OsResetSignals(void);

extern _X_EXPORT void
OsAbort(void)
    _X_NORETURN;

#if !defined(WIN32)
extern _X_EXPORT int
System(const char *);
extern _X_EXPORT void *
Popen(const char *, const char *);
extern _X_EXPORT int
Pclose(void *);
extern _X_EXPORT void *
Fopen(const char *, const char *);
extern _X_EXPORT int
Fclose(void *);
#else

extern const char *
Win32TempDir(void);

extern int
System(const char *cmdline);

#define Fopen(a,b) fopen(a,b)
#define Fclose(a) fclose(a)
#endif

extern _X_EXPORT void
CheckUserParameters(int argc, char **argv, char **envp);
extern _X_EXPORT void
CheckUserAuthorization(void);

extern _X_EXPORT int
AddHost(ClientPtr /*client */ ,
        int /*family */ ,
        unsigned /*length */ ,
        const void * /*pAddr */ );

extern _X_EXPORT Bool
ForEachHostInFamily(int family,
                    Bool (*func)(
                                           unsigned char *addr,
                                           short len,
                                           void *closure),
                    void *closure);

extern _X_EXPORT int
RemoveHost(ClientPtr client,
           int family,
           unsigned length,
           void *pAddr);

extern _X_EXPORT int
GetHosts(void ** /*data */ ,
         int * /*pnHosts */ ,
         int * /*pLen */ ,
         BOOL * /*pEnabled */ );

typedef struct sockaddr *sockaddrPtr;

extern _X_EXPORT int
InvalidHost(sockaddrPtr /*saddr */ , int /*len */ , ClientPtr client);

#define LCC_UID_SET	(1 << 0)
#define LCC_GID_SET	(1 << 1)
#define LCC_PID_SET	(1 << 2)
#define LCC_ZID_SET	(1 << 3)

typedef struct {
    int fieldsSet;              /* Bit mask of fields set */
    int euid;                   /* Effective uid */
    int egid;                   /* Primary effective group id */
    int nSuppGids;              /* Number of supplementary group ids */
    int *pSuppGids;             /* Array of supplementary group ids */
    int pid;                    /* Process id */
    int zoneid;                 /* Only set on Solaris 10 & later */
} LocalClientCredRec;

extern _X_EXPORT int
GetLocalClientCreds(ClientPtr, LocalClientCredRec **);

extern _X_EXPORT void
FreeLocalClientCreds(LocalClientCredRec *);

extern _X_EXPORT int
ChangeAccessControl(ClientPtr /*client */ , int /*fEnabled */ );

extern _X_EXPORT int
GetClientFd(ClientPtr);

extern _X_EXPORT Bool
ClientIsLocal(ClientPtr client);

extern _X_EXPORT int
GetAccessControl(void);

extern _X_EXPORT void
AddLocalHosts(void);

extern _X_EXPORT void
ResetHosts(const char *display);

extern _X_EXPORT void
EnableLocalAccess(void);

extern _X_EXPORT void
DisableLocalAccess(void);

extern _X_EXPORT void
EnableLocalHost(void);

extern _X_EXPORT void
DisableLocalHost(void);

#ifndef NO_LOCAL_CLIENT_CRED
extern _X_EXPORT void
EnableLocalUser(void);

extern _X_EXPORT void
DisableLocalUser(void);

extern _X_EXPORT void
LocalAccessScopeUser(void);
#endif

extern _X_EXPORT void
AccessUsingXdmcp(void);

extern _X_EXPORT void
DefineSelf(int /*fd */ );

#if XDMCP
extern _X_EXPORT void
AugmentSelf(void *from, int len);

extern _X_EXPORT void
RegisterAuthorizations(void);
#endif

extern _X_EXPORT void
InitAuthorization(const char * /*filename */ );

/* extern int LoadAuthorization(void); */

extern _X_EXPORT int
AuthorizationFromID(XID id,
                    unsigned short *name_lenp,
                    const char **namep,
                    unsigned short *data_lenp, char **datap);

extern _X_EXPORT XID
CheckAuthorization(unsigned int /*namelength */ ,
                   const char * /*name */ ,
                   unsigned int /*datalength */ ,
                   const char * /*data */ ,
                   ClientPtr /*client */ ,
                   const char **        /*reason */
    );

extern _X_EXPORT void
ResetAuthorization(void);

extern _X_EXPORT int
RemoveAuthorization(unsigned short name_length,
                    const char *name,
                    unsigned short data_length, const char *data);

extern _X_EXPORT int
AddAuthorization(unsigned int /*name_length */ ,
                 const char * /*name */ ,
                 unsigned int /*data_length */ ,
                 char * /*data */ );

#ifdef XCSECURITY
extern _X_EXPORT XID
GenerateAuthorization(unsigned int /* name_length */ ,
                      const char * /* name */ ,
                      unsigned int /* data_length */ ,
                      const char * /* data */ ,
                      unsigned int * /* data_length_return */ ,
                      char ** /* data_return */ );
#endif

extern _X_EXPORT int
ddxProcessArgument(int /*argc */ , char * /*argv */ [], int /*i */ );

extern _X_EXPORT void
ddxUseMsg(void);

/* stuff for ReplyCallback */
extern _X_EXPORT CallbackListPtr ReplyCallback;
typedef struct {
    ClientPtr client;
    const void *replyData;
    unsigned long dataLenBytes; /* actual bytes from replyData + pad bytes */
    unsigned long bytesRemaining;
    Bool startOfReply;
    unsigned long padBytes;     /* pad bytes from zeroed array */
} ReplyInfoRec;

/* stuff for FlushCallback */
extern _X_EXPORT CallbackListPtr FlushCallback;

enum ExitCode {
    EXIT_NO_ERROR = 0,
    EXIT_ERR_ABORT = 1,
    EXIT_ERR_CONFIGURE = 2,
    EXIT_ERR_DRIVERS = 3,
};

extern _X_EXPORT void
AbortDDX(enum ExitCode error);
extern _X_EXPORT void
ddxGiveUp(enum ExitCode error);
extern _X_EXPORT int
TimeSinceLastInputEvent(void);

/* Function fallbacks provided by AC_REPLACE_FUNCS in configure.ac */

#ifndef HAVE_REALLOCARRAY
#define reallocarray xreallocarray
extern _X_EXPORT void *
reallocarray(void *optr, size_t nmemb, size_t size);
#endif

#ifndef HAVE_STRCASECMP
#define strcasecmp xstrcasecmp
extern _X_EXPORT int
xstrcasecmp(const char *s1, const char *s2);
#endif

#ifndef HAVE_STRNCASECMP
#define strncasecmp xstrncasecmp
extern _X_EXPORT int
xstrncasecmp(const char *s1, const char *s2, size_t n);
#endif

#ifndef HAVE_STRCASESTR
#define strcasestr xstrcasestr
extern _X_EXPORT char *
xstrcasestr(const char *s, const char *find);
#endif

#ifndef HAVE_STRLCPY
extern _X_EXPORT size_t
strlcpy(char *dst, const char *src, size_t siz);
extern _X_EXPORT size_t
strlcat(char *dst, const char *src, size_t siz);
#endif

#ifndef HAVE_STRNDUP
extern _X_EXPORT char *
strndup(const char *str, size_t n);
#endif

#ifndef HAVE_TIMINGSAFE_MEMCMP
extern _X_EXPORT int
timingsafe_memcmp(const void *b1, const void *b2, size_t len);
#endif

/* Logging. */
typedef enum _LogParameter {
    XLOG_FLUSH,
    XLOG_SYNC,
    XLOG_VERBOSITY,
    XLOG_FILE_VERBOSITY
} LogParameter;

/* Flags for log messages. */
typedef enum {
    X_PROBED,                   /* Value was probed */
    X_CONFIG,                   /* Value was given in the config file */
    X_DEFAULT,                  /* Value is a default */
    X_CMDLINE,                  /* Value was given on the command line */
    X_NOTICE,                   /* Notice */
    X_ERROR,                    /* Error message */
    X_WARNING,                  /* Warning message */
    X_INFO,                     /* Informational message */
    X_NONE,                     /* No prefix */
    X_NOT_IMPLEMENTED,          /* Not implemented */
    X_DEBUG,                    /* Debug message */
    X_UNKNOWN = -1              /* unknown -- this must always be last */
} MessageType;

extern _X_EXPORT const char *
LogInit(const char *fname, const char *backup);
extern void
LogSetDisplay(void);
extern _X_EXPORT void
LogClose(enum ExitCode error);
extern _X_EXPORT Bool
LogSetParameter(LogParameter param, int value);
extern _X_EXPORT void
LogVWrite(int verb, const char *f, va_list args)
_X_ATTRIBUTE_PRINTF(2, 0);
extern _X_EXPORT void
LogWrite(int verb, const char *f, ...)
_X_ATTRIBUTE_PRINTF(2, 3);
extern _X_EXPORT void
LogVMessageVerb(MessageType type, int verb, const char *format, va_list args)
_X_ATTRIBUTE_PRINTF(3, 0);
extern _X_EXPORT void
LogMessageVerb(MessageType type, int verb, const char *format, ...)
_X_ATTRIBUTE_PRINTF(3, 4);
extern _X_EXPORT void
LogMessage(MessageType type, const char *format, ...)
_X_ATTRIBUTE_PRINTF(2, 3);
extern _X_EXPORT void
LogMessageVerbSigSafe(MessageType type, int verb, const char *format, ...)
_X_ATTRIBUTE_PRINTF(3, 4);
extern _X_EXPORT void
LogVMessageVerbSigSafe(MessageType type, int verb, const char *format, va_list args)
_X_ATTRIBUTE_PRINTF(3, 0);

extern _X_EXPORT void
LogVHdrMessageVerb(MessageType type, int verb,
                   const char *msg_format, va_list msg_args,
                   const char *hdr_format, va_list hdr_args)
_X_ATTRIBUTE_PRINTF(3, 0)
_X_ATTRIBUTE_PRINTF(5, 0);
extern _X_EXPORT void
LogHdrMessageVerb(MessageType type, int verb,
                  const char *msg_format, va_list msg_args,
                  const char *hdr_format, ...)
_X_ATTRIBUTE_PRINTF(3, 0)
_X_ATTRIBUTE_PRINTF(5, 6);
extern _X_EXPORT void
LogHdrMessage(MessageType type, const char *msg_format,
              va_list msg_args, const char *hdr_format, ...)
_X_ATTRIBUTE_PRINTF(2, 0)
_X_ATTRIBUTE_PRINTF(4, 5);

extern _X_EXPORT void
FreeAuditTimer(void);
extern _X_EXPORT void
AuditF(const char *f, ...)
_X_ATTRIBUTE_PRINTF(1, 2);
extern _X_EXPORT void
VAuditF(const char *f, va_list args)
_X_ATTRIBUTE_PRINTF(1, 0);
extern _X_EXPORT void
FatalError(const char *f, ...)
_X_ATTRIBUTE_PRINTF(1, 2)
    _X_NORETURN;

#ifdef DEBUG
#define DebugF ErrorF
#else
#define DebugF(...)             /* */
#endif

extern _X_EXPORT void
VErrorF(const char *f, va_list args)
_X_ATTRIBUTE_PRINTF(1, 0);
extern _X_EXPORT void
ErrorF(const char *f, ...)
_X_ATTRIBUTE_PRINTF(1, 2);
extern _X_EXPORT void
VErrorFSigSafe(const char *f, va_list args)
_X_ATTRIBUTE_PRINTF(1, 0);
extern _X_EXPORT void
ErrorFSigSafe(const char *f, ...)
_X_ATTRIBUTE_PRINTF(1, 2);
extern _X_EXPORT void
LogPrintMarkers(void);

extern _X_EXPORT void
xorg_backtrace(void);

extern _X_EXPORT int
os_move_fd(int fd);

#endif                          /* OS_H */
@


1.16
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@d600 5
@


1.15
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d72 1
a72 1
#define xnfcalloc(_num, _size) XNFcalloc((unsigned long)(_num)*(unsigned long)(_size))
d77 4
d229 8
a236 1
XNFcalloc(unsigned long /*amount */ );
d246 7
d425 1
d433 6
d562 8
a569 1
/* strcasecmp.c */
d626 2
@


1.14
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d29 2
a30 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d32 1
a32 1
both that copyright notice and this permission notice appear in 
d35 1
a35 1
software without specific, written prior permission.  
d70 1
a70 1
#ifndef xalloc
a74 4
#define xalloc(size) Xalloc((unsigned long)(size))
#define xcalloc(_num, _size) Xcalloc((unsigned long)(_num)*(unsigned long)(_size))
#define xrealloc(ptr, size) Xrealloc((void *)(ptr), (unsigned long)(size))
#define xfree(ptr) Xfree((void *)(ptr))
d138 2
a139 2
extern _X_EXPORT Bool EstablishNewConnections(ClientPtr /*clientUnused */ ,
                                              void */*closure */ );
d172 2
a173 2
extern _X_EXPORT void AdjustWaitForDelay(void */*waitTime */ ,
                                         unsigned long /*newdelay */ );
d177 3
a179 3
typedef CARD32 (*OsTimerCallback) (OsTimerPtr /* timer */ ,
                                   CARD32 /* time */ ,
                                   void */* arg */ );
d188 5
a192 5
extern _X_EXPORT OsTimerPtr TimerSet(OsTimerPtr /* timer */ ,
                                     int /* flags */ ,
                                     CARD32 /* millis */ ,
                                     OsTimerCallback /* func */ ,
                                     void */* arg */ );
d209 3
a211 34
extern _X_EXPORT int set_font_authorizations(char ** /* authorizations */ ,
                                             int * /*authlen */ ,
                                             void */* client */ );

#ifndef _HAVE_XALLOC_DECLS
#define _HAVE_XALLOC_DECLS

/*
 * Use malloc(3) instead.
 */
extern _X_EXPORT void *
Xalloc(unsigned long /*amount */ ) _X_DEPRECATED;

/*
 * Use calloc(3) instead
 */
extern _X_EXPORT void *
Xcalloc(unsigned long /*amount */ ) _X_DEPRECATED;

/*
 * Use realloc(3) instead
 */
extern _X_EXPORT void *
Xrealloc(void * /*ptr */ , unsigned long /*amount */ )
 _X_DEPRECATED;

/*
 * Use free(3) instead
 */
extern _X_EXPORT void
Xfree(void * /*ptr */ )
    _X_DEPRECATED;

#endif
d366 6
a371 6
ForEachHostInFamily(int /*family */ ,
                    Bool (* /*func */ )(
                                           unsigned char * /* addr */ ,
                                           short /* len */ ,
                                           void */* closure */ ),
                    void */*closure */ );
d374 4
a377 4
RemoveHost(ClientPtr /*client */ ,
           int /*family */ ,
           unsigned /*length */ ,
           void */*pAddr */ );
a389 3
extern _X_EXPORT int
LocalClientCred(ClientPtr, int *, int *);

d423 6
d434 11
d453 1
a453 1
AugmentSelf(void */*from */ , int /*len */ );
@


1.13
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d73 1
a73 1
#define xnfrealloc(ptr, size) XNFrealloc((pointer)(ptr), (unsigned long)(size))
d77 2
a78 2
#define xrealloc(ptr, size) Xrealloc((pointer)(ptr), (unsigned long)(size))
#define xfree(ptr) Xfree((pointer)(ptr))
d143 1
a143 1
                                              pointer /*closure */ );
d169 3
a171 3
#ifdef XQUARTZ
extern void ListenOnOpenFD(int /* fd */ , int /* noxauth */ );
#endif
d176 1
a176 1
extern _X_EXPORT void AdjustWaitForDelay(pointer /*waitTime */ ,
d183 1
a183 1
                                   pointer /* arg */ );
d196 1
a196 1
                                     pointer /* arg */ );
d215 1
a215 1
                                             pointer /* client */ );
d369 1
a369 1
extern _X_EXPORT pointer
d372 2
a373 2
Pclose(pointer);
extern _X_EXPORT pointer
d376 1
a376 1
Fclose(pointer);
d405 2
a406 2
                                           pointer /* closure */ ),
                    pointer /*closure */ );
d412 1
a412 1
           pointer /*pAddr */ );
d415 1
a415 1
GetHosts(pointer * /*data */ ,
d458 1
a458 1
ResetHosts(char *display);
d474 1
a474 1
AugmentSelf(pointer /*from */ , int /*len */ );
d481 1
a481 1
InitAuthorization(char * /*filename */ );
@


1.12
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d101 6
d174 1
d695 3
@


1.11
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d52 1
d91 3
a93 1
extern _X_EXPORT void (*OsVendorVErrorFProc) (const char *, va_list args);
d334 2
a335 1
OsVendorFatalError(void);
d346 9
d371 7
a377 3
#define System(a) system(a)
#define Popen(a,b) popen(a,b)
#define Pclose(a) pclose(a)
a418 3
LocalClient(ClientPtr /* client */ );

extern _X_EXPORT int
d602 1
d627 6
d676 6
@


1.10
log
@Bugfix Update to xserver 1.11.3
@
text
@a24 1

a46 1

d86 1
a86 1
extern void ddxBeforeReset (void);
d90 1
a90 1
extern _X_EXPORT void (*OsVendorVErrorFProc)(const char *, va_list args);
d93 2
a94 3
extern _X_EXPORT int WaitForSomething(
    int* /*pClientsReady*/
);
d96 1
a96 1
extern _X_EXPORT int ReadRequestFromClient(ClientPtr /*client*/);
d98 3
a100 4
extern _X_EXPORT Bool InsertFakeRequest(
    ClientPtr /*client*/, 
    char* /*data*/, 
    int /*count*/);
d102 1
a102 1
extern _X_EXPORT void ResetCurrentRequest(ClientPtr /*client*/);
d110 2
a111 1
extern _X_EXPORT int WriteToClient(ClientPtr /*who*/, int /*count*/, const void* /*buf*/);
d125 7
a131 1
extern _X_EXPORT XID AuthorizationIDOfClient(ClientPtr /*client*/);
d133 2
a134 10
extern _X_EXPORT char *ClientAuthorized(
    ClientPtr /*client*/,
    unsigned int /*proto_n*/,
    char* /*auth_proto*/,
    unsigned int /*string_n*/,
    char* /*auth_string*/);

extern _X_EXPORT Bool EstablishNewConnections(
    ClientPtr /*clientUnused*/,
    pointer /*closure*/);
d138 1
a138 1
extern _X_EXPORT void CloseDownConnection(ClientPtr /*client*/);
d140 1
a140 1
extern _X_EXPORT void AddGeneralSocket(int /*fd*/);
d142 1
a142 1
extern _X_EXPORT void RemoveGeneralSocket(int /*fd*/);
d144 1
a144 1
extern _X_EXPORT void AddEnabledDevice(int /*fd*/);
d146 1
a146 1
extern _X_EXPORT void RemoveEnabledDevice(int /*fd*/);
d148 1
a148 1
extern _X_EXPORT int OnlyListenToOneClient(ClientPtr /*client*/);
d152 1
a152 1
extern _X_EXPORT void IgnoreClient(ClientPtr /*client*/);
d154 1
a154 1
extern _X_EXPORT void AttendClient(ClientPtr /*client*/);
d156 1
a156 1
extern _X_EXPORT void MakeClientGrabImpervious(ClientPtr /*client*/);
d158 1
a158 1
extern _X_EXPORT void MakeClientGrabPervious(ClientPtr /*client*/);
d161 1
a161 1
extern void ListenOnOpenFD(int /* fd */, int /* noxauth */);
d166 8
a173 10
extern _X_EXPORT void AdjustWaitForDelay(
    pointer /*waitTime*/,
    unsigned long /*newdelay*/);

typedef	struct _OsTimerRec *OsTimerPtr;

typedef CARD32 (*OsTimerCallback)(
    OsTimerPtr /* timer */,
    CARD32 /* time */,
    pointer /* arg */);
d177 1
a177 1
extern _X_EXPORT Bool TimerForce(OsTimerPtr /* timer */);
d182 5
a186 6
extern _X_EXPORT OsTimerPtr TimerSet(
    OsTimerPtr /* timer */,
    int /* flags */,
    CARD32 /* millis */,
    OsTimerCallback /* func */,
    pointer /* arg */);
d189 2
a190 2
extern _X_EXPORT void TimerCancel(OsTimerPtr /* pTimer */);
extern _X_EXPORT void TimerFree(OsTimerPtr /* pTimer */);
d195 1
a195 1
extern _X_EXPORT void AutoResetServer(int /*sig*/);
d197 1
a197 1
extern _X_EXPORT void GiveUp(int /*sig*/);
d201 1
a201 1
extern _X_EXPORT void ProcessCommandLine(int /*argc*/, char* /*argv*/[]);
d203 3
a205 4
extern _X_EXPORT int set_font_authorizations(
    char ** /* authorizations */, 
    int * /*authlen */, 
    pointer /* client */);
d213 3
a215 1
extern _X_EXPORT void *Xalloc(unsigned long /*amount*/) _X_DEPRECATED;
d219 3
a221 1
extern _X_EXPORT void *Xcalloc(unsigned long /*amount*/) _X_DEPRECATED;
d225 4
a228 2
extern _X_EXPORT void *Xrealloc(void * /*ptr*/, unsigned long /*amount*/)
    _X_DEPRECATED;
d232 3
a234 1
extern _X_EXPORT void Xfree(void * /*ptr*/) _X_DEPRECATED;
d242 3
a244 1
extern _X_EXPORT void *XNFalloc(unsigned long /*amount*/);
d249 3
a251 1
extern _X_EXPORT void *XNFcalloc(unsigned long /*amount*/);
d256 2
a257 1
extern _X_EXPORT void *XNFrealloc(void * /*ptr*/, unsigned long /*amount*/);
d263 2
a264 1
extern _X_EXPORT char *Xstrdup(const char *s);
d270 2
a271 1
extern _X_EXPORT char *XNFstrdup(const char *s);
d277 16
a292 4
extern _X_EXPORT char *Xprintf(const char *fmt, ...) _X_ATTRIBUTE_PRINTF(1,2) _X_DEPRECATED;
extern _X_EXPORT char *Xvprintf(const char *fmt, va_list va)_X_ATTRIBUTE_PRINTF(1,0) _X_DEPRECATED;
extern _X_EXPORT char *XNFprintf(const char *fmt, ...) _X_ATTRIBUTE_PRINTF(1,2) _X_DEPRECATED;
extern _X_EXPORT char *XNFvprintf(const char *fmt, va_list va)_X_ATTRIBUTE_PRINTF(1,0) _X_DEPRECATED;
d294 2
a295 2
typedef void (*OsSigHandlerPtr)(int /* sig */);
typedef int (*OsSigWrapperPtr)(int /* sig */);
d297 4
a300 2
extern _X_EXPORT OsSigHandlerPtr OsSignal(int /* sig */, OsSigHandlerPtr /* handler */);
extern _X_EXPORT OsSigWrapperPtr OsRegisterSigWrapper(OsSigWrapperPtr newWrap);
d304 4
a307 2
extern _X_EXPORT void LockServer(void);
extern _X_EXPORT void UnlockServer(void);
d310 4
a313 1
extern _X_EXPORT int ChownLock(uid_t, gid_t);
d316 7
a322 7
extern _X_EXPORT int OsLookupColor(
    int	/*screen*/,
    char * /*name*/,
    unsigned /*len*/,
    unsigned short * /*pred*/,
    unsigned short * /*pgreen*/,
    unsigned short * /*pblue*/);
d324 2
a325 1
extern _X_EXPORT void OsInit(void);
d327 2
a328 1
extern _X_EXPORT void OsCleanup(Bool);
d330 2
a331 1
extern _X_EXPORT void OsVendorFatalError(void);
d333 2
a334 1
extern _X_EXPORT void OsVendorInit(void);
d336 2
a337 1
extern _X_EXPORT void OsBlockSignals (void);
d339 2
a340 1
extern _X_EXPORT void OsReleaseSignals (void);
d342 3
a344 1
extern _X_EXPORT void OsAbort (void) _X_NORETURN;
d347 10
a356 5
extern _X_EXPORT int System(char *);
extern _X_EXPORT pointer Popen(char *, char *);
extern _X_EXPORT int Pclose(pointer);
extern _X_EXPORT pointer Fopen(char *, char *);
extern _X_EXPORT int Fclose(pointer);
d365 32
a396 2
extern _X_EXPORT void CheckUserParameters(int argc, char **argv, char **envp);
extern _X_EXPORT void CheckUserAuthorization(void);
d398 2
a399 25
extern _X_EXPORT int AddHost(
    ClientPtr	/*client*/,
    int         /*family*/,
    unsigned    /*length*/,
    const void */*pAddr*/);

extern _X_EXPORT Bool ForEachHostInFamily (
    int	    /*family*/,
    Bool    (* /*func*/ )(
            unsigned char * /* addr */,
            short           /* len */,
            pointer         /* closure */),
    pointer /*closure*/);

extern _X_EXPORT int RemoveHost(
    ClientPtr	/*client*/,
    int         /*family*/,
    unsigned    /*length*/,
    pointer     /*pAddr*/);

extern _X_EXPORT int GetHosts(
    pointer * /*data*/,
    int	    * /*pnHosts*/,
    int	    * /*pLen*/,
    BOOL    * /*pEnabled*/);
d401 2
a402 1
typedef struct sockaddr * sockaddrPtr;
d404 2
a405 5
extern _X_EXPORT int InvalidHost(sockaddrPtr /*saddr*/, int /*len*/, ClientPtr client);

extern _X_EXPORT int LocalClient(ClientPtr /* client */);

extern _X_EXPORT int LocalClientCred(ClientPtr, int *, int *);
d413 7
a419 7
    int fieldsSet;	/* Bit mask of fields set */
    int	euid;		/* Effective uid */
    int egid;		/* Primary effective group id */
    int nSuppGids;	/* Number of supplementary group ids */
    int *pSuppGids;	/* Array of supplementary group ids */
    int pid;		/* Process id */
    int zoneid;		/* Only set on Solaris 10 & later */
d422 4
a425 4
extern _X_EXPORT int GetLocalClientCreds(ClientPtr, LocalClientCredRec **);
extern _X_EXPORT void FreeLocalClientCreds(LocalClientCredRec *);

extern _X_EXPORT int ChangeAccessControl(ClientPtr /*client*/, int /*fEnabled*/);
d427 2
a428 1
extern _X_EXPORT int GetAccessControl(void);
d430 2
d433 2
a434 1
extern _X_EXPORT void AddLocalHosts(void);
d436 2
a437 1
extern _X_EXPORT void ResetHosts(char *display);
d439 2
a440 1
extern _X_EXPORT void EnableLocalHost(void);
d442 2
a443 1
extern _X_EXPORT void DisableLocalHost(void);
d445 2
a446 1
extern _X_EXPORT void AccessUsingXdmcp(void);
d448 2
a449 1
extern _X_EXPORT void DefineSelf(int /*fd*/);
d452 2
a453 1
extern _X_EXPORT void AugmentSelf(pointer /*from*/, int /*len*/);
d455 2
a456 1
extern _X_EXPORT void RegisterAuthorizations(void);
d459 2
a460 1
extern _X_EXPORT void InitAuthorization(char * /*filename*/);
d464 28
a491 29
extern _X_EXPORT int AuthorizationFromID (
	XID 		id,
	unsigned short	*name_lenp,
	char		**namep,
	unsigned short	*data_lenp,
	char		**datap);

extern _X_EXPORT XID CheckAuthorization(
    unsigned int /*namelength*/,
    const char * /*name*/,
    unsigned int /*datalength*/,
    const char * /*data*/,
    ClientPtr /*client*/,
    char ** /*reason*/
);

extern _X_EXPORT void ResetAuthorization(void);

extern _X_EXPORT int RemoveAuthorization (
    unsigned short	name_length,
    const char		*name,
    unsigned short	data_length,
    const char		*data);

extern _X_EXPORT int AddAuthorization(
    unsigned int	/*name_length*/,
    const char *	/*name*/,
    unsigned int	/*data_length*/,
    char *		/*data*/);
d494 7
a500 7
extern _X_EXPORT XID GenerateAuthorization(
    unsigned int   /* name_length */,
    const char	*  /* name */,
    unsigned int   /* data_length */,
    const char	*  /* data */,
    unsigned int * /* data_length_return */,
    char	** /* data_return */);
d503 2
a504 1
extern _X_EXPORT int ddxProcessArgument(int /*argc*/, char * /*argv*/ [], int /*i*/);
d506 2
a507 1
extern _X_EXPORT void ddxUseMsg(void);
d524 4
a527 4
    EXIT_NO_ERROR	= 0,
    EXIT_ERR_ABORT	= 1,
    EXIT_ERR_CONFIGURE	= 2,
    EXIT_ERR_DRIVERS	= 3,
d530 6
a535 3
extern _X_EXPORT void AbortDDX(enum ExitCode error);
extern _X_EXPORT void ddxGiveUp(enum ExitCode error);
extern _X_EXPORT int TimeSinceLastInputEvent(void);
d538 1
a538 1
#if NEED_STRCASECMP
d540 2
a541 1
extern _X_EXPORT int xstrcasecmp(const char *s1, const char *s2);
d544 1
a544 1
#if NEED_STRNCASECMP
d546 2
a547 1
extern _X_EXPORT int xstrncasecmp(const char *s1, const char *s2, size_t n);
d550 1
a550 1
#if NEED_STRCASESTR
d552 9
a560 1
extern _X_EXPORT char *xstrcasestr(const char *s, const char *find);
d563 3
a565 3
#ifndef HAS_STRLCPY
extern _X_EXPORT size_t strlcpy(char *dst, const char *src, size_t siz);
extern _X_EXPORT size_t strlcat(char *dst, const char *src, size_t siz);
d578 11
a588 11
    X_PROBED,			/* Value was probed */
    X_CONFIG,			/* Value was given in the config file */
    X_DEFAULT,			/* Value is a default */
    X_CMDLINE,			/* Value was given on the command line */
    X_NOTICE,			/* Notice */
    X_ERROR,			/* Error message */
    X_WARNING,			/* Warning message */
    X_INFO,			/* Informational message */
    X_NONE,			/* No prefix */
    X_NOT_IMPLEMENTED,		/* Not implemented */
    X_UNKNOWN = -1		/* unknown -- this must always be last */
d591 52
a642 15
extern _X_EXPORT const char *LogInit(const char *fname, const char *backup);
extern _X_EXPORT void LogClose(enum ExitCode error);
extern _X_EXPORT Bool LogSetParameter(LogParameter param, int value);
extern _X_EXPORT void LogVWrite(int verb, const char *f, va_list args) _X_ATTRIBUTE_PRINTF(2,0);
extern _X_EXPORT void LogWrite(int verb, const char *f, ...) _X_ATTRIBUTE_PRINTF(2,3);
extern _X_EXPORT void LogVMessageVerb(MessageType type, int verb, const char *format,
			    va_list args) _X_ATTRIBUTE_PRINTF(3,0);
extern _X_EXPORT void LogMessageVerb(MessageType type, int verb, const char *format,
			   ...) _X_ATTRIBUTE_PRINTF(3,4);
extern _X_EXPORT void LogMessage(MessageType type, const char *format, ...)
			_X_ATTRIBUTE_PRINTF(2,3);
extern _X_EXPORT void FreeAuditTimer(void);
extern _X_EXPORT void AuditF(const char *f, ...) _X_ATTRIBUTE_PRINTF(1,2);
extern _X_EXPORT void VAuditF(const char *f, va_list args) _X_ATTRIBUTE_PRINTF(1,0);
extern _X_EXPORT void FatalError(const char *f, ...) _X_ATTRIBUTE_PRINTF(1,2) _X_NORETURN;
d647 1
a647 1
#define DebugF(...) /* */
d650 8
a657 4
extern _X_EXPORT void VErrorF(const char *f, va_list args) _X_ATTRIBUTE_PRINTF(1,0);
extern _X_EXPORT void ErrorF(const char *f, ...) _X_ATTRIBUTE_PRINTF(1,2);
extern _X_EXPORT void Error(const char *str);
extern _X_EXPORT void LogPrintMarkers(void);
d659 2
a660 1
extern _X_EXPORT void xorg_backtrace(void);
d662 1
a662 1
#endif /* OS_H */
@


1.9
log
@Update to xserver 1.11.2
@
text
@d458 1
a458 1
    unsigned long dataLenBytes;
d461 1
@


1.8
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d54 1
d267 8
a274 4
extern _X_EXPORT char *Xprintf(const char *fmt, ...) _X_ATTRIBUTE_PRINTF(1,2);
extern _X_EXPORT char *Xvprintf(const char *fmt, va_list va);
extern _X_EXPORT char *XNFprintf(const char *fmt, ...) _X_ATTRIBUTE_PRINTF(1,2);
extern _X_EXPORT char *XNFvprintf(const char *fmt, va_list va);
a452 23
/* int ReqLen(xReq *req, ClientPtr client)
 * Given a pointer to a *complete* request, return its length in bytes.
 * Note that if the request is a big request (as defined in the Big
 * Requests extension), the macro lies by returning 4 less than the
 * length that it actually occupies in the request buffer.  This is so you
 * can blindly compare the length with the various sz_<request> constants
 * in Xproto.h without having to know/care about big requests.
 */
#define ReqLen(_pxReq, _client) \
 ((_pxReq->length ? \
     (_client->swapped ? lswaps(_pxReq->length) : _pxReq->length) \
  : ((_client->swapped ? \
	lswapl(((CARD32*)_pxReq)[1]) : ((CARD32*)_pxReq)[1])-1) \
  ) << 2)

/* otherReqTypePtr CastxReq(xReq *req, otherReqTypePtr)
 * Cast the given request to one of type otherReqTypePtr to access
 * fields beyond the length field.
 */
#define CastxReq(_pxReq, otherReqTypePtr) \
    (_pxReq->length ? (otherReqTypePtr)_pxReq \
		    : (otherReqTypePtr)(((CARD32*)_pxReq)+1))

d466 9
a474 2
extern _X_EXPORT void AbortDDX(void);
extern _X_EXPORT void ddxGiveUp(void);
d522 1
a522 1
extern _X_EXPORT void LogClose(void);
d524 1
a524 1
extern _X_EXPORT void LogVWrite(int verb, const char *f, va_list args);
d527 1
a527 1
			    va_list args);
d534 1
a534 1
extern _X_EXPORT void VAuditF(const char *f, va_list args);
d543 1
a543 1
extern _X_EXPORT void VErrorF(const char *f, va_list args);
d545 1
a545 1
extern _X_EXPORT void Error(char *str);
@


1.7
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d217 19
a235 4
extern _X_EXPORT pointer Xalloc(unsigned long /*amount*/);
extern _X_EXPORT pointer Xcalloc(unsigned long /*amount*/);
extern _X_EXPORT pointer Xrealloc(pointer /*ptr*/, unsigned long /*amount*/);
extern _X_EXPORT void Xfree(pointer /*ptr*/);
d238 15
a252 3
extern _X_EXPORT pointer XNFalloc(unsigned long /*amount*/);
extern _X_EXPORT pointer XNFcalloc(unsigned long /*amount*/);
extern _X_EXPORT pointer XNFrealloc(pointer /*ptr*/, unsigned long /*amount*/);
d254 4
d259 5
d265 2
a266 1
extern _X_EXPORT char *Xprintf(const char *fmt, ...);
d268 1
a268 1
extern _X_EXPORT char *XNFprintf(const char *fmt, ...);
d306 1
a306 1
extern _X_EXPORT void OsAbort (void);
d329 1
a329 1
    pointer     /*pAddr*/);
d413 1
a413 1
    char * /*name*/,
d415 1
a415 1
    char * /*data*/,
d424 1
a424 1
    char		*name,
d426 1
a426 1
    char		*data);
d430 1
a430 1
    char *		/*name*/,
d437 1
a437 1
    char	*  /* name */,
d439 1
a439 1
    char	*  /* data */,
a531 7
/* XXX Need to check which GCC versions have the format(printf) attribute. */
#if defined(__GNUC__) && (__GNUC__ > 2)
#define _printf_attribute(a,b) __attribute((format(__printf__,a,b)))
#else
#define _printf_attribute(a,b) /**/
#endif

d536 1
a536 1
extern _X_EXPORT void LogWrite(int verb, const char *f, ...) _printf_attribute(2,3);
d540 1
a540 1
			   ...) _printf_attribute(3,4);
d542 1
a542 1
			_printf_attribute(2,3);
d544 1
a544 1
extern _X_EXPORT void AuditF(const char *f, ...) _printf_attribute(1,2);
d546 1
a546 5
extern _X_EXPORT void FatalError(const char *f, ...) _printf_attribute(1,2)
#if defined(__GNUC__) && (__GNUC__ > 2)
__attribute((noreturn))
#endif
;
d555 1
a555 1
extern _X_EXPORT void ErrorF(const char *f, ...) _printf_attribute(1,2);
@


1.6
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a54 2
#define NullFID ((FID) 0)

a66 1
typedef pointer	FID;
d86 2
a87 5
/* have to put $(SIGNAL_DEFINES) in DEFINES in Imakefile to get this right */
#ifdef SIGNALRETURNSINT
#define SIGVAL int
#else
#define SIGVAL void
d90 3
a92 1
extern void (*OsVendorVErrorFProc)(const char *, va_list args);
d94 1
a94 1
extern int WaitForSomething(
d98 1
a98 1
extern int ReadRequestFromClient(ClientPtr /*client*/);
d100 1
a100 1
extern Bool InsertFakeRequest(
d105 1
a105 1
extern void ResetCurrentRequest(ClientPtr /*client*/);
d107 1
a107 1
extern void FlushAllOutput(void);
d109 1
a109 1
extern void FlushIfCriticalOutputPending(void);
d111 1
a111 1
extern void SetCriticalOutputPending(void);
d113 1
a113 1
extern int WriteToClient(ClientPtr /*who*/, int /*count*/, const void* /*buf*/);
d115 1
a115 1
extern void ResetOsBuffers(void);
d117 1
a117 1
extern void InitConnectionLimits(void);
d119 1
a119 1
extern void NotifyParentProcess(void);
d121 1
a121 1
extern void CreateWellKnownSockets(void);
d123 1
a123 1
extern void ResetWellKnownSockets(void);
d125 1
a125 1
extern void CloseWellKnownConnections(void);
d127 1
a127 1
extern XID AuthorizationIDOfClient(ClientPtr /*client*/);
d129 1
a129 1
extern char *ClientAuthorized(
d136 1
a136 1
extern Bool EstablishNewConnections(
d140 1
a140 1
extern void CheckConnections(void);
d142 1
a142 1
extern void CloseDownConnection(ClientPtr /*client*/);
d144 1
a144 1
extern void AddGeneralSocket(int /*fd*/);
d146 1
a146 1
extern void RemoveGeneralSocket(int /*fd*/);
d148 1
a148 1
extern void AddEnabledDevice(int /*fd*/);
d150 1
a150 1
extern void RemoveEnabledDevice(int /*fd*/);
d152 1
a152 1
extern int OnlyListenToOneClient(ClientPtr /*client*/);
d154 1
a154 1
extern void ListenToAllClients(void);
d156 1
a156 1
extern void IgnoreClient(ClientPtr /*client*/);
d158 1
a158 1
extern void AttendClient(ClientPtr /*client*/);
d160 1
a160 1
extern void MakeClientGrabImpervious(ClientPtr /*client*/);
d162 1
a162 1
extern void MakeClientGrabPervious(ClientPtr /*client*/);
d168 1
a168 1
extern CARD32 GetTimeInMillis(void);
d170 1
a170 1
extern void AdjustWaitForDelay(
d181 1
a181 1
extern void TimerInit(void);
d183 1
a183 1
extern Bool TimerForce(OsTimerPtr /* timer */);
d188 1
a188 1
extern OsTimerPtr TimerSet(
d195 3
a197 3
extern void TimerCheck(void);
extern void TimerCancel(OsTimerPtr /* pTimer */);
extern void TimerFree(OsTimerPtr /* pTimer */);
d199 2
a200 2
extern void SetScreenSaverTimer(void);
extern void FreeScreenSaverTimer(void);
d202 1
a202 1
extern SIGVAL AutoResetServer(int /*sig*/);
d204 1
a204 1
extern SIGVAL GiveUp(int /*sig*/);
d206 1
a206 1
extern void UseMsg(void);
d208 1
a208 1
extern void ProcessCommandLine(int /*argc*/, char* /*argv*/[]);
d210 1
a210 1
extern int set_font_authorizations(
d217 4
a220 4
extern pointer Xalloc(unsigned long /*amount*/);
extern pointer Xcalloc(unsigned long /*amount*/);
extern pointer Xrealloc(pointer /*ptr*/, unsigned long /*amount*/);
extern void Xfree(pointer /*ptr*/);
d223 3
a225 3
extern pointer XNFalloc(unsigned long /*amount*/);
extern pointer XNFcalloc(unsigned long /*amount*/);
extern pointer XNFrealloc(pointer /*ptr*/, unsigned long /*amount*/);
d227 6
a232 6
extern char *Xstrdup(const char *s);
extern char *XNFstrdup(const char *s);
extern char *Xprintf(const char *fmt, ...);
extern char *Xvprintf(const char *fmt, va_list va);
extern char *XNFprintf(const char *fmt, ...);
extern char *XNFvprintf(const char *fmt, va_list va);
d234 2
a235 1
typedef SIGVAL (*OsSigHandlerPtr)(int /* sig */);
d237 2
a238 1
extern OsSigHandlerPtr OsSignal(int /* sig */, OsSigHandlerPtr /* handler */);
d240 1
a240 1
extern int auditTrailLevel;
d242 2
a243 2
extern void LockServer(void);
extern void UnlockServer(void);
d246 1
a246 1
extern int ChownLock(uid_t, gid_t);
d249 1
a249 1
extern int OsLookupColor(
d257 3
a259 1
extern void OsInit(void);
d261 1
a261 1
extern void OsCleanup(Bool);
d263 1
a263 1
extern void OsVendorFatalError(void);
d265 1
a265 1
extern void OsVendorInit(void);
d267 1
a267 1
void OsBlockSignals (void);
d269 1
a269 1
void OsReleaseSignals (void);
d272 5
a276 5
extern int System(char *);
extern pointer Popen(char *, char *);
extern int Pclose(pointer);
extern pointer Fopen(char *, char *);
extern int Fclose(pointer);
d285 2
a286 2
extern void CheckUserParameters(int argc, char **argv, char **envp);
extern void CheckUserAuthorization(void);
d288 1
a288 1
extern int AddHost(
d294 1
a294 1
extern Bool ForEachHostInFamily (
d302 1
a302 1
extern int RemoveHost(
d308 1
a308 1
extern int GetHosts(
d316 1
a316 1
extern int InvalidHost(sockaddrPtr /*saddr*/, int /*len*/, ClientPtr client);
d318 1
a318 1
extern int LocalClient(ClientPtr /* client */);
d320 1
a320 1
extern int LocalClientCred(ClientPtr, int *, int *);
d337 2
a338 2
extern int GetLocalClientCreds(ClientPtr, LocalClientCredRec **);
extern void FreeLocalClientCreds(LocalClientCredRec *); 
d340 1
a340 1
extern int ChangeAccessControl(ClientPtr /*client*/, int /*fEnabled*/);
d342 1
a342 1
extern int GetAccessControl(void);
d345 1
a345 1
extern void AddLocalHosts(void);
d347 1
a347 1
extern void ResetHosts(char *display);
d349 1
a349 1
extern void EnableLocalHost(void);
d351 1
a351 1
extern void DisableLocalHost(void);
d353 1
a353 1
extern void AccessUsingXdmcp(void);
d355 1
a355 1
extern void DefineSelf(int /*fd*/);
d357 2
a358 1
extern void AugmentSelf(pointer /*from*/, int /*len*/);
d360 4
a363 1
extern void InitAuthorization(char * /*filename*/);
d367 1
a367 3
extern void RegisterAuthorizations(void);

extern int AuthorizationFromID (
d374 1
a374 1
extern XID CheckAuthorization(
d383 1
a383 1
extern void ResetAuthorization(void);
d385 1
a385 1
extern int RemoveAuthorization (
d391 1
a391 1
extern int AddAuthorization(
d397 2
a398 1
extern XID GenerateAuthorization(
d405 1
d407 1
a407 1
extern int ddxProcessArgument(int /*argc*/, char * /*argv*/ [], int /*i*/);
d409 1
a409 1
extern void ddxUseMsg(void);
d435 1
a435 1
extern CallbackListPtr ReplyCallback;
d445 1
a445 1
extern CallbackListPtr FlushCallback;
d447 3
a449 3
extern void AbortDDX(void);
extern void ddxGiveUp(void);
extern int TimeSinceLastInputEvent(void);
d454 1
a454 1
extern int xstrcasecmp(const char *s1, const char *s2);
d459 1
a459 1
extern int xstrncasecmp(const char *s1, const char *s2, size_t n);
d464 1
a464 1
extern char *xstrcasestr(const char *s, const char *find);
d468 2
a469 2
extern size_t strlcpy(char *dst, const char *src, size_t siz);
extern size_t strlcat(char *dst, const char *src, size_t siz);
d502 6
a507 6
extern const char *LogInit(const char *fname, const char *backup);
extern void LogClose(void);
extern Bool LogSetParameter(LogParameter param, int value);
extern void LogVWrite(int verb, const char *f, va_list args);
extern void LogWrite(int verb, const char *f, ...) _printf_attribute(2,3);
extern void LogVMessageVerb(MessageType type, int verb, const char *format,
d509 1
a509 1
extern void LogMessageVerb(MessageType type, int verb, const char *format,
d511 1
a511 1
extern void LogMessage(MessageType type, const char *format, ...)
d513 4
a516 4
extern void FreeAuditTimer(void);
extern void AuditF(const char *f, ...) _printf_attribute(1,2);
extern void VAuditF(const char *f, va_list args);
extern void FatalError(const char *f, ...) _printf_attribute(1,2)
d528 4
a531 4
extern void VErrorF(const char *f, va_list args);
extern void ErrorF(const char *f, ...) _printf_attribute(1,2);
extern void Error(char *str);
extern void LogPrintMarkers(void);
d533 1
a533 1
extern void xorg_backtrace(void);
@


1.5
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@a95 1
extern Bool OsDelayInitColors;
d117 1
a117 1
extern int WriteToClient(ClientPtr /*who*/, int /*count*/, char* /*buf*/);
d168 3
a170 1
extern void AvailableClientInput(ClientPtr /* client */);
a211 2
extern void InitGlobals(void);

a230 2
extern void OsInitAllocator(void);

a243 1
#ifdef SERVER_LOCK
d246 1
a249 1
#endif
a266 2
extern int OsInitColors(void);

a402 6
#ifdef COMMANDLINE_CHALLENGED_OPERATING_SYSTEMS
extern void ExpandCommandLine(int * /*pargc*/, char *** /*pargv*/);
#endif

extern void ddxInitGlobals(void);

a429 8
/* stuff for SkippedRequestsCallback */
extern CallbackListPtr SkippedRequestsCallback;
typedef struct {
    xReqPtr req;
    ClientPtr client;
    int numskipped;
} SkippedRequestInfoRec;

d434 1
a434 1
    pointer replyData;
d447 21
d492 1
a492 2
#if defined(__GNUC__) && \
    ((__GNUC__ > 2) || ((__GNUC__ == 2) && (__GNUC_MINOR__ > 4)))
d513 1
a513 2
#if defined(__GNUC__) && \
    ((__GNUC__ > 2) || ((__GNUC__ == 2) && (__GNUC_MINOR__ > 4)))
@


1.4
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d530 2
@


1.3
log
@merge xserver 1.4, 1st pass
@
text
@a52 3
#define ALLOCATE_LOCAL_FALLBACK(_size) Xalloc((unsigned long)(_size))
#define DEALLOCATE_LOCAL_FALLBACK(_ptr) Xfree((pointer)(_ptr))
#include <X11/Xalloca.h>
d124 2
d157 1
a157 1
extern void OnlyListenToOneClient(ClientPtr /*client*/);
d328 18
d522 1
a522 1
#define DebugF(x, ...) /* */
@


1.2
log
@OpenBSD local modifications:
- privilege separation
- some snprintf/strlc{at,py} conversions
- support for more architectures
- signal handler fixes
- default mouse wheel support in config tools
- sunmouse protocol
@
text
@d278 1
a278 1
#if !defined(WIN32) && !defined(__UNIXOS2__)
a353 6
extern XID AuthorizationToID (
	unsigned short	name_length,
	char		*name,
	unsigned short	data_length,
	char		*data);

a401 8
/*
 *  idiom processing stuff
 */

extern xReqPtr PeekNextRequest(xReqPtr req, ClientPtr client, Bool readmore);

extern void SkipRequests(xReqPtr req, ClientPtr client, int numskipped);

d501 6
@


1.1
log
@Initial revision
@
text
@d251 3
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d275 1
a275 1
#if !defined(WIN32)
d351 6
d405 8
a511 6

#ifdef DEBUG
#define DebugF ErrorF
#else
#define DebugF(x, ...) /* */
#endif
@

