head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.2
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	s0SI41sEunLdyFfd;

1.13
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	Te1daavkBLskZ8gc;

1.12
date	2014.12.21.11.41.45;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	OOAr3LJJfv7DyAHR;

1.11
date	2014.12.09.17.58.53;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	vcnjRBuLQw44cPHf;

1.10
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2013.12.08.10.53.01;	author matthieu;	state Exp;
branches
	1.9.2.1
	1.9.4.1;
next	1.8;

1.8
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.16;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.12.16.20.09.36;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.56.09;	author matthieu;	state Exp;
branches;
next	;

1.9.2.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.9.4.1
date	2014.12.09.17.59.33;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.14
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#ifndef DIX_H
#define DIX_H

#include "callback.h"
#include "gc.h"
#include "window.h"
#include "input.h"
#include "cursor.h"
#include "geext.h"
#include "events.h"
#include <X11/extensions/XI.h>

#define EARLIER -1
#define SAMETIME 0
#define LATER 1

#define NullClient ((ClientPtr) 0)
#define REQUEST(type) \
	type *stuff = (type *)client->requestBuffer

#define ARRAY_SIZE(a)  (sizeof((a)) / sizeof((a)[0]))

#define REQUEST_SIZE_MATCH(req)\
    if ((sizeof(req) >> 2) != client->req_len)\
         return(BadLength)

#define REQUEST_AT_LEAST_SIZE(req) \
    if ((sizeof(req) >> 2) > client->req_len )\
         return(BadLength)

#define REQUEST_AT_LEAST_EXTRA_SIZE(req, extra)  \
    if (((sizeof(req) + ((uint64_t) extra)) >> 2) > client->req_len ) \
         return(BadLength)

#define REQUEST_FIXED_SIZE(req, n)\
    if (((sizeof(req) >> 2) > client->req_len) || \
        (((n) >> 2) >= client->req_len) ||                              \
        ((((uint64_t) sizeof(req) + (n) + 3) >> 2) != (uint64_t) client->req_len))  \
         return(BadLength)

#define LEGAL_NEW_RESOURCE(id,client)\
    if (!LegalNewID(id,client)) \
    {\
	client->errorValue = id;\
        return BadIDChoice;\
    }

#define VALIDATE_DRAWABLE_AND_GC(drawID, pDraw, mode)\
    {\
	int tmprc = dixLookupDrawable(&(pDraw), drawID, client, M_ANY, mode);\
	if (tmprc != Success)\
	    return tmprc;\
	tmprc = dixLookupGC(&(pGC), stuff->gc, client, DixUseAccess);\
	if (tmprc != Success)\
	    return tmprc;\
	if ((pGC->depth != pDraw->depth) || (pGC->pScreen != pDraw->pScreen))\
	    return BadMatch;\
    }\
    if (pGC->serialNumber != pDraw->serialNumber)\
	ValidateGC(pDraw, pGC);

#define WriteReplyToClient(pClient, size, pReply) { \
   if ((pClient)->swapped) \
      (*ReplySwapVector[((xReq *)(pClient)->requestBuffer)->reqType]) \
           (pClient, (int)(size), pReply); \
   else WriteToClient(pClient, (int)(size), (pReply)); }

#define WriteSwappedDataToClient(pClient, size, pbuf) \
   if ((pClient)->swapped) \
      (*(pClient)->pSwapReplyFunc)(pClient, (int)(size), pbuf); \
   else WriteToClient(pClient, (int)(size), (pbuf));

typedef struct _TimeStamp *TimeStampPtr;

#ifndef _XTYPEDEF_CLIENTPTR
typedef struct _Client *ClientPtr;      /* also in misc.h */

#define _XTYPEDEF_CLIENTPTR
#endif

typedef struct _WorkQueue *WorkQueuePtr;

extern _X_EXPORT ClientPtr clients[MAXCLIENTS];
extern _X_EXPORT ClientPtr serverClient;
extern _X_EXPORT int currentMaxClients;
extern _X_EXPORT char dispatchExceptionAtReset;

typedef int HWEventQueueType;
typedef HWEventQueueType *HWEventQueuePtr;

extern _X_EXPORT HWEventQueuePtr checkForInput[2];

typedef struct _TimeStamp {
    CARD32 months;              /* really ~49.7 days */
    CARD32 milliseconds;
} TimeStamp;

/* dispatch.c */

extern _X_EXPORT void SetInputCheck(HWEventQueuePtr /*c0 */ ,
                                    HWEventQueuePtr /*c1 */ );

extern _X_EXPORT void CloseDownClient(ClientPtr /*client */ );

extern _X_EXPORT void UpdateCurrentTime(void);

extern _X_EXPORT void UpdateCurrentTimeIf(void);

extern _X_EXPORT int dixDestroyPixmap(void *value,
                                      XID pid);

extern _X_EXPORT void InitClient(ClientPtr client,
                                 int i,
                                 void *ospriv);

extern _X_EXPORT ClientPtr NextAvailableClient(void *ospriv);

extern _X_EXPORT void SendErrorToClient(ClientPtr /*client */ ,
                                        unsigned int /*majorCode */ ,
                                        unsigned int /*minorCode */ ,
                                        XID /*resId */ ,
                                        int /*errorCode */ );

extern _X_EXPORT void MarkClientException(ClientPtr /*client */ );

extern _X_HIDDEN Bool CreateConnectionBlock(void);

/* dixutils.c */

extern _X_EXPORT int CompareISOLatin1Lowered(const unsigned char * /*a */ ,
                                             int alen,
                                             const unsigned char * /*b */ ,
                                             int blen);

extern _X_EXPORT int dixLookupWindow(WindowPtr *result,
                                     XID id,
                                     ClientPtr client, Mask access_mode);

extern _X_EXPORT int dixLookupDrawable(DrawablePtr *result,
                                       XID id,
                                       ClientPtr client,
                                       Mask type_mask, Mask access_mode);

extern _X_EXPORT int dixLookupGC(GCPtr *result,
                                 XID id, ClientPtr client, Mask access_mode);

extern _X_EXPORT int dixLookupFontable(FontPtr *result,
                                       XID id,
                                       ClientPtr client, Mask access_mode);

extern _X_EXPORT int dixLookupClient(ClientPtr *result,
                                     XID id,
                                     ClientPtr client, Mask access_mode);

extern _X_EXPORT void NoopDDA(void);

extern _X_EXPORT int AlterSaveSetForClient(ClientPtr /*client */ ,
                                           WindowPtr /*pWin */ ,
                                           unsigned /*mode */ ,
                                           Bool /*toRoot */ ,
                                           Bool /*map */ );

extern _X_EXPORT void DeleteWindowFromAnySaveSet(WindowPtr /*pWin */ );

extern _X_EXPORT void BlockHandler(void *pTimeout,
                                   void *pReadmask);

extern _X_EXPORT void WakeupHandler(int result,
                                    void *pReadmask);

void
 EnableLimitedSchedulingLatency(void);

void
 DisableLimitedSchedulingLatency(void);

typedef void (*WakeupHandlerProcPtr) (void *blockData,
                                      int result,
                                      void *pReadmask);

extern _X_EXPORT Bool RegisterBlockAndWakeupHandlers(BlockHandlerProcPtr blockHandler,
                                                     WakeupHandlerProcPtr wakeupHandler,
                                                     void *blockData);

extern _X_EXPORT void RemoveBlockAndWakeupHandlers(BlockHandlerProcPtr blockHandler,
                                                   WakeupHandlerProcPtr wakeupHandler,
                                                   void *blockData);

extern _X_EXPORT void InitBlockAndWakeupHandlers(void);

extern _X_EXPORT void ProcessWorkQueue(void);

extern _X_EXPORT void ProcessWorkQueueZombies(void);

extern _X_EXPORT Bool QueueWorkProc(Bool (*function)(ClientPtr clientUnused,
                                                     void *closure),
                                    ClientPtr client,
                                    void *closure);

typedef Bool (*ClientSleepProcPtr) (ClientPtr client,
                                    void *closure);

extern _X_EXPORT Bool ClientSleep(ClientPtr client,
                                  ClientSleepProcPtr function,
                                  void *closure);

#ifndef ___CLIENTSIGNAL_DEFINED___
#define ___CLIENTSIGNAL_DEFINED___
extern _X_EXPORT Bool ClientSignal(ClientPtr /*client */ );
#endif                          /* ___CLIENTSIGNAL_DEFINED___ */

#ifndef ___CLIENTSIGNALALL_DEFINED___
#define ___CLIENTSIGNALALL_DEFINED___
#define CLIENT_SIGNAL_ANY ((void *)-1)
extern _X_EXPORT int ClientSignalAll(ClientPtr /*client*/,
                                     ClientSleepProcPtr /*function*/,
                                     void * /*closure*/);
#endif                          /* ___CLIENTSIGNALALL_DEFINED___ */

extern _X_EXPORT void ClientWakeup(ClientPtr /*client */ );

extern _X_EXPORT Bool ClientIsAsleep(ClientPtr /*client */ );

extern _X_EXPORT void SendGraphicsExpose(ClientPtr /*client */ ,
                                         RegionPtr /*pRgn */ ,
                                         XID /*drawable */ ,
                                         int /*major */ ,
                                         int  /*minor */);

/* atom.c */

extern _X_EXPORT Atom MakeAtom(const char * /*string */ ,
                               unsigned /*len */ ,
                               Bool /*makeit */ );

extern _X_EXPORT Bool ValidAtom(Atom /*atom */ );

extern _X_EXPORT const char *NameForAtom(Atom /*atom */ );

extern _X_EXPORT void
AtomError(void)
    _X_NORETURN;

extern _X_EXPORT void
FreeAllAtoms(void);

extern _X_EXPORT void
InitAtoms(void);

/* main.c */

extern _X_EXPORT void
SetVendorRelease(int release);

extern _X_EXPORT void
SetVendorString(const char *string);

int
dix_main(int argc, char *argv[], char *envp[]);

/* events.c */

extern void
SetMaskForEvent(int /* deviceid */ ,
                Mask /* mask */ ,
                int /* event */ );

extern _X_EXPORT void
ConfineToShape(DeviceIntPtr /* pDev */ ,
               RegionPtr /* shape */ ,
               int * /* px */ ,
               int * /* py */ );

extern _X_EXPORT Bool
IsParent(WindowPtr /* maybeparent */ ,
         WindowPtr /* child */ );

extern _X_EXPORT WindowPtr
GetCurrentRootWindow(DeviceIntPtr pDev);

extern _X_EXPORT WindowPtr
GetSpriteWindow(DeviceIntPtr pDev);

extern _X_EXPORT void
NoticeTime(const DeviceIntPtr dev,
           TimeStamp time);
extern _X_EXPORT void
NoticeEventTime(InternalEvent *ev,
                DeviceIntPtr dev);
extern _X_EXPORT TimeStamp
LastEventTime(int deviceid);
extern _X_EXPORT Bool
LastEventTimeWasReset(int deviceid);
extern _X_EXPORT void
LastEventTimeToggleResetFlag(int deviceid, Bool state);
extern _X_EXPORT void
LastEventTimeToggleResetAll(Bool state);

extern void
EnqueueEvent(InternalEvent * /* ev */ ,
             DeviceIntPtr /* device */ );
extern void
PlayReleasedEvents(void);

extern void
ActivatePointerGrab(DeviceIntPtr /* mouse */ ,
                    GrabPtr /* grab */ ,
                    TimeStamp /* time */ ,
                    Bool /* autoGrab */ );

extern void
DeactivatePointerGrab(DeviceIntPtr /* mouse */ );

extern void
ActivateKeyboardGrab(DeviceIntPtr /* keybd */ ,
                     GrabPtr /* grab */ ,
                     TimeStamp /* time */ ,
                     Bool /* passive */ );

extern void
DeactivateKeyboardGrab(DeviceIntPtr /* keybd */ );

extern BOOL
ActivateFocusInGrab(DeviceIntPtr /* dev */ ,
                    WindowPtr /* old */ ,
                    WindowPtr /* win */ );

extern void
AllowSome(ClientPtr /* client */ ,
          TimeStamp /* time */ ,
          DeviceIntPtr /* thisDev */ ,
          int /* newState */ );

extern void
ReleaseActiveGrabs(ClientPtr client);

extern GrabPtr
CheckPassiveGrabsOnWindow(WindowPtr /* pWin */ ,
                          DeviceIntPtr /* device */ ,
                          InternalEvent * /* event */ ,
                          BOOL /* checkCore */ ,
                          BOOL /* activate */ );

extern _X_EXPORT int
DeliverEventsToWindow(DeviceIntPtr /* pWin */ ,
                      WindowPtr /* pWin */ ,
                      xEventPtr /* pEvents */ ,
                      int /* count */ ,
                      Mask /* filter */ ,
                      GrabPtr /* grab */ );

extern _X_EXPORT void
DeliverRawEvent(RawDeviceEvent * /* ev */ ,
                DeviceIntPtr    /* dev */
    );

extern int
DeliverDeviceEvents(WindowPtr /* pWin */ ,
                    InternalEvent * /* event */ ,
                    GrabPtr /* grab */ ,
                    WindowPtr /* stopAt */ ,
                    DeviceIntPtr /* dev */ );

extern int
DeliverOneGrabbedEvent(InternalEvent * /* event */ ,
                       DeviceIntPtr /* dev */ ,
                       enum InputLevel /* level */ );

extern void
DeliverTouchEvents(DeviceIntPtr /* dev */ ,
                   TouchPointInfoPtr /* ti */ ,
                   InternalEvent * /* ev */ ,
                   XID /* resource */ );

extern void
InitializeSprite(DeviceIntPtr /* pDev */ ,
                 WindowPtr /* pWin */ );
extern void
FreeSprite(DeviceIntPtr pDev);

extern void
UpdateSpriteForScreen(DeviceIntPtr /* pDev */ ,
                      ScreenPtr /* pScreen */ );

extern _X_EXPORT void
WindowHasNewCursor(WindowPtr /* pWin */ );

extern Bool
CheckDeviceGrabs(DeviceIntPtr /* device */ ,
                 DeviceEvent * /* event */ ,
                 WindowPtr /* ancestor */ );

extern void
DeliverFocusedEvent(DeviceIntPtr /* keybd */ ,
                    InternalEvent * /* event */ ,
                    WindowPtr /* window */ );

extern int
DeliverGrabbedEvent(InternalEvent * /* event */ ,
                    DeviceIntPtr /* thisDev */ ,
                    Bool /* deactivateGrab */ );

extern void
FixKeyState(DeviceEvent * /* event */ ,
            DeviceIntPtr /* keybd */ );

extern void
RecalculateDeliverableEvents(WindowPtr /* pWin */ );

extern _X_EXPORT int
OtherClientGone(void *value,
                XID id);

extern void
DoFocusEvents(DeviceIntPtr /* dev */ ,
              WindowPtr /* fromWin */ ,
              WindowPtr /* toWin */ ,
              int /* mode */ );

extern int
SetInputFocus(ClientPtr /* client */ ,
              DeviceIntPtr /* dev */ ,
              Window /* focusID */ ,
              CARD8 /* revertTo */ ,
              Time /* ctime */ ,
              Bool /* followOK */ );

extern int
GrabDevice(ClientPtr /* client */ ,
           DeviceIntPtr /* dev */ ,
           unsigned /* this_mode */ ,
           unsigned /* other_mode */ ,
           Window /* grabWindow */ ,
           unsigned /* ownerEvents */ ,
           Time /* ctime */ ,
           GrabMask * /* mask */ ,
           int /* grabtype */ ,
           Cursor /* curs */ ,
           Window /* confineToWin */ ,
           CARD8 * /* status */ );

extern void
InitEvents(void);

extern void
CloseDownEvents(void);

extern void
DeleteWindowFromAnyEvents(WindowPtr /* pWin */ ,
                          Bool /* freeResources */ );

extern Mask
EventMaskForClient(WindowPtr /* pWin */ ,
                   ClientPtr /* client */ );

extern _X_EXPORT int
DeliverEvents(WindowPtr /*pWin */ ,
              xEventPtr /*xE */ ,
              int /*count */ ,
              WindowPtr /*otherParent */ );

extern Bool
CheckMotion(DeviceEvent * /* ev */ ,
            DeviceIntPtr /* pDev */ );

extern _X_EXPORT void
WriteEventsToClient(ClientPtr /*pClient */ ,
                    int /*count */ ,
                    xEventPtr /*events */ );

extern _X_EXPORT int
TryClientEvents(ClientPtr /*client */ ,
                DeviceIntPtr /* device */ ,
                xEventPtr /*pEvents */ ,
                int /*count */ ,
                Mask /*mask */ ,
                Mask /*filter */ ,
                GrabPtr /*grab */ );

extern _X_EXPORT void
WindowsRestructured(void);

extern int
SetClientPointer(ClientPtr /* client */ ,
                 DeviceIntPtr /* device */ );

extern _X_EXPORT DeviceIntPtr
PickPointer(ClientPtr /* client */ );

extern _X_EXPORT DeviceIntPtr
PickKeyboard(ClientPtr /* client */ );

extern Bool
IsInterferingGrab(ClientPtr /* client */ ,
                  DeviceIntPtr /* dev */ ,
                  xEvent * /* events */ );

#ifdef PANORAMIX
extern _X_EXPORT void
ReinitializeRootWindow(WindowPtr win, int xoff, int yoff);
#endif

#ifdef RANDR
extern _X_EXPORT void
ScreenRestructured(ScreenPtr pScreen);
#endif

#ifndef HAVE_FFS
extern _X_EXPORT int
ffs(int i);
#endif

/*
 *  ServerGrabCallback stuff
 */

extern _X_EXPORT CallbackListPtr ServerGrabCallback;

typedef enum { SERVER_GRABBED, SERVER_UNGRABBED,
    CLIENT_PERVIOUS, CLIENT_IMPERVIOUS
} ServerGrabState;

typedef struct {
    ClientPtr client;
    ServerGrabState grabstate;
} ServerGrabInfoRec;

/*
 *  EventCallback stuff
 */

extern _X_EXPORT CallbackListPtr EventCallback;

typedef struct {
    ClientPtr client;
    xEventPtr events;
    int count;
} EventInfoRec;

/*
 *  DeviceEventCallback stuff
 */

extern _X_EXPORT CallbackListPtr DeviceEventCallback;

typedef struct {
    InternalEvent *event;
    DeviceIntPtr device;
} DeviceEventInfoRec;

extern int
XItoCoreType(int xi_type);
extern Bool
DevHasCursor(DeviceIntPtr pDev);
extern _X_EXPORT Bool
IsPointerDevice(DeviceIntPtr dev);
extern _X_EXPORT Bool
IsKeyboardDevice(DeviceIntPtr dev);
extern Bool
IsPointerEvent(InternalEvent *event);
extern Bool
IsTouchEvent(InternalEvent *event);
extern _X_EXPORT Bool
IsMaster(DeviceIntPtr dev);
extern _X_EXPORT Bool
IsFloating(DeviceIntPtr dev);

extern _X_HIDDEN void
CopyKeyClass(DeviceIntPtr device, DeviceIntPtr master);
extern _X_HIDDEN int
CorePointerProc(DeviceIntPtr dev, int what);
extern _X_HIDDEN int
CoreKeyboardProc(DeviceIntPtr dev, int what);

extern _X_EXPORT void *lastGLContext;

#endif                          /* DIX_H */
@


1.13
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d258 8
@


1.12
log
@Update to xorg-server  1.16.3.

Most of the 1.16.2->1.16.3 changes are the security patches that
where already there. This adds some extra fixes plus a few unrelated
bug fixes.
@
text
@d29 2
a30 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d32 1
a32 1
both that copyright notice and this permission notice appear in 
d35 1
a35 1
software without specific, written prior permission.  
d155 2
a156 2
extern _X_EXPORT int dixDestroyPixmap(void */*value */ ,
                                      XID /*pid */ );
d158 3
a160 3
extern _X_EXPORT void InitClient(ClientPtr /*client */ ,
                                 int /*i */ ,
                                 void */*ospriv */ );
d162 1
a162 1
extern _X_EXPORT ClientPtr NextAvailableClient(void */*ospriv */ );
d211 2
a212 2
extern _X_EXPORT void BlockHandler(void */*pTimeout */ ,
                                   void */*pReadmask */ );
d214 2
a215 2
extern _X_EXPORT void WakeupHandler(int /*result */ ,
                                    void */*pReadmask */ );
d223 11
a233 15
typedef void (*WakeupHandlerProcPtr) (void */* blockData */ ,
                                      int /* result */ ,
                                      void */* pReadmask */ );

extern _X_EXPORT Bool RegisterBlockAndWakeupHandlers(BlockHandlerProcPtr
                                                     /*blockHandler */ ,
                                                     WakeupHandlerProcPtr
                                                     /*wakeupHandler */ ,
                                                     void */*blockData */ );

extern _X_EXPORT void RemoveBlockAndWakeupHandlers(BlockHandlerProcPtr
                                                   /*blockHandler */ ,
                                                   WakeupHandlerProcPtr
                                                   /*wakeupHandler */ ,
                                                   void */*blockData */ );
d241 11
a251 16
extern _X_EXPORT Bool QueueWorkProc(Bool (* /*function */ )(
                                                               ClientPtr
                                                               /*clientUnused */
                                                               ,
                                                               void *
                                                               /*closure */ ),
                                    ClientPtr /*client */ ,
                                    void */*closure */
    );

typedef Bool (*ClientSleepProcPtr) (ClientPtr /*client */ ,
                                    void */*closure */ );

extern _X_EXPORT Bool ClientSleep(ClientPtr /*client */ ,
                                  ClientSleepProcPtr /* function */ ,
                                  void */*closure */ );
d262 6
d449 2
a450 2
OtherClientGone(void */* value */ ,
                XID /* id */ );
@


1.11
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d83 1
a83 1
        ((n >> 2) >= client->req_len) || \
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d77 4
d83 2
a84 1
        (((sizeof(req) + (n) + 3) >> 2) != client->req_len)) \
@


1.9
log
@Update to xserver 1.14.4
@
text
@d150 1
a150 1
extern _X_EXPORT int dixDestroyPixmap(pointer /*value */ ,
d155 1
a155 1
                                 pointer /*ospriv */ );
d157 1
a157 1
extern _X_EXPORT ClientPtr NextAvailableClient(pointer /*ospriv */ );
d206 2
a207 2
extern _X_EXPORT void BlockHandler(pointer /*pTimeout */ ,
                                   pointer /*pReadmask */ );
d210 1
a210 1
                                    pointer /*pReadmask */ );
d218 1
a218 1
typedef void (*WakeupHandlerProcPtr) (pointer /* blockData */ ,
d220 1
a220 1
                                      pointer /* pReadmask */ );
d226 1
a226 1
                                                     pointer /*blockData */ );
d232 1
a232 1
                                                   pointer /*blockData */ );
d244 1
a244 1
                                                               pointer
d247 1
a247 1
                                    pointer     /*closure */
d251 1
a251 1
                                    pointer /*closure */ );
d255 1
a255 1
                                  pointer /*closure */ );
d292 4
a295 1
SetVendorString(char *string);
d447 1
a447 1
OtherClientGone(pointer /* value */ ,
d610 2
@


1.9.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a76 4
#define REQUEST_AT_LEAST_EXTRA_SIZE(req, extra)  \
    if (((sizeof(req) + ((uint64_t) extra)) >> 2) > client->req_len ) \
         return(BadLength)

d79 1
a79 2
        ((n >> 2) >= client->req_len) || \
        ((((uint64_t) sizeof(req) + (n) + 3) >> 2) != (uint64_t) client->req_len))  \
@


1.9.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a76 4
#define REQUEST_AT_LEAST_EXTRA_SIZE(req, extra)  \
    if (((sizeof(req) + ((uint64_t) extra)) >> 2) > client->req_len ) \
         return(BadLength)

d79 1
a79 2
        ((n >> 2) >= client->req_len) || \
        ((((uint64_t) sizeof(req) + (n) + 3) >> 2) != (uint64_t) client->req_len))  \
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d318 3
d323 8
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d67 2
d91 6
a96 6
	int rc = dixLookupDrawable(&(pDraw), drawID, client, M_ANY, mode);\
	if (rc != Success)\
	    return rc;\
	rc = dixLookupGC(&(pGC), stuff->gc, client, DixUseAccess);\
	if (rc != Success)\
	    return rc;\
d107 1
a107 1
      else (void) WriteToClient(pClient, (int)(size), (char *)(pReply)); }
d112 1
a112 1
   else (void) WriteToClient (pClient, (int)(size), (char *)(pbuf));
d318 2
a319 1
NoticeEventTime(InternalEvent *ev);
d400 2
@


1.6
log
@Update to xserver 1.11.2
@
text
@a24 1

a66 1

a100 1

d115 2
a116 1
typedef struct _Client *ClientPtr; /* also in misc.h */
d120 1
a120 1
typedef struct _WorkQueue	*WorkQueuePtr;
d128 1
a128 1
typedef HWEventQueueType* HWEventQueuePtr;
d133 1
a133 1
    CARD32 months;	/* really ~49.7 days */
d135 1
a135 1
}           TimeStamp;
d139 2
a140 3
extern _X_EXPORT void SetInputCheck(
    HWEventQueuePtr /*c0*/,
    HWEventQueuePtr /*c1*/);
d142 1
a142 2
extern _X_EXPORT void CloseDownClient(
    ClientPtr /*client*/);
d148 14
a161 18
extern _X_EXPORT int dixDestroyPixmap(
    pointer /*value*/,
    XID /*pid*/);

extern _X_EXPORT void InitClient(
    ClientPtr /*client*/,
    int /*i*/,
    pointer /*ospriv*/);

extern _X_EXPORT ClientPtr NextAvailableClient(
    pointer /*ospriv*/);

extern _X_EXPORT void SendErrorToClient(
    ClientPtr /*client*/,
    unsigned int /*majorCode*/,
    unsigned int /*minorCode*/,
    XID /*resId*/,
    int /*errorCode*/);
d163 1
a163 2
extern _X_EXPORT void MarkClientException(
    ClientPtr /*client*/);
d166 1
d169 24
a192 36
extern _X_EXPORT int CompareISOLatin1Lowered(
    unsigned char * /*a*/,
    int alen,
    unsigned char * /*b*/,
    int blen);

extern _X_EXPORT int dixLookupWindow(
    WindowPtr *result,
    XID id,
    ClientPtr client,
    Mask access_mode);

extern _X_EXPORT int dixLookupDrawable(
    DrawablePtr *result,
    XID id,
    ClientPtr client,
    Mask type_mask,
    Mask access_mode);

extern _X_EXPORT int dixLookupGC(
    GCPtr *result,
    XID id,
    ClientPtr client,
    Mask access_mode);

extern _X_EXPORT int dixLookupFontable(
    FontPtr *result,
    XID id,
    ClientPtr client,
    Mask access_mode);

extern _X_EXPORT int dixLookupClient(
    ClientPtr *result,
    XID id,
    ClientPtr client,
    Mask access_mode);
d196 13
a208 17
extern _X_EXPORT int AlterSaveSetForClient(
    ClientPtr /*client*/,
    WindowPtr /*pWin*/,
    unsigned /*mode*/,
    Bool /*toRoot*/,
    Bool /*map*/);
  
extern _X_EXPORT void DeleteWindowFromAnySaveSet(
    WindowPtr /*pWin*/);

extern _X_EXPORT void BlockHandler(
    pointer /*pTimeout*/,
    pointer /*pReadmask*/);

extern _X_EXPORT void WakeupHandler(
    int /*result*/,
    pointer /*pReadmask*/);
d211 1
a211 1
EnableLimitedSchedulingLatency(void);
d214 1
a214 1
DisableLimitedSchedulingLatency(void);
d216 15
a230 14
typedef void (* WakeupHandlerProcPtr)(
    pointer /* blockData */,
    int /* result */,
    pointer /* pReadmask */);

extern _X_EXPORT Bool RegisterBlockAndWakeupHandlers(
    BlockHandlerProcPtr /*blockHandler*/,
    WakeupHandlerProcPtr /*wakeupHandler*/,
    pointer /*blockData*/);

extern _X_EXPORT void RemoveBlockAndWakeupHandlers(
    BlockHandlerProcPtr /*blockHandler*/,
    WakeupHandlerProcPtr /*wakeupHandler*/,
    pointer /*blockData*/);
d238 16
a253 16
extern _X_EXPORT Bool QueueWorkProc(
    Bool (* /*function*/)(
        ClientPtr /*clientUnused*/,
        pointer /*closure*/),
    ClientPtr /*client*/,
    pointer /*closure*/
);

typedef Bool (* ClientSleepProcPtr)(
    ClientPtr /*client*/,
    pointer /*closure*/);

extern _X_EXPORT Bool ClientSleep(
    ClientPtr /*client*/,
    ClientSleepProcPtr /* function */,
    pointer /*closure*/);
d257 2
a258 3
extern _X_EXPORT Bool ClientSignal(
    ClientPtr /*client*/);
#endif /* ___CLIENTSIGNAL_DEFINED___ */
d260 1
a260 2
extern _X_EXPORT void ClientWakeup(
    ClientPtr /*client*/);
d262 1
a262 2
extern _X_EXPORT Bool ClientIsAsleep(
    ClientPtr /*client*/);
d266 3
a268 4
extern _X_EXPORT Atom MakeAtom(
    const char * /*string*/,
    unsigned /*len*/,
    Bool /*makeit*/);
d270 1
a270 2
extern _X_EXPORT Bool ValidAtom(
    Atom /*atom*/);
d272 1
a272 2
extern _X_EXPORT const char *NameForAtom(
    Atom /*atom*/);
d274 3
a276 1
extern _X_EXPORT void AtomError(void) _X_NORETURN;
d278 2
a279 1
extern _X_EXPORT void FreeAllAtoms(void);
d281 2
a282 1
extern _X_EXPORT void InitAtoms(void);
d286 2
a287 1
extern _X_EXPORT void SetVendorRelease(int release);
d289 2
a290 1
extern _X_EXPORT void SetVendorString(char *string);
d294 220
a513 205
extern void SetMaskForEvent(
    int /* deviceid */,
    Mask /* mask */,
    int /* event */);

extern _X_EXPORT void ConfineToShape(
    DeviceIntPtr /* pDev */, 
    RegionPtr /* shape */, 
    int*      /* px */,
    int*      /* py */);

extern _X_EXPORT Bool IsParent(
    WindowPtr /* maybeparent */,
    WindowPtr /* child */);

extern _X_EXPORT WindowPtr GetCurrentRootWindow(DeviceIntPtr pDev);

extern _X_EXPORT WindowPtr GetSpriteWindow(DeviceIntPtr pDev);


extern _X_EXPORT void NoticeEventTime(InternalEvent *ev);

extern void EnqueueEvent(
    InternalEvent * /* ev */,
    DeviceIntPtr  /* device */);

extern void ActivatePointerGrab(
    DeviceIntPtr /* mouse */,
    GrabPtr /* grab */,
    TimeStamp /* time */,
    Bool /* autoGrab */);

extern void DeactivatePointerGrab(
    DeviceIntPtr /* mouse */);

extern void ActivateKeyboardGrab(
    DeviceIntPtr /* keybd */,
    GrabPtr /* grab */,
    TimeStamp /* time */,
    Bool /* passive */);

extern void DeactivateKeyboardGrab(
    DeviceIntPtr /* keybd */);

extern BOOL ActivateFocusInGrab(
    DeviceIntPtr /* dev */,
    WindowPtr /* old */,
    WindowPtr /* win */);

extern void AllowSome(
    ClientPtr	/* client */,
    TimeStamp /* time */,
    DeviceIntPtr /* thisDev */,
    int /* newState */);

extern void ReleaseActiveGrabs(
    ClientPtr client);

extern GrabPtr CheckPassiveGrabsOnWindow(
    WindowPtr /* pWin */,
    DeviceIntPtr /* device */,
    InternalEvent * /* event */,
    BOOL /* checkCore */,
    BOOL /* activate */);

extern _X_EXPORT int DeliverEventsToWindow(
    DeviceIntPtr /* pWin */,
    WindowPtr /* pWin */,
    xEventPtr /* pEvents */,
    int /* count */,
    Mask /* filter */,
    GrabPtr /* grab */);

extern _X_EXPORT void DeliverRawEvent(
    RawDeviceEvent* /* ev */,
    DeviceIntPtr /* dev */
);

extern int DeliverDeviceEvents(
    WindowPtr /* pWin */,
    InternalEvent* /* event */,
    GrabPtr /* grab */,
    WindowPtr /* stopAt */,
    DeviceIntPtr /* dev */);

extern void InitializeSprite(
    DeviceIntPtr /* pDev */,
    WindowPtr    /* pWin */);

extern void UpdateSpriteForScreen(
    DeviceIntPtr /* pDev */,
    ScreenPtr /* pScreen */);

extern _X_EXPORT void WindowHasNewCursor(
    WindowPtr /* pWin */);

extern Bool CheckDeviceGrabs(
    DeviceIntPtr /* device */,
    DeviceEvent* /* event */,
    WindowPtr /* ancestor */);

extern void DeliverFocusedEvent(
    DeviceIntPtr /* keybd */,
    InternalEvent* /* event */,
    WindowPtr /* window */);

extern int DeliverGrabbedEvent(
    InternalEvent* /* event */,
    DeviceIntPtr /* thisDev */,
    Bool /* deactivateGrab */);

extern void FixKeyState(
    DeviceEvent* /* event */,
    DeviceIntPtr /* keybd */);

extern void RecalculateDeliverableEvents(
    WindowPtr /* pWin */);

extern _X_EXPORT int OtherClientGone(
    pointer /* value */,
    XID /* id */);

extern void DoFocusEvents(
    DeviceIntPtr /* dev */,
    WindowPtr /* fromWin */,
    WindowPtr /* toWin */,
    int /* mode */);

extern int SetInputFocus(
    ClientPtr /* client */,
    DeviceIntPtr /* dev */,
    Window /* focusID */,
    CARD8 /* revertTo */,
    Time /* ctime */,
    Bool /* followOK */);

extern int GrabDevice(
    ClientPtr /* client */,
    DeviceIntPtr /* dev */,
    unsigned /* this_mode */,
    unsigned /* other_mode */,
    Window /* grabWindow */,
    unsigned /* ownerEvents */,
    Time /* ctime */,
    GrabMask* /* mask */,
    int /* grabtype */,
    Cursor /* curs */,
    Window /* confineToWin */,
    CARD8 * /* status */);

extern void InitEvents(void);

extern void CloseDownEvents(void);

extern void DeleteWindowFromAnyEvents(
    WindowPtr	/* pWin */,
    Bool /* freeResources */);


extern Mask EventMaskForClient(
    WindowPtr /* pWin */,
    ClientPtr /* client */);



extern _X_EXPORT int DeliverEvents(
    WindowPtr /*pWin*/,
    xEventPtr /*xE*/,
    int /*count*/,
    WindowPtr /*otherParent*/);

extern Bool CheckMotion(
    DeviceEvent* /* ev */,
    DeviceIntPtr /* pDev */);

extern _X_EXPORT void WriteEventsToClient(
    ClientPtr /*pClient*/,
    int	     /*count*/,
    xEventPtr /*events*/);

extern _X_EXPORT int TryClientEvents(
    ClientPtr /*client*/,
    DeviceIntPtr /* device */,
    xEventPtr /*pEvents*/,
    int /*count*/,
    Mask /*mask*/,
    Mask /*filter*/,
    GrabPtr /*grab*/);

extern _X_EXPORT void WindowsRestructured(void);

extern int SetClientPointer(
        ClientPtr /* client */,
        DeviceIntPtr /* device */);

extern _X_EXPORT DeviceIntPtr PickPointer(
    ClientPtr /* client */);

extern _X_EXPORT DeviceIntPtr PickKeyboard(
    ClientPtr /* client */);

extern Bool IsInterferingGrab(
        ClientPtr /* client */,
        DeviceIntPtr /* dev */,
        xEvent* /* events */);
d516 2
a517 1
extern _X_EXPORT void ReinitializeRootWindow(WindowPtr win, int xoff, int yoff);
d522 1
a522 1
ScreenRestructured (ScreenPtr pScreen);
d525 4
a528 2
extern _X_EXPORT int ffs(int i);

d536 3
a538 2
typedef enum {SERVER_GRABBED, SERVER_UNGRABBED,
	      CLIENT_PERVIOUS, CLIENT_IMPERVIOUS } ServerGrabState;
d568 23
a590 11
extern int XItoCoreType(int xi_type);
extern Bool DevHasCursor(DeviceIntPtr pDev);
extern _X_EXPORT Bool IsPointerDevice( DeviceIntPtr dev);
extern _X_EXPORT Bool IsKeyboardDevice(DeviceIntPtr dev);
extern Bool IsPointerEvent(InternalEvent *event);
extern _X_EXPORT Bool IsMaster(DeviceIntPtr dev);
extern _X_EXPORT Bool IsFloating(DeviceIntPtr dev);

extern _X_HIDDEN void CopyKeyClass(DeviceIntPtr device, DeviceIntPtr master);
extern _X_HIDDEN int CorePointerProc(DeviceIntPtr dev, int what);
extern _X_HIDDEN int CoreKeyboardProc(DeviceIntPtr dev, int what);
d592 1
a592 1
#endif /* DIX_H */
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d375 7
d390 5
d416 1
a416 1
    int /* checkFirst */);
d423 1
a423 1
extern void DeliverGrabbedEvent(
d578 1
a582 31


/*
 * These are deprecated compatibility functions and will be removed soon!
 * Please use the noted replacements instead.
 */
/* replaced by dixLookupWindow */
extern _X_EXPORT WindowPtr SecurityLookupWindow(
    XID id,
    ClientPtr client,
    Mask access_mode);
/* replaced by dixLookupWindow */
extern _X_EXPORT WindowPtr LookupWindow(
    XID id,
    ClientPtr client);

/* replaced by dixLookupDrawable */
extern _X_EXPORT pointer SecurityLookupDrawable(
    XID id,
    ClientPtr client,
    Mask access_mode);

/* replaced by dixLookupDrawable */
extern _X_EXPORT pointer LookupDrawable(
    XID id,
    ClientPtr client);

/* replaced by dixLookupClient */
extern _X_EXPORT ClientPtr LookupClient(
    XID id,
    ClientPtr client);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d51 1
d86 1
a86 1
        return(BadIDChoice);\
d98 1
a98 1
	    return (BadMatch);\
d202 6
d303 1
a303 1
extern _X_EXPORT void AtomError(void);
a521 30
/*
 *  callback manager stuff
 */

#ifndef _XTYPEDEF_CALLBACKLISTPTR
typedef struct _CallbackList *CallbackListPtr; /* also in misc.h */
#define _XTYPEDEF_CALLBACKLISTPTR
#endif

typedef void (*CallbackProcPtr) (
    CallbackListPtr *, pointer, pointer);

extern _X_EXPORT Bool AddCallback(
    CallbackListPtr * /*pcbl*/,
    CallbackProcPtr /*callback*/,
    pointer /*data*/);

extern _X_EXPORT Bool DeleteCallback(
    CallbackListPtr * /*pcbl*/,
    CallbackProcPtr /*callback*/,
    pointer /*data*/);

extern _X_EXPORT void CallCallbacks(
    CallbackListPtr * /*pcbl*/,
    pointer /*call_data*/);

extern _X_EXPORT void DeleteCallbackList(
    CallbackListPtr * /*pcbl*/);

extern _X_EXPORT void InitCallbackManager(void);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d56 1
d123 4
a126 4
extern ClientPtr clients[MAXCLIENTS];
extern ClientPtr serverClient;
extern int currentMaxClients;
extern char dispatchExceptionAtReset;
d131 1
a131 1
extern HWEventQueuePtr checkForInput[2];
d140 1
a140 1
extern void SetInputCheck(
d144 1
a144 1
extern void CloseDownClient(
d147 1
a147 1
extern void UpdateCurrentTime(void);
d149 1
a149 1
extern void UpdateCurrentTimeIf(void);
d151 1
a151 1
extern int dixDestroyPixmap(
d155 1
a155 1
extern void InitClient(
d160 1
a160 1
extern ClientPtr NextAvailableClient(
d163 1
a163 1
extern void SendErrorToClient(
d170 1
a170 1
extern void MarkClientException(
d173 1
a173 2
extern void ddxBeforeReset (void);

d176 1
a176 6
extern void CopyISOLatin1Lowered(
    unsigned char * /*dest*/,
    unsigned char * /*source*/,
    int /*length*/);

extern int CompareISOLatin1Lowered(
d182 1
a182 1
extern int dixLookupWindow(
d188 1
a188 1
extern int dixLookupDrawable(
d195 1
a195 1
extern int dixLookupGC(
d201 1
a201 1
extern int dixLookupClient(
d207 1
a207 1
extern void NoopDDA(void);
d209 1
a209 1
extern int AlterSaveSetForClient(
d216 1
a216 1
extern void DeleteWindowFromAnySaveSet(
d219 1
a219 1
extern void BlockHandler(
d223 1
a223 1
extern void WakeupHandler(
d238 1
a238 1
extern Bool RegisterBlockAndWakeupHandlers(
d243 1
a243 1
extern void RemoveBlockAndWakeupHandlers(
d248 1
a248 1
extern void InitBlockAndWakeupHandlers(void);
d250 1
a250 1
extern void ProcessWorkQueue(void);
d252 1
a252 1
extern void ProcessWorkQueueZombies(void);
d254 1
a254 1
extern Bool QueueWorkProc(
d266 1
a266 1
extern Bool ClientSleep(
d273 1
a273 1
extern Bool ClientSignal(
d277 1
a277 1
extern void ClientWakeup(
d280 1
a280 1
extern Bool ClientIsAsleep(
d285 2
a286 2
extern Atom MakeAtom(
    char * /*string*/,
d290 1
a290 1
extern Bool ValidAtom(
d293 1
a293 1
extern char *NameForAtom(
d296 1
a296 1
extern void AtomError(void);
d298 1
a298 1
extern void FreeAllAtoms(void);
d300 1
a300 1
extern void InitAtoms(void);
d304 1
a304 1
extern void SetVendorRelease(int release);
d306 1
a306 1
extern void SetVendorString(char *string);
d315 1
a315 1
extern void ConfineToShape(
d321 1
a321 1
extern Bool IsParent(
d325 1
a325 1
extern WindowPtr GetCurrentRootWindow(DeviceIntPtr pDev);
d327 1
a327 1
extern WindowPtr GetSpriteWindow(DeviceIntPtr pDev);
d330 1
a330 1
extern void NoticeEventTime(xEventPtr /* xE */);
d333 2
a334 3
    xEventPtr /* xE */,
    DeviceIntPtr /* device */,
    int	/* count */);
d354 5
d363 1
a363 2
    int /* newState */,
    Bool /* core */);
d368 1
a368 1
extern int DeliverEventsToWindow(
d374 1
a374 2
    GrabPtr /* grab */,
    int /* mskidx */);
d378 1
a378 1
    xEventPtr /* xE */,
d381 1
a381 9
    DeviceIntPtr /* dev */,
    int /* count */);

extern void DefineInitialRootWindow(
    WindowPtr /* win */);

extern void SetupSprite(
    DeviceIntPtr /* pDev */,
    ScreenPtr    /* pScreen */);
d391 1
a391 1
extern void WindowHasNewCursor(
d396 2
a397 3
    xEventPtr /* xE */,
    int /* checkFirst */,
    int /* count */);
d401 2
a402 3
    xEventPtr /* xE */,
    WindowPtr /* window */,
    int /* count */);
d405 1
a405 1
    xEventPtr /* xE */,
d407 1
a407 2
    Bool /* deactivateGrab */,
    int /* count */);
a408 1
#ifdef XKB
d410 1
a410 1
    xEvent * /* xE */,
a411 1
#endif /* XKB */
d416 1
a416 1
extern int OtherClientGone(
d442 5
a446 3
    Mask /* mask */,
    CARD8 * /* status */,
    Bool /* coreGrab */);
a448 4
extern void InitSprite(
        DeviceIntPtr /* pDev */, 
        Bool /* hasCursor */
        );
d463 1
a463 1
extern int DeliverEvents(
d469 2
a470 3
extern Bool
CheckMotion(
    xEvent* /* xE */, 
d473 1
a473 1
extern void WriteEventsToClient(
d478 1
a478 1
extern int TryClientEvents(
d487 1
a487 1
extern void WindowsRestructured(void);
d489 2
a490 3
extern Bool SetClientPointer(
        ClientPtr /* client */, 
        ClientPtr /* setter */, 
d493 1
a493 1
extern DeviceIntPtr PickPointer(
d496 1
a496 1
extern DeviceIntPtr PickKeyboard(
d505 1
a505 1
extern void ReinitializeRootWindow(WindowPtr win, int xoff, int yoff);
d509 1
a509 1
void
d513 1
a513 1
extern int ffs(int i);
d527 1
a527 1
extern Bool AddCallback(
d532 1
a532 1
extern Bool DeleteCallback(
d537 1
a537 1
extern void CallCallbacks(
d541 1
a541 1
extern void DeleteCallbackList(
d544 1
a544 1
extern void InitCallbackManager(void);
d550 1
a550 1
extern CallbackListPtr ServerGrabCallback;
d564 1
a564 1
extern CallbackListPtr EventCallback;
d576 1
a576 1
extern CallbackListPtr DeviceEventCallback;
d579 2
a580 2
    xEventPtr events;
    int count;
d585 9
a593 3
extern Bool IsPointerDevice( DeviceIntPtr dev);
extern Bool IsKeyboardDevice(DeviceIntPtr dev);
extern Bool IsPointerEvent(xEvent* xE);
d600 1
a600 1
extern WindowPtr SecurityLookupWindow(
d605 1
a605 1
extern WindowPtr LookupWindow(
d610 1
a610 1
extern pointer SecurityLookupDrawable(
d616 1
a616 1
extern pointer LookupDrawable(
d621 1
a621 1
extern ClientPtr LookupClient(
a624 12
/* GE stuff */
extern void SetGenericFilter(int extension, Mask* filters);
extern int ExtGrabDevice(ClientPtr client,
                         DeviceIntPtr dev,
                         int device_mode,
                         WindowPtr grabWindow,
                         WindowPtr confineTo,
                         TimeStamp ctime,
                         Bool ownerEvents,
                         CursorPtr cursor, 
                         Mask xi_mask,
                         GenericMaskPtr ge_masks);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d54 3
d64 1
a64 1
	register type *stuff = (type *)client->requestBuffer
d122 1
a122 4
#ifdef XPRINT
extern ClientPtr requestingClient;
#endif
extern ClientPtr *clients;
a171 1
#if defined(DDXBEFORERESET)
a172 1
#endif
d219 1
a219 1
    Bool /*remap*/);
d232 6
d316 1
d320 5
d330 1
a330 1
extern WindowPtr GetCurrentRootWindow(void);
d332 1
a332 1
extern WindowPtr GetSpriteWindow(void);
d364 2
a365 1
    int /* newState */);
d371 1
d390 8
d399 2
a400 1
     ScreenPtr /* pScreen */);
d459 2
a460 1
    CARD8 * /* status */);
d463 4
d487 4
d499 1
d508 16
d603 5
a607 15
/* strcasecmp.c */
#if NEED_STRCASECMP
#define strcasecmp xstrcasecmp
extern int xstrcasecmp(const char *s1, const char *s2);
#endif

#if NEED_STRNCASECMP
#define strncasecmp xstrncasecmp
extern int xstrncasecmp(const char *s1, const char *s2, size_t n);
#endif

#if NEED_STRCASESTR
#define strcasestr xstrcasestr
extern char *xstrcasestr(const char *s, const char *find);
#endif
a612 1

a617 1

d639 12
@


1.1
log
@Initial revision
@
text
@d84 1
a84 85
/* XXX if you are using this macro, you are probably not generating Match
 * errors where appropriate */
#define LOOKUP_DRAWABLE(did, client)\
    ((client->lastDrawableID == did) ? \
     client->lastDrawable : (DrawablePtr)LookupDrawable(did, client))

#ifdef XACE

#define SECURITY_VERIFY_DRAWABLE(pDraw, did, client, mode)\
    {\
	pDraw = (DrawablePtr) SecurityLookupIDByClass(client, did, \
						      RC_DRAWABLE, mode);\
	if (!pDraw) \
	{\
	    client->errorValue = did; \
	    return BadDrawable;\
	}\
	if (pDraw->type == UNDRAWABLE_WINDOW)\
	    return BadMatch;\
    }

#define SECURITY_VERIFY_GEOMETRABLE(pDraw, did, client, mode)\
    {\
	pDraw = (DrawablePtr) SecurityLookupIDByClass(client, did, \
						      RC_DRAWABLE, mode);\
	if (!pDraw) \
	{\
	    client->errorValue = did; \
	    return BadDrawable;\
	}\
    }

#define SECURITY_VERIFY_GC(pGC, rid, client, mode)\
	pGC = (GC *) SecurityLookupIDByType(client, rid, RT_GC, mode);\
    if (!pGC)\
    {\
	client->errorValue = rid;\
	return (BadGC);\
    }

#define VERIFY_DRAWABLE(pDraw, did, client)\
	SECURITY_VERIFY_DRAWABLE(pDraw, did, client, SecurityUnknownAccess)

#define VERIFY_GEOMETRABLE(pDraw, did, client)\
	SECURITY_VERIFY_GEOMETRABLE(pDraw, did, client, SecurityUnknownAccess)

#define VERIFY_GC(pGC, rid, client)\
	SECURITY_VERIFY_GC(pGC, rid, client, SecurityUnknownAccess)

#else /* not XACE */

#define VERIFY_DRAWABLE(pDraw, did, client)\
    if (client->lastDrawableID == did)\
	pDraw = client->lastDrawable;\
    else \
    {\
	pDraw = (DrawablePtr) LookupIDByClass(did, RC_DRAWABLE);\
	if (!pDraw) \
	{\
	    client->errorValue = did; \
	    return BadDrawable;\
	}\
	if (pDraw->type == UNDRAWABLE_WINDOW)\
	    return BadMatch;\
    }

#define VERIFY_GEOMETRABLE(pDraw, did, client)\
    if (client->lastDrawableID == did)\
	pDraw = client->lastDrawable;\
    else \
    {\
	pDraw = (DrawablePtr) LookupIDByClass(did, RC_DRAWABLE);\
	if (!pDraw) \
	{\
	    client->errorValue = did; \
	    return BadDrawable;\
	}\
    }

#define VERIFY_GC(pGC, rid, client)\
    if (client->lastGCID == rid)\
        pGC = client->lastGC;\
    else\
	pGC = (GC *)LookupIDByType(rid, RT_GC);\
    if (!pGC)\
d86 7
a92 76
	client->errorValue = rid;\
	return (BadGC);\
    }

#define SECURITY_VERIFY_DRAWABLE(pDraw, did, client, mode)\
	VERIFY_DRAWABLE(pDraw, did, client)

#define SECURITY_VERIFY_GEOMETRABLE(pDraw, did, client, mode)\
	VERIFY_GEOMETRABLE(pDraw, did, client)

#define SECURITY_VERIFY_GC(pGC, rid, client, mode)\
	VERIFY_GC(pGC, rid, client)

#endif /* XACE */

/*
 * We think that most hardware implementations of DBE will want
 * LookupID*(dbe_back_buffer_id) to return the window structure that the
 * id is a back buffer for.  Since both front and back buffers will
 * return the same structure, you need to be able to distinguish
 * somewhere what kind of buffer (front/back) was being asked for, so
 * that ddx can render to the right place.  That's the problem that the
 * following code solves.  Note: we couldn't embed this in the LookupID*
 * functions because the VALIDATE_DRAWABLE_AND_GC macro often circumvents
 * those functions by checking a one-element cache.  That's why we're
 * mucking with VALIDATE_DRAWABLE_AND_GC.
 * 
 * If you put -DNEED_DBE_BUF_BITS into PervasiveDBEDefines, the window
 * structure will have two additional bits defined, srcBuffer and
 * dstBuffer, and their values will be maintained via the macros
 * SET_DBE_DSTBUF and SET_DBE_SRCBUF (below).  If you also
 * put -DNEED_DBE_BUF_VALIDATE into PervasiveDBEDefines, the function
 * DbeValidateBuffer will be called any time the bits change to give you
 * a chance to do some setup.  See the DBE code for more details on this
 * function.  We put in these levels of conditionality so that you can do
 * just what you need to do, and no more.  If neither of these defines
 * are used, the bits won't be there, and VALIDATE_DRAWABLE_AND_GC will
 * be unchanged.	dpw
 */

#if defined(NEED_DBE_BUF_BITS)
#define SET_DBE_DSTBUF(_pDraw, _drawID) \
        SET_DBE_BUF(_pDraw, _drawID, dstBuffer, TRUE)
#define SET_DBE_SRCBUF(_pDraw, _drawID) \
        SET_DBE_BUF(_pDraw, _drawID, srcBuffer, FALSE)
#if defined (NEED_DBE_BUF_VALIDATE)
#define SET_DBE_BUF(_pDraw, _drawID, _whichBuffer, _dstbuf) \
    if (_pDraw->type == DRAWABLE_WINDOW)\
    {\
	int thisbuf = (_pDraw->id == _drawID);\
	if (thisbuf != ((WindowPtr)_pDraw)->_whichBuffer)\
	{\
	     ((WindowPtr)_pDraw)->_whichBuffer = thisbuf;\
	     DbeValidateBuffer((WindowPtr)_pDraw, _drawID, _dstbuf);\
	}\
     }
#else /* want buffer bits, but don't need to call DbeValidateBuffer */
#define SET_DBE_BUF(_pDraw, _drawID, _whichBuffer, _dstbuf) \
    if (_pDraw->type == DRAWABLE_WINDOW)\
    {\
	((WindowPtr)_pDraw)->_whichBuffer = (_pDraw->id == _drawID);\
    }
#endif /* NEED_DBE_BUF_VALIDATE */
#else /* don't want buffer bits in window */
#define SET_DBE_DSTBUF(_pDraw, _drawID) /**/
#define SET_DBE_SRCBUF(_pDraw, _drawID) /**/
#endif /* NEED_DBE_BUF_BITS */

#define VALIDATE_DRAWABLE_AND_GC(drawID, pDraw, pGC, client)\
    if ((stuff->gc == INVALID) || (client->lastGCID != stuff->gc) ||\
	(client->lastDrawableID != drawID))\
    {\
	SECURITY_VERIFY_GEOMETRABLE(pDraw, drawID, client, SecurityWriteAccess);\
	SECURITY_VERIFY_GC(pGC, stuff->gc, client, SecurityReadAccess);\
	if ((pGC->depth != pDraw->depth) ||\
	    (pGC->pScreen != pDraw->pScreen))\
a93 4
	client->lastDrawable = pDraw;\
	client->lastDrawableID = drawID;\
	client->lastGC = pGC;\
	client->lastGCID = stuff->gc;\
a94 6
    else\
    {\
        pGC = client->lastGC;\
        pDraw = client->lastDrawable;\
    }\
    SET_DBE_DSTBUF(pDraw, drawID);\
d119 1
d121 1
a149 4
extern void InitSelections(void);

extern void FlushClientCaches(XID /*id*/);

a153 2
extern void CloseDownRetainedResources(void);

a168 3
extern void DeleteWindowFromAnySelections(
    WindowPtr /*pWin*/);

a171 19
extern int GetGeometry(
    ClientPtr /*client*/,
    xGetGeometryReply* /* wa */);

extern int SendConnSetup(
    ClientPtr /*client*/,
    char* /*reason*/);

extern int DoGetImage(
    ClientPtr	/*client*/,
    int /*format*/,
    Drawable /*drawable*/,
    int /*x*/, 
    int /*y*/, 
    int /*width*/, 
    int /*height*/,
    Mask /*planemask*/,
    xGetImageReply ** /*im_return*/);

d189 24
a212 41
#ifdef XACE

extern WindowPtr SecurityLookupWindow(
    XID /*rid*/,
    ClientPtr /*client*/,
    Mask /*access_mode*/);

extern pointer SecurityLookupDrawable(
    XID /*rid*/,
    ClientPtr /*client*/,
    Mask /*access_mode*/);

extern WindowPtr LookupWindow(
    XID /*rid*/,
    ClientPtr /*client*/);

extern pointer LookupDrawable(
    XID /*rid*/,
    ClientPtr /*client*/);

#else

extern WindowPtr LookupWindow(
    XID /*rid*/,
    ClientPtr /*client*/);

extern pointer LookupDrawable(
    XID /*rid*/,
    ClientPtr /*client*/);

#define SecurityLookupWindow(rid, client, access_mode) \
	LookupWindow(rid, client)

#define SecurityLookupDrawable(rid, client, access_mode) \
	LookupDrawable(rid, client)

#endif /* XACE */

extern ClientPtr LookupClient(
    XID /*rid*/,
    ClientPtr /*client*/);
a331 7
extern void ComputeFreezes(void);

extern void CheckGrabForSyncs(
    DeviceIntPtr /* dev */,
    Bool /* thisMode */,
    Bool /* otherMode */);

d378 3
d486 1
a486 7
extern void ResetClientPrivates(void);

extern int AllocateClientPrivateIndex(void);

extern Bool AllocateClientPrivate(
    int /*index*/,
    unsigned /*amount*/);
a499 23
typedef Bool (*AddCallbackProcPtr) (
    CallbackListPtr *, CallbackProcPtr, pointer);

typedef Bool (*DeleteCallbackProcPtr) (
    CallbackListPtr *, CallbackProcPtr, pointer);

typedef void (*CallCallbacksProcPtr) (
    CallbackListPtr *, pointer);

typedef void (*DeleteCallbackListProcPtr) (
    CallbackListPtr *);

typedef struct _CallbackProcs {
    AddCallbackProcPtr		AddCallback;
    DeleteCallbackProcPtr	DeleteCallback;
    CallCallbacksProcPtr	CallCallbacks;
    DeleteCallbackListProcPtr	DeleteCallbackList;
} CallbackFuncsRec, *CallbackFuncsPtr;

extern Bool CreateCallbackList(
    CallbackListPtr * /*pcbl*/,
    CallbackFuncsPtr /*cbfuncs*/);

d556 16
d573 2
a574 1
 * SelectionCallback stuff
d577 10
a586 1
extern CallbackListPtr SelectionCallback;
d588 5
a592 5
typedef enum {
    SelectionSetOwner,
    SelectionWindowDestroy,
    SelectionClientClose
} SelectionCallbackKind;
d594 4
a597 4
typedef struct {
    struct _Selection	    *selection;
    SelectionCallbackKind   kind;
} SelectionInfoRec;
d599 4
a602 5
/* strcasecmp.c */
#if NEED_STRCASECMP
#define strcasecmp xstrcasecmp
extern int xstrcasecmp(char *s1, char *s2);
#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.1.99.903 from X.Org 7.2RC3
@
text
@a817 3
/* ffs.c */
extern int ffs(int i);

@


1.1.1.3
log
@xserver 1.4
@
text
@d84 154
d242 4
a245 9
	int rc;\
	rc = dixLookupDrawable(&(pDraw), drawID, client, M_ANY,\
			       DixWriteAccess);\
	if (rc != Success)\
	    return rc;\
	rc = dixLookupGC(&(pGC), stuff->gc, client, DixReadAccess);\
	if (rc != Success)\
	    return rc;\
	if ((pGC->depth != pDraw->depth) || (pGC->pScreen != pDraw->pScreen))\
d257 1
d319 2
d342 4
d350 11
d378 35
a412 24
extern int dixLookupWindow(
    WindowPtr *result,
    XID id,
    ClientPtr client,
    Mask access_mode);

extern int dixLookupDrawable(
    DrawablePtr *result,
    XID id,
    ClientPtr client,
    Mask type_mask,
    Mask access_mode);

extern int dixLookupGC(
    GCPtr *result,
    XID id,
    ClientPtr client,
    Mask access_mode);

extern int dixLookupClient(
    ClientPtr *result,
    XID id,
    ClientPtr client,
    Mask access_mode);
d414 5
a418 10
/*
 * These are deprecated compatibility functions and will be removed soon!
 * Please use the new dixLookup*() functions above.
 */
extern WindowPtr SecurityLookupWindow(XID, ClientPtr, Mask);
extern WindowPtr LookupWindow(XID, ClientPtr);
extern pointer SecurityLookupDrawable(XID, ClientPtr, Mask);
extern pointer LookupDrawable(XID, ClientPtr);
extern ClientPtr LookupClient(XID, ClientPtr);
/* end deprecated functions */
a703 2
extern int ffs(int i);

d735 4
d817 3
@


