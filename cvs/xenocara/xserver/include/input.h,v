head	1.15;
access;
symbols
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.2
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.2
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	s0SI41sEunLdyFfd;

1.14
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	Te1daavkBLskZ8gc;

1.13
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	cVXoV5PxI8YrEaVA;

1.12
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.12.08.10.53.02;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.09.28.15.36.35;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.18;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.18;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.10;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/************************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

#ifndef INPUT_H
#define INPUT_H

#include "misc.h"
#include "screenint.h"
#include <X11/Xmd.h>
#include <X11/Xproto.h>
#include <stdint.h>
#include "window.h"             /* for WindowPtr */
#include "xkbrules.h"
#include "events.h"
#include "list.h"
#include <X11/extensions/XI2.h>

#define DEVICE_INIT	0
#define DEVICE_ON	1
#define DEVICE_OFF	2
#define DEVICE_CLOSE	3
#define DEVICE_ABORT	4

#define POINTER_RELATIVE	(1 << 1)
#define POINTER_ABSOLUTE	(1 << 2)
#define POINTER_ACCELERATE	(1 << 3)
#define POINTER_SCREEN		(1 << 4)        /* Data in screen coordinates */
#define POINTER_NORAW		(1 << 5)        /* Don't generate RawEvents */
#define POINTER_EMULATED	(1 << 6)        /* Event was emulated from another event */
#define POINTER_DESKTOP		(1 << 7)        /* Data in desktop coordinates */

/* GetTouchEvent flags */
#define TOUCH_ACCEPT            (1 << 0)
#define TOUCH_REJECT            (1 << 1)
#define TOUCH_PENDING_END       (1 << 2)
#define TOUCH_CLIENT_ID         (1 << 3)        /* touch ID is the client-visible id */
#define TOUCH_REPLAYING         (1 << 4)        /* event is being replayed */
#define TOUCH_POINTER_EMULATED  (1 << 5)        /* touch event may be pointer emulated */
#define TOUCH_END               (1 << 6)        /* really end this touch now */

/*int constants for pointer acceleration schemes*/
#define PtrAccelNoOp            0
#define PtrAccelPredictable     1
#define PtrAccelLightweight     2
#define PtrAccelDefault         PtrAccelPredictable

#define MAX_VALUATORS 36
/* Maximum number of valuators, divided by six, rounded up, to get number
 * of events. */
#define MAX_VALUATOR_EVENTS 6
#define MAX_BUTTONS 256         /* completely arbitrarily chosen */

#define NO_AXIS_LIMITS -1

#define MAP_LENGTH	MAX_BUTTONS
#define DOWN_LENGTH	(MAX_BUTTONS/8)      /* 256/8 => number of bytes to hold 256 bits */
#define NullGrab ((GrabPtr)NULL)
#define PointerRootWin ((WindowPtr)PointerRoot)
#define NoneWin ((WindowPtr)None)
#define NullDevice ((DevicePtr)NULL)

#ifndef FollowKeyboard
#define FollowKeyboard 		3
#endif
#ifndef FollowKeyboardWin
#define FollowKeyboardWin  ((WindowPtr) FollowKeyboard)
#endif
#ifndef RevertToFollowKeyboard
#define RevertToFollowKeyboard	3
#endif

enum InputLevel {
    CORE = 1,
    XI = 2,
    XI2 = 3,
};

typedef unsigned long Leds;
typedef struct _OtherClients *OtherClientsPtr;
typedef struct _InputClients *InputClientsPtr;
typedef struct _DeviceIntRec *DeviceIntPtr;
typedef struct _ValuatorClassRec *ValuatorClassPtr;
typedef struct _ClassesRec *ClassesPtr;
typedef struct _SpriteRec *SpritePtr;
typedef struct _TouchClassRec *TouchClassPtr;
typedef struct _TouchPointInfo *TouchPointInfoPtr;
typedef struct _DDXTouchPointInfo *DDXTouchPointInfoPtr;
typedef union _GrabMask GrabMask;

typedef struct _ValuatorMask ValuatorMask;

/* The DIX stores incoming input events in this list */
extern InternalEvent *InputEventList;

typedef int (*DeviceProc) (DeviceIntPtr /*device */ ,
                           int /*what */ );

typedef void (*ProcessInputProc) (InternalEvent * /*event */ ,
                                  DeviceIntPtr /*device */ );

typedef Bool (*DeviceHandleProc) (DeviceIntPtr /*device */ ,
                                  void *        /*data */
    );

typedef void (*DeviceUnwrapProc) (DeviceIntPtr /*device */ ,
                                  DeviceHandleProc /*proc */ ,
                                  void *        /*data */
    );

/* pointer acceleration handling */
typedef void (*PointerAccelSchemeProc) (DeviceIntPtr /*device */ ,
                                        ValuatorMask * /*valuators */ ,
                                        CARD32 /*evtime */ );

typedef void (*DeviceCallbackProc) (DeviceIntPtr /*pDev */ );

struct _ValuatorAccelerationRec;
typedef Bool (*PointerAccelSchemeInitProc) (DeviceIntPtr /*dev */ ,
                                            struct _ValuatorAccelerationRec *
                                            /*protoScheme */ );

typedef struct _DeviceRec {
    void *devicePrivate;
    ProcessInputProc processInputProc;  /* current */
    ProcessInputProc realInputProc;     /* deliver */
    ProcessInputProc enqueueInputProc;  /* enqueue */
    Bool on;                    /* used by DDX to keep state */
} DeviceRec, *DevicePtr;

typedef struct {
    int click, bell, bell_pitch, bell_duration;
    Bool autoRepeat;
    unsigned char autoRepeats[32];
    Leds leds;
    unsigned char id;
} KeybdCtrl;

typedef struct {
    KeySym *map;
    KeyCode minKeyCode, maxKeyCode;
    int mapWidth;
} KeySymsRec, *KeySymsPtr;

typedef struct {
    int num, den, threshold;
    unsigned char id;
} PtrCtrl;

typedef struct {
    int resolution, min_value, max_value;
    int integer_displayed;
    unsigned char id;
} IntegerCtrl;

typedef struct {
    int max_symbols, num_symbols_supported;
    int num_symbols_displayed;
    KeySym *symbols_supported;
    KeySym *symbols_displayed;
    unsigned char id;
} StringCtrl;

typedef struct {
    int percent, pitch, duration;
    unsigned char id;
} BellCtrl;

typedef struct {
    Leds led_values;
    Mask led_mask;
    unsigned char id;
} LedCtrl;

extern _X_EXPORT KeybdCtrl defaultKeyboardControl;
extern _X_EXPORT PtrCtrl defaultPointerControl;

typedef struct _InputOption InputOption;
typedef struct _XI2Mask XI2Mask;

typedef struct _InputAttributes {
    char *product;
    char *vendor;
    char *device;
    char *pnp_id;
    char *usb_id;
    char **tags;                /* null-terminated */
    uint32_t flags;
} InputAttributes;

#define ATTR_KEYBOARD (1<<0)
#define ATTR_POINTER (1<<1)
#define ATTR_JOYSTICK (1<<2)
#define ATTR_TABLET (1<<3)
#define ATTR_TOUCHPAD (1<<4)
#define ATTR_TOUCHSCREEN (1<<5)

/* Key/Button has been run through all input processing and events sent to clients. */
#define KEY_PROCESSED 1
#define BUTTON_PROCESSED 1
/* Key/Button has not been fully processed, no events have been sent. */
#define KEY_POSTED 2
#define BUTTON_POSTED 2

extern _X_EXPORT void set_key_down(DeviceIntPtr pDev, int key_code, int type);
extern _X_EXPORT void set_key_up(DeviceIntPtr pDev, int key_code, int type);
extern _X_EXPORT int key_is_down(DeviceIntPtr pDev, int key_code, int type);
extern _X_EXPORT void set_button_down(DeviceIntPtr pDev, int button, int type);
extern _X_EXPORT void set_button_up(DeviceIntPtr pDev, int button, int type);
extern _X_EXPORT int button_is_down(DeviceIntPtr pDev, int button, int type);

extern void InitCoreDevices(void);
extern void InitXTestDevices(void);

extern _X_EXPORT DeviceIntPtr AddInputDevice(ClientPtr /*client */ ,
                                             DeviceProc /*deviceProc */ ,
                                             Bool /*autoStart */ );

extern _X_EXPORT Bool EnableDevice(DeviceIntPtr /*device */ ,
                                   BOOL /* sendevent */ );

extern _X_EXPORT Bool ActivateDevice(DeviceIntPtr /*device */ ,
                                     BOOL /* sendevent */ );

extern _X_EXPORT Bool DisableDevice(DeviceIntPtr /*device */ ,
                                    BOOL /* sendevent */ );
extern void DisableAllDevices(void);
extern int InitAndStartDevices(void);

extern void CloseDownDevices(void);
extern void AbortDevices(void);

extern void UndisplayDevices(void);

extern _X_EXPORT int RemoveDevice(DeviceIntPtr /*dev */ ,
                                  BOOL /* sendevent */ );

extern _X_EXPORT int NumMotionEvents(void);

extern _X_EXPORT int dixLookupDevice(DeviceIntPtr * /* dev */ ,
                                     int /* id */ ,
                                     ClientPtr /* client */ ,
                                     Mask /* access_mode */ );

extern _X_EXPORT void QueryMinMaxKeyCodes(KeyCode * /*minCode */ ,
                                          KeyCode * /*maxCode */ );

extern _X_EXPORT Bool InitButtonClassDeviceStruct(DeviceIntPtr /*device */ ,
                                                  int /*numButtons */ ,
                                                  Atom * /* labels */ ,
                                                  CARD8 * /*map */ );

extern _X_INTERNAL ValuatorClassPtr AllocValuatorClass(ValuatorClassPtr src,
                                                       int numAxes);

extern _X_EXPORT Bool InitValuatorClassDeviceStruct(DeviceIntPtr /*device */ ,
                                                    int /*numAxes */ ,
                                                    Atom * /* labels */ ,
                                                    int /*numMotionEvents */ ,
                                                    int /*mode */ );

extern _X_EXPORT Bool InitPointerAccelerationScheme(DeviceIntPtr /*dev */ ,
                                                    int /*scheme */ );

extern _X_EXPORT Bool InitFocusClassDeviceStruct(DeviceIntPtr /*device */ );

extern _X_EXPORT Bool InitTouchClassDeviceStruct(DeviceIntPtr /*device */ ,
                                                 unsigned int /*max_touches */ ,
                                                 unsigned int /*mode */ ,
                                                 unsigned int /*numAxes */ );

typedef void (*BellProcPtr) (int percent,
                             DeviceIntPtr device,
                             void *ctrl,
                             int feedbackClass);

typedef void (*KbdCtrlProcPtr) (DeviceIntPtr /*device */ ,
                                KeybdCtrl * /*ctrl */ );

typedef void (*PtrCtrlProcPtr) (DeviceIntPtr /*device */ ,
                                PtrCtrl * /*ctrl */ );

extern _X_EXPORT Bool InitPtrFeedbackClassDeviceStruct(DeviceIntPtr /*device */
                                                       ,
                                                       PtrCtrlProcPtr
                                                       /*controlProc */ );

typedef void (*StringCtrlProcPtr) (DeviceIntPtr /*device */ ,
                                   StringCtrl * /*ctrl */ );

extern _X_EXPORT Bool InitStringFeedbackClassDeviceStruct(DeviceIntPtr
                                                          /*device */ ,
                                                          StringCtrlProcPtr
                                                          /*controlProc */ ,
                                                          int /*max_symbols */ ,
                                                          int
                                                          /*num_symbols_supported */
                                                          ,
                                                          KeySym * /*symbols */
                                                          );

typedef void (*BellCtrlProcPtr) (DeviceIntPtr /*device */ ,
                                 BellCtrl * /*ctrl */ );

extern _X_EXPORT Bool InitBellFeedbackClassDeviceStruct(DeviceIntPtr /*device */
                                                        ,
                                                        BellProcPtr
                                                        /*bellProc */ ,
                                                        BellCtrlProcPtr
                                                        /*controlProc */ );

typedef void (*LedCtrlProcPtr) (DeviceIntPtr /*device */ ,
                                LedCtrl * /*ctrl */ );

extern _X_EXPORT Bool InitLedFeedbackClassDeviceStruct(DeviceIntPtr /*device */
                                                       ,
                                                       LedCtrlProcPtr
                                                       /*controlProc */ );

typedef void (*IntegerCtrlProcPtr) (DeviceIntPtr /*device */ ,
                                    IntegerCtrl * /*ctrl */ );

extern _X_EXPORT Bool InitIntegerFeedbackClassDeviceStruct(DeviceIntPtr
                                                           /*device */ ,
                                                           IntegerCtrlProcPtr
                                                           /*controlProc */ );

extern _X_EXPORT Bool InitPointerDeviceStruct(DevicePtr /*device */ ,
                                              CARD8 * /*map */ ,
                                              int /*numButtons */ ,
                                              Atom * /* btn_labels */ ,
                                              PtrCtrlProcPtr /*controlProc */ ,
                                              int /*numMotionEvents */ ,
                                              int /*numAxes */ ,
                                              Atom * /* axes_labels */ );

extern _X_EXPORT Bool InitKeyboardDeviceStruct(DeviceIntPtr /*device */ ,
                                               XkbRMLVOSet * /*rmlvo */ ,
                                               BellProcPtr /*bellProc */ ,
                                               KbdCtrlProcPtr /*controlProc */
                                               );

extern _X_EXPORT Bool InitKeyboardDeviceStructFromString(DeviceIntPtr dev,
							 const char *keymap,
							 int keymap_length,
							 BellProcPtr bell_func,
							 KbdCtrlProcPtr ctrl_func);

extern int ApplyPointerMapping(DeviceIntPtr /* pDev */ ,
                               CARD8 * /* map */ ,
                               int /* len */ ,
                               ClientPtr /* client */ );

extern Bool BadDeviceMap(BYTE * /*buff */ ,
                         int /*length */ ,
                         unsigned /*low */ ,
                         unsigned /*high */ ,
                         XID * /*errval */ );

extern void NoteLedState(DeviceIntPtr /*keybd */ ,
                         int /*led */ ,
                         Bool /*on */ );

extern void MaybeStopHint(DeviceIntPtr /*device */ ,
                          ClientPtr /*client */ );

extern void ProcessPointerEvent(InternalEvent * /* ev */ ,
                                DeviceIntPtr /*mouse */ );

extern void ProcessKeyboardEvent(InternalEvent * /*ev */ ,
                                 DeviceIntPtr /*keybd */ );

extern Bool LegalModifier(unsigned int /*key */ ,
                          DeviceIntPtr /*pDev */ );

extern _X_EXPORT void ProcessInputEvents(void);

extern _X_EXPORT void InitInput(int /*argc */ ,
                                char ** /*argv */ );
extern _X_EXPORT void CloseInput(void);

extern _X_EXPORT int GetMaximumEventsNum(void);

extern _X_EXPORT InternalEvent *InitEventList(int num_events);
extern _X_EXPORT void FreeEventList(InternalEvent *list, int num_events);

extern void CreateClassesChangedEvent(InternalEvent *event,
                                      DeviceIntPtr master,
                                      DeviceIntPtr slave, int flags);

extern InternalEvent *UpdateFromMaster(InternalEvent *events,
                                       DeviceIntPtr pDev,
                                       int type, int *num_events);

extern _X_EXPORT int GetPointerEvents(InternalEvent *events,
                                      DeviceIntPtr pDev,
                                      int type,
                                      int buttons,
                                      int flags, const ValuatorMask *mask);

extern _X_EXPORT void QueuePointerEvents(DeviceIntPtr pDev,
                                         int type,
                                         int buttons,
                                         int flags, const ValuatorMask *mask);

extern _X_EXPORT int GetKeyboardEvents(InternalEvent *events,
                                       DeviceIntPtr pDev,
                                       int type,
                                       int key_code);

extern _X_EXPORT void QueueKeyboardEvents(DeviceIntPtr pDev,
                                          int type,
                                          int key_code);

extern int GetTouchEvents(InternalEvent *events,
                          DeviceIntPtr pDev,
                          uint32_t ddx_touchid,
                          uint16_t type,
                          uint32_t flags, const ValuatorMask *mask);

void QueueTouchEvents(DeviceIntPtr device,
                      int type,
                      uint32_t ddx_touchid,
                      int flags, const ValuatorMask *mask);

extern int GetTouchOwnershipEvents(InternalEvent *events,
                                   DeviceIntPtr pDev,
                                   TouchPointInfoPtr ti,
                                   uint8_t mode, XID resource, uint32_t flags);

extern void GetDixTouchEnd(InternalEvent *ievent,
                           DeviceIntPtr dev,
                           TouchPointInfoPtr ti,
                           uint32_t flags);

extern _X_EXPORT int GetProximityEvents(InternalEvent *events,
                                        DeviceIntPtr pDev,
                                        int type, const ValuatorMask *mask);

extern _X_EXPORT void QueueProximityEvents(DeviceIntPtr pDev,
                                           int type, const ValuatorMask *mask);

#ifdef PANORAMIX
_X_EXPORT
#endif
extern void PostSyntheticMotion(DeviceIntPtr pDev,
                                int x, int y, int screen, unsigned long time);

extern _X_EXPORT int GetMotionHistorySize(void);

extern _X_EXPORT void AllocateMotionHistory(DeviceIntPtr pDev);

extern _X_EXPORT int GetMotionHistory(DeviceIntPtr pDev,
                                      xTimecoord ** buff,
                                      unsigned long start,
                                      unsigned long stop,
                                      ScreenPtr pScreen, BOOL core);

extern void ReleaseButtonsAndKeys(DeviceIntPtr dev);

extern int AttachDevice(ClientPtr client,
                        DeviceIntPtr slave, DeviceIntPtr master);

extern _X_EXPORT DeviceIntPtr GetPairedDevice(DeviceIntPtr kbd);
extern _X_EXPORT DeviceIntPtr GetMaster(DeviceIntPtr dev, int type);

extern _X_EXPORT int AllocDevicePair(ClientPtr client,
                                     const char *name,
                                     DeviceIntPtr *ptr,
                                     DeviceIntPtr *keybd,
                                     DeviceProc ptr_proc,
                                     DeviceProc keybd_proc, Bool master);
extern void DeepCopyDeviceClasses(DeviceIntPtr from,
                                  DeviceIntPtr to, DeviceChangedEvent *dce);

/* Helper functions. */
extern _X_EXPORT int generate_modkeymap(ClientPtr client, DeviceIntPtr dev,
                                        KeyCode **modkeymap,
                                        int *max_keys_per_mod);
extern int change_modmap(ClientPtr client, DeviceIntPtr dev, KeyCode *map,
                         int max_keys_per_mod);
extern int AllocXTestDevice(ClientPtr client, const char *name,
                            DeviceIntPtr *ptr, DeviceIntPtr *keybd,
                            DeviceIntPtr master_ptr, DeviceIntPtr master_keybd);
extern BOOL IsXTestDevice(DeviceIntPtr dev, DeviceIntPtr master);
extern DeviceIntPtr GetXTestDevice(DeviceIntPtr master);
extern void SendDevicePresenceEvent(int deviceid, int type);
extern _X_EXPORT InputAttributes *DuplicateInputAttributes(InputAttributes *
                                                           attrs);
extern _X_EXPORT void FreeInputAttributes(InputAttributes * attrs);

enum TouchListenerState {
    LISTENER_AWAITING_BEGIN = 0,   /**< Waiting for a TouchBegin event */
    LISTENER_AWAITING_OWNER,       /**< Waiting for a TouchOwnership event */
    LISTENER_EARLY_ACCEPT,         /**< Waiting for ownership, has already
                                        accepted */
    LISTENER_IS_OWNER,             /**< Is the current owner, hasn't accepted */
    LISTENER_HAS_ACCEPTED,         /**< Is the current owner, has accepted */
    LISTENER_HAS_END,              /**< Has already received the end event */
};

enum TouchListenerType {
    LISTENER_GRAB,
    LISTENER_POINTER_GRAB,
    LISTENER_REGULAR,
    LISTENER_POINTER_REGULAR,
};

extern void TouchInitDDXTouchPoint(DeviceIntPtr dev,
                                   DDXTouchPointInfoPtr ddxtouch);
extern DDXTouchPointInfoPtr TouchBeginDDXTouch(DeviceIntPtr dev,
                                               uint32_t ddx_id);
extern void TouchEndDDXTouch(DeviceIntPtr dev, DDXTouchPointInfoPtr ti);
extern DDXTouchPointInfoPtr TouchFindByDDXID(DeviceIntPtr dev,
                                             uint32_t ddx_id, Bool create);
extern Bool TouchInitTouchPoint(TouchClassPtr touch, ValuatorClassPtr v,
                                int index);
extern void TouchFreeTouchPoint(DeviceIntPtr dev, int index);
extern TouchPointInfoPtr TouchBeginTouch(DeviceIntPtr dev, int sourceid,
                                         uint32_t touchid,
                                         Bool emulate_pointer);
extern TouchPointInfoPtr TouchFindByClientID(DeviceIntPtr dev,
                                             uint32_t client_id);
extern void TouchEndTouch(DeviceIntPtr dev, TouchPointInfoPtr ti);
extern Bool TouchEventHistoryAllocate(TouchPointInfoPtr ti);
extern void TouchEventHistoryFree(TouchPointInfoPtr ti);
extern void TouchEventHistoryPush(TouchPointInfoPtr ti, const DeviceEvent *ev);
extern void TouchEventHistoryReplay(TouchPointInfoPtr ti, DeviceIntPtr dev,
                                    XID resource);
extern Bool TouchResourceIsOwner(TouchPointInfoPtr ti, XID resource);
extern void TouchAddListener(TouchPointInfoPtr ti, XID resource, int resource_type,
                             enum InputLevel level, enum TouchListenerType type,
                             enum TouchListenerState state, WindowPtr window, GrabPtr grab);
extern Bool TouchRemoveListener(TouchPointInfoPtr ti, XID resource);
extern void TouchSetupListeners(DeviceIntPtr dev, TouchPointInfoPtr ti,
                                InternalEvent *ev);
extern Bool TouchBuildSprite(DeviceIntPtr sourcedev, TouchPointInfoPtr ti,
                             InternalEvent *ev);
extern Bool TouchBuildDependentSpriteTrace(DeviceIntPtr dev, SpritePtr sprite);
extern int TouchConvertToPointerEvent(const InternalEvent *ev,
                                      InternalEvent *motion,
                                      InternalEvent *button);
extern int TouchGetPointerEventType(const InternalEvent *ev);
extern void TouchRemovePointerGrab(DeviceIntPtr dev);
extern void TouchListenerGone(XID resource);
extern int TouchListenerAcceptReject(DeviceIntPtr dev, TouchPointInfoPtr ti,
                                     int listener, int mode);
extern int TouchAcceptReject(ClientPtr client, DeviceIntPtr dev, int mode,
                             uint32_t touchid, Window grab_window, XID *error);
extern void TouchEndPhysicallyActiveTouches(DeviceIntPtr dev);
extern void TouchDeliverDeviceClassesChangedEvent(TouchPointInfoPtr ti,
                                                  Time time, XID resource);
extern void TouchEmitTouchEnd(DeviceIntPtr dev, TouchPointInfoPtr ti, int flags, XID resource);
extern void TouchAcceptAndEnd(DeviceIntPtr dev, int touchid);

/* misc event helpers */
extern Mask GetEventMask(DeviceIntPtr dev, xEvent *ev, InputClientsPtr clients);
extern Mask GetEventFilter(DeviceIntPtr dev, xEvent *event);
extern Bool WindowXI2MaskIsset(DeviceIntPtr dev, WindowPtr win, xEvent *ev);
extern int GetXI2MaskByte(XI2Mask *mask, DeviceIntPtr dev, int event_type);
void FixUpEventFromWindow(SpritePtr pSprite,
                          xEvent *xE,
                          WindowPtr pWin, Window child, Bool calcChild);
extern Bool PointInBorderSize(WindowPtr pWin, int x, int y);
extern WindowPtr XYToWindow(SpritePtr pSprite, int x, int y);
extern int EventIsDeliverable(DeviceIntPtr dev, int evtype, WindowPtr win);
extern Bool ActivatePassiveGrab(DeviceIntPtr dev, GrabPtr grab,
                                InternalEvent *ev, InternalEvent *real_event);
/**
 * Masks specifying the type of event to deliver for an InternalEvent; used
 * by EventIsDeliverable.
 * @@defgroup EventIsDeliverable return flags
 * @@{
 */
#define EVENT_XI1_MASK                (1 << 0) /**< XI1.x event */
#define EVENT_CORE_MASK               (1 << 1) /**< Core event */
#define EVENT_DONT_PROPAGATE_MASK     (1 << 2) /**< DontPropagate mask set */
#define EVENT_XI2_MASK                (1 << 3) /**< XI2 mask set on window */
/* @@} */

enum EventDeliveryState {
    EVENT_DELIVERED,     /**< Event has been delivered to a client  */
    EVENT_NOT_DELIVERED, /**< Event was not delivered to any client */
    EVENT_SKIP,          /**< Event can be discarded by the caller  */
    EVENT_REJECTED,      /**< Event was rejected for delivery to the client */
};

/* Implemented by the DDX. */
extern _X_EXPORT int NewInputDeviceRequest(InputOption *options,
                                           InputAttributes * attrs,
                                           DeviceIntPtr *dev);
extern _X_EXPORT void DeleteInputDeviceRequest(DeviceIntPtr dev);

extern _X_EXPORT void DDXRingBell(int volume, int pitch, int duration);

#define VALUATOR_MODE_ALL_AXES -1
extern _X_HIDDEN int valuator_get_mode(DeviceIntPtr dev, int axis);
extern _X_HIDDEN void valuator_set_mode(DeviceIntPtr dev, int axis, int mode);

/* Set to TRUE by default - os/utils.c sets it to FALSE on user request,
   xfixes/cursor.c uses it to determine if the cursor is enabled */
extern Bool EnableCursor;

/* Set to FALSE by default - ChangeWindowAttributes sets it to TRUE on
 * CWCursor, xfixes/cursor.c uses it to determine if the cursor is enabled
 */
extern Bool CursorVisible;

extern _X_EXPORT ValuatorMask *valuator_mask_new(int num_valuators);
extern _X_EXPORT void valuator_mask_free(ValuatorMask **mask);
extern _X_EXPORT void valuator_mask_set_range(ValuatorMask *mask,
                                              int first_valuator,
                                              int num_valuators,
                                              const int *valuators);
extern _X_EXPORT void valuator_mask_set(ValuatorMask *mask, int valuator,
                                        int data);
extern _X_EXPORT void valuator_mask_set_double(ValuatorMask *mask, int valuator,
                                               double data);
extern _X_EXPORT void valuator_mask_zero(ValuatorMask *mask);
extern _X_EXPORT int valuator_mask_size(const ValuatorMask *mask);
extern _X_EXPORT int valuator_mask_isset(const ValuatorMask *mask, int bit);
extern _X_EXPORT void valuator_mask_unset(ValuatorMask *mask, int bit);
extern _X_EXPORT int valuator_mask_num_valuators(const ValuatorMask *mask);
extern _X_EXPORT void valuator_mask_copy(ValuatorMask *dest,
                                         const ValuatorMask *src);
extern _X_EXPORT int valuator_mask_get(const ValuatorMask *mask, int valnum);
extern _X_EXPORT double valuator_mask_get_double(const ValuatorMask *mask,
                                                 int valnum);
extern _X_EXPORT Bool valuator_mask_fetch(const ValuatorMask *mask,
                                          int valnum, int *val);
extern _X_EXPORT Bool valuator_mask_fetch_double(const ValuatorMask *mask,
                                                 int valnum, double *val);

extern _X_EXPORT Bool valuator_mask_has_unaccelerated(const ValuatorMask *mask);
extern _X_EXPORT void valuator_mask_set_unaccelerated(ValuatorMask *mask,
                                                      int valuator,
                                                      double accel,
                                                      double unaccel);
extern _X_EXPORT double valuator_mask_get_accelerated(const ValuatorMask *mask,
                                                      int valuator);
extern _X_EXPORT double valuator_mask_get_unaccelerated(const ValuatorMask *mask,
                                                        int valuator);
extern _X_EXPORT Bool valuator_mask_fetch_unaccelerated(const ValuatorMask *mask,
                                                        int valuator,
                                                        double *accel,
                                                        double *unaccel);
extern _X_HIDDEN void valuator_mask_drop_unaccelerated(ValuatorMask *mask);

/* InputOption handling interface */
extern _X_EXPORT InputOption *input_option_new(InputOption *list,
                                               const char *key,
                                               const char *value);
extern _X_EXPORT void input_option_free_list(InputOption **opt);
extern _X_EXPORT InputOption *input_option_free_element(InputOption *opt,
                                                        const char *key);
extern _X_EXPORT InputOption *input_option_find(InputOption *list,
                                                const char *key);
extern _X_EXPORT const char *input_option_get_key(const InputOption *opt);
extern _X_EXPORT const char *input_option_get_value(const InputOption *opt);
extern _X_EXPORT void input_option_set_key(InputOption *opt, const char *key);
extern _X_EXPORT void input_option_set_value(InputOption *opt,
                                             const char *value);

extern _X_HIDDEN Bool point_on_screen(ScreenPtr pScreen, int x, int y);
extern _X_HIDDEN void update_desktop_dimensions(void);

extern _X_HIDDEN void input_constrain_cursor(DeviceIntPtr pDev, ScreenPtr screen,
                                             int current_x, int current_y,
                                             int dest_x, int dest_y,
                                             int *out_x, int *out_y,
                                             int *nevents, InternalEvent* events);

#endif                          /* INPUT_H */
@


1.14
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d451 1
a451 1
                                       int key_code, const ValuatorMask *mask);
d455 1
a455 2
                                          int key_code,
                                          const ValuatorMask *mask);
d675 15
@


1.13
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d29 2
a30 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d32 1
a32 1
both that copyright notice and this permission notice appear in 
d35 1
a35 1
software without specific, written prior permission.  
a289 3
extern _X_EXPORT Bool SetKeySymsMap(KeySymsPtr /*dst */ ,
                                    KeySymsPtr /*src */ );

d314 4
a317 4
typedef void (*BellProcPtr) (int /*percent */ ,
                             DeviceIntPtr /*device */ ,
                             void */*ctrl */ ,
                             int);
d508 1
a508 1
extern DeviceIntPtr GetMaster(DeviceIntPtr dev, int type);
@


1.12
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d98 2
a99 2
#define MAP_LENGTH	256
#define DOWN_LENGTH	32      /* 256/8 => number of bytes to hold 256 bits */
d166 1
a166 1
    pointer devicePrivate;
d319 1
a319 1
                             pointer /*ctrl */ ,
d388 6
d610 1
@


1.11
log
@Update to xserver 1.14.4
@
text
@d247 6
a252 6
extern void set_key_down(DeviceIntPtr pDev, int key_code, int type);
extern void set_key_up(DeviceIntPtr pDev, int key_code, int type);
extern int key_is_down(DeviceIntPtr pDev, int key_code, int type);
extern void set_button_down(DeviceIntPtr pDev, int button, int type);
extern void set_button_up(DeviceIntPtr pDev, int button, int type);
extern int button_is_down(DeviceIntPtr pDev, int button, int type);
d642 5
@


1.10
log
@Update to xserver 1.14.3
@
text
@d116 3
a118 3
    CORE,
    XI,
    XI2,
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d593 2
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d65 1
d73 1
d269 1
a269 1

d273 1
d471 5
d483 3
d571 1
a571 1
extern void TouchAddListener(TouchPointInfoPtr ti, XID resource,
d573 1
a573 1
                             enum TouchListenerState state, WindowPtr window);
d590 3
d683 6
@


1.7
log
@Bugfix Update to xserver 1.11.3
@
text
@a24 1

d55 1
a55 1
#include "window.h"     /* for WindowPtr */
d58 2
d69 12
a80 2
#define POINTER_SCREEN		(1 << 4)	/* Data in screen coordinates */
#define POINTER_NORAW		(1 << 5)	/* Don't generate RawEvents */
d92 1
a92 1
#define MAX_BUTTONS 256 /* completely arbitrarily chosen */
d97 1
a97 1
#define DOWN_LENGTH	32	/* 256/8 => number of bytes to hold 256 bits */
d113 6
d126 3
d134 7
a140 1
extern InternalEvent* InputEventList;
d142 2
a143 11
typedef int (*DeviceProc)(
    DeviceIntPtr /*device*/,
    int /*what*/);

typedef void (*ProcessInputProc)(
    InternalEvent * /*event*/,
    DeviceIntPtr /*device*/);

typedef Bool (*DeviceHandleProc)(
    DeviceIntPtr /*device*/,
    void* /*data*/
d146 3
a148 4
typedef void (*DeviceUnwrapProc)(
    DeviceIntPtr /*device*/,
    DeviceHandleProc /*proc*/,
    void* /*data*/
d152 3
a154 4
typedef void (*PointerAccelSchemeProc)(
    DeviceIntPtr /*device*/,
    ValuatorMask* /*valuators*/,
    CARD32 /*evtime*/);
d156 1
a156 2
typedef void (*DeviceCallbackProc)(
              DeviceIntPtr /*pDev*/);
d159 3
a161 3
typedef Bool (*PointerAccelSchemeInitProc)(
              DeviceIntPtr /*dev*/,
              struct _ValuatorAccelerationRec* /*protoScheme*/);
d164 5
a168 5
    pointer	devicePrivate;
    ProcessInputProc processInputProc;	/* current */
    ProcessInputProc realInputProc;	/* deliver */
    ProcessInputProc enqueueInputProc;	/* enqueue */
    Bool	on;			/* used by DDX to keep state */
d172 5
a176 5
    int			click, bell, bell_pitch, bell_duration;
    Bool		autoRepeat;
    unsigned char	autoRepeats[32];
    Leds		leds;
    unsigned char	id;
d180 3
a182 4
    KeySym  *map;
    KeyCode minKeyCode,
	    maxKeyCode;
    int     mapWidth;
d186 1
a186 1
    int		num, den, threshold;
d191 2
a192 2
    int         resolution, min_value, max_value;
    int         integer_displayed;
d197 4
a200 4
    int         max_symbols, num_symbols_supported;
    int         num_symbols_displayed;
    KeySym      *symbols_supported;
    KeySym      *symbols_displayed;
d205 1
a205 1
    int         percent, pitch, duration;
d210 2
a211 2
    Leds        led_values;
    Mask        led_mask;
d215 2
a216 2
extern _X_EXPORT KeybdCtrl	defaultKeyboardControl;
extern _X_EXPORT PtrCtrl	defaultPointerControl;
d218 2
a219 5
typedef struct _InputOption {
    char                *key;
    char                *value;
    struct _InputOption *next;
} InputOption;
d222 7
a228 7
    char                *product;
    char                *vendor;
    char                *device;
    char                *pnp_id;
    char                *usb_id;
    char                **tags; /* null-terminated */
    uint32_t            flags;
d255 12
a266 16
extern _X_EXPORT DeviceIntPtr AddInputDevice(
    ClientPtr /*client*/,
    DeviceProc /*deviceProc*/,
    Bool /*autoStart*/);

extern _X_EXPORT Bool EnableDevice(
    DeviceIntPtr /*device*/,
    BOOL /* sendevent */);

extern _X_EXPORT Bool ActivateDevice(
    DeviceIntPtr /*device*/,
    BOOL /* sendevent */);

extern _X_EXPORT Bool DisableDevice(
    DeviceIntPtr /*device*/,
    BOOL /* sendevent */);
d274 2
a275 3
extern _X_EXPORT int RemoveDevice(
    DeviceIntPtr /*dev*/,
    BOOL /* sendevent */);
d279 132
a410 142
extern _X_EXPORT int dixLookupDevice(
    DeviceIntPtr *         /* dev */,
    int                    /* id */,
    ClientPtr              /* client */,
    Mask                   /* access_mode */);

extern _X_EXPORT void QueryMinMaxKeyCodes(
    KeyCode* /*minCode*/,
    KeyCode* /*maxCode*/);

extern _X_EXPORT Bool SetKeySymsMap(
    KeySymsPtr /*dst*/,
    KeySymsPtr /*src*/);

extern _X_EXPORT Bool InitButtonClassDeviceStruct(
    DeviceIntPtr /*device*/,
    int /*numButtons*/,
    Atom* /* labels */,
    CARD8* /*map*/);

extern _X_INTERNAL ValuatorClassPtr AllocValuatorClass(
    ValuatorClassPtr src,
    int numAxes);

extern _X_EXPORT Bool InitValuatorClassDeviceStruct(
    DeviceIntPtr /*device*/,
    int /*numAxes*/,
    Atom* /* labels */,
    int /*numMotionEvents*/,
    int /*mode*/);

extern _X_EXPORT Bool InitPointerAccelerationScheme(
    DeviceIntPtr /*dev*/,
    int /*scheme*/);

extern _X_EXPORT Bool InitFocusClassDeviceStruct(
    DeviceIntPtr /*device*/);

typedef void (*BellProcPtr)(
    int /*percent*/,
    DeviceIntPtr /*device*/,
    pointer /*ctrl*/,
    int);

typedef void (*KbdCtrlProcPtr)(
    DeviceIntPtr /*device*/,
    KeybdCtrl * /*ctrl*/);

typedef void (*PtrCtrlProcPtr)(
    DeviceIntPtr /*device*/,
    PtrCtrl * /*ctrl*/);

extern _X_EXPORT Bool InitPtrFeedbackClassDeviceStruct(
    DeviceIntPtr /*device*/,
    PtrCtrlProcPtr /*controlProc*/);

typedef void (*StringCtrlProcPtr)(
    DeviceIntPtr /*device*/,
    StringCtrl * /*ctrl*/);

extern _X_EXPORT Bool InitStringFeedbackClassDeviceStruct(
    DeviceIntPtr /*device*/,
    StringCtrlProcPtr /*controlProc*/,
    int /*max_symbols*/,
    int /*num_symbols_supported*/,
    KeySym* /*symbols*/);

typedef void (*BellCtrlProcPtr)(
    DeviceIntPtr /*device*/,
    BellCtrl * /*ctrl*/);

extern _X_EXPORT Bool InitBellFeedbackClassDeviceStruct(
    DeviceIntPtr /*device*/,
    BellProcPtr /*bellProc*/,
    BellCtrlProcPtr /*controlProc*/);

typedef void (*LedCtrlProcPtr)(
    DeviceIntPtr /*device*/,
    LedCtrl * /*ctrl*/);

extern _X_EXPORT Bool InitLedFeedbackClassDeviceStruct(
    DeviceIntPtr /*device*/,
    LedCtrlProcPtr /*controlProc*/);

typedef void (*IntegerCtrlProcPtr)(
    DeviceIntPtr /*device*/,
    IntegerCtrl * /*ctrl*/);


extern _X_EXPORT Bool InitIntegerFeedbackClassDeviceStruct(
    DeviceIntPtr /*device*/,
    IntegerCtrlProcPtr /*controlProc*/);

extern _X_EXPORT Bool InitPointerDeviceStruct(
    DevicePtr /*device*/,
    CARD8* /*map*/,
    int /*numButtons*/,
    Atom* /* btn_labels */,
    PtrCtrlProcPtr /*controlProc*/,
    int /*numMotionEvents*/,
    int /*numAxes*/,
    Atom* /* axes_labels */);

extern _X_EXPORT Bool InitKeyboardDeviceStruct(
    DeviceIntPtr /*device*/,
    XkbRMLVOSet * /*rmlvo*/,
    BellProcPtr /*bellProc*/,
    KbdCtrlProcPtr /*controlProc*/);

extern int ApplyPointerMapping(
    DeviceIntPtr /* pDev */,
    CARD8 *      /* map */,
    int          /* len */,
    ClientPtr	/* client */);

extern Bool BadDeviceMap(
    BYTE* /*buff*/,
    int /*length*/,
    unsigned /*low*/,
    unsigned /*high*/,
    XID* /*errval*/);

extern void NoteLedState(
    DeviceIntPtr /*keybd*/,
    int /*led*/,
    Bool /*on*/);

extern void MaybeStopHint(
    DeviceIntPtr /*device*/,
    ClientPtr /*client*/);

extern void ProcessPointerEvent(
    InternalEvent* /* ev */,
    DeviceIntPtr /*mouse*/);

extern void ProcessKeyboardEvent(
    InternalEvent* /*ev*/,
    DeviceIntPtr   /*keybd*/);

extern Bool LegalModifier(
    unsigned int /*key*/, 
    DeviceIntPtr /*pDev*/);
d414 2
a415 3
extern _X_EXPORT void InitInput(
    int  /*argc*/,
    char ** /*argv*/);
d425 62
a486 67
                                      DeviceIntPtr slave,
                                      int type);
extern InternalEvent * UpdateFromMaster(
    InternalEvent *events,
    DeviceIntPtr pDev,
    int type,
    int *num_events);

extern _X_EXPORT int GetPointerEvents(
    InternalEvent *events,
    DeviceIntPtr pDev,
    int type,
    int buttons,
    int flags,
    const ValuatorMask *mask);

extern _X_EXPORT void QueuePointerEvents(
    DeviceIntPtr pDev,
    int type,
    int buttons,
    int flags,
    const ValuatorMask *mask);

extern _X_EXPORT int GetKeyboardEvents(
    InternalEvent *events,
    DeviceIntPtr pDev,
    int type,
    int key_code,
    const ValuatorMask *mask);

extern _X_EXPORT void QueueKeyboardEvents(
    DeviceIntPtr pDev,
    int type,
    int key_code,
    const ValuatorMask *mask);

extern _X_EXPORT int GetProximityEvents(
    InternalEvent *events,
    DeviceIntPtr pDev,
    int type,
    const ValuatorMask *mask);

extern _X_EXPORT void QueueProximityEvents(
    DeviceIntPtr pDev,
    int type,
    const ValuatorMask *mask);

extern void PostSyntheticMotion(
    DeviceIntPtr pDev,
    int x,
    int y,
    int screen,
    unsigned long time);

extern _X_EXPORT int GetMotionHistorySize(
    void);

extern _X_EXPORT void AllocateMotionHistory(
    DeviceIntPtr pDev);

extern _X_EXPORT int GetMotionHistory(
    DeviceIntPtr pDev,
    xTimecoord **buff,
    unsigned long start,
    unsigned long stop,
    ScreenPtr pScreen,
    BOOL core);
d491 1
a491 2
                        DeviceIntPtr slave,
                        DeviceIntPtr master);
d497 5
a501 6
                             char* name,
                             DeviceIntPtr* ptr,
                             DeviceIntPtr* keybd,
                             DeviceProc ptr_proc,
                             DeviceProc keybd_proc,
                             Bool master);
d503 1
a503 2
                                  DeviceIntPtr to,
                                  DeviceChangedEvent *dce);
d507 2
a508 1
                              KeyCode **modkeymap, int *max_keys_per_mod);
d511 3
a513 6
extern int AllocXTestDevice(ClientPtr client,
                             char* name,
                             DeviceIntPtr* ptr,
                             DeviceIntPtr* keybd,
                             DeviceIntPtr master_ptr,
                             DeviceIntPtr master_keybd);
d517 62
a578 2
extern _X_EXPORT InputAttributes *DuplicateInputAttributes(InputAttributes *attrs);
extern _X_EXPORT void FreeInputAttributes(InputAttributes *attrs);
d581 1
a581 1
extern Mask GetEventMask(DeviceIntPtr dev, xEvent* ev, InputClientsPtr clients);
d583 2
a584 1
extern Mask GetWindowXI2Mask(DeviceIntPtr dev, WindowPtr win, xEvent* ev);
d587 1
a587 3
                          WindowPtr pWin,
                          Window child,
                          Bool calcChild);
d589 3
a591 2
extern int EventIsDeliverable(DeviceIntPtr dev, InternalEvent* event,
                              WindowPtr win);
d604 7
d612 6
a617 11
extern _X_EXPORT int NewInputDeviceRequest(
    InputOption *options,
    InputAttributes *attrs,
    DeviceIntPtr *dev);
extern  _X_EXPORT void DeleteInputDeviceRequest(
    DeviceIntPtr dev);

extern _X_EXPORT void DDXRingBell(
    int volume,
    int pitch,
    int duration);
d627 1
a627 1
extern _X_EXPORT ValuatorMask  *valuator_mask_new(int num_valuators);
d630 4
a633 4
                                       int first_valuator, int num_valuators,
                                       const int* valuators);
extern _X_EXPORT void valuator_mask_set(ValuatorMask *mask,
                                        int valuator,
d635 2
d645 24
d670 1
a670 1
#endif /* INPUT_H */
@


1.6
log
@Update to xserver 1.11.2
@
text
@d467 1
a467 1
extern int GetProximityEvents(
d473 1
a473 1
extern void QueueProximityEvents(
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d65 5
a69 4
#define POINTER_RELATIVE (1 << 1)
#define POINTER_ABSOLUTE (1 << 2)
#define POINTER_ACCELERATE (1 << 3)
#define POINTER_SCREEN (1 << 4) /* Data in screen coordinates */
d106 1
d108 1
d111 1
a111 9
typedef struct _EventList {
    xEvent* event;
    int evlen; /* length of allocated memory for event in bytes.  This is not
                  the actual length of the event. The event's actual length is
                  32 for standard events or 32 +
                  ((xGenericEvent*)event)->length * 4 for GenericEvents.
                  For events in the EQ, the length is
                  ((InternalEvent*)event)->u.any.length */
} EventList, *EventListPtr;
d114 1
a114 2
extern EventListPtr InputEventList;
extern int InputEventListLen;
d137 3
a139 5
    DeviceIntPtr /*pDev*/,
    int /*first_valuator*/,
    int /*num_valuators*/,
    int* /*valuators*/,
    int /*evtime*/);
d144 5
a273 6
extern void RegisterPointerDevice(
    DeviceIntPtr /*device*/);

extern void RegisterKeyboardDevice(
    DeviceIntPtr /*device*/);

d294 4
a308 3
extern _X_EXPORT Bool InitAbsoluteClassDeviceStruct(
    DeviceIntPtr /*device*/);

d426 2
a427 3
extern _X_EXPORT int GetEventList(EventListPtr* list);
extern _X_EXPORT EventListPtr InitEventList(int num_events);
extern _X_EXPORT void FreeEventList(EventListPtr list, int num_events);
d429 1
a429 1
extern void CreateClassesChangedEvent(EventListPtr event,
d433 2
a434 2
extern EventListPtr UpdateFromMaster(
    EventListPtr events,
d440 1
a440 1
    EventListPtr events,
d445 8
a452 3
    int first_valuator,
    int num_valuators,
    int *valuators);
d455 1
a455 1
    EventListPtr events,
d458 2
a459 1
    int key_code);
d461 1
a461 2
extern int GetKeyboardValuatorEvents(
    EventListPtr events,
d465 1
a465 3
    int first_valuator,
    int num_valuator,
    int *valuators);
d468 6
a473 1
    EventListPtr events,
d476 1
a476 3
    int first_valuator,
    int num_valuators,
    int *valuators);
d499 2
d537 1
d540 1
a540 1
void FixUpEventFromWindow(DeviceIntPtr pDev,
d545 14
d573 4
d580 17
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d218 2
d231 1
a231 1
/* Key has been run through all input processing and events sent to clients. */
d233 2
a234 1
/* Key has not been fully processed, no events have been sent. */
d236 1
d241 3
d442 6
d534 2
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d55 1
d57 2
d80 1
a100 16
/* Used for enter/leave and focus in/out semaphores */
#define SEMAPHORE_FIELD_SET(win, dev, field) \
    (win)->field[(dev)->id/8] |= (1 << ((dev)->id % 8)); \

#define SEMAPHORE_FIELD_UNSET(win, dev, field) \
    (win)->field[(dev)->id/8] &= ~(1 << ((dev)->id % 8));

#define FOCUS_SEMAPHORE_SET(win, dev) \
        SEMAPHORE_FIELD_SET(win, dev, focusinout);

#define FOCUS_SEMAPHORE_UNSET(win, dev) \
        SEMAPHORE_FIELD_UNSET(win, dev, focusinout);

#define FOCUS_SEMAPHORE_ISSET(win, dev) \
        (win)->focusinout[(dev)->id/8] & (1 << ((dev)->id % 8))

d106 1
d113 3
a115 1
                  ((xGenericEvent*)event)->length * 4 for GenericEvents */
d127 2
a128 3
    xEventPtr /*events*/,
    DeviceIntPtr /*device*/,
    int /*count*/);
d205 2
a206 2
extern KeybdCtrl	defaultKeyboardControl;
extern PtrCtrl		defaultPointerControl;
d214 24
d239 1
d241 1
a241 1
extern DeviceIntPtr AddInputDevice(
d246 3
a248 2
extern Bool EnableDevice(
    DeviceIntPtr /*device*/);
d250 3
a252 2
extern Bool ActivateDevice(
    DeviceIntPtr /*device*/);
d254 3
a256 2
extern Bool DisableDevice(
    DeviceIntPtr /*device*/);
d264 3
a266 2
extern int RemoveDevice(
    DeviceIntPtr /*dev*/);
d268 1
a268 1
extern int NumMotionEvents(void);
d276 1
a276 1
extern int dixLookupDevice(
d282 1
a282 1
extern void QueryMinMaxKeyCodes(
d286 1
a286 1
extern Bool SetKeySymsMap(
d290 1
a290 6
extern Bool InitKeyClassDeviceStruct(
    DeviceIntPtr /*device*/,
    KeySymsPtr /*pKeySyms*/,
    CARD8 /*pModifiers*/[]);

extern Bool InitButtonClassDeviceStruct(
d293 1
d296 1
a296 1
extern Bool InitValuatorClassDeviceStruct(
d299 1
d303 1
a303 1
extern Bool InitPointerAccelerationScheme(
d307 1
a307 1
extern Bool InitAbsoluteClassDeviceStruct(
d310 1
a310 1
extern Bool InitFocusClassDeviceStruct(
a322 5
extern Bool InitKbdFeedbackClassDeviceStruct(
    DeviceIntPtr /*device*/,
    BellProcPtr /*bellProc*/,
    KbdCtrlProcPtr /*controlProc*/);

d327 1
a327 1
extern Bool InitPtrFeedbackClassDeviceStruct(
d335 1
a335 1
extern Bool InitStringFeedbackClassDeviceStruct(
d346 1
a346 1
extern Bool InitBellFeedbackClassDeviceStruct(
d355 1
a355 1
extern Bool InitLedFeedbackClassDeviceStruct(
d364 1
a364 1
extern Bool InitIntegerFeedbackClassDeviceStruct(
d368 1
a368 1
extern Bool InitPointerDeviceStruct(
d372 1
d375 2
a376 1
    int /*numAxes*/);
d378 3
a380 4
extern Bool InitKeyboardDeviceStruct(
    DevicePtr /*device*/,
    KeySymsPtr /*pKeySyms*/,
    CARD8 /*pModifiers*/[],
d384 1
a384 1
extern void SendMappingNotify(
d386 2
a387 3
    unsigned int /*request*/,
    unsigned int /*firstKeyCode*/,
    unsigned int /*count*/,
a396 7
extern Bool AllModifierKeysAreUp(
    DeviceIntPtr /*device*/,
    CARD8* /*map1*/,
    int /*per1*/,
    CARD8* /*map2*/,
    int /*per2*/);

d407 2
a408 3
    xEventPtr /*xE*/,
    DeviceIntPtr /*mouse*/,
    int /*count*/);
d411 2
a412 15
    xEventPtr /*xE*/,
    DeviceIntPtr /*keybd*/,
    int /*count*/);

#ifdef XKB
extern void CoreProcessPointerEvent(
    xEventPtr /*xE*/,
    DeviceIntPtr /*mouse*/,
    int /*count*/) _X_DEPRECATED;

extern _X_DEPRECATED void CoreProcessKeyboardEvent(
    xEventPtr /*xE*/,
    DeviceIntPtr /*keybd*/,
    int /*count*/) _X_DEPRECATED;
#endif
d418 1
a418 1
extern void ProcessInputEvents(void);
d420 1
a420 1
extern void InitInput(
d423 1
d425 1
a425 1
extern int GetMaximumEventsNum(void);
d427 3
a429 6
extern int GetEventList(EventListPtr* list);
extern EventListPtr InitEventList(int num_events);
extern void SetMinimumEventSize(EventListPtr list,
                                int num_events,
                                int min_size);
extern void FreeEventList(EventListPtr list, int num_events);
d431 1
a431 1
extern void CreateClassesChangedEvent(EventListPtr event, 
d433 3
a435 2
                                      DeviceIntPtr slave);
extern int GetPointerEvents(
d445 1
a445 1
extern int GetKeyboardEvents(
d475 1
a475 1
extern int GetMotionHistorySize(
d478 1
a478 1
extern void AllocateMotionHistory(
d481 1
a481 1
extern int GetMotionHistory(
d493 2
a494 1
extern DeviceIntPtr GetPairedDevice(DeviceIntPtr kbd);
d496 1
a496 1
extern int AllocMasterDevice(ClientPtr client,
d499 4
a502 1
                             DeviceIntPtr* keybd);
d504 26
a529 1
                                  DeviceIntPtr to);
d532 1
a532 1
extern int NewInputDeviceRequest(
d534 1
d536 1
a536 1
extern void DeleteInputDeviceRequest(
d539 1
a539 1
extern void DDXRingBell(
d543 4
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d65 14
d97 16
d117 13
d151 11
d227 1
d244 2
a280 7
typedef int (*ValuatorMotionProcPtr)(
		DeviceIntPtr /*pdevice*/,
		xTimecoord * /*coords*/,
		unsigned long /*start*/,
		unsigned long /*stop*/,
		ScreenPtr /*pScreen*/);

a283 1
    ValuatorMotionProcPtr /* motionProc */,
d287 4
a360 1
    ValuatorMotionProcPtr /*motionProc*/,
d373 1
d416 1
a416 1
    int /*count*/);
d418 1
a418 1
extern void CoreProcessKeyboardEvent(
d421 1
a421 1
    int /*count*/);
d436 10
d447 1
a447 1
    xEvent *events,
d457 1
a457 1
    xEvent *events,
d463 1
a463 1
    xEvent *events,
d472 1
a472 1
    xEvent *events,
d480 1
d494 1
a494 1
    xTimecoord *buff,
d497 2
a498 1
    ScreenPtr pScreen);
d500 12
a511 2
extern void SwitchCoreKeyboard(DeviceIntPtr pDev);
extern void SwitchCorePointer(DeviceIntPtr pDev);
@


1.1
log
@Initial revision
@
text
@d62 4
a160 4
extern int AllocateDevicePrivateIndex(void);
extern Bool AllocateDevicePrivate(DeviceIntPtr device, int index);
extern void ResetDevicePrivateIndex(void);

d164 8
d179 3
d189 1
a189 1
extern void RemoveDevice(
d200 5
a204 6
extern DevicePtr LookupKeyboardDevice(void);

extern DevicePtr LookupPointerDevice(void);

extern DevicePtr LookupDevice(
    int /* id */);
d238 3
d310 2
a311 1
    int /*numMotionEvents*/);
d373 1
a373 1
    DevicePtr /*pDev*/);
d380 69
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a61 4
#define POINTER_RELATIVE (1 << 1)
#define POINTER_ABSOLUTE (1 << 2)
#define POINTER_ACCELERATE (1 << 3)

a163 8
typedef struct _InputOption {
    char                *key;
    char                *value;
    struct _InputOption *next;
} InputOption;

extern void InitCoreDevices(void);

a170 3
extern Bool ActivateDevice(
    DeviceIntPtr /*device*/);

d178 1
a178 1
extern int RemoveDevice(
a227 3
extern Bool InitAbsoluteClassDeviceStruct(
    DeviceIntPtr /*device*/);

d297 1
a297 2
    int /*numMotionEvents*/,
    int /*numAxes*/);
d359 1
a359 1
    DeviceIntPtr /*pDev*/);
a365 72

extern int GetMaximumEventsNum(void);

extern int GetPointerEvents(
    xEvent *events,
    DeviceIntPtr pDev,
    int type,
    int buttons,
    int flags,
    int first_valuator,
    int num_valuators,
    int *valuators);

extern int GetKeyboardEvents(
    xEvent *events,
    DeviceIntPtr pDev,
    int type,
    int key_code);

extern int GetKeyboardValuatorEvents(
    xEvent *events,
    DeviceIntPtr pDev,
    int type,
    int key_code,
    int first_valuator,
    int num_valuator,
    int *valuators);

extern int GetProximityEvents(
    xEvent *events,
    DeviceIntPtr pDev,
    int type,
    int first_valuator,
    int num_valuators,
    int *valuators);

extern void PostSyntheticMotion(
    int x,
    int y,
    int screen,
    unsigned long time);

extern int GetMotionHistorySize(
    void);

extern void AllocateMotionHistory(
    DeviceIntPtr pDev);

extern int GetMotionHistory(
    DeviceIntPtr pDev,
    xTimecoord *buff,
    unsigned long start,
    unsigned long stop,
    ScreenPtr pScreen);

extern void SwitchCoreKeyboard(DeviceIntPtr pDev);
extern void SwitchCorePointer(DeviceIntPtr pDev);

extern DeviceIntPtr LookupDeviceIntRec(
    CARD8 deviceid);

/* Implemented by the DDX. */
extern int NewInputDeviceRequest(
    InputOption *options,
    DeviceIntPtr *dev);
extern void DeleteInputDeviceRequest(
    DeviceIntPtr dev);

extern void DDXRingBell(
    int volume,
    int pitch,
    int duration);
@

