head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.14
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.12
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.10
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.8
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.09.06.19.44.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@/*
 *
 * Copyright © 2006-2011 Simon Thum             simon dot thum at gmx dot de
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef POINTERVELOCITY_H
#define POINTERVELOCITY_H

#include <input.h>

/* constants for acceleration profiles */

#define AccelProfileNone -1
#define AccelProfileClassic  0
#define AccelProfileDeviceSpecific 1
#define AccelProfilePolynomial 2
#define AccelProfileSmoothLinear 3
#define AccelProfileSimple 4
#define AccelProfilePower 5
#define AccelProfileLinear 6
#define AccelProfileSmoothLimited 7
#define AccelProfileLAST AccelProfileSmoothLimited

/* fwd */
struct _DeviceVelocityRec;

/**
 * profile
 * returns actual acceleration depending on velocity, acceleration control,...
 */
typedef double (*PointerAccelerationProfileFunc)
 (DeviceIntPtr dev, struct _DeviceVelocityRec * vel,
  double velocity, double threshold, double accelCoeff);

/**
 * a motion history, with just enough information to
 * calc mean velocity and decide which motion was along
 * a more or less straight line
 */
typedef struct _MotionTracker {
    double dx, dy;              /* accumulated delta for each axis */
    int time;                   /* time of creation */
    int dir;                    /* initial direction bitfield */
} MotionTracker, *MotionTrackerPtr;

/**
 * Contains all data needed to implement mouse ballistics
 */
typedef struct _DeviceVelocityRec {
    MotionTrackerPtr tracker;
    int num_tracker;
    int cur_tracker;            /* current index */
    double velocity;            /* velocity as guessed by algorithm */
    double last_velocity;       /* previous velocity estimate */
    double last_dx;             /* last time-difference */
    double last_dy;             /* phase of last/current estimate */
    double corr_mul;            /* config: multiply this into velocity */
    double const_acceleration;  /* config: (recipr.) const deceleration */
    double min_acceleration;    /* config: minimum acceleration */
    short reset_time;           /* config: reset non-visible state after # ms */
    short use_softening;        /* config: use softening of mouse values */
    double max_rel_diff;        /* config: max. relative difference */
    double max_diff;            /* config: max. difference */
    int initial_range;          /* config: max. offset used as initial velocity */
    Bool average_accel;         /* config: average acceleration over velocity */
    PointerAccelerationProfileFunc Profile;
    PointerAccelerationProfileFunc deviceSpecificProfile;
    void *profile_private;      /* extended data, see  SetAccelerationProfile() */
    struct {                    /* to be able to query this information */
        int profile_number;
    } statistics;
} DeviceVelocityRec, *DeviceVelocityPtr;

/**
 * contains the run-time data for the predictable scheme, that is, a
 * DeviceVelocityPtr and the property handlers.
 */
typedef struct _PredictableAccelSchemeRec {
    DeviceVelocityPtr vel;
    long *prop_handlers;
    int num_prop_handlers;
} PredictableAccelSchemeRec, *PredictableAccelSchemePtr;

extern _X_EXPORT void
InitVelocityData(DeviceVelocityPtr vel);

extern _X_EXPORT void
InitTrackers(DeviceVelocityPtr vel, int ntracker);

extern _X_EXPORT BOOL
ProcessVelocityData2D(DeviceVelocityPtr vel, double dx, double dy, int time);

extern _X_EXPORT double
BasicComputeAcceleration(DeviceIntPtr dev, DeviceVelocityPtr vel,
                         double velocity, double threshold, double acc);

extern _X_EXPORT void
FreeVelocityData(DeviceVelocityPtr vel);

extern _X_EXPORT int
SetAccelerationProfile(DeviceVelocityPtr vel, int profile_num);

extern _X_EXPORT DeviceVelocityPtr
GetDevicePredictableAccelData(DeviceIntPtr dev);

extern _X_EXPORT void
SetDeviceSpecificAccelerationProfile(DeviceVelocityPtr vel,
                                     PointerAccelerationProfileFunc profile);

extern _X_INTERNAL void
AccelerationDefaultCleanup(DeviceIntPtr dev);

extern _X_INTERNAL Bool
InitPredictableAccelerationScheme(DeviceIntPtr dev,
                                  struct _ValuatorAccelerationRec *protoScheme);

extern _X_INTERNAL void
acceleratePointerPredictable(DeviceIntPtr dev, ValuatorMask *val,
                             CARD32 evtime);

extern _X_INTERNAL void
acceleratePointerLightweight(DeviceIntPtr dev, ValuatorMask *val,
                             CARD32 evtime);

#endif                          /* POINTERVELOCITY_H */
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d104 1
a104 1
 InitVelocityData(DeviceVelocityPtr vel);
d107 1
a107 1
 InitTrackers(DeviceVelocityPtr vel, int ntracker);
a112 1

d117 1
a117 1
 FreeVelocityData(DeviceVelocityPtr vel);
d120 1
a120 1
 SetAccelerationProfile(DeviceVelocityPtr vel, int profile_num);
a125 1

d130 1
a130 1
 AccelerationDefaultCleanup(DeviceIntPtr dev);
a132 1

a136 1

a140 1

@


1.4
log
@Update to xserver 1.11.2
@
text
@d50 3
a52 3
typedef float (*PointerAccelerationProfileFunc)
              (DeviceIntPtr dev, struct _DeviceVelocityRec* vel,
               float velocity, float threshold, float accelCoeff);
d60 3
a62 3
    int dx, dy;     /* accumulated delta for each axis */
    int time;         /* time of creation */
    int dir;        /* initial direction bitfield */
d71 14
a84 14
    int cur_tracker;        /* current index */
    float   velocity;       /* velocity as guessed by algorithm */
    float   last_velocity;  /* previous velocity estimate */
    int     last_dx;      /* last time-difference */
    int     last_dy ;     /* phase of last/current estimate */
    float   corr_mul;       /* config: multiply this into velocity */
    float   const_acceleration;  /* config: (recipr.) const deceleration */
    float   min_acceleration;    /* config: minimum acceleration */
    short   reset_time;     /* config: reset non-visible state after # ms */
    short   use_softening;  /* config: use softening of mouse values */
    float   max_rel_diff;   /* config: max. relative difference */
    float   max_diff;       /* config: max. difference */
    int     initial_range;  /* config: max. offset used as initial velocity */
    Bool    average_accel;  /* config: average acceleration over velocity */
d87 3
a89 3
    void*   profile_private;/* extended data, see  SetAccelerationProfile() */
    struct {   /* to be able to query this information */
        int     profile_number;
d99 1
a99 1
    long* prop_handlers;
d104 1
a104 1
InitVelocityData(DeviceVelocityPtr vel);
d107 1
a107 1
InitTrackers(DeviceVelocityPtr vel, int ntracker);
d110 3
a112 1
ProcessVelocityData2D(DeviceVelocityPtr vel, int dx, int dy, int time);
a113 1
extern _X_EXPORT float
d115 1
a115 1
    float velocity, float threshold, float acc);
d118 1
a118 1
FreeVelocityData(DeviceVelocityPtr vel);
d121 1
a121 1
SetAccelerationProfile(DeviceVelocityPtr vel, int profile_num);
d127 1
d132 1
a132 1
AccelerationDefaultCleanup(DeviceIntPtr dev);
d135 1
d137 1
a137 1
				  struct _ValuatorAccelerationRec* protoScheme);
d140 2
a141 1
acceleratePointerPredictable(DeviceIntPtr dev, ValuatorMask* val,
d145 2
a146 1
acceleratePointerLightweight(DeviceIntPtr dev, ValuatorMask* val,
d149 1
a149 1
#endif  /* POINTERVELOCITY_H */
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d3 1
a3 1
 * Copyright © 2006-2009 Simon Thum             simon dot thum at gmx dot de
d28 1
a28 1
#include <input.h> /* DeviceIntPtr */
a64 3
/* number of properties for predictable acceleration */
#define NPROPS_PREDICTABLE_ACCEL 4

a90 1
    long    prop_handlers[NPROPS_PREDICTABLE_ACCEL];
d93 10
d109 1
a109 1
extern _X_EXPORT short
a118 6
extern _X_INTERNAL BOOL
InitializePredictableAccelerationProperties(DeviceIntPtr dev);

extern _X_INTERNAL BOOL
DeletePredictableAccelerationProperties(DeviceIntPtr dev);

d132 4
d137 2
a138 2
acceleratePointerPredictable(DeviceIntPtr dev, int first_valuator,
                             int num_valuators, int *valuators, int evtime);
d141 2
a142 2
acceleratePointerLightweight(DeviceIntPtr dev, int first_valuator,
                             int num_valuators, int *valuators, int ignored);
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d65 3
d94 1
a95 1

@


1.1
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d3 1
a3 1
 * Copyright © 2006-2008 Simon Thum             simon dot thum at gmx dot de
d30 1
a30 7
/* maximum number of filters to approximate velocity.
 * ABI-breaker!
 */
#define MAX_VELOCITY_FILTERS 8

/* constants for acceleration profiles;
 * see  */
d32 1
d40 2
a41 1
#define AccelProfileReserved 7
d51 2
a52 2
              (struct _DeviceVelocityRec* /*pVel*/,
               float /*velocity*/, float /*threshold*/, float /*acc*/);
d55 3
a57 8
 * a filter stage contains the data for adaptive IIR filtering.
 * To improve results, one may run several parallel filters
 * which have different decays. Since more integration means more
 * delay, a given filter only does good matches in a specific phase of
 * a stroke.
 *
 * Basically, the coupling feature makes one filter fairly enough,
 * so that is the default.
d59 5
a63 6
typedef struct _FilterStage {
    float*  fading_lut;     /* lookup for adaptive IIR filter */
    int     fading_lut_size; /* size of lookup table */
    float   rdecay;     /* reciprocal weighting halflife in ms */
    float   current;
} FilterStage, *FilterStagePtr;
d69 3
a71 1
    FilterStage filters[MAX_VELOCITY_FILTERS];
d74 2
a75 4
    int     lrm_time;       /* time the last motion event was processed  */
    int     last_dx, last_dy; /* last motion delta */
    int     last_diff;      /* last time-difference */
    Bool    last_reset;     /* whether a nv-reset occurred just before */
d81 3
a83 1
    float   coupling;       /* config: max. divergence before coupling */
a89 1
        int     filter_usecount[MAX_VELOCITY_FILTERS +1];
d94 18
a111 2
extern void
InitVelocityData(DeviceVelocityPtr s);
d113 2
a114 3
extern void
InitFilterChain(DeviceVelocityPtr s, float rdecay, float degression,
                int lutsize, int stages);
d116 2
a117 2
extern int
SetAccelerationProfile(DeviceVelocityPtr s, int profile_num);
d119 2
a120 2
extern DeviceVelocityPtr
GetDevicePredictableAccelData(DeviceIntPtr pDev);
d122 2
a123 2
extern void
SetDeviceSpecificAccelerationProfile(DeviceVelocityPtr s,
d126 2
a127 2
extern void
AccelerationDefaultCleanup(DeviceIntPtr pDev);
d129 2
a130 2
extern void
acceleratePointerPredictable(DeviceIntPtr pDev, int first_valuator,
d133 3
a135 3
extern void
acceleratePointerLightweight(DeviceIntPtr pDev, int first_valuator,
                         int num_valuators, int *valuators, int ignore);
@

