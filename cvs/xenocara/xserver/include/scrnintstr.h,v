head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.18;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.18;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.11;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#ifndef SCREENINTSTRUCT_H
#define SCREENINTSTRUCT_H

#include "screenint.h"
#include "regionstr.h"
#include "colormap.h"
#include "cursor.h"
#include "validate.h"
#include <X11/Xproto.h>
#include "dix.h"
#include "privates.h"
#include <X11/extensions/randr.h>

typedef struct _PixmapFormat {
    unsigned char depth;
    unsigned char bitsPerPixel;
    unsigned char scanlinePad;
} PixmapFormatRec;

typedef struct _Visual {
    VisualID vid;
    short class;
    short bitsPerRGBValue;
    short ColormapEntries;
    short nplanes;              /* = log2 (ColormapEntries). This does not
                                 * imply that the screen has this many planes.
                                 * it may have more or fewer */
    unsigned long redMask, greenMask, blueMask;
    int offsetRed, offsetGreen, offsetBlue;
} VisualRec;

typedef struct _Depth {
    unsigned char depth;
    short numVids;
    VisualID *vids;             /* block of visual ids for this depth */
} DepthRec;

typedef struct _ScreenSaverStuff {
    WindowPtr pWindow;
    XID wid;
    char blanked;
    Bool (*ExternalScreenSaver) (ScreenPtr /*pScreen */ ,
                                 int /*xstate */ ,
                                 Bool /*force */ );
} ScreenSaverStuffRec;

/*
 *  There is a typedef for each screen function pointer so that code that
 *  needs to declare a screen function pointer (e.g. in a screen private
 *  or as a local variable) can easily do so and retain full type checking.
 */

typedef Bool (*CloseScreenProcPtr) (ScreenPtr /*pScreen */ );

typedef void (*QueryBestSizeProcPtr) (int /*class */ ,
                                      unsigned short * /*pwidth */ ,
                                      unsigned short * /*pheight */ ,
                                      ScreenPtr /*pScreen */ );

typedef Bool (*SaveScreenProcPtr) (ScreenPtr /*pScreen */ ,
                                   int /*on */ );

typedef void (*GetImageProcPtr) (DrawablePtr /*pDrawable */ ,
                                 int /*sx */ ,
                                 int /*sy */ ,
                                 int /*w */ ,
                                 int /*h */ ,
                                 unsigned int /*format */ ,
                                 unsigned long /*planeMask */ ,
                                 char * /*pdstLine */ );

typedef void (*GetSpansProcPtr) (DrawablePtr /*pDrawable */ ,
                                 int /*wMax */ ,
                                 DDXPointPtr /*ppt */ ,
                                 int * /*pwidth */ ,
                                 int /*nspans */ ,
                                 char * /*pdstStart */ );

typedef void (*SourceValidateProcPtr) (DrawablePtr /*pDrawable */ ,
                                       int /*x */ ,
                                       int /*y */ ,
                                       int /*width */ ,
                                       int /*height */ ,
                                       unsigned int /*subWindowMode */ );

typedef Bool (*CreateWindowProcPtr) (WindowPtr /*pWindow */ );

typedef Bool (*DestroyWindowProcPtr) (WindowPtr /*pWindow */ );

typedef Bool (*PositionWindowProcPtr) (WindowPtr /*pWindow */ ,
                                       int /*x */ ,
                                       int /*y */ );

typedef Bool (*ChangeWindowAttributesProcPtr) (WindowPtr /*pWindow */ ,
                                               unsigned long /*mask */ );

typedef Bool (*RealizeWindowProcPtr) (WindowPtr /*pWindow */ );

typedef Bool (*UnrealizeWindowProcPtr) (WindowPtr /*pWindow */ );

typedef void (*RestackWindowProcPtr) (WindowPtr /*pWindow */ ,
                                      WindowPtr /*pOldNextSib */ );

typedef int (*ValidateTreeProcPtr) (WindowPtr /*pParent */ ,
                                    WindowPtr /*pChild */ ,
                                    VTKind /*kind */ );

typedef void (*PostValidateTreeProcPtr) (WindowPtr /*pParent */ ,
                                         WindowPtr /*pChild */ ,
                                         VTKind /*kind */ );

typedef void (*WindowExposuresProcPtr) (WindowPtr /*pWindow */ ,
                                        RegionPtr /*prgn */);

typedef void (*PaintWindowProcPtr) (WindowPtr /*pWindow*/,
                                    RegionPtr /*pRegion*/,
                                    int /*what*/);

typedef void (*CopyWindowProcPtr) (WindowPtr /*pWindow */ ,
                                   DDXPointRec /*ptOldOrg */ ,
                                   RegionPtr /*prgnSrc */ );

typedef void (*ClearToBackgroundProcPtr) (WindowPtr /*pWindow */ ,
                                          int /*x */ ,
                                          int /*y */ ,
                                          int /*w */ ,
                                          int /*h */ ,
                                          Bool /*generateExposures */ );

typedef void (*ClipNotifyProcPtr) (WindowPtr /*pWindow */ ,
                                   int /*dx */ ,
                                   int /*dy */ );

/* pixmap will exist only for the duration of the current rendering operation */
#define CREATE_PIXMAP_USAGE_SCRATCH                     1
/* pixmap will be the backing pixmap for a redirected window */
#define CREATE_PIXMAP_USAGE_BACKING_PIXMAP              2
/* pixmap will contain a glyph */
#define CREATE_PIXMAP_USAGE_GLYPH_PICTURE               3
/* pixmap will be shared */
#define CREATE_PIXMAP_USAGE_SHARED                      4

typedef PixmapPtr (*CreatePixmapProcPtr) (ScreenPtr /*pScreen */ ,
                                          int /*width */ ,
                                          int /*height */ ,
                                          int /*depth */ ,
                                          unsigned /*usage_hint */ );

typedef Bool (*DestroyPixmapProcPtr) (PixmapPtr /*pPixmap */ );

typedef Bool (*RealizeFontProcPtr) (ScreenPtr /*pScreen */ ,
                                    FontPtr /*pFont */ );

typedef Bool (*UnrealizeFontProcPtr) (ScreenPtr /*pScreen */ ,
                                      FontPtr /*pFont */ );

typedef void (*ConstrainCursorProcPtr) (DeviceIntPtr /*pDev */ ,
                                        ScreenPtr /*pScreen */ ,
                                        BoxPtr /*pBox */ );

typedef void (*CursorLimitsProcPtr) (DeviceIntPtr /* pDev */ ,
                                     ScreenPtr /*pScreen */ ,
                                     CursorPtr /*pCursor */ ,
                                     BoxPtr /*pHotBox */ ,
                                     BoxPtr /*pTopLeftBox */ );

typedef Bool (*DisplayCursorProcPtr) (DeviceIntPtr /* pDev */ ,
                                      ScreenPtr /*pScreen */ ,
                                      CursorPtr /*pCursor */ );

typedef Bool (*RealizeCursorProcPtr) (DeviceIntPtr /* pDev */ ,
                                      ScreenPtr /*pScreen */ ,
                                      CursorPtr /*pCursor */ );

typedef Bool (*UnrealizeCursorProcPtr) (DeviceIntPtr /* pDev */ ,
                                        ScreenPtr /*pScreen */ ,
                                        CursorPtr /*pCursor */ );

typedef void (*RecolorCursorProcPtr) (DeviceIntPtr /* pDev */ ,
                                      ScreenPtr /*pScreen */ ,
                                      CursorPtr /*pCursor */ ,
                                      Bool /*displayed */ );

typedef Bool (*SetCursorPositionProcPtr) (DeviceIntPtr /* pDev */ ,
                                          ScreenPtr /*pScreen */ ,
                                          int /*x */ ,
                                          int /*y */ ,
                                          Bool /*generateEvent */ );

typedef Bool (*CreateGCProcPtr) (GCPtr /*pGC */ );

typedef Bool (*CreateColormapProcPtr) (ColormapPtr /*pColormap */ );

typedef void (*DestroyColormapProcPtr) (ColormapPtr /*pColormap */ );

typedef void (*InstallColormapProcPtr) (ColormapPtr /*pColormap */ );

typedef void (*UninstallColormapProcPtr) (ColormapPtr /*pColormap */ );

typedef int (*ListInstalledColormapsProcPtr) (ScreenPtr /*pScreen */ ,
                                              XID * /*pmaps */ );

typedef void (*StoreColorsProcPtr) (ColormapPtr /*pColormap */ ,
                                    int /*ndef */ ,
                                    xColorItem * /*pdef */ );

typedef void (*ResolveColorProcPtr) (unsigned short * /*pred */ ,
                                     unsigned short * /*pgreen */ ,
                                     unsigned short * /*pblue */ ,
                                     VisualPtr /*pVisual */ );

typedef RegionPtr (*BitmapToRegionProcPtr) (PixmapPtr /*pPix */ );

typedef void (*ScreenBlockHandlerProcPtr) (ScreenPtr pScreen,
                                           void *pTimeout,
                                           void *pReadmask);

typedef void (*ScreenWakeupHandlerProcPtr) (ScreenPtr pScreen,
                                            unsigned long result,
                                            void *pReadMask);

typedef Bool (*CreateScreenResourcesProcPtr) (ScreenPtr /*pScreen */ );

typedef Bool (*ModifyPixmapHeaderProcPtr) (PixmapPtr pPixmap,
                                           int width,
                                           int height,
                                           int depth,
                                           int bitsPerPixel,
                                           int devKind,
                                           void *pPixData);

typedef PixmapPtr (*GetWindowPixmapProcPtr) (WindowPtr /*pWin */ );

typedef void (*SetWindowPixmapProcPtr) (WindowPtr /*pWin */ ,
                                        PixmapPtr /*pPix */ );

typedef PixmapPtr (*GetScreenPixmapProcPtr) (ScreenPtr /*pScreen */ );

typedef void (*SetScreenPixmapProcPtr) (PixmapPtr /*pPix */ );

typedef void (*MarkWindowProcPtr) (WindowPtr /*pWin */ );

typedef Bool (*MarkOverlappedWindowsProcPtr) (WindowPtr /*parent */ ,
                                              WindowPtr /*firstChild */ ,
                                              WindowPtr * /*pLayerWin */ );

typedef int (*ConfigNotifyProcPtr) (WindowPtr /*pWin */ ,
                                    int /*x */ ,
                                    int /*y */ ,
                                    int /*w */ ,
                                    int /*h */ ,
                                    int /*bw */ ,
                                    WindowPtr /*pSib */ );

typedef void (*MoveWindowProcPtr) (WindowPtr /*pWin */ ,
                                   int /*x */ ,
                                   int /*y */ ,
                                   WindowPtr /*pSib */ ,
                                   VTKind /*kind */ );

typedef void (*ResizeWindowProcPtr) (WindowPtr /*pWin */ ,
                                     int /*x */ ,
                                     int /*y */ ,
                                     unsigned int /*w */ ,
                                     unsigned int /*h */ ,
                                     WindowPtr  /*pSib */
    );

typedef WindowPtr (*GetLayerWindowProcPtr) (WindowPtr   /*pWin */
    );

typedef void (*HandleExposuresProcPtr) (WindowPtr /*pWin */ );

typedef void (*ReparentWindowProcPtr) (WindowPtr /*pWin */ ,
                                       WindowPtr /*pPriorParent */ );

typedef void (*SetShapeProcPtr) (WindowPtr /*pWin */ ,
                                 int /* kind */ );

typedef void (*ChangeBorderWidthProcPtr) (WindowPtr /*pWin */ ,
                                          unsigned int /*width */ );

typedef void (*MarkUnrealizedWindowProcPtr) (WindowPtr /*pChild */ ,
                                             WindowPtr /*pWin */ ,
                                             Bool /*fromConfigure */ );

typedef Bool (*DeviceCursorInitializeProcPtr) (DeviceIntPtr /* pDev */ ,
                                               ScreenPtr /* pScreen */ );

typedef void (*DeviceCursorCleanupProcPtr) (DeviceIntPtr /* pDev */ ,
                                            ScreenPtr /* pScreen */ );

typedef void (*ConstrainCursorHarderProcPtr) (DeviceIntPtr, ScreenPtr, int,
                                              int *, int *);


typedef Bool (*SharePixmapBackingProcPtr)(PixmapPtr, ScreenPtr, void **);

typedef Bool (*SetSharedPixmapBackingProcPtr)(PixmapPtr, void *);

typedef Bool (*StartPixmapTrackingProcPtr)(PixmapPtr, PixmapPtr,
                                           int x, int y,
                                           int dst_x, int dst_y,
                                           Rotation rotation);

typedef Bool (*StopPixmapTrackingProcPtr)(PixmapPtr, PixmapPtr);

typedef Bool (*ReplaceScanoutPixmapProcPtr)(DrawablePtr, PixmapPtr, Bool);

typedef WindowPtr (*XYToWindowProcPtr)(ScreenPtr pScreen,
                                       SpritePtr pSprite, int x, int y);

typedef int (*NameWindowPixmapProcPtr)(WindowPtr, PixmapPtr, CARD32);

/* Wrapping Screen procedures

   There are a few modules in the X server which dynamically add and
    remove themselves from various screen procedure call chains.

    For example, the BlockHandler is dynamically modified by:

     * xf86Rotate
     * miSprite
     * composite
     * render (for animated cursors)

    Correctly manipulating this chain is complicated by the fact that
    the chain is constructed through a sequence of screen private
    structures, each holding the next screen->proc pointer.

    To add a module to a screen->proc chain is fairly simple; just save
    the current screen->proc value in the module screen private
    and store the module's function in the screen->proc location.

    Removing a screen proc is a bit trickier. It seems like all you
    need to do is set the screen->proc pointer back to the value saved
    in your screen private. However, if some other module has come
    along and wrapped on top of you, then the right place to store the
    previous screen->proc value is actually in the wrapping module's
    screen private structure(!). Of course, you have no idea what
    other module may have wrapped on top, nor could you poke inside
    its screen private in any case.

    To make this work, we restrict the unwrapping process to happen
    during the invocation of the screen proc itself, and then we
    require the screen proc to take some care when manipulating the
    screen proc functions pointers.

    The requirements are:

     1) The screen proc must set the screen->proc pointer back to the
        value saved in its screen private before calling outside its
        module.

     2a) If the screen proc wants to be remove itself from the chain,
         it must not manipulate screen->proc pointer again before
         returning.

     2b) If the screen proc wants to remain in the chain, it must:

       2b.1) Re-fetch the screen->proc pointer and store that in
             its screen private. This ensures that any changes
             to the chain will be preserved.

       2b.2) Set screen->proc back to itself

    One key requirement here is that these steps must wrap not just
    any invocation of the nested screen->proc value, but must nest
    essentially any calls outside the current module. This ensures
    that other modules can reliably manipulate screen->proc wrapping
    using these same rules.

    For example, the animated cursor code in render has two macros,
    Wrap and Unwrap.

        #define Unwrap(as,s,elt)    ((s)->elt = (as)->elt)

    Unwrap takes the screen private (as), the screen (s) and the
    member name (elt), and restores screen->proc to that saved in the
    screen private.

        #define Wrap(as,s,elt,func) (((as)->elt = (s)->elt), (s)->elt = func)

    Wrap takes the screen private (as), the screen (s), the member
    name (elt) and the wrapping function (func). It saves the
    current screen->proc value in the screen private, and then sets the
    screen->proc to the local wrapping function.

    Within each of these functions, there's a pretty simple pattern:

        Unwrap(as, pScreen, UnrealizeCursor);

        // Do local stuff, including possibly calling down through
        // pScreen->UnrealizeCursor

        Wrap(as, pScreen, UnrealizeCursor, AnimCurUnrealizeCursor);

    The wrapping block handler is a bit different; it does the Unwrap,
    the local operations and then only re-Wraps if the hook is still
    required. Unwrap occurrs at the top of each function, just after
    entry, and Wrap occurrs at the bottom of each function, just
    before returning.
 */

typedef struct _Screen {
    int myNum;                  /* index of this instance in Screens[] */
    ATOM id;
    short x, y, width, height;
    short mmWidth, mmHeight;
    short numDepths;
    unsigned char rootDepth;
    DepthPtr allowedDepths;
    unsigned long rootVisual;
    unsigned long defColormap;
    short minInstalledCmaps, maxInstalledCmaps;
    char backingStoreSupport, saveUnderSupport;
    unsigned long whitePixel, blackPixel;
    GCPtr GCperDepth[MAXFORMATS + 1];
    /* next field is a stipple to use as default in
       a GC.  we don't build default tiles of all depths
       because they are likely to be of a color
       different from the default fg pixel, so
       we don't win anything by building
       a standard one.
     */
    PixmapPtr PixmapPerDepth[1];
    void *devPrivate;
    short numVisuals;
    VisualPtr visuals;
    WindowPtr root;
    ScreenSaverStuffRec screensaver;

    DevPrivateSetRec    screenSpecificPrivates[PRIVATE_LAST];

    /* Random screen procedures */

    CloseScreenProcPtr CloseScreen;
    QueryBestSizeProcPtr QueryBestSize;
    SaveScreenProcPtr SaveScreen;
    GetImageProcPtr GetImage;
    GetSpansProcPtr GetSpans;
    SourceValidateProcPtr SourceValidate;

    /* Window Procedures */

    CreateWindowProcPtr CreateWindow;
    DestroyWindowProcPtr DestroyWindow;
    PositionWindowProcPtr PositionWindow;
    ChangeWindowAttributesProcPtr ChangeWindowAttributes;
    RealizeWindowProcPtr RealizeWindow;
    UnrealizeWindowProcPtr UnrealizeWindow;
    ValidateTreeProcPtr ValidateTree;
    PostValidateTreeProcPtr PostValidateTree;
    WindowExposuresProcPtr WindowExposures;
    CopyWindowProcPtr CopyWindow;
    ClearToBackgroundProcPtr ClearToBackground;
    ClipNotifyProcPtr ClipNotify;
    RestackWindowProcPtr RestackWindow;
    PaintWindowProcPtr PaintWindow;

    /* Pixmap procedures */

    CreatePixmapProcPtr CreatePixmap;
    DestroyPixmapProcPtr DestroyPixmap;

    /* Font procedures */

    RealizeFontProcPtr RealizeFont;
    UnrealizeFontProcPtr UnrealizeFont;

    /* Cursor Procedures */

    ConstrainCursorProcPtr ConstrainCursor;
    ConstrainCursorHarderProcPtr ConstrainCursorHarder;
    CursorLimitsProcPtr CursorLimits;
    DisplayCursorProcPtr DisplayCursor;
    RealizeCursorProcPtr RealizeCursor;
    UnrealizeCursorProcPtr UnrealizeCursor;
    RecolorCursorProcPtr RecolorCursor;
    SetCursorPositionProcPtr SetCursorPosition;

    /* GC procedures */

    CreateGCProcPtr CreateGC;

    /* Colormap procedures */

    CreateColormapProcPtr CreateColormap;
    DestroyColormapProcPtr DestroyColormap;
    InstallColormapProcPtr InstallColormap;
    UninstallColormapProcPtr UninstallColormap;
    ListInstalledColormapsProcPtr ListInstalledColormaps;
    StoreColorsProcPtr StoreColors;
    ResolveColorProcPtr ResolveColor;

    /* Region procedures */

    BitmapToRegionProcPtr BitmapToRegion;

    /* os layer procedures */

    ScreenBlockHandlerProcPtr BlockHandler;
    ScreenWakeupHandlerProcPtr WakeupHandler;

    /* anybody can get a piece of this array */
    PrivateRec *devPrivates;

    CreateScreenResourcesProcPtr CreateScreenResources;
    ModifyPixmapHeaderProcPtr ModifyPixmapHeader;

    GetWindowPixmapProcPtr GetWindowPixmap;
    SetWindowPixmapProcPtr SetWindowPixmap;
    GetScreenPixmapProcPtr GetScreenPixmap;
    SetScreenPixmapProcPtr SetScreenPixmap;
    NameWindowPixmapProcPtr NameWindowPixmap;

    PixmapPtr pScratchPixmap;   /* scratch pixmap "pool" */

    unsigned int totalPixmapSize;

    MarkWindowProcPtr MarkWindow;
    MarkOverlappedWindowsProcPtr MarkOverlappedWindows;
    ConfigNotifyProcPtr ConfigNotify;
    MoveWindowProcPtr MoveWindow;
    ResizeWindowProcPtr ResizeWindow;
    GetLayerWindowProcPtr GetLayerWindow;
    HandleExposuresProcPtr HandleExposures;
    ReparentWindowProcPtr ReparentWindow;

    SetShapeProcPtr SetShape;

    ChangeBorderWidthProcPtr ChangeBorderWidth;
    MarkUnrealizedWindowProcPtr MarkUnrealizedWindow;

    /* Device cursor procedures */
    DeviceCursorInitializeProcPtr DeviceCursorInitialize;
    DeviceCursorCleanupProcPtr DeviceCursorCleanup;

    /* set it in driver side if X server can copy the framebuffer content.
     * Meant to be used together with '-background none' option, avoiding
     * malicious users to steal framebuffer's content if that would be the
     * default */
    Bool canDoBGNoneRoot;

    Bool isGPU;

    struct xorg_list unattached_list;
    struct xorg_list unattached_head;

    ScreenPtr current_master;

    struct xorg_list output_slave_list;
    struct xorg_list output_head;

    SharePixmapBackingProcPtr SharePixmapBacking;
    SetSharedPixmapBackingProcPtr SetSharedPixmapBacking;

    StartPixmapTrackingProcPtr StartPixmapTracking;
    StopPixmapTrackingProcPtr StopPixmapTracking;

    struct xorg_list pixmap_dirty_list;
    struct xorg_list offload_slave_list;
    struct xorg_list offload_head;

    ReplaceScanoutPixmapProcPtr ReplaceScanoutPixmap;
    XYToWindowProcPtr XYToWindow;
} ScreenRec;

static inline RegionPtr
BitmapToRegion(ScreenPtr _pScreen, PixmapPtr pPix)
{
    return (*(_pScreen)->BitmapToRegion) (pPix);        /* no mi version?! */
}

typedef struct _ScreenInfo {
    int imageByteOrder;
    int bitmapScanlineUnit;
    int bitmapScanlinePad;
    int bitmapBitOrder;
    int numPixmapFormats;
     PixmapFormatRec formats[MAXFORMATS];
    int numScreens;
    ScreenPtr screens[MAXSCREENS];
    int numGPUScreens;
    ScreenPtr gpuscreens[MAXGPUSCREENS];
    int x;                      /* origin */
    int y;                      /* origin */
    int width;                  /* total width of all screens together */
    int height;                 /* total height of all screens together */
} ScreenInfo;

extern _X_EXPORT ScreenInfo screenInfo;

extern _X_EXPORT void InitOutput(ScreenInfo * /*pScreenInfo */ ,
                                 int /*argc */ ,
                                 char ** /*argv */ );

#endif                          /* SCREENINTSTRUCT_H */
@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d58 1
d161 4
d348 3
a350 1
                                           int x, int y);
d505 1
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d29 2
a30 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d32 1
a32 1
both that copyright notice and this permission notice appear in 
d35 1
a35 1
software without specific, written prior permission.  
d158 1
a158 2
                                        RegionPtr /*prgn */ ,
                                        RegionPtr /*other_exposed */ );
d255 7
a261 13
typedef void (*SendGraphicsExposeProcPtr) (ClientPtr /*client */ ,
                                           RegionPtr /*pRgn */ ,
                                           XID /*drawable */ ,
                                           int /*major */ ,
                                           int /*minor */ );

typedef void (*ScreenBlockHandlerProcPtr) (ScreenPtr /*pScreen*/ ,
                                           void */*pTimeout */ ,
                                           void */*pReadmask */ );

typedef void (*ScreenWakeupHandlerProcPtr) (ScreenPtr /*pScreen*/ ,
                                            unsigned long /*result */ ,
                                            void */*pReadMask */ );
d265 7
a271 7
typedef Bool (*ModifyPixmapHeaderProcPtr) (PixmapPtr /*pPixmap */ ,
                                           int /*width */ ,
                                           int /*height */ ,
                                           int /*depth */ ,
                                           int /*bitsPerPixel */ ,
                                           int /*devKind */ ,
                                           void */*pPixData */ );
d354 90
a536 1
    SendGraphicsExposeProcPtr SendGraphicsExpose;
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d263 2
a264 2
                                           pointer /*pTimeout */ ,
                                           pointer /*pReadmask */ );
d268 1
a268 1
                                            pointer /*pReadMask */ );
d278 1
a278 1
                                           pointer /*pPixData */ );
d356 5
d383 1
a383 1
    pointer devPrivate;
d471 1
d522 1
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d98 1
a98 2
typedef Bool (*CloseScreenProcPtr) (int /*index */ ,
                                    ScreenPtr /*pScreen */ );
d182 2
d262 1
a262 2
typedef void (*ScreenBlockHandlerProcPtr) (int /*screenNum */ ,
                                           pointer /*blockData */ ,
d266 1
a266 2
typedef void (*ScreenWakeupHandlerProcPtr) (int /*screenNum */ ,
                                            pointer /*wakeupData */ ,
d344 12
d384 2
a455 3
    pointer blockData;
    pointer wakeupData;

d494 22
d533 2
@


1.6
log
@Update to xserver 1.11.2
@
text
@a24 1

d60 5
a64 5
    unsigned char	depth;
    unsigned char	bitsPerPixel;
    unsigned char	scanlinePad;
    } PixmapFormatRec;
    
d66 10
a75 10
    VisualID		vid;
    short		class;
    short		bitsPerRGBValue;
    short		ColormapEntries;
    short		nplanes;/* = log2 (ColormapEntries). This does not
				 * imply that the screen has this many planes.
				 * it may have more or fewer */
    unsigned long	redMask, greenMask, blueMask;
    int			offsetRed, offsetGreen, offsetBlue;
  } VisualRec;
d78 4
a81 4
    unsigned char	depth;
    short		numVids;
    VisualID		*vids;    /* block of visual ids for this depth */
  } DepthRec;
d85 5
a89 6
    XID       wid;
    char      blanked;
    Bool      (*ExternalScreenSaver)(
	ScreenPtr	/*pScreen*/,
	int		/*xstate*/,
	Bool		/*force*/);
a91 1

d98 78
a175 97
typedef    Bool (* CloseScreenProcPtr)(
	int /*index*/,
	ScreenPtr /*pScreen*/);

typedef    void (* QueryBestSizeProcPtr)(
	int /*class*/,
	unsigned short * /*pwidth*/,
	unsigned short * /*pheight*/,
	ScreenPtr /*pScreen*/);

typedef    Bool (* SaveScreenProcPtr)(
	 ScreenPtr /*pScreen*/,
	 int /*on*/);

typedef    void (* GetImageProcPtr)(
	DrawablePtr /*pDrawable*/,
	int /*sx*/,
	int /*sy*/,
	int /*w*/,
	int /*h*/,
	unsigned int /*format*/,
	unsigned long /*planeMask*/,
	char * /*pdstLine*/);

typedef    void (* GetSpansProcPtr)(
	DrawablePtr /*pDrawable*/,
	int /*wMax*/,
	DDXPointPtr /*ppt*/,
	int* /*pwidth*/,
	int /*nspans*/,
	char * /*pdstStart*/);

typedef    void (* SourceValidateProcPtr)(
	DrawablePtr /*pDrawable*/,
	int /*x*/,
	int /*y*/,
	int /*width*/,
	int /*height*/,
	unsigned int /*subWindowMode*/);

typedef    Bool (* CreateWindowProcPtr)(
	WindowPtr /*pWindow*/);

typedef    Bool (* DestroyWindowProcPtr)(
	WindowPtr /*pWindow*/);

typedef    Bool (* PositionWindowProcPtr)(
	WindowPtr /*pWindow*/,
	int /*x*/,
	int /*y*/);

typedef    Bool (* ChangeWindowAttributesProcPtr)(
	WindowPtr /*pWindow*/,
	unsigned long /*mask*/);

typedef    Bool (* RealizeWindowProcPtr)(
	WindowPtr /*pWindow*/);

typedef    Bool (* UnrealizeWindowProcPtr)(
	WindowPtr /*pWindow*/);

typedef    void (* RestackWindowProcPtr)(
	WindowPtr /*pWindow*/,
	WindowPtr /*pOldNextSib*/);

typedef    int  (* ValidateTreeProcPtr)(
	WindowPtr /*pParent*/,
	WindowPtr /*pChild*/,
	VTKind /*kind*/);

typedef    void (* PostValidateTreeProcPtr)(
	WindowPtr /*pParent*/,
	WindowPtr /*pChild*/,
	VTKind /*kind*/);

typedef    void (* WindowExposuresProcPtr)(
	WindowPtr /*pWindow*/,
	RegionPtr /*prgn*/,
	RegionPtr /*other_exposed*/);

typedef    void (* CopyWindowProcPtr)(
	WindowPtr /*pWindow*/,
	DDXPointRec /*ptOldOrg*/,
	RegionPtr /*prgnSrc*/);

typedef    void (* ClearToBackgroundProcPtr)(
	WindowPtr /*pWindow*/,
	int /*x*/,
	int /*y*/,
	int /*w*/,
	int /*h*/,
	Bool /*generateExposures*/);

typedef    void (* ClipNotifyProcPtr)(
	WindowPtr /*pWindow*/,
	int /*dx*/,
	int /*dy*/);
d184 157
a340 199
typedef    PixmapPtr (* CreatePixmapProcPtr)(
	ScreenPtr /*pScreen*/,
	int /*width*/,
	int /*height*/,
	int /*depth*/,
	unsigned /*usage_hint*/);

typedef    Bool (* DestroyPixmapProcPtr)(
	PixmapPtr /*pPixmap*/);

typedef    Bool (* RealizeFontProcPtr)(
	ScreenPtr /*pScreen*/,
	FontPtr /*pFont*/);

typedef    Bool (* UnrealizeFontProcPtr)(
	ScreenPtr /*pScreen*/,
	FontPtr /*pFont*/);

typedef    void (* ConstrainCursorProcPtr)(
        DeviceIntPtr /*pDev*/,
	ScreenPtr /*pScreen*/,
	BoxPtr /*pBox*/);

typedef    void (* CursorLimitsProcPtr)(
        DeviceIntPtr /* pDev */,
	ScreenPtr /*pScreen*/,
	CursorPtr /*pCursor*/,
	BoxPtr /*pHotBox*/,
	BoxPtr /*pTopLeftBox*/);

typedef    Bool (* DisplayCursorProcPtr)(
        DeviceIntPtr /* pDev */,
	ScreenPtr /*pScreen*/,
	CursorPtr /*pCursor*/);

typedef    Bool (* RealizeCursorProcPtr)(
        DeviceIntPtr /* pDev */,
	ScreenPtr /*pScreen*/,
	CursorPtr /*pCursor*/);

typedef    Bool (* UnrealizeCursorProcPtr)(
        DeviceIntPtr /* pDev */,
	ScreenPtr /*pScreen*/,
	CursorPtr /*pCursor*/);

typedef    void (* RecolorCursorProcPtr)(
        DeviceIntPtr /* pDev */,
	ScreenPtr /*pScreen*/,
	CursorPtr /*pCursor*/,
	Bool /*displayed*/);

typedef    Bool (* SetCursorPositionProcPtr)(
        DeviceIntPtr /* pDev */,
	ScreenPtr /*pScreen*/,
	int /*x*/,
	int /*y*/,
	Bool /*generateEvent*/);

typedef    Bool (* CreateGCProcPtr)(
	GCPtr /*pGC*/);

typedef    Bool (* CreateColormapProcPtr)(
	ColormapPtr /*pColormap*/);

typedef    void (* DestroyColormapProcPtr)(
	ColormapPtr /*pColormap*/);

typedef    void (* InstallColormapProcPtr)(
	ColormapPtr /*pColormap*/);

typedef    void (* UninstallColormapProcPtr)(
	ColormapPtr /*pColormap*/);

typedef    int (* ListInstalledColormapsProcPtr) (
	ScreenPtr /*pScreen*/,
	XID* /*pmaps */);

typedef    void (* StoreColorsProcPtr)(
	ColormapPtr /*pColormap*/,
	int /*ndef*/,
	xColorItem * /*pdef*/);

typedef    void (* ResolveColorProcPtr)(
	unsigned short* /*pred*/,
	unsigned short* /*pgreen*/,
	unsigned short* /*pblue*/,
	VisualPtr /*pVisual*/);

typedef    RegionPtr (* BitmapToRegionProcPtr)(
	PixmapPtr /*pPix*/);

typedef    void (* SendGraphicsExposeProcPtr)(
	ClientPtr /*client*/,
	RegionPtr /*pRgn*/,
	XID /*drawable*/,
	int /*major*/,
	int /*minor*/);

typedef    void (* ScreenBlockHandlerProcPtr)(
	int /*screenNum*/,
	pointer /*blockData*/,
	pointer /*pTimeout*/,
	pointer /*pReadmask*/);

typedef    void (* ScreenWakeupHandlerProcPtr)(
	 int /*screenNum*/,
	 pointer /*wakeupData*/,
	 unsigned long /*result*/,
	 pointer /*pReadMask*/);

typedef    Bool (* CreateScreenResourcesProcPtr)(
	ScreenPtr /*pScreen*/);

typedef    Bool (* ModifyPixmapHeaderProcPtr)(
	PixmapPtr /*pPixmap*/,
	int /*width*/,
	int /*height*/,
	int /*depth*/,
	int /*bitsPerPixel*/,
	int /*devKind*/,
	pointer /*pPixData*/);

typedef    PixmapPtr (* GetWindowPixmapProcPtr)(
	WindowPtr /*pWin*/);

typedef    void (* SetWindowPixmapProcPtr)(
	WindowPtr /*pWin*/,
	PixmapPtr /*pPix*/);

typedef    PixmapPtr (* GetScreenPixmapProcPtr)(
	ScreenPtr /*pScreen*/);

typedef    void (* SetScreenPixmapProcPtr)(
	PixmapPtr /*pPix*/);

typedef    void (* MarkWindowProcPtr)(
	WindowPtr /*pWin*/);

typedef    Bool (* MarkOverlappedWindowsProcPtr)(
	WindowPtr /*parent*/,
	WindowPtr /*firstChild*/,
	WindowPtr * /*pLayerWin*/);

typedef    int (* ConfigNotifyProcPtr)(
	WindowPtr /*pWin*/,
	int /*x*/,
	int /*y*/,
	int /*w*/,
	int /*h*/,
	int /*bw*/,
	WindowPtr /*pSib*/);

typedef    void (* MoveWindowProcPtr)(
	WindowPtr /*pWin*/,
	int /*x*/,
	int /*y*/,
	WindowPtr /*pSib*/,
	VTKind /*kind*/);

typedef    void (* ResizeWindowProcPtr)(
    WindowPtr /*pWin*/,
    int /*x*/,
    int /*y*/, 
    unsigned int /*w*/,
    unsigned int /*h*/,
    WindowPtr /*pSib*/
);

typedef    WindowPtr (* GetLayerWindowProcPtr)(
    WindowPtr /*pWin*/
);

typedef    void (* HandleExposuresProcPtr)(
    WindowPtr /*pWin*/);

typedef    void (* ReparentWindowProcPtr)(
    WindowPtr /*pWin*/,
    WindowPtr /*pPriorParent*/);

typedef    void (* SetShapeProcPtr)(
        WindowPtr /*pWin*/,
        int /* kind */);

typedef    void (* ChangeBorderWidthProcPtr)(
	WindowPtr /*pWin*/,
	unsigned int /*width*/);

typedef    void (* MarkUnrealizedWindowProcPtr)(
	WindowPtr /*pChild*/,
	WindowPtr /*pWin*/,
	Bool /*fromConfigure*/);

typedef    Bool (* DeviceCursorInitializeProcPtr)(
        DeviceIntPtr /* pDev */,
        ScreenPtr    /* pScreen */);

typedef    void (* DeviceCursorCleanupProcPtr)(
        DeviceIntPtr /* pDev */,
        ScreenPtr    /* pScreen */);
d342 2
a343 2
typedef void (*ConstrainCursorHarderProcPtr)(
       DeviceIntPtr, ScreenPtr, int, int *, int *);
d346 25
a370 25
    int			myNum;	/* index of this instance in Screens[] */
    ATOM		id;
    short		x, y, width, height;
    short		mmWidth, mmHeight;
    short		numDepths;
    unsigned char      	rootDepth;
    DepthPtr       	allowedDepths;
    unsigned long      	rootVisual;
    unsigned long	defColormap;
    short		minInstalledCmaps, maxInstalledCmaps;
    char                backingStoreSupport, saveUnderSupport;
    unsigned long	whitePixel, blackPixel;
    GCPtr		GCperDepth[MAXFORMATS+1];
			/* next field is a stipple to use as default in
			   a GC.  we don't build default tiles of all depths
			   because they are likely to be of a color
			   different from the default fg pixel, so
			   we don't win anything by building
			   a standard one.
			*/
    PixmapPtr		PixmapPerDepth[1];
    pointer		devPrivate;
    short       	numVisuals;
    VisualPtr		visuals;
    WindowPtr		root;
d375 6
a380 6
    CloseScreenProcPtr		CloseScreen;
    QueryBestSizeProcPtr	QueryBestSize;
    SaveScreenProcPtr		SaveScreen;
    GetImageProcPtr		GetImage;
    GetSpansProcPtr		GetSpans;
    SourceValidateProcPtr	SourceValidate;
d384 3
a386 3
    CreateWindowProcPtr		CreateWindow;
    DestroyWindowProcPtr	DestroyWindow;
    PositionWindowProcPtr	PositionWindow;
d388 9
a396 9
    RealizeWindowProcPtr	RealizeWindow;
    UnrealizeWindowProcPtr	UnrealizeWindow;
    ValidateTreeProcPtr		ValidateTree;
    PostValidateTreeProcPtr	PostValidateTree;
    WindowExposuresProcPtr	WindowExposures;
    CopyWindowProcPtr		CopyWindow;
    ClearToBackgroundProcPtr	ClearToBackground;
    ClipNotifyProcPtr		ClipNotify;
    RestackWindowProcPtr	RestackWindow;
d400 2
a401 2
    CreatePixmapProcPtr		CreatePixmap;
    DestroyPixmapProcPtr	DestroyPixmap;
d405 2
a406 2
    RealizeFontProcPtr		RealizeFont;
    UnrealizeFontProcPtr	UnrealizeFont;
d410 1
a410 1
    ConstrainCursorProcPtr	ConstrainCursor;
d412 6
a417 6
    CursorLimitsProcPtr		CursorLimits;
    DisplayCursorProcPtr	DisplayCursor;
    RealizeCursorProcPtr	RealizeCursor;
    UnrealizeCursorProcPtr	UnrealizeCursor;
    RecolorCursorProcPtr	RecolorCursor;
    SetCursorPositionProcPtr	SetCursorPosition;
d421 1
a421 1
    CreateGCProcPtr		CreateGC;
d425 4
a428 4
    CreateColormapProcPtr	CreateColormap;
    DestroyColormapProcPtr	DestroyColormap;
    InstallColormapProcPtr	InstallColormap;
    UninstallColormapProcPtr	UninstallColormap;
d430 2
a431 2
    StoreColorsProcPtr		StoreColors;
    ResolveColorProcPtr		ResolveColor;
d435 2
a436 2
    BitmapToRegionProcPtr	BitmapToRegion;
    SendGraphicsExposeProcPtr	SendGraphicsExpose;
d440 2
a441 2
    ScreenBlockHandlerProcPtr	BlockHandler;
    ScreenWakeupHandlerProcPtr	WakeupHandler;
d447 1
a447 1
    PrivateRec	*devPrivates;
d450 1
a450 1
    ModifyPixmapHeaderProcPtr	ModifyPixmapHeader;
d452 4
a455 4
    GetWindowPixmapProcPtr	GetWindowPixmap;
    SetWindowPixmapProcPtr	SetWindowPixmap;
    GetScreenPixmapProcPtr	GetScreenPixmap;
    SetScreenPixmapProcPtr	SetScreenPixmap;
d457 1
a457 1
    PixmapPtr pScratchPixmap;		/* scratch pixmap "pool" */
d459 1
a459 1
    unsigned int		totalPixmapSize;
d461 1
a461 1
    MarkWindowProcPtr		MarkWindow;
d463 6
a468 6
    ConfigNotifyProcPtr		ConfigNotify;
    MoveWindowProcPtr		MoveWindow;
    ResizeWindowProcPtr		ResizeWindow;
    GetLayerWindowProcPtr	GetLayerWindow;
    HandleExposuresProcPtr	HandleExposures;
    ReparentWindowProcPtr	ReparentWindow;
d470 1
a470 1
    SetShapeProcPtr		SetShape;
d472 2
a473 2
    ChangeBorderWidthProcPtr	ChangeBorderWidth;
    MarkUnrealizedWindowProcPtr	MarkUnrealizedWindow;
d477 1
a477 1
    DeviceCursorCleanupProcPtr    DeviceCursorCleanup;
d483 1
a483 1
    Bool		canDoBGNoneRoot;
d486 4
a489 2
static inline RegionPtr BitmapToRegion(ScreenPtr _pScreen, PixmapPtr pPix) {
    return (*(_pScreen)->BitmapToRegion)(pPix); /* no mi version?! */
d493 12
a504 9
    int		imageByteOrder;
    int		bitmapScanlineUnit;
    int		bitmapScanlinePad;
    int		bitmapBitOrder;
    int		numPixmapFormats;
    PixmapFormatRec
		formats[MAXFORMATS];
    int		numScreens;
    ScreenPtr	screens[MAXSCREENS];
d509 3
a511 4
extern _X_EXPORT void InitOutput(
    ScreenInfo 	* /*pScreenInfo*/,
    int     	/*argc*/,
    char    	** /*argv*/);
d513 1
a513 1
#endif /* SCREENINTSTRUCT_H */
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a52 1
#include "bstore.h"
d138 2
a139 1
	int /*height*/);
a215 42
typedef    void (* SaveDoomedAreasProcPtr)(
	WindowPtr /*pWindow*/,
	RegionPtr /*prgnSave*/,
	int /*xorg*/,
	int /*yorg*/);

typedef    RegionPtr (* RestoreAreasProcPtr)(
	WindowPtr /*pWindow*/,
	RegionPtr /*prgnRestore*/);

typedef    void (* ExposeCopyProcPtr)(
	WindowPtr /*pSrc*/,
	DrawablePtr /*pDst*/,
	GCPtr /*pGC*/,
	RegionPtr /*prgnExposed*/,
	int /*srcx*/,
	int /*srcy*/,
	int /*dstx*/,
	int /*dsty*/,
	unsigned long /*plane*/);

typedef    RegionPtr (* TranslateBackingStoreProcPtr)(
	WindowPtr /*pWindow*/,
	int /*windx*/,
	int /*windy*/,
	RegionPtr /*oldClip*/,
	int /*oldx*/,
	int /*oldy*/);

typedef    RegionPtr (* ClearBackingStoreProcPtr)(
	WindowPtr /*pWindow*/,
	int /*x*/,
	int /*y*/,
	int /*w*/,
	int /*h*/,
	Bool /*generateExposures*/);

typedef    void (* DrawGuaranteeProcPtr)(
	WindowPtr /*pWindow*/,
	GCPtr /*pGC*/,
	int /*guarantee*/);
    
a348 8
typedef    Bool (* ChangeSaveUnderProcPtr)(
	WindowPtr /*pLayerWin*/,
	WindowPtr /*firstChild*/);

typedef    void (* PostChangeSaveUnderProcPtr)(
	WindowPtr /*pLayerWin*/,
	WindowPtr /*firstChild*/);

d406 3
a466 14
    /* Backing store procedures */

    SaveDoomedAreasProcPtr	SaveDoomedAreas;
    RestoreAreasProcPtr		RestoreAreas;
    ExposeCopyProcPtr		ExposeCopy;
    TranslateBackingStoreProcPtr TranslateBackingStore;
    ClearBackingStoreProcPtr	ClearBackingStore;
    DrawGuaranteeProcPtr	DrawGuarantee;
    /*
     * A read/write copy of the lower level backing store vector is needed now
     * that the functions can be wrapped.
     */
    BSFuncRec			BackingStoreFuncs;
    
d475 1
a526 2
    ChangeSaveUnderProcPtr	ChangeSaveUnder;
    PostChangeSaveUnderProcPtr	PostChangeSaveUnder;
d542 6
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d85 10
a133 5
typedef    void (* PointerNonInterestBoxProcPtr)(
        DeviceIntPtr /*pDev*/,
	ScreenPtr /*pScreen*/,
	BoxPtr /*pBox*/);

a180 8
typedef    void (* PaintWindowProcPtr)(
	WindowPtr /*pWindow*/,
	RegionPtr /*pRegion*/,
	int /*what*/);

typedef PaintWindowProcPtr PaintWindowBackgroundProcPtr;
typedef PaintWindowProcPtr PaintWindowBorderProcPtr;

d399 1
a399 1
typedef    void (* ConfigNotifyProcPtr)(
d436 2
a437 1
	WindowPtr /*pWin*/);
d459 1
a459 1
    short		width, height;
a468 1
    unsigned long	rgf;	/* array of flags; she's -- HUNGARIAN */
d481 2
a490 1
    PointerNonInterestBoxProcPtr PointerNonInterestBox;
a503 2
    PaintWindowBackgroundProcPtr PaintWindowBackground; /** unused */
    PaintWindowBorderProcPtr	PaintWindowBorder; /** unused */
d606 4
a617 1
    int		arraySize;
a619 1
    int		unused;
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d402 9
d593 1
d624 1
a624 1
extern ScreenInfo screenInfo;
d626 1
a626 1
extern void InitOutput(
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d125 1
d270 1
d275 1
d282 1
d287 1
d292 1
d297 1
d303 1
a428 1
#ifdef SHAPE
a430 1
#endif /* SHAPE */
d441 8
a589 1
#ifdef SHAPE
a590 1
#endif /* SHAPE */
d595 3
d611 1
a611 1
    int		numVideoScreens;
@


1.1
log
@Initial revision
@
text
@d59 1
d201 7
d212 2
a213 1
	int /*depth*/);
a460 6
    int			WindowPrivateLen;
    unsigned		*WindowPrivateSizes;
    unsigned		totalWindowSize;
    int			GCPrivateLen;
    unsigned		*GCPrivateSizes;
    unsigned		totalGCSize;
d483 2
a484 2
    PaintWindowBackgroundProcPtr PaintWindowBackground;
    PaintWindowBorderProcPtr	PaintWindowBorder;
d552 1
a552 1
    DevUnion	*devPrivates;
a563 3
#ifdef PIXPRIV
    int			PixmapPrivateLen;
    unsigned int		*PixmapPrivateSizes;
a564 1
#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d561 1
d565 1
@

