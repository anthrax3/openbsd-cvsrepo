head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.6
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	s0SI41sEunLdyFfd;

1.12
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	cVXoV5PxI8YrEaVA;

1.11
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.12.08.10.53.01;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.01.31.07.52.36;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.18;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.18;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.10;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/***********************************************************
Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#ifndef DIXSTRUCT_H
#define DIXSTRUCT_H

#include "client.h"
#include "dix.h"
#include "resource.h"
#include "cursor.h"
#include "gc.h"
#include "pixmap.h"
#include "privates.h"
#include <X11/Xmd.h>

/*
 * 	direct-mapped hash table, used by resource manager to store
 *      translation from client ids to server addresses.
 */

extern _X_EXPORT CallbackListPtr ClientStateCallback;

typedef struct {
    ClientPtr client;
    xConnSetupPrefix *prefix;
    xConnSetup *setup;
} NewClientInfoRec;

typedef void (*ReplySwapPtr) (ClientPtr /* pClient */ ,
                              int /* size */ ,
                              void * /* pbuf */ );

extern _X_EXPORT void
ReplyNotSwappd(ClientPtr /* pClient */ ,
               int /* size */ ,
               void * /* pbuf */ ) _X_NORETURN;

typedef enum { ClientStateInitial,
    ClientStateRunning,
    ClientStateRetained,
    ClientStateGone
} ClientState;

typedef struct _saveSet {
    struct _Window *windowPtr;
    Bool toRoot;
    Bool map;
} SaveSetElt;
#define SaveSetWindow(ss)   ((ss).windowPtr)
#define SaveSetToRoot(ss)   ((ss).toRoot)
#define SaveSetShouldMap(ss)	    ((ss).map)
#define SaveSetAssignWindow(ss,w)   ((ss).windowPtr = (w))
#define SaveSetAssignToRoot(ss,tr)  ((ss).toRoot = (tr))
#define SaveSetAssignMap(ss,m)      ((ss).map = (m))

typedef struct _Client {
    void *requestBuffer;
    void *osPrivate;             /* for OS layer, including scheduler */
    Mask clientAsMask;
    short index;
    unsigned char majorOp, minorOp;
    unsigned int swapped:1;
    unsigned int local:1;
    unsigned int big_requests:1; /* supports large requests */
    unsigned int clientGone:1;
    unsigned int closeDownMode:2;
    unsigned int clientState:2;
    signed char smart_priority;
    short noClientException;      /* this client died or needs to be killed */
    int priority;
    ReplySwapPtr pSwapReplyFunc;
    XID errorValue;
    int sequence;
    int ignoreCount;            /* count for Attend/IgnoreClient */
    int numSaved;
    SaveSetElt *saveSet;
    int (**requestVector) (ClientPtr /* pClient */ );
    CARD32 req_len;             /* length of current request */
    unsigned int replyBytesRemaining;
    PrivateRec *devPrivates;
    unsigned short xkbClientFlags;
    unsigned short mapNotifyMask;
    unsigned short newKeyboardNotifyMask;
    unsigned short vMajor, vMinor;
    KeyCode minKC, maxKC;

    int smart_start_tick;
    int smart_stop_tick;

    DeviceIntPtr clientPtr;
    ClientIdPtr clientIds;
#if XTRANS_SEND_FDS
    int req_fds;
#endif
} ClientRec;

#if XTRANS_SEND_FDS
static inline void
SetReqFds(ClientPtr client, int req_fds) {
    if (client->req_fds != 0 && req_fds != client->req_fds)
        LogMessage(X_ERROR, "Mismatching number of request fds %d != %d\n", req_fds, client->req_fds);
    client->req_fds = req_fds;
}
#endif

/*
 * Scheduling interface
 */
extern long SmartScheduleTime;
extern long SmartScheduleInterval;
extern long SmartScheduleSlice;
extern long SmartScheduleMaxSlice;
extern Bool SmartScheduleDisable;
extern void SmartScheduleStartTimer(void);
extern void SmartScheduleStopTimer(void);

#define SMART_MAX_PRIORITY  (20)
#define SMART_MIN_PRIORITY  (-20)

extern void SmartScheduleInit(void);

/* This prototype is used pervasively in Xext, dix */
#define DISPATCH_PROC(func) int func(ClientPtr /* client */)

typedef struct _WorkQueue {
    struct _WorkQueue *next;
    Bool (*function) (ClientPtr /* pClient */ ,
                      void *    /* closure */
        );
    ClientPtr client;
    void *closure;
} WorkQueueRec;

extern _X_EXPORT TimeStamp currentTime;

extern _X_EXPORT int
CompareTimeStamps(TimeStamp /*a */ ,
                  TimeStamp /*b */ );

extern _X_EXPORT TimeStamp
ClientTimeToServerTime(CARD32 /*c */ );

typedef struct _CallbackRec {
    CallbackProcPtr proc;
    void *data;
    Bool deleted;
    struct _CallbackRec *next;
} CallbackRec, *CallbackPtr;

typedef struct _CallbackList {
    int inCallback;
    Bool deleted;
    int numDeleted;
    CallbackPtr list;
} CallbackListRec;

/* proc vectors */

extern int (*InitialVector[3]) (ClientPtr /*client */ );

extern _X_EXPORT int (*ProcVector[256]) (ClientPtr /*client */ );

extern _X_EXPORT int (*SwappedProcVector[256]) (ClientPtr /*client */ );

extern ReplySwapPtr ReplySwapVector[256];

extern _X_EXPORT int
ProcBadRequest(ClientPtr /*client */ );

#endif                          /* DIXSTRUCT_H */
@


1.12
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d129 7
a135 9
extern _X_EXPORT long SmartScheduleTime;
extern _X_EXPORT long SmartScheduleInterval;
extern _X_EXPORT long SmartScheduleSlice;
extern _X_EXPORT long SmartScheduleMaxSlice;
extern _X_EXPORT Bool SmartScheduleDisable;
extern _X_EXPORT void
SmartScheduleStartTimer(void);
extern _X_EXPORT void
SmartScheduleStopTimer(void);
d140 1
a140 2
extern _X_EXPORT void
SmartScheduleInit(void);
d179 1
a179 1
extern _X_EXPORT int (*InitialVector[3]) (ClientPtr /*client */ );
d185 1
a185 1
extern _X_EXPORT ReplySwapPtr ReplySwapVector[256];
@


1.11
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d77 2
a78 2
    pointer requestBuffer;
    pointer osPrivate;          /* for OS layer, including scheduler */
a108 1
    int smart_check_tick;
d151 1
a151 1
                      pointer   /* closure */
d154 1
a154 1
    pointer closure;
d168 1
a168 1
    pointer data;
@


1.10
log
@Update to xserver 1.14.4
@
text
@a63 1
#ifdef XFIXES
a74 10
#else
typedef struct _Window *SaveSetElt;

#define SaveSetWindow(ss)   (ss)
#define SaveSetToRoot(ss)   FALSE
#define SaveSetShouldMap(ss)	    TRUE
#define SaveSetAssignWindow(ss,w)   ((ss) = (w))
#define SaveSetAssignToRoot(ss,tr)
#define SaveSetAssignMap(ss,m)
#endif
d113 3
d117 9
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a157 1
extern _X_EXPORT TimeStamp lastDeviceEventTime[MAXDEVICES];
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d59 1
a59 2
    /* 1 is unused now, was ClientStateAuthenticating */
    ClientStateRunning = 2,
a87 2
    int index;
    Mask clientAsMask;
d90 12
a101 1
    Bool swapped;
a104 4
    int closeDownMode;
    int clientGone;
    int noClientException;      /* this client died or needs to be
                                 * killed */
d106 1
a107 1
    int numSaved;
d110 1
a110 3
    Bool big_requests;          /* supports large requests */
    int priority;
    ClientState clientState;
d118 3
a120 5
    unsigned long replyBytesRemaining;
    int smart_priority;
    long smart_start_tick;
    long smart_stop_tick;
    long smart_check_tick;
a123 1
    unsigned short majorOp, minorOp;
d158 1
a158 1
extern _X_EXPORT TimeStamp lastDeviceEventTime;
@


1.7
log
@Update to xserver 1.11.4. tested by krw@@, shadchin@@.
@
text
@d44 3
a46 3
    ClientPtr 		client;
    xConnSetupPrefix 	*prefix; 
    xConnSetup  	*setup;
d49 15
a63 17
typedef void (*ReplySwapPtr) (
		ClientPtr	/* pClient */,
		int		/* size */,
		void *		/* pbuf */);

extern _X_EXPORT void ReplyNotSwappd (
		ClientPtr	/* pClient */,
		int		/* size */,
		void *		/* pbuf */) _X_NORETURN;

typedef enum {ClientStateInitial,
	      ClientStateAuthenticating,
	      ClientStateRunning,
	      ClientStateRetained,
	      ClientStateGone,
	      ClientStateCheckingSecurity,
	      ClientStateCheckedSecurity} ClientState;
d67 3
a69 3
    struct _Window  *windowPtr;
    Bool	    toRoot;
    Bool	    map;
d79 1
d89 5
a93 5
    int         index;
    Mask        clientAsMask;
    pointer     requestBuffer;
    pointer     osPrivate;	/* for OS layer, including scheduler */
    Bool        swapped;
d95 13
a107 14
    XID         errorValue;
    int         sequence;
    int         closeDownMode;
    int         clientGone;
    int         noClientException;	/* this client died or needs to be
					 * killed */
    int         ignoreCount;		/* count for Attend/IgnoreClient */
    SaveSetElt	*saveSet;
    int         numSaved;
    int         (**requestVector) (
		ClientPtr /* pClient */);
    CARD32	req_len;		/* length of current request */
    Bool	big_requests;		/* supports large requests */
    int		priority;
d109 6
a114 6
    PrivateRec	*devPrivates;
    unsigned short	xkbClientFlags;
    unsigned short	mapNotifyMask;
    unsigned short	newKeyboardNotifyMask;
    unsigned short	vMajor,vMinor;
    KeyCode		minKC,maxKC;
d117 5
a121 5
    int	    smart_priority;
    long    smart_start_tick;
    long    smart_stop_tick;
    long    smart_check_tick;
    
d123 1
a123 1
    ClientIdPtr  clientIds;
d125 1
a125 1
}           ClientRec;
d135 5
a139 2
extern _X_EXPORT void SmartScheduleStartTimer(void);
extern _X_EXPORT void SmartScheduleStopTimer(void);
d143 2
a144 2
extern _X_EXPORT void SmartScheduleInit(void);

d151 6
a156 7
    Bool        (*function) (
		ClientPtr	/* pClient */,
		pointer		/* closure */
);
    ClientPtr   client;
    pointer     closure;
}           WorkQueueRec;
d161 3
a163 3
extern _X_EXPORT int CompareTimeStamps(
    TimeStamp /*a*/,
    TimeStamp /*b*/);
d165 2
a166 1
extern _X_EXPORT TimeStamp ClientTimeToServerTime(CARD32 /*c*/);
d169 4
a172 4
  CallbackProcPtr proc;
  pointer data;
  Bool deleted;
  struct _CallbackRec *next;
d176 4
a179 4
  int inCallback;
  Bool deleted;
  int numDeleted;
  CallbackPtr list;
d184 1
a184 1
extern _X_EXPORT int (* InitialVector[3]) (ClientPtr /*client*/);
d186 1
a186 1
extern _X_EXPORT int (* ProcVector[256]) (ClientPtr /*client*/);
d188 1
a188 1
extern _X_EXPORT int (* SwappedProcVector[256]) (ClientPtr /*client*/);
d192 2
a193 1
extern _X_EXPORT int ProcBadRequest(ClientPtr /*client*/);
d195 1
a195 1
#endif				/* DIXSTRUCT_H */
@


1.6
log
@Update to xserver 1.11.2
@
text
@d126 1
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d27 1
d125 1
d141 1
a141 1
extern _X_EXPORT Bool SmartScheduleInit(void);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d56 1
a56 1
		void *		/* pbuf */);
a87 1
/* The unused_ members are ABI spacing.  Please reuse them. */
d101 1
a103 1
    void	*unused_screenPrivate[16];
a117 2
    void *unused_appgroup;
    void *unused_fontResFunc;
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d40 1
a40 5
#ifdef DEBUG
#define MAX_REQUEST_LOG 100
#endif

extern CallbackListPtr ClientStateCallback;
d53 1
a53 1
extern void ReplyNotSwappd (
d88 1
d104 1
a104 1
    pointer     screenPrivate[MAXSCREENS];
a111 1
#ifdef XKB
a116 1
#endif
a117 4
#ifdef DEBUG
    unsigned char requestLog[MAX_REQUEST_LOG];
    int         requestLogIndex;
#endif
d119 2
a120 4
    void *appgroup; /* Can't remove, ABI */
    struct _FontResolution * (*fontResFunc) (    /* no need for font.h */
		ClientPtr	/* pClient */,
		int *		/* num */);
d132 7
a138 7
extern long SmartScheduleTime;
extern long SmartScheduleInterval;
extern long SmartScheduleSlice;
extern long SmartScheduleMaxSlice;
extern Bool SmartScheduleDisable;
extern void SmartScheduleStartTimer(void);
extern void SmartScheduleStopTimer(void);
d142 1
a142 1
extern Bool SmartScheduleInit(void);
d158 2
a159 2
extern TimeStamp currentTime;
extern TimeStamp lastDeviceEventTime;
d161 1
a161 1
extern int CompareTimeStamps(
d165 1
a165 1
extern TimeStamp ClientTimeToServerTime(CARD32 /*c*/);
d183 1
a183 1
extern int (* InitialVector[3]) (ClientPtr /*client*/);
d185 1
a185 1
extern int (* ProcVector[256]) (ClientPtr /*client*/);
d187 1
a187 1
extern int (* SwappedProcVector[256]) (ClientPtr /*client*/);
d189 1
a189 1
extern ReplySwapPtr ReplySwapVector[256];
d191 1
a191 1
extern int ProcBadRequest(ClientPtr /*client*/);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d74 1
a74 1
    Bool	    remap;
d78 1
a78 1
#define SaveSetRemap(ss)    ((ss).remap)
d81 1
a81 1
#define SaveSetAssignRemap(ss,rm)  ((ss).remap = (rm))
d86 1
a86 1
#define SaveSetRemap(ss)    TRUE
d89 1
a89 1
#define SaveSetAssignRemap(ss,rm)
d128 1
a128 3
#ifdef XAPPGROUP
    struct _AppGroupRec*	appgroup;
#endif
a131 1
#ifdef SMART_SCHEDULE
d136 2
a137 1
#endif
a139 1
#ifdef SMART_SCHEDULE
a154 1
#endif
@


1.1
log
@Initial revision
@
text
@d32 1
a104 4
    DrawablePtr lastDrawable;
    Drawable    lastDrawableID;
    GCPtr       lastGC;
    GContext    lastGCID;
d114 1
a114 1
    DevUnion	*devPrivates;
a149 1
extern unsigned long SmartScheduleIdleCount;
d151 2
a152 3
extern Bool SmartScheduleIdle;
extern Bool SmartScheduleTimerStopped;
extern Bool SmartScheduleStartTimer(void);
a189 1
  CallbackFuncsRec funcs;
a202 4

#ifdef K5AUTH
extern int (*k5_Vector[256])(ClientPtr /*client*/);
#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d210 4
@

