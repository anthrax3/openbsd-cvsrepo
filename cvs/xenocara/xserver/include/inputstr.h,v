head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.6
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	Te1daavkBLskZ8gc;

1.12
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	cVXoV5PxI8YrEaVA;

1.11
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.09.28.15.36.35;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.21.20.10.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.17;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.17;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.10;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/************************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

#ifndef INPUTSTRUCT_H
#define INPUTSTRUCT_H

#include <X11/extensions/XI2proto.h>

#include <pixman.h>
#include "input.h"
#include "window.h"
#include "dixstruct.h"
#include "cursorstr.h"
#include "geext.h"
#include "privates.h"

#define BitIsOn(ptr, bit) (!!(((const BYTE *) (ptr))[(bit)>>3] & (1 << ((bit) & 7))))
#define SetBit(ptr, bit)  (((BYTE *) (ptr))[(bit)>>3] |= (1 << ((bit) & 7)))
#define ClearBit(ptr, bit) (((BYTE *)(ptr))[(bit)>>3] &= ~(1 << ((bit) & 7)))
extern _X_EXPORT int CountBits(const uint8_t * mask, int len);

#define SameClient(obj,client) \
	(CLIENT_BITS((obj)->resource) == (client)->clientAsMask)

#define EMASKSIZE	(MAXDEVICES + 2)

/* This is the last XI2 event supported by the server. If you add
 * events to the protocol, the server will not support these events until
 * this number here is bumped.
 */
#define XI2LASTEVENT    XI_BarrierLeave
#define XI2MASKSIZE     ((XI2LASTEVENT >> 3) + 1)       /* no of bytes for masks */

/**
 * Scroll types for ::SetScrollValuator and the scroll type in the
 * ::ScrollInfoPtr.
 */
enum ScrollType {
    SCROLL_TYPE_NONE = 0,           /**< Not a scrolling valuator */
    SCROLL_TYPE_VERTICAL = 8,
    SCROLL_TYPE_HORIZONTAL = 9,
};

/**
 * This struct stores the core event mask for each client except the client
 * that created the window.
 *
 * Each window that has events selected from other clients has at least one of
 * these masks. If multiple clients selected for events on the same window,
 * these masks are in a linked list.
 *
 * The event mask for the client that created the window is stored in
 * win->eventMask instead.
 *
 * The resource id is simply a fake client ID to associate this mask with a
 * client.
 *
 * Kludge: OtherClients and InputClients must be compatible, see code.
 */
typedef struct _OtherClients {
    OtherClientsPtr next;     /**< Pointer to the next mask */
    XID resource;                 /**< id for putting into resource manager */
    Mask mask;                /**< Core event mask */
} OtherClients;

/**
 * This struct stores the XI event mask for each client.
 *
 * Each window that has events selected has at least one of these masks. If
 * multiple client selected for events on the same window, these masks are in
 * a linked list.
 */
typedef struct _InputClients {
    InputClientsPtr next;     /**< Pointer to the next mask */
    XID resource;                 /**< id for putting into resource manager */
    Mask mask[EMASKSIZE];                /**< Actual XI event mask, deviceid is index */
    /** XI2 event masks. One per device, each bit is a mask of (1 << type) */
    struct _XI2Mask *xi2mask;
} InputClients;

/**
 * Combined XI event masks from all devices.
 *
 * This is the XI equivalent of the deliverableEvents, eventMask and
 * dontPropagate mask of the WindowRec (or WindowOptRec).
 *
 * A window that has an XI client selecting for events has exactly one
 * OtherInputMasks struct and exactly one InputClients struct hanging off
 * inputClients. Each further client appends to the inputClients list.
 * Each Mask field is per-device, with the device id as the index.
 * Exception: for non-device events (Presence events), the MAXDEVICES
 * deviceid is used.
 */
typedef struct _OtherInputMasks {
    /**
     * Bitwise OR of all masks by all clients and the window's parent's masks.
     */
    Mask deliverableEvents[EMASKSIZE];
    /**
     * Bitwise OR of all masks by all clients on this window.
     */
    Mask inputEvents[EMASKSIZE];
    /** The do-not-propagate masks for each device. */
    Mask dontPropagateMask[EMASKSIZE];
    /** The clients that selected for events */
    InputClientsPtr inputClients;
    /* XI2 event masks. One per device, each bit is a mask of (1 << type) */
    struct _XI2Mask *xi2mask;
} OtherInputMasks;

/*
 * The following structure gets used for both active and passive grabs. For
 * active grabs some of the fields (e.g. modifiers) are not used. However,
 * that is not much waste since there aren't many active grabs (one per
 * keyboard/pointer device) going at once in the server.
 */

#define MasksPerDetailMask 8    /* 256 keycodes and 256 possible
                                   modifier combinations, but only
                                   3 buttons. */

typedef struct _DetailRec {     /* Grab details may be bit masks */
    unsigned int exact;
    Mask *pMask;
} DetailRec;

union _GrabMask {
    Mask core;
    Mask xi;
    struct _XI2Mask *xi2mask;
};

/**
 * Central struct for device grabs.
 * The same struct is used for both core grabs and device grabs, with
 * different fields being set.
 * If the grab is a core grab (GrabPointer/GrabKeyboard), then the eventMask
 * is a combination of standard event masks (i.e. PointerMotionMask |
 * ButtonPressMask).
 * If the grab is a device grab (GrabDevice), then the eventMask is a
 * combination of event masks for a given XI event type (see SetEventInfo).
 *
 * If the grab is a result of a ButtonPress, then eventMask is the core mask
 * and deviceMask is set to the XI event mask for the grab.
 */
typedef struct _GrabRec {
    GrabPtr next;               /* for chain of passive grabs */
    XID resource;
    DeviceIntPtr device;
    WindowPtr window;
    unsigned ownerEvents:1;
    unsigned keyboardMode:1;
    unsigned pointerMode:1;
    enum InputLevel grabtype;
    CARD8 type;                 /* event type for passive grabs, 0 for active grabs */
    DetailRec modifiersDetail;
    DeviceIntPtr modifierDevice;
    DetailRec detail;           /* key or button */
    WindowPtr confineTo;        /* always NULL for keyboards */
    CursorPtr cursor;           /* always NULL for keyboards */
    Mask eventMask;
    Mask deviceMask;
    /* XI2 event masks. One per device, each bit is a mask of (1 << type) */
    struct _XI2Mask *xi2mask;
} GrabRec;

/**
 * Sprite information for a device.
 */
typedef struct _SpriteRec {
    CursorPtr current;
    BoxRec hotLimits;           /* logical constraints of hot spot */
    Bool confined;              /* confined to screen */
    RegionPtr hotShape;         /* additional logical shape constraint */
    BoxRec physLimits;          /* physical constraints of hot spot */
    WindowPtr win;              /* window of logical position */
    HotSpot hot;                /* logical pointer position */
    HotSpot hotPhys;            /* physical pointer position */
#ifdef PANORAMIX
    ScreenPtr screen;           /* all others are in Screen 0 coordinates */
    RegionRec Reg1;             /* Region 1 for confining motion */
    RegionRec Reg2;             /* Region 2 for confining virtual motion */
    WindowPtr windows[MAXSCREENS];
    WindowPtr confineWin;       /* confine window */
#endif
    /* The window trace information is used at dix/events.c to avoid having
     * to compute all the windows between the root and the current pointer
     * window each time a button or key goes down. The grabs on each of those
     * windows must be checked.
     * spriteTraces should only be used at dix/events.c! */
    WindowPtr *spriteTrace;
    int spriteTraceSize;
    int spriteTraceGood;

    /* Due to delays between event generation and event processing, it is
     * possible that the pointer has crossed screen boundaries between the
     * time in which it begins generating events and the time when
     * those events are processed.
     *
     * pEnqueueScreen: screen the pointer was on when the event was generated
     * pDequeueScreen: screen the pointer was on when the event is processed
     */
    ScreenPtr pEnqueueScreen;
    ScreenPtr pDequeueScreen;

} SpriteRec;

typedef struct _KeyClassRec {
    int sourceid;
    CARD8 down[DOWN_LENGTH];
    CARD8 postdown[DOWN_LENGTH];
    int modifierKeyCount[8];
    struct _XkbSrvInfo *xkbInfo;
} KeyClassRec, *KeyClassPtr;

typedef struct _ScrollInfo {
    enum ScrollType type;
    double increment;
    int flags;
} ScrollInfo, *ScrollInfoPtr;

typedef struct _AxisInfo {
    int resolution;
    int min_resolution;
    int max_resolution;
    int min_value;
    int max_value;
    Atom label;
    CARD8 mode;
    ScrollInfo scroll;
} AxisInfo, *AxisInfoPtr;

typedef struct _ValuatorAccelerationRec {
    int number;
    PointerAccelSchemeProc AccelSchemeProc;
    void *accelData;            /* at disposal of AccelScheme */
    PointerAccelSchemeInitProc AccelInitProc;
    DeviceCallbackProc AccelCleanupProc;
} ValuatorAccelerationRec, *ValuatorAccelerationPtr;

typedef struct _ValuatorClassRec {
    int sourceid;
    int numMotionEvents;
    int first_motion;
    int last_motion;
    void *motion;               /* motion history buffer. Different layout
                                   for MDs and SDs! */
    WindowPtr motionHintWindow;

    AxisInfoPtr axes;
    unsigned short numAxes;
    double *axisVal;            /* always absolute, but device-coord system */
    ValuatorAccelerationRec accelScheme;
    int h_scroll_axis;          /* horiz smooth-scrolling axis */
    int v_scroll_axis;          /* vert smooth-scrolling axis */
} ValuatorClassRec;

typedef struct _TouchListener {
    XID listener;           /* grabs/event selection IDs receiving
                             * events for this touch */
    int resource_type;      /* listener's resource type */
    enum TouchListenerType type;
    enum TouchListenerState state;
    enum InputLevel level;  /* matters only for emulating touches */
    WindowPtr window;
    GrabPtr grab;
} TouchListener;

typedef struct _TouchPointInfo {
    uint32_t client_id;         /* touch ID as seen in client events */
    int sourceid;               /* Source device's ID for this touchpoint */
    Bool active;                /* whether or not the touch is active */
    Bool pending_finish;        /* true if the touch is physically inactive
                                 * but still owned by a grab */
    SpriteRec sprite;           /* window trace for delivery */
    ValuatorMask *valuators;    /* last recorded axis values */
    TouchListener *listeners;   /* set of listeners */
    int num_listeners;
    int num_grabs;              /* number of open grabs on this touch
                                 * which have not accepted or rejected */
    Bool emulate_pointer;
    DeviceEvent *history;       /* History of events on this touchpoint */
    size_t history_elements;    /* Number of current elements in history */
    size_t history_size;        /* Size of history in elements */
} TouchPointInfoRec;

typedef struct _DDXTouchPointInfo {
    uint32_t client_id;         /* touch ID as seen in client events */
    Bool active;                /* whether or not the touch is active */
    uint32_t ddx_id;            /* touch ID given by the DDX */
    Bool emulate_pointer;

    ValuatorMask *valuators;    /* last axis values as posted, pre-transform */
} DDXTouchPointInfoRec;

typedef struct _TouchClassRec {
    int sourceid;
    TouchPointInfoPtr touches;
    unsigned short num_touches; /* number of allocated touches */
    unsigned short max_touches; /* maximum number of touches, may be 0 */
    CARD8 mode;                 /* ::XIDirectTouch, XIDependentTouch */
    /* for pointer-emulation */
    CARD8 buttonsDown;          /* number of buttons down */
    unsigned short state;       /* logical button state */
    Mask motionMask;
} TouchClassRec;

typedef struct _ButtonClassRec {
    int sourceid;
    CARD8 numButtons;
    CARD8 buttonsDown;          /* number of buttons currently down
                                   This counts logical buttons, not
                                   physical ones, i.e if some buttons
                                   are mapped to 0, they're not counted
                                   here */
    unsigned short state;
    Mask motionMask;
    CARD8 down[DOWN_LENGTH];
    CARD8 postdown[DOWN_LENGTH];
    CARD8 map[MAP_LENGTH];
    union _XkbAction *xkb_acts;
    Atom labels[MAX_BUTTONS];
} ButtonClassRec, *ButtonClassPtr;

typedef struct _FocusClassRec {
    int sourceid;
    WindowPtr win;              /* May be set to a int constant (e.g. PointerRootWin)! */
    int revert;
    TimeStamp time;
    WindowPtr *trace;
    int traceSize;
    int traceGood;
} FocusClassRec, *FocusClassPtr;

typedef struct _ProximityClassRec {
    int sourceid;
    char in_proximity;
} ProximityClassRec, *ProximityClassPtr;

typedef struct _KbdFeedbackClassRec *KbdFeedbackPtr;
typedef struct _PtrFeedbackClassRec *PtrFeedbackPtr;
typedef struct _IntegerFeedbackClassRec *IntegerFeedbackPtr;
typedef struct _StringFeedbackClassRec *StringFeedbackPtr;
typedef struct _BellFeedbackClassRec *BellFeedbackPtr;
typedef struct _LedFeedbackClassRec *LedFeedbackPtr;

typedef struct _KbdFeedbackClassRec {
    BellProcPtr BellProc;
    KbdCtrlProcPtr CtrlProc;
    KeybdCtrl ctrl;
    KbdFeedbackPtr next;
    struct _XkbSrvLedInfo *xkb_sli;
} KbdFeedbackClassRec;

typedef struct _PtrFeedbackClassRec {
    PtrCtrlProcPtr CtrlProc;
    PtrCtrl ctrl;
    PtrFeedbackPtr next;
} PtrFeedbackClassRec;

typedef struct _IntegerFeedbackClassRec {
    IntegerCtrlProcPtr CtrlProc;
    IntegerCtrl ctrl;
    IntegerFeedbackPtr next;
} IntegerFeedbackClassRec;

typedef struct _StringFeedbackClassRec {
    StringCtrlProcPtr CtrlProc;
    StringCtrl ctrl;
    StringFeedbackPtr next;
} StringFeedbackClassRec;

typedef struct _BellFeedbackClassRec {
    BellProcPtr BellProc;
    BellCtrlProcPtr CtrlProc;
    BellCtrl ctrl;
    BellFeedbackPtr next;
} BellFeedbackClassRec;

typedef struct _LedFeedbackClassRec {
    LedCtrlProcPtr CtrlProc;
    LedCtrl ctrl;
    LedFeedbackPtr next;
    struct _XkbSrvLedInfo *xkb_sli;
} LedFeedbackClassRec;

typedef struct _ClassesRec {
    KeyClassPtr key;
    ValuatorClassPtr valuator;
    TouchClassPtr touch;
    ButtonClassPtr button;
    FocusClassPtr focus;
    ProximityClassPtr proximity;
    KbdFeedbackPtr kbdfeed;
    PtrFeedbackPtr ptrfeed;
    IntegerFeedbackPtr intfeed;
    StringFeedbackPtr stringfeed;
    BellFeedbackPtr bell;
    LedFeedbackPtr leds;
} ClassesRec;

/* Device properties */
typedef struct _XIPropertyValue {
    Atom type;                  /* ignored by server */
    short format;               /* format of data for swapping - 8,16,32 */
    long size;                  /* size of data in (format/8) bytes */
    void *data;                 /* private to client */
} XIPropertyValueRec;

typedef struct _XIProperty {
    struct _XIProperty *next;
    Atom propertyName;
    BOOL deletable;             /* clients can delete this prop? */
    XIPropertyValueRec value;
} XIPropertyRec;

typedef XIPropertyRec *XIPropertyPtr;
typedef XIPropertyValueRec *XIPropertyValuePtr;

typedef struct _XIPropertyHandler {
    struct _XIPropertyHandler *next;
    long id;
    int (*SetProperty) (DeviceIntPtr dev,
                        Atom property, XIPropertyValuePtr prop, BOOL checkonly);
    int (*GetProperty) (DeviceIntPtr dev, Atom property);
    int (*DeleteProperty) (DeviceIntPtr dev, Atom property);
} XIPropertyHandler, *XIPropertyHandlerPtr;

/* states for devices */

#define NOT_GRABBED		0
#define THAWED			1
#define THAWED_BOTH		2       /* not a real state */
#define FREEZE_NEXT_EVENT	3
#define FREEZE_BOTH_NEXT_EVENT	4
#define FROZEN			5       /* any state >= has device frozen */
#define FROZEN_NO_EVENT		5
#define FROZEN_WITH_EVENT	6
#define THAW_OTHERS		7

typedef struct _GrabInfoRec {
    TimeStamp grabTime;
    Bool fromPassiveGrab;       /* true if from passive grab */
    Bool implicitGrab;          /* implicit from ButtonPress */
    GrabPtr unused;             /* Kept for ABI stability, remove soon */
    GrabPtr grab;
    CARD8 activatingKey;
    void (*ActivateGrab) (DeviceIntPtr /*device */ ,
                          GrabPtr /*grab */ ,
                          TimeStamp /*time */ ,
                          Bool /*autoGrab */ );
    void (*DeactivateGrab) (DeviceIntPtr /*device */ );
    struct {
        Bool frozen;
        int state;
        GrabPtr other;          /* if other grab has this frozen */
        DeviceEvent *event;     /* saved to be replayed */
    } sync;
} GrabInfoRec, *GrabInfoPtr;

typedef struct _SpriteInfoRec {
    /* sprite must always point to a valid sprite. For devices sharing the
     * sprite, let sprite point to a paired spriteOwner's sprite. */
    SpritePtr sprite;           /* sprite information */
    Bool spriteOwner;           /* True if device owns the sprite */
    DeviceIntPtr paired;        /* The paired device. Keyboard if
                                   spriteOwner is TRUE, otherwise the
                                   pointer that owns the sprite. */

    /* keep states for animated cursor */
    struct {
        CursorPtr pCursor;
        ScreenPtr pScreen;
        int elt;
        CARD32 time;
    } anim;
} SpriteInfoRec, *SpriteInfoPtr;

/* device types */
#define MASTER_POINTER          1
#define MASTER_KEYBOARD         2
#define SLAVE                   3
/* special types for GetMaster */
#define MASTER_ATTACHED         4       /* Master for this device */
#define KEYBOARD_OR_FLOAT       5       /* Keyboard master for this device or this device if floating */
#define POINTER_OR_FLOAT        6       /* Pointer master for this device or this device if floating */

typedef struct _DeviceIntRec {
    DeviceRec public;
    DeviceIntPtr next;
    Bool startup;               /* true if needs to be turned on at
                                   server initialization time */
    DeviceProc deviceProc;      /* proc(DevicePtr, DEVICE_xx). It is
                                   used to initialize, turn on, or
                                   turn off the device */
    Bool inited;                /* TRUE if INIT returns Success */
    Bool enabled;               /* TRUE if ON returns Success */
    Bool coreEvents;            /* TRUE if device also sends core */
    GrabInfoRec deviceGrab;     /* grab on the device */
    int type;                   /* MASTER_POINTER, MASTER_KEYBOARD, SLAVE */
    Atom xinput_type;
    char *name;
    int id;
    KeyClassPtr key;
    ValuatorClassPtr valuator;
    TouchClassPtr touch;
    ButtonClassPtr button;
    FocusClassPtr focus;
    ProximityClassPtr proximity;
    KbdFeedbackPtr kbdfeed;
    PtrFeedbackPtr ptrfeed;
    IntegerFeedbackPtr intfeed;
    StringFeedbackPtr stringfeed;
    BellFeedbackPtr bell;
    LedFeedbackPtr leds;
    struct _XkbInterest *xkb_interest;
    char *config_info;          /* used by the hotplug layer */
    ClassesPtr unused_classes;  /* for master devices */
    int saved_master_id;        /* for slaves while grabbed */
    PrivateRec *devPrivates;
    DeviceUnwrapProc unwrapProc;
    SpriteInfoPtr spriteInfo;
    DeviceIntPtr master;        /* master device */
    DeviceIntPtr lastSlave;     /* last slave device used */

    /* last valuator values recorded, not posted to client;
     * for slave devices, valuators is in device coordinates, mapped to the
     * desktop
     * for master devices, valuators is in desktop coordinates.
     * see dix/getevents.c
     * remainder supports acceleration
     */
    struct {
        double valuators[MAX_VALUATORS];
        int numValuators;
        DeviceIntPtr slave;
        ValuatorMask *scroll;
        int num_touches;        /* size of the touches array */
        DDXTouchPointInfoPtr touches;
    } last;

    /* Input device property handling. */
    struct {
        XIPropertyPtr properties;
        XIPropertyHandlerPtr handlers;  /* NULL-terminated */
    } properties;

    /* coordinate transformation matrix for relative movement. Matrix with
     * the translation component dropped */
    struct pixman_f_transform relative_transform;
    /* scale matrix for absolute devices, this is the combined matrix of
       [1/scale] . [transform] . [scale]. See DeviceSetTransform */
    struct pixman_f_transform scale_and_transform;

    /* XTest related master device id */
    int xtest_master_id;

    struct _SyncCounter *idle_counter;
} DeviceIntRec;

typedef struct {
    int numDevices;             /* total number of devices */
    DeviceIntPtr devices;       /* all devices turned on */
    DeviceIntPtr off_devices;   /* all devices turned off */
    DeviceIntPtr keyboard;      /* the main one for the server */
    DeviceIntPtr pointer;
    DeviceIntPtr all_devices;
    DeviceIntPtr all_master_devices;
} InputInfo;

extern _X_EXPORT InputInfo inputInfo;

/* for keeping the events for devices grabbed synchronously */
typedef struct _QdEvent *QdEventPtr;
typedef struct _QdEvent {
    struct xorg_list next;
    DeviceIntPtr device;
    ScreenPtr pScreen;          /* what screen the pointer was on */
    unsigned long months;       /* milliseconds is in the event */
    InternalEvent *event;
} QdEventRec;

/**
 * syncEvents is the global structure for queued events.
 *
 * Devices can be frozen through GrabModeSync pointer grabs. If this is the
 * case, events from these devices are added to "pending" instead of being
 * processed normally. When the device is unfrozen, events in "pending" are
 * replayed and processed as if they would come from the device directly.
 */
typedef struct _EventSyncInfo {
    struct xorg_list pending;

    /** The device to replay events for. Only set in AllowEvents(), in which
     * case it is set to the device specified in the request. */
    DeviceIntPtr replayDev;     /* kludgy rock to put flag for */

    /**
     * The window the events are supposed to be replayed on.
     * This window may be set to the grab's window (but only when
     * Replay{Pointer|Keyboard} is given in the XAllowEvents()
     * request. */
    WindowPtr replayWin;        /*   ComputeFreezes            */
    /**
     * Flag to indicate whether we're in the process of
     * replaying events. Only set in ComputeFreezes(). */
    Bool playingEvents;
    TimeStamp time;
} EventSyncInfoRec, *EventSyncInfoPtr;

extern EventSyncInfoRec syncEvents;

/**
 * Given a sprite, returns the window at the bottom of the trace (i.e. the
 * furthest window from the root).
 */
static inline WindowPtr
DeepestSpriteWin(SpritePtr sprite)
{
    assert(sprite->spriteTraceGood > 0);
    return sprite->spriteTrace[sprite->spriteTraceGood - 1];
}

struct _XI2Mask {
    unsigned char **masks;      /* event mask in masks[deviceid][event type byte] */
    size_t nmasks;              /* number of masks */
    size_t mask_size;           /* size of each mask in bytes */
};

#endif                          /* INPUTSTRUCT_H */
@


1.12
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d29 2
a30 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d32 1
a32 1
both that copyright notice and this permission notice appear in 
d35 1
a35 1
software without specific, written prior permission.  
d162 1
a162 1
                                   modifier combinations, but only      
d177 1
a177 1
 * Central struct for device grabs. 
d179 1
a179 1
 * different fields being set. 
@


1.11
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d450 1
a450 1
    pointer data;               /* private to client */
@


1.10
log
@Update to xserver 1.14.3
@
text
@d68 1
a68 1
#define EMASKSIZE	MAXDEVICES + 2
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d198 1
a198 1
    CARD8 type;                 /* event type */
d488 1
a488 1
    GrabPtr activeGrab;
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d74 1
a74 1
#define XI2LASTEVENT    XI_RawTouchEnd
d301 11
d320 1
a320 8
    struct _TouchListener {
        XID listener;           /* grabs/event selection IDs receiving
                                 * events for this touch */
        enum TouchListenerType type;
        enum TouchListenerState state;
        enum InputLevel level;  /* matters only for emulating touches */
        WindowPtr window;
    } *listeners;
a329 2
typedef struct _TouchListener TouchListener;

d336 1
a336 1
    ValuatorMask *valuators;    /* last recorded axis values */
d591 6
a596 2
    /* coordinate transformation matrix for absolute input devices */
    struct pixman_f_transform transform;
d600 2
@


1.7
log
@Update to xserver 1.11.2
@
text
@a24 1

a46 1

d50 2
d60 1
a60 1
#define BitIsOn(ptr, bit) (!!(((BYTE *) (ptr))[(bit)>>3] & (1 << ((bit) & 7))))
d63 1
a63 1
extern _X_EXPORT int CountBits(const uint8_t *mask, int len);
d74 12
a85 2
#define XI2LASTEVENT    17 /* XI_RawMotion */
#define XI2MASKSIZE     ((XI2LASTEVENT + 7)/8) /* no of bits for masks */
d104 3
a106 3
    OtherClientsPtr	next; /**< Pointer to the next mask */
    XID			resource; /**< id for putting into resource manager */
    Mask		mask; /**< Core event mask */
d117 3
a119 3
    InputClientsPtr	next; /**< Pointer to the next mask */
    XID			resource; /**< id for putting into resource manager */
    Mask		mask[EMASKSIZE]; /**< Actual XI event mask, deviceid is index */
d121 1
a121 1
    unsigned char       xi2mask[EMASKSIZE][XI2MASKSIZE];
d141 1
a141 1
    Mask		deliverableEvents[EMASKSIZE];
d145 1
a145 1
    Mask		inputEvents[EMASKSIZE];
d147 1
a147 1
    Mask		dontPropagateMask[EMASKSIZE];
d149 1
a149 1
    InputClientsPtr	inputClients;
d151 1
a151 1
    unsigned char       xi2mask[EMASKSIZE][XI2MASKSIZE];
d161 7
a167 7
#define MasksPerDetailMask 8		/* 256 keycodes and 256 possible
                                           modifier combinations, but only	
                                           3 buttons. */

typedef struct _DetailRec {		/* Grab details may be bit masks */
    unsigned int        exact;
    Mask                *pMask;
a169 6
typedef enum {
    GRABTYPE_CORE,
    GRABTYPE_XI,
    GRABTYPE_XI2
} GrabType;

d173 1
a173 1
    char xi2mask[EMASKSIZE][XI2MASKSIZE];
d190 16
a205 16
    GrabPtr		next;		/* for chain of passive grabs */
    XID			resource;
    DeviceIntPtr	device;
    WindowPtr		window;
    unsigned		ownerEvents:1;
    unsigned		keyboardMode:1;
    unsigned		pointerMode:1;
    GrabType		grabtype;
    CARD8		type;		/* event type */
    DetailRec		modifiersDetail;
    DeviceIntPtr	modifierDevice;
    DetailRec		detail;		/* key or button */
    WindowPtr		confineTo;	/* always NULL for keyboards */
    CursorPtr		cursor;		/* always NULL for keyboards */
    Mask		eventMask;
    Mask                deviceMask;     
d207 1
a207 1
    unsigned char       xi2mask[EMASKSIZE][XI2MASKSIZE];
d214 8
a221 8
    CursorPtr	current;
    BoxRec	hotLimits;	/* logical constraints of hot spot */
    Bool	confined;	/* confined to screen */
    RegionPtr	hotShape;	/* additional logical shape constraint */
    BoxRec	physLimits;	/* physical constraints of hot spot */
    WindowPtr	win;		/* window of logical position */
    HotSpot	hot;		/* logical pointer position */
    HotSpot	hotPhys;	/* physical pointer position */
d223 5
a227 5
    ScreenPtr	screen;		/* all others are in Screen 0 coordinates */
    RegionRec   Reg1;	        /* Region 1 for confining motion */
    RegionRec   Reg2;		/* Region 2 for confining virtual motion */
    WindowPtr   windows[MAXSCREENS];
    WindowPtr	confineWin;	/* confine window */
d252 4
a255 4
    int			sourceid;
    CARD8		down[DOWN_LENGTH];
    CARD8		postdown[DOWN_LENGTH];
    int                 modifierKeyCount[8];
d259 6
d266 8
a273 7
    int		resolution;
    int		min_resolution;
    int		max_resolution;
    int		min_value;
    int		max_value;
    Atom	label;
    CARD8	mode;
d277 5
a281 5
    int                         number;
    PointerAccelSchemeProc      AccelSchemeProc;
    void                       *accelData; /* at disposal of AccelScheme */
    PointerAccelSchemeInitProc  AccelInitProc;
    DeviceCallbackProc          AccelCleanupProc;
d285 14
a298 12
    int                   sourceid;
    int		 	  numMotionEvents;
    int                   first_motion;
    int                   last_motion;
    void                  *motion; /* motion history buffer. Different layout
                                      for MDs and SDs!*/
    WindowPtr             motionHintWindow;

    AxisInfoPtr 	  axes;
    unsigned short	  numAxes;
    double		  *axisVal; /* always absolute, but device-coord system */
    ValuatorAccelerationRec	accelScheme;
d301 48
d350 14
a363 14
    int			sourceid;
    CARD8		numButtons;
    CARD8		buttonsDown;	/* number of buttons currently down
                                           This counts logical buttons, not
					   physical ones, i.e if some buttons
					   are mapped to 0, they're not counted
					   here */
    unsigned short	state;
    Mask		motionMask;
    CARD8		down[DOWN_LENGTH];
    CARD8		postdown[DOWN_LENGTH];
    CARD8		map[MAP_LENGTH];
    union _XkbAction    *xkb_acts;
    Atom		labels[MAX_BUTTONS];
d367 7
a373 7
    int		sourceid;
    WindowPtr	win; /* May be set to a int constant (e.g. PointerRootWin)! */
    int		revert;
    TimeStamp	time;
    WindowPtr	*trace;
    int		traceSize;
    int		traceGood;
d377 2
a378 2
    int		sourceid;
    char	in_proximity;
d389 4
a392 4
    BellProcPtr		BellProc;
    KbdCtrlProcPtr	CtrlProc;
    KeybdCtrl	 	ctrl;
    KbdFeedbackPtr	next;
d397 3
a399 3
    PtrCtrlProcPtr	CtrlProc;
    PtrCtrl		ctrl;
    PtrFeedbackPtr	next;
d403 3
a405 3
    IntegerCtrlProcPtr	CtrlProc;
    IntegerCtrl	 	ctrl;
    IntegerFeedbackPtr	next;
d409 3
a411 3
    StringCtrlProcPtr	CtrlProc;
    StringCtrl	 	ctrl;
    StringFeedbackPtr	next;
d415 4
a418 4
    BellProcPtr		BellProc;
    BellCtrlProcPtr	CtrlProc;
    BellCtrl	 	ctrl;
    BellFeedbackPtr	next;
d422 3
a424 3
    LedCtrlProcPtr	CtrlProc;
    LedCtrl	 	ctrl;
    LedFeedbackPtr	next;
a427 1

d429 12
a440 11
    KeyClassPtr		key;
    ValuatorClassPtr	valuator;
    ButtonClassPtr	button;
    FocusClassPtr	focus;
    ProximityClassPtr	proximity;
    KbdFeedbackPtr	kbdfeed;
    PtrFeedbackPtr	ptrfeed;
    IntegerFeedbackPtr	intfeed;
    StringFeedbackPtr	stringfeed;
    BellFeedbackPtr	bell;
    LedFeedbackPtr	leds;
a442 1

d444 5
a448 6
typedef struct _XIPropertyValue
{
    Atom                type;           /* ignored by server */
    short               format;         /* format of data for swapping - 8,16,32 */
    long                size;           /* size of data in (format/8) bytes */
    pointer             data;           /* private to client */
d451 5
a455 6
typedef struct _XIProperty
{
    struct _XIProperty   *next;
    Atom                  propertyName;
    BOOL                  deletable;    /* clients can delete this prop? */
    XIPropertyValueRec    value;
d458 1
a458 1
typedef XIPropertyRec      *XIPropertyPtr;
d461 2
a462 4

typedef struct _XIPropertyHandler
{
    struct _XIPropertyHandler* next;
d465 3
a467 7
                        Atom property,
                        XIPropertyValuePtr prop,
                        BOOL checkonly);
    int (*GetProperty) (DeviceIntPtr dev,
                        Atom property);
    int (*DeleteProperty) (DeviceIntPtr dev,
                           Atom property);
d474 1
a474 1
#define THAWED_BOTH		2	/* not a real state */
d477 1
a477 1
#define FROZEN			5	/* any state >= has device frozen */
a481 1

d483 11
a493 13
    TimeStamp	    grabTime;
    Bool            fromPassiveGrab;    /* true if from passive grab */
    Bool            implicitGrab;       /* implicit from ButtonPress */
    GrabRec         activeGrab;
    GrabPtr         grab;
    CARD8           activatingKey;
    void	    (*ActivateGrab) (
                    DeviceIntPtr /*device*/,
                    GrabPtr /*grab*/,
                    TimeStamp /*time*/,
                    Bool /*autoGrab*/);
    void	    (*DeactivateGrab)(
                    DeviceIntPtr /*device*/);
d495 4
a498 4
	Bool		frozen;
	int		state;
	GrabPtr		other;		/* if other grab has this frozen */
	DeviceEvent	*event;		/* saved to be replayed */
d505 5
a509 5
    SpritePtr           sprite;      /* sprite information */
    Bool                spriteOwner; /* True if device owns the sprite */
    DeviceIntPtr        paired;      /* The paired device. Keyboard if
                                        spriteOwner is TRUE, otherwise the
                                        pointer that owns the sprite. */ 
d513 4
a516 4
        CursorPtr       pCursor;
        ScreenPtr       pScreen;
        int             elt;
        CARD32          time;
d524 4
a527 1
#define MASTER_ATTACHED         4  /* special type for GetMaster */
d530 1
a530 1
    DeviceRec	public;
d532 25
a556 24
    Bool	startup;		/* true if needs to be turned on at
				          server intialization time */
    DeviceProc	deviceProc;		/* proc(DevicePtr, DEVICE_xx). It is
					  used to initialize, turn on, or
					  turn off the device */
    Bool	inited;			/* TRUE if INIT returns Success */
    Bool        enabled;                /* TRUE if ON returns Success */
    Bool        coreEvents;             /* TRUE if device also sends core */
    GrabInfoRec deviceGrab;             /* grab on the device */
    int         type;                   /* MASTER_POINTER, MASTER_KEYBOARD, SLAVE */
    Atom		xinput_type;
    char		*name;
    int			id;
    KeyClassPtr		key;
    ValuatorClassPtr	valuator;
    ButtonClassPtr	button;
    FocusClassPtr	focus;
    ProximityClassPtr	proximity;
    KbdFeedbackPtr	kbdfeed;
    PtrFeedbackPtr	ptrfeed;
    IntegerFeedbackPtr	intfeed;
    StringFeedbackPtr	stringfeed;
    BellFeedbackPtr	bell;
    LedFeedbackPtr	leds;
d558 8
a565 8
    char                *config_info; /* used by the hotplug layer */
    ClassesPtr		unused_classes; /* for master devices */
    int			saved_master_id;	/* for slaves while grabbed */
    PrivateRec		*devPrivates;
    DeviceUnwrapProc    unwrapProc;
    SpriteInfoPtr       spriteInfo;
    DeviceIntPtr        master;     /* master device */
    DeviceIntPtr        lastSlave;  /* last slave device used */
d568 3
a570 2
     * for slave devices, valuators is in device coordinates
     * for master devices, valuators is in screen coordinates
d575 6
a580 4
        int             valuators[MAX_VALUATORS];
        float           remainder[MAX_VALUATORS];
        int             numValuators;
        DeviceIntPtr    slave;
d585 2
a586 2
        XIPropertyPtr   properties;
        XIPropertyHandlerPtr handlers; /* NULL-terminated */
d597 7
a603 7
    int			numDevices;	/* total number of devices */
    DeviceIntPtr	devices;	/* all devices turned on */
    DeviceIntPtr	off_devices;	/* all devices turned off */
    DeviceIntPtr	keyboard;	/* the main one for the server */
    DeviceIntPtr	pointer;
    DeviceIntPtr	all_devices;
    DeviceIntPtr	all_master_devices;
d611 5
a615 5
    QdEventPtr		next;
    DeviceIntPtr	device;
    ScreenPtr		pScreen;	/* what screen the pointer was on */
    unsigned long	months;		/* milliseconds is in the event */
    InternalEvent	*event;
d627 2
a628 2
    QdEventPtr          pending, /**<  list of queued events */
                        *pendtail; /**< last event in list */
d631 1
a631 1
    DeviceIntPtr        replayDev;      /* kludgy rock to put flag for */
d638 1
a638 1
    WindowPtr           replayWin;      /*   ComputeFreezes            */
d642 2
a643 2
    Bool                playingEvents;
    TimeStamp           time;
d652 2
a653 1
static inline WindowPtr DeepestSpriteWin(SpritePtr sprite)
d659 7
a665 1
#endif /* INPUTSTRUCT_H */
@


1.6
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d63 1
d206 41
d262 1
d269 1
a284 1
    CARD8	 	  mode;
d286 1
a286 1
} ValuatorClassRec, *ValuatorClassPtr;
d317 1
a317 1
    char	pad;
a319 21
typedef struct _AbsoluteClassRec {
    int         sourceid;
    /* Calibration. */
    int         min_x;
    int         max_x;
    int         min_y;
    int         max_y;
    int         flip_x;
    int         flip_y;
    int		rotation;
    int         button_threshold;

    /* Area. */
    int         offset_x;
    int         offset_y;
    int         width;
    int         height;
    int         screen;
    XID		following;
} AbsoluteClassRec, *AbsoluteClassPtr;

a373 1
    AbsoluteClassPtr    absolute;
a382 41
/**
 * Sprite information for a device.
 */
typedef struct {
    CursorPtr	current;
    BoxRec	hotLimits;	/* logical constraints of hot spot */
    Bool	confined;	/* confined to screen */
    RegionPtr	hotShape;	/* additional logical shape constraint */
    BoxRec	physLimits;	/* physical constraints of hot spot */
    WindowPtr	win;		/* window of logical position */
    HotSpot	hot;		/* logical pointer position */
    HotSpot	hotPhys;	/* physical pointer position */
#ifdef PANORAMIX
    ScreenPtr	screen;		/* all others are in Screen 0 coordinates */
    RegionRec   Reg1;	        /* Region 1 for confining motion */
    RegionRec   Reg2;		/* Region 2 for confining virtual motion */
    WindowPtr   windows[MAXSCREENS];
    WindowPtr	confineWin;	/* confine window */ 
#endif
    /* The window trace information is used at dix/events.c to avoid having
     * to compute all the windows between the root and the current pointer
     * window each time a button or key goes down. The grabs on each of those
     * windows must be checked.
     * spriteTraces should only be used at dix/events.c! */
    WindowPtr *spriteTrace;
    int spriteTraceSize;
    int spriteTraceGood;

    /* Due to delays between event generation and event processing, it is
     * possible that the pointer has crossed screen boundaries between the
     * time in which it begins generating events and the time when
     * those events are processed.
     *
     * pEnqueueScreen: screen the pointer was on when the event was generated
     * pDequeueScreen: screen the pointer was on when the event is processed
     */
    ScreenPtr pEnqueueScreen;
    ScreenPtr pDequeueScreen;

} SpriteRec, *SpritePtr;

d475 1
a497 1
    AbsoluteClassPtr    absolute;
d511 2
a512 4
    union {
        DeviceIntPtr        master;     /* master device */
        DeviceIntPtr        lastSlave;  /* last slave device used */
    } u;
d591 10
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d60 1
a60 1
#define BitIsOn(ptr, bit) (((BYTE *) (ptr))[(bit)>>3] & (1 << ((bit) & 7)))
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d52 1
d481 8
d526 2
a528 1
    int			nPrivates;
d554 6
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d60 2
d66 1
a66 1
#define EMASKSIZE	MAXDEVICES + 1
d68 6
a73 3
extern DevPrivateKey CoreDevicePrivateKey;

/* Kludge: OtherClients and InputClients must be compatible, see code */
d75 16
d92 3
a94 3
    OtherClientsPtr	next;
    XID			resource; /* id for putting into resource manager */
    Mask		mask;
d97 7
d105 5
a109 3
    InputClientsPtr	next;
    XID			resource; /* id for putting into resource manager */
    Mask		mask[EMASKSIZE];
d112 13
d126 3
d130 3
d134 1
d136 1
d138 2
d154 1
a154 1
    unsigned short      exact;
d158 12
d191 1
a191 2
    unsigned		coreGrab:1;	/* grab is on core device */
    unsigned		coreMods:1;	/* modifiers are on core keyboard */
d200 2
a201 1
    GenericMaskPtr      genericMasks;
d205 1
d208 1
a208 8
    KeyCode 		*modifierKeyMap;
    KeySymsRec		curKeySyms;
    int			modifierKeyCount[8];
    CARD8		modifierMap[MAP_LENGTH];
    CARD8		maxKeysPerModifier;
    unsigned short	state;
    unsigned short	prev_state;
#ifdef XKB
a209 3
#else
    void               *pad0;
#endif
d218 1
d229 1
d239 1
a239 1
    int			  *axisVal; /* always absolute, but device-coord system */
d245 1
d255 1
a256 1
#ifdef XKB
d258 1
a258 3
#else
    void                *pad0;
#endif
d262 1
d272 1
d277 1
a308 1
#ifdef XKB
a309 3
#else
    void                *pad0;
#endif
a340 1
#ifdef XKB
a341 3
#else
    void                *pad0;
#endif
d389 10
a398 2
    ScreenPtr pEnqueueScreen; /* screen events are being delivered to */
    ScreenPtr pDequeueScreen; /* screen events are being dispatched to */
d468 1
a468 2
	xEvent		*event;		/* saved to be replayed */
	int		evcount;
d482 5
d499 2
a500 2
    Bool        isMaster;               /* TRUE if device is master */
    Atom		type;
d502 1
a502 1
    CARD8		id;
a514 1
#ifdef XKB
a515 3
#else
    void                *pad0;
#endif
d522 2
a523 2
    DeviceIntPtr        master;       /* master device */
    DeviceIntPtr        lastSlave;    /* last slave device used */
d536 1
d552 2
d556 1
a556 1
extern InputInfo inputInfo;
d565 32
a596 3
    xEvent		*event;
    int			evcount;
} QdEventRec;    
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d55 2
d64 1
a64 3
#define MAX_DEVICES	20

#define EMASKSIZE	MAX_DEVICES
d105 13
d135 2
d164 7
a171 1
    ValuatorMotionProcPtr GetMotionProc;
d175 3
a177 3
    void                  *motion;

    WindowPtr    	  motionHintWindow;
d181 1
a181 4
    int			  *axisVal;
    int                   lastx, lasty; /* last event recorded, not posted to
                                         * client; see dix/devices.c */
    float                 dxremaind, dyremaind; /* for acceleration */
d183 1
d188 5
a192 1
    CARD8		buttonsDown;	/* number of buttons currently down */
d205 1
a205 1
    WindowPtr	win;
d292 85
d389 34
a425 1
    TimeStamp	grabTime;
d434 2
a435 8
    GrabPtr	grab;			/* the grabber - used by DIX */
    struct {
	Bool		frozen;
	int		state;
	GrabPtr		other;		/* if other grab has this frozen */
	xEvent		*event;		/* saved to be replayed */
	int		evcount;
    } sync;
a438 10
    CARD8		activatingKey;
    Bool		fromPassiveGrab;
    GrabRec		activeGrab;
    void		(*ActivateGrab) (
			DeviceIntPtr /*device*/,
			GrabPtr /*grab*/,
			TimeStamp /*time*/,
			Bool /*autoGrab*/);
    void		(*DeactivateGrab)(
			DeviceIntPtr /*device*/);
d460 23
@


1.1
log
@Initial revision
@
text
@d55 1
d66 2
d97 2
a98 2
						modifier combinations, but only	
						3 buttons. */
d100 4
a103 4
  typedef struct _DetailRec {		/* Grab details may be bit masks */
	unsigned short exact;
	Mask *pMask;
  } DetailRec;
d105 1
a105 1
  typedef struct _GrabRec {
d126 1
d136 2
d151 14
a164 6
    int		 	numMotionEvents;
    WindowPtr    	motionHintWindow;
    AxisInfoPtr 	axes;
    unsigned short	numAxes;
    int			*axisVal;
    CARD8	 	mode;
d175 3
a177 1
    union _XkbAction *	xkb_acts;
d194 20
d228 2
d264 2
d291 2
d319 1
d327 3
a329 1
    struct _XkbInterest *	xkb_interest;
d331 2
a332 1
    DevUnion		*devPrivates;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a64 2
extern int CoreDevicePrivatesIndex;

d94 2
a95 2
                                           modifier combinations, but only	
                                           3 buttons. */
d97 4
a100 4
typedef struct _DetailRec {		/* Grab details may be bit masks */
    unsigned short      exact;
    Mask                *pMask;
} DetailRec;
d102 1
a102 1
typedef struct _GrabRec {
a122 1
    CARD8		postdown[DOWN_LENGTH];
a131 2
#else
    void               *pad0;
d145 6
a150 14
    int		 	  numMotionEvents;
    int                   first_motion;
    int                   last_motion;
    void                  *motion;

    WindowPtr    	  motionHintWindow;

    AxisInfoPtr 	  axes;
    unsigned short	  numAxes;
    int			  *axisVal;
    int                   lastx, lasty; /* last event recorded, not posted to
                                         * client; see dix/devices.c */
    int                   dxremaind, dyremaind; /* for acceleration */
    CARD8	 	  mode;
d161 1
a161 3
    union _XkbAction    *xkb_acts;
#else
    void                *pad0;
a177 20
typedef struct _AbsoluteClassRec {
    /* Calibration. */
    int         min_x;
    int         max_x;
    int         min_y;
    int         max_y;
    int         flip_x;
    int         flip_y;
    int		rotation;
    int         button_threshold;

    /* Area. */
    int         offset_x;
    int         offset_y;
    int         width;
    int         height;
    int         screen;
    XID		following;
} AbsoluteClassRec, *AbsoluteClassPtr;

a191 2
#else
    void                *pad0;
a225 2
#else
    void                *pad0;
a250 2
    Bool        enabled;                /* TRUE if ON returns Success */
    Bool        coreEvents;             /* TRUE if device also sends core */
a276 1
    AbsoluteClassPtr    absolute;
d284 1
a284 3
    struct _XkbInterest *xkb_interest;
#else
    void                *pad0;
a285 1
    char                *config_info; /* used by the hotplug layer */
@

