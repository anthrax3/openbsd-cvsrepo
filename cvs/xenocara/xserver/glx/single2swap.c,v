head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	vcnjRBuLQw44cPHf;

1.8
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.14;	author matthieu;	state Exp;
branches;
next	;

1.7.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.8.2.1
date	2014.12.09.17.59.32;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "glxserver.h"
#include "glxutil.h"
#include "glxext.h"
#include "indirect_dispatch.h"
#include "unpack.h"

int
__glXDispSwap_FeedbackBuffer(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    GLsizei size;
    GLenum type;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLXcontext *cx;
    int error;

    REQUEST_FIXED_SIZE(xGLXSingleReq, 8);

    __GLX_SWAP_INT(&((xGLXSingleReq *) pc)->contextTag);
    cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
    if (!cx) {
        return error;
    }

    pc += __GLX_SINGLE_HDR_SIZE;
    __GLX_SWAP_INT(pc + 0);
    __GLX_SWAP_INT(pc + 4);
    size = *(GLsizei *) (pc + 0);
    type = *(GLenum *) (pc + 4);
    if (cx->feedbackBufSize < size) {
        cx->feedbackBuf = reallocarray(cx->feedbackBuf,
                                       (size_t) size, __GLX_SIZE_FLOAT32);
        if (!cx->feedbackBuf) {
            cl->client->errorValue = size;
            return BadAlloc;
        }
        cx->feedbackBufSize = size;
    }
    glFeedbackBuffer(size, type, cx->feedbackBuf);
    cx->hasUnflushedCommands = GL_TRUE;
    return Success;
}

int
__glXDispSwap_SelectBuffer(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    __GLXcontext *cx;
    GLsizei size;

    __GLX_DECLARE_SWAP_VARIABLES;
    int error;

    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

    __GLX_SWAP_INT(&((xGLXSingleReq *) pc)->contextTag);
    cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
    if (!cx) {
        return error;
    }

    pc += __GLX_SINGLE_HDR_SIZE;
    __GLX_SWAP_INT(pc + 0);
    size = *(GLsizei *) (pc + 0);
    if (cx->selectBufSize < size) {
        cx->selectBuf = reallocarray(cx->selectBuf,
                                     (size_t) size, __GLX_SIZE_CARD32);
        if (!cx->selectBuf) {
            cl->client->errorValue = size;
            return BadAlloc;
        }
        cx->selectBufSize = size;
    }
    glSelectBuffer(size, cx->selectBuf);
    cx->hasUnflushedCommands = GL_TRUE;
    return Success;
}

int
__glXDispSwap_RenderMode(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    __GLXcontext *cx;
    xGLXRenderModeReply reply;
    GLint nitems = 0, retBytes = 0, retval, newModeCheck;
    GLubyte *retBuffer = NULL;
    GLenum newMode;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
    int error;

    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

    __GLX_SWAP_INT(&((xGLXSingleReq *) pc)->contextTag);
    cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
    if (!cx) {
        return error;
    }

    pc += __GLX_SINGLE_HDR_SIZE;
    __GLX_SWAP_INT(pc);
    newMode = *(GLenum *) pc;
    retval = glRenderMode(newMode);

    /* Check that render mode worked */
    glGetIntegerv(GL_RENDER_MODE, &newModeCheck);
    if (newModeCheck != newMode) {
        /* Render mode change failed.  Bail */
        newMode = newModeCheck;
        goto noChangeAllowed;
    }

    /*
     ** Render mode might have still failed if we get here.  But in this
     ** case we can't really tell, nor does it matter.  If it did fail, it
     ** will return 0, and thus we won't send any data across the wire.
     */

    switch (cx->renderMode) {
    case GL_RENDER:
        cx->renderMode = newMode;
        break;
    case GL_FEEDBACK:
        if (retval < 0) {
            /* Overflow happened. Copy the entire buffer */
            nitems = cx->feedbackBufSize;
        }
        else {
            nitems = retval;
        }
        retBytes = nitems * __GLX_SIZE_FLOAT32;
        retBuffer = (GLubyte *) cx->feedbackBuf;
        __GLX_SWAP_FLOAT_ARRAY((GLbyte *) retBuffer, nitems);
        cx->renderMode = newMode;
        break;
    case GL_SELECT:
        if (retval < 0) {
            /* Overflow happened.  Copy the entire buffer */
            nitems = cx->selectBufSize;
        }
        else {
            GLuint *bp = cx->selectBuf;
            GLint i;

            /*
             ** Figure out how many bytes of data need to be sent.  Parse
             ** the selection buffer to determine this fact as the
             ** return value is the number of hits, not the number of
             ** items in the buffer.
             */
            nitems = 0;
            i = retval;
            while (--i >= 0) {
                GLuint n;

                /* Parse select data for this hit */
                n = *bp;
                bp += 3 + n;
            }
            nitems = bp - cx->selectBuf;
        }
        retBytes = nitems * __GLX_SIZE_CARD32;
        retBuffer = (GLubyte *) cx->selectBuf;
        __GLX_SWAP_INT_ARRAY((GLbyte *) retBuffer, nitems);
        cx->renderMode = newMode;
        break;
    }

    /*
     ** First reply is the number of elements returned in the feedback or
     ** selection array, as per the API for glRenderMode itself.
     */
 noChangeAllowed:;
    reply = (xGLXRenderModeReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = nitems,
        .retval = retval,
        .size = nitems,
        .newMode = newMode
    };
    __GLX_SWAP_SHORT(&reply.sequenceNumber);
    __GLX_SWAP_INT(&reply.length);
    __GLX_SWAP_INT(&reply.retval);
    __GLX_SWAP_INT(&reply.size);
    __GLX_SWAP_INT(&reply.newMode);
    WriteToClient(client, sz_xGLXRenderModeReply, &reply);
    if (retBytes) {
        WriteToClient(client, retBytes, retBuffer);
    }
    return Success;
}

int
__glXDispSwap_Flush(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    __GLXcontext *cx;
    int error;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXSingleReq);

    __GLX_SWAP_INT(&((xGLXSingleReq *) pc)->contextTag);
    cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
    if (!cx) {
        return error;
    }

    glFlush();
    cx->hasUnflushedCommands = GL_FALSE;
    return Success;
}

int
__glXDispSwap_Finish(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    __GLXcontext *cx;
    int error;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXSingleReq);

    __GLX_SWAP_INT(&((xGLXSingleReq *) pc)->contextTag);
    cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
    if (!cx) {
        return error;
    }

    /* Do a local glFinish */
    glFinish();
    cx->hasUnflushedCommands = GL_FALSE;

    /* Send empty reply packet to indicate finish is finished */
    __GLX_BEGIN_REPLY(0);
    __GLX_PUT_RETVAL(0);
    __GLX_SWAP_REPLY_HEADER();
    __GLX_SEND_HEADER();

    return Success;
}

int
__glXDispSwap_GetString(__GLXclientState * cl, GLbyte * pc)
{
    return DoGetString(cl, pc, GL_TRUE);
}
@


1.9
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d66 2
a67 3
        cx->feedbackBuf = (GLfloat *) realloc(cx->feedbackBuf,
                                              (size_t) size
                                              * __GLX_SIZE_FLOAT32);
d101 2
a102 2
        cx->selectBuf = (GLuint *) realloc(cx->selectBuf,
                                           (size_t) size * __GLX_SIZE_CARD32);
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d44 1
d52 2
d83 1
d90 2
d118 1
a118 1
    ClientPtr client;
d129 2
a210 1
    client = cl->client;
d234 1
d240 2
d256 1
a257 1
    ClientPtr client;
d262 2
a274 1
    client = cl->client;
@


1.8.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a43 1
    ClientPtr client = cl->client;
a50 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 8);

a79 1
    ClientPtr client = cl->client;
a85 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

d112 1
a112 1
    ClientPtr client = cl->client;
a122 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

d203 1
a226 1
    ClientPtr client = cl->client;
a231 2
    REQUEST_SIZE_MATCH(xGLXSingleReq);

a245 1
    ClientPtr client = cl->client;
d247 1
a251 2
    REQUEST_SIZE_MATCH(xGLXSingleReq);

d263 1
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a39 4
#include "glapitable.h"
#include "glapi.h"
#include "glthread.h"
#include "dispatch.h"
d72 1
a72 1
    CALL_FeedbackBuffer(GET_DISPATCH(), (size, type, cx->feedbackBuf));
d104 1
a104 1
    CALL_SelectBuffer(GET_DISPATCH(), (size, cx->selectBuf));
d132 1
a132 1
    retval = CALL_RenderMode(GET_DISPATCH(), (newMode));
d135 1
a135 1
    CALL_GetIntegerv(GET_DISPATCH(), (GL_RENDER_MODE, &newModeCheck));
d238 1
a238 1
    CALL_Flush(GET_DISPATCH(), ());
d259 1
a259 1
    CALL_Finish(GET_DISPATCH(), ());
@


1.7.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a47 1
    ClientPtr client = cl->client;
a54 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 8);

a83 1
    ClientPtr client = cl->client;
a89 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

d116 1
a116 1
    ClientPtr client = cl->client;
a126 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

d207 1
a230 1
    ClientPtr client = cl->client;
a235 2
    REQUEST_SIZE_MATCH(xGLXSingleReq);

a249 1
    ClientPtr client = cl->client;
d251 1
a255 2
    REQUEST_SIZE_MATCH(xGLXSingleReq);

d267 1
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d208 8
a215 6
    reply.length = nitems;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.retval = retval;
    reply.size = nitems;
    reply.newMode = newMode;
d221 1
a221 1
    WriteToClient(client, sz_xGLXRenderModeReply, (char *) &reply);
d223 1
a223 1
        WriteToClient(client, retBytes, (char *) retBuffer);
@


1.5
log
@Update to xserver 1.11.2
@
text
@d45 2
a46 1
int __glXDispSwap_FeedbackBuffer(__GLXclientState *cl, GLbyte *pc)
d50 1
d55 1
a55 1
    __GLX_SWAP_INT(&((xGLXSingleReq *)pc)->contextTag);
d58 1
a58 1
	return error;
d62 4
a65 4
    __GLX_SWAP_INT(pc+0);
    __GLX_SWAP_INT(pc+4);
    size = *(GLsizei *)(pc+0);
    type = *(GLenum *)(pc+4);
d67 8
a74 8
	cx->feedbackBuf = (GLfloat *) realloc(cx->feedbackBuf,
						   (size_t) size 
						   * __GLX_SIZE_FLOAT32);
	if (!cx->feedbackBuf) {
	    cl->client->errorValue = size;
	    return BadAlloc;
	}
	cx->feedbackBufSize = size;
d76 1
a76 1
    CALL_FeedbackBuffer( GET_DISPATCH(), (size, type, cx->feedbackBuf) );
d81 2
a82 1
int __glXDispSwap_SelectBuffer(__GLXclientState *cl, GLbyte *pc)
d86 1
d90 1
a90 1
    __GLX_SWAP_INT(&((xGLXSingleReq *)pc)->contextTag);
d93 1
a93 1
	return error;
d97 2
a98 2
    __GLX_SWAP_INT(pc+0);
    size = *(GLsizei *)(pc+0);
d100 7
a106 8
	cx->selectBuf = (GLuint *) realloc(cx->selectBuf,
						(size_t) size 
						* __GLX_SIZE_CARD32);
	if (!cx->selectBuf) {
	    cl->client->errorValue = size;
	    return BadAlloc;
	}
	cx->selectBufSize = size;
d108 1
a108 1
    CALL_SelectBuffer( GET_DISPATCH(), (size, cx->selectBuf) );
d113 2
a114 1
int __glXDispSwap_RenderMode(__GLXclientState *cl, GLbyte *pc)
d119 1
a119 1
    GLint nitems=0, retBytes=0, retval, newModeCheck;
d122 1
d127 1
a127 1
    __GLX_SWAP_INT(&((xGLXSingleReq *)pc)->contextTag);
d130 1
a130 1
	return error;
d135 2
a136 2
    newMode = *(GLenum*) pc;
    retval = CALL_RenderMode( GET_DISPATCH(), (newMode) );
d139 1
a139 1
    CALL_GetIntegerv( GET_DISPATCH(), (GL_RENDER_MODE, &newModeCheck) );
d141 3
a143 3
	/* Render mode change failed.  Bail */
	newMode = newModeCheck;
	goto noChangeAllowed;
d147 4
a150 4
    ** Render mode might have still failed if we get here.  But in this
    ** case we can't really tell, nor does it matter.  If it did fail, it
    ** will return 0, and thus we won't send any data across the wire.
    */
d153 47
a199 45
      case GL_RENDER:
	cx->renderMode = newMode;
	break;
      case GL_FEEDBACK:
	if (retval < 0) {
	    /* Overflow happened. Copy the entire buffer */
	    nitems = cx->feedbackBufSize;
	} else {
	    nitems = retval;
	}
	retBytes = nitems * __GLX_SIZE_FLOAT32;
	retBuffer = (GLubyte*) cx->feedbackBuf;
	__GLX_SWAP_FLOAT_ARRAY((GLbyte *)retBuffer, nitems);
	cx->renderMode = newMode;
	break;
      case GL_SELECT:
	if (retval < 0) {
	    /* Overflow happened.  Copy the entire buffer */
	    nitems = cx->selectBufSize;
	} else {
	    GLuint *bp = cx->selectBuf;
	    GLint i;

	    /*
	    ** Figure out how many bytes of data need to be sent.  Parse
	    ** the selection buffer to determine this fact as the
	    ** return value is the number of hits, not the number of
	    ** items in the buffer.
	    */
	    nitems = 0;
	    i = retval;
	    while (--i >= 0) {
		GLuint n;

		/* Parse select data for this hit */
		n = *bp;
		bp += 3 + n;
	    }
	    nitems = bp - cx->selectBuf;
	}
	retBytes = nitems * __GLX_SIZE_CARD32;
	retBuffer = (GLubyte*) cx->selectBuf;
	__GLX_SWAP_INT_ARRAY((GLbyte *)retBuffer, nitems);
	cx->renderMode = newMode;
	break;
d203 4
a206 4
    ** First reply is the number of elements returned in the feedback or
    ** selection array, as per the API for glRenderMode itself.
    */
  noChangeAllowed:;
d219 1
a219 1
    WriteToClient(client, sz_xGLXRenderModeReply, (char *)&reply);
d221 1
a221 1
	WriteToClient(client, retBytes, (char *)retBuffer);
d226 2
a227 1
int __glXDispSwap_Flush(__GLXclientState *cl, GLbyte *pc)
d229 14
a242 13
	__GLXcontext *cx;
	int error;
	__GLX_DECLARE_SWAP_VARIABLES;

	__GLX_SWAP_INT(&((xGLXSingleReq *)pc)->contextTag);
	cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
	if (!cx) {
		return error;
	}

	CALL_Flush( GET_DISPATCH(), () );
	cx->hasUnflushedCommands = GL_FALSE;
	return Success;
d245 2
a246 1
int __glXDispSwap_Finish(__GLXclientState *cl, GLbyte *pc)
d251 1
d254 1
a254 1
    __GLX_SWAP_INT(&((xGLXSingleReq *)pc)->contextTag);
d257 1
a257 1
	return error;
d261 1
a261 1
    CALL_Finish( GET_DISPATCH(), () );
d274 2
a275 1
int __glXDispSwap_GetString(__GLXclientState *cl, GLbyte *pc)
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d75 1
a75 1
    __GLX_NOTE_UNFLUSHED_CMDS(cx);
d106 1
a106 1
    __GLX_NOTE_UNFLUSHED_CMDS(cx);
d232 1
a232 1
	__GLX_NOTE_FLUSHED_CMDS(cx);
d251 1
a251 1
    __GLX_NOTE_FLUSHED_CMDS(cx);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d65 1
a65 1
	cx->feedbackBuf = (GLfloat *) xrealloc(cx->feedbackBuf,
d96 1
a96 1
	cx->selectBuf = (GLuint *) xrealloc(cx->selectBuf,
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a30 1
#define NEED_REPLIES
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d2 28
a29 33
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: The application programming interfaces
** established by SGI in conjunction with the Original Code are The
** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
** Window System(R) (Version 1.3), released October 19, 1998. This software
** was created using the OpenGL(R) version 1.2.1 Sample Implementation
** published by SGI, but has not been independently verified as being
** compliant with the OpenGL(R) version 1.2.1 Specification.
**
*/
@

