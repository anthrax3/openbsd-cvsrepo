head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.8
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.6
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.8
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	vcnjRBuLQw44cPHf;

1.6
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.14;	author matthieu;	state Exp;
branches;
next	;

1.4.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.5.2.1
date	2014.12.09.17.59.32;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * (C) Copyright IBM Corporation 2005, 2006
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sub license,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDERS, THE AUTHORS, AND/OR THEIR SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file indirect_program.c
 * Hand-coded routines needed to support programmable pipeline extensions.
 *
 * \author Ian Romanick <idr@@us.ibm.com>
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "glxserver.h"
#include "glxbyteorder.h"
#include "glxext.h"
#include "singlesize.h"
#include "unpack.h"
#include "indirect_size_get.h"
#include "indirect_dispatch.h"

/**
 * Handle both types of glGetProgramString calls.
 */
static int
DoGetProgramString(struct __GLXclientStateRec *cl, GLbyte * pc,
                   PFNGLGETPROGRAMIVARBPROC get_programiv,
                   PFNGLGETPROGRAMSTRINGARBPROC get_program_string,
                   Bool do_swap)
{
    xGLXVendorPrivateWithReplyReq *const req =
        (xGLXVendorPrivateWithReplyReq *) pc;
    int error;
    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
    ClientPtr client = cl->client;

    REQUEST_FIXED_SIZE(xGLXVendorPrivateWithReplyReq, 8);

    pc += __GLX_VENDPRIV_HDR_SIZE;
    if (cx != NULL) {
        GLenum target;
        GLenum pname;
        GLint compsize = 0;
        char *answer = NULL, answerBuffer[200];

        if (do_swap) {
            target = (GLenum) bswap_32(*(int *) (pc + 0));
            pname = (GLenum) bswap_32(*(int *) (pc + 4));
        }
        else {
            target = *(GLenum *) (pc + 0);
            pname = *(GLuint *) (pc + 4);
        }

        /* The value of the GL_PROGRAM_LENGTH_ARB and GL_PROGRAM_LENGTH_NV
         * enumerants is the same.
         */
        get_programiv(target, GL_PROGRAM_LENGTH_ARB, &compsize);

        if (compsize != 0) {
            __GLX_GET_ANSWER_BUFFER(answer, cl, compsize, 1);
            __glXClearErrorOccured();

            get_program_string(target, pname, (GLubyte *) answer);
        }

        if (__glXErrorOccured()) {
            __GLX_BEGIN_REPLY(0);
            __GLX_SEND_HEADER();
        }
        else {
            __GLX_BEGIN_REPLY(compsize);
            ((xGLXGetTexImageReply *) &__glXReply)->width = compsize;
            __GLX_SEND_HEADER();
            __GLX_SEND_VOID_ARRAY(compsize);
        }

        error = Success;
    }

    return error;
}

int
__glXDisp_GetProgramStringARB(struct __GLXclientStateRec *cl, GLbyte * pc)
{
    PFNGLGETPROGRAMIVARBPROC get_program =
        __glGetProcAddress("glGetProgramivARB");
    PFNGLGETPROGRAMSTRINGARBPROC get_program_string =
        __glGetProcAddress("glGetProgramStringARB");

    return DoGetProgramString(cl, pc, get_program, get_program_string, False);
}

int
__glXDispSwap_GetProgramStringARB(struct __GLXclientStateRec *cl, GLbyte * pc)
{
    PFNGLGETPROGRAMIVARBPROC get_program =
        __glGetProcAddress("glGetProgramivARB");
    PFNGLGETPROGRAMSTRINGARBPROC get_program_string =
        __glGetProcAddress("glGetProgramStringARB");

    return DoGetProgramString(cl, pc, get_program, get_program_string, True);
}
@


1.7
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d4 1
a4 1
 * 
d11 1
a11 1
 * 
d15 1
a15 1
 * 
@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d59 2
@


1.5
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a124 22

int
__glXDisp_GetProgramStringNV(struct __GLXclientStateRec *cl, GLbyte * pc)
{
    PFNGLGETPROGRAMIVARBPROC get_program =
        __glGetProcAddress("glGetProgramivARB");
    PFNGLGETPROGRAMSTRINGARBPROC get_program_string =
        __glGetProcAddress("glGetProgramStringARB");

    return DoGetProgramString(cl, pc, get_program, get_program_string, False);
}

int
__glXDispSwap_GetProgramStringNV(struct __GLXclientStateRec *cl, GLbyte * pc)
{
    PFNGLGETPROGRAMIVARBPROC get_program =
        __glGetProcAddress("glGetProgramivARB");
    PFNGLGETPROGRAMSTRINGARBPROC get_program_string =
        __glGetProcAddress("glGetProgramStringARB");

    return DoGetProgramString(cl, pc, get_program, get_program_string, True);
}
@


1.5.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a58 2
    REQUEST_FIXED_SIZE(xGLXVendorPrivateWithReplyReq, 8);

@


1.4
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a42 8
#include "glapitable.h"
#include "glapi.h"
#include "glthread.h"
#include "dispatch.h"

static int DoGetProgramString(struct __GLXclientStateRec *cl, GLbyte * pc,
                              unsigned get_programiv_offset,
                              unsigned get_program_string_offset, Bool do_swap);
a45 6
 *
 * This single function handles both \c glGetProgramStringARB and
 * \c glGetProgramStringNV.  The dispatch offsets for the functions to use
 * for \c glGetProgramivARB and \c glGetProgramStringARB are passed in by the
 * caller.  These can be the offsets of either the ARB versions or the NV
 * versions.
d47 1
a47 1
int
d49 3
a51 2
                   unsigned get_programiv_offset,
                   unsigned get_program_string_offset, Bool do_swap)
d78 1
a78 4
        CALL_by_offset(GET_DISPATCH(),
                       (void (GLAPIENTRYP) (GLuint, GLenum, GLint *)),
                       get_programiv_offset,
                       (target, GL_PROGRAM_LENGTH_ARB, &compsize));
d84 1
a84 4
            CALL_by_offset(GET_DISPATCH(),
                           (void (GLAPIENTRYP) (GLuint, GLenum, GLubyte *)),
                           get_program_string_offset,
                           (target, pname, (GLubyte *) answer));
d107 6
a112 2
    return DoGetProgramString(cl, pc, _gloffset_GetProgramivARB,
                              _gloffset_GetProgramStringARB, False);
d118 6
a123 2
    return DoGetProgramString(cl, pc, _gloffset_GetProgramivARB,
                              _gloffset_GetProgramStringARB, True);
d129 6
a134 2
    return DoGetProgramString(cl, pc, _gloffset_GetProgramivNV,
                              _gloffset_GetProgramStringNV, False);
d140 6
a145 2
    return DoGetProgramString(cl, pc, _gloffset_GetProgramivNV,
                              _gloffset_GetProgramStringNV, True);
@


1.4.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a71 2
    REQUEST_FIXED_SIZE(xGLXVendorPrivateWithReplyReq, 8);

@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d112 1
a112 1
            ((xGLXGetTexImageReply *) & __glXReply)->width = compsize;
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a46 1
#include "glapioffsets.h"
d48 3
a50 3
static int DoGetProgramString(struct __GLXclientStateRec *cl, GLbyte *pc,
    unsigned get_programiv_offset, unsigned get_program_string_offset,
    Bool do_swap);
d61 4
a64 4
int DoGetProgramString(struct __GLXclientStateRec *cl, GLbyte *pc,
		       unsigned get_programiv_offset,
		       unsigned get_program_string_offset,
		       Bool do_swap)
d66 2
a67 2
    xGLXVendorPrivateWithReplyReq * const req = 
      (xGLXVendorPrivateWithReplyReq *) pc;
d69 1
a69 1
    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, & error);
a71 1

d74 42
a115 41
	GLenum target;
	GLenum pname;
	GLint compsize = 0;
	char *answer = NULL, answerBuffer[200];

	if (do_swap) {
	    target = (GLenum) bswap_32(*(int *)(pc + 0));
	    pname =  (GLenum) bswap_32(*(int *)(pc + 4));
	}
	else {
	    target = *(GLenum *)(pc + 0);
	    pname =  *(GLuint *)(pc + 4);
	}

	/* The value of the GL_PROGRAM_LENGTH_ARB and GL_PROGRAM_LENGTH_NV
	 * enumerants is the same.
	 */
	CALL_by_offset(GET_DISPATCH(),
		       (void (GLAPIENTRYP)(GLuint, GLenum, GLint *)), 
		       get_programiv_offset,
		       (target, GL_PROGRAM_LENGTH_ARB, &compsize));

	if (compsize != 0) {
	    __GLX_GET_ANSWER_BUFFER(answer,cl,compsize,1);
	    __glXClearErrorOccured();

	    CALL_by_offset(GET_DISPATCH(), 
			   (void (GLAPIENTRYP)(GLuint, GLenum, GLubyte *)),
			   get_program_string_offset,
			   (target, pname, (GLubyte *)answer));
	}

	if (__glXErrorOccured()) {
	    __GLX_BEGIN_REPLY(0);
	    __GLX_SEND_HEADER();
	} else {
	    __GLX_BEGIN_REPLY(compsize);
	    ((xGLXGetTexImageReply *)&__glXReply)->width = compsize;
	    __GLX_SEND_HEADER();
	    __GLX_SEND_VOID_ARRAY(compsize);
	}
d117 1
a117 1
	error = Success;
d123 2
a124 1
int __glXDisp_GetProgramStringARB(struct __GLXclientStateRec *cl, GLbyte *pc)
d127 1
a127 1
			      _gloffset_GetProgramStringARB, False);
d130 2
a131 2

int __glXDispSwap_GetProgramStringARB(struct __GLXclientStateRec *cl, GLbyte *pc)
d134 1
a134 1
			      _gloffset_GetProgramStringARB, True);
d137 2
a138 2

int __glXDisp_GetProgramStringNV(struct __GLXclientStateRec *cl, GLbyte *pc)
d141 1
a141 1
			      _gloffset_GetProgramStringNV, False);
d144 2
a145 2

int __glXDispSwap_GetProgramStringNV(struct __GLXclientStateRec *cl, GLbyte *pc)
d148 1
a148 1
			      _gloffset_GetProgramStringNV, True);
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a31 1
#define NEED_REPLIES
d105 1
a105 1
			   (target, pname, answer));
@

