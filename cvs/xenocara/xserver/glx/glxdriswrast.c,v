head	1.14;
access;
symbols
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	s0SI41sEunLdyFfd;

1.13
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	7pAEtF6Y5EgemkuY;

1.12
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.09.09.14.51.24;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.11.12.18.31;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright © 2008 George Sapountzis <gsap7@@yahoo.gr>
 * Copyright © 2008 Red Hat, Inc
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without
 * fee, provided that the above copyright notice appear in all copies
 * and that both that copyright notice and this permission notice
 * appear in supporting documentation, and that the name of the
 * copyright holders not be used in advertising or publicity
 * pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied
 * warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <sys/time.h>
#include <dlfcn.h>

#include <GL/gl.h>
#include <GL/internal/dri_interface.h>
#include <GL/glxtokens.h>

#include "scrnintstr.h"
#include "pixmapstr.h"
#include "gcstruct.h"
#include "os.h"

#include "glxserver.h"
#include "glxutil.h"
#include "glxdricommon.h"

#include "extension_string.h"

/* RTLD_LOCAL is not defined on Cygwin */
#ifdef __CYGWIN__
#ifndef RTLD_LOCAL
#define RTLD_LOCAL 0
#endif
#endif

typedef struct __GLXDRIscreen __GLXDRIscreen;
typedef struct __GLXDRIcontext __GLXDRIcontext;
typedef struct __GLXDRIdrawable __GLXDRIdrawable;

struct __GLXDRIscreen {
    __GLXscreen base;
    __DRIscreen *driScreen;
    void *driver;

    const __DRIcoreExtension *core;
    const __DRIswrastExtension *swrast;
    const __DRIcopySubBufferExtension *copySubBuffer;
    const __DRItexBufferExtension *texBuffer;
    const __DRIconfig **driConfigs;

    unsigned char glx_enable_bits[__GLX_EXT_BYTES];
};

struct __GLXDRIcontext {
    __GLXcontext base;
    __DRIcontext *driContext;
};

struct __GLXDRIdrawable {
    __GLXdrawable base;
    __DRIdrawable *driDrawable;
    __GLXDRIscreen *screen;

    GCPtr gc;                   /* scratch GC for span drawing */
    GCPtr swapgc;               /* GC for swapping the color buffers */
};

static void
__glXDRIdrawableDestroy(__GLXdrawable * drawable)
{
    __GLXDRIdrawable *private = (__GLXDRIdrawable *) drawable;
    const __DRIcoreExtension *core = private->screen->core;

    (*core->destroyDrawable) (private->driDrawable);

    FreeGC(private->gc, (GContext) 0);
    FreeGC(private->swapgc, (GContext) 0);

    __glXDrawableRelease(drawable);

    free(private);
}

static GLboolean
__glXDRIdrawableSwapBuffers(ClientPtr client, __GLXdrawable * drawable)
{
    __GLXDRIdrawable *private = (__GLXDRIdrawable *) drawable;
    const __DRIcoreExtension *core = private->screen->core;

    (*core->swapBuffers) (private->driDrawable);

    return TRUE;
}

static void
__glXDRIdrawableCopySubBuffer(__GLXdrawable * basePrivate,
                              int x, int y, int w, int h)
{
    __GLXDRIdrawable *private = (__GLXDRIdrawable *) basePrivate;
    const __DRIcopySubBufferExtension *copySubBuffer =
        private->screen->copySubBuffer;

    if (copySubBuffer)
        (*copySubBuffer->copySubBuffer) (private->driDrawable, x, y, w, h);
}

static void
__glXDRIcontextDestroy(__GLXcontext * baseContext)
{
    __GLXDRIcontext *context = (__GLXDRIcontext *) baseContext;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) context->base.pGlxScreen;

    (*screen->core->destroyContext) (context->driContext);
    __glXContextDestroy(&context->base);
    free(context);
}

static int
__glXDRIcontextMakeCurrent(__GLXcontext * baseContext)
{
    __GLXDRIcontext *context = (__GLXDRIcontext *) baseContext;
    __GLXDRIdrawable *draw = (__GLXDRIdrawable *) baseContext->drawPriv;
    __GLXDRIdrawable *read = (__GLXDRIdrawable *) baseContext->readPriv;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) context->base.pGlxScreen;

    return (*screen->core->bindContext) (context->driContext,
                                         draw->driDrawable, read->driDrawable);
}

static int
__glXDRIcontextLoseCurrent(__GLXcontext * baseContext)
{
    __GLXDRIcontext *context = (__GLXDRIcontext *) baseContext;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) context->base.pGlxScreen;

    return (*screen->core->unbindContext) (context->driContext);
}

static int
__glXDRIcontextCopy(__GLXcontext * baseDst, __GLXcontext * baseSrc,
                    unsigned long mask)
{
    __GLXDRIcontext *dst = (__GLXDRIcontext *) baseDst;
    __GLXDRIcontext *src = (__GLXDRIcontext *) baseSrc;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) dst->base.pGlxScreen;

    return (*screen->core->copyContext) (dst->driContext,
                                         src->driContext, mask);
}

static int
__glXDRIbindTexImage(__GLXcontext * baseContext,
                     int buffer, __GLXdrawable * glxPixmap)
{
    __GLXDRIdrawable *drawable = (__GLXDRIdrawable *) glxPixmap;
    const __DRItexBufferExtension *texBuffer = drawable->screen->texBuffer;
    __GLXDRIcontext *context = (__GLXDRIcontext *) baseContext;

    if (texBuffer == NULL)
        return Success;

#if __DRI_TEX_BUFFER_VERSION >= 2
    if (texBuffer->base.version >= 2 && texBuffer->setTexBuffer2 != NULL) {
        (*texBuffer->setTexBuffer2) (context->driContext,
                                     glxPixmap->target,
                                     glxPixmap->format, drawable->driDrawable);
    }
    else
#endif
        texBuffer->setTexBuffer(context->driContext,
                                glxPixmap->target, drawable->driDrawable);

    return Success;
}

static int
__glXDRIreleaseTexImage(__GLXcontext * baseContext,
                        int buffer, __GLXdrawable * pixmap)
{
    /* FIXME: Just unbind the texture? */
    return Success;
}

static __GLXtextureFromPixmap __glXDRItextureFromPixmap = {
    __glXDRIbindTexImage,
    __glXDRIreleaseTexImage
};

static void
__glXDRIscreenDestroy(__GLXscreen * baseScreen)
{
    int i;

    __GLXDRIscreen *screen = (__GLXDRIscreen *) baseScreen;

    (*screen->core->destroyScreen) (screen->driScreen);

    dlclose(screen->driver);

    __glXScreenDestroy(baseScreen);

    if (screen->driConfigs) {
        for (i = 0; screen->driConfigs[i] != NULL; i++)
            free((__DRIconfig **) screen->driConfigs[i]);
        free(screen->driConfigs);
    }

    free(screen);
}

static __GLXcontext *
__glXDRIscreenCreateContext(__GLXscreen * baseScreen,
                            __GLXconfig * glxConfig,
                            __GLXcontext * baseShareContext,
                            unsigned num_attribs,
                            const uint32_t *attribs,
                            int *error)
{
    __GLXDRIscreen *screen = (__GLXDRIscreen *) baseScreen;
    __GLXDRIcontext *context, *shareContext;
    __GLXDRIconfig *config = (__GLXDRIconfig *) glxConfig;
    const __DRIcoreExtension *core = screen->core;
    __DRIcontext *driShare;

    /* DRISWRAST won't support createContextAttribs, so these parameters will
     * never be used.
     */
    (void) num_attribs;
    (void) attribs;
    (void) error;

    shareContext = (__GLXDRIcontext *) baseShareContext;
    if (shareContext)
        driShare = shareContext->driContext;
    else
        driShare = NULL;

    context = calloc(1, sizeof *context);
    if (context == NULL)
        return NULL;

    context->base.destroy = __glXDRIcontextDestroy;
    context->base.makeCurrent = __glXDRIcontextMakeCurrent;
    context->base.loseCurrent = __glXDRIcontextLoseCurrent;
    context->base.copy = __glXDRIcontextCopy;
    context->base.textureFromPixmap = &__glXDRItextureFromPixmap;

    context->driContext =
        (*core->createNewContext) (screen->driScreen,
                                   config->driConfig, driShare, context);

    return &context->base;
}

static __GLXdrawable *
__glXDRIscreenCreateDrawable(ClientPtr client,
                             __GLXscreen * screen,
                             DrawablePtr pDraw,
                             XID drawId,
                             int type, XID glxDrawId, __GLXconfig * glxConfig)
{
    XID gcvals[2];
    int status;
    __GLXDRIscreen *driScreen = (__GLXDRIscreen *) screen;
    __GLXDRIconfig *config = (__GLXDRIconfig *) glxConfig;
    __GLXDRIdrawable *private;

    private = calloc(1, sizeof *private);
    if (private == NULL)
        return NULL;

    private->screen = driScreen;
    if (!__glXDrawableInit(&private->base, screen,
                           pDraw, type, glxDrawId, glxConfig)) {
        free(private);
        return NULL;
    }

    private->base.destroy = __glXDRIdrawableDestroy;
    private->base.swapBuffers = __glXDRIdrawableSwapBuffers;
    private->base.copySubBuffer = __glXDRIdrawableCopySubBuffer;

    gcvals[0] = GXcopy;
    private->gc =
        CreateGC(pDraw, GCFunction, gcvals, &status, (XID) 0, serverClient);
    gcvals[1] = FALSE;
    private->swapgc =
        CreateGC(pDraw, GCFunction | GCGraphicsExposures, gcvals, &status,
                 (XID) 0, serverClient);

    private->driDrawable =
        (*driScreen->swrast->createNewDrawable) (driScreen->driScreen,
                                                 config->driConfig, private);

    return &private->base;
}

static void
swrastGetDrawableInfo(__DRIdrawable * draw,
                      int *x, int *y, int *w, int *h, void *loaderPrivate)
{
    __GLXDRIdrawable *drawable = loaderPrivate;
    DrawablePtr pDraw = drawable->base.pDraw;

    *x = pDraw->x;
    *y = pDraw->y;
    *w = pDraw->width;
    *h = pDraw->height;
}

static void
swrastPutImage(__DRIdrawable * draw, int op,
               int x, int y, int w, int h, char *data, void *loaderPrivate)
{
    __GLXDRIdrawable *drawable = loaderPrivate;
    DrawablePtr pDraw = drawable->base.pDraw;
    GCPtr gc;
    __GLXcontext *cx = lastGLContext;

    switch (op) {
    case __DRI_SWRAST_IMAGE_OP_DRAW:
        gc = drawable->gc;
        break;
    case __DRI_SWRAST_IMAGE_OP_SWAP:
        gc = drawable->swapgc;
        break;
    default:
        return;
    }

    ValidateGC(pDraw, gc);

    gc->ops->PutImage(pDraw, gc, pDraw->depth, x, y, w, h, 0, ZPixmap, data);
    if (cx != lastGLContext) {
        lastGLContext = cx;
        cx->makeCurrent(cx);
    }
}

static void
swrastGetImage(__DRIdrawable * draw,
               int x, int y, int w, int h, char *data, void *loaderPrivate)
{
    __GLXDRIdrawable *drawable = loaderPrivate;
    DrawablePtr pDraw = drawable->base.pDraw;
    ScreenPtr pScreen = pDraw->pScreen;
    __GLXcontext *cx = lastGLContext;

    pScreen->GetImage(pDraw, x, y, w, h, ZPixmap, ~0L, data);
    if (cx != lastGLContext) {
        lastGLContext = cx;
        cx->makeCurrent(cx);
    }
}

static const __DRIswrastLoaderExtension swrastLoaderExtension = {
    {__DRI_SWRAST_LOADER, 1},
    swrastGetDrawableInfo,
    swrastPutImage,
    swrastGetImage
};

static const __DRIextension *loader_extensions[] = {
    &systemTimeExtension.base,
    &swrastLoaderExtension.base,
    NULL
};

static void
initializeExtensions(__GLXDRIscreen * screen)
{
    const __DRIextension **extensions;
    int i;

    __glXEnableExtension(screen->glx_enable_bits, "GLX_MESA_copy_sub_buffer");
    LogMessage(X_INFO, "AIGLX: enabled GLX_MESA_copy_sub_buffer\n");

    if (screen->swrast->base.version >= 3) {
        __glXEnableExtension(screen->glx_enable_bits,
                             "GLX_ARB_create_context");
        __glXEnableExtension(screen->glx_enable_bits,
                             "GLX_ARB_create_context_profile");
        __glXEnableExtension(screen->glx_enable_bits,
                             "GLX_EXT_create_context_es_profile");
        __glXEnableExtension(screen->glx_enable_bits,
                             "GLX_EXT_create_context_es2_profile");
    }

    /* these are harmless to enable unconditionally */
    __glXEnableExtension(screen->glx_enable_bits, "GLX_EXT_framebuffer_sRGB");
    __glXEnableExtension(screen->glx_enable_bits, "GLX_ARB_fbconfig_float");
    __glXEnableExtension(screen->glx_enable_bits, "GLX_EXT_fbconfig_packed_float");
    __glXEnableExtension(screen->glx_enable_bits, "GLX_SGI_make_current_read");

    extensions = screen->core->getExtensions(screen->driScreen);

    for (i = 0; extensions[i]; i++) {
        if (strcmp(extensions[i]->name, __DRI_COPY_SUB_BUFFER) == 0) {
            screen->copySubBuffer =
                (const __DRIcopySubBufferExtension *) extensions[i];
        }

        if (strcmp(extensions[i]->name, __DRI_TEX_BUFFER) == 0) {
            screen->texBuffer = (const __DRItexBufferExtension *) extensions[i];
            /* GLX_EXT_texture_from_pixmap is always enabled. */
        }

#ifdef __DRI2_FLUSH_CONTROL
        if (strcmp(extensions[i]->name, __DRI2_FLUSH_CONTROL) == 0) {
            __glXEnableExtension(screen->glx_enable_bits,
                                 "GLX_ARB_context_flush_control\n");
        }
#endif

    }
}

/* white lie */
extern glx_func_ptr glXGetProcAddressARB(const char *);

static __GLXscreen *
__glXDRIscreenProbe(ScreenPtr pScreen)
{
    const char *driverName = "swrast";
    __GLXDRIscreen *screen;
    size_t buffer_size;

    screen = calloc(1, sizeof *screen);
    if (screen == NULL)
        return NULL;

    screen->base.destroy = __glXDRIscreenDestroy;
    screen->base.createContext = __glXDRIscreenCreateContext;
    screen->base.createDrawable = __glXDRIscreenCreateDrawable;
    screen->base.swapInterval = NULL;
    screen->base.pScreen = pScreen;

    __glXInitExtensionEnableBits(screen->glx_enable_bits);

    screen->driver = glxProbeDriver(driverName,
                                    (void **) &screen->core,
                                    __DRI_CORE, 1,
                                    (void **) &screen->swrast,
                                    __DRI_SWRAST, 1);
    if (screen->driver == NULL) {
        goto handle_error;
    }

    screen->driScreen =
        (*screen->swrast->createNewScreen) (pScreen->myNum,
                                            loader_extensions,
                                            &screen->driConfigs, screen);

    if (screen->driScreen == NULL) {
        LogMessage(X_ERROR, "AIGLX error: Calling driver entry point failed\n");
        goto handle_error;
    }

    initializeExtensions(screen);

    screen->base.fbconfigs = glxConvertConfigs(screen->core, screen->driConfigs,
                                               GLX_WINDOW_BIT |
                                               GLX_PIXMAP_BIT |
                                               GLX_PBUFFER_BIT);

    __glXScreenInit(&screen->base, pScreen);

    /* The first call simply determines the length of the extension string.
     * This allows us to allocate some memory to hold the extension string,
     * but it requires that we call __glXGetExtensionString a second time.
     */
    buffer_size = __glXGetExtensionString(screen->glx_enable_bits, NULL);
    if (buffer_size > 0) {
        free(screen->base.GLXextensions);

        screen->base.GLXextensions = xnfalloc(buffer_size);
        (void) __glXGetExtensionString(screen->glx_enable_bits,
                                       screen->base.GLXextensions);
    }

    screen->base.GLXmajor = 1;
    screen->base.GLXminor = 4;

    __glXsetGetProcAddress(glXGetProcAddressARB);

    LogMessage(X_INFO, "AIGLX: Loaded and initialized %s\n", driverName);

    return &screen->base;

 handle_error:
    if (screen->driver)
        dlclose(screen->driver);

    free(screen);

    LogMessage(X_ERROR, "GLX: could not load software renderer\n");

    return NULL;
}

_X_EXPORT __GLXprovider __glXDRISWRastProvider = {
    __glXDRIscreenProbe,
    "DRISWRAST",
    NULL
};
@


1.13
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d408 2
d416 1
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d74 2
d399 17
a421 1
            /* GLX_MESA_copy_sub_buffer is always enabled. */
d429 7
a435 1
        /* Ignore unknown extensions */
d447 1
d459 2
d488 13
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d328 1
a328 1
    *y = pDraw->x;
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a172 2
#ifdef __DRI_TEX_BUFFER

a205 18
#else

static int
__glXDRIbindTexImage(__GLXcontext * baseContext,
                     int buffer, __GLXdrawable * glxPixmap)
{
    return Success;
}

static int
__glXDRIreleaseTexImage(__GLXcontext * baseContext,
                        int buffer, __GLXdrawable * pixmap)
{
    return Success;
}

#endif

d340 1
d356 4
d369 1
d372 4
a399 1
#ifdef __DRI_COPY_SUB_BUFFER
a404 1
#endif
a405 1
#ifdef __DRI_TEX_BUFFER
d410 1
a410 1
#endif
@


1.9
log
@revert a local patch to check for swrastg, LLVMpipe installs as swrast now
ok mpi@@ ajacoutot@@
@
text
@a50 4
#include "glapitable.h"
#include "glapi.h"
#include "glthread.h"
#include "dispatch.h"
d389 1
a389 1
    {__DRI_SWRAST_LOADER, __DRI_SWRAST_LOADER_VERSION},
d428 3
d449 1
a449 1
                                    __DRI_CORE, __DRI_CORE_VERSION,
d451 1
a451 1
                                    __DRI_SWRAST, __DRI_SWRAST_VERSION);
d477 2
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d435 1
a435 1
    const char *driverName = "swrastg";
a452 10

    if (screen->driver == NULL) {
    	    driverName = "swrast";
	    screen->driver = glxProbeDriver(driverName,
					    (void **) &screen->core,
					    __DRI_CORE, __DRI_CORE_VERSION,
					    (void **) &screen->swrast,
					    __DRI_SWRAST, __DRI_SWRAST_VERSION);
    }

@


1.7
log
@Try to load the gallium3d "swrastg" driver if available before falling back
to the default mesa "swrast" one for software rendering.

ok matthieu@@
@
text
@d260 4
a263 1
                            __GLXcontext * baseShareContext)
d270 7
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d425 1
a425 1
    const char *driverName = "swrast";
d443 10
@


1.5
log
@Update to xserver 1.11.2
@
text
@d64 2
a65 2
typedef struct __GLXDRIscreen   __GLXDRIscreen;
typedef struct __GLXDRIcontext  __GLXDRIcontext;
d69 3
a71 3
    __GLXscreen		 base;
    __DRIscreen		*driScreen;
    void		*driver;
d77 1
d81 2
a82 2
    __GLXcontext	 base;
    __DRIcontext	*driContext;
d86 3
a88 3
    __GLXdrawable	 base;
    __DRIdrawable	*driDrawable;
    __GLXDRIscreen	*screen;
d90 2
a91 2
    GCPtr gc;		/* scratch GC for span drawing */
    GCPtr swapgc;	/* GC for swapping the color buffers */
d95 1
a95 1
__glXDRIdrawableDestroy(__GLXdrawable *drawable)
d100 1
a100 1
    (*core->destroyDrawable)(private->driDrawable);
d102 2
a103 2
    FreeGC(private->gc, (GContext)0);
    FreeGC(private->swapgc, (GContext)0);
d111 1
a111 1
__glXDRIdrawableSwapBuffers(ClientPtr client, __GLXdrawable *drawable)
d116 1
a116 1
    (*core->swapBuffers)(private->driDrawable);
d122 2
a123 2
__glXDRIdrawableCopySubBuffer(__GLXdrawable *basePrivate,
			       int x, int y, int w, int h)
d127 1
a127 1
	    private->screen->copySubBuffer;
d130 1
a130 1
	(*copySubBuffer->copySubBuffer)(private->driDrawable, x, y, w, h);
d134 1
a134 1
__glXDRIcontextDestroy(__GLXcontext *baseContext)
d139 1
a139 1
    (*screen->core->destroyContext)(context->driContext);
d145 1
a145 1
__glXDRIcontextMakeCurrent(__GLXcontext *baseContext)
d152 2
a153 3
    return (*screen->core->bindContext)(context->driContext,
					draw->driDrawable,
					read->driDrawable);
d157 1
a157 1
__glXDRIcontextLoseCurrent(__GLXcontext *baseContext)
d162 1
a162 1
    return (*screen->core->unbindContext)(context->driContext);
d166 2
a167 2
__glXDRIcontextCopy(__GLXcontext *baseDst, __GLXcontext *baseSrc,
		    unsigned long mask)
d173 2
a174 2
    return (*screen->core->copyContext)(dst->driContext,
					src->driContext, mask);
d180 2
a181 3
__glXDRIbindTexImage(__GLXcontext *baseContext,
		     int buffer,
		     __GLXdrawable *glxPixmap)
d192 5
a196 5
	(*texBuffer->setTexBuffer2)(context->driContext,
				    glxPixmap->target,
				    glxPixmap->format,
				    drawable->driDrawable);
    } else
d198 2
a199 3
    texBuffer->setTexBuffer(context->driContext,
			    glxPixmap->target,
			    drawable->driDrawable);
d205 2
a206 3
__glXDRIreleaseTexImage(__GLXcontext *baseContext,
			int buffer,
			__GLXdrawable *pixmap)
d215 2
a216 3
__glXDRIbindTexImage(__GLXcontext *baseContext,
		     int buffer,
		     __GLXdrawable *glxPixmap)
d222 2
a223 3
__glXDRIreleaseTexImage(__GLXcontext *baseContext,
			int buffer,
			__GLXdrawable *pixmap)
d236 1
a236 1
__glXDRIscreenDestroy(__GLXscreen *baseScreen)
d238 2
d242 1
a242 1
    (*screen->core->destroyScreen)(screen->driScreen);
d248 6
d258 3
a260 3
__glXDRIscreenCreateContext(__GLXscreen *baseScreen,
			    __GLXconfig *glxConfig,
			    __GLXcontext *baseShareContext)
d270 1
a270 1
	driShare = shareContext->driContext;
d272 1
a272 1
	driShare = NULL;
d276 1
a276 1
	return NULL;
d278 4
a281 4
    context->base.destroy           = __glXDRIcontextDestroy;
    context->base.makeCurrent       = __glXDRIcontextMakeCurrent;
    context->base.loseCurrent       = __glXDRIcontextLoseCurrent;
    context->base.copy              = __glXDRIcontextCopy;
d285 2
a286 2
	(*core->createNewContext)(screen->driScreen,
				  config->driConfig, driShare, context);
d293 4
a296 6
			     __GLXscreen *screen,
			     DrawablePtr pDraw,
			     XID drawId,
			     int type,
			     XID glxDrawId,
			     __GLXconfig *glxConfig)
d306 1
a306 1
	return NULL;
d310 1
a310 1
			   pDraw, type, glxDrawId, glxConfig)) {
d312 1
a312 1
	return NULL;
d315 2
a316 2
    private->base.destroy       = __glXDRIdrawableDestroy;
    private->base.swapBuffers   = __glXDRIdrawableSwapBuffers;
d320 2
a321 1
    private->gc = CreateGC(pDraw, GCFunction, gcvals, &status, (XID)0, serverClient);
d323 3
a325 1
    private->swapgc = CreateGC(pDraw, GCFunction | GCGraphicsExposures, gcvals, &status, (XID)0, serverClient);
d328 2
a329 3
	(*driScreen->swrast->createNewDrawable)(driScreen->driScreen,
						config->driConfig,
						private);
d335 2
a336 3
swrastGetDrawableInfo(__DRIdrawable *draw,
		      int *x, int *y, int *w, int *h,
		      void *loaderPrivate)
d348 2
a349 3
swrastPutImage(__DRIdrawable *draw, int op,
	     int x, int y, int w, int h, char *data,
	     void *loaderPrivate)
d357 2
a358 2
	gc = drawable->gc;
	break;
d360 2
a361 2
	gc = drawable->swapgc;
	break;
d363 1
a363 1
	return;
d368 1
a368 2
    gc->ops->PutImage(pDraw, gc, pDraw->depth,
		      x, y, w, h, 0, ZPixmap, data);
d372 2
a373 3
swrastGetImage(__DRIdrawable *draw,
	     int x, int y, int w, int h, char *data,
	     void *loaderPrivate)
d383 1
a383 1
    { __DRI_SWRAST_LOADER, __DRI_SWRAST_LOADER_VERSION },
d396 1
a396 1
initializeExtensions(__GLXDRIscreen *screen)
d405 5
a409 5
	if (strcmp(extensions[i]->name, __DRI_COPY_SUB_BUFFER) == 0) {
	    screen->copySubBuffer =
		(const __DRIcopySubBufferExtension *) extensions[i];
	    /* GLX_MESA_copy_sub_buffer is always enabled. */
	}
d413 4
a416 5
	if (strcmp(extensions[i]->name, __DRI_TEX_BUFFER) == 0) {
	    screen->texBuffer =
		(const __DRItexBufferExtension *) extensions[i];
	    /* GLX_EXT_texture_from_pixmap is always enabled. */
	}
d418 1
a418 1
	/* Ignore unknown extensions */
a426 1
    const __DRIconfig **driConfigs;
d430 1
a430 1
	return NULL;
d432 2
a433 2
    screen->base.destroy        = __glXDRIscreenDestroy;
    screen->base.createContext  = __glXDRIscreenCreateContext;
d435 2
a436 2
    screen->base.swapInterval   = NULL;
    screen->base.pScreen       = pScreen;
d439 4
a442 4
				    (void **)&screen->core,
				    __DRI_CORE, __DRI_CORE_VERSION,
				    (void **)&screen->swrast,
				    __DRI_SWRAST, __DRI_SWRAST_VERSION);
d448 3
a450 4
	(*screen->swrast->createNewScreen)(pScreen->myNum,
					   loader_extensions,
					   &driConfigs,
					   screen);
d453 2
a454 3
	LogMessage(X_ERROR,
		   "AIGLX error: Calling driver entry point failed\n");
	goto handle_error;
d459 4
a462 4
    screen->base.fbconfigs = glxConvertConfigs(screen->core, driConfigs,
					       GLX_WINDOW_BIT |
					       GLX_PIXMAP_BIT |
					       GLX_PBUFFER_BIT);
d469 1
a469 2
    LogMessage(X_INFO,
	       "AIGLX: Loaded and initialized %s\n", driverName);
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a50 1
#include "g_disptab.h"
d101 2
a102 2
    FreeScratchGC(private->gc);
    FreeScratchGC(private->swapgc);
a176 13
static int
__glXDRIcontextForceCurrent(__GLXcontext *baseContext)
{
    __GLXDRIcontext *context = (__GLXDRIcontext *) baseContext;
    __GLXDRIdrawable *draw = (__GLXDRIdrawable *) baseContext->drawPriv;
    __GLXDRIdrawable *read = (__GLXDRIdrawable *) baseContext->readPriv;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) context->base.pGlxScreen;

    return (*screen->core->bindContext)(context->driContext,
					draw->driDrawable,
					read->driDrawable);
}

d191 8
a278 1
    context->base.forceCurrent      = __glXDRIcontextForceCurrent;
d297 2
a298 1
    ChangeGCVal gcvals[2];
a302 2
    ScreenPtr pScreen = driScreen->base.pScreen;

d318 4
a321 7
    private->gc = CreateScratchGC(pScreen, pDraw->depth);
    private->swapgc = CreateScratchGC(pScreen, pDraw->depth);

    gcvals[0].val = GXcopy;
    ChangeGC(NullClient, private->gc, GCFunction, gcvals);
    gcvals[1].val = FALSE;
    ChangeGC(NullClient, private->swapgc, GCFunction | GCGraphicsExposures, gcvals);
a423 2
static const char dri_driver_path[] = DRI_DRIVER_PATH;

a428 2
    char filename[128];
    const __DRIextension **extensions;
a429 1
    int i;
d441 5
a445 4
    snprintf(filename, sizeof filename,
	     "%s/%s_dri.so", dri_driver_path, driverName);

    screen->driver = dlopen(filename, RTLD_LAZY | RTLD_LOCAL);
a446 2
	LogMessage(X_ERROR, "AIGLX error: dlopen of %s failed (%s)\n",
		   filename, dlerror());
a449 24
    extensions = dlsym(screen->driver, __DRI_DRIVER_EXTENSIONS);
    if (extensions == NULL) {
	LogMessage(X_ERROR, "AIGLX error: %s exports no extensions (%s)\n",
		   driverName, dlerror());
	goto handle_error;
    }

    for (i = 0; extensions[i]; i++) {
        if (strcmp(extensions[i]->name, __DRI_CORE) == 0 &&
	    extensions[i]->version >= __DRI_CORE_VERSION) {
		screen->core = (const __DRIcoreExtension *) extensions[i];
	}
        if (strcmp(extensions[i]->name, __DRI_SWRAST) == 0 &&
	    extensions[i]->version >= __DRI_SWRAST_VERSION) {
		screen->swrast = (const __DRIswrastExtension *) extensions[i];
	}
    }

    if (screen->core == NULL || screen->swrast == NULL) {
	LogMessage(X_ERROR, "AIGLX error: %s exports no DRI extension\n",
		   driverName);
	goto handle_error;
    }

d475 1
a475 1
	       "AIGLX: Loaded and initialized %s\n", filename);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d107 1
a107 1
    xfree(private);
d141 1
a141 1
    xfree(context);
d257 1
a257 1
    xfree(screen);
d277 1
a277 1
    context = xcalloc(1, sizeof *context);
a294 8
static void
glxChangeGC(GCPtr gc, BITS32 mask, CARD32 val)
{
    CARD32 v[1];
    v[0] = val;
    dixChangeGC(NullClient, gc, mask, v, NULL);
}

d304 1
d311 1
a311 1
    private = xcalloc(1, sizeof *private);
d318 1
a318 1
        xfree(private);
d329 4
a332 3
    glxChangeGC(private->gc, GCFunction, GXcopy);
    glxChangeGC(private->swapgc, GCFunction, GXcopy);
    glxChangeGC(private->swapgc, GCGraphicsExposures, FALSE);
d447 1
a447 1
    screen = xcalloc(1, sizeof *screen);
d505 4
a508 1
    screen->base.fbconfigs = glxConvertConfigs(screen->core, driConfigs);
d524 1
a524 1
    xfree(screen);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d58 7
d111 1
a111 1
__glXDRIdrawableSwapBuffers(__GLXdrawable *drawable)
d304 2
a305 1
__glXDRIscreenCreateDrawable(__GLXscreen *screen,
d307 1
d309 1
a309 1
			     XID drawId,
d324 1
a324 1
			   pDraw, type, drawId, glxConfig)) {
d504 2
a505 1
	LogMessage(X_ERROR, "AIGLX error: Calling driver entry point failed");
d515 3
d534 1
a534 1
__GLXprovider __glXDRISWRastProvider = {
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a83 1
    GCPtr cleargc;	/* GC for clearing the color buffer */
a95 1
    FreeScratchGC(private->cleargc);
d98 2
a103 9
__glXDRIdrawableResize(__GLXdrawable *drawable)
{
    /* Nothing to do here, the DRI driver asks the server for drawable
     * geometry appropriately. */

    return GL_TRUE;
}

static GLboolean
d270 1
a270 1
    context = xalloc(sizeof *context);
a273 1
    memset(context, 0, sizeof *context);
d309 1
a309 1
    private = xalloc(sizeof *private);
a312 2
    memset(private, 0, sizeof *private);

a320 1
    private->base.resize        = __glXDRIdrawableResize;
a324 1
    private->cleargc = CreateScratchGC(pScreen, pDraw->depth);
a327 1
    glxChangeGC(private->cleargc, GCFunction, GXcopy);
a365 3
    case __DRI_SWRAST_IMAGE_OP_CLEAR:
	gc = drawable->cleargc;
	break;
d444 1
a444 1
    screen = xalloc(sizeof *screen);
a446 1
    memset(screen, 0, sizeof *screen);
@

