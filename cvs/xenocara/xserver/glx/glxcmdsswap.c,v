head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.12
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.10
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.8
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	vcnjRBuLQw44cPHf;

1.7
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	;

1.6.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.7.2.1
date	2014.12.09.17.59.32;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.8
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>
#include "glxserver.h"
#include "glxutil.h"
#include <GL/glxtokens.h>
#include <unpack.h>
#include <pixmapstr.h>
#include <windowstr.h>
#include "glxext.h"
#include "indirect_dispatch.h"
#include "indirect_table.h"
#include "indirect_util.h"

/************************************************************************/

/*
** Byteswapping versions of GLX commands.  In most cases they just swap
** the incoming arguments and then call the unswapped routine.  For commands
** that have replies, a separate swapping routine for the reply is provided;
** it is called at the end of the unswapped routine.
*/

int
__glXDispSwap_CreateContext(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXCreateContextReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->context);
    __GLX_SWAP_INT(&req->visual);
    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->shareList);

    return __glXDisp_CreateContext(cl, pc);
}

int
__glXDispSwap_CreateNewContext(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreateNewContextReq *req = (xGLXCreateNewContextReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXCreateNewContextReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->context);
    __GLX_SWAP_INT(&req->fbconfig);
    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->renderType);
    __GLX_SWAP_INT(&req->shareList);

    return __glXDisp_CreateNewContext(cl, pc);
}

int
__glXDispSwap_CreateContextWithConfigSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreateContextWithConfigSGIXReq *req =
        (xGLXCreateContextWithConfigSGIXReq *) pc;
    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXCreateContextWithConfigSGIXReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->context);
    __GLX_SWAP_INT(&req->fbconfig);
    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->renderType);
    __GLX_SWAP_INT(&req->shareList);

    return __glXDisp_CreateContextWithConfigSGIX(cl, pc);
}

int
__glXDispSwap_DestroyContext(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyContextReq *req = (xGLXDestroyContextReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXDestroyContextReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->context);

    return __glXDisp_DestroyContext(cl, pc);
}

int
__glXDispSwap_MakeCurrent(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXMakeCurrentReq *req = (xGLXMakeCurrentReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXMakeCurrentReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->drawable);
    __GLX_SWAP_INT(&req->context);
    __GLX_SWAP_INT(&req->oldContextTag);

    return __glXDisp_MakeCurrent(cl, pc);
}

int
__glXDispSwap_MakeContextCurrent(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXMakeContextCurrentReq *req = (xGLXMakeContextCurrentReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXMakeContextCurrentReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->drawable);
    __GLX_SWAP_INT(&req->readdrawable);
    __GLX_SWAP_INT(&req->context);
    __GLX_SWAP_INT(&req->oldContextTag);

    return __glXDisp_MakeContextCurrent(cl, pc);
}

int
__glXDispSwap_MakeCurrentReadSGI(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXMakeCurrentReadSGIReq *req = (xGLXMakeCurrentReadSGIReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXMakeCurrentReadSGIReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->drawable);
    __GLX_SWAP_INT(&req->readable);
    __GLX_SWAP_INT(&req->context);
    __GLX_SWAP_INT(&req->oldContextTag);

    return __glXDisp_MakeCurrentReadSGI(cl, pc);
}

int
__glXDispSwap_IsDirect(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXIsDirectReq *req = (xGLXIsDirectReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXIsDirectReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->context);

    return __glXDisp_IsDirect(cl, pc);
}

int
__glXDispSwap_QueryVersion(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXQueryVersionReq *req = (xGLXQueryVersionReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXQueryVersionReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->majorVersion);
    __GLX_SWAP_INT(&req->minorVersion);

    return __glXDisp_QueryVersion(cl, pc);
}

int
__glXDispSwap_WaitGL(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXWaitGLReq *req = (xGLXWaitGLReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXWaitGLReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);

    return __glXDisp_WaitGL(cl, pc);
}

int
__glXDispSwap_WaitX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXWaitXReq *req = (xGLXWaitXReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXWaitXReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);

    return __glXDisp_WaitX(cl, pc);
}

int
__glXDispSwap_CopyContext(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCopyContextReq *req = (xGLXCopyContextReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXCopyContextReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->source);
    __GLX_SWAP_INT(&req->dest);
    __GLX_SWAP_INT(&req->mask);

    return __glXDisp_CopyContext(cl, pc);
}

int
__glXDispSwap_GetVisualConfigs(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXGetVisualConfigsReq *req = (xGLXGetVisualConfigsReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXGetVisualConfigsReq);

    __GLX_SWAP_INT(&req->screen);
    return __glXDisp_GetVisualConfigs(cl, pc);
}

int
__glXDispSwap_GetFBConfigs(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXGetFBConfigsReq *req = (xGLXGetFBConfigsReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXGetFBConfigsReq);

    __GLX_SWAP_INT(&req->screen);
    return __glXDisp_GetFBConfigs(cl, pc);
}

int
__glXDispSwap_GetFBConfigsSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXGetFBConfigsSGIXReq *req = (xGLXGetFBConfigsSGIXReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_AT_LEAST_SIZE(xGLXGetFBConfigsSGIXReq);

    __GLX_SWAP_INT(&req->screen);
    return __glXDisp_GetFBConfigsSGIX(cl, pc);
}

int
__glXDispSwap_CreateGLXPixmap(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreateGLXPixmapReq *req = (xGLXCreateGLXPixmapReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXCreateGLXPixmapReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->visual);
    __GLX_SWAP_INT(&req->pixmap);
    __GLX_SWAP_INT(&req->glxpixmap);

    return __glXDisp_CreateGLXPixmap(cl, pc);
}

int
__glXDispSwap_CreatePixmap(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreatePixmapReq *req = (xGLXCreatePixmapReq *) pc;
    CARD32 *attribs;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    REQUEST_AT_LEAST_SIZE(xGLXCreatePixmapReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->fbconfig);
    __GLX_SWAP_INT(&req->pixmap);
    __GLX_SWAP_INT(&req->glxpixmap);
    __GLX_SWAP_INT(&req->numAttribs);

    if (req->numAttribs > (UINT32_MAX >> 3)) {
        client->errorValue = req->numAttribs;
        return BadValue;
    }
    REQUEST_FIXED_SIZE(xGLXCreatePixmapReq, req->numAttribs << 3);
    attribs = (CARD32 *) (req + 1);
    __GLX_SWAP_INT_ARRAY(attribs, req->numAttribs << 1);

    return __glXDisp_CreatePixmap(cl, pc);
}

int
__glXDispSwap_CreateGLXPixmapWithConfigSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreateGLXPixmapWithConfigSGIXReq *req =
        (xGLXCreateGLXPixmapWithConfigSGIXReq *) pc;
    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXCreateGLXPixmapWithConfigSGIXReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->fbconfig);
    __GLX_SWAP_INT(&req->pixmap);
    __GLX_SWAP_INT(&req->glxpixmap);

    return __glXDisp_CreateGLXPixmapWithConfigSGIX(cl, pc);
}

int
__glXDispSwap_DestroyGLXPixmap(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyGLXPixmapReq *req = (xGLXDestroyGLXPixmapReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXDestroyGLXPixmapReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->glxpixmap);

    return __glXDisp_DestroyGLXPixmap(cl, pc);
}

int
__glXDispSwap_DestroyPixmap(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyGLXPixmapReq *req = (xGLXDestroyGLXPixmapReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_AT_LEAST_SIZE(xGLXDestroyGLXPixmapReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->glxpixmap);

    return __glXDisp_DestroyGLXPixmap(cl, pc);
}

int
__glXDispSwap_QueryContext(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXQueryContextReq *req = (xGLXQueryContextReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXQueryContextReq);

    __GLX_SWAP_INT(&req->context);

    return __glXDisp_QueryContext(cl, pc);
}

int
__glXDispSwap_CreatePbuffer(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreatePbufferReq *req = (xGLXCreatePbufferReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
    CARD32 *attribs;

    REQUEST_AT_LEAST_SIZE(xGLXCreatePbufferReq);

    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->fbconfig);
    __GLX_SWAP_INT(&req->pbuffer);
    __GLX_SWAP_INT(&req->numAttribs);

    if (req->numAttribs > (UINT32_MAX >> 3)) {
        client->errorValue = req->numAttribs;
        return BadValue;
    }
    REQUEST_FIXED_SIZE(xGLXCreatePbufferReq, req->numAttribs << 3);
    attribs = (CARD32 *) (req + 1);
    __GLX_SWAP_INT_ARRAY(attribs, req->numAttribs << 1);

    return __glXDisp_CreatePbuffer(cl, pc);
}

int
__glXDispSwap_CreateGLXPbufferSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreateGLXPbufferSGIXReq *req = (xGLXCreateGLXPbufferSGIXReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_AT_LEAST_SIZE(xGLXCreateGLXPbufferSGIXReq);

    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->fbconfig);
    __GLX_SWAP_INT(&req->pbuffer);
    __GLX_SWAP_INT(&req->width);
    __GLX_SWAP_INT(&req->height);

    return __glXDisp_CreateGLXPbufferSGIX(cl, pc);
}

int
__glXDispSwap_DestroyPbuffer(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyPbufferReq *req = (xGLXDestroyPbufferReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXDestroyPbufferReq);

    __GLX_SWAP_INT(&req->pbuffer);

    return __glXDisp_DestroyPbuffer(cl, pc);
}

int
__glXDispSwap_DestroyGLXPbufferSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyGLXPbufferSGIXReq *req = (xGLXDestroyGLXPbufferSGIXReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXDestroyGLXPbufferSGIXReq);

    __GLX_SWAP_INT(&req->pbuffer);

    return __glXDisp_DestroyGLXPbufferSGIX(cl, pc);
}

int
__glXDispSwap_ChangeDrawableAttributes(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXChangeDrawableAttributesReq *req =
        (xGLXChangeDrawableAttributesReq *) pc;
    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
    CARD32 *attribs;

    REQUEST_AT_LEAST_SIZE(xGLXChangeDrawableAttributesReq);

    __GLX_SWAP_INT(&req->drawable);
    __GLX_SWAP_INT(&req->numAttribs);

    if (req->numAttribs > (UINT32_MAX >> 3)) {
        client->errorValue = req->numAttribs;
        return BadValue;
    }
    if (((sizeof(xGLXChangeDrawableAttributesReq) +
          (req->numAttribs << 3)) >> 2) < client->req_len)
        return BadLength;

    attribs = (CARD32 *) (req + 1);
    __GLX_SWAP_INT_ARRAY(attribs, req->numAttribs << 1);

    return __glXDisp_ChangeDrawableAttributes(cl, pc);
}

int
__glXDispSwap_ChangeDrawableAttributesSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXChangeDrawableAttributesSGIXReq *req =
        (xGLXChangeDrawableAttributesSGIXReq *) pc;
    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
    CARD32 *attribs;

    REQUEST_AT_LEAST_SIZE(xGLXChangeDrawableAttributesSGIXReq);

    __GLX_SWAP_INT(&req->drawable);
    __GLX_SWAP_INT(&req->numAttribs);

    if (req->numAttribs > (UINT32_MAX >> 3)) {
        client->errorValue = req->numAttribs;
        return BadValue;
    }
    REQUEST_FIXED_SIZE(xGLXChangeDrawableAttributesSGIXReq,
                       req->numAttribs << 3);
    attribs = (CARD32 *) (req + 1);
    __GLX_SWAP_INT_ARRAY(attribs, req->numAttribs << 1);

    return __glXDisp_ChangeDrawableAttributesSGIX(cl, pc);
}

int
__glXDispSwap_CreateWindow(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreateWindowReq *req = (xGLXCreateWindowReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
    CARD32 *attribs;

    REQUEST_AT_LEAST_SIZE(xGLXCreateWindowReq);

    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->fbconfig);
    __GLX_SWAP_INT(&req->window);
    __GLX_SWAP_INT(&req->glxwindow);
    __GLX_SWAP_INT(&req->numAttribs);

    if (req->numAttribs > (UINT32_MAX >> 3)) {
        client->errorValue = req->numAttribs;
        return BadValue;
    }
    REQUEST_FIXED_SIZE(xGLXCreateWindowReq, req->numAttribs << 3);
    attribs = (CARD32 *) (req + 1);
    __GLX_SWAP_INT_ARRAY(attribs, req->numAttribs << 1);

    return __glXDisp_CreateWindow(cl, pc);
}

int
__glXDispSwap_DestroyWindow(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyWindowReq *req = (xGLXDestroyWindowReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_AT_LEAST_SIZE(xGLXDestroyWindowReq);

    __GLX_SWAP_INT(&req->glxwindow);

    return __glXDisp_DestroyWindow(cl, pc);
}

int
__glXDispSwap_SwapBuffers(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXSwapBuffersReq *req = (xGLXSwapBuffersReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXSwapBuffersReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);
    __GLX_SWAP_INT(&req->drawable);

    return __glXDisp_SwapBuffers(cl, pc);
}

int
__glXDispSwap_UseXFont(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXUseXFontReq *req = (xGLXUseXFontReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXUseXFontReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);
    __GLX_SWAP_INT(&req->font);
    __GLX_SWAP_INT(&req->first);
    __GLX_SWAP_INT(&req->count);
    __GLX_SWAP_INT(&req->listBase);

    return __glXDisp_UseXFont(cl, pc);
}

int
__glXDispSwap_QueryExtensionsString(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXQueryExtensionsStringReq *req = (xGLXQueryExtensionsStringReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXQueryExtensionsStringReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->screen);

    return __glXDisp_QueryExtensionsString(cl, pc);
}

int
__glXDispSwap_QueryServerString(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXQueryServerStringReq *req = (xGLXQueryServerStringReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXQueryServerStringReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->name);

    return __glXDisp_QueryServerString(cl, pc);
}

int
__glXDispSwap_ClientInfo(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXClientInfoReq *req = (xGLXClientInfoReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_AT_LEAST_SIZE(xGLXClientInfoReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->major);
    __GLX_SWAP_INT(&req->minor);
    __GLX_SWAP_INT(&req->numbytes);

    return __glXDisp_ClientInfo(cl, pc);
}

int
__glXDispSwap_QueryContextInfoEXT(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXQueryContextInfoEXTReq *req = (xGLXQueryContextInfoEXTReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXQueryContextInfoEXTReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->context);

    return __glXDisp_QueryContextInfoEXT(cl, pc);
}

int
__glXDispSwap_BindTexImageEXT(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;
    GLXDrawable *drawId;
    int *buffer;
    CARD32 *num_attribs;

    __GLX_DECLARE_SWAP_VARIABLES;

    if ((sizeof(xGLXVendorPrivateReq) + 12) >> 2 > client->req_len)
        return BadLength;

    pc += __GLX_VENDPRIV_HDR_SIZE;

    drawId = ((GLXDrawable *) (pc));
    buffer = ((int *) (pc + 4));
    num_attribs = ((CARD32 *) (pc + 8));

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);
    __GLX_SWAP_INT(drawId);
    __GLX_SWAP_INT(buffer);
    __GLX_SWAP_INT(num_attribs);

    return __glXDisp_BindTexImageEXT(cl, (GLbyte *) pc);
}

int
__glXDispSwap_ReleaseTexImageEXT(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;
    GLXDrawable *drawId;
    int *buffer;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 8);

    pc += __GLX_VENDPRIV_HDR_SIZE;

    drawId = ((GLXDrawable *) (pc));
    buffer = ((int *) (pc + 4));

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);
    __GLX_SWAP_INT(drawId);
    __GLX_SWAP_INT(buffer);

    return __glXDisp_ReleaseTexImageEXT(cl, (GLbyte *) pc);
}

int
__glXDispSwap_CopySubBufferMESA(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;
    GLXDrawable *drawId;
    int *buffer;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 20);

    (void) drawId;
    (void) buffer;

    pc += __GLX_VENDPRIV_HDR_SIZE;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);
    __GLX_SWAP_INT(pc);
    __GLX_SWAP_INT(pc + 4);
    __GLX_SWAP_INT(pc + 8);
    __GLX_SWAP_INT(pc + 12);
    __GLX_SWAP_INT(pc + 16);

    return __glXDisp_CopySubBufferMESA(cl, pc);

}

int
__glXDispSwap_GetDrawableAttributesSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXVendorPrivateWithReplyReq *req = (xGLXVendorPrivateWithReplyReq *) pc;
    CARD32 *data;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXGetDrawableAttributesSGIXReq);

    data = (CARD32 *) (req + 1);
    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);
    __GLX_SWAP_INT(data);

    return __glXDisp_GetDrawableAttributesSGIX(cl, pc);
}

int
__glXDispSwap_GetDrawableAttributes(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXGetDrawableAttributesReq *req = (xGLXGetDrawableAttributesReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_AT_LEAST_SIZE(xGLXGetDrawableAttributesReq);

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->drawable);

    return __glXDisp_GetDrawableAttributes(cl, pc);
}

/************************************************************************/

/*
** Swap replies.
*/

void
__glXSwapMakeCurrentReply(ClientPtr client, xGLXMakeCurrentReply * reply)
{
    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->contextTag);
    WriteToClient(client, sz_xGLXMakeCurrentReply, reply);
}

void
__glXSwapIsDirectReply(ClientPtr client, xGLXIsDirectReply * reply)
{
    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    WriteToClient(client, sz_xGLXIsDirectReply, reply);
}

void
__glXSwapQueryVersionReply(ClientPtr client, xGLXQueryVersionReply * reply)
{
    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->majorVersion);
    __GLX_SWAP_INT(&reply->minorVersion);
    WriteToClient(client, sz_xGLXQueryVersionReply, reply);
}

void
glxSwapQueryExtensionsStringReply(ClientPtr client,
                                  xGLXQueryExtensionsStringReply * reply,
                                  char *buf)
{
    int length = reply->length;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->n);
    WriteToClient(client, sz_xGLXQueryExtensionsStringReply, reply);
    __GLX_SWAP_INT_ARRAY((int *) buf, length);
    WriteToClient(client, length << 2, buf);
}

void
glxSwapQueryServerStringReply(ClientPtr client,
                              xGLXQueryServerStringReply * reply, char *buf)
{
    int length = reply->length;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->n);
    WriteToClient(client, sz_xGLXQueryServerStringReply, reply);
    /** no swap is needed for an array of chars **/
    /* __GLX_SWAP_INT_ARRAY((int *)buf, length); */
    WriteToClient(client, length << 2, buf);
}

void
__glXSwapQueryContextInfoEXTReply(ClientPtr client,
                                  xGLXQueryContextInfoEXTReply * reply,
                                  int *buf)
{
    int length = reply->length;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->n);
    WriteToClient(client, sz_xGLXQueryContextInfoEXTReply, reply);
    __GLX_SWAP_INT_ARRAY((int *) buf, length);
    WriteToClient(client, length << 2, buf);
}

void
__glXSwapGetDrawableAttributesReply(ClientPtr client,
                                    xGLXGetDrawableAttributesReply * reply,
                                    CARD32 *buf)
{
    int length = reply->length;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->numAttribs);
    WriteToClient(client, sz_xGLXGetDrawableAttributesReply, reply);
    __GLX_SWAP_INT_ARRAY((int *) buf, length);
    WriteToClient(client, length << 2, buf);
}

/************************************************************************/

/*
** Render and Renderlarge are not in the GLX API.  They are used by the GLX
** client library to send batches of GL rendering commands.
*/

int
__glXDispSwap_Render(__GLXclientState * cl, GLbyte * pc)
{
    return __glXDisp_Render(cl, pc);
}

/*
** Execute a large rendering request (one that spans multiple X requests).
*/
int
__glXDispSwap_RenderLarge(__GLXclientState * cl, GLbyte * pc)
{
    return __glXDisp_RenderLarge(cl, pc);
}

/************************************************************************/

/*
** No support is provided for the vendor-private requests other than
** allocating these entry points in the dispatch table.
*/

int
__glXDispSwap_VendorPrivate(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXVendorPrivateReq *req;
    GLint vendorcode;
    __GLXdispatchVendorPrivProcPtr proc;

    __GLX_DECLARE_SWAP_VARIABLES;
    REQUEST_AT_LEAST_SIZE(xGLXVendorPrivateReq);

    req = (xGLXVendorPrivateReq *) pc;
    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->vendorCode);

    vendorcode = req->vendorCode;

    proc = (__GLXdispatchVendorPrivProcPtr)
        __glXGetProtocolDecodeFunction(&VendorPriv_dispatch_info,
                                       vendorcode, 1);
    if (proc != NULL) {
        (*proc) (cl, (GLbyte *) req);
        return Success;
    }

    cl->client->errorValue = req->vendorCode;
    return __glXError(GLXUnsupportedPrivateRequest);
}

int
__glXDispSwap_VendorPrivateWithReply(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXVendorPrivateWithReplyReq *req;
    GLint vendorcode;
    __GLXdispatchVendorPrivProcPtr proc;

    __GLX_DECLARE_SWAP_VARIABLES;
    REQUEST_AT_LEAST_SIZE(xGLXVendorPrivateWithReplyReq);

    req = (xGLXVendorPrivateWithReplyReq *) pc;
    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->vendorCode);

    vendorcode = req->vendorCode;

    proc = (__GLXdispatchVendorPrivProcPtr)
        __glXGetProtocolDecodeFunction(&VendorPriv_dispatch_info,
                                       vendorcode, 1);
    if (proc != NULL) {
        return (*proc) (cl, (GLbyte *) req);
    }

    cl->client->errorValue = req->vendorCode;
    return __glXError(GLXUnsupportedPrivateRequest);
}
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d961 1
d967 1
d990 1
d996 1
@


1.7.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a960 1
    ClientPtr client = cl->client;
a965 1
    REQUEST_AT_LEAST_SIZE(xGLXVendorPrivateReq);
a987 1
    ClientPtr client = cl->client;
a992 1
    REQUEST_AT_LEAST_SIZE(xGLXVendorPrivateWithReplyReq);
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a42 4
#include "glapitable.h"
#include "glapi.h"
#include "glthread.h"
#include "dispatch.h"
@


1.6.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a964 1
    ClientPtr client = cl->client;
a969 1
    REQUEST_AT_LEAST_SIZE(xGLXVendorPrivateReq);
a991 1
    ClientPtr client = cl->client;
a996 1
    REQUEST_AT_LEAST_SIZE(xGLXVendorPrivateWithReplyReq);
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d843 1
a843 1
    WriteToClient(client, sz_xGLXMakeCurrentReply, (char *) reply);
d852 1
a852 1
    WriteToClient(client, sz_xGLXIsDirectReply, (char *) reply);
d863 1
a863 1
    WriteToClient(client, sz_xGLXQueryVersionReply, (char *) reply);
d878 1
a878 1
    WriteToClient(client, sz_xGLXQueryExtensionsStringReply, (char *) reply);
d893 1
a893 1
    WriteToClient(client, sz_xGLXQueryServerStringReply, (char *) reply);
d911 1
a911 1
    WriteToClient(client, sz_xGLXQueryContextInfoEXTReply, (char *) reply);
d913 1
a913 1
    WriteToClient(client, length << 2, (char *) buf);
d928 1
a928 1
    WriteToClient(client, sz_xGLXGetDrawableAttributesReply, (char *) reply);
d930 1
a930 1
    WriteToClient(client, length << 2, (char *) buf);
@


1.4
log
@Update to xserver 1.11.2
@
text
@a50 1

d60 2
a61 1
int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc)
d65 1
d79 2
a80 1
int __glXDispSwap_CreateNewContext(__GLXclientState *cl, GLbyte *pc)
d84 1
d99 2
a100 1
int __glXDispSwap_CreateContextWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)
d104 1
a104 1
	(xGLXCreateContextWithConfigSGIXReq *) pc;
d119 2
a120 1
int __glXDispSwap_DestroyContext(__GLXclientState *cl, GLbyte *pc)
d124 1
d135 2
a136 1
int __glXDispSwap_MakeCurrent(__GLXclientState *cl, GLbyte *pc)
d140 1
d153 2
a154 1
int __glXDispSwap_MakeContextCurrent(__GLXclientState *cl, GLbyte *pc)
d158 1
d172 2
a173 1
int __glXDispSwap_MakeCurrentReadSGI(__GLXclientState *cl, GLbyte *pc)
d177 1
d191 2
a192 1
int __glXDispSwap_IsDirect(__GLXclientState *cl, GLbyte *pc)
d196 1
d207 2
a208 1
int __glXDispSwap_QueryVersion(__GLXclientState *cl, GLbyte *pc)
d212 1
d224 2
a225 1
int __glXDispSwap_WaitGL(__GLXclientState *cl, GLbyte *pc)
d229 1
d240 2
a241 1
int __glXDispSwap_WaitX(__GLXclientState *cl, GLbyte *pc)
d245 1
d256 2
a257 1
int __glXDispSwap_CopyContext(__GLXclientState *cl, GLbyte *pc)
d261 1
d274 2
a275 1
int __glXDispSwap_GetVisualConfigs(__GLXclientState *cl, GLbyte *pc)
d279 1
d288 2
a289 1
int __glXDispSwap_GetFBConfigs(__GLXclientState *cl, GLbyte *pc)
d293 1
d302 2
a303 1
int __glXDispSwap_GetFBConfigsSGIX(__GLXclientState *cl, GLbyte *pc)
d307 1
d316 2
a317 1
int __glXDispSwap_CreateGLXPixmap(__GLXclientState *cl, GLbyte *pc)
d321 1
d335 2
a336 1
int __glXDispSwap_CreatePixmap(__GLXclientState *cl, GLbyte *pc)
d341 1
d355 2
a356 2
	client->errorValue = req->numAttribs;
	return BadValue;
d359 1
a359 1
    attribs = (CARD32*)(req + 1);
d365 2
a366 1
int __glXDispSwap_CreateGLXPixmapWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)
d369 2
a370 2
    xGLXCreateGLXPixmapWithConfigSGIXReq *req = 
	(xGLXCreateGLXPixmapWithConfigSGIXReq *) pc;
d384 2
a385 1
int __glXDispSwap_DestroyGLXPixmap(__GLXclientState *cl, GLbyte *pc)
d389 1
d400 2
a401 1
int __glXDispSwap_DestroyPixmap(__GLXclientState *cl, GLbyte *pc)
d405 1
d416 2
a417 1
int __glXDispSwap_QueryContext(__GLXclientState *cl, GLbyte *pc)
d420 2
a421 1
    xGLXQueryContextReq *req = (xGLXQueryContextReq *) pc;    
d431 2
a432 1
int __glXDispSwap_CreatePbuffer(__GLXclientState *cl, GLbyte *pc)
d435 2
a436 1
    xGLXCreatePbufferReq *req = (xGLXCreatePbufferReq *) pc;    
d449 2
a450 2
	client->errorValue = req->numAttribs;
	return BadValue;
d453 1
a453 1
    attribs = (CARD32*)(req + 1);
d459 2
a460 1
int __glXDispSwap_CreateGLXPbufferSGIX(__GLXclientState *cl, GLbyte *pc)
d463 2
a464 1
    xGLXCreateGLXPbufferSGIXReq *req = (xGLXCreateGLXPbufferSGIXReq *) pc;    
d478 2
a479 1
int __glXDispSwap_DestroyPbuffer(__GLXclientState *cl, GLbyte *pc)
d483 1
d493 2
a494 1
int __glXDispSwap_DestroyGLXPbufferSGIX(__GLXclientState *cl, GLbyte *pc)
d498 1
d508 2
a509 1
int __glXDispSwap_ChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
d513 1
a513 1
	(xGLXChangeDrawableAttributesReq *) pc;
d524 2
a525 2
	client->errorValue = req->numAttribs;
	return BadValue;
d527 3
a529 2
    if (((sizeof(xGLXChangeDrawableAttributesReq) + (req->numAttribs << 3)) >> 2) < client->req_len)
	return BadLength;
d531 1
a531 1
    attribs = (CARD32*)(req + 1);
d537 2
a538 2
int __glXDispSwap_ChangeDrawableAttributesSGIX(__GLXclientState *cl,
					       GLbyte *pc)
d542 1
a542 1
	(xGLXChangeDrawableAttributesSGIXReq *) pc;
d553 2
a554 2
	client->errorValue = req->numAttribs;
	return BadValue;
d556 3
a558 2
    REQUEST_FIXED_SIZE(xGLXChangeDrawableAttributesSGIXReq, req->numAttribs << 3);
    attribs = (CARD32*)(req + 1);
d564 2
a565 1
int __glXDispSwap_CreateWindow(__GLXclientState *cl, GLbyte *pc)
d569 1
d583 2
a584 2
	client->errorValue = req->numAttribs;
	return BadValue;
d587 1
a587 1
    attribs = (CARD32*)(req + 1);
d593 2
a594 1
int __glXDispSwap_DestroyWindow(__GLXclientState *cl, GLbyte *pc)
d598 1
d608 2
a609 1
int __glXDispSwap_SwapBuffers(__GLXclientState *cl, GLbyte *pc)
d613 1
d625 2
a626 1
int __glXDispSwap_UseXFont(__GLXclientState *cl, GLbyte *pc)
d630 1
d645 2
a646 2

int __glXDispSwap_QueryExtensionsString(__GLXclientState *cl, GLbyte *pc)
d649 2
a650 1
    xGLXQueryExtensionsStringReq *req = (xGLXQueryExtensionsStringReq *)pc;
d661 2
a662 1
int __glXDispSwap_QueryServerString(__GLXclientState *cl, GLbyte *pc)
d665 2
a666 1
    xGLXQueryServerStringReq *req = (xGLXQueryServerStringReq *)pc;
d678 2
a679 1
int __glXDispSwap_ClientInfo(__GLXclientState *cl, GLbyte *pc)
d682 2
a683 1
    xGLXClientInfoReq *req = (xGLXClientInfoReq *)pc;
d696 2
a697 1
int __glXDispSwap_QueryContextInfoEXT(__GLXclientState *cl, GLbyte *pc)
d701 1
d712 2
a713 1
int __glXDispSwap_BindTexImageEXT(__GLXclientState *cl, GLbyte *pc)
d717 4
a720 3
    GLXDrawable		 *drawId;
    int			 *buffer;
    CARD32		 *num_attribs;
d724 1
a724 1
	return BadLength;
d729 1
a729 1
    buffer = ((int *)	      (pc + 4));
d731 1
a731 1
    
d738 1
a738 1
    return __glXDisp_BindTexImageEXT(cl, (GLbyte *)pc);
d741 2
a742 1
int __glXDispSwap_ReleaseTexImageEXT(__GLXclientState *cl, GLbyte *pc)
d746 3
a748 2
    GLXDrawable		 *drawId;
    int			 *buffer;
d756 2
a757 2
    buffer = ((int *)	      (pc + 4));
    
d763 1
a763 1
    return __glXDisp_ReleaseTexImageEXT(cl, (GLbyte *)pc);
d766 2
a767 1
int __glXDispSwap_CopySubBufferMESA(__GLXclientState *cl, GLbyte *pc)
d771 3
a773 2
    GLXDrawable		 *drawId;
    int			 *buffer;
d795 2
a796 1
int __glXDispSwap_GetDrawableAttributesSGIX(__GLXclientState *cl, GLbyte *pc)
d799 1
a799 1
    xGLXVendorPrivateWithReplyReq *req = (xGLXVendorPrivateWithReplyReq *)pc;
d801 1
d814 2
a815 1
int __glXDispSwap_GetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
d818 2
a819 1
    xGLXGetDrawableAttributesReq *req = (xGLXGetDrawableAttributesReq *)pc;
a829 1

d836 2
a837 1
void __glXSwapMakeCurrentReply(ClientPtr client, xGLXMakeCurrentReply *reply)
d843 1
a843 1
    WriteToClient(client, sz_xGLXMakeCurrentReply, (char *)reply);
d846 2
a847 1
void __glXSwapIsDirectReply(ClientPtr client, xGLXIsDirectReply *reply)
d852 1
a852 1
    WriteToClient(client, sz_xGLXIsDirectReply, (char *)reply);
d855 2
a856 1
void __glXSwapQueryVersionReply(ClientPtr client, xGLXQueryVersionReply *reply)
d863 1
a863 1
    WriteToClient(client, sz_xGLXQueryVersionReply, (char *)reply);
d866 4
a869 2
void glxSwapQueryExtensionsStringReply(ClientPtr client,
				       xGLXQueryExtensionsStringReply *reply, char *buf)
d872 1
d878 2
a879 2
    WriteToClient(client, sz_xGLXQueryExtensionsStringReply, (char *)reply);
    __GLX_SWAP_INT_ARRAY((int *)buf, length);
d883 3
a885 2
void glxSwapQueryServerStringReply(ClientPtr client,
				   xGLXQueryServerStringReply *reply, char *buf)
d888 1
d893 1
a893 1
    WriteToClient(client, sz_xGLXQueryServerStringReply, (char *)reply);
d899 4
a902 1
void __glXSwapQueryContextInfoEXTReply(ClientPtr client, xGLXQueryContextInfoEXTReply *reply, int *buf)
d905 1
d911 3
a913 3
    WriteToClient(client, sz_xGLXQueryContextInfoEXTReply, (char *)reply);
    __GLX_SWAP_INT_ARRAY((int *)buf, length);
    WriteToClient(client, length << 2, (char *)buf);
d916 4
a919 2
void __glXSwapGetDrawableAttributesReply(ClientPtr client,
					 xGLXGetDrawableAttributesReply *reply, CARD32 *buf)
d922 1
d928 3
a930 3
    WriteToClient(client, sz_xGLXGetDrawableAttributesReply, (char *)reply);
    __GLX_SWAP_INT_ARRAY((int *)buf, length);
    WriteToClient(client, length << 2, (char *)buf);
d940 2
a941 1
int __glXDispSwap_Render(__GLXclientState *cl, GLbyte *pc)
d949 2
a950 1
int __glXDispSwap_RenderLarge(__GLXclientState *cl, GLbyte *pc)
d962 2
a963 1
int __glXDispSwap_VendorPrivate(__GLXclientState *cl, GLbyte *pc)
d978 2
a979 2
      __glXGetProtocolDecodeFunction(& VendorPriv_dispatch_info,
				     vendorcode, 1);
d981 2
a982 2
	(*proc)(cl, (GLbyte*)req);
	return Success;
d989 2
a990 2

int __glXDispSwap_VendorPrivateWithReply(__GLXclientState *cl, GLbyte *pc)
d1005 2
a1006 2
      __glXGetProtocolDecodeFunction(& VendorPriv_dispatch_info,
				     vendorcode, 1);
d1008 1
a1008 1
	return (*proc)(cl, (GLbyte*)req);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a39 1
#include "g_disptab.h"
d63 1
d67 2
d80 1
d84 2
d98 1
d103 2
d117 1
d121 2
d131 1
d135 2
d147 1
d151 2
d164 1
d168 2
d181 1
d185 2
d195 1
d199 2
d210 1
d214 2
d224 1
d228 2
d238 1
d242 2
d254 1
d258 2
d266 1
d270 2
d278 1
d282 2
d290 1
d294 2
d307 1
d313 2
d321 6
d328 1
a328 1
    __GLX_SWAP_INT_ARRAY(attribs, req->numAttribs);
d335 1
d340 2
d353 1
d357 2
d367 1
d371 2
d381 1
d385 2
d394 1
d400 2
d406 6
d413 1
a413 1
    __GLX_SWAP_INT_ARRAY(attribs, req->numAttribs);
d420 1
d424 2
d437 1
d441 2
d450 1
d454 2
d463 1
d470 2
d474 8
d483 1
a483 1
    __GLX_SWAP_INT_ARRAY(attribs, req->numAttribs);
d491 1
d498 2
d502 6
d509 1
a509 1
    __GLX_SWAP_INT_ARRAY(attribs, req->numAttribs);
d516 1
d522 2
d529 6
d536 1
a536 1
    __GLX_SWAP_INT_ARRAY(attribs, req->numAttribs);
d543 1
d547 2
d556 1
d560 2
d571 1
d575 2
d590 1
d594 2
d604 1
d608 2
d619 1
d623 2
d635 1
d639 2
d649 1
d653 1
a653 1
    
d656 3
d663 1
d669 1
d676 1
a679 1
    
d682 2
d699 1
d703 1
d705 1
a705 1
    __GLX_DECLARE_SWAP_VARIABLES;
d726 1
a728 1
    
d731 2
d743 1
a744 1
    
d746 2
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a30 2
#define NEED_REPLIES
#define FONT_PCF
d357 1
a357 1
    xGLXDestroyPbufferReq *req = (xGLXDestroyPbufferReq *) req;
d367 1
a367 1
    xGLXDestroyGLXPbufferSGIXReq *req = (xGLXDestroyGLXPbufferSGIXReq *) req;
d378 1
a378 1
	(xGLXChangeDrawableAttributesReq *) req;
d395 1
a395 1
	(xGLXChangeDrawableAttributesSGIXReq *) req;
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d2 28
a29 33
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: The application programming interfaces
** established by SGI in conjunction with the Original Code are The
** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
** Window System(R) (Version 1.3), released October 19, 1998. This software
** was created using the OpenGL(R) version 1.2.1 Sample Implementation
** published by SGI, but has not been independently verified as being
** compliant with the OpenGL(R) version 1.2.1 Specification.
**
*/
@

