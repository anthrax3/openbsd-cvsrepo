head	1.13;
access;
symbols
	OPENBSD_5_5:1.12.0.2
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2014.05.02.19.27.47;	author matthieu;	state dead;
branches;
next	1.12;

1.12
date	2013.09.28.15.36.34;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.08.24.19.44.32;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.21.20.10.46;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.20.05.00.14;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@/*
 * Copyright Â© 2006 Red Hat, Inc
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without
 * fee, provided that the above copyright notice appear in all copies
 * and that both that copyright notice and this permission notice
 * appear in supporting documentation, and that the name of Red Hat,
 * Inc not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior
 * permission.  Red Hat, Inc makes no representations about the
 * suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * RED HAT, INC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
 * NO EVENT SHALL RED HAT, INC BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
 * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <sys/time.h>
#include <dlfcn.h>

#include <drm.h>
#include <GL/gl.h>
#include <GL/internal/dri_interface.h>
#include <GL/glxtokens.h>

#include <windowstr.h>
#include <os.h>
#include <damage.h>

#define _XF86DRI_SERVER_
#include <drm_sarea.h>
#include <xf86drm.h>
#include <X11/dri/xf86driproto.h>
#include <xf86str.h>
#include <xf86.h>
#include <dri.h>

#include "servermd.h"

#define DRI_NEW_INTERFACE_ONLY
#include "glxserver.h"
#include "glxutil.h"
#include "glxdricommon.h"

#include "glapitable.h"
#include "glapi.h"
#include "glthread.h"
#include "dispatch.h"
#include "extension_string.h"

typedef struct __GLXDRIscreen __GLXDRIscreen;
typedef struct __GLXDRIcontext __GLXDRIcontext;
typedef struct __GLXDRIdrawable __GLXDRIdrawable;

struct __GLXDRIscreen {
    __GLXscreen base;
    __DRIscreen *driScreen;
    void *driver;

    xf86EnterVTProc *enterVT;
    xf86LeaveVTProc *leaveVT;

    const __DRIcoreExtension *core;
    const __DRIlegacyExtension *legacy;
    const __DRIcopySubBufferExtension *copySubBuffer;
    const __DRIswapControlExtension *swapControl;
    const __DRIconfig **driConfigs;

#ifdef __DRI_TEX_OFFSET
    const __DRItexOffsetExtension *texOffset;
    DRITexOffsetStartProcPtr texOffsetStart;
    DRITexOffsetFinishProcPtr texOffsetFinish;
    __GLXDRIdrawable *texOffsetOverride[16];
    GLuint lastTexOffsetOverride;
#endif

    unsigned char glx_enable_bits[__GLX_EXT_BYTES];
};

struct __GLXDRIcontext {
    __GLXcontext base;
    __DRIcontext *driContext;
    XID hwContextID;
};

struct __GLXDRIdrawable {
    __GLXdrawable base;
    __DRIdrawable *driDrawable;

    /* Pulled in from old __GLXpixmap */
#ifdef __DRI_TEX_OFFSET
    GLint texname;
    __GLXDRIcontext *ctx;
    unsigned long long offset;
    DamagePtr pDamage;
#endif
};

static void
__glXDRIleaveServer(GLboolean rendering)
{
    int i;

    for (i = 0; rendering && i < screenInfo.numScreens; i++) {
        __GLXDRIscreen *const screen =
            (__GLXDRIscreen *) glxGetScreen(screenInfo.screens[i]);
        GLuint lastOverride = screen->lastTexOffsetOverride;

        if (lastOverride) {
            __GLXDRIdrawable **texOffsetOverride = screen->texOffsetOverride;
            int j;

            for (j = 0; j < lastOverride; j++) {
                __GLXDRIdrawable *pGlxPix = texOffsetOverride[j];

                if (pGlxPix && pGlxPix->texname) {
                    pGlxPix->offset =
                        screen->texOffsetStart((PixmapPtr) pGlxPix->base.pDraw);
                }
            }
        }
    }

    DRIBlockHandler(NULL, NULL, NULL);

    for (i = 0; rendering && i < screenInfo.numScreens; i++) {
        __GLXDRIscreen *const screen =
            (__GLXDRIscreen *) glxGetScreen(screenInfo.screens[i]);
        GLuint lastOverride = screen->lastTexOffsetOverride;

        if (lastOverride) {
            __GLXDRIdrawable **texOffsetOverride = screen->texOffsetOverride;
            int j;

            for (j = 0; j < lastOverride; j++) {
                __GLXDRIdrawable *pGlxPix = texOffsetOverride[j];

                if (pGlxPix && pGlxPix->texname) {
                    screen->texOffset->setTexOffset(pGlxPix->ctx->driContext,
                                                    pGlxPix->texname,
                                                    pGlxPix->offset,
                                                    pGlxPix->base.pDraw->depth,
                                                    ((PixmapPtr) pGlxPix->base.
                                                     pDraw)->devKind);
                }
            }
        }
    }
}

static void
__glXDRIenterServer(GLboolean rendering)
{
    int i;

    for (i = 0; rendering && i < screenInfo.numScreens; i++) {
        __GLXDRIscreen *const screen = (__GLXDRIscreen *)
            glxGetScreen(screenInfo.screens[i]);

        if (screen->lastTexOffsetOverride) {
            CALL_Flush(GET_DISPATCH(), ());
            break;
        }
    }

    DRIWakeupHandler(NULL, 0, NULL);
}

static void
__glXDRIdoReleaseTexImage(__GLXDRIscreen * screen, __GLXDRIdrawable * drawable)
{
    GLuint lastOverride = screen->lastTexOffsetOverride;

    if (lastOverride) {
        __GLXDRIdrawable **texOffsetOverride = screen->texOffsetOverride;
        int i;

        for (i = 0; i < lastOverride; i++) {
            if (texOffsetOverride[i] == drawable) {
                if (screen->texOffsetFinish)
                    screen->texOffsetFinish((PixmapPtr) drawable->base.pDraw);

                texOffsetOverride[i] = NULL;

                if (i + 1 == lastOverride) {
                    lastOverride = 0;

                    while (i--) {
                        if (texOffsetOverride[i]) {
                            lastOverride = i + 1;
                            break;
                        }
                    }

                    screen->lastTexOffsetOverride = lastOverride;

                    break;
                }
            }
        }
    }
}

static void
__glXDRIdrawableDestroy(__GLXdrawable * drawable)
{
    __GLXDRIdrawable *private = (__GLXDRIdrawable *) drawable;
    __GLXDRIscreen *screen;
    int i;

    for (i = 0; i < screenInfo.numScreens; i++) {
        screen = (__GLXDRIscreen *) glxGetScreen(screenInfo.screens[i]);
        __glXDRIdoReleaseTexImage(screen, private);
    }

    /* If the X window was destroyed, the dri DestroyWindow hook will
     * aready have taken care of this, so only call if pDraw isn't NULL. */
    if (drawable->pDraw != NULL) {
        screen = (__GLXDRIscreen *) glxGetScreen(drawable->pDraw->pScreen);
        (*screen->core->destroyDrawable) (private->driDrawable);

        __glXenterServer(GL_FALSE);
        DRIDestroyDrawable(drawable->pDraw->pScreen,
                           serverClient, drawable->pDraw);
        __glXleaveServer(GL_FALSE);
    }

    __glXDrawableRelease(drawable);

    free(private);
}

static GLboolean
__glXDRIdrawableSwapBuffers(ClientPtr client, __GLXdrawable * basePrivate)
{
    __GLXDRIdrawable *private = (__GLXDRIdrawable *) basePrivate;
    __GLXDRIscreen *screen =
        (__GLXDRIscreen *) glxGetScreen(basePrivate->pDraw->pScreen);

    (*screen->core->swapBuffers) (private->driDrawable);

    return TRUE;
}

static int
__glXDRIdrawableSwapInterval(__GLXdrawable * baseDrawable, int interval)
{
    __GLXDRIdrawable *draw = (__GLXDRIdrawable *) baseDrawable;
    __GLXDRIscreen *screen =
        (__GLXDRIscreen *) glxGetScreen(baseDrawable->pDraw->pScreen);

    if (screen->swapControl)
        screen->swapControl->setSwapInterval(draw->driDrawable, interval);

    return 0;
}

static void
__glXDRIdrawableCopySubBuffer(__GLXdrawable * basePrivate,
                              int x, int y, int w, int h)
{
    __GLXDRIdrawable *private = (__GLXDRIdrawable *) basePrivate;
    __GLXDRIscreen *screen = (__GLXDRIscreen *)
        glxGetScreen(basePrivate->pDraw->pScreen);

    if (screen->copySubBuffer)
        screen->copySubBuffer->copySubBuffer(private->driDrawable, x, y, w, h);
}

static void
__glXDRIcontextDestroy(__GLXcontext * baseContext)
{
    __GLXDRIcontext *context = (__GLXDRIcontext *) baseContext;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) context->base.pGlxScreen;
    Bool retval;

    screen->core->destroyContext(context->driContext);

    __glXenterServer(GL_FALSE);
    retval = DRIDestroyContext(baseContext->pGlxScreen->pScreen,
                               context->hwContextID);
    __glXleaveServer(GL_FALSE);

    __glXContextDestroy(&context->base);
    free(context);
}

static int
__glXDRIcontextMakeCurrent(__GLXcontext * baseContext)
{
    __GLXDRIcontext *context = (__GLXDRIcontext *) baseContext;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) context->base.pGlxScreen;
    __GLXDRIdrawable *draw = (__GLXDRIdrawable *) baseContext->drawPriv;
    __GLXDRIdrawable *read = (__GLXDRIdrawable *) baseContext->readPriv;

    return (*screen->core->bindContext) (context->driContext,
                                         draw->driDrawable, read->driDrawable);
}

static int
__glXDRIcontextLoseCurrent(__GLXcontext * baseContext)
{
    __GLXDRIcontext *context = (__GLXDRIcontext *) baseContext;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) context->base.pGlxScreen;

    return (*screen->core->unbindContext) (context->driContext);
}

static int
__glXDRIcontextCopy(__GLXcontext * baseDst, __GLXcontext * baseSrc,
                    unsigned long mask)
{
    __GLXDRIcontext *dst = (__GLXDRIcontext *) baseDst;
    __GLXDRIcontext *src = (__GLXDRIcontext *) baseSrc;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) dst->base.pGlxScreen;

    return (*screen->core->copyContext) (dst->driContext,
                                         src->driContext, mask);
}

static void
glxFillAlphaChannel(CARD32 *pixels, CARD32 rowstride, int width, int height)
{
    int i;
    CARD32 *p, *end;

    rowstride /= 4;

    for (i = 0; i < height; i++) {
        p = pixels;
        end = p + width;
        while (p < end)
            *p++ |= 0xFF000000;
        pixels += rowstride;
    }
}

static Bool
testTexOffset(__GLXDRIscreen * const screen, PixmapPtr pPixmap)
{
    Bool ret;

    if (!screen->texOffsetStart || !screen->texOffset)
        return FALSE;

    __glXenterServer(GL_FALSE);
    ret = screen->texOffsetStart(pPixmap) != ~0ULL;
    __glXleaveServer(GL_FALSE);

    return ret;
}

/*
 * (sticking this here for lack of a better place)
 * Known issues with the GLX_EXT_texture_from_pixmap implementation:
 * - In general we ignore the fbconfig, lots of examples follow
 * - No fbconfig handling for multiple mipmap levels
 * - No fbconfig handling for 1D textures
 * - No fbconfig handling for TEXTURE_TARGET
 * - No fbconfig exposure of Y inversion state
 * - No GenerateMipmapEXT support (due to no FBO support)
 * - No support for anything but 16bpp and 32bpp-sparse pixmaps
 */

static int
__glXDRIbindTexImage(__GLXcontext * baseContext,
                     int buffer, __GLXdrawable * glxPixmap)
{
    RegionPtr pRegion = NULL;
    PixmapPtr pixmap;
    int bpp, override = 0, texname;
    GLenum format, type;
    ScreenPtr pScreen = glxPixmap->pDraw->pScreen;
    __GLXDRIdrawable *driDraw = (__GLXDRIdrawable *) glxPixmap;
    __GLXDRIscreen *const screen = (__GLXDRIscreen *) glxGetScreen(pScreen);

    CALL_GetIntegerv(GET_DISPATCH(), (glxPixmap->target == GL_TEXTURE_2D ?
                                      GL_TEXTURE_BINDING_2D :
                                      GL_TEXTURE_BINDING_RECTANGLE_NV,
                                      &texname));

    if (!texname)
        return __glXError(GLXBadContextState);

    pixmap = (PixmapPtr) glxPixmap->pDraw;

    if (testTexOffset(screen, pixmap)) {
        __GLXDRIdrawable **texOffsetOverride = screen->texOffsetOverride;
        int i, firstEmpty = 16;

        for (i = 0; i < 16; i++) {
            if (texOffsetOverride[i] == driDraw)
                goto alreadyin;

            if (firstEmpty == 16 && !texOffsetOverride[i])
                firstEmpty = i;
        }

        if (firstEmpty == 16) {
            ErrorF("%s: Failed to register texture offset override\n",
                   __func__);
            goto nooverride;
        }

        if (firstEmpty >= screen->lastTexOffsetOverride)
            screen->lastTexOffsetOverride = firstEmpty + 1;

        texOffsetOverride[firstEmpty] = driDraw;

 alreadyin:
        override = 1;

        driDraw->ctx = (__GLXDRIcontext *) baseContext;

        if (texname == driDraw->texname)
            return Success;

        driDraw->texname = texname;

        screen->texOffset->setTexOffset(driDraw->ctx->driContext, texname, 0,
                                        pixmap->drawable.depth,
                                        pixmap->devKind);
    }
 nooverride:

    if (!driDraw->pDamage) {
        if (!override) {
            driDraw->pDamage = DamageCreate(NULL, NULL, DamageReportNone,
                                            TRUE, pScreen, NULL);
            if (!driDraw->pDamage)
                return BadAlloc;

            DamageRegister((DrawablePtr) pixmap, driDraw->pDamage);
        }

        pRegion = NULL;
    }
    else {
        pRegion = DamageRegion(driDraw->pDamage);
        if (RegionNil(pRegion))
            return Success;
    }

    /* XXX 24bpp packed, 8, etc */
    if (pixmap->drawable.depth >= 24) {
        bpp = 4;
        format = GL_BGRA;
        type =
#if X_BYTE_ORDER == X_BIG_ENDIAN
            !override ? GL_UNSIGNED_INT_8_8_8_8_REV :
#endif
            GL_UNSIGNED_BYTE;
    }
    else {
        bpp = 2;
        format = GL_RGB;
        type = GL_UNSIGNED_SHORT_5_6_5;
    }

    if (pRegion == NULL) {
        void *data = NULL;

        if (!override) {
            unsigned pitch = PixmapBytePad(pixmap->drawable.width,
                                           pixmap->drawable.depth);

            data = malloc(pitch * pixmap->drawable.height);

            __glXenterServer(GL_FALSE);
            pScreen->GetImage(&pixmap->drawable, 0 /*pixmap->drawable.x */ ,
                              0 /*pixmap->drawable.y */ ,
                              pixmap->drawable.width,
                              pixmap->drawable.height, ZPixmap, ~0, data);
            __glXleaveServer(GL_FALSE);

            if (pixmap->drawable.depth == 24)
                glxFillAlphaChannel(data,
                                    pitch,
                                    pixmap->drawable.width,
                                    pixmap->drawable.height);

            CALL_PixelStorei(GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,
                                              pitch / bpp));
            CALL_PixelStorei(GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS, 0));
            CALL_PixelStorei(GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS, 0));
        }

        CALL_TexImage2D(GET_DISPATCH(),
                        (glxPixmap->target,
                         0,
                         bpp == 4 ? 4 : 3,
                         pixmap->drawable.width,
                         pixmap->drawable.height, 0, format, type, data));

        free(data);
    }
    else if (!override) {
        int i, numRects;
        BoxPtr p;

        numRects = RegionNumRects(pRegion);
        p = RegionRects(pRegion);

        CALL_PixelStorei(GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS, 0));
        CALL_PixelStorei(GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS, 0));

        for (i = 0; i < numRects; i++) {
            unsigned pitch = PixmapBytePad(p[i].x2 - p[i].x1,
                                           pixmap->drawable.depth);
            void *data = malloc(pitch * (p[i].y2 - p[i].y1));

            __glXenterServer(GL_FALSE);
            pScreen->GetImage(&pixmap->drawable, /*pixmap->drawable.x + */
                              p[i].x1,
                              /*pixmap->drawable.y */ +p[i].y1,
                              p[i].x2 - p[i].x1,
                              p[i].y2 - p[i].y1, ZPixmap, ~0, data);
            __glXleaveServer(GL_FALSE);

            if (pixmap->drawable.depth == 24)
                glxFillAlphaChannel(data,
                                    pitch,
                                    p[i].x2 - p[i].x1, p[i].y2 - p[i].y1);

            CALL_PixelStorei(GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,
                                              pitch / bpp));

            CALL_TexSubImage2D(GET_DISPATCH(),
                               (glxPixmap->target,
                                0,
                                p[i].x1, p[i].y1,
                                p[i].x2 - p[i].x1, p[i].y2 - p[i].y1,
                                format, type, data));

            free(data);
        }
    }

    if (!override)
        DamageEmpty(driDraw->pDamage);

    return Success;
}

static int
__glXDRIreleaseTexImage(__GLXcontext * baseContext,
                        int buffer, __GLXdrawable * pixmap)
{
    __GLXDRIscreen *screen =
        (__GLXDRIscreen *) glxGetScreen(pixmap->pDraw->pScreen);
    __GLXDRIdrawable *drawable = (__GLXDRIdrawable *) pixmap;

    __glXDRIdoReleaseTexImage(screen, drawable);

    return Success;
}

static __GLXtextureFromPixmap __glXDRItextureFromPixmap = {
    __glXDRIbindTexImage,
    __glXDRIreleaseTexImage
};

static void
__glXDRIscreenDestroy(__GLXscreen * baseScreen)
{
    int i;

    __GLXDRIscreen *screen = (__GLXDRIscreen *) baseScreen;

    screen->core->destroyScreen(screen->driScreen);

    dlclose(screen->driver);

    __glXScreenDestroy(baseScreen);

    if (screen->driConfigs) {
        for (i = 0; screen->driConfigs[i] != NULL; i++)
            free((__DRIconfig **) screen->driConfigs[i]);
        free(screen->driConfigs);
    }

    free(screen);
}

static __GLXcontext *
__glXDRIscreenCreateContext(__GLXscreen * baseScreen,
                            __GLXconfig * glxConfig,
                            __GLXcontext * baseShareContext,
                            unsigned num_attribs,
                            const uint32_t *attribs,
                            int *error)
{
    __GLXDRIscreen *screen = (__GLXDRIscreen *) baseScreen;
    __GLXDRIcontext *context, *shareContext;
    __GLXDRIconfig *config = (__GLXDRIconfig *) glxConfig;
    VisualPtr visual;
    int i;
    GLboolean retval;
    __DRIcontext *driShare;
    drm_context_t hwContext;
    ScreenPtr pScreen = baseScreen->pScreen;

    /* DRI1 cannot support createContextAttribs, so these parameters will
     * never be used.
     */
    (void) num_attribs;
    (void) attribs;
    (void) error;

    shareContext = (__GLXDRIcontext *) baseShareContext;
    if (shareContext)
        driShare = shareContext->driContext;
    else
        driShare = NULL;

    if (baseShareContext && baseShareContext->isDirect)
        return NULL;

    context = calloc(1, sizeof *context);
    if (context == NULL)
        return NULL;

    context->base.destroy = __glXDRIcontextDestroy;
    context->base.makeCurrent = __glXDRIcontextMakeCurrent;
    context->base.loseCurrent = __glXDRIcontextLoseCurrent;
    context->base.copy = __glXDRIcontextCopy;

    context->base.textureFromPixmap = &__glXDRItextureFromPixmap;
    /* Find the requested X visual */
    visual = pScreen->visuals;
    for (i = 0; i < pScreen->numVisuals; i++, visual++)
        if (visual->vid == glxConfig->visualID)
            break;
    if (i == pScreen->numVisuals)
        return NULL;

    context->hwContextID = FakeClientID(0);

    __glXenterServer(GL_FALSE);
    retval = DRICreateContext(baseScreen->pScreen, visual,
                              context->hwContextID, &hwContext);
    __glXleaveServer(GL_FALSE);

    if (!retval)
        return NULL;

    context->driContext = screen->legacy->createNewContext(screen->driScreen, config->driConfig, 0,     /* render type */
                                                           driShare,
                                                           hwContext, context);

    if (context->driContext == NULL) {
        __glXenterServer(GL_FALSE);
        retval = DRIDestroyContext(baseScreen->pScreen, context->hwContextID);
        __glXleaveServer(GL_FALSE);
        free(context);
        return NULL;
    }

    return &context->base;
}

static __GLXdrawable *
__glXDRIscreenCreateDrawable(ClientPtr client,
                             __GLXscreen * screen,
                             DrawablePtr pDraw,
                             XID drawId,
                             int type, XID glxDrawId, __GLXconfig * glxConfig)
{
    __GLXDRIscreen *driScreen = (__GLXDRIscreen *) screen;
    __GLXDRIconfig *config = (__GLXDRIconfig *) glxConfig;
    __GLXDRIdrawable *private;
    GLboolean retval;
    drm_drawable_t hwDrawable;

    private = calloc(1, sizeof *private);
    if (private == NULL)
        return NULL;

    if (!__glXDrawableInit(&private->base, screen,
                           pDraw, type, glxDrawId, glxConfig)) {
        free(private);
        return NULL;
    }

    private->base.destroy = __glXDRIdrawableDestroy;
    private->base.swapBuffers = __glXDRIdrawableSwapBuffers;
    private->base.copySubBuffer = __glXDRIdrawableCopySubBuffer;
    private->base.waitX = NULL;
    private->base.waitGL = NULL;

    __glXenterServer(GL_FALSE);
    retval = DRICreateDrawable(screen->pScreen, serverClient,
                               pDraw, &hwDrawable);
    __glXleaveServer(GL_FALSE);

    if (!retval) {
        free(private);
        return NULL;
    }

    /* The last argument is 'attrs', which is used with pbuffers which
     * we currently don't support. */

    private->driDrawable =
        (driScreen->legacy->createNewDrawable) (driScreen->driScreen,
                                                config->driConfig,
                                                hwDrawable, 0, NULL, private);

    if (private->driDrawable == NULL) {
        __glXenterServer(GL_FALSE);
        DRIDestroyDrawable(screen->pScreen, serverClient, pDraw);
        __glXleaveServer(GL_FALSE);
        free(private);
        return NULL;
    }

    return &private->base;
}

static GLboolean
getDrawableInfo(__DRIdrawable * driDrawable,
                unsigned int *index, unsigned int *stamp,
                int *x, int *y, int *width, int *height,
                int *numClipRects, drm_clip_rect_t ** ppClipRects,
                int *backX, int *backY,
                int *numBackClipRects, drm_clip_rect_t ** ppBackClipRects,
                void *data)
{
    __GLXDRIdrawable *drawable = data;
    ScreenPtr pScreen;
    drm_clip_rect_t *pClipRects, *pBackClipRects;
    GLboolean retval;
    size_t size;

    /* If the X window has been destroyed, give up here. */
    if (drawable->base.pDraw == NULL)
        return GL_FALSE;

    pScreen = drawable->base.pDraw->pScreen;
    __glXenterServer(GL_FALSE);
    retval = DRIGetDrawableInfo(pScreen, drawable->base.pDraw, index, stamp,
                                x, y, width, height,
                                numClipRects, &pClipRects,
                                backX, backY,
                                numBackClipRects, &pBackClipRects);
    __glXleaveServer(GL_FALSE);

    if (retval && *numClipRects > 0) {
        size = sizeof(drm_clip_rect_t) * *numClipRects;
        *ppClipRects = malloc(size);

        /* Clip cliprects to screen dimensions (redirected windows) */
        if (*ppClipRects != NULL) {
            int i, j;

            for (i = 0, j = 0; i < *numClipRects; i++) {
                (*ppClipRects)[j].x1 = max(pClipRects[i].x1, 0);
                (*ppClipRects)[j].y1 = max(pClipRects[i].y1, 0);
                (*ppClipRects)[j].x2 = min(pClipRects[i].x2, pScreen->width);
                (*ppClipRects)[j].y2 = min(pClipRects[i].y2, pScreen->height);

                if ((*ppClipRects)[j].x1 < (*ppClipRects)[j].x2 &&
                    (*ppClipRects)[j].y1 < (*ppClipRects)[j].y2) {
                    j++;
                }
            }

            if (*numClipRects != j) {
                *numClipRects = j;
                *ppClipRects = realloc(*ppClipRects,
                                       sizeof(drm_clip_rect_t) * *numClipRects);
            }
        }
        else
            *numClipRects = 0;
    }
    else {
        *ppClipRects = NULL;
        *numClipRects = 0;
    }

    if (retval && *numBackClipRects > 0) {
        size = sizeof(drm_clip_rect_t) * *numBackClipRects;
        *ppBackClipRects = malloc(size);
        if (*ppBackClipRects != NULL)
            memcpy(*ppBackClipRects, pBackClipRects, size);
        else
            *numBackClipRects = 0;
    }
    else {
        *ppBackClipRects = NULL;
        *numBackClipRects = 0;
    }

    return retval;
}

static void
__glXReportDamage(__DRIdrawable * driDraw,
                  int x, int y,
                  drm_clip_rect_t * rects, int num_rects,
                  GLboolean front_buffer, void *data)
{
    __GLXDRIdrawable *drawable = data;
    DrawablePtr pDraw = drawable->base.pDraw;
    RegionRec region;

    __glXenterServer(GL_FALSE);

    if (RegionInitBoxes(&region, (BoxPtr) rects, num_rects)) {
        RegionTranslate(&region, pDraw->x, pDraw->y);
        DamageDamageRegion(pDraw, &region);
        RegionUninit(&region);
    }
    else {
        while (num_rects--) {
            RegionInit(&region, (BoxPtr) rects++, 1);
            RegionTranslate(&region, pDraw->x, pDraw->y);
            DamageDamageRegion(pDraw, &region);
            RegionUninit(&region);
        }
    }

    __glXleaveServer(GL_FALSE);
}

static const __DRIgetDrawableInfoExtension getDrawableInfoExtension = {
    {__DRI_GET_DRAWABLE_INFO, __DRI_GET_DRAWABLE_INFO_VERSION},
    getDrawableInfo
};

static const __DRIdamageExtension damageExtension = {
    {__DRI_DAMAGE, __DRI_DAMAGE_VERSION},
    __glXReportDamage,
};

static const __DRIextension *loader_extensions[] = {
    &systemTimeExtension.base,
    &getDrawableInfoExtension.base,
    &damageExtension.base,
    NULL
};

static Bool
glxDRIEnterVT(ScrnInfoPtr scrn)
{
    Bool ret;
    __GLXDRIscreen *screen = (__GLXDRIscreen *)
        glxGetScreen(xf86ScrnToScreen(scrn));

    LogMessage(X_INFO, "AIGLX: Resuming AIGLX clients after VT switch\n");

    scrn->EnterVT = screen->enterVT;

    ret = scrn->EnterVT(scrn);

    screen->enterVT = scrn->EnterVT;
    scrn->EnterVT = glxDRIEnterVT;

    if (!ret)
        return FALSE;

    glxResumeClients();

    return TRUE;
}

static void
glxDRILeaveVT(ScrnInfoPtr scrn)
{
    __GLXDRIscreen *screen = (__GLXDRIscreen *)
        glxGetScreen(xf86ScrnToScreen(scrn));

    LogMessageVerbSigSafe(X_INFO, -1, "AIGLX: Suspending AIGLX clients for VT switch\n");

    glxSuspendClients();

    scrn->LeaveVT = screen->leaveVT;
    (*screen->leaveVT) (scrn);
    screen->leaveVT = scrn->LeaveVT;
    scrn->LeaveVT = glxDRILeaveVT;
}

static void
initializeExtensions(__GLXDRIscreen * screen)
{
    const __DRIextension **extensions;
    int i;

    extensions = screen->core->getExtensions(screen->driScreen);

    for (i = 0; extensions[i]; i++) {
#ifdef __DRI_READ_DRAWABLE
        if (strcmp(extensions[i]->name, __DRI_READ_DRAWABLE) == 0) {
            __glXEnableExtension(screen->glx_enable_bits,
                                 "GLX_SGI_make_current_read");

            LogMessage(X_INFO, "AIGLX: enabled GLX_SGI_make_current_read\n");
        }
#endif

#ifdef __DRI_COPY_SUB_BUFFER
        if (strcmp(extensions[i]->name, __DRI_COPY_SUB_BUFFER) == 0) {
            screen->copySubBuffer =
                (__DRIcopySubBufferExtension *) extensions[i];
            __glXEnableExtension(screen->glx_enable_bits,
                                 "GLX_MESA_copy_sub_buffer");

            LogMessage(X_INFO, "AIGLX: enabled GLX_MESA_copy_sub_buffer\n");
        }
#endif

#ifdef __DRI_SWAP_CONTROL
        if (strcmp(extensions[i]->name, __DRI_SWAP_CONTROL) == 0) {
            screen->swapControl = (__DRIswapControlExtension *) extensions[i];
            __glXEnableExtension(screen->glx_enable_bits,
                                 "GLX_SGI_swap_control");
            __glXEnableExtension(screen->glx_enable_bits,
                                 "GLX_MESA_swap_control");

            LogMessage(X_INFO,
                       "AIGLX: enabled GLX_SGI_swap_control and GLX_MESA_swap_control\n");
        }
#endif

#ifdef __DRI_TEX_OFFSET
        if (strcmp(extensions[i]->name, __DRI_TEX_OFFSET) == 0) {
            screen->texOffset = (__DRItexOffsetExtension *) extensions[i];
            LogMessage(X_INFO,
                       "AIGLX: enabled GLX_texture_from_pixmap with driver support\n");
        }
#endif
        /* Ignore unknown extensions */
    }
}

static __GLXscreen *
__glXDRIscreenProbe(ScreenPtr pScreen)
{
    drm_handle_t hSAREA;
    drmAddress pSAREA = NULL;
    char *BusID;
    __DRIversion ddx_version;
    __DRIversion dri_version;
    __DRIversion drm_version;
    __DRIframebuffer framebuffer;
    int fd = -1;
    int status;
    drm_magic_t magic;
    drmVersionPtr version;
    int newlyopened;
    char *driverName;
    drm_handle_t hFB;
    int junk;
    __GLXDRIscreen *screen;
    Bool isCapable;
    size_t buffer_size;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);

    framebuffer.base = NULL;

    if (!xf86LoaderCheckSymbol("DRIQueryDirectRenderingCapable") ||
        !DRIQueryDirectRenderingCapable(pScreen, &isCapable) || !isCapable) {
        LogMessage(X_INFO,
                   "AIGLX: Screen %d is not DRI capable\n", pScreen->myNum);
        return NULL;
    }

    screen = calloc(1, sizeof *screen);
    if (screen == NULL)
        return NULL;

    screen->base.destroy = __glXDRIscreenDestroy;
    screen->base.createContext = __glXDRIscreenCreateContext;
    screen->base.createDrawable = __glXDRIscreenCreateDrawable;
    screen->base.swapInterval = __glXDRIdrawableSwapInterval;
    screen->base.pScreen = pScreen;

    __glXInitExtensionEnableBits(screen->glx_enable_bits);

    /* DRI protocol version. */
    dri_version.major = XF86DRI_MAJOR_VERSION;
    dri_version.minor = XF86DRI_MINOR_VERSION;
    dri_version.patch = XF86DRI_PATCH_VERSION;

    if (!DRIOpenConnection(pScreen, &hSAREA, &BusID)) {
        LogMessage(X_ERROR, "AIGLX error: DRIOpenConnection failed\n");
        goto handle_error;
    }

    fd = drmOpenOnce(NULL, BusID, &newlyopened);

    if (fd < 0) {
        LogMessage(X_ERROR, "AIGLX error: drmOpenOnce failed (%s)\n",
                   strerror(-fd));
        goto handle_error;
    }

    if (drmGetMagic(fd, &magic)) {
        LogMessage(X_ERROR, "AIGLX error: drmGetMagic failed\n");
        goto handle_error;
    }

    version = drmGetVersion(fd);
    if (version) {
        drm_version.major = version->version_major;
        drm_version.minor = version->version_minor;
        drm_version.patch = version->version_patchlevel;
        drmFreeVersion(version);
    }
    else {
        drm_version.major = -1;
        drm_version.minor = -1;
        drm_version.patch = -1;
    }

    if (newlyopened && !DRIAuthConnection(pScreen, magic)) {
        LogMessage(X_ERROR, "AIGLX error: DRIAuthConnection failed\n");
        goto handle_error;
    }

    /* Get device name (like "tdfx") and the ddx version numbers.
     * We'll check the version in each DRI driver's "createNewScreen"
     * function. */
    if (!DRIGetClientDriverName(pScreen,
                                &ddx_version.major,
                                &ddx_version.minor,
                                &ddx_version.patch, &driverName)) {
        LogMessage(X_ERROR, "AIGLX error: DRIGetClientDriverName failed\n");
        goto handle_error;
    }

    screen->driver = glxProbeDriver(driverName,
                                    (void **) &screen->core,
                                    __DRI_CORE, __DRI_CORE_VERSION,
                                    (void **) &screen->legacy,
                                    __DRI_LEGACY, __DRI_LEGACY_VERSION);
    if (screen->driver == NULL) {
        goto handle_error;
    }

    /*
     * Get device-specific info.  pDevPriv will point to a struct
     * (such as DRIRADEONRec in xfree86/driver/ati/radeon_dri.h) that
     * has information about the screen size, depth, pitch, ancilliary
     * buffers, DRM mmap handles, etc.
     */
    if (!DRIGetDeviceInfo(pScreen, &hFB, &junk,
                          &framebuffer.size, &framebuffer.stride,
                          &framebuffer.dev_priv_size, &framebuffer.dev_priv)) {
        LogMessage(X_ERROR, "AIGLX error: XF86DRIGetDeviceInfo failed\n");
        goto handle_error;
    }

    framebuffer.width = pScreen->width;
    framebuffer.height = pScreen->height;

    /* Map the framebuffer region. */
    status = drmMap(fd, hFB, framebuffer.size,
                    (drmAddressPtr) &framebuffer.base);
    if (status != 0) {
        LogMessage(X_ERROR, "AIGLX error: drmMap of framebuffer failed (%s)\n",
                   strerror(-status));
        goto handle_error;
    }

    /* Map the SAREA region.  Further mmap regions may be setup in
     * each DRI driver's "createNewScreen" function.
     */
    status = drmMap(fd, hSAREA, SAREA_MAX, &pSAREA);
    if (status != 0) {
        LogMessage(X_ERROR, "AIGLX error: drmMap of SAREA failed (%s)\n",
                   strerror(-status));
        goto handle_error;
    }

    screen->driScreen =
        (*screen->legacy->createNewScreen) (pScreen->myNum,
                                            &ddx_version,
                                            &dri_version,
                                            &drm_version,
                                            &framebuffer,
                                            pSAREA,
                                            fd,
                                            loader_extensions,
                                            &screen->driConfigs, screen);

    if (screen->driScreen == NULL) {
        LogMessage(X_ERROR, "AIGLX error: Calling driver entry point failed\n");
        goto handle_error;
    }

    screen->base.fbconfigs = glxConvertConfigs(screen->core,
                                               screen->driConfigs,
                                               GLX_WINDOW_BIT);

    initializeExtensions(screen);

    DRIGetTexOffsetFuncs(pScreen, &screen->texOffsetStart,
                         &screen->texOffsetFinish);

    __glXScreenInit(&screen->base, pScreen);

    /* The first call simply determines the length of the extension string.
     * This allows us to allocate some memory to hold the extension string,
     * but it requires that we call __glXGetExtensionString a second time.
     */
    buffer_size = __glXGetExtensionString(screen->glx_enable_bits, NULL);
    if (buffer_size > 0) {
        free(screen->base.GLXextensions);

        screen->base.GLXextensions = xnfalloc(buffer_size);
        (void) __glXGetExtensionString(screen->glx_enable_bits,
                                       screen->base.GLXextensions);
    }

    __glXsetEnterLeaveServerFuncs(__glXDRIenterServer, __glXDRIleaveServer);

    screen->enterVT = pScrn->EnterVT;
    pScrn->EnterVT = glxDRIEnterVT;
    screen->leaveVT = pScrn->LeaveVT;
    pScrn->LeaveVT = glxDRILeaveVT;

    LogMessage(X_INFO, "AIGLX: Loaded and initialized %s\n", driverName);

    return &screen->base;

 handle_error:
    if (pSAREA != NULL)
        drmUnmap(pSAREA, SAREA_MAX);

    if (framebuffer.base != NULL)
        drmUnmap((drmAddress) framebuffer.base, framebuffer.size);

    if (fd >= 0)
        drmCloseOnce(fd);

    DRICloseConnection(pScreen);

    if (screen->driver)
        dlclose(screen->driver);

    free(screen);

    LogMessage(X_ERROR, "AIGLX: reverting to software rendering\n");

    return NULL;
}

_X_EXPORT __GLXprovider __glXDRIProvider = {
    __glXDRIscreenProbe,
    "DRI",
    NULL
};
@


1.12
log
@Update to xserver 1.14.3
@
text
@@


1.11
log
@Uodate to xserver 1.14.2. Tested by krw@@, shadchin@@, todd@@
@
text
@d974 2
@


1.10
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d888 1
a888 1
    LogMessage(X_INFO, "AIGLX: Suspending AIGLX clients for VT switch\n");
@


1.9
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d602 4
a605 1
                            __GLXcontext * baseShareContext)
d617 7
d859 1
a859 1
glxDRIEnterVT(int index, int flags)
a860 1
    ScrnInfoPtr scrn = xf86Screens[index];
d863 1
a863 1
        glxGetScreen(screenInfo.screens[index]);
d869 1
a869 1
    ret = scrn->EnterVT(index, flags);
d883 1
a883 1
glxDRILeaveVT(int index, int flags)
a884 1
    ScrnInfoPtr scrn = xf86Screens[index];
d886 1
a886 1
        glxGetScreen(screenInfo.screens[index]);
d893 1
a893 1
    (*screen->leaveVT) (index, flags);
d972 1
a972 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1072 1
a1072 1
                    (drmAddressPtr) & framebuffer.base);
@


1.8
log
@Update to xserver 1.11.2
@
text
@d65 2
a66 2
typedef struct __GLXDRIscreen   __GLXDRIscreen;
typedef struct __GLXDRIcontext  __GLXDRIcontext;
d70 3
a72 3
    __GLXscreen		 base;
    __DRIscreen		*driScreen;
    void		*driver;
d74 2
a75 2
    xf86EnterVTProc	*enterVT;
    xf86LeaveVTProc	*leaveVT;
d81 1
d119 17
a135 17
	__GLXDRIscreen * const screen =
	    (__GLXDRIscreen *) glxGetScreen(screenInfo.screens[i]);
	GLuint lastOverride = screen->lastTexOffsetOverride;

	if (lastOverride) {
	    __GLXDRIdrawable **texOffsetOverride = screen->texOffsetOverride;
	    int j;

	    for (j = 0; j < lastOverride; j++) {
		__GLXDRIdrawable *pGlxPix = texOffsetOverride[j];

		if (pGlxPix && pGlxPix->texname) {
		    pGlxPix->offset =
			screen->texOffsetStart((PixmapPtr)pGlxPix->base.pDraw);
		}
	    }
	}
d141 21
a161 20
	__GLXDRIscreen * const screen =
	    (__GLXDRIscreen *) glxGetScreen(screenInfo.screens[i]);
	GLuint lastOverride = screen->lastTexOffsetOverride;

	if (lastOverride) {
	    __GLXDRIdrawable **texOffsetOverride = screen->texOffsetOverride;
	    int j;

	    for (j = 0; j < lastOverride; j++) {
		__GLXDRIdrawable *pGlxPix = texOffsetOverride[j];

		if (pGlxPix && pGlxPix->texname) {
		    screen->texOffset->setTexOffset(pGlxPix->ctx->driContext,
						    pGlxPix->texname,
						    pGlxPix->offset,
						    pGlxPix->base.pDraw->depth,
						    ((PixmapPtr)pGlxPix->base.pDraw)->devKind);
		}
	    }
	}
d164 1
a164 1
    
d171 2
a172 2
	__GLXDRIscreen * const screen = (__GLXDRIscreen *)
	    glxGetScreen(screenInfo.screens[i]);
d174 4
a177 4
	if (screen->lastTexOffsetOverride) {
	    CALL_Flush(GET_DISPATCH(), ());
	    break;
	}
a182 1

d184 1
a184 1
__glXDRIdoReleaseTexImage(__GLXDRIscreen *screen, __GLXDRIdrawable *drawable)
d189 2
a190 2
	__GLXDRIdrawable **texOffsetOverride = screen->texOffsetOverride;
	int i;
d192 23
a214 23
	for (i = 0; i < lastOverride; i++) {
	    if (texOffsetOverride[i] == drawable) {
		if (screen->texOffsetFinish)
		    screen->texOffsetFinish((PixmapPtr)drawable->base.pDraw);

		texOffsetOverride[i] = NULL;

		if (i + 1 == lastOverride) {
		    lastOverride = 0;

		    while (i--) {
			if (texOffsetOverride[i]) {
			    lastOverride = i + 1;
			    break;
			}
		    }

		    screen->lastTexOffsetOverride = lastOverride;

		    break;
		}
	    }
	}
a217 1

d219 1
a219 1
__glXDRIdrawableDestroy(__GLXdrawable *drawable)
d226 2
a227 2
	screen = (__GLXDRIscreen *) glxGetScreen(screenInfo.screens[i]);
	__glXDRIdoReleaseTexImage(screen, private);
d233 2
a234 2
	screen = (__GLXDRIscreen *) glxGetScreen(drawable->pDraw->pScreen);
	(*screen->core->destroyDrawable)(private->driDrawable);
d236 4
a239 4
	__glXenterServer(GL_FALSE);
	DRIDestroyDrawable(drawable->pDraw->pScreen,
			   serverClient, drawable->pDraw);
	__glXleaveServer(GL_FALSE);
d248 1
a248 1
__glXDRIdrawableSwapBuffers(ClientPtr client, __GLXdrawable *basePrivate)
d252 1
a252 1
	(__GLXDRIscreen *) glxGetScreen(basePrivate->pDraw->pScreen);
d254 1
a254 1
    (*screen->core->swapBuffers)(private->driDrawable);
a258 1

d260 1
a260 1
__glXDRIdrawableSwapInterval(__GLXdrawable *baseDrawable, int interval)
d264 1
a264 1
	(__GLXDRIscreen *) glxGetScreen(baseDrawable->pDraw->pScreen);
d267 1
a267 1
	screen->swapControl->setSwapInterval(draw->driDrawable, interval);
a271 1

d273 2
a274 2
__glXDRIdrawableCopySubBuffer(__GLXdrawable *basePrivate,
			       int x, int y, int w, int h)
d278 1
a278 1
	glxGetScreen(basePrivate->pDraw->pScreen);
d281 1
a281 1
	screen->copySubBuffer->copySubBuffer(private->driDrawable, x, y, w, h);
d285 1
a285 1
__glXDRIcontextDestroy(__GLXcontext *baseContext)
d295 1
a295 1
			       context->hwContextID);
d303 1
a303 1
__glXDRIcontextMakeCurrent(__GLXcontext *baseContext)
d310 3
a312 4
    return (*screen->core->bindContext)(context->driContext,
					draw->driDrawable,
					read->driDrawable);
}					      
d315 1
a315 1
__glXDRIcontextLoseCurrent(__GLXcontext *baseContext)
d320 1
a320 1
    return (*screen->core->unbindContext)(context->driContext);
d324 2
a325 2
__glXDRIcontextCopy(__GLXcontext *baseDst, __GLXcontext *baseSrc,
		    unsigned long mask)
d331 2
a332 2
    return (*screen->core->copyContext)(dst->driContext,
					src->driContext, mask);
d336 1
a336 1
glxFillAlphaChannel (CARD32 *pixels, CARD32 rowstride, int width, int height)
d342 7
a348 8
    
    for (i = 0; i < height; i++)
    {
	p = pixels;
	end = p + width;
	while (p < end)
	  *p++ |= 0xFF000000;
	pixels += rowstride;
d358 1
a358 1
	return FALSE;
d380 7
a386 8
__glXDRIbindTexImage(__GLXcontext *baseContext,
		     int buffer,
		     __GLXdrawable *glxPixmap)
{
    RegionPtr	pRegion = NULL;
    PixmapPtr	pixmap;
    int		bpp, override = 0, texname;
    GLenum	format, type;
d389 1
a389 1
    __GLXDRIscreen * const screen = (__GLXDRIscreen *) glxGetScreen(pScreen);
d392 3
a394 3
				      GL_TEXTURE_BINDING_2D :
				      GL_TEXTURE_BINDING_RECTANGLE_NV,
				      &texname));
d397 1
a397 1
	return __glXError(GLXBadContextState);
d402 2
a403 2
	__GLXDRIdrawable **texOffsetOverride = screen->texOffsetOverride;
	int i, firstEmpty = 16;
d405 3
a407 3
	for (i = 0; i < 16; i++) {
	    if (texOffsetOverride[i] == driDraw)
		goto alreadyin; 
d409 3
a411 3
	    if (firstEmpty == 16 && !texOffsetOverride[i])
		firstEmpty = i;
	}
d413 5
a417 4
	if (firstEmpty == 16) {
	    ErrorF("%s: Failed to register texture offset override\n", __func__);
	    goto nooverride;
	}
d419 2
a420 2
	if (firstEmpty >= screen->lastTexOffsetOverride)
	    screen->lastTexOffsetOverride = firstEmpty + 1;
d422 1
a422 1
	texOffsetOverride[firstEmpty] = driDraw;
d424 2
a425 2
alreadyin:
	override = 1;
d427 1
a427 1
	driDraw->ctx = (__GLXDRIcontext*)baseContext;
d429 2
a430 2
	if (texname == driDraw->texname)
	    return Success;
d432 1
a432 1
	driDraw->texname = texname;
d434 3
a436 3
	screen->texOffset->setTexOffset(driDraw->ctx->driContext, texname, 0,
					pixmap->drawable.depth,
					pixmap->devKind);
d438 1
a438 1
nooverride:
d441 15
a455 14
	if (!override) {
	    driDraw->pDamage = DamageCreate(NULL, NULL, DamageReportNone,
					    TRUE, pScreen, NULL);
	    if (!driDraw->pDamage)
		return BadAlloc;

	    DamageRegister ((DrawablePtr) pixmap, driDraw->pDamage);
	}

	pRegion = NULL;
    } else {
	pRegion = DamageRegion(driDraw->pDamage);
	if (RegionNil(pRegion))
	    return Success;
d460 3
a462 3
	bpp = 4;
	format = GL_BGRA;
	type =
d464 1
a464 1
	    !override ? GL_UNSIGNED_INT_8_8_8_8_REV :
d466 42
a507 45
	    GL_UNSIGNED_BYTE;
    } else {
	bpp = 2;
	format = GL_RGB;
	type = GL_UNSIGNED_SHORT_5_6_5;
    }

    if (pRegion == NULL)
    {
	void *data = NULL;

	if (!override) {
	    unsigned pitch = PixmapBytePad(pixmap->drawable.width,
					   pixmap->drawable.depth); 

	    data = malloc(pitch * pixmap->drawable.height);

	    __glXenterServer(GL_FALSE);
	    pScreen->GetImage(&pixmap->drawable, 0 /*pixmap->drawable.x*/,
			      0 /*pixmap->drawable.y*/, pixmap->drawable.width,
			      pixmap->drawable.height, ZPixmap, ~0, data);
	    __glXleaveServer(GL_FALSE);

	    if (pixmap->drawable.depth == 24)
		glxFillAlphaChannel(data,
				    pitch,
				    pixmap->drawable.width,
				    pixmap->drawable.height);

	    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,
					       pitch / bpp) );
	    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS, 0) );
	    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS, 0) );
	}

	CALL_TexImage2D( GET_DISPATCH(),
			 (glxPixmap->target,
			  0,
			  bpp == 4 ? 4 : 3,
			  pixmap->drawable.width,
			  pixmap->drawable.height,
			  0,
			  format,
			  type,
			  data) );
d509 3
a511 2
	free(data);
    } else if (!override) {
d513 1
a513 1
	BoxPtr p;
d515 2
a516 2
	numRects = RegionNumRects (pRegion);
	p = RegionRects (pRegion);
d518 2
a519 2
	CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS, 0) );
	CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS, 0) );
d521 27
a547 29
	for (i = 0; i < numRects; i++)
	{
	    unsigned pitch = PixmapBytePad(p[i].x2 - p[i].x1,
					   pixmap->drawable.depth);
	    void *data = malloc(pitch * (p[i].y2 - p[i].y1));

	    __glXenterServer(GL_FALSE);
	    pScreen->GetImage(&pixmap->drawable, /*pixmap->drawable.x +*/ p[i].x1,
			      /*pixmap->drawable.y*/ + p[i].y1, p[i].x2 - p[i].x1,
			      p[i].y2 - p[i].y1, ZPixmap, ~0, data);
	    __glXleaveServer(GL_FALSE);

	    if (pixmap->drawable.depth == 24)
		glxFillAlphaChannel(data,
				    pitch,
				    p[i].x2 - p[i].x1,
				    p[i].y2 - p[i].y1);

	    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,
					       pitch / bpp) );

	    CALL_TexSubImage2D( GET_DISPATCH(),
				(glxPixmap->target,
				 0,
				 p[i].x1, p[i].y1,
				 p[i].x2 - p[i].x1, p[i].y2 - p[i].y1,
				 format,
				 type,
				 data) );
d549 2
a550 2
	    free(data);
	}
d554 1
a554 1
	DamageEmpty(driDraw->pDamage);
d560 2
a561 3
__glXDRIreleaseTexImage(__GLXcontext *baseContext,
			int buffer,
			__GLXdrawable *pixmap)
d564 1
a564 1
	(__GLXDRIscreen *) glxGetScreen(pixmap->pDraw->pScreen);
d578 1
a578 1
__glXDRIscreenDestroy(__GLXscreen *baseScreen)
d580 2
d590 6
d600 3
a602 3
__glXDRIscreenCreateContext(__GLXscreen *baseScreen,
			    __GLXconfig *glxConfig,
			    __GLXcontext *baseShareContext)
d616 1
a616 1
	driShare = shareContext->driContext;
d618 1
a618 1
	driShare = NULL;
d625 1
a625 1
	return NULL;
d627 4
a630 4
    context->base.destroy           = __glXDRIcontextDestroy;
    context->base.makeCurrent       = __glXDRIcontextMakeCurrent;
    context->base.loseCurrent       = __glXDRIcontextLoseCurrent;
    context->base.copy              = __glXDRIcontextCopy;
d636 2
a637 2
	if (visual->vid == glxConfig->visualID)
	    break;
d639 1
a639 1
	return NULL;
d645 1
a645 1
			      context->hwContextID, &hwContext);
d649 1
a649 1
    	return NULL;
d651 3
a653 7
    context->driContext =
	screen->legacy->createNewContext(screen->driScreen,
					 config->driConfig,
					 0, /* render type */
					 driShare,
					 hwContext,
					 context);
d656 5
a660 5
    	__glXenterServer(GL_FALSE);
	retval = DRIDestroyContext(baseScreen->pScreen, context->hwContextID);
    	__glXleaveServer(GL_FALSE);
	free(context);
	return NULL;
d668 4
a671 6
			     __GLXscreen *screen,
			     DrawablePtr pDraw,
			     XID drawId,
			     int type,
			     XID glxDrawId,
			     __GLXconfig *glxConfig)
d681 1
a681 1
	return NULL;
d684 1
a684 1
			   pDraw, type, glxDrawId, glxConfig)) {
d686 1
a686 1
	return NULL;
d689 2
a690 2
    private->base.destroy       = __glXDRIdrawableDestroy;
    private->base.swapBuffers   = __glXDRIdrawableSwapBuffers;
d692 2
a693 2
    private->base.waitX		= NULL;
    private->base.waitGL	= NULL;
d697 1
a697 1
			       pDraw, &hwDrawable);
d702 1
a702 1
    	return NULL;
d709 3
a711 3
	(driScreen->legacy->createNewDrawable)(driScreen->driScreen,
					       config->driConfig,
					       hwDrawable, 0, NULL, private);
d714 5
a718 5
	__glXenterServer(GL_FALSE);
	DRIDestroyDrawable(screen->pScreen, serverClient, pDraw);
	__glXleaveServer(GL_FALSE);
	free(private);
	return NULL;
d725 7
a731 7
getDrawableInfo(__DRIdrawable *driDrawable,
		unsigned int *index, unsigned int *stamp,
		int *x, int *y, int *width, int *height,
		int *numClipRects, drm_clip_rect_t **ppClipRects,
		int *backX, int *backY,
		int *numBackClipRects, drm_clip_rect_t **ppBackClipRects,
		void *data)
d741 1
a741 1
	return GL_FALSE;
d746 4
a749 4
				x, y, width, height,
				numClipRects, &pClipRects,
				backX, backY,
				numBackClipRects, &pBackClipRects);
d753 2
a754 2
	size = sizeof (drm_clip_rect_t) * *numClipRects;
	*ppClipRects = malloc(size);
d756 24
a779 24
	/* Clip cliprects to screen dimensions (redirected windows) */
	if (*ppClipRects != NULL) {
	    int i, j;

	    for (i = 0, j = 0; i < *numClipRects; i++) {
	        (*ppClipRects)[j].x1 = max(pClipRects[i].x1, 0);
		(*ppClipRects)[j].y1 = max(pClipRects[i].y1, 0);
		(*ppClipRects)[j].x2 = min(pClipRects[i].x2, pScreen->width);
		(*ppClipRects)[j].y2 = min(pClipRects[i].y2, pScreen->height);

		if ((*ppClipRects)[j].x1 < (*ppClipRects)[j].x2 &&
		    (*ppClipRects)[j].y1 < (*ppClipRects)[j].y2) {
		    j++;
		}
	    }

	    if (*numClipRects != j) {
		*numClipRects = j;
		*ppClipRects = realloc(*ppClipRects,
					 sizeof (drm_clip_rect_t) *
					 *numClipRects);
	    }
	} else
	    *numClipRects = 0;
d782 2
a783 2
      *ppClipRects = NULL;
      *numClipRects = 0;
d785 1
a785 1
      
d787 6
a792 6
	size = sizeof (drm_clip_rect_t) * *numBackClipRects;
	*ppBackClipRects = malloc(size);
	if (*ppBackClipRects != NULL)
	    memcpy (*ppBackClipRects, pBackClipRects, size);
	else
	    *numBackClipRects = 0;
d795 2
a796 2
      *ppBackClipRects = NULL;
      *numBackClipRects = 0;
d802 5
a806 5
static void __glXReportDamage(__DRIdrawable *driDraw,
			      int x, int y,
			      drm_clip_rect_t *rects, int num_rects,
			      GLboolean front_buffer,
			      void *data)
d815 3
a817 3
	RegionTranslate(&region, pDraw->x, pDraw->y);
	DamageDamageRegion(pDraw, &region);
	RegionUninit(&region);
d820 6
a825 6
	while (num_rects--) {
	    RegionInit (&region, (BoxPtr) rects++, 1);
	    RegionTranslate(&region, pDraw->x, pDraw->y);
	    DamageDamageRegion(pDraw, &region);
	    RegionUninit(&region);
	}
d832 1
a832 1
    { __DRI_GET_DRAWABLE_INFO, __DRI_GET_DRAWABLE_INFO_VERSION },
d837 1
a837 1
    { __DRI_DAMAGE, __DRI_DAMAGE_VERSION },
a847 2


d849 1
a849 1
glxDRIEnterVT (int index, int flags)
d852 3
a854 3
    Bool	ret;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) 
	glxGetScreen(screenInfo.screens[index]);
d860 1
a860 1
    ret = scrn->EnterVT (index, flags);
d866 2
a867 2
	return FALSE;
    
d874 1
a874 1
glxDRILeaveVT (int index, int flags)
d878 1
a878 1
	glxGetScreen(screenInfo.screens[index]);
d891 1
a891 1
initializeExtensions(__GLXDRIscreen *screen)
d900 6
a905 6
	if (strcmp(extensions[i]->name, __DRI_READ_DRAWABLE) == 0) {
	    __glXEnableExtension(screen->glx_enable_bits,
				 "GLX_SGI_make_current_read");
	    
	    LogMessage(X_INFO, "AIGLX: enabled GLX_SGI_make_current_read\n");
	}
d909 8
a916 7
	if (strcmp(extensions[i]->name, __DRI_COPY_SUB_BUFFER) == 0) {
	    screen->copySubBuffer = (__DRIcopySubBufferExtension *) extensions[i];
	    __glXEnableExtension(screen->glx_enable_bits,
				 "GLX_MESA_copy_sub_buffer");
	    
	    LogMessage(X_INFO, "AIGLX: enabled GLX_MESA_copy_sub_buffer\n");
	}
d920 10
a929 9
	if (strcmp(extensions[i]->name, __DRI_SWAP_CONTROL) == 0) {
	    screen->swapControl = (__DRIswapControlExtension *) extensions[i];
	    __glXEnableExtension(screen->glx_enable_bits,
				 "GLX_SGI_swap_control");
	    __glXEnableExtension(screen->glx_enable_bits,
				 "GLX_MESA_swap_control");
	    
	    LogMessage(X_INFO, "AIGLX: enabled GLX_SGI_swap_control and GLX_MESA_swap_control\n");
	}
d933 5
a937 4
	if (strcmp(extensions[i]->name, __DRI_TEX_OFFSET) == 0) {
	    screen->texOffset = (__DRItexOffsetExtension *) extensions[i];
	    LogMessage(X_INFO, "AIGLX: enabled GLX_texture_from_pixmap with driver support\n");
	}
d939 1
a939 1
	/* Ignore unknown extensions */
d942 1
a942 1
    
d949 6
a954 6
    __DRIversion   ddx_version;
    __DRIversion   dri_version;
    __DRIversion   drm_version;
    __DRIframebuffer  framebuffer;
    int   fd = -1;
    int   status;
d959 2
a960 2
    drm_handle_t  hFB;
    int        junk;
a964 1
    const __DRIconfig **driConfigs;
d967 4
a970 5
	!DRIQueryDirectRenderingCapable(pScreen, &isCapable) ||
	!isCapable) {
	LogMessage(X_INFO,
		   "AIGLX: Screen %d is not DRI capable\n", pScreen->myNum);
	return NULL;
d975 1
a975 1
      return NULL;
d977 2
a978 2
    screen->base.destroy        = __glXDRIscreenDestroy;
    screen->base.createContext  = __glXDRIscreenCreateContext;
d980 2
a981 2
    screen->base.swapInterval   = __glXDRIdrawableSwapInterval;
    screen->base.pScreen       = pScreen;
d991 2
a992 2
	LogMessage(X_ERROR, "AIGLX error: DRIOpenConnection failed\n");
	goto handle_error;
d998 3
a1000 3
	LogMessage(X_ERROR, "AIGLX error: drmOpenOnce failed (%s)\n",
		   strerror(-fd));
	goto handle_error;
d1004 2
a1005 2
	LogMessage(X_ERROR, "AIGLX error: drmGetMagic failed\n");
	goto handle_error;
d1010 4
a1013 4
	drm_version.major = version->version_major;
	drm_version.minor = version->version_minor;
	drm_version.patch = version->version_patchlevel;
	drmFreeVersion(version);
d1016 3
a1018 3
	drm_version.major = -1;
	drm_version.minor = -1;
	drm_version.patch = -1;
d1022 2
a1023 2
	LogMessage(X_ERROR, "AIGLX error: DRIAuthConnection failed\n");
	goto handle_error;
d1030 5
a1034 6
				&ddx_version.major,
				&ddx_version.minor,
				&ddx_version.patch,
				&driverName)) {
	LogMessage(X_ERROR, "AIGLX error: DRIGetClientDriverName failed\n");
	goto handle_error;
d1038 4
a1041 4
				    (void **)&screen->core,
				    __DRI_CORE, __DRI_CORE_VERSION,
				    (void **)&screen->legacy,
				    __DRI_LEGACY, __DRI_LEGACY_VERSION);
d1045 1
a1045 1
    
d1053 4
a1056 4
			  &framebuffer.size, &framebuffer.stride,
			  &framebuffer.dev_priv_size, &framebuffer.dev_priv)) {
	LogMessage(X_ERROR, "AIGLX error: XF86DRIGetDeviceInfo failed\n");
	goto handle_error;
d1063 2
a1064 2
    status = drmMap(fd, hFB, framebuffer.size, 
		    (drmAddressPtr)&framebuffer.base);
d1066 3
a1068 3
	LogMessage(X_ERROR, "AIGLX error: drmMap of framebuffer failed (%s)\n",
		   strerror(-status));
	goto handle_error;
d1076 3
a1078 3
	LogMessage(X_ERROR, "AIGLX error: drmMap of SAREA failed (%s)\n",
		   strerror(-status));
	goto handle_error;
d1080 1
a1080 1
    
d1082 9
a1090 10
	(*screen->legacy->createNewScreen)(pScreen->myNum,
					   &ddx_version,
					   &dri_version,
					   &drm_version,
					   &framebuffer,
					   pSAREA,
					   fd,
					   loader_extensions,
					   &driConfigs,
					   screen);
d1093 2
a1094 3
	LogMessage(X_ERROR,
		   "AIGLX error: Calling driver entry point failed\n");
	goto handle_error;
d1098 2
a1099 1
					       driConfigs, GLX_WINDOW_BIT);
d1104 1
a1104 1
			 &screen->texOffsetFinish);
d1114 1
a1114 1
	free(screen->base.GLXextensions);
d1116 3
a1118 3
	screen->base.GLXextensions = xnfalloc(buffer_size);
	(void) __glXGetExtensionString(screen->glx_enable_bits, 
				       screen->base.GLXextensions);
d1128 1
a1128 2
    LogMessage(X_INFO,
	       "AIGLX: Loaded and initialized %s\n", driverName);
d1134 1
a1134 1
	drmUnmap(pSAREA, SAREA_MAX);
d1137 1
a1137 1
	drmUnmap((drmAddress)framebuffer.base, framebuffer.size);
d1140 1
a1140 1
	drmCloseOnce(fd);
@


1.7
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@a58 1
#include "g_disptab.h"
a337 13
static int
__glXDRIcontextForceCurrent(__GLXcontext *baseContext)
{
    __GLXDRIcontext *context = (__GLXDRIcontext *) baseContext;
    __GLXDRIdrawable *draw = (__GLXDRIdrawable *) baseContext->drawPriv;
    __GLXDRIdrawable *read = (__GLXDRIdrawable *) baseContext->readPriv;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) context->base.pGlxScreen;

    return (*screen->core->bindContext)(context->driContext,
					draw->driDrawable,
					read->driDrawable);
}

a630 1
    context->base.forceCurrent      = __glXDRIcontextForceCurrent;
d820 13
a832 4
    RegionInit(&region, (BoxPtr) rects, num_rects);
    RegionTranslate(&region, pDraw->x, pDraw->y);
    DamageDamageRegion(pDraw, &region);
    RegionUninit(&region);
a855 2
static const char dri_driver_path[] = DRI_DRIVER_PATH;

a966 1
    char filename[128];
a970 2
    const __DRIextension **extensions;
    int i;
d1045 5
a1049 4
    snprintf(filename, sizeof filename, "%s/%s_dri.so",
             dri_driver_path, driverName);

    screen->driver = dlopen(filename, RTLD_LAZY | RTLD_LOCAL);
a1050 2
	LogMessage(X_ERROR, "AIGLX error: dlopen of %s failed (%s)\n",
		   filename, dlerror());
a1052 7

    extensions = dlsym(screen->driver, __DRI_DRIVER_EXTENSIONS);
    if (extensions == NULL) {
	LogMessage(X_ERROR, "AIGLX error: %s exports no extensions (%s)\n",
		   driverName, dlerror());
	goto handle_error;
    }
a1053 19
    for (i = 0; extensions[i]; i++) {
	if (strcmp(extensions[i]->name, __DRI_CORE) == 0 &&
	    extensions[i]->version >= __DRI_CORE_VERSION) {
		screen->core = (__DRIcoreExtension *) extensions[i];
	}

	if (strcmp(extensions[i]->name, __DRI_LEGACY) == 0 &&
	    extensions[i]->version >= __DRI_LEGACY_VERSION) {
		screen->legacy = (__DRIlegacyExtension *) extensions[i];
	}
    }

    if (screen->core == NULL || screen->legacy == NULL) {
	LogMessage(X_ERROR,
		   "AIGLX error: %s does not export required DRI extension\n",
		   driverName);
	goto handle_error;
    }

d1123 1
a1123 3
	if (screen->base.GLXextensions != NULL) {
	    free(screen->base.GLXextensions);
	}
d1138 1
a1138 1
	       "AIGLX: Loaded and initialized %s\n", filename);
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d837 1
a837 3
    DamageRegionAppend(pDraw, &region);
    /* This is wrong, this needs a seperate function. */
    DamageRegionProcessPending(pDraw);
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d38 1
d245 1
a245 1
    xfree(private);
d302 1
a302 1
    xfree(context);
d471 1
a471 1
	if (REGION_NIL(pRegion))
d498 1
a498 1
	    data = xalloc(pitch * pixmap->drawable.height);
d529 1
a529 1
	xfree(data);
d534 2
a535 2
	numRects = REGION_NUM_RECTS (pRegion);
	p = REGION_RECTS (pRegion);
d544 1
a544 1
	    void *data = xalloc(pitch * (p[i].y2 - p[i].y1));
d570 1
a570 1
	    xfree(data);
d610 1
a610 1
    xfree(screen);
d637 1
a637 1
    context = xcalloc(1, sizeof *context);
d678 1
a678 1
	xfree(context);
d700 1
a700 1
    private = xcalloc(1, sizeof *private);
d706 1
a706 1
        xfree(private);
d722 1
a722 1
    	xfree(private);
d738 1
a738 1
	xfree(private);
d775 1
a775 1
	*ppClipRects = xalloc (size);
d795 1
a795 1
		*ppClipRects = xrealloc (*ppClipRects,
d809 1
a809 1
	*ppBackClipRects = xalloc (size);
d835 2
a836 2
    REGION_INIT(pDraw->pScreen, &region, (BoxPtr) rects, num_rects);
    REGION_TRANSLATE(pScreen, &region, pDraw->x, pDraw->y);
d840 1
a840 1
    REGION_UNINIT(pDraw->pScreen, &region);
d869 2
d876 8
a883 1
    if (!(*screen->enterVT) (index, flags))
d894 1
d902 4
a905 1
    return (*screen->leaveVT) (index, flags);
a957 3
extern __GLXconfig *
glxConvertConfigs(const __DRIcoreExtension *core, const __DRIconfig **configs);

d993 1
a993 1
    screen = xcalloc(1, sizeof *screen);
d1147 2
a1148 1
    screen->base.fbconfigs = glxConvertConfigs(screen->core, driConfigs);
d1164 1
a1164 1
	    xfree(screen->base.GLXextensions);
d1199 1
a1199 1
    xfree(screen);
@


1.4
log
@Add missing \n at end of message.
@
text
@d41 1
d46 1
a46 1
#include <xf86dristr.h>
d248 1
a248 1
__glXDRIdrawableSwapBuffers(__GLXdrawable *basePrivate)
d685 2
a686 1
__glXDRIscreenCreateDrawable(__GLXscreen *screen,
d688 1
d690 1
a690 1
			     XID drawId,
d704 1
a704 1
			   pDraw, type, drawId, glxConfig)) {
d1092 1
a1092 1
	LogMessage(X_ERROR, "AIGLX error: XF86DRIGetDeviceInfo failed");
d1103 1
a1103 1
	LogMessage(X_ERROR, "AIGLX error: drmMap of framebuffer failed (%s)",
d1113 1
a1113 1
	LogMessage(X_ERROR, "AIGLX error: drmMap of SAREA failed (%s)",
d1131 2
a1132 1
	LogMessage(X_ERROR, "AIGLX error: Calling driver entry point failed\n");
d1145 4
d1163 1
a1163 1
    pScrn->EnterVT = glxDRIEnterVT; 
d1194 1
a1194 1
__GLXprovider __glXDRIProvider = {
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d1128 1
a1128 1
	LogMessage(X_ERROR, "AIGLX error: Calling driver entry point failed");
@


1.2
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d106 1
a106 1
    unsigned long offset;
d241 2
a246 9
__glXDRIdrawableResize(__GLXdrawable *glxPriv)
{
    /* Nothing to do here, the DRI driver asks the server for drawable
     * geometry when it sess the SAREA timestamps change.*/

    return GL_TRUE;
}

static GLboolean
d368 15
d418 1
a418 1
    if (screen->texOffsetStart && screen->texOffset) {
d635 1
a635 1
    context = xalloc(sizeof *context);
a638 1
    memset(context, 0, sizeof *context);
d652 1
a652 1
	return GL_FALSE;
d661 3
d696 1
a696 1
    private = xalloc(sizeof *private);
a699 2
    memset(private, 0, sizeof *private);

a706 1
    private->base.resize        = __glXDRIdrawableResize;
d709 2
d717 5
d769 1
a769 1
    if (*numClipRects > 0) {
d800 1
d803 1
a803 1
    if (*numBackClipRects > 0) {
d808 2
d813 1
d833 3
a835 1
    DamageDamageRegion(pDraw, &region);
d900 9
d979 1
a979 1
    screen = xalloc(sizeof *screen);
a981 1
    memset(screen, 0, sizeof *screen);
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d192 2
@

