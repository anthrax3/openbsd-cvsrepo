head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	s0SI41sEunLdyFfd;

1.12
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	7pAEtF6Y5EgemkuY;

1.11
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.08.24.19.44.32;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright Â© 2007 Red Hat, Inc
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without
 * fee, provided that the above copyright notice appear in all copies
 * and that both that copyright notice and this permission notice
 * appear in supporting documentation, and that the name of Red Hat,
 * Inc not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior
 * permission.  Red Hat, Inc makes no representations about the
 * suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * RED HAT, INC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
 * NO EVENT SHALL RED HAT, INC BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
 * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <dlfcn.h>

#include <drm.h>
#include <GL/gl.h>
#include <GL/internal/dri_interface.h>
#include <GL/glxtokens.h>

#include <windowstr.h>
#include <os.h>

#define _XF86DRI_SERVER_
#include <xf86drm.h>
#include <xf86.h>
#include <dri2.h>

#include "glxserver.h"
#include "glxutil.h"
#include "glxdricommon.h"
#include <GL/glxtokens.h>

#include "extension_string.h"

typedef struct __GLXDRIscreen __GLXDRIscreen;
typedef struct __GLXDRIcontext __GLXDRIcontext;
typedef struct __GLXDRIdrawable __GLXDRIdrawable;

#define ALL_DRI_CTX_FLAGS (__DRI_CTX_FLAG_DEBUG                         \
                           | __DRI_CTX_FLAG_FORWARD_COMPATIBLE          \
                           | __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS)

struct __GLXDRIscreen {
    __GLXscreen base;
    __DRIscreen *driScreen;
    void *driver;
    int fd;

    xf86EnterVTProc *enterVT;
    xf86LeaveVTProc *leaveVT;

    const __DRIcoreExtension *core;
    const __DRIdri2Extension *dri2;
    const __DRI2flushExtension *flush;
    const __DRIcopySubBufferExtension *copySubBuffer;
    const __DRIswapControlExtension *swapControl;
    const __DRItexBufferExtension *texBuffer;
    const __DRIconfig **driConfigs;

    unsigned char glx_enable_bits[__GLX_EXT_BYTES];
};

struct __GLXDRIcontext {
    __GLXcontext base;
    __DRIcontext *driContext;
};

#define MAX_DRAWABLE_BUFFERS 5

struct __GLXDRIdrawable {
    __GLXdrawable base;
    __DRIdrawable *driDrawable;
    __GLXDRIscreen *screen;

    /* Dimensions as last reported by DRI2GetBuffers. */
    int width;
    int height;
    __DRIbuffer buffers[MAX_DRAWABLE_BUFFERS];
    int count;
    XID dri2_id;
};

static void
__glXDRIdrawableDestroy(__GLXdrawable * drawable)
{
    __GLXDRIdrawable *private = (__GLXDRIdrawable *) drawable;
    const __DRIcoreExtension *core = private->screen->core;

    FreeResource(private->dri2_id, FALSE);

    (*core->destroyDrawable) (private->driDrawable);

    __glXDrawableRelease(drawable);

    free(private);
}

static void
copy_box(__GLXdrawable * drawable,
         int dst, int src,
         int x, int y, int w, int h)
{
    BoxRec box;
    RegionRec region;
    __GLXcontext *cx = lastGLContext;

    box.x1 = x;
    box.y1 = y;
    box.x2 = x + w;
    box.y2 = y + h;
    RegionInit(&region, &box, 0);

    DRI2CopyRegion(drawable->pDraw, &region, dst, src);
    if (cx != lastGLContext) {
        lastGLContext = cx;
        cx->makeCurrent(cx);
    }
}

static void
__glXDRIdrawableCopySubBuffer(__GLXdrawable * drawable,
                              int x, int y, int w, int h)
{
    __GLXDRIdrawable *private = (__GLXDRIdrawable *) drawable;

    copy_box(drawable, x, private->height - y - h,
             w, h,
             DRI2BufferFrontLeft, DRI2BufferBackLeft);
}

static void
__glXDRIdrawableWaitX(__GLXdrawable * drawable)
{
    __GLXDRIdrawable *private = (__GLXDRIdrawable *) drawable;

    copy_box(drawable, DRI2BufferFakeFrontLeft, DRI2BufferFrontLeft,
             0, 0, private->width, private->height);
}

static void
__glXDRIdrawableWaitGL(__GLXdrawable * drawable)
{
    __GLXDRIdrawable *private = (__GLXDRIdrawable *) drawable;

    copy_box(drawable, DRI2BufferFrontLeft, DRI2BufferFakeFrontLeft,
             0, 0, private->width, private->height);
}

static void
__glXdriSwapEvent(ClientPtr client, void *data, int type, CARD64 ust,
                  CARD64 msc, CARD32 sbc)
{
    __GLXdrawable *drawable = data;
    int glx_type;
    switch (type) {
    case DRI2_EXCHANGE_COMPLETE:
        glx_type = GLX_EXCHANGE_COMPLETE_INTEL;
        break;
    default:
        /* unknown swap completion type,
         * BLIT is a reasonable default, so
         * fall through ...
         */
    case DRI2_BLIT_COMPLETE:
        glx_type = GLX_BLIT_COMPLETE_INTEL;
        break;
    case DRI2_FLIP_COMPLETE:
        glx_type = GLX_FLIP_COMPLETE_INTEL;
        break;
    }

    __glXsendSwapEvent(drawable, glx_type, ust, msc, sbc);
}

/*
 * Copy or flip back to front, honoring the swap interval if possible.
 *
 * If the kernel supports it, we request an event for the frame when the
 * swap should happen, then perform the copy when we receive it.
 */
static GLboolean
__glXDRIdrawableSwapBuffers(ClientPtr client, __GLXdrawable * drawable)
{
    __GLXDRIdrawable *priv = (__GLXDRIdrawable *) drawable;
    __GLXDRIscreen *screen = priv->screen;
    CARD64 unused;
    __GLXcontext *cx = lastGLContext;
    int status;

    if (screen->flush) {
        (*screen->flush->flush) (priv->driDrawable);
        (*screen->flush->invalidate) (priv->driDrawable);
    }

    status = DRI2SwapBuffers(client, drawable->pDraw, 0, 0, 0, &unused,
                             __glXdriSwapEvent, drawable);
    if (cx != lastGLContext) {
        lastGLContext = cx;
        cx->makeCurrent(cx);
    }

    return status == Success;
}

static int
__glXDRIdrawableSwapInterval(__GLXdrawable * drawable, int interval)
{
    __GLXcontext *cx = lastGLContext;

    if (interval <= 0)          /* || interval > BIGNUM? */
        return GLX_BAD_VALUE;

    DRI2SwapInterval(drawable->pDraw, interval);
    if (cx != lastGLContext) {
        lastGLContext = cx;
        cx->makeCurrent(cx);
    }

    return 0;
}

static void
__glXDRIcontextDestroy(__GLXcontext * baseContext)
{
    __GLXDRIcontext *context = (__GLXDRIcontext *) baseContext;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) context->base.pGlxScreen;

    (*screen->core->destroyContext) (context->driContext);
    __glXContextDestroy(&context->base);
    free(context);
}

static int
__glXDRIcontextMakeCurrent(__GLXcontext * baseContext)
{
    __GLXDRIcontext *context = (__GLXDRIcontext *) baseContext;
    __GLXDRIdrawable *draw = (__GLXDRIdrawable *) baseContext->drawPriv;
    __GLXDRIdrawable *read = (__GLXDRIdrawable *) baseContext->readPriv;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) context->base.pGlxScreen;

    return (*screen->core->bindContext) (context->driContext,
                                         draw->driDrawable, read->driDrawable);
}

static int
__glXDRIcontextLoseCurrent(__GLXcontext * baseContext)
{
    __GLXDRIcontext *context = (__GLXDRIcontext *) baseContext;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) context->base.pGlxScreen;

    return (*screen->core->unbindContext) (context->driContext);
}

static int
__glXDRIcontextCopy(__GLXcontext * baseDst, __GLXcontext * baseSrc,
                    unsigned long mask)
{
    __GLXDRIcontext *dst = (__GLXDRIcontext *) baseDst;
    __GLXDRIcontext *src = (__GLXDRIcontext *) baseSrc;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) dst->base.pGlxScreen;

    return (*screen->core->copyContext) (dst->driContext,
                                         src->driContext, mask);
}

static Bool
__glXDRIcontextWait(__GLXcontext * baseContext,
                    __GLXclientState * cl, int *error)
{
    __GLXcontext *cx = lastGLContext;
    Bool ret;

    ret = DRI2WaitSwap(cl->client, baseContext->drawPriv->pDraw);
    if (cx != lastGLContext) {
        lastGLContext = cx;
        cx->makeCurrent(cx);
    }

    if (ret) {
        *error = cl->client->noClientException;
        return TRUE;
    }

    return FALSE;
}

static int
__glXDRIbindTexImage(__GLXcontext * baseContext,
                     int buffer, __GLXdrawable * glxPixmap)
{
    __GLXDRIdrawable *drawable = (__GLXDRIdrawable *) glxPixmap;
    const __DRItexBufferExtension *texBuffer = drawable->screen->texBuffer;
    __GLXDRIcontext *context = (__GLXDRIcontext *) baseContext;

    if (texBuffer == NULL)
        return Success;

    if (texBuffer->base.version >= 2 && texBuffer->setTexBuffer2 != NULL) {
        (*texBuffer->setTexBuffer2) (context->driContext,
                                     glxPixmap->target,
                                     glxPixmap->format, drawable->driDrawable);
    }
    else
    {
        texBuffer->setTexBuffer(context->driContext,
                                glxPixmap->target, drawable->driDrawable);
    }

    return Success;
}

static int
__glXDRIreleaseTexImage(__GLXcontext * baseContext,
                        int buffer, __GLXdrawable * pixmap)
{
    /* FIXME: Just unbind the texture? */
    return Success;
}

static __GLXtextureFromPixmap __glXDRItextureFromPixmap = {
    __glXDRIbindTexImage,
    __glXDRIreleaseTexImage
};

static void
__glXDRIscreenDestroy(__GLXscreen * baseScreen)
{
    int i;

    ScrnInfoPtr pScrn = xf86ScreenToScrn(baseScreen->pScreen);
    __GLXDRIscreen *screen = (__GLXDRIscreen *) baseScreen;

    (*screen->core->destroyScreen) (screen->driScreen);

    dlclose(screen->driver);

    __glXScreenDestroy(baseScreen);

    if (screen->driConfigs) {
        for (i = 0; screen->driConfigs[i] != NULL; i++)
            free((__DRIconfig **) screen->driConfigs[i]);
        free(screen->driConfigs);
    }

    pScrn->EnterVT = screen->enterVT;
    pScrn->LeaveVT = screen->leaveVT;

    free(screen);
}

static Bool
dri2_convert_glx_attribs(__GLXDRIscreen *screen, unsigned num_attribs,
                         const uint32_t *attribs,
                         unsigned *major_ver, unsigned *minor_ver,
                         uint32_t *flags, int *api, int *reset, unsigned *error)
{
    unsigned i;

    if (num_attribs == 0)
        return True;

    if (attribs == NULL) {
        *error = BadImplementation;
        return False;
    }

    *major_ver = 1;
    *minor_ver = 0;
    *reset = __DRI_CTX_RESET_NO_NOTIFICATION;

    for (i = 0; i < num_attribs; i++) {
        switch (attribs[i * 2]) {
        case GLX_CONTEXT_MAJOR_VERSION_ARB:
            *major_ver = attribs[i * 2 + 1];
            break;
        case GLX_CONTEXT_MINOR_VERSION_ARB:
            *minor_ver = attribs[i * 2 + 1];
            break;
        case GLX_CONTEXT_FLAGS_ARB:
            *flags = attribs[i * 2 + 1];
            break;
        case GLX_RENDER_TYPE:
            break;
        case GLX_CONTEXT_PROFILE_MASK_ARB:
            switch (attribs[i * 2 + 1]) {
            case GLX_CONTEXT_CORE_PROFILE_BIT_ARB:
                *api = __DRI_API_OPENGL_CORE;
                break;
            case GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB:
                *api = __DRI_API_OPENGL;
                break;
            case GLX_CONTEXT_ES2_PROFILE_BIT_EXT:
                *api = __DRI_API_GLES2;
                break;
            default:
                *error = __glXError(GLXBadProfileARB);
                return False;
            }
            break;
        case GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB:
            if (screen->dri2->base.version >= 4) {
                *error = BadValue;
                return False;
            }

            switch (attribs[i * 2 + 1]) {
            case GLX_NO_RESET_NOTIFICATION_ARB:
                *reset = __DRI_CTX_RESET_NO_NOTIFICATION;
                break;
            case GLX_LOSE_CONTEXT_ON_RESET_ARB:
                *reset = __DRI_CTX_RESET_LOSE_CONTEXT;
                break;
            default:
                *error = BadValue;
                return False;
            }
            break;
        default:
            /* If an unknown attribute is received, fail.
             */
            *error = BadValue;
            return False;
        }
    }

    /* Unknown flag value.
     */
    if ((*flags & ~ALL_DRI_CTX_FLAGS) != 0) {
        *error = BadValue;
        return False;
    }

    /* If the core profile is requested for a GL version is less than 3.2,
     * request the non-core profile from the DRI driver.  The core profile
     * only makes sense for GL versions >= 3.2, and many DRI drivers that
     * don't support OpenGL 3.2 may fail the request for a core profile.
     */
    if (*api == __DRI_API_OPENGL_CORE
        && (*major_ver < 3 || (*major_ver == 3 && *minor_ver < 2))) {
        *api = __DRI_API_OPENGL;
    }

    *error = Success;
    return True;
}

static void
create_driver_context(__GLXDRIcontext * context,
                      __GLXDRIscreen * screen,
                      __GLXDRIconfig * config,
                      __DRIcontext * driShare,
                      unsigned num_attribs,
                      const uint32_t *attribs,
                      int *error)
{
    context->driContext = NULL;

    if (screen->dri2->base.version >= 3) {
        uint32_t ctx_attribs[4 * 2];
        unsigned num_ctx_attribs = 0;
        unsigned dri_err = 0;
        unsigned major_ver;
        unsigned minor_ver;
        uint32_t flags = 0;
        int reset;
        int api = __DRI_API_OPENGL;

        if (num_attribs != 0) {
            if (!dri2_convert_glx_attribs(screen, num_attribs, attribs,
                                          &major_ver, &minor_ver,
                                          &flags, &api, &reset,
                                          (unsigned *) error))
                return;

            ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_MAJOR_VERSION;
            ctx_attribs[num_ctx_attribs++] = major_ver;
            ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_MINOR_VERSION;
            ctx_attribs[num_ctx_attribs++] = minor_ver;

            if (flags != 0) {
                ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_FLAGS;

                /* The current __DRI_CTX_FLAG_* values are identical to the
                 * GLX_CONTEXT_*_BIT values.
                 */
                ctx_attribs[num_ctx_attribs++] = flags;
            }

            if (reset != __DRI_CTX_RESET_NO_NOTIFICATION) {
                ctx_attribs[num_ctx_attribs++] =
                    __DRI_CTX_ATTRIB_RESET_STRATEGY;
                ctx_attribs[num_ctx_attribs++] = reset;
            }

            assert(num_ctx_attribs <= ARRAY_SIZE(ctx_attribs));
        }

        context->driContext =
            (*screen->dri2->createContextAttribs)(screen->driScreen,
                                                  api,
                                                  config->driConfig,
                                                  driShare,
                                                  num_ctx_attribs / 2,
                                                  ctx_attribs,
                                                  &dri_err,
                                                  context);

        switch (dri_err) {
        case __DRI_CTX_ERROR_SUCCESS:
            *error = Success;
            break;
        case __DRI_CTX_ERROR_NO_MEMORY:
            *error = BadAlloc;
            break;
        case __DRI_CTX_ERROR_BAD_API:
            *error = __glXError(GLXBadProfileARB);
            break;
        case __DRI_CTX_ERROR_BAD_VERSION:
        case __DRI_CTX_ERROR_BAD_FLAG:
            *error = __glXError(GLXBadFBConfig);
            break;
        case __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE:
        case __DRI_CTX_ERROR_UNKNOWN_FLAG:
        default:
            *error = BadValue;
            break;
        }

        return;
    }

    if (num_attribs != 0) {
        *error = BadValue;
        return;
    }

    context->driContext =
        (*screen->dri2->createNewContext) (screen->driScreen,
                                           config->driConfig,
                                           driShare, context);
}

static __GLXcontext *
__glXDRIscreenCreateContext(__GLXscreen * baseScreen,
                            __GLXconfig * glxConfig,
                            __GLXcontext * baseShareContext,
                            unsigned num_attribs,
                            const uint32_t *attribs,
                            int *error)
{
    __GLXDRIscreen *screen = (__GLXDRIscreen *) baseScreen;
    __GLXDRIcontext *context, *shareContext;
    __GLXDRIconfig *config = (__GLXDRIconfig *) glxConfig;
    __DRIcontext *driShare;

    shareContext = (__GLXDRIcontext *) baseShareContext;
    if (shareContext)
        driShare = shareContext->driContext;
    else
        driShare = NULL;

    context = calloc(1, sizeof *context);
    if (context == NULL) {
        *error = BadAlloc;
        return NULL;
    }

    context->base.destroy = __glXDRIcontextDestroy;
    context->base.makeCurrent = __glXDRIcontextMakeCurrent;
    context->base.loseCurrent = __glXDRIcontextLoseCurrent;
    context->base.copy = __glXDRIcontextCopy;
    context->base.textureFromPixmap = &__glXDRItextureFromPixmap;
    context->base.wait = __glXDRIcontextWait;

    create_driver_context(context, screen, config, driShare, num_attribs,
                          attribs, error);
    if (context->driContext == NULL) {
        free(context);
        return NULL;
    }

    return &context->base;
}

static void
__glXDRIinvalidateBuffers(DrawablePtr pDraw, void *priv, XID id)
{
    __GLXDRIdrawable *private = priv;
    __GLXDRIscreen *screen = private->screen;

    if (screen->flush)
        (*screen->flush->invalidate) (private->driDrawable);
}

static __GLXdrawable *
__glXDRIscreenCreateDrawable(ClientPtr client,
                             __GLXscreen * screen,
                             DrawablePtr pDraw,
                             XID drawId,
                             int type, XID glxDrawId, __GLXconfig * glxConfig)
{
    __GLXDRIscreen *driScreen = (__GLXDRIscreen *) screen;
    __GLXDRIconfig *config = (__GLXDRIconfig *) glxConfig;
    __GLXDRIdrawable *private;
    __GLXcontext *cx = lastGLContext;
    Bool ret;

    private = calloc(1, sizeof *private);
    if (private == NULL)
        return NULL;

    private->screen = driScreen;
    if (!__glXDrawableInit(&private->base, screen,
                           pDraw, type, glxDrawId, glxConfig)) {
        free(private);
        return NULL;
    }

    private->base.destroy = __glXDRIdrawableDestroy;
    private->base.swapBuffers = __glXDRIdrawableSwapBuffers;
    private->base.copySubBuffer = __glXDRIdrawableCopySubBuffer;
    private->base.waitGL = __glXDRIdrawableWaitGL;
    private->base.waitX = __glXDRIdrawableWaitX;

    ret = DRI2CreateDrawable2(client, pDraw, drawId,
                              __glXDRIinvalidateBuffers, private,
                              &private->dri2_id);
    if (cx != lastGLContext) {
        lastGLContext = cx;
        cx->makeCurrent(cx);
    }

    if (ret) {
        free(private);
        return NULL;
    }

    private->driDrawable =
        (*driScreen->dri2->createNewDrawable) (driScreen->driScreen,
                                               config->driConfig, private);

    return &private->base;
}

static __DRIbuffer *
dri2GetBuffers(__DRIdrawable * driDrawable,
               int *width, int *height,
               unsigned int *attachments, int count,
               int *out_count, void *loaderPrivate)
{
    __GLXDRIdrawable *private = loaderPrivate;
    DRI2BufferPtr *buffers;
    int i;
    int j;
    __GLXcontext *cx = lastGLContext;

    buffers = DRI2GetBuffers(private->base.pDraw,
                             width, height, attachments, count, out_count);
    if (cx != lastGLContext) {
        lastGLContext = cx;
        cx->makeCurrent(cx);

        /* If DRI2GetBuffers() changed the GL context, it may also have
         * invalidated the DRI2 buffers, so let's get them again
         */
        buffers = DRI2GetBuffers(private->base.pDraw,
                                 width, height, attachments, count, out_count);
        assert(lastGLContext == cx);
    }

    if (*out_count > MAX_DRAWABLE_BUFFERS) {
        *out_count = 0;
        return NULL;
    }

    private->width = *width;
    private->height = *height;

    /* This assumes the DRI2 buffer attachment tokens matches the
     * __DRIbuffer tokens. */
    j = 0;
    for (i = 0; i < *out_count; i++) {
        /* Do not send the real front buffer of a window to the client.
         */
        if ((private->base.pDraw->type == DRAWABLE_WINDOW)
            && (buffers[i]->attachment == DRI2BufferFrontLeft)) {
            continue;
        }

        private->buffers[j].attachment = buffers[i]->attachment;
        private->buffers[j].name = buffers[i]->name;
        private->buffers[j].pitch = buffers[i]->pitch;
        private->buffers[j].cpp = buffers[i]->cpp;
        private->buffers[j].flags = buffers[i]->flags;
        j++;
    }

    *out_count = j;
    return private->buffers;
}

static __DRIbuffer *
dri2GetBuffersWithFormat(__DRIdrawable * driDrawable,
                         int *width, int *height,
                         unsigned int *attachments, int count,
                         int *out_count, void *loaderPrivate)
{
    __GLXDRIdrawable *private = loaderPrivate;
    DRI2BufferPtr *buffers;
    int i;
    int j = 0;
    __GLXcontext *cx = lastGLContext;

    buffers = DRI2GetBuffersWithFormat(private->base.pDraw,
                                       width, height, attachments, count,
                                       out_count);
    if (cx != lastGLContext) {
        lastGLContext = cx;
        cx->makeCurrent(cx);

        /* If DRI2GetBuffersWithFormat() changed the GL context, it may also have
         * invalidated the DRI2 buffers, so let's get them again
         */
        buffers = DRI2GetBuffersWithFormat(private->base.pDraw,
                                           width, height, attachments, count,
                                           out_count);
        assert(lastGLContext == cx);
    }

    if (*out_count > MAX_DRAWABLE_BUFFERS) {
        *out_count = 0;
        return NULL;
    }

    private->width = *width;
    private->height = *height;

    /* This assumes the DRI2 buffer attachment tokens matches the
     * __DRIbuffer tokens. */
    for (i = 0; i < *out_count; i++) {
        /* Do not send the real front buffer of a window to the client.
         */
        if ((private->base.pDraw->type == DRAWABLE_WINDOW)
            && (buffers[i]->attachment == DRI2BufferFrontLeft)) {
            continue;
        }

        private->buffers[j].attachment = buffers[i]->attachment;
        private->buffers[j].name = buffers[i]->name;
        private->buffers[j].pitch = buffers[i]->pitch;
        private->buffers[j].cpp = buffers[i]->cpp;
        private->buffers[j].flags = buffers[i]->flags;
        j++;
    }

    *out_count = j;
    return private->buffers;
}

static void
dri2FlushFrontBuffer(__DRIdrawable * driDrawable, void *loaderPrivate)
{
    (void) driDrawable;
    __glXDRIdrawableWaitGL((__GLXdrawable *) loaderPrivate);
}

static const __DRIdri2LoaderExtension loaderExtension = {
    {__DRI_DRI2_LOADER, 3},
    dri2GetBuffers,
    dri2FlushFrontBuffer,
    dri2GetBuffersWithFormat,
};

static const __DRIuseInvalidateExtension dri2UseInvalidate = {
    {__DRI_USE_INVALIDATE, 1}
};

static const __DRIextension *loader_extensions[] = {
    &systemTimeExtension.base,
    &loaderExtension.base,
    &dri2UseInvalidate.base,
    NULL
};

static Bool
glxDRIEnterVT(ScrnInfoPtr scrn)
{
    Bool ret;
    __GLXDRIscreen *screen = (__GLXDRIscreen *)
        glxGetScreen(xf86ScrnToScreen(scrn));

    LogMessage(X_INFO, "AIGLX: Resuming AIGLX clients after VT switch\n");

    scrn->EnterVT = screen->enterVT;

    ret = scrn->EnterVT(scrn);

    screen->enterVT = scrn->EnterVT;
    scrn->EnterVT = glxDRIEnterVT;

    if (!ret)
        return FALSE;

    glxResumeClients();

    return TRUE;
}

static void
glxDRILeaveVT(ScrnInfoPtr scrn)
{
    __GLXDRIscreen *screen = (__GLXDRIscreen *)
        glxGetScreen(xf86ScrnToScreen(scrn));

    LogMessageVerbSigSafe(X_INFO, -1, "AIGLX: Suspending AIGLX clients for VT switch\n");

    glxSuspendClients();

    scrn->LeaveVT = screen->leaveVT;
    (*screen->leaveVT) (scrn);
    screen->leaveVT = scrn->LeaveVT;
    scrn->LeaveVT = glxDRILeaveVT;
}

/**
 * Initialize extension flags in glx_enable_bits when a new screen is created
 *
 * @@param screen The screen where glx_enable_bits are to be set.
 */
static void
initializeExtensions(__GLXDRIscreen * screen)
{
    ScreenPtr pScreen = screen->base.pScreen;
    const __DRIextension **extensions;
    int i;

    extensions = screen->core->getExtensions(screen->driScreen);

    __glXEnableExtension(screen->glx_enable_bits, "GLX_MESA_copy_sub_buffer");
    LogMessage(X_INFO, "AIGLX: enabled GLX_MESA_copy_sub_buffer\n");

    if (screen->dri2->base.version >= 3) {
        __glXEnableExtension(screen->glx_enable_bits,
                             "GLX_ARB_create_context");
        __glXEnableExtension(screen->glx_enable_bits,
                             "GLX_ARB_create_context_profile");
        __glXEnableExtension(screen->glx_enable_bits,
                             "GLX_EXT_create_context_es_profile");
        __glXEnableExtension(screen->glx_enable_bits,
                             "GLX_EXT_create_context_es2_profile");
        LogMessage(X_INFO, "AIGLX: enabled GLX_ARB_create_context\n");
        LogMessage(X_INFO, "AIGLX: enabled GLX_ARB_create_context_profile\n");
        LogMessage(X_INFO,
                   "AIGLX: enabled GLX_EXT_create_context_es{,2}_profile\n");
    }

    if (DRI2HasSwapControl(pScreen)) {
        __glXEnableExtension(screen->glx_enable_bits, "GLX_INTEL_swap_event");
        __glXEnableExtension(screen->glx_enable_bits, "GLX_SGI_swap_control");
        __glXEnableExtension(screen->glx_enable_bits, "GLX_MESA_swap_control");
        LogMessage(X_INFO, "AIGLX: enabled GLX_INTEL_swap_event\n");
        LogMessage(X_INFO,
                   "AIGLX: enabled GLX_SGI_swap_control and GLX_MESA_swap_control\n");
    }

    /* enable EXT_framebuffer_sRGB extension (even if there are no sRGB capable fbconfigs) */
    {
        __glXEnableExtension(screen->glx_enable_bits,
                 "GLX_EXT_framebuffer_sRGB");
        LogMessage(X_INFO, "AIGLX: enabled GLX_EXT_framebuffer_sRGB\n");
    }

    /* enable ARB_fbconfig_float extension (even if there are no float fbconfigs) */
    {
        __glXEnableExtension(screen->glx_enable_bits, "GLX_ARB_fbconfig_float");
        LogMessage(X_INFO, "AIGLX: enabled GLX_ARB_fbconfig_float\n");
    }

    /* enable EXT_fbconfig_packed_float (even if there are no packed float fbconfigs) */
    {
        __glXEnableExtension(screen->glx_enable_bits, "GLX_EXT_fbconfig_packed_float");
        LogMessage(X_INFO, "AIGLX: enabled GLX_EXT_fbconfig_packed_float\n");
    }

    for (i = 0; extensions[i]; i++) {
        if (strcmp(extensions[i]->name, __DRI_READ_DRAWABLE) == 0) {
            __glXEnableExtension(screen->glx_enable_bits,
                                 "GLX_SGI_make_current_read");

            LogMessage(X_INFO, "AIGLX: enabled GLX_SGI_make_current_read\n");
        }

        if (strcmp(extensions[i]->name, __DRI_TEX_BUFFER) == 0) {
            screen->texBuffer = (const __DRItexBufferExtension *) extensions[i];
            /* GLX_EXT_texture_from_pixmap is always enabled. */
            LogMessage(X_INFO,
                       "AIGLX: GLX_EXT_texture_from_pixmap backed by buffer objects\n");
        }

        if (strcmp(extensions[i]->name, __DRI2_FLUSH) == 0 &&
            extensions[i]->version >= 3) {
            screen->flush = (__DRI2flushExtension *) extensions[i];
        }

        if (strcmp(extensions[i]->name, __DRI2_ROBUSTNESS) == 0 &&
            screen->dri2->base.version >= 3) {
            __glXEnableExtension(screen->glx_enable_bits,
                                 "GLX_ARB_create_context_robustness");
            LogMessage(X_INFO,
                       "AIGLX: enabled GLX_ARB_create_context_robustness\n");
        }

#ifdef __DRI2_FLUSH_CONTROL
        if (strcmp(extensions[i]->name, __DRI2_FLUSH_CONTROL) == 0) {
            __glXEnableExtension(screen->glx_enable_bits,
                                 "GLX_ARB_context_flush_control\n");
        }
#endif

        /* Ignore unknown extensions */
    }
}

/* white lie */
extern glx_func_ptr glXGetProcAddressARB(const char *);

static __GLXscreen *
__glXDRIscreenProbe(ScreenPtr pScreen)
{
    const char *driverName, *deviceName;
    __GLXDRIscreen *screen;
    size_t buffer_size;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);

    screen = calloc(1, sizeof *screen);
    if (screen == NULL)
        return NULL;

    if (!DRI2Connect(serverClient, pScreen, DRI2DriverDRI,
                     &screen->fd, &driverName, &deviceName)) {
        LogMessage(X_INFO,
                   "AIGLX: Screen %d is not DRI2 capable\n", pScreen->myNum);
        goto handle_error;
    }

    screen->base.destroy = __glXDRIscreenDestroy;
    screen->base.createContext = __glXDRIscreenCreateContext;
    screen->base.createDrawable = __glXDRIscreenCreateDrawable;
    screen->base.swapInterval = __glXDRIdrawableSwapInterval;
    screen->base.pScreen = pScreen;

    __glXInitExtensionEnableBits(screen->glx_enable_bits);

    screen->driver =
        glxProbeDriver(driverName, (void **) &screen->core, __DRI_CORE, 1,
                       (void **) &screen->dri2, __DRI_DRI2, 1);
    if (screen->driver == NULL) {
        goto handle_error;
    }

    screen->driScreen =
        (*screen->dri2->createNewScreen) (pScreen->myNum,
                                          screen->fd,
                                          loader_extensions,
                                          &screen->driConfigs, screen);

    if (screen->driScreen == NULL) {
        LogMessage(X_ERROR, "AIGLX error: Calling driver entry point failed\n");
        goto handle_error;
    }

    initializeExtensions(screen);

    screen->base.fbconfigs = glxConvertConfigs(screen->core, screen->driConfigs,
                                               GLX_WINDOW_BIT |
                                               GLX_PIXMAP_BIT |
                                               GLX_PBUFFER_BIT);

    __glXScreenInit(&screen->base, pScreen);

    /* The first call simply determines the length of the extension string.
     * This allows us to allocate some memory to hold the extension string,
     * but it requires that we call __glXGetExtensionString a second time.
     */
    buffer_size = __glXGetExtensionString(screen->glx_enable_bits, NULL);
    if (buffer_size > 0) {
        free(screen->base.GLXextensions);

        screen->base.GLXextensions = xnfalloc(buffer_size);
        (void) __glXGetExtensionString(screen->glx_enable_bits,
                                       screen->base.GLXextensions);
    }

    /* We're going to assume (perhaps incorrectly?) that all DRI2-enabled
     * drivers support the required extensions for GLX 1.4.  The extensions
     * we're assuming are:
     *
     *    - GLX_SGI_make_current_read (1.3)
     *    - GLX_SGIX_fbconfig (1.3)
     *    - GLX_SGIX_pbuffer (1.3)
     *    - GLX_ARB_multisample (1.4)
     */
    screen->base.GLXmajor = 1;
    screen->base.GLXminor = 4;

    screen->enterVT = pScrn->EnterVT;
    pScrn->EnterVT = glxDRIEnterVT;
    screen->leaveVT = pScrn->LeaveVT;
    pScrn->LeaveVT = glxDRILeaveVT;

    __glXsetGetProcAddress(glXGetProcAddressARB);

    LogMessage(X_INFO, "AIGLX: Loaded and initialized %s\n", driverName);

    return &screen->base;

 handle_error:
    if (screen->driver)
        dlclose(screen->driver);

    free(screen);

    LogMessage(X_ERROR, "AIGLX: reverting to software rendering\n");

    return NULL;
}

_X_EXPORT __GLXprovider __glXDRI2Provider = {
    __glXDRIscreenProbe,
    "DRI2",
    NULL
};
@


1.12
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d867 2
d873 1
a873 1
                   "AIGLX: enabled GLX_EXT_create_context_es2_profile\n");
d896 6
@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d924 7
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d190 1
a190 1
    
d478 1
a478 1
        uint32_t ctx_attribs[3 * 2];
d513 2
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a57 1
#ifdef __DRI2_ROBUSTNESS
a60 4
#else
#define ALL_DRI_CTX_FLAGS (__DRI_CTX_FLAG_DEBUG                         \
                           | __DRI_CTX_FLAG_FORWARD_COMPATIBLE)
#endif
d118 3
a120 2
__glXDRIdrawableCopySubBuffer(__GLXdrawable * drawable,
                              int x, int y, int w, int h)
a121 1
    __GLXDRIdrawable *private = (__GLXDRIdrawable *) drawable;
d124 1
d127 1
a127 1
    box.y1 = private->height - y - h;
d129 1
a129 1
    box.y2 = private->height - y;
d132 16
a147 2
    DRI2CopyRegion(drawable->pDraw, &region,
                   DRI2BufferFrontLeft, DRI2BufferBackLeft);
a153 2
    BoxRec box;
    RegionRec region;
d155 2
a156 8
    box.x1 = 0;
    box.y1 = 0;
    box.x2 = private->width;
    box.y2 = private->height;
    RegionInit(&region, &box, 0);

    DRI2CopyRegion(drawable->pDraw, &region,
                   DRI2BufferFakeFrontLeft, DRI2BufferFrontLeft);
a162 2
    BoxRec box;
    RegionRec region;
d164 2
a165 8
    box.x1 = 0;
    box.y1 = 0;
    box.x2 = private->width;
    box.y2 = private->height;
    RegionInit(&region, &box, 0);

    DRI2CopyRegion(drawable->pDraw, &region,
                   DRI2BufferFrontLeft, DRI2BufferFakeFrontLeft);
d206 2
a208 1
#if __DRI2_FLUSH_VERSION >= 3
a212 4
#else
    if (screen->flush)
        (*screen->flush->flushInvalidate) (priv->driDrawable);
#endif
d214 6
a219 3
    if (DRI2SwapBuffers(client, drawable->pDraw, 0, 0, 0, &unused,
                        __glXdriSwapEvent, drawable) != Success)
        return FALSE;
d221 1
a221 1
    return TRUE;
d227 2
d233 4
d289 10
a298 1
    if (DRI2WaitSwap(cl->client, baseContext->drawPriv->pDraw)) {
a305 2
#ifdef __DRI_TEX_BUFFER

a316 1
#if __DRI_TEX_BUFFER_VERSION >= 2
a322 1
#endif
a338 18
#else

static int
__glXDRIbindTexImage(__GLXcontext * baseContext,
                     int buffer, __GLXdrawable * glxPixmap)
{
    return Success;
}

static int
__glXDRIreleaseTexImage(__GLXcontext * baseContext,
                        int buffer, __GLXdrawable * pixmap)
{
    return Success;
}

#endif

a387 1
#ifdef __DRI2_ROBUSTNESS
a388 3
#else
    (void) reset;
#endif
a418 1
#ifdef __DRI2_ROBUSTNESS
a436 1
#endif
a476 1
#if __DRI_DRI2_VERSION >= 3
d483 1
a483 1
        uint32_t flags;
a507 1
#ifdef __DRI2_ROBUSTNESS
a512 1
#endif
a547 1
#endif
a604 1
#if __DRI2_FLUSH_VERSION >= 3
a609 1
#endif
d622 2
d642 9
a650 3
    if (DRI2CreateDrawable2(client, pDraw, drawId,
                            __glXDRIinvalidateBuffers, private,
                            &private->dri2_id)) {
d672 1
d676 12
d729 1
d734 13
a790 1
#ifdef __DRI_USE_INVALIDATE
a793 1
#endif
a797 1
#ifdef __DRI_USE_INVALIDATE
a798 1
#endif
a858 2

#if __DRI_DRI2_VERSION >= 3
a870 1
#endif
a894 1
#ifdef __DRI_READ_DRAWABLE
a900 1
#endif
a901 1
#ifdef __DRI_TEX_BUFFER
a907 1
#endif
a908 1
#ifdef __DRI2_FLUSH
a912 1
#endif
a913 1
#ifdef __DRI2_ROBUSTNESS
a920 1
#endif
@


1.8
log
@Uodate to xserver 1.14.2. Tested by krw@@, shadchin@@, todd@@
@
text
@a51 4
#include "glapitable.h"
#include "glapi.h"
#include "glthread.h"
#include "dispatch.h"
a57 1

d179 1
a179 7
    xGLXBufferSwapComplete2 wire =  {
        .type = __glXEventBase + GLX_BufferSwapComplete
    };

    if (!(drawable->eventMask & GLX_BUFFER_SWAP_COMPLETE_INTEL_MASK))
        return;

d182 1
a182 1
        wire.event_type = GLX_EXCHANGE_COMPLETE_INTEL;
d184 5
d190 1
a190 1
        wire.event_type = GLX_BLIT_COMPLETE_INTEL;
d193 1
a193 5
        wire.event_type = GLX_FLIP_COMPLETE_INTEL;
        break;
    default:
        /* unknown swap completion type */
        wire.event_type = 0;
d196 2
a197 8
    wire.drawable = drawable->drawId;
    wire.ust_hi = ust >> 32;
    wire.ust_lo = ust & 0xffffffff;
    wire.msc_hi = msc >> 32;
    wire.msc_lo = msc & 0xffffffff;
    wire.sbc = sbc;

    WriteEventsToClient(client, 1, (xEvent *) &wire);
d362 1
d377 3
d775 1
a775 1
    {__DRI_DRI2_LOADER, __DRI_DRI2_LOADER_VERSION},
d783 1
a783 1
    {__DRI_USE_INVALIDATE, __DRI_USE_INVALIDATE_VERSION}
d836 5
a852 2
    __glXEnableExtension(screen->glx_enable_bits, "GLX_INTEL_swap_event");
    LogMessage(X_INFO, "AIGLX: enabled GLX_INTEL_swap_event\n");
d870 1
d873 1
d878 13
d931 3
d946 1
a946 2
    if (!xf86LoaderCheckSymbol("DRI2Connect") ||
        !DRI2Connect(serverClient, pScreen, DRI2DriverDRI,
d950 1
a950 1
        return NULL;
d1017 2
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d838 1
a838 1
    LogMessage(X_INFO, "AIGLX: Suspending AIGLX clients for VT switch\n");
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d50 1
d62 10
d109 1
d118 2
d184 3
a186 1
    xGLXBufferSwapComplete2 wire;
a190 1
    wire.type = __glXEventBase + GLX_BufferSwapComplete;
d395 200
d598 4
a601 1
                            __GLXcontext * baseShareContext)
d615 2
a616 1
    if (context == NULL)
d618 1
d627 2
a628 4
    context->driContext =
        (*screen->dri2->createNewContext) (screen->driScreen,
                                           config->driConfig,
                                           driShare, context);
d677 3
a679 2
    if (DRI2CreateDrawable(client, pDraw, drawId,
                           __glXDRIinvalidateBuffers, private)) {
d809 1
a809 1
glxDRIEnterVT(int index, int flags)
a810 1
    ScrnInfoPtr scrn = xf86Screens[index];
d813 1
a813 1
        glxGetScreen(screenInfo.screens[index]);
d819 1
a819 1
    ret = scrn->EnterVT(index, flags);
d833 1
a833 1
glxDRILeaveVT(int index, int flags)
a834 1
    ScrnInfoPtr scrn = xf86Screens[index];
d836 1
a836 1
        glxGetScreen(screenInfo.screens[index]);
d843 1
a843 1
    (*screen->leaveVT) (index, flags);
d863 15
d911 10
d931 1
a931 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d938 1
a938 1
        !DRI2Connect(pScreen, DRI2DriverDRI,
@


1.5
log
@Update to xserver 1.11.2
@
text
@d57 2
a58 2
typedef struct __GLXDRIscreen   __GLXDRIscreen;
typedef struct __GLXDRIcontext  __GLXDRIcontext;
d62 4
a65 4
    __GLXscreen		 base;
    __DRIscreen		*driScreen;
    void		*driver;
    int			 fd;
d67 2
a68 2
    xf86EnterVTProc	*enterVT;
    xf86LeaveVTProc	*leaveVT;
d76 1
d82 2
a83 2
    __GLXcontext	 base;
    __DRIcontext	*driContext;
d89 3
a91 3
    __GLXdrawable	 base;
    __DRIdrawable	*driDrawable;
    __GLXDRIscreen	*screen;
d101 1
a101 1
__glXDRIdrawableDestroy(__GLXdrawable *drawable)
d105 2
a106 2
    
    (*core->destroyDrawable)(private->driDrawable);
d114 2
a115 2
__glXDRIdrawableCopySubBuffer(__GLXdrawable *drawable,
			       int x, int y, int w, int h)
d128 1
a128 1
		   DRI2BufferFrontLeft, DRI2BufferBackLeft);
d132 1
a132 1
__glXDRIdrawableWaitX(__GLXdrawable *drawable)
d145 1
a145 1
		   DRI2BufferFakeFrontLeft, DRI2BufferFrontLeft);
d149 1
a149 1
__glXDRIdrawableWaitGL(__GLXdrawable *drawable)
d162 1
a162 1
		   DRI2BufferFrontLeft, DRI2BufferFakeFrontLeft);
d167 1
a167 1
		  CARD64 msc, CARD32 sbc)
d173 1
a173 1
	return;
d178 2
a179 2
	wire.event_type = GLX_EXCHANGE_COMPLETE_INTEL;
	break;
d181 2
a182 2
	wire.event_type = GLX_BLIT_COMPLETE_INTEL;
	break;
d184 2
a185 2
	wire.event_type = GLX_FLIP_COMPLETE_INTEL;
	break;
d187 3
a189 3
	/* unknown swap completion type */
	wire.event_type = 0;
	break;
d208 1
a208 1
__glXDRIdrawableSwapBuffers(ClientPtr client, __GLXdrawable *drawable)
d216 2
a217 2
	(*screen->flush->flush)(priv->driDrawable);
	(*screen->flush->invalidate)(priv->driDrawable);
d221 1
a221 1
	(*screen->flush->flushInvalidate)(priv->driDrawable);
d225 2
a226 2
			__glXdriSwapEvent, drawable) != Success)
	return FALSE;
d232 1
a232 1
__glXDRIdrawableSwapInterval(__GLXdrawable *drawable, int interval)
d234 2
a235 2
    if (interval <= 0) /* || interval > BIGNUM? */
	return GLX_BAD_VALUE;
d243 1
a243 1
__glXDRIcontextDestroy(__GLXcontext *baseContext)
d248 1
a248 1
    (*screen->core->destroyContext)(context->driContext);
d254 1
a254 1
__glXDRIcontextMakeCurrent(__GLXcontext *baseContext)
d261 3
a263 4
    return (*screen->core->bindContext)(context->driContext,
					draw->driDrawable,
					read->driDrawable);
}					      
d266 1
a266 1
__glXDRIcontextLoseCurrent(__GLXcontext *baseContext)
d271 1
a271 1
    return (*screen->core->unbindContext)(context->driContext);
d275 2
a276 2
__glXDRIcontextCopy(__GLXcontext *baseDst, __GLXcontext *baseSrc,
		    unsigned long mask)
d282 2
a283 2
    return (*screen->core->copyContext)(dst->driContext,
					src->driContext, mask);
d287 2
a288 2
__glXDRIcontextWait(__GLXcontext *baseContext,
		    __GLXclientState *cl, int *error)
d291 2
a292 2
	*error = cl->client->noClientException;
	return TRUE;
d301 2
a302 3
__glXDRIbindTexImage(__GLXcontext *baseContext,
		     int buffer,
		     __GLXdrawable *glxPixmap)
d313 5
a317 5
	(*texBuffer->setTexBuffer2)(context->driContext,
				    glxPixmap->target,
				    glxPixmap->format,
				    drawable->driDrawable);
    } else
d320 2
a321 3
	texBuffer->setTexBuffer(context->driContext,
				glxPixmap->target,
				drawable->driDrawable);
d328 2
a329 3
__glXDRIreleaseTexImage(__GLXcontext *baseContext,
			int buffer,
			__GLXdrawable *pixmap)
d338 2
a339 3
__glXDRIbindTexImage(__GLXcontext *baseContext,
		     int buffer,
		     __GLXdrawable *glxPixmap)
d345 2
a346 3
__glXDRIreleaseTexImage(__GLXcontext *baseContext,
			int buffer,
			__GLXdrawable *pixmap)
d359 1
a359 1
__glXDRIscreenDestroy(__GLXscreen *baseScreen)
d361 2
d365 1
a365 1
    (*screen->core->destroyScreen)(screen->driScreen);
d371 6
d381 3
a383 3
__glXDRIscreenCreateContext(__GLXscreen *baseScreen,
			    __GLXconfig *glxConfig,
			    __GLXcontext *baseShareContext)
d392 1
a392 1
	driShare = shareContext->driContext;
d394 1
a394 1
	driShare = NULL;
d398 1
a398 1
	return NULL;
d400 4
a403 4
    context->base.destroy           = __glXDRIcontextDestroy;
    context->base.makeCurrent       = __glXDRIcontextMakeCurrent;
    context->base.loseCurrent       = __glXDRIcontextLoseCurrent;
    context->base.copy              = __glXDRIcontextCopy;
d405 1
a405 1
    context->base.wait              = __glXDRIcontextWait;
d408 3
a410 3
	(*screen->dri2->createNewContext)(screen->driScreen,
					  config->driConfig,
					  driShare, context);
d412 1
a412 1
	    free(context);
d420 1
a420 1
__glXDRIinvalidateBuffers(DrawablePtr pDraw, void *priv)
d427 1
a427 1
	(*screen->flush->invalidate)(private->driDrawable);
d433 4
a436 6
			     __GLXscreen *screen,
			     DrawablePtr pDraw,
			     XID drawId,
			     int type,
			     XID glxDrawId,
			     __GLXconfig *glxConfig)
d444 1
a444 1
	return NULL;
d448 1
a448 1
			   pDraw, type, glxDrawId, glxConfig)) {
d450 1
a450 1
	return NULL;
d453 2
a454 2
    private->base.destroy       = __glXDRIdrawableDestroy;
    private->base.swapBuffers   = __glXDRIdrawableSwapBuffers;
d456 2
a457 2
    private->base.waitGL	= __glXDRIdrawableWaitGL;
    private->base.waitX		= __glXDRIdrawableWaitX;
d460 3
a462 3
			   __glXDRIinvalidateBuffers, private)) {
	    free(private);
	    return NULL;
d466 2
a467 2
	(*driScreen->dri2->createNewDrawable)(driScreen->driScreen,
					      config->driConfig, private);
d473 4
a476 4
dri2GetBuffers(__DRIdrawable *driDrawable,
	       int *width, int *height,
	       unsigned int *attachments, int count,
	       int *out_count, void *loaderPrivate)
d484 1
a484 1
			     width, height, attachments, count, out_count);
d486 2
a487 2
	*out_count = 0;
	return NULL;
d489 1
a489 1
	
d497 13
a509 13
	/* Do not send the real front buffer of a window to the client.
	 */
	if ((private->base.pDraw->type == DRAWABLE_WINDOW)
	    && (buffers[i]->attachment == DRI2BufferFrontLeft)) {
	    continue;
	}

	private->buffers[j].attachment = buffers[i]->attachment;
	private->buffers[j].name = buffers[i]->name;
	private->buffers[j].pitch = buffers[i]->pitch;
	private->buffers[j].cpp = buffers[i]->cpp;
	private->buffers[j].flags = buffers[i]->flags;
	j++;
d517 4
a520 4
dri2GetBuffersWithFormat(__DRIdrawable *driDrawable,
			 int *width, int *height,
			 unsigned int *attachments, int count,
			 int *out_count, void *loaderPrivate)
d528 2
a529 2
				       width, height, attachments, count,
				       out_count);
d531 2
a532 2
	*out_count = 0;
	return NULL;
d541 13
a553 13
	/* Do not send the real front buffer of a window to the client.
	 */
	if ((private->base.pDraw->type == DRAWABLE_WINDOW)
	    && (buffers[i]->attachment == DRI2BufferFrontLeft)) {
	    continue;
	}

	private->buffers[j].attachment = buffers[i]->attachment;
	private->buffers[j].name = buffers[i]->name;
	private->buffers[j].pitch = buffers[i]->pitch;
	private->buffers[j].cpp = buffers[i]->cpp;
	private->buffers[j].flags = buffers[i]->flags;
	j++;
d560 2
a561 2
static void 
dri2FlushFrontBuffer(__DRIdrawable *driDrawable, void *loaderPrivate)
d568 1
a568 1
    { __DRI_DRI2_LOADER, __DRI_DRI2_LOADER_VERSION },
d576 1
a576 1
   { __DRI_USE_INVALIDATE, __DRI_USE_INVALIDATE_VERSION }
d590 1
a590 1
glxDRIEnterVT (int index, int flags)
d593 3
a595 3
    Bool	ret;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) 
	glxGetScreen(screenInfo.screens[index]);
d601 1
a601 1
    ret = scrn->EnterVT (index, flags);
d607 2
a608 2
	return FALSE;
    
d615 1
a615 1
glxDRILeaveVT (int index, int flags)
d619 1
a619 1
	glxGetScreen(screenInfo.screens[index]);
d632 1
a632 1
initializeExtensions(__GLXDRIscreen *screen)
d640 1
a640 2
    __glXEnableExtension(screen->glx_enable_bits,
			 "GLX_MESA_copy_sub_buffer");
d647 4
a650 5
	__glXEnableExtension(screen->glx_enable_bits,
			     "GLX_SGI_swap_control");
	__glXEnableExtension(screen->glx_enable_bits,
			     "GLX_MESA_swap_control");
	LogMessage(X_INFO, "AIGLX: enabled GLX_SGI_swap_control and GLX_MESA_swap_control\n");
d655 3
a657 3
	if (strcmp(extensions[i]->name, __DRI_READ_DRAWABLE) == 0) {
	    __glXEnableExtension(screen->glx_enable_bits,
				 "GLX_SGI_make_current_read");
d659 2
a660 2
	    LogMessage(X_INFO, "AIGLX: enabled GLX_SGI_make_current_read\n");
	}
d664 6
a669 6
	if (strcmp(extensions[i]->name, __DRI_TEX_BUFFER) == 0) {
	    screen->texBuffer =
		(const __DRItexBufferExtension *) extensions[i];
	    /* GLX_EXT_texture_from_pixmap is always enabled. */
	    LogMessage(X_INFO, "AIGLX: GLX_EXT_texture_from_pixmap backed by buffer objects\n");
	}
d673 4
a676 4
	if (strcmp(extensions[i]->name, __DRI2_FLUSH) == 0 &&
	    extensions[i]->version >= 3) {
		screen->flush = (__DRI2flushExtension *) extensions[i];
	}
d679 1
a679 1
	/* Ignore unknown extensions */
a689 1
    const __DRIconfig **driConfigs;
d693 1
a693 1
	return NULL;
d696 5
a700 5
	!DRI2Connect(pScreen, DRI2DriverDRI,
		     &screen->fd, &driverName, &deviceName)) {
	LogMessage(X_INFO,
		   "AIGLX: Screen %d is not DRI2 capable\n", pScreen->myNum);
	return NULL;
d703 2
a704 2
    screen->base.destroy        = __glXDRIscreenDestroy;
    screen->base.createContext  = __glXDRIscreenCreateContext;
d706 2
a707 2
    screen->base.swapInterval   = __glXDRIdrawableSwapInterval;
    screen->base.pScreen       = pScreen;
d711 3
a713 2
    screen->driver = glxProbeDriver(driverName, (void **)&screen->core, __DRI_CORE, 1,
				    (void **)&screen->dri2, __DRI_DRI2, 1);
d717 1
a717 1
    
d719 4
a722 5
	(*screen->dri2->createNewScreen)(pScreen->myNum,
					 screen->fd,
					 loader_extensions,
					 &driConfigs,
					 screen);
d725 2
a726 3
	LogMessage(X_ERROR,
		   "AIGLX error: Calling driver entry point failed\n");
	goto handle_error;
d731 4
a734 4
    screen->base.fbconfigs = glxConvertConfigs(screen->core, driConfigs,
					       GLX_WINDOW_BIT |
					       GLX_PIXMAP_BIT |
					       GLX_PBUFFER_BIT);
d744 1
a744 1
	free(screen->base.GLXextensions);
d746 3
a748 3
	screen->base.GLXextensions = xnfalloc(buffer_size);
	(void) __glXGetExtensionString(screen->glx_enable_bits, 
				       screen->base.GLXextensions);
d762 1
a762 1
    
d764 1
a764 1
    pScrn->EnterVT = glxDRIEnterVT; 
d768 1
a768 2
    LogMessage(X_INFO,
	       "AIGLX: Loaded and initialized %s\n", driverName);
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a50 1
#include "g_disptab.h"
d166 1
a166 1
		  CARD64 msc, CARD64 sbc)
d169 1
a169 1
    xGLXBufferSwapComplete wire;
d187 1
d195 1
a195 2
    wire.sbc_hi = sbc >> 32;
    wire.sbc_lo = sbc & 0xffffffff;
d224 1
a224 1
			__glXdriSwapEvent, drawable->pDraw) != Success)
a285 13
static int
__glXDRIcontextForceCurrent(__GLXcontext *baseContext)
{
    __GLXDRIcontext *context = (__GLXDRIcontext *) baseContext;
    __GLXDRIdrawable *draw = (__GLXDRIdrawable *) baseContext->drawPriv;
    __GLXDRIdrawable *read = (__GLXDRIdrawable *) baseContext->readPriv;
    __GLXDRIscreen *screen = (__GLXDRIscreen *) context->base.pGlxScreen;

    return (*screen->core->bindContext)(context->driContext,
					draw->driDrawable,
					read->driDrawable);
}

a400 1
    context->base.forceCurrent      = __glXDRIcontextForceCurrent;
d583 1
a583 1
    &dri2UseInvalidate,
a587 2
static const char dri_driver_path[] = DRI_DRIVER_PATH;

a688 1
    char filename[128];
a690 1
    const __DRIextension **extensions;
a691 1
    int i;
d713 2
a714 4
    snprintf(filename, sizeof filename,
	     "%s/%s_dri.so", dri_driver_path, driverName);

    screen->driver = dlopen(filename, RTLD_LAZY | RTLD_LOCAL);
a715 2
	LogMessage(X_ERROR, "AIGLX error: dlopen of %s failed (%s)\n",
		   filename, dlerror());
a717 7

    extensions = dlsym(screen->driver, __DRI_DRIVER_EXTENSIONS);
    if (extensions == NULL) {
	LogMessage(X_ERROR, "AIGLX error: %s exports no extensions (%s)\n",
		   driverName, dlerror());
	goto handle_error;
    }
a718 17
    for (i = 0; extensions[i]; i++) {
        if (strcmp(extensions[i]->name, __DRI_CORE) == 0 &&
	    extensions[i]->version >= 1) {
		screen->core = (const __DRIcoreExtension *) extensions[i];
	}
        if (strcmp(extensions[i]->name, __DRI_DRI2) == 0 &&
	    extensions[i]->version >= 1) {
		screen->dri2 = (const __DRIdri2Extension *) extensions[i];
	}
    }

    if (screen->core == NULL || screen->dri2 == NULL) {
	LogMessage(X_ERROR, "AIGLX error: %s exports no DRI extension\n",
		   driverName);
	goto handle_error;
    }

d747 1
a747 3
	if (screen->base.GLXextensions != NULL) {
	    free(screen->base.GLXextensions);
	}
d772 1
a772 1
	       "AIGLX: Loaded and initialized %s\n", filename);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d110 1
a110 1
    xfree(private);
d125 1
a125 1
    REGION_INIT(drawable->pDraw->pScreen, &region, &box, 0);
d142 1
a142 1
    REGION_INIT(drawable->pDraw->pScreen, &region, &box, 0);
d159 1
a159 1
    REGION_INIT(drawable->pDraw->pScreen, &region, &box, 0);
a189 1
    wire.sequenceNumber = client->sequence;
d250 1
a250 1
    xfree(context);
d388 1
a388 1
    xfree(screen);
d407 1
a407 1
    context = xcalloc(1, sizeof *context);
d424 1
a424 1
	    xfree(context);
d431 12
d456 1
a456 1
    private = xcalloc(1, sizeof *private);
d463 1
a463 1
        xfree(private);
d473 3
a475 2
    if (DRI2CreateDrawable(client, pDraw, drawId)) {
	    xfree(private);
d588 6
d597 3
d608 2
d615 8
a622 1
    if (!(*screen->enterVT) (index, flags))
d633 1
d641 4
a644 1
    return (*screen->leaveVT) (index, flags);
d713 1
a713 1
    screen = xcalloc(1, sizeof *screen);
d782 4
a785 1
    screen->base.fbconfigs = glxConvertConfigs(screen->core, driConfigs);
d796 1
a796 1
	    xfree(screen->base.GLXextensions);
d830 1
a830 1
    xfree(screen);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d73 1
a107 5
    /* If the X window was destroyed, the dri DestroyWindow hook will
     * aready have taken care of this, so only call if pDraw isn't NULL. */
    if (drawable->pDraw != NULL)
	DRI2DestroyDrawable(drawable->pDraw);

a130 11
static GLboolean
__glXDRIdrawableSwapBuffers(__GLXdrawable *drawable)
{
    __GLXDRIdrawable *private = (__GLXDRIdrawable *) drawable;

    __glXDRIdrawableCopySubBuffer(drawable, 0, 0,
				  private->width, private->height);

    return TRUE;
}

d165 67
d235 5
d301 12
d418 1
d433 2
a434 1
__glXDRIscreenCreateDrawable(__GLXscreen *screen,
d436 1
d438 1
a438 1
			     XID drawId,
d451 1
a451 1
			   pDraw, type, drawId, glxConfig)) {
d462 1
a462 1
    if (DRI2CreateDrawable(pDraw)) {
d616 1
d626 11
d638 2
a639 4
#ifdef __DRI_SWAP_CONTROL
	if (strcmp(extensions[i]->name, __DRI_SWAP_CONTROL) == 0) {
	    screen->swapControl =
		(const __DRIswapControlExtension *) extensions[i];
d641 3
a643 5
				 "GLX_SGI_swap_control");
	    __glXEnableExtension(screen->glx_enable_bits,
				 "GLX_MESA_swap_control");
	    
	    LogMessage(X_INFO, "AIGLX: enabled GLX_SGI_swap_control and GLX_MESA_swap_control\n");
d655 8
d718 1
a718 1
	    extensions[i]->version >= __DRI_CORE_VERSION) {
d722 1
a722 1
	    extensions[i]->version >= __DRI_DRI2_VERSION) {
d752 4
d767 12
d800 1
a800 1
__GLXprovider __glXDRI2Provider = {
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d72 1
d85 2
d91 6
d112 2
d117 3
a119 2
static GLboolean
__glXDRIdrawableResize(__GLXdrawable *glxPriv)
d121 3
a123 2
    /* Nothing to do here, the DRI driver asks the server for drawable
     * geometry when it sess the SAREA timestamps change.*/
d125 8
a132 1
    return GL_TRUE;
a138 1
    const __DRIcoreExtension *core = private->screen->core;
d140 2
a141 1
    (*core->swapBuffers)(private->driDrawable);
d146 2
a147 3

static int
__glXDRIdrawableSwapInterval(__GLXdrawable *drawable, int interval)
d150 2
a151 1
    const __DRIswapControlExtension *swapControl = private->screen->swapControl;
d153 5
a157 2
    if (swapControl)
	swapControl->setSwapInterval(private->driDrawable, interval);
d159 2
a160 1
    return 0;
a162 1

d164 1
a164 2
__glXDRIdrawableCopySubBuffer(__GLXdrawable *basePrivate,
			       int x, int y, int w, int h)
d166 9
a174 3
    __GLXDRIdrawable *private = (__GLXDRIdrawable *) basePrivate;
    const __DRIcopySubBufferExtension *copySubBuffer =
	    private->screen->copySubBuffer;
d176 8
a183 2
    if (copySubBuffer)
	(*copySubBuffer->copySubBuffer)(private->driDrawable, x, y, w, h);
d258 13
a270 3
    texBuffer->setTexBuffer(context->driContext,
			    glxPixmap->target,
			    drawable->driDrawable);
a330 1
    const __DRIcoreExtension *core = screen->core;
d339 1
a339 1
    context = xalloc(sizeof *context);
a342 1
    memset(context, 0, sizeof *context);
d351 7
a357 2
	(*core->createNewContext)(screen->driScreen,
				  config->driConfig, driShare, context);
a371 2
    GLboolean retval;
    unsigned int handle, head;
d373 1
a373 1
    private = xalloc(sizeof *private);
a376 2
    memset(private, 0, sizeof *private);

a384 1
    private->base.resize        = __glXDRIdrawableResize;
d387 2
d390 4
a393 1
    retval = DRI2CreateDrawable(pDraw, &handle, &head);
d396 2
a397 3
	(*driScreen->core->createNewDrawable)(driScreen->driScreen, 
					      config->driConfig,
					      handle, head, private);
d402 5
a406 2
static void dri2ReemitDrawableInfo(__DRIdrawable *draw, unsigned int *tail,
				   void *loaderPrivate)
d408 25
a432 1
    __GLXDRIdrawable *pdraw = loaderPrivate;
d434 10
a443 1
    DRI2ReemitDrawableInfo(pdraw->base.pDraw, tail);
d446 43
a488 7
static void dri2PostDamage(__DRIdrawable *draw,
			   struct drm_clip_rect *rects,
			   int numRects, void *loaderPrivate)
{ 
    __GLXDRIdrawable *drawable = loaderPrivate;
    DrawablePtr pDraw = drawable->base.pDraw;
    RegionRec region;
d490 5
a494 4
    REGION_INIT(pDraw->pScreen, &region, (BoxPtr) rects, numRects);
    REGION_TRANSLATE(pScreen, &region, pDraw->x, pDraw->y);
    DamageDamageRegion(pDraw, &region);
    REGION_UNINIT(pDraw->pScreen, &region);
d497 5
a501 4
static const __DRIloaderExtension loaderExtension = {
    { __DRI_LOADER, __DRI_LOADER_VERSION },
    dri2ReemitDrawableInfo,
    dri2PostDamage
d549 4
a553 11
#ifdef __DRI_COPY_SUB_BUFFER
	if (strcmp(extensions[i]->name, __DRI_COPY_SUB_BUFFER) == 0) {
	    screen->copySubBuffer =
		(const __DRIcopySubBufferExtension *) extensions[i];
	    __glXEnableExtension(screen->glx_enable_bits,
				 "GLX_MESA_copy_sub_buffer");
	    
	    LogMessage(X_INFO, "AIGLX: enabled GLX_MESA_copy_sub_buffer\n");
	}
#endif

d582 1
a582 1
    const char *driverName;
a586 1
    unsigned int sareaHandle;
d591 1
a591 1
    screen = xalloc(sizeof *screen);
a593 1
    memset(screen, 0, sizeof *screen);
d596 2
a597 1
	!DRI2Connect(pScreen, &screen->fd, &driverName, &sareaHandle)) {
d633 4
d639 1
a639 1
    if (screen->core == NULL) {
d646 1
a646 1
	(*screen->core->createNewScreen)(pScreen->myNum,
a647 1
					 sareaHandle,
d653 2
a654 1
	LogMessage(X_ERROR, "AIGLX error: Calling driver entry point failed");
@

