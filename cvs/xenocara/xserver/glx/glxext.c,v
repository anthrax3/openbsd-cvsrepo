head	1.11;
access;
symbols
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.08.09.18.59.51;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	6HLO5qdN5N4nPDjW;

1.10
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>
#include "glxserver.h"
#include <windowstr.h>
#include <propertyst.h>
#include <registry.h>
#include "privates.h"
#include <os.h>
#include "extinit.h"
#include "glx_extinit.h"
#include "unpack.h"
#include "glxutil.h"
#include "glxext.h"
#include "indirect_table.h"
#include "indirect_util.h"

/*
** X resources.
*/
RESTYPE __glXContextRes;
RESTYPE __glXDrawableRes;

/*
** Reply for most singles.
*/
xGLXSingleReply __glXReply;

static DevPrivateKeyRec glxClientPrivateKeyRec;

#define glxClientPrivateKey (&glxClientPrivateKeyRec)

/*
** Forward declarations.
*/
static int __glXDispatch(ClientPtr);
static GLboolean __glXFreeContext(__GLXcontext * cx);

/*
** Called when the extension is reset.
*/
static void
ResetExtension(ExtensionEntry * extEntry)
{
    lastGLContext = NULL;
}

/*
** Reset state used to keep track of large (multi-request) commands.
*/
void
__glXResetLargeCommandStatus(__GLXclientState * cl)
{
    cl->largeCmdBytesSoFar = 0;
    cl->largeCmdBytesTotal = 0;
    cl->largeCmdRequestsSoFar = 0;
    cl->largeCmdRequestsTotal = 0;
}

/*
 * This procedure is called when the client who created the context goes away
 * OR when glXDestroyContext is called.  In either case, all we do is flag that
 * the ID is no longer valid, and (maybe) free the context.
 */
static int
ContextGone(__GLXcontext * cx, XID id)
{
    cx->idExists = GL_FALSE;
    if (!cx->currentClient) {
        __glXFreeContext(cx);
    }

    return True;
}

static __GLXcontext *glxPendingDestroyContexts;
static __GLXcontext *glxAllContexts;
static int glxServerLeaveCount;
static int glxBlockClients;

/*
** Destroy routine that gets called when a drawable is freed.  A drawable
** contains the ancillary buffers needed for rendering.
*/
static Bool
DrawableGone(__GLXdrawable * glxPriv, XID xid)
{
    __GLXcontext *c, *next;

    if (glxPriv->type == GLX_DRAWABLE_WINDOW) {
        /* If this was created by glXCreateWindow, free the matching resource */
        if (glxPriv->drawId != glxPriv->pDraw->id) {
            if (xid == glxPriv->drawId)
                FreeResourceByType(glxPriv->pDraw->id, __glXDrawableRes, TRUE);
            else
                FreeResourceByType(glxPriv->drawId, __glXDrawableRes, TRUE);
        }
        /* otherwise this window was implicitly created by MakeCurrent */
    }

    for (c = glxAllContexts; c; c = next) {
        next = c->next;
        if (c->currentClient &&
		(c->drawPriv == glxPriv || c->readPriv == glxPriv)) {
            /* flush the context */
            glFlush();
            c->hasUnflushedCommands = GL_FALSE;
            /* just force a re-bind the next time through */
            (*c->loseCurrent) (c);
            lastGLContext = NULL;
        }
        if (c->drawPriv == glxPriv)
            c->drawPriv = NULL;
        if (c->readPriv == glxPriv)
            c->readPriv = NULL;
    }

    /* drop our reference to any backing pixmap */
    if (glxPriv->type == GLX_DRAWABLE_PIXMAP)
        glxPriv->pDraw->pScreen->DestroyPixmap((PixmapPtr) glxPriv->pDraw);

    glxPriv->destroy(glxPriv);

    return True;
}

Bool
__glXAddContext(__GLXcontext * cx)
{
    /* Register this context as a resource.
     */
    if (!AddResource(cx->id, __glXContextRes, (void *)cx)) {
	return False;
    }

    cx->next = glxAllContexts;
    glxAllContexts = cx;
    return True;
}

static void
__glXRemoveFromContextList(__GLXcontext * cx)
{
    __GLXcontext *c, *prev;

    if (cx == glxAllContexts)
        glxAllContexts = cx->next;
    else {
        prev = glxAllContexts;
        for (c = glxAllContexts; c; c = c->next) {
            if (c == cx)
                prev->next = c->next;
            prev = c;
        }
    }
}

/*
** Free a context.
*/
static GLboolean
__glXFreeContext(__GLXcontext * cx)
{
    if (cx->idExists || cx->currentClient)
        return GL_FALSE;

    __glXRemoveFromContextList(cx);

    free(cx->feedbackBuf);
    free(cx->selectBuf);
    if (cx == lastGLContext) {
        lastGLContext = NULL;
    }

    /* We can get here through both regular dispatching from
     * __glXDispatch() or as a callback from the resource manager.  In
     * the latter case we need to lift the DRI lock manually. */

    if (!glxBlockClients) {
        __glXleaveServer(GL_FALSE);
        cx->destroy(cx);
        __glXenterServer(GL_FALSE);
    }
    else {
        cx->next = glxPendingDestroyContexts;
        glxPendingDestroyContexts = cx;
    }

    return GL_TRUE;
}

/************************************************************************/

/*
** These routines can be used to check whether a particular GL command
** has caused an error.  Specifically, we use them to check whether a
** given query has caused an error, in which case a zero-length data
** reply is sent to the client.
*/

static GLboolean errorOccured = GL_FALSE;

/*
** The GL was will call this routine if an error occurs.
*/
void
__glXErrorCallBack(GLenum code)
{
    errorOccured = GL_TRUE;
}

/*
** Clear the error flag before calling the GL command.
*/
void
__glXClearErrorOccured(void)
{
    errorOccured = GL_FALSE;
}

/*
** Check if the GL command caused an error.
*/
GLboolean
__glXErrorOccured(void)
{
    return errorOccured;
}

static int __glXErrorBase;
int __glXEventBase;

int
__glXError(int error)
{
    return __glXErrorBase + error;
}

__GLXclientState *
glxGetClient(ClientPtr pClient)
{
    return dixLookupPrivate(&pClient->devPrivates, glxClientPrivateKey);
}

static void
glxClientCallback(CallbackListPtr *list, void *closure, void *data)
{
    NewClientInfoRec *clientinfo = (NewClientInfoRec *) data;
    ClientPtr pClient = clientinfo->client;
    __GLXclientState *cl = glxGetClient(pClient);
    __GLXcontext *c, *next;

    switch (pClient->clientState) {
    case ClientStateRunning:
        cl->client = pClient;
        break;

    case ClientStateGone:
        /* detach from all current contexts */
        for (c = glxAllContexts; c; c = next) {
            next = c->next;
            if (c->currentClient == pClient) {
                c->loseCurrent(c);
                lastGLContext = NULL;
                c->currentClient = NULL;
                FreeResourceByType(c->id, __glXContextRes, FALSE);
            }
        }

        free(cl->returnBuf);
        free(cl->largeCmdBuf);
        free(cl->GLClientextensions);
        break;

    default:
        break;
    }
}

/************************************************************************/

static __GLXprovider *__glXProviderStack;

void
GlxPushProvider(__GLXprovider * provider)
{
    provider->next = __glXProviderStack;
    __glXProviderStack = provider;
}

static Bool
checkScreenVisuals(void)
{
    int i, j;

    for (i = 0; i < screenInfo.numScreens; i++) {
        ScreenPtr screen = screenInfo.screens[i];
        for (j = 0; j < screen->numVisuals; j++) {
            if (screen->visuals[j].class == TrueColor ||
                screen->visuals[j].class == DirectColor)
                return True;
        }
    }

    return False;
}

/*
** Initialize the GLX extension.
*/
void
GlxExtensionInit(void)
{
    ExtensionEntry *extEntry;
    ScreenPtr pScreen;
    int i;
    __GLXprovider *p, **stack;
    Bool glx_provided = False;

    if (serverGeneration == 1) {
        for (stack = &__glXProviderStack; *stack; stack = &(*stack)->next)
            ;
        *stack = &__glXDRISWRastProvider;
    }

    /* Mesa requires at least one True/DirectColor visual */
    if (!checkScreenVisuals())
        return;

    __glXContextRes = CreateNewResourceType((DeleteType) ContextGone,
                                            "GLXContext");
    __glXDrawableRes = CreateNewResourceType((DeleteType) DrawableGone,
                                             "GLXDrawable");
    if (!__glXContextRes || !__glXDrawableRes)
        return;

    if (!dixRegisterPrivateKey
        (&glxClientPrivateKeyRec, PRIVATE_CLIENT, sizeof(__GLXclientState)))
        return;
    if (!AddCallback(&ClientStateCallback, glxClientCallback, 0))
        return;

    for (i = 0; i < screenInfo.numScreens; i++) {
        pScreen = screenInfo.screens[i];

        for (p = __glXProviderStack; p != NULL; p = p->next) {
            __GLXscreen *glxScreen;

            glxScreen = p->screenProbe(pScreen);
            if (glxScreen != NULL) {
                if (glxScreen->GLXminor < glxMinorVersion)
                    glxMinorVersion = glxScreen->GLXminor;
                LogMessage(X_INFO,
                           "GLX: Initialized %s GL provider for screen %d\n",
                           p->name, i);
                break;
            }

        }

        if (!p)
            LogMessage(X_INFO,
                       "GLX: no usable GL providers found for screen %d\n", i);
        else
            glx_provided = True;
    }

    /* don't register extension if GL is not provided on any screen */
    if (!glx_provided)
        return;

    /*
     ** Add extension to server extensions.
     */
    extEntry = AddExtension(GLX_EXTENSION_NAME, __GLX_NUMBER_EVENTS,
                            __GLX_NUMBER_ERRORS, __glXDispatch,
                            __glXDispatch, ResetExtension, StandardMinorOpcode);
    if (!extEntry) {
        FatalError("__glXExtensionInit: AddExtensions failed\n");
        return;
    }
    if (!AddExtensionAlias(GLX_EXTENSION_ALIAS, extEntry)) {
        ErrorF("__glXExtensionInit: AddExtensionAlias failed\n");
        return;
    }

    __glXErrorBase = extEntry->errorBase;
    __glXEventBase = extEntry->eventBase;
#if PRESENT
    __glXregisterPresentCompleteNotify();
#endif
}

/************************************************************************/

/*
** Make a context the current one for the GL (in this implementation, there
** is only one instance of the GL, and we use it to serve all GL clients by
** switching it between different contexts).  While we are at it, look up
** a context by its tag and return its (__GLXcontext *).
*/
__GLXcontext *
__glXForceCurrent(__GLXclientState * cl, GLXContextTag tag, int *error)
{
    __GLXcontext *cx;

    /*
     ** See if the context tag is legal; it is managed by the extension,
     ** so if it's invalid, we have an implementation error.
     */
    cx = __glXLookupContextByTag(cl, tag);
    if (!cx) {
        cl->client->errorValue = tag;
        *error = __glXError(GLXBadContextTag);
        return 0;
    }

    if (!cx->isDirect) {
        if (cx->drawPriv == NULL) {
            /*
             ** The drawable has vanished.  It must be a window, because only
             ** windows can be destroyed from under us; GLX pixmaps are
             ** refcounted and don't go away until no one is using them.
             */
            *error = __glXError(GLXBadCurrentWindow);
            return 0;
        }
    }

    if (cx->wait && (*cx->wait) (cx, cl, error))
        return NULL;

    if (cx == lastGLContext) {
        /* No need to re-bind */
        return cx;
    }

    /* Make this context the current one for the GL. */
    if (!cx->isDirect) {
        /*
         * If it is being forced, it means that this context was already made
         * current. So it cannot just be made current again without decrementing
         * refcount's
         */
        (*cx->loseCurrent) (cx);
        lastGLContext = cx;
        if (!(*cx->makeCurrent) (cx)) {
            /* Bind failed, and set the error code.  Bummer */
            lastGLContext = NULL;
            cl->client->errorValue = cx->id;
            *error = __glXError(GLXBadContextState);
            return 0;
        }
    }
    return cx;
}

/************************************************************************/

void
glxSuspendClients(void)
{
    int i;

    for (i = 1; i < currentMaxClients; i++) {
        if (clients[i] && glxGetClient(clients[i])->inUse)
            IgnoreClient(clients[i]);
    }

    glxBlockClients = TRUE;
}

void
glxResumeClients(void)
{
    __GLXcontext *cx, *next;
    int i;

    glxBlockClients = FALSE;

    for (i = 1; i < currentMaxClients; i++) {
        if (clients[i] && glxGetClient(clients[i])->inUse)
            AttendClient(clients[i]);
    }

    __glXleaveServer(GL_FALSE);
    for (cx = glxPendingDestroyContexts; cx != NULL; cx = next) {
        next = cx->next;

        cx->destroy(cx);
    }
    glxPendingDestroyContexts = NULL;
    __glXenterServer(GL_FALSE);
}

static void
__glXnopEnterServer(GLboolean rendering)
{
}

static void
__glXnopLeaveServer(GLboolean rendering)
{
}

static void (*__glXenterServerFunc) (GLboolean) = __glXnopEnterServer;
static void (*__glXleaveServerFunc) (GLboolean) = __glXnopLeaveServer;

void
__glXsetEnterLeaveServerFuncs(void (*enter) (GLboolean),
                              void (*leave) (GLboolean))
{
    __glXenterServerFunc = enter;
    __glXleaveServerFunc = leave;
}

void
__glXenterServer(GLboolean rendering)
{
    glxServerLeaveCount--;

    if (glxServerLeaveCount == 0)
        (*__glXenterServerFunc) (rendering);
}

void
__glXleaveServer(GLboolean rendering)
{
    if (glxServerLeaveCount == 0)
        (*__glXleaveServerFunc) (rendering);

    glxServerLeaveCount++;
}

static glx_gpa_proc _get_proc_address;

void
__glXsetGetProcAddress(glx_gpa_proc get_proc_address)
{
    _get_proc_address = get_proc_address;
}

void *__glGetProcAddress(const char *proc)
{
    void *ret = (void *) _get_proc_address(proc);

    return ret ? ret : (void *) NoopDDA;
}

/*
** Top level dispatcher; all commands are executed from here down.
*/
static int
__glXDispatch(ClientPtr client)
{
    REQUEST(xGLXSingleReq);
    CARD8 opcode;
    __GLXdispatchSingleProcPtr proc;
    __GLXclientState *cl;
    int retval;

    opcode = stuff->glxCode;
    cl = glxGetClient(client);
    /* Mark it in use so we suspend it on VT switch. */
    cl->inUse = TRUE;

    /*
     ** If we're expecting a glXRenderLarge request, this better be one.
     */
    if ((cl->largeCmdRequestsSoFar != 0) && (opcode != X_GLXRenderLarge)) {
        client->errorValue = stuff->glxCode;
        return __glXError(GLXBadLargeRequest);
    }

    /* If we're currently blocking GLX clients, just put this guy to
     * sleep, reset the request and return. */
    if (glxBlockClients) {
        ResetCurrentRequest(client);
        client->sequence--;
        IgnoreClient(client);
        return Success;
    }

    /*
     ** Use the opcode to index into the procedure table.
     */
    proc = __glXGetProtocolDecodeFunction(&Single_dispatch_info, opcode,
                                          client->swapped);
    if (proc != NULL) {
        GLboolean rendering = opcode <= X_GLXRenderLarge;

        __glXleaveServer(rendering);

        retval = (*proc) (cl, (GLbyte *) stuff);

        __glXenterServer(rendering);
    }
    else {
        retval = BadRequest;
    }

    return retval;
}
@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d472 6
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d69 1
d137 3
d193 1
a193 1
GLboolean
d298 1
a298 1
                __glXFreeContext(c);
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a50 6
** The last context used by the server.  It is the context that is current
** from the server's perspective.
*/
__GLXcontext *__glXLastContext;

/*
d76 1
a76 1
    __glXFlushContextCache();
d138 1
a138 2
            if (c == __glXLastContext)
                __glXFlushContextCache();
d160 1
a160 1
    if (!AddResource(cx->id, __glXContextRes, (pointer)cx)) {
d199 2
a200 2
    if (cx == __glXLastContext) {
        __glXFlushContextCache();
d274 1
a274 1
glxClientCallback(CallbackListPtr *list, pointer closure, pointer data)
d292 1
d319 17
d354 4
a423 6
void
__glXFlushContextCache(void)
{
    __glXLastContext = 0;
}

d461 1
a461 1
    if (cx == __glXLastContext) {
d468 1
d471 1
a476 1
    __glXLastContext = cx;
d567 1
a567 1
    void *ret = _get_proc_address(proc);
d569 1
a569 1
    return ret ? ret : NoopDDA;
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d98 4
a101 5
** This procedure is called when the client who created the context goes
** away OR when glXDestroyContext is called.  In either case, all we do is
** flag that the ID is no longer valid, and (maybe) free the context.
** use.
*/
d106 1
a106 1
    if (!cx->isCurrent) {
d140 3
a142 1
        if (c->isCurrent && (c->drawPriv == glxPriv || c->readPriv == glxPriv)) {
a143 1
            c->isCurrent = GL_FALSE;
d199 1
a199 1
    if (cx->idExists || cx->isCurrent)
d202 2
a209 2
    __glXRemoveFromContextList(cx);

d286 1
a289 4
        /*
         ** By default, assume that the client supports
         ** GLX major version 1 minor version 0 protocol.
         */
d294 10
d402 3
d545 15
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d42 2
d162 2
a163 2
void
__glXAddToContextList(__GLXcontext * cx)
d165 6
d173 1
a292 2
        cl->GLClientmajorVersion = 1;
        cl->GLClientminorVersion = 0;
d327 1
a327 1
    __GLXprovider *p;
d329 6
@


1.5
log
@Update to xserver 1.11.2
@
text
@d66 1
d77 2
a78 1
static void ResetExtension(ExtensionEntry* extEntry)
d86 2
a87 1
void __glXResetLargeCommandStatus(__GLXclientState *cl)
d101 2
a102 1
static int ContextGone(__GLXcontext* cx, XID id)
d106 1
a106 1
	__glXFreeContext(cx);
d121 2
a122 1
static Bool DrawableGone(__GLXdrawable *glxPriv, XID xid)
d138 11
a148 11
	next = c->next;
	if (c->isCurrent && (c->drawPriv == glxPriv || c->readPriv == glxPriv)) {
	    (*c->loseCurrent)(c);
	    c->isCurrent = GL_FALSE;
	    if (c == __glXLastContext)
		__glXFlushContextCache();
	}
	if (c->drawPriv == glxPriv)
	    c->drawPriv = NULL;
	if (c->readPriv == glxPriv)
	    c->readPriv = NULL;
d153 1
a153 1
        glxPriv->pDraw->pScreen->DestroyPixmap((PixmapPtr)glxPriv->pDraw);
d160 2
a161 1
void __glXAddToContextList(__GLXcontext *cx)
d167 2
a168 1
static void __glXRemoveFromContextList(__GLXcontext *cx)
d173 1
a173 1
	glxAllContexts = cx->next;
d175 6
a180 6
	prev = glxAllContexts;
	for (c = glxAllContexts; c; c = c->next) {
	    if (c == cx)
		prev->next = c->next;
	    prev = c;
	}
d187 2
a188 1
GLboolean __glXFreeContext(__GLXcontext *cx)
d190 3
a192 2
    if (cx->idExists || cx->isCurrent) return GL_FALSE;
    
d196 1
a196 1
	__glXFlushContextCache();
d206 7
a212 6
	__glXleaveServer(GL_FALSE);
	cx->destroy(cx);
	__glXenterServer(GL_FALSE);
    } else {
	cx->next = glxPendingDestroyContexts;
	glxPendingDestroyContexts = cx;
d232 2
a233 1
void __glXErrorCallBack(GLenum code)
d241 2
a242 1
void __glXClearErrorOccured(void)
d250 2
a251 1
GLboolean __glXErrorOccured(void)
d259 2
a260 1
int __glXError(int error)
d272 5
a276 7
glxClientCallback (CallbackListPtr	*list,
		   pointer		closure,
		   pointer		data)
{
    NewClientInfoRec	*clientinfo = (NewClientInfoRec *) data;
    ClientPtr		pClient = clientinfo->client;
    __GLXclientState	*cl = glxGetClient(pClient);
d280 8
a287 8
	/*
	** By default, assume that the client supports
	** GLX major version 1 minor version 0 protocol.
	*/
	cl->GLClientmajorVersion = 1;
	cl->GLClientminorVersion = 0;
	cl->client = pClient;
	break;
d290 4
a293 4
	free(cl->returnBuf);
	free(cl->largeCmdBuf);
	free(cl->GLClientextensions);
	break;
d296 1
a296 1
	break;
d304 2
a305 1
void GlxPushProvider(__GLXprovider *provider)
d314 2
a315 1
void GlxExtensionInit(void)
d323 4
a326 4
    __glXContextRes = CreateNewResourceType((DeleteType)ContextGone,
					    "GLXContext");
    __glXDrawableRes = CreateNewResourceType((DeleteType)DrawableGone,
					     "GLXDrawable");
d328 1
a328 1
	return;
d330 5
a334 4
    if (!dixRegisterPrivateKey(&glxClientPrivateKeyRec, PRIVATE_CLIENT, sizeof (__GLXclientState)))
	return;
    if (!AddCallback (&ClientStateCallback, glxClientCallback, 0))
	return;
d337 4
a340 1
	pScreen = screenInfo.screens[i];
d342 9
a350 2
	for (p = __glXProviderStack; p != NULL; p = p->next) {
	    __GLXscreen *glxScreen;
d352 7
a358 17
	    glxScreen = p->screenProbe(pScreen);
	    if (glxScreen != NULL) {
	        if (glxScreen->GLXminor < glxMinorVersion)
		    glxMinorVersion = glxScreen->GLXminor;
		LogMessage(X_INFO,
			   "GLX: Initialized %s GL provider for screen %d\n",
			   p->name, i);
		break;
	    }

	}

	if (!p)
	    LogMessage(X_INFO,
		       "GLX: no usable GL providers found for screen %d\n", i);
	else
	    glx_provided = True;
d363 1
a363 1
	return;
d366 2
a367 2
    ** Add extension to server extensions.
    */
d369 2
a370 3
			    __GLX_NUMBER_ERRORS, __glXDispatch,
			    __glXDispatch, ResetExtension,
			    StandardMinorOpcode);
d372 2
a373 2
	FatalError("__glXExtensionInit: AddExtensions failed\n");
	return;
d376 2
a377 2
	ErrorF("__glXExtensionInit: AddExtensionAlias failed\n");
	return;
d386 2
a387 1
void __glXFlushContextCache(void)
d398 2
a399 2
__GLXcontext *__glXForceCurrent(__GLXclientState *cl, GLXContextTag tag,
				int *error)
d404 3
a406 3
    ** See if the context tag is legal; it is managed by the extension,
    ** so if it's invalid, we have an implementation error.
    */
d409 3
a411 3
	cl->client->errorValue = tag;
	*error = __glXError(GLXBadContextTag);
	return 0;
d415 13
a427 13
	if (cx->drawPriv == NULL) {
	    /*
	    ** The drawable has vanished.  It must be a window, because only
	    ** windows can be destroyed from under us; GLX pixmaps are
	    ** refcounted and don't go away until no one is using them.
	    */
	    *error = __glXError(GLXBadCurrentWindow);
	    return 0;
    	}
    }
    
    if (cx->wait && (*cx->wait)(cx, cl, error))
	return NULL;
d430 2
a431 2
	/* No need to re-bind */
	return cx;
d436 6
a441 6
	if (!(*cx->makeCurrent)(cx)) {
	    /* Bind failed, and set the error code.  Bummer */
	    cl->client->errorValue = cx->id;
	    *error = __glXError(GLXBadContextState);
	    return 0;
    	}
d449 2
a450 1
void glxSuspendClients(void)
d455 2
a456 2
	if (clients[i] && glxGetClient(clients[i])->inUse)
	    IgnoreClient(clients[i]);
d462 2
a463 1
void glxResumeClients(void)
d471 2
a472 2
	if (clients[i] && glxGetClient(clients[i])->inUse)
	    AttendClient(clients[i]);
d477 1
a477 1
	next = cx->next;
d479 1
a479 1
	cx->destroy(cx);
d489 1
a489 1
    
d495 2
a496 2
static void (*__glXenterServerFunc)(GLboolean) = __glXnopEnterServer;
static void (*__glXleaveServerFunc)(GLboolean)  = __glXnopLeaveServer;
d498 3
a500 2
void __glXsetEnterLeaveServerFuncs(void (*enter)(GLboolean),
				   void (*leave)(GLboolean))
d502 2
a503 2
  __glXenterServerFunc = enter;
  __glXleaveServerFunc = leave;
d506 2
a507 2

void __glXenterServer(GLboolean rendering)
d509 1
a509 1
  glxServerLeaveCount--;
d511 2
a512 2
  if (glxServerLeaveCount == 0)
    (*__glXenterServerFunc)(rendering);
d515 2
a516 1
void __glXleaveServer(GLboolean rendering)
d518 2
a519 2
  if (glxServerLeaveCount == 0)
    (*__glXleaveServerFunc)(rendering);
d521 1
a521 1
  glxServerLeaveCount++;
d527 2
a528 1
static int __glXDispatch(ClientPtr client)
d542 2
a543 2
    ** If we're expecting a glXRenderLarge request, this better be one.
    */
d545 2
a546 2
	client->errorValue = stuff->glxCode;
	return __glXError(GLXBadLargeRequest);
d552 4
a555 4
	ResetCurrentRequest(client);
	client->sequence--;
	IgnoreClient(client);
	return Success;
d559 3
a561 3
    ** Use the opcode to index into the procedure table.
    */
    proc = __glXGetProtocolDecodeFunction(& Single_dispatch_info, opcode,
d564 3
a566 2
	GLboolean rendering = opcode <= X_GLXRenderLarge;
	__glXleaveServer(rendering);
d568 1
a568 1
	retval = (*proc)(cl, (GLbyte *) stuff);
d570 1
a570 1
	__glXenterServer(rendering);
d573 1
a573 1
	retval = BadRequest;
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a41 1
#include "g_disptab.h"
a52 1
__GLXcontext *__glXContextList;
a58 1
RESTYPE __glXSwapBarrierRes;
a68 5
** Client that called into GLX dispatch.
*/
ClientPtr __pGlxClient;

/*
d121 9
a129 9
    /* If this drawable was created using glx 1.3 drawable
     * constructors, we added it as a glx drawable resource under both
     * its glx drawable ID and it X drawable ID.  Remove the other
     * resource now so we don't a callback for freed memory. */
    if (glxPriv->drawId != glxPriv->pDraw->id) {
	if (xid == glxPriv->drawId)
	    FreeResourceByType(glxPriv->pDraw->id, __glXDrawableRes, TRUE);
	else
	    FreeResourceByType(glxPriv->drawId, __glXDrawableRes, TRUE);
a134 2
	    int i;

a138 15

	    for (i = 1; i < currentMaxClients; i++) {
		if (clients[i]) {
		    __GLXclientState *cl = glxGetClient(clients[i]);

		    if (cl->inUse) {
			int j;

			for (j = 0; j < cl->numCurrentContexts; j++) {
			    if (cl->currentContexts[j] == c)
				cl->currentContexts[j] = NULL;
			}
		    }
		}
	    }
a143 2
	if (!c->idExists && !c->isCurrent)
	    __glXFreeContext(c);
d146 4
a207 13
extern RESTYPE __glXSwapBarrierRes;

static int SwapBarrierGone(int screen, XID drawable)
{
    __GLXscreen *pGlxScreen = glxGetScreen(screenInfo.screens[screen]);

    if (pGlxScreen->swapBarrierFuncs) {
        pGlxScreen->swapBarrierFuncs->bindSwapBarrierFunc(screen, drawable, 0);
    }
    FreeResourceByType(drawable, __glXSwapBarrierRes, FALSE);
    return True;
}

a264 2
    __GLXcontext	*cx;
    int i;
a277 9
	for (i = 0; i < cl->numCurrentContexts; i++) {
	    cx = cl->currentContexts[i];
	    if (cx) {
		cx->isCurrent = GL_FALSE;
		if (!cx->idExists)
		    __glXFreeContext(cx);
	    }
	}

a279 1
	free(cl->currentContexts);
d313 1
a313 3
    __glXSwapBarrierRes = CreateNewResourceType((DeleteType)SwapBarrierGone,
						"GLXSwapBarrier");
    if (!__glXContextRes || !__glXDrawableRes || !__glXSwapBarrierRes)
d392 1
a392 1
    cx = (__GLXcontext *) __glXLookupContextByTag(cl, tag);
d421 1
a421 1
	if (!(*cx->forceCurrent)(cx)) {
d541 2
a542 3
    proc = (__GLXdispatchSingleProcPtr) __glXGetProtocolDecodeFunction(& Single_dispatch_info,
								       opcode,
								       client->swapped);
a545 2

	__pGlxClient = client;
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d68 2
a69 2
static int glxClientPrivateKeyIndex;
static DevPrivateKey glxClientPrivateKey = &glxClientPrivateKeyIndex;
d127 1
a127 1
    __GLXcontext *c;
d140 2
a141 1
    for (c = glxAllContexts; c; c = c->next) {
a163 4

	    if (!c->idExists) {
		__glXFreeContext(c);
	    }
d169 2
d207 2
a208 2
    if (cx->feedbackBuf) xfree(cx->feedbackBuf);
    if (cx->selectBuf) xfree(cx->selectBuf);
d325 4
a328 4
	if (cl->returnBuf) xfree(cl->returnBuf);
	if (cl->largeCmdBuf) xfree(cl->largeCmdBuf);
	if (cl->currentContexts) xfree(cl->currentContexts);
	if (cl->GLClientextensions) xfree(cl->GLClientextensions);
d366 1
a366 1
    if (!dixRequestPrivate(glxClientPrivateKey, sizeof (__GLXclientState)))
d585 1
a585 1
	return(client->noClientException);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a30 1
#define NEED_REPLIES
d39 1
d129 11
d185 1
a185 1
void __glXRemoveFromContextList(__GLXcontext *cx)
d187 1
a187 1
    __GLXcontext *c, **prev;
d189 10
a198 4
    prev = &glxAllContexts;
    for (c = glxAllContexts; c; c = c->next)
	if (c == cx)
	    *prev = c->next;
d281 1
d358 8
a365 3
    __glXContextRes = CreateNewResourceType((DeleteType)ContextGone);
    __glXDrawableRes = CreateNewResourceType((DeleteType)DrawableGone);
    __glXSwapBarrierRes = CreateNewResourceType((DeleteType)SwapBarrierGone);
d376 6
a381 1
	    if (p->screenProbe(pScreen) != NULL) {
d387 1
d418 1
d462 3
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d2 28
a29 18
** The contents of this file are subject to the GLX Public License Version 1.0
** (the "License"). You may not use this file except in compliance with the
** License. You may obtain a copy of the License at Silicon Graphics, Inc.,
** attn: Legal Services, 2011 N. Shoreline Blvd., Mountain View, CA 94043
** or at http://www.sgi.com/software/opensource/glx/license.html.
**
** Software distributed under the License is distributed on an "AS IS"
** basis. ALL WARRANTIES ARE DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY
** IMPLIED WARRANTIES OF MERCHANTABILITY, OF FITNESS FOR A PARTICULAR
** PURPOSE OR OF NON- INFRINGEMENT. See the License for the specific
** language governing rights and limitations under the License.
**
** The Original Software is GLX version 1.2 source code, released February,
** 1999. The developer of the Original Software is Silicon Graphics, Inc.
** Those portions of the Subject Software created by Silicon Graphics, Inc.
** are Copyright (c) 1991-9 Silicon Graphics, Inc. All Rights Reserved.
**
*/
d54 1
d68 2
a69 1
static DevPrivateKey glxClientPrivateKey = &glxClientPrivateKey;
d116 5
d127 1
a127 1
    ScreenPtr pScreen = glxPriv->pDraw->pScreen;
d129 32
a160 5
    switch (glxPriv->type) {
	case GLX_DRAWABLE_PIXMAP:
	case GLX_DRAWABLE_PBUFFER:
	    (*pScreen->DestroyPixmap)((PixmapPtr) glxPriv->pDraw);
	    break;
d163 1
a163 3
    glxPriv->pDraw = NULL;
    glxPriv->drawId = 0;
    __glXUnrefDrawable(glxPriv);
d168 15
a182 3
static __GLXcontext *glxPendingDestroyContexts;
static int glxServerLeaveCount;
static int glxBlockClients;
d196 2
@

