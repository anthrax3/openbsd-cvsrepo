head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.6
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	vcnjRBuLQw44cPHf;

1.8
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.14;	author matthieu;	state Exp;
branches;
next	;

1.7.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.8.2.1
date	2014.12.09.17.59.32;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include "glxserver.h"
#include "glxutil.h"
#include "glxext.h"
#include "indirect_dispatch.h"
#include "unpack.h"

int
__glXDisp_FeedbackBuffer(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    GLsizei size;
    GLenum type;
    __GLXcontext *cx;
    int error;

    REQUEST_FIXED_SIZE(xGLXSingleReq, 8);

    cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
    if (!cx) {
        return error;
    }

    pc += __GLX_SINGLE_HDR_SIZE;
    size = *(GLsizei *) (pc + 0);
    type = *(GLenum *) (pc + 4);
    if (cx->feedbackBufSize < size) {
        cx->feedbackBuf = reallocarray(cx->feedbackBuf,
                                       (size_t) size, __GLX_SIZE_FLOAT32);
        if (!cx->feedbackBuf) {
            cl->client->errorValue = size;
            return BadAlloc;
        }
        cx->feedbackBufSize = size;
    }
    glFeedbackBuffer(size, type, cx->feedbackBuf);
    cx->hasUnflushedCommands = GL_TRUE;
    return Success;
}

int
__glXDisp_SelectBuffer(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    __GLXcontext *cx;
    GLsizei size;
    int error;

    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

    cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
    if (!cx) {
        return error;
    }

    pc += __GLX_SINGLE_HDR_SIZE;
    size = *(GLsizei *) (pc + 0);
    if (cx->selectBufSize < size) {
        cx->selectBuf = reallocarray(cx->selectBuf,
                                     (size_t) size, __GLX_SIZE_CARD32);
        if (!cx->selectBuf) {
            cl->client->errorValue = size;
            return BadAlloc;
        }
        cx->selectBufSize = size;
    }
    glSelectBuffer(size, cx->selectBuf);
    cx->hasUnflushedCommands = GL_TRUE;
    return Success;
}

int
__glXDisp_RenderMode(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXRenderModeReply reply;
    __GLXcontext *cx;
    GLint nitems = 0, retBytes = 0, retval, newModeCheck;
    GLubyte *retBuffer = NULL;
    GLenum newMode;
    int error;

    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

    cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
    if (!cx) {
        return error;
    }

    pc += __GLX_SINGLE_HDR_SIZE;
    newMode = *(GLenum *) pc;
    retval = glRenderMode(newMode);

    /* Check that render mode worked */
    glGetIntegerv(GL_RENDER_MODE, &newModeCheck);
    if (newModeCheck != newMode) {
        /* Render mode change failed.  Bail */
        newMode = newModeCheck;
        goto noChangeAllowed;
    }

    /*
     ** Render mode might have still failed if we get here.  But in this
     ** case we can't really tell, nor does it matter.  If it did fail, it
     ** will return 0, and thus we won't send any data across the wire.
     */

    switch (cx->renderMode) {
    case GL_RENDER:
        cx->renderMode = newMode;
        break;
    case GL_FEEDBACK:
        if (retval < 0) {
            /* Overflow happened. Copy the entire buffer */
            nitems = cx->feedbackBufSize;
        }
        else {
            nitems = retval;
        }
        retBytes = nitems * __GLX_SIZE_FLOAT32;
        retBuffer = (GLubyte *) cx->feedbackBuf;
        cx->renderMode = newMode;
        break;
    case GL_SELECT:
        if (retval < 0) {
            /* Overflow happened.  Copy the entire buffer */
            nitems = cx->selectBufSize;
        }
        else {
            GLuint *bp = cx->selectBuf;
            GLint i;

            /*
             ** Figure out how many bytes of data need to be sent.  Parse
             ** the selection buffer to determine this fact as the
             ** return value is the number of hits, not the number of
             ** items in the buffer.
             */
            nitems = 0;
            i = retval;
            while (--i >= 0) {
                GLuint n;

                /* Parse select data for this hit */
                n = *bp;
                bp += 3 + n;
            }
            nitems = bp - cx->selectBuf;
        }
        retBytes = nitems * __GLX_SIZE_CARD32;
        retBuffer = (GLubyte *) cx->selectBuf;
        cx->renderMode = newMode;
        break;
    }

    /*
     ** First reply is the number of elements returned in the feedback or
     ** selection array, as per the API for glRenderMode itself.
     */
 noChangeAllowed:;
    reply = (xGLXRenderModeReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = nitems,
        .retval = retval,
        .size = nitems,
        .newMode = newMode
    };
    WriteToClient(client, sz_xGLXRenderModeReply, &reply);
    if (retBytes) {
        WriteToClient(client, retBytes, retBuffer);
    }
    return Success;
}

int
__glXDisp_Flush(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    __GLXcontext *cx;
    int error;

    REQUEST_SIZE_MATCH(xGLXSingleReq);

    cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
    if (!cx) {
        return error;
    }

    glFlush();
    cx->hasUnflushedCommands = GL_FALSE;
    return Success;
}

int
__glXDisp_Finish(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    __GLXcontext *cx;
    int error;

    REQUEST_SIZE_MATCH(xGLXSingleReq);

    cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
    if (!cx) {
        return error;
    }

    /* Do a local glFinish */
    glFinish();
    cx->hasUnflushedCommands = GL_FALSE;

    /* Send empty reply packet to indicate finish is finished */
    client = cl->client;
    __GLX_BEGIN_REPLY(0);
    __GLX_SEND_HEADER();
    return Success;
}

#define SEPARATOR " "

char *
__glXcombine_strings(const char *cext_string, const char *sext_string)
{
    size_t clen, slen;
    char *combo_string, *token, *s1;
    const char *s2, *end;

    /* safeguard to prevent potentially fatal errors in the string functions */
    if (!cext_string)
        cext_string = "";
    if (!sext_string)
        sext_string = "";

    /*
     ** String can't be longer than min(cstring, sstring)
     ** pull tokens out of shortest string
     ** include space in combo_string for final separator and null terminator
     */
    clen = strlen(cext_string);
    slen = strlen(sext_string);
    if (clen > slen) {
        combo_string = (char *) malloc(slen + 2);
        s1 = (char *) malloc(slen + 2);
        if (s1)
            strcpy(s1, sext_string);
        s2 = cext_string;
    }
    else {
        combo_string = (char *) malloc(clen + 2);
        s1 = (char *) malloc(clen + 2);
        if (s1)
            strcpy(s1, cext_string);
        s2 = sext_string;
    }
    if (!combo_string || !s1) {
        free(combo_string);
        free(s1);
        return NULL;
    }
    combo_string[0] = '\0';

    /* Get first extension token */
    token = strtok(s1, SEPARATOR);
    while (token != NULL) {

        /*
         ** if token in second string then save it
         ** beware of extension names which are prefixes of other extension names
         */
        const char *p = s2;

        end = p + strlen(p);
        while (p < end) {
            size_t n = strcspn(p, SEPARATOR);

            if ((strlen(token) == n) && (strncmp(token, p, n) == 0)) {
                combo_string = strcat(combo_string, token);
                combo_string = strcat(combo_string, SEPARATOR);
            }
            p += (n + 1);
        }

        /* Get next extension token */
        token = strtok(NULL, SEPARATOR);
    }
    free(s1);
    return combo_string;
}

int
DoGetString(__GLXclientState * cl, GLbyte * pc, GLboolean need_swap)
{
    ClientPtr client = cl->client;
    __GLXcontext *cx;
    GLenum name;
    const char *string;

    __GLX_DECLARE_SWAP_VARIABLES;
    int error;
    char *buf = NULL, *buf1 = NULL;
    GLint length = 0;

    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

    /* If the client has the opposite byte order, swap the contextTag and
     * the name.
     */
    if (need_swap) {
        __GLX_SWAP_INT(pc + 4);
        __GLX_SWAP_INT(pc + __GLX_SINGLE_HDR_SIZE);
    }

    cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
    if (!cx) {
        return error;
    }

    pc += __GLX_SINGLE_HDR_SIZE;
    name = *(GLenum *) (pc + 0);
    string = (const char *) glGetString(name);

    if (string == NULL)
        string = "";

    /*
     ** Restrict extensions to those that are supported by both the
     ** implementation and the connection.  That is, return the
     ** intersection of client, server, and core extension strings.
     */
    if (name == GL_EXTENSIONS) {
        buf1 = __glXcombine_strings(string, cl->GLClientextensions);
        buf = __glXcombine_strings(buf1, cx->pGlxScreen->GLextensions);
        free(buf1);
        string = buf;
    }
    else if (name == GL_VERSION) {
        if (atof(string) > atof(GLServerVersion)) {
            if (asprintf(&buf, "%s (%s)", GLServerVersion, string) == -1) {
                string = GLServerVersion;
            }
            else {
                string = buf;
            }
        }
    }
    if (string) {
        length = strlen((const char *) string) + 1;
    }

    __GLX_BEGIN_REPLY(length);
    __GLX_PUT_SIZE(length);

    if (need_swap) {
        __GLX_SWAP_REPLY_SIZE();
        __GLX_SWAP_REPLY_HEADER();
    }

    __GLX_SEND_HEADER();
    WriteToClient(client, length, string);
    free(buf);

    return Success;
}

int
__glXDisp_GetString(__GLXclientState * cl, GLbyte * pc)
{
    return DoGetString(cl, pc, GL_FALSE);
}
@


1.9
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d65 2
a66 3
        cx->feedbackBuf = (GLfloat *) realloc(cx->feedbackBuf,
                                              (size_t) size
                                              * __GLX_SIZE_FLOAT32);
d96 2
a97 2
        cx->selectBuf = (GLuint *) realloc(cx->selectBuf,
                                           (size_t) size * __GLX_SIZE_CARD32);
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d48 1
d54 2
d82 1
d87 2
d113 1
a113 1
    ClientPtr client;
d121 2
a198 1
    client = cl->client;
d217 1
d221 2
d236 1
a237 1
    ClientPtr client;
d240 2
d332 1
a332 1
    ClientPtr client;
d342 2
a359 1
    client = cl->client;
@


1.8.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a47 1
    ClientPtr client = cl->client;
a52 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 8);

a78 1
    ClientPtr client = cl->client;
a82 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

d107 1
a107 1
    ClientPtr client = cl->client;
a114 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

d191 1
a209 1
    ClientPtr client = cl->client;
a212 2
    REQUEST_SIZE_MATCH(xGLXSingleReq);

a225 1
    ClientPtr client = cl->client;
d227 1
a229 2
    REQUEST_SIZE_MATCH(xGLXSingleReq);

d320 1
a320 1
    ClientPtr client = cl->client;
a329 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

d346 1
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a43 4
#include "glapitable.h"
#include "glapi.h"
#include "glthread.h"
#include "dispatch.h"
d71 1
a71 1
    CALL_FeedbackBuffer(GET_DISPATCH(), (size, type, cx->feedbackBuf));
d99 1
a99 1
    CALL_SelectBuffer(GET_DISPATCH(), (size, cx->selectBuf));
d122 1
a122 1
    retval = CALL_RenderMode(GET_DISPATCH(), (newMode));
d125 1
a125 1
    CALL_GetIntegerv(GET_DISPATCH(), (GL_RENDER_MODE, &newModeCheck));
d218 1
a218 1
    CALL_Flush(GET_DISPATCH(), ());
d236 1
a236 1
    CALL_Finish(GET_DISPATCH(), ());
d345 1
a345 1
    string = (const char *) CALL_GetString(GET_DISPATCH(), (name));
@


1.7.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a51 1
    ClientPtr client = cl->client;
a56 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 8);

a82 1
    ClientPtr client = cl->client;
a86 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

d111 1
a111 1
    ClientPtr client = cl->client;
a118 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

d195 1
a213 1
    ClientPtr client = cl->client;
a216 2
    REQUEST_SIZE_MATCH(xGLXSingleReq);

a229 1
    ClientPtr client = cl->client;
d231 1
a233 2
    REQUEST_SIZE_MATCH(xGLXSingleReq);

d324 1
a324 1
    ClientPtr client = cl->client;
a333 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

d350 1
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d196 9
a204 7
    reply.length = nitems;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.retval = retval;
    reply.size = nitems;
    reply.newMode = newMode;
    WriteToClient(client, sz_xGLXRenderModeReply, (char *) &reply);
d206 1
a206 1
        WriteToClient(client, retBytes, (char *) retBuffer);
d389 1
a389 1
    WriteToClient(client, length, (char *) string);
@


1.5
log
@Update to xserver 1.11.2
@
text
@d49 2
a50 1
int __glXDisp_FeedbackBuffer(__GLXclientState *cl, GLbyte *pc)
d59 1
a59 1
	return error;
d63 2
a64 2
    size = *(GLsizei *)(pc+0);
    type = *(GLenum *)(pc+4);
d66 8
a73 8
	cx->feedbackBuf = (GLfloat *) realloc(cx->feedbackBuf,
						   (size_t)size 
						   * __GLX_SIZE_FLOAT32);
	if (!cx->feedbackBuf) {
	    cl->client->errorValue = size;
	    return BadAlloc;
	}
	cx->feedbackBufSize = size;
d75 1
a75 1
    CALL_FeedbackBuffer( GET_DISPATCH(), (size, type, cx->feedbackBuf) );
d80 2
a81 1
int __glXDisp_SelectBuffer(__GLXclientState *cl, GLbyte *pc)
d89 1
a89 1
	return error;
d93 1
a93 1
    size = *(GLsizei *)(pc+0);
d95 7
a101 8
	cx->selectBuf = (GLuint *) realloc(cx->selectBuf,
						(size_t) size 
						* __GLX_SIZE_CARD32);
	if (!cx->selectBuf) {
	    cl->client->errorValue = size;
	    return BadAlloc;
	}
	cx->selectBufSize = size;
d103 1
a103 1
    CALL_SelectBuffer( GET_DISPATCH(), (size, cx->selectBuf) );
d108 2
a109 1
int __glXDisp_RenderMode(__GLXclientState *cl, GLbyte *pc)
d114 1
a114 1
    GLint nitems=0, retBytes=0, retval, newModeCheck;
d121 1
a121 1
	return error;
d125 2
a126 2
    newMode = *(GLenum*) pc;
    retval = CALL_RenderMode( GET_DISPATCH(), (newMode) );
d129 1
a129 1
    CALL_GetIntegerv( GET_DISPATCH(), (GL_RENDER_MODE, &newModeCheck) );
d131 3
a133 3
	/* Render mode change failed.  Bail */
	newMode = newModeCheck;
	goto noChangeAllowed;
d137 4
a140 4
    ** Render mode might have still failed if we get here.  But in this
    ** case we can't really tell, nor does it matter.  If it did fail, it
    ** will return 0, and thus we won't send any data across the wire.
    */
d143 45
a187 43
      case GL_RENDER:
	cx->renderMode = newMode;
	break;
      case GL_FEEDBACK:
	if (retval < 0) {
	    /* Overflow happened. Copy the entire buffer */
	    nitems = cx->feedbackBufSize;
	} else {
	    nitems = retval;
	}
	retBytes = nitems * __GLX_SIZE_FLOAT32;
	retBuffer = (GLubyte*) cx->feedbackBuf;
	cx->renderMode = newMode;
	break;
      case GL_SELECT:
	if (retval < 0) {
	    /* Overflow happened.  Copy the entire buffer */
	    nitems = cx->selectBufSize;
	} else {
	    GLuint *bp = cx->selectBuf;
	    GLint i;

	    /*
	    ** Figure out how many bytes of data need to be sent.  Parse
	    ** the selection buffer to determine this fact as the
	    ** return value is the number of hits, not the number of
	    ** items in the buffer.
	    */
	    nitems = 0;
	    i = retval;
	    while (--i >= 0) {
		GLuint n;

		/* Parse select data for this hit */
		n = *bp;
		bp += 3 + n;
	    }
	    nitems = bp - cx->selectBuf;
	}
	retBytes = nitems * __GLX_SIZE_CARD32;
	retBuffer = (GLubyte*) cx->selectBuf;
	cx->renderMode = newMode;
	break;
d191 4
a194 4
    ** First reply is the number of elements returned in the feedback or
    ** selection array, as per the API for glRenderMode itself.
    */
  noChangeAllowed:;
d202 1
a202 1
    WriteToClient(client, sz_xGLXRenderModeReply, (char *)&reply);
d204 1
a204 1
	WriteToClient(client, retBytes, (char *)retBuffer);
d209 2
a210 1
int __glXDisp_Flush(__GLXclientState *cl, GLbyte *pc)
d212 2
a213 2
	__GLXcontext *cx;
	int error;
d215 8
a222 8
	cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
	if (!cx) {
		return error;
	}

	CALL_Flush( GET_DISPATCH(), () );
	cx->hasUnflushedCommands = GL_FALSE;
	return Success;
d225 2
a226 1
int __glXDisp_Finish(__GLXclientState *cl, GLbyte *pc)
d234 1
a234 1
	return error;
d238 1
a238 1
    CALL_Finish( GET_DISPATCH(), () );
d250 2
a251 1
char *__glXcombine_strings(const char *cext_string, const char *sext_string)
d253 64
a316 59
   size_t clen, slen;
   char *combo_string, *token, *s1;
   const char *s2, *end;

   /* safeguard to prevent potentially fatal errors in the string functions */
   if (!cext_string)
      cext_string = "";
   if (!sext_string)
      sext_string = "";

   /*
   ** String can't be longer than min(cstring, sstring)
   ** pull tokens out of shortest string
   ** include space in combo_string for final separator and null terminator
   */
   clen = strlen(cext_string);
   slen = strlen(sext_string);
   if (clen > slen) {
	combo_string = (char *) malloc(slen + 2);
	s1 = (char *) malloc(slen + 2);
	if (s1) strcpy(s1, sext_string);
	s2 = cext_string;
   } else {
	combo_string = (char *) malloc(clen + 2);
	s1 = (char *) malloc(clen + 2);
	if (s1) strcpy(s1, cext_string);
	s2 = sext_string;
   }
   if (!combo_string || !s1) {
	free(combo_string);
	free(s1);
	return NULL;
   }
   combo_string[0] = '\0';

   /* Get first extension token */
   token = strtok( s1, SEPARATOR);
   while ( token != NULL ) {

	/*
	** if token in second string then save it
	** beware of extension names which are prefixes of other extension names
	*/
	const char *p = s2;
	end = p + strlen(p);
	while (p < end) {
	    size_t n = strcspn(p, SEPARATOR);
	    if ((strlen(token) == n) && (strncmp(token, p, n) == 0)) {
		combo_string = strcat(combo_string, token);
		combo_string = strcat(combo_string, SEPARATOR);
	    }
	    p += (n + 1);
	}

	/* Get next extension token */
	token = strtok( NULL, SEPARATOR);
   }
   free(s1);
   return combo_string;
d319 2
a320 1
int DoGetString(__GLXclientState *cl, GLbyte *pc, GLboolean need_swap)
d326 1
d335 3
a337 3
    if ( need_swap ) {
	__GLX_SWAP_INT(pc + 4);
	__GLX_SWAP_INT(pc + __GLX_SINGLE_HDR_SIZE);
d342 1
a342 1
	return error;
d346 2
a347 2
    name = *(GLenum *)(pc + 0);
    string = (const char *) CALL_GetString( GET_DISPATCH(), (name) );
d351 1
a351 1
      string = "";
d354 4
a357 4
    ** Restrict extensions to those that are supported by both the
    ** implementation and the connection.  That is, return the
    ** intersection of client, server, and core extension strings.
    */
d359 14
a372 19
	buf1 = __glXcombine_strings(string,
				      cl->GLClientextensions);
	buf = __glXcombine_strings(buf1,
				      cx->pGlxScreen->GLextensions);
	free(buf1);
	string = buf;
    }
    else if ( name == GL_VERSION ) {
	if ( atof( string ) > atof( GLServerVersion ) ) {
	    size_t len =  strlen( string ) + strlen( GLServerVersion ) + 4;
	    buf = malloc( len );
	    if ( buf == NULL ) {
		string = GLServerVersion;
	    }
	    else {
		snprintf( buf, len, "%s (%s)", GLServerVersion, string );
		string = buf;
	    }
	}
d375 1
a375 1
	length = strlen((const char *) string) + 1;
d381 3
a383 3
    if ( need_swap ) {
	__GLX_SWAP_REPLY_SIZE();
	__GLX_SWAP_REPLY_HEADER();
d387 1
a387 1
    WriteToClient(client, length, (char *) string); 
d393 2
a394 1
int __glXDisp_GetString(__GLXclientState *cl, GLbyte *pc)
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d75 1
a75 1
    __GLX_NOTE_UNFLUSHED_CMDS(cx);
d103 1
a103 1
    __GLX_NOTE_UNFLUSHED_CMDS(cx);
d216 1
a216 1
	__GLX_NOTE_FLUSHED_CMDS(cx);
d233 1
a233 1
    __GLX_NOTE_FLUSHED_CMDS(cx);
d349 1
a349 3
	if (buf1 != NULL) {
	    free(buf1);
	}
d379 1
a379 2
    if (buf != NULL)
	free(buf);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d65 1
a65 1
	cx->feedbackBuf = (GLfloat *) xrealloc(cx->feedbackBuf,
d93 1
a93 1
	cx->selectBuf = (GLuint *) xrealloc(cx->selectBuf,
d264 2
a265 2
	combo_string = (char *) xalloc(slen + 2);
	s1 = (char *) xalloc(slen + 2);
d269 2
a270 2
	combo_string = (char *) xalloc(clen + 2);
	s1 = (char *) xalloc(clen + 2);
d275 2
a276 4
	if (combo_string)
	    xfree(combo_string);
	if (s1)
	    xfree(s1);
d303 1
a303 1
   xfree(s1);
d350 1
a350 1
	    xfree(buf1);
d357 1
a357 1
	    buf = xalloc( len );
d382 1
a382 1
	xfree(buf);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a30 1
#define NEED_REPLIES
d337 3
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d2 28
a29 33
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: The application programming interfaces
** established by SGI in conjunction with the Original Code are The
** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
** Window System(R) (Version 1.3), released October 19, 1998. This software
** was created using the OpenGL(R) version 1.2.1 Sample Implementation
** published by SGI, but has not been independently verified as being
** compliant with the OpenGL(R) version 1.2.1 Specification.
**
*/
d356 2
a357 1
	    buf = xalloc( strlen( string ) + strlen( GLServerVersion ) + 4 );
d362 1
a362 1
		sprintf( buf, "%s (%s)", GLServerVersion, string );
@

