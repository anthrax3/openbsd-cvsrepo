head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.10
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <GL/glxtokens.h>
#include <string.h>
#include <windowstr.h>
#include <os.h>
#include <colormapst.h>

#include "privates.h"
#include "glxserver.h"
#include "glxutil.h"
#include "glxext.h"
#include "protocol-versions.h"

static DevPrivateKeyRec glxScreenPrivateKeyRec;

#define glxScreenPrivateKey (&glxScreenPrivateKeyRec)

const char GLServerVersion[] = "1.4";
static const char GLServerExtensions[] =
    "GL_ARB_depth_texture "
    "GL_ARB_draw_buffers "
    "GL_ARB_fragment_program "
    "GL_ARB_fragment_program_shadow "
    "GL_ARB_imaging "
    "GL_ARB_multisample "
    "GL_ARB_multitexture "
    "GL_ARB_occlusion_query "
    "GL_ARB_point_parameters "
    "GL_ARB_point_sprite "
    "GL_ARB_shadow "
    "GL_ARB_shadow_ambient "
    "GL_ARB_texture_border_clamp "
    "GL_ARB_texture_compression "
    "GL_ARB_texture_cube_map "
    "GL_ARB_texture_env_add "
    "GL_ARB_texture_env_combine "
    "GL_ARB_texture_env_crossbar "
    "GL_ARB_texture_env_dot3 "
    "GL_ARB_texture_mirrored_repeat "
    "GL_ARB_texture_non_power_of_two "
    "GL_ARB_transpose_matrix "
    "GL_ARB_vertex_program "
    "GL_ARB_window_pos "
    "GL_EXT_abgr "
    "GL_EXT_bgra "
    "GL_EXT_blend_color "
    "GL_EXT_blend_equation_separate "
    "GL_EXT_blend_func_separate "
    "GL_EXT_blend_logic_op "
    "GL_EXT_blend_minmax "
    "GL_EXT_blend_subtract "
    "GL_EXT_clip_volume_hint "
    "GL_EXT_copy_texture "
    "GL_EXT_draw_range_elements "
    "GL_EXT_fog_coord "
    "GL_EXT_framebuffer_object "
    "GL_EXT_multi_draw_arrays "
    "GL_EXT_packed_pixels "
    "GL_EXT_paletted_texture "
    "GL_EXT_point_parameters "
    "GL_EXT_polygon_offset "
    "GL_EXT_rescale_normal "
    "GL_EXT_secondary_color "
    "GL_EXT_separate_specular_color "
    "GL_EXT_shadow_funcs "
    "GL_EXT_shared_texture_palette "
    "GL_EXT_stencil_two_side "
    "GL_EXT_stencil_wrap "
    "GL_EXT_subtexture "
    "GL_EXT_texture "
    "GL_EXT_texture3D "
    "GL_EXT_texture_compression_dxt1 "
    "GL_EXT_texture_compression_s3tc "
    "GL_EXT_texture_edge_clamp "
    "GL_EXT_texture_env_add "
    "GL_EXT_texture_env_combine "
    "GL_EXT_texture_env_dot3 "
    "GL_EXT_texture_filter_anisotropic "
    "GL_EXT_texture_lod "
    "GL_EXT_texture_lod_bias "
    "GL_EXT_texture_mirror_clamp "
    "GL_EXT_texture_object "
    "GL_EXT_texture_rectangle "
    "GL_EXT_vertex_array "
    "GL_3DFX_texture_compression_FXT1 "
    "GL_APPLE_packed_pixels "
    "GL_ATI_draw_buffers "
    "GL_ATI_texture_env_combine3 "
    "GL_ATI_texture_mirror_once "
    "GL_HP_occlusion_test "
    "GL_IBM_texture_mirrored_repeat "
    "GL_INGR_blend_func_separate "
    "GL_MESA_pack_invert "
    "GL_MESA_ycbcr_texture "
    "GL_NV_blend_square "
    "GL_NV_depth_clamp "
    "GL_NV_fog_distance "
    "GL_NV_fragment_program_option "
    "GL_NV_fragment_program2 "
    "GL_NV_light_max_exponent "
    "GL_NV_multisample_filter_hint "
    "GL_NV_point_sprite "
    "GL_NV_texgen_reflection "
    "GL_NV_texture_compression_vtc "
    "GL_NV_texture_env_combine4 "
    "GL_NV_texture_expand_normal "
    "GL_NV_texture_rectangle "
    "GL_NV_vertex_program2_option "
    "GL_NV_vertex_program3 "
    "GL_OES_compressed_paletted_texture "
    "GL_SGI_color_matrix "
    "GL_SGI_color_table "
    "GL_SGIS_generate_mipmap "
    "GL_SGIS_multisample "
    "GL_SGIS_point_parameters "
    "GL_SGIS_texture_border_clamp "
    "GL_SGIS_texture_edge_clamp "
    "GL_SGIS_texture_lod "
    "GL_SGIX_depth_texture "
    "GL_SGIX_shadow "
    "GL_SGIX_shadow_ambient "
    "GL_SUN_slice_accum ";

/*
** We have made the simplifying assuption that the same extensions are
** supported across all screens in a multi-screen system.
*/
unsigned glxMajorVersion = SERVER_GLX_MAJOR_VERSION;
unsigned glxMinorVersion = SERVER_GLX_MINOR_VERSION;
static char GLXServerExtensions[] =
    "GLX_ARB_multisample "
    "GLX_EXT_visual_info "
    "GLX_EXT_visual_rating "
    "GLX_EXT_import_context "
    "GLX_EXT_texture_from_pixmap "
    "GLX_OML_swap_method "
    "GLX_SGI_make_current_read "
#ifndef __APPLE__
    "GLX_SGIS_multisample "
#endif
    "GLX_SGIX_fbconfig "
    "GLX_SGIX_pbuffer "
    "GLX_MESA_copy_sub_buffer ";

static Bool
glxCloseScreen(ScreenPtr pScreen)
{
    __GLXscreen *pGlxScreen = glxGetScreen(pScreen);

    pScreen->CloseScreen = pGlxScreen->CloseScreen;

    pGlxScreen->destroy(pGlxScreen);

    return pScreen->CloseScreen(pScreen);
}

__GLXscreen *
glxGetScreen(ScreenPtr pScreen)
{
    return dixLookupPrivate(&pScreen->devPrivates, glxScreenPrivateKey);
}

_X_EXPORT void
GlxSetVisualConfigs(int nconfigs, void *configs, void **privates)
{
    /* We keep this stub around for the DDX drivers that still
     * call it. */
}

GLint
glxConvertToXVisualType(int visualType)
{
    static const int x_visual_types[] = {
        TrueColor, DirectColor,
        PseudoColor, StaticColor,
        GrayScale, StaticGray
    };

    return ((unsigned) (visualType - GLX_TRUE_COLOR) < 6)
        ? x_visual_types[visualType - GLX_TRUE_COLOR] : -1;
}

/* This code inspired by composite/compinit.c.  We could move this to
 * mi/ and share it with composite.*/

static VisualPtr
AddScreenVisuals(ScreenPtr pScreen, int count, int d)
{
    int i;
    DepthPtr depth;

    depth = NULL;
    for (i = 0; i < pScreen->numDepths; i++) {
        if (pScreen->allowedDepths[i].depth == d) {
            depth = &pScreen->allowedDepths[i];
            break;
        }
    }
    if (depth == NULL)
        return NULL;

    if (ResizeVisualArray(pScreen, count, depth) == FALSE)
        return NULL;

    /* Return a pointer to the first of the added visuals. */
    return pScreen->visuals + pScreen->numVisuals - count;
}

static int
findFirstSet(unsigned int v)
{
    int i;

    for (i = 0; i < 32; i++)
        if (v & (1 << i))
            return i;

    return -1;
}

static void
initGlxVisual(VisualPtr visual, __GLXconfig * config)
{
    int maxBits;

    maxBits = max(config->redBits, max(config->greenBits, config->blueBits));

    config->visualID = visual->vid;
    visual->class = glxConvertToXVisualType(config->visualType);
    visual->bitsPerRGBValue = maxBits;
    visual->ColormapEntries = 1 << maxBits;
    visual->nplanes = config->redBits + config->greenBits + config->blueBits;

    visual->redMask = config->redMask;
    visual->greenMask = config->greenMask;
    visual->blueMask = config->blueMask;
    visual->offsetRed = findFirstSet(config->redMask);
    visual->offsetGreen = findFirstSet(config->greenMask);
    visual->offsetBlue = findFirstSet(config->blueMask);
}

static __GLXconfig *
pickFBConfig(__GLXscreen * pGlxScreen, VisualPtr visual)
{
    __GLXconfig *best = NULL, *config;
    int best_score = 0;

    for (config = pGlxScreen->fbconfigs; config != NULL; config = config->next) {
        int score = 0;

        if (config->redMask != visual->redMask ||
            config->greenMask != visual->greenMask ||
            config->blueMask != visual->blueMask)
            continue;
        if (config->visualRating != GLX_NONE)
            continue;
        /* Ignore multisampled configs */
        if (config->sampleBuffers)
            continue;
        if (glxConvertToXVisualType(config->visualType) != visual->class)
            continue;
        /* If it's the 32-bit RGBA visual, demand a 32-bit fbconfig. */
        if (visual->nplanes == 32 && config->rgbBits != 32)
            continue;
        /* Can't use the same FBconfig for multiple X visuals.  I think. */
        if (config->visualID != 0)
            continue;

        if (config->doubleBufferMode > 0)
            score += 8;
        if (config->depthBits > 0)
            score += 4;
        if (config->stencilBits > 0)
            score += 2;
        if (config->alphaBits > 0)
            score++;

        if (score > best_score) {
            best = config;
            best_score = score;
        }
    }

    return best;
}

void
__glXScreenInit(__GLXscreen * pGlxScreen, ScreenPtr pScreen)
{
    __GLXconfig *m;
    __GLXconfig *config;
    int i;

    if (!dixRegisterPrivateKey(&glxScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
        return;

    pGlxScreen->pScreen = pScreen;
    pGlxScreen->GLextensions = strdup(GLServerExtensions);
    pGlxScreen->GLXextensions = strdup(GLXServerExtensions);

    /* All GLX providers must support all of the functionality required for at
     * least GLX 1.2.  If the provider supports a higher version, the GLXminor
     * version can be changed in the provider's screen-probe routine.  For
     * most providers, the screen-probe routine is the caller of this
     * function.
     */
    pGlxScreen->GLXmajor = 1;
    pGlxScreen->GLXminor = 2;

    pGlxScreen->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = glxCloseScreen;

    i = 0;
    for (m = pGlxScreen->fbconfigs; m != NULL; m = m->next) {
        m->fbconfigID = FakeClientID(0);
        m->visualID = 0;
        i++;
    }
    pGlxScreen->numFBConfigs = i;

    pGlxScreen->visuals =
        calloc(pGlxScreen->numFBConfigs, sizeof(__GLXconfig *));

    /* First, try to choose featureful FBconfigs for the existing X visuals.
     * Note that if multiple X visuals end up with the same FBconfig being
     * chosen, the later X visuals don't get GLX visuals (because we want to
     * prioritize the root visual being GLX).
     */
    for (i = 0; i < pScreen->numVisuals; i++) {
        VisualPtr visual = &pScreen->visuals[i];

        config = pickFBConfig(pGlxScreen, visual);
        if (config) {
            pGlxScreen->visuals[pGlxScreen->numVisuals++] = config;
            config->visualID = visual->vid;
        }
    }

    /* Then, add new visuals corresponding to all FBconfigs that didn't have
     * an existing, appropriate visual.
     */
    for (config = pGlxScreen->fbconfigs; config != NULL; config = config->next) {
        int depth;

        VisualPtr visual;

        if (config->visualID != 0)
            continue;

        /* Only count RGB bits and not alpha, as we're not trying to create
         * visuals for compositing (that's what the 32-bit composite visual
         * set up above is for.
         */
        depth = config->redBits + config->greenBits + config->blueBits;

        /* Make sure that our FBconfig's depth can actually be displayed
         * (corresponds to an existing visual).
         */
        for (i = 0; i < pScreen->numVisuals; i++) {
            if (depth == pScreen->visuals[i].nplanes)
                break;
        }
        /* if it can't, fix up the fbconfig to not advertise window support */
        if (i == pScreen->numVisuals)
            config->drawableType &= ~(GLX_WINDOW_BIT);

        /* fbconfig must support window drawables */
        if (!(config->drawableType & GLX_WINDOW_BIT)) {
            config->visualID = 0;
            continue;
        }

        /* Create a new X visual for our FBconfig. */
        visual = AddScreenVisuals(pScreen, 1, depth);
        if (visual == NULL)
            continue;

        pGlxScreen->visuals[pGlxScreen->numVisuals++] = config;
        initGlxVisual(visual, config);
    }

    dixSetPrivate(&pScreen->devPrivates, glxScreenPrivateKey, pGlxScreen);
}

void
__glXScreenDestroy(__GLXscreen * screen)
{
    free(screen->GLXextensions);
    free(screen->GLextensions);
    free(screen->visuals);
}
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d158 1
a158 1
** We have made the simplifying assuption that the same extensions are 
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a130 1
    "GL_NV_fragment_program "
a140 3
    "GL_NV_vertex_program "
    "GL_NV_vertex_program1_1 "
    "GL_NV_vertex_program2 "
d153 3
a155 1
    "GL_SGIX_shadow " "GL_SGIX_shadow_ambient " "GL_SUN_slice_accum ";
a160 1
static char GLXServerVendorName[] = "SGI";
d169 2
a170 1
    "GLX_OML_swap_method " "GLX_SGI_make_current_read "
d175 2
a176 1
    "GLX_SGIX_pbuffer " "GLX_MESA_copy_sub_buffer ";
a331 1
    pGlxScreen->GLXvendor = strdup(GLXServerVendorName);
a420 1
    free(screen->GLXvendor);
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d177 1
a177 1
    "GLX_SGIX_pbuffer " "GLX_MESA_copy_sub_buffer " "GLX_INTEL_swap_event";
d180 1
a180 1
glxCloseScreen(int index, ScreenPtr pScreen)
d188 1
a188 1
    return pScreen->CloseScreen(index, pScreen);
d290 3
@


1.6
log
@Update to xserver 1.11.2
@
text
@d48 1
d52 106
a157 109
static const char GLServerExtensions[] = 
			"GL_ARB_depth_texture "
			"GL_ARB_draw_buffers "
			"GL_ARB_fragment_program "
			"GL_ARB_fragment_program_shadow "
			"GL_ARB_imaging "
			"GL_ARB_multisample "
			"GL_ARB_multitexture "
			"GL_ARB_occlusion_query "
			"GL_ARB_point_parameters "
			"GL_ARB_point_sprite "
			"GL_ARB_shadow "
			"GL_ARB_shadow_ambient "
			"GL_ARB_texture_border_clamp "
			"GL_ARB_texture_compression "
			"GL_ARB_texture_cube_map "
			"GL_ARB_texture_env_add "
			"GL_ARB_texture_env_combine "
			"GL_ARB_texture_env_crossbar "
			"GL_ARB_texture_env_dot3 "
			"GL_ARB_texture_mirrored_repeat "
			"GL_ARB_texture_non_power_of_two "
			"GL_ARB_transpose_matrix "
			"GL_ARB_vertex_program "
			"GL_ARB_window_pos "
			"GL_EXT_abgr "
			"GL_EXT_bgra "
 			"GL_EXT_blend_color "
			"GL_EXT_blend_equation_separate "
			"GL_EXT_blend_func_separate "
			"GL_EXT_blend_logic_op "
 			"GL_EXT_blend_minmax "
 			"GL_EXT_blend_subtract "
			"GL_EXT_clip_volume_hint "
			"GL_EXT_copy_texture "
			"GL_EXT_draw_range_elements "
			"GL_EXT_fog_coord "
			"GL_EXT_framebuffer_object "
			"GL_EXT_multi_draw_arrays "
			"GL_EXT_packed_pixels "
			"GL_EXT_paletted_texture "
			"GL_EXT_point_parameters "
			"GL_EXT_polygon_offset "
			"GL_EXT_rescale_normal "
			"GL_EXT_secondary_color "
			"GL_EXT_separate_specular_color "
			"GL_EXT_shadow_funcs "
			"GL_EXT_shared_texture_palette "
 			"GL_EXT_stencil_two_side "
			"GL_EXT_stencil_wrap "
			"GL_EXT_subtexture "
			"GL_EXT_texture "
			"GL_EXT_texture3D "
			"GL_EXT_texture_compression_dxt1 "
			"GL_EXT_texture_compression_s3tc "
			"GL_EXT_texture_edge_clamp "
 			"GL_EXT_texture_env_add "
 			"GL_EXT_texture_env_combine "
 			"GL_EXT_texture_env_dot3 "
 			"GL_EXT_texture_filter_anisotropic "
			"GL_EXT_texture_lod "
 			"GL_EXT_texture_lod_bias "
 			"GL_EXT_texture_mirror_clamp "
			"GL_EXT_texture_object "
			"GL_EXT_texture_rectangle "
			"GL_EXT_vertex_array "
			"GL_3DFX_texture_compression_FXT1 "
			"GL_APPLE_packed_pixels "
			"GL_ATI_draw_buffers "
			"GL_ATI_texture_env_combine3 "
			"GL_ATI_texture_mirror_once "
 			"GL_HP_occlusion_test "
			"GL_IBM_texture_mirrored_repeat "
			"GL_INGR_blend_func_separate "
			"GL_MESA_pack_invert "
			"GL_MESA_ycbcr_texture "
			"GL_NV_blend_square "
			"GL_NV_depth_clamp "
			"GL_NV_fog_distance "
			"GL_NV_fragment_program "
			"GL_NV_fragment_program_option "
			"GL_NV_fragment_program2 "
			"GL_NV_light_max_exponent "
			"GL_NV_multisample_filter_hint "
			"GL_NV_point_sprite "
			"GL_NV_texgen_reflection "
			"GL_NV_texture_compression_vtc "
			"GL_NV_texture_env_combine4 "
			"GL_NV_texture_expand_normal "
			"GL_NV_texture_rectangle "
			"GL_NV_vertex_program "
			"GL_NV_vertex_program1_1 "
			"GL_NV_vertex_program2 "
			"GL_NV_vertex_program2_option "
			"GL_NV_vertex_program3 "
			"GL_OES_compressed_paletted_texture "
			"GL_SGI_color_matrix "
			"GL_SGI_color_table "
			"GL_SGIS_generate_mipmap "
			"GL_SGIS_multisample "
			"GL_SGIS_point_parameters "
			"GL_SGIS_texture_border_clamp "
			"GL_SGIS_texture_edge_clamp "
			"GL_SGIS_texture_lod "
			"GL_SGIX_depth_texture "
			"GL_SGIX_shadow "
			"GL_SGIX_shadow_ambient "
			"GL_SUN_slice_accum "
			;
d167 6
a172 7
			"GLX_ARB_multisample "
			"GLX_EXT_visual_info "
			"GLX_EXT_visual_rating "
			"GLX_EXT_import_context "
                        "GLX_EXT_texture_from_pixmap "
			"GLX_OML_swap_method "
			"GLX_SGI_make_current_read "
d174 1
a174 1
			"GLX_SGIS_multisample "
d176 2
a177 5
			"GLX_SGIX_fbconfig "
			"GLX_SGIX_pbuffer "
			"GLX_MESA_copy_sub_buffer "
                        "GLX_INTEL_swap_event"
			;
d180 1
a180 1
glxCloseScreen (int index, ScreenPtr pScreen)
d197 2
a198 2
_X_EXPORT void GlxSetVisualConfigs(int nconfigs,
                         void *configs, void **privates)
d204 2
a205 1
GLint glxConvertToXVisualType(int visualType)
d208 3
a210 3
	TrueColor,   DirectColor,
	PseudoColor, StaticColor,
	GrayScale,   StaticGray
d213 2
a214 2
    return ( (unsigned) (visualType - GLX_TRUE_COLOR) < 6 )
	? x_visual_types[ visualType - GLX_TRUE_COLOR ] : -1;
d223 2
a224 2
    int		 i;
    DepthPtr	 depth;
d228 4
a231 4
	if (pScreen->allowedDepths[i].depth == d) {
	    depth = &pScreen->allowedDepths[i];
	    break;
	}
d234 1
a234 1
	return NULL;
d239 1
a239 1
    /* Return a pointer to the first of the added visuals. */ 
d249 2
a250 2
	if (v & (1 << i))
	    return i;
d256 1
a256 1
initGlxVisual(VisualPtr visual, __GLXconfig *config)
d259 1
d277 1
a277 1
pickFBConfig(__GLXscreen *pGlxScreen, VisualPtr visual)
d283 1
a283 1
	int score = 0;
d285 28
a312 28
	if (config->redMask != visual->redMask ||
	    config->greenMask != visual->greenMask ||
	    config->blueMask != visual->blueMask)
	    continue;
	if (config->visualRating != GLX_NONE)
	    continue;
	if (glxConvertToXVisualType(config->visualType) != visual->class)
	    continue;
	/* If it's the 32-bit RGBA visual, demand a 32-bit fbconfig. */
	if (visual->nplanes == 32 && config->rgbBits != 32)
	    continue;
	/* Can't use the same FBconfig for multiple X visuals.  I think. */
	if (config->visualID != 0)
	    continue;

	if (config->doubleBufferMode > 0)
	    score += 8;
	if (config->depthBits > 0)
	    score += 4;
	if (config->stencilBits > 0)
	    score += 2;
	if (config->alphaBits > 0)
	    score++;

	if (score > best_score) {
	    best = config;
	    best_score = score;
	}
d318 2
a319 1
void __glXScreenInit(__GLXscreen *pGlxScreen, ScreenPtr pScreen)
d326 1
a326 1
	return;
d328 3
a330 3
    pGlxScreen->pScreen       = pScreen;
    pGlxScreen->GLextensions  = strdup(GLServerExtensions);
    pGlxScreen->GLXvendor     = strdup(GLXServerVendorName);
d339 2
a340 2
    pGlxScreen->GLXmajor      = 1;
    pGlxScreen->GLXminor      = 2;
d347 3
a349 3
	m->fbconfigID = FakeClientID(0);
	m->visualID = 0;
	i++;
d354 1
a354 1
	calloc(pGlxScreen->numFBConfigs, sizeof (__GLXconfig *));
d362 1
a362 1
	VisualPtr visual = &pScreen->visuals[i];
d364 5
a368 5
	config = pickFBConfig(pGlxScreen, visual);
	if (config) {
	    pGlxScreen->visuals[pGlxScreen->numVisuals++] = config;
	    config->visualID = visual->vid;
	}
d375 1
a375 1
	int depth;
d377 1
a377 1
	VisualPtr visual;
d379 2
a380 2
	if (config->visualID != 0)
	    continue;
d382 27
a408 27
	/* Only count RGB bits and not alpha, as we're not trying to create
	 * visuals for compositing (that's what the 32-bit composite visual
	 * set up above is for.
	 */
	depth = config->redBits + config->greenBits + config->blueBits;

	/* Make sure that our FBconfig's depth can actually be displayed
	 * (corresponds to an existing visual).
	 */
	for (i = 0; i < pScreen->numVisuals; i++) {
	    if (depth == pScreen->visuals[i].nplanes)
		break;
	}
	/* if it can't, fix up the fbconfig to not advertise window support */
	if (i == pScreen->numVisuals)
	    config->drawableType &= ~(GLX_WINDOW_BIT);

       /* fbconfig must support window drawables */
	if (!(config->drawableType & GLX_WINDOW_BIT)) {
	    config->visualID = 0;
	    continue;
	}

	/* Create a new X visual for our FBconfig. */
	visual = AddScreenVisuals(pScreen, 1, depth);
	if (visual == NULL)
	    continue;
d410 2
a411 2
	pGlxScreen->visuals[pGlxScreen->numVisuals++] = config;
	initGlxVisual(visual, config);
d417 2
a418 1
void __glXScreenDestroy(__GLXscreen *screen)
d423 1
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a177 2
                        "GLX_SGIX_hyperpipe "
                        "GLX_SGIX_swap_barrier "
a184 25
/*
 * If your DDX driver wants to register support for swap barriers or hyperpipe
 * topology, it should call __glXHyperpipeInit() or __glXSwapBarrierInit()
 * with a dispatch table of functions to handle the requests.   In the XFree86
 * DDX, for example, you would call these near the bottom of the driver's
 * ScreenInit method, after DRI has been initialized.
 *
 * This should be replaced with a better method when we teach the server how
 * to load DRI drivers.
 */

void __glXHyperpipeInit(int screen, __GLXHyperpipeExtensionFuncs *funcs)
{
    __GLXscreen *pGlxScreen = glxGetScreen(screenInfo.screens[screen]);

    pGlxScreen->hyperpipeFuncs = funcs;
}

void __glXSwapBarrierInit(int screen, __GLXSwapBarrierExtensionFuncs *funcs)
{
    __GLXscreen *pGlxScreen = glxGetScreen(screenInfo.screens[screen]);

    pGlxScreen->swapBarrierFuncs = funcs;
}

d398 1
d400 5
d406 1
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d47 2
a48 2
static int glxScreenPrivateKeyIndex;
static DevPrivateKey glxScreenPrivateKey = &glxScreenPrivateKeyIndex;
d355 3
d359 3
a361 3
    pGlxScreen->GLextensions  = xstrdup(GLServerExtensions);
    pGlxScreen->GLXvendor     = xstrdup(GLXServerVendorName);
    pGlxScreen->GLXextensions = xstrdup(GLXServerExtensions);
d384 1
a384 1
	xcalloc(pGlxScreen->numFBConfigs, sizeof (__GLXconfig *));
d442 3
a444 3
    xfree(screen->GLXvendor);
    xfree(screen->GLXextensions);
    xfree(screen->GLextensions);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d45 1
d166 2
a167 1
static char GLXServerVersion[] = "1.2";
d182 1
d184 1
d230 2
a231 2
void GlxSetVisualConfigs(int nconfigs, 
                         __GLXvisualConfig *configs, void **privates)
d255 1
a255 4
    XID		*installedCmaps, *vids, vid;
    int		 numInstalledCmaps, numVisuals, i, j;
    VisualPtr	 visuals;
    ColormapPtr	 installedCmap;
d268 2
a269 48
    /* Find the installed colormaps */
    installedCmaps = xalloc (pScreen->maxInstalledCmaps * sizeof (XID));
    if (!installedCmaps)
	return NULL;

    numInstalledCmaps = pScreen->ListInstalledColormaps(pScreen, installedCmaps);

    /* realloc the visual array to fit the new one in place */
    numVisuals = pScreen->numVisuals;
    visuals = xrealloc(pScreen->visuals, (numVisuals + count) * sizeof(VisualRec));
    if (!visuals) {
	xfree(installedCmaps);
	return NULL;
    }

    vids = xrealloc(depth->vids, (depth->numVids + count) * sizeof(XID));
    if (vids == NULL) {
	xfree(installedCmaps);
	xfree(visuals);
	return NULL;
    }

    /*
     * Fix up any existing installed colormaps -- we'll assume that
     * the only ones created so far have been installed.  If this
     * isn't true, we'll have to walk the resource database looking
     * for all colormaps.
     */
    for (i = 0; i < numInstalledCmaps; i++) {
	installedCmap = LookupIDByType (installedCmaps[i], RT_COLORMAP);
	if (!installedCmap)
	    continue;
	j = installedCmap->pVisual - pScreen->visuals;
	installedCmap->pVisual = &visuals[j];
    }

    xfree(installedCmaps);

    for (i = 0; i < count; i++) {
	vid = FakeClientID(0);
	visuals[pScreen->numVisuals + i].vid = vid;
	vids[depth->numVids + i] = vid;
    }

    pScreen->visuals = visuals;
    pScreen->numVisuals += count;
    depth->vids = vids;
    depth->numVids += count;
a357 1
    pGlxScreen->GLXversion    = xstrdup(GLXServerVersion);
d360 9
a439 1
    xfree(screen->GLXversion);
@


1.2
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d2 28
a29 33
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: The application programming interfaces
** established by SGI in conjunction with the Original Code are The
** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
** Window System(R) (Version 1.3), released October 19, 1998. This software
** was created using the OpenGL(R) version 1.2.1 Sample Implementation
** published by SGI, but has not been independently verified as being
** compliant with the OpenGL(R) version 1.2.1 Specification.
**
*/
d46 2
a47 1
static DevPrivateKey glxScreenPrivateKey = &glxScreenPrivateKey;
a183 45
** This hook gets called when a window moves or changes size.
*/
static Bool glxPositionWindow(WindowPtr pWin, int x, int y)
{
    ScreenPtr pScreen;
    __GLXdrawable *glxPriv;
    Bool ret;
    __GLXscreen *pGlxScreen;

    /*
    ** Call wrapped position window routine
    */
    pScreen = pWin->drawable.pScreen;
    pGlxScreen = glxGetScreen(pScreen);
    pScreen->PositionWindow = pGlxScreen->PositionWindow;
    ret = (*pScreen->PositionWindow)(pWin, x, y);
    pScreen->PositionWindow = glxPositionWindow;

    /*
    ** Tell all contexts rendering into this window that the window size
    ** has changed.
    */
    glxPriv = (__GLXdrawable *) LookupIDByType(pWin->drawable.id,
					       __glXDrawableRes);
    if (glxPriv == NULL) {
	/*
	** This window is not being used by the OpenGL.
	*/
	return ret;
    }

    /*
    ** resize the drawable
    */
    /* first change the drawable size */
    if (glxPriv->resize(glxPriv) == GL_FALSE) {
	/* resize failed! */
	/* XXX: what can we possibly do here? */
	ret = False;
    }

    return ret;
}

/*
a213 1
    pScreen->PositionWindow = pGlxScreen->PositionWindow;
a244 38

static void
filterOutNativeConfigs(__GLXscreen *pGlxScreen)
{
    __GLXconfig *m, *next, **last;
    ScreenPtr pScreen = pGlxScreen->pScreen;
    int i, depth;

    last = &pGlxScreen->fbconfigs;
    for (m = pGlxScreen->fbconfigs; m != NULL; m = next) {
	next = m->next;
	depth = m->redBits + m->blueBits + m->greenBits;

	for (i = 0; i < pScreen->numVisuals; i++) {
	    if (pScreen->visuals[i].nplanes == depth) {
		*last = m;
		last = &m->next;
		break;
	    }
	}
    }

    *last = NULL;
}

static XID
findVisualForConfig(ScreenPtr pScreen, __GLXconfig *m)
{
    int i;

    for (i = 0; i < pScreen->numVisuals; i++) {
	if (glxConvertToXVisualType(m->visualType) == pScreen->visuals[i].class)
	    return pScreen->visuals[i].vid;
    }

    return 0;
}

a351 6
typedef struct {
    GLboolean doubleBuffer;
    GLboolean depthBuffer;
    GLboolean stencilBuffer;
} FBConfigTemplateRec, *FBConfigTemplatePtr;

d353 1
a353 1
pickFBConfig(__GLXscreen *pGlxScreen, FBConfigTemplatePtr template, int class)
d355 2
a356 1
    __GLXconfig *config;
d359 6
d367 1
a367 3
	if (glxConvertToXVisualType(config->visualType) != class)
	    continue;
	if ((config->doubleBufferMode > 0) != template->doubleBuffer)
d369 2
a370 1
	if ((config->depthBits > 0) != template->depthBuffer)
d372 2
a373 1
	if ((config->stencilBits > 0) != template->stencilBuffer)
d376 13
a388 1
	return config;
d391 1
a391 82
    return NULL;
}

static void
addMinimalSet(__GLXscreen *pGlxScreen)
{
    __GLXconfig *config;
    VisualPtr visuals;
    int i, j;
    FBConfigTemplateRec best = { GL_TRUE, GL_TRUE, GL_TRUE };
    FBConfigTemplateRec good = { GL_TRUE, GL_TRUE, GL_FALSE };
    FBConfigTemplateRec minimal = { GL_FALSE, GL_FALSE, GL_FALSE };

    pGlxScreen->visuals = xcalloc(pGlxScreen->pScreen->numVisuals,
				  sizeof (__GLXconfig *));
    if (pGlxScreen->visuals == NULL) {
	ErrorF("Failed to allocate for minimal set of GLX visuals\n");
	return;
    }

    visuals = pGlxScreen->pScreen->visuals;
    for (i = 0, j = 0; i < pGlxScreen->pScreen->numVisuals; i++) {
	if (visuals[i].nplanes == 32)
	    config = pickFBConfig(pGlxScreen, &minimal, visuals[i].class);
	else {
	    config = pickFBConfig(pGlxScreen, &best, visuals[i].class);
	    if (config == NULL)
		config = pickFBConfig(pGlxScreen, &good, visuals[i].class);
        }
	if (config == NULL)
	    config = pGlxScreen->fbconfigs;
	if (config == NULL)
	    continue;

	pGlxScreen->visuals[j] = config;
	config->visualID = visuals[i].vid;
	j++;
    }

    pGlxScreen->numVisuals = j;
}

static void
addTypicalSet(__GLXscreen *pGlxScreen)
{
    addMinimalSet(pGlxScreen);
}

static void
addFullSet(__GLXscreen *pGlxScreen)
{
    __GLXconfig *config;
    VisualPtr visuals;
    int i, depth;

    pGlxScreen->visuals =
	xcalloc(pGlxScreen->numFBConfigs, sizeof (__GLXconfig *));
    if (pGlxScreen->visuals == NULL) {
	ErrorF("Failed to allocate for full set of GLX visuals\n");
	return;
    }

    config = pGlxScreen->fbconfigs;
    depth = config->redBits + config->greenBits + config->blueBits;
    visuals = AddScreenVisuals(pGlxScreen->pScreen, pGlxScreen->numFBConfigs, depth);
    if (visuals == NULL) {
	xfree(pGlxScreen->visuals);
	return;
    }

    pGlxScreen->numVisuals = pGlxScreen->numFBConfigs;
    for (i = 0, config = pGlxScreen->fbconfigs; config; config = config->next, i++) {
	pGlxScreen->visuals[i] = config;
	initGlxVisual(&visuals[i], config);
    }
}

static int glxVisualConfig = GLX_ALL_VISUALS;

void GlxSetVisualConfig(int config)
{
    glxVisualConfig = config;
d397 1
a405 3
    pGlxScreen->PositionWindow = pScreen->PositionWindow;
    pScreen->PositionWindow = glxPositionWindow;
 
a408 2
    filterOutNativeConfigs(pGlxScreen);

d412 1
a412 1
	m->visualID = findVisualForConfig(pScreen, m);
d417 52
a468 16
    /* Select a subset of fbconfigs that we send to the client when it
     * asks for the glx visuals.  All the fbconfigs here have a valid
     * value for visual ID and each visual ID is only present once.
     * This runs before composite adds its extra visual so we have to
     * remember the number of visuals here.*/

    switch (glxVisualConfig) {
    case GLX_MINIMAL_VISUALS:
	addMinimalSet(pGlxScreen);
	break;
    case GLX_TYPICAL_VISUALS:
	addTypicalSet(pGlxScreen);
	break;
    case GLX_ALL_VISUALS:
	addFullSet(pGlxScreen);
	break;
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d113 1
a113 1
 			"GL_EXT_texture_filter_ansiotropic "
@

