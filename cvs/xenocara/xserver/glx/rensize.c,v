head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	s0SI41sEunLdyFfd;

1.6
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	Te1daavkBLskZ8gc;

1.5
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	vcnjRBuLQw44cPHf;

1.4
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches
	1.4.8.1
	1.4.10.1;
next	1.3;

1.3
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.14;	author matthieu;	state Exp;
branches;
next	;

1.4.8.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.4.10.1
date	2014.12.09.17.59.32;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.7
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <GL/gl.h>
#include "glxserver.h"
#include "GL/glxproto.h"
#include "unpack.h"
#include "indirect_size.h"
#include "indirect_reqsize.h"

#define SWAPL(a) \
  (((a & 0xff000000U)>>24) | ((a & 0xff0000U)>>8) | \
   ((a & 0xff00U)<<8) | ((a & 0xffU)<<24))

int
__glXMap1dReqSize(const GLbyte * pc, Bool swap, int reqlen)
{
    GLenum target;
    GLint order;

    target = *(GLenum *) (pc + 16);
    order = *(GLint *) (pc + 20);
    if (swap) {
        target = SWAPL(target);
        order = SWAPL(order);
    }
    if (order < 1)
        return -1;
    return safe_mul(8, safe_mul(__glMap1d_size(target), order));
}

int
__glXMap1fReqSize(const GLbyte * pc, Bool swap, int reqlen)
{
    GLenum target;
    GLint order;

    target = *(GLenum *) (pc + 0);
    order = *(GLint *) (pc + 12);
    if (swap) {
        target = SWAPL(target);
        order = SWAPL(order);
    }
    if (order < 1)
        return -1;
    return safe_mul(4, safe_mul(__glMap1f_size(target), order));
}

static int
Map2Size(int k, int majorOrder, int minorOrder)
{
    if (majorOrder < 1 || minorOrder < 1)
        return -1;
    return safe_mul(k, safe_mul(majorOrder, minorOrder));
}

int
__glXMap2dReqSize(const GLbyte * pc, Bool swap, int reqlen)
{
    GLenum target;
    GLint uorder, vorder;

    target = *(GLenum *) (pc + 32);
    uorder = *(GLint *) (pc + 36);
    vorder = *(GLint *) (pc + 40);
    if (swap) {
        target = SWAPL(target);
        uorder = SWAPL(uorder);
        vorder = SWAPL(vorder);
    }
    return safe_mul(8, Map2Size(__glMap2d_size(target), uorder, vorder));
}

int
__glXMap2fReqSize(const GLbyte * pc, Bool swap, int reqlen)
{
    GLenum target;
    GLint uorder, vorder;

    target = *(GLenum *) (pc + 0);
    uorder = *(GLint *) (pc + 12);
    vorder = *(GLint *) (pc + 24);
    if (swap) {
        target = SWAPL(target);
        uorder = SWAPL(uorder);
        vorder = SWAPL(vorder);
    }
    return safe_mul(4, Map2Size(__glMap2f_size(target), uorder, vorder));
}

/**
 * Calculate the size of an image.
 *
 * The size of an image sent to the server from the client or sent from the
 * server to the client is calculated.  The size is based on the dimensions
 * of the image, the type of pixel data, padding in the image, and the
 * alignment requirements of the image.
 *
 * \param format       Format of the pixels.  Same as the \c format parameter
 *                     to \c glTexImage1D
 * \param type         Type of the pixel data.  Same as the \c type parameter
 *                     to \c glTexImage1D
 * \param target       Typically the texture target of the image.  If the
 *                     target is one of \c GL_PROXY_*, the size returned is
 *                     always zero. For uses that do not have a texture target
 *                     (e.g, glDrawPixels), zero should be specified.
 * \param w            Width of the image data.  Must be >= 1.
 * \param h            Height of the image data.  Must be >= 1, even for 1D
 *                     images.
 * \param d            Depth of the image data.  Must be >= 1, even for 1D or
 *                     2D images.
 * \param imageHeight  If non-zero, defines the true height of a volumetric
 *                     image.  This value will be used instead of \c h for
 *                     calculating the size of the image.
 * \param rowLength    If non-zero, defines the true width of an image.  This
 *                     value will be used instead of \c w for calculating the
 *                     size of the image.
 * \param skipImages   Number of extra layers of image data in a volumtric
 *                     image that are to be skipped before the real data.
 * \param skipRows     Number of extra rows of image data in an image that are
 *                     to be skipped before the real data.
 * \param alignment    Specifies the alignment for the start of each pixel row
 *                     in memory.  This value must be one of 1, 2, 4, or 8.
 *
 * \returns
 * The size of the image is returned.  If the specified \c format and \c type
 * are invalid, -1 is returned.  If \c target is one of \c GL_PROXY_*, zero
 * is returned.
 */
int
__glXImageSize(GLenum format, GLenum type, GLenum target,
               GLsizei w, GLsizei h, GLsizei d,
               GLint imageHeight, GLint rowLength,
               GLint skipImages, GLint skipRows, GLint alignment)
{
    GLint bytesPerElement, elementsPerGroup, groupsPerRow;
    GLint groupSize, rowSize, padding, imageSize;

    if (w == 0 || h == 0 || d == 0)
        return 0;

    if (w < 0 || h < 0 || d < 0 ||
        (type == GL_BITMAP &&
         (format != GL_COLOR_INDEX && format != GL_STENCIL_INDEX))) {
        return -1;
    }

    /* proxy targets have no data */
    switch (target) {
    case GL_PROXY_TEXTURE_1D:
    case GL_PROXY_TEXTURE_2D:
    case GL_PROXY_TEXTURE_3D:
    case GL_PROXY_TEXTURE_4D_SGIS:
    case GL_PROXY_TEXTURE_CUBE_MAP:
    case GL_PROXY_TEXTURE_RECTANGLE_ARB:
    case GL_PROXY_HISTOGRAM:
    case GL_PROXY_COLOR_TABLE:
    case GL_PROXY_TEXTURE_COLOR_TABLE_SGI:
    case GL_PROXY_POST_CONVOLUTION_COLOR_TABLE:
    case GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE:
    case GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP:
        return 0;
    }

    /* real data has to have real sizes */
    if (imageHeight < 0 || rowLength < 0 || skipImages < 0 || skipRows < 0)
        return -1;
    if (alignment != 1 && alignment != 2 && alignment != 4 && alignment != 8)
        return -1;

    if (type == GL_BITMAP) {
        if (rowLength > 0) {
            groupsPerRow = rowLength;
        }
        else {
            groupsPerRow = w;
        }
        rowSize = bits_to_bytes(groupsPerRow);
        if (rowSize < 0)
            return -1;
        padding = (rowSize % alignment);
        if (padding) {
            rowSize += alignment - padding;
        }

        return safe_mul(safe_add(h, skipRows), rowSize);
    }
    else {
        switch (format) {
        case GL_COLOR_INDEX:
        case GL_STENCIL_INDEX:
        case GL_DEPTH_COMPONENT:
        case GL_RED:
        case GL_GREEN:
        case GL_BLUE:
        case GL_ALPHA:
        case GL_LUMINANCE:
        case GL_INTENSITY:
        case GL_RED_INTEGER_EXT:
        case GL_GREEN_INTEGER_EXT:
        case GL_BLUE_INTEGER_EXT:
        case GL_ALPHA_INTEGER_EXT:
        case GL_LUMINANCE_INTEGER_EXT:
            elementsPerGroup = 1;
            break;
        case GL_422_EXT:
        case GL_422_REV_EXT:
        case GL_422_AVERAGE_EXT:
        case GL_422_REV_AVERAGE_EXT:
        case GL_DEPTH_STENCIL_NV:
        case GL_DEPTH_STENCIL_MESA:
        case GL_YCBCR_422_APPLE:
        case GL_YCBCR_MESA:
        case GL_LUMINANCE_ALPHA:
        case GL_LUMINANCE_ALPHA_INTEGER_EXT:
            elementsPerGroup = 2;
            break;
        case GL_RGB:
        case GL_BGR:
        case GL_RGB_INTEGER_EXT:
        case GL_BGR_INTEGER_EXT:
            elementsPerGroup = 3;
            break;
        case GL_RGBA:
        case GL_BGRA:
        case GL_RGBA_INTEGER_EXT:
        case GL_BGRA_INTEGER_EXT:
        case GL_ABGR_EXT:
            elementsPerGroup = 4;
            break;
        default:
            return -1;
        }
        switch (type) {
        case GL_UNSIGNED_BYTE:
        case GL_BYTE:
            bytesPerElement = 1;
            break;
        case GL_UNSIGNED_BYTE_3_3_2:
        case GL_UNSIGNED_BYTE_2_3_3_REV:
            bytesPerElement = 1;
            elementsPerGroup = 1;
            break;
        case GL_UNSIGNED_SHORT:
        case GL_SHORT:
            bytesPerElement = 2;
            break;
        case GL_UNSIGNED_SHORT_5_6_5:
        case GL_UNSIGNED_SHORT_5_6_5_REV:
        case GL_UNSIGNED_SHORT_4_4_4_4:
        case GL_UNSIGNED_SHORT_4_4_4_4_REV:
        case GL_UNSIGNED_SHORT_5_5_5_1:
        case GL_UNSIGNED_SHORT_1_5_5_5_REV:
        case GL_UNSIGNED_SHORT_8_8_APPLE:
        case GL_UNSIGNED_SHORT_8_8_REV_APPLE:
        case GL_UNSIGNED_SHORT_15_1_MESA:
        case GL_UNSIGNED_SHORT_1_15_REV_MESA:
            bytesPerElement = 2;
            elementsPerGroup = 1;
            break;
        case GL_INT:
        case GL_UNSIGNED_INT:
        case GL_FLOAT:
            bytesPerElement = 4;
            break;
        case GL_UNSIGNED_INT_8_8_8_8:
        case GL_UNSIGNED_INT_8_8_8_8_REV:
        case GL_UNSIGNED_INT_10_10_10_2:
        case GL_UNSIGNED_INT_2_10_10_10_REV:
        case GL_UNSIGNED_INT_24_8_NV:
        case GL_UNSIGNED_INT_24_8_MESA:
        case GL_UNSIGNED_INT_8_24_REV_MESA:
            bytesPerElement = 4;
            elementsPerGroup = 1;
            break;
        default:
            return -1;
        }
        /* known safe by the switches above, not checked */
        groupSize = bytesPerElement * elementsPerGroup;
        if (rowLength > 0) {
            groupsPerRow = rowLength;
        }
        else {
            groupsPerRow = w;
        }

        if ((rowSize = safe_mul(groupsPerRow, groupSize)) < 0)
            return -1;
        padding = (rowSize % alignment);
        if (padding) {
            rowSize += alignment - padding;
        }

        if (imageHeight > 0)
            h = imageHeight;
        h = safe_add(h, skipRows);

        imageSize = safe_mul(h, rowSize);

        return safe_mul(safe_add(d, skipImages), imageSize);
    }
}

/* XXX this is used elsewhere - should it be exported from glxserver.h? */
int
__glXTypeSize(GLenum enm)
{
    switch (enm) {
    case GL_BYTE:
        return sizeof(GLbyte);
    case GL_UNSIGNED_BYTE:
        return sizeof(GLubyte);
    case GL_SHORT:
        return sizeof(GLshort);
    case GL_UNSIGNED_SHORT:
        return sizeof(GLushort);
    case GL_INT:
        return sizeof(GLint);
    case GL_UNSIGNED_INT:
        return sizeof(GLint);
    case GL_FLOAT:
        return sizeof(GLfloat);
    case GL_DOUBLE:
        return sizeof(GLdouble);
    default:
        return -1;
    }
}

int
__glXDrawArraysReqSize(const GLbyte * pc, Bool swap, int reqlen)
{
    __GLXdispatchDrawArraysHeader *hdr = (__GLXdispatchDrawArraysHeader *) pc;
    __GLXdispatchDrawArraysComponentHeader *compHeader;
    GLint numVertexes = hdr->numVertexes;
    GLint numComponents = hdr->numComponents;
    GLint arrayElementSize = 0;
    GLint x, size;
    int i;

    if (swap) {
        numVertexes = SWAPL(numVertexes);
        numComponents = SWAPL(numComponents);
    }

    pc += sizeof(__GLXdispatchDrawArraysHeader);
    reqlen -= sizeof(__GLXdispatchDrawArraysHeader);

    size = safe_mul(sizeof(__GLXdispatchDrawArraysComponentHeader),
                    numComponents);
    if (size < 0 || reqlen < 0 || reqlen < size)
        return -1;

    compHeader = (__GLXdispatchDrawArraysComponentHeader *) pc;

    for (i = 0; i < numComponents; i++) {
        GLenum datatype = compHeader[i].datatype;
        GLint numVals = compHeader[i].numVals;
        GLint component = compHeader[i].component;

        if (swap) {
            datatype = SWAPL(datatype);
            numVals = SWAPL(numVals);
            component = SWAPL(component);
        }

        switch (component) {
        case GL_VERTEX_ARRAY:
        case GL_COLOR_ARRAY:
        case GL_TEXTURE_COORD_ARRAY:
            break;
        case GL_SECONDARY_COLOR_ARRAY:
        case GL_NORMAL_ARRAY:
            if (numVals != 3) {
                /* bad size */
                return -1;
            }
            break;
        case GL_FOG_COORD_ARRAY:
        case GL_INDEX_ARRAY:
            if (numVals != 1) {
                /* bad size */
                return -1;
            }
            break;
        case GL_EDGE_FLAG_ARRAY:
            if ((numVals != 1) && (datatype != GL_UNSIGNED_BYTE)) {
                /* bad size or bad type */
                return -1;
            }
            break;
        default:
            /* unknown component type */
            return -1;
        }

        x = safe_pad(safe_mul(numVals, __glXTypeSize(datatype)));
        if ((arrayElementSize = safe_add(arrayElementSize, x)) < 0)
            return -1;

        pc += sizeof(__GLXdispatchDrawArraysComponentHeader);
    }

    return safe_add(size, safe_mul(numVertexes, arrayElementSize));
}

int
__glXSeparableFilter2DReqSize(const GLbyte * pc, Bool swap, int reqlen)
{
    __GLXdispatchConvolutionFilterHeader *hdr =
        (__GLXdispatchConvolutionFilterHeader *) pc;

    GLint image1size, image2size;
    GLenum format = hdr->format;
    GLenum type = hdr->type;
    GLint w = hdr->width;
    GLint h = hdr->height;
    GLint rowLength = hdr->rowLength;
    GLint alignment = hdr->alignment;

    if (swap) {
        format = SWAPL(format);
        type = SWAPL(type);
        w = SWAPL(w);
        h = SWAPL(h);
        rowLength = SWAPL(rowLength);
        alignment = SWAPL(alignment);
    }

    /* XXX Should rowLength be used for either or both image? */
    image1size = __glXImageSize(format, type, 0, w, 1, 1,
                                0, rowLength, 0, 0, alignment);
    image2size = __glXImageSize(format, type, 0, h, 1, 1,
                                0, rowLength, 0, 0, alignment);
    return safe_add(safe_pad(image1size), image2size);
}
@


1.6
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d243 1
@


1.5
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d124 1
a124 1
 * 
d129 1
a129 1
 * 
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a45 8
static int
Map1Size(GLint k, GLint order)
{
    if (order <= 0 || k < 0)
        return -1;
    return k * order;
}

d47 1
a47 1
__glXMap1dReqSize(const GLbyte * pc, Bool swap)
d50 1
a50 1
    GLint order, k;
d58 3
a60 2
    k = __glMap1d_size(target);
    return 8 * Map1Size(k, order);
d64 1
a64 1
__glXMap1fReqSize(const GLbyte * pc, Bool swap)
d67 1
a67 1
    GLint order, k;
d75 3
a77 2
    k = __glMap1f_size(target);
    return 4 * Map1Size(k, order);
d83 1
a83 1
    if (majorOrder <= 0 || minorOrder <= 0 || k < 0)
d85 1
a85 1
    return k * majorOrder * minorOrder;
d89 1
a89 1
__glXMap2dReqSize(const GLbyte * pc, Bool swap)
d92 1
a92 1
    GLint uorder, vorder, k;
d102 1
a102 2
    k = __glMap2d_size(target);
    return 8 * Map2Size(k, uorder, vorder);
d106 1
a106 1
__glXMap2fReqSize(const GLbyte * pc, Bool swap)
d109 1
a109 1
    GLint uorder, vorder, k;
d119 1
a119 2
    k = __glMap2f_size(target);
    return 4 * Map2Size(k, uorder, vorder);
d170 3
a177 2
    if (w == 0 || h == 0 || d == 0)
        return 0;
d179 1
d196 6
d210 2
d216 2
a217 1
        return ((h + skipRows) * rowSize);
d230 5
d245 1
d250 2
d256 2
d309 1
d317 3
a319 1
        rowSize = groupsPerRow * groupSize;
d324 8
a331 7
        if (imageHeight > 0) {
            imageSize = (imageHeight + skipRows) * rowSize;
        }
        else {
            imageSize = (h + skipRows) * rowSize;
        }
        return ((d + skipImages) * imageSize);
d362 1
a362 1
__glXDrawArraysReqSize(const GLbyte * pc, Bool swap)
d369 1
d378 7
d428 3
a430 1
        arrayElementSize += __GLX_PAD(numVals * __glXTypeSize(datatype));
d435 1
a435 2
    return ((numComponents * sizeof(__GLXdispatchDrawArraysComponentHeader)) +
            (numVertexes * arrayElementSize));
d439 1
a439 1
__glXSeparableFilter2DReqSize(const GLbyte * pc, Bool swap)
a463 1
    image1size = __GLX_PAD(image1size);
d466 1
a466 2
    return image1size + image2size;

@


1.4.8.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d46 8
d55 1
a55 1
__glXMap1dReqSize(const GLbyte * pc, Bool swap, int reqlen)
d58 1
a58 1
    GLint order;
d66 2
a67 3
    if (order < 1)
        return -1;
    return safe_mul(8, safe_mul(__glMap1d_size(target), order));
d71 1
a71 1
__glXMap1fReqSize(const GLbyte * pc, Bool swap, int reqlen)
d74 1
a74 1
    GLint order;
d82 2
a83 3
    if (order < 1)
        return -1;
    return safe_mul(4, safe_mul(__glMap1f_size(target), order));
d89 1
a89 1
    if (majorOrder < 1 || minorOrder < 1)
d91 1
a91 1
    return safe_mul(k, safe_mul(majorOrder, minorOrder));
d95 1
a95 1
__glXMap2dReqSize(const GLbyte * pc, Bool swap, int reqlen)
d98 1
a98 1
    GLint uorder, vorder;
d108 2
a109 1
    return safe_mul(8, Map2Size(__glMap2d_size(target), uorder, vorder));
d113 1
a113 1
__glXMap2fReqSize(const GLbyte * pc, Bool swap, int reqlen)
d116 1
a116 1
    GLint uorder, vorder;
d126 2
a127 1
    return safe_mul(4, Map2Size(__glMap2f_size(target), uorder, vorder));
a177 3
    if (w == 0 || h == 0 || d == 0)
        return 0;

d183 2
a185 1
    /* proxy targets have no data */
a201 6
    /* real data has to have real sizes */
    if (imageHeight < 0 || rowLength < 0 || skipImages < 0 || skipRows < 0)
        return -1;
    if (alignment != 1 && alignment != 2 && alignment != 4 && alignment != 8)
        return -1;

a209 2
        if (rowSize < 0)
            return -1;
d214 1
a214 2

        return safe_mul(safe_add(h, skipRows), rowSize);
a226 5
        case GL_RED_INTEGER_EXT:
        case GL_GREEN_INTEGER_EXT:
        case GL_BLUE_INTEGER_EXT:
        case GL_ALPHA_INTEGER_EXT:
        case GL_LUMINANCE_INTEGER_EXT:
a236 1
        case GL_LUMINANCE_ALPHA_INTEGER_EXT:
a240 2
        case GL_RGB_INTEGER_EXT:
        case GL_BGR_INTEGER_EXT:
a244 2
        case GL_RGBA_INTEGER_EXT:
        case GL_BGRA_INTEGER_EXT:
a295 1
        /* known safe by the switches above, not checked */
d303 1
a303 3

        if ((rowSize = safe_mul(groupsPerRow, groupSize)) < 0)
            return -1;
d308 7
a314 8

        if (imageHeight > 0)
            h = imageHeight;
        h = safe_add(h, skipRows);

        imageSize = safe_mul(h, rowSize);

        return safe_mul(safe_add(d, skipImages), imageSize);
d345 1
a345 1
__glXDrawArraysReqSize(const GLbyte * pc, Bool swap, int reqlen)
a351 1
    GLint x, size;
a359 7
    reqlen -= sizeof(__GLXdispatchDrawArraysHeader);

    size = safe_mul(sizeof(__GLXdispatchDrawArraysComponentHeader),
                    numComponents);
    if (size < 0 || reqlen < 0 || reqlen < size)
        return -1;

d403 1
a403 3
        x = safe_pad(safe_mul(numVals, __glXTypeSize(datatype)));
        if ((arrayElementSize = safe_add(arrayElementSize, x)) < 0)
            return -1;
d408 2
a409 1
    return safe_add(size, safe_mul(numVertexes, arrayElementSize));
d413 1
a413 1
__glXSeparableFilter2DReqSize(const GLbyte * pc, Bool swap, int reqlen)
d438 1
d441 2
a442 1
    return safe_add(safe_pad(image1size), image2size);
@


1.4.10.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d46 8
d55 1
a55 1
__glXMap1dReqSize(const GLbyte * pc, Bool swap, int reqlen)
d58 1
a58 1
    GLint order;
d66 2
a67 3
    if (order < 1)
        return -1;
    return safe_mul(8, safe_mul(__glMap1d_size(target), order));
d71 1
a71 1
__glXMap1fReqSize(const GLbyte * pc, Bool swap, int reqlen)
d74 1
a74 1
    GLint order;
d82 2
a83 3
    if (order < 1)
        return -1;
    return safe_mul(4, safe_mul(__glMap1f_size(target), order));
d89 1
a89 1
    if (majorOrder < 1 || minorOrder < 1)
d91 1
a91 1
    return safe_mul(k, safe_mul(majorOrder, minorOrder));
d95 1
a95 1
__glXMap2dReqSize(const GLbyte * pc, Bool swap, int reqlen)
d98 1
a98 1
    GLint uorder, vorder;
d108 2
a109 1
    return safe_mul(8, Map2Size(__glMap2d_size(target), uorder, vorder));
d113 1
a113 1
__glXMap2fReqSize(const GLbyte * pc, Bool swap, int reqlen)
d116 1
a116 1
    GLint uorder, vorder;
d126 2
a127 1
    return safe_mul(4, Map2Size(__glMap2f_size(target), uorder, vorder));
a177 3
    if (w == 0 || h == 0 || d == 0)
        return 0;

d183 2
a185 1
    /* proxy targets have no data */
a201 6
    /* real data has to have real sizes */
    if (imageHeight < 0 || rowLength < 0 || skipImages < 0 || skipRows < 0)
        return -1;
    if (alignment != 1 && alignment != 2 && alignment != 4 && alignment != 8)
        return -1;

a209 2
        if (rowSize < 0)
            return -1;
d214 1
a214 2

        return safe_mul(safe_add(h, skipRows), rowSize);
a226 5
        case GL_RED_INTEGER_EXT:
        case GL_GREEN_INTEGER_EXT:
        case GL_BLUE_INTEGER_EXT:
        case GL_ALPHA_INTEGER_EXT:
        case GL_LUMINANCE_INTEGER_EXT:
a236 1
        case GL_LUMINANCE_ALPHA_INTEGER_EXT:
a240 2
        case GL_RGB_INTEGER_EXT:
        case GL_BGR_INTEGER_EXT:
a244 2
        case GL_RGBA_INTEGER_EXT:
        case GL_BGRA_INTEGER_EXT:
a295 1
        /* known safe by the switches above, not checked */
d303 1
a303 3

        if ((rowSize = safe_mul(groupsPerRow, groupSize)) < 0)
            return -1;
d308 7
a314 8

        if (imageHeight > 0)
            h = imageHeight;
        h = safe_add(h, skipRows);

        imageSize = safe_mul(h, rowSize);

        return safe_mul(safe_add(d, skipImages), imageSize);
d345 1
a345 1
__glXDrawArraysReqSize(const GLbyte * pc, Bool swap, int reqlen)
a351 1
    GLint x, size;
a359 7
    reqlen -= sizeof(__GLXdispatchDrawArraysHeader);

    size = safe_mul(sizeof(__GLXdispatchDrawArraysComponentHeader),
                    numComponents);
    if (size < 0 || reqlen < 0 || reqlen < size)
        return -1;

d403 1
a403 3
        x = safe_pad(safe_mul(numVals, __glXTypeSize(datatype)));
        if ((arrayElementSize = safe_add(arrayElementSize, x)) < 0)
            return -1;
d408 2
a409 1
    return safe_add(size, safe_mul(numVertexes, arrayElementSize));
d413 1
a413 1
__glXSeparableFilter2DReqSize(const GLbyte * pc, Bool swap, int reqlen)
d438 1
d441 2
a442 1
    return safe_add(safe_pad(image1size), image2size);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d46 2
a47 1
static int Map1Size( GLint k, GLint order)
d49 2
a50 1
    if (order <= 0 || k < 0) return -1;
d54 2
a55 1
int __glXMap1dReqSize( const GLbyte *pc, Bool swap )
d60 2
a61 2
    target = *(GLenum*) (pc + 16);
    order = *(GLint*) (pc + 20);
d63 2
a64 2
	target = SWAPL( target );
	order = SWAPL( order );
d66 2
a67 2
    k = __glMap1d_size( target );
    return 8 * Map1Size( k, order );
d70 2
a71 1
int __glXMap1fReqSize( const GLbyte *pc, Bool swap )
d76 2
a77 2
    target = *(GLenum *)(pc + 0);
    order = *(GLint *)(pc + 12);
d79 2
a80 2
	target = SWAPL( target );
	order = SWAPL( order );
d86 2
a87 1
static int Map2Size(int k, int majorOrder, int minorOrder)
d89 2
a90 1
    if (majorOrder <= 0 || minorOrder <= 0 || k < 0) return -1;
d94 2
a95 1
int __glXMap2dReqSize( const GLbyte *pc, Bool swap )
d100 3
a102 3
    target = *(GLenum *)(pc + 32);
    uorder = *(GLint *)(pc + 36);
    vorder = *(GLint *)(pc + 40);
d104 3
a106 3
	target = SWAPL( target );
	uorder = SWAPL( uorder );
	vorder = SWAPL( vorder );
d108 2
a109 2
    k = __glMap2d_size( target );
    return 8 * Map2Size( k, uorder, vorder );
d112 2
a113 1
int __glXMap2fReqSize( const GLbyte *pc, Bool swap )
d118 3
a120 3
    target = *(GLenum *)(pc + 0);
    uorder = *(GLint *)(pc + 12);
    vorder = *(GLint *)(pc + 24);
d122 3
a124 3
	target = SWAPL( target );
	uorder = SWAPL( uorder );
	vorder = SWAPL( vorder );
d126 2
a127 2
    k = __glMap2f_size( target );
    return 4 * Map2Size( k, uorder, vorder );
d169 5
a173 4
int __glXImageSize( GLenum format, GLenum type, GLenum target,
		    GLsizei w, GLsizei h, GLsizei d,
		    GLint imageHeight, GLint rowLength,
		    GLint skipImages, GLint skipRows, GLint alignment )
d179 3
a181 3
	(type == GL_BITMAP &&
	 (format != GL_COLOR_INDEX && format != GL_STENCIL_INDEX))) {
	return -1;
d183 2
a184 1
    if (w==0 || h==0 || d == 0) return 0;
d186 1
a186 1
    switch( target ) {
d199 1
a199 1
	return 0;
d203 112
a314 108
	if (rowLength > 0) {
	    groupsPerRow = rowLength;
	} else {
	    groupsPerRow = w;
	}
	rowSize = bits_to_bytes(groupsPerRow);
	padding = (rowSize % alignment);
	if (padding) {
	    rowSize += alignment - padding;
	}
	return ((h + skipRows) * rowSize);
    } else {
	switch(format) {
	  case GL_COLOR_INDEX:
	  case GL_STENCIL_INDEX:
	  case GL_DEPTH_COMPONENT:
	  case GL_RED:
	  case GL_GREEN:
	  case GL_BLUE:
	  case GL_ALPHA:
	  case GL_LUMINANCE:
	  case GL_INTENSITY:
	    elementsPerGroup = 1;
	    break;
	  case GL_422_EXT:
	  case GL_422_REV_EXT:
	  case GL_422_AVERAGE_EXT:
	  case GL_422_REV_AVERAGE_EXT:
	  case GL_DEPTH_STENCIL_NV:
	  case GL_DEPTH_STENCIL_MESA:
	  case GL_YCBCR_MESA:
	  case GL_LUMINANCE_ALPHA:
	    elementsPerGroup = 2;
	    break;
	  case GL_RGB:
	  case GL_BGR:
	    elementsPerGroup = 3;
	    break;
	  case GL_RGBA:
	  case GL_BGRA:
	  case GL_ABGR_EXT:
	    elementsPerGroup = 4;
	    break;
	  default:
	    return -1;
	}
	switch(type) {
	  case GL_UNSIGNED_BYTE:
	  case GL_BYTE:
	    bytesPerElement = 1;
	    break;
	  case GL_UNSIGNED_BYTE_3_3_2:
	  case GL_UNSIGNED_BYTE_2_3_3_REV:
	    bytesPerElement = 1;	    
	    elementsPerGroup = 1;
	    break;
	  case GL_UNSIGNED_SHORT:
	  case GL_SHORT:
	    bytesPerElement = 2;
	    break;
	  case GL_UNSIGNED_SHORT_5_6_5:
	  case GL_UNSIGNED_SHORT_5_6_5_REV:
	  case GL_UNSIGNED_SHORT_4_4_4_4:
 	  case GL_UNSIGNED_SHORT_4_4_4_4_REV:
	  case GL_UNSIGNED_SHORT_5_5_5_1:
	  case GL_UNSIGNED_SHORT_1_5_5_5_REV:
	  case GL_UNSIGNED_SHORT_8_8_APPLE:
	  case GL_UNSIGNED_SHORT_8_8_REV_APPLE:
	  case GL_UNSIGNED_SHORT_15_1_MESA:
	  case GL_UNSIGNED_SHORT_1_15_REV_MESA:
	    bytesPerElement = 2;
	    elementsPerGroup = 1;
	    break;
	  case GL_INT:
	  case GL_UNSIGNED_INT:
	  case GL_FLOAT:
	    bytesPerElement = 4;
	    break;
	  case GL_UNSIGNED_INT_8_8_8_8:
	  case GL_UNSIGNED_INT_8_8_8_8_REV:
	  case GL_UNSIGNED_INT_10_10_10_2:
	  case GL_UNSIGNED_INT_2_10_10_10_REV:
	  case GL_UNSIGNED_INT_24_8_NV:
	  case GL_UNSIGNED_INT_24_8_MESA:
	  case GL_UNSIGNED_INT_8_24_REV_MESA:
	    bytesPerElement = 4;
	    elementsPerGroup = 1;
	    break;
	  default:
	    return -1;
	}
	groupSize = bytesPerElement * elementsPerGroup;
	if (rowLength > 0) {
	    groupsPerRow = rowLength;
	} else {
	    groupsPerRow = w;
	}
	rowSize = groupsPerRow * groupSize;
	padding = (rowSize % alignment);
	if (padding) {
	    rowSize += alignment - padding;
	}
	if (imageHeight > 0) {
	    imageSize = (imageHeight + skipRows) * rowSize;
	} else {
	    imageSize = (h + skipRows) * rowSize;
	}
	return ((d + skipImages) * imageSize);
a317 1

d319 2
a320 1
int __glXTypeSize(GLenum enm)
d322 20
a341 11
  switch(enm) {
    case GL_BYTE:		return sizeof(GLbyte);
    case GL_UNSIGNED_BYTE:	return sizeof(GLubyte);
    case GL_SHORT:		return sizeof(GLshort);
    case GL_UNSIGNED_SHORT:	return sizeof(GLushort);
    case GL_INT:		return sizeof(GLint);
    case GL_UNSIGNED_INT:	return sizeof(GLint);
    case GL_FLOAT:		return sizeof(GLfloat);
    case GL_DOUBLE:		return sizeof(GLdouble);
    default:			return -1;
  }
d344 2
a345 1
int __glXDrawArraysReqSize( const GLbyte *pc, Bool swap )
d355 2
a356 2
	numVertexes = SWAPL( numVertexes );
	numComponents = SWAPL( numComponents );
d362 40
a401 40
    for (i=0; i<numComponents; i++) {
	GLenum datatype = compHeader[i].datatype;
	GLint numVals = compHeader[i].numVals;
	GLint component = compHeader[i].component;

	if (swap) {
	    datatype = SWAPL( datatype );
	    numVals = SWAPL( numVals );
	    component = SWAPL( component );
	}

	switch (component) {
	  case GL_VERTEX_ARRAY:
	  case GL_COLOR_ARRAY:
	  case GL_TEXTURE_COORD_ARRAY:
	    break;
	  case GL_SECONDARY_COLOR_ARRAY:
	  case GL_NORMAL_ARRAY:
	    if (numVals != 3) {
		/* bad size */
		return -1;
	    }
	    break;
	  case GL_FOG_COORD_ARRAY:
	  case GL_INDEX_ARRAY:
	    if (numVals != 1) {
		/* bad size */
		return -1;
	    }
	    break;
	  case GL_EDGE_FLAG_ARRAY:
	    if ((numVals != 1) && (datatype != GL_UNSIGNED_BYTE)) {
		/* bad size or bad type */
		return -1;
	    }
	    break;
	  default:
	    /* unknown component type */
	    return -1;
	}
d403 1
a403 1
	arrayElementSize += __GLX_PAD(numVals * __glXTypeSize(datatype));
d405 1
a405 1
	pc += sizeof(__GLXdispatchDrawArraysComponentHeader);
d409 1
a409 1
	    (numVertexes * arrayElementSize));
d412 2
a413 1
int __glXSeparableFilter2DReqSize( const GLbyte *pc, Bool swap )
d416 1
a416 1
			(__GLXdispatchConvolutionFilterHeader *) pc;
d427 6
a432 6
	format = SWAPL( format );
	type = SWAPL( type );
	w = SWAPL( w );
	h = SWAPL( h );
	rowLength = SWAPL( rowLength );
	alignment = SWAPL( alignment );
d436 2
a437 2
    image1size = __glXImageSize( format, type, 0, w, 1, 1,
				 0, rowLength, 0, 0, alignment );
d439 2
a440 2
    image2size = __glXImageSize( format, type, 0, h, 1, 1,
				 0, rowLength, 0, 0, alignment );
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d198 1
a198 1
	rowSize = (groupsPerRow + 7) >> 3;
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d2 28
a29 33
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: The application programming interfaces
** established by SGI in conjunction with the Original Code are The
** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
** Window System(R) (Version 1.3), released October 19, 1998. This software
** was created using the OpenGL(R) version 1.2.1 Sample Implementation
** published by SGI, but has not been independently verified as being
** compliant with the OpenGL(R) version 1.2.1 Specification.
**
*/
@

