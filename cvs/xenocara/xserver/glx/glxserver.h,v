head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	vcnjRBuLQw44cPHf;

1.8
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.14;	author matthieu;	state Exp;
branches;
next	;

1.6.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.7.2.1
date	2014.12.09.17.59.32;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.9
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _GLX_server_h_
#define _GLX_server_h_

/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/Xmd.h>
#include <misc.h>
#include <dixstruct.h>
#include <pixmapstr.h>
#include <gcstruct.h>
#include <extnsionst.h>
#include <resource.h>
#include <scrnintstr.h>

#include <GL/gl.h>
#include <GL/glext.h>
#include <GL/glxproto.h>

/*
** GLX resources.
*/
typedef XID GLXContextID;
typedef XID GLXPixmap;
typedef XID GLXDrawable;

typedef struct __GLXclientStateRec __GLXclientState;
typedef struct __GLXdrawable __GLXdrawable;
typedef struct __GLXcontext __GLXcontext;

#include "glxscreens.h"
#include "glxdrawable.h"
#include "glxcontext.h"

#ifndef True
#define True 1
#endif
#ifndef False
#define False 0
#endif

extern __GLXscreen *glxGetScreen(ScreenPtr pScreen);
extern __GLXclientState *glxGetClient(ClientPtr pClient);

/************************************************************************/

void GlxSetVisualConfigs(int nconfigs, void *configs, void **privates);

void __glXScreenInitVisuals(__GLXscreen * screen);

/*
** The last context used (from the server's persective) is cached.
*/
extern __GLXcontext *__glXForceCurrent(__GLXclientState *, GLXContextTag,
                                       int *);

int __glXError(int error);

/************************************************************************/

typedef struct __GLXprovider __GLXprovider;
struct __GLXprovider {
    __GLXscreen *(*screenProbe) (ScreenPtr pScreen);
    const char *name;
    __GLXprovider *next;
};
extern __GLXprovider __glXDRISWRastProvider;

void GlxPushProvider(__GLXprovider * provider);

enum {
    GLX_MINIMAL_VISUALS,
    GLX_TYPICAL_VISUALS,
    GLX_ALL_VISUALS
};

void __glXsetEnterLeaveServerFuncs(void (*enter) (GLboolean),
                                   void (*leave) (GLboolean));
void __glXenterServer(GLboolean rendering);
void __glXleaveServer(GLboolean rendering);

void glxSuspendClients(void);
void glxResumeClients(void);

typedef void (*glx_func_ptr)(void);
typedef glx_func_ptr (*glx_gpa_proc)(const char *);
void __glXsetGetProcAddress(glx_gpa_proc get_proc_address);
void *__glGetProcAddress(const char *);

void
__glXsendSwapEvent(__GLXdrawable *drawable, int type, CARD64 ust,
                   CARD64 msc, CARD32 sbc);

#if PRESENT
void
__glXregisterPresentCompleteNotify(void);
#endif

/*
** State kept per client.
*/
struct __GLXclientStateRec {
    /*
     ** Whether this structure is currently being used to support a client.
     */
    Bool inUse;

    /*
     ** Buffer for returned data.
     */
    GLbyte *returnBuf;
    GLint returnBufSize;

    /*
     ** Keep track of large rendering commands, which span multiple requests.
     */
    GLint largeCmdBytesSoFar;   /* bytes received so far        */
    GLint largeCmdBytesTotal;   /* total bytes expected         */
    GLint largeCmdRequestsSoFar;        /* requests received so far     */
    GLint largeCmdRequestsTotal;        /* total requests expected      */
    GLbyte *largeCmdBuf;
    GLint largeCmdBufSize;

    /* Back pointer to X client record */
    ClientPtr client;

    char *GLClientextensions;
};

/************************************************************************/

/*
** Dispatch tables.
*/
typedef void (*__GLXdispatchRenderProcPtr) (GLbyte *);
typedef int (*__GLXdispatchSingleProcPtr) (__GLXclientState *, GLbyte *);
typedef int (*__GLXdispatchVendorPrivProcPtr) (__GLXclientState *, GLbyte *);

/*
 * Dispatch for GLX commands.
 */
typedef int (*__GLXprocPtr) (__GLXclientState *, char *pc);

/*
 * Tables for computing the size of each rendering command.
 */
typedef int (*gl_proto_size_func) (const GLbyte *, Bool, int);

typedef struct {
    int bytes;
    gl_proto_size_func varsize;
} __GLXrenderSizeData;

/************************************************************************/

/*
** X resources.
*/
extern RESTYPE __glXContextRes;
extern RESTYPE __glXClientRes;
extern RESTYPE __glXPixmapRes;
extern RESTYPE __glXDrawableRes;

/************************************************************************/

/*
** Prototypes.
*/

extern char *__glXcombine_strings(const char *, const char *);

/*
** Routines for sending swapped replies.
*/

extern void __glXSwapMakeCurrentReply(ClientPtr client,
                                      xGLXMakeCurrentReply * reply);
extern void __glXSwapIsDirectReply(ClientPtr client, xGLXIsDirectReply * reply);
extern void __glXSwapQueryVersionReply(ClientPtr client,
                                       xGLXQueryVersionReply * reply);
extern void __glXSwapQueryContextInfoEXTReply(ClientPtr client,
                                              xGLXQueryContextInfoEXTReply *
                                              reply, int *buf);
extern void __glXSwapGetDrawableAttributesReply(ClientPtr client,
                                                xGLXGetDrawableAttributesReply *
                                                reply, CARD32 *buf);
extern void glxSwapQueryExtensionsStringReply(ClientPtr client,
                                              xGLXQueryExtensionsStringReply *
                                              reply, char *buf);
extern void glxSwapQueryServerStringReply(ClientPtr client,
                                          xGLXQueryServerStringReply * reply,
                                          char *buf);

/*
 * Routines for computing the size of variably-sized rendering commands.
 */

static _X_INLINE int
safe_add(int a, int b)
{
    if (a < 0 || b < 0)
        return -1;

    if (INT_MAX - a < b)
        return -1;

    return a + b;
}

static _X_INLINE int
safe_mul(int a, int b)
{
    if (a < 0 || b < 0)
        return -1;

    if (a == 0 || b == 0)
        return 0;

    if (a > INT_MAX / b)
        return -1;

    return a * b;
}

static _X_INLINE int
safe_pad(int a)
{
    int ret;

    if (a < 0)
        return -1;

    if ((ret = safe_add(a, 3)) < 0)
        return -1;

    return ret & (GLuint)~3;
}

extern int __glXTypeSize(GLenum enm);
extern int __glXImageSize(GLenum format, GLenum type,
                          GLenum target, GLsizei w, GLsizei h, GLsizei d,
                          GLint imageHeight, GLint rowLength, GLint skipImages,
                          GLint skipRows, GLint alignment);

extern unsigned glxMajorVersion;
extern unsigned glxMinorVersion;

extern int __glXEventBase;

#endif                          /* !__GLX_server_h__ */
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d180 1
a180 1
typedef int (*gl_proto_size_func) (const GLbyte *, Bool);
d230 41
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a48 1
#define GL_GLEXT_PROTOTYPES     /* we want prototypes */
a86 1
extern __GLXcontext *__glXLastContext;
@


1.7.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d182 1
a182 1
typedef int (*gl_proto_size_func) (const GLbyte *, Bool, int);
a231 41

static _X_INLINE int
safe_add(int a, int b)
{
    if (a < 0 || b < 0)
        return -1;

    if (INT_MAX - a < b)
        return -1;

    return a + b;
}

static _X_INLINE int
safe_mul(int a, int b)
{
    if (a < 0 || b < 0)
        return -1;

    if (a == 0 || b == 0)
        return 0;

    if (a > INT_MAX / b)
        return -1;

    return a * b;
}

static _X_INLINE int
safe_pad(int a)
{
    int ret;

    if (a < 0)
        return -1;

    if ((ret = safe_add(a, 3)) < 0)
        return -1;

    return ret & (GLuint)~3;
}
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d49 1
d51 1
d119 14
@


1.6.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d166 1
a166 1
typedef int (*gl_proto_size_func) (const GLbyte *, Bool, int);
a215 41

static _X_INLINE int
safe_add(int a, int b)
{
    if (a < 0 || b < 0)
        return -1;

    if (INT_MAX - a < b)
        return -1;

    return a + b;
}

static _X_INLINE int
safe_mul(int a, int b)
{
    if (a < 0 || b < 0)
        return -1;

    if (a == 0 || b == 0)
        return 0;

    if (a > INT_MAX / b)
        return -1;

    return a * b;
}

static _X_INLINE int
safe_pad(int a)
{
    int ret;

    if (a < 0)
        return -1;

    if ((ret = safe_add(a, 3)) < 0)
        return -1;

    return ret & (GLuint)~3;
}
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a48 1
#define GL_GLEXT_PROTOTYPES     /* we want prototypes */
a78 2
void GlxExtensionInit(void);

d100 1
a145 2
    int GLClientmajorVersion;
    int GLClientminorVersion;
@


1.4
log
@Update to xserver 1.11.2
@
text
@d49 1
a49 7
/*
** The X header misc.h defines these math functions.
*/
#undef abs
#undef fabs

#define GL_GLEXT_PROTOTYPES /* we want prototypes */
d82 1
a82 2
void GlxSetVisualConfigs(int nconfigs, 
                         void *configs, void **privates);
d84 1
a84 1
void __glXScreenInitVisuals(__GLXscreen *screen);
d90 2
a91 1
extern __GLXcontext *__glXForceCurrent(__GLXclientState*, GLXContextTag, int*);
d99 2
a100 2
    __GLXscreen *(*screenProbe)(ScreenPtr pScreen);
    const char    *name;
d104 1
a104 1
void GlxPushProvider(__GLXprovider *provider);
d112 2
a113 2
void __glXsetEnterLeaveServerFuncs(void (*enter)(GLboolean),
				   void (*leave)(GLboolean));
d125 2
a126 2
    ** Whether this structure is currently being used to support a client.
    */
d130 2
a131 2
    ** Buffer for returned data.
    */
d136 6
a141 6
    ** Keep track of large rendering commands, which span multiple requests.
    */
    GLint largeCmdBytesSoFar;		/* bytes received so far	*/
    GLint largeCmdBytesTotal;		/* total bytes expected		*/
    GLint largeCmdRequestsSoFar;	/* requests received so far	*/
    GLint largeCmdRequestsTotal;	/* total requests expected	*/
d158 3
a160 3
typedef void (*__GLXdispatchRenderProcPtr)(GLbyte *);
typedef int (*__GLXdispatchSingleProcPtr)(__GLXclientState *, GLbyte *);
typedef int (*__GLXdispatchVendorPrivProcPtr)(__GLXclientState *, GLbyte *);
d165 1
a165 1
typedef int (*__GLXprocPtr)(__GLXclientState *, char *pc);
d170 1
a170 1
typedef int (*gl_proto_size_func)(const GLbyte *, Bool);
d200 2
a201 3
				      xGLXMakeCurrentReply *reply);
extern void __glXSwapIsDirectReply(ClientPtr client,
				   xGLXIsDirectReply *reply);
d203 1
a203 1
				       xGLXQueryVersionReply *reply);
d205 2
a206 2
					      xGLXQueryContextInfoEXTReply *reply,
					      int *buf);
d208 2
a209 1
						xGLXGetDrawableAttributesReply *reply, CARD32 *buf);
d211 2
a212 1
				xGLXQueryExtensionsStringReply *reply, char *buf);
d214 2
a215 2
				xGLXQueryServerStringReply *reply, char *buf);

d223 3
a225 3
    GLenum target, GLsizei w, GLsizei h, GLsizei d,
    GLint imageHeight, GLint rowLength, GLint skipImages, GLint skipRows,
    GLint alignment);
d232 1
a232 1
#endif /* !__GLX_server_h__ */
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a98 2
extern ClientPtr __pGlxClient;

a100 8
/*
** Macros to set, unset, and retrieve the flag that says whether a context
** has unflushed commands.
*/
#define __GLX_NOTE_UNFLUSHED_CMDS(glxc) glxc->hasUnflushedCommands = GL_TRUE
#define __GLX_NOTE_FLUSHED_CMDS(glxc) glxc->hasUnflushedCommands = GL_FALSE
#define __GLX_HAS_UNFLUSHED_CMDS(glxc) (glxc->hasUnflushedCommands)

a149 7

    /*
    ** Keep a list of all the contexts that are current for this client's
    ** threads.
    */
    __GLXcontext **currentContexts;
    GLint numCurrentContexts;
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a57 1
#include <GL/glxint.h>
d59 8
a66 1
/* For glxscreens.h */
a73 4

#define GLX_SERVER_MAJOR_VERSION 1
#define GLX_SERVER_MINOR_VERSION 2

a80 9
/*
** GLX resources.
*/
typedef XID GLXContextID;
typedef XID GLXPixmap;
typedef XID GLXDrawable;

typedef struct __GLXclientStateRec __GLXclientState;

d89 1
a89 4
                         __GLXvisualConfig *configs, void **privates);

struct _glapi_table;
void GlxSetRenderTables (struct _glapi_table *table);
d248 5
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d9 28
a36 33
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: The application programming interfaces
** established by SGI in conjunction with the Original Code are The
** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
** Window System(R) (Version 1.3), released October 19, 1998. This software
** was created using the OpenGL(R) version 1.2.1 Sample Implementation
** published by SGI, but has not been independently verified as being
** compliant with the OpenGL(R) version 1.2.1 Specification.
**
*/
a136 2

void GlxSetVisualConfig(int config);
@

