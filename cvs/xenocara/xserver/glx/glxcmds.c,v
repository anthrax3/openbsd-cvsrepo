head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.6
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	s0SI41sEunLdyFfd;

1.13
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	7pAEtF6Y5EgemkuY;

1.12
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	vcnjRBuLQw44cPHf;

1.10
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.02.16.08.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	;

1.8.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.9.2.1
date	2014.12.09.17.59.32;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.14
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>
#include <assert.h>

#include "glxserver.h"
#include <GL/glxtokens.h>
#include <unpack.h>
#include <pixmapstr.h>
#include <windowstr.h>
#include "glxutil.h"
#include "glxext.h"
#include "indirect_dispatch.h"
#include "indirect_table.h"
#include "indirect_util.h"

static char GLXServerVendorName[] = "SGI";

_X_HIDDEN int
validGlxScreen(ClientPtr client, int screen, __GLXscreen ** pGlxScreen,
               int *err)
{
    /*
     ** Check if screen exists.
     */
    if (screen < 0 || screen >= screenInfo.numScreens) {
        client->errorValue = screen;
        *err = BadValue;
        return FALSE;
    }
    *pGlxScreen = glxGetScreen(screenInfo.screens[screen]);

    return TRUE;
}

_X_HIDDEN int
validGlxFBConfig(ClientPtr client, __GLXscreen * pGlxScreen, XID id,
                 __GLXconfig ** config, int *err)
{
    __GLXconfig *m;

    for (m = pGlxScreen->fbconfigs; m != NULL; m = m->next)
        if (m->fbconfigID == id) {
            *config = m;
            return TRUE;
        }

    client->errorValue = id;
    *err = __glXError(GLXBadFBConfig);

    return FALSE;
}

static int
validGlxVisual(ClientPtr client, __GLXscreen * pGlxScreen, XID id,
               __GLXconfig ** config, int *err)
{
    int i;

    for (i = 0; i < pGlxScreen->numVisuals; i++)
        if (pGlxScreen->visuals[i]->visualID == id) {
            *config = pGlxScreen->visuals[i];
            return TRUE;
        }

    client->errorValue = id;
    *err = BadValue;

    return FALSE;
}

static int
validGlxFBConfigForWindow(ClientPtr client, __GLXconfig * config,
                          DrawablePtr pDraw, int *err)
{
    ScreenPtr pScreen = pDraw->pScreen;
    VisualPtr pVisual = NULL;
    XID vid;
    int i;

    vid = wVisual((WindowPtr) pDraw);
    for (i = 0; i < pScreen->numVisuals; i++) {
        if (pScreen->visuals[i].vid == vid) {
            pVisual = &pScreen->visuals[i];
            break;
        }
    }

    /* FIXME: What exactly should we check here... */
    if (pVisual->class != glxConvertToXVisualType(config->visualType) ||
        !(config->drawableType & GLX_WINDOW_BIT)) {
        client->errorValue = pDraw->id;
        *err = BadMatch;
        return FALSE;
    }

    return TRUE;
}

_X_HIDDEN int
validGlxContext(ClientPtr client, XID id, int access_mode,
                __GLXcontext ** context, int *err)
{
    *err = dixLookupResourceByType((void **) context, id,
                                   __glXContextRes, client, access_mode);
    if (*err != Success || (*context)->idExists == GL_FALSE) {
        client->errorValue = id;
        if (*err == BadValue || *err == Success)
            *err = __glXError(GLXBadContext);
        return FALSE;
    }

    return TRUE;
}

static int
validGlxDrawable(ClientPtr client, XID id, int type, int access_mode,
                 __GLXdrawable ** drawable, int *err)
{
    int rc;

    rc = dixLookupResourceByType((void **) drawable, id,
                                 __glXDrawableRes, client, access_mode);
    if (rc != Success && rc != BadValue) {
        *err = rc;
        client->errorValue = id;
        return FALSE;
    }

    /* If the ID of the glx drawable we looked up doesn't match the id
     * we looked for, it's because we looked it up under the X
     * drawable ID (see DoCreateGLXDrawable). */
    if (rc == BadValue ||
        (*drawable)->drawId != id ||
        (type != GLX_DRAWABLE_ANY && type != (*drawable)->type)) {
        client->errorValue = id;
        switch (type) {
        case GLX_DRAWABLE_WINDOW:
            *err = __glXError(GLXBadWindow);
            return FALSE;
        case GLX_DRAWABLE_PIXMAP:
            *err = __glXError(GLXBadPixmap);
            return FALSE;
        case GLX_DRAWABLE_PBUFFER:
            *err = __glXError(GLXBadPbuffer);
            return FALSE;
        case GLX_DRAWABLE_ANY:
            *err = __glXError(GLXBadDrawable);
            return FALSE;
        }
    }

    return TRUE;
}

void
__glXContextDestroy(__GLXcontext * context)
{
    lastGLContext = NULL;
}

static void
__glXdirectContextDestroy(__GLXcontext * context)
{
    __glXContextDestroy(context);
    free(context);
}

static int
__glXdirectContextLoseCurrent(__GLXcontext * context)
{
    return GL_TRUE;
}

_X_HIDDEN __GLXcontext *
__glXdirectContextCreate(__GLXscreen * screen,
                         __GLXconfig * modes, __GLXcontext * shareContext)
{
    __GLXcontext *context;

    context = calloc(1, sizeof(__GLXcontext));
    if (context == NULL)
        return NULL;

    context->destroy = __glXdirectContextDestroy;
    context->loseCurrent = __glXdirectContextLoseCurrent;

    return context;
}

/**
 * Create a GL context with the given properties.  This routine is used
 * to implement \c glXCreateContext, \c glXCreateNewContext, and
 * \c glXCreateContextWithConfigSGIX.  This works becuase of the hack way
 * that GLXFBConfigs are implemented.  Basically, the FBConfigID is the
 * same as the VisualID.
 */

static int
DoCreateContext(__GLXclientState * cl, GLXContextID gcId,
                GLXContextID shareList, __GLXconfig * config,
                __GLXscreen * pGlxScreen, GLboolean isDirect)
{
    ClientPtr client = cl->client;
    __GLXcontext *glxc, *shareglxc;
    int err;

    LEGAL_NEW_RESOURCE(gcId, client);

    /*
     ** Find the display list space that we want to share.
     **
     ** NOTE: In a multithreaded X server, we would need to keep a reference
     ** count for each display list so that if one client detroyed a list that
     ** another client was using, the list would not really be freed until it
     ** was no longer in use.  Since this sample implementation has no support
     ** for multithreaded servers, we don't do this.
     */
    if (shareList == None) {
        shareglxc = 0;
    }
    else {
        if (!validGlxContext(client, shareList, DixReadAccess,
                             &shareglxc, &err))
            return err;

        /* Page 26 (page 32 of the PDF) of the GLX 1.4 spec says:
         *
         *     "The server context state for all sharing contexts must exist
         *     in a single address space or a BadMatch error is generated."
         *
         * If the share context is indirect, force the new context to also be
         * indirect.  If the shard context is direct but the new context
         * cannot be direct, generate BadMatch.
         */
        if (shareglxc->isDirect && !isDirect) {
            client->errorValue = shareList;
            return BadMatch;
        }
        else if (!shareglxc->isDirect) {
            /*
             ** Create an indirect context regardless of what the client asked
             ** for; this way we can share display list space with shareList.
             */
            isDirect = GL_FALSE;
        }
    }

    /*
     ** Allocate memory for the new context
     */
    if (!isDirect) {
        /* Only allow creating indirect GLX contexts if allowed by
         * server command line.  Indirect GLX is of limited use (since
         * it's only GL 1.4), it's slower than direct contexts, and
         * it's a massive attack surface for buffer overflow type
         * errors.
         */
        if (!enableIndirectGLX) {
            client->errorValue = isDirect;
            return BadValue;
        }

        /* Without any attributes, the only error that the driver should be
         * able to generate is BadAlloc.  As result, just drop the error
         * returned from the driver on the floor.
         */
        glxc = pGlxScreen->createContext(pGlxScreen, config, shareglxc,
                                         0, NULL, &err);
    }
    else
        glxc = __glXdirectContextCreate(pGlxScreen, config, shareglxc);
    if (!glxc) {
        return BadAlloc;
    }

    /* Initialize the GLXcontext structure.
     */
    glxc->pGlxScreen = pGlxScreen;
    glxc->config = config;
    glxc->id = gcId;
    glxc->share_id = shareList;
    glxc->idExists = GL_TRUE;
    glxc->currentClient = NULL;
    glxc->isDirect = isDirect;
    glxc->hasUnflushedCommands = GL_FALSE;
    glxc->renderMode = GL_RENDER;
    glxc->feedbackBuf = NULL;
    glxc->feedbackBufSize = 0;
    glxc->selectBuf = NULL;
    glxc->selectBufSize = 0;
    glxc->drawPriv = NULL;
    glxc->readPriv = NULL;

    /* The GLX_ARB_create_context_robustness spec says:
     *
     *     "The default value for GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB
     *     is GLX_NO_RESET_NOTIFICATION_ARB."
     *
     * Without using glXCreateContextAttribsARB, there is no way to specify a
     * non-default reset notification strategy.
     */
    glxc->resetNotificationStrategy = GLX_NO_RESET_NOTIFICATION_ARB;

#ifdef GLX_CONTEXT_RELEASE_BEHAVIOR_ARB
    /* The GLX_ARB_context_flush_control spec says:
     *
     *     "The default value [for GLX_CONTEXT_RELEASE_BEHAVIOR] is
     *     CONTEXT_RELEASE_BEHAVIOR_FLUSH, and may in some cases be changed
     *     using platform-specific context creation extensions."
     *
     * Without using glXCreateContextAttribsARB, there is no way to specify a
     * non-default release behavior.
     */
    glxc->releaseBehavior = GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB;
#endif

    /* Add the new context to the various global tables of GLX contexts.
     */
    if (!__glXAddContext(glxc)) {
        (*glxc->destroy) (glxc);
        client->errorValue = gcId;
        return BadAlloc;
    }

    return Success;
}

int
__glXDisp_CreateContext(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;
    __GLXconfig *config;
    __GLXscreen *pGlxScreen;
    int err;

    REQUEST_SIZE_MATCH(xGLXCreateContextReq);

    if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))
        return err;
    if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))
        return err;

    return DoCreateContext(cl, req->context, req->shareList,
                           config, pGlxScreen, req->isDirect);
}

int
__glXDisp_CreateNewContext(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreateNewContextReq *req = (xGLXCreateNewContextReq *) pc;
    __GLXconfig *config;
    __GLXscreen *pGlxScreen;
    int err;

    REQUEST_SIZE_MATCH(xGLXCreateNewContextReq);

    if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))
        return err;
    if (!validGlxFBConfig(cl->client, pGlxScreen, req->fbconfig, &config, &err))
        return err;

    return DoCreateContext(cl, req->context, req->shareList,
                           config, pGlxScreen, req->isDirect);
}

int
__glXDisp_CreateContextWithConfigSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreateContextWithConfigSGIXReq *req =
        (xGLXCreateContextWithConfigSGIXReq *) pc;
    __GLXconfig *config;
    __GLXscreen *pGlxScreen;
    int err;

    REQUEST_SIZE_MATCH(xGLXCreateContextWithConfigSGIXReq);

    if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))
        return err;
    if (!validGlxFBConfig(cl->client, pGlxScreen, req->fbconfig, &config, &err))
        return err;

    return DoCreateContext(cl, req->context, req->shareList,
                           config, pGlxScreen, req->isDirect);
}

int
__glXDisp_DestroyContext(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyContextReq *req = (xGLXDestroyContextReq *) pc;
    __GLXcontext *glxc;
    int err;

    REQUEST_SIZE_MATCH(xGLXDestroyContextReq);

    if (!validGlxContext(cl->client, req->context, DixDestroyAccess,
                         &glxc, &err))
        return err;

    glxc->idExists = GL_FALSE;
    if (!glxc->currentClient)
        FreeResourceByType(req->context, __glXContextRes, FALSE);

    return Success;
}

/*
 * This will return "deleted" contexts, ie, where idExists is GL_FALSE.
 * Contrast validGlxContext, which will not.  We're cheating here and
 * using the XID as the context tag, which is fine as long as we defer
 * actually destroying the context until it's no longer referenced, and
 * block clients from trying to MakeCurrent on contexts that are on the
 * way to destruction.  Notice that DoMakeCurrent calls validGlxContext
 * for new contexts but __glXLookupContextByTag for previous contexts.
 */
__GLXcontext *
__glXLookupContextByTag(__GLXclientState * cl, GLXContextTag tag)
{
    __GLXcontext *ret;

    if (dixLookupResourceByType((void **) &ret, tag, __glXContextRes,
                                cl->client, DixUseAccess) == Success)
        return ret;

    return NULL;
}

/*****************************************************************************/

static void
StopUsingContext(__GLXcontext * glxc)
{
    if (glxc) {
        glxc->currentClient = NULL;
        if (!glxc->idExists) {
            FreeResourceByType(glxc->id, __glXContextRes, FALSE);
        }
    }
}

static void
StartUsingContext(__GLXclientState * cl, __GLXcontext * glxc)
{
    glxc->currentClient = cl->client;
}

/**
 * This is a helper function to handle the legacy (pre GLX 1.3) cases
 * where passing an X window to glXMakeCurrent is valid.  Given a
 * resource ID, look up the GLX drawable if available, otherwise, make
 * sure it's an X window and create a GLX drawable one the fly.
 */
static __GLXdrawable *
__glXGetDrawable(__GLXcontext * glxc, GLXDrawable drawId, ClientPtr client,
                 int *error)
{
    DrawablePtr pDraw;
    __GLXdrawable *pGlxDraw;
    int rc;

    if (validGlxDrawable(client, drawId, GLX_DRAWABLE_ANY,
                         DixWriteAccess, &pGlxDraw, &rc)) {
        if (glxc != NULL && pGlxDraw->config != glxc->config) {
            client->errorValue = drawId;
            *error = BadMatch;
            return NULL;
        }

        return pGlxDraw;
    }

    /* No active context and an unknown drawable, bail. */
    if (glxc == NULL) {
        client->errorValue = drawId;
        *error = BadMatch;
        return NULL;
    }

    /* The drawId wasn't a GLX drawable.  Make sure it's a window and
     * create a GLXWindow for it.  Check that the drawable screen
     * matches the context screen and that the context fbconfig is
     * compatible with the window visual. */

    rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixGetAttrAccess);
    if (rc != Success || pDraw->type != DRAWABLE_WINDOW) {
        client->errorValue = drawId;
        *error = __glXError(GLXBadDrawable);
        return NULL;
    }

    if (pDraw->pScreen != glxc->pGlxScreen->pScreen) {
        client->errorValue = pDraw->pScreen->myNum;
        *error = BadMatch;
        return NULL;
    }

    if (!validGlxFBConfigForWindow(client, glxc->config, pDraw, error))
        return NULL;

    pGlxDraw = glxc->pGlxScreen->createDrawable(client, glxc->pGlxScreen,
                                                pDraw, drawId,
                                                GLX_DRAWABLE_WINDOW,
                                                drawId, glxc->config);
    if (!pGlxDraw) {
	*error = BadAlloc;
	return NULL;
    }

    /* since we are creating the drawablePrivate, drawId should be new */
    if (!AddResource(drawId, __glXDrawableRes, pGlxDraw)) {
        *error = BadAlloc;
        return NULL;
    }

    return pGlxDraw;
}

/*****************************************************************************/
/*
** Make an OpenGL context and drawable current.
*/

static int
DoMakeCurrent(__GLXclientState * cl,
              GLXDrawable drawId, GLXDrawable readId,
              GLXContextID contextId, GLXContextTag tag)
{
    ClientPtr client = cl->client;
    xGLXMakeCurrentReply reply;
    __GLXcontext *glxc, *prevglxc;
    __GLXdrawable *drawPriv = NULL;
    __GLXdrawable *readPriv = NULL;
    int error;
    GLuint mask;

    /*
     ** If one is None and the other isn't, it's a bad match.
     */

    mask = (drawId == None) ? (1 << 0) : 0;
    mask |= (readId == None) ? (1 << 1) : 0;
    mask |= (contextId == None) ? (1 << 2) : 0;

    if ((mask != 0x00) && (mask != 0x07)) {
        return BadMatch;
    }

    /*
     ** Lookup old context.  If we have one, it must be in a usable state.
     */
    if (tag != 0) {
        prevglxc = __glXLookupContextByTag(cl, tag);
        if (!prevglxc) {
            /*
             ** Tag for previous context is invalid.
             */
            return __glXError(GLXBadContextTag);
        }
        if (prevglxc->renderMode != GL_RENDER) {
            /* Oops.  Not in render mode render. */
            client->errorValue = prevglxc->id;
            return __glXError(GLXBadContextState);
        }
    }
    else {
        prevglxc = 0;
    }

    /*
     ** Lookup new context.  It must not be current for someone else.
     */
    if (contextId != None) {
        int status;

        if (!validGlxContext(client, contextId, DixUseAccess, &glxc, &error))
            return error;
        if ((glxc != prevglxc) && glxc->currentClient) {
            /* Context is current to somebody else */
            return BadAccess;
        }

        assert(drawId != None);
        assert(readId != None);

        drawPriv = __glXGetDrawable(glxc, drawId, client, &status);
        if (drawPriv == NULL)
            return status;

        readPriv = __glXGetDrawable(glxc, readId, client, &status);
        if (readPriv == NULL)
            return status;

    }
    else {
        /* Switching to no context.  Ignore new drawable. */
        glxc = 0;
        drawPriv = 0;
        readPriv = 0;
    }

    if (prevglxc) {
        /*
         ** Flush the previous context if needed.
         */
        Bool need_flush = GL_TRUE;
#ifdef GLX_CONTEXT_RELEASE_BEHAVIOR_ARB
        if (prevglxc->releaseBehavior == GLX_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB)
            need_flush = GL_FALSE;
#endif
        if (prevglxc->hasUnflushedCommands && need_flush) {
            if (__glXForceCurrent(cl, tag, (int *) &error)) {
                glFlush();
                prevglxc->hasUnflushedCommands = GL_FALSE;
            }
            else {
                return error;
            }
        }

        /*
         ** Make the previous context not current.
         */
        if (!(*prevglxc->loseCurrent) (prevglxc)) {
            return __glXError(GLXBadContext);
        }
        lastGLContext = NULL;
        if (!prevglxc->isDirect) {
            prevglxc->drawPriv = NULL;
            prevglxc->readPriv = NULL;
        }
    }

    if ((glxc != 0) && !glxc->isDirect) {

        glxc->drawPriv = drawPriv;
        glxc->readPriv = readPriv;

        /* make the context current */
        lastGLContext = glxc;
        if (!(*glxc->makeCurrent) (glxc)) {
            lastGLContext = NULL;
            glxc->drawPriv = NULL;
            glxc->readPriv = NULL;
            return __glXError(GLXBadContext);
        }

        glxc->currentClient = client;
    }

    StopUsingContext(prevglxc);

    reply = (xGLXMakeCurrentReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .contextTag = 0
    };

    if (glxc) {
        StartUsingContext(cl, glxc);
        reply.contextTag = glxc->id;
    }

    if (client->swapped) {
        __glXSwapMakeCurrentReply(client, &reply);
    }
    else {
        WriteToClient(client, sz_xGLXMakeCurrentReply, &reply);
    }
    return Success;
}

int
__glXDisp_MakeCurrent(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXMakeCurrentReq *req = (xGLXMakeCurrentReq *) pc;

    REQUEST_SIZE_MATCH(xGLXMakeCurrentReq);

    return DoMakeCurrent(cl, req->drawable, req->drawable,
                         req->context, req->oldContextTag);
}

int
__glXDisp_MakeContextCurrent(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXMakeContextCurrentReq *req = (xGLXMakeContextCurrentReq *) pc;

    REQUEST_SIZE_MATCH(xGLXMakeContextCurrentReq);

    return DoMakeCurrent(cl, req->drawable, req->readdrawable,
                         req->context, req->oldContextTag);
}

int
__glXDisp_MakeCurrentReadSGI(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXMakeCurrentReadSGIReq *req = (xGLXMakeCurrentReadSGIReq *) pc;

    REQUEST_SIZE_MATCH(xGLXMakeCurrentReadSGIReq);

    return DoMakeCurrent(cl, req->drawable, req->readable,
                         req->context, req->oldContextTag);
}

int
__glXDisp_IsDirect(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXIsDirectReq *req = (xGLXIsDirectReq *) pc;
    xGLXIsDirectReply reply;
    __GLXcontext *glxc;
    int err;

    REQUEST_SIZE_MATCH(xGLXIsDirectReq);

    if (!validGlxContext(cl->client, req->context, DixReadAccess, &glxc, &err))
        return err;

    reply = (xGLXIsDirectReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .isDirect = glxc->isDirect
    };

    if (client->swapped) {
        __glXSwapIsDirectReply(client, &reply);
    }
    else {
        WriteToClient(client, sz_xGLXIsDirectReply, &reply);
    }

    return Success;
}

int
__glXDisp_QueryVersion(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXQueryVersionReq *req = (xGLXQueryVersionReq *) pc;
    xGLXQueryVersionReply reply;
    GLuint major, minor;

    REQUEST_SIZE_MATCH(xGLXQueryVersionReq);

    major = req->majorVersion;
    minor = req->minorVersion;
    (void) major;
    (void) minor;

    /*
     ** Server should take into consideration the version numbers sent by the
     ** client if it wants to work with older clients; however, in this
     ** implementation the server just returns its version number.
     */
    reply = (xGLXQueryVersionReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .majorVersion = glxMajorVersion,
        .minorVersion = glxMinorVersion
    };

    if (client->swapped) {
        __glXSwapQueryVersionReply(client, &reply);
    }
    else {
        WriteToClient(client, sz_xGLXQueryVersionReply, &reply);
    }
    return Success;
}

int
__glXDisp_WaitGL(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXWaitGLReq *req = (xGLXWaitGLReq *) pc;
    GLXContextTag tag;
    __GLXcontext *glxc = NULL;
    int error;

    REQUEST_SIZE_MATCH(xGLXWaitGLReq);

    tag = req->contextTag;
    if (tag) {
        glxc = __glXLookupContextByTag(cl, tag);
        if (!glxc)
            return __glXError(GLXBadContextTag);

        if (!__glXForceCurrent(cl, req->contextTag, &error))
            return error;

        glFinish();
    }

    if (glxc && glxc->drawPriv->waitGL)
        (*glxc->drawPriv->waitGL) (glxc->drawPriv);

    return Success;
}

int
__glXDisp_WaitX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXWaitXReq *req = (xGLXWaitXReq *) pc;
    GLXContextTag tag;
    __GLXcontext *glxc = NULL;
    int error;

    REQUEST_SIZE_MATCH(xGLXWaitXReq);

    tag = req->contextTag;
    if (tag) {
        glxc = __glXLookupContextByTag(cl, tag);
        if (!glxc)
            return __glXError(GLXBadContextTag);

        if (!__glXForceCurrent(cl, req->contextTag, &error))
            return error;
    }

    if (glxc && glxc->drawPriv->waitX)
        (*glxc->drawPriv->waitX) (glxc->drawPriv);

    return Success;
}

int
__glXDisp_CopyContext(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCopyContextReq *req = (xGLXCopyContextReq *) pc;
    GLXContextID source;
    GLXContextID dest;
    GLXContextTag tag;
    unsigned long mask;
    __GLXcontext *src, *dst;
    int error;

    REQUEST_SIZE_MATCH(xGLXCopyContextReq);

    source = req->source;
    dest = req->dest;
    tag = req->contextTag;
    mask = req->mask;
    if (!validGlxContext(cl->client, source, DixReadAccess, &src, &error))
        return error;
    if (!validGlxContext(cl->client, dest, DixWriteAccess, &dst, &error))
        return error;

    /*
     ** They must be in the same address space, and same screen.
     ** NOTE: no support for direct rendering contexts here.
     */
    if (src->isDirect || dst->isDirect || (src->pGlxScreen != dst->pGlxScreen)) {
        client->errorValue = source;
        return BadMatch;
    }

    /*
     ** The destination context must not be current for any client.
     */
    if (dst->currentClient) {
        client->errorValue = dest;
        return BadAccess;
    }

    if (tag) {
        __GLXcontext *tagcx = __glXLookupContextByTag(cl, tag);

        if (!tagcx) {
            return __glXError(GLXBadContextTag);
        }
        if (tagcx != src) {
            /*
             ** This would be caused by a faulty implementation of the client
             ** library.
             */
            return BadMatch;
        }
        /*
         ** In this case, glXCopyContext is in both GL and X streams, in terms
         ** of sequentiality.
         */
        if (__glXForceCurrent(cl, tag, &error)) {
            /*
             ** Do whatever is needed to make sure that all preceding requests
             ** in both streams are completed before the copy is executed.
             */
            glFinish();
            tagcx->hasUnflushedCommands = GL_FALSE;
        }
        else {
            return error;
        }
    }
    /*
     ** Issue copy.  The only reason for failure is a bad mask.
     */
    if (!(*dst->copy) (dst, src, mask)) {
        client->errorValue = mask;
        return BadValue;
    }
    return Success;
}

enum {
    GLX_VIS_CONFIG_UNPAIRED = 18,
    GLX_VIS_CONFIG_PAIRED = 22
};

enum {
    GLX_VIS_CONFIG_TOTAL = GLX_VIS_CONFIG_UNPAIRED + GLX_VIS_CONFIG_PAIRED
};

int
__glXDisp_GetVisualConfigs(__GLXclientState * cl, GLbyte * pc)
{
    xGLXGetVisualConfigsReq *req = (xGLXGetVisualConfigsReq *) pc;
    ClientPtr client = cl->client;
    xGLXGetVisualConfigsReply reply;
    __GLXscreen *pGlxScreen;
    __GLXconfig *modes;
    CARD32 buf[GLX_VIS_CONFIG_TOTAL];
    int p, i, err;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    REQUEST_SIZE_MATCH(xGLXGetVisualConfigsReq);

    if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))
        return err;

    reply = (xGLXGetVisualConfigsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = (pGlxScreen->numVisuals *
                   __GLX_SIZE_CARD32 * GLX_VIS_CONFIG_TOTAL) >> 2,
        .numVisuals = pGlxScreen->numVisuals,
        .numProps = GLX_VIS_CONFIG_TOTAL
    };

    if (client->swapped) {
        __GLX_SWAP_SHORT(&reply.sequenceNumber);
        __GLX_SWAP_INT(&reply.length);
        __GLX_SWAP_INT(&reply.numVisuals);
        __GLX_SWAP_INT(&reply.numProps);
    }

    WriteToClient(client, sz_xGLXGetVisualConfigsReply, &reply);

    for (i = 0; i < pGlxScreen->numVisuals; i++) {
        modes = pGlxScreen->visuals[i];

        p = 0;
        buf[p++] = modes->visualID;
        buf[p++] = glxConvertToXVisualType(modes->visualType);
        buf[p++] = (modes->renderType & GLX_RGBA_BIT) ? GL_TRUE : GL_FALSE;

        buf[p++] = modes->redBits;
        buf[p++] = modes->greenBits;
        buf[p++] = modes->blueBits;
        buf[p++] = modes->alphaBits;
        buf[p++] = modes->accumRedBits;
        buf[p++] = modes->accumGreenBits;
        buf[p++] = modes->accumBlueBits;
        buf[p++] = modes->accumAlphaBits;

        buf[p++] = modes->doubleBufferMode;
        buf[p++] = modes->stereoMode;

        buf[p++] = modes->rgbBits;
        buf[p++] = modes->depthBits;
        buf[p++] = modes->stencilBits;
        buf[p++] = modes->numAuxBuffers;
        buf[p++] = modes->level;

        assert(p == GLX_VIS_CONFIG_UNPAIRED);
        /*
         ** Add token/value pairs for extensions.
         */
        buf[p++] = GLX_VISUAL_CAVEAT_EXT;
        buf[p++] = modes->visualRating;
        buf[p++] = GLX_TRANSPARENT_TYPE;
        buf[p++] = modes->transparentPixel;
        buf[p++] = GLX_TRANSPARENT_RED_VALUE;
        buf[p++] = modes->transparentRed;
        buf[p++] = GLX_TRANSPARENT_GREEN_VALUE;
        buf[p++] = modes->transparentGreen;
        buf[p++] = GLX_TRANSPARENT_BLUE_VALUE;
        buf[p++] = modes->transparentBlue;
        buf[p++] = GLX_TRANSPARENT_ALPHA_VALUE;
        buf[p++] = modes->transparentAlpha;
        buf[p++] = GLX_TRANSPARENT_INDEX_VALUE;
        buf[p++] = modes->transparentIndex;
        buf[p++] = GLX_SAMPLES_SGIS;
        buf[p++] = modes->samples;
        buf[p++] = GLX_SAMPLE_BUFFERS_SGIS;
        buf[p++] = modes->sampleBuffers;
        /* Add attribute only if its value is not default. */
        if (modes->sRGBCapable != GL_FALSE) {
            buf[p++] = GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT;
            buf[p++] = modes->sRGBCapable;
        }
        /* Don't add visualSelectGroup (GLX_VISUAL_SELECT_GROUP_SGIX)?
         * Pad the remaining place with zeroes, so that attributes count is constant. */
        while (p < GLX_VIS_CONFIG_TOTAL) {
            buf[p++] = 0;
            buf[p++] = 0;
        }

        assert(p == GLX_VIS_CONFIG_TOTAL);
        if (client->swapped) {
            __GLX_SWAP_INT_ARRAY(buf, p);
        }
        WriteToClient(client, __GLX_SIZE_CARD32 * p, buf);
    }
    return Success;
}

#define __GLX_TOTAL_FBCONFIG_ATTRIBS (44)
#define __GLX_FBCONFIG_ATTRIBS_LENGTH (__GLX_TOTAL_FBCONFIG_ATTRIBS * 2)
/**
 * Send the set of GLXFBConfigs to the client.  There is not currently
 * and interface into the driver on the server-side to get GLXFBConfigs,
 * so we "invent" some based on the \c __GLXvisualConfig structures that
 * the driver does supply.
 *
 * The reply format for both \c glXGetFBConfigs and \c glXGetFBConfigsSGIX
 * is the same, so this routine pulls double duty.
 */

static int
DoGetFBConfigs(__GLXclientState * cl, unsigned screen)
{
    ClientPtr client = cl->client;
    xGLXGetFBConfigsReply reply;
    __GLXscreen *pGlxScreen;
    CARD32 buf[__GLX_FBCONFIG_ATTRIBS_LENGTH];
    int p, err;
    __GLXconfig *modes;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    if (!validGlxScreen(cl->client, screen, &pGlxScreen, &err))
        return err;

    reply = (xGLXGetFBConfigsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = __GLX_FBCONFIG_ATTRIBS_LENGTH * pGlxScreen->numFBConfigs,
        .numFBConfigs = pGlxScreen->numFBConfigs,
        .numAttribs = __GLX_TOTAL_FBCONFIG_ATTRIBS
    };

    if (client->swapped) {
        __GLX_SWAP_SHORT(&reply.sequenceNumber);
        __GLX_SWAP_INT(&reply.length);
        __GLX_SWAP_INT(&reply.numFBConfigs);
        __GLX_SWAP_INT(&reply.numAttribs);
    }

    WriteToClient(client, sz_xGLXGetFBConfigsReply, &reply);

    for (modes = pGlxScreen->fbconfigs; modes != NULL; modes = modes->next) {
        p = 0;

#define WRITE_PAIR(tag,value) \
    do { buf[p++] = tag ; buf[p++] = value ; } while( 0 )

        WRITE_PAIR(GLX_VISUAL_ID, modes->visualID);
        WRITE_PAIR(GLX_FBCONFIG_ID, modes->fbconfigID);
        WRITE_PAIR(GLX_X_RENDERABLE, GL_TRUE);

        WRITE_PAIR(GLX_RGBA,
                   (modes->renderType & GLX_RGBA_BIT) ? GL_TRUE : GL_FALSE);
        WRITE_PAIR(GLX_RENDER_TYPE, modes->renderType);
        WRITE_PAIR(GLX_DOUBLEBUFFER, modes->doubleBufferMode);
        WRITE_PAIR(GLX_STEREO, modes->stereoMode);

        WRITE_PAIR(GLX_BUFFER_SIZE, modes->rgbBits);
        WRITE_PAIR(GLX_LEVEL, modes->level);
        WRITE_PAIR(GLX_AUX_BUFFERS, modes->numAuxBuffers);
        WRITE_PAIR(GLX_RED_SIZE, modes->redBits);
        WRITE_PAIR(GLX_GREEN_SIZE, modes->greenBits);
        WRITE_PAIR(GLX_BLUE_SIZE, modes->blueBits);
        WRITE_PAIR(GLX_ALPHA_SIZE, modes->alphaBits);
        WRITE_PAIR(GLX_ACCUM_RED_SIZE, modes->accumRedBits);
        WRITE_PAIR(GLX_ACCUM_GREEN_SIZE, modes->accumGreenBits);
        WRITE_PAIR(GLX_ACCUM_BLUE_SIZE, modes->accumBlueBits);
        WRITE_PAIR(GLX_ACCUM_ALPHA_SIZE, modes->accumAlphaBits);
        WRITE_PAIR(GLX_DEPTH_SIZE, modes->depthBits);
        WRITE_PAIR(GLX_STENCIL_SIZE, modes->stencilBits);
        WRITE_PAIR(GLX_X_VISUAL_TYPE, modes->visualType);
        WRITE_PAIR(GLX_CONFIG_CAVEAT, modes->visualRating);
        WRITE_PAIR(GLX_TRANSPARENT_TYPE, modes->transparentPixel);
        WRITE_PAIR(GLX_TRANSPARENT_RED_VALUE, modes->transparentRed);
        WRITE_PAIR(GLX_TRANSPARENT_GREEN_VALUE, modes->transparentGreen);
        WRITE_PAIR(GLX_TRANSPARENT_BLUE_VALUE, modes->transparentBlue);
        WRITE_PAIR(GLX_TRANSPARENT_ALPHA_VALUE, modes->transparentAlpha);
        WRITE_PAIR(GLX_TRANSPARENT_INDEX_VALUE, modes->transparentIndex);
        WRITE_PAIR(GLX_SWAP_METHOD_OML, modes->swapMethod);
        WRITE_PAIR(GLX_SAMPLES_SGIS, modes->samples);
        WRITE_PAIR(GLX_SAMPLE_BUFFERS_SGIS, modes->sampleBuffers);
        WRITE_PAIR(GLX_VISUAL_SELECT_GROUP_SGIX, modes->visualSelectGroup);
        WRITE_PAIR(GLX_DRAWABLE_TYPE, modes->drawableType);
        WRITE_PAIR(GLX_BIND_TO_TEXTURE_RGB_EXT, modes->bindToTextureRgb);
        WRITE_PAIR(GLX_BIND_TO_TEXTURE_RGBA_EXT, modes->bindToTextureRgba);
        WRITE_PAIR(GLX_BIND_TO_MIPMAP_TEXTURE_EXT, modes->bindToMipmapTexture);
        WRITE_PAIR(GLX_BIND_TO_TEXTURE_TARGETS_EXT,
                   modes->bindToTextureTargets);
	/* can't report honestly until mesa is fixed */
	WRITE_PAIR(GLX_Y_INVERTED_EXT, GLX_DONT_CARE);
	if (modes->drawableType & GLX_PBUFFER_BIT) {
	    WRITE_PAIR(GLX_MAX_PBUFFER_WIDTH, modes->maxPbufferWidth);
	    WRITE_PAIR(GLX_MAX_PBUFFER_HEIGHT, modes->maxPbufferHeight);
	    WRITE_PAIR(GLX_MAX_PBUFFER_PIXELS, modes->maxPbufferPixels);
	    WRITE_PAIR(GLX_OPTIMAL_PBUFFER_WIDTH_SGIX,
		       modes->optimalPbufferWidth);
	    WRITE_PAIR(GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX,
		       modes->optimalPbufferHeight);
	}
        /* Add attribute only if its value is not default. */
        if (modes->sRGBCapable != GL_FALSE) {
            WRITE_PAIR(GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT, modes->sRGBCapable);
        }
        /* Pad the remaining place with zeroes, so that attributes count is constant. */
        while (p < __GLX_FBCONFIG_ATTRIBS_LENGTH) {
            WRITE_PAIR(0, 0);
        }
        assert(p == __GLX_FBCONFIG_ATTRIBS_LENGTH);

        if (client->swapped) {
            __GLX_SWAP_INT_ARRAY(buf, __GLX_FBCONFIG_ATTRIBS_LENGTH);
        }
        WriteToClient(client, __GLX_SIZE_CARD32 * __GLX_FBCONFIG_ATTRIBS_LENGTH,
                      (char *) buf);
    }
    return Success;
}

int
__glXDisp_GetFBConfigs(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXGetFBConfigsReq *req = (xGLXGetFBConfigsReq *) pc;

    REQUEST_SIZE_MATCH(xGLXGetFBConfigsReq);
    return DoGetFBConfigs(cl, req->screen);
}

int
__glXDisp_GetFBConfigsSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXGetFBConfigsSGIXReq *req = (xGLXGetFBConfigsSGIXReq *) pc;

    /* work around mesa bug, don't use REQUEST_SIZE_MATCH */
    REQUEST_AT_LEAST_SIZE(xGLXGetFBConfigsSGIXReq);
    return DoGetFBConfigs(cl, req->screen);
}

GLboolean
__glXDrawableInit(__GLXdrawable * drawable,
                  __GLXscreen * screen, DrawablePtr pDraw, int type,
                  XID drawId, __GLXconfig * config)
{
    drawable->pDraw = pDraw;
    drawable->type = type;
    drawable->drawId = drawId;
    drawable->config = config;
    drawable->eventMask = 0;

    return GL_TRUE;
}

void
__glXDrawableRelease(__GLXdrawable * drawable)
{
}

static int
DoCreateGLXDrawable(ClientPtr client, __GLXscreen * pGlxScreen,
                    __GLXconfig * config, DrawablePtr pDraw, XID drawableId,
                    XID glxDrawableId, int type)
{
    __GLXdrawable *pGlxDraw;

    if (pGlxScreen->pScreen != pDraw->pScreen)
        return BadMatch;

    pGlxDraw = pGlxScreen->createDrawable(client, pGlxScreen, pDraw,
                                          drawableId, type,
                                          glxDrawableId, config);
    if (pGlxDraw == NULL)
        return BadAlloc;

    if (!AddResource(glxDrawableId, __glXDrawableRes, pGlxDraw))
        return BadAlloc;

    /*
     * Windows aren't refcounted, so track both the X and the GLX window
     * so we get called regardless of destruction order.
     */
    if (drawableId != glxDrawableId && type == GLX_DRAWABLE_WINDOW &&
        !AddResource(pDraw->id, __glXDrawableRes, pGlxDraw))
        return BadAlloc;

    return Success;
}

static int
DoCreateGLXPixmap(ClientPtr client, __GLXscreen * pGlxScreen,
                  __GLXconfig * config, XID drawableId, XID glxDrawableId)
{
    DrawablePtr pDraw;
    int err;

    LEGAL_NEW_RESOURCE(glxDrawableId, client);

    err = dixLookupDrawable(&pDraw, drawableId, client, 0, DixAddAccess);
    if (err != Success) {
        client->errorValue = drawableId;
        return err;
    }
    if (pDraw->type != DRAWABLE_PIXMAP) {
        client->errorValue = drawableId;
        return BadPixmap;
    }

    err = DoCreateGLXDrawable(client, pGlxScreen, config, pDraw, drawableId,
                              glxDrawableId, GLX_DRAWABLE_PIXMAP);

    if (err == Success)
        ((PixmapPtr) pDraw)->refcnt++;

    return err;
}

static void
determineTextureTarget(ClientPtr client, XID glxDrawableID,
                       CARD32 *attribs, CARD32 numAttribs)
{
    GLenum target = 0;
    GLenum format = 0;
    int i, err;
    __GLXdrawable *pGlxDraw;

    if (!validGlxDrawable(client, glxDrawableID, GLX_DRAWABLE_PIXMAP,
                          DixWriteAccess, &pGlxDraw, &err))
        /* We just added it in CreatePixmap, so we should never get here. */
        return;

    for (i = 0; i < numAttribs; i++) {
        if (attribs[2 * i] == GLX_TEXTURE_TARGET_EXT) {
            switch (attribs[2 * i + 1]) {
            case GLX_TEXTURE_2D_EXT:
                target = GL_TEXTURE_2D;
                break;
            case GLX_TEXTURE_RECTANGLE_EXT:
                target = GL_TEXTURE_RECTANGLE_ARB;
                break;
            }
        }

        if (attribs[2 * i] == GLX_TEXTURE_FORMAT_EXT)
            format = attribs[2 * i + 1];
    }

    if (!target) {
        int w = pGlxDraw->pDraw->width, h = pGlxDraw->pDraw->height;

        if (h & (h - 1) || w & (w - 1))
            target = GL_TEXTURE_RECTANGLE_ARB;
        else
            target = GL_TEXTURE_2D;
    }

    pGlxDraw->target = target;
    pGlxDraw->format = format;
}

int
__glXDisp_CreateGLXPixmap(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreateGLXPixmapReq *req = (xGLXCreateGLXPixmapReq *) pc;
    __GLXconfig *config;
    __GLXscreen *pGlxScreen;
    int err;

    REQUEST_SIZE_MATCH(xGLXCreateGLXPixmapReq);

    if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))
        return err;
    if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))
        return err;

    return DoCreateGLXPixmap(cl->client, pGlxScreen, config,
                             req->pixmap, req->glxpixmap);
}

int
__glXDisp_CreatePixmap(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreatePixmapReq *req = (xGLXCreatePixmapReq *) pc;
    __GLXconfig *config;
    __GLXscreen *pGlxScreen;
    int err;

    REQUEST_AT_LEAST_SIZE(xGLXCreatePixmapReq);
    if (req->numAttribs > (UINT32_MAX >> 3)) {
        client->errorValue = req->numAttribs;
        return BadValue;
    }
    REQUEST_FIXED_SIZE(xGLXCreatePixmapReq, req->numAttribs << 3);

    if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))
        return err;
    if (!validGlxFBConfig(cl->client, pGlxScreen, req->fbconfig, &config, &err))
        return err;

    err = DoCreateGLXPixmap(cl->client, pGlxScreen, config,
                            req->pixmap, req->glxpixmap);
    if (err != Success)
        return err;

    determineTextureTarget(cl->client, req->glxpixmap,
                           (CARD32 *) (req + 1), req->numAttribs);

    return Success;
}

int
__glXDisp_CreateGLXPixmapWithConfigSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreateGLXPixmapWithConfigSGIXReq *req =
        (xGLXCreateGLXPixmapWithConfigSGIXReq *) pc;
    __GLXconfig *config;
    __GLXscreen *pGlxScreen;
    int err;

    REQUEST_SIZE_MATCH(xGLXCreateGLXPixmapWithConfigSGIXReq);

    if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))
        return err;
    if (!validGlxFBConfig(cl->client, pGlxScreen, req->fbconfig, &config, &err))
        return err;

    return DoCreateGLXPixmap(cl->client, pGlxScreen,
                             config, req->pixmap, req->glxpixmap);
}

static int
DoDestroyDrawable(__GLXclientState * cl, XID glxdrawable, int type)
{
    __GLXdrawable *pGlxDraw;
    int err;

    if (!validGlxDrawable(cl->client, glxdrawable, type,
                          DixDestroyAccess, &pGlxDraw, &err))
        return err;

    FreeResource(glxdrawable, FALSE);

    return Success;
}

int
__glXDisp_DestroyGLXPixmap(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyGLXPixmapReq *req = (xGLXDestroyGLXPixmapReq *) pc;

    REQUEST_SIZE_MATCH(xGLXDestroyGLXPixmapReq);

    return DoDestroyDrawable(cl, req->glxpixmap, GLX_DRAWABLE_PIXMAP);
}

int
__glXDisp_DestroyPixmap(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyPixmapReq *req = (xGLXDestroyPixmapReq *) pc;

    /* should be REQUEST_SIZE_MATCH, but mesa's glXDestroyPixmap used to set
     * length to 3 instead of 2 */
    REQUEST_AT_LEAST_SIZE(xGLXDestroyPixmapReq);

    return DoDestroyDrawable(cl, req->glxpixmap, GLX_DRAWABLE_PIXMAP);
}

static int
DoCreatePbuffer(ClientPtr client, int screenNum, XID fbconfigId,
                int width, int height, XID glxDrawableId)
{
    __GLXconfig *config;
    __GLXscreen *pGlxScreen;
    PixmapPtr pPixmap;
    int err;

    LEGAL_NEW_RESOURCE(glxDrawableId, client);

    if (!validGlxScreen(client, screenNum, &pGlxScreen, &err))
        return err;
    if (!validGlxFBConfig(client, pGlxScreen, fbconfigId, &config, &err))
        return err;

    __glXenterServer(GL_FALSE);
    pPixmap = (*pGlxScreen->pScreen->CreatePixmap) (pGlxScreen->pScreen,
                                                    width, height,
                                                    config->rgbBits, 0);
    __glXleaveServer(GL_FALSE);
    if (!pPixmap)
        return BadAlloc;

    /* Assign the pixmap the same id as the pbuffer and add it as a
     * resource so it and the DRI2 drawable will be reclaimed when the
     * pbuffer is destroyed. */
    pPixmap->drawable.id = glxDrawableId;
    if (!AddResource(pPixmap->drawable.id, RT_PIXMAP, pPixmap))
        return BadAlloc;

    return DoCreateGLXDrawable(client, pGlxScreen, config, &pPixmap->drawable,
                               glxDrawableId, glxDrawableId,
                               GLX_DRAWABLE_PBUFFER);
}

int
__glXDisp_CreatePbuffer(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreatePbufferReq *req = (xGLXCreatePbufferReq *) pc;
    CARD32 *attrs;
    int width, height, i;

    REQUEST_AT_LEAST_SIZE(xGLXCreatePbufferReq);
    if (req->numAttribs > (UINT32_MAX >> 3)) {
        client->errorValue = req->numAttribs;
        return BadValue;
    }
    REQUEST_FIXED_SIZE(xGLXCreatePbufferReq, req->numAttribs << 3);

    attrs = (CARD32 *) (req + 1);
    width = 0;
    height = 0;

    for (i = 0; i < req->numAttribs; i++) {
        switch (attrs[i * 2]) {
        case GLX_PBUFFER_WIDTH:
            width = attrs[i * 2 + 1];
            break;
        case GLX_PBUFFER_HEIGHT:
            height = attrs[i * 2 + 1];
            break;
        case GLX_LARGEST_PBUFFER:
            /* FIXME: huh... */
            break;
        }
    }

    return DoCreatePbuffer(cl->client, req->screen, req->fbconfig,
                           width, height, req->pbuffer);
}

int
__glXDisp_CreateGLXPbufferSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreateGLXPbufferSGIXReq *req = (xGLXCreateGLXPbufferSGIXReq *) pc;

    REQUEST_AT_LEAST_SIZE(xGLXCreateGLXPbufferSGIXReq);

    /*
     * We should really handle attributes correctly, but this extension
     * is so rare I have difficulty caring.
     */
    return DoCreatePbuffer(cl->client, req->screen, req->fbconfig,
                           req->width, req->height, req->pbuffer);
}

int
__glXDisp_DestroyPbuffer(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyPbufferReq *req = (xGLXDestroyPbufferReq *) pc;

    REQUEST_SIZE_MATCH(xGLXDestroyPbufferReq);

    return DoDestroyDrawable(cl, req->pbuffer, GLX_DRAWABLE_PBUFFER);
}

int
__glXDisp_DestroyGLXPbufferSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyGLXPbufferSGIXReq *req = (xGLXDestroyGLXPbufferSGIXReq *) pc;

    REQUEST_SIZE_MATCH(xGLXDestroyGLXPbufferSGIXReq);

    return DoDestroyDrawable(cl, req->pbuffer, GLX_DRAWABLE_PBUFFER);
}

static int
DoChangeDrawableAttributes(ClientPtr client, XID glxdrawable,
                           int numAttribs, CARD32 *attribs)
{
    __GLXdrawable *pGlxDraw;
    int i, err;

    if (!validGlxDrawable(client, glxdrawable, GLX_DRAWABLE_ANY,
                          DixSetAttrAccess, &pGlxDraw, &err))
        return err;

    for (i = 0; i < numAttribs; i++) {
        switch (attribs[i * 2]) {
        case GLX_EVENT_MASK:
            /* All we do is to record the event mask so we can send it
             * back when queried.  We never actually clobber the
             * pbuffers, so we never need to send out the event. */
            pGlxDraw->eventMask = attribs[i * 2 + 1];
            break;
        }
    }

    return Success;
}

int
__glXDisp_ChangeDrawableAttributes(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXChangeDrawableAttributesReq *req =
        (xGLXChangeDrawableAttributesReq *) pc;

    REQUEST_AT_LEAST_SIZE(xGLXChangeDrawableAttributesReq);
    if (req->numAttribs > (UINT32_MAX >> 3)) {
        client->errorValue = req->numAttribs;
        return BadValue;
    }
#if 0
    /* mesa sends an additional 8 bytes */
    REQUEST_FIXED_SIZE(xGLXChangeDrawableAttributesReq, req->numAttribs << 3);
#else
    if (((sizeof(xGLXChangeDrawableAttributesReq) +
          (req->numAttribs << 3)) >> 2) < client->req_len)
        return BadLength;
#endif

    return DoChangeDrawableAttributes(cl->client, req->drawable,
                                      req->numAttribs, (CARD32 *) (req + 1));
}

int
__glXDisp_ChangeDrawableAttributesSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXChangeDrawableAttributesSGIXReq *req =
        (xGLXChangeDrawableAttributesSGIXReq *) pc;

    REQUEST_AT_LEAST_SIZE(xGLXChangeDrawableAttributesSGIXReq);
    if (req->numAttribs > (UINT32_MAX >> 3)) {
        client->errorValue = req->numAttribs;
        return BadValue;
    }
    REQUEST_FIXED_SIZE(xGLXChangeDrawableAttributesSGIXReq,
                       req->numAttribs << 3);

    return DoChangeDrawableAttributes(cl->client, req->drawable,
                                      req->numAttribs, (CARD32 *) (req + 1));
}

int
__glXDisp_CreateWindow(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreateWindowReq *req = (xGLXCreateWindowReq *) pc;
    __GLXconfig *config;
    __GLXscreen *pGlxScreen;
    ClientPtr client = cl->client;
    DrawablePtr pDraw;
    int err;

    REQUEST_AT_LEAST_SIZE(xGLXCreateWindowReq);
    if (req->numAttribs > (UINT32_MAX >> 3)) {
        client->errorValue = req->numAttribs;
        return BadValue;
    }
    REQUEST_FIXED_SIZE(xGLXCreateWindowReq, req->numAttribs << 3);

    LEGAL_NEW_RESOURCE(req->glxwindow, client);

    if (!validGlxScreen(client, req->screen, &pGlxScreen, &err))
        return err;
    if (!validGlxFBConfig(client, pGlxScreen, req->fbconfig, &config, &err))
        return err;

    err = dixLookupDrawable(&pDraw, req->window, client, 0, DixAddAccess);
    if (err != Success || pDraw->type != DRAWABLE_WINDOW) {
        client->errorValue = req->window;
        return BadWindow;
    }

    if (!validGlxFBConfigForWindow(client, config, pDraw, &err))
        return err;

    return DoCreateGLXDrawable(client, pGlxScreen, config,
                               pDraw, req->window,
                               req->glxwindow, GLX_DRAWABLE_WINDOW);
}

int
__glXDisp_DestroyWindow(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyWindowReq *req = (xGLXDestroyWindowReq *) pc;

    /* mesa's glXDestroyWindow used to set length to 3 instead of 2 */
    REQUEST_AT_LEAST_SIZE(xGLXDestroyWindowReq);

    return DoDestroyDrawable(cl, req->glxwindow, GLX_DRAWABLE_WINDOW);
}

/*****************************************************************************/

/*
** NOTE: There is no portable implementation for swap buffers as of
** this time that is of value.  Consequently, this code must be
** implemented by somebody other than SGI.
*/
int
__glXDisp_SwapBuffers(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXSwapBuffersReq *req = (xGLXSwapBuffersReq *) pc;
    GLXContextTag tag;
    XID drawId;
    __GLXcontext *glxc = NULL;
    __GLXdrawable *pGlxDraw;
    int error;

    REQUEST_SIZE_MATCH(xGLXSwapBuffersReq);

    tag = req->contextTag;
    drawId = req->drawable;
    if (tag) {
        glxc = __glXLookupContextByTag(cl, tag);
        if (!glxc) {
            return __glXError(GLXBadContextTag);
        }
        /*
         ** The calling thread is swapping its current drawable.  In this case,
         ** glxSwapBuffers is in both GL and X streams, in terms of
         ** sequentiality.
         */
        if (__glXForceCurrent(cl, tag, &error)) {
            /*
             ** Do whatever is needed to make sure that all preceding requests
             ** in both streams are completed before the swap is executed.
             */
            glFinish();
            glxc->hasUnflushedCommands = GL_FALSE;
        }
        else {
            return error;
        }
    }

    pGlxDraw = __glXGetDrawable(glxc, drawId, client, &error);
    if (pGlxDraw == NULL)
        return error;

    if (pGlxDraw->type == DRAWABLE_WINDOW &&
        (*pGlxDraw->swapBuffers) (cl->client, pGlxDraw) == GL_FALSE)
        return __glXError(GLXBadDrawable);

    return Success;
}

static int
DoQueryContext(__GLXclientState * cl, GLXContextID gcId)
{
    ClientPtr client = cl->client;
    __GLXcontext *ctx;
    xGLXQueryContextInfoEXTReply reply;
    int nProps = 3;
    int sendBuf[nProps * 2];
    int nReplyBytes;
    int err;

    if (!validGlxContext(cl->client, gcId, DixReadAccess, &ctx, &err))
        return err;

    reply = (xGLXQueryContextInfoEXTReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = nProps << 1,
        .n = nProps
    };

    nReplyBytes = reply.length << 2;
    sendBuf[0] = GLX_SHARE_CONTEXT_EXT;
    sendBuf[1] = (int) (ctx->share_id);
    sendBuf[2] = GLX_VISUAL_ID_EXT;
    sendBuf[3] = (int) (ctx->config->visualID);
    sendBuf[4] = GLX_SCREEN_EXT;
    sendBuf[5] = (int) (ctx->pGlxScreen->pScreen->myNum);

    if (client->swapped) {
        __glXSwapQueryContextInfoEXTReply(client, &reply, sendBuf);
    }
    else {
        WriteToClient(client, sz_xGLXQueryContextInfoEXTReply, &reply);
        WriteToClient(client, nReplyBytes, sendBuf);
    }

    return Success;
}

int
__glXDisp_QueryContextInfoEXT(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXQueryContextInfoEXTReq *req = (xGLXQueryContextInfoEXTReq *) pc;

    REQUEST_SIZE_MATCH(xGLXQueryContextInfoEXTReq);

    return DoQueryContext(cl, req->context);
}

int
__glXDisp_QueryContext(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXQueryContextReq *req = (xGLXQueryContextReq *) pc;

    REQUEST_SIZE_MATCH(xGLXQueryContextReq);

    return DoQueryContext(cl, req->context);
}

int
__glXDisp_BindTexImageEXT(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;
    ClientPtr client = cl->client;
    __GLXcontext *context;
    __GLXdrawable *pGlxDraw;
    GLXDrawable drawId;
    int buffer;
    int error;
    CARD32 num_attribs;

    if ((sizeof(xGLXVendorPrivateReq) + 12) >> 2 > client->req_len)
        return BadLength;

    pc += __GLX_VENDPRIV_HDR_SIZE;

    drawId = *((CARD32 *) (pc));
    buffer = *((INT32 *) (pc + 4));
    num_attribs = *((CARD32 *) (pc + 8));
    if (num_attribs > (UINT32_MAX >> 3)) {
        client->errorValue = num_attribs;
        return BadValue;
    }
    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 12 + (num_attribs << 3));

    if (buffer != GLX_FRONT_LEFT_EXT)
        return __glXError(GLXBadPixmap);

    context = __glXForceCurrent(cl, req->contextTag, &error);
    if (!context)
        return error;

    if (!validGlxDrawable(client, drawId, GLX_DRAWABLE_PIXMAP,
                          DixReadAccess, &pGlxDraw, &error))
        return error;

    if (!context->textureFromPixmap)
        return __glXError(GLXUnsupportedPrivateRequest);

    return context->textureFromPixmap->bindTexImage(context, buffer, pGlxDraw);
}

int
__glXDisp_ReleaseTexImageEXT(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;
    ClientPtr client = cl->client;
    __GLXdrawable *pGlxDraw;
    __GLXcontext *context;
    GLXDrawable drawId;
    int buffer;
    int error;

    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 8);

    pc += __GLX_VENDPRIV_HDR_SIZE;

    drawId = *((CARD32 *) (pc));
    buffer = *((INT32 *) (pc + 4));

    context = __glXForceCurrent(cl, req->contextTag, &error);
    if (!context)
        return error;

    if (!validGlxDrawable(client, drawId, GLX_DRAWABLE_PIXMAP,
                          DixReadAccess, &pGlxDraw, &error))
        return error;

    if (!context->textureFromPixmap)
        return __glXError(GLXUnsupportedPrivateRequest);

    return context->textureFromPixmap->releaseTexImage(context,
                                                       buffer, pGlxDraw);
}

int
__glXDisp_CopySubBufferMESA(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;
    GLXContextTag tag = req->contextTag;
    __GLXcontext *glxc = NULL;
    __GLXdrawable *pGlxDraw;
    ClientPtr client = cl->client;
    GLXDrawable drawId;
    int error;
    int x, y, width, height;

    (void) client;
    (void) req;

    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 20);

    pc += __GLX_VENDPRIV_HDR_SIZE;

    drawId = *((CARD32 *) (pc));
    x = *((INT32 *) (pc + 4));
    y = *((INT32 *) (pc + 8));
    width = *((INT32 *) (pc + 12));
    height = *((INT32 *) (pc + 16));

    if (tag) {
        glxc = __glXLookupContextByTag(cl, tag);
        if (!glxc) {
            return __glXError(GLXBadContextTag);
        }
        /*
         ** The calling thread is swapping its current drawable.  In this case,
         ** glxSwapBuffers is in both GL and X streams, in terms of
         ** sequentiality.
         */
        if (__glXForceCurrent(cl, tag, &error)) {
            /*
             ** Do whatever is needed to make sure that all preceding requests
             ** in both streams are completed before the swap is executed.
             */
            glFinish();
            glxc->hasUnflushedCommands = GL_FALSE;
        }
        else {
            return error;
        }
    }

    pGlxDraw = __glXGetDrawable(glxc, drawId, client, &error);
    if (!pGlxDraw)
        return error;

    if (pGlxDraw == NULL ||
        pGlxDraw->type != GLX_DRAWABLE_WINDOW ||
        pGlxDraw->copySubBuffer == NULL)
        return __glXError(GLXBadDrawable);

    (*pGlxDraw->copySubBuffer) (pGlxDraw, x, y, width, height);

    return Success;
}

/* hack for old glxext.h */
#ifndef GLX_STEREO_TREE_EXT
#define GLX_STEREO_TREE_EXT                 0x20F5
#endif

/*
** Get drawable attributes
*/
static int
DoGetDrawableAttributes(__GLXclientState * cl, XID drawId)
{
    ClientPtr client = cl->client;
    xGLXGetDrawableAttributesReply reply;
    __GLXdrawable *pGlxDraw = NULL;
    DrawablePtr pDraw;
    CARD32 attributes[18];
    int num = 0, error;

    if (!validGlxDrawable(client, drawId, GLX_DRAWABLE_ANY,
                          DixGetAttrAccess, &pGlxDraw, &error)) {
        /* hack for GLX 1.2 naked windows */
        int err = dixLookupWindow((WindowPtr *)&pDraw, drawId, client,
                                  DixGetAttrAccess);
        if (err != Success)
            return error;
    }
    if (pGlxDraw)
        pDraw = pGlxDraw->pDraw;

#define ATTRIB(a, v) do { \
    attributes[2*num] = (a); \
    attributes[2*num+1] = (v); \
    num++; \
    } while (0)

    ATTRIB(GLX_Y_INVERTED_EXT, GL_FALSE);
    ATTRIB(GLX_WIDTH, pDraw->width);
    ATTRIB(GLX_HEIGHT, pDraw->height);
    ATTRIB(GLX_SCREEN, pDraw->pScreen->myNum);
    if (pGlxDraw) {
        ATTRIB(GLX_TEXTURE_TARGET_EXT,
               pGlxDraw->target == GL_TEXTURE_2D ?
                GLX_TEXTURE_2D_EXT : GLX_TEXTURE_RECTANGLE_EXT);
        ATTRIB(GLX_EVENT_MASK, pGlxDraw->eventMask);
        ATTRIB(GLX_FBCONFIG_ID, pGlxDraw->config->fbconfigID);
        if (pGlxDraw->type == GLX_DRAWABLE_PBUFFER) {
            ATTRIB(GLX_PRESERVED_CONTENTS, GL_TRUE);
        }
        if (pGlxDraw->type == GLX_DRAWABLE_WINDOW) {
            ATTRIB(GLX_STEREO_TREE_EXT, 0);
        }
    }
#undef ATTRIB

    reply = (xGLXGetDrawableAttributesReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = num << 1,
        .numAttribs = num
    };

    if (client->swapped) {
        __glXSwapGetDrawableAttributesReply(client, &reply, attributes);
    }
    else {
        WriteToClient(client, sz_xGLXGetDrawableAttributesReply, &reply);
        WriteToClient(client, reply.length * sizeof(CARD32), attributes);
    }

    return Success;
}

int
__glXDisp_GetDrawableAttributes(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXGetDrawableAttributesReq *req = (xGLXGetDrawableAttributesReq *) pc;

    /* this should be REQUEST_SIZE_MATCH, but mesa sends an additional 4 bytes */
    REQUEST_AT_LEAST_SIZE(xGLXGetDrawableAttributesReq);

    return DoGetDrawableAttributes(cl, req->drawable);
}

int
__glXDisp_GetDrawableAttributesSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXGetDrawableAttributesSGIXReq *req =
        (xGLXGetDrawableAttributesSGIXReq *) pc;

    REQUEST_SIZE_MATCH(xGLXGetDrawableAttributesSGIXReq);

    return DoGetDrawableAttributes(cl, req->drawable);
}

/************************************************************************/

/*
** Render and Renderlarge are not in the GLX API.  They are used by the GLX
** client library to send batches of GL rendering commands.
*/

/*
** Execute all the drawing commands in a request.
*/
int
__glXDisp_Render(__GLXclientState * cl, GLbyte * pc)
{
    xGLXRenderReq *req;
    ClientPtr client = cl->client;
    int left, cmdlen, error;
    int commandsDone;
    CARD16 opcode;
    __GLXrenderHeader *hdr;
    __GLXcontext *glxc;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_AT_LEAST_SIZE(xGLXRenderReq);

    req = (xGLXRenderReq *) pc;
    if (client->swapped) {
        __GLX_SWAP_SHORT(&req->length);
        __GLX_SWAP_INT(&req->contextTag);
    }

    glxc = __glXForceCurrent(cl, req->contextTag, &error);
    if (!glxc) {
        return error;
    }

    commandsDone = 0;
    pc += sz_xGLXRenderReq;
    left = (req->length << 2) - sz_xGLXRenderReq;
    while (left > 0) {
        __GLXrenderSizeData entry;
        int extra = 0;
        __GLXdispatchRenderProcPtr proc;
        int err;

        if (left < sizeof(__GLXrenderHeader))
            return BadLength;

        /*
         ** Verify that the header length and the overall length agree.
         ** Also, each command must be word aligned.
         */
        hdr = (__GLXrenderHeader *) pc;
        if (client->swapped) {
            __GLX_SWAP_SHORT(&hdr->length);
            __GLX_SWAP_SHORT(&hdr->opcode);
        }
        cmdlen = hdr->length;
        opcode = hdr->opcode;

        if (left < cmdlen)
            return BadLength;

        /*
         ** Check for core opcodes and grab entry data.
         */
        err = __glXGetProtocolSizeData(&Render_dispatch_info, opcode, &entry);
        proc = (__GLXdispatchRenderProcPtr)
            __glXGetProtocolDecodeFunction(&Render_dispatch_info,
                                           opcode, client->swapped);

        if ((err < 0) || (proc == NULL)) {
            client->errorValue = commandsDone;
            return __glXError(GLXBadRenderRequest);
        }

        if (cmdlen < entry.bytes) {
            return BadLength;
        }

        if (entry.varsize) {
            /* variable size command */
            extra = (*entry.varsize) (pc + __GLX_RENDER_HDR_SIZE,
                                      client->swapped,
                                      left - __GLX_RENDER_HDR_SIZE);
            if (extra < 0) {
                return BadLength;
            }
        }

        if (cmdlen != safe_pad(safe_add(entry.bytes, extra))) {
            return BadLength;
        }

        /*
         ** Skip over the header and execute the command.  We allow the
         ** caller to trash the command memory.  This is useful especially
         ** for things that require double alignment - they can just shift
         ** the data towards lower memory (trashing the header) by 4 bytes
         ** and achieve the required alignment.
         */
        (*proc) (pc + __GLX_RENDER_HDR_SIZE);
        pc += cmdlen;
        left -= cmdlen;
        commandsDone++;
    }
    glxc->hasUnflushedCommands = GL_TRUE;
    return Success;
}

/*
** Execute a large rendering request (one that spans multiple X requests).
*/
int
__glXDisp_RenderLarge(__GLXclientState * cl, GLbyte * pc)
{
    xGLXRenderLargeReq *req;
    ClientPtr client = cl->client;
    size_t dataBytes;
    __GLXrenderLargeHeader *hdr;
    __GLXcontext *glxc;
    int error;
    CARD16 opcode;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_AT_LEAST_SIZE(xGLXRenderLargeReq);

    req = (xGLXRenderLargeReq *) pc;
    if (client->swapped) {
        __GLX_SWAP_SHORT(&req->length);
        __GLX_SWAP_INT(&req->contextTag);
        __GLX_SWAP_INT(&req->dataBytes);
        __GLX_SWAP_SHORT(&req->requestNumber);
        __GLX_SWAP_SHORT(&req->requestTotal);
    }

    glxc = __glXForceCurrent(cl, req->contextTag, &error);
    if (!glxc) {
        /* Reset in case this isn't 1st request. */
        __glXResetLargeCommandStatus(cl);
        return error;
    }
    if (safe_pad(req->dataBytes) < 0)
        return BadLength;
    dataBytes = req->dataBytes;

    /*
     ** Check the request length.
     */
    if ((req->length << 2) != safe_pad(dataBytes) + sz_xGLXRenderLargeReq) {
        client->errorValue = req->length;
        /* Reset in case this isn't 1st request. */
        __glXResetLargeCommandStatus(cl);
        return BadLength;
    }
    pc += sz_xGLXRenderLargeReq;

    if (cl->largeCmdRequestsSoFar == 0) {
        __GLXrenderSizeData entry;
        int extra = 0;
        int left = (req->length << 2) - sz_xGLXRenderLargeReq;
        int cmdlen;
        int err;

        /*
         ** This is the first request of a multi request command.
         ** Make enough space in the buffer, then copy the entire request.
         */
        if (req->requestNumber != 1) {
            client->errorValue = req->requestNumber;
            return __glXError(GLXBadLargeRequest);
        }

        if (dataBytes < __GLX_RENDER_LARGE_HDR_SIZE)
            return BadLength;

        hdr = (__GLXrenderLargeHeader *) pc;
        if (client->swapped) {
            __GLX_SWAP_INT(&hdr->length);
            __GLX_SWAP_INT(&hdr->opcode);
        }
        opcode = hdr->opcode;
        if ((cmdlen = safe_pad(hdr->length)) < 0)
            return BadLength;

        /*
         ** Check for core opcodes and grab entry data.
         */
        err = __glXGetProtocolSizeData(&Render_dispatch_info, opcode, &entry);
        if (err < 0) {
            client->errorValue = opcode;
            return __glXError(GLXBadLargeRequest);
        }

        if (entry.varsize) {
            /*
             ** If it's a variable-size command (a command whose length must
             ** be computed from its parameters), all the parameters needed
             ** will be in the 1st request, so it's okay to do this.
             */
            extra = (*entry.varsize) (pc + __GLX_RENDER_LARGE_HDR_SIZE,
                                      client->swapped,
                                      left - __GLX_RENDER_LARGE_HDR_SIZE);
            if (extra < 0) {
                return BadLength;
            }
        }

        /* the +4 is safe because we know entry.bytes is small */
        if (cmdlen != safe_pad(safe_add(entry.bytes + 4, extra))) {
            return BadLength;
        }

        /*
         ** Make enough space in the buffer, then copy the entire request.
         */
        if (cl->largeCmdBufSize < cmdlen) {
	    GLbyte *newbuf = cl->largeCmdBuf;

	    if (!(newbuf = realloc(newbuf, cmdlen)))
		return BadAlloc;

	    cl->largeCmdBuf = newbuf;
            cl->largeCmdBufSize = cmdlen;
        }
        memcpy(cl->largeCmdBuf, pc, dataBytes);

        cl->largeCmdBytesSoFar = dataBytes;
        cl->largeCmdBytesTotal = cmdlen;
        cl->largeCmdRequestsSoFar = 1;
        cl->largeCmdRequestsTotal = req->requestTotal;
        return Success;

    }
    else {
        /*
         ** We are receiving subsequent (i.e. not the first) requests of a
         ** multi request command.
         */
        int bytesSoFar; /* including this packet */

        /*
         ** Check the request number and the total request count.
         */
        if (req->requestNumber != cl->largeCmdRequestsSoFar + 1) {
            client->errorValue = req->requestNumber;
            __glXResetLargeCommandStatus(cl);
            return __glXError(GLXBadLargeRequest);
        }
        if (req->requestTotal != cl->largeCmdRequestsTotal) {
            client->errorValue = req->requestTotal;
            __glXResetLargeCommandStatus(cl);
            return __glXError(GLXBadLargeRequest);
        }

        /*
         ** Check that we didn't get too much data.
         */
        if ((bytesSoFar = safe_add(cl->largeCmdBytesSoFar, dataBytes)) < 0) {
            client->errorValue = dataBytes;
            __glXResetLargeCommandStatus(cl);
            return __glXError(GLXBadLargeRequest);
        }

        if (bytesSoFar > cl->largeCmdBytesTotal) {
            client->errorValue = dataBytes;
            __glXResetLargeCommandStatus(cl);
            return __glXError(GLXBadLargeRequest);
        }

        memcpy(cl->largeCmdBuf + cl->largeCmdBytesSoFar, pc, dataBytes);
        cl->largeCmdBytesSoFar += dataBytes;
        cl->largeCmdRequestsSoFar++;

        if (req->requestNumber == cl->largeCmdRequestsTotal) {
            __GLXdispatchRenderProcPtr proc;

            /*
             ** This is the last request; it must have enough bytes to complete
             ** the command.
             */
            /* NOTE: the pad macro below is needed because the client library
             ** pads the total byte count, but not the per-request byte counts.
             ** The Protocol Encoding says the total byte count should not be
             ** padded, so a proposal will be made to the ARB to relax the
             ** padding constraint on the total byte count, thus preserving
             ** backward compatibility.  Meanwhile, the padding done below
             ** fixes a bug that did not allow large commands of odd sizes to
             ** be accepted by the server.
             */
            if (safe_pad(cl->largeCmdBytesSoFar) != cl->largeCmdBytesTotal) {
                client->errorValue = dataBytes;
                __glXResetLargeCommandStatus(cl);
                return __glXError(GLXBadLargeRequest);
            }
            hdr = (__GLXrenderLargeHeader *) cl->largeCmdBuf;
            /*
             ** The opcode and length field in the header had already been
             ** swapped when the first request was received.
             **
             ** Use the opcode to index into the procedure table.
             */
            opcode = hdr->opcode;

            proc = (__GLXdispatchRenderProcPtr)
                __glXGetProtocolDecodeFunction(&Render_dispatch_info, opcode,
                                               client->swapped);
            if (proc == NULL) {
                client->errorValue = opcode;
                return __glXError(GLXBadLargeRequest);
            }

            /*
             ** Skip over the header and execute the command.
             */
            (*proc) (cl->largeCmdBuf + __GLX_RENDER_LARGE_HDR_SIZE);
            glxc->hasUnflushedCommands = GL_TRUE;

            /*
             ** Reset for the next RenderLarge series.
             */
            __glXResetLargeCommandStatus(cl);
        }
        else {
            /*
             ** This is neither the first nor the last request.
             */
        }
        return Success;
    }
}

/************************************************************************/

/*
** No support is provided for the vendor-private requests other than
** allocating the entry points in the dispatch table.
*/

int
__glXDisp_VendorPrivate(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;
    GLint vendorcode = req->vendorCode;
    __GLXdispatchVendorPrivProcPtr proc;

    REQUEST_AT_LEAST_SIZE(xGLXVendorPrivateReq);

    proc = (__GLXdispatchVendorPrivProcPtr)
        __glXGetProtocolDecodeFunction(&VendorPriv_dispatch_info,
                                       vendorcode, 0);
    if (proc != NULL) {
        (*proc) (cl, (GLbyte *) req);
        return Success;
    }

    cl->client->errorValue = req->vendorCode;
    return __glXError(GLXUnsupportedPrivateRequest);
}

int
__glXDisp_VendorPrivateWithReply(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;
    GLint vendorcode = req->vendorCode;
    __GLXdispatchVendorPrivProcPtr proc;

    REQUEST_AT_LEAST_SIZE(xGLXVendorPrivateReq);

    proc = (__GLXdispatchVendorPrivProcPtr)
        __glXGetProtocolDecodeFunction(&VendorPriv_dispatch_info,
                                       vendorcode, 0);
    if (proc != NULL) {
        return (*proc) (cl, (GLbyte *) req);
    }

    cl->client->errorValue = vendorcode;
    return __glXError(GLXUnsupportedPrivateRequest);
}

int
__glXDisp_QueryExtensionsString(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXQueryExtensionsStringReq *req = (xGLXQueryExtensionsStringReq *) pc;
    xGLXQueryExtensionsStringReply reply;
    __GLXscreen *pGlxScreen;
    size_t n, length;
    char *buf;
    int err;

    REQUEST_SIZE_MATCH(xGLXQueryExtensionsStringReq);

    if (!validGlxScreen(client, req->screen, &pGlxScreen, &err))
        return err;

    n = strlen(pGlxScreen->GLXextensions) + 1;
    length = __GLX_PAD(n) >> 2;
    reply = (xGLXQueryExtensionsStringReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = length,
        .n = n
    };

    /* Allocate buffer to make sure it's a multiple of 4 bytes big. */
    buf = calloc(length, 4);
    if (buf == NULL)
        return BadAlloc;
    memcpy(buf, pGlxScreen->GLXextensions, n);

    if (client->swapped) {
        glxSwapQueryExtensionsStringReply(client, &reply, buf);
    }
    else {
        WriteToClient(client, sz_xGLXQueryExtensionsStringReply, &reply);
        WriteToClient(client, (int) (length << 2), buf);
    }

    free(buf);
    return Success;
}

int
__glXDisp_QueryServerString(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXQueryServerStringReq *req = (xGLXQueryServerStringReq *) pc;
    xGLXQueryServerStringReply reply;
    size_t n, length;
    const char *ptr;
    char *buf;
    __GLXscreen *pGlxScreen;
    int err;
    char ver_str[16];

    REQUEST_SIZE_MATCH(xGLXQueryServerStringReq);

    if (!validGlxScreen(client, req->screen, &pGlxScreen, &err))
        return err;

    switch (req->name) {
    case GLX_VENDOR:
        ptr = GLXServerVendorName;
        break;
    case GLX_VERSION:
        /* Return to the server version rather than the screen version
         * to prevent confusion when they do not match.
         */
        snprintf(ver_str, 16, "%d.%d", glxMajorVersion, glxMinorVersion);
        ptr = ver_str;
        break;
    case GLX_EXTENSIONS:
        ptr = pGlxScreen->GLXextensions;
        break;
    default:
        return BadValue;
    }

    n = strlen(ptr) + 1;
    length = __GLX_PAD(n) >> 2;
    reply = (xGLXQueryServerStringReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = length,
        .n = n
    };

    buf = calloc(length, 4);
    if (buf == NULL) {
        return BadAlloc;
    }
    memcpy(buf, ptr, n);

    if (client->swapped) {
        glxSwapQueryServerStringReply(client, &reply, buf);
    }
    else {
        WriteToClient(client, sz_xGLXQueryServerStringReply, &reply);
        WriteToClient(client, (int) (length << 2), buf);
    }

    free(buf);
    return Success;
}

int
__glXDisp_ClientInfo(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXClientInfoReq *req = (xGLXClientInfoReq *) pc;
    const char *buf;

    REQUEST_AT_LEAST_SIZE(xGLXClientInfoReq);

    buf = (const char *) (req + 1);
    if (!memchr(buf, 0, (client->req_len << 2) - sizeof(xGLXClientInfoReq)))
        return BadLength;

    free(cl->GLClientextensions);
    cl->GLClientextensions = strdup(buf);

    return Success;
}

#include <GL/glxtokens.h>

void
__glXsendSwapEvent(__GLXdrawable *drawable, int type, CARD64 ust,
                   CARD64 msc, CARD32 sbc)
{
    ClientPtr client = clients[CLIENT_ID(drawable->drawId)];

    xGLXBufferSwapComplete2 wire =  {
        .type = __glXEventBase + GLX_BufferSwapComplete
    };

    if (!client)
        return;

    if (!(drawable->eventMask & GLX_BUFFER_SWAP_COMPLETE_INTEL_MASK))
        return;

    wire.event_type = type;
    wire.drawable = drawable->drawId;
    wire.ust_hi = ust >> 32;
    wire.ust_lo = ust & 0xffffffff;
    wire.msc_hi = msc >> 32;
    wire.msc_lo = msc & 0xffffffff;
    wire.sbc = sbc;

    WriteEventsToClient(client, 1, (xEvent *) &wire);
}

#if PRESENT
static void
__glXpresentCompleteNotify(WindowPtr window, CARD8 present_kind, CARD8 present_mode,
                           CARD32 serial, uint64_t ust, uint64_t msc)
{
    __GLXdrawable *drawable;
    int glx_type;
    int rc;

    if (present_kind != PresentCompleteKindPixmap)
        return;

    rc = dixLookupResourceByType((void **) &drawable, window->drawable.id,
                                 __glXDrawableRes, serverClient, DixGetAttrAccess);

    if (rc != Success)
        return;

    if (present_mode == PresentCompleteModeFlip)
        glx_type = GLX_FLIP_COMPLETE_INTEL;
    else
        glx_type = GLX_BLIT_COMPLETE_INTEL;

    __glXsendSwapEvent(drawable, glx_type, ust, msc, serial);
}

#include <present.h>

void
__glXregisterPresentCompleteNotify(void)
{
    present_register_complete_notify(__glXpresentCompleteNotify);
}
#endif
@


1.13
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@a546 1
        pGlxDraw->destroy(pGlxDraw);
d1241 1
a1241 2
    if (!AddResource(glxDrawableId, __glXDrawableRes, pGlxDraw)) {
        pGlxDraw->destroy(pGlxDraw);
a1242 1
    }
d1249 1
a1249 2
        !AddResource(pDraw->id, __glXDrawableRes, pGlxDraw)) {
        pGlxDraw->destroy(pGlxDraw);
a1250 1
    }
d1924 5
d1939 1
a1939 1
    CARD32 attributes[14];
d1953 10
a1962 9
    attributes[2*num] = GLX_Y_INVERTED_EXT;
    attributes[2*num+1] = GL_FALSE;
    num++;
    attributes[2*num] = GLX_WIDTH;
    attributes[2*num+1] = pDraw->width;
    num++;
    attributes[2*num] = GLX_HEIGHT;
    attributes[2*num+1] = pDraw->height;
    num++;
d1964 5
a1968 11
        attributes[2*num] = GLX_TEXTURE_TARGET_EXT;
        attributes[2*num+1] = pGlxDraw->target == GL_TEXTURE_2D ?
            GLX_TEXTURE_2D_EXT :
            GLX_TEXTURE_RECTANGLE_EXT;
        num++;
        attributes[2*num] = GLX_EVENT_MASK;
        attributes[2*num+1] = pGlxDraw->eventMask;
        num++;
        attributes[2*num] = GLX_FBCONFIG_ID;
        attributes[2*num+1] = pGlxDraw->config->fbconfigID;
        num++;
d1970 4
a1973 3
            attributes[2*num] = GLX_PRESERVED_CONTENTS;
            attributes[2*num+1] = GL_TRUE;
            num++;
d1976 1
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d337 13
d642 6
a647 1
        if (prevglxc->hasUnflushedCommands) {
d2185 1
a2185 1
        size_t cmdlen;
@


1.11
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d201 6
d218 1
d243 1
a243 1
     ** Find the display list space that we want to share.  
d246 4
a249 4
     ** count for each display list so that if one client detroyed a list that 
     ** another client was using, the list would not really be freed until it 
     ** was no longer in use.  Since this sample implementation has no support 
     ** for multithreaded servers, we don't do this.  
d423 3
a425 1
    FreeResourceByType(req->context, __glXContextRes, FALSE);
d1004 1
a1004 1
        /* 
d1053 1
a1053 1
 * 
d1919 2
a1920 1
    __GLXdrawable *pGlxDraw;
d1922 1
a1922 1
    int numAttribs = 0, error;
d1925 9
a1933 2
                          DixGetAttrAccess, &pGlxDraw, &error))
        return error;
d1935 26
a1960 23
    attributes[0] = GLX_TEXTURE_TARGET_EXT;
    attributes[1] = pGlxDraw->target == GL_TEXTURE_2D ? GLX_TEXTURE_2D_EXT :
        GLX_TEXTURE_RECTANGLE_EXT;
    numAttribs++;
    attributes[2] = GLX_Y_INVERTED_EXT;
    attributes[3] = GL_FALSE;
    numAttribs++;
    attributes[4] = GLX_EVENT_MASK;
    attributes[5] = pGlxDraw->eventMask;
    numAttribs++;
    attributes[6] = GLX_WIDTH;
    attributes[7] = pGlxDraw->pDraw->width;
    numAttribs++;
    attributes[8] = GLX_HEIGHT;
    attributes[9] = pGlxDraw->pDraw->height;
    numAttribs++;
    attributes[10] = GLX_FBCONFIG_ID;
    attributes[11] = pGlxDraw->config->fbconfigID;
    numAttribs++;
    if (pGlxDraw->type == GLX_DRAWABLE_PBUFFER) {
        attributes[12] = GLX_PRESERVED_CONTENTS;
        attributes[13] = GL_TRUE;
        numAttribs++;
d1966 2
a1967 2
        .length = numAttribs << 1,
        .numAttribs = numAttribs
d2544 2
a2545 2
__glXpresentCompleteNotify(WindowPtr window, CARD8 present_mode, CARD32 serial,
                           uint64_t ust, uint64_t msc)
d2551 3
d2564 1
a2564 1
        
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d2026 1
a2026 1
        int extra;
d2045 3
d2061 4
d2068 2
a2069 1
                                      client->swapped);
a2070 3
                extra = 0;
            }
            if (cmdlen != __GLX_PAD(entry.bytes + extra)) {
d2074 2
a2075 7
        else {
            /* constant size command */
            if (cmdlen != __GLX_PAD(entry.bytes)) {
                return BadLength;
            }
        }
        if (left < cmdlen) {
d2111 2
d2128 2
d2135 1
a2135 1
    if ((req->length << 2) != __GLX_PAD(dataBytes) + sz_xGLXRenderLargeReq) {
d2145 2
a2146 1
        int extra;
d2159 3
a2166 1
        cmdlen = hdr->length;
d2168 2
d2187 2
a2188 1
                                      client->swapped);
a2189 4
                extra = 0;
            }
            /* large command's header is 4 bytes longer, so add 4 */
            if (cmdlen != __GLX_PAD(entry.bytes + 4 + extra)) {
d2193 4
a2196 5
        else {
            /* constant size command */
            if (cmdlen != __GLX_PAD(entry.bytes + 4)) {
                return BadLength;
            }
d2198 1
d2225 1
d2244 1
a2244 1
        if ((cl->largeCmdBytesSoFar + dataBytes) > cl->largeCmdBytesTotal) {
d2249 7
d2267 8
a2274 8
            /* NOTE: the two pad macros have been added below; they are needed
             ** because the client library pads the total byte count, but not
             ** the per-request byte counts.  The Protocol Encoding says the
             ** total byte count should not be padded, so a proposal will be 
             ** made to the ARB to relax the padding constraint on the total 
             ** byte count, thus preserving backward compatibility.  Meanwhile, 
             ** the padding done below fixes a bug that did not allow
             ** large commands of odd sizes to be accepted by the server.
d2276 1
a2276 2
            if (__GLX_PAD(cl->largeCmdBytesSoFar) !=
                __GLX_PAD(cl->largeCmdBytesTotal)) {
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d136 1
a136 1
    *err = dixLookupResourceByType((pointer *) context, id,
d154 1
a154 1
    rc = dixLookupResourceByType((pointer *) drawable, id,
d191 1
a191 1
    __glXFlushContextCache();
d278 11
a447 4
        if (glxc == __glXLastContext) {
            /* Tell server GL library */
            __glXLastContext = 0;
        }
a457 1
    __glXLastContext = glxc;
d636 1
a636 1
        __glXFlushContextCache();
d649 1
d651 1
d2518 1
a2518 1
    rc = dixLookupResourceByType((pointer *) &drawable, window->drawable.id,
@


1.9.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d2018 1
a2018 1
        int extra = 0;
a2036 3
        if (left < cmdlen)
            return BadLength;

a2049 4
        if (cmdlen < entry.bytes) {
            return BadLength;
        }

d2053 1
a2053 2
                                      client->swapped,
                                      left - __GLX_RENDER_HDR_SIZE);
d2055 9
d2067 1
a2067 2

        if (cmdlen != safe_pad(safe_add(entry.bytes, extra))) {
a2102 2
    REQUEST_AT_LEAST_SIZE(xGLXRenderLargeReq);

a2117 2
    if (safe_pad(req->dataBytes) < 0)
        return BadLength;
d2123 1
a2123 1
    if ((req->length << 2) != safe_pad(dataBytes) + sz_xGLXRenderLargeReq) {
d2133 1
a2133 2
        int extra = 0;
        int left = (req->length << 2) - sz_xGLXRenderLargeReq;
a2145 3
        if (dataBytes < __GLX_RENDER_LARGE_HDR_SIZE)
            return BadLength;

d2151 1
a2152 2
        if ((cmdlen = safe_pad(hdr->length)) < 0)
            return BadLength;
d2170 1
a2170 2
                                      client->swapped,
                                      left - __GLX_RENDER_LARGE_HDR_SIZE);
d2172 4
d2179 5
a2183 4

        /* the +4 is safe because we know entry.bytes is small */
        if (cmdlen != safe_pad(safe_add(entry.bytes + 4, extra))) {
            return BadLength;
a2184 1

a2210 1
        int bytesSoFar; /* including this packet */
d2229 1
a2229 1
        if ((bytesSoFar = safe_add(cl->largeCmdBytesSoFar, dataBytes)) < 0) {
a2233 7

        if (bytesSoFar > cl->largeCmdBytesTotal) {
            client->errorValue = dataBytes;
            __glXResetLargeCommandStatus(cl);
            return __glXError(GLXBadLargeRequest);
        }

d2245 8
a2252 8
            /* NOTE: the pad macro below is needed because the client library
             ** pads the total byte count, but not the per-request byte counts.
             ** The Protocol Encoding says the total byte count should not be
             ** padded, so a proposal will be made to the ARB to relax the
             ** padding constraint on the total byte count, thus preserving
             ** backward compatibility.  Meanwhile, the padding done below
             ** fixes a bug that did not allow large commands of odd sizes to
             ** be accepted by the server.
d2254 2
a2255 1
            if (safe_pad(cl->largeCmdBytesSoFar) != cl->largeCmdBytesTotal) {
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a44 4
#include "glapitable.h"
#include "glapi.h"
#include "glthread.h"
#include "dispatch.h"
d49 2
d298 1
a298 1
    glxc->isCurrent = GL_FALSE;
d405 1
a405 3
    glxc->idExists = GL_FALSE;
    if (!glxc->isCurrent)
        FreeResourceByType(req->context, __glXContextRes, FALSE);
d441 1
a441 1
        glxc->isCurrent = GL_FALSE;
a450 1
    glxc->isCurrent = GL_TRUE;
d452 1
d512 4
d586 1
a586 1
        if ((glxc != prevglxc) && glxc->isCurrent) {
d616 1
a616 1
                CALL_Flush(GET_DISPATCH(), ());
d649 1
a649 1
        glxc->isCurrent = GL_TRUE;
d799 1
a799 1
        CALL_Finish(GET_DISPATCH(), ());
d870 1
a870 1
    if (dst->isCurrent) {
d897 1
a897 1
            CALL_Finish(GET_DISPATCH(), ());
d916 1
a916 1
    GLX_VIS_CONFIG_PAIRED = 20
d1008 11
a1018 2
        buf[p++] = 0;           /* copy over visualSelectGroup (GLX_VISUAL_SELECT_GROUP_SGIX)? */
        buf[p++] = 0;
d1029 1
a1029 1
#define __GLX_TOTAL_FBCONFIG_ATTRIBS (36)
d1114 1
a1114 1
        /* GLX_VISUAL_SELECT_GROUP_SGIX ? */
d1121 20
d1247 2
a1248 1
    ((PixmapPtr) pDraw)->refcnt++;
d1429 2
a1471 1
        case GLX_PRESERVED_CONTENTS:
d1489 4
d1675 1
a1675 1
            CALL_Finish(GET_DISPATCH(), ());
d1700 2
a1701 2
    int nProps;
    int *sendBuf, *pSendBuf;
a1707 1
    nProps = 3;
d1716 6
a1721 11
    sendBuf = (int *) malloc((size_t) nReplyBytes);
    if (sendBuf == NULL) {
        return __glXError(GLXBadContext);       /* XXX: Is this correct? */
    }
    pSendBuf = sendBuf;
    *pSendBuf++ = GLX_SHARE_CONTEXT_EXT;
    *pSendBuf++ = (int) (ctx->share_id);
    *pSendBuf++ = GLX_VISUAL_ID_EXT;
    *pSendBuf++ = (int) (ctx->config->visualID);
    *pSendBuf++ = GLX_SCREEN_EXT;
    *pSendBuf++ = (int) (ctx->pGlxScreen->pScreen->myNum);
a1729 1
    free((char *) sendBuf);
d1872 1
a1872 1
            CALL_Finish(GET_DISPATCH(), ());
d1903 2
a1904 2
    CARD32 attributes[6];
    int numAttribs, error;
a1909 8
    numAttribs = 3;
    reply = (xGLXGetDrawableAttributesReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = numAttribs << 1,
        .numAttribs = numAttribs
    };

d1913 1
d1916 1
d1919 22
d2189 6
a2194 9
            if (!cl->largeCmdBuf) {
                cl->largeCmdBuf = (GLbyte *) malloc(cmdlen);
            }
            else {
                cl->largeCmdBuf = (GLbyte *) realloc(cl->largeCmdBuf, cmdlen);
            }
            if (!cl->largeCmdBuf) {
                return BadAlloc;
            }
d2410 1
a2410 1
        ptr = pGlxScreen->GLXvendor;
d2471 61
@


1.8.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d1974 1
a1974 1
        int extra = 0;
a1992 3
        if (left < cmdlen)
            return BadLength;

a2005 4
        if (cmdlen < entry.bytes) {
            return BadLength;
        }

d2009 1
a2009 2
                                      client->swapped,
                                      left - __GLX_RENDER_HDR_SIZE);
d2011 9
d2023 1
a2023 2

        if (cmdlen != safe_pad(safe_add(entry.bytes, extra))) {
a2058 2
    REQUEST_AT_LEAST_SIZE(xGLXRenderLargeReq);

a2073 2
    if (safe_pad(req->dataBytes) < 0)
        return BadLength;
d2079 1
a2079 1
    if ((req->length << 2) != safe_pad(dataBytes) + sz_xGLXRenderLargeReq) {
d2089 1
a2089 2
        int extra = 0;
        int left = (req->length << 2) - sz_xGLXRenderLargeReq;
a2101 3
        if (dataBytes < __GLX_RENDER_LARGE_HDR_SIZE)
            return BadLength;

d2107 1
a2108 2
        if ((cmdlen = safe_pad(hdr->length)) < 0)
            return BadLength;
d2126 1
a2126 2
                                      client->swapped,
                                      left - __GLX_RENDER_LARGE_HDR_SIZE);
d2128 4
d2135 5
a2139 4

        /* the +4 is safe because we know entry.bytes is small */
        if (cmdlen != safe_pad(safe_add(entry.bytes + 4, extra))) {
            return BadLength;
a2140 1

a2169 1
        int bytesSoFar; /* including this packet */
d2188 1
a2188 1
        if ((bytesSoFar = safe_add(cl->largeCmdBytesSoFar, dataBytes)) < 0) {
a2192 7

        if (bytesSoFar > cl->largeCmdBytesTotal) {
            client->errorValue = dataBytes;
            __glXResetLargeCommandStatus(cl);
            return __glXError(GLXBadLargeRequest);
        }

d2204 8
a2211 8
            /* NOTE: the pad macro below is needed because the client library
             ** pads the total byte count, but not the per-request byte counts.
             ** The Protocol Encoding says the total byte count should not be
             ** padded, so a proposal will be made to the ARB to relax the
             ** padding constraint on the total byte count, thus preserving
             ** backward compatibility.  Meanwhile, the padding done below
             ** fixes a bug that did not allow large commands of odd sizes to
             ** be accepted by the server.
d2213 2
a2214 1
            if (safe_pad(cl->largeCmdBytesSoFar) != cl->largeCmdBytesTotal) {
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d53 1
a53 1
static int
d70 1
a70 1
static int
d134 1
a134 1
static int
d203 1
a203 1
static __GLXcontext *
d254 10
a263 9
        if (shareglxc->isDirect) {
            /*
             ** NOTE: no support for sharing display lists between direct
             ** contexts, even if they are in the same address space.
             */
#if 0
            /* Disabling this code seems to allow shared display lists
             * and texture objects to work.  We'll leave it disabled for now.
             */
a265 1
#endif
d267 1
a267 1
        else {
d279 8
a286 2
    if (!isDirect)
        glxc = pGlxScreen->createContext(pGlxScreen, config, shareglxc);
d293 1
a293 3
    /*
     ** Initially, setup the part of the context that could be used by
     ** a GL core that needs windowing information (e.g., Mesa).
a296 14

    /*
     ** Register this context as a resource.
     */
    if (!AddResource(gcId, __glXContextRes, (pointer) glxc)) {
        (*glxc->destroy) (glxc);
        client->errorValue = gcId;
        return BadAlloc;
    }

    /*
     ** Finally, now that everything is working, setup the rest of the
     ** context.
     */
d302 1
d304 16
d321 7
a327 1
    __glXAddToContextList(glxc);
d654 7
a664 7
    else {
        reply.contextTag = 0;
    }

    reply.length = 0;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
d670 1
a670 1
        WriteToClient(client, sz_xGLXMakeCurrentReply, (char *) &reply);
d725 6
a730 4
    reply.isDirect = glxc->isDirect;
    reply.length = 0;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
d736 1
a736 1
        WriteToClient(client, sz_xGLXIsDirectReply, (char *) &reply);
d762 7
a768 5
    reply.majorVersion = glxMajorVersion;
    reply.minorVersion = glxMinorVersion;
    reply.length = 0;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
d774 1
a774 1
        WriteToClient(client, sz_xGLXQueryVersionReply, (char *) &reply);
d942 8
a949 6
    reply.numVisuals = pGlxScreen->numVisuals;
    reply.numProps = GLX_VIS_CONFIG_TOTAL;
    reply.length =
        (reply.numVisuals * __GLX_SIZE_CARD32 * GLX_VIS_CONFIG_TOTAL) >> 2;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
d958 1
a958 1
    WriteToClient(client, sz_xGLXGetVisualConfigsReply, (char *) &reply);
d1015 1
a1015 1
        WriteToClient(client, __GLX_SIZE_CARD32 * p, (char *) buf);
d1048 7
a1054 5
    reply.numFBConfigs = pGlxScreen->numFBConfigs;
    reply.numAttribs = __GLX_TOTAL_FBCONFIG_ATTRIBS;
    reply.length = (__GLX_FBCONFIG_ATTRIBS_LENGTH * reply.numFBConfigs);
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
d1063 1
a1063 1
    WriteToClient(client, sz_xGLXGetFBConfigsReply, (char *) &reply);
d1674 6
a1679 4
    reply.length = nProps << 1;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.n = nProps;
d1698 2
a1699 2
        WriteToClient(client, sz_xGLXQueryContextInfoEXTReply, (char *) &reply);
        WriteToClient(client, nReplyBytes, (char *) sendBuf);
d1883 6
a1888 4
    reply.length = numAttribs << 1;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.numAttribs = numAttribs;
d1902 2
a1903 4
        WriteToClient(client, sz_xGLXGetDrawableAttributesReply,
                      (char *) &reply);
        WriteToClient(client, reply.length * sizeof(CARD32),
                      (char *) attributes);
d2324 6
a2329 4
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = length;
    reply.n = n;
d2332 1
a2332 1
    buf = (char *) malloc(length << 2);
d2341 2
a2342 3
        WriteToClient(client, sz_xGLXQueryExtensionsStringReply,
                      (char *) &reply);
        WriteToClient(client, (int) (length << 2), (char *) buf);
d2387 6
a2392 4
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = length;
    reply.n = n;
d2394 1
a2394 1
    buf = (char *) malloc(length << 2);
d2404 1
a2404 1
        WriteToClient(client, sz_xGLXQueryServerStringReply, (char *) &reply);
a2424 2
    cl->GLClientmajorVersion = req->major;
    cl->GLClientminorVersion = req->minor;
@


1.6
log
@Update to xserver 1.11.2
@
text
@d54 2
a55 1
validGlxScreen(ClientPtr client, int screen, __GLXscreen **pGlxScreen, int *err)
d58 2
a59 2
    ** Check if screen exists.
    */
d61 3
a63 3
	client->errorValue = screen;
	*err = BadValue;
	return FALSE;
d71 2
a72 2
validGlxFBConfig(ClientPtr client, __GLXscreen *pGlxScreen, XID id,
		 __GLXconfig **config, int *err)
d77 4
a80 4
	if (m->fbconfigID == id) {
	    *config = m;
	    return TRUE;
	}
d89 2
a90 2
validGlxVisual(ClientPtr client, __GLXscreen *pGlxScreen, XID id,
	       __GLXconfig **config, int *err)
d95 4
a98 4
 	if (pGlxScreen->visuals[i]->visualID == id) {
	    *config = pGlxScreen->visuals[i];
	    return TRUE;
	}
d107 2
a108 2
validGlxFBConfigForWindow(ClientPtr client, __GLXconfig *config,
			  DrawablePtr pDraw, int *err)
d115 1
a115 1
    vid = wVisual((WindowPtr)pDraw);
d117 4
a120 4
	if (pScreen->visuals[i].vid == vid) {
	    pVisual = &pScreen->visuals[i];
	    break;
	}
d125 4
a128 4
	!(config->drawableType & GLX_WINDOW_BIT)) {
	client->errorValue = pDraw->id;
	*err = BadMatch;
	return FALSE;
d136 1
a136 1
		__GLXcontext **context, int *err)
d139 1
a139 1
				   __glXContextRes, client, access_mode);
d141 4
a144 4
	client->errorValue = id;
	if (*err == BadValue || *err == Success)
	    *err = __glXError(GLXBadContext);
	return FALSE;
d152 1
a152 1
		 __GLXdrawable **drawable, int *err)
d157 1
a157 1
				 __glXDrawableRes, client, access_mode);
d159 3
a161 3
	*err = rc;
	client->errorValue = id;
	return FALSE;
d168 17
a184 17
	(*drawable)->drawId != id ||
	(type != GLX_DRAWABLE_ANY && type != (*drawable)->type)) {
	client->errorValue = id;
	switch (type) {
	case GLX_DRAWABLE_WINDOW:
	    *err = __glXError(GLXBadWindow);
	    return FALSE;
	case GLX_DRAWABLE_PIXMAP:
	    *err = __glXError(GLXBadPixmap);
	    return FALSE;
	case GLX_DRAWABLE_PBUFFER:
	    *err = __glXError(GLXBadPbuffer);
	    return FALSE;
	case GLX_DRAWABLE_ANY:
	    *err = __glXError(GLXBadDrawable);
	    return FALSE;
	}
d191 1
a191 1
__glXContextDestroy(__GLXcontext *context)
d196 2
a197 1
static void __glXdirectContextDestroy(__GLXcontext *context)
d203 3
a205 3
static __GLXcontext *__glXdirectContextCreate(__GLXscreen *screen,
					      __GLXconfig *modes,
					      __GLXcontext *shareContext)
d209 1
a209 1
    context = calloc(1, sizeof (__GLXcontext));
d211 1
a211 1
	return NULL;
d227 3
a229 3
DoCreateContext(__GLXclientState *cl, GLXContextID gcId,
		GLXContextID shareList, __GLXconfig *config,
		__GLXscreen *pGlxScreen, GLboolean isDirect)
d234 1
a234 1
    
d238 8
a245 8
    ** Find the display list space that we want to share.  
    **
    ** NOTE: In a multithreaded X server, we would need to keep a reference
    ** count for each display list so that if one client detroyed a list that 
    ** another client was using, the list would not really be freed until it 
    ** was no longer in use.  Since this sample implementation has no support 
    ** for multithreaded servers, we don't do this.  
    */
d247 12
a258 11
	shareglxc = 0;
    } else {
	if (!validGlxContext(client, shareList, DixReadAccess,
			     &shareglxc, &err))
	    return err;

	if (shareglxc->isDirect) {
	    /*
	    ** NOTE: no support for sharing display lists between direct
	    ** contexts, even if they are in the same address space.
	    */
d263 2
a264 2
	    client->errorValue = shareList;
	    return BadMatch;
d266 8
a273 7
	} else {
	    /*
	    ** Create an indirect context regardless of what the client asked
	    ** for; this way we can share display list space with shareList.
	    */
	    isDirect = GL_FALSE;
	}
d277 2
a278 2
    ** Allocate memory for the new context
    */
d280 1
a280 1
	glxc = pGlxScreen->createContext(pGlxScreen, config, shareglxc);
d282 1
a282 1
	glxc = __glXdirectContextCreate(pGlxScreen, config, shareglxc);
d284 1
a284 1
	return BadAlloc;
d288 3
a290 3
    ** Initially, setup the part of the context that could be used by
    ** a GL core that needs windowing information (e.g., Mesa).
    */
d295 6
a300 6
    ** Register this context as a resource.
    */
    if (!AddResource(gcId, __glXContextRes, (pointer)glxc)) {
	(*glxc->destroy)(glxc);
	client->errorValue = gcId;
	return BadAlloc;
d302 1
a302 1
    
d304 3
a306 3
    ** Finally, now that everything is working, setup the rest of the
    ** context.
    */
d319 2
a320 1
int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc)
d331 1
a331 1
	return err;
d333 1
a333 1
	return err;
d336 1
a336 1
			   config, pGlxScreen, req->isDirect);
d339 2
a340 1
int __glXDisp_CreateNewContext(__GLXclientState *cl, GLbyte *pc)
d351 1
a351 1
	return err;
d353 1
a353 1
	return err;
d356 1
a356 1
			   config, pGlxScreen, req->isDirect);
d359 2
a360 1
int __glXDisp_CreateContextWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)
d363 2
a364 2
    xGLXCreateContextWithConfigSGIXReq *req = 
	(xGLXCreateContextWithConfigSGIXReq *) pc;
d372 1
a372 1
	return err;
d374 1
a374 1
	return err;
d377 1
a377 1
			   config, pGlxScreen, req->isDirect);
d380 2
a381 1
int __glXDisp_DestroyContext(__GLXclientState *cl, GLbyte *pc)
d391 2
a392 2
			 &glxc, &err))
	    return err;
d410 2
a411 1
__GLXcontext *__glXLookupContextByTag(__GLXclientState *cl, GLXContextTag tag)
d415 1
a415 1
    if (dixLookupResourceByType((void **)&ret, tag, __glXContextRes,
d424 2
a425 1
static void StopUsingContext(__GLXcontext *glxc)
d428 6
a433 6
	if (glxc == __glXLastContext) {
	    /* Tell server GL library */
	    __glXLastContext = 0;
	}
	glxc->isCurrent = GL_FALSE;
	if (!glxc->idExists) {
d435 1
a435 1
	}
d439 2
a440 1
static void StartUsingContext(__GLXclientState *cl, __GLXcontext *glxc)
d443 1
a443 1
    __glXLastContext = glxc;	
d453 2
a454 2
__glXGetDrawable(__GLXcontext *glxc, GLXDrawable drawId, ClientPtr client,
		 int *error)
d461 6
a466 6
			 DixWriteAccess, &pGlxDraw, &rc)) {
	if (glxc != NULL && pGlxDraw->config != glxc->config) {
	    client->errorValue = drawId;
	    *error = BadMatch;
	    return NULL;
	}
d468 1
a468 1
	return pGlxDraw;
d473 3
a475 3
	    client->errorValue = drawId;
	    *error = BadMatch;
	    return NULL;
d485 3
a487 3
	client->errorValue = drawId;
	*error = __glXError(GLXBadDrawable);
	return NULL;
d491 3
a493 3
	client->errorValue = pDraw->pScreen->myNum;
	*error = BadMatch;
	return NULL;
d497 1
a497 1
	return NULL;
d500 3
a502 3
						pDraw, drawId,
						GLX_DRAWABLE_WINDOW,
						drawId, glxc->config);
d506 3
a508 3
	pGlxDraw->destroy (pGlxDraw);
	*error = BadAlloc;
	return NULL;
d520 3
a522 3
DoMakeCurrent(__GLXclientState *cl,
	      GLXDrawable drawId, GLXDrawable readId,
	      GLXContextID contextId, GLXContextTag tag)
d530 1
a530 1
    GLuint  mask;
d533 2
a534 2
    ** If one is None and the other isn't, it's a bad match.
    */
d536 2
a537 2
    mask  = (drawId == None)    ? (1 << 0) : 0;
    mask |= (readId == None)    ? (1 << 1) : 0;
d540 2
a541 2
    if ( (mask != 0x00) && (mask != 0x07) ) {
	return BadMatch;
d543 1
a543 1
    
d545 2
a546 2
    ** Lookup old context.  If we have one, it must be in a usable state.
    */
d548 15
a562 14
	prevglxc = __glXLookupContextByTag(cl, tag);
	if (!prevglxc) {
	    /*
	    ** Tag for previous context is invalid.
	    */
	    return __glXError(GLXBadContextTag);
	}
	if (prevglxc->renderMode != GL_RENDER) {
	    /* Oops.  Not in render mode render. */
	    client->errorValue = prevglxc->id;
	    return __glXError(GLXBadContextState);
	}
    } else {
	prevglxc = 0;
d566 2
a567 2
    ** Lookup new context.  It must not be current for someone else.
    */
d569 1
a569 1
	int  status;
d571 24
a594 23
	if (!validGlxContext(client, contextId, DixUseAccess, &glxc, &error))
	    return error;
	if ((glxc != prevglxc) && glxc->isCurrent) {
	    /* Context is current to somebody else */
	    return BadAccess;
	}

	assert( drawId != None );
	assert( readId != None );

	drawPriv = __glXGetDrawable(glxc, drawId, client, &status);
	if (drawPriv == NULL)
	    return status;

	readPriv = __glXGetDrawable(glxc, readId, client, &status);
	if (readPriv == NULL)
	    return status;

    } else {
	/* Switching to no context.  Ignore new drawable. */
	glxc = 0;
	drawPriv = 0;
	readPriv = 0;
d597 13
d611 11
a621 24
    if (prevglxc) {
	/*
	** Flush the previous context if needed.
	*/
	if (prevglxc->hasUnflushedCommands) {
	    if (__glXForceCurrent(cl, tag, (int *)&error)) {
		CALL_Flush( GET_DISPATCH(), () );
		prevglxc->hasUnflushedCommands = GL_FALSE;
	    } else {
		return error;
	    }
	}

	/*
	** Make the previous context not current.
	*/
	if (!(*prevglxc->loseCurrent)(prevglxc)) {
	    return __glXError(GLXBadContext);
	}
	__glXFlushContextCache();
	if (!prevglxc->isDirect) {
	    prevglxc->drawPriv = NULL;
	    prevglxc->readPriv = NULL;
	}
a622 1
	
d626 2
a627 2
	glxc->drawPriv = drawPriv;
	glxc->readPriv = readPriv;
d629 6
a634 6
	/* make the context current */
	if (!(*glxc->makeCurrent)(glxc)) {
	    glxc->drawPriv = NULL;
	    glxc->readPriv = NULL;
	    return __glXError(GLXBadContext);
	}
d636 1
a636 1
	glxc->isCurrent = GL_TRUE;
d642 5
a646 4
	StartUsingContext(cl, glxc);
	reply.contextTag = glxc->id;
    } else {
	reply.contextTag = 0;
d654 4
a657 3
	__glXSwapMakeCurrentReply(client, &reply);
    } else {
	WriteToClient(client, sz_xGLXMakeCurrentReply, (char *)&reply);
d662 2
a663 1
int __glXDisp_MakeCurrent(__GLXclientState *cl, GLbyte *pc)
d670 2
a671 2
    return DoMakeCurrent( cl, req->drawable, req->drawable,
			  req->context, req->oldContextTag );
d674 2
a675 1
int __glXDisp_MakeContextCurrent(__GLXclientState *cl, GLbyte *pc)
d682 2
a683 2
    return DoMakeCurrent( cl, req->drawable, req->readdrawable,
			  req->context, req->oldContextTag );
d686 2
a687 1
int __glXDisp_MakeCurrentReadSGI(__GLXclientState *cl, GLbyte *pc)
d694 2
a695 2
    return DoMakeCurrent( cl, req->drawable, req->readable,
			  req->context, req->oldContextTag );
d698 2
a699 1
int __glXDisp_IsDirect(__GLXclientState *cl, GLbyte *pc)
d710 1
a710 1
	return err;
d718 4
a721 3
	__glXSwapIsDirectReply(client, &reply);
    } else {
	WriteToClient(client, sz_xGLXIsDirectReply, (char *)&reply);
d727 2
a728 1
int __glXDisp_QueryVersion(__GLXclientState *cl, GLbyte *pc)
d739 2
a740 2
    (void)major;
    (void)minor;
d743 4
a746 4
    ** Server should take into consideration the version numbers sent by the
    ** client if it wants to work with older clients; however, in this
    ** implementation the server just returns its version number.
    */
d754 4
a757 3
	__glXSwapQueryVersionReply(client, &reply);
    } else {
	WriteToClient(client, sz_xGLXQueryVersionReply, (char *)&reply);
d762 2
a763 1
int __glXDisp_WaitGL(__GLXclientState *cl, GLbyte *pc)
d766 1
a766 1
    xGLXWaitGLReq *req = (xGLXWaitGLReq *)pc;
d775 6
a780 6
	glxc = __glXLookupContextByTag(cl, tag);
	if (!glxc)
	    return __glXError(GLXBadContextTag);
    
	if (!__glXForceCurrent(cl, req->contextTag, &error))
	    return error;
d782 1
a782 1
	CALL_Finish( GET_DISPATCH(), () );
d786 1
a786 1
	(*glxc->drawPriv->waitGL)(glxc->drawPriv);
d791 2
a792 1
int __glXDisp_WaitX(__GLXclientState *cl, GLbyte *pc)
d795 1
a795 1
    xGLXWaitXReq *req = (xGLXWaitXReq *)pc;
d804 6
a809 6
	glxc = __glXLookupContextByTag(cl, tag);
	if (!glxc)
	    return __glXError(GLXBadContextTag);
    
	if (!__glXForceCurrent(cl, req->contextTag, &error))
	    return error;
d813 1
a813 1
	(*glxc->drawPriv->waitX)(glxc->drawPriv);
d818 2
a819 1
int __glXDisp_CopyContext(__GLXclientState *cl, GLbyte *pc)
d837 1
a837 1
	return error;
d839 1
a839 1
	return error;
d842 6
a847 7
    ** They must be in the same address space, and same screen.
    ** NOTE: no support for direct rendering contexts here.
    */
    if (src->isDirect || dst->isDirect ||
	(src->pGlxScreen != dst->pGlxScreen)) {
	client->errorValue = source;
	return BadMatch;
d851 2
a852 2
    ** The destination context must not be current for any client.
    */
d854 2
a855 2
	client->errorValue = dest;
	return BadAccess;
d859 27
a885 26
	__GLXcontext *tagcx = __glXLookupContextByTag(cl, tag);
	
	if (!tagcx) {
	    return __glXError(GLXBadContextTag);
	}
	if (tagcx != src) {
	    /*
	    ** This would be caused by a faulty implementation of the client
	    ** library.
	    */
	    return BadMatch;
	}
	/*
	** In this case, glXCopyContext is in both GL and X streams, in terms
	** of sequentiality.
	*/
	if (__glXForceCurrent(cl, tag, &error)) {
	    /*
	    ** Do whatever is needed to make sure that all preceding requests
	    ** in both streams are completed before the copy is executed.
	    */
	    CALL_Finish( GET_DISPATCH(), () );
	    tagcx->hasUnflushedCommands = GL_FALSE;
	} else {
	    return error;
	}
d888 5
a892 5
    ** Issue copy.  The only reason for failure is a bad mask.
    */
    if (!(*dst->copy)(dst, src, mask)) {
	client->errorValue = mask;
	return BadValue;
d906 2
a907 1
int __glXDisp_GetVisualConfigs(__GLXclientState *cl, GLbyte *pc)
d916 1
d923 1
a923 1
	return err;
d927 2
a928 1
    reply.length = (reply.numVisuals * __GLX_SIZE_CARD32 * GLX_VIS_CONFIG_TOTAL) >> 2;
d933 4
a936 4
	__GLX_SWAP_SHORT(&reply.sequenceNumber);
	__GLX_SWAP_INT(&reply.length);
	__GLX_SWAP_INT(&reply.numVisuals);
	__GLX_SWAP_INT(&reply.numProps);
d939 1
a939 1
    WriteToClient(client, sz_xGLXGetVisualConfigsReply, (char *)&reply);
d942 1
a942 1
	modes = pGlxScreen->visuals[i];
d944 53
a996 53
	p = 0;
	buf[p++] = modes->visualID;
	buf[p++] = glxConvertToXVisualType( modes->visualType );
	buf[p++] = (modes->renderType & GLX_RGBA_BIT) ? GL_TRUE : GL_FALSE;

	buf[p++] = modes->redBits;
	buf[p++] = modes->greenBits;
	buf[p++] = modes->blueBits;
	buf[p++] = modes->alphaBits;
	buf[p++] = modes->accumRedBits;
	buf[p++] = modes->accumGreenBits;
	buf[p++] = modes->accumBlueBits;
	buf[p++] = modes->accumAlphaBits;

	buf[p++] = modes->doubleBufferMode;
	buf[p++] = modes->stereoMode;

	buf[p++] = modes->rgbBits;
	buf[p++] = modes->depthBits;
	buf[p++] = modes->stencilBits;
	buf[p++] = modes->numAuxBuffers;
	buf[p++] = modes->level;

	assert(p == GLX_VIS_CONFIG_UNPAIRED);
	/* 
	** Add token/value pairs for extensions.
	*/
	buf[p++] = GLX_VISUAL_CAVEAT_EXT;
	buf[p++] = modes->visualRating;
	buf[p++] = GLX_TRANSPARENT_TYPE;
	buf[p++] = modes->transparentPixel;
	buf[p++] = GLX_TRANSPARENT_RED_VALUE;
	buf[p++] = modes->transparentRed;
	buf[p++] = GLX_TRANSPARENT_GREEN_VALUE;
	buf[p++] = modes->transparentGreen;
	buf[p++] = GLX_TRANSPARENT_BLUE_VALUE;
	buf[p++] = modes->transparentBlue;
	buf[p++] = GLX_TRANSPARENT_ALPHA_VALUE;
	buf[p++] = modes->transparentAlpha;
	buf[p++] = GLX_TRANSPARENT_INDEX_VALUE;
	buf[p++] = modes->transparentIndex;
	buf[p++] = GLX_SAMPLES_SGIS;
	buf[p++] = modes->samples;
	buf[p++] = GLX_SAMPLE_BUFFERS_SGIS;
	buf[p++] = modes->sampleBuffers;
	buf[p++] = 0; /* copy over visualSelectGroup (GLX_VISUAL_SELECT_GROUP_SGIX)? */
	buf[p++] = 0;

	assert(p == GLX_VIS_CONFIG_TOTAL);
	if (client->swapped) {
	    __GLX_SWAP_INT_ARRAY(buf, p);
	}
	WriteToClient(client, __GLX_SIZE_CARD32 * p, (char *)buf);
d1014 1
a1014 1
DoGetFBConfigs(__GLXclientState *cl, unsigned screen)
d1022 1
d1027 1
a1027 1
	return err;
d1036 4
a1039 4
	__GLX_SWAP_SHORT(&reply.sequenceNumber);
	__GLX_SWAP_INT(&reply.length);
	__GLX_SWAP_INT(&reply.numFBConfigs);
	__GLX_SWAP_INT(&reply.numAttribs);
d1042 1
a1042 1
    WriteToClient(client, sz_xGLXGetFBConfigsReply, (char *)&reply);
d1045 1
a1045 1
	p = 0;
d1050 47
a1096 46
	WRITE_PAIR( GLX_VISUAL_ID,        modes->visualID );
	WRITE_PAIR( GLX_FBCONFIG_ID,      modes->fbconfigID );
	WRITE_PAIR( GLX_X_RENDERABLE,     GL_TRUE );

	WRITE_PAIR( GLX_RGBA,
		    (modes->renderType & GLX_RGBA_BIT) ? GL_TRUE : GL_FALSE );
	WRITE_PAIR( GLX_RENDER_TYPE,      modes->renderType );
	WRITE_PAIR( GLX_DOUBLEBUFFER,     modes->doubleBufferMode );
	WRITE_PAIR( GLX_STEREO,           modes->stereoMode );

	WRITE_PAIR( GLX_BUFFER_SIZE,      modes->rgbBits );
	WRITE_PAIR( GLX_LEVEL,            modes->level );
	WRITE_PAIR( GLX_AUX_BUFFERS,      modes->numAuxBuffers );
	WRITE_PAIR( GLX_RED_SIZE,         modes->redBits );
	WRITE_PAIR( GLX_GREEN_SIZE,       modes->greenBits );
	WRITE_PAIR( GLX_BLUE_SIZE,        modes->blueBits );
	WRITE_PAIR( GLX_ALPHA_SIZE,       modes->alphaBits );
	WRITE_PAIR( GLX_ACCUM_RED_SIZE,   modes->accumRedBits );
	WRITE_PAIR( GLX_ACCUM_GREEN_SIZE, modes->accumGreenBits );
	WRITE_PAIR( GLX_ACCUM_BLUE_SIZE,  modes->accumBlueBits );
	WRITE_PAIR( GLX_ACCUM_ALPHA_SIZE, modes->accumAlphaBits );
	WRITE_PAIR( GLX_DEPTH_SIZE,       modes->depthBits );
	WRITE_PAIR( GLX_STENCIL_SIZE,     modes->stencilBits );
	WRITE_PAIR( GLX_X_VISUAL_TYPE,    modes->visualType );
	WRITE_PAIR( GLX_CONFIG_CAVEAT, modes->visualRating );
	WRITE_PAIR( GLX_TRANSPARENT_TYPE, modes->transparentPixel );
	WRITE_PAIR( GLX_TRANSPARENT_RED_VALUE, modes->transparentRed );
	WRITE_PAIR( GLX_TRANSPARENT_GREEN_VALUE, modes->transparentGreen );
	WRITE_PAIR( GLX_TRANSPARENT_BLUE_VALUE, modes->transparentBlue );
	WRITE_PAIR( GLX_TRANSPARENT_ALPHA_VALUE, modes->transparentAlpha );
	WRITE_PAIR( GLX_TRANSPARENT_INDEX_VALUE, modes->transparentIndex );
	WRITE_PAIR( GLX_SWAP_METHOD_OML, modes->swapMethod );
	WRITE_PAIR( GLX_SAMPLES_SGIS, modes->samples );
	WRITE_PAIR( GLX_SAMPLE_BUFFERS_SGIS, modes->sampleBuffers );
	/* GLX_VISUAL_SELECT_GROUP_SGIX ? */
	WRITE_PAIR( GLX_DRAWABLE_TYPE, modes->drawableType );
	WRITE_PAIR( GLX_BIND_TO_TEXTURE_RGB_EXT, modes->bindToTextureRgb );
	WRITE_PAIR( GLX_BIND_TO_TEXTURE_RGBA_EXT, modes->bindToTextureRgba );
	WRITE_PAIR( GLX_BIND_TO_MIPMAP_TEXTURE_EXT, modes->bindToMipmapTexture );
	WRITE_PAIR( GLX_BIND_TO_TEXTURE_TARGETS_EXT, modes->bindToTextureTargets );

	if (client->swapped) {
	    __GLX_SWAP_INT_ARRAY(buf, __GLX_FBCONFIG_ATTRIBS_LENGTH);
	}
	WriteToClient(client, __GLX_SIZE_CARD32 * __GLX_FBCONFIG_ATTRIBS_LENGTH,
		      (char *)buf);
d1101 2
a1102 2

int __glXDisp_GetFBConfigs(__GLXclientState *cl, GLbyte *pc)
d1106 1
d1111 2
a1112 1
int __glXDisp_GetFBConfigsSGIX(__GLXclientState *cl, GLbyte *pc)
d1116 1
d1123 3
a1125 3
__glXDrawableInit(__GLXdrawable *drawable,
		  __GLXscreen *screen, DrawablePtr pDraw, int type,
		  XID drawId, __GLXconfig *config)
d1137 1
a1137 1
__glXDrawableRelease(__GLXdrawable *drawable)
d1141 4
a1144 4
static int 
DoCreateGLXDrawable(ClientPtr client, __GLXscreen *pGlxScreen,
		    __GLXconfig *config, DrawablePtr pDraw, XID drawableId,
		    XID glxDrawableId, int type)
d1149 1
a1149 1
	return BadMatch;
d1152 2
a1153 2
					  drawableId, type,
					  glxDrawableId, config);
d1155 1
a1155 1
	return BadAlloc;
d1158 2
a1159 2
	pGlxDraw->destroy (pGlxDraw);
	return BadAlloc;
d1167 3
a1169 3
	!AddResource(pDraw->id, __glXDrawableRes, pGlxDraw)) {
	pGlxDraw->destroy (pGlxDraw);
	return BadAlloc;
d1176 2
a1177 2
DoCreateGLXPixmap(ClientPtr client, __GLXscreen *pGlxScreen, __GLXconfig *config,
		  XID drawableId, XID glxDrawableId)
d1186 2
a1187 2
	client->errorValue = drawableId;
	return err;
d1190 2
a1191 2
	client->errorValue = drawableId;
	return BadPixmap;
d1195 1
a1195 1
			      glxDrawableId, GLX_DRAWABLE_PIXMAP);
d1197 1
a1197 1
    ((PixmapPtr)pDraw)->refcnt++;
d1204 1
a1204 1
		       CARD32 *attribs, CARD32 numAttribs)
d1212 3
a1214 3
			  DixWriteAccess, &pGlxDraw, &err))
	/* We just added it in CreatePixmap, so we should never get here. */
	return;
d1217 10
a1226 10
	if (attribs[2 * i] == GLX_TEXTURE_TARGET_EXT) {
	    switch (attribs[2 * i + 1]) {
	    case GLX_TEXTURE_2D_EXT:
		target = GL_TEXTURE_2D;
		break;
	    case GLX_TEXTURE_RECTANGLE_EXT:
		target = GL_TEXTURE_RECTANGLE_ARB;
		break;
	    }
	}
d1228 2
a1229 2
	if (attribs[2 * i] == GLX_TEXTURE_FORMAT_EXT)
		format = attribs[2 * i + 1];
d1231 1
a1231 1
 
d1233 6
a1238 6
	int w = pGlxDraw->pDraw->width, h = pGlxDraw->pDraw->height;
	
	if (h & (h - 1) || w & (w - 1))
	    target = GL_TEXTURE_RECTANGLE_ARB;
	else
	    target = GL_TEXTURE_2D;
d1245 2
a1246 1
int __glXDisp_CreateGLXPixmap(__GLXclientState *cl, GLbyte *pc)
d1257 1
a1257 1
	return err;
d1259 1
a1259 1
	return err;
d1262 1
a1262 1
			     req->pixmap, req->glxpixmap);
d1265 2
a1266 1
int __glXDisp_CreatePixmap(__GLXclientState *cl, GLbyte *pc)
d1276 2
a1277 2
	client->errorValue = req->numAttribs;
	return BadValue;
d1282 1
a1282 1
	return err;
d1284 1
a1284 1
	return err;
d1287 1
a1287 1
			    req->pixmap, req->glxpixmap);
d1289 1
a1289 1
	return err;
d1292 1
a1292 1
			   (CARD32*) (req + 1), req->numAttribs);
d1297 2
a1298 1
int __glXDisp_CreateGLXPixmapWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)
d1301 2
a1302 2
    xGLXCreateGLXPixmapWithConfigSGIXReq *req = 
	(xGLXCreateGLXPixmapWithConfigSGIXReq *) pc;
d1310 1
a1310 1
	return err;
d1312 1
a1312 1
	return err;
d1315 1
a1315 1
			     config, req->pixmap, req->glxpixmap);
d1318 2
a1319 2

static int DoDestroyDrawable(__GLXclientState *cl, XID glxdrawable, int type)
d1325 2
a1326 2
			  DixDestroyAccess, &pGlxDraw, &err))
	return err;
d1333 2
a1334 1
int __glXDisp_DestroyGLXPixmap(__GLXclientState *cl, GLbyte *pc)
d1344 2
a1345 1
int __glXDisp_DestroyPixmap(__GLXclientState *cl, GLbyte *pc)
d1359 1
a1359 1
		int width, int height, XID glxDrawableId)
d1361 4
a1364 4
    __GLXconfig	*config;
    __GLXscreen		*pGlxScreen;
    PixmapPtr		 pPixmap;
    int			 err;
d1369 1
a1369 1
	return err;
d1371 1
a1371 1
	return err;
d1375 2
a1376 1
						    width, height, config->rgbBits, 0);
d1384 1
a1384 1
	return BadAlloc;
d1387 2
a1388 2
			       glxDrawableId, glxDrawableId,
			       GLX_DRAWABLE_PBUFFER);
d1391 2
a1392 1
int __glXDisp_CreatePbuffer(__GLXclientState *cl, GLbyte *pc)
d1395 3
a1397 3
    xGLXCreatePbufferReq	*req = (xGLXCreatePbufferReq *) pc;
    CARD32			*attrs;
    int				 width, height, i;
d1401 2
a1402 2
	client->errorValue = req->numAttribs;
	return BadValue;
d1411 12
a1422 12
	switch (attrs[i * 2]) {
	case GLX_PBUFFER_WIDTH:
	    width = attrs[i * 2 + 1];
	    break;
	case GLX_PBUFFER_HEIGHT:
	    height = attrs[i * 2 + 1];
	    break;
	case GLX_LARGEST_PBUFFER:
	case GLX_PRESERVED_CONTENTS:
	    /* FIXME: huh... */
	    break;
	}
d1426 1
a1426 1
			   width, height, req->pbuffer);
d1429 2
a1430 1
int __glXDisp_CreateGLXPbufferSGIX(__GLXclientState *cl, GLbyte *pc)
d1438 1
a1438 1
			   req->width, req->height, req->pbuffer);
d1441 2
a1442 1
int __glXDisp_DestroyPbuffer(__GLXclientState *cl, GLbyte *pc)
d1452 2
a1453 1
int __glXDisp_DestroyGLXPbufferSGIX(__GLXclientState *cl, GLbyte *pc)
d1465 1
a1465 1
			   int numAttribs, CARD32 *attribs)
d1471 2
a1472 2
			  DixSetAttrAccess, &pGlxDraw, &err))
	return err;
d1475 8
a1482 8
	switch(attribs[i * 2]) {
	case GLX_EVENT_MASK:
	    /* All we do is to record the event mask so we can send it
	     * back when queried.  We never actually clobber the
	     * pbuffers, so we never need to send out the event. */
	    pGlxDraw->eventMask = attribs[i * 2 + 1];
	    break;
	}
d1488 2
a1489 1
int __glXDisp_ChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
d1493 1
a1493 1
	(xGLXChangeDrawableAttributesReq *) pc;
d1497 2
a1498 2
	client->errorValue = req->numAttribs;
	return BadValue;
d1504 3
a1506 2
    if (((sizeof(xGLXChangeDrawableAttributesReq) + (req->numAttribs << 3)) >> 2) < client->req_len)
	    return BadLength;
d1510 1
a1510 1
				      req->numAttribs, (CARD32 *) (req + 1));
d1513 2
a1514 1
int __glXDisp_ChangeDrawableAttributesSGIX(__GLXclientState *cl, GLbyte *pc)
d1518 1
a1518 1
	(xGLXChangeDrawableAttributesSGIXReq *)pc;
d1522 2
a1523 2
	client->errorValue = req->numAttribs;
	return BadValue;
d1525 2
a1526 1
    REQUEST_FIXED_SIZE(xGLXChangeDrawableAttributesSGIXReq, req->numAttribs << 3);
d1529 1
a1529 1
				      req->numAttribs, (CARD32 *) (req + 1));
d1532 2
a1533 1
int __glXDisp_CreateWindow(__GLXclientState *cl, GLbyte *pc)
d1535 6
a1540 6
    xGLXCreateWindowReq	*req = (xGLXCreateWindowReq *) pc;
    __GLXconfig	*config;
    __GLXscreen		*pGlxScreen;
    ClientPtr		 client = cl->client;
    DrawablePtr		 pDraw;
    int			 err;
d1544 2
a1545 2
	client->errorValue = req->numAttribs;
	return BadValue;
d1552 1
a1552 1
	return err;
d1554 1
a1554 1
	return err;
d1558 2
a1559 2
	client->errorValue = req->window;
	return BadWindow;
d1563 1
a1563 1
	return err;
d1566 2
a1567 2
			       pDraw, req->window,
			       req->glxwindow, GLX_DRAWABLE_WINDOW);
d1570 2
a1571 1
int __glXDisp_DestroyWindow(__GLXclientState *cl, GLbyte *pc)
a1581 1

d1589 2
a1590 1
int __glXDisp_SwapBuffers(__GLXclientState *cl, GLbyte *pc)
d1605 20
a1624 19
	glxc = __glXLookupContextByTag(cl, tag);
	if (!glxc) {
	    return __glXError(GLXBadContextTag);
	}
	/*
	** The calling thread is swapping its current drawable.  In this case,
	** glxSwapBuffers is in both GL and X streams, in terms of
	** sequentiality.
	*/
	if (__glXForceCurrent(cl, tag, &error)) {
	    /*
	    ** Do whatever is needed to make sure that all preceding requests
	    ** in both streams are completed before the swap is executed.
	    */
	    CALL_Finish( GET_DISPATCH(), () );
	    glxc->hasUnflushedCommands = GL_FALSE;
	} else {
	    return error;
	}
d1629 1
a1629 1
	return error;
d1632 2
a1633 2
	(*pGlxDraw->swapBuffers)(cl->client, pGlxDraw) == GL_FALSE)
	return __glXError(GLXBadDrawable);
a1637 1

d1639 1
a1639 1
DoQueryContext(__GLXclientState *cl, GLXContextID gcId)
d1650 1
a1650 1
	return err;
d1659 1
a1659 1
    sendBuf = (int *)malloc((size_t)nReplyBytes);
d1661 1
a1661 1
	return __glXError(GLXBadContext);	/* XXX: Is this correct? */
d1665 1
a1665 1
    *pSendBuf++ = (int)(ctx->share_id);
d1667 1
a1667 1
    *pSendBuf++ = (int)(ctx->config->visualID);
d1669 1
a1669 1
    *pSendBuf++ = (int)(ctx->pGlxScreen->pScreen->myNum);
d1672 5
a1676 4
	__glXSwapQueryContextInfoEXTReply(client, &reply, sendBuf);
    } else {
	WriteToClient(client, sz_xGLXQueryContextInfoEXTReply, (char *)&reply);
	WriteToClient(client, nReplyBytes, (char *)sendBuf);
d1678 1
a1678 1
    free((char *)sendBuf);
d1683 2
a1684 1
int __glXDisp_QueryContextInfoEXT(__GLXclientState *cl, GLbyte *pc)
d1694 2
a1695 1
int __glXDisp_QueryContext(__GLXclientState *cl, GLbyte *pc)
d1705 2
a1706 1
int __glXDisp_BindTexImageEXT(__GLXclientState *cl, GLbyte *pc)
d1709 7
a1715 7
    ClientPtr		 client = cl->client;
    __GLXcontext	*context;
    __GLXdrawable	*pGlxDraw;
    GLXDrawable		 drawId;
    int			 buffer;
    int			 error;
    CARD32		 num_attribs;
d1718 1
a1718 1
	return BadLength;
d1723 1
a1723 1
    buffer = *((INT32 *)  (pc + 4));
d1726 2
a1727 2
	client->errorValue = num_attribs;
	return BadValue;
d1732 1
a1732 1
	return __glXError(GLXBadPixmap);
d1734 1
a1734 1
    context = __glXForceCurrent (cl, req->contextTag, &error);
d1736 1
a1736 1
	return error;
d1739 2
a1740 2
			  DixReadAccess, &pGlxDraw, &error))
	return error;
d1743 1
a1743 1
	return __glXError(GLXUnsupportedPrivateRequest);
d1745 1
a1745 3
    return context->textureFromPixmap->bindTexImage(context,
						    buffer,
						    pGlxDraw);
d1748 2
a1749 1
int __glXDisp_ReleaseTexImageEXT(__GLXclientState *cl, GLbyte *pc)
d1752 6
a1757 6
    ClientPtr		 client = cl->client;
    __GLXdrawable	*pGlxDraw;
    __GLXcontext	*context;
    GLXDrawable		 drawId;
    int			 buffer;
    int			 error;
d1764 3
a1766 3
    buffer = *((INT32 *)  (pc + 4));
    
    context = __glXForceCurrent (cl, req->contextTag, &error);
d1768 1
a1768 1
	return error;
d1771 2
a1772 2
			  DixReadAccess, &pGlxDraw, &error))
	return error;
d1775 1
a1775 1
	return __glXError(GLXUnsupportedPrivateRequest);
d1778 1
a1778 2
						       buffer,
						       pGlxDraw);
d1781 2
a1782 1
int __glXDisp_CopySubBufferMESA(__GLXclientState *cl, GLbyte *pc)
d1785 7
a1791 7
    GLXContextTag         tag = req->contextTag;
    __GLXcontext         *glxc = NULL;
    __GLXdrawable        *pGlxDraw;
    ClientPtr		  client = cl->client;
    GLXDrawable		  drawId;
    int                   error;
    int                   x, y, width, height;
d1801 4
a1804 4
    x      = *((INT32 *)  (pc + 4));
    y      = *((INT32 *)  (pc + 8));
    width  = *((INT32 *)  (pc + 12));
    height = *((INT32 *)  (pc + 16));
d1807 20
a1826 19
	glxc = __glXLookupContextByTag(cl, tag);
	if (!glxc) {
	    return __glXError(GLXBadContextTag);
	}
	/*
	** The calling thread is swapping its current drawable.  In this case,
	** glxSwapBuffers is in both GL and X streams, in terms of
	** sequentiality.
	*/
	if (__glXForceCurrent(cl, tag, &error)) {
	    /*
	    ** Do whatever is needed to make sure that all preceding requests
	    ** in both streams are completed before the swap is executed.
	    */
	    CALL_Finish( GET_DISPATCH(), () );
	    glxc->hasUnflushedCommands = GL_FALSE;
	} else {
	    return error;
	}
d1831 1
a1831 1
	return error;
d1834 3
a1836 3
	pGlxDraw->type != GLX_DRAWABLE_WINDOW ||
	pGlxDraw->copySubBuffer == NULL)
	return __glXError(GLXBadDrawable);
d1838 1
a1838 1
    (*pGlxDraw->copySubBuffer)(pGlxDraw, x, y, width, height);
d1847 1
a1847 1
DoGetDrawableAttributes(__GLXclientState *cl, XID drawId)
d1856 2
a1857 2
			  DixGetAttrAccess, &pGlxDraw, &error))
	return error;
d1867 1
a1867 1
	GLX_TEXTURE_RECTANGLE_EXT;
d1874 7
a1880 6
	__glXSwapGetDrawableAttributesReply(client, &reply, attributes);
    } else {
	WriteToClient(client, sz_xGLXGetDrawableAttributesReply,
		      (char *)&reply);
	WriteToClient(client, reply.length * sizeof (CARD32),
		      (char *)attributes);
d1886 2
a1887 1
int __glXDisp_GetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
d1890 1
a1890 1
    xGLXGetDrawableAttributesReq *req = (xGLXGetDrawableAttributesReq *)pc;
d1898 2
a1899 1
int __glXDisp_GetDrawableAttributesSGIX(__GLXclientState *cl, GLbyte *pc)
d1903 2
a1904 2
	(xGLXGetDrawableAttributesSGIXReq *)pc;
    
d1920 2
a1921 1
int __glXDisp_Render(__GLXclientState *cl, GLbyte *pc)
d1924 1
a1924 1
    ClientPtr client= cl->client;
d1930 1
d1937 2
a1938 2
	__GLX_SWAP_SHORT(&req->length);
	__GLX_SWAP_INT(&req->contextTag);
d1943 1
a1943 1
	return error;
d1952 2
a1953 2
	__GLXdispatchRenderProcPtr proc;
	int err;
d1955 2
a1956 2
	if (left < sizeof(__GLXrenderHeader))
	    return BadLength;
d1958 24
a1981 24
	/*
	** Verify that the header length and the overall length agree.
	** Also, each command must be word aligned.
	*/
	hdr = (__GLXrenderHeader *) pc;
	if (client->swapped) {
	    __GLX_SWAP_SHORT(&hdr->length);
	    __GLX_SWAP_SHORT(&hdr->opcode);
	}
	cmdlen = hdr->length;
	opcode = hdr->opcode;

	/*
	** Check for core opcodes and grab entry data.
	*/
	err = __glXGetProtocolSizeData(& Render_dispatch_info, opcode, & entry);
	proc = (__GLXdispatchRenderProcPtr)
	    __glXGetProtocolDecodeFunction(& Render_dispatch_info,
					   opcode, client->swapped);

	if ((err < 0) || (proc == NULL)) {
	    client->errorValue = commandsDone;
	    return __glXError(GLXBadRenderRequest);
	}
d1985 2
a1986 2
            extra = (*entry.varsize)(pc + __GLX_RENDER_HDR_SIZE,
				     client->swapped);
d1993 2
a1994 1
        } else {
d2000 15
a2014 15
	if (left < cmdlen) {
	    return BadLength;
	}

	/*
	** Skip over the header and execute the command.  We allow the
	** caller to trash the command memory.  This is useful especially
	** for things that require double alignment - they can just shift
	** the data towards lower memory (trashing the header) by 4 bytes
	** and achieve the required alignment.
	*/
	(*proc)(pc + __GLX_RENDER_HDR_SIZE);
	pc += cmdlen;
	left -= cmdlen;
	commandsDone++;
a2019 1

d2023 2
a2024 1
int __glXDisp_RenderLarge(__GLXclientState *cl, GLbyte *pc)
d2027 1
a2027 1
    ClientPtr client= cl->client;
d2033 1
d2035 1
a2035 1
    
d2038 5
a2042 5
	__GLX_SWAP_SHORT(&req->length);
	__GLX_SWAP_INT(&req->contextTag);
	__GLX_SWAP_INT(&req->dataBytes);
	__GLX_SWAP_SHORT(&req->requestNumber);
	__GLX_SWAP_SHORT(&req->requestTotal);
d2047 3
a2049 3
	/* Reset in case this isn't 1st request. */
	__glXResetLargeCommandStatus(cl);
	return error;
d2054 2
a2055 2
    ** Check the request length.
    */
d2057 4
a2060 4
	client->errorValue = req->length;
	/* Reset in case this isn't 1st request. */
	__glXResetLargeCommandStatus(cl);
	return BadLength;
d2063 1
a2063 1
    
d2065 165
a2229 161
	__GLXrenderSizeData entry;
	int extra;
	size_t cmdlen;
	int err;

	/*
	** This is the first request of a multi request command.
	** Make enough space in the buffer, then copy the entire request.
	*/
	if (req->requestNumber != 1) {
	    client->errorValue = req->requestNumber;
	    return __glXError(GLXBadLargeRequest);
	}

	hdr = (__GLXrenderLargeHeader *) pc;
	if (client->swapped) {
	    __GLX_SWAP_INT(&hdr->length);
	    __GLX_SWAP_INT(&hdr->opcode);
	}
	cmdlen = hdr->length;
	opcode = hdr->opcode;

	/*
	** Check for core opcodes and grab entry data.
	*/
	err = __glXGetProtocolSizeData(& Render_dispatch_info, opcode, & entry);
	if (err < 0) {
	    client->errorValue = opcode;
	    return __glXError(GLXBadLargeRequest);
	}

	if (entry.varsize) {
	    /*
	    ** If it's a variable-size command (a command whose length must
	    ** be computed from its parameters), all the parameters needed
	    ** will be in the 1st request, so it's okay to do this.
	    */
	    extra = (*entry.varsize)(pc + __GLX_RENDER_LARGE_HDR_SIZE,
				     client->swapped);
	    if (extra < 0) {
		extra = 0;
	    }
	    /* large command's header is 4 bytes longer, so add 4 */
	    if (cmdlen != __GLX_PAD(entry.bytes + 4 + extra)) {
		return BadLength;
	    }
	} else {
	    /* constant size command */
	    if (cmdlen != __GLX_PAD(entry.bytes + 4)) {
		return BadLength;
	    }
	}
	/*
	** Make enough space in the buffer, then copy the entire request.
	*/
	if (cl->largeCmdBufSize < cmdlen) {
	    if (!cl->largeCmdBuf) {
		cl->largeCmdBuf = (GLbyte *) malloc(cmdlen);
	    } else {
		cl->largeCmdBuf = (GLbyte *) realloc(cl->largeCmdBuf, cmdlen);
	    }
	    if (!cl->largeCmdBuf) {
		return BadAlloc;
	    }
	    cl->largeCmdBufSize = cmdlen;
	}
	memcpy(cl->largeCmdBuf, pc, dataBytes);

	cl->largeCmdBytesSoFar = dataBytes;
	cl->largeCmdBytesTotal = cmdlen;
	cl->largeCmdRequestsSoFar = 1;
	cl->largeCmdRequestsTotal = req->requestTotal;
	return Success;
	
    } else {
	/*
	** We are receiving subsequent (i.e. not the first) requests of a
	** multi request command.
	*/

	/*
	** Check the request number and the total request count.
	*/
	if (req->requestNumber != cl->largeCmdRequestsSoFar + 1) {
	    client->errorValue = req->requestNumber;
	    __glXResetLargeCommandStatus(cl);
	    return __glXError(GLXBadLargeRequest);
	}
	if (req->requestTotal != cl->largeCmdRequestsTotal) {
	    client->errorValue = req->requestTotal;
	    __glXResetLargeCommandStatus(cl);
	    return __glXError(GLXBadLargeRequest);
	}

	/*
	** Check that we didn't get too much data.
	*/
	if ((cl->largeCmdBytesSoFar + dataBytes) > cl->largeCmdBytesTotal) {
	    client->errorValue = dataBytes;
	    __glXResetLargeCommandStatus(cl);
	    return __glXError(GLXBadLargeRequest);
	}
	memcpy(cl->largeCmdBuf + cl->largeCmdBytesSoFar, pc, dataBytes);
	cl->largeCmdBytesSoFar += dataBytes;
	cl->largeCmdRequestsSoFar++;

	if (req->requestNumber == cl->largeCmdRequestsTotal) {
	    __GLXdispatchRenderProcPtr proc;

	    /*
	    ** This is the last request; it must have enough bytes to complete
	    ** the command.
	    */
	    /* NOTE: the two pad macros have been added below; they are needed
	    ** because the client library pads the total byte count, but not
	    ** the per-request byte counts.  The Protocol Encoding says the
	    ** total byte count should not be padded, so a proposal will be 
	    ** made to the ARB to relax the padding constraint on the total 
	    ** byte count, thus preserving backward compatibility.  Meanwhile, 
	    ** the padding done below fixes a bug that did not allow
	    ** large commands of odd sizes to be accepted by the server.
	    */
	    if (__GLX_PAD(cl->largeCmdBytesSoFar) !=
		__GLX_PAD(cl->largeCmdBytesTotal)) {
		client->errorValue = dataBytes;
		__glXResetLargeCommandStatus(cl);
		return __glXError(GLXBadLargeRequest);
	    }
	    hdr = (__GLXrenderLargeHeader *) cl->largeCmdBuf;
	    /*
	    ** The opcode and length field in the header had already been
	    ** swapped when the first request was received.
	    **
	    ** Use the opcode to index into the procedure table.
	    */
	    opcode = hdr->opcode;

	    proc = (__GLXdispatchRenderProcPtr)
	      __glXGetProtocolDecodeFunction(& Render_dispatch_info, opcode,
					     client->swapped);
	    if (proc == NULL) {
		client->errorValue = opcode;
		return __glXError(GLXBadLargeRequest);
	    }

	    /*
	    ** Skip over the header and execute the command.
	    */
	    (*proc)(cl->largeCmdBuf + __GLX_RENDER_LARGE_HDR_SIZE);
	    glxc->hasUnflushedCommands = GL_TRUE;

	    /*
	    ** Reset for the next RenderLarge series.
	    */
	    __glXResetLargeCommandStatus(cl);
	} else {
	    /*
	    ** This is neither the first nor the last request.
	    */
	}
	return Success;
d2240 2
a2241 1
int __glXDisp_VendorPrivate(__GLXclientState *cl, GLbyte *pc)
d2251 2
a2252 2
      __glXGetProtocolDecodeFunction(& VendorPriv_dispatch_info,
				     vendorcode, 0);
d2254 2
a2255 2
	(*proc)(cl, (GLbyte*)req);
	return Success;
d2262 2
a2263 1
int __glXDisp_VendorPrivateWithReply(__GLXclientState *cl, GLbyte *pc)
d2273 2
a2274 2
      __glXGetProtocolDecodeFunction(& VendorPriv_dispatch_info,
				     vendorcode, 0);
d2276 1
a2276 1
	return (*proc)(cl, (GLbyte*)req);
d2283 2
a2284 1
int __glXDisp_QueryExtensionsString(__GLXclientState *cl, GLbyte *pc)
d2297 1
a2297 1
	return err;
d2306 1
a2306 1
    /* Allocate buffer to make sure it's a multiple of 4 bytes big.*/
d2314 5
a2318 3
    } else {
        WriteToClient(client, sz_xGLXQueryExtensionsStringReply,(char *)&reply);
        WriteToClient(client, (int)(length << 2), (char *)buf);
d2325 2
a2326 1
int __glXDisp_QueryServerString(__GLXclientState *cl, GLbyte *pc)
d2341 1
a2341 1
	return err;
d2343 16
a2358 16
    switch(req->name) {
	case GLX_VENDOR:
	    ptr = pGlxScreen->GLXvendor;
	    break;
	case GLX_VERSION:
	    /* Return to the server version rather than the screen version
	     * to prevent confusion when they do not match.
	     */
	    snprintf(ver_str, 16, "%d.%d", glxMajorVersion, glxMinorVersion);
	    ptr = ver_str;
	    break;
	case GLX_EXTENSIONS:
	    ptr = pGlxScreen->GLXextensions;
	    break;
	default:
	    return BadValue; 
d2376 4
a2379 3
    } else {
        WriteToClient(client, sz_xGLXQueryServerStringReply, (char *)&reply);
        WriteToClient(client, (int)(length << 2), buf);
d2386 2
a2387 1
int __glXDisp_ClientInfo(__GLXclientState *cl, GLbyte *pc)
d2392 1
a2392 1
   
d2395 1
a2395 1
    buf = (const char *)(req+1);
d2397 1
a2397 1
	return BadLength;
@


1.5
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@a40 1
#include "g_disptab.h"
d139 1
a139 1
    if (*err != Success) {
d141 1
a141 1
	if (*err == BadValue)
d317 1
d323 2
d336 1
d342 2
d355 1
d362 2
d372 1
d375 1
d380 2
d386 4
a389 1
    FreeResourceByType(req->context, __glXContextRes, FALSE);
a392 2
/*****************************************************************************/

d394 9
a402 9
** For each client, the server keeps a table of all the contexts that are
** current for that client (each thread of a client may have its own current
** context).  These routines add, change, and lookup contexts in the table.
*/

/*
** Add a current context, and return the tag that will be used to refer to it.
*/
static int AddCurrentContext(__GLXclientState *cl, __GLXcontext *glxc)
d404 1
a404 3
    int i;
    int num = cl->numCurrentContexts;
    __GLXcontext **table = cl->currentContexts;
d406 3
a408 25
    if (!glxc) return -1;
    
    /*
    ** Try to find an empty slot and use it.
    */
    for (i=0; i < num; i++) {
	if (!table[i]) {
	    table[i] = glxc;
	    return i+1;
	}
    }
    /*
    ** Didn't find a free slot, so we'll have to grow the table.
    */
    if (!num) {
	table = (__GLXcontext **) malloc(sizeof(__GLXcontext *));
    } else {
	table = (__GLXcontext **) realloc(table,
					   (num+1)*sizeof(__GLXcontext *));
    }
    table[num] = glxc;
    cl->currentContexts = table;
    cl->numCurrentContexts++;
    return num+1;
}
d410 1
a410 24
/*
** Given a tag, change the current context for the corresponding entry.
*/
static void ChangeCurrentContext(__GLXclientState *cl, __GLXcontext *glxc,
				GLXContextTag tag)
{
    __GLXcontext **table = cl->currentContexts;
    table[tag-1] = glxc;
}

/*
** For this implementation we have chosen to simply use the index of the
** context's entry in the table as the context tag.  A tag must be greater
** than 0.
*/
__GLXcontext *__glXLookupContextByTag(__GLXclientState *cl, GLXContextTag tag)
{
    int num = cl->numCurrentContexts;

    if (tag < 1 || tag > num) {
	return 0;
    } else {
	return cl->currentContexts[tag-1];
    }
d424 1
a424 1
	    __glXFreeContext(glxc);
d589 1
a589 1
	if (__GLX_HAS_UNFLUSHED_CMDS(prevglxc)) {
d592 1
a592 1
		__GLX_NOTE_FLUSHED_CMDS(prevglxc);
d627 1
a627 6
    if (prevglxc) {
	ChangeCurrentContext(cl, glxc, tag);
	StopUsingContext(prevglxc);
    } else {
	tag = AddCurrentContext(cl, glxc);
    }
d631 1
a631 1
	reply.contextTag = tag;
d650 1
d653 2
d661 1
d664 2
d672 1
d675 2
d689 2
d715 2
d743 1
d745 1
a745 1
    GLXContextTag tag = req->contextTag;
d749 3
d771 1
d773 1
a773 1
    GLXContextTag tag = req->contextTag;
d777 3
d799 4
a802 4
    GLXContextID source = req->source;
    GLXContextID dest = req->dest;
    GLXContextTag tag = req->contextTag;
    unsigned long mask = req->mask;
d806 6
d858 1
a858 1
	    __GLX_NOTE_FLUSHED_CMDS(tagcx);
d894 2
d1075 1
d1077 1
d1083 1
d1085 2
d1130 5
a1134 4
    /* Add the glx drawable under the XID of the underlying X drawable
     * too.  That way we'll get a callback in DrawableGone and can
     * clean up properly when the drawable is destroyed. */
    if (drawableId != glxDrawableId &&
d1165 2
d1215 1
d1221 2
d1234 1
d1240 7
d1265 1
d1272 2
d1300 1
d1303 2
d1310 1
d1313 4
d1355 1
d1360 7
d1392 1
d1395 2
d1403 1
d1406 2
d1413 1
d1416 2
d1448 1
d1452 13
d1471 1
d1475 7
d1495 7
d1525 1
d1528 3
d1546 2
a1547 2
    GLXContextTag tag = req->contextTag;
    XID drawId = req->drawable;
d1552 4
d1572 1
a1572 1
	    __GLX_NOTE_FLUSHED_CMDS(glxc);
d1636 1
d1639 2
d1646 1
d1649 2
d1663 4
d1672 6
d1708 2
d1745 2
d1771 1
a1771 1
	    __GLX_NOTE_FLUSHED_CMDS(glxc);
d1835 1
d1838 3
d1846 1
d1850 2
d1876 2
d1898 3
d1958 1
a1958 1
    __GLX_NOTE_UNFLUSHED_CMDS(glxc);
d2155 1
a2155 1
	    __GLX_NOTE_UNFLUSHED_CMDS(glxc);
a2169 232
extern RESTYPE __glXSwapBarrierRes;

int __glXDisp_BindSwapBarrierSGIX(__GLXclientState *cl, GLbyte *pc)
{
    ClientPtr client = cl->client;
    xGLXBindSwapBarrierSGIXReq *req = (xGLXBindSwapBarrierSGIXReq *) pc;
    XID drawable = req->drawable;
    int barrier = req->barrier;
    DrawablePtr pDraw;
    int screen, rc;
    __GLXscreen *pGlxScreen;

    rc = dixLookupDrawable(&pDraw, drawable, client, 0, DixGetAttrAccess);
    pGlxScreen = glxGetScreen(pDraw->pScreen);
    if (rc == Success && (pDraw->type == DRAWABLE_WINDOW)) {
	screen = pDraw->pScreen->myNum;
        if (pGlxScreen->swapBarrierFuncs) {
            int ret = pGlxScreen->swapBarrierFuncs->bindSwapBarrierFunc(screen, drawable, barrier);
            if (ret == Success) {
                if (barrier)
                    /* add source for cleanup when drawable is gone */
                    AddResource(drawable, __glXSwapBarrierRes, (pointer)(intptr_t)screen);
                else
                    /* delete source */
                    FreeResourceByType(drawable, __glXSwapBarrierRes, FALSE);
            }
            return ret;
        }
    }
    client->errorValue = drawable;
    return __glXError(GLXBadDrawable);
}


int __glXDisp_QueryMaxSwapBarriersSGIX(__GLXclientState *cl, GLbyte *pc)
{
    ClientPtr client = cl->client;
    xGLXQueryMaxSwapBarriersSGIXReq *req =
                                    (xGLXQueryMaxSwapBarriersSGIXReq *) pc;
    xGLXQueryMaxSwapBarriersSGIXReply reply;
    int screen = req->screen;
    __GLXscreen *pGlxScreen;

    pGlxScreen = glxGetScreen(screenInfo.screens[screen]);
    if (pGlxScreen->swapBarrierFuncs)
        reply.max = pGlxScreen->swapBarrierFuncs->queryMaxSwapBarriersFunc(screen);
    else
        reply.max = 0;


    reply.length = 0;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;

    if (client->swapped) {
        __GLX_DECLARE_SWAP_VARIABLES;
        __GLX_SWAP_SHORT(&reply.sequenceNumber);
    }

    WriteToClient(client, sz_xGLXQueryMaxSwapBarriersSGIXReply,
                        (char *) &reply);
    return Success;
}

#define GLX_BAD_HYPERPIPE_SGIX 92

int __glXDisp_QueryHyperpipeNetworkSGIX(__GLXclientState *cl, GLbyte *pc)
{
    ClientPtr client = cl->client;
    xGLXQueryHyperpipeNetworkSGIXReq * req = (xGLXQueryHyperpipeNetworkSGIXReq *) pc;
    xGLXQueryHyperpipeNetworkSGIXReply reply;
    int screen = req->screen;
    void *rdata = NULL;

    int length=0;
    int npipes=0;

    int n= 0;
    __GLXscreen *pGlxScreen;

    pGlxScreen = glxGetScreen(screenInfo.screens[screen]);
    if (pGlxScreen->hyperpipeFuncs) {
        rdata =
            (pGlxScreen->hyperpipeFuncs->queryHyperpipeNetworkFunc(screen, &npipes, &n));
    }
    length = __GLX_PAD(n) >> 2;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = length;
    reply.n = n;
    reply.npipes = npipes;

    if (client->swapped) {
        __GLX_DECLARE_SWAP_VARIABLES;
        __GLX_SWAP_SHORT(&reply.sequenceNumber);
        __GLX_SWAP_INT(&reply.length);
        __GLX_SWAP_INT(&reply.n);
        __GLX_SWAP_INT(&reply.npipes);
    }
    WriteToClient(client, sz_xGLXQueryHyperpipeNetworkSGIXReply,
                  (char *) &reply);

    WriteToClient(client, length << 2, (char *)rdata);

    return Success;
}

int __glXDisp_DestroyHyperpipeConfigSGIX (__GLXclientState *cl, GLbyte *pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyHyperpipeConfigSGIXReq * req =
        (xGLXDestroyHyperpipeConfigSGIXReq *) pc;
    xGLXDestroyHyperpipeConfigSGIXReply reply;
    int screen = req->screen;
    int  success = GLX_BAD_HYPERPIPE_SGIX;
    int hpId ;
    __GLXscreen *pGlxScreen;

    hpId = req->hpId;

    pGlxScreen = glxGetScreen(screenInfo.screens[screen]);
    if (pGlxScreen->hyperpipeFuncs) {
        success = pGlxScreen->hyperpipeFuncs->destroyHyperpipeConfigFunc(screen, hpId);
    }

    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = __GLX_PAD(0) >> 2;
    reply.n = 0;
    reply.success = success;


    if (client->swapped) {
        __GLX_DECLARE_SWAP_VARIABLES;
        __GLX_SWAP_SHORT(&reply.sequenceNumber);
    }
    WriteToClient(client,
                  sz_xGLXDestroyHyperpipeConfigSGIXReply,
                  (char *) &reply);
    return Success;
}

int __glXDisp_QueryHyperpipeConfigSGIX(__GLXclientState *cl, GLbyte *pc)
{
    ClientPtr client = cl->client;
    xGLXQueryHyperpipeConfigSGIXReq * req =
        (xGLXQueryHyperpipeConfigSGIXReq *) pc;
    xGLXQueryHyperpipeConfigSGIXReply reply;
    int screen = req->screen;
    void *rdata = NULL;
    int length;
    int npipes=0;
    int n= 0;
    int hpId;
    __GLXscreen *pGlxScreen;

    hpId = req->hpId;

    pGlxScreen = glxGetScreen(screenInfo.screens[screen]);
    if (pGlxScreen->hyperpipeFuncs) {
        rdata = pGlxScreen->hyperpipeFuncs->queryHyperpipeConfigFunc(screen, hpId,&npipes, &n);
    }

    length = __GLX_PAD(n) >> 2;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = length;
    reply.n = n;
    reply.npipes = npipes;


    if (client->swapped) {
        __GLX_DECLARE_SWAP_VARIABLES;
        __GLX_SWAP_SHORT(&reply.sequenceNumber);
        __GLX_SWAP_INT(&reply.length);
        __GLX_SWAP_INT(&reply.n);
        __GLX_SWAP_INT(&reply.npipes);
    }

    WriteToClient(client, sz_xGLXQueryHyperpipeConfigSGIXReply,
                  (char *) &reply);

    WriteToClient(client, length << 2, (char *)rdata);

    return Success;
}

int __glXDisp_HyperpipeConfigSGIX(__GLXclientState *cl, GLbyte *pc)
{
    ClientPtr client = cl->client;
    xGLXHyperpipeConfigSGIXReq * req =
        (xGLXHyperpipeConfigSGIXReq *) pc;
    xGLXHyperpipeConfigSGIXReply reply;
    int screen = req->screen;
    void *rdata;

    int npipes=0, networkId;
    int hpId=-1;
    __GLXscreen *pGlxScreen;

    pGlxScreen = glxGetScreen(screenInfo.screens[screen]);
    networkId = (int)req->networkId;
    npipes = (int)req->npipes;
    rdata = (void *)(req +1);

    if (pGlxScreen->hyperpipeFuncs) {
        pGlxScreen->hyperpipeFuncs->hyperpipeConfigFunc(screen,networkId,
                                                        &hpId, &npipes,
                                                        (void *) rdata);
    }

    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = __GLX_PAD(0) >> 2;
    reply.n = 0;
    reply.npipes = npipes;
    reply.hpId = hpId;

    if (client->swapped) {
        __GLX_DECLARE_SWAP_VARIABLES;
        __GLX_SWAP_SHORT(&reply.sequenceNumber);
        __GLX_SWAP_INT(&reply.npipes);
        __GLX_SWAP_INT(&reply.hpId);
    }

    WriteToClient(client, sz_xGLXHyperpipeConfigSGIXReply,
                  (char *) &reply);

    return Success;
}


d2179 1
d2184 1
d2200 1
d2205 1
d2228 2
d2269 2
d2318 1
d2322 6
a2330 1
    buf = (const char *)(req+1);
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d60 1
a60 1
    if (screen >= screenInfo.numScreens) {
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d199 1
a199 1
    xfree(context);
d208 1
a208 1
    context = xcalloc (1, sizeof (__GLXcontext));
d410 1
a410 1
	table = (__GLXcontext **) xalloc(sizeof(__GLXcontext *));
d412 1
a412 1
	table = (__GLXcontext **) xrealloc(table,
d494 7
d1537 1
a1537 1
    sendBuf = (int *)xalloc((size_t)nReplyBytes);
d1555 1
a1555 1
    xfree((char *)sendBuf);
d1957 1
a1957 1
		cl->largeCmdBuf = (GLbyte *) xalloc(cmdlen);
d1959 1
a1959 1
		cl->largeCmdBuf = (GLbyte *) xrealloc(cl->largeCmdBuf, cmdlen);
d2361 1
a2361 1
    buf = (char *) xalloc(length << 2);
d2373 1
a2373 1
    xfree(buf);
d2417 1
a2417 1
    buf = (char *) xalloc(length << 2);
d2430 1
a2430 1
    xfree(buf);
d2441 1
a2441 2
    if (cl->GLClientextensions)
	xfree(cl->GLClientextensions);
d2443 1
a2443 1
    cl->GLClientextensions = xstrdup(buf);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a30 2
#define NEED_REPLIES
#define FONT_PCF
a53 6
void
GlxSetRenderTables (struct _glapi_table *table)
{
    _glapi_set_dispatch (table);
}

d134 56
d232 2
a233 1

d248 4
a251 5
	shareglxc = (__GLXcontext *) LookupIDByType(shareList, __glXContextRes);
	if (!shareglxc) {
	    client->errorValue = shareList;
	    return __glXError(GLXBadContext);
	}
a365 1
    ClientPtr client = cl->client;
a366 1
    GLXContextID gcId = req->context;
d368 8
a375 15
    
    glxc = (__GLXcontext *) LookupIDByType(gcId, __glXContextRes);
    if (glxc) {
	/*
	** Just free the resource; don't actually destroy the context,
	** because it might be in use.  The
	** destroy method will be called by the resource destruction routine
	** if necessary.
	*/
	FreeResourceByType(gcId, __glXContextRes, FALSE);
	return Success;
    } else {
	client->errorValue = gcId;
	return __glXError(GLXBadContext);
    }
d470 4
a473 14
 * Given a drawable ID, get the associated drawable and / or pixmap.
 * 
 * If the specified drawable ID is not a pixmap, \c ppPixmap will be set
 * to \c NULL on return.  In either case, \c ppDraw will be set to a drawable.
 * In the case where the drawable ID is a pixmap, \c ppDraw will be set to
 * the drawable associated with that pixmap.
 *
 * \param glxc      Associated GLX context.
 * \param drawId    ID of the drawable.
 * \param client    Pointer to the client state.
 * \return  the __GLXdrawable is returned on success.  Otherwise NULL.
 * 
 * \notes This function will need some modification when support pbuffers
 *        is added.
d483 2
a484 4
    /* This is the GLX 1.3 case - the client passes in a GLXWindow or
     * GLXPixmap and we just return the __GLXdrawable.  */
    pGlxDraw = (__GLXdrawable *) LookupIDByType(drawId, __glXDrawableRes);
    if (pGlxDraw != NULL) {
d494 4
a497 7
    /* The drawId wasn't a GLX drawable, so presumably it's a regular
     * X window.  In that case, we create a shadow GLXWindow for it on
     * demand here for pre GLX 1.3 compatibility and use the X Window
     * XID as its GLXWindow XID.  The client can't explicitly create a
     * GLXWindow with the same XID as an X Window, so we wont get any
     * resource ID clashes.  Effectively, the X Window is now also a
     * GLXWindow. */
d506 3
a508 3
    /* If we're not given a context, don't create the __GLXdrawable */
    if (glxc == NULL) {
	*error = __glXError(GLXBadDrawable);
d512 1
a512 6
    /* We're binding an X Window for the first time and need to create
     * a GLX drawable for it.  Check that the drawable screen matches
     * the context screen and that the context fbconfig is compatible
     * with the window visual. */
    if (pDraw->pScreen != glxc->pGlxScreen->pScreen ||
	!validGlxFBConfigForWindow(client, glxc->config, pDraw, error))
d515 3
a517 2
    pGlxDraw = glxc->pGlxScreen->createDrawable(glxc->pGlxScreen,
						pDraw, GLX_DRAWABLE_WINDOW,
d545 1
a545 1
    GLint error;
d586 2
a587 5
	glxc = (__GLXcontext *) LookupIDByType(contextId, __glXContextRes);
	if (!glxc) {
	    client->errorValue = contextId;
	    return __glXError(GLXBadContext);
	}
d710 1
d712 2
a713 8
    /*
    ** Find the GL context.
    */
    glxc = (__GLXcontext *) LookupIDByType(req->context, __glXContextRes);
    if (!glxc) {
	client->errorValue = req->context;
	return __glXError(GLXBadContext);
    }
d746 2
a747 2
    reply.majorVersion = GLX_SERVER_MAJOR_VERSION;
    reply.minorVersion = GLX_SERVER_MINOR_VERSION;
d800 2
a801 2
    if (glxc && glxc->drawPriv->waitGL)
	(*glxc->drawPriv->waitGL)(glxc->drawPriv);
d817 4
a820 13
    /*
    ** Check that each context exists.
    */
    src = (__GLXcontext *) LookupIDByType(source, __glXContextRes);
    if (!src) {
	client->errorValue = source;
	return __glXError(GLXBadContext);
    }
    dst = (__GLXcontext *) LookupIDByType(dest, __glXContextRes);
    if (!dst) {
	client->errorValue = dest;
	return __glXError(GLXBadContext);
    }
d878 8
d894 1
a894 1
    CARD32 buf[__GLX_TOTAL_CONFIG];
d903 2
a904 2
    reply.numProps = __GLX_TOTAL_CONFIG;
    reply.length = (reply.numVisuals * __GLX_SIZE_CARD32 * __GLX_TOTAL_CONFIG) >> 2;
d942 2
d968 1
d970 1
a970 1
	    __GLX_SWAP_INT_ARRAY(buf, __GLX_TOTAL_CONFIG);
d972 1
a972 2
	WriteToClient(client, __GLX_SIZE_CARD32 * __GLX_TOTAL_CONFIG, 
		(char *)buf);
a1104 8
    ScreenPtr pScreen = drawable->pDraw->pScreen;

    switch (drawable->type) {
    case GLX_DRAWABLE_PIXMAP:
    case GLX_DRAWABLE_PBUFFER:
	(*pScreen->DestroyPixmap)((PixmapPtr) drawable->pDraw);
	break;
    }
d1108 3
a1110 2
DoCreateGLXDrawable(ClientPtr client, __GLXscreen *pGlxScreen, __GLXconfig *config,
		    DrawablePtr pDraw, XID glxDrawableId, int type)
a1113 2
    LEGAL_NEW_RESOURCE(glxDrawableId, client);

d1117 2
a1118 1
    pGlxDraw = pGlxScreen->createDrawable(pGlxScreen, pDraw, type,
d1128 9
d1147 2
d1150 5
a1154 1
    if (err != Success || pDraw->type != DRAWABLE_PIXMAP) {
d1159 1
a1159 1
    err = DoCreateGLXDrawable(client, pGlxScreen, config, pDraw,
a1161 3
    if (err == Success)
	((PixmapPtr) pDraw)->refcnt++;

d1166 2
a1167 1
determineTextureTarget(XID glxDrawableID, CARD32 *attribs, CARD32 numAttribs)
d1171 1
a1171 1
    int i;
d1174 4
a1177 1
    pGlxDraw = LookupIDByType(glxDrawableID, __glXDrawableRes);
d1241 1
a1241 1
    determineTextureTarget(req->glxpixmap,
a1266 1
    ClientPtr client = cl->client;
d1268 1
d1270 3
a1272 15
    /*
    ** Check it's the right type of drawable.
    */
    pGlxDraw = LookupIDByType(glxdrawable, __glXDrawableRes);
    if (pGlxDraw == NULL || pGlxDraw->type != type) {
	client->errorValue = glxdrawable;
	switch (type) {
	case GLX_DRAWABLE_WINDOW:
	    return __glXError(GLXBadWindow);
	case GLX_DRAWABLE_PIXMAP:
	    return __glXError(GLXBadDrawable);
	case GLX_DRAWABLE_PBUFFER:
	    return __glXError(GLXBadPbuffer);
	}
    }
d1302 2
d1314 7
d1322 2
a1323 1
			       glxDrawableId, GLX_DRAWABLE_PBUFFER);
d1382 5
a1386 1
    int i;
a1387 1
    pGlxDraw = LookupIDByType(glxdrawable, __glXDrawableRes);
d1429 2
d1446 2
a1447 1
			       pDraw, req->glxwindow, GLX_DRAWABLE_WINDOW);
d1502 1
a1502 1
	(*pGlxDraw->swapBuffers)(pGlxDraw) == GL_FALSE)
d1518 1
d1520 2
a1521 5
    ctx = (__GLXcontext *) LookupIDByType(gcId, __glXContextRes);
    if (!ctx) {
	client->errorValue = gcId;
	return __glXError(GLXBadContext);
    }
d1589 3
a1591 5
    pGlxDraw = __glXGetDrawable(NULL, drawId, client, &error);
    if (!pGlxDraw || pGlxDraw->type != GLX_DRAWABLE_PIXMAP) {
	client->errorValue = drawId;
	return __glXError(GLXBadPixmap);
    }
d1620 2
a1621 3
    pGlxDraw = __glXGetDrawable(NULL, drawId, client, &error);
    if (!pGlxDraw || pGlxDraw->type != GLX_DRAWABLE_PIXMAP) {
	client->errorValue = drawId;
a1622 1
    }
d1702 2
a1703 3
    pGlxDraw = __glXGetDrawable(NULL, drawId, client, &error);
    if (!pGlxDraw) {
	client->errorValue = drawId;
a1704 1
    }
d2078 1
a2078 1
                    AddResource(drawable, __glXSwapBarrierRes, (pointer)screen);
d2380 1
d2390 5
a2394 1
	    ptr = pGlxScreen->GLXversion;
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d2 28
a29 33
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: The application programming interfaces
** established by SGI in conjunction with the Original Code are The
** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
** Window System(R) (Version 1.3), released October 19, 1998. This software
** was created using the OpenGL(R) version 1.2.1 Sample Implementation
** published by SGI, but has not been independently verified as being
** compliant with the OpenGL(R) version 1.2.1 Specification.
**
*/
a144 2
    if (!context->isDirect)
	__glXDeassociateContext(context);
a147 1

d160 1
a160 1
    context = xalloc (sizeof (__GLXcontext));
a163 1
    memset(context, 0, sizeof *context);
d263 2
d427 1
d615 4
a618 1
	__glXDeassociateContext(prevglxc);
a633 9
	/* resize the buffers */
	if (!(*drawPriv->resize)(drawPriv)) {
	    /* could not do initial resize.  make current failed */
	    (*glxc->loseCurrent)(glxc);
	    glxc->drawPriv = NULL;
	    glxc->readPriv = NULL;
	    return __glXError(GLXBadContext);
	}

a634 3
	__glXAssociateContext(glxc);
	assert(drawPriv->drawGlxc == glxc);
	assert(readPriv->readGlxc == glxc);
d751 2
d754 5
d760 4
a763 2
    if (!__glXForceCurrent(cl, req->contextTag, &error)) {
	return error;
d765 4
a768 1
    CALL_Finish( GET_DISPATCH(), () );
d775 2
d778 5
d784 2
a785 2
    if (!__glXForceCurrent(cl, req->contextTag, &error)) {
	return error;
d787 4
a790 6
    /*
    ** In a multithreaded server that had separate X and GL threads, we would
    ** have to wait for the X thread to finish before returning.  As it stands,
    ** this sample implementation only supports singlethreaded servers, and
    ** nothing needs to be done here.
    */
d1075 27
d1152 1
d1169 3
d1184 1
@

