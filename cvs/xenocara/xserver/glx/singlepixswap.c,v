head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.12
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.10
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.12.21.11.41.45;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	OOAr3LJJfv7DyAHR;

1.8
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	vcnjRBuLQw44cPHf;

1.7
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.14;	author matthieu;	state Exp;
branches;
next	;

1.6.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.7.2.1
date	2014.12.09.17.59.33;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.9
log
@Update to xorg-server  1.16.3.

Most of the 1.16.2->1.16.3 changes are the security patches that
where already there. This adds some extra fixes plus a few unrelated
bug fixes.
@
text
@/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "glxserver.h"
#include "glxext.h"
#include "singlesize.h"
#include "unpack.h"
#include "indirect_dispatch.h"
#include "indirect_size_get.h"

int
__glXDispSwap_ReadPixels(__GLXclientState * cl, GLbyte * pc)
{
    GLsizei width, height;
    GLenum format, type;
    GLboolean swapBytes, lsbFirst;
    GLint compsize;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLXcontext *cx;
    ClientPtr client = cl->client;
    int error;
    char *answer, answerBuffer[200];

    REQUEST_FIXED_SIZE(xGLXSingleReq, 28);

    __GLX_SWAP_INT(&((xGLXSingleReq *) pc)->contextTag);
    cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
    if (!cx) {
        return error;
    }

    pc += __GLX_SINGLE_HDR_SIZE;
    __GLX_SWAP_INT(pc + 0);
    __GLX_SWAP_INT(pc + 4);
    __GLX_SWAP_INT(pc + 8);
    __GLX_SWAP_INT(pc + 12);
    __GLX_SWAP_INT(pc + 16);
    __GLX_SWAP_INT(pc + 20);

    width = *(GLsizei *) (pc + 8);
    height = *(GLsizei *) (pc + 12);
    format = *(GLenum *) (pc + 16);
    type = *(GLenum *) (pc + 20);
    swapBytes = *(GLboolean *) (pc + 24);
    lsbFirst = *(GLboolean *) (pc + 25);
    compsize = __glReadPixels_size(format, type, width, height);
    if (compsize < 0)
        return BadLength;

    glPixelStorei(GL_PACK_SWAP_BYTES, !swapBytes);
    glPixelStorei(GL_PACK_LSB_FIRST, lsbFirst);
    __GLX_GET_ANSWER_BUFFER(answer, cl, compsize, 1);
    __glXClearErrorOccured();
    glReadPixels(*(GLint *) (pc + 0), *(GLint *) (pc + 4),
                 *(GLsizei *) (pc + 8), *(GLsizei *) (pc + 12),
                 *(GLenum *) (pc + 16), *(GLenum *) (pc + 20), answer);

    if (__glXErrorOccured()) {
        __GLX_BEGIN_REPLY(0);
        __GLX_SWAP_REPLY_HEADER();
        __GLX_SEND_HEADER();
    }
    else {
        __GLX_BEGIN_REPLY(compsize);
        __GLX_SWAP_REPLY_HEADER();
        __GLX_SEND_HEADER();
        __GLX_SEND_VOID_ARRAY(compsize);
    }
    cx->hasUnflushedCommands = GL_FALSE;
    return Success;
}

int
__glXDispSwap_GetTexImage(__GLXclientState * cl, GLbyte * pc)
{
    GLint level, compsize;
    GLenum format, type, target;
    GLboolean swapBytes;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLXcontext *cx;
    ClientPtr client = cl->client;
    int error;
    char *answer, answerBuffer[200];
    GLint width = 0, height = 0, depth = 1;

    REQUEST_FIXED_SIZE(xGLXSingleReq, 20);

    __GLX_SWAP_INT(&((xGLXSingleReq *) pc)->contextTag);
    cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
    if (!cx) {
        return error;
    }

    pc += __GLX_SINGLE_HDR_SIZE;
    __GLX_SWAP_INT(pc + 0);
    __GLX_SWAP_INT(pc + 4);
    __GLX_SWAP_INT(pc + 8);
    __GLX_SWAP_INT(pc + 12);

    level = *(GLint *) (pc + 4);
    format = *(GLenum *) (pc + 8);
    type = *(GLenum *) (pc + 12);
    target = *(GLenum *) (pc + 0);
    swapBytes = *(GLboolean *) (pc + 16);

    glGetTexLevelParameteriv(target, level, GL_TEXTURE_WIDTH, &width);
    glGetTexLevelParameteriv(target, level, GL_TEXTURE_HEIGHT, &height);
    if (target == GL_TEXTURE_3D) {
        glGetTexLevelParameteriv(target, level, GL_TEXTURE_DEPTH, &depth);
    }
    /*
     * The three queries above might fail if we're in a state where queries
     * are illegal, but then width, height, and depth would still be zero anyway.
     */
    compsize =
        __glGetTexImage_size(target, level, format, type, width, height, depth);
    if (compsize < 0)
        return BadLength;

    glPixelStorei(GL_PACK_SWAP_BYTES, !swapBytes);
    __GLX_GET_ANSWER_BUFFER(answer, cl, compsize, 1);
    __glXClearErrorOccured();
    glGetTexImage(*(GLenum *) (pc + 0), *(GLint *) (pc + 4),
                  *(GLenum *) (pc + 8), *(GLenum *) (pc + 12), answer);

    if (__glXErrorOccured()) {
        __GLX_BEGIN_REPLY(0);
        __GLX_SWAP_REPLY_HEADER();
        __GLX_SEND_HEADER();
    }
    else {
        __GLX_BEGIN_REPLY(compsize);
        __GLX_SWAP_REPLY_HEADER();
        __GLX_SWAP_INT(&width);
        __GLX_SWAP_INT(&height);
        __GLX_SWAP_INT(&depth);
        ((xGLXGetTexImageReply *) &__glXReply)->width = width;
        ((xGLXGetTexImageReply *) &__glXReply)->height = height;
        ((xGLXGetTexImageReply *) &__glXReply)->depth = depth;
        __GLX_SEND_HEADER();
        __GLX_SEND_VOID_ARRAY(compsize);
    }
    return Success;
}

int
__glXDispSwap_GetPolygonStipple(__GLXclientState * cl, GLbyte * pc)
{
    GLboolean lsbFirst;
    __GLXcontext *cx;
    ClientPtr client = cl->client;
    int error;
    GLubyte answerBuffer[200];
    char *answer;

    __GLX_DECLARE_SWAP_VARIABLES;

    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

    __GLX_SWAP_INT(&((xGLXSingleReq *) pc)->contextTag);
    cx = __glXForceCurrent(cl, __GLX_GET_SINGLE_CONTEXT_TAG(pc), &error);
    if (!cx) {
        return error;
    }
    pc += __GLX_SINGLE_HDR_SIZE;
    lsbFirst = *(GLboolean *) (pc + 0);

    glPixelStorei(GL_PACK_LSB_FIRST, lsbFirst);
    __GLX_GET_ANSWER_BUFFER(answer, cl, 128, 1);

    __glXClearErrorOccured();
    glGetPolygonStipple((GLubyte *) answer);
    if (__glXErrorOccured()) {
        __GLX_BEGIN_REPLY(0);
        __GLX_SWAP_REPLY_HEADER();
        __GLX_SEND_HEADER();
    }
    else {
        __GLX_BEGIN_REPLY(128);
        __GLX_SWAP_REPLY_HEADER();
        __GLX_SEND_HEADER();
        __GLX_SEND_BYTE_ARRAY(128);
    }
    return Success;
}

static int
GetSeparableFilter(__GLXclientState * cl, GLbyte * pc, GLXContextTag tag)
{
    GLint compsize, compsize2;
    GLenum format, type, target;
    GLboolean swapBytes;
    __GLXcontext *cx;
    ClientPtr client = cl->client;
    int error;

    __GLX_DECLARE_SWAP_VARIABLES;
    char *answer, answerBuffer[200];
    GLint width = 0, height = 0;

    cx = __glXForceCurrent(cl, tag, &error);
    if (!cx) {
        return error;
    }

    __GLX_SWAP_INT(pc + 0);
    __GLX_SWAP_INT(pc + 4);
    __GLX_SWAP_INT(pc + 8);

    format = *(GLenum *) (pc + 4);
    type = *(GLenum *) (pc + 8);
    target = *(GLenum *) (pc + 0);
    swapBytes = *(GLboolean *) (pc + 12);

    /* target must be SEPARABLE_2D, however I guess we can let the GL
       barf on this one.... */

    glGetConvolutionParameteriv(target, GL_CONVOLUTION_WIDTH, &width);
    glGetConvolutionParameteriv(target, GL_CONVOLUTION_HEIGHT, &height);
    /*
     * The two queries above might fail if we're in a state where queries
     * are illegal, but then width and height would still be zero anyway.
     */
    compsize = __glGetTexImage_size(target, 1, format, type, width, 1, 1);
    compsize2 = __glGetTexImage_size(target, 1, format, type, height, 1, 1);

    if ((compsize = safe_pad(compsize)) < 0)
        return BadLength;
    if ((compsize2 = safe_pad(compsize2)) < 0)
        return BadLength;

    glPixelStorei(GL_PACK_SWAP_BYTES, !swapBytes);
    __GLX_GET_ANSWER_BUFFER(answer, cl, safe_add(compsize, compsize2), 1);
    __glXClearErrorOccured();
    glGetSeparableFilter(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4),
                         *(GLenum *) (pc + 8), answer, answer + compsize, NULL);

    if (__glXErrorOccured()) {
        __GLX_BEGIN_REPLY(0);
        __GLX_SWAP_REPLY_HEADER();
    }
    else {
        __GLX_BEGIN_REPLY(compsize + compsize2);
        __GLX_SWAP_REPLY_HEADER();
        __GLX_SWAP_INT(&width);
        __GLX_SWAP_INT(&height);
        ((xGLXGetSeparableFilterReply *) &__glXReply)->width = width;
        ((xGLXGetSeparableFilterReply *) &__glXReply)->height = height;
        __GLX_SEND_VOID_ARRAY(compsize + compsize2);
    }

    return Success;
}

int
__glXDispSwap_GetSeparableFilter(__GLXclientState * cl, GLbyte * pc)
{
    const GLXContextTag tag = __GLX_GET_SINGLE_CONTEXT_TAG(pc);
    ClientPtr client = cl->client;

    REQUEST_FIXED_SIZE(xGLXSingleReq, 16);
    return GetSeparableFilter(cl, pc + __GLX_SINGLE_HDR_SIZE, tag);
}

int
__glXDispSwap_GetSeparableFilterEXT(__GLXclientState * cl, GLbyte * pc)
{
    const GLXContextTag tag = __GLX_GET_VENDPRIV_CONTEXT_TAG(pc);
    ClientPtr client = cl->client;

    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 16);
    return GetSeparableFilter(cl, pc + __GLX_VENDPRIV_HDR_SIZE, tag);
}

static int
GetConvolutionFilter(__GLXclientState * cl, GLbyte * pc, GLXContextTag tag)
{
    GLint compsize;
    GLenum format, type, target;
    GLboolean swapBytes;
    __GLXcontext *cx;
    ClientPtr client = cl->client;
    int error;

    __GLX_DECLARE_SWAP_VARIABLES;
    char *answer, answerBuffer[200];
    GLint width = 0, height = 0;

    cx = __glXForceCurrent(cl, tag, &error);
    if (!cx) {
        return error;
    }

    __GLX_SWAP_INT(pc + 0);
    __GLX_SWAP_INT(pc + 4);
    __GLX_SWAP_INT(pc + 8);

    format = *(GLenum *) (pc + 4);
    type = *(GLenum *) (pc + 8);
    target = *(GLenum *) (pc + 0);
    swapBytes = *(GLboolean *) (pc + 12);

    glGetConvolutionParameteriv(target, GL_CONVOLUTION_WIDTH, &width);
    if (target == GL_CONVOLUTION_2D) {
        height = 1;
    }
    else {
        glGetConvolutionParameteriv(target, GL_CONVOLUTION_HEIGHT, &height);
    }
    /*
     * The two queries above might fail if we're in a state where queries
     * are illegal, but then width and height would still be zero anyway.
     */
    compsize = __glGetTexImage_size(target, 1, format, type, width, height, 1);
    if (compsize < 0)
        return BadLength;

    glPixelStorei(GL_PACK_SWAP_BYTES, !swapBytes);
    __GLX_GET_ANSWER_BUFFER(answer, cl, compsize, 1);
    __glXClearErrorOccured();
    glGetConvolutionFilter(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4),
                           *(GLenum *) (pc + 8), answer);

    if (__glXErrorOccured()) {
        __GLX_BEGIN_REPLY(0);
        __GLX_SWAP_REPLY_HEADER();
    }
    else {
        __GLX_BEGIN_REPLY(compsize);
        __GLX_SWAP_REPLY_HEADER();
        __GLX_SWAP_INT(&width);
        __GLX_SWAP_INT(&height);
        ((xGLXGetConvolutionFilterReply *) &__glXReply)->width = width;
        ((xGLXGetConvolutionFilterReply *) &__glXReply)->height = height;
        __GLX_SEND_VOID_ARRAY(compsize);
    }

    return Success;
}

int
__glXDispSwap_GetConvolutionFilter(__GLXclientState * cl, GLbyte * pc)
{
    const GLXContextTag tag = __GLX_GET_SINGLE_CONTEXT_TAG(pc);
    ClientPtr client = cl->client;

    REQUEST_FIXED_SIZE(xGLXSingleReq, 16);
    return GetConvolutionFilter(cl, pc + __GLX_SINGLE_HDR_SIZE, tag);
}

int
__glXDispSwap_GetConvolutionFilterEXT(__GLXclientState * cl, GLbyte * pc)
{
    const GLXContextTag tag = __GLX_GET_VENDPRIV_CONTEXT_TAG(pc);
    ClientPtr client = cl->client;

    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 16);
    return GetConvolutionFilter(cl, pc + __GLX_VENDPRIV_HDR_SIZE, tag);
}

static int
GetHistogram(__GLXclientState * cl, GLbyte * pc, GLXContextTag tag)
{
    GLint compsize;
    GLenum format, type, target;
    GLboolean swapBytes, reset;
    __GLXcontext *cx;
    ClientPtr client = cl->client;
    int error;

    __GLX_DECLARE_SWAP_VARIABLES;
    char *answer, answerBuffer[200];
    GLint width = 0;

    cx = __glXForceCurrent(cl, tag, &error);
    if (!cx) {
        return error;
    }

    __GLX_SWAP_INT(pc + 0);
    __GLX_SWAP_INT(pc + 4);
    __GLX_SWAP_INT(pc + 8);

    format = *(GLenum *) (pc + 4);
    type = *(GLenum *) (pc + 8);
    target = *(GLenum *) (pc + 0);
    swapBytes = *(GLboolean *) (pc + 12);
    reset = *(GLboolean *) (pc + 13);

    glGetHistogramParameteriv(target, GL_HISTOGRAM_WIDTH, &width);
    /*
     * The one query above might fail if we're in a state where queries
     * are illegal, but then width would still be zero anyway.
     */
    compsize = __glGetTexImage_size(target, 1, format, type, width, 1, 1);
    if (compsize < 0)
        return BadLength;

    glPixelStorei(GL_PACK_SWAP_BYTES, !swapBytes);
    __GLX_GET_ANSWER_BUFFER(answer, cl, compsize, 1);
    __glXClearErrorOccured();
    glGetHistogram(target, reset, format, type, answer);

    if (__glXErrorOccured()) {
        __GLX_BEGIN_REPLY(0);
        __GLX_SWAP_REPLY_HEADER();
    }
    else {
        __GLX_BEGIN_REPLY(compsize);
        __GLX_SWAP_REPLY_HEADER();
        __GLX_SWAP_INT(&width);
        ((xGLXGetHistogramReply *) &__glXReply)->width = width;
        __GLX_SEND_VOID_ARRAY(compsize);
    }

    return Success;
}

int
__glXDispSwap_GetHistogram(__GLXclientState * cl, GLbyte * pc)
{
    const GLXContextTag tag = __GLX_GET_SINGLE_CONTEXT_TAG(pc);
    ClientPtr client = cl->client;

    REQUEST_FIXED_SIZE(xGLXSingleReq, 16);
    return GetHistogram(cl, pc + __GLX_SINGLE_HDR_SIZE, tag);
}

int
__glXDispSwap_GetHistogramEXT(__GLXclientState * cl, GLbyte * pc)
{
    const GLXContextTag tag = __GLX_GET_VENDPRIV_CONTEXT_TAG(pc);
    ClientPtr client = cl->client;

    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 16);
    return GetHistogram(cl, pc + __GLX_VENDPRIV_HDR_SIZE, tag);
}

static int
GetMinmax(__GLXclientState * cl, GLbyte * pc, GLXContextTag tag)
{
    GLint compsize;
    GLenum format, type, target;
    GLboolean swapBytes, reset;
    __GLXcontext *cx;
    ClientPtr client = cl->client;
    int error;

    __GLX_DECLARE_SWAP_VARIABLES;
    char *answer, answerBuffer[200];

    cx = __glXForceCurrent(cl, tag, &error);
    if (!cx) {
        return error;
    }

    __GLX_SWAP_INT(pc + 0);
    __GLX_SWAP_INT(pc + 4);
    __GLX_SWAP_INT(pc + 8);

    format = *(GLenum *) (pc + 4);
    type = *(GLenum *) (pc + 8);
    target = *(GLenum *) (pc + 0);
    swapBytes = *(GLboolean *) (pc + 12);
    reset = *(GLboolean *) (pc + 13);

    compsize = __glGetTexImage_size(target, 1, format, type, 2, 1, 1);
    if (compsize < 0)
        return BadLength;

    glPixelStorei(GL_PACK_SWAP_BYTES, !swapBytes);
    __GLX_GET_ANSWER_BUFFER(answer, cl, compsize, 1);
    __glXClearErrorOccured();
    glGetMinmax(target, reset, format, type, answer);

    if (__glXErrorOccured()) {
        __GLX_BEGIN_REPLY(0);
        __GLX_SWAP_REPLY_HEADER();
    }
    else {
        __GLX_BEGIN_REPLY(compsize);
        __GLX_SWAP_REPLY_HEADER();
        __GLX_SEND_VOID_ARRAY(compsize);
    }

    return Success;
}

int
__glXDispSwap_GetMinmax(__GLXclientState * cl, GLbyte * pc)
{
    const GLXContextTag tag = __GLX_GET_SINGLE_CONTEXT_TAG(pc);
    ClientPtr client = cl->client;

    REQUEST_FIXED_SIZE(xGLXSingleReq, 16);
    return GetMinmax(cl, pc + __GLX_SINGLE_HDR_SIZE, tag);
}

int
__glXDispSwap_GetMinmaxEXT(__GLXclientState * cl, GLbyte * pc)
{
    const GLXContextTag tag = __GLX_GET_VENDPRIV_CONTEXT_TAG(pc);
    ClientPtr client = cl->client;

    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 16);
    return GetMinmax(cl, pc + __GLX_VENDPRIV_HDR_SIZE, tag);
}

static int
GetColorTable(__GLXclientState * cl, GLbyte * pc, GLXContextTag tag)
{
    GLint compsize;
    GLenum format, type, target;
    GLboolean swapBytes;
    __GLXcontext *cx;
    ClientPtr client = cl->client;
    int error;

    __GLX_DECLARE_SWAP_VARIABLES;
    char *answer, answerBuffer[200];
    GLint width = 0;

    cx = __glXForceCurrent(cl, tag, &error);
    if (!cx) {
        return error;
    }

    __GLX_SWAP_INT(pc + 0);
    __GLX_SWAP_INT(pc + 4);
    __GLX_SWAP_INT(pc + 8);

    format = *(GLenum *) (pc + 4);
    type = *(GLenum *) (pc + 8);
    target = *(GLenum *) (pc + 0);
    swapBytes = *(GLboolean *) (pc + 12);

    glGetColorTableParameteriv(target, GL_COLOR_TABLE_WIDTH, &width);
    /*
     * The one query above might fail if we're in a state where queries
     * are illegal, but then width would still be zero anyway.
     */
    compsize = __glGetTexImage_size(target, 1, format, type, width, 1, 1);
    if (compsize < 0)
        return BadLength;

    glPixelStorei(GL_PACK_SWAP_BYTES, !swapBytes);
    __GLX_GET_ANSWER_BUFFER(answer, cl, compsize, 1);
    __glXClearErrorOccured();
    glGetColorTable(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4),
                    *(GLenum *) (pc + 8), answer);

    if (__glXErrorOccured()) {
        __GLX_BEGIN_REPLY(0);
        __GLX_SWAP_REPLY_HEADER();
    }
    else {
        __GLX_BEGIN_REPLY(compsize);
        __GLX_SWAP_REPLY_HEADER();
        __GLX_SWAP_INT(&width);
        ((xGLXGetColorTableReply *) &__glXReply)->width = width;
        __GLX_SEND_VOID_ARRAY(compsize);
    }

    return Success;
}

int
__glXDispSwap_GetColorTable(__GLXclientState * cl, GLbyte * pc)
{
    const GLXContextTag tag = __GLX_GET_SINGLE_CONTEXT_TAG(pc);
    ClientPtr client = cl->client;

    REQUEST_FIXED_SIZE(xGLXSingleReq, 16);
    return GetColorTable(cl, pc + __GLX_SINGLE_HDR_SIZE, tag);
}

int
__glXDispSwap_GetColorTableSGI(__GLXclientState * cl, GLbyte * pc)
{
    const GLXContextTag tag = __GLX_GET_VENDPRIV_CONTEXT_TAG(pc);
    ClientPtr client = cl->client;

    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 16);
    return GetColorTable(cl, pc + __GLX_VENDPRIV_HDR_SIZE, tag);
}
@


1.8
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d80 1
a80 1
        compsize = 0;
d151 1
a151 1
        compsize = 0;
d261 1
a261 1
        compsize = 0;
d263 1
a263 1
        compsize2 = 0;
d349 1
a349 1
        compsize = 0;
d430 1
a430 1
        compsize = 0;
d502 1
a502 1
        compsize = 0;
d577 1
a577 1
        compsize = 0;
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d56 2
d119 2
d191 2
d260 1
a260 1
    if (compsize < 0)
d262 1
a262 1
    if (compsize2 < 0)
a263 2
    compsize = __GLX_PAD(compsize);
    compsize2 = __GLX_PAD(compsize2);
d266 1
a266 1
    __GLX_GET_ANSWER_BUFFER(answer, cl, compsize + compsize2, 1);
d292 1
d294 1
d302 1
d304 1
d378 1
d380 1
d388 1
d390 1
d456 1
d458 1
d466 1
d468 1
d526 1
d528 1
d536 1
d538 1
d604 1
d606 1
d614 1
d616 1
@


1.7.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a55 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 28);

a116 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 20);

a186 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

d254 1
a254 1
    if ((compsize = safe_pad(compsize)) < 0)
d256 1
a256 1
    if ((compsize2 = safe_pad(compsize2)) < 0)
d258 2
d262 1
a262 1
    __GLX_GET_ANSWER_BUFFER(answer, cl, safe_add(compsize, compsize2), 1);
a287 1
    ClientPtr client = cl->client;
a288 1
    REQUEST_FIXED_SIZE(xGLXSingleReq, 16);
a295 1
    ClientPtr client = cl->client;
a296 1
    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 16);
a369 1
    ClientPtr client = cl->client;
a370 1
    REQUEST_FIXED_SIZE(xGLXSingleReq, 16);
a377 1
    ClientPtr client = cl->client;
a378 1
    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 16);
a443 1
    ClientPtr client = cl->client;
a444 1
    REQUEST_FIXED_SIZE(xGLXSingleReq, 16);
a451 1
    ClientPtr client = cl->client;
a452 1
    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 16);
a509 1
    ClientPtr client = cl->client;
a510 1
    REQUEST_FIXED_SIZE(xGLXSingleReq, 16);
a517 1
    ClientPtr client = cl->client;
a518 1
    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 16);
a583 1
    ClientPtr client = cl->client;
a584 1
    REQUEST_FIXED_SIZE(xGLXSingleReq, 16);
a591 1
    ClientPtr client = cl->client;
a592 1
    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 16);
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a40 4
#include "glapitable.h"
#include "glapi.h"
#include "glthread.h"
#include "dispatch.h"
d80 2
a81 2
    CALL_PixelStorei(GET_DISPATCH(), (GL_PACK_SWAP_BYTES, !swapBytes));
    CALL_PixelStorei(GET_DISPATCH(), (GL_PACK_LSB_FIRST, lsbFirst));
d84 3
a86 7
    CALL_ReadPixels(GET_DISPATCH(),
                    (*(GLint *) (pc + 0),
                     *(GLint *) (pc + 4),
                     *(GLsizei *) (pc + 8),
                     *(GLsizei *) (pc + 12),
                     *(GLenum *) (pc + 16), *(GLenum *) (pc + 20), answer)
        );
d135 2
a136 4
    CALL_GetTexLevelParameteriv(GET_DISPATCH(),
                                (target, level, GL_TEXTURE_WIDTH, &width));
    CALL_GetTexLevelParameteriv(GET_DISPATCH(),
                                (target, level, GL_TEXTURE_HEIGHT, &height));
d138 1
a138 2
        CALL_GetTexLevelParameteriv(GET_DISPATCH(),
                                    (target, level, GL_TEXTURE_DEPTH, &depth));
d149 1
a149 1
    CALL_PixelStorei(GET_DISPATCH(), (GL_PACK_SWAP_BYTES, !swapBytes));
d152 2
a153 4
    CALL_GetTexImage(GET_DISPATCH(), (*(GLenum *) (pc + 0),
                                      *(GLint *) (pc + 4),
                                      *(GLenum *) (pc + 8),
                                      *(GLenum *) (pc + 12), answer));
d195 1
a195 1
    CALL_PixelStorei(GET_DISPATCH(), (GL_PACK_LSB_FIRST, lsbFirst));
d199 1
a199 1
    CALL_GetPolygonStipple(GET_DISPATCH(), ((GLubyte *) answer));
d245 2
a246 4
    CALL_GetConvolutionParameteriv(GET_DISPATCH(),
                                   (target, GL_CONVOLUTION_WIDTH, &width));
    CALL_GetConvolutionParameteriv(GET_DISPATCH(),
                                   (target, GL_CONVOLUTION_HEIGHT, &height));
d261 1
a261 1
    CALL_PixelStorei(GET_DISPATCH(), (GL_PACK_SWAP_BYTES, !swapBytes));
d264 2
a265 4
    CALL_GetSeparableFilter(GET_DISPATCH(), (*(GLenum *) (pc + 0),
                                             *(GLenum *) (pc + 4),
                                             *(GLenum *) (pc + 8),
                                             answer, answer + compsize, NULL));
d328 1
a328 2
    CALL_GetConvolutionParameteriv(GET_DISPATCH(),
                                   (target, GL_CONVOLUTION_WIDTH, &width));
d333 1
a333 3
        CALL_GetConvolutionParameteriv(GET_DISPATCH(),
                                       (target, GL_CONVOLUTION_HEIGHT,
                                        &height));
d343 1
a343 1
    CALL_PixelStorei(GET_DISPATCH(), (GL_PACK_SWAP_BYTES, !swapBytes));
d346 2
a347 3
    CALL_GetConvolutionFilter(GET_DISPATCH(), (*(GLenum *) (pc + 0),
                                               *(GLenum *) (pc + 4),
                                               *(GLenum *) (pc + 8), answer));
d411 1
a411 2
    CALL_GetHistogramParameteriv(GET_DISPATCH(),
                                 (target, GL_HISTOGRAM_WIDTH, &width));
d420 1
a420 1
    CALL_PixelStorei(GET_DISPATCH(), (GL_PACK_SWAP_BYTES, !swapBytes));
d423 1
a423 1
    CALL_GetHistogram(GET_DISPATCH(), (target, reset, format, type, answer));
d488 1
a488 1
    CALL_PixelStorei(GET_DISPATCH(), (GL_PACK_SWAP_BYTES, !swapBytes));
d491 1
a491 1
    CALL_GetMinmax(GET_DISPATCH(), (target, reset, format, type, answer));
d550 1
a550 2
    CALL_GetColorTableParameteriv(GET_DISPATCH(),
                                  (target, GL_COLOR_TABLE_WIDTH, &width));
d559 1
a559 1
    CALL_PixelStorei(GET_DISPATCH(), (GL_PACK_SWAP_BYTES, !swapBytes));
d562 2
a563 3
    CALL_GetColorTable(GET_DISPATCH(), (*(GLenum *) (pc + 0),
                                        *(GLenum *) (pc + 4),
                                        *(GLenum *) (pc + 8), answer));
@


1.6.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a59 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 28);

a124 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 20);

a199 2
    REQUEST_FIXED_SIZE(xGLXSingleReq, 4);

d269 1
a269 1
    if ((compsize = safe_pad(compsize)) < 0)
d271 1
a271 1
    if ((compsize2 = safe_pad(compsize2)) < 0)
d273 2
d277 1
a277 1
    __GLX_GET_ANSWER_BUFFER(answer, cl, safe_add(compsize, compsize2), 1);
a304 1
    ClientPtr client = cl->client;
a305 1
    REQUEST_FIXED_SIZE(xGLXSingleReq, 16);
a312 1
    ClientPtr client = cl->client;
a313 1
    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 16);
a390 1
    ClientPtr client = cl->client;
a391 1
    REQUEST_FIXED_SIZE(xGLXSingleReq, 16);
a398 1
    ClientPtr client = cl->client;
a399 1
    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 16);
a465 1
    ClientPtr client = cl->client;
a466 1
    REQUEST_FIXED_SIZE(xGLXSingleReq, 16);
a473 1
    ClientPtr client = cl->client;
a474 1
    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 16);
a531 1
    ClientPtr client = cl->client;
a532 1
    REQUEST_FIXED_SIZE(xGLXSingleReq, 16);
a539 1
    ClientPtr client = cl->client;
a540 1
    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 16);
a607 1
    ClientPtr client = cl->client;
a608 1
    REQUEST_FIXED_SIZE(xGLXSingleReq, 16);
a615 1
    ClientPtr client = cl->client;
a616 1
    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 16);
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d179 3
a181 3
        ((xGLXGetTexImageReply *) & __glXReply)->width = width;
        ((xGLXGetTexImageReply *) & __glXReply)->height = height;
        ((xGLXGetTexImageReply *) & __glXReply)->depth = depth;
d293 2
a294 2
        ((xGLXGetSeparableFilterReply *) & __glXReply)->width = width;
        ((xGLXGetSeparableFilterReply *) & __glXReply)->height = height;
d379 2
a380 2
        ((xGLXGetConvolutionFilterReply *) & __glXReply)->width = width;
        ((xGLXGetConvolutionFilterReply *) & __glXReply)->height = height;
d455 1
a455 1
        ((xGLXGetHistogramReply *) & __glXReply)->width = width;
d597 1
a597 1
        ((xGLXGetColorTableReply *) & __glXReply)->width = width;
@


1.4
log
@Update to xserver 1.11.2
@
text
@d46 2
a47 1
int __glXDispSwap_ReadPixels(__GLXclientState *cl, GLbyte *pc)
d53 1
d60 1
a60 1
    __GLX_SWAP_INT(&((xGLXSingleReq *)pc)->contextTag);
d63 1
a63 1
	return error;
d67 20
a86 19
    __GLX_SWAP_INT(pc+0);
    __GLX_SWAP_INT(pc+4);
    __GLX_SWAP_INT(pc+8);
    __GLX_SWAP_INT(pc+12);
    __GLX_SWAP_INT(pc+16);
    __GLX_SWAP_INT(pc+20);

    width = *(GLsizei *)(pc + 8);
    height = *(GLsizei *)(pc + 12);
    format = *(GLenum *)(pc + 16);
    type = *(GLenum *)(pc + 20);
    swapBytes = *(GLboolean *)(pc + 24);
    lsbFirst = *(GLboolean *)(pc + 25);
    compsize = __glReadPixels_size(format,type,width,height);
    if (compsize < 0) compsize = 0;

    CALL_PixelStorei( GET_DISPATCH(), (GL_PACK_SWAP_BYTES, !swapBytes) );
    CALL_PixelStorei( GET_DISPATCH(), (GL_PACK_LSB_FIRST, lsbFirst) );
    __GLX_GET_ANSWER_BUFFER(answer,cl,compsize,1);
d88 7
a94 9
    CALL_ReadPixels( GET_DISPATCH(),
		 (*(GLint    *)(pc + 0),
		 *(GLint    *)(pc + 4),
		 *(GLsizei  *)(pc + 8),
		 *(GLsizei  *)(pc + 12),
		 *(GLenum   *)(pc + 16),
		 *(GLenum   *)(pc + 20),
		 answer)
		 );
d97 9
a105 8
	__GLX_BEGIN_REPLY(0);
	__GLX_SWAP_REPLY_HEADER();
	__GLX_SEND_HEADER();
    } else {
	__GLX_BEGIN_REPLY(compsize);
	__GLX_SWAP_REPLY_HEADER();
	__GLX_SEND_HEADER();
	__GLX_SEND_VOID_ARRAY(compsize);
d111 2
a112 1
int __glXDispSwap_GetTexImage(__GLXclientState *cl, GLbyte *pc)
d117 1
d123 1
a123 1
    GLint width=0, height=0, depth=1;
d125 1
a125 1
    __GLX_SWAP_INT(&((xGLXSingleReq *)pc)->contextTag);
d128 1
a128 1
	return error;
d132 18
a149 15
    __GLX_SWAP_INT(pc+0);
    __GLX_SWAP_INT(pc+4);
    __GLX_SWAP_INT(pc+8);
    __GLX_SWAP_INT(pc+12);

    level = *(GLint *)(pc + 4);
    format = *(GLenum *)(pc + 8);
    type = *(GLenum *)(pc + 12);
    target = *(GLenum *)(pc + 0);
    swapBytes = *(GLboolean *)(pc + 16);

    CALL_GetTexLevelParameteriv( GET_DISPATCH(), (target, level, GL_TEXTURE_WIDTH, &width) );
    CALL_GetTexLevelParameteriv( GET_DISPATCH(), (target, level, GL_TEXTURE_HEIGHT, &height) );
    if ( target == GL_TEXTURE_3D) {
	CALL_GetTexLevelParameteriv( GET_DISPATCH(), (target, level, GL_TEXTURE_DEPTH, &depth) );
d155 4
a158 2
    compsize = __glGetTexImage_size(target,level,format,type,width,height,depth);
    if (compsize < 0) compsize = 0;
d160 2
a161 2
    CALL_PixelStorei( GET_DISPATCH(), (GL_PACK_SWAP_BYTES, !swapBytes) );
    __GLX_GET_ANSWER_BUFFER(answer,cl,compsize,1);
d163 4
a166 7
    CALL_GetTexImage( GET_DISPATCH(), (
		  *(GLenum   *)(pc + 0),
		  *(GLint    *)(pc + 4),
		  *(GLenum   *)(pc + 8),
		  *(GLenum   *)(pc + 12),
		  answer
		  ) );
d169 15
a183 14
	__GLX_BEGIN_REPLY(0);
	__GLX_SWAP_REPLY_HEADER();
	__GLX_SEND_HEADER();
    } else {
	__GLX_BEGIN_REPLY(compsize);
	__GLX_SWAP_REPLY_HEADER();
	__GLX_SWAP_INT(&width);
	__GLX_SWAP_INT(&height);
	__GLX_SWAP_INT(&depth);
	((xGLXGetTexImageReply *)&__glXReply)->width = width;
	((xGLXGetTexImageReply *)&__glXReply)->height = height;
	((xGLXGetTexImageReply *)&__glXReply)->depth = depth;
	__GLX_SEND_HEADER();
	__GLX_SEND_VOID_ARRAY(compsize);
d188 2
a189 1
int __glXDispSwap_GetPolygonStipple(__GLXclientState *cl, GLbyte *pc)
d197 1
d200 1
a200 1
    __GLX_SWAP_INT(&((xGLXSingleReq *)pc)->contextTag);
d203 1
a203 1
	return error;
d206 1
a206 1
    lsbFirst = *(GLboolean *)(pc + 0);
d208 2
a209 2
    CALL_PixelStorei( GET_DISPATCH(), (GL_PACK_LSB_FIRST, lsbFirst) );
    __GLX_GET_ANSWER_BUFFER(answer,cl,128,1);
d212 1
a212 1
    CALL_GetPolygonStipple( GET_DISPATCH(), ((GLubyte  *) answer) );
d214 9
a222 8
	__GLX_BEGIN_REPLY(0);
	__GLX_SWAP_REPLY_HEADER();
	__GLX_SEND_HEADER();
    } else {
	__GLX_BEGIN_REPLY(128);
	__GLX_SWAP_REPLY_HEADER();
	__GLX_SEND_HEADER();
	__GLX_SEND_BYTE_ARRAY(128);
d227 2
a228 1
static int GetSeparableFilter(__GLXclientState *cl, GLbyte *pc, GLXContextTag tag)
d236 1
d239 1
a239 1
    GLint width=0, height=0;
d243 1
a243 1
	return error;
d246 3
a248 3
    __GLX_SWAP_INT(pc+0);
    __GLX_SWAP_INT(pc+4);
    __GLX_SWAP_INT(pc+8);
d250 4
a253 4
    format = *(GLenum *)(pc + 4);
    type = *(GLenum *)(pc + 8);
    target = *(GLenum *)(pc + 0);
    swapBytes = *(GLboolean *)(pc + 12);
d258 4
a261 2
    CALL_GetConvolutionParameteriv( GET_DISPATCH(), (target, GL_CONVOLUTION_WIDTH, &width) );
    CALL_GetConvolutionParameteriv( GET_DISPATCH(), (target, GL_CONVOLUTION_HEIGHT, &height) );
d266 2
a267 2
    compsize = __glGetTexImage_size(target,1,format,type,width,1,1);
    compsize2 = __glGetTexImage_size(target,1,format,type,height,1,1);
d269 4
a272 2
    if (compsize < 0) compsize = 0;
    if (compsize2 < 0) compsize2 = 0;
d276 2
a277 2
    CALL_PixelStorei( GET_DISPATCH(), (GL_PACK_SWAP_BYTES, !swapBytes) );
    __GLX_GET_ANSWER_BUFFER(answer,cl,compsize + compsize2,1);
d279 4
a282 8
    CALL_GetSeparableFilter( GET_DISPATCH(), (
		  *(GLenum   *)(pc + 0),
		  *(GLenum   *)(pc + 4),
		  *(GLenum   *)(pc + 8),
		  answer,
		  answer + compsize,
		  NULL
		  ) );
d285 11
a295 10
	__GLX_BEGIN_REPLY(0);
	__GLX_SWAP_REPLY_HEADER();
    } else {
	__GLX_BEGIN_REPLY(compsize + compsize2);
	__GLX_SWAP_REPLY_HEADER();
	__GLX_SWAP_INT(&width);
	__GLX_SWAP_INT(&height);
	((xGLXGetSeparableFilterReply *)&__glXReply)->width = width;
	((xGLXGetSeparableFilterReply *)&__glXReply)->height = height;
	__GLX_SEND_VOID_ARRAY(compsize + compsize2);
d301 2
a302 1
int __glXDispSwap_GetSeparableFilter(__GLXclientState *cl, GLbyte *pc)
d309 2
a310 1
int __glXDispSwap_GetSeparableFilterEXT(__GLXclientState *cl, GLbyte *pc)
d317 2
a318 1
static int GetConvolutionFilter(__GLXclientState *cl, GLbyte *pc, GLXContextTag tag)
d326 1
d329 1
a329 1
    GLint width=0, height=0;
d333 1
a333 1
	return error;
d336 3
a338 3
    __GLX_SWAP_INT(pc+0);
    __GLX_SWAP_INT(pc+4);
    __GLX_SWAP_INT(pc+8);
d340 4
a343 4
    format = *(GLenum *)(pc + 4);
    type = *(GLenum *)(pc + 8);
    target = *(GLenum *)(pc + 0);
    swapBytes = *(GLboolean *)(pc + 12);
d345 2
a346 1
    CALL_GetConvolutionParameteriv( GET_DISPATCH(), (target, GL_CONVOLUTION_WIDTH, &width) );
d349 5
a353 2
    } else {
	CALL_GetConvolutionParameteriv( GET_DISPATCH(), (target, GL_CONVOLUTION_HEIGHT, &height) );
d359 3
a361 2
    compsize = __glGetTexImage_size(target,1,format,type,width,height,1);
    if (compsize < 0) compsize = 0;
d363 2
a364 2
    CALL_PixelStorei( GET_DISPATCH(), (GL_PACK_SWAP_BYTES, !swapBytes) );
    __GLX_GET_ANSWER_BUFFER(answer,cl,compsize,1);
d366 3
a368 6
    CALL_GetConvolutionFilter( GET_DISPATCH(), (
		  *(GLenum   *)(pc + 0),
		  *(GLenum   *)(pc + 4),
		  *(GLenum   *)(pc + 8),
		  answer
		  ) );
d371 11
a381 10
	__GLX_BEGIN_REPLY(0);
	__GLX_SWAP_REPLY_HEADER();
    } else {
	__GLX_BEGIN_REPLY(compsize);
	__GLX_SWAP_REPLY_HEADER();
	__GLX_SWAP_INT(&width);
	__GLX_SWAP_INT(&height);
	((xGLXGetConvolutionFilterReply *)&__glXReply)->width = width;
	((xGLXGetConvolutionFilterReply *)&__glXReply)->height = height;
	__GLX_SEND_VOID_ARRAY(compsize);
d387 2
a388 1
int __glXDispSwap_GetConvolutionFilter(__GLXclientState *cl, GLbyte *pc)
d395 2
a396 1
int __glXDispSwap_GetConvolutionFilterEXT(__GLXclientState *cl, GLbyte *pc)
d403 2
a404 1
static int GetHistogram(__GLXclientState *cl, GLbyte *pc, GLXContextTag tag)
d412 1
d415 1
a415 1
    GLint width=0;
d419 1
a419 1
	return error;
d422 3
a424 3
    __GLX_SWAP_INT(pc+0);
    __GLX_SWAP_INT(pc+4);
    __GLX_SWAP_INT(pc+8);
d426 5
a430 5
    format = *(GLenum *)(pc + 4);
    type = *(GLenum *)(pc + 8);
    target = *(GLenum *)(pc + 0);
    swapBytes = *(GLboolean *)(pc + 12);
    reset = *(GLboolean *)(pc + 13);
d432 2
a433 1
    CALL_GetHistogramParameteriv( GET_DISPATCH(), (target, GL_HISTOGRAM_WIDTH, &width) );
d438 3
a440 2
    compsize = __glGetTexImage_size(target,1,format,type,width,1,1);
    if (compsize < 0) compsize = 0;
d442 2
a443 2
    CALL_PixelStorei( GET_DISPATCH(), (GL_PACK_SWAP_BYTES, !swapBytes) );
    __GLX_GET_ANSWER_BUFFER(answer,cl,compsize,1);
d445 1
a445 1
    CALL_GetHistogram( GET_DISPATCH(), (target, reset, format, type, answer) );
d448 9
a456 8
	__GLX_BEGIN_REPLY(0);
	__GLX_SWAP_REPLY_HEADER();
    } else {
	__GLX_BEGIN_REPLY(compsize);
	__GLX_SWAP_REPLY_HEADER();
	__GLX_SWAP_INT(&width);
	((xGLXGetHistogramReply *)&__glXReply)->width = width;
	__GLX_SEND_VOID_ARRAY(compsize);
d462 2
a463 1
int __glXDispSwap_GetHistogram(__GLXclientState *cl, GLbyte *pc)
d470 2
a471 1
int __glXDispSwap_GetHistogramEXT(__GLXclientState *cl, GLbyte *pc)
d478 2
a479 1
static int GetMinmax(__GLXclientState *cl, GLbyte *pc, GLXContextTag tag)
d487 1
d493 1
a493 1
	return error;
d496 3
a498 3
    __GLX_SWAP_INT(pc+0);
    __GLX_SWAP_INT(pc+4);
    __GLX_SWAP_INT(pc+8);
d500 5
a504 5
    format = *(GLenum *)(pc + 4);
    type = *(GLenum *)(pc + 8);
    target = *(GLenum *)(pc + 0);
    swapBytes = *(GLboolean *)(pc + 12);
    reset = *(GLboolean *)(pc + 13);
d506 3
a508 2
    compsize = __glGetTexImage_size(target,1,format,type,2,1,1);
    if (compsize < 0) compsize = 0;
d510 2
a511 2
    CALL_PixelStorei( GET_DISPATCH(), (GL_PACK_SWAP_BYTES, !swapBytes) );
    __GLX_GET_ANSWER_BUFFER(answer,cl,compsize,1);
d513 1
a513 1
    CALL_GetMinmax( GET_DISPATCH(), (target, reset, format, type, answer) );
d516 7
a522 6
	__GLX_BEGIN_REPLY(0);
	__GLX_SWAP_REPLY_HEADER();
    } else {
	__GLX_BEGIN_REPLY(compsize);
	__GLX_SWAP_REPLY_HEADER();
	__GLX_SEND_VOID_ARRAY(compsize);
d528 2
a529 1
int __glXDispSwap_GetMinmax(__GLXclientState *cl, GLbyte *pc)
d536 2
a537 1
int __glXDispSwap_GetMinmaxEXT(__GLXclientState *cl, GLbyte *pc)
d544 2
a545 1
static int GetColorTable(__GLXclientState *cl, GLbyte *pc, GLXContextTag tag)
d553 1
d556 1
a556 1
    GLint width=0;
d560 1
a560 1
	return error;
d563 3
a565 3
    __GLX_SWAP_INT(pc+0);
    __GLX_SWAP_INT(pc+4);
    __GLX_SWAP_INT(pc+8);
d567 4
a570 4
    format = *(GLenum *)(pc + 4);
    type = *(GLenum *)(pc + 8);
    target = *(GLenum *)(pc + 0);
    swapBytes = *(GLboolean *)(pc + 12);
d572 2
a573 1
    CALL_GetColorTableParameteriv( GET_DISPATCH(), (target, GL_COLOR_TABLE_WIDTH, &width) );
d578 3
a580 2
    compsize = __glGetTexImage_size(target,1,format,type,width,1,1);
    if (compsize < 0) compsize = 0;
d582 2
a583 2
    CALL_PixelStorei( GET_DISPATCH(), (GL_PACK_SWAP_BYTES, !swapBytes) );
    __GLX_GET_ANSWER_BUFFER(answer,cl,compsize,1);
d585 3
a587 6
    CALL_GetColorTable( GET_DISPATCH(), (
		  *(GLenum   *)(pc + 0),
		  *(GLenum   *)(pc + 4),
		  *(GLenum   *)(pc + 8),
		  answer
		  ) );
d590 9
a598 8
	__GLX_BEGIN_REPLY(0);
	__GLX_SWAP_REPLY_HEADER();
    } else {
	__GLX_BEGIN_REPLY(compsize);
	__GLX_SWAP_REPLY_HEADER();
	__GLX_SWAP_INT(&width);
	((xGLXGetColorTableReply *)&__glXReply)->width = width;
	__GLX_SEND_VOID_ARRAY(compsize);
d604 2
a605 1
int __glXDispSwap_GetColorTable(__GLXclientState *cl, GLbyte *pc)
d612 2
a613 1
int __glXDispSwap_GetColorTableSGI(__GLXclientState *cl, GLbyte *pc)
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d105 1
a105 1
    __GLX_NOTE_FLUSHED_CMDS(cx);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a30 1
#define NEED_REPLIES
d105 1
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d2 28
a29 33
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: The application programming interfaces
** established by SGI in conjunction with the Original Code are The
** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
** Window System(R) (Version 1.3), released October 19, 1998. This software
** was created using the OpenGL(R) version 1.2.1 Sample Implementation
** published by SGI, but has not been independently verified as being
** compliant with the OpenGL(R) version 1.2.1 Specification.
**
*/
@

