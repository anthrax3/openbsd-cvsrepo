head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2015.02.11.20.58.47;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	dgcmwPGRv39E4MF9;

1.7
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.05.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.05.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright Â© 2006 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */
/*
 * This Xinerama implementation comes from the SiS driver which has
 * the following notice:
 */
/*
 * SiS driver main code
 *
 * Copyright (C) 2001-2005 by Thomas Winischhofer, Vienna, Austria.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author: Thomas Winischhofer <thomas@@winischhofer.net>
 *	- driver entirely rewritten since 2001, only basic structure taken from
 *	  old code (except sis_dri.c, sis_shadow.c, sis_accel.c and parts of
 *	  sis_dga.c; these were mostly taken over; sis_dri.c was changed for
 *	  new versions of the DRI layer)
 *
 * This notice covers the entire driver code unless indicated otherwise.
 *
 * Formerly based on code which was
 * 	     Copyright (C) 1998, 1999 by Alan Hourihane, Wigan, England.
 * 	     Written by:
 *           Alan Hourihane <alanh@@fairlite.demon.co.uk>,
 *           Mike Chapman <mike@@paranoia.com>,
 *           Juanjo Santamarta <santamarta@@ctv.es>,
 *           Mitani Hiroshi <hmitani@@drl.mei.co.jp>,
 *           David Thomas <davtom@@dream.org.uk>.
 */

#include "randrstr.h"
#include "swaprep.h"
#include <X11/extensions/panoramiXproto.h>
#include "protocol-versions.h"

/* Xinerama is not multi-screen capable; just report about screen 0 */
#define RR_XINERAMA_SCREEN  0

static int ProcRRXineramaQueryVersion(ClientPtr client);
static int ProcRRXineramaGetState(ClientPtr client);
static int ProcRRXineramaGetScreenCount(ClientPtr client);
static int ProcRRXineramaGetScreenSize(ClientPtr client);
static int ProcRRXineramaIsActive(ClientPtr client);
static int ProcRRXineramaQueryScreens(ClientPtr client);
static int SProcRRXineramaDispatch(ClientPtr client);

Bool noRRXineramaExtension = FALSE;

/* Proc */

int
ProcRRXineramaQueryVersion(ClientPtr client)
{
    xPanoramiXQueryVersionReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .majorVersion = SERVER_RRXINERAMA_MAJOR_VERSION,
        .minorVersion = SERVER_RRXINERAMA_MINOR_VERSION
    };

    REQUEST_SIZE_MATCH(xPanoramiXQueryVersionReq);
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.majorVersion);
        swaps(&rep.minorVersion);
    }
    WriteToClient(client, sizeof(xPanoramiXQueryVersionReply), &rep);
    return Success;
}

int
ProcRRXineramaGetState(ClientPtr client)
{
    REQUEST(xPanoramiXGetStateReq);
    WindowPtr pWin;
    xPanoramiXGetStateReply rep;
    register int rc;
    ScreenPtr pScreen;
    rrScrPrivPtr pScrPriv;
    Bool active = FALSE;

    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    pScreen = pWin->drawable.pScreen;
    pScrPriv = rrGetScrPriv(pScreen);
    if (pScrPriv) {
        /* XXX do we need more than this? */
        active = TRUE;
    }

    rep = (xPanoramiXGetStateReply) {
        .type = X_Reply,
        .state = active,
        .sequenceNumber = client->sequence,
        .length = 0,
        .window = stuff->window
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.window);
    }
    WriteToClient(client, sizeof(xPanoramiXGetStateReply), &rep);
    return Success;
}

static int
RRXineramaScreenCount(ScreenPtr pScreen)
{
    return RRMonitorCountList(pScreen);
}

static Bool
RRXineramaScreenActive(ScreenPtr pScreen)
{
    return RRXineramaScreenCount(pScreen) > 0;
}

int
ProcRRXineramaGetScreenCount(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenCountReq);
    WindowPtr pWin;
    xPanoramiXGetScreenCountReply rep;
    register int rc;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    rep = (xPanoramiXGetScreenCountReply)  {
        .type = X_Reply,
        .ScreenCount = RRXineramaScreenCount(pWin->drawable.pScreen),
        .sequenceNumber = client->sequence,
        .length = 0,
        .window = stuff->window
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.window);
    }
    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), &rep);
    return Success;
}

int
ProcRRXineramaGetScreenSize(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenSizeReq);
    WindowPtr pWin, pRoot;
    ScreenPtr pScreen;
    xPanoramiXGetScreenSizeReply rep;
    register int rc;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    pScreen = pWin->drawable.pScreen;
    pRoot = pScreen->root;

    rep = (xPanoramiXGetScreenSizeReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .width = pRoot->drawable.width,
        .height = pRoot->drawable.height,
        .window = stuff->window,
        .screen = stuff->screen
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.width);
        swapl(&rep.height);
        swapl(&rep.window);
        swapl(&rep.screen);
    }
    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), &rep);
    return Success;
}

int
ProcRRXineramaIsActive(ClientPtr client)
{
    xXineramaIsActiveReply rep;

    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);

    rep = (xXineramaIsActiveReply) {
        .type = X_Reply,
        .length = 0,
        .sequenceNumber = client->sequence,
        .state = RRXineramaScreenActive(screenInfo.screens[RR_XINERAMA_SCREEN])
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.state);
    }
    WriteToClient(client, sizeof(xXineramaIsActiveReply), &rep);
    return Success;
}

static void
RRXineramaWriteMonitor(ClientPtr client, RRMonitorPtr monitor)
{
    xXineramaScreenInfo scratch;

    scratch.x_org = monitor->geometry.box.x1;
    scratch.y_org = monitor->geometry.box.y1;
    scratch.width = monitor->geometry.box.x2 - monitor->geometry.box.x1;
    scratch.height = monitor->geometry.box.y2 - monitor->geometry.box.y1;

    WriteToClient(client, sz_XineramaScreenInfo, &scratch);
}

int
ProcRRXineramaQueryScreens(ClientPtr client)
{
    xXineramaQueryScreensReply rep;
    ScreenPtr pScreen = screenInfo.screens[RR_XINERAMA_SCREEN];
    int m;
    RRMonitorPtr monitors = NULL;
    int nmonitors = 0;

    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);

    if (RRXineramaScreenActive(pScreen)) {
        RRGetInfo(pScreen, FALSE);
        if (!RRMonitorMakeList(pScreen, TRUE, &monitors, &nmonitors))
            return BadAlloc;
    }

    rep = (xXineramaQueryScreensReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(nmonitors * sz_XineramaScreenInfo),
        .number = nmonitors
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.number);
    }
    WriteToClient(client, sizeof(xXineramaQueryScreensReply), &rep);

    for (m = 0; m < nmonitors; m++)
        RRXineramaWriteMonitor(client, &monitors[m]);

    if (monitors)
        RRMonitorFreeList(monitors, nmonitors);

    return Success;
}

static int
ProcRRXineramaDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_PanoramiXQueryVersion:
        return ProcRRXineramaQueryVersion(client);
    case X_PanoramiXGetState:
        return ProcRRXineramaGetState(client);
    case X_PanoramiXGetScreenCount:
        return ProcRRXineramaGetScreenCount(client);
    case X_PanoramiXGetScreenSize:
        return ProcRRXineramaGetScreenSize(client);
    case X_XineramaIsActive:
        return ProcRRXineramaIsActive(client);
    case X_XineramaQueryScreens:
        return ProcRRXineramaQueryScreens(client);
    }
    return BadRequest;
}

/* SProc */

static int
SProcRRXineramaQueryVersion(ClientPtr client)
{
    REQUEST(xPanoramiXQueryVersionReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xPanoramiXQueryVersionReq);
    return ProcRRXineramaQueryVersion(client);
}

static int
SProcRRXineramaGetState(ClientPtr client)
{
    REQUEST(xPanoramiXGetStateReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
    swapl(&stuff->window);
    return ProcRRXineramaGetState(client);
}

static int
SProcRRXineramaGetScreenCount(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenCountReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
    swapl(&stuff->window);
    return ProcRRXineramaGetScreenCount(client);
}

static int
SProcRRXineramaGetScreenSize(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenSizeReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
    swapl(&stuff->window);
    swapl(&stuff->screen);
    return ProcRRXineramaGetScreenSize(client);
}

static int
SProcRRXineramaIsActive(ClientPtr client)
{
    REQUEST(xXineramaIsActiveReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
    return ProcRRXineramaIsActive(client);
}

static int
SProcRRXineramaQueryScreens(ClientPtr client)
{
    REQUEST(xXineramaQueryScreensReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
    return ProcRRXineramaQueryScreens(client);
}

int
SProcRRXineramaDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_PanoramiXQueryVersion:
        return SProcRRXineramaQueryVersion(client);
    case X_PanoramiXGetState:
        return SProcRRXineramaGetState(client);
    case X_PanoramiXGetScreenCount:
        return SProcRRXineramaGetScreenCount(client);
    case X_PanoramiXGetScreenSize:
        return SProcRRXineramaGetScreenSize(client);
    case X_XineramaIsActive:
        return SProcRRXineramaIsActive(client);
    case X_XineramaQueryScreens:
        return SProcRRXineramaQueryScreens(client);
    }
    return BadRequest;
}

void
RRXineramaExtensionInit(void)
{
#ifdef PANORAMIX
    if (!noPanoramiXExtension)
        return;
#endif

    if (noRRXineramaExtension)
      return;

    /*
     * Xinerama isn't capable enough to have multiple protocol screens each
     * with their own output geometry.  So if there's more than one protocol
     * screen, just don't even try.
     */
    if (screenInfo.numScreens > 1)
        return;

    (void) AddExtension(PANORAMIX_PROTOCOL_NAME, 0, 0,
                        ProcRRXineramaDispatch,
                        SProcRRXineramaDispatch, NULL, StandardMinorOpcode);
}
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d87 2
a151 6
static Bool
RRXineramaCrtcActive(RRCrtcPtr crtc)
{
    return crtc->mode != NULL && crtc->numOutputs > 0;
}

d155 1
a155 20
    int i, n;
    ScreenPtr slave;

    n = 0;
    if (rrGetScrPriv(pScreen)) {
        rrScrPriv(pScreen);
        for (i = 0; i < pScrPriv->numCrtcs; i++)
            if (RRXineramaCrtcActive(pScrPriv->crtcs[i]))
                n++;
    }

    xorg_list_for_each_entry(slave, &pScreen->output_slave_list, output_head) {
        rrScrPrivPtr pSlavePriv;
        pSlavePriv = rrGetScrPriv(slave);
        for (i = 0; i < pSlavePriv->numCrtcs; i++)
            if (RRXineramaCrtcActive(pSlavePriv->crtcs[i]))
                n++;
    }

    return n;
d254 1
a254 1
RRXineramaWriteCrtc(ClientPtr client, RRCrtcPtr crtc)
d258 6
a263 32
    if (RRXineramaCrtcActive(crtc)) {
        ScreenPtr pScreen = crtc->pScreen;
        rrScrPrivPtr pScrPriv = rrGetScrPriv(pScreen);
        BoxRec panned_area;

        /* Check to see if crtc is panned and return the full area when applicable. */
        if (pScrPriv && pScrPriv->rrGetPanning &&
            pScrPriv->rrGetPanning(pScreen, crtc, &panned_area, NULL, NULL) &&
            (panned_area.x2 > panned_area.x1) &&
            (panned_area.y2 > panned_area.y1)) {
            scratch.x_org = panned_area.x1;
            scratch.y_org = panned_area.y1;
            scratch.width = panned_area.x2 - panned_area.x1;
            scratch.height = panned_area.y2 - panned_area.y1;
        }
        else {
            int width, height;

            RRCrtcGetScanoutSize(crtc, &width, &height);
            scratch.x_org = crtc->x;
            scratch.y_org = crtc->y;
            scratch.width = width;
            scratch.height = height;
        }
        if (client->swapped) {
            swaps(&scratch.x_org);
            swaps(&scratch.y_org);
            swaps(&scratch.width);
            swaps(&scratch.height);
        }
        WriteToClient(client, sz_XineramaScreenInfo, &scratch);
    }
d271 3
a273 2
    int n = 0;
    int i;
d279 2
a280 1
        n = RRXineramaScreenCount(pScreen);
d286 2
a287 2
        .length = bytes_to_int32(n * sz_XineramaScreenInfo),
        .number = n
d296 5
a300 34
    if (n) {
        ScreenPtr slave;
        rrScrPriv(pScreen);
        int has_primary = 0;
        RRCrtcPtr primary_crtc = NULL;

        if (pScrPriv->primaryOutput && pScrPriv->primaryOutput->crtc) {
            has_primary = 1;
            primary_crtc = pScrPriv->primaryOutput->crtc;
            RRXineramaWriteCrtc(client, pScrPriv->primaryOutput->crtc);
        }

        for (i = 0; i < pScrPriv->numCrtcs; i++) {
            if (has_primary &&
                primary_crtc == pScrPriv->crtcs[i]) {
                has_primary = 0;
                continue;
            }
            RRXineramaWriteCrtc(client, pScrPriv->crtcs[i]);
        }

        xorg_list_for_each_entry(slave, &pScreen->output_slave_list, output_head) {
            rrScrPrivPtr pSlavePriv;
            pSlavePriv = rrGetScrPriv(slave);
            for (i = 0; i < pSlavePriv->numCrtcs; i++) {
                if (has_primary &&
                    primary_crtc == pSlavePriv->crtcs[i]) {
                    has_primary = 0;
                    continue;
                }
                RRXineramaWriteCrtc(client, pSlavePriv->crtcs[i]);
            }
        }
    }
d414 3
@


1.8
log
@Update to xserver 1.16.4.
Contains fix for CVE-2015-0255. ok dcoppa@@
@
text
@d26 1
a26 1
/* 
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d347 1
d351 1
d357 1
a357 1
                pScrPriv->primaryOutput->crtc == pScrPriv->crtcs[i]) {
d367 6
a372 1
            for (i = 0; i < pSlavePriv->numCrtcs; i++)
d374 1
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d92 7
a98 1
    xPanoramiXQueryVersionReply rep;
a100 5
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_RRXINERAMA_MAJOR_VERSION;
    rep.minorVersion = SERVER_RRXINERAMA_MINOR_VERSION;
d107 1
a107 1
    WriteToClient(client, sizeof(xPanoramiXQueryVersionReply), (char *) &rep);
d134 7
a140 5
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.state = active;
    rep.window = stuff->window;
d146 1
a146 1
    WriteToClient(client, sizeof(xPanoramiXGetStateReply), (char *) &rep);
d160 1
d169 9
d200 7
a206 5
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.ScreenCount = RRXineramaScreenCount(pWin->drawable.pScreen);
    rep.window = stuff->window;
d212 1
a212 1
    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), (char *) &rep);
d233 9
a241 7
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.width = pRoot->drawable.width;
    rep.height = pRoot->drawable.height;
    rep.window = stuff->window;
    rep.screen = stuff->screen;
d250 1
a250 1
    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), (char *) &rep);
d261 6
a266 5
    memset(&rep, 0, sizeof(xXineramaIsActiveReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.state = RRXineramaScreenActive(screenInfo.screens[RR_XINERAMA_SCREEN]);
d272 1
a272 1
    WriteToClient(client, sizeof(xXineramaIsActiveReply), (char *) &rep);
d320 2
d325 1
a325 1
    if (RRXineramaScreenActive(pScreen))
d327 2
d330 6
a335 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.number = RRXineramaScreenCount(pScreen);
    rep.length = bytes_to_int32(rep.number * sz_XineramaScreenInfo);
d341 1
a341 1
    WriteToClient(client, sizeof(xXineramaQueryScreensReply), (char *) &rep);
d343 2
a344 1
    if (rep.number) {
a345 1
        int i;
d360 7
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d92 1
a92 2
    xPanoramiXQueryVersionReply	  rep;
    register int		  n;
d100 5
a104 5
    if(client->swapped) {
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swaps(&rep.majorVersion, n);
        swaps(&rep.minorVersion, n);
d106 1
a106 1
    WriteToClient(client, sizeof(xPanoramiXQueryVersionReply), (char *)&rep);
d114 6
a119 6
    WindowPtr			pWin;
    xPanoramiXGetStateReply	rep;
    register int		n, rc;
    ScreenPtr			pScreen;
    rrScrPrivPtr		pScrPriv;
    Bool			active = FALSE;
d123 2
a124 2
    if(rc != Success)
	return rc;
d128 3
a130 4
    if (pScrPriv)
    {
	/* XXX do we need more than this? */
	active = TRUE;
d138 4
a141 4
    if(client->swapped) {
       swaps (&rep.sequenceNumber, n);
       swapl (&rep.length, n);
       swapl (&rep.window, n);
d143 1
a143 1
    WriteToClient(client, sizeof(xPanoramiXGetStateReply), (char *)&rep);
d148 1
a148 1
RRXineramaCrtcActive (RRCrtcPtr crtc)
d154 1
a154 1
RRXineramaScreenCount (ScreenPtr pScreen)
d156 2
a157 2
    int	i, n;
    
d159 5
a163 6
    if (rrGetScrPriv (pScreen))
    {
	rrScrPriv(pScreen);
	for (i = 0; i < pScrPriv->numCrtcs; i++)
	    if (RRXineramaCrtcActive (pScrPriv->crtcs[i]))
		n++;
d169 1
a169 1
RRXineramaScreenActive (ScreenPtr pScreen)
d171 1
a171 1
    return RRXineramaScreenCount (pScreen) > 0;
d178 3
a180 3
    WindowPtr				pWin;
    xPanoramiXGetScreenCountReply	rep;
    register int			n, rc;
d185 2
a186 2
	return rc;
    
d190 1
a190 1
    rep.ScreenCount = RRXineramaScreenCount (pWin->drawable.pScreen);
d192 4
a195 4
    if(client->swapped) {
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swapl(&rep.window, n);
d197 1
a197 1
    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), (char *)&rep);
d205 4
a208 4
    WindowPtr				pWin, pRoot;
    ScreenPtr				pScreen;
    xPanoramiXGetScreenSizeReply	rep;
    register int			n, rc;
d213 1
a213 1
	return rc;
d217 1
a217 1
    
d221 1
a221 1
    rep.width  = pRoot->drawable.width;
d225 7
a231 7
    if(client->swapped) {
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swapl(&rep.width, n);
       swapl(&rep.height, n);
       swapl(&rep.window, n);
       swapl(&rep.screen, n);
d233 1
a233 1
    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), (char *)&rep);
d240 1
a240 1
    xXineramaIsActiveReply	rep;
d248 5
a252 6
    rep.state = RRXineramaScreenActive (screenInfo.screens[RR_XINERAMA_SCREEN]);
    if(client->swapped) {
	register int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.state, n);
d263 31
a293 30
    if (RRXineramaCrtcActive (crtc))
    {
	ScreenPtr pScreen = crtc->pScreen;
	rrScrPrivPtr pScrPriv = rrGetScrPriv(pScreen);
	BoxRec panned_area;

	/* Check to see if crtc is panned and return the full area when applicable. */
	if (pScrPriv && pScrPriv->rrGetPanning &&
	    pScrPriv->rrGetPanning (pScreen, crtc, &panned_area, NULL, NULL) &&
	    (panned_area.x2 > panned_area.x1) && (panned_area.y2 > panned_area.y1)) {
	    scratch.x_org  = panned_area.x1;
	    scratch.y_org  = panned_area.y1;
	    scratch.width  = panned_area.x2  - panned_area.x1;
	    scratch.height = panned_area.y2  - panned_area.y1;
	} else {
	    int width, height;
	    RRCrtcGetScanoutSize (crtc, &width, &height);
	    scratch.x_org  = crtc->x;
	    scratch.y_org  = crtc->y;
	    scratch.width  = width;
	    scratch.height = height;
	}
	if(client->swapped) {
	    register int n;
	    swaps(&scratch.x_org, n);
	    swaps(&scratch.y_org, n);
	    swaps(&scratch.width, n);
	    swaps(&scratch.height, n);
	}
	WriteToClient(client, sz_XineramaScreenInfo, &scratch);
d300 2
a301 2
    xXineramaQueryScreensReply	rep;
    ScreenPtr	pScreen = screenInfo.screens[RR_XINERAMA_SCREEN];
d305 2
a306 2
    if (RRXineramaScreenActive (pScreen))
	RRGetInfo (pScreen, FALSE);
d310 1
a310 1
    rep.number = RRXineramaScreenCount (pScreen);
d312 25
a336 27
    if(client->swapped) {
	register int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.number, n);
    }
    WriteToClient(client, sizeof(xXineramaQueryScreensReply), (char *)&rep);

    if(rep.number) {
	rrScrPriv(pScreen);
	int i;
	int has_primary = 0;

	if (pScrPriv->primaryOutput && pScrPriv->primaryOutput->crtc) {
	    has_primary = 1;
	    RRXineramaWriteCrtc(client, pScrPriv->primaryOutput->crtc);
	}

	for(i = 0; i < pScrPriv->numCrtcs; i++) {
	    if (has_primary &&
		pScrPriv->primaryOutput->crtc == pScrPriv->crtcs[i])
	    {
		has_primary = 0;
		continue;
	    }
	    RRXineramaWriteCrtc(client, pScrPriv->crtcs[i]);
	}
d347 12
a358 12
	case X_PanoramiXQueryVersion:
	     return ProcRRXineramaQueryVersion(client);
	case X_PanoramiXGetState:
	     return ProcRRXineramaGetState(client);
	case X_PanoramiXGetScreenCount:
	     return ProcRRXineramaGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return ProcRRXineramaGetScreenSize(client);
	case X_XineramaIsActive:
	     return ProcRRXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return ProcRRXineramaQueryScreens(client);
d366 1
a366 1
SProcRRXineramaQueryVersion (ClientPtr client)
d369 2
a370 3
    register int n;
    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
d378 1
a378 2
    register int n;
    swaps (&stuff->length, n);
d380 1
a380 1
    swapl (&stuff->window, n);
d388 1
a388 2
    register int n;
    swaps (&stuff->length, n);
d390 1
a390 1
    swapl (&stuff->window, n);
d398 1
a398 2
    register int n;
    swaps (&stuff->length, n);
d400 2
a401 2
    swapl (&stuff->window, n);
    swapl (&stuff->screen, n);
d409 1
a409 2
    register int n;
    swaps (&stuff->length, n);
d418 1
a418 2
    register int n;
    swaps (&stuff->length, n);
d428 12
a439 12
	case X_PanoramiXQueryVersion:
	     return SProcRRXineramaQueryVersion(client);
	case X_PanoramiXGetState:
	     return SProcRRXineramaGetState(client);
	case X_PanoramiXGetScreenCount:
	     return SProcRRXineramaGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return SProcRRXineramaGetScreenSize(client);
	case X_XineramaIsActive:
	     return SProcRRXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return SProcRRXineramaQueryScreens(client);
d448 2
a449 2
    if(!noPanoramiXExtension)
	return;
d458 1
a458 1
	return;
d460 3
a462 5
    (void) AddExtension(PANORAMIX_PROTOCOL_NAME, 0,0,
			ProcRRXineramaDispatch,
			SProcRRXineramaDispatch,
			NULL,
			StandardMinorOpcode);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d108 1
a108 1
    return (client->noClientException);
d146 1
a146 1
    return client->noClientException;
d201 1
a201 1
    return client->noClientException;
d219 1
a219 1
    pRoot = WindowTable[pScreen->myNum];
d237 1
a237 1
    return client->noClientException;
d259 1
a259 1
    return client->noClientException;
d344 1
a344 1
    return client->noClientException;
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d74 1
a74 3

#define RR_XINERAMA_MAJOR_VERSION   1
#define RR_XINERAMA_MINOR_VERSION   1
d99 2
a100 2
    rep.majorVersion = RR_XINERAMA_MAJOR_VERSION;
    rep.minorVersion = RR_XINERAMA_MINOR_VERSION;
d246 2
a247 1
	
d314 1
a314 1
    rep.length = rep.number * sz_XineramaScreenInfo >> 2;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d263 38
d310 2
a311 6
    {
	rrScrPriv(pScreen);
	if (pScrPriv->numCrtcs == 0 || pScrPriv->numOutputs == 0)
	    RRGetInfo (pScreen);
    }
    
a325 1
	xXineramaScreenInfo scratch;
d327 6
d335 2
a336 2
	    RRCrtcPtr	crtc = pScrPriv->crtcs[i];
	    if (RRXineramaCrtcActive (crtc))
d338 2
a339 14
	        int width, height;
		RRCrtcGetScanoutSize (crtc, &width, &height);
		scratch.x_org  = crtc->x;
		scratch.y_org  = crtc->y;
		scratch.width  = width;
		scratch.height = height;
		if(client->swapped) {
		    register int n;
		    swaps(&scratch.x_org, n);
		    swaps(&scratch.y_org, n);
		    swaps(&scratch.width, n);
		    swaps(&scratch.height, n);
		}
		WriteToClient(client, sz_XineramaScreenInfo, (char *)&scratch);
d341 1
a455 5
static void
RRXineramaResetProc(ExtensionEntry* extEntry)
{
}

d475 1
a475 1
			RRXineramaResetProc,
@


1.1
log
@Initial revision
@
text
@d125 1
a125 1
    rc = dixLookupWindow(&pWin, stuff->window, client, DixUnknownAccess);
d141 1
d145 1
a145 1
       swaps (&rep.state, n);
d188 1
a188 1
    rc = dixLookupWindow(&pWin, stuff->window, client, DixUnknownAccess);
d196 1
d200 1
a200 1
       swaps(&rep.ScreenCount, n);
d216 1
a216 1
    rc = dixLookupWindow(&pWin, stuff->window, client, DixUnknownAccess);
d228 2
d233 4
a236 2
       swaps(&rep.width, n);
       swaps(&rep.height, n);
d360 1
d371 1
d382 2
@


1.1.1.1
log
@xserver 1.4
@
text
@@
