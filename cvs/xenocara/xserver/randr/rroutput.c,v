head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	s0SI41sEunLdyFfd;

1.12
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2015.02.11.20.58.47;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	dgcmwPGRv39E4MF9;

1.10
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2013.12.28.14.40.02;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.05.13;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.05.13;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright © 2006 Keith Packard
 * Copyright © 2008 Red Hat, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"

RESTYPE RROutputType;

/*
 * Notify the output of some change
 */
void
RROutputChanged(RROutputPtr output, Bool configChanged)
{
    /* set changed bits on the master screen only */
    ScreenPtr pScreen = output->pScreen;
    rrScrPrivPtr mastersp;

    output->changed = TRUE;
    if (!pScreen)
        return;

    if (pScreen->isGPU) {
        ScreenPtr master = pScreen->current_master;
        if (!master)
            return;
        mastersp = rrGetScrPriv(master);
    }
    else {
        mastersp = rrGetScrPriv(pScreen);
    }

    RRSetChanged(pScreen);
    if (configChanged)
        mastersp->configChanged = TRUE;
}

/*
 * Create an output
 */

RROutputPtr
RROutputCreate(ScreenPtr pScreen,
               const char *name, int nameLength, void *devPrivate)
{
    RROutputPtr output;
    RROutputPtr *outputs;
    rrScrPrivPtr pScrPriv;

    if (!RRInit())
        return NULL;

    pScrPriv = rrGetScrPriv(pScreen);

    if (pScrPriv->numOutputs)
        outputs = reallocarray(pScrPriv->outputs,
                               pScrPriv->numOutputs + 1, sizeof(RROutputPtr));
    else
        outputs = malloc(sizeof(RROutputPtr));
    if (!outputs)
        return FALSE;

    pScrPriv->outputs = outputs;

    output = malloc(sizeof(RROutputRec) + nameLength + 1);
    if (!output)
        return NULL;
    output->id = FakeClientID(0);
    output->pScreen = pScreen;
    output->name = (char *) (output + 1);
    output->nameLength = nameLength;
    memcpy(output->name, name, nameLength);
    output->name[nameLength] = '\0';
    output->connection = RR_UnknownConnection;
    output->subpixelOrder = SubPixelUnknown;
    output->mmWidth = 0;
    output->mmHeight = 0;
    output->crtc = NULL;
    output->numCrtcs = 0;
    output->crtcs = NULL;
    output->numClones = 0;
    output->clones = NULL;
    output->numModes = 0;
    output->numPreferred = 0;
    output->modes = NULL;
    output->numUserModes = 0;
    output->userModes = NULL;
    output->properties = NULL;
    output->pendingProperties = FALSE;
    output->changed = FALSE;
    output->devPrivate = devPrivate;

    if (!AddResource(output->id, RROutputType, (void *) output))
        return NULL;

    pScrPriv->outputs[pScrPriv->numOutputs++] = output;

    RRResourcesChanged(pScreen);

    return output;
}

/*
 * Notify extension that output parameters have been changed
 */
Bool
RROutputSetClones(RROutputPtr output, RROutputPtr * clones, int numClones)
{
    RROutputPtr *newClones;
    int i;

    if (numClones == output->numClones) {
        for (i = 0; i < numClones; i++)
            if (output->clones[i] != clones[i])
                break;
        if (i == numClones)
            return TRUE;
    }
    if (numClones) {
        newClones = xallocarray(numClones, sizeof(RROutputPtr));
        if (!newClones)
            return FALSE;
    }
    else
        newClones = NULL;
    free(output->clones);
    memcpy(newClones, clones, numClones * sizeof(RROutputPtr));
    output->clones = newClones;
    output->numClones = numClones;
    RROutputChanged(output, TRUE);
    return TRUE;
}

Bool
RROutputSetModes(RROutputPtr output,
                 RRModePtr * modes, int numModes, int numPreferred)
{
    RRModePtr *newModes;
    int i;

    if (numModes == output->numModes && numPreferred == output->numPreferred) {
        for (i = 0; i < numModes; i++)
            if (output->modes[i] != modes[i])
                break;
        if (i == numModes) {
            for (i = 0; i < numModes; i++)
                RRModeDestroy(modes[i]);
            return TRUE;
        }
    }

    if (numModes) {
        newModes = xallocarray(numModes, sizeof(RRModePtr));
        if (!newModes)
            return FALSE;
    }
    else
        newModes = NULL;
    if (output->modes) {
        for (i = 0; i < output->numModes; i++)
            RRModeDestroy(output->modes[i]);
        free(output->modes);
    }
    memcpy(newModes, modes, numModes * sizeof(RRModePtr));
    output->modes = newModes;
    output->numModes = numModes;
    output->numPreferred = numPreferred;
    RROutputChanged(output, TRUE);
    return TRUE;
}

int
RROutputAddUserMode(RROutputPtr output, RRModePtr mode)
{
    int m;
    ScreenPtr pScreen = output->pScreen;

    rrScrPriv(pScreen);
    RRModePtr *newModes;

    /* Check to see if this mode is already listed for this output */
    for (m = 0; m < output->numModes + output->numUserModes; m++) {
        RRModePtr e = (m < output->numModes ?
                       output->modes[m] :
                       output->userModes[m - output->numModes]);
        if (mode == e)
            return Success;
    }

    /* Check with the DDX to see if this mode is OK */
    if (pScrPriv->rrOutputValidateMode)
        if (!pScrPriv->rrOutputValidateMode(pScreen, output, mode))
            return BadMatch;

    if (output->userModes)
        newModes = reallocarray(output->userModes,
                                output->numUserModes + 1, sizeof(RRModePtr));
    else
        newModes = malloc(sizeof(RRModePtr));
    if (!newModes)
        return BadAlloc;

    output->userModes = newModes;
    output->userModes[output->numUserModes++] = mode;
    ++mode->refcnt;
    RROutputChanged(output, TRUE);
    RRTellChanged(pScreen);
    return Success;
}

int
RROutputDeleteUserMode(RROutputPtr output, RRModePtr mode)
{
    int m;

    /* Find this mode in the user mode list */
    for (m = 0; m < output->numUserModes; m++) {
        RRModePtr e = output->userModes[m];

        if (mode == e)
            break;
    }
    /* Not there, access error */
    if (m == output->numUserModes)
        return BadAccess;

    /* make sure the mode isn't active for this output */
    if (output->crtc && output->crtc->mode == mode)
        return BadMatch;

    memmove(output->userModes + m, output->userModes + m + 1,
            (output->numUserModes - m - 1) * sizeof(RRModePtr));
    output->numUserModes--;
    RRModeDestroy(mode);
    return Success;
}

Bool
RROutputSetCrtcs(RROutputPtr output, RRCrtcPtr * crtcs, int numCrtcs)
{
    RRCrtcPtr *newCrtcs;
    int i;

    if (numCrtcs == output->numCrtcs) {
        for (i = 0; i < numCrtcs; i++)
            if (output->crtcs[i] != crtcs[i])
                break;
        if (i == numCrtcs)
            return TRUE;
    }
    if (numCrtcs) {
        newCrtcs = xallocarray(numCrtcs, sizeof(RRCrtcPtr));
        if (!newCrtcs)
            return FALSE;
    }
    else
        newCrtcs = NULL;
    free(output->crtcs);
    memcpy(newCrtcs, crtcs, numCrtcs * sizeof(RRCrtcPtr));
    output->crtcs = newCrtcs;
    output->numCrtcs = numCrtcs;
    RROutputChanged(output, TRUE);
    return TRUE;
}

Bool
RROutputSetConnection(RROutputPtr output, CARD8 connection)
{
    if (output->connection == connection)
        return TRUE;
    output->connection = connection;
    RROutputChanged(output, TRUE);
    return TRUE;
}

Bool
RROutputSetSubpixelOrder(RROutputPtr output, int subpixelOrder)
{
    if (output->subpixelOrder == subpixelOrder)
        return TRUE;

    output->subpixelOrder = subpixelOrder;
    RROutputChanged(output, FALSE);
    return TRUE;
}

Bool
RROutputSetPhysicalSize(RROutputPtr output, int mmWidth, int mmHeight)
{
    if (output->mmWidth == mmWidth && output->mmHeight == mmHeight)
        return TRUE;
    output->mmWidth = mmWidth;
    output->mmHeight = mmHeight;
    RROutputChanged(output, FALSE);
    return TRUE;
}

void
RRDeliverOutputEvent(ClientPtr client, WindowPtr pWin, RROutputPtr output)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    rrScrPriv(pScreen);
    RRCrtcPtr crtc = output->crtc;
    RRModePtr mode = crtc ? crtc->mode : NULL;

    xRROutputChangeNotifyEvent oe = {
        .type = RRNotify + RREventBase,
        .subCode = RRNotify_OutputChange,
        .timestamp = pScrPriv->lastSetTime.milliseconds,
        .configTimestamp = pScrPriv->lastConfigTime.milliseconds,
        .window = pWin->drawable.id,
        .output = output->id,
        .crtc = crtc ? crtc->id : None,
        .mode = mode ? mode->mode.id : None,
        .rotation = crtc ? crtc->rotation : RR_Rotate_0,
        .connection = output->connection,
        .subpixelOrder = output->subpixelOrder
    };
    WriteEventsToClient(client, 1, (xEvent *) &oe);
}

/*
 * Destroy a Output at shutdown
 */
void
RROutputDestroy(RROutputPtr output)
{
    FreeResource(output->id, 0);
}

static int
RROutputDestroyResource(void *value, XID pid)
{
    RROutputPtr output = (RROutputPtr) value;
    ScreenPtr pScreen = output->pScreen;
    int m;

    if (pScreen) {
        rrScrPriv(pScreen);
        int i;

        if (pScrPriv->primaryOutput == output)
            pScrPriv->primaryOutput = NULL;

        for (i = 0; i < pScrPriv->numOutputs; i++) {
            if (pScrPriv->outputs[i] == output) {
                memmove(pScrPriv->outputs + i, pScrPriv->outputs + i + 1,
                        (pScrPriv->numOutputs - (i + 1)) * sizeof(RROutputPtr));
                --pScrPriv->numOutputs;
                break;
            }
        }

        RRResourcesChanged(pScreen);
    }
    if (output->modes) {
        for (m = 0; m < output->numModes; m++)
            RRModeDestroy(output->modes[m]);
        free(output->modes);
    }

    for (m = 0; m < output->numUserModes; m++)
        RRModeDestroy(output->userModes[m]);
    free(output->userModes);

    free(output->crtcs);
    free(output->clones);
    RRDeleteAllOutputProperties(output);
    free(output);
    return 1;
}

/*
 * Initialize output type
 */
Bool
RROutputInit(void)
{
    RROutputType = CreateNewResourceType(RROutputDestroyResource, "OUTPUT");
    if (!RROutputType)
        return FALSE;

    return TRUE;
}

/*
 * Initialize output type error value
 */
void
RROutputInitErrorValue(void)
{
    SetResourceTypeErrorValue(RROutputType, RRErrorBase + BadRROutput);
}

#define OutputInfoExtra	(SIZEOF(xRRGetOutputInfoReply) - 32)

int
ProcRRGetOutputInfo(ClientPtr client)
{
    REQUEST(xRRGetOutputInfoReq);
    xRRGetOutputInfoReply rep;
    RROutputPtr output;
    CARD8 *extra;
    unsigned long extraLen;
    ScreenPtr pScreen;
    rrScrPrivPtr pScrPriv;
    RRCrtc *crtcs;
    RRMode *modes;
    RROutput *clones;
    char *name;
    int i;

    REQUEST_SIZE_MATCH(xRRGetOutputInfoReq);
    VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);

    pScreen = output->pScreen;
    pScrPriv = rrGetScrPriv(pScreen);

    rep = (xRRGetOutputInfoReply) {
        .type = X_Reply,
        .status = RRSetConfigSuccess,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(OutputInfoExtra),
        .timestamp = pScrPriv->lastSetTime.milliseconds,
        .crtc = output->crtc ? output->crtc->id : None,
        .mmWidth = output->mmWidth,
        .mmHeight = output->mmHeight,
        .connection = output->connection,
        .subpixelOrder = output->subpixelOrder,
        .nCrtcs = output->numCrtcs,
        .nModes = output->numModes + output->numUserModes,
        .nPreferred = output->numPreferred,
        .nClones = output->numClones,
        .nameLength = output->nameLength
    };
    extraLen = ((output->numCrtcs +
                 output->numModes + output->numUserModes +
                 output->numClones + bytes_to_int32(rep.nameLength)) << 2);

    if (extraLen) {
        rep.length += bytes_to_int32(extraLen);
        extra = malloc(extraLen);
        if (!extra)
            return BadAlloc;
    }
    else
        extra = NULL;

    crtcs = (RRCrtc *) extra;
    modes = (RRMode *) (crtcs + output->numCrtcs);
    clones = (RROutput *) (modes + output->numModes + output->numUserModes);
    name = (char *) (clones + output->numClones);

    for (i = 0; i < output->numCrtcs; i++) {
        crtcs[i] = output->crtcs[i]->id;
        if (client->swapped)
            swapl(&crtcs[i]);
    }
    for (i = 0; i < output->numModes + output->numUserModes; i++) {
        if (i < output->numModes)
            modes[i] = output->modes[i]->mode.id;
        else
            modes[i] = output->userModes[i - output->numModes]->mode.id;
        if (client->swapped)
            swapl(&modes[i]);
    }
    for (i = 0; i < output->numClones; i++) {
        clones[i] = output->clones[i]->id;
        if (client->swapped)
            swapl(&clones[i]);
    }
    memcpy(name, output->name, output->nameLength);
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.timestamp);
        swapl(&rep.crtc);
        swapl(&rep.mmWidth);
        swapl(&rep.mmHeight);
        swaps(&rep.nCrtcs);
        swaps(&rep.nModes);
        swaps(&rep.nPreferred);
        swaps(&rep.nClones);
        swaps(&rep.nameLength);
    }
    WriteToClient(client, sizeof(xRRGetOutputInfoReply), &rep);
    if (extraLen) {
        WriteToClient(client, extraLen, extra);
        free(extra);
    }

    return Success;
}

static void
RRSetPrimaryOutput(ScreenPtr pScreen, rrScrPrivPtr pScrPriv, RROutputPtr output)
{
    if (pScrPriv->primaryOutput == output)
        return;

    /* clear the old primary */
    if (pScrPriv->primaryOutput) {
        RROutputChanged(pScrPriv->primaryOutput, 0);
        pScrPriv->primaryOutput = NULL;
    }

    /* set the new primary */
    if (output) {
        pScrPriv->primaryOutput = output;
        RROutputChanged(output, 0);
    }

    pScrPriv->layoutChanged = TRUE;

    RRTellChanged(pScreen);
}

int
ProcRRSetOutputPrimary(ClientPtr client)
{
    REQUEST(xRRSetOutputPrimaryReq);
    RROutputPtr output = NULL;
    WindowPtr pWin;
    rrScrPrivPtr pScrPriv;
    int ret;
    ScreenPtr slave;

    REQUEST_SIZE_MATCH(xRRSetOutputPrimaryReq);

    ret = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (ret != Success)
        return ret;

    if (stuff->output) {
        VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);

        if (!output->pScreen->isGPU && output->pScreen != pWin->drawable.pScreen) {
            client->errorValue = stuff->window;
            return BadMatch;
        }
        if (output->pScreen->isGPU && output->pScreen->current_master != pWin->drawable.pScreen) {
            client->errorValue = stuff->window;
            return BadMatch;
        }
    }

    pScrPriv = rrGetScrPriv(pWin->drawable.pScreen);
    if (pScrPriv)
    {
        RRSetPrimaryOutput(pWin->drawable.pScreen, pScrPriv, output);

        xorg_list_for_each_entry(slave,
                                 &pWin->drawable.pScreen->output_slave_list,
                                 output_head) {
            rrScrPrivPtr pSlavePriv;
            pSlavePriv = rrGetScrPriv(slave);

            RRSetPrimaryOutput(slave, pSlavePriv, output);
        }
    }

    return Success;
}

int
ProcRRGetOutputPrimary(ClientPtr client)
{
    REQUEST(xRRGetOutputPrimaryReq);
    WindowPtr pWin;
    rrScrPrivPtr pScrPriv;
    xRRGetOutputPrimaryReply rep;
    RROutputPtr primary = NULL;
    int rc;

    REQUEST_SIZE_MATCH(xRRGetOutputPrimaryReq);

    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    pScrPriv = rrGetScrPriv(pWin->drawable.pScreen);
    if (pScrPriv)
        primary = pScrPriv->primaryOutput;

    rep = (xRRGetOutputPrimaryReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .output = primary ? primary->id : None
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.output);
    }

    WriteToClient(client, sizeof(xRRGetOutputPrimaryReply), &rep);

    return Success;
}
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d34 1
d36 1
d39 11
a49 5
    if (pScreen) {
        rrScrPriv(pScreen);
        RRSetChanged(pScreen);
        if (configChanged)
            pScrPriv->configChanged = TRUE;
d51 4
d75 2
a76 2
        outputs = realloc(pScrPriv->outputs,
                          (pScrPriv->numOutputs + 1) * sizeof(RROutputPtr));
d139 1
a139 1
        newClones = malloc(numClones * sizeof(RROutputPtr));
d172 1
a172 1
        newModes = malloc(numModes * sizeof(RRModePtr));
d215 2
a216 2
        newModes = realloc(output->userModes,
                           (output->numUserModes + 1) * sizeof(RRModePtr));
d271 1
a271 1
        newCrtcs = malloc(numCrtcs * sizeof(RRCrtcPtr));
d546 1
d569 1
d571 10
@


1.11
log
@Update to xserver 1.16.4.
Contains fix for CVE-2015-0255. ok dcoppa@@
@
text
@d490 1
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d543 5
a547 1
        if (output->pScreen != pWin->drawable.pScreen) {
@


1.9
log
@Update to xserver 1.14.5
@
text
@d100 1
a100 1
    if (!AddResource(output->id, RROutputType, (pointer) output))
d340 1
a340 1
RROutputDestroyResource(pointer value, XID pid)
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d39 1
a39 1
        pScrPriv->changed = TRUE;
d104 3
d361 2
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a307 1
    xRROutputChangeNotifyEvent oe;
d309 1
a309 1
    RRModePtr mode = crtc ? crtc->mode : 0;
d311 13
a323 18
    oe.type = RRNotify + RREventBase;
    oe.subCode = RRNotify_OutputChange;
    oe.timestamp = pScrPriv->lastSetTime.milliseconds;
    oe.configTimestamp = pScrPriv->lastConfigTime.milliseconds;
    oe.window = pWin->drawable.id;
    oe.output = output->id;
    if (crtc) {
        oe.crtc = crtc->id;
        oe.mode = mode ? mode->mode.id : None;
        oe.rotation = crtc->rotation;
    }
    else {
        oe.crtc = None;
        oe.mode = None;
        oe.rotation = RR_Rotate_0;
    }
    oe.connection = output->connection;
    oe.subpixelOrder = output->subpixelOrder;
d422 17
a438 15
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = bytes_to_int32(OutputInfoExtra);
    rep.timestamp = pScrPriv->lastSetTime.milliseconds;
    rep.crtc = output->crtc ? output->crtc->id : None;
    rep.mmWidth = output->mmWidth;
    rep.mmHeight = output->mmHeight;
    rep.connection = output->connection;
    rep.subpixelOrder = output->subpixelOrder;
    rep.nCrtcs = output->numCrtcs;
    rep.nModes = output->numModes + output->numUserModes;
    rep.nPreferred = output->numPreferred;
    rep.nClones = output->numClones;
    rep.nameLength = output->nameLength;

d488 1
a488 1
    WriteToClient(client, sizeof(xRRGetOutputInfoReply), (char *) &rep);
d490 1
a490 1
        WriteToClient(client, extraLen, (char *) extra);
d527 1
a527 1
    int rc;
d531 3
a533 3
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
d545 2
a546 1
    RRSetPrimaryOutput(pWin->drawable.pScreen, pScrPriv, output);
d571 5
a575 4
    memset(&rep, 0, sizeof(rep));
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.output = primary ? primary->id : None;
@


1.6
log
@Update to xserver 1.11.2
@
text
@d26 1
a26 1
RESTYPE	RROutputType;
d32 1
a32 1
RROutputChanged (RROutputPtr output, Bool configChanged)
d34 2
a35 2
    ScreenPtr	pScreen = output->pScreen;
    
d37 5
a41 6
    if (pScreen)
    {
	rrScrPriv (pScreen);
	pScrPriv->changed = TRUE;
	if (configChanged)
	    pScrPriv->configChanged = TRUE;
d50 6
a55 8
RROutputCreate (ScreenPtr   pScreen,
		const char  *name,
		int	    nameLength,
		void	    *devPrivate)
{
    RROutputPtr	    output;
    RROutputPtr	    *outputs;
    rrScrPrivPtr    pScrPriv;
d58 2
a59 2
	return NULL;
    
d63 2
a64 2
	outputs = realloc(pScrPriv->outputs,
			    (pScrPriv->numOutputs + 1) * sizeof (RROutputPtr));
d66 1
a66 1
	outputs = malloc(sizeof (RROutputPtr));
d68 1
a68 1
	return FALSE;
d71 2
a72 2
    
    output = malloc(sizeof (RROutputRec) + nameLength + 1);
d74 2
a75 2
	return NULL;
    output->id = FakeClientID (0);
d79 1
a79 1
    memcpy (output->name, name, nameLength);
d99 3
a101 3
    
    if (!AddResource (output->id, RROutputType, (pointer) output))
	return NULL;
d111 16
a126 20
RROutputSetClones (RROutputPtr  output,
		   RROutputPtr  *clones,
		   int		numClones)
{
    RROutputPtr	*newClones;
    int		i;

    if (numClones == output->numClones)
    {
	for (i = 0; i < numClones; i++)
	    if (output->clones[i] != clones[i])
		break;
	if (i == numClones)
	    return TRUE;
    }
    if (numClones)
    {
	newClones = malloc(numClones * sizeof (RROutputPtr));
	if (!newClones)
	    return FALSE;
d129 1
a129 1
	newClones = NULL;
d131 1
a131 1
    memcpy (newClones, clones, numClones * sizeof (RROutputPtr));
d134 1
a134 1
    RROutputChanged (output, TRUE);
d139 21
a159 26
RROutputSetModes (RROutputPtr	output,
		  RRModePtr	*modes,
		  int		numModes,
		  int		numPreferred)
{
    RRModePtr	*newModes;
    int		i;

    if (numModes == output->numModes && numPreferred == output->numPreferred)
    {
	for (i = 0; i < numModes; i++)
	    if (output->modes[i] != modes[i])
		break;
	if (i == numModes)
	{
	    for (i = 0; i < numModes; i++)
		RRModeDestroy (modes[i]);
	    return TRUE;
	}
    }

    if (numModes)
    {
	newModes = malloc(numModes * sizeof (RRModePtr));
	if (!newModes)
	    return FALSE;
d162 5
a166 6
	newModes = NULL;
    if (output->modes)
    {
	for (i = 0; i < output->numModes; i++)
	    RRModeDestroy (output->modes[i]);
	free(output->modes);
d168 1
a168 1
    memcpy (newModes, modes, numModes * sizeof (RRModePtr));
d172 1
a172 1
    RROutputChanged (output, TRUE);
d177 1
a177 2
RROutputAddUserMode (RROutputPtr    output,
		     RRModePtr	    mode)
d179 3
a181 2
    int		m;
    ScreenPtr	pScreen = output->pScreen;
d183 1
a183 1
    RRModePtr	*newModes;
d186 6
a191 7
    for (m = 0; m < output->numModes + output->numUserModes; m++)
    {
	RRModePtr   e = (m < output->numModes ?
			 output->modes[m] :
			 output->userModes[m - output->numModes]);
	if (mode == e)
	    return Success;
d196 2
a197 2
	if (!pScrPriv->rrOutputValidateMode (pScreen, output, mode))
	    return BadMatch;
d200 2
a201 2
	newModes = realloc(output->userModes,
			     (output->numUserModes + 1) * sizeof (RRModePtr));
d203 1
a203 1
	newModes = malloc(sizeof (RRModePtr));
d205 1
a205 1
	return BadAlloc;
d210 2
a211 2
    RROutputChanged (output, TRUE);
    RRTellChanged (pScreen);
d216 1
a216 2
RROutputDeleteUserMode (RROutputPtr output,
			RRModePtr   mode)
d218 2
a219 2
    int		m;
    
d221 2
a222 3
    for (m = 0; m < output->numUserModes; m++)
    {
	RRModePtr   e = output->userModes[m];
d224 2
a225 2
	if (mode == e)
	    break;
d229 1
a229 1
	return BadAccess;
d233 1
a233 1
	return BadMatch;
d235 2
a236 2
    memmove (output->userModes + m, output->userModes + m + 1,
	     (output->numUserModes - m - 1) * sizeof (RRModePtr));
d238 1
a238 1
    RRModeDestroy (mode);
d243 16
a258 20
RROutputSetCrtcs (RROutputPtr	output,
		  RRCrtcPtr	*crtcs,
		  int		numCrtcs)
{
    RRCrtcPtr	*newCrtcs;
    int		i;

    if (numCrtcs == output->numCrtcs)
    {
	for (i = 0; i < numCrtcs; i++)
	    if (output->crtcs[i] != crtcs[i])
		break;
	if (i == numCrtcs)
	    return TRUE;
    }
    if (numCrtcs)
    {
	newCrtcs = malloc(numCrtcs * sizeof (RRCrtcPtr));
	if (!newCrtcs)
	    return FALSE;
d261 1
a261 1
	newCrtcs = NULL;
d263 1
a263 1
    memcpy (newCrtcs, crtcs, numCrtcs * sizeof (RRCrtcPtr));
d266 1
a266 1
    RROutputChanged (output, TRUE);
d271 1
a271 2
RROutputSetConnection (RROutputPtr  output,
		       CARD8	    connection)
d274 1
a274 1
	return TRUE;
d276 1
a276 1
    RROutputChanged (output, TRUE);
d281 1
a281 2
RROutputSetSubpixelOrder (RROutputPtr output,
			  int	      subpixelOrder)
d284 1
a284 1
	return TRUE;
d287 1
a287 1
    RROutputChanged (output, FALSE);
d292 1
a292 3
RROutputSetPhysicalSize (RROutputPtr	output,
			 int		mmWidth,
			 int		mmHeight)
d295 1
a295 1
	return TRUE;
d298 1
a298 1
    RROutputChanged (output, FALSE);
a301 1

d306 6
a311 5
    rrScrPriv (pScreen);
    xRROutputChangeNotifyEvent	oe;
    RRCrtcPtr	crtc = output->crtc;
    RRModePtr	mode = crtc ? crtc->mode : 0;
    
d318 9
a326 11
    if (crtc)
    {
	oe.crtc = crtc->id;
	oe.mode = mode ? mode->mode.id : None;
	oe.rotation = crtc->rotation;
    }
    else
    {
	oe.crtc = None;
	oe.mode = None;
	oe.rotation = RR_Rotate_0;
d330 1
a330 1
    WriteEventsToClient (client, 1, (xEvent *) &oe);
d337 1
a337 1
RROutputDestroy (RROutputPtr output)
d339 1
a339 1
    FreeResource (output->id, 0);
d343 1
a343 1
RROutputDestroyResource (pointer value, XID pid)
d345 24
a368 28
    RROutputPtr	output = (RROutputPtr) value;
    ScreenPtr	pScreen = output->pScreen;
    int		m;

    if (pScreen)
    {
	rrScrPriv(pScreen);
	int		i;

	if (pScrPriv->primaryOutput == output)
	    pScrPriv->primaryOutput = NULL;
    
	for (i = 0; i < pScrPriv->numOutputs; i++)
	{
	    if (pScrPriv->outputs[i] == output)
	    {
		memmove (pScrPriv->outputs + i, pScrPriv->outputs + i + 1,
			 (pScrPriv->numOutputs - (i + 1)) * sizeof (RROutputPtr));
		--pScrPriv->numOutputs;
		break;
	    }
	}
    }
    if (output->modes)
    {
	for (m = 0; m < output->numModes; m++)
	    RRModeDestroy (output->modes[m]);
	free(output->modes);
d370 1
a370 1
    
d372 1
a372 1
	RRModeDestroy (output->userModes[m]);
d377 1
a377 2

    RRDeleteAllOutputProperties (output);
d386 1
a386 1
RROutputInit (void)
d388 1
a388 1
    RROutputType = CreateNewResourceType (RROutputDestroyResource, "OUTPUT");
d390 1
a390 1
	return FALSE;
d407 1
a407 1
ProcRRGetOutputInfo (ClientPtr client)
d410 12
a421 12
    xRRGetOutputInfoReply	rep;
    RROutputPtr			output;
    CARD8			*extra;
    unsigned long		extraLen;
    ScreenPtr			pScreen;
    rrScrPrivPtr		pScrPriv;
    RRCrtc			*crtcs;
    RRMode			*modes;
    RROutput			*clones;
    char			*name;
    int				i, n;
    
d442 1
a442 1
    
d444 8
a451 10
		 output->numModes + output->numUserModes +
		 output->numClones +
		 bytes_to_int32(rep.nameLength)) << 2);

    if (extraLen)
    {
	rep.length += bytes_to_int32(extraLen);
	extra = malloc(extraLen);
	if (!extra)
	    return BadAlloc;
d454 1
a454 1
	extra = NULL;
d460 18
a477 21
    
    for (i = 0; i < output->numCrtcs; i++)
    {
	crtcs[i] = output->crtcs[i]->id;
	if (client->swapped)
	    swapl (&crtcs[i], n);
    }
    for (i = 0; i < output->numModes + output->numUserModes; i++)
    {
	if (i < output->numModes)
	    modes[i] = output->modes[i]->mode.id;
	else
	    modes[i] = output->userModes[i - output->numModes]->mode.id;
	if (client->swapped)
	    swapl (&modes[i], n);
    }
    for (i = 0; i < output->numClones; i++)
    {
	clones[i] = output->clones[i]->id;
	if (client->swapped)
	    swapl (&clones[i], n);
d479 1
a479 1
    memcpy (name, output->name, output->nameLength);
d481 15
a495 16
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.timestamp, n);
	swapl(&rep.crtc, n);
	swapl(&rep.mmWidth, n);
	swapl(&rep.mmHeight, n);
	swaps(&rep.nCrtcs, n);
	swaps(&rep.nModes, n);
	swaps(&rep.nClones, n);
	swaps(&rep.nameLength, n);
    }
    WriteToClient(client, sizeof(xRRGetOutputInfoReply), (char *)&rep);
    if (extraLen)
    {
	WriteToClient (client, extraLen, (char *) extra);
	free(extra);
d497 1
a497 1
    
d502 1
a502 2
RRSetPrimaryOutput(ScreenPtr pScreen, rrScrPrivPtr pScrPriv,
		   RROutputPtr output)
d505 1
a505 1
	return;
d509 2
a510 2
	RROutputChanged(pScrPriv->primaryOutput, 0);
	pScrPriv->primaryOutput = NULL;
d515 2
a516 2
	pScrPriv->primaryOutput = output;
	RROutputChanged(output, 0);
d537 1
a537 1
	return rc;
d540 1
a540 1
	VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);
d542 4
a545 4
	if (output->pScreen != pWin->drawable.pScreen) {
	    client->errorValue = stuff->window;
	    return BadMatch;
	}
d568 1
a568 1
	return rc;
d572 1
a572 1
	primary = pScrPriv->primaryOutput;
d580 2
a581 3
	int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.output, n);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d406 1
a406 1
    free (output->clones);
d409 1
a409 1
    free (output);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d66 1
a66 1
	outputs = xrealloc (pScrPriv->outputs, 
d69 1
a69 1
	outputs = xalloc (sizeof (RROutputPtr));
d75 1
a75 1
    output = xalloc (sizeof (RROutputRec) + nameLength + 1);
d131 1
a131 1
	newClones = xalloc (numClones * sizeof (RROutputPtr));
d137 1
a137 2
    if (output->clones)
	xfree (output->clones);
d169 1
a169 1
	newModes = xalloc (numModes * sizeof (RRModePtr));
d179 1
a179 1
	xfree (output->modes);
d214 1
a214 1
	newModes = xrealloc (output->userModes,
d217 1
a217 1
	newModes = xalloc (sizeof (RRModePtr));
d276 1
a276 1
	newCrtcs = xalloc (numCrtcs * sizeof (RRCrtcPtr));
d282 1
a282 2
    if (output->crtcs)
	xfree (output->crtcs);
a337 1
    oe.sequenceNumber = client->sequence;
d398 1
a398 1
	xfree (output->modes);
d403 4
a406 2
    if (output->userModes)
	xfree (output->userModes);
a407 5
    if (output->crtcs)
	xfree (output->crtcs);
    if (output->clones)
	xfree (output->clones);
#ifdef notyet
d409 1
a409 2
#endif
    xfree (output);
d422 1
d426 9
d482 1
a482 1
	extra = xalloc (extraLen);
d532 1
a532 1
	xfree (extra);
d535 1
a535 1
    return client->noClientException;
d589 1
a589 1
    return client->noClientException;
d625 1
a625 1
    return client->noClientException;
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a24 1
#include "registry.h"
d426 1
a426 1
    RROutputType = CreateNewResourceType (RROutputDestroyResource);
a428 1
    RegisterResourceName (RROutputType, "OUTPUT");
d451 1
a451 7
    output = LookupOutput(client, stuff->output, DixReadAccess);

    if (!output)
    {
	client->errorValue = stuff->output;
	return RRErrorBase + BadRROutput;
    }
d458 1
a458 1
    rep.length = OutputInfoExtra >> 2;
d471 1
a471 1
    extraLen = ((output->numCrtcs + 
d474 1
a474 1
		 ((rep.nameLength + 3) >> 2)) << 2);
d478 1
a478 1
	rep.length += extraLen >> 2;
d535 1
a535 1
void
d566 1
d570 3
a572 7
    pWin = SecurityLookupIDByType(client, stuff->window, RT_WINDOW,
				  DixReadAccess);

    if (!pWin) {
	client->errorValue = stuff->window;
	return BadWindow;
    }
d575 1
a575 6
	output = LookupOutput(client, stuff->output, DixReadAccess);

	if (!output) {
	    client->errorValue = stuff->output;
	    return RRErrorBase + BadRROutput;
	}
d597 1
d601 3
a603 7
    pWin = SecurityLookupIDByType(client, stuff->window, RT_WINDOW,
				  DixReadAccess);

    if (!pWin) {
	client->errorValue = stuff->window;
	return BadWindow;
    }
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d3 1
d383 3
d414 1
d416 1
d435 1
a435 1
				
d540 101
@


1.1
log
@Initial revision
@
text
@d24 1
d99 1
d424 1
a424 3
#ifdef XResExtension
	RegisterResourceName (RROutputType, "OUTPUT");
#endif
@


1.1.1.1
log
@xserver 1.4
@
text
@@
