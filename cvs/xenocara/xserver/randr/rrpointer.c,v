head	1.5;
access;
symbols
	OPENBSD_6_0:1.5.0.4
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.6
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.10
	OPENBSD_5_0:1.2.0.8
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.4
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.1.0.8
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.6
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	Te1daavkBLskZ8gc;

1.4
date	2013.12.28.14.40.02;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.05.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.05.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright Â© 2006 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"
#include "inputstr.h"

/*
 * When the pointer moves, check to see if the specified position is outside
 * any of theavailable CRTCs and move it to a 'sensible' place if so, where
 * sensible is the closest monitor to the departing edge.
 *
 * Returns whether the position was adjusted
 */

static Bool
RRCrtcContainsPosition(RRCrtcPtr crtc, int x, int y)
{
    RRModePtr mode = crtc->mode;
    int scan_width, scan_height;

    if (!mode)
        return FALSE;

    RRCrtcGetScanoutSize(crtc, &scan_width, &scan_height);

    if (crtc->x <= x && x < crtc->x + scan_width &&
        crtc->y <= y && y < crtc->y + scan_height)
        return TRUE;
    return FALSE;
}

/*
 * Find the CRTC nearest the specified position, ignoring 'skip'
 */
static void
RRPointerToNearestCrtc(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y,
                       RRCrtcPtr skip)
{
    rrScrPriv(pScreen);
    int c;
    RRCrtcPtr nearest = NULL;
    int best = 0;
    int best_dx = 0, best_dy = 0;

    for (c = 0; c < pScrPriv->numCrtcs; c++) {
        RRCrtcPtr crtc = pScrPriv->crtcs[c];
        RRModePtr mode = crtc->mode;
        int dx, dy;
        int dist;
        int scan_width, scan_height;

        if (!mode)
            continue;
        if (crtc == skip)
            continue;

        RRCrtcGetScanoutSize(crtc, &scan_width, &scan_height);

        if (x < crtc->x)
            dx = crtc->x - x;
        else if (x > crtc->x + scan_width - 1)
            dx = crtc->x + (scan_width - 1) - x;
        else
            dx = 0;
        if (y < crtc->y)
            dy = crtc->y - y;
        else if (y > crtc->y + scan_height - 1)
            dy = crtc->y + (scan_height - 1) - y;
        else
            dy = 0;
        dist = dx * dx + dy * dy;
        if (!nearest || dist < best) {
            nearest = crtc;
            best_dx = dx;
            best_dy = dy;
            best = dist;
        }
    }
    if (best_dx || best_dy)
        (*pScreen->SetCursorPosition) (pDev, pScreen, x + best_dx, y + best_dy,
                                       TRUE);
    pScrPriv->pointerCrtc = nearest;
}

void
RRPointerMoved(ScreenPtr pScreen, int x, int y)
{
    rrScrPriv(pScreen);
    RRCrtcPtr pointerCrtc = pScrPriv->pointerCrtc;
    int c;

    /* Check last known CRTC */
    if (pointerCrtc && RRCrtcContainsPosition(pointerCrtc, x, y))
        return;

    /* Check all CRTCs */
    for (c = 0; c < pScrPriv->numCrtcs; c++) {
        RRCrtcPtr crtc = pScrPriv->crtcs[c];

        if (RRCrtcContainsPosition(crtc, x, y)) {
            /* Remember containing CRTC */
            pScrPriv->pointerCrtc = crtc;
            return;
        }
    }

    /* None contain pointer, find nearest */
    ErrorF("RRPointerMoved: Untested, may cause \"bogus pointer event\"\n");
    RRPointerToNearestCrtc(inputInfo.pointer, pScreen, x, y, pointerCrtc);
}

/*
 * When the screen is reconfigured, move all pointers to the nearest
 * CRTC
 */
void
RRPointerScreenConfigured(ScreenPtr pScreen)
{
    WindowPtr pRoot;
    ScreenPtr pCurrentScreen;
    int x, y;
    DeviceIntPtr pDev;

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if (IsPointerDevice(pDev)) {
            pRoot = GetCurrentRootWindow(pDev);
            pCurrentScreen = pRoot ? pRoot->drawable.pScreen : NULL;

            if (pScreen == pCurrentScreen) {
                GetSpritePosition(pDev, &x, &y);
                RRPointerToNearestCrtc(pDev, pScreen, x, y, NULL);
            }
        }
    }
}
@


1.4
log
@Update to xserver 1.14.5
@
text
@d80 2
a81 2
        else if (x > crtc->x + scan_width)
            dx = x - (crtc->x + scan_width);
d86 2
a87 2
        else if (y > crtc->y + scan_height)
            dy = y - (crtc->y + scan_height);
d90 1
a90 1
        dist = dx + dy;
d95 1
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d85 1
a85 1
            dy = crtc->y - x;
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d35 1
a35 1
RRCrtcContainsPosition (RRCrtcPtr crtc, int x, int y)
d37 2
a38 2
    RRModePtr   mode = crtc->mode;
    int		scan_width, scan_height;
d41 1
a41 1
	return FALSE;
d43 1
a43 1
    RRCrtcGetScanoutSize (crtc, &scan_width, &scan_height);
d46 2
a47 2
	crtc->y <= y && y < crtc->y + scan_height)
	return TRUE;
d55 2
a56 1
RRPointerToNearestCrtc (DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y, RRCrtcPtr skip)
d58 38
a95 40
    rrScrPriv (pScreen);
    int		c;
    RRCrtcPtr	nearest = NULL;
    int		best = 0;
    int		best_dx = 0, best_dy = 0;

    for (c = 0; c < pScrPriv->numCrtcs; c++)
    {
	RRCrtcPtr   crtc = pScrPriv->crtcs[c];
	RRModePtr   mode = crtc->mode;
	int	    dx, dy;
	int	    dist;
	int	    scan_width, scan_height;

	if (!mode)
	    continue;
	if (crtc == skip)
	    continue;

	RRCrtcGetScanoutSize (crtc, &scan_width, &scan_height);

	if (x < crtc->x)
	    dx = crtc->x - x;
	else if (x > crtc->x + scan_width)
	    dx = x - (crtc->x + scan_width);
	else
	    dx = 0;
	if (y < crtc->y)
	    dy = crtc->y - x;
	else if (y > crtc->y + scan_height)
	    dy = y - (crtc->y + scan_height);
	else
	    dy = 0;
	dist = dx + dy;
	if (!nearest || dist < best)
	{
	    nearest = crtc;
	    best_dx = dx;
	    best_dy = dy;
	}
d98 2
a99 1
	(*pScreen->SetCursorPosition) (pDev, pScreen, x + best_dx, y + best_dy, TRUE);
d104 1
a104 1
RRPointerMoved (ScreenPtr pScreen, int x, int y)
d106 3
a108 3
    rrScrPriv (pScreen);
    RRCrtcPtr	pointerCrtc = pScrPriv->pointerCrtc;
    int	c;
d111 3
a113 3
    if (pointerCrtc && RRCrtcContainsPosition (pointerCrtc, x, y))
	return;
    
d115 8
a122 10
    for (c = 0; c < pScrPriv->numCrtcs; c++)
    {
	RRCrtcPtr   crtc = pScrPriv->crtcs[c];
	
	if (RRCrtcContainsPosition (crtc, x, y))
	{
	    /* Remember containing CRTC */
	    pScrPriv->pointerCrtc = crtc;
	    return;
	}
d127 1
a127 1
    RRPointerToNearestCrtc (inputInfo.pointer, pScreen, x, y, pointerCrtc);
d135 1
a135 1
RRPointerScreenConfigured (ScreenPtr pScreen)
d137 3
a139 3
    WindowPtr	pRoot;
    ScreenPtr	pCurrentScreen;
    int		x, y;
d142 2
a143 4
    for (pDev = inputInfo.devices; pDev; pDev = pDev->next)
    {
        if (IsPointerDevice(pDev))
        {
d147 1
a147 2
            if (pScreen == pCurrentScreen)
            {
d149 1
a149 1
                RRPointerToNearestCrtc (pDev, pScreen, x, y, NULL);
@


1.1
log
@Initial revision
@
text
@d24 1
d55 1
a55 1
RRPointerToNearestCrtc (ScreenPtr pScreen, int x, int y, RRCrtcPtr skip)
d99 1
a99 1
	(*pScreen->SetCursorPosition) (pScreen, x + best_dx, y + best_dy, TRUE);
d128 2
a129 1
    RRPointerToNearestCrtc (pScreen, x, y, pointerCrtc);
d133 1
a133 1
 * When the screen is reconfigured, move the pointer to the nearest
d139 2
a140 2
    WindowPtr	pRoot = GetCurrentRootWindow ();
    ScreenPtr	pCurrentScreen = pRoot ? pRoot->drawable.pScreen : NULL;
d142 1
d144 14
a157 4
    if (pScreen != pCurrentScreen)
	return;
    GetSpritePosition (&x, &y);
    RRPointerToNearestCrtc (pScreen, x, y, NULL);
@


1.1.1.1
log
@xserver 1.4
@
text
@@
