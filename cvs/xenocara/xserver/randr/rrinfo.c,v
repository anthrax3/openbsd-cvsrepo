head	1.7;
access;
symbols
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.10
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.6
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.1.0.8
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.6
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	s0SI41sEunLdyFfd;

1.6
date	2013.12.28.14.40.02;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.05.13;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.05.13;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright Â© 2006 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"

#ifdef RANDR_10_INTERFACE
static RRModePtr
RROldModeAdd(RROutputPtr output, RRScreenSizePtr size, int refresh)
{
    ScreenPtr pScreen = output->pScreen;

    rrScrPriv(pScreen);
    xRRModeInfo modeInfo;
    char name[100];
    RRModePtr mode;
    int i;
    RRModePtr *modes;

    memset(&modeInfo, '\0', sizeof(modeInfo));
    snprintf(name, sizeof(name), "%dx%d", size->width, size->height);

    modeInfo.width = size->width;
    modeInfo.height = size->height;
    modeInfo.hTotal = size->width;
    modeInfo.vTotal = size->height;
    modeInfo.dotClock = ((CARD32) size->width * (CARD32) size->height *
                         (CARD32) refresh);
    modeInfo.nameLength = strlen(name);
    mode = RRModeGet(&modeInfo, name);
    if (!mode)
        return NULL;
    for (i = 0; i < output->numModes; i++)
        if (output->modes[i] == mode) {
            RRModeDestroy(mode);
            return mode;
        }

    if (output->numModes)
        modes = reallocarray(output->modes,
                             output->numModes + 1, sizeof(RRModePtr));
    else
        modes = malloc(sizeof(RRModePtr));
    if (!modes) {
        RRModeDestroy(mode);
        FreeResource(mode->mode.id, 0);
        return NULL;
    }
    modes[output->numModes++] = mode;
    output->modes = modes;
    output->changed = TRUE;
    pScrPriv->changed = TRUE;
    pScrPriv->configChanged = TRUE;
    return mode;
}

static void
RRScanOldConfig(ScreenPtr pScreen, Rotation rotations)
{
    rrScrPriv(pScreen);
    RROutputPtr output;
    RRCrtcPtr crtc;
    RRModePtr mode, newMode = NULL;
    int i;
    CARD16 minWidth = MAXSHORT, minHeight = MAXSHORT;
    CARD16 maxWidth = 0, maxHeight = 0;
    CARD16 width, height;

    /*
     * First time through, create a crtc and output and hook
     * them together
     */
    if (pScrPriv->numOutputs == 0 && pScrPriv->numCrtcs == 0) {
        crtc = RRCrtcCreate(pScreen, NULL);
        if (!crtc)
            return;
        output = RROutputCreate(pScreen, "default", 7, NULL);
        if (!output)
            return;
        RROutputSetCrtcs(output, &crtc, 1);
        RROutputSetConnection(output, RR_Connected);
        RROutputSetSubpixelOrder(output, PictureGetSubpixelOrder(pScreen));
    }

    output = pScrPriv->outputs[0];
    if (!output)
        return;
    crtc = pScrPriv->crtcs[0];
    if (!crtc)
        return;

    /* check rotations */
    if (rotations != crtc->rotations) {
        crtc->rotations = rotations;
        crtc->changed = TRUE;
        pScrPriv->changed = TRUE;
    }

    /* regenerate mode list */
    for (i = 0; i < pScrPriv->nSizes; i++) {
        RRScreenSizePtr size = &pScrPriv->pSizes[i];
        int r;

        if (size->nRates) {
            for (r = 0; r < size->nRates; r++) {
                mode = RROldModeAdd(output, size, size->pRates[r].rate);
                if (i == pScrPriv->size &&
                    size->pRates[r].rate == pScrPriv->rate) {
                    newMode = mode;
                }
            }
            free(size->pRates);
        }
        else {
            mode = RROldModeAdd(output, size, 0);
            if (i == pScrPriv->size)
                newMode = mode;
        }
    }
    if (pScrPriv->nSizes)
        free(pScrPriv->pSizes);
    pScrPriv->pSizes = NULL;
    pScrPriv->nSizes = 0;

    /* find size bounds */
    for (i = 0; i < output->numModes + output->numUserModes; i++) {
        mode = (i < output->numModes ?
                          output->modes[i] :
                          output->userModes[i - output->numModes]);
        width = mode->mode.width;
        height = mode->mode.height;

        if (width < minWidth)
            minWidth = width;
        if (width > maxWidth)
            maxWidth = width;
        if (height < minHeight)
            minHeight = height;
        if (height > maxHeight)
            maxHeight = height;
    }

    RRScreenSetSizeRange(pScreen, minWidth, minHeight, maxWidth, maxHeight);

    /* notice current mode */
    if (newMode)
        RRCrtcNotify(crtc, newMode, 0, 0, pScrPriv->rotation, NULL, 1, &output);
}
#endif

/*
 * Poll the driver for changed information
 */
Bool
RRGetInfo(ScreenPtr pScreen, Bool force_query)
{
    rrScrPriv(pScreen);
    Rotation rotations;
    int i;

    /* Return immediately if we don't need to re-query and we already have the
     * information.
     */
    if (!force_query) {
        if (pScrPriv->numCrtcs != 0 || pScrPriv->numOutputs != 0)
            return TRUE;
    }

    for (i = 0; i < pScrPriv->numOutputs; i++)
        pScrPriv->outputs[i]->changed = FALSE;
    for (i = 0; i < pScrPriv->numCrtcs; i++)
        pScrPriv->crtcs[i]->changed = FALSE;

    rotations = 0;
    pScrPriv->changed = FALSE;
    pScrPriv->configChanged = FALSE;

    if (!(*pScrPriv->rrGetInfo) (pScreen, &rotations))
        return FALSE;

#if RANDR_10_INTERFACE
    if (pScrPriv->nSizes)
        RRScanOldConfig(pScreen, rotations);
#endif
    RRTellChanged(pScreen);
    return TRUE;
}

/*
 * Register the range of sizes for the screen
 */
void
RRScreenSetSizeRange(ScreenPtr pScreen,
                     CARD16 minWidth,
                     CARD16 minHeight, CARD16 maxWidth, CARD16 maxHeight)
{
    rrScrPriv(pScreen);

    if (!pScrPriv)
        return;
    if (pScrPriv->minWidth == minWidth && pScrPriv->minHeight == minHeight &&
        pScrPriv->maxWidth == maxWidth && pScrPriv->maxHeight == maxHeight) {
        return;
    }

    pScrPriv->minWidth = minWidth;
    pScrPriv->minHeight = minHeight;
    pScrPriv->maxWidth = maxWidth;
    pScrPriv->maxHeight = maxHeight;
    RRSetChanged(pScreen);
    pScrPriv->configChanged = TRUE;
}

#ifdef RANDR_10_INTERFACE
static Bool
RRScreenSizeMatches(RRScreenSizePtr a, RRScreenSizePtr b)
{
    if (a->width != b->width)
        return FALSE;
    if (a->height != b->height)
        return FALSE;
    if (a->mmWidth != b->mmWidth)
        return FALSE;
    if (a->mmHeight != b->mmHeight)
        return FALSE;
    return TRUE;
}

RRScreenSizePtr
RRRegisterSize(ScreenPtr pScreen,
               short width, short height, short mmWidth, short mmHeight)
{
    rrScrPriv(pScreen);
    int i;
    RRScreenSize tmp;
    RRScreenSizePtr pNew;

    if (!pScrPriv)
        return 0;

    tmp.id = 0;
    tmp.width = width;
    tmp.height = height;
    tmp.mmWidth = mmWidth;
    tmp.mmHeight = mmHeight;
    tmp.pRates = 0;
    tmp.nRates = 0;
    for (i = 0; i < pScrPriv->nSizes; i++)
        if (RRScreenSizeMatches(&tmp, &pScrPriv->pSizes[i]))
            return &pScrPriv->pSizes[i];
    pNew = reallocarray(pScrPriv->pSizes,
                        pScrPriv->nSizes + 1, sizeof(RRScreenSize));
    if (!pNew)
        return 0;
    pNew[pScrPriv->nSizes++] = tmp;
    pScrPriv->pSizes = pNew;
    return &pNew[pScrPriv->nSizes - 1];
}

Bool
RRRegisterRate(ScreenPtr pScreen, RRScreenSizePtr pSize, int rate)
{
    rrScrPriv(pScreen);
    int i;
    RRScreenRatePtr pNew, pRate;

    if (!pScrPriv)
        return FALSE;

    for (i = 0; i < pSize->nRates; i++)
        if (pSize->pRates[i].rate == rate)
            return TRUE;

    pNew = reallocarray(pSize->pRates, pSize->nRates + 1, sizeof(RRScreenRate));
    if (!pNew)
        return FALSE;
    pRate = &pNew[pSize->nRates++];
    pRate->rate = rate;
    pSize->pRates = pNew;
    return TRUE;
}

Rotation
RRGetRotation(ScreenPtr pScreen)
{
    RROutputPtr output = RRFirstOutput(pScreen);

    if (!output)
        return RR_Rotate_0;

    return output->crtc->rotation;
}

void
RRSetCurrentConfig(ScreenPtr pScreen,
                   Rotation rotation, int rate, RRScreenSizePtr pSize)
{
    rrScrPriv(pScreen);

    if (!pScrPriv)
        return;
    pScrPriv->size = pSize - pScrPriv->pSizes;
    pScrPriv->rotation = rotation;
    pScrPriv->rate = rate;
}
#endif
@


1.6
log
@Update to xserver 1.14.5
@
text
@d58 2
a59 2
        modes = realloc(output->modes,
                        (output->numModes + 1) * sizeof(RRModePtr));
d269 2
a270 2
    pNew = realloc(pScrPriv->pSizes,
                   (pScrPriv->nSizes + 1) * sizeof(RRScreenSize));
d292 1
a292 1
    pNew = realloc(pSize->pRates, (pSize->nRates + 1) * sizeof(RRScreenRate));
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d228 1
a228 1
    pScrPriv->changed = TRUE;
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d85 1
d145 1
a145 1
        RRModePtr mode = (i < output->numModes ?
d148 2
a149 2
        CARD16 width = mode->mode.width;
        CARD16 height = mode->mode.height;
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d27 1
a27 1
RROldModeAdd (RROutputPtr output, RRScreenSizePtr size, int refresh)
d29 2
a30 1
    ScreenPtr	pScreen = output->pScreen;
d32 9
a40 9
    xRRModeInfo	modeInfo;
    char	name[100];
    RRModePtr	mode;
    int		i;
    RRModePtr   *modes;
    
    memset (&modeInfo, '\0', sizeof (modeInfo));
    snprintf (name, sizeof(name), "%dx%d", size->width, size->height);
    
d46 3
a48 3
			 (CARD32) refresh);
    modeInfo.nameLength = strlen (name);
    mode = RRModeGet (&modeInfo, name);
d50 1
a50 1
	return NULL;
d52 5
a56 6
	if (output->modes[i] == mode)
	{
	    RRModeDestroy (mode);
	    return mode;
	}
    
d58 2
a59 2
	modes = realloc(output->modes,
			  (output->numModes + 1) * sizeof (RRModePtr));
d61 5
a65 6
	modes = malloc(sizeof (RRModePtr));
    if (!modes)
    {
	RRModeDestroy (mode);
	FreeResource (mode->mode.id, 0);
	return NULL;
d76 1
a76 1
RRScanOldConfig (ScreenPtr pScreen, Rotation rotations)
d79 7
a85 7
    RROutputPtr	output;
    RRCrtcPtr	crtc;
    RRModePtr	mode, newMode = NULL;
    int		i;
    CARD16	minWidth = MAXSHORT, minHeight = MAXSHORT;
    CARD16	maxWidth = 0, maxHeight = 0;
    
d90 10
a99 12
    if (pScrPriv->numOutputs == 0 &&
	pScrPriv->numCrtcs == 0)
    {
	crtc = RRCrtcCreate (pScreen, NULL);
	if (!crtc)
	    return;
	output = RROutputCreate (pScreen, "default", 7, NULL);
	if (!output)
	    return;
	RROutputSetCrtcs (output, &crtc, 1);
	RROutputSetConnection (output, RR_Connected);
	RROutputSetSubpixelOrder (output, PictureGetSubpixelOrder (pScreen));
d104 1
a104 1
	return;
d107 1
a107 1
	return;
d110 1
a110 2
    if (rotations != crtc->rotations)
    {
d112 2
a113 2
	crtc->changed = TRUE;
	pScrPriv->changed = TRUE;
d115 1
a115 1
	
d117 19
a135 24
    for (i = 0; i < pScrPriv->nSizes; i++)
    {
	RRScreenSizePtr	size = &pScrPriv->pSizes[i];
	int		r;

	if (size->nRates)
	{
	    for (r = 0; r < size->nRates; r++)
	    {
		mode = RROldModeAdd (output, size, size->pRates[r].rate);
		if (i == pScrPriv->size && 
		    size->pRates[r].rate == pScrPriv->rate)
		{
		    newMode = mode;
		}
	    }
	    free(size->pRates);
	}
	else
	{
	    mode = RROldModeAdd (output, size, 0);
	    if (i == pScrPriv->size)
		newMode = mode;
	}
d138 1
a138 1
	free(pScrPriv->pSizes);
d141 1
a141 1
	    
d143 15
a157 12
    for (i = 0; i < output->numModes + output->numUserModes; i++) 
    {
	RRModePtr   mode = (i < output->numModes ? 
			    output->modes[i] : 
			    output->userModes[i-output->numModes]);
        CARD16	    width = mode->mode.width;
        CARD16	    height = mode->mode.height;
	
	if (width < minWidth) minWidth = width;
	if (width > maxWidth) maxWidth = width;
	if (height < minHeight) minHeight = height;
	if (height > maxHeight) maxHeight = height;
d160 1
a160 1
    RRScreenSetSizeRange (pScreen, minWidth, minHeight, maxWidth, maxHeight);
d164 1
a164 2
	RRCrtcNotify (crtc, newMode, 0, 0, pScrPriv->rotation,
		      NULL, 1, &output);
d172 1
a172 1
RRGetInfo (ScreenPtr pScreen, Bool force_query)
d174 3
a176 3
    rrScrPriv (pScreen);
    Rotation	    rotations;
    int		    i;
d182 2
a183 2
	if (pScrPriv->numCrtcs != 0 || pScrPriv->numOutputs != 0)
	    return TRUE;
d187 1
a187 1
	pScrPriv->outputs[i]->changed = FALSE;
d189 2
a190 2
	pScrPriv->crtcs[i]->changed = FALSE;
    
d194 1
a194 1
    
d196 1
a196 1
	return FALSE;
d200 1
a200 1
	RRScanOldConfig (pScreen, rotations);
d202 1
a202 1
    RRTellChanged (pScreen);
d210 3
a212 5
RRScreenSetSizeRange (ScreenPtr	pScreen,
		      CARD16	minWidth,
		      CARD16	minHeight,
		      CARD16	maxWidth,
		      CARD16	maxHeight)
d214 1
a214 1
    rrScrPriv (pScreen);
d217 1
a217 1
	return;
d219 2
a220 3
	pScrPriv->maxWidth == maxWidth && pScrPriv->maxHeight == maxHeight)
    {
	return;
d222 2
a223 2
	
    pScrPriv->minWidth  = minWidth;
d225 1
a225 1
    pScrPriv->maxWidth  = maxWidth;
d233 1
a233 2
RRScreenSizeMatches (RRScreenSizePtr  a,
		   RRScreenSizePtr  b)
d236 1
a236 1
	return FALSE;
d238 1
a238 1
	return FALSE;
d240 1
a240 1
	return FALSE;
d242 1
a242 1
	return FALSE;
d247 2
a248 5
RRRegisterSize (ScreenPtr	    pScreen,
		short		    width, 
		short		    height,
		short		    mmWidth,
		short		    mmHeight)
d250 3
a252 3
    rrScrPriv (pScreen);
    int		    i;
    RRScreenSize    tmp;
d256 2
a257 2
	return 0;
    
d260 1
a260 1
    tmp.height= height;
d266 2
a267 2
	if (RRScreenSizeMatches (&tmp, &pScrPriv->pSizes[i]))
	    return &pScrPriv->pSizes[i];
d269 1
a269 1
		     (pScrPriv->nSizes + 1) * sizeof (RRScreenSize));
d271 1
a271 1
	return 0;
d274 1
a274 1
    return &pNew[pScrPriv->nSizes-1];
d277 2
a278 3
Bool RRRegisterRate (ScreenPtr		pScreen,
		     RRScreenSizePtr	pSize,
		     int		rate)
d281 1
a281 1
    int		    i;
d285 2
a286 2
	return FALSE;
    
d288 2
a289 2
	if (pSize->pRates[i].rate == rate)
	    return TRUE;
d291 1
a291 2
    pNew = realloc(pSize->pRates,
		     (pSize->nRates + 1) * sizeof (RRScreenRate));
d293 1
a293 1
	return FALSE;
d303 1
a303 1
    RROutputPtr	output = RRFirstOutput (pScreen);
d306 1
a306 1
	return RR_Rotate_0;
d312 2
a313 4
RRSetCurrentConfig (ScreenPtr		pScreen,
		    Rotation		rotation,
		    int			rate,
		    RRScreenSizePtr	pSize)
d315 1
a315 1
    rrScrPriv (pScreen);
d318 1
a318 1
	return;
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d58 1
a58 1
	modes = xrealloc (output->modes, 
d61 1
a61 1
	modes = xalloc (sizeof (RRModePtr));
a101 1
#ifdef RENDER
a102 1
#endif
d137 1
a137 1
	    xfree (size->pRates);
d147 1
a147 1
	xfree (pScrPriv->pSizes);
d282 1
a282 1
    pNew = xrealloc (pScrPriv->pSizes,
d306 1
a306 1
    pNew = xrealloc (pSize->pRates,
@


1.1
log
@Initial revision
@
text
@d38 1
a38 1
    sprintf (name, "%dx%d", size->width, size->height);
d173 1
a173 1
		      1, &output);
d181 1
a181 1
RRGetInfo (ScreenPtr pScreen)
d186 8
@


1.1.1.1
log
@xserver 1.4
@
text
@@
