head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	s0SI41sEunLdyFfd;

1.12
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2015.02.11.20.58.47;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	dgcmwPGRv39E4MF9;

1.10
date	2013.12.28.14.40.02;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.04.02.16.08.40;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.05.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.05.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright Â© 2006 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"

static CARD16
 RR10CurrentSizeID(ScreenPtr pScreen);

/*
 * Edit connection information block so that new clients
 * see the current screen size on connect
 */
static void
RREditConnectionInfo(ScreenPtr pScreen)
{
    xConnSetup *connSetup;
    char *vendor;
    xPixmapFormat *formats;
    xWindowRoot *root;
    xDepth *depth;
    xVisualType *visual;
    int screen = 0;
    int d;

    connSetup = (xConnSetup *) ConnectionInfo;
    vendor = (char *) connSetup + sizeof(xConnSetup);
    formats = (xPixmapFormat *) ((char *) vendor +
                                 pad_to_int32(connSetup->nbytesVendor));
    root = (xWindowRoot *) ((char *) formats +
                            sizeof(xPixmapFormat) *
                            screenInfo.numPixmapFormats);
    while (screen != pScreen->myNum) {
        depth = (xDepth *) ((char *) root + sizeof(xWindowRoot));
        for (d = 0; d < root->nDepths; d++) {
            visual = (xVisualType *) ((char *) depth + sizeof(xDepth));
            depth = (xDepth *) ((char *) visual +
                                depth->nVisuals * sizeof(xVisualType));
        }
        root = (xWindowRoot *) ((char *) depth);
        screen++;
    }
    root->pixWidth = pScreen->width;
    root->pixHeight = pScreen->height;
    root->mmWidth = pScreen->mmWidth;
    root->mmHeight = pScreen->mmHeight;
}

void
RRSendConfigNotify(ScreenPtr pScreen)
{
    WindowPtr pWin = pScreen->root;
    xEvent event = {
        .u.configureNotify.window = pWin->drawable.id,
        .u.configureNotify.aboveSibling = None,
        .u.configureNotify.x = 0,
        .u.configureNotify.y = 0,

    /* XXX xinerama stuff ? */

        .u.configureNotify.width = pWin->drawable.width,
        .u.configureNotify.height = pWin->drawable.height,
        .u.configureNotify.borderWidth = wBorderWidth(pWin),
        .u.configureNotify.override = pWin->overrideRedirect
    };
    event.u.u.type = ConfigureNotify;
    DeliverEvents(pWin, &event, 1, NullWindow);
}

void
RRDeliverScreenEvent(ClientPtr client, WindowPtr pWin, ScreenPtr pScreen)
{
    rrScrPriv(pScreen);
    RRCrtcPtr crtc = pScrPriv->numCrtcs ? pScrPriv->crtcs[0] : NULL;
    WindowPtr pRoot = pScreen->root;

    xRRScreenChangeNotifyEvent se = {
        .type = RRScreenChangeNotify + RREventBase,
        .rotation = (CARD8) (crtc ? crtc->rotation : RR_Rotate_0),
        .timestamp = pScrPriv->lastSetTime.milliseconds,
        .configTimestamp = pScrPriv->lastConfigTime.milliseconds,
        .root = pRoot->drawable.id,
        .window = pWin->drawable.id,
        .subpixelOrder = PictureGetSubpixelOrder(pScreen),

        .sizeID = RR10CurrentSizeID(pScreen)
    };

    if (se.rotation & (RR_Rotate_90 | RR_Rotate_270)) {
        se.widthInPixels = pScreen->height;
        se.heightInPixels = pScreen->width;
        se.widthInMillimeters = pScreen->mmHeight;
        se.heightInMillimeters = pScreen->mmWidth;
    }
    else {
        se.widthInPixels = pScreen->width;
        se.heightInPixels = pScreen->height;
        se.widthInMillimeters = pScreen->mmWidth;
        se.heightInMillimeters = pScreen->mmHeight;
    }

    WriteEventsToClient(client, 1, (xEvent *) &se);
}

/*
 * Notify the extension that the screen size has been changed.
 * The driver is responsible for calling this whenever it has changed
 * the size of the screen
 */
void
RRScreenSizeNotify(ScreenPtr pScreen)
{
    rrScrPriv(pScreen);
    /*
     * Deliver ConfigureNotify events when root changes
     * pixel size
     */
    if (pScrPriv->width == pScreen->width &&
        pScrPriv->height == pScreen->height &&
        pScrPriv->mmWidth == pScreen->mmWidth &&
        pScrPriv->mmHeight == pScreen->mmHeight)
        return;

    pScrPriv->width = pScreen->width;
    pScrPriv->height = pScreen->height;
    pScrPriv->mmWidth = pScreen->mmWidth;
    pScrPriv->mmHeight = pScreen->mmHeight;
    RRSetChanged(pScreen);
/*    pScrPriv->sizeChanged = TRUE; */

    RRTellChanged(pScreen);
    RRSendConfigNotify(pScreen);
    RREditConnectionInfo(pScreen);

    RRPointerScreenConfigured(pScreen);
    /*
     * Fix pointer bounds and location
     */
    ScreenRestructured(pScreen);
}

/*
 * Request that the screen be resized
 */
Bool
RRScreenSizeSet(ScreenPtr pScreen,
                CARD16 width, CARD16 height, CARD32 mmWidth, CARD32 mmHeight)
{
    rrScrPriv(pScreen);

#if RANDR_12_INTERFACE
    if (pScrPriv->rrScreenSetSize) {
        return (*pScrPriv->rrScreenSetSize) (pScreen,
                                             width, height, mmWidth, mmHeight);
    }
#endif
#if RANDR_10_INTERFACE
    if (pScrPriv->rrSetConfig) {
        return TRUE;            /* can't set size separately */
    }
#endif
    return FALSE;
}

/*
 * Retrieve valid screen size range
 */
int
ProcRRGetScreenSizeRange(ClientPtr client)
{
    REQUEST(xRRGetScreenSizeRangeReq);
    xRRGetScreenSizeRangeReply rep;
    WindowPtr pWin;
    ScreenPtr pScreen;
    rrScrPrivPtr pScrPriv;
    int rc;

    REQUEST_SIZE_MATCH(xRRGetScreenSizeRangeReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    pScreen = pWin->drawable.pScreen;
    pScrPriv = rrGetScrPriv(pScreen);

    rep = (xRRGetScreenSizeRangeReply) {
        .type = X_Reply,
        .pad = 0,
        .sequenceNumber = client->sequence,
        .length = 0
    };

    if (pScrPriv) {
        if (!RRGetInfo(pScreen, FALSE))
            return BadAlloc;
        rep.minWidth = pScrPriv->minWidth;
        rep.minHeight = pScrPriv->minHeight;
        rep.maxWidth = pScrPriv->maxWidth;
        rep.maxHeight = pScrPriv->maxHeight;
    }
    else {
        rep.maxWidth = rep.minWidth = pScreen->width;
        rep.maxHeight = rep.minHeight = pScreen->height;
    }
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.minWidth);
        swaps(&rep.minHeight);
        swaps(&rep.maxWidth);
        swaps(&rep.maxHeight);
    }
    WriteToClient(client, sizeof(xRRGetScreenSizeRangeReply), &rep);
    return Success;
}

int
ProcRRSetScreenSize(ClientPtr client)
{
    REQUEST(xRRSetScreenSizeReq);
    WindowPtr pWin;
    ScreenPtr pScreen;
    rrScrPrivPtr pScrPriv;
    int i, rc;

    REQUEST_SIZE_MATCH(xRRSetScreenSizeReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    pScreen = pWin->drawable.pScreen;
    pScrPriv = rrGetScrPriv(pScreen);
    if (!pScrPriv)
        return BadMatch;

    if (stuff->width < pScrPriv->minWidth || pScrPriv->maxWidth < stuff->width) {
        client->errorValue = stuff->width;
        return BadValue;
    }
    if (stuff->height < pScrPriv->minHeight ||
        pScrPriv->maxHeight < stuff->height) {
        client->errorValue = stuff->height;
        return BadValue;
    }
    for (i = 0; i < pScrPriv->numCrtcs; i++) {
        RRCrtcPtr crtc = pScrPriv->crtcs[i];
        RRModePtr mode = crtc->mode;

        if (mode) {
            int source_width = mode->mode.width;
            int source_height = mode->mode.height;
            Rotation rotation = crtc->rotation;

            if (rotation == RR_Rotate_90 || rotation == RR_Rotate_270) {
                source_width = mode->mode.height;
                source_height = mode->mode.width;
            }

            if (crtc->x + source_width > stuff->width ||
                crtc->y + source_height > stuff->height)
                return BadMatch;
        }
    }
    if (stuff->widthInMillimeters == 0 || stuff->heightInMillimeters == 0) {
        client->errorValue = 0;
        return BadValue;
    }
    if (!RRScreenSizeSet(pScreen,
                         stuff->width, stuff->height,
                         stuff->widthInMillimeters,
                         stuff->heightInMillimeters)) {
        return BadMatch;
    }
    return Success;
}


#define update_totals(gpuscreen, pScrPriv) do {       \
    total_crtcs += pScrPriv->numCrtcs;                \
    total_outputs += pScrPriv->numOutputs;            \
    modes = RRModesForScreen(gpuscreen, &num_modes);  \
    if (!modes)                                       \
        return BadAlloc;                              \
    for (j = 0; j < num_modes; j++)                   \
        total_name_len += modes[j]->mode.nameLength;  \
    total_modes += num_modes;                         \
    free(modes);                                      \
} while(0)

static inline void swap_modeinfos(xRRModeInfo *modeinfos, int i)
{
    swapl(&modeinfos[i].id);
    swaps(&modeinfos[i].width);
    swaps(&modeinfos[i].height);
    swapl(&modeinfos[i].dotClock);
    swaps(&modeinfos[i].hSyncStart);
    swaps(&modeinfos[i].hSyncEnd);
    swaps(&modeinfos[i].hTotal);
    swaps(&modeinfos[i].hSkew);
    swaps(&modeinfos[i].vSyncStart);
    swaps(&modeinfos[i].vSyncEnd);
    swaps(&modeinfos[i].vTotal);
    swaps(&modeinfos[i].nameLength);
    swapl(&modeinfos[i].modeFlags);
}

#define update_arrays(gpuscreen, pScrPriv, primary_crtc, has_primary) do {            \
    for (j = 0; j < pScrPriv->numCrtcs; j++) {             \
        if (has_primary && \
            primary_crtc == pScrPriv->crtcs[j]) { \
            has_primary = 0;   \
            continue; \
        }\
        crtcs[crtc_count] = pScrPriv->crtcs[j]->id;        \
        if (client->swapped)                               \
            swapl(&crtcs[crtc_count]);                     \
        crtc_count++;                                      \
    }                                                      \
    for (j = 0; j < pScrPriv->numOutputs; j++) {           \
        outputs[output_count] = pScrPriv->outputs[j]->id;  \
        if (client->swapped)                               \
            swapl(&outputs[output_count]);                 \
        output_count++;                                    \
    }                                                      \
    {                                                      \
        RRModePtr mode;                                    \
        modes = RRModesForScreen(gpuscreen, &num_modes);   \
        for (j = 0; j < num_modes; j++) {                  \
            mode = modes[j];                               \
            modeinfos[mode_count] = mode->mode;            \
            if (client->swapped) {                         \
                swap_modeinfos(modeinfos, mode_count);     \
            }                                              \
            memcpy(names, mode->name, mode->mode.nameLength); \
            names += mode->mode.nameLength;                \
            mode_count++;                                  \
        }                                                  \
        free(modes);                                       \
    }                                                      \
    } while (0)

static int
rrGetMultiScreenResources(ClientPtr client, Bool query, ScreenPtr pScreen)
{
    int j;
    int total_crtcs, total_outputs, total_modes, total_name_len;
    int crtc_count, output_count, mode_count;
    ScreenPtr iter;
    rrScrPrivPtr pScrPriv;
    int num_modes;
    RRModePtr *modes;
    xRRGetScreenResourcesReply rep;
    unsigned long extraLen;
    CARD8 *extra;
    RRCrtc *crtcs;
    RRCrtcPtr primary_crtc = NULL;
    RROutput *outputs;
    xRRModeInfo *modeinfos;
    CARD8 *names;
    int has_primary = 0;

    /* we need to iterate all the GPU masters and all their output slaves */
    total_crtcs = 0;
    total_outputs = 0;
    total_modes = 0;
    total_name_len = 0;

    pScrPriv = rrGetScrPriv(pScreen);

    if (query && pScrPriv)
        if (!RRGetInfo(pScreen, query))
            return BadAlloc;

    update_totals(pScreen, pScrPriv);

    xorg_list_for_each_entry(iter, &pScreen->output_slave_list, output_head) {
        pScrPriv = rrGetScrPriv(iter);

        if (query)
          if (!RRGetInfo(iter, query))
            return BadAlloc;
        update_totals(iter, pScrPriv);
    }

    pScrPriv = rrGetScrPriv(pScreen);
    rep = (xRRGetScreenResourcesReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .timestamp = pScrPriv->lastSetTime.milliseconds,
        .configTimestamp = pScrPriv->lastConfigTime.milliseconds,
        .nCrtcs = total_crtcs,
        .nOutputs = total_outputs,
        .nModes = total_modes,
        .nbytesNames = total_name_len
    };

    rep.length = (total_crtcs + total_outputs +
                  total_modes * bytes_to_int32(SIZEOF(xRRModeInfo)) +
                  bytes_to_int32(total_name_len));

    extraLen = rep.length << 2;
    if (extraLen) {
        extra = malloc(extraLen);
        if (!extra) {
            return BadAlloc;
        }
    }
    else
        extra = NULL;

    crtcs = (RRCrtc *)extra;
    outputs = (RROutput *)(crtcs + total_crtcs);
    modeinfos = (xRRModeInfo *)(outputs + total_outputs);
    names = (CARD8 *)(modeinfos + total_modes);

    crtc_count = 0;
    output_count = 0;
    mode_count = 0;

    pScrPriv = rrGetScrPriv(pScreen);
    if (pScrPriv->primaryOutput && pScrPriv->primaryOutput->crtc) {
        has_primary = 1;
        primary_crtc = pScrPriv->primaryOutput->crtc;
        crtcs[0] = pScrPriv->primaryOutput->crtc->id;
        if (client->swapped)
            swapl(&crtcs[0]);
        crtc_count = 1;
    }
    update_arrays(pScreen, pScrPriv, primary_crtc, has_primary);

    xorg_list_for_each_entry(iter, &pScreen->output_slave_list, output_head) {
        pScrPriv = rrGetScrPriv(iter);

        update_arrays(iter, pScrPriv, primary_crtc, has_primary);
    }

    assert(bytes_to_int32((char *) names - (char *) extra) == rep.length);
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.timestamp);
        swapl(&rep.configTimestamp);
        swaps(&rep.nCrtcs);
        swaps(&rep.nOutputs);
        swaps(&rep.nModes);
        swaps(&rep.nbytesNames);
    }
    WriteToClient(client, sizeof(xRRGetScreenResourcesReply), &rep);
    if (extraLen) {
        WriteToClient(client, extraLen, extra);
        free(extra);
    }
    return Success;
}

static int
rrGetScreenResources(ClientPtr client, Bool query)
{
    REQUEST(xRRGetScreenResourcesReq);
    xRRGetScreenResourcesReply rep;
    WindowPtr pWin;
    ScreenPtr pScreen;
    rrScrPrivPtr pScrPriv;
    CARD8 *extra;
    unsigned long extraLen;
    int i, rc, has_primary = 0;
    RRCrtc *crtcs;
    RROutput *outputs;
    xRRModeInfo *modeinfos;
    CARD8 *names;

    REQUEST_SIZE_MATCH(xRRGetScreenResourcesReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    pScreen = pWin->drawable.pScreen;
    pScrPriv = rrGetScrPriv(pScreen);

    if (query && pScrPriv)
        if (!RRGetInfo(pScreen, query))
            return BadAlloc;

    if (!xorg_list_is_empty(&pScreen->output_slave_list))
        return rrGetMultiScreenResources(client, query, pScreen);

    if (!pScrPriv) {
        rep = (xRRGetScreenResourcesReply) {
            .type = X_Reply,
            .sequenceNumber = client->sequence,
            .length = 0,
            .timestamp = currentTime.milliseconds,
            .configTimestamp = currentTime.milliseconds,
            .nCrtcs = 0,
            .nOutputs = 0,
            .nModes = 0,
            .nbytesNames = 0
        };
        extra = NULL;
        extraLen = 0;
    }
    else {
        RRModePtr *modes;
        int num_modes;

        modes = RRModesForScreen(pScreen, &num_modes);
        if (!modes)
            return BadAlloc;

        rep = (xRRGetScreenResourcesReply) {
            .type = X_Reply,
            .sequenceNumber = client->sequence,
            .length = 0,
            .timestamp = pScrPriv->lastSetTime.milliseconds,
            .configTimestamp = pScrPriv->lastConfigTime.milliseconds,
            .nCrtcs = pScrPriv->numCrtcs,
            .nOutputs = pScrPriv->numOutputs,
            .nModes = num_modes,
            .nbytesNames = 0
        };


        for (i = 0; i < num_modes; i++)
            rep.nbytesNames += modes[i]->mode.nameLength;

        rep.length = (pScrPriv->numCrtcs +
                      pScrPriv->numOutputs +
                      num_modes * bytes_to_int32(SIZEOF(xRRModeInfo)) +
                      bytes_to_int32(rep.nbytesNames));

        extraLen = rep.length << 2;
        if (extraLen) {
            extra = malloc(extraLen);
            if (!extra) {
                free(modes);
                return BadAlloc;
            }
        }
        else
            extra = NULL;

        crtcs = (RRCrtc *) extra;
        outputs = (RROutput *) (crtcs + pScrPriv->numCrtcs);
        modeinfos = (xRRModeInfo *) (outputs + pScrPriv->numOutputs);
        names = (CARD8 *) (modeinfos + num_modes);

        if (pScrPriv->primaryOutput && pScrPriv->primaryOutput->crtc) {
            has_primary = 1;
            crtcs[0] = pScrPriv->primaryOutput->crtc->id;
            if (client->swapped)
                swapl(&crtcs[0]);
        }

        for (i = 0; i < pScrPriv->numCrtcs; i++) {
            if (has_primary &&
                pScrPriv->primaryOutput->crtc == pScrPriv->crtcs[i]) {
                has_primary = 0;
                continue;
            }
            crtcs[i + has_primary] = pScrPriv->crtcs[i]->id;
            if (client->swapped)
                swapl(&crtcs[i + has_primary]);
        }

        for (i = 0; i < pScrPriv->numOutputs; i++) {
            outputs[i] = pScrPriv->outputs[i]->id;
            if (client->swapped)
                swapl(&outputs[i]);
        }

        for (i = 0; i < num_modes; i++) {
            RRModePtr mode = modes[i];

            modeinfos[i] = mode->mode;
            if (client->swapped) {
                swapl(&modeinfos[i].id);
                swaps(&modeinfos[i].width);
                swaps(&modeinfos[i].height);
                swapl(&modeinfos[i].dotClock);
                swaps(&modeinfos[i].hSyncStart);
                swaps(&modeinfos[i].hSyncEnd);
                swaps(&modeinfos[i].hTotal);
                swaps(&modeinfos[i].hSkew);
                swaps(&modeinfos[i].vSyncStart);
                swaps(&modeinfos[i].vSyncEnd);
                swaps(&modeinfos[i].vTotal);
                swaps(&modeinfos[i].nameLength);
                swapl(&modeinfos[i].modeFlags);
            }
            memcpy(names, mode->name, mode->mode.nameLength);
            names += mode->mode.nameLength;
        }
        free(modes);
        assert(bytes_to_int32((char *) names - (char *) extra) == rep.length);
    }

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.timestamp);
        swapl(&rep.configTimestamp);
        swaps(&rep.nCrtcs);
        swaps(&rep.nOutputs);
        swaps(&rep.nModes);
        swaps(&rep.nbytesNames);
    }
    WriteToClient(client, sizeof(xRRGetScreenResourcesReply), (char *) &rep);
    if (extraLen) {
        WriteToClient(client, extraLen, (char *) extra);
        free(extra);
    }
    return Success;
}

int
ProcRRGetScreenResources(ClientPtr client)
{
    return rrGetScreenResources(client, TRUE);
}

int
ProcRRGetScreenResourcesCurrent(ClientPtr client)
{
    return rrGetScreenResources(client, FALSE);
}

typedef struct _RR10Data {
    RRScreenSizePtr sizes;
    int nsize;
    int nrefresh;
    int size;
    CARD16 refresh;
} RR10DataRec, *RR10DataPtr;

/*
 * Convert 1.2 monitor data into 1.0 screen data
 */
static RR10DataPtr
RR10GetData(ScreenPtr pScreen, RROutputPtr output)
{
    RR10DataPtr data;
    RRScreenSizePtr size;
    int nmode = output->numModes + output->numUserModes;
    int o, os, l, r;
    RRScreenRatePtr refresh;
    CARD16 vRefresh;
    RRModePtr mode;
    Bool *used;

    /* Make sure there is plenty of space for any combination */
    data = malloc(sizeof(RR10DataRec) +
                  sizeof(RRScreenSize) * nmode +
                  sizeof(RRScreenRate) * nmode + sizeof(Bool) * nmode);
    if (!data)
        return NULL;
    size = (RRScreenSizePtr) (data + 1);
    refresh = (RRScreenRatePtr) (size + nmode);
    used = (Bool *) (refresh + nmode);
    memset(used, '\0', sizeof(Bool) * nmode);
    data->sizes = size;
    data->nsize = 0;
    data->nrefresh = 0;
    data->size = 0;
    data->refresh = 0;

    /*
     * find modes not yet listed
     */
    for (o = 0; o < output->numModes + output->numUserModes; o++) {
        if (used[o])
            continue;

        if (o < output->numModes)
            mode = output->modes[o];
        else
            mode = output->userModes[o - output->numModes];

        l = data->nsize;
        size[l].id = data->nsize;
        size[l].width = mode->mode.width;
        size[l].height = mode->mode.height;
        if (output->mmWidth && output->mmHeight) {
            size[l].mmWidth = output->mmWidth;
            size[l].mmHeight = output->mmHeight;
        }
        else {
            size[l].mmWidth = pScreen->mmWidth;
            size[l].mmHeight = pScreen->mmHeight;
        }
        size[l].nRates = 0;
        size[l].pRates = &refresh[data->nrefresh];
        data->nsize++;

        /*
         * Find all modes with matching size
         */
        for (os = o; os < output->numModes + output->numUserModes; os++) {
            if (os < output->numModes)
                mode = output->modes[os];
            else
                mode = output->userModes[os - output->numModes];
            if (mode->mode.width == size[l].width &&
                mode->mode.height == size[l].height) {
                vRefresh = RRVerticalRefresh(&mode->mode);
                used[os] = TRUE;

                for (r = 0; r < size[l].nRates; r++)
                    if (vRefresh == size[l].pRates[r].rate)
                        break;
                if (r == size[l].nRates) {
                    size[l].pRates[r].rate = vRefresh;
                    size[l].pRates[r].mode = mode;
                    size[l].nRates++;
                    data->nrefresh++;
                }
                if (mode == output->crtc->mode) {
                    data->size = l;
                    data->refresh = vRefresh;
                }
            }
        }
    }
    return data;
}

int
ProcRRGetScreenInfo(ClientPtr client)
{
    REQUEST(xRRGetScreenInfoReq);
    xRRGetScreenInfoReply rep;
    WindowPtr pWin;
    int rc;
    ScreenPtr pScreen;
    rrScrPrivPtr pScrPriv;
    CARD8 *extra;
    unsigned long extraLen;
    RROutputPtr output;

    REQUEST_SIZE_MATCH(xRRGetScreenInfoReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    pScreen = pWin->drawable.pScreen;
    pScrPriv = rrGetScrPriv(pScreen);

    if (pScrPriv)
        if (!RRGetInfo(pScreen, TRUE))
            return BadAlloc;

    output = RRFirstOutput(pScreen);

    if (!pScrPriv || !output) {
        rep = (xRRGetScreenInfoReply) {
            .type = X_Reply,
            .setOfRotations = RR_Rotate_0,
            .sequenceNumber = client->sequence,
            .length = 0,
            .root = pWin->drawable.pScreen->root->drawable.id,
            .timestamp = currentTime.milliseconds,
            .configTimestamp = currentTime.milliseconds,
            .nSizes = 0,
            .sizeID = 0,
            .rotation = RR_Rotate_0,
            .rate = 0,
            .nrateEnts = 0
        };
        extra = 0;
        extraLen = 0;
    }
    else {
        int i, j;
        xScreenSizes *size;
        CARD16 *rates;
        CARD8 *data8;
        Bool has_rate = RRClientKnowsRates(client);
        RR10DataPtr pData;
        RRScreenSizePtr pSize;

        pData = RR10GetData(pScreen, output);
        if (!pData)
            return BadAlloc;

        rep = (xRRGetScreenInfoReply) {
            .type = X_Reply,
            .setOfRotations = output->crtc->rotations,
            .sequenceNumber = client->sequence,
            .length = 0,
            .root = pWin->drawable.pScreen->root->drawable.id,
            .timestamp = pScrPriv->lastSetTime.milliseconds,
            .configTimestamp = pScrPriv->lastConfigTime.milliseconds,
            .rotation = output->crtc->rotation,
            .nSizes = pData->nsize,
            .nrateEnts = pData->nrefresh + pData->nsize,
            .sizeID = pData->size,
            .rate = pData->refresh
        };

        extraLen = rep.nSizes * sizeof(xScreenSizes);
        if (has_rate)
            extraLen += rep.nrateEnts * sizeof(CARD16);

        if (extraLen) {
            extra = (CARD8 *) malloc(extraLen);
            if (!extra) {
                free(pData);
                return BadAlloc;
            }
        }
        else
            extra = NULL;

        /*
         * First comes the size information
         */
        size = (xScreenSizes *) extra;
        rates = (CARD16 *) (size + rep.nSizes);
        for (i = 0; i < pData->nsize; i++) {
            pSize = &pData->sizes[i];
            size->widthInPixels = pSize->width;
            size->heightInPixels = pSize->height;
            size->widthInMillimeters = pSize->mmWidth;
            size->heightInMillimeters = pSize->mmHeight;
            if (client->swapped) {
                swaps(&size->widthInPixels);
                swaps(&size->heightInPixels);
                swaps(&size->widthInMillimeters);
                swaps(&size->heightInMillimeters);
            }
            size++;
            if (has_rate) {
                *rates = pSize->nRates;
                if (client->swapped) {
                    swaps(rates);
                }
                rates++;
                for (j = 0; j < pSize->nRates; j++) {
                    *rates = pSize->pRates[j].rate;
                    if (client->swapped) {
                        swaps(rates);
                    }
                    rates++;
                }
            }
        }
        free(pData);

        data8 = (CARD8 *) rates;

        if (data8 - (CARD8 *) extra != extraLen)
            FatalError("RRGetScreenInfo bad extra len %ld != %ld\n",
                       (unsigned long) (data8 - (CARD8 *) extra), extraLen);
        rep.length = bytes_to_int32(extraLen);
    }
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.timestamp);
        swapl(&rep.configTimestamp);
        swaps(&rep.rotation);
        swaps(&rep.nSizes);
        swaps(&rep.sizeID);
        swaps(&rep.rate);
        swaps(&rep.nrateEnts);
    }
    WriteToClient(client, sizeof(xRRGetScreenInfoReply), &rep);
    if (extraLen) {
        WriteToClient(client, extraLen, extra);
        free(extra);
    }
    return Success;
}

int
ProcRRSetScreenConfig(ClientPtr client)
{
    REQUEST(xRRSetScreenConfigReq);
    xRRSetScreenConfigReply rep;
    DrawablePtr pDraw;
    int rc;
    ScreenPtr pScreen;
    rrScrPrivPtr pScrPriv;
    TimeStamp time;
    int i;
    Rotation rotation;
    int rate;
    Bool has_rate;
    CARD8 status;
    RROutputPtr output;
    RRCrtcPtr crtc;
    RRModePtr mode;
    RR10DataPtr pData = NULL;
    RRScreenSizePtr pSize;
    int width, height;

    UpdateCurrentTime();

    if (RRClientKnowsRates(client)) {
        REQUEST_SIZE_MATCH(xRRSetScreenConfigReq);
        has_rate = TRUE;
    }
    else {
        REQUEST_SIZE_MATCH(xRR1_0SetScreenConfigReq);
        has_rate = FALSE;
    }

    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixWriteAccess);
    if (rc != Success)
        return rc;

    pScreen = pDraw->pScreen;

    pScrPriv = rrGetScrPriv(pScreen);

    time = ClientTimeToServerTime(stuff->timestamp);

    if (!pScrPriv) {
        time = currentTime;
        status = RRSetConfigFailed;
        goto sendReply;
    }
    if (!RRGetInfo(pScreen, FALSE))
        return BadAlloc;

    output = RRFirstOutput(pScreen);
    if (!output) {
        time = currentTime;
        status = RRSetConfigFailed;
        goto sendReply;
    }

    crtc = output->crtc;

    /*
     * If the client's config timestamp is not the same as the last config
     * timestamp, then the config information isn't up-to-date and
     * can't even be validated.
     *
     * Note that the client only knows about the milliseconds part of the
     * timestamp, so using CompareTimeStamps here would cause randr to suddenly
     * stop working after several hours have passed (freedesktop bug #6502).
     */
    if (stuff->configTimestamp != pScrPriv->lastConfigTime.milliseconds) {
        status = RRSetConfigInvalidConfigTime;
        goto sendReply;
    }

    pData = RR10GetData(pScreen, output);
    if (!pData)
        return BadAlloc;

    if (stuff->sizeID >= pData->nsize) {
        /*
         * Invalid size ID
         */
        client->errorValue = stuff->sizeID;
        free(pData);
        return BadValue;
    }
    pSize = &pData->sizes[stuff->sizeID];

    /*
     * Validate requested rotation
     */
    rotation = (Rotation) stuff->rotation;

    /* test the rotation bits only! */
    switch (rotation & 0xf) {
    case RR_Rotate_0:
    case RR_Rotate_90:
    case RR_Rotate_180:
    case RR_Rotate_270:
        break;
    default:
        /*
         * Invalid rotation
         */
        client->errorValue = stuff->rotation;
        free(pData);
        return BadValue;
    }

    if ((~crtc->rotations) & rotation) {
        /*
         * requested rotation or reflection not supported by screen
         */
        client->errorValue = stuff->rotation;
        free(pData);
        return BadMatch;
    }

    /*
     * Validate requested refresh
     */
    if (has_rate)
        rate = (int) stuff->rate;
    else
        rate = 0;

    if (rate) {
        for (i = 0; i < pSize->nRates; i++) {
            if (pSize->pRates[i].rate == rate)
                break;
        }
        if (i == pSize->nRates) {
            /*
             * Invalid rate
             */
            client->errorValue = rate;
            free(pData);
            return BadValue;
        }
        mode = pSize->pRates[i].mode;
    }
    else
        mode = pSize->pRates[0].mode;

    /*
     * Make sure the requested set-time is not older than
     * the last set-time
     */
    if (CompareTimeStamps(time, pScrPriv->lastSetTime) < 0) {
        status = RRSetConfigInvalidTime;
        goto sendReply;
    }

    /*
     * If the screen size is changing, adjust all of the other outputs
     * to fit the new size, mirroring as much as possible
     */
    width = mode->mode.width;
    height = mode->mode.height;
    if (width < pScrPriv->minWidth || pScrPriv->maxWidth < width) {
        client->errorValue = width;
        free(pData);
        return BadValue;
    }
    if (height < pScrPriv->minHeight || pScrPriv->maxHeight < height) {
        client->errorValue = height;
        free(pData);
        return BadValue;
    }

    if (rotation & (RR_Rotate_90 | RR_Rotate_270)) {
        width = mode->mode.height;
        height = mode->mode.width;
    }

    if (width != pScreen->width || height != pScreen->height) {
        int c;

        for (c = 0; c < pScrPriv->numCrtcs; c++) {
            if (!RRCrtcSet(pScrPriv->crtcs[c], NULL, 0, 0, RR_Rotate_0,
                           0, NULL)) {
                status = RRSetConfigFailed;
                /* XXX recover from failure */
                goto sendReply;
            }
        }
        if (!RRScreenSizeSet(pScreen, width, height,
                             pScreen->mmWidth, pScreen->mmHeight)) {
            status = RRSetConfigFailed;
            /* XXX recover from failure */
            goto sendReply;
        }
    }

    if (!RRCrtcSet(crtc, mode, 0, 0, stuff->rotation, 1, &output))
        status = RRSetConfigFailed;
    else {
        pScrPriv->lastSetTime = time;
        status = RRSetConfigSuccess;
    }

    /*
     * XXX Configure other crtcs to mirror as much as possible
     */

 sendReply:

    free(pData);

    rep = (xRRSetScreenConfigReply) {
        .type = X_Reply,
        .status = status,
        .sequenceNumber = client->sequence,
        .length = 0,

        .newTimestamp = pScrPriv->lastSetTime.milliseconds,
        .newConfigTimestamp = pScrPriv->lastConfigTime.milliseconds,
        .root = pDraw->pScreen->root->drawable.id,
        /* .subpixelOrder = ?? */
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.newTimestamp);
        swapl(&rep.newConfigTimestamp);
        swapl(&rep.root);
    }
    WriteToClient(client, sizeof(xRRSetScreenConfigReply), &rep);

    return Success;
}

static CARD16
RR10CurrentSizeID(ScreenPtr pScreen)
{
    CARD16 sizeID = 0xffff;
    RROutputPtr output = RRFirstOutput(pScreen);

    if (output) {
        RR10DataPtr data = RR10GetData(pScreen, output);

        if (data) {
            int i;

            for (i = 0; i < data->nsize; i++)
                if (data->sizes[i].width == pScreen->width &&
                    data->sizes[i].height == pScreen->height) {
                    sizeID = (CARD16) i;
                    break;
                }
            free(data);
        }
    }
    return sizeID;
}
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d416 3
a418 2
    rep.length = (total_crtcs + total_outputs + total_modes * bytes_to_int32(SIZEOF(xRRModeInfo)) +
                  bytes_to_int32(rep.nbytesNames));
@


1.11
log
@Update to xserver 1.16.4.
Contains fix for CVE-2015-0255. ok dcoppa@@
@
text
@a402 2
    ErrorF("reporting %d %d %d %d\n", total_crtcs, total_outputs, total_modes, total_name_len);

@


1.10
log
@Update to xserver 1.14.5
@
text
@d325 1
a325 1
#define update_arrays(gpuscreen, pScrPriv) do {            \
d327 5
d374 1
d378 1
a435 1
    /* TODO primary */
d441 9
a449 1
    update_arrays(pScreen, pScrPriv);
d454 1
a454 1
        update_arrays(iter, pScrPriv);
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d146 1
a146 1
    pScrPriv->changed = TRUE;
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a24 2
static const int padlength[4] = { 0, 3, 2, 1 };

d47 1
a47 2
                                 connSetup->nbytesVendor +
                                 padlength[connSetup->nbytesVendor & 3]);
d71 5
a75 7
    xEvent event;

    event.u.u.type = ConfigureNotify;
    event.u.configureNotify.window = pWin->drawable.id;
    event.u.configureNotify.aboveSibling = None;
    event.u.configureNotify.x = 0;
    event.u.configureNotify.y = 0;
d79 6
a84 4
    event.u.configureNotify.width = pWin->drawable.width;
    event.u.configureNotify.height = pWin->drawable.height;
    event.u.configureNotify.borderWidth = wBorderWidth(pWin);
    event.u.configureNotify.override = pWin->overrideRedirect;
a91 1
    xRRScreenChangeNotifyEvent se;
d95 8
a102 7
    se.type = RRScreenChangeNotify + RREventBase;
    se.rotation = (CARD8) (crtc ? crtc->rotation : RR_Rotate_0);
    se.timestamp = pScrPriv->lastSetTime.milliseconds;
    se.configTimestamp = pScrPriv->lastConfigTime.milliseconds;
    se.root = pRoot->drawable.id;
    se.window = pWin->drawable.id;
    se.subpixelOrder = PictureGetSubpixelOrder(pScreen);
d104 2
a105 1
    se.sizeID = RR10CurrentSizeID(pScreen);
d196 1
a196 1
    REQUEST_SIZE_MATCH(xRRGetScreenInfoReq);
d204 6
a209 4
    rep.type = X_Reply;
    rep.pad = 0;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
d231 1
a231 1
    WriteToClient(client, sizeof(xRRGetScreenSizeRangeReply), (char *) &rep);
d251 3
d295 167
a484 1
    rep.pad = 0;
d490 3
d494 11
a504 9
        rep.type = X_Reply;
        rep.sequenceNumber = client->sequence;
        rep.length = 0;
        rep.timestamp = currentTime.milliseconds;
        rep.configTimestamp = currentTime.milliseconds;
        rep.nCrtcs = 0;
        rep.nOutputs = 0;
        rep.nModes = 0;
        rep.nbytesNames = 0;
d516 12
a527 9
        rep.type = X_Reply;
        rep.sequenceNumber = client->sequence;
        rep.length = 0;
        rep.timestamp = pScrPriv->lastSetTime.milliseconds;
        rep.configTimestamp = pScrPriv->lastConfigTime.milliseconds;
        rep.nCrtcs = pScrPriv->numCrtcs;
        rep.nOutputs = pScrPriv->numOutputs;
        rep.nModes = num_modes;
        rep.nbytesNames = 0;
a751 1
    rep.pad = 0;
d760 14
a773 12
        rep.type = X_Reply;
        rep.setOfRotations = RR_Rotate_0;
        rep.sequenceNumber = client->sequence;
        rep.length = 0;
        rep.root = pWin->drawable.pScreen->root->drawable.id;
        rep.timestamp = currentTime.milliseconds;
        rep.configTimestamp = currentTime.milliseconds;
        rep.nSizes = 0;
        rep.sizeID = 0;
        rep.rotation = RR_Rotate_0;
        rep.rate = 0;
        rep.nrateEnts = 0;
d790 14
a803 12
        rep.type = X_Reply;
        rep.setOfRotations = output->crtc->rotations;
        rep.sequenceNumber = client->sequence;
        rep.length = 0;
        rep.root = pWin->drawable.pScreen->root->drawable.id;
        rep.timestamp = pScrPriv->lastSetTime.milliseconds;
        rep.configTimestamp = pScrPriv->lastConfigTime.milliseconds;
        rep.rotation = output->crtc->rotation;
        rep.nSizes = pData->nsize;
        rep.nrateEnts = pData->nrefresh + pData->nsize;
        rep.sizeID = pData->size;
        rep.rate = pData->refresh;
d865 1
d872 1
a872 1
    WriteToClient(client, sizeof(xRRGetScreenInfoReply), (char *) &rep);
d874 1
a874 1
        WriteToClient(client, extraLen, (char *) extra);
d894 1
d925 1
a925 1
        rep.status = RRSetConfigFailed;
d934 1
a934 1
        rep.status = RRSetConfigFailed;
d950 1
a950 1
        rep.status = RRSetConfigInvalidConfigTime;
d1029 1
a1029 1
        rep.status = RRSetConfigInvalidTime;
d1061 1
a1061 1
                rep.status = RRSetConfigFailed;
d1068 1
a1068 1
            rep.status = RRSetConfigFailed;
d1075 1
a1075 1
        rep.status = RRSetConfigFailed;
d1078 1
a1078 1
        rep.status = RRSetConfigSuccess;
d1089 11
a1099 8
    rep.type = X_Reply;
    /* rep.status has already been filled in */
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    rep.newTimestamp = pScrPriv->lastSetTime.milliseconds;
    rep.newConfigTimestamp = pScrPriv->lastConfigTime.milliseconds;
    rep.root = pDraw->pScreen->root->drawable.id;
d1108 1
a1108 1
    WriteToClient(client, sizeof(xRRSetScreenConfigReply), (char *) &rep);
@


1.7
log
@Update to xserver 1.11.2
@
text
@d25 1
a25 1
static const int padlength[4] = {0, 3, 2, 1};
d28 1
a28 1
RR10CurrentSizeID (ScreenPtr pScreen);
d35 1
a35 1
RREditConnectionInfo (ScreenPtr pScreen)
d37 8
a44 8
    xConnSetup	    *connSetup;
    char	    *vendor;
    xPixmapFormat   *formats;
    xWindowRoot	    *root;
    xDepth	    *depth;
    xVisualType	    *visual;
    int		    screen = 0;
    int		    d;
d47 1
a47 1
    vendor = (char *) connSetup + sizeof (xConnSetup);
d49 2
a50 2
				 connSetup->nbytesVendor +
				 padlength[connSetup->nbytesVendor & 3]);
d52 11
a62 14
			    sizeof (xPixmapFormat) * screenInfo.numPixmapFormats);
    while (screen != pScreen->myNum)
    {
	depth = (xDepth *) ((char *) root + 
			    sizeof (xWindowRoot));
	for (d = 0; d < root->nDepths; d++)
	{
	    visual = (xVisualType *) ((char *) depth +
				      sizeof (xDepth));
	    depth = (xDepth *) ((char *) visual +
				depth->nVisuals * sizeof (xVisualType));
	}
	root = (xWindowRoot *) ((char *) depth);
	screen++;
d71 1
a71 1
RRSendConfigNotify (ScreenPtr pScreen)
d73 2
a74 2
    WindowPtr	pWin = pScreen->root;
    xEvent	event;
d83 1
a83 1
    
d86 1
a86 1
    event.u.configureNotify.borderWidth = wBorderWidth (pWin);
d92 1
a92 1
RRDeliverScreenEvent (ClientPtr client, WindowPtr pWin, ScreenPtr pScreen)
d94 5
a98 5
    rrScrPriv (pScreen);
    xRRScreenChangeNotifyEvent	se;
    RRCrtcPtr	crtc = pScrPriv->numCrtcs ? pScrPriv->crtcs[0] : NULL;
    WindowPtr	pRoot = pScreen->root;
    
d103 1
a103 1
    se.root =  pRoot->drawable.id;
d105 1
a105 1
    se.subpixelOrder = PictureGetSubpixelOrder (pScreen);
d107 1
a107 1
    se.sizeID = RR10CurrentSizeID (pScreen);
d110 10
a119 9
	se.widthInPixels = pScreen->height;
	se.heightInPixels = pScreen->width;
	se.widthInMillimeters = pScreen->mmHeight;
	se.heightInMillimeters = pScreen->mmWidth;
    } else {
	se.widthInPixels = pScreen->width;
	se.heightInPixels = pScreen->height;
	se.widthInMillimeters = pScreen->mmWidth;
	se.heightInMillimeters = pScreen->mmHeight;
d122 1
a122 1
    WriteEventsToClient (client, 1, (xEvent *) &se);
d131 1
a131 1
RRScreenSizeNotify (ScreenPtr	pScreen)
d139 5
a143 5
	pScrPriv->height == pScreen->height &&
	pScrPriv->mmWidth == pScreen->mmWidth &&
	pScrPriv->mmHeight == pScreen->mmHeight)
	return;
    
d151 5
a155 5
    RRTellChanged (pScreen);
    RRSendConfigNotify (pScreen);
    RREditConnectionInfo (pScreen);
    
    RRPointerScreenConfigured (pScreen);
d159 1
a159 1
    ScreenRestructured (pScreen);
d166 2
a167 5
RRScreenSizeSet (ScreenPtr  pScreen,
		 CARD16	    width,
		 CARD16	    height,
		 CARD32	    mmWidth,
		 CARD32	    mmHeight)
d172 3
a174 5
    if (pScrPriv->rrScreenSetSize)
    {
	return (*pScrPriv->rrScreenSetSize) (pScreen,
					     width, height,
					     mmWidth, mmHeight);
d178 2
a179 3
    if (pScrPriv->rrSetConfig)
    {
	return TRUE;	/* can't set size separately */
d189 1
a189 1
ProcRRGetScreenSizeRange (ClientPtr client)
d192 6
a197 6
    xRRGetScreenSizeRangeReply	rep;
    WindowPtr			pWin;
    ScreenPtr			pScreen;
    rrScrPrivPtr		pScrPriv;
    int				rc;
    
d201 1
a201 1
	return rc;
d205 1
a205 1
    
d210 8
a217 9
    
    if (pScrPriv) 
    {
	if (!RRGetInfo (pScreen, FALSE))
	    return BadAlloc;
	rep.minWidth  = pScrPriv->minWidth;
	rep.minHeight = pScrPriv->minHeight;
	rep.maxWidth  = pScrPriv->maxWidth;
	rep.maxHeight = pScrPriv->maxHeight;
d219 11
a229 15
    else
    {
	rep.maxWidth  = rep.minWidth  = pScreen->width;
	rep.maxHeight = rep.minHeight = pScreen->height;
    }
    if (client->swapped) 
    {
	int n;
	
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swaps(&rep.minWidth, n);
	swaps(&rep.minHeight, n);
	swaps(&rep.maxWidth, n);
	swaps(&rep.maxHeight, n);
d231 1
a231 1
    WriteToClient(client, sizeof(xRRGetScreenSizeRangeReply), (char *)&rep);
d236 1
a236 1
ProcRRSetScreenSize (ClientPtr client)
d239 5
a243 5
    WindowPtr		pWin;
    ScreenPtr		pScreen;
    rrScrPrivPtr	pScrPriv;
    int			i, rc;
    
d247 1
a247 1
	return rc;
d251 37
a287 43
    if (stuff->width < pScrPriv->minWidth || pScrPriv->maxWidth < stuff->width)
    {
	client->errorValue = stuff->width;
	return BadValue;
    }
    if (stuff->height < pScrPriv->minHeight || 
	pScrPriv->maxHeight < stuff->height)
    {
	client->errorValue = stuff->height;
	return BadValue;
    }
    for (i = 0; i < pScrPriv->numCrtcs; i++) 
    {
	RRCrtcPtr   crtc = pScrPriv->crtcs[i];
	RRModePtr   mode = crtc->mode;
	if (mode)
	{
	    int		source_width = mode->mode.width;
	    int		source_height = mode->mode.height;
	    Rotation	rotation = crtc->rotation;

	    if (rotation == RR_Rotate_90 || rotation == RR_Rotate_270)
	    {
		source_width = mode->mode.height;
		source_height = mode->mode.width;
	    }
	    
	    if (crtc->x + source_width > stuff->width ||
		crtc->y + source_height > stuff->height)
	    return BadMatch;
	}
    }
    if (stuff->widthInMillimeters == 0 || stuff->heightInMillimeters == 0)
    {
	client->errorValue = 0;
	return BadValue;
    }
    if (!RRScreenSizeSet (pScreen, 
			  stuff->width, stuff->height,
			  stuff->widthInMillimeters,
			  stuff->heightInMillimeters))
    {
	return BadMatch;
d296 12
a307 12
    xRRGetScreenResourcesReply  rep;
    WindowPtr			pWin;
    ScreenPtr			pScreen;
    rrScrPrivPtr		pScrPriv;
    CARD8			*extra;
    unsigned long		extraLen;
    int				i, n, rc, has_primary = 0;
    RRCrtc			*crtcs;
    RROutput			*outputs;
    xRRModeInfo			*modeinfos;
    CARD8			*names;
    
d311 2
a312 2
	return rc;
    
d316 1
a316 1
    
d318 2
a319 2
	if (!RRGetInfo (pScreen, query))
	    return BadAlloc;
d321 12
a332 13
    if (!pScrPriv)
    {
	rep.type = X_Reply;
	rep.sequenceNumber = client->sequence;
	rep.length = 0;
	rep.timestamp = currentTime.milliseconds;
	rep.configTimestamp = currentTime.milliseconds;
	rep.nCrtcs = 0;
	rep.nOutputs = 0;
	rep.nModes = 0;
	rep.nbytesNames = 0;
	extra = NULL;
	extraLen = 0;
d334 88
a421 97
    else
    {
	RRModePtr   *modes;
	int	    num_modes;

	modes = RRModesForScreen (pScreen, &num_modes);
	if (!modes)
	    return BadAlloc;
	
	rep.type = X_Reply;
	rep.sequenceNumber = client->sequence;
	rep.length = 0;
	rep.timestamp = pScrPriv->lastSetTime.milliseconds;
	rep.configTimestamp = pScrPriv->lastConfigTime.milliseconds;
	rep.nCrtcs = pScrPriv->numCrtcs;
	rep.nOutputs = pScrPriv->numOutputs;
	rep.nModes = num_modes;
	rep.nbytesNames = 0;

	for (i = 0; i < num_modes; i++)
	    rep.nbytesNames += modes[i]->mode.nameLength;

	rep.length = (pScrPriv->numCrtcs + 
		      pScrPriv->numOutputs + 
		      num_modes * bytes_to_int32(SIZEOF(xRRModeInfo)) +
		      bytes_to_int32(rep.nbytesNames));
	
	extraLen = rep.length << 2;
	if (extraLen)
	{
	    extra = malloc(extraLen);
	    if (!extra)
	    {
		free(modes);
		return BadAlloc;
	    }
	}
	else
	    extra = NULL;

	crtcs = (RRCrtc *) extra;
	outputs = (RROutput *) (crtcs + pScrPriv->numCrtcs);
	modeinfos = (xRRModeInfo *) (outputs + pScrPriv->numOutputs);
	names = (CARD8 *) (modeinfos + num_modes);

	if (pScrPriv->primaryOutput && pScrPriv->primaryOutput->crtc)
	{
	    has_primary = 1;
	    crtcs[0] = pScrPriv->primaryOutput->crtc->id;
	    if (client->swapped)
		swapl (&crtcs[0], n);
	}
	
	for (i = 0; i < pScrPriv->numCrtcs; i++)
	{
	    if (has_primary &&
		pScrPriv->primaryOutput->crtc == pScrPriv->crtcs[i])
	    {
		has_primary = 0;
		continue;
	    }
	    crtcs[i + has_primary] = pScrPriv->crtcs[i]->id;
	    if (client->swapped)
		swapl (&crtcs[i + has_primary], n);
	}
	
	for (i = 0; i < pScrPriv->numOutputs; i++)
	{
	    outputs[i] = pScrPriv->outputs[i]->id;
	    if (client->swapped)
		swapl (&outputs[i], n);
	}
	
	for (i = 0; i < num_modes; i++)
	{
	    RRModePtr	mode = modes[i];
	    modeinfos[i] = mode->mode;
	    if (client->swapped)
	    {
		swapl (&modeinfos[i].id, n);
		swaps (&modeinfos[i].width, n);
		swaps (&modeinfos[i].height, n);
		swapl (&modeinfos[i].dotClock, n);
		swaps (&modeinfos[i].hSyncStart, n);
		swaps (&modeinfos[i].hSyncEnd, n);
		swaps (&modeinfos[i].hTotal, n);
		swaps (&modeinfos[i].hSkew, n);
		swaps (&modeinfos[i].vSyncStart, n);
		swaps (&modeinfos[i].vSyncEnd, n);
		swaps (&modeinfos[i].vTotal, n);
		swaps (&modeinfos[i].nameLength, n);
		swapl (&modeinfos[i].modeFlags, n);
	    }
	    memcpy (names, mode->name, 
		    mode->mode.nameLength);
	    names += mode->mode.nameLength;
	}
d423 1
a423 1
	assert (bytes_to_int32((char *) names - (char *) extra) == rep.length);
d425 1
a425 1
    
d427 13
a439 14
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.timestamp, n);
	swapl(&rep.configTimestamp, n);
	swaps(&rep.nCrtcs, n);
	swaps(&rep.nOutputs, n);
	swaps(&rep.nModes, n);
	swaps(&rep.nbytesNames, n);
    }
    WriteToClient(client, sizeof(xRRGetScreenResourcesReply), (char *)&rep);
    if (extraLen)
    {
	WriteToClient (client, extraLen, (char *) extra);
	free(extra);
d445 1
a445 1
ProcRRGetScreenResources (ClientPtr client)
d449 1
a449 1
    
d451 1
a451 1
ProcRRGetScreenResourcesCurrent (ClientPtr client)
d458 4
a461 4
    int		    nsize;
    int		    nrefresh;
    int		    size;
    CARD16	    refresh;
d468 1
a468 1
RR10GetData (ScreenPtr pScreen, RROutputPtr output)
d470 1
a470 1
    RR10DataPtr	    data;
d472 2
a473 2
    int		    nmode = output->numModes + output->numUserModes;
    int		    o, os, l, r;
d475 3
a477 3
    CARD16	    vRefresh;
    RRModePtr	    mode;
    Bool	    *used;
d480 3
a482 4
    data = malloc (sizeof (RR10DataRec) + 
		   sizeof (RRScreenSize) * nmode + 
		   sizeof (RRScreenRate) * nmode +
		   sizeof (Bool) * nmode);
d484 1
a484 1
	return NULL;
d488 1
a488 1
    memset (used, '\0', sizeof (Bool) * nmode);
d494 1
a494 1
    
d498 53
a550 56
    for (o = 0; o < output->numModes + output->numUserModes; o++)
    {
	if (used[o]) continue;
	
	if (o < output->numModes)
	    mode = output->modes[o];
	else
	    mode = output->userModes[o - output->numModes];
	
	l = data->nsize;
	size[l].id = data->nsize;
	size[l].width = mode->mode.width;
	size[l].height = mode->mode.height;
	if (output->mmWidth && output->mmHeight) {
	    size[l].mmWidth = output->mmWidth;
	    size[l].mmHeight = output->mmHeight;
	} else {
	    size[l].mmWidth = pScreen->mmWidth;
	    size[l].mmHeight = pScreen->mmHeight;
	}
	size[l].nRates = 0;
	size[l].pRates = &refresh[data->nrefresh];
	data->nsize++;
	
	/*
	 * Find all modes with matching size
	 */
	for (os = o; os < output->numModes + output->numUserModes; os++)
	{
	    if (os < output->numModes)
		mode = output->modes[os];
	    else
		mode = output->userModes[os - output->numModes];
	    if (mode->mode.width == size[l].width &&
		mode->mode.height == size[l].height)
	    {
		vRefresh = RRVerticalRefresh (&mode->mode);
		used[os] = TRUE;
		
		for (r = 0; r < size[l].nRates; r++)
		    if (vRefresh == size[l].pRates[r].rate)
			break;
		if (r == size[l].nRates)
		{
		    size[l].pRates[r].rate = vRefresh;
		    size[l].pRates[r].mode = mode;
		    size[l].nRates++;
		    data->nrefresh++;
		}
		if (mode == output->crtc->mode)
		{
		    data->size = l;
		    data->refresh = vRefresh;
		}
	    }
	}
d556 1
a556 1
ProcRRGetScreenInfo (ClientPtr client)
d559 8
a566 8
    xRRGetScreenInfoReply   rep;
    WindowPtr	    	    pWin;
    int			    n, rc;
    ScreenPtr		    pScreen;
    rrScrPrivPtr	    pScrPriv;
    CARD8		    *extra;
    unsigned long	    extraLen;
    RROutputPtr		    output;
d571 1
a571 1
	return rc;
d576 1
a576 1
    
d578 4
a581 2
	if (!RRGetInfo (pScreen, TRUE))
	    return BadAlloc;
d583 15
a597 18
    output = RRFirstOutput (pScreen);
    
    if (!pScrPriv || !output)
    {
	rep.type = X_Reply;
	rep.setOfRotations = RR_Rotate_0;
	rep.sequenceNumber = client->sequence;
	rep.length = 0;
	rep.root = pWin->drawable.pScreen->root->drawable.id;
	rep.timestamp = currentTime.milliseconds;
	rep.configTimestamp = currentTime.milliseconds;
	rep.nSizes = 0;
	rep.sizeID = 0;
	rep.rotation = RR_Rotate_0;
	rep.rate = 0;
	rep.nrateEnts = 0;
	extra = 0;
	extraLen = 0;
d599 22
a620 23
    else
    {
	int			i, j;
	xScreenSizes		*size;
	CARD16			*rates;
	CARD8			*data8;
	Bool			has_rate = RRClientKnowsRates (client);
	RR10DataPtr		pData;
	RRScreenSizePtr		pSize;
    
	pData = RR10GetData (pScreen, output);
	if (!pData)
	    return BadAlloc;
	
	rep.type = X_Reply;
	rep.setOfRotations = output->crtc->rotations;
	rep.sequenceNumber = client->sequence;
	rep.length = 0;
	rep.root = pWin->drawable.pScreen->root->drawable.id;
	rep.timestamp = pScrPriv->lastSetTime.milliseconds;
	rep.configTimestamp = pScrPriv->lastConfigTime.milliseconds;
	rep.rotation = output->crtc->rotation;
	rep.nSizes = pData->nsize;
d622 2
a623 2
	rep.sizeID = pData->size;
	rep.rate = pData->refresh;
d625 47
a671 55
	extraLen = rep.nSizes * sizeof (xScreenSizes);
	if (has_rate)
		extraLen += rep.nrateEnts * sizeof (CARD16);

	if (extraLen)
	{
	    extra = (CARD8 *) malloc(extraLen);
	    if (!extra)
	    {
		free(pData);
		return BadAlloc;
	    }
	}
	else
	    extra = NULL;

	/*
	 * First comes the size information
	 */
	size = (xScreenSizes *) extra;
	rates = (CARD16 *) (size + rep.nSizes);
	for (i = 0; i < pData->nsize; i++)
	{
	    pSize = &pData->sizes[i];
	    size->widthInPixels = pSize->width;
	    size->heightInPixels = pSize->height;
	    size->widthInMillimeters = pSize->mmWidth;
	    size->heightInMillimeters = pSize->mmHeight;
	    if (client->swapped)
	    {
	        swaps (&size->widthInPixels, n);
	        swaps (&size->heightInPixels, n);
	        swaps (&size->widthInMillimeters, n);
	        swaps (&size->heightInMillimeters, n);
	    }
	    size++;
	    if (has_rate)
	    {
		*rates = pSize->nRates;
		if (client->swapped)
		{
		    swaps (rates, n);
		}
		rates++;
		for (j = 0; j < pSize->nRates; j++)
		{
		    *rates = pSize->pRates[j].rate;
		    if (client->swapped)
		    {
			swaps (rates, n);
		    }
		    rates++;
		}
	    }
	}
a672 2
	
	data8 = (CARD8 *) rates;
d674 6
a679 4
	if (data8 - (CARD8 *) extra != extraLen)
	    FatalError ("RRGetScreenInfo bad extra len %ld != %ld\n",
			(unsigned long)(data8 - (CARD8 *) extra), extraLen);
	rep.length =  bytes_to_int32(extraLen);
d682 13
a694 14
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.timestamp, n);
	swaps(&rep.rotation, n);
	swaps(&rep.nSizes, n);
	swaps(&rep.sizeID, n);
	swaps(&rep.rate, n);
	swaps(&rep.nrateEnts, n);
    }
    WriteToClient(client, sizeof(xRRGetScreenInfoReply), (char *)&rep);
    if (extraLen)
    {
	WriteToClient (client, extraLen, (char *) extra);
	free(extra);
d700 1
a700 1
ProcRRSetScreenConfig (ClientPtr client)
d704 21
a724 22
    DrawablePtr		    pDraw;
    int			    n, rc;
    ScreenPtr		    pScreen;
    rrScrPrivPtr	    pScrPriv;
    TimeStamp		    time;
    int			    i;
    Rotation		    rotation;
    int			    rate;
    Bool		    has_rate;
    RROutputPtr		    output;
    RRCrtcPtr		    crtc;
    RRModePtr		    mode;
    RR10DataPtr		    pData = NULL;
    RRScreenSizePtr    	    pSize;
    int			    width, height;
    
    UpdateCurrentTime ();

    if (RRClientKnowsRates (client))
    {
	REQUEST_SIZE_MATCH (xRRSetScreenConfigReq);
	has_rate = TRUE;
d726 3
a728 4
    else
    {
	REQUEST_SIZE_MATCH (xRR1_0SetScreenConfigReq);
	has_rate = FALSE;
d730 1
a730 1
    
d733 1
a733 1
	return rc;
d738 1
a738 1
    
d740 14
a753 16
    
    if (!pScrPriv)
    {
	time = currentTime;
	rep.status = RRSetConfigFailed;
	goto sendReply;
    }
    if (!RRGetInfo (pScreen, FALSE))
	return BadAlloc;
    
    output = RRFirstOutput (pScreen);
    if (!output)
    {
	time = currentTime;
	rep.status = RRSetConfigFailed;
	goto sendReply;
d767 3
a769 4
    if (stuff->configTimestamp != pScrPriv->lastConfigTime.milliseconds)
    {
	rep.status = RRSetConfigInvalidConfigTime;
	goto sendReply;
d771 2
a772 2
    
    pData = RR10GetData (pScreen, output);
d774 9
a782 10
	return BadAlloc;
    
    if (stuff->sizeID >= pData->nsize)
    {
	/*
	 * Invalid size ID
	 */
	client->errorValue = stuff->sizeID;
	free(pData);
	return BadValue;
d785 1
a785 1
    
d797 1
a797 1
	break;
d799 15
a813 16
	/*
	 * Invalid rotation
	 */
	client->errorValue = stuff->rotation;
	free(pData);
	return BadValue;
    }

    if ((~crtc->rotations) & rotation)
    {
	/*
	 * requested rotation or reflection not supported by screen
	 */
	client->errorValue = stuff->rotation;
	free(pData);
	return BadMatch;
d820 1
a820 1
	rate = (int) stuff->rate;
d822 1
a822 1
	rate = 0;
d824 14
a837 17
    if (rate)
    {
	for (i = 0; i < pSize->nRates; i++)
	{
	    if (pSize->pRates[i].rate == rate)
		break;
	}
	if (i == pSize->nRates)
	{
	    /*
	     * Invalid rate
	     */
	    client->errorValue = rate;
	    free(pData);
	    return BadValue;
	}
	mode = pSize->pRates[i].mode;
d840 2
a841 2
	mode = pSize->pRates[0].mode;
    
d846 3
a848 4
    if (CompareTimeStamps (time, pScrPriv->lastSetTime) < 0)
    {
	rep.status = RRSetConfigInvalidTime;
	goto sendReply;
d858 3
a860 3
	client->errorValue = width;
	free(pData);
	return BadValue;
d863 3
a865 32
	client->errorValue = height;
	free(pData);
	return BadValue;
    }

    if (rotation & (RR_Rotate_90|RR_Rotate_270))
    {
	width = mode->mode.height;
	height = mode->mode.width;
    }

    if (width != pScreen->width || height != pScreen->height)
    {
	int	c;

	for (c = 0; c < pScrPriv->numCrtcs; c++)
	{
	    if (!RRCrtcSet (pScrPriv->crtcs[c], NULL, 0, 0, RR_Rotate_0,
			    0, NULL))
	    {
		rep.status = RRSetConfigFailed;
		/* XXX recover from failure */
		goto sendReply;
	    }
	}
	if (!RRScreenSizeSet (pScreen, width, height,
			      pScreen->mmWidth, pScreen->mmHeight))
	{
	    rep.status = RRSetConfigFailed;
	    /* XXX recover from failure */
	    goto sendReply;
	}
d868 26
a893 2
    if (!RRCrtcSet (crtc, mode, 0, 0, stuff->rotation, 1, &output))
	rep.status = RRSetConfigFailed;
d895 2
a896 2
	pScrPriv->lastSetTime = time;
	rep.status = RRSetConfigSuccess;
d902 3
a904 3
    
sendReply:
    
d916 6
a921 7
    if (client->swapped) 
    {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.newTimestamp, n);
	swapl(&rep.newConfigTimestamp, n);
	swapl(&rep.root, n);
d923 1
a923 1
    WriteToClient(client, sizeof(xRRSetScreenConfigReply), (char *)&rep);
d929 1
a929 1
RR10CurrentSizeID (ScreenPtr pScreen)
d931 17
a947 18
    CARD16	sizeID = 0xffff;
    RROutputPtr output = RRFirstOutput (pScreen);
    
    if (output)
    {
	RR10DataPtr data = RR10GetData (pScreen, output);
	if (data)
	{
	    int i;
	    for (i = 0; i < data->nsize; i++)
		if (data->sizes[i].width == pScreen->width &&
		    data->sizes[i].height == pScreen->height)
		{
		    sizeID = (CARD16) i;
		    break;
		}
	    free(data);
	}
@


1.6
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@a912 6
    if (rotation & (RR_Rotate_90|RR_Rotate_270))
    {
	width = mode->mode.height;
	height = mode->mode.width;
    }

d922 6
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d918 12
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d76 1
a76 1
    WindowPtr	pWin = WindowTable[pScreen->myNum];
d100 1
a100 1
    WindowPtr	pRoot = WindowTable[pScreen->myNum];
a104 1
    se.sequenceNumber = client->sequence;
a107 1
#ifdef RENDER
a108 3
#else
    se.subpixelOrder = SubPixelUnknown;
#endif
a109 1
    se.sequenceNumber = client->sequence;
d245 1
a245 1
    return (client->noClientException);
d384 1
a384 1
	    extra = xalloc (extraLen);
d387 1
a387 1
		xfree (modes);
d451 1
a451 1
    	xfree (modes);
d469 1
a469 1
	xfree (extra);
d471 1
a471 1
    return client->noClientException;
d623 1
a623 1
	rep.root = WindowTable[pWin->drawable.pScreen->myNum]->drawable.id;
d652 1
a652 1
	rep.root = WindowTable[pWin->drawable.pScreen->myNum]->drawable.id;
d667 1
a667 1
	    extra = (CARD8 *) xalloc (extraLen);
d670 1
a670 1
		xfree (pData);
d716 1
a716 1
        xfree (pData);
d739 1
a739 1
	xfree (extra);
d741 1
a741 1
    return (client->noClientException);
d832 1
a832 1
	xfree (pData);
d854 1
a854 1
	xfree (pData);
d864 1
a864 1
	xfree (pData);
d889 1
a889 1
	    xfree (pData);
d954 1
a954 2
    if (pData)
	xfree (pData);
d963 1
a963 1
    rep.root = WindowTable[pDraw->pScreen->myNum]->drawable.id;
d975 1
a975 1
    return (client->noClientException);
d997 1
a997 1
	    xfree (data);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d202 1
a202 1
int 
d213 1
a213 1
    rc = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
d264 1
a264 1
    rc = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
d334 1
a334 1
    rc = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
d384 2
a385 2
		      num_modes * (SIZEOF(xRRModeInfo) >> 2) +
		      ((rep.nbytesNames + 3) >> 2));
d458 1
a458 1
	assert (((((char *) names - (char *) extra) + 3) >> 2) == rep.length);
d609 1
a609 1
    rc = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
d729 1
a729 1
	rep.length =  (extraLen + 3) >> 2;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d25 1
a25 3
extern char	*ConnectionInfo;

static int padlength[4] = {0, 3, 2, 1};
d227 1
a227 1
	if (!RRGetInfo (pScreen))
d317 2
a318 2
int
ProcRRGetScreenResources (ClientPtr client)
d327 1
a327 1
    int				i, n, rc;
d342 2
a343 2
    if (pScrPriv)
	if (!RRGetInfo (pScreen))
d404 8
d415 7
a421 1
	    crtcs[i] = pScrPriv->crtcs[i]->id;
d423 1
a423 1
		swapl (&crtcs[i], n);
d480 12
d618 1
a618 1
	if (!RRGetInfo (pScreen))
d626 1
a626 1
	rep.setOfRotations = RR_Rotate_0;;
d667 3
a669 2
	extraLen = (rep.nSizes * sizeof (xScreenSizes) +
		    rep.nrateEnts * sizeof (CARD16));
d800 1
a800 1
    if (!RRGetInfo (pScreen))
d949 2
a950 1
    else
d952 1
@


1.1
log
@Initial revision
@
text
@a733 1
    TimeStamp		    configTime;
@


1.1.1.1
log
@xserver 1.4
@
text
@@
