head	1.12;
access;
symbols
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.6
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2013.12.28.14.40.02;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.05.18.11.38;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.13;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.13;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.13;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright © 2000 Compaq Computer Corporation
 * Copyright © 2002 Hewlett-Packard Company
 * Copyright © 2006 Intel Corporation
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 *
 * Author:  Jim Gettys, Hewlett-Packard Company, Inc.
 *	    Keith Packard, Intel Corporation
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "randrstr.h"
#include "extinit.h"

/* From render.h */
#ifndef SubPixelUnknown
#define SubPixelUnknown 0
#endif

#define RR_VALIDATE
static int RRNScreens;

#define wrap(priv,real,mem,func) {\
    priv->mem = real->mem; \
    real->mem = func; \
}

#define unwrap(priv,real,mem) {\
    real->mem = priv->mem; \
}

static int ProcRRDispatch(ClientPtr pClient);
static int SProcRRDispatch(ClientPtr pClient);

int RREventBase;
int RRErrorBase;
RESTYPE RRClientType, RREventType;      /* resource types for event masks */
DevPrivateKeyRec RRClientPrivateKeyRec;

DevPrivateKeyRec rrPrivKeyRec;

static void
RRClientCallback(CallbackListPtr *list, void *closure, void *data)
{
    NewClientInfoRec *clientinfo = (NewClientInfoRec *) data;
    ClientPtr pClient = clientinfo->client;

    rrClientPriv(pClient);
    RRTimesPtr pTimes = (RRTimesPtr) (pRRClient + 1);
    int i;

    pRRClient->major_version = 0;
    pRRClient->minor_version = 0;
    for (i = 0; i < screenInfo.numScreens; i++) {
        ScreenPtr pScreen = screenInfo.screens[i];

        rrScrPriv(pScreen);

        if (pScrPriv) {
            pTimes[i].setTime = pScrPriv->lastSetTime;
            pTimes[i].configTime = pScrPriv->lastConfigTime;
        }
    }
}

static Bool
RRCloseScreen(ScreenPtr pScreen)
{
    rrScrPriv(pScreen);
    int j;

    unwrap(pScrPriv, pScreen, CloseScreen);
    for (j = pScrPriv->numCrtcs - 1; j >= 0; j--)
        RRCrtcDestroy(pScrPriv->crtcs[j]);
    for (j = pScrPriv->numOutputs - 1; j >= 0; j--)
        RROutputDestroy(pScrPriv->outputs[j]);

    if (pScrPriv->provider)
        RRProviderDestroy(pScrPriv->provider);

    RRMonitorClose(pScreen);

    free(pScrPriv->crtcs);
    free(pScrPriv->outputs);
    free(pScrPriv);
    RRNScreens -= 1;            /* ok, one fewer screen with RandR running */
    return (*pScreen->CloseScreen) (pScreen);
}

static void
SRRScreenChangeNotifyEvent(xRRScreenChangeNotifyEvent * from,
                           xRRScreenChangeNotifyEvent * to)
{
    to->type = from->type;
    to->rotation = from->rotation;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->timestamp, to->timestamp);
    cpswapl(from->configTimestamp, to->configTimestamp);
    cpswapl(from->root, to->root);
    cpswapl(from->window, to->window);
    cpswaps(from->sizeID, to->sizeID);
    cpswaps(from->subpixelOrder, to->subpixelOrder);
    cpswaps(from->widthInPixels, to->widthInPixels);
    cpswaps(from->heightInPixels, to->heightInPixels);
    cpswaps(from->widthInMillimeters, to->widthInMillimeters);
    cpswaps(from->heightInMillimeters, to->heightInMillimeters);
}

static void
SRRCrtcChangeNotifyEvent(xRRCrtcChangeNotifyEvent * from,
                         xRRCrtcChangeNotifyEvent * to)
{
    to->type = from->type;
    to->subCode = from->subCode;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->timestamp, to->timestamp);
    cpswapl(from->window, to->window);
    cpswapl(from->crtc, to->crtc);
    cpswapl(from->mode, to->mode);
    cpswaps(from->rotation, to->rotation);
    /* pad1 */
    cpswaps(from->x, to->x);
    cpswaps(from->y, to->y);
    cpswaps(from->width, to->width);
    cpswaps(from->height, to->height);
}

static void
SRROutputChangeNotifyEvent(xRROutputChangeNotifyEvent * from,
                           xRROutputChangeNotifyEvent * to)
{
    to->type = from->type;
    to->subCode = from->subCode;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->timestamp, to->timestamp);
    cpswapl(from->configTimestamp, to->configTimestamp);
    cpswapl(from->window, to->window);
    cpswapl(from->output, to->output);
    cpswapl(from->crtc, to->crtc);
    cpswapl(from->mode, to->mode);
    cpswaps(from->rotation, to->rotation);
    to->connection = from->connection;
    to->subpixelOrder = from->subpixelOrder;
}

static void
SRROutputPropertyNotifyEvent(xRROutputPropertyNotifyEvent * from,
                             xRROutputPropertyNotifyEvent * to)
{
    to->type = from->type;
    to->subCode = from->subCode;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->window, to->window);
    cpswapl(from->output, to->output);
    cpswapl(from->atom, to->atom);
    cpswapl(from->timestamp, to->timestamp);
    to->state = from->state;
    /* pad1 */
    /* pad2 */
    /* pad3 */
    /* pad4 */
}

static void
SRRProviderChangeNotifyEvent(xRRProviderChangeNotifyEvent * from,
                         xRRProviderChangeNotifyEvent * to)
{
    to->type = from->type;
    to->subCode = from->subCode;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->timestamp, to->timestamp);
    cpswapl(from->window, to->window);
    cpswapl(from->provider, to->provider);
}

static void
SRRProviderPropertyNotifyEvent(xRRProviderPropertyNotifyEvent * from,
                               xRRProviderPropertyNotifyEvent * to)
{
    to->type = from->type;
    to->subCode = from->subCode;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->window, to->window);
    cpswapl(from->provider, to->provider);
    cpswapl(from->atom, to->atom);
    cpswapl(from->timestamp, to->timestamp);
    to->state = from->state;
    /* pad1 */
    /* pad2 */
    /* pad3 */
    /* pad4 */
}

static void
SRRResourceChangeNotifyEvent(xRRResourceChangeNotifyEvent * from,
                             xRRResourceChangeNotifyEvent * to)
{
    to->type = from->type;
    to->subCode = from->subCode;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->timestamp, to->timestamp);
    cpswapl(from->window, to->window);
}

static void
SRRNotifyEvent(xEvent *from, xEvent *to)
{
    switch (from->u.u.detail) {
    case RRNotify_CrtcChange:
        SRRCrtcChangeNotifyEvent((xRRCrtcChangeNotifyEvent *) from,
                                 (xRRCrtcChangeNotifyEvent *) to);
        break;
    case RRNotify_OutputChange:
        SRROutputChangeNotifyEvent((xRROutputChangeNotifyEvent *) from,
                                   (xRROutputChangeNotifyEvent *) to);
        break;
    case RRNotify_OutputProperty:
        SRROutputPropertyNotifyEvent((xRROutputPropertyNotifyEvent *) from,
                                     (xRROutputPropertyNotifyEvent *) to);
        break;
    case RRNotify_ProviderChange:
        SRRProviderChangeNotifyEvent((xRRProviderChangeNotifyEvent *) from,
                                   (xRRProviderChangeNotifyEvent *) to);
        break;
    case RRNotify_ProviderProperty:
        SRRProviderPropertyNotifyEvent((xRRProviderPropertyNotifyEvent *) from,
                                       (xRRProviderPropertyNotifyEvent *) to);
        break;
    case RRNotify_ResourceChange:
        SRRResourceChangeNotifyEvent((xRRResourceChangeNotifyEvent *) from,
                                   (xRRResourceChangeNotifyEvent *) to);
    default:
        break;
    }
}

static int RRGeneration;

Bool
RRInit(void)
{
    if (RRGeneration != serverGeneration) {
        if (!RRModeInit())
            return FALSE;
        if (!RRCrtcInit())
            return FALSE;
        if (!RROutputInit())
            return FALSE;
        if (!RRProviderInit())
            return FALSE;
        RRGeneration = serverGeneration;
    }
    if (!dixRegisterPrivateKey(&rrPrivKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    return TRUE;
}

Bool
RRScreenInit(ScreenPtr pScreen)
{
    rrScrPrivPtr pScrPriv;

    if (!RRInit())
        return FALSE;

    pScrPriv = (rrScrPrivPtr) calloc(1, sizeof(rrScrPrivRec));
    if (!pScrPriv)
        return FALSE;

    SetRRScreen(pScreen, pScrPriv);

    /*
     * Calling function best set these function vectors
     */
    pScrPriv->rrGetInfo = 0;
    pScrPriv->maxWidth = pScrPriv->minWidth = pScreen->width;
    pScrPriv->maxHeight = pScrPriv->minHeight = pScreen->height;

    pScrPriv->width = pScreen->width;
    pScrPriv->height = pScreen->height;
    pScrPriv->mmWidth = pScreen->mmWidth;
    pScrPriv->mmHeight = pScreen->mmHeight;
#if RANDR_12_INTERFACE
    pScrPriv->rrScreenSetSize = NULL;
    pScrPriv->rrCrtcSet = NULL;
    pScrPriv->rrCrtcSetGamma = NULL;
#endif
#if RANDR_10_INTERFACE
    pScrPriv->rrSetConfig = 0;
    pScrPriv->rotations = RR_Rotate_0;
    pScrPriv->reqWidth = pScreen->width;
    pScrPriv->reqHeight = pScreen->height;
    pScrPriv->nSizes = 0;
    pScrPriv->pSizes = NULL;
    pScrPriv->rotation = RR_Rotate_0;
    pScrPriv->rate = 0;
    pScrPriv->size = 0;
#endif

    /*
     * This value doesn't really matter -- any client must call
     * GetScreenInfo before reading it which will automatically update
     * the time
     */
    pScrPriv->lastSetTime = currentTime;
    pScrPriv->lastConfigTime = currentTime;

    wrap(pScrPriv, pScreen, CloseScreen, RRCloseScreen);

    pScreen->ConstrainCursorHarder = RRConstrainCursorHarder;
    pScreen->ReplaceScanoutPixmap = RRReplaceScanoutPixmap;
    pScrPriv->numOutputs = 0;
    pScrPriv->outputs = NULL;
    pScrPriv->numCrtcs = 0;
    pScrPriv->crtcs = NULL;

    RRMonitorInit(pScreen);

    RRNScreens += 1;            /* keep count of screens that implement randr */
    return TRUE;
}

 /*ARGSUSED*/ static int
RRFreeClient(void *data, XID id)
{
    RREventPtr pRREvent;
    WindowPtr pWin;
    RREventPtr *pHead, pCur, pPrev;

    pRREvent = (RREventPtr) data;
    pWin = pRREvent->window;
    dixLookupResourceByType((void **) &pHead, pWin->drawable.id,
                            RREventType, serverClient, DixDestroyAccess);
    if (pHead) {
        pPrev = 0;
        for (pCur = *pHead; pCur && pCur != pRREvent; pCur = pCur->next)
            pPrev = pCur;
        if (pCur) {
            if (pPrev)
                pPrev->next = pRREvent->next;
            else
                *pHead = pRREvent->next;
        }
    }
    free((void *) pRREvent);
    return 1;
}

 /*ARGSUSED*/ static int
RRFreeEvents(void *data, XID id)
{
    RREventPtr *pHead, pCur, pNext;

    pHead = (RREventPtr *) data;
    for (pCur = *pHead; pCur; pCur = pNext) {
        pNext = pCur->next;
        FreeResource(pCur->clientResource, RRClientType);
        free((void *) pCur);
    }
    free((void *) pHead);
    return 1;
}

void
RRExtensionInit(void)
{
    ExtensionEntry *extEntry;

    if (RRNScreens == 0)
        return;

    if (!dixRegisterPrivateKey(&RRClientPrivateKeyRec, PRIVATE_CLIENT,
                               sizeof(RRClientRec) +
                               screenInfo.numScreens * sizeof(RRTimesRec)))
        return;
    if (!AddCallback(&ClientStateCallback, RRClientCallback, 0))
        return;

    RRClientType = CreateNewResourceType(RRFreeClient, "RandRClient");
    if (!RRClientType)
        return;
    RREventType = CreateNewResourceType(RRFreeEvents, "RandREvent");
    if (!RREventType)
        return;
    extEntry = AddExtension(RANDR_NAME, RRNumberEvents, RRNumberErrors,
                            ProcRRDispatch, SProcRRDispatch,
                            NULL, StandardMinorOpcode);
    if (!extEntry)
        return;
    RRErrorBase = extEntry->errorBase;
    RREventBase = extEntry->eventBase;
    EventSwapVector[RREventBase + RRScreenChangeNotify] = (EventSwapPtr)
        SRRScreenChangeNotifyEvent;
    EventSwapVector[RREventBase + RRNotify] = (EventSwapPtr)
        SRRNotifyEvent;

    RRModeInitErrorValue();
    RRCrtcInitErrorValue();
    RROutputInitErrorValue();
    RRProviderInitErrorValue();
#ifdef PANORAMIX
    RRXineramaExtensionInit();
#endif
}

void
RRResourcesChanged(ScreenPtr pScreen)
{
    rrScrPriv(pScreen);
    pScrPriv->resourcesChanged = TRUE;

    RRSetChanged(pScreen);
}

static void
RRDeliverResourceEvent(ClientPtr client, WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    rrScrPriv(pScreen);

    xRRResourceChangeNotifyEvent re = {
        .type = RRNotify + RREventBase,
        .subCode = RRNotify_ResourceChange,
        .timestamp = pScrPriv->lastSetTime.milliseconds,
        .window = pWin->drawable.id
    };

    WriteEventsToClient(client, 1, (xEvent *) &re);
}

static int
TellChanged(WindowPtr pWin, void *value)
{
    RREventPtr *pHead, pRREvent;
    ClientPtr client;
    ScreenPtr pScreen = pWin->drawable.pScreen;
    ScreenPtr iter;
    rrScrPrivPtr pSlaveScrPriv;

    rrScrPriv(pScreen);
    int i;

    dixLookupResourceByType((void **) &pHead, pWin->drawable.id,
                            RREventType, serverClient, DixReadAccess);
    if (!pHead)
        return WT_WALKCHILDREN;

    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent->next) {
        client = pRREvent->client;
        if (client == serverClient || client->clientGone)
            continue;

        if (pRREvent->mask & RRScreenChangeNotifyMask)
            RRDeliverScreenEvent(client, pWin, pScreen);

        if (pRREvent->mask & RRCrtcChangeNotifyMask) {
            for (i = 0; i < pScrPriv->numCrtcs; i++) {
                RRCrtcPtr crtc = pScrPriv->crtcs[i];

                if (crtc->changed)
                    RRDeliverCrtcEvent(client, pWin, crtc);
            }

            xorg_list_for_each_entry(iter, &pScreen->output_slave_list, output_head) {
                pSlaveScrPriv = rrGetScrPriv(iter);
                for (i = 0; i < pSlaveScrPriv->numCrtcs; i++) {
                    RRCrtcPtr crtc = pSlaveScrPriv->crtcs[i];

                    if (crtc->changed)
                        RRDeliverCrtcEvent(client, pWin, crtc);
                }
            }
        }

        if (pRREvent->mask & RROutputChangeNotifyMask) {
            for (i = 0; i < pScrPriv->numOutputs; i++) {
                RROutputPtr output = pScrPriv->outputs[i];

                if (output->changed)
                    RRDeliverOutputEvent(client, pWin, output);
            }

            xorg_list_for_each_entry(iter, &pScreen->output_slave_list, output_head) {
                pSlaveScrPriv = rrGetScrPriv(iter);
                for (i = 0; i < pSlaveScrPriv->numOutputs; i++) {
                    RROutputPtr output = pSlaveScrPriv->outputs[i];

                    if (output->changed)
                        RRDeliverOutputEvent(client, pWin, output);
                }
            }
        }

        if (pRREvent->mask & RRProviderChangeNotifyMask) {
            xorg_list_for_each_entry(iter, &pScreen->output_slave_list, output_head) {
                pSlaveScrPriv = rrGetScrPriv(iter);
                if (pSlaveScrPriv->provider->changed)
                    RRDeliverProviderEvent(client, pWin, pSlaveScrPriv->provider);
            }
            xorg_list_for_each_entry(iter, &pScreen->offload_slave_list, offload_head) {
                pSlaveScrPriv = rrGetScrPriv(iter);
                if (pSlaveScrPriv->provider->changed)
                    RRDeliverProviderEvent(client, pWin, pSlaveScrPriv->provider);
            }
            xorg_list_for_each_entry(iter, &pScreen->unattached_list, unattached_head) {
                pSlaveScrPriv = rrGetScrPriv(iter);
                if (pSlaveScrPriv->provider->changed)
                    RRDeliverProviderEvent(client, pWin, pSlaveScrPriv->provider);
            }
        }

        if (pRREvent->mask & RRResourceChangeNotifyMask) {
            if (pScrPriv->resourcesChanged) {
                RRDeliverResourceEvent(client, pWin);
            }
        }
    }
    return WT_WALKCHILDREN;
}

void
RRSetChanged(ScreenPtr pScreen)
{
    /* set changed bits on the master screen only */
    ScreenPtr master;
    rrScrPriv(pScreen);
    rrScrPrivPtr mastersp;

    if (pScreen->isGPU) {
        master = pScreen->current_master;
        if (!master)
            return;
        mastersp = rrGetScrPriv(master);
    }
    else {
        master = pScreen;
        mastersp = pScrPriv;
    }

    mastersp->changed = TRUE;
}

/*
 * Something changed; send events and adjust pointer position
 */
void
RRTellChanged(ScreenPtr pScreen)
{
    ScreenPtr master;
    rrScrPriv(pScreen);
    rrScrPrivPtr mastersp;
    int i;
    ScreenPtr iter;
    rrScrPrivPtr pSlaveScrPriv;

    if (pScreen->isGPU) {
        master = pScreen->current_master;
        mastersp = rrGetScrPriv(master);
    }
    else {
        master = pScreen;
        mastersp = pScrPriv;
    }

    if (mastersp->changed) {
        UpdateCurrentTimeIf();
        if (mastersp->configChanged) {
            mastersp->lastConfigTime = currentTime;
            mastersp->configChanged = FALSE;
        }
        pScrPriv->changed = FALSE;
        mastersp->changed = FALSE;

        WalkTree(master, TellChanged, (void *) master);

        mastersp->resourcesChanged = FALSE;

        for (i = 0; i < pScrPriv->numOutputs; i++)
            pScrPriv->outputs[i]->changed = FALSE;
        for (i = 0; i < pScrPriv->numCrtcs; i++)
            pScrPriv->crtcs[i]->changed = FALSE;

        xorg_list_for_each_entry(iter, &master->output_slave_list, output_head) {
            pSlaveScrPriv = rrGetScrPriv(iter);
            pSlaveScrPriv->provider->changed = FALSE;
            for (i = 0; i < pSlaveScrPriv->numOutputs; i++)
                pSlaveScrPriv->outputs[i]->changed = FALSE;
            for (i = 0; i < pSlaveScrPriv->numCrtcs; i++)
                pSlaveScrPriv->crtcs[i]->changed = FALSE;
        }
        xorg_list_for_each_entry(iter, &master->offload_slave_list, offload_head) {
            pSlaveScrPriv = rrGetScrPriv(iter);
            pSlaveScrPriv->provider->changed = FALSE;
        }
        xorg_list_for_each_entry(iter, &master->unattached_list, unattached_head) {
            pSlaveScrPriv = rrGetScrPriv(iter);
            pSlaveScrPriv->provider->changed = FALSE;
        }

        if (mastersp->layoutChanged) {
            pScrPriv->layoutChanged = FALSE;
            RRPointerScreenConfigured(master);
            RRSendConfigNotify(master);
        }
    }
}

/*
 * Return the first output which is connected to an active CRTC
 * Used in emulating 1.0 behaviour
 */
RROutputPtr
RRFirstOutput(ScreenPtr pScreen)
{
    rrScrPriv(pScreen);
    RROutputPtr output;
    int i, j;

    if (!pScrPriv)
        return NULL;

    if (pScrPriv->primaryOutput && pScrPriv->primaryOutput->crtc)
        return pScrPriv->primaryOutput;

    for (i = 0; i < pScrPriv->numCrtcs; i++) {
        RRCrtcPtr crtc = pScrPriv->crtcs[i];

        for (j = 0; j < pScrPriv->numOutputs; j++) {
            output = pScrPriv->outputs[j];
            if (output->crtc == crtc)
                return output;
        }
    }
    return NULL;
}

CARD16
RRVerticalRefresh(xRRModeInfo * mode)
{
    CARD32 refresh;
    CARD32 dots = mode->hTotal * mode->vTotal;

    if (!dots)
        return 0;
    refresh = (mode->dotClock + dots / 2) / dots;
    if (refresh > 0xffff)
        refresh = 0xffff;
    return (CARD16) refresh;
}

static int
ProcRRDispatch(ClientPtr client)
{
    REQUEST(xReq);
    if (stuff->data >= RRNumberRequests || !ProcRandrVector[stuff->data])
        return BadRequest;
    return (*ProcRandrVector[stuff->data]) (client);
}

static int
SProcRRDispatch(ClientPtr client)
{
    REQUEST(xReq);
    if (stuff->data >= RRNumberRequests || !SProcRandrVector[stuff->data])
        return BadRequest;
    return (*SProcRandrVector[stuff->data]) (client);
}
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d101 2
d337 2
@


1.10
log
@Update to xserver 1.14.5
@
text
@d63 1
a63 1
RRClientCallback(CallbackListPtr *list, pointer closure, pointer data)
d341 1
a341 1
RRFreeClient(pointer data, XID id)
d349 1
a349 1
    dixLookupResourceByType((pointer *) &pHead, pWin->drawable.id,
d362 1
a362 1
    free((pointer) pRREvent);
d367 1
a367 1
RRFreeEvents(pointer data, XID id)
d375 1
a375 1
        free((pointer) pCur);
d377 1
a377 1
    free((pointer) pHead);
d450 1
a450 1
TellChanged(WindowPtr pWin, pointer value)
d461 1
a461 1
    dixLookupResourceByType((pointer *) &pHead, pWin->drawable.id,
d592 1
a592 1
        WalkTree(master, TellChanged, (pointer) master);
d682 1
a682 1
    if (stuff->data >= RRNumberRequests || !ProcRandrVector[stuff->data])
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d423 26
d455 2
d481 10
d500 34
d539 22
d571 2
d583 1
a583 1
    if (pScrPriv->changed) {
d591 1
d593 3
d600 18
@


1.8
log
@Update to xserver 1.12.3.
@
text
@d33 1
d87 1
a87 1
RRCloseScreen(int i, ScreenPtr pScreen)
d98 3
d105 1
a105 1
    return (*pScreen->CloseScreen) (i, pScreen);
d183 41
d239 11
d267 2
d330 1
a330 1

d417 1
a417 1

d473 1
d475 1
d478 9
d489 3
a491 3
        if (pScrPriv->configChanged) {
            pScrPriv->lastConfigTime = currentTime;
            pScrPriv->configChanged = FALSE;
d494 2
a495 1
        WalkTree(pScreen, TellChanged, (pointer) pScreen);
d500 1
a500 1
        if (pScrPriv->layoutChanged) {
d502 2
a503 2
            RRPointerScreenConfigured(pScreen);
            RRSendConfigNotify(pScreen);
d518 3
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d419 1
a419 1
        UpdateCurrentTime();
@


1.6
log
@Update to xserver 1.11.2
@
text
@d40 1
a40 1
static int	RRNScreens;
d51 2
a52 2
static int ProcRRDispatch (ClientPtr pClient);
static int SProcRRDispatch (ClientPtr pClient);
d54 3
a56 3
int	RREventBase;
int	RRErrorBase;
RESTYPE RRClientType, RREventType; /* resource types for event masks */
d62 1
a62 3
RRClientCallback (CallbackListPtr	*list,
		  pointer		closure,
		  pointer		data)
d64 3
a66 2
    NewClientInfoRec	*clientinfo = (NewClientInfoRec *) data;
    ClientPtr		pClient = clientinfo->client;
d68 2
a69 2
    RRTimesPtr		pTimes = (RRTimesPtr) (pRRClient + 1);
    int			i;
d73 9
a81 10
    for (i = 0; i < screenInfo.numScreens; i++)
    {
	ScreenPtr   pScreen = screenInfo.screens[i];
	rrScrPriv(pScreen);

	if (pScrPriv)
	{
	    pTimes[i].setTime = pScrPriv->lastSetTime;
	    pTimes[i].configTime = pScrPriv->lastConfigTime;
	}
d86 1
a86 1
RRCloseScreen (int i, ScreenPtr pScreen)
d89 1
a89 1
    int		    j;
d91 1
a91 1
    unwrap (pScrPriv, pScreen, CloseScreen);
d93 1
a93 1
	RRCrtcDestroy (pScrPriv->crtcs[j]);
d95 2
a96 2
	RROutputDestroy (pScrPriv->outputs[j]);
    
d100 2
a101 2
    RRNScreens -= 1;	/* ok, one fewer screen with RandR running */
    return (*pScreen->CloseScreen) (i, pScreen);    
d105 2
a106 2
SRRScreenChangeNotifyEvent(xRRScreenChangeNotifyEvent *from,
			   xRRScreenChangeNotifyEvent *to)
d124 2
a125 2
SRRCrtcChangeNotifyEvent(xRRCrtcChangeNotifyEvent *from,
			 xRRCrtcChangeNotifyEvent *to)
d143 2
a144 2
SRROutputChangeNotifyEvent(xRROutputChangeNotifyEvent *from,
			   xRROutputChangeNotifyEvent *to)
d161 2
a162 2
SRROutputPropertyNotifyEvent(xRROutputPropertyNotifyEvent *from,
			     xRROutputPropertyNotifyEvent *to)
d179 1
a179 2
SRRNotifyEvent (xEvent *from,
		xEvent *to)
d183 3
a185 3
	SRRCrtcChangeNotifyEvent ((xRRCrtcChangeNotifyEvent *) from,
				  (xRRCrtcChangeNotifyEvent *) to);
	break;
d187 3
a189 3
	SRROutputChangeNotifyEvent ((xRROutputChangeNotifyEvent *) from,
				    (xRROutputChangeNotifyEvent *) to);
	break;
d191 3
a193 3
	SRROutputPropertyNotifyEvent ((xRROutputPropertyNotifyEvent *) from,
				      (xRROutputPropertyNotifyEvent *) to);
	break;
d195 1
a195 1
	break;
d201 2
a202 1
Bool RRInit (void)
d204 8
a211 9
    if (RRGeneration != serverGeneration)
    {
	if (!RRModeInit ())
	    return FALSE;
	if (!RRCrtcInit ())
	    return FALSE;
	if (!RROutputInit ())
	    return FALSE;
	RRGeneration = serverGeneration;
d214 1
a214 1
	return FALSE;
d219 2
a220 1
Bool RRScreenInit(ScreenPtr pScreen)
d222 1
a222 1
    rrScrPrivPtr   pScrPriv;
d224 2
a225 2
    if (!RRInit ())
	return FALSE;
d227 1
a227 1
    pScrPriv = (rrScrPrivPtr) calloc(1, sizeof (rrScrPrivRec));
d229 1
a229 1
	return FALSE;
d239 1
a239 1
    
d249 1
a249 1
#if RANDR_10_INTERFACE    
d260 1
a260 1
    
d268 2
a269 2
    
    wrap (pScrPriv, pScreen, CloseScreen, RRCloseScreen);
d277 2
a278 2
    
    RRNScreens += 1;	/* keep count of screens that implement randr */
d282 2
a283 3
/*ARGSUSED*/
static int
RRFreeClient (pointer data, XID id)
d285 3
a287 3
    RREventPtr   pRREvent;
    WindowPtr	    pWin;
    RREventPtr   *pHead, pCur, pPrev;
d291 2
a292 2
    dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
			    RREventType, serverClient, DixDestroyAccess);
d294 9
a302 10
	pPrev = 0;
	for (pCur = *pHead; pCur && pCur != pRREvent; pCur=pCur->next)
	    pPrev = pCur;
	if (pCur)
	{
	    if (pPrev)
	    	pPrev->next = pRREvent->next;
	    else
	    	*pHead = pRREvent->next;
	}
d308 2
a309 3
/*ARGSUSED*/
static int
RRFreeEvents (pointer data, XID id)
d311 1
a311 1
    RREventPtr   *pHead, pCur, pNext;
d315 3
a317 3
	pNext = pCur->next;
	FreeResource (pCur->clientResource, RRClientType);
	free((pointer) pCur);
d324 1
a324 1
RRExtensionInit (void)
d328 2
a329 1
    if (RRNScreens == 0) return;
d332 5
a336 5
			       sizeof (RRClientRec) +
			       screenInfo.numScreens * sizeof (RRTimesRec)))
	return;
    if (!AddCallback (&ClientStateCallback, RRClientCallback, 0))
	return;
d340 1
a340 1
	return;
d343 4
a346 4
	return;
    extEntry = AddExtension (RANDR_NAME, RRNumberEvents, RRNumberErrors,
			     ProcRRDispatch, SProcRRDispatch,
			     NULL, StandardMinorOpcode);
d348 1
a348 1
	return;
d351 2
a352 2
    EventSwapVector[RREventBase + RRScreenChangeNotify] = (EventSwapPtr) 
	SRRScreenChangeNotifyEvent;
d354 1
a354 1
	SRRNotifyEvent;
d366 1
a366 1
TellChanged (WindowPtr pWin, pointer value)
d368 4
a371 3
    RREventPtr			*pHead, pRREvent;
    ClientPtr			client;
    ScreenPtr			pScreen = pWin->drawable.pScreen;
d373 1
a373 1
    int				i;
d375 2
a376 2
    dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
			    RREventType, serverClient, DixReadAccess);
d378 1
a378 1
	return WT_WALKCHILDREN;
d380 25
a404 28
    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent->next) 
    {
	client = pRREvent->client;
	if (client == serverClient || client->clientGone)
	    continue;

	if (pRREvent->mask & RRScreenChangeNotifyMask)
	    RRDeliverScreenEvent (client, pWin, pScreen);
	
	if (pRREvent->mask & RRCrtcChangeNotifyMask)
	{
	    for (i = 0; i < pScrPriv->numCrtcs; i++)
	    {
		RRCrtcPtr   crtc = pScrPriv->crtcs[i];
		if (crtc->changed)
		    RRDeliverCrtcEvent (client, pWin, crtc);
	    }
	}
	
	if (pRREvent->mask & RROutputChangeNotifyMask)
	{
	    for (i = 0; i < pScrPriv->numOutputs; i++)
	    {
		RROutputPtr   output = pScrPriv->outputs[i];
		if (output->changed)
		    RRDeliverOutputEvent (client, pWin, output);
	    }
	}
d413 1
a413 1
RRTellChanged (ScreenPtr pScreen)
d415 1
a415 1
    rrScrPriv (pScreen);
d417 18
a434 21
    
    if (pScrPriv->changed)
    {
	UpdateCurrentTime ();
	if (pScrPriv->configChanged)
	{
	    pScrPriv->lastConfigTime = currentTime;
	    pScrPriv->configChanged = FALSE;
	}
	pScrPriv->changed = FALSE;
	WalkTree (pScreen, TellChanged, (pointer) pScreen);
	for (i = 0; i < pScrPriv->numOutputs; i++)
	    pScrPriv->outputs[i]->changed = FALSE;
	for (i = 0; i < pScrPriv->numCrtcs; i++)
	    pScrPriv->crtcs[i]->changed = FALSE;
	if (pScrPriv->layoutChanged)
	{
	    pScrPriv->layoutChanged = FALSE;
	    RRPointerScreenConfigured (pScreen);
	    RRSendConfigNotify (pScreen);
	}
d443 1
a443 1
RRFirstOutput (ScreenPtr pScreen)
d446 3
a448 3
    RROutputPtr		    output;
    int	i, j;
    
d450 4
a453 1
	return pScrPriv->primaryOutput;
d455 5
a459 9
    for (i = 0; i < pScrPriv->numCrtcs; i++)
    {
	RRCrtcPtr   crtc = pScrPriv->crtcs[i];
	for (j = 0; j < pScrPriv->numOutputs; j++)
	{
	    output = pScrPriv->outputs[j];
	    if (output->crtc == crtc)
		return output;
	}
d465 1
a465 1
RRVerticalRefresh (xRRModeInfo *mode)
d467 3
a469 2
    CARD32  refresh;
    CARD32  dots = mode->hTotal * mode->vTotal;
d471 2
a472 2
	return 0;
    refresh = (mode->dotClock + dots/2) / dots;
d474 1
a474 1
	refresh = 0xffff;
d479 1
a479 1
ProcRRDispatch (ClientPtr client)
d483 1
a483 1
	return BadRequest;
d488 1
a488 1
SProcRRDispatch (ClientPtr client)
d492 1
a492 1
	return BadRequest;
a494 1

@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d273 2
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d57 1
a57 2
static int RRClientPrivateKeyIndex;
DevPrivateKey RRClientPrivateKey = &RRClientPrivateKeyIndex;
d59 1
a59 2
static int rrPrivKeyIndex;
DevPrivateKey rrPrivKey = &rrPrivKeyIndex;
d99 3
a101 3
    xfree (pScrPriv->crtcs);
    xfree (pScrPriv->outputs);
    xfree (pScrPriv);
d216 3
d229 1
a229 1
    pScrPriv = (rrScrPrivPtr) xcalloc (1, sizeof (rrScrPrivRec));
d306 1
a306 1
    xfree ((pointer) pRREvent);
d320 1
a320 1
	xfree ((pointer) pCur);
d322 1
a322 1
    xfree ((pointer) pHead);
d333 3
a335 3
    if (!dixRequestPrivate(RRClientPrivateKey,
				sizeof (RRClientRec) +
				screenInfo.numScreens * sizeof (RRTimesRec)))
d357 5
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a27 2
#define NEED_REPLIES
#define NEED_EVENTS
d101 2
d291 2
a292 1
    pHead = (RREventPtr *) LookupIDByType(pWin->drawable.id, RREventType);
d339 1
a339 1
    RRClientType = CreateNewResourceType(RRFreeClient);
d342 1
a342 1
    RREventType = CreateNewResourceType(RRFreeEvents);
d370 2
a371 1
    pHead = (RREventPtr *) LookupIDByType (pWin->drawable.id, RREventType);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d59 2
a60 1
DevPrivateKey RRClientPrivateKey = &RRClientPrivateKey;
d62 2
a63 1
DevPrivateKey rrPrivKey = &rrPrivKey;
a90 5
static void
RRResetProc (ExtensionEntry *extEntry)
{
}
    
d120 1
a124 1
    cpswaps(from->subpixelOrder, to->subpixelOrder);
a137 1
    cpswapl(from->window, to->window);
d139 1
d160 2
d175 5
d346 1
a346 1
			     RRResetProc, StandardMinorOpcode);
d448 3
@


1.1
log
@Initial revision
@
text
@d2 3
a4 3
 *
 * Copyright © 2000, Compaq Computer Corporation, 
 * Copyright © 2002, Hewlett Packard, Inc.
d8 7
a14 7
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Compaq or HP not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.  HP makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
d16 7
a22 6
 * HP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL HP
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d24 2
a25 1
 * Author:  Jim Gettys, HP Labs, Hewlett-Packard, Inc.
a27 1

a33 13
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "resource.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "extnsionst.h"
#include "servermd.h"
#include <X11/extensions/randr.h>
#include <X11/extensions/randrproto.h>
a34 5
#ifdef RENDER
#include <X11/extensions/render.h> 	/* we share subpixel order information */
#include "picturestr.h"
#endif
#include <X11/Xfuncproto.h>
d42 1
a42 7
int	RRGeneration;
int	RRNScreens;

static int ProcRRQueryVersion (ClientPtr pClient);
static int ProcRRDispatch (ClientPtr pClient);
static int SProcRRDispatch (ClientPtr pClient);
static int SProcRRQueryVersion (ClientPtr pClient);
d53 2
a54 28
#if 0
static CARD8	RRReqCode;
static int	RRErrBase;
#endif
static int	RREventBase;
static RESTYPE ClientType, EventType; /* resource types for event masks */
static int	RRClientPrivateIndex;

typedef struct _RRTimes {
    TimeStamp	setTime;
    TimeStamp	configTime;
} RRTimesRec, *RRTimesPtr;

typedef struct _RRClient {
    int		major_version;
    int		minor_version;
/*  RRTimesRec	times[0]; */
} RRClientRec, *RRClientPtr;

/*
 * each window has a list of clients requesting
 * RRNotify events.  Each client has a resource
 * for each window it selects RRNotify input for,
 * this resource is used to delete the RRNotifyRec
 * entry from the per-window queue.
 */

typedef struct _RREvent *RREventPtr;
d56 4
a59 7
typedef struct _RREvent {
    RREventPtr  next;
    ClientPtr	client;
    WindowPtr	window;
    XID		clientResource;
    int		mask;
} RREventRec;
d61 1
a61 13
int	rrPrivIndex = -1;

#define GetRRClient(pClient)    ((RRClientPtr) (pClient)->devPrivates[RRClientPrivateIndex].ptr)
#define rrClientPriv(pClient)	RRClientPtr pRRClient = GetRRClient(pClient)

static Bool
RRClientKnowsRates (ClientPtr	pClient)
{
    rrClientPriv(pClient);

    return (pRRClient->major_version > 1 ||
	    (pRRClient->major_version == 1 && pRRClient->minor_version >= 1));
}
d98 1
d101 5
a105 2
    if (pScrPriv->pSizes)
	xfree (pScrPriv->pSizes);
d130 51
a180 1
Bool RRScreenInit(ScreenPtr pScreen)
d182 19
a200 1
    rrScrPrivPtr   pScrPriv;
d202 2
d206 5
a210 1
	if ((rrPrivIndex = AllocateScreenPrivateIndex()) < 0)
d214 6
d221 4
a224 1
    pScrPriv = (rrScrPrivPtr) xalloc (sizeof (rrScrPrivRec));
d233 14
d248 10
a257 1
    pScrPriv->rrGetInfo = 0;
d268 4
a271 8
    pScrPriv->rotations = RR_Rotate_0;
    
    pScrPriv->nSizes = 0;
    pScrPriv->nSizesInUse = 0;
    pScrPriv->pSizes = 0;
    
    pScrPriv->rotation = RR_Rotate_0;
    pScrPriv->size = -1;
d287 1
a287 1
    pHead = (RREventPtr *) LookupIDByType(pWin->drawable.id, EventType);
d313 1
a313 1
	FreeResource (pCur->clientResource, ClientType);
d327 1
a327 2
    RRClientPrivateIndex = AllocateClientPrivateIndex ();
    if (!AllocateClientPrivate (RRClientPrivateIndex,
d334 2
a335 2
    ClientType = CreateNewResourceType(RRFreeClient);
    if (!ClientType)
d337 2
a338 2
    EventType = CreateNewResourceType(RRFreeEvents);
    if (!EventType)
d345 1
a345 4
#if 0
    RRReqCode = (CARD8) extEntry->base;
    RRErrBase = extEntry->errorBase;
#endif
d348 7
a354 1
      SRRScreenChangeNotifyEvent;
a355 3
    return;
}
		
a360 1
    xRRScreenChangeNotifyEvent	se;
d363 1
a363 2
    RRScreenSizePtr		pSize;
    WindowPtr			pRoot = WindowTable[pScreen->myNum];
d365 1
a365 1
    pHead = (RREventPtr *) LookupIDByType (pWin->drawable.id, EventType);
a368 32
    se.type = RRScreenChangeNotify + RREventBase;
    se.rotation = (CARD8) pScrPriv->rotation;
    se.timestamp = pScrPriv->lastSetTime.milliseconds;
    se.configTimestamp = pScrPriv->lastConfigTime.milliseconds;
    se.root =  pRoot->drawable.id;
    se.window = pWin->drawable.id;
#ifdef RENDER
    se.subpixelOrder = PictureGetSubpixelOrder (pScreen);
#else
    se.subpixelOrder = SubPixelUnknown;
#endif
    if (pScrPriv->size >= 0)
    {
	pSize = &pScrPriv->pSizes[pScrPriv->size];
	se.sizeID = pSize->id;
	se.widthInPixels = pSize->width;
	se.heightInPixels = pSize->height;
	se.widthInMillimeters = pSize->mmWidth;
	se.heightInMillimeters = pSize->mmHeight;
    }
    else
    {
	/*
	 * This "shouldn't happen", but a broken DDX can
	 * forget to set the current configuration on GetInfo
	 */
	se.sizeID = 0xffff;
	se.widthInPixels = 0;
	se.heightInPixels = 0;
	se.widthInMillimeters = 0;
	se.heightInMillimeters = 0;
    }    
a373 6
	se.sequenceNumber = client->sequence;
	if(pRREvent->mask & RRScreenChangeNotifyMask)
	  WriteEventsToClient (client, 1, (xEvent *) &se);
    }
    return WT_WALKCHILDREN;
}
d375 4
a378 218
static Bool
RRGetInfo (ScreenPtr pScreen)
{
    rrScrPriv (pScreen);
    int		    i, j, k, l;
    Bool	    changed;
    Rotation	    rotations;
    RRScreenSizePtr pSize;
    RRScreenRatePtr pRate;

    for (i = 0; i < pScrPriv->nSizes; i++)
    {
	pSize = &pScrPriv->pSizes[i];
	pSize->oldReferenced = pSize->referenced;
	pSize->referenced = FALSE;
	for (k = 0; k < pSize->nRates; k++)
	{
	    pRate = &pSize->pRates[k];
	    pRate->oldReferenced = pRate->referenced;
	    pRate->referenced = FALSE;
	}
    }
    if (!(*pScrPriv->rrGetInfo) (pScreen, &rotations))
	return FALSE;

    changed = FALSE;

    /*
     * Check whether anything changed and simultaneously generate
     * the protocol id values for the objects
     */
    if (rotations != pScrPriv->rotations)
    {
	pScrPriv->rotations = rotations;
	changed = TRUE;
    }

    j = 0;
    for (i = 0; i < pScrPriv->nSizes; i++)
    {
	pSize = &pScrPriv->pSizes[i];
	if (pSize->oldReferenced != pSize->referenced)
	    changed = TRUE;
	if (pSize->referenced)
	    pSize->id = j++;
	l = 0;
	for (k = 0; k < pSize->nRates; k++)
	{
	    pRate = &pSize->pRates[k];
	    if (pRate->oldReferenced != pRate->referenced)
		changed = TRUE;
	    if (pRate->referenced)
		l++;
	}
	pSize->nRatesInUse = l;
    }
    pScrPriv->nSizesInUse = j;
    if (changed)
    {
	UpdateCurrentTime ();
	pScrPriv->lastConfigTime = currentTime;
	WalkTree (pScreen, TellChanged, (pointer) pScreen);
    }
    return TRUE;
}

static void
RRSendConfigNotify (ScreenPtr pScreen)
{
    WindowPtr	pWin = WindowTable[pScreen->myNum];
    xEvent	event;

    event.u.u.type = ConfigureNotify;
    event.u.configureNotify.window = pWin->drawable.id;
    event.u.configureNotify.aboveSibling = None;
    event.u.configureNotify.x = 0;
    event.u.configureNotify.y = 0;

    /* XXX xinerama stuff ? */
    
    event.u.configureNotify.width = pWin->drawable.width;
    event.u.configureNotify.height = pWin->drawable.height;
    event.u.configureNotify.borderWidth = wBorderWidth (pWin);
    event.u.configureNotify.override = pWin->overrideRedirect;
    DeliverEvents(pWin, &event, 1, NullWindow);
}

static int
ProcRRQueryVersion (ClientPtr client)
{
    xRRQueryVersionReply rep;
    register int n;
    REQUEST(xRRQueryVersionReq);
    rrClientPriv(client);

    REQUEST_SIZE_MATCH(xRRQueryVersionReq);
    pRRClient->major_version = stuff->majorVersion;
    pRRClient->minor_version = stuff->minorVersion;
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = RANDR_MAJOR;
    rep.minorVersion = RANDR_MINOR;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.majorVersion, n);
	swapl(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xRRQueryVersionReply), (char *)&rep);
    return (client->noClientException);
}


extern char	*ConnectionInfo;

static int padlength[4] = {0, 3, 2, 1};

static void
RREditConnectionInfo (ScreenPtr pScreen)
{
    xConnSetup	    *connSetup;
    char	    *vendor;
    xPixmapFormat   *formats;
    xWindowRoot	    *root;
    xDepth	    *depth;
    xVisualType	    *visual;
    int		    screen = 0;
    int		    d;

    connSetup = (xConnSetup *) ConnectionInfo;
    vendor = (char *) connSetup + sizeof (xConnSetup);
    formats = (xPixmapFormat *) ((char *) vendor +
				 connSetup->nbytesVendor +
				 padlength[connSetup->nbytesVendor & 3]);
    root = (xWindowRoot *) ((char *) formats +
			    sizeof (xPixmapFormat) * screenInfo.numPixmapFormats);
    while (screen != pScreen->myNum)
    {
	depth = (xDepth *) ((char *) root + 
			    sizeof (xWindowRoot));
	for (d = 0; d < root->nDepths; d++)
	{
	    visual = (xVisualType *) ((char *) depth +
				      sizeof (xDepth));
	    depth = (xDepth *) ((char *) visual +
				depth->nVisuals * sizeof (xVisualType));
	}
	root = (xWindowRoot *) ((char *) depth);
	screen++;
    }
    root->pixWidth = pScreen->width;
    root->pixHeight = pScreen->height;
    root->mmWidth = pScreen->mmWidth;
    root->mmHeight = pScreen->mmHeight;
}

static int
ProcRRGetScreenInfo (ClientPtr client)
{
    REQUEST(xRRGetScreenInfoReq);
    xRRGetScreenInfoReply   rep;
    WindowPtr	    	    pWin;
    int			    n;
    ScreenPtr		    pScreen;
    rrScrPrivPtr	    pScrPriv;
    CARD8		    *extra;
    unsigned long	    extraLen;

    REQUEST_SIZE_MATCH(xRRGetScreenInfoReq);
    pWin = (WindowPtr)SecurityLookupWindow(stuff->window, client,
					   SecurityReadAccess);

    if (!pWin)
	return BadWindow;

    pScreen = pWin->drawable.pScreen;
    pScrPriv = rrGetScrPriv(pScreen);
    rep.pad = 0;
    if (!pScrPriv)
    {
	rep.type = X_Reply;
	rep.setOfRotations = RR_Rotate_0;;
	rep.sequenceNumber = client->sequence;
	rep.length = 0;
	rep.root = WindowTable[pWin->drawable.pScreen->myNum]->drawable.id;
	rep.timestamp = currentTime.milliseconds;
	rep.configTimestamp = currentTime.milliseconds;
	rep.nSizes = 0;
	rep.sizeID = 0;
	rep.rotation = RR_Rotate_0;
	rep.rate = 0;
	rep.nrateEnts = 0;
	extra = 0;
	extraLen = 0;
    }
    else
    {
	int			i, j;
	xScreenSizes		*size;
	CARD16			*rates;
	CARD8			*data8;
	Bool			has_rate = RRClientKnowsRates (client);
    
	RRGetInfo (pScreen);

	rep.type = X_Reply;
	rep.setOfRotations = pScrPriv->rotations;
	rep.sequenceNumber = client->sequence;
	rep.length = 0;
	rep.root = WindowTable[pWin->drawable.pScreen->myNum]->drawable.id;
	rep.timestamp = pScrPriv->lastSetTime.milliseconds;
	rep.configTimestamp = pScrPriv->lastConfigTime.milliseconds;
	rep.rotation = pScrPriv->rotation;
	rep.nSizes = pScrPriv->nSizesInUse;
	rep.rate = pScrPriv->rate;
        rep.nrateEnts = 0;
	if (has_rate)
d380 1
a380 1
	    for (i = 0; i < pScrPriv->nSizes; i++)
d382 3
a384 5
		RRScreenSizePtr pSize = &pScrPriv->pSizes[i];
		if (pSize->referenced)
		{
		    rep.nrateEnts += (1 + pSize->nRatesInUse);
		}
d387 2
a388 18

	if (pScrPriv->size >= 0)
	    rep.sizeID = pScrPriv->pSizes[pScrPriv->size].id;
	else
	    return BadImplementation;

	extraLen = (rep.nSizes * sizeof (xScreenSizes) +
		    rep.nrateEnts * sizeof (CARD16));

	extra = (CARD8 *) xalloc (extraLen);
	if (!extra)
	    return BadAlloc;
	/*
	 * First comes the size information
	 */
	size = (xScreenSizes *) extra;
	rates = (CARD16 *) (size + rep.nSizes);
	for (i = 0; i < pScrPriv->nSizes; i++)
d390 1
a390 2
	    RRScreenSizePtr pSize = &pScrPriv->pSizes[i];
	    if (pSize->referenced)
d392 3
a394 34
		size->widthInPixels = pSize->width;
		size->heightInPixels = pSize->height;
		size->widthInMillimeters = pSize->mmWidth;
		size->heightInMillimeters = pSize->mmHeight;
		if (client->swapped)
		{
		    swaps (&size->widthInPixels, n);
		    swaps (&size->heightInPixels, n);
		    swaps (&size->widthInMillimeters, n);
		    swaps (&size->heightInMillimeters, n);
		}
		size++;
		if (has_rate)
		{
		    *rates = pSize->nRatesInUse;
		    if (client->swapped)
		    {
			swaps (rates, n);
		    }
		    rates++;
		    for (j = 0; j < pSize->nRates; j++)
		    {
			RRScreenRatePtr	pRate = &pSize->pRates[j];
			if (pRate->referenced)
			{
			    *rates = pRate->rate;
			    if (client->swapped)
			    {
				swaps (rates, n);
			    }
			    rates++;
			}
		    }
		}
a396 6
	data8 = (CARD8 *) rates;

	if (data8 - (CARD8 *) extra != extraLen)
	    FatalError ("RRGetScreenInfo bad extra len %ld != %ld\n",
			(unsigned long)(data8 - (CARD8 *) extra), extraLen);
	rep.length =  (extraLen + 3) >> 2;
d398 1
a398 17
    if (client->swapped) {
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.timestamp, n);
	swaps(&rep.rotation, n);
	swaps(&rep.nSizes, n);
	swaps(&rep.sizeID, n);
	swaps(&rep.rate, n);
	swaps(&rep.nrateEnts, n);
    }
    WriteToClient(client, sizeof(xRRGetScreenInfoReply), (char *)&rep);
    if (extraLen)
    {
	WriteToClient (client, extraLen, (char *) extra);
	xfree (extra);
    }
    return (client->noClientException);
d401 5
a405 2
static int
ProcRRSetScreenConfig (ClientPtr client)
d407 2
a408 27
    REQUEST(xRRSetScreenConfigReq);
    xRRSetScreenConfigReply rep;
    DrawablePtr		    pDraw;
    int			    n;
    ScreenPtr		    pScreen;
    rrScrPrivPtr	    pScrPriv;
    TimeStamp		    configTime;
    TimeStamp		    time;
    RRScreenSizePtr	    pSize;
    int			    i;
    Rotation		    rotation;
    int			    rate;
    short		    oldWidth, oldHeight;
    Bool		    has_rate;

    UpdateCurrentTime ();

    if (RRClientKnowsRates (client))
    {
	REQUEST_SIZE_MATCH (xRRSetScreenConfigReq);
	has_rate = TRUE;
    }
    else
    {
	REQUEST_SIZE_MATCH (xRR1_0SetScreenConfigReq);
	has_rate = FALSE;
    }
d410 1
a410 14
    SECURITY_VERIFY_DRAWABLE(pDraw, stuff->drawable, client,
			     SecurityWriteAccess);

    pScreen = pDraw->pScreen;

    pScrPriv = rrGetScrPriv(pScreen);
    
    time = ClientTimeToServerTime(stuff->timestamp);
    configTime = ClientTimeToServerTime(stuff->configTimestamp);
    
    oldWidth = pScreen->width;
    oldHeight = pScreen->height;
    
    if (!pScrPriv)
d412 2
a413 26
	time = currentTime;
	rep.status = RRSetConfigFailed;
	goto sendReply;
    }
    if (!RRGetInfo (pScreen))
	return BadAlloc;
    
    /*
     * if the client's config timestamp is not the same as the last config
     * timestamp, then the config information isn't up-to-date and
     * can't even be validated
     */
    if (CompareTimeStamps (configTime, pScrPriv->lastConfigTime) != 0)
    {
	rep.status = RRSetConfigInvalidConfigTime;
	goto sendReply;
    }
    
    /*
     * Search for the requested size
     */
    pSize = 0;
    for (i = 0; i < pScrPriv->nSizes; i++)
    {
	pSize = &pScrPriv->pSizes[i];
	if (pSize->referenced && pSize->id == stuff->sizeID)
d415 2
a416 1
	    break;
d418 11
a428 54
    }
    if (i == pScrPriv->nSizes)
    {
	/*
	 * Invalid size ID
	 */
	client->errorValue = stuff->sizeID;
	return BadValue;
    }
    
    /*
     * Validate requested rotation
     */
    rotation = (Rotation) stuff->rotation;

    /* test the rotation bits only! */
    switch (rotation & 0xf) {
    case RR_Rotate_0:
    case RR_Rotate_90:
    case RR_Rotate_180:
    case RR_Rotate_270:
	break;
    default:
	/*
	 * Invalid rotation
	 */
	client->errorValue = stuff->rotation;
	return BadValue;
    }

    if ((~pScrPriv->rotations) & rotation)
    {
	/*
	 * requested rotation or reflection not supported by screen
	 */
	client->errorValue = stuff->rotation;
	return BadMatch;
    }

    /*
     * Validate requested refresh
     */
    if (has_rate)
	rate = (int) stuff->rate;
    else
	rate = 0;

    if (rate)
    {
	for (i = 0; i < pSize->nRates; i++)
	{
	    RRScreenRatePtr pRate = &pSize->pRates[i];
	    if (pRate->referenced && pRate->rate == rate)
		break;
a429 31
	if (i == pSize->nRates)
	{
	    /*
	     * Invalid rate
	     */
	    client->errorValue = rate;
	    return BadValue;
	}
    }
    
    /*
     * Make sure the requested set-time is not older than
     * the last set-time
     */
    if (CompareTimeStamps (time, pScrPriv->lastSetTime) < 0)
    {
	rep.status = RRSetConfigInvalidTime;
	goto sendReply;
    }

    /*
     * call out to ddx routine to effect the change
     */
    if (!(*pScrPriv->rrSetConfig) (pScreen, rotation, rate,
				   pSize))
    {
	/*
	 * unknown DDX failure, report to client
	 */
	rep.status = RRSetConfigFailed;
	goto sendReply;
a430 53
    
    /*
     * set current extension configuration pointers
     */
    RRSetCurrentConfig (pScreen, rotation, rate, pSize);
    
    /*
     * Deliver ScreenChangeNotify events whenever
     * the configuration is updated
     */
    WalkTree (pScreen, TellChanged, (pointer) pScreen);
    
    /*
     * Deliver ConfigureNotify events when root changes
     * pixel size
     */
    if (oldWidth != pScreen->width || oldHeight != pScreen->height)
	RRSendConfigNotify (pScreen);
    RREditConnectionInfo (pScreen);
    
    /*
     * Fix pointer bounds and location
     */
    ScreenRestructured (pScreen);
    pScrPriv->lastSetTime = time;
    
    /*
     * Report Success
     */
    rep.status = RRSetConfigSuccess;
    
sendReply:
    
    rep.type = X_Reply;
    /* rep.status has already been filled in */
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    rep.newTimestamp = pScrPriv->lastSetTime.milliseconds;
    rep.newConfigTimestamp = pScrPriv->lastConfigTime.milliseconds;
    rep.root = WindowTable[pDraw->pScreen->myNum]->drawable.id;

    if (client->swapped) 
    {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.newTimestamp, n);
	swapl(&rep.newConfigTimestamp, n);
	swapl(&rep.root, n);
    }
    WriteToClient(client, sizeof(xRRSetScreenConfigReply), (char *)&rep);

    return (client->noClientException);
d433 6
a438 5
int
RRSetScreenConfig (ScreenPtr		pScreen,
		   Rotation		rotation,
		   int			rate,
		   RRScreenSizePtr	pSize)
d440 3
a442 11
    rrScrPrivPtr	    pScrPriv;
    int			    i;
    short		    oldWidth, oldHeight;

    pScrPriv = rrGetScrPriv(pScreen);
    
    oldWidth = pScreen->width;
    oldHeight = pScreen->height;
    
    if (!RRGetInfo (pScreen))
	return BadAlloc;
d444 1
a444 30
    /*
     * Validate requested rotation
     */

    /* test the rotation bits only! */
    switch (rotation & 0xf) {
    case RR_Rotate_0:
    case RR_Rotate_90:
    case RR_Rotate_180:
    case RR_Rotate_270:
	break;
    default:
	/*
	 * Invalid rotation
	 */
	return BadValue;
    }

    if ((~pScrPriv->rotations) & rotation)
    {
	/*
	 * requested rotation or reflection not supported by screen
	 */
	return BadMatch;
    }

    /*
     * Validate requested refresh
     */
    if (rate)
d446 2
a447 1
	for (i = 0; i < pSize->nRates; i++)
d449 3
a451 3
	    RRScreenRatePtr pRate = &pSize->pRates[i];
	    if (pRate->referenced && pRate->rate == rate)
		break;
a452 19
	if (i == pSize->nRates)
	{
	    /*
	     * Invalid rate
	     */
	    return BadValue;
	}
    }

    /*
     * call out to ddx routine to effect the change
     */
    if (!(*pScrPriv->rrSetConfig) (pScreen, rotation, rate,
				   pSize))
    {
	/*
	 * unknown DDX failure, report to client
	 */
        return BadImplementation;
d454 1
a454 26
    
    /*
     * set current extension configuration pointers
     */
    RRSetCurrentConfig (pScreen, rotation, rate, pSize);
    
    /*
     * Deliver ScreenChangeNotify events whenever
     * the configuration is updated
     */
    WalkTree (pScreen, TellChanged, (pointer) pScreen);
    
    /*
     * Deliver ConfigureNotify events when root changes
     * pixel size
     */
    if (oldWidth != pScreen->width || oldHeight != pScreen->height)
	RRSendConfigNotify (pScreen);
    RREditConnectionInfo (pScreen);
    
    /*
     * Fix pointer bounds and location
     */
    ScreenRestructured (pScreen);
    
    return Success;
d457 2
a458 2
static int
ProcRRSelectInput (ClientPtr client)
d460 8
a467 104
    REQUEST(xRRSelectInputReq);
    rrClientPriv(client);
    RRTimesPtr	pTimes;
    WindowPtr	pWin;
    RREventPtr	pRREvent, pNewRREvent, *pHead;
    XID		clientResource;

    REQUEST_SIZE_MATCH(xRRSelectInputReq);
    pWin = SecurityLookupWindow (stuff->window, client, SecurityWriteAccess);
    if (!pWin)
	return BadWindow;
    pHead = (RREventPtr *)SecurityLookupIDByType(client,
						 pWin->drawable.id, EventType,
						 SecurityWriteAccess);

    if (stuff->enable & (RRScreenChangeNotifyMask)) 
    {
	ScreenPtr	pScreen = pWin->drawable.pScreen;
	rrScrPriv	(pScreen);

	if (pHead) 
	{
	    /* check for existing entry. */
	    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent->next)
		if (pRREvent->client == client)
		    return Success;
	}

	/* build the entry */
	pNewRREvent = (RREventPtr) xalloc (sizeof (RREventRec));
	if (!pNewRREvent)
	    return BadAlloc;
	pNewRREvent->next = 0;
	pNewRREvent->client = client;
	pNewRREvent->window = pWin;
	pNewRREvent->mask = stuff->enable;
	/*
	 * add a resource that will be deleted when
	 * the client goes away
	 */
	clientResource = FakeClientID (client->index);
	pNewRREvent->clientResource = clientResource;
	if (!AddResource (clientResource, ClientType, (pointer)pNewRREvent))
	    return BadAlloc;
	/*
	 * create a resource to contain a pointer to the list
	 * of clients selecting input.  This must be indirect as
	 * the list may be arbitrarily rearranged which cannot be
	 * done through the resource database.
	 */
	if (!pHead)
	{
	    pHead = (RREventPtr *) xalloc (sizeof (RREventPtr));
	    if (!pHead ||
		!AddResource (pWin->drawable.id, EventType, (pointer)pHead))
	    {
		FreeResource (clientResource, RT_NONE);
		return BadAlloc;
	    }
	    *pHead = 0;
	}
	pNewRREvent->next = *pHead;
	*pHead = pNewRREvent;
	/*
	 * Now see if the client needs an event
	 */
	if (pScrPriv)
	{
	    pTimes = &((RRTimesPtr) (pRRClient + 1))[pScreen->myNum];
	    if (CompareTimeStamps (pTimes->setTime, 
				   pScrPriv->lastSetTime) != 0 ||
		CompareTimeStamps (pTimes->configTime, 
				   pScrPriv->lastConfigTime) != 0)
	    {
		TellChanged (pWin, (pointer) pScreen);
	    }
	}
    }
    else if (stuff->enable == xFalse) 
    {
	/* delete the interest */
	if (pHead) {
	    pNewRREvent = 0;
	    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent->next) {
		if (pRREvent->client == client)
		    break;
		pNewRREvent = pRREvent;
	    }
	    if (pRREvent) {
		FreeResource (pRREvent->clientResource, ClientType);
		if (pNewRREvent)
		    pNewRREvent->next = pRREvent->next;
		else
		    *pHead = pRREvent->next;
		xfree (pRREvent);
	    }
	}
    }
    else 
    {
	client->errorValue = stuff->enable;
	return BadValue;
    }
    return Success;
a469 1

d474 1
a474 11
    switch (stuff->data)
    {
    case X_RRQueryVersion:
	return ProcRRQueryVersion(client);
    case X_RRSetScreenConfig:
        return ProcRRSetScreenConfig(client);
    case X_RRSelectInput:
        return ProcRRSelectInput(client);
    case X_RRGetScreenInfo:
        return ProcRRGetScreenInfo(client);
    default:
d476 1
a476 48
    }
}

static int
SProcRRQueryVersion (ClientPtr client)
{
    register int n;
    REQUEST(xRRQueryVersionReq);

    swaps(&stuff->length, n);
    swapl(&stuff->majorVersion, n);
    swapl(&stuff->minorVersion, n);
    return ProcRRQueryVersion(client);
}

static int
SProcRRGetScreenInfo (ClientPtr client)
{
    register int n;
    REQUEST(xRRGetScreenInfoReq);

    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    return ProcRRGetScreenInfo(client);
}

static int
SProcRRSetScreenConfig (ClientPtr client)
{
    register int n;
    REQUEST(xRRSetScreenConfigReq);

    if (RRClientKnowsRates (client))
    {
	REQUEST_SIZE_MATCH (xRRSetScreenConfigReq);
	swaps (&stuff->rate, n);
    }
    else
    {
	REQUEST_SIZE_MATCH (xRR1_0SetScreenConfigReq);
    }
    
    swaps(&stuff->length, n);
    swapl(&stuff->drawable, n);
    swapl(&stuff->timestamp, n);
    swaps(&stuff->sizeID, n);
    swaps(&stuff->rotation, n);
    return ProcRRSetScreenConfig(client);
a479 12
SProcRRSelectInput (ClientPtr client)
{
    register int n;
    REQUEST(xRRSelectInputReq);

    swaps(&stuff->length, n);
    swapl(&stuff->window, n);
    return ProcRRSelectInput(client);
}


static int
d483 1
a483 11
    switch (stuff->data)
    {
    case X_RRQueryVersion:
	return SProcRRQueryVersion(client);
    case X_RRSetScreenConfig:
        return SProcRRSetScreenConfig(client);
    case X_RRSelectInput:
        return SProcRRSelectInput(client);
    case X_RRGetScreenInfo:
        return SProcRRGetScreenInfo(client);
    default:
d485 1
a485 100
    }
}


static Bool
RRScreenSizeMatches (RRScreenSizePtr  a,
		   RRScreenSizePtr  b)
{
    if (a->width != b->width)
	return FALSE;
    if (a->height != b->height)
	return FALSE;
    if (a->mmWidth != b->mmWidth)
	return FALSE;
    if (a->mmHeight != b->mmHeight)
	return FALSE;
    return TRUE;
}

RRScreenSizePtr
RRRegisterSize (ScreenPtr	    pScreen,
		short		    width, 
		short		    height,
		short		    mmWidth,
		short		    mmHeight)
{
    rrScrPriv (pScreen);
    int		    i;
    RRScreenSize    tmp;
    RRScreenSizePtr pNew;

    if (!pScrPriv)
	return 0;
    
    tmp.width = width;
    tmp.height= height;
    tmp.mmWidth = mmWidth;
    tmp.mmHeight = mmHeight;
    tmp.pRates = 0;
    tmp.nRates = 0;
    tmp.nRatesInUse = 0;
    tmp.referenced = TRUE;
    tmp.oldReferenced = FALSE;
    for (i = 0; i < pScrPriv->nSizes; i++)
	if (RRScreenSizeMatches (&tmp, &pScrPriv->pSizes[i]))
	{
	    pScrPriv->pSizes[i].referenced = TRUE;
	    return &pScrPriv->pSizes[i];
	}
    pNew = xrealloc (pScrPriv->pSizes,
		     (pScrPriv->nSizes + 1) * sizeof (RRScreenSize));
    if (!pNew)
	return 0;
    pNew[pScrPriv->nSizes++] = tmp;
    pScrPriv->pSizes = pNew;
    return &pNew[pScrPriv->nSizes-1];
}

Bool RRRegisterRate (ScreenPtr		pScreen,
		     RRScreenSizePtr	pSize,
		     int		rate)
{
    rrScrPriv(pScreen);
    int		    i;
    RRScreenRatePtr pNew, pRate;

    if (!pScrPriv)
	return FALSE;
    
    for (i = 0; i < pSize->nRates; i++)
    {
	pRate = &pSize->pRates[i];
	if (pRate->rate == rate)
	{
	    pRate->referenced = TRUE;
	    return TRUE;
	}
    }

    pNew = xrealloc (pSize->pRates,
		     (pSize->nRates + 1) * sizeof (RRScreenRate));
    if (!pNew)
	return FALSE;
    pRate = &pNew[pSize->nRates++];
    pRate->rate = rate;
    pRate->referenced = TRUE;
    pRate->oldReferenced = FALSE;
    pSize->pRates = pNew;
    return TRUE;
}

Rotation
RRGetRotation(ScreenPtr pScreen)
{
    rrScrPriv (pScreen);

    if (!pScrPriv)
	return RR_Rotate_0;

    return pScrPriv->rotation;
a487 15
void
RRSetCurrentConfig (ScreenPtr		pScreen,
		    Rotation		rotation,
		    int			rate,
		    RRScreenSizePtr	pSize)
{
    rrScrPriv (pScreen);

    if (!pScrPriv)
	return;

    pScrPriv->rotation = rotation;
    pScrPriv->size = pSize - pScrPriv->pSizes;
    pScrPriv->rate = rate;
}
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 3
a4 3
 * Copyright © 2000 Compaq Computer Corporation
 * Copyright © 2002 Hewlett-Packard Company
 * Copyright © 2006 Intel Corporation
d8 7
a14 7
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
d16 6
a21 7
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
d23 1
a23 2
 * Author:  Jim Gettys, Hewlett-Packard Company, Inc.
 *	    Keith Packard, Intel Corporation
d26 1
d33 13
d47 5
d59 7
a65 1
static int	RRNScreens;
d76 28
a103 2
static int ProcRRDispatch (ClientPtr pClient);
static int SProcRRDispatch (ClientPtr pClient);
d105 7
a111 4
int	RREventBase;
int	RRErrorBase;
RESTYPE RRClientType, RREventType; /* resource types for event masks */
int	RRClientPrivateIndex;
d115 12
a161 1
    int		    j;
d164 2
a165 5
    for (j = pScrPriv->numCrtcs - 1; j >= 0; j--)
	RRCrtcDestroy (pScrPriv->crtcs[j]);
    for (j = pScrPriv->numOutputs - 1; j >= 0; j--)
	RROutputDestroy (pScrPriv->outputs[j]);
    
a189 89
static void
SRRCrtcChangeNotifyEvent(xRRCrtcChangeNotifyEvent *from,
			 xRRCrtcChangeNotifyEvent *to)
{
    to->type = from->type;
    to->subCode = from->subCode;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->timestamp, to->timestamp);
    cpswapl(from->window, to->window);
    cpswapl(from->crtc, to->crtc);
    cpswapl(from->mode, to->mode);
    cpswapl(from->window, to->window);
    cpswaps(from->rotation, to->rotation);
    cpswaps(from->x, to->x);
    cpswaps(from->y, to->y);
    cpswaps(from->width, to->width);
    cpswaps(from->height, to->height);
}

static void
SRROutputChangeNotifyEvent(xRROutputChangeNotifyEvent *from,
			   xRROutputChangeNotifyEvent *to)
{
    to->type = from->type;
    to->subCode = from->subCode;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->timestamp, to->timestamp);
    cpswapl(from->configTimestamp, to->configTimestamp);
    cpswapl(from->window, to->window);
    cpswapl(from->output, to->output);
    cpswapl(from->crtc, to->crtc);
    cpswapl(from->mode, to->mode);
    cpswaps(from->rotation, to->rotation);
}

static void
SRROutputPropertyNotifyEvent(xRROutputPropertyNotifyEvent *from,
			     xRROutputPropertyNotifyEvent *to)
{
    to->type = from->type;
    to->subCode = from->subCode;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->window, to->window);
    cpswapl(from->output, to->output);
    cpswapl(from->atom, to->atom);
    cpswapl(from->timestamp, to->timestamp);
}

static void
SRRNotifyEvent (xEvent *from,
		xEvent *to)
{
    switch (from->u.u.detail) {
    case RRNotify_CrtcChange:
	SRRCrtcChangeNotifyEvent ((xRRCrtcChangeNotifyEvent *) from,
				  (xRRCrtcChangeNotifyEvent *) to);
	break;
    case RRNotify_OutputChange:
	SRROutputChangeNotifyEvent ((xRROutputChangeNotifyEvent *) from,
				    (xRROutputChangeNotifyEvent *) to);
	break;
    case RRNotify_OutputProperty:
	SRROutputPropertyNotifyEvent ((xRROutputPropertyNotifyEvent *) from,
				      (xRROutputPropertyNotifyEvent *) to);
	break;
    default:
	break;
    }
}

static int RRGeneration;

Bool RRInit (void)
{
    if (RRGeneration != serverGeneration)
    {
	if (!RRModeInit ())
	    return FALSE;
	if (!RRCrtcInit ())
	    return FALSE;
	if (!RROutputInit ())
	    return FALSE;
	RRGeneration = serverGeneration;
    }
    return TRUE;
}

static int RRScreenGeneration;

d194 1
a194 4
    if (!RRInit ())
	return FALSE;

    if (RRScreenGeneration != serverGeneration)
d198 1
a198 1
	RRScreenGeneration = serverGeneration;
d201 1
a201 1
    pScrPriv = (rrScrPrivPtr) xcalloc (1, sizeof (rrScrPrivRec));
d210 1
a211 24
    pScrPriv->maxWidth = pScrPriv->minWidth = pScreen->width;
    pScrPriv->maxHeight = pScrPriv->minHeight = pScreen->height;
    
    pScrPriv->width = pScreen->width;
    pScrPriv->height = pScreen->height;
    pScrPriv->mmWidth = pScreen->mmWidth;
    pScrPriv->mmHeight = pScreen->mmHeight;
#if RANDR_12_INTERFACE
    pScrPriv->rrScreenSetSize = NULL;
    pScrPriv->rrCrtcSet = NULL;
    pScrPriv->rrCrtcSetGamma = NULL;
#endif
#if RANDR_10_INTERFACE    
    pScrPriv->rrSetConfig = 0;
    pScrPriv->rotations = RR_Rotate_0;
    pScrPriv->reqWidth = pScreen->width;
    pScrPriv->reqHeight = pScreen->height;
    pScrPriv->nSizes = 0;
    pScrPriv->pSizes = NULL;
    pScrPriv->rotation = RR_Rotate_0;
    pScrPriv->rate = 0;
    pScrPriv->size = 0;
#endif
    
d222 8
a229 4
    pScrPriv->numOutputs = 0;
    pScrPriv->outputs = NULL;
    pScrPriv->numCrtcs = 0;
    pScrPriv->crtcs = NULL;
d245 1
a245 1
    pHead = (RREventPtr *) LookupIDByType(pWin->drawable.id, RREventType);
d271 1
a271 1
	FreeResource (pCur->clientResource, RRClientType);
d293 2
a294 2
    RRClientType = CreateNewResourceType(RRFreeClient);
    if (!RRClientType)
d296 2
a297 2
    RREventType = CreateNewResourceType(RRFreeEvents);
    if (!RREventType)
d304 4
a307 1
    RRErrorBase = extEntry->errorBase;
d310 3
a312 6
	SRRScreenChangeNotifyEvent;
    EventSwapVector[RREventBase + RRNotify] = (EventSwapPtr)
	SRRNotifyEvent;
#ifdef PANORAMIX
    RRXineramaExtensionInit();
#endif
d314 1
a314 1

d320 1
d323 2
a324 1
    int				i;
d326 1
a326 1
    pHead = (RREventPtr *) LookupIDByType (pWin->drawable.id, RREventType);
d330 32
d367 163
d531 61
a591 4
	if (pRREvent->mask & RRScreenChangeNotifyMask)
	    RRDeliverScreenEvent (client, pWin, pScreen);
	
	if (pRREvent->mask & RRCrtcChangeNotifyMask)
d593 1
a593 1
	    for (i = 0; i < pScrPriv->numCrtcs; i++)
d595 5
a599 3
		RRCrtcPtr   crtc = pScrPriv->crtcs[i];
		if (crtc->changed)
		    RRDeliverCrtcEvent (client, pWin, crtc);
d602 18
a619 2
	
	if (pRREvent->mask & RROutputChangeNotifyMask)
d621 2
a622 1
	    for (i = 0; i < pScrPriv->numOutputs; i++)
d624 34
a657 3
		RROutputPtr   output = pScrPriv->outputs[i];
		if (output->changed)
		    RRDeliverOutputEvent (client, pWin, output);
d660 16
d677 7
a683 1
    return WT_WALKCHILDREN;
d686 2
a687 5
/*
 * Something changed; send events and adjust pointer position
 */
void
RRTellChanged (ScreenPtr pScreen)
d689 81
a769 2
    rrScrPriv (pScreen);
    int i;
d771 21
a791 1
    if (pScrPriv->changed)
d793 18
a810 2
	UpdateCurrentTime ();
	if (pScrPriv->configChanged)
d812 3
a814 2
	    pScrPriv->lastConfigTime = currentTime;
	    pScrPriv->configChanged = FALSE;
d816 7
a822 11
	pScrPriv->changed = FALSE;
	WalkTree (pScreen, TellChanged, (pointer) pScreen);
	for (i = 0; i < pScrPriv->numOutputs; i++)
	    pScrPriv->outputs[i]->changed = FALSE;
	for (i = 0; i < pScrPriv->numCrtcs; i++)
	    pScrPriv->crtcs[i]->changed = FALSE;
	if (pScrPriv->layoutChanged)
	{
	    pScrPriv->layoutChanged = FALSE;
	    RRPointerScreenConfigured (pScreen);
	    RRSendConfigNotify (pScreen);
d825 76
d903 5
a907 6
/*
 * Return the first output which is connected to an active CRTC
 * Used in emulating 1.0 behaviour
 */
RROutputPtr
RRFirstOutput (ScreenPtr pScreen)
d909 11
a919 3
    rrScrPriv(pScreen);
    RROutputPtr		    output;
    int	i, j;
d921 19
a939 1
    for (i = 0; i < pScrPriv->numCrtcs; i++)
d941 18
a958 2
	RRCrtcPtr   crtc = pScrPriv->crtcs[i];
	for (j = 0; j < pScrPriv->numOutputs; j++)
d960 4
a963 3
	    output = pScrPriv->outputs[j];
	    if (output->crtc == crtc)
		return output;
d966 38
a1003 1
    return NULL;
d1006 2
a1007 2
CARD16
RRVerticalRefresh (xRRModeInfo *mode)
d1009 104
a1112 8
    CARD32  refresh;
    CARD32  dots = mode->hTotal * mode->vTotal;
    if (!dots)
	return 0;
    refresh = (mode->dotClock + dots/2) / dots;
    if (refresh > 0xffff)
	refresh = 0xffff;
    return (CARD16) refresh;
d1115 1
d1120 11
a1130 1
    if (stuff->data >= RRNumberRequests || !ProcRandrVector[stuff->data])
d1132 13
a1144 1
    return (*ProcRandrVector[stuff->data]) (client);
d1148 47
d1198 11
a1208 1
    if (stuff->data >= RRNumberRequests || !ProcRandrVector[stuff->data])
d1210 1
a1210 1
    return (*SProcRandrVector[stuff->data]) (client);
d1213 114
@

