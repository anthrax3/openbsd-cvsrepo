head	1.15;
access;
symbols
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	s0SI41sEunLdyFfd;

1.14
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	7pAEtF6Y5EgemkuY;

1.13
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	Te1daavkBLskZ8gc;

1.12
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	cVXoV5PxI8YrEaVA;

1.11
date	2014.05.02.19.27.51;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.12.28.14.40.02;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.05.13;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.05.13;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright Â© 2006 Keith Packard
 * Copyright 2010 Red Hat, Inc
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"
#include "swaprep.h"
#include "mipointer.h"

RESTYPE RRCrtcType;

/*
 * Notify the CRTC of some change
 */
void
RRCrtcChanged(RRCrtcPtr crtc, Bool layoutChanged)
{
    ScreenPtr pScreen = crtc->pScreen;

    crtc->changed = TRUE;
    if (pScreen) {
        rrScrPriv(pScreen);

        RRSetChanged(pScreen);
        /*
         * Send ConfigureNotify on any layout change
         */
        if (layoutChanged)
            pScrPriv->layoutChanged = TRUE;
    }
}

/*
 * Create a CRTC
 */
RRCrtcPtr
RRCrtcCreate(ScreenPtr pScreen, void *devPrivate)
{
    RRCrtcPtr crtc;
    RRCrtcPtr *crtcs;
    rrScrPrivPtr pScrPriv;

    if (!RRInit())
        return NULL;

    pScrPriv = rrGetScrPriv(pScreen);

    /* make space for the crtc pointer */
    if (pScrPriv->numCrtcs)
        crtcs = reallocarray(pScrPriv->crtcs,
                             pScrPriv->numCrtcs + 1, sizeof(RRCrtcPtr));
    else
        crtcs = malloc(sizeof(RRCrtcPtr));
    if (!crtcs)
        return FALSE;
    pScrPriv->crtcs = crtcs;

    crtc = calloc(1, sizeof(RRCrtcRec));
    if (!crtc)
        return NULL;
    crtc->id = FakeClientID(0);
    crtc->pScreen = pScreen;
    crtc->mode = NULL;
    crtc->x = 0;
    crtc->y = 0;
    crtc->rotation = RR_Rotate_0;
    crtc->rotations = RR_Rotate_0;
    crtc->outputs = NULL;
    crtc->numOutputs = 0;
    crtc->gammaSize = 0;
    crtc->gammaRed = crtc->gammaBlue = crtc->gammaGreen = NULL;
    crtc->changed = FALSE;
    crtc->devPrivate = devPrivate;
    RRTransformInit(&crtc->client_pending_transform);
    RRTransformInit(&crtc->client_current_transform);
    pixman_transform_init_identity(&crtc->transform);
    pixman_f_transform_init_identity(&crtc->f_transform);
    pixman_f_transform_init_identity(&crtc->f_inverse);

    if (!AddResource(crtc->id, RRCrtcType, (void *) crtc))
        return NULL;

    /* attach the screen and crtc together */
    crtc->pScreen = pScreen;
    pScrPriv->crtcs[pScrPriv->numCrtcs++] = crtc;

    RRResourcesChanged(pScreen);

    return crtc;
}

/*
 * Set the allowed rotations on a CRTC
 */
void
RRCrtcSetRotations(RRCrtcPtr crtc, Rotation rotations)
{
    crtc->rotations = rotations;
}

/*
 * Set whether transforms are allowed on a CRTC
 */
void
RRCrtcSetTransformSupport(RRCrtcPtr crtc, Bool transforms)
{
    crtc->transforms = transforms;
}

/*
 * Notify the extension that the Crtc has been reconfigured,
 * the driver calls this whenever it has updated the mode
 */
Bool
RRCrtcNotify(RRCrtcPtr crtc,
             RRModePtr mode,
             int x,
             int y,
             Rotation rotation,
             RRTransformPtr transform, int numOutputs, RROutputPtr * outputs)
{
    int i, j;

    /*
     * Check to see if any of the new outputs were
     * not in the old list and mark them as changed
     */
    for (i = 0; i < numOutputs; i++) {
        for (j = 0; j < crtc->numOutputs; j++)
            if (outputs[i] == crtc->outputs[j])
                break;
        if (j == crtc->numOutputs) {
            outputs[i]->crtc = crtc;
            RROutputChanged(outputs[i], FALSE);
            RRCrtcChanged(crtc, FALSE);
        }
    }
    /*
     * Check to see if any of the old outputs are
     * not in the new list and mark them as changed
     */
    for (j = 0; j < crtc->numOutputs; j++) {
        for (i = 0; i < numOutputs; i++)
            if (outputs[i] == crtc->outputs[j])
                break;
        if (i == numOutputs) {
            if (crtc->outputs[j]->crtc == crtc)
                crtc->outputs[j]->crtc = NULL;
            RROutputChanged(crtc->outputs[j], FALSE);
            RRCrtcChanged(crtc, FALSE);
        }
    }
    /*
     * Reallocate the crtc output array if necessary
     */
    if (numOutputs != crtc->numOutputs) {
        RROutputPtr *newoutputs;

        if (numOutputs) {
            if (crtc->numOutputs)
                newoutputs = reallocarray(crtc->outputs,
                                          numOutputs, sizeof(RROutputPtr));
            else
                newoutputs = xallocarray(numOutputs, sizeof(RROutputPtr));
            if (!newoutputs)
                return FALSE;
        }
        else {
            free(crtc->outputs);
            newoutputs = NULL;
        }
        crtc->outputs = newoutputs;
        crtc->numOutputs = numOutputs;
    }
    /*
     * Copy the new list of outputs into the crtc
     */
    memcpy(crtc->outputs, outputs, numOutputs * sizeof(RROutputPtr));
    /*
     * Update remaining crtc fields
     */
    if (mode != crtc->mode) {
        if (crtc->mode)
            RRModeDestroy(crtc->mode);
        crtc->mode = mode;
        if (mode != NULL)
            mode->refcnt++;
        RRCrtcChanged(crtc, TRUE);
    }
    if (x != crtc->x) {
        crtc->x = x;
        RRCrtcChanged(crtc, TRUE);
    }
    if (y != crtc->y) {
        crtc->y = y;
        RRCrtcChanged(crtc, TRUE);
    }
    if (rotation != crtc->rotation) {
        crtc->rotation = rotation;
        RRCrtcChanged(crtc, TRUE);
    }
    if (!RRTransformEqual(transform, &crtc->client_current_transform)) {
        RRTransformCopy(&crtc->client_current_transform, transform);
        RRCrtcChanged(crtc, TRUE);
    }
    if (crtc->changed && mode) {
        RRTransformCompute(x, y,
                           mode->mode.width, mode->mode.height,
                           rotation,
                           &crtc->client_current_transform,
                           &crtc->transform, &crtc->f_transform,
                           &crtc->f_inverse);
    }
    return TRUE;
}

void
RRDeliverCrtcEvent(ClientPtr client, WindowPtr pWin, RRCrtcPtr crtc)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    rrScrPriv(pScreen);
    RRModePtr mode = crtc->mode;

    xRRCrtcChangeNotifyEvent ce = {
        .type = RRNotify + RREventBase,
        .subCode = RRNotify_CrtcChange,
        .timestamp = pScrPriv->lastSetTime.milliseconds,
        .window = pWin->drawable.id,
        .crtc = crtc->id,
        .mode = mode ? mode->mode.id : None,
        .rotation = crtc->rotation,
        .x = mode ? crtc->x : 0,
        .y = mode ? crtc->y : 0,
        .width = mode ? mode->mode.width : 0,
        .height = mode ? mode->mode.height : 0
    };
    WriteEventsToClient(client, 1, (xEvent *) &ce);
}

static Bool
RRCrtcPendingProperties(RRCrtcPtr crtc)
{
    ScreenPtr pScreen = crtc->pScreen;

    rrScrPriv(pScreen);
    int o;

    for (o = 0; o < pScrPriv->numOutputs; o++) {
        RROutputPtr output = pScrPriv->outputs[o];

        if (output->crtc == crtc && output->pendingProperties)
            return TRUE;
    }
    return FALSE;
}

static void
crtc_bounds(RRCrtcPtr crtc, int *left, int *right, int *top, int *bottom)
{
    *left = crtc->x;
    *top = crtc->y;

    switch (crtc->rotation) {
    case RR_Rotate_0:
    case RR_Rotate_180:
    default:
        *right = crtc->x + crtc->mode->mode.width;
        *bottom = crtc->y + crtc->mode->mode.height;
        return;
    case RR_Rotate_90:
    case RR_Rotate_270:
        *right = crtc->x + crtc->mode->mode.height;
        *bottom = crtc->y + crtc->mode->mode.width;
        return;
    }
}

/* overlapping counts as adjacent */
static Bool
crtcs_adjacent(const RRCrtcPtr a, const RRCrtcPtr b)
{
    /* left, right, top, bottom... */
    int al, ar, at, ab;
    int bl, br, bt, bb;
    int cl, cr, ct, cb;         /* the overlap, if any */

    crtc_bounds(a, &al, &ar, &at, &ab);
    crtc_bounds(b, &bl, &br, &bt, &bb);

    cl = max(al, bl);
    cr = min(ar, br);
    ct = max(at, bt);
    cb = min(ab, bb);

    return (cl <= cr) && (ct <= cb);
}

/* Depth-first search and mark all CRTCs reachable from cur */
static void
mark_crtcs(rrScrPrivPtr pScrPriv, int *reachable, int cur)
{
    int i;

    reachable[cur] = TRUE;
    for (i = 0; i < pScrPriv->numCrtcs; ++i) {
        if (reachable[i] || !pScrPriv->crtcs[i]->mode)
            continue;
        if (crtcs_adjacent(pScrPriv->crtcs[cur], pScrPriv->crtcs[i]))
            mark_crtcs(pScrPriv, reachable, i);
    }
}

static void
RRComputeContiguity(ScreenPtr pScreen)
{
    rrScrPriv(pScreen);
    Bool discontiguous = TRUE;
    int i, n = pScrPriv->numCrtcs;

    int *reachable = calloc(n, sizeof(int));

    if (!reachable)
        goto out;

    /* Find first enabled CRTC and start search for reachable CRTCs from it */
    for (i = 0; i < n; ++i) {
        if (pScrPriv->crtcs[i]->mode) {
            mark_crtcs(pScrPriv, reachable, i);
            break;
        }
    }

    /* Check that all enabled CRTCs were marked as reachable */
    for (i = 0; i < n; ++i)
        if (pScrPriv->crtcs[i]->mode && !reachable[i])
            goto out;

    discontiguous = FALSE;

 out:
    free(reachable);
    pScrPriv->discontiguous = discontiguous;
}

void
RRCrtcDetachScanoutPixmap(RRCrtcPtr crtc)
{
    ScreenPtr master = crtc->pScreen->current_master;
    PixmapPtr mscreenpix;
    rrScrPriv(crtc->pScreen);

    mscreenpix = master->GetScreenPixmap(master);

    pScrPriv->rrCrtcSetScanoutPixmap(crtc, NULL);
    if (crtc->scanout_pixmap) {
        master->StopPixmapTracking(mscreenpix, crtc->scanout_pixmap);
        /*
         * Unref the pixmap twice: once for the original reference, and once
         * for the reference implicitly added by PixmapShareToSlave.
         */
        master->DestroyPixmap(crtc->scanout_pixmap->master_pixmap);
        master->DestroyPixmap(crtc->scanout_pixmap->master_pixmap);
        crtc->pScreen->DestroyPixmap(crtc->scanout_pixmap);
    }
    crtc->scanout_pixmap = NULL;
    RRCrtcChanged(crtc, TRUE);
}

static Bool
rrCreateSharedPixmap(RRCrtcPtr crtc, int width, int height,
                     int x, int y, Rotation rotation)
{
    PixmapPtr mpix, spix;
    ScreenPtr master = crtc->pScreen->current_master;
    Bool ret;
    int depth;
    PixmapPtr mscreenpix;
    PixmapPtr protopix = master->GetScreenPixmap(master);
    rrScrPriv(crtc->pScreen);

    /* create a pixmap on the master screen,
       then get a shared handle for it
       create a shared pixmap on the slave screen using the handle
       set the master screen to do dirty updates to the shared pixmap
       from the screen pixmap.
       set slave screen to scanout shared linear pixmap
    */

    mscreenpix = master->GetScreenPixmap(master);
    depth = protopix->drawable.depth;

    if (crtc->scanout_pixmap)
        RRCrtcDetachScanoutPixmap(crtc);

    if (width == 0 && height == 0) {
        return TRUE;
    }

    mpix = master->CreatePixmap(master, width, height, depth,
                                CREATE_PIXMAP_USAGE_SHARED);
    if (!mpix)
        return FALSE;

    spix = PixmapShareToSlave(mpix, crtc->pScreen);
    if (spix == NULL) {
        master->DestroyPixmap(mpix);
        return FALSE;
    }

    ret = pScrPriv->rrCrtcSetScanoutPixmap(crtc, spix);
    if (ret == FALSE) {
        ErrorF("randr: failed to set shadow slave pixmap\n");
        return FALSE;
    }

    crtc->scanout_pixmap = spix;

    master->StartPixmapTracking(mscreenpix, spix, x, y, 0, 0, rotation);
    return TRUE;
}

static void crtc_to_box(BoxPtr box, RRCrtcPtr crtc)
{
    box->x1 = crtc->x;
    box->y1 = crtc->y;
    switch (crtc->rotation) {
    case RR_Rotate_0:
    case RR_Rotate_180:
    default:
        box->x2 = crtc->x + crtc->mode->mode.width;
        box->y2 = crtc->y + crtc->mode->mode.height;
        break;
    case RR_Rotate_90:
    case RR_Rotate_270:
        box->x2 = crtc->x + crtc->mode->mode.height;
        box->y2 = crtc->y + crtc->mode->mode.width;
        break;
    }
}

static Bool
rrCheckPixmapBounding(ScreenPtr pScreen,
                      RRCrtcPtr rr_crtc, Rotation rotation,
                      int x, int y, int w, int h)
{
    RegionRec root_pixmap_region, total_region, new_crtc_region;
    int c;
    BoxRec newbox;
    BoxPtr newsize;
    ScreenPtr slave;
    int new_width, new_height;
    PixmapPtr screen_pixmap = pScreen->GetScreenPixmap(pScreen);
    rrScrPriv(pScreen);

    PixmapRegionInit(&root_pixmap_region, screen_pixmap);
    RegionInit(&total_region, NULL, 0);

    /* have to iterate all the crtcs of the attached gpu masters
       and all their output slaves */
    for (c = 0; c < pScrPriv->numCrtcs; c++) {
        RRCrtcPtr crtc = pScrPriv->crtcs[c];

        if (crtc == rr_crtc) {
            newbox.x1 = x;
            newbox.y1 = y;
            if (rotation == RR_Rotate_90 ||
                rotation == RR_Rotate_270) {
                newbox.x2 = x + h;
                newbox.y2 = y + w;
            } else {
                newbox.x2 = x + w;
                newbox.y2 = y + h;
            }
        } else {
            if (!crtc->mode)
                continue;
            crtc_to_box(&newbox, crtc);
        }
        RegionInit(&new_crtc_region, &newbox, 1);
        RegionUnion(&total_region, &total_region, &new_crtc_region);
    }

    xorg_list_for_each_entry(slave, &pScreen->output_slave_list, output_head) {
        rrScrPrivPtr    slave_priv = rrGetScrPriv(slave);
        for (c = 0; c < slave_priv->numCrtcs; c++) {
            RRCrtcPtr slave_crtc = slave_priv->crtcs[c];

            if (slave_crtc == rr_crtc) {
                newbox.x1 = x;
                newbox.y1 = y;
                if (rotation == RR_Rotate_90 ||
                    rotation == RR_Rotate_270) {
                    newbox.x2 = x + h;
                    newbox.y2 = y + w;
                } else {
                    newbox.x2 = x + w;
                    newbox.y2 = y + h;
                }
            }
            else {
                if (!slave_crtc->mode)
                    continue;
                crtc_to_box(&newbox, slave_crtc);
            }
            RegionInit(&new_crtc_region, &newbox, 1);
            RegionUnion(&total_region, &total_region, &new_crtc_region);
        }
    }

    newsize = RegionExtents(&total_region);
    new_width = newsize->x2 - newsize->x1;
    new_height = newsize->y2 - newsize->y1;

    if (new_width == screen_pixmap->drawable.width &&
        new_height == screen_pixmap->drawable.height) {
    } else {
        pScrPriv->rrScreenSetSize(pScreen, new_width, new_height, 0, 0);
    }

    /* set shatters TODO */
    return TRUE;
}

/*
 * Request that the Crtc be reconfigured
 */
Bool
RRCrtcSet(RRCrtcPtr crtc,
          RRModePtr mode,
          int x,
          int y, Rotation rotation, int numOutputs, RROutputPtr * outputs)
{
    ScreenPtr pScreen = crtc->pScreen;
    Bool ret = FALSE;
    Bool recompute = TRUE;
    Bool crtcChanged;
    int  o;

    rrScrPriv(pScreen);

    crtcChanged = FALSE;
    for (o = 0; o < numOutputs; o++) {
        if (outputs[o] && outputs[o]->crtc != crtc) {
            crtcChanged = TRUE;
            break;
        }
    }

    /* See if nothing changed */
    if (crtc->mode == mode &&
        crtc->x == x &&
        crtc->y == y &&
        crtc->rotation == rotation &&
        crtc->numOutputs == numOutputs &&
        !memcmp(crtc->outputs, outputs, numOutputs * sizeof(RROutputPtr)) &&
        !RRCrtcPendingProperties(crtc) && !RRCrtcPendingTransform(crtc) &&
        !crtcChanged) {
        recompute = FALSE;
        ret = TRUE;
    }
    else {
        if (pScreen->isGPU) {
            ScreenPtr master = pScreen->current_master;
            int width = 0, height = 0;

            if (mode) {
                width = mode->mode.width;
                height = mode->mode.height;
            }
            ret = rrCheckPixmapBounding(master, crtc,
                                        rotation, x, y, width, height);
            if (!ret)
                return FALSE;

            if (pScreen->current_master) {
                ret = rrCreateSharedPixmap(crtc, width, height, x, y, rotation);
            }
        }
#if RANDR_12_INTERFACE
        if (pScrPriv->rrCrtcSet) {
            ret = (*pScrPriv->rrCrtcSet) (pScreen, crtc, mode, x, y,
                                          rotation, numOutputs, outputs);
        }
        else
#endif
        {
#if RANDR_10_INTERFACE
            if (pScrPriv->rrSetConfig) {
                RRScreenSize size;
                RRScreenRate rate;

                if (!mode) {
                    RRCrtcNotify(crtc, NULL, x, y, rotation, NULL, 0, NULL);
                    ret = TRUE;
                }
                else {
                    size.width = mode->mode.width;
                    size.height = mode->mode.height;
                    if (outputs[0]->mmWidth && outputs[0]->mmHeight) {
                        size.mmWidth = outputs[0]->mmWidth;
                        size.mmHeight = outputs[0]->mmHeight;
                    }
                    else {
                        size.mmWidth = pScreen->mmWidth;
                        size.mmHeight = pScreen->mmHeight;
                    }
                    size.nRates = 1;
                    rate.rate = RRVerticalRefresh(&mode->mode);
                    size.pRates = &rate;
                    ret =
                        (*pScrPriv->rrSetConfig) (pScreen, rotation, rate.rate,
                                                  &size);
                    /*
                     * Old 1.0 interface tied screen size to mode size
                     */
                    if (ret) {
                        RRCrtcNotify(crtc, mode, x, y, rotation, NULL, 1,
                                     outputs);
                        RRScreenSizeNotify(pScreen);
                    }
                }
            }
#endif
        }
        if (ret) {

            RRTellChanged(pScreen);

            for (o = 0; o < numOutputs; o++)
                RRPostPendingProperties(outputs[o]);
        }
    }

    if (recompute)
        RRComputeContiguity(pScreen);

    return ret;
}

/*
 * Return crtc transform
 */
RRTransformPtr
RRCrtcGetTransform(RRCrtcPtr crtc)
{
    RRTransformPtr transform = &crtc->client_pending_transform;

    if (pixman_transform_is_identity(&transform->transform))
        return NULL;
    return transform;
}

/*
 * Check whether the pending and current transforms are the same
 */
Bool
RRCrtcPendingTransform(RRCrtcPtr crtc)
{
    return memcmp(&crtc->client_current_transform.transform,
                  &crtc->client_pending_transform.transform,
                  sizeof(PictTransform)) != 0;
}

/*
 * Destroy a Crtc at shutdown
 */
void
RRCrtcDestroy(RRCrtcPtr crtc)
{
    FreeResource(crtc->id, 0);
}

static int
RRCrtcDestroyResource(void *value, XID pid)
{
    RRCrtcPtr crtc = (RRCrtcPtr) value;
    ScreenPtr pScreen = crtc->pScreen;

    if (pScreen) {
        rrScrPriv(pScreen);
        int i;

        for (i = 0; i < pScrPriv->numCrtcs; i++) {
            if (pScrPriv->crtcs[i] == crtc) {
                memmove(pScrPriv->crtcs + i, pScrPriv->crtcs + i + 1,
                        (pScrPriv->numCrtcs - (i + 1)) * sizeof(RRCrtcPtr));
                --pScrPriv->numCrtcs;
                break;
            }
        }

        RRResourcesChanged(pScreen);
    }

    if (crtc->scanout_pixmap)
        RRCrtcDetachScanoutPixmap(crtc);
    free(crtc->gammaRed);
    if (crtc->mode)
        RRModeDestroy(crtc->mode);
    free(crtc);
    return 1;
}

/*
 * Request that the Crtc gamma be changed
 */

Bool
RRCrtcGammaSet(RRCrtcPtr crtc, CARD16 *red, CARD16 *green, CARD16 *blue)
{
    Bool ret = TRUE;

#if RANDR_12_INTERFACE
    ScreenPtr pScreen = crtc->pScreen;
#endif

    memcpy(crtc->gammaRed, red, crtc->gammaSize * sizeof(CARD16));
    memcpy(crtc->gammaGreen, green, crtc->gammaSize * sizeof(CARD16));
    memcpy(crtc->gammaBlue, blue, crtc->gammaSize * sizeof(CARD16));
#if RANDR_12_INTERFACE
    if (pScreen) {
        rrScrPriv(pScreen);
        if (pScrPriv->rrCrtcSetGamma)
            ret = (*pScrPriv->rrCrtcSetGamma) (pScreen, crtc);
    }
#endif
    return ret;
}

/*
 * Request current gamma back from the DDX (if possible).
 * This includes gamma size.
 */
Bool
RRCrtcGammaGet(RRCrtcPtr crtc)
{
    Bool ret = TRUE;

#if RANDR_12_INTERFACE
    ScreenPtr pScreen = crtc->pScreen;
#endif

#if RANDR_12_INTERFACE
    if (pScreen) {
        rrScrPriv(pScreen);
        if (pScrPriv->rrCrtcGetGamma)
            ret = (*pScrPriv->rrCrtcGetGamma) (pScreen, crtc);
    }
#endif
    return ret;
}

/*
 * Notify the extension that the Crtc gamma has been changed
 * The driver calls this whenever it has changed the gamma values
 * in the RRCrtcRec
 */

Bool
RRCrtcGammaNotify(RRCrtcPtr crtc)
{
    return TRUE;                /* not much going on here */
}

static void
RRModeGetScanoutSize(RRModePtr mode, PictTransformPtr transform,
                     int *width, int *height)
{
    BoxRec box;

    if (mode == NULL) {
        *width = 0;
        *height = 0;
        return;
    }

    box.x1 = 0;
    box.y1 = 0;
    box.x2 = mode->mode.width;
    box.y2 = mode->mode.height;

    pixman_transform_bounds(transform, &box);
    *width = box.x2 - box.x1;
    *height = box.y2 - box.y1;
}

/**
 * Returns the width/height that the crtc scans out from the framebuffer
 */
void
RRCrtcGetScanoutSize(RRCrtcPtr crtc, int *width, int *height)
{
    RRModeGetScanoutSize(crtc->mode, &crtc->transform, width, height);
}

/*
 * Set the size of the gamma table at server startup time
 */

Bool
RRCrtcGammaSetSize(RRCrtcPtr crtc, int size)
{
    CARD16 *gamma;

    if (size == crtc->gammaSize)
        return TRUE;
    if (size) {
        gamma = xallocarray(size, 3 * sizeof(CARD16));
        if (!gamma)
            return FALSE;
    }
    else
        gamma = NULL;
    free(crtc->gammaRed);
    crtc->gammaRed = gamma;
    crtc->gammaGreen = gamma + size;
    crtc->gammaBlue = gamma + size * 2;
    crtc->gammaSize = size;
    return TRUE;
}

/*
 * Set the pending CRTC transformation
 */

int
RRCrtcTransformSet(RRCrtcPtr crtc,
                   PictTransformPtr transform,
                   struct pixman_f_transform *f_transform,
                   struct pixman_f_transform *f_inverse,
                   char *filter_name,
                   int filter_len, xFixed * params, int nparams)
{
    PictFilterPtr filter = NULL;
    int width = 0, height = 0;

    if (!crtc->transforms)
        return BadValue;

    if (filter_len) {
        filter = PictureFindFilter(crtc->pScreen, filter_name, filter_len);
        if (!filter)
            return BadName;
        if (filter->ValidateParams) {
            if (!filter->ValidateParams(crtc->pScreen, filter->id,
                                        params, nparams, &width, &height))
                return BadMatch;
        }
        else {
            width = filter->width;
            height = filter->height;
        }
    }
    else {
        if (nparams)
            return BadMatch;
    }
    if (!RRTransformSetFilter(&crtc->client_pending_transform,
                              filter, params, nparams, width, height))
        return BadAlloc;

    crtc->client_pending_transform.transform = *transform;
    crtc->client_pending_transform.f_transform = *f_transform;
    crtc->client_pending_transform.f_inverse = *f_inverse;
    return Success;
}

/*
 * Initialize crtc type
 */
Bool
RRCrtcInit(void)
{
    RRCrtcType = CreateNewResourceType(RRCrtcDestroyResource, "CRTC");
    if (!RRCrtcType)
        return FALSE;

    return TRUE;
}

/*
 * Initialize crtc type error value
 */
void
RRCrtcInitErrorValue(void)
{
    SetResourceTypeErrorValue(RRCrtcType, RRErrorBase + BadRRCrtc);
}

int
ProcRRGetCrtcInfo(ClientPtr client)
{
    REQUEST(xRRGetCrtcInfoReq);
    xRRGetCrtcInfoReply rep;
    RRCrtcPtr crtc;
    CARD8 *extra;
    unsigned long extraLen;
    ScreenPtr pScreen;
    rrScrPrivPtr pScrPriv;
    RRModePtr mode;
    RROutput *outputs;
    RROutput *possible;
    int i, j, k;
    int width, height;
    BoxRec panned_area;

    REQUEST_SIZE_MATCH(xRRGetCrtcInfoReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);

    /* All crtcs must be associated with screens before client
     * requests are processed
     */
    pScreen = crtc->pScreen;
    pScrPriv = rrGetScrPriv(pScreen);

    mode = crtc->mode;

    rep = (xRRGetCrtcInfoReply) {
        .type = X_Reply,
        .status = RRSetConfigSuccess,
        .sequenceNumber = client->sequence,
        .length = 0,
        .timestamp = pScrPriv->lastSetTime.milliseconds
    };
    if (pScrPriv->rrGetPanning &&
        pScrPriv->rrGetPanning(pScreen, crtc, &panned_area, NULL, NULL) &&
        (panned_area.x2 > panned_area.x1) && (panned_area.y2 > panned_area.y1))
    {
        rep.x = panned_area.x1;
        rep.y = panned_area.y1;
        rep.width = panned_area.x2 - panned_area.x1;
        rep.height = panned_area.y2 - panned_area.y1;
    }
    else {
        RRCrtcGetScanoutSize(crtc, &width, &height);
        rep.x = crtc->x;
        rep.y = crtc->y;
        rep.width = width;
        rep.height = height;
    }
    rep.mode = mode ? mode->mode.id : 0;
    rep.rotation = crtc->rotation;
    rep.rotations = crtc->rotations;
    rep.nOutput = crtc->numOutputs;
    k = 0;
    for (i = 0; i < pScrPriv->numOutputs; i++)
        for (j = 0; j < pScrPriv->outputs[i]->numCrtcs; j++)
            if (pScrPriv->outputs[i]->crtcs[j] == crtc)
                k++;
    rep.nPossibleOutput = k;

    rep.length = rep.nOutput + rep.nPossibleOutput;

    extraLen = rep.length << 2;
    if (extraLen) {
        extra = malloc(extraLen);
        if (!extra)
            return BadAlloc;
    }
    else
        extra = NULL;

    outputs = (RROutput *) extra;
    possible = (RROutput *) (outputs + rep.nOutput);

    for (i = 0; i < crtc->numOutputs; i++) {
        outputs[i] = crtc->outputs[i]->id;
        if (client->swapped)
            swapl(&outputs[i]);
    }
    k = 0;
    for (i = 0; i < pScrPriv->numOutputs; i++)
        for (j = 0; j < pScrPriv->outputs[i]->numCrtcs; j++)
            if (pScrPriv->outputs[i]->crtcs[j] == crtc) {
                possible[k] = pScrPriv->outputs[i]->id;
                if (client->swapped)
                    swapl(&possible[k]);
                k++;
            }

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.timestamp);
        swaps(&rep.x);
        swaps(&rep.y);
        swaps(&rep.width);
        swaps(&rep.height);
        swapl(&rep.mode);
        swaps(&rep.rotation);
        swaps(&rep.rotations);
        swaps(&rep.nOutput);
        swaps(&rep.nPossibleOutput);
    }
    WriteToClient(client, sizeof(xRRGetCrtcInfoReply), &rep);
    if (extraLen) {
        WriteToClient(client, extraLen, extra);
        free(extra);
    }

    return Success;
}

int
ProcRRSetCrtcConfig(ClientPtr client)
{
    REQUEST(xRRSetCrtcConfigReq);
    xRRSetCrtcConfigReply rep;
    ScreenPtr pScreen;
    rrScrPrivPtr pScrPriv;
    RRCrtcPtr crtc;
    RRModePtr mode;
    int numOutputs;
    RROutputPtr *outputs = NULL;
    RROutput *outputIds;
    TimeStamp time;
    Rotation rotation;
    int ret, i, j;
    CARD8 status;

    REQUEST_AT_LEAST_SIZE(xRRSetCrtcConfigReq);
    numOutputs = (stuff->length - bytes_to_int32(SIZEOF(xRRSetCrtcConfigReq)));

    VERIFY_RR_CRTC(stuff->crtc, crtc, DixSetAttrAccess);

    if (stuff->mode == None) {
        mode = NULL;
        if (numOutputs > 0)
            return BadMatch;
    }
    else {
        VERIFY_RR_MODE(stuff->mode, mode, DixSetAttrAccess);
        if (numOutputs == 0)
            return BadMatch;
    }
    if (numOutputs) {
        outputs = xallocarray(numOutputs, sizeof(RROutputPtr));
        if (!outputs)
            return BadAlloc;
    }
    else
        outputs = NULL;

    outputIds = (RROutput *) (stuff + 1);
    for (i = 0; i < numOutputs; i++) {
        ret = dixLookupResourceByType((void **) (outputs + i), outputIds[i],
                                     RROutputType, client, DixSetAttrAccess);
        if (ret != Success) {
            free(outputs);
            return ret;
        }
        /* validate crtc for this output */
        for (j = 0; j < outputs[i]->numCrtcs; j++)
            if (outputs[i]->crtcs[j] == crtc)
                break;
        if (j == outputs[i]->numCrtcs) {
            free(outputs);
            return BadMatch;
        }
        /* validate mode for this output */
        for (j = 0; j < outputs[i]->numModes + outputs[i]->numUserModes; j++) {
            RRModePtr m = (j < outputs[i]->numModes ?
                           outputs[i]->modes[j] :
                           outputs[i]->userModes[j - outputs[i]->numModes]);
            if (m == mode)
                break;
        }
        if (j == outputs[i]->numModes + outputs[i]->numUserModes) {
            free(outputs);
            return BadMatch;
        }
    }
    /* validate clones */
    for (i = 0; i < numOutputs; i++) {
        for (j = 0; j < numOutputs; j++) {
            int k;

            if (i == j)
                continue;
            for (k = 0; k < outputs[i]->numClones; k++) {
                if (outputs[i]->clones[k] == outputs[j])
                    break;
            }
            if (k == outputs[i]->numClones) {
                free(outputs);
                return BadMatch;
            }
        }
    }

    pScreen = crtc->pScreen;
    pScrPriv = rrGetScrPriv(pScreen);

    time = ClientTimeToServerTime(stuff->timestamp);

    if (!pScrPriv) {
        time = currentTime;
        status = RRSetConfigFailed;
        goto sendReply;
    }

    /*
     * Validate requested rotation
     */
    rotation = (Rotation) stuff->rotation;

    /* test the rotation bits only! */
    switch (rotation & 0xf) {
    case RR_Rotate_0:
    case RR_Rotate_90:
    case RR_Rotate_180:
    case RR_Rotate_270:
        break;
    default:
        /*
         * Invalid rotation
         */
        client->errorValue = stuff->rotation;
        free(outputs);
        return BadValue;
    }

    if (mode) {
        if ((~crtc->rotations) & rotation) {
            /*
             * requested rotation or reflection not supported by screen
             */
            client->errorValue = stuff->rotation;
            free(outputs);
            return BadMatch;
        }

#ifdef RANDR_12_INTERFACE
        /*
         * Check screen size bounds if the DDX provides a 1.2 interface
         * for setting screen size. Else, assume the CrtcSet sets
         * the size along with the mode. If the driver supports transforms,
         * then it must allow crtcs to display a subset of the screen, so
         * only do this check for drivers without transform support.
         */
        if (pScrPriv->rrScreenSetSize && !crtc->transforms) {
            int source_width;
            int source_height;
            PictTransform transform;
            struct pixman_f_transform f_transform, f_inverse;
            int width, height;

            if (pScreen->isGPU) {
                width = pScreen->current_master->width;
                height = pScreen->current_master->height;
            }
            else {
                width = pScreen->width;
                height = pScreen->height;
            }

            RRTransformCompute(stuff->x, stuff->y,
                               mode->mode.width, mode->mode.height,
                               rotation,
                               &crtc->client_pending_transform,
                               &transform, &f_transform, &f_inverse);

            RRModeGetScanoutSize(mode, &transform, &source_width,
                                 &source_height);
            if (stuff->x + source_width > width) {
                client->errorValue = stuff->x;
                free(outputs);
                return BadValue;
            }

            if (stuff->y + source_height > height) {
                client->errorValue = stuff->y;
                free(outputs);
                return BadValue;
            }
        }
#endif
    }

    if (!RRCrtcSet(crtc, mode, stuff->x, stuff->y,
                   rotation, numOutputs, outputs)) {
        status = RRSetConfigFailed;
        goto sendReply;
    }
    status = RRSetConfigSuccess;
    pScrPriv->lastSetTime = time;

 sendReply:
    free(outputs);

    rep = (xRRSetCrtcConfigReply) {
        .type = X_Reply,
        .status = status,
        .sequenceNumber = client->sequence,
        .length = 0,
        .newTimestamp = pScrPriv->lastSetTime.milliseconds
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.newTimestamp);
    }
    WriteToClient(client, sizeof(xRRSetCrtcConfigReply), &rep);

    return Success;
}

int
ProcRRGetPanning(ClientPtr client)
{
    REQUEST(xRRGetPanningReq);
    xRRGetPanningReply rep;
    RRCrtcPtr crtc;
    ScreenPtr pScreen;
    rrScrPrivPtr pScrPriv;
    BoxRec total;
    BoxRec tracking;
    INT16 border[4];

    REQUEST_SIZE_MATCH(xRRGetPanningReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);

    /* All crtcs must be associated with screens before client
     * requests are processed
     */
    pScreen = crtc->pScreen;
    pScrPriv = rrGetScrPriv(pScreen);

    if (!pScrPriv)
        return RRErrorBase + BadRRCrtc;

    rep = (xRRGetPanningReply) {
        .type = X_Reply,
        .status = RRSetConfigSuccess,
        .sequenceNumber = client->sequence,
        .length = 1,
        .timestamp = pScrPriv->lastSetTime.milliseconds
    };

    if (pScrPriv->rrGetPanning &&
        pScrPriv->rrGetPanning(pScreen, crtc, &total, &tracking, border)) {
        rep.left = total.x1;
        rep.top = total.y1;
        rep.width = total.x2 - total.x1;
        rep.height = total.y2 - total.y1;
        rep.track_left = tracking.x1;
        rep.track_top = tracking.y1;
        rep.track_width = tracking.x2 - tracking.x1;
        rep.track_height = tracking.y2 - tracking.y1;
        rep.border_left = border[0];
        rep.border_top = border[1];
        rep.border_right = border[2];
        rep.border_bottom = border[3];
    }

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.timestamp);
        swaps(&rep.left);
        swaps(&rep.top);
        swaps(&rep.width);
        swaps(&rep.height);
        swaps(&rep.track_left);
        swaps(&rep.track_top);
        swaps(&rep.track_width);
        swaps(&rep.track_height);
        swaps(&rep.border_left);
        swaps(&rep.border_top);
        swaps(&rep.border_right);
        swaps(&rep.border_bottom);
    }
    WriteToClient(client, sizeof(xRRGetPanningReply), &rep);
    return Success;
}

int
ProcRRSetPanning(ClientPtr client)
{
    REQUEST(xRRSetPanningReq);
    xRRSetPanningReply rep;
    RRCrtcPtr crtc;
    ScreenPtr pScreen;
    rrScrPrivPtr pScrPriv;
    TimeStamp time;
    BoxRec total;
    BoxRec tracking;
    INT16 border[4];
    CARD8 status;

    REQUEST_SIZE_MATCH(xRRSetPanningReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);

    /* All crtcs must be associated with screens before client
     * requests are processed
     */
    pScreen = crtc->pScreen;
    pScrPriv = rrGetScrPriv(pScreen);

    if (!pScrPriv) {
        time = currentTime;
        status = RRSetConfigFailed;
        goto sendReply;
    }

    time = ClientTimeToServerTime(stuff->timestamp);

    if (!pScrPriv->rrGetPanning)
        return RRErrorBase + BadRRCrtc;

    total.x1 = stuff->left;
    total.y1 = stuff->top;
    total.x2 = total.x1 + stuff->width;
    total.y2 = total.y1 + stuff->height;
    tracking.x1 = stuff->track_left;
    tracking.y1 = stuff->track_top;
    tracking.x2 = tracking.x1 + stuff->track_width;
    tracking.y2 = tracking.y1 + stuff->track_height;
    border[0] = stuff->border_left;
    border[1] = stuff->border_top;
    border[2] = stuff->border_right;
    border[3] = stuff->border_bottom;

    if (!pScrPriv->rrSetPanning(pScreen, crtc, &total, &tracking, border))
        return BadMatch;

    pScrPriv->lastSetTime = time;

    status = RRSetConfigSuccess;

 sendReply:
    rep = (xRRSetPanningReply) {
        .type = X_Reply,
        .status = status,
        .sequenceNumber = client->sequence,
        .length = 0,
        .newTimestamp = pScrPriv->lastSetTime.milliseconds
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.newTimestamp);
    }
    WriteToClient(client, sizeof(xRRSetPanningReply), &rep);
    return Success;
}

int
ProcRRGetCrtcGammaSize(ClientPtr client)
{
    REQUEST(xRRGetCrtcGammaSizeReq);
    xRRGetCrtcGammaSizeReply reply;
    RRCrtcPtr crtc;

    REQUEST_SIZE_MATCH(xRRGetCrtcGammaSizeReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);

    /* Gamma retrieval failed, any better error? */
    if (!RRCrtcGammaGet(crtc))
        return RRErrorBase + BadRRCrtc;

    reply = (xRRGetCrtcGammaSizeReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .size = crtc->gammaSize
    };
    if (client->swapped) {
        swaps(&reply.sequenceNumber);
        swapl(&reply.length);
        swaps(&reply.size);
    }
    WriteToClient(client, sizeof(xRRGetCrtcGammaSizeReply), &reply);
    return Success;
}

int
ProcRRGetCrtcGamma(ClientPtr client)
{
    REQUEST(xRRGetCrtcGammaReq);
    xRRGetCrtcGammaReply reply;
    RRCrtcPtr crtc;
    unsigned long len;
    char *extra = NULL;

    REQUEST_SIZE_MATCH(xRRGetCrtcGammaReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);

    /* Gamma retrieval failed, any better error? */
    if (!RRCrtcGammaGet(crtc))
        return RRErrorBase + BadRRCrtc;

    len = crtc->gammaSize * 3 * 2;

    if (crtc->gammaSize) {
        extra = malloc(len);
        if (!extra)
            return BadAlloc;
    }

    reply = (xRRGetCrtcGammaReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(len),
        .size = crtc->gammaSize
    };
    if (client->swapped) {
        swaps(&reply.sequenceNumber);
        swapl(&reply.length);
        swaps(&reply.size);
    }
    WriteToClient(client, sizeof(xRRGetCrtcGammaReply), &reply);
    if (crtc->gammaSize) {
        memcpy(extra, crtc->gammaRed, len);
        client->pSwapReplyFunc = (ReplySwapPtr) CopySwap16Write;
        WriteSwappedDataToClient(client, len, extra);
        free(extra);
    }
    return Success;
}

int
ProcRRSetCrtcGamma(ClientPtr client)
{
    REQUEST(xRRSetCrtcGammaReq);
    RRCrtcPtr crtc;
    unsigned long len;
    CARD16 *red, *green, *blue;

    REQUEST_AT_LEAST_SIZE(xRRSetCrtcGammaReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);

    len = client->req_len - bytes_to_int32(sizeof(xRRSetCrtcGammaReq));
    if (len < (stuff->size * 3 + 1) >> 1)
        return BadLength;

    if (stuff->size != crtc->gammaSize)
        return BadMatch;

    red = (CARD16 *) (stuff + 1);
    green = red + crtc->gammaSize;
    blue = green + crtc->gammaSize;

    RRCrtcGammaSet(crtc, red, green, blue);

    return Success;
}

/* Version 1.3 additions */

int
ProcRRSetCrtcTransform(ClientPtr client)
{
    REQUEST(xRRSetCrtcTransformReq);
    RRCrtcPtr crtc;
    PictTransform transform;
    struct pixman_f_transform f_transform, f_inverse;
    char *filter;
    int nbytes;
    xFixed *params;
    int nparams;

    REQUEST_AT_LEAST_SIZE(xRRSetCrtcTransformReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);

    PictTransform_from_xRenderTransform(&transform, &stuff->transform);
    pixman_f_transform_from_pixman_transform(&f_transform, &transform);
    if (!pixman_f_transform_invert(&f_inverse, &f_transform))
        return BadMatch;

    filter = (char *) (stuff + 1);
    nbytes = stuff->nbytesFilter;
    params = (xFixed *) (filter + pad_to_int32(nbytes));
    nparams = ((xFixed *) stuff + client->req_len) - params;
    if (nparams < 0)
        return BadLength;

    return RRCrtcTransformSet(crtc, &transform, &f_transform, &f_inverse,
                              filter, nbytes, params, nparams);
}

#define CrtcTransformExtra	(SIZEOF(xRRGetCrtcTransformReply) - 32)

static int
transform_filter_length(RRTransformPtr transform)
{
    int nbytes, nparams;

    if (transform->filter == NULL)
        return 0;
    nbytes = strlen(transform->filter->name);
    nparams = transform->nparams;
    return pad_to_int32(nbytes) + (nparams * sizeof(xFixed));
}

static int
transform_filter_encode(ClientPtr client, char *output,
                        CARD16 *nbytesFilter,
                        CARD16 *nparamsFilter, RRTransformPtr transform)
{
    int nbytes, nparams;

    if (transform->filter == NULL) {
        *nbytesFilter = 0;
        *nparamsFilter = 0;
        return 0;
    }
    nbytes = strlen(transform->filter->name);
    nparams = transform->nparams;
    *nbytesFilter = nbytes;
    *nparamsFilter = nparams;
    memcpy(output, transform->filter->name, nbytes);
    while ((nbytes & 3) != 0)
        output[nbytes++] = 0;
    memcpy(output + nbytes, transform->params, nparams * sizeof(xFixed));
    if (client->swapped) {
        swaps(nbytesFilter);
        swaps(nparamsFilter);
        SwapLongs((CARD32 *) (output + nbytes), nparams);
    }
    nbytes += nparams * sizeof(xFixed);
    return nbytes;
}

static void
transform_encode(ClientPtr client, xRenderTransform * wire,
                 PictTransform * pict)
{
    xRenderTransform_from_PictTransform(wire, pict);
    if (client->swapped)
        SwapLongs((CARD32 *) wire, bytes_to_int32(sizeof(xRenderTransform)));
}

int
ProcRRGetCrtcTransform(ClientPtr client)
{
    REQUEST(xRRGetCrtcTransformReq);
    xRRGetCrtcTransformReply *reply;
    RRCrtcPtr crtc;
    int nextra;
    RRTransformPtr current, pending;
    char *extra;

    REQUEST_SIZE_MATCH(xRRGetCrtcTransformReq);
    VERIFY_RR_CRTC(stuff->crtc, crtc, DixReadAccess);

    pending = &crtc->client_pending_transform;
    current = &crtc->client_current_transform;

    nextra = (transform_filter_length(pending) +
              transform_filter_length(current));

    reply = calloc(1, sizeof(xRRGetCrtcTransformReply) + nextra);
    if (!reply)
        return BadAlloc;

    extra = (char *) (reply + 1);
    reply->type = X_Reply;
    reply->sequenceNumber = client->sequence;
    reply->length = bytes_to_int32(CrtcTransformExtra + nextra);

    reply->hasTransforms = crtc->transforms;

    transform_encode(client, &reply->pendingTransform, &pending->transform);
    extra += transform_filter_encode(client, extra,
                                     &reply->pendingNbytesFilter,
                                     &reply->pendingNparamsFilter, pending);

    transform_encode(client, &reply->currentTransform, &current->transform);
    extra += transform_filter_encode(client, extra,
                                     &reply->currentNbytesFilter,
                                     &reply->currentNparamsFilter, current);

    if (client->swapped) {
        swaps(&reply->sequenceNumber);
        swapl(&reply->length);
    }
    WriteToClient(client, sizeof(xRRGetCrtcTransformReply) + nextra, reply);
    free(reply);
    return Success;
}

static Bool
check_all_screen_crtcs(ScreenPtr pScreen, int *x, int *y)
{
    rrScrPriv(pScreen);
    int i;
    for (i = 0; i < pScrPriv->numCrtcs; i++) {
        RRCrtcPtr crtc = pScrPriv->crtcs[i];

        int left, right, top, bottom;

        if (!crtc->mode)
            continue;

        crtc_bounds(crtc, &left, &right, &top, &bottom);

        if ((*x >= left) && (*x < right) && (*y >= top) && (*y < bottom))
            return TRUE;
    }
    return FALSE;
}

static Bool
constrain_all_screen_crtcs(DeviceIntPtr pDev, ScreenPtr pScreen, int *x, int *y)
{
    rrScrPriv(pScreen);
    int i;

    /* if we're trying to escape, clamp to the CRTC we're coming from */
    for (i = 0; i < pScrPriv->numCrtcs; i++) {
        RRCrtcPtr crtc = pScrPriv->crtcs[i];
        int nx, ny;
        int left, right, top, bottom;

        if (!crtc->mode)
            continue;

        crtc_bounds(crtc, &left, &right, &top, &bottom);
        miPointerGetPosition(pDev, &nx, &ny);

        if ((nx >= left) && (nx < right) && (ny >= top) && (ny < bottom)) {
            if (*x < left)
                *x = left;
            if (*x >= right)
                *x = right - 1;
            if (*y < top)
                *y = top;
            if (*y >= bottom)
                *y = bottom - 1;

            return TRUE;
        }
    }
    return FALSE;
}

void
RRConstrainCursorHarder(DeviceIntPtr pDev, ScreenPtr pScreen, int mode, int *x,
                        int *y)
{
    rrScrPriv(pScreen);
    Bool ret;
    ScreenPtr slave;

    /* intentional dead space -> let it float */
    if (pScrPriv->discontiguous)
        return;

    /* if we're moving inside a crtc, we're fine */
    ret = check_all_screen_crtcs(pScreen, x, y);
    if (ret == TRUE)
        return;

    xorg_list_for_each_entry(slave, &pScreen->output_slave_list, output_head) {
        ret = check_all_screen_crtcs(slave, x, y);
        if (ret == TRUE)
            return;
    }

    /* if we're trying to escape, clamp to the CRTC we're coming from */
    ret = constrain_all_screen_crtcs(pDev, pScreen, x, y);
    if (ret == TRUE)
        return;

    xorg_list_for_each_entry(slave, &pScreen->output_slave_list, output_head) {
        ret = constrain_all_screen_crtcs(pDev, slave, x, y);
        if (ret == TRUE)
            return;
    }
}

Bool
RRReplaceScanoutPixmap(DrawablePtr pDrawable, PixmapPtr pPixmap, Bool enable)
{
    rrScrPriv(pDrawable->pScreen);
    Bool ret = TRUE;
    PixmapPtr *saved_scanout_pixmap;
    int i;

    saved_scanout_pixmap = malloc(sizeof(PixmapPtr)*pScrPriv->numCrtcs);
    if (saved_scanout_pixmap == NULL)
        return FALSE;

    for (i = 0; i < pScrPriv->numCrtcs; i++) {
        RRCrtcPtr crtc = pScrPriv->crtcs[i];
        Bool size_fits;

        saved_scanout_pixmap[i] = crtc->scanout_pixmap;

        if (!crtc->mode && enable)
            continue;
        if (!crtc->scanout_pixmap && !enable)
            continue;

        size_fits = (crtc->mode &&
                     crtc->x == pDrawable->x &&
                     crtc->y == pDrawable->y &&
                     crtc->mode->mode.width == pDrawable->width &&
                     crtc->mode->mode.height == pDrawable->height);

        /* is the pixmap already set? */
        if (crtc->scanout_pixmap == pPixmap) {
            /* if its a disable then don't care about size */
            if (enable == FALSE) {
                /* set scanout to NULL */
                crtc->scanout_pixmap = NULL;
            }
            else if (!size_fits) {
                /* if the size no longer fits then drop off */
                crtc->scanout_pixmap = NULL;
                pScrPriv->rrCrtcSetScanoutPixmap(crtc, crtc->scanout_pixmap);

                (*pScrPriv->rrCrtcSet) (pDrawable->pScreen, crtc, crtc->mode, crtc->x, crtc->y,
                                        crtc->rotation, crtc->numOutputs, crtc->outputs);
                saved_scanout_pixmap[i] = crtc->scanout_pixmap;
                ret = FALSE;
            }
            else {
                /* if the size fits then we are already setup */
            }
        }
        else {
            if (!size_fits)
                ret = FALSE;
            else if (enable)
                crtc->scanout_pixmap = pPixmap;
            else
                /* reject an attempt to disable someone else's scanout_pixmap */
                ret = FALSE;
        }
    }

    for (i = 0; i < pScrPriv->numCrtcs; i++) {
        RRCrtcPtr crtc = pScrPriv->crtcs[i];

        if (crtc->scanout_pixmap == saved_scanout_pixmap[i])
            continue;

        if (ret) {
            pScrPriv->rrCrtcSetScanoutPixmap(crtc, crtc->scanout_pixmap);

            (*pScrPriv->rrCrtcSet) (pDrawable->pScreen, crtc, crtc->mode, crtc->x, crtc->y,
                                    crtc->rotation, crtc->numOutputs, crtc->outputs);
        }
        else
            crtc->scanout_pixmap = saved_scanout_pixmap[i];
    }
    free(saved_scanout_pixmap);

    return ret;
}
@


1.14
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d68 2
a69 2
        crtcs = realloc(pScrPriv->crtcs,
                        (pScrPriv->numCrtcs + 1) * sizeof(RRCrtcPtr));
d179 2
a180 2
                newoutputs = realloc(crtc->outputs,
                                     numOutputs * sizeof(RROutputPtr));
d182 1
a182 1
                newoutputs = malloc(numOutputs * sizeof(RROutputPtr));
d390 1
a390 1
                     int x, int y)
d397 1
a397 1
    PixmapPtr protopix = crtc->pScreen->current_master->GetScreenPixmap(crtc->pScreen->current_master);
d437 1
a437 1
    master->StartPixmapTracking(mscreenpix, spix, x, y);
d441 19
d462 2
a463 1
                      RRCrtcPtr rr_crtc, int x, int y, int w, int h)
d480 3
a482 1
        if (pScrPriv->crtcs[c] == rr_crtc) {
a483 1
            newbox.x2 = x + w;
d485 8
a492 1
            newbox.y2 = y + h;
d494 1
a494 1
            if (!pScrPriv->crtcs[c]->mode)
d496 1
a496 4
            newbox.x1 = pScrPriv->crtcs[c]->x;
            newbox.x2 = pScrPriv->crtcs[c]->x + pScrPriv->crtcs[c]->mode->mode.width;
            newbox.y1 = pScrPriv->crtcs[c]->y;
            newbox.y2 = pScrPriv->crtcs[c]->y + pScrPriv->crtcs[c]->mode->mode.height;
d505 3
a507 1
            if (slave_priv->crtcs[c] == rr_crtc) {
a508 1
                newbox.x2 = x + w;
d510 8
a517 1
                newbox.y2 = y + h;
d520 1
a520 1
                if (!slave_priv->crtcs[c]->mode)
d522 1
a522 4
                newbox.x1 = slave_priv->crtcs[c]->x;
                newbox.x2 = slave_priv->crtcs[c]->x + slave_priv->crtcs[c]->mode->mode.width;
                newbox.y1 = slave_priv->crtcs[c]->y;
                newbox.y2 = slave_priv->crtcs[c]->y + slave_priv->crtcs[c]->mode->mode.height;
d590 1
a590 1
                                        x, y, width, height);
d595 1
a595 1
                ret = rrCreateSharedPixmap(crtc, width, height, x, y);
d827 1
a827 1
        gamma = malloc(size * 3 * sizeof(CARD16));
d1056 1
a1056 1
        outputs = malloc(numOutputs * sizeof(RROutputPtr));
d1604 2
a1605 1
static Bool check_all_screen_crtcs(ScreenPtr pScreen, int *x, int *y)
d1625 2
a1626 1
static Bool constrain_all_screen_crtcs(DeviceIntPtr pDev, ScreenPtr pScreen, int *x, int *y)
@


1.13
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d1666 2
d1669 4
a1672 3
    Bool size_fits = FALSE;
    Bool changed = FALSE;
    Bool ret = TRUE;
d1676 3
d1682 2
d1685 5
a1689 6
        changed = FALSE;
        if (crtc->mode && crtc->x == pDrawable->x &&
            crtc->y == pDrawable->y &&
            crtc->mode->mode.width == pDrawable->width &&
            crtc->mode->mode.height == pDrawable->height)
            size_fits = TRUE;
d1697 2
a1698 5
                changed = TRUE;
            } else {
                /* if the size fits then we are already setup */
                if (size_fits)
                    return TRUE;
d1701 5
a1705 1
                changed = TRUE;
d1708 5
a1712 1
        } else {
d1714 2
a1715 2
                return FALSE;
            if (enable) {
d1717 3
a1719 3
                pScrPriv->rrCrtcSetScanoutPixmap(crtc, pPixmap);
                changed = TRUE;
            }
d1721 4
d1726 4
a1729 1
        if (changed && pScrPriv->rrCrtcSet) {
d1735 2
d1738 2
@


1.12
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d431 1
a431 1
        ErrorF("failed to set shadow slave pixmap\n");
a504 1
        ErrorF("adjust shatters %d %d\n", newsize->x1, newsize->x2);
a558 1
            ErrorF("have a master to look out for\n");
a565 2
                ErrorF("need to create shared pixmap %d", ret);

@


1.11
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d98 1
a98 1
    if (!AddResource(crtc->id, RRCrtcType, (pointer) crtc))
d478 3
a480 3
        rrScrPriv(slave);
        for (c = 0; c < pScrPriv->numCrtcs; c++)
            if (pScrPriv->crtcs[c] == rr_crtc) {
d487 1
a487 1
                if (!pScrPriv->crtcs[c]->mode)
d489 4
a492 4
                newbox.x1 = pScrPriv->crtcs[c]->x;
                newbox.x2 = pScrPriv->crtcs[c]->x + pScrPriv->crtcs[c]->mode->mode.width;
                newbox.y1 = pScrPriv->crtcs[c]->y;
                newbox.y2 = pScrPriv->crtcs[c]->y + pScrPriv->crtcs[c]->mode->mode.height;
d494 3
a496 2
        RegionInit(&new_crtc_region, &newbox, 1);
        RegionUnion(&total_region, &total_region, &new_crtc_region);
a506 1
        rrScrPriv(pScreen);
d526 2
d531 8
d546 2
a547 1
        !RRCrtcPendingProperties(crtc) && !RRCrtcPendingTransform(crtc)) {
a618 1
            int o;
d667 1
a667 1
RRCrtcDestroyResource(pointer value, XID pid)
d1039 1
a1039 1
        ret = dixLookupResourceByType((pointer *) (outputs + i), outputIds[i],
@


1.10
log
@Update to xserver 1.14.5
@
text
@a367 1
    int ret;
d373 1
a373 1
    ret = pScrPriv->rrCrtcSetScanoutPixmap(crtc, NULL);
d446 1
a446 1
    int i, c;
a505 1
        int ret;
d507 1
a507 2
        ret = pScrPriv->rrScreenSetSize(pScreen,
                                           new_width, new_height, 0, 0);
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d42 1
a42 1
        pScrPriv->changed = TRUE;
d105 2
d677 2
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a238 1
    xRRCrtcChangeNotifyEvent ce;
d241 13
a253 20
    ce.type = RRNotify + RREventBase;
    ce.subCode = RRNotify_CrtcChange;
    ce.timestamp = pScrPriv->lastSetTime.milliseconds;
    ce.window = pWin->drawable.id;
    ce.crtc = crtc->id;
    ce.rotation = crtc->rotation;
    if (mode) {
        ce.mode = mode->mode.id;
        ce.x = crtc->x;
        ce.y = crtc->y;
        ce.width = mode->mode.width;
        ce.height = mode->mode.height;
    }
    else {
        ce.mode = None;
        ce.x = 0;
        ce.y = 0;
        ce.width = 0;
        ce.height = 0;
    }
d362 153
d542 20
d676 3
d900 7
a906 5
    rep.type = X_Reply;
    rep.status = RRSetConfigSuccess;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.timestamp = pScrPriv->lastSetTime.milliseconds;
d977 1
a977 1
    WriteToClient(client, sizeof(xRRGetCrtcInfoReply), (char *) &rep);
d979 1
a979 1
        WriteToClient(client, extraLen, (char *) extra);
a997 1
    TimeStamp configTime;
d1000 2
a1001 1
    int rc, i, j;
d1028 1
a1028 1
        rc = dixLookupResourceByType((pointer *) (outputs + i), outputIds[i],
d1030 1
a1030 1
        if (rc != Success) {
d1032 1
a1032 1
            return rc;
a1076 1
    configTime = ClientTimeToServerTime(stuff->configTimestamp);
d1080 1
a1080 1
        rep.status = RRSetConfigFailed;
d1128 10
d1147 1
a1147 1
            if (stuff->x + source_width > pScreen->width) {
d1153 1
a1153 1
            if (stuff->y + source_height > pScreen->height) {
d1164 1
a1164 1
        rep.status = RRSetConfigFailed;
d1167 1
a1167 1
    rep.status = RRSetConfigSuccess;
d1173 7
a1179 5
    rep.type = X_Reply;
    /* rep.status has already been filled in */
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.newTimestamp = pScrPriv->lastSetTime.milliseconds;
d1186 1
a1186 1
    WriteToClient(client, sizeof(xRRSetCrtcConfigReply), (char *) &rep);
d1215 7
a1221 6
    memset(&rep, 0, sizeof(rep));
    rep.type = X_Reply;
    rep.status = RRSetConfigSuccess;
    rep.sequenceNumber = client->sequence;
    rep.length = 1;
    rep.timestamp = pScrPriv->lastSetTime.milliseconds;
d1256 1
a1256 1
    WriteToClient(client, sizeof(xRRGetPanningReply), (char *) &rep);
d1272 1
d1285 1
a1285 1
        rep.status = RRSetConfigFailed;
d1312 1
a1312 1
    rep.status = RRSetConfigSuccess;
d1315 7
a1321 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.newTimestamp = pScrPriv->lastSetTime.milliseconds;
d1328 1
a1328 1
    WriteToClient(client, sizeof(xRRSetPanningReply), (char *) &rep);
d1346 6
a1351 4
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = 0;
    reply.size = crtc->gammaSize;
d1357 1
a1357 1
    WriteToClient(client, sizeof(xRRGetCrtcGammaSizeReply), (char *) &reply);
d1385 6
a1390 4
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = bytes_to_int32(len);
    reply.size = crtc->gammaSize;
d1396 1
a1396 1
    WriteToClient(client, sizeof(xRRGetCrtcGammaReply), (char *) &reply);
d1537 1
a1537 1
    reply = malloc(sizeof(xRRGetCrtcTransformReply) + nextra);
d1562 1
a1562 2
    WriteToClient(client, sizeof(xRRGetCrtcTransformReply) + nextra,
                  (char *) reply);
d1567 1
a1567 3
void
RRConstrainCursorHarder(DeviceIntPtr pDev, ScreenPtr pScreen, int mode, int *x,
                        int *y)
a1570 6

    /* intentional dead space -> let it float */
    if (pScrPriv->discontiguous)
        return;

    /* if we're moving inside a crtc, we're fine */
d1582 1
a1582 1
            return;
d1584 7
d1614 26
d1641 67
d1710 1
@


1.7
log
@Bugfix Update to xserver 1.11.3
@
text
@d28 1
a28 1
RESTYPE	RRCrtcType;
d34 1
a34 1
RRCrtcChanged (RRCrtcPtr crtc, Bool layoutChanged)
d36 1
a36 1
    ScreenPtr	pScreen = crtc->pScreen;
d39 9
a47 10
    if (pScreen)
    {
	rrScrPriv(pScreen);
    
	pScrPriv->changed = TRUE;
	/*
	 * Send ConfigureNotify on any layout change
	 */
	if (layoutChanged)
	    pScrPriv->layoutChanged = TRUE;
d55 1
a55 1
RRCrtcCreate (ScreenPtr pScreen, void *devPrivate)
d57 3
a59 3
    RRCrtcPtr	    crtc;
    RRCrtcPtr	    *crtcs;
    rrScrPrivPtr    pScrPriv;
d62 2
a63 2
	return NULL;
    
d68 2
a69 2
	crtcs = realloc(pScrPriv->crtcs, 
			  (pScrPriv->numCrtcs + 1) * sizeof (RRCrtcPtr));
d71 1
a71 1
	crtcs = malloc(sizeof (RRCrtcPtr));
d73 1
a73 1
	return FALSE;
d75 2
a76 2
    
    crtc = calloc(1, sizeof (RRCrtcRec));
d78 2
a79 2
	return NULL;
    crtc->id = FakeClientID (0);
d92 5
a96 5
    RRTransformInit (&crtc->client_pending_transform);
    RRTransformInit (&crtc->client_current_transform);
    pixman_transform_init_identity (&crtc->transform);
    pixman_f_transform_init_identity (&crtc->f_transform);
    pixman_f_transform_init_identity (&crtc->f_inverse);
d98 2
a99 2
    if (!AddResource (crtc->id, RRCrtcType, (pointer) crtc))
	return NULL;
d104 1
a104 1
    
d112 1
a112 1
RRCrtcSetRotations (RRCrtcPtr crtc, Rotation rotations)
d121 1
a121 1
RRCrtcSetTransformSupport (RRCrtcPtr crtc, Bool transforms)
d131 6
a136 8
RRCrtcNotify (RRCrtcPtr	    crtc,
	      RRModePtr	    mode,
	      int	    x,
	      int	    y,
	      Rotation	    rotation,
	      RRTransformPtr transform,
	      int	    numOutputs,
	      RROutputPtr   *outputs)
d138 2
a139 2
    int	    i, j;
    
d144 9
a152 11
    for (i = 0; i < numOutputs; i++)
    {
	for (j = 0; j < crtc->numOutputs; j++)
	    if (outputs[i] == crtc->outputs[j])
		break;
	if (j == crtc->numOutputs)
	{
	    outputs[i]->crtc = crtc;
	    RROutputChanged (outputs[i], FALSE);
	    RRCrtcChanged (crtc, FALSE);
	}
d158 10
a167 12
    for (j = 0; j < crtc->numOutputs; j++)
    {
	for (i = 0; i < numOutputs; i++)
	    if (outputs[i] == crtc->outputs[j])
		break;
	if (i == numOutputs)
	{
	    if (crtc->outputs[j]->crtc == crtc)
		crtc->outputs[j]->crtc = NULL;
	    RROutputChanged (crtc->outputs[j], FALSE);
	    RRCrtcChanged (crtc, FALSE);
	}
d172 18
a189 21
    if (numOutputs != crtc->numOutputs)
    {
	RROutputPtr *newoutputs;
	
	if (numOutputs)
	{
	    if (crtc->numOutputs)
		newoutputs = realloc(crtc->outputs,
				    numOutputs * sizeof (RROutputPtr));
	    else
		newoutputs = malloc(numOutputs * sizeof (RROutputPtr));
	    if (!newoutputs)
		return FALSE;
	}
	else
	{
	    free(crtc->outputs);
	    newoutputs = NULL;
	}
	crtc->outputs = newoutputs;
	crtc->numOutputs = numOutputs;
d194 1
a194 1
    memcpy (crtc->outputs, outputs, numOutputs * sizeof (RROutputPtr));
d198 31
a228 36
    if (mode != crtc->mode)
    {
	if (crtc->mode)
	    RRModeDestroy (crtc->mode);
	crtc->mode = mode;
	if (mode != NULL)
	    mode->refcnt++;
	RRCrtcChanged (crtc, TRUE);
    }
    if (x != crtc->x)
    {
	crtc->x = x;
	RRCrtcChanged (crtc, TRUE);
    }
    if (y != crtc->y)
    {
	crtc->y = y;
	RRCrtcChanged (crtc, TRUE);
    }
    if (rotation != crtc->rotation)
    {
	crtc->rotation = rotation;
	RRCrtcChanged (crtc, TRUE);
    }
    if (!RRTransformEqual (transform, &crtc->client_current_transform)) {
	RRTransformCopy (&crtc->client_current_transform, transform);
	RRCrtcChanged (crtc, TRUE);
    }
    if (crtc->changed && mode)
    {
	RRTransformCompute (x, y,
			    mode->mode.width, mode->mode.height,
			    rotation,
			    &crtc->client_current_transform,
			    &crtc->transform, &crtc->f_transform,
			    &crtc->f_inverse);
d234 1
a234 1
RRDeliverCrtcEvent (ClientPtr client, WindowPtr pWin, RRCrtcPtr crtc)
d237 5
a241 4
    rrScrPriv (pScreen);
    xRRCrtcChangeNotifyEvent	ce;
    RRModePtr	mode = crtc->mode;
    
d248 13
a260 15
    if (mode)
    {
	ce.mode = mode->mode.id;
	ce.x = crtc->x;
	ce.y = crtc->y;
	ce.width = mode->mode.width;
	ce.height = mode->mode.height;
    }
    else
    {
	ce.mode = None;
	ce.x = 0;
	ce.y = 0;
	ce.width = 0;
	ce.height = 0;
d262 1
a262 1
    WriteEventsToClient (client, 1, (xEvent *) &ce);
d266 1
a266 1
RRCrtcPendingProperties (RRCrtcPtr crtc)
d268 2
a269 1
    ScreenPtr	pScreen = crtc->pScreen;
d271 4
a274 1
    int		o;
d276 2
a277 5
    for (o = 0; o < pScrPriv->numOutputs; o++)
    {
	RROutputPtr output = pScrPriv->outputs[o];
	if (output->crtc == crtc && output->pendingProperties)
	    return TRUE;
d292 3
a294 3
       *right = crtc->x + crtc->mode->mode.width;
       *bottom = crtc->y + crtc->mode->mode.height;
       return;
d297 3
a299 3
       *right = crtc->x + crtc->mode->mode.height;
       *bottom = crtc->y + crtc->mode->mode.width;
       return;
d310 1
a310 1
    int cl, cr, ct, cb; /* the overlap, if any */
d325 1
a325 1
mark_crtcs (rrScrPrivPtr pScrPriv, int *reachable, int cur)
d328 1
d339 1
a339 1
RRComputeContiguity (ScreenPtr pScreen)
d346 1
d365 1
a365 1
out:
d374 9
a382 11
RRCrtcSet (RRCrtcPtr    crtc,
	   RRModePtr	mode,
	   int		x,
	   int		y,
	   Rotation	rotation,
	   int		numOutputs,
	   RROutputPtr  *outputs)
{
    ScreenPtr	pScreen = crtc->pScreen;
    Bool	ret = FALSE;
    Bool	recompute = TRUE;
d387 8
a394 10
	crtc->x == x &&
	crtc->y == y &&
	crtc->rotation == rotation &&
	crtc->numOutputs == numOutputs &&
	!memcmp (crtc->outputs, outputs, numOutputs * sizeof (RROutputPtr)) &&
	!RRCrtcPendingProperties (crtc) &&
	!RRCrtcPendingTransform (crtc))
    {
	recompute = FALSE;
	ret = TRUE;
d396 1
a396 2
    else
    {
d398 5
a402 6
	if (pScrPriv->rrCrtcSet)
	{
	    ret = (*pScrPriv->rrCrtcSet) (pScreen, crtc, mode, x, y, 
					  rotation, numOutputs, outputs);
	}
	else
d404 1
a404 1
	{
d406 35
a440 38
	    if (pScrPriv->rrSetConfig)
	    {
		RRScreenSize	    size;
		RRScreenRate	    rate;

		if (!mode)
		{
		    RRCrtcNotify (crtc, NULL, x, y, rotation, NULL, 0, NULL);
		    ret = TRUE;
		}
		else
		{
		    size.width = mode->mode.width;
		    size.height = mode->mode.height;
		    if (outputs[0]->mmWidth && outputs[0]->mmHeight)
		    {
			size.mmWidth = outputs[0]->mmWidth;
			size.mmHeight = outputs[0]->mmHeight;
		    }
		    else
		    {
			size.mmWidth = pScreen->mmWidth;
			size.mmHeight = pScreen->mmHeight;
		    }
		    size.nRates = 1;
		    rate.rate = RRVerticalRefresh (&mode->mode);
		    size.pRates = &rate;
		    ret = (*pScrPriv->rrSetConfig) (pScreen, rotation, rate.rate, &size);
		    /*
		     * Old 1.0 interface tied screen size to mode size
		     */
		    if (ret)
		    {
			RRCrtcNotify (crtc, mode, x, y, rotation, NULL, 1, outputs);
			RRScreenSizeNotify (pScreen);
		    }
		}
	    }
d442 9
a450 9
	}
	if (ret)
	{
	    int	o;
	    RRTellChanged (pScreen);

	    for (o = 0; o < numOutputs; o++)
		RRPostPendingProperties (outputs[o]);
	}
d454 1
a454 1
       RRComputeContiguity(pScreen);
d463 1
a463 1
RRCrtcGetTransform (RRCrtcPtr crtc)
d465 1
a465 1
    RRTransformPtr  transform = &crtc->client_pending_transform;
d467 2
a468 2
    if (pixman_transform_is_identity (&transform->transform))
	return NULL;
d476 1
a476 1
RRCrtcPendingTransform (RRCrtcPtr crtc)
d478 3
a480 3
    return memcmp (&crtc->client_current_transform.transform,
		   &crtc->client_pending_transform.transform,
		   sizeof (PictTransform)) != 0;
d487 1
a487 1
RRCrtcDestroy (RRCrtcPtr crtc)
d489 1
a489 1
    FreeResource (crtc->id, 0);
d493 1
a493 1
RRCrtcDestroyResource (pointer value, XID pid)
d495 6
a500 2
    RRCrtcPtr	crtc = (RRCrtcPtr) value;
    ScreenPtr	pScreen = crtc->pScreen;
d502 8
a509 15
    if (pScreen)
    {
	rrScrPriv(pScreen);
	int		i;
    
	for (i = 0; i < pScrPriv->numCrtcs; i++)
	{
	    if (pScrPriv->crtcs[i] == crtc)
	    {
		memmove (pScrPriv->crtcs + i, pScrPriv->crtcs + i + 1,
			 (pScrPriv->numCrtcs - (i + 1)) * sizeof (RRCrtcPtr));
		--pScrPriv->numCrtcs;
		break;
	    }
	}
d513 1
a513 1
	RRModeDestroy (crtc->mode);
d523 1
a523 4
RRCrtcGammaSet (RRCrtcPtr   crtc,
		CARD16	    *red,
		CARD16	    *green,
		CARD16	    *blue)
d525 2
a526 1
    Bool	ret = TRUE;
d528 1
a528 1
    ScreenPtr	pScreen = crtc->pScreen;
d530 4
a533 4
    
    memcpy (crtc->gammaRed, red, crtc->gammaSize * sizeof (CARD16));
    memcpy (crtc->gammaGreen, green, crtc->gammaSize * sizeof (CARD16));
    memcpy (crtc->gammaBlue, blue, crtc->gammaSize * sizeof (CARD16));
d535 4
a538 5
    if (pScreen)
    {
	rrScrPriv(pScreen);
	if (pScrPriv->rrCrtcSetGamma)
	    ret = (*pScrPriv->rrCrtcSetGamma) (pScreen, crtc);
d552 1
d554 1
a554 1
    ScreenPtr	pScreen = crtc->pScreen;
d558 1
a558 2
    if (pScreen)
    {
d574 1
a574 1
RRCrtcGammaNotify (RRCrtcPtr	crtc)
d576 1
a576 1
    return TRUE;    /* not much going on here */
d580 2
a581 2
RRModeGetScanoutSize (RRModePtr mode, PictTransformPtr transform,
		      int *width, int *height)
d583 1
a583 1
    BoxRec  box;
d586 3
a588 3
	*width = 0;
	*height = 0;
	return;
d596 1
a596 1
    pixman_transform_bounds (transform, &box);
d607 1
a607 1
    RRModeGetScanoutSize (crtc->mode, &crtc->transform, width, height);
d615 1
a615 2
RRCrtcGammaSetSize (RRCrtcPtr	crtc,
		    int		size)
d617 1
a617 1
    CARD16  *gamma;
d620 5
a624 6
	return TRUE;
    if (size)
    {
	gamma = malloc(size * 3 * sizeof (CARD16));
	if (!gamma)
	    return FALSE;
d627 1
a627 1
	gamma = NULL;
d631 1
a631 1
    crtc->gammaBlue = gamma + size*2;
d641 6
a646 8
RRCrtcTransformSet (RRCrtcPtr		crtc,
		    PictTransformPtr	transform,
		    struct pixman_f_transform *f_transform,
		    struct pixman_f_transform *f_inverse,
		    char		*filter_name,
		    int			filter_len,
		    xFixed		*params,
		    int			nparams)
d648 2
a649 2
    PictFilterPtr   filter = NULL;
    int		    width = 0, height = 0;
d652 1
a652 1
	return BadValue;
d654 13
a666 22
    if (filter_len)
    {
	filter = PictureFindFilter (crtc->pScreen,
				    filter_name,
				    filter_len);
	if (!filter)
	    return BadName;
	if (filter->ValidateParams)
	{
	    if (!filter->ValidateParams (crtc->pScreen, filter->id,
					 params, nparams, &width, &height))
		return BadMatch;
	}
	else {
	    width = filter->width;
	    height = filter->height;
	}
    }
    else
    {
	if (nparams)
	    return BadMatch;
d668 7
a674 3
    if (!RRTransformSetFilter (&crtc->client_pending_transform,
			       filter, params, nparams, width, height))
	return BadAlloc;
d686 1
a686 1
RRCrtcInit (void)
d688 1
a688 1
    RRCrtcType = CreateNewResourceType (RRCrtcDestroyResource, "CRTC");
d690 2
a691 2
	return FALSE;
    
d705 1
a705 1
ProcRRGetCrtcInfo (ClientPtr client)
d708 13
a720 13
    xRRGetCrtcInfoReply	rep;
    RRCrtcPtr			crtc;
    CARD8			*extra;
    unsigned long		extraLen;
    ScreenPtr			pScreen;
    rrScrPrivPtr		pScrPriv;
    RRModePtr			mode;
    RROutput			*outputs;
    RROutput			*possible;
    int				i, j, k, n;
    int				width, height;
    BoxRec			panned_area;
    
d731 1
a731 1
    
d738 2
a739 2
	pScrPriv->rrGetPanning (pScreen, crtc, &panned_area, NULL, NULL) &&
	(panned_area.x2 > panned_area.x1) && (panned_area.y2 > panned_area.y1))
d741 11
a751 12
 	rep.x = panned_area.x1;
	rep.y = panned_area.y1;
	rep.width = panned_area.x2 - panned_area.x1;
	rep.height = panned_area.y2 - panned_area.y1;
    }
    else
    {
	RRCrtcGetScanoutSize (crtc, &width, &height);
	rep.x = crtc->x;
	rep.y = crtc->y;
	rep.width = width;
	rep.height = height;
d759 3
a761 3
	for (j = 0; j < pScrPriv->outputs[i]->numCrtcs; j++)
	    if (pScrPriv->outputs[i]->crtcs[j] == crtc)
		k++;
d763 1
a763 1
    
d767 4
a770 5
    if (extraLen)
    {
	extra = malloc(extraLen);
	if (!extra)
	    return BadAlloc;
d773 1
a773 1
	extra = NULL;
d777 5
a781 6
    
    for (i = 0; i < crtc->numOutputs; i++)
    {
	outputs[i] = crtc->outputs[i]->id;
	if (client->swapped)
	    swapl (&outputs[i], n);
d785 8
a792 9
	for (j = 0; j < pScrPriv->outputs[i]->numCrtcs; j++)
	    if (pScrPriv->outputs[i]->crtcs[j] == crtc)
	    {
		possible[k] = pScrPriv->outputs[i]->id;
		if (client->swapped)
		    swapl (&possible[k], n);
		k++;
	    }
    
d794 17
a810 12
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.timestamp, n);
	swaps(&rep.x, n);
	swaps(&rep.y, n);
	swaps(&rep.width, n);
	swaps(&rep.height, n);
	swapl(&rep.mode, n);
	swaps(&rep.rotation, n);
	swaps(&rep.rotations, n);
	swaps(&rep.nOutput, n);
	swaps(&rep.nPossibleOutput, n);
d812 1
a812 7
    WriteToClient(client, sizeof(xRRGetCrtcInfoReply), (char *)&rep);
    if (extraLen)
    {
	WriteToClient (client, extraLen, (char *) extra);
	free(extra);
    }
    
d817 1
a817 1
ProcRRSetCrtcConfig (ClientPtr client)
d820 13
a832 13
    xRRSetCrtcConfigReply   rep;
    ScreenPtr		    pScreen;
    rrScrPrivPtr	    pScrPriv;
    RRCrtcPtr		    crtc;
    RRModePtr		    mode;
    int			    numOutputs;
    RROutputPtr		    *outputs = NULL;
    RROutput		    *outputIds;
    TimeStamp		    configTime;
    TimeStamp		    time;
    Rotation		    rotation;
    int			    rc, i, j;
    
d834 2
a835 2
    numOutputs = (stuff->length - bytes_to_int32(SIZEOF (xRRSetCrtcConfigReq)));
    
d838 14
a851 5
    if (stuff->mode == None)
    {
	mode = NULL;
	if (numOutputs > 0)
	    return BadMatch;
d854 2
a855 14
    {
	VERIFY_RR_MODE(stuff->mode, mode, DixSetAttrAccess);
	if (numOutputs == 0)
	    return BadMatch;
    }
    if (numOutputs)
    {
	outputs = malloc(numOutputs * sizeof (RROutputPtr));
	if (!outputs)
	    return BadAlloc;
    }
    else
	outputs = NULL;
    
d857 27
a883 32
    for (i = 0; i < numOutputs; i++)
    {
	rc = dixLookupResourceByType((pointer *)(outputs + i), outputIds[i],
				     RROutputType, client, DixSetAttrAccess);
	if (rc != Success)
	{
	    free(outputs);
	    return rc;
	}
	/* validate crtc for this output */
	for (j = 0; j < outputs[i]->numCrtcs; j++)
	    if (outputs[i]->crtcs[j] == crtc)
		break;
	if (j == outputs[i]->numCrtcs)
	{
	    free(outputs);
	    return BadMatch;
	}
	/* validate mode for this output */
	for (j = 0; j < outputs[i]->numModes + outputs[i]->numUserModes; j++)
	{
	    RRModePtr	m = (j < outputs[i]->numModes ? 
			     outputs[i]->modes[j] :
			     outputs[i]->userModes[j - outputs[i]->numModes]);
	    if (m == mode)
		break;
	}
	if (j == outputs[i]->numModes + outputs[i]->numUserModes)
	{
	    free(outputs);
	    return BadMatch;
	}
d886 15
a900 18
    for (i = 0; i < numOutputs; i++)
    {
	for (j = 0; j < numOutputs; j++)
	{
	    int k;
	    if (i == j)
		continue;
	    for (k = 0; k < outputs[i]->numClones; k++)
	    {
		if (outputs[i]->clones[k] == outputs[j])
		    break;
	    }
	    if (k == outputs[i]->numClones)
	    {
		free(outputs);
		return BadMatch;
	    }
	}
d905 1
a905 1
    
d908 5
a912 6
    
    if (!pScrPriv)
    {
	time = currentTime;
	rep.status = RRSetConfigFailed;
	goto sendReply;
d914 1
a914 1
    
d926 1
a926 1
	break;
d928 17
a944 7
	/*
	 * Invalid rotation
	 */
	client->errorValue = stuff->rotation;
	free(outputs);
	return BadValue;
    }
a945 12
    if (mode)
    {
	if ((~crtc->rotations) & rotation)
	{
	    /*
	     * requested rotation or reflection not supported by screen
	     */
	    client->errorValue = stuff->rotation;
	    free(outputs);
	    return BadMatch;
	}
    
d947 33
a979 35
	/*
	 * Check screen size bounds if the DDX provides a 1.2 interface
	 * for setting screen size. Else, assume the CrtcSet sets
	 * the size along with the mode. If the driver supports transforms,
	 * then it must allow crtcs to display a subset of the screen, so
	 * only do this check for drivers without transform support.
	 */
	if (pScrPriv->rrScreenSetSize && !crtc->transforms)
	{
	    int source_width;
	    int	source_height;
	    PictTransform transform;
	    struct pixman_f_transform f_transform, f_inverse;

	    RRTransformCompute (stuff->x, stuff->y,
				mode->mode.width, mode->mode.height,
				rotation,
				&crtc->client_pending_transform,
				&transform, &f_transform, &f_inverse);

	    RRModeGetScanoutSize (mode, &transform, &source_width, &source_height);
	    if (stuff->x + source_width > pScreen->width)
	    {
		client->errorValue = stuff->x;
		free(outputs);
		return BadValue;
	    }
	    
	    if (stuff->y + source_height > pScreen->height)
	    {
		client->errorValue = stuff->y;
		free(outputs);
		return BadValue;
	    }
	}
d982 5
a986 6
    
    if (!RRCrtcSet (crtc, mode, stuff->x, stuff->y,
		   rotation, numOutputs, outputs))
    {
	rep.status = RRSetConfigFailed;
	goto sendReply;
d990 2
a991 2
    
sendReply:
d993 1
a993 1
    
d1000 4
a1003 6
    if (client->swapped) 
    {
	int n;
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.newTimestamp, n);
d1005 2
a1006 2
    WriteToClient(client, sizeof(xRRSetCrtcConfigReply), (char *)&rep);
    
d1011 1
a1011 1
ProcRRGetPanning (ClientPtr client)
d1014 8
a1021 9
    xRRGetPanningReply	rep;
    RRCrtcPtr		crtc;
    ScreenPtr		pScreen;
    rrScrPrivPtr	pScrPriv;
    BoxRec		total;
    BoxRec		tracking;
    INT16		border[4];
    int			n;
    
d1032 1
a1032 1
	return RRErrorBase + BadRRCrtc;
d1042 13
a1054 13
	pScrPriv->rrGetPanning (pScreen, crtc, &total, &tracking, border)) {
	rep.left          = total.x1;
	rep.top           = total.y1;
	rep.width         = total.x2 - total.x1;
	rep.height        = total.y2 - total.y1;
	rep.track_left    = tracking.x1;
	rep.track_top     = tracking.y1;
	rep.track_width   = tracking.x2 - tracking.x1;
	rep.track_height  = tracking.y2 - tracking.y1;
	rep.border_left   = border[0];
	rep.border_top    = border[1];
	rep.border_right  = border[2];
	rep.border_bottom = border[3];
d1058 15
a1072 15
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swaps(&rep.timestamp, n);
	swaps(&rep.left, n);
	swaps(&rep.top, n);
	swaps(&rep.width, n);
	swaps(&rep.height, n);
	swaps(&rep.track_left, n);
	swaps(&rep.track_top, n);
	swaps(&rep.track_width, n);
	swaps(&rep.track_height, n);
	swaps(&rep.border_left, n);
	swaps(&rep.border_top, n);
	swaps(&rep.border_right, n);
	swaps(&rep.border_bottom, n);
d1074 1
a1074 1
    WriteToClient(client, sizeof(xRRGetPanningReply), (char *)&rep);
d1079 1
a1079 1
ProcRRSetPanning (ClientPtr client)
d1082 9
a1090 10
    xRRSetPanningReply	rep;
    RRCrtcPtr		crtc;
    ScreenPtr		pScreen;
    rrScrPrivPtr	pScrPriv;
    TimeStamp		time;
    BoxRec		total;
    BoxRec		tracking;
    INT16		border[4];
    int			n;
    
d1101 3
a1103 3
	time = currentTime;
	rep.status = RRSetConfigFailed;
	goto sendReply;
d1105 1
a1105 1
    
d1107 1
a1107 1
    
d1109 1
a1109 1
	return RRErrorBase + BadRRCrtc;
d1111 4
a1114 4
    total.x1    = stuff->left;
    total.y1    = stuff->top;
    total.x2    = total.x1 + stuff->width;
    total.y2    = total.y1 + stuff->height;
d1119 4
a1122 4
    border[0]   = stuff->border_left;
    border[1]   = stuff->border_top;
    border[2]   = stuff->border_right;
    border[3]   = stuff->border_bottom;
d1124 2
a1125 2
    if (! pScrPriv->rrSetPanning (pScreen, crtc, &total, &tracking, border))
	return BadMatch;
d1131 1
a1131 1
sendReply:
d1138 3
a1140 3
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swaps(&rep.newTimestamp, n);
d1142 1
a1142 1
    WriteToClient(client, sizeof(xRRSetPanningReply), (char *)&rep);
d1147 1
a1147 1
ProcRRGetCrtcGammaSize (ClientPtr client)
d1150 2
a1151 3
    xRRGetCrtcGammaSizeReply	reply;
    RRCrtcPtr			crtc;
    int				n;
d1165 3
a1167 3
	swaps (&reply.sequenceNumber, n);
	swapl (&reply.length, n);
	swaps (&reply.size, n);
d1169 1
a1169 1
    WriteToClient (client, sizeof (xRRGetCrtcGammaSizeReply), (char *) &reply);
d1174 1
a1174 1
ProcRRGetCrtcGamma (ClientPtr client)
d1177 5
a1181 6
    xRRGetCrtcGammaReply	reply;
    RRCrtcPtr			crtc;
    int				n;
    unsigned long		len;
    char			*extra = NULL;
    
d1190 1
a1190 1
    
d1192 3
a1194 3
	extra = malloc(len);
	if (!extra)
	    return BadAlloc;
d1202 3
a1204 3
	swaps (&reply.sequenceNumber, n);
	swapl (&reply.length, n);
	swaps (&reply.size, n);
d1206 6
a1211 7
    WriteToClient (client, sizeof (xRRGetCrtcGammaReply), (char *) &reply);
    if (crtc->gammaSize)
    {
	memcpy(extra, crtc->gammaRed, len);
	client->pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write;
	WriteSwappedDataToClient (client, len, extra);
	free(extra);
d1217 1
a1217 1
ProcRRSetCrtcGamma (ClientPtr client)
d1220 4
a1223 4
    RRCrtcPtr			crtc;
    unsigned long		len;
    CARD16			*red, *green, *blue;
    
d1226 2
a1227 2
    
    len = client->req_len - bytes_to_int32(sizeof (xRRSetCrtcGammaReq));
d1229 1
a1229 1
	return BadLength;
d1232 2
a1233 2
	return BadMatch;
    
d1237 2
a1238 2
    
    RRCrtcGammaSet (crtc, red, green, blue);
d1246 1
a1246 1
ProcRRSetCrtcTransform (ClientPtr client)
d1249 2
a1250 2
    RRCrtcPtr		    crtc;
    PictTransform	    transform;
d1252 4
a1255 4
    char		    *filter;
    int			    nbytes;
    xFixed		    *params;
    int			    nparams;
d1260 4
a1263 4
    PictTransform_from_xRenderTransform (&transform, &stuff->transform);
    pixman_f_transform_from_pixman_transform (&f_transform, &transform);
    if (!pixman_f_transform_invert (&f_inverse, &f_transform))
	return BadMatch;
d1270 1
a1270 1
	return BadLength;
d1272 2
a1273 2
    return RRCrtcTransformSet (crtc, &transform, &f_transform, &f_inverse,
			       filter, nbytes, params, nparams);
d1276 1
a1277 2
#define CrtcTransformExtra	(SIZEOF(xRRGetCrtcTransformReply) - 32)
				
d1279 1
a1279 1
transform_filter_length (RRTransformPtr transform)
d1281 1
a1281 1
    int	nbytes, nparams;
d1284 2
a1285 2
	return 0;
    nbytes = strlen (transform->filter->name);
d1287 1
a1287 1
    return pad_to_int32(nbytes) + (nparams * sizeof (xFixed));
d1291 3
a1293 4
transform_filter_encode (ClientPtr client, char *output,
			 CARD16	*nbytesFilter,
			 CARD16	*nparamsFilter,
			 RRTransformPtr transform)
d1295 1
a1295 2
    int	    nbytes, nparams;
    int	    n;
d1298 3
a1300 3
	*nbytesFilter = 0;
	*nparamsFilter = 0;
	return 0;
d1302 1
a1302 1
    nbytes = strlen (transform->filter->name);
d1306 1
a1306 1
    memcpy (output, transform->filter->name, nbytes);
d1308 2
a1309 2
	output[nbytes++] = 0;
    memcpy (output + nbytes, transform->params, nparams * sizeof (xFixed));
d1311 3
a1313 3
	swaps (nbytesFilter, n);
	swaps (nparamsFilter, n);
	SwapLongs ((CARD32 *) (output + nbytes), nparams);
d1315 1
a1315 1
    nbytes += nparams * sizeof (xFixed);
d1320 2
a1321 1
transform_encode (ClientPtr client, xRenderTransform *wire, PictTransform *pict)
d1323 1
a1323 1
    xRenderTransform_from_PictTransform (wire, pict);
d1325 1
a1325 1
	SwapLongs ((CARD32 *) wire, bytes_to_int32(sizeof(xRenderTransform)));
d1329 1
a1329 1
ProcRRGetCrtcTransform (ClientPtr client)
d1332 5
a1336 5
    xRRGetCrtcTransformReply	*reply;
    RRCrtcPtr			crtc;
    int				n, nextra;
    RRTransformPtr		current, pending;
    char			*extra;
d1338 1
a1338 1
    REQUEST_SIZE_MATCH (xRRGetCrtcTransformReq);
d1344 2
a1345 2
    nextra = (transform_filter_length (pending) +
	      transform_filter_length (current));
d1347 1
a1347 1
    reply = malloc(sizeof (xRRGetCrtcTransformReply) + nextra);
d1349 1
a1349 1
	return BadAlloc;
d1358 9
a1366 11
    transform_encode (client, &reply->pendingTransform, &pending->transform);
    extra += transform_filter_encode (client, extra,
				      &reply->pendingNbytesFilter,
				      &reply->pendingNparamsFilter,
				      pending);

    transform_encode (client, &reply->currentTransform, &current->transform);
    extra += transform_filter_encode (client, extra,
				      &reply->currentNbytesFilter,
				      &reply->currentNparamsFilter,
				      current);
d1369 2
a1370 2
	swaps (&reply->sequenceNumber, n);
	swapl (&reply->length, n);
d1372 2
a1373 1
    WriteToClient (client, sizeof (xRRGetCrtcTransformReply) + nextra, (char *) reply);
d1379 2
a1380 1
RRConstrainCursorHarder(DeviceIntPtr pDev, ScreenPtr pScreen, int mode, int *x, int *y)
d1382 1
a1382 1
    rrScrPriv (pScreen);
d1387 1
a1387 1
       return;
d1391 1
a1391 1
       RRCrtcPtr crtc = pScrPriv->crtcs[i];
d1393 1
a1393 1
       int left, right, top, bottom;
d1395 2
a1396 2
       if (!crtc->mode)
           continue;
d1398 1
a1398 1
       crtc_bounds(crtc, &left, &right, &top, &bottom);
d1400 2
a1401 2
       if ((*x >= left) && (*x < right) && (*y >= top) && (*y < bottom))
           return;
d1406 9
a1414 19
       RRCrtcPtr crtc = pScrPriv->crtcs[i];
       int nx, ny;
       int left, right, top, bottom;

       if (!crtc->mode)
           continue;

       crtc_bounds(crtc, &left, &right, &top, &bottom);
       miPointerGetPosition(pDev, &nx, &ny);

       if ((nx >= left) && (nx < right) && (ny >= top) && (ny < bottom)) {
           if (*x < left)
               *x = left;
           if (*x >= right)
               *x = right - 1;
           if (*y < top)
               *y = top;
           if (*y >= bottom)
               *y = bottom - 1;
d1416 12
a1427 2
           return;
       }
@


1.6
log
@Update to xserver 1.11.2
@
text
@d1468 1
a1468 1
       if ((*x >= left) && (*x <= right) && (*y >= top) && (*y <= bottom))
d1484 9
a1492 18
       if ((nx >= left) && (nx <= right) && (ny >= top) && (ny <= bottom)) {
           if ((*x <= left) || (*x >= right)) {
               int dx = *x - nx;

               if (dx > 0)
                   *x = right;
               else if (dx < 0)
                   *x = left;
           }

           if ((*y <= top) || (*y >= bottom)) {
               int dy = *y - ny;

               if (dy > 0)
                   *y = bottom;
               else if (dy < 0)
                   *y = top;
           }
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d3 1
d26 1
d297 86
d397 1
d410 1
d474 4
d635 1
a635 1
    return RRModeGetScanoutSize (crtc->mode, &crtc->transform, width, height);
d1445 61
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d67 1
a67 1
	crtcs = xrealloc (pScrPriv->crtcs, 
d70 1
a70 1
	crtcs = xalloc (sizeof (RRCrtcPtr));
d75 1
a75 1
    crtc = xcalloc (1, sizeof (RRCrtcRec));
d184 1
a184 1
		newoutputs = xrealloc (crtc->outputs,
d187 1
a187 1
		newoutputs = xalloc (numOutputs * sizeof (RROutputPtr));
d193 1
a193 2
	    if (crtc->outputs)
		xfree (crtc->outputs);
a255 1
    ce.sequenceNumber = client->sequence;
d442 1
a442 2
    if (crtc->gammaRed)
	xfree (crtc->gammaRed);
d445 1
a445 1
    xfree (crtc);
d558 1
a558 1
	gamma = xalloc (size * 3 * sizeof (CARD16));
d564 1
a564 2
    if (crtc->gammaRed)
	xfree (crtc->gammaRed);
d634 1
d638 9
d713 1
a713 1
	extra = xalloc (extraLen);
d758 1
a758 1
	xfree (extra);
d761 1
a761 1
    return client->noClientException;
d800 1
a800 1
	outputs = xalloc (numOutputs * sizeof (RROutputPtr));
d814 2
a815 3
	    if (outputs)
		xfree (outputs);
	    return (rc == BadValue) ? RRErrorBase + BadRROutput : rc;
d823 1
a823 2
	    if (outputs)
		xfree (outputs);
d837 1
a837 2
	    if (outputs)
		xfree (outputs);
d856 1
a856 2
		if (outputs)
		    xfree (outputs);
a874 13
#if 0
    /*
     * if the client's config timestamp is not the same as the last config
     * timestamp, then the config information isn't up-to-date and
     * can't even be validated
     */
    if (CompareTimeStamps (configTime, pScrPriv->lastConfigTime) != 0)
    {
	rep.status = RRSetConfigInvalidConfigTime;
	goto sendReply;
    }
#endif
    
d892 1
a892 2
	if (outputs)
	    xfree (outputs);
d904 1
a904 2
	    if (outputs)
		xfree (outputs);
d933 1
a933 2
		if (outputs)
		    xfree (outputs);
d940 1
a940 2
		if (outputs)
		    xfree (outputs);
a946 10
    /*
     * Make sure the requested set-time is not older than
     * the last set-time
     */
    if (CompareTimeStamps (time, pScrPriv->lastSetTime) < 0)
    {
	rep.status = RRSetConfigInvalidTime;
	goto sendReply;
    }

d957 1
a957 2
    if (outputs)
	xfree (outputs);
d974 1
a974 1
    return client->noClientException;
d1043 1
a1043 1
    return client->noClientException;
a1076 10
    /*
     * Make sure the requested set-time is not older than
     * the last set-time
     */
    if (CompareTimeStamps (time, pScrPriv->lastSetTime) < 0)
    {
	rep.status = RRSetConfigInvalidTime;
	goto sendReply;
    }

d1112 1
a1112 1
    return client->noClientException;
d1140 1
a1140 1
    return client->noClientException;
d1163 1
a1163 1
	extra = xalloc(len);
d1183 1
a1183 1
	xfree(extra);
d1185 1
a1185 1
    return client->noClientException;
d1321 1
a1321 1
    reply = xalloc (sizeof (xRRGetCrtcTransformReply) + nextra);
d1349 2
a1350 2
    xfree(reply);
    return client->noClientException;
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a24 1
#include "registry.h"
d482 23
d635 1
a635 1
    RRCrtcType = CreateNewResourceType (RRCrtcDestroyResource);
a637 1
    RegisterResourceName (RRCrtcType, "CRTC");
d659 1
a659 4
    crtc = LookupCrtc(client, stuff->crtc, DixReadAccess);

    if (!crtc)
	return RRErrorBase + BadRRCrtc;
d773 1
a773 1
    int			    i, j;
d776 1
a776 1
    numOutputs = (stuff->length - (SIZEOF (xRRSetCrtcConfigReq) >> 2));
d778 2
a779 6
    crtc = LookupIDByType (stuff->crtc, RRCrtcType);
    if (!crtc)
    {
	client->errorValue = stuff->crtc;
	return RRErrorBase + BadRRCrtc;
    }
d788 1
a788 6
	mode = LookupIDByType (stuff->mode, RRModeType);
	if (!mode)
	{
	    client->errorValue = stuff->mode;
	    return RRErrorBase + BadRRMode;
	}
d804 3
a806 2
	outputs[i] = (RROutputPtr) LookupIDByType (outputIds[i], RROutputType);
	if (!outputs[i])
a807 1
	    client->errorValue = outputIds[i];
d810 1
a810 1
	    return RRErrorBase + BadRROutput;
d1017 1
a1017 4
    crtc = LookupCrtc(client, stuff->crtc, DixReadAccess);

    if (!crtc)
	return RRErrorBase + BadRRCrtc;
d1087 1
a1087 5
    crtc = LookupCrtc(client, stuff->crtc, DixReadAccess);

    if (!crtc)
	return RRErrorBase + BadRRCrtc;

d1160 6
a1165 4
    crtc = LookupCrtc (client, stuff->crtc, DixReadAccess);
    if (!crtc)
	return RRErrorBase + BadRRCrtc;
    
d1190 6
a1195 4
    crtc = LookupCrtc (client, stuff->crtc, DixReadAccess);
    if (!crtc)
	return RRErrorBase + BadRRCrtc;
    
d1206 1
a1206 1
    reply.length = (len + 3) >> 2;
d1233 1
a1233 3
    crtc = LookupCrtc (client, stuff->crtc, DixWriteAccess);
    if (!crtc)
	return RRErrorBase + BadRRCrtc;
d1235 1
a1235 1
    len = client->req_len - (sizeof (xRRSetCrtcGammaReq) >> 2);
d1266 1
a1266 3
    crtc = LookupCrtc (client, stuff->crtc, DixWriteAccess);
    if (!crtc)
	return RRErrorBase + BadRRCrtc;
d1275 1
a1275 1
    params = (xFixed *) (filter + ((nbytes + 3) & ~3));
d1296 1
a1296 1
    return ((nbytes + 3) & ~3) + (nparams * sizeof (xFixed));
d1335 1
a1335 1
	SwapLongs ((CARD32 *) wire, sizeof (xRenderTransform) >> 2);
d1349 1
a1349 3
    crtc = LookupCrtc (client, stuff->crtc, DixWriteAccess);
    if (!crtc)
	return RRErrorBase + BadRRCrtc;
d1364 1
a1364 1
    reply->length = (CrtcTransformExtra + nextra) >> 2;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d92 5
d118 9
d136 1
d232 13
d321 2
a322 1
	!RRCrtcPendingProperties (crtc))
d345 1
a345 1
		    RRCrtcNotify (crtc, NULL, x, y, rotation, 0, NULL);
d371 1
a371 1
			RRCrtcNotify (crtc, mode, x, y, rotation, 1, outputs);
d391 24
d494 22
d522 1
a522 18
    if (crtc->mode == NULL) {
	*width = 0;
	*height = 0;
	return;
    }

    switch (crtc->rotation & 0xf) {
    case RR_Rotate_0:
    case RR_Rotate_180:
	*width = crtc->mode->mode.width;
	*height = crtc->mode->mode.height;
	break;
    case RR_Rotate_90:
    case RR_Rotate_270:
	*width = crtc->mode->mode.height;
	*height = crtc->mode->mode.width;
	break;
    }
d555 53
d635 1
d656 17
a672 5
    rep.x = crtc->x;
    rep.y = crtc->y;
    RRCrtcGetScanoutSize (crtc, &width, &height);
    rep.width = width;
    rep.height = height;
d916 3
a918 1
	 * the size along with the mode
d920 1
a920 1
	if (pScrPriv->rrScreenSetSize)
d922 10
a931 2
	    int source_width = mode->mode.width;
	    int	source_height = mode->mode.height;
d933 1
a933 5
	    if ((rotation & 0xf) == RR_Rotate_90 || (rotation & 0xf) == RR_Rotate_270)
	    {
		source_width = mode->mode.height;
		source_height = mode->mode.width;
	    }
d970 1
d980 1
a980 1
    rep.newTimestamp = pScrPriv->lastConfigTime.milliseconds;
d995 155
d1183 1
a1183 1
    char			*extra;
d1247 141
@


1.1
log
@Initial revision
@
text
@d25 1
d76 1
a76 1
    crtc = xalloc (sizeof (RRCrtcRec));
d154 2
a155 1
	    crtc->outputs[j]->crtc = NULL;
d505 1
a505 3
#ifdef XResExtension
	RegisterResourceName (RRCrtcType, "CRTC");
#endif
d897 1
d906 6
d924 1
d926 2
a927 1
	WriteSwappedDataToClient (client, len, (char *) crtc->gammaRed);
@


1.1.1.1
log
@xserver 1.4
@
text
@@
