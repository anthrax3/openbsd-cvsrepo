head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.6
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.05.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.05.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright Â© 2006 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include "randrstr.h"
#include "propertyst.h"
#include "swaprep.h"

static int
DeliverPropertyEvent(WindowPtr pWin, void *value)
{
    xRROutputPropertyNotifyEvent *event = value;
    RREventPtr *pHead, pRREvent;

    dixLookupResourceByType((void **) &pHead, pWin->drawable.id,
                            RREventType, serverClient, DixReadAccess);
    if (!pHead)
        return WT_WALKCHILDREN;

    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent->next) {
        if (!(pRREvent->mask & RROutputPropertyNotifyMask))
            continue;

        event->window = pRREvent->window->drawable.id;
        WriteEventsToClient(pRREvent->client, 1, (xEvent *) event);
    }

    return WT_WALKCHILDREN;
}

static void
RRDeliverPropertyEvent(ScreenPtr pScreen, xEvent *event)
{
    if (!(dispatchException & (DE_RESET | DE_TERMINATE)))
        WalkTree(pScreen, DeliverPropertyEvent, event);
}

static void
RRDestroyOutputProperty(RRPropertyPtr prop)
{
    free(prop->valid_values);
    free(prop->current.data);
    free(prop->pending.data);
    free(prop);
}

static void
RRDeleteProperty(RROutputRec * output, RRPropertyRec * prop)
{
    xRROutputPropertyNotifyEvent event = {
        .type = RREventBase + RRNotify,
        .subCode = RRNotify_OutputProperty,
        .output = output->id,
        .state = PropertyDelete,
        .atom = prop->propertyName,
        .timestamp = currentTime.milliseconds
    };

    RRDeliverPropertyEvent(output->pScreen, (xEvent *) &event);

    RRDestroyOutputProperty(prop);
}

void
RRDeleteAllOutputProperties(RROutputPtr output)
{
    RRPropertyPtr prop, next;

    for (prop = output->properties; prop; prop = next) {
        next = prop->next;
        RRDeleteProperty(output, prop);
    }
}

static void
RRInitOutputPropertyValue(RRPropertyValuePtr property_value)
{
    property_value->type = None;
    property_value->format = 0;
    property_value->size = 0;
    property_value->data = NULL;
}

static RRPropertyPtr
RRCreateOutputProperty(Atom property)
{
    RRPropertyPtr prop;

    prop = (RRPropertyPtr) malloc(sizeof(RRPropertyRec));
    if (!prop)
        return NULL;
    prop->next = NULL;
    prop->propertyName = property;
    prop->is_pending = FALSE;
    prop->range = FALSE;
    prop->immutable = FALSE;
    prop->num_valid = 0;
    prop->valid_values = NULL;
    RRInitOutputPropertyValue(&prop->current);
    RRInitOutputPropertyValue(&prop->pending);
    return prop;
}

void
RRDeleteOutputProperty(RROutputPtr output, Atom property)
{
    RRPropertyRec *prop, **prev;

    for (prev = &output->properties; (prop = *prev); prev = &(prop->next))
        if (prop->propertyName == property) {
            *prev = prop->next;
            RRDeleteProperty(output, prop);
            return;
        }
}

int
RRChangeOutputProperty(RROutputPtr output, Atom property, Atom type,
                       int format, int mode, unsigned long len,
                       void *value, Bool sendevent, Bool pending)
{
    RRPropertyPtr prop;
    rrScrPrivPtr pScrPriv = rrGetScrPriv(output->pScreen);
    int size_in_bytes;
    unsigned long total_len;
    RRPropertyValuePtr prop_value;
    RRPropertyValueRec new_value;
    Bool add = FALSE;

    size_in_bytes = format >> 3;

    /* first see if property already exists */
    prop = RRQueryOutputProperty(output, property);
    if (!prop) {                /* just add to list */
        prop = RRCreateOutputProperty(property);
        if (!prop)
            return BadAlloc;
        add = TRUE;
        mode = PropModeReplace;
    }
    if (pending && prop->is_pending)
        prop_value = &prop->pending;
    else
        prop_value = &prop->current;

    /* To append or prepend to a property the request format and type
       must match those of the already defined property.  The
       existing format and type are irrelevant when using the mode
       "PropModeReplace" since they will be written over. */

    if ((format != prop_value->format) && (mode != PropModeReplace))
        return BadMatch;
    if ((prop_value->type != type) && (mode != PropModeReplace))
        return BadMatch;
    new_value = *prop_value;
    if (mode == PropModeReplace)
        total_len = len;
    else
        total_len = prop_value->size + len;

    if (mode == PropModeReplace || len > 0) {
        void *new_data = NULL, *old_data = NULL;

        new_value.data = xallocarray(total_len, size_in_bytes);
        if (!new_value.data && total_len && size_in_bytes) {
            if (add)
                RRDestroyOutputProperty(prop);
            return BadAlloc;
        }
        new_value.size = len;
        new_value.type = type;
        new_value.format = format;

        switch (mode) {
        case PropModeReplace:
            new_data = new_value.data;
            old_data = NULL;
            break;
        case PropModeAppend:
            new_data = (void *) (((char *) new_value.data) +
                                  (prop_value->size * size_in_bytes));
            old_data = new_value.data;
            break;
        case PropModePrepend:
            new_data = new_value.data;
            old_data = (void *) (((char *) new_value.data) +
                                  (prop_value->size * size_in_bytes));
            break;
        }
        if (new_data)
            memcpy((char *) new_data, (char *) value, len * size_in_bytes);
        if (old_data)
            memcpy((char *) old_data, (char *) prop_value->data,
                   prop_value->size * size_in_bytes);

        if (pending && pScrPriv->rrOutputSetProperty &&
            !pScrPriv->rrOutputSetProperty(output->pScreen, output,
                                           prop->propertyName, &new_value)) {
            free(new_value.data);
            if (add)
                RRDestroyOutputProperty(prop);
            return BadValue;
        }
        free(prop_value->data);
        *prop_value = new_value;
    }

    else if (len == 0) {
        /* do nothing */
    }

    if (add) {
        prop->next = output->properties;
        output->properties = prop;
    }

    if (pending && prop->is_pending)
        output->pendingProperties = TRUE;

    if (sendevent) {
        xRROutputPropertyNotifyEvent event = {
            .type = RREventBase + RRNotify,
            .subCode = RRNotify_OutputProperty,
            .output = output->id,
            .state = PropertyNewValue,
            .atom = prop->propertyName,
            .timestamp = currentTime.milliseconds
        };
        RRDeliverPropertyEvent(output->pScreen, (xEvent *) &event);
    }
    return Success;
}

Bool
RRPostPendingProperties(RROutputPtr output)
{
    RRPropertyValuePtr pending_value;
    RRPropertyValuePtr current_value;
    RRPropertyPtr property;
    Bool ret = TRUE;

    if (!output->pendingProperties)
        return TRUE;

    output->pendingProperties = FALSE;
    for (property = output->properties; property; property = property->next) {
        /* Skip non-pending properties */
        if (!property->is_pending)
            continue;

        pending_value = &property->pending;
        current_value = &property->current;

        /*
         * If the pending and current values are equal, don't mark it
         * as changed (which would deliver an event)
         */
        if (pending_value->type == current_value->type &&
            pending_value->format == current_value->format &&
            pending_value->size == current_value->size &&
            !memcmp(pending_value->data, current_value->data,
                    pending_value->size * (pending_value->format / 8)))
            continue;

        if (RRChangeOutputProperty(output, property->propertyName,
                                   pending_value->type, pending_value->format,
                                   PropModeReplace, pending_value->size,
                                   pending_value->data, TRUE, FALSE) != Success)
            ret = FALSE;
    }
    return ret;
}

RRPropertyPtr
RRQueryOutputProperty(RROutputPtr output, Atom property)
{
    RRPropertyPtr prop;

    for (prop = output->properties; prop; prop = prop->next)
        if (prop->propertyName == property)
            return prop;
    return NULL;
}

RRPropertyValuePtr
RRGetOutputProperty(RROutputPtr output, Atom property, Bool pending)
{
    RRPropertyPtr prop = RRQueryOutputProperty(output, property);
    rrScrPrivPtr pScrPriv = rrGetScrPriv(output->pScreen);

    if (!prop)
        return NULL;
    if (pending && prop->is_pending)
        return &prop->pending;
    else {
#if RANDR_13_INTERFACE
        /* If we can, try to update the property value first */
        if (pScrPriv->rrOutputGetProperty)
            pScrPriv->rrOutputGetProperty(output->pScreen, output,
                                          prop->propertyName);
#endif
        return &prop->current;
    }
}

int
RRConfigureOutputProperty(RROutputPtr output, Atom property,
                          Bool pending, Bool range, Bool immutable,
                          int num_values, INT32 *values)
{
    RRPropertyPtr prop = RRQueryOutputProperty(output, property);
    Bool add = FALSE;
    INT32 *new_values;

    if (!prop) {
        prop = RRCreateOutputProperty(property);
        if (!prop)
            return BadAlloc;
        add = TRUE;
    }
    else if (prop->immutable && !immutable)
        return BadAccess;

    /*
     * ranges must have even number of values
     */
    if (range && (num_values & 1)) {
        if (add)
            RRDestroyOutputProperty(prop);
        return BadMatch;
    }

    new_values = xallocarray(num_values, sizeof(INT32));
    if (!new_values && num_values) {
        if (add)
            RRDestroyOutputProperty(prop);
        return BadAlloc;
    }
    if (num_values)
        memcpy(new_values, values, num_values * sizeof(INT32));

    /*
     * Property moving from pending to non-pending
     * loses any pending values
     */
    if (prop->is_pending && !pending) {
        free(prop->pending.data);
        RRInitOutputPropertyValue(&prop->pending);
    }

    prop->is_pending = pending;
    prop->range = range;
    prop->immutable = immutable;
    prop->num_valid = num_values;
    free(prop->valid_values);
    prop->valid_values = new_values;

    if (add) {
        prop->next = output->properties;
        output->properties = prop;
    }

    return Success;
}

int
ProcRRListOutputProperties(ClientPtr client)
{
    REQUEST(xRRListOutputPropertiesReq);
    Atom *pAtoms = NULL;
    xRRListOutputPropertiesReply rep;
    int numProps = 0;
    RROutputPtr output;
    RRPropertyPtr prop;

    REQUEST_SIZE_MATCH(xRRListOutputPropertiesReq);

    VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);

    for (prop = output->properties; prop; prop = prop->next)
        numProps++;
    if (numProps)
        if (!(pAtoms = xallocarray(numProps, sizeof(Atom))))
            return BadAlloc;

    rep = (xRRListOutputPropertiesReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(numProps * sizeof(Atom)),
        .nAtoms = numProps
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.nAtoms);
    }
    WriteToClient(client, sizeof(xRRListOutputPropertiesReply), &rep);

    if (numProps) {
        /* Copy property name atoms to reply buffer */
        Atom *temppAtoms = pAtoms;
        for (prop = output->properties; prop; prop = prop->next)
            *temppAtoms++ = prop->propertyName;

        client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
        WriteSwappedDataToClient(client, numProps * sizeof(Atom), pAtoms);
        free(pAtoms);
    }
    return Success;
}

int
ProcRRQueryOutputProperty(ClientPtr client)
{
    REQUEST(xRRQueryOutputPropertyReq);
    xRRQueryOutputPropertyReply rep;
    RROutputPtr output;
    RRPropertyPtr prop;
    char *extra = NULL;

    REQUEST_SIZE_MATCH(xRRQueryOutputPropertyReq);

    VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);

    prop = RRQueryOutputProperty(output, stuff->property);
    if (!prop)
        return BadName;

    if (prop->num_valid) {
        extra = xallocarray(prop->num_valid, sizeof(INT32));
        if (!extra)
            return BadAlloc;
    }

    rep = (xRRQueryOutputPropertyReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = prop->num_valid,
        .pending = prop->is_pending,
        .range = prop->range,
        .immutable = prop->immutable
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
    }
    WriteToClient(client, sizeof(xRRQueryOutputPropertyReply), &rep);
    if (prop->num_valid) {
        memcpy(extra, prop->valid_values, prop->num_valid * sizeof(INT32));
        client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
        WriteSwappedDataToClient(client, prop->num_valid * sizeof(INT32),
                                 extra);
        free(extra);
    }
    return Success;
}

int
ProcRRConfigureOutputProperty(ClientPtr client)
{
    REQUEST(xRRConfigureOutputPropertyReq);
    RROutputPtr output;
    int num_valid;

    REQUEST_AT_LEAST_SIZE(xRRConfigureOutputPropertyReq);

    VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);

    num_valid =
        stuff->length - bytes_to_int32(sizeof(xRRConfigureOutputPropertyReq));
    return RRConfigureOutputProperty(output, stuff->property, stuff->pending,
                                     stuff->range, FALSE, num_valid,
                                     (INT32 *) (stuff + 1));
}

int
ProcRRChangeOutputProperty(ClientPtr client)
{
    REQUEST(xRRChangeOutputPropertyReq);
    RROutputPtr output;
    char format, mode;
    unsigned long len;
    int sizeInBytes;
    int totalSize;
    int err;

    REQUEST_AT_LEAST_SIZE(xRRChangeOutputPropertyReq);
    UpdateCurrentTime();
    format = stuff->format;
    mode = stuff->mode;
    if ((mode != PropModeReplace) && (mode != PropModeAppend) &&
        (mode != PropModePrepend)) {
        client->errorValue = mode;
        return BadValue;
    }
    if ((format != 8) && (format != 16) && (format != 32)) {
        client->errorValue = format;
        return BadValue;
    }
    len = stuff->nUnits;
    if (len > bytes_to_int32((0xffffffff - sizeof(xChangePropertyReq))))
        return BadLength;
    sizeInBytes = format >> 3;
    totalSize = len * sizeInBytes;
    REQUEST_FIXED_SIZE(xRRChangeOutputPropertyReq, totalSize);

    VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);

    if (!ValidAtom(stuff->property)) {
        client->errorValue = stuff->property;
        return BadAtom;
    }
    if (!ValidAtom(stuff->type)) {
        client->errorValue = stuff->type;
        return BadAtom;
    }

    err = RRChangeOutputProperty(output, stuff->property,
                                 stuff->type, (int) format,
                                 (int) mode, len, (void *) &stuff[1], TRUE,
                                 TRUE);
    if (err != Success)
        return err;
    else
        return Success;
}

int
ProcRRDeleteOutputProperty(ClientPtr client)
{
    REQUEST(xRRDeleteOutputPropertyReq);
    RROutputPtr output;
    RRPropertyPtr prop;

    REQUEST_SIZE_MATCH(xRRDeleteOutputPropertyReq);
    UpdateCurrentTime();
    VERIFY_RR_OUTPUT(stuff->output, output, DixReadAccess);

    if (!ValidAtom(stuff->property)) {
        client->errorValue = stuff->property;
        return BadAtom;
    }

    prop = RRQueryOutputProperty(output, stuff->property);
    if (!prop) {
        client->errorValue = stuff->property;
        return BadName;
    }

    if (prop->immutable) {
        client->errorValue = stuff->property;
        return BadAccess;
    }

    RRDeleteOutputProperty(output, stuff->property);
    return Success;
}

int
ProcRRGetOutputProperty(ClientPtr client)
{
    REQUEST(xRRGetOutputPropertyReq);
    RRPropertyPtr prop, *prev;
    RRPropertyValuePtr prop_value;
    unsigned long n, len, ind;
    RROutputPtr output;
    xRRGetOutputPropertyReply reply;
    char *extra = NULL;

    REQUEST_SIZE_MATCH(xRRGetOutputPropertyReq);
    if (stuff->delete)
        UpdateCurrentTime();
    VERIFY_RR_OUTPUT(stuff->output, output,
                     stuff->delete ? DixWriteAccess : DixReadAccess);

    if (!ValidAtom(stuff->property)) {
        client->errorValue = stuff->property;
        return BadAtom;
    }
    if ((stuff->delete != xTrue) && (stuff->delete != xFalse)) {
        client->errorValue = stuff->delete;
        return BadValue;
    }
    if ((stuff->type != AnyPropertyType) && !ValidAtom(stuff->type)) {
        client->errorValue = stuff->type;
        return BadAtom;
    }

    for (prev = &output->properties; (prop = *prev); prev = &prop->next)
        if (prop->propertyName == stuff->property)
            break;

    reply = (xRRGetOutputPropertyReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence
    };
    if (!prop) {
        reply.nItems = 0;
        reply.length = 0;
        reply.bytesAfter = 0;
        reply.propertyType = None;
        reply.format = 0;
        if (client->swapped) {
            swaps(&reply.sequenceNumber);
            swapl(&reply.length);
            swapl(&reply.propertyType);
            swapl(&reply.bytesAfter);
            swapl(&reply.nItems);
        }
        WriteToClient(client, sizeof(xRRGetOutputPropertyReply), &reply);
        return Success;
    }

    if (prop->immutable && stuff->delete)
        return BadAccess;

    prop_value = RRGetOutputProperty(output, stuff->property, stuff->pending);
    if (!prop_value)
        return BadAtom;

    /* If the request type and actual type don't match. Return the
       property information, but not the data. */

    if (((stuff->type != prop_value->type) && (stuff->type != AnyPropertyType))
        ) {
        reply.bytesAfter = prop_value->size;
        reply.format = prop_value->format;
        reply.length = 0;
        reply.nItems = 0;
        reply.propertyType = prop_value->type;
        if (client->swapped) {
            swaps(&reply.sequenceNumber);
            swapl(&reply.length);
            swapl(&reply.propertyType);
            swapl(&reply.bytesAfter);
            swapl(&reply.nItems);
        }
        WriteToClient(client, sizeof(xRRGetOutputPropertyReply), &reply);
        return Success;
    }

/*
 *  Return type, format, value to client
 */
    n = (prop_value->format / 8) * prop_value->size;    /* size (bytes) of prop */
    ind = stuff->longOffset << 2;

    /* If longOffset is invalid such that it causes "len" to
       be negative, it's a value error. */

    if (n < ind) {
        client->errorValue = stuff->longOffset;
        return BadValue;
    }

    len = min(n - ind, 4 * stuff->longLength);

    if (len) {
        extra = malloc(len);
        if (!extra)
            return BadAlloc;
    }
    reply.bytesAfter = n - (ind + len);
    reply.format = prop_value->format;
    reply.length = bytes_to_int32(len);
    if (prop_value->format)
        reply.nItems = len / (prop_value->format / 8);
    else
        reply.nItems = 0;
    reply.propertyType = prop_value->type;

    if (stuff->delete && (reply.bytesAfter == 0)) {
        xRROutputPropertyNotifyEvent event = {
            .type = RREventBase + RRNotify,
            .subCode = RRNotify_OutputProperty,
            .output = output->id,
            .state = PropertyDelete,
            .atom = prop->propertyName,
            .timestamp = currentTime.milliseconds
        };
        RRDeliverPropertyEvent(output->pScreen, (xEvent *) &event);
    }

    if (client->swapped) {
        swaps(&reply.sequenceNumber);
        swapl(&reply.length);
        swapl(&reply.propertyType);
        swapl(&reply.bytesAfter);
        swapl(&reply.nItems);
    }
    WriteToClient(client, sizeof(xGenericReply), &reply);
    if (len) {
        memcpy(extra, (char *) prop_value->data + ind, len);
        switch (reply.format) {
        case 32:
            client->pSwapReplyFunc = (ReplySwapPtr) CopySwap32Write;
            break;
        case 16:
            client->pSwapReplyFunc = (ReplySwapPtr) CopySwap16Write;
            break;
        default:
            client->pSwapReplyFunc = (ReplySwapPtr) WriteToClient;
            break;
        }
        WriteSwappedDataToClient(client, len, extra);
        free(extra);
    }

    if (stuff->delete && (reply.bytesAfter == 0)) {     /* delete the Property */
        *prev = prop->next;
        RRDestroyOutputProperty(prop);
    }
    return Success;
}
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a142 1
    int total_size;
d182 2
a183 3
        total_size = total_len * size_in_bytes;
        new_value.data = (void *) malloc(total_size);
        if (!new_value.data && total_size) {
d351 1
a351 1
    new_values = malloc(num_values * sizeof(INT32));
d401 1
a401 1
        if (!(pAtoms = (Atom *) malloc(numProps * sizeof(Atom))))
d448 1
a448 1
        extra = malloc(prop->num_valid * sizeof(INT32));
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d33 1
a33 1
    dixLookupResourceByType((pointer *) &pHead, pWin->drawable.id,
d138 1
a138 1
                       pointer value, Bool sendevent, Bool pending)
d181 1
a181 1
        pointer new_data = NULL, old_data = NULL;
d184 1
a184 1
        new_value.data = (pointer) malloc(total_size);
d200 1
a200 1
            new_data = (pointer) (((char *) new_value.data) +
d206 1
a206 1
            old_data = (pointer) (((char *) new_value.data) +
d541 1
a541 1
                                 (int) mode, len, (pointer) &stuff[1], TRUE,
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d68 8
a75 8
    xRROutputPropertyNotifyEvent event;

    event.type = RREventBase + RRNotify;
    event.subCode = RRNotify_OutputProperty;
    event.output = output->id;
    event.state = PropertyDelete;
    event.atom = prop->propertyName;
    event.timestamp = currentTime.milliseconds;
a140 1
    xRROutputPropertyNotifyEvent event;
d220 2
d241 8
a248 6
        event.type = RREventBase + RRNotify;
        event.subCode = RRNotify_OutputProperty;
        event.output = output->id;
        event.state = PropertyNewValue;
        event.atom = prop->propertyName;
        event.timestamp = currentTime.milliseconds;
d347 3
a349 1
    if (range && (num_values & 1))
d351 1
d354 3
a356 1
    if (!new_values && num_values)
d358 1
d390 1
a390 1
    Atom *pAtoms = NULL, *temppAtoms;
d406 6
a411 4
    rep.type = X_Reply;
    rep.length = bytes_to_int32(numProps * sizeof(Atom));
    rep.sequenceNumber = client->sequence;
    rep.nAtoms = numProps;
d417 1
a417 3
    temppAtoms = pAtoms;
    for (prop = output->properties; prop; prop = prop->next)
        *temppAtoms++ = prop->propertyName;
a418 1
    WriteToClient(client, sizeof(xRRListOutputPropertiesReply), (char *) &rep);
d420 5
d454 10
a463 6
    rep.type = X_Reply;
    rep.length = prop->num_valid;
    rep.sequenceNumber = client->sequence;
    rep.pending = prop->is_pending;
    rep.range = prop->range;
    rep.immutable = prop->immutable;
d468 1
a468 1
    WriteToClient(client, sizeof(xRRQueryOutputPropertyReply), (char *) &rep);
d614 4
a617 2
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
d694 8
a701 8
        xRROutputPropertyNotifyEvent event;

        event.type = RREventBase + RRNotify;
        event.subCode = RRNotify_OutputProperty;
        event.output = output->id;
        event.state = PropertyDelete;
        event.atom = prop->propertyName;
        event.timestamp = currentTime.milliseconds;
@


1.7
log
@Update to xserver 1.11.2
@
text
@d33 2
a34 2
    dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
			    RREventType, serverClient, DixReadAccess);
d36 1
a36 1
	return WT_WALKCHILDREN;
d38 3
a40 4
    for (pRREvent = *pHead; pRREvent; pRREvent = pRREvent->next)
    {
	if (!(pRREvent->mask & RROutputPropertyNotifyMask))
	    continue;
d42 2
a43 2
	event->window = pRREvent->window->drawable.id;
	WriteEventsToClient(pRREvent->client, 1, (xEvent *)event);
d49 2
a50 1
static void RRDeliverPropertyEvent(ScreenPtr pScreen, xEvent *event)
d53 1
a53 1
	WalkTree(pScreen, DeliverPropertyEvent, event);
d57 1
a57 1
RRDestroyOutputProperty (RRPropertyPtr prop)
d66 1
a66 1
RRDeleteProperty(RROutputRec *output, RRPropertyRec *prop)
d69 1
d77 1
a77 1
    RRDeliverPropertyEvent(output->pScreen, (xEvent *)&event);
d88 1
a88 1
	next = prop->next;
d94 1
a94 1
RRInitOutputPropertyValue (RRPropertyValuePtr property_value)
d103 1
a103 1
RRCreateOutputProperty (Atom property)
d105 1
a105 1
    RRPropertyPtr   prop;
d107 1
a107 1
    prop = (RRPropertyPtr)malloc(sizeof(RRPropertyRec));
d109 1
a109 1
	return NULL;
d117 2
a118 2
    RRInitOutputPropertyValue (&prop->current);
    RRInitOutputPropertyValue (&prop->pending);
d128 1
a128 1
	if (prop->propertyName == property) {
d136 13
a148 13
RRChangeOutputProperty (RROutputPtr output, Atom property, Atom type,
			int format, int mode, unsigned long len,
			pointer value, Bool sendevent, Bool pending)
{
    RRPropertyPtr		    prop;
    xRROutputPropertyNotifyEvent    event;
    rrScrPrivPtr		    pScrPriv = rrGetScrPriv(output->pScreen);
    int				    size_in_bytes;
    int				    total_size;
    unsigned long		    total_len;
    RRPropertyValuePtr		    prop_value;
    RRPropertyValueRec		    new_value;
    Bool			    add = FALSE;
d153 7
a159 8
    prop = RRQueryOutputProperty (output, property);
    if (!prop)   /* just add to list */
    {
	prop = RRCreateOutputProperty (property);
	if (!prop)
	    return BadAlloc;
	add = TRUE;
	mode = PropModeReplace;
d162 1
a162 1
	prop_value = &prop->pending;
d164 1
a164 1
	prop_value = &prop->current;
d167 3
a169 3
     must match those of the already defined property.  The
     existing format and type are irrelevant when using the mode
     "PropModeReplace" since they will be written over. */
d172 1
a172 1
	return BadMatch;
d174 1
a174 1
	return BadMatch;
d177 1
a177 1
	total_len = len;
d179 4
a182 1
	total_len = prop_value->size + len;
d184 50
a233 58
    if (mode == PropModeReplace || len > 0)
    {
	pointer	    new_data = NULL, old_data = NULL;

	total_size = total_len * size_in_bytes;
	new_value.data = (pointer)malloc(total_size);
	if (!new_value.data && total_size)
	{
	    if (add)
		RRDestroyOutputProperty (prop);
	    return BadAlloc;
	}
	new_value.size = len;
	new_value.type = type;
	new_value.format = format;

	switch (mode) {
	case PropModeReplace:
	    new_data = new_value.data;
	    old_data = NULL;
	    break;
	case PropModeAppend:
	    new_data = (pointer) (((char *) new_value.data) + 
				  (prop_value->size * size_in_bytes));
	    old_data = new_value.data;
	    break;
	case PropModePrepend:
	    new_data = new_value.data;
	    old_data = (pointer) (((char *) new_value.data) + 
				  (prop_value->size * size_in_bytes));
	    break;
	}
	if (new_data)
	    memcpy ((char *) new_data, (char *) value, len * size_in_bytes);
	if (old_data)
	    memcpy ((char *) old_data, (char *) prop_value->data, 
		    prop_value->size * size_in_bytes);

	if (pending && pScrPriv->rrOutputSetProperty &&
	    !pScrPriv->rrOutputSetProperty(output->pScreen, output,
					   prop->propertyName, &new_value))
	{
	    free(new_value.data);
	    return BadValue;
	}
	free(prop_value->data);
	*prop_value = new_value;
    }

    else if (len == 0)
    {
	/* do nothing */
    }

    if (add)
    {
	prop->next = output->properties;
	output->properties = prop;
d237 1
a237 1
	output->pendingProperties = TRUE;
d239 8
a246 9
    if (sendevent)
    {
	event.type = RREventBase + RRNotify;
	event.subCode = RRNotify_OutputProperty;
	event.output = output->id;
	event.state = PropertyNewValue;
	event.atom = prop->propertyName;
	event.timestamp = currentTime.milliseconds;
	RRDeliverPropertyEvent (output->pScreen, (xEvent *)&event);
d252 1
a252 1
RRPostPendingProperties (RROutputPtr output)
d254 4
a257 4
    RRPropertyValuePtr	pending_value;
    RRPropertyValuePtr	current_value;
    RRPropertyPtr	property;
    Bool		ret = TRUE;
d260 2
a261 2
	return TRUE;
    
d263 24
a286 26
    for (property = output->properties; property; property = property->next)
    {
	/* Skip non-pending properties */
	if (!property->is_pending)
	    continue;
	
	pending_value = &property->pending;
	current_value = &property->current;

	/*
	 * If the pending and current values are equal, don't mark it
	 * as changed (which would deliver an event)
	 */
	if (pending_value->type == current_value->type &&
	    pending_value->format == current_value->format &&
	    pending_value->size == current_value->size &&
	    !memcmp (pending_value->data, current_value->data,
		     pending_value->size * (pending_value->format / 8)))
	    continue;

	if (RRChangeOutputProperty (output, property->propertyName,
				    pending_value->type, pending_value->format,
				    PropModeReplace, pending_value->size,
				    pending_value->data, TRUE,
				    FALSE) != Success)
	    ret = FALSE;
d292 1
a292 1
RRQueryOutputProperty (RROutputPtr output, Atom property)
d294 2
a295 2
    RRPropertyPtr   prop;
    
d297 2
a298 2
	if (prop->propertyName == property)
	    return prop;
d301 1
a301 1
		       
d303 1
a303 1
RRGetOutputProperty (RROutputPtr output, Atom property, Bool pending)
d305 2
a306 2
    RRPropertyPtr   prop = RRQueryOutputProperty (output, property);
    rrScrPrivPtr    pScrPriv = rrGetScrPriv(output->pScreen);
d309 1
a309 1
	return NULL;
d311 1
a311 1
	return &prop->pending;
d314 4
a317 4
	/* If we can, try to update the property value first */
	if (pScrPriv->rrOutputGetProperty)
	    pScrPriv->rrOutputGetProperty(output->pScreen, output,
					  prop->propertyName);
d319 1
a319 1
	return &prop->current;
d324 16
a339 7
RRConfigureOutputProperty (RROutputPtr output, Atom property,
			   Bool pending, Bool range, Bool immutable,
			   int num_values, INT32 *values)
{
    RRPropertyPtr   prop = RRQueryOutputProperty (output, property);
    Bool	    add = FALSE;
    INT32	    *new_values;
a340 9
    if (!prop)
    {
        prop = RRCreateOutputProperty (property);
	if (!prop)
	    return BadAlloc;
	add = TRUE;
    } else if (prop->immutable && !immutable)
	return BadAccess;
    
d345 1
a345 1
	return BadMatch;
d347 1
a347 1
    new_values = malloc(num_values * sizeof (INT32));
d349 1
a349 1
	return BadAlloc;
d351 2
a352 2
	memcpy (new_values, values, num_values * sizeof (INT32));
    
d357 3
a359 4
    if (prop->is_pending && !pending)
    {
	free(prop->pending.data);
	RRInitOutputPropertyValue (&prop->pending);
d370 2
a371 2
	prop->next = output->properties;
	output->properties = prop;
d378 1
a378 1
ProcRRListOutputProperties (ClientPtr client)
d381 6
a386 6
    Atom			    *pAtoms = NULL, *temppAtoms;
    xRRListOutputPropertiesReply    rep;
    int				    numProps = 0;
    RROutputPtr			    output;
    RRPropertyPtr			    prop;
    
d392 1
a392 1
	numProps++;
d394 1
a394 1
        if(!(pAtoms = (Atom *)malloc(numProps * sizeof(Atom))))
d401 4
a404 6
    if (client->swapped) 
    {
	int n;
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swaps (&rep.nAtoms, n);
d408 1
a408 1
	*temppAtoms++ = prop->propertyName;
d410 3
a412 4
    WriteToClient(client, sizeof(xRRListOutputPropertiesReply), (char*)&rep);
    if (numProps)
    {
        client->pSwapReplyFunc = (ReplySwapPtr)Swap32Write;
d420 1
a420 1
ProcRRQueryOutputProperty (ClientPtr client)
d423 3
a425 3
    xRRQueryOutputPropertyReply	    rep;
    RROutputPtr			    output;
    RRPropertyPtr		    prop;
d427 1
a427 1
    
d431 2
a432 2
    
    prop = RRQueryOutputProperty (output, stuff->property);
d434 2
a435 2
	return BadName;
    
d437 3
a439 3
	extra = malloc(prop->num_valid * sizeof(INT32));
	if (!extra)
	    return BadAlloc;
d447 6
a452 9
    if (client->swapped) 
    {
	int n;
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
    }
    WriteToClient (client, sizeof (xRRQueryOutputPropertyReply), (char*)&rep);
    if (prop->num_valid)
    {
d454 1
a454 1
        client->pSwapReplyFunc = (ReplySwapPtr)Swap32Write;
d456 1
a456 1
				 extra);
d463 1
a463 1
ProcRRConfigureOutputProperty (ClientPtr client)
d466 3
a468 3
    RROutputPtr				output;
    int					num_valid;
    
d472 6
a477 6
    
    num_valid = stuff->length - bytes_to_int32(sizeof (xRRConfigureOutputPropertyReq));
    return RRConfigureOutputProperty (output, stuff->property,
				      stuff->pending, stuff->range,
				      FALSE, num_valid, 
				      (INT32 *) (stuff + 1));
d481 1
a481 1
ProcRRChangeOutputProperty (ClientPtr client)
d484 6
a489 6
    RROutputPtr	    output;
    char	    format, mode;
    unsigned long   len;
    int		    sizeInBytes;
    int		    totalSize;
    int		    err;
d496 6
a501 8
	(mode != PropModePrepend))
    {
	client->errorValue = mode;
	return BadValue;
    }
    if ((format != 8) && (format != 16) && (format != 32))
    {
	client->errorValue = format;
d506 2
a507 2
	return BadLength;
    sizeInBytes = format>>3;
d512 8
a519 10
    
    if (!ValidAtom(stuff->property))
    {
	client->errorValue = stuff->property;
	return BadAtom;
    }
    if (!ValidAtom(stuff->type))
    {
	client->errorValue = stuff->type;
	return BadAtom;
d523 3
a525 2
				 stuff->type, (int)format,
				 (int)mode, len, (pointer)&stuff[1], TRUE, TRUE);
d527 1
a527 1
	return err;
d529 1
a529 1
	return Success;
d533 1
a533 1
ProcRRDeleteOutputProperty (ClientPtr client)
d536 3
a538 2
    RROutputPtr	output;
              
d542 4
a545 5
    
    if (!ValidAtom(stuff->property))
    {
	client->errorValue = stuff->property;
	return BadAtom;
d548 10
d564 1
a564 1
ProcRRGetOutputProperty (ClientPtr client)
d567 6
a572 6
    RRPropertyPtr		prop, *prev;
    RRPropertyValuePtr		prop_value;
    unsigned long		n, len, ind;
    RROutputPtr			output;
    xRRGetOutputPropertyReply	reply;
    char			*extra = NULL;
d576 1
a576 1
	UpdateCurrentTime();
d578 1
a578 1
		     stuff->delete ? DixWriteAccess : DixReadAccess);
d580 11
a590 14
    if (!ValidAtom(stuff->property))
    {
	client->errorValue = stuff->property;
	return BadAtom;
    }
    if ((stuff->delete != xTrue) && (stuff->delete != xFalse))
    {
	client->errorValue = stuff->delete;
	return BadValue;
    }
    if ((stuff->type != AnyPropertyType) && !ValidAtom(stuff->type))
    {
	client->errorValue = stuff->type;
	return BadAtom;
d594 2
a595 2
	if (prop->propertyName == stuff->property) 
	    break;
d599 15
a613 18
    if (!prop) 
    {
	reply.nItems = 0;
	reply.length = 0;
	reply.bytesAfter = 0;
	reply.propertyType = None;
	reply.format = 0;
	if (client->swapped) {
	    int n;

	    swaps(&reply.sequenceNumber, n);
	    swapl(&reply.length, n);
	    swapl(&reply.propertyType, n);
	    swapl(&reply.bytesAfter, n);
	    swapl(&reply.nItems, n);
	}
	WriteToClient(client, sizeof(xRRGetOutputPropertyReply), &reply);
	return Success;
d617 1
a617 1
	return BadAccess;
d621 1
a621 1
	return BadAtom;
d624 1
a624 1
    property information, but not the data. */
d626 16
a641 20
    if (((stuff->type != prop_value->type) &&
	 (stuff->type != AnyPropertyType))
       )
    {
	reply.bytesAfter = prop_value->size;
	reply.format = prop_value->format;
	reply.length = 0;
	reply.nItems = 0;
	reply.propertyType = prop_value->type;
	if (client->swapped) {
	    int n;

	    swaps(&reply.sequenceNumber, n);
	    swapl(&reply.length, n);
	    swapl(&reply.propertyType, n);
	    swapl(&reply.bytesAfter, n);
	    swapl(&reply.nItems, n);
	}
	WriteToClient(client, sizeof(xRRGetOutputPropertyReply), &reply);
	return Success;
d647 2
a648 2
    n = (prop_value->format/8) * prop_value->size; /* size (bytes) of prop */
    ind = stuff->longOffset << 2;        
d650 2
a651 2
   /* If longOffset is invalid such that it causes "len" to
	    be negative, it's a value error. */
d653 3
a655 4
    if (n < ind)
    {
	client->errorValue = stuff->longOffset;
	return BadValue;
d661 3
a663 3
	extra = malloc(len);
	if (!extra)
	    return BadAlloc;
d669 1
a669 1
	reply.nItems = len / (prop_value->format / 8);
d671 1
a671 1
	reply.nItems = 0;
d674 10
a683 11
    if (stuff->delete && (reply.bytesAfter == 0))
    {
	xRROutputPropertyNotifyEvent    event;

	event.type = RREventBase + RRNotify;
	event.subCode = RRNotify_OutputProperty;
	event.output = output->id;
	event.state = PropertyDelete;
	event.atom = prop->propertyName;
	event.timestamp = currentTime.milliseconds;
	RRDeliverPropertyEvent (output->pScreen, (xEvent *)&event);
d687 5
a691 7
	int n;

	swaps(&reply.sequenceNumber, n);
	swapl(&reply.length, n);
	swapl(&reply.propertyType, n);
	swapl(&reply.bytesAfter, n);
	swapl(&reply.nItems, n);
d694 20
a713 17
    if (len)
    {
	memcpy(extra, (char *)prop_value->data + ind, len);
	switch (reply.format) {
	case 32: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap32Write; break;
	case 16: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write; break;
	default: client->pSwapReplyFunc = (ReplySwapPtr)WriteToClient; break;
	}
	WriteSwappedDataToClient(client, len,
				 extra);
	free(extra);
    }

    if (stuff->delete && (reply.bytesAfter == 0))
    { /* delete the Property */
	*prev = prop->next;
	RRDestroyOutputProperty (prop);
a716 1

@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d286 1
a286 1
		     pending_value->size))
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a31 1
    ClientPtr client;
a39 4
	client = pRREvent->client;
	if (client == serverClient || client->clientGone)
	    continue;

a42 1
	event->sequenceNumber = client->sequence;
d56 25
d82 1
a82 1
RRDeleteAllOutputProperties (RROutputPtr output)
a84 1
    xRROutputPropertyNotifyEvent    event;
d86 1
a86 2
    for (prop = output->properties; prop; prop = next)
    {
d88 1
a88 12
	event.type = RREventBase + RRNotify;
	event.subCode = RRNotify_OutputProperty;
	event.output = output->id;
	event.state = PropertyDelete;
	event.atom = prop->propertyName;
	event.timestamp = currentTime.milliseconds;
	RRDeliverPropertyEvent (output->pScreen, (xEvent *)&event);
	if (prop->current.data)
	    xfree(prop->current.data);
	if (prop->pending.data)
	    xfree(prop->pending.data);
	xfree(prop);
d106 1
a106 1
    prop = (RRPropertyPtr)xalloc(sizeof(RRPropertyRec));
a120 14
static void
RRDestroyOutputProperty (RRPropertyPtr prop)
{
    if (prop->valid_values)
	xfree (prop->valid_values);
    if (prop->current.data)
	xfree(prop->current.data);
    if (prop->pending.data)
	xfree(prop->pending.data);
    if (prop->valid_values)
	xfree(prop->valid_values);
    xfree(prop);
}

d122 1
a122 1
RRDeleteOutputProperty (RROutputPtr output, Atom property)
d124 1
a124 2
    RRPropertyPtr	prop, *prev;
    xRROutputPropertyNotifyEvent    event;
d127 5
a131 14
	if (prop->propertyName == property)
	    break;
    if (prop)
    {
	*prev = prop->next;
	event.type = RREventBase + RRNotify;
	event.subCode = RRNotify_OutputProperty;
	event.output = output->id;
	event.state = PropertyDelete;
	event.atom = prop->propertyName;
	event.timestamp = currentTime.milliseconds;
	RRDeliverPropertyEvent (output->pScreen, (xEvent *)&event);
	RRDestroyOutputProperty (prop);
    }
d157 1
a157 1
	    return(BadAlloc);
d172 1
a172 1
	return(BadMatch);
d174 1
a174 1
	return(BadMatch);
d186 1
a186 1
	new_value.data = (pointer)xalloc (total_size);
d223 2
a224 3
	    if (new_value.data)
		xfree (new_value.data);
	    return (BadValue);
d226 1
a226 2
	if (prop_value->data)
	    xfree (prop_value->data);
d254 1
a254 1
    return(Success);
d344 1
a344 1
	    return(BadAlloc);
d347 1
a347 1
	return(BadAccess);
d355 1
a355 1
    new_values = xalloc (num_values * sizeof (INT32));
d367 1
a367 2
	if (prop->pending.data)
	    xfree (prop->pending.data);
d375 1
a375 2
    if (prop->valid_values)
	xfree (prop->valid_values);
d403 2
a404 2
        if(!(pAtoms = (Atom *)xalloc(numProps * sizeof(Atom))))
            return(BadAlloc);
d426 1
a426 1
        xfree(pAtoms);
d428 1
a428 1
    return(client->noClientException);
d449 1
a449 1
	extra = xalloc(prop->num_valid * sizeof(INT32));
d472 1
a472 1
        xfree(extra);
d474 1
a474 1
    return(client->noClientException);
d533 1
a533 1
	return(BadAtom);
d538 1
a538 1
	return(BadAtom);
d547 1
a547 1
	return client->noClientException;
d563 1
a563 1
	return (BadAtom);
d568 1
a568 1
    return client->noClientException;
d591 1
a591 1
	return(BadAtom);
d596 1
a596 1
	return(BadValue);
d601 1
a601 1
	return(BadAtom);
d627 1
a627 1
	return(client->noClientException);
d659 1
a659 1
	return(client->noClientException);
d680 1
a680 1
	extra = xalloc(len);
d726 1
a726 1
	xfree(extra);
d734 1
a734 1
    return(client->noClientException);
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d34 2
a35 1
    pHead = LookupIDByType(pWin->drawable.id, RREventType);
a49 5
	if (client->swapped) {
	    int n;
	    swaps(&event->sequenceNumber, n);
	    swapl(&event->window, n);
	}
d124 2
d420 1
a420 4
    output = LookupOutput (client, stuff->output, DixReadAccess);
    
    if (!output)
        return RRErrorBase + BadRROutput;
d429 1
a429 1
    rep.length = (numProps * sizeof(Atom)) >> 2;
d464 1
a464 4
    output = LookupOutput (client, stuff->output, DixReadAccess);
    
    if (!output)
        return RRErrorBase + BadRROutput;
d508 1
a508 4
    output = LookupOutput (client, stuff->output, DixReadAccess);
    
    if (!output)
        return RRErrorBase + BadRROutput;
d510 1
a510 1
    num_valid = stuff->length - (sizeof (xRRConfigureOutputPropertyReq) >> 2);
d544 1
a544 1
    if (len > ((0xffffffff - sizeof(xChangePropertyReq)) >> 2))
d550 1
a550 3
    output = LookupOutput (client, stuff->output, DixWriteAccess);
    if (!output)
	return RRErrorBase + BadRROutput;
d580 1
a580 3
    output = LookupOutput (client, stuff->output, DixWriteAccess);
    if (!output)
        return RRErrorBase + BadRROutput;
d607 2
a608 5
    output = LookupOutput (client, stuff->output, 
			   stuff->delete ? DixWriteAccess :
			   DixReadAccess);
    if (!output)
	return RRErrorBase + BadRROutput;
d708 1
a708 1
    reply.length = (len + 3) >> 2;
@


1.3
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d336 1
d342 7
a348 1
    else
d350 1
d465 1
a465 1
    char *extra;
d617 1
a617 1
    char			*extra;
d673 4
a676 5
    if (stuff->pending && prop->is_pending)
	prop_value = &prop->pending;
    else
	prop_value = &prop->current;
    
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d27 2
a28 2
static void
RRDeliverEvent (ScreenPtr pScreen, xEvent *event, CARD32 mask)
d30 16
d47 17
d81 1
a81 1
	RRDeliverEvent (output->pScreen, (xEvent *) &event, RROutputPropertyNotifyMask);
d149 1
a149 1
	RRDeliverEvent (output->pScreen, (xEvent *) &event, RROutputPropertyNotifyMask);
d274 1
a274 1
	RRDeliverEvent (output->pScreen, (xEvent *) &event, RROutputPropertyNotifyMask);
d736 1
a736 1
	RRDeliverEvent (output->pScreen, (xEvent *) &event, RROutputPropertyNotifyMask);
@


1.1
log
@Initial revision
@
text
@d389 1
a389 1
        if(!(pAtoms = (Atom *)ALLOCATE_LOCAL(numProps * sizeof(Atom))))
d401 1
d407 1
a407 1
    WriteReplyToClient(client, sizeof(xRRListOutputPropertiesReply), &rep);
d412 1
a412 1
        DEALLOCATE_LOCAL(pAtoms);
d424 1
d437 5
d454 1
a454 1
    WriteReplyToClient (client, sizeof (xRRQueryOutputPropertyReply), &rep);
d457 1
d460 2
a461 1
				 prop->valid_values);
d576 1
d616 10
a625 1
	WriteReplyToClient(client, sizeof(xRRGetOutputPropertyReply), &reply);
d649 10
a658 1
	WriteReplyToClient(client, sizeof(xRRGetOutputPropertyReply), &reply);
d679 5
d706 10
a715 1
    WriteReplyToClient(client, sizeof(xGenericReply), &reply);
d718 1
d725 2
a726 1
				 (char *)prop_value->data + ind);
@


1.1.1.1
log
@xserver 1.4
@
text
@@
