head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	s0SI41sEunLdyFfd;

1.12
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2014.05.02.19.27.51;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.12.28.14.40.02;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.13;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.13;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.12;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright © 2000 Compaq Computer Corporation
 * Copyright © 2002 Hewlett-Packard Company
 * Copyright © 2006 Intel Corporation
 * Copyright © 2008 Red Hat, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 *
 * Author:  Jim Gettys, Hewlett-Packard Company, Inc.
 *	    Keith Packard, Intel Corporation
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _RANDRSTR_H_
#define _RANDRSTR_H_

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "resource.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "extnsionst.h"
#include "servermd.h"
#include "rrtransform.h"
#include <X11/extensions/randr.h>
#include <X11/extensions/randrproto.h>
#include <X11/extensions/render.h>      /* we share subpixel order information */
#include "picturestr.h"
#include <X11/Xfuncproto.h>

/* required for ABI compatibility for now */
#define RANDR_10_INTERFACE 1
#define RANDR_12_INTERFACE 1
#define RANDR_13_INTERFACE 1    /* requires RANDR_12_INTERFACE */
#define RANDR_GET_CRTC_INTERFACE 1

#define RANDR_INTERFACE_VERSION 0x0104

typedef XID RRMode;
typedef XID RROutput;
typedef XID RRCrtc;
typedef XID RRProvider;

extern int RREventBase, RRErrorBase;

extern int (*ProcRandrVector[RRNumberRequests]) (ClientPtr);
extern int (*SProcRandrVector[RRNumberRequests]) (ClientPtr);

/*
 * Modeline for a monitor. Name follows directly after this struct
 */

#define RRModeName(pMode) ((char *) (pMode + 1))
typedef struct _rrMode RRModeRec, *RRModePtr;
typedef struct _rrPropertyValue RRPropertyValueRec, *RRPropertyValuePtr;
typedef struct _rrProperty RRPropertyRec, *RRPropertyPtr;
typedef struct _rrCrtc RRCrtcRec, *RRCrtcPtr;
typedef struct _rrOutput RROutputRec, *RROutputPtr;
typedef struct _rrProvider RRProviderRec, *RRProviderPtr;
typedef struct _rrMonitor RRMonitorRec, *RRMonitorPtr;

struct _rrMode {
    int refcnt;
    xRRModeInfo mode;
    char *name;
    ScreenPtr userScreen;
};

struct _rrPropertyValue {
    Atom type;                  /* ignored by server */
    short format;               /* format of data for swapping - 8,16,32 */
    long size;                  /* size of data in (format/8) bytes */
    void *data;                 /* private to client */
};

struct _rrProperty {
    RRPropertyPtr next;
    ATOM propertyName;
    Bool is_pending;
    Bool range;
    Bool immutable;
    int num_valid;
    INT32 *valid_values;
    RRPropertyValueRec current, pending;
};

struct _rrCrtc {
    RRCrtc id;
    ScreenPtr pScreen;
    RRModePtr mode;
    int x, y;
    Rotation rotation;
    Rotation rotations;
    Bool changed;
    int numOutputs;
    RROutputPtr *outputs;
    int gammaSize;
    CARD16 *gammaRed;
    CARD16 *gammaBlue;
    CARD16 *gammaGreen;
    void *devPrivate;
    Bool transforms;
    RRTransformRec client_pending_transform;
    RRTransformRec client_current_transform;
    PictTransform transform;
    struct pict_f_transform f_transform;
    struct pict_f_transform f_inverse;

    PixmapPtr scanout_pixmap;
};

struct _rrOutput {
    RROutput id;
    ScreenPtr pScreen;
    char *name;
    int nameLength;
    CARD8 connection;
    CARD8 subpixelOrder;
    int mmWidth;
    int mmHeight;
    RRCrtcPtr crtc;
    int numCrtcs;
    RRCrtcPtr *crtcs;
    int numClones;
    RROutputPtr *clones;
    int numModes;
    int numPreferred;
    RRModePtr *modes;
    int numUserModes;
    RRModePtr *userModes;
    Bool changed;
    RRPropertyPtr properties;
    Bool pendingProperties;
    void *devPrivate;
};

struct _rrProvider {
    RRProvider id;
    ScreenPtr pScreen;
    uint32_t capabilities;
    char *name;
    int nameLength;
    RRPropertyPtr properties;
    Bool pendingProperties;
    Bool changed;
    struct _rrProvider *offload_sink;
    struct _rrProvider *output_source;
};

typedef struct _rrMonitorGeometry {
    BoxRec box;
    CARD32 mmWidth;
    CARD32 mmHeight;
} RRMonitorGeometryRec, *RRMonitorGeometryPtr;

struct _rrMonitor {
    Atom name;
    ScreenPtr pScreen;
    int numOutputs;
    RROutput *outputs;
    Bool primary;
    Bool automatic;
    RRMonitorGeometryRec geometry;
};

#if RANDR_12_INTERFACE
typedef Bool (*RRScreenSetSizeProcPtr) (ScreenPtr pScreen,
                                        CARD16 width,
                                        CARD16 height,
                                        CARD32 mmWidth, CARD32 mmHeight);

typedef Bool (*RRCrtcSetProcPtr) (ScreenPtr pScreen,
                                  RRCrtcPtr crtc,
                                  RRModePtr mode,
                                  int x,
                                  int y,
                                  Rotation rotation,
                                  int numOutputs, RROutputPtr * outputs);

typedef Bool (*RRCrtcSetGammaProcPtr) (ScreenPtr pScreen, RRCrtcPtr crtc);

typedef Bool (*RRCrtcGetGammaProcPtr) (ScreenPtr pScreen, RRCrtcPtr crtc);

typedef Bool (*RROutputSetPropertyProcPtr) (ScreenPtr pScreen,
                                            RROutputPtr output,
                                            Atom property,
                                            RRPropertyValuePtr value);

typedef Bool (*RROutputValidateModeProcPtr) (ScreenPtr pScreen,
                                             RROutputPtr output,
                                             RRModePtr mode);

typedef void (*RRModeDestroyProcPtr) (ScreenPtr pScreen, RRModePtr mode);

#endif

#if RANDR_13_INTERFACE
typedef Bool (*RROutputGetPropertyProcPtr) (ScreenPtr pScreen,
                                            RROutputPtr output, Atom property);
typedef Bool (*RRGetPanningProcPtr) (ScreenPtr pScrn,
                                     RRCrtcPtr crtc,
                                     BoxPtr totalArea,
                                     BoxPtr trackingArea, INT16 *border);
typedef Bool (*RRSetPanningProcPtr) (ScreenPtr pScrn,
                                     RRCrtcPtr crtc,
                                     BoxPtr totalArea,
                                     BoxPtr trackingArea, INT16 *border);

#endif                          /* RANDR_13_INTERFACE */

typedef Bool (*RRProviderGetPropertyProcPtr) (ScreenPtr pScreen,
                                            RRProviderPtr provider, Atom property);
typedef Bool (*RRProviderSetPropertyProcPtr) (ScreenPtr pScreen,
                                              RRProviderPtr provider,
                                              Atom property,
                                              RRPropertyValuePtr value);

typedef Bool (*RRGetInfoProcPtr) (ScreenPtr pScreen, Rotation * rotations);
typedef Bool (*RRCloseScreenProcPtr) (ScreenPtr pscreen);

typedef Bool (*RRProviderSetOutputSourceProcPtr)(ScreenPtr pScreen,
                                          RRProviderPtr provider,
                                          RRProviderPtr output_source);

typedef Bool (*RRProviderSetOffloadSinkProcPtr)(ScreenPtr pScreen,
                                         RRProviderPtr provider,
                                         RRProviderPtr offload_sink);


typedef void (*RRProviderDestroyProcPtr)(ScreenPtr pScreen,
                                         RRProviderPtr provider);

/* These are for 1.0 compatibility */

typedef struct _rrRefresh {
    CARD16 rate;
    RRModePtr mode;
} RRScreenRate, *RRScreenRatePtr;

typedef struct _rrScreenSize {
    int id;
    short width, height;
    short mmWidth, mmHeight;
    int nRates;
    RRScreenRatePtr pRates;
} RRScreenSize, *RRScreenSizePtr;

#ifdef RANDR_10_INTERFACE

typedef Bool (*RRSetConfigProcPtr) (ScreenPtr pScreen,
                                    Rotation rotation,
                                    int rate, RRScreenSizePtr pSize);

#endif

typedef Bool (*RRCrtcSetScanoutPixmapProcPtr)(RRCrtcPtr crtc, PixmapPtr pixmap);

typedef struct _rrScrPriv {
    /*
     * 'public' part of the structure; DDXen fill this in
     * as they initialize
     */
#if RANDR_10_INTERFACE
    RRSetConfigProcPtr rrSetConfig;
#endif
    RRGetInfoProcPtr rrGetInfo;
#if RANDR_12_INTERFACE
    RRScreenSetSizeProcPtr rrScreenSetSize;
    RRCrtcSetProcPtr rrCrtcSet;
    RRCrtcSetGammaProcPtr rrCrtcSetGamma;
    RRCrtcGetGammaProcPtr rrCrtcGetGamma;
    RROutputSetPropertyProcPtr rrOutputSetProperty;
    RROutputValidateModeProcPtr rrOutputValidateMode;
    RRModeDestroyProcPtr rrModeDestroy;
#endif
#if RANDR_13_INTERFACE
    RROutputGetPropertyProcPtr rrOutputGetProperty;
    RRGetPanningProcPtr rrGetPanning;
    RRSetPanningProcPtr rrSetPanning;
#endif
    /* TODO #if RANDR_15_INTERFACE */
    RRCrtcSetScanoutPixmapProcPtr rrCrtcSetScanoutPixmap;

    RRProviderSetOutputSourceProcPtr rrProviderSetOutputSource;
    RRProviderSetOffloadSinkProcPtr rrProviderSetOffloadSink;
    RRProviderGetPropertyProcPtr rrProviderGetProperty;
    RRProviderSetPropertyProcPtr rrProviderSetProperty;
    /*
     * Private part of the structure; not considered part of the ABI
     */
    TimeStamp lastSetTime;      /* last changed by client */
    TimeStamp lastConfigTime;   /* possible configs changed */
    RRCloseScreenProcPtr CloseScreen;

    Bool changed;               /* some config changed */
    Bool configChanged;         /* configuration changed */
    Bool layoutChanged;         /* screen layout changed */
    Bool resourcesChanged;      /* screen resources change */

    CARD16 minWidth, minHeight;
    CARD16 maxWidth, maxHeight;
    CARD16 width, height;       /* last known screen size */
    CARD16 mmWidth, mmHeight;   /* last known screen size */

    int numOutputs;
    RROutputPtr *outputs;
    RROutputPtr primaryOutput;

    int numCrtcs;
    RRCrtcPtr *crtcs;

    /* Last known pointer position */
    RRCrtcPtr pointerCrtc;

#ifdef RANDR_10_INTERFACE
    /*
     * Configuration information
     */
    Rotation rotations;
    CARD16 reqWidth, reqHeight;

    int nSizes;
    RRScreenSizePtr pSizes;

    Rotation rotation;
    int rate;
    int size;
#endif
    Bool discontiguous;

    RRProviderPtr provider;

    RRProviderDestroyProcPtr rrProviderDestroy;

    int numMonitors;
    RRMonitorPtr *monitors;

} rrScrPrivRec, *rrScrPrivPtr;

extern _X_EXPORT DevPrivateKeyRec rrPrivKeyRec;

#define rrPrivKey (&rrPrivKeyRec)

#define rrGetScrPriv(pScr)  ((rrScrPrivPtr)dixLookupPrivate(&(pScr)->devPrivates, rrPrivKey))
#define rrScrPriv(pScr)	rrScrPrivPtr    pScrPriv = rrGetScrPriv(pScr)
#define SetRRScreen(s,p) dixSetPrivate(&(s)->devPrivates, rrPrivKey, p)

/*
 * each window has a list of clients requesting
 * RRNotify events.  Each client has a resource
 * for each window it selects RRNotify input for,
 * this resource is used to delete the RRNotifyRec
 * entry from the per-window queue.
 */

typedef struct _RREvent *RREventPtr;

typedef struct _RREvent {
    RREventPtr next;
    ClientPtr client;
    WindowPtr window;
    XID clientResource;
    int mask;
} RREventRec;

typedef struct _RRTimes {
    TimeStamp setTime;
    TimeStamp configTime;
} RRTimesRec, *RRTimesPtr;

typedef struct _RRClient {
    int major_version;
    int minor_version;
/*  RRTimesRec	times[0]; */
} RRClientRec, *RRClientPtr;

extern RESTYPE RRClientType, RREventType;     /* resource types for event masks */
extern DevPrivateKeyRec RRClientPrivateKeyRec;

#define RRClientPrivateKey (&RRClientPrivateKeyRec)
extern _X_EXPORT RESTYPE RRCrtcType, RRModeType, RROutputType, RRProviderType;

#define VERIFY_RR_OUTPUT(id, ptr, a)\
    {\
	int rc = dixLookupResourceByType((void **)&(ptr), id,\
	                                 RROutputType, client, a);\
	if (rc != Success) {\
	    client->errorValue = id;\
	    return rc;\
	}\
    }

#define VERIFY_RR_CRTC(id, ptr, a)\
    {\
	int rc = dixLookupResourceByType((void **)&(ptr), id,\
	                                 RRCrtcType, client, a);\
	if (rc != Success) {\
	    client->errorValue = id;\
	    return rc;\
	}\
    }

#define VERIFY_RR_MODE(id, ptr, a)\
    {\
	int rc = dixLookupResourceByType((void **)&(ptr), id,\
	                                 RRModeType, client, a);\
	if (rc != Success) {\
	    client->errorValue = id;\
	    return rc;\
	}\
    }

#define VERIFY_RR_PROVIDER(id, ptr, a)\
    {\
        int rc = dixLookupResourceByType((void **)&(ptr), id,\
                                         RRProviderType, client, a);\
        if (rc != Success) {\
            client->errorValue = id;\
            return rc;\
        }\
    }

#define GetRRClient(pClient)    ((RRClientPtr)dixLookupPrivate(&(pClient)->devPrivates, RRClientPrivateKey))
#define rrClientPriv(pClient)	RRClientPtr pRRClient = GetRRClient(pClient)

#ifdef RANDR_12_INTERFACE
/*
 * Set the range of sizes for the screen
 */
extern _X_EXPORT void

RRScreenSetSizeRange(ScreenPtr pScreen,
                     CARD16 minWidth,
                     CARD16 minHeight, CARD16 maxWidth, CARD16 maxHeight);
#endif

/* rrscreen.c */
/*
 * Notify the extension that the screen size has been changed.
 * The driver is responsible for calling this whenever it has changed
 * the size of the screen
 */
extern _X_EXPORT void
 RRScreenSizeNotify(ScreenPtr pScreen);

/*
 * Request that the screen be resized
 */
extern _X_EXPORT Bool

RRScreenSizeSet(ScreenPtr pScreen,
                CARD16 width, CARD16 height, CARD32 mmWidth, CARD32 mmHeight);

/*
 * Send ConfigureNotify event to root window when 'something' happens
 */
extern _X_EXPORT void
 RRSendConfigNotify(ScreenPtr pScreen);

/*
 * screen dispatch
 */
extern _X_EXPORT int
 ProcRRGetScreenSizeRange(ClientPtr client);

extern _X_EXPORT int
 ProcRRSetScreenSize(ClientPtr client);

extern _X_EXPORT int
 ProcRRGetScreenResources(ClientPtr client);

extern _X_EXPORT int
 ProcRRGetScreenResourcesCurrent(ClientPtr client);

extern _X_EXPORT int
 ProcRRSetScreenConfig(ClientPtr client);

extern _X_EXPORT int
 ProcRRGetScreenInfo(ClientPtr client);

/*
 * Deliver a ScreenNotify event
 */
extern _X_EXPORT void
 RRDeliverScreenEvent(ClientPtr client, WindowPtr pWin, ScreenPtr pScreen);

extern _X_EXPORT void
 RRResourcesChanged(ScreenPtr pScreen);

/* randr.c */
/* set a screen change on the primary screen */
extern _X_EXPORT void
RRSetChanged(ScreenPtr pScreen);

/*
 * Send all pending events
 */
extern _X_EXPORT void
 RRTellChanged(ScreenPtr pScreen);

/*
 * Poll the driver for changed information
 */
extern _X_EXPORT Bool
 RRGetInfo(ScreenPtr pScreen, Bool force_query);

extern _X_EXPORT Bool RRInit(void);

extern _X_EXPORT Bool RRScreenInit(ScreenPtr pScreen);

extern _X_EXPORT RROutputPtr RRFirstOutput(ScreenPtr pScreen);

extern _X_EXPORT CARD16
 RRVerticalRefresh(xRRModeInfo * mode);

#ifdef RANDR_10_INTERFACE
/*
 * This is the old interface, deprecated but left
 * around for compatibility
 */

/*
 * Then, register the specific size with the screen
 */

extern _X_EXPORT RRScreenSizePtr
RRRegisterSize(ScreenPtr pScreen,
               short width, short height, short mmWidth, short mmHeight);

extern _X_EXPORT Bool
 RRRegisterRate(ScreenPtr pScreen, RRScreenSizePtr pSize, int rate);

/*
 * Finally, set the current configuration of the screen
 */

extern _X_EXPORT void

RRSetCurrentConfig(ScreenPtr pScreen,
                   Rotation rotation, int rate, RRScreenSizePtr pSize);

extern _X_EXPORT Rotation RRGetRotation(ScreenPtr pScreen);

#endif

/* rrcrtc.c */

/*
 * Notify the CRTC of some change; layoutChanged indicates that
 * some position or size element changed
 */
extern _X_EXPORT void
 RRCrtcChanged(RRCrtcPtr crtc, Bool layoutChanged);

/*
 * Create a CRTC
 */
extern _X_EXPORT RRCrtcPtr RRCrtcCreate(ScreenPtr pScreen, void *devPrivate);

/*
 * Set the allowed rotations on a CRTC
 */
extern _X_EXPORT void
 RRCrtcSetRotations(RRCrtcPtr crtc, Rotation rotations);

/*
 * Set whether transforms are allowed on a CRTC
 */
extern _X_EXPORT void
 RRCrtcSetTransformSupport(RRCrtcPtr crtc, Bool transforms);

/*
 * Notify the extension that the Crtc has been reconfigured,
 * the driver calls this whenever it has updated the mode
 */
extern _X_EXPORT Bool

RRCrtcNotify(RRCrtcPtr crtc,
             RRModePtr mode,
             int x,
             int y,
             Rotation rotation,
             RRTransformPtr transform, int numOutputs, RROutputPtr * outputs);

extern _X_EXPORT void
 RRDeliverCrtcEvent(ClientPtr client, WindowPtr pWin, RRCrtcPtr crtc);

/*
 * Request that the Crtc be reconfigured
 */
extern _X_EXPORT Bool

RRCrtcSet(RRCrtcPtr crtc,
          RRModePtr mode,
          int x,
          int y, Rotation rotation, int numOutput, RROutputPtr * outputs);

/*
 * Request that the Crtc gamma be changed
 */

extern _X_EXPORT Bool
 RRCrtcGammaSet(RRCrtcPtr crtc, CARD16 *red, CARD16 *green, CARD16 *blue);

/*
 * Request current gamma back from the DDX (if possible).
 * This includes gamma size.
 */

extern _X_EXPORT Bool
 RRCrtcGammaGet(RRCrtcPtr crtc);

/*
 * Notify the extension that the Crtc gamma has been changed
 * The driver calls this whenever it has changed the gamma values
 * in the RRCrtcRec
 */

extern _X_EXPORT Bool
 RRCrtcGammaNotify(RRCrtcPtr crtc);

/*
 * Set the size of the gamma table at server startup time
 */

extern _X_EXPORT Bool
 RRCrtcGammaSetSize(RRCrtcPtr crtc, int size);

/*
 * Return the area of the frame buffer scanned out by the crtc,
 * taking into account the current mode and rotation
 */

extern _X_EXPORT void
 RRCrtcGetScanoutSize(RRCrtcPtr crtc, int *width, int *height);

/*
 * Return crtc transform
 */
extern _X_EXPORT RRTransformPtr RRCrtcGetTransform(RRCrtcPtr crtc);

/*
 * Check whether the pending and current transforms are the same
 */
extern _X_EXPORT Bool
 RRCrtcPendingTransform(RRCrtcPtr crtc);

/*
 * Destroy a Crtc at shutdown
 */
extern _X_EXPORT void
 RRCrtcDestroy(RRCrtcPtr crtc);

/*
 * Set the pending CRTC transformation
 */

extern _X_EXPORT int

RRCrtcTransformSet(RRCrtcPtr crtc,
                   PictTransformPtr transform,
                   struct pict_f_transform *f_transform,
                   struct pict_f_transform *f_inverse,
                   char *filter, int filter_len, xFixed * params, int nparams);

/*
 * Initialize crtc type
 */
extern _X_EXPORT Bool
 RRCrtcInit(void);

/*
 * Initialize crtc type error value
 */
extern _X_EXPORT void
 RRCrtcInitErrorValue(void);

/*
 * Detach and free a scanout pixmap
 */
extern _X_EXPORT void
 RRCrtcDetachScanoutPixmap(RRCrtcPtr crtc);

extern _X_EXPORT Bool
 RRReplaceScanoutPixmap(DrawablePtr pDrawable, PixmapPtr pPixmap, Bool enable);

/*
 * Crtc dispatch
 */

extern _X_EXPORT int
 ProcRRGetCrtcInfo(ClientPtr client);

extern _X_EXPORT int
 ProcRRSetCrtcConfig(ClientPtr client);

extern _X_EXPORT int
 ProcRRGetCrtcGammaSize(ClientPtr client);

extern _X_EXPORT int
 ProcRRGetCrtcGamma(ClientPtr client);

extern _X_EXPORT int
 ProcRRSetCrtcGamma(ClientPtr client);

extern _X_EXPORT int
 ProcRRSetCrtcTransform(ClientPtr client);

extern _X_EXPORT int
 ProcRRGetCrtcTransform(ClientPtr client);

int
 ProcRRGetPanning(ClientPtr client);

int
 ProcRRSetPanning(ClientPtr client);

void
 RRConstrainCursorHarder(DeviceIntPtr, ScreenPtr, int, int *, int *);

/* rrdispatch.c */
extern _X_EXPORT Bool
 RRClientKnowsRates(ClientPtr pClient);

/* rrmode.c */
/*
 * Find, and if necessary, create a mode
 */

extern _X_EXPORT RRModePtr RRModeGet(xRRModeInfo * modeInfo, const char *name);

/*
 * Destroy a mode.
 */

extern _X_EXPORT void
 RRModeDestroy(RRModePtr mode);

/*
 * Return a list of modes that are valid for some output in pScreen
 */
extern _X_EXPORT RRModePtr *RRModesForScreen(ScreenPtr pScreen, int *num_ret);

/*
 * Initialize mode type
 */
extern _X_EXPORT Bool
 RRModeInit(void);

/*
 * Initialize mode type error value
 */
extern _X_EXPORT void
 RRModeInitErrorValue(void);

extern _X_EXPORT int
 ProcRRCreateMode(ClientPtr client);

extern _X_EXPORT int
 ProcRRDestroyMode(ClientPtr client);

extern _X_EXPORT int
 ProcRRAddOutputMode(ClientPtr client);

extern _X_EXPORT int
 ProcRRDeleteOutputMode(ClientPtr client);

/* rroutput.c */

/*
 * Notify the output of some change. configChanged indicates whether
 * any external configuration (mode list, clones, connected status)
 * has changed, or whether the change was strictly internal
 * (which crtc is in use)
 */
extern _X_EXPORT void
 RROutputChanged(RROutputPtr output, Bool configChanged);

/*
 * Create an output
 */

extern _X_EXPORT RROutputPtr
RROutputCreate(ScreenPtr pScreen,
               const char *name, int nameLength, void *devPrivate);

/*
 * Notify extension that output parameters have been changed
 */
extern _X_EXPORT Bool
 RROutputSetClones(RROutputPtr output, RROutputPtr * clones, int numClones);

extern _X_EXPORT Bool

RROutputSetModes(RROutputPtr output,
                 RRModePtr * modes, int numModes, int numPreferred);

extern _X_EXPORT int
 RROutputAddUserMode(RROutputPtr output, RRModePtr mode);

extern _X_EXPORT int
 RROutputDeleteUserMode(RROutputPtr output, RRModePtr mode);

extern _X_EXPORT Bool
 RROutputSetCrtcs(RROutputPtr output, RRCrtcPtr * crtcs, int numCrtcs);

extern _X_EXPORT Bool
 RROutputSetConnection(RROutputPtr output, CARD8 connection);

extern _X_EXPORT Bool
 RROutputSetSubpixelOrder(RROutputPtr output, int subpixelOrder);

extern _X_EXPORT Bool
 RROutputSetPhysicalSize(RROutputPtr output, int mmWidth, int mmHeight);

extern _X_EXPORT void
 RRDeliverOutputEvent(ClientPtr client, WindowPtr pWin, RROutputPtr output);

extern _X_EXPORT void
 RROutputDestroy(RROutputPtr output);

extern _X_EXPORT int
 ProcRRGetOutputInfo(ClientPtr client);

extern _X_EXPORT int
 ProcRRSetOutputPrimary(ClientPtr client);

extern _X_EXPORT int
 ProcRRGetOutputPrimary(ClientPtr client);

/*
 * Initialize output type
 */
extern _X_EXPORT Bool
 RROutputInit(void);

/*
 * Initialize output type error value
 */
extern _X_EXPORT void
 RROutputInitErrorValue(void);

/* rrpointer.c */
extern _X_EXPORT void
 RRPointerMoved(ScreenPtr pScreen, int x, int y);

extern _X_EXPORT void
 RRPointerScreenConfigured(ScreenPtr pScreen);

/* rrproperty.c */

extern _X_EXPORT void
 RRDeleteAllOutputProperties(RROutputPtr output);

extern _X_EXPORT RRPropertyValuePtr
RRGetOutputProperty(RROutputPtr output, Atom property, Bool pending);

extern _X_EXPORT RRPropertyPtr
RRQueryOutputProperty(RROutputPtr output, Atom property);

extern _X_EXPORT void
 RRDeleteOutputProperty(RROutputPtr output, Atom property);

extern _X_EXPORT Bool
 RRPostPendingProperties(RROutputPtr output);

extern _X_EXPORT int

RRChangeOutputProperty(RROutputPtr output, Atom property, Atom type,
                       int format, int mode, unsigned long len,
                       void *value, Bool sendevent, Bool pending);

extern _X_EXPORT int

RRConfigureOutputProperty(RROutputPtr output, Atom property,
                          Bool pending, Bool range, Bool immutable,
                          int num_values, INT32 *values);
extern _X_EXPORT int
 ProcRRChangeOutputProperty(ClientPtr client);

extern _X_EXPORT int
 ProcRRGetOutputProperty(ClientPtr client);

extern _X_EXPORT int
 ProcRRListOutputProperties(ClientPtr client);

extern _X_EXPORT int
 ProcRRQueryOutputProperty(ClientPtr client);

extern _X_EXPORT int
 ProcRRConfigureOutputProperty(ClientPtr client);

extern _X_EXPORT int
 ProcRRDeleteOutputProperty(ClientPtr client);

/* rrprovider.c */
extern _X_EXPORT void
RRProviderInitErrorValue(void);

extern _X_EXPORT int
ProcRRGetProviders(ClientPtr client);

extern _X_EXPORT int
ProcRRGetProviderInfo(ClientPtr client);

extern _X_EXPORT int
ProcRRSetProviderOutputSource(ClientPtr client);

extern _X_EXPORT int
ProcRRSetProviderOffloadSink(ClientPtr client);

extern _X_EXPORT Bool
RRProviderInit(void);

extern _X_EXPORT RRProviderPtr
RRProviderCreate(ScreenPtr pScreen, const char *name,
                 int nameLength);

extern _X_EXPORT void
RRProviderDestroy (RRProviderPtr provider);

extern _X_EXPORT void
RRProviderSetCapabilities(RRProviderPtr provider, uint32_t capabilities);

extern _X_EXPORT Bool
RRProviderLookup(XID id, RRProviderPtr *provider_p);

extern _X_EXPORT void
RRDeliverProviderEvent(ClientPtr client, WindowPtr pWin, RRProviderPtr provider);

/* rrproviderproperty.c */

extern _X_EXPORT void
 RRDeleteAllProviderProperties(RRProviderPtr provider);

extern _X_EXPORT RRPropertyValuePtr
 RRGetProviderProperty(RRProviderPtr provider, Atom property, Bool pending);

extern _X_EXPORT RRPropertyPtr
 RRQueryProviderProperty(RRProviderPtr provider, Atom property);

extern _X_EXPORT void
 RRDeleteProviderProperty(RRProviderPtr provider, Atom property);

extern _X_EXPORT int
RRChangeProviderProperty(RRProviderPtr provider, Atom property, Atom type,
                       int format, int mode, unsigned long len,
                       void *value, Bool sendevent, Bool pending);

extern _X_EXPORT int
 RRConfigureProviderProperty(RRProviderPtr provider, Atom property,
                             Bool pending, Bool range, Bool immutable,
                             int num_values, INT32 *values);

extern _X_EXPORT Bool
 RRPostProviderPendingProperties(RRProviderPtr provider);

extern _X_EXPORT int
 ProcRRGetProviderProperty(ClientPtr client);

extern _X_EXPORT int
 ProcRRListProviderProperties(ClientPtr client);

extern _X_EXPORT int
 ProcRRQueryProviderProperty(ClientPtr client);

extern _X_EXPORT int
ProcRRConfigureProviderProperty(ClientPtr client);

extern _X_EXPORT int
ProcRRChangeProviderProperty(ClientPtr client);

extern _X_EXPORT int
 ProcRRDeleteProviderProperty(ClientPtr client);
/* rrxinerama.c */
#ifdef XINERAMA
extern _X_EXPORT void
 RRXineramaExtensionInit(void);
#endif

void
RRMonitorInit(ScreenPtr screen);

Bool
RRMonitorMakeList(ScreenPtr screen, Bool get_active, RRMonitorPtr *monitors_ret, int *nmon_ret);

int
RRMonitorCountList(ScreenPtr screen);

void
RRMonitorFreeList(RRMonitorPtr monitors, int nmon);

void
RRMonitorClose(ScreenPtr screen);

RRMonitorPtr
RRMonitorAlloc(int noutput);

int
RRMonitorAdd(ClientPtr client, ScreenPtr screen, RRMonitorPtr monitor);

void
RRMonitorFree(RRMonitorPtr monitor);

int
ProcRRGetMonitors(ClientPtr client);

int
ProcRRSetMonitor(ClientPtr client);

int
ProcRRDeleteMonitor(ClientPtr client);

#endif                          /* _RANDRSTR_H_ */

/*

randr extension implementation structure

Query state:
    ProcRRGetScreenInfo/ProcRRGetScreenResources
	RRGetInfo

	    • Request configuration from driver, either 1.0 or 1.2 style
	    • These functions only record state changes, all
	      other actions are pended until RRTellChanged is called

	    ->rrGetInfo
	    1.0:
		RRRegisterSize
		RRRegisterRate
		RRSetCurrentConfig
	    1.2:
		RRScreenSetSizeRange
		RROutputSetCrtcs
		RRModeGet
		RROutputSetModes
		RROutputSetConnection
		RROutputSetSubpixelOrder
		RROutputSetClones
		RRCrtcNotify

	• Must delay scanning configuration until after ->rrGetInfo returns
	  because some drivers will call SetCurrentConfig in the middle
	  of the ->rrGetInfo operation.

	1.0:

	    • Scan old configuration, mirror to new structures

	    RRScanOldConfig
		RRCrtcCreate
		RROutputCreate
		RROutputSetCrtcs
		RROutputSetConnection
		RROutputSetSubpixelOrder
		RROldModeAdd	• This adds modes one-at-a-time
		    RRModeGet
		RRCrtcNotify

	• send events, reset pointer if necessary

	RRTellChanged
	    WalkTree (sending events)

	    • when layout has changed:
		RRPointerScreenConfigured
		RRSendConfigNotify

Asynchronous state setting (1.2 only)
    When setting state asynchronously, the driver invokes the
    ->rrGetInfo function and then calls RRTellChanged to flush
    the changes to the clients and reset pointer if necessary

Set state

    ProcRRSetScreenConfig
	RRCrtcSet
	    1.2:
		->rrCrtcSet
		    RRCrtcNotify
	    1.0:
		->rrSetConfig
		RRCrtcNotify
	    RRTellChanged
 */
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d67 1
a67 1
extern _X_EXPORT int RREventBase, RRErrorBase;
d69 2
a70 2
extern _X_EXPORT int (*ProcRandrVector[RRNumberRequests]) (ClientPtr);
extern _X_EXPORT int (*SProcRandrVector[RRNumberRequests]) (ClientPtr);
d83 1
d173 16
d358 3
d400 2
a401 2
extern _X_EXPORT RESTYPE RRClientType, RREventType;     /* resource types for event masks */
extern _X_EXPORT DevPrivateKeyRec RRClientPrivateKeyRec;
d1003 33
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d987 1
a987 1
 
d993 1
a993 1
 
d997 1
a997 1
 
d1012 1
a1012 1
 
d1016 1
a1016 1
 
d1020 1
a1020 1
 
d1030 1
a1030 1
 
d1032 1
a1032 1
 
d1035 1
a1035 1
 
d1039 1
a1039 1
 
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d95 1
a95 1
    pointer data;               /* private to client */
d388 1
a388 1
	int rc = dixLookupResourceByType((pointer *)&(ptr), id,\
d398 1
a398 1
	int rc = dixLookupResourceByType((pointer *)&(ptr), id,\
d408 1
a408 1
	int rc = dixLookupResourceByType((pointer *)&(ptr), id,\
d418 1
a418 1
        int rc = dixLookupResourceByType((pointer *)&(ptr), id,\
d874 1
a874 1
                       pointer value, Bool sendevent, Bool pending);
d951 1
a951 1
                       pointer value, Bool sendevent, Bool pending);
@


1.9
log
@Update to xserver 1.14.5
@
text
@d167 1
a169 1
    Bool changed;
d304 1
a340 1
    Bool resourcesChanged;      /* screen resources change */
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d169 1
d340 1
d490 3
d494 4
d930 3
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d60 1
a60 1
#define RANDR_INTERFACE_VERSION 0x0103
d65 1
d82 1
d130 2
d159 12
d216 7
d224 13
a236 1
typedef Bool (*RRCloseScreenProcPtr) (int i, ScreenPtr pscreen);
d261 2
d286 2
d289 4
d334 5
d382 1
a382 1
extern _X_EXPORT RESTYPE RRCrtcType, RRModeType, RROutputType;
d414 10
a426 4
/* Initialize the extension */
extern _X_EXPORT void
 RRExtensionInit(void);

a631 19
 * Compute the complete transformation matrix including
 * client-specified transform, rotation/reflection values and the crtc 
 * offset.
 *
 * Return TRUE if the resulting transform is not a simple translation.
 */
extern _X_EXPORT Bool

RRTransformCompute(int x,
                   int y,
                   int width,
                   int height,
                   Rotation rotation,
                   RRTransformPtr rr_transform,
                   PictTransformPtr transform,
                   struct pict_f_transform *f_transform,
                   struct pict_f_transform *f_inverse);

/*
d673 9
d890 76
@


1.6
log
@Update to xserver 1.11.2
@
text
@d50 1
a50 1
#include <X11/extensions/render.h> 	/* we share subpixel order information */
d57 1
a57 1
#define RANDR_13_INTERFACE 1 /* requires RANDR_12_INTERFACE */
d62 9
a70 9
typedef XID	RRMode;
typedef XID	RROutput;
typedef XID	RRCrtc;

extern _X_EXPORT int	RREventBase, RRErrorBase;

extern _X_EXPORT int (*ProcRandrVector[RRNumberRequests])(ClientPtr);
extern _X_EXPORT int (*SProcRandrVector[RRNumberRequests])(ClientPtr);
    
d76 5
a80 5
typedef struct _rrMode		RRModeRec, *RRModePtr;
typedef struct _rrPropertyValue	RRPropertyValueRec, *RRPropertyValuePtr;
typedef struct _rrProperty	RRPropertyRec, *RRPropertyPtr;
typedef struct _rrCrtc		RRCrtcRec, *RRCrtcPtr;
typedef struct _rrOutput	RROutputRec, *RROutputPtr;
d83 4
a86 4
    int		    refcnt;
    xRRModeInfo	    mode;
    char	    *name;
    ScreenPtr	    userScreen;
d90 4
a93 4
    Atom	    type;       /* ignored by server */
    short	    format;     /* format of data for swapping - 8,16,32 */
    long	    size;	/* size of data in (format/8) bytes */
    pointer         data;	/* private to client */
d97 8
a104 8
    RRPropertyPtr   next;
    ATOM 	    propertyName;
    Bool	    is_pending;
    Bool	    range;
    Bool	    immutable;
    int		    num_valid;
    INT32	    *valid_values;
    RRPropertyValueRec	current, pending;
d108 18
a125 18
    RRCrtc	    id;
    ScreenPtr	    pScreen;
    RRModePtr	    mode;
    int		    x, y;
    Rotation	    rotation;
    Rotation	    rotations;
    Bool	    changed;
    int		    numOutputs;
    RROutputPtr	    *outputs;
    int		    gammaSize;
    CARD16	    *gammaRed;
    CARD16	    *gammaBlue;
    CARD16	    *gammaGreen;
    void	    *devPrivate;
    Bool	    transforms;
    RRTransformRec  client_pending_transform;
    RRTransformRec  client_current_transform;
    PictTransform   transform;
d131 22
a152 22
    RROutput	    id;
    ScreenPtr	    pScreen;
    char	    *name;
    int		    nameLength;
    CARD8	    connection;
    CARD8	    subpixelOrder;
    int		    mmWidth;
    int		    mmHeight;
    RRCrtcPtr	    crtc;
    int		    numCrtcs;
    RRCrtcPtr	    *crtcs;
    int		    numClones;
    RROutputPtr	    *clones;
    int		    numModes;
    int		    numPreferred;
    RRModePtr	    *modes;
    int		    numUserModes;
    RRModePtr	    *userModes;
    Bool	    changed;
    RRPropertyPtr   properties;
    Bool	    pendingProperties;
    void	    *devPrivate;
d156 25
a180 29
typedef Bool (*RRScreenSetSizeProcPtr) (ScreenPtr	pScreen,
					CARD16		width,
					CARD16		height,
					CARD32		mmWidth,
					CARD32		mmHeight);
					
typedef Bool (*RRCrtcSetProcPtr) (ScreenPtr		pScreen,
				  RRCrtcPtr		crtc,
				  RRModePtr		mode,
				  int			x,
				  int			y,
				  Rotation		rotation,
				  int			numOutputs,
				  RROutputPtr		*outputs);

typedef Bool (*RRCrtcSetGammaProcPtr) (ScreenPtr	pScreen,
				       RRCrtcPtr	crtc);

typedef Bool (*RRCrtcGetGammaProcPtr) (ScreenPtr	pScreen,
				       RRCrtcPtr	crtc);

typedef Bool (*RROutputSetPropertyProcPtr) (ScreenPtr		pScreen,
					    RROutputPtr		output,
					    Atom		property,
					    RRPropertyValuePtr	value);

typedef Bool (*RROutputValidateModeProcPtr) (ScreenPtr		pScreen,
					     RROutputPtr	output,
					     RRModePtr		mode);
d182 1
a182 2
typedef void (*RRModeDestroyProcPtr) (ScreenPtr	    pScreen,
				      RRModePtr	    mode);
d187 10
a196 13
typedef Bool (*RROutputGetPropertyProcPtr) (ScreenPtr		pScreen,
					    RROutputPtr		output,
					    Atom		property);
typedef Bool (*RRGetPanningProcPtr)    (ScreenPtr		pScrn,
					RRCrtcPtr		crtc,
					BoxPtr		totalArea,
					BoxPtr		trackingArea,
					INT16		*border);
typedef Bool (*RRSetPanningProcPtr)    (ScreenPtr		pScrn,
					RRCrtcPtr		crtc,
					BoxPtr		totalArea,
					BoxPtr		trackingArea,
					INT16		*border);
d198 1
a198 1
#endif /* RANDR_13_INTERFACE */
d200 2
a201 2
typedef Bool (*RRGetInfoProcPtr) (ScreenPtr pScreen, Rotation *rotations);
typedef Bool (*RRCloseScreenProcPtr) ( int i, ScreenPtr pscreen);
d204 1
a204 1
 
d206 2
a207 2
    CARD16	    rate;
    RRModePtr	    mode;
d211 4
a214 4
    int		    id;
    short	    width, height;
    short	    mmWidth, mmHeight;
    int		    nRates;
d220 3
a222 4
typedef Bool (*RRSetConfigProcPtr) (ScreenPtr		pScreen,
				    Rotation		rotation,
				    int			rate,
				    RRScreenSizePtr	pSize);
a224 1
	
d232 1
a232 1
    RRSetConfigProcPtr	    rrSetConfig;
d234 1
a234 1
    RRGetInfoProcPtr	    rrGetInfo;
d236 7
a242 7
    RRScreenSetSizeProcPtr  rrScreenSetSize;
    RRCrtcSetProcPtr	    rrCrtcSet;
    RRCrtcSetGammaProcPtr   rrCrtcSetGamma;
    RRCrtcGetGammaProcPtr   rrCrtcGetGamma;
    RROutputSetPropertyProcPtr	rrOutputSetProperty;
    RROutputValidateModeProcPtr	rrOutputValidateMode;
    RRModeDestroyProcPtr	rrModeDestroy;
d245 3
a247 3
    RROutputGetPropertyProcPtr	rrOutputGetProperty;
    RRGetPanningProcPtr	rrGetPanning;
    RRSetPanningProcPtr	rrSetPanning;
d249 1
a249 1
    
d253 16
a268 16
    TimeStamp		    lastSetTime;	/* last changed by client */
    TimeStamp		    lastConfigTime;	/* possible configs changed */
    RRCloseScreenProcPtr    CloseScreen;

    Bool		    changed;		/* some config changed */
    Bool		    configChanged;	/* configuration changed */
    Bool		    layoutChanged;	/* screen layout changed */

    CARD16		    minWidth, minHeight;
    CARD16		    maxWidth, maxHeight;
    CARD16		    width, height;	/* last known screen size */
    CARD16		    mmWidth, mmHeight;	/* last known screen size */

    int			    numOutputs;
    RROutputPtr		    *outputs;
    RROutputPtr		    primaryOutput;
d270 2
a271 2
    int			    numCrtcs;
    RRCrtcPtr		    *crtcs;
d274 1
a274 1
    RRCrtcPtr		    pointerCrtc;
d280 9
a288 9
    Rotation		    rotations;
    CARD16		    reqWidth, reqHeight;
    
    int			    nSizes;
    RRScreenSizePtr	    pSizes;
    
    Rotation		    rotation;
    int			    rate;
    int			    size;
d290 1
a290 1
    Bool                   discontiguous;
d294 1
d312 5
a316 5
    RREventPtr  next;
    ClientPtr	client;
    WindowPtr	window;
    XID		clientResource;
    int		mask;
d320 2
a321 2
    TimeStamp	setTime;
    TimeStamp	configTime;
d325 2
a326 2
    int		major_version;
    int		minor_version;
d330 1
a330 1
extern _X_EXPORT RESTYPE RRClientType, RREventType; /* resource types for event masks */
d332 1
d371 1
a371 1
RRExtensionInit (void);
d378 4
a381 5
RRScreenSetSizeRange (ScreenPtr	pScreen,
		      CARD16	minWidth,
		      CARD16	minHeight,
		      CARD16	maxWidth,
		      CARD16	maxHeight);
d391 1
a391 1
RRScreenSizeNotify (ScreenPtr	pScreen);
d397 3
a399 5
RRScreenSizeSet (ScreenPtr  pScreen,
		 CARD16	    width,
		 CARD16	    height,
		 CARD32	    mmWidth,
		 CARD32	    mmHeight);
d405 2
a406 2
RRSendConfigNotify (ScreenPtr pScreen);
    
d411 1
a411 1
ProcRRGetScreenSizeRange (ClientPtr client);
d414 1
a414 1
ProcRRSetScreenSize (ClientPtr client);
d417 1
a417 1
ProcRRGetScreenResources (ClientPtr client);
d420 1
a420 1
ProcRRGetScreenResourcesCurrent (ClientPtr client);
d423 1
a423 1
ProcRRSetScreenConfig (ClientPtr client);
d426 1
a426 1
ProcRRGetScreenInfo (ClientPtr client);
d432 2
a433 2
RRDeliverScreenEvent (ClientPtr client, WindowPtr pWin, ScreenPtr pScreen);
    
d439 1
a439 1
RRTellChanged (ScreenPtr pScreen);
d445 1
a445 1
RRGetInfo (ScreenPtr pScreen, Bool force_query);
d447 1
a447 1
extern _X_EXPORT Bool RRInit (void);
d451 1
a451 5
extern _X_EXPORT RROutputPtr
RRFirstOutput (ScreenPtr pScreen);

extern _X_EXPORT Rotation
RRGetRotation (ScreenPtr pScreen);
d454 1
a454 1
RRVerticalRefresh (xRRModeInfo *mode);
d456 1
a456 1
#ifdef RANDR_10_INTERFACE					
d467 2
a468 5
RRRegisterSize (ScreenPtr		pScreen,
		short			width, 
		short			height,
		short			mmWidth,
		short			mmHeight);
d471 1
a471 3
RRRegisterRate (ScreenPtr		pScreen,
		     RRScreenSizePtr	pSize,
		     int		rate);
a477 4
RRSetCurrentConfig (ScreenPtr		pScreen,
		    Rotation		rotation,
		    int			rate,
		    RRScreenSizePtr	pSize);
d479 2
a480 1
extern _X_EXPORT Bool RRScreenInit (ScreenPtr pScreen);
d482 1
a482 2
extern _X_EXPORT Rotation
RRGetRotation (ScreenPtr pScreen);
d484 1
a484 1
#endif					
d493 1
a493 1
RRCrtcChanged (RRCrtcPtr crtc, Bool layoutChanged);
d498 1
a498 2
extern _X_EXPORT RRCrtcPtr
RRCrtcCreate (ScreenPtr pScreen, void	*devPrivate);
d504 1
a504 1
RRCrtcSetRotations (RRCrtcPtr crtc, Rotation rotations);
d510 1
a510 1
RRCrtcSetTransformSupport (RRCrtcPtr crtc, Bool transforms);
d517 7
a523 8
RRCrtcNotify (RRCrtcPtr	    crtc,
	      RRModePtr	    mode,
	      int	    x,
	      int	    y,
	      Rotation	    rotation,
	      RRTransformPtr transform,
	      int	    numOutputs,
	      RROutputPtr   *outputs);
d526 2
a527 2
RRDeliverCrtcEvent (ClientPtr client, WindowPtr pWin, RRCrtcPtr crtc);
    
d532 5
a536 7
RRCrtcSet (RRCrtcPtr    crtc,
	   RRModePtr	mode,
	   int		x,
	   int		y,
	   Rotation	rotation,
	   int		numOutput,
	   RROutputPtr  *outputs);
d543 1
a543 4
RRCrtcGammaSet (RRCrtcPtr   crtc,
		CARD16	    *red,
		CARD16	    *green,
		CARD16	    *blue);
d549 1
a549 1
 
d551 1
a551 1
RRCrtcGammaGet(RRCrtcPtr crtc);
d560 1
a560 1
RRCrtcGammaNotify (RRCrtcPtr	crtc);
d567 1
a567 2
RRCrtcGammaSetSize (RRCrtcPtr	crtc,
		    int		size);
d575 1
a575 1
RRCrtcGetScanoutSize(RRCrtcPtr crtc, int *width, int *height);
d585 10
a594 10
RRTransformCompute (int			    x,
		    int			    y,
		    int			    width,
		    int			    height,
		    Rotation		    rotation,
		    RRTransformPtr	    rr_transform,

		    PictTransformPtr	    transform,
		    struct pict_f_transform *f_transform,
		    struct pict_f_transform *f_inverse);
d599 1
a599 2
extern _X_EXPORT RRTransformPtr
RRCrtcGetTransform (RRCrtcPtr crtc);
d605 1
a605 1
RRCrtcPendingTransform (RRCrtcPtr crtc);
d611 1
a611 2
RRCrtcDestroy (RRCrtcPtr crtc);

d618 6
a623 8
RRCrtcTransformSet (RRCrtcPtr		crtc,
		    PictTransformPtr	transform,
		    struct pict_f_transform *f_transform,
		    struct pict_f_transform *f_inverse,
		    char		*filter,
		    int			filter_len,
		    xFixed		*params,
		    int			nparams);
d629 1
a629 1
RRCrtcInit (void);
d635 1
a635 1
RRCrtcInitErrorValue (void);
d642 1
a642 1
ProcRRGetCrtcInfo (ClientPtr client);
d645 1
a645 1
ProcRRSetCrtcConfig (ClientPtr client);
d648 1
a648 1
ProcRRGetCrtcGammaSize (ClientPtr client);
d651 1
a651 1
ProcRRGetCrtcGamma (ClientPtr client);
d654 1
a654 1
ProcRRSetCrtcGamma (ClientPtr client);
d657 1
a657 1
ProcRRSetCrtcTransform (ClientPtr client);
d660 1
a660 1
ProcRRGetCrtcTransform (ClientPtr client);
d663 1
a663 1
ProcRRGetPanning (ClientPtr client);
d666 1
a666 1
ProcRRSetPanning (ClientPtr client);
d669 1
a669 1
RRConstrainCursorHarder (DeviceIntPtr, ScreenPtr, int, int *, int *);
d673 1
a673 1
RRClientKnowsRates (ClientPtr	pClient);
d680 1
a680 3
extern _X_EXPORT RRModePtr
RRModeGet (xRRModeInfo	*modeInfo,
	   const char	*name);
d687 1
a687 1
RRModeDestroy (RRModePtr mode);
d692 2
a693 3
extern _X_EXPORT RRModePtr *
RRModesForScreen (ScreenPtr pScreen, int *num_ret);
    
d698 1
a698 1
RRModeInit (void);
d704 2
a705 2
RRModeInitErrorValue (void);
    
d707 1
a707 1
ProcRRCreateMode (ClientPtr client);
d710 1
a710 1
ProcRRDestroyMode (ClientPtr client);
d713 1
a713 1
ProcRRAddOutputMode (ClientPtr client);
d716 1
a716 1
ProcRRDeleteOutputMode (ClientPtr client);
d727 1
a727 1
RROutputChanged (RROutputPtr output, Bool configChanged);
d734 2
a735 4
RROutputCreate (ScreenPtr   pScreen,
		const char  *name,
		int	    nameLength,
		void	    *devPrivate);
d741 1
a741 3
RROutputSetClones (RROutputPtr  output,
		   RROutputPtr  *clones,
		   int		numClones);
d744 3
a746 4
RROutputSetModes (RROutputPtr	output,
		  RRModePtr	*modes,
		  int		numModes,
		  int		numPreferred);
d749 1
a749 2
RROutputAddUserMode (RROutputPtr    output,
		     RRModePtr	    mode);
d752 1
a752 2
RROutputDeleteUserMode (RROutputPtr output,
			RRModePtr   mode);
d755 1
a755 3
RROutputSetCrtcs (RROutputPtr	output,
		  RRCrtcPtr	*crtcs,
		  int		numCrtcs);
d758 1
a758 2
RROutputSetConnection (RROutputPtr  output,
		       CARD8	    connection);
d761 1
a761 2
RROutputSetSubpixelOrder (RROutputPtr output,
			  int	      subpixelOrder);
d764 1
a764 3
RROutputSetPhysicalSize (RROutputPtr	output,
			 int		mmWidth,
			 int		mmHeight);
d767 1
a767 1
RRDeliverOutputEvent(ClientPtr client, WindowPtr pWin, RROutputPtr output);
d770 1
a770 1
RROutputDestroy (RROutputPtr	output);
d773 1
a773 1
ProcRRGetOutputInfo (ClientPtr client);
d776 1
a776 1
ProcRRSetOutputPrimary (ClientPtr client);
d779 1
a779 1
ProcRRGetOutputPrimary (ClientPtr client);
d785 1
a785 1
RROutputInit (void);
d791 2
a792 2
RROutputInitErrorValue (void);
    
d795 1
a795 1
RRPointerMoved (ScreenPtr pScreen, int x, int y);
d798 1
a798 1
RRPointerScreenConfigured (ScreenPtr pScreen);
d803 1
a803 1
RRDeleteAllOutputProperties (RROutputPtr output);
d806 1
a806 1
RRGetOutputProperty (RROutputPtr output, Atom property, Bool pending);
d809 2
a810 2
RRQueryOutputProperty (RROutputPtr output, Atom property);
		       
d812 1
a812 1
RRDeleteOutputProperty (RROutputPtr output, Atom property);
d815 2
a816 2
RRPostPendingProperties (RROutputPtr output);
    
d818 4
a821 3
RRChangeOutputProperty (RROutputPtr output, Atom property, Atom type,
			int format, int mode, unsigned long len,
			pointer value, Bool sendevent, Bool pending);
d824 4
a827 3
RRConfigureOutputProperty (RROutputPtr output, Atom property,
			   Bool pending, Bool range, Bool immutable,
			   int num_values, INT32 *values);
d829 1
a829 1
ProcRRChangeOutputProperty (ClientPtr client);
d832 1
a832 1
ProcRRGetOutputProperty (ClientPtr client);
d835 1
a835 1
ProcRRListOutputProperties (ClientPtr client);
d838 1
a838 1
ProcRRQueryOutputProperty (ClientPtr client);
d841 1
a841 1
ProcRRConfigureOutputProperty (ClientPtr client);
d844 1
a844 1
ProcRRDeleteOutputProperty (ClientPtr client);
d849 1
a849 1
RRXineramaExtensionInit(void);
d852 1
a852 1
#endif /* _RANDRSTR_H_ */
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d300 1
a444 37
/* mirandr.c */
extern _X_EXPORT Bool
miRandRInit (ScreenPtr pScreen);

extern _X_EXPORT Bool
miRRGetInfo (ScreenPtr pScreen, Rotation *rotations);

extern _X_EXPORT Bool
miRRCrtcSet (ScreenPtr	pScreen,
	     RRCrtcPtr	crtc,
	     RRModePtr	mode,
	     int	x,
	     int	y,
	     Rotation	rotation,
	     int	numOutput,
	     RROutputPtr *outputs);

extern _X_EXPORT Bool
miRROutputSetProperty (ScreenPtr	    pScreen,
		       RROutputPtr	    output,
		       Atom		    property,
		       RRPropertyValuePtr   value);

extern _X_EXPORT Bool
miRROutputGetProperty (ScreenPtr	    pScreen,
		       RROutputPtr	    output,
		       Atom		    property);

extern _X_EXPORT Bool
miRROutputValidateMode (ScreenPtr	    pScreen,
			RROutputPtr	    output,
			RRModePtr	    mode);

extern _X_EXPORT void
miRRModeDestroy (ScreenPtr  pScreen,
		 RRModePtr  mode);

d703 3
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a49 1
#ifdef RENDER
a51 1
#endif
d302 2
a303 1
extern _X_EXPORT DevPrivateKey rrPrivKey;
d339 2
a340 1
extern _X_EXPORT DevPrivateKey RRClientPrivateKey;
d349 1
a349 1
	    return (rc == BadValue) ? RRErrorBase + BadRROutput : rc;\
d359 1
a359 1
	    return (rc == BadValue) ? RRErrorBase + BadRRCrtc : rc;\
d369 1
a369 1
	    return (rc == BadValue) ? RRErrorBase + BadRRMode : rc;\
d704 6
d771 6
d871 6
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d68 1
a68 1
extern int	RREventBase, RRErrorBase;
d70 2
a71 2
extern int (*ProcRandrVector[RRNumberRequests])(ClientPtr);
extern int (*SProcRandrVector[RRNumberRequests])(ClientPtr);
d176 3
d251 1
d304 1
a304 1
extern DevPrivateKey rrPrivKey;
d339 33
a371 13
extern RESTYPE	RRClientType, RREventType; /* resource types for event masks */
extern DevPrivateKey RRClientPrivateKey;
extern RESTYPE	RRCrtcType, RRModeType, RROutputType;

#define LookupOutput(client,id,a) ((RROutputPtr) \
				   (SecurityLookupIDByType (client, id, \
							    RROutputType, a)))
#define LookupCrtc(client,id,a) ((RRCrtcPtr) \
				 (SecurityLookupIDByType (client, id, \
							  RRCrtcType, a)))
#define LookupMode(client,id,a) ((RRModePtr) \
				 (SecurityLookupIDByType (client, id, \
							  RRModeType, a)))
d377 1
a377 1
void
d384 1
a384 1
void
d398 1
a398 1
void
d404 1
a404 1
Bool
d414 1
a414 1
void
d420 1
a420 1
int 
d423 1
a423 1
int
d426 1
a426 1
int
d429 1
a429 1
int
d432 1
a432 1
int
d435 1
a435 1
int
d441 1
a441 1
void
d445 1
a445 1
Bool
d448 1
a448 1
Bool
d451 1
a451 4
Bool
miRRGetScreenInfo (ScreenPtr pScreen);

Bool
d461 1
a461 1
Bool
d467 1
a467 1
Bool
d472 1
a472 1
Bool
d477 1
a477 1
void
d485 1
a485 1
void
d491 1
a491 1
Bool
d494 1
a494 1
Bool RRInit (void);
d496 1
a496 1
Bool RRScreenInit(ScreenPtr pScreen);
d498 1
a498 1
RROutputPtr
d501 1
a501 1
Rotation
d504 1
a504 1
CARD16
d517 1
a517 1
RRScreenSizePtr
d524 2
a525 1
Bool RRRegisterRate (ScreenPtr		pScreen,
d533 1
a533 1
void
d539 1
a539 1
Bool RRScreenInit (ScreenPtr pScreen);
d541 1
a541 1
Rotation
a543 6
int
RRSetScreenConfig (ScreenPtr		pScreen,
		   Rotation		rotation,
		   int			rate,
		   RRScreenSizePtr	pSize);

d552 1
a552 1
void
d558 1
a558 1
RRCrtcPtr
d564 1
a564 1
void
d570 1
a570 1
void
d577 1
a577 1
Bool
d587 1
a587 1
void
d593 1
a593 1
Bool
d606 1
a606 1
Bool
d613 8
d626 1
a626 1
Bool
d633 1
a633 1
Bool
d642 1
a642 1
void
d652 1
a652 1
Bool
d667 1
a667 1
RRTransformPtr
d673 1
a673 1
Bool
d679 1
a679 1
void
d687 1
a687 1
int
d700 1
a700 1
Bool
d707 1
a707 1
int
d710 1
a710 1
int
d713 1
a713 1
int
d716 1
a716 1
int
d719 1
a719 1
int
d722 1
a722 1
int
d725 1
a725 1
int
d735 1
a735 1
Bool
d743 1
a743 1
RRModePtr
a746 3
void
RRModePruneUnused (ScreenPtr pScreen);

d751 1
a751 1
void
d757 1
a757 1
RRModePtr *
d763 1
a763 1
Bool
d766 1
a766 1
int
d769 1
a769 1
int
d772 1
a772 1
int
d775 1
a775 1
int
d786 1
a786 1
void
d793 1
a793 1
RROutputPtr
d802 1
a802 1
Bool
d807 1
a807 1
Bool
d813 1
a813 1
int
d817 1
a817 1
int
d821 1
a821 1
Bool
d826 1
a826 1
Bool
d830 1
a830 1
Bool
d834 1
a834 1
Bool
d839 1
a839 1
void
d842 1
a842 1
void
d845 1
a845 1
int
d848 1
a848 1
extern int
d851 1
a851 1
extern int
d857 1
a857 1
Bool
d861 1
a861 1
void
d864 1
a864 1
void
d869 1
a869 1
void
d872 1
a872 1
RRPropertyValuePtr
d875 1
a875 1
RRPropertyPtr
d878 1
a878 1
void
d881 1
a881 1
Bool
d884 1
a884 1
int
d889 1
a889 1
int
d893 1
a893 1
int
d896 1
a896 1
int
d899 1
a899 1
int
d902 1
a902 1
int
d905 1
a905 1
int
d908 1
a908 1
int
d912 2
a913 1
void
d915 1
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d5 1
d47 1
d59 4
d124 6
d190 17
d252 5
d276 1
d406 3
d447 5
d471 1
a471 1
RRGetInfo (ScreenPtr pScreen);
d552 6
d567 1
d622 31
d658 15
d698 12
d826 6
@


1.1
log
@Initial revision
@
text
@a1 1
 *
d3 2
d8 7
a14 7
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Compaq not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Compaq makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
d16 1
a16 1
 * COMPAQ DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
d18 1
a18 1
 * EVENT SHALL COMPAQ BE LIABLE FOR ANY SPECIAL, INDIRECT OR
d21 5
a25 2
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d35 11
d47 130
d178 8
a185 4
typedef struct _rrScreenRate {
    int		    rate;
    Bool	    referenced;
    Bool	    oldReferenced;
d192 1
a193 4
    int		    nRates;
    int		    nRatesInUse;
    Bool	    referenced;
    Bool	    oldReferenced;
d196 2
d203 1
a203 2
typedef Bool (*RRGetInfoProcPtr) (ScreenPtr pScreen, Rotation *rotations);
typedef Bool (*RRCloseScreenProcPtr) ( int i, ScreenPtr pscreen);
d205 1
d207 5
d213 1
d215 8
d224 3
d231 19
d254 1
a256 1
    int			    nSizesInUse;
d258 1
a258 4

    /*
     * Current state
     */
d260 1
d262 1
a262 1
    int			    rate;
d265 1
a265 1
extern int rrPrivIndex;
d267 1
a267 1
#define rrGetScrPriv(pScr)  ((rrScrPrivPtr) (pScr)->devPrivates[rrPrivIndex].ptr)
d269 47
a315 1
#define SetRRScreen(s,p) ((s)->devPrivates[rrPrivIndex].ptr = (pointer) (p))
d321 128
d474 1
a474 1
Bool RRScreenInit(ScreenPtr pScreen);
d485 67
d553 151
a703 1
miRandRInit (ScreenPtr pScreen);
d706 12
a717 1
miRRGetInfo (ScreenPtr pScreen, Rotation *rotations);
d719 3
d723 22
a744 4
miRRSetConfig (ScreenPtr	pScreen,
	       Rotation		rotation,
	       int		rate,
	       RRScreenSizePtr	size);
d747 32
a778 1
miRRGetScreenInfo (ScreenPtr pScreen);
d781 72
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 1
a3 2
 * Copyright © 2002 Hewlett-Packard Company
 * Copyright © 2006 Intel Corporation
d7 7
a13 7
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
d15 1
a15 1
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
d17 1
a17 1
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
d20 2
a21 5
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 *
 * Author:  Jim Gettys, Hewlett-Packard Company, Inc.
 *	    Keith Packard, Intel Corporation
a30 11
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "resource.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "extnsionst.h"
#include "servermd.h"
a31 130
#include <X11/extensions/randrproto.h>
#ifdef RENDER
#include <X11/extensions/render.h> 	/* we share subpixel order information */
#include "picturestr.h"
#endif
#include <X11/Xfuncproto.h>

/* required for ABI compatibility for now */
#define RANDR_10_INTERFACE 1
#define RANDR_12_INTERFACE 1

typedef XID	RRMode;
typedef XID	RROutput;
typedef XID	RRCrtc;

extern int	RREventBase, RRErrorBase;

extern int (*ProcRandrVector[RRNumberRequests])(ClientPtr);
extern int (*SProcRandrVector[RRNumberRequests])(ClientPtr);
    
/*
 * Modeline for a monitor. Name follows directly after this struct
 */

#define RRModeName(pMode) ((char *) (pMode + 1))
typedef struct _rrMode		RRModeRec, *RRModePtr;
typedef struct _rrPropertyValue	RRPropertyValueRec, *RRPropertyValuePtr;
typedef struct _rrProperty	RRPropertyRec, *RRPropertyPtr;
typedef struct _rrCrtc		RRCrtcRec, *RRCrtcPtr;
typedef struct _rrOutput	RROutputRec, *RROutputPtr;

struct _rrMode {
    int		    refcnt;
    xRRModeInfo	    mode;
    char	    *name;
    ScreenPtr	    userScreen;
};

struct _rrPropertyValue {
    Atom	    type;       /* ignored by server */
    short	    format;     /* format of data for swapping - 8,16,32 */
    long	    size;	/* size of data in (format/8) bytes */
    pointer         data;	/* private to client */
};

struct _rrProperty {
    RRPropertyPtr   next;
    ATOM 	    propertyName;
    Bool	    is_pending;
    Bool	    range;
    Bool	    immutable;
    int		    num_valid;
    INT32	    *valid_values;
    RRPropertyValueRec	current, pending;
};

struct _rrCrtc {
    RRCrtc	    id;
    ScreenPtr	    pScreen;
    RRModePtr	    mode;
    int		    x, y;
    Rotation	    rotation;
    Rotation	    rotations;
    Bool	    changed;
    int		    numOutputs;
    RROutputPtr	    *outputs;
    int		    gammaSize;
    CARD16	    *gammaRed;
    CARD16	    *gammaBlue;
    CARD16	    *gammaGreen;
    void	    *devPrivate;
};

struct _rrOutput {
    RROutput	    id;
    ScreenPtr	    pScreen;
    char	    *name;
    int		    nameLength;
    CARD8	    connection;
    CARD8	    subpixelOrder;
    int		    mmWidth;
    int		    mmHeight;
    RRCrtcPtr	    crtc;
    int		    numCrtcs;
    RRCrtcPtr	    *crtcs;
    int		    numClones;
    RROutputPtr	    *clones;
    int		    numModes;
    int		    numPreferred;
    RRModePtr	    *modes;
    int		    numUserModes;
    RRModePtr	    *userModes;
    Bool	    changed;
    RRPropertyPtr   properties;
    Bool	    pendingProperties;
    void	    *devPrivate;
};

#if RANDR_12_INTERFACE
typedef Bool (*RRScreenSetSizeProcPtr) (ScreenPtr	pScreen,
					CARD16		width,
					CARD16		height,
					CARD32		mmWidth,
					CARD32		mmHeight);
					
typedef Bool (*RRCrtcSetProcPtr) (ScreenPtr		pScreen,
				  RRCrtcPtr		crtc,
				  RRModePtr		mode,
				  int			x,
				  int			y,
				  Rotation		rotation,
				  int			numOutputs,
				  RROutputPtr		*outputs);

typedef Bool (*RRCrtcSetGammaProcPtr) (ScreenPtr	pScreen,
				       RRCrtcPtr	crtc);

typedef Bool (*RROutputSetPropertyProcPtr) (ScreenPtr		pScreen,
					    RROutputPtr		output,
					    Atom		property,
					    RRPropertyValuePtr	value);

typedef Bool (*RROutputValidateModeProcPtr) (ScreenPtr		pScreen,
					     RROutputPtr	output,
					     RRModePtr		mode);

typedef void (*RRModeDestroyProcPtr) (ScreenPtr	    pScreen,
				      RRModePtr	    mode);

#endif
d33 4
a36 8
typedef Bool (*RRGetInfoProcPtr) (ScreenPtr pScreen, Rotation *rotations);
typedef Bool (*RRCloseScreenProcPtr) ( int i, ScreenPtr pscreen);

/* These are for 1.0 compatibility */
 
typedef struct _rrRefresh {
    CARD16	    rate;
    RRModePtr	    mode;
d43 1
d45 3
a47 1
    RRScreenRatePtr pRates;
a49 2
#ifdef RANDR_10_INTERFACE

d55 2
a56 1
#endif
a57 1

a58 5
    /*
     * 'public' part of the structure; DDXen fill this in
     * as they initialize
     */
#if RANDR_10_INTERFACE
a59 1
#endif
a60 8
#if RANDR_12_INTERFACE
    RRScreenSetSizeProcPtr  rrScreenSetSize;
    RRCrtcSetProcPtr	    rrCrtcSet;
    RRCrtcSetGammaProcPtr   rrCrtcSetGamma;
    RROutputSetPropertyProcPtr	rrOutputSetProperty;
    RROutputValidateModeProcPtr	rrOutputValidateMode;
    RRModeDestroyProcPtr	rrModeDestroy;
#endif
a61 3
    /*
     * Private part of the structure; not considered part of the ABI
     */
a65 19
    Bool		    changed;		/* some config changed */
    Bool		    configChanged;	/* configuration changed */
    Bool		    layoutChanged;	/* screen layout changed */

    CARD16		    minWidth, minHeight;
    CARD16		    maxWidth, maxHeight;
    CARD16		    width, height;	/* last known screen size */
    CARD16		    mmWidth, mmHeight;	/* last known screen size */

    int			    numOutputs;
    RROutputPtr		    *outputs;

    int			    numCrtcs;
    RRCrtcPtr		    *crtcs;

    /* Last known pointer position */
    RRCrtcPtr		    pointerCrtc;

#ifdef RANDR_10_INTERFACE
a69 1
    CARD16		    reqWidth, reqHeight;
d72 1
d74 4
a77 1
    
d79 1
a80 2
    int			    size;
#endif
a88 46
/*
 * each window has a list of clients requesting
 * RRNotify events.  Each client has a resource
 * for each window it selects RRNotify input for,
 * this resource is used to delete the RRNotifyRec
 * entry from the per-window queue.
 */

typedef struct _RREvent *RREventPtr;

typedef struct _RREvent {
    RREventPtr  next;
    ClientPtr	client;
    WindowPtr	window;
    XID		clientResource;
    int		mask;
} RREventRec;

typedef struct _RRTimes {
    TimeStamp	setTime;
    TimeStamp	configTime;
} RRTimesRec, *RRTimesPtr;

typedef struct _RRClient {
    int		major_version;
    int		minor_version;
/*  RRTimesRec	times[0]; */
} RRClientRec, *RRClientPtr;

extern RESTYPE	RRClientType, RREventType; /* resource types for event masks */
extern int	RRClientPrivateIndex;
extern RESTYPE	RRCrtcType, RRModeType, RROutputType;

#define LookupOutput(client,id,a) ((RROutputPtr) \
				   (SecurityLookupIDByType (client, id, \
							    RROutputType, a)))
#define LookupCrtc(client,id,a) ((RRCrtcPtr) \
				 (SecurityLookupIDByType (client, id, \
							  RRCrtcType, a)))
#define LookupMode(client,id,a) ((RRModePtr) \
				 (SecurityLookupIDByType (client, id, \
							  RRModeType, a)))

#define GetRRClient(pClient)    ((RRClientPtr) (pClient)->devPrivates[RRClientPrivateIndex].ptr)
#define rrClientPriv(pClient)	RRClientPtr pRRClient = GetRRClient(pClient)

a92 128
#ifdef RANDR_12_INTERFACE
/*
 * Set the range of sizes for the screen
 */
void
RRScreenSetSizeRange (ScreenPtr	pScreen,
		      CARD16	minWidth,
		      CARD16	minHeight,
		      CARD16	maxWidth,
		      CARD16	maxHeight);
#endif

/* rrscreen.c */
/*
 * Notify the extension that the screen size has been changed.
 * The driver is responsible for calling this whenever it has changed
 * the size of the screen
 */
void
RRScreenSizeNotify (ScreenPtr	pScreen);

/*
 * Request that the screen be resized
 */
Bool
RRScreenSizeSet (ScreenPtr  pScreen,
		 CARD16	    width,
		 CARD16	    height,
		 CARD32	    mmWidth,
		 CARD32	    mmHeight);

/*
 * Send ConfigureNotify event to root window when 'something' happens
 */
void
RRSendConfigNotify (ScreenPtr pScreen);
    
/*
 * screen dispatch
 */
int 
ProcRRGetScreenSizeRange (ClientPtr client);

int
ProcRRSetScreenSize (ClientPtr client);

int
ProcRRGetScreenResources (ClientPtr client);

int
ProcRRSetScreenConfig (ClientPtr client);

int
ProcRRGetScreenInfo (ClientPtr client);

/*
 * Deliver a ScreenNotify event
 */
void
RRDeliverScreenEvent (ClientPtr client, WindowPtr pWin, ScreenPtr pScreen);
    
/* mirandr.c */
Bool
miRandRInit (ScreenPtr pScreen);

Bool
miRRGetInfo (ScreenPtr pScreen, Rotation *rotations);

Bool
miRRGetScreenInfo (ScreenPtr pScreen);

Bool
miRRCrtcSet (ScreenPtr	pScreen,
	     RRCrtcPtr	crtc,
	     RRModePtr	mode,
	     int	x,
	     int	y,
	     Rotation	rotation,
	     int	numOutput,
	     RROutputPtr *outputs);

Bool
miRROutputSetProperty (ScreenPtr	    pScreen,
		       RROutputPtr	    output,
		       Atom		    property,
		       RRPropertyValuePtr   value);

Bool
miRROutputValidateMode (ScreenPtr	    pScreen,
			RROutputPtr	    output,
			RRModePtr	    mode);

void
miRRModeDestroy (ScreenPtr  pScreen,
		 RRModePtr  mode);

/* randr.c */
/*
 * Send all pending events
 */
void
RRTellChanged (ScreenPtr pScreen);

/*
 * Poll the driver for changed information
 */
Bool
RRGetInfo (ScreenPtr pScreen);

Bool RRInit (void);

Bool RRScreenInit(ScreenPtr pScreen);

RROutputPtr
RRFirstOutput (ScreenPtr pScreen);

Rotation
RRGetRotation (ScreenPtr pScreen);

CARD16
RRVerticalRefresh (xRRModeInfo *mode);

#ifdef RANDR_10_INTERFACE					
/*
 * This is the old interface, deprecated but left
 * around for compatibility
 */

d118 1
a118 1
Bool RRScreenInit (ScreenPtr pScreen);
a128 27
#endif					

/* rrcrtc.c */

/*
 * Notify the CRTC of some change; layoutChanged indicates that
 * some position or size element changed
 */
void
RRCrtcChanged (RRCrtcPtr crtc, Bool layoutChanged);

/*
 * Create a CRTC
 */
RRCrtcPtr
RRCrtcCreate (ScreenPtr pScreen, void	*devPrivate);

/*
 * Set the allowed rotations on a CRTC
 */
void
RRCrtcSetRotations (RRCrtcPtr crtc, Rotation rotations);

/*
 * Notify the extension that the Crtc has been reconfigured,
 * the driver calls this whenever it has updated the mode
 */
d130 1
a130 26
RRCrtcNotify (RRCrtcPtr	    crtc,
	      RRModePtr	    mode,
	      int	    x,
	      int	    y,
	      Rotation	    rotation,
	      int	    numOutputs,
	      RROutputPtr   *outputs);

void
RRDeliverCrtcEvent (ClientPtr client, WindowPtr pWin, RRCrtcPtr crtc);
    
/*
 * Request that the Crtc be reconfigured
 */
Bool
RRCrtcSet (RRCrtcPtr    crtc,
	   RRModePtr	mode,
	   int		x,
	   int		y,
	   Rotation	rotation,
	   int		numOutput,
	   RROutputPtr  *outputs);

/*
 * Request that the Crtc gamma be changed
 */
d133 1
a133 10
RRCrtcGammaSet (RRCrtcPtr   crtc,
		CARD16	    *red,
		CARD16	    *green,
		CARD16	    *blue);

/*
 * Notify the extension that the Crtc gamma has been changed
 * The driver calls this whenever it has changed the gamma values
 * in the RRCrtcRec
 */
d136 4
a139 5
RRCrtcGammaNotify (RRCrtcPtr	crtc);

/*
 * Set the size of the gamma table at server startup time
 */
d142 1
a142 219
RRCrtcGammaSetSize (RRCrtcPtr	crtc,
		    int		size);

/*
 * Return the area of the frame buffer scanned out by the crtc,
 * taking into account the current mode and rotation
 */

void
RRCrtcGetScanoutSize(RRCrtcPtr crtc, int *width, int *height);

/*
 * Destroy a Crtc at shutdown
 */
void
RRCrtcDestroy (RRCrtcPtr crtc);

/*
 * Initialize crtc type
 */
Bool
RRCrtcInit (void);

/*
 * Crtc dispatch
 */

int
ProcRRGetCrtcInfo (ClientPtr client);

int
ProcRRSetCrtcConfig (ClientPtr client);

int
ProcRRGetCrtcGammaSize (ClientPtr client);

int
ProcRRGetCrtcGamma (ClientPtr client);

int
ProcRRSetCrtcGamma (ClientPtr client);

/* rrdispatch.c */
Bool
RRClientKnowsRates (ClientPtr	pClient);

/* rrmode.c */
/*
 * Find, and if necessary, create a mode
 */

RRModePtr
RRModeGet (xRRModeInfo	*modeInfo,
	   const char	*name);

void
RRModePruneUnused (ScreenPtr pScreen);

/*
 * Destroy a mode.
 */

void
RRModeDestroy (RRModePtr mode);

/*
 * Return a list of modes that are valid for some output in pScreen
 */
RRModePtr *
RRModesForScreen (ScreenPtr pScreen, int *num_ret);
    
/*
 * Initialize mode type
 */
Bool
RRModeInit (void);
    
int
ProcRRCreateMode (ClientPtr client);

int
ProcRRDestroyMode (ClientPtr client);

int
ProcRRAddOutputMode (ClientPtr client);

int
ProcRRDeleteOutputMode (ClientPtr client);

/* rroutput.c */

/*
 * Notify the output of some change. configChanged indicates whether
 * any external configuration (mode list, clones, connected status)
 * has changed, or whether the change was strictly internal
 * (which crtc is in use)
 */
void
RROutputChanged (RROutputPtr output, Bool configChanged);

/*
 * Create an output
 */

RROutputPtr
RROutputCreate (ScreenPtr   pScreen,
		const char  *name,
		int	    nameLength,
		void	    *devPrivate);

/*
 * Notify extension that output parameters have been changed
 */
Bool
RROutputSetClones (RROutputPtr  output,
		   RROutputPtr  *clones,
		   int		numClones);

Bool
RROutputSetModes (RROutputPtr	output,
		  RRModePtr	*modes,
		  int		numModes,
		  int		numPreferred);

int
RROutputAddUserMode (RROutputPtr    output,
		     RRModePtr	    mode);

int
RROutputDeleteUserMode (RROutputPtr output,
			RRModePtr   mode);

Bool
RROutputSetCrtcs (RROutputPtr	output,
		  RRCrtcPtr	*crtcs,
		  int		numCrtcs);

Bool
RROutputSetConnection (RROutputPtr  output,
		       CARD8	    connection);

Bool
RROutputSetSubpixelOrder (RROutputPtr output,
			  int	      subpixelOrder);

Bool
RROutputSetPhysicalSize (RROutputPtr	output,
			 int		mmWidth,
			 int		mmHeight);

void
RRDeliverOutputEvent(ClientPtr client, WindowPtr pWin, RROutputPtr output);

void
RROutputDestroy (RROutputPtr	output);

int
ProcRRGetOutputInfo (ClientPtr client);

/*
 * Initialize output type
 */
Bool
RROutputInit (void);
    
/* rrpointer.c */
void
RRPointerMoved (ScreenPtr pScreen, int x, int y);

void
RRPointerScreenConfigured (ScreenPtr pScreen);

/* rrproperty.c */

void
RRDeleteAllOutputProperties (RROutputPtr output);

RRPropertyValuePtr
RRGetOutputProperty (RROutputPtr output, Atom property, Bool pending);

RRPropertyPtr
RRQueryOutputProperty (RROutputPtr output, Atom property);
		       
void
RRDeleteOutputProperty (RROutputPtr output, Atom property);

Bool
RRPostPendingProperties (RROutputPtr output);
    
int
RRChangeOutputProperty (RROutputPtr output, Atom property, Atom type,
			int format, int mode, unsigned long len,
			pointer value, Bool sendevent, Bool pending);

int
RRConfigureOutputProperty (RROutputPtr output, Atom property,
			   Bool pending, Bool range, Bool immutable,
			   int num_values, INT32 *values);
int
ProcRRChangeOutputProperty (ClientPtr client);

int
ProcRRGetOutputProperty (ClientPtr client);

int
ProcRRListOutputProperties (ClientPtr client);

int
ProcRRQueryOutputProperty (ClientPtr client);

int
ProcRRConfigureOutputProperty (ClientPtr client);

int
ProcRRDeleteOutputProperty (ClientPtr client);

/* rrxinerama.c */
void
RRXineramaExtensionInit(void);
a144 72

/*
 
randr extension implementation structure

Query state:
    ProcRRGetScreenInfo/ProcRRGetScreenResources
	RRGetInfo
 
	    • Request configuration from driver, either 1.0 or 1.2 style
	    • These functions only record state changes, all
	      other actions are pended until RRTellChanged is called
 
	    ->rrGetInfo
	    1.0:
		RRRegisterSize
		RRRegisterRate
		RRSetCurrentConfig
	    1.2:
		RRScreenSetSizeRange
		RROutputSetCrtcs
		RRModeGet
		RROutputSetModes
		RROutputSetConnection
		RROutputSetSubpixelOrder
		RROutputSetClones
		RRCrtcNotify
 
	• Must delay scanning configuration until after ->rrGetInfo returns
	  because some drivers will call SetCurrentConfig in the middle
	  of the ->rrGetInfo operation.
 
	1.0:

	    • Scan old configuration, mirror to new structures
 
	    RRScanOldConfig
		RRCrtcCreate
		RROutputCreate
		RROutputSetCrtcs
		RROutputSetConnection
		RROutputSetSubpixelOrder
		RROldModeAdd	• This adds modes one-at-a-time
		    RRModeGet
		RRCrtcNotify
 
	• send events, reset pointer if necessary
 
	RRTellChanged
	    WalkTree (sending events)
 
	    • when layout has changed:
		RRPointerScreenConfigured
		RRSendConfigNotify
 
Asynchronous state setting (1.2 only)
    When setting state asynchronously, the driver invokes the
    ->rrGetInfo function and then calls RRTellChanged to flush
    the changes to the clients and reset pointer if necessary

Set state

    ProcRRSetScreenConfig
	RRCrtcSet
	    1.2:
		->rrCrtcSet
		    RRCrtcNotify
	    1.0:
		->rrSetConfig
		RRCrtcNotify
	    RRTellChanged
 */
@

