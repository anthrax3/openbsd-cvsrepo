head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.4.0.2
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.1.0.4
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.2
	OPENBSD_5_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2016.08.09.18.59.51;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	6HLO5qdN5N4nPDjW;

1.4
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.3;
commitid	s0SI41sEunLdyFfd;

1.3
date	2015.12.01.21.17.49;	author kettenis;	state Exp;
branches;
next	1.2;
commitid	8CqzlltQWcq0mkiY;

1.2
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.1;
commitid	Te1daavkBLskZ8gc;

1.1
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	;
commitid	cVXoV5PxI8YrEaVA;


desc
@@


1.5
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/*
 * Copyright © 2009 Intel Corporation
 * Copyright © 1998 Keith Packard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Zhigang Gong <zhigang.gong@@gmail.com>
 *
 */

#include <stdlib.h>

#include "glamor_priv.h"

#define GLAMOR_CACHE_EXPIRE_MAX 100

#define GLAMOR_CACHE_DEFAULT    0
#define GLAMOR_CACHE_EXACT_SIZE 1

//#define NO_FBO_CACHE 1
#define FBO_CACHE_THRESHOLD  (256*1024*1024)

/* Loop from the tail to the head. */
#define xorg_list_for_each_entry_reverse(pos, head, member)             \
    for (pos = __container_of((head)->prev, pos, member);               \
         &pos->member != (head);                                        \
         pos = __container_of(pos->member.prev, pos, member))

#define xorg_list_for_each_entry_safe_reverse(pos, tmp, head, member)   \
    for (pos = __container_of((head)->prev, pos, member),               \
         tmp = __container_of(pos->member.prev, pos, member);           \
         &pos->member != (head);                                        \
         pos = tmp, tmp = __container_of(pos->member.prev, tmp, member))

inline static int
cache_wbucket(int size)
{
    int order = __fls(size / 32);

    if (order >= CACHE_BUCKET_WCOUNT)
        order = CACHE_BUCKET_WCOUNT - 1;
    return order;
}

inline static int
cache_hbucket(int size)
{
    int order = __fls(size / 32);

    if (order >= CACHE_BUCKET_HCOUNT)
        order = CACHE_BUCKET_HCOUNT - 1;
    return order;
}

static int
cache_format(GLenum format)
{
    switch (format) {
    case GL_ALPHA:
    case GL_LUMINANCE:
    case GL_RED:
        return 2;
    case GL_RGB:
        return 1;
    case GL_RGBA:
        return 0;
    default:
        return -1;
    }
}

static glamor_pixmap_fbo *
glamor_pixmap_fbo_cache_get(glamor_screen_private *glamor_priv,
                            int w, int h, GLenum format)
{
    struct xorg_list *cache;
    glamor_pixmap_fbo *fbo_entry, *ret_fbo = NULL;
    int n_format;

#ifdef NO_FBO_CACHE
    return NULL;
#else
    n_format = cache_format(format);
    if (n_format == -1)
        return NULL;
    cache = &glamor_priv->fbo_cache[n_format]
        [cache_wbucket(w)]
        [cache_hbucket(h)];

    xorg_list_for_each_entry(fbo_entry, cache, list) {
        if (fbo_entry->width == w && fbo_entry->height == h) {

            DEBUGF("Request w %d h %d format %x \n", w, h, format);
            DEBUGF("got cache entry %p w %d h %d fbo %d tex %d format %x\n",
                   fbo_entry, fbo_entry->width, fbo_entry->height,
                   fbo_entry->fb, fbo_entry->tex, fbo_entry->format);
            assert(format == fbo_entry->format);
            xorg_list_del(&fbo_entry->list);
            ret_fbo = fbo_entry;
            break;
        }
    }

    if (ret_fbo)
        glamor_priv->fbo_cache_watermark -= ret_fbo->width * ret_fbo->height;

    assert(glamor_priv->fbo_cache_watermark >= 0);

    return ret_fbo;
#endif
}

static void
glamor_purge_fbo(glamor_screen_private *glamor_priv,
                 glamor_pixmap_fbo *fbo)
{
    glamor_make_current(glamor_priv);

    if (fbo->fb)
        glDeleteFramebuffers(1, &fbo->fb);
    if (fbo->tex)
        glDeleteTextures(1, &fbo->tex);

    free(fbo);
}

static void
glamor_pixmap_fbo_cache_put(glamor_screen_private *glamor_priv,
                            glamor_pixmap_fbo *fbo)
{
    struct xorg_list *cache;
    int n_format;

#ifdef NO_FBO_CACHE
    glamor_purge_fbo(fbo);
    return;
#else
    n_format = cache_format(fbo->format);

    if (fbo->fb == 0 || fbo->external || n_format == -1
        || glamor_priv->fbo_cache_watermark >= FBO_CACHE_THRESHOLD) {
        glamor_priv->tick += GLAMOR_CACHE_EXPIRE_MAX;
        glamor_fbo_expire(glamor_priv);
        glamor_purge_fbo(glamor_priv, fbo);
        return;
    }

    cache = &glamor_priv->fbo_cache[n_format]
        [cache_wbucket(fbo->width)]
        [cache_hbucket(fbo->height)];
    DEBUGF
        ("Put cache entry %p to cache %p w %d h %d format %x fbo %d tex %d \n",
         fbo, cache, fbo->width, fbo->height, fbo->format, fbo->fb, fbo->tex);

    glamor_priv->fbo_cache_watermark += fbo->width * fbo->height;
    xorg_list_add(&fbo->list, cache);
    fbo->expire = glamor_priv->tick + GLAMOR_CACHE_EXPIRE_MAX;
#endif
}

static int
glamor_pixmap_ensure_fb(glamor_screen_private *glamor_priv,
                        glamor_pixmap_fbo *fbo)
{
    int status, err = 0;

    glamor_make_current(glamor_priv);

    if (fbo->fb == 0)
        glGenFramebuffers(1, &fbo->fb);
    assert(fbo->tex != 0);
    glBindFramebuffer(GL_FRAMEBUFFER, fbo->fb);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                           GL_TEXTURE_2D, fbo->tex, 0);
    status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if (status != GL_FRAMEBUFFER_COMPLETE) {
        const char *str;

        switch (status) {
        case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            str = "incomplete attachment";
            break;
        case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            str = "incomplete/missing attachment";
            break;
        case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:
            str = "incomplete draw buffer";
            break;
        case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER:
            str = "incomplete read buffer";
            break;
        case GL_FRAMEBUFFER_UNSUPPORTED:
            str = "unsupported";
            break;
        case GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:
            str = "incomplete multiple";
            break;
        default:
            str = "unknown error";
            break;
        }

        glamor_fallback("glamor: Failed to create fbo, %s\n", str);
        err = -1;
    }

    return err;
}

glamor_pixmap_fbo *
glamor_create_fbo_from_tex(glamor_screen_private *glamor_priv,
                           int w, int h, GLenum format, GLint tex, int flag)
{
    glamor_pixmap_fbo *fbo;

    fbo = calloc(1, sizeof(*fbo));
    if (fbo == NULL)
        return NULL;

    xorg_list_init(&fbo->list);

    fbo->tex = tex;
    fbo->width = w;
    fbo->height = h;
    fbo->external = FALSE;
    fbo->format = format;

    if (flag == CREATE_PIXMAP_USAGE_SHARED)
        fbo->external = TRUE;

    if (flag != GLAMOR_CREATE_FBO_NO_FBO) {
        if (glamor_pixmap_ensure_fb(glamor_priv, fbo) != 0) {
            glamor_purge_fbo(glamor_priv, fbo);
            fbo = NULL;
        }
    }

    return fbo;
}

void
glamor_fbo_expire(glamor_screen_private *glamor_priv)
{
    struct xorg_list *cache;
    glamor_pixmap_fbo *fbo_entry, *tmp;
    int i, j, k;

    for (i = 0; i < CACHE_FORMAT_COUNT; i++)
        for (j = 0; j < CACHE_BUCKET_WCOUNT; j++)
            for (k = 0; k < CACHE_BUCKET_HCOUNT; k++) {
                cache = &glamor_priv->fbo_cache[i][j][k];
                xorg_list_for_each_entry_safe_reverse(fbo_entry, tmp, cache,
                                                      list) {
                    if (GLAMOR_TICK_AFTER(fbo_entry->expire, glamor_priv->tick)) {
                        break;
                    }

                    glamor_priv->fbo_cache_watermark -=
                        fbo_entry->width * fbo_entry->height;
                    xorg_list_del(&fbo_entry->list);
                    DEBUGF("cache %p fbo %p expired %d current %d \n", cache,
                           fbo_entry, fbo_entry->expire, glamor_priv->tick);
                    glamor_purge_fbo(glamor_priv, fbo_entry);
                }
            }

}

void
glamor_init_pixmap_fbo(ScreenPtr screen)
{
    glamor_screen_private *glamor_priv;
    int i, j, k;

    glamor_priv = glamor_get_screen_private(screen);
    for (i = 0; i < CACHE_FORMAT_COUNT; i++)
        for (j = 0; j < CACHE_BUCKET_WCOUNT; j++)
            for (k = 0; k < CACHE_BUCKET_HCOUNT; k++) {
                xorg_list_init(&glamor_priv->fbo_cache[i][j][k]);
            }
    glamor_priv->fbo_cache_watermark = 0;
}

void
glamor_fini_pixmap_fbo(ScreenPtr screen)
{
    struct xorg_list *cache;
    glamor_screen_private *glamor_priv;
    glamor_pixmap_fbo *fbo_entry, *tmp;
    int i, j, k;

    glamor_priv = glamor_get_screen_private(screen);
    for (i = 0; i < CACHE_FORMAT_COUNT; i++)
        for (j = 0; j < CACHE_BUCKET_WCOUNT; j++)
            for (k = 0; k < CACHE_BUCKET_HCOUNT; k++) {
                cache = &glamor_priv->fbo_cache[i][j][k];
                xorg_list_for_each_entry_safe_reverse(fbo_entry, tmp, cache,
                                                      list) {
                    xorg_list_del(&fbo_entry->list);
                    glamor_purge_fbo(glamor_priv, fbo_entry);
                }
            }
}

void
glamor_destroy_fbo(glamor_screen_private *glamor_priv,
                   glamor_pixmap_fbo *fbo)
{
    xorg_list_del(&fbo->list);
    glamor_pixmap_fbo_cache_put(glamor_priv, fbo);

}

static int
_glamor_create_tex(glamor_screen_private *glamor_priv,
                   int w, int h, GLenum format)
{
    unsigned int tex;

    glamor_make_current(glamor_priv);
    glGenTextures(1, &tex);
    glBindTexture(GL_TEXTURE_2D, tex);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    if (format == glamor_priv->one_channel_format && format == GL_RED)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_A, GL_RED);
    glamor_priv->suppress_gl_out_of_memory_logging = true;
    glTexImage2D(GL_TEXTURE_2D, 0, format, w, h, 0,
                 format, GL_UNSIGNED_BYTE, NULL);
    glamor_priv->suppress_gl_out_of_memory_logging = false;

    if (glGetError() == GL_OUT_OF_MEMORY) {
        if (!glamor_priv->logged_any_fbo_allocation_failure) {
            LogMessageVerb(X_WARNING, 0, "glamor: Failed to allocate %dx%d "
                           "FBO due to GL_OUT_OF_MEMORY.\n", w, h);
            LogMessageVerb(X_WARNING, 0,
                           "glamor: Expect reduced performance.\n");
            glamor_priv->logged_any_fbo_allocation_failure = true;
        }
        glDeleteTextures(1, &tex);
        return 0;
    }

    return tex;
}

glamor_pixmap_fbo *
glamor_create_fbo(glamor_screen_private *glamor_priv,
                  int w, int h, GLenum format, int flag)
{
    glamor_pixmap_fbo *fbo;
    GLint tex = 0;

    if (flag == GLAMOR_CREATE_FBO_NO_FBO || flag == CREATE_PIXMAP_USAGE_SHARED)
        goto new_fbo;

    fbo = glamor_pixmap_fbo_cache_get(glamor_priv, w, h, format);
    if (fbo)
        return fbo;
 new_fbo:
    tex = _glamor_create_tex(glamor_priv, w, h, format);
    if (!tex)
        return NULL;
    fbo = glamor_create_fbo_from_tex(glamor_priv, w, h, format, tex, flag);

    return fbo;
}

/**
 * Create storage for the w * h region, using FBOs of the GL's maximum
 * supported size.
 */
glamor_pixmap_fbo *
glamor_create_fbo_array(glamor_screen_private *glamor_priv,
                         int w, int h, GLenum format, int flag,
                         int block_w, int block_h,
                         glamor_pixmap_private *priv)
{
    int block_wcnt;
    int block_hcnt;
    glamor_pixmap_fbo **fbo_array;
    BoxPtr box_array;
    int i, j;

    priv->block_w = block_w;
    priv->block_h = block_h;

    block_wcnt = (w + block_w - 1) / block_w;
    block_hcnt = (h + block_h - 1) / block_h;

    box_array = calloc(block_wcnt * block_hcnt, sizeof(box_array[0]));
    if (box_array == NULL)
        return NULL;

    fbo_array = calloc(block_wcnt * block_hcnt, sizeof(glamor_pixmap_fbo *));
    if (fbo_array == NULL) {
        free(box_array);
        return FALSE;
    }
    for (i = 0; i < block_hcnt; i++) {
        int block_y1, block_y2;
        int fbo_w, fbo_h;

        block_y1 = i * block_h;
        block_y2 = (block_y1 + block_h) > h ? h : (block_y1 + block_h);
        fbo_h = block_y2 - block_y1;

        for (j = 0; j < block_wcnt; j++) {
            box_array[i * block_wcnt + j].x1 = j * block_w;
            box_array[i * block_wcnt + j].y1 = block_y1;
            box_array[i * block_wcnt + j].x2 =
                (j + 1) * block_w > w ? w : (j + 1) * block_w;
            box_array[i * block_wcnt + j].y2 = block_y2;
            fbo_w =
                box_array[i * block_wcnt + j].x2 - box_array[i * block_wcnt +
                                                             j].x1;
            fbo_array[i * block_wcnt + j] = glamor_create_fbo(glamor_priv,
                                                              fbo_w, fbo_h,
                                                              format,
                                                              GLAMOR_CREATE_PIXMAP_FIXUP);
            if (fbo_array[i * block_wcnt + j] == NULL)
                goto cleanup;
        }
    }

    priv->box = box_array[0];
    priv->box_array = box_array;
    priv->fbo_array = fbo_array;
    priv->block_wcnt = block_wcnt;
    priv->block_hcnt = block_hcnt;
    return fbo_array[0];

 cleanup:
    for (i = 0; i < block_wcnt * block_hcnt; i++)
        if (fbo_array[i])
            glamor_destroy_fbo(glamor_priv, fbo_array[i]);
    free(box_array);
    free(fbo_array);
    return NULL;
}

glamor_pixmap_fbo *
glamor_pixmap_detach_fbo(glamor_pixmap_private *pixmap_priv)
{
    glamor_pixmap_fbo *fbo;

    if (pixmap_priv == NULL)
        return NULL;

    fbo = pixmap_priv->fbo;
    if (fbo == NULL)
        return NULL;

    pixmap_priv->fbo = NULL;
    return fbo;
}

/* The pixmap must not be attached to another fbo. */
void
glamor_pixmap_attach_fbo(PixmapPtr pixmap, glamor_pixmap_fbo *fbo)
{
    glamor_pixmap_private *pixmap_priv;

    pixmap_priv = glamor_get_pixmap_private(pixmap);

    if (pixmap_priv->fbo)
        return;

    pixmap_priv->fbo = fbo;

    switch (pixmap_priv->type) {
    case GLAMOR_TEXTURE_ONLY:
    case GLAMOR_TEXTURE_DRM:
        pixmap_priv->gl_fbo = GLAMOR_FBO_NORMAL;
        pixmap->devPrivate.ptr = NULL;
    default:
        break;
    }
}

void
glamor_pixmap_destroy_fbo(PixmapPtr pixmap)
{
    ScreenPtr screen = pixmap->drawable.pScreen;
    glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
    glamor_pixmap_private *priv = glamor_get_pixmap_private(pixmap);
    glamor_pixmap_fbo *fbo;

    if (glamor_pixmap_priv_is_large(priv)) {
        int i;

        for (i = 0; i < priv->block_wcnt * priv->block_hcnt; i++)
            glamor_destroy_fbo(glamor_priv, priv->fbo_array[i]);
        free(priv->fbo_array);
    }
    else {
        fbo = glamor_pixmap_detach_fbo(priv);
        if (fbo)
            glamor_destroy_fbo(glamor_priv, fbo);
    }
}

Bool
glamor_pixmap_ensure_fbo(PixmapPtr pixmap, GLenum format, int flag)
{
    glamor_screen_private *glamor_priv;
    glamor_pixmap_private *pixmap_priv;
    glamor_pixmap_fbo *fbo;

    glamor_priv = glamor_get_screen_private(pixmap->drawable.pScreen);
    pixmap_priv = glamor_get_pixmap_private(pixmap);
    if (pixmap_priv->fbo == NULL) {

        fbo = glamor_create_fbo(glamor_priv, pixmap->drawable.width,
                                pixmap->drawable.height, format, flag);
        if (fbo == NULL)
            return FALSE;

        glamor_pixmap_attach_fbo(pixmap, fbo);
    }
    else {
        /* We do have a fbo, but it may lack of fb or tex. */
        if (!pixmap_priv->fbo->tex)
            pixmap_priv->fbo->tex =
                _glamor_create_tex(glamor_priv, pixmap->drawable.width,
                                   pixmap->drawable.height, format);

        if (flag != GLAMOR_CREATE_FBO_NO_FBO && pixmap_priv->fbo->fb == 0)
            if (glamor_pixmap_ensure_fb(glamor_priv, pixmap_priv->fbo) != 0)
                return FALSE;
    }

    return TRUE;
}

_X_EXPORT void
glamor_pixmap_exchange_fbos(PixmapPtr front, PixmapPtr back)
{
    glamor_pixmap_private *front_priv, *back_priv;
    glamor_pixmap_fbo *temp_fbo;

    front_priv = glamor_get_pixmap_private(front);
    back_priv = glamor_get_pixmap_private(back);
    temp_fbo = front_priv->fbo;
    front_priv->fbo = back_priv->fbo;
    back_priv->fbo = temp_fbo;
}
@


1.4
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@d343 1
a343 2
    if (format == glamor_priv->one_channel_format && format == GL_RED) {
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_SWIZZLE_R, GL_ZERO);
a344 1
    }
@


1.3
log
@Use an ARGB8888 based texture even when DRI3 isn't enabled.  This achieves the
same effect as a change that was recently made upstream.  The code changed
significantly in the meantime.

ok jsg@@, matthieu@@
@
text
@d73 17
d92 1
a92 1
                            int w, int h, GLenum format, int flag)
a106 17
    if (!(flag & GLAMOR_CACHE_EXACT_SIZE)) {
        xorg_list_for_each_entry(fbo_entry, cache, list) {
            if (fbo_entry->width >= w && fbo_entry->height >= h) {

                DEBUGF("Request w %d h %d format %x \n", w, h, format);
                DEBUGF("got cache entry %p w %d h %d fbo %d tex %d format %x\n",
                       fbo_entry, fbo_entry->width, fbo_entry->height,
                       fbo_entry->fb, fbo_entry->tex);
                xorg_list_del(&fbo_entry->list);
                ret_fbo = fbo_entry;
                break;
            }
        }
    }
    else {
        xorg_list_for_each_entry(fbo_entry, cache, list) {
            if (fbo_entry->width == w && fbo_entry->height == h) {
d108 11
a118 9
                DEBUGF("Request w %d h %d format %x \n", w, h, format);
                DEBUGF("got cache entry %p w %d h %d fbo %d tex %d format %x\n",
                       fbo_entry, fbo_entry->width, fbo_entry->height,
                       fbo_entry->fb, fbo_entry->tex, fbo_entry->format);
                assert(format == fbo_entry->format);
                xorg_list_del(&fbo_entry->list);
                ret_fbo = fbo_entry;
                break;
            }
d132 2
a133 1
glamor_purge_fbo(glamor_pixmap_fbo *fbo)
d135 1
a135 1
    glamor_make_current(fbo->glamor_priv);
a140 2
    if (fbo->pbo)
        glDeleteBuffers(1, &fbo->pbo);
d146 2
a147 1
glamor_pixmap_fbo_cache_put(glamor_pixmap_fbo *fbo)
d159 4
a162 4
        || fbo->glamor_priv->fbo_cache_watermark >= FBO_CACHE_THRESHOLD) {
        fbo->glamor_priv->tick += GLAMOR_CACHE_EXPIRE_MAX;
        glamor_fbo_expire(fbo->glamor_priv);
        glamor_purge_fbo(fbo);
d166 1
a166 1
    cache = &fbo->glamor_priv->fbo_cache[n_format]
d173 1
a173 1
    fbo->glamor_priv->fbo_cache_watermark += fbo->width * fbo->height;
d175 1
a175 1
    fbo->expire = fbo->glamor_priv->tick + GLAMOR_CACHE_EXPIRE_MAX;
d180 2
a181 1
glamor_pixmap_ensure_fb(glamor_pixmap_fbo *fbo)
d185 1
a185 1
    glamor_make_current(fbo->glamor_priv);
a244 1
    fbo->glamor_priv = glamor_priv;
d246 2
a247 5
    if (flag == GLAMOR_CREATE_PIXMAP_MAP) {
        glamor_make_current(glamor_priv);
        glGenBuffers(1, &fbo->pbo);
        goto done;
    }
d250 2
a251 2
        if (glamor_pixmap_ensure_fb(fbo) != 0) {
            glamor_purge_fbo(fbo);
a255 1
 done:
d281 1
a281 1
                    glamor_purge_fbo(fbo_entry);
d318 1
a318 1
                    glamor_purge_fbo(fbo_entry);
d324 2
a325 1
glamor_destroy_fbo(glamor_pixmap_fbo *fbo)
d328 1
a328 1
    glamor_pixmap_fbo_cache_put(fbo);
d336 1
a336 1
    unsigned int tex = 0;
d338 24
a361 16
    /* With dri3, we want to allocate ARGB8888 pixmaps only.
     * Depending on the implementation, GL_RGBA might not
     * give us ARGB8888. We ask glamor_egl to use get
     * an ARGB8888 based texture for us. */
    if (format == GL_RGBA) {
        tex = glamor_egl_create_argb8888_based_texture(glamor_priv->screen,
                                                       w, h);
    }
    if (!tex) {
        glamor_make_current(glamor_priv);
        glGenTextures(1, &tex);
        glBindTexture(GL_TEXTURE_2D, tex);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glTexImage2D(GL_TEXTURE_2D, 0, format, w, h, 0,
                     format, GL_UNSIGNED_BYTE, NULL);
d363 1
a372 1
    int cache_flag;
d374 1
a374 1
    if (flag == GLAMOR_CREATE_FBO_NO_FBO)
d377 1
a377 10
    if (flag == GLAMOR_CREATE_PIXMAP_MAP)
        goto no_tex;

    /* Tiling from textures requires exact pixmap sizes. As we don't
     * know which pixmaps will be used as tiles, just allocate
     * everything at the requested size
     */
    cache_flag = GLAMOR_CACHE_EXACT_SIZE;

    fbo = glamor_pixmap_fbo_cache_get(glamor_priv, w, h, format, cache_flag);
d382 2
a383 1
 no_tex:
d389 6
a394 2
static glamor_pixmap_fbo *
_glamor_create_fbo_array(glamor_screen_private *glamor_priv,
d397 1
a397 1
                         glamor_pixmap_private *pixmap_priv, int has_fbo)
a403 1
    glamor_pixmap_private_large_t *priv;
d405 2
a406 1
    priv = &pixmap_priv->large;
d437 4
a440 7
            if (!has_fbo)
                fbo_array[i * block_wcnt + j] = glamor_create_fbo(glamor_priv,
                                                                  fbo_w, fbo_h,
                                                                  format,
                                                                  GLAMOR_CREATE_PIXMAP_FIXUP);
            else
                fbo_array[i * block_wcnt + j] = priv->base.fbo;
d455 2
a456 2
        if ((fbo_array)[i])
            glamor_destroy_fbo((fbo_array)[i]);
a461 14
/* Create a fbo array to cover the w*h region, by using block_w*block_h
 * block.*/
glamor_pixmap_fbo *
glamor_create_fbo_array(glamor_screen_private *glamor_priv,
                        int w, int h, GLenum format, int flag,
                        int block_w, int block_h,
                        glamor_pixmap_private *pixmap_priv)
{
    pixmap_priv->large.block_w = block_w;
    pixmap_priv->large.block_h = block_h;
    return _glamor_create_fbo_array(glamor_priv, w, h, format, flag,
                                    block_w, block_h, pixmap_priv, 0);
}

d470 1
a470 1
    fbo = pixmap_priv->base.fbo;
d474 1
a474 1
    pixmap_priv->base.fbo = NULL;
d486 1
a486 1
    if (pixmap_priv->base.fbo)
d489 1
a489 1
    pixmap_priv->base.fbo = fbo;
a491 1
    case GLAMOR_TEXTURE_LARGE:
d494 1
a494 8
        pixmap_priv->base.gl_fbo = GLAMOR_FBO_NORMAL;
        if (fbo->tex != 0)
            pixmap_priv->base.gl_tex = 1;
        else {
            /* XXX For the Xephyr only, may be broken now. */
            pixmap_priv->base.gl_tex = 0;
        }
    case GLAMOR_MEMORY_MAP:
a495 1
        break;
d502 1
a502 1
glamor_pixmap_destroy_fbo(glamor_pixmap_private *priv)
d504 3
d509 1
a509 1
    if (priv->type == GLAMOR_TEXTURE_LARGE) {
a510 1
        glamor_pixmap_private_large_t *large = &priv->large;
d512 3
a514 3
        for (i = 0; i < large->block_wcnt * large->block_hcnt; i++)
            glamor_destroy_fbo(large->fbo_array[i]);
        free(large->fbo_array);
d519 1
a519 1
            glamor_destroy_fbo(fbo);
d532 1
a532 1
    if (pixmap_priv->base.fbo == NULL) {
d543 2
a544 2
        if (!pixmap_priv->base.fbo->tex)
            pixmap_priv->base.fbo->tex =
d548 2
a549 2
        if (flag != GLAMOR_CREATE_FBO_NO_FBO && pixmap_priv->base.fbo->fb == 0)
            if (glamor_pixmap_ensure_fb(pixmap_priv->base.fbo) != 0)
d564 3
a566 3
    temp_fbo = front_priv->base.fbo;
    front_priv->base.fbo = back_priv->base.fbo;
    back_priv->base.fbo = temp_fbo;
@


1.2
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d343 1
a343 1
    if (glamor_priv->dri3_enabled && format == GL_RGBA) {
@


1.1
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d129 1
a129 1
void
d156 1
a156 1
    if (fbo->fb == 0 || n_format == -1
d240 1
a350 1
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
a541 2

    free(priv);
@

