head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.2
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.1.0.4
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.2
	OPENBSD_5_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.2;
commitid	s0SI41sEunLdyFfd;

1.2
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.1;
commitid	Te1daavkBLskZ8gc;

1.1
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	;
commitid	cVXoV5PxI8YrEaVA;


desc
@@


1.3
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright © 2009 Intel Corporation
 * Copyright © 1998 Keith Packard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Zhigang Gong <zhigang.gong@@gmail.com>
 *
 */

#include "glamor_priv.h"
#include <dixfontstr.h>
#include "glamor_transform.h"

static const glamor_facet glamor_facet_poly_glyph_blt = {
    .name = "poly_glyph_blt",
    .vs_vars = "attribute vec2 primitive;\n",
    .vs_exec = ("       vec2 pos = vec2(0,0);\n"
                GLAMOR_POS(gl_Position, primitive)),
};

static Bool
glamor_poly_glyph_blt_gl(DrawablePtr drawable, GCPtr gc,
                         int start_x, int y, unsigned int nglyph,
                         CharInfoPtr *ppci, void *pglyph_base)
{
    ScreenPtr screen = drawable->pScreen;
    glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
    PixmapPtr pixmap = glamor_get_drawable_pixmap(drawable);
    glamor_pixmap_private *pixmap_priv;
    glamor_program *prog;
    RegionPtr clip = gc->pCompositeClip;
    int box_index;

    pixmap_priv = glamor_get_pixmap_private(pixmap);
    if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(pixmap_priv))
        goto bail;

    glamor_make_current(glamor_priv);

    prog = glamor_use_program_fill(pixmap, gc,
                                   &glamor_priv->poly_glyph_blt_progs,
                                   &glamor_facet_poly_glyph_blt);
    if (!prog)
        goto bail;

    glEnableVertexAttribArray(GLAMOR_VERTEX_POS);

    start_x += drawable->x;
    y += drawable->y;

    glamor_pixmap_loop(pixmap_priv, box_index) {
        int x;
        int n;
        int num_points, max_points;
        INT16 *points = NULL;
        int off_x, off_y;
        char *vbo_offset;

        glamor_set_destination_drawable(drawable, box_index, FALSE, TRUE,
                                        prog->matrix_uniform, &off_x, &off_y);

        max_points = 500;
        num_points = 0;
        x = start_x;
        for (n = 0; n < nglyph; n++) {
            CharInfoPtr charinfo = ppci[n];
            int w = GLYPHWIDTHPIXELS(charinfo);
            int h = GLYPHHEIGHTPIXELS(charinfo);
            uint8_t *glyphbits = FONTGLYPHBITS(NULL, charinfo);

            if (w && h) {
                int glyph_x = x + charinfo->metrics.leftSideBearing;
                int glyph_y = y - charinfo->metrics.ascent;
                int glyph_stride = GLYPHWIDTHBYTESPADDED(charinfo);
                int xx, yy;

                for (yy = 0; yy < h; yy++) {
                    uint8_t *glyph = glyphbits;
                    for (xx = 0; xx < w; glyph += ((xx&7) == 7), xx++) {
                        int pt_x_i = glyph_x + xx;
                        int pt_y_i = glyph_y + yy;

                        if (!(*glyph & (1 << (xx & 7))))
                            continue;

                        if (!RegionContainsPoint(clip, pt_x_i, pt_y_i, NULL))
                            continue;

                        if (!num_points) {
                            points = glamor_get_vbo_space(screen,
                                                          max_points *
                                                          (2 * sizeof (INT16)),
                                                          &vbo_offset);

                            glVertexAttribPointer(GLAMOR_VERTEX_POS,
                                                  2, GL_SHORT,
                                                  GL_FALSE, 0, vbo_offset);
                        }

                        *points++ = pt_x_i;
                        *points++ = pt_y_i;
                        num_points++;

                        if (num_points == max_points) {
                            glamor_put_vbo_space(screen);
                            glDrawArrays(GL_POINTS, 0, num_points);
                            num_points = 0;
                        }
                    }
                    glyphbits += glyph_stride;
                }
            }
            x += charinfo->metrics.characterWidth;
        }

        if (num_points) {
            glamor_put_vbo_space(screen);
            glDrawArrays(GL_POINTS, 0, num_points);
        }
    }

    glDisableVertexAttribArray(GLAMOR_VERTEX_POS);

    return TRUE;
bail:
    return FALSE;
}

void
glamor_poly_glyph_blt(DrawablePtr drawable, GCPtr gc,
                      int start_x, int y, unsigned int nglyph,
                      CharInfoPtr *ppci, void *pglyph_base)
{
    if (glamor_poly_glyph_blt_gl(drawable, gc, start_x, y, nglyph, ppci,
                                 pglyph_base))
        return;
    miPolyGlyphBlt(drawable, gc, start_x, y, nglyph,
                   ppci, pglyph_base);
}

static Bool
glamor_push_pixels_gl(GCPtr gc, PixmapPtr bitmap,
                      DrawablePtr drawable, int w, int h, int x, int y)
{
    ScreenPtr screen = drawable->pScreen;
    glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
    PixmapPtr pixmap = glamor_get_drawable_pixmap(drawable);
    glamor_pixmap_private *pixmap_priv;
    uint8_t *bitmap_data = bitmap->devPrivate.ptr;
    int bitmap_stride = bitmap->devKind;
    glamor_program *prog;
    RegionPtr clip = gc->pCompositeClip;
    int box_index;
    int yy, xx;
    int num_points;
    INT16 *points = NULL;
    char *vbo_offset;

    if (w * h > MAXINT / (2 * sizeof(float)))
        goto bail;

    pixmap_priv = glamor_get_pixmap_private(pixmap);
    if (!GLAMOR_PIXMAP_PRIV_HAS_FBO(pixmap_priv))
        goto bail;

    glamor_make_current(glamor_priv);

    prog = glamor_use_program_fill(pixmap, gc,
                                   &glamor_priv->poly_glyph_blt_progs,
                                   &glamor_facet_poly_glyph_blt);
    if (!prog)
        goto bail;

    glEnableVertexAttribArray(GLAMOR_VERTEX_POS);

    points = glamor_get_vbo_space(screen, w * h * sizeof(INT16) * 2,
                                  &vbo_offset);
    num_points = 0;

    /* Note that because fb sets miTranslate in the GC, our incoming X
     * and Y are in screen coordinate space (same for spans, but not
     * other operations).
     */

    for (yy = 0; yy < h; yy++) {
        uint8_t *bitmap_row = bitmap_data + yy * bitmap_stride;
        for (xx = 0; xx < w; xx++) {
            if (bitmap_row[xx / 8] & (1 << xx % 8) &&
                RegionContainsPoint(clip,
                                    x + xx,
                                    y + yy,
                                    NULL)) {
                *points++ = x + xx;
                *points++ = y + yy;
                num_points++;
            }
        }
    }
    glVertexAttribPointer(GLAMOR_VERTEX_POS, 2, GL_SHORT,
                          GL_FALSE, 0, vbo_offset);

    glamor_put_vbo_space(screen);

    glamor_pixmap_loop(pixmap_priv, box_index) {
        glamor_set_destination_drawable(drawable, box_index, FALSE, TRUE,
                                        prog->matrix_uniform, NULL, NULL);

        glDrawArrays(GL_POINTS, 0, num_points);
    }

    glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
    return TRUE;

bail:
    return FALSE;
}

void
glamor_push_pixels(GCPtr pGC, PixmapPtr pBitmap,
                   DrawablePtr pDrawable, int w, int h, int x, int y)
{
    if (glamor_push_pixels_gl(pGC, pBitmap, pDrawable, w, h, x, y))
        return;

    miPushPixels(pGC, pBitmap, pDrawable, w, h, x, y);
}
@


1.2
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d51 1
a51 1
    int box_x, box_y;
d63 1
a63 1
        goto bail_ctx;
d70 1
a70 1
    glamor_pixmap_loop(pixmap_priv, box_x, box_y) {
d78 1
a78 1
        glamor_set_destination_drawable(drawable, box_x, box_y, FALSE, TRUE,
a140 1
    glDisable(GL_COLOR_LOGIC_OP);
a143 2
bail_ctx:
    glDisable(GL_COLOR_LOGIC_OP);
a159 26
Bool
glamor_poly_glyph_blt_nf(DrawablePtr drawable, GCPtr gc,
                         int start_x, int y, unsigned int nglyph,
                         CharInfoPtr *ppci, void *pglyph_base)
{
    if (glamor_poly_glyph_blt_gl(drawable, gc, start_x, y, nglyph, ppci,
                                 pglyph_base))
        return TRUE;
    if (glamor_ddx_fallback_check_pixmap(drawable) &&
        glamor_ddx_fallback_check_gc(gc)) {
        return FALSE;
    }
    miPolyGlyphBlt(drawable, gc, start_x, y, nglyph,
                   ppci, pglyph_base);
    return TRUE;
}

Bool
glamor_image_glyph_blt_nf(DrawablePtr drawable, GCPtr gc,
                          int start_x, int y, unsigned int nglyph,
                          CharInfoPtr *ppci, void *pglyph_base)
{
    miImageGlyphBlt(drawable, gc, start_x, y, nglyph, ppci, pglyph_base);
    return TRUE;
}

d172 1
a172 1
    int box_x, box_y;
d191 1
a191 1
        goto bail_ctx;
d223 2
a224 2
    glamor_pixmap_loop(pixmap_priv, box_x, box_y) {
        glamor_set_destination_drawable(drawable, box_x, box_y, FALSE, TRUE,
a229 1
    glDisable(GL_COLOR_LOGIC_OP);
a232 2
bail_ctx:
    glDisable(GL_COLOR_LOGIC_OP);
a244 18
}

Bool
glamor_push_pixels_nf(GCPtr gc, PixmapPtr bitmap,
                      DrawablePtr drawable, int w, int h, int x, int y)
{
    if (glamor_push_pixels_gl(gc, bitmap, drawable, w, h, x, y))
        return TRUE;

    if (glamor_ddx_fallback_check_pixmap(drawable) &&
        glamor_ddx_fallback_check_pixmap(&bitmap->drawable) &&
        glamor_ddx_fallback_check_gc(gc))
    {
        return FALSE;
    }

    miPushPixels(gc, bitmap, drawable, w, h, x, y);
    return TRUE;
@


1.1
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d59 2
a60 1
    prog = glamor_use_program_fill(pixmap, gc, &glamor_priv->poly_glyph_blt_progs,
d78 2
a79 1
        glamor_set_destination_drawable(drawable, box_x, box_y, FALSE, TRUE, prog->matrix_uniform, &off_x, &off_y);
d110 2
a111 1
                                                          max_points * (2 * sizeof (INT16)),
d114 2
a115 1
                            glVertexAttribPointer(GLAMOR_VERTEX_POS, 2, GL_SHORT,
d156 2
a157 1
    if (glamor_poly_glyph_blt_gl(drawable, gc, start_x, y, nglyph, ppci, pglyph_base))
d168 2
a169 1
    if (glamor_poly_glyph_blt_gl(drawable, gc, start_x, y, nglyph, ppci, pglyph_base))
d171 2
a172 1
    if (glamor_ddx_fallback_check_pixmap(drawable) && glamor_ddx_fallback_check_gc(gc))
d174 1
d190 2
a191 2
glamor_push_pixels_points(GCPtr gc, PixmapPtr bitmap,
                          DrawablePtr drawable, int w, int h, int x, int y)
d199 3
a201 1
    int off_x, off_y;
d203 2
a204 5
    GLfloat xscale, yscale;
    float color[4];
    unsigned long fg_pixel = gc->fgPixel;
    float *points, *next_point;
    int num_points = 0;
a205 1
    RegionPtr clip;
d208 1
a208 6
        return FALSE;

    if (gc->fillStyle != FillSolid) {
        glamor_fallback("gc fillstyle not solid\n");
        return FALSE;
    }
d212 1
a212 1
        return FALSE;
a214 8
    if (!glamor_set_alu(screen, gc->alu)) {
        if (gc->alu == GXclear)
            fg_pixel = 0;
        else {
            glamor_fallback("unsupported alu %x\n", gc->alu);
            return FALSE;
        }
    }
d216 5
a220 4
    if (!glamor_set_planemask(pixmap, gc->planemask)) {
        glamor_fallback("Failed to set planemask in %s.\n", __FUNCTION__);
        return FALSE;
    }
d222 1
a222 6
    glamor_get_drawable_deltas(drawable, pixmap, &off_x, &off_y);

    glamor_set_destination_pixmap_priv_nc(pixmap_priv);
    pixmap_priv_get_dest_scale(pixmap_priv, &xscale, &yscale);

    glUseProgram(glamor_priv->solid_prog);
d224 1
a224 6
    glamor_get_rgba_from_pixel(fg_pixel,
                               &color[0], &color[1], &color[2], &color[3],
                               format_for_pixmap(pixmap));
    glUniform4fv(glamor_priv->solid_color_uniform_location, 1, color);

    points = glamor_get_vbo_space(screen, w * h * sizeof(float) * 2,
d226 1
a226 3
    next_point = points;

    clip = fbGetCompositeClip(gc);
d232 1
d241 2
a242 7
                next_point[0] = v_from_x_coord_x(xscale, x + xx + off_x + 0.5);
                if (glamor_priv->yInverted)
                    next_point[1] = v_from_x_coord_y_inverted(yscale, y + yy + off_y + 0.5);
                else
                    next_point[1] = v_from_x_coord_y(yscale, y + yy + off_y + 0.5);

                next_point += 2;
d247 2
a248 4
    glVertexAttribPointer(GLAMOR_VERTEX_POS, 2, GL_FLOAT,
                          GL_FALSE, 2 * sizeof(float),
                          vbo_offset);
    glEnableVertexAttribArray(GLAMOR_VERTEX_POS);
d252 6
a257 1
    glDrawArrays(GL_POINTS, 0, num_points);
d259 1
a260 1

a261 1
}
d263 4
a266 20
static Bool
_glamor_push_pixels(GCPtr pGC, PixmapPtr pBitmap,
                    DrawablePtr pDrawable, int w, int h, int x, int y,
                    Bool fallback)
{
    glamor_pixmap_private *pixmap_priv;

    if (!fallback && glamor_ddx_fallback_check_pixmap(pDrawable)
        && glamor_ddx_fallback_check_pixmap(&pBitmap->drawable)
        && glamor_ddx_fallback_check_gc(pGC))
        return FALSE;

    pixmap_priv = glamor_get_pixmap_private(pBitmap);
    if (pixmap_priv->type == GLAMOR_MEMORY) {
        if (glamor_push_pixels_points(pGC, pBitmap, pDrawable, w, h, x, y))
            return TRUE;
    }

    miPushPixels(pGC, pBitmap, pDrawable, w, h, x, y);
    return TRUE;
d273 4
a276 1
    _glamor_push_pixels(pGC, pBitmap, pDrawable, w, h, x, y, TRUE);
d280 2
a281 2
glamor_push_pixels_nf(GCPtr pGC, PixmapPtr pBitmap,
                      DrawablePtr pDrawable, int w, int h, int x, int y)
d283 12
a294 1
    return _glamor_push_pixels(pGC, pBitmap, pDrawable, w, h, x, y, FALSE);
@

