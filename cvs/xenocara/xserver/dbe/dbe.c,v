head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.6
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.13.0.2
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.17;
commitid	s0SI41sEunLdyFfd;

1.17
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	Te1daavkBLskZ8gc;

1.16
date	2014.12.21.11.41.45;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	OOAr3LJJfv7DyAHR;

1.15
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	vcnjRBuLQw44cPHf;

1.14
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	cVXoV5PxI8YrEaVA;

1.13
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.02.15.26.12;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.11.16.15.28;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.24.19.04.01;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.03.11.31.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.09.14.24.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.46;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.46;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.11.46;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.18.05.37;	author matthieu;	state Exp;
branches;
next	;

1.12.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.13.2.1
date	2014.12.09.17.59.32;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.18
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/******************************************************************************
 *
 * Copyright (c) 1994, 1995  Hewlett-Packard Company
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the Hewlett-Packard
 * Company shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization from the Hewlett-Packard Company.
 *
 *     DIX DBE code
 *
 *****************************************************************************/

/* INCLUDES */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>
#include <stdint.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "scrnintstr.h"
#include "extnsionst.h"
#include "extinit.h"
#include "gcstruct.h"
#include "dixstruct.h"
#define NEED_DBE_PROTOCOL
#include "dbestruct.h"
#include "midbe.h"
#include "xace.h"

/* GLOBALS */

/* These are globals for use by DDX */
DevPrivateKeyRec dbeScreenPrivKeyRec;
DevPrivateKeyRec dbeWindowPrivKeyRec;

/* These are globals for use by DDX */
RESTYPE dbeDrawableResType;
RESTYPE dbeWindowPrivResType;

/* Used to generate DBE's BadBuffer error. */
static int dbeErrorBase;

/******************************************************************************
 *
 * DBE DIX Procedure: DbeStubScreen
 *
 * Description:
 *
 *     This is function stubs the function pointers in the given DBE screen
 *     private and increments the number of stubbed screens.
 *
 *****************************************************************************/

static void
DbeStubScreen(DbeScreenPrivPtr pDbeScreenPriv, int *nStubbedScreens)
{
    /* Stub DIX. */
    pDbeScreenPriv->SetupBackgroundPainter = NULL;

    /* Do not unwrap PositionWindow nor DestroyWindow.  If the DDX
     * initialization function failed, we assume that it did not wrap
     * PositionWindow.  Also, DestroyWindow is only wrapped if the DDX
     * initialization function succeeded.
     */

    /* Stub DDX. */
    pDbeScreenPriv->GetVisualInfo = NULL;
    pDbeScreenPriv->AllocBackBufferName = NULL;
    pDbeScreenPriv->SwapBuffers = NULL;
    pDbeScreenPriv->WinPrivDelete = NULL;

    (*nStubbedScreens)++;

}                               /* DbeStubScreen() */

/******************************************************************************
 *
 * DBE DIX Procedure: ProcDbeGetVersion
 *
 * Description:
 *
 *     This function is for processing a DbeGetVersion request.
 *     This request returns the major and minor version numbers of this
 *     extension.
 *
 * Return Values:
 *
 *     Success
 *
 *****************************************************************************/

static int
ProcDbeGetVersion(ClientPtr client)
{
    /* REQUEST(xDbeGetVersionReq); */
    xDbeGetVersionReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .majorVersion = DBE_MAJOR_VERSION,
        .minorVersion = DBE_MINOR_VERSION
    };

    REQUEST_SIZE_MATCH(xDbeGetVersionReq);

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
    }

    WriteToClient(client, sizeof(xDbeGetVersionReply), &rep);

    return Success;

}                               /* ProcDbeGetVersion() */

/******************************************************************************
 *
 * DBE DIX Procedure: ProcDbeAllocateBackBufferName
 *
 * Description:
 *
 *     This function is for processing a DbeAllocateBackBufferName request.
 *     This request allocates a drawable ID used to refer to the back buffer
 *     of a window.
 *
 * Return Values:
 *
 *     BadAlloc    - server can not allocate resources
 *     BadIDChoice - id is out of range for client; id is already in use
 *     BadMatch    - window is not an InputOutput window;
 *                   visual of window is not on list returned by
 *                   DBEGetVisualInfo;
 *     BadValue    - invalid swap action is specified
 *     BadWindow   - window is not a valid window
 *     Success
 *
 *****************************************************************************/

static int
ProcDbeAllocateBackBufferName(ClientPtr client)
{
    REQUEST(xDbeAllocateBackBufferNameReq);
    WindowPtr pWin;
    DbeScreenPrivPtr pDbeScreenPriv;
    DbeWindowPrivPtr pDbeWindowPriv;
    XdbeScreenVisualInfo scrVisInfo;
    register int i;
    Bool visualMatched = FALSE;
    xDbeSwapAction swapAction;
    VisualID visual;
    int status;
    int add_index;

    REQUEST_SIZE_MATCH(xDbeAllocateBackBufferNameReq);

    /* The window must be valid. */
    status = dixLookupWindow(&pWin, stuff->window, client, DixManageAccess);
    if (status != Success)
        return status;

    /* The window must be InputOutput. */
    if (pWin->drawable.class != InputOutput) {
        return BadMatch;
    }

    /* The swap action must be valid. */
    swapAction = stuff->swapAction;     /* use local var for performance. */
    if ((swapAction != XdbeUndefined) &&
        (swapAction != XdbeBackground) &&
        (swapAction != XdbeUntouched) && (swapAction != XdbeCopied)) {
        return BadValue;
    }

    /* The id must be in range and not already in use. */
    LEGAL_NEW_RESOURCE(stuff->buffer, client);

    /* The visual of the window must be in the list returned by
     * GetVisualInfo.
     */
    pDbeScreenPriv = DBE_SCREEN_PRIV_FROM_WINDOW(pWin);
    if (!pDbeScreenPriv->GetVisualInfo)
        return BadMatch;        /* screen doesn't support double buffering */

    if (!(*pDbeScreenPriv->GetVisualInfo) (pWin->drawable.pScreen, &scrVisInfo)) {
        /* GetVisualInfo() failed to allocate visual info data. */
        return BadAlloc;
    }

    /* See if the window's visual is on the list. */
    visual = wVisual(pWin);
    for (i = 0; (i < scrVisInfo.count) && !visualMatched; i++) {
        if (scrVisInfo.visinfo[i].visual == visual) {
            visualMatched = TRUE;
        }
    }

    /* Free what was allocated by the GetVisualInfo() call above. */
    free(scrVisInfo.visinfo);

    if (!visualMatched) {
        return BadMatch;
    }

    if ((pDbeWindowPriv = DBE_WINDOW_PRIV(pWin)) == NULL) {
        /* There is no buffer associated with the window.
         * Allocate a window priv.
         */

        pDbeWindowPriv = calloc(1, sizeof(DbeWindowPrivRec));
        if (!pDbeWindowPriv)
            return BadAlloc;

        /* Fill out window priv information. */
        pDbeWindowPriv->pWindow = pWin;
        pDbeWindowPriv->width = pWin->drawable.width;
        pDbeWindowPriv->height = pWin->drawable.height;
        pDbeWindowPriv->x = pWin->drawable.x;
        pDbeWindowPriv->y = pWin->drawable.y;
        pDbeWindowPriv->nBufferIDs = 0;

        /* Set the buffer ID array pointer to the initial (static) array). */
        pDbeWindowPriv->IDs = pDbeWindowPriv->initIDs;

        /* Initialize the buffer ID list. */
        pDbeWindowPriv->maxAvailableIDs = DBE_INIT_MAX_IDS;
        pDbeWindowPriv->IDs[0] = stuff->buffer;

        add_index = 0;
        for (i = 0; i < DBE_INIT_MAX_IDS; i++) {
            pDbeWindowPriv->IDs[i] = DBE_FREE_ID_ELEMENT;
        }

        /* Actually connect the window priv to the window. */
        dixSetPrivate(&pWin->devPrivates, dbeWindowPrivKey, pDbeWindowPriv);

    }                           /* if -- There is no buffer associated with the window. */

    else {
        /* A buffer is already associated with the window.
         * Add the new buffer ID to the array, reallocating the array memory
         * if necessary.
         */

        /* Determine if there is a free element in the ID array. */
        for (i = 0; i < pDbeWindowPriv->maxAvailableIDs; i++) {
            if (pDbeWindowPriv->IDs[i] == DBE_FREE_ID_ELEMENT) {
                /* There is still room in the ID array. */
                break;
            }
        }

        if (i == pDbeWindowPriv->maxAvailableIDs) {
            /* No more room in the ID array -- reallocate another array. */
            XID *pIDs;

            /* Setup an array pointer for the realloc operation below. */
            if (pDbeWindowPriv->maxAvailableIDs == DBE_INIT_MAX_IDS) {
                /* We will malloc a new array. */
                pIDs = NULL;
            }
            else {
                /* We will realloc a new array. */
                pIDs = pDbeWindowPriv->IDs;
            }

            /* malloc/realloc a new array and initialize all elements to 0. */
            pDbeWindowPriv->IDs =
                reallocarray(pIDs,
                             pDbeWindowPriv->maxAvailableIDs + DBE_INCR_MAX_IDS,
                             sizeof(XID));
            if (!pDbeWindowPriv->IDs) {
                return BadAlloc;
            }
            memset(&pDbeWindowPriv->IDs[pDbeWindowPriv->nBufferIDs], 0,
                   (pDbeWindowPriv->maxAvailableIDs + DBE_INCR_MAX_IDS -
                    pDbeWindowPriv->nBufferIDs) * sizeof(XID));

            if (pDbeWindowPriv->maxAvailableIDs == DBE_INIT_MAX_IDS) {
                /* We just went from using the initial (static) array to a
                 * newly allocated array.  Copy the IDs from the initial array
                 * to the new array.
                 */
                memcpy(pDbeWindowPriv->IDs, pDbeWindowPriv->initIDs,
                       DBE_INIT_MAX_IDS * sizeof(XID));
            }

            pDbeWindowPriv->maxAvailableIDs += DBE_INCR_MAX_IDS;
        }

        add_index = i;

    }                           /* else -- A buffer is already associated with the window. */

    /* Call the DDX routine to allocate the back buffer. */
    status = (*pDbeScreenPriv->AllocBackBufferName) (pWin, stuff->buffer,
                                                     stuff->swapAction);

    if (status == Success) {
        pDbeWindowPriv->IDs[add_index] = stuff->buffer;
        if (!AddResource(stuff->buffer, dbeWindowPrivResType,
                         (void *) pDbeWindowPriv)) {
            pDbeWindowPriv->IDs[add_index] = DBE_FREE_ID_ELEMENT;

            if (pDbeWindowPriv->nBufferIDs == 0) {
                status = BadAlloc;
                goto out_free;
            }
        }
    }
    else {
        /* The DDX buffer allocation routine failed for the first buffer of
         * this window.
         */
        if (pDbeWindowPriv->nBufferIDs == 0) {
            goto out_free;
        }
    }

    /* Increment the number of buffers (XIDs) associated with this window. */
    pDbeWindowPriv->nBufferIDs++;

    /* Set swap action on all calls. */
    pDbeWindowPriv->swapAction = stuff->swapAction;

    return status;

 out_free:
    dixSetPrivate(&pWin->devPrivates, dbeWindowPrivKey, NULL);
    free(pDbeWindowPriv);
    return status;

}                               /* ProcDbeAllocateBackBufferName() */

/******************************************************************************
 *
 * DBE DIX Procedure: ProcDbeDeallocateBackBufferName
 *
 * Description:
 *
 *     This function is for processing a DbeDeallocateBackBufferName request.
 *     This request frees a drawable ID that was obtained by a
 *     DbeAllocateBackBufferName request.
 *
 * Return Values:
 *
 *     BadBuffer - buffer to deallocate is not associated with a window
 *     Success
 *
 *****************************************************************************/

static int
ProcDbeDeallocateBackBufferName(ClientPtr client)
{
    REQUEST(xDbeDeallocateBackBufferNameReq);
    DbeWindowPrivPtr pDbeWindowPriv;
    int rc, i;
    void *val;

    REQUEST_SIZE_MATCH(xDbeDeallocateBackBufferNameReq);

    /* Buffer name must be valid */
    rc = dixLookupResourceByType((void **) &pDbeWindowPriv, stuff->buffer,
                                 dbeWindowPrivResType, client,
                                 DixDestroyAccess);
    if (rc != Success)
        return rc;

    rc = dixLookupResourceByType(&val, stuff->buffer, dbeDrawableResType,
                                 client, DixDestroyAccess);
    if (rc != Success)
        return rc;

    /* Make sure that the id is valid for the window.
     * This is paranoid code since we already looked up the ID by type
     * above.
     */

    for (i = 0; i < pDbeWindowPriv->nBufferIDs; i++) {
        /* Loop through the ID list to find the ID. */
        if (pDbeWindowPriv->IDs[i] == stuff->buffer) {
            break;
        }
    }

    if (i == pDbeWindowPriv->nBufferIDs) {
        /* We did not find the ID in the ID list. */
        client->errorValue = stuff->buffer;
        return dbeErrorBase + DbeBadBuffer;
    }

    FreeResource(stuff->buffer, RT_NONE);

    return Success;

}                               /* ProcDbeDeallocateBackBufferName() */

/******************************************************************************
 *
 * DBE DIX Procedure: ProcDbeSwapBuffers
 *
 * Description:
 *
 *     This function is for processing a DbeSwapBuffers request.
 *     This request swaps the buffers for all windows listed, applying the
 *     appropriate swap action for each window.
 *
 * Return Values:
 *
 *     BadAlloc  - local allocation failed; this return value is not defined
 *                 by the protocol
 *     BadMatch  - a window in request is not double-buffered; a window in
 *                 request is listed more than once
 *     BadValue  - invalid swap action is specified; no swap action is
 *                 specified
 *     BadWindow - a window in request is not valid
 *     Success
 *
 *****************************************************************************/

static int
ProcDbeSwapBuffers(ClientPtr client)
{
    REQUEST(xDbeSwapBuffersReq);
    WindowPtr pWin;
    DbeScreenPrivPtr pDbeScreenPriv;
    DbeSwapInfoPtr swapInfo;
    xDbeSwapInfo *dbeSwapInfo;
    int error;
    unsigned int i, j;
    unsigned int nStuff;
    int nStuff_i;       /* DDX API requires int for nStuff */

    REQUEST_AT_LEAST_SIZE(xDbeSwapBuffersReq);
    nStuff = stuff->n;          /* use local variable for performance. */

    if (nStuff == 0) {
        REQUEST_SIZE_MATCH(xDbeSwapBuffersReq);
        return Success;
    }

    if (nStuff > UINT32_MAX / sizeof(DbeSwapInfoRec))
        return BadAlloc;
    REQUEST_FIXED_SIZE(xDbeSwapBuffersReq, nStuff * sizeof(xDbeSwapInfo));

    /* Get to the swap info appended to the end of the request. */
    dbeSwapInfo = (xDbeSwapInfo *) &stuff[1];

    /* Allocate array to record swap information. */
    swapInfo = xallocarray(nStuff, sizeof(DbeSwapInfoRec));
    if (swapInfo == NULL) {
        return BadAlloc;
    }

    for (i = 0; i < nStuff; i++) {
        /* Check all windows to swap. */

        /* Each window must be a valid window - BadWindow. */
        error = dixLookupWindow(&pWin, dbeSwapInfo[i].window, client,
                                DixWriteAccess);
        if (error != Success) {
            free(swapInfo);
            return error;
        }

        /* Each window must be double-buffered - BadMatch. */
        if (DBE_WINDOW_PRIV(pWin) == NULL) {
            free(swapInfo);
            return BadMatch;
        }

        /* Each window must only be specified once - BadMatch. */
        for (j = i + 1; j < nStuff; j++) {
            if (dbeSwapInfo[i].window == dbeSwapInfo[j].window) {
                free(swapInfo);
                return BadMatch;
            }
        }

        /* Each swap action must be valid - BadValue. */
        if ((dbeSwapInfo[i].swapAction != XdbeUndefined) &&
            (dbeSwapInfo[i].swapAction != XdbeBackground) &&
            (dbeSwapInfo[i].swapAction != XdbeUntouched) &&
            (dbeSwapInfo[i].swapAction != XdbeCopied)) {
            free(swapInfo);
            return BadValue;
        }

        /* Everything checks out OK.  Fill in the swap info array. */
        swapInfo[i].pWindow = pWin;
        swapInfo[i].swapAction = dbeSwapInfo[i].swapAction;

    }                           /* for (i = 0; i < nStuff; i++) */

    /* Call the DDX routine to perform the swap(s).  The DDX routine should
     * scan the swap list (swap info), swap any buffers that it knows how to
     * handle, delete them from the list, and update nStuff to indicate how
     * many windows it did not handle.
     *
     * This scheme allows a range of sophistication in the DDX SwapBuffers()
     * implementation.  Naive implementations could just swap the first buffer
     * in the list, move the last buffer to the front, decrement nStuff, and
     * return.  The next level of sophistication could be to scan the whole
     * list for windows on the same screen.  Up another level, the DDX routine
     * could deal with cross-screen synchronization.
     */

    nStuff_i = nStuff;
    while (nStuff_i > 0) {
        pDbeScreenPriv = DBE_SCREEN_PRIV_FROM_WINDOW(swapInfo[0].pWindow);
        error = (*pDbeScreenPriv->SwapBuffers) (client, &nStuff_i, swapInfo);
        if (error != Success) {
            free(swapInfo);
            return error;
        }
    }

    free(swapInfo);
    return Success;

}                               /* ProcDbeSwapBuffers() */

/******************************************************************************
 *
 * DBE DIX Procedure: ProcDbeGetVisualInfo
 *
 * Description:
 *
 *     This function is for processing a ProcDbeGetVisualInfo request.
 *     This request returns information about which visuals support
 *     double buffering.
 *
 * Return Values:
 *
 *     BadDrawable - value in screen specifiers is not a valid drawable
 *     Success
 *
 *****************************************************************************/

static int
ProcDbeGetVisualInfo(ClientPtr client)
{
    REQUEST(xDbeGetVisualInfoReq);
    DbeScreenPrivPtr pDbeScreenPriv;
    xDbeGetVisualInfoReply rep;
    Drawable *drawables;
    DrawablePtr *pDrawables = NULL;
    register int i, j, rc;
    register int count;         /* number of visual infos in reply */
    register int length;        /* length of reply */
    ScreenPtr pScreen;
    XdbeScreenVisualInfo *pScrVisInfo;

    REQUEST_AT_LEAST_SIZE(xDbeGetVisualInfoReq);

    if (stuff->n > UINT32_MAX / sizeof(DrawablePtr))
        return BadAlloc;
    /* Make sure any specified drawables are valid. */
    if (stuff->n != 0) {
        if (!(pDrawables = xallocarray(stuff->n, sizeof(DrawablePtr)))) {
            return BadAlloc;
        }

        drawables = (Drawable *) &stuff[1];

        for (i = 0; i < stuff->n; i++) {
            rc = dixLookupDrawable(pDrawables + i, drawables[i], client, 0,
                                   DixGetAttrAccess);
            if (rc != Success) {
                free(pDrawables);
                return rc;
            }
        }
    }

    count = (stuff->n == 0) ? screenInfo.numScreens : stuff->n;
    if (!(pScrVisInfo = calloc(count, sizeof(XdbeScreenVisualInfo)))) {
        free(pDrawables);

        return BadAlloc;
    }

    length = 0;

    for (i = 0; i < count; i++) {
        pScreen = (stuff->n == 0) ? screenInfo.screens[i] :
            pDrawables[i]->pScreen;
        pDbeScreenPriv = DBE_SCREEN_PRIV(pScreen);

        rc = XaceHook(XACE_SCREEN_ACCESS, client, pScreen, DixGetAttrAccess);
        if (rc != Success)
            goto freeScrVisInfo;

        if (!(*pDbeScreenPriv->GetVisualInfo) (pScreen, &pScrVisInfo[i])) {
            /* We failed to alloc pScrVisInfo[i].visinfo. */
            rc = BadAlloc;

            /* Free visinfos that we allocated for previous screen infos. */
            goto freeScrVisInfo;
        }

        /* Account for n, number of xDbeVisInfo items in list. */
        length += sizeof(CARD32);

        /* Account for n xDbeVisInfo items */
        length += pScrVisInfo[i].count * sizeof(xDbeVisInfo);
    }

    rep = (xDbeGetVisualInfoReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(length),
        .m = count
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.m);
    }

    /* Send off reply. */
    WriteToClient(client, sizeof(xDbeGetVisualInfoReply), &rep);

    for (i = 0; i < count; i++) {
        CARD32 data32;

        /* For each screen in the reply, send off the visual info */

        /* Send off number of visuals. */
        data32 = (CARD32) pScrVisInfo[i].count;

        if (client->swapped) {
            swapl(&data32);
        }

        WriteToClient(client, sizeof(CARD32), &data32);

        /* Now send off visual info items. */
        for (j = 0; j < pScrVisInfo[i].count; j++) {
            xDbeVisInfo visInfo;

            /* Copy the data in the client data structure to a protocol
             * data structure.  We will send data to the client from the
             * protocol data structure.
             */

            visInfo.visualID = (CARD32) pScrVisInfo[i].visinfo[j].visual;
            visInfo.depth = (CARD8) pScrVisInfo[i].visinfo[j].depth;
            visInfo.perfLevel = (CARD8) pScrVisInfo[i].visinfo[j].perflevel;

            if (client->swapped) {
                swapl(&visInfo.visualID);

                /* We do not need to swap depth and perfLevel since they are
                 * already 1 byte quantities.
                 */
            }

            /* Write visualID(32), depth(8), perfLevel(8), and pad(16). */
            WriteToClient(client, 2 * sizeof(CARD32), &visInfo.visualID);
        }
    }

    rc = Success;

 freeScrVisInfo:
    /* Clean up memory. */
    for (i = 0; i < count; i++) {
        free(pScrVisInfo[i].visinfo);
    }
    free(pScrVisInfo);

    free(pDrawables);

    return rc;

}                               /* ProcDbeGetVisualInfo() */

/******************************************************************************
 *
 * DBE DIX Procedure: ProcDbeGetbackBufferAttributes
 *
 * Description:
 *
 *     This function is for processing a ProcDbeGetbackBufferAttributes
 *     request.  This request returns information about a back buffer.
 *
 * Return Values:
 *
 *     Success
 *
 *****************************************************************************/

static int
ProcDbeGetBackBufferAttributes(ClientPtr client)
{
    REQUEST(xDbeGetBackBufferAttributesReq);
    xDbeGetBackBufferAttributesReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };
    DbeWindowPrivPtr pDbeWindowPriv;
    int rc;

    REQUEST_SIZE_MATCH(xDbeGetBackBufferAttributesReq);

    rc = dixLookupResourceByType((void **) &pDbeWindowPriv, stuff->buffer,
                                 dbeWindowPrivResType, client,
                                 DixGetAttrAccess);
    if (rc == Success) {
        rep.attributes = pDbeWindowPriv->pWindow->drawable.id;
    }
    else {
        rep.attributes = None;
    }

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.attributes);
    }

    WriteToClient(client, sizeof(xDbeGetBackBufferAttributesReply), &rep);
    return Success;

}                               /* ProcDbeGetbackBufferAttributes() */

/******************************************************************************
 *
 * DBE DIX Procedure: ProcDbeDispatch
 *
 * Description:
 *
 *     This function dispatches DBE requests.
 *
 *****************************************************************************/

static int
ProcDbeDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_DbeGetVersion:
        return (ProcDbeGetVersion(client));

    case X_DbeAllocateBackBufferName:
        return (ProcDbeAllocateBackBufferName(client));

    case X_DbeDeallocateBackBufferName:
        return (ProcDbeDeallocateBackBufferName(client));

    case X_DbeSwapBuffers:
        return (ProcDbeSwapBuffers(client));

    case X_DbeBeginIdiom:
        return Success;

    case X_DbeEndIdiom:
        return Success;

    case X_DbeGetVisualInfo:
        return (ProcDbeGetVisualInfo(client));

    case X_DbeGetBackBufferAttributes:
        return (ProcDbeGetBackBufferAttributes(client));

    default:
        return BadRequest;
    }

}                               /* ProcDbeDispatch() */

/******************************************************************************
 *
 * DBE DIX Procedure: SProcDbeGetVersion
 *
 * Description:
 *
 *     This function is for processing a DbeGetVersion request on a swapped
 *     server.  This request returns the major and minor version numbers of
 *     this extension.
 *
 * Return Values:
 *
 *     Success
 *
 *****************************************************************************/

static int
SProcDbeGetVersion(ClientPtr client)
{
    REQUEST(xDbeGetVersionReq);

    swaps(&stuff->length);
    return (ProcDbeGetVersion(client));

}                               /* SProcDbeGetVersion() */

/******************************************************************************
 *
 * DBE DIX Procedure: SProcDbeAllocateBackBufferName
 *
 * Description:
 *
 *     This function is for processing a DbeAllocateBackBufferName request on
 *     a swapped server.  This request allocates a drawable ID used to refer
 *     to the back buffer of a window.
 *
 * Return Values:
 *
 *     BadAlloc    - server can not allocate resources
 *     BadIDChoice - id is out of range for client; id is already in use
 *     BadMatch    - window is not an InputOutput window;
 *                   visual of window is not on list returned by
 *                   DBEGetVisualInfo;
 *     BadValue    - invalid swap action is specified
 *     BadWindow   - window is not a valid window
 *     Success
 *
 *****************************************************************************/

static int
SProcDbeAllocateBackBufferName(ClientPtr client)
{
    REQUEST(xDbeAllocateBackBufferNameReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDbeAllocateBackBufferNameReq);

    swapl(&stuff->window);
    swapl(&stuff->buffer);
    /* stuff->swapAction is a byte.  We do not need to swap this field. */

    return (ProcDbeAllocateBackBufferName(client));

}                               /* SProcDbeAllocateBackBufferName() */

/******************************************************************************
 *
 * DBE DIX Procedure: SProcDbeDeallocateBackBufferName
 *
 * Description:
 *
 *     This function is for processing a DbeDeallocateBackBufferName request
 *     on a swapped server.  This request frees a drawable ID that was
 *     obtained by a DbeAllocateBackBufferName request.
 *
 * Return Values:
 *
 *     BadBuffer - buffer to deallocate is not associated with a window
 *     Success
 *
 *****************************************************************************/

static int
SProcDbeDeallocateBackBufferName(ClientPtr client)
{
    REQUEST(xDbeDeallocateBackBufferNameReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDbeDeallocateBackBufferNameReq);

    swapl(&stuff->buffer);

    return (ProcDbeDeallocateBackBufferName(client));

}                               /* SProcDbeDeallocateBackBufferName() */

/******************************************************************************
 *
 * DBE DIX Procedure: SProcDbeSwapBuffers
 *
 * Description:
 *
 *     This function is for processing a DbeSwapBuffers request on a swapped
 *     server.  This request swaps the buffers for all windows listed,
 *     applying the appropriate swap action for each window.
 *
 * Return Values:
 *
 *     BadMatch  - a window in request is not double-buffered; a window in
 *                 request is listed more than once; all windows in request do
 *                 not have the same root
 *     BadValue  - invalid swap action is specified
 *     BadWindow - a window in request is not valid
 *     Success
 *
 *****************************************************************************/

static int
SProcDbeSwapBuffers(ClientPtr client)
{
    REQUEST(xDbeSwapBuffersReq);
    unsigned int i;
    xDbeSwapInfo *pSwapInfo;

    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xDbeSwapBuffersReq);

    swapl(&stuff->n);
    if (stuff->n > UINT32_MAX / sizeof(DbeSwapInfoRec))
        return BadAlloc;
    REQUEST_FIXED_SIZE(xDbeSwapBuffersReq, stuff->n * sizeof(xDbeSwapInfo));

    if (stuff->n != 0) {
        pSwapInfo = (xDbeSwapInfo *) stuff + 1;

        /* The swap info following the fix part of this request is a window(32)
         * followed by a 1 byte swap action and then 3 pad bytes.  We only need
         * to swap the window information.
         */
        for (i = 0; i < stuff->n; i++) {
            swapl(&pSwapInfo->window);
        }
    }

    return (ProcDbeSwapBuffers(client));

}                               /* SProcDbeSwapBuffers() */

/******************************************************************************
 *
 * DBE DIX Procedure: SProcDbeGetVisualInfo
 *
 * Description:
 *
 *     This function is for processing a ProcDbeGetVisualInfo request on a
 *     swapped server.  This request returns information about which visuals
 *     support double buffering.
 *
 * Return Values:
 *
 *     BadDrawable - value in screen specifiers is not a valid drawable
 *     Success
 *
 *****************************************************************************/

static int
SProcDbeGetVisualInfo(ClientPtr client)
{
    REQUEST(xDbeGetVisualInfoReq);

    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xDbeGetVisualInfoReq);

    swapl(&stuff->n);
    SwapRestL(stuff);

    return (ProcDbeGetVisualInfo(client));

}                               /* SProcDbeGetVisualInfo() */

/******************************************************************************
 *
 * DBE DIX Procedure: SProcDbeGetbackBufferAttributes
 *
 * Description:
 *
 *     This function is for processing a ProcDbeGetbackBufferAttributes
 *     request on a swapped server.  This request returns information about a
 *     back buffer.
 *
 * Return Values:
 *
 *     Success
 *
 *****************************************************************************/

static int
SProcDbeGetBackBufferAttributes(ClientPtr client)
{
    REQUEST(xDbeGetBackBufferAttributesReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDbeGetBackBufferAttributesReq);

    swapl(&stuff->buffer);

    return (ProcDbeGetBackBufferAttributes(client));

}                               /* SProcDbeGetBackBufferAttributes() */

/******************************************************************************
 *
 * DBE DIX Procedure: SProcDbeDispatch
 *
 * Description:
 *
 *     This function dispatches DBE requests on a swapped server.
 *
 *****************************************************************************/

static int
SProcDbeDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_DbeGetVersion:
        return (SProcDbeGetVersion(client));

    case X_DbeAllocateBackBufferName:
        return (SProcDbeAllocateBackBufferName(client));

    case X_DbeDeallocateBackBufferName:
        return (SProcDbeDeallocateBackBufferName(client));

    case X_DbeSwapBuffers:
        return (SProcDbeSwapBuffers(client));

    case X_DbeBeginIdiom:
        return Success;

    case X_DbeEndIdiom:
        return Success;

    case X_DbeGetVisualInfo:
        return (SProcDbeGetVisualInfo(client));

    case X_DbeGetBackBufferAttributes:
        return (SProcDbeGetBackBufferAttributes(client));

    default:
        return BadRequest;
    }

}                               /* SProcDbeDispatch() */

/******************************************************************************
 *
 * DBE DIX Procedure: DbeSetupBackgroundPainter
 *
 * Description:
 *
 *     This function sets up pGC to clear pixmaps.
 *
 * Return Values:
 *
 *     TRUE  - setup was successful
 *     FALSE - the window's background state is NONE
 *
 *****************************************************************************/

static Bool
DbeSetupBackgroundPainter(WindowPtr pWin, GCPtr pGC)
{
    ChangeGCVal gcvalues[4];
    int ts_x_origin, ts_y_origin;
    PixUnion background;
    int backgroundState;
    Mask gcmask;

    /* First take care of any ParentRelative stuff by altering the
     * tile/stipple origin to match the coordinates of the upper-left
     * corner of the first ancestor without a ParentRelative background.
     * This coordinate is, of course, negative.
     */
    ts_x_origin = ts_y_origin = 0;
    while (pWin->backgroundState == ParentRelative) {
        ts_x_origin -= pWin->origin.x;
        ts_y_origin -= pWin->origin.y;

        pWin = pWin->parent;
    }
    backgroundState = pWin->backgroundState;
    background = pWin->background;

    switch (backgroundState) {
    case BackgroundPixel:
        gcvalues[0].val = background.pixel;
        gcvalues[1].val = FillSolid;
        gcmask = GCForeground | GCFillStyle;
        break;

    case BackgroundPixmap:
        gcvalues[0].val = FillTiled;
        gcvalues[1].ptr = background.pixmap;
        gcvalues[2].val = ts_x_origin;
        gcvalues[3].val = ts_y_origin;
        gcmask = GCFillStyle | GCTile | GCTileStipXOrigin | GCTileStipYOrigin;
        break;

    default:
        /* pWin->backgroundState == None */
        return FALSE;
    }

    return ChangeGC(NullClient, pGC, gcmask, gcvalues) == 0;
}                               /* DbeSetupBackgroundPainter() */

/******************************************************************************
 *
 * DBE DIX Procedure: DbeDrawableDelete
 *
 * Description:
 *
 *     This is the resource delete function for dbeDrawableResType.
 *     It is registered when the drawable resource type is created in
 *     DbeExtensionInit().
 *
 *     To make resource deletion simple, we do not do anything in this function
 *     and leave all resource deleteion to DbeWindowPrivDelete(), which will
 *     eventually be called or already has been called.  Deletion functions are
 *     not guaranteed to be called in any particular order.
 *
 *****************************************************************************/
static int
DbeDrawableDelete(void *pDrawable, XID id)
{
    return Success;

}                               /* DbeDrawableDelete() */

/******************************************************************************
 *
 * DBE DIX Procedure: DbeWindowPrivDelete
 *
 * Description:
 *
 *     This is the resource delete function for dbeWindowPrivResType.
 *     It is registered when the drawable resource type is created in
 *     DbeExtensionInit().
 *
 *****************************************************************************/
static int
DbeWindowPrivDelete(void *pDbeWinPriv, XID id)
{
    DbeScreenPrivPtr pDbeScreenPriv;
    DbeWindowPrivPtr pDbeWindowPriv = (DbeWindowPrivPtr) pDbeWinPriv;
    int i;

    /*
     **************************************************************************
     ** Remove the buffer ID from the ID array.
     **************************************************************************
     */

    /* Find the ID in the ID array. */
    i = 0;
    while ((i < pDbeWindowPriv->nBufferIDs) && (pDbeWindowPriv->IDs[i] != id)) {
        i++;
    }

    if (i == pDbeWindowPriv->nBufferIDs) {
        /* We did not find the ID in the array.  We should never get here. */
        return BadValue;
    }

    /* Remove the ID from the array. */

    if (i < (pDbeWindowPriv->nBufferIDs - 1)) {
        /* Compress the buffer ID array, overwriting the ID in the process. */
        memmove(&pDbeWindowPriv->IDs[i], &pDbeWindowPriv->IDs[i + 1],
                (pDbeWindowPriv->nBufferIDs - i - 1) * sizeof(XID));
    }
    else {
        /* We are removing the last ID in the array, in which case, the
         * assignement below is all that we need to do.
         */
    }
    pDbeWindowPriv->IDs[pDbeWindowPriv->nBufferIDs - 1] = DBE_FREE_ID_ELEMENT;

    pDbeWindowPriv->nBufferIDs--;

    /* If an extended array was allocated, then check to see if the remaining
     * buffer IDs will fit in the static array.
     */

    if ((pDbeWindowPriv->maxAvailableIDs > DBE_INIT_MAX_IDS) &&
        (pDbeWindowPriv->nBufferIDs == DBE_INIT_MAX_IDS)) {
        /* Copy the IDs back into the static array. */
        memcpy(pDbeWindowPriv->initIDs, pDbeWindowPriv->IDs,
               DBE_INIT_MAX_IDS * sizeof(XID));

        /* Free the extended array; use the static array. */
        free(pDbeWindowPriv->IDs);
        pDbeWindowPriv->IDs = pDbeWindowPriv->initIDs;
        pDbeWindowPriv->maxAvailableIDs = DBE_INIT_MAX_IDS;
    }

    /*
     **************************************************************************
     ** Perform DDX level tasks.
     **************************************************************************
     */

    pDbeScreenPriv = DBE_SCREEN_PRIV_FROM_WINDOW_PRIV((DbeWindowPrivPtr)
                                                      pDbeWindowPriv);
    (*pDbeScreenPriv->WinPrivDelete) ((DbeWindowPrivPtr) pDbeWindowPriv, id);

    /*
     **************************************************************************
     ** Perform miscellaneous tasks if this is the last buffer associated
     ** with the window.
     **************************************************************************
     */

    if (pDbeWindowPriv->nBufferIDs == 0) {
        /* Reset the DBE window priv pointer. */
        dixSetPrivate(&pDbeWindowPriv->pWindow->devPrivates, dbeWindowPrivKey,
                      NULL);

        /* We are done with the window priv. */
        free(pDbeWindowPriv);
    }

    return Success;

}                               /* DbeWindowPrivDelete() */

/******************************************************************************
 *
 * DBE DIX Procedure: DbeResetProc
 *
 * Description:
 *
 *     This routine is called at the end of every server generation.
 *     It deallocates any memory reserved for the extension and performs any
 *     other tasks related to shutting down the extension.
 *
 *****************************************************************************/
static void
DbeResetProc(ExtensionEntry * extEntry)
{
    int i;
    ScreenPtr pScreen;
    DbeScreenPrivPtr pDbeScreenPriv;

    for (i = 0; i < screenInfo.numScreens; i++) {
        pScreen = screenInfo.screens[i];
        pDbeScreenPriv = DBE_SCREEN_PRIV(pScreen);

        if (pDbeScreenPriv) {
            /* Unwrap DestroyWindow, which was wrapped in DbeExtensionInit(). */
            pScreen->DestroyWindow = pDbeScreenPriv->DestroyWindow;
            pScreen->PositionWindow = pDbeScreenPriv->PositionWindow;
            free(pDbeScreenPriv);
        }
    }
}                               /* DbeResetProc() */

/******************************************************************************
 *
 * DBE DIX Procedure: DbeDestroyWindow
 *
 * Description:
 *
 *     This is the wrapper for pScreen->DestroyWindow.
 *     This function frees buffer resources for a window before it is
 *     destroyed.
 *
 *****************************************************************************/

static Bool
DbeDestroyWindow(WindowPtr pWin)
{
    DbeScreenPrivPtr pDbeScreenPriv;
    DbeWindowPrivPtr pDbeWindowPriv;
    ScreenPtr pScreen;
    Bool ret;

    /*
     **************************************************************************
     ** 1. Unwrap the member routine.
     **************************************************************************
     */

    pScreen = pWin->drawable.pScreen;
    pDbeScreenPriv = DBE_SCREEN_PRIV(pScreen);
    pScreen->DestroyWindow = pDbeScreenPriv->DestroyWindow;

    /*
     **************************************************************************
     ** 2. Do any work necessary before the member routine is called.
     **
     **    Call the window priv delete function for all buffer IDs associated
     **    with this window.
     **************************************************************************
     */

    if ((pDbeWindowPriv = DBE_WINDOW_PRIV(pWin))) {
        while (pDbeWindowPriv) {
            /* *DbeWinPrivDelete() will free the window private and set it to
             * NULL if there are no more buffer IDs associated with this
             * window.
             */
            FreeResource(pDbeWindowPriv->IDs[0], RT_NONE);
            pDbeWindowPriv = DBE_WINDOW_PRIV(pWin);
        }
    }

    /*
     **************************************************************************
     ** 3. Call the member routine, saving its result if necessary.
     **************************************************************************
     */

    ret = (*pScreen->DestroyWindow) (pWin);

    /*
     **************************************************************************
     ** 4. Rewrap the member routine, restoring the wrapper value first in case
     **    the wrapper (or something that it wrapped) change this value.
     **************************************************************************
     */

    pDbeScreenPriv->DestroyWindow = pScreen->DestroyWindow;
    pScreen->DestroyWindow = DbeDestroyWindow;

    /*
     **************************************************************************
     ** 5. Do any work necessary after the member routine has been called.
     **
     **    In this case we do not need to do anything.
     **************************************************************************
     */

    return ret;

}                               /* DbeDestroyWindow() */

/******************************************************************************
 *
 * DBE DIX Procedure: DbeExtensionInit
 *
 * Description:
 *
 *     Called from InitExtensions in main()
 *
 *****************************************************************************/

void
DbeExtensionInit(void)
{
    ExtensionEntry *extEntry;
    register int i, j;
    ScreenPtr pScreen = NULL;
    DbeScreenPrivPtr pDbeScreenPriv;
    int nStubbedScreens = 0;
    Bool ddxInitSuccess;

#ifdef PANORAMIX
    if (!noPanoramiXExtension)
        return;
#endif

    /* Create the resource types. */
    dbeDrawableResType =
        CreateNewResourceType(DbeDrawableDelete, "dbeDrawable");
    if (!dbeDrawableResType)
        return;
    dbeDrawableResType |= RC_DRAWABLE;

    dbeWindowPrivResType =
        CreateNewResourceType(DbeWindowPrivDelete, "dbeWindow");
    if (!dbeWindowPrivResType)
        return;

    if (!dixRegisterPrivateKey(&dbeScreenPrivKeyRec, PRIVATE_SCREEN, 0))
        return;

    if (!dixRegisterPrivateKey(&dbeWindowPrivKeyRec, PRIVATE_WINDOW, 0))
        return;

    for (i = 0; i < screenInfo.numScreens; i++) {
        /* For each screen, set up DBE screen privates and init DIX and DDX
         * interface.
         */

        pScreen = screenInfo.screens[i];

        if (!(pDbeScreenPriv = malloc(sizeof(DbeScreenPrivRec)))) {
            /* If we can not alloc a window or screen private,
             * then free any privates that we already alloc'ed and return
             */

            for (j = 0; j < i; j++) {
                free(dixLookupPrivate(&screenInfo.screens[j]->devPrivates,
                                      dbeScreenPrivKey));
                dixSetPrivate(&screenInfo.screens[j]->devPrivates,
                              dbeScreenPrivKey, NULL);
            }
            return;
        }

        dixSetPrivate(&pScreen->devPrivates, dbeScreenPrivKey, pDbeScreenPriv);

        {
            /* We don't have DDX support for DBE anymore */

#ifndef DISABLE_MI_DBE_BY_DEFAULT
            /* Setup DIX. */
            pDbeScreenPriv->SetupBackgroundPainter = DbeSetupBackgroundPainter;

            /* Setup DDX. */
            ddxInitSuccess = miDbeInit(pScreen, pDbeScreenPriv);

            /* DDX DBE initialization may have the side affect of
             * reallocating pDbeScreenPriv, so we need to update it.
             */
            pDbeScreenPriv = DBE_SCREEN_PRIV(pScreen);

            if (ddxInitSuccess) {
                /* Wrap DestroyWindow.  The DDX initialization function
                 * already wrapped PositionWindow for us.
                 */

                pDbeScreenPriv->DestroyWindow = pScreen->DestroyWindow;
                pScreen->DestroyWindow = DbeDestroyWindow;
            }
            else {
                /* DDX initialization failed.  Stub the screen. */
                DbeStubScreen(pDbeScreenPriv, &nStubbedScreens);
            }
#else
            DbeStubScreen(pDbeScreenPriv, &nStubbedScreens);
#endif

        }

    }                           /* for (i = 0; i < screenInfo.numScreens; i++) */

    if (nStubbedScreens == screenInfo.numScreens) {
        /* All screens stubbed.  Clean up and return. */

        for (i = 0; i < screenInfo.numScreens; i++) {
            free(dixLookupPrivate(&screenInfo.screens[i]->devPrivates,
                                  dbeScreenPrivKey));
            dixSetPrivate(&pScreen->devPrivates, dbeScreenPrivKey, NULL);
        }
        return;
    }

    /* Now add the extension. */
    extEntry = AddExtension(DBE_PROTOCOL_NAME, DbeNumberEvents,
                            DbeNumberErrors, ProcDbeDispatch, SProcDbeDispatch,
                            DbeResetProc, StandardMinorOpcode);

    dbeErrorBase = extEntry->errorBase;
    SetResourceTypeErrorValue(dbeWindowPrivResType,
                              dbeErrorBase + DbeBadBuffer);
    SetResourceTypeErrorValue(dbeDrawableResType, dbeErrorBase + DbeBadBuffer);

}                               /* DbeExtensionInit() */
@


1.17
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d290 4
a293 5
            pDbeWindowPriv->IDs = (XID *) realloc(pIDs,
                                                  (pDbeWindowPriv->
                                                   maxAvailableIDs +
                                                   DBE_INCR_MAX_IDS) *
                                                  sizeof(XID));
d472 1
a472 1
    swapInfo = (DbeSwapInfoPtr) malloc(nStuff * sizeof(DbeSwapInfoRec));
d582 1
a582 2
        if (!(pDrawables = (DrawablePtr *) malloc(stuff->n *
                                                  sizeof(DrawablePtr)))) {
@


1.16
log
@Update to xorg-server  1.16.3.

Most of the 1.16.2->1.16.3 changes are the security patches that
where already there. This adds some extra fixes plus a few unrelated
bug fixes.
@
text
@d2 1
a2 1
 * 
d12 1
a12 1
 * 
d15 1
a15 1
 * 
d23 1
a23 1
 * 
d28 1
a28 1
 * 
d155 1
a155 1
 *                   DBEGetVisualInfo; 
d842 1
a842 1
 *                   DBEGetVisualInfo; 
d1068 1
a1068 1
 * 
@


1.15
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d455 1
d531 2
a532 1
    while (nStuff > 0) {
d534 1
a534 1
        error = (*pDbeScreenPriv->SwapBuffers) (client, &nStuff, swapInfo);
@


1.14
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d453 2
a454 2
    register int i, j;
    int nStuff;
d460 1
d466 1
d919 1
a919 1
    register int i;
d926 3
@


1.13
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d325 1
a325 1
                         (pointer) pDbeWindowPriv)) {
d381 1
a381 1
    pointer val;
d386 1
a386 1
    rc = dixLookupResourceByType((pointer *) &pDbeWindowPriv, stuff->buffer,
d729 1
a729 1
    rc = dixLookupResourceByType((pointer *) &pDbeWindowPriv, stuff->buffer,
d1128 1
a1128 1
DbeDrawableDelete(pointer pDrawable, XID id)
d1146 1
a1146 1
DbeWindowPrivDelete(pointer pDbeWinPriv, XID id)
@


1.13.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d453 2
a454 2
    unsigned int i, j;
    unsigned int nStuff;
a459 1
        REQUEST_SIZE_MATCH(xDbeSwapBuffersReq);
a464 1
    REQUEST_FIXED_SIZE(xDbeSwapBuffersReq, nStuff * sizeof(xDbeSwapInfo));
d917 1
a917 1
    unsigned int i;
a923 3
    if (stuff->n > UINT32_MAX / sizeof(DbeSwapInfoRec))
        return BadAlloc;
    REQUEST_FIXED_SIZE(xDbeSwapBuffersReq, stuff->n * sizeof(xDbeSwapInfo));
@


1.12
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a92 2
    pDbeScreenPriv->BeginIdiom = NULL;
    pDbeScreenPriv->EndIdiom = NULL;
a93 1
    pDbeScreenPriv->ResetProc = NULL;
d232 1
a232 2
        pDbeWindowPriv =
            dixAllocateObjectWithPrivates(DbeWindowPrivRec, PRIVATE_DBE_WINDOW);
a543 38
 * DBE DIX Procedure: ProcDbeBeginIdiom
 *
 * Description:
 *
 *     This function is for processing a DbeBeginIdiom request.
 *     This request informs the server that a complex swap will immediately
 *     follow this request.
 *
 * Return Values:
 *
 *     Success
 *
 *****************************************************************************/

static int
ProcDbeBeginIdiom(ClientPtr client)
{
    /* REQUEST(xDbeBeginIdiomReq); */
    DbeScreenPrivPtr pDbeScreenPriv;
    register int i;

    REQUEST_SIZE_MATCH(xDbeBeginIdiomReq);

    for (i = 0; i < screenInfo.numScreens; i++) {
        pDbeScreenPriv = DBE_SCREEN_PRIV(screenInfo.screens[i]);

        /* Call the DDX begin idiom procedure if there is one. */
        if (pDbeScreenPriv->BeginIdiom) {
            (*pDbeScreenPriv->BeginIdiom) (client);
        }
    }

    return Success;

}                               /* ProcDbeBeginIdiom() */

/******************************************************************************
 *
d779 1
a779 1
        return (ProcDbeBeginIdiom(client));
a942 26
 * DBE DIX Procedure: SProcDbeBeginIdiom
 *
 * Description:
 *
 *     This function is for processing a DbeBeginIdiom request on a swapped
 *     server.  This request informs the server that a complex swap will
 *     immediately follow this request.
 *
 * Return Values:
 *
 *     Success
 *
 *****************************************************************************/

static int
SProcDbeBeginIdiom(ClientPtr client)
{
    REQUEST(xDbeBeginIdiomReq);

    swaps(&stuff->length);
    return (ProcDbeBeginIdiom(client));

}                               /* SProcDbeBeginIdiom() */

/******************************************************************************
 *
d1032 1
a1032 1
        return (SProcDbeBeginIdiom(client));
d1224 1
a1224 1
        dixFreeObjectWithPrivates(pDbeWindowPriv, PRIVATE_DBE_WINDOW);
d1256 1
a1256 4

            if (pDbeScreenPriv->ResetProc)
                (*pDbeScreenPriv->ResetProc) (pScreen);

@


1.12.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d457 2
a458 2
    unsigned int i, j;
    unsigned int nStuff;
a463 1
        REQUEST_SIZE_MATCH(xDbeSwapBuffersReq);
a468 1
    REQUEST_FIXED_SIZE(xDbeSwapBuffersReq, nStuff * sizeof(xDbeSwapInfo));
d959 1
a959 1
    unsigned int i;
a965 3
    if (stuff->n > UINT32_MAX / sizeof(DbeSwapInfoRec))
        return BadAlloc;
    REQUEST_FIXED_SIZE(xDbeSwapBuffersReq, stuff->n * sizeof(xDbeSwapInfo));
@


1.11
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d45 1
d122 7
a128 1
    xDbeGetVersionReply rep;
a131 6
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = DBE_MAJOR_VERSION;
    rep.minorVersion = DBE_MINOR_VERSION;

d136 1
a136 1
    WriteToClient(client, sizeof(xDbeGetVersionReply), (char *) &rep);
d671 6
a676 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = bytes_to_int32(length);
    rep.m = count;
d685 1
a685 1
    WriteToClient(client, sizeof(xDbeGetVisualInfoReply), (char *) &rep);
d699 1
a699 1
        WriteToClient(client, sizeof(CARD32), (char *) &data32);
d723 1
a723 2
            WriteToClient(client, 2 * sizeof(CARD32),
                          (char *) &visInfo.visualID);
d761 5
a765 1
    xDbeGetBackBufferAttributesReply rep;
a780 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;

d787 1
a787 2
    WriteToClient(client, sizeof(xDbeGetBackBufferAttributesReply),
                  (char *) &rep);
@


1.10
log
@Update to xserver 1.11.2
@
text
@a32 1

a39 1
#if HAVE_STDINT_H
a40 4
#elif !defined(UINT32_MAX)
#define UINT32_MAX 0xffffffffU
#endif

d59 2
a60 2
RESTYPE	dbeDrawableResType;
RESTYPE	dbeWindowPrivResType;
d63 1
a63 1
static int	dbeErrorBase;
d89 1
a89 1
    pDbeScreenPriv->GetVisualInfo       = NULL;
d91 5
a95 5
    pDbeScreenPriv->SwapBuffers         = NULL;
    pDbeScreenPriv->BeginIdiom          = NULL;
    pDbeScreenPriv->EndIdiom            = NULL;
    pDbeScreenPriv->WinPrivDelete       = NULL;
    pDbeScreenPriv->ResetProc           = NULL;
d99 1
a99 3
} /* DbeStubScreen() */


d121 1
a121 3
    xDbeGetVersionReply	rep;
    register int	n;

d125 2
a126 2
    rep.type           = X_Reply;
    rep.length         = 0;
d128 2
a129 2
    rep.majorVersion   = DBE_MAJOR_VERSION;
    rep.minorVersion   = DBE_MINOR_VERSION;
d131 2
a132 3
    if (client->swapped)
    {
        swaps(&rep.sequenceNumber, n);
d135 1
a135 1
    WriteToClient(client, sizeof(xDbeGetVersionReply), (char *)&rep);
d139 1
a139 2
} /* ProcDbeGetVersion() */

d168 10
a177 11
    WindowPtr			pWin;
    DbeScreenPrivPtr		pDbeScreenPriv;
    DbeWindowPrivPtr		pDbeWindowPriv;
    XdbeScreenVisualInfo	scrVisInfo;
    register int		i;
    Bool			visualMatched = FALSE;
    xDbeSwapAction		swapAction;
    VisualID			visual;
    int				status;
    int				add_index;

d184 1
a184 1
	return status;
d187 2
a188 3
    if (pWin->drawable.class != InputOutput)
    {
	return BadMatch;
d192 2
a193 2
    swapAction = stuff->swapAction;	/* use local var for performance. */
    if ((swapAction != XdbeUndefined ) &&
d195 1
a195 3
        (swapAction != XdbeUntouched ) &&
        (swapAction != XdbeCopied    ))
    {
d207 1
a207 1
	return BadMatch; /* screen doesn't support double buffering */
d209 1
a209 2
    if (!(*pDbeScreenPriv->GetVisualInfo)(pWin->drawable.pScreen, &scrVisInfo))
    {
d216 4
a219 6
    for (i = 0; (i < scrVisInfo.count) && !visualMatched; i++)
    {
        if (scrVisInfo.visinfo[i].visual == visual)
	{
	    visualMatched = TRUE;
	}
d225 2
a226 3
    if (!visualMatched)
    {
	return BadMatch;
d229 1
a229 2
    if ((pDbeWindowPriv = DBE_WINDOW_PRIV(pWin)) == NULL)
    {
d234 3
a236 2
        pDbeWindowPriv = dixAllocateObjectWithPrivates(DbeWindowPrivRec, PRIVATE_DBE_WINDOW);
	if (!pDbeWindowPriv)
d240 6
a245 6
        pDbeWindowPriv->pWindow      = pWin;
        pDbeWindowPriv->width        = pWin->drawable.width;
        pDbeWindowPriv->height       = pWin->drawable.height;
        pDbeWindowPriv->x            = pWin->drawable.x;
        pDbeWindowPriv->y            = pWin->drawable.y;
        pDbeWindowPriv->nBufferIDs   = 0;
d250 1
a250 1
        /* Initialize the buffer ID list. */ 
d255 1
a255 2
        for (i = 0; i < DBE_INIT_MAX_IDS; i++)
        {
d262 1
a262 1
    } /* if -- There is no buffer associated with the window. */
d264 1
a264 2
    else
    {
d271 2
a272 4
        for (i = 0; i < pDbeWindowPriv->maxAvailableIDs; i++)
        {
            if (pDbeWindowPriv->IDs[i] == DBE_FREE_ID_ELEMENT)
            {
d277 2
a278 3
 
        if (i == pDbeWindowPriv->maxAvailableIDs)
        {
d280 1
a280 1
            XID	*pIDs;
d283 1
a283 2
            if (pDbeWindowPriv->maxAvailableIDs == DBE_INIT_MAX_IDS)
            {
d287 1
a287 2
            else
            {
d293 6
a298 4
            pDbeWindowPriv->IDs = (XID *)realloc(pIDs,
                (pDbeWindowPriv->maxAvailableIDs+DBE_INCR_MAX_IDS)*sizeof(XID));
            if (!pDbeWindowPriv->IDs)
            {
d305 1
a305 2
            if (pDbeWindowPriv->maxAvailableIDs == DBE_INIT_MAX_IDS)
            {
d317 1
a317 3
	add_index = i;

    } /* else -- A buffer is already associated with the window. */
d319 1
d322 2
a323 2
    status = (*pDbeScreenPriv->AllocBackBufferName)(pWin, stuff->buffer,
                                                    stuff->swapAction);
d325 2
a326 3
    if (status == Success)
    {
	pDbeWindowPriv->IDs[add_index] = stuff->buffer;
d328 1
a328 2
                         (pointer)pDbeWindowPriv))
	{
d336 2
a337 1
    } else {
d354 1
a354 1
out_free:
d359 1
a359 2
} /* ProcDbeAllocateBackBufferName() */

d382 2
a383 2
    DbeWindowPrivPtr	pDbeWindowPriv;
    int			rc, i;
a385 1

d389 3
a391 3
    rc = dixLookupResourceByType((pointer *)&pDbeWindowPriv, stuff->buffer,
				 dbeWindowPrivResType, client,
				 DixDestroyAccess);
d393 1
a393 1
	return rc;
d396 1
a396 1
				 client, DixDestroyAccess);
d398 1
a398 1
	return rc;
d405 1
a405 2
    for (i = 0; i < pDbeWindowPriv->nBufferIDs; i++)
    {
d407 1
a407 2
        if (pDbeWindowPriv->IDs[i] == stuff->buffer)
        {
d412 1
a412 2
    if (i == pDbeWindowPriv->nBufferIDs)
    {
d422 1
a422 2
} /* ProcDbeDeallocateBackBufferName() */

d451 7
a457 8
    WindowPtr		pWin;
    DbeScreenPrivPtr	pDbeScreenPriv;
    DbeSwapInfoPtr	swapInfo;
    xDbeSwapInfo	*dbeSwapInfo;
    int			error;
    register int	i, j;
    int			nStuff;

d460 1
a460 1
    nStuff = stuff->n;	/* use local variable for performance. */
d462 1
a462 2
    if (nStuff == 0)
    {
d467 1
a467 1
	    return BadAlloc;
d470 1
a470 1
    dbeSwapInfo = (xDbeSwapInfo *)&stuff[1];
d472 3
a474 4
    /* Allocate array to record swap information. */ 
    swapInfo = (DbeSwapInfoPtr)malloc(nStuff * sizeof(DbeSwapInfoRec));
    if (swapInfo == NULL)
    {
d478 1
a478 3

    for (i = 0; i < nStuff; i++)
    {
d482 3
a484 3
	error = dixLookupWindow(&pWin, dbeSwapInfo[i].window, client,
				DixWriteAccess);
	if (error != Success) {
d486 1
a486 1
	    return error;
d490 1
a490 2
        if (DBE_WINDOW_PRIV(pWin) == NULL)
        {
d496 2
a497 4
        for (j = i + 1; j < nStuff; j++)
        {
            if (dbeSwapInfo[i].window == dbeSwapInfo[j].window)
            {
d500 1
a500 1
	    }
d504 1
a504 1
        if ((dbeSwapInfo[i].swapAction != XdbeUndefined ) &&
d506 2
a507 3
            (dbeSwapInfo[i].swapAction != XdbeUntouched ) &&
            (dbeSwapInfo[i].swapAction != XdbeCopied    ))
        {
d513 2
a514 4
        swapInfo[i].pWindow    = pWin;     
        swapInfo[i].swapAction = dbeSwapInfo[i].swapAction;     

    } /* for (i = 0; i < nStuff; i++) */
d516 1
d531 1
a531 2
    while (nStuff > 0)
    {
d533 2
a534 3
        error = (*pDbeScreenPriv->SwapBuffers)(client, &nStuff, swapInfo);
        if (error != Success)
        {
d539 1
a539 1
    
d543 1
a543 2
} /* ProcDbeSwapBuffers() */

d565 2
a566 3
    DbeScreenPrivPtr	pDbeScreenPriv;
    register int	i;

d570 1
a570 2
    for (i = 0; i < screenInfo.numScreens; i++)
    {
d574 2
a575 3
        if (pDbeScreenPriv->BeginIdiom)
        {
           (*pDbeScreenPriv->BeginIdiom)(client);
d581 1
a581 2
} /* ProcDbeBeginIdiom() */

d604 9
a612 10
    DbeScreenPrivPtr		pDbeScreenPriv;
    xDbeGetVisualInfoReply	rep;
    Drawable			*drawables;
    DrawablePtr			*pDrawables = NULL;
    register int		i, j, n, rc;
    register int		count;  /* number of visual infos in reply */
    register int		length; /* length of reply */
    ScreenPtr			pScreen;
    XdbeScreenVisualInfo	*pScrVisInfo;

d617 1
a617 1
	    return BadAlloc;
d619 3
a621 5
    if (stuff->n != 0)
    {
        if (!(pDrawables = (DrawablePtr *)malloc(stuff->n *
                                                 sizeof(DrawablePtr))))
        {
d625 1
a625 1
        drawables = (Drawable *)&stuff[1];
d627 4
a630 5
        for (i = 0; i < stuff->n; i++)
        {
	    rc = dixLookupDrawable(pDrawables+i, drawables[i], client, 0,
				   DixGetAttrAccess);
	    if (rc != Success) {
d638 1
a638 2
    if (!(pScrVisInfo = calloc(count, sizeof(XdbeScreenVisualInfo))))
    {
d646 1
a646 2
    for (i = 0; i < count; i++)
    {
d648 1
a648 1
                                    pDrawables[i]->pScreen;
d651 1
a651 1
	rc = XaceHook(XACE_SCREEN_ACCESS, client, pScreen, DixGetAttrAccess);
d655 1
a655 2
        if (!(*pDbeScreenPriv->GetVisualInfo)(pScreen, &pScrVisInfo[i]))
        {
d659 1
a659 1
            /* Free visinfos that we allocated for previous screen infos.*/
d670 1
a670 1
    rep.type           = X_Reply;
d672 2
a673 2
    rep.length         = bytes_to_int32(length);
    rep.m              = count;
d675 4
a678 5
    if (client->swapped)
    {
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.m, n);
d682 1
a682 1
    WriteToClient(client, sizeof(xDbeGetVisualInfoReply), (char *)&rep);
d684 2
a685 3
    for (i = 0; i < count; i++)
    {
        CARD32	data32;
d690 1
a690 1
        data32 = (CARD32)pScrVisInfo[i].count;
d692 2
a693 3
        if (client->swapped)
        {
            swapl(&data32, n);
d696 1
a696 1
        WriteToClient(client, sizeof(CARD32), (char *)&data32);
d699 2
a700 3
        for (j = 0; j < pScrVisInfo[i].count; j++)
        {
            xDbeVisInfo		visInfo;
d707 2
a708 2
            visInfo.visualID  = (CARD32)pScrVisInfo[i].visinfo[j].visual;
            visInfo.depth     = (CARD8) pScrVisInfo[i].visinfo[j].depth;
d711 2
a712 3
            if (client->swapped)
            {
                swapl(&visInfo.visualID, n);
d720 2
a721 1
            WriteToClient(client, 2*sizeof(CARD32), (char *)&visInfo.visualID);
d727 1
a727 1
  freeScrVisInfo:
d729 1
a729 2
    for (i = 0; i < count; i++)
    {
d738 1
a738 2
} /* ProcDbeGetVisualInfo() */

d759 3
a761 4
    xDbeGetBackBufferAttributesReply	rep;
    DbeWindowPrivPtr			pDbeWindowPriv;
    int					rc, n;

d765 4
a768 5
    rc = dixLookupResourceByType((pointer *)&pDbeWindowPriv, stuff->buffer,
				 dbeWindowPrivResType, client,
				 DixGetAttrAccess);
    if (rc == Success)
    {
d771 1
a771 2
    else
    {
d774 2
a775 2
        
    rep.type           = X_Reply;
d777 6
a782 7
    rep.length         = 0;
    
    if (client->swapped)
    {
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.attributes, n);
d786 1
a786 1
                  (char *)&rep);
d789 1
a789 2
} /* ProcDbeGetbackBufferAttributes() */

d806 3
d810 2
a811 4
    switch (stuff->data)
    {
        case X_DbeGetVersion:
            return(ProcDbeGetVersion(client));
d813 2
a814 2
        case X_DbeAllocateBackBufferName:
            return(ProcDbeAllocateBackBufferName(client));
d816 2
a817 2
        case X_DbeDeallocateBackBufferName:
            return(ProcDbeDeallocateBackBufferName(client));
d819 2
a820 2
        case X_DbeSwapBuffers:
            return(ProcDbeSwapBuffers(client));
d822 2
a823 5
        case X_DbeBeginIdiom:
            return(ProcDbeBeginIdiom(client));

        case X_DbeEndIdiom:
            return Success;
d825 2
a826 2
        case X_DbeGetVisualInfo:
            return(ProcDbeGetVisualInfo(client));
d828 2
a829 2
        case X_DbeGetBackBufferAttributes:
            return(ProcDbeGetBackBufferAttributes(client));
d831 2
a832 2
        default:
            return BadRequest;
d835 1
a835 2
} /* ProcDbeDispatch() */

a856 5
    register int	n;


    swaps(&stuff->length, n);
    return(ProcDbeGetVersion(client));
d858 2
a859 1
} /* SProcDbeGetVersion() */
d861 1
a889 1
    register int	n;
d891 1
a891 1
    swaps(&stuff->length, n);
d894 2
a895 2
    swapl(&stuff->window, n);
    swapl(&stuff->buffer, n);
d898 1
a898 3
    return(ProcDbeAllocateBackBufferName(client));

} /* SProcDbeAllocateBackBufferName() */
d900 1
d922 1
a922 3
    REQUEST (xDbeDeallocateBackBufferNameReq);
    register int	n;

d924 1
a924 1
    swaps(&stuff->length, n);
d927 1
a927 1
    swapl(&stuff->buffer, n);
d929 1
a929 3
    return(ProcDbeDeallocateBackBufferName(client));

} /* SProcDbeDeallocateBackBufferName() */
d931 1
d958 2
a959 3
    register int	i, n;
    xDbeSwapInfo	*pSwapInfo;

d961 1
a961 1
    swaps(&stuff->length, n);
d964 1
a964 1
    swapl(&stuff->n, n);
d966 2
a967 3
    if (stuff->n != 0)
    { 
        pSwapInfo = (xDbeSwapInfo *)stuff+1;
d973 2
a974 3
        for (i = 0; i < stuff->n; i++)
        {
            swapl(&pSwapInfo->window, n);
d978 1
a978 3
    return(ProcDbeSwapBuffers(client));

} /* SProcDbeSwapBuffers() */
d980 1
a1001 4
    register int	n;

    swaps(&stuff->length, n);
    return(ProcDbeBeginIdiom(client));
d1003 2
a1004 1
} /* SProcDbeBeginIdiom() */
d1006 1
a1028 2
    register int	n;

d1030 1
a1030 1
    swaps(&stuff->length, n);
d1033 1
a1033 1
    swapl(&stuff->n, n);
d1036 1
a1036 3
    return(ProcDbeGetVisualInfo(client));

} /* SProcDbeGetVisualInfo() */
d1038 1
d1059 1
a1059 2
    REQUEST (xDbeGetBackBufferAttributesReq);
    register int	n;
d1061 1
a1061 1
    swaps(&stuff->length, n);
d1064 1
a1064 3
    swapl(&stuff->buffer, n);

    return(ProcDbeGetBackBufferAttributes(client));
d1066 1
a1066 1
} /* SProcDbeGetBackBufferAttributes() */
d1068 1
d1085 3
d1089 2
a1090 4
    switch (stuff->data)
    {
        case X_DbeGetVersion:
            return(SProcDbeGetVersion(client));
d1092 2
a1093 2
        case X_DbeAllocateBackBufferName:
            return(SProcDbeAllocateBackBufferName(client));
d1095 2
a1096 2
        case X_DbeDeallocateBackBufferName:
            return(SProcDbeDeallocateBackBufferName(client));
d1098 2
a1099 2
        case X_DbeSwapBuffers:
            return(SProcDbeSwapBuffers(client));
d1101 2
a1102 5
        case X_DbeBeginIdiom:
            return(SProcDbeBeginIdiom(client));

        case X_DbeEndIdiom:
            return Success;
d1104 2
a1105 2
        case X_DbeGetVisualInfo:
            return(SProcDbeGetVisualInfo(client));
d1107 2
a1108 2
        case X_DbeGetBackBufferAttributes:
            return(SProcDbeGetBackBufferAttributes(client));
d1110 2
a1111 2
        default:
            return BadRequest;
d1114 1
a1114 2
} /* SProcDbeDispatch() */

d1134 5
a1138 6
    ChangeGCVal	gcvalues[4];
    int		ts_x_origin, ts_y_origin;
    PixUnion	background;
    int		backgroundState;
    Mask	gcmask;

d1146 1
a1146 2
    while (pWin->backgroundState == ParentRelative)
    {
d1153 1
a1153 9
    background      = pWin->background;

    switch (backgroundState)
    {
        case BackgroundPixel:
            gcvalues[0].val = background.pixel;
            gcvalues[1].val = FillSolid;
            gcmask = GCForeground|GCFillStyle;
            break;
d1155 18
a1172 11
        case BackgroundPixmap:
            gcvalues[0].val = FillTiled;
            gcvalues[1].ptr = background.pixmap;
            gcvalues[2].val = ts_x_origin;
            gcvalues[3].val = ts_y_origin;
            gcmask = GCFillStyle|GCTile|GCTileStipXOrigin|GCTileStipYOrigin;
            break;

        default:
            /* pWin->backgroundState == None */
            return FALSE;
d1176 1
a1176 2
} /* DbeSetupBackgroundPainter() */

d1199 1
a1199 2
} /* DbeDrawableDelete() */

d1215 3
a1217 4
    DbeScreenPrivPtr	pDbeScreenPriv;
    DbeWindowPrivPtr	pDbeWindowPriv = (DbeWindowPrivPtr)pDbeWinPriv;
    int			i;

d1227 1
a1227 2
    while ((i < pDbeWindowPriv->nBufferIDs) && (pDbeWindowPriv->IDs[i] != id))
    {
d1231 1
a1231 2
    if (i == pDbeWindowPriv->nBufferIDs)
    {
d1238 1
a1238 2
    if (i < (pDbeWindowPriv->nBufferIDs - 1))
    {
d1240 2
a1241 2
        memmove(&pDbeWindowPriv->IDs[i], &pDbeWindowPriv->IDs[i+1],
            (pDbeWindowPriv->nBufferIDs - i - 1) * sizeof(XID));
d1243 1
a1243 2
    else
    {
d1256 2
a1257 3
    if ((pDbeWindowPriv->maxAvailableIDs >  DBE_INIT_MAX_IDS) &&
        (pDbeWindowPriv->nBufferIDs      == DBE_INIT_MAX_IDS))
    {
a1267 1

d1274 3
a1276 4
    pDbeScreenPriv = DBE_SCREEN_PRIV_FROM_WINDOW_PRIV(
                         (DbeWindowPrivPtr)pDbeWindowPriv);
    (*pDbeScreenPriv->WinPrivDelete)((DbeWindowPrivPtr)pDbeWindowPriv, id);

d1285 1
a1285 2
    if (pDbeWindowPriv->nBufferIDs == 0)
    {
d1287 2
a1288 2
	dixSetPrivate(&pDbeWindowPriv->pWindow->devPrivates, dbeWindowPrivKey,
		      NULL);
d1291 1
a1291 1
	dixFreeObjectWithPrivates(pDbeWindowPriv, PRIVATE_DBE_WINDOW);
d1296 1
a1296 2
} /* DbeWindowPrivDelete() */

d1310 1
a1310 1
DbeResetProc(ExtensionEntry *extEntry)
d1312 10
a1321 12
    int			i;
    ScreenPtr		pScreen;
    DbeScreenPrivPtr	pDbeScreenPriv;
    
    for (i = 0; i < screenInfo.numScreens; i++)
    {
	pScreen = screenInfo.screens[i];
	pDbeScreenPriv = DBE_SCREEN_PRIV(pScreen);

	if (pDbeScreenPriv)
	{
            /* Unwrap DestroyWindow, which was wrapped in DbeExtensionInit().*/
d1324 2
a1325 2
	    if (pDbeScreenPriv->ResetProc)
		(*pDbeScreenPriv->ResetProc)(pScreen);
d1327 2
a1328 2
	    free(pDbeScreenPriv);
	}
d1330 1
a1330 2
} /* DbeResetProc() */

d1347 4
a1350 5
    DbeScreenPrivPtr	pDbeScreenPriv;
    DbeWindowPrivPtr	pDbeWindowPriv;
    ScreenPtr		pScreen;
    Bool		ret;

d1358 2
a1359 2
    pScreen                = pWin->drawable.pScreen;
    pDbeScreenPriv         = DBE_SCREEN_PRIV(pScreen);
d1371 2
a1372 4
    if ((pDbeWindowPriv = DBE_WINDOW_PRIV(pWin)))
    {
        while (pDbeWindowPriv)
        {
d1388 1
a1388 1
    ret = (*pScreen->DestroyWindow)(pWin);
d1410 1
a1410 2
} /* DbeDestroyWindow() */

d1425 6
a1430 6
    ExtensionEntry	*extEntry;
    register int	i, j;
    ScreenPtr		pScreen = NULL;
    DbeScreenPrivPtr	pDbeScreenPriv;
    int			nStubbedScreens = 0;
    Bool		ddxInitSuccess;
d1433 2
a1434 1
    if(!noPanoramiXExtension) return;
d1441 1
a1441 1
	return;
d1447 1
a1447 1
	return;
d1450 1
a1450 1
	return;
d1453 1
a1453 1
	return;
d1455 1
a1455 2
    for (i = 0; i < screenInfo.numScreens; i++)
    {
d1460 1
a1460 1
	pScreen = screenInfo.screens[i];
d1462 1
a1462 2
	if (!(pDbeScreenPriv = malloc (sizeof (DbeScreenPrivRec))))
	{
d1467 8
a1474 9
	    for (j = 0; j < i; j++)
	    {
		free(dixLookupPrivate(&screenInfo.screens[j]->devPrivates,
				       dbeScreenPrivKey));
		dixSetPrivate(&screenInfo.screens[j]->devPrivates,
			      dbeScreenPrivKey, NULL);
	    }
	    return;
	}
d1476 1
a1476 1
	dixSetPrivate(&pScreen->devPrivates, dbeScreenPrivKey, pDbeScreenPriv);
d1483 1
a1483 1
            pDbeScreenPriv->SetupBackgroundPainter = DbeSetupBackgroundPainter; 
d1493 1
a1493 2
            if (ddxInitSuccess)
            {
d1499 1
a1499 1
                pScreen->DestroyWindow        = DbeDestroyWindow;
d1501 1
a1501 2
            else
            {
d1511 1
a1511 2
    } /* for (i = 0; i < screenInfo.numScreens; i++) */

d1513 2
a1514 3
    if (nStubbedScreens == screenInfo.numScreens)
    {
	/* All screens stubbed.  Clean up and return. */
d1516 4
a1519 5
        for (i = 0; i < screenInfo.numScreens; i++)
        {
		free(dixLookupPrivate(&screenInfo.screens[i]->devPrivates,
				       dbeScreenPrivKey));
		dixSetPrivate(&pScreen->devPrivates, dbeScreenPrivKey, NULL);
a1523 1

d1525 1
a1525 1
    extEntry = AddExtension(DBE_PROTOCOL_NAME, DbeNumberEvents, 
d1530 2
a1531 1
    SetResourceTypeErrorValue(dbeWindowPrivResType, dbeErrorBase + DbeBadBuffer);
d1534 1
a1534 2
} /* DbeExtensionInit() */

@


1.9
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d693 1
a693 2
    if (!(pScrVisInfo = (XdbeScreenVisualInfo *)malloc(count *
                        sizeof(XdbeScreenVisualInfo))))
d709 4
a712 2
	if ((rc != Success) ||
	    !(*pDbeScreenPriv->GetVisualInfo)(pScreen, &pScrVisInfo[i]))
d715 1
d718 1
a718 9
            for (j = 0; j < i; j++)
            {
                free(pScrVisInfo[j].visinfo);
            }

            /* Free pDrawables if we needed to allocate it above. */
            free(pDrawables);

            return (rc == Success) ? BadAlloc : rc;
d787 3
d799 1
a799 1
    return Success;
@


1.8
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d60 7
a66 9
/* These are static globals copied to DBE's screen private for use by DDX */
static int dbeScreenPrivKeyIndex;
static DevPrivateKey dbeScreenPrivKey = &dbeScreenPrivKeyIndex;
static int dbeWindowPrivKeyIndex;
static DevPrivateKey dbeWindowPrivKey = &dbeWindowPrivKeyIndex;

/* These are static globals copied to DBE's screen private for use by DDX */
static RESTYPE	dbeDrawableResType;
static RESTYPE	dbeWindowPrivResType;
d148 1
a148 1
    return(client->noClientException);
d202 1
a202 1
	return(BadMatch);
d212 1
a212 1
        return(BadValue);
d223 1
a223 1
	return(BadMatch); /* screen doesn't support double buffering */
d228 1
a228 1
        return(BadAlloc);
d242 1
a242 1
    xfree(scrVisInfo.visinfo);
d246 1
a246 1
	return(BadMatch);
d255 1
a255 1
        pDbeWindowPriv = xcalloc(1, sizeof(DbeWindowPrivRec));
d257 1
a257 1
            return(BadAlloc);
d320 1
a320 1
            pDbeWindowPriv->IDs = (XID *)xrealloc(pIDs,
d324 1
a324 1
                return(BadAlloc);
d380 1
a380 1
    return(status);
d384 2
a385 2
    xfree(pDbeWindowPriv);
    return (status);
d423 1
a423 1
	return (rc == BadValue) ? dbeErrorBase + DbeBadBuffer : rc;
d428 1
a428 1
	return (rc == BadValue) ? dbeErrorBase + DbeBadBuffer : rc;
d448 1
a448 1
        return(dbeErrorBase + DbeBadBuffer);
d453 1
a453 1
    return(Success);
d499 1
a499 1
        return(Success);
d509 1
a509 1
    swapInfo = (DbeSwapInfoPtr)Xalloc(nStuff * sizeof(DbeSwapInfoRec));
d512 1
a512 1
        return(BadAlloc);
d524 1
a524 1
            Xfree(swapInfo);
d531 2
a532 2
            Xfree(swapInfo);
            return(BadMatch);
d540 2
a541 2
                Xfree(swapInfo);
                return(BadMatch);
d551 2
a552 2
            Xfree(swapInfo);
            return(BadValue);
d581 2
a582 2
            Xfree(swapInfo);
            return(error);
d586 2
a587 2
    Xfree(swapInfo);
    return(Success);
d629 1
a629 1
    return(Success);
d673 1
a673 1
        if (!(pDrawables = (DrawablePtr *)Xalloc(stuff->n *
d676 1
a676 1
            return(BadAlloc);
d686 1
a686 1
                Xfree(pDrawables);
d693 1
a693 1
    if (!(pScrVisInfo = (XdbeScreenVisualInfo *)xalloc(count *
d696 1
a696 4
        if (pDrawables)
        {
            Xfree(pDrawables);
        }
d698 1
a698 1
        return(BadAlloc);
d718 1
a718 1
                xfree(pScrVisInfo[j].visinfo);
d722 1
a722 4
            if (pDrawables)
            {
                Xfree(pDrawables);
            }
d796 1
a796 1
        xfree(pScrVisInfo[i].visinfo);
d798 1
a798 1
    xfree(pScrVisInfo);
d800 1
a800 4
    if (pDrawables)
    {
        Xfree(pDrawables);
    }
d802 1
a802 1
    return(client->noClientException);
d858 1
a858 1
    return(client->noClientException);
d897 1
a897 1
            return(Success);
d906 1
a906 1
            return(BadRequest);
d1198 1
a1198 1
            return(Success);
d1207 1
a1207 1
            return (BadRequest);
d1231 1
a1231 1
    pointer	gcvalues[4];
d1257 2
a1258 2
            gcvalues[0] = (pointer)background.pixel;
            gcvalues[1] = (pointer)FillSolid;
d1263 4
a1266 4
            gcvalues[0] = (pointer)FillTiled;
            gcvalues[1] = (pointer)background.pixmap;
            gcvalues[2] = (pointer)(long)ts_x_origin;
            gcvalues[3] = (pointer)(long)ts_y_origin;
d1272 1
a1272 1
            return(FALSE);
d1275 1
a1275 7
    if (DoChangeGC(pGC, gcmask, (XID *)gcvalues, TRUE) != 0)
    {
        return(FALSE);
    }

    return(TRUE);

d1298 1
a1298 1
    return(Success);
d1338 1
a1338 1
        return(BadValue);
d1371 1
a1371 1
        xfree(pDbeWindowPriv->IDs);
d1402 1
a1402 2
	dixFreePrivates(pDbeWindowPriv->devPrivates);
        xfree(pDbeWindowPriv);
d1405 1
a1405 1
    return(Success);
d1441 1
a1441 2
	    dixFreePrivates(pDbeScreenPriv->devPrivates);
	    xfree(pDbeScreenPriv);
d1526 1
a1526 1
    return(ret);
d1567 4
a1570 2
    if (!dixRegisterPrivateOffset(dbeDrawableResType,
				  offsetof(PixmapRec, devPrivates)))
d1581 1
a1581 2
	if (!(pDbeScreenPriv =
             (DbeScreenPrivPtr)Xcalloc(sizeof(DbeScreenPrivRec))))
d1589 1
a1589 1
		xfree(dixLookupPrivate(&screenInfo.screens[j]->devPrivates,
a1598 8
        /* Copy the resource types */
        pDbeScreenPriv->dbeDrawableResType   = dbeDrawableResType;
        pDbeScreenPriv->dbeWindowPrivResType = dbeWindowPrivResType;

        /* Copy the private indices */
        pDbeScreenPriv->dbeScreenPrivKey = dbeScreenPrivKey;
        pDbeScreenPriv->dbeWindowPrivKey = dbeWindowPrivKey;

d1643 1
a1643 1
		xfree(dixLookupPrivate(&screenInfo.screens[i]->devPrivates,
d1657 2
@


1.7
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a35 1
#define NEED_EVENTS
d414 2
a415 1
    int			i;
d421 10
a430 8
    if (!(pDbeWindowPriv = (DbeWindowPrivPtr)SecurityLookupIDByType(client,
		stuff->buffer, dbeWindowPrivResType, DixDestroyAccess)) ||
        !(SecurityLookupIDByType(client, stuff->buffer, dbeDrawableResType,
				 DixDestroyAccess)))
    {
        client->errorValue = stuff->buffer;
        return(dbeErrorBase + DbeBadBuffer);
    }
d744 1
a744 1
    rep.length         = length >> 2;
d839 1
a839 1
    int					n;
d844 4
a847 2
    if (!(pDbeWindowPriv = (DbeWindowPrivPtr)SecurityLookupIDByType(client,
		stuff->buffer, dbeWindowPrivResType, DixGetAttrAccess)))
d849 1
a849 1
        rep.attributes = None;
d853 1
a853 1
        rep.attributes = pDbeWindowPriv->pWindow->drawable.id;
d1576 5
a1580 1
        CreateNewResourceType(DbeDrawableDelete) | RC_DRAWABLE;
d1582 4
a1585 1
        CreateNewResourceType(DbeWindowPrivDelete);
@


1.6
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a60 3
/* Per-screen initialization functions [init'ed by DbeRegisterFunction()] */
static Bool (* DbeInitFunct[MAXSCREENS])();	/* pScreen, pDbeScreenPriv */

d62 4
a65 2
static DevPrivateKey dbeScreenPrivKey = &dbeScreenPrivKey;
static DevPrivateKey dbeWindowPrivKey = &dbeWindowPrivKey;
a73 39
/* Used by DbeRegisterFunction() to initialize the initialization function
 * table only once per server lifetime.
 */
static Bool	firstRegistrationPass = TRUE;


/******************************************************************************
 *
 * DBE DIX Procedure: DbeRegisterFunction
 *
 * Description:
 *
 *     This function registers the DBE init function for the specified screen.
 *
 *****************************************************************************/

void
DbeRegisterFunction(ScreenPtr pScreen, Bool (*funct) (/* ??? */))
{
    int	i;

    /* Initialize the initialization function table if it has not been
     * initialized already.
     */
    if (firstRegistrationPass)
    {
        for (i = 0; i < MAXSCREENS; i++)
        {
            DbeInitFunct[i] = NULL;
        }

        firstRegistrationPass = FALSE;
    }

    DbeInitFunct[pScreen->myNum] = funct;

} /* DbeRegisterFunction() */


d258 1
a258 1
        pDbeWindowPriv = (DbeWindowPrivPtr)xalloc(sizeof(DbeWindowPrivRec));
a260 1
	bzero(pDbeWindowPriv, sizeof(DbeWindowPrivRec));
a1458 6

    /* We want to init the initialization function table after every server
     * reset in DbeRegisterFunction().
     */
    firstRegistrationPass = TRUE;

a1613 1
        if(DbeInitFunct[i])
d1615 1
a1615 31
            /* This screen supports DBE. */

            /* Setup DIX. */
            pDbeScreenPriv->SetupBackgroundPainter = DbeSetupBackgroundPainter; 

            /* Setup DDX. */
            ddxInitSuccess = (*DbeInitFunct[i])(pScreen, pDbeScreenPriv);

            /* DDX DBE initialization may have the side affect of
             * reallocating pDbeScreenPriv, so we need to update it.
             */
            pDbeScreenPriv = DBE_SCREEN_PRIV(pScreen);

            if (ddxInitSuccess)
            {
                /* Wrap DestroyWindow.  The DDX initialization function
                 * already wrapped PositionWindow for us.
                 */

                pDbeScreenPriv->DestroyWindow = pScreen->DestroyWindow;
                pScreen->DestroyWindow        = DbeDestroyWindow;
            }
            else
            {
                /* DDX initialization failed.  Stub the screen. */
                DbeStubScreen(pDbeScreenPriv, &nStubbedScreens);
            }
        }
        else
        {
            /* This screen does not support DBE. */
d1647 1
a1647 1
        } /* else -- this screen does not support DBE. */
@


1.5
log
@Fix from X.Org for a possible, non-exploitable crash in the DBE extension.
Reported to iDefense by regenrecht. Patch from Dave Airlie.
@
text
@d57 1
d62 1
a62 1
static Bool	(* DbeInitFunct[MAXSCREENS])();	/* pScreen, pDbeScreenPriv */
d65 2
a66 2
static int	dbeScreenPrivIndex;
static int	dbeWindowPrivIndex;
a71 3
/* This global is used by DbeAllocWinPrivPrivIndex() */
static int	winPrivPrivCount = 0;

a115 140
 * DBE DIX Procedure: DbeAllocWinPriv
 *
 * Description:
 *
 *     This function was cloned from AllocateWindow() in window.c.
 *     This function allocates a window priv structure to be associated 
 *     with a double-buffered window.
 *
 *****************************************************************************/
static DbeWindowPrivPtr
DbeAllocWinPriv(ScreenPtr pScreen)
{
    DbeWindowPrivPtr		pDbeWindowPriv;
    DbeScreenPrivPtr		pDbeScreenPriv;
    register char		*ptr;
    register DevUnion		*ppriv;
    register unsigned int	*sizes;
    register unsigned int	size;
    register int		i;

    pDbeScreenPriv = DBE_SCREEN_PRIV(pScreen);
    pDbeWindowPriv = (DbeWindowPrivPtr)xalloc(pDbeScreenPriv->totalWinPrivSize);

    if (pDbeWindowPriv)
    {
        ppriv = (DevUnion *)(pDbeWindowPriv + 1);
        pDbeWindowPriv->devPrivates = ppriv;
        sizes = pDbeScreenPriv->winPrivPrivSizes;
        ptr = (char *)(ppriv + pDbeScreenPriv->winPrivPrivLen);
        for (i = pDbeScreenPriv->winPrivPrivLen; --i >= 0; ppriv++, sizes++)
        {
            if ((size = *sizes))
            {
                ppriv->ptr = (pointer)ptr;
                ptr += size;
            }
            else
                ppriv->ptr = (pointer)NULL;
        }
    }

    return(pDbeWindowPriv);

} /* DbeAllocWinPriv() */


/******************************************************************************
 *
 * DBE DIX Procedure: DbeFallbackAllocWinPriv
 *
 * Description:
 *
 *     This is a fallback function for AllocWinPriv().
 *
 *****************************************************************************/

#if 0 /* NOT USED */
static DbeWindowPrivPtr
DbeFallbackAllocWinPriv(pScreen)
    ScreenPtr	pScreen;
{
    return (NULL);
} /* DbeFallbackAllocWinPriv() */
#endif


/******************************************************************************
 *
 * DBE DIX Procedure: DbeAllocWinPrivPrivIndex
 *
 * Description:
 *
 *     This function was cloned from AllocateWindowPrivateIndex() in window.c.
 *     This function allocates a new window priv priv index by simply returning
 *     an incremented private counter.
 *
 *****************************************************************************/

static int
DbeAllocWinPrivPrivIndex(void)
{
    return winPrivPrivCount++;

} /* DbeAllocWinPrivPrivIndex() */


/******************************************************************************
 *
 * DBE DIX Procedure: DbeAllocWinPrivPriv
 *
 * Description:
 *
 *     This function was cloned from AllocateWindowPrivate() in privates.c.
 *     This function allocates a private structure to be hung off
 *     a window private.
 *
 *****************************************************************************/

static Bool
DbeAllocWinPrivPriv(register ScreenPtr pScreen, int index, unsigned int amount)
{
    DbeScreenPrivPtr	pDbeScreenPriv;
    unsigned int	oldamount;


    pDbeScreenPriv = DBE_SCREEN_PRIV(pScreen);

    if (index >= pDbeScreenPriv->winPrivPrivLen)
    {
	unsigned *nsizes;
	nsizes = (unsigned *)xrealloc(pDbeScreenPriv->winPrivPrivSizes,
				      (index + 1) * sizeof(unsigned));
	if (!nsizes)
        {
	    return(FALSE);
        }

	while (pDbeScreenPriv->winPrivPrivLen <= index)
	{
	    nsizes[pDbeScreenPriv->winPrivPrivLen++] = 0;
	    pDbeScreenPriv->totalWinPrivSize += sizeof(DevUnion);
	}

	pDbeScreenPriv->winPrivPrivSizes = nsizes;
    }

    oldamount = pDbeScreenPriv->winPrivPrivSizes[index];

    if (amount > oldamount)
    {
	pDbeScreenPriv->winPrivPrivSizes[index] = amount;
	pDbeScreenPriv->totalWinPrivSize += (amount - oldamount);
    }
    return(TRUE);

} /* DbeAllocWinPrivPriv() */


/******************************************************************************
 *
a129 3
    pDbeScreenPriv->AllocWinPriv           = NULL;
    pDbeScreenPriv->AllocWinPrivPrivIndex  = NULL;
    pDbeScreenPriv->AllocWinPrivPriv       = NULL;
d234 1
d238 1
a238 1
    status = dixLookupWindow(&pWin, stuff->window, client, DixWriteAccess);
d298 2
a299 3
        if (!(pDbeWindowPriv =
            (*pDbeScreenPriv->AllocWinPriv)(pWin->drawable.pScreen)))
        {
d301 1
a301 1
        }
d316 5
a320 4
     
	add_index = 0;
	for (i = 1; i < DBE_INIT_MAX_IDS; i++)
	{
d325 1
a325 1
        pWin->devPrivates[dbeWindowPrivIndex].ptr = (pointer)pDbeWindowPriv;
a350 1

d387 1
a387 1
        add_index = i;
d398 1
a398 1
        pDbeWindowPriv->IDs[add_index] = stuff->buffer;
d401 1
a401 1
        {
a412 1

a423 1

d427 1
a427 1
    pWin->devPrivates[dbeWindowPrivIndex].ptr = NULL;
d429 1
a429 1
    return(status);    
d725 1
a725 1
				   DixReadAccess);
d753 3
a755 1
        if (!(*pDbeScreenPriv->GetVisualInfo)(pScreen, &pScrVisInfo[i]))
d771 1
a771 1
            return(BadAlloc);
d884 1
a884 1
		stuff->buffer, dbeWindowPrivResType, DixReadAccess)))
d1452 2
a1453 2
        pDbeWindowPriv->pWindow->devPrivates[dbeWindowPrivIndex].ptr =
            (pointer)NULL;
d1456 1
a1482 6

    if (dbeScreenPrivIndex < 0)
    {
	return;
    }

d1496 1
a1496 5
            if (pDbeScreenPriv->winPrivPrivSizes)
            {
	        xfree(pDbeScreenPriv->winPrivPrivSizes);
            }

a1616 15
    /* Allocate private pointers in windows and screens. */

    if ((dbeScreenPrivIndex = AllocateScreenPrivateIndex()) < 0)
    {
	return;
    }

    if ((dbeWindowPrivIndex = AllocateWindowPrivateIndex()) < 0)
    {
	return;
    }

    /* Initialize the priv priv counts between server generations. */
    winPrivPrivCount  = 0;

d1619 1
a1619 1
        CreateNewResourceType(DbeDrawableDelete) | RC_CACHED | RC_DRAWABLE;
d1622 3
d1634 1
a1634 2
	if (!AllocateWindowPrivate(pScreen, dbeWindowPrivIndex, 0) ||
	    !(pDbeScreenPriv =
d1643 4
a1646 2
	      xfree(screenInfo.screens[j]->devPrivates[dbeScreenPrivIndex].ptr);
              screenInfo.screens[j]->devPrivates[dbeScreenPrivIndex].ptr = NULL;
d1651 1
a1651 8
	pScreen->devPrivates[dbeScreenPrivIndex].ptr = (pointer)pDbeScreenPriv;

        /* Store the DBE priv priv size info for later use when allocating
         * priv privs at the driver level.
         */
        pDbeScreenPriv->winPrivPrivLen   = 0;
        pDbeScreenPriv->winPrivPrivSizes = (unsigned *)NULL;
        pDbeScreenPriv->totalWinPrivSize = sizeof(DbeWindowPrivRec);
d1658 2
a1659 2
        pDbeScreenPriv->dbeScreenPrivIndex = dbeScreenPrivIndex;
        pDbeScreenPriv->dbeWindowPrivIndex = dbeWindowPrivIndex;
a1666 3
            pDbeScreenPriv->AllocWinPriv           = DbeAllocWinPriv;
            pDbeScreenPriv->AllocWinPrivPrivIndex  = DbeAllocWinPrivPrivIndex;
            pDbeScreenPriv->AllocWinPrivPriv       = DbeAllocWinPrivPriv;
a1697 3
            pDbeScreenPriv->AllocWinPriv           = DbeAllocWinPriv;
            pDbeScreenPriv->AllocWinPrivPrivIndex  = DbeAllocWinPrivPrivIndex;
            pDbeScreenPriv->AllocWinPrivPriv       = DbeAllocWinPrivPriv;
d1736 3
a1738 2
             xfree(screenInfo.screens[i]->devPrivates[dbeScreenPrivIndex].ptr);
             pScreen->devPrivates[dbeScreenPrivIndex].ptr = NULL;
@


1.4
log
@merge xserver 1.4, 1st pass
@
text
@d377 1
a377 1

a447 8
        /* Make the window priv a DBE window priv resource. */
        if (!AddResource(stuff->buffer, dbeWindowPrivResType,
            (pointer)pDbeWindowPriv))
        {
            xfree(pDbeWindowPriv);
            return(BadAlloc);
        }

d461 4
a464 3
        pDbeWindowPriv->IDs[0] = stuff->buffer;
        for (i = 1; i < DBE_INIT_MAX_IDS; i++)
        {
a467 1

d532 1
a532 10
        /* Finally, record the buffer ID in the array. */
        pDbeWindowPriv->IDs[i] = stuff->buffer;

        /* Associate the new ID with an existing window priv. */
        if (!AddResource(stuff->buffer, dbeWindowPrivResType,
                         (pointer)pDbeWindowPriv))
        {
            pDbeWindowPriv->IDs[i] = DBE_FREE_ID_ELEMENT;
            return(BadAlloc);
        }
d541 1
a541 1
    if ((status != Success) && (pDbeWindowPriv->nBufferIDs == 0))
d543 12
d558 4
a561 2
        xfree(pDbeWindowPriv);
        return(status);
d572 5
@


1.3
log
@merge xserver 1.2.0
@
text
@a84 30
 * DBE DIX Procedure: DbeValidateBuffer
 *
 * Description:
 *
 *     This function is called from VALIDATE_DRAWABLE_AND_GC and from
 *     various places in dispatch.c if the server has been compiled with
 *     the flags -DNEED_DBE_BUF_BITS and -DNEED_DBE_BUF_VALIDATE.  
 *     When pWin->dstBuffer changes, this function will be called with pWin
 *     as the first argument, the drawable ID that was specified as the
 *     second argument (could be a back buffer id), and True for the third
 *     argument.
 *     When pWin->srcBuffer changes, the third argument will be False, and
 *     the first two arguments are as described for dstBuffer.
 *
 *     This function should prepare the hardware to access the specified
 *     buffer for reads (if dstbuf is False) or writes (if dstbuf is True).
 *
 *****************************************************************************/

void
DbeValidateBuffer(WindowPtr pWin, XID drawID, Bool dstbuf)
{
    DbeScreenPrivPtr pDbeScreenPriv = DBE_SCREEN_PRIV_FROM_WINDOW(pWin);
    if (pDbeScreenPriv->ValidateBuffer)
	(*pDbeScreenPriv->ValidateBuffer)(pWin, drawID, dstbuf);
}


/******************************************************************************
 *
a289 1
    pDbeScreenPriv->ValidateBuffer	= NULL;
d382 3
a384 5
    if (!(pWin = SecurityLookupWindow(stuff->window, client,
				      SecurityWriteAccess)))
    {
	return(BadWindow);
    }
d608 1
a608 1
		stuff->buffer, dbeWindowPrivResType, SecurityDestroyAccess)) ||
d610 1
a610 1
				 SecurityDestroyAccess)))
d707 3
a709 3
        if (!(pWin = SecurityLookupWindow(dbeSwapInfo[i].window, client,
					  SecurityWriteAccess)))
        {
d711 1
a711 1
	    return(BadWindow);
d845 1
a845 1
    register int		i, j, n;
d869 3
a871 3
            if (!(pDrawables[i] = (DrawablePtr)SecurityLookupDrawable(
				drawables[i], client, SecurityReadAccess)))
            {
d873 1
a873 1
                return(BadDrawable);
d1027 1
a1027 1
		stuff->buffer, dbeWindowPrivResType, SecurityReadAccess)))
@


1.2
log
@CVE-2006-6101 CVE-2006-6102 CVE-2006-6103: The ProcDbeGetVisualInfo(),
ProcDbeSwapBuffer() and ProcRenderAddGlyphs() functions in the X server,
implementing requests for the dbe and render extensions, may be used
to overwrite data on the stack or in other parts of the X server memory.
@
text
@d42 1
a42 1
#if HAVE_STDINT_T
@


1.1
log
@Initial revision
@
text
@d42 5
d721 3
d728 1
a728 1
    swapInfo = (DbeSwapInfoPtr)ALLOCATE_LOCAL(nStuff * sizeof(DbeSwapInfoRec));
d743 1
a743 1
            DEALLOCATE_LOCAL(swapInfo);
d750 1
a750 1
            DEALLOCATE_LOCAL(swapInfo);
d759 1
a759 1
                DEALLOCATE_LOCAL(swapInfo);
d770 1
a770 1
            DEALLOCATE_LOCAL(swapInfo);
d800 1
a800 1
            DEALLOCATE_LOCAL(swapInfo);
d805 1
a805 1
    DEALLOCATE_LOCAL(swapInfo);
d887 2
d892 1
a892 1
        if (!(pDrawables = (DrawablePtr *)ALLOCATE_LOCAL(stuff->n *
d905 1
a905 1
                DEALLOCATE_LOCAL(pDrawables);
d917 1
a917 1
            DEALLOCATE_LOCAL(pDrawables);
d944 1
a944 1
                DEALLOCATE_LOCAL(pDrawables);
d1025 1
a1025 1
        DEALLOCATE_LOCAL(pDrawables);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@Import xserver version 1.2.0 (X.Org 7.2 final).
@
text
@a41 5
#if HAVE_STDINT_H
#include <stdint.h>
#elif !defined(UINT32_MAX)
#define UINT32_MAX 0xffffffffU
#endif
a715 3
    if (nStuff > UINT32_MAX / sizeof(DbeSwapInfoRec))
	    return BadAlloc;

d720 1
a720 1
    swapInfo = (DbeSwapInfoPtr)Xalloc(nStuff * sizeof(DbeSwapInfoRec));
d735 1
a735 1
            Xfree(swapInfo);
d742 1
a742 1
            Xfree(swapInfo);
d751 1
a751 1
                Xfree(swapInfo);
d762 1
a762 1
            Xfree(swapInfo);
d792 1
a792 1
            Xfree(swapInfo);
d797 1
a797 1
    Xfree(swapInfo);
a878 2
    if (stuff->n > UINT32_MAX / sizeof(DrawablePtr))
	    return BadAlloc;
d882 1
a882 1
        if (!(pDrawables = (DrawablePtr *)Xalloc(stuff->n *
d895 1
a895 1
                Xfree(pDrawables);
d907 1
a907 1
            Xfree(pDrawables);
d934 1
a934 1
                Xfree(pDrawables);
d1015 1
a1015 1
        Xfree(pDrawables);
@


1.1.1.3
log
@xserver 1.4
@
text
@d85 30
d320 1
d413 5
a417 3
    status = dixLookupWindow(&pWin, stuff->window, client, DixWriteAccess);
    if (status != Success)
	return status;
d641 1
a641 1
		stuff->buffer, dbeWindowPrivResType, DixDestroyAccess)) ||
d643 1
a643 1
				 DixDestroyAccess)))
d740 3
a742 3
	error = dixLookupWindow(&pWin, dbeSwapInfo[i].window, client,
				DixWriteAccess);
	if (error != Success) {
d744 1
a744 1
	    return error;
d878 1
a878 1
    register int		i, j, n, rc;
d902 3
a904 3
	    rc = dixLookupDrawable(pDrawables+i, drawables[i], client, 0,
				   DixReadAccess);
	    if (rc != Success) {
d906 1
a906 1
                return rc;
d1060 1
a1060 1
		stuff->buffer, dbeWindowPrivResType, DixReadAccess)))
@


