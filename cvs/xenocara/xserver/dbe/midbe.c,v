head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.12;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.37;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/******************************************************************************
 *
 * Copyright (c) 1994, 1995  Hewlett-Packard Company
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the Hewlett-Packard
 * Company shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization from the Hewlett-Packard Company.
 *
 *     Machine-independent DBE code
 *
 *****************************************************************************/

/* INCLUDES */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "resource.h"
#include "opaque.h"
#include "dbestruct.h"
#include "regionstr.h"
#include "gcstruct.h"
#include "inputstr.h"
#include "midbe.h"
#include "xace.h"

#include <stdio.h>


/******************************************************************************
 *
 * DBE MI Procedure: miDbeGetVisualInfo
 *
 * Description:
 *
 *     This is the MI function for the DbeGetVisualInfo request.  This function
 *     is called through pDbeScreenPriv->GetVisualInfo.  This function is also
 *     called for the DbeAllocateBackBufferName request at the extension level;
 *     it is called by ProcDbeAllocateBackBufferName() in dbe.c.
 *
 *     If memory allocation fails or we can not get the visual info, this
 *     function returns FALSE.  Otherwise, it returns TRUE for success.
 *
 *****************************************************************************/

static Bool
miDbeGetVisualInfo(ScreenPtr pScreen, XdbeScreenVisualInfo * pScrVisInfo)
{
    register int i, j, k;
    register int count;
    DepthPtr pDepth;
    XdbeVisualInfo *visInfo;

    /* Determine number of visuals for this screen. */
    for (i = 0, count = 0; i < pScreen->numDepths; i++) {
        count += pScreen->allowedDepths[i].numVids;
    }

    /* Allocate an array of XdbeVisualInfo items. */
    if (!(visInfo = xallocarray(count, sizeof(XdbeVisualInfo)))) {
        return FALSE;           /* memory alloc failure */
    }

    for (i = 0, k = 0; i < pScreen->numDepths; i++) {
        /* For each depth of this screen, get visual information. */

        pDepth = &pScreen->allowedDepths[i];

        for (j = 0; j < pDepth->numVids; j++) {
            /* For each visual for this depth of this screen, get visual ID
             * and visual depth.  Since this is MI code, we will always return
             * the same performance level for all visuals (0).  A higher
             * performance level value indicates higher performance.
             */
            visInfo[k].visual = pDepth->vids[j];
            visInfo[k].depth = pDepth->depth;
            visInfo[k].perflevel = 0;
            k++;
        }
    }

    /* Record the number of visuals and point visual_depth to
     * the array of visual info.
     */
    pScrVisInfo->count = count;
    pScrVisInfo->visinfo = visInfo;

    return TRUE;                /* success */

}                               /* miDbeGetVisualInfo() */

/******************************************************************************
 *
 * DBE MI Procedure: miAllocBackBufferName
 *
 * Description:
 *
 *     This is the MI function for the DbeAllocateBackBufferName request.
 *
 *****************************************************************************/

static int
miDbeAllocBackBufferName(WindowPtr pWin, XID bufId, int swapAction)
{
    ScreenPtr pScreen;
    DbeWindowPrivPtr pDbeWindowPriv;
    DbeScreenPrivPtr pDbeScreenPriv;
    GCPtr pGC;
    xRectangle clearRect;
    int rc;

    pScreen = pWin->drawable.pScreen;
    pDbeWindowPriv = DBE_WINDOW_PRIV(pWin);

    if (pDbeWindowPriv->nBufferIDs == 0) {
        /* There is no buffer associated with the window.
         * We have to create the window priv priv.  Remember, the window
         * priv was created at the DIX level, so all we need to do is
         * create the priv priv and attach it to the priv.
         */

        pDbeScreenPriv = DBE_SCREEN_PRIV(pScreen);

        /* Get a front pixmap. */
        if (!(pDbeWindowPriv->pFrontBuffer =
              (*pScreen->CreatePixmap) (pScreen, pDbeWindowPriv->width,
                                        pDbeWindowPriv->height,
                                        pWin->drawable.depth, 0))) {
            return BadAlloc;
        }

        /* Get a back pixmap. */
        if (!(pDbeWindowPriv->pBackBuffer =
              (*pScreen->CreatePixmap) (pScreen, pDbeWindowPriv->width,
                                        pDbeWindowPriv->height,
                                        pWin->drawable.depth, 0))) {
            (*pScreen->DestroyPixmap) (pDbeWindowPriv->pFrontBuffer);
            return BadAlloc;
        }

        /* Security creation/labeling check. */
        rc = XaceHook(XACE_RESOURCE_ACCESS, serverClient, bufId,
                      dbeDrawableResType, pDbeWindowPriv->pBackBuffer,
                      RT_WINDOW, pWin, DixCreateAccess);

        /* Make the back pixmap a DBE drawable resource. */
        if (rc != Success || !AddResource(bufId, dbeDrawableResType,
                                          pDbeWindowPriv->pBackBuffer)) {
            /* free the buffer and the drawable resource */
            FreeResource(bufId, RT_NONE);
            return (rc == Success) ? BadAlloc : rc;
        }

        /* Clear the back buffer. */
        pGC = GetScratchGC(pWin->drawable.depth, pWin->drawable.pScreen);
        if ((*pDbeScreenPriv->SetupBackgroundPainter) (pWin, pGC)) {
            ValidateGC((DrawablePtr) pDbeWindowPriv->pBackBuffer, pGC);
            clearRect.x = clearRect.y = 0;
            clearRect.width = pDbeWindowPriv->pBackBuffer->drawable.width;
            clearRect.height = pDbeWindowPriv->pBackBuffer->drawable.height;
            (*pGC->ops->PolyFillRect) ((DrawablePtr) pDbeWindowPriv->
                                       pBackBuffer, pGC, 1, &clearRect);
        }
        FreeScratchGC(pGC);

    }                           /* if no buffer associated with the window */

    else {
        /* A buffer is already associated with the window.
         * Place the new buffer ID information at the head of the ID list.
         */

        /* Associate the new ID with an existing pixmap. */
        if (!AddResource(bufId, dbeDrawableResType,
                         (void *) pDbeWindowPriv->pBackBuffer)) {
            return BadAlloc;
        }

    }

    return Success;

}                               /* miDbeAllocBackBufferName() */

/******************************************************************************
 *
 * DBE MI Procedure: miDbeAliasBuffers
 *
 * Description:
 *
 *     This function associates all XIDs of a buffer with the back pixmap
 *     stored in the window priv.
 *
 *****************************************************************************/

static void
miDbeAliasBuffers(DbeWindowPrivPtr pDbeWindowPriv)
{
    int i;

    for (i = 0; i < pDbeWindowPriv->nBufferIDs; i++) {
        ChangeResourceValue(pDbeWindowPriv->IDs[i], dbeDrawableResType,
                            (void *) pDbeWindowPriv->pBackBuffer);
    }

}                               /* miDbeAliasBuffers() */

/******************************************************************************
 *
 * DBE MI Procedure: miDbeSwapBuffers
 *
 * Description:
 *
 *     This is the MI function for the DbeSwapBuffers request.
 *
 *****************************************************************************/

static int
miDbeSwapBuffers(ClientPtr client, int *pNumWindows, DbeSwapInfoPtr swapInfo)
{
    DbeScreenPrivPtr pDbeScreenPriv;
    DbeWindowPrivPtr pDbeWindowPriv;
    GCPtr pGC;
    WindowPtr pWin;
    PixmapPtr pTmpBuffer;
    xRectangle clearRect;

    pWin = swapInfo[0].pWindow;
    pDbeScreenPriv = DBE_SCREEN_PRIV_FROM_WINDOW(pWin);
    pDbeWindowPriv = DBE_WINDOW_PRIV(pWin);
    pGC = GetScratchGC(pWin->drawable.depth, pWin->drawable.pScreen);

    /*
     **********************************************************************
     ** Setup before swap.
     **********************************************************************
     */

    switch (swapInfo[0].swapAction) {
    case XdbeUndefined:
        break;

    case XdbeBackground:
        break;

    case XdbeUntouched:
        ValidateGC((DrawablePtr) pDbeWindowPriv->pFrontBuffer, pGC);
        (*pGC->ops->CopyArea) ((DrawablePtr) pWin,
                               (DrawablePtr) pDbeWindowPriv->pFrontBuffer,
                               pGC, 0, 0, pWin->drawable.width,
                               pWin->drawable.height, 0, 0);
        break;

    case XdbeCopied:
        break;

    }

    /*
     **********************************************************************
     ** Swap.
     **********************************************************************
     */

    ValidateGC((DrawablePtr) pWin, pGC);
    (*pGC->ops->CopyArea) ((DrawablePtr) pDbeWindowPriv->pBackBuffer,
                           (DrawablePtr) pWin, pGC, 0, 0,
                           pWin->drawable.width, pWin->drawable.height, 0, 0);

    /*
     **********************************************************************
     ** Tasks after swap.
     **********************************************************************
     */

    switch (swapInfo[0].swapAction) {
    case XdbeUndefined:
        break;

    case XdbeBackground:
        if ((*pDbeScreenPriv->SetupBackgroundPainter) (pWin, pGC)) {
            ValidateGC((DrawablePtr) pDbeWindowPriv->pBackBuffer, pGC);
            clearRect.x = 0;
            clearRect.y = 0;
            clearRect.width = pDbeWindowPriv->pBackBuffer->drawable.width;
            clearRect.height = pDbeWindowPriv->pBackBuffer->drawable.height;
            (*pGC->ops->PolyFillRect) ((DrawablePtr) pDbeWindowPriv->
                                       pBackBuffer, pGC, 1, &clearRect);
        }
        break;

    case XdbeUntouched:
        /* Swap pixmap pointers. */
        pTmpBuffer = pDbeWindowPriv->pBackBuffer;
        pDbeWindowPriv->pBackBuffer = pDbeWindowPriv->pFrontBuffer;
        pDbeWindowPriv->pFrontBuffer = pTmpBuffer;

        miDbeAliasBuffers(pDbeWindowPriv);

        break;

    case XdbeCopied:
        break;

    }

    /* Remove the swapped window from the swap information array and decrement
     * pNumWindows to indicate to the DIX level how many windows were actually
     * swapped.
     */

    if (*pNumWindows > 1) {
        /* We were told to swap more than one window, but we only swapped the
         * first one.  Remove the first window in the list by moving the last
         * window to the beginning.
         */
        swapInfo[0].pWindow = swapInfo[*pNumWindows - 1].pWindow;
        swapInfo[0].swapAction = swapInfo[*pNumWindows - 1].swapAction;

        /* Clear the last window information just to be safe. */
        swapInfo[*pNumWindows - 1].pWindow = (WindowPtr) NULL;
        swapInfo[*pNumWindows - 1].swapAction = 0;
    }
    else {
        /* Clear the window information just to be safe. */
        swapInfo[0].pWindow = (WindowPtr) NULL;
        swapInfo[0].swapAction = 0;
    }

    (*pNumWindows)--;

    FreeScratchGC(pGC);

    return Success;

}                               /* miSwapBuffers() */

/******************************************************************************
 *
 * DBE MI Procedure: miDbeWinPrivDelete
 *
 * Description:
 *
 *     This is the MI function for deleting the dbeWindowPrivResType resource.
 *     This function is invoked indirectly by calling FreeResource() to free
 *     the resources associated with a DBE buffer ID.  There are 5 ways that
 *     miDbeWinPrivDelete() can be called by FreeResource().  They are:
 *
 *     - A DBE window is destroyed, in which case the DbeDestroyWindow()
 *       wrapper is invoked.  The wrapper calls FreeResource() for all DBE
 *       buffer IDs.
 *
 *     - miDbeAllocBackBufferName() calls FreeResource() to clean up resources
 *       after a buffer allocation failure.
 *
 *     - The PositionWindow wrapper, miDbePositionWindow(), calls
 *       FreeResource() when it fails to create buffers of the new size.
 *       FreeResource() is called for all DBE buffer IDs.
 *
 *     - FreeClientResources() calls FreeResource() when a client dies or the
 *       the server resets.
 *
 *     When FreeResource() is called for a DBE buffer ID, the delete function
 *     for the only other type of DBE resource, dbeDrawableResType, is also
 *     invoked.  This delete function (DbeDrawableDelete) is a NOOP to make
 *     resource deletion easier.  It is not guaranteed which delete function is
 *     called first.  Hence, we will let miDbeWinPrivDelete() free all DBE
 *     resources.
 *
 *     This function deletes/frees the following stuff associated with
 *     the window private:
 *
 *     - the ID node in the ID list representing the passed in ID.
 *
 *     In addition, pDbeWindowPriv->nBufferIDs is decremented.
 *
 *     If this function is called for the last/only buffer ID for a window,
 *     these are additionally deleted/freed:
 *
 *     - the front and back pixmaps
 *     - the window priv itself
 *
 *****************************************************************************/

static void
miDbeWinPrivDelete(DbeWindowPrivPtr pDbeWindowPriv, XID bufId)
{
    if (pDbeWindowPriv->nBufferIDs != 0) {
        /* We still have at least one more buffer ID associated with this
         * window.
         */
        return;
    }

    /* We have no more buffer IDs associated with this window.  We need to
     * free some stuff.
     */

    /* Destroy the front and back pixmaps. */
    if (pDbeWindowPriv->pFrontBuffer) {
        (*pDbeWindowPriv->pWindow->drawable.pScreen->
         DestroyPixmap) (pDbeWindowPriv->pFrontBuffer);
    }
    if (pDbeWindowPriv->pBackBuffer) {
        (*pDbeWindowPriv->pWindow->drawable.pScreen->
         DestroyPixmap) (pDbeWindowPriv->pBackBuffer);
    }
}                               /* miDbeWinPrivDelete() */

/******************************************************************************
 *
 * DBE MI Procedure: miDbePositionWindow
 *
 * Description:
 *
 *     This function was cloned from miMbxPositionWindow() in mimultibuf.c.
 *     This function resizes the buffer when the window is resized.
 *
 *****************************************************************************/

static Bool
miDbePositionWindow(WindowPtr pWin, int x, int y)
{
    ScreenPtr pScreen;
    DbeScreenPrivPtr pDbeScreenPriv;
    DbeWindowPrivPtr pDbeWindowPriv;
    int width, height;
    int dx, dy, dw, dh;
    int sourcex, sourcey;
    int destx, desty;
    int savewidth, saveheight;
    PixmapPtr pFrontBuffer;
    PixmapPtr pBackBuffer;
    Bool clear;
    GCPtr pGC;
    xRectangle clearRect;
    Bool ret;

    /*
     **************************************************************************
     ** 1. Unwrap the member routine.
     **************************************************************************
     */

    pScreen = pWin->drawable.pScreen;
    pDbeScreenPriv = DBE_SCREEN_PRIV(pScreen);
    pScreen->PositionWindow = pDbeScreenPriv->PositionWindow;

    /*
     **************************************************************************
     ** 2. Do any work necessary before the member routine is called.
     **
     **    In this case we do not need to do anything.
     **************************************************************************
     */

    /*
     **************************************************************************
     ** 3. Call the member routine, saving its result if necessary.
     **************************************************************************
     */

    ret = (*pScreen->PositionWindow) (pWin, x, y);

    /*
     **************************************************************************
     ** 4. Rewrap the member routine, restoring the wrapper value first in case
     **    the wrapper (or something that it wrapped) change this value.
     **************************************************************************
     */

    pDbeScreenPriv->PositionWindow = pScreen->PositionWindow;
    pScreen->PositionWindow = miDbePositionWindow;

    /*
     **************************************************************************
     ** 5. Do any work necessary after the member routine has been called.
     **************************************************************************
     */

    if (!(pDbeWindowPriv = DBE_WINDOW_PRIV(pWin))) {
        return ret;
    }

    if (pDbeWindowPriv->width == pWin->drawable.width &&
        pDbeWindowPriv->height == pWin->drawable.height) {
        return ret;
    }

    width = pWin->drawable.width;
    height = pWin->drawable.height;

    dx = pWin->drawable.x - pDbeWindowPriv->x;
    dy = pWin->drawable.y - pDbeWindowPriv->y;
    dw = width - pDbeWindowPriv->width;
    dh = height - pDbeWindowPriv->height;

    GravityTranslate(0, 0, -dx, -dy, dw, dh, pWin->bitGravity, &destx, &desty);

    clear = ((pDbeWindowPriv->width < (unsigned short) width) ||
             (pDbeWindowPriv->height < (unsigned short) height) ||
             (pWin->bitGravity == ForgetGravity));

    sourcex = 0;
    sourcey = 0;
    savewidth = pDbeWindowPriv->width;
    saveheight = pDbeWindowPriv->height;

    /* Clip rectangle to source and destination. */
    if (destx < 0) {
        savewidth += destx;
        sourcex -= destx;
        destx = 0;
    }

    if (destx + savewidth > width) {
        savewidth = width - destx;
    }

    if (desty < 0) {
        saveheight += desty;
        sourcey -= desty;
        desty = 0;
    }

    if (desty + saveheight > height) {
        saveheight = height - desty;
    }

    pDbeWindowPriv->width = width;
    pDbeWindowPriv->height = height;
    pDbeWindowPriv->x = pWin->drawable.x;
    pDbeWindowPriv->y = pWin->drawable.y;

    pGC = GetScratchGC(pWin->drawable.depth, pScreen);

    if (clear) {
        if ((*pDbeScreenPriv->SetupBackgroundPainter) (pWin, pGC)) {
            clearRect.x = 0;
            clearRect.y = 0;
            clearRect.width = width;
            clearRect.height = height;
        }
        else {
            clear = FALSE;
        }
    }

    /* Create DBE buffer pixmaps equal to size of resized window. */
    pFrontBuffer = (*pScreen->CreatePixmap) (pScreen, width, height,
                                             pWin->drawable.depth, 0);

    pBackBuffer = (*pScreen->CreatePixmap) (pScreen, width, height,
                                            pWin->drawable.depth, 0);

    if (!pFrontBuffer || !pBackBuffer) {
        /* We failed at creating 1 or 2 of the pixmaps. */

        if (pFrontBuffer) {
            (*pScreen->DestroyPixmap) (pFrontBuffer);
        }

        if (pBackBuffer) {
            (*pScreen->DestroyPixmap) (pBackBuffer);
        }

        /* Destroy all buffers for this window. */
        while (pDbeWindowPriv) {
            /* DbeWindowPrivDelete() will free the window private if there no
             * more buffer IDs associated with this window.
             */
            FreeResource(pDbeWindowPriv->IDs[0], RT_NONE);
            pDbeWindowPriv = DBE_WINDOW_PRIV(pWin);
        }

        FreeScratchGC(pGC);
        return FALSE;
    }

    else {
        /* Clear out the new DBE buffer pixmaps. */

        /* I suppose this could avoid quite a bit of work if
         * it computed the minimal area required.
         */
        ValidateGC(&pFrontBuffer->drawable, pGC);
        if (clear) {
            (*pGC->ops->PolyFillRect) ((DrawablePtr) pFrontBuffer, pGC, 1,
                                       &clearRect);
        }
        /* Copy the contents of the old front pixmap to the new one. */
        if (pWin->bitGravity != ForgetGravity) {
            (*pGC->ops->CopyArea) ((DrawablePtr) pDbeWindowPriv->pFrontBuffer,
				   (DrawablePtr) pFrontBuffer, pGC,
				   sourcex, sourcey, savewidth, saveheight,
                                   destx, desty);
        }

        ValidateGC(&pBackBuffer->drawable, pGC);
        if (clear) {
            (*pGC->ops->PolyFillRect) ((DrawablePtr) pBackBuffer, pGC, 1,
                                       &clearRect);
        }
        /* Copy the contents of the old back pixmap to the new one. */
        if (pWin->bitGravity != ForgetGravity) {
            (*pGC->ops->CopyArea) ((DrawablePtr) pDbeWindowPriv->pBackBuffer,
				   (DrawablePtr) pBackBuffer, pGC,
                                   sourcex, sourcey, savewidth, saveheight,
                                   destx, desty);
        }

        /* Destroy the old pixmaps, and point the DBE window priv to the new
         * pixmaps.
         */

        (*pScreen->DestroyPixmap) (pDbeWindowPriv->pFrontBuffer);
        (*pScreen->DestroyPixmap) (pDbeWindowPriv->pBackBuffer);

        pDbeWindowPriv->pFrontBuffer = pFrontBuffer;
        pDbeWindowPriv->pBackBuffer = pBackBuffer;

        /* Make sure all XID are associated with the new back pixmap. */
        miDbeAliasBuffers(pDbeWindowPriv);

        FreeScratchGC(pGC);
    }

    return ret;

}                               /* miDbePositionWindow() */

/******************************************************************************
 *
 * DBE MI Procedure: miDbeInit
 *
 * Description:
 *
 *     This is the MI initialization function called by DbeExtensionInit().
 *
 *****************************************************************************/

Bool
miDbeInit(ScreenPtr pScreen, DbeScreenPrivPtr pDbeScreenPriv)
{
    /* Wrap functions. */
    pDbeScreenPriv->PositionWindow = pScreen->PositionWindow;
    pScreen->PositionWindow = miDbePositionWindow;

    /* Initialize the per-screen DBE function pointers. */
    pDbeScreenPriv->GetVisualInfo = miDbeGetVisualInfo;
    pDbeScreenPriv->AllocBackBufferName = miDbeAllocBackBufferName;
    pDbeScreenPriv->SwapBuffers = miDbeSwapBuffers;
    pDbeScreenPriv->WinPrivDelete = miDbeWinPrivDelete;

    return TRUE;

}                               /* miDbeInit() */
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d90 1
a90 1
    if (!(visInfo = (XdbeVisualInfo *) malloc(count * sizeof(XdbeVisualInfo)))) {
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d2 1
a2 1
 * 
d12 1
a12 1
 * 
d15 1
a15 1
 * 
d23 1
a23 1
 * 
d28 1
a28 1
 * 
d399 1
a399 1
 *     
d446 1
a446 1
 *     This function was cloned from miMbxPositionWindow() in mimultibuf.c. 
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d205 1
a205 1
                         (pointer) pDbeWindowPriv->pBackBuffer)) {
d233 1
a233 1
                            (pointer) pDbeWindowPriv->pBackBuffer);
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a50 1
#include "midbestr.h"
a58 3
static DevPrivateKeyRec miDbeWindowPrivPrivKeyRec;

#define miDbeWindowPrivPrivKey (&miDbeWindowPrivPrivKeyRec)
a136 1
    MiDbeWindowPrivPrivPtr pDbeWindowPrivPriv;
a153 4
        /* Setup the window priv priv. */
        pDbeWindowPrivPriv = MI_DBE_WINDOW_PRIV_PRIV(pDbeWindowPriv);
        pDbeWindowPrivPriv->pDbeWindowPriv = pDbeWindowPriv;

d155 1
a155 1
        if (!(pDbeWindowPrivPriv->pFrontBuffer =
d163 1
a163 1
        if (!(pDbeWindowPrivPriv->pBackBuffer =
d167 1
a167 1
            (*pScreen->DestroyPixmap) (pDbeWindowPrivPriv->pFrontBuffer);
d173 1
a173 1
                      dbeDrawableResType, pDbeWindowPrivPriv->pBackBuffer,
d178 1
a178 1
                                          pDbeWindowPrivPriv->pBackBuffer)) {
d187 1
a187 1
            ValidateGC((DrawablePtr) pDbeWindowPrivPriv->pBackBuffer, pGC);
d189 3
a191 3
            clearRect.width = pDbeWindowPrivPriv->pBackBuffer->drawable.width;
            clearRect.height = pDbeWindowPrivPriv->pBackBuffer->drawable.height;
            (*pGC->ops->PolyFillRect) ((DrawablePtr) pDbeWindowPrivPriv->
a203 1
        pDbeWindowPrivPriv = MI_DBE_WINDOW_PRIV_PRIV(pDbeWindowPriv);
d205 1
a205 1
                         (pointer) pDbeWindowPrivPriv->pBackBuffer)) {
a229 2
    MiDbeWindowPrivPrivPtr pDbeWindowPrivPriv =
        MI_DBE_WINDOW_PRIV_PRIV(pDbeWindowPriv);
d233 1
a233 1
                            (pointer) pDbeWindowPrivPriv->pBackBuffer);
d252 1
a254 1
    MiDbeWindowPrivPrivPtr pDbeWindowPrivPriv;
d260 1
a260 1
    pDbeWindowPrivPriv = MI_DBE_WINDOW_PRIV_PRIV_FROM_WINDOW(pWin);
d277 1
a277 1
        ValidateGC((DrawablePtr) pDbeWindowPrivPriv->pFrontBuffer, pGC);
d279 1
a279 1
                               (DrawablePtr) pDbeWindowPrivPriv->pFrontBuffer,
d296 1
a296 1
    (*pGC->ops->CopyArea) ((DrawablePtr) pDbeWindowPrivPriv->pBackBuffer,
d312 1
a312 1
            ValidateGC((DrawablePtr) pDbeWindowPrivPriv->pBackBuffer, pGC);
d315 3
a317 3
            clearRect.width = pDbeWindowPrivPriv->pBackBuffer->drawable.width;
            clearRect.height = pDbeWindowPrivPriv->pBackBuffer->drawable.height;
            (*pGC->ops->PolyFillRect) ((DrawablePtr) pDbeWindowPrivPriv->
d324 3
a326 3
        pTmpBuffer = pDbeWindowPrivPriv->pBackBuffer;
        pDbeWindowPrivPriv->pBackBuffer = pDbeWindowPrivPriv->pFrontBuffer;
        pDbeWindowPrivPriv->pFrontBuffer = pTmpBuffer;
d328 1
a328 1
        miDbeAliasBuffers(pDbeWindowPrivPriv->pDbeWindowPriv);
a417 2
    MiDbeWindowPrivPrivPtr pDbeWindowPrivPriv;

a428 2
    pDbeWindowPrivPriv = MI_DBE_WINDOW_PRIV_PRIV(pDbeWindowPriv);

d430 1
a430 1
    if (pDbeWindowPrivPriv->pFrontBuffer) {
d432 1
a432 1
         DestroyPixmap) (pDbeWindowPrivPriv->pFrontBuffer);
d434 1
a434 1
    if (pDbeWindowPrivPriv->pBackBuffer) {
d436 1
a436 1
         DestroyPixmap) (pDbeWindowPrivPriv->pBackBuffer);
a437 1

a612 4
        MiDbeWindowPrivPrivPtr pDbeWindowPrivPriv;

        pDbeWindowPrivPriv = MI_DBE_WINDOW_PRIV_PRIV(pDbeWindowPriv);

d623 3
a625 3
            (*pGC->ops->CopyArea) ((DrawablePtr) pDbeWindowPrivPriv->
                                   pFrontBuffer, (DrawablePtr) pFrontBuffer,
                                   pGC, sourcex, sourcey, savewidth, saveheight,
d636 2
a637 2
            (*pGC->ops->CopyArea) ((DrawablePtr) pDbeWindowPrivPriv->
                                   pBackBuffer, (DrawablePtr) pBackBuffer, pGC,
d646 2
a647 2
        (*pScreen->DestroyPixmap) (pDbeWindowPrivPriv->pFrontBuffer);
        (*pScreen->DestroyPixmap) (pDbeWindowPrivPriv->pBackBuffer);
d649 2
a650 2
        pDbeWindowPrivPriv->pFrontBuffer = pFrontBuffer;
        pDbeWindowPrivPriv->pBackBuffer = pBackBuffer;
a663 24
 * DBE MI Procedure: miDbeResetProc
 *
 * Description:
 *
 *     This function is called from DbeResetProc(), which is called at the end
 *     of every server generation.  This function peforms any MI-specific
 *     shutdown tasks.
 *
 *****************************************************************************/

static void
miDbeResetProc(ScreenPtr pScreen)
{
    DbeScreenPrivPtr pDbeScreenPriv;

    pDbeScreenPriv = DBE_SCREEN_PRIV(pScreen);

    /* Unwrap wrappers */
    pScreen->PositionWindow = pDbeScreenPriv->PositionWindow;

}                               /* miDbeResetProc() */

/******************************************************************************
 *
a674 4
    if (!dixRegisterPrivateKey(&miDbeWindowPrivPrivKeyRec, PRIVATE_DBE_WINDOW,
                               sizeof(MiDbeWindowPrivPrivRec)))
        return FALSE;

a682 3
    pDbeScreenPriv->BeginIdiom = 0;
    pDbeScreenPriv->EndIdiom = 0;
    pDbeScreenPriv->ResetProc = miDbeResetProc;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a32 1

d61 1
a62 1

d81 1
a81 1
miDbeGetVisualInfo(ScreenPtr pScreen, XdbeScreenVisualInfo *pScrVisInfo)
d83 4
a86 5
    register int	i, j, k;
    register int	count;
    DepthPtr		pDepth;
    XdbeVisualInfo	*visInfo;

d89 1
a89 2
    for (i = 0, count = 0; i < pScreen->numDepths; i++)
    {
d94 2
a95 3
    if (!(visInfo = (XdbeVisualInfo *)malloc(count * sizeof(XdbeVisualInfo))))
    {
        return FALSE; /* memory alloc failure */
d98 1
a98 2
    for (i = 0, k = 0; i < pScreen->numDepths; i++)
    {
d103 1
a103 2
        for (j = 0; j < pDepth->numVids; j++)
        {
d109 2
a110 2
            visInfo[k].visual    = pDepth->vids[j];
            visInfo[k].depth     = pDepth->depth;
d119 1
a119 1
    pScrVisInfo->count   = count;
d122 1
a122 3
    return TRUE; /* success */

} /* miDbeGetVisualInfo() */
d124 1
d139 7
a145 8
    ScreenPtr			pScreen;
    DbeWindowPrivPtr		pDbeWindowPriv;
    MiDbeWindowPrivPrivPtr	pDbeWindowPrivPriv; 
    DbeScreenPrivPtr		pDbeScreenPriv;
    GCPtr			pGC;
    xRectangle			clearRect;
    int				rc;

d150 1
a150 2
    if (pDbeWindowPriv->nBufferIDs == 0)
    {
d165 3
a167 4
            (*pScreen->CreatePixmap)(pScreen, pDbeWindowPriv->width,
                                     pDbeWindowPriv->height,
                                     pWin->drawable.depth, 0)))
        {
d173 4
a176 5
            (*pScreen->CreatePixmap)(pScreen, pDbeWindowPriv->width,
                                     pDbeWindowPriv->height,
                                     pWin->drawable.depth, 0)))
        {
            (*pScreen->DestroyPixmap)(pDbeWindowPrivPriv->pFrontBuffer); 
d180 4
a183 4
	/* Security creation/labeling check. */
	rc = XaceHook(XACE_RESOURCE_ACCESS, serverClient, bufId,
		      dbeDrawableResType, pDbeWindowPrivPriv->pBackBuffer,
		      RT_WINDOW, pWin, DixCreateAccess);
d187 1
a187 2
					  pDbeWindowPrivPriv->pBackBuffer))
        {
d195 2
a196 3
        if ((*pDbeScreenPriv->SetupBackgroundPainter)(pWin, pGC))
        {
            ValidateGC((DrawablePtr)pDbeWindowPrivPriv->pBackBuffer, pGC);
d198 1
a198 1
            clearRect.width  = pDbeWindowPrivPriv->pBackBuffer->drawable.width;
d200 2
a201 3
            (*pGC->ops->PolyFillRect)(
                (DrawablePtr)pDbeWindowPrivPriv->pBackBuffer, pGC, 1,
                &clearRect);
d205 1
a205 1
    } /* if no buffer associated with the window */
d207 1
a207 2
    else
    {
d215 1
a215 2
                         (pointer)pDbeWindowPrivPriv->pBackBuffer))
        {
d223 1
a223 2
} /* miDbeAllocBackBufferName() */

d239 3
a241 3
    int				i;
    MiDbeWindowPrivPrivPtr	pDbeWindowPrivPriv =
                                    MI_DBE_WINDOW_PRIV_PRIV(pDbeWindowPriv);
d243 1
a243 2
    for (i = 0; i < pDbeWindowPriv->nBufferIDs; i++)
    {
d245 1
a245 1
                            (pointer)pDbeWindowPrivPriv->pBackBuffer);
d248 1
a248 2
} /* miDbeAliasBuffers() */

d263 6
a268 6
    DbeScreenPrivPtr		pDbeScreenPriv;
    GCPtr		    	pGC;
    WindowPtr		    	pWin;
    MiDbeWindowPrivPrivPtr	pDbeWindowPrivPriv; 
    PixmapPtr			pTmpBuffer;
    xRectangle			clearRect;
d270 2
a271 3

    pWin               = swapInfo[0].pWindow;
    pDbeScreenPriv     = DBE_SCREEN_PRIV_FROM_WINDOW(pWin);
d281 14
a294 15
    switch(swapInfo[0].swapAction)
    {
        case XdbeUndefined:
            break;

        case XdbeBackground:
            break;

        case XdbeUntouched:
            ValidateGC((DrawablePtr)pDbeWindowPrivPriv->pFrontBuffer, pGC);
            (*pGC->ops->CopyArea)((DrawablePtr)pWin,
                                  (DrawablePtr)pDbeWindowPrivPriv->pFrontBuffer,
                                  pGC, 0, 0, pWin->drawable.width,
                                  pWin->drawable.height, 0, 0);
            break;
d296 2
a297 2
        case XdbeCopied:
            break;
d307 4
a310 5
    ValidateGC((DrawablePtr)pWin, pGC);
    (*pGC->ops->CopyArea)((DrawablePtr)pDbeWindowPrivPriv->pBackBuffer,
                          (DrawablePtr)pWin, pGC, 0, 0,
                          pWin->drawable.width, pWin->drawable.height,
                          0, 0);
d318 21
a338 27
    switch(swapInfo[0].swapAction)
    {
        case XdbeUndefined:
            break;

        case XdbeBackground:
            if ((*pDbeScreenPriv->SetupBackgroundPainter)(pWin, pGC))
            {
                ValidateGC((DrawablePtr)pDbeWindowPrivPriv->pBackBuffer, pGC);
                clearRect.x = 0;
                clearRect.y = 0;
                clearRect.width =
                    pDbeWindowPrivPriv->pBackBuffer->drawable.width;
                clearRect.height =
                    pDbeWindowPrivPriv->pBackBuffer->drawable.height;
                (*pGC->ops->PolyFillRect)(
				(DrawablePtr)pDbeWindowPrivPriv->pBackBuffer,
				pGC, 1, &clearRect);
	    }
            break;

        case XdbeUntouched:
            /* Swap pixmap pointers. */
            pTmpBuffer = pDbeWindowPrivPriv->pBackBuffer;
            pDbeWindowPrivPriv->pBackBuffer =
                pDbeWindowPrivPriv->pFrontBuffer;
            pDbeWindowPrivPriv->pFrontBuffer = pTmpBuffer;
d340 1
a340 1
            miDbeAliasBuffers(pDbeWindowPrivPriv->pDbeWindowPriv);
d342 1
a342 1
            break;
d344 2
a345 2
        case XdbeCopied:
            break;
d354 1
a354 2
    if (*pNumWindows > 1)
    {
d359 1
a359 1
        swapInfo[0].pWindow    = swapInfo[*pNumWindows - 1].pWindow;
d363 1
a363 1
        swapInfo[*pNumWindows - 1].pWindow    = (WindowPtr)NULL;
d366 1
a366 2
    else
    {
d368 1
a368 1
        swapInfo[0].pWindow    = (WindowPtr)NULL;
d378 1
a378 2
} /* miSwapBuffers() */

d430 1
a430 1
    MiDbeWindowPrivPrivPtr	pDbeWindowPrivPriv;
d432 1
a432 3

    if (pDbeWindowPriv->nBufferIDs != 0)
    {
a438 1

d446 7
a452 9
    if (pDbeWindowPrivPriv->pFrontBuffer)
    {
        (*pDbeWindowPriv->pWindow->drawable.pScreen->DestroyPixmap)(
            pDbeWindowPrivPriv->pFrontBuffer);
    }
    if (pDbeWindowPrivPriv->pBackBuffer)
    {
        (*pDbeWindowPriv->pWindow->drawable.pScreen->DestroyPixmap)(
            pDbeWindowPrivPriv->pBackBuffer);
d455 1
a455 2
} /* miDbeWinPrivDelete() */

d471 14
a484 15
    ScreenPtr			pScreen;
    DbeScreenPrivPtr		pDbeScreenPriv;
    DbeWindowPrivPtr		pDbeWindowPriv;
    int				width, height;
    int				dx, dy, dw, dh;
    int				sourcex, sourcey;
    int				destx, desty;
    int				savewidth, saveheight;
    PixmapPtr			pFrontBuffer;
    PixmapPtr			pBackBuffer;
    Bool			clear;
    GCPtr			pGC;
    xRectangle			clearRect;
    Bool			ret;

d491 3
a493 3
     
    pScreen                 = pWin->drawable.pScreen;
    pDbeScreenPriv          = DBE_SCREEN_PRIV(pScreen);
d503 1
a503 1
     
d509 2
a510 2
     
    ret = (*pScreen->PositionWindow)(pWin, x, y);
d527 3
a529 4
     
    if (!(pDbeWindowPriv = DBE_WINDOW_PRIV(pWin)))
    {
	return ret;
d532 3
a534 4
    if (pDbeWindowPriv->width  == pWin->drawable.width &&
        pDbeWindowPriv->height == pWin->drawable.height)
    {
	return ret;
d537 1
a537 1
    width  = pWin->drawable.width;
d542 1
a542 1
    dw = width  - pDbeWindowPriv->width;
d545 1
a545 1
    GravityTranslate (0, 0, -dx, -dy, dw, dh, pWin->bitGravity, &destx, &desty);
d547 2
a548 2
    clear = ((pDbeWindowPriv->width  < (unsigned short)width ) ||
             (pDbeWindowPriv->height < (unsigned short)height) ||
d553 1
a553 1
    savewidth  = pDbeWindowPriv->width;
d557 4
a560 5
    if (destx < 0)
    {
	savewidth += destx;
	sourcex   -= destx;
	destx      = 0;
d563 2
a564 3
    if (destx + savewidth > width)
    {
	savewidth = width - destx;
d567 4
a570 5
    if (desty < 0)
    {
	saveheight += desty;
	sourcey    -= desty;
	desty       = 0;
d573 2
a574 3
    if (desty + saveheight > height)
    {
	saveheight = height - desty;
d577 1
a577 1
    pDbeWindowPriv->width  = width;
d582 1
a582 1
    pGC = GetScratchGC (pWin->drawable.depth, pScreen);
d584 10
a593 13
    if (clear)
    {
	if ((*pDbeScreenPriv->SetupBackgroundPainter)(pWin, pGC))
	{
	    clearRect.x = 0;
	    clearRect.y = 0;
	    clearRect.width  = width;
	    clearRect.height = height;
	}
	else
	{ 
	    clear = FALSE;
	}
d597 2
a598 2
    pFrontBuffer = (*pScreen->CreatePixmap)(pScreen, width, height,
					    pWin->drawable.depth, 0);
d600 2
a601 2
    pBackBuffer = (*pScreen->CreatePixmap)(pScreen, width, height,
					   pWin->drawable.depth, 0);
d603 1
a603 2
    if (!pFrontBuffer || !pBackBuffer)
    {
d606 2
a607 3
        if (pFrontBuffer)
        {
	    (*pScreen->DestroyPixmap)(pFrontBuffer);
d610 2
a611 3
        if (pBackBuffer)
        {
	    (*pScreen->DestroyPixmap)(pBackBuffer);
d615 1
a615 2
        while (pDbeWindowPriv)
        {
d627 1
a627 2
    else
    {
d630 1
a630 1
        MiDbeWindowPrivPrivPtr	pDbeWindowPrivPriv;
d632 1
d634 15
a648 1
        pDbeWindowPrivPriv = MI_DBE_WINDOW_PRIV_PRIV(pDbeWindowPriv);
d650 12
a661 30
	/* I suppose this could avoid quite a bit of work if
	 * it computed the minimal area required.
	 */
	ValidateGC(&pFrontBuffer->drawable, pGC);
	if (clear)
        {
	    (*pGC->ops->PolyFillRect)((DrawablePtr)pFrontBuffer, pGC, 1,
				      &clearRect);
	}
	/* Copy the contents of the old front pixmap to the new one. */
	if (pWin->bitGravity != ForgetGravity)
	{
	    (*pGC->ops->CopyArea)((DrawablePtr)pDbeWindowPrivPriv->pFrontBuffer,
                                  (DrawablePtr)pFrontBuffer, pGC, sourcex,
                                  sourcey, savewidth, saveheight, destx, desty);
        }

	ValidateGC(&pBackBuffer->drawable, pGC);
	if (clear)
	{
	    (*pGC->ops->PolyFillRect)((DrawablePtr)pBackBuffer , pGC, 1,
				      &clearRect);
	}
	/* Copy the contents of the old back pixmap to the new one. */
	if (pWin->bitGravity != ForgetGravity)
	{
	    (*pGC->ops->CopyArea)((DrawablePtr)pDbeWindowPrivPriv->pBackBuffer,
                                  (DrawablePtr)pBackBuffer, pGC, sourcex,
                                  sourcey, savewidth, saveheight, destx, desty);
	}
d667 2
a668 2
	(*pScreen->DestroyPixmap)(pDbeWindowPrivPriv->pFrontBuffer);
	(*pScreen->DestroyPixmap)(pDbeWindowPrivPriv->pBackBuffer);
d671 1
a671 1
        pDbeWindowPrivPriv->pBackBuffer  = pBackBuffer;
d673 1
a673 1
	/* Make sure all XID are associated with the new back pixmap. */
d681 1
a681 2
} /* miDbePositionWindow() */

d698 1
a698 2
    DbeScreenPrivPtr    pDbeScreenPriv;

d705 1
a705 2
} /* miDbeResetProc() */

d721 1
a721 1
			       sizeof(MiDbeWindowPrivPrivRec)))
d726 1
a726 1
    pScreen->PositionWindow        = miDbePositionWindow;
d729 7
a735 7
    pDbeScreenPriv->GetVisualInfo         = miDbeGetVisualInfo;
    pDbeScreenPriv->AllocBackBufferName   = miDbeAllocBackBufferName;
    pDbeScreenPriv->SwapBuffers           = miDbeSwapBuffers;
    pDbeScreenPriv->BeginIdiom            = 0;
    pDbeScreenPriv->EndIdiom              = 0;
    pDbeScreenPriv->ResetProc             = miDbeResetProc;
    pDbeScreenPriv->WinPrivDelete         = miDbeWinPrivDelete;
d739 1
a739 1
} /* miDbeInit() */
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d61 2
a62 8
static int miDbeWindowPrivPrivKeyIndex;
static DevPrivateKey miDbeWindowPrivPrivKey = &miDbeWindowPrivPrivKeyIndex;
static RESTYPE	dbeDrawableResType;
static RESTYPE	dbeWindowPrivResType;
static int dbeScreenPrivKeyIndex;
static DevPrivateKey dbeScreenPrivKey = &dbeScreenPrivKeyIndex;
static int dbeWindowPrivKeyIndex;
static DevPrivateKey dbeWindowPrivKey = &dbeWindowPrivKeyIndex;
d97 1
a97 1
    if (!(visInfo = (XdbeVisualInfo *)xalloc(count * sizeof(XdbeVisualInfo))))
d99 1
a99 1
        return(FALSE); /* memory alloc failure */
d128 1
a128 1
    return(TRUE); /* success */
d178 1
a178 1
            return(BadAlloc);
d188 1
a188 1
            return(BadAlloc);
a204 6

        /* Attach the priv priv to the priv. */
	dixSetPrivate(&pDbeWindowPriv->devPrivates, miDbeWindowPrivPrivKey,
		      pDbeWindowPrivPriv);


d232 1
a232 1
            return(BadAlloc);
d237 1
a237 1
    return(Success);
d406 1
a406 1
    return(Success);
d568 1
a568 1
	return(ret);
d574 1
a574 1
	return(ret);
d675 1
a675 1
        return(FALSE);
d734 1
a734 1
    return(ret);
d778 3
a780 11
    /* Copy resource types created by DIX */
    dbeDrawableResType   = pDbeScreenPriv->dbeDrawableResType;
    dbeWindowPrivResType = pDbeScreenPriv->dbeWindowPrivResType;

    /* Copy private indices created by DIX */
    dbeScreenPrivKey = pDbeScreenPriv->dbeScreenPrivKey;
    dbeWindowPrivKey = pDbeScreenPriv->dbeWindowPrivKey;

    if (!dixRequestPrivate(miDbeWindowPrivPrivKey,
			   sizeof(MiDbeWindowPrivPrivRec)))
        return(FALSE);
d795 1
a795 1
    return(TRUE);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a35 2
#define NEED_REPLIES
#define NEED_EVENTS
a697 1
        ValidateGC((DrawablePtr)pFrontBuffer, pGC);
d702 1
d707 2
a708 5
	    (*pGC->ops->PolyFillRect)((DrawablePtr)pBackBuffer , pGC, 1,
				      &clearRect);
        }

        /* Copy the contents of the old DBE pixmaps to the new pixmaps. */
d714 11
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d63 2
a64 1
static DevPrivateKey miDbeWindowPrivPrivKey = &miDbeWindowPrivPrivKey;
d67 4
a70 2
static DevPrivateKey dbeScreenPrivKey = &dbeScreenPrivKey;
static DevPrivateKey dbeWindowPrivKey = &dbeWindowPrivKey;
@


1.1
log
@Initial revision
@
text
@d59 1
d63 5
a67 15
/* DEFINES */


/* TYPEDEFS */


/* GLOBALS */

static int	miDbePrivPrivGeneration  =  0;
static int	miDbeWindowPrivPrivIndex = -1;
RESTYPE		dbeDrawableResType;
RESTYPE		dbeWindowPrivResType;
int		dbeScreenPrivIndex = -1;
int		dbeWindowPrivIndex = -1;

d157 1
d181 1
a181 1
                                     pWin->drawable.depth)))
d190 1
a190 1
                                     pWin->drawable.depth)))
d196 4
d202 2
a203 2
        if (!AddResource(bufId, dbeDrawableResType,
            (pointer)pDbeWindowPrivPriv->pBackBuffer))
d207 1
a207 1
            return(BadAlloc);
d212 2
a213 2
	pDbeWindowPriv->devPrivates[miDbeWindowPrivPrivIndex].ptr =
            (pointer)pDbeWindowPrivPriv;
d656 1
a656 1
					    pWin->drawable.depth);
d659 1
a659 1
					   pWin->drawable.depth);
a766 5
static void
miDbeNopValidateBuffer(WindowPtr pWin, XID bufId, Bool dstbuffer)
{
}

d786 2
a787 13
    dbeScreenPrivIndex = pDbeScreenPriv->dbeScreenPrivIndex;
    dbeWindowPrivIndex = pDbeScreenPriv->dbeWindowPrivIndex;

    /* Reset the window priv privs if generations do not match. */
    if (miDbePrivPrivGeneration != serverGeneration)
    {
        /*
         **********************************************************************
         ** Allocate the window priv priv.
         **********************************************************************
         */

        miDbeWindowPrivPrivIndex = (*pDbeScreenPriv->AllocWinPrivPrivIndex)();
d789 2
a790 8
        /* Make sure we only do this code once. */
	miDbePrivPrivGeneration = serverGeneration;

    } /* if -- Reset priv privs. */

    if (!(*pDbeScreenPriv->AllocWinPrivPriv)(pScreen,
        miDbeWindowPrivPrivIndex, sizeof(MiDbeWindowPrivPrivRec)))
    {
a791 1
    }
a804 3

    /* The mi implementation doesn't need buffer validation. */
    pDbeScreenPriv->ValidateBuffer	  = miDbeNopValidateBuffer;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d62 8
d72 5
a76 4
static RESTYPE	dbeDrawableResType;
static RESTYPE	dbeWindowPrivResType;
static int	dbeScreenPrivIndex = -1;
static int	dbeWindowPrivIndex = -1;
d771 5
d832 3
@

