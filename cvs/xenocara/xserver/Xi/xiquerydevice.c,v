head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.8
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	vcnjRBuLQw44cPHf;

1.7
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches
	1.7.4.1
	1.7.6.1;
next	1.6;

1.6
date	2012.08.05.18.11.37;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.03.28.21.10.15;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	;

1.7.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.7.6.1
date	2014.12.09.17.59.32;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.8
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@/*
 * Copyright Â© 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors: Peter Hutterer
 *
 */

/**
 * @@file Protocol handling for the XIQueryDevice request/reply.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"
#include <X11/X.h>
#include <X11/Xatom.h>
#include <X11/extensions/XI2proto.h>
#include "xkbstr.h"
#include "xkbsrv.h"
#include "xserver-properties.h"
#include "exevents.h"
#include "xace.h"
#include "inpututils.h"

#include "xiquerydevice.h"

static Bool ShouldSkipDevice(ClientPtr client, int deviceid, DeviceIntPtr d);
static int
 ListDeviceInfo(ClientPtr client, DeviceIntPtr dev, xXIDeviceInfo * info);
static int SizeDeviceInfo(DeviceIntPtr dev);
static void SwapDeviceInfo(DeviceIntPtr dev, xXIDeviceInfo * info);
int
SProcXIQueryDevice(ClientPtr client)
{
    REQUEST(xXIQueryDeviceReq);
    REQUEST_SIZE_MATCH(xXIQueryDeviceReq);

    swaps(&stuff->length);
    swaps(&stuff->deviceid);

    return ProcXIQueryDevice(client);
}

int
ProcXIQueryDevice(ClientPtr client)
{
    xXIQueryDeviceReply rep;
    DeviceIntPtr dev = NULL;
    int rc = Success;
    int i = 0, len = 0;
    char *info, *ptr;
    Bool *skip = NULL;

    REQUEST(xXIQueryDeviceReq);
    REQUEST_SIZE_MATCH(xXIQueryDeviceReq);

    if (stuff->deviceid != XIAllDevices &&
        stuff->deviceid != XIAllMasterDevices) {
        rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
        if (rc != Success) {
            client->errorValue = stuff->deviceid;
            return rc;
        }
        len += SizeDeviceInfo(dev);
    }
    else {
        skip = calloc(sizeof(Bool), inputInfo.numDevices);
        if (!skip)
            return BadAlloc;

        for (dev = inputInfo.devices; dev; dev = dev->next, i++) {
            skip[i] = ShouldSkipDevice(client, stuff->deviceid, dev);
            if (!skip[i])
                len += SizeDeviceInfo(dev);
        }

        for (dev = inputInfo.off_devices; dev; dev = dev->next, i++) {
            skip[i] = ShouldSkipDevice(client, stuff->deviceid, dev);
            if (!skip[i])
                len += SizeDeviceInfo(dev);
        }
    }

    info = calloc(1, len);
    if (!info) {
        free(skip);
        return BadAlloc;
    }

    rep = (xXIQueryDeviceReply) {
        .repType = X_Reply,
        .RepType = X_XIQueryDevice,
        .sequenceNumber = client->sequence,
        .length = len / 4,
        .num_devices = 0
    };

    ptr = info;
    if (dev) {
        len = ListDeviceInfo(client, dev, (xXIDeviceInfo *) info);
        if (client->swapped)
            SwapDeviceInfo(dev, (xXIDeviceInfo *) info);
        info += len;
        rep.num_devices = 1;
    }
    else {
        i = 0;
        for (dev = inputInfo.devices; dev; dev = dev->next, i++) {
            if (!skip[i]) {
                len = ListDeviceInfo(client, dev, (xXIDeviceInfo *) info);
                if (client->swapped)
                    SwapDeviceInfo(dev, (xXIDeviceInfo *) info);
                info += len;
                rep.num_devices++;
            }
        }

        for (dev = inputInfo.off_devices; dev; dev = dev->next, i++) {
            if (!skip[i]) {
                len = ListDeviceInfo(client, dev, (xXIDeviceInfo *) info);
                if (client->swapped)
                    SwapDeviceInfo(dev, (xXIDeviceInfo *) info);
                info += len;
                rep.num_devices++;
            }
        }
    }

    len = rep.length * 4;
    WriteReplyToClient(client, sizeof(xXIQueryDeviceReply), &rep);
    WriteToClient(client, len, ptr);
    free(ptr);
    free(skip);
    return rc;
}

void
SRepXIQueryDevice(ClientPtr client, int size, xXIQueryDeviceReply * rep)
{
    swaps(&rep->sequenceNumber);
    swapl(&rep->length);
    swaps(&rep->num_devices);

    /* Device info is already swapped, see ProcXIQueryDevice */

    WriteToClient(client, size, rep);
}

/**
 * @@return Whether the device should be included in the returned list.
 */
static Bool
ShouldSkipDevice(ClientPtr client, int deviceid, DeviceIntPtr dev)
{
    /* if all devices are not being queried, only master devices are */
    if (deviceid == XIAllDevices || IsMaster(dev)) {
        int rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixGetAttrAccess);

        if (rc == Success)
            return FALSE;
    }
    return TRUE;
}

/**
 * @@return The number of bytes needed to store this device's xXIDeviceInfo
 * (and its classes).
 */
static int
SizeDeviceInfo(DeviceIntPtr dev)
{
    int len = sizeof(xXIDeviceInfo);

    /* 4-padded name */
    len += pad_to_int32(strlen(dev->name));

    return len + SizeDeviceClasses(dev);

}

/*
 * @@return The number of bytes needed to store this device's classes.
 */
int
SizeDeviceClasses(DeviceIntPtr dev)
{
    int len = 0;

    if (dev->button) {
        len += sizeof(xXIButtonInfo);
        len += dev->button->numButtons * sizeof(Atom);
        len += pad_to_int32(bits_to_bytes(dev->button->numButtons));
    }

    if (dev->key) {
        XkbDescPtr xkb = dev->key->xkbInfo->desc;

        len += sizeof(xXIKeyInfo);
        len += (xkb->max_key_code - xkb->min_key_code + 1) * sizeof(uint32_t);
    }

    if (dev->valuator) {
        int i;

        len += (sizeof(xXIValuatorInfo)) * dev->valuator->numAxes;

        for (i = 0; i < dev->valuator->numAxes; i++) {
            if (dev->valuator->axes[i].scroll.type != SCROLL_TYPE_NONE)
                len += sizeof(xXIScrollInfo);
        }
    }

    if (dev->touch)
        len += sizeof(xXITouchInfo);

    return len;
}

/**
 * Write button information into info.
 * @@return Number of bytes written into info.
 */
int
ListButtonInfo(DeviceIntPtr dev, xXIButtonInfo * info, Bool reportState)
{
    unsigned char *bits;
    int mask_len;
    int i;

    if (!dev || !dev->button)
        return 0;

    mask_len = bytes_to_int32(bits_to_bytes(dev->button->numButtons));

    info->type = ButtonClass;
    info->num_buttons = dev->button->numButtons;
    info->length = bytes_to_int32(sizeof(xXIButtonInfo)) +
        info->num_buttons + mask_len;
    info->sourceid = dev->button->sourceid;

    bits = (unsigned char *) &info[1];
    memset(bits, 0, mask_len * 4);

    if (reportState)
        for (i = 0; i < dev->button->numButtons; i++)
            if (BitIsOn(dev->button->down, i))
                SetBit(bits, i);

    bits += mask_len * 4;
    memcpy(bits, dev->button->labels, dev->button->numButtons * sizeof(Atom));

    return info->length * 4;
}

static void
SwapButtonInfo(DeviceIntPtr dev, xXIButtonInfo * info)
{
    Atom *btn;
    int i;

    swaps(&info->type);
    swaps(&info->length);
    swaps(&info->sourceid);

    for (i = 0, btn = (Atom *) &info[1]; i < info->num_buttons; i++, btn++)
        swapl(btn);

    swaps(&info->num_buttons);
}

/**
 * Write key information into info.
 * @@return Number of bytes written into info.
 */
int
ListKeyInfo(DeviceIntPtr dev, xXIKeyInfo * info)
{
    int i;
    XkbDescPtr xkb = dev->key->xkbInfo->desc;
    uint32_t *kc;

    info->type = KeyClass;
    info->num_keycodes = xkb->max_key_code - xkb->min_key_code + 1;
    info->length = sizeof(xXIKeyInfo) / 4 + info->num_keycodes;
    info->sourceid = dev->key->sourceid;

    kc = (uint32_t *) &info[1];
    for (i = xkb->min_key_code; i <= xkb->max_key_code; i++, kc++)
        *kc = i;

    return info->length * 4;
}

static void
SwapKeyInfo(DeviceIntPtr dev, xXIKeyInfo * info)
{
    uint32_t *key;
    int i;

    swaps(&info->type);
    swaps(&info->length);
    swaps(&info->sourceid);

    for (i = 0, key = (uint32_t *) &info[1]; i < info->num_keycodes;
         i++, key++)
        swapl(key);

    swaps(&info->num_keycodes);
}

/**
 * List axis information for the given axis.
 *
 * @@return The number of bytes written into info.
 */
int
ListValuatorInfo(DeviceIntPtr dev, xXIValuatorInfo * info, int axisnumber,
                 Bool reportState)
{
    ValuatorClassPtr v = dev->valuator;

    info->type = ValuatorClass;
    info->length = sizeof(xXIValuatorInfo) / 4;
    info->label = v->axes[axisnumber].label;
    info->min.integral = v->axes[axisnumber].min_value;
    info->min.frac = 0;
    info->max.integral = v->axes[axisnumber].max_value;
    info->max.frac = 0;
    info->value = double_to_fp3232(v->axisVal[axisnumber]);
    info->resolution = v->axes[axisnumber].resolution;
    info->number = axisnumber;
    info->mode = valuator_get_mode(dev, axisnumber);
    info->sourceid = v->sourceid;

    if (!reportState)
        info->value = info->min;

    return info->length * 4;
}

static void
SwapValuatorInfo(DeviceIntPtr dev, xXIValuatorInfo * info)
{
    swaps(&info->type);
    swaps(&info->length);
    swapl(&info->label);
    swapl(&info->min.integral);
    swapl(&info->min.frac);
    swapl(&info->max.integral);
    swapl(&info->max.frac);
    swaps(&info->number);
    swaps(&info->sourceid);
}

int
ListScrollInfo(DeviceIntPtr dev, xXIScrollInfo * info, int axisnumber)
{
    ValuatorClassPtr v = dev->valuator;
    AxisInfoPtr axis = &v->axes[axisnumber];

    if (axis->scroll.type == SCROLL_TYPE_NONE)
        return 0;

    info->type = XIScrollClass;
    info->length = sizeof(xXIScrollInfo) / 4;
    info->number = axisnumber;
    switch (axis->scroll.type) {
    case SCROLL_TYPE_VERTICAL:
        info->scroll_type = XIScrollTypeVertical;
        break;
    case SCROLL_TYPE_HORIZONTAL:
        info->scroll_type = XIScrollTypeHorizontal;
        break;
    default:
        ErrorF("[Xi] Unknown scroll type %d. This is a bug.\n",
               axis->scroll.type);
        break;
    }
    info->increment = double_to_fp3232(axis->scroll.increment);
    info->sourceid = v->sourceid;

    info->flags = 0;

    if (axis->scroll.flags & SCROLL_FLAG_DONT_EMULATE)
        info->flags |= XIScrollFlagNoEmulation;
    if (axis->scroll.flags & SCROLL_FLAG_PREFERRED)
        info->flags |= XIScrollFlagPreferred;

    return info->length * 4;
}

static void
SwapScrollInfo(DeviceIntPtr dev, xXIScrollInfo * info)
{
    swaps(&info->type);
    swaps(&info->length);
    swaps(&info->number);
    swaps(&info->sourceid);
    swaps(&info->scroll_type);
    swapl(&info->increment.integral);
    swapl(&info->increment.frac);
}

/**
 * List multitouch information
 *
 * @@return The number of bytes written into info.
 */
int
ListTouchInfo(DeviceIntPtr dev, xXITouchInfo * touch)
{
    touch->type = XITouchClass;
    touch->length = sizeof(xXITouchInfo) >> 2;
    touch->sourceid = dev->touch->sourceid;
    touch->mode = dev->touch->mode;
    touch->num_touches = dev->touch->num_touches;

    return touch->length << 2;
}

static void
SwapTouchInfo(DeviceIntPtr dev, xXITouchInfo * touch)
{
    swaps(&touch->type);
    swaps(&touch->length);
    swaps(&touch->sourceid);
}

int
GetDeviceUse(DeviceIntPtr dev, uint16_t * attachment)
{
    DeviceIntPtr master = GetMaster(dev, MASTER_ATTACHED);
    int use;

    if (IsMaster(dev)) {
        DeviceIntPtr paired = GetPairedDevice(dev);

        use = IsPointerDevice(dev) ? XIMasterPointer : XIMasterKeyboard;
        *attachment = (paired ? paired->id : 0);
    }
    else if (!IsFloating(dev)) {
        use = IsPointerDevice(master) ? XISlavePointer : XISlaveKeyboard;
        *attachment = master->id;
    }
    else
        use = XIFloatingSlave;

    return use;
}

/**
 * Write the info for device dev into the buffer pointed to by info.
 *
 * @@return The number of bytes used.
 */
static int
ListDeviceInfo(ClientPtr client, DeviceIntPtr dev, xXIDeviceInfo * info)
{
    char *any = (char *) &info[1];
    int len = 0, total_len = 0;

    info->deviceid = dev->id;
    info->use = GetDeviceUse(dev, &info->attachment);
    info->num_classes = 0;
    info->name_len = strlen(dev->name);
    info->enabled = dev->enabled;
    total_len = sizeof(xXIDeviceInfo);

    len = pad_to_int32(info->name_len);
    memset(any, 0, len);
    strncpy(any, dev->name, info->name_len);
    any += len;
    total_len += len;

    total_len += ListDeviceClasses(client, dev, any, &info->num_classes);
    return total_len;
}

/**
 * Write the class info of the device into the memory pointed to by any, set
 * nclasses to the number of classes in total and return the number of bytes
 * written.
 */
int
ListDeviceClasses(ClientPtr client, DeviceIntPtr dev,
                  char *any, uint16_t * nclasses)
{
    int total_len = 0;
    int len;
    int i;
    int rc;

    /* Check if the current device state should be suppressed */
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixReadAccess);

    if (dev->button) {
        (*nclasses)++;
        len = ListButtonInfo(dev, (xXIButtonInfo *) any, rc == Success);
        any += len;
        total_len += len;
    }

    if (dev->key) {
        (*nclasses)++;
        len = ListKeyInfo(dev, (xXIKeyInfo *) any);
        any += len;
        total_len += len;
    }

    for (i = 0; dev->valuator && i < dev->valuator->numAxes; i++) {
        (*nclasses)++;
        len = ListValuatorInfo(dev, (xXIValuatorInfo *) any, i, rc == Success);
        any += len;
        total_len += len;
    }

    for (i = 0; dev->valuator && i < dev->valuator->numAxes; i++) {
        len = ListScrollInfo(dev, (xXIScrollInfo *) any, i);
        if (len)
            (*nclasses)++;
        any += len;
        total_len += len;
    }

    if (dev->touch) {
        (*nclasses)++;
        len = ListTouchInfo(dev, (xXITouchInfo *) any);
        any += len;
        total_len += len;
    }

    return total_len;
}

static void
SwapDeviceInfo(DeviceIntPtr dev, xXIDeviceInfo * info)
{
    char *any = (char *) &info[1];
    int i;

    /* Skip over name */
    any += pad_to_int32(info->name_len);

    for (i = 0; i < info->num_classes; i++) {
        int len = ((xXIAnyInfo *) any)->length;

        switch (((xXIAnyInfo *) any)->type) {
        case XIButtonClass:
            SwapButtonInfo(dev, (xXIButtonInfo *) any);
            break;
        case XIKeyClass:
            SwapKeyInfo(dev, (xXIKeyInfo *) any);
            break;
        case XIValuatorClass:
            SwapValuatorInfo(dev, (xXIValuatorInfo *) any);
            break;
        case XIScrollClass:
            SwapScrollInfo(dev, (xXIScrollInfo *) any);
            break;
        case XITouchClass:
            SwapTouchInfo(dev, (xXITouchInfo *) any);
            break;

        }

        any += len * 4;
    }

    swaps(&info->deviceid);
    swaps(&info->use);
    swaps(&info->attachment);
    swaps(&info->num_classes);
    swaps(&info->name_len);

}
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d57 1
@


1.7.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a56 1
    REQUEST_SIZE_MATCH(xXIQueryDeviceReq);
@


1.7.6.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a56 1
    REQUEST_SIZE_MATCH(xXIQueryDeviceReq);
@


1.6
log
@Update to xserver 1.12.3.
@
text
@d110 7
a116 6
    memset(&rep, 0, sizeof(xXIQueryDeviceReply));
    rep.repType = X_Reply;
    rep.RepType = X_XIQueryDevice;
    rep.sequenceNumber = client->sequence;
    rep.length = len / 4;
    rep.num_devices = 0;
d166 1
a166 1
    WriteToClient(client, size, (char *) rep);
d307 1
a307 1
    kc = (uint32_t *) & info[1];
d324 1
a324 1
    for (i = 0, key = (uint32_t *) & info[1]; i < info->num_keycodes;
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d433 1
a433 1
    touch->sourceid = touch->sourceid;
@


1.4
log
@Update to xserver 1.11.2
@
text
@d44 1
d50 1
a50 1
ListDeviceInfo(ClientPtr client, DeviceIntPtr dev, xXIDeviceInfo* info);
d52 1
a52 1
static void SwapDeviceInfo(DeviceIntPtr dev, xXIDeviceInfo* info);
a55 2
    char n;

d58 2
a59 2
    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
d77 2
a78 2
    if (stuff->deviceid != XIAllDevices && stuff->deviceid != XIAllMasterDevices)
    {
d80 1
a80 2
        if (rc != Success)
        {
d86 1
a86 2
    else
    {
d91 1
a91 2
        for (dev = inputInfo.devices; dev; dev = dev->next, i++)
        {
d97 1
a97 2
        for (dev = inputInfo.off_devices; dev; dev = dev->next, i++)
        {
d114 1
a114 1
    rep.length = len/4;
d118 2
a119 3
    if (dev)
    {
        len = ListDeviceInfo(client, dev, (xXIDeviceInfo*)info);
d121 1
a121 1
            SwapDeviceInfo(dev, (xXIDeviceInfo*)info);
d124 2
a125 2
    } else
    {
d127 3
a129 5
        for (dev = inputInfo.devices; dev; dev = dev->next, i++)
        {
            if (!skip[i])
            {
                len = ListDeviceInfo(client, dev, (xXIDeviceInfo*)info);
d131 1
a131 1
                    SwapDeviceInfo(dev, (xXIDeviceInfo*)info);
d137 3
a139 5
        for (dev = inputInfo.off_devices; dev; dev = dev->next, i++)
        {
            if (!skip[i])
            {
                len = ListDeviceInfo(client, dev, (xXIDeviceInfo*)info);
d141 1
a141 1
                    SwapDeviceInfo(dev, (xXIDeviceInfo*)info);
d157 1
a157 1
SRepXIQueryDevice(ClientPtr client, int size, xXIQueryDeviceReply *rep)
d159 3
a161 5
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->num_devices, n);
d165 1
a165 1
    WriteToClient(client, size, (char *)rep);
a167 1

d175 1
a175 2
    if (deviceid == XIAllDevices || IsMaster(dev))
    {
d177 1
d208 1
a208 2
    if (dev->button)
    {
d214 1
a214 2
    if (dev->key)
    {
d216 1
d221 13
a233 2
    if (dev->valuator)
        len += sizeof(xXIValuatorInfo) * dev->valuator->numAxes;
a237 1

d243 1
a243 1
ListButtonInfo(DeviceIntPtr dev, xXIButtonInfo* info, Bool reportState)
d250 1
a250 1
	return 0;
d257 1
a257 1
                   info->num_buttons + mask_len;
d260 1
a260 1
    bits = (unsigned char*)&info[1];
d264 3
a266 3
	for (i = 0; i < dev->button->numButtons; i++)
	    if (BitIsOn(dev->button->down, i))
		SetBit(bits, i);
d275 1
a275 1
SwapButtonInfo(DeviceIntPtr dev, xXIButtonInfo* info)
a276 1
    char n;
a278 3
    swaps(&info->type, n);
    swaps(&info->length, n);
    swaps(&info->sourceid, n);
d280 6
a285 2
    for (i = 0, btn = (Atom*)&info[1]; i < info->num_buttons; i++, btn++)
        swaps(btn, n);
d287 1
a287 1
    swaps(&info->num_buttons, n);
d295 1
a295 1
ListKeyInfo(DeviceIntPtr dev, xXIKeyInfo* info)
d303 1
a303 1
    info->length = sizeof(xXIKeyInfo)/4 + info->num_keycodes;
d306 1
a306 1
    kc = (uint32_t*)&info[1];
d314 1
a314 1
SwapKeyInfo(DeviceIntPtr dev, xXIKeyInfo* info)
a315 1
    char n;
a317 3
    swaps(&info->type, n);
    swaps(&info->length, n);
    swaps(&info->sourceid, n);
d319 7
a325 2
    for (i = 0, key = (uint32_t*)&info[1]; i < info->num_keycodes; i++, key++)
        swapl(key, n);
d327 1
a327 1
    swaps(&info->num_keycodes, n);
d336 2
a337 2
ListValuatorInfo(DeviceIntPtr dev, xXIValuatorInfo* info, int axisnumber,
		 Bool reportState)
d342 1
a342 1
    info->length = sizeof(xXIValuatorInfo)/4;
d348 1
a348 2
    info->value.integral = (int)v->axisVal[axisnumber];
    info->value.frac = (int)(v->axisVal[axisnumber] * (1 << 16) * (1 << 16));
d355 1
a355 1
	info->value = info->min;
d361 1
a361 1
SwapValuatorInfo(DeviceIntPtr dev, xXIValuatorInfo* info)
d363 9
a371 10
    char n;
    swaps(&info->type, n);
    swaps(&info->length, n);
    swapl(&info->label, n);
    swapl(&info->min.integral, n);
    swapl(&info->min.frac, n);
    swapl(&info->max.integral, n);
    swapl(&info->max.frac, n);
    swaps(&info->number, n);
    swaps(&info->sourceid, n);
d374 76
a449 1
int GetDeviceUse(DeviceIntPtr dev, uint16_t *attachment)
d454 1
a454 2
    if (IsMaster(dev))
    {
d456 1
d459 2
a460 2
    } else if (!IsFloating(dev))
    {
d463 2
a464 1
    } else
d476 1
a476 1
ListDeviceInfo(ClientPtr client, DeviceIntPtr dev, xXIDeviceInfo* info)
d478 1
a478 1
    char *any = (char*)&info[1];
d505 1
a505 1
		  char *any, uint16_t *nclasses)
d515 1
a515 2
    if (dev->button)
    {
d517 1
a517 1
        len = ListButtonInfo(dev, (xXIButtonInfo*)any, rc == Success);
d522 1
a522 2
    if (dev->key)
    {
d524 1
a524 1
        len = ListKeyInfo(dev, (xXIKeyInfo*)any);
d529 1
a529 2
    for (i = 0; dev->valuator && i < dev->valuator->numAxes; i++)
    {
d531 16
a546 1
        len = ListValuatorInfo(dev, (xXIValuatorInfo*)any, i, rc == Success);
d555 1
a555 1
SwapDeviceInfo(DeviceIntPtr dev, xXIDeviceInfo* info)
d557 1
a557 2
    char n;
    char *any = (char*)&info[1];
d563 20
a582 14
    for (i = 0; i < info->num_classes; i++)
    {
        int len = ((xXIAnyInfo*)any)->length;
        switch(((xXIAnyInfo*)any)->type)
        {
            case XIButtonClass:
                SwapButtonInfo(dev, (xXIButtonInfo*)any);
                break;
            case XIKeyClass:
                SwapKeyInfo(dev, (xXIKeyInfo*)any);
                break;
            case XIValuatorClass:
                SwapValuatorInfo(dev, (xXIValuatorInfo*)any);
                break;
d588 5
a592 5
    swaps(&info->deviceid, n);
    swaps(&info->use, n);
    swaps(&info->attachment, n);
    swaps(&info->num_classes, n);
    swaps(&info->name_len, n);
@


1.3
log
@WriteReplyToClient() swaps rep contents if client and server endianess
differ. Cache rep.length so that it can be used after returning from
WriteReplyToClient().
Fixes xinput --list when client and server have different endianess.
gtk3-demo now fails a bit further in this case.
@
text
@d110 2
a111 1
    if (!info)
d113 1
d157 2
a158 1
    len = rep.length*4;
d355 1
a355 1
    info->mode = v->mode; /* Server doesn't have per-axis mode yet */
d381 1
a381 1
    DeviceIntPtr master = dev->u.master;
d389 1
a389 1
    } else if (master)
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d155 1
a155 1

d157 1
a157 1
    WriteToClient(client, rep.length * 4, ptr);
@


1.1
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d90 1
a90 1
        skip = xcalloc(sizeof(Bool), inputInfo.numDevices);
d109 1
a109 1
    info = xcalloc(1, len);
d158 2
a159 2
    xfree(ptr);
    xfree(skip);
d250 3
d265 1
a265 1
	for (i = 0; dev && dev->button && i < dev->button->numButtons; i++)
@

