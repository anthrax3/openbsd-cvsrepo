head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	vcnjRBuLQw44cPHf;

1.7
date	2014.09.27.17.52.59;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches
	1.6.4.1
	1.6.6.1;
next	1.5;

1.5
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.09.06.19.44.20;	author matthieu;	state Exp;
branches;
next	;

1.6.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.6.6.1
date	2014.12.09.17.59.32;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright © 2006 Keith Packard
 * Copyright © 2008 Peter Hutterer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WAXIANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WAXIANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

/* This code is a modified version of randr/rrproperty.c */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "dix.h"
#include "inputstr.h"
#include <X11/extensions/XI.h>
#include <X11/Xatom.h>
#include <X11/extensions/XIproto.h>
#include <X11/extensions/XI2proto.h>
#include "exglobals.h"
#include "exevents.h"
#include "swaprep.h"

#include "xiproperty.h"
#include "xserver-properties.h"

/**
 * Properties used or alloced from inside the server.
 */
static struct dev_properties {
    Atom type;
    const char *name;
} dev_properties[] = {
    {0, XI_PROP_ENABLED},
    {0, XI_PROP_XTEST_DEVICE},
    {0, XATOM_FLOAT},
    {0, ACCEL_PROP_PROFILE_NUMBER},
    {0, ACCEL_PROP_CONSTANT_DECELERATION},
    {0, ACCEL_PROP_ADAPTIVE_DECELERATION},
    {0, ACCEL_PROP_VELOCITY_SCALING},
    {0, AXIS_LABEL_PROP},
    {0, AXIS_LABEL_PROP_REL_X},
    {0, AXIS_LABEL_PROP_REL_Y},
    {0, AXIS_LABEL_PROP_REL_Z},
    {0, AXIS_LABEL_PROP_REL_RX},
    {0, AXIS_LABEL_PROP_REL_RY},
    {0, AXIS_LABEL_PROP_REL_RZ},
    {0, AXIS_LABEL_PROP_REL_HWHEEL},
    {0, AXIS_LABEL_PROP_REL_DIAL},
    {0, AXIS_LABEL_PROP_REL_WHEEL},
    {0, AXIS_LABEL_PROP_REL_MISC},
    {0, AXIS_LABEL_PROP_REL_VSCROLL},
    {0, AXIS_LABEL_PROP_REL_HSCROLL},
    {0, AXIS_LABEL_PROP_ABS_X},
    {0, AXIS_LABEL_PROP_ABS_Y},
    {0, AXIS_LABEL_PROP_ABS_Z},
    {0, AXIS_LABEL_PROP_ABS_RX},
    {0, AXIS_LABEL_PROP_ABS_RY},
    {0, AXIS_LABEL_PROP_ABS_RZ},
    {0, AXIS_LABEL_PROP_ABS_THROTTLE},
    {0, AXIS_LABEL_PROP_ABS_RUDDER},
    {0, AXIS_LABEL_PROP_ABS_WHEEL},
    {0, AXIS_LABEL_PROP_ABS_GAS},
    {0, AXIS_LABEL_PROP_ABS_BRAKE},
    {0, AXIS_LABEL_PROP_ABS_HAT0X},
    {0, AXIS_LABEL_PROP_ABS_HAT0Y},
    {0, AXIS_LABEL_PROP_ABS_HAT1X},
    {0, AXIS_LABEL_PROP_ABS_HAT1Y},
    {0, AXIS_LABEL_PROP_ABS_HAT2X},
    {0, AXIS_LABEL_PROP_ABS_HAT2Y},
    {0, AXIS_LABEL_PROP_ABS_HAT3X},
    {0, AXIS_LABEL_PROP_ABS_HAT3Y},
    {0, AXIS_LABEL_PROP_ABS_PRESSURE},
    {0, AXIS_LABEL_PROP_ABS_DISTANCE},
    {0, AXIS_LABEL_PROP_ABS_TILT_X},
    {0, AXIS_LABEL_PROP_ABS_TILT_Y},
    {0, AXIS_LABEL_PROP_ABS_TOOL_WIDTH},
    {0, AXIS_LABEL_PROP_ABS_VOLUME},
    {0, AXIS_LABEL_PROP_ABS_MT_TOUCH_MAJOR},
    {0, AXIS_LABEL_PROP_ABS_MT_TOUCH_MINOR},
    {0, AXIS_LABEL_PROP_ABS_MT_WIDTH_MAJOR},
    {0, AXIS_LABEL_PROP_ABS_MT_WIDTH_MINOR},
    {0, AXIS_LABEL_PROP_ABS_MT_ORIENTATION},
    {0, AXIS_LABEL_PROP_ABS_MT_POSITION_X},
    {0, AXIS_LABEL_PROP_ABS_MT_POSITION_Y},
    {0, AXIS_LABEL_PROP_ABS_MT_TOOL_TYPE},
    {0, AXIS_LABEL_PROP_ABS_MT_BLOB_ID},
    {0, AXIS_LABEL_PROP_ABS_MT_TRACKING_ID},
    {0, AXIS_LABEL_PROP_ABS_MT_PRESSURE},
    {0, AXIS_LABEL_PROP_ABS_MT_DISTANCE},
    {0, AXIS_LABEL_PROP_ABS_MT_TOOL_X},
    {0, AXIS_LABEL_PROP_ABS_MT_TOOL_Y},
    {0, AXIS_LABEL_PROP_ABS_MISC},
    {0, BTN_LABEL_PROP},
    {0, BTN_LABEL_PROP_BTN_UNKNOWN},
    {0, BTN_LABEL_PROP_BTN_WHEEL_UP},
    {0, BTN_LABEL_PROP_BTN_WHEEL_DOWN},
    {0, BTN_LABEL_PROP_BTN_HWHEEL_LEFT},
    {0, BTN_LABEL_PROP_BTN_HWHEEL_RIGHT},
    {0, BTN_LABEL_PROP_BTN_0},
    {0, BTN_LABEL_PROP_BTN_1},
    {0, BTN_LABEL_PROP_BTN_2},
    {0, BTN_LABEL_PROP_BTN_3},
    {0, BTN_LABEL_PROP_BTN_4},
    {0, BTN_LABEL_PROP_BTN_5},
    {0, BTN_LABEL_PROP_BTN_6},
    {0, BTN_LABEL_PROP_BTN_7},
    {0, BTN_LABEL_PROP_BTN_8},
    {0, BTN_LABEL_PROP_BTN_9},
    {0, BTN_LABEL_PROP_BTN_LEFT},
    {0, BTN_LABEL_PROP_BTN_RIGHT},
    {0, BTN_LABEL_PROP_BTN_MIDDLE},
    {0, BTN_LABEL_PROP_BTN_SIDE},
    {0, BTN_LABEL_PROP_BTN_EXTRA},
    {0, BTN_LABEL_PROP_BTN_FORWARD},
    {0, BTN_LABEL_PROP_BTN_BACK},
    {0, BTN_LABEL_PROP_BTN_TASK},
    {0, BTN_LABEL_PROP_BTN_TRIGGER},
    {0, BTN_LABEL_PROP_BTN_THUMB},
    {0, BTN_LABEL_PROP_BTN_THUMB2},
    {0, BTN_LABEL_PROP_BTN_TOP},
    {0, BTN_LABEL_PROP_BTN_TOP2},
    {0, BTN_LABEL_PROP_BTN_PINKIE},
    {0, BTN_LABEL_PROP_BTN_BASE},
    {0, BTN_LABEL_PROP_BTN_BASE2},
    {0, BTN_LABEL_PROP_BTN_BASE3},
    {0, BTN_LABEL_PROP_BTN_BASE4},
    {0, BTN_LABEL_PROP_BTN_BASE5},
    {0, BTN_LABEL_PROP_BTN_BASE6},
    {0, BTN_LABEL_PROP_BTN_DEAD},
    {0, BTN_LABEL_PROP_BTN_A},
    {0, BTN_LABEL_PROP_BTN_B},
    {0, BTN_LABEL_PROP_BTN_C},
    {0, BTN_LABEL_PROP_BTN_X},
    {0, BTN_LABEL_PROP_BTN_Y},
    {0, BTN_LABEL_PROP_BTN_Z},
    {0, BTN_LABEL_PROP_BTN_TL},
    {0, BTN_LABEL_PROP_BTN_TR},
    {0, BTN_LABEL_PROP_BTN_TL2},
    {0, BTN_LABEL_PROP_BTN_TR2},
    {0, BTN_LABEL_PROP_BTN_SELECT},
    {0, BTN_LABEL_PROP_BTN_START},
    {0, BTN_LABEL_PROP_BTN_MODE},
    {0, BTN_LABEL_PROP_BTN_THUMBL},
    {0, BTN_LABEL_PROP_BTN_THUMBR},
    {0, BTN_LABEL_PROP_BTN_TOOL_PEN},
    {0, BTN_LABEL_PROP_BTN_TOOL_RUBBER},
    {0, BTN_LABEL_PROP_BTN_TOOL_BRUSH},
    {0, BTN_LABEL_PROP_BTN_TOOL_PENCIL},
    {0, BTN_LABEL_PROP_BTN_TOOL_AIRBRUSH},
    {0, BTN_LABEL_PROP_BTN_TOOL_FINGER},
    {0, BTN_LABEL_PROP_BTN_TOOL_MOUSE},
    {0, BTN_LABEL_PROP_BTN_TOOL_LENS},
    {0, BTN_LABEL_PROP_BTN_TOUCH},
    {0, BTN_LABEL_PROP_BTN_STYLUS},
    {0, BTN_LABEL_PROP_BTN_STYLUS2},
    {0, BTN_LABEL_PROP_BTN_TOOL_DOUBLETAP},
    {0, BTN_LABEL_PROP_BTN_TOOL_TRIPLETAP},
    {0, BTN_LABEL_PROP_BTN_GEAR_DOWN},
    {0, BTN_LABEL_PROP_BTN_GEAR_UP},
    {0, XI_PROP_TRANSFORM}
};

static long XIPropHandlerID = 1;

static void
send_property_event(DeviceIntPtr dev, Atom property, int what)
{
    int state = (what == XIPropertyDeleted) ? PropertyDelete : PropertyNewValue;
    devicePropertyNotify event = {
        .type = DevicePropertyNotify,
        .deviceid = dev->id,
        .state = state,
        .atom = property,
        .time = currentTime.milliseconds
    };
    xXIPropertyEvent xi2 = {
        .type = GenericEvent,
        .extension = IReqCode,
        .length = 0,
        .evtype = XI_PropertyEvent,
        .deviceid = dev->id,
        .time = currentTime.milliseconds,
        .property = property,
        .what = what
    };

    SendEventToAllWindows(dev, DevicePropertyNotifyMask, (xEvent *) &event, 1);

    SendEventToAllWindows(dev, GetEventFilter(dev, (xEvent *) &xi2),
                          (xEvent *) &xi2, 1);
}

static int
list_atoms(DeviceIntPtr dev, int *natoms, Atom **atoms_return)
{
    XIPropertyPtr prop;
    Atom *atoms = NULL;
    int nprops = 0;

    for (prop = dev->properties.properties; prop; prop = prop->next)
        nprops++;
    if (nprops) {
        Atom *a;

        atoms = xallocarray(nprops, sizeof(Atom));
        if (!atoms)
            return BadAlloc;
        a = atoms;
        for (prop = dev->properties.properties; prop; prop = prop->next, a++)
            *a = prop->propertyName;
    }

    *natoms = nprops;
    *atoms_return = atoms;
    return Success;
}

static int
get_property(ClientPtr client, DeviceIntPtr dev, Atom property, Atom type,
             BOOL delete, int offset, int length,
             int *bytes_after, Atom *type_return, int *format, int *nitems,
             int *length_return, char **data)
{
    unsigned long n, len, ind;
    int rc;
    XIPropertyPtr prop;
    XIPropertyValuePtr prop_value;

    if (!ValidAtom(property)) {
        client->errorValue = property;
        return BadAtom;
    }
    if ((delete != xTrue) && (delete != xFalse)) {
        client->errorValue = delete;
        return BadValue;
    }

    if ((type != AnyPropertyType) && !ValidAtom(type)) {
        client->errorValue = type;
        return BadAtom;
    }

    for (prop = dev->properties.properties; prop; prop = prop->next)
        if (prop->propertyName == property)
            break;

    if (!prop) {
        *bytes_after = 0;
        *type_return = None;
        *format = 0;
        *nitems = 0;
        *length_return = 0;
        return Success;
    }

    rc = XIGetDeviceProperty(dev, property, &prop_value);
    if (rc != Success) {
        client->errorValue = property;
        return rc;
    }

    /* If the request type and actual type don't match. Return the
       property information, but not the data. */

    if (((type != prop_value->type) && (type != AnyPropertyType))) {
        *bytes_after = prop_value->size;
        *format = prop_value->format;
        *length_return = 0;
        *nitems = 0;
        *type_return = prop_value->type;
        return Success;
    }

    /* Return type, format, value to client */
    n = (prop_value->format / 8) * prop_value->size;    /* size (bytes) of prop */
    ind = offset << 2;

    /* If offset is invalid such that it causes "len" to
       be negative, it's a value error. */

    if (n < ind) {
        client->errorValue = offset;
        return BadValue;
    }

    len = min(n - ind, 4 * length);

    *bytes_after = n - (ind + len);
    *format = prop_value->format;
    *length_return = len;
    if (prop_value->format)
        *nitems = len / (prop_value->format / 8);
    else
        *nitems = 0;
    *type_return = prop_value->type;

    *data = (char *) prop_value->data + ind;

    return Success;
}

static int
check_change_property(ClientPtr client, Atom property, Atom type, int format,
                      int mode, int nitems)
{
    if ((mode != PropModeReplace) && (mode != PropModeAppend) &&
        (mode != PropModePrepend)) {
        client->errorValue = mode;
        return BadValue;
    }
    if ((format != 8) && (format != 16) && (format != 32)) {
        client->errorValue = format;
        return BadValue;
    }

    if (!ValidAtom(property)) {
        client->errorValue = property;
        return BadAtom;
    }
    if (!ValidAtom(type)) {
        client->errorValue = type;
        return BadAtom;
    }

    return Success;
}

static int
change_property(ClientPtr client, DeviceIntPtr dev, Atom property, Atom type,
                int format, int mode, int len, void *data)
{
    int rc = Success;

    rc = XIChangeDeviceProperty(dev, property, type, format, mode, len, data,
                                TRUE);
    if (rc != Success)
        client->errorValue = property;

    return rc;
}

/**
 * Return the atom assigned to the specified string or 0 if the atom isn't known
 * to the DIX.
 *
 * If name is NULL, None is returned.
 */
Atom
XIGetKnownProperty(const char *name)
{
    int i;

    if (!name)
        return None;

    for (i = 0; i < (sizeof(dev_properties) / sizeof(struct dev_properties));
         i++) {
        if (strcmp(name, dev_properties[i].name) == 0) {
            if (dev_properties[i].type == None) {
                dev_properties[i].type =
                    MakeAtom(dev_properties[i].name,
                             strlen(dev_properties[i].name), TRUE);
            }

            return dev_properties[i].type;
        }
    }

    return 0;
}

void
XIResetProperties(void)
{
    int i;

    for (i = 0; i < (sizeof(dev_properties) / sizeof(struct dev_properties));
         i++)
        dev_properties[i].type = None;
}

/**
 * Convert the given property's value(s) into @@nelem_return integer values and
 * store them in @@buf_return. If @@nelem_return is larger than the number of
 * values in the property, @@nelem_return is set to the number of values in the
 * property.
 *
 * If *@@buf_return is NULL and @@nelem_return is 0, memory is allocated
 * automatically and must be freed by the caller.
 *
 * Possible return codes.
 * Success ... No error.
 * BadMatch ... Wrong atom type, atom is not XA_INTEGER
 * BadAlloc ... NULL passed as buffer and allocation failed.
 * BadLength ... @@buff is NULL but @@nelem_return is non-zero.
 *
 * @@param val The property value
 * @@param nelem_return The maximum number of elements to return.
 * @@param buf_return Pointer to an array of at least @@nelem_return values.
 * @@return Success or the error code if an error occured.
 */
_X_EXPORT int
XIPropToInt(XIPropertyValuePtr val, int *nelem_return, int **buf_return)
{
    int i;
    int *buf;

    if (val->type != XA_INTEGER)
        return BadMatch;
    if (!*buf_return && *nelem_return)
        return BadLength;

    switch (val->format) {
    case 8:
    case 16:
    case 32:
        break;
    default:
        return BadValue;
    }

    buf = *buf_return;

    if (!buf && !(*nelem_return)) {
        buf = calloc(val->size, sizeof(int));
        if (!buf)
            return BadAlloc;
        *buf_return = buf;
        *nelem_return = val->size;
    }
    else if (val->size < *nelem_return)
        *nelem_return = val->size;

    for (i = 0; i < val->size && i < *nelem_return; i++) {
        switch (val->format) {
        case 8:
            buf[i] = ((CARD8 *) val->data)[i];
            break;
        case 16:
            buf[i] = ((CARD16 *) val->data)[i];
            break;
        case 32:
            buf[i] = ((CARD32 *) val->data)[i];
            break;
        }
    }

    return Success;
}

/**
 * Convert the given property's value(s) into @@nelem_return float values and
 * store them in @@buf_return. If @@nelem_return is larger than the number of
 * values in the property, @@nelem_return is set to the number of values in the
 * property.
 *
 * If *@@buf_return is NULL and @@nelem_return is 0, memory is allocated
 * automatically and must be freed by the caller.
 *
 * Possible errors returned:
 * Success
 * BadMatch ... Wrong atom type, atom is not XA_FLOAT
 * BadValue ... Wrong format, format is not 32
 * BadAlloc ... NULL passed as buffer and allocation failed.
 * BadLength ... @@buff is NULL but @@nelem_return is non-zero.
 *
 * @@param val The property value
 * @@param nelem_return The maximum number of elements to return.
 * @@param buf_return Pointer to an array of at least @@nelem_return values.
 * @@return Success or the error code if an error occured.
 */
_X_EXPORT int
XIPropToFloat(XIPropertyValuePtr val, int *nelem_return, float **buf_return)
{
    int i;
    float *buf;

    if (!val->type || val->type != XIGetKnownProperty(XATOM_FLOAT))
        return BadMatch;

    if (val->format != 32)
        return BadValue;
    if (!*buf_return && *nelem_return)
        return BadLength;

    buf = *buf_return;

    if (!buf && !(*nelem_return)) {
        buf = calloc(val->size, sizeof(float));
        if (!buf)
            return BadAlloc;
        *buf_return = buf;
        *nelem_return = val->size;
    }
    else if (val->size < *nelem_return)
        *nelem_return = val->size;

    for (i = 0; i < val->size && i < *nelem_return; i++)
        buf[i] = ((float *) val->data)[i];

    return Success;
}

/* Registers a new property handler on the given device and returns a unique
 * identifier for this handler. This identifier is required to unregister the
 * property handler again.
 * @@return The handler's identifier or 0 if an error occured.
 */
long
XIRegisterPropertyHandler(DeviceIntPtr dev,
                          int (*SetProperty) (DeviceIntPtr dev,
                                              Atom property,
                                              XIPropertyValuePtr prop,
                                              BOOL checkonly),
                          int (*GetProperty) (DeviceIntPtr dev,
                                              Atom property),
                          int (*DeleteProperty) (DeviceIntPtr dev,
                                                 Atom property))
{
    XIPropertyHandlerPtr new_handler;

    new_handler = calloc(1, sizeof(XIPropertyHandler));
    if (!new_handler)
        return 0;

    new_handler->id = XIPropHandlerID++;
    new_handler->SetProperty = SetProperty;
    new_handler->GetProperty = GetProperty;
    new_handler->DeleteProperty = DeleteProperty;
    new_handler->next = dev->properties.handlers;
    dev->properties.handlers = new_handler;

    return new_handler->id;
}

void
XIUnregisterPropertyHandler(DeviceIntPtr dev, long id)
{
    XIPropertyHandlerPtr curr, prev = NULL;

    curr = dev->properties.handlers;
    while (curr && curr->id != id) {
        prev = curr;
        curr = curr->next;
    }

    if (!curr)
        return;

    if (!prev)                  /* first one */
        dev->properties.handlers = curr->next;
    else
        prev->next = curr->next;

    free(curr);
}

static XIPropertyPtr
XICreateDeviceProperty(Atom property)
{
    XIPropertyPtr prop;

    prop = (XIPropertyPtr) malloc(sizeof(XIPropertyRec));
    if (!prop)
        return NULL;

    prop->next = NULL;
    prop->propertyName = property;
    prop->value.type = None;
    prop->value.format = 0;
    prop->value.size = 0;
    prop->value.data = NULL;
    prop->deletable = TRUE;

    return prop;
}

static XIPropertyPtr
XIFetchDeviceProperty(DeviceIntPtr dev, Atom property)
{
    XIPropertyPtr prop;

    for (prop = dev->properties.properties; prop; prop = prop->next)
        if (prop->propertyName == property)
            return prop;
    return NULL;
}

static void
XIDestroyDeviceProperty(XIPropertyPtr prop)
{
    free(prop->value.data);
    free(prop);
}

/* This function destroys all of the device's property-related stuff,
 * including removing all device handlers.
 * DO NOT CALL FROM THE DRIVER.
 */
void
XIDeleteAllDeviceProperties(DeviceIntPtr device)
{
    XIPropertyPtr prop, next;
    XIPropertyHandlerPtr curr_handler, next_handler;

    for (prop = device->properties.properties; prop; prop = next) {
        next = prop->next;
        send_property_event(device, prop->propertyName, XIPropertyDeleted);
        XIDestroyDeviceProperty(prop);
    }

    device->properties.properties = NULL;

    /* Now free all handlers */
    curr_handler = device->properties.handlers;
    while (curr_handler) {
        next_handler = curr_handler->next;
        free(curr_handler);
        curr_handler = next_handler;
    }

    device->properties.handlers = NULL;
}

int
XIDeleteDeviceProperty(DeviceIntPtr device, Atom property, Bool fromClient)
{
    XIPropertyPtr prop, *prev;
    int rc = Success;

    for (prev = &device->properties.properties; (prop = *prev);
         prev = &(prop->next))
        if (prop->propertyName == property)
            break;

    if (!prop)
        return Success;

    if (fromClient && !prop->deletable)
        return BadAccess;

    /* Ask handlers if we may delete the property */
    if (device->properties.handlers) {
        XIPropertyHandlerPtr handler = device->properties.handlers;

        while (handler) {
            if (handler->DeleteProperty)
                rc = handler->DeleteProperty(device, prop->propertyName);
            if (rc != Success)
                return rc;
            handler = handler->next;
        }
    }

    if (prop) {
        *prev = prop->next;
        send_property_event(device, prop->propertyName, XIPropertyDeleted);
        XIDestroyDeviceProperty(prop);
    }

    return Success;
}

int
XIChangeDeviceProperty(DeviceIntPtr dev, Atom property, Atom type,
                       int format, int mode, unsigned long len,
                       const void *value, Bool sendevent)
{
    XIPropertyPtr prop;
    int size_in_bytes;
    unsigned long total_len;
    XIPropertyValuePtr prop_value;
    XIPropertyValueRec new_value;
    Bool add = FALSE;
    int rc;

    size_in_bytes = format >> 3;

    /* first see if property already exists */
    prop = XIFetchDeviceProperty(dev, property);
    if (!prop) {                /* just add to list */
        prop = XICreateDeviceProperty(property);
        if (!prop)
            return BadAlloc;
        add = TRUE;
        mode = PropModeReplace;
    }
    prop_value = &prop->value;

    /* To append or prepend to a property the request format and type
       must match those of the already defined property.  The
       existing format and type are irrelevant when using the mode
       "PropModeReplace" since they will be written over. */

    if ((format != prop_value->format) && (mode != PropModeReplace))
        return BadMatch;
    if ((prop_value->type != type) && (mode != PropModeReplace))
        return BadMatch;
    new_value = *prop_value;
    if (mode == PropModeReplace)
        total_len = len;
    else
        total_len = prop_value->size + len;

    if (mode == PropModeReplace || len > 0) {
        void *new_data = NULL, *old_data = NULL;

        new_value.data = xallocarray(total_len, size_in_bytes);
        if (!new_value.data && total_len && size_in_bytes) {
            if (add)
                XIDestroyDeviceProperty(prop);
            return BadAlloc;
        }
        new_value.size = len;
        new_value.type = type;
        new_value.format = format;

        switch (mode) {
        case PropModeReplace:
            new_data = new_value.data;
            old_data = NULL;
            break;
        case PropModeAppend:
            new_data = (void *) (((char *) new_value.data) +
                                  (prop_value->size * size_in_bytes));
            old_data = new_value.data;
            break;
        case PropModePrepend:
            new_data = new_value.data;
            old_data = (void *) (((char *) new_value.data) +
                                  (prop_value->size * size_in_bytes));
            break;
        }
        if (new_data)
            memcpy((char *) new_data, value, len * size_in_bytes);
        if (old_data)
            memcpy((char *) old_data, (char *) prop_value->data,
                   prop_value->size * size_in_bytes);

        if (dev->properties.handlers) {
            XIPropertyHandlerPtr handler;
            BOOL checkonly = TRUE;

            /* run through all handlers with checkonly TRUE, then again with
             * checkonly FALSE. Handlers MUST return error codes on the
             * checkonly run, errors on the second run are ignored */
            do {
                handler = dev->properties.handlers;
                while (handler) {
                    if (handler->SetProperty) {
                        rc = handler->SetProperty(dev, prop->propertyName,
                                                  &new_value, checkonly);
                        if (checkonly && rc != Success) {
                            free(new_value.data);
                            if (add)
                                XIDestroyDeviceProperty(prop);
                            return rc;
                        }
                    }
                    handler = handler->next;
                }
                checkonly = !checkonly;
            } while (!checkonly);
        }
        free(prop_value->data);
        *prop_value = new_value;
    }
    else if (len == 0) {
        /* do nothing */
    }

    if (add) {
        prop->next = dev->properties.properties;
        dev->properties.properties = prop;
    }

    if (sendevent)
        send_property_event(dev, prop->propertyName,
                            (add) ? XIPropertyCreated : XIPropertyModified);

    return Success;
}

int
XIGetDeviceProperty(DeviceIntPtr dev, Atom property, XIPropertyValuePtr *value)
{
    XIPropertyPtr prop = XIFetchDeviceProperty(dev, property);
    int rc;

    if (!prop) {
        *value = NULL;
        return BadAtom;
    }

    /* If we can, try to update the property value first */
    if (dev->properties.handlers) {
        XIPropertyHandlerPtr handler = dev->properties.handlers;

        while (handler) {
            if (handler->GetProperty) {
                rc = handler->GetProperty(dev, prop->propertyName);
                if (rc != Success) {
                    *value = NULL;
                    return rc;
                }
            }
            handler = handler->next;
        }
    }

    *value = &prop->value;
    return Success;
}

int
XISetDevicePropertyDeletable(DeviceIntPtr dev, Atom property, Bool deletable)
{
    XIPropertyPtr prop = XIFetchDeviceProperty(dev, property);

    if (!prop)
        return BadAtom;

    prop->deletable = deletable;
    return Success;
}

int
ProcXListDeviceProperties(ClientPtr client)
{
    Atom *atoms;
    xListDevicePropertiesReply rep;
    int natoms;
    DeviceIntPtr dev;
    int rc = Success;

    REQUEST(xListDevicePropertiesReq);
    REQUEST_SIZE_MATCH(xListDevicePropertiesReq);

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixListPropAccess);
    if (rc != Success)
        return rc;

    rc = list_atoms(dev, &natoms, &atoms);
    if (rc != Success)
        return rc;

    rep = (xListDevicePropertiesReply) {
        .repType = X_Reply,
        .RepType = X_ListDeviceProperties,
        .sequenceNumber = client->sequence,
        .length = natoms,
        .nAtoms = natoms
    };

    WriteReplyToClient(client, sizeof(xListDevicePropertiesReply), &rep);
    if (natoms) {
        client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
        WriteSwappedDataToClient(client, natoms * sizeof(Atom), atoms);
        free(atoms);
    }
    return rc;
}

int
ProcXChangeDeviceProperty(ClientPtr client)
{
    REQUEST(xChangeDevicePropertyReq);
    DeviceIntPtr dev;
    unsigned long len;
    int totalSize;
    int rc;

    REQUEST_AT_LEAST_SIZE(xChangeDevicePropertyReq);
    UpdateCurrentTime();

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixSetPropAccess);
    if (rc != Success)
        return rc;

    rc = check_change_property(client, stuff->property, stuff->type,
                               stuff->format, stuff->mode, stuff->nUnits);

    len = stuff->nUnits;
    if (len > (bytes_to_int32(0xffffffff - sizeof(xChangeDevicePropertyReq))))
        return BadLength;

    totalSize = len * (stuff->format / 8);
    REQUEST_FIXED_SIZE(xChangeDevicePropertyReq, totalSize);

    rc = change_property(client, dev, stuff->property, stuff->type,
                         stuff->format, stuff->mode, len, (void *) &stuff[1]);
    return rc;
}

int
ProcXDeleteDeviceProperty(ClientPtr client)
{
    REQUEST(xDeleteDevicePropertyReq);
    DeviceIntPtr dev;
    int rc;

    REQUEST_SIZE_MATCH(xDeleteDevicePropertyReq);
    UpdateCurrentTime();
    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixSetPropAccess);
    if (rc != Success)
        return rc;

    if (!ValidAtom(stuff->property)) {
        client->errorValue = stuff->property;
        return BadAtom;
    }

    rc = XIDeleteDeviceProperty(dev, stuff->property, TRUE);
    return rc;
}

int
ProcXGetDeviceProperty(ClientPtr client)
{
    REQUEST(xGetDevicePropertyReq);
    DeviceIntPtr dev;
    int length;
    int rc, format, nitems, bytes_after;
    char *data;
    Atom type;
    xGetDevicePropertyReply reply;

    REQUEST_SIZE_MATCH(xGetDevicePropertyReq);
    if (stuff->delete)
        UpdateCurrentTime();
    rc = dixLookupDevice(&dev, stuff->deviceid, client,
                         stuff->delete ? DixSetPropAccess : DixGetPropAccess);
    if (rc != Success)
        return rc;

    rc = get_property(client, dev, stuff->property, stuff->type,
                      stuff->delete, stuff->longOffset, stuff->longLength,
                      &bytes_after, &type, &format, &nitems, &length, &data);

    if (rc != Success)
        return rc;

    reply = (xGetDevicePropertyReply) {
        .repType = X_Reply,
        .RepType = X_GetDeviceProperty,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(length),
        .propertyType = type,
        .bytesAfter = bytes_after,
        .nItems = nitems,
        .format = format,
        .deviceid = dev->id
    };

    if (stuff->delete && (reply.bytesAfter == 0))
        send_property_event(dev, stuff->property, XIPropertyDeleted);

    WriteReplyToClient(client, sizeof(xGenericReply), &reply);

    if (length) {
        switch (reply.format) {
        case 32:
            client->pSwapReplyFunc = (ReplySwapPtr) CopySwap32Write;
            break;
        case 16:
            client->pSwapReplyFunc = (ReplySwapPtr) CopySwap16Write;
            break;
        default:
            client->pSwapReplyFunc = (ReplySwapPtr) WriteToClient;
            break;
        }
        WriteSwappedDataToClient(client, length, data);
    }

    /* delete the Property */
    if (stuff->delete && (reply.bytesAfter == 0)) {
        XIPropertyPtr prop, *prev;

        for (prev = &dev->properties.properties; (prop = *prev);
             prev = &prop->next) {
            if (prop->propertyName == stuff->property) {
                *prev = prop->next;
                XIDestroyDeviceProperty(prop);
                break;
            }
        }
    }
    return Success;
}

int
SProcXListDeviceProperties(ClientPtr client)
{
    REQUEST(xListDevicePropertiesReq);
    REQUEST_SIZE_MATCH(xListDevicePropertiesReq);

    swaps(&stuff->length);
    return (ProcXListDeviceProperties(client));
}

int
SProcXChangeDeviceProperty(ClientPtr client)
{
    REQUEST(xChangeDevicePropertyReq);

    REQUEST_AT_LEAST_SIZE(xChangeDevicePropertyReq);
    swaps(&stuff->length);
    swapl(&stuff->property);
    swapl(&stuff->type);
    swapl(&stuff->nUnits);
    return (ProcXChangeDeviceProperty(client));
}

int
SProcXDeleteDeviceProperty(ClientPtr client)
{
    REQUEST(xDeleteDevicePropertyReq);
    REQUEST_SIZE_MATCH(xDeleteDevicePropertyReq);

    swaps(&stuff->length);
    swapl(&stuff->property);
    return (ProcXDeleteDeviceProperty(client));
}

int
SProcXGetDeviceProperty(ClientPtr client)
{
    REQUEST(xGetDevicePropertyReq);
    REQUEST_SIZE_MATCH(xGetDevicePropertyReq);

    swaps(&stuff->length);
    swapl(&stuff->property);
    swapl(&stuff->type);
    swapl(&stuff->longOffset);
    swapl(&stuff->longLength);
    return (ProcXGetDeviceProperty(client));
}

/* Reply swapping */

void
SRepXListDeviceProperties(ClientPtr client, int size,
                          xListDevicePropertiesReply * rep)
{
    swaps(&rep->sequenceNumber);
    swapl(&rep->length);
    swaps(&rep->nAtoms);
    /* properties will be swapped later, see ProcXListDeviceProperties */
    WriteToClient(client, size, rep);
}

void
SRepXGetDeviceProperty(ClientPtr client, int size,
                       xGetDevicePropertyReply * rep)
{
    swaps(&rep->sequenceNumber);
    swapl(&rep->length);
    swapl(&rep->propertyType);
    swapl(&rep->bytesAfter);
    swapl(&rep->nItems);
    /* data will be swapped, see ProcXGetDeviceProperty */
    WriteToClient(client, size, rep);
}

/* XI2 Request/reply handling */
int
ProcXIListProperties(ClientPtr client)
{
    Atom *atoms;
    xXIListPropertiesReply rep;
    int natoms;
    DeviceIntPtr dev;
    int rc = Success;

    REQUEST(xXIListPropertiesReq);
    REQUEST_SIZE_MATCH(xXIListPropertiesReq);

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixListPropAccess);
    if (rc != Success)
        return rc;

    rc = list_atoms(dev, &natoms, &atoms);
    if (rc != Success)
        return rc;

    rep = (xXIListPropertiesReply) {
        .repType = X_Reply,
        .RepType = X_XIListProperties,
        .sequenceNumber = client->sequence,
        .length = natoms,
        .num_properties = natoms
    };

    WriteReplyToClient(client, sizeof(xXIListPropertiesReply), &rep);
    if (natoms) {
        client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
        WriteSwappedDataToClient(client, natoms * sizeof(Atom), atoms);
        free(atoms);
    }
    return rc;
}

int
ProcXIChangeProperty(ClientPtr client)
{
    int rc;
    DeviceIntPtr dev;
    int totalSize;
    unsigned long len;

    REQUEST(xXIChangePropertyReq);
    REQUEST_AT_LEAST_SIZE(xXIChangePropertyReq);
    UpdateCurrentTime();

    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixSetPropAccess);
    if (rc != Success)
        return rc;

    rc = check_change_property(client, stuff->property, stuff->type,
                               stuff->format, stuff->mode, stuff->num_items);
    len = stuff->num_items;
    if (len > bytes_to_int32(0xffffffff - sizeof(xXIChangePropertyReq)))
        return BadLength;

    totalSize = len * (stuff->format / 8);
    REQUEST_FIXED_SIZE(xXIChangePropertyReq, totalSize);

    rc = change_property(client, dev, stuff->property, stuff->type,
                         stuff->format, stuff->mode, len, (void *) &stuff[1]);
    return rc;
}

int
ProcXIDeleteProperty(ClientPtr client)
{
    DeviceIntPtr dev;
    int rc;

    REQUEST(xXIDeletePropertyReq);

    REQUEST_SIZE_MATCH(xXIDeletePropertyReq);
    UpdateCurrentTime();
    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixSetPropAccess);
    if (rc != Success)
        return rc;

    if (!ValidAtom(stuff->property)) {
        client->errorValue = stuff->property;
        return BadAtom;
    }

    rc = XIDeleteDeviceProperty(dev, stuff->property, TRUE);
    return rc;
}

int
ProcXIGetProperty(ClientPtr client)
{
    REQUEST(xXIGetPropertyReq);
    DeviceIntPtr dev;
    xXIGetPropertyReply reply;
    int length;
    int rc, format, nitems, bytes_after;
    char *data;
    Atom type;

    REQUEST_SIZE_MATCH(xXIGetPropertyReq);
    if (stuff->delete)
        UpdateCurrentTime();
    rc = dixLookupDevice(&dev, stuff->deviceid, client,
                         stuff->delete ? DixSetPropAccess : DixGetPropAccess);
    if (rc != Success)
        return rc;

    rc = get_property(client, dev, stuff->property, stuff->type,
                      stuff->delete, stuff->offset, stuff->len,
                      &bytes_after, &type, &format, &nitems, &length, &data);

    if (rc != Success)
        return rc;

    reply = (xXIGetPropertyReply) {
        .repType = X_Reply,
        .RepType = X_XIGetProperty,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(length),
        .type = type,
        .bytes_after = bytes_after,
        .num_items = nitems,
        .format = format
    };

    if (length && stuff->delete && (reply.bytes_after == 0))
        send_property_event(dev, stuff->property, XIPropertyDeleted);

    WriteReplyToClient(client, sizeof(xXIGetPropertyReply), &reply);

    if (length) {
        switch (reply.format) {
        case 32:
            client->pSwapReplyFunc = (ReplySwapPtr) CopySwap32Write;
            break;
        case 16:
            client->pSwapReplyFunc = (ReplySwapPtr) CopySwap16Write;
            break;
        default:
            client->pSwapReplyFunc = (ReplySwapPtr) WriteToClient;
            break;
        }
        WriteSwappedDataToClient(client, length, data);
    }

    /* delete the Property */
    if (stuff->delete && (reply.bytes_after == 0)) {
        XIPropertyPtr prop, *prev;

        for (prev = &dev->properties.properties; (prop = *prev);
             prev = &prop->next) {
            if (prop->propertyName == stuff->property) {
                *prev = prop->next;
                XIDestroyDeviceProperty(prop);
                break;
            }
        }
    }

    return Success;
}

int
SProcXIListProperties(ClientPtr client)
{
    REQUEST(xXIListPropertiesReq);
    REQUEST_SIZE_MATCH(xXIListPropertiesReq);

    swaps(&stuff->length);
    swaps(&stuff->deviceid);
    return (ProcXIListProperties(client));
}

int
SProcXIChangeProperty(ClientPtr client)
{
    REQUEST(xXIChangePropertyReq);

    REQUEST_AT_LEAST_SIZE(xXIChangePropertyReq);
    swaps(&stuff->length);
    swaps(&stuff->deviceid);
    swapl(&stuff->property);
    swapl(&stuff->type);
    swapl(&stuff->num_items);
    return (ProcXIChangeProperty(client));
}

int
SProcXIDeleteProperty(ClientPtr client)
{
    REQUEST(xXIDeletePropertyReq);
    REQUEST_SIZE_MATCH(xXIDeletePropertyReq);

    swaps(&stuff->length);
    swaps(&stuff->deviceid);
    swapl(&stuff->property);
    return (ProcXIDeleteProperty(client));
}

int
SProcXIGetProperty(ClientPtr client)
{
    REQUEST(xXIGetPropertyReq);
    REQUEST_SIZE_MATCH(xXIGetPropertyReq);

    swaps(&stuff->length);
    swaps(&stuff->deviceid);
    swapl(&stuff->property);
    swapl(&stuff->type);
    swapl(&stuff->offset);
    swapl(&stuff->len);
    return (ProcXIGetProperty(client));
}

void
SRepXIListProperties(ClientPtr client, int size, xXIListPropertiesReply * rep)
{
    swaps(&rep->sequenceNumber);
    swapl(&rep->length);
    swaps(&rep->num_properties);
    /* properties will be swapped later, see ProcXIListProperties */
    WriteToClient(client, size, rep);
}

void
SRepXIGetProperty(ClientPtr client, int size, xXIGetPropertyReply * rep)
{
    swaps(&rep->sequenceNumber);
    swapl(&rep->length);
    swapl(&rep->type);
    swapl(&rep->bytes_after);
    swapl(&rep->num_items);
    /* data will be swapped, see ProcXIGetProperty */
    WriteToClient(client, size, rep);
}
@


1.8
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d224 1
a224 1
        atoms = malloc(nprops * sizeof(Atom));
a689 1
    int total_size;
d727 2
a728 3
        total_size = total_len * size_in_bytes;
        new_value.data = (void *) malloc(total_size);
        if (!new_value.data && total_size) {
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1016 1
a1018 2

    REQUEST_SIZE_MATCH(xListDevicePropertiesReq);
d1039 1
a1042 1
    REQUEST_SIZE_MATCH(xDeleteDevicePropertyReq);
d1050 1
a1056 1
    REQUEST_SIZE_MATCH(xGetDevicePropertyReq);
d1255 1
a1258 2

    REQUEST_SIZE_MATCH(xXIListPropertiesReq);
d1280 1
a1284 1
    REQUEST_SIZE_MATCH(xXIDeletePropertyReq);
d1292 1
a1299 1
    REQUEST_SIZE_MATCH(xXIGetPropertyReq);
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d726 1
a726 1
        pointer new_data = NULL, old_data = NULL;
d729 1
a729 1
        new_value.data = (pointer) malloc(total_size);
d745 1
a745 1
            new_data = (pointer) (((char *) new_value.data) +
d751 1
a751 1
            old_data = (pointer) (((char *) new_value.data) +
@


1.6.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a1015 1
    REQUEST_SIZE_MATCH(xListDevicePropertiesReq);
d1018 2
a1039 1
    REQUEST_SIZE_MATCH(xDeleteDevicePropertyReq);
d1043 1
a1050 1
    REQUEST_SIZE_MATCH(xGetDevicePropertyReq);
d1057 1
a1255 1
    REQUEST_SIZE_MATCH(xXIListPropertiesReq);
d1259 2
a1281 1
    REQUEST_SIZE_MATCH(xXIDeletePropertyReq);
d1286 1
a1293 1
    REQUEST_SIZE_MATCH(xXIGetPropertyReq);
d1301 1
@


1.6.6.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a1015 1
    REQUEST_SIZE_MATCH(xListDevicePropertiesReq);
d1018 2
a1039 1
    REQUEST_SIZE_MATCH(xDeleteDevicePropertyReq);
d1043 1
a1050 1
    REQUEST_SIZE_MATCH(xGetDevicePropertyReq);
d1057 1
a1255 1
    REQUEST_SIZE_MATCH(xXIListPropertiesReq);
d1259 2
a1281 1
    REQUEST_SIZE_MATCH(xXIDeletePropertyReq);
d1286 1
a1293 1
    REQUEST_SIZE_MATCH(xXIGetPropertyReq);
d1301 1
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d52 128
a179 126
    {
    0, XI_PROP_ENABLED}, {
    0, XI_PROP_XTEST_DEVICE}, {
    0, XATOM_FLOAT}, {
    0, ACCEL_PROP_PROFILE_NUMBER}, {
    0, ACCEL_PROP_CONSTANT_DECELERATION}, {
    0, ACCEL_PROP_ADAPTIVE_DECELERATION}, {
    0, ACCEL_PROP_VELOCITY_SCALING}, {
    0, AXIS_LABEL_PROP}, {
    0, AXIS_LABEL_PROP_REL_X}, {
    0, AXIS_LABEL_PROP_REL_Y}, {
    0, AXIS_LABEL_PROP_REL_Z}, {
    0, AXIS_LABEL_PROP_REL_RX}, {
    0, AXIS_LABEL_PROP_REL_RY}, {
    0, AXIS_LABEL_PROP_REL_RZ}, {
    0, AXIS_LABEL_PROP_REL_HWHEEL}, {
    0, AXIS_LABEL_PROP_REL_DIAL}, {
    0, AXIS_LABEL_PROP_REL_WHEEL}, {
    0, AXIS_LABEL_PROP_REL_MISC}, {
    0, AXIS_LABEL_PROP_REL_VSCROLL}, {
    0, AXIS_LABEL_PROP_REL_HSCROLL}, {
    0, AXIS_LABEL_PROP_ABS_X}, {
    0, AXIS_LABEL_PROP_ABS_Y}, {
    0, AXIS_LABEL_PROP_ABS_Z}, {
    0, AXIS_LABEL_PROP_ABS_RX}, {
    0, AXIS_LABEL_PROP_ABS_RY}, {
    0, AXIS_LABEL_PROP_ABS_RZ}, {
    0, AXIS_LABEL_PROP_ABS_THROTTLE}, {
    0, AXIS_LABEL_PROP_ABS_RUDDER}, {
    0, AXIS_LABEL_PROP_ABS_WHEEL}, {
    0, AXIS_LABEL_PROP_ABS_GAS}, {
    0, AXIS_LABEL_PROP_ABS_BRAKE}, {
    0, AXIS_LABEL_PROP_ABS_HAT0X}, {
    0, AXIS_LABEL_PROP_ABS_HAT0Y}, {
    0, AXIS_LABEL_PROP_ABS_HAT1X}, {
    0, AXIS_LABEL_PROP_ABS_HAT1Y}, {
    0, AXIS_LABEL_PROP_ABS_HAT2X}, {
    0, AXIS_LABEL_PROP_ABS_HAT2Y}, {
    0, AXIS_LABEL_PROP_ABS_HAT3X}, {
    0, AXIS_LABEL_PROP_ABS_HAT3Y}, {
    0, AXIS_LABEL_PROP_ABS_PRESSURE}, {
    0, AXIS_LABEL_PROP_ABS_DISTANCE}, {
    0, AXIS_LABEL_PROP_ABS_TILT_X}, {
    0, AXIS_LABEL_PROP_ABS_TILT_Y}, {
    0, AXIS_LABEL_PROP_ABS_TOOL_WIDTH}, {
    0, AXIS_LABEL_PROP_ABS_VOLUME}, {
    0, AXIS_LABEL_PROP_ABS_MT_TOUCH_MAJOR}, {
    0, AXIS_LABEL_PROP_ABS_MT_TOUCH_MINOR}, {
    0, AXIS_LABEL_PROP_ABS_MT_WIDTH_MAJOR}, {
    0, AXIS_LABEL_PROP_ABS_MT_WIDTH_MINOR}, {
    0, AXIS_LABEL_PROP_ABS_MT_ORIENTATION}, {
    0, AXIS_LABEL_PROP_ABS_MT_POSITION_X}, {
    0, AXIS_LABEL_PROP_ABS_MT_POSITION_Y}, {
    0, AXIS_LABEL_PROP_ABS_MT_TOOL_TYPE}, {
    0, AXIS_LABEL_PROP_ABS_MT_BLOB_ID}, {
    0, AXIS_LABEL_PROP_ABS_MT_TRACKING_ID}, {
    0, AXIS_LABEL_PROP_ABS_MT_PRESSURE}, {
    0, AXIS_LABEL_PROP_ABS_MISC}, {
    0, BTN_LABEL_PROP}, {
    0, BTN_LABEL_PROP_BTN_UNKNOWN}, {
    0, BTN_LABEL_PROP_BTN_WHEEL_UP}, {
    0, BTN_LABEL_PROP_BTN_WHEEL_DOWN}, {
    0, BTN_LABEL_PROP_BTN_HWHEEL_LEFT}, {
    0, BTN_LABEL_PROP_BTN_HWHEEL_RIGHT}, {
    0, BTN_LABEL_PROP_BTN_0}, {
    0, BTN_LABEL_PROP_BTN_1}, {
    0, BTN_LABEL_PROP_BTN_2}, {
    0, BTN_LABEL_PROP_BTN_3}, {
    0, BTN_LABEL_PROP_BTN_4}, {
    0, BTN_LABEL_PROP_BTN_5}, {
    0, BTN_LABEL_PROP_BTN_6}, {
    0, BTN_LABEL_PROP_BTN_7}, {
    0, BTN_LABEL_PROP_BTN_8}, {
    0, BTN_LABEL_PROP_BTN_9}, {
    0, BTN_LABEL_PROP_BTN_LEFT}, {
    0, BTN_LABEL_PROP_BTN_RIGHT}, {
    0, BTN_LABEL_PROP_BTN_MIDDLE}, {
    0, BTN_LABEL_PROP_BTN_SIDE}, {
    0, BTN_LABEL_PROP_BTN_EXTRA}, {
    0, BTN_LABEL_PROP_BTN_FORWARD}, {
    0, BTN_LABEL_PROP_BTN_BACK}, {
    0, BTN_LABEL_PROP_BTN_TASK}, {
    0, BTN_LABEL_PROP_BTN_TRIGGER}, {
    0, BTN_LABEL_PROP_BTN_THUMB}, {
    0, BTN_LABEL_PROP_BTN_THUMB2}, {
    0, BTN_LABEL_PROP_BTN_TOP}, {
    0, BTN_LABEL_PROP_BTN_TOP2}, {
    0, BTN_LABEL_PROP_BTN_PINKIE}, {
    0, BTN_LABEL_PROP_BTN_BASE}, {
    0, BTN_LABEL_PROP_BTN_BASE2}, {
    0, BTN_LABEL_PROP_BTN_BASE3}, {
    0, BTN_LABEL_PROP_BTN_BASE4}, {
    0, BTN_LABEL_PROP_BTN_BASE5}, {
    0, BTN_LABEL_PROP_BTN_BASE6}, {
    0, BTN_LABEL_PROP_BTN_DEAD}, {
    0, BTN_LABEL_PROP_BTN_A}, {
    0, BTN_LABEL_PROP_BTN_B}, {
    0, BTN_LABEL_PROP_BTN_C}, {
    0, BTN_LABEL_PROP_BTN_X}, {
    0, BTN_LABEL_PROP_BTN_Y}, {
    0, BTN_LABEL_PROP_BTN_Z}, {
    0, BTN_LABEL_PROP_BTN_TL}, {
    0, BTN_LABEL_PROP_BTN_TR}, {
    0, BTN_LABEL_PROP_BTN_TL2}, {
    0, BTN_LABEL_PROP_BTN_TR2}, {
    0, BTN_LABEL_PROP_BTN_SELECT}, {
    0, BTN_LABEL_PROP_BTN_START}, {
    0, BTN_LABEL_PROP_BTN_MODE}, {
    0, BTN_LABEL_PROP_BTN_THUMBL}, {
    0, BTN_LABEL_PROP_BTN_THUMBR}, {
    0, BTN_LABEL_PROP_BTN_TOOL_PEN}, {
    0, BTN_LABEL_PROP_BTN_TOOL_RUBBER}, {
    0, BTN_LABEL_PROP_BTN_TOOL_BRUSH}, {
    0, BTN_LABEL_PROP_BTN_TOOL_PENCIL}, {
    0, BTN_LABEL_PROP_BTN_TOOL_AIRBRUSH}, {
    0, BTN_LABEL_PROP_BTN_TOOL_FINGER}, {
    0, BTN_LABEL_PROP_BTN_TOOL_MOUSE}, {
    0, BTN_LABEL_PROP_BTN_TOOL_LENS}, {
    0, BTN_LABEL_PROP_BTN_TOUCH}, {
    0, BTN_LABEL_PROP_BTN_STYLUS}, {
    0, BTN_LABEL_PROP_BTN_STYLUS2}, {
    0, BTN_LABEL_PROP_BTN_TOOL_DOUBLETAP}, {
    0, BTN_LABEL_PROP_BTN_TOOL_TRIPLETAP}, {
    0, BTN_LABEL_PROP_BTN_GEAR_DOWN}, {
    0, BTN_LABEL_PROP_BTN_GEAR_UP}, {
    0, XI_PROP_TRANSFORM}
d187 18
a204 3
    devicePropertyNotify event;
    xXIPropertyEvent xi2;
    int state;
a205 10
    if (what == XIPropertyDeleted)
        state = PropertyDelete;
    else
        state = PropertyNewValue;

    event.type = DevicePropertyNotify;
    event.deviceid = dev->id;
    event.state = state;
    event.atom = property;
    event.time = currentTime.milliseconds;
a207 8
    xi2.type = GenericEvent;
    xi2.extension = IReqCode;
    xi2.length = 0;
    xi2.evtype = XI_PropertyEvent;
    xi2.deviceid = dev->id;
    xi2.time = currentTime.milliseconds;
    xi2.property = property;
    xi2.what = what;
d756 1
a756 1
            memcpy((char *) new_data, (char *) value, len * size_in_bytes);
d776 2
d868 7
a874 5
    rep.repType = X_Reply;
    rep.RepType = X_ListDeviceProperties;
    rep.length = natoms;
    rep.sequenceNumber = client->sequence;
    rep.nAtoms = natoms;
d964 11
a974 9
    reply.repType = X_Reply;
    reply.RepType = X_GetDeviceProperty;
    reply.sequenceNumber = client->sequence;
    reply.deviceid = dev->id;
    reply.nItems = nitems;
    reply.format = format;
    reply.bytesAfter = bytes_after;
    reply.propertyType = type;
    reply.length = bytes_to_int32(length);
d1071 1
a1071 1
    WriteToClient(client, size, (char *) rep);
d1084 1
a1084 1
    WriteToClient(client, size, (char *) rep);
d1108 7
a1114 5
    rep.repType = X_Reply;
    rep.RepType = X_XIListProperties;
    rep.length = natoms;
    rep.sequenceNumber = client->sequence;
    rep.num_properties = natoms;
d1204 10
a1213 8
    reply.repType = X_Reply;
    reply.RepType = X_XIGetProperty;
    reply.sequenceNumber = client->sequence;
    reply.num_items = nitems;
    reply.format = format;
    reply.bytes_after = bytes_after;
    reply.type = type;
    reply.length = bytes_to_int32(length);
d1312 1
a1312 1
    WriteToClient(client, size, (char *) rep);
d1324 1
a1324 1
    WriteToClient(client, size, (char *) rep);
@


1.4
log
@Update to xserver 1.11.2
@
text
@d48 1
a48 2
static struct dev_properties
{
d50 1
a50 1
    char *name;
d52 126
a177 130
    {0, XI_PROP_ENABLED},
    {0, XI_PROP_XTEST_DEVICE},
    {0, XATOM_FLOAT},
    {0, ACCEL_PROP_PROFILE_NUMBER},
    {0, ACCEL_PROP_CONSTANT_DECELERATION},
    {0, ACCEL_PROP_ADAPTIVE_DECELERATION},
    {0, ACCEL_PROP_VELOCITY_SCALING},
    {0, AXIS_LABEL_PROP},
    {0, AXIS_LABEL_PROP_REL_X},
    {0, AXIS_LABEL_PROP_REL_Y},
    {0, AXIS_LABEL_PROP_REL_Z},
    {0, AXIS_LABEL_PROP_REL_RX},
    {0, AXIS_LABEL_PROP_REL_RY},
    {0, AXIS_LABEL_PROP_REL_RZ},
    {0, AXIS_LABEL_PROP_REL_HWHEEL},
    {0, AXIS_LABEL_PROP_REL_DIAL},
    {0, AXIS_LABEL_PROP_REL_WHEEL},
    {0, AXIS_LABEL_PROP_REL_MISC},
    {0, AXIS_LABEL_PROP_ABS_X},
    {0, AXIS_LABEL_PROP_ABS_Y},
    {0, AXIS_LABEL_PROP_ABS_Z},
    {0, AXIS_LABEL_PROP_ABS_RX},
    {0, AXIS_LABEL_PROP_ABS_RY},
    {0, AXIS_LABEL_PROP_ABS_RZ},
    {0, AXIS_LABEL_PROP_ABS_THROTTLE},
    {0, AXIS_LABEL_PROP_ABS_RUDDER},
    {0, AXIS_LABEL_PROP_ABS_WHEEL},
    {0, AXIS_LABEL_PROP_ABS_GAS},
    {0, AXIS_LABEL_PROP_ABS_BRAKE},
    {0, AXIS_LABEL_PROP_ABS_HAT0X},
    {0, AXIS_LABEL_PROP_ABS_HAT0Y},
    {0, AXIS_LABEL_PROP_ABS_HAT1X},
    {0, AXIS_LABEL_PROP_ABS_HAT1Y},
    {0, AXIS_LABEL_PROP_ABS_HAT2X},
    {0, AXIS_LABEL_PROP_ABS_HAT2Y},
    {0, AXIS_LABEL_PROP_ABS_HAT3X},
    {0, AXIS_LABEL_PROP_ABS_HAT3Y},
    {0, AXIS_LABEL_PROP_ABS_PRESSURE},
    {0, AXIS_LABEL_PROP_ABS_DISTANCE},
    {0, AXIS_LABEL_PROP_ABS_TILT_X},
    {0, AXIS_LABEL_PROP_ABS_TILT_Y},
    {0, AXIS_LABEL_PROP_ABS_TOOL_WIDTH},
    {0, AXIS_LABEL_PROP_ABS_VOLUME},
    {0, AXIS_LABEL_PROP_ABS_MT_TOUCH_MAJOR},
    {0, AXIS_LABEL_PROP_ABS_MT_TOUCH_MINOR},
    {0, AXIS_LABEL_PROP_ABS_MT_WIDTH_MAJOR},
    {0, AXIS_LABEL_PROP_ABS_MT_WIDTH_MINOR},
    {0, AXIS_LABEL_PROP_ABS_MT_ORIENTATION},
    {0, AXIS_LABEL_PROP_ABS_MT_POSITION_X},
    {0, AXIS_LABEL_PROP_ABS_MT_POSITION_Y},
    {0, AXIS_LABEL_PROP_ABS_MT_TOOL_TYPE},
    {0, AXIS_LABEL_PROP_ABS_MT_BLOB_ID},
    {0, AXIS_LABEL_PROP_ABS_MT_TRACKING_ID},
    {0, AXIS_LABEL_PROP_ABS_MT_PRESSURE},
    {0, AXIS_LABEL_PROP_ABS_MISC},

    {0, BTN_LABEL_PROP},
    {0, BTN_LABEL_PROP_BTN_UNKNOWN},
    {0, BTN_LABEL_PROP_BTN_WHEEL_UP},
    {0, BTN_LABEL_PROP_BTN_WHEEL_DOWN},
    {0, BTN_LABEL_PROP_BTN_HWHEEL_LEFT},
    {0, BTN_LABEL_PROP_BTN_HWHEEL_RIGHT},
    {0, BTN_LABEL_PROP_BTN_0},
    {0, BTN_LABEL_PROP_BTN_1},
    {0, BTN_LABEL_PROP_BTN_2},
    {0, BTN_LABEL_PROP_BTN_3},
    {0, BTN_LABEL_PROP_BTN_4},
    {0, BTN_LABEL_PROP_BTN_5},
    {0, BTN_LABEL_PROP_BTN_6},
    {0, BTN_LABEL_PROP_BTN_7},
    {0, BTN_LABEL_PROP_BTN_8},
    {0, BTN_LABEL_PROP_BTN_9},

    {0, BTN_LABEL_PROP_BTN_LEFT},
    {0, BTN_LABEL_PROP_BTN_RIGHT},
    {0, BTN_LABEL_PROP_BTN_MIDDLE},
    {0, BTN_LABEL_PROP_BTN_SIDE},
    {0, BTN_LABEL_PROP_BTN_EXTRA},
    {0, BTN_LABEL_PROP_BTN_FORWARD},
    {0, BTN_LABEL_PROP_BTN_BACK},
    {0, BTN_LABEL_PROP_BTN_TASK},

    {0, BTN_LABEL_PROP_BTN_TRIGGER},
    {0, BTN_LABEL_PROP_BTN_THUMB},
    {0, BTN_LABEL_PROP_BTN_THUMB2},
    {0, BTN_LABEL_PROP_BTN_TOP},
    {0, BTN_LABEL_PROP_BTN_TOP2},
    {0, BTN_LABEL_PROP_BTN_PINKIE},
    {0, BTN_LABEL_PROP_BTN_BASE},
    {0, BTN_LABEL_PROP_BTN_BASE2},
    {0, BTN_LABEL_PROP_BTN_BASE3},
    {0, BTN_LABEL_PROP_BTN_BASE4},
    {0, BTN_LABEL_PROP_BTN_BASE5},
    {0, BTN_LABEL_PROP_BTN_BASE6},
    {0, BTN_LABEL_PROP_BTN_DEAD},

    {0, BTN_LABEL_PROP_BTN_A},
    {0, BTN_LABEL_PROP_BTN_B},
    {0, BTN_LABEL_PROP_BTN_C},
    {0, BTN_LABEL_PROP_BTN_X},
    {0, BTN_LABEL_PROP_BTN_Y},
    {0, BTN_LABEL_PROP_BTN_Z},
    {0, BTN_LABEL_PROP_BTN_TL},
    {0, BTN_LABEL_PROP_BTN_TR},
    {0, BTN_LABEL_PROP_BTN_TL2},
    {0, BTN_LABEL_PROP_BTN_TR2},
    {0, BTN_LABEL_PROP_BTN_SELECT},
    {0, BTN_LABEL_PROP_BTN_START},
    {0, BTN_LABEL_PROP_BTN_MODE},
    {0, BTN_LABEL_PROP_BTN_THUMBL},
    {0, BTN_LABEL_PROP_BTN_THUMBR},

    {0, BTN_LABEL_PROP_BTN_TOOL_PEN},
    {0, BTN_LABEL_PROP_BTN_TOOL_RUBBER},
    {0, BTN_LABEL_PROP_BTN_TOOL_BRUSH},
    {0, BTN_LABEL_PROP_BTN_TOOL_PENCIL},
    {0, BTN_LABEL_PROP_BTN_TOOL_AIRBRUSH},
    {0, BTN_LABEL_PROP_BTN_TOOL_FINGER},
    {0, BTN_LABEL_PROP_BTN_TOOL_MOUSE},
    {0, BTN_LABEL_PROP_BTN_TOOL_LENS},
    {0, BTN_LABEL_PROP_BTN_TOUCH},
    {0, BTN_LABEL_PROP_BTN_STYLUS},
    {0, BTN_LABEL_PROP_BTN_STYLUS2},
    {0, BTN_LABEL_PROP_BTN_TOOL_DOUBLETAP},
    {0, BTN_LABEL_PROP_BTN_TOOL_TRIPLETAP},

    {0, BTN_LABEL_PROP_BTN_GEAR_DOWN},
    {0, BTN_LABEL_PROP_BTN_GEAR_UP},

    {0, XI_PROP_TRANSFORM}
d182 2
a183 1
static void send_property_event(DeviceIntPtr dev, Atom property, int what)
d185 26
a210 27
        devicePropertyNotify    event;
        xXIPropertyEvent        xi2;
        int state;

        if (what == XIPropertyDeleted)
            state = PropertyDelete;
        else
            state = PropertyNewValue;

        event.type      = DevicePropertyNotify;
        event.deviceid  = dev->id;
        event.state     = state;
        event.atom      = property;
        event.time      = currentTime.milliseconds;
        SendEventToAllWindows(dev, DevicePropertyNotifyMask,
                              (xEvent*)&event, 1);

        xi2.type        = GenericEvent;
        xi2.extension   = IReqCode;
        xi2.length      = 0;
        xi2.evtype      = XI_PropertyEvent;
        xi2.deviceid    = dev->id;
        xi2.time        = currentTime.milliseconds;
        xi2.property    = property;
        xi2.what        = what;
        SendEventToAllWindows(dev, GetEventFilter(dev, (xEvent*)&xi2),
                              (xEvent*)&xi2, 1);
d213 2
a214 1
static int list_atoms(DeviceIntPtr dev, int *natoms, Atom **atoms_return)
d217 2
a218 2
    Atom *atoms         = NULL;
    int nprops          = 0;
d222 1
a222 2
    if (nprops)
    {
d226 1
a226 1
        if(!atoms)
d249 1
a249 2
    if (!ValidAtom(property))
    {
d253 1
a253 2
    if ((delete != xTrue) && (delete != xFalse))
    {
d258 1
a258 2
    if ((type != AnyPropertyType) && !ValidAtom(type))
    {
d267 1
a267 2
    if (!prop)
    {
d277 1
a277 2
    if (rc != Success)
    {
d283 1
a283 1
    property information, but not the data. */
d285 1
a285 2
    if (((type != prop_value->type) && (type != AnyPropertyType)))
    {
d295 1
a295 1
    n = (prop_value->format/8) * prop_value->size; /* size (bytes) of prop */
d298 2
a299 2
   /* If offset is invalid such that it causes "len" to
            be negative, it's a value error. */
d301 1
a301 2
    if (n < ind)
    {
d317 1
a317 1
    *data = (char*)prop_value->data + ind;
d327 1
a327 2
        (mode != PropModePrepend))
    {
d331 1
a331 2
    if ((format != 8) && (format != 16) && (format != 32))
    {
d336 1
a336 2
    if (!ValidAtom(property))
    {
d340 1
a340 2
    if (!ValidAtom(type))
    {
d354 2
a355 1
    rc = XIChangeDeviceProperty(dev, property, type, format, mode, len, data, TRUE);
d369 1
a369 1
XIGetKnownProperty(char *name)
d376 7
a382 8
    for (i = 0; i < (sizeof(dev_properties)/sizeof(struct dev_properties)); i++)
    {
        if (strcmp(name, dev_properties[i].name) == 0){
            if (dev_properties[i].type == None){
		dev_properties[i].type =
			    MakeAtom(dev_properties[i].name,
			             strlen(dev_properties[i].name),
			             TRUE);
d397 2
a398 1
    for (i = 0; i < (sizeof(dev_properties)/sizeof(struct dev_properties)); i++)
d433 7
a439 8
    switch(val->format)
    {
        case 8:
        case 16:
        case 32:
            break;
        default:
            return BadValue;
d444 1
a444 2
    if (!buf && !(*nelem_return))
    {
d450 2
a451 1
    } else if (val->size < *nelem_return)
d454 11
a464 7
    for (i = 0; i < val->size && i < *nelem_return; i++)
    {
        switch(val->format)
        {
            case 8:  buf[i] = ((CARD8*)val->data)[i]; break;
            case 16: buf[i] = ((CARD16*)val->data)[i]; break;
            case 32: buf[i] = ((CARD32*)val->data)[i]; break;
d508 1
a508 2
    if (!buf && !(*nelem_return))
    {
d514 2
a515 1
    } else if (val->size < *nelem_return)
d519 1
a519 1
           buf[i] = ((float*)val->data)[i];
d530 1
a530 1
XIRegisterPropertyHandler(DeviceIntPtr         dev,
d562 1
a562 2
    while(curr && curr->id != id)
    {
d570 1
a570 1
    if (!prev) /* first one */
d579 1
a579 1
XICreateDeviceProperty (Atom property)
d581 1
a581 1
    XIPropertyPtr   prop;
d583 1
a583 1
    prop = (XIPropertyPtr)malloc(sizeof(XIPropertyRec));
d587 3
a589 3
    prop->next          = NULL;
    prop->propertyName  = property;
    prop->value.type   = None;
d591 3
a593 3
    prop->value.size   = 0;
    prop->value.data   = NULL;
    prop->deletable    = TRUE;
d601 1
a601 1
    XIPropertyPtr   prop;
d610 1
a610 1
XIDestroyDeviceProperty (XIPropertyPtr prop)
d621 1
a621 1
XIDeleteAllDeviceProperties (DeviceIntPtr device)
d623 2
a624 2
    XIPropertyPtr               prop, next;
    XIPropertyHandlerPtr        curr_handler, next_handler;
d626 1
a626 2
    for (prop = device->properties.properties; prop; prop = next)
    {
d636 1
a636 2
    while(curr_handler)
    {
a644 1

d646 1
a646 1
XIDeleteDeviceProperty (DeviceIntPtr device, Atom property, Bool fromClient)
d648 2
a649 2
    XIPropertyPtr               prop, *prev;
    int                         rc = Success;
d651 2
a652 1
    for (prev = &device->properties.properties; (prop = *prev); prev = &(prop->next))
d663 1
a663 2
    if (device->properties.handlers)
    {
d665 2
a666 2
        while(handler)
        {
d675 1
a675 2
    if (prop)
    {
d678 1
a678 1
        XIDestroyDeviceProperty (prop);
d685 12
a696 12
XIChangeDeviceProperty (DeviceIntPtr dev, Atom property, Atom type,
                        int format, int mode, unsigned long len,
                        const pointer value, Bool sendevent)
{
    XIPropertyPtr               prop;
    int                         size_in_bytes;
    int                         total_size;
    unsigned long               total_len;
    XIPropertyValuePtr          prop_value;
    XIPropertyValueRec          new_value;
    Bool                        add = FALSE;
    int                         rc;
d701 3
a703 4
    prop = XIFetchDeviceProperty (dev, property);
    if (!prop)   /* just add to list */
    {
        prop = XICreateDeviceProperty (property);
d712 3
a714 3
     must match those of the already defined property.  The
     existing format and type are irrelevant when using the mode
     "PropModeReplace" since they will be written over. */
d726 2
a727 3
    if (mode == PropModeReplace || len > 0)
    {
        pointer            new_data = NULL, old_data = NULL;
d730 2
a731 3
        new_value.data = (pointer)malloc(total_size);
        if (!new_value.data && total_size)
        {
d733 1
a733 1
                XIDestroyDeviceProperty (prop);
d757 1
a757 1
            memcpy ((char *) new_data, (char *) value, len * size_in_bytes);
d759 2
a760 2
            memcpy ((char *) old_data, (char *) prop_value->data,
                    prop_value->size * size_in_bytes);
d762 1
a762 2
        if (dev->properties.handlers)
        {
d765 1
d769 1
a769 2
            do
            {
d771 2
a772 4
                while(handler)
                {
                    if (handler->SetProperty)
                    {
d774 2
a775 3
                                &new_value, checkonly);
                        if (checkonly && rc != Success)
                        {
d787 2
a788 2
    } else if (len == 0)
    {
d792 1
a792 2
    if (add)
    {
d799 1
a799 1
                            (add) ?  XIPropertyCreated : XIPropertyModified);
d805 1
a805 1
XIGetDeviceProperty (DeviceIntPtr dev, Atom property, XIPropertyValuePtr *value)
d807 1
a807 1
    XIPropertyPtr   prop = XIFetchDeviceProperty (dev, property);
d810 1
a810 2
    if (!prop)
    {
d816 1
a816 2
    if (dev->properties.handlers)
    {
d818 3
a820 4
        while(handler)
        {
            if (handler->GetProperty)
            {
d822 1
a822 2
                if (rc != Success)
                {
d848 1
a848 1
ProcXListDeviceProperties (ClientPtr client)
d850 5
a854 5
    Atom                        *atoms;
    xListDevicePropertiesReply  rep;
    int                         natoms;
    DeviceIntPtr                dev;
    int                         rc = Success;
d859 1
a859 1
    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixListPropAccess);
d874 2
a875 3
    if (natoms)
    {
        client->pSwapReplyFunc = (ReplySwapPtr)Swap32Write;
d883 1
a883 1
ProcXChangeDeviceProperty (ClientPtr client)
d886 4
a889 4
    DeviceIntPtr        dev;
    unsigned long       len;
    int                 totalSize;
    int                 rc;
d894 1
a894 1
    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixSetPropAccess);
d905 1
a905 1
    totalSize = len * (stuff->format/8);
d909 1
a909 1
                         stuff->format, stuff->mode, len, (void*)&stuff[1]);
d914 1
a914 1
ProcXDeleteDeviceProperty (ClientPtr client)
d917 2
a918 2
    DeviceIntPtr        dev;
    int                 rc;
d922 1
a922 1
    rc =  dixLookupDevice (&dev, stuff->deviceid, client, DixSetPropAccess);
d926 1
a926 2
    if (!ValidAtom(stuff->property))
    {
d936 1
a936 1
ProcXGetDeviceProperty (ClientPtr client)
d939 6
a944 6
    DeviceIntPtr                dev;
    int                         length;
    int                         rc, format, nitems, bytes_after;
    char                        *data;
    Atom                        type;
    xGetDevicePropertyReply     reply;
d949 2
a950 3
    rc = dixLookupDevice (&dev, stuff->deviceid, client,
                           stuff->delete ? DixSetPropAccess :
                           DixGetPropAccess);
d955 2
a956 2
            stuff->delete, stuff->longOffset, stuff->longLength,
            &bytes_after, &type, &format, &nitems, &length, &data);
d976 1
a976 2
    if (length)
    {
d978 9
a986 3
            case 32: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap32Write; break;
            case 16: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write; break;
            default: client->pSwapReplyFunc = (ReplySwapPtr)WriteToClient; break;
d992 1
a992 2
    if (stuff->delete && (reply.bytesAfter == 0))
    {
d994 4
a997 4
        for (prev = &dev->properties.properties; (prop = *prev); prev = &prop->next)
        {
            if (prop->propertyName == stuff->property)
            {
a1006 1

d1008 1
a1008 1
SProcXListDeviceProperties (ClientPtr client)
a1009 1
    char n;
d1012 1
a1012 1
    swaps(&stuff->length, n);
d1019 1
a1019 1
SProcXChangeDeviceProperty (ClientPtr client)
a1020 1
    char n;
d1024 4
a1027 4
    swaps(&stuff->length, n);
    swapl(&stuff->property, n);
    swapl(&stuff->type, n);
    swapl(&stuff->nUnits, n);
d1032 1
a1032 1
SProcXDeleteDeviceProperty (ClientPtr client)
a1033 1
    char n;
d1036 2
a1037 2
    swaps(&stuff->length, n);
    swapl(&stuff->property, n);
d1043 1
a1043 1
SProcXGetDeviceProperty (ClientPtr client)
a1044 1
    char n;
d1047 5
a1051 5
    swaps(&stuff->length, n);
    swapl(&stuff->property, n);
    swapl(&stuff->type, n);
    swapl(&stuff->longOffset, n);
    swapl(&stuff->longLength, n);
a1055 1

d1060 1
a1060 1
                          xListDevicePropertiesReply *rep)
d1062 3
a1064 4
    char n;
    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->nAtoms, n);
d1066 1
a1066 1
    WriteToClient(client, size, (char*)rep);
d1071 1
a1071 1
                       xGetDevicePropertyReply *rep)
d1073 5
a1077 7
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swapl(&rep->propertyType, n);
    swapl(&rep->bytesAfter, n);
    swapl(&rep->nItems, n);
d1079 1
a1079 1
    WriteToClient(client, size, (char*)rep);
d1086 5
a1090 5
    Atom                        *atoms;
    xXIListPropertiesReply      rep;
    int                         natoms;
    DeviceIntPtr                dev;
    int                         rc = Success;
d1095 1
a1095 1
    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixListPropAccess);
d1110 2
a1111 3
    if (natoms)
    {
        client->pSwapReplyFunc = (ReplySwapPtr)Swap32Write;
d1121 4
a1124 4
    int                 rc;
    DeviceIntPtr        dev;
    int                 totalSize;
    unsigned long       len;
d1130 1
a1130 1
    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixSetPropAccess);
d1140 1
a1140 1
    totalSize = len * (stuff->format/8);
d1144 1
a1144 1
                         stuff->format, stuff->mode, len, (void*)&stuff[1]);
d1151 3
a1153 2
    DeviceIntPtr        dev;
    int                 rc;
d1158 1
a1158 1
    rc =  dixLookupDevice (&dev, stuff->deviceid, client, DixSetPropAccess);
d1162 1
a1162 2
    if (!ValidAtom(stuff->property))
    {
a1170 1

d1175 6
a1180 6
    DeviceIntPtr                dev;
    xXIGetPropertyReply         reply;
    int                         length;
    int                         rc, format, nitems, bytes_after;
    char                        *data;
    Atom                        type;
d1185 2
a1186 3
    rc = dixLookupDevice (&dev, stuff->deviceid, client,
                           stuff->delete ? DixSetPropAccess :
                           DixGetPropAccess);
d1191 2
a1192 2
            stuff->delete, stuff->offset, stuff->len,
            &bytes_after, &type, &format, &nitems, &length, &data);
d1211 1
a1211 2
    if (length)
    {
d1213 9
a1221 3
            case 32: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap32Write; break;
            case 16: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write; break;
            default: client->pSwapReplyFunc = (ReplySwapPtr)WriteToClient; break;
d1227 1
a1227 2
    if (stuff->delete && (reply.bytes_after == 0))
    {
d1229 4
a1232 4
        for (prev = &dev->properties.properties; (prop = *prev); prev = &prop->next)
        {
            if (prop->propertyName == stuff->property)
            {
a1245 1
    char n;
d1248 2
a1249 2
    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
a1257 1
    char n;
d1261 5
a1265 5
    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->property, n);
    swapl(&stuff->type, n);
    swapl(&stuff->num_items, n);
a1271 1
    char n;
d1274 3
a1276 3
    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->property, n);
a1283 1
    char n;
d1286 6
a1291 6
    swaps(&stuff->length, n);
    swaps(&stuff->deviceid, n);
    swapl(&stuff->property, n);
    swapl(&stuff->type, n);
    swapl(&stuff->offset, n);
    swapl(&stuff->len, n);
a1295 1

d1297 1
a1297 2
SRepXIListProperties(ClientPtr client, int size,
                     xXIListPropertiesReply *rep)
d1299 3
a1301 4
    char n;
    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->num_properties, n);
d1303 1
a1303 1
    WriteToClient(client, size, (char*)rep);
d1307 1
a1307 2
SRepXIGetProperty(ClientPtr client, int size,
                  xXIGetPropertyReply *rep)
d1309 5
a1313 7
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swapl(&rep->type, n);
    swapl(&rep->bytes_after, n);
    swapl(&rep->num_items, n);
d1315 1
a1315 1
    WriteToClient(client, size, (char*)rep);
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d704 1
a704 1
                        pointer value, Bool sendevent)
d1054 1
a1058 1
    REQUEST_SIZE_MATCH(xChangeDevicePropertyReq);
d1298 1
a1303 1
    REQUEST_SIZE_MATCH(xXIChangePropertyReq);
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d180 3
a182 1
    {0, BTN_LABEL_PROP_BTN_GEAR_UP}
d230 1
a230 1
        atoms = xalloc(nprops * sizeof(Atom));
d257 1
a257 1
        return(BadAtom);
d262 1
a262 1
        return(BadValue);
d268 1
a268 1
        return(BadAtom);
d353 1
a353 1
        return(BadAtom);
d358 1
a358 1
        return(BadAtom);
d462 1
a462 1
        buf = xcalloc(val->size, sizeof(int));
d522 1
a522 1
        buf = xcalloc(val->size, sizeof(float));
d554 1
a554 1
    new_handler = xcalloc(1, sizeof(XIPropertyHandler));
d588 1
a588 1
    xfree(curr);
d596 1
a596 1
    prop = (XIPropertyPtr)xalloc(sizeof(XIPropertyRec));
d625 2
a626 3
    if (prop->value.data)
        xfree(prop->value.data);
    xfree(prop);
d653 1
a653 1
        xfree(curr_handler);
d686 1
a686 1
                return (rc);
d723 1
a723 1
            return(BadAlloc);
d735 1
a735 1
        return(BadMatch);
d737 1
a737 1
        return(BadMatch);
d749 1
a749 1
        new_value.data = (pointer)xalloc (total_size);
d800 2
a801 3
                            if (new_value.data)
                                xfree (new_value.data);
                            return (rc);
d809 1
a809 2
        if (prop_value->data)
            xfree (prop_value->data);
d826 1
a826 1
    return(Success);
d907 1
a907 1
        xfree(atoms);
d959 1
a959 1
        return (BadAtom);
d1151 1
a1151 1
        xfree(atoms);
d1202 1
a1202 1
        return (BadAtom);
@


1.1
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d37 1
d54 127
a180 1
    {0, XATOM_FLOAT}
d185 190
d376 1
a376 1
 * Return the type assigned to the specified atom or 0 if the atom isn't known
d381 1
a381 1
_X_EXPORT Atom
d391 8
a398 1
        if (strcmp(name, dev_properties[i].name) == 0)
d400 1
d406 9
a533 18
/**
 * Init those properties that are allocated by the server and most likely used
 * by the DIX or the DDX.
 */
void
XIInitKnownProperties(void)
{
    int i;
    for (i = 0; i < (sizeof(dev_properties)/sizeof(struct dev_properties)); i++)
    {
        dev_properties[i].type =
            MakeAtom(dev_properties[i].name,
                     strlen(dev_properties[i].name),
                     TRUE);
    }
}


a636 1
    devicePropertyNotify        event;
d641 1
a641 9

        event.type      = DevicePropertyNotify;
        event.deviceid  = device->id;
        event.state     = PropertyDelete;
        event.atom      = prop->propertyName;
        event.time      = currentTime.milliseconds;
        SendEventToAllWindows(device, DevicePropertyNotifyMask,
                (xEvent*)&event, 1);

d645 2
d655 2
a663 1
    devicePropertyNotify        event;
d670 3
d693 1
a693 7
        event.type      = DevicePropertyNotify;
        event.deviceid  = device->id;
        event.state     = PropertyDelete;
        event.atom      = prop->propertyName;
        event.time      = currentTime.milliseconds;
        SendEventToAllWindows(device, DevicePropertyNotifyMask,
                              (xEvent*)&event, 1);
a705 1
    devicePropertyNotify        event;
d824 3
a826 9
    {
        event.type      = DevicePropertyNotify;
        event.deviceid  = dev->id;
        event.state     = PropertyNewValue;
        event.atom      = prop->propertyName;
        event.time      = currentTime.milliseconds;
        SendEventToAllWindows(dev, DevicePropertyNotifyMask,
                              (xEvent*)&event, 1);
    }
d880 1
a880 1
    Atom                        *pAtoms = NULL, *temppAtoms;
d882 1
a882 1
    int                         numProps = 0;
a883 1
    XIPropertyPtr               prop;
d889 1
a889 1
    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixReadAccess);
d893 3
a895 5
    for (prop = dev->properties.properties; prop; prop = prop->next)
        numProps++;
    if (numProps)
        if(!(pAtoms = (Atom *)xalloc(numProps * sizeof(Atom))))
            return(BadAlloc);
d899 1
a899 1
    rep.length = (numProps * sizeof(Atom)) >> 2;
d901 1
a901 4
    rep.nAtoms = numProps;
    temppAtoms = pAtoms;
    for (prop = dev->properties.properties; prop; prop = prop->next)
        *temppAtoms++ = prop->propertyName;
d904 1
a904 1
    if (numProps)
d907 2
a908 2
        WriteSwappedDataToClient(client, numProps * sizeof(Atom), pAtoms);
        xfree(pAtoms);
a917 1
    char                format, mode;
a918 1
    int                 sizeInBytes;
a923 19
    format = stuff->format;
    mode = stuff->mode;
    if ((mode != PropModeReplace) && (mode != PropModeAppend) &&
        (mode != PropModePrepend))
    {
        client->errorValue = mode;
        return BadValue;
    }
    if ((format != 8) && (format != 16) && (format != 32))
    {
        client->errorValue = format;
        return BadValue;
    }
    len = stuff->nUnits;
    if (len > ((0xffffffff - sizeof(xChangeDevicePropertyReq)) >> 2))
        return BadLength;
    sizeInBytes = format>>3;
    totalSize = len * sizeInBytes;
    REQUEST_FIXED_SIZE(xChangeDevicePropertyReq, totalSize);
d925 1
a925 1
    rc = dixLookupDevice (&dev, stuff->deviceid, client, DixWriteAccess);
d929 6
a934 10
    if (!ValidAtom(stuff->property))
    {
        client->errorValue = stuff->property;
        return(BadAtom);
    }
    if (!ValidAtom(stuff->type))
    {
        client->errorValue = stuff->type;
        return(BadAtom);
    }
d936 2
a937 3
    rc = XIChangeDeviceProperty(dev, stuff->property,
                                 stuff->type, (int)format,
                                 (int)mode, len, (pointer)&stuff[1], TRUE);
d939 2
a940 2
    if (rc != Success)
        client->errorValue = stuff->property;
d953 1
a953 1
    rc =  dixLookupDevice (&dev, stuff->deviceid, client, DixWriteAccess);
a970 3
    XIPropertyPtr               prop, *prev;
    XIPropertyValuePtr          prop_value;
    unsigned long               n, len, ind;
d972 4
a976 1
    int                         rc;
d982 2
a983 2
                           stuff->delete ? DixWriteAccess :
                           DixReadAccess);
d987 3
a989 15
    if (!ValidAtom(stuff->property))
    {
        client->errorValue = stuff->property;
        return(BadAtom);
    }
    if ((stuff->delete != xTrue) && (stuff->delete != xFalse))
    {
        client->errorValue = stuff->delete;
        return(BadValue);
    }
    if ((stuff->type != AnyPropertyType) && !ValidAtom(stuff->type))
    {
        client->errorValue = stuff->type;
        return(BadAtom);
    }
d991 2
a992 3
    for (prev = &dev->properties.properties; (prop = *prev); prev = &prop->next)
        if (prop->propertyName == stuff->property)
            break;
d998 5
a1002 59
    if (!prop)
    {
        reply.nItems = 0;
        reply.length = 0;
        reply.bytesAfter = 0;
        reply.propertyType = None;
        reply.format = 0;
        WriteReplyToClient(client, sizeof(xGetDevicePropertyReply), &reply);
        return(client->noClientException);
    }

    rc = XIGetDeviceProperty(dev, stuff->property, &prop_value);
    if (rc != Success)
    {
        client->errorValue = stuff->property;
        return rc;
    }

    /* If the request type and actual type don't match. Return the
    property information, but not the data. */

    if (((stuff->type != prop_value->type) &&
         (stuff->type != AnyPropertyType))
       )
    {
        reply.bytesAfter = prop_value->size;
        reply.format = prop_value->format;
        reply.length = 0;
        reply.nItems = 0;
        reply.propertyType = prop_value->type;
        WriteReplyToClient(client, sizeof(xGetDevicePropertyReply), &reply);
        return(client->noClientException);
    }

/*
 *  Return type, format, value to client
 */
    n = (prop_value->format/8) * prop_value->size; /* size (bytes) of prop */
    ind = stuff->longOffset << 2;

   /* If longOffset is invalid such that it causes "len" to
            be negative, it's a value error. */

    if (n < ind)
    {
        client->errorValue = stuff->longOffset;
        return BadValue;
    }

    len = min(n - ind, 4 * stuff->longLength);

    reply.bytesAfter = n - (ind + len);
    reply.format = prop_value->format;
    reply.length = (len + 3) >> 2;
    if (prop_value->format)
        reply.nItems = len / (prop_value->format / 8);
    else
        reply.nItems = 0;
    reply.propertyType = prop_value->type;
d1005 1
a1005 2
    {
        devicePropertyNotify    event;
d1007 1
a1007 8
        event.type      = DevicePropertyNotify;
        event.deviceid  = dev->id;
        event.state     = PropertyDelete;
        event.atom      = prop->propertyName;
        event.time      = currentTime.milliseconds;
        SendEventToAllWindows(dev, DevicePropertyNotifyMask,
                              (xEvent*)&event, 1);
    }
d1009 1
a1009 2
    WriteReplyToClient(client, sizeof(xGenericReply), &reply);
    if (len)
d1012 3
a1014 3
        case 32: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap32Write; break;
        case 16: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write; break;
        default: client->pSwapReplyFunc = (ReplySwapPtr)WriteToClient; break;
d1016 1
a1016 2
        WriteSwappedDataToClient(client, len,
                                 (char *)prop_value->data + ind);
d1019 1
d1021 11
a1031 3
    { /* delete the Property */
        *prev = prop->next;
        XIDestroyDeviceProperty (prop);
d1033 1
a1033 1
    return(client->noClientException);
d1117 245
@

