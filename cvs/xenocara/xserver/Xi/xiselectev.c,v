head	1.7;
access;
symbols
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.6
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	vcnjRBuLQw44cPHf;

1.6
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches
	1.6.4.1
	1.6.6.1;
next	1.5;

1.5
date	2013.05.19.07.20.38;	author ajacoutot;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	;

1.6.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.6.6.1
date	2014.12.09.17.59.32;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.7
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@/*
 * Copyright 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "dixstruct.h"
#include "windowstr.h"
#include "exglobals.h"
#include "exevents.h"
#include <X11/extensions/XI2proto.h>
#include "inpututils.h"

#include "xiselectev.h"

/**
 * Ruleset:
 * - if A has XIAllDevices, B may select on device X
 * - If A has XIAllDevices, B may select on XIAllMasterDevices
 * - If A has XIAllMasterDevices, B may select on device X
 * - If A has XIAllMasterDevices, B may select on XIAllDevices
 * - if A has device X, B may select on XIAllDevices/XIAllMasterDevices
 */
static int check_for_touch_selection_conflicts(ClientPtr B, WindowPtr win, int deviceid)
{
    OtherInputMasks *inputMasks = wOtherInputMasks(win);
    InputClients *A = NULL;

    if (inputMasks)
        A = inputMasks->inputClients;
    for (; A; A = A->next) {
        DeviceIntPtr tmp;

        if (CLIENT_ID(A->resource) == B->index)
            continue;

        if (deviceid == XIAllDevices)
            tmp = inputInfo.all_devices;
        else if (deviceid == XIAllMasterDevices)
            tmp = inputInfo.all_master_devices;
        else
            dixLookupDevice(&tmp, deviceid, serverClient, DixReadAccess);
        if (!tmp)
            return BadImplementation;       /* this shouldn't happen */

        /* A has XIAllDevices */
        if (xi2mask_isset_for_device(A->xi2mask, inputInfo.all_devices, XI_TouchBegin)) {
            if (deviceid == XIAllDevices)
                return BadAccess;
        }

        /* A has XIAllMasterDevices */
        if (xi2mask_isset_for_device(A->xi2mask, inputInfo.all_master_devices, XI_TouchBegin)) {
            if (deviceid == XIAllMasterDevices)
                return BadAccess;
        }

        /* A has this device */
        if (xi2mask_isset_for_device(A->xi2mask, tmp, XI_TouchBegin))
            return BadAccess;
    }

    return Success;
}


/**
 * Check the given mask (in len bytes) for invalid mask bits.
 * Invalid mask bits are any bits above XI2LastEvent.
 *
 * @@return BadValue if at least one invalid bit is set or Success otherwise.
 */
int
XICheckInvalidMaskBits(ClientPtr client, unsigned char *mask, int len)
{
    if (len >= XIMaskLen(XI2LASTEVENT)) {
        int i;

        for (i = XI2LASTEVENT + 1; i < len * 8; i++) {
            if (BitIsOn(mask, i)) {
                client->errorValue = i;
                return BadValue;
            }
        }
    }

    return Success;
}

int
SProcXISelectEvents(ClientPtr client)
{
    int i;
    int len;
    xXIEventMask *evmask;

    REQUEST(xXISelectEventsReq);
    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xXISelectEventsReq);
    swapl(&stuff->win);
    swaps(&stuff->num_masks);

    len = stuff->length - bytes_to_int32(sizeof(xXISelectEventsReq));
    evmask = (xXIEventMask *) &stuff[1];
    for (i = 0; i < stuff->num_masks; i++) {
        if (len < bytes_to_int32(sizeof(xXIEventMask)))
            return BadLength;
        len -= bytes_to_int32(sizeof(xXIEventMask));
        swaps(&evmask->deviceid);
        swaps(&evmask->mask_len);
        if (len < evmask->mask_len)
            return BadLength;
        len -= evmask->mask_len;
        evmask =
            (xXIEventMask *) (((char *) &evmask[1]) + evmask->mask_len * 4);
    }

    return (ProcXISelectEvents(client));
}

int
ProcXISelectEvents(ClientPtr client)
{
    int rc, num_masks;
    WindowPtr win;
    DeviceIntPtr dev;
    DeviceIntRec dummy;
    xXIEventMask *evmask;
    int *types = NULL;
    int len;

    REQUEST(xXISelectEventsReq);
    REQUEST_AT_LEAST_SIZE(xXISelectEventsReq);

    if (stuff->num_masks == 0)
        return BadValue;

    rc = dixLookupWindow(&win, stuff->win, client, DixReceiveAccess);
    if (rc != Success)
        return rc;

    len = sz_xXISelectEventsReq;

    /* check request validity */
    evmask = (xXIEventMask *) &stuff[1];
    num_masks = stuff->num_masks;
    while (num_masks--) {
        len += sizeof(xXIEventMask) + evmask->mask_len * 4;

        if (bytes_to_int32(len) > stuff->length)
            return BadLength;

        if (evmask->deviceid != XIAllDevices &&
            evmask->deviceid != XIAllMasterDevices)
            rc = dixLookupDevice(&dev, evmask->deviceid, client, DixUseAccess);
        else {
            /* XXX: XACE here? */
        }
        if (rc != Success)
            return rc;

        /* hierarchy event mask is not allowed on devices */
        if (evmask->deviceid != XIAllDevices && evmask->mask_len >= 1) {
            unsigned char *bits = (unsigned char *) &evmask[1];

            if (BitIsOn(bits, XI_HierarchyChanged)) {
                client->errorValue = XI_HierarchyChanged;
                return BadValue;
            }
        }

        /* Raw events may only be selected on root windows */
        if (win->parent && evmask->mask_len >= 1) {
            unsigned char *bits = (unsigned char *) &evmask[1];

            if (BitIsOn(bits, XI_RawKeyPress) ||
                BitIsOn(bits, XI_RawKeyRelease) ||
                BitIsOn(bits, XI_RawButtonPress) ||
                BitIsOn(bits, XI_RawButtonRelease) ||
                BitIsOn(bits, XI_RawMotion) ||
                BitIsOn(bits, XI_RawTouchBegin) ||
                BitIsOn(bits, XI_RawTouchUpdate) ||
                BitIsOn(bits, XI_RawTouchEnd)) {
                client->errorValue = XI_RawKeyPress;
                return BadValue;
            }
        }

        if (evmask->mask_len >= 1) {
            unsigned char *bits = (unsigned char *) &evmask[1];

            /* All three touch events must be selected at once */
            if ((BitIsOn(bits, XI_TouchBegin) ||
                 BitIsOn(bits, XI_TouchUpdate) ||
                 BitIsOn(bits, XI_TouchOwnership) ||
                 BitIsOn(bits, XI_TouchEnd)) &&
                (!BitIsOn(bits, XI_TouchBegin) ||
                 !BitIsOn(bits, XI_TouchUpdate) ||
                 !BitIsOn(bits, XI_TouchEnd))) {
                client->errorValue = XI_TouchBegin;
                return BadValue;
            }

            /* Only one client per window may select for touch events on the
             * same devices, including master devices.
             * XXX: This breaks if a device goes from floating to attached. */
            if (BitIsOn(bits, XI_TouchBegin)) {
                rc = check_for_touch_selection_conflicts(client,
                                                         win,
                                                         evmask->deviceid);
                if (rc != Success)
                    return rc;
            }
        }

        if (XICheckInvalidMaskBits(client, (unsigned char *) &evmask[1],
                                   evmask->mask_len * 4) != Success)
            return BadValue;

        evmask =
            (xXIEventMask *) (((unsigned char *) evmask) +
                              evmask->mask_len * 4);
        evmask++;
    }

    if (bytes_to_int32(len) != stuff->length)
        return BadLength;

    /* Set masks on window */
    evmask = (xXIEventMask *) &stuff[1];
    num_masks = stuff->num_masks;
    while (num_masks--) {
        if (evmask->deviceid == XIAllDevices ||
            evmask->deviceid == XIAllMasterDevices) {
            dummy.id = evmask->deviceid;
            dev = &dummy;
        }
        else
            dixLookupDevice(&dev, evmask->deviceid, client, DixUseAccess);
        if (XISetEventMask(dev, win, client, evmask->mask_len * 4,
                           (unsigned char *) &evmask[1]) != Success)
            return BadAlloc;
        evmask =
            (xXIEventMask *) (((unsigned char *) evmask) +
                              evmask->mask_len * 4);
        evmask++;
    }

    RecalculateDeliverableEvents(win);

    free(types);
    return Success;
}

int
SProcXIGetSelectedEvents(ClientPtr client)
{
    REQUEST(xXIGetSelectedEventsReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXIGetSelectedEventsReq);
    swapl(&stuff->win);

    return (ProcXIGetSelectedEvents(client));
}

int
ProcXIGetSelectedEvents(ClientPtr client)
{
    int rc, i;
    WindowPtr win;
    char *buffer = NULL;
    xXIGetSelectedEventsReply reply;
    OtherInputMasks *masks;
    InputClientsPtr others = NULL;
    xXIEventMask *evmask = NULL;
    DeviceIntPtr dev;

    REQUEST(xXIGetSelectedEventsReq);
    REQUEST_SIZE_MATCH(xXIGetSelectedEventsReq);

    rc = dixLookupWindow(&win, stuff->win, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    reply = (xXIGetSelectedEventsReply) {
        .repType = X_Reply,
        .RepType = X_XIGetSelectedEvents,
        .sequenceNumber = client->sequence,
        .length = 0,
        .num_masks = 0
    };

    masks = wOtherInputMasks(win);
    if (masks) {
        for (others = wOtherInputMasks(win)->inputClients; others;
             others = others->next) {
            if (SameClient(others, client)) {
                break;
            }
        }
    }

    if (!others) {
        WriteReplyToClient(client, sizeof(xXIGetSelectedEventsReply), &reply);
        return Success;
    }

    buffer =
        calloc(MAXDEVICES, sizeof(xXIEventMask) + pad_to_int32(XI2MASKSIZE));
    if (!buffer)
        return BadAlloc;

    evmask = (xXIEventMask *) buffer;
    for (i = 0; i < MAXDEVICES; i++) {
        int j;
        const unsigned char *devmask = xi2mask_get_one_mask(others->xi2mask, i);

        if (i > 2) {
            rc = dixLookupDevice(&dev, i, client, DixGetAttrAccess);
            if (rc != Success)
                continue;
        }

        for (j = xi2mask_mask_size(others->xi2mask) - 1; j >= 0; j--) {
            if (devmask[j] != 0) {
                int mask_len = (j + 4) / 4;     /* j is an index, hence + 4, not + 3 */

                evmask->deviceid = i;
                evmask->mask_len = mask_len;
                reply.num_masks++;
                reply.length += sizeof(xXIEventMask) / 4 + evmask->mask_len;

                if (client->swapped) {
                    swaps(&evmask->deviceid);
                    swaps(&evmask->mask_len);
                }

                memcpy(&evmask[1], devmask, j + 1);
                evmask = (xXIEventMask *) ((char *) evmask +
                                           sizeof(xXIEventMask) + mask_len * 4);
                break;
            }
        }
    }

    WriteReplyToClient(client, sizeof(xXIGetSelectedEventsReply), &reply);

    if (reply.num_masks)
        WriteToClient(client, reply.length * 4, buffer);

    free(buffer);
    return Success;
}

void
SRepXIGetSelectedEvents(ClientPtr client,
                        int len, xXIGetSelectedEventsReply * rep)
{
    swaps(&rep->sequenceNumber);
    swapl(&rep->length);
    swaps(&rep->num_masks);
    WriteToClient(client, len, rep);
}
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d117 1
d126 1
d129 3
d134 3
@


1.6.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a116 1
    int len;
a124 1
    len = stuff->length - bytes_to_int32(sizeof(xXISelectEventsReq));
a126 3
        if (len < bytes_to_int32(sizeof(xXIEventMask)))
            return BadLength;
        len -= bytes_to_int32(sizeof(xXIEventMask));
a128 3
        if (len < evmask->mask_len)
            return BadLength;
        len -= evmask->mask_len;
@


1.6.6.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a116 1
    int len;
a124 1
    len = stuff->length - bytes_to_int32(sizeof(xXISelectEventsReq));
a126 3
        if (len < bytes_to_int32(sizeof(xXIEventMask)))
            return BadLength;
        len -= bytes_to_int32(sizeof(xXIEventMask));
a128 3
        if (len < evmask->mask_len)
            return BadLength;
        len -= evmask->mask_len;
@


1.5
log
@Merge the following commit from upstream:
Touch: Fix duplicate TouchBegin selection with virtual devices
http://cgit.freedesktop.org/xorg/xserver/commit/?id=314776eb369ca2e438907795ae030dd743c281fc

This fixes gtk+3 applications crashing with 'BadImplementation' error.

ok matthieu@@
@
text
@d40 51
d223 5
a227 25
                OtherInputMasks *inputMasks = wOtherInputMasks(win);
                InputClients *iclient = NULL;

                if (inputMasks)
                    iclient = inputMasks->inputClients;
                for (; iclient; iclient = iclient->next) {
                    DeviceIntPtr dummy;

                    if (CLIENT_ID(iclient->resource) == client->index)
                        continue;

                    if (evmask->deviceid == XIAllDevices)
                        dummy = inputInfo.all_devices;
                    else if (evmask->deviceid == XIAllMasterDevices)
                        dummy = inputInfo.all_master_devices;
                    else
                        dixLookupDevice(&dummy, evmask->deviceid, serverClient,
                                        DixReadAccess);

                    if (!dummy)
                        return BadImplementation;       /* this shouldn't happen */

                    if (xi2mask_isset(iclient->xi2mask, dummy, XI_TouchBegin))
                        return BadAccess;
                }
d300 7
a306 5
    reply.repType = X_Reply;
    reply.RepType = X_XIGetSelectedEvents;
    reply.length = 0;
    reply.sequenceNumber = client->sequence;
    reply.num_masks = 0;
d377 1
a377 1
    WriteToClient(client, len, (char *) rep);
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d183 8
a190 2
                    dixLookupDevice(&dummy, evmask->deviceid, serverClient,
                                    DixReadAccess);
@


1.3
log
@Update to xserver 1.11.2
@
text
@a29 1

d35 1
d45 2
a46 1
int XICheckInvalidMaskBits(ClientPtr client, unsigned char *mask, int len)
d48 1
a48 2
    if (len >= XIMaskLen(XI2LASTEVENT))
    {
d50 3
a52 4
        for (i = XI2LASTEVENT + 1; i < len * 8; i++)
        {
            if (BitIsOn(mask, i))
            {
a64 1
    char n;
d66 1
a66 1
    xXIEventMask* evmask;
d69 1
a69 1
    swaps(&stuff->length, n);
d71 2
a72 2
    swapl(&stuff->win, n);
    swaps(&stuff->num_masks, n);
d74 6
a79 6
    evmask = (xXIEventMask*)&stuff[1];
    for (i = 0; i < stuff->num_masks; i++)
    {
        swaps(&evmask->deviceid, n);
        swaps(&evmask->mask_len, n);
        evmask = (xXIEventMask*)(((char*)&evmask[1]) + evmask->mask_len * 4);
d109 1
a109 1
    evmask = (xXIEventMask*)&stuff[1];
d111 1
a111 2
    while(num_masks--)
    {
d127 4
a130 5
        if (evmask->deviceid != XIAllDevices && evmask->mask_len >= 1)
        {
            unsigned char *bits = (unsigned char*)&evmask[1];
            if (BitIsOn(bits, XI_HierarchyChanged))
            {
d137 3
a139 3
        if (win->parent && evmask->mask_len >= 1)
        {
            unsigned char *bits = (unsigned char*)&evmask[1];
d144 4
a147 2
                BitIsOn(bits, XI_RawMotion))
            {
d153 42
a194 1
        if (XICheckInvalidMaskBits(client, (unsigned char*)&evmask[1],
d198 3
a200 1
        evmask = (xXIEventMask*)(((unsigned char*)evmask) + evmask->mask_len * 4);
d208 1
a208 1
    evmask = (xXIEventMask*)&stuff[1];
d210 1
a210 2
    while(num_masks--)
    {
d212 1
a212 2
            evmask->deviceid == XIAllMasterDevices)
        {
d215 2
a216 1
        } else
d219 1
a219 1
                           (unsigned char*)&evmask[1]) != Success)
d221 3
a223 1
        evmask = (xXIEventMask*)(((unsigned char*)evmask) + evmask->mask_len * 4);
a232 1

a235 2
    char n;

d237 1
a237 1
    swaps(&stuff->length, n);
d239 1
a239 1
    swapl(&stuff->win, n);
a248 1
    char n;
d270 4
a273 5
    if (masks)
    {
	for (others = wOtherInputMasks(win)->inputClients; others;
	     others = others->next) {
	    if (SameClient(others, client)) {
d279 1
a279 2
    if (!others)
    {
d284 2
a285 1
    buffer = calloc(MAXDEVICES, sizeof(xXIEventMask) + pad_to_int32(XI2MASKSIZE));
d289 2
a290 3
    evmask = (xXIEventMask*)buffer;
    for (i = 0; i < MAXDEVICES; i++)
    {
d292 1
a292 1
        unsigned char *devmask = others->xi2mask[i];
d294 1
a294 2
        if (i > 2)
        {
d300 3
a303 5
        for (j = XI2MASKSIZE - 1; j >= 0; j--)
        {
            if (devmask[j] != 0)
            {
                int mask_len = (j + 4)/4; /* j is an index, hence + 4, not + 3 */
d307 1
a307 1
                reply.length += sizeof(xXIEventMask)/4 + evmask->mask_len;
d309 3
a311 4
                if (client->swapped)
                {
                    swaps(&evmask->deviceid, n);
                    swaps(&evmask->mask_len, n);
d315 2
a316 2
                evmask = (xXIEventMask*)((char*)evmask +
                           sizeof(xXIEventMask) + mask_len * 4);
d331 3
a333 2
void SRepXIGetSelectedEvents(ClientPtr client,
                            int len, xXIGetSelectedEventsReply *rep)
d335 4
a338 6
    char n;

    swaps(&rep->sequenceNumber, n);
    swapl(&rep->length, n);
    swaps(&rep->num_masks, n);
    WriteToClient(client, len, (char *)rep);
a339 2


@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d45 1
a45 1
int XICheckInvalidMaskBits(unsigned char *mask, int len)
d51 1
d53 2
d56 2
d134 2
d137 1
d149 2
d152 1
d155 1
a155 1
        if (XICheckInvalidMaskBits((unsigned char*)&evmask[1],
@


1.1
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d176 1
a176 1
    xfree(types);
d237 1
a237 1
    buffer = xcalloc(MAXDEVICES, sizeof(xXIEventMask) + pad_to_int32(XI2MASKSIZE));
d284 1
a284 1
    xfree(buffer);
@

