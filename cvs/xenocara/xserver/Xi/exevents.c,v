head	1.21;
access;
symbols
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.2
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.14.0.2
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2016.08.09.18.59.50;	author matthieu;	state Exp;
branches;
next	1.20;
commitid	6HLO5qdN5N4nPDjW;

1.20
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.19;
commitid	s0SI41sEunLdyFfd;

1.19
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.18;
commitid	7pAEtF6Y5EgemkuY;

1.18
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.17;
commitid	Te1daavkBLskZ8gc;

1.17
date	2014.09.27.17.52.59;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	cVXoV5PxI8YrEaVA;

1.16
date	2014.07.11.08.13.44;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	QZ1xfp0adMyURB7B;

1.15
date	2014.05.02.19.27.46;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2013.09.28.15.36.32;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2013.08.24.19.44.29;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.01.31.07.52.35;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.15.00.09.30;	author ajacoutot;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.02.16.08.39;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.20;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.11;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.33;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.21;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.13.21.06.11;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1989 by Hewlett-Packard Company, Palo Alto, California.

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Hewlett-Packard not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/*
 * Copyright © 2010 Collabora Ltd.
 * Copyright © 2011 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Daniel Stone <daniel@@fooishbar.org>
 */

/********************************************************************
 *
 *  Routines to register and initialize extension input devices.
 *  This also contains ProcessOtherEvent, the routine called from DDX
 *  to route extension events.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "inputstr.h"
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include <X11/extensions/XI2proto.h>
#include <X11/extensions/geproto.h>
#include "windowstr.h"
#include "miscstruct.h"
#include "region.h"
#include "exevents.h"
#include "extnsionst.h"
#include "exglobals.h"
#include "dixevents.h"          /* DeliverFocusedEvent */
#include "dixgrabs.h"           /* CreateGrab() */
#include "scrnintstr.h"
#include "listdev.h"            /* for CopySwapXXXClass */
#include "xace.h"
#include "xiquerydevice.h"      /* For List*Info */
#include "eventconvert.h"
#include "eventstr.h"
#include "inpututils.h"
#include "mi.h"

#include <X11/extensions/XKBproto.h>
#include "xkbsrv.h"

#define WID(w) ((w) ? ((w)->drawable.id) : 0)
#define AllModifiersMask ( \
	ShiftMask | LockMask | ControlMask | Mod1Mask | Mod2Mask | \
	Mod3Mask | Mod4Mask | Mod5Mask )
#define AllButtonsMask ( \
	Button1Mask | Button2Mask | Button3Mask | Button4Mask | Button5Mask )

Bool ShouldFreeInputMasks(WindowPtr /* pWin */ ,
                          Bool  /* ignoreSelectedEvents */
    );
static Bool MakeInputMasks(WindowPtr    /* pWin */
    );

/*
 * Only let the given client know of core events which will affect its
 * interpretation of input events, if the client's ClientPointer (or the
 * paired keyboard) is the current device.
 */
int
XIShouldNotify(ClientPtr client, DeviceIntPtr dev)
{
    DeviceIntPtr current_ptr = PickPointer(client);
    DeviceIntPtr current_kbd = GetMaster(current_ptr, KEYBOARD_OR_FLOAT);

    if (dev == current_kbd || dev == current_ptr)
        return 1;

    return 0;
}

Bool
IsPointerEvent(InternalEvent *event)
{
    switch (event->any.type) {
    case ET_ButtonPress:
    case ET_ButtonRelease:
    case ET_Motion:
        /* XXX: enter/leave ?? */
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

Bool
IsTouchEvent(InternalEvent *event)
{
    switch (event->any.type) {
    case ET_TouchBegin:
    case ET_TouchUpdate:
    case ET_TouchEnd:
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

/**
 * @@return the device matching the deviceid of the device set in the event, or
 * NULL if the event is not an XInput event.
 */
DeviceIntPtr
XIGetDevice(xEvent *xE)
{
    DeviceIntPtr pDev = NULL;

    if (xE->u.u.type == DeviceButtonPress ||
        xE->u.u.type == DeviceButtonRelease ||
        xE->u.u.type == DeviceMotionNotify ||
        xE->u.u.type == ProximityIn ||
        xE->u.u.type == ProximityOut || xE->u.u.type == DevicePropertyNotify) {
        int rc;
        int id;

        id = ((deviceKeyButtonPointer *) xE)->deviceid & ~MORE_EVENTS;

        rc = dixLookupDevice(&pDev, id, serverClient, DixUnknownAccess);
        if (rc != Success)
            ErrorF("[dix] XIGetDevice failed on XACE restrictions (%d)\n", rc);
    }
    return pDev;
}

/**
 * Copy the device->key into master->key and send a mapping notify to the
 * clients if appropriate.
 * master->key needs to be allocated by the caller.
 *
 * Device is the slave device. If it is attached to a master device, we may
 * need to send a mapping notify to the client because it causes the MD
 * to change state.
 *
 * Mapping notify needs to be sent in the following cases:
 *      - different slave device on same master
 *      - different master
 *
 * XXX: They way how the code is we also send a map notify if the slave device
 * stays the same, but the master changes. This isn't really necessary though.
 *
 * XXX: this gives you funny behaviour with the ClientPointer. When a
 * MappingNotify is sent to the client, the client usually responds with a
 * GetKeyboardMapping. This will retrieve the ClientPointer's keyboard
 * mapping, regardless of which keyboard sent the last mapping notify request.
 * So depending on the CP setting, your keyboard may change layout in each
 * app...
 *
 * This code is basically the old SwitchCoreKeyboard.
 */

void
CopyKeyClass(DeviceIntPtr device, DeviceIntPtr master)
{
    KeyClassPtr mk = master->key;

    if (device == master)
        return;

    mk->sourceid = device->id;

    if (!XkbDeviceApplyKeymap(master, device->key->xkbInfo->desc))
        FatalError("Couldn't pivot keymap from device to core!\n");
}

/**
 * Copies the feedback classes from device "from" into device "to". Classes
 * are duplicated (not just flipping the pointers). All feedback classes are
 * linked lists, the full list is duplicated.
 */
static void
DeepCopyFeedbackClasses(DeviceIntPtr from, DeviceIntPtr to)
{
    ClassesPtr classes;

    if (from->intfeed) {
        IntegerFeedbackPtr *i, it;

        if (!to->intfeed) {
            classes = to->unused_classes;
            to->intfeed = classes->intfeed;
            classes->intfeed = NULL;
        }

        i = &to->intfeed;
        for (it = from->intfeed; it; it = it->next) {
            if (!(*i)) {
                *i = calloc(1, sizeof(IntegerFeedbackClassRec));
                if (!(*i)) {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*i)->CtrlProc = it->CtrlProc;
            (*i)->ctrl = it->ctrl;

            i = &(*i)->next;
        }
    }
    else if (to->intfeed && !from->intfeed) {
        classes = to->unused_classes;
        classes->intfeed = to->intfeed;
        to->intfeed = NULL;
    }

    if (from->stringfeed) {
        StringFeedbackPtr *s, it;

        if (!to->stringfeed) {
            classes = to->unused_classes;
            to->stringfeed = classes->stringfeed;
            classes->stringfeed = NULL;
        }

        s = &to->stringfeed;
        for (it = from->stringfeed; it; it = it->next) {
            if (!(*s)) {
                *s = calloc(1, sizeof(StringFeedbackClassRec));
                if (!(*s)) {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*s)->CtrlProc = it->CtrlProc;
            (*s)->ctrl = it->ctrl;

            s = &(*s)->next;
        }
    }
    else if (to->stringfeed && !from->stringfeed) {
        classes = to->unused_classes;
        classes->stringfeed = to->stringfeed;
        to->stringfeed = NULL;
    }

    if (from->bell) {
        BellFeedbackPtr *b, it;

        if (!to->bell) {
            classes = to->unused_classes;
            to->bell = classes->bell;
            classes->bell = NULL;
        }

        b = &to->bell;
        for (it = from->bell; it; it = it->next) {
            if (!(*b)) {
                *b = calloc(1, sizeof(BellFeedbackClassRec));
                if (!(*b)) {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*b)->BellProc = it->BellProc;
            (*b)->CtrlProc = it->CtrlProc;
            (*b)->ctrl = it->ctrl;

            b = &(*b)->next;
        }
    }
    else if (to->bell && !from->bell) {
        classes = to->unused_classes;
        classes->bell = to->bell;
        to->bell = NULL;
    }

    if (from->leds) {
        LedFeedbackPtr *l, it;

        if (!to->leds) {
            classes = to->unused_classes;
            to->leds = classes->leds;
            classes->leds = NULL;
        }

        l = &to->leds;
        for (it = from->leds; it; it = it->next) {
            if (!(*l)) {
                *l = calloc(1, sizeof(LedFeedbackClassRec));
                if (!(*l)) {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*l)->CtrlProc = it->CtrlProc;
            (*l)->ctrl = it->ctrl;
            if ((*l)->xkb_sli)
                XkbFreeSrvLedInfo((*l)->xkb_sli);
            (*l)->xkb_sli = XkbCopySrvLedInfo(from, it->xkb_sli, NULL, *l);

            l = &(*l)->next;
        }
    }
    else if (to->leds && !from->leds) {
        classes = to->unused_classes;
        classes->leds = to->leds;
        to->leds = NULL;
    }
}

static void
DeepCopyKeyboardClasses(DeviceIntPtr from, DeviceIntPtr to)
{
    ClassesPtr classes;

    /* XkbInitDevice (->XkbInitIndicatorMap->XkbFindSrvLedInfo) relies on the
     * kbdfeed to be set up properly, so let's do the feedback classes first.
     */
    if (from->kbdfeed) {
        KbdFeedbackPtr *k, it;

        if (!to->kbdfeed) {
            classes = to->unused_classes;

            to->kbdfeed = classes->kbdfeed;
            if (!to->kbdfeed)
                InitKeyboardDeviceStruct(to, NULL, NULL, NULL);
            classes->kbdfeed = NULL;
        }

        k = &to->kbdfeed;
        for (it = from->kbdfeed; it; it = it->next) {
            if (!(*k)) {
                *k = calloc(1, sizeof(KbdFeedbackClassRec));
                if (!*k) {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*k)->BellProc = it->BellProc;
            (*k)->CtrlProc = it->CtrlProc;
            (*k)->ctrl = it->ctrl;
            if ((*k)->xkb_sli)
                XkbFreeSrvLedInfo((*k)->xkb_sli);
            (*k)->xkb_sli = XkbCopySrvLedInfo(from, it->xkb_sli, *k, NULL);

            k = &(*k)->next;
        }
    }
    else if (to->kbdfeed && !from->kbdfeed) {
        classes = to->unused_classes;
        classes->kbdfeed = to->kbdfeed;
        to->kbdfeed = NULL;
    }

    if (from->key) {
        if (!to->key) {
            classes = to->unused_classes;
            to->key = classes->key;
            if (!to->key)
                InitKeyboardDeviceStruct(to, NULL, NULL, NULL);
            else
                classes->key = NULL;
        }

        CopyKeyClass(from, to);
    }
    else if (to->key && !from->key) {
        classes = to->unused_classes;
        classes->key = to->key;
        to->key = NULL;
    }

    /* If a SrvLedInfoPtr's flags are XkbSLI_IsDefault, the names and maps
     * pointer point into the xkbInfo->desc struct.  XkbCopySrvLedInfo
     * didn't update the pointers so we need to do it manually here.
     */
    if (to->kbdfeed) {
        KbdFeedbackPtr k;

        for (k = to->kbdfeed; k; k = k->next) {
            if (!k->xkb_sli)
                continue;
            if (k->xkb_sli->flags & XkbSLI_IsDefault) {
                k->xkb_sli->names = to->key->xkbInfo->desc->names->indicators;
                k->xkb_sli->maps = to->key->xkbInfo->desc->indicators->maps;
            }
        }
    }

    /* We can't just copy over the focus class. When an app sets the focus,
     * it'll do so on the master device. Copying the SDs focus means losing
     * the focus.
     * So we only copy the focus class if the device didn't have one,
     * otherwise we leave it as it is.
     */
    if (from->focus) {
        if (!to->focus) {
            WindowPtr *oldTrace;

            classes = to->unused_classes;
            to->focus = classes->focus;
            if (!to->focus) {
                to->focus = calloc(1, sizeof(FocusClassRec));
                if (!to->focus)
                    FatalError("[Xi] no memory for class shift.\n");
            }
            else
                classes->focus = NULL;

            oldTrace = to->focus->trace;
            memcpy(to->focus, from->focus, sizeof(FocusClassRec));
            to->focus->trace = reallocarray(oldTrace,
                                            to->focus->traceSize,
                                            sizeof(WindowPtr));
            if (!to->focus->trace && to->focus->traceSize)
                FatalError("[Xi] no memory for trace.\n");
            memcpy(to->focus->trace, from->focus->trace,
                   from->focus->traceSize * sizeof(WindowPtr));
            to->focus->sourceid = from->id;
        }
    }
    else if (to->focus) {
        classes = to->unused_classes;
        classes->focus = to->focus;
        to->focus = NULL;
    }

}

/* FIXME: this should really be shared with the InitValuatorAxisClassRec and
 * similar */
static void
DeepCopyPointerClasses(DeviceIntPtr from, DeviceIntPtr to)
{
    ClassesPtr classes;

    /* Feedback classes must be copied first */
    if (from->ptrfeed) {
        PtrFeedbackPtr *p, it;

        if (!to->ptrfeed) {
            classes = to->unused_classes;
            to->ptrfeed = classes->ptrfeed;
            classes->ptrfeed = NULL;
        }

        p = &to->ptrfeed;
        for (it = from->ptrfeed; it; it = it->next) {
            if (!(*p)) {
                *p = calloc(1, sizeof(PtrFeedbackClassRec));
                if (!*p) {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*p)->CtrlProc = it->CtrlProc;
            (*p)->ctrl = it->ctrl;

            p = &(*p)->next;
        }
    }
    else if (to->ptrfeed && !from->ptrfeed) {
        classes = to->unused_classes;
        classes->ptrfeed = to->ptrfeed;
        to->ptrfeed = NULL;
    }

    if (from->valuator) {
        ValuatorClassPtr v;

        if (!to->valuator) {
            classes = to->unused_classes;
            to->valuator = classes->valuator;
            if (to->valuator)
                classes->valuator = NULL;
        }

        v = AllocValuatorClass(to->valuator, from->valuator->numAxes);

        if (!v)
            FatalError("[Xi] no memory for class shift.\n");

        to->valuator = v;
        memcpy(v->axes, from->valuator->axes, v->numAxes * sizeof(AxisInfo));

        v->sourceid = from->id;
    }
    else if (to->valuator && !from->valuator) {
        classes = to->unused_classes;
        classes->valuator = to->valuator;
        to->valuator = NULL;
    }

    if (from->button) {
        if (!to->button) {
            classes = to->unused_classes;
            to->button = classes->button;
            if (!to->button) {
                to->button = calloc(1, sizeof(ButtonClassRec));
                if (!to->button)
                    FatalError("[Xi] no memory for class shift.\n");
            }
            else
                classes->button = NULL;
        }

        if (from->button->xkb_acts) {
            if (!to->button->xkb_acts) {
                to->button->xkb_acts = calloc(1, sizeof(XkbAction));
                if (!to->button->xkb_acts)
                    FatalError("[Xi] not enough memory for xkb_acts.\n");
            }
            memcpy(to->button->xkb_acts, from->button->xkb_acts,
                   sizeof(XkbAction));
        }
        else
            free(to->button->xkb_acts);

        memcpy(to->button->labels, from->button->labels,
               from->button->numButtons * sizeof(Atom));
        to->button->sourceid = from->id;
    }
    else if (to->button && !from->button) {
        classes = to->unused_classes;
        classes->button = to->button;
        to->button = NULL;
    }

    if (from->proximity) {
        if (!to->proximity) {
            classes = to->unused_classes;
            to->proximity = classes->proximity;
            if (!to->proximity) {
                to->proximity = calloc(1, sizeof(ProximityClassRec));
                if (!to->proximity)
                    FatalError("[Xi] no memory for class shift.\n");
            }
            else
                classes->proximity = NULL;
        }
        memcpy(to->proximity, from->proximity, sizeof(ProximityClassRec));
        to->proximity->sourceid = from->id;
    }
    else if (to->proximity) {
        classes = to->unused_classes;
        classes->proximity = to->proximity;
        to->proximity = NULL;
    }

    if (from->touch) {
        TouchClassPtr t, f;

        if (!to->touch) {
            classes = to->unused_classes;
            to->touch = classes->touch;
            if (!to->touch) {
                int i;

                to->touch = calloc(1, sizeof(TouchClassRec));
                if (!to->touch)
                    FatalError("[Xi] no memory for class shift.\n");
                to->touch->num_touches = from->touch->num_touches;
                to->touch->touches = calloc(to->touch->num_touches,
                                            sizeof(TouchPointInfoRec));
                for (i = 0; i < to->touch->num_touches; i++)
                    TouchInitTouchPoint(to->touch, to->valuator, i);
                if (!to->touch)
                    FatalError("[Xi] no memory for class shift.\n");
            }
            else
                classes->touch = NULL;
        }

        t = to->touch;
        f = from->touch;
        t->sourceid = f->sourceid;
        t->max_touches = f->max_touches;
        t->mode = f->mode;
        t->buttonsDown = f->buttonsDown;
        t->state = f->state;
        t->motionMask = f->motionMask;
        /* to->touches and to->num_touches are separate on the master,
         * don't copy */
    }
    /* Don't remove touch class if from->touch is non-existent. The to device
     * may have an active touch grab, so we need to keep the touch class record
     * around. */
}

/**
 * Copies the CONTENT of the classes of device from into the classes in device
 * to. From and to are identical after finishing.
 *
 * If to does not have classes from currenly has, the classes are stored in
 * to's devPrivates system. Later, we recover it again from there if needed.
 * Saves a few memory allocations.
 */
void
DeepCopyDeviceClasses(DeviceIntPtr from, DeviceIntPtr to,
                      DeviceChangedEvent *dce)
{
    OsBlockSIGIO();

    /* generic feedback classes, not tied to pointer and/or keyboard */
    DeepCopyFeedbackClasses(from, to);

    if ((dce->flags & DEVCHANGE_KEYBOARD_EVENT))
        DeepCopyKeyboardClasses(from, to);
    if ((dce->flags & DEVCHANGE_POINTER_EVENT))
        DeepCopyPointerClasses(from, to);

    OsReleaseSIGIO();
}

/**
 * Send an XI2 DeviceChangedEvent to all interested clients.
 */
void
XISendDeviceChangedEvent(DeviceIntPtr device, DeviceChangedEvent *dce)
{
    xXIDeviceChangedEvent *dcce;
    int rc;

    rc = EventToXI2((InternalEvent *) dce, (xEvent **) &dcce);
    if (rc != Success) {
        ErrorF("[Xi] event conversion from DCE failed with code %d\n", rc);
        return;
    }

    /* we don't actually swap if there's a NullClient, swapping is done
     * later when event is delivered. */
    SendEventToAllWindows(device, XI_DeviceChangedMask, (xEvent *) dcce, 1);
    free(dcce);
}

static void
ChangeMasterDeviceClasses(DeviceIntPtr device, DeviceChangedEvent *dce)
{
    DeviceIntPtr slave;
    int rc;

    /* For now, we don't have devices that change physically. */
    if (!IsMaster(device))
        return;

    rc = dixLookupDevice(&slave, dce->sourceid, serverClient, DixReadAccess);

    if (rc != Success)
        return;                 /* Device has disappeared */

    if (IsMaster(slave))
        return;

    if (IsFloating(slave))
        return;                 /* set floating since the event */

    if (GetMaster(slave, MASTER_ATTACHED)->id != dce->masterid)
        return;                 /* not our slave anymore, don't care */

    /* FIXME: we probably need to send a DCE for the new slave now */

    device->public.devicePrivate = slave->public.devicePrivate;

    /* FIXME: the classes may have changed since we generated the event. */
    DeepCopyDeviceClasses(slave, device, dce);
    dce->deviceid = device->id;
    XISendDeviceChangedEvent(device, dce);
}

/**
 * Add state and motionMask to the filter for this event. The protocol
 * supports some extra masks for motion when a button is down:
 * ButtonXMotionMask and the DeviceButtonMotionMask to trigger only when at
 * least one button (or that specific button is down). These masks need to
 * be added to the filters for core/XI motion events.
 *
 * @@param device The device to update the mask for
 * @@param state The current button state mask
 * @@param motion_mask The motion mask (DeviceButtonMotionMask or 0)
 */
static void
UpdateDeviceMotionMask(DeviceIntPtr device, unsigned short state,
                       Mask motion_mask)
{
    Mask mask;

    mask = DevicePointerMotionMask | state | motion_mask;
    SetMaskForEvent(device->id, mask, DeviceMotionNotify);
    mask = PointerMotionMask | state | motion_mask;
    SetMaskForEvent(device->id, mask, MotionNotify);
}

static void
IncreaseButtonCount(DeviceIntPtr dev, int key, CARD8 *buttons_down,
                    Mask *motion_mask, unsigned short *state)
{
    if (dev->valuator)
        dev->valuator->motionHintWindow = NullWindow;

    (*buttons_down)++;
    *motion_mask = DeviceButtonMotionMask;
    if (dev->button->map[key] <= 5)
        *state |= (Button1Mask >> 1) << dev->button->map[key];
}

static void
DecreaseButtonCount(DeviceIntPtr dev, int key, CARD8 *buttons_down,
                    Mask *motion_mask, unsigned short *state)
{
    if (dev->valuator)
        dev->valuator->motionHintWindow = NullWindow;

    if (*buttons_down >= 1 && !--(*buttons_down))
        *motion_mask = 0;
    if (dev->button->map[key] <= 5)
        *state &= ~((Button1Mask >> 1) << dev->button->map[key]);
}

/**
 * Update the device state according to the data in the event.
 *
 * return values are
 *   DEFAULT ... process as normal
 *   DONT_PROCESS ... return immediately from caller
 */
#define DEFAULT 0
#define DONT_PROCESS 1
int
UpdateDeviceState(DeviceIntPtr device, DeviceEvent *event)
{
    int i;
    int key = 0, last_valuator;

    KeyClassPtr k = NULL;
    ButtonClassPtr b = NULL;
    ValuatorClassPtr v = NULL;
    TouchClassPtr t = NULL;

    /* This event is always the first we get, before the actual events with
     * the data. However, the way how the DDX is set up, "device" will
     * actually be the slave device that caused the event.
     */
    switch (event->type) {
    case ET_DeviceChanged:
        ChangeMasterDeviceClasses(device, (DeviceChangedEvent *) event);
        return DONT_PROCESS;    /* event has been sent already */
    case ET_Motion:
    case ET_ButtonPress:
    case ET_ButtonRelease:
    case ET_KeyPress:
    case ET_KeyRelease:
    case ET_ProximityIn:
    case ET_ProximityOut:
    case ET_TouchBegin:
    case ET_TouchUpdate:
    case ET_TouchEnd:
        break;
    default:
        /* other events don't update the device */
        return DEFAULT;
    }

    k = device->key;
    v = device->valuator;
    b = device->button;
    t = device->touch;

    key = event->detail.key;

    /* Update device axis */
    /* Check valuators first */
    last_valuator = -1;
    for (i = 0; i < MAX_VALUATORS; i++) {
        if (BitIsOn(&event->valuators.mask, i)) {
            if (!v) {
                ErrorF("[Xi] Valuators reported for non-valuator device '%s'. "
                       "Ignoring event.\n", device->name);
                return DONT_PROCESS;
            }
            else if (v->numAxes < i) {
                ErrorF("[Xi] Too many valuators reported for device '%s'. "
                       "Ignoring event.\n", device->name);
                return DONT_PROCESS;
            }
            last_valuator = i;
        }
    }

    for (i = 0; i <= last_valuator && i < v->numAxes; i++) {
        /* XXX: Relative/Absolute mode */
        if (BitIsOn(&event->valuators.mask, i))
            v->axisVal[i] = event->valuators.data[i];
    }

    if (event->type == ET_KeyPress) {
        if (!k)
            return DONT_PROCESS;

        /* don't allow ddx to generate multiple downs, but repeats are okay */
        if (key_is_down(device, key, KEY_PROCESSED) && !event->key_repeat)
            return DONT_PROCESS;

        if (device->valuator)
            device->valuator->motionHintWindow = NullWindow;
        set_key_down(device, key, KEY_PROCESSED);
    }
    else if (event->type == ET_KeyRelease) {
        if (!k)
            return DONT_PROCESS;

        if (!key_is_down(device, key, KEY_PROCESSED))   /* guard against duplicates */
            return DONT_PROCESS;
        if (device->valuator)
            device->valuator->motionHintWindow = NullWindow;
        set_key_up(device, key, KEY_PROCESSED);
    }
    else if (event->type == ET_ButtonPress) {
        if (!b)
            return DONT_PROCESS;

        if (button_is_down(device, key, BUTTON_PROCESSED))
            return DONT_PROCESS;

        set_button_down(device, key, BUTTON_PROCESSED);

        if (!b->map[key])
            return DONT_PROCESS;

        IncreaseButtonCount(device, key, &b->buttonsDown, &b->motionMask,
                            &b->state);
        UpdateDeviceMotionMask(device, b->state, b->motionMask);
    }
    else if (event->type == ET_ButtonRelease) {
        if (!b)
            return DONT_PROCESS;

        if (!button_is_down(device, key, BUTTON_PROCESSED))
            return DONT_PROCESS;
        if (IsMaster(device)) {
            DeviceIntPtr sd;

            /*
             * Leave the button down if any slave has the
             * button still down. Note that this depends on the
             * event being delivered through the slave first
             */
            for (sd = inputInfo.devices; sd; sd = sd->next) {
                if (IsMaster(sd) || GetMaster(sd, MASTER_POINTER) != device)
                    continue;
                if (!sd->button)
                    continue;
                for (i = 1; i <= sd->button->numButtons; i++)
                    if (sd->button->map[i] == key &&
                        button_is_down(sd, i, BUTTON_PROCESSED))
                        return DONT_PROCESS;
            }
        }
        set_button_up(device, key, BUTTON_PROCESSED);
        if (!b->map[key])
            return DONT_PROCESS;

        DecreaseButtonCount(device, key, &b->buttonsDown, &b->motionMask,
                            &b->state);
        UpdateDeviceMotionMask(device, b->state, b->motionMask);
    }
    else if (event->type == ET_ProximityIn)
        device->proximity->in_proximity = TRUE;
    else if (event->type == ET_ProximityOut)
        device->proximity->in_proximity = FALSE;
    else if (event->type == ET_TouchBegin) {
        BUG_RETURN_VAL(!b || !v, DONT_PROCESS);
        BUG_RETURN_VAL(!t, DONT_PROCESS);

        if (!b->map[key])
            return DONT_PROCESS;

        if (!(event->flags & TOUCH_POINTER_EMULATED) ||
            (event->flags & TOUCH_REPLAYING))
            return DONT_PROCESS;

        IncreaseButtonCount(device, key, &t->buttonsDown, &t->motionMask,
                            &t->state);
        UpdateDeviceMotionMask(device, t->state, DeviceButtonMotionMask);
    }
    else if (event->type == ET_TouchEnd) {
        BUG_RETURN_VAL(!b || !v, DONT_PROCESS);
        BUG_RETURN_VAL(!t, DONT_PROCESS);

        if (t->buttonsDown <= 0 || !b->map[key])
            return DONT_PROCESS;

        if (!(event->flags & TOUCH_POINTER_EMULATED))
            return DONT_PROCESS;

        DecreaseButtonCount(device, key, &t->buttonsDown, &t->motionMask,
                            &t->state);
        UpdateDeviceMotionMask(device, t->state, DeviceButtonMotionMask);
    }

    return DEFAULT;
}

/**
 * A client that does not have the TouchOwnership mask set may not receive a
 * TouchBegin event if there is at least one grab active.
 *
 * @@return TRUE if the client selected for ownership events on the given
 * window for this device, FALSE otherwise
 */
static inline Bool
TouchClientWantsOwnershipEvents(ClientPtr client, DeviceIntPtr dev,
                                WindowPtr win)
{
    InputClients *iclient;

    nt_list_for_each_entry(iclient, wOtherInputMasks(win)->inputClients, next) {
        if (rClient(iclient) != client)
            continue;

        return xi2mask_isset(iclient->xi2mask, dev, XI_TouchOwnership);
    }

    return FALSE;
}

static void
TouchSendOwnershipEvent(DeviceIntPtr dev, TouchPointInfoPtr ti, int reason,
                        XID resource)
{
    int nev, i;
    InternalEvent *tel = InitEventList(GetMaximumEventsNum());

    nev = GetTouchOwnershipEvents(tel, dev, ti, reason, resource, 0);
    for (i = 0; i < nev; i++)
        mieqProcessDeviceEvent(dev, tel + i, NULL);

    FreeEventList(tel, GetMaximumEventsNum());
}

/**
 * Attempts to deliver a touch event to the given client.
 */
static Bool
DeliverOneTouchEvent(ClientPtr client, DeviceIntPtr dev, TouchPointInfoPtr ti,
                     GrabPtr grab, WindowPtr win, InternalEvent *ev)
{
    int err;
    xEvent *xi2;
    Mask filter;
    Window child = DeepestSpriteWin(&ti->sprite)->drawable.id;

    /* FIXME: owner event handling */

    /* If the client does not have the ownership mask set and is not
     * the current owner of the touch, only pretend we delivered */
    if (!grab && ti->num_grabs != 0 &&
        !TouchClientWantsOwnershipEvents(client, dev, win))
        return TRUE;

    /* If we fail here, we're going to leave a client hanging. */
    err = EventToXI2(ev, &xi2);
    if (err != Success)
        FatalError("[Xi] %s: XI2 conversion failed in %s"
                   " (%d)\n", dev->name, __func__, err);

    FixUpEventFromWindow(&ti->sprite, xi2, win, child, FALSE);
    filter = GetEventFilter(dev, xi2);
    if (XaceHook(XACE_RECEIVE_ACCESS, client, win, xi2, 1) != Success)
        return FALSE;
    err = TryClientEvents(client, dev, xi2, 1, filter, filter, NullGrab);
    free(xi2);

    /* Returning the value from TryClientEvents isn't useful, since all our
     * resource-gone cleanups will update the delivery list anyway. */
    return TRUE;
}

static void
ActivateEarlyAccept(DeviceIntPtr dev, TouchPointInfoPtr ti)
{
    ClientPtr client;
    XID error;
    GrabPtr grab = ti->listeners[0].grab;

    BUG_RETURN(ti->listeners[0].type != LISTENER_GRAB &&
               ti->listeners[0].type != LISTENER_POINTER_GRAB);
    BUG_RETURN(!grab);

    client = rClient(grab);

    if (TouchAcceptReject(client, dev, XIAcceptTouch, ti->client_id,
                          ti->listeners[0].window->drawable.id, &error) != Success)
        ErrorF("[Xi] Failed to accept touch grab after early acceptance.\n");
}

/**
 * Find the oldest touch that still has a pointer emulation client.
 *
 * Pointer emulation can only be performed for the oldest touch. Otherwise, the
 * order of events seen by the client will be wrong. This function helps us find
 * the next touch to be emulated.
 *
 * @@param dev The device to find touches for.
 */
static TouchPointInfoPtr
FindOldestPointerEmulatedTouch(DeviceIntPtr dev)
{
    TouchPointInfoPtr oldest = NULL;
    int i;

    for (i = 0; i < dev->touch->num_touches; i++) {
        TouchPointInfoPtr ti = dev->touch->touches + i;
        int j;

        if (!ti->active || !ti->emulate_pointer)
            continue;

        for (j = 0; j < ti->num_listeners; j++) {
            if (ti->listeners[j].type == LISTENER_POINTER_GRAB ||
                ti->listeners[j].type == LISTENER_POINTER_REGULAR)
                break;
        }
        if (j == ti->num_listeners)
            continue;

        if (!oldest) {
            oldest = ti;
            continue;
        }

        if (oldest->client_id - ti->client_id < UINT_MAX / 2)
            oldest = ti;
    }

    return oldest;
}

/**
 * If the current owner has rejected the event, deliver the
 * TouchOwnership/TouchBegin to the next item in the sprite stack.
 */
static void
TouchPuntToNextOwner(DeviceIntPtr dev, TouchPointInfoPtr ti,
                     TouchOwnershipEvent *ev)
{
    TouchListener *listener = &ti->listeners[0]; /* new owner */
    int accepted_early = listener->state == LISTENER_EARLY_ACCEPT;

    /* Deliver the ownership */
    if (listener->state == LISTENER_AWAITING_OWNER || accepted_early)
        DeliverTouchEvents(dev, ti, (InternalEvent *) ev,
                           listener->listener);
    else if (listener->state == LISTENER_AWAITING_BEGIN) {
        /* We can't punt to a pointer listener unless all older pointer
         * emulated touches have been seen already. */
        if ((listener->type == LISTENER_POINTER_GRAB ||
             listener->type == LISTENER_POINTER_REGULAR) &&
            ti != FindOldestPointerEmulatedTouch(dev))
            return;

        TouchEventHistoryReplay(ti, dev, listener->listener);
    }

    /* New owner has Begin/Update but not end. If touch is pending_finish,
     * emulate the TouchEnd now */
    if (ti->pending_finish) {
        TouchEmitTouchEnd(dev, ti, 0, 0);

        /* If the last owner is not a touch grab, finalise the touch, we
           won't get more correspondence on this.
         */
        if (ti->num_listeners == 1 &&
            (ti->num_grabs == 0 ||
             listener->grab->grabtype != XI2 ||
             !xi2mask_isset(listener->grab->xi2mask, dev, XI_TouchBegin))) {
            TouchEndTouch(dev, ti);
            return;
        }
    }

    if (accepted_early)
        ActivateEarlyAccept(dev, ti);
}

/**
 * Check the oldest touch to see if it needs to be replayed to its pointer
 * owner.
 *
 * Touch event propagation is paused if it hits a pointer listener while an
 * older touch with a pointer listener is waiting on accept or reject. This
 * function will restart propagation of a paused touch if needed.
 *
 * @@param dev The device to check touches for.
 */
static void
CheckOldestTouch(DeviceIntPtr dev)
{
    TouchPointInfoPtr oldest = FindOldestPointerEmulatedTouch(dev);

    if (oldest && oldest->listeners[0].state == LISTENER_AWAITING_BEGIN)
        TouchPuntToNextOwner(dev, oldest, NULL);
}

/**
 * Process a touch rejection.
 *
 * @@param sourcedev The source device of the touch sequence.
 * @@param ti The touchpoint info record.
 * @@param resource The resource of the client rejecting the touch.
 * @@param ev TouchOwnership event to send. Set to NULL if no event should be
 *        sent.
 */
void
TouchRejected(DeviceIntPtr sourcedev, TouchPointInfoPtr ti, XID resource,
              TouchOwnershipEvent *ev)
{
    Bool was_owner = (resource == ti->listeners[0].listener);
    int i;

    /* Send a TouchEnd event to the resource being removed, but only if they
     * haven't received one yet already */
    for (i = 0; i < ti->num_listeners; i++) {
        if (ti->listeners[i].listener == resource) {
            if (ti->listeners[i].state != LISTENER_HAS_END)
                TouchEmitTouchEnd(sourcedev, ti, TOUCH_REJECT, resource);
            break;
        }
    }

    /* Remove the resource from the listener list, updating
     * ti->num_listeners, as well as ti->num_grabs if it was a grab. */
    TouchRemoveListener(ti, resource);

    /* If the current owner was removed and there are further listeners, deliver
     * the TouchOwnership or TouchBegin event to the new owner. */
    if (ev && ti->num_listeners > 0 && was_owner)
        TouchPuntToNextOwner(sourcedev, ti, ev);
    else if (ti->num_listeners == 0)
        TouchEndTouch(sourcedev, ti);

    CheckOldestTouch(sourcedev);
}

/**
 * Processes a TouchOwnership event, indicating a grab has accepted the touch
 * it currently owns, or a grab or selection has been removed.  Will generate
 * and send TouchEnd events to all clients removed from the delivery list, as
 * well as possibly sending the new TouchOwnership event.  May end the
 * touchpoint if it is pending finish.
 */
static void
ProcessTouchOwnershipEvent(TouchOwnershipEvent *ev,
                           DeviceIntPtr dev)
{
    TouchPointInfoPtr ti = TouchFindByClientID(dev, ev->touchid);

    if (!ti) {
        DebugF("[Xi] %s: Failed to get event %d for touchpoint %d\n",
               dev->name, ev->type, ev->touchid);
        return;
    }

    if (ev->reason == XIRejectTouch)
        TouchRejected(dev, ti, ev->resource, ev);
    else if (ev->reason == XIAcceptTouch) {
        int i;


        /* For pointer-emulated listeners that ungrabbed the active grab,
         * the state was forced to LISTENER_HAS_END. Still go
         * through the motions of ending the touch if the listener has
         * already seen the end. This ensures that the touch record is ended in
         * the server.
         */
        if (ti->listeners[0].state == LISTENER_HAS_END)
            TouchEmitTouchEnd(dev, ti, TOUCH_ACCEPT, ti->listeners[0].listener);

        /* The touch owner has accepted the touch.  Send TouchEnd events to
         * everyone else, and truncate the list of listeners. */
        for (i = 1; i < ti->num_listeners; i++)
            TouchEmitTouchEnd(dev, ti, TOUCH_ACCEPT, ti->listeners[i].listener);

        while (ti->num_listeners > 1)
            TouchRemoveListener(ti, ti->listeners[1].listener);
        /* Owner accepted after receiving end */
        if (ti->listeners[0].state == LISTENER_HAS_END)
            TouchEndTouch(dev, ti);
        else
            ti->listeners[0].state = LISTENER_HAS_ACCEPTED;
    }
    else {  /* this is the very first ownership event for a grab */
        DeliverTouchEvents(dev, ti, (InternalEvent *) ev, ev->resource);
    }
}

/**
 * Copy the event's valuator information into the touchpoint, we may need
 * this for emulated TouchEnd events.
 */
static void
TouchCopyValuatorData(DeviceEvent *ev, TouchPointInfoPtr ti)
{
    int i;

    for (i = 0; i < ARRAY_SIZE(ev->valuators.data); i++)
        if (BitIsOn(ev->valuators.mask, i))
            valuator_mask_set_double(ti->valuators, i, ev->valuators.data[i]);
}

/**
 * Given a touch event and a potential listener, retrieve info needed for
 * processing the event.
 *
 * @@param dev The device generating the touch event.
 * @@param ti The touch point info record for the touch event.
 * @@param ev The touch event to process.
 * @@param listener The touch event listener that may receive the touch event.
 * @@param[out] client The client that should receive the touch event.
 * @@param[out] win The window to deliver the event on.
 * @@param[out] grab The grab to deliver the event through, if any.
 * @@param[out] mask The XI 2.x event mask of the grab or selection, if any.
 * @@return TRUE if an event should be delivered to the listener, FALSE
 *         otherwise.
 */
static Bool
RetrieveTouchDeliveryData(DeviceIntPtr dev, TouchPointInfoPtr ti,
                          InternalEvent *ev, TouchListener * listener,
                          ClientPtr *client, WindowPtr *win, GrabPtr *grab,
                          XI2Mask **mask)
{
    int rc;
    InputClients *iclients = NULL;
    *mask = NULL;

    if (listener->type == LISTENER_GRAB ||
        listener->type == LISTENER_POINTER_GRAB) {

        *grab = listener->grab;

        BUG_RETURN_VAL(!*grab, FALSE);

        *client = rClient(*grab);
        *win = (*grab)->window;
        *mask = (*grab)->xi2mask;
    }
    else {
        rc = dixLookupResourceByType((void **) win, listener->listener,
                                     listener->resource_type,
                                     serverClient, DixSendAccess);
        if (rc != Success)
            return FALSE;

        if (listener->level == XI2) {
            int evtype;

            if (ti->emulate_pointer &&
                listener->type == LISTENER_POINTER_REGULAR)
                evtype = GetXI2Type(TouchGetPointerEventType(ev));
            else
                evtype = GetXI2Type(ev->any.type);

            nt_list_for_each_entry(iclients,
                                   wOtherInputMasks(*win)->inputClients, next)
                if (xi2mask_isset(iclients->xi2mask, dev, evtype))
                break;

            BUG_RETURN_VAL(!iclients, FALSE);

            *mask = iclients->xi2mask;
            *client = rClient(iclients);
        }
        else if (listener->level == XI) {
            int xi_type = GetXIType(TouchGetPointerEventType(ev));
            Mask xi_filter = event_get_filter_from_type(dev, xi_type);

            nt_list_for_each_entry(iclients,
                                   wOtherInputMasks(*win)->inputClients, next)
                if (iclients->mask[dev->id] & xi_filter)
                break;
            BUG_RETURN_VAL(!iclients, FALSE);

            *client = rClient(iclients);
        }
        else {
            int coretype = GetCoreType(TouchGetPointerEventType(ev));
            Mask core_filter = event_get_filter_from_type(dev, coretype);
            OtherClients *oclients;

            /* all others */
            nt_list_for_each_entry(oclients,
                                   (OtherClients *) wOtherClients(*win), next)
                if (oclients->mask & core_filter)
                    break;

            /* if owner selected, oclients is NULL */
            *client = oclients ? rClient(oclients) : wClient(*win);
        }

        *grab = NULL;
    }

    return TRUE;
}

static int
DeliverTouchEmulatedEvent(DeviceIntPtr dev, TouchPointInfoPtr ti,
                          InternalEvent *ev, TouchListener * listener,
                          ClientPtr client, WindowPtr win, GrabPtr grab,
                          XI2Mask *xi2mask)
{
    InternalEvent motion, button;
    InternalEvent *ptrev = &motion;
    int nevents;
    DeviceIntPtr kbd;

    /* We don't deliver pointer events to non-owners */
    if (!TouchResourceIsOwner(ti, listener->listener))
        return !Success;

    if (!ti->emulate_pointer)
        return !Success;

    nevents = TouchConvertToPointerEvent(ev, &motion, &button);
    BUG_RETURN_VAL(nevents == 0, BadValue);

    if (nevents > 1)
        ptrev = &button;

    kbd = GetMaster(dev, KEYBOARD_OR_FLOAT);
    event_set_state(dev, kbd, &ptrev->device_event);
    ptrev->device_event.corestate = event_get_corestate(dev, kbd);

    if (grab) {
        /* this side-steps the usual activation mechanisms, but... */
        if (ev->any.type == ET_TouchBegin && !dev->deviceGrab.grab)
            ActivatePassiveGrab(dev, grab, ptrev, ev);  /* also delivers the event */
        else {
            int deliveries = 0;

            /* 'grab' is the passive grab, but if the grab isn't active,
             * don't deliver */
            if (!dev->deviceGrab.grab)
                return !Success;

            if (grab->ownerEvents) {
                WindowPtr focus = NullWindow;
                WindowPtr sprite_win = DeepestSpriteWin(dev->spriteInfo->sprite);

                deliveries = DeliverDeviceEvents(sprite_win, ptrev, grab, focus, dev);
            }

            if (!deliveries)
                deliveries = DeliverOneGrabbedEvent(ptrev, dev, grab->grabtype);

            /* We must accept the touch sequence once a pointer listener has
             * received one event past ButtonPress. */
            if (deliveries && ev->any.type != ET_TouchBegin &&
                !(ev->device_event.flags & TOUCH_CLIENT_ID))
                TouchListenerAcceptReject(dev, ti, 0, XIAcceptTouch);

            if (ev->any.type == ET_TouchEnd &&
                ti->num_listeners == 1 &&
                !dev->button->buttonsDown &&
                dev->deviceGrab.fromPassiveGrab && GrabIsPointerGrab(grab)) {
                (*dev->deviceGrab.DeactivateGrab) (dev);
                CheckOldestTouch(dev);
                return Success;
            }
        }
    }
    else {
        GrabPtr devgrab = dev->deviceGrab.grab;
        WindowPtr sprite_win = DeepestSpriteWin(dev->spriteInfo->sprite);

        DeliverDeviceEvents(sprite_win, ptrev, grab, win, dev);
        /* FIXME: bad hack
         * Implicit passive grab activated in response to this event. Store
         * the event.
         */
        if (!devgrab && dev->deviceGrab.grab && dev->deviceGrab.implicitGrab) {
            TouchListener *l;
            GrabPtr g;

            devgrab = dev->deviceGrab.grab;
            g = AllocGrab(devgrab);
            BUG_WARN(!g);

            *dev->deviceGrab.sync.event = ev->device_event;

            /* The listener array has a sequence of grabs and then one event
             * selection. Implicit grab activation occurs through delivering an
             * event selection. Thus, we update the last listener in the array.
             */
            l = &ti->listeners[ti->num_listeners - 1];
            l->listener = g->resource;
            l->grab = g;
            //l->resource_type = RT_NONE;

            if (devgrab->grabtype != XI2 || devgrab->type != XI_TouchBegin)
                l->type = LISTENER_POINTER_GRAB;
            else
                l->type = LISTENER_GRAB;
        }

    }
    if (ev->any.type == ET_TouchBegin)
        listener->state = LISTENER_IS_OWNER;
    else if (ev->any.type == ET_TouchEnd)
        listener->state = LISTENER_HAS_END;

    return Success;
}

static void
DeliverEmulatedMotionEvent(DeviceIntPtr dev, TouchPointInfoPtr ti,
                           InternalEvent *ev)
{
    DeviceEvent motion;

    if (ti->num_listeners) {
        ClientPtr client;
        WindowPtr win;
        GrabPtr grab;
        XI2Mask *mask;

        if (ti->listeners[0].type != LISTENER_POINTER_REGULAR &&
            ti->listeners[0].type != LISTENER_POINTER_GRAB)
            return;

        motion = ev->device_event;
        motion.type = ET_TouchUpdate;
        motion.detail.button = 0;

        if (!RetrieveTouchDeliveryData(dev, ti, (InternalEvent*)&motion,
                                       &ti->listeners[0], &client, &win, &grab,
                                       &mask))
            return;

        /* There may be a pointer grab on the device */
        if (!grab) {
            grab = dev->deviceGrab.grab;
            if (grab) {
                win = grab->window;
                mask = grab->xi2mask;
                client = rClient(grab);
            }
        }

        DeliverTouchEmulatedEvent(dev, ti, (InternalEvent*)&motion, &ti->listeners[0], client,
                                  win, grab, mask);
    }
    else {
        InternalEvent button;
        int converted;

        converted = TouchConvertToPointerEvent(ev, (InternalEvent*)&motion, &button);

        BUG_WARN(converted == 0);
        if (converted)
            ProcessOtherEvent((InternalEvent*)&motion, dev);
    }
}

/**
 * Processes and delivers a TouchBegin, TouchUpdate, or a
 * TouchEnd event.
 *
 * Due to having rather different delivery semantics (see the Xi 2.2 protocol
 * spec for more information), this implements its own grab and event-selection
 * delivery logic.
 */
static void
ProcessTouchEvent(InternalEvent *ev, DeviceIntPtr dev)
{
    TouchClassPtr t = dev->touch;
    TouchPointInfoPtr ti;
    uint32_t touchid;
    int type = ev->any.type;
    int emulate_pointer = ! !(ev->device_event.flags & TOUCH_POINTER_EMULATED);
    DeviceIntPtr kbd;

    if (!t)
        return;

    touchid = ev->device_event.touchid;

    if (type == ET_TouchBegin && !(ev->device_event.flags & TOUCH_REPLAYING)) {
        ti = TouchBeginTouch(dev, ev->device_event.sourceid, touchid,
                             emulate_pointer);
    }
    else
        ti = TouchFindByClientID(dev, touchid);

    /* Active pointer grab */
    if (emulate_pointer && dev->deviceGrab.grab && !dev->deviceGrab.fromPassiveGrab &&
        (dev->deviceGrab.grab->grabtype == CORE ||
         dev->deviceGrab.grab->grabtype == XI ||
         !xi2mask_isset(dev->deviceGrab.grab->xi2mask, dev, XI_TouchBegin)))
    {
        /* Active pointer grab on touch point and we get a TouchEnd - claim this
         * touchpoint accepted, otherwise clients waiting for ownership will
         * wait on this touchpoint until this client ungrabs, or the cows come
         * home, whichever is earlier */
        if (ti && type == ET_TouchEnd)
            TouchListenerAcceptReject(dev, ti, 0, XIAcceptTouch);
        else if (!ti && type != ET_TouchBegin) {
            /* Under the following circumstances we create a new touch record for an
             * existing touch:
             *
             * - The touch may be pointer emulated
             * - An explicit grab is active on the device
             * - The grab is a pointer grab
             *
             * This allows for an explicit grab to receive pointer events for an already
             * active touch.
             */
            ti = TouchBeginTouch(dev, ev->device_event.sourceid, touchid,
                                 emulate_pointer);
            if (!ti) {
                DebugF("[Xi] %s: Failed to create new dix record for explicitly "
                       "grabbed touchpoint %d\n",
                       dev->name, touchid);
                return;
            }

            TouchBuildSprite(dev, ti, ev);
            TouchSetupListeners(dev, ti, ev);
        }
    }

    if (!ti) {
        DebugF("[Xi] %s: Failed to get event %d for touchpoint %d\n",
               dev->name, type, touchid);
        goto out;
    }

    /* if emulate_pointer is set, emulate the motion event right
     * here, so we can ignore it for button event emulation. TouchUpdate
     * events which _only_ emulate motion just work normally */
    if (emulate_pointer && ev->any.type != ET_TouchUpdate)
        DeliverEmulatedMotionEvent(dev, ti, ev);

    if (emulate_pointer && IsMaster(dev))
        CheckMotion(&ev->device_event, dev);

    kbd = GetMaster(dev, KEYBOARD_OR_FLOAT);
    event_set_state(NULL, kbd, &ev->device_event);
    ev->device_event.corestate = event_get_corestate(NULL, kbd);

    /* Make sure we have a valid window trace for event delivery; must be
     * called after event type mutation. Touch end events are always processed
     * in order to end touch records. */
    /* FIXME: check this */
    if ((type == ET_TouchBegin &&
         !(ev->device_event.flags & TOUCH_REPLAYING) &&
         !TouchBuildSprite(dev, ti, ev)) ||
        (type != ET_TouchEnd && ti->sprite.spriteTraceGood == 0))
        return;

    TouchCopyValuatorData(&ev->device_event, ti);
    /* WARNING: the event type may change to TouchUpdate in
     * DeliverTouchEvents if a TouchEnd was delivered to a grabbing
     * owner */
    DeliverTouchEvents(dev, ti, ev, ev->device_event.resource);
    if (ev->any.type == ET_TouchEnd)
        TouchEndTouch(dev, ti);

 out:
    if (emulate_pointer)
        UpdateDeviceState(dev, &ev->device_event);
}

static void
ProcessBarrierEvent(InternalEvent *e, DeviceIntPtr dev)
{
    Mask filter;
    WindowPtr pWin;
    BarrierEvent *be = &e->barrier_event;
    xEvent *ev;
    int rc;
    GrabPtr grab = dev->deviceGrab.grab;

    if (!IsMaster(dev))
        return;

    if (dixLookupWindow(&pWin, be->window, serverClient, DixReadAccess) != Success)
        return;

    if (grab)
        be->flags |= XIBarrierDeviceIsGrabbed;

    rc = EventToXI2(e, &ev);
    if (rc != Success) {
        ErrorF("[Xi] event conversion from %s failed with code %d\n", __func__, rc);
        return;
    }

    /* A client has a grab, deliver to this client if the grab_window is the
       barrier window.

       Otherwise, deliver normally to the client.
     */
    if (grab &&
        CLIENT_ID(be->barrierid) == CLIENT_ID(grab->resource) &&
        grab->window->drawable.id == be->window) {
        DeliverGrabbedEvent(e, dev, FALSE);
    } else {
        filter = GetEventFilter(dev, ev);

        DeliverEventsToWindow(dev, pWin, ev, 1,
                              filter, NullGrab);
    }
    free(ev);
}

/**
 * Process DeviceEvents and DeviceChangedEvents.
 */
static void
ProcessDeviceEvent(InternalEvent *ev, DeviceIntPtr device)
{
    GrabPtr grab;
    Bool deactivateDeviceGrab = FALSE;
    int key = 0, rootX, rootY;
    ButtonClassPtr b;
    int ret = 0;
    int corestate;
    DeviceIntPtr mouse = NULL, kbd = NULL;
    DeviceEvent *event = &ev->device_event;

    if (IsPointerDevice(device)) {
        kbd = GetMaster(device, KEYBOARD_OR_FLOAT);
        mouse = device;
        if (!kbd->key)          /* can happen with floating SDs */
            kbd = NULL;
    }
    else {
        mouse = GetMaster(device, POINTER_OR_FLOAT);
        kbd = device;
        if (!mouse->valuator || !mouse->button) /* may be float. SDs */
            mouse = NULL;
    }

    corestate = event_get_corestate(mouse, kbd);
    event_set_state(mouse, kbd, event);

    ret = UpdateDeviceState(device, event);
    if (ret == DONT_PROCESS)
        return;

    b = device->button;

    if (IsMaster(device) || IsFloating(device))
        CheckMotion(event, device);

    switch (event->type) {
    case ET_Motion:
    case ET_ButtonPress:
    case ET_ButtonRelease:
    case ET_KeyPress:
    case ET_KeyRelease:
    case ET_ProximityIn:
    case ET_ProximityOut:
        GetSpritePosition(device, &rootX, &rootY);
        event->root_x = rootX;
        event->root_y = rootY;
        NoticeEventTime((InternalEvent *) event, device);
        event->corestate = corestate;
        key = event->detail.key;
        break;
    default:
        break;
    }

    /* send KeyPress and KeyRelease events to XACE plugins */
    if (XaceHookIsSet(XACE_KEY_AVAIL) &&
            (event->type == ET_KeyPress || event->type == ET_KeyRelease)) {
        xEvent *core;
        int count;

        if (EventToCore(ev, &core, &count) == Success && count > 0) {
            XaceHook(XACE_KEY_AVAIL, core, device, 0);
            free(core);
        }
    }

    if (DeviceEventCallback && !syncEvents.playingEvents) {
        DeviceEventInfoRec eventinfo;
        SpritePtr pSprite = device->spriteInfo->sprite;

        /* see comment in EnqueueEvents regarding the next three lines */
        if (ev->any.type == ET_Motion)
            ev->device_event.root = pSprite->hotPhys.pScreen->root->drawable.id;

        eventinfo.device = device;
        eventinfo.event = ev;
        CallCallbacks(&DeviceEventCallback, (void *) &eventinfo);
    }

    grab = device->deviceGrab.grab;

    switch (event->type) {
    case ET_KeyPress:
        if (!grab && CheckDeviceGrabs(device, event, 0))
            return;
        break;
    case ET_KeyRelease:
        if (grab && device->deviceGrab.fromPassiveGrab &&
            (key == device->deviceGrab.activatingKey) &&
            GrabIsKeyboardGrab(device->deviceGrab.grab))
            deactivateDeviceGrab = TRUE;
        break;
    case ET_ButtonPress:
        if (b->map[key] == 0)   /* there's no button 0 */
            return;
        event->detail.button = b->map[key];
        if (!grab && CheckDeviceGrabs(device, event, 0)) {
            /* if a passive grab was activated, the event has been sent
             * already */
            return;
        }
        break;
    case ET_ButtonRelease:
        if (b->map[key] == 0)   /* there's no button 0 */
            return;
        event->detail.button = b->map[key];
        if (grab && !b->buttonsDown &&
            device->deviceGrab.fromPassiveGrab &&
            GrabIsPointerGrab(device->deviceGrab.grab))
            deactivateDeviceGrab = TRUE;
    default:
        break;
    }

    if (grab)
        DeliverGrabbedEvent((InternalEvent *) event, device,
                            deactivateDeviceGrab);
    else if (device->focus && !IsPointerEvent(ev))
        DeliverFocusedEvent(device, (InternalEvent *) event,
                            GetSpriteWindow(device));
    else
        DeliverDeviceEvents(GetSpriteWindow(device), (InternalEvent *) event,
                            NullGrab, NullWindow, device);

    if (deactivateDeviceGrab == TRUE) {
        (*device->deviceGrab.DeactivateGrab) (device);

        if (!IsMaster (device) && !IsFloating (device)) {
            int flags, num_events = 0;
            InternalEvent dce;

            flags = (IsPointerDevice (device)) ?
                DEVCHANGE_POINTER_EVENT : DEVCHANGE_KEYBOARD_EVENT;
            UpdateFromMaster (&dce, device, flags, &num_events);
            BUG_WARN(num_events > 1);

            if (num_events == 1)
                ChangeMasterDeviceClasses(GetMaster (device, MASTER_ATTACHED),
                                          &dce.changed_event);
        }

    }

    event->detail.key = key;
}

/**
 * Main device event processing function.
 * Called from when processing the events from the event queue.
 *
 */
void
ProcessOtherEvent(InternalEvent *ev, DeviceIntPtr device)
{
    verify_internal_event(ev);

    switch (ev->any.type) {
    case ET_RawKeyPress:
    case ET_RawKeyRelease:
    case ET_RawButtonPress:
    case ET_RawButtonRelease:
    case ET_RawMotion:
    case ET_RawTouchBegin:
    case ET_RawTouchUpdate:
    case ET_RawTouchEnd:
        DeliverRawEvent(&ev->raw_event, device);
        break;
    case ET_TouchBegin:
    case ET_TouchUpdate:
    case ET_TouchEnd:
        ProcessTouchEvent(ev, device);
        break;
    case ET_TouchOwnership:
        /* TouchOwnership events are handled separately from the rest, as they
         * have more complex semantics. */
        ProcessTouchOwnershipEvent(&ev->touch_ownership_event, device);
        break;
    case ET_BarrierHit:
    case ET_BarrierLeave:
        ProcessBarrierEvent(ev, device);
        break;
    default:
        ProcessDeviceEvent(ev, device);
        break;
    }
}

static int
DeliverTouchBeginEvent(DeviceIntPtr dev, TouchPointInfoPtr ti,
                       InternalEvent *ev, TouchListener * listener,
                       ClientPtr client, WindowPtr win, GrabPtr grab,
                       XI2Mask *xi2mask)
{
    enum TouchListenerState state;
    int rc = Success;
    Bool has_ownershipmask;

    if (listener->type == LISTENER_POINTER_REGULAR ||
        listener->type == LISTENER_POINTER_GRAB) {
        rc = DeliverTouchEmulatedEvent(dev, ti, ev, listener, client, win,
                                       grab, xi2mask);
        if (rc == Success) {
            listener->state = LISTENER_IS_OWNER;
            /* async grabs cannot replay, so automatically accept this touch */
            if (listener->type == LISTENER_POINTER_GRAB &&
                dev->deviceGrab.grab &&
                dev->deviceGrab.fromPassiveGrab &&
                dev->deviceGrab.grab->pointerMode == GrabModeAsync)
                ActivateEarlyAccept(dev, ti);
        }
        goto out;
    }

    has_ownershipmask = xi2mask_isset(xi2mask, dev, XI_TouchOwnership);

    if (TouchResourceIsOwner(ti, listener->listener) || has_ownershipmask)
        rc = DeliverOneTouchEvent(client, dev, ti, grab, win, ev);
    if (!TouchResourceIsOwner(ti, listener->listener)) {
        if (has_ownershipmask)
            state = LISTENER_AWAITING_OWNER;
        else
            state = LISTENER_AWAITING_BEGIN;
    }
    else {
        if (has_ownershipmask)
            TouchSendOwnershipEvent(dev, ti, 0, listener->listener);

        if (listener->type == LISTENER_REGULAR)
            state = LISTENER_HAS_ACCEPTED;
        else
            state = LISTENER_IS_OWNER;
    }
    listener->state = state;

 out:
    return rc;
}

static int
DeliverTouchEndEvent(DeviceIntPtr dev, TouchPointInfoPtr ti, InternalEvent *ev,
                     TouchListener * listener, ClientPtr client,
                     WindowPtr win, GrabPtr grab, XI2Mask *xi2mask)
{
    int rc = Success;

    if (listener->type == LISTENER_POINTER_REGULAR ||
        listener->type == LISTENER_POINTER_GRAB) {
        /* Note: If the active grab was ungrabbed, we already changed the
         * state to LISTENER_HAS_END but still get here. So we mustn't
         * actually send the event.
         * This is part two of the hack in DeactivatePointerGrab
         */
        if (listener->state != LISTENER_HAS_END) {
            rc = DeliverTouchEmulatedEvent(dev, ti, ev, listener, client, win,
                                           grab, xi2mask);

             /* Once we send a TouchEnd to a legacy listener, we're already well
              * past the accepting/rejecting stage (can only happen on
              * GrabModeSync + replay. This listener now gets the end event,
              * and we can continue.
              */
            if (rc == Success)
                listener->state = LISTENER_HAS_END;
        }
        goto out;
    }

    /* A client is waiting for the begin, don't give it a TouchEnd */
    if (listener->state == LISTENER_AWAITING_BEGIN) {
        listener->state = LISTENER_HAS_END;
        goto out;
    }

    /* Event in response to reject */
    if (ev->device_event.flags & TOUCH_REJECT ||
        (ev->device_event.flags & TOUCH_ACCEPT && !TouchResourceIsOwner(ti, listener->listener))) {
        /* Touch has been rejected, or accepted by its owner which is not this listener */
        if (listener->state != LISTENER_HAS_END)
            rc = DeliverOneTouchEvent(client, dev, ti, grab, win, ev);
        listener->state = LISTENER_HAS_END;
    }
    else if (TouchResourceIsOwner(ti, listener->listener)) {
        Bool normal_end = !(ev->device_event.flags & TOUCH_ACCEPT);

        /* FIXME: what about early acceptance */
        if (normal_end && listener->state != LISTENER_HAS_END)
            rc = DeliverOneTouchEvent(client, dev, ti, grab, win, ev);

        if ((ti->num_listeners > 1 ||
             (ti->num_grabs > 0 && listener->state != LISTENER_HAS_ACCEPTED)) &&
            (ev->device_event.flags & (TOUCH_ACCEPT | TOUCH_REJECT)) == 0) {
            ev->any.type = ET_TouchUpdate;
            ev->device_event.flags |= TOUCH_PENDING_END;
            ti->pending_finish = TRUE;
        }

        if (normal_end)
            listener->state = LISTENER_HAS_END;
    }

 out:
    return rc;
}

static int
DeliverTouchEvent(DeviceIntPtr dev, TouchPointInfoPtr ti, InternalEvent *ev,
                  TouchListener * listener, ClientPtr client,
                  WindowPtr win, GrabPtr grab, XI2Mask *xi2mask)
{
    Bool has_ownershipmask = FALSE;
    int rc = Success;

    if (xi2mask)
        has_ownershipmask = xi2mask_isset(xi2mask, dev, XI_TouchOwnership);

    if (ev->any.type == ET_TouchOwnership) {
        ev->touch_ownership_event.deviceid = dev->id;
        if (!TouchResourceIsOwner(ti, listener->listener))
            goto out;
        rc = DeliverOneTouchEvent(client, dev, ti, grab, win, ev);
        listener->state = LISTENER_IS_OWNER;
    }
    else
        ev->device_event.deviceid = dev->id;

    if (ev->any.type == ET_TouchBegin) {
        rc = DeliverTouchBeginEvent(dev, ti, ev, listener, client, win, grab,
                                    xi2mask);
    }
    else if (ev->any.type == ET_TouchUpdate) {
        if (listener->type == LISTENER_POINTER_REGULAR ||
            listener->type == LISTENER_POINTER_GRAB)
            DeliverTouchEmulatedEvent(dev, ti, ev, listener, client, win, grab,
                                      xi2mask);
        else if (TouchResourceIsOwner(ti, listener->listener) ||
                 has_ownershipmask)
            rc = DeliverOneTouchEvent(client, dev, ti, grab, win, ev);
    }
    else if (ev->any.type == ET_TouchEnd)
        rc = DeliverTouchEndEvent(dev, ti, ev, listener, client, win, grab,
                                  xi2mask);

 out:
    return rc;
}

/**
 * Delivers a touch events to all interested clients.  For TouchBegin events,
 * will update ti->listeners, ti->num_listeners, and ti->num_grabs.
 * May also mutate ev (type and flags) upon successful delivery.  If
 * @@resource is non-zero, will only attempt delivery to the owner of that
 * resource.
 *
 * @@return TRUE if the event was delivered at least once, FALSE otherwise
 */
void
DeliverTouchEvents(DeviceIntPtr dev, TouchPointInfoPtr ti,
                   InternalEvent *ev, XID resource)
{
    int i;

    if (ev->any.type == ET_TouchBegin &&
        !(ev->device_event.flags & (TOUCH_CLIENT_ID | TOUCH_REPLAYING)))
        TouchSetupListeners(dev, ti, ev);

    TouchEventHistoryPush(ti, &ev->device_event);

    for (i = 0; i < ti->num_listeners; i++) {
        GrabPtr grab = NULL;
        ClientPtr client;
        WindowPtr win;
        XI2Mask *mask;
        TouchListener *listener = &ti->listeners[i];

        if (resource && listener->listener != resource)
            continue;

        if (!RetrieveTouchDeliveryData(dev, ti, ev, listener, &client, &win,
                                       &grab, &mask))
            continue;

        DeliverTouchEvent(dev, ti, ev, listener, client, win, grab, mask);
    }
}

int
InitProximityClassDeviceStruct(DeviceIntPtr dev)
{
    ProximityClassPtr proxc;

    BUG_RETURN_VAL(dev == NULL, FALSE);
    BUG_RETURN_VAL(dev->proximity != NULL, FALSE);

    proxc = (ProximityClassPtr) malloc(sizeof(ProximityClassRec));
    if (!proxc)
        return FALSE;
    proxc->sourceid = dev->id;
    proxc->in_proximity = TRUE;
    dev->proximity = proxc;
    return TRUE;
}

/**
 * Initialise the device's valuators. The memory must already be allocated,
 * this function merely inits the matching axis (specified through axnum) to
 * sane values.
 *
 * It is a condition that (minval < maxval).
 *
 * @@see InitValuatorClassDeviceStruct
 */
Bool
InitValuatorAxisStruct(DeviceIntPtr dev, int axnum, Atom label, int minval,
                       int maxval, int resolution, int min_res, int max_res,
                       int mode)
{
    AxisInfoPtr ax;

    BUG_RETURN_VAL(dev == NULL, FALSE);
    BUG_RETURN_VAL(dev->valuator == NULL, FALSE);
    BUG_RETURN_VAL(axnum >= dev->valuator->numAxes, FALSE);
    BUG_RETURN_VAL(minval > maxval && mode == Absolute, FALSE);

    ax = dev->valuator->axes + axnum;

    ax->min_value = minval;
    ax->max_value = maxval;
    ax->resolution = resolution;
    ax->min_resolution = min_res;
    ax->max_resolution = max_res;
    ax->label = label;
    ax->mode = mode;

    if (mode & OutOfProximity)
        dev->proximity->in_proximity = FALSE;

    return SetScrollValuator(dev, axnum, SCROLL_TYPE_NONE, 0, SCROLL_FLAG_NONE);
}

/**
 * Set the given axis number as a scrolling valuator.
 */
Bool
SetScrollValuator(DeviceIntPtr dev, int axnum, enum ScrollType type,
                  double increment, int flags)
{
    AxisInfoPtr ax;
    int *current_ax;
    InternalEvent dce;
    DeviceIntPtr master;

    BUG_RETURN_VAL(dev == NULL, FALSE);
    BUG_RETURN_VAL(dev->valuator == NULL, FALSE);
    BUG_RETURN_VAL(axnum >= dev->valuator->numAxes, FALSE);

    switch (type) {
    case SCROLL_TYPE_VERTICAL:
        current_ax = &dev->valuator->v_scroll_axis;
        break;
    case SCROLL_TYPE_HORIZONTAL:
        current_ax = &dev->valuator->h_scroll_axis;
        break;
    case SCROLL_TYPE_NONE:
        ax = &dev->valuator->axes[axnum];
        ax->scroll.type = type;
        return TRUE;
    default:
        return FALSE;
    }

    if (increment == 0.0)
        return FALSE;

    if (*current_ax != -1 && axnum != *current_ax) {
        ax = &dev->valuator->axes[*current_ax];
        if (ax->scroll.type == type &&
            (flags & SCROLL_FLAG_PREFERRED) &&
            (ax->scroll.flags & SCROLL_FLAG_PREFERRED))
            return FALSE;
    }
    *current_ax = axnum;

    ax = &dev->valuator->axes[axnum];
    ax->scroll.type = type;
    ax->scroll.increment = increment;
    ax->scroll.flags = flags;

    master = GetMaster(dev, MASTER_ATTACHED);
    CreateClassesChangedEvent(&dce, master, dev,
                              DEVCHANGE_POINTER_EVENT |
                              DEVCHANGE_DEVICE_CHANGE);
    XISendDeviceChangedEvent(dev, &dce.changed_event);

    /* if the current slave is us, update the master. If not, we'll update
     * whenever the next slave switch happens anyway. CMDC sends the event
     * for us */
    if (master && master->lastSlave == dev)
        ChangeMasterDeviceClasses(master, &dce.changed_event);

    return TRUE;
}

int
CheckGrabValues(ClientPtr client, GrabParameters *param)
{
    if (param->grabtype != CORE &&
        param->grabtype != XI && param->grabtype != XI2) {
        ErrorF("[Xi] grabtype is invalid. This is a bug.\n");
        return BadImplementation;
    }

    if ((param->this_device_mode != GrabModeSync) &&
        (param->this_device_mode != GrabModeAsync) &&
        (param->this_device_mode != XIGrabModeTouch)) {
        client->errorValue = param->this_device_mode;
        return BadValue;
    }
    if ((param->other_devices_mode != GrabModeSync) &&
        (param->other_devices_mode != GrabModeAsync) &&
        (param->other_devices_mode != XIGrabModeTouch)) {
        client->errorValue = param->other_devices_mode;
        return BadValue;
    }

    if (param->modifiers != AnyModifier &&
        param->modifiers != XIAnyModifier &&
        (param->modifiers & ~AllModifiersMask)) {
        client->errorValue = param->modifiers;
        return BadValue;
    }

    if ((param->ownerEvents != xFalse) && (param->ownerEvents != xTrue)) {
        client->errorValue = param->ownerEvents;
        return BadValue;
    }
    return Success;
}

int
GrabButton(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr modifier_device,
           int button, GrabParameters *param, enum InputLevel grabtype,
           GrabMask *mask)
{
    WindowPtr pWin, confineTo;
    CursorPtr cursor;
    GrabPtr grab;
    int rc, type = -1;
    Mask access_mode = DixGrabAccess;

    rc = CheckGrabValues(client, param);
    if (rc != Success)
        return rc;
    if (param->confineTo == None)
        confineTo = NullWindow;
    else {
        rc = dixLookupWindow(&confineTo, param->confineTo, client,
                             DixSetAttrAccess);
        if (rc != Success)
            return rc;
    }
    if (param->cursor == None)
        cursor = NullCursor;
    else {
        rc = dixLookupResourceByType((void **) &cursor, param->cursor,
                                     RT_CURSOR, client, DixUseAccess);
        if (rc != Success) {
            client->errorValue = param->cursor;
            return rc;
        }
        access_mode |= DixForceAccess;
    }
    if (param->this_device_mode == GrabModeSync ||
        param->other_devices_mode == GrabModeSync)
        access_mode |= DixFreezeAccess;
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, access_mode);
    if (rc != Success)
        return rc;
    rc = dixLookupWindow(&pWin, param->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;

    if (grabtype == XI)
        type = DeviceButtonPress;
    else if (grabtype == XI2)
        type = XI_ButtonPress;

    grab = CreateGrab(client->index, dev, modifier_device, pWin, grabtype,
                      mask, param, type, button, confineTo, cursor);
    if (!grab)
        return BadAlloc;
    return AddPassiveGrabToList(client, grab);
}

/**
 * Grab the given key.
 */
int
GrabKey(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr modifier_device,
        int key, GrabParameters *param, enum InputLevel grabtype,
        GrabMask *mask)
{
    WindowPtr pWin;
    GrabPtr grab;
    KeyClassPtr k = dev->key;
    Mask access_mode = DixGrabAccess;
    int rc, type = -1;

    rc = CheckGrabValues(client, param);
    if (rc != Success)
        return rc;
    if ((dev->id != XIAllDevices && dev->id != XIAllMasterDevices) && k == NULL)
        return BadMatch;
    if (grabtype == XI) {
        if ((key > k->xkbInfo->desc->max_key_code ||
             key < k->xkbInfo->desc->min_key_code)
            && (key != AnyKey)) {
            client->errorValue = key;
            return BadValue;
        }
        type = DeviceKeyPress;
    }
    else if (grabtype == XI2)
        type = XI_KeyPress;

    rc = dixLookupWindow(&pWin, param->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;
    if (param->this_device_mode == GrabModeSync ||
        param->other_devices_mode == GrabModeSync)
        access_mode |= DixFreezeAccess;
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, access_mode);
    if (rc != Success)
        return rc;

    grab = CreateGrab(client->index, dev, modifier_device, pWin, grabtype,
                      mask, param, type, key, NULL, NULL);
    if (!grab)
        return BadAlloc;
    return AddPassiveGrabToList(client, grab);
}

/* Enter/FocusIn grab */
int
GrabWindow(ClientPtr client, DeviceIntPtr dev, int type,
           GrabParameters *param, GrabMask *mask)
{
    WindowPtr pWin;
    CursorPtr cursor;
    GrabPtr grab;
    Mask access_mode = DixGrabAccess;
    int rc;

    rc = CheckGrabValues(client, param);
    if (rc != Success)
        return rc;

    rc = dixLookupWindow(&pWin, param->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;
    if (param->cursor == None)
        cursor = NullCursor;
    else {
        rc = dixLookupResourceByType((void **) &cursor, param->cursor,
                                     RT_CURSOR, client, DixUseAccess);
        if (rc != Success) {
            client->errorValue = param->cursor;
            return rc;
        }
        access_mode |= DixForceAccess;
    }
    if (param->this_device_mode == GrabModeSync ||
        param->other_devices_mode == GrabModeSync)
        access_mode |= DixFreezeAccess;
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, access_mode);
    if (rc != Success)
        return rc;

    grab = CreateGrab(client->index, dev, dev, pWin, XI2,
                      mask, param,
                      (type == XIGrabtypeEnter) ? XI_Enter : XI_FocusIn, 0,
                      NULL, cursor);

    if (!grab)
        return BadAlloc;

    return AddPassiveGrabToList(client, grab);
}

/* Touch grab */
int
GrabTouch(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr mod_dev,
          GrabParameters *param, GrabMask *mask)
{
    WindowPtr pWin;
    GrabPtr grab;
    int rc;

    rc = CheckGrabValues(client, param);
    if (rc != Success)
        return rc;

    rc = dixLookupWindow(&pWin, param->grabWindow, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixGrabAccess);
    if (rc != Success)
        return rc;

    grab = CreateGrab(client->index, dev, mod_dev, pWin, XI2,
                      mask, param, XI_TouchBegin, 0, NullWindow, NullCursor);
    if (!grab)
        return BadAlloc;

    return AddPassiveGrabToList(client, grab);
}

int
SelectForWindow(DeviceIntPtr dev, WindowPtr pWin, ClientPtr client,
                Mask mask, Mask exclusivemasks)
{
    int mskidx = dev->id;
    int i, ret;
    Mask check;
    InputClientsPtr others;

    check = (mask & exclusivemasks);
    if (wOtherInputMasks(pWin)) {
        if (check & wOtherInputMasks(pWin)->inputEvents[mskidx]) {
            /* It is illegal for two different clients to select on any of
             * the events for maskcheck. However, it is OK, for some client
             * to continue selecting on one of those events.
             */
            for (others = wOtherInputMasks(pWin)->inputClients; others;
                 others = others->next) {
                if (!SameClient(others, client) && (check &
                                                    others->mask[mskidx]))
                    return BadAccess;
            }
        }
        for (others = wOtherInputMasks(pWin)->inputClients; others;
             others = others->next) {
            if (SameClient(others, client)) {
                check = others->mask[mskidx];
                others->mask[mskidx] = mask;
                if (mask == 0) {
                    for (i = 0; i < EMASKSIZE; i++)
                        if (i != mskidx && others->mask[i] != 0)
                            break;
                    if (i == EMASKSIZE) {
                        RecalculateDeviceDeliverableEvents(pWin);
                        if (ShouldFreeInputMasks(pWin, FALSE))
                            FreeResource(others->resource, RT_NONE);
                        return Success;
                    }
                }
                goto maskSet;
            }
        }
    }
    check = 0;
    if ((ret = AddExtensionClient(pWin, client, mask, mskidx)) != Success)
        return ret;
 maskSet:
    if (dev->valuator)
        if ((dev->valuator->motionHintWindow == pWin) &&
            (mask & DevicePointerMotionHintMask) &&
            !(check & DevicePointerMotionHintMask) && !dev->deviceGrab.grab)
            dev->valuator->motionHintWindow = NullWindow;
    RecalculateDeviceDeliverableEvents(pWin);
    return Success;
}

static void
FreeInputClient(InputClientsPtr * other)
{
    xi2mask_free(&(*other)->xi2mask);
    free(*other);
    *other = NULL;
}

static InputClientsPtr
AllocInputClient(void)
{
    return calloc(1, sizeof(InputClients));
}

int
AddExtensionClient(WindowPtr pWin, ClientPtr client, Mask mask, int mskidx)
{
    InputClientsPtr others;

    if (!pWin->optional && !MakeWindowOptional(pWin))
        return BadAlloc;
    others = AllocInputClient();
    if (!others)
        return BadAlloc;
    if (!pWin->optional->inputMasks && !MakeInputMasks(pWin))
        goto bail;
    others->xi2mask = xi2mask_new();
    if (!others->xi2mask)
        goto bail;
    others->mask[mskidx] = mask;
    others->resource = FakeClientID(client->index);
    others->next = pWin->optional->inputMasks->inputClients;
    pWin->optional->inputMasks->inputClients = others;
    if (!AddResource(others->resource, RT_INPUTCLIENT, (void *) pWin))
        goto bail;
    return Success;

 bail:
    FreeInputClient(&others);
    return BadAlloc;
}

static Bool
MakeInputMasks(WindowPtr pWin)
{
    struct _OtherInputMasks *imasks;

    imasks = calloc(1, sizeof(struct _OtherInputMasks));
    if (!imasks)
        return FALSE;
    imasks->xi2mask = xi2mask_new();
    if (!imasks->xi2mask) {
        free(imasks);
        return FALSE;
    }
    pWin->optional->inputMasks = imasks;
    return TRUE;
}

static void
FreeInputMask(OtherInputMasks ** imask)
{
    xi2mask_free(&(*imask)->xi2mask);
    free(*imask);
    *imask = NULL;
}

void
RecalculateDeviceDeliverableEvents(WindowPtr pWin)
{
    InputClientsPtr others;
    struct _OtherInputMasks *inputMasks;        /* default: NULL */
    WindowPtr pChild, tmp;
    int i;

    pChild = pWin;
    while (1) {
        if ((inputMasks = wOtherInputMasks(pChild)) != 0) {
            xi2mask_zero(inputMasks->xi2mask, -1);
            for (others = inputMasks->inputClients; others;
                 others = others->next) {
                for (i = 0; i < EMASKSIZE; i++)
                    inputMasks->inputEvents[i] |= others->mask[i];
                xi2mask_merge(inputMasks->xi2mask, others->xi2mask);
            }
            for (i = 0; i < EMASKSIZE; i++)
                inputMasks->deliverableEvents[i] = inputMasks->inputEvents[i];
            for (tmp = pChild->parent; tmp; tmp = tmp->parent)
                if (wOtherInputMasks(tmp))
                    for (i = 0; i < EMASKSIZE; i++)
                        inputMasks->deliverableEvents[i] |=
                            (wOtherInputMasks(tmp)->deliverableEvents[i]
                             & ~inputMasks->dontPropagateMask[i] &
                             PropagateMask[i]);
        }
        if (pChild->firstChild) {
            pChild = pChild->firstChild;
            continue;
        }
        while (!pChild->nextSib && (pChild != pWin))
            pChild = pChild->parent;
        if (pChild == pWin)
            break;
        pChild = pChild->nextSib;
    }
}

int
InputClientGone(WindowPtr pWin, XID id)
{
    InputClientsPtr other, prev;

    if (!wOtherInputMasks(pWin))
        return Success;
    prev = 0;
    for (other = wOtherInputMasks(pWin)->inputClients; other;
         other = other->next) {
        if (other->resource == id) {
            if (prev) {
                prev->next = other->next;
                FreeInputClient(&other);
            }
            else if (!(other->next)) {
                if (ShouldFreeInputMasks(pWin, TRUE)) {
                    OtherInputMasks *mask = wOtherInputMasks(pWin);

                    mask->inputClients = other->next;
                    FreeInputMask(&mask);
                    pWin->optional->inputMasks = (OtherInputMasks *) NULL;
                    CheckWindowOptionalNeed(pWin);
                    FreeInputClient(&other);
                }
                else {
                    other->resource = FakeClientID(0);
                    if (!AddResource(other->resource, RT_INPUTCLIENT,
                                     (void *) pWin))
                        return BadAlloc;
                }
            }
            else {
                wOtherInputMasks(pWin)->inputClients = other->next;
                FreeInputClient(&other);
            }
            RecalculateDeviceDeliverableEvents(pWin);
            return Success;
        }
        prev = other;
    }
    FatalError("client not on device event list");
}

/**
 * Search for window in each touch trace for each device. Remove the window
 * and all its subwindows from the trace when found. The initial window
 * order is preserved.
 */
void
WindowGone(WindowPtr win)
{
    DeviceIntPtr dev;

    for (dev = inputInfo.devices; dev; dev = dev->next) {
        TouchClassPtr t = dev->touch;
        int i;

        if (!t)
            continue;

        for (i = 0; i < t->num_touches; i++) {
            SpritePtr sprite = &t->touches[i].sprite;
            int j;

            for (j = 0; j < sprite->spriteTraceGood; j++) {
                if (sprite->spriteTrace[j] == win) {
                    sprite->spriteTraceGood = j;
                    break;
                }
            }
        }
    }
}

int
SendEvent(ClientPtr client, DeviceIntPtr d, Window dest, Bool propagate,
          xEvent *ev, Mask mask, int count)
{
    WindowPtr pWin;
    WindowPtr effectiveFocus = NullWindow;      /* only set if dest==InputFocus */
    WindowPtr spriteWin = GetSpriteWindow(d);

    if (dest == PointerWindow)
        pWin = spriteWin;
    else if (dest == InputFocus) {
        WindowPtr inputFocus;

        if (!d->focus)
            inputFocus = spriteWin;
        else
            inputFocus = d->focus->win;

        if (inputFocus == FollowKeyboardWin)
            inputFocus = inputInfo.keyboard->focus->win;

        if (inputFocus == NoneWin)
            return Success;

        /* If the input focus is PointerRootWin, send the event to where
         * the pointer is if possible, then perhaps propogate up to root. */
        if (inputFocus == PointerRootWin)
            inputFocus = GetCurrentRootWindow(d);

        if (IsParent(inputFocus, spriteWin)) {
            effectiveFocus = inputFocus;
            pWin = spriteWin;
        }
        else
            effectiveFocus = pWin = inputFocus;
    }
    else
        dixLookupWindow(&pWin, dest, client, DixSendAccess);
    if (!pWin)
        return BadWindow;
    if ((propagate != xFalse) && (propagate != xTrue)) {
        client->errorValue = propagate;
        return BadValue;
    }
    ev->u.u.type |= 0x80;
    if (propagate) {
        for (; pWin; pWin = pWin->parent) {
            if (DeliverEventsToWindow(d, pWin, ev, count, mask, NullGrab))
                return Success;
            if (pWin == effectiveFocus)
                return Success;
            if (wOtherInputMasks(pWin))
                mask &= ~wOtherInputMasks(pWin)->dontPropagateMask[d->id];
            if (!mask)
                break;
        }
    }
    else if (!XaceHook(XACE_SEND_ACCESS, client, NULL, pWin, ev, count))
        DeliverEventsToWindow(d, pWin, ev, count, mask, NullGrab);
    return Success;
}

int
SetButtonMapping(ClientPtr client, DeviceIntPtr dev, int nElts, BYTE * map)
{
    int i;
    ButtonClassPtr b = dev->button;

    if (b == NULL)
        return BadMatch;

    if (nElts != b->numButtons) {
        client->errorValue = nElts;
        return BadValue;
    }
    if (BadDeviceMap(&map[0], nElts, 1, 255, &client->errorValue))
        return BadValue;
    for (i = 0; i < nElts; i++)
        if ((b->map[i + 1] != map[i]) && BitIsOn(b->down, i + 1))
            return MappingBusy;
    for (i = 0; i < nElts; i++)
        b->map[i + 1] = map[i];
    return Success;
}

int
ChangeKeyMapping(ClientPtr client,
                 DeviceIntPtr dev,
                 unsigned len,
                 int type,
                 KeyCode firstKeyCode,
                 CARD8 keyCodes, CARD8 keySymsPerKeyCode, KeySym * map)
{
    KeySymsRec keysyms;
    KeyClassPtr k = dev->key;

    if (k == NULL)
        return BadMatch;

    if (len != (keyCodes * keySymsPerKeyCode))
        return BadLength;

    if ((firstKeyCode < k->xkbInfo->desc->min_key_code) ||
        (firstKeyCode + keyCodes - 1 > k->xkbInfo->desc->max_key_code)) {
        client->errorValue = firstKeyCode;
        return BadValue;
    }
    if (keySymsPerKeyCode == 0) {
        client->errorValue = 0;
        return BadValue;
    }
    keysyms.minKeyCode = firstKeyCode;
    keysyms.maxKeyCode = firstKeyCode + keyCodes - 1;
    keysyms.mapWidth = keySymsPerKeyCode;
    keysyms.map = map;

    XkbApplyMappingChange(dev, &keysyms, firstKeyCode, keyCodes, NULL,
                          serverClient);

    return Success;
}

static void
DeleteDeviceFromAnyExtEvents(WindowPtr pWin, DeviceIntPtr dev)
{
    WindowPtr parent;

    /* Deactivate any grabs performed on this window, before making
     * any input focus changes.
     * Deactivating a device grab should cause focus events. */

    if (dev->deviceGrab.grab && (dev->deviceGrab.grab->window == pWin))
        (*dev->deviceGrab.DeactivateGrab) (dev);

    /* If the focus window is a root window (ie. has no parent)
     * then don't delete the focus from it. */

    if (dev->focus && (pWin == dev->focus->win) && (pWin->parent != NullWindow)) {
        int focusEventMode = NotifyNormal;

        /* If a grab is in progress, then alter the mode of focus events. */

        if (dev->deviceGrab.grab)
            focusEventMode = NotifyWhileGrabbed;

        switch (dev->focus->revert) {
        case RevertToNone:
            if (!ActivateFocusInGrab(dev, pWin, NoneWin))
                DoFocusEvents(dev, pWin, NoneWin, focusEventMode);
            dev->focus->win = NoneWin;
            dev->focus->traceGood = 0;
            break;
        case RevertToParent:
            parent = pWin;
            do {
                parent = parent->parent;
                dev->focus->traceGood--;
            }
            while (!parent->realized);
            if (!ActivateFocusInGrab(dev, pWin, parent))
                DoFocusEvents(dev, pWin, parent, focusEventMode);
            dev->focus->win = parent;
            dev->focus->revert = RevertToNone;
            break;
        case RevertToPointerRoot:
            if (!ActivateFocusInGrab(dev, pWin, PointerRootWin))
                DoFocusEvents(dev, pWin, PointerRootWin, focusEventMode);
            dev->focus->win = PointerRootWin;
            dev->focus->traceGood = 0;
            break;
        case RevertToFollowKeyboard:
        {
            DeviceIntPtr kbd = GetMaster(dev, MASTER_KEYBOARD);

            if (!kbd || (kbd == dev && kbd != inputInfo.keyboard))
                kbd = inputInfo.keyboard;
            if (kbd->focus->win) {
                if (!ActivateFocusInGrab(dev, pWin, kbd->focus->win))
                    DoFocusEvents(dev, pWin, kbd->focus->win, focusEventMode);
                dev->focus->win = FollowKeyboardWin;
                dev->focus->traceGood = 0;
            }
            else {
                if (!ActivateFocusInGrab(dev, pWin, NoneWin))
                    DoFocusEvents(dev, pWin, NoneWin, focusEventMode);
                dev->focus->win = NoneWin;
                dev->focus->traceGood = 0;
            }
        }
            break;
        }
    }

    if (dev->valuator)
        if (dev->valuator->motionHintWindow == pWin)
            dev->valuator->motionHintWindow = NullWindow;
}

void
DeleteWindowFromAnyExtEvents(WindowPtr pWin, Bool freeResources)
{
    int i;
    DeviceIntPtr dev;
    InputClientsPtr ic;
    struct _OtherInputMasks *inputMasks;

    for (dev = inputInfo.devices; dev; dev = dev->next) {
        DeleteDeviceFromAnyExtEvents(pWin, dev);
    }

    for (dev = inputInfo.off_devices; dev; dev = dev->next)
        DeleteDeviceFromAnyExtEvents(pWin, dev);

    if (freeResources)
        while ((inputMasks = wOtherInputMasks(pWin)) != 0) {
            ic = inputMasks->inputClients;
            for (i = 0; i < EMASKSIZE; i++)
                inputMasks->dontPropagateMask[i] = 0;
            FreeResource(ic->resource, RT_NONE);
        }
}

int
MaybeSendDeviceMotionNotifyHint(deviceKeyButtonPointer *pEvents, Mask mask)
{
    DeviceIntPtr dev;

    dixLookupDevice(&dev, pEvents->deviceid & DEVICE_BITS, serverClient,
                    DixReadAccess);
    if (!dev)
        return 0;

    if (pEvents->type == DeviceMotionNotify) {
        if (mask & DevicePointerMotionHintMask) {
            if (WID(dev->valuator->motionHintWindow) == pEvents->event) {
                return 1;       /* don't send, but pretend we did */
            }
            pEvents->detail = NotifyHint;
        }
        else {
            pEvents->detail = NotifyNormal;
        }
    }
    return 0;
}

void
CheckDeviceGrabAndHintWindow(WindowPtr pWin, int type,
                             deviceKeyButtonPointer *xE, GrabPtr grab,
                             ClientPtr client, Mask deliveryMask)
{
    DeviceIntPtr dev;

    dixLookupDevice(&dev, xE->deviceid & DEVICE_BITS, serverClient,
                    DixGrabAccess);
    if (!dev)
        return;

    if (type == DeviceMotionNotify)
        dev->valuator->motionHintWindow = pWin;
    else if ((type == DeviceButtonPress) && (!grab) &&
             (deliveryMask & DeviceButtonGrabMask)) {
        GrabPtr tempGrab;

        tempGrab = AllocGrab(NULL);
        if (!tempGrab)
            return;

        tempGrab->device = dev;
        tempGrab->resource = client->clientAsMask;
        tempGrab->window = pWin;
        tempGrab->ownerEvents =
            (deliveryMask & DeviceOwnerGrabButtonMask) ? TRUE : FALSE;
        tempGrab->eventMask = deliveryMask;
        tempGrab->keyboardMode = GrabModeAsync;
        tempGrab->pointerMode = GrabModeAsync;
        tempGrab->confineTo = NullWindow;
        tempGrab->cursor = NullCursor;
        tempGrab->next = NULL;
        (*dev->deviceGrab.ActivateGrab) (dev, tempGrab, currentTime, TRUE);
        FreeGrab(tempGrab);
    }
}

static Mask
DeviceEventMaskForClient(DeviceIntPtr dev, WindowPtr pWin, ClientPtr client)
{
    InputClientsPtr other;

    if (!wOtherInputMasks(pWin))
        return 0;
    for (other = wOtherInputMasks(pWin)->inputClients; other;
         other = other->next) {
        if (SameClient(other, client))
            return other->mask[dev->id];
    }
    return 0;
}

void
MaybeStopDeviceHint(DeviceIntPtr dev, ClientPtr client)
{
    WindowPtr pWin;
    GrabPtr grab = dev->deviceGrab.grab;

    pWin = dev->valuator->motionHintWindow;

    if ((grab && SameClient(grab, client) &&
         ((grab->eventMask & DevicePointerMotionHintMask) ||
          (grab->ownerEvents &&
           (DeviceEventMaskForClient(dev, pWin, client) &
            DevicePointerMotionHintMask)))) ||
        (!grab &&
         (DeviceEventMaskForClient(dev, pWin, client) &
          DevicePointerMotionHintMask)))
        dev->valuator->motionHintWindow = NullWindow;
}

int
DeviceEventSuppressForWindow(WindowPtr pWin, ClientPtr client, Mask mask,
                             int maskndx)
{
    struct _OtherInputMasks *inputMasks = wOtherInputMasks(pWin);

    if (mask & ~PropagateMask[maskndx]) {
        client->errorValue = mask;
        return BadValue;
    }

    if (mask == 0) {
        if (inputMasks)
            inputMasks->dontPropagateMask[maskndx] = mask;
    }
    else {
        if (!inputMasks)
            AddExtensionClient(pWin, client, 0, 0);
        inputMasks = wOtherInputMasks(pWin);
        inputMasks->dontPropagateMask[maskndx] = mask;
    }
    RecalculateDeviceDeliverableEvents(pWin);
    if (ShouldFreeInputMasks(pWin, FALSE))
        FreeResource(inputMasks->inputClients->resource, RT_NONE);
    return Success;
}

Bool
ShouldFreeInputMasks(WindowPtr pWin, Bool ignoreSelectedEvents)
{
    int i;
    Mask allInputEventMasks = 0;
    struct _OtherInputMasks *inputMasks = wOtherInputMasks(pWin);

    for (i = 0; i < EMASKSIZE; i++)
        allInputEventMasks |= inputMasks->dontPropagateMask[i];
    if (!ignoreSelectedEvents)
        for (i = 0; i < EMASKSIZE; i++)
            allInputEventMasks |= inputMasks->inputEvents[i];
    if (allInputEventMasks == 0)
        return TRUE;
    else
        return FALSE;
}

/***********************************************************************
 *
 * Walk through the window tree, finding all clients that want to know
 * about the Event.
 *
 */

static void
FindInterestedChildren(DeviceIntPtr dev, WindowPtr p1, Mask mask,
                       xEvent *ev, int count)
{
    WindowPtr p2;

    while (p1) {
        p2 = p1->firstChild;
        DeliverEventsToWindow(dev, p1, ev, count, mask, NullGrab);
        FindInterestedChildren(dev, p2, mask, ev, count);
        p1 = p1->nextSib;
    }
}

/***********************************************************************
 *
 * Send an event to interested clients in all windows on all screens.
 *
 */

void
SendEventToAllWindows(DeviceIntPtr dev, Mask mask, xEvent *ev, int count)
{
    int i;
    WindowPtr pWin, p1;

    for (i = 0; i < screenInfo.numScreens; i++) {
        pWin = screenInfo.screens[i]->root;
        if (!pWin)
            continue;
        DeliverEventsToWindow(dev, pWin, ev, count, mask, NullGrab);
        p1 = pWin->firstChild;
        FindInterestedChildren(dev, p1, mask, ev, count);
    }
}

/**
 * Set the XI2 mask for the given client on the given window.
 * @@param dev The device to set the mask for.
 * @@param win The window to set the mask on.
 * @@param client The client setting the mask.
 * @@param len Number of bytes in mask.
 * @@param mask Event mask in the form of (1 << eventtype)
 */
int
XISetEventMask(DeviceIntPtr dev, WindowPtr win, ClientPtr client,
               unsigned int len, unsigned char *mask)
{
    OtherInputMasks *masks;
    InputClientsPtr others = NULL;

    masks = wOtherInputMasks(win);
    if (masks) {
        for (others = wOtherInputMasks(win)->inputClients; others;
             others = others->next) {
            if (SameClient(others, client)) {
                xi2mask_zero(others->xi2mask, dev->id);
                break;
            }
        }
    }

    if (len && !others) {
        if (AddExtensionClient(win, client, 0, 0) != Success)
            return BadAlloc;
        others = wOtherInputMasks(win)->inputClients;
    }

    if (others) {
        xi2mask_zero(others->xi2mask, dev->id);
        len = min(len, xi2mask_mask_size(others->xi2mask));
    }

    if (len) {
        xi2mask_set_one_mask(others->xi2mask, dev->id, mask, len);
    }

    RecalculateDeviceDeliverableEvents(win);

    return Success;
}
@


1.20
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@d1382 3
@


1.19
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d474 3
a476 3
            to->focus->trace = realloc(oldTrace,
                                       to->focus->traceSize *
                                       sizeof(WindowPtr));
d1593 1
a1593 1
        return;
d1627 1
@


1.18
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d1733 12
@


1.17
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1406 1
a1406 1
                WindowPtr sprite_win = dev->spriteInfo->sprite->win;
d1432 1
d1434 1
a1434 1
        DeliverDeviceEvents(win, ptrev, grab, win, dev);
@


1.16
log
@Update to xorg-server 1.15.2. bug fixes.
@
text
@d233 1
a233 1
    if (!XkbCopyDeviceKeymap(master, device))
d1309 1
a1309 1
        rc = dixLookupResourceByType((pointer *) win, listener->listener,
d1476 1
a1476 1
    InternalEvent motion;
d1488 3
a1490 3
        motion = *ev;
        motion.any.type = ET_TouchUpdate;
        motion.device_event.detail.button = 0;
d1492 1
a1492 1
        if (!RetrieveTouchDeliveryData(dev, ti, &motion,
d1507 1
a1507 1
        DeliverTouchEmulatedEvent(dev, ti, &motion, &ti->listeners[0], client,
d1514 1
a1514 1
        converted = TouchConvertToPointerEvent(ev, &motion, &button);
d1518 1
a1518 1
            ProcessOtherEvent(&motion, dev);
d1742 1
a1742 1
        CallCallbacks(&DeviceEventCallback, (pointer) &eventinfo);
d2229 1
a2229 1
        rc = dixLookupResourceByType((pointer *) &cursor, param->cursor,
d2328 1
a2328 1
        rc = dixLookupResourceByType((pointer *) &cursor, param->cursor,
d2471 1
a2471 1
    if (!AddResource(others->resource, RT_INPUTCLIENT, (pointer) pWin))
d2573 1
a2573 1
                                     (pointer) pWin))
@


1.15
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d664 2
d673 2
@


1.14
log
@Update to xserver 1.14.3
@
text
@d1416 2
a1417 1
            if (deliveries && ev->any.type == ET_TouchEnd &&
d1480 1
a1480 1
        if (ti->listeners[0].type != LISTENER_POINTER_REGULAR ||
d1786 1
a1786 1
    if (deactivateDeviceGrab == TRUE)
d1788 17
d1866 2
a1867 1
            if (dev->deviceGrab.grab &&
d1936 3
a1938 1
    if (ev->device_event.flags & TOUCH_REJECT) {
a1960 6
    else if (ev->device_event.flags & TOUCH_ACCEPT) {
        /* Touch has been accepted by its owner, which is not this listener */
        if (listener->state != LISTENER_HAS_END)
            rc = DeliverOneTouchEvent(client, dev, ti, grab, win, ev);
        listener->state = LISTENER_HAS_END;
    }
d2052 3
d2080 4
a2083 4
    if (!dev || !dev->valuator || (minval > maxval && mode == Absolute))
        return FALSE;
    if (axnum >= dev->valuator->numAxes)
        return FALSE;
d2113 3
a2115 2
    if (!dev || !dev->valuator || axnum >= dev->valuator->numAxes)
        return FALSE;
d2186 2
a2187 1
    if (param->grabtype != XI2 && (param->modifiers != AnyModifier) &&
d2256 1
a2256 2
 * Grab the given key. If grabtype is XI, the key is a keycode. If
 * grabtype is XI2, the key is a keysym.
@


1.13
log
@Uodate to xserver 1.14.2. Tested by krw@@, shadchin@@, todd@@
@
text
@a1038 1
    int rc;
d1041 5
d1047 1
a1047 6
    rc = dixLookupClient(&client, ti->listeners[0].listener, serverClient,
                         DixSendAccess);
    if (rc != Success) {
        ErrorF("[Xi] Failed to lookup early accepting client.\n");
        return;
    }
d1050 1
a1050 2
                          ti->listeners[0].window->drawable.id, &error) !=
        Success)
a1054 23
 * Generate and deliver a TouchEnd event.
 *
 * @@param dev The device to deliver the event for.
 * @@param ti The touch point record to deliver the event for.
 * @@param flags Internal event flags. The called does not need to provide
 *        TOUCH_CLIENT_ID and TOUCH_POINTER_EMULATED, this function will ensure
 *        they are set appropriately.
 * @@param resource The client resource to deliver to, or 0 for all clients.
 */
static void
EmitTouchEnd(DeviceIntPtr dev, TouchPointInfoPtr ti, int flags, XID resource)
{
    InternalEvent event;

    flags |= TOUCH_CLIENT_ID;
    if (ti->emulate_pointer)
        flags |= TOUCH_POINTER_EMULATED;
    TouchDeliverDeviceClassesChangedEvent(ti, GetTimeInMillis(), resource);
    GetDixTouchEnd(&event, dev, ti, flags);
    DeliverTouchEvents(dev, ti, &event, resource);
}

/**
d1104 3
d1108 1
a1108 2
    if (ti->listeners[0].state == LISTENER_AWAITING_OWNER ||
        ti->listeners[0].state == LISTENER_EARLY_ACCEPT)
d1110 2
a1111 2
                           ti->listeners[0].listener);
    else if (ti->listeners[0].state == LISTENER_AWAITING_BEGIN) {
d1114 2
a1115 2
        if ((ti->listeners[0].type == LISTENER_POINTER_GRAB ||
             ti->listeners[0].type == LISTENER_POINTER_REGULAR) &&
d1119 1
a1119 1
        TouchEventHistoryReplay(ti, dev, ti->listeners[0].listener);
d1122 15
a1136 6
    /* If we've just removed the last grab and the touch has physically
     * ended, send a TouchEnd event too and finalise the touch. */
    if (ti->num_listeners == 1 && ti->num_grabs == 0 && ti->pending_finish) {
        EmitTouchEnd(dev, ti, 0, 0);
        TouchEndTouch(dev, ti);
        return;
d1139 1
a1139 1
    if (ti->listeners[0].state == LISTENER_EARLY_ACCEPT)
d1183 1
a1183 1
                EmitTouchEnd(sourcedev, ti, TOUCH_REJECT, resource);
d1226 4
a1229 1
        /* Go through the motions of ending the touch if the listener has
d1231 2
a1232 1
         * the server. */
d1234 1
a1234 1
            EmitTouchEnd(dev, ti, TOUCH_ACCEPT, ti->listeners[0].listener);
d1239 1
a1239 1
            EmitTouchEnd(dev, ti, TOUCH_ACCEPT, ti->listeners[i].listener);
d1376 1
a1376 1
        return Success;
d1398 1
a1398 1
                return Success;
d1408 1
a1408 1
                DeliverOneGrabbedEvent(ptrev, dev, grab->grabtype);
d1416 1
a1416 2
            if (ev->any.type == ET_TouchEnd &&
                !(ev->device_event.flags & TOUCH_CLIENT_ID) &&
d1435 1
d1438 2
d1448 2
a1449 2
            l->listener = devgrab->resource;
            l->grab = devgrab;
d1540 1
a1540 1
    if (type == ET_TouchBegin) {
d1607 3
a1609 1
    if ((type == ET_TouchBegin && !TouchBuildSprite(dev, ti, ev)) ||
d1617 1
a1617 1
    DeliverTouchEvents(dev, ti, (InternalEvent *) ev, 0);
d1845 8
d1870 1
a1870 1
        if (!has_ownershipmask || listener->type == LISTENER_REGULAR)
d1890 16
a1905 8
        rc = DeliverTouchEmulatedEvent(dev, ti, ev, listener, client, win,
                                       grab, xi2mask);

        if (ti->num_listeners > 1) {
            ev->any.type = ET_TouchUpdate;
            ev->device_event.flags |= TOUCH_PENDING_END;
            if (!(ev->device_event.flags & TOUCH_CLIENT_ID))
                ti->pending_finish = TRUE;
a1906 1

d1930 1
a1930 1
             listener->state != LISTENER_HAS_ACCEPTED) &&
d2861 1
a2861 1
        tempGrab = AllocGrab();
@


1.12
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d1224 2
a1225 2
ProcessTouchOwnershipEvent(DeviceIntPtr dev, TouchPointInfoPtr ti,
                           TouchOwnershipEvent *ev)
d1227 7
d1546 1
a1546 4
    if (ev->any.type == ET_TouchOwnership)
        touchid = ev->touch_ownership_event.touchid;
    else
        touchid = ev->device_event.touchid;
d1619 7
a1625 13
    /* TouchOwnership events are handled separately from the rest, as they
     * have more complex semantics. */
    if (ev->any.type == ET_TouchOwnership)
        ProcessTouchOwnershipEvent(dev, ti, &ev->touch_ownership_event);
    else {
        TouchCopyValuatorData(&ev->device_event, ti);
        /* WARNING: the event type may change to TouchUpdate in
         * DeliverTouchEvents if a TouchEnd was delivered to a grabbing
         * owner */
        DeliverTouchEvents(dev, ti, (InternalEvent *) ev, 0);
        if (ev->any.type == ET_TouchEnd)
            TouchEndTouch(dev, ti);
    }
a1818 1
    case ET_TouchOwnership:
d1821 5
@


1.11
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a271 2
        ClassesPtr classes;

a301 2
        ClassesPtr classes;

a332 2
        ClassesPtr classes;

a365 2
        ClassesPtr classes;

a411 2
        ClassesPtr classes;

a429 2
        ClassesPtr classes;

a484 2
        ClassesPtr classes;

a524 2
        ClassesPtr classes;

a550 2
        ClassesPtr classes;

a585 2
        ClassesPtr classes;

a606 2
        ClassesPtr classes;

d929 2
a930 2
        BUG_WARN(!b || !v);
        BUG_WARN(!t);
d932 1
a932 1
        if (!b || !t || !b->map[key])
d944 2
a945 2
        BUG_WARN(!b || !v);
        BUG_WARN(!t);
d947 1
a947 1
        if (!b || !t || t->buttonsDown <= 0 || !b->map[key])
a951 2
        if (!(event->flags & TOUCH_END))
            return DONT_PROCESS;
d1069 1
a1069 8
    InternalEvent *tel = InitEventList(GetMaximumEventsNum());
    ValuatorMask *mask = valuator_mask_new(2);
    int i, nev;

    valuator_mask_set_double(mask, 0,
                             valuator_mask_get_double(ti->valuators, 0));
    valuator_mask_set_double(mask, 1,
                             valuator_mask_get_double(ti->valuators, 1));
d1074 3
a1076 6
    nev = GetTouchEvents(tel, dev, ti->client_id, XI_TouchEnd, flags, mask);
    for (i = 0; i < nev; i++)
        DeliverTouchEvents(dev, ti, tel + i, resource);

    valuator_mask_free(&mask);
    FreeEventList(tel, GetMaximumEventsNum());
a1189 1
    void *grab;
d1204 1
a1204 5
    if (TouchRemoveListener(ti, resource)) {
        if (dixLookupResourceByType(&grab, resource, RT_PASSIVEGRAB,
                                    serverClient, DixGetAttrAccess) == Success)
            ti->num_grabs--;
    }
d1252 1
a1252 1
    else {                      /* this is the very first ownership event for a grab */
d1266 1
a1266 1
    for (i = 0; i < sizeof(ev->valuators.mask) * 8; i++)
d1298 4
a1301 15
        rc = dixLookupResourceByType((pointer *) grab, listener->listener,
                                     RT_PASSIVEGRAB,
                                     serverClient, DixSendAccess);
        if (rc != Success) {
            /* the grab doesn't exist but we have a grabbing listener - this
             * is an implicit/active grab */
            rc = dixLookupClient(client, listener->listener, serverClient,
                                 DixSendAccess);
            if (rc != Success)
                return FALSE;

            *grab = dev->deviceGrab.grab;
            if (!*grab)
                return FALSE;
        }
d1308 3
a1310 7
        if (listener->level == CORE)
            rc = dixLookupWindow(win, listener->listener,
                                 serverClient, DixSendAccess);
        else
            rc = dixLookupResourceByType((pointer *) win, listener->listener,
                                         RT_INPUTCLIENT,
                                         serverClient, DixSendAccess);
d1327 2
a1328 3
            BUG_WARN(!iclients);
            if (!iclients)
                return FALSE;
d1341 1
a1341 3
            BUG_WARN(!iclients);
            if (!iclients)
                return FALSE;
d1382 1
a1382 3
    BUG_WARN(nevents == 0);
    if (nevents == 0)
        return BadValue;
d1392 1
a1392 1
        /* this side-steps the usual activation mechansims, but... */
d1405 1
a1405 1
                WindowPtr win = dev->spriteInfo->sprite->win;
d1407 1
a1407 1
                deliveries = DeliverDeviceEvents(win, ptrev, grab, focus, dev);
d1438 1
a1438 1
            TouchListener *listener;
d1448 4
a1451 2
            listener = &ti->listeners[ti->num_listeners - 1];
            listener->listener = devgrab->resource;
d1454 1
a1454 1
                listener->type = LISTENER_POINTER_GRAB;
d1456 1
a1456 1
                listener->type = LISTENER_GRAB;
d1534 1
a1543 3
    if (emulate_pointer)
        UpdateDeviceState(dev, &ev->device_event);

d1551 2
a1552 12
    /* Under the following circumstances we create a new touch record for an
     * existing touch:
     *
     * - The touch may be pointer emulated
     * - An explicit grab is active on the device
     * - The grab is a pointer grab
     *
     * This allows for an explicit grab to receive pointer events for an already
     * active touch.
     */
    if (!ti && type != ET_TouchBegin && emulate_pointer &&
        dev->deviceGrab.grab && !dev->deviceGrab.fromPassiveGrab &&
d1555 30
a1584 8
         !xi2mask_isset(dev->deviceGrab.grab->xi2mask, dev, XI_TouchBegin))) {
        ti = TouchBeginTouch(dev, ev->device_event.sourceid, touchid,
                             emulate_pointer);
        if (!ti) {
            DebugF("[Xi] %s: Failed to create new dix record for explicitly "
                   "grabbed touchpoint %d\n",
                   dev->name, type, touchid);
            return;
a1585 3

        TouchBuildSprite(dev, ti, ev);
        TouchSetupListeners(dev, ti, ev);
d1599 1
d1603 4
d1628 46
d1727 1
a1727 1
        NoticeEventTime((InternalEvent *) event);
d1825 4
d1899 6
d1929 6
a2133 234
static void
FixDeviceStateNotify(DeviceIntPtr dev, deviceStateNotify * ev, KeyClassPtr k,
                     ButtonClassPtr b, ValuatorClassPtr v, int first)
{
    ev->type = DeviceStateNotify;
    ev->deviceid = dev->id;
    ev->time = currentTime.milliseconds;
    ev->classes_reported = 0;
    ev->num_keys = 0;
    ev->num_buttons = 0;
    ev->num_valuators = 0;

    if (b) {
        ev->classes_reported |= (1 << ButtonClass);
        ev->num_buttons = b->numButtons;
        memcpy((char *) ev->buttons, (char *) b->down, 4);
    }
    else if (k) {
        ev->classes_reported |= (1 << KeyClass);
        ev->num_keys = k->xkbInfo->desc->max_key_code -
            k->xkbInfo->desc->min_key_code;
        memmove((char *) &ev->keys[0], (char *) k->down, 4);
    }
    if (v) {
        int nval = v->numAxes - first;

        ev->classes_reported |= (1 << ValuatorClass);
        ev->classes_reported |= valuator_get_mode(dev, 0) << ModeBitsShift;
        ev->num_valuators = nval < 3 ? nval : 3;
        switch (ev->num_valuators) {
        case 3:
            ev->valuator2 = v->axisVal[first + 2];
        case 2:
            ev->valuator1 = v->axisVal[first + 1];
        case 1:
            ev->valuator0 = v->axisVal[first];
            break;
        }
    }
}

static void
FixDeviceValuator(DeviceIntPtr dev, deviceValuator * ev, ValuatorClassPtr v,
                  int first)
{
    int nval = v->numAxes - first;

    ev->type = DeviceValuator;
    ev->deviceid = dev->id;
    ev->num_valuators = nval < 3 ? nval : 3;
    ev->first_valuator = first;
    switch (ev->num_valuators) {
    case 3:
        ev->valuator2 = v->axisVal[first + 2];
    case 2:
        ev->valuator1 = v->axisVal[first + 1];
    case 1:
        ev->valuator0 = v->axisVal[first];
        break;
    }
    first += ev->num_valuators;
}

static void
DeliverStateNotifyEvent(DeviceIntPtr dev, WindowPtr win)
{
    int evcount = 1;
    deviceStateNotify *ev, *sev;
    deviceKeyStateNotify *kev;
    deviceButtonStateNotify *bev;

    KeyClassPtr k;
    ButtonClassPtr b;
    ValuatorClassPtr v;
    int nval = 0, nkeys = 0, nbuttons = 0, first = 0;

    if (!(wOtherInputMasks(win)) ||
        !(wOtherInputMasks(win)->inputEvents[dev->id] & DeviceStateNotifyMask))
        return;

    if ((b = dev->button) != NULL) {
        nbuttons = b->numButtons;
        if (nbuttons > 32)
            evcount++;
    }
    if ((k = dev->key) != NULL) {
        nkeys = k->xkbInfo->desc->max_key_code - k->xkbInfo->desc->min_key_code;
        if (nkeys > 32)
            evcount++;
        if (nbuttons > 0) {
            evcount++;
        }
    }
    if ((v = dev->valuator) != NULL) {
        nval = v->numAxes;

        if (nval > 3)
            evcount++;
        if (nval > 6) {
            if (!(k && b))
                evcount++;
            if (nval > 9)
                evcount += ((nval - 7) / 3);
        }
    }

    sev = ev = (deviceStateNotify *) malloc(evcount * sizeof(xEvent));
    FixDeviceStateNotify(dev, ev, NULL, NULL, NULL, first);

    if (b != NULL) {
        FixDeviceStateNotify(dev, ev++, NULL, b, v, first);
        first += 3;
        nval -= 3;
        if (nbuttons > 32) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            bev = (deviceButtonStateNotify *) ev++;
            bev->type = DeviceButtonStateNotify;
            bev->deviceid = dev->id;
            memcpy((char *) &bev->buttons[4], (char *) &b->down[4],
                   DOWN_LENGTH - 4);
        }
        if (nval > 0) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
            first += 3;
            nval -= 3;
        }
    }

    if (k != NULL) {
        FixDeviceStateNotify(dev, ev++, k, NULL, v, first);
        first += 3;
        nval -= 3;
        if (nkeys > 32) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            kev = (deviceKeyStateNotify *) ev++;
            kev->type = DeviceKeyStateNotify;
            kev->deviceid = dev->id;
            memmove((char *) &kev->keys[0], (char *) &k->down[4], 28);
        }
        if (nval > 0) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
            first += 3;
            nval -= 3;
        }
    }

    while (nval > 0) {
        FixDeviceStateNotify(dev, ev++, NULL, NULL, v, first);
        first += 3;
        nval -= 3;
        if (nval > 0) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
            first += 3;
            nval -= 3;
        }
    }

    DeliverEventsToWindow(dev, win, (xEvent *) sev, evcount,
                          DeviceStateNotifyMask, NullGrab);
    free(sev);
}

void
DeviceFocusEvent(DeviceIntPtr dev, int type, int mode, int detail,
                 WindowPtr pWin)
{
    deviceFocus event;
    xXIFocusInEvent *xi2event;
    DeviceIntPtr mouse;
    int btlen, len, i;

    mouse = IsFloating(dev) ? dev : GetMaster(dev, MASTER_POINTER);

    /* XI 2 event */
    btlen = (mouse->button) ? bits_to_bytes(mouse->button->numButtons) : 0;
    btlen = bytes_to_int32(btlen);
    len = sizeof(xXIFocusInEvent) + btlen * 4;

    xi2event = calloc(1, len);
    xi2event->type = GenericEvent;
    xi2event->extension = IReqCode;
    xi2event->evtype = type;
    xi2event->length = bytes_to_int32(len - sizeof(xEvent));
    xi2event->buttons_len = btlen;
    xi2event->detail = detail;
    xi2event->time = currentTime.milliseconds;
    xi2event->deviceid = dev->id;
    xi2event->sourceid = dev->id;       /* a device doesn't change focus by itself */
    xi2event->mode = mode;
    xi2event->root_x = FP1616(mouse->spriteInfo->sprite->hot.x, 0);
    xi2event->root_y = FP1616(mouse->spriteInfo->sprite->hot.y, 0);

    for (i = 0; mouse && mouse->button && i < mouse->button->numButtons; i++)
        if (BitIsOn(mouse->button->down, i))
            SetBit(&xi2event[1], mouse->button->map[i]);

    if (dev->key) {
        xi2event->mods.base_mods = dev->key->xkbInfo->state.base_mods;
        xi2event->mods.latched_mods = dev->key->xkbInfo->state.latched_mods;
        xi2event->mods.locked_mods = dev->key->xkbInfo->state.locked_mods;
        xi2event->mods.effective_mods = dev->key->xkbInfo->state.mods;

        xi2event->group.base_group = dev->key->xkbInfo->state.base_group;
        xi2event->group.latched_group = dev->key->xkbInfo->state.latched_group;
        xi2event->group.locked_group = dev->key->xkbInfo->state.locked_group;
        xi2event->group.effective_group = dev->key->xkbInfo->state.group;
    }

    FixUpEventFromWindow(dev->spriteInfo->sprite, (xEvent *) xi2event, pWin,
                         None, FALSE);

    DeliverEventsToWindow(dev, pWin, (xEvent *) xi2event, 1,
                          GetEventFilter(dev, (xEvent *) xi2event), NullGrab);

    free(xi2event);

    /* XI 1.x event */
    event.deviceid = dev->id;
    event.mode = mode;
    event.type = (type == XI_FocusIn) ? DeviceFocusIn : DeviceFocusOut;
    event.detail = detail;
    event.window = pWin->drawable.id;
    event.time = currentTime.milliseconds;

    DeliverEventsToWindow(dev, pWin, (xEvent *) &event, 1,
                          DeviceFocusChangeMask, NullGrab);

    if (event.type == DeviceFocusIn)
        DeliverStateNotifyEvent(dev, pWin);
}

d2359 5
a2363 6
        if (check & wOtherInputMasks(pWin)->inputEvents[mskidx]) {      /* It is illegal for two different
                                                                         * clients to select on any of the
                                                                         * events for maskcheck. However,
                                                                         * it is OK, for some client to
                                                                         * continue selecting on one of those
                                                                         * events.  */
@


1.10
log
@Update to xserver 1.11.4. tested by krw@@, shadchin@@.
@
text
@d47 26
d98 2
a99 2
#include "dixevents.h"	/* DeliverFocusedEvent */
#include "dixgrabs.h"	/* CreateGrab() */
d101 1
a101 1
#include "listdev.h" /* for CopySwapXXXClass */
d103 1
a103 1
#include "xiquerydevice.h" /* For List*Info */
d107 1
d120 1
a120 1
				 Bool	/* ignoreSelectedEvents */
d122 1
a122 1
static Bool MakeInputMasks(WindowPtr	/* pWin */
d134 1
a134 1
    DeviceIntPtr current_kbd = GetPairedDevice(current_ptr);
d143 16
a158 1
IsPointerEvent(InternalEvent* event)
d160 7
a166 9
    switch(event->any.type)
    {
        case ET_ButtonPress:
        case ET_ButtonRelease:
        case ET_Motion:
            /* XXX: enter/leave ?? */
            return TRUE;
        default:
            break;
d176 1
a176 1
XIGetDevice(xEvent* xE)
d184 1
a184 3
        xE->u.u.type == ProximityOut ||
        xE->u.u.type == DevicePropertyNotify)
    {
d188 1
a188 1
        id = ((deviceKeyButtonPointer*)xE)->deviceid & ~MORE_EVENTS;
a196 1

a232 1

d247 1
a247 3

    if (from->intfeed)
    {
d250 1
a250 2
        if (!to->intfeed)
        {
d257 2
a258 4
        for (it = from->intfeed; it; it = it->next)
        {
            if (!(*i))
            {
d260 1
a260 2
                if (!(*i))
                {
d266 1
a266 1
            (*i)->ctrl     = it->ctrl;
d270 2
a271 2
    } else if (to->intfeed && !from->intfeed)
    {
d273 1
d276 1
a276 1
        to->intfeed      = NULL;
d279 1
a279 2
    if (from->stringfeed)
    {
d282 1
a282 2
        if (!to->stringfeed)
        {
d289 2
a290 4
        for (it = from->stringfeed; it; it = it->next)
        {
            if (!(*s))
            {
d292 1
a292 2
                if (!(*s))
                {
d298 1
a298 1
            (*s)->ctrl     = it->ctrl;
d302 2
a303 2
    } else if (to->stringfeed && !from->stringfeed)
    {
d305 1
d308 1
a308 1
        to->stringfeed      = NULL;
d311 1
a311 2
    if (from->bell)
    {
d314 1
a314 2
        if (!to->bell)
        {
d321 2
a322 4
        for (it = from->bell; it; it = it->next)
        {
            if (!(*b))
            {
d324 1
a324 2
                if (!(*b))
                {
d331 1
a331 1
            (*b)->ctrl     = it->ctrl;
d335 2
a336 2
    } else if (to->bell && !from->bell)
    {
d338 1
d341 1
a341 1
        to->bell      = NULL;
d344 1
a344 2
    if (from->leds)
    {
d347 1
a347 2
        if (!to->leds)
        {
d354 2
a355 4
        for (it = from->leds; it; it = it->next)
        {
            if (!(*l))
            {
d357 1
a357 2
                if (!(*l))
                {
d363 1
a363 1
            (*l)->ctrl     = it->ctrl;
d370 2
a371 2
    } else if (to->leds && !from->leds)
    {
d373 1
d376 1
a376 1
        to->leds      = NULL;
d388 1
a388 2
    if (from->kbdfeed)
    {
d391 1
a391 2
        if (!to->kbdfeed)
        {
d401 2
a402 4
        for(it = from->kbdfeed; it; it = it->next)
        {
            if (!(*k))
            {
d404 1
a404 2
                if (!*k)
                {
d411 1
a411 1
            (*k)->ctrl     = it->ctrl;
d418 2
a419 2
    } else if (to->kbdfeed && !from->kbdfeed)
    {
d421 1
d424 1
a424 1
        to->kbdfeed      = NULL;
d427 2
a428 4
    if (from->key)
    {
        if (!to->key)
        {
d438 2
a439 2
    } else if (to->key && !from->key)
    {
d441 1
d444 1
a444 1
        to->key      = NULL;
d451 1
a451 2
    if (to->kbdfeed)
    {
d454 1
a454 2
        for (k = to->kbdfeed; k; k = k->next)
        {
d457 1
a457 2
            if (k->xkb_sli->flags & XkbSLI_IsDefault)
            {
d470 2
a471 4
    if (from->focus)
    {
        if (!to->focus)
        {
d476 1
a476 2
            if (!to->focus)
            {
d480 2
a481 1
            } else
d487 2
a488 1
                                  to->focus->traceSize * sizeof(WindowPtr));
d492 1
a492 1
                    from->focus->traceSize * sizeof(WindowPtr));
d495 2
a496 2
    } else if (to->focus)
    {
d498 1
d501 1
a501 1
        to->focus      = NULL;
d506 2
d514 1
a514 2
    if (from->ptrfeed)
    {
d516 2
a517 2
        if (!to->ptrfeed)
        {
d524 2
a525 4
        for (it = from->ptrfeed; it; it = it->next)
        {
            if (!(*p))
            {
d527 1
a527 2
                if (!*p)
                {
d533 1
a533 1
            (*p)->ctrl     = it->ctrl;
d537 2
a538 2
    } else if (to->ptrfeed && !from->ptrfeed)
    {
d540 1
d543 1
a543 1
        to->ptrfeed      = NULL;
d546 1
a546 2
    if (from->valuator)
    {
d549 1
a549 2
        if (!to->valuator)
        {
d565 2
a566 2
    } else if (to->valuator && !from->valuator)
    {
d568 1
d571 1
a571 1
        to->valuator      = NULL;
d574 2
a575 4
    if (from->button)
    {
        if (!to->button)
        {
d578 1
a578 2
            if (!to->button)
            {
d582 2
a583 1
            } else
d587 2
a588 4
        if (from->button->xkb_acts)
        {
            if (!to->button->xkb_acts)
            {
d594 3
a596 2
                    sizeof(XkbAction));
        } else
d599 2
a600 2
         memcpy(to->button->labels, from->button->labels,
                from->button->numButtons * sizeof(Atom));
d602 2
a603 2
    } else if (to->button && !from->button)
    {
d605 1
d608 1
a608 1
        to->button      = NULL;
d611 2
a612 4
    if (from->proximity)
    {
        if (!to->proximity)
        {
d615 1
a615 2
            if (!to->proximity)
            {
d619 2
a620 1
            } else
d625 2
a626 2
    } else if (to->proximity)
    {
d628 1
d631 1
a631 1
        to->proximity      = NULL;
d633 39
d683 2
a684 1
DeepCopyDeviceClasses(DeviceIntPtr from, DeviceIntPtr to, DeviceChangedEvent *dce)
a694 1

d699 1
a699 1
XISendDeviceChangedEvent(DeviceIntPtr device, DeviceIntPtr master, DeviceChangedEvent *dce)
d704 2
a705 3
    rc = EventToXI2((InternalEvent*)dce, (xEvent**)&dcce);
    if (rc != Success)
    {
d712 1
a712 1
    SendEventToAllWindows(master, XI_DeviceChangedMask, (xEvent*)dcce, 1);
d729 1
a729 1
        return; /* Device has disappeared */
d735 1
a735 1
        return; /* set floating since the event */
d738 1
a738 1
        return; /* not our slave anymore, don't care */
d746 51
a796 1
    XISendDeviceChangedEvent(slave, device, dce);
d809 1
a809 1
UpdateDeviceState(DeviceIntPtr device, DeviceEvent* event)
d812 6
a817 7
    int key = 0,
        bit = 0,
        last_valuator;

    KeyClassPtr k       = NULL;
    ButtonClassPtr b    = NULL;
    ValuatorClassPtr v  = NULL;
d823 18
a840 16
    switch(event->type)
    {
        case ET_DeviceChanged:
            ChangeMasterDeviceClasses(device, (DeviceChangedEvent*)event);
            return DONT_PROCESS; /* event has been sent already */
        case ET_Motion:
        case ET_ButtonPress:
        case ET_ButtonRelease:
        case ET_KeyPress:
        case ET_KeyRelease:
        case ET_ProximityIn:
        case ET_ProximityOut:
            break;
        default:
            /* other events don't update the device */
            return DEFAULT;
d846 1
a848 1
    bit = 1 << (key & 7);
d853 3
a855 6
    for (i = 0; i < MAX_VALUATORS; i++)
    {
        if (BitIsOn(&event->valuators.mask, i))
        {
            if (!v)
            {
d857 1
a857 1
                        "Ignoring event.\n", device->name);
d859 2
a860 2
            } else if (v->numAxes < i)
            {
d862 1
a862 1
                        "Ignoring event.\n", device->name);
d869 2
a870 2
    for (i = 0; i <= last_valuator && i < v->numAxes; i++)
    {
a871 2
        {
            /* XXX: Relative/Absolute mode */
a872 2
            v->axisVal[i] += (event->valuators.data_frac[i] * 1.0f / (1 << 16) / (1 << 16));
        }
d879 9
a887 8
	/* don't allow ddx to generate multiple downs, but repeats are okay */
	if (key_is_down(device, key, KEY_PROCESSED) && !event->key_repeat)
	    return DONT_PROCESS;

	if (device->valuator)
	    device->valuator->motionHintWindow = NullWindow;
	set_key_down(device, key, KEY_PROCESSED);
    } else if (event->type == ET_KeyRelease) {
d891 7
a897 7
	if (!key_is_down(device, key, KEY_PROCESSED))	/* guard against duplicates */
	    return DONT_PROCESS;
	if (device->valuator)
	    device->valuator->motionHintWindow = NullWindow;
	set_key_up(device, key, KEY_PROCESSED);
    } else if (event->type == ET_ButtonPress) {
        Mask mask;
d905 1
a905 2
	if (device->valuator)
	    device->valuator->motionHintWindow = NullWindow;
d908 6
a913 12
        b->buttonsDown++;
	b->motionMask = DeviceButtonMotionMask;
        if (b->map[key] <= 5)
	    b->state |= (Button1Mask >> 1) << b->map[key];

        /* Add state and motionMask to the filter for this event */
        mask = DevicePointerMotionMask | b->state | b->motionMask;
        SetMaskForEvent(device->id, mask, DeviceMotionNotify);
        mask = PointerMotionMask | b->state | b->motionMask;
        SetMaskForEvent(device->id, mask, MotionNotify);
    } else if (event->type == ET_ButtonRelease) {
        Mask mask;
d919 724
a1642 2
        if (IsMaster(device)) {
            DeviceIntPtr sd;
d1644 15
a1658 35
            /*
             * Leave the button down if any slave has the
             * button still down. Note that this depends on the
             * event being delivered through the slave first
             */
            for (sd = inputInfo.devices; sd; sd = sd->next) {
                if (IsMaster(sd) || GetMaster(sd, MASTER_POINTER) != device)
                    continue;
                if (!sd->button)
                    continue;
                for (i = 1; i <= sd->button->numButtons; i++)
                    if (sd->button->map[i] == key &&
                        button_is_down(sd, i, BUTTON_PROCESSED))
                        return DONT_PROCESS;
            }
        }
        set_button_up(device, key, BUTTON_PROCESSED);
	if (device->valuator)
	    device->valuator->motionHintWindow = NullWindow;
        if (!b->map[key])
            return DONT_PROCESS;
        if (b->buttonsDown >= 1 && !--b->buttonsDown)
	    b->motionMask = 0;
	if (b->map[key] <= 5)
	    b->state &= ~((Button1Mask >> 1) << b->map[key]);

        /* Add state and motionMask to the filter for this event */
        mask = DevicePointerMotionMask | b->state | b->motionMask;
        SetMaskForEvent(device->id, mask, DeviceMotionNotify);
        mask = PointerMotionMask | b->state | b->motionMask;
        SetMaskForEvent(device->id, mask, MotionNotify);
    } else if (event->type == ET_ProximityIn)
	device->proximity->in_proximity = TRUE;
    else if (event->type == ET_ProximityOut)
	device->proximity->in_proximity = FALSE;
d1660 13
a1672 1
    return DEFAULT;
d1676 1
a1676 3
 * Main device event processing function.
 * Called from when processing the events from the event queue.
 *
d1678 2
a1679 2
void
ProcessOtherEvent(InternalEvent *ev, DeviceIntPtr device)
a1684 2
    KeyClassPtr k;
    ValuatorClassPtr v;
d1686 1
a1686 1
    int state, i;
d1690 2
a1691 15
    verify_internal_event(ev);

    if (ev->any.type == ET_RawKeyPress ||
        ev->any.type == ET_RawKeyRelease ||
        ev->any.type == ET_RawButtonPress ||
        ev->any.type == ET_RawButtonRelease ||
        ev->any.type == ET_RawMotion)
    {
        DeliverRawEvent(&ev->raw_event, device);
        return;
    }

    if (IsPointerDevice(device))
    {
        kbd = GetPairedDevice(device);
d1693 1
a1693 1
        if (!kbd->key) /* can happen with floating SDs */
d1695 3
a1697 3
    } else
    {
        mouse = GetPairedDevice(device);
d1703 2
a1704 27
    /* State needs to be assembled BEFORE the device is updated. */
    state = (kbd && kbd->key) ? XkbStateFieldFromRec(&kbd->key->xkbInfo->state) : 0;
    state |= (mouse && mouse->button) ? (mouse->button->state) : 0;

    for (i = 0; mouse && mouse->button && i < mouse->button->numButtons; i++)
        if (BitIsOn(mouse->button->down, i))
            SetBit(event->buttons, mouse->button->map[i]);

    if (kbd && kbd->key)
    {
        XkbStatePtr state;
        /* we need the state before the event happens */
        if (event->type == ET_KeyPress || event->type == ET_KeyRelease)
            state = &kbd->key->xkbInfo->prev_state;
        else
            state = &kbd->key->xkbInfo->state;

        event->mods.base = state->base_mods;
        event->mods.latched = state->latched_mods;
        event->mods.locked = state->locked_mods;
        event->mods.effective = state->mods;

        event->group.base = state->base_group;
        event->group.latched = state->latched_group;
        event->group.locked = state->locked_group;
        event->group.effective = state->group;
    }
a1709 1
    v = device->valuator;
a1710 1
    k = device->key;
d1715 17
a1731 18
    switch (event->type)
    {
        case ET_Motion:
        case ET_ButtonPress:
        case ET_ButtonRelease:
        case ET_KeyPress:
        case ET_KeyRelease:
        case ET_ProximityIn:
        case ET_ProximityOut:
            GetSpritePosition(device, &rootX, &rootY);
            event->root_x = rootX;
            event->root_y = rootY;
            NoticeEventTime((InternalEvent*)event);
            event->corestate = state;
            key = event->detail.key;
            break;
        default:
            break;
d1735 2
a1736 2
	DeviceEventInfoRec eventinfo;
	SpritePtr pSprite = device->spriteInfo->sprite;
d1738 7
a1744 7
	/* see comment in EnqueueEvents regarding the next three lines */
	if (ev->any.type == ET_Motion)
	    ev->device_event.root = pSprite->hotPhys.pScreen->root->drawable.id;

	eventinfo.device = device;
	eventinfo.event = ev;
	CallCallbacks(&DeviceEventCallback, (pointer) & eventinfo);
d1749 31
a1779 41
    switch(event->type)
    {
        case ET_KeyPress:
            if (!grab && CheckDeviceGrabs(device, event, 0))
                return;
            break;
        case ET_KeyRelease:
            if (grab && device->deviceGrab.fromPassiveGrab &&
                (key == device->deviceGrab.activatingKey) &&
                (device->deviceGrab.grab->type == KeyPress ||
                 device->deviceGrab.grab->type == DeviceKeyPress ||
                 device->deviceGrab.grab->type == XI_KeyPress))
                deactivateDeviceGrab = TRUE;
            break;
        case ET_ButtonPress:
            event->detail.button = b->map[key];
            if (!event->detail.button) { /* there's no button 0 */
                event->detail.button = key;
                return;
            }
            if (!grab && CheckDeviceGrabs(device, event, 0))
            {
                /* if a passive grab was activated, the event has been sent
                 * already */
                return;
            }
            break;
        case ET_ButtonRelease:
            event->detail.button = b->map[key];
            if (!event->detail.button) { /* there's no button 0 */
                event->detail.button = key;
                return;
            }
            if (grab && !b->buttonsDown &&
                device->deviceGrab.fromPassiveGrab &&
                (device->deviceGrab.grab->type == ButtonPress ||
                 device->deviceGrab.grab->type == DeviceButtonPress ||
                 device->deviceGrab.grab->type == XI_ButtonPress))
                deactivateDeviceGrab = TRUE;
        default:
            break;
a1781 1

d1783 4
a1786 3
        DeliverGrabbedEvent((InternalEvent*)event, device, deactivateDeviceGrab);
    else if (device->focus && !IsPointerEvent((InternalEvent*)ev))
        DeliverFocusedEvent(device, (InternalEvent*)event,
d1789 1
a1789 1
        DeliverDeviceEvents(GetSpriteWindow(device), (InternalEvent*)event,
d1793 1
a1793 1
	(*device->deviceGrab.DeactivateGrab) (device);
d1797 207
d2011 1
a2011 1
	return FALSE;
d2027 4
a2030 3
void
InitValuatorAxisStruct(DeviceIntPtr dev, int axnum, Atom label, int minval, int maxval,
		       int resolution, int min_res, int max_res, int mode)
d2034 2
a2035 2
    if (!dev || !dev->valuator || minval > maxval)
        return;
d2037 1
a2037 1
        return;
d2051 64
d2119 1
a2119 1
		     ButtonClassPtr b, ValuatorClassPtr v, int first)
d2130 9
a2138 8
	ev->classes_reported |= (1 << ButtonClass);
	ev->num_buttons = b->numButtons;
	memcpy((char*)ev->buttons, (char*)b->down, 4);
    } else if (k) {
	ev->classes_reported |= (1 << KeyClass);
	ev->num_keys = k->xkbInfo->desc->max_key_code -
                       k->xkbInfo->desc->min_key_code;
	memmove((char *)&ev->keys[0], (char *)k->down, 4);
d2141 1
a2141 1
	int nval = v->numAxes - first;
d2143 12
a2154 12
	ev->classes_reported |= (1 << ValuatorClass);
	ev->classes_reported |= valuator_get_mode(dev, 0) << ModeBitsShift;
	ev->num_valuators = nval < 3 ? nval : 3;
	switch (ev->num_valuators) {
	case 3:
	    ev->valuator2 = v->axisVal[first + 2];
	case 2:
	    ev->valuator1 = v->axisVal[first + 1];
	case 1:
	    ev->valuator0 = v->axisVal[first];
	    break;
	}
d2160 1
a2160 1
		  int first)
d2170 1
a2170 1
	ev->valuator2 = v->axisVal[first + 2];
d2172 1
a2172 1
	ev->valuator1 = v->axisVal[first + 1];
d2174 2
a2175 2
	ev->valuator0 = v->axisVal[first];
	break;
d2203 1
a2203 2
        nkeys = k->xkbInfo->desc->max_key_code -
            k->xkbInfo->desc->min_key_code;
d2235 2
a2236 1
            memcpy((char*)&bev->buttons[4], (char*)&b->down[4], DOWN_LENGTH - 4);
d2255 1
a2255 1
            memmove((char *)&kev->keys[0], (char *)&k->down[4], 28);
d2284 1
a2284 1
		 WindowPtr pWin)
d2299 12
a2310 12
    xi2event->type         = GenericEvent;
    xi2event->extension    = IReqCode;
    xi2event->evtype       = type;
    xi2event->length       = bytes_to_int32(len - sizeof(xEvent));
    xi2event->buttons_len  = btlen;
    xi2event->detail       = detail;
    xi2event->time         = currentTime.milliseconds;
    xi2event->deviceid     = dev->id;
    xi2event->sourceid     = dev->id; /* a device doesn't change focus by itself */
    xi2event->mode         = mode;
    xi2event->root_x       = FP1616(mouse->spriteInfo->sprite->hot.x, 0);
    xi2event->root_y       = FP1616(mouse->spriteInfo->sprite->hot.y, 0);
d2314 1
a2314 1
            SetBit(&xi2event[1], i);
d2316 1
a2316 2
    if (dev->key)
    {
d2328 1
a2328 1
    FixUpEventFromWindow(dev->spriteInfo->sprite, (xEvent*)xi2event, pWin,
d2331 2
a2332 2
    DeliverEventsToWindow(dev, pWin, (xEvent*)xi2event, 1,
                          GetEventFilter(dev, (xEvent*)xi2event), NullGrab);
d2344 2
a2345 2
    DeliverEventsToWindow(dev, pWin, (xEvent *) & event, 1,
				DeviceFocusChangeMask, NullGrab);
d2352 1
a2352 1
CheckGrabValues(ClientPtr client, GrabParameters* param)
d2354 2
a2355 4
    if (param->grabtype != GRABTYPE_CORE &&
        param->grabtype != GRABTYPE_XI &&
        param->grabtype != GRABTYPE_XI2)
    {
d2361 4
a2364 3
	(param->this_device_mode != GrabModeAsync)) {
	client->errorValue = param->this_device_mode;
	return BadValue;
d2367 4
a2370 3
	(param->other_devices_mode != GrabModeAsync)) {
	client->errorValue = param->other_devices_mode;
	return BadValue;
d2373 1
a2373 1
    if (param->grabtype != GRABTYPE_XI2 && (param->modifiers != AnyModifier) &&
d2375 2
a2376 2
	client->errorValue = param->modifiers;
	return BadValue;
d2380 2
a2381 2
	client->errorValue = param->ownerEvents;
	return BadValue;
d2388 2
a2389 2
           int button, GrabParameters *param, GrabType grabtype,
	   GrabMask *mask)
d2399 1
a2399 1
	return rc;
d2401 1
a2401 1
	confineTo = NullWindow;
d2403 4
a2406 3
	rc = dixLookupWindow(&confineTo, param->confineTo, client, DixSetAttrAccess);
	if (rc != Success)
	    return rc;
d2409 1
a2409 1
	cursor = NullCursor;
d2411 11
a2421 11
	rc = dixLookupResourceByType((pointer *)&cursor, param->cursor,
				     RT_CURSOR, client, DixUseAccess);
	if (rc != Success)
	{
	    client->errorValue = param->cursor;
	    return rc;
	}
	access_mode |= DixForceAccess;
    }
    if (param->this_device_mode == GrabModeSync || param->other_devices_mode == GrabModeSync)
	access_mode |= DixFreezeAccess;
d2424 1
a2424 1
	return rc;
d2427 1
a2427 1
	return rc;
d2429 1
a2429 1
    if (grabtype == GRABTYPE_XI)
d2431 1
a2431 1
    else if (grabtype == GRABTYPE_XI2)
d2437 1
a2437 1
	return BadAlloc;
d2442 2
a2443 2
 * Grab the given key. If grabtype is GRABTYPE_XI, the key is a keycode. If
 * grabtype is GRABTYPE_XI2, the key is a keysym.
d2447 2
a2448 1
        int key, GrabParameters *param, GrabType grabtype, GrabMask *mask)
d2460 2
a2461 3
	return BadMatch;
    if (grabtype == GRABTYPE_XI)
    {
d2463 2
a2464 2
                    key < k->xkbInfo->desc->min_key_code)
                && (key != AnyKey)) {
d2469 2
a2470 1
    } else if (grabtype == GRABTYPE_XI2)
d2475 4
a2478 3
	return rc;
    if (param->this_device_mode == GrabModeSync || param->other_devices_mode == GrabModeSync)
	access_mode |= DixFreezeAccess;
d2481 1
a2481 1
	return rc;
d2486 1
a2486 1
	return BadAlloc;
d2507 1
a2507 1
	return rc;
d2509 1
a2509 1
	cursor = NullCursor;
d2511 11
a2521 11
	rc = dixLookupResourceByType((pointer *)&cursor, param->cursor,
				     RT_CURSOR, client, DixUseAccess);
	if (rc != Success)
	{
	    client->errorValue = param->cursor;
	    return rc;
	}
	access_mode |= DixForceAccess;
    }
    if (param->this_device_mode == GrabModeSync || param->other_devices_mode == GrabModeSync)
	access_mode |= DixFreezeAccess;
d2524 25
a2548 1
	return rc;
d2550 6
a2555 3
    grab = CreateGrab(client->index, dev, dev, pWin, GRABTYPE_XI2,
                      mask, param, (type == XIGrabtypeEnter) ? XI_Enter : XI_FocusIn,
                      0, NULL, cursor);
d2557 2
d2567 1
a2567 1
		Mask mask, Mask exclusivemasks)
d2576 32
a2607 32
	if (check & wOtherInputMasks(pWin)->inputEvents[mskidx]) {	/* It is illegal for two different
									 * clients to select on any of the
									 * events for maskcheck. However,
									 * it is OK, for some client to
									 * continue selecting on one of those
									 * events.  */
	    for (others = wOtherInputMasks(pWin)->inputClients; others;
		 others = others->next) {
		if (!SameClient(others, client) && (check &
						    others->mask[mskidx]))
		    return BadAccess;
	    }
	}
	for (others = wOtherInputMasks(pWin)->inputClients; others;
	     others = others->next) {
	    if (SameClient(others, client)) {
		check = others->mask[mskidx];
		others->mask[mskidx] = mask;
		if (mask == 0) {
		    for (i = 0; i < EMASKSIZE; i++)
			if (i != mskidx && others->mask[i] != 0)
			    break;
		    if (i == EMASKSIZE) {
			RecalculateDeviceDeliverableEvents(pWin);
			if (ShouldFreeInputMasks(pWin, FALSE))
			    FreeResource(others->resource, RT_NONE);
			return Success;
		    }
		}
		goto maskSet;
	    }
	}
d2611 2
a2612 2
	return ret;
  maskSet:
d2614 4
a2617 4
	if ((dev->valuator->motionHintWindow == pWin) &&
	    (mask & DevicePointerMotionHintMask) &&
	    !(check & DevicePointerMotionHintMask) && !dev->deviceGrab.grab)
	    dev->valuator->motionHintWindow = NullWindow;
d2622 14
d2642 2
a2643 2
	return BadAlloc;
    others = calloc(1, sizeof(InputClients));
d2645 1
a2645 1
	return BadAlloc;
d2647 4
a2650 1
	goto bail;
d2656 1
a2656 1
	goto bail;
d2659 2
a2660 2
bail:
    free(others);
d2671 6
a2676 1
	return FALSE;
d2681 8
d2693 1
a2693 1
    struct _OtherInputMasks *inputMasks;	/* default: NULL */
d2695 1
a2695 1
    int i, j;
d2699 8
a2706 1
	if ((inputMasks = wOtherInputMasks(pChild)) != 0) {
d2708 18
a2725 28
                memset(inputMasks->xi2mask[i], 0, sizeof(inputMasks->xi2mask[i]));
	    for (others = inputMasks->inputClients; others;
		 others = others->next) {
		for (i = 0; i < EMASKSIZE; i++)
		    inputMasks->inputEvents[i] |= others->mask[i];
                for (i = 0; i < EMASKSIZE; i++)
                    for (j = 0; j < XI2MASKSIZE; j++)
                        inputMasks->xi2mask[i][j] |= others->xi2mask[i][j];
	    }
	    for (i = 0; i < EMASKSIZE; i++)
		inputMasks->deliverableEvents[i] = inputMasks->inputEvents[i];
	    for (tmp = pChild->parent; tmp; tmp = tmp->parent)
		if (wOtherInputMasks(tmp))
		    for (i = 0; i < EMASKSIZE; i++)
			inputMasks->deliverableEvents[i] |=
			    (wOtherInputMasks(tmp)->deliverableEvents[i]
			     & ~inputMasks->
			     dontPropagateMask[i] & PropagateMask[i]);
	}
	if (pChild->firstChild) {
	    pChild = pChild->firstChild;
	    continue;
	}
	while (!pChild->nextSib && (pChild != pWin))
	    pChild = pChild->parent;
	if (pChild == pWin)
	    break;
	pChild = pChild->nextSib;
d2735 1
a2735 1
	return Success;
d2738 31
a2768 26
	 other = other->next) {
	if (other->resource == id) {
	    if (prev) {
		prev->next = other->next;
		free(other);
	    } else if (!(other->next)) {
		if (ShouldFreeInputMasks(pWin, TRUE)) {
		    wOtherInputMasks(pWin)->inputClients = other->next;
		    free(wOtherInputMasks(pWin));
		    pWin->optional->inputMasks = (OtherInputMasks *) NULL;
		    CheckWindowOptionalNeed(pWin);
		    free(other);
		} else {
		    other->resource = FakeClientID(0);
		    if (!AddResource(other->resource, RT_INPUTCLIENT,
				     (pointer) pWin))
			return BadAlloc;
		}
	    } else {
		wOtherInputMasks(pWin)->inputClients = other->next;
		free(other);
	    }
	    RecalculateDeviceDeliverableEvents(pWin);
	    return Success;
	}
	prev = other;
d2773 31
d2806 1
a2806 1
	  xEvent * ev, Mask mask, int count)
d2809 1
a2809 1
    WindowPtr effectiveFocus = NullWindow;	/* only set if dest==InputFocus */
d2813 1
a2813 1
	pWin = spriteWin;
d2815 1
a2815 1
	WindowPtr inputFocus;
d2817 25
a2841 23
	if (!d->focus)
	    inputFocus = spriteWin;
	else
	    inputFocus = d->focus->win;

	if (inputFocus == FollowKeyboardWin)
	    inputFocus = inputInfo.keyboard->focus->win;

	if (inputFocus == NoneWin)
	    return Success;

	/* If the input focus is PointerRootWin, send the event to where
	 * the pointer is if possible, then perhaps propogate up to root. */
	if (inputFocus == PointerRootWin)
	    inputFocus = GetCurrentRootWindow(d);

	if (IsParent(inputFocus, spriteWin)) {
	    effectiveFocus = inputFocus;
	    pWin = spriteWin;
	} else
	    effectiveFocus = pWin = inputFocus;
    } else
	dixLookupWindow(&pWin, dest, client, DixSendAccess);
d2843 1
a2843 1
	return BadWindow;
d2845 2
a2846 2
	client->errorValue = propagate;
	return BadValue;
d2850 13
a2862 12
	for (; pWin; pWin = pWin->parent) {
	    if (DeliverEventsToWindow(d, pWin, ev, count, mask, NullGrab))
		return Success;
	    if (pWin == effectiveFocus)
		return Success;
	    if (wOtherInputMasks(pWin))
		mask &= ~wOtherInputMasks(pWin)->dontPropagateMask[d->id];
	    if (!mask)
		break;
	}
    } else if (!XaceHook(XACE_SEND_ACCESS, client, NULL, pWin, ev, count))
	DeliverEventsToWindow(d, pWin, ev, count, mask, NullGrab);
d2873 1
a2873 1
	return BadMatch;
d2876 2
a2877 2
	client->errorValue = nElts;
	return BadValue;
d2880 1
a2880 1
	return BadValue;
d2882 2
a2883 2
	if ((b->map[i + 1] != map[i]) && BitIsOn(b->down, i + 1))
	    return MappingBusy;
d2885 1
a2885 1
	b->map[i + 1] = map[i];
d2891 5
a2895 5
		 DeviceIntPtr dev,
		 unsigned len,
		 int type,
		 KeyCode firstKeyCode,
		 CARD8 keyCodes, CARD8 keySymsPerKeyCode, KeySym * map)
d2901 1
a2901 1
	return BadMatch;
d2904 1
a2904 1
	return BadLength;
d2907 3
a2909 3
	(firstKeyCode + keyCodes - 1 > k->xkbInfo->desc->max_key_code)) {
	client->errorValue = firstKeyCode;
	return BadValue;
d2912 2
a2913 2
	client->errorValue = 0;
	return BadValue;
d2936 1
a2936 1
	(*dev->deviceGrab.DeactivateGrab) (dev);
d2942 3
a2944 1
	int focusEventMode = NotifyNormal;
d2946 2
a2947 1
	/* If a grab is in progress, then alter the mode of focus events. */
d2949 28
a2976 2
	if (dev->deviceGrab.grab)
	    focusEventMode = NotifyWhileGrabbed;
d2978 9
a2986 36
	switch (dev->focus->revert) {
	case RevertToNone:
	    if (!ActivateFocusInGrab(dev, pWin, NoneWin))
		DoFocusEvents(dev, pWin, NoneWin, focusEventMode);
	    dev->focus->win = NoneWin;
	    dev->focus->traceGood = 0;
	    break;
	case RevertToParent:
	    parent = pWin;
	    do {
		parent = parent->parent;
		dev->focus->traceGood--;
	    }
	    while (!parent->realized);
	    if (!ActivateFocusInGrab(dev, pWin, parent))
		DoFocusEvents(dev, pWin, parent, focusEventMode);
	    dev->focus->win = parent;
	    dev->focus->revert = RevertToNone;
	    break;
	case RevertToPointerRoot:
	    if (!ActivateFocusInGrab(dev, pWin, PointerRootWin))
		DoFocusEvents(dev, pWin, PointerRootWin, focusEventMode);
	    dev->focus->win = PointerRootWin;
	    dev->focus->traceGood = 0;
	    break;
	case RevertToFollowKeyboard:
            {
                DeviceIntPtr kbd = GetMaster(dev, MASTER_KEYBOARD);
                if (!kbd || (kbd == dev && kbd != inputInfo.keyboard))
                    kbd = inputInfo.keyboard;
	    if (kbd->focus->win) {
		if (!ActivateFocusInGrab(dev, pWin, kbd->focus->win))
		    DoFocusEvents(dev, pWin, kbd->focus->win, focusEventMode);
		dev->focus->win = FollowKeyboardWin;
		dev->focus->traceGood = 0;
	    } else {
d2989 2
a2990 3
		dev->focus->win = NoneWin;
		dev->focus->traceGood = 0;
	    }
d2992 3
a2994 2
	    break;
	}
d2998 2
a2999 2
	if (dev->valuator->motionHintWindow == pWin)
	    dev->valuator->motionHintWindow = NullWindow;
d3011 1
a3011 1
	DeleteDeviceFromAnyExtEvents(pWin, dev);
d3015 1
a3015 1
	DeleteDeviceFromAnyExtEvents(pWin, dev);
d3018 6
a3023 6
	while ((inputMasks = wOtherInputMasks(pWin)) != 0) {
	    ic = inputMasks->inputClients;
	    for (i = 0; i < EMASKSIZE; i++)
		inputMasks->dontPropagateMask[i] = 0;
	    FreeResource(ic->resource, RT_NONE);
	}
d3027 1
a3027 1
MaybeSendDeviceMotionNotifyHint(deviceKeyButtonPointer * pEvents, Mask mask)
d3032 1
a3032 1
		    DixReadAccess);
d3037 9
a3045 8
	if (mask & DevicePointerMotionHintMask) {
	    if (WID(dev->valuator->motionHintWindow) == pEvents->event) {
		return 1;	/* don't send, but pretend we did */
	    }
	    pEvents->detail = NotifyHint;
	} else {
	    pEvents->detail = NotifyNormal;
	}
d3052 2
a3053 2
			     deviceKeyButtonPointer * xE, GrabPtr grab,
			     ClientPtr client, Mask deliveryMask)
d3058 1
a3058 1
		    DixGrabAccess);
d3063 1
a3063 1
	dev->valuator->motionHintWindow = pWin;
d3065 2
a3066 2
	     (deliveryMask & DeviceButtonGrabMask)) {
	GrabRec tempGrab;
d3068 17
a3084 12
	tempGrab.device = dev;
	tempGrab.resource = client->clientAsMask;
	tempGrab.window = pWin;
	tempGrab.ownerEvents =
	    (deliveryMask & DeviceOwnerGrabButtonMask) ? TRUE : FALSE;
	tempGrab.eventMask = deliveryMask;
	tempGrab.keyboardMode = GrabModeAsync;
	tempGrab.pointerMode = GrabModeAsync;
	tempGrab.confineTo = NullWindow;
	tempGrab.cursor = NullCursor;
        tempGrab.next = NULL;
	(*dev->deviceGrab.ActivateGrab) (dev, &tempGrab, currentTime, TRUE);
d3094 1
a3094 1
	return 0;
d3096 3
a3098 3
	 other = other->next) {
	if (SameClient(other, client))
	    return other->mask[dev->id];
d3112 8
a3119 8
	 ((grab->eventMask & DevicePointerMotionHintMask) ||
	  (grab->ownerEvents &&
	   (DeviceEventMaskForClient(dev, pWin, client) &
	    DevicePointerMotionHintMask)))) ||
	(!grab &&
	 (DeviceEventMaskForClient(dev, pWin, client) &
	  DevicePointerMotionHintMask)))
	dev->valuator->motionHintWindow = NullWindow;
d3124 1
a3124 1
			     int maskndx)
d3129 2
a3130 2
	client->errorValue = mask;
	return BadValue;
d3134 8
a3141 7
	if (inputMasks)
	    inputMasks->dontPropagateMask[maskndx] = mask;
    } else {
	if (!inputMasks)
	    AddExtensionClient(pWin, client, 0, 0);
	inputMasks = wOtherInputMasks(pWin);
	inputMasks->dontPropagateMask[maskndx] = mask;
d3145 1
a3145 1
	FreeResource(inputMasks->inputClients->resource, RT_NONE);
d3157 1
a3157 1
	allInputEventMasks |= inputMasks->dontPropagateMask[i];
d3159 2
a3160 2
	for (i = 0; i < EMASKSIZE; i++)
	    allInputEventMasks |= inputMasks->inputEvents[i];
d3162 1
a3162 1
	return TRUE;
d3164 1
a3164 1
	return FALSE;
d3176 1
a3176 1
                       xEvent * ev, int count)
d3195 1
a3195 1
SendEventToAllWindows(DeviceIntPtr dev, Mask mask, xEvent * ev, int count)
d3220 1
a3220 1
               unsigned int len, unsigned char* mask)
d3226 5
a3230 7
    if (masks)
    {
	for (others = wOtherInputMasks(win)->inputClients; others;
	     others = others->next) {
	    if (SameClient(others, client)) {
                memset(others->xi2mask[dev->id], 0,
                       sizeof(others->xi2mask[dev->id]));
d3236 1
a3236 4
    len = min(len, sizeof(others->xi2mask[dev->id]));

    if (len && !others)
    {
d3239 1
a3239 1
        others= wOtherInputMasks(win)->inputClients;
d3242 4
a3245 2
    if (others)
        memset(others->xi2mask[dev->id], 0, sizeof(others->xi2mask[dev->id]));
d3247 3
a3249 2
    if (len)
        memcpy(others->xi2mask[dev->id], mask, len);
@


1.9
log
@Merge patch from http://patchwork.freedesktop.org/patch/7707/,
Xi: allow passive keygrabs on the XIAll(Master)Devices fake deviceslogin.
Amongst other things, this fixes a regression that can be seen in media
keys handling under gnome-settings-daemon.

ok matthieu@@
@
text
@d930 1
a930 1
            SetBit(event->buttons, i);
@


1.8
log
@Update to xserver 1.11.2
@
text
@d1444 1
a1444 1
    if (k == NULL)
@


1.7
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d80 1
a114 7
void
RegisterOtherDevice(DeviceIntPtr device)
{
    device->public.processInputProc = ProcessOtherEvent;
    device->public.realInputProc = ProcessOtherEvent;
}

d539 1
d548 2
a549 4
        to->valuator = realloc(to->valuator, sizeof(ValuatorClassRec) +
                from->valuator->numAxes * sizeof(AxisInfo) +
                from->valuator->numAxes * sizeof(double));
        v = to->valuator;
d553 1
a553 2
        v->numAxes = from->valuator->numAxes;
        v->axes = (AxisInfoPtr)&v[1];
a555 1
        v->axisVal = (double*)(v->axes + from->valuator->numAxes);
a556 1
        v->mode = from->valuator->mode;
a626 24

    if (from->absolute)
    {
        if (!to->absolute)
        {
            classes = to->unused_classes;
            to->absolute = classes->absolute;
            if (!to->absolute)
            {
                to->absolute = calloc(1, sizeof(AbsoluteClassRec));
                if (!to->absolute)
                    FatalError("[Xi] no memory for class shift.\n");
            } else
                classes->absolute = NULL;
        }
        memcpy(to->absolute, from->absolute, sizeof(AbsoluteClassRec));
        to->absolute->sourceid = from->id;
    } else if (to->absolute)
    {
        ClassesPtr classes;
        classes = to->unused_classes;
        classes->absolute = to->absolute;
        to->absolute      = NULL;
    }
d687 4
a690 1
    if (!slave->u.master)
d693 1
a693 1
    if (slave->u.master->id != dce->masterid)
d846 1
a846 1
                if (IsMaster(sd) || sd->u.master != device)
d872 1
a872 1
	device->valuator->mode &= ~OutOfProximity;
d874 1
a874 1
	device->valuator->mode |= OutOfProximity;
a878 26
static void
ProcessRawEvent(RawDeviceEvent *ev, DeviceIntPtr device)
{
    GrabPtr grab = device->deviceGrab.grab;

    if (grab)
        DeliverGrabbedEvent((InternalEvent*)ev, device, FALSE);
    else { /* deliver to all root windows */
        xEvent *xi;
        int i;

        i = EventToXI2((InternalEvent*)ev, (xEvent**)&xi);
        if (i != Success)
        {
            ErrorF("[Xi] %s: XI2 conversion failed in ProcessRawEvent (%d)\n",
                    device->name, i);
            return;
        }

        for (i = 0; i < screenInfo.numScreens; i++)
            DeliverEventsToWindow(device, screenInfo.screens[i]->root, xi, 1,
                                  GetEventFilter(device, xi), NULL);
        free(xi);
    }
}

d898 1
a898 1
    CHECKEVENT(ev);
d906 1
a906 1
        ProcessRawEvent(&ev->raw_event, device);
d960 1
a960 1
    if (IsMaster(device) || !device->u.master)
d1001 1
a1001 2
            if (!grab && CheckDeviceGrabs(device, event, 0)) {
                device->deviceGrab.activatingKey = key;
a1002 1
            }
d1065 1
d1081 1
a1081 1
		       int resolution, int min_res, int max_res)
d1098 4
d1130 1
a1130 1
	ev->classes_reported |= (dev->valuator->mode << ModeBitsShift);
d1166 102
d1277 1
a1277 1
    mouse = (IsMaster(dev) || dev->u.master) ? GetMaster(dev, MASTER_POINTER) : dev;
d1315 2
a1316 1
    FixUpEventFromWindow(dev, (xEvent*)xi2event, pWin, None, FALSE);
d1334 2
a1335 98
    if ((type == DeviceFocusIn) &&
	(wOtherInputMasks(pWin)) &&
	(wOtherInputMasks(pWin)->inputEvents[dev->id] & DeviceStateNotifyMask))
    {
	int evcount = 1;
	deviceStateNotify *ev, *sev;
	deviceKeyStateNotify *kev;
	deviceButtonStateNotify *bev;

	KeyClassPtr k;
	ButtonClassPtr b;
	ValuatorClassPtr v;
	int nval = 0, nkeys = 0, nbuttons = 0, first = 0;

	if ((b = dev->button) != NULL) {
	    nbuttons = b->numButtons;
	    if (nbuttons > 32)
		evcount++;
	}
	if ((k = dev->key) != NULL) {
	    nkeys = k->xkbInfo->desc->max_key_code -
                    k->xkbInfo->desc->min_key_code;
	    if (nkeys > 32)
		evcount++;
	    if (nbuttons > 0) {
		evcount++;
	    }
	}
	if ((v = dev->valuator) != NULL) {
	    nval = v->numAxes;

	    if (nval > 3)
		evcount++;
	    if (nval > 6) {
		if (!(k && b))
		    evcount++;
		if (nval > 9)
		    evcount += ((nval - 7) / 3);
	    }
	}

	sev = ev = (deviceStateNotify *) malloc(evcount * sizeof(xEvent));
	FixDeviceStateNotify(dev, ev, NULL, NULL, NULL, first);

	if (b != NULL) {
	    FixDeviceStateNotify(dev, ev++, NULL, b, v, first);
	    first += 3;
	    nval -= 3;
	    if (nbuttons > 32) {
		(ev - 1)->deviceid |= MORE_EVENTS;
		bev = (deviceButtonStateNotify *) ev++;
		bev->type = DeviceButtonStateNotify;
		bev->deviceid = dev->id;
		memcpy((char*)&bev->buttons[4], (char*)&b->down[4], DOWN_LENGTH - 4);
	    }
	    if (nval > 0) {
		(ev - 1)->deviceid |= MORE_EVENTS;
		FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
		first += 3;
		nval -= 3;
	    }
	}

	if (k != NULL) {
	    FixDeviceStateNotify(dev, ev++, k, NULL, v, first);
	    first += 3;
	    nval -= 3;
	    if (nkeys > 32) {
		(ev - 1)->deviceid |= MORE_EVENTS;
		kev = (deviceKeyStateNotify *) ev++;
		kev->type = DeviceKeyStateNotify;
		kev->deviceid = dev->id;
		memmove((char *)&kev->keys[0], (char *)&k->down[4], 28);
	    }
	    if (nval > 0) {
		(ev - 1)->deviceid |= MORE_EVENTS;
		FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
		first += 3;
		nval -= 3;
	    }
	}

	while (nval > 0) {
	    FixDeviceStateNotify(dev, ev++, NULL, NULL, v, first);
	    first += 3;
	    nval -= 3;
	    if (nval > 0) {
		(ev - 1)->deviceid |= MORE_EVENTS;
		FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
		first += 3;
		nval -= 3;
	    }
	}

	DeliverEventsToWindow(dev, pWin, (xEvent *) sev, evcount,
				    DeviceStateNotifyMask, NullGrab);
	free(sev);
    }
d1588 1
a1588 1
	return BadAlloc;
d1594 1
a1594 1
	return BadAlloc;
d1596 4
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d881 4
a884 2
                if (button_is_down(sd, key, BUTTON_PROCESSED))
                    return DONT_PROCESS;
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a96 3
/* Used to sture classes currently not in use by an MD */
extern DevPrivateKey UnusedClassesPrivateKey;

d224 1
a224 2
            classes = dixLookupPrivate(&to->devPrivates,
                                       UnusedClassesPrivateKey);
d226 1
d234 1
a234 1
                *i = xcalloc(1, sizeof(IntegerFeedbackClassRec));
d249 1
a249 1
        classes = dixLookupPrivate(&to->devPrivates, UnusedClassesPrivateKey);
d260 1
a260 2
            classes = dixLookupPrivate(&to->devPrivates,
                                       UnusedClassesPrivateKey);
d262 1
d270 1
a270 1
                *s = xcalloc(1, sizeof(StringFeedbackClassRec));
d285 1
a285 1
        classes = dixLookupPrivate(&to->devPrivates, UnusedClassesPrivateKey);
d296 1
a296 2
            classes = dixLookupPrivate(&to->devPrivates,
                                       UnusedClassesPrivateKey);
d298 1
d306 1
a306 1
                *b = xcalloc(1, sizeof(BellFeedbackClassRec));
d322 1
a322 1
        classes = dixLookupPrivate(&to->devPrivates, UnusedClassesPrivateKey);
d333 1
a333 2
            classes = dixLookupPrivate(&to->devPrivates,
                                       UnusedClassesPrivateKey);
d335 1
d343 1
a343 1
                *l = xcalloc(1, sizeof(LedFeedbackClassRec));
d361 1
a361 1
        classes = dixLookupPrivate(&to->devPrivates, UnusedClassesPrivateKey);
d381 1
a381 2
            classes = dixLookupPrivate(&to->devPrivates,
                                       UnusedClassesPrivateKey);
d386 1
d394 1
a394 1
                *k = xcalloc(1, sizeof(KbdFeedbackClassRec));
d413 1
a413 1
        classes = dixLookupPrivate(&to->devPrivates, UnusedClassesPrivateKey);
d422 1
a422 2
            classes = dixLookupPrivate(&to->devPrivates,
                    UnusedClassesPrivateKey);
d434 1
a434 1
        classes = dixLookupPrivate(&to->devPrivates, UnusedClassesPrivateKey);
d471 1
a471 2
            classes = dixLookupPrivate(&to->devPrivates,
                                       UnusedClassesPrivateKey);
d475 1
a475 1
                to->focus = xcalloc(1, sizeof(FocusClassRec));
d483 1
a483 1
            to->focus->trace = xrealloc(oldTrace,
d494 1
a494 1
        classes = dixLookupPrivate(&to->devPrivates, UnusedClassesPrivateKey);
d512 1
a512 2
            classes = dixLookupPrivate(&to->devPrivates,
                                       UnusedClassesPrivateKey);
d514 1
d522 1
a522 1
                *p = xcalloc(1, sizeof(PtrFeedbackClassRec));
d537 1
a537 1
        classes = dixLookupPrivate(&to->devPrivates, UnusedClassesPrivateKey);
d547 1
a547 2
            classes = dixLookupPrivate(&to->devPrivates,
                                       UnusedClassesPrivateKey);
d553 1
a553 1
        to->valuator = xrealloc(to->valuator, sizeof(ValuatorClassRec) +
d570 1
a570 1
        classes = dixLookupPrivate(&to->devPrivates, UnusedClassesPrivateKey);
d579 1
a579 2
            classes = dixLookupPrivate(&to->devPrivates,
                                       UnusedClassesPrivateKey);
d583 1
a583 1
                to->button = xcalloc(1, sizeof(ButtonClassRec));
d594 1
a594 1
                to->button->xkb_acts = xcalloc(1, sizeof(XkbAction));
d601 1
a601 1
            xfree(to->button->xkb_acts);
d609 1
a609 1
        classes = dixLookupPrivate(&to->devPrivates, UnusedClassesPrivateKey);
d618 1
a618 2
            classes = dixLookupPrivate(&to->devPrivates,
                                       UnusedClassesPrivateKey);
d622 1
a622 1
                to->proximity = xcalloc(1, sizeof(ProximityClassRec));
d633 1
a633 1
        classes = dixLookupPrivate(&to->devPrivates, UnusedClassesPrivateKey);
d642 1
a642 2
            classes = dixLookupPrivate(&to->devPrivates,
                                       UnusedClassesPrivateKey);
d646 1
a646 1
                to->absolute = xcalloc(1, sizeof(AbsoluteClassRec));
d657 1
a657 1
        classes = dixLookupPrivate(&to->devPrivates, UnusedClassesPrivateKey);
d703 1
a703 1
    xfree(dcce);
a755 1
    BYTE *kptr          = NULL;
d822 2
a823 3
	kptr = &k->down[key >> 3];
        /* don't allow ddx to generate multiple downs, but repeats are okay */
	if ((*kptr & bit) && !event->key_repeat)
d825 1
d828 1
a828 1
	*kptr |= bit;
d833 1
a833 2
	kptr = &k->down[key >> 3];
	if (!(*kptr & bit))	/* guard against duplicates */
d837 1
a837 1
	*kptr &= ~bit;
d843 1
a843 2
        kptr = &b->down[key >> 3];
        if ((*kptr & bit) != 0)
d845 2
a846 1
        *kptr |= bit;
d866 1
a866 2
        kptr = &b->down[key>>3];
        if (!(*kptr & bit))
d881 1
a881 1
                if ((sd->button->down[key>>3] & bit) != 0)
d885 1
a885 1
        *kptr &= ~bit;
d928 1
a928 1
            DeliverEventsToWindow(device, WindowTable[i], xi, 1,
d930 1
a930 1
        xfree(xi);
d1044 1
a1044 1
	    ev->device_event.root = WindowTable[pSprite->hotPhys.pScreen->myNum]->drawable.id;
d1118 1
a1118 1
    proxc = (ProximityClassPtr) xalloc(sizeof(ProximityClassRec));
d1234 1
a1234 1
    xi2event = xcalloc(1, len);
d1270 1
a1270 1
    xfree(xi2event);
d1324 1
a1324 1
	sev = ev = (deviceStateNotify *) xalloc(evcount * sizeof(xEvent));
d1379 1
a1379 1
	xfree(sev);
d1447 1
a1447 1
	    return (rc == BadValue) ? BadCursor : rc;
d1545 1
a1545 1
	    return (rc == BadValue) ? BadCursor : rc;
d1629 1
a1629 1
    others = xcalloc(1, sizeof(InputClients));
d1648 1
a1648 1
    imasks = xcalloc(1, sizeof(struct _OtherInputMasks));
d1704 1
a1704 1
	return (Success);
d1711 1
a1711 1
		xfree(other);
d1715 1
a1715 1
		    xfree(wOtherInputMasks(pWin));
d1718 1
a1718 1
		    xfree(other);
d1727 1
a1727 1
		xfree(other);
d1730 1
a1730 1
	    return (Success);
d1831 1
a1831 1
	return (BadMatch);
d1853 1
a1853 1
    return client->noClientException;
d1974 1
a1974 1
    return (0);
d2122 1
a2122 1
        pWin = WindowTable[i];
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a54 1
#define	 NEED_EVENTS
d59 1
d64 1
a65 1
#include "inputstr.h"
d77 3
a80 1
#ifdef XKB
a82 2
extern Bool XkbCopyKeymap(XkbDescPtr src, XkbDescPtr dst, Bool sendNotifies);
#endif
a89 2
#define Motion_Filter(class) (DevicePointerMotionMask | \
			      (class)->state | (class)->motionMask)
d100 16
d125 1
a125 1
IsPointerEvent(xEvent* xE)
d127 1
a127 1
    switch(xE->u.u.type)
d129 4
a132 5
        case ButtonPress:
        case ButtonRelease:
        case MotionNotify:
        case EnterNotify:
        case LeaveNotify:
d135 1
a135 8
            if (xE->u.u.type == DeviceButtonPress ||
                xE->u.u.type == DeviceButtonRelease ||
                xE->u.u.type == DeviceMotionNotify ||
                xE->u.u.type == ProximityIn ||
                xE->u.u.type == ProximityOut)
            {
                return TRUE;
            }
d198 1
a198 4
    static DeviceIntPtr lastMapNotifyDevice = NULL;
    KeyClassPtr mk, dk; /* master, device */
    BOOL sendNotify = FALSE;
    int i;
d203 1
a203 20
    dk = device->key;
    mk = master->key;

    if (device != dixLookupPrivate(&master->devPrivates,
                                   CoreDevicePrivateKey)) {
        memcpy(mk->modifierMap, dk->modifierMap, MAP_LENGTH);

        if (dk->maxKeysPerModifier)
        {
            mk->modifierKeyMap = xrealloc(mk->modifierKeyMap,
                                          8 * dk->maxKeysPerModifier);
            if (!mk->modifierKeyMap)
                FatalError("[Xi] no memory for class shift.\n");
            memcpy(mk->modifierKeyMap, dk->modifierKeyMap,
                    (8 * dk->maxKeysPerModifier));
        } else
        {
            xfree(mk->modifierKeyMap);
            mk->modifierKeyMap = NULL;
        }
a204 35
        mk->maxKeysPerModifier = dk->maxKeysPerModifier;
        mk->curKeySyms.minKeyCode = dk->curKeySyms.minKeyCode;
        mk->curKeySyms.maxKeyCode = dk->curKeySyms.maxKeyCode;
        SetKeySymsMap(&mk->curKeySyms, &dk->curKeySyms);

        /*
         * Copy state from the extended keyboard to core.  If you omit this,
         * holding Ctrl on keyboard one, and pressing Q on keyboard two, will
         * cause your app to quit.  This feels wrong to me, hence the below
         * code.
         *
         * XXX: If you synthesise core modifier events, the state will get
         *      clobbered here.  You'll have to work out something sensible
         *      to fix that.  Good luck.
         */

#define KEYBOARD_MASK (ShiftMask | LockMask | ControlMask | Mod1Mask | \
        Mod2Mask | Mod3Mask | Mod4Mask | Mod5Mask)
        mk->state &= ~(KEYBOARD_MASK);
        mk->state |= (dk->state & KEYBOARD_MASK);
#undef KEYBOARD_MASK
        for (i = 0; i < 8; i++)
            mk->modifierKeyCount[i] = dk->modifierKeyCount[i];

#ifdef XKB
        if (!noXkbExtension && dk->xkbInfo && dk->xkbInfo->desc) {
            if (!mk->xkbInfo || !mk->xkbInfo->desc)
            {
                XkbInitDevice(master);
                XkbFinishDeviceInit(master);
            }
            if (!XkbCopyKeymap(dk->xkbInfo->desc, mk->xkbInfo->desc, True))
                FatalError("Couldn't pivot keymap from device to core!\n");
        }
#endif
d206 2
a207 14
        dixSetPrivate(&master->devPrivates, CoreDevicePrivateKey, device);
        sendNotify = TRUE;
    } else if (lastMapNotifyDevice != master)
        sendNotify = TRUE;

    if (sendNotify)
    {
        SendMappingNotify(master, MappingKeyboard,
                           mk->curKeySyms.minKeyCode,
                          (mk->curKeySyms.maxKeyCode -
                           mk->curKeySyms.minKeyCode),
                          serverClient);
        lastMapNotifyDevice = master;
    }
a219 76
    if (from->kbdfeed)
    {
        KbdFeedbackPtr *k, it;

        if (!to->kbdfeed)
        {
            classes = dixLookupPrivate(&to->devPrivates,
                                       UnusedClassesPrivateKey);
            to->kbdfeed = classes->kbdfeed;
        }

        k = &to->kbdfeed;
        for(it = from->kbdfeed; it; it = it->next)
        {
            if (!(*k))
            {
                *k = xcalloc(1, sizeof(KbdFeedbackClassRec));
                if (!*k)
                {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*k)->BellProc = it->BellProc;
            (*k)->CtrlProc = it->CtrlProc;
            (*k)->ctrl     = it->ctrl;
#ifdef XKB
            if ((*k)->xkb_sli)
                XkbFreeSrvLedInfo((*k)->xkb_sli);
            (*k)->xkb_sli = XkbCopySrvLedInfo(from, it->xkb_sli, *k, NULL);
#endif

            k = &(*k)->next;
        }
    } else if (to->kbdfeed && !from->kbdfeed)
    {
        ClassesPtr classes;
        classes = dixLookupPrivate(&to->devPrivates, UnusedClassesPrivateKey);
        classes->kbdfeed = to->kbdfeed;
        to->kbdfeed      = NULL;
    }

    if (from->ptrfeed)
    {
        PtrFeedbackPtr *p, it;
        if (!to->ptrfeed)
        {
            classes = dixLookupPrivate(&to->devPrivates,
                                       UnusedClassesPrivateKey);
            to->ptrfeed = classes->ptrfeed;
        }

        p = &to->ptrfeed;
        for (it = from->ptrfeed; it; it = it->next)
        {
            if (!(*p))
            {
                *p = xcalloc(1, sizeof(PtrFeedbackClassRec));
                if (!*p)
                {
                    ErrorF("[Xi] Cannot alloc memory for class copy.");
                    return;
                }
            }
            (*p)->CtrlProc = it->CtrlProc;
            (*p)->ctrl     = it->ctrl;

            p = &(*p)->next;
        }
    } else if (to->ptrfeed && !from->ptrfeed)
    {
        ClassesPtr classes;
        classes = dixLookupPrivate(&to->devPrivates, UnusedClassesPrivateKey);
        classes->ptrfeed = to->ptrfeed;
        to->ptrfeed      = NULL;
    }
a354 1
#ifdef XKB
a357 1
#endif
d370 2
a371 11
/**
 * Copies the CONTENT of the classes of device from into the classes in device
 * to. From and to are identical after finishing.
 *
 * If to does not have classes from currenly has, the classes are stored in
 * to's devPrivates system. Later, we recover it again from there if needed.
 * Saves a few memory allocations.
 */

void
DeepCopyDeviceClasses(DeviceIntPtr from, DeviceIntPtr to)
d378 42
a419 1
    DeepCopyFeedbackClasses(from, to);
a422 5
        KeyCode             *oldModKeyMap;
        KeySym              *oldMap;
#ifdef XKB
        struct _XkbSrvInfo  *oldXkbInfo;
#endif
d426 1
a426 1
                                       UnusedClassesPrivateKey);
d429 50
d480 2
a481 2
                to->key = xcalloc(1, sizeof(KeyClassRec));
                if (!to->key)
d484 11
a494 1
                classes->key = NULL;
d496 7
d504 6
a509 5
        oldModKeyMap    = to->key->modifierKeyMap;
        oldMap          = to->key->curKeySyms.map;
#ifdef XKB
        oldXkbInfo      = to->key->xkbInfo;
#endif
d511 5
a515 1
        if (!oldMap) /* newly created key struct */
d517 3
a519 5
            int bytes = (to->key->curKeySyms.maxKeyCode -
                         to->key->curKeySyms.minKeyCode + 1) *
                         to->key->curKeySyms.mapWidth;
            oldMap = (KeySym *)xcalloc(sizeof(KeySym), bytes);
            memcpy(oldMap, from->key->curKeySyms.map, bytes);
d522 14
a535 5
        to->key->modifierKeyMap = oldModKeyMap;
        to->key->curKeySyms.map = oldMap;
#ifdef XKB
        to->key->xkbInfo        = oldXkbInfo;
#endif
d537 3
a539 2
        CopyKeyClass(from, to);
    } else if (to->key && !from->key)
d543 2
a544 2
        classes->key = to->key;
        to->key      = NULL;
d561 1
a561 1
                from->valuator->numAxes * sizeof(unsigned int));
d570 3
a572 1
        v->axisVal = (int*)(v->axes + from->valuator->numAxes);
a596 1
#ifdef XKB
d609 4
a612 1
#endif
d621 1
a621 8

    /* We can't just copy over the focus class. When an app sets the focus,
     * it'll do so on the master device. Copying the SDs focus means losing
     * the focus.
     * So we only copy the focus class if the device didn't have one,
     * otherwise we leave it as it is.
     */
    if (from->focus)
d623 1
a623 1
        if (!to->focus)
a624 2
            WindowPtr *oldTrace;

d627 2
a628 2
            to->focus = classes->focus;
            if (!to->focus)
d630 2
a631 2
                to->focus = xcalloc(1, sizeof(FocusClassRec));
                if (!to->focus)
d634 1
a634 10
                classes->focus = NULL;

            oldTrace = to->focus->trace;
            memcpy(to->focus, from->focus, sizeof(FocusClassRec));
            to->focus->trace = xrealloc(oldTrace,
                                  to->focus->traceSize * sizeof(WindowPtr));
            if (!to->focus->trace && to->focus->traceSize)
                FatalError("[Xi] no memory for trace.\n");
            memcpy(to->focus->trace, from->focus->trace,
                    from->focus->traceSize * sizeof(WindowPtr));
d636 3
a638 1
    } else if (to->focus)
d642 2
a643 2
        classes->focus = to->focus;
        to->focus      = NULL;
d646 1
a646 1
    if (from->proximity)
d648 1
a648 1
        if (!to->proximity)
d652 2
a653 2
            to->proximity = classes->proximity;
            if (!to->proximity)
d655 2
a656 2
                to->proximity = xcalloc(1, sizeof(ProximityClassRec));
                if (!to->proximity)
d659 1
a659 1
                classes->proximity = NULL;
d661 3
a663 2
        memcpy(to->proximity, from->proximity, sizeof(ProximityClassRec));
    } else if (to->proximity)
d667 2
a668 2
        classes->proximity = to->proximity;
        to->proximity      = NULL;
d670 1
d672 32
a703 17
    if (from->absolute)
    {
        if (!to->absolute)
        {
            classes = dixLookupPrivate(&to->devPrivates,
                                       UnusedClassesPrivateKey);
            to->absolute = classes->absolute;
            if (!to->absolute)
            {
                to->absolute = xcalloc(1, sizeof(AbsoluteClassRec));
                if (!to->absolute)
                    FatalError("[Xi] no memory for class shift.\n");
            } else
                classes->absolute = NULL;
        }
        memcpy(to->absolute, from->absolute, sizeof(AbsoluteClassRec));
    } else if (to->absolute)
d705 2
a706 4
        ClassesPtr classes;
        classes = dixLookupPrivate(&to->devPrivates, UnusedClassesPrivateKey);
        classes->absolute = to->absolute;
        to->absolute      = NULL;
d708 5
d715 29
a750 1
 *   IS_REPEAT .. event is a repeat event.
a753 1
#define IS_REPEAT 2
d755 1
a755 1
UpdateDeviceState(DeviceIntPtr device, xEvent* xE, int count)
d759 2
a760 1
        bit = 0;
a764 1
    deviceValuator *xV  = (deviceValuator *) xE;
a765 2
    CARD16 modifiers    = 0,
           mask         = 0;
d767 21
a787 3
    /* currently no other generic event modifies the device */
    if (xE->u.u.type == GenericEvent)
        return DEFAULT;
d793 2
d796 4
a799 1
    if (xE->u.u.type != DeviceValuator)
d801 15
a815 2
        key = xE->u.u.detail;
        bit = 1 << (key & 7);
d818 8
a825 60
    /* Update device axis */
    /* Don't update valuators for the VCP, it never sends XI events anyway */
    for (i = 1; !device->isMaster && i < count; i++) {
	if ((++xV)->type == DeviceValuator) {
	    int *axisvals;
            int first = xV->first_valuator;
            BOOL change = FALSE;


	    if (xV->num_valuators &&
                (!v || (xV->num_valuators &&
                      (first + xV->num_valuators > v->numAxes))))
		FatalError("Bad valuators reported for device %s\n",
			   device->name);
	    if (v && v->axisVal) {
                /* v->axisVal is always in absolute coordinates. Only the
                 * delivery mode changes.
                 * If device is mode Absolute
                 *     dev = event
                 * If device is mode Relative
                 *      swap = (event - device)
                 *      dev = event
                 *      event = delta
                 */
                int delta;
                axisvals = v->axisVal;
                if (v->mode == Relative) /* device reports relative */
                    change = TRUE;

                switch (xV->num_valuators) {
                    case 6:
                        if (change) delta = xV->valuator5 - *(axisvals + first + 5);
                        *(axisvals + first + 5) = xV->valuator5;
                        if (change) xV->valuator5 = delta;
                    case 5:
                        if (change) delta = xV->valuator4 - *(axisvals + first + 4);
                        *(axisvals + first + 4) = xV->valuator4;
                        if (change) xV->valuator4 = delta;
                    case 4:
                        if (change) delta = xV->valuator3 - *(axisvals + first + 3);
                        *(axisvals + first + 3) = xV->valuator3;
                        if (change) xV->valuator3 = delta;
                    case 3:
                        if (change) delta = xV->valuator2 - *(axisvals + first + 2);
                        *(axisvals + first + 2) = xV->valuator2;
                        if (change) xV->valuator2 = delta;
                    case 2:
                        if (change) delta = xV->valuator1 - *(axisvals + first + 1);
                        *(axisvals + first + 1) = xV->valuator1;
                        if (change) xV->valuator1 = delta;
                    case 1:
                        if (change) delta = xV->valuator0 - *(axisvals + first);
                        *(axisvals + first) = xV->valuator0;
                        if (change) xV->valuator0 = delta;
                    case 0:
                    default:
                        break;
                }
	    }
	}
d828 1
a828 1
    if (xE->u.u.type == DeviceKeyPress) {
a831 1
	modifiers = k->modifierMap[key];
d833 3
a835 3
	if (*kptr & bit) {	/* allow ddx to generate multiple downs */
	    return IS_REPEAT;
	}
d839 1
a839 10
	k->prev_state = k->state;
	for (i = 0, mask = 1; modifiers; i++, mask <<= 1) {
	    if (mask & modifiers) {
		/* This key affects modifier "i" */
		k->modifierKeyCount[i]++;
		k->state |= mask;
		modifiers &= ~mask;
	    }
	}
    } else if (xE->u.u.type == DeviceKeyRelease) {
a845 1
	modifiers = k->modifierMap[key];
d849 2
a850 12
	k->prev_state = k->state;
	for (i = 0, mask = 1; modifiers; i++, mask <<= 1) {
	    if (mask & modifiers) {
		/* This key affects modifier "i" */
		if (--k->modifierKeyCount[i] <= 0) {
		    k->modifierKeyCount[i] = 0;
		    k->state &= ~mask;
		}
		modifiers &= ~mask;
	    }
	}
    } else if (xE->u.u.type == DeviceButtonPress) {
d866 8
a873 2
	SetMaskForEvent(device->id, Motion_Filter(b), DeviceMotionNotify);
    } else if (xE->u.u.type == DeviceButtonRelease) {
d880 1
a880 1
        if (device->isMaster) {
d889 3
a891 1
                if (sd->isMaster || sd->u.master != device)
d906 7
a912 2
	SetMaskForEvent(device->id, Motion_Filter(b), DeviceMotionNotify);
    } else if (xE->u.u.type == ProximityIn)
d914 1
a914 1
    else if (xE->u.u.type == ProximityOut)
d920 26
d952 1
a952 1
ProcessOtherEvent(xEventPtr xE, DeviceIntPtr device, int count)
d954 1
a954 3
    int i;
    CARD16 modifiers;
    GrabPtr grab = device->deviceGrab.grab;
a959 1
    deviceValuator *xV  = (deviceValuator *) xE;
d961 1
a961 1
    int state;
d963 13
d992 26
a1017 2
    state = (kbd) ? kbd->key->state : 0;
    state |= (mouse) ? (mouse->button->state) : 0;
d1019 1
a1019 1
    ret = UpdateDeviceState(device, xE, count);
d1027 2
a1028 2
    if (device->isMaster)
        CheckMotion(xE, device);
d1030 19
a1048 5
    if (xE->u.u.type != DeviceValuator && xE->u.u.type != GenericEvent) {
	GetSpritePosition(device, &rootX, &rootY);
	xE->u.keyButtonPointer.rootX = rootX;
	xE->u.keyButtonPointer.rootY = rootY;
	NoticeEventTime(xE);
d1050 3
a1052 1
        xE->u.keyButtonPointer.state = state;
d1054 3
a1056 4
        key = xE->u.u.detail;
    }
    if (DeviceEventCallback) {
	DeviceEventInfoRec eventinfo;
d1058 2
a1059 2
	eventinfo.events = (xEventPtr) xE;
	eventinfo.count = count;
d1063 1
a1063 2
    /* Valuator event handling */
    /* Don't care about valuators for the VCP, it never sends XI events */
d1065 43
a1107 15
    for (i = 1; !device->isMaster && i < count; i++) {
	if ((++xV)->type == DeviceValuator) {
	    int first = xV->first_valuator;
	    if (xV->num_valuators
		&& (!v
		    || (xV->num_valuators
			&& (first + xV->num_valuators > v->numAxes))))
		FatalError("Bad valuators reported for device %s\n",
			   device->name);
	    xV->device_state = 0;
	    if (k)
		xV->device_state |= k->state;
	    if (b)
		xV->device_state |= b->state;
	}
a1109 42
    if (xE->u.u.type == DeviceKeyPress) {
        if (ret == IS_REPEAT) {	/* allow ddx to generate multiple downs */
            modifiers = k->modifierMap[key];
	    if (!modifiers) {
		xE->u.u.type = DeviceKeyRelease;
		ProcessOtherEvent(xE, device, count);
		xE->u.u.type = DeviceKeyPress;
		/* release can have side effects, don't fall through */
		ProcessOtherEvent(xE, device, count);
	    }
	    return;
	}
	if (!grab && CheckDeviceGrabs(device, xE, 0, count)) {
	    device->deviceGrab.activatingKey = key;
	    return;
	}
    } else if (xE->u.u.type == DeviceKeyRelease) {
	if (device->deviceGrab.fromPassiveGrab &&
            (key == device->deviceGrab.activatingKey))
	    deactivateDeviceGrab = TRUE;
    } else if (xE->u.u.type == DeviceButtonPress) {
	xE->u.u.detail = b->map[key];
	if (xE->u.u.detail == 0) {
	    xE->u.u.detail = key;
	    return;
	}
        if (!grab && CheckDeviceGrabs(device, xE, 0, count))
        {
            /* if a passive grab was activated, the event has been sent
             * already */
            return;
        }

    } else if (xE->u.u.type == DeviceButtonRelease) {
	xE->u.u.detail = b->map[key];
	if (xE->u.u.detail == 0) {
	    xE->u.u.detail = key;
	    return;
	}
        if (!b->buttonsDown && device->deviceGrab.fromPassiveGrab)
            deactivateDeviceGrab = TRUE;
    }
d1112 4
a1115 3
        DeliverGrabbedEvent(xE, device, deactivateDeviceGrab, count);
    else if (device->focus && !IsPointerEvent(xE))
	DeliverFocusedEvent(device, xE, GetSpriteWindow(device), count);
d1117 2
a1118 2
	DeliverDeviceEvents(GetSpriteWindow(device), xE, NullGrab, NullWindow,
			    device, count);
d1122 1
a1122 1
    xE->u.u.detail = key;
d1125 1
a1125 1
_X_EXPORT int
d1133 1
d1147 2
a1148 2
_X_EXPORT void
InitValuatorAxisStruct(DeviceIntPtr dev, int axnum, int minval, int maxval,
d1155 2
d1165 1
d1186 2
a1187 1
	ev->num_keys = k->curKeySyms.maxKeyCode - k->curKeySyms.minKeyCode;
d1235 43
d1279 4
a1282 4
    if (type == FocusIn)
	type = DeviceFocusIn;
    else
	type = DeviceFocusOut;
d1284 1
d1287 1
a1287 1
    event.type = type;
d1292 2
a1293 2
    (void)DeliverEventsToWindow(dev, pWin, (xEvent *) & event, 1,
				DeviceFocusChangeMask, NullGrab, dev->id);
d1315 2
a1316 1
	    nkeys = k->curKeySyms.maxKeyCode - k->curKeySyms.minKeyCode;
d1389 2
a1390 2
	(void)DeliverEventsToWindow(dev, pWin, (xEvent *) sev, evcount,
				    DeviceStateNotifyMask, NullGrab, dev->id);
d1396 1
a1396 4
GrabButton(ClientPtr client, DeviceIntPtr dev, BYTE this_device_mode,
	   BYTE other_devices_mode, CARD16 modifiers,
	   DeviceIntPtr modifier_device, CARD8 button, Window grabWindow,
	   BOOL ownerEvents, Cursor rcursor, Window rconfineTo, Mask eventMask)
d1398 7
a1404 5
    WindowPtr pWin, confineTo;
    CursorPtr cursor;
    GrabPtr grab;
    Mask access_mode = DixGrabAccess;
    int rc;
d1406 3
a1408 3
    if ((this_device_mode != GrabModeSync) &&
	(this_device_mode != GrabModeAsync)) {
	client->errorValue = this_device_mode;
d1411 3
a1413 3
    if ((other_devices_mode != GrabModeSync) &&
	(other_devices_mode != GrabModeAsync)) {
	client->errorValue = other_devices_mode;
d1416 4
a1419 2
    if ((modifiers != AnyModifier) && (modifiers & ~AllModifiersMask)) {
	client->errorValue = modifiers;
d1422 3
a1424 2
    if ((ownerEvents != xFalse) && (ownerEvents != xTrue)) {
	client->errorValue = ownerEvents;
d1427 15
a1441 1
    rc = dixLookupWindow(&pWin, grabWindow, client, DixSetAttrAccess);
d1444 1
a1444 1
    if (rconfineTo == None)
d1447 1
a1447 1
	rc = dixLookupWindow(&confineTo, rconfineTo, client, DixSetAttrAccess);
d1451 1
a1451 1
    if (rcursor == None)
d1454 2
a1455 2
	rc = dixLookupResourceByType((pointer *)&cursor, rcursor, RT_CURSOR,
			       client, DixUseAccess);
d1458 1
a1458 1
	    client->errorValue = rcursor;
d1463 1
a1463 1
    if (this_device_mode == GrabModeSync || other_devices_mode == GrabModeSync)
d1468 8
d1477 2
a1478 4
    grab = CreateGrab(client->index, dev, pWin, eventMask,
		      (Bool) ownerEvents, (Bool) this_device_mode,
		      (Bool) other_devices_mode, modifier_device, modifiers,
		      DeviceButtonPress, button, confineTo, cursor);
d1484 4
d1489 2
a1490 4
GrabKey(ClientPtr client, DeviceIntPtr dev, BYTE this_device_mode,
	BYTE other_devices_mode, CARD16 modifiers,
	DeviceIntPtr modifier_device, CARD8 key, Window grabWindow,
	BOOL ownerEvents, Mask mask)
d1496 1
a1496 1
    int rc;
d1498 3
d1503 13
a1515 24
    if ((other_devices_mode != GrabModeSync) &&
	(other_devices_mode != GrabModeAsync)) {
	client->errorValue = other_devices_mode;
	return BadValue;
    }
    if ((this_device_mode != GrabModeSync) &&
	(this_device_mode != GrabModeAsync)) {
	client->errorValue = this_device_mode;
	return BadValue;
    }
    if (((key > k->curKeySyms.maxKeyCode) || (key < k->curKeySyms.minKeyCode))
	&& (key != AnyKey)) {
	client->errorValue = key;
	return BadValue;
    }
    if ((modifiers != AnyModifier) && (modifiers & ~AllModifiersMask)) {
	client->errorValue = modifiers;
	return BadValue;
    }
    if ((ownerEvents != xTrue) && (ownerEvents != xFalse)) {
	client->errorValue = ownerEvents;
	return BadValue;
    }
    rc = dixLookupWindow(&pWin, grabWindow, client, DixSetAttrAccess);
d1518 1
a1518 1
    if (this_device_mode == GrabModeSync || other_devices_mode == GrabModeSync)
d1524 2
a1525 4
    grab = CreateGrab(client->index, dev, pWin,
		      mask, ownerEvents, this_device_mode, other_devices_mode,
		      modifier_device, modifiers, DeviceKeyPress, key,
		      NullWindow, NullCursor);
d1531 46
d1579 1
a1579 1
		Mask mask, Mask exclusivemasks, Mask validmasks)
a1585 4
    if (mask & ~validmasks) {
	client->errorValue = mask;
	return BadValue;
    }
d1673 1
a1673 1
    int i;
d1678 2
d1684 3
d1794 1
a1794 1
	    if (DeliverEventsToWindow(d, pWin, ev, count, mask, NullGrab, d->id))
d1804 1
a1804 1
	(void)(DeliverEventsToWindow(d, pWin, ev, count, mask, NullGrab, d->id));
a1831 105
SetModifierMapping(ClientPtr client, DeviceIntPtr dev, int len, int rlen,
		   int numKeyPerModifier, KeyCode * inputMap, KeyClassPtr * k)
{
    KeyCode *map = NULL;
    int inputMapLen;
    int i;

    *k = dev->key;
    if (*k == NULL)
	return BadMatch;
    if (len != ((numKeyPerModifier << 1) + rlen))
	return BadLength;

    inputMapLen = 8 * numKeyPerModifier;

    /*
     *  Now enforce the restriction that "all of the non-zero keycodes must be
     *  in the range specified by min-keycode and max-keycode in the
     *  connection setup (else a Value error)"
     */
    i = inputMapLen;
    while (i--) {
	if (inputMap[i]
	    && (inputMap[i] < (*k)->curKeySyms.minKeyCode
		|| inputMap[i] > (*k)->curKeySyms.maxKeyCode)) {
	    client->errorValue = inputMap[i];
	    return -1;	/* BadValue collides with MappingFailed */
	}
    }

    /*
     *  Now enforce the restriction that none of the old or new
     *  modifier keys may be down while we change the mapping,  and
     *  that the DDX layer likes the choice.
     */
    if (!AllModifierKeysAreUp(dev, (*k)->modifierKeyMap,
			      (int)(*k)->maxKeysPerModifier, inputMap,
			      (int)numKeyPerModifier)
	|| !AllModifierKeysAreUp(dev, inputMap, (int)numKeyPerModifier,
				 (*k)->modifierKeyMap,
				 (int)(*k)->maxKeysPerModifier)) {
	return MappingBusy;
    } else {
	for (i = 0; i < inputMapLen; i++) {
	    if (inputMap[i] && !LegalModifier(inputMap[i], dev)) {
		return MappingFailed;
	    }
	}
    }

    /*
     *  Now build the keyboard's modifier bitmap from the
     *  list of keycodes.
     */
    if (inputMapLen) {
	map = (KeyCode *) xalloc(inputMapLen);
	if (!map)
	    return BadAlloc;
    }
    if ((*k)->modifierKeyMap)
	xfree((*k)->modifierKeyMap);
    if (inputMapLen) {
	(*k)->modifierKeyMap = map;
	memmove((char *)(*k)->modifierKeyMap, (char *)inputMap, inputMapLen);
    } else
	(*k)->modifierKeyMap = NULL;

    (*k)->maxKeysPerModifier = numKeyPerModifier;
    for (i = 0; i < MAP_LENGTH; i++)
	(*k)->modifierMap[i] = 0;
    for (i = 0; i < inputMapLen; i++)
	if (inputMap[i]) {
	    (*k)->modifierMap[inputMap[i]]
		|= (1 << (i / (*k)->maxKeysPerModifier));
	}

    return (MappingSuccess);
}

void
SendDeviceMappingNotify(ClientPtr client, CARD8 request,
			KeyCode firstKeyCode, CARD8 count, DeviceIntPtr dev)
{
    xEvent event;
    deviceMappingNotify *ev = (deviceMappingNotify *) & event;

    ev->type = DeviceMappingNotify;
    ev->request = request;
    ev->deviceid = dev->id;
    ev->time = currentTime.milliseconds;
    if (request == MappingKeyboard) {
	ev->firstKeyCode = firstKeyCode;
	ev->count = count;
    }

#ifdef XKB
    if (!noXkbExtension && (request == MappingKeyboard ||
                            request == MappingModifier))
        XkbApplyMappingChange(dev, request, firstKeyCode, count, client);
#endif

    SendEventToAllWindows(dev, DeviceMappingNotifyMask, (xEvent *) ev, 1);
}

int
d1848 2
a1849 2
    if ((firstKeyCode < k->curKeySyms.minKeyCode) ||
	(firstKeyCode + keyCodes - 1 > k->curKeySyms.maxKeyCode)) {
d1861 4
a1864 3
    if (!SetKeySymsMap(&k->curKeySyms, &keysyms))
	return BadAlloc;
    SendDeviceMappingNotify(client, MappingKeyboard, firstKeyCode, keyCodes, dev);
d1893 2
a1894 1
	    DoFocusEvents(dev, pWin, NoneWin, focusEventMode);
d1905 2
a1906 1
	    DoFocusEvents(dev, pWin, parent, focusEventMode);
d1911 2
a1912 1
	    DoFocusEvents(dev, pWin, PointerRootWin, focusEventMode);
d1917 7
a1923 3
	    if (inputInfo.keyboard->focus->win) {
		DoFocusEvents(dev, pWin, inputInfo.keyboard->focus->win,
			      focusEventMode);
d1927 2
a1928 1
		DoFocusEvents(dev, pWin, NoneWin, focusEventMode);
d1932 1
a1950 2
	if (dev == inputInfo.pointer || dev == inputInfo.keyboard)
	    continue;
d1997 1
a1997 1
		    DixReadAccess);
a2016 1
        tempGrab.genericMasks = NULL;
d2115 1
a2115 1
        (void)DeliverEventsToWindow(dev, p1, ev, count, mask, NullGrab, dev->id);
d2137 1
a2137 1
        (void)DeliverEventsToWindow(dev, pWin, ev, count, mask, NullGrab, dev->id);
d2143 47
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d64 1
d75 1
d79 1
d81 1
d93 1
a93 1
static Bool ShouldFreeInputMasks(WindowPtr /* pWin */ ,
d99 3
a101 5
/**************************************************************************
 *
 * Procedures for extension device event routing.
 *
 */
a107 2
    (device)->ActivateGrab = ActivateKeyboardGrab;
    (device)->DeactivateGrab = DeactivateKeyboardGrab;
d110 81
a190 2
 /*ARGSUSED*/ void
ProcessOtherEvent(xEventPtr xE, DeviceIntPtr other, int count)
d192 3
a194 1
    BYTE *kptr;
a195 9
    CARD16 modifiers;
    CARD16 mask;
    GrabPtr grab = other->grab;
    Bool deactivateDeviceGrab = FALSE;
    int key = 0, bit = 0, rootX, rootY;
    ButtonClassPtr b = other->button;
    KeyClassPtr k = other->key;
    ValuatorClassPtr v = other->valuator;
    deviceValuator *xV = (deviceValuator *) xE;
d197 541
a737 9
    if (xE->u.u.type != DeviceValuator) {
	GetSpritePosition(&rootX, &rootY);
	xE->u.keyButtonPointer.rootX = rootX;
	xE->u.keyButtonPointer.rootY = rootY;
	key = xE->u.u.detail;
	NoticeEventTime(xE);
	xE->u.keyButtonPointer.state = inputInfo.keyboard->key->state |
	    inputInfo.pointer->button->state;
	bit = 1 << (key & 7);
d739 37
a775 2
    if (DeviceEventCallback) {
	DeviceEventInfoRec eventinfo;
d777 4
a780 3
	eventinfo.events = (xEventPtr) xE;
	eventinfo.count = count;
	CallCallbacks(&DeviceEventCallback, (pointer) & eventinfo);
d782 4
a785 1
    for (i = 1; i < count; i++)
a786 1
	    int first = xV->first_valuator;
d788 3
d792 3
a794 4
	    if (xV->num_valuators
		&& (!v
		    || (xV->num_valuators
			&& (first + xV->num_valuators > v->numAxes))))
d796 1
a796 6
			   other->name);
	    xV->device_state = 0;
	    if (k)
		xV->device_state |= k->state;
	    if (b)
		xV->device_state |= b->state;
d798 43
a840 18
		axisvals = v->axisVal;
		switch (xV->num_valuators) {
		case 6:
		    *(axisvals + first + 5) = xV->valuator5;
		case 5:
		    *(axisvals + first + 4) = xV->valuator4;
		case 4:
		    *(axisvals + first + 3) = xV->valuator3;
		case 3:
		    *(axisvals + first + 2) = xV->valuator2;
		case 2:
		    *(axisvals + first + 1) = xV->valuator1;
		case 1:
		    *(axisvals + first) = xV->valuator0;
		case 0:
		default:
		    break;
		}
d843 1
d847 1
a847 1
            return;
d852 1
a852 8
	    if (!modifiers) {
		xE->u.u.type = DeviceKeyRelease;
		ProcessOtherEvent(xE, other, count);
		xE->u.u.type = DeviceKeyPress;
		/* release can have side effects, don't fall through */
		ProcessOtherEvent(xE, other, count);
	    }
	    return;
d854 2
a855 2
	if (other->valuator)
	    other->valuator->motionHintWindow = NullWindow;
a865 4
	if (!grab && CheckDeviceGrabs(other, xE, 0, count)) {
	    other->activatingKey = key;
	    return;
	}
d868 1
a868 1
            return;
d872 1
a872 1
	    return;
d874 2
a875 2
	if (other->valuator)
	    other->valuator->motionHintWindow = NullWindow;
a887 3

	if (other->fromPassiveGrab && (key == other->activatingKey))
	    deactivateDeviceGrab = TRUE;
d890 1
a890 1
            return;
d892 9
a900 5
	kptr = &b->down[key >> 3];
	*kptr |= bit;
	if (other->valuator)
	    other->valuator->motionHintWindow = NullWindow;
	b->buttonsDown++;
d902 3
a904 12
	xE->u.u.detail = key;
	if (xE->u.u.detail == 0)
	    return;
	if (xE->u.u.detail <= 5)
	    b->state |= (Button1Mask >> 1) << xE->u.u.detail;
	SetMaskForEvent(Motion_Filter(b), DeviceMotionNotify);
	if (!grab)
	    if (CheckDeviceGrabs(other, xE, 0, count))
                /* if a passive grab was activated, the event has been sent
                 * already */
                return;

d907 1
a907 1
            return;
d909 23
a931 4
	kptr = &b->down[key >> 3];
	*kptr &= ~bit;
	if (other->valuator)
	    other->valuator->motionHintWindow = NullWindow;
d934 113
a1046 2
	xE->u.u.detail = key;
	if (xE->u.u.detail == 0)
d1048 4
a1051 4
	if (xE->u.u.detail <= 5)
	    b->state &= ~((Button1Mask >> 1) << xE->u.u.detail);
	SetMaskForEvent(Motion_Filter(b), DeviceMotionNotify);
	if (!b->state && other->fromPassiveGrab)
d1053 22
a1074 4
    } else if (xE->u.u.type == ProximityIn)
	other->valuator->mode &= ~OutOfProximity;
    else if (xE->u.u.type == ProximityOut)
	other->valuator->mode |= OutOfProximity;
d1077 3
a1079 3
	DeliverGrabbedEvent(xE, other, deactivateDeviceGrab, count);
    else if (other->focus)
	DeliverFocusedEvent(other, xE, GetSpriteWindow(), count);
d1081 2
a1082 2
	DeliverDeviceEvents(GetSpriteWindow(), xE, NullGrab, NullWindow,
			    other, count);
d1085 2
a1086 1
	(*other->DeactivateGrab) (other);
d1101 9
d1115 2
a1116 2
   
    if (!dev || !dev->valuator)
d1143 1
a1143 1
	memmove((char *)&ev->buttons[0], (char *)b->down, 4);
d1207 1
a1207 1
    (void)DeliverEventsToWindow(pWin, (xEvent *) & event, 1,
d1262 1
a1262 1
		memmove((char *)&bev->buttons[0], (char *)&b->down[4], 28);
d1303 1
a1303 1
	(void)DeliverEventsToWindow(pWin, (xEvent *) sev, evcount,
d1352 1
a1352 1
	rc = dixLookupResource((pointer *)&cursor, rcursor, RT_CURSOR,
d1486 1
a1486 1
	    !(check & DevicePointerMotionHintMask) && !dev->grab)
d1499 1
a1499 1
    others = (InputClients *) xalloc(sizeof(InputClients));
a1503 1
    bzero((char *)&others->mask[0], sizeof(Mask) * EMASKSIZE);
d1518 1
a1518 2
    imasks = (struct _OtherInputMasks *)
	xalloc(sizeof(struct _OtherInputMasks));
a1520 1
    bzero((char *)imasks, sizeof(struct _OtherInputMasks));
d1608 1
a1608 1
    WindowPtr spriteWin = GetSpriteWindow();
d1629 1
a1629 1
	    inputFocus = GetCurrentRootWindow();
d1647 1
a1647 1
	    if (DeliverEventsToWindow(pWin, ev, count, mask, NullGrab, d->id))
d1657 1
a1657 1
	(void)(DeliverEventsToWindow(pWin, ev, count, mask, NullGrab, d->id));
d1781 2
a1782 1
    if (request == MappingKeyboard || request == MappingModifier)
d1834 2
a1835 2
    if (dev->grab && (dev->grab->window == pWin))
	(*dev->DeactivateGrab) (dev);
d1837 1
a1837 1
    /* If the focus window is a root window (ie. has no parent) 
d1845 1
a1845 1
	if (dev->grab)
d1967 3
a1969 1
	(*dev->ActivateGrab) (dev, &tempGrab, currentTime, TRUE);
d1992 1
a1992 1
    GrabPtr grab = dev->grab;
d2033 1
a2033 1
static Bool
d2066 1
a2066 1
        (void)DeliverEventsToWindow(p1, ev, count, mask, NullGrab, dev->id);
d2088 1
a2088 1
        (void)DeliverEventsToWindow(pWin, ev, count, mask, NullGrab, dev->id);
d2093 1
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@a69 1
#include "extinit.h"	/* LookupDeviceIntRec */
d74 1
d126 3
a128 8
        /* Other types already have root{X,Y} filled in. */
        if (xE->u.u.type == DeviceKeyPress ||
            xE->u.u.type == DeviceKeyRelease) {
	    GetSpritePosition(&rootX, &rootY);
	    xE->u.keyButtonPointer.rootX = rootX;
	    xE->u.keyButtonPointer.rootY = rootY;
        }

d514 1
d535 1
a535 1
    rc = dixLookupWindow(&pWin, grabWindow, client, DixUnknownAccess);
d541 1
a541 1
	rc = dixLookupWindow(&confineTo, rconfineTo, client, DixUnknownAccess);
d548 4
a551 2
	cursor = (CursorPtr) LookupIDByType(rcursor, RT_CURSOR);
	if (!cursor) {
d553 1
a553 1
	    return BadCursor;
d555 1
d557 5
d569 1
a569 1
    return AddPassiveGrabToList(grab);
d581 1
d609 6
a614 1
    rc = dixLookupWindow(&pWin, grabWindow, client, DixUnknownAccess);
d624 1
a624 1
    return AddPassiveGrabToList(grab);
d836 1
a836 1
	dixLookupWindow(&pWin, dest, client, DixUnknownAccess);
d855 1
a855 1
    } else
d1119 2
a1120 1
    dev = LookupDeviceIntRec(pEvents->deviceid & DEVICE_BITS);
d1144 2
a1145 1
    dev = LookupDeviceIntRec(xE->deviceid & DEVICE_BITS);
d1282 2
@


1.1
log
@Initial revision
@
text
@d74 1
d76 3
a78 1
#include "chgptr.h"
d111 1
a111 1
ProcessOtherEvent(xEventPtr xE, register DeviceIntPtr other, int count)
d113 4
a116 4
    register BYTE *kptr;
    register int i;
    register CARD16 modifiers;
    register CARD16 mask;
d126 8
a133 3
	GetSpritePosition(&rootX, &rootY);
	xE->u.keyButtonPointer.rootX = rootX;
	xE->u.keyButtonPointer.rootY = rootY;
d252 1
a252 1
	xE->u.u.detail = b->map[key];
d260 3
a262 1
		return;
d272 1
a272 1
	if (!--b->buttonsDown)
d274 1
a274 1
	xE->u.u.detail = b->map[key];
d302 1
a302 1
    register ProximityClassPtr proxc;
d315 6
a320 1
    register AxisInfoPtr ax = dev->valuator->axes + axnum;
d392 1
a392 1
		 register WindowPtr pWin)
d519 1
d539 3
a541 3
    pWin = LookupWindow(grabWindow, client);
    if (!pWin)
	return BadWindow;
d545 3
a547 3
	confineTo = LookupWindow(rconfineTo, client);
	if (!confineTo)
	    return BadWindow;
d577 1
d604 3
a606 3
    pWin = LookupWindow(grabWindow, client);
    if (!pWin)
	return BadWindow;
d717 1
a717 1
    register InputClientsPtr others;
d719 1
a719 1
    register WindowPtr pChild, tmp;
d753 1
a753 1
InputClientGone(register WindowPtr pWin, XID id)
d755 1
a755 1
    register InputClientsPtr other, prev;
d826 1
a826 1
	pWin = LookupWindow(dest, client);
d853 1
a853 1
    register int i;
d879 1
a879 1
    register int i;
d918 1
a918 1
	    if (inputMap[i] && !LegalModifier(inputMap[i], (DevicePtr) dev)) {
d954 1
a954 1
SendDeviceMappingNotify(CARD8 request,
d969 5
d1009 1
a1009 1
    SendDeviceMappingNotify(MappingKeyboard, firstKeyCode, keyCodes, dev);
d1013 1
a1013 27
void
DeleteWindowFromAnyExtEvents(WindowPtr pWin, Bool freeResources)
{
    int i;
    DeviceIntPtr dev;
    InputClientsPtr ic;
    struct _OtherInputMasks *inputMasks;

    for (dev = inputInfo.devices; dev; dev = dev->next) {
	if (dev == inputInfo.pointer || dev == inputInfo.keyboard)
	    continue;
	DeleteDeviceFromAnyExtEvents(pWin, dev);
    }

    for (dev = inputInfo.off_devices; dev; dev = dev->next)
	DeleteDeviceFromAnyExtEvents(pWin, dev);

    if (freeResources)
	while ((inputMasks = wOtherInputMasks(pWin)) != 0) {
	    ic = inputMasks->inputClients;
	    for (i = 0; i < EMASKSIZE; i++)
		inputMasks->dontPropagateMask[i] = 0;
	    FreeResource(ic->resource, RT_NONE);
	}
}

void
d1078 26
d1157 1
a1157 1
Mask
d1160 1
a1160 1
    register InputClientsPtr other;
d1173 1
a1173 1
MaybeStopDeviceHint(register DeviceIntPtr dev, ClientPtr client)
d1233 41
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d74 2
a75 1
#include "scrnintstr.h"
d108 1
a108 1
ProcessOtherEvent(xEventPtr xE, DeviceIntPtr other, int count)
d110 4
a113 4
    BYTE *kptr;
    int i;
    CARD16 modifiers;
    CARD16 mask;
d252 1
a252 3
                /* if a passive grab was activated, the event has been sent
                 * already */
                return;
d262 1
a262 1
        if (b->buttonsDown >= 1 && !--b->buttonsDown)
d292 1
a292 1
    ProximityClassPtr proxc;
d305 1
a305 6
    AxisInfoPtr ax;
   
    if (!dev || !dev->valuator)
        return;

    ax = dev->valuator->axes + axnum;
d377 1
a377 1
		 WindowPtr pWin)
a503 1
    int rc;
d523 3
a525 3
    rc = dixLookupWindow(&pWin, grabWindow, client, DixUnknownAccess);
    if (rc != Success)
	return rc;
d529 3
a531 3
	rc = dixLookupWindow(&confineTo, rconfineTo, client, DixUnknownAccess);
	if (rc != Success)
	    return rc;
a560 1
    int rc;
d587 3
a589 3
    rc = dixLookupWindow(&pWin, grabWindow, client, DixUnknownAccess);
    if (rc != Success)
	return rc;
d700 1
a700 1
    InputClientsPtr others;
d702 1
a702 1
    WindowPtr pChild, tmp;
d736 1
a736 1
InputClientGone(WindowPtr pWin, XID id)
d738 1
a738 1
    InputClientsPtr other, prev;
d809 1
a809 1
	dixLookupWindow(&pWin, dest, client, DixUnknownAccess);
d836 1
a836 1
    int i;
d862 1
a862 1
    int i;
d901 1
a901 1
	    if (inputMap[i] && !LegalModifier(inputMap[i], dev)) {
d991 27
a1017 1
static void
a1081 26
void
DeleteWindowFromAnyExtEvents(WindowPtr pWin, Bool freeResources)
{
    int i;
    DeviceIntPtr dev;
    InputClientsPtr ic;
    struct _OtherInputMasks *inputMasks;

    for (dev = inputInfo.devices; dev; dev = dev->next) {
	if (dev == inputInfo.pointer || dev == inputInfo.keyboard)
	    continue;
	DeleteDeviceFromAnyExtEvents(pWin, dev);
    }

    for (dev = inputInfo.off_devices; dev; dev = dev->next)
	DeleteDeviceFromAnyExtEvents(pWin, dev);

    if (freeResources)
	while ((inputMasks = wOtherInputMasks(pWin)) != 0) {
	    ic = inputMasks->inputClients;
	    for (i = 0; i < EMASKSIZE; i++)
		inputMasks->dontPropagateMask[i] = 0;
	    FreeResource(ic->resource, RT_NONE);
	}
}

d1135 1
a1135 1
static Mask
d1138 1
a1138 1
    InputClientsPtr other;
d1151 1
a1151 1
MaybeStopDeviceHint(DeviceIntPtr dev, ClientPtr client)
a1210 41
}

/***********************************************************************
 *
 * Walk through the window tree, finding all clients that want to know
 * about the Event.
 *
 */

static void
FindInterestedChildren(DeviceIntPtr dev, WindowPtr p1, Mask mask,
                       xEvent * ev, int count)
{
    WindowPtr p2;

    while (p1) {
        p2 = p1->firstChild;
        (void)DeliverEventsToWindow(p1, ev, count, mask, NullGrab, dev->id);
        FindInterestedChildren(dev, p2, mask, ev, count);
        p1 = p1->nextSib;
    }
}

/***********************************************************************
 *
 * Send an event to interested clients in all windows on all screens.
 *
 */

void
SendEventToAllWindows(DeviceIntPtr dev, Mask mask, xEvent * ev, int count)
{
    int i;
    WindowPtr pWin, p1;

    for (i = 0; i < screenInfo.numScreens; i++) {
        pWin = WindowTable[i];
        (void)DeliverEventsToWindow(pWin, ev, count, mask, NullGrab, dev->id);
        p1 = pWin->firstChild;
        FindInterestedChildren(dev, p1, mask, ev, count);
    }
@


1.1.1.3
log
@xserver 1.4.0.90
@
text
@a75 4
#ifdef XKB
#include "xkbsrv.h"
#endif

d243 1
a243 1
	xE->u.u.detail = key;
d265 1
a265 1
	xE->u.u.detail = key;
d945 1
a945 1
SendDeviceMappingNotify(ClientPtr client, CARD8 request,
a959 5
#ifdef XKB
    if (request == MappingKeyboard || request == MappingModifier)
        XkbApplyMappingChange(dev, request, firstKeyCode, count, client);
#endif

d995 1
a995 1
    SendDeviceMappingNotify(client, MappingKeyboard, firstKeyCode, keyCodes, dev);
@


