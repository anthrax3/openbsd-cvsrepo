head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	vcnjRBuLQw44cPHf;

1.7
date	2014.05.02.19.27.46;	author matthieu;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.01.31.07.52.35;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	;

1.6.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.7.2.1
date	2014.12.09.17.59.32;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 2007-2008 Peter Hutterer
 * Copyright 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Peter Hutterer, University of South Australia, NICTA
 */

/***********************************************************************
 *
 * Request change in the device hierarchy.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>              /* for inputstr.h    */
#include <X11/Xproto.h>         /* Request macro     */
#include "inputstr.h"           /* DeviceIntPtr      */
#include "windowstr.h"          /* window structure  */
#include "scrnintstr.h"         /* screen structure  */
#include <X11/extensions/XI.h>
#include <X11/extensions/XI2proto.h>
#include <X11/extensions/geproto.h>
#include "extnsionst.h"
#include "exevents.h"
#include "exglobals.h"
#include "geext.h"
#include "xace.h"
#include "xiquerydevice.h"      /* for GetDeviceUse */

#include "xkbsrv.h"

#include "xichangehierarchy.h"
#include "xibarriers.h"

/**
 * Send the current state of the device hierarchy to all clients.
 */
void
XISendDeviceHierarchyEvent(int flags[MAXDEVICES])
{
    xXIHierarchyEvent *ev;
    xXIHierarchyInfo *info;
    DeviceIntRec dummyDev;
    DeviceIntPtr dev;
    int i;

    if (!flags)
        return;

    ev = calloc(1, sizeof(xXIHierarchyEvent) +
                MAXDEVICES * sizeof(xXIHierarchyInfo));
    if (!ev)
        return;
    ev->type = GenericEvent;
    ev->extension = IReqCode;
    ev->evtype = XI_HierarchyChanged;
    ev->time = GetTimeInMillis();
    ev->flags = 0;
    ev->num_info = inputInfo.numDevices;

    info = (xXIHierarchyInfo *) &ev[1];
    for (dev = inputInfo.devices; dev; dev = dev->next) {
        info->deviceid = dev->id;
        info->enabled = dev->enabled;
        info->use = GetDeviceUse(dev, &info->attachment);
        info->flags = flags[dev->id];
        ev->flags |= info->flags;
        info++;
    }
    for (dev = inputInfo.off_devices; dev; dev = dev->next) {
        info->deviceid = dev->id;
        info->enabled = dev->enabled;
        info->use = GetDeviceUse(dev, &info->attachment);
        info->flags = flags[dev->id];
        ev->flags |= info->flags;
        info++;
    }

    for (i = 0; i < MAXDEVICES; i++) {
        if (flags[i] & (XIMasterRemoved | XISlaveRemoved)) {
            info->deviceid = i;
            info->enabled = FALSE;
            info->flags = flags[i];
            info->use = 0;
            ev->flags |= info->flags;
            ev->num_info++;
            info++;
        }
    }

    ev->length = bytes_to_int32(ev->num_info * sizeof(xXIHierarchyInfo));

    memset(&dummyDev, 0, sizeof(dummyDev));
    dummyDev.id = XIAllDevices;
    dummyDev.type = SLAVE;
    SendEventToAllWindows(&dummyDev, (XI_HierarchyChangedMask >> 8),
                          (xEvent *) ev, 1);
    free(ev);
}

/***********************************************************************
 *
 * This procedure allows a client to change the device hierarchy through
 * adding new master devices, removing them, etc.
 *
 */

int
SProcXIChangeHierarchy(ClientPtr client)
{
    REQUEST(xXIChangeHierarchyReq);
    swaps(&stuff->length);
    return (ProcXIChangeHierarchy(client));
}

static int
add_master(ClientPtr client, xXIAddMasterInfo * c, int flags[MAXDEVICES])
{
    DeviceIntPtr ptr, keybd, XTestptr, XTestkeybd;
    char *name;
    int rc;

    name = calloc(c->name_len + 1, sizeof(char));
    if (name == NULL) {
        rc = BadAlloc;
        goto unwind;
    }
    strncpy(name, (char *) &c[1], c->name_len);

    rc = AllocDevicePair(client, name, &ptr, &keybd,
                         CorePointerProc, CoreKeyboardProc, TRUE);
    if (rc != Success)
        goto unwind;

    if (!c->send_core)
        ptr->coreEvents = keybd->coreEvents = FALSE;

    /* Allocate virtual slave devices for xtest events */
    rc = AllocXTestDevice(client, name, &XTestptr, &XTestkeybd, ptr, keybd);
    if (rc != Success) {
        DeleteInputDeviceRequest(ptr);
        DeleteInputDeviceRequest(keybd);
        goto unwind;
    }

    ActivateDevice(ptr, FALSE);
    ActivateDevice(keybd, FALSE);
    flags[ptr->id] |= XIMasterAdded;
    flags[keybd->id] |= XIMasterAdded;

    ActivateDevice(XTestptr, FALSE);
    ActivateDevice(XTestkeybd, FALSE);
    flags[XTestptr->id] |= XISlaveAdded;
    flags[XTestkeybd->id] |= XISlaveAdded;

    if (c->enable) {
        EnableDevice(ptr, FALSE);
        EnableDevice(keybd, FALSE);
        flags[ptr->id] |= XIDeviceEnabled;
        flags[keybd->id] |= XIDeviceEnabled;

        EnableDevice(XTestptr, FALSE);
        EnableDevice(XTestkeybd, FALSE);
        flags[XTestptr->id] |= XIDeviceEnabled;
        flags[XTestkeybd->id] |= XIDeviceEnabled;
    }

    /* Attach the XTest virtual devices to the newly
       created master device */
    AttachDevice(NULL, XTestptr, ptr);
    AttachDevice(NULL, XTestkeybd, keybd);
    flags[XTestptr->id] |= XISlaveAttached;
    flags[XTestkeybd->id] |= XISlaveAttached;

    XIBarrierNewMasterDevice(client, ptr->id);

 unwind:
    free(name);
    return rc;
}

static void
disable_clientpointer(DeviceIntPtr dev)
{
    int i;

    for (i = 0; i < currentMaxClients; i++) {
        ClientPtr client = clients[i];

        if (client && client->clientPtr == dev)
            client->clientPtr = NULL;
    }
}

static int
remove_master(ClientPtr client, xXIRemoveMasterInfo * r, int flags[MAXDEVICES])
{
    DeviceIntPtr ptr, keybd, XTestptr, XTestkeybd;
    int rc = Success;

    if (r->return_mode != XIAttachToMaster && r->return_mode != XIFloating)
        return BadValue;

    rc = dixLookupDevice(&ptr, r->deviceid, client, DixDestroyAccess);
    if (rc != Success)
        goto unwind;

    if (!IsMaster(ptr)) {
        client->errorValue = r->deviceid;
        rc = BadDevice;
        goto unwind;
    }

    /* XXX: For now, don't allow removal of VCP, VCK */
    if (ptr == inputInfo.pointer ||ptr == inputInfo.keyboard) {
        rc = BadDevice;
        goto unwind;
    }

    ptr = GetMaster(ptr, MASTER_POINTER);
    rc = dixLookupDevice(&ptr, ptr->id, client, DixDestroyAccess);
    if (rc != Success)
        goto unwind;
    keybd = GetMaster(ptr, MASTER_KEYBOARD);
    rc = dixLookupDevice(&keybd, keybd->id, client, DixDestroyAccess);
    if (rc != Success)
        goto unwind;

    XTestptr = GetXTestDevice(ptr);
    rc = dixLookupDevice(&XTestptr, XTestptr->id, client, DixDestroyAccess);
    if (rc != Success)
        goto unwind;

    XTestkeybd = GetXTestDevice(keybd);
    rc = dixLookupDevice(&XTestkeybd, XTestkeybd->id, client, DixDestroyAccess);
    if (rc != Success)
        goto unwind;

    disable_clientpointer(ptr);

    /* Disabling sends the devices floating, reattach them if
     * desired. */
    if (r->return_mode == XIAttachToMaster) {
        DeviceIntPtr attached, newptr, newkeybd;

        rc = dixLookupDevice(&newptr, r->return_pointer, client, DixAddAccess);
        if (rc != Success)
            goto unwind;

        if (!IsMaster(newptr)) {
            client->errorValue = r->return_pointer;
            rc = BadDevice;
            goto unwind;
        }

        rc = dixLookupDevice(&newkeybd, r->return_keyboard,
                             client, DixAddAccess);
        if (rc != Success)
            goto unwind;

        if (!IsMaster(newkeybd)) {
            client->errorValue = r->return_keyboard;
            rc = BadDevice;
            goto unwind;
        }

        for (attached = inputInfo.devices; attached; attached = attached->next) {
            if (!IsMaster(attached)) {
                if (GetMaster(attached, MASTER_ATTACHED) == ptr) {
                    AttachDevice(client, attached, newptr);
                    flags[attached->id] |= XISlaveAttached;
                }
                if (GetMaster(attached, MASTER_ATTACHED) == keybd) {
                    AttachDevice(client, attached, newkeybd);
                    flags[attached->id] |= XISlaveAttached;
                }
            }
        }
    }

    XIBarrierRemoveMasterDevice(client, ptr->id);

    /* disable the remove the devices, XTest devices must be done first
       else the sprites they rely on will be destroyed  */
    DisableDevice(XTestptr, FALSE);
    DisableDevice(XTestkeybd, FALSE);
    DisableDevice(keybd, FALSE);
    DisableDevice(ptr, FALSE);
    flags[XTestptr->id] |= XIDeviceDisabled | XISlaveDetached;
    flags[XTestkeybd->id] |= XIDeviceDisabled | XISlaveDetached;
    flags[keybd->id] |= XIDeviceDisabled;
    flags[ptr->id] |= XIDeviceDisabled;

    flags[XTestptr->id] |= XISlaveRemoved;
    flags[XTestkeybd->id] |= XISlaveRemoved;
    flags[keybd->id] |= XIMasterRemoved;
    flags[ptr->id] |= XIMasterRemoved;

    RemoveDevice(XTestptr, FALSE);
    RemoveDevice(XTestkeybd, FALSE);
    RemoveDevice(keybd, FALSE);
    RemoveDevice(ptr, FALSE);

 unwind:
    return rc;
}

static int
detach_slave(ClientPtr client, xXIDetachSlaveInfo * c, int flags[MAXDEVICES])
{
    DeviceIntPtr dev;
    int rc;

    rc = dixLookupDevice(&dev, c->deviceid, client, DixManageAccess);
    if (rc != Success)
        goto unwind;

    if (IsMaster(dev)) {
        client->errorValue = c->deviceid;
        rc = BadDevice;
        goto unwind;
    }

    /* Don't allow changes to XTest Devices, these are fixed */
    if (IsXTestDevice(dev, NULL)) {
        client->errorValue = c->deviceid;
        rc = BadDevice;
        goto unwind;
    }

    ReleaseButtonsAndKeys(dev);
    AttachDevice(client, dev, NULL);
    flags[dev->id] |= XISlaveDetached;

 unwind:
    return rc;
}

static int
attach_slave(ClientPtr client, xXIAttachSlaveInfo * c, int flags[MAXDEVICES])
{
    DeviceIntPtr dev;
    DeviceIntPtr newmaster;
    int rc;

    rc = dixLookupDevice(&dev, c->deviceid, client, DixManageAccess);
    if (rc != Success)
        goto unwind;

    if (IsMaster(dev)) {
        client->errorValue = c->deviceid;
        rc = BadDevice;
        goto unwind;
    }

    /* Don't allow changes to XTest Devices, these are fixed */
    if (IsXTestDevice(dev, NULL)) {
        client->errorValue = c->deviceid;
        rc = BadDevice;
        goto unwind;
    }

    rc = dixLookupDevice(&newmaster, c->new_master, client, DixAddAccess);
    if (rc != Success)
        goto unwind;
    if (!IsMaster(newmaster)) {
        client->errorValue = c->new_master;
        rc = BadDevice;
        goto unwind;
    }

    if (!((IsPointerDevice(newmaster) && IsPointerDevice(dev)) ||
          (IsKeyboardDevice(newmaster) && IsKeyboardDevice(dev)))) {
        rc = BadDevice;
        goto unwind;
    }

    ReleaseButtonsAndKeys(dev);
    AttachDevice(client, dev, newmaster);
    flags[dev->id] |= XISlaveAttached;

 unwind:
    return rc;
}

#define SWAPIF(cmd) if (client->swapped) { cmd; }

int
ProcXIChangeHierarchy(ClientPtr client)
{
    xXIAnyHierarchyChangeInfo *any;
    size_t len;			/* length of data remaining in request */
    int rc = Success;
    int flags[MAXDEVICES] = { 0 };

    REQUEST(xXIChangeHierarchyReq);
    REQUEST_AT_LEAST_SIZE(xXIChangeHierarchyReq);

    if (!stuff->num_changes)
        return rc;

    len = ((size_t)stuff->length << 2) - sizeof(xXIAnyHierarchyChangeInfo);

    any = (xXIAnyHierarchyChangeInfo *) &stuff[1];
    while (stuff->num_changes--) {
        if (len < sizeof(xXIAnyHierarchyChangeInfo)) {
            rc = BadLength;
            goto unwind;
        }

        SWAPIF(swaps(&any->type));
        SWAPIF(swaps(&any->length));

        if (len < ((size_t)any->length << 2))
            return BadLength;

#define CHANGE_SIZE_MATCH(type) \
    do { \
        if ((len < sizeof(type)) || (any->length != (sizeof(type) >> 2))) { \
            rc = BadLength; \
            goto unwind; \
        } \
    } while(0)

        switch (any->type) {
        case XIAddMaster:
        {
            xXIAddMasterInfo *c = (xXIAddMasterInfo *) any;

            /* Variable length, due to appended name string */
            if (len < sizeof(xXIAddMasterInfo)) {
                rc = BadLength;
                goto unwind;
            }
            SWAPIF(swaps(&c->name_len));
            if (c->name_len > (len - sizeof(xXIAddMasterInfo))) {
                rc = BadLength;
                goto unwind;
            }

            rc = add_master(client, c, flags);
            if (rc != Success)
                goto unwind;
        }
            break;
        case XIRemoveMaster:
        {
            xXIRemoveMasterInfo *r = (xXIRemoveMasterInfo *) any;

            CHANGE_SIZE_MATCH(xXIRemoveMasterInfo);
            rc = remove_master(client, r, flags);
            if (rc != Success)
                goto unwind;
        }
            break;
        case XIDetachSlave:
        {
            xXIDetachSlaveInfo *c = (xXIDetachSlaveInfo *) any;

            CHANGE_SIZE_MATCH(xXIDetachSlaveInfo);
            rc = detach_slave(client, c, flags);
            if (rc != Success)
                goto unwind;
        }
            break;
        case XIAttachSlave:
        {
            xXIAttachSlaveInfo *c = (xXIAttachSlaveInfo *) any;

            CHANGE_SIZE_MATCH(xXIAttachSlaveInfo);
            rc = attach_slave(client, c, flags);
            if (rc != Success)
                goto unwind;
        }
            break;
        }

        len -= any->length * 4;
        any = (xXIAnyHierarchyChangeInfo *) ((char *) any + any->length * 4);
    }

 unwind:

    XISendDeviceHierarchyEvent(flags);
    return rc;
}
@


1.8
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d424 1
a424 3
    if (stuff->length > (INT_MAX >> 2))
        return BadAlloc;
    len = (stuff->length << 2) - sizeof(xXIAnyHierarchyChangeInfo);
d436 1
a436 1
        if ((any->length > (INT_MAX >> 2)) || (len < (any->length << 2)))
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d414 1
a414 1
    int required_len = sizeof(xXIChangeHierarchyReq);
d424 4
d430 5
d438 1
a438 2
        required_len += any->length;
        if ((stuff->length * 4) < required_len)
d441 8
d454 5
d460 4
d474 1
d484 1
d494 1
d502 1
@


1.7.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d414 1
a414 1
    size_t len;			/* length of data remaining in request */
a423 4
    if (stuff->length > (INT_MAX >> 2))
        return BadAlloc;
    len = (stuff->length << 2) - sizeof(xXIAnyHierarchyChangeInfo);

a425 5
        if (len < sizeof(xXIAnyHierarchyChangeInfo)) {
            rc = BadLength;
            goto unwind;
        }

d429 2
a430 1
        if ((any->length > (INT_MAX >> 2)) || (len < (any->length << 2)))
a432 8
#define CHANGE_SIZE_MATCH(type) \
    do { \
        if ((len < sizeof(type)) || (any->length != (sizeof(type) >> 2))) { \
            rc = BadLength; \
            goto unwind; \
        } \
    } while(0)

a437 5
            /* Variable length, due to appended name string */
            if (len < sizeof(xXIAddMasterInfo)) {
                rc = BadLength;
                goto unwind;
            }
a438 4
            if (c->name_len > (len - sizeof(xXIAddMasterInfo))) {
                rc = BadLength;
                goto unwind;
            }
a448 1
            CHANGE_SIZE_MATCH(xXIRemoveMasterInfo);
a457 1
            CHANGE_SIZE_MATCH(xXIDetachSlaveInfo);
a466 1
            CHANGE_SIZE_MATCH(xXIAttachSlaveInfo);
a473 1
        len -= any->length * 4;
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d146 4
@


1.6.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d410 1
a410 1
    size_t len;			/* length of data remaining in request */
a419 4
    if (stuff->length > (INT_MAX >> 2))
        return BadAlloc;
    len = (stuff->length << 2) - sizeof(xXIAnyHierarchyChangeInfo);

a421 5
        if (len < sizeof(xXIAnyHierarchyChangeInfo)) {
            rc = BadLength;
            goto unwind;
        }

d425 2
a426 1
        if ((any->length > (INT_MAX >> 2)) || (len < (any->length << 2)))
a428 8
#define CHANGE_SIZE_MATCH(type) \
    do { \
        if ((len < sizeof(type)) || (any->length != (sizeof(type) >> 2))) { \
            rc = BadLength; \
            goto unwind; \
        } \
    } while(0)

a433 5
            /* Variable length, due to appended name string */
            if (len < sizeof(xXIAddMasterInfo)) {
                rc = BadLength;
                goto unwind;
            }
a434 4
            if (c->name_len > (len - sizeof(xXIAddMasterInfo))) {
                rc = BadLength;
                goto unwind;
            }
a444 1
            CHANGE_SIZE_MATCH(xXIRemoveMasterInfo);
a453 1
            CHANGE_SIZE_MATCH(xXIDetachSlaveInfo);
a462 1
            CHANGE_SIZE_MATCH(xXIAttachSlaveInfo);
a469 1
        len -= any->length * 4;
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d55 1
d83 1
a83 1
    info = (xXIHierarchyInfo *) & ev[1];
d193 2
d299 1
a299 5
    /* can't disable until we removed pairing */
    keybd->spriteInfo->paired = NULL;
    ptr->spriteInfo->paired = NULL;
    XTestptr->spriteInfo->paired = NULL;
    XTestkeybd->spriteInfo->paired = NULL;
d312 5
a320 4
    flags[XTestptr->id] |= XISlaveRemoved;
    flags[XTestkeybd->id] |= XISlaveRemoved;
    flags[keybd->id] |= XIMasterRemoved;
    flags[ptr->id] |= XIMasterRemoved;
@


1.4
log
@Update to xserver 1.11.4. tested by krw@@, shadchin@@.
@
text
@a32 1

d37 5
a41 5
#include <X11/X.h>	/* for inputstr.h    */
#include <X11/Xproto.h>	/* Request macro     */
#include "inputstr.h"	/* DeviceIntPtr      */
#include "windowstr.h"	/* window structure  */
#include "scrnintstr.h"	/* screen structure  */
d50 1
a50 1
#include "xiquerydevice.h" /* for GetDeviceUse */
d59 2
a60 1
void XISendDeviceHierarchyEvent(int flags[MAXDEVICES])
d72 1
a72 1
                 MAXDEVICES * sizeof(xXIHierarchyInfo));
d82 2
a83 3
    info = (xXIHierarchyInfo*)&ev[1];
    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
d91 1
a91 2
    for (dev = inputInfo.off_devices; dev; dev = dev->next)
    {
d100 2
a101 5

    for (i = 0; i < MAXDEVICES; i++)
    {
        if (flags[i] & (XIMasterRemoved | XISlaveRemoved))
        {
d117 2
a118 1
    SendEventToAllWindows(&dummyDev, (XI_HierarchyChangedMask >> 8), (xEvent*)ev, 1);
a121 1

d129 2
a130 1
int SProcXIChangeHierarchy(ClientPtr client)
a131 2
    char n;

d133 1
a133 1
    swaps(&stuff->length, n);
d138 1
a138 1
add_master(ClientPtr client, xXIAddMasterInfo *c, int flags[MAXDEVICES])
d141 1
a141 1
    char* name;
d145 1
a145 1
    strncpy(name, (char*)&c[1], c->name_len);
d153 1
a153 1
        ptr->coreEvents = keybd->coreEvents =  FALSE;
d157 1
a157 2
    if (rc != Success)
    {
d173 1
a173 2
    if (c->enable)
    {
d192 1
a192 1
unwind:
d202 1
a202 2
    for (i = 0; i < currentMaxClients; i++)
    {
d204 1
d211 1
a211 2
remove_master(ClientPtr client, xXIRemoveMasterInfo *r,
              int flags[MAXDEVICES])
d216 1
a216 2
    if (r->return_mode != XIAttachToMaster &&
        r->return_mode != XIFloating)
d223 1
a223 2
    if (!IsMaster(ptr))
    {
d230 1
a230 2
    if (ptr == inputInfo.pointer || ptr == inputInfo.keyboard)
    {
a234 1

d250 1
a250 2
    rc = dixLookupDevice(&XTestkeybd, XTestkeybd->id, client,
                         DixDestroyAccess);
d258 2
a259 5
    if (r->return_mode == XIAttachToMaster)
    {
        DeviceIntPtr attached,
                     newptr,
                     newkeybd;
d265 1
a265 2
        if (!IsMaster(newptr))
        {
d276 1
a276 2
        if (!IsMaster(newkeybd))
        {
d282 1
a282 2
        for (attached = inputInfo.devices; attached; attached = attached->next)
        {
d284 1
a284 2
                if (GetMaster(attached, MASTER_ATTACHED) == ptr)
                {
d288 1
a288 2
                if (GetMaster(attached, MASTER_ATTACHED) == keybd)
                {
d322 1
a322 1
unwind:
d327 1
a327 1
detach_slave(ClientPtr client, xXIDetachSlaveInfo *c, int flags[MAXDEVICES])
d336 1
a336 2
    if (IsMaster(dev))
    {
d343 1
a343 2
    if (IsXTestDevice(dev, NULL))
    {
d353 1
a353 1
unwind:
d358 1
a358 2
attach_slave(ClientPtr client, xXIAttachSlaveInfo *c,
             int flags[MAXDEVICES])
d368 1
a368 2
    if (IsMaster(dev))
    {
d375 1
a375 2
    if (IsXTestDevice(dev, NULL))
    {
d384 1
a384 2
    if (!IsMaster(newmaster))
    {
d391 1
a391 2
        (IsKeyboardDevice(newmaster) && IsKeyboardDevice(dev))))
    {
d400 1
a400 1
unwind:
a403 2


a410 1
    char n;
d412 1
a412 1
    int flags[MAXDEVICES] = {0};
d420 4
a423 5
    any = (xXIAnyHierarchyChangeInfo*)&stuff[1];
    while(stuff->num_changes--)
    {
        SWAPIF(swapl(&any->type, n));
        SWAPIF(swaps(&any->length, n));
d429 2
a430 1
        switch(any->type)
d432 36
a467 37
            case XIAddMaster:
                {
                    xXIAddMasterInfo* c = (xXIAddMasterInfo*)any;
                    SWAPIF(swaps(&c->name_len, n));

                    rc = add_master(client, c, flags);
                    if (rc != Success)
                        goto unwind;
                }
                break;
            case XIRemoveMaster:
                {
                    xXIRemoveMasterInfo* r = (xXIRemoveMasterInfo*)any;

                    rc = remove_master(client, r, flags);
                    if (rc != Success)
                        goto unwind;
                }
                break;
            case XIDetachSlave:
                {
                    xXIDetachSlaveInfo* c = (xXIDetachSlaveInfo*)any;

                    rc = detach_slave(client, c, flags);
                    if (rc != Success)
                       goto unwind;
                }
                break;
            case XIAttachSlave:
                {
                    xXIAttachSlaveInfo* c = (xXIAttachSlaveInfo*)any;

                    rc = attach_slave(client, c, flags);
                    if (rc != Success)
                       goto unwind;
                }
                break;
d470 1
a470 1
        any = (xXIAnyHierarchyChangeInfo*)((char*)any + any->length * 4);
d473 1
a473 1
unwind:
a477 1

@


1.3
log
@Update to xserver 1.11.2
@
text
@d205 13
d267 2
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d73 2
d119 1
d121 1
d143 277
a424 1
    DeviceIntPtr ptr, keybd, XTestptr, XTestkeybd;
a451 2
                    char* name;

a452 3
                    name = calloc(c->name_len + 1, sizeof(char));
                    strncpy(name, (char*)&c[1], c->name_len);

d454 1
a454 3
                    rc = AllocDevicePair(client, name, &ptr, &keybd,
                                         CorePointerProc, CoreKeyboardProc,
                                         TRUE);
a455 2
                    {
                        free(name);
a456 46
                    }

                    if (!c->send_core)
                        ptr->coreEvents = keybd->coreEvents =  FALSE;

                    /* Allocate virtual slave devices for xtest events */
                    rc = AllocXTestDevice(client, name, &XTestptr, &XTestkeybd,
                                         ptr, keybd);
                    if (rc != Success)
                    {

                        free(name);
                        goto unwind;
                    }

                    ActivateDevice(ptr, FALSE);
                    ActivateDevice(keybd, FALSE);
                    flags[ptr->id] |= XIMasterAdded;
                    flags[keybd->id] |= XIMasterAdded;

                    ActivateDevice(XTestptr, FALSE);
                    ActivateDevice(XTestkeybd, FALSE);
                    flags[XTestptr->id] |= XISlaveAdded;
                    flags[XTestkeybd->id] |= XISlaveAdded;

                    if (c->enable)
                    {
                        EnableDevice(ptr, FALSE);
                        EnableDevice(keybd, FALSE);
                        flags[ptr->id] |= XIDeviceEnabled;
                        flags[keybd->id] |= XIDeviceEnabled;

                        EnableDevice(XTestptr, FALSE);
                        EnableDevice(XTestkeybd, FALSE);
                        flags[XTestptr->id] |= XIDeviceEnabled;
                        flags[XTestkeybd->id] |= XIDeviceEnabled;
                    }

                    /* Attach the XTest virtual devices to the newly
                       created master device */
                    AttachDevice(NULL, XTestptr, ptr);
                    AttachDevice(NULL, XTestkeybd, keybd);
                    flags[XTestptr->id] |= XISlaveAttached;
                    flags[XTestkeybd->id] |= XISlaveAttached;

                    free(name);
d463 1
a463 6
                    if (r->return_mode != XIAttachToMaster &&
                            r->return_mode != XIFloating)
                        return BadValue;

                    rc = dixLookupDevice(&ptr, r->deviceid, client,
                                         DixDestroyAccess);
a465 120

                    if (!IsMaster(ptr))
                    {
                        client->errorValue = r->deviceid;
                        rc = BadDevice;
                        goto unwind;
                    }

                    /* XXX: For now, don't allow removal of VCP, VCK */
                    if (ptr == inputInfo.pointer ||
                            ptr == inputInfo.keyboard)
                    {
                        rc = BadDevice;
                        goto unwind;
                    }


                    ptr = GetMaster(ptr, MASTER_POINTER);
                    rc = dixLookupDevice(&ptr,
                                         ptr->id,
                                         client,
                                         DixDestroyAccess);
                    if (rc != Success)
                        goto unwind;
                    keybd = GetMaster(ptr, MASTER_KEYBOARD);
                    rc = dixLookupDevice(&keybd,
                                         keybd->id,
                                         client,
                                         DixDestroyAccess);
                    if (rc != Success)
                        goto unwind;

                    XTestptr = GetXTestDevice(ptr);
                    rc = dixLookupDevice(&XTestptr, XTestptr->id, client,
                                         DixDestroyAccess);
                    if (rc != Success)
                        goto unwind;

                    XTestkeybd = GetXTestDevice(keybd);
                    rc = dixLookupDevice(&XTestkeybd, XTestkeybd->id, client,
                                         DixDestroyAccess);
                    if (rc != Success)
                        goto unwind;

                    /* Disabling sends the devices floating, reattach them if
                     * desired. */
                    if (r->return_mode == XIAttachToMaster)
                    {
                        DeviceIntPtr attached,
                                     newptr,
                                     newkeybd;

                        rc = dixLookupDevice(&newptr, r->return_pointer,
                                             client, DixAddAccess);
                        if (rc != Success)
                            goto unwind;

                        if (!IsMaster(newptr))
                        {
                            client->errorValue = r->return_pointer;
                            rc = BadDevice;
                            goto unwind;
                        }

                        rc = dixLookupDevice(&newkeybd, r->return_keyboard,
                                             client, DixAddAccess);
                        if (rc != Success)
                            goto unwind;

                        if (!IsMaster(newkeybd))
                        {
                            client->errorValue = r->return_keyboard;
                            rc = BadDevice;
                            goto unwind;
                        }

                        for (attached = inputInfo.devices;
                                attached;
                                attached = attached->next)
                        {
                            if (!IsMaster(attached)) {
                                if (attached->u.master == ptr)
                                {
                                    AttachDevice(client, attached, newptr);
                                    flags[attached->id] |= XISlaveAttached;
                                }
                                if (attached->u.master == keybd)
                                {
                                    AttachDevice(client, attached, newkeybd);
                                    flags[attached->id] |= XISlaveAttached;
                                }
                            }
                        }
                    }

                    /* can't disable until we removed pairing */
                    keybd->spriteInfo->paired = NULL;
                    ptr->spriteInfo->paired = NULL;
                    XTestptr->spriteInfo->paired = NULL;
                    XTestkeybd->spriteInfo->paired = NULL;

                    /* disable the remove the devices, XTest devices must be done first
                       else the sprites they rely on will be destroyed  */
                    DisableDevice(XTestptr, FALSE);
                    DisableDevice(XTestkeybd, FALSE);
                    DisableDevice(keybd, FALSE);
                    DisableDevice(ptr, FALSE);
                    flags[XTestptr->id] |= XIDeviceDisabled | XISlaveDetached;
                    flags[XTestkeybd->id] |= XIDeviceDisabled | XISlaveDetached;
                    flags[keybd->id] |= XIDeviceDisabled;
                    flags[ptr->id] |= XIDeviceDisabled;

                    RemoveDevice(XTestptr, FALSE);
                    RemoveDevice(XTestkeybd, FALSE);
                    RemoveDevice(keybd, FALSE);
                    RemoveDevice(ptr, FALSE);
                    flags[XTestptr->id] |= XISlaveRemoved;
                    flags[XTestkeybd->id] |= XISlaveRemoved;
                    flags[keybd->id] |= XIMasterRemoved;
                    flags[ptr->id] |= XIMasterRemoved;
d472 1
a472 2
                    rc = dixLookupDevice(&ptr, c->deviceid, client,
                                          DixManageAccess);
a474 18

                    if (IsMaster(ptr))
                    {
                        client->errorValue = c->deviceid;
                        rc = BadDevice;
                        goto unwind;
                    }

                    /* Don't allow changes to XTest Devices, these are fixed */
                    if (IsXTestDevice(ptr, NULL))
                    {
                        client->errorValue = c->deviceid;
                        rc = BadDevice;
                        goto unwind;
                    }

                    AttachDevice(client, ptr, NULL);
                    flags[ptr->id] |= XISlaveDetached;
a479 1
                    DeviceIntPtr newmaster;
d481 1
a481 2
                    rc = dixLookupDevice(&ptr, c->deviceid, client,
                                          DixManageAccess);
a483 37

                    if (IsMaster(ptr))
                    {
                        client->errorValue = c->deviceid;
                        rc = BadDevice;
                        goto unwind;
                    }

                    /* Don't allow changes to XTest Devices, these are fixed */
                    if (IsXTestDevice(ptr, NULL))
                    {
                        client->errorValue = c->deviceid;
                        rc = BadDevice;
                        goto unwind;
                    }

                    rc = dixLookupDevice(&newmaster, c->new_master,
                            client, DixAddAccess);
                    if (rc != Success)
                        goto unwind;
                    if (!IsMaster(newmaster))
                    {
                        client->errorValue = c->new_master;
                        rc = BadDevice;
                        goto unwind;
                    }

                    if (!((IsPointerDevice(newmaster) &&
                                    IsPointerDevice(ptr)) ||
                                (IsKeyboardDevice(newmaster) &&
                                 IsKeyboardDevice(ptr))))
                    {
                        rc = BadDevice;
                        goto unwind;
                    }
                    AttachDevice(client, ptr, newmaster);
                    flags[ptr->id] |= XISlaveAttached;
@


1.1
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d71 1
a71 1
    ev = xcalloc(1, sizeof(xXIHierarchyEvent) +
d119 1
a119 1
    xfree(ev);
d175 1
a175 1
                    name = xcalloc(c->name_len + 1, sizeof(char));
d184 1
a184 1
                        xfree(name);
d197 1
a197 1
                        xfree(name);
d231 1
a231 1
                    xfree(name);
@

