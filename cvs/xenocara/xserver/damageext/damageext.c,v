head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.10
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.8
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.6
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.21.20.10.46;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.12;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.42;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.42;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.06.06;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright Â© 2002 Keith Packard
 * Copyright 2013 Red Hat, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "damageextint.h"
#include "damagestr.h"
#include "protocol-versions.h"
#include "extinit.h"

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"

typedef struct {
    DamageExtPtr ext;
    DamagePtr damage[MAXSCREENS];
} PanoramiXDamageRes;

static RESTYPE XRT_DAMAGE;
static int (*PanoramiXSaveDamageCreate) (ClientPtr);

#endif

static unsigned char DamageReqCode;
static int DamageEventBase;
static RESTYPE DamageExtType;

static DevPrivateKeyRec DamageClientPrivateKeyRec;

#define DamageClientPrivateKey (&DamageClientPrivateKeyRec)

static void
DamageNoteCritical(ClientPtr pClient)
{
    DamageClientPtr pDamageClient = GetDamageClient(pClient);

    /* Composite extension marks clients with manual Subwindows as critical */
    if (pDamageClient->critical > 0) {
        SetCriticalOutputPending();
        pClient->smart_priority = SMART_MAX_PRIORITY;
    }
}

static void
damageGetGeometry(DrawablePtr draw, int *x, int *y, int *w, int *h)
{
#ifdef PANORAMIX
    if (!noPanoramiXExtension && draw->type == DRAWABLE_WINDOW) {
        WindowPtr win = (WindowPtr)draw;

        if (!win->parent) {
            *x = screenInfo.x;
            *y = screenInfo.y;
            *w = screenInfo.width;
            *h = screenInfo.height;
            return;
        }
    }
#endif

    *x = draw->x;
    *y = draw->y;
    *w = draw->width;
    *h = draw->height;
}

static void
DamageExtNotify(DamageExtPtr pDamageExt, BoxPtr pBoxes, int nBoxes)
{
    ClientPtr pClient = pDamageExt->pClient;
    DrawablePtr pDrawable = pDamageExt->pDrawable;
    xDamageNotifyEvent ev;
    int i, x, y, w, h;

    damageGetGeometry(pDrawable, &x, &y, &w, &h);

    UpdateCurrentTimeIf();
    ev = (xDamageNotifyEvent) {
        .type = DamageEventBase + XDamageNotify,
        .level = pDamageExt->level,
        .drawable = pDamageExt->drawable,
        .damage = pDamageExt->id,
        .timestamp = currentTime.milliseconds,
        .geometry.x = x,
        .geometry.y = y,
        .geometry.width = w,
        .geometry.height = h
    };
    if (pBoxes) {
        for (i = 0; i < nBoxes; i++) {
            ev.level = pDamageExt->level;
            if (i < nBoxes - 1)
                ev.level |= DamageNotifyMore;
            ev.area.x = pBoxes[i].x1;
            ev.area.y = pBoxes[i].y1;
            ev.area.width = pBoxes[i].x2 - pBoxes[i].x1;
            ev.area.height = pBoxes[i].y2 - pBoxes[i].y1;
            WriteEventsToClient(pClient, 1, (xEvent *) &ev);
        }
    }
    else {
        ev.area.x = 0;
        ev.area.y = 0;
        ev.area.width = w;
        ev.area.height = h;
        WriteEventsToClient(pClient, 1, (xEvent *) &ev);
    }

    DamageNoteCritical(pClient);
}

static void
DamageExtReport(DamagePtr pDamage, RegionPtr pRegion, void *closure)
{
    DamageExtPtr pDamageExt = closure;

    switch (pDamageExt->level) {
    case DamageReportRawRegion:
    case DamageReportDeltaRegion:
        DamageExtNotify(pDamageExt, RegionRects(pRegion),
                        RegionNumRects(pRegion));
        break;
    case DamageReportBoundingBox:
        DamageExtNotify(pDamageExt, RegionExtents(pRegion), 1);
        break;
    case DamageReportNonEmpty:
        DamageExtNotify(pDamageExt, NullBox, 0);
        break;
    case DamageReportNone:
        break;
    }
}

static void
DamageExtDestroy(DamagePtr pDamage, void *closure)
{
    DamageExtPtr pDamageExt = closure;

    pDamageExt->pDamage = 0;
    if (pDamageExt->id)
        FreeResource(pDamageExt->id, RT_NONE);
}

void
DamageExtSetCritical(ClientPtr pClient, Bool critical)
{
    DamageClientPtr pDamageClient = GetDamageClient(pClient);

    if (pDamageClient)
        pDamageClient->critical += critical ? 1 : -1;
}

static int
ProcDamageQueryVersion(ClientPtr client)
{
    DamageClientPtr pDamageClient = GetDamageClient(client);
    xDamageQueryVersionReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };

    REQUEST(xDamageQueryVersionReq);

    REQUEST_SIZE_MATCH(xDamageQueryVersionReq);

    if (stuff->majorVersion < SERVER_DAMAGE_MAJOR_VERSION) {
        rep.majorVersion = stuff->majorVersion;
        rep.minorVersion = stuff->minorVersion;
    }
    else {
        rep.majorVersion = SERVER_DAMAGE_MAJOR_VERSION;
        if (stuff->majorVersion == SERVER_DAMAGE_MAJOR_VERSION &&
            stuff->minorVersion < SERVER_DAMAGE_MINOR_VERSION)
            rep.minorVersion = stuff->minorVersion;
        else
            rep.minorVersion = SERVER_DAMAGE_MINOR_VERSION;
    }
    pDamageClient->major_version = rep.majorVersion;
    pDamageClient->minor_version = rep.minorVersion;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.majorVersion);
        swapl(&rep.minorVersion);
    }
    WriteToClient(client, sizeof(xDamageQueryVersionReply), &rep);
    return Success;
}

static void
DamageExtRegister(DrawablePtr pDrawable, DamagePtr pDamage, Bool report)
{
    DamageSetReportAfterOp(pDamage, TRUE);
    DamageRegister(pDrawable, pDamage);

    if (report) {
        RegionPtr pRegion = &((WindowPtr) pDrawable)->borderClip;
        RegionTranslate(pRegion, -pDrawable->x, -pDrawable->y);
        DamageReportDamage(pDamage, pRegion);
        RegionTranslate(pRegion, pDrawable->x, pDrawable->y);
    }
}

static DamageExtPtr
DamageExtCreate(DrawablePtr pDrawable, DamageReportLevel level,
                ClientPtr client, XID id, XID drawable)
{
    DamageExtPtr pDamageExt = malloc(sizeof(DamageExtRec));
    if (!pDamageExt)
        return NULL;

    pDamageExt->id = id;
    pDamageExt->drawable = drawable;
    pDamageExt->pDrawable = pDrawable;
    pDamageExt->level = level;
    pDamageExt->pClient = client;
    pDamageExt->pDamage = DamageCreate(DamageExtReport, DamageExtDestroy, level,
                                       FALSE, pDrawable->pScreen, pDamageExt);
    if (!pDamageExt->pDamage) {
        free(pDamageExt);
        return NULL;
    }

    if (!AddResource(id, DamageExtType, (void *) pDamageExt))
        return NULL;

    DamageExtRegister(pDrawable, pDamageExt->pDamage,
                      pDrawable->type == DRAWABLE_WINDOW);

    return pDamageExt;
}

static DamageExtPtr
doDamageCreate(ClientPtr client, int *rc)
{
    DrawablePtr pDrawable;
    DamageExtPtr pDamageExt;
    DamageReportLevel level;

    REQUEST(xDamageCreateReq);

    *rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
                            DixGetAttrAccess | DixReadAccess);
    if (*rc != Success)
        return NULL;

    switch (stuff->level) {
    case XDamageReportRawRectangles:
        level = DamageReportRawRegion;
        break;
    case XDamageReportDeltaRectangles:
        level = DamageReportDeltaRegion;
        break;
    case XDamageReportBoundingBox:
        level = DamageReportBoundingBox;
        break;
    case XDamageReportNonEmpty:
        level = DamageReportNonEmpty;
        break;
    default:
        client->errorValue = stuff->level;
        *rc = BadValue;
        return NULL;
    }

    pDamageExt = DamageExtCreate(pDrawable, level, client, stuff->damage,
                                 stuff->drawable);
    if (!pDamageExt)
        *rc = BadAlloc;

    return pDamageExt;
}

static int
ProcDamageCreate(ClientPtr client)
{
    int rc;
    REQUEST(xDamageCreateReq);
    REQUEST_SIZE_MATCH(xDamageCreateReq);
    LEGAL_NEW_RESOURCE(stuff->damage, client);
    doDamageCreate(client, &rc);
    return rc;
}

static int
ProcDamageDestroy(ClientPtr client)
{
    REQUEST(xDamageDestroyReq);
    DamageExtPtr pDamageExt;

    REQUEST_SIZE_MATCH(xDamageDestroyReq);
    VERIFY_DAMAGEEXT(pDamageExt, stuff->damage, client, DixWriteAccess);
    FreeResource(stuff->damage, RT_NONE);
    return Success;
}

#ifdef PANORAMIX
static RegionPtr
DamageExtSubtractWindowClip(DamageExtPtr pDamageExt)
{
    WindowPtr win = (WindowPtr)pDamageExt->pDrawable;
    PanoramiXRes *res = NULL;
    RegionPtr ret;
    int i;

    if (!win->parent)
        return &PanoramiXScreenRegion;

    dixLookupResourceByType((void **)&res, win->drawable.id, XRT_WINDOW,
                            serverClient, DixReadAccess);
    if (!res)
        return NULL;

    ret = RegionCreate(NULL, 0);
    if (!ret)
        return NULL;

    FOR_NSCREENS_FORWARD(i) {
        ScreenPtr screen;
        if (Success != dixLookupWindow(&win, res->info[i].id, serverClient,
                                       DixReadAccess))
            goto out;

        screen = win->drawable.pScreen;

        RegionTranslate(ret, -screen->x, -screen->y);
        if (!RegionUnion(ret, ret, &win->borderClip))
            goto out;
        RegionTranslate(ret, screen->x, screen->y);
    }

    return ret;

out:
    RegionDestroy(ret);
    return NULL;
}

static void
DamageExtFreeWindowClip(RegionPtr reg)
{
    if (reg != &PanoramiXScreenRegion)
        RegionDestroy(reg);
}
#endif

/*
 * DamageSubtract intersects with borderClip, so we must reconstruct the
 * protocol's perspective of same...
 */
static Bool
DamageExtSubtract(DamageExtPtr pDamageExt, const RegionPtr pRegion)
{
    DamagePtr pDamage = pDamageExt->pDamage;

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        RegionPtr damage = DamageRegion(pDamage);
        RegionSubtract(damage, damage, pRegion);

        if (pDamageExt->pDrawable->type == DRAWABLE_WINDOW) {
            DrawablePtr pDraw = pDamageExt->pDrawable;
            RegionPtr clip = DamageExtSubtractWindowClip(pDamageExt);
            if (clip) {
                RegionTranslate(clip, -pDraw->x, -pDraw->y);
                RegionIntersect(damage, damage, clip);
                RegionTranslate(clip, pDraw->x, pDraw->y);
                DamageExtFreeWindowClip(clip);
            }
        }

        return RegionNotEmpty(damage);
    }
#endif

    return DamageSubtract(pDamage, pRegion);
}

static int
ProcDamageSubtract(ClientPtr client)
{
    REQUEST(xDamageSubtractReq);
    DamageExtPtr pDamageExt;
    RegionPtr pRepair;
    RegionPtr pParts;

    REQUEST_SIZE_MATCH(xDamageSubtractReq);
    VERIFY_DAMAGEEXT(pDamageExt, stuff->damage, client, DixWriteAccess);
    VERIFY_REGION_OR_NONE(pRepair, stuff->repair, client, DixWriteAccess);
    VERIFY_REGION_OR_NONE(pParts, stuff->parts, client, DixWriteAccess);

    if (pDamageExt->level != DamageReportRawRegion) {
        DamagePtr pDamage = pDamageExt->pDamage;

        if (pRepair) {
            if (pParts)
                RegionIntersect(pParts, DamageRegion(pDamage), pRepair);
            if (DamageExtSubtract(pDamageExt, pRepair))
                DamageExtReport(pDamage, DamageRegion(pDamage),
                                (void *) pDamageExt);
        }
        else {
            if (pParts)
                RegionCopy(pParts, DamageRegion(pDamage));
            DamageEmpty(pDamage);
        }
    }

    return Success;
}

static int
ProcDamageAdd(ClientPtr client)
{
    REQUEST(xDamageAddReq);
    DrawablePtr pDrawable;
    RegionPtr pRegion;
    int rc;

    REQUEST_SIZE_MATCH(xDamageAddReq);
    VERIFY_REGION(pRegion, stuff->region, client, DixWriteAccess);
    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
                           DixWriteAccess);
    if (rc != Success)
        return rc;

    /* The region is relative to the drawable origin, so translate it out to
     * screen coordinates like damage expects.
     */
    RegionTranslate(pRegion, pDrawable->x, pDrawable->y);
    DamageDamageRegion(pDrawable, pRegion);
    RegionTranslate(pRegion, -pDrawable->x, -pDrawable->y);

    return Success;
}

/* Major version controls available requests */
static const int version_requests[] = {
    X_DamageQueryVersion,       /* before client sends QueryVersion */
    X_DamageAdd,                /* Version 1 */
};

#define NUM_VERSION_REQUESTS	(sizeof (version_requests) / sizeof (version_requests[0]))

static int (*ProcDamageVector[XDamageNumberRequests]) (ClientPtr) = {
    /*************** Version 1 ******************/
    ProcDamageQueryVersion,
    ProcDamageCreate,
    ProcDamageDestroy,
    ProcDamageSubtract,
    /*************** Version 1.1 ****************/
    ProcDamageAdd,
};

static int
ProcDamageDispatch(ClientPtr client)
{
    REQUEST(xDamageReq);
    DamageClientPtr pDamageClient = GetDamageClient(client);

    if (pDamageClient->major_version >= NUM_VERSION_REQUESTS)
        return BadRequest;
    if (stuff->damageReqType > version_requests[pDamageClient->major_version])
        return BadRequest;
    return (*ProcDamageVector[stuff->damageReqType]) (client);
}

static int
SProcDamageQueryVersion(ClientPtr client)
{
    REQUEST(xDamageQueryVersionReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDamageQueryVersionReq);
    swapl(&stuff->majorVersion);
    swapl(&stuff->minorVersion);
    return (*ProcDamageVector[stuff->damageReqType]) (client);
}

static int
SProcDamageCreate(ClientPtr client)
{
    REQUEST(xDamageCreateReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDamageCreateReq);
    swapl(&stuff->damage);
    swapl(&stuff->drawable);
    return (*ProcDamageVector[stuff->damageReqType]) (client);
}

static int
SProcDamageDestroy(ClientPtr client)
{
    REQUEST(xDamageDestroyReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDamageDestroyReq);
    swapl(&stuff->damage);
    return (*ProcDamageVector[stuff->damageReqType]) (client);
}

static int
SProcDamageSubtract(ClientPtr client)
{
    REQUEST(xDamageSubtractReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDamageSubtractReq);
    swapl(&stuff->damage);
    swapl(&stuff->repair);
    swapl(&stuff->parts);
    return (*ProcDamageVector[stuff->damageReqType]) (client);
}

static int
SProcDamageAdd(ClientPtr client)
{
    REQUEST(xDamageAddReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDamageSubtractReq);
    swapl(&stuff->drawable);
    swapl(&stuff->region);
    return (*ProcDamageVector[stuff->damageReqType]) (client);
}

static int (*SProcDamageVector[XDamageNumberRequests]) (ClientPtr) = {
    /*************** Version 1 ******************/
    SProcDamageQueryVersion,
    SProcDamageCreate,
    SProcDamageDestroy,
    SProcDamageSubtract,
    /*************** Version 1.1 ****************/
    SProcDamageAdd,
};

static int
SProcDamageDispatch(ClientPtr client)
{
    REQUEST(xDamageReq);
    if (stuff->damageReqType >= XDamageNumberRequests)
        return BadRequest;
    return (*SProcDamageVector[stuff->damageReqType]) (client);
}

static void
DamageClientCallback(CallbackListPtr *list, void *closure, void *data)
{
    NewClientInfoRec *clientinfo = (NewClientInfoRec *) data;
    ClientPtr pClient = clientinfo->client;
    DamageClientPtr pDamageClient = GetDamageClient(pClient);

    pDamageClient->critical = 0;
    pDamageClient->major_version = 0;
    pDamageClient->minor_version = 0;
}

 /*ARGSUSED*/ static void
DamageResetProc(ExtensionEntry * extEntry)
{
    DeleteCallback(&ClientStateCallback, DamageClientCallback, 0);
}

static int
FreeDamageExt(void *value, XID did)
{
    DamageExtPtr pDamageExt = (DamageExtPtr) value;

    /*
     * Get rid of the resource table entry hanging from the window id
     */
    pDamageExt->id = 0;
    if (pDamageExt->pDamage) {
        DamageDestroy(pDamageExt->pDamage);
    }
    free(pDamageExt);
    return Success;
}

static void
SDamageNotifyEvent(xDamageNotifyEvent * from, xDamageNotifyEvent * to)
{
    to->type = from->type;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->drawable, to->drawable);
    cpswapl(from->damage, to->damage);
    cpswaps(from->area.x, to->area.x);
    cpswaps(from->area.y, to->area.y);
    cpswaps(from->area.width, to->area.width);
    cpswaps(from->area.height, to->area.height);
    cpswaps(from->geometry.x, to->geometry.x);
    cpswaps(from->geometry.y, to->geometry.y);
    cpswaps(from->geometry.width, to->geometry.width);
    cpswaps(from->geometry.height, to->geometry.height);
}

#ifdef PANORAMIX

static void
PanoramiXDamageReport(DamagePtr pDamage, RegionPtr pRegion, void *closure)
{
    PanoramiXDamageRes *res = closure;
    DamageExtPtr pDamageExt = res->ext;
    WindowPtr pWin = (WindowPtr)pDamage->pDrawable;
    ScreenPtr pScreen = pDamage->pScreen;

    /* happens on unmap? sigh xinerama */
    if (RegionNil(pRegion))
        return;

    /* translate root windows if necessary */
    if (!pWin->parent)
        RegionTranslate(pRegion, pScreen->x, pScreen->y);

    /* add our damage to the protocol view */
    DamageReportDamage(pDamageExt->pDamage, pRegion);

    /* empty our view */
    DamageEmpty(pDamage);
}

static void
PanoramiXDamageExtDestroy(DamagePtr pDamage, void *closure)
{
    PanoramiXDamageRes *damage = closure;
    damage->damage[pDamage->pScreen->myNum] = NULL;
}

static int
PanoramiXDamageCreate(ClientPtr client)
{
    PanoramiXDamageRes *damage;
    PanoramiXRes *draw;
    int i, rc;

    REQUEST(xDamageCreateReq);

    REQUEST_SIZE_MATCH(xDamageCreateReq);
    LEGAL_NEW_RESOURCE(stuff->damage, client);
    rc = dixLookupResourceByClass((void **)&draw, stuff->drawable, XRC_DRAWABLE,
                                  client, DixGetAttrAccess | DixReadAccess);
    if (rc != Success)
        return rc;

    if (!(damage = calloc(1, sizeof(PanoramiXDamageRes))))
        return BadAlloc;

    if (!AddResource(stuff->damage, XRT_DAMAGE, damage))
        return BadAlloc;

    damage->ext = doDamageCreate(client, &rc);
    if (rc == Success && draw->type == XRT_WINDOW) {
        FOR_NSCREENS_FORWARD(i) {
            DrawablePtr pDrawable;
            DamagePtr pDamage = DamageCreate(PanoramiXDamageReport,
                                             PanoramiXDamageExtDestroy,
                                             DamageReportRawRegion,
                                             FALSE,
                                             screenInfo.screens[i],
                                             damage);
            if (!pDamage) {
                rc = BadAlloc;
            } else {
                damage->damage[i] = pDamage;
                rc = dixLookupDrawable(&pDrawable, draw->info[i].id, client,
                                       M_WINDOW,
                                       DixGetAttrAccess | DixReadAccess);
            }
            if (rc != Success)
                break;

            DamageExtRegister(pDrawable, pDamage, i != 0);
        }
    }

    if (rc != Success)
        FreeResource(stuff->damage, RT_NONE);

    return rc;
}

static int
PanoramiXDamageDelete(void *res, XID id)
{
    int i;
    PanoramiXDamageRes *damage = res;

    FOR_NSCREENS_BACKWARD(i) {
        if (damage->damage[i]) {
            DamageDestroy(damage->damage[i]);
            damage->damage[i] = NULL;
        }
    }

    free(damage);
    return 1;
}

void
PanoramiXDamageInit(void)
{
    XRT_DAMAGE = CreateNewResourceType(PanoramiXDamageDelete, "XineramaDamage");
    if (!XRT_DAMAGE)
        FatalError("Couldn't Xineramify Damage extension\n");

    PanoramiXSaveDamageCreate = ProcDamageVector[X_DamageCreate];
    ProcDamageVector[X_DamageCreate] = PanoramiXDamageCreate;
}

void
PanoramiXDamageReset(void)
{
    ProcDamageVector[X_DamageCreate] = PanoramiXSaveDamageCreate;
}

#endif /* PANORAMIX */

void
DamageExtensionInit(void)
{
    ExtensionEntry *extEntry;
    int s;

    for (s = 0; s < screenInfo.numScreens; s++)
        DamageSetup(screenInfo.screens[s]);

    DamageExtType = CreateNewResourceType(FreeDamageExt, "DamageExt");
    if (!DamageExtType)
        return;

    if (!dixRegisterPrivateKey
        (&DamageClientPrivateKeyRec, PRIVATE_CLIENT, sizeof(DamageClientRec)))
        return;

    if (!AddCallback(&ClientStateCallback, DamageClientCallback, 0))
        return;

    if ((extEntry = AddExtension(DAMAGE_NAME, XDamageNumberEvents,
                                 XDamageNumberErrors,
                                 ProcDamageDispatch, SProcDamageDispatch,
                                 DamageResetProc, StandardMinorOpcode)) != 0) {
        DamageReqCode = (unsigned char) extEntry->base;
        DamageEventBase = extEntry->eventBase;
        EventSwapVector[DamageEventBase + XDamageNotify] =
            (EventSwapPtr) SDamageNotifyEvent;
        SetResourceTypeErrorValue(DamageExtType,
                                  extEntry->errorBase + BadDamage);
#ifdef PANORAMIX
        if (XRT_DAMAGE)
            SetResourceTypeErrorValue(XRT_DAMAGE,
                                      extEntry->errorBase + BadDamage);
#endif
    }
}
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d248 1
a248 1
    if (!AddResource(id, DamageExtType, (pointer) pDamageExt))
d572 1
a572 1
DamageClientCallback(CallbackListPtr *list, pointer closure, pointer data)
d590 1
a590 1
FreeDamageExt(pointer value, XID did)
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d3 1
d29 1
d33 14
a49 1
static RESTYPE DamageExtWinType;
d56 35
a93 1
    DamageClientPtr pDamageClient = GetDamageClient(pClient);
d96 3
a98 1
    int i;
d107 4
a110 4
        .geometry.x = pDrawable->x,
        .geometry.y = pDrawable->y,
        .geometry.width = pDrawable->width,
        .geometry.height = pDrawable->height
d127 2
a128 2
        ev.area.width = pDrawable->width;
        ev.area.height = pDrawable->height;
d131 2
a132 5
    /* Composite extension marks clients with manual Subwindows as critical */
    if (pDamageClient->critical > 0) {
        SetCriticalOutputPending();
        pClient->smart_priority = SMART_MAX_PRIORITY;
    }
d214 45
a258 2
static int
ProcDamageCreate(ClientPtr client)
a262 2
    RegionPtr pRegion;
    int rc;
d266 4
a269 6
    REQUEST_SIZE_MATCH(xDamageCreateReq);
    LEGAL_NEW_RESOURCE(stuff->damage, client);
    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
                           DixGetAttrAccess | DixReadAccess);
    if (rc != Success)
        return rc;
d286 2
a287 1
        return BadValue;
d290 2
a291 1
    pDamageExt = malloc(sizeof(DamageExtRec));
d293 1
a293 16
        return BadAlloc;
    pDamageExt->id = stuff->damage;
    pDamageExt->drawable = stuff->drawable;
    pDamageExt->pDrawable = pDrawable;
    pDamageExt->level = level;
    pDamageExt->pClient = client;
    pDamageExt->pDamage = DamageCreate(DamageExtReport,
                                       DamageExtDestroy,
                                       level,
                                       FALSE, pDrawable->pScreen, pDamageExt);
    if (!pDamageExt->pDamage) {
        free(pDamageExt);
        return BadAlloc;
    }
    if (!AddResource(stuff->damage, DamageExtType, (pointer) pDamageExt))
        return BadAlloc;
d295 2
a296 2
    DamageSetReportAfterOp(pDamageExt->pDamage, TRUE);
    DamageRegister(pDamageExt->pDrawable, pDamageExt->pDamage);
d298 9
a306 6
    if (pDrawable->type == DRAWABLE_WINDOW) {
        pRegion = &((WindowPtr) pDrawable)->borderClip;
        DamageReportDamage(pDamageExt->pDamage, pRegion);
    }

    return Success;
d321 82
d422 1
a422 1
            if (DamageSubtract(pDamage, pRepair))
d432 1
d470 1
a470 1
/*************** Version 1 ******************/
d472 6
a477 3
        ProcDamageCreate, ProcDamageDestroy, ProcDamageSubtract,
/*************** Version 1.1 ****************/
ProcDamageAdd,};
d553 1
a553 1
/*************** Version 1 ******************/
d555 6
a560 3
        SProcDamageCreate, SProcDamageDestroy, SProcDamageSubtract,
/*************** Version 1.1 ****************/
SProcDamageAdd,};
a597 2
    if (WindowDrawable(pDamageExt->pDrawable->type))
        FreeResourceByType(pDamageExt->pDrawable->id, DamageExtWinType, TRUE);
a598 1
        DamageUnregister(pDamageExt->pDrawable, pDamageExt->pDamage);
a604 10
static int
FreeDamageExtWin(pointer value, XID wid)
{
    DamageExtPtr pDamageExt = (DamageExtPtr) value;

    if (pDamageExt->id)
        FreeResource(pDamageExt->id, RT_NONE);
    return Success;
}

d622 121
a755 4
    DamageExtWinType = CreateNewResourceType(FreeDamageExtWin, "DamageExtWin");
    if (!DamageExtWinType)
        return;

d773 5
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d29 1
d50 11
a60 9
    ev.type = DamageEventBase + XDamageNotify;
    ev.level = pDamageExt->level;
    ev.drawable = pDamageExt->drawable;
    ev.damage = pDamageExt->id;
    ev.timestamp = currentTime.milliseconds;
    ev.geometry.x = pDrawable->x;
    ev.geometry.y = pDrawable->y;
    ev.geometry.width = pDrawable->width;
    ev.geometry.height = pDrawable->height;
d132 5
a136 1
    xDamageQueryVersionReply rep;
d141 1
a141 3
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
d162 1
a162 1
    WriteToClient(client, sizeof(xDamageQueryVersionReply), (char *) &rep);
@


1.7
log
@Update to xserver 1.11.2
@
text
@d30 4
a33 4
static unsigned char	DamageReqCode;
static int		DamageEventBase;
static RESTYPE		DamageExtType;
static RESTYPE		DamageExtWinType;
d36 1
d40 1
a40 1
DamageExtNotify (DamageExtPtr pDamageExt, BoxPtr pBoxes, int nBoxes)
d42 5
a46 5
    ClientPtr		pClient = pDamageExt->pClient;
    DamageClientPtr	pDamageClient = GetDamageClient (pClient);
    DrawablePtr		pDrawable = pDamageExt->pDrawable;
    xDamageNotifyEvent	ev;
    int			i;
d48 1
a48 1
    UpdateCurrentTimeIf ();
d58 18
a75 21
    if (pBoxes)
    {
	for (i = 0; i < nBoxes; i++)
	{
	    ev.level = pDamageExt->level;
	    if (i < nBoxes - 1)
		ev.level |= DamageNotifyMore;
	    ev.area.x = pBoxes[i].x1;
	    ev.area.y = pBoxes[i].y1;
	    ev.area.width = pBoxes[i].x2 - pBoxes[i].x1;
	    ev.area.height = pBoxes[i].y2 - pBoxes[i].y1;
	    WriteEventsToClient (pClient, 1, (xEvent *) &ev);
	}
    }
    else
    {
	ev.area.x = 0;
	ev.area.y = 0;
	ev.area.width = pDrawable->width;
	ev.area.height = pDrawable->height;
	WriteEventsToClient (pClient, 1, (xEvent *) &ev);
d78 3
a80 4
    if (pDamageClient->critical > 0)
    {
	SetCriticalOutputPending ();
	pClient->smart_priority = SMART_MAX_PRIORITY;
d85 1
a85 1
DamageExtReport (DamagePtr pDamage, RegionPtr pRegion, void *closure)
d87 1
a87 1
    DamageExtPtr    pDamageExt = closure;
d92 3
a94 2
	DamageExtNotify (pDamageExt, RegionRects(pRegion), RegionNumRects(pRegion));
	break;
d96 2
a97 2
	DamageExtNotify (pDamageExt, RegionExtents(pRegion), 1);
	break;
d99 2
a100 2
	DamageExtNotify (pDamageExt, NullBox, 0);
	break;
d102 1
a102 1
	break;
d107 1
a107 1
DamageExtDestroy (DamagePtr pDamage, void *closure)
d109 2
a110 2
    DamageExtPtr    pDamageExt = closure;
    
d113 1
a113 1
	FreeResource (pDamageExt->id, RT_NONE);
d117 1
a117 1
DamageExtSetCritical (ClientPtr pClient, Bool critical)
d119 1
a119 1
    DamageClientPtr pDamageClient = GetDamageClient (pClient);
d122 1
a122 1
	pDamageClient->critical += critical ? 1 : -1;
d128 1
a128 1
    DamageClientPtr pDamageClient = GetDamageClient (client);
d130 1
a130 1
    register int n;
d138 10
a147 9
	rep.majorVersion = stuff->majorVersion;
	rep.minorVersion = stuff->minorVersion;
    } else {
	rep.majorVersion = SERVER_DAMAGE_MAJOR_VERSION;
	if (stuff->majorVersion == SERVER_DAMAGE_MAJOR_VERSION &&
	    stuff->minorVersion < SERVER_DAMAGE_MINOR_VERSION)
	    rep.minorVersion = stuff->minorVersion;
	else
	    rep.minorVersion = SERVER_DAMAGE_MINOR_VERSION;
d152 4
a155 4
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.majorVersion, n);
	swapl(&rep.minorVersion, n);
d157 1
a157 1
    WriteToClient(client, sizeof(xDamageQueryVersionReply), (char *)&rep);
d162 1
a162 1
ProcDamageCreate (ClientPtr client)
d164 6
a169 6
    DrawablePtr		pDrawable;
    DamageExtPtr	pDamageExt;
    DamageReportLevel	level;
    RegionPtr		pRegion;
    int			rc;
    
d175 1
a175 1
			   DixGetAttrAccess|DixReadAccess);
d177 1
a177 1
	return rc;
d181 2
a182 2
	level = DamageReportRawRegion;
	break;
d184 2
a185 2
	level = DamageReportDeltaRegion;
	break;
d187 2
a188 2
	level = DamageReportBoundingBox;
	break;
d190 2
a191 2
	level = DamageReportNonEmpty;
	break;
d193 2
a194 2
	client->errorValue = stuff->level;
	return BadValue;
d196 2
a197 2
    
    pDamageExt = malloc(sizeof (DamageExtRec));
d199 1
a199 1
	return BadAlloc;
d205 17
a221 21
    pDamageExt->pDamage = DamageCreate (DamageExtReport,
					DamageExtDestroy,
					level,
					FALSE,
					pDrawable->pScreen,
					pDamageExt);
    if (!pDamageExt->pDamage)
    {
	free(pDamageExt);
	return BadAlloc;
    }
    if (!AddResource (stuff->damage, DamageExtType, (pointer) pDamageExt))
	return BadAlloc;

    DamageSetReportAfterOp (pDamageExt->pDamage, TRUE);
    DamageRegister (pDamageExt->pDrawable, pDamageExt->pDamage);

    if (pDrawable->type == DRAWABLE_WINDOW)
    {
	pRegion = &((WindowPtr) pDrawable)->borderClip;
	DamageReportDamage(pDamageExt->pDamage, pRegion);
d228 1
a228 1
ProcDamageDestroy (ClientPtr client)
d231 1
a231 1
    DamageExtPtr    pDamageExt;
d235 1
a235 1
    FreeResource (stuff->damage, RT_NONE);
d240 1
a240 1
ProcDamageSubtract (ClientPtr client)
d243 3
a245 3
    DamageExtPtr    pDamageExt;
    RegionPtr	    pRepair;
    RegionPtr	    pParts;
d252 15
a266 16
    if (pDamageExt->level != DamageReportRawRegion)
    {
	DamagePtr   pDamage = pDamageExt->pDamage;
	if (pRepair)
	{
	    if (pParts)
		RegionIntersect(pParts, DamageRegion (pDamage), pRepair);
	    if (DamageSubtract (pDamage, pRepair))
		DamageExtReport (pDamage, DamageRegion (pDamage), (void *) pDamageExt);
	}
	else
	{
	    if (pParts)
		RegionCopy(pParts, DamageRegion (pDamage));
	    DamageEmpty (pDamage);
	}
d272 1
a272 1
ProcDamageAdd (ClientPtr client)
d275 3
a277 3
    DrawablePtr	    pDrawable;
    RegionPtr	    pRegion;
    int		    rc;
d282 1
a282 1
			   DixWriteAccess);
d284 1
a284 1
	return rc;
d298 2
a299 2
    X_DamageQueryVersion,	/* before client sends QueryVersion */
    X_DamageAdd,		/* Version 1 */
d303 2
a304 2
    
static int (*ProcDamageVector[XDamageNumberRequests])(ClientPtr) = {
d307 1
a307 3
    ProcDamageCreate,
    ProcDamageDestroy,
    ProcDamageSubtract,
d309 1
a309 3
    ProcDamageAdd,
};

d312 1
a312 1
ProcDamageDispatch (ClientPtr client)
d315 1
a315 1
    DamageClientPtr pDamageClient = GetDamageClient (client);
d318 1
a318 1
	return BadRequest;
d320 1
a320 1
	return BadRequest;
a326 1
    register int n;
d329 1
a329 1
    swaps(&stuff->length, n);
d331 2
a332 2
    swapl(&stuff->majorVersion, n);
    swapl(&stuff->minorVersion, n);
d337 1
a337 1
SProcDamageCreate (ClientPtr client)
a338 1
    register int n;
d340 2
a341 2
    
    swaps (&stuff->length, n);
d343 2
a344 2
    swapl (&stuff->damage, n);
    swapl (&stuff->drawable, n);
d349 1
a349 1
SProcDamageDestroy (ClientPtr client)
a350 1
    register int n;
d352 2
a353 2
    
    swaps (&stuff->length, n);
d355 1
a355 1
    swapl (&stuff->damage, n);
d360 1
a360 1
SProcDamageSubtract (ClientPtr client)
a361 1
    register int n;
d363 2
a364 2
    
    swaps (&stuff->length, n);
d366 3
a368 3
    swapl (&stuff->damage, n);
    swapl (&stuff->repair, n);
    swapl (&stuff->parts, n);
d373 1
a373 1
SProcDamageAdd (ClientPtr client)
a374 1
    register int n;
d377 1
a377 1
    swaps (&stuff->length, n);
d379 2
a380 2
    swapl (&stuff->drawable, n);
    swapl (&stuff->region, n);
d384 1
a384 1
static int (*SProcDamageVector[XDamageNumberRequests])(ClientPtr) = {
d387 1
a387 3
    SProcDamageCreate,
    SProcDamageDestroy,
    SProcDamageSubtract,
d389 1
a389 2
    SProcDamageAdd,
};
d392 1
a392 1
SProcDamageDispatch (ClientPtr client)
d396 1
a396 1
	return BadRequest;
d401 5
a405 7
DamageClientCallback (CallbackListPtr	*list,
		      pointer		closure,
		      pointer		data)
{
    NewClientInfoRec	*clientinfo = (NewClientInfoRec *) data;
    ClientPtr		pClient = clientinfo->client;
    DamageClientPtr	pDamageClient = GetDamageClient (pClient);
d412 2
a413 3
/*ARGSUSED*/
static void
DamageResetProc (ExtensionEntry *extEntry)
d415 1
a415 1
    DeleteCallback (&ClientStateCallback, DamageClientCallback, 0);
d419 1
a419 1
FreeDamageExt (pointer value, XID did)
d421 1
a421 1
    DamageExtPtr    pDamageExt = (DamageExtPtr) value;
d428 4
a431 5
	FreeResourceByType (pDamageExt->pDrawable->id, DamageExtWinType, TRUE);
    if (pDamageExt->pDamage)
    {
	DamageUnregister (pDamageExt->pDrawable, pDamageExt->pDamage);
	DamageDestroy (pDamageExt->pDamage);
d438 1
a438 1
FreeDamageExtWin (pointer value, XID wid)
d440 1
a440 1
    DamageExtPtr    pDamageExt = (DamageExtPtr) value;
d443 1
a443 1
	FreeResource (pDamageExt->id, RT_NONE);
d448 1
a448 2
SDamageNotifyEvent (xDamageNotifyEvent *from,
		    xDamageNotifyEvent *to)
d451 11
a461 11
    cpswaps (from->sequenceNumber, to->sequenceNumber);
    cpswapl (from->drawable, to->drawable);
    cpswapl (from->damage, to->damage);
    cpswaps (from->area.x, to->area.x);
    cpswaps (from->area.y, to->area.y);
    cpswaps (from->area.width, to->area.width);
    cpswaps (from->area.height, to->area.height);
    cpswaps (from->geometry.x, to->geometry.x);
    cpswaps (from->geometry.y, to->geometry.y);
    cpswaps (from->geometry.width, to->geometry.width);
    cpswaps (from->geometry.height, to->geometry.height);
d468 1
a468 1
    int		    s;
d471 1
a471 1
	DamageSetup (screenInfo.screens[s]);
d473 1
a473 1
    DamageExtType = CreateNewResourceType (FreeDamageExt, "DamageExt");
d475 1
a475 1
	return;
d477 1
a477 1
    DamageExtWinType = CreateNewResourceType (FreeDamageExtWin, "DamageExtWin");
d479 1
a479 7
	return;

    if (!dixRegisterPrivateKey(&DamageClientPrivateKeyRec, PRIVATE_CLIENT, sizeof (DamageClientRec)))
	return;

    if (!AddCallback (&ClientStateCallback, DamageClientCallback, 0))
	return;
d481 17
a497 10
    if ((extEntry = AddExtension(DAMAGE_NAME, XDamageNumberEvents, 
				 XDamageNumberErrors,
				 ProcDamageDispatch, SProcDamageDispatch,
				 DamageResetProc, StandardMinorOpcode)) != 0)
    {
	DamageReqCode = (unsigned char)extEntry->base;
	DamageEventBase = extEntry->eventBase;
	EventSwapVector[DamageEventBase + XDamageNotify] =
			(EventSwapPtr) SDamageNotifyEvent;
	SetResourceTypeErrorValue(DamageExtType, extEntry->errorBase + BadDamage);
@


1.6
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d226 1
a226 1
	DamageDamageRegion(pDrawable, pRegion);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d226 1
a226 1
	DamageRegionAppend(pDrawable, pRegion);
d296 1
a296 1
    DamageRegionAppend(pDrawable, pRegion);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a31 1
static int		DamageErrorBase;
d35 2
a36 4
static int DamageClientPrivateKeyIndex;
static DevPrivateKey DamageClientPrivateKey = &DamageClientPrivateKeyIndex;

#define prScreen	screenInfo.screens[0]
d50 1
a50 2
    ev.sequenceNumber = pClient->sequence;
    ev.drawable = pDrawable->id;
d68 1
a68 2
	    if (!pClient->clientGone)
		WriteEventsToClient (pClient, 1, (xEvent *) &ev);
d77 1
a77 2
	if (!pClient->clientGone)
	    WriteEventsToClient (pClient, 1, (xEvent *) &ev);
d95 1
a95 1
	DamageExtNotify (pDamageExt, REGION_RECTS(pRegion), REGION_NUM_RECTS(pRegion));
d98 1
a98 1
	DamageExtNotify (pDamageExt, REGION_EXTENTS(prScreen, pRegion), 1);
d159 1
a159 1
    return(client->noClientException);
d198 1
a198 1
    pDamageExt = xalloc (sizeof (DamageExtRec));
d202 1
d214 1
a214 1
	xfree (pDamageExt);
d220 1
d229 1
a229 1
    return (client->noClientException);
d241 1
a241 1
    return (client->noClientException);
d263 1
a263 1
		REGION_INTERSECT (prScreen, pParts, DamageRegion (pDamage), pRepair);
d270 1
a270 1
		REGION_COPY (prScreen, pParts, DamageRegion (pDamage));
d274 1
a274 1
    return (client->noClientException);
d295 1
a295 1
    REGION_TRANSLATE(pScreen, pRegion, pDrawable->x, pDrawable->y);
d297 1
a297 1
    REGION_TRANSLATE(pScreen, pRegion, -pDrawable->x, -pDrawable->y);
d299 1
a299 1
    return (client->noClientException);
d455 1
a455 1
    xfree (pDamageExt);
d504 1
a504 1
    if (!dixRequestPrivate(DamageClientPrivateKey, sizeof (DamageClientRec)))
d506 1
a516 1
	DamageErrorBase = extEntry->errorBase;
d519 1
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d28 1
a38 7
/* Version of the damage extension supported by the server, as opposed to the
 * DAMAGE_* defines from damageproto for what version the proto header
 * supports.
 */
#define SERVER_DAMAGE_MAJOR	1
#define SERVER_DAMAGE_MINOR	1

d145 1
a145 1
    if (stuff->majorVersion < SERVER_DAMAGE_MAJOR) {
d149 3
a151 3
	rep.majorVersion = SERVER_DAMAGE_MAJOR;
	if (stuff->majorVersion == SERVER_DAMAGE_MAJOR && 
	    stuff->minorVersion < SERVER_DAMAGE_MINOR)
d154 1
a154 1
	    rep.minorVersion = SERVER_DAMAGE_MINOR;
d500 1
a500 1
    DamageExtType = CreateNewResourceType (FreeDamageExt);
d504 1
a504 1
    DamageExtWinType = CreateNewResourceType (FreeDamageExtWin);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a31 1
static DevPrivateKey	DamageClientPrivateKey = &DamageClientPrivateKey;
d35 3
a94 1
#ifdef SMART_SCHEDULE
a95 1
#endif
d236 1
a236 1
	DamageDamageRegion (pDrawable, pRegion);
d306 1
a306 1
    DamageDamageRegion(pDrawable, pRegion);
@


1.1
log
@Initial revision
@
text
@a1 2
 * $Id$
 *
d29 13
a41 6
unsigned char	DamageReqCode;
int		DamageEventBase;
int		DamageErrorBase;
int		DamageClientPrivateIndex;
RESTYPE		DamageExtType;
RESTYPE		DamageExtWinType;
d151 1
a151 1
    if (stuff->majorVersion < DAMAGE_MAJOR) {
d155 3
a157 3
	rep.majorVersion = DAMAGE_MAJOR;
	if (stuff->majorVersion == DAMAGE_MAJOR && 
	    stuff->minorVersion < DAMAGE_MINOR)
d160 1
a160 1
	    rep.minorVersion = DAMAGE_MINOR;
d181 1
d187 5
a191 2
    SECURITY_VERIFY_DRAWABLE (pDrawable, stuff->drawable, client,
			      SecurityReadAccess);
d249 1
a249 1
    VERIFY_DAMAGEEXT(pDamageExt, stuff->damage, client, SecurityWriteAccess);
d263 3
a265 3
    VERIFY_DAMAGEEXT(pDamageExt, stuff->damage, client, SecurityWriteAccess);
    VERIFY_REGION_OR_NONE(pRepair, stuff->repair, client, SecurityWriteAccess);
    VERIFY_REGION_OR_NONE(pParts, stuff->parts, client, SecurityWriteAccess);
d287 25
d315 1
a315 1
    X_DamageSubtract,		/* Version 1 */
d320 1
a320 1
int	(*ProcDamageVector[XDamageNumberRequests])(ClientPtr) = {
d326 2
d396 14
a409 1
int	(*SProcDamageVector[XDamageNumberRequests])(ClientPtr) = {
d415 2
d479 1
a479 1
void
d514 1
a514 3
    DamageClientPrivateIndex = AllocateClientPrivateIndex ();
    if (!AllocateClientPrivate (DamageClientPrivateIndex, 
				sizeof (DamageClientRec)))
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d31 6
a36 13
static unsigned char	DamageReqCode;
static int		DamageEventBase;
static int		DamageErrorBase;
static int		DamageClientPrivateIndex;
static RESTYPE		DamageExtType;
static RESTYPE		DamageExtWinType;

/* Version of the damage extension supported by the server, as opposed to the
 * DAMAGE_* defines from damageproto for what version the proto header
 * supports.
 */
#define SERVER_DAMAGE_MAJOR	1
#define SERVER_DAMAGE_MINOR	1
d146 1
a146 1
    if (stuff->majorVersion < SERVER_DAMAGE_MAJOR) {
d150 3
a152 3
	rep.majorVersion = SERVER_DAMAGE_MAJOR;
	if (stuff->majorVersion == SERVER_DAMAGE_MAJOR && 
	    stuff->minorVersion < SERVER_DAMAGE_MINOR)
d155 1
a155 1
	    rep.minorVersion = SERVER_DAMAGE_MINOR;
a175 1
    int			rc;
d181 2
a182 5
    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
			   DixReadAccess);
    if (rc != Success)
	return rc;

d240 1
a240 1
    VERIFY_DAMAGEEXT(pDamageExt, stuff->damage, client, DixWriteAccess);
d254 3
a256 3
    VERIFY_DAMAGEEXT(pDamageExt, stuff->damage, client, DixWriteAccess);
    VERIFY_REGION_OR_NONE(pRepair, stuff->repair, client, DixWriteAccess);
    VERIFY_REGION_OR_NONE(pParts, stuff->parts, client, DixWriteAccess);
a277 25
static int
ProcDamageAdd (ClientPtr client)
{
    REQUEST(xDamageAddReq);
    DrawablePtr	    pDrawable;
    RegionPtr	    pRegion;
    int		    rc;

    REQUEST_SIZE_MATCH(xDamageAddReq);
    VERIFY_REGION(pRegion, stuff->region, client, DixWriteAccess);
    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
			   DixReadAccess);
    if (rc != Success)
	return rc;

    /* The region is relative to the drawable origin, so translate it out to
     * screen coordinates like damage expects.
     */
    REGION_TRANSLATE(pScreen, pRegion, pDrawable->x, pDrawable->y);
    DamageDamageRegion(pDrawable, pRegion);
    REGION_TRANSLATE(pScreen, pRegion, -pDrawable->x, -pDrawable->y);

    return (client->noClientException);
}

d281 1
a281 1
    X_DamageAdd,		/* Version 1 */
d286 1
a286 1
static int (*ProcDamageVector[XDamageNumberRequests])(ClientPtr) = {
a291 2
/*************** Version 1.1 ****************/
    ProcDamageAdd,
d360 1
a360 14
static int
SProcDamageAdd (ClientPtr client)
{
    register int n;
    REQUEST(xDamageAddReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xDamageSubtractReq);
    swapl (&stuff->drawable, n);
    swapl (&stuff->region, n);
    return (*ProcDamageVector[stuff->damageReqType]) (client);
}

static int (*SProcDamageVector[XDamageNumberRequests])(ClientPtr) = {
a365 2
/*************** Version 1.1 ****************/
    SProcDamageAdd,
d428 1
a428 1
static void
@

