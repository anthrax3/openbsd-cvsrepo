head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.10
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.6
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.8
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.6
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	cVXoV5PxI8YrEaVA;

1.11
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.12.18.16.08.59;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.12;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.06.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.06.36;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.12.13.21.06.24;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright © 2007 Daniel Stone
 * Copyright © 2007 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Author: Daniel Stone <daniel@@fooishbar.org>
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <dbus/dbus.h>
#include <hal/libhal.h>
#include <string.h>
#include <sys/select.h>

#include "dbus-core.h"
#include "input.h"
#include "inputstr.h"
#include "hotplug.h"
#include "config-backends.h"
#include "os.h"

#define LIBHAL_PROP_KEY "input.x11_options."
#define LIBHAL_XKB_PROP_KEY "input.xkb."

struct config_hal_info {
    DBusConnection *system_bus;
    LibHalContext *hal_ctx;
};

/* Used for special handling of xkb options. */
struct xkb_options {
    char *layout;
    char *model;
    char *rules;
    char *variant;
    char *options;
};

static void
device_removed(LibHalContext * ctx, const char *udi)
{
    char *value;

    if (asprintf(&value, "hal:%s", udi) == -1)
        return;

    remove_devices("hal", value);

    free(value);
}

static char *
get_prop_string(LibHalContext * hal_ctx, const char *udi, const char *name)
{
    char *prop, *ret;

    prop = libhal_device_get_property_string(hal_ctx, udi, name, NULL);
    LogMessageVerb(X_INFO, 10, "config/hal: getting %s on %s returned %s\n",
                   name, udi, prop ? prop : "(null)");
    if (prop) {
        ret = strdup(prop);
        libhal_free_string(prop);
    }
    else {
        return NULL;
    }

    return ret;
}

static char *
get_prop_string_array(LibHalContext * hal_ctx, const char *udi,
                      const char *prop)
{
    char **props, *ret, *str;
    int i, len = 0;

    props = libhal_device_get_property_strlist(hal_ctx, udi, prop, NULL);
    if (props) {
        for (i = 0; props[i]; i++)
            len += strlen(props[i]);

        ret = calloc(sizeof(char), len + i);    /* i - 1 commas, 1 NULL */
        if (!ret) {
            libhal_free_string_array(props);
            return NULL;
        }

        str = ret;
        for (i = 0; props[i]; i++) {
            strcpy(str, props[i]);
            str += strlen(props[i]);
            *str++ = ',';
        }
        *(str - 1) = '\0';

        libhal_free_string_array(props);
    }
    else {
        return NULL;
    }

    return ret;
}

static void
device_added(LibHalContext * hal_ctx, const char *udi)
{
    char *path = NULL, *driver = NULL, *name = NULL, *config_info = NULL;
    char *hal_tags, *parent;
    InputOption *input_options = NULL;
    InputAttributes attrs = { 0 };
    DeviceIntPtr dev = NULL;
    DBusError error;
    struct xkb_options xkb_opts = { 0 };
    int rc;

    LibHalPropertySet *set = NULL;
    LibHalPropertySetIterator set_iter;
    char *psi_key = NULL, *tmp_val;

    dbus_error_init(&error);

    driver = get_prop_string(hal_ctx, udi, "input.x11_driver");
    if (!driver) {
        /* verbose, don't tell the user unless they _want_ to see it */
        LogMessageVerb(X_INFO, 7,
                       "config/hal: no driver specified for device %s\n", udi);
        goto unwind;
    }

    path = get_prop_string(hal_ctx, udi, "input.device");
    if (!path) {
        LogMessage(X_WARNING,
                   "config/hal: no driver or path specified for %s\n", udi);
        goto unwind;
    }
    attrs.device = strdup(path);

    name = get_prop_string(hal_ctx, udi, "info.product");
    if (!name)
        name = strdup("(unnamed)");
    else
        attrs.product = strdup(name);

    attrs.vendor = get_prop_string(hal_ctx, udi, "info.vendor");
    hal_tags = get_prop_string(hal_ctx, udi, "input.tags");
    attrs.tags = xstrtokenize(hal_tags, ",");
    free(hal_tags);

    if (libhal_device_query_capability(hal_ctx, udi, "input.keys", NULL))
        attrs.flags |= ATTR_KEYBOARD;
    if (libhal_device_query_capability(hal_ctx, udi, "input.mouse", NULL))
        attrs.flags |= ATTR_POINTER;
    if (libhal_device_query_capability(hal_ctx, udi, "input.joystick", NULL))
        attrs.flags |= ATTR_JOYSTICK;
    if (libhal_device_query_capability(hal_ctx, udi, "input.tablet", NULL))
        attrs.flags |= ATTR_TABLET;
    if (libhal_device_query_capability(hal_ctx, udi, "input.touchpad", NULL))
        attrs.flags |= ATTR_TOUCHPAD;
    if (libhal_device_query_capability(hal_ctx, udi, "input.touchscreen", NULL))
        attrs.flags |= ATTR_TOUCHSCREEN;

    parent = get_prop_string(hal_ctx, udi, "info.parent");
    if (parent) {
        int usb_vendor, usb_product;
        char *old_parent;

        /* construct USB ID in lowercase - "0000:ffff" */
        usb_vendor = libhal_device_get_property_int(hal_ctx, parent,
                                                    "usb.vendor_id", NULL);
        LogMessageVerb(X_INFO, 10,
                       "config/hal: getting usb.vendor_id on %s "
                       "returned %04x\n", parent, usb_vendor);
        usb_product = libhal_device_get_property_int(hal_ctx, parent,
                                                     "usb.product_id", NULL);
        LogMessageVerb(X_INFO, 10,
                       "config/hal: getting usb.product_id on %s "
                       "returned %04x\n", parent, usb_product);
        if (usb_vendor && usb_product)
            if (asprintf(&attrs.usb_id, "%04x:%04x", usb_vendor, usb_product)
                == -1)
                attrs.usb_id = NULL;

        attrs.pnp_id = get_prop_string(hal_ctx, parent, "pnp.id");
        old_parent = parent;

        while (!attrs.pnp_id &&
               (parent = get_prop_string(hal_ctx, parent, "info.parent"))) {
            attrs.pnp_id = get_prop_string(hal_ctx, parent, "pnp.id");

            free(old_parent);
            old_parent = parent;
        }

        free(old_parent);
    }

    input_options = input_option_new(NULL, "_source", "server/hal");
    if (!input_options) {
        LogMessage(X_ERROR,
                   "config/hal: couldn't allocate first key/value pair\n");
        goto unwind;
    }

    /* most drivers use device.. not path. evdev uses both however, but the
     * path version isn't documented apparently. support both for now. */
    input_options = input_option_new(input_options, "path", path);
    input_options = input_option_new(input_options, "device", path);

    input_options = input_option_new(input_options, "driver", driver);
    input_options = input_option_new(input_options, "name", name);

    if (asprintf(&config_info, "hal:%s", udi) == -1) {
        config_info = NULL;
        LogMessage(X_ERROR, "config/hal: couldn't allocate name\n");
        goto unwind;
    }

    /* Check for duplicate devices */
    if (device_is_duplicate(config_info)) {
        LogMessage(X_WARNING,
                   "config/hal: device %s already added. Ignoring.\n", name);
        goto unwind;
    }

    /* ok, grab options from hal.. iterate through all properties
     * and lets see if any of them are options that we can add */
    set = libhal_device_get_all_properties(hal_ctx, udi, &error);

    if (!set) {
        LogMessage(X_ERROR,
                   "config/hal: couldn't get property list for %s: %s (%s)\n",
                   udi, error.name, error.message);
        goto unwind;
    }

    libhal_psi_init(&set_iter, set);
    while (libhal_psi_has_more(&set_iter)) {
        /* we are looking for supported keys.. extract and add to options */
        psi_key = libhal_psi_get_key(&set_iter);

        if (psi_key) {

            /* normal options first (input.x11_options.<propname>) */
            if (!strncasecmp
                (psi_key, LIBHAL_PROP_KEY, sizeof(LIBHAL_PROP_KEY) - 1)) {
                char *tmp;

                /* only support strings for all values */
                tmp_val = get_prop_string(hal_ctx, udi, psi_key);

                if (tmp_val) {

                    /* xkb needs special handling. HAL specs include
                     * input.xkb.xyz options, but the x11-input.fdi specifies
                     * input.x11_options.Xkbxyz options. By default, we use
                     * the former, unless the specific X11 ones are specified.
                     * Since we can't predict the order in which the keys
                     * arrive, we need to store them.
                     */
                    if ((tmp = strcasestr(psi_key, "xkb")) && strlen(tmp) >= 4) {
                        if (!strcasecmp(&tmp[3], "layout")) {
                            free(xkb_opts.layout);
                            xkb_opts.layout = strdup(tmp_val);
                        }
                        else if (!strcasecmp(&tmp[3], "model")) {
                            free(xkb_opts.model);
                            xkb_opts.model = strdup(tmp_val);
                        }
                        else if (!strcasecmp(&tmp[3], "rules")) {
                            free(xkb_opts.rules);
                            xkb_opts.rules = strdup(tmp_val);
                        }
                        else if (!strcasecmp(&tmp[3], "variant")) {
                            free(xkb_opts.variant);
                            xkb_opts.variant = strdup(tmp_val);
                        }
                        else if (!strcasecmp(&tmp[3], "options")) {
                            free(xkb_opts.options);
                            xkb_opts.options = strdup(tmp_val);
                        }
                    }
                    else {
                        /* all others */
                        input_options =
                            input_option_new(input_options,
                                             psi_key + sizeof(LIBHAL_PROP_KEY) -
                                             1, tmp_val);
                        free(tmp_val);
                    }
                }
                else {
                    /* server 1.4 had xkb_options as strlist. */
                    if ((tmp = strcasestr(psi_key, "xkb")) &&
                        (strlen(tmp) >= 4) &&
                        (!strcasecmp(&tmp[3], "options")) &&
                        (tmp_val =
                         get_prop_string_array(hal_ctx, udi, psi_key))) {
                        free(xkb_opts.options);
                        xkb_opts.options = strdup(tmp_val);
                    }
                }
            }
            else if (!strncasecmp
                     (psi_key, LIBHAL_XKB_PROP_KEY,
                      sizeof(LIBHAL_XKB_PROP_KEY) - 1)) {
                char *tmp;

                /* only support strings for all values */
                tmp_val = get_prop_string(hal_ctx, udi, psi_key);

                if (tmp_val && strlen(psi_key) >= sizeof(LIBHAL_XKB_PROP_KEY)) {

                    tmp = &psi_key[sizeof(LIBHAL_XKB_PROP_KEY) - 1];

                    if (!strcasecmp(tmp, "layout")) {
                        if (!xkb_opts.layout)
                            xkb_opts.layout = strdup(tmp_val);
                    }
                    else if (!strcasecmp(tmp, "rules")) {
                        if (!xkb_opts.rules)
                            xkb_opts.rules = strdup(tmp_val);
                    }
                    else if (!strcasecmp(tmp, "variant")) {
                        if (!xkb_opts.variant)
                            xkb_opts.variant = strdup(tmp_val);
                    }
                    else if (!strcasecmp(tmp, "model")) {
                        if (!xkb_opts.model)
                            xkb_opts.model = strdup(tmp_val);
                    }
                    else if (!strcasecmp(tmp, "options")) {
                        if (!xkb_opts.options)
                            xkb_opts.options = strdup(tmp_val);
                    }
                    free(tmp_val);
                }
                else {
                    /* server 1.4 had xkb options as strlist */
                    tmp_val = get_prop_string_array(hal_ctx, udi, psi_key);
                    if (tmp_val &&
                        strlen(psi_key) >= sizeof(LIBHAL_XKB_PROP_KEY)) {
                        tmp = &psi_key[sizeof(LIBHAL_XKB_PROP_KEY) - 1];
                        if (!strcasecmp(tmp, ".options") && (!xkb_opts.options))
                            xkb_opts.options = strdup(tmp_val);
                    }
                    free(tmp_val);
                }
            }
        }

        /* psi_key doesn't need to be freed */
        libhal_psi_next(&set_iter);
    }

    /* Now add xkb options */
    if (xkb_opts.layout)
        input_options =
            input_option_new(input_options, "xkb_layout", xkb_opts.layout);
    if (xkb_opts.rules)
        input_options =
            input_option_new(input_options, "xkb_rules", xkb_opts.rules);
    if (xkb_opts.variant)
        input_options =
            input_option_new(input_options, "xkb_variant", xkb_opts.variant);
    if (xkb_opts.model)
        input_options =
            input_option_new(input_options, "xkb_model", xkb_opts.model);
    if (xkb_opts.options)
        input_options =
            input_option_new(input_options, "xkb_options", xkb_opts.options);
    input_options = input_option_new(input_options, "config_info", config_info);

    /* this isn't an error, but how else do you output something that the user can see? */
    LogMessage(X_INFO, "config/hal: Adding input device %s\n", name);
    if ((rc = NewInputDeviceRequest(input_options, &attrs, &dev)) != Success) {
        LogMessage(X_ERROR, "config/hal: NewInputDeviceRequest failed (%d)\n",
                   rc);
        dev = NULL;
        goto unwind;
    }

 unwind:
    if (set)
        libhal_free_property_set(set);
    free(path);
    free(driver);
    free(name);
    free(config_info);
    input_option_free_list(&input_options);

    free(attrs.product);
    free(attrs.vendor);
    free(attrs.device);
    free(attrs.pnp_id);
    free(attrs.usb_id);
    if (attrs.tags) {
        char **tag = attrs.tags;

        while (*tag) {
            free(*tag);
            tag++;
        }
        free(attrs.tags);
    }

    free(xkb_opts.layout);
    free(xkb_opts.rules);
    free(xkb_opts.model);
    free(xkb_opts.variant);
    free(xkb_opts.options);

    dbus_error_free(&error);

    return;
}

static void
disconnect_hook(void *data)
{
    DBusError error;
    struct config_hal_info *info = data;

    if (info->hal_ctx) {
        if (dbus_connection_get_is_connected(info->system_bus)) {
            dbus_error_init(&error);
            if (!libhal_ctx_shutdown(info->hal_ctx, &error))
                LogMessage(X_WARNING,
                           "config/hal: disconnect_hook couldn't shut down context: %s (%s)\n",
                           error.name, error.message);
            dbus_error_free(&error);
        }
        libhal_ctx_free(info->hal_ctx);
    }

    info->hal_ctx = NULL;
    info->system_bus = NULL;
}

static BOOL
connect_and_register(DBusConnection * connection, struct config_hal_info *info)
{
    DBusError error;
    char **devices;
    int num_devices, i;

    if (info->hal_ctx)
        return TRUE;            /* already registered, pretend we did something */

    info->system_bus = connection;

    dbus_error_init(&error);

    info->hal_ctx = libhal_ctx_new();
    if (!info->hal_ctx) {
        LogMessage(X_ERROR, "config/hal: couldn't create HAL context\n");
        goto out_err;
    }

    if (!libhal_ctx_set_dbus_connection(info->hal_ctx, info->system_bus)) {
        LogMessage(X_ERROR,
                   "config/hal: couldn't associate HAL context with bus\n");
        goto out_err;
    }
    if (!libhal_ctx_init(info->hal_ctx, &error)) {
        LogMessage(X_ERROR,
                   "config/hal: couldn't initialise context: %s (%s)\n",
                   error.name ? error.name : "unknown error",
                   error.message ? error.message : "null");
        goto out_err;
    }
    if (!libhal_device_property_watch_all(info->hal_ctx, &error)) {
        LogMessage(X_ERROR,
                   "config/hal: couldn't watch all properties: %s (%s)\n",
                   error.name ? error.name : "unknown error",
                   error.message ? error.message : "null");
        goto out_ctx;
    }
    libhal_ctx_set_device_added(info->hal_ctx, device_added);
    libhal_ctx_set_device_removed(info->hal_ctx, device_removed);

    devices = libhal_find_device_by_capability(info->hal_ctx, "input",
                                               &num_devices, &error);
    /* FIXME: Get default devices if error is set. */
    if (dbus_error_is_set(&error)) {
        LogMessage(X_ERROR, "config/hal: couldn't find input device: %s (%s)\n",
                   error.name ? error.name : "unknown error",
                   error.message ? error.message : "null");
        goto out_ctx;
    }
    for (i = 0; i < num_devices; i++)
        device_added(info->hal_ctx, devices[i]);
    libhal_free_string_array(devices);

    dbus_error_free(&error);

    return TRUE;

 out_ctx:
    dbus_error_free(&error);

    if (!libhal_ctx_shutdown(info->hal_ctx, &error)) {
        LogMessage(X_WARNING,
                   "config/hal: couldn't shut down context: %s (%s)\n",
                   error.name ? error.name : "unknown error",
                   error.message ? error.message : "null");
        dbus_error_free(&error);
    }

 out_err:
    dbus_error_free(&error);

    if (info->hal_ctx) {
        libhal_ctx_free(info->hal_ctx);
    }

    info->hal_ctx = NULL;
    info->system_bus = NULL;

    return FALSE;
}

/**
 * Handle NewOwnerChanged signals to deal with HAL startup at X server runtime.
 *
 * NewOwnerChanged is send once when HAL shuts down, and once again when it
 * comes back up. Message has three arguments, first is the name
 * (org.freedesktop.Hal), the second one is the old owner, third one is new
 * owner.
 */
static DBusHandlerResult
ownerchanged_handler(DBusConnection * connection, DBusMessage * message,
                     void *data)
{
    int ret = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;

    if (dbus_message_is_signal(message,
                               "org.freedesktop.DBus", "NameOwnerChanged")) {
        DBusError error;
        char *name, *old_owner, *new_owner;

        dbus_error_init(&error);
        dbus_message_get_args(message, &error,
                              DBUS_TYPE_STRING, &name,
                              DBUS_TYPE_STRING, &old_owner,
                              DBUS_TYPE_STRING, &new_owner, DBUS_TYPE_INVALID);

        if (dbus_error_is_set(&error)) {
            ErrorF
                ("[config/hal] failed to get NameOwnerChanged args: %s (%s)\n",
                 error.name, error.message);
        }
        else if (name && strcmp(name, "org.freedesktop.Hal") == 0) {

            if (!old_owner || !strlen(old_owner)) {
                DebugF("[config/hal] HAL startup detected.\n");
                if (connect_and_register
                    (connection, (struct config_hal_info *) data))
                    dbus_connection_unregister_object_path(connection,
                                                           "/org/freedesktop/DBus");
                else
                    ErrorF("[config/hal] Failed to connect to HAL bus.\n");
            }

            ret = DBUS_HANDLER_RESULT_HANDLED;
        }
        dbus_error_free(&error);
    }

    return ret;
}

/**
 * Register a handler for the NameOwnerChanged signal.
 */
static BOOL
listen_for_startup(DBusConnection * connection, void *data)
{
    DBusObjectPathVTable vtable = {.message_function = ownerchanged_handler, };
    DBusError error;
    const char MATCH_RULE[] = "sender='org.freedesktop.DBus',"
        "interface='org.freedesktop.DBus',"
        "type='signal',"
        "path='/org/freedesktop/DBus'," "member='NameOwnerChanged'";
    int rc = FALSE;

    dbus_error_init(&error);
    dbus_bus_add_match(connection, MATCH_RULE, &error);
    if (!dbus_error_is_set(&error)) {
        if (dbus_connection_register_object_path(connection,
                                                 "/org/freedesktop/DBus",
                                                 &vtable, data))
            rc = TRUE;
        else
            ErrorF("[config/hal] cannot register object path.\n");
    }
    else {
        ErrorF("[config/hal] couldn't add match rule: %s (%s)\n", error.name,
               error.message);
        ErrorF("[config/hal] cannot detect a HAL startup.\n");
    }

    dbus_error_free(&error);

    return rc;
}

static void
connect_hook(DBusConnection * connection, void *data)
{
    struct config_hal_info *info = data;

    if (listen_for_startup(connection, data) &&
        connect_and_register(connection, info))
        dbus_connection_unregister_object_path(connection,
                                               "/org/freedesktop/DBus");

    return;
}

static struct config_hal_info hal_info;

static struct dbus_core_hook hook = {
    .connect = connect_hook,
    .disconnect = disconnect_hook,
    .data = &hal_info,
};

int
config_hal_init(void)
{
    memset(&hal_info, 0, sizeof(hal_info));
    hal_info.system_bus = NULL;
    hal_info.hal_ctx = NULL;

    if (!dbus_core_add_hook(&hook)) {
        LogMessage(X_ERROR, "config/hal: failed to add D-Bus hook\n");
        return 0;
    }

    /* verbose message */
    LogMessageVerb(X_INFO, 7, "config/hal: initialized\n");

    return 1;
}

void
config_hal_fini(void)
{
    dbus_core_remove_hook(&hook);
}
@


1.11
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d36 1
d645 1
a645 1
static struct config_dbus_core_hook hook = {
d658 1
a658 1
    if (!config_dbus_core_add_hook(&hook)) {
d672 1
a672 1
    config_dbus_core_remove_hook(&hook);
@


1.10
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d187 1
a187 2

        attrs.pnp_id = get_prop_string(hal_ctx, parent, "pnp.id");
d205 12
a216 1
        free(parent);
@


1.9
log
@Bugfix Update to xserver 1.11.3
@
text
@a41 1

a44 1

d52 5
a56 5
    char* layout;
    char* model;
    char* rules;
    char* variant;
    char* options;
d60 1
a60 1
device_removed(LibHalContext *ctx, const char *udi)
d64 1
a64 1
    if (asprintf (&value, "hal:%s", udi) == -1)
d73 1
a73 1
get_prop_string(LibHalContext *hal_ctx, const char *udi, const char *name)
d78 2
a79 1
    LogMessageVerb(X_INFO, 10, "config/hal: getting %s on %s returned %s\n", name, udi, prop ? prop : "(null)");
d92 2
a93 1
get_prop_string_array(LibHalContext *hal_ctx, const char *udi, const char *prop)
d103 1
a103 1
        ret = calloc(sizeof(char), len + i); /* i - 1 commas, 1 NULL */
d115 1
a115 1
        *(str-1) = '\0';
d127 1
a127 1
device_added(LibHalContext *hal_ctx, const char *udi)
d131 2
a132 2
    InputOption *options = NULL, *tmpo = NULL;
    InputAttributes attrs = {0};
d135 1
a135 1
    struct xkb_options xkb_opts = {0};
d139 1
a139 1
	LibHalPropertySetIterator set_iter;
a141 1

d145 1
a145 1
    if (!driver){
d147 2
a148 1
        LogMessageVerb(X_INFO,7,"config/hal: no driver specified for device %s\n", udi);
d154 2
a155 1
        LogMessage(X_WARNING,"config/hal: no driver or path specified for %s\n", udi);
d203 2
a204 2
		== -1)
		attrs.usb_id = NULL;
d209 4
a212 10
    options = calloc(sizeof(*options), 1);
    if (!options){
        LogMessage(X_ERROR, "config/hal: couldn't allocate space for input options!\n");
        goto unwind;
    }

    options->key = strdup("_source");
    options->value = strdup("server/hal");
    if (!options->key || !options->value) {
        LogMessage(X_ERROR, "config/hal: couldn't allocate first key/value pair\n");
d218 2
a219 2
    add_option(&options, "path", path);
    add_option(&options, "device", path);
d221 2
a222 2
    add_option(&options, "driver", driver);
    add_option(&options, "name", name);
d224 1
a224 1
    if (asprintf (&config_info, "hal:%s", udi) == -1) {
d231 3
a233 3
    if (device_is_duplicate(config_info))
    {
        LogMessage(X_WARNING, "config/hal: device %s already added. Ignoring.\n", name);
d238 1
a238 1
    * and lets see if any of them are options that we can add */
d242 3
a244 2
        LogMessage(X_ERROR, "config/hal: couldn't get property list for %s: %s (%s)\n",
               udi, error.name, error.message);
d248 1
a248 1
    libhal_psi_init(&set_iter,set);
d253 1
a253 1
        if (psi_key){
d256 3
a258 2
            if (!strncasecmp(psi_key, LIBHAL_PROP_KEY, sizeof(LIBHAL_PROP_KEY)-1)){
                char* tmp;
d263 1
a263 1
                if (tmp_val){
d272 2
a273 4
                    if ((tmp = strcasestr(psi_key, "xkb")) && strlen(tmp) >= 4)
                    {
                        if (!strcasecmp(&tmp[3], "layout"))
                        {
d276 2
a277 2
                        } else if (!strcasecmp(&tmp[3], "model"))
                        {
d280 2
a281 2
                        } else if (!strcasecmp(&tmp[3], "rules"))
                        {
d284 2
a285 2
                        } else if (!strcasecmp(&tmp[3], "variant"))
                        {
d288 2
a289 2
                        } else if (!strcasecmp(&tmp[3], "options"))
                        {
d293 2
a294 2
                    } else
                    {
d296 4
a299 1
                        add_option(&options, psi_key + sizeof(LIBHAL_PROP_KEY)-1, tmp_val);
d302 2
a303 2
                } else
                {
d308 2
a309 2
                        (tmp_val = get_prop_string_array(hal_ctx, udi, psi_key)))
                    {
d314 5
a318 2
            } else if (!strncasecmp(psi_key, LIBHAL_XKB_PROP_KEY, sizeof(LIBHAL_XKB_PROP_KEY)-1)){
                char* tmp;
d327 1
a327 2
                    if (!strcasecmp(tmp, "layout"))
                    {
d330 2
a331 2
                    } else if (!strcasecmp(tmp, "rules"))
                    {
d334 2
a335 2
                    } else if (!strcasecmp(tmp, "variant"))
                    {
d338 2
a339 2
                    } else if (!strcasecmp(tmp, "model"))
                    {
d342 2
a343 2
                    } else if (!strcasecmp(tmp, "options"))
                    {
d348 2
a349 2
                } else
                {
d352 2
a353 2
                    if (tmp_val && strlen(psi_key) >= sizeof(LIBHAL_XKB_PROP_KEY))
                    {
a366 1

d369 2
a370 1
        add_option(&options, "xkb_layout", xkb_opts.layout);
d372 2
a373 1
        add_option(&options, "xkb_rules", xkb_opts.rules);
d375 2
a376 1
        add_option(&options, "xkb_variant", xkb_opts.variant);
d378 2
a379 1
        add_option(&options, "xkb_model", xkb_opts.model);
d381 3
a383 2
        add_option(&options, "xkb_options", xkb_opts.options);
    add_option(&options, "config_info", config_info);
d387 3
a389 2
    if ((rc = NewInputDeviceRequest(options, &attrs, &dev)) != Success) {
        LogMessage(X_ERROR, "config/hal: NewInputDeviceRequest failed (%d)\n", rc);
d394 1
a394 1
unwind:
d401 1
a401 6
    while ((tmpo = options)) {
        options = tmpo->next;
        free(tmpo->key);        /* NULL if dev != NULL */
        free(tmpo->value);      /* NULL if dev != NULL */
        free(tmpo);
    }
d410 1
d439 3
a441 2
                LogMessage(X_WARNING, "config/hal: disconnect_hook couldn't shut down context: %s (%s)\n",
                        error.name, error.message);
d452 1
a452 1
connect_and_register(DBusConnection *connection, struct config_hal_info *info)
d459 1
a459 1
        return TRUE; /* already registered, pretend we did something */
d472 2
a473 1
        LogMessage(X_ERROR, "config/hal: couldn't associate HAL context with bus\n");
d477 4
a480 3
        LogMessage(X_ERROR, "config/hal: couldn't initialise context: %s (%s)\n",
		   error.name ? error.name : "unknown error",
		   error.message ? error.message : "null");
d484 4
a487 3
        LogMessage(X_ERROR, "config/hal: couldn't watch all properties: %s (%s)\n",
		   error.name ? error.name : "unknown error",
		   error.message ? error.message : "null");
d498 2
a499 2
		   error.name ? error.name : "unknown error",
		   error.message ? error.message : "null");
d510 1
a510 1
out_ctx:
d514 4
a517 3
        LogMessage(X_WARNING, "config/hal: couldn't shut down context: %s (%s)\n",
                error.name ? error.name : "unknown error",
                error.message ? error.message : "null");
d521 1
a521 1
out_err:
a533 1

d543 2
a544 1
ownerchanged_handler(DBusConnection *connection, DBusMessage *message, void *data)
d549 1
a549 2
                               "org.freedesktop.DBus",
                               "NameOwnerChanged")) {
d557 1
a557 2
                              DBUS_TYPE_STRING, &new_owner,
                              DBUS_TYPE_INVALID);
d560 5
a564 3
            ErrorF("[config/hal] failed to get NameOwnerChanged args: %s (%s)\n",
                   error.name, error.message);
        } else if (name && strcmp(name, "org.freedesktop.Hal") == 0) {
d568 2
a569 1
                if (connect_and_register(connection, (struct config_hal_info*)data))
d571 1
a571 1
                                                     "/org/freedesktop/DBus");
d588 1
a588 1
listen_for_startup(DBusConnection *connection, void *data)
d590 1
a590 1
    DBusObjectPathVTable vtable = { .message_function = ownerchanged_handler, };
d593 3
a595 4
                              "interface='org.freedesktop.DBus',"
                              "type='signal',"
                              "path='/org/freedesktop/DBus',"
                              "member='NameOwnerChanged'";
d602 2
a603 3
                                                  "/org/freedesktop/DBus",
                                                  &vtable,
                                                  data))
d607 2
a608 1
    } else {
d610 1
a610 1
                error.message);
d620 1
a620 1
connect_hook(DBusConnection *connection, void *data)
d633 1
d653 1
a653 1
    LogMessageVerb(X_INFO,7,"config/hal: initialized\n");
@


1.8
log
@Update to xserver 1.11.2
@
text
@d358 1
@


1.7
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d66 1
a66 2
    value = malloc(strlen(udi) + 5); /* "hal:" + NULL */
    if (!value)
a67 1
    sprintf(value, "hal:%s", udi);
d201 3
a203 1
            attrs.usb_id = Xprintf("%04x:%04x", usb_vendor, usb_product);
d229 2
a230 2
    config_info = malloc(strlen(udi) + 5); /* "hal:" and NULL */
    if (!config_info) {
a233 1
    sprintf(config_info, "hal:%s", udi);
d378 1
a387 5
    for (; dev; dev = dev->next){
        free(dev->config_info);
        dev->config_info = strdup(config_info);
    }

d395 1
a395 1
    while (!dev && (tmpo = options)) {
d397 2
a398 2
        free(tmpo->key);
        free(tmpo->value);
@


1.6
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d66 1
a66 1
    value = xalloc(strlen(udi) + 5); /* "hal:" + NULL */
d73 1
a73 1
    xfree(value);
d84 1
a84 1
        ret = xstrdup(prop);
d105 1
a105 1
        ret = xcalloc(sizeof(char), len + i); /* i - 1 commas, 1 NULL */
d132 1
d159 1
a159 1
    attrs.device = xstrdup(path);
d163 1
a163 1
        name = xstrdup("(unnamed)");
d165 1
a165 1
        attrs.product = xstrdup(name);
d168 3
a170 1
    attrs.tags = xstrtokenize(get_prop_string(hal_ctx, udi, "input.tags"), ",");
d185 24
a208 1
    options = xcalloc(sizeof(*options), 1);
d214 2
a215 2
    options->key = xstrdup("_source");
    options->value = xstrdup("server/hal");
d229 1
a229 1
    config_info = xalloc(strlen(udi) + 5); /* "hal:" and NULL */
d280 1
a280 2
                            if (xkb_opts.layout)
                                xfree(xkb_opts.layout);
d284 1
a284 2
                            if (xkb_opts.model)
                                xfree(xkb_opts.model);
d288 1
a288 2
                            if (xkb_opts.rules)
                                xfree(xkb_opts.rules);
d292 1
a292 2
                            if (xkb_opts.variant)
                                xfree(xkb_opts.variant);
d296 1
a296 2
                            if (xkb_opts.options)
                                xfree(xkb_opts.options);
d303 1
a303 1
                        xfree(tmp_val);
d313 1
a313 2
                        if (xkb_opts.options)
                            xfree(xkb_opts.options);
d348 1
a348 1
                    xfree(tmp_val);
d389 2
a390 3
        if (dev->config_info)
            xfree(dev->config_info);
        dev->config_info = xstrdup(config_info);
d396 4
a399 8
    if (path)
        xfree(path);
    if (driver)
        xfree(driver);
    if (name)
        xfree(name);
    if (config_info)
        xfree(config_info);
d402 3
a404 3
        xfree(tmpo->key);
        xfree(tmpo->value);
        xfree(tmpo);
d407 5
a411 3
    xfree(attrs.product);
    xfree(attrs.vendor);
    xfree(attrs.device);
d415 1
a415 1
            xfree(*tag);
d418 1
a418 1
        xfree(attrs.tags);
d421 5
a425 10
    if (xkb_opts.layout)
        xfree(xkb_opts.layout);
    if (xkb_opts.rules)
        xfree(xkb_opts.rules);
    if (xkb_opts.model)
        xfree(xkb_opts.model);
    if (xkb_opts.variant)
        xfree(xkb_opts.variant);
    if (xkb_opts.options)
        xfree(xkb_opts.options);
d650 1
a650 1
    LogMessageVerb(X_INFO,7,"config/hal: initialized");
@


1.5
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a60 15

static void
remove_device(DeviceIntPtr dev)
{
    /* this only gets called for devices that have already been added */
    LogMessage(X_INFO, "config/hal: removing device %s\n", dev->name);

    /* Call PIE here so we don't try to dereference a device that's
     * already been removed. */
    OsBlockSignals();
    ProcessInputEvents();
    DeleteInputDeviceRequest(dev);
    OsReleaseSignals();
}

a63 1
    DeviceIntPtr dev, next;
d71 1
a71 10
    for (dev = inputInfo.devices; dev; dev = next) {
	next = dev->next;
        if (dev->config_info && strcmp(dev->config_info, value) == 0)
            remove_device(dev);
    }
    for (dev = inputInfo.off_devices; dev; dev = next) {
	next = dev->next;
        if (dev->config_info && strcmp(dev->config_info, value) == 0)
            remove_device(dev);
    }
a75 16
static void
add_option(InputOption **options, const char *key, const char *value)
{
    if (!value || *value == '\0')
        return;

    for (; *options; options = &(*options)->next)
        ;
    *options = xcalloc(sizeof(**options), 1);
    if (!*options) /* Yeesh. */
        return;
    (*options)->key = xstrdup(key);
    (*options)->value = xstrdup(value);
    (*options)->next = NULL;
}

a127 20
static BOOL
device_is_duplicate(char *config_info)
{
    DeviceIntPtr dev;

    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
        if (dev->config_info && (strcmp(dev->config_info, config_info) == 0))
            return TRUE;
    }

    for (dev = inputInfo.off_devices; dev; dev = dev->next)
    {
        if (dev->config_info && (strcmp(dev->config_info, config_info) == 0))
            return TRUE;
    }

    return FALSE;
}

d133 1
d158 1
d163 18
d362 1
a362 1
    if ((rc = NewInputDeviceRequest(options, &dev)) != Success) {
d390 12
@


1.4
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d123 1
a123 1
    LogMessageVerb(X_INFO, 10, "config/hal: getting %s on %s returned %s\n", name, udi, prop);
d194 1
a194 1
    DeviceIntPtr dev;
d197 1
d403 2
a404 2
    if (NewInputDeviceRequest(options, &dev) != Success) {
        LogMessage(X_ERROR, "config/hal: NewInputDeviceRequest failed\n");
d470 2
a471 2
static void
connect_hook(DBusConnection *connection, void *data)
a473 1
    struct config_hal_info *info = data;
d477 3
d484 1
a484 2
    if (!info->hal_ctx)
        info->hal_ctx = libhal_ctx_new();
d492 1
a492 1
        goto out_ctx;
d496 3
a498 2
               error.name, error.message);
        goto out_ctx;
d502 3
a504 2
               error.name, error.message);
        goto out_ctx2;
d512 6
d524 4
a527 1
    return;
d529 1
a529 2
out_ctx2:
    if (!libhal_ctx_shutdown(info->hal_ctx, &error))
d531 5
a535 3
               error.name, error.message);
out_ctx:
    libhal_ctx_free(info->hal_ctx);
d539 4
d545 98
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d169 20
d249 7
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d3 1
d42 4
a45 3
#define TYPE_NONE 0
#define TYPE_KEYS 1
#define TYPE_POINTER 2
d52 10
d65 2
a66 1
    DebugF("[config/hal] removing device %s\n", dev->name);
d123 1
a123 1
    DebugF(" [config/hal] getting %s on %s returned %s\n", name, udi, prop);
d172 1
a172 4
    char **props;
    char *path = NULL, *driver = NULL, *name = NULL, *xkb_rules = NULL;
    char *xkb_model = NULL, *xkb_layout = NULL, *xkb_variant = NULL;
    char *xkb_options = NULL, *config_info = NULL;
d176 6
a181 2
    int type = TYPE_NONE;
    int i;
d185 5
a189 17
    props = libhal_device_get_property_strlist(hal_ctx, udi,
                                               "info.capabilities", &error);
    if (!props) {
        DebugF("[config/hal] couldn't get capabilities for %s: %s (%s)\n",
               udi, error.name, error.message);
        goto out_error;
    }
    for (i = 0; props[i]; i++) {
        /* input.keys is the new, of which input.keyboard is a subset, but
         * input.keyboard is the old 'we have keys', so we have to keep it
         * around. */
        if (strcmp(props[i], "input.keys") == 0 ||
            strcmp(props[i], "input.keyboard") == 0)
            type |= TYPE_KEYS;
        if (strcmp(props[i], "input.mouse") == 0 ||
            strcmp(props[i], "input.touchpad") == 0)
            type |= TYPE_POINTER;
a190 1
    libhal_free_string_array(props);
a191 4
    if (type == TYPE_NONE)
        goto out_error;

    driver = get_prop_string(hal_ctx, udi, "input.x11_driver");
d193 2
a194 2
    if (!driver || !path) {
        DebugF("[config/hal] no driver or path specified for %s\n", udi);
d197 1
d202 4
a205 6
    if (type & TYPE_KEYS) {
        xkb_rules = get_prop_string(hal_ctx, udi, "input.xkb.rules");
        xkb_model = get_prop_string(hal_ctx, udi, "input.xkb.model");
        xkb_layout = get_prop_string(hal_ctx, udi, "input.xkb.layout");
        xkb_variant = get_prop_string(hal_ctx, udi, "input.xkb.variant");
        xkb_options = get_prop_string_array(hal_ctx, udi, "input.xkb.options");
a207 1
    options = xcalloc(sizeof(*options), 1);
d211 1
a211 1
        ErrorF("[config] couldn't allocate first key/value pair\n");
d215 2
d218 2
d222 1
d224 2
a225 1
    if (!config_info)
d227 1
d230 125
a354 8
    if (xkb_model)
        add_option(&options, "xkb_model", xkb_model);
    if (xkb_layout)
        add_option(&options, "xkb_layout", xkb_layout);
    if (xkb_variant)
        add_option(&options, "xkb_variant", xkb_variant);
    if (xkb_options)
        add_option(&options, "xkb_options", xkb_options);
d356 19
d376 1
a376 1
        DebugF("[config/hal] NewInputDeviceRequest failed\n");
d381 3
a383 1
    for (; dev; dev = dev->next)
d385 1
d388 2
a395 8
    if (xkb_rules)
        xfree(xkb_rules);
    if (xkb_model)
        xfree(xkb_model);
    if (xkb_layout)
        xfree(xkb_layout);
    if (xkb_options)
        xfree(xkb_options);
d405 11
a415 1
out_error:
d428 7
a434 4
        dbus_error_init(&error);
        if (!libhal_ctx_shutdown(info->hal_ctx, &error))
            DebugF("[config/hal] couldn't shut down context: %s (%s)\n",
                   error.name, error.message);
a435 1
        dbus_error_free(&error);
d457 1
a457 1
        ErrorF("[config/hal] couldn't create HAL context\n");
d462 1
a462 1
        ErrorF("[config/hal] couldn't associate HAL context with bus\n");
d466 1
a466 1
        ErrorF("[config/hal] couldn't initialise context: %s (%s)\n",
d471 1
a471 1
        ErrorF("[config/hal] couldn't watch all properties: %s (%s)\n",
d491 1
a491 1
        DebugF("[config/hal] couldn't shut down context: %s (%s)\n",
d519 1
a519 1
        ErrorF("[config/hal] failed to add D-Bus hook\n");
d522 3
@


1.1
log
@Initial revision
@
text
@d66 1
a66 1
    DeviceIntPtr dev;
d74 2
a75 1
    for (dev = inputInfo.devices; dev; dev = dev->next) {
d79 2
a80 1
    for (dev = inputInfo.off_devices; dev; dev = dev->next) {
d97 2
d141 2
a142 1
            str = strcpy(str, props[i]);
d145 1
a145 1
        *str = '\0';
d163 1
a163 1
    InputOption *options = NULL;
d185 2
a186 1
        if (strcmp(props[i], "input.mouse") == 0)
d239 1
d263 6
@


1.1.1.1
log
@xserver 1.4
@
text
@@


1.1.1.2
log
@xserver 1.4.0.90
@
text
@d137 1
a137 2
            strcpy(str, props[i]);
            str += strlen(props[i]);
d140 1
a140 1
        *(str-1) = '\0';
d180 1
a180 2
        if (strcmp(props[i], "input.mouse") == 0 ||
            strcmp(props[i], "input.touchpad") == 0)
@

