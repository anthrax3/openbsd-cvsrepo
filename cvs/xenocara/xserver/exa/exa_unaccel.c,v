head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.8
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.6
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.01.31.21.10.06;	author stsp;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.44;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.44;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.06.35;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *
 * Copyright Â© 1999 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#include "exa_priv.h"

#include "mipict.h"

/*
 * These functions wrap the low-level fb rendering functions and
 * synchronize framebuffer/accelerated drawing by stalling until
 * the accelerator is idle
 */

/**
 * Calls exaPrepareAccess with EXA_PREPARE_SRC for the tile, if that is the
 * current fill style.
 *
 * Solid doesn't use an extra pixmap source, and Stippled/OpaqueStippled are
 * 1bpp and never in fb, so we don't worry about them.
 * We should worry about them for completeness sake and going forward.
 */
void
exaPrepareAccessGC(GCPtr pGC)
{
    if (pGC->stipple)
        exaPrepareAccess(&pGC->stipple->drawable, EXA_PREPARE_MASK);
    if (pGC->fillStyle == FillTiled)
        exaPrepareAccess(&pGC->tile.pixmap->drawable, EXA_PREPARE_SRC);
}

/**
 * Finishes access to the tile in the GC, if used.
 */
void
exaFinishAccessGC(GCPtr pGC)
{
    if (pGC->fillStyle == FillTiled)
        exaFinishAccess(&pGC->tile.pixmap->drawable, EXA_PREPARE_SRC);
    if (pGC->stipple)
        exaFinishAccess(&pGC->stipple->drawable, EXA_PREPARE_MASK);
}

#if DEBUG_TRACE_FALL
char
exaDrawableLocation(DrawablePtr pDrawable)
{
    return exaDrawableIsOffscreen(pDrawable) ? 's' : 'm';
}
#endif                          /* DEBUG_TRACE_FALL */

void
ExaCheckFillSpans(DrawablePtr pDrawable, GCPtr pGC, int nspans,
                  DDXPointPtr ppt, int *pwidth, int fSorted)
{
    EXA_PRE_FALLBACK_GC(pGC);
    EXA_FALLBACK(("to %p (%c)\n", pDrawable, exaDrawableLocation(pDrawable)));
    exaPrepareAccess(pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccessGC(pGC);
    pGC->ops->FillSpans(pDrawable, pGC, nspans, ppt, pwidth, fSorted);
    exaFinishAccessGC(pGC);
    exaFinishAccess(pDrawable, EXA_PREPARE_DEST);
    EXA_POST_FALLBACK_GC(pGC);
}

void
ExaCheckSetSpans(DrawablePtr pDrawable, GCPtr pGC, char *psrc,
                 DDXPointPtr ppt, int *pwidth, int nspans, int fSorted)
{
    EXA_PRE_FALLBACK_GC(pGC);
    EXA_FALLBACK(("to %p (%c)\n", pDrawable, exaDrawableLocation(pDrawable)));
    exaPrepareAccess(pDrawable, EXA_PREPARE_DEST);
    pGC->ops->SetSpans(pDrawable, pGC, psrc, ppt, pwidth, nspans, fSorted);
    exaFinishAccess(pDrawable, EXA_PREPARE_DEST);
    EXA_POST_FALLBACK_GC(pGC);
}

void
ExaCheckPutImage(DrawablePtr pDrawable, GCPtr pGC, int depth,
                 int x, int y, int w, int h, int leftPad, int format,
                 char *bits)
{
    PixmapPtr pPixmap = exaGetDrawablePixmap(pDrawable);

    ExaPixmapPriv(pPixmap);

    EXA_PRE_FALLBACK_GC(pGC);
    EXA_FALLBACK(("to %p (%c)\n", pDrawable, exaDrawableLocation(pDrawable)));
    if (!pExaScr->prepare_access_reg || !pExaPixmap->pDamage ||
        exaGCReadsDestination(pDrawable, pGC->planemask, pGC->fillStyle,
                              pGC->alu, pGC->clientClip != NULL))
        exaPrepareAccess(pDrawable, EXA_PREPARE_DEST);
    else
        pExaScr->prepare_access_reg(pPixmap, EXA_PREPARE_DEST,
                                    DamagePendingRegion(pExaPixmap->pDamage));
    pGC->ops->PutImage(pDrawable, pGC, depth, x, y, w, h, leftPad, format,
                       bits);
    exaFinishAccess(pDrawable, EXA_PREPARE_DEST);
    EXA_POST_FALLBACK_GC(pGC);
}

void
ExaCheckCopyNtoN(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
                 BoxPtr pbox, int nbox, int dx, int dy, Bool reverse,
                 Bool upsidedown, Pixel bitplane, void *closure)
{
    RegionRec reg;
    int xoff, yoff;

    EXA_PRE_FALLBACK_GC(pGC);
    EXA_FALLBACK(("from %p to %p (%c,%c)\n", pSrc, pDst,
                  exaDrawableLocation(pSrc), exaDrawableLocation(pDst)));

    if (pExaScr->prepare_access_reg && RegionInitBoxes(&reg, pbox, nbox)) {
        PixmapPtr pPixmap = exaGetDrawablePixmap(pSrc);

        exaGetDrawableDeltas(pSrc, pPixmap, &xoff, &yoff);
        RegionTranslate(&reg, xoff + dx, yoff + dy);
        pExaScr->prepare_access_reg(pPixmap, EXA_PREPARE_SRC, &reg);
        RegionUninit(&reg);
    }
    else
        exaPrepareAccess(pSrc, EXA_PREPARE_SRC);

    if (pExaScr->prepare_access_reg &&
        !exaGCReadsDestination(pDst, pGC->planemask, pGC->fillStyle,
                               pGC->alu, pGC->clientClip != NULL) &&
        RegionInitBoxes(&reg, pbox, nbox)) {
        PixmapPtr pPixmap = exaGetDrawablePixmap(pDst);

        exaGetDrawableDeltas(pDst, pPixmap, &xoff, &yoff);
        RegionTranslate(&reg, xoff, yoff);
        pExaScr->prepare_access_reg(pPixmap, EXA_PREPARE_DEST, &reg);
        RegionUninit(&reg);
    }
    else
        exaPrepareAccess(pDst, EXA_PREPARE_DEST);

    /* This will eventually call fbCopyNtoN, with some calculation overhead. */
    while (nbox--) {
        pGC->ops->CopyArea(pSrc, pDst, pGC, pbox->x1 - pSrc->x + dx,
                           pbox->y1 - pSrc->y + dy, pbox->x2 - pbox->x1,
                           pbox->y2 - pbox->y1, pbox->x1 - pDst->x,
                           pbox->y1 - pDst->y);
        pbox++;
    }
    exaFinishAccess(pSrc, EXA_PREPARE_SRC);
    exaFinishAccess(pDst, EXA_PREPARE_DEST);
    EXA_POST_FALLBACK_GC(pGC);
}

static void
ExaFallbackPrepareReg(DrawablePtr pDrawable,
                      GCPtr pGC,
                      int x, int y, int width, int height,
                      int index, Bool checkReads)
{
    ScreenPtr pScreen = pDrawable->pScreen;

    ExaScreenPriv(pScreen);

    if (pExaScr->prepare_access_reg &&
        !(checkReads && exaGCReadsDestination(pDrawable, pGC->planemask,
                                              pGC->fillStyle, pGC->alu,
                                              pGC->clientClip != NULL))) {
        BoxRec box;
        RegionRec reg;
        int xoff, yoff;
        PixmapPtr pPixmap = exaGetDrawablePixmap(pDrawable);

        exaGetDrawableDeltas(pDrawable, pPixmap, &xoff, &yoff);
        box.x1 = pDrawable->x + x + xoff;
        box.y1 = pDrawable->y + y + yoff;
        box.x2 = box.x1 + width;
        box.y2 = box.y1 + height;

        RegionInit(&reg, &box, 1);
        pExaScr->prepare_access_reg(pPixmap, index, &reg);
        RegionUninit(&reg);
    }
    else
        exaPrepareAccess(pDrawable, index);
}

RegionPtr
ExaCheckCopyArea(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
                 int srcx, int srcy, int w, int h, int dstx, int dsty)
{
    RegionPtr ret;

    EXA_PRE_FALLBACK_GC(pGC);
    EXA_FALLBACK(("from %p to %p (%c,%c)\n", pSrc, pDst,
                  exaDrawableLocation(pSrc), exaDrawableLocation(pDst)));
    ExaFallbackPrepareReg(pSrc, pGC, srcx, srcy, w, h, EXA_PREPARE_SRC, FALSE);
    ExaFallbackPrepareReg(pDst, pGC, dstx, dsty, w, h, EXA_PREPARE_DEST, TRUE);
    ret = pGC->ops->CopyArea(pSrc, pDst, pGC, srcx, srcy, w, h, dstx, dsty);
    exaFinishAccess(pSrc, EXA_PREPARE_SRC);
    exaFinishAccess(pDst, EXA_PREPARE_DEST);
    EXA_POST_FALLBACK_GC(pGC);

    return ret;
}

RegionPtr
ExaCheckCopyPlane(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
                  int srcx, int srcy, int w, int h, int dstx, int dsty,
                  unsigned long bitPlane)
{
    RegionPtr ret;

    EXA_PRE_FALLBACK_GC(pGC);
    EXA_FALLBACK(("from %p to %p (%c,%c)\n", pSrc, pDst,
                  exaDrawableLocation(pSrc), exaDrawableLocation(pDst)));
    ExaFallbackPrepareReg(pSrc, pGC, srcx, srcy, w, h, EXA_PREPARE_SRC, FALSE);
    ExaFallbackPrepareReg(pDst, pGC, dstx, dsty, w, h, EXA_PREPARE_DEST, TRUE);
    ret = pGC->ops->CopyPlane(pSrc, pDst, pGC, srcx, srcy, w, h, dstx, dsty,
                              bitPlane);
    exaFinishAccess(pSrc, EXA_PREPARE_SRC);
    exaFinishAccess(pDst, EXA_PREPARE_DEST);
    EXA_POST_FALLBACK_GC(pGC);

    return ret;
}

void
ExaCheckPolyPoint(DrawablePtr pDrawable, GCPtr pGC, int mode, int npt,
                  DDXPointPtr pptInit)
{
    EXA_PRE_FALLBACK_GC(pGC);
    EXA_FALLBACK(("to %p (%c)\n", pDrawable, exaDrawableLocation(pDrawable)));
    exaPrepareAccess(pDrawable, EXA_PREPARE_DEST);
    pGC->ops->PolyPoint(pDrawable, pGC, mode, npt, pptInit);
    exaFinishAccess(pDrawable, EXA_PREPARE_DEST);
    EXA_POST_FALLBACK_GC(pGC);
}

void
ExaCheckPolylines(DrawablePtr pDrawable, GCPtr pGC,
                  int mode, int npt, DDXPointPtr ppt)
{
    EXA_PRE_FALLBACK_GC(pGC);
    EXA_FALLBACK(("to %p (%c), width %d, mode %d, count %d\n",
                  pDrawable, exaDrawableLocation(pDrawable),
                  pGC->lineWidth, mode, npt));

    exaPrepareAccess(pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccessGC(pGC);
    pGC->ops->Polylines(pDrawable, pGC, mode, npt, ppt);
    exaFinishAccessGC(pGC);
    exaFinishAccess(pDrawable, EXA_PREPARE_DEST);
    EXA_POST_FALLBACK_GC(pGC);
}

void
ExaCheckPolySegment(DrawablePtr pDrawable, GCPtr pGC,
                    int nsegInit, xSegment * pSegInit)
{
    EXA_PRE_FALLBACK_GC(pGC);
    EXA_FALLBACK(("to %p (%c) width %d, count %d\n", pDrawable,
                  exaDrawableLocation(pDrawable), pGC->lineWidth, nsegInit));

    exaPrepareAccess(pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccessGC(pGC);
    pGC->ops->PolySegment(pDrawable, pGC, nsegInit, pSegInit);
    exaFinishAccessGC(pGC);
    exaFinishAccess(pDrawable, EXA_PREPARE_DEST);
    EXA_POST_FALLBACK_GC(pGC);
}

void
ExaCheckPolyArc(DrawablePtr pDrawable, GCPtr pGC, int narcs, xArc * pArcs)
{
    EXA_PRE_FALLBACK_GC(pGC);
    EXA_FALLBACK(("to %p (%c)\n", pDrawable, exaDrawableLocation(pDrawable)));

    exaPrepareAccess(pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccessGC(pGC);
    pGC->ops->PolyArc(pDrawable, pGC, narcs, pArcs);
    exaFinishAccessGC(pGC);
    exaFinishAccess(pDrawable, EXA_PREPARE_DEST);
    EXA_POST_FALLBACK_GC(pGC);
}

void
ExaCheckPolyFillRect(DrawablePtr pDrawable, GCPtr pGC,
                     int nrect, xRectangle *prect)
{
    EXA_PRE_FALLBACK_GC(pGC);
    EXA_FALLBACK(("to %p (%c)\n", pDrawable, exaDrawableLocation(pDrawable)));

    exaPrepareAccess(pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccessGC(pGC);
    pGC->ops->PolyFillRect(pDrawable, pGC, nrect, prect);
    exaFinishAccessGC(pGC);
    exaFinishAccess(pDrawable, EXA_PREPARE_DEST);
    EXA_POST_FALLBACK_GC(pGC);
}

void
ExaCheckImageGlyphBlt(DrawablePtr pDrawable, GCPtr pGC,
                      int x, int y, unsigned int nglyph,
                      CharInfoPtr * ppci, void *pglyphBase)
{
    EXA_PRE_FALLBACK_GC(pGC);
    EXA_FALLBACK(("to %p (%c)\n", pDrawable, exaDrawableLocation(pDrawable)));
    exaPrepareAccess(pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccessGC(pGC);
    pGC->ops->ImageGlyphBlt(pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
    exaFinishAccessGC(pGC);
    exaFinishAccess(pDrawable, EXA_PREPARE_DEST);
    EXA_POST_FALLBACK_GC(pGC);
}

void
ExaCheckPolyGlyphBlt(DrawablePtr pDrawable, GCPtr pGC,
                     int x, int y, unsigned int nglyph,
                     CharInfoPtr * ppci, void *pglyphBase)
{
    EXA_PRE_FALLBACK_GC(pGC);
    EXA_FALLBACK(("to %p (%c), style %d alu %d\n", pDrawable,
                  exaDrawableLocation(pDrawable), pGC->fillStyle, pGC->alu));
    exaPrepareAccess(pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccessGC(pGC);
    pGC->ops->PolyGlyphBlt(pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
    exaFinishAccessGC(pGC);
    exaFinishAccess(pDrawable, EXA_PREPARE_DEST);
    EXA_POST_FALLBACK_GC(pGC);
}

void
ExaCheckPushPixels(GCPtr pGC, PixmapPtr pBitmap,
                   DrawablePtr pDrawable, int w, int h, int x, int y)
{
    EXA_PRE_FALLBACK_GC(pGC);
    EXA_FALLBACK(("from %p to %p (%c,%c)\n", pBitmap, pDrawable,
                  exaDrawableLocation(&pBitmap->drawable),
                  exaDrawableLocation(pDrawable)));
    ExaFallbackPrepareReg(pDrawable, pGC, x, y, w, h, EXA_PREPARE_DEST, TRUE);
    ExaFallbackPrepareReg(&pBitmap->drawable, pGC, 0, 0, w, h,
                          EXA_PREPARE_SRC, FALSE);
    exaPrepareAccessGC(pGC);
    pGC->ops->PushPixels(pGC, pBitmap, pDrawable, w, h, x, y);
    exaFinishAccessGC(pGC);
    exaFinishAccess(&pBitmap->drawable, EXA_PREPARE_SRC);
    exaFinishAccess(pDrawable, EXA_PREPARE_DEST);
    EXA_POST_FALLBACK_GC(pGC);
}

void
ExaCheckCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
{
    DrawablePtr pDrawable = &pWin->drawable;
    ScreenPtr pScreen = pDrawable->pScreen;

    EXA_PRE_FALLBACK(pScreen);
    EXA_FALLBACK(("from %p\n", pWin));

    /* Only need the source bits, the destination region will be overwritten */
    if (pExaScr->prepare_access_reg) {
        PixmapPtr pPixmap = pScreen->GetWindowPixmap(pWin);
        int xoff, yoff;

        exaGetDrawableDeltas(&pWin->drawable, pPixmap, &xoff, &yoff);
        RegionTranslate(prgnSrc, xoff, yoff);
        pExaScr->prepare_access_reg(pPixmap, EXA_PREPARE_SRC, prgnSrc);
        RegionTranslate(prgnSrc, -xoff, -yoff);
    }
    else
        exaPrepareAccess(pDrawable, EXA_PREPARE_SRC);

    swap(pExaScr, pScreen, CopyWindow);
    pScreen->CopyWindow(pWin, ptOldOrg, prgnSrc);
    swap(pExaScr, pScreen, CopyWindow);
    exaFinishAccess(pDrawable, EXA_PREPARE_SRC);
    EXA_POST_FALLBACK(pScreen);
}

void
ExaCheckGetImage(DrawablePtr pDrawable, int x, int y, int w, int h,
                 unsigned int format, unsigned long planeMask, char *d)
{
    ScreenPtr pScreen = pDrawable->pScreen;

    EXA_PRE_FALLBACK(pScreen);
    EXA_FALLBACK(("from %p (%c)\n", pDrawable, exaDrawableLocation(pDrawable)));

    ExaFallbackPrepareReg(pDrawable, NULL, x, y, w, h, EXA_PREPARE_SRC, FALSE);
    swap(pExaScr, pScreen, GetImage);
    pScreen->GetImage(pDrawable, x, y, w, h, format, planeMask, d);
    swap(pExaScr, pScreen, GetImage);
    exaFinishAccess(pDrawable, EXA_PREPARE_SRC);
    EXA_POST_FALLBACK(pScreen);
}

void
ExaCheckGetSpans(DrawablePtr pDrawable,
                 int wMax,
                 DDXPointPtr ppt, int *pwidth, int nspans, char *pdstStart)
{
    ScreenPtr pScreen = pDrawable->pScreen;

    EXA_PRE_FALLBACK(pScreen);
    EXA_FALLBACK(("from %p (%c)\n", pDrawable, exaDrawableLocation(pDrawable)));
    exaPrepareAccess(pDrawable, EXA_PREPARE_SRC);
    swap(pExaScr, pScreen, GetSpans);
    pScreen->GetSpans(pDrawable, wMax, ppt, pwidth, nspans, pdstStart);
    swap(pExaScr, pScreen, GetSpans);
    exaFinishAccess(pDrawable, EXA_PREPARE_SRC);
    EXA_POST_FALLBACK(pScreen);
}

static void
ExaSrcValidate(DrawablePtr pDrawable,
               int x, int y, int width, int height, unsigned int subWindowMode)
{
    ScreenPtr pScreen = pDrawable->pScreen;

    ExaScreenPriv(pScreen);
    PixmapPtr pPix = exaGetDrawablePixmap(pDrawable);
    BoxRec box;
    RegionRec reg;
    RegionPtr dst;
    int xoff, yoff;

    if (pExaScr->srcPix == pPix)
        dst = &pExaScr->srcReg;
    else if (pExaScr->maskPix == pPix)
        dst = &pExaScr->maskReg;
    else
        return;

    exaGetDrawableDeltas(pDrawable, pPix, &xoff, &yoff);

    box.x1 = x + xoff;
    box.y1 = y + yoff;
    box.x2 = box.x1 + width;
    box.y2 = box.y1 + height;

    RegionInit(&reg, &box, 1);
    RegionUnion(dst, dst, &reg);
    RegionUninit(&reg);

    if (pExaScr->SavedSourceValidate) {
        swap(pExaScr, pScreen, SourceValidate);
        pScreen->SourceValidate(pDrawable, x, y, width, height, subWindowMode);
        swap(pExaScr, pScreen, SourceValidate);
    }
}

static Bool
ExaPrepareCompositeReg(ScreenPtr pScreen,
                       CARD8 op,
                       PicturePtr pSrc,
                       PicturePtr pMask,
                       PicturePtr pDst,
                       INT16 xSrc,
                       INT16 ySrc,
                       INT16 xMask,
                       INT16 yMask,
                       INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
{
    RegionRec region;
    RegionPtr dstReg = NULL;
    RegionPtr srcReg = NULL;
    RegionPtr maskReg = NULL;
    PixmapPtr pSrcPix = NULL;
    PixmapPtr pMaskPix = NULL;
    PixmapPtr pDstPix;

    ExaScreenPriv(pScreen);
    Bool ret;

    RegionNull(&region);

    if (pSrc->pDrawable) {
        pSrcPix = exaGetDrawablePixmap(pSrc->pDrawable);
        RegionNull(&pExaScr->srcReg);
        srcReg = &pExaScr->srcReg;
        pExaScr->srcPix = pSrcPix;
        if (pSrc != pDst)
            RegionTranslate(pSrc->pCompositeClip,
                            -pSrc->pDrawable->x, -pSrc->pDrawable->y);
    } else
        pExaScr->srcPix = NULL;

    if (pMask && pMask->pDrawable) {
        pMaskPix = exaGetDrawablePixmap(pMask->pDrawable);
        RegionNull(&pExaScr->maskReg);
        maskReg = &pExaScr->maskReg;
        pExaScr->maskPix = pMaskPix;
        if (pMask != pDst && pMask != pSrc)
            RegionTranslate(pMask->pCompositeClip,
                            -pMask->pDrawable->x, -pMask->pDrawable->y);
    } else
        pExaScr->maskPix = NULL;

    RegionTranslate(pDst->pCompositeClip,
                    -pDst->pDrawable->x, -pDst->pDrawable->y);

    pExaScr->SavedSourceValidate = ExaSrcValidate;
    swap(pExaScr, pScreen, SourceValidate);
    ret = miComputeCompositeRegion(&region, pSrc, pMask, pDst,
                                   xSrc, ySrc, xMask, yMask,
                                   xDst, yDst, width, height);
    swap(pExaScr, pScreen, SourceValidate);

    RegionTranslate(pDst->pCompositeClip,
                    pDst->pDrawable->x, pDst->pDrawable->y);
    if (pSrc->pDrawable && pSrc != pDst)
        RegionTranslate(pSrc->pCompositeClip,
                        pSrc->pDrawable->x, pSrc->pDrawable->y);
    if (pMask && pMask->pDrawable && pMask != pDst && pMask != pSrc)
        RegionTranslate(pMask->pCompositeClip,
                        pMask->pDrawable->x, pMask->pDrawable->y);

    if (!ret) {
        if (srcReg)
            RegionUninit(srcReg);
        if (maskReg)
            RegionUninit(maskReg);

        return FALSE;
    }

    /**
     * Don't limit alphamaps readbacks for now until we've figured out how that
     * should be done.
     */

    if (pSrc->alphaMap && pSrc->alphaMap->pDrawable)
        pExaScr->
            prepare_access_reg(exaGetDrawablePixmap(pSrc->alphaMap->pDrawable),
                               EXA_PREPARE_AUX_SRC, NULL);
    if (pMask && pMask->alphaMap && pMask->alphaMap->pDrawable)
        pExaScr->
            prepare_access_reg(exaGetDrawablePixmap(pMask->alphaMap->pDrawable),
                               EXA_PREPARE_AUX_MASK, NULL);

    if (pSrcPix)
        pExaScr->prepare_access_reg(pSrcPix, EXA_PREPARE_SRC, srcReg);

    if (pMaskPix)
        pExaScr->prepare_access_reg(pMaskPix, EXA_PREPARE_MASK, maskReg);

    if (srcReg)
        RegionUninit(srcReg);
    if (maskReg)
        RegionUninit(maskReg);

    pDstPix = exaGetDrawablePixmap(pDst->pDrawable);
    if (!exaOpReadsDestination(op)) {
        int xoff;
        int yoff;

        exaGetDrawableDeltas(pDst->pDrawable, pDstPix, &xoff, &yoff);
        RegionTranslate(&region, pDst->pDrawable->x + xoff,
                        pDst->pDrawable->y + yoff);
        dstReg = &region;
    }

    if (pDst->alphaMap && pDst->alphaMap->pDrawable)
        pExaScr->
            prepare_access_reg(exaGetDrawablePixmap(pDst->alphaMap->pDrawable),
                               EXA_PREPARE_AUX_DEST, dstReg);
    pExaScr->prepare_access_reg(pDstPix, EXA_PREPARE_DEST, dstReg);

    RegionUninit(&region);
    return TRUE;
}

void
ExaCheckComposite(CARD8 op,
                  PicturePtr pSrc,
                  PicturePtr pMask,
                  PicturePtr pDst,
                  INT16 xSrc,
                  INT16 ySrc,
                  INT16 xMask,
                  INT16 yMask,
                  INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);

    EXA_PRE_FALLBACK(pScreen);

    if (pExaScr->prepare_access_reg) {
        if (!ExaPrepareCompositeReg(pScreen, op, pSrc, pMask, pDst, xSrc,
                                    ySrc, xMask, yMask, xDst, yDst, width,
                                    height))
            goto out_no_clip;
    }
    else {

        /* We need to prepare access to any separate alpha maps first,
         * in case the driver doesn't support EXA_PREPARE_AUX*,
         * in which case EXA_PREPARE_SRC may be used for moving them out.
         */

        if (pSrc->alphaMap && pSrc->alphaMap->pDrawable)
            exaPrepareAccess(pSrc->alphaMap->pDrawable, EXA_PREPARE_AUX_SRC);
        if (pMask && pMask->alphaMap && pMask->alphaMap->pDrawable)
            exaPrepareAccess(pMask->alphaMap->pDrawable, EXA_PREPARE_AUX_MASK);
        if (pDst->alphaMap && pDst->alphaMap->pDrawable)
            exaPrepareAccess(pDst->alphaMap->pDrawable, EXA_PREPARE_AUX_DEST);

        exaPrepareAccess(pDst->pDrawable, EXA_PREPARE_DEST);

        EXA_FALLBACK(("from picts %p/%p to pict %p\n", pSrc, pMask, pDst));

        if (pSrc->pDrawable != NULL)
            exaPrepareAccess(pSrc->pDrawable, EXA_PREPARE_SRC);
        if (pMask && pMask->pDrawable != NULL)
            exaPrepareAccess(pMask->pDrawable, EXA_PREPARE_MASK);
    }

    swap(pExaScr, ps, Composite);
    ps->Composite(op,
                  pSrc,
                  pMask,
                  pDst, xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);
    swap(pExaScr, ps, Composite);
    if (pMask && pMask->pDrawable != NULL)
        exaFinishAccess(pMask->pDrawable, EXA_PREPARE_MASK);
    if (pSrc->pDrawable != NULL)
        exaFinishAccess(pSrc->pDrawable, EXA_PREPARE_SRC);
    exaFinishAccess(pDst->pDrawable, EXA_PREPARE_DEST);
    if (pDst->alphaMap && pDst->alphaMap->pDrawable)
        exaFinishAccess(pDst->alphaMap->pDrawable, EXA_PREPARE_AUX_DEST);
    if (pSrc->alphaMap && pSrc->alphaMap->pDrawable)
        exaFinishAccess(pSrc->alphaMap->pDrawable, EXA_PREPARE_AUX_SRC);
    if (pMask && pMask->alphaMap && pMask->alphaMap->pDrawable)
        exaFinishAccess(pMask->alphaMap->pDrawable, EXA_PREPARE_AUX_MASK);

 out_no_clip:
    EXA_POST_FALLBACK(pScreen);
}

/**
 * Avoid migration ping-pong when using a mask.
 */
void
ExaCheckGlyphs(CARD8 op,
               PicturePtr pSrc,
               PicturePtr pDst,
               PictFormatPtr maskFormat,
               INT16 xSrc,
               INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;

    EXA_PRE_FALLBACK(pScreen);

    miGlyphs(op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, list, glyphs);

    EXA_POST_FALLBACK(pScreen);
}

void
ExaCheckAddTraps(PicturePtr pPicture,
                 INT16 x_off, INT16 y_off, int ntrap, xTrap * traps)
{
    ScreenPtr pScreen = pPicture->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);

    EXA_PRE_FALLBACK(pScreen);

    EXA_FALLBACK(("to pict %p (%c)\n", pPicture,
                  exaDrawableLocation(pPicture->pDrawable)));
    exaPrepareAccess(pPicture->pDrawable, EXA_PREPARE_DEST);
    swap(pExaScr, ps, AddTraps);
    ps->AddTraps(pPicture, x_off, y_off, ntrap, traps);
    swap(pExaScr, ps, AddTraps);
    exaFinishAccess(pPicture->pDrawable, EXA_PREPARE_DEST);
    EXA_POST_FALLBACK(pScreen);
}

/**
 * Gets the 0,0 pixel of a pixmap.  Used for doing solid fills of tiled pixmaps
 * that happen to be 1x1.  Pixmap must be at least 8bpp.
 */
CARD32
exaGetPixmapFirstPixel(PixmapPtr pPixmap)
{
    switch (pPixmap->drawable.bitsPerPixel) {
    case 32:
    {
        CARD32 pixel;

        pPixmap->drawable.pScreen->GetImage(&pPixmap->drawable, 0, 0, 1, 1,
                                            ZPixmap, ~0, (char *) &pixel);
        return pixel;
    }
    case 16:
    {
        CARD16 pixel;

        pPixmap->drawable.pScreen->GetImage(&pPixmap->drawable, 0, 0, 1, 1,
                                            ZPixmap, ~0, (char *) &pixel);
        return pixel;
    }
    case 8:
    case 4:
    case 1:
    {
        CARD8 pixel;

        pPixmap->drawable.pScreen->GetImage(&pPixmap->drawable, 0, 0, 1, 1,
                                            ZPixmap, ~0, (char *) &pixel);
        return pixel;
    }
    default:
        FatalError("%s called for invalid bpp %d\n", __func__,
                   pPixmap->drawable.bitsPerPixel);
    }
}
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d110 1
a110 1
                              pGC->alu, pGC->clientClipType))
d146 1
a146 1
                               pGC->alu, pGC->clientClipType) &&
d182 3
a184 4
        !(checkReads && exaGCReadsDestination(pDrawable,
                                              pGC->planemask,
                                              pGC->fillStyle,
                                              pGC->alu, pGC->clientClipType))) {
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d322 1
a322 1
                      CharInfoPtr * ppci, pointer pglyphBase)
d337 1
a337 1
                     CharInfoPtr * ppci, pointer pglyphBase)
d688 1
a688 1
    EXA_FALLBACK(("to pict %p (%c)\n",
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d445 7
a458 2
    dst = (pExaScr->srcPix == pPix) ? &pExaScr->srcReg : &pExaScr->maskReg;

d503 2
a504 1
    }
d510 1
d514 2
a515 1
    }
@


1.7
log
@Update to xserver 1.11.2
@
text
@d48 1
a48 1
	exaPrepareAccess(&pGC->tile.pixmap->drawable, EXA_PREPARE_SRC);
d58 1
a58 1
	exaFinishAccess(&pGC->tile.pixmap->drawable, EXA_PREPARE_SRC);
d69 1
a69 1
#endif /* DEBUG_TRACE_FALL */
d72 2
a73 2
ExaCheckFillSpans (DrawablePtr pDrawable, GCPtr pGC, int nspans,
		   DDXPointPtr ppt, int *pwidth, int fSorted)
d77 5
a81 5
    exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccessGC (pGC);
    pGC->ops->FillSpans (pDrawable, pGC, nspans, ppt, pwidth, fSorted);
    exaFinishAccessGC (pGC);
    exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
d86 2
a87 2
ExaCheckSetSpans (DrawablePtr pDrawable, GCPtr pGC, char *psrc,
		 DDXPointPtr ppt, int *pwidth, int nspans, int fSorted)
d91 3
a93 3
    exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
    pGC->ops->SetSpans (pDrawable, pGC, psrc, ppt, pwidth, nspans, fSorted);
    exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
d98 3
a100 3
ExaCheckPutImage (DrawablePtr pDrawable, GCPtr pGC, int depth,
		 int x, int y, int w, int h, int leftPad, int format,
		 char *bits)
d103 1
d109 3
a111 3
	exaGCReadsDestination(pDrawable, pGC->planemask, pGC->fillStyle,
			      pGC->alu, pGC->clientClipType))
	exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
d113 5
a117 4
	pExaScr->prepare_access_reg(pPixmap, EXA_PREPARE_DEST,
				    DamagePendingRegion(pExaPixmap->pDamage));
    pGC->ops->PutImage (pDrawable, pGC, depth, x, y, w, h, leftPad, format, bits);
    exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
d122 3
a124 3
ExaCheckCopyNtoN (DrawablePtr pSrc, DrawablePtr pDst,  GCPtr pGC,
	     BoxPtr	pbox, int nbox, int dx, int dy, Bool	reverse, 
	     Bool upsidedown, Pixel bitplane, void *closure)
d128 1
d131 1
a131 1
		  exaDrawableLocation(pSrc), exaDrawableLocation(pDst)));
d134 1
a134 1
	PixmapPtr pPixmap = exaGetDrawablePixmap(pSrc);
d136 7
a142 6
	exaGetDrawableDeltas(pSrc, pPixmap, &xoff, &yoff);
	RegionTranslate(&reg, xoff + dx, yoff + dy);
	pExaScr->prepare_access_reg(pPixmap, EXA_PREPARE_SRC, &reg);
	RegionUninit(&reg);
    } else
	exaPrepareAccess (pSrc, EXA_PREPARE_SRC);
d145 12
a156 11
	!exaGCReadsDestination(pDst, pGC->planemask, pGC->fillStyle,
			       pGC->alu, pGC->clientClipType) &&
	RegionInitBoxes (&reg, pbox, nbox)) {
	PixmapPtr pPixmap = exaGetDrawablePixmap(pDst);

	exaGetDrawableDeltas(pDst, pPixmap, &xoff, &yoff);
	RegionTranslate(&reg, xoff, yoff);
	pExaScr->prepare_access_reg(pPixmap, EXA_PREPARE_DEST, &reg);
	RegionUninit(&reg);
    } else
	exaPrepareAccess (pDst, EXA_PREPARE_DEST);
d160 5
a164 3
	pGC->ops->CopyArea (pSrc, pDst, pGC, pbox->x1 - pSrc->x + dx, pbox->y1 - pSrc->y + dy, 
			pbox->x2 - pbox->x1, pbox->y2 - pbox->y1, pbox->x1 - pDst->x, pbox->y1 - pDst->y);
	pbox++;
d166 2
a167 2
    exaFinishAccess (pSrc, EXA_PREPARE_SRC);
    exaFinishAccess (pDst, EXA_PREPARE_DEST);
d173 3
a175 3
		      GCPtr pGC,
		      int x, int y, int width, int height,
		      int index, Bool checkReads)
d178 1
d182 21
a202 21
	!(checkReads && exaGCReadsDestination(pDrawable,
					      pGC->planemask,
					      pGC->fillStyle,
					      pGC->alu,
					      pGC->clientClipType))) {
	BoxRec box;
	RegionRec reg;
	int xoff, yoff;
	PixmapPtr pPixmap = exaGetDrawablePixmap(pDrawable);

	exaGetDrawableDeltas(pDrawable, pPixmap, &xoff, &yoff);
	box.x1 = pDrawable->x + x + xoff;
	box.y1 = pDrawable->y + y + yoff;
	box.x2 = box.x1 + width;
	box.y2 = box.y1 + height;

	RegionInit(&reg, &box, 1);
	pExaScr->prepare_access_reg(pPixmap, index, &reg);
	RegionUninit(&reg);
    } else
	exaPrepareAccess(pDrawable, index);
a204 1

d206 2
a207 2
ExaCheckCopyArea (DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
		 int srcx, int srcy, int w, int h, int dstx, int dsty)
d213 6
a218 8
		  exaDrawableLocation(pSrc), exaDrawableLocation(pDst)));
    ExaFallbackPrepareReg(pSrc, pGC, srcx, srcy, w, h,
			  EXA_PREPARE_SRC, FALSE);
    ExaFallbackPrepareReg(pDst, pGC, dstx, dsty, w, h,
			  EXA_PREPARE_DEST, TRUE);
    ret = pGC->ops->CopyArea (pSrc, pDst, pGC, srcx, srcy, w, h, dstx, dsty);
    exaFinishAccess (pSrc, EXA_PREPARE_SRC);
    exaFinishAccess (pDst, EXA_PREPARE_DEST);
d225 3
a227 3
ExaCheckCopyPlane (DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
		  int srcx, int srcy, int w, int h, int dstx, int dsty,
		  unsigned long bitPlane)
d233 7
a239 9
		  exaDrawableLocation(pSrc), exaDrawableLocation(pDst)));
    ExaFallbackPrepareReg(pSrc, pGC, srcx, srcy, w, h,
			  EXA_PREPARE_SRC, FALSE);
    ExaFallbackPrepareReg(pDst, pGC, dstx, dsty, w, h,
			  EXA_PREPARE_DEST, TRUE);
    ret = pGC->ops->CopyPlane (pSrc, pDst, pGC, srcx, srcy, w, h, dstx, dsty,
		       bitPlane);
    exaFinishAccess (pSrc, EXA_PREPARE_SRC);
    exaFinishAccess (pDst, EXA_PREPARE_DEST);
d246 2
a247 2
ExaCheckPolyPoint (DrawablePtr pDrawable, GCPtr pGC, int mode, int npt,
		  DDXPointPtr pptInit)
d251 3
a253 3
    exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
    pGC->ops->PolyPoint (pDrawable, pGC, mode, npt, pptInit);
    exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
d258 2
a259 2
ExaCheckPolylines (DrawablePtr pDrawable, GCPtr pGC,
		  int mode, int npt, DDXPointPtr ppt)
d263 2
a264 2
		  pDrawable, exaDrawableLocation(pDrawable),
		  pGC->lineWidth, mode, npt));
d266 5
a270 5
    exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccessGC (pGC);
    pGC->ops->Polylines (pDrawable, pGC, mode, npt, ppt);
    exaFinishAccessGC (pGC);
    exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
d275 2
a276 2
ExaCheckPolySegment (DrawablePtr pDrawable, GCPtr pGC,
		    int nsegInit, xSegment *pSegInit)
d280 1
a280 1
		  exaDrawableLocation(pDrawable), pGC->lineWidth, nsegInit));
d282 5
a286 5
    exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccessGC (pGC);
    pGC->ops->PolySegment (pDrawable, pGC, nsegInit, pSegInit);
    exaFinishAccessGC (pGC);
    exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
d291 1
a291 2
ExaCheckPolyArc (DrawablePtr pDrawable, GCPtr pGC,
		int narcs, xArc *pArcs)
d296 5
a300 5
    exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccessGC (pGC);
    pGC->ops->PolyArc (pDrawable, pGC, narcs, pArcs);
    exaFinishAccessGC (pGC);
    exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
d305 2
a306 2
ExaCheckPolyFillRect (DrawablePtr pDrawable, GCPtr pGC,
		     int nrect, xRectangle *prect)
d311 5
a315 5
    exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccessGC (pGC);
    pGC->ops->PolyFillRect (pDrawable, pGC, nrect, prect);
    exaFinishAccessGC (pGC);
    exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
d320 3
a322 3
ExaCheckImageGlyphBlt (DrawablePtr pDrawable, GCPtr pGC,
		      int x, int y, unsigned int nglyph,
		      CharInfoPtr *ppci, pointer pglyphBase)
d325 6
a330 7
    EXA_FALLBACK(("to %p (%c)\n", pDrawable,
		  exaDrawableLocation(pDrawable)));
    exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccessGC (pGC);
    pGC->ops->ImageGlyphBlt (pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
    exaFinishAccessGC (pGC);
    exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
d335 3
a337 3
ExaCheckPolyGlyphBlt (DrawablePtr pDrawable, GCPtr pGC,
		     int x, int y, unsigned int nglyph,
		     CharInfoPtr *ppci, pointer pglyphBase)
d341 6
a346 6
		  exaDrawableLocation(pDrawable), pGC->fillStyle, pGC->alu));
    exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccessGC (pGC);
    pGC->ops->PolyGlyphBlt (pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
    exaFinishAccessGC (pGC);
    exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
d351 2
a352 3
ExaCheckPushPixels (GCPtr pGC, PixmapPtr pBitmap,
		   DrawablePtr pDrawable,
		   int w, int h, int x, int y)
d356 3
a358 4
		  exaDrawableLocation(&pBitmap->drawable),
		  exaDrawableLocation(pDrawable)));
    ExaFallbackPrepareReg(pDrawable, pGC, x, y, w, h,
			  EXA_PREPARE_DEST, TRUE);
d360 6
a365 6
			  EXA_PREPARE_SRC, FALSE);
    exaPrepareAccessGC (pGC);
    pGC->ops->PushPixels (pGC, pBitmap, pDrawable, w, h, x, y);
    exaFinishAccessGC (pGC);
    exaFinishAccess (&pBitmap->drawable, EXA_PREPARE_SRC);
    exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
d374 1
d380 2
a381 2
	PixmapPtr pPixmap = pScreen->GetWindowPixmap(pWin);
	int xoff, yoff;
d383 7
a389 6
	exaGetDrawableDeltas(&pWin->drawable, pPixmap, &xoff, &yoff);
	RegionTranslate(prgnSrc, xoff, yoff);
	pExaScr->prepare_access_reg(pPixmap, EXA_PREPARE_SRC, prgnSrc);
	RegionTranslate(prgnSrc, -xoff, -yoff);
    } else
	exaPrepareAccess(pDrawable, EXA_PREPARE_SRC);
d392 1
a392 1
    pScreen->CopyWindow (pWin, ptOldOrg, prgnSrc);
d394 1
a394 1
    exaFinishAccess (pDrawable, EXA_PREPARE_SRC);
d400 1
a400 1
		unsigned int format, unsigned long planeMask, char *d)
d403 1
d405 1
a405 2
    EXA_FALLBACK(("from %p (%c)\n", pDrawable,
		  exaDrawableLocation(pDrawable)));
d407 1
a407 2
    ExaFallbackPrepareReg(pDrawable, NULL, x, y, w, h,
			  EXA_PREPARE_SRC, FALSE);
d409 1
a409 1
    pScreen->GetImage (pDrawable, x, y, w, h, format, planeMask, d);
d411 1
a411 1
    exaFinishAccess (pDrawable, EXA_PREPARE_SRC);
d416 3
a418 6
ExaCheckGetSpans (DrawablePtr pDrawable,
		 int wMax,
		 DDXPointPtr ppt,
		 int *pwidth,
		 int nspans,
		 char *pdstStart)
d424 1
a424 1
    exaPrepareAccess (pDrawable, EXA_PREPARE_SRC);
d426 1
a426 1
    pScreen->GetSpans (pDrawable, wMax, ppt, pwidth, nspans, pdstStart);
d428 1
a428 1
    exaFinishAccess (pDrawable, EXA_PREPARE_SRC);
d434 1
a434 5
	       int x,
	       int y,
	       int width,
	       int height,
	       unsigned int subWindowMode)
d437 1
d439 1
a439 1
    PixmapPtr pPix = exaGetDrawablePixmap (pDrawable);
d452 1
a452 2
    dst = (pExaScr->srcPix == pPix) ? &pExaScr->srcReg :
	&pExaScr->maskReg;
d466 10
a475 13
ExaPrepareCompositeReg(ScreenPtr  pScreen,
		       CARD8      op,
		       PicturePtr pSrc,
		       PicturePtr pMask,
		       PicturePtr pDst,
		       INT16      xSrc,
		       INT16      ySrc,
		       INT16      xMask,
		       INT16      yMask,
		       INT16      xDst,
		       INT16      yDst,
		       CARD16     width,
		       CARD16     height)
d484 1
a487 1

d491 7
a497 8
	pSrcPix = exaGetDrawablePixmap(pSrc->pDrawable);
	RegionNull(&pExaScr->srcReg);
	srcReg = &pExaScr->srcReg;
	pExaScr->srcPix = pSrcPix;
	if (pSrc != pDst)
	    RegionTranslate(pSrc->pCompositeClip,
			     -pSrc->pDrawable->x,
			     -pSrc->pDrawable->y);
d501 6
a506 7
	pMaskPix = exaGetDrawablePixmap(pMask->pDrawable);
	RegionNull(&pExaScr->maskReg);
	maskReg = &pExaScr->maskReg;
	if (pMask != pDst && pMask != pSrc)
	    RegionTranslate(pMask->pCompositeClip,
			     -pMask->pDrawable->x,
			     -pMask->pDrawable->y);
d510 1
a510 2
		     -pDst->pDrawable->x,
		     -pDst->pDrawable->y);
d514 3
a516 5
    ret = miComputeCompositeRegion (&region, pSrc, pMask, pDst,
				    xSrc, ySrc, xMask, yMask,
				    xDst,
				    yDst,
				    width, height);
d520 1
a520 2
		     pDst->pDrawable->x,
		     pDst->pDrawable->y);
d522 2
a523 3
	RegionTranslate(pSrc->pCompositeClip,
			 pSrc->pDrawable->x,
			 pSrc->pDrawable->y);
d525 2
a526 3
	RegionTranslate(pMask->pCompositeClip,
			 pMask->pDrawable->x,
			 pMask->pDrawable->y);
d529 4
a532 4
	if (srcReg)
	    RegionUninit(srcReg);
	if (maskReg)
	    RegionUninit(maskReg);
d534 1
a534 1
	return FALSE;
d543 3
a545 3
	pExaScr->prepare_access_reg(exaGetDrawablePixmap(pSrc->alphaMap->pDrawable),
				    EXA_PREPARE_AUX_SRC,
				    NULL);
d547 3
a549 3
	pExaScr->prepare_access_reg(exaGetDrawablePixmap(pMask->alphaMap->pDrawable),
				    EXA_PREPARE_AUX_MASK,
				    NULL);
d552 1
a552 3
	pExaScr->prepare_access_reg(pSrcPix,
				    EXA_PREPARE_SRC,
				    srcReg);
d555 1
a555 3
	pExaScr->prepare_access_reg(pMaskPix,
				    EXA_PREPARE_MASK,
				    maskReg);
d558 1
a558 1
	RegionUninit(srcReg);
d560 1
a560 1
	RegionUninit(maskReg);
d564 2
a565 2
	int xoff;
	int yoff;
d567 4
a570 4
	exaGetDrawableDeltas (pDst->pDrawable, pDstPix, &xoff, &yoff);
	RegionTranslate(&region, pDst->pDrawable->x + xoff,
			 pDst->pDrawable->y + yoff);
	dstReg = &region;
d574 3
a576 3
	pExaScr->prepare_access_reg(exaGetDrawablePixmap(pDst->alphaMap->pDrawable),
				    EXA_PREPARE_AUX_DEST,
				    dstReg);
d584 9
a592 12
ExaCheckComposite (CARD8      op,
                   PicturePtr pSrc,
                   PicturePtr pMask,
                   PicturePtr pDst,
                   INT16      xSrc,
                   INT16      ySrc,
                   INT16      xMask,
                   INT16      yMask,
                   INT16      xDst,
                   INT16      yDst,
                   CARD16     width,
                   CARD16     height)
d595 2
a596 1
    PictureScreenPtr	ps = GetPictureScreen(pScreen);
d600 27
a626 27
	if (!ExaPrepareCompositeReg(pScreen, op, pSrc, pMask, pDst, xSrc,
				   ySrc, xMask, yMask, xDst, yDst, width,
				   height))
	    goto out_no_clip;
    } else {

	/* We need to prepare access to any separate alpha maps first,
	 * in case the driver doesn't support EXA_PREPARE_AUX*,
	 * in which case EXA_PREPARE_SRC may be used for moving them out.
	 */

	if (pSrc->alphaMap && pSrc->alphaMap->pDrawable)
	    exaPrepareAccess(pSrc->alphaMap->pDrawable, EXA_PREPARE_AUX_SRC);
	if (pMask && pMask->alphaMap && pMask->alphaMap->pDrawable)
	    exaPrepareAccess(pMask->alphaMap->pDrawable, EXA_PREPARE_AUX_MASK);
	if (pDst->alphaMap && pDst->alphaMap->pDrawable)
	    exaPrepareAccess(pDst->alphaMap->pDrawable, EXA_PREPARE_AUX_DEST);

	exaPrepareAccess (pDst->pDrawable, EXA_PREPARE_DEST);

	EXA_FALLBACK(("from picts %p/%p to pict %p\n",
		      pSrc, pMask, pDst));

	if (pSrc->pDrawable != NULL)
	    exaPrepareAccess (pSrc->pDrawable, EXA_PREPARE_SRC);
	if (pMask && pMask->pDrawable != NULL)
	    exaPrepareAccess (pMask->pDrawable, EXA_PREPARE_MASK);
d630 4
a633 12
    ps->Composite (op,
                 pSrc,
                 pMask,
                 pDst,
                 xSrc,
                 ySrc,
                 xMask,
                 yMask,
                 xDst,
                 yDst,
                 width,
                 height);
d636 1
a636 1
	exaFinishAccess (pMask->pDrawable, EXA_PREPARE_MASK);
d638 2
a639 2
	exaFinishAccess (pSrc->pDrawable, EXA_PREPARE_SRC);
    exaFinishAccess (pDst->pDrawable, EXA_PREPARE_DEST);
d641 1
a641 1
	exaFinishAccess(pDst->alphaMap->pDrawable, EXA_PREPARE_AUX_DEST);
d643 1
a643 1
	exaFinishAccess(pSrc->alphaMap->pDrawable, EXA_PREPARE_AUX_SRC);
d645 1
a645 1
	exaFinishAccess(pMask->alphaMap->pDrawable, EXA_PREPARE_AUX_MASK);
d647 1
a647 1
out_no_clip:
d655 6
a660 9
ExaCheckGlyphs (CARD8	      op,
		PicturePtr    pSrc,
		PicturePtr    pDst,
		PictFormatPtr maskFormat,
		INT16	      xSrc,
		INT16	      ySrc,
		int	      nlist,
		GlyphListPtr  list,
		GlyphPtr      *glyphs)
d663 1
d672 2
a673 5
ExaCheckAddTraps (PicturePtr	pPicture,
		  INT16		x_off,
		  INT16		y_off,
		  int		ntrap,
		  xTrap		*traps)
d676 2
a677 1
    PictureScreenPtr	ps = GetPictureScreen(pScreen);
d681 1
a681 1
		  exaDrawableLocation(pPicture->pDrawable)));
d684 1
a684 1
    ps->AddTraps (pPicture, x_off, y_off, ntrap, traps);
d695 1
a695 1
exaGetPixmapFirstPixel (PixmapPtr pPixmap)
d699 2
a700 2
	{
	    CARD32 pixel;
d702 4
a705 4
	    pPixmap->drawable.pScreen->GetImage(&pPixmap->drawable, 0, 0, 1, 1,
						ZPixmap, ~0, (char*)&pixel);
	    return pixel;
	}
d707 2
a708 2
	{
	    CARD16 pixel;
d710 4
a713 4
	    pPixmap->drawable.pScreen->GetImage(&pPixmap->drawable, 0, 0, 1, 1,
						ZPixmap, ~0, (char*)&pixel);
	    return pixel;
	}
d717 2
a718 2
	{
	    CARD8 pixel;
d720 4
a723 4
	    pPixmap->drawable.pScreen->GetImage(&pPixmap->drawable, 0, 0, 1, 1,
						ZPixmap, ~0, (char*)&pixel);
	    return pixel;
	}
d725 2
a726 2
	FatalError("%s called for invalid bpp %d\n", __func__,
		   pPixmap->drawable.bitsPerPixel);
@


1.6
log
@Apply fix from upstream:
  commit e06fa804009798ea95efa8babaabb0228dfdfe65
  EXA: Fix crash with fill using 1x1 tile of depth < 8 (bug #24703).
Fixes http://bugs.freedesktop.org/show_bug.cgi?id=24703
Reported by Barry Grumbine on ports@@
ok matthieu@@
@
text
@d3 1
a3 1
 * Copyright © 1999 Keith Packard
d130 1
a130 1
    if (pExaScr->prepare_access_reg) {
a133 1
	RegionInit(&reg, pbox, nbox);
d142 2
a143 1
			       pGC->alu, pGC->clientClipType)) {
d146 1
a146 2
	exaGetDrawableDeltas(pSrc, pPixmap, &xoff, &yoff);
	RegionInit(&reg, pbox, nbox);
d440 2
a441 1
	       int height)
d467 1
a467 1
        pScreen->SourceValidate(pDrawable, x, y, width, height);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d751 2
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a25 1
#ifdef RENDER
a26 1
#endif
d134 2
a135 2
	REGION_INIT(pScreen, &reg, pbox, nbox);
	REGION_TRANSLATE(pScreen, &reg, xoff + dx, yoff + dy);
d137 1
a137 1
	REGION_UNINIT(pScreen, &reg);
d147 2
a148 2
	REGION_INIT(pScreen, &reg, pbox, nbox);
	REGION_TRANSLATE(pScreen, &reg, xoff, yoff);
d150 1
a150 1
	REGION_UNINIT(pScreen, &reg);
d191 1
a191 1
	REGION_INIT(pScreen, &reg, &box, 1);
d193 1
a193 1
	REGION_UNINIT(pScreen, &reg);
d385 1
a385 1
	REGION_TRANSLATE(pScreen, prgnSrc, xoff, yoff);
d387 1
a387 1
	REGION_TRANSLATE(pScreen, prgnSrc, -xoff, -yoff);
d461 3
a463 3
    REGION_INIT(pScreen, &reg, &box, 1);
    REGION_UNION(pScreen, dst, dst, &reg);
    REGION_UNINIT(pScreen, &reg);
d498 1
a498 1
    REGION_NULL(pScreen, &region);
d502 1
a502 1
	REGION_NULL(pScreen, &pExaScr->srcReg);
d506 1
a506 1
	    REGION_TRANSLATE(pScreen, pSrc->pCompositeClip,
d513 1
a513 1
	REGION_NULL(pScreen, &pExaScr->maskReg);
d516 1
a516 1
	    REGION_TRANSLATE(pScreen, pMask->pCompositeClip,
d521 1
a521 1
    REGION_TRANSLATE(pScreen, pDst->pCompositeClip,
d534 1
a534 1
    REGION_TRANSLATE(pScreen, pDst->pCompositeClip,
d538 1
a538 1
	REGION_TRANSLATE(pScreen, pSrc->pCompositeClip,
d542 1
a542 1
	REGION_TRANSLATE(pScreen, pMask->pCompositeClip,
d548 1
a548 1
	    REGION_UNINIT(pScreen, srcReg);
d550 1
a550 1
	    REGION_UNINIT(pScreen, maskReg);
d580 1
a580 1
	REGION_UNINIT(pScreen, srcReg);
d582 1
a582 1
	REGION_UNINIT(pScreen, maskReg);
d590 1
a590 1
	REGION_TRANSLATE(pScreen, &region, pDst->pDrawable->x + xoff,
d601 1
a601 1
    REGION_UNINIT(pScreen, &region);
a619 1
#ifdef RENDER
a620 1
#endif /* RENDER */
a652 1
#ifdef RENDER
a666 1
#endif /* RENDER */
d683 22
a712 1
#ifdef RENDER
a713 1
#endif /* RENDER */
a718 1
#ifdef RENDER
a721 1
#endif /* RENDER */
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d77 1
d81 1
a81 1
    fbFillSpans (pDrawable, pGC, nspans, ppt, pwidth, fSorted);
d84 1
d91 1
d94 1
a94 1
    fbSetSpans (pDrawable, pGC, psrc, ppt, pwidth, nspans, fSorted);
d96 1
d104 2
a105 1
    ExaPixmapPriv(exaGetDrawablePixmap(pDrawable));
d107 1
d109 2
a110 1
    if (exaGCReadsDestination(pDrawable, pGC->planemask, pGC->fillStyle,
d114 3
a116 3
	exaPrepareAccessReg (pDrawable, EXA_PREPARE_DEST, pExaPixmap->pDamage ?
			     DamagePendingRegion(pExaPixmap->pDamage) : NULL);
    fbPutImage (pDrawable, pGC, depth, x, y, w, h, leftPad, format, bits);
d118 1
d121 80
d207 1
d210 5
a214 3
    exaPrepareAccess (pDst, EXA_PREPARE_DEST);
    exaPrepareAccess (pSrc, EXA_PREPARE_SRC);
    ret = fbCopyArea (pSrc, pDst, pGC, srcx, srcy, w, h, dstx, dsty);
d217 1
d229 1
d232 5
a236 3
    exaPrepareAccess (pDst, EXA_PREPARE_DEST);
    exaPrepareAccess (pSrc, EXA_PREPARE_SRC);
    ret = fbCopyPlane (pSrc, pDst, pGC, srcx, srcy, w, h, dstx, dsty,
d240 1
d249 1
d252 1
a252 1
    fbPolyPoint (pDrawable, pGC, mode, npt, pptInit);
d254 1
d261 1
d266 6
a271 10
    if (pGC->lineWidth == 0) {
	exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
	exaPrepareAccessGC (pGC);
	fbPolyLine (pDrawable, pGC, mode, npt, ppt);
	exaFinishAccessGC (pGC);
	exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
	return;
    }
    /* fb calls mi functions in the lineWidth != 0 case. */
    fbPolyLine (pDrawable, pGC, mode, npt, ppt);
d278 1
d281 7
a287 10
    if (pGC->lineWidth == 0) {
	exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
	exaPrepareAccessGC (pGC);
	fbPolySegment (pDrawable, pGC, nsegInit, pSegInit);
	exaFinishAccessGC (pGC);
	exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
	return;
    }
    /* fb calls mi functions in the lineWidth != 0 case. */
    fbPolySegment (pDrawable, pGC, nsegInit, pSegInit);
d294 1
d297 6
a302 16
    /* Disable this as fbPolyArc can call miZeroPolyArc which in turn
     * can call accelerated functions, that as yet, haven't been notified
     * with exaFinishAccess().
     */
#if 0
    if (pGC->lineWidth == 0)
    {
	exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
	exaPrepareAccessGC (pGC);
	fbPolyArc (pDrawable, pGC, narcs, pArcs);
	exaFinishAccessGC (pGC);
	exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
	return;
    }
#endif
    miPolyArc (pDrawable, pGC, narcs, pArcs);
d309 1
d314 1
a314 1
    fbPolyFillRect (pDrawable, pGC, nrect, prect);
d317 1
d325 1
d330 1
a330 1
    fbImageGlyphBlt (pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
d333 1
d341 1
d346 1
a346 1
    fbPolyGlyphBlt (pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
d349 1
d357 1
d361 4
a364 2
    exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
    exaPrepareAccess (&pBitmap->drawable, EXA_PREPARE_SRC);
d366 1
a366 1
    fbPushPixels (pGC, pBitmap, pDrawable, w, h, x, y);
d370 46
d426 3
d431 3
a433 1
    fbGetSpans (pDrawable, wMax, ppt, pwidth, nspans, pdstStart);
d435 170
d621 12
a632 2
    RegionRec region;
    int xoff, yoff;
d634 11
a644 1
    REGION_NULL(pScreen, &region);
d646 1
a646 20
    /* We need to prepare access to any separate alpha maps first, in case the
     * driver doesn't support EXA_PREPARE_AUX*, in which case EXA_PREPARE_SRC
     * may be used for moving them out.
     */
    if (pSrc->alphaMap && pSrc->alphaMap->pDrawable)
	exaPrepareAccess(pSrc->alphaMap->pDrawable, EXA_PREPARE_AUX2);
    if (pMask && pMask->alphaMap && pMask->alphaMap->pDrawable)
	exaPrepareAccess(pMask->alphaMap->pDrawable, EXA_PREPARE_AUX1);

    if (!exaOpReadsDestination(op)) {
	if (!miComputeCompositeRegion (&region, pSrc, pMask, pDst,
				       xSrc, ySrc, xMask, yMask, xDst, yDst,
				       width, height))
	    return;

	exaGetDrawableDeltas (pDst->pDrawable,
			      exaGetDrawablePixmap(pDst->pDrawable),
			      &xoff, &yoff);

	REGION_TRANSLATE(pScreen, &region, xoff, yoff);
d648 2
a649 3
	if (pDst->alphaMap && pDst->alphaMap->pDrawable)
	    exaPrepareAccessReg(pDst->alphaMap->pDrawable, EXA_PREPARE_AUX0,
				&region);
d651 4
a654 6
	exaPrepareAccessReg (pDst->pDrawable, EXA_PREPARE_DEST, &region);
    } else {
	if (pDst->alphaMap && pDst->alphaMap->pDrawable)
	    exaPrepareAccess(pDst->alphaMap->pDrawable, EXA_PREPARE_AUX0);

	exaPrepareAccess (pDst->pDrawable, EXA_PREPARE_DEST);
d657 3
a659 8
    EXA_FALLBACK(("from picts %p/%p to pict %p\n",
		 pSrc, pMask, pDst));

    if (pSrc->pDrawable != NULL)
	exaPrepareAccess (pSrc->pDrawable, EXA_PREPARE_SRC);
    if (pMask && pMask->pDrawable != NULL)
	exaPrepareAccess (pMask->pDrawable, EXA_PREPARE_MASK);
    fbComposite (op,
d671 2
a674 2
    if (pMask && pMask->alphaMap && pMask->alphaMap->pDrawable)
	exaFinishAccess(pMask->alphaMap->pDrawable, EXA_PREPARE_AUX1);
a676 2
    if (pSrc->alphaMap && pSrc->alphaMap->pDrawable)
	exaFinishAccess(pSrc->alphaMap->pDrawable, EXA_PREPARE_AUX2);
d679 5
a683 1
	exaFinishAccess(pDst->alphaMap->pDrawable, EXA_PREPARE_AUX0);
d685 2
a686 1
    REGION_UNINIT(pScreen, &region);
d696 6
d705 5
a709 1
    fbAddTraps (pPicture, x_off, y_off, ntrap, traps);
d711 1
a716 2
 *
 * XXX This really belongs in fb, so it can be aware of tiling and etc.
a720 30
    CARD32 pixel;
    void *fb;
    Bool need_finish = FALSE;
    BoxRec box;
    RegionRec migration;
    ExaPixmapPriv (pPixmap);
    Bool sys_valid = pExaPixmap->pDamage &&
	!miPointInRegion(&pExaPixmap->validSys, 0, 0,  &box);
    Bool damaged = pExaPixmap->pDamage &&
 	miPointInRegion(DamageRegion(pExaPixmap->pDamage), 0, 0, &box);
    Bool offscreen = exaPixmapIsOffscreen(pPixmap);

    fb = pExaPixmap->sys_ptr;

    /* Try to avoid framebuffer readbacks */
    if ((!offscreen && !sys_valid && !damaged) ||
	(offscreen && (!sys_valid || damaged)))
    {
	box.x1 = 0;
	box.y1 = 0;
	box.x2 = 1;
	box.y2 = 1;
	REGION_INIT(pScreen, &migration, &box, 1);

	need_finish = TRUE;

	exaPrepareAccessReg(&pPixmap->drawable, EXA_PREPARE_SRC, &migration);
	fb = pPixmap->devPrivate.ptr;
    }

d723 7
a729 2
	pixel = *(CARD32 *)fb;
	break;
d731 15
a745 2
	pixel = *(CARD16 *)fb;
	break;
d747 2
a748 2
	pixel = *(CARD8 *)fb;
	break;
a749 7

    if (need_finish) {
	exaFinishAccess(&pPixmap->drawable, EXA_PREPARE_SRC);
	REGION_UNINIT(pScreen, &migration);
    }

    return pixel;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d60 1
a60 1
	exaFinishAccess(&pGC->tile.pixmap->drawable, EXA_PREPARE_MASK);
d62 1
a62 1
        exaFinishAccess(&pGC->stipple->drawable, EXA_PREPARE_SRC);
d100 2
d104 1
a104 1
			      pGC->alu))
d107 2
a108 1
	ExaDoPrepareAccess (pDrawable, EXA_PREPARE_DEST);
d312 9
d333 4
d338 4
a341 1
    } else
d343 1
d366 2
d370 2
d373 2
a401 1
    ExaScreenPriv(pPixmap->drawable.pScreen);
d408 4
a411 3
    Bool sys_valid = !miPointInRegion(&pExaPixmap->validSys, 0, 0,  &box);
    Bool damaged = miPointInRegion(DamageRegion(pExaPixmap->pDamage), 0, 0,
				   &box);
d417 1
a417 2
    if (pExaScr->info->CreatePixmap ||
	(!offscreen && !sys_valid && !damaged) ||
@


1.1
log
@Initial revision
@
text
@d26 4
d42 1
d47 2
d60 3
a62 1
	exaFinishAccess(&pGC->tile.pixmap->drawable, EXA_PREPARE_SRC);
d101 5
a105 1
    exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
d199 6
d214 1
d223 1
d268 1
d272 1
a276 13
ExaCheckGetImage (DrawablePtr pDrawable,
		 int x, int y, int w, int h,
		 unsigned int format, unsigned long planeMask,
		 char *d)
{
    EXA_FALLBACK(("from %p (%c)\n", pDrawable,
		  exaDrawableLocation(pDrawable)));
    exaPrepareAccess (pDrawable, EXA_PREPARE_SRC);
    fbGetImage (pDrawable, x, y, w, h, format, planeMask, d);
    exaFinishAccess (pDrawable, EXA_PREPARE_SRC);
}

void
a290 43
ExaCheckSaveAreas (PixmapPtr	pPixmap,
		  RegionPtr	prgnSave,
		  int		xorg,
		  int		yorg,
		  WindowPtr	pWin)
{
    EXA_FALLBACK(("from %p (%c)\n", &pPixmap->drawable,
		  exaDrawableLocation(&pPixmap->drawable)));
    exaPrepareAccess ((DrawablePtr)pPixmap, EXA_PREPARE_DEST);
    fbSaveAreas (pPixmap, prgnSave, xorg, yorg, pWin);
    exaFinishAccess ((DrawablePtr)pPixmap, EXA_PREPARE_DEST);
}

void
ExaCheckRestoreAreas (PixmapPtr	pPixmap,
		     RegionPtr	prgnSave,
		     int	xorg,
		     int    	yorg,
		     WindowPtr	pWin)
{
    EXA_FALLBACK(("to %p (%c)\n", &pPixmap->drawable,
		  exaDrawableLocation(&pPixmap->drawable)));
    exaPrepareAccess ((DrawablePtr)pPixmap, EXA_PREPARE_DEST);
    fbRestoreAreas (pPixmap, prgnSave, xorg, yorg, pWin);
    exaFinishAccess ((DrawablePtr)pPixmap, EXA_PREPARE_DEST);
}

/* XXX: Note the lack of a prepare on the tile, if the window has a tiled
 * background.  This function happens to only be called if pExaScr->swappedOut,
 * so we actually end up not having to do it since the tile won't be in fb.
 * That doesn't make this not dirty, though.
 */
void
ExaCheckPaintWindow (WindowPtr pWin, RegionPtr pRegion, int what)
{
    EXA_FALLBACK(("from %p (%c)\n", pWin,
		  exaDrawableLocation(&pWin->drawable)));
    exaPrepareAccess (&pWin->drawable, EXA_PREPARE_DEST);
    fbPaintWindow (pWin, pRegion, what);
    exaFinishAccess (&pWin->drawable, EXA_PREPARE_DEST);
}

void
d304 21
d327 1
a327 1
    exaPrepareAccess (pDst->pDrawable, EXA_PREPARE_DEST);
d349 16
d370 2
d376 1
d378 22
a399 1
    ExaMigrationRec pixmaps[1];
d401 5
a405 4
    pixmaps[0].as_dst = FALSE;
    pixmaps[0].as_src = TRUE;
    pixmaps[0].pPix = pPixmap;
    exaDoMigration (pixmaps, 1, FALSE);
a406 1
    exaPrepareAccess(&pPixmap->drawable, EXA_PREPARE_SRC);
d409 1
a409 1
	pixel = *(CARD32 *)(pPixmap->devPrivate.ptr);
d412 1
a412 1
	pixel = *(CARD16 *)(pPixmap->devPrivate.ptr);
d415 1
a415 1
	pixel = *(CARD8 *)(pPixmap->devPrivate.ptr);
d418 5
a422 1
    exaFinishAccess(&pPixmap->drawable, EXA_PREPARE_SRC);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a90 3
    PixmapPtr pPixmap = exaGetDrawablePixmap(pDrawable);
    int xoff, yoff;

a94 2
    exaGetDrawableDeltas(pDrawable, pPixmap, &xoff, &yoff);
    exaPixmapDirty(pPixmap, x + xoff, y + yoff, x + xoff + w, y + yoff + h);
a202 1

a365 2
 *
 * XXX This really belongs in fb, so it can be aware of tiling and etc.
a370 3
    void *fb;
    Bool need_finish = FALSE;
    BoxRec box;
a371 3
    ExaPixmapPriv (pPixmap);

    fb = pExaPixmap->sys_ptr;
d373 4
a376 12
    /* Try to avoid framebuffer readbacks */
    if (exaPixmapIsOffscreen(pPixmap) &&
        miPointInRegion(DamageRegion(pExaPixmap->pDamage), 0, 0,  &box))
    {
	need_finish = TRUE;
	pixmaps[0].as_dst = FALSE;
	pixmaps[0].as_src = TRUE;
	pixmaps[0].pPix = pPixmap;
	exaDoMigration (pixmaps, 1, FALSE);
	exaPrepareAccess(&pPixmap->drawable, EXA_PREPARE_SRC);
	fb = pPixmap->devPrivate.ptr;
    }
d378 1
d381 1
a381 1
	pixel = *(CARD32 *)fb;
d384 1
a384 1
	pixel = *(CARD16 *)fb;
d387 1
a387 1
	pixel = *(CARD8 *)fb;
d390 1
a390 3

    if (need_finish)
	exaFinishAccess(&pPixmap->drawable, EXA_PREPARE_SRC);
@

