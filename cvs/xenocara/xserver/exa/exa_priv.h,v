head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.6
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.42;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.42;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.06.35;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *
 * Copyright (C) 2000 Keith Packard, member of The XFree86 Project, Inc.
 *               2005 Zack Rusin, Trolltech
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

#ifndef EXAPRIV_H
#define EXAPRIV_H

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "exa.h"

#include <X11/X.h>
#include <X11/Xproto.h>
#ifdef MITSHM
#include "shmint.h"
#endif
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "servermd.h"
#include "colormapst.h"
#include "gcstruct.h"
#include "input.h"
#include "mipointer.h"
#include "mi.h"
#include "dix.h"
#include "fb.h"
#include "fboverlay.h"
#include "fbpict.h"
#include "glyphstr.h"
#include "damage.h"

#define DEBUG_TRACE_FALL	0
#define DEBUG_MIGRATE		0
#define DEBUG_PIXMAP		0
#define DEBUG_OFFSCREEN		0
#define DEBUG_GLYPH_CACHE	0

#if DEBUG_TRACE_FALL
#define EXA_FALLBACK(x)     					\
do {								\
	ErrorF("EXA fallback at %s: ", __FUNCTION__);		\
	ErrorF x;						\
} while (0)

char
 exaDrawableLocation(DrawablePtr pDrawable);
#else
#define EXA_FALLBACK(x)
#endif

#if DEBUG_PIXMAP
#define DBG_PIXMAP(a) ErrorF a
#else
#define DBG_PIXMAP(a)
#endif

#ifndef EXA_MAX_FB
#define EXA_MAX_FB   FB_OVERLAY_MAX
#endif

#ifdef DEBUG
#define EXA_FatalErrorDebug(x) FatalError x
#define EXA_FatalErrorDebugWithRet(x, ret) FatalError x
#else
#define EXA_FatalErrorDebug(x) ErrorF x
#define EXA_FatalErrorDebugWithRet(x, ret) \
do { \
    ErrorF x; \
    return ret; \
} while (0)
#endif

/**
 * This is the list of migration heuristics supported by EXA.  See
 * exaDoMigration() for what their implementations do.
 */
enum ExaMigrationHeuristic {
    ExaMigrationGreedy,
    ExaMigrationAlways,
    ExaMigrationSmart
};

typedef struct {
    unsigned char sha1[20];
} ExaCachedGlyphRec, *ExaCachedGlyphPtr;

typedef struct {
    /* The identity of the cache, statically configured at initialization */
    unsigned int format;
    int glyphWidth;
    int glyphHeight;

    int size;                   /* Size of cache; eventually this should be dynamically determined */

    /* Hash table mapping from glyph sha1 to position in the glyph; we use
     * open addressing with a hash table size determined based on size and large
     * enough so that we always have a good amount of free space, so we can
     * use linear probing. (Linear probing is preferrable to double hashing
     * here because it allows us to easily remove entries.)
     */
    int *hashEntries;
    int hashSize;

    ExaCachedGlyphPtr glyphs;
    int glyphCount;             /* Current number of glyphs */

    PicturePtr picture;         /* Where the glyphs of the cache are stored */
    int yOffset;                /* y location within the picture where the cache starts */
    int columns;                /* Number of columns the glyphs are layed out in */
    int evictionPosition;       /* Next random position to evict a glyph */
} ExaGlyphCacheRec, *ExaGlyphCachePtr;

#define EXA_NUM_GLYPH_CACHES 4

#define EXA_FALLBACK_COPYWINDOW (1 << 0)
#define EXA_ACCEL_COPYWINDOW (1 << 1)

typedef struct _ExaMigrationRec {
    Bool as_dst;
    Bool as_src;
    PixmapPtr pPix;
    RegionPtr pReg;
} ExaMigrationRec, *ExaMigrationPtr;

typedef void (*EnableDisableFBAccessProcPtr) (ScreenPtr, Bool);
typedef struct {
    ExaDriverPtr info;
    ScreenBlockHandlerProcPtr SavedBlockHandler;
    ScreenWakeupHandlerProcPtr SavedWakeupHandler;
    CreateGCProcPtr SavedCreateGC;
    CloseScreenProcPtr SavedCloseScreen;
    GetImageProcPtr SavedGetImage;
    GetSpansProcPtr SavedGetSpans;
    CreatePixmapProcPtr SavedCreatePixmap;
    DestroyPixmapProcPtr SavedDestroyPixmap;
    CopyWindowProcPtr SavedCopyWindow;
    ChangeWindowAttributesProcPtr SavedChangeWindowAttributes;
    BitmapToRegionProcPtr SavedBitmapToRegion;
    CreateScreenResourcesProcPtr SavedCreateScreenResources;
    ModifyPixmapHeaderProcPtr SavedModifyPixmapHeader;
    SharePixmapBackingProcPtr SavedSharePixmapBacking;
    SetSharedPixmapBackingProcPtr SavedSetSharedPixmapBacking;
    SourceValidateProcPtr SavedSourceValidate;
    CompositeProcPtr SavedComposite;
    TrianglesProcPtr SavedTriangles;
    GlyphsProcPtr SavedGlyphs;
    TrapezoidsProcPtr SavedTrapezoids;
    AddTrapsProcPtr SavedAddTraps;
    void (*do_migration) (ExaMigrationPtr pixmaps, int npixmaps,
                          Bool can_accel);
    Bool (*pixmap_has_gpu_copy) (PixmapPtr pPixmap);
    void (*do_move_in_pixmap) (PixmapPtr pPixmap);
    void (*do_move_out_pixmap) (PixmapPtr pPixmap);
    void (*prepare_access_reg) (PixmapPtr pPixmap, int index, RegionPtr pReg);

    Bool swappedOut;
    enum ExaMigrationHeuristic migration;
    Bool checkDirtyCorrectness;
    unsigned disableFbCount;
    Bool optimize_migration;
    unsigned offScreenCounter;
    unsigned numOffscreenAvailable;
    CARD32 lastDefragment;
    CARD32 nextDefragment;
    PixmapPtr deferred_mixed_pixmap;

    /* Reference counting for accessed pixmaps */
    struct {
        PixmapPtr pixmap;
        int count;
        Bool retval;
    } access[EXA_NUM_PREPARE_INDICES];

    /* Holds information on fallbacks that cannot be relayed otherwise. */
    unsigned int fallback_flags;
    unsigned int fallback_counter;

    ExaGlyphCacheRec glyphCaches[EXA_NUM_GLYPH_CACHES];

    /**
     * Regions affected by fallback composite source / mask operations.
     */

    RegionRec srcReg;
    RegionRec maskReg;
    PixmapPtr srcPix;
    PixmapPtr maskPix;

    DevPrivateKeyRec pixmapPrivateKeyRec;
    DevPrivateKeyRec gcPrivateKeyRec;
} ExaScreenPrivRec, *ExaScreenPrivPtr;

extern DevPrivateKeyRec exaScreenPrivateKeyRec;

#define exaScreenPrivateKey (&exaScreenPrivateKeyRec)

#define ExaGetScreenPriv(s) ((ExaScreenPrivPtr)dixGetPrivate(&(s)->devPrivates, exaScreenPrivateKey))
#define ExaScreenPriv(s)	ExaScreenPrivPtr    pExaScr = ExaGetScreenPriv(s)

#define ExaGetGCPriv(gc) ((ExaGCPrivPtr)dixGetPrivateAddr(&(gc)->devPrivates, &ExaGetScreenPriv(gc->pScreen)->gcPrivateKeyRec))
#define ExaGCPriv(gc) ExaGCPrivPtr pExaGC = ExaGetGCPriv(gc)

/*
 * Some macros to deal with function wrapping.
 */
#define wrap(priv, real, mem, func) {\
    priv->Saved##mem = real->mem; \
    real->mem = func; \
}

#define unwrap(priv, real, mem) {\
    real->mem = priv->Saved##mem; \
}

#ifdef HAVE_TYPEOF
#define swap(priv, real, mem) {\
    typeof(real->mem) tmp = priv->Saved##mem; \
    priv->Saved##mem = real->mem; \
    real->mem = tmp; \
}
#else
#define swap(priv, real, mem) {\
    void *tmp = priv->Saved##mem; \
    priv->Saved##mem = real->mem; \
    real->mem = tmp; \
}
#endif

#define EXA_PRE_FALLBACK(_screen_) \
    ExaScreenPriv(_screen_); \
    pExaScr->fallback_counter++;

#define EXA_POST_FALLBACK(_screen_) \
    pExaScr->fallback_counter--;

#define EXA_PRE_FALLBACK_GC(_gc_) \
    ExaScreenPriv(_gc_->pScreen); \
    ExaGCPriv(_gc_); \
    pExaScr->fallback_counter++; \
    swap(pExaGC, _gc_, ops);

#define EXA_POST_FALLBACK_GC(_gc_) \
    pExaScr->fallback_counter--; \
    swap(pExaGC, _gc_, ops);

/** Align an offset to an arbitrary alignment */
#define EXA_ALIGN(offset, align) (((offset) + (align) - 1) - \
	(((offset) + (align) - 1) % (align)))
/** Align an offset to a power-of-two alignment */
#define EXA_ALIGN2(offset, align) (((offset) + (align) - 1) & ~((align) - 1))

#define EXA_PIXMAP_SCORE_MOVE_IN    10
#define EXA_PIXMAP_SCORE_MAX	    20
#define EXA_PIXMAP_SCORE_MOVE_OUT   -10
#define EXA_PIXMAP_SCORE_MIN	    -20
#define EXA_PIXMAP_SCORE_PINNED	    1000
#define EXA_PIXMAP_SCORE_INIT	    1001

#define ExaGetPixmapPriv(p) ((ExaPixmapPrivPtr)dixGetPrivateAddr(&(p)->devPrivates, &ExaGetScreenPriv((p)->drawable.pScreen)->pixmapPrivateKeyRec))
#define ExaPixmapPriv(p)	ExaPixmapPrivPtr pExaPixmap = ExaGetPixmapPriv(p)

#define EXA_RANGE_PITCH (1 << 0)
#define EXA_RANGE_WIDTH (1 << 1)
#define EXA_RANGE_HEIGHT (1 << 2)

typedef struct {
    ExaOffscreenArea *area;
    int score;                  /**< score for the move-in vs move-out heuristic */
    Bool use_gpu_copy;

    CARD8 *sys_ptr;             /**< pointer to pixmap data in system memory */
    int sys_pitch;              /**< pitch of pixmap in system memory */

    CARD8 *fb_ptr;              /**< pointer to pixmap data in framebuffer memory */
    int fb_pitch;               /**< pitch of pixmap in framebuffer memory */
    unsigned int fb_size;       /**< size of pixmap in framebuffer memory */

    /**
     * Holds information about whether this pixmap can be used for
     * acceleration (== 0) or not (> 0).
     *
     * Contains a OR'ed combination of the following values:
     * EXA_RANGE_PITCH - set if the pixmap's pitch is out of range
     * EXA_RANGE_WIDTH - set if the pixmap's width is out of range
     * EXA_RANGE_HEIGHT - set if the pixmap's height is out of range
     */
    unsigned int accel_blocked;

    /**
     * The damage record contains the areas of the pixmap's current location
     * (framebuffer or system) that have been damaged compared to the other
     * location.
     */
    DamagePtr pDamage;
    /**
     * The valid regions mark the valid bits (at least, as they're derived from
     * damage, which may be overreported) of a pixmap's system and FB copies.
     */
    RegionRec validSys, validFB;
    /**
     * Driver private storage per EXA pixmap
     */
    void *driverPriv;
} ExaPixmapPrivRec, *ExaPixmapPrivPtr;

typedef struct {
    /* GC values from the layer below. */
    const GCOps *Savedops;
    const GCFuncs *Savedfuncs;
} ExaGCPrivRec, *ExaGCPrivPtr;

typedef struct {
    PicturePtr pDst;
    INT16 xSrc;
    INT16 ySrc;
    INT16 xMask;
    INT16 yMask;
    INT16 xDst;
    INT16 yDst;
    INT16 width;
    INT16 height;
} ExaCompositeRectRec, *ExaCompositeRectPtr;

/**
 * exaDDXDriverInit must be implemented by the DDX using EXA, and is the place
 * to set EXA options or hook in screen functions to handle using EXA as the AA.
  */
void exaDDXDriverInit(ScreenPtr pScreen);

/* exa_unaccel.c */
void
 exaPrepareAccessGC(GCPtr pGC);

void
 exaFinishAccessGC(GCPtr pGC);

void

ExaCheckFillSpans(DrawablePtr pDrawable, GCPtr pGC, int nspans,
                  DDXPointPtr ppt, int *pwidth, int fSorted);

void

ExaCheckSetSpans(DrawablePtr pDrawable, GCPtr pGC, char *psrc,
                 DDXPointPtr ppt, int *pwidth, int nspans, int fSorted);

void

ExaCheckPutImage(DrawablePtr pDrawable, GCPtr pGC, int depth,
                 int x, int y, int w, int h, int leftPad, int format,
                 char *bits);

void

ExaCheckCopyNtoN(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
                 BoxPtr pbox, int nbox, int dx, int dy, Bool reverse,
                 Bool upsidedown, Pixel bitplane, void *closure);

RegionPtr

ExaCheckCopyArea(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
                 int srcx, int srcy, int w, int h, int dstx, int dsty);

RegionPtr

ExaCheckCopyPlane(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
                  int srcx, int srcy, int w, int h, int dstx, int dsty,
                  unsigned long bitPlane);

void

ExaCheckPolyPoint(DrawablePtr pDrawable, GCPtr pGC, int mode, int npt,
                  DDXPointPtr pptInit);

void

ExaCheckPolylines(DrawablePtr pDrawable, GCPtr pGC,
                  int mode, int npt, DDXPointPtr ppt);

void

ExaCheckPolySegment(DrawablePtr pDrawable, GCPtr pGC,
                    int nsegInit, xSegment * pSegInit);

void
 ExaCheckPolyArc(DrawablePtr pDrawable, GCPtr pGC, int narcs, xArc * pArcs);

void

ExaCheckPolyFillRect(DrawablePtr pDrawable, GCPtr pGC,
                     int nrect, xRectangle *prect);

void

ExaCheckImageGlyphBlt(DrawablePtr pDrawable, GCPtr pGC,
                      int x, int y, unsigned int nglyph,
                      CharInfoPtr * ppci, void *pglyphBase);

void

ExaCheckPolyGlyphBlt(DrawablePtr pDrawable, GCPtr pGC,
                     int x, int y, unsigned int nglyph,
                     CharInfoPtr * ppci, void *pglyphBase);

void

ExaCheckPushPixels(GCPtr pGC, PixmapPtr pBitmap,
                   DrawablePtr pDrawable, int w, int h, int x, int y);

void
 ExaCheckCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc);

void

ExaCheckGetImage(DrawablePtr pDrawable, int x, int y, int w, int h,
                 unsigned int format, unsigned long planeMask, char *d);

void

ExaCheckGetSpans(DrawablePtr pDrawable,
                 int wMax,
                 DDXPointPtr ppt, int *pwidth, int nspans, char *pdstStart);

void

ExaCheckAddTraps(PicturePtr pPicture,
                 INT16 x_off, INT16 y_off, int ntrap, xTrap * traps);

/* exa_accel.c */

static _X_INLINE Bool
exaGCReadsDestination(DrawablePtr pDrawable, unsigned long planemask,
                      unsigned int fillStyle, unsigned char alu,
                      Bool clientClip)
{
    return ((alu != GXcopy && alu != GXclear && alu != GXset &&
             alu != GXcopyInverted) || fillStyle == FillStippled ||
            clientClip != FALSE || !EXA_PM_IS_SOLID(pDrawable, planemask));
}

void
 exaCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc);

Bool

exaFillRegionTiled(DrawablePtr pDrawable, RegionPtr pRegion, PixmapPtr pTile,
                   DDXPointPtr pPatOrg, CARD32 planemask, CARD32 alu,
                   Bool clientClip);

void

exaGetImage(DrawablePtr pDrawable, int x, int y, int w, int h,
            unsigned int format, unsigned long planeMask, char *d);

RegionPtr

exaCopyArea(DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable, GCPtr pGC,
            int srcx, int srcy, int width, int height, int dstx, int dsty);

Bool

exaHWCopyNtoN(DrawablePtr pSrcDrawable,
              DrawablePtr pDstDrawable,
              GCPtr pGC,
              BoxPtr pbox,
              int nbox, int dx, int dy, Bool reverse, Bool upsidedown);

void

exaCopyNtoN(DrawablePtr pSrcDrawable,
            DrawablePtr pDstDrawable,
            GCPtr pGC,
            BoxPtr pbox,
            int nbox,
            int dx,
            int dy,
            Bool reverse, Bool upsidedown, Pixel bitplane, void *closure);

extern const GCOps exaOps;

void

ExaCheckComposite(CARD8 op,
                  PicturePtr pSrc,
                  PicturePtr pMask,
                  PicturePtr pDst,
                  INT16 xSrc,
                  INT16 ySrc,
                  INT16 xMask,
                  INT16 yMask,
                  INT16 xDst, INT16 yDst, CARD16 width, CARD16 height);

void

ExaCheckGlyphs(CARD8 op,
               PicturePtr pSrc,
               PicturePtr pDst,
               PictFormatPtr maskFormat,
               INT16 xSrc,
               INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs);

/* exa_offscreen.c */
void
 ExaOffscreenSwapOut(ScreenPtr pScreen);

void
 ExaOffscreenSwapIn(ScreenPtr pScreen);

ExaOffscreenArea *ExaOffscreenDefragment(ScreenPtr pScreen);

Bool
 exaOffscreenInit(ScreenPtr pScreen);

void
 ExaOffscreenFini(ScreenPtr pScreen);

/* exa.c */
Bool
 ExaDoPrepareAccess(PixmapPtr pPixmap, int index);

void
 exaPrepareAccess(DrawablePtr pDrawable, int index);

void
 exaFinishAccess(DrawablePtr pDrawable, int index);

void
 exaDestroyPixmap(PixmapPtr pPixmap);

void
 exaPixmapDirty(PixmapPtr pPix, int x1, int y1, int x2, int y2);

void

exaGetDrawableDeltas(DrawablePtr pDrawable, PixmapPtr pPixmap,
                     int *xp, int *yp);

Bool
 exaPixmapHasGpuCopy(PixmapPtr p);

PixmapPtr
 exaGetOffscreenPixmap(DrawablePtr pDrawable, int *xp, int *yp);

PixmapPtr
 exaGetDrawablePixmap(DrawablePtr pDrawable);

void

exaSetFbPitch(ExaScreenPrivPtr pExaScr, ExaPixmapPrivPtr pExaPixmap,
              int w, int h, int bpp);

void

exaSetAccelBlock(ExaScreenPrivPtr pExaScr, ExaPixmapPrivPtr pExaPixmap,
                 int w, int h, int bpp);

void
 exaDoMigration(ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel);

Bool
 exaPixmapIsPinned(PixmapPtr pPix);

extern const GCFuncs exaGCFuncs;

/* exa_classic.c */
PixmapPtr

exaCreatePixmap_classic(ScreenPtr pScreen, int w, int h, int depth,
                        unsigned usage_hint);

Bool

exaModifyPixmapHeader_classic(PixmapPtr pPixmap, int width, int height,
                              int depth, int bitsPerPixel, int devKind,
                              void *pPixData);

Bool
 exaDestroyPixmap_classic(PixmapPtr pPixmap);

Bool
 exaPixmapHasGpuCopy_classic(PixmapPtr pPixmap);

/* exa_driver.c */
PixmapPtr

exaCreatePixmap_driver(ScreenPtr pScreen, int w, int h, int depth,
                       unsigned usage_hint);

Bool

exaModifyPixmapHeader_driver(PixmapPtr pPixmap, int width, int height,
                             int depth, int bitsPerPixel, int devKind,
                             void *pPixData);

Bool
 exaDestroyPixmap_driver(PixmapPtr pPixmap);

Bool
 exaPixmapHasGpuCopy_driver(PixmapPtr pPixmap);

/* exa_mixed.c */
PixmapPtr

exaCreatePixmap_mixed(ScreenPtr pScreen, int w, int h, int depth,
                      unsigned usage_hint);

Bool

exaModifyPixmapHeader_mixed(PixmapPtr pPixmap, int width, int height, int depth,
                            int bitsPerPixel, int devKind, void *pPixData);

Bool
 exaDestroyPixmap_mixed(PixmapPtr pPixmap);

Bool
 exaPixmapHasGpuCopy_mixed(PixmapPtr pPixmap);

/* exa_migration_mixed.c */
void
 exaCreateDriverPixmap_mixed(PixmapPtr pPixmap);

void
 exaDoMigration_mixed(ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel);

void
 exaMoveInPixmap_mixed(PixmapPtr pPixmap);

void
 exaDamageReport_mixed(DamagePtr pDamage, RegionPtr pRegion, void *closure);

void
 exaPrepareAccessReg_mixed(PixmapPtr pPixmap, int index, RegionPtr pReg);

Bool
exaSetSharedPixmapBacking_mixed(PixmapPtr pPixmap, void *handle);
Bool
exaSharePixmapBacking_mixed(PixmapPtr pPixmap, ScreenPtr slave, void **handle_p);

/* exa_render.c */
Bool
 exaOpReadsDestination(CARD8 op);

void

exaComposite(CARD8 op,
             PicturePtr pSrc,
             PicturePtr pMask,
             PicturePtr pDst,
             INT16 xSrc,
             INT16 ySrc,
             INT16 xMask,
             INT16 yMask, INT16 xDst, INT16 yDst, CARD16 width, CARD16 height);

void

exaCompositeRects(CARD8 op,
                  PicturePtr Src,
                  PicturePtr pMask,
                  PicturePtr pDst, int nrect, ExaCompositeRectPtr rects);

void

exaTrapezoids(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
              PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
              int ntrap, xTrapezoid * traps);

void

exaTriangles(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
             PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
             int ntri, xTriangle * tris);

/* exa_glyph.c */
void
 exaGlyphsInit(ScreenPtr pScreen);

void
 exaGlyphsFini(ScreenPtr pScreen);

void

exaGlyphs(CARD8 op,
          PicturePtr pSrc,
          PicturePtr pDst,
          PictFormatPtr maskFormat,
          INT16 xSrc,
          INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs);

/* exa_migration_classic.c */
void
 exaCopyDirtyToSys(ExaMigrationPtr migrate);

void
 exaCopyDirtyToFb(ExaMigrationPtr migrate);

void
 exaDoMigration_classic(ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel);

void
 exaPixmapSave(ScreenPtr pScreen, ExaOffscreenArea * area);

void
 exaMoveOutPixmap_classic(PixmapPtr pPixmap);

void
 exaMoveInPixmap_classic(PixmapPtr pPixmap);

void
 exaPrepareAccessReg_classic(PixmapPtr pPixmap, int index, RegionPtr pReg);

#endif                          /* EXAPRIV_H */
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a216 12
/*
 * This is the only completely portable way to
 * compute this info.
 */
#ifndef BitsPerPixel
#define BitsPerPixel(d) (\
    PixmapWidthPaddingInfo[d].notPower2 ? \
    (PixmapWidthPaddingInfo[d].bytesPerPixel * 8) : \
    ((1 << PixmapWidthPaddingInfo[d].padBytesLog2) * 8 / \
    (PixmapWidthPaddingInfo[d].padRoundUp+1)))
#endif

d458 1
a458 1
                      unsigned int clientClipType)
d462 1
a462 2
            clientClipType != CT_NONE ||
            !EXA_PM_IS_SOLID(pDrawable, planemask));
d472 1
a472 1
                   unsigned int clientClipType);
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d251 7
d263 1
d344 2
a345 2
    GCOps *Savedops;
    GCFuncs *Savedfuncs;
d433 1
a433 1
                      CharInfoPtr * ppci, pointer pglyphBase);
d439 1
a439 1
                     CharInfoPtr * ppci, pointer pglyphBase);
d612 1
a612 1
                              pointer pPixData);
d630 1
a630 1
                             pointer pPixData);
d647 1
a647 1
                            int bitsPerPixel, int devKind, pointer pPixData);
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a43 1
#include "mibstore.h"
d149 1
a149 1
typedef void (*EnableDisableFBAccessProcPtr) (int, Bool);
d165 2
d211 1
d213 2
a231 6
extern DevPrivateKeyRec exaPixmapPrivateKeyRec;

#define exaPixmapPrivateKey (&exaPixmapPrivateKeyRec)
extern DevPrivateKeyRec exaGCPrivateKeyRec;

#define exaGCPrivateKey (&exaGCPrivateKeyRec)
d236 1
a236 1
#define ExaGetGCPriv(gc) ((ExaGCPrivPtr)dixGetPrivateAddr(&(gc)->devPrivates, exaGCPrivateKey))
d287 1
a287 1
#define ExaGetPixmapPriv(p) ((ExaPixmapPrivPtr)dixGetPrivateAddr(&(p)->devPrivates, exaPixmapPrivateKey))
d662 5
@


1.7
log
@Update to xserver 1.11.2
@
text
@d71 1
a71 1
exaDrawableLocation(DrawablePtr pDrawable);
d118 1
a118 1
    int size; /* Size of cache; eventually this should be dynamically determined */
d128 1
a128 1
    
d130 6
a135 6
    int glyphCount; /* Current number of glyphs */
    
    PicturePtr picture;   /* Where the glyphs of the cache are stored */
    int yOffset;          /* y location within the picture where the cache starts */
    int columns;          /* Number of columns the glyphs are layed out in */
    int evictionPosition; /* Next random position to evict a glyph */
d150 1
a150 1
typedef void (*EnableDisableFBAccessProcPtr)(int, Bool);
d153 9
a161 9
    ScreenBlockHandlerProcPtr	 SavedBlockHandler;
    ScreenWakeupHandlerProcPtr	 SavedWakeupHandler;
    CreateGCProcPtr 		 SavedCreateGC;
    CloseScreenProcPtr 		 SavedCloseScreen;
    GetImageProcPtr 		 SavedGetImage;
    GetSpansProcPtr 		 SavedGetSpans;
    CreatePixmapProcPtr 	 SavedCreatePixmap;
    DestroyPixmapProcPtr 	 SavedDestroyPixmap;
    CopyWindowProcPtr 		 SavedCopyWindow;
d163 1
a163 1
    BitmapToRegionProcPtr        SavedBitmapToRegion;
d165 9
a173 8
    ModifyPixmapHeaderProcPtr    SavedModifyPixmapHeader;
    SourceValidateProcPtr        SavedSourceValidate;
    CompositeProcPtr             SavedComposite;
    TrianglesProcPtr		 SavedTriangles;
    GlyphsProcPtr                SavedGlyphs;
    TrapezoidsProcPtr            SavedTrapezoids;
    AddTrapsProcPtr		 SavedAddTraps;
    void (*do_migration) (ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel);
d177 1
a177 1
    void (*prepare_access_reg)(PixmapPtr pPixmap, int index, RegionPtr pReg);
d179 10
a188 10
    Bool			 swappedOut;
    enum ExaMigrationHeuristic	 migration;
    Bool			 checkDirtyCorrectness;
    unsigned			 disableFbCount;
    Bool			 optimize_migration;
    unsigned			 offScreenCounter;
    unsigned			 numOffscreenAvailable;
    CARD32			 lastDefragment;
    CARD32			 nextDefragment;
    PixmapPtr			 deferred_mixed_pixmap;
d192 3
a194 3
	PixmapPtr pixmap;
	int count;
	Bool retval;
d201 1
a201 1
    ExaGlyphCacheRec             glyphCaches[EXA_NUM_GLYPH_CACHES];
d226 1
d229 1
d232 1
d298 2
a299 2
    int		    score;	/**< score for the move-in vs move-out heuristic */
    Bool	    use_gpu_copy;
d301 2
a302 2
    CARD8	    *sys_ptr;	/**< pointer to pixmap data in system memory */
    int		    sys_pitch;	/**< pitch of pixmap in system memory */
d304 3
a306 3
    CARD8	    *fb_ptr;	/**< pointer to pixmap data in framebuffer memory */
    int		    fb_pitch;	/**< pitch of pixmap in framebuffer memory */
    unsigned int    fb_size;	/**< size of pixmap in framebuffer memory */
d317 1
a317 1
    unsigned int    accel_blocked;
d324 1
a324 1
    DamagePtr	    pDamage;
d329 1
a329 1
    RegionRec	    validSys, validFB;
d358 1
a358 1
void exaDDXDriverInit (ScreenPtr pScreen);
d362 1
a362 1
exaPrepareAccessGC(GCPtr pGC);
d365 1
a365 1
exaFinishAccessGC(GCPtr pGC);
d368 3
a370 2
ExaCheckFillSpans  (DrawablePtr pDrawable, GCPtr pGC, int nspans,
		   DDXPointPtr ppt, int *pwidth, int fSorted);
d373 3
a375 2
ExaCheckSetSpans (DrawablePtr pDrawable, GCPtr pGC, char *psrc,
		 DDXPointPtr ppt, int *pwidth, int nspans, int fSorted);
d378 4
a381 3
ExaCheckPutImage (DrawablePtr pDrawable, GCPtr pGC, int depth,
		 int x, int y, int w, int h, int leftPad, int format,
		 char *bits);
d384 4
a387 3
ExaCheckCopyNtoN (DrawablePtr pSrc, DrawablePtr pDst,  GCPtr pGC,
	     BoxPtr	pbox, int nbox, int dx, int dy, Bool	reverse, 
	     Bool upsidedown, Pixel bitplane, void *closure);
d390 3
a392 2
ExaCheckCopyArea (DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
		 int srcx, int srcy, int w, int h, int dstx, int dsty);
d395 4
a398 3
ExaCheckCopyPlane (DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
		  int srcx, int srcy, int w, int h, int dstx, int dsty,
		  unsigned long bitPlane);
d401 3
a403 2
ExaCheckPolyPoint (DrawablePtr pDrawable, GCPtr pGC, int mode, int npt,
		  DDXPointPtr pptInit);
d406 3
a408 2
ExaCheckPolylines (DrawablePtr pDrawable, GCPtr pGC,
		  int mode, int npt, DDXPointPtr ppt);
d411 3
a413 2
ExaCheckPolySegment (DrawablePtr pDrawable, GCPtr pGC,
		    int nsegInit, xSegment *pSegInit);
d416 1
a416 2
ExaCheckPolyArc (DrawablePtr pDrawable, GCPtr pGC,
		int narcs, xArc *pArcs);
d419 3
a421 2
ExaCheckPolyFillRect (DrawablePtr pDrawable, GCPtr pGC,
		     int nrect, xRectangle *prect);
d424 4
a427 3
ExaCheckImageGlyphBlt (DrawablePtr pDrawable, GCPtr pGC,
		      int x, int y, unsigned int nglyph,
		      CharInfoPtr *ppci, pointer pglyphBase);
d430 4
a433 3
ExaCheckPolyGlyphBlt (DrawablePtr pDrawable, GCPtr pGC,
		     int x, int y, unsigned int nglyph,
		     CharInfoPtr *ppci, pointer pglyphBase);
d436 3
a438 3
ExaCheckPushPixels (GCPtr pGC, PixmapPtr pBitmap,
		   DrawablePtr pDrawable,
		   int w, int h, int x, int y);
d441 1
a441 1
ExaCheckCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc);
d444 1
d446 1
a446 1
		unsigned int format, unsigned long planeMask, char *d);
d449 9
a457 13
ExaCheckGetSpans (DrawablePtr pDrawable,
		 int wMax,
		 DDXPointPtr ppt,
		 int *pwidth,
		 int nspans,
		 char *pdstStart);

void
ExaCheckAddTraps (PicturePtr	pPicture,
		  INT16		x_off,
		  INT16		y_off,
		  int		ntrap,
		  xTrap		*traps);
d463 2
a464 2
		      unsigned int fillStyle, unsigned char alu,
		      unsigned int clientClipType)
d467 3
a469 2
	     alu != GXcopyInverted) || fillStyle == FillStippled ||
	    clientClipType != CT_NONE || !EXA_PM_IS_SOLID(pDrawable, planemask));
d473 1
a473 1
exaCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc);
d476 4
a479 3
exaFillRegionTiled (DrawablePtr	pDrawable, RegionPtr pRegion, PixmapPtr pTile,
		    DDXPointPtr pPatOrg, CARD32 planemask, CARD32 alu,
		    unsigned int clientClipType);
d482 3
a484 2
exaGetImage (DrawablePtr pDrawable, int x, int y, int w, int h,
	     unsigned int format, unsigned long planeMask, char *d);
d487 1
d489 1
a489 1
	    int srcx, int srcy, int width, int height, int dstx, int dsty);
d492 17
a508 22
exaHWCopyNtoN (DrawablePtr    pSrcDrawable,
	     DrawablePtr    pDstDrawable,
	     GCPtr	    pGC,
	     BoxPtr	    pbox,
	     int	    nbox,
	     int	    dx,
	     int	    dy,
	     Bool	    reverse,
	     Bool	    upsidedown);

void
exaCopyNtoN (DrawablePtr    pSrcDrawable,
	     DrawablePtr    pDstDrawable,
	     GCPtr	    pGC,
	     BoxPtr	    pbox,
	     int	    nbox,
	     int	    dx,
	     int	    dy,
	     Bool	    reverse,
	     Bool	    upsidedown,
	     Pixel	    bitplane,
	     void	    *closure);
d513 19
a531 23
ExaCheckComposite (CARD8      op,
		  PicturePtr pSrc,
		  PicturePtr pMask,
		  PicturePtr pDst,
		  INT16      xSrc,
		  INT16      ySrc,
		  INT16      xMask,
		  INT16      yMask,
		  INT16      xDst,
		  INT16      yDst,
		  CARD16     width,
		  CARD16     height);

void
ExaCheckGlyphs (CARD8	      op,
		PicturePtr    pSrc,
		PicturePtr    pDst,
		PictFormatPtr maskFormat,
		INT16	      xSrc,
		INT16	      ySrc,
		int	      nlist,
		GlyphListPtr  list,
		GlyphPtr      *glyphs);
d535 1
a535 1
ExaOffscreenSwapOut (ScreenPtr pScreen);
d538 1
a538 1
ExaOffscreenSwapIn (ScreenPtr pScreen);
d540 1
a540 2
ExaOffscreenArea*
ExaOffscreenDefragment (ScreenPtr pScreen);
d543 1
a543 1
exaOffscreenInit(ScreenPtr pScreen);
d546 1
a546 1
ExaOffscreenFini (ScreenPtr pScreen);
d550 1
a550 1
ExaDoPrepareAccess(PixmapPtr pPixmap, int index);
d553 1
a553 1
exaPrepareAccess(DrawablePtr pDrawable, int index);
d556 1
a556 1
exaFinishAccess(DrawablePtr pDrawable, int index);
d559 1
a559 1
exaDestroyPixmap(PixmapPtr pPixmap);
d562 1
a562 1
exaPixmapDirty(PixmapPtr pPix, int x1, int y1, int x2, int y2);
d565 3
a567 2
exaGetDrawableDeltas (DrawablePtr pDrawable, PixmapPtr pPixmap,
		      int *xp, int *yp);
d570 1
a570 1
exaPixmapHasGpuCopy(PixmapPtr p);
d573 1
a573 1
exaGetOffscreenPixmap (DrawablePtr pDrawable, int *xp, int *yp);
d576 1
a576 1
exaGetDrawablePixmap(DrawablePtr pDrawable);
d579 1
d584 1
d589 1
a589 1
exaDoMigration (ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel);
d592 1
a592 1
exaPixmapIsPinned (PixmapPtr pPix);
d598 1
d600 1
a600 1
		unsigned usage_hint);
d603 4
a606 2
exaModifyPixmapHeader_classic(PixmapPtr pPixmap, int width, int height, int depth,
		      int bitsPerPixel, int devKind, pointer pPixData);
d609 1
a609 1
exaDestroyPixmap_classic (PixmapPtr pPixmap);
d612 1
a612 1
exaPixmapHasGpuCopy_classic(PixmapPtr pPixmap);
d616 1
d618 1
a618 1
		unsigned usage_hint);
d621 4
a624 2
exaModifyPixmapHeader_driver(PixmapPtr pPixmap, int width, int height, int depth,
		      int bitsPerPixel, int devKind, pointer pPixData);
d627 1
a627 1
exaDestroyPixmap_driver (PixmapPtr pPixmap);
d630 1
a630 1
exaPixmapHasGpuCopy_driver(PixmapPtr pPixmap);
d634 1
d636 1
a636 1
		unsigned usage_hint);
d639 1
d641 1
a641 1
		      int bitsPerPixel, int devKind, pointer pPixData);
d644 1
a644 1
exaDestroyPixmap_mixed(PixmapPtr pPixmap);
d647 1
a647 1
exaPixmapHasGpuCopy_mixed(PixmapPtr pPixmap);
d651 1
a651 1
exaCreateDriverPixmap_mixed(PixmapPtr pPixmap);
d654 1
a654 1
exaDoMigration_mixed(ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel);
d657 1
a657 1
exaMoveInPixmap_mixed(PixmapPtr pPixmap);
d660 1
a660 1
exaDamageReport_mixed(DamagePtr pDamage, RegionPtr pRegion, void *closure);
d663 1
a663 1
exaPrepareAccessReg_mixed(PixmapPtr pPixmap, int index, RegionPtr pReg);
d667 1
a667 1
exaOpReadsDestination (CARD8 op);
d670 28
a697 30
exaComposite(CARD8	op,
	     PicturePtr pSrc,
	     PicturePtr pMask,
	     PicturePtr pDst,
	     INT16	xSrc,
	     INT16	ySrc,
	     INT16	xMask,
	     INT16	yMask,
	     INT16	xDst,
	     INT16	yDst,
	     CARD16	width,
	     CARD16	height);

void
exaCompositeRects(CARD8	              op,
		  PicturePtr	      Src,
		  PicturePtr	      pMask,
		  PicturePtr	      pDst,
		  int                 nrect,
		  ExaCompositeRectPtr rects);

void
exaTrapezoids (CARD8 op, PicturePtr pSrc, PicturePtr pDst,
               PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
               int ntrap, xTrapezoid *traps);

void
exaTriangles (CARD8 op, PicturePtr pSrc, PicturePtr pDst,
	      PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
	      int ntri, xTriangle *tris);
d701 1
a701 1
exaGlyphsInit(ScreenPtr pScreen);
d704 1
a704 1
exaGlyphsFini (ScreenPtr pScreen);
d707 7
a713 9
exaGlyphs (CARD8	op,
	  PicturePtr	pSrc,
	  PicturePtr	pDst,
	  PictFormatPtr	maskFormat,
	  INT16		xSrc,
	  INT16		ySrc,
	  int		nlist,
	  GlyphListPtr	list,
	  GlyphPtr	*glyphs);
d717 1
a717 1
exaCopyDirtyToSys (ExaMigrationPtr migrate);
d720 1
a720 1
exaCopyDirtyToFb (ExaMigrationPtr migrate);
d723 1
a723 1
exaDoMigration_classic (ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel);
d726 1
a726 1
exaPixmapSave (ScreenPtr pScreen, ExaOffscreenArea *area);
d729 1
a729 1
exaMoveOutPixmap_classic (PixmapPtr pPixmap);
d732 1
a732 1
exaMoveInPixmap_classic (PixmapPtr pPixmap);
d735 1
a735 1
exaPrepareAccessReg_classic(PixmapPtr pPixmap, int index, RegionPtr pReg);
d737 1
a737 1
#endif /* EXAPRIV_H */
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d231 1
a231 1
#define ExaGetScreenPriv(s) ((ExaScreenPrivPtr)dixLookupPrivate(&(s)->devPrivates, exaScreenPrivateKey))
d234 1
a234 1
#define ExaGetGCPriv(gc) ((ExaGCPrivPtr)dixLookupPrivate(&(gc)->devPrivates, exaGCPrivateKey))
d285 1
a285 2
#define ExaGetPixmapPriv(p) ((ExaPixmapPrivPtr)dixLookupPrivate(&(p)->devPrivates, exaPixmapPrivateKey))
#define ExaSetPixmapPriv(p,a) dixSetPrivate(&(p)->devPrivates, exaPixmapPrivateKey, a)
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a52 1
#ifdef RENDER
a54 1
#endif
a166 1
#ifdef RENDER
a171 1
#endif
d224 7
a230 3
extern DevPrivateKey exaScreenPrivateKey;
extern DevPrivateKey exaPixmapPrivateKey;
extern DevPrivateKey exaGCPrivateKey;
a501 1
#ifdef RENDER
d515 11
a525 1
#endif
d552 3
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a35 1
#define NEED_EVENTS
d88 12
d142 10
d155 2
d168 1
d176 6
a181 1
  
d188 15
d205 9
d230 1
d234 38
d296 1
a296 1
    Bool	    offscreen;
a331 7
 
typedef struct _ExaMigrationRec {
    Bool as_dst;
    Bool as_src;
    PixmapPtr pPix;
    RegionPtr pReg;
} ExaMigrationRec, *ExaMigrationPtr;
d334 7
d343 2
d377 5
d427 7
d472 28
d525 3
d535 2
a536 5
void
ExaDoPrepareAccess(DrawablePtr pDrawable, int index);

void
exaPrepareAccessReg(DrawablePtr pDrawable, int index, RegionPtr pReg);
d552 1
a552 1
exaPixmapIsOffscreen(PixmapPtr p);
d560 73
a632 3
RegionPtr
exaCopyArea(DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable, GCPtr pGC,
	    int srcx, int srcy, int width, int height, int dstx, int dsty);
d635 1
a635 11
exaCopyNtoN (DrawablePtr    pSrcDrawable,
	     DrawablePtr    pDstDrawable,
	     GCPtr	    pGC,
	     BoxPtr	    pbox,
	     int	    nbox,
	     int	    dx,
	     int	    dy,
	     Bool	    reverse,
	     Bool	    upsidedown,
	     Pixel	    bitplane,
	     void	    *closure);
d658 1
d691 4
a694 1
/* exa_migration.c */
d696 4
a699 1
exaDoMigration (ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel);
d703 9
@


1.3
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d64 1
d99 32
d159 2
d248 9
a262 6
void
exaPrepareAccessWindow(WindowPtr pWin);

void
exaFinishAccessWindow(WindowPtr pWin);

d346 2
a347 1
		      unsigned int fillStyle, unsigned char alu)
d349 1
a349 1
    return ((alu != GXcopy && alu != GXclear &&alu != GXset &&
d351 1
a351 1
	    !EXA_PM_IS_SOLID(pDrawable, planemask));
d359 2
a360 1
		    DDXPointPtr pPatOrg, CARD32 planemask, CARD32 alu);
d462 7
d477 7
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a377 3
exaDrawableIsOffscreen (DrawablePtr pDrawable);

Bool
@


1.1
log
@Initial revision
@
text
@d38 3
d56 1
d58 1
a104 1
    PaintWindowBackgroundProcPtr SavedPaintWindowBackground;
a106 1
    PaintWindowBorderProcPtr 	 SavedPaintWindowBorder;
d108 4
d114 1
a114 2
    RasterizeTrapezoidProcPtr	 SavedRasterizeTrapezoid;
    AddTrianglesProcPtr		 SavedAddTriangles;
d116 2
d119 1
a121 1
    Bool			 hideOffscreenPixmapData;
d123 3
d140 3
a142 3
extern int exaScreenPrivateIndex;
extern int exaPixmapPrivateIndex;
#define ExaGetScreenPriv(s)	((ExaScreenPrivPtr)(s)->devPrivates[exaScreenPrivateIndex].ptr)
d158 2
a159 2
#define ExaGetPixmapPriv(p)	((ExaPixmapPrivPtr)(p)->devPrivates[exaPixmapPrivateIndex].ptr)
#define ExaSetPixmapPriv(p,a)	((p)->devPrivates[exaPixmapPrivateIndex].ptr = (pointer) (a))
d162 4
d169 1
d179 2
a180 3
     * If area is NULL, then dirty == TRUE means that the pixmap has been
     * modified, so the contents are defined.  Used to avoid uploads of
     * undefined data.
d182 20
a201 4
     * If area is non-NULL, then dirty == TRUE means that the pixmap data at
     * pPixmap->devPrivate.ptr (either fb_ptr or sys_ptr) has been changed
     * compared to the copy in the other location.  This is used to avoid
     * uploads/downloads of unmodified data.
d203 1
a203 1
    Bool	    dirty;
d210 1
d219 6
a289 6
ExaCheckGetImage (DrawablePtr pDrawable,
		 int x, int y, int w, int h,
		 unsigned int format, unsigned long planeMask,
		 char *d);

void
d298 5
a302 5
ExaCheckSaveAreas (PixmapPtr	pPixmap,
		  RegionPtr	prgnSave,
		  int		xorg,
		  int		yorg,
		  WindowPtr	pWin);
d304 1
a304 9
void
ExaCheckRestoreAreas (PixmapPtr	pPixmap,
		     RegionPtr	prgnSave,
		     int	xorg,
		     int    	yorg,
		     WindowPtr	pWin);

void
ExaCheckPaintWindow (WindowPtr pWin, RegionPtr pRegion, int what);
d306 8
a313 2
CARD32
exaGetPixmapFirstPixel (PixmapPtr pPixmap); 
a314 1
/* exa_accel.c */
d318 3
a320 2
void
exaPaintWindow(WindowPtr pWin, RegionPtr pRegion, int what);
a325 4
void
exaGetSpans (DrawablePtr pDrawable, int wMax, DDXPointPtr ppt, int *pwidth,
	     int nspans, char *pdstStart);

d344 1
a344 4
/* exaoffscreen.c */
void
ExaOffscreenMarkUsed (PixmapPtr pPixmap);

d359 6
d371 5
a375 1
exaDrawableDirty(DrawablePtr pDrawable);
d407 3
d425 3
a427 2
exaRasterizeTrapezoid (PicturePtr pPicture, xTrapezoid  *trap,
		       int x_off, int y_off);
d430 3
a432 2
exaAddTriangles (PicturePtr pPicture, INT16 x_off, INT16 y_off, int ntri,
		 xTriangle *tris);
d450 1
a450 4
exaMoveInPixmap (PixmapPtr pPixmap);

void
exaMoveOutPixmap (PixmapPtr pPixmap);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a53 1
#include "damage.h"
a109 1
    TrapezoidsProcPtr            SavedTrapezoids;
a114 1
    unsigned			 disableFbCount;
d163 8
a170 3
     * The damage record contains the areas of the pixmap's current location
     * (framebuffer or system) that have been damaged compared to the other
     * location.
d172 1
a172 6
    DamagePtr	    pDamage;
    /**
     * The valid region marks the valid bits of a drawable (at least, as it's
     * derived from damage, which may be overreported).
     */
    RegionRec	    validReg;
a288 4
Bool
exaFillRegionTiled (DrawablePtr	pDrawable, RegionPtr pRegion, PixmapPtr pTile,
		    DDXPointPtr pPatOrg, CARD32 planemask, CARD32 alu);

d318 4
a321 1
/* exa_offscreen.c */
d342 1
a342 5
exaPixmapDirty(PixmapPtr pPix, int x1, int y1, int x2, int y2);

void
exaGetDrawableDeltas (DrawablePtr pDrawable, PixmapPtr pPixmap,
		      int *xp, int *yp);
a388 5
exaTrapezoids (CARD8 op, PicturePtr pSrc, PicturePtr pDst,
               PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
               int ntrap, xTrapezoid *traps);

void
d412 4
a415 1
exaPixmapSave (ScreenPtr pScreen, ExaOffscreenArea *area);
@

