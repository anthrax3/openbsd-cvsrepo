head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.4
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.2
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.08.09.18.59.51;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	6HLO5qdN5N4nPDjW;

1.8
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	s0SI41sEunLdyFfd;

1.7
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/*
 * Copyright © 2008 Red Hat, Inc.
 * Partly based on code Copyright © 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Red Hat not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  Red Hat makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * Red Hat DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL Red Hat
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author: Owen Taylor <otaylor@@fishsoup.net>
 * Based on code by: Keith Packard
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include "exa_priv.h"

#include "mipict.h"

#if DEBUG_GLYPH_CACHE
#define DBG_GLYPH_CACHE(a) ErrorF a
#else
#define DBG_GLYPH_CACHE(a)
#endif

/* Width of the pixmaps we use for the caches; this should be less than
 * max texture size of the driver; this may need to actually come from
 * the driver.
 */
#define CACHE_PICTURE_WIDTH 1024

/* Maximum number of glyphs we buffer on the stack before flushing
 * rendering to the mask or destination surface.
 */
#define GLYPH_BUFFER_SIZE 256

typedef struct {
    PicturePtr mask;
    ExaCompositeRectRec rects[GLYPH_BUFFER_SIZE];
    int count;
} ExaGlyphBuffer, *ExaGlyphBufferPtr;

typedef enum {
    ExaGlyphSuccess,            /* Glyph added to render buffer */
    ExaGlyphFail,               /* out of memory, etc */
    ExaGlyphNeedFlush,          /* would evict a glyph already in the buffer */
} ExaGlyphCacheResult;

void
exaGlyphsInit(ScreenPtr pScreen)
{
    ExaScreenPriv(pScreen);
    int i = 0;

    memset(pExaScr->glyphCaches, 0, sizeof(pExaScr->glyphCaches));

    pExaScr->glyphCaches[i].format = PICT_a8;
    pExaScr->glyphCaches[i].glyphWidth = pExaScr->glyphCaches[i].glyphHeight =
        16;
    i++;
    pExaScr->glyphCaches[i].format = PICT_a8;
    pExaScr->glyphCaches[i].glyphWidth = pExaScr->glyphCaches[i].glyphHeight =
        32;
    i++;
    pExaScr->glyphCaches[i].format = PICT_a8r8g8b8;
    pExaScr->glyphCaches[i].glyphWidth = pExaScr->glyphCaches[i].glyphHeight =
        16;
    i++;
    pExaScr->glyphCaches[i].format = PICT_a8r8g8b8;
    pExaScr->glyphCaches[i].glyphWidth = pExaScr->glyphCaches[i].glyphHeight =
        32;
    i++;

    assert(i == EXA_NUM_GLYPH_CACHES);

    for (i = 0; i < EXA_NUM_GLYPH_CACHES; i++) {
        pExaScr->glyphCaches[i].columns =
            CACHE_PICTURE_WIDTH / pExaScr->glyphCaches[i].glyphWidth;
        pExaScr->glyphCaches[i].size = 256;
        pExaScr->glyphCaches[i].hashSize = 557;
    }
}

static void
exaUnrealizeGlyphCaches(ScreenPtr pScreen, unsigned int format)
{
    ExaScreenPriv(pScreen);
    int i;

    for (i = 0; i < EXA_NUM_GLYPH_CACHES; i++) {
        ExaGlyphCachePtr cache = &pExaScr->glyphCaches[i];

        if (cache->format != format)
            continue;

        if (cache->picture) {
            FreePicture((void *) cache->picture, (XID) 0);
            cache->picture = NULL;
        }

        free(cache->hashEntries);
        cache->hashEntries = NULL;

        free(cache->glyphs);
        cache->glyphs = NULL;
        cache->glyphCount = 0;
    }
}

#define NeedsComponent(f) (PICT_FORMAT_A(f) != 0 && PICT_FORMAT_RGB(f) != 0)

/* All caches for a single format share a single pixmap for glyph storage,
 * allowing mixing glyphs of different sizes without paying a penalty
 * for switching between mask pixmaps. (Note that for a size of font
 * right at the border between two sizes, we might be switching for almost
 * every glyph.)
 *
 * This function allocates the storage pixmap, and then fills in the
 * rest of the allocated structures for all caches with the given format.
 */
static Bool
exaRealizeGlyphCaches(ScreenPtr pScreen, unsigned int format)
{
    ExaScreenPriv(pScreen);

    int depth = PIXMAN_FORMAT_DEPTH(format);
    PictFormatPtr pPictFormat;
    PixmapPtr pPixmap;
    PicturePtr pPicture;
    CARD32 component_alpha;
    int height;
    int i;
    int error;

    pPictFormat = PictureMatchFormat(pScreen, depth, format);
    if (!pPictFormat)
        return FALSE;

    /* Compute the total vertical size needed for the format */

    height = 0;
    for (i = 0; i < EXA_NUM_GLYPH_CACHES; i++) {
        ExaGlyphCachePtr cache = &pExaScr->glyphCaches[i];
        int rows;

        if (cache->format != format)
            continue;

        cache->yOffset = height;

        rows = (cache->size + cache->columns - 1) / cache->columns;
        height += rows * cache->glyphHeight;
    }

    /* Now allocate the pixmap and picture */
    pPixmap = (*pScreen->CreatePixmap) (pScreen,
                                        CACHE_PICTURE_WIDTH, height, depth, 0);
    if (!pPixmap)
        return FALSE;

    component_alpha = NeedsComponent(pPictFormat->format);
    pPicture = CreatePicture(0, &pPixmap->drawable, pPictFormat,
                             CPComponentAlpha, &component_alpha, serverClient,
                             &error);

    (*pScreen->DestroyPixmap) (pPixmap);        /* picture holds a refcount */

    if (!pPicture)
        return FALSE;

    /* And store the picture in all the caches for the format */
    for (i = 0; i < EXA_NUM_GLYPH_CACHES; i++) {
        ExaGlyphCachePtr cache = &pExaScr->glyphCaches[i];
        int j;

        if (cache->format != format)
            continue;

        cache->picture = pPicture;
        cache->picture->refcnt++;
        cache->hashEntries = xallocarray(cache->hashSize, sizeof(int));
        cache->glyphs = xallocarray(cache->size, sizeof(ExaCachedGlyphRec));
        cache->glyphCount = 0;

        if (!cache->hashEntries || !cache->glyphs)
            goto bail;

        for (j = 0; j < cache->hashSize; j++)
            cache->hashEntries[j] = -1;

        cache->evictionPosition = rand() % cache->size;
    }

    /* Each cache references the picture individually */
    FreePicture((void *) pPicture, (XID) 0);
    return TRUE;

 bail:
    exaUnrealizeGlyphCaches(pScreen, format);
    return FALSE;
}

void
exaGlyphsFini(ScreenPtr pScreen)
{
    ExaScreenPriv(pScreen);
    int i;

    for (i = 0; i < EXA_NUM_GLYPH_CACHES; i++) {
        ExaGlyphCachePtr cache = &pExaScr->glyphCaches[i];

        if (cache->picture)
            exaUnrealizeGlyphCaches(pScreen, cache->format);
    }
}

static int
exaGlyphCacheHashLookup(ExaGlyphCachePtr cache, GlyphPtr pGlyph)
{
    int slot;

    slot = (*(CARD32 *) pGlyph->sha1) % cache->hashSize;

    while (TRUE) {              /* hash table can never be full */
        int entryPos = cache->hashEntries[slot];

        if (entryPos == -1)
            return -1;

        if (memcmp
            (pGlyph->sha1, cache->glyphs[entryPos].sha1,
             sizeof(pGlyph->sha1)) == 0) {
            return entryPos;
        }

        slot--;
        if (slot < 0)
            slot = cache->hashSize - 1;
    }
}

static void
exaGlyphCacheHashInsert(ExaGlyphCachePtr cache, GlyphPtr pGlyph, int pos)
{
    int slot;

    memcpy(cache->glyphs[pos].sha1, pGlyph->sha1, sizeof(pGlyph->sha1));

    slot = (*(CARD32 *) pGlyph->sha1) % cache->hashSize;

    while (TRUE) {              /* hash table can never be full */
        if (cache->hashEntries[slot] == -1) {
            cache->hashEntries[slot] = pos;
            return;
        }

        slot--;
        if (slot < 0)
            slot = cache->hashSize - 1;
    }
}

static void
exaGlyphCacheHashRemove(ExaGlyphCachePtr cache, int pos)
{
    int slot;
    int emptiedSlot = -1;

    slot = (*(CARD32 *) cache->glyphs[pos].sha1) % cache->hashSize;

    while (TRUE) {              /* hash table can never be full */
        int entryPos = cache->hashEntries[slot];

        if (entryPos == -1)
            return;

        if (entryPos == pos) {
            cache->hashEntries[slot] = -1;
            emptiedSlot = slot;
        }
        else if (emptiedSlot != -1) {
            /* See if we can move this entry into the emptied slot, we can't
             * do that if if entry would have hashed between the current position
             * and the emptied slot. (taking wrapping into account). Bad positions
             * are:
             *
             * |   XXXXXXXXXX             |
             *     i         j
             *
             * |XXX                   XXXX|
             *     j                  i
             *
             * i - slot, j - emptiedSlot
             *
             * (Knuth 6.4R)
             */

            int entrySlot =
                (*(CARD32 *) cache->glyphs[entryPos].sha1) % cache->hashSize;

            if (!((entrySlot >= slot && entrySlot < emptiedSlot) ||
                  (emptiedSlot < slot &&
                   (entrySlot < emptiedSlot || entrySlot >= slot)))) {
                cache->hashEntries[emptiedSlot] = entryPos;
                cache->hashEntries[slot] = -1;
                emptiedSlot = slot;
            }
        }

        slot--;
        if (slot < 0)
            slot = cache->hashSize - 1;
    }
}

#define CACHE_X(pos) (((pos) % cache->columns) * cache->glyphWidth)
#define CACHE_Y(pos) (cache->yOffset + ((pos) / cache->columns) * cache->glyphHeight)

/* The most efficient thing to way to upload the glyph to the screen
 * is to use the UploadToScreen() driver hook; this allows us to
 * pipeline glyph uploads and to avoid creating gpu backed pixmaps for
 * glyphs that we'll never use again.
 *
 * If we can't do it with UploadToScreen (because the glyph has a gpu copy,
 * etc), we fall back to CompositePicture.
 *
 * We need to damage the cache pixmap manually in either case because the damage
 * layer unwrapped the picture screen before calling exaGlyphs.
 */
static void
exaGlyphCacheUploadGlyph(ScreenPtr pScreen,
                         ExaGlyphCachePtr cache, int x, int y, GlyphPtr pGlyph)
{
    ExaScreenPriv(pScreen);
    PicturePtr pGlyphPicture = GetGlyphPicture(pGlyph, pScreen);
    PixmapPtr pGlyphPixmap = (PixmapPtr) pGlyphPicture->pDrawable;

    ExaPixmapPriv(pGlyphPixmap);
    PixmapPtr pCachePixmap = (PixmapPtr) cache->picture->pDrawable;

    if (!pExaScr->info->UploadToScreen || pExaScr->swappedOut ||
        pExaPixmap->accel_blocked)
        goto composite;

    /* If the glyph pixmap is already uploaded, no point in doing
     * things this way */
    if (exaPixmapHasGpuCopy(pGlyphPixmap))
        goto composite;

    /* UploadToScreen only works if bpp match */
    if (pGlyphPixmap->drawable.bitsPerPixel !=
        pCachePixmap->drawable.bitsPerPixel)
        goto composite;

    if (pExaScr->do_migration) {
        ExaMigrationRec pixmaps[1];

        /* cache pixmap must have a gpu copy. */
        pixmaps[0].as_dst = TRUE;
        pixmaps[0].as_src = FALSE;
        pixmaps[0].pPix = pCachePixmap;
        pixmaps[0].pReg = NULL;
        exaDoMigration(pixmaps, 1, TRUE);
    }

    if (!exaPixmapHasGpuCopy(pCachePixmap))
        goto composite;

    /* x,y are in pixmap coordinates, no need for cache{X,Y}off */
    if (pExaScr->info->UploadToScreen(pCachePixmap,
                                      x,
                                      y,
                                      pGlyph->info.width,
                                      pGlyph->info.height,
                                      (char *) pExaPixmap->sys_ptr,
                                      pExaPixmap->sys_pitch))
        goto damage;

 composite:
    CompositePicture(PictOpSrc,
                     pGlyphPicture,
                     None,
                     cache->picture,
                     0, 0, 0, 0, x, y, pGlyph->info.width, pGlyph->info.height);

 damage:
    /* The cache pixmap isn't a window, so no need to offset coordinates. */
    exaPixmapDirty(pCachePixmap,
                   x, y, x + cache->glyphWidth, y + cache->glyphHeight);
}

static ExaGlyphCacheResult
exaGlyphCacheBufferGlyph(ScreenPtr pScreen,
                         ExaGlyphCachePtr cache,
                         ExaGlyphBufferPtr buffer,
                         GlyphPtr pGlyph,
                         PicturePtr pSrc,
                         PicturePtr pDst,
                         INT16 xSrc,
                         INT16 ySrc,
                         INT16 xMask, INT16 yMask, INT16 xDst, INT16 yDst)
{
    ExaCompositeRectPtr rect;
    int pos;
    int x, y;

    if (buffer->mask && buffer->mask != cache->picture)
        return ExaGlyphNeedFlush;

    if (!cache->picture) {
        if (!exaRealizeGlyphCaches(pScreen, cache->format))
            return ExaGlyphFail;
    }

    DBG_GLYPH_CACHE(("(%d,%d,%s): buffering glyph %lx\n",
                     cache->glyphWidth, cache->glyphHeight,
                     cache->format == PICT_a8 ? "A" : "ARGB",
                     (long) *(CARD32 *) pGlyph->sha1));

    pos = exaGlyphCacheHashLookup(cache, pGlyph);
    if (pos != -1) {
        DBG_GLYPH_CACHE(("  found existing glyph at %d\n", pos));
        x = CACHE_X(pos);
        y = CACHE_Y(pos);
    }
    else {
        if (cache->glyphCount < cache->size) {
            /* Space remaining; we fill from the start */
            pos = cache->glyphCount;
            x = CACHE_X(pos);
            y = CACHE_Y(pos);
            cache->glyphCount++;
            DBG_GLYPH_CACHE(("  storing glyph in free space at %d\n", pos));

            exaGlyphCacheHashInsert(cache, pGlyph, pos);

        }
        else {
            /* Need to evict an entry. We have to see if any glyphs
             * already in the output buffer were at this position in
             * the cache
             */
            pos = cache->evictionPosition;
            x = CACHE_X(pos);
            y = CACHE_Y(pos);
            DBG_GLYPH_CACHE(("  evicting glyph at %d\n", pos));
            if (buffer->count) {
                int i;

                for (i = 0; i < buffer->count; i++) {
                    if (pSrc ?
                        (buffer->rects[i].xMask == x &&
                         buffer->rects[i].yMask ==
                         y) : (buffer->rects[i].xSrc == x &&
                               buffer->rects[i].ySrc == y)) {
                        DBG_GLYPH_CACHE(("  must flush buffer\n"));
                        return ExaGlyphNeedFlush;
                    }
                }
            }

            /* OK, we're all set, swap in the new glyph */
            exaGlyphCacheHashRemove(cache, pos);
            exaGlyphCacheHashInsert(cache, pGlyph, pos);

            /* And pick a new eviction position */
            cache->evictionPosition = rand() % cache->size;
        }

        exaGlyphCacheUploadGlyph(pScreen, cache, x, y, pGlyph);
    }

    buffer->mask = cache->picture;

    rect = &buffer->rects[buffer->count];

    if (pSrc) {
        rect->xSrc = xSrc;
        rect->ySrc = ySrc;
        rect->xMask = x;
        rect->yMask = y;
    }
    else {
        rect->xSrc = x;
        rect->ySrc = y;
        rect->xMask = 0;
        rect->yMask = 0;
    }

    rect->pDst = pDst;
    rect->xDst = xDst;
    rect->yDst = yDst;
    rect->width = pGlyph->info.width;
    rect->height = pGlyph->info.height;

    buffer->count++;

    return ExaGlyphSuccess;
}

#undef CACHE_X
#undef CACHE_Y

static ExaGlyphCacheResult
exaBufferGlyph(ScreenPtr pScreen,
               ExaGlyphBufferPtr buffer,
               GlyphPtr pGlyph,
               PicturePtr pSrc,
               PicturePtr pDst,
               INT16 xSrc,
               INT16 ySrc, INT16 xMask, INT16 yMask, INT16 xDst, INT16 yDst)
{
    ExaScreenPriv(pScreen);
    unsigned int format = (GetGlyphPicture(pGlyph, pScreen))->format;
    int width = pGlyph->info.width;
    int height = pGlyph->info.height;
    ExaCompositeRectPtr rect;
    PicturePtr mask;
    int i;

    if (buffer->count == GLYPH_BUFFER_SIZE)
        return ExaGlyphNeedFlush;

    if (PICT_FORMAT_BPP(format) == 1)
        format = PICT_a8;

    for (i = 0; i < EXA_NUM_GLYPH_CACHES; i++) {
        ExaGlyphCachePtr cache = &pExaScr->glyphCaches[i];

        if (format == cache->format &&
            width <= cache->glyphWidth && height <= cache->glyphHeight) {
            ExaGlyphCacheResult result = exaGlyphCacheBufferGlyph(pScreen,
                                                                  &pExaScr->
                                                                  glyphCaches
                                                                  [i],
                                                                  buffer,
                                                                  pGlyph,
                                                                  pSrc,
                                                                  pDst,
                                                                  xSrc, ySrc,
                                                                  xMask, yMask,
                                                                  xDst, yDst);

            switch (result) {
            case ExaGlyphFail:
                break;
            case ExaGlyphSuccess:
            case ExaGlyphNeedFlush:
                return result;
            }
        }
    }

    /* Couldn't find the glyph in the cache, use the glyph picture directly */

    mask = GetGlyphPicture(pGlyph, pScreen);
    if (buffer->mask && buffer->mask != mask)
        return ExaGlyphNeedFlush;

    buffer->mask = mask;

    rect = &buffer->rects[buffer->count];
    rect->xSrc = xSrc;
    rect->ySrc = ySrc;
    rect->xMask = xMask;
    rect->yMask = yMask;
    rect->xDst = xDst;
    rect->yDst = yDst;
    rect->width = width;
    rect->height = height;

    buffer->count++;

    return ExaGlyphSuccess;
}

static void
exaGlyphsToMask(PicturePtr pMask, ExaGlyphBufferPtr buffer)
{
    exaCompositeRects(PictOpAdd, buffer->mask, NULL, pMask,
                      buffer->count, buffer->rects);

    buffer->count = 0;
    buffer->mask = NULL;
}

static void
exaGlyphsToDst(CARD8 op, PicturePtr pSrc, PicturePtr pDst, ExaGlyphBufferPtr buffer)
{
    exaCompositeRects(op, pSrc, buffer->mask, pDst, buffer->count,
                      buffer->rects);

    buffer->count = 0;
    buffer->mask = NULL;
}

/* Cut and paste from render/glyph.c - probably should export it instead */
static void
GlyphExtents(int nlist, GlyphListPtr list, GlyphPtr * glyphs, BoxPtr extents)
{
    int x1, x2, y1, y2;
    int n;
    GlyphPtr glyph;
    int x, y;

    x = 0;
    y = 0;
    extents->x1 = MAXSHORT;
    extents->x2 = MINSHORT;
    extents->y1 = MAXSHORT;
    extents->y2 = MINSHORT;
    while (nlist--) {
        x += list->xOff;
        y += list->yOff;
        n = list->len;
        list++;
        while (n--) {
            glyph = *glyphs++;
            x1 = x - glyph->info.x;
            if (x1 < MINSHORT)
                x1 = MINSHORT;
            y1 = y - glyph->info.y;
            if (y1 < MINSHORT)
                y1 = MINSHORT;
            x2 = x1 + glyph->info.width;
            if (x2 > MAXSHORT)
                x2 = MAXSHORT;
            y2 = y1 + glyph->info.height;
            if (y2 > MAXSHORT)
                y2 = MAXSHORT;
            if (x1 < extents->x1)
                extents->x1 = x1;
            if (x2 > extents->x2)
                extents->x2 = x2;
            if (y1 < extents->y1)
                extents->y1 = y1;
            if (y2 > extents->y2)
                extents->y2 = y2;
            x += glyph->info.xOff;
            y += glyph->info.yOff;
        }
    }
}

void
exaGlyphs(CARD8 op,
          PicturePtr pSrc,
          PicturePtr pDst,
          PictFormatPtr maskFormat,
          INT16 xSrc,
          INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs)
{
    PixmapPtr pMaskPixmap = 0;
    PicturePtr pMask = NULL;
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    int width = 0, height = 0;
    int x, y;
    int first_xOff = list->xOff, first_yOff = list->yOff;
    int n;
    GlyphPtr glyph;
    int error;
    BoxRec extents = { 0, 0, 0, 0 };
    CARD32 component_alpha;
    ExaGlyphBuffer buffer;

    if (maskFormat) {
        ExaScreenPriv(pScreen);
        GCPtr pGC;
        xRectangle rect;

        GlyphExtents(nlist, list, glyphs, &extents);

        if (extents.x2 <= extents.x1 || extents.y2 <= extents.y1)
            return;
        width = extents.x2 - extents.x1;
        height = extents.y2 - extents.y1;

        if (maskFormat->depth == 1) {
            PictFormatPtr a8Format = PictureMatchFormat(pScreen, 8, PICT_a8);

            if (a8Format)
                maskFormat = a8Format;
        }

        pMaskPixmap = (*pScreen->CreatePixmap) (pScreen, width, height,
                                                maskFormat->depth,
                                                CREATE_PIXMAP_USAGE_SCRATCH);
        if (!pMaskPixmap)
            return;
        component_alpha = NeedsComponent(maskFormat->format);
        pMask = CreatePicture(0, &pMaskPixmap->drawable,
                              maskFormat, CPComponentAlpha, &component_alpha,
                              serverClient, &error);
        if (!pMask ||
            (!component_alpha && pExaScr->info->CheckComposite &&
             !(*pExaScr->info->CheckComposite) (PictOpAdd, pSrc, NULL, pMask)))
        {
            PictFormatPtr argbFormat;

            (*pScreen->DestroyPixmap) (pMaskPixmap);

            if (!pMask)
                return;

            /* The driver can't seem to composite to a8, let's try argb (but
             * without component-alpha) */
            FreePicture((void *) pMask, (XID) 0);

            argbFormat = PictureMatchFormat(pScreen, 32, PICT_a8r8g8b8);

            if (argbFormat)
                maskFormat = argbFormat;

            pMaskPixmap = (*pScreen->CreatePixmap) (pScreen, width, height,
                                                    maskFormat->depth,
                                                    CREATE_PIXMAP_USAGE_SCRATCH);
            if (!pMaskPixmap)
                return;

            pMask = CreatePicture(0, &pMaskPixmap->drawable, maskFormat, 0, 0,
                                  serverClient, &error);
            if (!pMask) {
                (*pScreen->DestroyPixmap) (pMaskPixmap);
                return;
            }
        }
        pGC = GetScratchGC(pMaskPixmap->drawable.depth, pScreen);
        ValidateGC(&pMaskPixmap->drawable, pGC);
        rect.x = 0;
        rect.y = 0;
        rect.width = width;
        rect.height = height;
        (*pGC->ops->PolyFillRect) (&pMaskPixmap->drawable, pGC, 1, &rect);
        FreeScratchGC(pGC);
        x = -extents.x1;
        y = -extents.y1;
    }
    else {
        x = 0;
        y = 0;
    }
    buffer.count = 0;
    buffer.mask = NULL;
    while (nlist--) {
        x += list->xOff;
        y += list->yOff;
        n = list->len;
        while (n--) {
            glyph = *glyphs++;

            if (glyph->info.width > 0 && glyph->info.height > 0) {
                /* pGlyph->info.{x,y} compensate for empty space in the glyph. */
                if (maskFormat) {
                    if (exaBufferGlyph(pScreen, &buffer, glyph, NULL, pMask,
                                       0, 0, 0, 0, x - glyph->info.x,
                                       y - glyph->info.y) ==
                        ExaGlyphNeedFlush) {
                        exaGlyphsToMask(pMask, &buffer);
                        exaBufferGlyph(pScreen, &buffer, glyph, NULL, pMask,
                                       0, 0, 0, 0, x - glyph->info.x,
                                       y - glyph->info.y);
                    }
                }
                else {
                    if (exaBufferGlyph(pScreen, &buffer, glyph, pSrc, pDst,
                                       xSrc + (x - glyph->info.x) - first_xOff,
                                       ySrc + (y - glyph->info.y) - first_yOff,
                                       0, 0, x - glyph->info.x,
                                       y - glyph->info.y)
                        == ExaGlyphNeedFlush) {
                        exaGlyphsToDst(op, pSrc, pDst, &buffer);
                        exaBufferGlyph(pScreen, &buffer, glyph, pSrc, pDst,
                                       xSrc + (x - glyph->info.x) - first_xOff,
                                       ySrc + (y - glyph->info.y) - first_yOff,
                                       0, 0, x - glyph->info.x,
                                       y - glyph->info.y);
                    }
                }
            }

            x += glyph->info.xOff;
            y += glyph->info.yOff;
        }
        list++;
    }

    if (buffer.count) {
        if (maskFormat)
            exaGlyphsToMask(pMask, &buffer);
        else
            exaGlyphsToDst(op, pSrc, pDst, &buffer);
    }

    if (maskFormat) {
        x = extents.x1;
        y = extents.y1;
        CompositePicture(op,
                         pSrc,
                         pMask,
                         pDst,
                         xSrc + x - first_xOff,
                         ySrc + y - first_yOff, 0, 0, x, y, width, height);
        FreePicture((void *) pMask, (XID) 0);
        (*pScreen->DestroyPixmap) (pMaskPixmap);
    }
}
@


1.8
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@d621 1
a621 1
exaGlyphsToDst(PicturePtr pSrc, PicturePtr pDst, ExaGlyphBufferPtr buffer)
d623 1
a623 1
    exaCompositeRects(PictOpOver, pSrc, buffer->mask, pDst, buffer->count,
d804 1
a804 1
                        exaGlyphsToDst(pSrc, pDst, &buffer);
d824 1
a824 1
            exaGlyphsToDst(pSrc, pDst, &buffer);
@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d214 2
a215 2
        cache->hashEntries = malloc(sizeof(int) * cache->hashSize);
        cache->glyphs = malloc(sizeof(ExaCachedGlyphRec) * cache->size);
@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d19 1
a19 1
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
d36 1
a36 1
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
d321 2
a322 2
             *     i         j            
             *                            
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d130 1
a130 1
            FreePicture((pointer) cache->picture, (XID) 0);
d228 1
a228 1
    FreePicture((pointer) pPicture, (XID) 0);
d740 1
a740 1
            FreePicture((pointer) pMask, (XID) 0);
d836 1
a836 1
        FreePicture((pointer) pMask, (XID) 0);
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d368 1
a368 1
    PicturePtr pGlyphPicture = GlyphPicture(pGlyph)[pScreen->myNum];
d547 1
a547 1
    unsigned int format = (GlyphPicture(pGlyph)[pScreen->myNum])->format;
d589 1
a589 1
    mask = GlyphPicture(pGlyph)[pScreen->myNum];
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d77 3
a79 3
    ExaGlyphSuccess,    /* Glyph added to render buffer */
    ExaGlyphFail,       /* out of memory, etc */
    ExaGlyphNeedFlush,  /* would evict a glyph already in the buffer */
d91 2
a92 1
    pExaScr->glyphCaches[i].glyphWidth = pExaScr->glyphCaches[i].glyphHeight = 16;
d95 2
a96 1
    pExaScr->glyphCaches[i].glyphWidth = pExaScr->glyphCaches[i].glyphHeight = 32;
d99 2
a100 1
    pExaScr->glyphCaches[i].glyphWidth = pExaScr->glyphCaches[i].glyphHeight = 16;
d103 2
a104 1
    pExaScr->glyphCaches[i].glyphWidth = pExaScr->glyphCaches[i].glyphHeight = 32;
d108 1
a108 1
    
d110 4
a113 3
	pExaScr->glyphCaches[i].columns = CACHE_PICTURE_WIDTH / pExaScr->glyphCaches[i].glyphWidth;
	pExaScr->glyphCaches[i].size = 256;
	pExaScr->glyphCaches[i].hashSize = 557;
d118 1
a118 2
exaUnrealizeGlyphCaches(ScreenPtr    pScreen,
			unsigned int format)
d124 16
a139 16
	ExaGlyphCachePtr cache = &pExaScr->glyphCaches[i];
	
	if (cache->format != format)
	    continue;

	if (cache->picture) {
	    FreePicture ((pointer) cache->picture, (XID) 0);
	    cache->picture = NULL;
	}

	free(cache->hashEntries);
	cache->hashEntries = NULL;
	
	free(cache->glyphs);
	cache->glyphs = NULL;
	cache->glyphCount = 0;
d155 1
a155 2
exaRealizeGlyphCaches(ScreenPtr    pScreen,
		      unsigned int format)
d166 1
a166 1
    int	error;
d170 2
a171 2
	return FALSE;
    
d176 2
a177 2
	ExaGlyphCachePtr cache = &pExaScr->glyphCaches[i];
	int rows;
d179 2
a180 2
	if (cache->format != format)
	    continue;
d182 1
a182 1
	cache->yOffset = height;
d184 2
a185 2
	rows = (cache->size + cache->columns - 1) / cache->columns;
	height += rows * cache->glyphHeight;
d190 1
a190 2
					CACHE_PICTURE_WIDTH,
					height, depth, 0);
d192 1
a192 1
	return FALSE;
d196 2
a197 2
			     CPComponentAlpha, &component_alpha, serverClient,
			     &error);
d199 1
a199 1
    (*pScreen->DestroyPixmap) (pPixmap); /* picture holds a refcount */
d202 1
a202 1
	return FALSE;
d206 14
a219 2
	ExaGlyphCachePtr cache = &pExaScr->glyphCaches[i];
	int j;
d221 2
a222 2
	if (cache->format != format)
	    continue;
d224 1
a224 13
	cache->picture = pPicture;
	cache->picture->refcnt++;
	cache->hashEntries = malloc(sizeof(int) * cache->hashSize);
	cache->glyphs = malloc(sizeof(ExaCachedGlyphRec) * cache->size);
	cache->glyphCount = 0;

	if (!cache->hashEntries || !cache->glyphs)
	    goto bail;

	for (j = 0; j < cache->hashSize; j++)
	    cache->hashEntries[j] = -1;
	
	cache->evictionPosition = rand() % cache->size;
d228 1
a228 1
    FreePicture ((pointer) pPicture, (XID) 0);
d231 1
a231 1
bail:
d237 1
a237 1
exaGlyphsFini (ScreenPtr pScreen)
d243 1
a243 1
	ExaGlyphCachePtr cache = &pExaScr->glyphCaches[i];
d245 2
a246 2
	if (cache->picture)
	    exaUnrealizeGlyphCaches(pScreen, cache->format);
d251 1
a251 2
exaGlyphCacheHashLookup(ExaGlyphCachePtr cache,
			GlyphPtr         pGlyph)
d256 16
a271 13
    
    while (TRUE) { /* hash table can never be full */
	int entryPos = cache->hashEntries[slot];
	if (entryPos == -1)
	    return -1;

	if (memcmp(pGlyph->sha1, cache->glyphs[entryPos].sha1, sizeof(pGlyph->sha1)) == 0){
	    return entryPos;
	}
	    
	slot--;
	if (slot < 0)
	    slot = cache->hashSize - 1;
d276 1
a276 3
exaGlyphCacheHashInsert(ExaGlyphCachePtr cache,
			GlyphPtr         pGlyph,
			int              pos)
d281 1
a281 1
    
d283 10
a292 10
    
    while (TRUE) { /* hash table can never be full */
	if (cache->hashEntries[slot] == -1) {
	    cache->hashEntries[slot] = pos;
	    return;
	}
	    
	slot--;
	if (slot < 0)
	    slot = cache->hashSize - 1;
d297 1
a297 2
exaGlyphCacheHashRemove(ExaGlyphCachePtr cache,
			int              pos)
d304 42
a345 40
    while (TRUE) { /* hash table can never be full */
	int entryPos = cache->hashEntries[slot];
	
	if (entryPos == -1)
	    return;

	if (entryPos == pos) {
	    cache->hashEntries[slot] = -1;
	    emptiedSlot = slot;
	} else if (emptiedSlot != -1) {
	    /* See if we can move this entry into the emptied slot, we can't
	     * do that if if entry would have hashed between the current position
	     * and the emptied slot. (taking wrapping into account). Bad positions
	     * are:
	     *
	     * |   XXXXXXXXXX             |
	     *     i         j            
	     *                            
	     * |XXX                   XXXX|
	     *     j                  i
	     *
	     * i - slot, j - emptiedSlot
	     *
	     * (Knuth 6.4R)
	     */
	    
	    int entrySlot = (*(CARD32 *) cache->glyphs[entryPos].sha1) % cache->hashSize;

	    if (!((entrySlot >= slot && entrySlot < emptiedSlot) ||
		  (emptiedSlot < slot && (entrySlot < emptiedSlot || entrySlot >= slot)))) 
	    {
		cache->hashEntries[emptiedSlot] = entryPos;
		cache->hashEntries[slot] = -1;
		emptiedSlot = slot;
	    }
	}
	
	slot--;
	if (slot < 0)
	    slot = cache->hashSize - 1;
d364 2
a365 5
exaGlyphCacheUploadGlyph(ScreenPtr         pScreen,
			 ExaGlyphCachePtr  cache,
			 int               x,
			 int               y,
			 GlyphPtr          pGlyph)
d369 2
a370 1
    PixmapPtr pGlyphPixmap = (PixmapPtr)pGlyphPicture->pDrawable;
d372 1
a372 1
    PixmapPtr pCachePixmap = (PixmapPtr)cache->picture->pDrawable;
d374 3
a376 2
    if (!pExaScr->info->UploadToScreen || pExaScr->swappedOut || pExaPixmap->accel_blocked)
	goto composite;
d381 1
a381 1
	goto composite;
d384 3
a386 2
    if (pGlyphPixmap->drawable.bitsPerPixel != pCachePixmap->drawable.bitsPerPixel)
	goto composite;
d389 1
a389 1
	ExaMigrationRec pixmaps[1];
d391 6
a396 6
	/* cache pixmap must have a gpu copy. */
	pixmaps[0].as_dst = TRUE;
	pixmaps[0].as_src = FALSE;
	pixmaps[0].pPix = pCachePixmap;
	pixmaps[0].pReg = NULL;
	exaDoMigration (pixmaps, 1, TRUE);
d400 1
a400 1
	goto composite;
d404 14
a417 19
				      x,
				      y,
				      pGlyph->info.width,
				      pGlyph->info.height,
				      (char *)pExaPixmap->sys_ptr,
				      pExaPixmap->sys_pitch))
	goto damage;

composite:
    CompositePicture (PictOpSrc,
		      pGlyphPicture,
		      None,
		      cache->picture,
		      0, 0,
		      0, 0,
		      x,
		      y,
		      pGlyph->info.width,
		      pGlyph->info.height);
d419 1
a419 1
damage:
d421 2
a422 5
    exaPixmapDirty (pCachePixmap,
		    x,
		    y,
		    x + cache->glyphWidth,
		    y + cache->glyphHeight);
d426 9
a434 12
exaGlyphCacheBufferGlyph(ScreenPtr         pScreen,
			 ExaGlyphCachePtr  cache,
			 ExaGlyphBufferPtr buffer,
			 GlyphPtr          pGlyph,
			 PicturePtr        pSrc,
			 PicturePtr        pDst,
			 INT16             xSrc,
			 INT16             ySrc,
			 INT16             xMask,
			 INT16             yMask,
			 INT16             xDst,
			 INT16             yDst)
d439 1
a439 1
    
d441 1
a441 1
	return ExaGlyphNeedFlush;
d444 2
a445 2
	if (!exaRealizeGlyphCaches(pScreen, cache->format))
	    return ExaGlyphFail;
d449 4
a452 3
		     cache->glyphWidth, cache->glyphHeight, cache->format == PICT_a8 ? "A" : "ARGB",
		     (long)*(CARD32 *) pGlyph->sha1));
   
d455 47
a501 43
	DBG_GLYPH_CACHE(("  found existing glyph at %d\n", pos));
	x = CACHE_X(pos);
	y = CACHE_Y(pos);
    } else {
	if (cache->glyphCount < cache->size) {
	    /* Space remaining; we fill from the start */
	    pos = cache->glyphCount;
	    x = CACHE_X(pos);
	    y = CACHE_Y(pos);
	    cache->glyphCount++;
	    DBG_GLYPH_CACHE(("  storing glyph in free space at %d\n", pos));

	    exaGlyphCacheHashInsert(cache, pGlyph, pos);

	} else {
	    /* Need to evict an entry. We have to see if any glyphs
	     * already in the output buffer were at this position in
	     * the cache
	     */
	    pos = cache->evictionPosition;
	    x = CACHE_X(pos);
	    y = CACHE_Y(pos);
	    DBG_GLYPH_CACHE(("  evicting glyph at %d\n", pos));
	    if (buffer->count) {
		int i;

		for (i = 0; i < buffer->count; i++) {
		    if (pSrc ?
			(buffer->rects[i].xMask == x && buffer->rects[i].yMask == y) :
			(buffer->rects[i].xSrc == x && buffer->rects[i].ySrc == y)) {
			DBG_GLYPH_CACHE(("  must flush buffer\n"));
			return ExaGlyphNeedFlush;
		    }
		}
	    }

	    /* OK, we're all set, swap in the new glyph */
	    exaGlyphCacheHashRemove(cache, pos);
	    exaGlyphCacheHashInsert(cache, pGlyph, pos);

	    /* And pick a new eviction position */
	    cache->evictionPosition = rand() % cache->size;
	}
d503 1
a503 1
	exaGlyphCacheUploadGlyph(pScreen, cache, x, y, pGlyph);
d507 1
a507 1
	    
d510 11
a520 13
    if (pSrc)
    {
	rect->xSrc = xSrc;
	rect->ySrc = ySrc;
	rect->xMask = x;
	rect->yMask = y;
    }
    else
    {
	rect->xSrc = x;
	rect->ySrc = y;
	rect->xMask = 0;
	rect->yMask = 0;
d538 7
a544 11
exaBufferGlyph(ScreenPtr         pScreen,
	       ExaGlyphBufferPtr buffer,
	       GlyphPtr          pGlyph,
	       PicturePtr        pSrc,
	       PicturePtr        pDst,
	       INT16             xSrc,
	       INT16             ySrc,
	       INT16             xMask,
	       INT16             yMask,
	       INT16             xDst,
	       INT16             yDst)
d555 1
a555 1
	return ExaGlyphNeedFlush;
d558 2
a559 2
	format = PICT_a8;
    
d561 1
a561 1
	ExaGlyphCachePtr cache = &pExaScr->glyphCaches[i];
d563 22
a584 20
	if (format == cache->format &&
	    width <= cache->glyphWidth &&
	    height <= cache->glyphHeight) {
	    ExaGlyphCacheResult result = exaGlyphCacheBufferGlyph(pScreen,
								  &pExaScr->glyphCaches[i],
								  buffer,
								  pGlyph,
								  pSrc,
								  pDst,
								  xSrc, ySrc,
								  xMask, yMask,
								  xDst, yDst);
	    switch (result) {
	    case ExaGlyphFail:
		break;
	    case ExaGlyphSuccess:
	    case ExaGlyphNeedFlush:
		return result;
	    }
	}
d591 1
a591 1
	return ExaGlyphNeedFlush;
d611 1
a611 2
exaGlyphsToMask(PicturePtr        pMask,
		ExaGlyphBufferPtr buffer)
d614 2
a615 2
		      buffer->count, buffer->rects);
    
d621 1
a621 3
exaGlyphsToDst(PicturePtr	 pSrc,
	       PicturePtr	 pDst,
	       ExaGlyphBufferPtr buffer)
d624 2
a625 2
		      buffer->rects);
    
d632 7
a638 10
GlyphExtents (int		nlist,
	      GlyphListPtr	list,
	      GlyphPtr	       *glyphs,
	      BoxPtr		extents)
{
    int		x1, x2, y1, y2;
    int		n;
    GlyphPtr	glyph;
    int		x, y;
    
d645 30
a674 32
    while (nlist--)
    {
	x += list->xOff;
	y += list->yOff;
	n = list->len;
	list++;
	while (n--)
	{
	    glyph = *glyphs++;
	    x1 = x - glyph->info.x;
	    if (x1 < MINSHORT)
		x1 = MINSHORT;
	    y1 = y - glyph->info.y;
	    if (y1 < MINSHORT)
		y1 = MINSHORT;
	    x2 = x1 + glyph->info.width;
	    if (x2 > MAXSHORT)
		x2 = MAXSHORT;
	    y2 = y1 + glyph->info.height;
	    if (y2 > MAXSHORT)
		y2 = MAXSHORT;
	    if (x1 < extents->x1)
		extents->x1 = x1;
	    if (x2 > extents->x2)
		extents->x2 = x2;
	    if (y1 < extents->y1)
		extents->y1 = y1;
	    if (y2 > extents->y2)
		extents->y2 = y2;
	    x += glyph->info.xOff;
	    y += glyph->info.yOff;
	}
d679 18
a696 21
exaGlyphs (CARD8 	 op,
	   PicturePtr	 pSrc,
	   PicturePtr	 pDst,
	   PictFormatPtr maskFormat,
	   INT16	 xSrc,
	   INT16	 ySrc,
	   int		 nlist,
	   GlyphListPtr	 list,
	   GlyphPtr	*glyphs)
{
    PixmapPtr   pMaskPixmap = 0;
    PicturePtr  pMask = NULL;
    ScreenPtr   pScreen = pDst->pDrawable->pScreen;
    int		width = 0, height = 0;
    int		x, y;
    int		first_xOff = list->xOff, first_yOff = list->yOff;
    int		n;
    GlyphPtr	glyph;
    int		error;
    BoxRec	extents = {0, 0, 0, 0};
    CARD32	component_alpha;
d699 75
a773 77
    if (maskFormat)
    {
	ExaScreenPriv(pScreen);
	GCPtr	    pGC;
	xRectangle  rect;

	GlyphExtents (nlist, list, glyphs, &extents);

	if (extents.x2 <= extents.x1 || extents.y2 <= extents.y1)
	    return;
	width = extents.x2 - extents.x1;
	height = extents.y2 - extents.y1;

	if (maskFormat->depth == 1) {
	    PictFormatPtr a8Format = PictureMatchFormat (pScreen, 8, PICT_a8);

	    if (a8Format)
		maskFormat = a8Format;
	}

	pMaskPixmap = (*pScreen->CreatePixmap) (pScreen, width, height,
						maskFormat->depth,
						CREATE_PIXMAP_USAGE_SCRATCH);
	if (!pMaskPixmap)
	    return;
	component_alpha = NeedsComponent(maskFormat->format);
	pMask = CreatePicture (0, &pMaskPixmap->drawable,
			       maskFormat, CPComponentAlpha, &component_alpha,
			       serverClient, &error);
	if (!pMask ||
	    (!component_alpha && pExaScr->info->CheckComposite &&
	     !(*pExaScr->info->CheckComposite) (PictOpAdd, pSrc, NULL, pMask)))
	{
	    PictFormatPtr argbFormat;

	    (*pScreen->DestroyPixmap) (pMaskPixmap);

	    if (!pMask)
		return;

	    /* The driver can't seem to composite to a8, let's try argb (but
	     * without component-alpha) */
	    FreePicture ((pointer) pMask, (XID) 0);

	    argbFormat = PictureMatchFormat (pScreen, 32, PICT_a8r8g8b8);

	    if (argbFormat)
		maskFormat = argbFormat;
	    
	    pMaskPixmap = (*pScreen->CreatePixmap) (pScreen, width, height,
						    maskFormat->depth,
						    CREATE_PIXMAP_USAGE_SCRATCH);
	    if (!pMaskPixmap)
		return;

	    pMask = CreatePicture (0, &pMaskPixmap->drawable, maskFormat, 0, 0,
				   serverClient, &error);
	    if (!pMask) {
		(*pScreen->DestroyPixmap) (pMaskPixmap);
		return;
	    }
	}
	pGC = GetScratchGC (pMaskPixmap->drawable.depth, pScreen);
	ValidateGC (&pMaskPixmap->drawable, pGC);
	rect.x = 0;
	rect.y = 0;
	rect.width = width;
	rect.height = height;
	(*pGC->ops->PolyFillRect) (&pMaskPixmap->drawable, pGC, 1, &rect);
	FreeScratchGC (pGC);
	x = -extents.x1;
	y = -extents.y1;
    }
    else
    {
	x = 0;
	y = 0;
d777 41
a817 41
    while (nlist--)
    {
	x += list->xOff;
	y += list->yOff;
	n = list->len;
	while (n--)
	{
	    glyph = *glyphs++;

	    if (glyph->info.width > 0 && glyph->info.height > 0)
	    {
		/* pGlyph->info.{x,y} compensate for empty space in the glyph. */
		if (maskFormat)
		{
		    if (exaBufferGlyph(pScreen, &buffer, glyph, NULL, pMask,
				       0, 0, 0, 0, x - glyph->info.x, y - glyph->info.y) == ExaGlyphNeedFlush)
		    {
			exaGlyphsToMask(pMask, &buffer);
			exaBufferGlyph(pScreen, &buffer, glyph, NULL, pMask,
				       0, 0, 0, 0, x - glyph->info.x, y - glyph->info.y);
		    }
		}
		else
		{
		    if (exaBufferGlyph(pScreen, &buffer, glyph, pSrc, pDst,
				       xSrc + (x - glyph->info.x) - first_xOff, ySrc + (y - glyph->info.y) - first_yOff,
				       0, 0, x - glyph->info.x, y - glyph->info.y)
			== ExaGlyphNeedFlush)
		    {
			exaGlyphsToDst(pSrc, pDst, &buffer);
			exaBufferGlyph(pScreen, &buffer, glyph, pSrc, pDst,
				       xSrc + (x - glyph->info.x) - first_xOff, ySrc + (y - glyph->info.y) - first_yOff,
				       0, 0, x - glyph->info.x, y - glyph->info.y);
		    }
		}
	    }

	    x += glyph->info.xOff;
	    y += glyph->info.yOff;
	}
	list++;
d819 1
a819 1
    
d822 1
a822 1
	    exaGlyphsToMask(pMask, &buffer);
d824 1
a824 1
	    exaGlyphsToDst(pSrc, pDst, &buffer);
d827 11
a837 15
    if (maskFormat)
    {
	x = extents.x1;
	y = extents.y1;
	CompositePicture (op,
			  pSrc,
			  pMask,
			  pDst,
			  xSrc + x - first_xOff,
			  ySrc + y - first_yOff,
			  0, 0,
			  x, y,
			  width, height);
	FreePicture ((pointer) pMask, (XID) 0);
	(*pScreen->DestroyPixmap) (pMaskPixmap);
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d130 2
a131 4
	if (cache->hashEntries) {
	    xfree(cache->hashEntries);
	    cache->hashEntries = NULL;
	}
d133 2
a134 4
	if (cache->glyphs) {
	    xfree(cache->glyphs);
	    cache->glyphs = NULL;
	}
d212 2
a213 2
	cache->hashEntries = xalloc(sizeof(int) * cache->hashSize);
	cache->glyphs = xalloc(sizeof(ExaCachedGlyphRec) * cache->size);
@


1.1
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d71 1
a71 1
    PicturePtr source;
d147 1
a147 1
 * for switching between source pixmaps. (Note that for a size of font
a189 1
       
a206 1
    
d355 1
a355 1
 * pipeline glyph uploads and to avoid creating offscreen pixmaps for
d358 2
a359 2
 * If we can't do it with UploadToScreen (because the glyph is offscreen, etc),
 * we fall back to CompositePicture.
d367 2
a368 1
			 int               pos,
a375 1
    ExaMigrationRec pixmaps[1];
d382 1
a382 1
    if (exaPixmapIsOffscreen(pGlyphPixmap))
d389 10
a398 6
    /* cache pixmap must be offscreen. */
    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = FALSE;
    pixmaps[0].pPix = pCachePixmap;
    pixmaps[0].pReg = NULL;
    exaDoMigration (pixmaps, 1, TRUE);
d400 1
a400 1
    if (!exaPixmapIsOffscreen(pCachePixmap))
d403 1
a403 1
    /* CACHE_{X,Y} are in pixmap coordinates, no need for cache{X,Y}off */
d405 2
a406 2
				      CACHE_X(pos),
				      CACHE_Y(pos),
d420 2
a421 2
		      CACHE_X(pos),
		      CACHE_Y(pos),
d428 4
a431 4
		    CACHE_X(pos),
		    CACHE_Y(pos),
		    CACHE_X(pos) + cache->glyphWidth,
		    CACHE_Y(pos) + cache->glyphHeight);
d439 8
a446 2
			 int               xGlyph,
			 int               yGlyph)
d450 1
d452 1
a452 1
    if (buffer->source && buffer->source != cache->picture)
d467 2
d473 2
a484 1
	    
d486 2
a489 1
		int x, y;
a490 3
		
		x = CACHE_X(pos);
		y = CACHE_Y(pos);
d493 3
a495 1
		    if (buffer->rects[i].xSrc == x && buffer->rects[i].ySrc == y) {
d510 1
a510 1
	exaGlyphCacheUploadGlyph(pScreen, cache, pos, pGlyph);
d513 1
a513 1
    buffer->source = cache->picture;
d516 19
a534 4
    rect->xSrc = CACHE_X(pos);
    rect->ySrc = CACHE_Y(pos);
    rect->xDst = xGlyph - pGlyph->info.x;
    rect->yDst = yGlyph - pGlyph->info.y;
d550 8
a557 2
	       int               xGlyph,
	       int               yGlyph)
d564 1
a564 1
    PicturePtr source;
d579 2
a580 1
	    ExaGlyphCacheResult result = exaGlyphCacheBufferGlyph(pScreen, &pExaScr->glyphCaches[i],
d582 6
a587 1
								  pGlyph, xGlyph, yGlyph);
d600 2
a601 2
    source = GlyphPicture(pGlyph)[pScreen->myNum];
    if (buffer->source && buffer->source != source)
d604 2
a605 2
    buffer->source = source;
    
d607 8
a614 6
    rect->xSrc = 0;
    rect->ySrc = 0;
    rect->xDst = xGlyph - pGlyph->info.x;
    rect->yDst = yGlyph - pGlyph->info.y;
    rect->width = pGlyph->info.width;
    rect->height = pGlyph->info.height;
d625 1
a625 1
    exaCompositeRects(PictOpAdd, buffer->source, pMask,
d629 1
a629 1
    buffer->source = NULL;
d633 1
a633 2
exaGlyphsToDst(CARD8		 op,
	       PicturePtr	 pSrc,
d635 1
a635 5
	       ExaGlyphBufferPtr buffer,
	       INT16		 xSrc,
	       INT16		 ySrc,
	       INT16		 xDst,
	       INT16		 yDst)
d637 2
a638 18
    int i;

    for (i = 0; i < buffer->count; i++) {
	ExaCompositeRectPtr rect = &buffer->rects[i];

	CompositePicture (op,
			  pSrc,
			  buffer->source,
			  pDst,
			  xSrc + rect->xDst - xDst,
			  ySrc + rect->yDst - yDst,
			  rect->xSrc,
			  rect->ySrc,
			  rect->xDst,
			  rect->yDst,
			  rect->width,
			  rect->height);
    }
d641 1
a641 1
    buffer->source = NULL;
a696 73
/**
 * Returns TRUE if the glyphs in the lists intersect.  Only checks based on
 * bounding box, which appears to be good enough to catch most cases at least.
 */
static Bool
exaGlyphsIntersect(int nlist, GlyphListPtr list, GlyphPtr *glyphs)
{
    int x1, x2, y1, y2;
    int n;
    GlyphPtr glyph;
    int x, y;
    BoxRec extents;
    Bool first = TRUE;

    x = 0;
    y = 0;
    while (nlist--) {
       x += list->xOff;
       y += list->yOff;
       n = list->len;
       list++;
       while (n--) {
           glyph = *glyphs++;

           if (glyph->info.width == 0 || glyph->info.height == 0) {
               x += glyph->info.xOff;
               y += glyph->info.yOff;
               continue;
           }

           x1 = x - glyph->info.x;
           if (x1 < MINSHORT)
               x1 = MINSHORT;
           y1 = y - glyph->info.y;
           if (y1 < MINSHORT)
               y1 = MINSHORT;
           x2 = x1 + glyph->info.width;
           if (x2 > MAXSHORT)
               x2 = MAXSHORT;
           y2 = y1 + glyph->info.height;
           if (y2 > MAXSHORT)
               y2 = MAXSHORT;

           if (first) {
               extents.x1 = x1;
               extents.y1 = y1;
               extents.x2 = x2;
               extents.y2 = y2;
               first = FALSE;
           } else {
               if (x1 < extents.x2 && x2 > extents.x1 &&
                   y1 < extents.y2 && y2 > extents.y1)
               {
                   return TRUE;
               }

               if (x1 < extents.x1)
                  extents.x1 = x1;
               if (x2 > extents.x2)
                   extents.x2 = x2;
               if (y1 < extents.y1)
                   extents.y1 = y1;
               if (y2 > extents.y2)
                   extents.y2 = y2;
           }
           x += glyph->info.xOff;
           y += glyph->info.yOff;
       }
    }

    return FALSE;
}

a707 1
    PicturePtr	pPicture;
d709 1
a709 1
    PicturePtr  pMask;
d713 1
a713 1
    int		xDst = list->xOff, yDst = list->yOff;
a720 23
    /* If we don't have a mask format but all the glyphs have the same format
     * and don't intersect, use the glyph format as mask format for the full
     * benefits of the glyph cache.
     */
    if (!maskFormat) {
       Bool sameFormat = TRUE;
       int i;

       maskFormat = list[0].format;

       for (i = 0; i < nlist; i++) {
           if (maskFormat->format != list[i].format->format) {
               sameFormat = FALSE;
               break;
           }
       }

       if (!sameFormat || (maskFormat->depth != 1 &&
			   exaGlyphsIntersect(nlist, list, glyphs))) {
	   maskFormat = NULL;
       }
    }

d723 1
d750 3
a752 1
	if (!pMask)
d754 2
d757 25
a781 1
	    return;
a795 1
	pMask = pDst;
d800 1
a800 1
    buffer.source = NULL;
a808 1
	    pPicture = GlyphPicture (glyph)[pScreen->myNum];
d810 1
a810 2
	    if (glyph->info.width > 0 && glyph->info.height > 0 &&
		exaBufferGlyph(pScreen, &buffer, glyph, x, y) == ExaGlyphNeedFlush)
d812 1
d814 9
a822 1
		    exaGlyphsToMask(pMask, &buffer);
d824 12
a835 4
		    exaGlyphsToDst(op, pSrc, pDst, &buffer,
				   xSrc, ySrc, xDst, yDst);

		exaBufferGlyph(pScreen, &buffer, glyph, x, y);
d848 1
a848 2
	    exaGlyphsToDst(op, pSrc, pDst, &buffer,
		           xSrc, ySrc, xDst, yDst);
d859 2
a860 2
			  xSrc + x - xDst,
			  ySrc + y - yDst,
@

