head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.6
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.43;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.06.34;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright Â© 2003 Anders Carlsson
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Anders Carlsson not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Anders Carlsson makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * ANDERS CARLSSON DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL ANDERS CARLSSON BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/** @@file
 * This allocator allocates blocks of memory by maintaining a list of areas.
 * When allocating, the contiguous block of areas with the minimum eviction
 * cost is found and evicted in order to make room for the new allocation.
 */

#include "exa_priv.h"

#include <limits.h>
#include <assert.h>
#include <stdlib.h>

#if DEBUG_OFFSCREEN
#define DBG_OFFSCREEN(a) ErrorF a
#else
#define DBG_OFFSCREEN(a)
#endif

#if DEBUG_OFFSCREEN
static void
ExaOffscreenValidate(ScreenPtr pScreen)
{
    ExaScreenPriv(pScreen);
    ExaOffscreenArea *prev = 0, *area;

    assert(pExaScr->info->offScreenAreas->base_offset ==
           pExaScr->info->offScreenBase);
    for (area = pExaScr->info->offScreenAreas; area; area = area->next) {
        assert(area->offset >= area->base_offset &&
               area->offset < (area->base_offset + area->size));
        if (prev)
            assert(prev->base_offset + prev->size == area->base_offset);
        prev = area;
    }
    assert(prev->base_offset + prev->size == pExaScr->info->memorySize);
}
#else
#define ExaOffscreenValidate(s)
#endif

static ExaOffscreenArea *
ExaOffscreenKickOut(ScreenPtr pScreen, ExaOffscreenArea * area)
{
    if (area->save)
        (*area->save) (pScreen, area);
    return exaOffscreenFree(pScreen, area);
}

static void
exaUpdateEvictionCost(ExaOffscreenArea * area, unsigned offScreenCounter)
{
    unsigned age;

    if (area->state == ExaOffscreenAvail)
        return;

    age = offScreenCounter - area->last_use;

    /* This is unlikely to happen, but could result in a division by zero... */
    if (age > (UINT_MAX / 2)) {
        age = UINT_MAX / 2;
        area->last_use = offScreenCounter - age;
    }

    area->eviction_cost = area->size / age;
}

static ExaOffscreenArea *
exaFindAreaToEvict(ExaScreenPrivPtr pExaScr, int size, int align)
{
    ExaOffscreenArea *begin, *end, *best;
    unsigned cost, best_cost;
    int avail, real_size;

    best_cost = UINT_MAX;
    begin = end = pExaScr->info->offScreenAreas;
    avail = 0;
    cost = 0;
    best = 0;

    while (end != NULL) {
 restart:
        while (begin != NULL && begin->state == ExaOffscreenLocked)
            begin = end = begin->next;

        if (begin == NULL)
            break;

        /* adjust size needed to account for alignment loss for this area */
        real_size = size + (begin->base_offset + begin->size - size) % align;

        while (avail < real_size && end != NULL) {
            if (end->state == ExaOffscreenLocked) {
                /* Can't more room here, restart after this locked area */
                avail = 0;
                cost = 0;
                begin = end;
                goto restart;
            }
            avail += end->size;
            exaUpdateEvictionCost(end, pExaScr->offScreenCounter);
            cost += end->eviction_cost;
            end = end->next;
        }

        /* Check the cost, update best */
        if (avail >= real_size && cost < best_cost) {
            best = begin;
            best_cost = cost;
        }

        avail -= begin->size;
        cost -= begin->eviction_cost;
        begin = begin->next;
    }

    return best;
}

/**
 * exaOffscreenAlloc allocates offscreen memory
 *
 * @@param pScreen current screen
 * @@param size size in bytes of the allocation
 * @@param align byte alignment requirement for the offset of the allocated area
 * @@param locked whether the allocated area is locked and can't be kicked out
 * @@param save callback for when the area is evicted from memory
 * @@param privdata private data for the save callback.
 *
 * Allocates offscreen memory from the device associated with pScreen.  size
 * and align deteremine where and how large the allocated area is, and locked
 * will mark whether it should be held in card memory.  privdata may be any
 * pointer for the save callback when the area is removed.
 *
 * Note that locked areas do get evicted on VT switch unless the driver
 * requested version 2.1 or newer behavior.  In that case, the save callback is
 * still called.
 */
ExaOffscreenArea *
exaOffscreenAlloc(ScreenPtr pScreen, int size, int align,
                  Bool locked, ExaOffscreenSaveProc save, void *privData)
{
    ExaOffscreenArea *area;

    ExaScreenPriv(pScreen);
    int real_size = 0, largest_avail = 0;

#if DEBUG_OFFSCREEN
    static int number = 0;

    ErrorF("================= ============ allocating a new pixmap %d\n",
           ++number);
#endif

    ExaOffscreenValidate(pScreen);
    if (!align)
        align = 1;

    if (!size) {
        DBG_OFFSCREEN(("Alloc 0x%x -> EMPTY\n", size));
        return NULL;
    }

    /* throw out requests that cannot fit */
    if (size > (pExaScr->info->memorySize - pExaScr->info->offScreenBase)) {
        DBG_OFFSCREEN(("Alloc 0x%x vs (0x%lx) -> TOBIG\n", size,
                       pExaScr->info->memorySize -
                       pExaScr->info->offScreenBase));
        return NULL;
    }

    /* Try to find a free space that'll fit. */
    for (area = pExaScr->info->offScreenAreas; area; area = area->next) {
        /* skip allocated areas */
        if (area->state != ExaOffscreenAvail)
            continue;

        /* adjust size to match alignment requirement */
        real_size = size + (area->base_offset + area->size - size) % align;

        /* does it fit? */
        if (real_size <= area->size)
            break;

        if (area->size > largest_avail)
            largest_avail = area->size;
    }

    if (!area) {
        area = exaFindAreaToEvict(pExaScr, size, align);

        if (!area) {
            DBG_OFFSCREEN(("Alloc 0x%x -> NOSPACE\n", size));
            /* Could not allocate memory */
            ExaOffscreenValidate(pScreen);
            return NULL;
        }

        /* adjust size needed to account for alignment loss for this area */
        real_size = size + (area->base_offset + area->size - size) % align;

        /*
         * Kick out first area if in use
         */
        if (area->state != ExaOffscreenAvail)
            area = ExaOffscreenKickOut(pScreen, area);
        /*
         * Now get the system to merge the other needed areas together
         */
        while (area->size < real_size) {
            assert(area->next && area->next->state == ExaOffscreenRemovable);
            (void) ExaOffscreenKickOut(pScreen, area->next);
        }
    }

    /* save extra space in new area */
    if (real_size < area->size) {
        ExaOffscreenArea *new_area = malloc(sizeof(ExaOffscreenArea));

        if (!new_area)
            return NULL;
        new_area->base_offset = area->base_offset;

        new_area->offset = new_area->base_offset;
        new_area->align = 0;
        new_area->size = area->size - real_size;
        new_area->state = ExaOffscreenAvail;
        new_area->save = NULL;
        new_area->last_use = 0;
        new_area->eviction_cost = 0;
        new_area->next = area;
        new_area->prev = area->prev;
        if (area->prev->next)
            area->prev->next = new_area;
        else
            pExaScr->info->offScreenAreas = new_area;
        area->prev = new_area;
        area->base_offset = new_area->base_offset + new_area->size;
        area->size = real_size;
    }
    else
        pExaScr->numOffscreenAvailable--;

    /*
     * Mark this area as in use
     */
    if (locked)
        area->state = ExaOffscreenLocked;
    else
        area->state = ExaOffscreenRemovable;
    area->privData = privData;
    area->save = save;
    area->last_use = pExaScr->offScreenCounter++;
    area->offset = (area->base_offset + align - 1);
    area->offset -= area->offset % align;
    area->align = align;

    ExaOffscreenValidate(pScreen);

    DBG_OFFSCREEN(("Alloc 0x%x -> 0x%x (0x%x)\n", size,
                   area->base_offset, area->offset));
    return area;
}

/**
 * Ejects all offscreen areas, and uninitializes the offscreen memory manager.
 */
void
ExaOffscreenSwapOut(ScreenPtr pScreen)
{
    ExaScreenPriv(pScreen);

    ExaOffscreenValidate(pScreen);
    /* loop until a single free area spans the space */
    for (;;) {
        ExaOffscreenArea *area = pExaScr->info->offScreenAreas;

        if (!area)
            break;
        if (area->state == ExaOffscreenAvail) {
            area = area->next;
            if (!area)
                break;
        }
        assert(area->state != ExaOffscreenAvail);
        (void) ExaOffscreenKickOut(pScreen, area);
        ExaOffscreenValidate(pScreen);
    }
    ExaOffscreenValidate(pScreen);
    ExaOffscreenFini(pScreen);
}

/** Ejects all pixmaps managed by EXA. */
static void
ExaOffscreenEjectPixmaps(ScreenPtr pScreen)
{
    ExaScreenPriv(pScreen);

    ExaOffscreenValidate(pScreen);
    /* loop until a single free area spans the space */
    for (;;) {
        ExaOffscreenArea *area;

        for (area = pExaScr->info->offScreenAreas; area != NULL;
             area = area->next) {
            if (area->state == ExaOffscreenRemovable &&
                area->save == exaPixmapSave) {
                (void) ExaOffscreenKickOut(pScreen, area);
                ExaOffscreenValidate(pScreen);
                break;
            }
        }
        if (area == NULL)
            break;
    }
    ExaOffscreenValidate(pScreen);
}

void
ExaOffscreenSwapIn(ScreenPtr pScreen)
{
    exaOffscreenInit(pScreen);
}

/**
 * Prepares EXA for disabling of FB access, or restoring it.
 *
 * In version 2.1, the disabling results in pixmaps being ejected, while other
 * allocations remain.  With this plus the prevention of migration while
 * swappedOut is set, EXA by itself should not cause any access of the
 * framebuffer to occur while swapped out.  Any remaining issues are the
 * responsibility of the driver.
 *
 * Prior to version 2.1, all allocations, including locked ones, are ejected
 * when access is disabled, and the allocator is torn down while swappedOut
 * is set.  This is more drastic, and caused implementation difficulties for
 * many drivers that could otherwise handle the lack of FB access while
 * swapped out.
 */
void
exaEnableDisableFBAccess(ScreenPtr pScreen, Bool enable)
{
    ExaScreenPriv(pScreen);

    if (pExaScr->info->flags & EXA_HANDLES_PIXMAPS)
        return;

    if (!enable && pExaScr->disableFbCount++ == 0) {
        if (pExaScr->info->exa_minor < 1)
            ExaOffscreenSwapOut(pScreen);
        else
            ExaOffscreenEjectPixmaps(pScreen);
        pExaScr->swappedOut = TRUE;
    }

    if (enable && --pExaScr->disableFbCount == 0) {
        if (pExaScr->info->exa_minor < 1)
            ExaOffscreenSwapIn(pScreen);
        pExaScr->swappedOut = FALSE;
    }
}

/* merge the next free area into this one */
static void
ExaOffscreenMerge(ExaScreenPrivPtr pExaScr, ExaOffscreenArea * area)
{
    ExaOffscreenArea *next = area->next;

    /* account for space */
    area->size += next->size;
    /* frob pointer */
    area->next = next->next;
    if (area->next)
        area->next->prev = area;
    else
        pExaScr->info->offScreenAreas->prev = area;
    free(next);

    pExaScr->numOffscreenAvailable--;
}

/**
 * exaOffscreenFree frees an allocation.
 *
 * @@param pScreen current screen
 * @@param area offscreen area to free
 *
 * exaOffscreenFree frees an allocation created by exaOffscreenAlloc.  Note that
 * the save callback of the area is not called, and it is up to the driver to
 * do any cleanup necessary as a result.
 *
 * @@return pointer to the newly freed area. This behavior should not be relied
 * on.
 */
ExaOffscreenArea *
exaOffscreenFree(ScreenPtr pScreen, ExaOffscreenArea * area)
{
    ExaScreenPriv(pScreen);
    ExaOffscreenArea *next = area->next;
    ExaOffscreenArea *prev;

    DBG_OFFSCREEN(("Free 0x%x -> 0x%x (0x%x)\n", area->size,
                   area->base_offset, area->offset));
    ExaOffscreenValidate(pScreen);

    area->state = ExaOffscreenAvail;
    area->save = NULL;
    area->last_use = 0;
    area->eviction_cost = 0;
    /*
     * Find previous area
     */
    if (area == pExaScr->info->offScreenAreas)
        prev = NULL;
    else
        prev = area->prev;

    pExaScr->numOffscreenAvailable++;

    /* link with next area if free */
    if (next && next->state == ExaOffscreenAvail)
        ExaOffscreenMerge(pExaScr, area);

    /* link with prev area if free */
    if (prev && prev->state == ExaOffscreenAvail) {
        area = prev;
        ExaOffscreenMerge(pExaScr, area);
    }

    ExaOffscreenValidate(pScreen);
    DBG_OFFSCREEN(("\tdone freeing\n"));
    return area;
}

void
ExaOffscreenMarkUsed(PixmapPtr pPixmap)
{
    ExaPixmapPriv(pPixmap);
    ExaScreenPriv(pPixmap->drawable.pScreen);

    if (!pExaPixmap || !pExaPixmap->area)
        return;

    pExaPixmap->area->last_use = pExaScr->offScreenCounter++;
}

/**
 * Defragment offscreen memory by compacting allocated areas at the end of it,
 * leaving the total amount of memory available as a single area at the
 * beginning (when there are no pinned allocations).
 */
_X_HIDDEN ExaOffscreenArea *
ExaOffscreenDefragment(ScreenPtr pScreen)
{
    ExaScreenPriv(pScreen);
    ExaOffscreenArea *area, *largest_available = NULL;
    int largest_size = 0;
    PixmapPtr pDstPix;
    ExaPixmapPrivPtr pExaDstPix;

    pDstPix = (*pScreen->CreatePixmap) (pScreen, 0, 0, 0, 0);

    if (!pDstPix)
        return NULL;

    pExaDstPix = ExaGetPixmapPriv(pDstPix);
    pExaDstPix->use_gpu_copy = TRUE;

    for (area = pExaScr->info->offScreenAreas->prev;
         area != pExaScr->info->offScreenAreas;) {
        ExaOffscreenArea *prev = area->prev;
        PixmapPtr pSrcPix;
        ExaPixmapPrivPtr pExaSrcPix;
        Bool save_use_gpu_copy;
        int save_pitch;

        if (area->state != ExaOffscreenAvail ||
            prev->state == ExaOffscreenLocked ||
            (prev->state == ExaOffscreenRemovable &&
             prev->save != exaPixmapSave)) {
            area = prev;
            continue;
        }

        if (prev->state == ExaOffscreenAvail) {
            if (area == largest_available) {
                largest_available = prev;
                largest_size += prev->size;
            }
            area = prev;
            ExaOffscreenMerge(pExaScr, area);
            continue;
        }

        if (area->size > largest_size) {
            largest_available = area;
            largest_size = area->size;
        }

        pSrcPix = prev->privData;
        pExaSrcPix = ExaGetPixmapPriv(pSrcPix);

        pExaDstPix->fb_ptr = pExaScr->info->memoryBase +
            area->base_offset + area->size - prev->size + prev->base_offset -
            prev->offset;
        pExaDstPix->fb_ptr -= (unsigned long) pExaDstPix->fb_ptr % prev->align;

        if (pExaDstPix->fb_ptr <= pExaSrcPix->fb_ptr) {
            area = prev;
            continue;
        }

        if (!(pExaScr->info->flags & EXA_SUPPORTS_OFFSCREEN_OVERLAPS) &&
            (pExaSrcPix->fb_ptr + prev->size) > pExaDstPix->fb_ptr) {
            area = prev;
            continue;
        }

        save_use_gpu_copy = pExaSrcPix->use_gpu_copy;
        save_pitch = pSrcPix->devKind;

        pExaSrcPix->use_gpu_copy = TRUE;
        pSrcPix->devKind = pExaSrcPix->fb_pitch;

        pDstPix->drawable.width = pSrcPix->drawable.width;
        pDstPix->devKind = pSrcPix->devKind;
        pDstPix->drawable.height = pSrcPix->drawable.height;
        pDstPix->drawable.depth = pSrcPix->drawable.depth;
        pDstPix->drawable.bitsPerPixel = pSrcPix->drawable.bitsPerPixel;

        if (!pExaScr->info->PrepareCopy(pSrcPix, pDstPix, -1, -1, GXcopy, ~0)) {
            pExaSrcPix->use_gpu_copy = save_use_gpu_copy;
            pSrcPix->devKind = save_pitch;
            area = prev;
            continue;
        }

        pExaScr->info->Copy(pDstPix, 0, 0, 0, 0, pDstPix->drawable.width,
                            pDstPix->drawable.height);
        pExaScr->info->DoneCopy(pDstPix);
        exaMarkSync(pScreen);

        DBG_OFFSCREEN(("Before swap: prev=0x%08x-0x%08x-0x%08x area=0x%08x-0x%08x-0x%08x\n", prev->base_offset, prev->offset, prev->base_offset + prev->size, area->base_offset, area->offset, area->base_offset + area->size));

        /* Calculate swapped area offsets and sizes */
        area->base_offset = prev->base_offset;
        area->offset = area->base_offset;
        prev->offset += pExaDstPix->fb_ptr - pExaSrcPix->fb_ptr;
        assert(prev->offset >= pExaScr->info->offScreenBase &&
               prev->offset < pExaScr->info->memorySize);
        prev->base_offset = prev->offset;
        if (area->next)
            prev->size = area->next->base_offset - prev->base_offset;
        else
            prev->size = pExaScr->info->memorySize - prev->base_offset;
        area->size = prev->base_offset - area->base_offset;

        DBG_OFFSCREEN(("After swap: area=0x%08x-0x%08x-0x%08x prev=0x%08x-0x%08x-0x%08x\n", area->base_offset, area->offset, area->base_offset + area->size, prev->base_offset, prev->offset, prev->base_offset + prev->size));

        /* Swap areas in list */
        if (area->next)
            area->next->prev = prev;
        else
            pExaScr->info->offScreenAreas->prev = prev;
        if (prev->prev->next)
            prev->prev->next = area;
        else
            pExaScr->info->offScreenAreas = area;
        prev->next = area->next;
        area->next = prev;
        area->prev = prev->prev;
        prev->prev = area;
        if (!area->prev->next)
            pExaScr->info->offScreenAreas = area;

#if DEBUG_OFFSCREEN
        if (prev->prev == prev || prev->next == prev)
            ErrorF("Whoops, prev points to itself!\n");

        if (area->prev == area || area->next == area)
            ErrorF("Whoops, area points to itself!\n");
#endif

        pExaSrcPix->fb_ptr = pExaDstPix->fb_ptr;
        pExaSrcPix->use_gpu_copy = save_use_gpu_copy;
        pSrcPix->devKind = save_pitch;
    }

    pDstPix->drawable.width = 0;
    pDstPix->drawable.height = 0;
    pDstPix->drawable.depth = 0;
    pDstPix->drawable.bitsPerPixel = 0;

    (*pScreen->DestroyPixmap) (pDstPix);

    if (area->state == ExaOffscreenAvail && area->size > largest_size)
        return area;

    return largest_available;
}

/**
 * exaOffscreenInit initializes the offscreen memory manager.
 *
 * @@param pScreen current screen
 *
 * exaOffscreenInit is called by exaDriverInit to set up the memory manager for
 * the screen, if any offscreen memory is available.
 */
Bool
exaOffscreenInit(ScreenPtr pScreen)
{
    ExaScreenPriv(pScreen);
    ExaOffscreenArea *area;

    /* Allocate a big free area */
    area = malloc(sizeof(ExaOffscreenArea));

    if (!area)
        return FALSE;

    area->state = ExaOffscreenAvail;
    area->base_offset = pExaScr->info->offScreenBase;
    area->offset = area->base_offset;
    area->align = 0;
    area->size = pExaScr->info->memorySize - area->base_offset;
    area->save = NULL;
    area->next = NULL;
    area->prev = area;
    area->last_use = 0;
    area->eviction_cost = 0;

    /* Add it to the free areas */
    pExaScr->info->offScreenAreas = area;
    pExaScr->offScreenCounter = 1;
    pExaScr->numOffscreenAvailable = 1;

    ExaOffscreenValidate(pScreen);

    return TRUE;
}

void
ExaOffscreenFini(ScreenPtr pScreen)
{
    ExaScreenPriv(pScreen);
    ExaOffscreenArea *area;

    /* just free all of the area records */
    while ((area = pExaScr->info->offScreenAreas)) {
        pExaScr->info->offScreenAreas = area->next;
        free(area);
    }
}
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d163 1
a163 1
                  Bool locked, ExaOffscreenSaveProc save, pointer privData)
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d363 1
a363 1
exaEnableDisableFBAccess(int index, Bool enable)
a364 2
    ScreenPtr pScreen = screenInfo.screens[index];

@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d43 1
a43 1
ExaOffscreenValidate (ScreenPtr pScreen)
d45 1
a45 1
    ExaScreenPriv (pScreen);
d48 8
a55 9
    assert (pExaScr->info->offScreenAreas->base_offset == 
	    pExaScr->info->offScreenBase);
    for (area = pExaScr->info->offScreenAreas; area; area = area->next)
    {
	assert (area->offset >= area->base_offset &&
		area->offset < (area->base_offset + area->size));
	if (prev)
	    assert (prev->base_offset + prev->size == area->base_offset);
	prev = area;
d57 1
a57 1
    assert (prev->base_offset + prev->size == pExaScr->info->memorySize);
d64 1
a64 1
ExaOffscreenKickOut (ScreenPtr pScreen, ExaOffscreenArea *area)
d67 2
a68 2
	(*area->save) (pScreen, area);
    return exaOffscreenFree (pScreen, area);
d72 1
a72 1
exaUpdateEvictionCost(ExaOffscreenArea *area, unsigned offScreenCounter)
d77 1
a77 1
	return;
d83 2
a84 2
	age = UINT_MAX / 2;
	area->last_use = offScreenCounter - age;
d103 34
a136 36
    while (end != NULL)
    {
	restart:
	while (begin != NULL && begin->state == ExaOffscreenLocked)
	    begin = end = begin->next;

	if (begin == NULL)
	    break;

	/* adjust size needed to account for alignment loss for this area */
	real_size = size + (begin->base_offset + begin->size - size) % align;

	while (avail < real_size && end != NULL)
	{
	    if (end->state == ExaOffscreenLocked) {
		/* Can't more room here, restart after this locked area */
		avail = 0;
		cost = 0;
		begin = end;
		goto restart;
	    }
	    avail += end->size;
	    exaUpdateEvictionCost(end, pExaScr->offScreenCounter);
	    cost += end->eviction_cost;
	    end = end->next;
	}

	/* Check the cost, update best */
	if (avail >= real_size && cost < best_cost) {
	    best = begin;
	    best_cost = cost;
	}

	avail -= begin->size;
	cost -= begin->eviction_cost;
	begin = begin->next;
d162 2
a163 4
exaOffscreenAlloc (ScreenPtr pScreen, int size, int align,
                   Bool locked,
                   ExaOffscreenSaveProc save,
                   pointer privData)
d166 2
a167 1
    ExaScreenPriv (pScreen);
d169 1
d172 3
a174 1
    ErrorF("================= ============ allocating a new pixmap %d\n", ++number);
d177 1
a177 1
    ExaOffscreenValidate (pScreen);
d179 1
a179 1
	align = 1;
d181 3
a183 4
    if (!size)
    {
	DBG_OFFSCREEN (("Alloc 0x%x -> EMPTY\n", size));
	return NULL;
d187 5
a191 6
    if (size > (pExaScr->info->memorySize - pExaScr->info->offScreenBase))
    {
	DBG_OFFSCREEN (("Alloc 0x%x vs (0x%lx) -> TOBIG\n", size,
			pExaScr->info->memorySize -
			pExaScr->info->offScreenBase));
	return NULL;
d195 41
a235 15
    for (area = pExaScr->info->offScreenAreas; area; area = area->next)
    {
	/* skip allocated areas */
	if (area->state != ExaOffscreenAvail)
	    continue;

	/* adjust size to match alignment requirement */
	real_size = size + (area->base_offset + area->size - size) % align;

	/* does it fit? */
	if (real_size <= area->size)
	    break;

	if (area->size > largest_avail)
	    largest_avail = area->size;
d238 3
a240 3
    if (!area)
    {
	area = exaFindAreaToEvict(pExaScr, size, align);
d242 20
a261 24
	if (!area)
	{
	    DBG_OFFSCREEN (("Alloc 0x%x -> NOSPACE\n", size));
	    /* Could not allocate memory */
	    ExaOffscreenValidate (pScreen);
	    return NULL;
	}

	/* adjust size needed to account for alignment loss for this area */
	real_size = size + (area->base_offset + area->size - size) % align;

	/*
	 * Kick out first area if in use
	 */
	if (area->state != ExaOffscreenAvail)
	    area = ExaOffscreenKickOut (pScreen, area);
	/*
	 * Now get the system to merge the other needed areas together
	 */
	while (area->size < real_size)
	{
	    assert (area->next && area->next->state == ExaOffscreenRemovable);
	    (void) ExaOffscreenKickOut (pScreen, area->next);
	}
d263 2
a264 27

    /* save extra space in new area */
    if (real_size < area->size)
    {
	ExaOffscreenArea   *new_area = malloc(sizeof (ExaOffscreenArea));
	if (!new_area)
	    return NULL;
	new_area->base_offset = area->base_offset;

	new_area->offset = new_area->base_offset;
	new_area->align = 0;
	new_area->size = area->size - real_size;
	new_area->state = ExaOffscreenAvail;
	new_area->save = NULL;
	new_area->last_use = 0;
	new_area->eviction_cost = 0;
	new_area->next = area;
	new_area->prev = area->prev;
	if (area->prev->next)
	    area->prev->next = new_area;
	else
	    pExaScr->info->offScreenAreas = new_area;
	area->prev = new_area;
	area->base_offset = new_area->base_offset + new_area->size;
	area->size = real_size;
    } else
	pExaScr->numOffscreenAvailable--;
d270 1
a270 1
	area->state = ExaOffscreenLocked;
d272 1
a272 1
	area->state = ExaOffscreenRemovable;
d280 1
a280 1
    ExaOffscreenValidate (pScreen);
d282 2
a283 2
    DBG_OFFSCREEN (("Alloc 0x%x -> 0x%x (0x%x)\n", size,
		    area->base_offset, area->offset));
d291 1
a291 1
ExaOffscreenSwapOut (ScreenPtr pScreen)
d293 1
a293 1
    ExaScreenPriv (pScreen);
d295 1
a295 1
    ExaOffscreenValidate (pScreen);
d297 13
a309 15
    for (;;)
    {
	ExaOffscreenArea *area = pExaScr->info->offScreenAreas;

	if (!area)
	    break;
	if (area->state == ExaOffscreenAvail)
	{
	    area = area->next;
	    if (!area)
		break;
	}
	assert (area->state != ExaOffscreenAvail);
	(void) ExaOffscreenKickOut (pScreen, area);
	ExaOffscreenValidate (pScreen);
d311 2
a312 2
    ExaOffscreenValidate (pScreen);
    ExaOffscreenFini (pScreen);
d317 1
a317 1
ExaOffscreenEjectPixmaps (ScreenPtr pScreen)
d319 1
a319 1
    ExaScreenPriv (pScreen);
d321 1
a321 1
    ExaOffscreenValidate (pScreen);
d323 14
a336 17
    for (;;)
    {
	ExaOffscreenArea *area;

	for (area = pExaScr->info->offScreenAreas; area != NULL;
	     area = area->next)
	{
	    if (area->state == ExaOffscreenRemovable &&
		area->save == exaPixmapSave)
	    {
		(void) ExaOffscreenKickOut (pScreen, area);
		ExaOffscreenValidate (pScreen);
		break;
	    }
	}
	if (area == NULL)
	    break;
d338 1
a338 1
    ExaOffscreenValidate (pScreen);
d342 1
a342 1
ExaOffscreenSwapIn (ScreenPtr pScreen)
d344 1
a344 1
    exaOffscreenInit (pScreen);
d363 1
a363 1
exaEnableDisableFBAccess (int index, Bool enable)
d366 2
a367 1
    ExaScreenPriv (pScreen);
d370 1
a370 1
	return;
d373 5
a377 5
	if (pExaScr->info->exa_minor < 1)
	    ExaOffscreenSwapOut (pScreen);
	else
	    ExaOffscreenEjectPixmaps (pScreen);
	pExaScr->swappedOut = TRUE;
d379 1
a379 1
    
d381 3
a383 3
	if (pExaScr->info->exa_minor < 1)
	    ExaOffscreenSwapIn (pScreen);
	pExaScr->swappedOut = FALSE;
d389 1
a389 1
ExaOffscreenMerge (ExaScreenPrivPtr pExaScr, ExaOffscreenArea *area)
d391 1
a391 1
    ExaOffscreenArea	*next = area->next;
d398 1
a398 1
	area->next->prev = area;
d400 1
a400 1
	pExaScr->info->offScreenAreas->prev = area;
d420 1
a420 1
exaOffscreenFree (ScreenPtr pScreen, ExaOffscreenArea *area)
d423 2
a424 2
    ExaOffscreenArea	*next = area->next;
    ExaOffscreenArea	*prev;
d426 3
a428 3
    DBG_OFFSCREEN (("Free 0x%x -> 0x%x (0x%x)\n", area->size,
		    area->base_offset, area->offset));
    ExaOffscreenValidate (pScreen);
d438 1
a438 1
	prev = NULL;
d440 1
a440 1
	prev = area->prev;
d446 1
a446 1
	ExaOffscreenMerge (pExaScr, area);
d449 3
a451 4
    if (prev && prev->state == ExaOffscreenAvail)
    {
	area = prev;
	ExaOffscreenMerge (pExaScr, area);
d454 1
a454 1
    ExaOffscreenValidate (pScreen);
d460 1
a460 1
ExaOffscreenMarkUsed (PixmapPtr pPixmap)
d462 2
a463 2
    ExaPixmapPriv (pPixmap);
    ExaScreenPriv (pPixmap->drawable.pScreen);
d466 1
a466 1
	return;
d476 2
a477 2
_X_HIDDEN ExaOffscreenArea*
ExaOffscreenDefragment (ScreenPtr pScreen)
d479 1
a479 1
    ExaScreenPriv (pScreen);
d488 1
a488 1
	return NULL;
d490 1
a490 1
    pExaDstPix = ExaGetPixmapPriv (pDstPix);
d494 105
a598 111
	 area != pExaScr->info->offScreenAreas;
	 )
    {
	ExaOffscreenArea *prev = area->prev;
	PixmapPtr pSrcPix;
	ExaPixmapPrivPtr pExaSrcPix;
	Bool save_use_gpu_copy;
	int save_pitch;

	if (area->state != ExaOffscreenAvail ||
	    prev->state == ExaOffscreenLocked ||
	    (prev->state == ExaOffscreenRemovable &&
	     prev->save != exaPixmapSave)) {
	    area = prev;
	    continue;
	}

	if (prev->state == ExaOffscreenAvail) {
	    if (area == largest_available) {
		largest_available = prev;
		largest_size += prev->size;
	    }
	    area = prev;
	    ExaOffscreenMerge (pExaScr, area);
	    continue;
	}

	if (area->size > largest_size) {
	    largest_available = area;
	    largest_size = area->size;
	}

	pSrcPix = prev->privData;
	pExaSrcPix = ExaGetPixmapPriv (pSrcPix);

	pExaDstPix->fb_ptr = pExaScr->info->memoryBase +
	    area->base_offset + area->size - prev->size + prev->base_offset -
	    prev->offset;
	pExaDstPix->fb_ptr -= (unsigned long)pExaDstPix->fb_ptr % prev->align;

	if (pExaDstPix->fb_ptr <= pExaSrcPix->fb_ptr) {
	    area = prev;
	    continue;
	}

	if (!(pExaScr->info->flags & EXA_SUPPORTS_OFFSCREEN_OVERLAPS) &&
	    (pExaSrcPix->fb_ptr + prev->size) > pExaDstPix->fb_ptr) {
	    area = prev;
	    continue;
	}

	save_use_gpu_copy = pExaSrcPix->use_gpu_copy;
	save_pitch = pSrcPix->devKind;

	pExaSrcPix->use_gpu_copy = TRUE;
	pSrcPix->devKind = pExaSrcPix->fb_pitch;

	pDstPix->drawable.width = pSrcPix->drawable.width;
	pDstPix->devKind = pSrcPix->devKind;
	pDstPix->drawable.height = pSrcPix->drawable.height;
	pDstPix->drawable.depth = pSrcPix->drawable.depth;
	pDstPix->drawable.bitsPerPixel = pSrcPix->drawable.bitsPerPixel;

	if (!pExaScr->info->PrepareCopy (pSrcPix, pDstPix, -1, -1, GXcopy, ~0)) {
	    pExaSrcPix->use_gpu_copy = save_use_gpu_copy;
	    pSrcPix->devKind = save_pitch;
	    area = prev;
	    continue;
	}

	pExaScr->info->Copy (pDstPix, 0, 0, 0, 0, pDstPix->drawable.width,
			     pDstPix->drawable.height);
	pExaScr->info->DoneCopy (pDstPix);
	exaMarkSync (pScreen);

	DBG_OFFSCREEN(("Before swap: prev=0x%08x-0x%08x-0x%08x area=0x%08x-0x%08x-0x%08x\n",
		       prev->base_offset, prev->offset, prev->base_offset + prev->size,
		       area->base_offset, area->offset, area->base_offset + area->size));

	/* Calculate swapped area offsets and sizes */
	area->base_offset = prev->base_offset;
	area->offset = area->base_offset;
	prev->offset += pExaDstPix->fb_ptr - pExaSrcPix->fb_ptr;
	assert(prev->offset >= pExaScr->info->offScreenBase &&
	       prev->offset < pExaScr->info->memorySize);
	prev->base_offset = prev->offset;
	if (area->next)
	    prev->size = area->next->base_offset - prev->base_offset;
	else
	    prev->size = pExaScr->info->memorySize - prev->base_offset;
	area->size = prev->base_offset - area->base_offset;

	DBG_OFFSCREEN(("After swap: area=0x%08x-0x%08x-0x%08x prev=0x%08x-0x%08x-0x%08x\n",
		       area->base_offset, area->offset, area->base_offset + area->size,
		       prev->base_offset, prev->offset, prev->base_offset + prev->size));

	/* Swap areas in list */
	if (area->next)
	    area->next->prev = prev;
	else
	    pExaScr->info->offScreenAreas->prev = prev;
	if (prev->prev->next)
	    prev->prev->next = area;
	else
	    pExaScr->info->offScreenAreas = area;
	prev->next = area->next;
	area->next = prev;
	area->prev = prev->prev;
	prev->prev = area;
	if (!area->prev->next)
	    pExaScr->info->offScreenAreas = area;
d601 2
a602 2
	if (prev->prev == prev || prev->next == prev)
	    ErrorF("Whoops, prev points to itself!\n");
d604 2
a605 2
	if (area->prev == area || area->next == area)
	    ErrorF("Whoops, area points to itself!\n");
d608 3
a610 3
	pExaSrcPix->fb_ptr = pExaDstPix->fb_ptr;
	pExaSrcPix->use_gpu_copy = save_use_gpu_copy;
	pSrcPix->devKind = save_pitch;
d621 1
a621 1
	return area;
d635 1
a635 1
exaOffscreenInit (ScreenPtr pScreen)
d637 1
a637 1
    ExaScreenPriv (pScreen);
d641 1
a641 1
    area = malloc(sizeof (ExaOffscreenArea));
d644 1
a644 1
	return FALSE;
d662 1
a662 1
    ExaOffscreenValidate (pScreen);
d668 1
a668 1
ExaOffscreenFini (ScreenPtr pScreen)
d670 1
a670 1
    ExaScreenPriv (pScreen);
d674 3
a676 4
    while ((area = pExaScr->info->offScreenAreas))
    {
	pExaScr->info->offScreenAreas = area->next;
	free(area);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d248 1
a248 1
	ExaOffscreenArea   *new_area = xalloc (sizeof (ExaOffscreenArea));
d411 1
a411 1
    xfree (next);
d658 1
a658 1
    area = xalloc (sizeof (ExaOffscreenArea));
d694 1
a694 1
	xfree (area);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d96 1
a96 1
    int avail, real_size, tmp;
d114 1
a114 4
	real_size = size;
	tmp = begin->base_offset % align;
	if (tmp)
	    real_size += (align - tmp);
d172 1
a172 1
    int tmp, real_size = 0;
d205 1
a205 4
	real_size = size;
	tmp = area->base_offset % align;
	if (tmp)
	    real_size += (align - tmp);
d210 3
d228 1
a228 4
	real_size = size;
	tmp = area->base_offset % align;
	if (tmp)
	    real_size += (align - tmp);
d251 2
a252 1
	new_area->base_offset = area->base_offset + real_size;
d254 1
d260 8
a267 2
	new_area->next = area->next;
	area->next = new_area;
d269 3
a271 1
    }
d284 1
d379 3
d399 1
a399 1
ExaOffscreenMerge (ExaOffscreenArea *area)
d407 4
d412 2
d450 3
a452 3
	for (prev = pExaScr->info->offScreenAreas; prev; prev = prev->next)
	    if (prev->next == area)
		break;
d456 1
a456 1
	ExaOffscreenMerge (area);
d462 1
a462 1
	ExaOffscreenMerge (area);
d483 161
d666 1
d670 1
d677 1
@


1.1
log
@Initial revision
@
text
@d24 3
a26 5
 * This allocator allocates blocks of memory by maintaining a list of areas
 * and a score for each area.  As an area is marked used, its score is
 * incremented, and periodically all of the areas have their scores decayed by
 * a fraction.  When allocating, the contiguous block of areas with the minimum
 * score is found and evicted in order to make room for the new allocation.
d55 1
a55 1
	    assert (prev->base_offset + prev->area.size == area->base_offset);
d72 76
d158 4
a161 4
 * Allocates offscreen memory from the device associated with pScreen.  size and
 * align deteremine where and how large the allocated area is, and locked will
 * mark whether it should be held in card memory.  privdata may be any pointer
 * for the save callback when the area is removed.
d163 3
a165 4
 * Note that locked areas do get evicted on VT switch, because during that time
 * all offscreen memory becomes inaccessible.  This may change in the future,
 * but drivers should be aware of this and provide a callback to mark that their
 * locked allocation was evicted, and then restore it if necessary on EnterVT.
d173 1
a173 1
    ExaOffscreenArea *area, *begin, *best;
d175 1
a175 1
    int tmp, real_size = 0, best_score;
d220 1
a220 5
	/*
	 * Kick out existing users to make space.
	 *
	 * First, locate a region which can hold the desired object.
	 */
a221 41
	/* prev points at the first object to boot */
	best = NULL;
	best_score = INT_MAX;
	for (begin = pExaScr->info->offScreenAreas; begin != NULL;
	     begin = begin->next)
	{
	    int avail, score;
	    ExaOffscreenArea *scan;

	    if (begin->state == ExaOffscreenLocked)
		continue;

	    /* adjust size needed to account for alignment loss for this area */
	    real_size = size;
	    tmp = begin->base_offset % align;
	    if (tmp)
		real_size += (align - tmp);

	    avail = 0;
	    score = 0;
	    /* now see if we can make room here, and how "costly" it'll be. */
	    for (scan = begin; scan != NULL; scan = scan->next)
	    {
		if (scan->state == ExaOffscreenLocked) {
		    /* Can't make room here, start after this locked area. */
		    begin = scan;
		    break;
		}
		/* Score should only be non-zero for ExaOffscreenRemovable */
		score += scan->score;
		avail += scan->size;
		if (avail >= real_size)
		    break;
	    }
	    /* Is it the best option we've found so far? */
	    if (avail >= real_size && score < best_score) {
		best = begin;
		best_score = score;
	    }
	}
	area = best;
d262 2
a263 1
	new_area->score = 0;
d277 1
a277 1
    area->score = 0;
d288 3
d318 29
d353 15
d374 5
a378 2
    if (!enable) {
	ExaOffscreenSwapOut (pScreen);
d380 5
a384 2
    } else {
	ExaOffscreenSwapIn (pScreen);
d428 2
a429 1
    area->score = 0;
a460 1
    static int iter = 0;
d462 1
a462 1
    if (!pExaPixmap->area)
d465 1
a465 11
    /* The numbers here are arbitrary.  We may want to tune these. */
    pExaPixmap->area->score += 100;
    if (++iter == 10) {
	ExaOffscreenArea *area;
	for (area = pExaScr->info->offScreenAreas; area != NULL;
	     area = area->next)
	{
	    if (area->state == ExaOffscreenRemovable)
		area->score = (area->score * 7) / 8;
	}
    }
d494 2
a495 1
    area->score = 0;
d499 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d57 1
a57 1
	    assert (prev->base_offset + prev->size == area->base_offset);
d84 4
a87 4
 * Allocates offscreen memory from the device associated with pScreen.  size
 * and align deteremine where and how large the allocated area is, and locked
 * will mark whether it should be held in card memory.  privdata may be any
 * pointer for the save callback when the area is removed.
d89 4
a92 3
 * Note that locked areas do get evicted on VT switch unless the driver
 * requested version 2.1 or newer behavior.  In that case, the save callback is
 * still called.
a258 3
/**
 * Ejects all offscreen areas, and uninitializes the offscreen memory manager.
 */
a285 29
/** Ejects all pixmaps managed by EXA. */
static void
ExaOffscreenEjectPixmaps (ScreenPtr pScreen)
{
    ExaScreenPriv (pScreen);

    ExaOffscreenValidate (pScreen);
    /* loop until a single free area spans the space */
    for (;;)
    {
	ExaOffscreenArea *area;

	for (area = pExaScr->info->offScreenAreas; area != NULL;
	     area = area->next)
	{
	    if (area->state == ExaOffscreenRemovable &&
		area->save == exaPixmapSave)
	    {
		(void) ExaOffscreenKickOut (pScreen, area);
		ExaOffscreenValidate (pScreen);
		break;
	    }
	}
	if (area == NULL)
	    break;
    }
    ExaOffscreenValidate (pScreen);
}

a291 15
/**
 * Prepares EXA for disabling of FB access, or restoring it.
 *
 * In version 2.1, the disabling results in pixmaps being ejected, while other
 * allocations remain.  With this plus the prevention of migration while
 * swappedOut is set, EXA by itself should not cause any access of the
 * framebuffer to occur while swapped out.  Any remaining issues are the
 * responsibility of the driver.
 *
 * Prior to version 2.1, all allocations, including locked ones, are ejected
 * when access is disabled, and the allocator is torn down while swappedOut
 * is set.  This is more drastic, and caused implementation difficulties for
 * many drivers that could otherwise handle the lack of FB access while
 * swapped out.
 */
d298 2
a299 5
    if (!enable && pExaScr->disableFbCount++ == 0) {
	if (pExaScr->info->exa_minor < 1)
	    ExaOffscreenSwapOut (pScreen);
	else
	    ExaOffscreenEjectPixmaps (pScreen);
d301 2
a302 5
    }
    
    if (enable && --pExaScr->disableFbCount == 0) {
	if (pExaScr->info->exa_minor < 1)
	    ExaOffscreenSwapIn (pScreen);
d380 1
a380 1
    if (!pExaPixmap || !pExaPixmap->area)
a392 1
	iter = 0;
@

