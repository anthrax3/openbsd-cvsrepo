head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.6
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.8
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.45;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.45;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.06.32;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *
 * Copyright (C) 2000 Keith Packard
 *               2004 Eric Anholt
 *               2005 Zack Rusin
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of copyright holders not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission. Copyright holders make no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/** @@file
 * This is the header containing the public API of EXA for exa drivers.
 */

#ifndef EXA_H
#define EXA_H

#include "scrnintstr.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "gcstruct.h"
#include "picturestr.h"
#include "fb.h"

#define EXA_VERSION_MAJOR   2
#define EXA_VERSION_MINOR   6
#define EXA_VERSION_RELEASE 0

typedef struct _ExaOffscreenArea ExaOffscreenArea;

typedef void (*ExaOffscreenSaveProc) (ScreenPtr pScreen,
                                      ExaOffscreenArea * area);

typedef enum _ExaOffscreenState {
    ExaOffscreenAvail,
    ExaOffscreenRemovable,
    ExaOffscreenLocked
} ExaOffscreenState;

struct _ExaOffscreenArea {
    int base_offset;            /* allocation base */
    int offset;                 /* aligned offset */
    int size;                   /* total allocation size */
    unsigned last_use;
    void *privData;

    ExaOffscreenSaveProc save;

    ExaOffscreenState state;

    ExaOffscreenArea *next;

    unsigned eviction_cost;

    ExaOffscreenArea *prev;     /* Double-linked list for defragmentation */
    int align;                  /* required alignment */
};

/**
 * The ExaDriver structure is allocated through exaDriverAlloc(), and then
 * fllled in by drivers.
 */
typedef struct _ExaDriver {
    /**
     * exa_major and exa_minor should be set by the driver to the version of
     * EXA which the driver was compiled for (or configures itself at runtime
     * to support).  This allows EXA to extend the structure for new features
     * without breaking ABI for drivers compiled against older versions.
     */
    int exa_major, exa_minor;

    /**
     * memoryBase is the address of the beginning of framebuffer memory.
     * The visible screen should be within memoryBase to memoryBase +
     * memorySize.
     */
    CARD8 *memoryBase;

    /**
     * offScreenBase is the offset from memoryBase of the beginning of the area
     * to be managed by EXA's linear offscreen memory manager.
     *
     * In XFree86 DDX drivers, this is probably:
     *   (pScrn->displayWidth * cpp * pScrn->virtualY)
     */
    unsigned long offScreenBase;

    /**
     * memorySize is the length (in bytes) of framebuffer memory beginning
     * from memoryBase.
     *
     * The offscreen memory manager will manage the area beginning at
     * (memoryBase + offScreenBase), with a length of (memorySize -
     * offScreenBase)
     *
     * In XFree86 DDX drivers, this is probably (pScrn->videoRam * 1024)
     */
    unsigned long memorySize;

    /**
     * pixmapOffsetAlign is the byte alignment necessary for pixmap offsets
     * within framebuffer.
     *
     * Hardware typically has a required alignment of offsets, which may or may
     * not be a power of two.  EXA will ensure that pixmaps managed by the
     * offscreen memory manager meet this alignment requirement.
     */
    int pixmapOffsetAlign;

    /**
     * pixmapPitchAlign is the byte alignment necessary for pixmap pitches
     * within the framebuffer.
     *
     * Hardware typically has a required alignment of pitches for acceleration.
     * For 3D hardware, Composite acceleration often requires that source and
     * mask pixmaps (textures) have a power-of-two pitch, which can be demanded
     * using EXA_OFFSCREEN_ALIGN_POT.  These pitch requirements only apply to
     * pixmaps managed by the offscreen memory manager.  Thus, it is up to the
     * driver to ensure that the visible screen has an appropriate pitch for
     * acceleration.
     */
    int pixmapPitchAlign;

    /**
     * The flags field is bitfield of boolean values controlling EXA's behavior.
     *
     * The flags in clude EXA_OFFSCREEN_PIXMAPS, EXA_OFFSCREEN_ALIGN_POT, and
     * EXA_TWO_BITBLT_DIRECTIONS.
     */
    int flags;

    /** @@{ */
    /**
     * maxX controls the X coordinate limitation for rendering from the card.
     * The driver should never receive a request for rendering beyond maxX
     * in the X direction from the origin of a pixmap.
     */
    int maxX;

    /**
     * maxY controls the Y coordinate limitation for rendering from the card.
     * The driver should never receive a request for rendering beyond maxY
     * in the Y direction from the origin of a pixmap.
     */
    int maxY;
    /** @@} */

    /* private */
    ExaOffscreenArea *offScreenAreas;
    Bool needsSync;
    int lastMarker;

    /** @@name Solid
     * @@{
     */
    /**
     * PrepareSolid() sets up the driver for doing a solid fill.
     * @@param pPixmap Destination pixmap
     * @@param alu raster operation
     * @@param planemask write mask for the fill
     * @@param fg "foreground" color for the fill
     *
     * This call should set up the driver for doing a series of solid fills
     * through the Solid() call.  The alu raster op is one of the GX*
     * graphics functions listed in X.h, and typically maps to a similar
     * single-byte "ROP" setting in all hardware.  The planemask controls
     * which bits of the destination should be affected, and will only represent
     * the bits up to the depth of pPixmap.  The fg is the pixel value of the
     * foreground color referred to in ROP descriptions.
     *
     * Note that many drivers will need to store some of the data in the driver
     * private record, for sending to the hardware with each drawing command.
     *
     * The PrepareSolid() call is required of all drivers, but it may fail for any
     * reason.  Failure results in a fallback to software rendering.
     */
    Bool (*PrepareSolid) (PixmapPtr pPixmap,
                          int alu, Pixel planemask, Pixel fg);

    /**
     * Solid() performs a solid fill set up in the last PrepareSolid() call.
     *
     * @@param pPixmap destination pixmap
     * @@param x1 left coordinate
     * @@param y1 top coordinate
     * @@param x2 right coordinate
     * @@param y2 bottom coordinate
     *
     * Performs the fill set up by the last PrepareSolid() call, covering the
     * area from (x1,y1) to (x2,y2) in pPixmap.  Note that the coordinates are
     * in the coordinate space of the destination pixmap, so the driver will
     * need to set up the hardware's offset and pitch for the destination
     * coordinates according to the pixmap's offset and pitch within
     * framebuffer.  This likely means using exaGetPixmapOffset() and
     * exaGetPixmapPitch().
     *
     * This call is required if PrepareSolid() ever succeeds.
     */
    void (*Solid) (PixmapPtr pPixmap, int x1, int y1, int x2, int y2);

    /**
     * DoneSolid() finishes a set of solid fills.
     *
     * @@param pPixmap destination pixmap.
     *
     * The DoneSolid() call is called at the end of a series of consecutive
     * Solid() calls following a successful PrepareSolid().  This allows drivers
     * to finish up emitting drawing commands that were buffered, or clean up
     * state from PrepareSolid().
     *
     * This call is required if PrepareSolid() ever succeeds.
     */
    void (*DoneSolid) (PixmapPtr pPixmap);
    /** @@} */

    /** @@name Copy
     * @@{
     */
    /**
     * PrepareCopy() sets up the driver for doing a copy within video
     * memory.
     *
     * @@param pSrcPixmap source pixmap
     * @@param pDstPixmap destination pixmap
     * @@param dx X copy direction
     * @@param dy Y copy direction
     * @@param alu raster operation
     * @@param planemask write mask for the fill
     *
     * This call should set up the driver for doing a series of copies from the
     * the pSrcPixmap to the pDstPixmap.  The dx flag will be positive if the
     * hardware should do the copy from the left to the right, and dy will be
     * positive if the copy should be done from the top to the bottom.  This
     * is to deal with self-overlapping copies when pSrcPixmap == pDstPixmap.
     * If your hardware can only support blits that are (left to right, top to
     * bottom) or (right to left, bottom to top), then you should set
     * #EXA_TWO_BITBLT_DIRECTIONS, and EXA will break down Copy operations to
     * ones that meet those requirements.  The alu raster op is one of the GX*
     * graphics functions listed in X.h, and typically maps to a similar
     * single-byte "ROP" setting in all hardware.  The planemask controls which
     * bits of the destination should be affected, and will only represent the
     * bits up to the depth of pPixmap.
     *
     * Note that many drivers will need to store some of the data in the driver
     * private record, for sending to the hardware with each drawing command.
     *
     * The PrepareCopy() call is required of all drivers, but it may fail for any
     * reason.  Failure results in a fallback to software rendering.
     */
    Bool (*PrepareCopy) (PixmapPtr pSrcPixmap,
                         PixmapPtr pDstPixmap,
                         int dx, int dy, int alu, Pixel planemask);

    /**
     * Copy() performs a copy set up in the last PrepareCopy call.
     *
     * @@param pDstPixmap destination pixmap
     * @@param srcX source X coordinate
     * @@param srcY source Y coordinate
     * @@param dstX destination X coordinate
     * @@param dstY destination Y coordinate
     * @@param width width of the rectangle to be copied
     * @@param height height of the rectangle to be copied.
     *
     * Performs the copy set up by the last PrepareCopy() call, copying the
     * rectangle from (srcX, srcY) to (srcX + width, srcY + width) in the source
     * pixmap to the same-sized rectangle at (dstX, dstY) in the destination
     * pixmap.  Those rectangles may overlap in memory, if
     * pSrcPixmap == pDstPixmap.  Note that this call does not receive the
     * pSrcPixmap as an argument -- if it's needed in this function, it should
     * be stored in the driver private during PrepareCopy().  As with Solid(),
     * the coordinates are in the coordinate space of each pixmap, so the driver
     * will need to set up source and destination pitches and offsets from those
     * pixmaps, probably using exaGetPixmapOffset() and exaGetPixmapPitch().
     *
     * This call is required if PrepareCopy ever succeeds.
     */
    void (*Copy) (PixmapPtr pDstPixmap,
                  int srcX,
                  int srcY, int dstX, int dstY, int width, int height);

    /**
     * DoneCopy() finishes a set of copies.
     *
     * @@param pPixmap destination pixmap.
     *
     * The DoneCopy() call is called at the end of a series of consecutive
     * Copy() calls following a successful PrepareCopy().  This allows drivers
     * to finish up emitting drawing commands that were buffered, or clean up
     * state from PrepareCopy().
     *
     * This call is required if PrepareCopy() ever succeeds.
     */
    void (*DoneCopy) (PixmapPtr pDstPixmap);
    /** @@} */

    /** @@name Composite
     * @@{
     */
    /**
     * CheckComposite() checks to see if a composite operation could be
     * accelerated.
     *
     * @@param op Render operation
     * @@param pSrcPicture source Picture
     * @@param pMaskPicture mask picture
     * @@param pDstPicture destination Picture
     *
     * The CheckComposite() call checks if the driver could handle acceleration
     * of op with the given source, mask, and destination pictures.  This allows
     * drivers to check source and destination formats, supported operations,
     * transformations, and component alpha state, and send operations it can't
     * support to software rendering early on.  This avoids costly pixmap
     * migration to the wrong places when the driver can't accelerate
     * operations.  Note that because migration hasn't happened, the driver
     * can't know during CheckComposite() what the offsets and pitches of the
     * pixmaps are going to be.
     *
     * See PrepareComposite() for more details on likely issues that drivers
     * will have in accelerating Composite operations.
     *
     * The CheckComposite() call is recommended if PrepareComposite() is
     * implemented, but is not required.
     */
    Bool (*CheckComposite) (int op,
                            PicturePtr pSrcPicture,
                            PicturePtr pMaskPicture, PicturePtr pDstPicture);

    /**
     * PrepareComposite() sets up the driver for doing a Composite operation
     * described in the Render extension protocol spec.
     *
     * @@param op Render operation
     * @@param pSrcPicture source Picture
     * @@param pMaskPicture mask picture
     * @@param pDstPicture destination Picture
     * @@param pSrc source pixmap
     * @@param pMask mask pixmap
     * @@param pDst destination pixmap
     *
     * This call should set up the driver for doing a series of Composite
     * operations, as described in the Render protocol spec, with the given
     * pSrcPicture, pMaskPicture, and pDstPicture.  The pSrc, pMask, and
     * pDst are the pixmaps containing the pixel data, and should be used for
     * setting the offset and pitch used for the coordinate spaces for each of
     * the Pictures.
     *
     * Notes on interpreting Picture structures:
     * - The Picture structures will always have a valid pDrawable.
     * - The Picture structures will never have alphaMap set.
     * - The mask Picture (and therefore pMask) may be NULL, in which case the
     *   operation is simply src OP dst instead of src IN mask OP dst, and
     *   mask coordinates should be ignored.
     * - pMarkPicture may have componentAlpha set, which greatly changes
     *   the behavior of the Composite operation.  componentAlpha has no effect
     *   when set on pSrcPicture or pDstPicture.
     * - The source and mask Pictures may have a transformation set
     *   (Picture->transform != NULL), which means that the source coordinates
     *   should be transformed by that transformation, resulting in scaling,
     *   rotation, etc.  The PictureTransformPoint() call can transform
     *   coordinates for you.  Transforms have no effect on Pictures when used
     *   as a destination.
     * - The source and mask pictures may have a filter set.  PictFilterNearest
     *   and PictFilterBilinear are defined in the Render protocol, but others
     *   may be encountered, and must be handled correctly (usually by
     *   PrepareComposite failing, and falling back to software).  Filters have
     *   no effect on Pictures when used as a destination.
     * - The source and mask Pictures may have repeating set, which must be
     *   respected.  Many chipsets will be unable to support repeating on
     *   pixmaps that have a width or height that is not a power of two.
     *
     * If your hardware can't support source pictures (textures) with
     * non-power-of-two pitches, you should set #EXA_OFFSCREEN_ALIGN_POT.
     *
     * Note that many drivers will need to store some of the data in the driver
     * private record, for sending to the hardware with each drawing command.
     *
     * The PrepareComposite() call is not required.  However, it is highly
     * recommended for performance of antialiased font rendering and performance
     * of cairo applications.  Failure results in a fallback to software
     * rendering.
     */
    Bool (*PrepareComposite) (int op,
                              PicturePtr pSrcPicture,
                              PicturePtr pMaskPicture,
                              PicturePtr pDstPicture,
                              PixmapPtr pSrc, PixmapPtr pMask, PixmapPtr pDst);

    /**
     * Composite() performs a Composite operation set up in the last
     * PrepareComposite() call.
     *
     * @@param pDstPixmap destination pixmap
     * @@param srcX source X coordinate
     * @@param srcY source Y coordinate
     * @@param maskX source X coordinate
     * @@param maskY source Y coordinate
     * @@param dstX destination X coordinate
     * @@param dstY destination Y coordinate
     * @@param width destination rectangle width
     * @@param height destination rectangle height
     *
     * Performs the Composite operation set up by the last PrepareComposite()
     * call, to the rectangle from (dstX, dstY) to (dstX + width, dstY + height)
     * in the destination Pixmap.  Note that if a transformation was set on
     * the source or mask Pictures, the source rectangles may not be the same
     * size as the destination rectangles and filtering.  Getting the coordinate
     * transformation right at the subpixel level can be tricky, and rendercheck
     * can test this for you.
     *
     * This call is required if PrepareComposite() ever succeeds.
     */
    void (*Composite) (PixmapPtr pDst,
                       int srcX,
                       int srcY,
                       int maskX,
                       int maskY, int dstX, int dstY, int width, int height);

    /**
     * DoneComposite() finishes a set of Composite operations.
     *
     * @@param pPixmap destination pixmap.
     *
     * The DoneComposite() call is called at the end of a series of consecutive
     * Composite() calls following a successful PrepareComposite().  This allows
     * drivers to finish up emitting drawing commands that were buffered, or
     * clean up state from PrepareComposite().
     *
     * This call is required if PrepareComposite() ever succeeds.
     */
    void (*DoneComposite) (PixmapPtr pDst);
    /** @@} */

    /**
     * UploadToScreen() loads a rectangle of data from src into pDst.
     *
     * @@param pDst destination pixmap
     * @@param x destination X coordinate.
     * @@param y destination Y coordinate
     * @@param width width of the rectangle to be copied
     * @@param height height of the rectangle to be copied
     * @@param src pointer to the beginning of the source data
     * @@param src_pitch pitch (in bytes) of the lines of source data.
     *
     * UploadToScreen() copies data in system memory beginning at src (with
     * pitch src_pitch) into the destination pixmap from (x, y) to
     * (x + width, y + height).  This is typically done with hostdata uploads,
     * where the CPU sets up a blit command on the hardware with instructions
     * that the blit data will be fed through some sort of aperture on the card.
     *
     * If UploadToScreen() is performed asynchronously, it is up to the driver
     * to call exaMarkSync().  This is in contrast to most other acceleration
     * calls in EXA.
     *
     * UploadToScreen() can aid in pixmap migration, but is most important for
     * the performance of exaGlyphs() (antialiased font drawing) by allowing
     * pipelining of data uploads, avoiding a sync of the card after each glyph.
     *
     * @@return TRUE if the driver successfully uploaded the data.  FALSE
     * indicates that EXA should fall back to doing the upload in software.
     *
     * UploadToScreen() is not required, but is recommended if Composite
     * acceleration is supported.
     */
    Bool (*UploadToScreen) (PixmapPtr pDst,
                            int x,
                            int y, int w, int h, char *src, int src_pitch);

    /**
     * UploadToScratch() is no longer used and will be removed next time the EXA
     * major version needs to be bumped.
     */
    Bool (*UploadToScratch) (PixmapPtr pSrc, PixmapPtr pDst);

    /**
     * DownloadFromScreen() loads a rectangle of data from pSrc into dst
     *
     * @@param pSrc source pixmap
     * @@param x source X coordinate.
     * @@param y source Y coordinate
     * @@param width width of the rectangle to be copied
     * @@param height height of the rectangle to be copied
     * @@param dst pointer to the beginning of the destination data
     * @@param dst_pitch pitch (in bytes) of the lines of destination data.
     *
     * DownloadFromScreen() copies data from offscreen memory in pSrc from
     * (x, y) to (x + width, y + height), to system memory starting at
     * dst (with pitch dst_pitch).  This would usually be done
     * using scatter-gather DMA, supported by a DRM call, or by blitting to AGP
     * and then synchronously reading from AGP.  Because the implementation
     * might be synchronous, EXA leaves it up to the driver to call
     * exaMarkSync() if DownloadFromScreen() was asynchronous.  This is in
     * contrast to most other acceleration calls in EXA.
     *
     * DownloadFromScreen() can aid in the largest bottleneck in pixmap
     * migration, which is the read from framebuffer when evicting pixmaps from
     * framebuffer memory.  Thus, it is highly recommended, even though
     * implementations are typically complicated.
     *
     * @@return TRUE if the driver successfully downloaded the data.  FALSE
     * indicates that EXA should fall back to doing the download in software.
     *
     * DownloadFromScreen() is not required, but is highly recommended.
     */
    Bool (*DownloadFromScreen) (PixmapPtr pSrc,
                                int x, int y,
                                int w, int h, char *dst, int dst_pitch);

    /**
     * MarkSync() requests that the driver mark a synchronization point,
     * returning an driver-defined integer marker which could be requested for
     * synchronization to later in WaitMarker().  This might be used in the
     * future to avoid waiting for full hardware stalls before accessing pixmap
     * data with the CPU, but is not important in the current incarnation of
     * EXA.
     *
     * Note that drivers should call exaMarkSync() when they have done some
     * acceleration, rather than their own MarkSync() handler, as otherwise EXA
     * will be unaware of the driver's acceleration and not sync to it during
     * fallbacks.
     *
     * MarkSync() is optional.
     */
    int (*MarkSync) (ScreenPtr pScreen);

    /**
     * WaitMarker() waits for all rendering before the given marker to have
     * completed.  If the driver does not implement MarkSync(), marker is
     * meaningless, and all rendering by the hardware should be completed before
     * WaitMarker() returns.
     *
     * Note that drivers should call exaWaitSync() to wait for all acceleration
     * to finish, as otherwise EXA will be unaware of the driver having
     * synchronized, resulting in excessive WaitMarker() calls.
     *
     * WaitMarker() is required of all drivers.
     */
    void (*WaitMarker) (ScreenPtr pScreen, int marker);

    /** @@{ */
    /**
     * PrepareAccess() is called before CPU access to an offscreen pixmap.
     *
     * @@param pPix the pixmap being accessed
     * @@param index the index of the pixmap being accessed.
     *
     * PrepareAccess() will be called before CPU access to an offscreen pixmap.
     * This can be used to set up hardware surfaces for byteswapping or
     * untiling, or to adjust the pixmap's devPrivate.ptr for the purpose of
     * making CPU access use a different aperture.
     *
     * The index is one of #EXA_PREPARE_DEST, #EXA_PREPARE_SRC,
     * #EXA_PREPARE_MASK, #EXA_PREPARE_AUX_DEST, #EXA_PREPARE_AUX_SRC, or
     * #EXA_PREPARE_AUX_MASK. Since only up to #EXA_NUM_PREPARE_INDICES pixmaps
     * will have PrepareAccess() called on them per operation, drivers can have
     * a small, statically-allocated space to maintain state for PrepareAccess()
     * and FinishAccess() in.  Note that PrepareAccess() is only called once per
     * pixmap and operation, regardless of whether the pixmap is used as a
     * destination and/or source, and the index may not reflect the usage.
     *
     * PrepareAccess() may fail.  An example might be the case of hardware that
     * can set up 1 or 2 surfaces for CPU access, but not 3.  If PrepareAccess()
     * fails, EXA will migrate the pixmap to system memory.
     * DownloadFromScreen() must be implemented and must not fail if a driver
     * wishes to fail in PrepareAccess().  PrepareAccess() must not fail when
     * pPix is the visible screen, because the visible screen can not be
     * migrated.
     *
     * @@return TRUE if PrepareAccess() successfully prepared the pixmap for CPU
     * drawing.
     * @@return FALSE if PrepareAccess() is unsuccessful and EXA should use
     * DownloadFromScreen() to migate the pixmap out.
     */
    Bool (*PrepareAccess) (PixmapPtr pPix, int index);

    /**
     * FinishAccess() is called after CPU access to an offscreen pixmap.
     *
     * @@param pPix the pixmap being accessed
     * @@param index the index of the pixmap being accessed.
     *
     * FinishAccess() will be called after finishing CPU access of an offscreen
     * pixmap set up by PrepareAccess().  Note that the FinishAccess() will not be
     * called if PrepareAccess() failed and the pixmap was migrated out.
     */
    void (*FinishAccess) (PixmapPtr pPix, int index);

    /**
     * PixmapIsOffscreen() is an optional driver replacement to
     * exaPixmapHasGpuCopy(). Set to NULL if you want the standard behaviour
     * of exaPixmapHasGpuCopy().
     *
     * @@param pPix the pixmap
     * @@return TRUE if the given drawable is in framebuffer memory.
     *
     * exaPixmapHasGpuCopy() is used to determine if a pixmap is in offscreen
     * memory, meaning that acceleration could probably be done to it, and that it
     * will need to be wrapped by PrepareAccess()/FinishAccess() when accessing it
     * with the CPU.
     *
     *
     */
    Bool (*PixmapIsOffscreen) (PixmapPtr pPix);

        /** @@name PrepareAccess() and FinishAccess() indices
	 * @@{
	 */
        /**
	 * EXA_PREPARE_DEST is the index for a pixmap that may be drawn to or
	 * read from.
	 */
#define EXA_PREPARE_DEST	0
        /**
	 * EXA_PREPARE_SRC is the index for a pixmap that may be read from
	 */
#define EXA_PREPARE_SRC		1
        /**
	 * EXA_PREPARE_SRC is the index for a second pixmap that may be read
	 * from.
	 */
#define EXA_PREPARE_MASK	2
        /**
	 * EXA_PREPARE_AUX* are additional indices for other purposes, e.g.
	 * separate alpha maps with Composite operations.
	 */
#define EXA_PREPARE_AUX_DEST	3
#define EXA_PREPARE_AUX_SRC	4
#define EXA_PREPARE_AUX_MASK	5
#define EXA_NUM_PREPARE_INDICES	6
        /** @@} */

    /**
     * maxPitchPixels controls the pitch limitation for rendering from
     * the card.
     * The driver should never receive a request for rendering a pixmap
     * that has a pitch (in pixels) beyond maxPitchPixels.
     *
     * Setting this field is optional -- if your hardware doesn't have
     * a pitch limitation in pixels, don't set this. If neither this value
     * nor maxPitchBytes is set, then maxPitchPixels is set to maxX.
     * If set, it must not be smaller than maxX.
     *
     * @@sa maxPitchBytes
     */
    int maxPitchPixels;

    /**
     * maxPitchBytes controls the pitch limitation for rendering from
     * the card.
     * The driver should never receive a request for rendering a pixmap
     * that has a pitch (in bytes) beyond maxPitchBytes.
     *
     * Setting this field is optional -- if your hardware doesn't have
     * a pitch limitation in bytes, don't set this.
     * If set, it must not be smaller than maxX * 4.
     * There's no default value for maxPitchBytes.
     *
     * @@sa maxPitchPixels
     */
    int maxPitchBytes;

    /* Hooks to allow driver to its own pixmap memory management */
    void *(*CreatePixmap) (ScreenPtr pScreen, int size, int align);
    void (*DestroyPixmap) (ScreenPtr pScreen, void *driverPriv);
    /**
     * Returning a pixmap with non-NULL devPrivate.ptr implies a pixmap which is
     * not offscreen, which will never be accelerated and Prepare/FinishAccess won't
     * be called.
     */
    Bool (*ModifyPixmapHeader) (PixmapPtr pPixmap, int width, int height,
                                int depth, int bitsPerPixel, int devKind,
                                void *pPixData);

    /* hooks for drivers with tiling support:
     * driver MUST fill out new_fb_pitch with valid pitch of pixmap
     */
    void *(*CreatePixmap2) (ScreenPtr pScreen, int width, int height,
                            int depth, int usage_hint, int bitsPerPixel,
                            int *new_fb_pitch);
    /** @@} */
    Bool (*SharePixmapBacking)(PixmapPtr pPixmap, ScreenPtr slave, void **handle_p);

    Bool (*SetSharedPixmapBacking)(PixmapPtr pPixmap, void *handle);

} ExaDriverRec, *ExaDriverPtr;

/** @@name EXA driver flags
 * @@{
 */
/**
 * EXA_OFFSCREEN_PIXMAPS indicates to EXA that the driver can support
 * offscreen pixmaps.
 */
#define EXA_OFFSCREEN_PIXMAPS		(1 << 0)

/**
 * EXA_OFFSCREEN_ALIGN_POT indicates to EXA that the driver needs pixmaps
 * to have a power-of-two pitch.
 */
#define EXA_OFFSCREEN_ALIGN_POT		(1 << 1)

/**
 * EXA_TWO_BITBLT_DIRECTIONS indicates to EXA that the driver can only
 * support copies that are (left-to-right, top-to-bottom) or
 * (right-to-left, bottom-to-top).
 */
#define EXA_TWO_BITBLT_DIRECTIONS	(1 << 2)

/**
 * EXA_HANDLES_PIXMAPS indicates to EXA that the driver can handle
 * all pixmap addressing and migration.
 */
#define EXA_HANDLES_PIXMAPS             (1 << 3)

/**
 * EXA_SUPPORTS_PREPARE_AUX indicates to EXA that the driver can handle the
 * EXA_PREPARE_AUX* indices in the Prepare/FinishAccess hooks. If there are no
 * such hooks, this flag has no effect.
 */
#define EXA_SUPPORTS_PREPARE_AUX        (1 << 4)

/**
 * EXA_SUPPORTS_OFFSCREEN_OVERLAPS indicates to EXA that the driver Copy hooks
 * can handle the source and destination occupying overlapping offscreen memory
 * areas. This allows the offscreen memory defragmentation code to defragment
 * areas where the defragmented position overlaps the fragmented position.
 *
 * Typically this is supported by traditional 2D engines but not by 3D engines.
 */
#define EXA_SUPPORTS_OFFSCREEN_OVERLAPS (1 << 5)

/**
 * EXA_MIXED_PIXMAPS will hide unacceleratable pixmaps from drivers and manage the
 * problem known software fallbacks like trapezoids. This only migrates pixmaps one way
 * into a driver pixmap and then pins it.
 */
#define EXA_MIXED_PIXMAPS (1 << 6)

/** @@} */

/* in exa.c */
extern _X_EXPORT ExaDriverPtr exaDriverAlloc(void);

extern _X_EXPORT Bool
 exaDriverInit(ScreenPtr pScreen, ExaDriverPtr pScreenInfo);

extern _X_EXPORT void
 exaDriverFini(ScreenPtr pScreen);

extern _X_EXPORT void
 exaMarkSync(ScreenPtr pScreen);
extern _X_EXPORT void
 exaWaitSync(ScreenPtr pScreen);

extern _X_EXPORT unsigned long
 exaGetPixmapOffset(PixmapPtr pPix);

extern _X_EXPORT unsigned long
 exaGetPixmapPitch(PixmapPtr pPix);

extern _X_EXPORT unsigned long
 exaGetPixmapSize(PixmapPtr pPix);

extern _X_EXPORT void *exaGetPixmapDriverPrivate(PixmapPtr p);

/* in exa_offscreen.c */
extern _X_EXPORT ExaOffscreenArea *exaOffscreenAlloc(ScreenPtr pScreen,
                                                     int size, int align,
                                                     Bool locked,
                                                     ExaOffscreenSaveProc save,
                                                     void *privData);

extern _X_EXPORT ExaOffscreenArea *exaOffscreenFree(ScreenPtr pScreen,
                                                    ExaOffscreenArea * area);

extern _X_EXPORT void
 ExaOffscreenMarkUsed(PixmapPtr pPixmap);

extern _X_EXPORT void
 exaEnableDisableFBAccess(ScreenPtr pScreen, Bool enable);

extern _X_EXPORT Bool
 exaDrawableIsOffscreen(DrawablePtr pDrawable);

/* in exa.c */
extern _X_EXPORT void
 exaMoveInPixmap(PixmapPtr pPixmap);

extern _X_EXPORT void
 exaMoveOutPixmap(PixmapPtr pPixmap);

/* in exa_unaccel.c */
extern _X_EXPORT CARD32
 exaGetPixmapFirstPixel(PixmapPtr pPixmap);

/**
 * Returns TRUE if the given planemask covers all the significant bits in the
 * pixel values for pDrawable.
 */
#define EXA_PM_IS_SOLID(_pDrawable, _pm) \
	(((_pm) & FbFullMask((_pDrawable)->depth)) == \
	 FbFullMask((_pDrawable)->depth))

#endif                          /* EXA_H */
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d236 1
a236 1
     * PrepareCopy() sets up the driver for doing a copy within video 
d474 1
a474 1
     * 
d515 1
a515 1
     * 
d707 1
a707 1
 * EXA_OFFSCREEN_PIXMAPS indicates to EXA that the driver can support 
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d61 1
a61 1
    pointer privData;
d688 1
a688 1
                                pointer pPixData);
d787 1
a787 1
                                                     pointer privData);
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d42 1
a42 1
#define EXA_VERSION_MINOR   5
d697 4
d796 1
a796 1
 exaEnableDisableFBAccess(int index, Bool enable);
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d47 2
a48 1
typedef void (*ExaOffscreenSaveProc) (ScreenPtr pScreen, ExaOffscreenArea *area);
d57 5
a61 5
    int                 base_offset;	/* allocation base */
    int                 offset;         /* aligned offset */
    int                 size;           /* total allocation size */
    unsigned            last_use;
    pointer             privData;
d65 1
a65 1
    ExaOffscreenState   state;
d67 1
a67 1
    ExaOffscreenArea    *next;
d69 1
a69 1
    unsigned            eviction_cost;
d71 2
a72 2
    ExaOffscreenArea    *prev;          /* Double-linked list for defragmentation */
    int                 align;          /* required alignment */
d93 1
a93 1
    CARD8         *memoryBase;
d102 1
a102 1
    unsigned long  offScreenBase;
d166 2
a167 2
    Bool              needsSync;
    int               lastMarker;
d193 2
a194 4
    Bool        (*PrepareSolid) (PixmapPtr      pPixmap,
                                 int            alu,
                                 Pixel          planemask,
                                 Pixel          fg);
d215 1
a215 1
    void        (*Solid) (PixmapPtr      pPixmap, int x1, int y1, int x2, int y2);
d229 1
a229 1
    void        (*DoneSolid) (PixmapPtr      pPixmap);
d266 3
a268 6
    Bool        (*PrepareCopy) (PixmapPtr       pSrcPixmap,
                                PixmapPtr       pDstPixmap,
                                int             dx,
                                int             dy,
                                int             alu,
                                Pixel           planemask);
d294 3
a296 7
    void        (*Copy) (PixmapPtr       pDstPixmap,
                         int    srcX,
                         int    srcY,
                         int    dstX,
                         int    dstY,
                         int    width,
                         int    height);
d310 1
a310 1
    void        (*DoneCopy) (PixmapPtr       pDstPixmap);
d341 3
a343 4
    Bool        (*CheckComposite) (int          op,
                                   PicturePtr   pSrcPicture,
                                   PicturePtr   pMaskPicture,
                                   PicturePtr   pDstPicture);
d399 5
a403 7
    Bool        (*PrepareComposite) (int                op,
                                     PicturePtr         pSrcPicture,
                                     PicturePtr         pMaskPicture,
                                     PicturePtr         pDstPicture,
                                     PixmapPtr          pSrc,
                                     PixmapPtr          pMask,
                                     PixmapPtr          pDst);
d429 5
a433 9
    void        (*Composite) (PixmapPtr         pDst,
                              int       srcX,
                              int        srcY,
                              int        maskX,
                              int        maskY,
                              int        dstX,
                              int        dstY,
                              int        width,
                              int        height);
d447 1
a447 1
    void        (*DoneComposite) (PixmapPtr         pDst);
d481 3
a483 7
    Bool        (*UploadToScreen) (PixmapPtr            pDst,
				   int                  x,
				   int                  y,
				   int                  w,
				   int                  h,
                                   char                 *src,
                                   int                  src_pitch);
d489 1
a489 2
    Bool        (*UploadToScratch) (PixmapPtr           pSrc,
                                    PixmapPtr           pDst);
d521 3
a523 4
    Bool (*DownloadFromScreen)(PixmapPtr pSrc,
                               int x,  int y,
                               int w,  int h,
                               char *dst,  int dst_pitch);
d540 1
a540 1
    int		(*MarkSync)   (ScreenPtr pScreen);
d554 1
a554 1
    void	(*WaitMarker) (ScreenPtr pScreen, int marker);
d590 1
a590 1
    Bool	(*PrepareAccess)(PixmapPtr pPix, int index);
d602 1
a602 1
    void	(*FinishAccess)(PixmapPtr pPix, int index);
d619 1
a619 1
    Bool	(*PixmapIsOffscreen)(PixmapPtr pPix);
d621 1
a621 1
	/** @@name PrepareAccess() and FinishAccess() indices
d624 1
a624 1
	/**
d627 3
a629 3
	 */ 
	#define EXA_PREPARE_DEST	0
	/**
d632 2
a633 2
	#define EXA_PREPARE_SRC		1
	/**
d637 2
a638 2
	#define EXA_PREPARE_MASK	2
	/**
d642 5
a646 5
	#define EXA_PREPARE_AUX_DEST	3
	#define EXA_PREPARE_AUX_SRC	4
	#define EXA_PREPARE_AUX_MASK	5
	#define EXA_NUM_PREPARE_INDICES	6
	/** @@} */
d679 2
a680 2
    void *(*CreatePixmap)(ScreenPtr pScreen, int size, int align);
    void (*DestroyPixmap)(ScreenPtr pScreen, void *driverPriv);
d686 3
a688 3
    Bool (*ModifyPixmapHeader)(PixmapPtr pPixmap, int width, int height,
                              int depth, int bitsPerPixel, int devKind,
                              pointer pPixData);
d693 3
a695 3
    void *(*CreatePixmap2)(ScreenPtr pScreen, int width, int height,
			   int depth, int usage_hint, int bitsPerPixel,
			   int *new_fb_pitch);
d754 1
a754 2
extern _X_EXPORT ExaDriverPtr
exaDriverAlloc(void);
d757 1
a757 2
exaDriverInit(ScreenPtr      pScreen,
              ExaDriverPtr   pScreenInfo);
d760 1
a760 1
exaDriverFini(ScreenPtr      pScreen);
d763 1
a763 1
exaMarkSync(ScreenPtr pScreen);
d765 1
a765 1
exaWaitSync(ScreenPtr pScreen);
d768 1
a768 1
exaGetPixmapOffset(PixmapPtr pPix);
d771 1
a771 1
exaGetPixmapPitch(PixmapPtr pPix);
d774 1
a774 4
exaGetPixmapSize(PixmapPtr pPix);

extern _X_EXPORT void *
exaGetPixmapDriverPrivate(PixmapPtr p);
d776 1
d779 5
a783 5
extern _X_EXPORT ExaOffscreenArea *
exaOffscreenAlloc(ScreenPtr pScreen, int size, int align,
                  Bool locked,
                  ExaOffscreenSaveProc save,
                  pointer privData);
d785 2
a786 2
extern _X_EXPORT ExaOffscreenArea *
exaOffscreenFree(ScreenPtr pScreen, ExaOffscreenArea *area);
d789 1
a789 1
ExaOffscreenMarkUsed (PixmapPtr pPixmap);
d792 1
a792 1
exaEnableDisableFBAccess (int index, Bool enable);
d795 1
a795 1
exaDrawableIsOffscreen (DrawablePtr pDrawable);
d799 1
a799 1
exaMoveInPixmap (PixmapPtr pPixmap);
d802 1
a802 2
exaMoveOutPixmap (PixmapPtr pPixmap);

d806 1
a806 2
exaGetPixmapFirstPixel (PixmapPtr pPixmap);

d816 1
a816 1
#endif /* EXA_H */
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d42 1
a42 1
#define EXA_VERSION_MINOR   4
d69 3
d505 2
a506 21
     * UploadToScratch() is used to upload a pixmap to a scratch area for
     * acceleration.
     *
     * @@param pSrc source pixmap in host memory
     * @@param pDst fake, scratch pixmap to be set up in offscreen memory.
     *
     * The UploadToScratch() call was added to support Xati before Xati had
     * support for hostdata uploads and before exaGlyphs() was written.  It
     * behaves incorrectly (uses an invalid pixmap as pDst),
     * and UploadToScreen() should be implemented instead.
     *
     * Drivers implementing UploadToScratch() had to set up space (likely in a
     * statically allocated area) in offscreen memory, copy pSrc to that
     * scratch area, and adust pDst->devKind for the pitch and
     * pDst->devPrivate.ptr for the pointer to that scratch area.  The driver
     * was responsible for syncing (as it was implemented using memcpy() in
     * Xati), and only the data from the last UploadToScratch() was guaranteed
     * to be valid at any given time.
     *
     * UploadToScratch() should not be implemented by drivers, and will likely
     * be removed in a future version of EXA.
d589 8
a596 8
     * The index is one of #EXA_PREPARE_DEST, #EXA_PREPARE_SRC, or
     * #EXA_PREPARE_MASK, indicating which pixmap is in question.  Since only up
     * to three pixmaps will have PrepareAccess() called on them per operation,
     * drivers can have a small, statically-allocated space to maintain state
     * for PrepareAccess() and FinishAccess() in.  Note that the same pixmap may
     * have PrepareAccess() called on it more than once, for example when doing
     * a copy within the same pixmap (so it gets PrepareAccess as()
     * #EXA_PREPARE_DEST and then as #EXA_PREPARE_SRC).
d627 2
a628 2
     * exaPixmapIsOffscreen(). Set to NULL if you want the standard behaviour
     * of exaPixmapIsOffscreen().
d633 1
a633 1
     * exaPixmapIsOffscreen() is used to determine if a pixmap is in offscreen
d663 4
a666 3
	#define EXA_PREPARE_AUX0	3
	#define EXA_PREPARE_AUX1	4
	#define EXA_PREPARE_AUX2	5
d702 5
d711 6
d755 17
d775 1
a775 1
ExaDriverPtr
d778 1
a778 1
Bool
d782 1
a782 1
void
d785 1
a785 1
void
d787 1
a787 1
void
d790 1
a790 1
unsigned long
d793 1
a793 1
unsigned long
d796 1
a796 1
unsigned long
d799 1
a799 1
void *
d804 1
a804 1
ExaOffscreenArea *
d810 1
a810 1
ExaOffscreenArea *
d813 1
a813 1
void
d816 1
a816 1
void
d819 1
a819 1
Bool
d822 2
a823 2
/* in exa_migration.c */
void
d826 1
a826 1
void
d831 1
a831 1
CARD32
@


1.3
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d675 7
d752 7
d761 1
d766 1
a766 1
exaDriverInit(ScreenPtr                pScreen,
d770 1
a770 1
exaDriverFini(ScreenPtr                pScreen);
d777 14
a802 9
unsigned long
exaGetPixmapOffset(PixmapPtr pPix);

unsigned long
exaGetPixmapPitch(PixmapPtr pPix);

unsigned long
exaGetPixmapSize(PixmapPtr pPix);

a815 2
void *
exaGetPixmapDriverPrivate(PixmapPtr p);
d817 1
d820 1
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d786 4
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
#define EXA_VERSION_MINOR   0
d59 1
a59 1
    int                 score;
d67 2
d78 2
a79 2
     * EXA which the driver was compiled for (or configures itself at runtime to
     * support).  This allows EXA to extend the structure for new features
d234 1
a234 1
     * PrepareCopy() sets up the driver for doing a copy within offscreen
d641 17
d676 38
d738 7
d771 3
d785 12
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d42 1
a42 1
#define EXA_VERSION_MINOR   2
d76 2
a77 2
     * EXA which the driver was compiled for (or configures itself at runtime
     * to support).  This allows EXA to extend the structure for new features
d232 1
a232 1
     * PrepareCopy() sets up the driver for doing a copy within video 
a638 17
    /**
     * PixmapIsOffscreen() is an optional driver replacement to
     * exaPixmapIsOffscreen(). Set to NULL if you want the standard behaviour
     * of exaPixmapIsOffscreen().
     *
     * @@param pPix the pixmap
     * @@return TRUE if the given drawable is in framebuffer memory.
     *
     * exaPixmapIsOffscreen() is used to determine if a pixmap is in offscreen
     * memory, meaning that acceleration could probably be done to it, and that it
     * will need to be wrapped by PrepareAccess()/FinishAccess() when accessing it
     * with the CPU.
     *
     *
     */
    Bool	(*PixmapIsOffscreen)(PixmapPtr pPix);

a706 3
void
ExaOffscreenMarkUsed (PixmapPtr pPixmap);

a717 6

void
exaMoveInPixmap (PixmapPtr pPixmap);

void
exaMoveOutPixmap (PixmapPtr pPixmap);
@

