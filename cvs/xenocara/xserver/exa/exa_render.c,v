head	1.11;
access;
symbols
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.10
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.8
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.08.09.18.59.51;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	6HLO5qdN5N4nPDjW;

1.10
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	7pAEtF6Y5EgemkuY;

1.9
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.43;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.06.35;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/*
 * Copyright © 2001 Keith Packard
 *
 * Partly based on code that is Copyright © The XFree86 Project Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include "exa_priv.h"

#include "mipict.h"

#if DEBUG_TRACE_FALL
static void
exaCompositeFallbackPictDesc(PicturePtr pict, char *string, int n)
{
    char format[20];
    char size[20];
    char loc;
    int temp;

    if (!pict) {
        snprintf(string, n, "None");
        return;
    }

    switch (pict->format) {
    case PICT_a8r8g8b8:
        snprintf(format, 20, "ARGB8888");
        break;
    case PICT_x8r8g8b8:
        snprintf(format, 20, "XRGB8888");
        break;
    case PICT_b8g8r8a8:
        snprintf(format, 20, "BGRA8888");
        break;
    case PICT_b8g8r8x8:
        snprintf(format, 20, "BGRX8888");
        break;
    case PICT_r5g6b5:
        snprintf(format, 20, "RGB565  ");
        break;
    case PICT_x1r5g5b5:
        snprintf(format, 20, "RGB555  ");
        break;
    case PICT_a8:
        snprintf(format, 20, "A8      ");
        break;
    case PICT_a1:
        snprintf(format, 20, "A1      ");
        break;
    default:
        snprintf(format, 20, "0x%x", (int) pict->format);
        break;
    }

    if (pict->pDrawable) {
        loc = exaGetOffscreenPixmap(pict->pDrawable, &temp, &temp) ? 's' : 'm';

        snprintf(size, 20, "%dx%d%s", pict->pDrawable->width,
                 pict->pDrawable->height, pict->repeat ? " R" : "");
    }
    else {
        loc = '-';

        snprintf(size, 20, "%s", pict->repeat ? " R" : "");
    }

    snprintf(string, n, "%p:%c fmt %s (%s)", pict->pDrawable, loc, format,
             size);
}

static void
exaPrintCompositeFallback(CARD8 op,
                          PicturePtr pSrc, PicturePtr pMask, PicturePtr pDst)
{
    char sop[20];
    char srcdesc[40], maskdesc[40], dstdesc[40];

    switch (op) {
    case PictOpSrc:
        snprintf(sop, sizeof(sop), "Src");
        break;
    case PictOpOver:
        snprintf(sop, sizeof(sop), "Over");
        break;
    default:
        snprintf(sop, sizeof(sop), "0x%x", (int) op);
        break;
    }

    exaCompositeFallbackPictDesc(pSrc, srcdesc, 40);
    exaCompositeFallbackPictDesc(pMask, maskdesc, 40);
    exaCompositeFallbackPictDesc(pDst, dstdesc, 40);

    ErrorF("Composite fallback: op %s, \n"
           "                    src  %s, \n"
           "                    mask %s, \n"
           "                    dst  %s, \n", sop, srcdesc, maskdesc, dstdesc);
}
#endif                          /* DEBUG_TRACE_FALL */

Bool
exaOpReadsDestination(CARD8 op)
{
    /* FALSE (does not read destination) is the list of ops in the protocol
     * document with "0" in the "Fb" column and no "Ab" in the "Fa" column.
     * That's just Clear and Src.  ReduceCompositeOp() will already have
     * converted con/disjoint clear/src to Clear or Src.
     */
    switch (op) {
    case PictOpClear:
    case PictOpSrc:
        return FALSE;
    default:
        return TRUE;
    }
}

static Bool
exaGetPixelFromRGBA(CARD32 *pixel,
                    CARD16 red,
                    CARD16 green,
                    CARD16 blue, CARD16 alpha, PictFormatPtr pFormat)
{
    int rbits, bbits, gbits, abits;
    int rshift, bshift, gshift, ashift;

    *pixel = 0;

    if (!PICT_FORMAT_COLOR(pFormat->format) &&
        PICT_FORMAT_TYPE(pFormat->format) != PICT_TYPE_A)
        return FALSE;

    rbits = PICT_FORMAT_R(pFormat->format);
    gbits = PICT_FORMAT_G(pFormat->format);
    bbits = PICT_FORMAT_B(pFormat->format);
    abits = PICT_FORMAT_A(pFormat->format);

    rshift = pFormat->direct.red;
    gshift = pFormat->direct.green;
    bshift = pFormat->direct.blue;
    ashift = pFormat->direct.alpha;

    *pixel |= (blue >> (16 - bbits)) << bshift;
    *pixel |= (red >> (16 - rbits)) << rshift;
    *pixel |= (green >> (16 - gbits)) << gshift;
    *pixel |= (alpha >> (16 - abits)) << ashift;

    return TRUE;
}

static Bool
exaGetRGBAFromPixel(CARD32 pixel,
                    CARD16 *red,
                    CARD16 *green,
                    CARD16 *blue,
                    CARD16 *alpha,
                    PictFormatPtr pFormat, PictFormatShort format)
{
    int rbits, bbits, gbits, abits;
    int rshift, bshift, gshift, ashift;

    if (!PICT_FORMAT_COLOR(format) && PICT_FORMAT_TYPE(format) != PICT_TYPE_A)
        return FALSE;

    rbits = PICT_FORMAT_R(format);
    gbits = PICT_FORMAT_G(format);
    bbits = PICT_FORMAT_B(format);
    abits = PICT_FORMAT_A(format);

    if (pFormat) {
        rshift = pFormat->direct.red;
        gshift = pFormat->direct.green;
        bshift = pFormat->direct.blue;
        ashift = pFormat->direct.alpha;
    }
    else if (format == PICT_a8r8g8b8) {
        rshift = 16;
        gshift = 8;
        bshift = 0;
        ashift = 24;
    }
    else
        FatalError("EXA bug: exaGetRGBAFromPixel() doesn't match "
                   "createSourcePicture()\n");

    if (rbits) {
        *red = ((pixel >> rshift) & ((1 << rbits) - 1)) << (16 - rbits);
        while (rbits < 16) {
            *red |= *red >> rbits;
            rbits <<= 1;
        }

        *green = ((pixel >> gshift) & ((1 << gbits) - 1)) << (16 - gbits);
        while (gbits < 16) {
            *green |= *green >> gbits;
            gbits <<= 1;
        }

        *blue = ((pixel >> bshift) & ((1 << bbits) - 1)) << (16 - bbits);
        while (bbits < 16) {
            *blue |= *blue >> bbits;
            bbits <<= 1;
        }
    }
    else {
        *red = 0x0000;
        *green = 0x0000;
        *blue = 0x0000;
    }

    if (abits) {
        *alpha = ((pixel >> ashift) & ((1 << abits) - 1)) << (16 - abits);
        while (abits < 16) {
            *alpha |= *alpha >> abits;
            abits <<= 1;
        }
    }
    else
        *alpha = 0xffff;

    return TRUE;
}

static int
exaTryDriverSolidFill(PicturePtr pSrc,
                      PicturePtr pDst,
                      INT16 xSrc,
                      INT16 ySrc,
                      INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
{
    ExaScreenPriv(pDst->pDrawable->pScreen);
    RegionRec region;
    BoxPtr pbox;
    int nbox;
    int dst_off_x, dst_off_y;
    PixmapPtr pSrcPix, pDstPix;
    ExaPixmapPrivPtr pDstExaPix;
    CARD32 pixel;
    CARD16 red, green, blue, alpha;

    pDstPix = exaGetDrawablePixmap(pDst->pDrawable);
    pDstExaPix = ExaGetPixmapPriv(pDstPix);

    /* Check whether the accelerator can use the destination pixmap.
     */
    if (pDstExaPix->accel_blocked) {
        return -1;
    }

    xDst += pDst->pDrawable->x;
    yDst += pDst->pDrawable->y;
    if (pSrc->pDrawable) {
        xSrc += pSrc->pDrawable->x;
        ySrc += pSrc->pDrawable->y;
    }

    if (!miComputeCompositeRegion(&region, pSrc, NULL, pDst,
                                  xSrc, ySrc, 0, 0, xDst, yDst, width, height))
        return 1;

    exaGetDrawableDeltas(pDst->pDrawable, pDstPix, &dst_off_x, &dst_off_y);

    RegionTranslate(&region, dst_off_x, dst_off_y);

    if (pSrc->pDrawable) {
        pSrcPix = exaGetDrawablePixmap(pSrc->pDrawable);
        pixel = exaGetPixmapFirstPixel(pSrcPix);
    }
    else
        pixel = pSrc->pSourcePict->solidFill.color;

    if (!exaGetRGBAFromPixel(pixel, &red, &green, &blue, &alpha,
                             pSrc->pFormat, pSrc->format) ||
        !exaGetPixelFromRGBA(&pixel, red, green, blue, alpha, pDst->pFormat)) {
        RegionUninit(&region);
        return -1;
    }

    if (pExaScr->do_migration) {
        ExaMigrationRec pixmaps[1];

        pixmaps[0].as_dst = TRUE;
        pixmaps[0].as_src = FALSE;
        pixmaps[0].pPix = pDstPix;
        pixmaps[0].pReg = &region;
        exaDoMigration(pixmaps, 1, TRUE);
    }

    if (!exaPixmapHasGpuCopy(pDstPix)) {
        RegionUninit(&region);
        return 0;
    }

    if (!(*pExaScr->info->PrepareSolid) (pDstPix, GXcopy, 0xffffffff, pixel)) {
        RegionUninit(&region);
        return -1;
    }

    nbox = RegionNumRects(&region);
    pbox = RegionRects(&region);

    while (nbox--) {
        (*pExaScr->info->Solid) (pDstPix, pbox->x1, pbox->y1, pbox->x2,
                                 pbox->y2);
        pbox++;
    }

    (*pExaScr->info->DoneSolid) (pDstPix);
    exaMarkSync(pDst->pDrawable->pScreen);

    RegionUninit(&region);
    return 1;
}

static int
exaTryDriverCompositeRects(CARD8 op,
                           PicturePtr pSrc,
                           PicturePtr pMask,
                           PicturePtr pDst,
                           int nrect, ExaCompositeRectPtr rects)
{
    ExaScreenPriv(pDst->pDrawable->pScreen);
    int src_off_x = 0, src_off_y = 0, mask_off_x = 0, mask_off_y = 0;
    int dst_off_x, dst_off_y;
    PixmapPtr pSrcPix = NULL, pMaskPix = NULL, pDstPix;
    ExaPixmapPrivPtr pSrcExaPix = NULL, pMaskExaPix = NULL, pDstExaPix;

    if (!pExaScr->info->PrepareComposite)
        return -1;

    if (pSrc->pDrawable) {
        pSrcPix = exaGetDrawablePixmap(pSrc->pDrawable);
        pSrcExaPix = ExaGetPixmapPriv(pSrcPix);
    }

    if (pMask && pMask->pDrawable) {
        pMaskPix = exaGetDrawablePixmap(pMask->pDrawable);
        pMaskExaPix = ExaGetPixmapPriv(pMaskPix);
    }

    pDstPix = exaGetDrawablePixmap(pDst->pDrawable);
    pDstExaPix = ExaGetPixmapPriv(pDstPix);

    /* Check whether the accelerator can use these pixmaps.
     * FIXME: If it cannot, use temporary pixmaps so that the drawing
     * happens within limits.
     */
    if (pDstExaPix->accel_blocked ||
        (pSrcExaPix && pSrcExaPix->accel_blocked) ||
        (pMaskExaPix && pMaskExaPix->accel_blocked)) {
        return -1;
    }

    if (pExaScr->info->CheckComposite &&
        !(*pExaScr->info->CheckComposite) (op, pSrc, pMask, pDst)) {
        return -1;
    }

    if (pExaScr->do_migration) {
        ExaMigrationRec pixmaps[3];
        int i = 0;

        pixmaps[i].as_dst = TRUE;
        pixmaps[i].as_src = exaOpReadsDestination(op);
        pixmaps[i].pPix = pDstPix;
        pixmaps[i].pReg = NULL;
        i++;

        if (pSrcPix) {
            pixmaps[i].as_dst = FALSE;
            pixmaps[i].as_src = TRUE;
            pixmaps[i].pPix = pSrcPix;
            pixmaps[i].pReg = NULL;
            i++;
        }

        if (pMaskPix) {
            pixmaps[i].as_dst = FALSE;
            pixmaps[i].as_src = TRUE;
            pixmaps[i].pPix = pMaskPix;
            pixmaps[i].pReg = NULL;
            i++;
        }

        exaDoMigration(pixmaps, i, TRUE);
    }

    pDstPix = exaGetOffscreenPixmap(pDst->pDrawable, &dst_off_x, &dst_off_y);
    if (!pDstPix)
        return 0;

    if (pSrcPix) {
        pSrcPix =
            exaGetOffscreenPixmap(pSrc->pDrawable, &src_off_x, &src_off_y);
        if (!pSrcPix)
            return 0;
    }

    if (pMaskPix) {
        pMaskPix =
            exaGetOffscreenPixmap(pMask->pDrawable, &mask_off_x, &mask_off_y);
        if (!pMaskPix)
            return 0;
    }

    if (!(*pExaScr->info->PrepareComposite) (op, pSrc, pMask, pDst, pSrcPix,
                                             pMaskPix, pDstPix))
        return -1;

    while (nrect--) {
        INT16 xDst = rects->xDst + pDst->pDrawable->x;
        INT16 yDst = rects->yDst + pDst->pDrawable->y;
        INT16 xMask = rects->xMask;
        INT16 yMask = rects->yMask;
        INT16 xSrc = rects->xSrc;
        INT16 ySrc = rects->ySrc;
        RegionRec region;
        BoxPtr pbox;
        int nbox;

        if (pMaskPix) {
            xMask += pMask->pDrawable->x;
            yMask += pMask->pDrawable->y;
        }

        if (pSrcPix) {
            xSrc += pSrc->pDrawable->x;
            ySrc += pSrc->pDrawable->y;
        }

        if (!miComputeCompositeRegion(&region, pSrc, pMask, pDst,
                                      xSrc, ySrc, xMask, yMask, xDst, yDst,
                                      rects->width, rects->height))
            goto next_rect;

        RegionTranslate(&region, dst_off_x, dst_off_y);

        nbox = RegionNumRects(&region);
        pbox = RegionRects(&region);

        xMask = xMask + mask_off_x - xDst - dst_off_x;
        yMask = yMask + mask_off_y - yDst - dst_off_y;
        xSrc = xSrc + src_off_x - xDst - dst_off_x;
        ySrc = ySrc + src_off_y - yDst - dst_off_y;

        while (nbox--) {
            (*pExaScr->info->Composite) (pDstPix,
                                         pbox->x1 + xSrc,
                                         pbox->y1 + ySrc,
                                         pbox->x1 + xMask,
                                         pbox->y1 + yMask,
                                         pbox->x1,
                                         pbox->y1,
                                         pbox->x2 - pbox->x1,
                                         pbox->y2 - pbox->y1);
            pbox++;
        }

 next_rect:
        RegionUninit(&region);

        rects++;
    }

    (*pExaScr->info->DoneComposite) (pDstPix);
    exaMarkSync(pDst->pDrawable->pScreen);

    return 1;
}

/**
 * Copy a number of rectangles from source to destination in a single
 * operation. This is specialized for glyph rendering: we don't have the
 * special-case fallbacks found in exaComposite() - if the driver can support
 * it, we use the driver functionality, otherwise we fall back straight to
 * software.
 */
void
exaCompositeRects(CARD8 op,
                  PicturePtr pSrc,
                  PicturePtr pMask,
                  PicturePtr pDst, int nrect, ExaCompositeRectPtr rects)
{
    ExaScreenPriv(pDst->pDrawable->pScreen);
    int n;
    ExaCompositeRectPtr r;
    int ret;

    /* If we get a mask, that means we're rendering to the exaGlyphs
     * destination directly, so the damage layer takes care of this.
     */
    if (!pMask) {
        RegionRec region;
        int x1 = MAXSHORT;
        int y1 = MAXSHORT;
        int x2 = MINSHORT;
        int y2 = MINSHORT;
        BoxRec box;

        /* We have to manage the damage ourselves, since CompositeRects isn't
         * something in the screen that can be managed by the damage extension,
         * and EXA depends on damage to track what needs to be migrated between
         * the gpu and the cpu.
         */

        /* Compute the overall extents of the composited region - we're making
         * the assumption here that we are compositing a bunch of glyphs that
         * cluster closely together and damaging each glyph individually would
         * be a loss compared to damaging the bounding box.
         */
        n = nrect;
        r = rects;
        while (n--) {
            int rect_x2 = r->xDst + r->width;
            int rect_y2 = r->yDst + r->height;

            if (r->xDst < x1)
                x1 = r->xDst;
            if (r->yDst < y1)
                y1 = r->yDst;
            if (rect_x2 > x2)
                x2 = rect_x2;
            if (rect_y2 > y2)
                y2 = rect_y2;

            r++;
        }

        if (x2 <= x1 || y2 <= y1)
            return;

        box.x1 = x1;
        box.x2 = x2 < MAXSHORT ? x2 : MAXSHORT;
        box.y1 = y1;
        box.y2 = y2 < MAXSHORT ? y2 : MAXSHORT;

        /* The pixmap migration code relies on pendingDamage indicating
         * the bounds of the current rendering, so we need to force
         * the actual damage into that region before we do anything, and
         * (see use of DamagePendingRegion in exaCopyDirty)
         */

        RegionInit(&region, &box, 1);

        DamageRegionAppend(pDst->pDrawable, &region);

        RegionUninit(&region);
    }

    /************************************************************/

    ValidatePicture(pSrc);
    if (pMask)
        ValidatePicture(pMask);
    ValidatePicture(pDst);

    ret = exaTryDriverCompositeRects(op, pSrc, pMask, pDst, nrect, rects);

    if (ret != 1) {
        if (ret == -1 && op == PictOpOver && pMask && pMask->componentAlpha &&
            (!pExaScr->info->CheckComposite ||
             ((*pExaScr->info->CheckComposite) (PictOpOutReverse, pSrc, pMask,
                                                pDst) &&
              (*pExaScr->info->CheckComposite) (PictOpAdd, pSrc, pMask,
                                                pDst)))) {
            ret =
                exaTryDriverCompositeRects(PictOpOutReverse, pSrc, pMask, pDst,
                                           nrect, rects);
            if (ret == 1) {
                op = PictOpAdd;
                ret = exaTryDriverCompositeRects(op, pSrc, pMask, pDst, nrect,
                                                 rects);
            }
        }

        if (ret != 1) {
            n = nrect;
            r = rects;
            while (n--) {
                ExaCheckComposite(op, pSrc, pMask, pDst,
                                  r->xSrc, r->ySrc,
                                  r->xMask, r->yMask,
                                  r->xDst, r->yDst, r->width, r->height);
                r++;
            }
        }
    }

    /************************************************************/

    if (!pMask) {
        /* Now we have to flush the damage out from pendingDamage => damage
         * Calling DamageRegionProcessPending has that effect.
         */

        DamageRegionProcessPending(pDst->pDrawable);
    }
}

static int
exaTryDriverComposite(CARD8 op,
                      PicturePtr pSrc,
                      PicturePtr pMask,
                      PicturePtr pDst,
                      INT16 xSrc,
                      INT16 ySrc,
                      INT16 xMask,
                      INT16 yMask,
                      INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
{
    ExaScreenPriv(pDst->pDrawable->pScreen);
    RegionRec region;
    BoxPtr pbox;
    int nbox;
    int src_off_x, src_off_y, mask_off_x = 0, mask_off_y = 0, dst_off_x, dst_off_y;
    PixmapPtr pSrcPix = NULL, pMaskPix = NULL, pDstPix;
    ExaPixmapPrivPtr pSrcExaPix = NULL, pMaskExaPix = NULL, pDstExaPix;

    if (pSrc->pDrawable) {
        pSrcPix = exaGetDrawablePixmap(pSrc->pDrawable);
        pSrcExaPix = ExaGetPixmapPriv(pSrcPix);
    }

    pDstPix = exaGetDrawablePixmap(pDst->pDrawable);
    pDstExaPix = ExaGetPixmapPriv(pDstPix);

    if (pMask && pMask->pDrawable) {
        pMaskPix = exaGetDrawablePixmap(pMask->pDrawable);
        pMaskExaPix = ExaGetPixmapPriv(pMaskPix);
    }

    /* Check whether the accelerator can use these pixmaps.
     * FIXME: If it cannot, use temporary pixmaps so that the drawing
     * happens within limits.
     */
    if (pDstExaPix->accel_blocked ||
        (pSrcExaPix && pSrcExaPix->accel_blocked) ||
        (pMaskExaPix && (pMaskExaPix->accel_blocked))) {
        return -1;
    }

    xDst += pDst->pDrawable->x;
    yDst += pDst->pDrawable->y;

    if (pMaskPix) {
        xMask += pMask->pDrawable->x;
        yMask += pMask->pDrawable->y;
    }

    if (pSrcPix) {
        xSrc += pSrc->pDrawable->x;
        ySrc += pSrc->pDrawable->y;
    }

    if (pExaScr->info->CheckComposite &&
        !(*pExaScr->info->CheckComposite) (op, pSrc, pMask, pDst)) {
        return -1;
    }

    if (!miComputeCompositeRegion(&region, pSrc, pMask, pDst,
                                  xSrc, ySrc, xMask, yMask, xDst, yDst,
                                  width, height))
        return 1;

    exaGetDrawableDeltas(pDst->pDrawable, pDstPix, &dst_off_x, &dst_off_y);

    RegionTranslate(&region, dst_off_x, dst_off_y);

    if (pExaScr->do_migration) {
        ExaMigrationRec pixmaps[3];
        int i = 0;

        pixmaps[i].as_dst = TRUE;
        pixmaps[i].as_src = exaOpReadsDestination(op);
        pixmaps[i].pPix = pDstPix;
        pixmaps[i].pReg = pixmaps[0].as_src ? NULL : &region;
        i++;

        if (pSrcPix) {
            pixmaps[i].as_dst = FALSE;
            pixmaps[i].as_src = TRUE;
            pixmaps[i].pPix = pSrcPix;
            pixmaps[i].pReg = NULL;
            i++;
        }

        if (pMaskPix) {
            pixmaps[i].as_dst = FALSE;
            pixmaps[i].as_src = TRUE;
            pixmaps[i].pPix = pMaskPix;
            pixmaps[i].pReg = NULL;
            i++;
        }

        exaDoMigration(pixmaps, i, TRUE);
    }

    if (pSrcPix) {
        pSrcPix =
            exaGetOffscreenPixmap(pSrc->pDrawable, &src_off_x, &src_off_y);
        if (!pSrcPix) {
            RegionUninit(&region);
            return 0;
        }
    }

    if (pMaskPix) {
        pMaskPix = exaGetOffscreenPixmap(pMask->pDrawable, &mask_off_x,
                                         &mask_off_y);
        if (!pMaskPix) {
            RegionUninit(&region);
            return 0;
        }
    }

    if (!exaPixmapHasGpuCopy(pDstPix)) {
        RegionUninit(&region);
        return 0;
    }

    if (!(*pExaScr->info->PrepareComposite) (op, pSrc, pMask, pDst, pSrcPix,
                                             pMaskPix, pDstPix)) {
        RegionUninit(&region);
        return -1;
    }

    nbox = RegionNumRects(&region);
    pbox = RegionRects(&region);

    xMask = xMask + mask_off_x - xDst - dst_off_x;
    yMask = yMask + mask_off_y - yDst - dst_off_y;

    xSrc = xSrc + src_off_x - xDst - dst_off_x;
    ySrc = ySrc + src_off_y - yDst - dst_off_y;

    while (nbox--) {
        (*pExaScr->info->Composite) (pDstPix,
                                     pbox->x1 + xSrc,
                                     pbox->y1 + ySrc,
                                     pbox->x1 + xMask,
                                     pbox->y1 + yMask,
                                     pbox->x1,
                                     pbox->y1,
                                     pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
        pbox++;
    }
    (*pExaScr->info->DoneComposite) (pDstPix);
    exaMarkSync(pDst->pDrawable->pScreen);

    RegionUninit(&region);
    return 1;
}

/**
 * exaTryMagicTwoPassCompositeHelper implements PictOpOver using two passes of
 * simpler operations PictOpOutReverse and PictOpAdd. Mainly used for component
 * alpha and limited 1-tmu cards.
 *
 * From http://anholt.livejournal.com/32058.html:
 *
 * The trouble is that component-alpha rendering requires two different sources
 * for blending: one for the source value to the blender, which is the
 * per-channel multiplication of source and mask, and one for the source alpha
 * for multiplying with the destination channels, which is the multiplication
 * of the source channels by the mask alpha. So the equation for Over is:
 *
 * dst.A = src.A * mask.A + (1 - (src.A * mask.A)) * dst.A
 * dst.R = src.R * mask.R + (1 - (src.A * mask.R)) * dst.R
 * dst.G = src.G * mask.G + (1 - (src.A * mask.G)) * dst.G
 * dst.B = src.B * mask.B + (1 - (src.A * mask.B)) * dst.B
 *
 * But we can do some simpler operations, right? How about PictOpOutReverse,
 * which has a source factor of 0 and dest factor of (1 - source alpha). We
 * can get the source alpha value (srca.X = src.A * mask.X) out of the texture
 * blenders pretty easily. So we can do a component-alpha OutReverse, which
 * gets us:
 *
 * dst.A = 0 + (1 - (src.A * mask.A)) * dst.A
 * dst.R = 0 + (1 - (src.A * mask.R)) * dst.R
 * dst.G = 0 + (1 - (src.A * mask.G)) * dst.G
 * dst.B = 0 + (1 - (src.A * mask.B)) * dst.B
 *
 * OK. And if an op doesn't use the source alpha value for the destination
 * factor, then we can do the channel multiplication in the texture blenders
 * to get the source value, and ignore the source alpha that we wouldn't use.
 * We've supported this in the Radeon driver for a long time. An example would
 * be PictOpAdd, which does:
 *
 * dst.A = src.A * mask.A + dst.A
 * dst.R = src.R * mask.R + dst.R
 * dst.G = src.G * mask.G + dst.G
 * dst.B = src.B * mask.B + dst.B
 *
 * Hey, this looks good! If we do a PictOpOutReverse and then a PictOpAdd right
 * after it, we get:
 *
 * dst.A = src.A * mask.A + ((1 - (src.A * mask.A)) * dst.A)
 * dst.R = src.R * mask.R + ((1 - (src.A * mask.R)) * dst.R)
 * dst.G = src.G * mask.G + ((1 - (src.A * mask.G)) * dst.G)
 * dst.B = src.B * mask.B + ((1 - (src.A * mask.B)) * dst.B)
 */

static int
exaTryMagicTwoPassCompositeHelper(CARD8 op,
                                  PicturePtr pSrc,
                                  PicturePtr pMask,
                                  PicturePtr pDst,
                                  INT16 xSrc,
                                  INT16 ySrc,
                                  INT16 xMask,
                                  INT16 yMask,
                                  INT16 xDst,
                                  INT16 yDst, CARD16 width, CARD16 height)
{
    ExaScreenPriv(pDst->pDrawable->pScreen);

    assert(op == PictOpOver);

    if (pExaScr->info->CheckComposite &&
        (!(*pExaScr->info->CheckComposite) (PictOpOutReverse, pSrc, pMask,
                                            pDst) ||
         !(*pExaScr->info->CheckComposite) (PictOpAdd, pSrc, pMask, pDst))) {
        return -1;
    }

    /* Now, we think we should be able to accelerate this operation. First,
     * composite the destination to be the destination times the source alpha
     * factors.
     */
    exaComposite(PictOpOutReverse, pSrc, pMask, pDst, xSrc, ySrc, xMask, yMask,
                 xDst, yDst, width, height);

    /* Then, add in the source value times the destination alpha factors (1.0).
     */
    exaComposite(PictOpAdd, pSrc, pMask, pDst, xSrc, ySrc, xMask, yMask,
                 xDst, yDst, width, height);

    return 1;
}

void
exaComposite(CARD8 op,
             PicturePtr pSrc,
             PicturePtr pMask,
             PicturePtr pDst,
             INT16 xSrc,
             INT16 ySrc,
             INT16 xMask,
             INT16 yMask, INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
{
    ExaScreenPriv(pDst->pDrawable->pScreen);
    int ret = -1;
    Bool saveSrcRepeat = pSrc->repeat;
    Bool saveMaskRepeat = pMask ? pMask->repeat : 0;
    RegionRec region;

    if (pExaScr->swappedOut)
        goto fallback;

    /* Remove repeat in source if useless */
    if (pSrc->pDrawable && pSrc->repeat && !pSrc->transform && xSrc >= 0 &&
        (xSrc + width) <= pSrc->pDrawable->width && ySrc >= 0 &&
        (ySrc + height) <= pSrc->pDrawable->height)
        pSrc->repeat = 0;

    if (!pMask && !pSrc->alphaMap && !pDst->alphaMap &&
        (op == PictOpSrc || (op == PictOpOver && !PICT_FORMAT_A(pSrc->format))))
    {
        if (pSrc->pDrawable ?
            (pSrc->pDrawable->width == 1 && pSrc->pDrawable->height == 1 &&
             pSrc->repeat) :
            (pSrc->pSourcePict->type == SourcePictTypeSolidFill)) {
            ret = exaTryDriverSolidFill(pSrc, pDst, xSrc, ySrc, xDst, yDst,
                                        width, height);
            if (ret == 1)
                goto done;
        }
        else if (pSrc->pDrawable && !pSrc->transform &&
                 ((op == PictOpSrc &&
                   (pSrc->format == pDst->format ||
                    (PICT_FORMAT_COLOR(pDst->format) &&
                     PICT_FORMAT_COLOR(pSrc->format) &&
                     pDst->format == PICT_FORMAT(PICT_FORMAT_BPP(pSrc->format),
                                                 PICT_FORMAT_TYPE(pSrc->format),
                                                 0,
                                                 PICT_FORMAT_R(pSrc->format),
                                                 PICT_FORMAT_G(pSrc->format),
                                                 PICT_FORMAT_B(pSrc->format)))))
                  || (op == PictOpOver && pSrc->format == pDst->format &&
                      !PICT_FORMAT_A(pSrc->format)))) {
            if (!pSrc->repeat && xSrc >= 0 && ySrc >= 0 &&
                (xSrc + width <= pSrc->pDrawable->width) &&
                (ySrc + height <= pSrc->pDrawable->height)) {
                Bool suc;

                xDst += pDst->pDrawable->x;
                yDst += pDst->pDrawable->y;
                xSrc += pSrc->pDrawable->x;
                ySrc += pSrc->pDrawable->y;

                if (!miComputeCompositeRegion(&region, pSrc, pMask, pDst,
                                              xSrc, ySrc, xMask, yMask, xDst,
                                              yDst, width, height))
                    goto done;

                suc = exaHWCopyNtoN(pSrc->pDrawable, pDst->pDrawable, NULL,
                                    RegionRects(&region),
                                    RegionNumRects(&region), xSrc - xDst,
                                    ySrc - yDst, FALSE, FALSE);
                RegionUninit(&region);

                /* Reset values to their original values. */
                xDst -= pDst->pDrawable->x;
                yDst -= pDst->pDrawable->y;
                xSrc -= pSrc->pDrawable->x;
                ySrc -= pSrc->pDrawable->y;

                if (!suc)
                    goto fallback;

                goto done;
            }

            if (pSrc->repeat && pSrc->repeatType == RepeatNormal &&
                pSrc->pDrawable->type == DRAWABLE_PIXMAP) {
                DDXPointRec patOrg;

                /* Let's see if the driver can do the repeat in one go */
                if (pExaScr->info->PrepareComposite && !pSrc->alphaMap &&
                    !pDst->alphaMap) {
                    ret = exaTryDriverComposite(op, pSrc, pMask, pDst, xSrc,
                                                ySrc, xMask, yMask, xDst, yDst,
                                                width, height);
                    if (ret == 1)
                        goto done;
                }

                /* Now see if we can use exaFillRegionTiled() */
                xDst += pDst->pDrawable->x;
                yDst += pDst->pDrawable->y;
                xSrc += pSrc->pDrawable->x;
                ySrc += pSrc->pDrawable->y;

                if (!miComputeCompositeRegion(&region, pSrc, pMask, pDst, xSrc,
                                              ySrc, xMask, yMask, xDst, yDst,
                                              width, height))
                    goto done;

                /* pattern origin is the point in the destination drawable
                 * corresponding to (0,0) in the source */
                patOrg.x = xDst - xSrc;
                patOrg.y = yDst - ySrc;

                ret = exaFillRegionTiled(pDst->pDrawable, &region,
                                         (PixmapPtr) pSrc->pDrawable,
                                         &patOrg, FB_ALLONES, GXcopy, CT_NONE);

                RegionUninit(&region);

                if (ret)
                    goto done;

                /* Let's be correct and restore the variables to their original state. */
                xDst -= pDst->pDrawable->x;
                yDst -= pDst->pDrawable->y;
                xSrc -= pSrc->pDrawable->x;
                ySrc -= pSrc->pDrawable->y;
            }
        }
    }

    /* Remove repeat in mask if useless */
    if (pMask && pMask->pDrawable && pMask->repeat && !pMask->transform &&
        xMask >= 0 && (xMask + width) <= pMask->pDrawable->width &&
        yMask >= 0 && (yMask + height) <= pMask->pDrawable->height)
        pMask->repeat = 0;

    if (pExaScr->info->PrepareComposite &&
        !pSrc->alphaMap && (!pMask || !pMask->alphaMap) && !pDst->alphaMap) {
        Bool isSrcSolid;

        ret = exaTryDriverComposite(op, pSrc, pMask, pDst, xSrc, ySrc, xMask,
                                    yMask, xDst, yDst, width, height);
        if (ret == 1)
            goto done;

        /* For generic masks and solid src pictures, mach64 can do Over in two
         * passes, similar to the component-alpha case.
         */
        isSrcSolid = pSrc->pDrawable ?
            (pSrc->pDrawable->width == 1 && pSrc->pDrawable->height == 1 &&
             pSrc->repeat) :
            (pSrc->pSourcePict->type == SourcePictTypeSolidFill);

        /* If we couldn't do the Composite in a single pass, and it was a
         * component-alpha Over, see if we can do it in two passes with
         * an OutReverse and then an Add.
         */
        if (ret == -1 && op == PictOpOver && pMask &&
            (pMask->componentAlpha || isSrcSolid)) {
            ret = exaTryMagicTwoPassCompositeHelper(op, pSrc, pMask, pDst,
                                                    xSrc, ySrc,
                                                    xMask, yMask, xDst, yDst,
                                                    width, height);
            if (ret == 1)
                goto done;
        }
    }

 fallback:
#if DEBUG_TRACE_FALL
    exaPrintCompositeFallback(op, pSrc, pMask, pDst);
#endif

    ExaCheckComposite(op, pSrc, pMask, pDst, xSrc, ySrc,
                      xMask, yMask, xDst, yDst, width, height);

 done:
    pSrc->repeat = saveSrcRepeat;
    if (pMask)
        pMask->repeat = saveMaskRepeat;
}

/**
 * Same as miCreateAlphaPicture, except it uses ExaCheckPolyFillRect instead
 * of PolyFillRect to initialize the pixmap after creating it, to prevent
 * the pixmap from being migrated.
 *
 * See the comments about exaTrapezoids and exaTriangles.
 */
static PicturePtr
exaCreateAlphaPicture(ScreenPtr pScreen,
                      PicturePtr pDst,
                      PictFormatPtr pPictFormat, CARD16 width, CARD16 height)
{
    PixmapPtr pPixmap;
    PicturePtr pPicture;
    GCPtr pGC;
    int error;
    xRectangle rect;

    if (width > 32767 || height > 32767)
        return 0;

    if (!pPictFormat) {
        if (pDst->polyEdge == PolyEdgeSharp)
            pPictFormat = PictureMatchFormat(pScreen, 1, PICT_a1);
        else
            pPictFormat = PictureMatchFormat(pScreen, 8, PICT_a8);
        if (!pPictFormat)
            return 0;
    }

    pPixmap = (*pScreen->CreatePixmap) (pScreen, width, height,
                                        pPictFormat->depth, 0);
    if (!pPixmap)
        return 0;
    pGC = GetScratchGC(pPixmap->drawable.depth, pScreen);
    if (!pGC) {
        (*pScreen->DestroyPixmap) (pPixmap);
        return 0;
    }
    ValidateGC(&pPixmap->drawable, pGC);
    rect.x = 0;
    rect.y = 0;
    rect.width = width;
    rect.height = height;
    ExaCheckPolyFillRect(&pPixmap->drawable, pGC, 1, &rect);
    exaPixmapDirty(pPixmap, 0, 0, width, height);
    FreeScratchGC(pGC);
    pPicture = CreatePicture(0, &pPixmap->drawable, pPictFormat,
                             0, 0, serverClient, &error);
    (*pScreen->DestroyPixmap) (pPixmap);
    return pPicture;
}

/**
 * exaTrapezoids is essentially a copy of miTrapezoids that uses
 * exaCreateAlphaPicture instead of miCreateAlphaPicture.
 *
 * The problem with miCreateAlphaPicture is that it calls PolyFillRect
 * to initialize the contents after creating the pixmap, which
 * causes the pixmap to be moved in for acceleration. The subsequent
 * call to RasterizeTrapezoid won't be accelerated however, which
 * forces the pixmap to be moved out again.
 *
 * exaCreateAlphaPicture avoids this roundtrip by using ExaCheckPolyFillRect
 * to initialize the contents.
 */
void
exaTrapezoids(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
              PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
              int ntrap, xTrapezoid * traps)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    BoxRec bounds;

    if (maskFormat) {
        PicturePtr pPicture;
        INT16 xDst, yDst;
        INT16 xRel, yRel;

        miTrapezoidBounds(ntrap, traps, &bounds);

        if (bounds.y1 >= bounds.y2 || bounds.x1 >= bounds.x2)
            return;

        xDst = traps[0].left.p1.x >> 16;
        yDst = traps[0].left.p1.y >> 16;

        pPicture = exaCreateAlphaPicture(pScreen, pDst, maskFormat,
                                         bounds.x2 - bounds.x1,
                                         bounds.y2 - bounds.y1);
        if (!pPicture)
            return;

        exaPrepareAccess(pPicture->pDrawable, EXA_PREPARE_DEST);
        for (; ntrap; ntrap--, traps++)
            if (xTrapezoidValid(traps))
                (*ps->RasterizeTrapezoid) (pPicture, traps, -bounds.x1, -bounds.y1);
        exaFinishAccess(pPicture->pDrawable, EXA_PREPARE_DEST);

        xRel = bounds.x1 + xSrc - xDst;
        yRel = bounds.y1 + ySrc - yDst;
        CompositePicture(op, pSrc, pPicture, pDst,
                         xRel, yRel, 0, 0, bounds.x1, bounds.y1,
                         bounds.x2 - bounds.x1, bounds.y2 - bounds.y1);
        FreePicture(pPicture, 0);
    }
    else {
        if (pDst->polyEdge == PolyEdgeSharp)
            maskFormat = PictureMatchFormat(pScreen, 1, PICT_a1);
        else
            maskFormat = PictureMatchFormat(pScreen, 8, PICT_a8);
        for (; ntrap; ntrap--, traps++)
            exaTrapezoids(op, pSrc, pDst, maskFormat, xSrc, ySrc, 1, traps);
    }
}

/**
 * exaTriangles is essentially a copy of miTriangles that uses
 * exaCreateAlphaPicture instead of miCreateAlphaPicture.
 *
 * The problem with miCreateAlphaPicture is that it calls PolyFillRect
 * to initialize the contents after creating the pixmap, which
 * causes the pixmap to be moved in for acceleration. The subsequent
 * call to AddTriangles won't be accelerated however, which forces the pixmap
 * to be moved out again.
 *
 * exaCreateAlphaPicture avoids this roundtrip by using ExaCheckPolyFillRect
 * to initialize the contents.
 */
void
exaTriangles(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
             PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
             int ntri, xTriangle * tris)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    BoxRec bounds;

    if (maskFormat) {
        PicturePtr pPicture;
        INT16 xDst, yDst;
        INT16 xRel, yRel;

        miTriangleBounds(ntri, tris, &bounds);

        if (bounds.y1 >= bounds.y2 || bounds.x1 >= bounds.x2)
            return;

        xDst = tris[0].p1.x >> 16;
        yDst = tris[0].p1.y >> 16;

        pPicture = exaCreateAlphaPicture(pScreen, pDst, maskFormat,
                                         bounds.x2 - bounds.x1,
                                         bounds.y2 - bounds.y1);
        if (!pPicture)
            return;

        exaPrepareAccess(pPicture->pDrawable, EXA_PREPARE_DEST);
        (*ps->AddTriangles) (pPicture, -bounds.x1, -bounds.y1, ntri, tris);
        exaFinishAccess(pPicture->pDrawable, EXA_PREPARE_DEST);

        xRel = bounds.x1 + xSrc - xDst;
        yRel = bounds.y1 + ySrc - yDst;
        CompositePicture(op, pSrc, pPicture, pDst,
                         xRel, yRel, 0, 0, bounds.x1, bounds.y1,
                         bounds.x2 - bounds.x1, bounds.y2 - bounds.y1);
        FreePicture(pPicture, 0);
    }
    else {
        if (pDst->polyEdge == PolyEdgeSharp)
            maskFormat = PictureMatchFormat(pScreen, 1, PICT_a1);
        else
            maskFormat = PictureMatchFormat(pScreen, 8, PICT_a8);

        for (; ntri; ntri--, tris++)
            exaTriangles(op, pSrc, pDst, maskFormat, xSrc, ySrc, 1, tris);
    }
}
@


1.10
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d1144 2
a1145 1
            (*ps->RasterizeTrapezoid) (pPicture, traps, -bounds.x1, -bounds.y1);
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d639 1
a639 1
    int src_off_x, src_off_y, mask_off_x, mask_off_y, dst_off_x, dst_off_y;
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d562 1
a562 1
         * the bounds of the current rendering, so we need to force 
d616 1
a616 1
        /* Now we have to flush the damage out from pendingDamage => damage 
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d918 1
a918 1
                Bool ret;
d930 1
a930 1
                ret = exaHWCopyNtoN(pSrc->pDrawable, pDst->pDrawable, NULL,
d942 1
a942 1
                if (!ret)
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d36 2
a37 1
static void exaCompositeFallbackPictDesc(PicturePtr pict, char *string, int n)
d45 2
a46 2
	snprintf(string, n, "None");
	return;
d49 1
a49 2
    switch (pict->format)
    {
d51 2
a52 2
	snprintf(format, 20, "ARGB8888");
	break;
d54 2
a55 2
	snprintf(format, 20, "XRGB8888");
	break;
d57 2
a58 2
	snprintf(format, 20, "BGRA8888");
	break;
d60 2
a61 2
	snprintf(format, 20, "BGRX8888");
	break;
d63 2
a64 2
	snprintf(format, 20, "RGB565  ");
	break;
d66 2
a67 2
	snprintf(format, 20, "RGB555  ");
	break;
d69 2
a70 2
	snprintf(format, 20, "A8      ");
	break;
d72 2
a73 2
	snprintf(format, 20, "A1      ");
	break;
d75 2
a76 2
	snprintf(format, 20, "0x%x", (int)pict->format);
	break;
d80 1
a80 1
	loc = exaGetOffscreenPixmap(pict->pDrawable, &temp, &temp) ? 's' : 'm';
d82 5
a86 5
	snprintf(size, 20, "%dx%d%s", pict->pDrawable->width,
		 pict->pDrawable->height, pict->repeat ?
		 " R" : "");
    } else {
	loc = '-';
d88 1
a88 1
	snprintf(size, 20, "%s", pict->repeat ? " R" : "");
d91 2
a92 1
    snprintf(string, n, "%p:%c fmt %s (%s)", pict->pDrawable, loc, format, size);
d97 1
a97 3
			  PicturePtr pSrc,
			  PicturePtr pMask,
			  PicturePtr pDst)
d102 1
a102 2
    switch(op)
    {
d104 2
a105 2
	sprintf(sop, "Src");
	break;
d107 2
a108 2
	sprintf(sop, "Over");
	break;
d110 2
a111 2
	sprintf(sop, "0x%x", (int)op);
	break;
d119 3
a121 4
	   "                    src  %s, \n"
	   "                    mask %s, \n"
	   "                    dst  %s, \n",
	   sop, srcdesc, maskdesc, dstdesc);
d123 1
a123 1
#endif /* DEBUG_TRACE_FALL */
d126 1
a126 1
exaOpReadsDestination (CARD8 op)
d136 1
a136 1
	return FALSE;
d138 1
a138 1
	return TRUE;
a141 1

d143 4
a146 6
exaGetPixelFromRGBA(CARD32	*pixel,
		    CARD16	red,
		    CARD16	green,
		    CARD16	blue,
		    CARD16	alpha,
		    PictFormatPtr pFormat)
d154 2
a155 2
	PICT_FORMAT_TYPE(pFormat->format) != PICT_TYPE_A)
	return FALSE;
d167 4
a170 4
    *pixel |=  ( blue >> (16 - bbits)) << bshift;
    *pixel |=  (  red >> (16 - rbits)) << rshift;
    *pixel |=  (green >> (16 - gbits)) << gshift;
    *pixel |=  (alpha >> (16 - abits)) << ashift;
d176 6
a181 7
exaGetRGBAFromPixel(CARD32	pixel,
		    CARD16	*red,
		    CARD16	*green,
		    CARD16	*blue,
		    CARD16	*alpha,
		    PictFormatPtr pFormat,
		    PictFormatShort format)
d187 1
a187 1
	return FALSE;
d195 14
a208 12
	rshift = pFormat->direct.red;
	gshift = pFormat->direct.green;
	bshift = pFormat->direct.blue;
	ashift = pFormat->direct.alpha;
    } else if (format == PICT_a8r8g8b8) {
	rshift = 16;
	gshift = 8;
	bshift = 0;
	ashift = 24;
    } else
	FatalError("EXA bug: exaGetRGBAFromPixel() doesn't match "
		   "createSourcePicture()\n");
d211 22
a232 21
	*red = ((pixel >> rshift ) & ((1 << rbits) - 1)) << (16 - rbits);
	while (rbits < 16) {
	    *red |= *red >> rbits;
	    rbits <<= 1;
	}

	*green = ((pixel >> gshift ) & ((1 << gbits) - 1)) << (16 - gbits);
	while (gbits < 16) {
	    *green |= *green >> gbits;
	    gbits <<= 1;
	}

	*blue = ((pixel >> bshift ) & ((1 << bbits) - 1)) << (16 - bbits);
	while (bbits < 16) {
	    *blue |= *blue >> bbits;
	    bbits <<= 1;
	}
    } else {
	*red = 0x0000;
	*green = 0x0000;
	*blue = 0x0000;
d236 8
a243 7
	*alpha = ((pixel >> ashift ) & ((1 << abits) - 1)) << (16 - abits);
	while (abits < 16) {
	    *alpha |= *alpha >> abits;
	    abits <<= 1;
	}
    } else
	*alpha = 0xffff;
d249 5
a253 8
exaTryDriverSolidFill(PicturePtr	pSrc,
		      PicturePtr	pDst,
		      INT16		xSrc,
		      INT16		ySrc,
		      INT16		xDst,
		      INT16		yDst,
		      CARD16		width,
		      CARD16		height)
d255 1
a255 1
    ExaScreenPriv (pDst->pDrawable->pScreen);
d265 1
a265 1
    pDstPix = exaGetDrawablePixmap (pDst->pDrawable);
d270 2
a271 3
    if (pDstExaPix->accel_blocked)
    {
	return -1;
d277 2
a278 2
	xSrc += pSrc->pDrawable->x;
	ySrc += pSrc->pDrawable->y;
d281 3
a283 4
    if (!miComputeCompositeRegion (&region, pSrc, NULL, pDst,
				   xSrc, ySrc, 0, 0, xDst, yDst,
				   width, height))
	return 1;
d285 1
a285 1
    exaGetDrawableDeltas (pDst->pDrawable, pDstPix, &dst_off_x, &dst_off_y);
d290 5
a294 4
	pSrcPix = exaGetDrawablePixmap (pSrc->pDrawable);
	pixel = exaGetPixmapFirstPixel (pSrcPix);
    } else
	pixel = pSrc->pSourcePict->solidFill.color;
d297 4
a300 6
			     pSrc->pFormat, pSrc->format) ||
	!exaGetPixelFromRGBA(&pixel, red, green, blue, alpha,
			     pDst->pFormat))
    {
	RegionUninit(&region);
	return -1;
d304 1
a304 1
	ExaMigrationRec pixmaps[1];
d306 5
a310 5
	pixmaps[0].as_dst = TRUE;
	pixmaps[0].as_src = FALSE;
	pixmaps[0].pPix = pDstPix;
	pixmaps[0].pReg = &region;
	exaDoMigration(pixmaps, 1, TRUE);
d314 2
a315 2
	RegionUninit(&region);
	return 0;
d318 3
a320 4
    if (!(*pExaScr->info->PrepareSolid) (pDstPix, GXcopy, 0xffffffff, pixel))
    {
	RegionUninit(&region);
	return -1;
d326 4
a329 4
    while (nbox--)
    {
	(*pExaScr->info->Solid) (pDstPix, pbox->x1, pbox->y1, pbox->x2, pbox->y2);
	pbox++;
d340 5
a344 6
exaTryDriverCompositeRects(CARD8	       op,
			   PicturePtr	       pSrc,
			   PicturePtr	       pMask,
			   PicturePtr	       pDst,
			   int                 nrect,
			   ExaCompositeRectPtr rects)
d346 1
a346 1
    ExaScreenPriv (pDst->pDrawable->pScreen);
d353 1
a353 1
	return -1;
d356 2
a357 2
	pSrcPix = exaGetDrawablePixmap(pSrc->pDrawable);
	pSrcExaPix = ExaGetPixmapPriv(pSrcPix);
d361 2
a362 2
	pMaskPix = exaGetDrawablePixmap(pMask->pDrawable);
	pMaskExaPix = ExaGetPixmapPriv(pMaskPix);
d373 3
a375 4
	(pSrcExaPix && pSrcExaPix->accel_blocked) ||
	(pMaskExaPix && pMaskExaPix->accel_blocked))
    {
	return -1;
d379 2
a380 3
	!(*pExaScr->info->CheckComposite) (op, pSrc, pMask, pDst))
    {
	return -1;
d384 2
a385 2
	ExaMigrationRec pixmaps[3];
	int i = 0;
d387 21
a407 21
	pixmaps[i].as_dst = TRUE;
	pixmaps[i].as_src = exaOpReadsDestination(op);
	pixmaps[i].pPix = pDstPix;
	pixmaps[i].pReg = NULL;
	i++;

	if (pSrcPix) {
	    pixmaps[i].as_dst = FALSE;
	    pixmaps[i].as_src = TRUE;
	    pixmaps[i].pPix = pSrcPix;
	    pixmaps[i].pReg = NULL;
	    i++;
	}

	if (pMaskPix) {
	    pixmaps[i].as_dst = FALSE;
	    pixmaps[i].as_src = TRUE;
	    pixmaps[i].pPix = pMaskPix;
	    pixmaps[i].pReg = NULL;
	    i++;
	}
d409 1
a409 1
	exaDoMigration(pixmaps, i, TRUE);
d412 1
a412 1
    pDstPix = exaGetOffscreenPixmap (pDst->pDrawable, &dst_off_x, &dst_off_y);
d414 1
a414 1
	return 0;
d417 4
a420 3
	pSrcPix = exaGetOffscreenPixmap (pSrc->pDrawable, &src_off_x, &src_off_y);
	if (!pSrcPix)
	    return 0;
d424 4
a427 3
	pMaskPix = exaGetOffscreenPixmap (pMask->pDrawable, &mask_off_x, &mask_off_y);
	if (!pMaskPix)
	    return 0;
d431 2
a432 2
					     pMaskPix, pDstPix))
	return -1;
d434 48
a481 50
    while (nrect--)
    {
	INT16 xDst = rects->xDst + pDst->pDrawable->x;
	INT16 yDst = rects->yDst + pDst->pDrawable->y;
	INT16 xMask = rects->xMask;
	INT16 yMask = rects->yMask;
	INT16 xSrc = rects->xSrc;
	INT16 ySrc = rects->ySrc;
	RegionRec region;
	BoxPtr pbox;
	int nbox;

	if (pMaskPix) {
	    xMask += pMask->pDrawable->x;
	    yMask += pMask->pDrawable->y;
	}

	if (pSrcPix) {
	    xSrc += pSrc->pDrawable->x;
	    ySrc += pSrc->pDrawable->y;
	}

	if (!miComputeCompositeRegion (&region, pSrc, pMask, pDst,
				       xSrc, ySrc, xMask, yMask, xDst, yDst,
				       rects->width, rects->height))
	    goto next_rect;

	RegionTranslate(&region, dst_off_x, dst_off_y);

	nbox = RegionNumRects(&region);
	pbox = RegionRects(&region);

	xMask = xMask + mask_off_x - xDst - dst_off_x;
	yMask = yMask + mask_off_y - yDst - dst_off_y;
	xSrc = xSrc + src_off_x - xDst - dst_off_x;
	ySrc = ySrc + src_off_y - yDst - dst_off_y;

	while (nbox--)
	{
	    (*pExaScr->info->Composite) (pDstPix,
					 pbox->x1 + xSrc,
					 pbox->y1 + ySrc,
					 pbox->x1 + xMask,
					 pbox->y1 + yMask,
					 pbox->x1,
					 pbox->y1,
					 pbox->x2 - pbox->x1,
					 pbox->y2 - pbox->y1);
	    pbox++;
	}
d483 2
a484 2
    next_rect:
	RegionUninit(&region);
d486 1
a486 1
	rects++;
d503 4
a506 6
exaCompositeRects(CARD8	              op,
		  PicturePtr	      pSrc,
		  PicturePtr	      pMask,
		  PicturePtr	      pDst,
		  int                 nrect,
		  ExaCompositeRectPtr rects)
d508 1
a508 1
    ExaScreenPriv (pDst->pDrawable->pScreen);
d517 53
a569 49
	RegionRec region;
	int x1 = MAXSHORT;
	int y1 = MAXSHORT;
	int x2 = MINSHORT;
	int y2 = MINSHORT;
	BoxRec box;
    
	/* We have to manage the damage ourselves, since CompositeRects isn't
	 * something in the screen that can be managed by the damage extension,
	 * and EXA depends on damage to track what needs to be migrated between
	 * the gpu and the cpu.
	 */

	/* Compute the overall extents of the composited region - we're making
	 * the assumption here that we are compositing a bunch of glyphs that
	 * cluster closely together and damaging each glyph individually would
	 * be a loss compared to damaging the bounding box.
	 */
	n = nrect;
	r = rects;
	while (n--) {
	    int rect_x2 = r->xDst + r->width;
	    int rect_y2 = r->yDst + r->height;

	    if (r->xDst < x1) x1 = r->xDst;
	    if (r->yDst < y1) y1 = r->yDst;
	    if (rect_x2 > x2) x2 = rect_x2;
	    if (rect_y2 > y2) y2 = rect_y2;

	    r++;
	}

	if (x2 <= x1 || y2 <= y1)
	    return;

	box.x1 = x1;
	box.x2 = x2 < MAXSHORT ? x2 : MAXSHORT;
	box.y1 = y1;
	box.y2 = y2 < MAXSHORT ? y2 : MAXSHORT;

 	/* The pixmap migration code relies on pendingDamage indicating
	 * the bounds of the current rendering, so we need to force 
	 * the actual damage into that region before we do anything, and
	 * (see use of DamagePendingRegion in exaCopyDirty)
	 */

	RegionInit(&region, &box, 1);
    
	DamageRegionAppend(pDst->pDrawable, &region);
d571 1
a571 1
	RegionUninit(&region);
d573 1
a573 1
    
d575 2
a576 2
    
    ValidatePicture (pSrc);
d578 2
a579 2
	ValidatePicture (pMask);
    ValidatePicture (pDst);
d584 27
a610 26
	if (ret == -1 && op == PictOpOver && pMask && pMask->componentAlpha &&
	    (!pExaScr->info->CheckComposite ||
	     ((*pExaScr->info->CheckComposite)(PictOpOutReverse, pSrc, pMask,
					       pDst) &&
	      (*pExaScr->info->CheckComposite)(PictOpAdd, pSrc, pMask, pDst)))) {
	    ret = exaTryDriverCompositeRects(PictOpOutReverse, pSrc, pMask,
					     pDst, nrect, rects);
	    if (ret == 1) {
		op = PictOpAdd;
		ret = exaTryDriverCompositeRects(op, pSrc, pMask, pDst, nrect,
						 rects);
	    }
	}

	if (ret != 1) {
	    n = nrect;
	    r = rects;
	    while (n--) {
		ExaCheckComposite (op, pSrc, pMask, pDst,
				   r->xSrc, r->ySrc,
				   r->xMask, r->yMask,
				   r->xDst, r->yDst,
				   r->width, r->height);
		r++;
	    }
	}
d612 1
a612 1
    
d616 3
a618 3
	/* Now we have to flush the damage out from pendingDamage => damage 
	 * Calling DamageRegionProcessPending has that effect.
	 */
d620 1
a620 1
	DamageRegionProcessPending(pDst->pDrawable);
d625 9
a633 12
exaTryDriverComposite(CARD8		op,
		      PicturePtr	pSrc,
		      PicturePtr	pMask,
		      PicturePtr	pDst,
		      INT16		xSrc,
		      INT16		ySrc,
		      INT16		xMask,
		      INT16		yMask,
		      INT16		xDst,
		      INT16		yDst,
		      CARD16		width,
		      CARD16		height)
d635 1
a635 1
    ExaScreenPriv (pDst->pDrawable->pScreen);
d644 2
a645 2
	pSrcPix = exaGetDrawablePixmap(pSrc->pDrawable);
	pSrcExaPix = ExaGetPixmapPriv(pSrcPix);
d652 1
a652 1
	pMaskPix = exaGetDrawablePixmap(pMask->pDrawable);
d661 3
a663 4
	(pSrcExaPix && pSrcExaPix->accel_blocked) ||
	(pMaskExaPix && (pMaskExaPix->accel_blocked)))
    {
	return -1;
d670 2
a671 2
	xMask += pMask->pDrawable->x;
	yMask += pMask->pDrawable->y;
d675 2
a676 2
	xSrc += pSrc->pDrawable->x;
	ySrc += pSrc->pDrawable->y;
d680 2
a681 3
	!(*pExaScr->info->CheckComposite) (op, pSrc, pMask, pDst))
    {
	return -1;
d684 4
a687 4
    if (!miComputeCompositeRegion (&region, pSrc, pMask, pDst,
				   xSrc, ySrc, xMask, yMask, xDst, yDst,
				   width, height))
	return 1;
d689 1
a689 1
    exaGetDrawableDeltas (pDst->pDrawable, pDstPix, &dst_off_x, &dst_off_y);
d694 2
a695 2
	ExaMigrationRec pixmaps[3];
	int i = 0;
d697 21
a717 21
	pixmaps[i].as_dst = TRUE;
	pixmaps[i].as_src = exaOpReadsDestination(op);
	pixmaps[i].pPix = pDstPix;
	pixmaps[i].pReg = pixmaps[0].as_src ? NULL : &region;
	i++;

	if (pSrcPix) {
	    pixmaps[i].as_dst = FALSE;
	    pixmaps[i].as_src = TRUE;
	    pixmaps[i].pPix = pSrcPix;
	    pixmaps[i].pReg = NULL;
	    i++;
	}

	if (pMaskPix) {
	    pixmaps[i].as_dst = FALSE;
	    pixmaps[i].as_src = TRUE;
	    pixmaps[i].pPix = pMaskPix;
	    pixmaps[i].pReg = NULL;
	    i++;
	}
d719 1
a719 1
	exaDoMigration(pixmaps, i, TRUE);
d723 6
a728 5
	pSrcPix = exaGetOffscreenPixmap (pSrc->pDrawable, &src_off_x, &src_off_y);
	if (!pSrcPix) {
	    RegionUninit(&region);
	    return 0;
	}
d732 6
a737 6
	pMaskPix = exaGetOffscreenPixmap (pMask->pDrawable, &mask_off_x,
					  &mask_off_y);
	if (!pMaskPix) {
	    RegionUninit(&region);
	    return 0;
	}
d741 2
a742 2
	RegionUninit(&region);
	return 0;
d746 3
a748 4
					     pMaskPix, pDstPix))
    {
	RegionUninit(&region);
	return -1;
d760 10
a769 12
    while (nbox--)
    {
	(*pExaScr->info->Composite) (pDstPix,
				     pbox->x1 + xSrc,
				     pbox->y1 + ySrc,
				     pbox->x1 + xMask,
				     pbox->y1 + yMask,
				     pbox->x1,
				     pbox->y1,
				     pbox->x2 - pbox->x1,
				     pbox->y2 - pbox->y1);
	pbox++;
d829 9
a837 11
				  PicturePtr pSrc,
				  PicturePtr pMask,
				  PicturePtr pDst,
				  INT16 xSrc,
				  INT16 ySrc,
				  INT16 xMask,
				  INT16 yMask,
				  INT16 xDst,
				  INT16 yDst,
				  CARD16 width,
				  CARD16 height)
d839 1
a839 1
    ExaScreenPriv (pDst->pDrawable->pScreen);
d844 4
a847 5
	(!(*pExaScr->info->CheckComposite)(PictOpOutReverse, pSrc, pMask,
					   pDst) ||
	 !(*pExaScr->info->CheckComposite)(PictOpAdd, pSrc, pMask, pDst)))
    {
	return -1;
d855 1
a855 1
		 xDst, yDst, width, height);
d860 1
a860 1
		 xDst, yDst, width, height);
d866 8
a873 12
exaComposite(CARD8	op,
	     PicturePtr pSrc,
	     PicturePtr pMask,
	     PicturePtr pDst,
	     INT16	xSrc,
	     INT16	ySrc,
	     INT16	xMask,
	     INT16	yMask,
	     INT16	xDst,
	     INT16	yDst,
	     CARD16	width,
	     CARD16	height)
d875 1
a875 1
    ExaScreenPriv (pDst->pDrawable->pScreen);
d882 1
a882 1
	goto fallback;
d886 3
a888 3
	(xSrc + width) <= pSrc->pDrawable->width && ySrc >= 0 &&
	(ySrc + height) <= pSrc->pDrawable->height)
	    pSrc->repeat = 0;
d891 1
a891 1
	(op == PictOpSrc || (op == PictOpOver && !PICT_FORMAT_A(pSrc->format))))
d893 101
a993 103
	if (pSrc->pDrawable ?
	    (pSrc->pDrawable->width == 1 && pSrc->pDrawable->height == 1 &&
	     pSrc->repeat) :
	    (pSrc->pSourcePict->type == SourcePictTypeSolidFill))
	{
	    ret = exaTryDriverSolidFill(pSrc, pDst, xSrc, ySrc, xDst, yDst,
					width, height);
	    if (ret == 1)
		goto done;
	} else if (pSrc->pDrawable && !pSrc->transform &&
	    ((op == PictOpSrc &&
	      (pSrc->format == pDst->format ||
	       (PICT_FORMAT_COLOR(pDst->format) &&
		PICT_FORMAT_COLOR(pSrc->format) &&
		pDst->format == PICT_FORMAT(PICT_FORMAT_BPP(pSrc->format),
					    PICT_FORMAT_TYPE(pSrc->format),
					    0,
					    PICT_FORMAT_R(pSrc->format),
					    PICT_FORMAT_G(pSrc->format),
					    PICT_FORMAT_B(pSrc->format))))) ||
	     (op == PictOpOver && pSrc->format == pDst->format &&
	      !PICT_FORMAT_A(pSrc->format))))
	{
	    if (!pSrc->repeat && xSrc >= 0 && ySrc >= 0 &&
		(xSrc + width <= pSrc->pDrawable->width) &&
		(ySrc + height <= pSrc->pDrawable->height))
	    {
		Bool ret;
		xDst += pDst->pDrawable->x;
		yDst += pDst->pDrawable->y;
		xSrc += pSrc->pDrawable->x;
		ySrc += pSrc->pDrawable->y;

		if (!miComputeCompositeRegion (&region, pSrc, pMask, pDst,
					       xSrc, ySrc, xMask, yMask, xDst,
					       yDst, width, height))
		    goto done;

		ret = exaHWCopyNtoN(pSrc->pDrawable, pDst->pDrawable, NULL,
			     RegionRects(&region), RegionNumRects(&region),
			     xSrc - xDst, ySrc - yDst, FALSE, FALSE);
		RegionUninit(&region);

		/* Reset values to their original values. */
		xDst -= pDst->pDrawable->x;
		yDst -= pDst->pDrawable->y;
		xSrc -= pSrc->pDrawable->x;
		ySrc -= pSrc->pDrawable->y;

		if (!ret)
		    goto fallback;

		goto done;
	    }

	    if (pSrc->repeat && pSrc->repeatType == RepeatNormal &&
		pSrc->pDrawable->type == DRAWABLE_PIXMAP)
	    {
		DDXPointRec patOrg;

		/* Let's see if the driver can do the repeat in one go */
		if (pExaScr->info->PrepareComposite && !pSrc->alphaMap &&
		    !pDst->alphaMap)
		{
		    ret = exaTryDriverComposite(op, pSrc, pMask, pDst, xSrc,
						ySrc, xMask, yMask, xDst, yDst,
						width, height);
		    if (ret == 1)
			goto done;
		}

		/* Now see if we can use exaFillRegionTiled() */
		xDst += pDst->pDrawable->x;
		yDst += pDst->pDrawable->y;
		xSrc += pSrc->pDrawable->x;
		ySrc += pSrc->pDrawable->y;

		if (!miComputeCompositeRegion (&region, pSrc, pMask, pDst, xSrc,
					       ySrc, xMask, yMask, xDst, yDst,
					       width, height))
		    goto done;

		/* pattern origin is the point in the destination drawable
		 * corresponding to (0,0) in the source */
		patOrg.x = xDst - xSrc;
		patOrg.y = yDst - ySrc;

		ret = exaFillRegionTiled(pDst->pDrawable, &region,
					 (PixmapPtr)pSrc->pDrawable,
					 &patOrg, FB_ALLONES, GXcopy, CT_NONE);

		RegionUninit(&region);

		if (ret)
		    goto done;

		/* Let's be correct and restore the variables to their original state. */
		xDst -= pDst->pDrawable->x;
		yDst -= pDst->pDrawable->y;
		xSrc -= pSrc->pDrawable->x;
		ySrc -= pSrc->pDrawable->y;
	    }
	}
d998 3
a1000 3
	xMask >= 0 && (xMask + width) <= pMask->pDrawable->width &&
	yMask >= 0 && (yMask + height) <= pMask->pDrawable->height)
	    pMask->repeat = 0;
d1003 2
a1004 3
	!pSrc->alphaMap && (!pMask || !pMask->alphaMap) && !pDst->alphaMap)
    {
	Bool isSrcSolid;
d1006 26
a1031 26
	ret = exaTryDriverComposite(op, pSrc, pMask, pDst, xSrc, ySrc, xMask,
				    yMask, xDst, yDst, width, height);
	if (ret == 1)
	    goto done;

	/* For generic masks and solid src pictures, mach64 can do Over in two
	 * passes, similar to the component-alpha case.
	 */
	isSrcSolid = pSrc->pDrawable ?
	    (pSrc->pDrawable->width == 1 && pSrc->pDrawable->height == 1 &&
	     pSrc->repeat) :
	    (pSrc->pSourcePict->type == SourcePictTypeSolidFill);

	/* If we couldn't do the Composite in a single pass, and it was a
	 * component-alpha Over, see if we can do it in two passes with
	 * an OutReverse and then an Add.
	 */
	if (ret == -1 && op == PictOpOver && pMask &&
	    (pMask->componentAlpha || isSrcSolid)) {
	    ret = exaTryMagicTwoPassCompositeHelper(op, pSrc, pMask, pDst,
						    xSrc, ySrc,
						    xMask, yMask, xDst, yDst,
						    width, height);
	    if (ret == 1)
		goto done;
	}
d1034 1
a1034 1
fallback:
d1036 1
a1036 1
    exaPrintCompositeFallback (op, pSrc, pMask, pDst);
d1039 2
a1040 2
    ExaCheckComposite (op, pSrc, pMask, pDst, xSrc, ySrc,
		      xMask, yMask, xDst, yDst, width, height);
d1042 1
a1042 1
done:
d1045 1
a1045 1
	pMask->repeat = saveMaskRepeat;
d1056 3
a1058 5
exaCreateAlphaPicture (ScreenPtr     pScreen,
                       PicturePtr    pDst,
                       PictFormatPtr pPictFormat,
                       CARD16        width,
                       CARD16        height)
d1060 5
a1064 5
    PixmapPtr	    pPixmap;
    PicturePtr	    pPicture;
    GCPtr	    pGC;
    int		    error;
    xRectangle	    rect;
d1067 1
a1067 1
	return 0;
d1069 7
a1075 8
    if (!pPictFormat)
    {
	if (pDst->polyEdge == PolyEdgeSharp)
	    pPictFormat = PictureMatchFormat (pScreen, 1, PICT_a1);
	else
	    pPictFormat = PictureMatchFormat (pScreen, 8, PICT_a8);
	if (!pPictFormat)
	    return 0;
d1079 1
a1079 1
					pPictFormat->depth, 0);
d1081 5
a1085 6
	return 0;
    pGC = GetScratchGC (pPixmap->drawable.depth, pScreen);
    if (!pGC)
    {
	(*pScreen->DestroyPixmap) (pPixmap);
	return 0;
d1087 1
a1087 1
    ValidateGC (&pPixmap->drawable, pGC);
d1092 5
a1096 5
    ExaCheckPolyFillRect (&pPixmap->drawable, pGC, 1, &rect);
    exaPixmapDirty (pPixmap, 0, 0, width, height);
    FreeScratchGC (pGC);
    pPicture = CreatePicture (0, &pPixmap->drawable, pPictFormat,
			      0, 0, serverClient, &error);
d1115 3
a1117 3
exaTrapezoids (CARD8 op, PicturePtr pSrc, PicturePtr pDst,
               PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
               int ntrap, xTrapezoid *traps)
d1119 3
a1121 3
    ScreenPtr		pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
    BoxRec		bounds;
d1124 37
a1160 38
	PicturePtr	pPicture;
	INT16		xDst, yDst;
	INT16		xRel, yRel;

	miTrapezoidBounds (ntrap, traps, &bounds);

	if (bounds.y1 >= bounds.y2 || bounds.x1 >= bounds.x2)
	    return;

	xDst = traps[0].left.p1.x >> 16;
	yDst = traps[0].left.p1.y >> 16;

	pPicture = exaCreateAlphaPicture (pScreen, pDst, maskFormat,
	                                  bounds.x2 - bounds.x1,
	                                  bounds.y2 - bounds.y1);
	if (!pPicture)
	    return;

	exaPrepareAccess(pPicture->pDrawable, EXA_PREPARE_DEST);
	for (; ntrap; ntrap--, traps++)
	    (*ps->RasterizeTrapezoid) (pPicture, traps,
				       -bounds.x1, -bounds.y1);
	exaFinishAccess(pPicture->pDrawable, EXA_PREPARE_DEST);

	xRel = bounds.x1 + xSrc - xDst;
	yRel = bounds.y1 + ySrc - yDst;
	CompositePicture (op, pSrc, pPicture, pDst,
			  xRel, yRel, 0, 0, bounds.x1, bounds.y1,
			  bounds.x2 - bounds.x1,
			  bounds.y2 - bounds.y1);
	FreePicture (pPicture, 0);
    } else {
	if (pDst->polyEdge == PolyEdgeSharp)
	    maskFormat = PictureMatchFormat (pScreen, 1, PICT_a1);
	else
	    maskFormat = PictureMatchFormat (pScreen, 8, PICT_a8);
	for (; ntrap; ntrap--, traps++)
	    exaTrapezoids (op, pSrc, pDst, maskFormat, xSrc, ySrc, 1, traps);
d1178 3
a1180 3
exaTriangles (CARD8 op, PicturePtr pSrc, PicturePtr pDst,
	      PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
	      int ntri, xTriangle *tris)
d1182 3
a1184 3
    ScreenPtr		pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
    BoxRec		bounds;
d1187 34
a1220 33
	PicturePtr	pPicture;
	INT16		xDst, yDst;
	INT16		xRel, yRel;

	miTriangleBounds (ntri, tris, &bounds);

	if (bounds.y1 >= bounds.y2 || bounds.x1 >= bounds.x2)
	    return;

	xDst = tris[0].p1.x >> 16;
	yDst = tris[0].p1.y >> 16;

	pPicture = exaCreateAlphaPicture (pScreen, pDst, maskFormat,
					  bounds.x2 - bounds.x1,
					  bounds.y2 - bounds.y1);
	if (!pPicture)
	    return;

	exaPrepareAccess(pPicture->pDrawable, EXA_PREPARE_DEST);
	(*ps->AddTriangles) (pPicture, -bounds.x1, -bounds.y1, ntri, tris);
	exaFinishAccess(pPicture->pDrawable, EXA_PREPARE_DEST);

	xRel = bounds.x1 + xSrc - xDst;
	yRel = bounds.y1 + ySrc - yDst;
	CompositePicture (op, pSrc, pPicture, pDst,
			  xRel, yRel, 0, 0, bounds.x1, bounds.y1,
			  bounds.x2 - bounds.x1, bounds.y2 - bounds.y1);
	FreePicture (pPicture, 0);
    } else {
	if (pDst->polyEdge == PolyEdgeSharp)
	    maskFormat = PictureMatchFormat (pScreen, 1, PICT_a1);
	else
	    maskFormat = PictureMatchFormat (pScreen, 8, PICT_a8);
d1222 2
a1223 2
	for (; ntri; ntri--, tris++)
	    exaTriangles (op, pSrc, pDst, maskFormat, xSrc, ySrc, 1, tris);
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a32 1
#ifdef RENDER
d295 1
a295 1
    REGION_TRANSLATE(pScreen, &region, dst_off_x, dst_off_y);
d308 1
a308 1
	REGION_UNINIT(pDst->pDrawable->pScreen, &region);
d323 1
a323 1
	REGION_UNINIT(pDst->pDrawable->pScreen, &region);
d329 1
a329 1
	REGION_UNINIT(pDst->pDrawable->pScreen, &region);
d333 2
a334 2
    nbox = REGION_NUM_RECTS(&region);
    pbox = REGION_RECTS(&region);
d345 1
a345 1
    REGION_UNINIT(pDst->pDrawable->pScreen, &region);
d472 1
a472 1
	REGION_TRANSLATE(pScreen, &region, dst_off_x, dst_off_y);
d474 2
a475 2
	nbox = REGION_NUM_RECTS(&region);
	pbox = REGION_RECTS(&region);
d497 1
a497 1
	REGION_UNINIT(pDst->pDrawable->pScreen, &region);
d578 1
a578 1
	REGION_INIT(pScreen, &region, &box, 1);
d582 1
a582 1
	REGION_UNINIT(pScreen, &region);
d706 1
a706 1
    REGION_TRANSLATE(pScreen, &region, dst_off_x, dst_off_y);
d740 1
a740 1
	    REGION_UNINIT(pDst->pDrawable->pScreen, &region);
d749 1
a749 1
	    REGION_UNINIT(pDst->pDrawable->pScreen, &region);
d755 1
a755 1
	REGION_UNINIT(pDst->pDrawable->pScreen, &region);
d762 1
a762 1
	REGION_UNINIT(pDst->pDrawable->pScreen, &region);
d766 2
a767 2
    nbox = REGION_NUM_RECTS(&region);
    pbox = REGION_RECTS(&region);
d791 1
a791 1
    REGION_UNINIT(pDst->pDrawable->pScreen, &region);
d956 1
a956 1
			     REGION_RECTS(&region), REGION_NUM_RECTS(&region),
d958 1
a958 1
		REGION_UNINIT(pDst->pDrawable->pScreen, &region);
d1008 1
a1008 1
		REGION_UNINIT(pDst->pDrawable->pScreen, &region);
a1073 1
#endif
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d57 6
d80 8
a87 1
    loc = exaGetOffscreenPixmap(pict->pDrawable, &temp, &temp) ? 's' : 'm';
d89 2
a90 3
    snprintf(size, 20, "%dx%d%s", pict->pDrawable->width,
	     pict->pDrawable->height, pict->repeat ?
	     " R" : "");
d153 1
a153 1
		    CARD32	format)
d160 2
a161 1
    if (!PICT_FORMAT_COLOR(format))
d164 9
a172 16
    rbits = PICT_FORMAT_R(format);
    gbits = PICT_FORMAT_G(format);
    bbits = PICT_FORMAT_B(format);
    abits = PICT_FORMAT_A(format);

    if (PICT_FORMAT_TYPE(format) == PICT_TYPE_ARGB) {
	bshift = 0;
	gshift = bbits;
	rshift = gshift + gbits;
	ashift = rshift + rbits;
    } else {  /* PICT_TYPE_ABGR */
	rshift = 0;
	gshift = rbits;
	bshift = gshift + gbits;
	ashift = bshift + bbits;
    }
d188 2
a189 1
		    CARD32	format)
d194 1
a194 1
    if (!PICT_FORMAT_COLOR(format))
d202 8
a209 1
    if (PICT_FORMAT_TYPE(format) == PICT_TYPE_ARGB) {
d211 27
a237 26
	gshift = bbits;
	rshift = gshift + gbits;
	ashift = rshift + rbits;
    } else {  /* PICT_TYPE_ABGR */
	rshift = 0;
	gshift = rbits;
	bshift = gshift + gbits;
	ashift = bshift + bbits;
    }

    *red = ((pixel >> rshift ) & ((1 << rbits) - 1)) << (16 - rbits);
    while (rbits < 16) {
	*red |= *red >> rbits;
	rbits <<= 1;
    }

    *green = ((pixel >> gshift ) & ((1 << gbits) - 1)) << (16 - gbits);
    while (gbits < 16) {
	*green |= *green >> gbits;
	gbits <<= 1;
    }

    *blue = ((pixel >> bshift ) & ((1 << bbits) - 1)) << (16 - bbits);
    while (bbits < 16) {
	*blue |= *blue >> bbits;
	bbits <<= 1;
d268 1
a268 1
    ExaPixmapPrivPtr pSrcExaPix, pDstExaPix;
a270 1
    ExaMigrationRec pixmaps[1];
a272 3
    pSrcPix = exaGetDrawablePixmap (pSrc->pDrawable);

    pSrcExaPix = ExaGetPixmapPriv(pSrcPix);
d275 1
a275 1
    /* Check whether the accelerator can use these pixmaps.
d277 1
a277 1
    if (pSrcExaPix->accel_blocked || pDstExaPix->accel_blocked)
d284 4
a287 2
    xSrc += pSrc->pDrawable->x;
    ySrc += pSrc->pDrawable->y;
d298 5
a302 12
    pixel = exaGetPixmapFirstPixel (pSrcPix);

    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = FALSE;
    pixmaps[0].pPix = pDstPix;
    pixmaps[0].pReg = &region;
    exaDoMigration(pixmaps, 1, TRUE);

    if (!exaPixmapIsOffscreen(pDstPix)) {
	REGION_UNINIT(pDst->pDrawable->pScreen, &region);
	return 0;
    }
d305 3
a307 1
			 pSrc->format))
d313 11
a323 3
    if (!exaGetPixelFromRGBA(&pixel, red, green, blue, alpha,
			pDst->format))
    {
d325 1
a325 1
	return -1;
d353 1
d359 4
a362 5
    int src_off_x, src_off_y, dst_off_x, dst_off_y;
    PixmapPtr pSrcPix, pDstPix;
    ExaPixmapPrivPtr pSrcExaPix, pDstExaPix;
    struct _Pixmap scratch;
    ExaMigrationRec pixmaps[2];
d367 9
a375 2
    pSrcPix = exaGetDrawablePixmap(pSrc->pDrawable);
    pSrcExaPix = ExaGetPixmapPriv(pSrcPix);
d384 3
a386 2
    if (pSrcExaPix->accel_blocked ||
	pDstExaPix->accel_blocked)
d392 1
a392 1
	!(*pExaScr->info->CheckComposite) (op, pSrc, NULL, pDst))
a395 2
    
    exaGetDrawableDeltas (pDst->pDrawable, pDstPix, &dst_off_x, &dst_off_y);
d397 28
a424 9
    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = exaOpReadsDestination(op);
    pixmaps[0].pPix = pDstPix;
    pixmaps[0].pReg = NULL;
    pixmaps[1].as_dst = FALSE;
    pixmaps[1].as_src = TRUE;
    pixmaps[1].pPix = pSrcPix;
    pixmaps[1].pReg = NULL;
    exaDoMigration(pixmaps, 2, TRUE);
d426 2
a427 2
    pSrcPix = exaGetOffscreenPixmap (pSrc->pDrawable, &src_off_x, &src_off_y);
    if (!exaPixmapIsOffscreen(pDstPix))
d429 5
a433 6
    
    if (!pSrcPix && pExaScr->info->UploadToScratch)
    {
	pSrcPix = exaGetDrawablePixmap (pSrc->pDrawable);
	if ((*pExaScr->info->UploadToScratch) (pSrcPix, &scratch))
	    pSrcPix = &scratch;
d436 5
a440 2
    if (!pSrcPix)
	return 0;
d442 2
a443 2
    if (!(*pExaScr->info->PrepareComposite) (op, pSrc, NULL, pDst, pSrcPix,
					     NULL, pDstPix))
d450 4
a453 3
	INT16 xSrc = rects->xSrc + pSrc->pDrawable->x;
	INT16 ySrc = rects->ySrc + pSrc->pDrawable->y;

d458 12
a469 2
	if (!miComputeCompositeRegion (&region, pSrc, NULL, pDst,
				       xSrc, ySrc, 0, 0, xDst, yDst,
d478 2
d488 2
a489 1
					 0, 0,
d511 4
a514 5
 * operation. This is specialized for building a glyph mask: we don'y
 * have a mask argument because we don't need it for that, and we
 * don't have he special-case fallbacks found in exaComposite() - if the
 * driver can support it, we use the driver functionality, otherwise we
 * fallback straight to software.
d519 1
d524 1
a524 2
    PixmapPtr pPixmap = exaGetDrawablePixmap(pDst->pDrawable);
    ExaPixmapPriv(pPixmap);
d527 6
a532 2
    
    if (pExaPixmap->pDamage) {
d543 1
a543 1
	 * offscreen and onscreen.
d589 2
d592 29
a620 11
    
    if (exaTryDriverCompositeRects(op, pSrc, pDst, nrect, rects) != 1) {
	n = nrect;
	r = rects;
	while (n--) {
	    ExaCheckComposite (op, pSrc, NULL, pDst,
			       r->xSrc, r->ySrc,
			       0, 0,
			       r->xDst, r->yDst,
			       r->width, r->height);
	    r++;
d626 1
a626 1
    if (pExaPixmap->pDamage) {
d654 2
a655 4
    PixmapPtr pSrcPix, pMaskPix = NULL, pDstPix;
    ExaPixmapPrivPtr pSrcExaPix, pMaskExaPix = NULL, pDstExaPix;
    struct _Pixmap scratch;
    ExaMigrationRec pixmaps[3];
d657 4
a660 2
    pSrcPix = exaGetDrawablePixmap(pSrc->pDrawable);
    pSrcExaPix = ExaGetPixmapPriv(pSrcPix);
d665 1
a665 1
    if (pMask) {
d674 3
a676 3
    if (pSrcExaPix->accel_blocked ||
	pDstExaPix->accel_blocked ||
	(pMask && (pMaskExaPix->accel_blocked)))
d684 1
a684 1
    if (pMask) {
d689 4
a692 2
    xSrc += pSrc->pDrawable->x;
    ySrc += pSrc->pDrawable->y;
d709 35
a743 16
    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = exaOpReadsDestination(op);
    pixmaps[0].pPix = pDstPix;
    pixmaps[0].pReg = pixmaps[0].as_src ? NULL : &region;
    pixmaps[1].as_dst = FALSE;
    pixmaps[1].as_src = TRUE;
    pixmaps[1].pPix = pSrcPix;
    pixmaps[1].pReg = NULL;
    if (pMask) {
	pixmaps[2].as_dst = FALSE;
	pixmaps[2].as_src = TRUE;
	pixmaps[2].pPix = pMaskPix;
	pixmaps[2].pReg = NULL;
	exaDoMigration(pixmaps, 3, TRUE);
    } else {
	exaDoMigration(pixmaps, 2, TRUE);
d746 1
a746 2
    pSrcPix = exaGetOffscreenPixmap (pSrc->pDrawable, &src_off_x, &src_off_y);
    if (pMask)
d749 4
a752 4

    if (!exaPixmapIsOffscreen(pDstPix)) {
	REGION_UNINIT(pDst->pDrawable->pScreen, &region);
	return 0;
d755 1
a755 11
    if (!pSrcPix && (!pMask || pMaskPix) && pExaScr->info->UploadToScratch) {
	pSrcPix = exaGetDrawablePixmap (pSrc->pDrawable);
	if ((*pExaScr->info->UploadToScratch) (pSrcPix, &scratch))
	    pSrcPix = &scratch;
    } else if (pSrcPix && pMask && !pMaskPix && pExaScr->info->UploadToScratch) {
	pMaskPix = exaGetDrawablePixmap (pMask->pDrawable);
	if ((*pExaScr->info->UploadToScratch) (pMaskPix, &scratch))
	    pMaskPix = &scratch;
    }

    if (!pSrcPix || (pMask && !pMaskPix)) {
d906 1
a906 6
    /* We currently don't support acceleration of gradients, or other pictures
     * with a NULL pDrawable.
     */
    if (pExaScr->swappedOut ||
	pSrc->pDrawable == NULL || (pMask != NULL && pMask->pDrawable == NULL))
    {
a907 1
    }
d910 1
a910 1
    if (pSrc->repeat && !pSrc->transform && xSrc >= 0 &&
d915 2
a916 1
    if (!pMask)
d918 22
a939 7
      if ((op == PictOpSrc &&
	   ((pSrc->format == pDst->format) ||
	    (pSrc->format==PICT_a8r8g8b8 && pDst->format==PICT_x8r8g8b8) ||
	    (pSrc->format==PICT_a8b8g8r8 && pDst->format==PICT_x8b8g8r8))) ||
	  (op == PictOpOver && !pSrc->alphaMap && !pDst->alphaMap &&
	   pSrc->format == pDst->format &&
	   (pSrc->format==PICT_x8r8g8b8 || pSrc->format==PICT_x8b8g8r8)))
d941 3
a943 12
	    if (pSrc->pDrawable->width == 1 &&
		pSrc->pDrawable->height == 1 &&
		pSrc->repeat)
	    {
		ret = exaTryDriverSolidFill(pSrc, pDst, xSrc, ySrc, xDst, yDst,
					    width, height);
		if (ret == 1)
		    goto done;
	    }
	    else if (pSrc->pDrawable != NULL &&
		     !pSrc->repeat &&
		     !pSrc->transform)
d945 1
d956 1
a956 2

		exaCopyNtoN (pSrc->pDrawable, pDst->pDrawable, NULL,
d958 1
a958 2
			     xSrc - xDst, ySrc - yDst,
			     FALSE, FALSE, 0, NULL);
d960 10
d972 3
a974 4
	    else if (pSrc->pDrawable != NULL &&
		     pSrc->pDrawable->type == DRAWABLE_PIXMAP &&
		     !pSrc->transform &&
		     pSrc->repeatType == RepeatNormal)
d1024 3
a1026 3
    if (pMask && pMask->repeat && !pMask->transform && xMask >= 0 &&
	(xMask + width) <= pMask->pDrawable->width && yMask >= 0 &&
	(yMask + height) <= pMask->pDrawable->height)
d1042 4
a1045 3
	isSrcSolid = pSrc->pDrawable->width == 1 &&
		     pSrc->pDrawable->height == 1 &&
		     pSrc->repeat;
a1164 1

@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d335 221
d908 1
a908 1
					 &patOrg, FB_ALLONES, GXcopy);
d914 6
a1054 1
    Bool		direct = op == PictOpAdd && miIsSolidAlpha (pSrc);
d1056 5
a1060 1
    if (maskFormat || direct) {
a1064 1
    }
a1065 38
    /*
     * Check for solid alpha add
     */
    if (direct)
    {
	DrawablePtr pDraw = pDst->pDrawable;
	PixmapPtr pixmap = exaGetDrawablePixmap (pDraw);
	ExaPixmapPriv (pixmap);
	RegionRec migration;
	RegionPtr pending_damage = DamagePendingRegion(pExaPixmap->pDamage);
	int xoff, yoff;

	exaGetDrawableDeltas(pDraw, pixmap, &xoff, &yoff);

	xoff += pDraw->x;
	yoff += pDraw->y;

	bounds.x1 += xoff;
	bounds.y1 += yoff;
	bounds.x2 += xoff;
	bounds.y2 += yoff;

	REGION_INIT(pScreen, &migration, &bounds, 1);
	REGION_UNION(pScreen, pending_damage, pending_damage, &migration);
	REGION_UNINIT(pScreen, &migration);

	exaPrepareAccess(pDraw, EXA_PREPARE_DEST);

	for (; ntrap; ntrap--, traps++)
	    (*ps->RasterizeTrapezoid) (pDst, traps, 0, 0);

	exaFinishAccess(pDraw, EXA_PREPARE_DEST);
    }
    else if (maskFormat)
    {
	PicturePtr	pPicture;
	INT16		xDst, yDst;
	INT16		xRel, yRel;
d1089 1
a1089 3
    }
    else
    {
a1119 1
    Bool		direct = op == PictOpAdd && miIsSolidAlpha (pSrc);
d1121 5
a1125 1
    if (maskFormat || direct) {
a1129 1
    }
a1130 36
    /*
     * Check for solid alpha add
     */
    if (direct)
    {
	DrawablePtr pDraw = pDst->pDrawable;
	PixmapPtr pixmap = exaGetDrawablePixmap (pDraw);
	ExaPixmapPriv (pixmap);
	RegionRec migration;
	RegionPtr pending_damage = DamagePendingRegion(pExaPixmap->pDamage);
	int xoff, yoff;

	exaGetDrawableDeltas(pDraw, pixmap, &xoff, &yoff);

	xoff += pDraw->x;
	yoff += pDraw->y;

	bounds.x1 += xoff;
	bounds.y1 += yoff;
	bounds.x2 += xoff;
	bounds.y2 += yoff;

	REGION_INIT(pScreen, &migration, &bounds, 1);
	REGION_UNION(pScreen, pending_damage, pending_damage, &migration);
	REGION_UNINIT(pScreen, &migration);

	exaPrepareAccess(pDraw, EXA_PREPARE_DEST);
	(*ps->AddTriangles) (pDst, 0, 0, ntri, tris);
	exaFinishAccess(pDraw, EXA_PREPARE_DEST);
    }
    else if (maskFormat)
    {
	PicturePtr	pPicture;
	INT16		xDst, yDst;
	INT16		xRel, yRel;
	
d1143 1
a1143 1
	
d1150 1
a1150 3
    }
    else
    {
d1155 1
a1155 1
	
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d54 3
d117 1
a117 1
static Bool
d253 1
d258 13
d281 4
a284 1
    pSrcPix = exaGetDrawablePixmap (pSrc->pDrawable);
d289 2
a290 1
    pixmaps[0].pPix = exaGetDrawablePixmap (pDst->pDrawable);
d293 1
a293 2
    pDstPix = exaGetOffscreenPixmap (pDst->pDrawable, &dst_off_x, &dst_off_y);
    if (!pDstPix) {
d323 1
a323 3
	(*pExaScr->info->Solid) (pDstPix,
				 pbox->x1 + dst_off_x, pbox->y1 + dst_off_y,
				 pbox->x2 + dst_off_x, pbox->y2 + dst_off_y);
d354 1
d359 2
d362 3
a364 1
    if (pMask)
d366 2
d369 3
a371 3
    /* Bail if we might exceed coord limits by rendering from/to these.  We
     * should really be making some scratch pixmaps with offsets and coords
     * adjusted to deal with this, but it hasn't been done yet.
d373 3
a375 6
    if (pSrcPix->drawable.width > pExaScr->info->maxX ||
	pSrcPix->drawable.height > pExaScr->info->maxY ||
	pDstPix->drawable.width > pExaScr->info->maxX ||
	pDstPix->drawable.height > pExaScr->info->maxY || 
	(pMask && (pMaskPix->drawable.width > pExaScr->info->maxX ||
		   pMaskPix->drawable.height > pExaScr->info->maxY)))
d391 6
d402 3
a404 6
    if (pExaScr->info->CheckComposite &&
	!(*pExaScr->info->CheckComposite) (op, pSrc, pMask, pDst))
    {
	REGION_UNINIT(pDst->pDrawable->pScreen, &region);
	return -1;
    }
d408 2
a409 1
    pixmaps[0].pPix = exaGetDrawablePixmap (pDst->pDrawable);
d412 2
a413 1
    pixmaps[1].pPix = exaGetDrawablePixmap (pSrc->pDrawable);
d417 2
a418 1
	pixmaps[2].pPix = exaGetDrawablePixmap (pMask->pDrawable);
a427 1
    pDstPix = exaGetOffscreenPixmap (pDst->pDrawable, &dst_off_x, &dst_off_y);
d429 1
a429 1
    if (!pDstPix) {
d459 2
a460 2
    xMask -= xDst;
    yMask -= yDst;
d462 2
a463 2
    xSrc -= xDst;
    ySrc -= yDst;
d468 6
a473 6
				     pbox->x1 + xSrc + src_off_x,
				     pbox->y1 + ySrc + src_off_y,
				     pbox->x1 + xMask + mask_off_x,
				     pbox->y1 + yMask + mask_off_y,
				     pbox->x1 + dst_off_x,
				     pbox->y1 + dst_off_y,
a548 3
    DrawablePtr pDstDraw = pDst->pDrawable;
    PixmapPtr pDstPixmap = exaGetDrawablePixmap(pDstDraw);
    int xoff, yoff;
a566 6
    exaGetDrawableDeltas(pDstDraw, pDstPixmap, &xoff, &yoff);
    xoff += pDstDraw->x;
    yoff += pDstDraw->y;
    exaPixmapDirty(pDstPixmap, xDst + xoff, yDst + yoff, xDst + xoff + width,
		   yDst + yoff + height);

d593 1
a593 22
    ExaMigrationRec pixmaps[3];
    int npixmaps = 1;
    PixmapPtr pSrcPixmap = NULL;

    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = exaOpReadsDestination(op);
    pixmaps[0].pPix = exaGetDrawablePixmap (pDst->pDrawable);

    if (pSrc->pDrawable) {
	pSrcPixmap = exaGetDrawablePixmap (pSrc->pDrawable);
	pixmaps[npixmaps].as_dst = FALSE;
	pixmaps[npixmaps].as_src = TRUE;
	pixmaps[npixmaps].pPix = pSrcPixmap;
	npixmaps++;
    }

    if (pMask && pMask->pDrawable) {
	pixmaps[npixmaps].as_dst = FALSE;
	pixmaps[npixmaps].as_src = TRUE;
	pixmaps[npixmaps].pPix = exaGetDrawablePixmap (pMask->pDrawable);
	npixmaps++;
    }
d629 3
a631 1
	    else if (pSrcPixmap && !pSrc->repeat && !pSrc->transform)
a632 2
		RegionRec	region;

d651 3
a653 1
	    else if (pSrcPixmap && !pSrc->transform &&
d656 1
a656 2
		RegionRec region;
		DDXPointRec srcOrg;
d680 8
a687 5
		srcOrg.x = (xSrc - xDst) % pSrcPixmap->drawable.width;
		srcOrg.y = (ySrc - yDst) % pSrcPixmap->drawable.height;

		ret = exaFillRegionTiled(pDst->pDrawable, &region, pSrcPixmap,
					 &srcOrg, FB_ALLONES, GXcopy);
a703 2
	(!pSrc->repeat || pSrc->repeatType == RepeatNormal) &&
	(!pMask || !pMask->repeat || pMask->repeatType == RepeatNormal) &&
a739 1
    exaDoMigration(pixmaps, npixmaps, FALSE);
d755 1
a755 1
 * See the comments about exaTrapezoids.
d784 1
a784 1
					pPictFormat->depth);
d827 9
d840 1
a840 1
    if (op == PictOpAdd && miIsSolidAlpha (pSrc))
d842 23
d867 2
a872 1
	BoxRec		bounds;
a878 3
	miTrapezoidBounds (ntrap, traps, &bounds);
	if (bounds.y1 >= bounds.y2 || bounds.x1 >= bounds.x2)
	    return;
d884 2
d889 2
a909 2
#define NeedsComponent(f) (PICT_FORMAT_A(f) != 0 && PICT_FORMAT_RGB(f) != 0)

d911 8
a918 1
 * exaRasterizeTrapezoid is just a wrapper around the software implementation.
d920 2
a921 3
 * The trapezoid specification is basically too hard to be done in hardware (at
 * the very least, without programmability), so we just do the appropriate
 * Prepare/FinishAccess for it before using fbtrap.c.
d924 3
a926 2
exaRasterizeTrapezoid (PicturePtr pPicture, xTrapezoid  *trap,
		       int x_off, int y_off)
d928 4
a931 17
    DrawablePtr pDraw = pPicture->pDrawable;
    ExaMigrationRec pixmaps[1];
    int xoff, yoff;

    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = TRUE;
    pixmaps[0].pPix = exaGetDrawablePixmap (pDraw);
    exaDoMigration(pixmaps, 1, FALSE);

    exaPrepareAccess(pDraw, EXA_PREPARE_DEST);
    fbRasterizeTrapezoid(pPicture, trap, x_off, y_off);
    exaGetDrawableDeltas(pDraw, pixmaps[0].pPix, &xoff, &yoff);
    exaPixmapDirty(pixmaps[0].pPix, pDraw->x + xoff, pDraw->y + yoff,
		   pDraw->x + xoff + pDraw->width,
		   pDraw->y + yoff + pDraw->height);
    exaFinishAccess(pDraw, EXA_PREPARE_DEST);
}
d933 2
a934 11
/**
 * exaAddTriangles does migration and syncing before dumping down to the
 * software implementation.
 */
void
exaAddTriangles (PicturePtr pPicture, INT16 x_off, INT16 y_off, int ntri,
		 xTriangle *tris)
{
    DrawablePtr pDraw = pPicture->pDrawable;
    ExaMigrationRec pixmaps[1];
    int xoff, yoff;
d936 2
a937 82
    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = TRUE;
    pixmaps[0].pPix = exaGetDrawablePixmap (pDraw);
    exaDoMigration(pixmaps, 1, FALSE);

    exaPrepareAccess(pDraw, EXA_PREPARE_DEST);
    fbAddTriangles(pPicture, x_off, y_off, ntri, tris);
    exaGetDrawableDeltas(pDraw, pixmaps[0].pPix, &xoff, &yoff);
    exaPixmapDirty(pixmaps[0].pPix, pDraw->x + xoff, pDraw->y + yoff,
		   pDraw->x + xoff + pDraw->width,
		   pDraw->y + yoff + pDraw->height);
    exaFinishAccess(pDraw, EXA_PREPARE_DEST);
}

/**
 * Returns TRUE if the glyphs in the lists intersect.  Only checks based on
 * bounding box, which appears to be good enough to catch most cases at least.
 */
static Bool
exaGlyphsIntersect(int nlist, GlyphListPtr list, GlyphPtr *glyphs)
{
    int x1, x2, y1, y2;
    int n;
    GlyphPtr glyph;
    int x, y;
    BoxRec extents;
    Bool first = TRUE;
    
    x = 0;
    y = 0;
    while (nlist--) {
	x += list->xOff;
	y += list->yOff;
	n = list->len;
	list++;
	while (n--) {
	    glyph = *glyphs++;

	    if (glyph->info.width == 0 || glyph->info.height == 0) {
		x += glyph->info.xOff;
		y += glyph->info.yOff;
		continue;
	    }

	    x1 = x - glyph->info.x;
	    if (x1 < MINSHORT)
		x1 = MINSHORT;
	    y1 = y - glyph->info.y;
	    if (y1 < MINSHORT)
		y1 = MINSHORT;
	    x2 = x1 + glyph->info.width;
	    if (x2 > MAXSHORT)
		x2 = MAXSHORT;
	    y2 = y1 + glyph->info.height;
	    if (y2 > MAXSHORT)
		y2 = MAXSHORT;

	    if (first) {
		extents.x1 = x1;
		extents.y1 = y1;
		extents.x2 = x2;
		extents.y2 = y2;
		first = FALSE;
	    } else {
		if (x1 < extents.x2 && x2 > extents.x1 &&
		    y1 < extents.y2 && y2 > extents.y1)
		{
		    return TRUE;
		}

		if (x1 < extents.x1)
		    extents.x1 = x1;
		if (x2 > extents.x2)
		    extents.x2 = x2;
		if (y1 < extents.y1)
		    extents.y1 = y1;
		if (y2 > extents.y2)
		    extents.y2 = y2;
	    }
	    x += glyph->info.xOff;
	    y += glyph->info.yOff;
	}
d940 2
a941 37
    return FALSE;
}

/* exaGlyphs is a slight variation on miGlyphs, to support acceleration.  The
 * issue is that miGlyphs' use of ModifyPixmapHeader makes it impossible to
 * migrate these pixmaps.  So, instead we create a pixmap at the beginning of
 * the loop and upload each glyph into the pixmap before compositing.
 */
void
exaGlyphs (CARD8	op,
	  PicturePtr	pSrc,
	  PicturePtr	pDst,
	  PictFormatPtr	maskFormat,
	  INT16		xSrc,
	  INT16		ySrc,
	  int		nlist,
	  GlyphListPtr	list,
	  GlyphPtr	*glyphs)
{
    ExaScreenPriv (pDst->pDrawable->pScreen);
    PixmapPtr	pPixmap = NULL;
    PicturePtr	pPicture;
    PixmapPtr   pMaskPixmap = NULL;
    PixmapPtr   pDstPixmap = exaGetDrawablePixmap(pDst->pDrawable);
    PicturePtr  pMask;
    ScreenPtr   pScreen = pDst->pDrawable->pScreen;
    int		width = 0, height = 0;
    int		x, y, x1, y1, xoff, yoff;
    int		xDst = list->xOff, yDst = list->yOff;
    int		n;
    int		error;
    BoxRec	extents;
    CARD32	component_alpha;

    /* If we have a mask format but it's the same as all the glyphs and
     * the glyphs don't intersect, we can avoid accumulating the glyphs in the
     * temporary picture.
d943 1
a943 22
    if (maskFormat != NULL) {
	Bool sameFormat = TRUE;
	int i;

	for (i = 0; i < nlist; i++) {
	    if (maskFormat->format != list[i].format->format) {
		sameFormat = FALSE;
		break;
	    }
	}
	if (sameFormat) {
	    if (!exaGlyphsIntersect(nlist, list, glyphs)) {
		maskFormat = NULL;
	    }
	}
    }

    /* If the driver doesn't support accelerated composite, there's no point in
     * going to this extra work.  Assume that any driver that supports Composite
     * will be able to support component alpha using the two-pass helper.
     */
    if (!pExaScr->info->PrepareComposite)
d945 24
a968 2
	miGlyphs(op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, list, glyphs);
	return;
d970 1
a970 2

    if (maskFormat)
d972 3
a974 2
	GCPtr	    pGC;
	xRectangle  rect;
d976 2
a977 1
	miGlyphExtents (nlist, list, glyphs, &extents);
d979 5
a983 4
	extents.x1 = max(extents.x1, 0);
	extents.y1 = max(extents.y1, 0);
	extents.x2 = min(extents.x2, pDst->pDrawable->width);
	extents.y2 = min(extents.y2, pDst->pDrawable->height);
d985 10
a994 29
	if (extents.x2 <= extents.x1 || extents.y2 <= extents.y1)
	    return;
	width = extents.x2 - extents.x1;
	height = extents.y2 - extents.y1;
	pMaskPixmap = (*pScreen->CreatePixmap) (pScreen, width, height,
						maskFormat->depth);
	if (!pMaskPixmap)
	    return;
	component_alpha = NeedsComponent(maskFormat->format);
	pMask = CreatePicture (0, &pMaskPixmap->drawable,
			       maskFormat, CPComponentAlpha, &component_alpha,
			       serverClient, &error);
	if (!pMask)
	{
	    (*pScreen->DestroyPixmap) (pMaskPixmap);
	    return;
	}
	ValidatePicture(pMask);
	pGC = GetScratchGC (pMaskPixmap->drawable.depth, pScreen);
	ValidateGC (&pMaskPixmap->drawable, pGC);
	rect.x = 0;
	rect.y = 0;
	rect.width = width;
	rect.height = height;
	(*pGC->ops->PolyFillRect) (&pMaskPixmap->drawable, pGC, 1, &rect);
	exaPixmapDirty(pMaskPixmap, 0, 0, width, height);
	FreeScratchGC (pGC);
	x = -extents.x1;
	y = -extents.y1;
d998 4
a1001 111
	pMask = pDst;
	x = 0;
	y = 0;
    }

    exaGetDrawableDeltas(pDst->pDrawable, pDstPixmap, &xoff, &yoff);

    while (nlist--)
    {
	GCPtr pGC = NULL;
	int maxwidth = 0, maxheight = 0, i;
	ExaMigrationRec pixmaps[1];
	PixmapPtr pScratchPixmap = NULL;

	x += list->xOff;
	y += list->yOff;
	n = list->len;
	for (i = 0; i < n; i++) {
	    if (glyphs[i]->info.width > maxwidth)
		maxwidth = glyphs[i]->info.width;
	    if (glyphs[i]->info.height > maxheight)
		maxheight = glyphs[i]->info.height;
	}
	if (maxwidth == 0 || maxheight == 0) {
	    while (n--)
	    {
		GlyphPtr glyph;

		glyph = *glyphs++;
		x += glyph->info.xOff;
		y += glyph->info.yOff;
	    }
	    list++;
	    continue;
	}

	/* Create the (real) temporary pixmap to store the current glyph in */
	pPixmap = (*pScreen->CreatePixmap) (pScreen, maxwidth, maxheight,
					    list->format->depth);
	if (!pPixmap)
	    return;

	/* Create a temporary picture to wrap the temporary pixmap, so it can be
	 * used as a source for Composite.
	 */
	component_alpha = NeedsComponent(list->format->format);
	pPicture = CreatePicture (0, &pPixmap->drawable, list->format,
				  CPComponentAlpha, &component_alpha, 
				  serverClient, &error);
	if (!pPicture) {
	    (*pScreen->DestroyPixmap) (pPixmap);
	    return;
	}
	ValidatePicture(pPicture);

	/* Give the temporary pixmap an initial kick towards the screen, so
	 * it'll stick there.
	 */
	pixmaps[0].as_dst = TRUE;
	pixmaps[0].as_src = TRUE;
	pixmaps[0].pPix = pPixmap;
	exaDoMigration (pixmaps, 1, pExaScr->info->PrepareComposite != NULL);

	while (n--)
	{
	    GlyphPtr glyph = *glyphs++;
	    pointer glyphdata = (pointer) (glyph + 1);
	    DrawablePtr pCmpDrw = (maskFormat ? pMask : pDst)->pDrawable;

	    x1 = x - glyph->info.x;
	    y1 = y - glyph->info.y;

	    if (x1 >= pCmpDrw->width || y1 >= pCmpDrw->height ||
		glyph->info.width == 0 || glyph->info.height == 0 ||
		(x1 + glyph->info.width) <= 0 || (y1 + glyph->info.height) <= 0)
		goto nextglyph;

	    (*pScreen->ModifyPixmapHeader) (pScratchPixmap, 
					    glyph->info.width,
					    glyph->info.height,
					    0, 0, -1, glyphdata);

	    /* Copy the glyph data into the proper pixmap instead of a fake.
	     * First we try to use UploadToScreen, if we can, then we fall back
	     * to a plain exaCopyArea in case of failure.
	     */
	    if (pExaScr->info->UploadToScreen &&
		exaPixmapIsOffscreen(pPixmap) &&
		(*pExaScr->info->UploadToScreen) (pPixmap, 0, 0,
					glyph->info.width,
					glyph->info.height,
					glyphdata,
					PixmapBytePad(glyph->info.width,
						      list->format->depth)))
	    {
		exaMarkSync (pScreen);
	    } else {
		/* Set up the scratch pixmap/GC for doing a CopyArea. */
		if (pScratchPixmap == NULL) {
		    /* Get a scratch pixmap to wrap the original glyph data */
		    pScratchPixmap = GetScratchPixmapHeader (pScreen,
							glyph->info.width,
							glyph->info.height, 
							list->format->depth,
							list->format->depth, 
							-1, glyphdata);
		    if (!pScratchPixmap) {
			FreePicture(pPicture, 0);
			(*pScreen->DestroyPixmap) (pPixmap);
			return;
		    }
d1003 2
a1004 58
		    /* Get a scratch GC with which to copy the glyph data from
		     * scratch to temporary
		     */
		    pGC = GetScratchGC (list->format->depth, pScreen);
		    ValidateGC (&pPixmap->drawable, pGC);
		} else {
		    (*pScreen->ModifyPixmapHeader) (pScratchPixmap, 
						    glyph->info.width,
						    glyph->info.height,
						    0, 0, -1, glyphdata);
		    pScratchPixmap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
		}

		exaCopyArea (&pScratchPixmap->drawable, &pPixmap->drawable, pGC,
			     0, 0, glyph->info.width, glyph->info.height, 0, 0);
	    }

	    exaPixmapDirty (pPixmap, 0, 0,
			    glyph->info.width, glyph->info.height);

	    if (maskFormat)
	    {
		exaComposite (PictOpAdd, pPicture, NULL, pMask, 0, 0, 0, 0,
			      x1, y1, glyph->info.width, glyph->info.height);
		exaPixmapDirty(pMaskPixmap, x1, y1, x1 + glyph->info.width,
			       y1 + glyph->info.height);
	    }
	    else
	    {
		exaComposite (op, pSrc, pPicture, pDst,
			      xSrc + x1 - xDst, ySrc + y1 - yDst,
			      0, 0, x1, y1, glyph->info.width,
			      glyph->info.height);
		x1 += pDst->pDrawable->x + xoff;
		y1 += pDst->pDrawable->y + yoff;
		exaPixmapDirty(pDstPixmap, x1, y1, x1 + glyph->info.width,
			       y1 + glyph->info.height);
	    }
nextglyph:
	    x += glyph->info.xOff;
	    y += glyph->info.yOff;
	}
	list++;
	if (pGC != NULL)
	    FreeScratchGC (pGC);
	FreePicture ((pointer) pPicture, 0);
	(*pScreen->DestroyPixmap) (pPixmap);
	if (pScratchPixmap != NULL)
	    FreeScratchPixmapHeader (pScratchPixmap);
    }
    if (maskFormat)
    {
	x = extents.x1;
	y = extents.y1;
	exaComposite (op, pSrc, pMask, pDst, xSrc + x - xDst, ySrc + y - yDst,
		      0, 0, x, y, width, height);
	FreePicture ((pointer) pMask, (XID) 0);
	(*pScreen->DestroyPixmap) (pMaskPixmap);
@


1.1
log
@Initial revision
@
text
@d300 1
a310 1
    exaDrawableDirty (pDst->pDrawable);
d339 5
d348 6
a353 6
    if (pSrc->pDrawable->width > pExaScr->info->maxX ||
	pSrc->pDrawable->height > pExaScr->info->maxY ||
	pDst->pDrawable->width > pExaScr->info->maxX ||
	pDst->pDrawable->height > pExaScr->info->maxY || 
	(pMask && (pMask->pDrawable->width > pExaScr->info->maxX ||
		   pMask->pDrawable->height > pExaScr->info->maxY)))
a450 1

a452 1
    exaDrawableDirty (pDst->pDrawable);
d522 3
d543 6
d575 22
d604 1
a604 3
	ExaCheckComposite (op, pSrc, pMask, pDst, xSrc, ySrc,
			   xMask, yMask, xDst, yDst, width, height);
        return;
d615 7
a621 1
	if (op == PictOpSrc)
d624 2
a625 2
		pSrc->pDrawable->height == 1 && pSrc->repeat &&
		pSrc->repeatType == RepeatNormal)
d632 1
a632 2
	    else if (!pSrc->repeat && !pSrc->transform &&
		     pSrc->format == pDst->format)
d654 39
d703 2
a704 2
	(!pSrc->repeat || pSrc->repeat == RepeatNormal) &&
	(!pMask || !pMask->repeat || pMask->repeat == RepeatNormal) &&
d736 1
a736 21
    if (ret != 0) {
	ExaMigrationRec pixmaps[3];
	/* failure to accelerate was not due to pixmaps being in the wrong
	 * locations.
	 */
	pixmaps[0].as_dst = TRUE;
	pixmaps[0].as_src = exaOpReadsDestination(op);
	pixmaps[0].pPix = exaGetDrawablePixmap (pDst->pDrawable);
	pixmaps[1].as_dst = FALSE;
	pixmaps[1].as_src = TRUE;
	pixmaps[1].pPix = exaGetDrawablePixmap (pSrc->pDrawable);
	if (pMask) {
	    pixmaps[2].as_dst = FALSE;
	    pixmaps[2].as_src = TRUE;
	    pixmaps[2].pPix = exaGetDrawablePixmap (pMask->pDrawable);
	    exaDoMigration(pixmaps, 3, FALSE);
	} else {
	    exaDoMigration(pixmaps, 2, FALSE);
	}
    }

d741 1
d752 126
d891 1
d893 1
d897 1
a897 1
    pixmaps[0].pPix = exaGetDrawablePixmap (pPicture->pDrawable);
d900 1
a900 1
    exaPrepareAccess(pPicture->pDrawable, EXA_PREPARE_DEST);
d902 5
a906 1
    exaFinishAccess(pPicture->pDrawable, EXA_PREPARE_DEST);
d917 1
d919 1
d923 1
a923 1
    pixmaps[0].pPix = exaGetDrawablePixmap (pPicture->pDrawable);
d926 1
a926 1
    exaPrepareAccess(pPicture->pDrawable, EXA_PREPARE_DEST);
d928 5
a932 1
    exaFinishAccess(pPicture->pDrawable, EXA_PREPARE_DEST);
d1028 1
d1032 1
a1032 1
    int		x, y;
d1076 6
a1081 1
	
d1107 1
d1119 2
d1175 1
a1175 1
	exaDoMigration (pixmaps, 1, TRUE);
d1181 10
a1190 1
	    
d1200 3
a1202 3
	    if (!pExaScr->info->UploadToScreen ||
		!exaPixmapIsOffscreen(pPixmap) ||
		!(*pExaScr->info->UploadToScreen) (pPixmap, 0, 0,
d1209 2
a1240 2
	    } else {
		exaDrawableDirty (&pPixmap->drawable);
d1243 3
d1249 3
a1251 2
			      x - glyph->info.x, y - glyph->info.y,
			      glyph->info.width, glyph->info.height);
d1256 7
a1262 4
			      xSrc + (x - glyph->info.x) - xDst,
			      ySrc + (y - glyph->info.y) - yDst,
			      0, 0, x - glyph->info.x, y - glyph->info.y,
			      glyph->info.width, glyph->info.height);
d1264 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a299 1

d310 1
a338 5
    pSrcPix = exaGetDrawablePixmap(pSrc->pDrawable);
    pDstPix = exaGetDrawablePixmap(pDst->pDrawable);
    if (pMask)
	pMaskPix = exaGetDrawablePixmap(pMask->pDrawable);

d343 6
a348 6
    if (pSrcPix->drawable.width > pExaScr->info->maxX ||
	pSrcPix->drawable.height > pExaScr->info->maxY ||
	pDstPix->drawable.width > pExaScr->info->maxX ||
	pDstPix->drawable.height > pExaScr->info->maxY || 
	(pMask && (pMaskPix->drawable.width > pExaScr->info->maxX ||
		   pMaskPix->drawable.height > pExaScr->info->maxY)))
d446 1
d449 1
a518 3
    DrawablePtr pDstDraw = pDst->pDrawable;
    PixmapPtr pDstPixmap = exaGetDrawablePixmap(pDstDraw);
    int xoff, yoff;
a536 6
    exaGetDrawableDeltas(pDstDraw, pDstPixmap, &xoff, &yoff);
    xoff += pDstDraw->x;
    yoff += pDstDraw->y;
    exaPixmapDirty(pDstPixmap, xDst + xoff, yDst + yoff, xDst + xoff + width,
		   yDst + yoff + height);

a562 22
    ExaMigrationRec pixmaps[3];
    int npixmaps = 1;
    PixmapPtr pSrcPixmap = NULL;

    pixmaps[0].as_dst = TRUE;
    pixmaps[0].as_src = exaOpReadsDestination(op);
    pixmaps[0].pPix = exaGetDrawablePixmap (pDst->pDrawable);

    if (pSrc->pDrawable) {
	pSrcPixmap = exaGetDrawablePixmap (pSrc->pDrawable);
	pixmaps[npixmaps].as_dst = FALSE;
	pixmaps[npixmaps].as_src = TRUE;
	pixmaps[npixmaps].pPix = pSrcPixmap;
	npixmaps++;
    }

    if (pMask && pMask->pDrawable) {
	pixmaps[npixmaps].as_dst = FALSE;
	pixmaps[npixmaps].as_src = TRUE;
	pixmaps[npixmaps].pPix = exaGetDrawablePixmap (pMask->pDrawable);
	npixmaps++;
    }
d570 3
a572 1
	goto fallback;
d583 1
a583 7
      if ((op == PictOpSrc &&
	   ((pSrc->format == pDst->format) ||
	    (pSrc->format==PICT_a8r8g8b8 && pDst->format==PICT_x8r8g8b8) ||
	    (pSrc->format==PICT_a8b8g8r8 && pDst->format==PICT_x8b8g8r8))) ||
	  (op == PictOpOver && !pSrc->alphaMap && !pDst->alphaMap &&
	   pSrc->format == pDst->format &&
	   (pSrc->format==PICT_x8r8g8b8 || pSrc->format==PICT_x8b8g8r8)))
d586 2
a587 2
		pSrc->pDrawable->height == 1 &&
		pSrc->repeat)
d594 2
a595 1
	    else if (pSrcPixmap && !pSrc->repeat && !pSrc->transform)
a616 39
	    else if (pSrcPixmap && !pSrc->transform &&
		     pSrc->repeatType == RepeatNormal)
	    {
		RegionRec region;
		DDXPointRec srcOrg;

		/* Let's see if the driver can do the repeat in one go */
		if (pExaScr->info->PrepareComposite && !pSrc->alphaMap &&
		    !pDst->alphaMap)
		{
		    ret = exaTryDriverComposite(op, pSrc, pMask, pDst, xSrc,
						ySrc, xMask, yMask, xDst, yDst,
						width, height);
		    if (ret == 1)
			goto done;
		}

		/* Now see if we can use exaFillRegionTiled() */
		xDst += pDst->pDrawable->x;
		yDst += pDst->pDrawable->y;
		xSrc += pSrc->pDrawable->x;
		ySrc += pSrc->pDrawable->y;

		if (!miComputeCompositeRegion (&region, pSrc, pMask, pDst, xSrc,
					       ySrc, xMask, yMask, xDst, yDst,
					       width, height))
		    goto done;

		srcOrg.x = (xSrc - xDst) % pSrcPixmap->drawable.width;
		srcOrg.y = (ySrc - yDst) % pSrcPixmap->drawable.height;

		ret = exaFillRegionTiled(pDst->pDrawable, &region, pSrcPixmap,
					 &srcOrg, FB_ALLONES, GXcopy);

		REGION_UNINIT(pDst->pDrawable->pScreen, &region);

		if (ret)
		    goto done;
	    }
d627 2
a628 2
	(!pSrc->repeat || pSrc->repeatType == RepeatNormal) &&
	(!pMask || !pMask->repeat || pMask->repeatType == RepeatNormal) &&
d660 21
a680 1
fallback:
a684 1
    exaDoMigration(pixmaps, npixmaps, FALSE);
a694 126
/**
 * Same as miCreateAlphaPicture, except it uses ExaCheckPolyFillRect instead
 * of PolyFillRect to initialize the pixmap after creating it, to prevent
 * the pixmap from being migrated.
 *
 * See the comments about exaTrapezoids.
 */
static PicturePtr
exaCreateAlphaPicture (ScreenPtr     pScreen,
                       PicturePtr    pDst,
                       PictFormatPtr pPictFormat,
                       CARD16        width,
                       CARD16        height)
{
    PixmapPtr	    pPixmap;
    PicturePtr	    pPicture;
    GCPtr	    pGC;
    int		    error;
    xRectangle	    rect;

    if (width > 32767 || height > 32767)
	return 0;

    if (!pPictFormat)
    {
	if (pDst->polyEdge == PolyEdgeSharp)
	    pPictFormat = PictureMatchFormat (pScreen, 1, PICT_a1);
	else
	    pPictFormat = PictureMatchFormat (pScreen, 8, PICT_a8);
	if (!pPictFormat)
	    return 0;
    }

    pPixmap = (*pScreen->CreatePixmap) (pScreen, width, height,
					pPictFormat->depth);
    if (!pPixmap)
	return 0;
    pGC = GetScratchGC (pPixmap->drawable.depth, pScreen);
    if (!pGC)
    {
	(*pScreen->DestroyPixmap) (pPixmap);
	return 0;
    }
    ValidateGC (&pPixmap->drawable, pGC);
    rect.x = 0;
    rect.y = 0;
    rect.width = width;
    rect.height = height;
    ExaCheckPolyFillRect (&pPixmap->drawable, pGC, 1, &rect);
    exaPixmapDirty (pPixmap, 0, 0, width, height);
    FreeScratchGC (pGC);
    pPicture = CreatePicture (0, &pPixmap->drawable, pPictFormat,
			      0, 0, serverClient, &error);
    (*pScreen->DestroyPixmap) (pPixmap);
    return pPicture;
}

/**
 * exaTrapezoids is essentially a copy of miTrapezoids that uses
 * exaCreateAlphaPicture instead of miCreateAlphaPicture.
 *
 * The problem with miCreateAlphaPicture is that it calls PolyFillRect
 * to initialize the contents after creating the pixmap, which
 * causes the pixmap to be moved in for acceleration. The subsequent
 * call to RasterizeTrapezoid won't be accelerated however, which
 * forces the pixmap to be moved out again.
 *
 * exaCreateAlphaPicture avoids this roundtrip by using ExaCheckPolyFillRect
 * to initialize the contents.
 */
void
exaTrapezoids (CARD8 op, PicturePtr pSrc, PicturePtr pDst,
               PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
               int ntrap, xTrapezoid *traps)
{
    ScreenPtr		pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr    ps = GetPictureScreen(pScreen);

    /*
     * Check for solid alpha add
     */
    if (op == PictOpAdd && miIsSolidAlpha (pSrc))
    {
	for (; ntrap; ntrap--, traps++)
	    (*ps->RasterizeTrapezoid) (pDst, traps, 0, 0);
    }
    else if (maskFormat)
    {
	PicturePtr	pPicture;
	BoxRec		bounds;
	INT16		xDst, yDst;
	INT16		xRel, yRel;

	xDst = traps[0].left.p1.x >> 16;
	yDst = traps[0].left.p1.y >> 16;

	miTrapezoidBounds (ntrap, traps, &bounds);
	if (bounds.y1 >= bounds.y2 || bounds.x1 >= bounds.x2)
	    return;
	pPicture = exaCreateAlphaPicture (pScreen, pDst, maskFormat,
	                                  bounds.x2 - bounds.x1,
	                                  bounds.y2 - bounds.y1);
	if (!pPicture)
	    return;
	for (; ntrap; ntrap--, traps++)
	    (*ps->RasterizeTrapezoid) (pPicture, traps,
				       -bounds.x1, -bounds.y1);
	xRel = bounds.x1 + xSrc - xDst;
	yRel = bounds.y1 + ySrc - yDst;
	CompositePicture (op, pSrc, pPicture, pDst,
			  xRel, yRel, 0, 0, bounds.x1, bounds.y1,
			  bounds.x2 - bounds.x1,
			  bounds.y2 - bounds.y1);
	FreePicture (pPicture, 0);
    }
    else
    {
	if (pDst->polyEdge == PolyEdgeSharp)
	    maskFormat = PictureMatchFormat (pScreen, 1, PICT_a1);
	else
	    maskFormat = PictureMatchFormat (pScreen, 8, PICT_a8);
	for (; ntrap; ntrap--, traps++)
	    exaTrapezoids (op, pSrc, pDst, maskFormat, xSrc, ySrc, 1, traps);
    }
}

a707 1
    DrawablePtr pDraw = pPicture->pDrawable;
a708 1
    int xoff, yoff;
d712 1
a712 1
    pixmaps[0].pPix = exaGetDrawablePixmap (pDraw);
d715 1
a715 1
    exaPrepareAccess(pDraw, EXA_PREPARE_DEST);
d717 1
a717 5
    exaGetDrawableDeltas(pDraw, pixmaps[0].pPix, &xoff, &yoff);
    exaPixmapDirty(pixmaps[0].pPix, pDraw->x + xoff, pDraw->y + yoff,
		   pDraw->x + xoff + pDraw->width,
		   pDraw->y + yoff + pDraw->height);
    exaFinishAccess(pDraw, EXA_PREPARE_DEST);
a727 1
    DrawablePtr pDraw = pPicture->pDrawable;
a728 1
    int xoff, yoff;
d732 1
a732 1
    pixmaps[0].pPix = exaGetDrawablePixmap (pDraw);
d735 1
a735 1
    exaPrepareAccess(pDraw, EXA_PREPARE_DEST);
d737 1
a737 5
    exaGetDrawableDeltas(pDraw, pixmaps[0].pPix, &xoff, &yoff);
    exaPixmapDirty(pixmaps[0].pPix, pDraw->x + xoff, pDraw->y + yoff,
		   pDraw->x + xoff + pDraw->width,
		   pDraw->y + yoff + pDraw->height);
    exaFinishAccess(pDraw, EXA_PREPARE_DEST);
a832 1
    PixmapPtr   pDstPixmap = exaGetDrawablePixmap(pDst->pDrawable);
d836 1
a836 1
    int		x, y, x1, y1, xoff, yoff;
d880 1
a880 6

	extents.x1 = max(extents.x1, 0);
	extents.y1 = max(extents.y1, 0);
	extents.x2 = min(extents.x2, pDst->pDrawable->width);
	extents.y2 = min(extents.y2, pDst->pDrawable->height);

a905 1
	exaPixmapDirty(pMaskPixmap, 0, 0, width, height);
a916 2
    exaGetDrawableDeltas(pDst->pDrawable, pDstPixmap, &xoff, &yoff);

d971 1
a971 1
	exaDoMigration (pixmaps, 1, pExaScr->info->PrepareComposite != NULL);
d977 1
a977 9
	    DrawablePtr pCmpDrw = (maskFormat ? pMask : pDst)->pDrawable;

	    x1 = x - glyph->info.x;
	    y1 = y - glyph->info.y;

	    if (x1 >= pCmpDrw->width || y1 >= pCmpDrw->height ||
		(x1 + glyph->info.width) <= 0 || (y1 + glyph->info.height) <= 0)
		goto nextglyph;

d987 3
a989 3
	    if (pExaScr->info->UploadToScreen &&
		exaPixmapIsOffscreen(pPixmap) &&
		(*pExaScr->info->UploadToScreen) (pPixmap, 0, 0,
a995 2
		exaMarkSync (pScreen);
	    } else {
d1026 2
a1029 3
	    exaPixmapDirty (pPixmap, 0, 0,
			    glyph->info.width, glyph->info.height);

d1033 2
a1034 3
			      x1, y1, glyph->info.width, glyph->info.height);
		exaPixmapDirty(pMaskPixmap, x1, y1, x1 + glyph->info.width,
			       y1 + glyph->info.height);
d1039 4
a1042 7
			      xSrc + x1 - xDst, ySrc + y1 - yDst,
			      0, 0, x1, y1, glyph->info.width,
			      glyph->info.height);
		x1 += pDst->pDrawable->x + xoff;
		y1 += pDst->pDrawable->y + yoff;
		exaPixmapDirty(pDstPixmap, x1, y1, x1 + glyph->info.width,
			       y1 + glyph->info.height);
a1043 1
nextglyph:
@

