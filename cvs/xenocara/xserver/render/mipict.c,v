head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.10
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.21;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.21;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.16;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *
 * Copyright Â© 1999 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "scrnintstr.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "mi.h"
#include "picturestr.h"
#include "mipict.h"

int
miCreatePicture(PicturePtr pPicture)
{
    return Success;
}

void
miDestroyPicture(PicturePtr pPicture)
{
    if (pPicture->freeCompClip)
        RegionDestroy(pPicture->pCompositeClip);
}

static void
miDestroyPictureClip(PicturePtr pPicture)
{
    if (pPicture->clientClip)
        RegionDestroy(pPicture->clientClip);
    pPicture->clientClip = NULL;
}

static int
miChangePictureClip(PicturePtr pPicture, int type, void *value, int n)
{
    ScreenPtr pScreen = pPicture->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    RegionPtr clientClip;

    switch (type) {
    case CT_PIXMAP:
        /* convert the pixmap to a region */
        clientClip = BitmapToRegion(pScreen, (PixmapPtr) value);
        if (!clientClip)
            return BadAlloc;
        (*pScreen->DestroyPixmap) ((PixmapPtr) value);
        break;
    case CT_REGION:
        clientClip = value;
        break;
    case CT_NONE:
        clientClip = 0;
        break;
    default:
        clientClip = RegionFromRects(n, (xRectangle *) value, type);
        if (!clientClip)
            return BadAlloc;
        free(value);
        break;
    }
    (*ps->DestroyPictureClip) (pPicture);
    pPicture->clientClip = clientClip;
    pPicture->stateChanges |= CPClipMask;
    return Success;
}

static void
miChangePicture(PicturePtr pPicture, Mask mask)
{
    return;
}

static void
miValidatePicture(PicturePtr pPicture, Mask mask)
{
    DrawablePtr pDrawable = pPicture->pDrawable;

    if ((mask & (CPClipXOrigin | CPClipYOrigin | CPClipMask | CPSubwindowMode))
        || (pDrawable->serialNumber !=
            (pPicture->serialNumber & DRAWABLE_SERIAL_BITS))) {
        if (pDrawable->type == DRAWABLE_WINDOW) {
            WindowPtr pWin = (WindowPtr) pDrawable;
            RegionPtr pregWin;
            Bool freeTmpClip, freeCompClip;

            if (pPicture->subWindowMode == IncludeInferiors) {
                pregWin = NotClippedByChildren(pWin);
                freeTmpClip = TRUE;
            }
            else {
                pregWin = &pWin->clipList;
                freeTmpClip = FALSE;
            }
            freeCompClip = pPicture->freeCompClip;

            /*
             * if there is no client clip, we can get by with just keeping the
             * pointer we got, and remembering whether or not should destroy
             * (or maybe re-use) it later.  this way, we avoid unnecessary
             * copying of regions.  (this wins especially if many clients clip
             * by children and have no client clip.)
             */
            if (!pPicture->clientClip) {
                if (freeCompClip)
                    RegionDestroy(pPicture->pCompositeClip);
                pPicture->pCompositeClip = pregWin;
                pPicture->freeCompClip = freeTmpClip;
            }
            else {
                /*
                 * we need one 'real' region to put into the composite clip. if
                 * pregWin the current composite clip are real, we can get rid of
                 * one. if pregWin is real and the current composite clip isn't,
                 * use pregWin for the composite clip. if the current composite
                 * clip is real and pregWin isn't, use the current composite
                 * clip. if neither is real, create a new region.
                 */

                RegionTranslate(pPicture->clientClip,
                                pDrawable->x + pPicture->clipOrigin.x,
                                pDrawable->y + pPicture->clipOrigin.y);

                if (freeCompClip) {
                    RegionIntersect(pPicture->pCompositeClip,
                                    pregWin, pPicture->clientClip);
                    if (freeTmpClip)
                        RegionDestroy(pregWin);
                }
                else if (freeTmpClip) {
                    RegionIntersect(pregWin, pregWin, pPicture->clientClip);
                    pPicture->pCompositeClip = pregWin;
                }
                else {
                    pPicture->pCompositeClip = RegionCreate(NullBox, 0);
                    RegionIntersect(pPicture->pCompositeClip,
                                    pregWin, pPicture->clientClip);
                }
                pPicture->freeCompClip = TRUE;
                RegionTranslate(pPicture->clientClip,
                                -(pDrawable->x + pPicture->clipOrigin.x),
                                -(pDrawable->y + pPicture->clipOrigin.y));
            }
        }                       /* end of composite clip for a window */
        else {
            BoxRec pixbounds;

            /* XXX should we translate by drawable.x/y here ? */
            /* If you want pixmaps in offscreen memory, yes */
            pixbounds.x1 = pDrawable->x;
            pixbounds.y1 = pDrawable->y;
            pixbounds.x2 = pDrawable->x + pDrawable->width;
            pixbounds.y2 = pDrawable->y + pDrawable->height;

            if (pPicture->freeCompClip) {
                RegionReset(pPicture->pCompositeClip, &pixbounds);
            }
            else {
                pPicture->freeCompClip = TRUE;
                pPicture->pCompositeClip = RegionCreate(&pixbounds, 1);
            }

            if (pPicture->clientClip) {
                if (pDrawable->x || pDrawable->y) {
                    RegionTranslate(pPicture->clientClip,
                                    pDrawable->x + pPicture->clipOrigin.x,
                                    pDrawable->y + pPicture->clipOrigin.y);
                    RegionIntersect(pPicture->pCompositeClip,
                                    pPicture->pCompositeClip,
                                    pPicture->clientClip);
                    RegionTranslate(pPicture->clientClip,
                                    -(pDrawable->x + pPicture->clipOrigin.x),
                                    -(pDrawable->y + pPicture->clipOrigin.y));
                }
                else {
                    RegionTranslate(pPicture->pCompositeClip,
                                    -pPicture->clipOrigin.x,
                                    -pPicture->clipOrigin.y);
                    RegionIntersect(pPicture->pCompositeClip,
                                    pPicture->pCompositeClip,
                                    pPicture->clientClip);
                    RegionTranslate(pPicture->pCompositeClip,
                                    pPicture->clipOrigin.x,
                                    pPicture->clipOrigin.y);
                }
            }
        }                       /* end of composite clip for pixmap */
    }
}

static int
miChangePictureTransform(PicturePtr pPicture, PictTransform * transform)
{
    return Success;
}

static int
miChangePictureFilter(PicturePtr pPicture,
                      int filter, xFixed * params, int nparams)
{
    return Success;
}

#define BOUND(v)	(INT16) ((v) < MINSHORT ? MINSHORT : (v) > MAXSHORT ? MAXSHORT : (v))

static inline pixman_bool_t
miClipPictureReg(pixman_region16_t * pRegion,
                 pixman_region16_t * pClip, int dx, int dy)
{
    if (pixman_region_n_rects(pRegion) == 1 &&
        pixman_region_n_rects(pClip) == 1) {
        pixman_box16_t *pRbox = pixman_region_rectangles(pRegion, NULL);
        pixman_box16_t *pCbox = pixman_region_rectangles(pClip, NULL);
        int v;

        if (pRbox->x1 < (v = pCbox->x1 + dx))
            pRbox->x1 = BOUND(v);
        if (pRbox->x2 > (v = pCbox->x2 + dx))
            pRbox->x2 = BOUND(v);
        if (pRbox->y1 < (v = pCbox->y1 + dy))
            pRbox->y1 = BOUND(v);
        if (pRbox->y2 > (v = pCbox->y2 + dy))
            pRbox->y2 = BOUND(v);
        if (pRbox->x1 >= pRbox->x2 || pRbox->y1 >= pRbox->y2) {
            pixman_region_init(pRegion);
        }
    }
    else if (!pixman_region_not_empty(pClip))
        return FALSE;
    else {
        if (dx || dy)
            pixman_region_translate(pRegion, -dx, -dy);
        if (!pixman_region_intersect(pRegion, pRegion, pClip))
            return FALSE;
        if (dx || dy)
            pixman_region_translate(pRegion, dx, dy);
    }
    return pixman_region_not_empty(pRegion);
}

static inline Bool
miClipPictureSrc(RegionPtr pRegion, PicturePtr pPicture, int dx, int dy)
{
    if (pPicture->clientClip) {
        Bool result;

        pixman_region_translate(pPicture->clientClip,
                                pPicture->clipOrigin.x + dx,
                                pPicture->clipOrigin.y + dy);

        result = RegionIntersect(pRegion, pRegion, pPicture->clientClip);

        pixman_region_translate(pPicture->clientClip,
                                -(pPicture->clipOrigin.x + dx),
                                -(pPicture->clipOrigin.y + dy));

        if (!result)
            return FALSE;
    }
    return TRUE;
}

static void
SourceValidateOnePicture(PicturePtr pPicture)
{
    DrawablePtr pDrawable = pPicture->pDrawable;
    ScreenPtr pScreen;

    if (!pDrawable)
        return;

    pScreen = pDrawable->pScreen;

    if (pScreen->SourceValidate) {
        pScreen->SourceValidate(pDrawable, 0, 0, pDrawable->width,
                                pDrawable->height, pPicture->subWindowMode);
    }
}

void
miCompositeSourceValidate(PicturePtr pPicture)
{
    SourceValidateOnePicture(pPicture);
    if (pPicture->alphaMap)
        SourceValidateOnePicture(pPicture->alphaMap);
}

/*
 * returns FALSE if the final region is empty.  Indistinguishable from
 * an allocation failure, but rendering ignores those anyways.
 */

Bool
miComputeCompositeRegion(RegionPtr pRegion,
                         PicturePtr pSrc,
                         PicturePtr pMask,
                         PicturePtr pDst,
                         INT16 xSrc,
                         INT16 ySrc,
                         INT16 xMask,
                         INT16 yMask,
                         INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
{

    int v;

    pRegion->extents.x1 = xDst;
    v = xDst + width;
    pRegion->extents.x2 = BOUND(v);
    pRegion->extents.y1 = yDst;
    v = yDst + height;
    pRegion->extents.y2 = BOUND(v);
    pRegion->data = 0;
    /* Check for empty operation */
    if (pRegion->extents.x1 >= pRegion->extents.x2 ||
        pRegion->extents.y1 >= pRegion->extents.y2) {
        pixman_region_init(pRegion);
        return FALSE;
    }
    /* clip against dst */
    if (!miClipPictureReg(pRegion, pDst->pCompositeClip, 0, 0)) {
        pixman_region_fini(pRegion);
        return FALSE;
    }
    if (pDst->alphaMap) {
        if (!miClipPictureReg(pRegion, pDst->alphaMap->pCompositeClip,
                              -pDst->alphaOrigin.x, -pDst->alphaOrigin.y)) {
            pixman_region_fini(pRegion);
            return FALSE;
        }
    }
    /* clip against src */
    if (!miClipPictureSrc(pRegion, pSrc, xDst - xSrc, yDst - ySrc)) {
        pixman_region_fini(pRegion);
        return FALSE;
    }
    if (pSrc->alphaMap) {
        if (!miClipPictureSrc(pRegion, pSrc->alphaMap,
                              xDst - (xSrc - pSrc->alphaOrigin.x),
                              yDst - (ySrc - pSrc->alphaOrigin.y))) {
            pixman_region_fini(pRegion);
            return FALSE;
        }
    }
    /* clip against mask */
    if (pMask) {
        if (!miClipPictureSrc(pRegion, pMask, xDst - xMask, yDst - yMask)) {
            pixman_region_fini(pRegion);
            return FALSE;
        }
        if (pMask->alphaMap) {
            if (!miClipPictureSrc(pRegion, pMask->alphaMap,
                                  xDst - (xMask - pMask->alphaOrigin.x),
                                  yDst - (yMask - pMask->alphaOrigin.y))) {
                pixman_region_fini(pRegion);
                return FALSE;
            }
        }
    }

    miCompositeSourceValidate(pSrc);
    if (pMask)
        miCompositeSourceValidate(pMask);

    return TRUE;
}

void
miRenderColorToPixel(PictFormatPtr format, xRenderColor * color, CARD32 *pixel)
{
    CARD32 r, g, b, a;
    miIndexedPtr pIndexed;

    switch (format->type) {
    case PictTypeDirect:
        r = color->red >> (16 - Ones(format->direct.redMask));
        g = color->green >> (16 - Ones(format->direct.greenMask));
        b = color->blue >> (16 - Ones(format->direct.blueMask));
        a = color->alpha >> (16 - Ones(format->direct.alphaMask));
        r = r << format->direct.red;
        g = g << format->direct.green;
        b = b << format->direct.blue;
        a = a << format->direct.alpha;
        *pixel = r | g | b | a;
        break;
    case PictTypeIndexed:
        pIndexed = (miIndexedPtr) (format->index.devPrivate);
        if (pIndexed->color) {
            r = color->red >> 11;
            g = color->green >> 11;
            b = color->blue >> 11;
            *pixel = miIndexToEnt15(pIndexed, (r << 10) | (g << 5) | b);
        }
        else {
            r = color->red >> 8;
            g = color->green >> 8;
            b = color->blue >> 8;
            *pixel = miIndexToEntY24(pIndexed, (r << 16) | (g << 8) | b);
        }
        break;
    }
}

static CARD16
miFillColor(CARD32 pixel, int bits)
{
    while (bits < 16) {
        pixel |= pixel << bits;
        bits <<= 1;
    }
    return (CARD16) pixel;
}

Bool
miIsSolidAlpha(PicturePtr pSrc)
{
    ScreenPtr pScreen;
    char line[1];

    if (!pSrc->pDrawable)
        return FALSE;

    pScreen = pSrc->pDrawable->pScreen;

    /* Alpha-only */
    if (PICT_FORMAT_TYPE(pSrc->format) != PICT_TYPE_A)
        return FALSE;
    /* repeat */
    if (!pSrc->repeat)
        return FALSE;
    /* 1x1 */
    if (pSrc->pDrawable->width != 1 || pSrc->pDrawable->height != 1)
        return FALSE;
    line[0] = 1;
    (*pScreen->GetImage) (pSrc->pDrawable, 0, 0, 1, 1, ZPixmap, ~0L, line);
    switch (pSrc->pDrawable->bitsPerPixel) {
    case 1:
        return (CARD8) line[0] == 1 || (CARD8) line[0] == 0x80;
    case 4:
        return (CARD8) line[0] == 0xf || (CARD8) line[0] == 0xf0;
    case 8:
        return (CARD8) line[0] == 0xff;
    default:
        return FALSE;
    }
}

void
miRenderPixelToColor(PictFormatPtr format, CARD32 pixel, xRenderColor * color)
{
    CARD32 r, g, b, a;
    miIndexedPtr pIndexed;

    switch (format->type) {
    case PictTypeDirect:
        r = (pixel >> format->direct.red) & format->direct.redMask;
        g = (pixel >> format->direct.green) & format->direct.greenMask;
        b = (pixel >> format->direct.blue) & format->direct.blueMask;
        a = (pixel >> format->direct.alpha) & format->direct.alphaMask;
        color->red = miFillColor(r, Ones(format->direct.redMask));
        color->green = miFillColor(g, Ones(format->direct.greenMask));
        color->blue = miFillColor(b, Ones(format->direct.blueMask));
        color->alpha = miFillColor(a, Ones(format->direct.alphaMask));
        break;
    case PictTypeIndexed:
        pIndexed = (miIndexedPtr) (format->index.devPrivate);
        pixel = pIndexed->rgba[pixel & (MI_MAX_INDEXED - 1)];
        r = (pixel >> 16) & 0xff;
        g = (pixel >> 8) & 0xff;
        b = (pixel) & 0xff;
        color->red = miFillColor(r, 8);
        color->green = miFillColor(g, 8);
        color->blue = miFillColor(b, 8);
        color->alpha = 0xffff;
        break;
    }
}

static void
miTriStrip(CARD8 op,
           PicturePtr pSrc,
           PicturePtr pDst,
           PictFormatPtr maskFormat,
           INT16 xSrc, INT16 ySrc, int npoints, xPointFixed * points)
{
    xTriangle *tris, *tri;
    int ntri;

    ntri = npoints - 2;
    tris = xallocarray(ntri, sizeof(xTriangle));
    if (!tris)
        return;

    for (tri = tris; npoints >= 3; npoints--, points++, tri++) {
        tri->p1 = points[0];
        tri->p2 = points[1];
        tri->p3 = points[2];
    }
    CompositeTriangles(op, pSrc, pDst, maskFormat, xSrc, ySrc, ntri, tris);
    free(tris);
}

static void
miTriFan(CARD8 op,
         PicturePtr pSrc,
         PicturePtr pDst,
         PictFormatPtr maskFormat,
         INT16 xSrc, INT16 ySrc, int npoints, xPointFixed * points)
{
    xTriangle *tris, *tri;
    xPointFixed *first;
    int ntri;

    ntri = npoints - 2;
    tris = xallocarray(ntri, sizeof(xTriangle));
    if (!tris)
        return;

    first = points++;
    for (tri = tris; npoints >= 3; npoints--, points++, tri++) {
        tri->p1 = *first;
        tri->p2 = points[0];
        tri->p3 = points[1];
    }
    CompositeTriangles(op, pSrc, pDst, maskFormat, xSrc, ySrc, ntri, tris);
    free(tris);
}

Bool
miPictureInit(ScreenPtr pScreen, PictFormatPtr formats, int nformats)
{
    PictureScreenPtr ps;

    if (!PictureInit(pScreen, formats, nformats))
        return FALSE;
    ps = GetPictureScreen(pScreen);
    ps->CreatePicture = miCreatePicture;
    ps->DestroyPicture = miDestroyPicture;
    ps->ChangePictureClip = miChangePictureClip;
    ps->DestroyPictureClip = miDestroyPictureClip;
    ps->ChangePicture = miChangePicture;
    ps->ValidatePicture = miValidatePicture;
    ps->InitIndexed = miInitIndexed;
    ps->CloseIndexed = miCloseIndexed;
    ps->UpdateIndexed = miUpdateIndexed;
    ps->ChangePictureTransform = miChangePictureTransform;
    ps->ChangePictureFilter = miChangePictureFilter;
    ps->RealizeGlyph = miRealizeGlyph;
    ps->UnrealizeGlyph = miUnrealizeGlyph;

    /* MI rendering routines */
    ps->Composite = 0;          /* requires DDX support */
    ps->Glyphs = miGlyphs;
    ps->CompositeRects = miCompositeRects;
    ps->Trapezoids = 0;
    ps->Triangles = 0;

    ps->RasterizeTrapezoid = 0; /* requires DDX support */
    ps->AddTraps = 0;           /* requires DDX support */
    ps->AddTriangles = 0;       /* requires DDX support */

    ps->TriStrip = miTriStrip;  /* converts call to CompositeTriangles */
    ps->TriFan = miTriFan;

    return TRUE;
}
@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d49 1
a49 1
void
d57 1
a57 1
int
d91 1
a91 1
void
d97 1
a97 1
void
d214 1
a214 1
int
d220 1
a220 1
int
d502 1
a502 1
void
d513 1
a513 1
    tris = malloc(ntri * sizeof(xTriangle));
d526 1
a526 1
void
d538 1
a538 1
    tris = malloc(ntri * sizeof(xTriangle));
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d52 1
a52 12
    switch (pPicture->clientClipType) {
    case CT_NONE:
        return;
    case CT_PIXMAP:
        (*pPicture->pDrawable->pScreen->
         DestroyPixmap) ((PixmapPtr) (pPicture->clientClip));
        break;
    default:
        /*
         * we know we'll never have a list of rectangles, since ChangeClip
         * immediately turns them into a region
         */
a53 2
        break;
    }
a54 1
    pPicture->clientClipType = CT_NONE;
d62 1
a62 2
    void *clientClip;
    int clientClipType;
d67 1
a67 1
        clientClip = (void *) BitmapToRegion(pScreen, (PixmapPtr) value);
a69 1
        clientClipType = CT_REGION;
a73 1
        clientClipType = CT_REGION;
a76 1
        clientClipType = CT_NONE;
d79 1
a79 1
        clientClip = (void *) RegionFromRects(n, (xRectangle *) value, type);
a81 1
        clientClipType = CT_REGION;
a86 1
    pPicture->clientClipType = clientClipType;
d127 1
a127 1
            if (pPicture->clientClipType == CT_NONE) {
d186 1
a186 1
            if (pPicture->clientClipType == CT_REGION) {
d267 1
a267 1
    if (pPicture->clientClipType != CT_NONE) {
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d72 1
a72 1
miChangePictureClip(PicturePtr pPicture, int type, pointer value, int n)
d76 1
a76 1
    pointer clientClip;
d82 1
a82 1
        clientClip = (pointer) BitmapToRegion(pScreen, (PixmapPtr) value);
d97 1
a97 1
        clientClip = (pointer) RegionFromRects(n, (xRectangle *) value, type);
@


1.5
log
@Update to xserver 1.11.2
@
text
@a35 4
#ifndef __GNUC__
#define __inline
#endif

d37 1
a37 1
miCreatePicture (PicturePtr pPicture)
d43 1
a43 1
miDestroyPicture (PicturePtr pPicture)
d46 1
a46 1
	RegionDestroy(pPicture->pCompositeClip);
d50 1
a50 1
miDestroyPictureClip (PicturePtr pPicture)
d54 1
a54 1
	return;
d56 3
a58 2
	(*pPicture->pDrawable->pScreen->DestroyPixmap) ((PixmapPtr) (pPicture->clientClip));
	break;
d60 6
a65 6
	/*
	 * we know we'll never have a list of rectangles, since ChangeClip
	 * immediately turns them into a region
	 */
	RegionDestroy(pPicture->clientClip);
	break;
d69 1
a69 1
}    
d72 7
a78 10
miChangePictureClip (PicturePtr    pPicture,
		     int	   type,
		     pointer	   value,
		     int	   n)
{
    ScreenPtr		pScreen = pPicture->pDrawable->pScreen;
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
    pointer		clientClip;
    int			clientClipType;
    
d81 7
a87 7
	/* convert the pixmap to a region */
	clientClip = (pointer) BitmapToRegion(pScreen, (PixmapPtr) value);
	if (!clientClip)
	    return BadAlloc;
	clientClipType = CT_REGION;
	(*pScreen->DestroyPixmap) ((PixmapPtr) value);
	break;
d89 3
a91 3
	clientClip = value;
	clientClipType = CT_REGION;
	break;
d93 3
a95 3
	clientClip = 0;
	clientClipType = CT_NONE;
	break;
d97 6
a102 8
	clientClip = (pointer) RegionFromRects(n,
					       (xRectangle *) value,
					       type);
	if (!clientClip)
	    return BadAlloc;
	clientClipType = CT_REGION;
	free(value);
	break;
d112 1
a112 2
miChangePicture (PicturePtr pPicture,
		 Mask       mask)
d118 1
a118 2
miValidatePicture (PicturePtr pPicture,
		   Mask       mask)
d120 1
a120 1
    DrawablePtr	    pDrawable = pPicture->pDrawable;
d122 109
a230 116
    if ((mask & (CPClipXOrigin|CPClipYOrigin|CPClipMask|CPSubwindowMode)) ||
	(pDrawable->serialNumber != (pPicture->serialNumber & DRAWABLE_SERIAL_BITS)))
    {
	if (pDrawable->type == DRAWABLE_WINDOW)
	{
	    WindowPtr       pWin = (WindowPtr) pDrawable;
	    RegionPtr       pregWin;
	    Bool            freeTmpClip, freeCompClip;

	    if (pPicture->subWindowMode == IncludeInferiors)
	    {
		pregWin = NotClippedByChildren(pWin);
		freeTmpClip = TRUE;
	    }
	    else
	    {
		pregWin = &pWin->clipList;
		freeTmpClip = FALSE;
	    }
	    freeCompClip = pPicture->freeCompClip;

	    /*
	     * if there is no client clip, we can get by with just keeping the
	     * pointer we got, and remembering whether or not should destroy
	     * (or maybe re-use) it later.  this way, we avoid unnecessary
	     * copying of regions.  (this wins especially if many clients clip
	     * by children and have no client clip.)
	     */
	    if (pPicture->clientClipType == CT_NONE)
	    {
		if (freeCompClip)
		    RegionDestroy(pPicture->pCompositeClip);
		pPicture->pCompositeClip = pregWin;
		pPicture->freeCompClip = freeTmpClip;
	    }
	    else
	    {
		/*
		 * we need one 'real' region to put into the composite clip. if
		 * pregWin the current composite clip are real, we can get rid of
		 * one. if pregWin is real and the current composite clip isn't,
		 * use pregWin for the composite clip. if the current composite
		 * clip is real and pregWin isn't, use the current composite
		 * clip. if neither is real, create a new region.
		 */

		RegionTranslate(pPicture->clientClip,
				 pDrawable->x + pPicture->clipOrigin.x,
				 pDrawable->y + pPicture->clipOrigin.y);

		if (freeCompClip)
		{
		    RegionIntersect(pPicture->pCompositeClip,
				     pregWin, pPicture->clientClip);
		    if (freeTmpClip)
			RegionDestroy(pregWin);
		}
		else if (freeTmpClip)
		{
		    RegionIntersect(pregWin, pregWin, pPicture->clientClip);
		    pPicture->pCompositeClip = pregWin;
		}
		else
		{
		    pPicture->pCompositeClip = RegionCreate(NullBox, 0);
		    RegionIntersect(pPicture->pCompositeClip,
				     pregWin, pPicture->clientClip);
		}
		pPicture->freeCompClip = TRUE;
		RegionTranslate(pPicture->clientClip,
				 -(pDrawable->x + pPicture->clipOrigin.x),
				 -(pDrawable->y + pPicture->clipOrigin.y));
	    }
	}	/* end of composite clip for a window */
	else
	{
	    BoxRec          pixbounds;

	    /* XXX should we translate by drawable.x/y here ? */
	    /* If you want pixmaps in offscreen memory, yes */
	    pixbounds.x1 = pDrawable->x;
	    pixbounds.y1 = pDrawable->y;
	    pixbounds.x2 = pDrawable->x + pDrawable->width;
	    pixbounds.y2 = pDrawable->y + pDrawable->height;

	    if (pPicture->freeCompClip)
	    {
		RegionReset(pPicture->pCompositeClip, &pixbounds);
	    }
	    else
	    {
		pPicture->freeCompClip = TRUE;
		pPicture->pCompositeClip = RegionCreate(&pixbounds, 1);
	    }

	    if (pPicture->clientClipType == CT_REGION)
	    {
		if(pDrawable->x || pDrawable->y) {
		    RegionTranslate(pPicture->clientClip,
				     pDrawable->x + pPicture->clipOrigin.x, 
				     pDrawable->y + pPicture->clipOrigin.y);
		    RegionIntersect(pPicture->pCompositeClip,
				     pPicture->pCompositeClip, pPicture->clientClip);
		    RegionTranslate(pPicture->clientClip,
				     -(pDrawable->x + pPicture->clipOrigin.x), 
				     -(pDrawable->y + pPicture->clipOrigin.y));
		} else {
		    RegionTranslate(pPicture->pCompositeClip,
				     -pPicture->clipOrigin.x, -pPicture->clipOrigin.y);
		    RegionIntersect(pPicture->pCompositeClip,
				     pPicture->pCompositeClip, pPicture->clientClip);
		    RegionTranslate(pPicture->pCompositeClip,
				     pPicture->clipOrigin.x, pPicture->clipOrigin.y);
		}
	    }
	}	/* end of composite clip for pixmap */
d235 1
a235 2
miChangePictureTransform (PicturePtr	pPicture,
			  PictTransform *transform)
d241 2
a242 4
miChangePictureFilter (PicturePtr pPicture,
		       int	  filter,
		       xFixed     *params,
		       int	  nparams)
d250 2
a251 4
miClipPictureReg (pixman_region16_t *	pRegion,
		  pixman_region16_t *	pClip,
		  int		dx,
		  int		dy)
d254 26
a279 30
	pixman_region_n_rects(pClip) == 1)
    {
	pixman_box16_t *  pRbox = pixman_region_rectangles(pRegion, NULL);
	pixman_box16_t *  pCbox = pixman_region_rectangles(pClip, NULL);
	int	v;
	
	if (pRbox->x1 < (v = pCbox->x1 + dx))
	    pRbox->x1 = BOUND(v);
	if (pRbox->x2 > (v = pCbox->x2 + dx))
	    pRbox->x2 = BOUND(v);
	if (pRbox->y1 < (v = pCbox->y1 + dy))
	    pRbox->y1 = BOUND(v);
	if (pRbox->y2 > (v = pCbox->y2 + dy))
	    pRbox->y2 = BOUND(v);
	if (pRbox->x1 >= pRbox->x2 ||
	    pRbox->y1 >= pRbox->y2)
	{
	    pixman_region_init (pRegion);
	}
    }
    else if (!pixman_region_not_empty (pClip))
	return FALSE;
    else
    {
	if (dx || dy)
	    pixman_region_translate (pRegion, -dx, -dy);
	if (!pixman_region_intersect (pRegion, pRegion, pClip))
	    return FALSE;
	if (dx || dy)
	    pixman_region_translate(pRegion, dx, dy);
d284 11
a294 19
static __inline Bool
miClipPictureSrc (RegionPtr	pRegion,
		  PicturePtr	pPicture,
		  int		dx,
		  int		dy)
{
    if (pPicture->clientClipType != CT_NONE)
    {
	Bool result;
	
	pixman_region_translate ( pPicture->clientClip,
				  pPicture->clipOrigin.x + dx,
				  pPicture->clipOrigin.y + dy);

	result = RegionIntersect(pRegion, pRegion, pPicture->clientClip);
	
	pixman_region_translate ( pPicture->clientClip,
				  - (pPicture->clipOrigin.x + dx),
				  - (pPicture->clipOrigin.y + dy));
d296 6
a301 2
	if (!result)
	    return FALSE;
d307 1
a307 1
SourceValidateOnePicture (PicturePtr pPicture)
d309 2
a310 2
    DrawablePtr	pDrawable = pPicture->pDrawable;
    ScreenPtr	pScreen;
d317 3
a319 4
    if (pScreen->SourceValidate)
    {
	pScreen->SourceValidate (
	    pDrawable, 0, 0, pDrawable->width, pDrawable->height, pPicture->subWindowMode);
d324 1
a324 1
miCompositeSourceValidate (PicturePtr pPicture)
d326 1
a326 1
    SourceValidateOnePicture (pPicture);
d328 1
a328 1
	SourceValidateOnePicture (pPicture->alphaMap);
d337 9
a345 12
miComputeCompositeRegion (RegionPtr	pRegion,
			  PicturePtr	pSrc,
			  PicturePtr	pMask,
			  PicturePtr	pDst,
			  INT16		xSrc,
			  INT16		ySrc,
			  INT16		xMask,
			  INT16		yMask,
			  INT16		xDst,
			  INT16		yDst,
			  CARD16	width,
			  CARD16	height)
d347 2
a348 2
    
    int		v;
d359 3
a361 4
	pRegion->extents.y1 >= pRegion->extents.y2)
    {
	pixman_region_init (pRegion);
	return FALSE;
d364 10
a373 14
    if (!miClipPictureReg (pRegion, pDst->pCompositeClip, 0, 0))
    {
	pixman_region_fini (pRegion);
	return FALSE;
    }
    if (pDst->alphaMap)
    {
	if (!miClipPictureReg (pRegion, pDst->alphaMap->pCompositeClip,
			       -pDst->alphaOrigin.x,
			       -pDst->alphaOrigin.y))
	{
	    pixman_region_fini (pRegion);
	    return FALSE;
	}
d376 11
a386 14
    if (!miClipPictureSrc (pRegion, pSrc, xDst - xSrc, yDst - ySrc))
    {
	pixman_region_fini (pRegion);
	return FALSE;
    }
    if (pSrc->alphaMap)
    {
	if (!miClipPictureSrc (pRegion, pSrc->alphaMap,
			       xDst - (xSrc - pSrc->alphaOrigin.x),
			       yDst - (ySrc - pSrc->alphaOrigin.y)))
	{
	    pixman_region_fini (pRegion);
	    return FALSE;
	}
d389 13
a401 17
    if (pMask)
    {
	if (!miClipPictureSrc (pRegion, pMask, xDst - xMask, yDst - yMask))
	{
	    pixman_region_fini (pRegion);
	    return FALSE;
	}	
	if (pMask->alphaMap)
	{
	    if (!miClipPictureSrc (pRegion, pMask->alphaMap,
				   xDst - (xMask - pMask->alphaOrigin.x),
				   yDst - (yMask - pMask->alphaOrigin.y)))
	    {
		pixman_region_fini (pRegion);
		return FALSE;
	    }
	}
d404 1
a404 2
    
    miCompositeSourceValidate (pSrc);
d406 1
a406 1
	miCompositeSourceValidate (pMask);
d412 1
a412 3
miRenderColorToPixel (PictFormatPtr format,
		      xRenderColor  *color,
		      CARD32	    *pixel)
d414 2
a415 2
    CARD32	    r, g, b, a;
    miIndexedPtr    pIndexed;
d419 10
a428 10
	r = color->red >> (16 - Ones (format->direct.redMask));
	g = color->green >> (16 - Ones (format->direct.greenMask));
	b = color->blue >> (16 - Ones (format->direct.blueMask));
	a = color->alpha >> (16 - Ones (format->direct.alphaMask));
	r = r << format->direct.red;
	g = g << format->direct.green;
	b = b << format->direct.blue;
	a = a << format->direct.alpha;
	*pixel = r|g|b|a;
	break;
d430 14
a443 16
	pIndexed = (miIndexedPtr) (format->index.devPrivate);
	if (pIndexed->color)
	{
	    r = color->red >> 11;
	    g = color->green >> 11;
	    b = color->blue >> 11;
	    *pixel = miIndexToEnt15 (pIndexed, (r << 10) | (g << 5) | b);
	}
	else
	{
	    r = color->red >> 8;
	    g = color->green >> 8;
	    b = color->blue >> 8;
	    *pixel = miIndexToEntY24 (pIndexed, (r << 16) | (g << 8) | b);
	}
	break;
d448 1
a448 1
miFillColor (CARD32 pixel, int bits)
d450 3
a452 4
    while (bits < 16)
    {
	pixel |= pixel << bits;
	bits <<= 1;
d458 1
a458 1
miIsSolidAlpha (PicturePtr pSrc)
d460 2
a461 2
    ScreenPtr	pScreen;
    char	line[1];
d467 1
a467 1
    
d469 2
a470 2
    if (PICT_FORMAT_TYPE (pSrc->format) != PICT_TYPE_A)
	return FALSE;
d473 1
a473 1
	return FALSE;
d476 1
a476 1
	return FALSE;
d481 1
a481 1
	return (CARD8) line[0] == 1 || (CARD8) line[0] == 0x80;
d483 1
a483 1
	return (CARD8) line[0] == 0xf || (CARD8) line[0] == 0xf0;
d485 1
a485 1
	return (CARD8) line[0] == 0xff;
d487 1
a487 1
	return FALSE;
d492 5
a496 7
miRenderPixelToColor (PictFormatPtr format,
		      CARD32	    pixel,
		      xRenderColor  *color)
{
    CARD32	    r, g, b, a;
    miIndexedPtr    pIndexed;
    
d499 9
a507 9
	r = (pixel >> format->direct.red) & format->direct.redMask;
	g = (pixel >> format->direct.green) & format->direct.greenMask;
	b = (pixel >> format->direct.blue) & format->direct.blueMask;
	a = (pixel >> format->direct.alpha) & format->direct.alphaMask;
	color->red = miFillColor (r, Ones (format->direct.redMask));
	color->green = miFillColor (g, Ones (format->direct.greenMask));
	color->blue = miFillColor (b, Ones (format->direct.blueMask));
	color->alpha = miFillColor (a, Ones (format->direct.alphaMask));
	break;
d509 58
a566 10
	pIndexed = (miIndexedPtr) (format->index.devPrivate);
	pixel = pIndexed->rgba[pixel & (MI_MAX_INDEXED-1)];
	r = (pixel >> 16) & 0xff;
	g = (pixel >>  8) & 0xff;
	b = (pixel      ) & 0xff;
	color->red = miFillColor (r, 8);
	color->green = miFillColor (g, 8);
	color->blue = miFillColor (b, 8);
	color->alpha = 0xffff;
	break;
d568 2
d573 1
a573 1
miPictureInit (ScreenPtr pScreen, PictFormatPtr formats, int nformats)
d575 4
a578 4
    PictureScreenPtr    ps;
    
    if (!PictureInit (pScreen, formats, nformats))
	return FALSE;
d595 12
a606 9
    ps->Composite	= 0;			/* requires DDX support */
    ps->Glyphs		= miGlyphs;
    ps->CompositeRects	= miCompositeRects;
    ps->Trapezoids	= 0;
    ps->Triangles	= 0;
    
    ps->RasterizeTrapezoid = 0;			/* requires DDX support */
    ps->AddTraps	= 0;			/* requires DDX support */
    ps->AddTriangles	= 0;			/* requires DDX support */
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d336 2
a337 6
void
miCompositeSourceValidate (PicturePtr	pPicture,
			   INT16	x,
			   INT16	y,
			   CARD16	width,
			   CARD16	height)
d346 1
a346 1
    
d349 2
a350 37
	if (pPicture->transform)
	{
	    xPoint	    points[4];
	    int		    i;
	    int		    xmin, ymin, xmax, ymax;

#define VectorSet(i,_x,_y) { points[i].x = _x; points[i].y = _y; }
	    VectorSet (0, x, y);
	    VectorSet (1, x + width, y);
	    VectorSet (2, x, y + height);
	    VectorSet (3, x + width, y + height);
	    xmin = ymin = 32767;
	    xmax = ymax = -32737;
	    for (i = 0; i < 4; i++)
	    {
		PictVector  t;
		t.vector[0] = IntToxFixed (points[i].x);
		t.vector[1] = IntToxFixed (points[i].y);
		t.vector[2] = xFixed1;
		if (pixman_transform_point (pPicture->transform, &t))
		{
		    int	tx = xFixedToInt (t.vector[0]);
		    int ty = xFixedToInt (t.vector[1]);
		    if (tx < xmin) xmin = tx;
		    if (tx > xmax) xmax = tx;
		    if (ty < ymin) ymin = ty;
		    if (ty > ymax) ymax = ty;
		}
	    }
	    x = xmin;
	    y = ymin;
	    width = xmax - xmin;
	    height = ymax - ymin;
	}
        x += pPicture->pDrawable->x;
        y += pPicture->pDrawable->y;
	(*pScreen->SourceValidate) (pDrawable, x, y, width, height);
d354 8
d451 1
a451 1
    miCompositeSourceValidate (pSrc, xSrc, ySrc, width, height);
d453 1
a453 1
	miCompositeSourceValidate (pMask, xMask, yMask, width, height);
d602 2
a603 4
    ps->Trapezoids	= miTrapezoids;
    ps->Triangles	= miTriangles;
    ps->TriStrip	= miTriStrip;
    ps->TriFan		= miTriFan;
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d50 1
a50 1
	REGION_DESTROY(pPicture->pDrawable->pScreen, pPicture->pCompositeClip);
d67 1
a67 1
	REGION_DESTROY(pPicture->pDrawable->pScreen, pPicture->clientClip);
d88 1
a88 1
	clientClip = (pointer) BITMAP_TO_REGION(pScreen, (PixmapPtr) value);
d103 1
a103 1
	clientClip = (pointer) RECTS_TO_REGION(pScreen, n,
d109 1
a109 1
	xfree(value);
d163 1
a163 1
		    REGION_DESTROY(pScreen, pPicture->pCompositeClip);
d178 1
a178 1
		REGION_TRANSLATE(pScreen, pPicture->clientClip,
d184 1
a184 1
		    REGION_INTERSECT(pScreen, pPicture->pCompositeClip,
d187 1
a187 1
			REGION_DESTROY(pScreen, pregWin);
d191 1
a191 1
		    REGION_INTERSECT(pScreen, pregWin, pregWin, pPicture->clientClip);
d196 2
a197 2
		    pPicture->pCompositeClip = REGION_CREATE(pScreen, NullBox, 0);
		    REGION_INTERSECT(pScreen, pPicture->pCompositeClip,
d201 1
a201 1
		REGION_TRANSLATE(pScreen, pPicture->clientClip,
d219 1
a219 1
		REGION_RESET(pScreen, pPicture->pCompositeClip, &pixbounds);
d224 1
a224 1
		pPicture->pCompositeClip = REGION_CREATE(pScreen, &pixbounds, 1);
d230 1
a230 1
		    REGION_TRANSLATE(pScreen, pPicture->clientClip,
d233 1
a233 1
		    REGION_INTERSECT(pScreen, pPicture->pCompositeClip,
d235 1
a235 1
		    REGION_TRANSLATE(pScreen, pPicture->clientClip,
d239 1
a239 1
		    REGION_TRANSLATE(pScreen, pPicture->pCompositeClip,
d241 1
a241 1
		    REGION_INTERSECT(pScreen, pPicture->pCompositeClip,
d243 1
a243 1
		    REGION_TRANSLATE(pScreen, pPicture->pCompositeClip,
d324 1
a324 1
	result = REGION_INTERSECT (pScreen, pRegion, pRegion, pPicture->clientClip);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d316 1
a316 4
    /* XXX what to do with clipping from transformed pictures? */
    if (pPicture->transform || !pPicture->pDrawable)
	return TRUE;
    if (pPicture->repeat)
d318 14
a331 20
	if (pPicture->clientClipType != CT_NONE)
	{
	    pixman_region_translate ( pRegion, 
			     dx - pPicture->clipOrigin.x,
			     dy - pPicture->clipOrigin.y);
	    if (!REGION_INTERSECT (pScreen, pRegion, pRegion, 
				   (RegionPtr) pPicture->pCompositeClip)) // clientClip))
		return FALSE;
	    pixman_region_translate ( pRegion, 
			     - (dx - pPicture->clipOrigin.x),
			     - (dy - pPicture->clipOrigin.y));
	}
	return TRUE;
    }
    else
    {
	return miClipPictureReg (pRegion,
				 pPicture->pCompositeClip,
				 dx,
				 dy);
d333 1
a352 2
        x -= pPicture->pDrawable->x;
        y -= pPicture->pDrawable->y;
d387 2
d398 1
a398 1
_X_EXPORT Bool
d454 2
a455 2
			       xDst - (xSrc + pSrc->alphaOrigin.x),
			       yDst - (ySrc + pSrc->alphaOrigin.y)))
d472 2
a473 2
				   xDst - (xMask + pMask->alphaOrigin.x),
				   yDst - (yMask + pMask->alphaOrigin.y)))
d607 1
a607 1
_X_EXPORT Bool
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
 /*
d269 3
a271 3
static __inline Bool
miClipPictureReg (RegionPtr	pRegion,
		  RegionPtr	pClip,
d275 2
a276 2
    if (REGION_NUM_RECTS(pRegion) == 1 &&
	REGION_NUM_RECTS(pClip) == 1)
d278 2
a279 2
	BoxPtr  pRbox = REGION_RECTS(pRegion);
	BoxPtr  pCbox = REGION_RECTS(pClip);
d281 1
a281 1

d293 1
a293 1
	    REGION_EMPTY(pScreen, pRegion);
d296 1
a296 1
    else if (!REGION_NOTEMPTY (pScreen, pClip))
d301 2
a302 2
	    REGION_TRANSLATE(pScreen, pRegion, -dx, -dy);
	if (!REGION_INTERSECT (pScreen, pRegion, pRegion, pClip))
d305 1
a305 1
	    REGION_TRANSLATE(pScreen, pRegion, dx, dy);
d307 1
a307 1
    return REGION_NOTEMPTY(pScreen, pRegion);
d309 1
a309 1
		  
d323 1
a323 1
	    REGION_TRANSLATE(pScreen, pRegion, 
d327 1
a327 1
				   (RegionPtr) pPicture->clientClip))
d329 1
a329 1
	    REGION_TRANSLATE(pScreen, pRegion, 
d344 1
a344 1
static void
d382 1
a382 1
		if (PictureTransformPoint (pPicture->transform, &t))
d420 1
d434 1
a434 1
	REGION_EMPTY (pDst->pDrawable->pScreen, pRegion);
d440 1
a440 1
	REGION_UNINIT (pScreen, pRegion);
d449 1
a449 1
	    REGION_UNINIT (pScreen, pRegion);
d456 1
a456 1
	REGION_UNINIT (pScreen, pRegion);
d465 1
a465 1
	    REGION_UNINIT (pScreen, pRegion);
d474 1
a474 1
	    REGION_UNINIT (pScreen, pRegion);
d483 1
a483 1
		REGION_UNINIT (pScreen, pRegion);
d488 2
d493 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
a1 1
/*
d269 3
a271 3
static inline pixman_bool_t
miClipPictureReg (pixman_region16_t *	pRegion,
		  pixman_region16_t *	pClip,
d275 2
a276 2
    if (pixman_region_n_rects(pRegion) == 1 &&
	pixman_region_n_rects(pClip) == 1)
d278 2
a279 2
	pixman_box16_t *  pRbox = pixman_region_rectangles(pRegion, NULL);
	pixman_box16_t *  pCbox = pixman_region_rectangles(pClip, NULL);
d281 1
a281 1
	
d293 1
a293 1
	    pixman_region_init (pRegion);
d296 1
a296 1
    else if (!pixman_region_not_empty (pClip))
d301 2
a302 2
	    pixman_region_translate (pRegion, -dx, -dy);
	if (!pixman_region_intersect (pRegion, pRegion, pClip))
d305 1
a305 1
	    pixman_region_translate(pRegion, dx, dy);
d307 1
a307 1
    return pixman_region_not_empty(pRegion);
d309 1
a309 1

d323 1
a323 1
	    pixman_region_translate ( pRegion, 
d327 1
a327 1
				   (RegionPtr) pPicture->pCompositeClip)) // clientClip))
d329 1
a329 1
	    pixman_region_translate ( pRegion, 
d344 1
a344 1
void
a419 1
    
d433 1
a433 1
	pixman_region_init (pRegion);
d439 1
a439 1
	pixman_region_fini (pRegion);
d448 1
a448 1
	    pixman_region_fini (pRegion);
d455 1
a455 1
	pixman_region_fini (pRegion);
d464 1
a464 1
	    pixman_region_fini (pRegion);
d473 1
a473 1
	    pixman_region_fini (pRegion);
d482 1
a482 1
		pixman_region_fini (pRegion);
a486 2

    
a489 1

@

