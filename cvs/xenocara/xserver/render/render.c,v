head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.4
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.2
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.3
	OPENBSD_4_2:1.4.0.2
	OPENBSD_4_2_BASE:1.4
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.19;
commitid	s0SI41sEunLdyFfd;

1.19
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.18;
commitid	7pAEtF6Y5EgemkuY;

1.18
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.17;
commitid	Te1daavkBLskZ8gc;

1.17
date	2014.12.09.17.58.53;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	vcnjRBuLQw44cPHf;

1.16
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	cVXoV5PxI8YrEaVA;

1.15
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches
	1.15.4.1
	1.15.6.1;
next	1.14;

1.14
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.21.20.10.49;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.31.14.09.44;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.11.15.39.26;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.24.19.04.07;	author matthieu;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2007.08.06.16.15.08;	author matthieu;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2007.06.13.22.53.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.09.14.24.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.23;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.23;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.09.18;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.18.05.19;	author matthieu;	state Exp;
branches;
next	;

1.4.2.1
date	2008.07.13.03.11.28;	author brad;	state Exp;
branches;
next	;

1.5.2.1
date	2008.07.13.03.08.30;	author brad;	state Exp;
branches;
next	;

1.15.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.15.6.1
date	2014.12.09.17.59.33;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.20
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *
 * Copyright Â© 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "resource.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "colormapst.h"
#include "extnsionst.h"
#include "extinit.h"
#include "servermd.h"
#include <X11/extensions/render.h>
#include <X11/extensions/renderproto.h>
#include "picturestr.h"
#include "glyphstr.h"
#include <X11/Xfuncproto.h>
#include "cursorstr.h"
#include "xace.h"
#include "protocol-versions.h"

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif

#include <stdint.h>

static int ProcRenderQueryVersion(ClientPtr pClient);
static int ProcRenderQueryPictFormats(ClientPtr pClient);
static int ProcRenderQueryPictIndexValues(ClientPtr pClient);
static int ProcRenderQueryDithers(ClientPtr pClient);
static int ProcRenderCreatePicture(ClientPtr pClient);
static int ProcRenderChangePicture(ClientPtr pClient);
static int ProcRenderSetPictureClipRectangles(ClientPtr pClient);
static int ProcRenderFreePicture(ClientPtr pClient);
static int ProcRenderComposite(ClientPtr pClient);
static int ProcRenderScale(ClientPtr pClient);
static int ProcRenderTrapezoids(ClientPtr pClient);
static int ProcRenderTriangles(ClientPtr pClient);
static int ProcRenderTriStrip(ClientPtr pClient);
static int ProcRenderTriFan(ClientPtr pClient);
static int ProcRenderColorTrapezoids(ClientPtr pClient);
static int ProcRenderColorTriangles(ClientPtr pClient);
static int ProcRenderTransform(ClientPtr pClient);
static int ProcRenderCreateGlyphSet(ClientPtr pClient);
static int ProcRenderReferenceGlyphSet(ClientPtr pClient);
static int ProcRenderFreeGlyphSet(ClientPtr pClient);
static int ProcRenderAddGlyphs(ClientPtr pClient);
static int ProcRenderAddGlyphsFromPicture(ClientPtr pClient);
static int ProcRenderFreeGlyphs(ClientPtr pClient);
static int ProcRenderCompositeGlyphs(ClientPtr pClient);
static int ProcRenderFillRectangles(ClientPtr pClient);
static int ProcRenderCreateCursor(ClientPtr pClient);
static int ProcRenderSetPictureTransform(ClientPtr pClient);
static int ProcRenderQueryFilters(ClientPtr pClient);
static int ProcRenderSetPictureFilter(ClientPtr pClient);
static int ProcRenderCreateAnimCursor(ClientPtr pClient);
static int ProcRenderAddTraps(ClientPtr pClient);
static int ProcRenderCreateSolidFill(ClientPtr pClient);
static int ProcRenderCreateLinearGradient(ClientPtr pClient);
static int ProcRenderCreateRadialGradient(ClientPtr pClient);
static int ProcRenderCreateConicalGradient(ClientPtr pClient);

static int ProcRenderDispatch(ClientPtr pClient);

static int SProcRenderQueryVersion(ClientPtr pClient);
static int SProcRenderQueryPictFormats(ClientPtr pClient);
static int SProcRenderQueryPictIndexValues(ClientPtr pClient);
static int SProcRenderQueryDithers(ClientPtr pClient);
static int SProcRenderCreatePicture(ClientPtr pClient);
static int SProcRenderChangePicture(ClientPtr pClient);
static int SProcRenderSetPictureClipRectangles(ClientPtr pClient);
static int SProcRenderFreePicture(ClientPtr pClient);
static int SProcRenderComposite(ClientPtr pClient);
static int SProcRenderScale(ClientPtr pClient);
static int SProcRenderTrapezoids(ClientPtr pClient);
static int SProcRenderTriangles(ClientPtr pClient);
static int SProcRenderTriStrip(ClientPtr pClient);
static int SProcRenderTriFan(ClientPtr pClient);
static int SProcRenderColorTrapezoids(ClientPtr pClient);
static int SProcRenderColorTriangles(ClientPtr pClient);
static int SProcRenderTransform(ClientPtr pClient);
static int SProcRenderCreateGlyphSet(ClientPtr pClient);
static int SProcRenderReferenceGlyphSet(ClientPtr pClient);
static int SProcRenderFreeGlyphSet(ClientPtr pClient);
static int SProcRenderAddGlyphs(ClientPtr pClient);
static int SProcRenderAddGlyphsFromPicture(ClientPtr pClient);
static int SProcRenderFreeGlyphs(ClientPtr pClient);
static int SProcRenderCompositeGlyphs(ClientPtr pClient);
static int SProcRenderFillRectangles(ClientPtr pClient);
static int SProcRenderCreateCursor(ClientPtr pClient);
static int SProcRenderSetPictureTransform(ClientPtr pClient);
static int SProcRenderQueryFilters(ClientPtr pClient);
static int SProcRenderSetPictureFilter(ClientPtr pClient);
static int SProcRenderCreateAnimCursor(ClientPtr pClient);
static int SProcRenderAddTraps(ClientPtr pClient);
static int SProcRenderCreateSolidFill(ClientPtr pClient);
static int SProcRenderCreateLinearGradient(ClientPtr pClient);
static int SProcRenderCreateRadialGradient(ClientPtr pClient);
static int SProcRenderCreateConicalGradient(ClientPtr pClient);

static int SProcRenderDispatch(ClientPtr pClient);

int (*ProcRenderVector[RenderNumberRequests]) (ClientPtr) = {
ProcRenderQueryVersion,
        ProcRenderQueryPictFormats,
        ProcRenderQueryPictIndexValues,
        ProcRenderQueryDithers,
        ProcRenderCreatePicture,
        ProcRenderChangePicture,
        ProcRenderSetPictureClipRectangles,
        ProcRenderFreePicture,
        ProcRenderComposite,
        ProcRenderScale,
        ProcRenderTrapezoids,
        ProcRenderTriangles,
        ProcRenderTriStrip,
        ProcRenderTriFan,
        ProcRenderColorTrapezoids,
        ProcRenderColorTriangles,
        ProcRenderTransform,
        ProcRenderCreateGlyphSet,
        ProcRenderReferenceGlyphSet,
        ProcRenderFreeGlyphSet,
        ProcRenderAddGlyphs,
        ProcRenderAddGlyphsFromPicture,
        ProcRenderFreeGlyphs,
        ProcRenderCompositeGlyphs,
        ProcRenderCompositeGlyphs,
        ProcRenderCompositeGlyphs,
        ProcRenderFillRectangles,
        ProcRenderCreateCursor,
        ProcRenderSetPictureTransform,
        ProcRenderQueryFilters,
        ProcRenderSetPictureFilter,
        ProcRenderCreateAnimCursor,
        ProcRenderAddTraps,
        ProcRenderCreateSolidFill,
        ProcRenderCreateLinearGradient,
        ProcRenderCreateRadialGradient, ProcRenderCreateConicalGradient};

int (*SProcRenderVector[RenderNumberRequests]) (ClientPtr) = {
SProcRenderQueryVersion,
        SProcRenderQueryPictFormats,
        SProcRenderQueryPictIndexValues,
        SProcRenderQueryDithers,
        SProcRenderCreatePicture,
        SProcRenderChangePicture,
        SProcRenderSetPictureClipRectangles,
        SProcRenderFreePicture,
        SProcRenderComposite,
        SProcRenderScale,
        SProcRenderTrapezoids,
        SProcRenderTriangles,
        SProcRenderTriStrip,
        SProcRenderTriFan,
        SProcRenderColorTrapezoids,
        SProcRenderColorTriangles,
        SProcRenderTransform,
        SProcRenderCreateGlyphSet,
        SProcRenderReferenceGlyphSet,
        SProcRenderFreeGlyphSet,
        SProcRenderAddGlyphs,
        SProcRenderAddGlyphsFromPicture,
        SProcRenderFreeGlyphs,
        SProcRenderCompositeGlyphs,
        SProcRenderCompositeGlyphs,
        SProcRenderCompositeGlyphs,
        SProcRenderFillRectangles,
        SProcRenderCreateCursor,
        SProcRenderSetPictureTransform,
        SProcRenderQueryFilters,
        SProcRenderSetPictureFilter,
        SProcRenderCreateAnimCursor,
        SProcRenderAddTraps,
        SProcRenderCreateSolidFill,
        SProcRenderCreateLinearGradient,
        SProcRenderCreateRadialGradient, SProcRenderCreateConicalGradient};

int RenderErrBase;
static DevPrivateKeyRec RenderClientPrivateKeyRec;

#define RenderClientPrivateKey (&RenderClientPrivateKeyRec )

typedef struct _RenderClient {
    int major_version;
    int minor_version;
} RenderClientRec, *RenderClientPtr;

#define GetRenderClient(pClient) ((RenderClientPtr)dixLookupPrivate(&(pClient)->devPrivates, RenderClientPrivateKey))

static void
RenderClientCallback(CallbackListPtr *list, void *closure, void *data)
{
    NewClientInfoRec *clientinfo = (NewClientInfoRec *) data;
    ClientPtr pClient = clientinfo->client;
    RenderClientPtr pRenderClient = GetRenderClient(pClient);

    pRenderClient->major_version = 0;
    pRenderClient->minor_version = 0;
}

#ifdef PANORAMIX
RESTYPE XRT_PICTURE;
#endif

void
RenderExtensionInit(void)
{
    ExtensionEntry *extEntry;

    if (!PictureType)
        return;
    if (!PictureFinishInit())
        return;
    if (!dixRegisterPrivateKey
        (&RenderClientPrivateKeyRec, PRIVATE_CLIENT, sizeof(RenderClientRec)))
        return;
    if (!AddCallback(&ClientStateCallback, RenderClientCallback, 0))
        return;

    extEntry = AddExtension(RENDER_NAME, 0, RenderNumberErrors,
                            ProcRenderDispatch, SProcRenderDispatch,
                            NULL, StandardMinorOpcode);
    if (!extEntry)
        return;
    RenderErrBase = extEntry->errorBase;
#ifdef PANORAMIX
    if (XRT_PICTURE)
        SetResourceTypeErrorValue(XRT_PICTURE, RenderErrBase + BadPicture);
#endif
    SetResourceTypeErrorValue(PictureType, RenderErrBase + BadPicture);
    SetResourceTypeErrorValue(PictFormatType, RenderErrBase + BadPictFormat);
    SetResourceTypeErrorValue(GlyphSetType, RenderErrBase + BadGlyphSet);
}

static int
ProcRenderQueryVersion(ClientPtr client)
{
    RenderClientPtr pRenderClient = GetRenderClient(client);
    xRenderQueryVersionReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };

    REQUEST(xRenderQueryVersionReq);

    REQUEST_SIZE_MATCH(xRenderQueryVersionReq);

    pRenderClient->major_version = stuff->majorVersion;
    pRenderClient->minor_version = stuff->minorVersion;

    if ((stuff->majorVersion * 1000 + stuff->minorVersion) <
        (SERVER_RENDER_MAJOR_VERSION * 1000 + SERVER_RENDER_MINOR_VERSION)) {
        rep.majorVersion = stuff->majorVersion;
        rep.minorVersion = stuff->minorVersion;
    }
    else {
        rep.majorVersion = SERVER_RENDER_MAJOR_VERSION;
        rep.minorVersion = SERVER_RENDER_MINOR_VERSION;
    }

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.majorVersion);
        swapl(&rep.minorVersion);
    }
    WriteToClient(client, sizeof(xRenderQueryVersionReply), &rep);
    return Success;
}

static VisualPtr
findVisual(ScreenPtr pScreen, VisualID vid)
{
    VisualPtr pVisual;
    int v;

    for (v = 0; v < pScreen->numVisuals; v++) {
        pVisual = pScreen->visuals + v;
        if (pVisual->vid == vid)
            return pVisual;
    }
    return 0;
}

static int
ProcRenderQueryPictFormats(ClientPtr client)
{
    RenderClientPtr pRenderClient = GetRenderClient(client);
    xRenderQueryPictFormatsReply *reply;
    xPictScreen *pictScreen;
    xPictDepth *pictDepth;
    xPictVisual *pictVisual;
    xPictFormInfo *pictForm;
    CARD32 *pictSubpixel;
    ScreenPtr pScreen;
    VisualPtr pVisual;
    DepthPtr pDepth;
    int v, d;
    PictureScreenPtr ps;
    PictFormatPtr pFormat;
    int nformat;
    int ndepth;
    int nvisual;
    int rlength;
    int s;
    int numScreens;
    int numSubpixel;

/*    REQUEST(xRenderQueryPictFormatsReq); */

    REQUEST_SIZE_MATCH(xRenderQueryPictFormatsReq);

#ifdef PANORAMIX
    if (noPanoramiXExtension)
        numScreens = screenInfo.numScreens;
    else
        numScreens = ((xConnSetup *) ConnectionInfo)->numRoots;
#else
    numScreens = screenInfo.numScreens;
#endif
    ndepth = nformat = nvisual = 0;
    for (s = 0; s < numScreens; s++) {
        pScreen = screenInfo.screens[s];
        for (d = 0; d < pScreen->numDepths; d++) {
            pDepth = pScreen->allowedDepths + d;
            ++ndepth;

            for (v = 0; v < pDepth->numVids; v++) {
                pVisual = findVisual(pScreen, pDepth->vids[v]);
                if (pVisual &&
                    PictureMatchVisual(pScreen, pDepth->depth, pVisual))
                    ++nvisual;
            }
        }
        ps = GetPictureScreenIfSet(pScreen);
        if (ps)
            nformat += ps->nformats;
    }
    if (pRenderClient->major_version == 0 && pRenderClient->minor_version < 6)
        numSubpixel = 0;
    else
        numSubpixel = numScreens;

    rlength = (sizeof(xRenderQueryPictFormatsReply) +
               nformat * sizeof(xPictFormInfo) +
               numScreens * sizeof(xPictScreen) +
               ndepth * sizeof(xPictDepth) +
               nvisual * sizeof(xPictVisual) + numSubpixel * sizeof(CARD32));
    reply = (xRenderQueryPictFormatsReply *) calloc(1, rlength);
    if (!reply)
        return BadAlloc;
    reply->type = X_Reply;
    reply->sequenceNumber = client->sequence;
    reply->length = bytes_to_int32(rlength - sizeof(xGenericReply));
    reply->numFormats = nformat;
    reply->numScreens = numScreens;
    reply->numDepths = ndepth;
    reply->numVisuals = nvisual;
    reply->numSubpixel = numSubpixel;

    pictForm = (xPictFormInfo *) (reply + 1);

    for (s = 0; s < numScreens; s++) {
        pScreen = screenInfo.screens[s];
        ps = GetPictureScreenIfSet(pScreen);
        if (ps) {
            for (nformat = 0, pFormat = ps->formats;
                 nformat < ps->nformats; nformat++, pFormat++) {
                pictForm->id = pFormat->id;
                pictForm->type = pFormat->type;
                pictForm->depth = pFormat->depth;
                pictForm->direct.red = pFormat->direct.red;
                pictForm->direct.redMask = pFormat->direct.redMask;
                pictForm->direct.green = pFormat->direct.green;
                pictForm->direct.greenMask = pFormat->direct.greenMask;
                pictForm->direct.blue = pFormat->direct.blue;
                pictForm->direct.blueMask = pFormat->direct.blueMask;
                pictForm->direct.alpha = pFormat->direct.alpha;
                pictForm->direct.alphaMask = pFormat->direct.alphaMask;
                if (pFormat->type == PictTypeIndexed &&
                    pFormat->index.pColormap)
                    pictForm->colormap = pFormat->index.pColormap->mid;
                else
                    pictForm->colormap = None;
                if (client->swapped) {
                    swapl(&pictForm->id);
                    swaps(&pictForm->direct.red);
                    swaps(&pictForm->direct.redMask);
                    swaps(&pictForm->direct.green);
                    swaps(&pictForm->direct.greenMask);
                    swaps(&pictForm->direct.blue);
                    swaps(&pictForm->direct.blueMask);
                    swaps(&pictForm->direct.alpha);
                    swaps(&pictForm->direct.alphaMask);
                    swapl(&pictForm->colormap);
                }
                pictForm++;
            }
        }
    }

    pictScreen = (xPictScreen *) pictForm;
    for (s = 0; s < numScreens; s++) {
        pScreen = screenInfo.screens[s];
        pictDepth = (xPictDepth *) (pictScreen + 1);
        ndepth = 0;
        for (d = 0; d < pScreen->numDepths; d++) {
            pictVisual = (xPictVisual *) (pictDepth + 1);
            pDepth = pScreen->allowedDepths + d;

            nvisual = 0;
            for (v = 0; v < pDepth->numVids; v++) {
                pVisual = findVisual(pScreen, pDepth->vids[v]);
                if (pVisual && (pFormat = PictureMatchVisual(pScreen,
                                                             pDepth->depth,
                                                             pVisual))) {
                    pictVisual->visual = pVisual->vid;
                    pictVisual->format = pFormat->id;
                    if (client->swapped) {
                        swapl(&pictVisual->visual);
                        swapl(&pictVisual->format);
                    }
                    pictVisual++;
                    nvisual++;
                }
            }
            pictDepth->depth = pDepth->depth;
            pictDepth->nPictVisuals = nvisual;
            if (client->swapped) {
                swaps(&pictDepth->nPictVisuals);
            }
            ndepth++;
            pictDepth = (xPictDepth *) pictVisual;
        }
        pictScreen->nDepth = ndepth;
        ps = GetPictureScreenIfSet(pScreen);
        if (ps)
            pictScreen->fallback = ps->fallback->id;
        else
            pictScreen->fallback = 0;
        if (client->swapped) {
            swapl(&pictScreen->nDepth);
            swapl(&pictScreen->fallback);
        }
        pictScreen = (xPictScreen *) pictDepth;
    }
    pictSubpixel = (CARD32 *) pictScreen;

    for (s = 0; s < numSubpixel; s++) {
        pScreen = screenInfo.screens[s];
        ps = GetPictureScreenIfSet(pScreen);
        if (ps)
            *pictSubpixel = ps->subpixel;
        else
            *pictSubpixel = SubPixelUnknown;
        if (client->swapped) {
            swapl(pictSubpixel);
        }
        ++pictSubpixel;
    }

    if (client->swapped) {
        swaps(&reply->sequenceNumber);
        swapl(&reply->length);
        swapl(&reply->numFormats);
        swapl(&reply->numScreens);
        swapl(&reply->numDepths);
        swapl(&reply->numVisuals);
        swapl(&reply->numSubpixel);
    }
    WriteToClient(client, rlength, reply);
    free(reply);
    return Success;
}

static int
ProcRenderQueryPictIndexValues(ClientPtr client)
{
    PictFormatPtr pFormat;
    int rc, num;
    int rlength;
    int i;

    REQUEST(xRenderQueryPictIndexValuesReq);
    xRenderQueryPictIndexValuesReply *reply;
    xIndexValue *values;

    REQUEST_AT_LEAST_SIZE(xRenderQueryPictIndexValuesReq);

    rc = dixLookupResourceByType((void **) &pFormat, stuff->format,
                                 PictFormatType, client, DixReadAccess);
    if (rc != Success)
        return rc;

    if (pFormat->type != PictTypeIndexed) {
        client->errorValue = stuff->format;
        return BadMatch;
    }
    num = pFormat->index.nvalues;
    rlength = (sizeof(xRenderQueryPictIndexValuesReply) +
               num * sizeof(xIndexValue));
    reply = (xRenderQueryPictIndexValuesReply *) calloc(1, rlength);
    if (!reply)
        return BadAlloc;

    reply->type = X_Reply;
    reply->sequenceNumber = client->sequence;
    reply->length = bytes_to_int32(rlength - sizeof(xGenericReply));
    reply->numIndexValues = num;

    values = (xIndexValue *) (reply + 1);

    memcpy(reply + 1, pFormat->index.pValues, num * sizeof(xIndexValue));

    if (client->swapped) {
        for (i = 0; i < num; i++) {
            swapl(&values[i].pixel);
            swaps(&values[i].red);
            swaps(&values[i].green);
            swaps(&values[i].blue);
            swaps(&values[i].alpha);
        }
        swaps(&reply->sequenceNumber);
        swapl(&reply->length);
        swapl(&reply->numIndexValues);
    }

    WriteToClient(client, rlength, reply);
    free(reply);
    return Success;
}

static int
ProcRenderQueryDithers(ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderCreatePicture(ClientPtr client)
{
    PicturePtr pPicture;
    DrawablePtr pDrawable;
    PictFormatPtr pFormat;
    int len, error, rc;

    REQUEST(xRenderCreatePictureReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreatePictureReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);
    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
                           DixReadAccess | DixAddAccess);
    if (rc != Success)
        return rc;

    rc = dixLookupResourceByType((void **) &pFormat, stuff->format,
                                 PictFormatType, client, DixReadAccess);
    if (rc != Success)
        return rc;

    if (pFormat->depth != pDrawable->depth)
        return BadMatch;
    len = client->req_len - bytes_to_int32(sizeof(xRenderCreatePictureReq));
    if (Ones(stuff->mask) != len)
        return BadLength;

    pPicture = CreatePicture(stuff->pid,
                             pDrawable,
                             pFormat,
                             stuff->mask, (XID *) (stuff + 1), client, &error);
    if (!pPicture)
        return error;
    if (!AddResource(stuff->pid, PictureType, (void *) pPicture))
        return BadAlloc;
    return Success;
}

static int
ProcRenderChangePicture(ClientPtr client)
{
    PicturePtr pPicture;

    REQUEST(xRenderChangePictureReq);
    int len;

    REQUEST_AT_LEAST_SIZE(xRenderChangePictureReq);
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixSetAttrAccess);

    len = client->req_len - bytes_to_int32(sizeof(xRenderChangePictureReq));
    if (Ones(stuff->mask) != len)
        return BadLength;

    return ChangePicture(pPicture, stuff->mask, (XID *) (stuff + 1),
                         (DevUnion *) 0, client);
}

static int
ProcRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    PicturePtr pPicture;
    int nr;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixSetAttrAccess);
    if (!pPicture->pDrawable)
        return RenderErrBase + BadPicture;

    nr = (client->req_len << 2) - sizeof(xRenderSetPictureClipRectanglesReq);
    if (nr & 4)
        return BadLength;
    nr >>= 3;
    return SetPictureClipRects(pPicture,
                               stuff->xOrigin, stuff->yOrigin,
                               nr, (xRectangle *) &stuff[1]);
}

static int
ProcRenderFreePicture(ClientPtr client)
{
    PicturePtr pPicture;

    REQUEST(xRenderFreePictureReq);

    REQUEST_SIZE_MATCH(xRenderFreePictureReq);

    VERIFY_PICTURE(pPicture, stuff->picture, client, DixDestroyAccess);
    FreeResource(stuff->picture, RT_NONE);
    return Success;
}

static Bool
PictOpValid(CARD8 op)
{
    if ( /*PictOpMinimum <= op && */ op <= PictOpMaximum)
        return TRUE;
    if (PictOpDisjointMinimum <= op && op <= PictOpDisjointMaximum)
        return TRUE;
    if (PictOpConjointMinimum <= op && op <= PictOpConjointMaximum)
        return TRUE;
    if (PictOpBlendMinimum <= op && op <= PictOpBlendMaximum)
        return TRUE;
    return FALSE;
}

static int
ProcRenderComposite(ClientPtr client)
{
    PicturePtr pSrc, pMask, pDst;

    REQUEST(xRenderCompositeReq);

    REQUEST_SIZE_MATCH(xRenderCompositeReq);
    if (!PictOpValid(stuff->op)) {
        client->errorValue = stuff->op;
        return BadValue;
    }
    VERIFY_PICTURE(pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    VERIFY_PICTURE(pSrc, stuff->src, client, DixReadAccess);
    VERIFY_ALPHA(pMask, stuff->mask, client, DixReadAccess);
    if ((pSrc->pDrawable &&
         pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen) || (pMask &&
                                                                   pMask->
                                                                   pDrawable &&
                                                                   pDst->
                                                                   pDrawable->
                                                                   pScreen !=
                                                                   pMask->
                                                                   pDrawable->
                                                                   pScreen))
        return BadMatch;
    CompositePicture(stuff->op,
                     pSrc,
                     pMask,
                     pDst,
                     stuff->xSrc,
                     stuff->ySrc,
                     stuff->xMask,
                     stuff->yMask,
                     stuff->xDst, stuff->yDst, stuff->width, stuff->height);
    return Success;
}

static int
ProcRenderScale(ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderTrapezoids(ClientPtr client)
{
    int rc, ntraps;
    PicturePtr pSrc, pDst;
    PictFormatPtr pFormat;

    REQUEST(xRenderTrapezoidsReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrapezoidsReq);
    if (!PictOpValid(stuff->op)) {
        client->errorValue = stuff->op;
        return BadValue;
    }
    VERIFY_PICTURE(pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE(pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)
        return BadMatch;
    if (stuff->maskFormat) {
        rc = dixLookupResourceByType((void **) &pFormat, stuff->maskFormat,
                                     PictFormatType, client, DixReadAccess);
        if (rc != Success)
            return rc;
    }
    else
        pFormat = 0;
    ntraps = (client->req_len << 2) - sizeof(xRenderTrapezoidsReq);
    if (ntraps % sizeof(xTrapezoid))
        return BadLength;
    ntraps /= sizeof(xTrapezoid);
    if (ntraps)
        CompositeTrapezoids(stuff->op, pSrc, pDst, pFormat,
                            stuff->xSrc, stuff->ySrc,
                            ntraps, (xTrapezoid *) &stuff[1]);
    return Success;
}

static int
ProcRenderTriangles(ClientPtr client)
{
    int rc, ntris;
    PicturePtr pSrc, pDst;
    PictFormatPtr pFormat;

    REQUEST(xRenderTrianglesReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrianglesReq);
    if (!PictOpValid(stuff->op)) {
        client->errorValue = stuff->op;
        return BadValue;
    }
    VERIFY_PICTURE(pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE(pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)
        return BadMatch;
    if (stuff->maskFormat) {
        rc = dixLookupResourceByType((void **) &pFormat, stuff->maskFormat,
                                     PictFormatType, client, DixReadAccess);
        if (rc != Success)
            return rc;
    }
    else
        pFormat = 0;
    ntris = (client->req_len << 2) - sizeof(xRenderTrianglesReq);
    if (ntris % sizeof(xTriangle))
        return BadLength;
    ntris /= sizeof(xTriangle);
    if (ntris)
        CompositeTriangles(stuff->op, pSrc, pDst, pFormat,
                           stuff->xSrc, stuff->ySrc,
                           ntris, (xTriangle *) &stuff[1]);
    return Success;
}

static int
ProcRenderTriStrip(ClientPtr client)
{
    int rc, npoints;
    PicturePtr pSrc, pDst;
    PictFormatPtr pFormat;

    REQUEST(xRenderTrianglesReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrianglesReq);
    if (!PictOpValid(stuff->op)) {
        client->errorValue = stuff->op;
        return BadValue;
    }
    VERIFY_PICTURE(pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE(pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)
        return BadMatch;
    if (stuff->maskFormat) {
        rc = dixLookupResourceByType((void **) &pFormat, stuff->maskFormat,
                                     PictFormatType, client, DixReadAccess);
        if (rc != Success)
            return rc;
    }
    else
        pFormat = 0;
    npoints = ((client->req_len << 2) - sizeof(xRenderTriStripReq));
    if (npoints & 4)
        return BadLength;
    npoints >>= 3;
    if (npoints >= 3)
        CompositeTriStrip(stuff->op, pSrc, pDst, pFormat,
                          stuff->xSrc, stuff->ySrc,
                          npoints, (xPointFixed *) &stuff[1]);
    return Success;
}

static int
ProcRenderTriFan(ClientPtr client)
{
    int rc, npoints;
    PicturePtr pSrc, pDst;
    PictFormatPtr pFormat;

    REQUEST(xRenderTrianglesReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrianglesReq);
    if (!PictOpValid(stuff->op)) {
        client->errorValue = stuff->op;
        return BadValue;
    }
    VERIFY_PICTURE(pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE(pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)
        return BadMatch;
    if (stuff->maskFormat) {
        rc = dixLookupResourceByType((void **) &pFormat, stuff->maskFormat,
                                     PictFormatType, client, DixReadAccess);
        if (rc != Success)
            return rc;
    }
    else
        pFormat = 0;
    npoints = ((client->req_len << 2) - sizeof(xRenderTriStripReq));
    if (npoints & 4)
        return BadLength;
    npoints >>= 3;
    if (npoints >= 3)
        CompositeTriFan(stuff->op, pSrc, pDst, pFormat,
                        stuff->xSrc, stuff->ySrc,
                        npoints, (xPointFixed *) &stuff[1]);
    return Success;
}

static int
ProcRenderColorTrapezoids(ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderColorTriangles(ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderTransform(ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderCreateGlyphSet(ClientPtr client)
{
    GlyphSetPtr glyphSet;
    PictFormatPtr format;
    int rc, f;

    REQUEST(xRenderCreateGlyphSetReq);

    REQUEST_SIZE_MATCH(xRenderCreateGlyphSetReq);

    LEGAL_NEW_RESOURCE(stuff->gsid, client);
    rc = dixLookupResourceByType((void **) &format, stuff->format,
                                 PictFormatType, client, DixReadAccess);
    if (rc != Success)
        return rc;

    switch (format->depth) {
    case 1:
        f = GlyphFormat1;
        break;
    case 4:
        f = GlyphFormat4;
        break;
    case 8:
        f = GlyphFormat8;
        break;
    case 16:
        f = GlyphFormat16;
        break;
    case 32:
        f = GlyphFormat32;
        break;
    default:
        return BadMatch;
    }
    if (format->type != PictTypeDirect)
        return BadMatch;
    glyphSet = AllocateGlyphSet(f, format);
    if (!glyphSet)
        return BadAlloc;
    /* security creation/labeling check */
    rc = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->gsid, GlyphSetType,
                  glyphSet, RT_NONE, NULL, DixCreateAccess);
    if (rc != Success)
        return rc;
    if (!AddResource(stuff->gsid, GlyphSetType, (void *) glyphSet))
        return BadAlloc;
    return Success;
}

static int
ProcRenderReferenceGlyphSet(ClientPtr client)
{
    GlyphSetPtr glyphSet;
    int rc;

    REQUEST(xRenderReferenceGlyphSetReq);

    REQUEST_SIZE_MATCH(xRenderReferenceGlyphSetReq);

    LEGAL_NEW_RESOURCE(stuff->gsid, client);

    rc = dixLookupResourceByType((void **) &glyphSet, stuff->existing,
                                 GlyphSetType, client, DixGetAttrAccess);
    if (rc != Success) {
        client->errorValue = stuff->existing;
        return rc;
    }
    glyphSet->refcnt++;
    if (!AddResource(stuff->gsid, GlyphSetType, (void *) glyphSet))
        return BadAlloc;
    return Success;
}

#define NLOCALDELTA	64
#define NLOCALGLYPH	256

static int
ProcRenderFreeGlyphSet(ClientPtr client)
{
    GlyphSetPtr glyphSet;
    int rc;

    REQUEST(xRenderFreeGlyphSetReq);

    REQUEST_SIZE_MATCH(xRenderFreeGlyphSetReq);
    rc = dixLookupResourceByType((void **) &glyphSet, stuff->glyphset,
                                 GlyphSetType, client, DixDestroyAccess);
    if (rc != Success) {
        client->errorValue = stuff->glyphset;
        return rc;
    }
    FreeResource(stuff->glyphset, RT_NONE);
    return Success;
}

typedef struct _GlyphNew {
    Glyph id;
    GlyphPtr glyph;
    Bool found;
    unsigned char sha1[20];
} GlyphNewRec, *GlyphNewPtr;

#define NeedsComponent(f) (PICT_FORMAT_A(f) != 0 && PICT_FORMAT_RGB(f) != 0)

static int
ProcRenderAddGlyphs(ClientPtr client)
{
    GlyphSetPtr glyphSet;

    REQUEST(xRenderAddGlyphsReq);
    GlyphNewRec glyphsLocal[NLOCALGLYPH];
    GlyphNewPtr glyphsBase, glyphs, glyph_new;
    int remain, nglyphs;
    CARD32 *gids;
    xGlyphInfo *gi;
    CARD8 *bits;
    unsigned int size;
    int err;
    int i, screen;
    PicturePtr pSrc = NULL, pDst = NULL;
    PixmapPtr pSrcPix = NULL, pDstPix = NULL;
    CARD32 component_alpha;

    REQUEST_AT_LEAST_SIZE(xRenderAddGlyphsReq);
    err =
        dixLookupResourceByType((void **) &glyphSet, stuff->glyphset,
                                GlyphSetType, client, DixAddAccess);
    if (err != Success) {
        client->errorValue = stuff->glyphset;
        return err;
    }

    err = BadAlloc;
    nglyphs = stuff->nglyphs;
    if (nglyphs > UINT32_MAX / sizeof(GlyphNewRec))
        return BadAlloc;

    component_alpha = NeedsComponent(glyphSet->format->format);

    if (nglyphs <= NLOCALGLYPH) {
        memset(glyphsLocal, 0, sizeof(glyphsLocal));
        glyphsBase = glyphsLocal;
    }
    else {
        glyphsBase = (GlyphNewPtr) calloc(nglyphs, sizeof(GlyphNewRec));
        if (!glyphsBase)
            return BadAlloc;
    }

    remain = (client->req_len << 2) - sizeof(xRenderAddGlyphsReq);

    glyphs = glyphsBase;

    gids = (CARD32 *) (stuff + 1);
    gi = (xGlyphInfo *) (gids + nglyphs);
    bits = (CARD8 *) (gi + nglyphs);
    remain -= (sizeof(CARD32) + sizeof(xGlyphInfo)) * nglyphs;

    /* protect against bad nglyphs */
    if (gi < ((xGlyphInfo *) stuff) ||
        gi > ((xGlyphInfo *) ((CARD32 *) stuff + client->req_len)) ||
        bits < ((CARD8 *) stuff) ||
        bits > ((CARD8 *) ((CARD32 *) stuff + client->req_len))) {
        err = BadLength;
        goto bail;
    }

    for (i = 0; i < nglyphs; i++) {
        size_t padded_width;

        glyph_new = &glyphs[i];

        padded_width = PixmapBytePad(gi[i].width, glyphSet->format->depth);

        if (gi[i].height &&
            padded_width > (UINT32_MAX - sizeof(GlyphRec)) / gi[i].height)
            break;

        size = gi[i].height * padded_width;
        if (remain < size)
            break;

        err = HashGlyph(&gi[i], bits, size, glyph_new->sha1);
        if (err)
            goto bail;

        glyph_new->glyph = FindGlyphByHash(glyph_new->sha1, glyphSet->fdepth);

        if (glyph_new->glyph && glyph_new->glyph != DeletedGlyph) {
            glyph_new->found = TRUE;
        }
        else {
            GlyphPtr glyph;

            glyph_new->found = FALSE;
            glyph_new->glyph = glyph = AllocateGlyph(&gi[i], glyphSet->fdepth);
            if (!glyph) {
                err = BadAlloc;
                goto bail;
            }

            for (screen = 0; screen < screenInfo.numScreens; screen++) {
                int width = gi[i].width;
                int height = gi[i].height;
                int depth = glyphSet->format->depth;
                ScreenPtr pScreen;
                int error;

                /* Skip work if it's invisibly small anyway */
                if (!width || !height)
                    break;

                pScreen = screenInfo.screens[screen];
                pSrcPix = GetScratchPixmapHeader(pScreen,
                                                 width, height,
                                                 depth, depth, -1, bits);
                if (!pSrcPix) {
                    err = BadAlloc;
                    goto bail;
                }

                pSrc = CreatePicture(0, &pSrcPix->drawable,
                                     glyphSet->format, 0, NULL,
                                     serverClient, &error);
                if (!pSrc) {
                    err = BadAlloc;
                    goto bail;
                }

                pDstPix = (pScreen->CreatePixmap) (pScreen,
                                                   width, height, depth,
                                                   CREATE_PIXMAP_USAGE_GLYPH_PICTURE);

                if (!pDstPix) {
                    err = BadAlloc;
                    goto bail;
                }

                pDst = CreatePicture(0, &pDstPix->drawable,
                                  glyphSet->format,
                                  CPComponentAlpha, &component_alpha,
                                  serverClient, &error);
                SetGlyphPicture(glyph, pScreen, pDst);

                /* The picture takes a reference to the pixmap, so we
                   drop ours. */
                (pScreen->DestroyPixmap) (pDstPix);
                pDstPix = NULL;

                if (!pDst) {
                    err = BadAlloc;
                    goto bail;
                }

                CompositePicture(PictOpSrc,
                                 pSrc,
                                 None, pDst, 0, 0, 0, 0, 0, 0, width, height);

                FreePicture((void *) pSrc, 0);
                pSrc = NULL;
                FreeScratchPixmapHeader(pSrcPix);
                pSrcPix = NULL;
            }

            memcpy(glyph_new->glyph->sha1, glyph_new->sha1, 20);
        }

        glyph_new->id = gids[i];

        if (size & 3)
            size += 4 - (size & 3);
        bits += size;
        remain -= size;
    }
    if (remain || i < nglyphs) {
        err = BadLength;
        goto bail;
    }
    if (!ResizeGlyphSet(glyphSet, nglyphs)) {
        err = BadAlloc;
        goto bail;
    }
    for (i = 0; i < nglyphs; i++)
        AddGlyph(glyphSet, glyphs[i].glyph, glyphs[i].id);

    if (glyphsBase != glyphsLocal)
        free(glyphsBase);
    return Success;
 bail:
    if (pSrc)
        FreePicture((void *) pSrc, 0);
    if (pSrcPix)
        FreeScratchPixmapHeader(pSrcPix);
    for (i = 0; i < nglyphs; i++)
        if (glyphs[i].glyph && !glyphs[i].found)
            free(glyphs[i].glyph);
    if (glyphsBase != glyphsLocal)
        free(glyphsBase);
    return err;
}

static int
ProcRenderAddGlyphsFromPicture(ClientPtr client)
{
    return BadImplementation;
}

static int
ProcRenderFreeGlyphs(ClientPtr client)
{
    REQUEST(xRenderFreeGlyphsReq);
    GlyphSetPtr glyphSet;
    int rc, nglyph;
    CARD32 *gids;
    CARD32 glyph;

    REQUEST_AT_LEAST_SIZE(xRenderFreeGlyphsReq);
    rc = dixLookupResourceByType((void **) &glyphSet, stuff->glyphset,
                                 GlyphSetType, client, DixRemoveAccess);
    if (rc != Success) {
        client->errorValue = stuff->glyphset;
        return rc;
    }
    nglyph =
        bytes_to_int32((client->req_len << 2) - sizeof(xRenderFreeGlyphsReq));
    gids = (CARD32 *) (stuff + 1);
    while (nglyph-- > 0) {
        glyph = *gids++;
        if (!DeleteGlyph(glyphSet, glyph)) {
            client->errorValue = glyph;
            return RenderErrBase + BadGlyph;
        }
    }
    return Success;
}

static int
ProcRenderCompositeGlyphs(ClientPtr client)
{
    GlyphSetPtr glyphSet;
    GlyphSet gs;
    PicturePtr pSrc, pDst;
    PictFormatPtr pFormat;
    GlyphListRec listsLocal[NLOCALDELTA];
    GlyphListPtr lists, listsBase;
    GlyphPtr glyphsLocal[NLOCALGLYPH];
    Glyph glyph;
    GlyphPtr *glyphs, *glyphsBase;
    xGlyphElt *elt;
    CARD8 *buffer, *end;
    int nglyph;
    int nlist;
    int space;
    int size;
    int rc, n;

    REQUEST(xRenderCompositeGlyphsReq);

    REQUEST_AT_LEAST_SIZE(xRenderCompositeGlyphsReq);

    switch (stuff->renderReqType) {
    default:
        size = 1;
        break;
    case X_RenderCompositeGlyphs16:
        size = 2;
        break;
    case X_RenderCompositeGlyphs32:
        size = 4;
        break;
    }

    if (!PictOpValid(stuff->op)) {
        client->errorValue = stuff->op;
        return BadValue;
    }
    VERIFY_PICTURE(pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE(pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;
    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)
        return BadMatch;
    if (stuff->maskFormat) {
        rc = dixLookupResourceByType((void **) &pFormat, stuff->maskFormat,
                                     PictFormatType, client, DixReadAccess);
        if (rc != Success)
            return rc;
    }
    else
        pFormat = 0;

    rc = dixLookupResourceByType((void **) &glyphSet, stuff->glyphset,
                                 GlyphSetType, client, DixUseAccess);
    if (rc != Success)
        return rc;

    buffer = (CARD8 *) (stuff + 1);
    end = (CARD8 *) stuff + (client->req_len << 2);
    nglyph = 0;
    nlist = 0;
    while (buffer + sizeof(xGlyphElt) < end) {
        elt = (xGlyphElt *) buffer;
        buffer += sizeof(xGlyphElt);

        if (elt->len == 0xff) {
            buffer += 4;
        }
        else {
            nlist++;
            nglyph += elt->len;
            space = size * elt->len;
            if (space & 3)
                space += 4 - (space & 3);
            buffer += space;
        }
    }
    if (nglyph <= NLOCALGLYPH)
        glyphsBase = glyphsLocal;
    else {
        glyphsBase = xallocarray(nglyph, sizeof(GlyphPtr));
        if (!glyphsBase)
            return BadAlloc;
    }
    if (nlist <= NLOCALDELTA)
        listsBase = listsLocal;
    else {
        listsBase = xallocarray(nlist, sizeof(GlyphListRec));
        if (!listsBase) {
            rc = BadAlloc;
            goto bail;
        }
    }
    buffer = (CARD8 *) (stuff + 1);
    glyphs = glyphsBase;
    lists = listsBase;
    while (buffer + sizeof(xGlyphElt) < end) {
        elt = (xGlyphElt *) buffer;
        buffer += sizeof(xGlyphElt);

        if (elt->len == 0xff) {
            if (buffer + sizeof(GlyphSet) < end) {
                memcpy(&gs, buffer, sizeof(GlyphSet));
                rc = dixLookupResourceByType((void **) &glyphSet, gs,
                                             GlyphSetType, client,
                                             DixUseAccess);
                if (rc != Success)
                    goto bail;
            }
            buffer += 4;
        }
        else {
            lists->xOff = elt->deltax;
            lists->yOff = elt->deltay;
            lists->format = glyphSet->format;
            lists->len = 0;
            n = elt->len;
            while (n--) {
                if (buffer + size <= end) {
                    switch (size) {
                    case 1:
                        glyph = *((CARD8 *) buffer);
                        break;
                    case 2:
                        glyph = *((CARD16 *) buffer);
                        break;
                    case 4:
                    default:
                        glyph = *((CARD32 *) buffer);
                        break;
                    }
                    if ((*glyphs = FindGlyph(glyphSet, glyph))) {
                        lists->len++;
                        glyphs++;
                    }
                }
                buffer += size;
            }
            space = size * elt->len;
            if (space & 3)
                buffer += 4 - (space & 3);
            lists++;
        }
    }
    if (buffer > end) {
        rc = BadLength;
        goto bail;
    }

    CompositeGlyphs(stuff->op,
                    pSrc,
                    pDst,
                    pFormat,
                    stuff->xSrc, stuff->ySrc, nlist, listsBase, glyphsBase);
    rc = Success;

 bail:
    if (glyphsBase != glyphsLocal)
        free(glyphsBase);
    if (listsBase != listsLocal)
        free(listsBase);
    return rc;
}

static int
ProcRenderFillRectangles(ClientPtr client)
{
    PicturePtr pDst;
    int things;

    REQUEST(xRenderFillRectanglesReq);

    REQUEST_AT_LEAST_SIZE(xRenderFillRectanglesReq);
    if (!PictOpValid(stuff->op)) {
        client->errorValue = stuff->op;
        return BadValue;
    }
    VERIFY_PICTURE(pDst, stuff->dst, client, DixWriteAccess);
    if (!pDst->pDrawable)
        return BadDrawable;

    things = (client->req_len << 2) - sizeof(xRenderFillRectanglesReq);
    if (things & 4)
        return BadLength;
    things >>= 3;

    CompositeRects(stuff->op,
                   pDst, &stuff->color, things, (xRectangle *) &stuff[1]);

    return Success;
}

static void
RenderSetBit(unsigned char *line, int x, int bit)
{
    unsigned char mask;

    if (screenInfo.bitmapBitOrder == LSBFirst)
        mask = (1 << (x & 7));
    else
        mask = (0x80 >> (x & 7));
    /* XXX assumes byte order is host byte order */
    line += (x >> 3);
    if (bit)
        *line |= mask;
    else
        *line &= ~mask;
}

#define DITHER_DIM 2

static CARD32 orderedDither[DITHER_DIM][DITHER_DIM] = {
    {1, 3,},
    {4, 2,},
};

#define DITHER_SIZE  ((sizeof orderedDither / sizeof orderedDither[0][0]) + 1)

static int
ProcRenderCreateCursor(ClientPtr client)
{
    REQUEST(xRenderCreateCursorReq);
    PicturePtr pSrc;
    ScreenPtr pScreen;
    unsigned short width, height;
    CARD32 *argbbits, *argb;
    unsigned char *srcbits, *srcline;
    unsigned char *mskbits, *mskline;
    int stride;
    int x, y;
    int nbytes_mono;
    CursorMetricRec cm;
    CursorPtr pCursor;
    CARD32 twocolor[3];
    int rc, ncolor;

    REQUEST_SIZE_MATCH(xRenderCreateCursorReq);
    LEGAL_NEW_RESOURCE(stuff->cid, client);

    VERIFY_PICTURE(pSrc, stuff->src, client, DixReadAccess);
    if (!pSrc->pDrawable)
        return BadDrawable;
    pScreen = pSrc->pDrawable->pScreen;
    width = pSrc->pDrawable->width;
    height = pSrc->pDrawable->height;
    if (height && width > UINT32_MAX / (height * sizeof(CARD32)))
        return BadAlloc;
    if (stuff->x > width || stuff->y > height)
        return BadMatch;
    argbbits = malloc(width * height * sizeof(CARD32));
    if (!argbbits)
        return BadAlloc;

    stride = BitmapBytePad(width);
    nbytes_mono = stride * height;
    srcbits = calloc(1, nbytes_mono);
    if (!srcbits) {
        free(argbbits);
        return BadAlloc;
    }
    mskbits = calloc(1, nbytes_mono);
    if (!mskbits) {
        free(argbbits);
        free(srcbits);
        return BadAlloc;
    }

    if (pSrc->format == PICT_a8r8g8b8) {
        (*pScreen->GetImage) (pSrc->pDrawable,
                              0, 0, width, height, ZPixmap,
                              0xffffffff, (void *) argbbits);
    }
    else {
        PixmapPtr pPixmap;
        PicturePtr pPicture;
        PictFormatPtr pFormat;
        int error;

        pFormat = PictureMatchFormat(pScreen, 32, PICT_a8r8g8b8);
        if (!pFormat) {
            free(argbbits);
            free(srcbits);
            free(mskbits);
            return BadImplementation;
        }
        pPixmap = (*pScreen->CreatePixmap) (pScreen, width, height, 32,
                                            CREATE_PIXMAP_USAGE_SCRATCH);
        if (!pPixmap) {
            free(argbbits);
            free(srcbits);
            free(mskbits);
            return BadAlloc;
        }
        pPicture = CreatePicture(0, &pPixmap->drawable, pFormat, 0, 0,
                                 client, &error);
        if (!pPicture) {
            free(argbbits);
            free(srcbits);
            free(mskbits);
            return error;
        }
        (*pScreen->DestroyPixmap) (pPixmap);
        CompositePicture(PictOpSrc,
                         pSrc, 0, pPicture, 0, 0, 0, 0, 0, 0, width, height);
        (*pScreen->GetImage) (pPicture->pDrawable,
                              0, 0, width, height, ZPixmap,
                              0xffffffff, (void *) argbbits);
        FreePicture(pPicture, 0);
    }
    /*
     * Check whether the cursor can be directly supported by
     * the core cursor code
     */
    ncolor = 0;
    argb = argbbits;
    for (y = 0; ncolor <= 2 && y < height; y++) {
        for (x = 0; ncolor <= 2 && x < width; x++) {
            CARD32 p = *argb++;
            CARD32 a = (p >> 24);

            if (a == 0)         /* transparent */
                continue;
            if (a == 0xff) {    /* opaque */
                int n;

                for (n = 0; n < ncolor; n++)
                    if (p == twocolor[n])
                        break;
                if (n == ncolor)
                    twocolor[ncolor++] = p;
            }
            else
                ncolor = 3;
        }
    }

    /*
     * Convert argb image to two plane cursor
     */
    srcline = srcbits;
    mskline = mskbits;
    argb = argbbits;
    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            CARD32 p = *argb++;

            if (ncolor <= 2) {
                CARD32 a = ((p >> 24));

                RenderSetBit(mskline, x, a != 0);
                RenderSetBit(srcline, x, a != 0 && p == twocolor[0]);
            }
            else {
                CARD32 a = ((p >> 24) * DITHER_SIZE + 127) / 255;
                CARD32 i = ((CvtR8G8B8toY15(p) >> 7) * DITHER_SIZE + 127) / 255;
                CARD32 d =
                    orderedDither[y & (DITHER_DIM - 1)][x & (DITHER_DIM - 1)];
                /* Set mask from dithered alpha value */
                RenderSetBit(mskline, x, a > d);
                /* Set src from dithered intensity value */
                RenderSetBit(srcline, x, a > d && i <= d);
            }
        }
        srcline += stride;
        mskline += stride;
    }
    /*
     * Dither to white and black if the cursor has more than two colors
     */
    if (ncolor > 2) {
        twocolor[0] = 0xff000000;
        twocolor[1] = 0xffffffff;
    }
    else {
        free(argbbits);
        argbbits = 0;
    }

#define GetByte(p,s)	(((p) >> (s)) & 0xff)
#define GetColor(p,s)	(GetByte(p,s) | (GetByte(p,s) << 8))

    cm.width = width;
    cm.height = height;
    cm.xhot = stuff->x;
    cm.yhot = stuff->y;
    rc = AllocARGBCursor(srcbits, mskbits, argbbits, &cm,
                         GetColor(twocolor[0], 16),
                         GetColor(twocolor[0], 8),
                         GetColor(twocolor[0], 0),
                         GetColor(twocolor[1], 16),
                         GetColor(twocolor[1], 8),
                         GetColor(twocolor[1], 0),
                         &pCursor, client, stuff->cid);
    if (rc != Success)
        goto bail;
    if (!AddResource(stuff->cid, RT_CURSOR, (void *) pCursor)) {
        rc = BadAlloc;
        goto bail;
    }

    return Success;
 bail:
    free(srcbits);
    free(mskbits);
    return rc;
}

static int
ProcRenderSetPictureTransform(ClientPtr client)
{
    REQUEST(xRenderSetPictureTransformReq);
    PicturePtr pPicture;

    REQUEST_SIZE_MATCH(xRenderSetPictureTransformReq);
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixSetAttrAccess);
    return SetPictureTransform(pPicture, (PictTransform *) &stuff->transform);
}

static int
ProcRenderQueryFilters(ClientPtr client)
{
    REQUEST(xRenderQueryFiltersReq);
    DrawablePtr pDrawable;
    xRenderQueryFiltersReply *reply;
    int nbytesName;
    int nnames;
    ScreenPtr pScreen;
    PictureScreenPtr ps;
    int i, j, len, total_bytes, rc;
    INT16 *aliases;
    char *names;

    REQUEST_SIZE_MATCH(xRenderQueryFiltersReq);
    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
                           DixGetAttrAccess);
    if (rc != Success)
        return rc;

    pScreen = pDrawable->pScreen;
    nbytesName = 0;
    nnames = 0;
    ps = GetPictureScreenIfSet(pScreen);
    if (ps) {
        for (i = 0; i < ps->nfilters; i++)
            nbytesName += 1 + strlen(ps->filters[i].name);
        for (i = 0; i < ps->nfilterAliases; i++)
            nbytesName += 1 + strlen(ps->filterAliases[i].alias);
        nnames = ps->nfilters + ps->nfilterAliases;
    }
    len = ((nnames + 1) >> 1) + bytes_to_int32(nbytesName);
    total_bytes = sizeof(xRenderQueryFiltersReply) + (len << 2);
    reply = (xRenderQueryFiltersReply *) calloc(1, total_bytes);
    if (!reply)
        return BadAlloc;
    aliases = (INT16 *) (reply + 1);
    names = (char *) (aliases + ((nnames + 1) & ~1));

    reply->type = X_Reply;
    reply->sequenceNumber = client->sequence;
    reply->length = len;
    reply->numAliases = nnames;
    reply->numFilters = nnames;
    if (ps) {

        /* fill in alias values */
        for (i = 0; i < ps->nfilters; i++)
            aliases[i] = FilterAliasNone;
        for (i = 0; i < ps->nfilterAliases; i++) {
            for (j = 0; j < ps->nfilters; j++)
                if (ps->filterAliases[i].filter_id == ps->filters[j].id)
                    break;
            if (j == ps->nfilters) {
                for (j = 0; j < ps->nfilterAliases; j++)
                    if (ps->filterAliases[i].filter_id ==
                        ps->filterAliases[j].alias_id) {
                        break;
                    }
                if (j == ps->nfilterAliases)
                    j = FilterAliasNone;
                else
                    j = j + ps->nfilters;
            }
            aliases[i + ps->nfilters] = j;
        }

        /* fill in filter names */
        for (i = 0; i < ps->nfilters; i++) {
            j = strlen(ps->filters[i].name);
            *names++ = j;
            memcpy(names, ps->filters[i].name, j);
            names += j;
        }

        /* fill in filter alias names */
        for (i = 0; i < ps->nfilterAliases; i++) {
            j = strlen(ps->filterAliases[i].alias);
            *names++ = j;
            memcpy(names, ps->filterAliases[i].alias, j);
            names += j;
        }
    }

    if (client->swapped) {
        for (i = 0; i < reply->numAliases; i++) {
            swaps(&aliases[i]);
        }
        swaps(&reply->sequenceNumber);
        swapl(&reply->length);
        swapl(&reply->numAliases);
        swapl(&reply->numFilters);
    }
    WriteToClient(client, total_bytes, reply);
    free(reply);

    return Success;
}

static int
ProcRenderSetPictureFilter(ClientPtr client)
{
    REQUEST(xRenderSetPictureFilterReq);
    PicturePtr pPicture;
    int result;
    xFixed *params;
    int nparams;
    char *name;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureFilterReq);
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixSetAttrAccess);
    name = (char *) (stuff + 1);
    params = (xFixed *) (name + pad_to_int32(stuff->nbytes));
    nparams = ((xFixed *) stuff + client->req_len) - params;
    result = SetPictureFilter(pPicture, name, stuff->nbytes, params, nparams);
    return result;
}

static int
ProcRenderCreateAnimCursor(ClientPtr client)
{
    REQUEST(xRenderCreateAnimCursorReq);
    CursorPtr *cursors;
    CARD32 *deltas;
    CursorPtr pCursor;
    int ncursor;
    xAnimCursorElt *elt;
    int i;
    int ret;

    REQUEST_AT_LEAST_SIZE(xRenderCreateAnimCursorReq);
    LEGAL_NEW_RESOURCE(stuff->cid, client);
    if (client->req_len & 1)
        return BadLength;
    ncursor =
        (client->req_len -
         (bytes_to_int32(sizeof(xRenderCreateAnimCursorReq)))) >> 1;
    cursors = xallocarray(ncursor, sizeof(CursorPtr) + sizeof(CARD32));
    if (!cursors)
        return BadAlloc;
    deltas = (CARD32 *) (cursors + ncursor);
    elt = (xAnimCursorElt *) (stuff + 1);
    for (i = 0; i < ncursor; i++) {
        ret = dixLookupResourceByType((void **) (cursors + i), elt->cursor,
                                      RT_CURSOR, client, DixReadAccess);
        if (ret != Success) {
            free(cursors);
            return ret;
        }
        deltas[i] = elt->delay;
        elt++;
    }
    ret = AnimCursorCreate(cursors, deltas, ncursor, &pCursor, client,
                           stuff->cid);
    free(cursors);
    if (ret != Success)
        return ret;

    if (AddResource(stuff->cid, RT_CURSOR, (void *) pCursor))
        return Success;
    return BadAlloc;
}

static int
ProcRenderAddTraps(ClientPtr client)
{
    int ntraps;
    PicturePtr pPicture;

    REQUEST(xRenderAddTrapsReq);

    REQUEST_AT_LEAST_SIZE(xRenderAddTrapsReq);
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixWriteAccess);
    if (!pPicture->pDrawable)
        return BadDrawable;
    ntraps = (client->req_len << 2) - sizeof(xRenderAddTrapsReq);
    if (ntraps % sizeof(xTrap))
        return BadLength;
    ntraps /= sizeof(xTrap);
    if (ntraps)
        AddTraps(pPicture,
                 stuff->xOff, stuff->yOff, ntraps, (xTrap *) &stuff[1]);
    return Success;
}

static int
ProcRenderCreateSolidFill(ClientPtr client)
{
    PicturePtr pPicture;
    int error = 0;

    REQUEST(xRenderCreateSolidFillReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreateSolidFillReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);

    pPicture = CreateSolidPicture(stuff->pid, &stuff->color, &error);
    if (!pPicture)
        return error;
    /* security creation/labeling check */
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
                     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
        return error;
    if (!AddResource(stuff->pid, PictureType, (void *) pPicture))
        return BadAlloc;
    return Success;
}

static int
ProcRenderCreateLinearGradient(ClientPtr client)
{
    PicturePtr pPicture;
    int len;
    int error = 0;
    xFixed *stops;
    xRenderColor *colors;

    REQUEST(xRenderCreateLinearGradientReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreateLinearGradientReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);

    len = (client->req_len << 2) - sizeof(xRenderCreateLinearGradientReq);
    if (stuff->nStops > UINT32_MAX / (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    if (len != stuff->nStops * (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    stops = (xFixed *) (stuff + 1);
    colors = (xRenderColor *) (stops + stuff->nStops);

    pPicture = CreateLinearGradientPicture(stuff->pid, &stuff->p1, &stuff->p2,
                                           stuff->nStops, stops, colors,
                                           &error);
    if (!pPicture)
        return error;
    /* security creation/labeling check */
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
                     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
        return error;
    if (!AddResource(stuff->pid, PictureType, (void *) pPicture))
        return BadAlloc;
    return Success;
}

static int
ProcRenderCreateRadialGradient(ClientPtr client)
{
    PicturePtr pPicture;
    int len;
    int error = 0;
    xFixed *stops;
    xRenderColor *colors;

    REQUEST(xRenderCreateRadialGradientReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreateRadialGradientReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (len != stuff->nStops * (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    stops = (xFixed *) (stuff + 1);
    colors = (xRenderColor *) (stops + stuff->nStops);

    pPicture =
        CreateRadialGradientPicture(stuff->pid, &stuff->inner, &stuff->outer,
                                    stuff->inner_radius, stuff->outer_radius,
                                    stuff->nStops, stops, colors, &error);
    if (!pPicture)
        return error;
    /* security creation/labeling check */
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
                     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
        return error;
    if (!AddResource(stuff->pid, PictureType, (void *) pPicture))
        return BadAlloc;
    return Success;
}

static int
ProcRenderCreateConicalGradient(ClientPtr client)
{
    PicturePtr pPicture;
    int len;
    int error = 0;
    xFixed *stops;
    xRenderColor *colors;

    REQUEST(xRenderCreateConicalGradientReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreateConicalGradientReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);

    len = (client->req_len << 2) - sizeof(xRenderCreateConicalGradientReq);
    if (len != stuff->nStops * (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    stops = (xFixed *) (stuff + 1);
    colors = (xRenderColor *) (stops + stuff->nStops);

    pPicture =
        CreateConicalGradientPicture(stuff->pid, &stuff->center, stuff->angle,
                                     stuff->nStops, stops, colors, &error);
    if (!pPicture)
        return error;
    /* security creation/labeling check */
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
                     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
        return error;
    if (!AddResource(stuff->pid, PictureType, (void *) pPicture))
        return BadAlloc;
    return Success;
}

static int
ProcRenderDispatch(ClientPtr client)
{
    REQUEST(xReq);

    if (stuff->data < RenderNumberRequests)
        return (*ProcRenderVector[stuff->data]) (client);
    else
        return BadRequest;
}

static int
SProcRenderQueryVersion(ClientPtr client)
{
    REQUEST(xRenderQueryVersionReq);
    REQUEST_SIZE_MATCH(xRenderQueryVersionReq);
    swaps(&stuff->length);
    swapl(&stuff->majorVersion);
    swapl(&stuff->minorVersion);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderQueryPictFormats(ClientPtr client)
{
    REQUEST(xRenderQueryPictFormatsReq);
    REQUEST_SIZE_MATCH(xRenderQueryPictFormatsReq);
    swaps(&stuff->length);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderQueryPictIndexValues(ClientPtr client)
{
    REQUEST(xRenderQueryPictIndexValuesReq);
    REQUEST_AT_LEAST_SIZE(xRenderQueryPictIndexValuesReq);
    swaps(&stuff->length);
    swapl(&stuff->format);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderQueryDithers(ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderCreatePicture(ClientPtr client)
{
    REQUEST(xRenderCreatePictureReq);
    REQUEST_AT_LEAST_SIZE(xRenderCreatePictureReq);
    swaps(&stuff->length);
    swapl(&stuff->pid);
    swapl(&stuff->drawable);
    swapl(&stuff->format);
    swapl(&stuff->mask);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderChangePicture(ClientPtr client)
{
    REQUEST(xRenderChangePictureReq);
    REQUEST_AT_LEAST_SIZE(xRenderChangePictureReq);
    swaps(&stuff->length);
    swapl(&stuff->picture);
    swapl(&stuff->mask);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);
    swaps(&stuff->length);
    swapl(&stuff->picture);
    swaps(&stuff->xOrigin);
    swaps(&stuff->yOrigin);
    SwapRestS(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderFreePicture(ClientPtr client)
{
    REQUEST(xRenderFreePictureReq);
    REQUEST_SIZE_MATCH(xRenderFreePictureReq);
    swaps(&stuff->length);
    swapl(&stuff->picture);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderComposite(ClientPtr client)
{
    REQUEST(xRenderCompositeReq);
    REQUEST_SIZE_MATCH(xRenderCompositeReq);
    swaps(&stuff->length);
    swapl(&stuff->src);
    swapl(&stuff->mask);
    swapl(&stuff->dst);
    swaps(&stuff->xSrc);
    swaps(&stuff->ySrc);
    swaps(&stuff->xMask);
    swaps(&stuff->yMask);
    swaps(&stuff->xDst);
    swaps(&stuff->yDst);
    swaps(&stuff->width);
    swaps(&stuff->height);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderScale(ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderTrapezoids(ClientPtr client)
{
    REQUEST(xRenderTrapezoidsReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrapezoidsReq);
    swaps(&stuff->length);
    swapl(&stuff->src);
    swapl(&stuff->dst);
    swapl(&stuff->maskFormat);
    swaps(&stuff->xSrc);
    swaps(&stuff->ySrc);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderTriangles(ClientPtr client)
{
    REQUEST(xRenderTrianglesReq);

    REQUEST_AT_LEAST_SIZE(xRenderTrianglesReq);
    swaps(&stuff->length);
    swapl(&stuff->src);
    swapl(&stuff->dst);
    swapl(&stuff->maskFormat);
    swaps(&stuff->xSrc);
    swaps(&stuff->ySrc);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderTriStrip(ClientPtr client)
{
    REQUEST(xRenderTriStripReq);

    REQUEST_AT_LEAST_SIZE(xRenderTriStripReq);
    swaps(&stuff->length);
    swapl(&stuff->src);
    swapl(&stuff->dst);
    swapl(&stuff->maskFormat);
    swaps(&stuff->xSrc);
    swaps(&stuff->ySrc);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderTriFan(ClientPtr client)
{
    REQUEST(xRenderTriFanReq);

    REQUEST_AT_LEAST_SIZE(xRenderTriFanReq);
    swaps(&stuff->length);
    swapl(&stuff->src);
    swapl(&stuff->dst);
    swapl(&stuff->maskFormat);
    swaps(&stuff->xSrc);
    swaps(&stuff->ySrc);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderColorTrapezoids(ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderColorTriangles(ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderTransform(ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderCreateGlyphSet(ClientPtr client)
{
    REQUEST(xRenderCreateGlyphSetReq);
    REQUEST_SIZE_MATCH(xRenderCreateGlyphSetReq);
    swaps(&stuff->length);
    swapl(&stuff->gsid);
    swapl(&stuff->format);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderReferenceGlyphSet(ClientPtr client)
{
    REQUEST(xRenderReferenceGlyphSetReq);
    REQUEST_SIZE_MATCH(xRenderReferenceGlyphSetReq);
    swaps(&stuff->length);
    swapl(&stuff->gsid);
    swapl(&stuff->existing);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderFreeGlyphSet(ClientPtr client)
{
    REQUEST(xRenderFreeGlyphSetReq);
    REQUEST_SIZE_MATCH(xRenderFreeGlyphSetReq);
    swaps(&stuff->length);
    swapl(&stuff->glyphset);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderAddGlyphs(ClientPtr client)
{
    register int i;
    CARD32 *gids;
    void *end;
    xGlyphInfo *gi;

    REQUEST(xRenderAddGlyphsReq);
    REQUEST_AT_LEAST_SIZE(xRenderAddGlyphsReq);
    swaps(&stuff->length);
    swapl(&stuff->glyphset);
    swapl(&stuff->nglyphs);
    if (stuff->nglyphs & 0xe0000000)
        return BadLength;
    end = (CARD8 *) stuff + (client->req_len << 2);
    gids = (CARD32 *) (stuff + 1);
    gi = (xGlyphInfo *) (gids + stuff->nglyphs);
    if ((char *) end - (char *) (gids + stuff->nglyphs) < 0)
        return BadLength;
    if ((char *) end - (char *) (gi + stuff->nglyphs) < 0)
        return BadLength;
    for (i = 0; i < stuff->nglyphs; i++) {
        swapl(&gids[i]);
        swaps(&gi[i].width);
        swaps(&gi[i].height);
        swaps(&gi[i].x);
        swaps(&gi[i].y);
        swaps(&gi[i].xOff);
        swaps(&gi[i].yOff);
    }
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderAddGlyphsFromPicture(ClientPtr client)
{
    return BadImplementation;
}

static int
SProcRenderFreeGlyphs(ClientPtr client)
{
    REQUEST(xRenderFreeGlyphsReq);
    REQUEST_AT_LEAST_SIZE(xRenderFreeGlyphsReq);
    swaps(&stuff->length);
    swapl(&stuff->glyphset);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderCompositeGlyphs(ClientPtr client)
{
    xGlyphElt *elt;
    CARD8 *buffer;
    CARD8 *end;
    int space;
    int i;
    int size;

    REQUEST(xRenderCompositeGlyphsReq);
    REQUEST_AT_LEAST_SIZE(xRenderCompositeGlyphsReq);

    switch (stuff->renderReqType) {
    default:
        size = 1;
        break;
    case X_RenderCompositeGlyphs16:
        size = 2;
        break;
    case X_RenderCompositeGlyphs32:
        size = 4;
        break;
    }

    swaps(&stuff->length);
    swapl(&stuff->src);
    swapl(&stuff->dst);
    swapl(&stuff->maskFormat);
    swapl(&stuff->glyphset);
    swaps(&stuff->xSrc);
    swaps(&stuff->ySrc);
    buffer = (CARD8 *) (stuff + 1);
    end = (CARD8 *) stuff + (client->req_len << 2);
    while (buffer + sizeof(xGlyphElt) < end) {
        elt = (xGlyphElt *) buffer;
        buffer += sizeof(xGlyphElt);

        swaps(&elt->deltax);
        swaps(&elt->deltay);

        i = elt->len;
        if (i == 0xff) {
            swapl((int *) buffer);
            buffer += 4;
        }
        else {
            space = size * i;
            switch (size) {
            case 1:
                buffer += i;
                break;
            case 2:
                while (i--) {
                    swaps((short *) buffer);
                    buffer += 2;
                }
                break;
            case 4:
                while (i--) {
                    swapl((int *) buffer);
                    buffer += 4;
                }
                break;
            }
            if (space & 3)
                buffer += 4 - (space & 3);
        }
    }
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderFillRectangles(ClientPtr client)
{
    REQUEST(xRenderFillRectanglesReq);

    REQUEST_AT_LEAST_SIZE(xRenderFillRectanglesReq);
    swaps(&stuff->length);
    swapl(&stuff->dst);
    swaps(&stuff->color.red);
    swaps(&stuff->color.green);
    swaps(&stuff->color.blue);
    swaps(&stuff->color.alpha);
    SwapRestS(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderCreateCursor(ClientPtr client)
{
    REQUEST(xRenderCreateCursorReq);
    REQUEST_SIZE_MATCH(xRenderCreateCursorReq);

    swaps(&stuff->length);
    swapl(&stuff->cid);
    swapl(&stuff->src);
    swaps(&stuff->x);
    swaps(&stuff->y);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderSetPictureTransform(ClientPtr client)
{
    REQUEST(xRenderSetPictureTransformReq);
    REQUEST_SIZE_MATCH(xRenderSetPictureTransformReq);

    swaps(&stuff->length);
    swapl(&stuff->picture);
    swapl(&stuff->transform.matrix11);
    swapl(&stuff->transform.matrix12);
    swapl(&stuff->transform.matrix13);
    swapl(&stuff->transform.matrix21);
    swapl(&stuff->transform.matrix22);
    swapl(&stuff->transform.matrix23);
    swapl(&stuff->transform.matrix31);
    swapl(&stuff->transform.matrix32);
    swapl(&stuff->transform.matrix33);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderQueryFilters(ClientPtr client)
{
    REQUEST(xRenderQueryFiltersReq);
    REQUEST_SIZE_MATCH(xRenderQueryFiltersReq);

    swaps(&stuff->length);
    swapl(&stuff->drawable);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderSetPictureFilter(ClientPtr client)
{
    REQUEST(xRenderSetPictureFilterReq);
    REQUEST_AT_LEAST_SIZE(xRenderSetPictureFilterReq);

    swaps(&stuff->length);
    swapl(&stuff->picture);
    swaps(&stuff->nbytes);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderCreateAnimCursor(ClientPtr client)
{
    REQUEST(xRenderCreateAnimCursorReq);
    REQUEST_AT_LEAST_SIZE(xRenderCreateAnimCursorReq);

    swaps(&stuff->length);
    swapl(&stuff->cid);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderAddTraps(ClientPtr client)
{
    REQUEST(xRenderAddTrapsReq);
    REQUEST_AT_LEAST_SIZE(xRenderAddTrapsReq);

    swaps(&stuff->length);
    swapl(&stuff->picture);
    swaps(&stuff->xOff);
    swaps(&stuff->yOff);
    SwapRestL(stuff);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderCreateSolidFill(ClientPtr client)
{
    REQUEST(xRenderCreateSolidFillReq);
    REQUEST_AT_LEAST_SIZE(xRenderCreateSolidFillReq);

    swaps(&stuff->length);
    swapl(&stuff->pid);
    swaps(&stuff->color.alpha);
    swaps(&stuff->color.red);
    swaps(&stuff->color.green);
    swaps(&stuff->color.blue);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static void
swapStops(void *stuff, int num)
{
    int i;
    CARD32 *stops;
    CARD16 *colors;

    stops = (CARD32 *) (stuff);
    for (i = 0; i < num; ++i) {
        swapl(stops);
        ++stops;
    }
    colors = (CARD16 *) (stops);
    for (i = 0; i < 4 * num; ++i) {
        swaps(colors);
        ++colors;
    }
}

static int
SProcRenderCreateLinearGradient(ClientPtr client)
{
    int len;

    REQUEST(xRenderCreateLinearGradientReq);
    REQUEST_AT_LEAST_SIZE(xRenderCreateLinearGradientReq);

    swaps(&stuff->length);
    swapl(&stuff->pid);
    swapl(&stuff->p1.x);
    swapl(&stuff->p1.y);
    swapl(&stuff->p2.x);
    swapl(&stuff->p2.y);
    swapl(&stuff->nStops);

    len = (client->req_len << 2) - sizeof(xRenderCreateLinearGradientReq);
    if (stuff->nStops > UINT32_MAX / (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    if (len != stuff->nStops * (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff + 1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderCreateRadialGradient(ClientPtr client)
{
    int len;

    REQUEST(xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE(xRenderCreateRadialGradientReq);

    swaps(&stuff->length);
    swapl(&stuff->pid);
    swapl(&stuff->inner.x);
    swapl(&stuff->inner.y);
    swapl(&stuff->outer.x);
    swapl(&stuff->outer.y);
    swapl(&stuff->inner_radius);
    swapl(&stuff->outer_radius);
    swapl(&stuff->nStops);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX / (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    if (len != stuff->nStops * (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff + 1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderCreateConicalGradient(ClientPtr client)
{
    int len;

    REQUEST(xRenderCreateConicalGradientReq);
    REQUEST_AT_LEAST_SIZE(xRenderCreateConicalGradientReq);

    swaps(&stuff->length);
    swapl(&stuff->pid);
    swapl(&stuff->center.x);
    swapl(&stuff->center.y);
    swapl(&stuff->angle);
    swapl(&stuff->nStops);

    len = (client->req_len << 2) - sizeof(xRenderCreateConicalGradientReq);
    if (stuff->nStops > UINT32_MAX / (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    if (len != stuff->nStops * (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff + 1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}

static int
SProcRenderDispatch(ClientPtr client)
{
    REQUEST(xReq);

    if (stuff->data < RenderNumberRequests)
        return (*SProcRenderVector[stuff->data]) (client);
    else
        return BadRequest;
}

#ifdef PANORAMIX
#define VERIFY_XIN_PICTURE(pPicture, pid, client, mode) {\
    int rc = dixLookupResourceByType((void **)&(pPicture), pid,\
                                     XRT_PICTURE, client, mode);\
    if (rc != Success)\
	return rc;\
}

#define VERIFY_XIN_ALPHA(pPicture, pid, client, mode) {\
    if (pid == None) \
	pPicture = 0; \
    else { \
	VERIFY_XIN_PICTURE(pPicture, pid, client, mode); \
    } \
} \

int (*PanoramiXSaveRenderVector[RenderNumberRequests]) (ClientPtr);

static int
PanoramiXRenderCreatePicture(ClientPtr client)
{
    REQUEST(xRenderCreatePictureReq);
    PanoramiXRes *refDraw, *newPict;
    int result, j;

    REQUEST_AT_LEAST_SIZE(xRenderCreatePictureReq);
    result = dixLookupResourceByClass((void **) &refDraw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;
    if (!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
        return BadAlloc;
    newPict->type = XRT_PICTURE;
    panoramix_setup_ids(newPict, client, stuff->pid);

    if (refDraw->type == XRT_WINDOW &&
        stuff->drawable == screenInfo.screens[0]->root->drawable.id) {
        newPict->u.pict.root = TRUE;
    }
    else
        newPict->u.pict.root = FALSE;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->pid = newPict->info[j].id;
        stuff->drawable = refDraw->info[j].id;
        result = (*PanoramiXSaveRenderVector[X_RenderCreatePicture]) (client);
        if (result != Success)
            break;
    }

    if (result == Success)
        AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else
        free(newPict);

    return result;
}

static int
PanoramiXRenderChangePicture(ClientPtr client)
{
    PanoramiXRes *pict;
    int result = Success, j;

    REQUEST(xRenderChangePictureReq);

    REQUEST_AT_LEAST_SIZE(xRenderChangePictureReq);

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result = (*PanoramiXSaveRenderVector[X_RenderChangePicture]) (client);
        if (result != Success)
            break;
    }

    return result;
}

static int
PanoramiXRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int result = Success, j;
    PanoramiXRes *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])
            (client);
        if (result != Success)
            break;
    }

    return result;
}

static int
PanoramiXRenderSetPictureTransform(ClientPtr client)
{
    REQUEST(xRenderSetPictureTransformReq);
    int result = Success, j;
    PanoramiXRes *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureTransformReq);

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureTransform]) (client);
        if (result != Success)
            break;
    }

    return result;
}

static int
PanoramiXRenderSetPictureFilter(ClientPtr client)
{
    REQUEST(xRenderSetPictureFilterReq);
    int result = Success, j;
    PanoramiXRes *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureFilterReq);

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureFilter]) (client);
        if (result != Success)
            break;
    }

    return result;
}

static int
PanoramiXRenderFreePicture(ClientPtr client)
{
    PanoramiXRes *pict;
    int result = Success, j;

    REQUEST(xRenderFreePictureReq);

    REQUEST_SIZE_MATCH(xRenderFreePictureReq);

    client->errorValue = stuff->picture;

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixDestroyAccess);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result = (*PanoramiXSaveRenderVector[X_RenderFreePicture]) (client);
        if (result != Success)
            break;
    }

    /* Since ProcRenderFreePicture is using FreeResource, it will free
       our resource for us on the last pass through the loop above */

    return result;
}

static int
PanoramiXRenderComposite(ClientPtr client)
{
    PanoramiXRes *src, *msk, *dst;
    int result = Success, j;
    xRenderCompositeReq orig;

    REQUEST(xRenderCompositeReq);

    REQUEST_SIZE_MATCH(xRenderCompositeReq);

    VERIFY_XIN_PICTURE(src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_ALPHA(msk, stuff->mask, client, DixReadAccess);
    VERIFY_XIN_PICTURE(dst, stuff->dst, client, DixWriteAccess);

    orig = *stuff;

    FOR_NSCREENS_FORWARD(j) {
        stuff->src = src->info[j].id;
        if (src->u.pict.root) {
            stuff->xSrc = orig.xSrc - screenInfo.screens[j]->x;
            stuff->ySrc = orig.ySrc - screenInfo.screens[j]->y;
        }
        stuff->dst = dst->info[j].id;
        if (dst->u.pict.root) {
            stuff->xDst = orig.xDst - screenInfo.screens[j]->x;
            stuff->yDst = orig.yDst - screenInfo.screens[j]->y;
        }
        if (msk) {
            stuff->mask = msk->info[j].id;
            if (msk->u.pict.root) {
                stuff->xMask = orig.xMask - screenInfo.screens[j]->x;
                stuff->yMask = orig.yMask - screenInfo.screens[j]->y;
            }
        }
        result = (*PanoramiXSaveRenderVector[X_RenderComposite]) (client);
        if (result != Success)
            break;
    }

    return result;
}

static int
PanoramiXRenderCompositeGlyphs(ClientPtr client)
{
    PanoramiXRes *src, *dst;
    int result = Success, j;

    REQUEST(xRenderCompositeGlyphsReq);
    xGlyphElt origElt, *elt;
    INT16 xSrc, ySrc;

    REQUEST_AT_LEAST_SIZE(xRenderCompositeGlyphsReq);
    VERIFY_XIN_PICTURE(src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE(dst, stuff->dst, client, DixWriteAccess);

    if (client->req_len << 2 >= (sizeof(xRenderCompositeGlyphsReq) +
                                 sizeof(xGlyphElt))) {
        elt = (xGlyphElt *) (stuff + 1);
        origElt = *elt;
        xSrc = stuff->xSrc;
        ySrc = stuff->ySrc;
        FOR_NSCREENS_FORWARD(j) {
            stuff->src = src->info[j].id;
            if (src->u.pict.root) {
                stuff->xSrc = xSrc - screenInfo.screens[j]->x;
                stuff->ySrc = ySrc - screenInfo.screens[j]->y;
            }
            stuff->dst = dst->info[j].id;
            if (dst->u.pict.root) {
                elt->deltax = origElt.deltax - screenInfo.screens[j]->x;
                elt->deltay = origElt.deltay - screenInfo.screens[j]->y;
            }
            result =
                (*PanoramiXSaveRenderVector[stuff->renderReqType]) (client);
            if (result != Success)
                break;
        }
    }

    return result;
}

static int
PanoramiXRenderFillRectangles(ClientPtr client)
{
    PanoramiXRes *dst;
    int result = Success, j;

    REQUEST(xRenderFillRectanglesReq);
    char *extra;
    int extra_len;

    REQUEST_AT_LEAST_SIZE(xRenderFillRectanglesReq);
    VERIFY_XIN_PICTURE(dst, stuff->dst, client, DixWriteAccess);
    extra_len = (client->req_len << 2) - sizeof(xRenderFillRectanglesReq);
    if (extra_len && (extra = (char *) malloc(extra_len))) {
        memcpy(extra, stuff + 1, extra_len);
        FOR_NSCREENS_FORWARD(j) {
            if (j)
                memcpy(stuff + 1, extra, extra_len);
            if (dst->u.pict.root) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

                if (x_off || y_off) {
                    xRectangle *rects = (xRectangle *) (stuff + 1);
                    int i = extra_len / sizeof(xRectangle);

                    while (i--) {
                        rects->x -= x_off;
                        rects->y -= y_off;
                        rects++;
                    }
                }
            }
            stuff->dst = dst->info[j].id;
            result =
                (*PanoramiXSaveRenderVector[X_RenderFillRectangles]) (client);
            if (result != Success)
                break;
        }
        free(extra);
    }

    return result;
}

static int
PanoramiXRenderTrapezoids(ClientPtr client)
{
    PanoramiXRes *src, *dst;
    int result = Success, j;

    REQUEST(xRenderTrapezoidsReq);
    char *extra;
    int extra_len;

    REQUEST_AT_LEAST_SIZE(xRenderTrapezoidsReq);

    VERIFY_XIN_PICTURE(src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE(dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof(xRenderTrapezoidsReq);

    if (extra_len && (extra = (char *) malloc(extra_len))) {
        memcpy(extra, stuff + 1, extra_len);

        FOR_NSCREENS_FORWARD(j) {
            if (j)
                memcpy(stuff + 1, extra, extra_len);
            if (dst->u.pict.root) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

                if (x_off || y_off) {
                    xTrapezoid *trap = (xTrapezoid *) (stuff + 1);
                    int i = extra_len / sizeof(xTrapezoid);

                    while (i--) {
                        trap->top -= y_off;
                        trap->bottom -= y_off;
                        trap->left.p1.x -= x_off;
                        trap->left.p1.y -= y_off;
                        trap->left.p2.x -= x_off;
                        trap->left.p2.y -= y_off;
                        trap->right.p1.x -= x_off;
                        trap->right.p1.y -= y_off;
                        trap->right.p2.x -= x_off;
                        trap->right.p2.y -= y_off;
                        trap++;
                    }
                }
            }

            stuff->src = src->info[j].id;
            stuff->dst = dst->info[j].id;
            result = (*PanoramiXSaveRenderVector[X_RenderTrapezoids]) (client);

            if (result != Success)
                break;
        }

        free(extra);
    }

    return result;
}

static int
PanoramiXRenderTriangles(ClientPtr client)
{
    PanoramiXRes *src, *dst;
    int result = Success, j;

    REQUEST(xRenderTrianglesReq);
    char *extra;
    int extra_len;

    REQUEST_AT_LEAST_SIZE(xRenderTrianglesReq);

    VERIFY_XIN_PICTURE(src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE(dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof(xRenderTrianglesReq);

    if (extra_len && (extra = (char *) malloc(extra_len))) {
        memcpy(extra, stuff + 1, extra_len);

        FOR_NSCREENS_FORWARD(j) {
            if (j)
                memcpy(stuff + 1, extra, extra_len);
            if (dst->u.pict.root) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

                if (x_off || y_off) {
                    xTriangle *tri = (xTriangle *) (stuff + 1);
                    int i = extra_len / sizeof(xTriangle);

                    while (i--) {
                        tri->p1.x -= x_off;
                        tri->p1.y -= y_off;
                        tri->p2.x -= x_off;
                        tri->p2.y -= y_off;
                        tri->p3.x -= x_off;
                        tri->p3.y -= y_off;
                        tri++;
                    }
                }
            }

            stuff->src = src->info[j].id;
            stuff->dst = dst->info[j].id;
            result = (*PanoramiXSaveRenderVector[X_RenderTriangles]) (client);

            if (result != Success)
                break;
        }

        free(extra);
    }

    return result;
}

static int
PanoramiXRenderTriStrip(ClientPtr client)
{
    PanoramiXRes *src, *dst;
    int result = Success, j;

    REQUEST(xRenderTriStripReq);
    char *extra;
    int extra_len;

    REQUEST_AT_LEAST_SIZE(xRenderTriStripReq);

    VERIFY_XIN_PICTURE(src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE(dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof(xRenderTriStripReq);

    if (extra_len && (extra = (char *) malloc(extra_len))) {
        memcpy(extra, stuff + 1, extra_len);

        FOR_NSCREENS_FORWARD(j) {
            if (j)
                memcpy(stuff + 1, extra, extra_len);
            if (dst->u.pict.root) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

                if (x_off || y_off) {
                    xPointFixed *fixed = (xPointFixed *) (stuff + 1);
                    int i = extra_len / sizeof(xPointFixed);

                    while (i--) {
                        fixed->x -= x_off;
                        fixed->y -= y_off;
                        fixed++;
                    }
                }
            }

            stuff->src = src->info[j].id;
            stuff->dst = dst->info[j].id;
            result = (*PanoramiXSaveRenderVector[X_RenderTriStrip]) (client);

            if (result != Success)
                break;
        }

        free(extra);
    }

    return result;
}

static int
PanoramiXRenderTriFan(ClientPtr client)
{
    PanoramiXRes *src, *dst;
    int result = Success, j;

    REQUEST(xRenderTriFanReq);
    char *extra;
    int extra_len;

    REQUEST_AT_LEAST_SIZE(xRenderTriFanReq);

    VERIFY_XIN_PICTURE(src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE(dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof(xRenderTriFanReq);

    if (extra_len && (extra = (char *) malloc(extra_len))) {
        memcpy(extra, stuff + 1, extra_len);

        FOR_NSCREENS_FORWARD(j) {
            if (j)
                memcpy(stuff + 1, extra, extra_len);
            if (dst->u.pict.root) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

                if (x_off || y_off) {
                    xPointFixed *fixed = (xPointFixed *) (stuff + 1);
                    int i = extra_len / sizeof(xPointFixed);

                    while (i--) {
                        fixed->x -= x_off;
                        fixed->y -= y_off;
                        fixed++;
                    }
                }
            }

            stuff->src = src->info[j].id;
            stuff->dst = dst->info[j].id;
            result = (*PanoramiXSaveRenderVector[X_RenderTriFan]) (client);

            if (result != Success)
                break;
        }

        free(extra);
    }

    return result;
}

static int
PanoramiXRenderAddTraps(ClientPtr client)
{
    PanoramiXRes *picture;
    int result = Success, j;

    REQUEST(xRenderAddTrapsReq);
    char *extra;
    int extra_len;
    INT16 x_off, y_off;

    REQUEST_AT_LEAST_SIZE(xRenderAddTrapsReq);
    VERIFY_XIN_PICTURE(picture, stuff->picture, client, DixWriteAccess);
    extra_len = (client->req_len << 2) - sizeof(xRenderAddTrapsReq);
    if (extra_len && (extra = (char *) malloc(extra_len))) {
        memcpy(extra, stuff + 1, extra_len);
        x_off = stuff->xOff;
        y_off = stuff->yOff;
        FOR_NSCREENS_FORWARD(j) {
            if (j)
                memcpy(stuff + 1, extra, extra_len);
            stuff->picture = picture->info[j].id;

            if (picture->u.pict.root) {
                stuff->xOff = x_off + screenInfo.screens[j]->x;
                stuff->yOff = y_off + screenInfo.screens[j]->y;
            }
            result = (*PanoramiXSaveRenderVector[X_RenderAddTraps]) (client);
            if (result != Success)
                break;
        }
        free(extra);
    }

    return result;
}

static int
PanoramiXRenderCreateSolidFill(ClientPtr client)
{
    REQUEST(xRenderCreateSolidFillReq);
    PanoramiXRes *newPict;
    int result = Success, j;

    REQUEST_AT_LEAST_SIZE(xRenderCreateSolidFillReq);

    if (!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newPict->type = XRT_PICTURE;
    panoramix_setup_ids(newPict, client, stuff->pid);
    newPict->u.pict.root = FALSE;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->pid = newPict->info[j].id;
        result = (*PanoramiXSaveRenderVector[X_RenderCreateSolidFill]) (client);
        if (result != Success)
            break;
    }

    if (result == Success)
        AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else
        free(newPict);

    return result;
}

static int
PanoramiXRenderCreateLinearGradient(ClientPtr client)
{
    REQUEST(xRenderCreateLinearGradientReq);
    PanoramiXRes *newPict;
    int result = Success, j;

    REQUEST_AT_LEAST_SIZE(xRenderCreateLinearGradientReq);

    if (!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newPict->type = XRT_PICTURE;
    panoramix_setup_ids(newPict, client, stuff->pid);
    newPict->u.pict.root = FALSE;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->pid = newPict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderCreateLinearGradient]) (client);
        if (result != Success)
            break;
    }

    if (result == Success)
        AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else
        free(newPict);

    return result;
}

static int
PanoramiXRenderCreateRadialGradient(ClientPtr client)
{
    REQUEST(xRenderCreateRadialGradientReq);
    PanoramiXRes *newPict;
    int result = Success, j;

    REQUEST_AT_LEAST_SIZE(xRenderCreateRadialGradientReq);

    if (!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newPict->type = XRT_PICTURE;
    panoramix_setup_ids(newPict, client, stuff->pid);
    newPict->u.pict.root = FALSE;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->pid = newPict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderCreateRadialGradient]) (client);
        if (result != Success)
            break;
    }

    if (result == Success)
        AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else
        free(newPict);

    return result;
}

static int
PanoramiXRenderCreateConicalGradient(ClientPtr client)
{
    REQUEST(xRenderCreateConicalGradientReq);
    PanoramiXRes *newPict;
    int result = Success, j;

    REQUEST_AT_LEAST_SIZE(xRenderCreateConicalGradientReq);

    if (!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newPict->type = XRT_PICTURE;
    panoramix_setup_ids(newPict, client, stuff->pid);
    newPict->u.pict.root = FALSE;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->pid = newPict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderCreateConicalGradient])
            (client);
        if (result != Success)
            break;
    }

    if (result == Success)
        AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else
        free(newPict);

    return result;
}

void
PanoramiXRenderInit(void)
{
    int i;

    XRT_PICTURE = CreateNewResourceType(XineramaDeleteResource,
                                        "XineramaPicture");
    if (RenderErrBase)
        SetResourceTypeErrorValue(XRT_PICTURE, RenderErrBase + BadPicture);
    for (i = 0; i < RenderNumberRequests; i++)
        PanoramiXSaveRenderVector[i] = ProcRenderVector[i];
    /*
     * Stuff in Xinerama aware request processing hooks
     */
    ProcRenderVector[X_RenderCreatePicture] = PanoramiXRenderCreatePicture;
    ProcRenderVector[X_RenderChangePicture] = PanoramiXRenderChangePicture;
    ProcRenderVector[X_RenderSetPictureTransform] =
        PanoramiXRenderSetPictureTransform;
    ProcRenderVector[X_RenderSetPictureFilter] =
        PanoramiXRenderSetPictureFilter;
    ProcRenderVector[X_RenderSetPictureClipRectangles] =
        PanoramiXRenderSetPictureClipRectangles;
    ProcRenderVector[X_RenderFreePicture] = PanoramiXRenderFreePicture;
    ProcRenderVector[X_RenderComposite] = PanoramiXRenderComposite;
    ProcRenderVector[X_RenderCompositeGlyphs8] = PanoramiXRenderCompositeGlyphs;
    ProcRenderVector[X_RenderCompositeGlyphs16] =
        PanoramiXRenderCompositeGlyphs;
    ProcRenderVector[X_RenderCompositeGlyphs32] =
        PanoramiXRenderCompositeGlyphs;
    ProcRenderVector[X_RenderFillRectangles] = PanoramiXRenderFillRectangles;

    ProcRenderVector[X_RenderTrapezoids] = PanoramiXRenderTrapezoids;
    ProcRenderVector[X_RenderTriangles] = PanoramiXRenderTriangles;
    ProcRenderVector[X_RenderTriStrip] = PanoramiXRenderTriStrip;
    ProcRenderVector[X_RenderTriFan] = PanoramiXRenderTriFan;
    ProcRenderVector[X_RenderAddTraps] = PanoramiXRenderAddTraps;

    ProcRenderVector[X_RenderCreateSolidFill] = PanoramiXRenderCreateSolidFill;
    ProcRenderVector[X_RenderCreateLinearGradient] =
        PanoramiXRenderCreateLinearGradient;
    ProcRenderVector[X_RenderCreateRadialGradient] =
        PanoramiXRenderCreateRadialGradient;
    ProcRenderVector[X_RenderCreateConicalGradient] =
        PanoramiXRenderCreateConicalGradient;
}

void
PanoramiXRenderReset(void)
{
    int i;

    for (i = 0; i < RenderNumberRequests; i++)
        ProcRenderVector[i] = PanoramiXSaveRenderVector[i];
    RenderErrBase = 0;
}

#endif                          /* PANORAMIX */
@


1.19
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d1321 1
a1321 1
        glyphsBase = (GlyphPtr *) malloc(nglyph * sizeof(GlyphPtr));
d1328 1
a1328 1
        listsBase = (GlyphListPtr) malloc(nlist * sizeof(GlyphListRec));
d1796 1
a1796 1
    cursors = malloc(ncursor * (sizeof(CursorPtr) + sizeof(CARD32)));
@


1.18
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d2102 1
a2102 14
    REQUEST(xRenderScaleReq);
    REQUEST_SIZE_MATCH(xRenderScaleReq);
    swaps(&stuff->length);
    swapl(&stuff->src);
    swapl(&stuff->dst);
    swapl(&stuff->colorScale);
    swapl(&stuff->alphaScale);
    swaps(&stuff->xSrc);
    swaps(&stuff->ySrc);
    swaps(&stuff->xDst);
    swaps(&stuff->yDst);
    swaps(&stuff->width);
    swaps(&stuff->height);
    return (*ProcRenderVector[stuff->renderReqType]) (client);
@


1.17
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d19 1
a19 1
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
d1551 1
a1551 1
     * Check whether the cursor can be directly supported by 
@


1.16
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d279 2
a283 2
    REQUEST_SIZE_MATCH(xRenderQueryVersionReq);

d1998 1
a1998 1

d2009 1
d2018 1
d2034 1
d2048 1
d2060 1
d2073 1
d2083 1
d2103 1
d2204 1
d2215 1
d2226 1
d2241 1
d2276 1
d2294 1
@


1.15
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d223 1
a223 1
RenderClientCallback(CallbackListPtr *list, pointer closure, pointer data)
d523 1
a523 1
    rc = dixLookupResourceByType((pointer *) &pFormat, stuff->format,
d590 1
a590 1
    rc = dixLookupResourceByType((pointer *) &pFormat, stuff->format,
d607 1
a607 1
    if (!AddResource(stuff->pid, PictureType, (pointer) pPicture))
d641 1
a641 1
        return BadDrawable;
d747 1
a747 1
        rc = dixLookupResourceByType((pointer *) &pFormat, stuff->maskFormat,
d786 1
a786 1
        rc = dixLookupResourceByType((pointer *) &pFormat, stuff->maskFormat,
d825 1
a825 1
        rc = dixLookupResourceByType((pointer *) &pFormat, stuff->maskFormat,
d864 1
a864 1
        rc = dixLookupResourceByType((pointer *) &pFormat, stuff->maskFormat,
d912 1
a912 1
    rc = dixLookupResourceByType((pointer *) &format, stuff->format,
d946 1
a946 1
    if (!AddResource(stuff->gsid, GlyphSetType, (pointer) glyphSet))
d963 1
a963 1
    rc = dixLookupResourceByType((pointer *) &glyphSet, stuff->existing,
d970 1
a970 1
    if (!AddResource(stuff->gsid, GlyphSetType, (pointer) glyphSet))
d987 1
a987 1
    rc = dixLookupResourceByType((pointer *) &glyphSet, stuff->glyphset,
d1027 1
a1027 1
        dixLookupResourceByType((pointer *) &glyphSet, stuff->glyphset,
d1160 1
a1160 1
                FreePicture((pointer) pSrc, 0);
d1192 1
a1192 1
        FreePicture((pointer) pSrc, 0);
d1219 1
a1219 1
    rc = dixLookupResourceByType((pointer *) &glyphSet, stuff->glyphset,
d1285 1
a1285 1
        rc = dixLookupResourceByType((pointer *) &pFormat, stuff->maskFormat,
d1293 1
a1293 1
    rc = dixLookupResourceByType((pointer *) &glyphSet, stuff->glyphset,
d1344 1
a1344 1
                rc = dixLookupResourceByType((pointer *) &glyphSet, gs,
d1511 1
a1511 1
                              0xffffffff, (pointer) argbbits);
d1547 1
a1547 1
                              0xffffffff, (pointer) argbbits);
d1636 1
a1636 1
    if (!AddResource(stuff->cid, RT_CURSOR, (pointer) pCursor)) {
d1802 1
a1802 1
        ret = dixLookupResourceByType((pointer *) (cursors + i), elt->cursor,
d1817 1
a1817 1
    if (AddResource(stuff->cid, RT_CURSOR, (pointer) pCursor))
d1864 1
a1864 1
    if (!AddResource(stuff->pid, PictureType, (pointer) pPicture))
d1903 1
a1903 1
    if (!AddResource(stuff->pid, PictureType, (pointer) pPicture))
d1941 1
a1941 1
    if (!AddResource(stuff->pid, PictureType, (pointer) pPicture))
d1978 1
a1978 1
    if (!AddResource(stuff->pid, PictureType, (pointer) pPicture))
d2569 1
a2569 1
    int rc = dixLookupResourceByType((pointer *)&(pPicture), pid,\
d2593 1
a2593 1
    result = dixLookupResourceByClass((pointer *) &refDraw, stuff->drawable,
@


1.15.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a278 2
    REQUEST_SIZE_MATCH(xRenderQueryVersionReq);

d282 2
d1998 1
a1998 1
    REQUEST_SIZE_MATCH(xRenderQueryVersionReq);
a2008 1
    REQUEST_SIZE_MATCH(xRenderQueryPictFormatsReq);
a2016 1
    REQUEST_AT_LEAST_SIZE(xRenderQueryPictIndexValuesReq);
a2031 1
    REQUEST_AT_LEAST_SIZE(xRenderCreatePictureReq);
a2044 1
    REQUEST_AT_LEAST_SIZE(xRenderChangePictureReq);
a2055 1
    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);
a2067 1
    REQUEST_SIZE_MATCH(xRenderFreePictureReq);
a2076 1
    REQUEST_SIZE_MATCH(xRenderCompositeReq);
a2095 1
    REQUEST_SIZE_MATCH(xRenderScaleReq);
a2195 1
    REQUEST_SIZE_MATCH(xRenderCreateGlyphSetReq);
a2205 1
    REQUEST_SIZE_MATCH(xRenderReferenceGlyphSetReq);
a2215 1
    REQUEST_SIZE_MATCH(xRenderFreeGlyphSetReq);
a2229 1
    REQUEST_AT_LEAST_SIZE(xRenderAddGlyphsReq);
a2263 1
    REQUEST_AT_LEAST_SIZE(xRenderFreeGlyphsReq);
a2280 1
    REQUEST_AT_LEAST_SIZE(xRenderCompositeGlyphsReq);
@


1.15.6.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a278 2
    REQUEST_SIZE_MATCH(xRenderQueryVersionReq);

d282 2
d1998 1
a1998 1
    REQUEST_SIZE_MATCH(xRenderQueryVersionReq);
a2008 1
    REQUEST_SIZE_MATCH(xRenderQueryPictFormatsReq);
a2016 1
    REQUEST_AT_LEAST_SIZE(xRenderQueryPictIndexValuesReq);
a2031 1
    REQUEST_AT_LEAST_SIZE(xRenderCreatePictureReq);
a2044 1
    REQUEST_AT_LEAST_SIZE(xRenderChangePictureReq);
a2055 1
    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);
a2067 1
    REQUEST_SIZE_MATCH(xRenderFreePictureReq);
a2076 1
    REQUEST_SIZE_MATCH(xRenderCompositeReq);
a2095 1
    REQUEST_SIZE_MATCH(xRenderScaleReq);
a2195 1
    REQUEST_SIZE_MATCH(xRenderCreateGlyphSetReq);
a2205 1
    REQUEST_SIZE_MATCH(xRenderReferenceGlyphSetReq);
a2215 1
    REQUEST_SIZE_MATCH(xRenderFreeGlyphSetReq);
a2229 1
    REQUEST_AT_LEAST_SIZE(xRenderAddGlyphsReq);
a2263 1
    REQUEST_AT_LEAST_SIZE(xRenderFreeGlyphsReq);
a2280 1
    REQUEST_AT_LEAST_SIZE(xRenderCompositeGlyphsReq);
@


1.14
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d40 1
d271 5
a275 1
    xRenderQueryVersionReply rep;
a282 4
    memset(&rep, 0, sizeof(xRenderQueryVersionReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
d300 1
a300 1
    WriteToClient(client, sizeof(xRenderQueryVersionReply), (char *) &rep);
d504 1
a504 1
    WriteToClient(client, rlength, (char *) reply);
d535 1
a535 1
    reply = (xRenderQueryPictIndexValuesReply *) malloc(rlength);
d561 1
a561 1
    WriteToClient(client, rlength, (char *) reply);
d1140 1
a1140 2
                GlyphPicture(glyph)[screen] = pDst =
                    CreatePicture(0, &pDstPix->drawable,
d1144 1
d1692 1
a1692 1
    reply = (xRenderQueryFiltersReply *) malloc(total_bytes);
d1752 1
a1752 1
    WriteToClient(client, total_bytes, (char *) reply);
@


1.13
log
@Update to xserver 1.11.2
@
text
@a54 1
#if HAVE_STDINT_H
a55 3
#elif !defined(UINT32_MAX)
#define UINT32_MAX 0xffffffffU
#endif
d57 151
a207 115
static int ProcRenderQueryVersion (ClientPtr pClient);
static int ProcRenderQueryPictFormats (ClientPtr pClient);
static int ProcRenderQueryPictIndexValues (ClientPtr pClient);
static int ProcRenderQueryDithers (ClientPtr pClient);
static int ProcRenderCreatePicture (ClientPtr pClient);
static int ProcRenderChangePicture (ClientPtr pClient);
static int ProcRenderSetPictureClipRectangles (ClientPtr pClient);
static int ProcRenderFreePicture (ClientPtr pClient);
static int ProcRenderComposite (ClientPtr pClient);
static int ProcRenderScale (ClientPtr pClient);
static int ProcRenderTrapezoids (ClientPtr pClient);
static int ProcRenderTriangles (ClientPtr pClient);
static int ProcRenderTriStrip (ClientPtr pClient);
static int ProcRenderTriFan (ClientPtr pClient);
static int ProcRenderColorTrapezoids (ClientPtr pClient);
static int ProcRenderColorTriangles (ClientPtr pClient);
static int ProcRenderTransform (ClientPtr pClient);
static int ProcRenderCreateGlyphSet (ClientPtr pClient);
static int ProcRenderReferenceGlyphSet (ClientPtr pClient);
static int ProcRenderFreeGlyphSet (ClientPtr pClient);
static int ProcRenderAddGlyphs (ClientPtr pClient);
static int ProcRenderAddGlyphsFromPicture (ClientPtr pClient);
static int ProcRenderFreeGlyphs (ClientPtr pClient);
static int ProcRenderCompositeGlyphs (ClientPtr pClient);
static int ProcRenderFillRectangles (ClientPtr pClient);
static int ProcRenderCreateCursor (ClientPtr pClient);
static int ProcRenderSetPictureTransform (ClientPtr pClient);
static int ProcRenderQueryFilters (ClientPtr pClient);
static int ProcRenderSetPictureFilter (ClientPtr pClient);
static int ProcRenderCreateAnimCursor (ClientPtr pClient);
static int ProcRenderAddTraps (ClientPtr pClient);
static int ProcRenderCreateSolidFill (ClientPtr pClient);
static int ProcRenderCreateLinearGradient (ClientPtr pClient);
static int ProcRenderCreateRadialGradient (ClientPtr pClient);
static int ProcRenderCreateConicalGradient (ClientPtr pClient);

static int ProcRenderDispatch (ClientPtr pClient);

static int SProcRenderQueryVersion (ClientPtr pClient);
static int SProcRenderQueryPictFormats (ClientPtr pClient);
static int SProcRenderQueryPictIndexValues (ClientPtr pClient);
static int SProcRenderQueryDithers (ClientPtr pClient);
static int SProcRenderCreatePicture (ClientPtr pClient);
static int SProcRenderChangePicture (ClientPtr pClient);
static int SProcRenderSetPictureClipRectangles (ClientPtr pClient);
static int SProcRenderFreePicture (ClientPtr pClient);
static int SProcRenderComposite (ClientPtr pClient);
static int SProcRenderScale (ClientPtr pClient);
static int SProcRenderTrapezoids (ClientPtr pClient);
static int SProcRenderTriangles (ClientPtr pClient);
static int SProcRenderTriStrip (ClientPtr pClient);
static int SProcRenderTriFan (ClientPtr pClient);
static int SProcRenderColorTrapezoids (ClientPtr pClient);
static int SProcRenderColorTriangles (ClientPtr pClient);
static int SProcRenderTransform (ClientPtr pClient);
static int SProcRenderCreateGlyphSet (ClientPtr pClient);
static int SProcRenderReferenceGlyphSet (ClientPtr pClient);
static int SProcRenderFreeGlyphSet (ClientPtr pClient);
static int SProcRenderAddGlyphs (ClientPtr pClient);
static int SProcRenderAddGlyphsFromPicture (ClientPtr pClient);
static int SProcRenderFreeGlyphs (ClientPtr pClient);
static int SProcRenderCompositeGlyphs (ClientPtr pClient);
static int SProcRenderFillRectangles (ClientPtr pClient);
static int SProcRenderCreateCursor (ClientPtr pClient);
static int SProcRenderSetPictureTransform (ClientPtr pClient);
static int SProcRenderQueryFilters (ClientPtr pClient);
static int SProcRenderSetPictureFilter (ClientPtr pClient);
static int SProcRenderCreateAnimCursor (ClientPtr pClient);
static int SProcRenderAddTraps (ClientPtr pClient);
static int SProcRenderCreateSolidFill (ClientPtr pClient);
static int SProcRenderCreateLinearGradient (ClientPtr pClient);
static int SProcRenderCreateRadialGradient (ClientPtr pClient);
static int SProcRenderCreateConicalGradient (ClientPtr pClient);

static int SProcRenderDispatch (ClientPtr pClient);

int	(*ProcRenderVector[RenderNumberRequests])(ClientPtr) = {
    ProcRenderQueryVersion,
    ProcRenderQueryPictFormats,
    ProcRenderQueryPictIndexValues,
    ProcRenderQueryDithers,
    ProcRenderCreatePicture,
    ProcRenderChangePicture,
    ProcRenderSetPictureClipRectangles,
    ProcRenderFreePicture,
    ProcRenderComposite,
    ProcRenderScale,
    ProcRenderTrapezoids,
    ProcRenderTriangles,
    ProcRenderTriStrip,
    ProcRenderTriFan,
    ProcRenderColorTrapezoids,
    ProcRenderColorTriangles,
    ProcRenderTransform,
    ProcRenderCreateGlyphSet,
    ProcRenderReferenceGlyphSet,
    ProcRenderFreeGlyphSet,
    ProcRenderAddGlyphs,
    ProcRenderAddGlyphsFromPicture,
    ProcRenderFreeGlyphs,
    ProcRenderCompositeGlyphs,
    ProcRenderCompositeGlyphs,
    ProcRenderCompositeGlyphs,
    ProcRenderFillRectangles,
    ProcRenderCreateCursor,
    ProcRenderSetPictureTransform,
    ProcRenderQueryFilters,
    ProcRenderSetPictureFilter,
    ProcRenderCreateAnimCursor,
    ProcRenderAddTraps,
    ProcRenderCreateSolidFill,
    ProcRenderCreateLinearGradient,
    ProcRenderCreateRadialGradient,
    ProcRenderCreateConicalGradient
};
d209 2
a210 39
int	(*SProcRenderVector[RenderNumberRequests])(ClientPtr) = {
    SProcRenderQueryVersion,
    SProcRenderQueryPictFormats,
    SProcRenderQueryPictIndexValues,
    SProcRenderQueryDithers,
    SProcRenderCreatePicture,
    SProcRenderChangePicture,
    SProcRenderSetPictureClipRectangles,
    SProcRenderFreePicture,
    SProcRenderComposite,
    SProcRenderScale,
    SProcRenderTrapezoids,
    SProcRenderTriangles,
    SProcRenderTriStrip,
    SProcRenderTriFan,
    SProcRenderColorTrapezoids,
    SProcRenderColorTriangles,
    SProcRenderTransform,
    SProcRenderCreateGlyphSet,
    SProcRenderReferenceGlyphSet,
    SProcRenderFreeGlyphSet,
    SProcRenderAddGlyphs,
    SProcRenderAddGlyphsFromPicture,
    SProcRenderFreeGlyphs,
    SProcRenderCompositeGlyphs,
    SProcRenderCompositeGlyphs,
    SProcRenderCompositeGlyphs,
    SProcRenderFillRectangles,
    SProcRenderCreateCursor,
    SProcRenderSetPictureTransform,
    SProcRenderQueryFilters,
    SProcRenderSetPictureFilter,
    SProcRenderCreateAnimCursor,
    SProcRenderAddTraps,
    SProcRenderCreateSolidFill,
    SProcRenderCreateLinearGradient,
    SProcRenderCreateRadialGradient,
    SProcRenderCreateConicalGradient
};
a211 2
int	RenderErrBase;
static DevPrivateKeyRec RenderClientPrivateKeyRec;
d215 2
a216 2
    int	    major_version;
    int	    minor_version;
d222 5
a226 7
RenderClientCallback (CallbackListPtr	*list,
		      pointer		closure,
		      pointer		data)
{
    NewClientInfoRec	*clientinfo = (NewClientInfoRec *) data;
    ClientPtr		pClient = clientinfo->client;
    RenderClientPtr	pRenderClient = GetRenderClient (pClient);
d233 1
a233 1
RESTYPE	XRT_PICTURE;
d237 1
a237 1
RenderExtensionInit (void)
d242 12
a253 11
	return;
    if (!PictureFinishInit ())
	return;
    if (!dixRegisterPrivateKey(&RenderClientPrivateKeyRec, PRIVATE_CLIENT, sizeof(RenderClientRec)))
	return;
    if (!AddCallback (&ClientStateCallback, RenderClientCallback, 0))
	return;

    extEntry = AddExtension (RENDER_NAME, 0, RenderNumberErrors,
			     ProcRenderDispatch, SProcRenderDispatch,
			     NULL, StandardMinorOpcode);
d255 1
a255 1
	return;
d259 1
a259 1
	SetResourceTypeErrorValue(XRT_PICTURE, RenderErrBase + BadPicture);
d267 1
a267 1
ProcRenderQueryVersion (ClientPtr client)
d269 1
a269 1
    RenderClientPtr pRenderClient = GetRenderClient (client);
d271 1
a271 1
    register int n;
d284 7
a290 8
        (SERVER_RENDER_MAJOR_VERSION * 1000 + SERVER_RENDER_MINOR_VERSION))
    {
	rep.majorVersion = stuff->majorVersion;
	rep.minorVersion = stuff->minorVersion;
    } else
    {
	rep.majorVersion = SERVER_RENDER_MAJOR_VERSION;
	rep.minorVersion = SERVER_RENDER_MINOR_VERSION;
d294 4
a297 4
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.majorVersion, n);
	swapl(&rep.minorVersion, n);
d299 1
a299 1
    WriteToClient(client, sizeof(xRenderQueryVersionReply), (char *)&rep);
d304 1
a304 1
findVisual (ScreenPtr pScreen, VisualID vid)
d306 2
a307 2
    VisualPtr	pVisual;
    int		v;
d309 4
a312 5
    for (v = 0; v < pScreen->numVisuals; v++)
    {
	pVisual = pScreen->visuals + v;
	if (pVisual->vid == vid)
	    return pVisual;
d318 1
a318 1
ProcRenderQueryPictFormats (ClientPtr client)
d320 21
a340 21
    RenderClientPtr		    pRenderClient = GetRenderClient (client);
    xRenderQueryPictFormatsReply    *reply;
    xPictScreen			    *pictScreen;
    xPictDepth			    *pictDepth;
    xPictVisual			    *pictVisual;
    xPictFormInfo		    *pictForm;
    CARD32			    *pictSubpixel;
    ScreenPtr			    pScreen;
    VisualPtr			    pVisual;
    DepthPtr			    pDepth;
    int				    v, d;
    PictureScreenPtr		    ps;
    PictFormatPtr		    pFormat;
    int				    nformat;
    int				    ndepth;
    int				    nvisual;
    int				    rlength;
    int				    s;
    int				    n;
    int				    numScreens;
    int				    numSubpixel;
d347 3
a349 3
	numScreens = screenInfo.numScreens;
    else 
        numScreens = ((xConnSetup *)ConnectionInfo)->numRoots;
d354 16
a369 18
    for (s = 0; s < numScreens; s++)
    {
	pScreen = screenInfo.screens[s];
	for (d = 0; d < pScreen->numDepths; d++)
	{
	    pDepth = pScreen->allowedDepths + d;
	    ++ndepth;

	    for (v = 0; v < pDepth->numVids; v++)
	    {
		pVisual = findVisual (pScreen, pDepth->vids[v]);
		if (pVisual && PictureMatchVisual (pScreen, pDepth->depth, pVisual))
		    ++nvisual;
	    }
	}
	ps = GetPictureScreenIfSet(pScreen);
	if (ps)
	    nformat += ps->nformats;
d372 1
a372 1
	numSubpixel = 0;
d374 7
a380 8
	numSubpixel = numScreens;
    
    rlength = (sizeof (xRenderQueryPictFormatsReply) +
	       nformat * sizeof (xPictFormInfo) +
	       numScreens * sizeof (xPictScreen) +
	       ndepth * sizeof (xPictDepth) +
	       nvisual * sizeof (xPictVisual) +
	       numSubpixel * sizeof (CARD32));
d383 1
a383 1
	return BadAlloc;
d392 1
a392 1
    
d394 38
a431 42
    
    for (s = 0; s < numScreens; s++)
    {
	pScreen = screenInfo.screens[s];
	ps = GetPictureScreenIfSet(pScreen);
	if (ps)
	{
	    for (nformat = 0, pFormat = ps->formats; 
		 nformat < ps->nformats;
		 nformat++, pFormat++)
	    {
		pictForm->id = pFormat->id;
		pictForm->type = pFormat->type;
		pictForm->depth = pFormat->depth;
		pictForm->direct.red = pFormat->direct.red;
		pictForm->direct.redMask = pFormat->direct.redMask;
		pictForm->direct.green = pFormat->direct.green;
		pictForm->direct.greenMask = pFormat->direct.greenMask;
		pictForm->direct.blue = pFormat->direct.blue;
		pictForm->direct.blueMask = pFormat->direct.blueMask;
		pictForm->direct.alpha = pFormat->direct.alpha;
		pictForm->direct.alphaMask = pFormat->direct.alphaMask;
		if (pFormat->type == PictTypeIndexed && pFormat->index.pColormap)
		    pictForm->colormap = pFormat->index.pColormap->mid;
		else
		    pictForm->colormap = None;
		if (client->swapped)
		{
		    swapl (&pictForm->id, n);
		    swaps (&pictForm->direct.red, n);
		    swaps (&pictForm->direct.redMask, n);
		    swaps (&pictForm->direct.green, n);
		    swaps (&pictForm->direct.greenMask, n);
		    swaps (&pictForm->direct.blue, n);
		    swaps (&pictForm->direct.blueMask, n);
		    swaps (&pictForm->direct.alpha, n);
		    swaps (&pictForm->direct.alphaMask, n);
		    swapl (&pictForm->colormap, n);
		}
		pictForm++;
	    }
	}
d433 1
a433 1
    
d435 43
a477 50
    for (s = 0; s < numScreens; s++)
    {
	pScreen = screenInfo.screens[s];
	pictDepth = (xPictDepth *) (pictScreen + 1);
	ndepth = 0;
	for (d = 0; d < pScreen->numDepths; d++)
	{
	    pictVisual = (xPictVisual *) (pictDepth + 1);
	    pDepth = pScreen->allowedDepths + d;

	    nvisual = 0;
	    for (v = 0; v < pDepth->numVids; v++)
	    {
		pVisual = findVisual (pScreen, pDepth->vids[v]);
		if (pVisual && (pFormat = PictureMatchVisual (pScreen, 
							      pDepth->depth, 
							      pVisual)))
		{
		    pictVisual->visual = pVisual->vid;
		    pictVisual->format = pFormat->id;
		    if (client->swapped)
		    {
			swapl (&pictVisual->visual, n);
			swapl (&pictVisual->format, n);
		    }
		    pictVisual++;
		    nvisual++;
		}
	    }
	    pictDepth->depth = pDepth->depth;
	    pictDepth->nPictVisuals = nvisual;
	    if (client->swapped)
	    {
		swaps (&pictDepth->nPictVisuals, n);
	    }
	    ndepth++;
	    pictDepth = (xPictDepth *) pictVisual;
	}
	pictScreen->nDepth = ndepth;
	ps = GetPictureScreenIfSet(pScreen);
	if (ps)
	    pictScreen->fallback = ps->fallback->id;
	else
	    pictScreen->fallback = 0;
	if (client->swapped)
	{
	    swapl (&pictScreen->nDepth, n);
	    swapl (&pictScreen->fallback, n);
	}
	pictScreen = (xPictScreen *) pictDepth;
d480 22
a501 25
    
    for (s = 0; s < numSubpixel; s++)
    {
	pScreen = screenInfo.screens[s];
	ps = GetPictureScreenIfSet(pScreen);
	if (ps)
	    *pictSubpixel = ps->subpixel;
	else
	    *pictSubpixel = SubPixelUnknown;
	if (client->swapped)
	{
	    swapl (pictSubpixel, n);
	}
	++pictSubpixel;
    }
    
    if (client->swapped)
    {
	swaps (&reply->sequenceNumber, n);
	swapl (&reply->length, n);
	swapl (&reply->numFormats, n);
	swapl (&reply->numScreens, n);
	swapl (&reply->numDepths, n);
	swapl (&reply->numVisuals, n);
	swapl (&reply->numSubpixel, n);
d509 1
a509 1
ProcRenderQueryPictIndexValues (ClientPtr client)
d511 5
a515 4
    PictFormatPtr   pFormat;
    int		    rc, num;
    int		    rlength;
    int		    i, n;
d518 1
a518 1
    xIndexValue	    *values;
d522 2
a523 2
    rc = dixLookupResourceByType((pointer *)&pFormat, stuff->format,
				 PictFormatType, client, DixReadAccess);
d525 1
a525 1
	return rc;
d527 3
a529 4
    if (pFormat->type != PictTypeIndexed)
    {
	client->errorValue = stuff->format;
	return BadMatch;
d532 2
a533 2
    rlength = (sizeof (xRenderQueryPictIndexValuesReply) + 
	       num * sizeof(xIndexValue));
d536 1
a536 1
	return BadAlloc;
d544 14
a557 16
    
    memcpy (reply + 1, pFormat->index.pValues, num * sizeof (xIndexValue));
    
    if (client->swapped)
    {
	for (i = 0; i < num; i++)
	{
	    swapl (&values[i].pixel, n);
	    swaps (&values[i].red, n);
	    swaps (&values[i].green, n);
	    swaps (&values[i].blue, n);
	    swaps (&values[i].alpha, n);
	}
	swaps (&reply->sequenceNumber, n);
	swapl (&reply->length, n);
	swapl (&reply->numIndexValues, n);
d566 1
a566 1
ProcRenderQueryDithers (ClientPtr client)
d572 1
a572 1
ProcRenderCreatePicture (ClientPtr client)
d574 5
a578 4
    PicturePtr	    pPicture;
    DrawablePtr	    pDrawable;
    PictFormatPtr   pFormat;
    int		    len, error, rc;
d585 1
a585 1
			   DixReadAccess|DixAddAccess);
d587 1
a587 1
	return rc;
d589 2
a590 2
    rc = dixLookupResourceByType((pointer *)&pFormat, stuff->format,
				 PictFormatType, client, DixReadAccess);
d592 1
a592 1
	return rc;
d595 1
a595 1
	return BadMatch;
d598 6
a603 9
	return BadLength;
    
    pPicture = CreatePicture (stuff->pid,
			      pDrawable,
			      pFormat,
			      stuff->mask,
			      (XID *) (stuff + 1),
			      client,
			      &error);
d605 3
a607 3
	return error;
    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))
	return BadAlloc;
d612 1
a612 1
ProcRenderChangePicture (ClientPtr client)
d614 2
a615 1
    PicturePtr	    pPicture;
d620 1
a620 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess);
d624 4
a627 4
	return BadLength;
    
    return ChangePicture (pPicture, stuff->mask, (XID *) (stuff + 1),
			  (DevUnion *) 0, client);
d631 1
a631 1
ProcRenderSetPictureClipRectangles (ClientPtr client)
d634 2
a635 2
    PicturePtr	    pPicture;
    int		    nr;
d638 1
a638 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess);
d644 1
a644 1
	return BadLength;
d646 3
a648 3
    return SetPictureClipRects (pPicture,
				  stuff->xOrigin, stuff->yOrigin,
				  nr, (xRectangle *) &stuff[1]);
d652 1
a652 1
ProcRenderFreePicture (ClientPtr client)
d654 2
a655 1
    PicturePtr	pPicture;
d660 2
a661 2
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixDestroyAccess);
    FreeResource (stuff->picture, RT_NONE);
d666 1
a666 1
PictOpValid (CARD8 op)
d668 2
a669 2
    if (/*PictOpMinimum <= op && */ op <= PictOpMaximum)
	return TRUE;
d671 1
a671 1
	return TRUE;
d673 1
a673 1
	return TRUE;
d675 1
a675 1
	return TRUE;
d680 1
a680 1
ProcRenderComposite (ClientPtr client)
d682 2
a683 1
    PicturePtr	pSrc, pMask, pDst;
d687 3
a689 4
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
d691 1
a691 1
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
d694 22
a715 17
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_ALPHA (pMask, stuff->mask, client, DixReadAccess);
    if ((pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen) ||
	(pMask && pMask->pDrawable && pDst->pDrawable->pScreen != pMask->pDrawable->pScreen))
	return BadMatch;
    CompositePicture (stuff->op,
		      pSrc,
		      pMask,
		      pDst,
		      stuff->xSrc,
		      stuff->ySrc,
		      stuff->xMask,
		      stuff->yMask,
		      stuff->xDst,
		      stuff->yDst,
		      stuff->width,
		      stuff->height);
d720 1
a720 1
ProcRenderScale (ClientPtr client)
d726 1
a726 1
ProcRenderTrapezoids (ClientPtr client)
d728 4
a731 3
    int		rc, ntraps;
    PicturePtr	pSrc, pDst;
    PictFormatPtr   pFormat;
d735 3
a737 4
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
d739 2
a740 2
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
d744 6
a749 7
	return BadMatch;
    if (stuff->maskFormat)
    {
	rc = dixLookupResourceByType((pointer *)&pFormat, stuff->maskFormat,
				     PictFormatType, client, DixReadAccess);
	if (rc != Success)
	    return rc;
d752 5
a756 5
	pFormat = 0;
    ntraps = (client->req_len << 2) - sizeof (xRenderTrapezoidsReq);
    if (ntraps % sizeof (xTrapezoid))
	return BadLength;
    ntraps /= sizeof (xTrapezoid);
d758 3
a760 3
	CompositeTrapezoids (stuff->op, pSrc, pDst, pFormat,
			     stuff->xSrc, stuff->ySrc,
			     ntraps, (xTrapezoid *) &stuff[1]);
d765 1
a765 1
ProcRenderTriangles (ClientPtr client)
d767 4
a770 3
    int		rc, ntris;
    PicturePtr	pSrc, pDst;
    PictFormatPtr   pFormat;
d774 3
a776 4
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
d778 2
a779 2
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
d783 6
a788 7
	return BadMatch;
    if (stuff->maskFormat)
    {
	rc = dixLookupResourceByType((pointer *)&pFormat, stuff->maskFormat,
				     PictFormatType, client, DixReadAccess);
	if (rc != Success)
	    return rc;
d791 5
a795 5
	pFormat = 0;
    ntris = (client->req_len << 2) - sizeof (xRenderTrianglesReq);
    if (ntris % sizeof (xTriangle))
	return BadLength;
    ntris /= sizeof (xTriangle);
d797 3
a799 3
	CompositeTriangles (stuff->op, pSrc, pDst, pFormat,
			    stuff->xSrc, stuff->ySrc,
			    ntris, (xTriangle *) &stuff[1]);
d804 1
a804 1
ProcRenderTriStrip (ClientPtr client)
d806 4
a809 3
    int		rc, npoints;
    PicturePtr	pSrc, pDst;
    PictFormatPtr   pFormat;
d813 3
a815 4
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
d817 2
a818 2
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
d822 6
a827 7
	return BadMatch;
    if (stuff->maskFormat)
    {
	rc = dixLookupResourceByType((pointer *)&pFormat, stuff->maskFormat,
				     PictFormatType, client, DixReadAccess);
	if (rc != Success)
	    return rc;
d830 2
a831 2
	pFormat = 0;
    npoints = ((client->req_len << 2) - sizeof (xRenderTriStripReq));
d833 1
a833 1
	return BadLength;
d836 3
a838 3
	CompositeTriStrip (stuff->op, pSrc, pDst, pFormat,
			   stuff->xSrc, stuff->ySrc,
			   npoints, (xPointFixed *) &stuff[1]);
d843 1
a843 1
ProcRenderTriFan (ClientPtr client)
d845 4
a848 3
    int		rc, npoints;
    PicturePtr	pSrc, pDst;
    PictFormatPtr   pFormat;
d852 3
a854 4
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
d856 2
a857 2
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
d861 6
a866 7
	return BadMatch;
    if (stuff->maskFormat)
    {
	rc = dixLookupResourceByType((pointer *)&pFormat, stuff->maskFormat,
				     PictFormatType, client, DixReadAccess);
	if (rc != Success)
	    return rc;
d869 2
a870 2
	pFormat = 0;
    npoints = ((client->req_len << 2) - sizeof (xRenderTriStripReq));
d872 1
a872 1
	return BadLength;
d875 3
a877 3
	CompositeTriFan (stuff->op, pSrc, pDst, pFormat,
			 stuff->xSrc, stuff->ySrc,
			 npoints, (xPointFixed *) &stuff[1]);
d882 1
a882 1
ProcRenderColorTrapezoids (ClientPtr client)
d888 1
a888 1
ProcRenderColorTriangles (ClientPtr client)
d894 1
a894 1
ProcRenderTransform (ClientPtr client)
d900 1
a900 1
ProcRenderCreateGlyphSet (ClientPtr client)
d902 4
a905 3
    GlyphSetPtr	    glyphSet;
    PictFormatPtr   format;
    int		    rc, f;
d911 2
a912 2
    rc = dixLookupResourceByType((pointer *)&format, stuff->format,
				 PictFormatType, client, DixReadAccess);
d914 1
a914 1
	return rc;
d918 2
a919 2
	f = GlyphFormat1;
	break;
d921 2
a922 2
	f = GlyphFormat4;
	break;
d924 2
a925 2
	f = GlyphFormat8;
	break;
d927 2
a928 2
	f = GlyphFormat16;
	break;
d930 2
a931 2
	f = GlyphFormat32;
	break;
d933 1
a933 1
	return BadMatch;
d936 2
a937 2
	return BadMatch;
    glyphSet = AllocateGlyphSet (f, format);
d939 1
a939 1
	return BadAlloc;
d942 1
a942 1
		  glyphSet, RT_NONE, NULL, DixCreateAccess);
d944 3
a946 3
	return rc;
    if (!AddResource (stuff->gsid, GlyphSetType, (pointer)glyphSet))
	return BadAlloc;
d951 1
a951 1
ProcRenderReferenceGlyphSet (ClientPtr client)
d953 1
a953 1
    GlyphSetPtr     glyphSet;
d955 1
d962 5
a966 6
    rc = dixLookupResourceByType((pointer *)&glyphSet, stuff->existing, GlyphSetType,
			   client, DixGetAttrAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->existing;
	return rc;
d969 2
a970 2
    if (!AddResource (stuff->gsid, GlyphSetType, (pointer)glyphSet))
	return BadAlloc;
d978 1
a978 1
ProcRenderFreeGlyphSet (ClientPtr client)
d980 1
a980 1
    GlyphSetPtr     glyphSet;
d982 1
d986 5
a990 6
    rc = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,
			   client, DixDestroyAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->glyphset;
	return rc;
d992 1
a992 1
    FreeResource (stuff->glyphset, RT_NONE);
d997 4
a1000 4
    Glyph	    id;
    GlyphPtr        glyph;
    Bool	    found;
    unsigned char   sha1[20];
d1006 1
a1006 1
ProcRenderAddGlyphs (ClientPtr client)
d1008 2
a1009 1
    GlyphSetPtr     glyphSet;
d1011 12
a1022 12
    GlyphNewRec	    glyphsLocal[NLOCALGLYPH];
    GlyphNewPtr	    glyphsBase, glyphs, glyph_new;
    int		    remain, nglyphs;
    CARD32	    *gids;
    xGlyphInfo	    *gi;
    CARD8	    *bits;
    unsigned int    size;
    int		    err;
    int		    i, screen;
    PicturePtr	    pSrc = NULL, pDst = NULL;
    PixmapPtr	    pSrcPix = NULL, pDstPix = NULL;
    CARD32	    component_alpha;
d1025 6
a1030 6
    err = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,
			    client, DixAddAccess);
    if (err != Success)
    {
	client->errorValue = stuff->glyphset;
	return err;
d1036 1
a1036 1
	    return BadAlloc;
d1038 1
a1038 1
    component_alpha = NeedsComponent (glyphSet->format->format);
d1041 2
a1042 2
	memset (glyphsLocal, 0, sizeof (glyphsLocal));
	glyphsBase = glyphsLocal;
d1044 4
a1047 5
    else
    {
	glyphsBase = (GlyphNewPtr)calloc(nglyphs, sizeof (GlyphNewRec));
	if (!glyphsBase)
	    return BadAlloc;
d1050 1
a1050 1
    remain = (client->req_len << 2) - sizeof (xRenderAddGlyphsReq);
d1057 1
a1057 1
    remain -= (sizeof (CARD32) + sizeof (xGlyphInfo)) * nglyphs;
d1060 4
a1063 4
    if (gi < ((xGlyphInfo *)stuff) ||
        gi > ((xGlyphInfo *)((CARD32 *)stuff + client->req_len)) ||
        bits < ((CARD8 *)stuff) ||
        bits > ((CARD8 *)((CARD32 *)stuff + client->req_len))) {
d1068 114
a1181 131
    for (i = 0; i < nglyphs; i++)
    {
	size_t padded_width;
	glyph_new = &glyphs[i];

	padded_width = PixmapBytePad (gi[i].width,
				      glyphSet->format->depth);

	if (gi[i].height && padded_width > (UINT32_MAX - sizeof(GlyphRec))/gi[i].height)
	    break;
	
	size = gi[i].height * padded_width;
	if (remain < size)
	    break;

	err = HashGlyph (&gi[i], bits, size, glyph_new->sha1);
	if (err)
	    goto bail;

	glyph_new->glyph = FindGlyphByHash (glyph_new->sha1,
					    glyphSet->fdepth);

	if (glyph_new->glyph && glyph_new->glyph != DeletedGlyph)
	{
	    glyph_new->found = TRUE;
	}
	else
	{
	    GlyphPtr glyph;

	    glyph_new->found = FALSE;
	    glyph_new->glyph = glyph = AllocateGlyph (&gi[i], glyphSet->fdepth);
	    if (! glyph)
	    {
		err = BadAlloc;
		goto bail;
	    }

	    for (screen = 0; screen < screenInfo.numScreens; screen++)
	    {
		int	    width = gi[i].width;
		int	    height = gi[i].height;
		int	    depth = glyphSet->format->depth;
		ScreenPtr   pScreen;
		int	    error;

		/* Skip work if it's invisibly small anyway */
		if (!width || !height)
		    break;

		pScreen = screenInfo.screens[screen];
		pSrcPix = GetScratchPixmapHeader (pScreen,
						  width, height,
						  depth, depth,
						  -1, bits);
		if (! pSrcPix)
		{
		    err = BadAlloc;
		    goto bail;
		}

		pSrc = CreatePicture (0, &pSrcPix->drawable,
				      glyphSet->format, 0, NULL,
				      serverClient, &error);
		if (! pSrc)
		{
		    err = BadAlloc;
		    goto bail;
		}

		pDstPix = (pScreen->CreatePixmap) (pScreen,
						   width, height, depth,
						   CREATE_PIXMAP_USAGE_GLYPH_PICTURE);

		if (!pDstPix)
		{
		    err = BadAlloc;
		    goto bail;
		}

		GlyphPicture (glyph)[screen] = pDst =
			CreatePicture (0, &pDstPix->drawable,
				       glyphSet->format,
				       CPComponentAlpha, &component_alpha,
				       serverClient, &error);

		/* The picture takes a reference to the pixmap, so we
		   drop ours. */
		(pScreen->DestroyPixmap) (pDstPix);
		pDstPix = NULL;

		if (! pDst)
		{
		    err = BadAlloc;
		    goto bail;
		}

		CompositePicture (PictOpSrc,
				  pSrc,
				  None,
				  pDst,
				  0, 0,
				  0, 0,
				  0, 0,
				  width, height);

		FreePicture ((pointer) pSrc, 0);
		pSrc = NULL;
		FreeScratchPixmapHeader (pSrcPix);
		pSrcPix = NULL;
	    }

	    memcpy (glyph_new->glyph->sha1, glyph_new->sha1, 20);
	}

	glyph_new->id = gids[i];
	
	if (size & 3)
	    size += 4 - (size & 3);
	bits += size;
	remain -= size;
    }
    if (remain || i < nglyphs)
    {
	err = BadLength;
	goto bail;
    }
    if (!ResizeGlyphSet (glyphSet, nglyphs))
    {
	err = BadAlloc;
	goto bail;
d1184 1
a1184 1
	AddGlyph (glyphSet, glyphs[i].glyph, glyphs[i].id);
d1187 1
a1187 1
	free(glyphsBase);
d1189 1
a1189 1
bail:
d1191 1
a1191 1
	FreePicture ((pointer) pSrc, 0);
d1193 1
a1193 1
	FreeScratchPixmapHeader (pSrcPix);
d1195 2
a1196 2
	if (glyphs[i].glyph && ! glyphs[i].found)
	    free(glyphs[i].glyph);
d1198 1
a1198 1
	free(glyphsBase);
d1203 1
a1203 1
ProcRenderAddGlyphsFromPicture (ClientPtr client)
d1209 1
a1209 1
ProcRenderFreeGlyphs (ClientPtr client)
d1212 4
a1215 4
    GlyphSetPtr     glyphSet;
    int		    rc, nglyph;
    CARD32	    *gids;
    CARD32	    glyph;
d1218 5
a1222 6
    rc = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,
			   client, DixRemoveAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->glyphset;
	return rc;
d1224 2
a1225 1
    nglyph = bytes_to_int32((client->req_len << 2) - sizeof (xRenderFreeGlyphsReq));
d1227 6
a1232 8
    while (nglyph-- > 0)
    {
	glyph = *gids++;
	if (!DeleteGlyph (glyphSet, glyph))
	{
	    client->errorValue = glyph;
	    return RenderErrBase + BadGlyph;
	}
d1238 19
a1256 19
ProcRenderCompositeGlyphs (ClientPtr client)
{
    GlyphSetPtr     glyphSet;
    GlyphSet	    gs;
    PicturePtr      pSrc, pDst;
    PictFormatPtr   pFormat;
    GlyphListRec    listsLocal[NLOCALDELTA];
    GlyphListPtr    lists, listsBase;
    GlyphPtr	    glyphsLocal[NLOCALGLYPH];
    Glyph	    glyph;
    GlyphPtr	    *glyphs, *glyphsBase;
    xGlyphElt	    *elt;
    CARD8	    *buffer, *end;
    int		    nglyph;
    int		    nlist;
    int		    space;
    int		    size;
    int		    rc, n;
    
d1262 14
a1275 9
    default:			    size = 1; break;
    case X_RenderCompositeGlyphs16: size = 2; break;
    case X_RenderCompositeGlyphs32: size = 4; break;
    }
	    
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
d1277 2
a1278 2
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
d1282 6
a1287 7
	return BadMatch;
    if (stuff->maskFormat)
    {
	rc = dixLookupResourceByType((pointer *)&pFormat, stuff->maskFormat,
				     PictFormatType, client, DixReadAccess);
	if (rc != Success)
	    return rc;
d1290 1
a1290 1
	pFormat = 0;
d1292 2
a1293 2
    rc = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset,
				 GlyphSetType, client, DixUseAccess);
d1295 1
a1295 1
	return rc;
d1301 15
a1315 18
    while (buffer + sizeof (xGlyphElt) < end)
    {
	elt = (xGlyphElt *) buffer;
	buffer += sizeof (xGlyphElt);
	
	if (elt->len == 0xff)
	{
	    buffer += 4;
	}
	else
	{
	    nlist++;
	    nglyph += elt->len;
	    space = size * elt->len;
	    if (space & 3)
		space += 4 - (space & 3);
	    buffer += space;
	}
d1318 5
a1322 6
	glyphsBase = glyphsLocal;
    else
    {
	glyphsBase = (GlyphPtr *) malloc(nglyph * sizeof (GlyphPtr));
	if (!glyphsBase)
	    return BadAlloc;
d1325 7
a1331 8
	listsBase = listsLocal;
    else
    {
	listsBase = (GlyphListPtr) malloc(nlist * sizeof (GlyphListRec));
	if (!listsBase) {
	    rc = BadAlloc;
	    goto bail;
	}
d1336 6
a1341 9
    while (buffer + sizeof (xGlyphElt) < end)
    {
	elt = (xGlyphElt *) buffer;
	buffer += sizeof (xGlyphElt);
	
	if (elt->len == 0xff)
	{
	    if (buffer + sizeof (GlyphSet) < end)
	    {
d1343 40
a1382 41
		rc = dixLookupResourceByType((pointer *)&glyphSet, gs,
					     GlyphSetType, client,
					     DixUseAccess);
		if (rc != Success)
		    goto bail;
	    }
	    buffer += 4;
	}
	else
	{
	    lists->xOff = elt->deltax;
	    lists->yOff = elt->deltay;
	    lists->format = glyphSet->format;
	    lists->len = 0;
	    n = elt->len;
	    while (n--)
	    {
		if (buffer + size <= end)
		{
		    switch (size) {
		    case 1:
			glyph = *((CARD8 *)buffer); break;
		    case 2:
			glyph = *((CARD16 *)buffer); break;
		    case 4:
		    default:
			glyph = *((CARD32 *)buffer); break;
		    }
		    if ((*glyphs = FindGlyph (glyphSet, glyph)))
		    {
			lists->len++;
			glyphs++;
		    }
		}
		buffer += size;
	    }
	    space = size * elt->len;
	    if (space & 3)
		buffer += 4 - (space & 3);
	    lists++;
	}
d1385 2
a1386 2
	rc = BadLength;
	goto bail;
d1389 5
a1393 9
    CompositeGlyphs (stuff->op,
		     pSrc,
		     pDst,
		     pFormat,
		     stuff->xSrc,
		     stuff->ySrc,
		     nlist,
		     listsBase,
		     glyphsBase);
d1396 1
a1396 1
bail:
d1398 1
a1398 1
	free(glyphsBase);
d1400 1
a1400 1
	free(listsBase);
d1405 1
a1405 1
ProcRenderFillRectangles (ClientPtr client)
d1407 3
a1409 2
    PicturePtr	    pDst;
    int             things;
d1411 5
a1415 6
    
    REQUEST_AT_LEAST_SIZE (xRenderFillRectanglesReq);
    if (!PictOpValid (stuff->op))
    {
	client->errorValue = stuff->op;
	return BadValue;
d1417 1
a1417 1
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess);
d1420 1
a1420 1
    
d1423 1
a1423 1
	return BadLength;
d1425 4
a1428 7
    
    CompositeRects (stuff->op,
		    pDst,
		    &stuff->color,
		    things,
		    (xRectangle *) &stuff[1]);
    
d1433 1
a1433 1
RenderSetBit (unsigned char *line, int x, int bit)
d1435 2
a1436 2
    unsigned char   mask;
    
d1438 1
a1438 1
	mask = (1 << (x & 7));
d1440 1
a1440 1
	mask = (0x80 >> (x & 7));
d1444 1
a1444 1
	*line |= mask;
d1446 1
a1446 1
	*line &= ~mask;
d1452 2
a1453 2
    {  1,  3,  },
    {  4,  2,  },
d1459 1
a1459 1
ProcRenderCreateCursor (ClientPtr client)
d1462 9
a1470 9
    PicturePtr	    pSrc;
    ScreenPtr	    pScreen;
    unsigned short  width, height;
    CARD32	    *argbbits, *argb;
    unsigned char   *srcbits, *srcline;
    unsigned char   *mskbits, *mskline;
    int		    stride;
    int		    x, y;
    int		    nbytes_mono;
d1472 3
a1474 3
    CursorPtr	    pCursor;
    CARD32	    twocolor[3];
    int		    rc, ncolor;
d1476 1
a1476 1
    REQUEST_SIZE_MATCH (xRenderCreateCursorReq);
d1478 2
a1479 2
    
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess);
d1485 5
a1489 6
    if (height && width > UINT32_MAX/(height*sizeof(CARD32)))
	return BadAlloc;
    if ( stuff->x > width 
      || stuff->y > height )
	return BadMatch;
    argbbits = malloc(width * height * sizeof (CARD32));
d1491 2
a1492 2
	return BadAlloc;
    
d1494 1
a1494 1
    nbytes_mono = stride*height;
d1496 3
a1498 4
    if (!srcbits)
    {
	free(argbbits);
	return BadAlloc;
d1501 47
a1547 54
    if (!mskbits)
    {
	free(argbbits);
	free(srcbits);
	return BadAlloc;
    }

    if (pSrc->format == PICT_a8r8g8b8)
    {
	(*pScreen->GetImage) (pSrc->pDrawable,
			      0, 0, width, height, ZPixmap,
			      0xffffffff, (pointer) argbbits);
    }
    else
    {
	PixmapPtr	pPixmap;
	PicturePtr	pPicture;
	PictFormatPtr	pFormat;
	int		error;

	pFormat = PictureMatchFormat (pScreen, 32, PICT_a8r8g8b8);
	if (!pFormat)
	{
	    free(argbbits);
	    free(srcbits);
	    free(mskbits);
	    return BadImplementation;
	}
	pPixmap = (*pScreen->CreatePixmap) (pScreen, width, height, 32,
					    CREATE_PIXMAP_USAGE_SCRATCH);
	if (!pPixmap)
	{
	    free(argbbits);
	    free(srcbits);
	    free(mskbits);
	    return BadAlloc;
	}
	pPicture = CreatePicture (0, &pPixmap->drawable, pFormat, 0, 0, 
				  client, &error);
	if (!pPicture)
	{
	    free(argbbits);
	    free(srcbits);
	    free(mskbits);
	    return error;
	}
	(*pScreen->DestroyPixmap) (pPixmap);
	CompositePicture (PictOpSrc,
			  pSrc, 0, pPicture,
			  0, 0, 0, 0, 0, 0, width, height);
	(*pScreen->GetImage) (pPicture->pDrawable,
			      0, 0, width, height, ZPixmap,
			      0xffffffff, (pointer) argbbits);
	FreePicture (pPicture, 0);
d1555 19
a1573 21
    for (y = 0; ncolor <= 2 && y < height; y++)
    {
	for (x = 0; ncolor <= 2 && x < width; x++)
	{
	    CARD32  p = *argb++;
	    CARD32  a = (p >> 24);

	    if (a == 0)	    /* transparent */
		continue;
	    if (a == 0xff)  /* opaque */
	    {
		int n;
		for (n = 0; n < ncolor; n++)
		    if (p == twocolor[n])
			break;
		if (n == ncolor)
		    twocolor[ncolor++] = p;
	    }
	    else
		ncolor = 3;
	}
d1575 1
a1575 1
    
d1582 23
a1604 26
    for (y = 0; y < height; y++)
    {
	for (x = 0; x < width; x++)
	{
	    CARD32  p = *argb++;

	    if (ncolor <= 2)
	    {
		CARD32	a = ((p >> 24));

		RenderSetBit (mskline, x, a != 0);
		RenderSetBit (srcline, x, a != 0 && p == twocolor[0]);
	    }
	    else
	    {
		CARD32	a = ((p >> 24) * DITHER_SIZE + 127) / 255;
		CARD32	i = ((CvtR8G8B8toY15(p) >> 7) * DITHER_SIZE + 127) / 255;
		CARD32	d = orderedDither[y&(DITHER_DIM-1)][x&(DITHER_DIM-1)];
		/* Set mask from dithered alpha value */
		RenderSetBit(mskline, x, a > d);
		/* Set src from dithered intensity value */
		RenderSetBit(srcline, x, a > d && i <= d);
	    }
	}
	srcline += stride;
	mskline += stride;
d1609 7
a1615 4
    if (ncolor > 2)
    {
	twocolor[0] = 0xff000000;
	twocolor[1] = 0xffffffff;
d1617 1
a1617 6
    else
    {
	free(argbbits);
	argbbits = 0;
    }
    
d1620 1
a1620 1
    
d1626 7
a1632 7
			 GetColor(twocolor[0], 16),
			 GetColor(twocolor[0], 8),
			 GetColor(twocolor[0], 0),
			 GetColor(twocolor[1], 16),
			 GetColor(twocolor[1], 8),
			 GetColor(twocolor[1], 0),
			 &pCursor, client, stuff->cid);
d1634 4
a1637 4
	goto bail;
    if (!AddResource(stuff->cid, RT_CURSOR, (pointer)pCursor)) {
	rc = BadAlloc;
	goto bail;
d1641 1
a1641 1
bail:
d1648 1
a1648 1
ProcRenderSetPictureTransform (ClientPtr client)
d1651 1
a1651 1
    PicturePtr	pPicture;
d1654 2
a1655 2
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess);
    return SetPictureTransform (pPicture, (PictTransform *) &stuff->transform);
d1659 1
a1659 1
ProcRenderQueryFilters (ClientPtr client)
d1661 10
a1670 10
    REQUEST (xRenderQueryFiltersReq);
    DrawablePtr			pDrawable;
    xRenderQueryFiltersReply	*reply;
    int				nbytesName;
    int				nnames;
    ScreenPtr			pScreen;
    PictureScreenPtr		ps;
    int				i, j, len, total_bytes, rc;
    INT16			*aliases;
    char			*names;
d1674 1
a1674 1
			   DixGetAttrAccess);
d1676 2
a1677 2
	return rc;
    
d1682 6
a1687 7
    if (ps)
    {
	for (i = 0; i < ps->nfilters; i++)
	    nbytesName += 1 + strlen (ps->filters[i].name);
	for (i = 0; i < ps->nfilterAliases; i++)
	    nbytesName += 1 + strlen (ps->filterAliases[i].alias);
	nnames = ps->nfilters + ps->nfilterAliases;
d1690 1
a1690 1
    total_bytes = sizeof (xRenderQueryFiltersReply) + (len << 2);
d1693 1
a1693 1
	return BadAlloc;
d1696 1
a1696 1
    
d1702 39
a1740 2
    if (ps)
    {
d1742 8
a1749 55
	/* fill in alias values */
	for (i = 0; i < ps->nfilters; i++)
	    aliases[i] = FilterAliasNone;
	for (i = 0; i < ps->nfilterAliases; i++)
	{
	    for (j = 0; j < ps->nfilters; j++)
		if (ps->filterAliases[i].filter_id == ps->filters[j].id)
		    break;
	    if (j == ps->nfilters)
	    {
		for (j = 0; j < ps->nfilterAliases; j++)
		    if (ps->filterAliases[i].filter_id == 
			ps->filterAliases[j].alias_id)
		    {
			break;
		    }
		if (j == ps->nfilterAliases)
		    j = FilterAliasNone;
		else
		    j = j + ps->nfilters;
	    }
	    aliases[i + ps->nfilters] = j;
	}

	/* fill in filter names */
	for (i = 0; i < ps->nfilters; i++)
	{
	    j = strlen (ps->filters[i].name);
	    *names++ = j;
	    strncpy (names, ps->filters[i].name, j);
	    names += j;
	}
	
	/* fill in filter alias names */
	for (i = 0; i < ps->nfilterAliases; i++)
	{
	    j = strlen (ps->filterAliases[i].alias);
	    *names++ = j;
	    strncpy (names, ps->filterAliases[i].alias, j);
	    names += j;
	}
    }

    if (client->swapped)
    {
	register int n;

	for (i = 0; i < reply->numAliases; i++)
	{
	    swaps (&aliases[i], n);
	}
    	swaps(&reply->sequenceNumber, n);
    	swapl(&reply->length, n);
	swapl(&reply->numAliases, n);
	swapl(&reply->numFilters, n);
d1753 1
a1753 1
    
d1758 1
a1758 1
ProcRenderSetPictureFilter (ClientPtr client)
d1760 9
a1768 9
    REQUEST (xRenderSetPictureFilterReq);
    PicturePtr	pPicture;
    int		result;
    xFixed	*params;
    int		nparams;
    char	*name;
    
    REQUEST_AT_LEAST_SIZE (xRenderSetPictureFilterReq);
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess);
d1772 1
a1772 1
    result = SetPictureFilter (pPicture, name, stuff->nbytes, params, nparams);
d1777 1
a1777 1
ProcRenderCreateAnimCursor (ClientPtr client)
d1780 7
a1786 7
    CursorPtr	    *cursors;
    CARD32	    *deltas;
    CursorPtr	    pCursor;
    int		    ncursor;
    xAnimCursorElt  *elt;
    int		    i;
    int		    ret;
d1791 5
a1795 3
	return BadLength;
    ncursor = (client->req_len - (bytes_to_int32(sizeof(xRenderCreateAnimCursorReq)))) >> 1;
    cursors = malloc(ncursor * (sizeof (CursorPtr) + sizeof (CARD32)));
d1797 1
a1797 1
	return BadAlloc;
d1800 9
a1808 11
    for (i = 0; i < ncursor; i++)
    {
	ret = dixLookupResourceByType((pointer *)(cursors + i), elt->cursor,
				      RT_CURSOR, client, DixReadAccess);
	if (ret != Success)
	{
	    free(cursors);
	    return ret;
	}
	deltas[i] = elt->delay;
	elt++;
d1810 2
a1811 2
    ret = AnimCursorCreate (cursors, deltas, ncursor, &pCursor, client,
			    stuff->cid);
d1814 4
a1817 4
	return ret;
    
    if (AddResource (stuff->cid, RT_CURSOR, (pointer)pCursor))
	return Success;
d1822 1
a1822 1
ProcRenderAddTraps (ClientPtr client)
d1824 3
a1826 2
    int		ntraps;
    PicturePtr	pPicture;
d1830 1
a1830 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixWriteAccess);
d1833 4
a1836 4
    ntraps = (client->req_len << 2) - sizeof (xRenderAddTrapsReq);
    if (ntraps % sizeof (xTrap))
	return BadLength;
    ntraps /= sizeof (xTrap);
d1838 2
a1839 3
	AddTraps (pPicture,
		  stuff->xOff, stuff->yOff,
		  ntraps, (xTrap *) &stuff[1]);
d1843 2
a1844 1
static int ProcRenderCreateSolidFill(ClientPtr client)
d1846 3
a1848 2
    PicturePtr	    pPicture;
    int		    error = 0;
d1857 1
a1857 1
	return error;
d1860 1
a1860 1
		     pPicture, RT_NONE, NULL, DixCreateAccess);
d1862 3
a1864 3
	return error;
    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))
	return BadAlloc;
d1868 2
a1869 1
static int ProcRenderCreateLinearGradient (ClientPtr client)
d1871 6
a1876 5
    PicturePtr	    pPicture;
    int		    len;
    int		    error = 0;
    xFixed          *stops;
    xRenderColor   *colors;
d1884 3
a1886 3
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
d1889 2
a1890 2
    stops = (xFixed *)(stuff + 1);
    colors = (xRenderColor *)(stops + stuff->nStops);
d1892 3
a1894 2
    pPicture = CreateLinearGradientPicture (stuff->pid, &stuff->p1, &stuff->p2,
                                            stuff->nStops, stops, colors, &error);
d1896 1
a1896 1
	return error;
d1899 1
a1899 1
		     pPicture, RT_NONE, NULL, DixCreateAccess);
d1901 3
a1903 3
	return error;
    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))
	return BadAlloc;
d1907 2
a1908 1
static int ProcRenderCreateRadialGradient (ClientPtr client)
d1910 6
a1915 5
    PicturePtr	    pPicture;
    int		    len;
    int		    error = 0;
    xFixed          *stops;
    xRenderColor   *colors;
d1923 1
a1923 1
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
d1926 2
a1927 2
    stops = (xFixed *)(stuff + 1);
    colors = (xRenderColor *)(stops + stuff->nStops);
d1929 4
a1932 3
    pPicture = CreateRadialGradientPicture (stuff->pid, &stuff->inner, &stuff->outer,
                                            stuff->inner_radius, stuff->outer_radius,
                                            stuff->nStops, stops, colors, &error);
d1934 1
a1934 1
	return error;
d1937 1
a1937 1
		     pPicture, RT_NONE, NULL, DixCreateAccess);
d1939 3
a1941 3
	return error;
    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))
	return BadAlloc;
d1945 2
a1946 1
static int ProcRenderCreateConicalGradient (ClientPtr client)
d1948 6
a1953 5
    PicturePtr	    pPicture;
    int		    len;
    int		    error = 0;
    xFixed          *stops;
    xRenderColor   *colors;
d1961 1
a1961 1
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
d1964 2
a1965 2
    stops = (xFixed *)(stuff + 1);
    colors = (xRenderColor *)(stops + stuff->nStops);
d1967 3
a1969 2
    pPicture = CreateConicalGradientPicture (stuff->pid, &stuff->center, stuff->angle,
                                             stuff->nStops, stops, colors, &error);
d1971 1
a1971 1
	return error;
d1974 1
a1974 1
		     pPicture, RT_NONE, NULL, DixCreateAccess);
d1976 3
a1978 3
	return error;
    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))
	return BadAlloc;
a1981 1

d1983 1
a1983 1
ProcRenderDispatch (ClientPtr client)
d1986 1
a1986 1
    
d1988 1
a1988 1
	return (*ProcRenderVector[stuff->data]) (client);
d1990 1
a1990 1
	return BadRequest;
d1994 1
a1994 1
SProcRenderQueryVersion (ClientPtr client)
a1995 1
    register int n;
d1998 4
a2001 4
    swaps(&stuff->length, n);
    swapl(&stuff->majorVersion, n);
    swapl(&stuff->minorVersion, n);
    return (*ProcRenderVector[stuff->renderReqType])(client);
d2005 1
a2005 1
SProcRenderQueryPictFormats (ClientPtr client)
a2006 1
    register int n;
d2008 1
a2008 1
    swaps(&stuff->length, n);
d2013 1
a2013 1
SProcRenderQueryPictIndexValues (ClientPtr client)
a2014 1
    register int n;
d2016 2
a2017 2
    swaps(&stuff->length, n);
    swapl(&stuff->format, n);
d2022 1
a2022 1
SProcRenderQueryDithers (ClientPtr client)
d2028 1
a2028 1
SProcRenderCreatePicture (ClientPtr client)
a2029 1
    register int n;
d2031 5
a2035 5
    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->drawable, n);
    swapl(&stuff->format, n);
    swapl(&stuff->mask, n);
d2041 1
a2041 1
SProcRenderChangePicture (ClientPtr client)
a2042 1
    register int n;
d2044 3
a2046 3
    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    swapl(&stuff->mask, n);
d2052 1
a2052 1
SProcRenderSetPictureClipRectangles (ClientPtr client)
a2053 1
    register int n;
d2055 4
a2058 4
    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    swaps(&stuff->xOrigin, n);
    swaps(&stuff->yOrigin, n);
d2064 1
a2064 1
SProcRenderFreePicture (ClientPtr client)
a2065 1
    register int n;
d2067 2
a2068 2
    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
d2073 1
a2073 1
SProcRenderComposite (ClientPtr client)
a2074 1
    register int n;
d2076 12
a2087 12
    swaps(&stuff->length, n);
    swapl(&stuff->src, n);
    swapl(&stuff->mask, n);
    swapl(&stuff->dst, n);
    swaps(&stuff->xSrc, n);
    swaps(&stuff->ySrc, n);
    swaps(&stuff->xMask, n);
    swaps(&stuff->yMask, n);
    swaps(&stuff->xDst, n);
    swaps(&stuff->yDst, n);
    swaps(&stuff->width, n);
    swaps(&stuff->height, n);
d2092 1
a2092 1
SProcRenderScale (ClientPtr client)
a2093 1
    register int n;
d2095 11
a2105 11
    swaps(&stuff->length, n);
    swapl(&stuff->src, n);
    swapl(&stuff->dst, n);
    swapl(&stuff->colorScale, n);
    swapl(&stuff->alphaScale, n);
    swaps(&stuff->xSrc, n);
    swaps(&stuff->ySrc, n);
    swaps(&stuff->xDst, n);
    swaps(&stuff->yDst, n);
    swaps(&stuff->width, n);
    swaps(&stuff->height, n);
d2110 1
a2110 1
SProcRenderTrapezoids (ClientPtr client)
a2111 1
    register int n;
d2115 6
a2120 6
    swaps (&stuff->length, n);
    swapl (&stuff->src, n);
    swapl (&stuff->dst, n);
    swapl (&stuff->maskFormat, n);
    swaps (&stuff->xSrc, n);
    swaps (&stuff->ySrc, n);
d2126 1
a2126 1
SProcRenderTriangles (ClientPtr client)
a2127 1
    register int n;
d2131 6
a2136 6
    swaps (&stuff->length, n);
    swapl (&stuff->src, n);
    swapl (&stuff->dst, n);
    swapl (&stuff->maskFormat, n);
    swaps (&stuff->xSrc, n);
    swaps (&stuff->ySrc, n);
d2142 1
a2142 1
SProcRenderTriStrip (ClientPtr client)
a2143 1
    register int n;
d2147 6
a2152 6
    swaps (&stuff->length, n);
    swapl (&stuff->src, n);
    swapl (&stuff->dst, n);
    swapl (&stuff->maskFormat, n);
    swaps (&stuff->xSrc, n);
    swaps (&stuff->ySrc, n);
d2158 1
a2158 1
SProcRenderTriFan (ClientPtr client)
a2159 1
    register int n;
d2163 6
a2168 6
    swaps (&stuff->length, n);
    swapl (&stuff->src, n);
    swapl (&stuff->dst, n);
    swapl (&stuff->maskFormat, n);
    swaps (&stuff->xSrc, n);
    swaps (&stuff->ySrc, n);
d2174 1
a2174 1
SProcRenderColorTrapezoids (ClientPtr client)
d2180 1
a2180 1
SProcRenderColorTriangles (ClientPtr client)
d2186 1
a2186 1
SProcRenderTransform (ClientPtr client)
d2192 1
a2192 1
SProcRenderCreateGlyphSet (ClientPtr client)
a2193 1
    register int n;
d2195 3
a2197 3
    swaps(&stuff->length, n);
    swapl(&stuff->gsid, n);
    swapl(&stuff->format, n);
d2202 1
a2202 1
SProcRenderReferenceGlyphSet (ClientPtr client)
a2203 1
    register int n;
d2205 4
a2208 4
    swaps(&stuff->length, n);
    swapl(&stuff->gsid, n);
    swapl(&stuff->existing, n);
    return (*ProcRenderVector[stuff->renderReqType])  (client);
d2212 1
a2212 1
SProcRenderFreeGlyphSet (ClientPtr client)
a2213 1
    register int n;
d2215 2
a2216 2
    swaps(&stuff->length, n);
    swapl(&stuff->glyphset, n);
d2221 1
a2221 1
SProcRenderAddGlyphs (ClientPtr client)
a2222 1
    register int n;
d2224 2
a2225 2
    CARD32  *gids;
    void    *end;
d2227 1
d2229 3
a2231 3
    swaps(&stuff->length, n);
    swapl(&stuff->glyphset, n);
    swapl(&stuff->nglyphs, n);
d2233 1
a2233 1
	return BadLength;
d2238 1
a2238 1
	return BadLength;
d2240 9
a2248 10
	return BadLength;
    for (i = 0; i < stuff->nglyphs; i++)
    {
	swapl (&gids[i], n);
	swaps (&gi[i].width, n);
	swaps (&gi[i].height, n);
	swaps (&gi[i].x, n);
	swaps (&gi[i].y, n);
	swaps (&gi[i].xOff, n);
	swaps (&gi[i].yOff, n);
d2254 1
a2254 1
SProcRenderAddGlyphsFromPicture (ClientPtr client)
d2260 1
a2260 1
SProcRenderFreeGlyphs (ClientPtr client)
a2261 1
    register int n;
d2263 2
a2264 2
    swaps(&stuff->length, n);
    swapl(&stuff->glyphset, n);
d2270 1
a2270 1
SProcRenderCompositeGlyphs (ClientPtr client)
d2272 7
a2278 8
    register int n;
    xGlyphElt	*elt;
    CARD8	*buffer;
    CARD8	*end;
    int		space;
    int		i;
    int		size;
    
d2280 1
a2280 1
    
d2282 18
a2299 12
    default:			    size = 1; break;
    case X_RenderCompositeGlyphs16: size = 2; break;
    case X_RenderCompositeGlyphs32: size = 4; break;
    }
	    
    swaps(&stuff->length, n);
    swapl(&stuff->src, n);
    swapl(&stuff->dst, n);
    swapl(&stuff->maskFormat, n);
    swapl(&stuff->glyphset, n);
    swaps(&stuff->xSrc, n);
    swaps(&stuff->ySrc, n);
d2302 34
a2335 39
    while (buffer + sizeof (xGlyphElt) < end)
    {
	elt = (xGlyphElt *) buffer;
	buffer += sizeof (xGlyphElt);
	
	swaps (&elt->deltax, n);
	swaps (&elt->deltay, n);
	
	i = elt->len;
	if (i == 0xff)
	{
	    swapl (buffer, n);
	    buffer += 4;
	}
	else
	{
	    space = size * i;
	    switch (size) {
	    case 1:
		buffer += i;
		break;
	    case 2:
		while (i--)
		{
		    swaps (buffer, n);
		    buffer += 2;
		}
		break;
	    case 4:
		while (i--)
		{
		    swapl (buffer, n);
		    buffer += 4;
		}
		break;
	    }
	    if (space & 3)
		buffer += 4 - (space & 3);
	}
d2341 1
a2341 1
SProcRenderFillRectangles (ClientPtr client)
a2342 1
    register int n;
d2345 7
a2351 7
    REQUEST_AT_LEAST_SIZE (xRenderFillRectanglesReq);
    swaps(&stuff->length, n);
    swapl(&stuff->dst, n);
    swaps(&stuff->color.red, n);
    swaps(&stuff->color.green, n);
    swaps(&stuff->color.blue, n);
    swaps(&stuff->color.alpha, n);
d2355 1
a2355 1
    
d2357 1
a2357 1
SProcRenderCreateCursor (ClientPtr client)
a2358 1
    register int n;
d2360 7
a2366 7
    REQUEST_SIZE_MATCH (xRenderCreateCursorReq);
    
    swaps(&stuff->length, n);
    swapl(&stuff->cid, n);
    swapl(&stuff->src, n);
    swaps(&stuff->x, n);
    swaps(&stuff->y, n);
d2369 1
a2369 1
    
d2371 1
a2371 1
SProcRenderSetPictureTransform (ClientPtr client)
a2372 1
    register int n;
d2376 11
a2386 11
    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    swapl(&stuff->transform.matrix11, n);
    swapl(&stuff->transform.matrix12, n);
    swapl(&stuff->transform.matrix13, n);
    swapl(&stuff->transform.matrix21, n);
    swapl(&stuff->transform.matrix22, n);
    swapl(&stuff->transform.matrix23, n);
    swapl(&stuff->transform.matrix31, n);
    swapl(&stuff->transform.matrix32, n);
    swapl(&stuff->transform.matrix33, n);
d2391 1
a2391 1
SProcRenderQueryFilters (ClientPtr client)
d2393 2
a2394 3
    register int n;
    REQUEST (xRenderQueryFiltersReq);
    REQUEST_SIZE_MATCH (xRenderQueryFiltersReq);
d2396 2
a2397 2
    swaps(&stuff->length, n);
    swapl(&stuff->drawable, n);
d2400 1
a2400 1
    
d2402 1
a2402 1
SProcRenderSetPictureFilter (ClientPtr client)
d2404 2
a2405 3
    register int n;
    REQUEST (xRenderSetPictureFilterReq);
    REQUEST_AT_LEAST_SIZE (xRenderSetPictureFilterReq);
d2407 3
a2409 3
    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    swaps(&stuff->nbytes, n);
d2412 1
a2412 1
    
d2414 1
a2414 1
SProcRenderCreateAnimCursor (ClientPtr client)
d2416 2
a2417 3
    register int n;
    REQUEST (xRenderCreateAnimCursorReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateAnimCursorReq);
d2419 2
a2420 2
    swaps(&stuff->length, n);
    swapl(&stuff->cid, n);
d2426 1
a2426 1
SProcRenderAddTraps (ClientPtr client)
d2428 7
a2434 8
    register int n;
    REQUEST (xRenderAddTrapsReq);
    REQUEST_AT_LEAST_SIZE (xRenderAddTrapsReq);

    swaps(&stuff->length, n);
    swapl(&stuff->picture, n);
    swaps(&stuff->xOff, n);
    swaps(&stuff->yOff, n);
d2442 2
a2443 3
    register int n;
    REQUEST (xRenderCreateSolidFillReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateSolidFillReq);
d2445 6
a2450 6
    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swaps(&stuff->color.alpha, n);
    swaps(&stuff->color.red, n);
    swaps(&stuff->color.green, n);
    swaps(&stuff->color.blue, n);
d2454 2
a2455 1
static void swapStops(void *stuff, int num)
d2457 1
a2457 1
    int i, n;
d2460 2
a2461 1
    stops = (CARD32 *)(stuff);
d2463 1
a2463 1
        swapl(stops, n);
d2466 3
a2468 3
    colors = (CARD16 *)(stops);
    for (i = 0; i < 4*num; ++i) {
        swaps(colors, n);
d2474 1
a2474 1
SProcRenderCreateLinearGradient (ClientPtr client)
a2475 1
    register int n;
a2476 2
    REQUEST (xRenderCreateLinearGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateLinearGradientReq);
d2478 10
a2487 7
    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->p1.x, n);
    swapl(&stuff->p1.y, n);
    swapl(&stuff->p2.x, n);
    swapl(&stuff->p2.y, n);
    swapl(&stuff->nStops, n);
d2490 3
a2492 3
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
d2495 1
a2495 1
    swapStops(stuff+1, stuff->nStops);
d2501 1
a2501 1
SProcRenderCreateRadialGradient (ClientPtr client)
a2502 1
    register int n;
a2503 2
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);
d2505 12
a2516 9
    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);
d2519 3
a2521 3
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
d2524 1
a2524 1
    swapStops(stuff+1, stuff->nStops);
d2530 1
a2530 1
SProcRenderCreateConicalGradient (ClientPtr client)
a2531 1
    register int n;
a2532 2
    REQUEST (xRenderCreateConicalGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateConicalGradientReq);
d2534 9
a2542 6
    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->center.x, n);
    swapl(&stuff->center.y, n);
    swapl(&stuff->angle, n);
    swapl(&stuff->nStops, n);
d2545 3
a2547 3
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
d2550 1
a2550 1
    swapStops(stuff+1, stuff->nStops);
d2556 1
a2556 1
SProcRenderDispatch (ClientPtr client)
d2559 1
a2559 1
    
d2561 1
a2561 1
	return (*SProcRenderVector[stuff->data]) (client);
d2563 1
a2563 1
	return BadRequest;
d2582 1
a2582 1
int	    (*PanoramiXSaveRenderVector[RenderNumberRequests])(ClientPtr);
d2585 1
a2585 1
PanoramiXRenderCreatePicture (ClientPtr client)
d2588 2
a2589 2
    PanoramiXRes    *refDraw, *newPict;
    int		    result, j;
d2592 2
a2593 2
    result = dixLookupResourceByClass((pointer *)&refDraw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d2595 3
a2597 3
	return (result == BadValue) ? BadDrawable : result;
    if(!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
	return BadAlloc;
d2600 1
a2600 1
    
d2602 2
a2603 3
	stuff->drawable == screenInfo.screens[0]->root->drawable.id)
    {
	newPict->u.pict.root = TRUE;
d2606 2
a2607 2
	newPict->u.pict.root = FALSE;
    
d2609 5
a2613 4
	stuff->pid = newPict->info[j].id;
	stuff->drawable = refDraw->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderCreatePicture]) (client);
	if(result != Success) break;
d2617 3
a2619 3
	AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
    else 
	free(newPict);
d2625 1
a2625 1
PanoramiXRenderChangePicture (ClientPtr client)
d2627 3
a2629 2
    PanoramiXRes    *pict;
    int		    result = Success, j;
d2633 1
a2633 1
    
d2635 1
a2635 1
    
d2639 2
a2640 1
        if(result != Success) break;
d2647 1
a2647 1
PanoramiXRenderSetPictureClipRectangles (ClientPtr client)
d2650 2
a2651 2
    int		    result = Success, j;
    PanoramiXRes    *pict;
d2654 1
a2654 1
    
d2656 1
a2656 1
    
d2659 5
a2663 2
        result = (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles]) (client);
        if(result != Success) break;
d2670 1
a2670 1
PanoramiXRenderSetPictureTransform (ClientPtr client)
d2673 2
a2674 2
    int		    result = Success, j;
    PanoramiXRes    *pict;
d2677 1
a2677 1
    
d2679 1
a2679 1
    
d2682 4
a2685 2
        result = (*PanoramiXSaveRenderVector[X_RenderSetPictureTransform]) (client);
        if(result != Success) break;
d2692 1
a2692 1
PanoramiXRenderSetPictureFilter (ClientPtr client)
d2695 2
a2696 2
    int		    result = Success, j;
    PanoramiXRes    *pict;
d2699 1
a2699 1
    
d2701 1
a2701 1
    
d2704 4
a2707 2
        result = (*PanoramiXSaveRenderVector[X_RenderSetPictureFilter]) (client);
        if(result != Success) break;
d2714 1
a2714 1
PanoramiXRenderFreePicture (ClientPtr client)
d2717 2
a2718 1
    int         result = Success, j;
a2725 1
    
d2728 4
a2731 3
	stuff->picture = pict->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderFreePicture]) (client);
	if(result != Success) break;
d2735 2
a2736 2
	our resource for us on the last pass through the loop above */
 
d2741 1
a2741 1
PanoramiXRenderComposite (ClientPtr client)
d2743 4
a2746 3
    PanoramiXRes	*src, *msk, *dst;
    int			result = Success, j;
    xRenderCompositeReq	orig;
d2750 5
a2754 5
    
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_ALPHA (msk, stuff->mask, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);
    
d2756 1
a2756 1
    
d2758 20
a2777 23
	stuff->src = src->info[j].id;
	if (src->u.pict.root)
	{
	    stuff->xSrc = orig.xSrc - screenInfo.screens[j]->x;
	    stuff->ySrc = orig.ySrc - screenInfo.screens[j]->y;
	}
	stuff->dst = dst->info[j].id;
	if (dst->u.pict.root)
	{
	    stuff->xDst = orig.xDst - screenInfo.screens[j]->x;
	    stuff->yDst = orig.yDst - screenInfo.screens[j]->y;
	}
	if (msk)
	{
	    stuff->mask = msk->info[j].id;
	    if (msk->u.pict.root)
	    {
		stuff->xMask = orig.xMask - screenInfo.screens[j]->x;
		stuff->yMask = orig.yMask - screenInfo.screens[j]->y;
	    }
	}
	result = (*PanoramiXSaveRenderVector[X_RenderComposite]) (client);
	if(result != Success) break;
d2784 1
a2784 1
PanoramiXRenderCompositeGlyphs (ClientPtr client)
d2786 3
a2788 2
    PanoramiXRes    *src, *dst;
    int		    result = Success, j;
d2790 2
a2791 2
    xGlyphElt	    origElt, *elt;
    INT16	    xSrc, ySrc;
d2794 2
a2795 2
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);
d2797 22
a2818 23
    if (client->req_len << 2 >= (sizeof (xRenderCompositeGlyphsReq) +
				 sizeof (xGlyphElt)))
    {
	elt = (xGlyphElt *) (stuff + 1);
	origElt = *elt;
	xSrc = stuff->xSrc;
	ySrc = stuff->ySrc;
	FOR_NSCREENS_FORWARD(j) {
	    stuff->src = src->info[j].id;
	    if (src->u.pict.root)
	    {
		stuff->xSrc = xSrc - screenInfo.screens[j]->x;
		stuff->ySrc = ySrc - screenInfo.screens[j]->y;
	    }
	    stuff->dst = dst->info[j].id;
	    if (dst->u.pict.root)
	    {
		elt->deltax = origElt.deltax - screenInfo.screens[j]->x;
		elt->deltay = origElt.deltay - screenInfo.screens[j]->y;
	    }
	    result = (*PanoramiXSaveRenderVector[stuff->renderReqType]) (client);
	    if(result != Success) break;
	}
d2825 1
a2825 1
PanoramiXRenderFillRectangles (ClientPtr client)
d2827 3
a2829 2
    PanoramiXRes    *dst;
    int		    result = Success, j;
d2831 2
a2832 2
    char	    *extra;
    int		    extra_len;
d2834 30
a2863 31
    REQUEST_AT_LEAST_SIZE (xRenderFillRectanglesReq);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);
    extra_len = (client->req_len << 2) - sizeof (xRenderFillRectanglesReq);
    if (extra_len &&
	(extra = (char *) malloc(extra_len)))
    {
	memcpy (extra, stuff + 1, extra_len);
	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root)
	    {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    xRectangle	*rects = (xRectangle *) (stuff + 1);
		    int		i = extra_len / sizeof (xRectangle);

		    while (i--)
		    {
			rects->x -= x_off;
			rects->y -= y_off;
			rects++;
		    }
		}
	    }
	    stuff->dst = dst->info[j].id;
	    result = (*PanoramiXSaveRenderVector[X_RenderFillRectangles]) (client);
	    if(result != Success) break;
	}
	free(extra);
d2872 3
a2874 2
    PanoramiXRes        *src, *dst;
    int                 result = Success, j;
d2876 40
a2915 40
    char		*extra;
    int			extra_len;
    
    REQUEST_AT_LEAST_SIZE (xRenderTrapezoidsReq);
    
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof (xRenderTrapezoidsReq);

    if (extra_len &&
	(extra = (char *) malloc(extra_len))) {
	memcpy (extra, stuff + 1, extra_len);

	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
                    xTrapezoid  *trap = (xTrapezoid *) (stuff + 1);
		    int         i = extra_len / sizeof (xTrapezoid);

		    while (i--) {
			trap->top -= y_off;
			trap->bottom -= y_off;
			trap->left.p1.x -= x_off;
			trap->left.p1.y -= y_off;
			trap->left.p2.x -= x_off;
			trap->left.p2.y -= y_off;
			trap->right.p1.x -= x_off;
			trap->right.p1.y -= y_off;
			trap->right.p2.x -= x_off;
			trap->right.p2.y -= y_off;
			trap++;
		    }
		}
	    }
	    
d2918 5
a2922 2
	    result =
		(*PanoramiXSaveRenderVector[X_RenderTrapezoids]) (client);
a2923 3
	    if(result != Success) break;
	}
	
d2933 3
a2935 2
    PanoramiXRes        *src, *dst;
    int                 result = Success, j;
d2937 36
a2972 36
    char		*extra;
    int			extra_len;
    
    REQUEST_AT_LEAST_SIZE (xRenderTrianglesReq);
    
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof (xRenderTrianglesReq);

    if (extra_len &&
	(extra = (char *) malloc(extra_len))) {
	memcpy (extra, stuff + 1, extra_len);

	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
                    xTriangle  *tri = (xTriangle *) (stuff + 1);
		    int         i = extra_len / sizeof (xTriangle);

		    while (i--) {
			tri->p1.x -= x_off;
			tri->p1.y -= y_off;
			tri->p2.x -= x_off;
			tri->p2.y -= y_off;
			tri->p3.x -= x_off;
			tri->p3.y -= y_off;
			tri++;
		    }
		}
	    }
	    
d2975 5
a2979 2
	    result =
		(*PanoramiXSaveRenderVector[X_RenderTriangles]) (client);
a2980 3
	    if(result != Success) break;
	}
	
d2990 3
a2992 2
    PanoramiXRes        *src, *dst;
    int                 result = Success, j;
d2994 32
a3025 32
    char		*extra;
    int			extra_len;
    
    REQUEST_AT_LEAST_SIZE (xRenderTriStripReq);
    
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof (xRenderTriStripReq);

    if (extra_len &&
	(extra = (char *) malloc(extra_len))) {
	memcpy (extra, stuff + 1, extra_len);

	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
                    xPointFixed  *fixed = (xPointFixed *) (stuff + 1);
		    int         i = extra_len / sizeof (xPointFixed);

		    while (i--) {
			fixed->x -= x_off;
			fixed->y -= y_off;
			fixed++;
		    }
		}
	    }
	    
d3028 5
a3032 2
	    result =
		(*PanoramiXSaveRenderVector[X_RenderTriStrip]) (client);
a3033 3
	    if(result != Success) break;
	}
	
d3043 3
a3045 2
    PanoramiXRes        *src, *dst;
    int                 result = Success, j;
d3047 32
a3078 32
    char		*extra;
    int			extra_len;
    
    REQUEST_AT_LEAST_SIZE (xRenderTriFanReq);
    
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess);

    extra_len = (client->req_len << 2) - sizeof (xRenderTriFanReq);

    if (extra_len &&
	(extra = (char *) malloc(extra_len))) {
	memcpy (extra, stuff + 1, extra_len);

	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
                    xPointFixed  *fixed = (xPointFixed *) (stuff + 1);
		    int         i = extra_len / sizeof (xPointFixed);

		    while (i--) {
			fixed->x -= x_off;
			fixed->y -= y_off;
			fixed++;
		    }
		}
	    }
	    
d3081 5
a3085 2
	    result =
		(*PanoramiXSaveRenderVector[X_RenderTriFan]) (client);
a3086 3
	    if(result != Success) break;
	}
	
d3094 1
a3094 1
PanoramiXRenderAddTraps (ClientPtr client)
d3096 3
a3098 2
    PanoramiXRes    *picture;
    int		    result = Success, j;
d3100 25
a3124 26
    char	    *extra;
    int		    extra_len;
    INT16    	    x_off, y_off;

    REQUEST_AT_LEAST_SIZE (xRenderAddTrapsReq);
    VERIFY_XIN_PICTURE (picture, stuff->picture, client, DixWriteAccess);
    extra_len = (client->req_len << 2) - sizeof (xRenderAddTrapsReq);
    if (extra_len &&
	(extra = (char *) malloc(extra_len)))
    {
	memcpy (extra, stuff + 1, extra_len);
	x_off = stuff->xOff;
	y_off = stuff->yOff;
	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    stuff->picture = picture->info[j].id;
	    
	    if (picture->u.pict.root)
	    {
		stuff->xOff = x_off + screenInfo.screens[j]->x;
		stuff->yOff = y_off + screenInfo.screens[j]->y;
	    }
	    result = (*PanoramiXSaveRenderVector[X_RenderAddTraps]) (client);
	    if(result != Success) break;
	}
	free(extra);
d3131 1
a3131 1
PanoramiXRenderCreateSolidFill (ClientPtr client)
d3134 2
a3135 2
    PanoramiXRes    *newPict;
    int		    result = Success, j;
d3139 2
a3140 2
    if(!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
	return BadAlloc;
d3145 1
a3145 1
	
d3147 4
a3150 3
	stuff->pid = newPict->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderCreateSolidFill]) (client);
	if(result != Success) break;
d3154 1
a3154 1
	AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
d3156 1
a3156 1
	free(newPict);
d3162 1
a3162 1
PanoramiXRenderCreateLinearGradient (ClientPtr client)
d3165 2
a3166 2
    PanoramiXRes    *newPict;
    int		    result = Success, j;
d3170 2
a3171 2
    if(!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
	return BadAlloc;
d3178 5
a3182 3
	stuff->pid = newPict->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderCreateLinearGradient]) (client);
	if(result != Success) break;
d3186 1
a3186 1
	AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
d3188 1
a3188 1
	free(newPict);
d3194 1
a3194 1
PanoramiXRenderCreateRadialGradient (ClientPtr client)
d3197 2
a3198 2
    PanoramiXRes    *newPict;
    int		    result = Success, j;
d3202 2
a3203 2
    if(!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
	return BadAlloc;
d3210 5
a3214 3
	stuff->pid = newPict->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderCreateRadialGradient]) (client);
	if(result != Success) break;
d3218 1
a3218 1
	AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
d3220 1
a3220 1
	free(newPict);
d3226 1
a3226 1
PanoramiXRenderCreateConicalGradient (ClientPtr client)
d3229 2
a3230 2
    PanoramiXRes    *newPict;
    int		    result = Success, j;
d3234 2
a3235 2
    if(!(newPict = (PanoramiXRes *) malloc(sizeof(PanoramiXRes))))
	return BadAlloc;
d3242 6
a3247 3
	stuff->pid = newPict->info[j].id;
	result = (*PanoramiXSaveRenderVector[X_RenderCreateConicalGradient]) (client);
	if(result != Success) break;
d3251 1
a3251 1
	AddResource(newPict->info[0].id, XRT_PICTURE, newPict);
d3253 1
a3253 1
	free(newPict);
d3259 1
a3259 1
PanoramiXRenderInit (void)
d3261 4
a3264 4
    int	    i;
    
    XRT_PICTURE = CreateNewResourceType (XineramaDeleteResource,
					 "XineramaPicture");
d3266 1
a3266 1
	SetResourceTypeErrorValue(XRT_PICTURE, RenderErrBase + BadPicture);
d3268 1
a3268 1
	PanoramiXSaveRenderVector[i] = ProcRenderVector[i];
d3274 6
a3279 3
    ProcRenderVector[X_RenderSetPictureTransform] = PanoramiXRenderSetPictureTransform;
    ProcRenderVector[X_RenderSetPictureFilter] = PanoramiXRenderSetPictureFilter;
    ProcRenderVector[X_RenderSetPictureClipRectangles] = PanoramiXRenderSetPictureClipRectangles;
d3283 4
a3286 2
    ProcRenderVector[X_RenderCompositeGlyphs16] = PanoramiXRenderCompositeGlyphs;
    ProcRenderVector[X_RenderCompositeGlyphs32] = PanoramiXRenderCompositeGlyphs;
d3296 6
a3301 3
    ProcRenderVector[X_RenderCreateLinearGradient] = PanoramiXRenderCreateLinearGradient;
    ProcRenderVector[X_RenderCreateRadialGradient] = PanoramiXRenderCreateRadialGradient;
    ProcRenderVector[X_RenderCreateConicalGradient] = PanoramiXRenderCreateConicalGradient;
d3305 1
a3305 1
PanoramiXRenderReset (void)
d3307 2
a3308 1
    int	    i;
d3310 1
a3310 1
	ProcRenderVector[i] = PanoramiXSaveRenderVector[i];
d3314 1
a3314 1
#endif	/* PANORAMIX */
@


1.12
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d50 5
d242 1
a242 1
unsigned long	XRT_PICTURE;
d1087 4
a1090 2
    if (gi < stuff || gi > ((CARD32 *)stuff + client->req_len) ||
        bits < stuff || bits > ((CARD32 *)stuff + client->req_len)) {
d1375 4
a1378 2
	if (!listsBase)
	    return BadAlloc;
d1397 1
a1397 7
		{
		    if (glyphsBase != glyphsLocal)
			free(glyphsBase);
		    if (listsBase != listsLocal)
			free(listsBase);
		    return rc;
		}
d1435 4
a1438 2
    if (buffer > end)
	return BadLength;
d1449 1
d1451 1
d1456 1
a1456 2
    
    return Success;
d1708 5
a1712 3
	return rc;
    if (!AddResource(stuff->cid, RT_CURSOR, (pointer)pCursor))
	return BadAlloc;
d1715 4
a2665 3
#include "panoramiX.h"
#include "panoramiXsrv.h"

d2698 1
a2698 1
    newPict->info[0].id = stuff->pid;
a2706 3

    for(j = 1; j < PanoramiXNumScreens; j++)
	newPict->info[j].id = FakeClientID(client->index);
d3230 1
a3230 1
    newPict->info[0].id = stuff->pid;
a3231 3

    for(j = 1; j < PanoramiXNumScreens; j++)
	newPict->info[j].id = FakeClientID(client->index);
d3260 1
a3260 1
    newPict->info[0].id = stuff->pid;
a3262 3
    for(j = 1; j < PanoramiXNumScreens; j++)
	newPict->info[j].id = FakeClientID(client->index);

d3290 1
a3290 1
    newPict->info[0].id = stuff->pid;
a3292 3
    for(j = 1; j < PanoramiXNumScreens; j++)
	newPict->info[j].id = FakeClientID(client->index);

d3320 1
a3320 1
    newPict->info[0].id = stuff->pid;
a3321 3

    for(j = 1; j < PanoramiXNumScreens; j++)
	newPict->info[j].id = FakeClientID(client->index);
@


1.11
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d2555 2
a2556 2
        swaps(stops, n);
        ++stops;
@


1.10
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d213 2
a214 2
static int RenderClientPrivateKeyIndex;
DevPrivateKey RenderClientPrivateKey = &RenderClientPrivateKeyIndex;
d236 4
d249 1
a249 1
    if (!dixRequestPrivate(RenderClientPrivateKey, sizeof(RenderClientRec)))
d260 7
d304 1
a304 1
    return (client->noClientException);
d389 1
a389 1
    reply = (xRenderQueryPictFormatsReply *) xcalloc (1, rlength);
d526 2
a527 2
    xfree (reply);
    return client->noClientException;
d546 1
a546 1
	return (rc == BadValue) ? RenderErrBase + BadPictFormat : rc;
d556 1
a556 1
    reply = (xRenderQueryPictIndexValuesReply *) xalloc (rlength);
d585 2
a586 2
    xfree(reply);
    return (client->noClientException);
d615 1
a615 1
	return (rc == BadValue) ? RenderErrBase + BadPictFormat : rc;
d645 1
a645 2
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess,
		    RenderErrBase + BadPicture);
a660 1
    int		    result;
d663 1
a663 2
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess,
		    RenderErrBase + BadPicture);
d671 1
a671 1
    result = SetPictureClipRects (pPicture, 
a673 4
    if (client->noClientException != Success)
        return(client->noClientException);
    else
        return(result);
d684 1
a684 2
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixDestroyAccess,
		    RenderErrBase + BadPicture);
d686 1
a686 1
    return(client->noClientException);
d715 1
a715 2
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess,
		    RenderErrBase + BadPicture);
d718 2
a719 4
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess, 
		    RenderErrBase + BadPicture);
    VERIFY_ALPHA (pMask, stuff->mask, client, DixReadAccess, 
		  RenderErrBase + BadPicture);
d758 2
a759 4
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess, 
		    RenderErrBase + BadPicture);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess, 
		    RenderErrBase + BadPicture);
d769 1
a769 1
	    return (rc == BadValue) ? RenderErrBase + BadPictFormat : rc;
d781 1
a781 1
    return client->noClientException;
d798 2
a799 4
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess, 
		    RenderErrBase + BadPicture);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess, 
		    RenderErrBase + BadPicture);
d809 1
a809 1
	    return (rc == BadValue) ? RenderErrBase + BadPictFormat : rc;
d821 1
a821 1
    return client->noClientException;
d838 2
a839 4
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess, 
		    RenderErrBase + BadPicture);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess, 
		    RenderErrBase + BadPicture);
d849 1
a849 1
	    return (rc == BadValue) ? RenderErrBase + BadPictFormat : rc;
d855 1
a855 1
	return(BadLength);
d861 1
a861 1
    return client->noClientException;
d878 2
a879 4
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess, 
		    RenderErrBase + BadPicture);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess, 
		    RenderErrBase + BadPicture);
d889 1
a889 1
	    return (rc == BadValue) ? RenderErrBase + BadPictFormat : rc;
d895 1
a895 1
	return(BadLength);
d901 1
a901 1
    return client->noClientException;
d936 1
a936 1
	return (rc == BadValue) ? RenderErrBase + BadPictFormat : rc;
d988 1
a988 1
	return (rc == BadValue) ? RenderErrBase + BadGlyphSet : rc;
d993 1
a993 1
    return client->noClientException;
d1012 1
a1012 1
	return (rc == BadValue) ? RenderErrBase + BadGlyphSet : rc;
d1015 1
a1015 1
    return client->noClientException;
d1051 1
a1051 1
	return (err == BadValue) ? RenderErrBase + BadGlyphSet : err;
d1067 1
a1067 1
	glyphsBase = (GlyphNewPtr) Xcalloc (nglyphs * sizeof (GlyphNewRec));
d1080 8
d1224 2
a1225 2
	Xfree (glyphsBase);
    return client->noClientException;
d1233 1
a1233 1
	    xfree (glyphs[i].glyph);
d1235 1
a1235 1
	Xfree (glyphsBase);
d1260 1
a1260 1
	return (rc == BadValue) ? RenderErrBase + BadGlyphSet : rc;
d1273 1
a1273 1
    return client->noClientException;
d1311 2
a1312 4
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess,
		    RenderErrBase + BadPicture);
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess,
		    RenderErrBase + BadPicture);
d1322 1
a1322 1
	    return (rc == BadValue) ? RenderErrBase + BadPictFormat : rc;
d1330 1
a1330 1
	return (rc == BadValue) ? RenderErrBase + BadGlyphSet : rc;
d1359 1
a1359 1
	glyphsBase = (GlyphPtr *) xalloc (nglyph * sizeof (GlyphPtr));
d1367 1
a1367 1
	listsBase = (GlyphListPtr) xalloc (nlist * sizeof (GlyphListRec));
d1390 1
a1390 1
			xfree (glyphsBase);
d1392 2
a1393 2
			xfree (listsBase);
		    return (rc == BadValue) ? RenderErrBase + BadGlyphSet : rc;
d1446 1
a1446 1
	xfree (glyphsBase);
d1448 1
a1448 1
	xfree (listsBase);
d1450 1
a1450 1
    return client->noClientException;
d1466 1
a1466 2
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess, 
		    RenderErrBase + BadPicture);
d1472 1
a1472 1
	return(BadLength);
d1481 1
a1481 1
    return client->noClientException;
d1531 1
a1531 2
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess, 
		    RenderErrBase + BadPicture);
d1541 2
a1542 2
	return (BadMatch);
    argbbits = xalloc (width * height * sizeof (CARD32));
d1544 1
a1544 1
	return (BadAlloc);
d1548 1
a1548 1
    srcbits = xcalloc(1, nbytes_mono);
d1551 2
a1552 2
	xfree (argbbits);
	return (BadAlloc);
d1554 1
a1554 1
    mskbits = xcalloc(1, nbytes_mono);
d1557 3
a1559 3
	xfree(argbbits);
	xfree(srcbits);
	return (BadAlloc);
d1578 4
a1581 4
	    xfree (argbbits);
	    xfree (srcbits);
	    xfree (mskbits);
	    return (BadImplementation);
d1587 4
a1590 4
	    xfree (argbbits);
	    xfree (srcbits);
	    xfree (mskbits);
	    return (BadAlloc);
d1596 3
a1598 3
	    xfree (argbbits);
	    xfree (srcbits);
	    xfree (mskbits);
d1682 1
a1682 1
	xfree (argbbits);
d1706 1
a1706 1
    return client->noClientException;
a1713 1
    int		result;
d1716 2
a1717 7
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess,
		    RenderErrBase + BadPicture);
    result = SetPictureTransform (pPicture, (PictTransform *) &stuff->transform);
    if (client->noClientException != Success)
        return(client->noClientException);
    else
        return(result);
d1754 1
a1754 1
    reply = (xRenderQueryFiltersReply *) xalloc (total_bytes);
d1825 1
a1825 1
    xfree (reply);
d1827 1
a1827 1
    return(client->noClientException);
d1841 1
a1841 2
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixSetAttrAccess,
		    RenderErrBase + BadPicture);
d1866 1
a1866 1
    cursors = xalloc (ncursor * (sizeof (CursorPtr) + sizeof (CARD32)));
d1877 2
a1878 2
	    xfree (cursors);
	    return (ret == BadValue) ? BadCursor : ret;
d1885 1
a1885 1
    xfree (cursors);
d1890 1
a1890 1
	return client->noClientException;
d1902 1
a1902 2
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixWriteAccess, 
		    RenderErrBase + BadPicture);
d1913 1
a1913 1
    return client->noClientException;
d2657 1
a2657 1
#define VERIFY_XIN_PICTURE(pPicture, pid, client, mode, err) {\
d2661 1
a2661 1
	return (rc == BadValue) ? err : rc;\
d2664 1
a2664 1
#define VERIFY_XIN_ALPHA(pPicture, pid, client, mode, err) {\
d2668 1
a2668 1
	VERIFY_XIN_PICTURE(pPicture, pid, client, mode, err); \
a2673 2
unsigned long	XRT_PICTURE;

d2686 1
a2686 1
    if(!(newPict = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes))))
d2692 1
a2692 1
	stuff->drawable == WindowTable[0]->drawable.id)
d2712 1
a2712 1
	xfree(newPict);
d2714 1
a2714 1
    return (result);
d2726 1
a2726 2
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess,
		       RenderErrBase + BadPicture);
d2734 1
a2734 1
    return (result);
d2746 1
a2746 2
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess,
		       RenderErrBase + BadPicture);
d2754 1
a2754 1
    return (result);
d2766 1
a2766 2
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess,
		       RenderErrBase + BadPicture);
d2774 1
a2774 1
    return (result);
d2786 1
a2786 2
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess,
		       RenderErrBase + BadPicture);
d2794 1
a2794 1
    return (result);
d2808 1
a2808 2
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixDestroyAccess,
		       RenderErrBase + BadPicture);
d2820 1
a2820 1
    return (result);
d2833 3
a2835 6
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess, 
			RenderErrBase + BadPicture);
    VERIFY_XIN_ALPHA (msk, stuff->mask, client, DixReadAccess, 
		      RenderErrBase + BadPicture);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess, 
			RenderErrBase + BadPicture);
d2843 2
a2844 2
	    stuff->xSrc = orig.xSrc - panoramiXdataPtr[j].x;
	    stuff->ySrc = orig.ySrc - panoramiXdataPtr[j].y;
d2849 2
a2850 2
	    stuff->xDst = orig.xDst - panoramiXdataPtr[j].x;
	    stuff->yDst = orig.yDst - panoramiXdataPtr[j].y;
d2857 2
a2858 2
		stuff->xMask = orig.xMask - panoramiXdataPtr[j].x;
		stuff->yMask = orig.yMask - panoramiXdataPtr[j].y;
d2878 2
a2879 4
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess,
			RenderErrBase + BadPicture);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess,
			RenderErrBase + BadPicture);
d2892 2
a2893 2
		stuff->xSrc = xSrc - panoramiXdataPtr[j].x;
		stuff->ySrc = ySrc - panoramiXdataPtr[j].y;
d2898 2
a2899 2
		elt->deltax = origElt.deltax - panoramiXdataPtr[j].x;
		elt->deltay = origElt.deltay - panoramiXdataPtr[j].y;
d2919 1
a2919 2
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess, 
			RenderErrBase + BadPicture);
d2922 1
a2922 1
	(extra = (char *) xalloc (extra_len)))
d2929 2
a2930 2
		int x_off = panoramiXdataPtr[j].x;
		int y_off = panoramiXdataPtr[j].y;
d2948 1
a2948 1
	xfree(extra);
d2965 2
a2966 4
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess,
			RenderErrBase + BadPicture);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess,
			RenderErrBase + BadPicture);
d2971 1
a2971 1
	(extra = (char *) xalloc (extra_len))) {
d2977 2
a2978 2
                int x_off = panoramiXdataPtr[j].x;
		int y_off = panoramiXdataPtr[j].y;
d3008 1
a3008 1
        xfree(extra);
d3025 2
a3026 4
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess,
			RenderErrBase + BadPicture);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess,
			RenderErrBase + BadPicture);
d3031 1
a3031 1
	(extra = (char *) xalloc (extra_len))) {
d3037 2
a3038 2
                int x_off = panoramiXdataPtr[j].x;
		int y_off = panoramiXdataPtr[j].y;
d3064 1
a3064 1
        xfree(extra);
d3081 2
a3082 4
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess,
			RenderErrBase + BadPicture);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess,
			RenderErrBase + BadPicture);
d3087 1
a3087 1
	(extra = (char *) xalloc (extra_len))) {
d3093 2
a3094 2
                int x_off = panoramiXdataPtr[j].x;
		int y_off = panoramiXdataPtr[j].y;
d3116 1
a3116 1
        xfree(extra);
d3133 2
a3134 4
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess,
			RenderErrBase + BadPicture);
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess,
			RenderErrBase + BadPicture);
d3139 1
a3139 1
	(extra = (char *) xalloc (extra_len))) {
d3145 2
a3146 2
                int x_off = panoramiXdataPtr[j].x;
		int y_off = panoramiXdataPtr[j].y;
d3168 1
a3168 1
        xfree(extra);
d3185 1
a3185 2
    VERIFY_XIN_PICTURE (picture, stuff->picture, client, DixWriteAccess, 
			RenderErrBase + BadPicture);
d3188 1
a3188 1
	(extra = (char *) xalloc (extra_len)))
d3199 2
a3200 2
		stuff->xOff = x_off + panoramiXdataPtr[j].x;
		stuff->yOff = y_off + panoramiXdataPtr[j].y;
d3205 1
a3205 1
	xfree(extra);
d3220 1
a3220 1
    if(!(newPict = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes))))
d3239 1
a3239 1
	xfree(newPict);
d3253 1
a3253 1
    if(!(newPict = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes))))
d3272 1
a3272 1
	xfree(newPict);
d3286 1
a3286 1
    if(!(newPict = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes))))
d3305 1
a3305 1
	xfree(newPict);
d3319 1
a3319 1
    if(!(newPict = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes))))
d3338 1
a3338 1
	xfree(newPict);
d3350 2
d3387 1
@


1.9
log
@Update to server 1.6.5.
@
text
@a24 2
#define NEED_REPLIES
#define NEED_EVENTS
d48 1
a55 3
#define SERVER_RENDER_MAJOR 0
#define SERVER_RENDER_MINOR 10

d270 1
d274 12
a285 2
    rep.majorVersion = SERVER_RENDER_MAJOR;
    rep.minorVersion = SERVER_RENDER_MINOR;
d378 1
a378 1
    reply = (xRenderQueryPictFormatsReply *) xalloc (rlength);
d383 1
a383 1
    reply->length = (rlength - sizeof(xGenericReply)) >> 2;
d523 1
a523 1
    int		    num;
d532 4
a535 4
    pFormat = (PictFormatPtr) SecurityLookupIDByType (client, 
						      stuff->format,
						      PictFormatType,
						      DixReadAccess);
a536 5
    if (!pFormat)
    {
	client->errorValue = stuff->format;
	return RenderErrBase + BadPictFormat;
    }
d551 1
a551 1
    reply->length = (rlength - sizeof(xGenericReply)) >> 2;
d601 5
a605 9
    pFormat = (PictFormatPtr) SecurityLookupIDByType (client, 
						      stuff->format,
						      PictFormatType,
						      DixReadAccess);
    if (!pFormat)
    {
	client->errorValue = stuff->format;
	return RenderErrBase + BadPictFormat;
    }
d608 1
a608 1
    len = client->req_len - (sizeof(xRenderCreatePictureReq) >> 2);
d637 1
a637 1
    len = client->req_len - (sizeof(xRenderChangePictureReq) >> 2);
d659 1
a659 1
    nr = (client->req_len << 2) - sizeof(xRenderChangePictureReq);
d695 2
d747 1
a747 1
    int		ntraps;
d768 4
a771 9
	pFormat = (PictFormatPtr) SecurityLookupIDByType (client,
							  stuff->maskFormat,
							  PictFormatType,
							  DixReadAccess);
	if (!pFormat)
	{
	    client->errorValue = stuff->maskFormat;
	    return RenderErrBase + BadPictFormat;
	}
d789 1
a789 1
    int		ntris;
d810 4
a813 9
	pFormat = (PictFormatPtr) SecurityLookupIDByType (client,
							  stuff->maskFormat,
							  PictFormatType,
							  DixReadAccess);
	if (!pFormat)
	{
	    client->errorValue = stuff->maskFormat;
	    return RenderErrBase + BadPictFormat;
	}
d831 1
a831 1
    int		npoints;
d852 4
a855 9
	pFormat = (PictFormatPtr) SecurityLookupIDByType (client,
							  stuff->maskFormat,
							  PictFormatType,
							  DixReadAccess);
	if (!pFormat)
	{
	    client->errorValue = stuff->maskFormat;
	    return RenderErrBase + BadPictFormat;
	}
d873 1
a873 1
    int		npoints;
d894 4
a897 9
	pFormat = (PictFormatPtr) SecurityLookupIDByType (client,
							  stuff->maskFormat,
							  PictFormatType,
							  DixReadAccess);
	if (!pFormat)
	{
	    client->errorValue = stuff->maskFormat;
	    return RenderErrBase + BadPictFormat;
	}
d941 5
a945 9
    format = (PictFormatPtr) SecurityLookupIDByType (client,
						     stuff->format,
						     PictFormatType,
						     DixReadAccess);
    if (!format)
    {
	client->errorValue = stuff->format;
	return RenderErrBase + BadPictFormat;
    }
d1046 1
a1046 1
    int		    size;
d1134 4
d1162 6
d1177 1
d1262 1
a1262 1
    nglyph = ((client->req_len << 2) - sizeof (xRenderFreeGlyphsReq)) >> 2;
d1294 1
a1294 1
    int		    n;
d1321 4
a1324 9
	pFormat = (PictFormatPtr) SecurityLookupIDByType (client,
							  stuff->maskFormat,
							  PictFormatType,
							  DixReadAccess);
	if (!pFormat)
	{
	    client->errorValue = stuff->maskFormat;
	    return RenderErrBase + BadPictFormat;
	}
d1329 4
a1332 9
    glyphSet = (GlyphSetPtr) SecurityLookupIDByType (client,
						     stuff->glyphset,
						     GlyphSetType,
						     DixUseAccess);
    if (!glyphSet)
    {
	client->errorValue = stuff->glyphset;
	return RenderErrBase + BadGlyphSet;
    }
d1385 5
a1389 6
		gs = *(CARD32 *) buffer;
		glyphSet = (GlyphSetPtr) SecurityLookupIDByType (client,
								 gs,
								 GlyphSetType,
								 DixUseAccess);
		if (!glyphSet)
a1390 1
		    client->errorValue = gs;
d1395 1
a1395 1
		    return RenderErrBase + BadGlyphSet;
d1488 1
a1488 1
SetBit (unsigned char *line, int x, int bit)
d1659 2
a1660 2
		SetBit (mskline, x, a != 0);
		SetBit (srcline, x, a != 0 && p == twocolor[0]);
d1668 1
a1668 1
		SetBit(mskline, x, a > d);
d1670 1
a1670 1
		SetBit(srcline, x, a > d && i <= d);
d1762 1
a1762 1
    len = ((nnames + 1) >> 1) + ((nbytesName + 3) >> 2);
d1854 1
a1854 1
    params = (xFixed *) (name + ((stuff->nbytes + 3) & ~3));
d1876 1
a1876 1
    ncursor = (client->req_len - (SIZEOF(xRenderCreateAnimCursorReq) >> 2)) >> 1;
d1884 3
a1886 3
	cursors[i] = (CursorPtr)SecurityLookupIDByType(client, elt->cursor,
						       RT_CURSOR, DixReadAccess);
	if (!cursors[i])
d1889 1
a1889 2
	    client->errorValue = elt->cursor;
	    return BadCursor;
d2670 4
a2673 5
    pPicture = SecurityLookupIDByType(client, pid, XRT_PICTURE, mode);\
    if (!pPicture) { \
	client->errorValue = pid; \
	return err; \
    } \
d2693 1
a2693 1
    int		    result = Success, j;
d2696 4
a2699 3
    if(!(refDraw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;
d2738 1
a2738 1
    REQUEST_AT_LEAST_SIZE(xChangeWindowAttributesReq);
d3245 132
d3382 2
a3383 1
    XRT_PICTURE = CreateNewResourceType (XineramaDeleteResource);
d3406 5
@


1.8
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d57 3
d277 2
a278 2
    rep.majorVersion = RENDER_MAJOR;
    rep.minorVersion = RENDER_MINOR;
@


1.7
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a212 3
static void
RenderResetProc (ExtensionEntry *extEntry);
    
d214 2
a215 1
DevPrivateKey RenderClientPrivateKey;
d253 1
a253 1
			     RenderResetProc, StandardMinorOpcode);
a258 5
static void
RenderResetProc (ExtensionEntry *extEntry)
{
}

a300 2
extern char *ConnectionInfo;

d1012 1
a1012 1
    rc = dixLookupResource((pointer *)&glyphSet, stuff->existing, GlyphSetType,
d1036 1
a1036 1
    rc = dixLookupResource((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,
d1075 1
a1075 1
    err = dixLookupResource((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,
d1265 1
a1265 1
    rc = dixLookupResource((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,
d1574 1
a1574 1
    srcbits = (unsigned char *)xalloc(nbytes_mono);
d1580 1
a1580 1
    mskbits = (unsigned char *)xalloc(nbytes_mono);
a1586 2
    bzero ((char *) mskbits, nbytes_mono);
    bzero ((char *) srcbits, nbytes_mono);
@


1.6
log
@Fixes for various integer overflow problems from X.Org:
CVE-2008-2360 - RENDER Extension heap buffer overflow
CVE-2008-2361 - RENDER Extension crash
CVE-2008-2362 - RENDER Extension memory corruption
CVE-2008-1379 - MIT-SHM arbitrary memory read
CVE-2008-1377 - RECORD and Security extensions memory corruption
@
text
@d49 1
a215 3
#if 0
static CARD8	RenderReqCode;
#endif
d217 1
a217 1
int	RenderClientPrivateIndex;
d224 1
a224 1
#define GetRenderClient(pClient)    ((RenderClientPtr) (pClient)->devPrivates[RenderClientPrivateIndex].ptr)
d248 1
a248 3
    RenderClientPrivateIndex = AllocateClientPrivateIndex ();
    if (!AllocateClientPrivate (RenderClientPrivateIndex, 
				sizeof (RenderClientRec)))
a257 3
#if 0
    RenderReqCode = (CARD8) extEntry->base;
#endif
a263 2
    ResetPicturePrivateIndex();
    ResetGlyphSetPrivateIndex();
a292 20
#if 0
static int
VisualDepth (ScreenPtr pScreen, VisualPtr pVisual)
{
    DepthPtr    pDepth;
    int		d, v;

    for (d = 0; d < pScreen->numDepths; d++)
    {
	pDepth = pScreen->allowedDepths + d;
	for (v = 0; v < pDepth->numVids; v++)
	{
	    if (pDepth->vids[v] == pVisual->vid)
		return pDepth->depth;
	}
    }
    return 0;
}
#endif

d601 1
a601 1
			   DixWriteAccess);
d642 1
a642 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixWriteAccess,
d662 1
a662 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixWriteAccess,
d961 1
a961 1
    int		    f;
d1000 5
d1014 1
d1021 3
a1023 5
    glyphSet = (GlyphSetPtr) SecurityLookupIDByType (client,
						     stuff->existing,
						     GlyphSetType,
						     DixWriteAccess);
    if (!glyphSet)
d1026 1
a1026 1
	return RenderErrBase + BadGlyphSet;
d1041 1
d1045 3
a1047 5
    glyphSet = (GlyphSetPtr) SecurityLookupIDByType (client,
						     stuff->glyphset,
						     GlyphSetType,
						     DixDestroyAccess);
    if (!glyphSet)
d1050 1
a1050 1
	return RenderErrBase + BadGlyphSet;
d1057 4
a1060 2
    Glyph	id;
    GlyphPtr    glyph;
d1063 2
d1071 1
a1071 2
    GlyphNewPtr	    glyphsBase, glyphs;
    GlyphPtr	    glyph;
d1077 5
a1081 1
    int		    err = BadAlloc;
d1084 3
a1086 5
    glyphSet = (GlyphSetPtr) SecurityLookupIDByType (client,
						     stuff->glyphset,
						     GlyphSetType,
						     DixWriteAccess);
    if (!glyphSet)
d1089 1
a1089 1
	return RenderErrBase + BadGlyphSet;
d1092 1
d1097 4
a1100 1
    if (nglyphs <= NLOCALGLYPH)
d1102 1
d1105 1
a1105 1
	glyphsBase = (GlyphNewPtr) Xalloc (nglyphs * sizeof (GlyphNewRec));
d1118 1
a1118 1
    while (remain >= 0 && nglyphs)
d1120 8
a1127 6
	glyph = AllocateGlyph (gi, glyphSet->fdepth);
	if (!glyph)
	{
	    err = BadAlloc;
	    goto bail;
	}
d1129 1
a1129 4
	glyphs->glyph = glyph;
	glyphs->id = *gids;	
	
	size = glyph->size - sizeof (xGlyphInfo);
d1132 91
a1222 1
	memcpy ((CARD8 *) (glyph + 1), bits, size);
a1227 4
	gi++;
	gids++;
	glyphs++;
	nglyphs--;
d1229 1
a1229 1
    if (nglyphs || remain)
a1233 1
    nglyphs = stuff->nglyphs;
d1239 2
a1240 5
    glyphs = glyphsBase;
    while (nglyphs--) {
	AddGlyph (glyphSet, glyphs->glyph, glyphs->id);
	glyphs++;
    }
d1246 7
a1252 5
    while (glyphs != glyphsBase)
    {
	--glyphs;
	xfree (glyphs->glyph);
    }
d1269 1
a1269 1
    int		    nglyph;
d1274 3
a1276 5
    glyphSet = (GlyphSetPtr) SecurityLookupIDByType (client,
						     stuff->glyphset,
						     GlyphSetType,
						     DixWriteAccess);
    if (!glyphSet)
d1279 1
a1279 1
	return RenderErrBase + BadGlyphSet;
d1356 1
a1356 1
						     DixReadAccess);
d1390 1
a1390 1
	glyphsBase = (GlyphPtr *) ALLOCATE_LOCAL (nglyph * sizeof (GlyphPtr));
d1398 1
a1398 1
	listsBase = (GlyphListPtr) ALLOCATE_LOCAL (nlist * sizeof (GlyphListRec));
d1418 1
a1418 1
								 DixReadAccess);
d1423 1
a1423 1
			DEALLOCATE_LOCAL (glyphsBase);
d1425 1
a1425 1
			DEALLOCATE_LOCAL (listsBase);
d1479 1
a1479 1
	DEALLOCATE_LOCAL (glyphsBase);
d1481 1
a1481 1
	DEALLOCATE_LOCAL (listsBase);
d1560 1
a1560 1
    int		    ncolor;
d1620 2
a1621 1
	pPixmap = (*pScreen->CreatePixmap) (pScreen, width, height, 32);
d1730 14
a1743 10
    pCursor = AllocCursorARGB (srcbits, mskbits, argbbits, &cm,
			       GetColor(twocolor[0], 16),
			       GetColor(twocolor[0], 8),
			       GetColor(twocolor[0], 0),
			       GetColor(twocolor[1], 16),
			       GetColor(twocolor[1], 8),
			       GetColor(twocolor[1], 0));
    if (pCursor && AddResource(stuff->cid, RT_CURSOR, (pointer)pCursor))
	return (client->noClientException);
    return BadAlloc;
d1754 1
a1754 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixWriteAccess,
d1779 1
a1779 1
			   DixReadAccess);
d1884 1
a1884 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixWriteAccess,
d1928 2
a1929 1
    ret = AnimCursorCreate (cursors, deltas, ncursor, &pCursor);
d1975 5
d2011 5
d2046 5
d2080 5
d2981 1
a2981 1
	(extra = (char *) ALLOCATE_LOCAL (extra_len)))
d3007 1
a3007 1
	DEALLOCATE_LOCAL(extra);
d3032 1
a3032 1
	(extra = (char *) ALLOCATE_LOCAL (extra_len))) {
d3069 1
a3069 1
        DEALLOCATE_LOCAL(extra);
d3094 1
a3094 1
	(extra = (char *) ALLOCATE_LOCAL (extra_len))) {
d3127 1
a3127 1
        DEALLOCATE_LOCAL(extra);
d3152 1
a3152 1
	(extra = (char *) ALLOCATE_LOCAL (extra_len))) {
d3181 1
a3181 1
        DEALLOCATE_LOCAL(extra);
d3206 1
a3206 1
	(extra = (char *) ALLOCATE_LOCAL (extra_len))) {
d3235 1
a3235 1
        DEALLOCATE_LOCAL(extra);
a3240 92
#if 0 /* Not implemented yet */

static int
PanoramiXRenderColorTrapezoids(ClientPtr client)
{
    PanoramiXRes        *src, *dst;
    int                 result = Success, j;
    REQUEST(xRenderColorTrapezoidsReq);
    char		*extra;
    int			extra_len;
    
    REQUEST_AT_LEAST_SIZE (xRenderColorTrapezoidsReq);
    
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess,
			RenderErrBase + BadPicture);

    extra_len = (client->req_len << 2) - sizeof (xRenderColorTrapezoidsReq);

    if (extra_len &&
	(extra = (char *) ALLOCATE_LOCAL (extra_len))) {
	memcpy (extra, stuff + 1, extra_len);

	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root) {
                int x_off = panoramiXdataPtr[j].x;
		int y_off = panoramiXdataPtr[j].y;

		if(x_off || y_off) {
			....; 
		}
	    }
	    
            stuff->dst = dst->info[j].id;
	    result =
		(*PanoramiXSaveRenderVector[X_RenderColorTrapezoids]) (client);

	    if(result != Success) break;
	}
	
        DEALLOCATE_LOCAL(extra);
    }

    return result;
}

static int
PanoramiXRenderColorTriangles(ClientPtr client)
{
    PanoramiXRes        *src, *dst;
    int                 result = Success, j;
    REQUEST(xRenderColorTrianglesReq);
    char		*extra;
    int			extra_len;
    
    REQUEST_AT_LEAST_SIZE (xRenderColorTrianglesReq);
    
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess,
			RenderErrBase + BadPicture);

    extra_len = (client->req_len << 2) - sizeof (xRenderColorTrianglesReq);

    if (extra_len &&
	(extra = (char *) ALLOCATE_LOCAL (extra_len))) {
	memcpy (extra, stuff + 1, extra_len);

	FOR_NSCREENS_FORWARD(j) {
	    if (j) memcpy (stuff + 1, extra, extra_len);
	    if (dst->u.pict.root) {
                int x_off = panoramiXdataPtr[j].x;
		int y_off = panoramiXdataPtr[j].y;

		if(x_off || y_off) {
			....; 
		}
	    }
	    
            stuff->dst = dst->info[j].id;
	    result =
		(*PanoramiXSaveRenderVector[X_RenderColorTriangles]) (client);

	    if(result != Success) break;
	}
	
        DEALLOCATE_LOCAL(extra);
    }

    return result;
}

#endif

d3256 1
a3256 1
	(extra = (char *) ALLOCATE_LOCAL (extra_len)))
d3273 1
a3273 1
	DEALLOCATE_LOCAL(extra);
@


1.5
log
@merge xserver 1.4, 1st pass
@
text
@d1507 2
d1923 2
d2498 1
a2498 1
static void swapStops(void *stuff, int n)
d2500 1
a2500 1
    int i;
d2504 1
a2504 1
    for (i = 0; i < n; ++i) {
d2509 1
a2509 1
    for (i = 0; i < 4*n; ++i) {
d2532 2
d2561 2
d2587 2
@


1.5.2.1
log
@Fixes for various integer overflow problems from X.Org:
CVE-2008-2360 - RENDER Extension heap buffer overflow
CVE-2008-2361 - RENDER Extension crash
CVE-2008-2362 - RENDER Extension memory corruption
CVE-2008-1379 - MIT-SHM arbitrary memory read
CVE-2008-1377 - RECORD and Security extensions memory corruption
@
text
@a1506 2
    if (height && width > UINT32_MAX/(height*sizeof(CARD32)))
	return BadAlloc;
a1920 2
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
d2494 1
a2494 1
static void swapStops(void *stuff, int num)
d2496 1
a2496 1
    int i, n;
d2500 1
a2500 1
    for (i = 0; i < num; ++i) {
d2505 1
a2505 1
    for (i = 0; i < 4*num; ++i) {
a2527 2
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
a2554 2
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
a2578 2
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
@


1.4
log
@Pull patch from X.Org bugzilla #7364 from XF4 tree: fix for
potential unaligned access on 64 bit architectures.
@
text
@d563 1
a563 1
						      SecurityReadAccess);
d623 1
a623 2
    int		    len;
    int		    error;
d629 5
a633 2
    SECURITY_VERIFY_DRAWABLE(pDrawable, stuff->drawable, client,
			     SecurityWriteAccess);
d637 1
a637 1
						      SecurityReadAccess);
d671 1
a671 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, SecurityWriteAccess,
d691 1
a691 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, SecurityWriteAccess,
d717 1
a717 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, SecurityDestroyAccess,
d747 1
a747 1
    VERIFY_PICTURE (pDst, stuff->dst, client, SecurityWriteAccess,
d751 1
a751 1
    VERIFY_PICTURE (pSrc, stuff->src, client, SecurityReadAccess, 
d753 1
a753 1
    VERIFY_ALPHA (pMask, stuff->mask, client, SecurityReadAccess, 
d793 1
a793 1
    VERIFY_PICTURE (pSrc, stuff->src, client, SecurityReadAccess, 
d795 1
a795 1
    VERIFY_PICTURE (pDst, stuff->dst, client, SecurityWriteAccess, 
d806 1
a806 1
							  SecurityReadAccess);
d840 1
a840 1
    VERIFY_PICTURE (pSrc, stuff->src, client, SecurityReadAccess, 
d842 1
a842 1
    VERIFY_PICTURE (pDst, stuff->dst, client, SecurityWriteAccess, 
d853 1
a853 1
							  SecurityReadAccess);
d887 1
a887 1
    VERIFY_PICTURE (pSrc, stuff->src, client, SecurityReadAccess, 
d889 1
a889 1
    VERIFY_PICTURE (pDst, stuff->dst, client, SecurityWriteAccess, 
d900 1
a900 1
							  SecurityReadAccess);
d934 1
a934 1
    VERIFY_PICTURE (pSrc, stuff->src, client, SecurityReadAccess, 
d936 1
a936 1
    VERIFY_PICTURE (pDst, stuff->dst, client, SecurityWriteAccess, 
d947 1
a947 1
							  SecurityReadAccess);
d999 1
a999 1
						     SecurityReadAccess);
d1047 1
a1047 1
						     SecurityWriteAccess);
d1072 1
a1072 1
						     SecurityDestroyAccess);
d1106 1
a1106 1
						     SecurityWriteAccess);
d1210 1
a1210 1
						     SecurityWriteAccess);
d1265 1
a1265 1
    VERIFY_PICTURE (pSrc, stuff->src, client, SecurityReadAccess,
d1267 1
a1267 1
    VERIFY_PICTURE (pDst, stuff->dst, client, SecurityWriteAccess,
d1278 1
a1278 1
							  SecurityReadAccess);
d1291 1
a1291 1
						     SecurityReadAccess);
d1353 1
a1353 1
								 SecurityReadAccess);
d1434 1
a1434 1
    VERIFY_PICTURE (pDst, stuff->dst, client, SecurityWriteAccess, 
d1500 1
a1500 1
    VERIFY_PICTURE (pSrc, stuff->src, client, SecurityReadAccess, 
d1682 1
a1682 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, SecurityWriteAccess,
d1701 1
a1701 3
    int				i, j;
    int				len;
    int				total_bytes;
d1706 4
a1709 1
    SECURITY_VERIFY_DRAWABLE(pDrawable, stuff->drawable, client, SecurityReadAccess);
d1812 1
a1812 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, SecurityWriteAccess,
d1846 1
a1846 1
						       RT_CURSOR, SecurityReadAccess);
d1874 1
a1874 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, SecurityWriteAccess, 
d2631 1
a2631 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d2673 1
a2673 1
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, SecurityWriteAccess,
d2694 1
a2694 1
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, SecurityWriteAccess,
d2715 1
a2715 1
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, SecurityWriteAccess,
d2736 1
a2736 1
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, SecurityWriteAccess,
d2759 1
a2759 1
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, SecurityDestroyAccess,
d2785 1
a2785 1
    VERIFY_XIN_PICTURE (src, stuff->src, client, SecurityReadAccess, 
d2787 1
a2787 1
    VERIFY_XIN_ALPHA (msk, stuff->mask, client, SecurityReadAccess, 
d2789 1
a2789 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, SecurityWriteAccess, 
d2833 1
a2833 1
    VERIFY_XIN_PICTURE (src, stuff->src, client, SecurityReadAccess,
d2835 1
a2835 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, SecurityWriteAccess,
d2876 1
a2876 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, SecurityWriteAccess, 
d2923 1
a2923 1
    VERIFY_XIN_PICTURE (src, stuff->src, client, SecurityReadAccess,
d2925 1
a2925 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, SecurityWriteAccess,
d2985 1
a2985 1
    VERIFY_XIN_PICTURE (src, stuff->src, client, SecurityReadAccess,
d2987 1
a2987 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, SecurityWriteAccess,
d3043 1
a3043 1
    VERIFY_XIN_PICTURE (src, stuff->src, client, SecurityReadAccess,
d3045 1
a3045 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, SecurityWriteAccess,
d3097 1
a3097 1
    VERIFY_XIN_PICTURE (src, stuff->src, client, SecurityReadAccess,
d3099 1
a3099 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, SecurityWriteAccess,
d3153 1
a3153 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, SecurityWriteAccess,
d3197 1
a3197 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, SecurityWriteAccess,
d3243 1
a3243 1
    VERIFY_XIN_PICTURE (picture, stuff->picture, client, SecurityWriteAccess, 
@


1.4.2.1
log
@Fixes for various integer overflow problems from X.Org:
CVE-2008-2360 - RENDER Extension heap buffer overflow
CVE-2008-2361 - RENDER Extension crash
CVE-2008-2362 - RENDER Extension memory corruption
CVE-2008-1379 - MIT-SHM arbitrary memory read
CVE-2008-1377 - RECORD and Security extensions memory corruption
@
text
@a1504 2
    if (height && width > UINT32_MAX/(height*sizeof(CARD32)))
	return BadAlloc;
a1917 2
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
d2491 1
a2491 1
static void swapStops(void *stuff, int num)
d2493 1
a2493 1
    int i, n;
d2497 1
a2497 1
    for (i = 0; i < num; ++i) {
d2502 1
a2502 1
    for (i = 0; i < 4*num; ++i) {
a2524 2
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
a2551 2
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
a2575 2
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
@


1.3
log
@swap xOrigin and yOrigin in SProcRenderSetPictureClipRectangles.
Fixes Xrender clipping rectangles when X server and client are of
different endianness, shown by xterm 225 among others.
@
text
@d1347 1
a1347 1
                memcpy(&gs, buffer, sizeof(GlyphSet));
@


1.2
log
@CVE-2006-6101 CVE-2006-6102 CVE-2006-6103: The ProcDbeGetVisualInfo(),
ProcDbeSwapBuffer() and ProcRenderAddGlyphs() functions in the X server,
implementing requests for the dbe and render extensions, may be used
to overwrite data on the stack or in other parts of the X server memory.
@
text
@d2074 2
@


1.1
log
@Initial revision
@
text
@d50 6
d1112 3
d1119 1
a1119 1
	glyphsBase = (GlyphNewPtr) ALLOCATE_LOCAL (nglyphs * sizeof (GlyphNewRec));
d1176 1
a1176 1
	DEALLOCATE_LOCAL (glyphsBase);
d1185 1
a1185 1
	DEALLOCATE_LOCAL (glyphsBase);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@Import xserver version 1.2.0 (X.Org 7.2 final).
@
text
@a49 6
#if HAVE_STDINT_H
#include <stdint.h>
#elif !defined(UINT32_MAX)
#define UINT32_MAX 0xffffffffU
#endif

a1105 3
    if (nglyphs > UINT32_MAX / sizeof(GlyphNewRec))
	    return BadAlloc;

d1110 1
a1110 1
	glyphsBase = (GlyphNewPtr) Xalloc (nglyphs * sizeof (GlyphNewRec));
d1167 1
a1167 1
	Xfree (glyphsBase);
d1176 1
a1176 1
	Xfree (glyphsBase);
@


1.1.1.3
log
@xserver 1.4
@
text
@d563 1
a563 1
						      DixReadAccess);
d623 2
a624 1
    int		    len, error, rc;
d630 2
a631 5
    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
			   DixWriteAccess);
    if (rc != Success)
	return rc;

d635 1
a635 1
						      DixReadAccess);
d669 1
a669 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixWriteAccess,
d689 1
a689 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixWriteAccess,
d715 1
a715 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixDestroyAccess,
d745 1
a745 1
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess,
d749 1
a749 1
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess, 
d751 1
a751 1
    VERIFY_ALPHA (pMask, stuff->mask, client, DixReadAccess, 
d791 1
a791 1
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess, 
d793 1
a793 1
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess, 
d804 1
a804 1
							  DixReadAccess);
d838 1
a838 1
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess, 
d840 1
a840 1
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess, 
d851 1
a851 1
							  DixReadAccess);
d885 1
a885 1
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess, 
d887 1
a887 1
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess, 
d898 1
a898 1
							  DixReadAccess);
d932 1
a932 1
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess, 
d934 1
a934 1
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess, 
d945 1
a945 1
							  DixReadAccess);
d997 1
a997 1
						     DixReadAccess);
d1045 1
a1045 1
						     DixWriteAccess);
d1070 1
a1070 1
						     DixDestroyAccess);
d1104 1
a1104 1
						     DixWriteAccess);
d1208 1
a1208 1
						     DixWriteAccess);
d1263 1
a1263 1
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess,
d1265 1
a1265 1
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess,
d1276 1
a1276 1
							  DixReadAccess);
d1289 1
a1289 1
						     DixReadAccess);
d1351 1
a1351 1
								 DixReadAccess);
d1432 1
a1432 1
    VERIFY_PICTURE (pDst, stuff->dst, client, DixWriteAccess, 
d1498 1
a1498 1
    VERIFY_PICTURE (pSrc, stuff->src, client, DixReadAccess, 
d1680 1
a1680 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixWriteAccess,
d1699 3
a1701 1
    int				i, j, len, total_bytes, rc;
d1706 1
a1706 4
    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
			   DixReadAccess);
    if (rc != Success)
	return rc;
d1809 1
a1809 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixWriteAccess,
d1843 1
a1843 1
						       RT_CURSOR, DixReadAccess);
d1871 1
a1871 1
    VERIFY_PICTURE (pPicture, stuff->picture, client, DixWriteAccess, 
a2073 2
    swaps(&stuff->xOrigin, n);
    swaps(&stuff->yOrigin, n);
d2626 1
a2626 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d2668 1
a2668 1
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess,
d2689 1
a2689 1
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess,
d2710 1
a2710 1
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess,
d2731 1
a2731 1
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess,
d2754 1
a2754 1
    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixDestroyAccess,
d2780 1
a2780 1
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess, 
d2782 1
a2782 1
    VERIFY_XIN_ALPHA (msk, stuff->mask, client, DixReadAccess, 
d2784 1
a2784 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess, 
d2828 1
a2828 1
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess,
d2830 1
a2830 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess,
d2871 1
a2871 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess, 
d2918 1
a2918 1
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess,
d2920 1
a2920 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess,
d2980 1
a2980 1
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess,
d2982 1
a2982 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess,
d3038 1
a3038 1
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess,
d3040 1
a3040 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess,
d3092 1
a3092 1
    VERIFY_XIN_PICTURE (src, stuff->src, client, DixReadAccess,
d3094 1
a3094 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess,
d3148 1
a3148 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess,
d3192 1
a3192 1
    VERIFY_XIN_PICTURE (dst, stuff->dst, client, DixWriteAccess,
d3238 1
a3238 1
    VERIFY_XIN_PICTURE (picture, stuff->picture, client, DixWriteAccess, 
@


