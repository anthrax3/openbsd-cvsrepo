head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.2
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.5.0.16
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.14
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.12
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.10
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	s0SI41sEunLdyFfd;

1.5
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.21;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *
 * Copyright Â© 2001 Keith Packard, member of The XFree86 Project, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _MIINDEX_H_
#define _MIINDEX_H_

#include "scrnintstr.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "mi.h"
#include "picturestr.h"
#include "mipict.h"
#include "colormapst.h"

#define NUM_CUBE_LEVELS	4
#define NUM_GRAY_LEVELS	13

static Bool
miBuildRenderColormap(ColormapPtr pColormap, Pixel * pixels, int *nump)
{
    int r, g, b;
    unsigned short red, green, blue;
    Pixel pixel;
    Bool used[MI_MAX_INDEXED];
    int needed;
    int policy;
    int cube, gray;
    int i, n;

    if (pColormap->mid != pColormap->pScreen->defColormap) {
        policy = PictureCmapPolicyAll;
    }
    else {
        int avail = pColormap->pVisual->ColormapEntries;

        policy = PictureCmapPolicy;
        if (policy == PictureCmapPolicyDefault) {
            if (avail >= 256 &&
                (pColormap->pVisual->class | DynamicClass) == PseudoColor)
                policy = PictureCmapPolicyColor;
            else if (avail >= 64)
                policy = PictureCmapPolicyGray;
            else
                policy = PictureCmapPolicyMono;
        }
    }
    /*
     * Make sure enough cells are free for the chosen policy
     */
    for (;;) {
        switch (policy) {
        case PictureCmapPolicyAll:
            needed = 0;
            break;
        case PictureCmapPolicyColor:
            needed = 71;
            break;
        case PictureCmapPolicyGray:
            needed = 11;
            break;
        case PictureCmapPolicyMono:
        default:
            needed = 0;
            break;
        }
        if (needed <= pColormap->freeRed)
            break;
        policy--;
    }

    /*
     * Compute size of cube and gray ramps
     */
    cube = gray = 0;
    switch (policy) {
    case PictureCmapPolicyAll:
        /*
         * Allocate as big a cube as possible
         */
        if ((pColormap->pVisual->class | DynamicClass) == PseudoColor) {
            for (cube = 1;
                 cube * cube * cube < pColormap->pVisual->ColormapEntries;
                 cube++);
            cube--;
            if (cube == 1)
                cube = 0;
        }
        else
            cube = 0;
        /*
         * Figure out how many gray levels to use so that they
         * line up neatly with the cube
         */
        if (cube) {
            needed = pColormap->pVisual->ColormapEntries - (cube * cube * cube);
            /* levels to fill in with */
            gray = needed / (cube - 1);
            /* total levels */
            gray = (gray + 1) * (cube - 1) + 1;
        }
        else
            gray = pColormap->pVisual->ColormapEntries;
        break;

    case PictureCmapPolicyColor:
        cube = NUM_CUBE_LEVELS;
        /* fall through ... */
    case PictureCmapPolicyGray:
        gray = NUM_GRAY_LEVELS;
        break;
    case PictureCmapPolicyMono:
    default:
        gray = 2;
        break;
    }

    memset(used, '\0', pColormap->pVisual->ColormapEntries * sizeof(Bool));
    for (r = 0; r < cube; r++)
        for (g = 0; g < cube; g++)
            for (b = 0; b < cube; b++) {
                pixel = 0;
                red = (r * 65535 + (cube - 1) / 2) / (cube - 1);
                green = (g * 65535 + (cube - 1) / 2) / (cube - 1);
                blue = (b * 65535 + (cube - 1) / 2) / (cube - 1);
                if (AllocColor(pColormap, &red, &green,
                               &blue, &pixel, 0) != Success)
                    return FALSE;
                used[pixel] = TRUE;
            }
    for (g = 0; g < gray; g++) {
        pixel = 0;
        red = green = blue = (g * 65535 + (gray - 1) / 2) / (gray - 1);
        if (AllocColor(pColormap, &red, &green, &blue, &pixel, 0) != Success)
            return FALSE;
        used[pixel] = TRUE;
    }
    n = 0;
    for (i = 0; i < pColormap->pVisual->ColormapEntries; i++)
        if (used[i])
            pixels[n++] = i;

    *nump = n;

    return TRUE;
}

/* 0 <= red, green, blue < 32 */
static Pixel
FindBestColor(miIndexedPtr pIndexed, Pixel * pixels, int num,
              int red, int green, int blue)
{
    Pixel best = pixels[0];
    int bestDist = 1 << 30;
    int dist;
    int dr, dg, db;

    while (num--) {
        Pixel pixel = *pixels++;
        CARD32 v = pIndexed->rgba[pixel];

        dr = ((v >> 19) & 0x1f);
        dg = ((v >> 11) & 0x1f);
        db = ((v >> 3) & 0x1f);
        dr = dr - red;
        dg = dg - green;
        db = db - blue;
        dist = dr * dr + dg * dg + db * db;
        if (dist < bestDist) {
            bestDist = dist;
            best = pixel;
        }
    }
    return best;
}

/* 0 <= gray < 32768 */
static Pixel
FindBestGray(miIndexedPtr pIndexed, Pixel * pixels, int num, int gray)
{
    Pixel best = pixels[0];
    int bestDist = 1 << 30;
    int dist;
    int dr;
    int r;

    while (num--) {
        Pixel pixel = *pixels++;
        CARD32 v = pIndexed->rgba[pixel];

        r = v & 0xff;
        r = r | (r << 8);
        dr = gray - (r >> 1);
        dist = dr * dr;
        if (dist < bestDist) {
            bestDist = dist;
            best = pixel;
        }
    }
    return best;
}

Bool
miInitIndexed(ScreenPtr pScreen, PictFormatPtr pFormat)
{
    ColormapPtr pColormap = pFormat->index.pColormap;
    VisualPtr pVisual = pColormap->pVisual;
    miIndexedPtr pIndexed;
    Pixel pixels[MI_MAX_INDEXED];
    xrgb rgb[MI_MAX_INDEXED];
    int num;
    int i;
    Pixel p, r, g, b;

    if (pVisual->ColormapEntries > MI_MAX_INDEXED)
        return FALSE;

    if (pVisual->class & DynamicClass) {
        if (!miBuildRenderColormap(pColormap, pixels, &num))
            return FALSE;
    }
    else {
        num = pVisual->ColormapEntries;
        for (p = 0; p < num; p++)
            pixels[p] = p;
    }

    pIndexed = malloc(sizeof(miIndexedRec));
    if (!pIndexed)
        return FALSE;

    pFormat->index.nvalues = num;
    pFormat->index.pValues = xallocarray(num, sizeof(xIndexValue));
    if (!pFormat->index.pValues) {
        free(pIndexed);
        return FALSE;
    }

    /*
     * Build mapping from pixel value to ARGB
     */
    QueryColors(pColormap, num, pixels, rgb, serverClient);
    for (i = 0; i < num; i++) {
        p = pixels[i];
        pFormat->index.pValues[i].pixel = p;
        pFormat->index.pValues[i].red = rgb[i].red;
        pFormat->index.pValues[i].green = rgb[i].green;
        pFormat->index.pValues[i].blue = rgb[i].blue;
        pFormat->index.pValues[i].alpha = 0xffff;
        pIndexed->rgba[p] = (0xff000000 |
                             ((rgb[i].red & 0xff00) << 8) |
                             ((rgb[i].green & 0xff00)) |
                             ((rgb[i].blue & 0xff00) >> 8));
    }

    /*
     * Build mapping from RGB to pixel value.  This could probably be
     * done a bit quicker...
     */
    switch (pVisual->class | DynamicClass) {
    case GrayScale:
        pIndexed->color = FALSE;
        for (r = 0; r < 32768; r++)
            pIndexed->ent[r] = FindBestGray(pIndexed, pixels, num, r);
        break;
    case PseudoColor:
        pIndexed->color = TRUE;
        p = 0;
        for (r = 0; r < 32; r++)
            for (g = 0; g < 32; g++)
                for (b = 0; b < 32; b++) {
                    pIndexed->ent[p] = FindBestColor(pIndexed, pixels, num,
                                                     r, g, b);
                    p++;
                }
        break;
    }
    pFormat->index.devPrivate = pIndexed;
    return TRUE;
}

void
miCloseIndexed(ScreenPtr pScreen, PictFormatPtr pFormat)
{
    free(pFormat->index.devPrivate);
    pFormat->index.devPrivate = NULL;
    free(pFormat->index.pValues);
    pFormat->index.pValues = NULL;
}

void
miUpdateIndexed(ScreenPtr pScreen,
                PictFormatPtr pFormat, int ndef, xColorItem * pdef)
{
    miIndexedPtr pIndexed = pFormat->index.devPrivate;

    if (pIndexed) {
        while (ndef--) {
            pIndexed->rgba[pdef->pixel] = (0xff000000 |
                                           ((pdef->red & 0xff00) << 8) |
                                           ((pdef->green & 0xff00)) |
                                           ((pdef->blue & 0xff00) >> 8));
            pdef++;
        }
    }
}

#endif                          /* _MIINDEX_H_ */
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d257 1
a257 1
    pFormat->index.pValues = malloc(num * sizeof(xIndexValue));
@


1.4
log
@Update to xserver 1.11.2
@
text
@d44 1
a44 1
miBuildRenderColormap (ColormapPtr  pColormap, Pixel *pixels, int *nump)
d46 25
a70 26
    int		r, g, b;
    unsigned short  red, green, blue;
    Pixel	pixel;
    Bool	used[MI_MAX_INDEXED];
    int		needed;
    int		policy;
    int		cube, gray;
    int		i, n;
    
    if (pColormap->mid != pColormap->pScreen->defColormap)
    {
	policy = PictureCmapPolicyAll;
    }
    else
    {
	int	avail = pColormap->pVisual->ColormapEntries;
	policy = PictureCmapPolicy;
	if (policy == PictureCmapPolicyDefault)
	{
	    if (avail >= 256 && (pColormap->pVisual->class|DynamicClass) == PseudoColor)
		policy = PictureCmapPolicyColor;
	    else if (avail >= 64)
		policy = PictureCmapPolicyGray;
	    else
		policy = PictureCmapPolicyMono;
	}
d75 21
a95 22
    for (;;)
    {
	switch (policy) {
	case PictureCmapPolicyAll:
	    needed = 0;
	    break;
	case PictureCmapPolicyColor:
	    needed = 71;
	    break;
	case PictureCmapPolicyGray:
	    needed = 11;
	    break;
	case PictureCmapPolicyMono:
	default:
	    needed = 0;
	    break;
	}
	if (needed <= pColormap->freeRed)
	    break;
	policy--;
    } 
    
d102 28
a129 29
	/*
	 * Allocate as big a cube as possible
	 */
	if ((pColormap->pVisual->class|DynamicClass) == PseudoColor)
	{
	    for (cube = 1; cube * cube * cube < pColormap->pVisual->ColormapEntries; cube++)
		;
	    cube--;
	    if (cube == 1)
		cube = 0;
	}
	else
	    cube = 0;
	/*
	 * Figure out how many gray levels to use so that they
	 * line up neatly with the cube
	 */
	if (cube)
	{
	    needed = pColormap->pVisual->ColormapEntries - (cube*cube*cube);
	    /* levels to fill in with */
	    gray = needed / (cube - 1);
	    /* total levels */
	    gray = (gray + 1) * (cube - 1) + 1;
	}
	else
	    gray = pColormap->pVisual->ColormapEntries;
	break;
		
d131 2
a132 2
	cube = NUM_CUBE_LEVELS;
	/* fall through ... */
d134 2
a135 2
	gray = NUM_GRAY_LEVELS;
	break;
d138 2
a139 2
	gray = 2;
	break;
d141 2
a142 2
    
    memset (used, '\0', pColormap->pVisual->ColormapEntries * sizeof (Bool));
d144 17
a160 19
	for (g = 0; g < cube; g++)
	    for (b = 0; b < cube; b++)
	    {
		pixel = 0;
		red = (r * 65535 + (cube-1)/2) / (cube - 1);
		green = (g * 65535 + (cube-1)/2) / (cube - 1);
		blue = (b * 65535 + (cube-1)/2) / (cube - 1);
		if (AllocColor (pColormap, &red, &green, 
				&blue, &pixel, 0) != Success)
		    return FALSE;
		used[pixel] = TRUE;
	    }
    for (g = 0; g < gray; g++)
    {
	pixel = 0;
	red = green = blue = (g * 65535 + (gray-1)/2) / (gray - 1);
	if (AllocColor (pColormap, &red, &green, &blue, &pixel, 0) != Success)
	    return FALSE;
	used[pixel] = TRUE;
d164 2
a165 2
	if (used[i])
	    pixels[n++] = i;
d168 1
a168 1
    
d174 2
a175 2
FindBestColor (miIndexedPtr pIndexed, Pixel *pixels, int num,
	       int red, int green, int blue)
d177 20
a196 21
    Pixel   best = pixels[0];
    int	    bestDist = 1 << 30;
    int	    dist;
    int	    dr, dg, db;
    while (num--)
    {
	Pixel	pixel = *pixels++;
	CARD32	v = pIndexed->rgba[pixel];

	dr = ((v >> 19) & 0x1f);
	dg = ((v >> 11) & 0x1f);
	db = ((v >> 3) & 0x1f);
	dr = dr - red;
	dg = dg - green;
	db = db - blue;
	dist = dr * dr + dg * dg + db * db;
	if (dist < bestDist)
	{
	    bestDist = dist;
	    best = pixel;
	}
d203 1
a203 1
FindBestGray (miIndexedPtr pIndexed, Pixel *pixels, int num, int gray)
d205 18
a222 20
    Pixel   best = pixels[0];
    int	    bestDist = 1 << 30;
    int	    dist;
    int	    dr;
    int	    r;
    
    while (num--)
    {
	Pixel   pixel = *pixels++;
	CARD32	v = pIndexed->rgba[pixel];

	r = v & 0xff;
	r = r | (r << 8);
	dr = gray - (r >> 1);
	dist = dr * dr;
	if (dist < bestDist)
	{
	    bestDist = dist;
	    best = pixel;
	}
d228 1
a228 2
miInitIndexed (ScreenPtr	pScreen,
	       PictFormatPtr	pFormat)
d230 8
a237 8
    ColormapPtr	    pColormap = pFormat->index.pColormap;
    VisualPtr	    pVisual = pColormap->pVisual;
    miIndexedPtr    pIndexed;
    Pixel	    pixels[MI_MAX_INDEXED];
    xrgb	    rgb[MI_MAX_INDEXED];
    int		    num;
    int		    i;
    Pixel	    p, r, g, b;
d240 10
a249 12
	return FALSE;
    
    if (pVisual->class & DynamicClass)
    {
	if (!miBuildRenderColormap (pColormap, pixels, &num))
	    return FALSE;
    }
    else
    {
	num = pVisual->ColormapEntries;
	for (p = 0; p < num; p++)
	    pixels[p] = p;
d251 2
a252 2
    
    pIndexed = malloc(sizeof (miIndexedRec));
d254 2
a255 2
	return FALSE;
    
d257 4
a260 5
    pFormat->index.pValues = malloc(num * sizeof (xIndexValue));
    if (!pFormat->index.pValues)
    {
	free(pIndexed);
	return FALSE;
d262 1
a262 2
    
    
d266 12
a277 13
    QueryColors (pColormap, num, pixels, rgb, serverClient);
    for (i = 0; i < num; i++)
    {
	p = pixels[i];
	pFormat->index.pValues[i].pixel = p;
	pFormat->index.pValues[i].red   = rgb[i].red;
	pFormat->index.pValues[i].green = rgb[i].green;
	pFormat->index.pValues[i].blue  = rgb[i].blue;
	pFormat->index.pValues[i].alpha = 0xffff;
	pIndexed->rgba[p] = (0xff000000 |
			     ((rgb[i].red   & 0xff00) << 8) |
			     ((rgb[i].green & 0xff00)     ) |
			     ((rgb[i].blue  & 0xff00) >> 8));
d286 4
a289 4
	pIndexed->color = FALSE;
	for (r = 0; r < 32768; r++)
	    pIndexed->ent[r] = FindBestGray (pIndexed, pixels, num, r);
	break;
d291 10
a300 11
	pIndexed->color = TRUE;
	p = 0;
	for (r = 0; r < 32; r++)
	    for (g = 0; g < 32; g++)
		for (b = 0; b < 32; b++)
		{
		    pIndexed->ent[p] = FindBestColor (pIndexed, pixels, num,
						      r, g, b);
		    p++;
		}
	break;
d307 1
a307 2
miCloseIndexed (ScreenPtr	pScreen,
		PictFormatPtr	pFormat)
d316 2
a317 4
miUpdateIndexed (ScreenPtr	pScreen,
		 PictFormatPtr	pFormat,
		 int		ndef,
		 xColorItem	*pdef)
d321 8
a328 10
    if (pIndexed)
    {
	while (ndef--)
	{
	    pIndexed->rgba[pdef->pixel] = (0xff000000 |
					   ((pdef->red   & 0xff00) << 8) |
					   ((pdef->green & 0xff00)     ) |
					   ((pdef->blue  & 0xff00) >> 8));
	    pdef++;
	}
d332 1
a332 1
#endif /* _MIINDEX_H_ */
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d325 4
a328 10
    if (pFormat->index.devPrivate)
    {
	free(pFormat->index.devPrivate);
	pFormat->index.devPrivate = 0;
    }
    if (pFormat->index.pValues)
    {
	free(pFormat->index.pValues);
	pFormat->index.pValues = 0;
    }
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d263 1
a263 1
    pIndexed = xalloc (sizeof (miIndexedRec));
d268 1
a268 1
    pFormat->index.pValues = xalloc (num * sizeof (xIndexValue));
d271 1
a271 1
	xfree (pIndexed);
d279 1
a279 1
    QueryColors (pColormap, num, pixels, rgb);
d327 1
a327 1
	xfree (pFormat->index.devPrivate);
d332 1
a332 1
	xfree (pFormat->index.pValues);
@


1.1
log
@Initial revision
@
text
@d150 1
d161 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
