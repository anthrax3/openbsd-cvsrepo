head	1.11;
access;
symbols
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.33;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.11.15.39.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.21;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.21;	author matthieu;	state Exp;
branches
	1.1.1.1.2.1;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.16;	author matthieu;	state Exp;
branches
	1.1.1.2.2.1;
next	;

1.1.1.2.2.1
date	2008.07.13.03.08.30;	author brad;	state Exp;
branches;
next	;

1.1.1.1.2.1
date	2008.07.13.03.11.28;	author brad;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *
 * Copyright Â© 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xsha1.h"

#include "misc.h"
#include "scrnintstr.h"
#include "os.h"
#include "regionstr.h"
#include "validate.h"
#include "windowstr.h"
#include "input.h"
#include "resource.h"
#include "colormapst.h"
#include "cursorstr.h"
#include "dixstruct.h"
#include "gcstruct.h"
#include "servermd.h"
#include "picturestr.h"
#include "glyphstr.h"
#include "mipict.h"

/*
 * From Knuth -- a good choice for hash/rehash values is p, p-2 where
 * p and p-2 are both prime.  These tables are sized to have an extra 10%
 * free to avoid exponential performance degradation as the hash table fills
 */
static GlyphHashSetRec glyphHashSets[] = {
    {32, 43, 41},
    {64, 73, 71},
    {128, 151, 149},
    {256, 283, 281},
    {512, 571, 569},
    {1024, 1153, 1151},
    {2048, 2269, 2267},
    {4096, 4519, 4517},
    {8192, 9013, 9011},
    {16384, 18043, 18041},
    {32768, 36109, 36107},
    {65536, 72091, 72089},
    {131072, 144409, 144407},
    {262144, 288361, 288359},
    {524288, 576883, 576881},
    {1048576, 1153459, 1153457},
    {2097152, 2307163, 2307161},
    {4194304, 4613893, 4613891},
    {8388608, 9227641, 9227639},
    {16777216, 18455029, 18455027},
    {33554432, 36911011, 36911009},
    {67108864, 73819861, 73819859},
    {134217728, 147639589, 147639587},
    {268435456, 295279081, 295279079},
    {536870912, 590559793, 590559791}
};

#define NGLYPHHASHSETS	(sizeof(glyphHashSets)/sizeof(glyphHashSets[0]))

static GlyphHashRec globalGlyphs[GlyphFormatNum];

void
GlyphUninit(ScreenPtr pScreen)
{
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    GlyphPtr glyph;
    int fdepth, i;

    for (fdepth = 0; fdepth < GlyphFormatNum; fdepth++) {
        if (!globalGlyphs[fdepth].hashSet)
            continue;

        for (i = 0; i < globalGlyphs[fdepth].hashSet->size; i++) {
            glyph = globalGlyphs[fdepth].table[i].glyph;
            if (glyph && glyph != DeletedGlyph) {
                if (GetGlyphPicture(glyph, pScreen)) {
                    FreePicture((void *) GetGlyphPicture(glyph, pScreen), 0);
                    SetGlyphPicture(glyph, pScreen, NULL);
                }
                (*ps->UnrealizeGlyph) (pScreen, glyph);
            }
        }
    }
}

static GlyphHashSetPtr
FindGlyphHashSet(CARD32 filled)
{
    int i;

    for (i = 0; i < NGLYPHHASHSETS; i++)
        if (glyphHashSets[i].entries >= filled)
            return &glyphHashSets[i];
    return 0;
}

static GlyphRefPtr
FindGlyphRef(GlyphHashPtr hash,
             CARD32 signature, Bool match, unsigned char sha1[20])
{
    CARD32 elt, step, s;
    GlyphPtr glyph;
    GlyphRefPtr table, gr, del;
    CARD32 tableSize = hash->hashSet->size;

    table = hash->table;
    elt = signature % tableSize;
    step = 0;
    del = 0;
    for (;;) {
        gr = &table[elt];
        s = gr->signature;
        glyph = gr->glyph;
        if (!glyph) {
            if (del)
                gr = del;
            break;
        }
        if (glyph == DeletedGlyph) {
            if (!del)
                del = gr;
            else if (gr == del)
                break;
        }
        else if (s == signature &&
                 (!match || memcmp(glyph->sha1, sha1, 20) == 0)) {
            break;
        }
        if (!step) {
            step = signature % hash->hashSet->rehash;
            if (!step)
                step = 1;
        }
        elt += step;
        if (elt >= tableSize)
            elt -= tableSize;
    }
    return gr;
}

int
HashGlyph(xGlyphInfo * gi,
          CARD8 *bits, unsigned long size, unsigned char sha1[20])
{
    void *ctx = x_sha1_init();
    int success;

    if (!ctx)
        return BadAlloc;

    success = x_sha1_update(ctx, gi, sizeof(xGlyphInfo));
    if (!success)
        return BadAlloc;
    success = x_sha1_update(ctx, bits, size);
    if (!success)
        return BadAlloc;
    success = x_sha1_final(ctx, sha1);
    if (!success)
        return BadAlloc;
    return Success;
}

GlyphPtr
FindGlyphByHash(unsigned char sha1[20], int format)
{
    GlyphRefPtr gr;
    CARD32 signature = *(CARD32 *) sha1;

    if (!globalGlyphs[format].hashSet)
        return NULL;

    gr = FindGlyphRef(&globalGlyphs[format], signature, TRUE, sha1);

    if (gr->glyph && gr->glyph != DeletedGlyph)
        return gr->glyph;
    else
        return NULL;
}

#ifdef CHECK_DUPLICATES
void
DuplicateRef(GlyphPtr glyph, char *where)
{
    ErrorF("Duplicate Glyph 0x%x from %s\n", glyph, where);
}

void
CheckDuplicates(GlyphHashPtr hash, char *where)
{
    GlyphPtr g;
    int i, j;

    for (i = 0; i < hash->hashSet->size; i++) {
        g = hash->table[i].glyph;
        if (!g || g == DeletedGlyph)
            continue;
        for (j = i + 1; j < hash->hashSet->size; j++)
            if (hash->table[j].glyph == g)
                DuplicateRef(g, where);
    }
}
#else
#define CheckDuplicates(a,b)
#define DuplicateRef(a,b)
#endif

static void
FreeGlyphPicture(GlyphPtr glyph)
{
    PictureScreenPtr ps;
    int i;

    for (i = 0; i < screenInfo.numScreens; i++) {
        ScreenPtr pScreen = screenInfo.screens[i];

        if (GetGlyphPicture(glyph, pScreen))
            FreePicture((void *) GetGlyphPicture(glyph, pScreen), 0);

        ps = GetPictureScreenIfSet(pScreen);
        if (ps)
            (*ps->UnrealizeGlyph) (pScreen, glyph);
    }
}

static void
FreeGlyph(GlyphPtr glyph, int format)
{
    CheckDuplicates(&globalGlyphs[format], "FreeGlyph");
    if (--glyph->refcnt == 0) {
        GlyphRefPtr gr;
        int i;
        int first;
        CARD32 signature;

        first = -1;
        for (i = 0; i < globalGlyphs[format].hashSet->size; i++)
            if (globalGlyphs[format].table[i].glyph == glyph) {
                if (first != -1)
                    DuplicateRef(glyph, "FreeGlyph check");
                first = i;
            }

        signature = *(CARD32 *) glyph->sha1;
        gr = FindGlyphRef(&globalGlyphs[format], signature, TRUE, glyph->sha1);
        if (gr - globalGlyphs[format].table != first)
            DuplicateRef(glyph, "Found wrong one");
        if (gr->glyph && gr->glyph != DeletedGlyph) {
            gr->glyph = DeletedGlyph;
            gr->signature = 0;
            globalGlyphs[format].tableEntries--;
        }

        FreeGlyphPicture(glyph);
        dixFreeObjectWithPrivates(glyph, PRIVATE_GLYPH);
    }
}

void
AddGlyph(GlyphSetPtr glyphSet, GlyphPtr glyph, Glyph id)
{
    GlyphRefPtr gr;
    CARD32 signature;

    CheckDuplicates(&globalGlyphs[glyphSet->fdepth], "AddGlyph top global");
    /* Locate existing matching glyph */
    signature = *(CARD32 *) glyph->sha1;
    gr = FindGlyphRef(&globalGlyphs[glyphSet->fdepth], signature,
                      TRUE, glyph->sha1);
    if (gr->glyph && gr->glyph != DeletedGlyph && gr->glyph != glyph) {
        FreeGlyphPicture(glyph);
        dixFreeObjectWithPrivates(glyph, PRIVATE_GLYPH);
        glyph = gr->glyph;
    }
    else if (gr->glyph != glyph) {
        gr->glyph = glyph;
        gr->signature = signature;
        globalGlyphs[glyphSet->fdepth].tableEntries++;
    }

    /* Insert/replace glyphset value */
    gr = FindGlyphRef(&glyphSet->hash, id, FALSE, 0);
    ++glyph->refcnt;
    if (gr->glyph && gr->glyph != DeletedGlyph)
        FreeGlyph(gr->glyph, glyphSet->fdepth);
    else
        glyphSet->hash.tableEntries++;
    gr->glyph = glyph;
    gr->signature = id;
    CheckDuplicates(&globalGlyphs[glyphSet->fdepth], "AddGlyph bottom");
}

Bool
DeleteGlyph(GlyphSetPtr glyphSet, Glyph id)
{
    GlyphRefPtr gr;
    GlyphPtr glyph;

    gr = FindGlyphRef(&glyphSet->hash, id, FALSE, 0);
    glyph = gr->glyph;
    if (glyph && glyph != DeletedGlyph) {
        gr->glyph = DeletedGlyph;
        glyphSet->hash.tableEntries--;
        FreeGlyph(glyph, glyphSet->fdepth);
        return TRUE;
    }
    return FALSE;
}

GlyphPtr
FindGlyph(GlyphSetPtr glyphSet, Glyph id)
{
    GlyphPtr glyph;

    glyph = FindGlyphRef(&glyphSet->hash, id, FALSE, 0)->glyph;
    if (glyph == DeletedGlyph)
        glyph = 0;
    return glyph;
}

GlyphPtr
AllocateGlyph(xGlyphInfo * gi, int fdepth)
{
    PictureScreenPtr ps;
    int size;
    GlyphPtr glyph;
    int i;
    int head_size;

    head_size = sizeof(GlyphRec) + screenInfo.numScreens * sizeof(PicturePtr);
    size = (head_size + dixPrivatesSize(PRIVATE_GLYPH));
    glyph = (GlyphPtr) malloc(size);
    if (!glyph)
        return 0;
    glyph->refcnt = 0;
    glyph->size = size + sizeof(xGlyphInfo);
    glyph->info = *gi;
    dixInitPrivates(glyph, (char *) glyph + head_size, PRIVATE_GLYPH);

    for (i = 0; i < screenInfo.numScreens; i++) {
        ScreenPtr pScreen = screenInfo.screens[i];
        SetGlyphPicture(glyph, pScreen, NULL);
        ps = GetPictureScreenIfSet(pScreen);

        if (ps) {
            if (!(*ps->RealizeGlyph) (pScreen, glyph))
                goto bail;
        }
    }

    return glyph;

 bail:
    while (i--) {
        ps = GetPictureScreenIfSet(screenInfo.screens[i]);
        if (ps)
            (*ps->UnrealizeGlyph) (screenInfo.screens[i], glyph);
    }

    dixFreeObjectWithPrivates(glyph, PRIVATE_GLYPH);
    return 0;
}

static Bool
AllocateGlyphHash(GlyphHashPtr hash, GlyphHashSetPtr hashSet)
{
    hash->table = calloc(hashSet->size, sizeof(GlyphRefRec));
    if (!hash->table)
        return FALSE;
    hash->hashSet = hashSet;
    hash->tableEntries = 0;
    return TRUE;
}

static Bool
ResizeGlyphHash(GlyphHashPtr hash, CARD32 change, Bool global)
{
    CARD32 tableEntries;
    GlyphHashSetPtr hashSet;
    GlyphHashRec newHash;
    GlyphRefPtr gr;
    GlyphPtr glyph;
    int i;
    int oldSize;
    CARD32 s;

    tableEntries = hash->tableEntries + change;
    hashSet = FindGlyphHashSet(tableEntries);
    if (hashSet == hash->hashSet)
        return TRUE;
    if (global)
        CheckDuplicates(hash, "ResizeGlyphHash top");
    if (!AllocateGlyphHash(&newHash, hashSet))
        return FALSE;
    if (hash->table) {
        oldSize = hash->hashSet->size;
        for (i = 0; i < oldSize; i++) {
            glyph = hash->table[i].glyph;
            if (glyph && glyph != DeletedGlyph) {
                s = hash->table[i].signature;
                gr = FindGlyphRef(&newHash, s, global, glyph->sha1);

                gr->signature = s;
                gr->glyph = glyph;
                ++newHash.tableEntries;
            }
        }
        free(hash->table);
    }
    *hash = newHash;
    if (global)
        CheckDuplicates(hash, "ResizeGlyphHash bottom");
    return TRUE;
}

Bool
ResizeGlyphSet(GlyphSetPtr glyphSet, CARD32 change)
{
    return (ResizeGlyphHash(&glyphSet->hash, change, FALSE) &&
            ResizeGlyphHash(&globalGlyphs[glyphSet->fdepth], change, TRUE));
}

GlyphSetPtr
AllocateGlyphSet(int fdepth, PictFormatPtr format)
{
    GlyphSetPtr glyphSet;

    if (!globalGlyphs[fdepth].hashSet) {
        if (!AllocateGlyphHash(&globalGlyphs[fdepth], &glyphHashSets[0]))
            return FALSE;
    }

    glyphSet = dixAllocateObjectWithPrivates(GlyphSetRec, PRIVATE_GLYPHSET);
    if (!glyphSet)
        return FALSE;

    if (!AllocateGlyphHash(&glyphSet->hash, &glyphHashSets[0])) {
        free(glyphSet);
        return FALSE;
    }
    glyphSet->refcnt = 1;
    glyphSet->fdepth = fdepth;
    glyphSet->format = format;
    return glyphSet;
}

int
FreeGlyphSet(void *value, XID gid)
{
    GlyphSetPtr glyphSet = (GlyphSetPtr) value;

    if (--glyphSet->refcnt == 0) {
        CARD32 i, tableSize = glyphSet->hash.hashSet->size;
        GlyphRefPtr table = glyphSet->hash.table;
        GlyphPtr glyph;

        for (i = 0; i < tableSize; i++) {
            glyph = table[i].glyph;
            if (glyph && glyph != DeletedGlyph)
                FreeGlyph(glyph, glyphSet->fdepth);
        }
        if (!globalGlyphs[glyphSet->fdepth].tableEntries) {
            free(globalGlyphs[glyphSet->fdepth].table);
            globalGlyphs[glyphSet->fdepth].table = 0;
            globalGlyphs[glyphSet->fdepth].hashSet = 0;
        }
        else
            ResizeGlyphHash(&globalGlyphs[glyphSet->fdepth], 0, TRUE);
        free(table);
        dixFreeObjectWithPrivates(glyphSet, PRIVATE_GLYPHSET);
    }
    return Success;
}

static void
GlyphExtents(int nlist, GlyphListPtr list, GlyphPtr * glyphs, BoxPtr extents)
{
    int x1, x2, y1, y2;
    int n;
    GlyphPtr glyph;
    int x, y;

    x = 0;
    y = 0;
    extents->x1 = MAXSHORT;
    extents->x2 = MINSHORT;
    extents->y1 = MAXSHORT;
    extents->y2 = MINSHORT;
    while (nlist--) {
        x += list->xOff;
        y += list->yOff;
        n = list->len;
        list++;
        while (n--) {
            glyph = *glyphs++;
            x1 = x - glyph->info.x;
            if (x1 < MINSHORT)
                x1 = MINSHORT;
            y1 = y - glyph->info.y;
            if (y1 < MINSHORT)
                y1 = MINSHORT;
            x2 = x1 + glyph->info.width;
            if (x2 > MAXSHORT)
                x2 = MAXSHORT;
            y2 = y1 + glyph->info.height;
            if (y2 > MAXSHORT)
                y2 = MAXSHORT;
            if (x1 < extents->x1)
                extents->x1 = x1;
            if (x2 > extents->x2)
                extents->x2 = x2;
            if (y1 < extents->y1)
                extents->y1 = y1;
            if (y2 > extents->y2)
                extents->y2 = y2;
            x += glyph->info.xOff;
            y += glyph->info.yOff;
        }
    }
}

#define NeedsComponent(f) (PICT_FORMAT_A(f) != 0 && PICT_FORMAT_RGB(f) != 0)

void
CompositeGlyphs(CARD8 op,
                PicturePtr pSrc,
                PicturePtr pDst,
                PictFormatPtr maskFormat,
                INT16 xSrc,
                INT16 ySrc, int nlist, GlyphListPtr lists, GlyphPtr * glyphs)
{
    PictureScreenPtr ps = GetPictureScreen(pDst->pDrawable->pScreen);

    ValidatePicture(pSrc);
    ValidatePicture(pDst);
    (*ps->Glyphs) (op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, lists,
                   glyphs);
}

Bool
miRealizeGlyph(ScreenPtr pScreen, GlyphPtr glyph)
{
    return TRUE;
}

void
miUnrealizeGlyph(ScreenPtr pScreen, GlyphPtr glyph)
{
}

void
miGlyphs(CARD8 op,
         PicturePtr pSrc,
         PicturePtr pDst,
         PictFormatPtr maskFormat,
         INT16 xSrc,
         INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs)
{
    PicturePtr pPicture;
    PixmapPtr pMaskPixmap = 0;
    PicturePtr pMask;
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    int width = 0, height = 0;
    int x, y;
    int xDst = list->xOff, yDst = list->yOff;
    int n;
    GlyphPtr glyph;
    int error;
    BoxRec extents = { 0, 0, 0, 0 };
    CARD32 component_alpha;

    if (maskFormat) {
        GCPtr pGC;
        xRectangle rect;

        GlyphExtents(nlist, list, glyphs, &extents);

        if (extents.x2 <= extents.x1 || extents.y2 <= extents.y1)
            return;
        width = extents.x2 - extents.x1;
        height = extents.y2 - extents.y1;
        pMaskPixmap = (*pScreen->CreatePixmap) (pScreen, width, height,
                                                maskFormat->depth,
                                                CREATE_PIXMAP_USAGE_SCRATCH);
        if (!pMaskPixmap)
            return;
        component_alpha = NeedsComponent(maskFormat->format);
        pMask = CreatePicture(0, &pMaskPixmap->drawable,
                              maskFormat, CPComponentAlpha, &component_alpha,
                              serverClient, &error);
        if (!pMask) {
            (*pScreen->DestroyPixmap) (pMaskPixmap);
            return;
        }
        pGC = GetScratchGC(pMaskPixmap->drawable.depth, pScreen);
        ValidateGC(&pMaskPixmap->drawable, pGC);
        rect.x = 0;
        rect.y = 0;
        rect.width = width;
        rect.height = height;
        (*pGC->ops->PolyFillRect) (&pMaskPixmap->drawable, pGC, 1, &rect);
        FreeScratchGC(pGC);
        x = -extents.x1;
        y = -extents.y1;
    }
    else {
        pMask = pDst;
        x = 0;
        y = 0;
    }
    while (nlist--) {
        x += list->xOff;
        y += list->yOff;
        n = list->len;
        while (n--) {
            glyph = *glyphs++;
            pPicture = GetGlyphPicture(glyph, pScreen);

            if (pPicture) {
                if (maskFormat) {
                    CompositePicture(PictOpAdd,
                                     pPicture,
                                     None,
                                     pMask,
                                     0, 0,
                                     0, 0,
                                     x - glyph->info.x,
                                     y - glyph->info.y,
                                     glyph->info.width, glyph->info.height);
                }
                else {
                    CompositePicture(op,
                                     pSrc,
                                     pPicture,
                                     pDst,
                                     xSrc + (x - glyph->info.x) - xDst,
                                     ySrc + (y - glyph->info.y) - yDst,
                                     0, 0,
                                     x - glyph->info.x,
                                     y - glyph->info.y,
                                     glyph->info.width, glyph->info.height);
                }
            }

            x += glyph->info.xOff;
            y += glyph->info.yOff;
        }
        list++;
    }
    if (maskFormat) {
        x = extents.x1;
        y = extents.y1;
        CompositePicture(op,
                         pSrc,
                         pMask,
                         pDst,
                         xSrc + x - xDst,
                         ySrc + y - yDst, 0, 0, x, y, width, height);
        FreePicture((void *) pMask, (XID) 0);
        (*pScreen->DestroyPixmap) (pMaskPixmap);
    }
}

PicturePtr GetGlyphPicture(GlyphPtr glyph, ScreenPtr pScreen)
{
    if (pScreen->isGPU)
        return NULL;
    return GlyphPicture(glyph)[pScreen->myNum];
}

void SetGlyphPicture(GlyphPtr glyph, ScreenPtr pScreen, PicturePtr picture)
{
    GlyphPicture(glyph)[pScreen->myNum] = picture;
}
@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d109 1
a109 1
GlyphHashSetPtr
d120 1
a120 1
GlyphRefPtr
d248 1
a248 1
void
d386 1
a386 1
Bool
d397 1
a397 1
Bool
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d19 1
a19 1
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d100 1
a100 1
                    FreePicture((pointer) GetGlyphPicture(glyph, pScreen), 0);
d240 1
a240 1
            FreePicture((pointer) GetGlyphPicture(glyph, pScreen), 0);
d470 1
a470 1
FreeGlyphSet(pointer value, XID gid)
d681 1
a681 1
        FreePicture((pointer) pMask, (XID) 0);
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a82 2
static const CARD8 glyphDepths[GlyphFormatNum] = { 1, 4, 8, 16, 32 };

a90 1
    int scrno = pScreen->myNum;
d99 3
a101 3
                if (GlyphPicture(glyph)[scrno]) {
                    FreePicture((pointer) GlyphPicture(glyph)[scrno], 0);
                    GlyphPicture(glyph)[scrno] = NULL;
d239 2
a240 2
        if (GlyphPicture(glyph)[i])
            FreePicture((pointer) GlyphPicture(glyph)[i], 0);
d363 3
a365 2
        GlyphPicture(glyph)[i] = NULL;
        ps = GetPictureScreenIfSet(screenInfo.screens[i]);
d368 1
a368 1
            if (!(*ps->RealizeGlyph) (screenInfo.screens[i], glyph))
d639 1
a639 1
            pPicture = GlyphPicture(glyph)[pScreen->myNum];
d684 12
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d54 25
a78 25
    { 32,		43,		41        },
    { 64,		73,		71        },
    { 128,		151,		149       },
    { 256,		283,		281       },
    { 512,		571,		569       },
    { 1024,		1153,		1151      },
    { 2048,		2269,		2267      },
    { 4096,		4519,		4517      },
    { 8192,		9013,		9011      },
    { 16384,		18043,		18041     },
    { 32768,		36109,		36107     },
    { 65536,		72091,		72089     },
    { 131072,		144409,		144407    },
    { 262144,		288361,		288359    },
    { 524288,		576883,		576881    },
    { 1048576,		1153459,	1153457   },
    { 2097152,		2307163,	2307161   },
    { 4194304,		4613893,	4613891   },
    { 8388608,		9227641,	9227639   },
    { 16777216,		18455029,	18455027  },
    { 33554432,		36911011,	36911009  },
    { 67108864,		73819861,	73819859  },
    { 134217728,	147639589,	147639587 },
    { 268435456,	295279081,	295279079 },
    { 536870912,	590559793,	590559791 }
d83 1
a83 1
static const CARD8	glyphDepths[GlyphFormatNum] = { 1, 4, 8, 16, 32 };
d85 1
a85 1
static GlyphHashRec	globalGlyphs[GlyphFormatNum];
d88 1
a88 1
GlyphUninit (ScreenPtr pScreen)
d90 19
a108 23
    PictureScreenPtr ps = GetPictureScreen (pScreen);
    GlyphPtr	     glyph;
    int		     fdepth, i;
    int		     scrno = pScreen->myNum;

    for (fdepth = 0; fdepth < GlyphFormatNum; fdepth++)
    {
	if (!globalGlyphs[fdepth].hashSet)
	    continue;
	
	for (i = 0; i < globalGlyphs[fdepth].hashSet->size; i++)
	{
	    glyph = globalGlyphs[fdepth].table[i].glyph;
	    if (glyph && glyph != DeletedGlyph)
	    {
		if (GlyphPicture(glyph)[scrno])
		{
		    FreePicture ((pointer) GlyphPicture (glyph)[scrno], 0);
		    GlyphPicture(glyph)[scrno] = NULL;
		}
		(*ps->UnrealizeGlyph) (pScreen, glyph);
	    }
	}
d113 1
a113 1
FindGlyphHashSet (CARD32 filled)
d115 1
a115 1
    int	i;
d118 2
a119 2
	if (glyphHashSets[i].entries >= filled)
	    return &glyphHashSets[i];
d124 7
a130 9
FindGlyphRef (GlyphHashPtr	hash,
	      CARD32		signature,
	      Bool		match,
	      unsigned char	sha1[20])
{
    CARD32	elt, step, s;
    GlyphPtr	glyph;
    GlyphRefPtr	table, gr, del;
    CARD32	tableSize = hash->hashSet->size;
d136 27
a162 33
    for (;;)
    {
	gr = &table[elt];
	s = gr->signature;
	glyph = gr->glyph;
	if (!glyph)
	{
	    if (del)
		gr = del;
	    break;
	}
	if (glyph == DeletedGlyph)
	{
	    if (!del)
		del = gr;
	    else if (gr == del)
		break;
	}
	else if (s == signature &&
		 (!match || 
		  memcmp (glyph->sha1, sha1, 20) == 0))
	{
	    break;
	}
	if (!step)
	{
	    step = signature % hash->hashSet->rehash;
	    if (!step)
		step = 1;
	}
	elt += step;
	if (elt >= tableSize)
	    elt -= tableSize;
d168 2
a169 4
HashGlyph (xGlyphInfo    *gi,
	   CARD8	 *bits,
	   unsigned long size,
	   unsigned char sha1[20])
d175 1
a175 1
	return BadAlloc;
d179 1
a179 1
	return BadAlloc;
d182 1
a182 1
	return BadAlloc;
d185 1
a185 1
	return BadAlloc;
d190 1
a190 1
FindGlyphByHash (unsigned char sha1[20], int format)
d196 1
a196 1
	return NULL;
d198 1
a198 2
    gr = FindGlyphRef (&globalGlyphs[format],
		       signature, TRUE, sha1);
d201 1
a201 1
	return gr->glyph;
d203 1
a203 1
	return NULL;
d208 1
a208 1
DuplicateRef (GlyphPtr glyph, char *where)
d210 1
a210 1
    ErrorF ("Duplicate Glyph 0x%x from %s\n", glyph, where);
d214 1
a214 1
CheckDuplicates (GlyphHashPtr hash, char *where)
d216 2
a217 2
    GlyphPtr	g;
    int		i, j;
d219 7
a225 8
    for (i = 0; i < hash->hashSet->size; i++)
    {
	g = hash->table[i].glyph;
	if (!g || g == DeletedGlyph)
	    continue;
	for (j = i + 1; j < hash->hashSet->size; j++)
	    if (hash->table[j].glyph == g)
		DuplicateRef (g, where);
d239 1
a239 2
    for (i = 0; i < screenInfo.numScreens; i++)
    {
d243 1
a243 1
            FreePicture ((pointer) GlyphPicture (glyph)[i], 0);
d245 1
a245 1
        ps = GetPictureScreenIfSet (pScreen);
a250 1

d252 1
a252 1
FreeGlyph (GlyphPtr glyph, int format)
d254 24
a277 28
    CheckDuplicates (&globalGlyphs[format], "FreeGlyph");
    if (--glyph->refcnt == 0)
    {
	GlyphRefPtr      gr;
	int	         i;
	int	         first;
	CARD32		 signature;

	first = -1;
	for (i = 0; i < globalGlyphs[format].hashSet->size; i++)
	    if (globalGlyphs[format].table[i].glyph == glyph)
	    {
		if (first != -1)
		    DuplicateRef (glyph, "FreeGlyph check");
		first = i;
	    }

	signature = *(CARD32 *) glyph->sha1;
	gr = FindGlyphRef (&globalGlyphs[format], signature,
			   TRUE, glyph->sha1);
	if (gr - globalGlyphs[format].table != first)
	    DuplicateRef (glyph, "Found wrong one");
	if (gr->glyph && gr->glyph != DeletedGlyph)
	{
	    gr->glyph = DeletedGlyph;
	    gr->signature = 0;
	    globalGlyphs[format].tableEntries--;
	}
d279 2
a280 2
	FreeGlyphPicture(glyph);
	dixFreeObjectWithPrivates(glyph, PRIVATE_GLYPH);
d285 1
a285 1
AddGlyph (GlyphSetPtr glyphSet, GlyphPtr glyph, Glyph id)
d287 2
a288 2
    GlyphRefPtr	    gr;
    CARD32	    signature;
d290 1
a290 1
    CheckDuplicates (&globalGlyphs[glyphSet->fdepth], "AddGlyph top global");
d293 11
a303 13
    gr = FindGlyphRef (&globalGlyphs[glyphSet->fdepth], signature,
		       TRUE, glyph->sha1);
    if (gr->glyph && gr->glyph != DeletedGlyph && gr->glyph != glyph)
    {
	FreeGlyphPicture(glyph);
	dixFreeObjectWithPrivates(glyph, PRIVATE_GLYPH);
	glyph = gr->glyph;
    }
    else if (gr->glyph != glyph)
    {
	gr->glyph = glyph;
	gr->signature = signature;
	globalGlyphs[glyphSet->fdepth].tableEntries++;
d305 1
a305 1
    
d307 1
a307 1
    gr = FindGlyphRef (&glyphSet->hash, id, FALSE, 0);
d310 1
a310 1
	FreeGlyph (gr->glyph, glyphSet->fdepth);
d312 1
a312 1
	glyphSet->hash.tableEntries++;
d315 1
a315 1
    CheckDuplicates (&globalGlyphs[glyphSet->fdepth], "AddGlyph bottom");
d319 1
a319 1
DeleteGlyph (GlyphSetPtr glyphSet, Glyph id)
d321 2
a322 2
    GlyphRefPtr     gr;
    GlyphPtr	    glyph;
d324 1
a324 1
    gr = FindGlyphRef (&glyphSet->hash, id, FALSE, 0);
d326 5
a330 6
    if (glyph && glyph != DeletedGlyph)
    {
	gr->glyph = DeletedGlyph;
	glyphSet->hash.tableEntries--;
	FreeGlyph (glyph, glyphSet->fdepth);
	return TRUE;
d336 1
a336 1
FindGlyph (GlyphSetPtr glyphSet, Glyph id)
d338 1
a338 1
    GlyphPtr        glyph;
d340 1
a340 1
    glyph = FindGlyphRef (&glyphSet->hash, id, FALSE, 0)->glyph;
d342 1
a342 1
	glyph = 0;
d347 1
a347 1
AllocateGlyph (xGlyphInfo *gi, int fdepth)
d350 4
a353 4
    int		     size;
    GlyphPtr	     glyph;
    int		     i;
    int		     head_size;
d355 1
a355 1
    head_size = sizeof (GlyphRec) + screenInfo.numScreens * sizeof (PicturePtr);
d357 1
a357 1
    glyph = (GlyphPtr) malloc (size);
d359 1
a359 1
	return 0;
d361 1
a361 1
    glyph->size = size + sizeof (xGlyphInfo);
d365 8
a372 10
    for (i = 0; i < screenInfo.numScreens; i++)
    {
	GlyphPicture(glyph)[i] = NULL;
	ps = GetPictureScreenIfSet (screenInfo.screens[i]);

	if (ps)
	{
	    if (!(*ps->RealizeGlyph) (screenInfo.screens[i], glyph))
		goto bail;
	}
d374 1
a374 1
    
d377 5
a381 6
bail:
    while (i--)
    {
	ps = GetPictureScreenIfSet (screenInfo.screens[i]);
	if (ps)
	    (*ps->UnrealizeGlyph) (screenInfo.screens[i], glyph);
d387 1
a387 1
    
d389 1
a389 1
AllocateGlyphHash (GlyphHashPtr hash, GlyphHashSetPtr hashSet)
d391 1
a391 1
    hash->table = calloc(hashSet->size, sizeof (GlyphRefRec));
d393 1
a393 1
	return FALSE;
d400 1
a400 1
ResizeGlyphHash (GlyphHashPtr hash, CARD32 change, Bool global)
d402 1
a402 1
    CARD32	    tableEntries;
d404 6
a409 6
    GlyphHashRec    newHash;
    GlyphRefPtr	    gr;
    GlyphPtr	    glyph;
    int		    i;
    int		    oldSize;
    CARD32	    s;
d412 1
a412 1
    hashSet = FindGlyphHashSet (tableEntries);
d414 1
a414 1
	return TRUE;
d416 17
a432 19
	CheckDuplicates (hash, "ResizeGlyphHash top");
    if (!AllocateGlyphHash (&newHash, hashSet))
	return FALSE;
    if (hash->table)
    {
	oldSize = hash->hashSet->size;
	for (i = 0; i < oldSize; i++)
	{
	    glyph = hash->table[i].glyph;
	    if (glyph && glyph != DeletedGlyph)
	    {
		s = hash->table[i].signature;
		gr = FindGlyphRef (&newHash, s, global, glyph->sha1);
		gr->signature = s;
		gr->glyph = glyph;
		++newHash.tableEntries;
	    }
	}
	free(hash->table);
d436 1
a436 1
	CheckDuplicates (hash, "ResizeGlyphHash bottom");
d441 1
a441 1
ResizeGlyphSet (GlyphSetPtr glyphSet, CARD32 change)
d443 2
a444 2
    return (ResizeGlyphHash (&glyphSet->hash, change, FALSE) &&
	    ResizeGlyphHash (&globalGlyphs[glyphSet->fdepth], change, TRUE));
d446 1
a446 1
			    
d448 1
a448 1
AllocateGlyphSet (int fdepth, PictFormatPtr format)
d450 5
a454 6
    GlyphSetPtr	glyphSet;
    
    if (!globalGlyphs[fdepth].hashSet)
    {
	if (!AllocateGlyphHash (&globalGlyphs[fdepth], &glyphHashSets[0]))
	    return FALSE;
d459 1
a459 1
	return FALSE;
d461 3
a463 4
    if (!AllocateGlyphHash (&glyphSet->hash, &glyphHashSets[0]))
    {
	free(glyphSet);
	return FALSE;
d468 1
a468 1
    return glyphSet;	
d472 1
a472 2
FreeGlyphSet (pointer	value,
	      XID       gid)
d474 21
a494 24
    GlyphSetPtr	glyphSet = (GlyphSetPtr) value;
    
    if (--glyphSet->refcnt == 0)
    {
	CARD32	    i, tableSize = glyphSet->hash.hashSet->size;
	GlyphRefPtr table = glyphSet->hash.table;
	GlyphPtr    glyph;
    
	for (i = 0; i < tableSize; i++)
	{
	    glyph = table[i].glyph;
	    if (glyph && glyph != DeletedGlyph)
		FreeGlyph (glyph, glyphSet->fdepth);
	}
	if (!globalGlyphs[glyphSet->fdepth].tableEntries)
	{
	    free(globalGlyphs[glyphSet->fdepth].table);
	    globalGlyphs[glyphSet->fdepth].table = 0;
	    globalGlyphs[glyphSet->fdepth].hashSet = 0;
	}
	else
	    ResizeGlyphHash (&globalGlyphs[glyphSet->fdepth], 0, TRUE);
	free(table);
	dixFreeObjectWithPrivates(glyphSet, PRIVATE_GLYPHSET);
d500 7
a506 10
GlyphExtents (int		nlist,
		GlyphListPtr	list,
		GlyphPtr	*glyphs,
		BoxPtr		extents)
{
    int		x1, x2, y1, y2;
    int		n;
    GlyphPtr	glyph;
    int		x, y;
    
d513 30
a542 32
    while (nlist--)
    {
	x += list->xOff;
	y += list->yOff;
	n = list->len;
	list++;
	while (n--)
	{
	    glyph = *glyphs++;
	    x1 = x - glyph->info.x;
	    if (x1 < MINSHORT)
		x1 = MINSHORT;
	    y1 = y - glyph->info.y;
	    if (y1 < MINSHORT)
		y1 = MINSHORT;
	    x2 = x1 + glyph->info.width;
	    if (x2 > MAXSHORT)
		x2 = MAXSHORT;
	    y2 = y1 + glyph->info.height;
	    if (y2 > MAXSHORT)
		y2 = MAXSHORT;
	    if (x1 < extents->x1)
		extents->x1 = x1;
	    if (x2 > extents->x2)
		extents->x2 = x2;
	    if (y1 < extents->y1)
		extents->y1 = y1;
	    if (y2 > extents->y2)
		extents->y2 = y2;
	    x += glyph->info.xOff;
	    y += glyph->info.yOff;
	}
d549 13
a561 15
CompositeGlyphs (CARD8		op,
		 PicturePtr	pSrc,
		 PicturePtr	pDst,
		 PictFormatPtr	maskFormat,
		 INT16		xSrc,
		 INT16		ySrc,
		 int		nlist,
		 GlyphListPtr	lists,
		 GlyphPtr	*glyphs)
{
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);

    ValidatePicture (pSrc);
    ValidatePicture (pDst);
    (*ps->Glyphs) (op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, lists, glyphs);
d565 1
a565 2
miRealizeGlyph (ScreenPtr pScreen,
		GlyphPtr  glyph)
d571 1
a571 2
miUnrealizeGlyph (ScreenPtr pScreen,
		  GlyphPtr  glyph)
d576 109
a684 126
miGlyphs (CARD8		op,
	  PicturePtr	pSrc,
	  PicturePtr	pDst,
	  PictFormatPtr	maskFormat,
	  INT16		xSrc,
	  INT16		ySrc,
	  int		nlist,
	  GlyphListPtr	list,
	  GlyphPtr	*glyphs)
{
    PicturePtr	pPicture;
    PixmapPtr   pMaskPixmap = 0;
    PicturePtr  pMask;
    ScreenPtr   pScreen = pDst->pDrawable->pScreen;
    int		width = 0, height = 0;
    int		x, y;
    int		xDst = list->xOff, yDst = list->yOff;
    int		n;
    GlyphPtr	glyph;
    int		error;
    BoxRec	extents = {0, 0, 0, 0};
    CARD32	component_alpha;

    if (maskFormat)
    {
	GCPtr	    pGC;
	xRectangle  rect;

	GlyphExtents (nlist, list, glyphs, &extents);

	if (extents.x2 <= extents.x1 || extents.y2 <= extents.y1)
	    return;
	width = extents.x2 - extents.x1;
	height = extents.y2 - extents.y1;
	pMaskPixmap = (*pScreen->CreatePixmap) (pScreen, width, height,
						maskFormat->depth,
						CREATE_PIXMAP_USAGE_SCRATCH);
	if (!pMaskPixmap)
	    return;
	component_alpha = NeedsComponent(maskFormat->format);
	pMask = CreatePicture (0, &pMaskPixmap->drawable,
			       maskFormat, CPComponentAlpha, &component_alpha,
			       serverClient, &error);
	if (!pMask)
	{
	    (*pScreen->DestroyPixmap) (pMaskPixmap);
	    return;
	}
	pGC = GetScratchGC (pMaskPixmap->drawable.depth, pScreen);
	ValidateGC (&pMaskPixmap->drawable, pGC);
	rect.x = 0;
	rect.y = 0;
	rect.width = width;
	rect.height = height;
	(*pGC->ops->PolyFillRect) (&pMaskPixmap->drawable, pGC, 1, &rect);
	FreeScratchGC (pGC);
	x = -extents.x1;
	y = -extents.y1;
    }
    else
    {
	pMask = pDst;
	x = 0;
	y = 0;
    }
    while (nlist--)
    {
	x += list->xOff;
	y += list->yOff;
	n = list->len;
	while (n--)
	{
	    glyph = *glyphs++;
	    pPicture = GlyphPicture (glyph)[pScreen->myNum];

	    if (pPicture)
	    {
		if (maskFormat)
		{
			CompositePicture (PictOpAdd,
					  pPicture,
					  None,
					  pMask,
					  0, 0,
					  0, 0,
					  x - glyph->info.x,
					  y - glyph->info.y,
					  glyph->info.width,
					  glyph->info.height);
		}
		else
		{
		    CompositePicture (op,
				      pSrc,
				      pPicture,
				      pDst,
				      xSrc + (x - glyph->info.x) - xDst,
				      ySrc + (y - glyph->info.y) - yDst,
				      0, 0,
				      x - glyph->info.x,
				      y - glyph->info.y,
				      glyph->info.width,
				      glyph->info.height);
		}
	    }

	    x += glyph->info.xOff;
	    y += glyph->info.yOff;
	}
	list++;
    }
    if (maskFormat)
    {
	x = extents.x1;
	y = extents.y1;
	CompositePicture (op,
			  pSrc,
			  pMask,
			  pDst,
			  xSrc + x - xDst,
			  ySrc + y - yDst,
			  0, 0,
			  x, y,
			  width, height);
	FreePicture ((pointer) pMask, (XID) 0);
	(*pScreen->DestroyPixmap) (pMaskPixmap);
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a86 7
static void
FreeGlyphPrivates (GlyphPtr glyph)
{
    dixFreePrivates(glyph->devPrivates);
    glyph->devPrivates = NULL;
}

d93 1
d105 5
a110 1
		FreeGlyphPrivates(glyph);
a113 9

    for (fdepth = 0; fdepth < GlyphFormatNum; fdepth++)
    {
	if (!globalGlyphs[fdepth].hashSet)
	    continue;
	
	for (i = 0; i < globalGlyphs[fdepth].hashSet->size; i++)
	    glyph = globalGlyphs[fdepth].table[i].glyph;    
    }
d302 1
a302 2
	FreeGlyphPrivates(glyph);
	xfree (glyph);
d320 1
a320 2
	FreeGlyphPrivates(glyph);
	xfree (glyph);
d378 1
d380 3
a382 2
    size = screenInfo.numScreens * sizeof (PicturePtr);
    glyph = (GlyphPtr) xalloc (size + sizeof (GlyphRec));
d388 1
a388 1
    glyph->devPrivates = NULL;
d412 1
a412 2
    FreeGlyphPrivates(glyph);
    xfree (glyph);
d419 1
a419 1
    hash->table = xcalloc (hashSet->size, sizeof (GlyphRefRec));
d462 1
a462 1
	xfree (hash->table);
a480 1
    int size;
d488 1
a488 2
    size = sizeof (GlyphSetRec);
    glyphSet = xcalloc (1, size);
d494 1
a494 1
	xfree (glyphSet);
d523 1
a523 1
	    xfree (globalGlyphs[glyphSet->fdepth].table);
d529 2
a530 3
	xfree (table);
	dixFreePrivates(glyphSet->devPrivates);
	xfree (glyphSet);
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d29 1
a29 8
#if defined(HAVE_SHA1INIT) || /* Use libc SHA1 */ \
	defined(HAVE_SHA1_IN_LIBMD) /* Use libmd for SHA1 */
# include <sys/types.h>
# include <sha1.h>
#else /* Use OpenSSL's libcrypto */
# include <stddef.h>  /* buggy openssl/sha.h wants size_t */
# include <openssl/sha.h>
#endif
d196 1
a196 10
#if defined(HAVE_SHA1INIT) ||	/* SHA1 in libC */ \
	defined(HAVE_SHA1_IN_LIBMD)  /* Use libmd for SHA1 */
    SHA1_CTX ctx;

    SHA1Init (&ctx);
    SHA1Update (&ctx, gi, sizeof (xGlyphInfo));
    SHA1Update (&ctx, bits, size);
    SHA1Final (sha1, &ctx);
#else /* Use OpenSSL's libcrypto */
    SHA_CTX ctx;
d199 1
a199 2
    success = SHA1_Init (&ctx);
    if (! success)
d202 2
a203 2
    success = SHA1_Update (&ctx, gi, sizeof (xGlyphInfo));
    if (! success)
d205 2
a206 3

    success = SHA1_Update (&ctx, bits, size);
    if (! success)
d208 2
a209 3

    success = SHA1_Final (sha1, &ctx);
    if (! success)
a210 2
#endif

d220 3
d260 20
a285 1
	PictureScreenPtr ps;
d312 1
a312 11
	for (i = 0; i < screenInfo.numScreens; i++)
	{
	    ScreenPtr pScreen = screenInfo.screens[i];

	    FreePicture ((pointer) GlyphPicture (glyph)[i], 0);

	    ps = GetPictureScreenIfSet (pScreen);
	    if (ps)
		(*ps->UnrealizeGlyph) (pScreen, glyph);
	}
	
d331 1
a331 9
	PictureScreenPtr ps;
	int              i;
	
	for (i = 0; i < screenInfo.numScreens; i++)
	{
	    ps = GetPictureScreenIfSet (screenInfo.screens[i]);
	    if (ps)
		(*ps->UnrealizeGlyph) (screenInfo.screens[i], glyph);
	}
d403 1
d604 1
a604 1
_X_EXPORT void
d635 1
a635 1
_X_EXPORT void
d711 1
a711 14
	    if (maskFormat)
	    {
		CompositePicture (PictOpAdd,
				  pPicture,
				  None,
				  pMask,
				  0, 0,
				  0, 0,
				  x - glyph->info.x,
				  y - glyph->info.y,
				  glyph->info.width,
				  glyph->info.height);
	    }
	    else
d713 27
a739 11
		CompositePicture (op,
				  pSrc,
				  pPicture,
				  pDst,
				  xSrc + (x - glyph->info.x) - xDst,
				  ySrc + (y - glyph->info.y) - yDst,
				  0, 0,
				  x - glyph->info.x,
				  y - glyph->info.y,
				  glyph->info.width,
				  glyph->info.height);
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d29 8
a36 2
#include <stddef.h>  /* buggy openssl/sha.h wants size_t */
#include <openssl/sha.h>
a96 8
    ScreenPtr pScreen;
    int i;

    for (i = 0; i < screenInfo.numScreens; i++) {
	pScreen = screenInfo.screens[i];
	dixFreePrivates(*GetGlyphPrivatesForScreen(glyph, pScreen));
    }

d203 9
d230 1
d447 1
a447 1
    hash->table = (GlyphRefPtr) xalloc (hashSet->size * sizeof (GlyphRefRec));
a449 1
    memset (hash->table, 0, hashSet->size * sizeof (GlyphRefRec));
d518 1
a518 1
    glyphSet = xalloc (size);
a520 1
    bzero((char *)glyphSet, size);
@


1.2
log
@Fixes for various integer overflow problems from X.Org:
CVE-2008-2360 - RENDER Extension heap buffer overflow
CVE-2008-2361 - RENDER Extension crash
CVE-2008-2362 - RENDER Extension memory corruption
CVE-2008-1379 - MIT-SHM arbitrary memory read
CVE-2008-1377 - RECORD and Security extensions memory corruption
@
text
@d29 3
d47 1
a87 58
static int	globalTotalGlyphPrivateSize = 0;

static int	glyphPrivateCount = 0;

void
ResetGlyphPrivates (void)
{
    glyphPrivateCount = 0;
}

int
AllocateGlyphPrivateIndex (void)
{
    return glyphPrivateCount++;
}

Bool
AllocateGlyphPrivate (ScreenPtr pScreen,
		      int	index2,
		      unsigned	amount)
{
    PictureScreenPtr ps;
    unsigned	     oldamount;

    ps = GetPictureScreenIfSet (pScreen);
    if (!ps)
	return FALSE;

    /* Round up sizes for proper alignment */
    amount = ((amount + (sizeof (DevUnion) - 1)) / sizeof (DevUnion)) *
	sizeof (DevUnion);

    if (index2 >= ps->glyphPrivateLen)
    {
	unsigned *nsizes;
	nsizes = (unsigned *) xrealloc (ps->glyphPrivateSizes,
					(index2 + 1) * sizeof (unsigned));
	if (!nsizes)
	    return FALSE;
	
	while (ps->glyphPrivateLen <= index2)
	{
	    nsizes[ps->glyphPrivateLen++] = 0;
	    ps->totalGlyphPrivateSize += sizeof (DevUnion);
	}
	ps->glyphPrivateSizes = nsizes;
    }
    oldamount = ps->glyphPrivateSizes[index2];
    if (amount > oldamount)
    {
	ps->glyphPrivateSizes[index2] = amount;
	ps->totalGlyphPrivateSize += (amount - oldamount);
    }
    ps->totalGlyphPrivateSize = BitmapBytePad (ps->totalGlyphPrivateSize * 8);
    
    return TRUE;
}

d89 1
a89 1
SetGlyphScreenPrivateOffsets (void)
d91 2
a92 3
    PictureScreenPtr ps;
    int		     offset = 0;
    int		     i;
d94 3
a96 8
    for (i = 0; i < screenInfo.numScreens; i++)
    {
	ps = GetPictureScreenIfSet (screenInfo.screens[i]);
	if (ps && ps->totalGlyphPrivateSize)
	{
	    ps->glyphPrivateOffset = offset;
	    offset += ps->totalGlyphPrivateSize / sizeof (DevUnion);
	}
a97 1
}
d99 2
a100 138
static void
SetGlyphPrivatePointers (GlyphPtr glyph)
{
    PictureScreenPtr ps;
    int		     i;
    char	     *ptr;
    DevUnion         *ppriv;
    unsigned         *sizes;
    unsigned         size;
    int		     len;

    for (i = 0; i < screenInfo.numScreens; i++)
    {
	ps = GetPictureScreenIfSet (screenInfo.screens[i]);
	if (ps && ps->totalGlyphPrivateSize)
	{
	    ppriv = glyph->devPrivates + ps->glyphPrivateOffset;
	    sizes = ps->glyphPrivateSizes;
	    ptr = (char *) (ppriv + ps->glyphPrivateLen);
	    for (len = ps->glyphPrivateLen; --len >= 0; ppriv++, sizes++)
	    {
		if ((size = *sizes) != 0)
		{
		    ppriv->ptr = (pointer) ptr;
		    ptr += size;
		}
		else
		    ppriv->ptr = (pointer) 0;
	    }
	}
    }
}

static Bool
ReallocGlobalGlyphPrivate (GlyphPtr glyph)
{
    PictureScreenPtr ps;
    DevUnion         *devPrivates;
    char	     *ptr;
    int		     i;

    devPrivates = xalloc (globalTotalGlyphPrivateSize);
    if (!devPrivates)
	return FALSE;

    ptr = (char *) devPrivates;
    for (i = 0; i < screenInfo.numScreens; i++)
    {
	ps = GetPictureScreenIfSet (screenInfo.screens[i]);
	if (ps && ps->totalGlyphPrivateSize)
	{
	    if (ps->glyphPrivateOffset != -1)
	    {
		memcpy (ptr, glyph->devPrivates + ps->glyphPrivateOffset,
			ps->totalGlyphPrivateSize);
	    }
	    else if (ps->totalGlyphPrivateSize)
	    {
		memset (ptr, 0, ps->totalGlyphPrivateSize);
	    }
	    
	    ptr += ps->totalGlyphPrivateSize;
	}
    }

    if (glyph->devPrivates)
	xfree (glyph->devPrivates);
    
    glyph->devPrivates = devPrivates;

    return TRUE;
}

Bool
GlyphInit (ScreenPtr pScreen)
{
    PictureScreenPtr ps = GetPictureScreen (pScreen);
    
    ps->totalGlyphPrivateSize = 0;
    ps->glyphPrivateSizes = 0;
    ps->glyphPrivateLen = 0;
    ps->glyphPrivateOffset = -1;
    
    return TRUE;
}

Bool
GlyphFinishInit (ScreenPtr pScreen)
{
    PictureScreenPtr ps = GetPictureScreen (pScreen);

    if (ps->totalGlyphPrivateSize)
    {
	GlyphPtr glyph;
	int	 fdepth, i;
	
	globalTotalGlyphPrivateSize += ps->totalGlyphPrivateSize;
	
	for (fdepth = 0; fdepth < GlyphFormatNum; fdepth++)
	{
	    if (!globalGlyphs[fdepth].hashSet)
		continue;
		
	    for (i = 0; i < globalGlyphs[fdepth].hashSet->size; i++)
	    {
		glyph = globalGlyphs[fdepth].table[i].glyph;
		if (glyph && glyph != DeletedGlyph)
		{
		    if (!ReallocGlobalGlyphPrivate (glyph))
			return FALSE;
		}
	    }
	}

	SetGlyphScreenPrivateOffsets ();

	for (fdepth = 0; fdepth < GlyphFormatNum; fdepth++)
	{
	    if (!globalGlyphs[fdepth].hashSet)
		continue;
		
	    for (i = 0; i < globalGlyphs[fdepth].hashSet->size; i++)
	    {
		glyph = globalGlyphs[fdepth].table[i].glyph;
		if (glyph && glyph != DeletedGlyph)
		{
		    SetGlyphPrivatePointers (glyph);
			
		    if (!(*ps->RealizeGlyph) (pScreen, glyph))
			return FALSE;
		}
	    }
	}
    }
    else
	ps->glyphPrivateOffset = 0;
    
    return TRUE;
a109 2
    globalTotalGlyphPrivateSize -= ps->totalGlyphPrivateSize;

d121 1
a121 12
		
		if (globalTotalGlyphPrivateSize)
		{
		    if (!ReallocGlobalGlyphPrivate (glyph))
			return;
		}
		else
		{
		    if (glyph->devPrivates)
			xfree (glyph->devPrivates);
		    glyph->devPrivates = NULL;
		}
a125 3
    if (globalTotalGlyphPrivateSize)
	SetGlyphScreenPrivateOffsets ();

a131 1
	{
a132 6
	    if (glyph && glyph != DeletedGlyph)
	    {
		if (globalTotalGlyphPrivateSize)
		    SetGlyphPrivatePointers (glyph);
	    }
	}
a133 3

    if (ps->glyphPrivateSizes)
	xfree (ps->glyphPrivateSizes);
a146 44
static int _GlyphSetPrivateAllocateIndex = 0;

int
AllocateGlyphSetPrivateIndex (void)
{
    return _GlyphSetPrivateAllocateIndex++;
}

void
ResetGlyphSetPrivateIndex (void)
{
    _GlyphSetPrivateAllocateIndex = 0;
}

Bool
_GlyphSetSetNewPrivate (GlyphSetPtr glyphSet, int n, pointer ptr)
{
    pointer *new;

    if (n > glyphSet->maxPrivate) {
	if (glyphSet->devPrivates &&
	    glyphSet->devPrivates != (pointer)(&glyphSet[1])) {
	    new = (pointer *) xrealloc (glyphSet->devPrivates,
					(n + 1) * sizeof (pointer));
	    if (!new)
		return FALSE;
	} else {
	    new = (pointer *) xalloc ((n + 1) * sizeof (pointer));
	    if (!new)
		return FALSE;
	    if (glyphSet->devPrivates)
		memcpy (new,
			glyphSet->devPrivates,
			(glyphSet->maxPrivate + 1) * sizeof (pointer));
	}
	glyphSet->devPrivates = new;
	/* Zero out new, uninitialize privates */
	while (++glyphSet->maxPrivate < n)
	    glyphSet->devPrivates[glyphSet->maxPrivate] = (pointer)0;
    }
    glyphSet->devPrivates[n] = ptr;
    return TRUE;
}

d148 4
a151 1
FindGlyphRef (GlyphHashPtr hash, CARD32 signature, Bool match, GlyphPtr compare)
d182 1
a182 1
		  memcmp (&compare->info, &glyph->info, compare->size) == 0))
d199 30
a228 2
CARD32
HashGlyph (GlyphPtr glyph)
d230 10
a239 8
    CARD32  *bits = (CARD32 *) &(glyph->info);
    CARD32  hash;
    int	    n = glyph->size / sizeof (CARD32);

    hash = 0;
    while (n--)
	hash ^= *bits++;
    return hash;
d280 1
d291 3
a293 2
	gr = FindGlyphRef (&globalGlyphs[format],
			   HashGlyph (glyph), TRUE, glyph);
d305 5
a309 1
	    ps = GetPictureScreenIfSet (screenInfo.screens[i]);
d311 1
a311 1
		(*ps->UnrealizeGlyph) (screenInfo.screens[i], glyph);
d314 1
a314 2
	if (glyph->devPrivates)
	    xfree (glyph->devPrivates);
d323 1
a323 1
    CARD32	    hash;
d327 4
a330 3
    hash = HashGlyph (glyph);
    gr = FindGlyphRef (&globalGlyphs[glyphSet->fdepth], hash, TRUE, glyph);
    if (gr->glyph && gr->glyph != DeletedGlyph)
d341 1
a341 2
	if (glyph->devPrivates)
	    xfree (glyph->devPrivates);
d345 1
a345 1
    else
d348 1
a348 1
	gr->signature = hash;
d400 2
a401 6
    size_t	     padded_width;
    
    padded_width = PixmapBytePad (gi->width, glyphDepths[fdepth]);
    if (gi->height && padded_width > (UINT32_MAX - sizeof(GlyphRec))/gi->height)
	return 0;
    size = gi->height * padded_width;
d408 1
a408 10

    if (globalTotalGlyphPrivateSize)
    {
	glyph->devPrivates = xalloc (globalTotalGlyphPrivateSize);
	if (!glyph->devPrivates)
	    return 0;

	SetGlyphPrivatePointers (glyph);
    } else
	glyph->devPrivates = NULL;
d413 1
d417 1
a417 13
	    {
		while (i--)
		{
		    ps = GetPictureScreenIfSet (screenInfo.screens[i]);
		    if (ps)
			(*ps->UnrealizeGlyph) (screenInfo.screens[i], glyph);
		}
		
		if (glyph->devPrivates)
		    xfree (glyph->devPrivates);
		xfree (glyph);
		return 0;
	    }
d422 12
d477 1
a477 1
		gr = FindGlyphRef (&newHash, s, global, glyph);
d510 1
a510 2
    size = (sizeof (GlyphSetRec) +
	    (sizeof (pointer) * _GlyphSetPrivateAllocateIndex));
a514 3
    glyphSet->maxPrivate = _GlyphSetPrivateAllocateIndex - 1;
    if (_GlyphSetPrivateAllocateIndex)
	glyphSet->devPrivates = (pointer)(&glyphSet[1]);
d554 5
d560 71
a630 3
	if (glyphSet->devPrivates &&
	    glyphSet->devPrivates != (pointer)(&glyphSet[1]))
	    xfree(glyphSet->devPrivates);
d632 137
a768 1
	xfree (glyphSet);
a769 1
    return Success;
@


1.1
log
@Initial revision
@
text
@d80 1
a80 1
const CARD8	glyphDepths[GlyphFormatNum] = { 1, 4, 8, 16, 32 };
d82 1
a82 1
GlyphHashRec	globalGlyphs[GlyphFormatNum];
d84 1
a84 1
int		globalTotalGlyphPrivateSize = 0;
d89 1
a89 1
ResetGlyphPrivates ()
d95 1
a95 1
AllocateGlyphPrivateIndex ()
d629 6
a634 2

    size = gi->height * PixmapBytePad (gi->width, glyphDepths[fdepth]);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.1.2.1
log
@Fixes for various integer overflow problems from X.Org:
CVE-2008-2360 - RENDER Extension heap buffer overflow
CVE-2008-2361 - RENDER Extension crash
CVE-2008-2362 - RENDER Extension memory corruption
CVE-2008-1379 - MIT-SHM arbitrary memory read
CVE-2008-1377 - RECORD and Security extensions memory corruption
@
text
@a44 6
#if HAVE_STDINT_H
#include <stdint.h>
#elif !defined(UINT32_MAX)
#define UINT32_MAX 0xffffffffU
#endif

d629 2
a630 6
    size_t	     padded_width;
    
    padded_width = PixmapBytePad (gi->width, glyphDepths[fdepth]);
    if (gi->height && padded_width > (UINT32_MAX - sizeof(GlyphRec))/gi->height)
	return 0;
    size = gi->height * padded_width;
@


1.1.1.2
log
@xserver 1.4
@
text
@d80 1
a80 1
static const CARD8	glyphDepths[GlyphFormatNum] = { 1, 4, 8, 16, 32 };
d82 1
a82 1
static GlyphHashRec	globalGlyphs[GlyphFormatNum];
d84 1
a84 1
static int	globalTotalGlyphPrivateSize = 0;
d89 1
a89 1
ResetGlyphPrivates (void)
d95 1
a95 1
AllocateGlyphPrivateIndex (void)
@


1.1.1.2.2.1
log
@Fixes for various integer overflow problems from X.Org:
CVE-2008-2360 - RENDER Extension heap buffer overflow
CVE-2008-2361 - RENDER Extension crash
CVE-2008-2362 - RENDER Extension memory corruption
CVE-2008-1379 - MIT-SHM arbitrary memory read
CVE-2008-1377 - RECORD and Security extensions memory corruption
@
text
@d629 2
a630 6
    size_t	     padded_width;
    
    padded_width = PixmapBytePad (gi->width, glyphDepths[fdepth]);
    if (gi->height && padded_width > (UINT32_MAX - sizeof(GlyphRec))/gi->height)
	return 0;
    size = gi->height * padded_width;
@


