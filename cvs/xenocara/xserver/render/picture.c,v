head	1.12;
access;
symbols
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	7pAEtF6Y5EgemkuY;

1.10
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.25;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.17;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *
 * Copyright Â© 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "misc.h"
#include "scrnintstr.h"
#include "os.h"
#include "regionstr.h"
#include "validate.h"
#include "windowstr.h"
#include "input.h"
#include "resource.h"
#include "colormapst.h"
#include "cursorstr.h"
#include "dixstruct.h"
#include "gcstruct.h"
#include "servermd.h"
#include "picturestr.h"
#include "xace.h"
#ifdef PANORAMIX
#include "panoramiXsrv.h"
#endif

DevPrivateKeyRec PictureScreenPrivateKeyRec;
DevPrivateKeyRec PictureWindowPrivateKeyRec;
static int PictureGeneration;
RESTYPE PictureType;
RESTYPE PictFormatType;
RESTYPE GlyphSetType;
int PictureCmapPolicy = PictureCmapPolicyDefault;

PictFormatPtr
PictureWindowFormat(WindowPtr pWindow)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    return PictureMatchVisual(pScreen, pWindow->drawable.depth,
                              WindowGetVisual(pWindow));
}

static Bool
PictureDestroyWindow(WindowPtr pWindow)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    PicturePtr pPicture;
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    Bool ret;

    while ((pPicture = GetPictureWindow(pWindow))) {
        SetPictureWindow(pWindow, pPicture->pNext);
        if (pPicture->id)
            FreeResource(pPicture->id, PictureType);
        FreePicture((void *) pPicture, pPicture->id);
    }
    pScreen->DestroyWindow = ps->DestroyWindow;
    ret = (*pScreen->DestroyWindow) (pWindow);
    ps->DestroyWindow = pScreen->DestroyWindow;
    pScreen->DestroyWindow = PictureDestroyWindow;
    return ret;
}

static Bool
PictureCloseScreen(ScreenPtr pScreen)
{
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    Bool ret;
    int n;

    pScreen->CloseScreen = ps->CloseScreen;
    ret = (*pScreen->CloseScreen) (pScreen);
    PictureResetFilters(pScreen);
    for (n = 0; n < ps->nformats; n++)
        if (ps->formats[n].type == PictTypeIndexed)
            (*ps->CloseIndexed) (pScreen, &ps->formats[n]);
    GlyphUninit(pScreen);
    SetPictureScreen(pScreen, 0);
    free(ps->formats);
    free(ps);
    return ret;
}

static void
PictureStoreColors(ColormapPtr pColormap, int ndef, xColorItem * pdef)
{
    ScreenPtr pScreen = pColormap->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);

    pScreen->StoreColors = ps->StoreColors;
    (*pScreen->StoreColors) (pColormap, ndef, pdef);
    ps->StoreColors = pScreen->StoreColors;
    pScreen->StoreColors = PictureStoreColors;

    if (pColormap->class == PseudoColor || pColormap->class == GrayScale) {
        PictFormatPtr format = ps->formats;
        int nformats = ps->nformats;

        while (nformats--) {
            if (format->type == PictTypeIndexed &&
                format->index.pColormap == pColormap) {
                (*ps->UpdateIndexed) (pScreen, format, ndef, pdef);
                break;
            }
            format++;
        }
    }
}

static int
visualDepth(ScreenPtr pScreen, VisualPtr pVisual)
{
    int d, v;
    DepthPtr pDepth;

    for (d = 0; d < pScreen->numDepths; d++) {
        pDepth = &pScreen->allowedDepths[d];
        for (v = 0; v < pDepth->numVids; v++)
            if (pDepth->vids[v] == pVisual->vid)
                return pDepth->depth;
    }
    return 0;
}

typedef struct _formatInit {
    CARD32 format;
    CARD8 depth;
} FormatInitRec, *FormatInitPtr;

static int
addFormat(FormatInitRec formats[256], int nformat, CARD32 format, CARD8 depth)
{
    int n;

    for (n = 0; n < nformat; n++)
        if (formats[n].format == format && formats[n].depth == depth)
            return nformat;
    formats[nformat].format = format;
    formats[nformat].depth = depth;
    return ++nformat;
}

#define Mask(n) ((1 << (n)) - 1)

static PictFormatPtr
PictureCreateDefaultFormats(ScreenPtr pScreen, int *nformatp)
{
    int nformats, f;
    PictFormatPtr pFormats;
    FormatInitRec formats[1024];
    CARD32 format;
    CARD8 depth;
    VisualPtr pVisual;
    int v;
    int bpp;
    int type;
    int r, g, b;
    int d;
    DepthPtr pDepth;

    nformats = 0;
    /* formats required by protocol */
    formats[nformats].format = PICT_a1;
    formats[nformats].depth = 1;
    nformats++;
    formats[nformats].format = PICT_FORMAT(BitsPerPixel(8),
                                           PICT_TYPE_A, 8, 0, 0, 0);
    formats[nformats].depth = 8;
    nformats++;
    formats[nformats].format = PICT_FORMAT(BitsPerPixel(4),
                                           PICT_TYPE_A, 4, 0, 0, 0);
    formats[nformats].depth = 4;
    nformats++;
    formats[nformats].format = PICT_a8r8g8b8;
    formats[nformats].depth = 32;
    nformats++;
    formats[nformats].format = PICT_x8r8g8b8;
    formats[nformats].depth = 32;
    nformats++;
    formats[nformats].format = PICT_b8g8r8a8;
    formats[nformats].depth = 32;
    nformats++;
    formats[nformats].format = PICT_b8g8r8x8;
    formats[nformats].depth = 32;
    nformats++;

    /* now look through the depths and visuals adding other formats */
    for (v = 0; v < pScreen->numVisuals; v++) {
        pVisual = &pScreen->visuals[v];
        depth = visualDepth(pScreen, pVisual);
        if (!depth)
            continue;
        bpp = BitsPerPixel(depth);
        switch (pVisual->class) {
        case DirectColor:
        case TrueColor:
            r = Ones(pVisual->redMask);
            g = Ones(pVisual->greenMask);
            b = Ones(pVisual->blueMask);
            type = PICT_TYPE_OTHER;
            /*
             * Current rendering code supports only three direct formats,
             * fields must be packed together at the bottom of the pixel
             */
            if (pVisual->offsetBlue == 0 &&
                pVisual->offsetGreen == b && pVisual->offsetRed == b + g) {
                type = PICT_TYPE_ARGB;
            }
            else if (pVisual->offsetRed == 0 &&
                     pVisual->offsetGreen == r &&
                     pVisual->offsetBlue == r + g) {
                type = PICT_TYPE_ABGR;
            }
            else if (pVisual->offsetRed == pVisual->offsetGreen - r &&
                     pVisual->offsetGreen == pVisual->offsetBlue - g &&
                     pVisual->offsetBlue == bpp - b) {
                type = PICT_TYPE_BGRA;
            }
            if (type != PICT_TYPE_OTHER) {
                format = PICT_FORMAT(bpp, type, 0, r, g, b);
                nformats = addFormat(formats, nformats, format, depth);
            }
            break;
        case StaticColor:
        case PseudoColor:
            format = PICT_VISFORMAT(bpp, PICT_TYPE_COLOR, v);
            nformats = addFormat(formats, nformats, format, depth);
            break;
        case StaticGray:
        case GrayScale:
            format = PICT_VISFORMAT(bpp, PICT_TYPE_GRAY, v);
            nformats = addFormat(formats, nformats, format, depth);
            break;
        }
    }
    /*
     * Walk supported depths and add useful Direct formats
     */
    for (d = 0; d < pScreen->numDepths; d++) {
        pDepth = &pScreen->allowedDepths[d];
        bpp = BitsPerPixel(pDepth->depth);
        format = 0;
        switch (bpp) {
        case 16:
            /* depth 12 formats */
            if (pDepth->depth >= 12) {
                nformats = addFormat(formats, nformats,
                                     PICT_x4r4g4b4, pDepth->depth);
                nformats = addFormat(formats, nformats,
                                     PICT_x4b4g4r4, pDepth->depth);
            }
            /* depth 15 formats */
            if (pDepth->depth >= 15) {
                nformats = addFormat(formats, nformats,
                                     PICT_x1r5g5b5, pDepth->depth);
                nformats = addFormat(formats, nformats,
                                     PICT_x1b5g5r5, pDepth->depth);
            }
            /* depth 16 formats */
            if (pDepth->depth >= 16) {
                nformats = addFormat(formats, nformats,
                                     PICT_a1r5g5b5, pDepth->depth);
                nformats = addFormat(formats, nformats,
                                     PICT_a1b5g5r5, pDepth->depth);
                nformats = addFormat(formats, nformats,
                                     PICT_r5g6b5, pDepth->depth);
                nformats = addFormat(formats, nformats,
                                     PICT_b5g6r5, pDepth->depth);
                nformats = addFormat(formats, nformats,
                                     PICT_a4r4g4b4, pDepth->depth);
                nformats = addFormat(formats, nformats,
                                     PICT_a4b4g4r4, pDepth->depth);
            }
            break;
        case 24:
            if (pDepth->depth >= 24) {
                nformats = addFormat(formats, nformats,
                                     PICT_r8g8b8, pDepth->depth);
                nformats = addFormat(formats, nformats,
                                     PICT_b8g8r8, pDepth->depth);
            }
            break;
        case 32:
            if (pDepth->depth >= 24) {
                nformats = addFormat(formats, nformats,
                                     PICT_x8r8g8b8, pDepth->depth);
                nformats = addFormat(formats, nformats,
                                     PICT_x8b8g8r8, pDepth->depth);
            }
            if (pDepth->depth >= 30) {
                nformats = addFormat(formats, nformats,
                                     PICT_a2r10g10b10, pDepth->depth);
                nformats = addFormat(formats, nformats,
                                     PICT_x2r10g10b10, pDepth->depth);
                nformats = addFormat(formats, nformats,
                                     PICT_a2b10g10r10, pDepth->depth);
                nformats = addFormat(formats, nformats,
                                     PICT_x2b10g10r10, pDepth->depth);
            }
            break;
        }
    }

    pFormats = calloc(nformats, sizeof(PictFormatRec));
    if (!pFormats)
        return 0;
    for (f = 0; f < nformats; f++) {
        pFormats[f].id = FakeClientID(0);
        pFormats[f].depth = formats[f].depth;
        format = formats[f].format;
        pFormats[f].format = format;
        switch (PICT_FORMAT_TYPE(format)) {
        case PICT_TYPE_ARGB:
            pFormats[f].type = PictTypeDirect;

            pFormats[f].direct.alphaMask = Mask (PICT_FORMAT_A(format));

            if (pFormats[f].direct.alphaMask)
                pFormats[f].direct.alpha = (PICT_FORMAT_R(format) +
                                            PICT_FORMAT_G(format) +
                                            PICT_FORMAT_B(format));

            pFormats[f].direct.redMask = Mask (PICT_FORMAT_R(format));

            pFormats[f].direct.red = (PICT_FORMAT_G(format) +
                                      PICT_FORMAT_B(format));

            pFormats[f].direct.greenMask = Mask (PICT_FORMAT_G(format));

            pFormats[f].direct.green = PICT_FORMAT_B(format);

            pFormats[f].direct.blueMask = Mask (PICT_FORMAT_B(format));

            pFormats[f].direct.blue = 0;
            break;

        case PICT_TYPE_ABGR:
            pFormats[f].type = PictTypeDirect;

            pFormats[f].direct.alphaMask = Mask (PICT_FORMAT_A(format));

            if (pFormats[f].direct.alphaMask)
                pFormats[f].direct.alpha = (PICT_FORMAT_B(format) +
                                            PICT_FORMAT_G(format) +
                                            PICT_FORMAT_R(format));

            pFormats[f].direct.blueMask = Mask (PICT_FORMAT_B(format));

            pFormats[f].direct.blue = (PICT_FORMAT_G(format) +
                                       PICT_FORMAT_R(format));

            pFormats[f].direct.greenMask = Mask (PICT_FORMAT_G(format));

            pFormats[f].direct.green = PICT_FORMAT_R(format);

            pFormats[f].direct.redMask = Mask (PICT_FORMAT_R(format));

            pFormats[f].direct.red = 0;
            break;

        case PICT_TYPE_BGRA:
            pFormats[f].type = PictTypeDirect;

            pFormats[f].direct.blueMask = Mask (PICT_FORMAT_B(format));

            pFormats[f].direct.blue =
                (PICT_FORMAT_BPP(format) - PICT_FORMAT_B(format));

            pFormats[f].direct.greenMask = Mask (PICT_FORMAT_G(format));

            pFormats[f].direct.green =
                (PICT_FORMAT_BPP(format) - PICT_FORMAT_B(format) -
                 PICT_FORMAT_G(format));

            pFormats[f].direct.redMask = Mask (PICT_FORMAT_R(format));

            pFormats[f].direct.red =
                (PICT_FORMAT_BPP(format) - PICT_FORMAT_B(format) -
                 PICT_FORMAT_G(format) - PICT_FORMAT_R(format));

            pFormats[f].direct.alphaMask = Mask (PICT_FORMAT_A(format));

            pFormats[f].direct.alpha = 0;
            break;

        case PICT_TYPE_A:
            pFormats[f].type = PictTypeDirect;

            pFormats[f].direct.alpha = 0;
            pFormats[f].direct.alphaMask = Mask (PICT_FORMAT_A(format));

            /* remaining fields already set to zero */
            break;

        case PICT_TYPE_COLOR:
        case PICT_TYPE_GRAY:
            pFormats[f].type = PictTypeIndexed;
            pFormats[f].index.vid =
                pScreen->visuals[PICT_FORMAT_VIS(format)].vid;
            break;
        }
    }
    *nformatp = nformats;
    return pFormats;
}

static VisualPtr
PictureFindVisual(ScreenPtr pScreen, VisualID visual)
{
    int i;
    VisualPtr pVisual;

    for (i = 0, pVisual = pScreen->visuals;
         i < pScreen->numVisuals; i++, pVisual++) {
        if (pVisual->vid == visual)
            return pVisual;
    }
    return 0;
}

static Bool
PictureInitIndexedFormat(ScreenPtr pScreen, PictFormatPtr format)
{
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);

    if (format->type != PictTypeIndexed || format->index.pColormap)
        return TRUE;

    if (format->index.vid == pScreen->rootVisual) {
        dixLookupResourceByType((void **) &format->index.pColormap,
                                pScreen->defColormap, RT_COLORMAP,
                                serverClient, DixGetAttrAccess);
    }
    else {
        VisualPtr pVisual = PictureFindVisual(pScreen, format->index.vid);

        if (CreateColormap(FakeClientID(0), pScreen, pVisual,
                           &format->index.pColormap, AllocNone, 0)
            != Success)
            return FALSE;
    }
    if (!ps->InitIndexed(pScreen, format))
        return FALSE;
    return TRUE;
}

static Bool
PictureInitIndexedFormats(ScreenPtr pScreen)
{
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);
    PictFormatPtr format;
    int nformat;

    if (!ps)
        return FALSE;
    format = ps->formats;
    nformat = ps->nformats;
    while (nformat--)
        if (!PictureInitIndexedFormat(pScreen, format++))
            return FALSE;
    return TRUE;
}

Bool
PictureFinishInit(void)
{
    int s;

    for (s = 0; s < screenInfo.numScreens; s++) {
        if (!PictureInitIndexedFormats(screenInfo.screens[s]))
            return FALSE;
        (void) AnimCurInit(screenInfo.screens[s]);
    }

    return TRUE;
}

Bool
PictureSetSubpixelOrder(ScreenPtr pScreen, int subpixel)
{
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);

    if (!ps)
        return FALSE;
    ps->subpixel = subpixel;
    return TRUE;

}

int
PictureGetSubpixelOrder(ScreenPtr pScreen)
{
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);

    if (!ps)
        return SubPixelUnknown;
    return ps->subpixel;
}

PictFormatPtr
PictureMatchVisual(ScreenPtr pScreen, int depth, VisualPtr pVisual)
{
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);
    PictFormatPtr format;
    int nformat;
    int type;

    if (!ps)
        return 0;
    format = ps->formats;
    nformat = ps->nformats;
    switch (pVisual->class) {
    case StaticGray:
    case GrayScale:
    case StaticColor:
    case PseudoColor:
        type = PictTypeIndexed;
        break;
    case TrueColor:
    case DirectColor:
        type = PictTypeDirect;
        break;
    default:
        return 0;
    }
    while (nformat--) {
        if (format->depth == depth && format->type == type) {
            if (type == PictTypeIndexed) {
                if (format->index.vid == pVisual->vid)
                    return format;
            }
            else {
                if (format->direct.redMask << format->direct.red ==
                    pVisual->redMask &&
                    format->direct.greenMask << format->direct.green ==
                    pVisual->greenMask &&
                    format->direct.blueMask << format->direct.blue ==
                    pVisual->blueMask) {
                    return format;
                }
            }
        }
        format++;
    }
    return 0;
}

PictFormatPtr
PictureMatchFormat(ScreenPtr pScreen, int depth, CARD32 f)
{
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);
    PictFormatPtr format;
    int nformat;

    if (!ps)
        return 0;
    format = ps->formats;
    nformat = ps->nformats;
    while (nformat--) {
        if (format->depth == depth && format->format == (f & 0xffffff))
            return format;
        format++;
    }
    return 0;
}

int
PictureParseCmapPolicy(const char *name)
{
    if (strcmp(name, "default") == 0)
        return PictureCmapPolicyDefault;
    else if (strcmp(name, "mono") == 0)
        return PictureCmapPolicyMono;
    else if (strcmp(name, "gray") == 0)
        return PictureCmapPolicyGray;
    else if (strcmp(name, "color") == 0)
        return PictureCmapPolicyColor;
    else if (strcmp(name, "all") == 0)
        return PictureCmapPolicyAll;
    else
        return PictureCmapPolicyInvalid;
}

/** @@see GetDefaultBytes */
static void
GetPictureBytes(void *value, XID id, ResourceSizePtr size)
{
    PicturePtr picture = value;

    /* Currently only pixmap bytes are reported to clients. */
    size->resourceSize = 0;

    size->refCnt = picture->refcnt;

    /* Calculate pixmap reference sizes. */
    size->pixmapRefSize = 0;
    if (picture->pDrawable && (picture->pDrawable->type == DRAWABLE_PIXMAP))
    {
        SizeType pixmapSizeFunc = GetResourceTypeSizeFunc(RT_PIXMAP);
        ResourceSizeRec pixmapSize = { 0, 0, 0 };
        PixmapPtr pixmap = (PixmapPtr)picture->pDrawable;
        pixmapSizeFunc(pixmap, pixmap->drawable.id, &pixmapSize);
        size->pixmapRefSize += pixmapSize.pixmapRefSize;
    }
}

static int
FreePictFormat(void *pPictFormat, XID pid)
{
    return Success;
}

Bool
PictureInit(ScreenPtr pScreen, PictFormatPtr formats, int nformats)
{
    PictureScreenPtr ps;
    int n;
    CARD32 type, a, r, g, b;

    if (PictureGeneration != serverGeneration) {
        PictureType = CreateNewResourceType(FreePicture, "PICTURE");
        if (!PictureType)
            return FALSE;
        SetResourceTypeSizeFunc(PictureType, GetPictureBytes);
        PictFormatType = CreateNewResourceType(FreePictFormat, "PICTFORMAT");
        if (!PictFormatType)
            return FALSE;
        GlyphSetType = CreateNewResourceType(FreeGlyphSet, "GLYPHSET");
        if (!GlyphSetType)
            return FALSE;
        PictureGeneration = serverGeneration;
    }
    if (!dixRegisterPrivateKey(&PictureScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    if (!dixRegisterPrivateKey(&PictureWindowPrivateKeyRec, PRIVATE_WINDOW, 0))
        return FALSE;

    if (!formats) {
        formats = PictureCreateDefaultFormats(pScreen, &nformats);
        if (!formats)
            return FALSE;
    }
    for (n = 0; n < nformats; n++) {
        if (!AddResource
            (formats[n].id, PictFormatType, (void *) (formats + n))) {
            int i;
            for (i = 0; i < n; i++)
                FreeResource(formats[i].id, RT_NONE);
            free(formats);
            return FALSE;
        }
        if (formats[n].type == PictTypeIndexed) {
            VisualPtr pVisual =
                PictureFindVisual(pScreen, formats[n].index.vid);
            if ((pVisual->class | DynamicClass) == PseudoColor)
                type = PICT_TYPE_COLOR;
            else
                type = PICT_TYPE_GRAY;
            a = r = g = b = 0;
        }
        else {
            if ((formats[n].direct.redMask |
                 formats[n].direct.blueMask | formats[n].direct.greenMask) == 0)
                type = PICT_TYPE_A;
            else if (formats[n].direct.red > formats[n].direct.blue)
                type = PICT_TYPE_ARGB;
            else if (formats[n].direct.red == 0)
                type = PICT_TYPE_ABGR;
            else
                type = PICT_TYPE_BGRA;
            a = Ones(formats[n].direct.alphaMask);
            r = Ones(formats[n].direct.redMask);
            g = Ones(formats[n].direct.greenMask);
            b = Ones(formats[n].direct.blueMask);
        }
        formats[n].format = PICT_FORMAT(0, type, a, r, g, b);
    }
    ps = (PictureScreenPtr) malloc(sizeof(PictureScreenRec));
    if (!ps) {
        free(formats);
        return FALSE;
    }
    SetPictureScreen(pScreen, ps);

    ps->formats = formats;
    ps->fallback = formats;
    ps->nformats = nformats;

    ps->filters = 0;
    ps->nfilters = 0;
    ps->filterAliases = 0;
    ps->nfilterAliases = 0;

    ps->subpixel = SubPixelUnknown;

    ps->CloseScreen = pScreen->CloseScreen;
    ps->DestroyWindow = pScreen->DestroyWindow;
    ps->StoreColors = pScreen->StoreColors;
    pScreen->DestroyWindow = PictureDestroyWindow;
    pScreen->CloseScreen = PictureCloseScreen;
    pScreen->StoreColors = PictureStoreColors;

    if (!PictureSetDefaultFilters(pScreen)) {
        PictureResetFilters(pScreen);
        SetPictureScreen(pScreen, 0);
        free(formats);
        free(ps);
        return FALSE;
    }

    return TRUE;
}

static void
SetPictureToDefaults(PicturePtr pPicture)
{
    pPicture->refcnt = 1;
    pPicture->repeat = 0;
    pPicture->graphicsExposures = FALSE;
    pPicture->subWindowMode = ClipByChildren;
    pPicture->polyEdge = PolyEdgeSharp;
    pPicture->polyMode = PolyModePrecise;
    pPicture->freeCompClip = FALSE;
    pPicture->componentAlpha = FALSE;
    pPicture->repeatType = RepeatNone;

    pPicture->alphaMap = 0;
    pPicture->alphaOrigin.x = 0;
    pPicture->alphaOrigin.y = 0;

    pPicture->clipOrigin.x = 0;
    pPicture->clipOrigin.y = 0;
    pPicture->clientClip = 0;

    pPicture->transform = 0;

    pPicture->filter = PictureGetFilterId(FilterNearest, -1, TRUE);
    pPicture->filter_params = 0;
    pPicture->filter_nparams = 0;

    pPicture->serialNumber = GC_CHANGE_SERIAL_BIT;
    pPicture->stateChanges = -1;
    pPicture->pSourcePict = 0;
}

PicturePtr
CreatePicture(Picture pid,
              DrawablePtr pDrawable,
              PictFormatPtr pFormat,
              Mask vmask, XID *vlist, ClientPtr client, int *error)
{
    PicturePtr pPicture;
    PictureScreenPtr ps = GetPictureScreen(pDrawable->pScreen);

    pPicture = dixAllocateScreenObjectWithPrivates(pDrawable->pScreen,
                                                   PictureRec, PRIVATE_PICTURE);
    if (!pPicture) {
        *error = BadAlloc;
        return 0;
    }

    pPicture->id = pid;
    pPicture->pDrawable = pDrawable;
    pPicture->pFormat = pFormat;
    pPicture->format = pFormat->format | (pDrawable->bitsPerPixel << 24);

    /* security creation/labeling check */
    *error = XaceHook(XACE_RESOURCE_ACCESS, client, pid, PictureType, pPicture,
                      RT_PIXMAP, pDrawable, DixCreateAccess | DixSetAttrAccess);
    if (*error != Success)
        goto out;

    if (pDrawable->type == DRAWABLE_PIXMAP) {
        ++((PixmapPtr) pDrawable)->refcnt;
        pPicture->pNext = 0;
    }
    else {
        pPicture->pNext = GetPictureWindow(((WindowPtr) pDrawable));
        SetPictureWindow(((WindowPtr) pDrawable), pPicture);
    }

    SetPictureToDefaults(pPicture);

    if (vmask)
        *error = ChangePicture(pPicture, vmask, vlist, 0, client);
    else
        *error = Success;
    if (*error == Success)
        *error = (*ps->CreatePicture) (pPicture);
 out:
    if (*error != Success) {
        FreePicture(pPicture, (XID) 0);
        pPicture = 0;
    }
    return pPicture;
}

static CARD32
xRenderColorToCard32(xRenderColor c)
{
    return
        (c.alpha >> 8 << 24) |
        (c.red >> 8 << 16) | (c.green & 0xff00) | (c.blue >> 8);
}

static void
initGradient(SourcePictPtr pGradient, int stopCount,
             xFixed * stopPoints, xRenderColor * stopColors, int *error)
{
    int i;
    xFixed dpos;

    if (stopCount <= 0) {
        *error = BadValue;
        return;
    }

    dpos = -1;
    for (i = 0; i < stopCount; ++i) {
        if (stopPoints[i] < dpos || stopPoints[i] > (1 << 16)) {
            *error = BadValue;
            return;
        }
        dpos = stopPoints[i];
    }

    pGradient->gradient.stops = xallocarray(stopCount, sizeof(PictGradientStop));
    if (!pGradient->gradient.stops) {
        *error = BadAlloc;
        return;
    }

    pGradient->gradient.nstops = stopCount;

    for (i = 0; i < stopCount; ++i) {
        pGradient->gradient.stops[i].x = stopPoints[i];
        pGradient->gradient.stops[i].color = stopColors[i];
    }
}

static PicturePtr
createSourcePicture(void)
{
    PicturePtr pPicture;

    pPicture = dixAllocateScreenObjectWithPrivates(NULL, PictureRec,
                                                   PRIVATE_PICTURE);
    if (!pPicture)
	return 0;

    pPicture->pDrawable = 0;
    pPicture->pFormat = 0;
    pPicture->pNext = 0;
    pPicture->format = PICT_a8r8g8b8;

    SetPictureToDefaults(pPicture);
    return pPicture;
}

PicturePtr
CreateSolidPicture(Picture pid, xRenderColor * color, int *error)
{
    PicturePtr pPicture;

    pPicture = createSourcePicture();
    if (!pPicture) {
        *error = BadAlloc;
        return 0;
    }

    pPicture->id = pid;
    pPicture->pSourcePict = (SourcePictPtr) malloc(sizeof(PictSolidFill));
    if (!pPicture->pSourcePict) {
        *error = BadAlloc;
        free(pPicture);
        return 0;
    }
    pPicture->pSourcePict->type = SourcePictTypeSolidFill;
    pPicture->pSourcePict->solidFill.color = xRenderColorToCard32(*color);
    return pPicture;
}

PicturePtr
CreateLinearGradientPicture(Picture pid, xPointFixed * p1, xPointFixed * p2,
                            int nStops, xFixed * stops, xRenderColor * colors,
                            int *error)
{
    PicturePtr pPicture;

    if (nStops < 1) {
        *error = BadValue;
        return 0;
    }

    pPicture = createSourcePicture();
    if (!pPicture) {
        *error = BadAlloc;
        return 0;
    }

    pPicture->id = pid;
    pPicture->pSourcePict = (SourcePictPtr) malloc(sizeof(PictLinearGradient));
    if (!pPicture->pSourcePict) {
        *error = BadAlloc;
        free(pPicture);
        return 0;
    }

    pPicture->pSourcePict->linear.type = SourcePictTypeLinear;
    pPicture->pSourcePict->linear.p1 = *p1;
    pPicture->pSourcePict->linear.p2 = *p2;

    initGradient(pPicture->pSourcePict, nStops, stops, colors, error);
    if (*error) {
        free(pPicture);
        return 0;
    }
    return pPicture;
}

PicturePtr
CreateRadialGradientPicture(Picture pid, xPointFixed * inner,
                            xPointFixed * outer, xFixed innerRadius,
                            xFixed outerRadius, int nStops, xFixed * stops,
                            xRenderColor * colors, int *error)
{
    PicturePtr pPicture;
    PictRadialGradient *radial;

    if (nStops < 1) {
        *error = BadValue;
        return 0;
    }

    pPicture = createSourcePicture();
    if (!pPicture) {
        *error = BadAlloc;
        return 0;
    }

    pPicture->id = pid;
    pPicture->pSourcePict = (SourcePictPtr) malloc(sizeof(PictRadialGradient));
    if (!pPicture->pSourcePict) {
        *error = BadAlloc;
        free(pPicture);
        return 0;
    }
    radial = &pPicture->pSourcePict->radial;

    radial->type = SourcePictTypeRadial;
    radial->c1.x = inner->x;
    radial->c1.y = inner->y;
    radial->c1.radius = innerRadius;
    radial->c2.x = outer->x;
    radial->c2.y = outer->y;
    radial->c2.radius = outerRadius;

    initGradient(pPicture->pSourcePict, nStops, stops, colors, error);
    if (*error) {
        free(pPicture);
        return 0;
    }
    return pPicture;
}

PicturePtr
CreateConicalGradientPicture(Picture pid, xPointFixed * center, xFixed angle,
                             int nStops, xFixed * stops, xRenderColor * colors,
                             int *error)
{
    PicturePtr pPicture;

    if (nStops < 1) {
        *error = BadValue;
        return 0;
    }

    pPicture = createSourcePicture();
    if (!pPicture) {
        *error = BadAlloc;
        return 0;
    }

    pPicture->id = pid;
    pPicture->pSourcePict = (SourcePictPtr) malloc(sizeof(PictConicalGradient));
    if (!pPicture->pSourcePict) {
        *error = BadAlloc;
        free(pPicture);
        return 0;
    }

    pPicture->pSourcePict->conical.type = SourcePictTypeConical;
    pPicture->pSourcePict->conical.center = *center;
    pPicture->pSourcePict->conical.angle = angle;

    initGradient(pPicture->pSourcePict, nStops, stops, colors, error);
    if (*error) {
        free(pPicture);
        return 0;
    }
    return pPicture;
}

static int
cpAlphaMap(void **result, XID id, ScreenPtr screen, ClientPtr client, Mask mode)
{
#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        PanoramiXRes *res;
        int err = dixLookupResourceByType((void **)&res, id, XRT_PICTURE,
                                          client, mode);
        if (err != Success)
            return err;
        id = res->info[screen->myNum].id;
    }
#endif
    return dixLookupResourceByType(result, id, PictureType, client, mode);
}

static int
cpClipMask(void **result, XID id, ScreenPtr screen, ClientPtr client, Mask mode)
{
#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        PanoramiXRes *res;
        int err = dixLookupResourceByType((void **)&res, id, XRT_PIXMAP,
                                          client, mode);
        if (err != Success)
            return err;
        id = res->info[screen->myNum].id;
    }
#endif
    return dixLookupResourceByType(result, id, RT_PIXMAP, client, mode);
}

#define NEXT_VAL(_type) (vlist ? (_type) *vlist++ : (_type) ulist++->val)

#define NEXT_PTR(_type) ((_type) ulist++->ptr)

int
ChangePicture(PicturePtr pPicture,
              Mask vmask, XID *vlist, DevUnion *ulist, ClientPtr client)
{
    ScreenPtr pScreen = pPicture->pDrawable ? pPicture->pDrawable->pScreen : 0;
    PictureScreenPtr ps = pScreen ? GetPictureScreen(pScreen) : 0;
    BITS32 index2;
    int error = 0;
    BITS32 maskQ;

    pPicture->serialNumber |= GC_CHANGE_SERIAL_BIT;
    maskQ = vmask;
    while (vmask && !error) {
        index2 = (BITS32) lowbit(vmask);
        vmask &= ~index2;
        pPicture->stateChanges |= index2;
        switch (index2) {
        case CPRepeat:
        {
            unsigned int newr;
            newr = NEXT_VAL(unsigned int);

            if (newr <= RepeatReflect) {
                pPicture->repeat = (newr != RepeatNone);
                pPicture->repeatType = newr;
            }
            else {
                client->errorValue = newr;
                error = BadValue;
            }
        }
            break;
        case CPAlphaMap:
        {
            PicturePtr pAlpha;

            if (vlist) {
                Picture pid = NEXT_VAL(Picture);

                if (pid == None)
                    pAlpha = 0;
                else {
                    error = cpAlphaMap((void **) &pAlpha, pid, pScreen,
                                       client, DixReadAccess);
                    if (error != Success) {
                        client->errorValue = pid;
                        break;
                    }
                    if (pAlpha->pDrawable == NULL ||
                        pAlpha->pDrawable->type != DRAWABLE_PIXMAP) {
                        client->errorValue = pid;
                        error = BadMatch;
                        break;
                    }
                }
            }
            else
                pAlpha = NEXT_PTR(PicturePtr);
            if (!error) {
                if (pAlpha && pAlpha->pDrawable->type == DRAWABLE_PIXMAP)
                    pAlpha->refcnt++;
                if (pPicture->alphaMap)
                    FreePicture((void *) pPicture->alphaMap, (XID) 0);
                pPicture->alphaMap = pAlpha;
            }
        }
            break;
        case CPAlphaXOrigin:
            pPicture->alphaOrigin.x = NEXT_VAL(INT16);

            break;
        case CPAlphaYOrigin:
            pPicture->alphaOrigin.y = NEXT_VAL(INT16);

            break;
        case CPClipXOrigin:
            pPicture->clipOrigin.x = NEXT_VAL(INT16);

            break;
        case CPClipYOrigin:
            pPicture->clipOrigin.y = NEXT_VAL(INT16);

            break;
        case CPClipMask:
        {
            Pixmap pid;
            PixmapPtr pPixmap;
            int clipType;

            if (!pScreen)
                return BadDrawable;

            if (vlist) {
                pid = NEXT_VAL(Pixmap);
                if (pid == None) {
                    clipType = CT_NONE;
                    pPixmap = NullPixmap;
                }
                else {
                    clipType = CT_PIXMAP;
                    error = cpClipMask((void **) &pPixmap, pid, pScreen,
                                       client, DixReadAccess);
                    if (error != Success) {
                        client->errorValue = pid;
                        break;
                    }
                }
            }
            else {
                pPixmap = NEXT_PTR(PixmapPtr);

                if (pPixmap)
                    clipType = CT_PIXMAP;
                else
                    clipType = CT_NONE;
            }

            if (pPixmap) {
                if ((pPixmap->drawable.depth != 1) ||
                    (pPixmap->drawable.pScreen != pScreen)) {
                    error = BadMatch;
                    break;
                }
                else {
                    clipType = CT_PIXMAP;
                    pPixmap->refcnt++;
                }
            }
            error = (*ps->ChangePictureClip) (pPicture, clipType,
                                              (void *) pPixmap, 0);
            break;
        }
        case CPGraphicsExposure:
        {
            unsigned int newe;
            newe = NEXT_VAL(unsigned int);

            if (newe <= xTrue)
                pPicture->graphicsExposures = newe;
            else {
                client->errorValue = newe;
                error = BadValue;
            }
        }
            break;
        case CPSubwindowMode:
        {
            unsigned int news;
            news = NEXT_VAL(unsigned int);

            if (news == ClipByChildren || news == IncludeInferiors)
                pPicture->subWindowMode = news;
            else {
                client->errorValue = news;
                error = BadValue;
            }
        }
            break;
        case CPPolyEdge:
        {
            unsigned int newe;
            newe = NEXT_VAL(unsigned int);

            if (newe == PolyEdgeSharp || newe == PolyEdgeSmooth)
                pPicture->polyEdge = newe;
            else {
                client->errorValue = newe;
                error = BadValue;
            }
        }
            break;
        case CPPolyMode:
        {
            unsigned int newm;
            newm = NEXT_VAL(unsigned int);

            if (newm == PolyModePrecise || newm == PolyModeImprecise)
                pPicture->polyMode = newm;
            else {
                client->errorValue = newm;
                error = BadValue;
            }
        }
            break;
        case CPDither:
            (void) NEXT_VAL(Atom);      /* unimplemented */

            break;
        case CPComponentAlpha:
        {
            unsigned int newca;

            newca = NEXT_VAL(unsigned int);

            if (newca <= xTrue)
                pPicture->componentAlpha = newca;
            else {
                client->errorValue = newca;
                error = BadValue;
            }
        }
            break;
        default:
            client->errorValue = maskQ;
            error = BadValue;
            break;
        }
    }
    if (ps)
        (*ps->ChangePicture) (pPicture, maskQ);
    return error;
}

int
SetPictureClipRects(PicturePtr pPicture,
                    int xOrigin, int yOrigin, int nRect, xRectangle *rects)
{
    ScreenPtr pScreen = pPicture->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    RegionPtr clientClip;
    int result;

    clientClip = RegionFromRects(nRect, rects, CT_UNSORTED);
    if (!clientClip)
        return BadAlloc;
    result = (*ps->ChangePictureClip) (pPicture, CT_REGION,
                                       (void *) clientClip, 0);
    if (result == Success) {
        pPicture->clipOrigin.x = xOrigin;
        pPicture->clipOrigin.y = yOrigin;
        pPicture->stateChanges |= CPClipXOrigin | CPClipYOrigin | CPClipMask;
        pPicture->serialNumber |= GC_CHANGE_SERIAL_BIT;
    }
    return result;
}

int
SetPictureClipRegion(PicturePtr pPicture,
                     int xOrigin, int yOrigin, RegionPtr pRegion)
{
    ScreenPtr pScreen = pPicture->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    RegionPtr clientClip;
    int result;
    int type;

    if (pRegion) {
        type = CT_REGION;
        clientClip = RegionCreate(RegionExtents(pRegion),
                                  RegionNumRects(pRegion));
        if (!clientClip)
            return BadAlloc;
        if (!RegionCopy(clientClip, pRegion)) {
            RegionDestroy(clientClip);
            return BadAlloc;
        }
    }
    else {
        type = CT_NONE;
        clientClip = 0;
    }

    result = (*ps->ChangePictureClip) (pPicture, type, (void *) clientClip, 0);
    if (result == Success) {
        pPicture->clipOrigin.x = xOrigin;
        pPicture->clipOrigin.y = yOrigin;
        pPicture->stateChanges |= CPClipXOrigin | CPClipYOrigin | CPClipMask;
        pPicture->serialNumber |= GC_CHANGE_SERIAL_BIT;
    }
    return result;
}

static Bool
transformIsIdentity(PictTransform * t)
{
    return ((t->matrix[0][0] == t->matrix[1][1]) &&
            (t->matrix[0][0] == t->matrix[2][2]) &&
            (t->matrix[0][0] != 0) &&
            (t->matrix[0][1] == 0) &&
            (t->matrix[0][2] == 0) &&
            (t->matrix[1][0] == 0) &&
            (t->matrix[1][2] == 0) &&
            (t->matrix[2][0] == 0) && (t->matrix[2][1] == 0));
}

int
SetPictureTransform(PicturePtr pPicture, PictTransform * transform)
{
    if (transform && transformIsIdentity(transform))
        transform = 0;

    if (transform) {
        if (!pPicture->transform) {
            pPicture->transform =
                (PictTransform *) malloc(sizeof(PictTransform));
            if (!pPicture->transform)
                return BadAlloc;
        }
        *pPicture->transform = *transform;
    }
    else {
        free(pPicture->transform);
        pPicture->transform = NULL;
    }
    pPicture->serialNumber |= GC_CHANGE_SERIAL_BIT;

    if (pPicture->pDrawable != NULL) {
        int result;
        PictureScreenPtr ps = GetPictureScreen(pPicture->pDrawable->pScreen);

        result = (*ps->ChangePictureTransform) (pPicture, transform);

        return result;
    }

    return Success;
}

static void
ValidateOnePicture(PicturePtr pPicture)
{
    if (pPicture->pDrawable &&
        pPicture->serialNumber != pPicture->pDrawable->serialNumber) {
        PictureScreenPtr ps = GetPictureScreen(pPicture->pDrawable->pScreen);

        (*ps->ValidatePicture) (pPicture, pPicture->stateChanges);
        pPicture->stateChanges = 0;
        pPicture->serialNumber = pPicture->pDrawable->serialNumber;
    }
}

void
ValidatePicture(PicturePtr pPicture)
{
    ValidateOnePicture(pPicture);
    if (pPicture->alphaMap)
        ValidateOnePicture(pPicture->alphaMap);
}

int
FreePicture(void *value, XID pid)
{
    PicturePtr pPicture = (PicturePtr) value;

    if (--pPicture->refcnt == 0) {
        free(pPicture->transform);
        free(pPicture->filter_params);

        if (pPicture->pSourcePict) {
            if (pPicture->pSourcePict->type != SourcePictTypeSolidFill)
                free(pPicture->pSourcePict->linear.stops);

            free(pPicture->pSourcePict);
        }

        if (pPicture->pDrawable) {
            ScreenPtr pScreen = pPicture->pDrawable->pScreen;
            PictureScreenPtr ps = GetPictureScreen(pScreen);

            if (pPicture->alphaMap)
                FreePicture((void *) pPicture->alphaMap, (XID) 0);
            (*ps->DestroyPicture) (pPicture);
            (*ps->DestroyPictureClip) (pPicture);
            if (pPicture->pDrawable->type == DRAWABLE_WINDOW) {
                WindowPtr pWindow = (WindowPtr) pPicture->pDrawable;
                PicturePtr *pPrev;

                for (pPrev = (PicturePtr *) dixLookupPrivateAddr
                     (&pWindow->devPrivates, PictureWindowPrivateKey);
                     *pPrev; pPrev = &(*pPrev)->pNext) {
                    if (*pPrev == pPicture) {
                        *pPrev = pPicture->pNext;
                        break;
                    }
                }
            }
            else if (pPicture->pDrawable->type == DRAWABLE_PIXMAP) {
                (*pScreen->DestroyPixmap) ((PixmapPtr) pPicture->pDrawable);
            }
        }
        dixFreeObjectWithPrivates(pPicture, PRIVATE_PICTURE);
    }
    return Success;
}

/**
 * ReduceCompositeOp is used to choose simpler ops for cases where alpha
 * channels are always one and so math on the alpha channel per pixel becomes
 * unnecessary.  It may also avoid destination reads sometimes if apps aren't
 * being careful to avoid these cases.
 */
static CARD8
ReduceCompositeOp(CARD8 op, PicturePtr pSrc, PicturePtr pMask, PicturePtr pDst,
                  INT16 xSrc, INT16 ySrc, CARD16 width, CARD16 height)
{
    Bool no_src_alpha, no_dst_alpha;

    /* Sampling off the edge of a RepeatNone picture introduces alpha
     * even if the picture itself doesn't have alpha. We don't try to
     * detect every case where we don't sample off the edge, just the
     * simplest case where there is no transform on the source
     * picture.
     */
    no_src_alpha = PICT_FORMAT_COLOR(pSrc->format) &&
        PICT_FORMAT_A(pSrc->format) == 0 &&
        (pSrc->repeatType != RepeatNone ||
         (!pSrc->transform &&
          xSrc >= 0 && ySrc >= 0 &&
          xSrc + width <= pSrc->pDrawable->width &&
          ySrc + height <= pSrc->pDrawable->height)) &&
        pSrc->alphaMap == NULL && pMask == NULL;
    no_dst_alpha = PICT_FORMAT_COLOR(pDst->format) &&
        PICT_FORMAT_A(pDst->format) == 0 && pDst->alphaMap == NULL;

    /* TODO, maybe: Conjoint and Disjoint op reductions? */

    /* Deal with simplifications where the source alpha is always 1. */
    if (no_src_alpha) {
        switch (op) {
        case PictOpOver:
            op = PictOpSrc;
            break;
        case PictOpInReverse:
            op = PictOpDst;
            break;
        case PictOpOutReverse:
            op = PictOpClear;
            break;
        case PictOpAtop:
            op = PictOpIn;
            break;
        case PictOpAtopReverse:
            op = PictOpOverReverse;
            break;
        case PictOpXor:
            op = PictOpOut;
            break;
        default:
            break;
        }
    }

    /* Deal with simplifications when the destination alpha is always 1 */
    if (no_dst_alpha) {
        switch (op) {
        case PictOpOverReverse:
            op = PictOpDst;
            break;
        case PictOpIn:
            op = PictOpSrc;
            break;
        case PictOpOut:
            op = PictOpClear;
            break;
        case PictOpAtop:
            op = PictOpOver;
            break;
        case PictOpXor:
            op = PictOpOutReverse;
            break;
        default:
            break;
        }
    }

    /* Reduce some con/disjoint ops to the basic names. */
    switch (op) {
    case PictOpDisjointClear:
    case PictOpConjointClear:
        op = PictOpClear;
        break;
    case PictOpDisjointSrc:
    case PictOpConjointSrc:
        op = PictOpSrc;
        break;
    case PictOpDisjointDst:
    case PictOpConjointDst:
        op = PictOpDst;
        break;
    default:
        break;
    }

    return op;
}

void
CompositePicture(CARD8 op,
                 PicturePtr pSrc,
                 PicturePtr pMask,
                 PicturePtr pDst,
                 INT16 xSrc,
                 INT16 ySrc,
                 INT16 xMask,
                 INT16 yMask,
                 INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
{
    PictureScreenPtr ps = GetPictureScreen(pDst->pDrawable->pScreen);

    ValidatePicture(pSrc);
    if (pMask)
        ValidatePicture(pMask);
    ValidatePicture(pDst);

    op = ReduceCompositeOp(op, pSrc, pMask, pDst, xSrc, ySrc, width, height);
    if (op == PictOpDst)
        return;

    (*ps->Composite) (op,
                      pSrc,
                      pMask,
                      pDst,
                      xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);
}

void
CompositeRects(CARD8 op,
               PicturePtr pDst,
               xRenderColor * color, int nRect, xRectangle *rects)
{
    PictureScreenPtr ps = GetPictureScreen(pDst->pDrawable->pScreen);

    ValidatePicture(pDst);
    (*ps->CompositeRects) (op, pDst, color, nRect, rects);
}

void
CompositeTrapezoids(CARD8 op,
                    PicturePtr pSrc,
                    PicturePtr pDst,
                    PictFormatPtr maskFormat,
                    INT16 xSrc, INT16 ySrc, int ntrap, xTrapezoid * traps)
{
    PictureScreenPtr ps = GetPictureScreen(pDst->pDrawable->pScreen);

    ValidatePicture(pSrc);
    ValidatePicture(pDst);
    (*ps->Trapezoids) (op, pSrc, pDst, maskFormat, xSrc, ySrc, ntrap, traps);
}

void
CompositeTriangles(CARD8 op,
                   PicturePtr pSrc,
                   PicturePtr pDst,
                   PictFormatPtr maskFormat,
                   INT16 xSrc,
                   INT16 ySrc, int ntriangles, xTriangle * triangles)
{
    PictureScreenPtr ps = GetPictureScreen(pDst->pDrawable->pScreen);

    ValidatePicture(pSrc);
    ValidatePicture(pDst);
    (*ps->Triangles) (op, pSrc, pDst, maskFormat, xSrc, ySrc, ntriangles,
                      triangles);
}

void
CompositeTriStrip(CARD8 op,
                  PicturePtr pSrc,
                  PicturePtr pDst,
                  PictFormatPtr maskFormat,
                  INT16 xSrc, INT16 ySrc, int npoints, xPointFixed * points)
{
    PictureScreenPtr ps = GetPictureScreen(pDst->pDrawable->pScreen);

    if (npoints < 3)
        return;

    ValidatePicture(pSrc);
    ValidatePicture(pDst);
    (*ps->TriStrip) (op, pSrc, pDst, maskFormat, xSrc, ySrc, npoints, points);
}

void
CompositeTriFan(CARD8 op,
                PicturePtr pSrc,
                PicturePtr pDst,
                PictFormatPtr maskFormat,
                INT16 xSrc, INT16 ySrc, int npoints, xPointFixed * points)
{
    PictureScreenPtr ps = GetPictureScreen(pDst->pDrawable->pScreen);

    if (npoints < 3)
        return;

    ValidatePicture(pSrc);
    ValidatePicture(pDst);
    (*ps->TriFan) (op, pSrc, pDst, maskFormat, xSrc, ySrc, npoints, points);
}

void
AddTraps(PicturePtr pPicture, INT16 xOff, INT16 yOff, int ntrap, xTrap * traps)
{
    PictureScreenPtr ps = GetPictureScreen(pPicture->pDrawable->pScreen);

    ValidatePicture(pPicture);
    (*ps->AddTraps) (pPicture, xOff, yOff, ntrap, traps);
}
@


1.11
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d64 1
a64 1
Bool
d85 1
a85 1
Bool
d105 1
a105 1
void
d166 1
a166 1
PictFormatPtr
d442 1
a442 1
Bool
d628 6
d668 3
d736 1
a736 1
void
d849 1
a849 1
    pGradient->gradient.stops = malloc(stopCount * sizeof(PictGradientStop));
a1443 6
    return Success;
}

int
FreePictFormat(void *pPictFormat, XID pid)
{
@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d859 5
a863 1
    pPicture = dixAllocateScreenObjectWithPrivates(NULL, PictureRec, PRIVATE_PICTURE);
d903 1
a903 1
    if (nStops < 2) {
d943 1
a943 1
    if (nStops < 2) {
d986 1
a986 1
    if (nStops < 2) {
d1399 1
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d19 1
a19 1
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
d44 3
a736 1
    pPicture->clientClipType = CT_NONE;
d1013 32
d1091 2
a1092 3
                    error = dixLookupResourceByType((void **) &pAlpha, pid,
                                                    PictureType, client,
                                                    DixReadAccess);
d1149 2
a1150 3
                    error = dixLookupResourceByType((void **) &pPixmap, pid,
                                                    RT_PIXMAP, client,
                                                    DixReadAccess);
a1364 81
}

void
CopyPicture(PicturePtr pSrc, Mask mask, PicturePtr pDst)
{
    PictureScreenPtr ps = GetPictureScreen(pSrc->pDrawable->pScreen);
    Mask origMask = mask;

    pDst->serialNumber |= GC_CHANGE_SERIAL_BIT;
    pDst->stateChanges |= mask;

    while (mask) {
        Mask bit = lowbit(mask);

        switch (bit) {
        case CPRepeat:
            pDst->repeat = pSrc->repeat;
            pDst->repeatType = pSrc->repeatType;
            break;
        case CPAlphaMap:
            if (pSrc->alphaMap &&
                pSrc->alphaMap->pDrawable->type == DRAWABLE_PIXMAP)
                pSrc->alphaMap->refcnt++;
            if (pDst->alphaMap)
                FreePicture((void *) pDst->alphaMap, (XID) 0);
            pDst->alphaMap = pSrc->alphaMap;
            break;
        case CPAlphaXOrigin:
            pDst->alphaOrigin.x = pSrc->alphaOrigin.x;
            break;
        case CPAlphaYOrigin:
            pDst->alphaOrigin.y = pSrc->alphaOrigin.y;
            break;
        case CPClipXOrigin:
            pDst->clipOrigin.x = pSrc->clipOrigin.x;
            break;
        case CPClipYOrigin:
            pDst->clipOrigin.y = pSrc->clipOrigin.y;
            break;
        case CPClipMask:
            switch (pSrc->clientClipType) {
            case CT_NONE:
                (*ps->ChangePictureClip) (pDst, CT_NONE, NULL, 0);
                break;
            case CT_REGION:
                if (!pSrc->clientClip) {
                    (*ps->ChangePictureClip) (pDst, CT_NONE, NULL, 0);
                }
                else {
                    RegionPtr clientClip;
                    RegionPtr srcClientClip = (RegionPtr) pSrc->clientClip;

                    clientClip = RegionCreate(RegionExtents(srcClientClip),
                                              RegionNumRects(srcClientClip));
                    (*ps->ChangePictureClip) (pDst, CT_REGION, clientClip, 0);
                }
                break;
            default:
                /* XXX: CT_PIXMAP unimplemented */
                break;
            }
            break;
        case CPGraphicsExposure:
            pDst->graphicsExposures = pSrc->graphicsExposures;
            break;
        case CPPolyEdge:
            pDst->polyEdge = pSrc->polyEdge;
            break;
        case CPPolyMode:
            pDst->polyMode = pSrc->polyMode;
            break;
        case CPDither:
            break;
        case CPComponentAlpha:
            pDst->componentAlpha = pSrc->componentAlpha;
            break;
        }
        mask &= ~bit;
    }

    (*ps->ChangePicture) (pDst, origMask);
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d73 1
a73 1
        FreePicture((pointer) pPicture, pPicture->id);
d448 1
a448 1
        dixLookupResourceByType((pointer *) &format->index.pColormap,
d604 1
a604 1
GetPictureBytes(pointer value, XID id, ResourceSizePtr size)
d658 1
a658 1
            (formats[n].id, PictFormatType, (pointer) (formats + n))) {
d1057 1
a1057 1
                    error = dixLookupResourceByType((pointer *) &pAlpha, pid,
d1078 1
a1078 1
                    FreePicture((pointer) pPicture->alphaMap, (XID) 0);
d1116 1
a1116 1
                    error = dixLookupResourceByType((pointer *) &pPixmap, pid,
d1146 1
a1146 1
                                              (pointer) pPixmap, 0);
d1243 1
a1243 1
                                       (pointer) clientClip, 0);
d1279 1
a1279 1
    result = (*ps->ChangePictureClip) (pPicture, type, (pointer) clientClip, 0);
d1357 1
a1357 1
                FreePicture((pointer) pDst->alphaMap, (XID) 0);
d1438 1
a1438 1
FreePicture(pointer value, XID pid)
d1457 1
a1457 1
                FreePicture((pointer) pPicture->alphaMap, (XID) 0);
d1483 1
a1483 1
FreePictFormat(pointer pPictFormat, XID pid)
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d53 8
d83 1
a83 1
PictureCloseScreen(int index, ScreenPtr pScreen)
d90 1
a90 1
    ret = (*pScreen->CloseScreen) (index, pScreen);
d602 23
d636 1
d766 2
a767 1
    pPicture = dixAllocateObjectWithPrivates(PictureRec, PRIVATE_PICTURE);
d857 1
a857 1
    pPicture = dixAllocateObjectWithPrivates(PictureRec, PRIVATE_PICTURE);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d47 5
a51 5
static int	PictureGeneration;
RESTYPE		PictureType;
RESTYPE		PictFormatType;
RESTYPE		GlyphSetType;
int		PictureCmapPolicy = PictureCmapPolicyDefault;
d54 1
a54 1
PictureDestroyWindow (WindowPtr pWindow)
d56 10
a65 11
    ScreenPtr		pScreen = pWindow->drawable.pScreen;
    PicturePtr		pPicture;
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
    Bool		ret;

    while ((pPicture = GetPictureWindow(pWindow)))
    {
	SetPictureWindow(pWindow, pPicture->pNext);
	if (pPicture->id)
	    FreeResource (pPicture->id, PictureType);
	FreePicture ((pointer) pPicture, pPicture->id);
d75 1
a75 1
PictureCloseScreen (int index, ScreenPtr pScreen)
d77 3
a79 3
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
    Bool                ret;
    int			n;
d83 1
a83 1
    PictureResetFilters (pScreen);
d85 3
a87 3
	if (ps->formats[n].type == PictTypeIndexed)
	    (*ps->CloseIndexed) (pScreen, &ps->formats[n]);
    GlyphUninit (pScreen);
d95 1
a95 1
PictureStoreColors (ColormapPtr pColormap, int ndef, xColorItem *pdef)
d97 2
a98 2
    ScreenPtr		pScreen = pColormap->pScreen;
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
d105 12
a116 15
    if (pColormap->class == PseudoColor || pColormap->class == GrayScale)
    {
	PictFormatPtr	format = ps->formats;
	int		nformats = ps->nformats;

	while (nformats--)
	{
	    if (format->type == PictTypeIndexed &&
		format->index.pColormap == pColormap)
	    {
		(*ps->UpdateIndexed) (pScreen, format, ndef, pdef);
		break;
	    }
	    format++;
	}
d121 1
a121 1
visualDepth (ScreenPtr pScreen, VisualPtr pVisual)
d123 2
a124 2
    int		d, v;
    DepthPtr	pDepth;
d126 5
a130 6
    for (d = 0; d < pScreen->numDepths; d++)
    {
	pDepth = &pScreen->allowedDepths[d];
	for (v = 0; v < pDepth->numVids; v++)
	    if (pDepth->vids[v] == pVisual->vid)
		return pDepth->depth;
d136 2
a137 2
    CARD32  format;
    CARD8   depth;
d141 1
a141 4
addFormat (FormatInitRec    formats[256],
	   int		    nformat,
	   CARD32	    format,
	   CARD8	    depth)
d143 1
a143 1
    int	n;
d146 2
a147 2
	if (formats[n].format == format && formats[n].depth == depth)
	    return nformat;
d156 1
a156 1
PictureCreateDefaultFormats (ScreenPtr pScreen, int *nformatp)
d158 12
a169 12
    int		    nformats, f;
    PictFormatPtr   pFormats;
    FormatInitRec   formats[1024];
    CARD32	    format;
    CARD8	    depth;
    VisualPtr	    pVisual;
    int		    v;
    int		    bpp;
    int		    type;
    int		    r, g, b;
    int		    d;
    DepthPtr	    pDepth;
d177 1
a177 2
					   PICT_TYPE_A,
					   8, 0, 0, 0);
d181 1
a181 2
					   PICT_TYPE_A,
					   4, 0, 0, 0);
d198 47
a244 53
    for (v = 0; v < pScreen->numVisuals; v++)
    {
	pVisual = &pScreen->visuals[v];
	depth = visualDepth (pScreen, pVisual);
	if (!depth)
	    continue;
    	bpp = BitsPerPixel (depth);
	switch (pVisual->class) {
	case DirectColor:
	case TrueColor:
	    r = Ones (pVisual->redMask);
	    g = Ones (pVisual->greenMask);
	    b = Ones (pVisual->blueMask);
	    type = PICT_TYPE_OTHER;
	    /*
	     * Current rendering code supports only three direct formats,
	     * fields must be packed together at the bottom of the pixel
	     */
	    if (pVisual->offsetBlue == 0 &&
		pVisual->offsetGreen == b &&
		pVisual->offsetRed == b + g)
	    {
		type = PICT_TYPE_ARGB;
	    }
	    else if (pVisual->offsetRed == 0 &&
		     pVisual->offsetGreen == r && 
		     pVisual->offsetBlue == r + g)
	    {
		type = PICT_TYPE_ABGR;
	    }
	    else if (pVisual->offsetRed == pVisual->offsetGreen - r &&
		     pVisual->offsetGreen == pVisual->offsetBlue - g && 
		     pVisual->offsetBlue == bpp - b)
	    {
		type = PICT_TYPE_BGRA;
	    }
	    if (type != PICT_TYPE_OTHER)
	    {
		format = PICT_FORMAT(bpp, type, 0, r, g, b);
		nformats = addFormat (formats, nformats, format, depth);
	    }
	    break;
	case StaticColor:
	case PseudoColor:
	    format = PICT_VISFORMAT (bpp, PICT_TYPE_COLOR, v);
	    nformats = addFormat (formats, nformats, format, depth);
	    break;
	case StaticGray:
	case GrayScale:
	    format = PICT_VISFORMAT (bpp, PICT_TYPE_GRAY, v);
	    nformats = addFormat (formats, nformats, format, depth);
	    break;
	}
d249 63
a311 70
    for (d = 0; d < pScreen->numDepths; d++)
    {
	pDepth = &pScreen->allowedDepths[d];
	bpp = BitsPerPixel (pDepth->depth);
	format = 0;
	switch (bpp) {
	case 16:
	    /* depth 12 formats */
	    if (pDepth->depth >= 12)
	    {
		nformats = addFormat (formats, nformats,
				      PICT_x4r4g4b4, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_x4b4g4r4, pDepth->depth);
	    }
	    /* depth 15 formats */
	    if (pDepth->depth >= 15)
	    {
		nformats = addFormat (formats, nformats,
				      PICT_x1r5g5b5, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_x1b5g5r5, pDepth->depth);
	    }
	    /* depth 16 formats */
	    if (pDepth->depth >= 16) 
	    {
		nformats = addFormat (formats, nformats,
				      PICT_a1r5g5b5, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_a1b5g5r5, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_r5g6b5, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_b5g6r5, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_a4r4g4b4, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_a4b4g4r4, pDepth->depth);
	    }
	    break;
	case 24:
	    if (pDepth->depth >= 24)
	    {
		nformats = addFormat (formats, nformats,
				      PICT_r8g8b8, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_b8g8r8, pDepth->depth);
	    }
	    break;
	case 32:
	    if (pDepth->depth >= 24)
	    {
		nformats = addFormat (formats, nformats,
				      PICT_x8r8g8b8, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_x8b8g8r8, pDepth->depth);
	    }
	    if (pDepth->depth >= 30)
	    {
		nformats = addFormat (formats, nformats,
				      PICT_a2r10g10b10, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_x2r10g10b10, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_a2b10g10r10, pDepth->depth);
		nformats = addFormat (formats, nformats,
				      PICT_x2b10g10r10, pDepth->depth);
	    }
	    break;
	}
a312 1
    
d314 1
a314 1
    pFormats = calloc(nformats, sizeof (PictFormatRec));
d316 96
a411 81
	return 0;
    for (f = 0; f < nformats; f++)
    {
        pFormats[f].id = FakeClientID (0);
	pFormats[f].depth = formats[f].depth;
	format = formats[f].format;
	pFormats[f].format = format;
	switch (PICT_FORMAT_TYPE(format)) {
	case PICT_TYPE_ARGB:
	    pFormats[f].type = PictTypeDirect;
	    
	    pFormats[f].direct.alphaMask = Mask(PICT_FORMAT_A(format));
	    if (pFormats[f].direct.alphaMask)
		pFormats[f].direct.alpha = (PICT_FORMAT_R(format) +
					    PICT_FORMAT_G(format) +
					    PICT_FORMAT_B(format));
	    
	    pFormats[f].direct.redMask = Mask(PICT_FORMAT_R(format));
	    pFormats[f].direct.red = (PICT_FORMAT_G(format) + 
				      PICT_FORMAT_B(format));
	    
	    pFormats[f].direct.greenMask = Mask(PICT_FORMAT_G(format));
	    pFormats[f].direct.green = PICT_FORMAT_B(format);
	    
	    pFormats[f].direct.blueMask = Mask(PICT_FORMAT_B(format));
	    pFormats[f].direct.blue = 0;
	    break;

	case PICT_TYPE_ABGR:
	    pFormats[f].type = PictTypeDirect;
	    
	    pFormats[f].direct.alphaMask = Mask(PICT_FORMAT_A(format));
	    if (pFormats[f].direct.alphaMask)
		pFormats[f].direct.alpha = (PICT_FORMAT_B(format) +
					    PICT_FORMAT_G(format) +
					    PICT_FORMAT_R(format));
	    
	    pFormats[f].direct.blueMask = Mask(PICT_FORMAT_B(format));
	    pFormats[f].direct.blue = (PICT_FORMAT_G(format) + 
				       PICT_FORMAT_R(format));
	    
	    pFormats[f].direct.greenMask = Mask(PICT_FORMAT_G(format));
	    pFormats[f].direct.green = PICT_FORMAT_R(format);
	    
	    pFormats[f].direct.redMask = Mask(PICT_FORMAT_R(format));
	    pFormats[f].direct.red = 0;
	    break;

	case PICT_TYPE_BGRA:
	    pFormats[f].type = PictTypeDirect;
	    
	    pFormats[f].direct.blueMask = Mask(PICT_FORMAT_B(format));
	    pFormats[f].direct.blue = (PICT_FORMAT_BPP(format) - PICT_FORMAT_B(format));

	    pFormats[f].direct.greenMask = Mask(PICT_FORMAT_G(format));
	    pFormats[f].direct.green = (PICT_FORMAT_BPP(format) - PICT_FORMAT_B(format) -
					PICT_FORMAT_G(format));

	    pFormats[f].direct.redMask = Mask(PICT_FORMAT_R(format));
	    pFormats[f].direct.red = (PICT_FORMAT_BPP(format) - PICT_FORMAT_B(format) -
				      PICT_FORMAT_G(format) - PICT_FORMAT_R(format));

	    pFormats[f].direct.alphaMask = Mask(PICT_FORMAT_A(format));
	    pFormats[f].direct.alpha = 0;
	    break;

	case PICT_TYPE_A:
	    pFormats[f].type = PictTypeDirect;

	    pFormats[f].direct.alpha = 0;
	    pFormats[f].direct.alphaMask = Mask(PICT_FORMAT_A(format));

	    /* remaining fields already set to zero */
	    break;
	    
	case PICT_TYPE_COLOR:
	case PICT_TYPE_GRAY:
	    pFormats[f].type = PictTypeIndexed;
	    pFormats[f].index.vid = pScreen->visuals[PICT_FORMAT_VIS(format)].vid;
	    break;
	}
d418 1
a418 1
PictureFindVisual (ScreenPtr pScreen, VisualID visual)
d420 3
a422 2
    int         i;
    VisualPtr   pVisual;
d424 1
a424 3
         i < pScreen->numVisuals;
         i++, pVisual++)
    {
d437 1
a437 1
	return TRUE;
d440 11
a450 9
	dixLookupResourceByType((pointer *)&format->index.pColormap,
				pScreen->defColormap, RT_COLORMAP,
				serverClient, DixGetAttrAccess);
    } else {
	VisualPtr pVisual = PictureFindVisual(pScreen, format->index.vid);
	if (CreateColormap(FakeClientID (0), pScreen, pVisual,
		    &format->index.pColormap, AllocNone, 0)
		!= Success)
	    return FALSE;
d453 1
a453 1
	return FALSE;
d458 1
a458 1
PictureInitIndexedFormats (ScreenPtr pScreen)
d460 3
a462 3
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);
    PictFormatPtr	format;
    int			nformat;
d465 1
a465 1
	return FALSE;
d469 2
a470 2
	if (!PictureInitIndexedFormat(pScreen, format++))
	    return FALSE;
d475 1
a475 1
PictureFinishInit (void)
d477 1
a477 1
    int	    s;
d479 4
a482 5
    for (s = 0; s < screenInfo.numScreens; s++)
    {
	if (!PictureInitIndexedFormats (screenInfo.screens[s]))
	    return FALSE;
	(void) AnimCurInit (screenInfo.screens[s]);
d489 1
a489 1
PictureSetSubpixelOrder (ScreenPtr pScreen, int subpixel)
d491 1
a491 1
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);
d494 1
a494 1
	return FALSE;
d497 1
a497 1
    
d501 1
a501 1
PictureGetSubpixelOrder (ScreenPtr pScreen)
d503 1
a503 1
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);
d506 1
a506 1
	return SubPixelUnknown;
d509 1
a509 1
    
d511 1
a511 1
PictureMatchVisual (ScreenPtr pScreen, int depth, VisualPtr pVisual)
d513 4
a516 4
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);
    PictFormatPtr	format;
    int			nformat;
    int			type;
d519 1
a519 1
	return 0;
d527 2
a528 2
	type = PictTypeIndexed;
	break;
d531 2
a532 2
	type = PictTypeDirect;
	break;
d534 1
a534 1
	return 0;
d536 18
a553 23
    while (nformat--)
    {
	if (format->depth == depth && format->type == type)
	{
	    if (type == PictTypeIndexed)
	    {
		if (format->index.vid == pVisual->vid)
		    return format;
	    }
	    else
	    {
		if (format->direct.redMask << format->direct.red == 
		    pVisual->redMask &&
		    format->direct.greenMask << format->direct.green == 
		    pVisual->greenMask &&
		    format->direct.blueMask << format->direct.blue == 
		    pVisual->blueMask)
		{
		    return format;
		}
	    }
	}
	format++;
d559 1
a559 1
PictureMatchFormat (ScreenPtr pScreen, int depth, CARD32 f)
d561 3
a563 3
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);
    PictFormatPtr	format;
    int			nformat;
d566 1
a566 1
	return 0;
d569 4
a572 5
    while (nformat--)
    {
	if (format->depth == depth && format->format == (f & 0xffffff))
	    return format;
	format++;
d578 1
a578 1
PictureParseCmapPolicy (const char *name)
d580 10
a589 10
    if ( strcmp (name, "default" ) == 0)
	return PictureCmapPolicyDefault;
    else if ( strcmp (name, "mono" ) == 0)
	return PictureCmapPolicyMono;
    else if ( strcmp (name, "gray" ) == 0)
	return PictureCmapPolicyGray;
    else if ( strcmp (name, "color" ) == 0)
	return PictureCmapPolicyColor;
    else if ( strcmp (name, "all" ) == 0)
	return PictureCmapPolicyAll;
d591 1
a591 1
	return PictureCmapPolicyInvalid;
d595 1
a595 1
PictureInit (ScreenPtr pScreen, PictFormatPtr formats, int nformats)
d597 15
a611 16
    PictureScreenPtr	ps;
    int			n;
    CARD32		type, a, r, g, b;
    
    if (PictureGeneration != serverGeneration)
    {
	PictureType = CreateNewResourceType (FreePicture, "PICTURE");
	if (!PictureType)
	    return FALSE;
	PictFormatType = CreateNewResourceType (FreePictFormat, "PICTFORMAT");
	if (!PictFormatType)
	    return FALSE;
	GlyphSetType = CreateNewResourceType (FreeGlyphSet, "GLYPHSET");
	if (!GlyphSetType)
	    return FALSE;
	PictureGeneration = serverGeneration;
d614 1
a614 1
	return FALSE;
d617 1
a617 1
	return FALSE;
d619 36
a654 40
    if (!formats)
    {
	formats = PictureCreateDefaultFormats (pScreen, &nformats);
	if (!formats)
	    return FALSE;
    }
    for (n = 0; n < nformats; n++)
    {
	if (!AddResource (formats[n].id, PictFormatType, (pointer) (formats+n)))
	{
	    free(formats);
	    return FALSE;
	}
	if (formats[n].type == PictTypeIndexed)
	{
            VisualPtr   pVisual = PictureFindVisual (pScreen, formats[n].index.vid);
	    if ((pVisual->class | DynamicClass) == PseudoColor)
		type = PICT_TYPE_COLOR;
	    else
		type = PICT_TYPE_GRAY;
	    a = r = g = b = 0;
	}
	else
	{
	    if ((formats[n].direct.redMask|
		 formats[n].direct.blueMask|
		 formats[n].direct.greenMask) == 0)
		type = PICT_TYPE_A;
	    else if (formats[n].direct.red > formats[n].direct.blue)
		type = PICT_TYPE_ARGB;
	    else if (formats[n].direct.red == 0)
		type = PICT_TYPE_ABGR;
	    else
		type = PICT_TYPE_BGRA;
	    a = Ones (formats[n].direct.alphaMask);
	    r = Ones (formats[n].direct.redMask);
	    g = Ones (formats[n].direct.greenMask);
	    b = Ones (formats[n].direct.blueMask);
	}
	formats[n].format = PICT_FORMAT(0,type,a,r,g,b);
d656 4
a659 5
    ps = (PictureScreenPtr) malloc(sizeof (PictureScreenRec));
    if (!ps)
    {
	free(formats);
	return FALSE;
d666 1
a666 1
    
d681 6
a686 7
    if (!PictureSetDefaultFilters (pScreen))
    {
	PictureResetFilters (pScreen);
	SetPictureScreen(pScreen, 0);
	free(formats);
	free(ps);
	return FALSE;
d693 1
a693 1
SetPictureToDefaults (PicturePtr    pPicture)
d716 1
a716 1
    pPicture->filter = PictureGetFilterId (FilterNearest, -1, TRUE);
d726 4
a729 7
CreatePicture (Picture		pid,
	       DrawablePtr	pDrawable,
	       PictFormatPtr	pFormat,
	       Mask		vmask,
	       XID		*vlist,
	       ClientPtr	client,
	       int		*error)
d731 2
a732 2
    PicturePtr		pPicture;
    PictureScreenPtr	ps = GetPictureScreen(pDrawable->pScreen);
d735 3
a737 4
    if (!pPicture)
    {
	*error = BadAlloc;
	return 0;
d747 1
a747 1
		      RT_PIXMAP, pDrawable, DixCreateAccess|DixSetAttrAccess);
d749 1
a749 1
	goto out;
d751 7
a757 9
    if (pDrawable->type == DRAWABLE_PIXMAP)
    {
	++((PixmapPtr)pDrawable)->refcnt;
	pPicture->pNext = 0;
    }
    else
    {
	pPicture->pNext = GetPictureWindow(((WindowPtr) pDrawable));
	SetPictureWindow(((WindowPtr) pDrawable), pPicture);
d760 2
a761 2
    SetPictureToDefaults (pPicture);
    
d763 1
a763 1
	*error = ChangePicture (pPicture, vmask, vlist, 0, client);
d765 1
a765 1
	*error = Success;
d767 5
a771 6
	*error = (*ps->CreatePicture) (pPicture);
out:
    if (*error != Success)
    {
	FreePicture (pPicture, (XID) 0);
	pPicture = 0;
d776 2
a777 1
static CARD32 xRenderColorToCard32(xRenderColor c)
d781 1
a781 3
        (c.red >> 8 << 16) |
        (c.green & 0xff00) |
        (c.blue >> 8);
d784 3
a786 2
static void initGradient(SourcePictPtr pGradient, int stopCount,
                         xFixed *stopPoints, xRenderColor *stopColors, int *error)
d798 1
a798 1
        if (stopPoints[i] < dpos || stopPoints[i] > (1<<16)) {
d805 1
a805 1
    pGradient->gradient.stops = malloc(stopCount*sizeof(PictGradientStop));
d819 2
a820 1
static PicturePtr createSourcePicture(void)
d823 1
d835 1
a835 1
CreateSolidPicture (Picture pid, xRenderColor *color, int *error)
d838 1
d858 3
a860 2
CreateLinearGradientPicture (Picture pid, xPointFixed *p1, xPointFixed *p2,
                             int nStops, xFixed *stops, xRenderColor *colors, int *error)
d896 4
a899 3
CreateRadialGradientPicture (Picture pid, xPointFixed *inner, xPointFixed *outer,
                             xFixed innerRadius, xFixed outerRadius,
                             int nStops, xFixed *stops, xRenderColor *colors, int *error)
d931 1
a931 1
    
d941 3
a943 2
CreateConicalGradientPicture (Picture pid, xPointFixed *center, xFixed angle,
                              int nStops, xFixed *stops, xRenderColor *colors, int *error)
d983 2
a984 5
ChangePicture (PicturePtr	pPicture,
	       Mask		vmask,
	       XID		*vlist,
	       DevUnion		*ulist,
	       ClientPtr	client)
d988 4
a991 4
    BITS32		index2;
    int			error = 0;
    BITS32		maskQ;
    
d994 197
a1190 206
    while (vmask && !error)
    {
	index2 = (BITS32) lowbit (vmask);
	vmask &= ~index2;
	pPicture->stateChanges |= index2;
	switch (index2)
	{
	case CPRepeat:
	    {
		unsigned int	newr;
		newr = NEXT_VAL(unsigned int);
		if (newr <= RepeatReflect)
		{
		    pPicture->repeat = (newr != RepeatNone);
		    pPicture->repeatType = newr;
		}
		else
		{
		    client->errorValue = newr;
		    error = BadValue;
		}
	    }
	    break;
	case CPAlphaMap:
	    {
		PicturePtr  pAlpha;
		
		if (vlist)
		{
		    Picture	pid = NEXT_VAL(Picture);

		    if (pid == None)
			pAlpha = 0;
		    else
		    {
			error = dixLookupResourceByType((pointer *)&pAlpha, pid,
						  PictureType, client,
						  DixReadAccess);
			if (error != Success)
			{
			    client->errorValue = pid;
			    break;
			}
			if (pAlpha->pDrawable == NULL ||
			    pAlpha->pDrawable->type != DRAWABLE_PIXMAP)
			{
			    client->errorValue = pid;
			    error = BadMatch;
			    break;
			}
		    }
		}
		else
		    pAlpha = NEXT_PTR(PicturePtr);
		if (!error)
		{
		    if (pAlpha && pAlpha->pDrawable->type == DRAWABLE_PIXMAP)
			pAlpha->refcnt++;
		    if (pPicture->alphaMap)
			FreePicture ((pointer) pPicture->alphaMap, (XID) 0);
		    pPicture->alphaMap = pAlpha;
		}
	    }
	    break;
	case CPAlphaXOrigin:
	    pPicture->alphaOrigin.x = NEXT_VAL(INT16);
	    break;
	case CPAlphaYOrigin:
	    pPicture->alphaOrigin.y = NEXT_VAL(INT16);
	    break;
	case CPClipXOrigin:
	    pPicture->clipOrigin.x = NEXT_VAL(INT16);
	    break;
	case CPClipYOrigin:
	    pPicture->clipOrigin.y = NEXT_VAL(INT16);
	    break;
	case CPClipMask:
	    {
		Pixmap	    pid;
		PixmapPtr   pPixmap;
		int	    clipType;
                if (!pScreen)
                    return BadDrawable;

		if (vlist)
		{
		    pid = NEXT_VAL(Pixmap);
		    if (pid == None)
		    {
			clipType = CT_NONE;
			pPixmap = NullPixmap;
		    }
		    else
		    {
			clipType = CT_PIXMAP;
			error = dixLookupResourceByType((pointer *)&pPixmap, pid,
						  RT_PIXMAP, client,
						  DixReadAccess);
			if (error != Success)
			{
			    client->errorValue = pid;
			    break;
			}
		    }
		}
		else
		{
		    pPixmap = NEXT_PTR(PixmapPtr);
		    if (pPixmap)
			clipType = CT_PIXMAP;
		    else
			clipType = CT_NONE;
		}

		if (pPixmap)
		{
		    if ((pPixmap->drawable.depth != 1) ||
			(pPixmap->drawable.pScreen != pScreen))
		    {
			error = BadMatch;
			break;
		    }
		    else
		    {
			clipType = CT_PIXMAP;
			pPixmap->refcnt++;
		    }
		}
		error = (*ps->ChangePictureClip)(pPicture, clipType,
						 (pointer)pPixmap, 0);
		break;
	    }
	case CPGraphicsExposure:
	    {
		unsigned int	newe;
		newe = NEXT_VAL(unsigned int);
		if (newe <= xTrue)
		    pPicture->graphicsExposures = newe;
		else
		{
		    client->errorValue = newe;
		    error = BadValue;
		}
	    }
	    break;
	case CPSubwindowMode:
	    {
		unsigned int	news;
		news = NEXT_VAL(unsigned int);
		if (news == ClipByChildren || news == IncludeInferiors)
		    pPicture->subWindowMode = news;
		else
		{
		    client->errorValue = news;
		    error = BadValue;
		}
	    }
	    break;
	case CPPolyEdge:
	    {
		unsigned int	newe;
		newe = NEXT_VAL(unsigned int);
		if (newe == PolyEdgeSharp || newe == PolyEdgeSmooth)
		    pPicture->polyEdge = newe;
		else
		{
		    client->errorValue = newe;
		    error = BadValue;
		}
	    }
	    break;
	case CPPolyMode:
	    {
		unsigned int	newm;
		newm = NEXT_VAL(unsigned int);
		if (newm == PolyModePrecise || newm == PolyModeImprecise)
		    pPicture->polyMode = newm;
		else
		{
		    client->errorValue = newm;
		    error = BadValue;
		}
	    }
	    break;
	case CPDither:
	    (void) NEXT_VAL(Atom); /* unimplemented */
	    break;
	case CPComponentAlpha:
	    {
		unsigned int	newca;

		newca = NEXT_VAL (unsigned int);
		if (newca <= xTrue)
		    pPicture->componentAlpha = newca;
		else
		{
		    client->errorValue = newca;
		    error = BadValue;
		}
	    }
	    break;
	default:
	    client->errorValue = maskQ;
	    error = BadValue;
	    break;
	}
d1198 7
a1204 10
SetPictureClipRects (PicturePtr	pPicture,
		     int	xOrigin,
		     int	yOrigin,
		     int	nRect,
		     xRectangle	*rects)
{
    ScreenPtr		pScreen = pPicture->pDrawable->pScreen;
    PictureScreenPtr	ps = GetPictureScreen(pScreen);
    RegionPtr		clientClip;
    int			result;
d1208 8
a1215 9
	return BadAlloc;
    result =(*ps->ChangePictureClip) (pPicture, CT_REGION, 
				      (pointer) clientClip, 0);
    if (result == Success)
    {
	pPicture->clipOrigin.x = xOrigin;
	pPicture->clipOrigin.y = yOrigin;
	pPicture->stateChanges |= CPClipXOrigin|CPClipYOrigin|CPClipMask;
	pPicture->serialNumber |= GC_CHANGE_SERIAL_BIT;
d1221 8
a1228 10
SetPictureClipRegion (PicturePtr    pPicture,
                      int           xOrigin,
                      int           yOrigin,
                      RegionPtr     pRegion)
{
    ScreenPtr           pScreen = pPicture->pDrawable->pScreen;
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
    RegionPtr           clientClip;
    int                 result;
    int                 type;
d1230 1
a1230 2
    if (pRegion)
    {
d1236 1
a1236 2
        if (!RegionCopy(clientClip, pRegion))
        {
d1241 1
a1241 2
    else
    {
d1246 2
a1247 4
    result =(*ps->ChangePictureClip) (pPicture, type,
                                      (pointer) clientClip, 0);
    if (result == Success)
    {
d1250 1
a1250 1
        pPicture->stateChanges |= CPClipXOrigin|CPClipYOrigin|CPClipMask;
d1257 1
a1257 1
transformIsIdentity(PictTransform *t)
d1266 1
a1266 2
            (t->matrix[2][0] == 0) &&
            (t->matrix[2][1] == 0));
d1270 1
a1270 2
SetPictureTransform (PicturePtr	    pPicture,
		     PictTransform  *transform)
d1272 11
a1282 12
    if (transform && transformIsIdentity (transform))
	transform = 0;
    
    if (transform)
    {
	if (!pPicture->transform)
	{
	    pPicture->transform = (PictTransform *) malloc(sizeof (PictTransform));
	    if (!pPicture->transform)
		return BadAlloc;
	}
	*pPicture->transform = *transform;
d1284 3
a1286 4
    else
    {
	free(pPicture->transform);
	pPicture->transform = NULL;
d1291 2
a1292 2
	int result;
	PictureScreenPtr ps = GetPictureScreen(pPicture->pDrawable->pScreen);
d1294 1
a1294 1
	result = (*ps->ChangePictureTransform) (pPicture, transform);
d1296 1
a1296 1
	return result;
d1303 1
a1303 3
CopyPicture (PicturePtr	pSrc,
	     Mask	mask,
	     PicturePtr	pDst)
d1312 1
a1312 1
	Mask bit = lowbit(mask);
d1314 64
a1377 64
	switch (bit)
	{
	case CPRepeat:
	    pDst->repeat = pSrc->repeat;
	    pDst->repeatType = pSrc->repeatType;
	    break;
	case CPAlphaMap:
	    if (pSrc->alphaMap && pSrc->alphaMap->pDrawable->type == DRAWABLE_PIXMAP)
		pSrc->alphaMap->refcnt++;
	    if (pDst->alphaMap)
		FreePicture ((pointer) pDst->alphaMap, (XID) 0);
	    pDst->alphaMap = pSrc->alphaMap;
	    break;
	case CPAlphaXOrigin:
	    pDst->alphaOrigin.x = pSrc->alphaOrigin.x;
	    break;
	case CPAlphaYOrigin:
	    pDst->alphaOrigin.y = pSrc->alphaOrigin.y;
	    break;
	case CPClipXOrigin:
	    pDst->clipOrigin.x = pSrc->clipOrigin.x;
	    break;
	case CPClipYOrigin:
	    pDst->clipOrigin.y = pSrc->clipOrigin.y;
	    break;
	case CPClipMask:
	    switch (pSrc->clientClipType) {
	    case CT_NONE:
		(*ps->ChangePictureClip)(pDst, CT_NONE, NULL, 0);
		break;
	    case CT_REGION:
		if (!pSrc->clientClip) {
		    (*ps->ChangePictureClip)(pDst, CT_NONE, NULL, 0);
		} else {
		    RegionPtr clientClip;
		    RegionPtr srcClientClip = (RegionPtr)pSrc->clientClip;

		    clientClip = RegionCreate(
			RegionExtents(srcClientClip),
			RegionNumRects(srcClientClip));
		    (*ps->ChangePictureClip)(pDst, CT_REGION, clientClip, 0);
		}
		break;
	    default:
		/* XXX: CT_PIXMAP unimplemented */
		break;
	    }
	    break;
	case CPGraphicsExposure:
	    pDst->graphicsExposures = pSrc->graphicsExposures;
	    break;
	case CPPolyEdge:
	    pDst->polyEdge = pSrc->polyEdge;
	    break;
	case CPPolyMode:
	    pDst->polyMode = pSrc->polyMode;
	    break;
	case CPDither:
	    break;
	case CPComponentAlpha:
	    pDst->componentAlpha = pSrc->componentAlpha;
	    break;
	}
	mask &= ~bit;
d1380 1
a1380 1
    (*ps->ChangePicture)(pDst, origMask);
d1384 1
a1384 1
ValidateOnePicture (PicturePtr pPicture)
d1386 7
a1392 7
    if (pPicture->pDrawable && pPicture->serialNumber != pPicture->pDrawable->serialNumber)
    {
	PictureScreenPtr    ps = GetPictureScreen(pPicture->pDrawable->pScreen);

	(*ps->ValidatePicture) (pPicture, pPicture->stateChanges);
	pPicture->stateChanges = 0;
	pPicture->serialNumber = pPicture->pDrawable->serialNumber;
d1399 1
a1399 1
    ValidateOnePicture (pPicture);
d1401 1
a1401 1
	ValidateOnePicture (pPicture->alphaMap);
d1405 1
a1405 2
FreePicture (pointer	value,
	     XID	pid)
d1407 15
a1421 1
    PicturePtr	pPicture = (PicturePtr) value;
a1422 17
    if (--pPicture->refcnt == 0)
    {
	free(pPicture->transform);

	if (pPicture->pSourcePict)
	{
	    if (pPicture->pSourcePict->type != SourcePictTypeSolidFill)
		free(pPicture->pSourcePict->linear.stops);

	    free(pPicture->pSourcePict);
	}

	if (pPicture->pDrawable)
	{
            ScreenPtr	    pScreen = pPicture->pDrawable->pScreen;
            PictureScreenPtr    ps = GetPictureScreen(pScreen);
	
d1424 1
a1424 1
                FreePicture ((pointer) pPicture->alphaMap, (XID) 0);
d1427 8
a1434 12
            if (pPicture->pDrawable->type == DRAWABLE_WINDOW)
            {
                WindowPtr	pWindow = (WindowPtr) pPicture->pDrawable;
                PicturePtr	*pPrev;

                for (pPrev = (PicturePtr *)dixLookupPrivateAddr
			 (&pWindow->devPrivates, PictureWindowPrivateKey);
                     *pPrev;
                     pPrev = &(*pPrev)->pNext)
                {
                    if (*pPrev == pPicture)
                    {
d1440 2
a1441 3
            else if (pPicture->pDrawable->type == DRAWABLE_PIXMAP)
            {
                (*pScreen->DestroyPixmap) ((PixmapPtr)pPicture->pDrawable);
d1444 1
a1444 1
	dixFreeObjectWithPrivates(pPicture, PRIVATE_PICTURE);
d1450 1
a1450 2
FreePictFormat (pointer	pPictFormat,
		XID     pid)
d1462 2
a1463 2
ReduceCompositeOp (CARD8 op, PicturePtr pSrc, PicturePtr pMask, PicturePtr pDst,
		   INT16 xSrc, INT16 ySrc, CARD16 width, CARD16 height)
d1474 7
a1480 8
                   PICT_FORMAT_A(pSrc->format) == 0 &&
                   (pSrc->repeatType != RepeatNone ||
		    (!pSrc->transform &&
		     xSrc >= 0 && ySrc >= 0 &&
		     xSrc + width <= pSrc->pDrawable->width &&
		     ySrc + height <= pSrc->pDrawable->height)) &&
                   pSrc->alphaMap == NULL &&
                   pMask == NULL;
d1482 1
a1482 2
                   PICT_FORMAT_A(pDst->format) == 0 &&
                   pDst->alphaMap == NULL;
d1485 1
a1485 1
 
d1487 23
a1509 24
    if (no_src_alpha)
    {
	switch (op) {
	case PictOpOver:
	    op = PictOpSrc;
	    break;
	case PictOpInReverse:
	    op = PictOpDst;
	    break;
	case PictOpOutReverse:
	    op = PictOpClear;
	    break;
	case PictOpAtop:
	    op = PictOpIn;
	    break;
	case PictOpAtopReverse:
	    op = PictOpOverReverse;
	    break;
	case PictOpXor:
	    op = PictOpOut;
	    break;
	default:
	    break;
	}
d1513 20
a1532 21
    if (no_dst_alpha)
    {
	switch (op) {
	case PictOpOverReverse:
	    op = PictOpDst;
	    break;
	case PictOpIn:
	    op = PictOpSrc;
	    break;
	case PictOpOut:
	    op = PictOpClear;
	    break;
	case PictOpAtop:
	    op = PictOpOver;
	    break;
	case PictOpXor:
	    op = PictOpOutReverse;
	    break;
	default:
	    break;
	}
d1539 2
a1540 2
	op = PictOpClear;
	break;
d1543 2
a1544 2
	op = PictOpSrc;
	break;
d1547 2
a1548 2
	op = PictOpDst;
	break;
d1550 1
a1550 1
	break;
d1557 13
a1569 16
CompositePicture (CARD8		op,
		  PicturePtr	pSrc,
		  PicturePtr	pMask,
		  PicturePtr	pDst,
		  INT16		xSrc,
		  INT16		ySrc,
		  INT16		xMask,
		  INT16		yMask,
		  INT16		xDst,
		  INT16		yDst,
		  CARD16	width,
		  CARD16	height)
{
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);
    
    ValidatePicture (pSrc);
d1571 2
a1572 2
	ValidatePicture (pMask);
    ValidatePicture (pDst);
d1574 1
a1574 1
    op = ReduceCompositeOp (op, pSrc, pMask, pDst, xSrc, ySrc, width, height);
d1576 1
a1576 1
	return;
d1579 4
a1582 11
		       pSrc,
		       pMask,
		       pDst,
		       xSrc,
		       ySrc,
		       xMask,
		       yMask,
		       xDst,
		       yDst,
		       width,
		       height);
d1586 7
a1592 9
CompositeRects (CARD8		op,
		PicturePtr	pDst,
		xRenderColor	*color,
		int		nRect,
		xRectangle      *rects)
{
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);
    
    ValidatePicture (pDst);
d1597 10
a1606 13
CompositeTrapezoids (CARD8	    op,
		     PicturePtr	    pSrc,
		     PicturePtr	    pDst,
		     PictFormatPtr  maskFormat,
		     INT16	    xSrc,
		     INT16	    ySrc,
		     int	    ntrap,
		     xTrapezoid	    *traps)
{
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);
    
    ValidatePicture (pSrc);
    ValidatePicture (pDst);
d1611 13
a1623 14
CompositeTriangles (CARD8	    op,
		    PicturePtr	    pSrc,
		    PicturePtr	    pDst,
		    PictFormatPtr   maskFormat,
		    INT16	    xSrc,
		    INT16	    ySrc,
		    int		    ntriangles,
		    xTriangle	    *triangles)
{
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);
    
    ValidatePicture (pSrc);
    ValidatePicture (pDst);
    (*ps->Triangles) (op, pSrc, pDst, maskFormat, xSrc, ySrc, ntriangles, triangles);
d1627 8
a1634 12
CompositeTriStrip (CARD8	    op,
		   PicturePtr	    pSrc,
		   PicturePtr	    pDst,
		   PictFormatPtr    maskFormat,
		   INT16	    xSrc,
		   INT16	    ySrc,
		   int		    npoints,
		   xPointFixed	    *points)
{
    xTriangle           *tris, *tri;
    int                 ntri;
    
d1637 4
a1640 12
    ntri = npoints - 2;
    tris = malloc(ntri * sizeof (xTriangle));
    if (!tris)
        return;
    for (tri = tris; npoints >= 3; npoints--, points++, tri++)
    {
        tri->p1 = points[0];
        tri->p2 = points[1];
        tri->p3 = points[2];
    }
    CompositeTriangles (op, pSrc, pDst, maskFormat, xSrc, ySrc, ntri, tris);
    free(tris);
d1644 8
a1651 13
CompositeTriFan (CARD8		op,
		 PicturePtr	pSrc,
		 PicturePtr	pDst,
		 PictFormatPtr	maskFormat,
		 INT16		xSrc,
		 INT16		ySrc,
		 int		npoints,
		 xPointFixed	*points)
{
    xTriangle		*tris, *tri;
    xPointFixed		*first;
    int			ntri;
    
d1653 5
a1657 14
	return;
    ntri = npoints - 2;
    tris = malloc(ntri * sizeof (xTriangle));
    if (!tris)
	return;
    first = points++;
    for (tri = tris; npoints >= 3; npoints--, points++, tri++)
    {
	tri->p1 = *first;
	tri->p2 = points[0];
	tri->p3 = points[1];
    }
    CompositeTriangles (op, pSrc, pDst, maskFormat, xSrc, ySrc, ntri, tris);
    free(tris);
d1661 5
a1665 9
AddTraps (PicturePtr	pPicture,
	  INT16		xOff,
	  INT16		yOff,
	  int		ntrap,
	  xTrap		*traps)
{
    PictureScreenPtr	ps = GetPictureScreen(pPicture->pDrawable->pScreen);
    
    ValidatePicture (pPicture);
a1667 1

@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d161 1
a161 1
#define Mask(n)	((n) == 32 ? 0xffffffff : ((1 << (n))-1))
a737 1
    pPicture->dither = None;
d743 1
a743 1
    pPicture->stateChanges = (1 << (CPLastBit+1)) - 1;
a813 45
static unsigned int premultiply(unsigned int x)
{
    unsigned int a = x >> 24;
    unsigned int t = (x & 0xff00ff) * a + 0x800080;
    t = (t + ((t >> 8) & 0xff00ff)) >> 8;
    t &= 0xff00ff;

    x = ((x >> 8) & 0xff) * a + 0x80;
    x = (x + ((x >> 8) & 0xff));
    x &= 0xff00;
    x |= t | (a << 24);
    return x;
}

static unsigned int INTERPOLATE_PIXEL_256(unsigned int x, unsigned int a,
                                          unsigned int y, unsigned int b)
{
    CARD32 t = (x & 0xff00ff) * a + (y & 0xff00ff) * b;
    t >>= 8;
    t &= 0xff00ff;

    x = ((x >> 8) & 0xff00ff) * a + ((y >> 8) & 0xff00ff) * b;
    x &= 0xff00ff00;
    x |= t;
    return x;
}

CARD32
PictureGradientColor (PictGradientStopPtr stop1,
		      PictGradientStopPtr stop2,
		      CARD32	          x)
{
     CARD32 current_color, next_color;
     int	   dist, idist;

     current_color = xRenderColorToCard32 (stop1->color);
     next_color    = xRenderColorToCard32 (stop2->color);

     dist  = (int) (256 * (x - stop1->x) / (stop2->x - stop1->x));
     idist = 256 - dist;

     return premultiply (INTERPOLATE_PIXEL_256 (current_color, idist,
					       next_color, dist));
}

a845 5

    pGradient->gradient.class	       = SourcePictClassUnknown;
    pGradient->gradient.stopRange      = 0xffff;
    pGradient->gradient.colorTable     = NULL;
    pGradient->gradient.colorTableSize = 0;
a919 2
#define FixedToDouble(x) ((x)/65536.)

a954 6
    radial->cdx = (radial->c2.x - radial->c1.x) / 65536.;
    radial->cdy = (radial->c2.y - radial->c1.y) / 65536.;
    radial->dr = (radial->c2.radius - radial->c1.radius) / 65536.;
    radial->A = (  radial->cdx * radial->cdx
		   + radial->cdy * radial->cdy
		   - radial->dr  * radial->dr);
d1205 1
a1205 1
	    pPicture->dither = NEXT_VAL(Atom);
d1335 2
a1336 5
	if (pPicture->transform)
	{
	    free(pPicture->transform);
	    pPicture->transform = 0;
	}
a1423 1
	    pDst->dither = pSrc->dither;
d1718 2
a1719 1
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);
d1721 14
a1734 3
    ValidatePicture (pSrc);
    ValidatePicture (pDst);
    (*ps->TriStrip) (op, pSrc, pDst, maskFormat, xSrc, ySrc, npoints, points);
d1747 3
a1749 1
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);
d1751 15
a1765 3
    ValidatePicture (pSrc);
    ValidatePicture (pDst);
    (*ps->TriFan) (op, pSrc, pDst, maskFormat, xSrc, ySrc, npoints, points);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d45 2
a46 4
static int PictureScreenPrivateKeyIndex;
DevPrivateKey PictureScreenPrivateKey = &PictureScreenPrivateKeyIndex;
static int PictureWindowPrivateKeyIndex;
DevPrivateKey	PictureWindowPrivateKey = &PictureWindowPrivateKeyIndex;
d90 2
a91 2
    xfree (ps->formats);
    xfree (ps);
d338 1
a338 1
    pFormats = xcalloc (nformats, sizeof (PictFormatRec));
d629 6
d645 1
a645 1
	    xfree (formats);
d676 1
a676 1
    ps = (PictureScreenPtr) xalloc (sizeof (PictureScreenRec));
d679 1
a679 1
	xfree (formats);
d706 2
a707 2
	xfree (formats);
	xfree (ps);
d760 1
a760 1
    pPicture = (PicturePtr)xalloc(sizeof(PictureRec));
a770 1
    pPicture->devPrivates = NULL;
d880 1
a880 1
    pGradient->gradient.stops = xalloc(stopCount*sizeof(PictGradientStop));
d902 1
a902 1
    pPicture = (PicturePtr) xalloc(sizeof(PictureRec));
a906 1
    pPicture->devPrivates = 0;
d923 1
a923 1
    pPicture->pSourcePict = (SourcePictPtr) xalloc(sizeof(PictSolidFill));
d926 1
a926 1
        xfree(pPicture);
d952 1
a952 1
    pPicture->pSourcePict = (SourcePictPtr) xalloc(sizeof(PictLinearGradient));
d955 1
a955 1
        xfree(pPicture);
d965 1
a965 1
        xfree(pPicture);
d993 1
a993 1
    pPicture->pSourcePict = (SourcePictPtr) xalloc(sizeof(PictRadialGradient));
d996 1
a996 1
        xfree(pPicture);
d1017 1
a1017 1
        xfree(pPicture);
d1041 1
a1041 1
    pPicture->pSourcePict = (SourcePictPtr) xalloc(sizeof(PictConicalGradient));
d1044 1
a1044 1
        xfree(pPicture);
d1054 1
a1054 1
        xfree(pPicture);
a1119 1
			    error = (error == BadValue) ? BadPixmap : error;
a1179 1
			    error = (error == BadValue) ? BadPixmap : error;
d1303 1
a1303 2
    clientClip = RECTS_TO_REGION(pScreen,
				 nRect, rects, CT_UNSORTED);
d1333 2
a1334 3
        clientClip = REGION_CREATE (pScreen,
                                    REGION_EXTENTS(pScreen, pRegion),
                                    REGION_NUM_RECTS(pRegion));
d1337 1
a1337 1
        if (!REGION_COPY (pSCreen, clientClip, pRegion))
d1339 1
a1339 1
            REGION_DESTROY (pScreen, clientClip);
d1386 1
a1386 1
	    pPicture->transform = (PictTransform *) xalloc (sizeof (PictTransform));
d1396 1
a1396 1
	    xfree (pPicture->transform);
d1465 3
a1467 3
		    clientClip = REGION_CREATE(pSrc->pDrawable->pScreen,
			REGION_EXTENTS(pSrc->pDrawable->pScreen, srcClientClip),
			REGION_NUM_RECTS(srcClientClip));
d1527 1
a1527 2
	if (pPicture->transform)
	    xfree (pPicture->transform);
d1532 1
a1532 1
		xfree(pPicture->pSourcePict->linear.stops);
d1534 1
a1534 1
	    xfree(pPicture->pSourcePict);
d1568 1
a1568 2
	dixFreePrivates(pPicture->devPrivates);
	xfree (pPicture);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a43 1
#include "registry.h"
d46 1
a46 1
_X_EXPORT DevPrivateKey PictureScreenPrivateKey = &PictureScreenPrivateKeyIndex;
d202 6
d225 1
a225 1
	     * Current rendering code supports only two direct formats,
a226 1
	     * and must be either RGB or BGR
d240 6
d324 11
d390 18
d452 3
a454 2
	format->index.pColormap =
	    (ColormapPtr) LookupIDByType(pScreen->defColormap, RT_COLORMAP);
d499 1
a499 1
_X_EXPORT Bool
d511 1
a511 1
_X_EXPORT int
d611 1
a611 1
_X_EXPORT Bool
d620 1
a620 1
	PictureType = CreateNewResourceType (FreePicture);
d623 1
a623 1
	PictFormatType = CreateNewResourceType (FreePictFormat);
d626 1
a626 1
	GlyphSetType = CreateNewResourceType (FreeGlyphSet);
a629 3
	RegisterResourceName (PictureType, "PICTURE");
	RegisterResourceName (PictFormatType, "PICTFORMAT");
	RegisterResourceName (GlyphSetType, "GLYPHSET");
d661 2
d664 1
a664 1
		type = PICT_TYPE_ABGR;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d46 4
a49 2
_X_EXPORT DevPrivateKey PictureScreenPrivateKey = &PictureScreenPrivateKey;
DevPrivateKey	PictureWindowPrivateKey = &PictureWindowPrivateKey;
d319 1
a319 1
    pFormats = (PictFormatPtr) xalloc (nformats * sizeof (PictFormatRec));
a321 1
    memset (pFormats, '\0', nformats * sizeof (PictFormatRec));
d1073 1
a1073 1
			error = dixLookupResource((pointer *)&pAlpha, pid,
d1134 1
a1134 1
			error = dixLookupResource((pointer *)&pPixmap, pid,
a1782 64
_X_EXPORT Bool
PictureTransformPoint3d (PictTransformPtr transform,
                         PictVectorPtr	vector)
{
    PictVector	    result;
    int		    i, j;
    xFixed_32_32    partial;
    xFixed_48_16    v;

    for (j = 0; j < 3; j++)
    {
	v = 0;
	for (i = 0; i < 3; i++)
	{
	    partial = ((xFixed_48_16) transform->matrix[j][i] *
		       (xFixed_48_16) vector->vector[i]);
	    v += partial >> 16;
	}
	if (v > MAX_FIXED_48_16 || v < MIN_FIXED_48_16)
	    return FALSE;
	result.vector[j] = (xFixed) v;
    }
    if (!result.vector[2])
	return FALSE;
    *vector = result;
    return TRUE;
}


_X_EXPORT Bool
PictureTransformPoint (PictTransformPtr transform,
		       PictVectorPtr	vector)
{
    PictVector	    result;
    int		    i, j;
    xFixed_32_32    partial;
    xFixed_48_16    v;

    for (j = 0; j < 3; j++)
    {
	v = 0;
	for (i = 0; i < 3; i++)
	{
	    partial = ((xFixed_48_16) transform->matrix[j][i] * 
		       (xFixed_48_16) vector->vector[i]);
	    v += partial >> 16;
	}
	if (v > MAX_FIXED_48_16 || v < MIN_FIXED_48_16)
	    return FALSE;
	result.vector[j] = (xFixed) v;
    }
    if (!result.vector[2])
	return FALSE;
    for (j = 0; j < 2; j++)
    {
	partial = (xFixed_48_16) result.vector[j] << 16;
	v = partial / result.vector[2];
	if (v > MAX_FIXED_48_16 || v < MIN_FIXED_48_16)
	    return FALSE;
	vector->vector[j] = (xFixed) v;
    }
    vector->vector[2] = xFixed1;
    return TRUE;
}
@


1.1
log
@Initial revision
@
text
@d43 2
d46 3
a48 3
_X_EXPORT int	PictureScreenPrivateIndex = -1;
int		PictureWindowPrivateIndex;
int		PictureGeneration;
a53 51
/* Picture Private machinery */

static int picturePrivateCount;

void
ResetPicturePrivateIndex (void)
{
    picturePrivateCount = 0;
}

int
AllocatePicturePrivateIndex (void)
{
    return picturePrivateCount++;
}

Bool
AllocatePicturePrivate (ScreenPtr pScreen, int index2, unsigned int amount)
{
    PictureScreenPtr	ps = GetPictureScreen(pScreen);
    unsigned int	oldamount;

    /* Round up sizes for proper alignment */
    amount = ((amount + (sizeof(long) - 1)) / sizeof(long)) * sizeof(long);

    if (index2 >= ps->PicturePrivateLen)
    {
	unsigned int *nsizes;

	nsizes = (unsigned int *)xrealloc(ps->PicturePrivateSizes,
					  (index2 + 1) * sizeof(unsigned int));
	if (!nsizes)
	    return FALSE;
	while (ps->PicturePrivateLen <= index2)
	{
	    nsizes[ps->PicturePrivateLen++] = 0;
	    ps->totalPictureSize += sizeof(DevUnion);
	}
	ps->PicturePrivateSizes = nsizes;
    }
    oldamount = ps->PicturePrivateSizes[index2];
    if (amount > oldamount)
    {
	ps->PicturePrivateSizes[index2] = amount;
	ps->totalPictureSize += (amount - oldamount);
    }

    return TRUE;
}


a90 2
    if (ps->PicturePrivateSizes)
	xfree (ps->PicturePrivateSizes);
d404 23
d438 2
a439 24
    {
	if (format->type == PictTypeIndexed && !format->index.pColormap)
	{
	    if (format->index.vid == pScreen->rootVisual)
		format->index.pColormap = (ColormapPtr) LookupIDByType(pScreen->defColormap,
								       RT_COLORMAP);
	    else
	    {
                VisualPtr   pVisual;

                pVisual = PictureFindVisual (pScreen, format->index.vid);
		if (CreateColormap (FakeClientID (0), pScreen,
				    pVisual,
				    &format->index.pColormap, AllocNone,
				    0) != Success)
		{
		    return FALSE;
		}
	    }
	    if (!(*ps->InitIndexed) (pScreen, format))
		return FALSE;
	}
	format++;
    }
a449 2
	if (!GlyphFinishInit (screenInfo.screens[s]))
	    return FALSE;
a587 4
	PictureScreenPrivateIndex = AllocateScreenPrivateIndex();
	if (PictureScreenPrivateIndex < 0)
	    return FALSE;
	PictureWindowPrivateIndex = AllocateWindowPrivateIndex();
a588 1
#ifdef XResExtension
a591 1
#endif
a592 3
    if (!AllocateWindowPrivate (pScreen, PictureWindowPrivateIndex, 0))
	return FALSE;
    
a638 7
    if (!GlyphInit (pScreen))
    {
	SetPictureScreen(pScreen, 0);
	xfree (formats);
	xfree (ps);
	return FALSE;
    }
a639 4
    ps->totalPictureSize = sizeof (PictureRec);
    ps->PicturePrivateSizes = 0;
    ps->PicturePrivateLen = 0;
    
a704 31
AllocatePicture (ScreenPtr  pScreen)
{
    PictureScreenPtr	ps = GetPictureScreen(pScreen);
    PicturePtr		pPicture;
    char		*ptr;
    DevUnion		*ppriv;
    unsigned int    	*sizes;
    unsigned int    	size;
    int			i;

    pPicture = (PicturePtr) xalloc (ps->totalPictureSize);
    if (!pPicture)
	return 0;
    ppriv = (DevUnion *)(pPicture + 1);
    pPicture->devPrivates = ppriv;
    sizes = ps->PicturePrivateSizes;
    ptr = (char *)(ppriv + ps->PicturePrivateLen);
    for (i = ps->PicturePrivateLen; --i >= 0; ppriv++, sizes++)
    {
	if ( (size = *sizes) )
	{
	    ppriv->ptr = (pointer)ptr;
	    ptr += size;
	}
	else
	    ppriv->ptr = (pointer)NULL;
    }
    return pPicture;
}

PicturePtr
d716 1
a716 1
    pPicture = AllocatePicture (pDrawable->pScreen);
d727 8
d754 1
d799 7
a805 33
static void initGradientColorTable(SourcePictPtr pGradient, int *error)
{
    int begin_pos, end_pos;
    xFixed incr, dpos;
    int pos, current_stop;
    PictGradientStopPtr stops = pGradient->linear.stops;
    int nstops = pGradient->linear.nstops;

    /* The position where the gradient begins and ends */
    begin_pos = (stops[0].x * PICT_GRADIENT_STOPTABLE_SIZE) >> 16;
    end_pos = (stops[nstops - 1].x * PICT_GRADIENT_STOPTABLE_SIZE) >> 16;

    pos = 0; /* The position in the color table. */

    /* Up to first point */
    while (pos <= begin_pos) {
        pGradient->linear.colorTable[pos] = xRenderColorToCard32(stops[0].color);
        ++pos;
    }

    incr =  (1<<16)/ PICT_GRADIENT_STOPTABLE_SIZE; /* the double increment. */
    dpos = incr * pos; /* The position in terms of 0-1. */

    current_stop = 0; /* We always interpolate between current and current + 1. */

    /* Gradient area */
    while (pos < end_pos) {
        unsigned int current_color = xRenderColorToCard32(stops[current_stop].color);
        unsigned int next_color = xRenderColorToCard32(stops[current_stop + 1].color);

        int dist = (int)(256*(dpos - stops[current_stop].x)
                         / (stops[current_stop+1].x - stops[current_stop].x));
        int idist = 256 - dist;
d807 2
a808 1
        pGradient->linear.colorTable[pos] = premultiply(INTERPOLATE_PIXEL_256(current_color, idist, next_color, dist));
d810 2
a811 2
        ++pos;
        dpos += incr;
d813 2
a814 9
        if (dpos > stops[current_stop + 1].x)
            ++current_stop;
    }

    /* After last point */
    while (pos < PICT_GRADIENT_STOPTABLE_SIZE) {
        pGradient->linear.colorTable[pos] = xRenderColorToCard32(stops[nstops - 1].color);
        ++pos;
    }
d830 1
a830 1
        if (stopPoints[i] <= dpos || stopPoints[i] > (1<<16)) {
d837 2
a838 2
    pGradient->linear.stops = xalloc(stopCount*sizeof(PictGradientStop));
    if (!pGradient->linear.stops) {
d843 1
a843 1
    pGradient->linear.nstops = stopCount;
d846 2
a847 2
        pGradient->linear.stops[i].x = stopPoints[i];
        pGradient->linear.stops[i].color = stopColors[i];
d849 5
a853 1
    initGradientColorTable(pGradient, error);
a860 1
    pPicture->format = PICT_a8r8g8b8;
d863 1
a907 4
    if (p1->x == p2->x && p1->y == p2->y) {
        *error = BadValue;
        return 0;
    }
a948 8
    {
        double dx = (double)(inner->x - outer->x);
        double dy = (double)(inner->y - outer->y);
        if (sqrt(dx*dx + dy*dy) + (double)(innerRadius) > (double)(outerRadius)) {
            *error = BadValue;
            return 0;
        }
    }
d960 13
a972 16
    {
        double x = (double)innerRadius / (double)outerRadius;
        radial->dx = (outer->x - inner->x);
        radial->dy = (outer->y - inner->y);
        radial->fx = (inner->x) - x*radial->dx;
        radial->fy = (inner->y) - x*radial->dy;
        radial->m = 1./(1+x);
        radial->b = -x*radial->m;
        radial->dx /= 65536.;
        radial->dy /= 65536.;
        radial->fx /= 65536.;
        radial->fy /= 65536.;
        x = outerRadius/65536.;
        radial->a = x*x - radial->dx*radial->dx - radial->dy*radial->dy;
    }

d1072 4
a1075 5
			pAlpha = (PicturePtr) SecurityLookupIDByType(client,
								     pid, 
								     PictureType, 
								     SecurityWriteAccess|SecurityReadAccess);
			if (!pAlpha)
d1078 1
a1078 1
			    error = BadPixmap;
d1133 4
a1136 5
			pPixmap = (PixmapPtr)SecurityLookupIDByType(client,
								    pid, 
								    RT_PIXMAP,
								    SecurityReadAccess);
			if (!pPixmap)
d1139 1
a1139 1
			    error = BadPixmap;
d1491 11
a1501 7
        if (!pPicture->pDrawable) {
            if (pPicture->pSourcePict) {
                if (pPicture->pSourcePict->type != SourcePictTypeSolidFill)
                    xfree(pPicture->pSourcePict->linear.stops);
                xfree(pPicture->pSourcePict);
            }
        } else {
d1514 2
a1515 1
                for (pPrev = (PicturePtr *) &((pWindow)->devPrivates[PictureWindowPrivateIndex].ptr);
d1531 1
d1550 3
a1552 2
static Bool
ReduceCompositeOp (CARD8 op, PicturePtr pSrc, PicturePtr pMask, PicturePtr pDst)
d1556 6
d1564 5
d1670 1
a1670 1
    op = ReduceCompositeOp (op, pSrc, pMask, pDst);
a1688 18
CompositeGlyphs (CARD8		op,
		 PicturePtr	pSrc,
		 PicturePtr	pDst,
		 PictFormatPtr	maskFormat,
		 INT16		xSrc,
		 INT16		ySrc,
		 int		nlist,
		 GlyphListPtr	lists,
		 GlyphPtr	*glyphs)
{
    PictureScreenPtr	ps = GetPictureScreen(pDst->pDrawable->pScreen);
    
    ValidatePicture (pSrc);
    ValidatePicture (pDst);
    (*ps->Glyphs) (op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, lists, glyphs);
}

void
a1780 3

#define MAX_FIXED_48_16	    ((xFixed_48_16) 0x7fffffff)
#define MIN_FIXED_48_16	    (-((xFixed_48_16) 1 << 31))
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d46 1
a46 1
static int	PictureGeneration;
d893 33
a925 7
CARD32
PictureGradientColor (PictGradientStopPtr stop1,
		      PictGradientStopPtr stop2,
		      CARD32	          x)
{
     CARD32 current_color, next_color;
     int	   dist, idist;
d927 1
a927 2
     current_color = xRenderColorToCard32 (stop1->color);
     next_color    = xRenderColorToCard32 (stop2->color);
d929 2
a930 2
     dist  = (int) (256 * (x - stop1->x) / (stop2->x - stop1->x));
     idist = 256 - dist;
d932 9
a940 2
     return premultiply (INTERPOLATE_PIXEL_256 (current_color, idist,
					       next_color, dist));
d956 1
a956 1
        if (stopPoints[i] < dpos || stopPoints[i] > (1<<16)) {
d963 2
a964 2
    pGradient->gradient.stops = xalloc(stopCount*sizeof(PictGradientStop));
    if (!pGradient->gradient.stops) {
d969 1
a969 1
    pGradient->gradient.nstops = stopCount;
d972 2
a973 2
        pGradient->gradient.stops[i].x = stopPoints[i];
        pGradient->gradient.stops[i].color = stopColors[i];
d975 1
a975 5

    pGradient->gradient.class	       = SourcePictClassUnknown;
    pGradient->gradient.stopRange      = 0xffff;
    pGradient->gradient.colorTable     = NULL;
    pGradient->gradient.colorTableSize = 0;
d983 1
a985 1
    pPicture->format = PICT_a8r8g8b8;
d1030 4
d1075 8
d1094 16
a1109 13
    radial->c1.x = inner->x;
    radial->c1.y = inner->y;
    radial->c1.radius = innerRadius;
    radial->c2.x = outer->x;
    radial->c2.y = outer->y;
    radial->c2.radius = outerRadius;
    radial->cdx = (radial->c2.x - radial->c1.x) / 65536.;
    radial->cdy = (radial->c2.y - radial->c1.y) / 65536.;
    radial->dr = (radial->c2.radius - radial->c1.radius) / 65536.;
    radial->A = (  radial->cdx * radial->cdx
		   + radial->cdy * radial->cdy
		   - radial->dr  * radial->dr);
    
d1212 1
a1212 1
								     DixWriteAccess|DixReadAccess);
d1274 1
a1274 1
								    DixReadAccess);
d1630 7
a1636 11

	if (pPicture->pSourcePict)
	{
	    if (pPicture->pSourcePict->type != SourcePictTypeSolidFill)
		xfree(pPicture->pSourcePict->linear.stops);

	    xfree(pPicture->pSourcePict);
	}

	if (pPicture->pDrawable)
	{
d1683 1
a1683 1
static CARD8
d1920 3
@

