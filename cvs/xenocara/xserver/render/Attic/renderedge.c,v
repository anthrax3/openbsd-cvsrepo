head	1.5;
access;
symbols
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.10
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.8
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.6
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2011.11.05.13.32.57;	author matthieu;	state dead;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.19.04.07;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.02.09.56.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.21;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.21;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.05.19;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.11.2
@
text
@/*
 * Copyright Â© 2004 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "renderedge.h"

/*
 * Compute the smallest value no less than y which is on a
 * grid row
 */

xFixed
RenderSampleCeilY (xFixed y, int n)
{
    return pixman_sample_ceil_y (y, n);
}

#define _div(a,b)    ((a) >= 0 ? (a) / (b) : -((-(a) + (b) - 1) / (b)))

/*
 * Compute the largest value no greater than y which is on a
 * grid row
 */
xFixed
RenderSampleFloorY (xFixed y, int n)
{
    return pixman_sample_floor_y (y, n);
}

/*
 * Step an edge by any amount (including negative values)
 */
void
RenderEdgeStep (RenderEdge *e, int n)
{
    pixman_edge_step (e, n);
}

/*
 * Initialize one edge structure given the line endpoints and a
 * starting y value
 */
void
RenderEdgeInit (RenderEdge	*e,
		int		n,
		xFixed		y_start,
		xFixed		x_top,
		xFixed		y_top,
		xFixed		x_bot,
		xFixed		y_bot)
{
    pixman_edge_init (e, n, y_start, x_top, y_top, x_bot, y_bot);
}

/*
 * Initialize one edge structure given a line, starting y value
 * and a pixel offset for the line
 */
void
RenderLineFixedEdgeInit (RenderEdge *e,
			 int	    n,
			 xFixed	    y,
			 xLineFixed *line,
			 int	    x_off,
			 int	    y_off)
{
    pixman_line_fixed_edge_init (e, n, y, (pixman_line_fixed_t *)line, x_off, y_off);
}

@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@@


1.3
log
@merge xserver 1.4, 1st pass
@
text
@d34 1
a34 1
_X_EXPORT xFixed
d46 1
a46 1
_X_EXPORT xFixed
d55 1
a55 1
_X_EXPORT void
d65 1
a65 1
_X_EXPORT void
d81 1
a81 1
_X_EXPORT void
@


1.2
log
@Fix for a divide by zero that can be triggered by a malicious client.
Problem reported by Derek Abdine of rapid7.com, patch by Keith Packard.
@
text
@a1 2
 * $Id: renderedge.c,v 1.1.1.1 2006/11/26 18:16:21 matthieu Exp $
 *
d37 1
a37 10
    xFixed   f = xFixedFrac(y);
    xFixed   i = xFixedFloor(y);
    
    f = ((f + Y_FRAC_FIRST(n)) / STEP_Y_SMALL(n)) * STEP_Y_SMALL(n) + Y_FRAC_FIRST(n);
    if (f > Y_FRAC_LAST(n))
    {
	f = Y_FRAC_FIRST(n);
	i += xFixed1;
    }
    return (i | f);
d49 1
a49 10
    xFixed   f = xFixedFrac(y);
    xFixed   i = xFixedFloor (y);
    
    f = _div(f - Y_FRAC_FIRST(n), STEP_Y_SMALL(n)) * STEP_Y_SMALL(n) + Y_FRAC_FIRST(n);
    if (f < Y_FRAC_FIRST(n))
    {
	f = Y_FRAC_LAST(n);
	i -= xFixed1;
    }
    return (i | f);
d58 1
a58 46
    xFixed_48_16	ne;

    e->x += n * e->stepx;
    
    ne = e->e + n * (xFixed_48_16) e->dx;
    
    if (n >= 0)
    {
	if (ne > 0)
	{
	    int nx = (ne + e->dy - 1) / e->dy;
	    e->e = ne - nx * (xFixed_48_16) e->dy;
	    e->x += nx * e->signdx;
	}
    }
    else
    {
	if (ne <= -e->dy)
	{
	    int nx = (-ne) / e->dy;
	    e->e = ne + nx * (xFixed_48_16) e->dy;
	    e->x -= nx * e->signdx;
	}
    }
}

/*
 * A private routine to initialize the multi-step
 * elements of an edge structure
 */
static void
_RenderEdgeMultiInit (RenderEdge *e, int n, xFixed *stepx_p, xFixed *dx_p)
{
    xFixed	stepx;
    xFixed_48_16	ne;
    
    ne = n * (xFixed_48_16) e->dx;
    stepx = n * e->stepx;
    if (ne > 0)
    {
	int nx = ne / e->dy;
	ne -= nx * e->dy;
	stepx += nx * e->signdx;
    }
    *dx_p = ne;
    *stepx_p = stepx;
d74 1
a74 29
    xFixed	dx, dy;

    e->x = x_top;
    e->e = 0;
    dx = x_bot - x_top;
    dy = y_bot - y_top;
    e->dy = dy;
    e->dx = 0;
    if (dy)
    {
	if (dx >= 0)
	{
	    e->signdx = 1;
	    e->stepx = dx / dy;
	    e->dx = dx % dy;
	    e->e = -dy;
	}
	else
	{
	    e->signdx = -1;
	    e->stepx = -(-dx / dy);
	    e->dx = -dx % dy;
	    e->e = 0;
	}
    
	_RenderEdgeMultiInit (e, STEP_Y_SMALL(n), &e->stepx_small, &e->dx_small);
	_RenderEdgeMultiInit (e, STEP_Y_BIG(n), &e->stepx_big, &e->dx_big);
    }
    RenderEdgeStep (e, y_start - y_top);
d89 1
a89 19
    xFixed	x_off_fixed = IntToxFixed(x_off);
    xFixed	y_off_fixed = IntToxFixed(y_off);
    xPointFixed	*top, *bot;

    if (line->p1.y <= line->p2.y)
    {
	top = &line->p1;
	bot = &line->p2;
    }
    else
    {
	top = &line->p2;
	bot = &line->p1;
    }
    RenderEdgeInit (e, n, y,
		    top->x + x_off_fixed,
		    top->y + y_off_fixed,
		    bot->x + x_off_fixed,
		    bot->y + y_off_fixed);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id$
d146 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d39 10
a48 1
    return pixman_sample_ceil_y (y, n);
d60 10
a69 1
    return pixman_sample_floor_y (y, n);
d78 46
a123 1
    pixman_edge_step (e, n);
d139 28
a166 1
    pixman_edge_init (e, n, y_start, x_top, y_top, x_bot, y_bot);
d181 19
a199 1
    pixman_line_fixed_edge_init (e, n, y, (pixman_line_fixed_t *)line, x_off, y_off);
@

