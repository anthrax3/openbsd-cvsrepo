head	1.12;
access;
symbols
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.28;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*

Copyright 1993, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#if defined(WIN32)
#include <X11/Xwinsock.h>
#endif
#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/Xos.h>
#include "scrnintstr.h"
#include "servermd.h"
#define PSZ 8
#include "fb.h"
#include "colormapst.h"
#include "gcstruct.h"
#include "input.h"
#include "mipointer.h"
#include "micmap.h"
#include <sys/types.h>
#ifdef HAVE_MMAP
#include <sys/mman.h>
#ifndef MAP_FILE
#define MAP_FILE 0
#endif
#endif                          /* HAVE_MMAP */
#include <sys/stat.h>
#include <errno.h>
#ifndef WIN32
#include <sys/param.h>
#endif
#include <X11/XWDFile.h>
#ifdef HAS_SHM
#include <sys/ipc.h>
#include <sys/shm.h>
#endif                          /* HAS_SHM */
#include "dix.h"
#include "miline.h"
#include "glx_extinit.h"
#include "randrstr.h"

#define VFB_DEFAULT_WIDTH      1280
#define VFB_DEFAULT_HEIGHT     1024
#define VFB_DEFAULT_DEPTH         8
#define VFB_DEFAULT_WHITEPIXEL    1
#define VFB_DEFAULT_BLACKPIXEL    0
#define VFB_DEFAULT_LINEBIAS      0
#define XWD_WINDOW_NAME_LEN      60

typedef struct {
    int width;
    int paddedBytesWidth;
    int paddedWidth;
    int height;
    int depth;
    int bitsPerPixel;
    int sizeInBytes;
    int ncolors;
    char *pfbMemory;
    XWDColor *pXWDCmap;
    XWDFileHeader *pXWDHeader;
    Pixel blackPixel;
    Pixel whitePixel;
    unsigned int lineBias;
    CloseScreenProcPtr closeScreen;

#ifdef HAVE_MMAP
    int mmap_fd;
    char mmap_file[MAXPATHLEN];
#endif

#ifdef HAS_SHM
    int shmid;
#endif
} vfbScreenInfo, *vfbScreenInfoPtr;

static int vfbNumScreens;
static vfbScreenInfo *vfbScreens;

static vfbScreenInfo defaultScreenInfo = {
    .width = VFB_DEFAULT_WIDTH,
    .height = VFB_DEFAULT_HEIGHT,
    .depth = VFB_DEFAULT_DEPTH,
    .blackPixel = VFB_DEFAULT_BLACKPIXEL,
    .whitePixel = VFB_DEFAULT_WHITEPIXEL,
    .lineBias = VFB_DEFAULT_LINEBIAS,
};

static Bool vfbPixmapDepths[33];

#ifdef HAVE_MMAP
static char *pfbdir = NULL;
#endif
typedef enum { NORMAL_MEMORY_FB, SHARED_MEMORY_FB, MMAPPED_FILE_FB } fbMemType;
static fbMemType fbmemtype = NORMAL_MEMORY_FB;
static char needswap = 0;
static Bool Render = TRUE;

#define swapcopy16(_dst, _src) \
    if (needswap) { CARD16 _s = _src; cpswaps(_s, _dst); } \
    else _dst = _src;

#define swapcopy32(_dst, _src) \
    if (needswap) { CARD32 _s = _src; cpswapl(_s, _dst); } \
    else _dst = _src;

static void
vfbInitializePixmapDepths(void)
{
    int i;

    vfbPixmapDepths[1] = TRUE;  /* always need bitmaps */
    for (i = 2; i <= 32; i++)
        vfbPixmapDepths[i] = FALSE;
}

static int
vfbBitsPerPixel(int depth)
{
    if (depth == 1)
        return 1;
    else if (depth <= 8)
        return 8;
    else if (depth <= 16)
        return 16;
    else
        return 32;
}

void
ddxGiveUp(enum ExitCode error)
{
    int i;

    /* clean up the framebuffers */

    switch (fbmemtype) {
#ifdef HAVE_MMAP
    case MMAPPED_FILE_FB:
        for (i = 0; i < vfbNumScreens; i++) {
            if (-1 == unlink(vfbScreens[i].mmap_file)) {
                perror("unlink");
                ErrorF("unlink %s failed, %s",
                       vfbScreens[i].mmap_file, strerror(errno));
            }
        }
        break;
#else                           /* HAVE_MMAP */
    case MMAPPED_FILE_FB:
        break;
#endif                          /* HAVE_MMAP */

#ifdef HAS_SHM
    case SHARED_MEMORY_FB:
        for (i = 0; i < vfbNumScreens; i++) {
            if (-1 == shmdt((char *) vfbScreens[i].pXWDHeader)) {
                perror("shmdt");
                ErrorF("shmdt failed, %s", strerror(errno));
            }
        }
        break;
#else                           /* HAS_SHM */
    case SHARED_MEMORY_FB:
        break;
#endif                          /* HAS_SHM */

    case NORMAL_MEMORY_FB:
        for (i = 0; i < vfbNumScreens; i++) {
            free(vfbScreens[i].pXWDHeader);
        }
        break;
    }
}

void
AbortDDX(enum ExitCode error)
{
    ddxGiveUp(error);
}

#ifdef __APPLE__
void
DarwinHandleGUI(int argc, char *argv[])
{
}
#endif

void
OsVendorInit(void)
{
}

void
OsVendorFatalError(const char *f, va_list args)
{
}

#if defined(DDXBEFORERESET)
void
ddxBeforeReset(void)
{
    return;
}
#endif

void
ddxUseMsg(void)
{
    ErrorF("-screen scrn WxHxD     set screen's width, height, depth\n");
    ErrorF("-pixdepths list-of-int support given pixmap depths\n");
    ErrorF("+/-render		   turn on/off RENDER extension support"
           "(default on)\n");
    ErrorF("-linebias n            adjust thin line pixelization\n");
    ErrorF("-blackpixel n          pixel value for black\n");
    ErrorF("-whitepixel n          pixel value for white\n");

#ifdef HAVE_MMAP
    ErrorF
        ("-fbdir directory       put framebuffers in mmap'ed files in directory\n");
#endif

#ifdef HAS_SHM
    ErrorF("-shmem                 put framebuffers in shared memory\n");
#endif
}

int
ddxProcessArgument(int argc, char *argv[], int i)
{
    static Bool firstTime = TRUE;
    static int lastScreen = -1;
    vfbScreenInfo *currentScreen;

    if (firstTime) {
        vfbInitializePixmapDepths();
        firstTime = FALSE;
    }

    if (lastScreen == -1)
        currentScreen = &defaultScreenInfo;
    else
        currentScreen = &vfbScreens[lastScreen];

#define CHECK_FOR_REQUIRED_ARGUMENTS(num) \
    if (((i + num) >= argc) || (!argv[i + num])) {                      \
      ErrorF("Required argument to %s not specified\n", argv[i]);       \
      UseMsg();                                                         \
      FatalError("Required argument to %s not specified\n", argv[i]);   \
    }

    if (strcmp(argv[i], "-screen") == 0) {      /* -screen n WxHxD */
        int screenNum;

        CHECK_FOR_REQUIRED_ARGUMENTS(2);
        screenNum = atoi(argv[i + 1]);
        /* The protocol only has a CARD8 for number of screens in the
           connection setup block, so don't allow more than that. */
        if ((screenNum < 0) || (screenNum >= 255)) {
            ErrorF("Invalid screen number %d\n", screenNum);
            UseMsg();
            FatalError("Invalid screen number %d passed to -screen\n",
                       screenNum);
        }

        if (vfbNumScreens <= screenNum) {
            vfbScreens =
                reallocarray(vfbScreens, screenNum + 1, sizeof(*vfbScreens));
            if (!vfbScreens)
                FatalError("Not enough memory for screen %d\n", screenNum);
            for (; vfbNumScreens <= screenNum; ++vfbNumScreens)
                vfbScreens[vfbNumScreens] = defaultScreenInfo;
        }

        if (3 != sscanf(argv[i + 2], "%dx%dx%d",
                        &vfbScreens[screenNum].width,
                        &vfbScreens[screenNum].height,
                        &vfbScreens[screenNum].depth)) {
            ErrorF("Invalid screen configuration %s\n", argv[i + 2]);
            UseMsg();
            FatalError("Invalid screen configuration %s for -screen %d\n",
                       argv[i + 2], screenNum);
        }

        lastScreen = screenNum;
        return 3;
    }

    if (strcmp(argv[i], "-pixdepths") == 0) {   /* -pixdepths list-of-depth */
        int depth, ret = 1;

        CHECK_FOR_REQUIRED_ARGUMENTS(1);
        while ((++i < argc) && (depth = atoi(argv[i])) != 0) {
            if (depth < 0 || depth > 32) {
                ErrorF("Invalid pixmap depth %d\n", depth);
                UseMsg();
                FatalError("Invalid pixmap depth %d passed to -pixdepths\n",
                           depth);
            }
            vfbPixmapDepths[depth] = TRUE;
            ret++;
        }
        return ret;
    }

    if (strcmp(argv[i], "+render") == 0) {      /* +render */
        Render = TRUE;
        return 1;
    }

    if (strcmp(argv[i], "-render") == 0) {      /* -render */
        Render = FALSE;
#ifdef COMPOSITE
        noCompositeExtension = TRUE;
#endif
        return 1;
    }

    if (strcmp(argv[i], "-blackpixel") == 0) {  /* -blackpixel n */
        CHECK_FOR_REQUIRED_ARGUMENTS(1);
        currentScreen->blackPixel = atoi(argv[++i]);
        return 2;
    }

    if (strcmp(argv[i], "-whitepixel") == 0) {  /* -whitepixel n */
        CHECK_FOR_REQUIRED_ARGUMENTS(1);
        currentScreen->whitePixel = atoi(argv[++i]);
        return 2;
    }

    if (strcmp(argv[i], "-linebias") == 0) {    /* -linebias n */
        CHECK_FOR_REQUIRED_ARGUMENTS(1);
        currentScreen->lineBias = atoi(argv[++i]);
        return 2;
    }

#ifdef HAVE_MMAP
    if (strcmp(argv[i], "-fbdir") == 0) {       /* -fbdir directory */
        CHECK_FOR_REQUIRED_ARGUMENTS(1);
        pfbdir = argv[++i];
        fbmemtype = MMAPPED_FILE_FB;
        return 2;
    }
#endif                          /* HAVE_MMAP */

#ifdef HAS_SHM
    if (strcmp(argv[i], "-shmem") == 0) {       /* -shmem */
        fbmemtype = SHARED_MEMORY_FB;
        return 1;
    }
#endif

    return 0;
}

static void
vfbInstallColormap(ColormapPtr pmap)
{
    ColormapPtr oldpmap = GetInstalledmiColormap(pmap->pScreen);

    if (pmap != oldpmap) {
        int entries;
        XWDFileHeader *pXWDHeader;
        VisualPtr pVisual;
        Pixel *ppix;
        xrgb *prgb;
        xColorItem *defs;
        int i;

        miInstallColormap(pmap);

        entries = pmap->pVisual->ColormapEntries;
        pXWDHeader = vfbScreens[pmap->pScreen->myNum].pXWDHeader;
        pVisual = pmap->pVisual;

        swapcopy32(pXWDHeader->visual_class, pVisual->class);
        swapcopy32(pXWDHeader->red_mask, pVisual->redMask);
        swapcopy32(pXWDHeader->green_mask, pVisual->greenMask);
        swapcopy32(pXWDHeader->blue_mask, pVisual->blueMask);
        swapcopy32(pXWDHeader->bits_per_rgb, pVisual->bitsPerRGBValue);
        swapcopy32(pXWDHeader->colormap_entries, pVisual->ColormapEntries);

        ppix = xallocarray(entries, sizeof(Pixel));
        prgb = xallocarray(entries, sizeof(xrgb));
        defs = xallocarray(entries, sizeof(xColorItem));

        for (i = 0; i < entries; i++)
            ppix[i] = i;
        /* XXX truecolor */
        QueryColors(pmap, entries, ppix, prgb, serverClient);

        for (i = 0; i < entries; i++) { /* convert xrgbs to xColorItems */
            defs[i].pixel = ppix[i] & 0xff;     /* change pixel to index */
            defs[i].red = prgb[i].red;
            defs[i].green = prgb[i].green;
            defs[i].blue = prgb[i].blue;
            defs[i].flags = DoRed | DoGreen | DoBlue;
        }
        (*pmap->pScreen->StoreColors) (pmap, entries, defs);

        free(ppix);
        free(prgb);
        free(defs);
    }
}

static void
vfbStoreColors(ColormapPtr pmap, int ndef, xColorItem * pdefs)
{
    XWDColor *pXWDCmap;
    int i;

    if (pmap != GetInstalledmiColormap(pmap->pScreen)) {
        return;
    }

    pXWDCmap = vfbScreens[pmap->pScreen->myNum].pXWDCmap;

    if ((pmap->pVisual->class | DynamicClass) == DirectColor) {
        return;
    }

    for (i = 0; i < ndef; i++) {
        if (pdefs[i].flags & DoRed) {
            swapcopy16(pXWDCmap[pdefs[i].pixel].red, pdefs[i].red);
        }
        if (pdefs[i].flags & DoGreen) {
            swapcopy16(pXWDCmap[pdefs[i].pixel].green, pdefs[i].green);
        }
        if (pdefs[i].flags & DoBlue) {
            swapcopy16(pXWDCmap[pdefs[i].pixel].blue, pdefs[i].blue);
        }
    }
}

static Bool
vfbSaveScreen(ScreenPtr pScreen, int on)
{
    return TRUE;
}

#ifdef HAVE_MMAP

/* this flushes any changes to the screens out to the mmapped file */
static void
vfbBlockHandler(void *blockData, OSTimePtr pTimeout, void *pReadmask)
{
    int i;

    for (i = 0; i < vfbNumScreens; i++) {
#ifdef MS_ASYNC
        if (-1 == msync((caddr_t) vfbScreens[i].pXWDHeader,
                        (size_t) vfbScreens[i].sizeInBytes, MS_ASYNC))
#else
        /* silly NetBSD and who else? */
        if (-1 == msync((caddr_t) vfbScreens[i].pXWDHeader,
                        (size_t) vfbScreens[i].sizeInBytes))
#endif
        {
            perror("msync");
            ErrorF("msync failed, %s", strerror(errno));
        }
    }
}

static void
vfbWakeupHandler(void *blockData, int result, void *pReadmask)
{
}

static void
vfbAllocateMmappedFramebuffer(vfbScreenInfoPtr pvfb)
{
#define DUMMY_BUFFER_SIZE 65536
    char dummyBuffer[DUMMY_BUFFER_SIZE];
    int currentFileSize, writeThisTime;

    snprintf(pvfb->mmap_file, sizeof(pvfb->mmap_file), "%s/Xvfb_screen%d",
             pfbdir, (int) (pvfb - vfbScreens));
    if (-1 == (pvfb->mmap_fd = open(pvfb->mmap_file, O_CREAT | O_RDWR, 0666))) {
        perror("open");
        ErrorF("open %s failed, %s", pvfb->mmap_file, strerror(errno));
        return;
    }

    /* Extend the file to be the proper size */

    memset(dummyBuffer, 0, DUMMY_BUFFER_SIZE);
    for (currentFileSize = 0;
         currentFileSize < pvfb->sizeInBytes;
         currentFileSize += writeThisTime) {
        writeThisTime = min(DUMMY_BUFFER_SIZE,
                            pvfb->sizeInBytes - currentFileSize);
        if (-1 == write(pvfb->mmap_fd, dummyBuffer, writeThisTime)) {
            perror("write");
            ErrorF("write %s failed, %s", pvfb->mmap_file, strerror(errno));
            return;
        }
    }

    /* try to mmap the file */

    pvfb->pXWDHeader = (XWDFileHeader *) mmap((caddr_t) NULL, pvfb->sizeInBytes,
                                              PROT_READ | PROT_WRITE,
                                              MAP_FILE | MAP_SHARED,
                                              pvfb->mmap_fd, 0);
    if (-1 == (long) pvfb->pXWDHeader) {
        perror("mmap");
        ErrorF("mmap %s failed, %s", pvfb->mmap_file, strerror(errno));
        pvfb->pXWDHeader = NULL;
        return;
    }

    if (!RegisterBlockAndWakeupHandlers(vfbBlockHandler, vfbWakeupHandler,
                                        NULL)) {
        pvfb->pXWDHeader = NULL;
    }
}
#endif                          /* HAVE_MMAP */

#ifdef HAS_SHM
static void
vfbAllocateSharedMemoryFramebuffer(vfbScreenInfoPtr pvfb)
{
    /* create the shared memory segment */

    pvfb->shmid = shmget(IPC_PRIVATE, pvfb->sizeInBytes, IPC_CREAT | 0777);
    if (pvfb->shmid < 0) {
        perror("shmget");
        ErrorF("shmget %d bytes failed, %s", pvfb->sizeInBytes,
               strerror(errno));
        return;
    }

    /* try to attach it */

    pvfb->pXWDHeader = (XWDFileHeader *) shmat(pvfb->shmid, 0, 0);
    if (-1 == (long) pvfb->pXWDHeader) {
        perror("shmat");
        ErrorF("shmat failed, %s", strerror(errno));
        pvfb->pXWDHeader = NULL;
        return;
    }

    ErrorF("screen %d shmid %d\n", (int) (pvfb - vfbScreens), pvfb->shmid);
}
#endif                          /* HAS_SHM */

static char *
vfbAllocateFramebufferMemory(vfbScreenInfoPtr pvfb)
{
    if (pvfb->pfbMemory)
        return pvfb->pfbMemory; /* already done */

    pvfb->sizeInBytes = pvfb->paddedBytesWidth * pvfb->height;

    /* Calculate how many entries in colormap.  This is rather bogus, because
     * the visuals haven't even been set up yet, but we need to know because we
     * have to allocate space in the file for the colormap.  The number 10
     * below comes from the MAX_PSEUDO_DEPTH define in cfbcmap.c.
     */

    if (pvfb->depth <= 10) {    /* single index colormaps */
        pvfb->ncolors = 1 << pvfb->depth;
    }
    else {                      /* decomposed colormaps */
        int nplanes_per_color_component = pvfb->depth / 3;

        if (pvfb->depth % 3)
            nplanes_per_color_component++;
        pvfb->ncolors = 1 << nplanes_per_color_component;
    }

    /* add extra bytes for XWDFileHeader, window name, and colormap */

    pvfb->sizeInBytes += SIZEOF(XWDheader) + XWD_WINDOW_NAME_LEN +
        pvfb->ncolors * SIZEOF(XWDColor);

    pvfb->pXWDHeader = NULL;
    switch (fbmemtype) {
#ifdef HAVE_MMAP
    case MMAPPED_FILE_FB:
        vfbAllocateMmappedFramebuffer(pvfb);
        break;
#else
    case MMAPPED_FILE_FB:
        break;
#endif

#ifdef HAS_SHM
    case SHARED_MEMORY_FB:
        vfbAllocateSharedMemoryFramebuffer(pvfb);
        break;
#else
    case SHARED_MEMORY_FB:
        break;
#endif

    case NORMAL_MEMORY_FB:
        pvfb->pXWDHeader = (XWDFileHeader *) malloc(pvfb->sizeInBytes);
        break;
    }

    if (pvfb->pXWDHeader) {
        pvfb->pXWDCmap = (XWDColor *) ((char *) pvfb->pXWDHeader
                                       + SIZEOF(XWDheader) +
                                       XWD_WINDOW_NAME_LEN);
        pvfb->pfbMemory = (char *) (pvfb->pXWDCmap + pvfb->ncolors);

        return pvfb->pfbMemory;
    }
    else
        return NULL;
}

static void
vfbWriteXWDFileHeader(ScreenPtr pScreen)
{
    vfbScreenInfoPtr pvfb = &vfbScreens[pScreen->myNum];
    XWDFileHeader *pXWDHeader = pvfb->pXWDHeader;
    char hostname[XWD_WINDOW_NAME_LEN];
    unsigned long swaptest = 1;
    int i;

    needswap = *(char *) &swaptest;

    pXWDHeader->header_size =
        (char *) pvfb->pXWDCmap - (char *) pvfb->pXWDHeader;
    pXWDHeader->file_version = XWD_FILE_VERSION;

    pXWDHeader->pixmap_format = ZPixmap;
    pXWDHeader->pixmap_depth = pvfb->depth;
    pXWDHeader->pixmap_height = pXWDHeader->window_height = pvfb->height;
    pXWDHeader->xoffset = 0;
    pXWDHeader->byte_order = IMAGE_BYTE_ORDER;
    pXWDHeader->bitmap_bit_order = BITMAP_BIT_ORDER;
#ifndef INTERNAL_VS_EXTERNAL_PADDING
    pXWDHeader->pixmap_width = pXWDHeader->window_width = pvfb->width;
    pXWDHeader->bitmap_unit = BITMAP_SCANLINE_UNIT;
    pXWDHeader->bitmap_pad = BITMAP_SCANLINE_PAD;
#else
    pXWDHeader->pixmap_width = pXWDHeader->window_width = pvfb->paddedWidth;
    pXWDHeader->bitmap_unit = BITMAP_SCANLINE_UNIT_PROTO;
    pXWDHeader->bitmap_pad = BITMAP_SCANLINE_PAD_PROTO;
#endif
    pXWDHeader->bits_per_pixel = pvfb->bitsPerPixel;
    pXWDHeader->bytes_per_line = pvfb->paddedBytesWidth;
    pXWDHeader->ncolors = pvfb->ncolors;

    /* visual related fields are written when colormap is installed */

    pXWDHeader->window_x = pXWDHeader->window_y = 0;
    pXWDHeader->window_bdrwidth = 0;

    /* write xwd "window" name: Xvfb hostname:server.screen */

    if (-1 == gethostname(hostname, sizeof(hostname)))
        hostname[0] = 0;
    else
        hostname[XWD_WINDOW_NAME_LEN - 1] = 0;
    sprintf((char *) (pXWDHeader + 1), "Xvfb %s:%s.%d", hostname, display,
            pScreen->myNum);

    /* write colormap pixel slot values */

    for (i = 0; i < pvfb->ncolors; i++) {
        pvfb->pXWDCmap[i].pixel = i;
    }

    /* byte swap to most significant byte first */

    if (needswap) {
        SwapLongs((CARD32 *) pXWDHeader, SIZEOF(XWDheader) / 4);
        for (i = 0; i < pvfb->ncolors; i++) {
            swapl(&pvfb->pXWDCmap[i].pixel);
        }
    }
}

static Bool
vfbCursorOffScreen(ScreenPtr *ppScreen, int *x, int *y)
{
    return FALSE;
}

static void
vfbCrossScreen(ScreenPtr pScreen, Bool entering)
{
}

static miPointerScreenFuncRec vfbPointerCursorFuncs = {
    vfbCursorOffScreen,
    vfbCrossScreen,
    miPointerWarpCursor
};

static Bool
vfbCloseScreen(ScreenPtr pScreen)
{
    vfbScreenInfoPtr pvfb = &vfbScreens[pScreen->myNum];

    pScreen->CloseScreen = pvfb->closeScreen;

    /*
     * fb overwrites miCloseScreen, so do this here
     */
    if (pScreen->devPrivate)
        (*pScreen->DestroyPixmap) (pScreen->devPrivate);
    pScreen->devPrivate = NULL;

    return pScreen->CloseScreen(pScreen);
}

static Bool
vfbRROutputValidateMode(ScreenPtr           pScreen,
                        RROutputPtr         output,
                        RRModePtr           mode)
{
    rrScrPriv(pScreen);

    if (pScrPriv->minWidth <= mode->mode.width &&
        pScrPriv->maxWidth >= mode->mode.width &&
        pScrPriv->minHeight <= mode->mode.height &&
        pScrPriv->maxHeight >= mode->mode.height)
        return TRUE;
    else
        return FALSE;
}

static Bool
vfbRRScreenSetSize(ScreenPtr  pScreen,
                   CARD16     width,
                   CARD16     height,
                   CARD32     mmWidth,
                   CARD32     mmHeight)
{
    // Prevent screen updates while we change things around
    SetRootClip(pScreen, ROOT_CLIP_NONE);

    pScreen->width = width;
    pScreen->height = height;
    pScreen->mmWidth = mmWidth;
    pScreen->mmHeight = mmHeight;

    // Restore the ability to update screen, now with new dimensions
    SetRootClip(pScreen, ROOT_CLIP_FULL);

    RRScreenSizeNotify (pScreen);
    RRTellChanged(pScreen);

    return TRUE;
}

static Bool
vfbRRCrtcSet(ScreenPtr pScreen,
             RRCrtcPtr crtc,
             RRModePtr mode,
             int       x,
             int       y,
             Rotation  rotation,
             int       numOutput,
             RROutputPtr *outputs)
{
  return RRCrtcNotify(crtc, mode, x, y, rotation, NULL, numOutput, outputs);
}

static Bool
vfbRRGetInfo(ScreenPtr pScreen, Rotation *rotations)
{
    return TRUE;
}

static Bool
vfbRandRInit(ScreenPtr pScreen)
{
    rrScrPrivPtr pScrPriv;
#if RANDR_12_INTERFACE
    RRModePtr  mode;
    RRCrtcPtr  crtc;
    RROutputPtr        output;
    xRRModeInfo modeInfo;
    char       name[64];
#endif

    if (!RRScreenInit (pScreen))
       return FALSE;
    pScrPriv = rrGetScrPriv(pScreen);
    pScrPriv->rrGetInfo = vfbRRGetInfo;
#if RANDR_12_INTERFACE
    pScrPriv->rrCrtcSet = vfbRRCrtcSet;
    pScrPriv->rrScreenSetSize = vfbRRScreenSetSize;
    pScrPriv->rrOutputSetProperty = NULL;
#if RANDR_13_INTERFACE
    pScrPriv->rrOutputGetProperty = NULL;
#endif
    pScrPriv->rrOutputValidateMode = vfbRROutputValidateMode;
    pScrPriv->rrModeDestroy = NULL;

    RRScreenSetSizeRange (pScreen,
                         1, 1,
                         pScreen->width, pScreen->height);

    sprintf (name, "%dx%d", pScreen->width, pScreen->height);
    memset (&modeInfo, '\0', sizeof (modeInfo));
    modeInfo.width = pScreen->width;
    modeInfo.height = pScreen->height;
    modeInfo.nameLength = strlen (name);

    mode = RRModeGet (&modeInfo, name);
    if (!mode)
       return FALSE;

    crtc = RRCrtcCreate (pScreen, NULL);
    if (!crtc)
       return FALSE;

    output = RROutputCreate (pScreen, "screen", 6, NULL);
    if (!output)
       return FALSE;
    if (!RROutputSetClones (output, NULL, 0))
       return FALSE;
    if (!RROutputSetModes (output, &mode, 1, 0))
       return FALSE;
    if (!RROutputSetCrtcs (output, &crtc, 1))
       return FALSE;
    if (!RROutputSetConnection (output, RR_Connected))
       return FALSE;
    RRCrtcNotify (crtc, mode, 0, 0, RR_Rotate_0, NULL, 1, &output);
#endif
    return TRUE;
}

static Bool
vfbScreenInit(ScreenPtr pScreen, int argc, char **argv)
{
    vfbScreenInfoPtr pvfb = &vfbScreens[pScreen->myNum];
    int dpix = monitorResolution, dpiy = monitorResolution;
    int ret;
    char *pbits;

    if (dpix == 0)
        dpix = 100;

    if (dpiy == 0)
        dpiy = 100;

    pvfb->paddedBytesWidth = PixmapBytePad(pvfb->width, pvfb->depth);
    pvfb->bitsPerPixel = vfbBitsPerPixel(pvfb->depth);
    if (pvfb->bitsPerPixel >= 8)
        pvfb->paddedWidth = pvfb->paddedBytesWidth / (pvfb->bitsPerPixel / 8);
    else
        pvfb->paddedWidth = pvfb->paddedBytesWidth * 8;
    pbits = vfbAllocateFramebufferMemory(pvfb);
    if (!pbits)
        return FALSE;

    switch (pvfb->depth) {
    case 8:
        miSetVisualTypesAndMasks(8,
                                 ((1 << StaticGray) |
                                  (1 << GrayScale) |
                                  (1 << StaticColor) |
                                  (1 << PseudoColor) |
                                  (1 << TrueColor) |
                                  (1 << DirectColor)), 8, PseudoColor, 0, 0, 0);
        break;
    case 15:
        miSetVisualTypesAndMasks(15,
                                 ((1 << TrueColor) |
                                  (1 << DirectColor)),
                                 8, TrueColor, 0x7c00, 0x03e0, 0x001f);
        break;
    case 16:
        miSetVisualTypesAndMasks(16,
                                 ((1 << TrueColor) |
                                  (1 << DirectColor)),
                                 8, TrueColor, 0xf800, 0x07e0, 0x001f);
        break;
    case 24:
        miSetVisualTypesAndMasks(24,
                                 ((1 << TrueColor) |
                                  (1 << DirectColor)),
                                 8, TrueColor, 0xff0000, 0x00ff00, 0x0000ff);
        break;
    case 30:
        miSetVisualTypesAndMasks(30,
                                 ((1 << TrueColor) |
                                  (1 << DirectColor)),
                                 10, TrueColor, 0x3ff00000, 0x000ffc00,
                                 0x000003ff);
        break;
    default:
        return FALSE;
    }

    miSetPixmapDepths();

    ret = fbScreenInit(pScreen, pbits, pvfb->width, pvfb->height,
                       dpix, dpiy, pvfb->paddedWidth, pvfb->bitsPerPixel);
    if (ret && Render)
        fbPictureInit(pScreen, 0, 0);

    if (!ret)
        return FALSE;

    if (!vfbRandRInit(pScreen))
       return FALSE;

    pScreen->InstallColormap = vfbInstallColormap;

    pScreen->SaveScreen = vfbSaveScreen;
    pScreen->StoreColors = vfbStoreColors;

    miDCInitialize(pScreen, &vfbPointerCursorFuncs);

    vfbWriteXWDFileHeader(pScreen);

    pScreen->blackPixel = pvfb->blackPixel;
    pScreen->whitePixel = pvfb->whitePixel;

    ret = fbCreateDefColormap(pScreen);

    miSetZeroLineBias(pScreen, pvfb->lineBias);

    pvfb->closeScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = vfbCloseScreen;

    return ret;

}                               /* end vfbScreenInit */

static const ExtensionModule vfbExtensions[] = {
#ifdef GLXEXT
    { GlxExtensionInit, "GLX", &noGlxExtension },
#endif
};

static
void vfbExtensionInit(void)
{
    LoadExtensionList(vfbExtensions, ARRAY_SIZE(vfbExtensions), TRUE);
}

void
InitOutput(ScreenInfo * screen_info, int argc, char **argv)
{
    int i;
    int NumFormats = 0;

    if (serverGeneration == 1)
        vfbExtensionInit();

    /* initialize pixmap formats */

    /* must have a pixmap depth to match every screen depth */
    for (i = 0; i < vfbNumScreens; i++) {
        vfbPixmapDepths[vfbScreens[i].depth] = TRUE;
    }

    /* RENDER needs a good set of pixmaps. */
    if (Render) {
        vfbPixmapDepths[1] = TRUE;
        vfbPixmapDepths[4] = TRUE;
        vfbPixmapDepths[8] = TRUE;
#if 0
        vfbPixmapDepths[12] = TRUE;
#endif
/*	vfbPixmapDepths[15] = TRUE; */
        vfbPixmapDepths[16] = TRUE;
        vfbPixmapDepths[24] = TRUE;
#if 0
        vfbPixmapDepths[30] = TRUE;
#endif
        vfbPixmapDepths[32] = TRUE;
    }

    for (i = 1; i <= 32; i++) {
        if (vfbPixmapDepths[i]) {
            if (NumFormats >= MAXFORMATS)
                FatalError("MAXFORMATS is too small for this server\n");
            screen_info->formats[NumFormats].depth = i;
            screen_info->formats[NumFormats].bitsPerPixel = vfbBitsPerPixel(i);
            screen_info->formats[NumFormats].scanlinePad = BITMAP_SCANLINE_PAD;
            NumFormats++;
        }
    }

    screen_info->imageByteOrder = IMAGE_BYTE_ORDER;
    screen_info->bitmapScanlineUnit = BITMAP_SCANLINE_UNIT;
    screen_info->bitmapScanlinePad = BITMAP_SCANLINE_PAD;
    screen_info->bitmapBitOrder = BITMAP_BIT_ORDER;
    screen_info->numPixmapFormats = NumFormats;

    /* initialize screens */

    if (vfbNumScreens < 1) {
        vfbScreens = &defaultScreenInfo;
        vfbNumScreens = 1;
    }
    for (i = 0; i < vfbNumScreens; i++) {
        if (-1 == AddScreen(vfbScreenInit, argc, argv)) {
            FatalError("Couldn't add screen %d", i);
        }
    }

}                               /* end InitOutput */
@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d69 1
d296 1
a296 1
                realloc(vfbScreens, sizeof(*vfbScreens) * (screenNum + 1));
d411 3
a413 3
        ppix = (Pixel *) malloc(entries * sizeof(Pixel));
        prgb = (xrgb *) malloc(entries * sizeof(xrgb));
        defs = (xColorItem *) malloc(entries * sizeof(xColorItem));
d743 119
d933 3
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a382 16
static DevPrivateKeyRec cmapScrPrivateKeyRec;

#define cmapScrPrivateKey (&cmapScrPrivateKeyRec)

#define GetInstalledColormap(s) ((ColormapPtr) dixLookupPrivate(&(s)->devPrivates, cmapScrPrivateKey))
#define SetInstalledColormap(s,c) (dixSetPrivate(&(s)->devPrivates, cmapScrPrivateKey, c))

static int
vfbListInstalledColormaps(ScreenPtr pScreen, Colormap * pmaps)
{
    /* By the time we are processing requests, we can guarantee that there
     * is always a colormap installed */
    *pmaps = GetInstalledColormap(pScreen)->mid;
    return 1;
}

d386 1
a386 1
    ColormapPtr oldpmap = GetInstalledColormap(pmap->pScreen);
d397 1
a397 5
        if (oldpmap != (ColormapPtr) None)
            WalkTree(pmap->pScreen, TellLostMap, (char *) &oldpmap->mid);
        /* Install pmap */
        SetInstalledColormap(pmap->pScreen, pmap);
        WalkTree(pmap->pScreen, TellGainedMap, (char *) &pmap->mid);
a434 16
vfbUninstallColormap(ColormapPtr pmap)
{
    ColormapPtr curpmap = GetInstalledColormap(pmap->pScreen);

    if (pmap == curpmap) {
        if (pmap->mid != pmap->pScreen->defColormap) {
            dixLookupResourceByType((void **) &curpmap,
                                    pmap->pScreen->defColormap,
                                    RT_COLORMAP, serverClient,
                                    DixInstallAccess);
            (*pmap->pScreen->InstallColormap) (curpmap);
        }
    }
}

static void
d440 1
a440 1
    if (pmap != GetInstalledColormap(pmap->pScreen)) {
a727 1
    int i;
a731 7
     * XXX probably lots of stuff to clean.  For now,
     * clear installed colormaps so that server reset works correctly.
     */
    for (i = 0; i < screenInfo.numScreens; i++)
        SetInstalledColormap(screenInfo.screens[i], NULL);

    /*
a748 3
    if (!dixRegisterPrivateKey(&cmapScrPrivateKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

a814 2
    pScreen->UninstallColormap = vfbUninstallColormap;
    pScreen->ListInstalledColormaps = vfbListInstalledColormaps;
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a406 1
        XWDColor *pXWDCmap;
a420 1
        pXWDCmap = vfbScreens[pmap->pScreen->myNum].pXWDCmap;
d461 1
a461 1
            dixLookupResourceByType((pointer *) &curpmap,
d509 1
a509 1
vfbBlockHandler(pointer blockData, OSTimePtr pTimeout, pointer pReadmask)
d530 1
a530 1
vfbWakeupHandler(pointer blockData, int result, pointer pReadmask)
d895 1
a895 4
    int i;

    for (i = 0; i < ARRAY_SIZE(vfbExtensions); i++)
        LoadExtension(&vfbExtensions[i], TRUE);
d899 1
a899 1
InitOutput(ScreenInfo * screenInfo, int argc, char **argv)
d935 3
a937 3
            screenInfo->formats[NumFormats].depth = i;
            screenInfo->formats[NumFormats].bitsPerPixel = vfbBitsPerPixel(i);
            screenInfo->formats[NumFormats].scanlinePad = BITMAP_SCANLINE_PAD;
d942 5
a946 5
    screenInfo->imageByteOrder = IMAGE_BYTE_ORDER;
    screenInfo->bitmapScanlineUnit = BITMAP_SCANLINE_UNIT;
    screenInfo->bitmapScanlinePad = BITMAP_SCANLINE_PAD;
    screenInfo->bitmapBitOrder = BITMAP_BIT_ORDER;
    screenInfo->numPixmapFormats = NumFormats;
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a43 1
#include "mibstore.h"
d68 1
d222 1
a222 1
OsVendorFatalError(void)
d763 1
a763 1
vfbCloseScreen(int index, ScreenPtr pScreen)
d765 1
a765 1
    vfbScreenInfoPtr pvfb = &vfbScreens[index];
d777 8
a784 1
    return pScreen->CloseScreen(index, pScreen);
d788 1
a788 1
vfbScreenInit(int index, ScreenPtr pScreen, int argc, char **argv)
d790 1
a790 1
    vfbScreenInfoPtr pvfb = &vfbScreens[index];
d888 15
d908 3
@


1.7
log
@Bugfix Update to xserver 1.11.3
@
text
@d51 1
a51 1
#ifdef HAS_MMAP
d56 1
a56 1
#endif /* HAS_MMAP */
d66 1
a66 1
#endif /* HAS_SHM */
d78 1
a78 2
typedef struct
{
d95 1
a95 1
#ifdef HAS_MMAP
d107 1
d109 1
a109 1
    .width  = VFB_DEFAULT_WIDTH,
d111 1
a111 1
    .depth  = VFB_DEFAULT_DEPTH,
d116 1
d118 2
a119 1
#ifdef HAS_MMAP
a134 1

d139 2
a140 1
    vfbPixmapDepths[1] = TRUE; /* always need bitmaps */
d142 1
a142 1
	vfbPixmapDepths[i] = FALSE;
d148 8
a155 4
    if (depth == 1) return 1;
    else if (depth <= 8) return 8;
    else if (depth <= 16) return 16;
    else return 32;
d165 12
a176 15
    switch (fbmemtype)
    {
#ifdef HAS_MMAP
    case MMAPPED_FILE_FB: 
	for (i = 0; i < vfbNumScreens; i++)
	{
	    if (-1 == unlink(vfbScreens[i].mmap_file))
	    {
		perror("unlink");
		ErrorF("unlink %s failed, %s",
		       vfbScreens[i].mmap_file, strerror(errno));
	    }
	}
	break;
#else /* HAS_MMAP */
d179 2
a180 2
#endif /* HAS_MMAP */
	
d183 8
a190 10
	for (i = 0; i < vfbNumScreens; i++)
	{
	    if (-1 == shmdt((char *)vfbScreens[i].pXWDHeader))
	    {
		perror("shmdt");
		ErrorF("shmdt failed, %s", strerror(errno));
	    }
	}
	break;
#else /* HAS_SHM */
d193 2
a194 2
#endif /* HAS_SHM */
	
d196 4
a199 5
	for (i = 0; i < vfbNumScreens; i++)
	{
	    free(vfbScreens[i].pXWDHeader);
	}
	break;
d227 2
a228 1
void ddxBeforeReset(void)
d240 1
a240 1
	   "(default on)\n");
d245 3
a247 2
#ifdef HAS_MMAP
    ErrorF("-fbdir directory       put framebuffers in mmap'ed files in directory\n");
d262 2
a263 3
    if (firstTime)
    {
	vfbInitializePixmapDepths();
d268 1
a268 1
	currentScreen = &defaultScreenInfo;
d270 1
a270 1
	currentScreen = &vfbScreens[lastScreen];
d278 62
a339 69
    
    if (strcmp (argv[i], "-screen") == 0)	/* -screen n WxHxD */
    {
	int screenNum;
	CHECK_FOR_REQUIRED_ARGUMENTS(2);
	screenNum = atoi(argv[i+1]);
	/* The protocol only has a CARD8 for number of screens in the
	   connection setup block, so don't allow more than that. */
	if ((screenNum < 0) || (screenNum >= 255))
	{
	    ErrorF("Invalid screen number %d\n", screenNum);
	    UseMsg();
	    FatalError("Invalid screen number %d passed to -screen\n",
		       screenNum);
	}

	if (vfbNumScreens <= screenNum)
	{
	    vfbScreens = realloc(vfbScreens, sizeof(*vfbScreens) * (screenNum + 1));
	    if (!vfbScreens)
		FatalError("Not enough memory for screen %d\n", screenNum);
	    for (; vfbNumScreens <= screenNum; ++vfbNumScreens)
		vfbScreens[vfbNumScreens] = defaultScreenInfo;
	}

	if (3 != sscanf(argv[i+2], "%dx%dx%d",
			&vfbScreens[screenNum].width,
			&vfbScreens[screenNum].height,
			&vfbScreens[screenNum].depth))
	{
	    ErrorF("Invalid screen configuration %s\n", argv[i+2]);
	    UseMsg();
	    FatalError("Invalid screen configuration %s for -screen %d\n",
		   argv[i+2], screenNum);
	}

	lastScreen = screenNum;
	return 3;
    }

    if (strcmp (argv[i], "-pixdepths") == 0)	/* -pixdepths list-of-depth */
    {
	int depth, ret = 1;

	CHECK_FOR_REQUIRED_ARGUMENTS(1);
	while ((++i < argc) && (depth = atoi(argv[i])) != 0)
	{
	    if (depth < 0 || depth > 32)
	    {
		ErrorF("Invalid pixmap depth %d\n", depth);
		UseMsg();
		FatalError("Invalid pixmap depth %d passed to -pixdepths\n",
			   depth);
	    }
	    vfbPixmapDepths[depth] = TRUE;
	    ret++;
	}
	return ret;
    }

    if (strcmp (argv[i], "+render") == 0)	/* +render */
    {
	Render = TRUE;
	return 1;
    }

    if (strcmp (argv[i], "-render") == 0)	/* -render */
    {
	Render = FALSE;
d341 1
a341 1
	noCompositeExtension = TRUE;
d343 1
a343 1
	return 1;
d346 4
a349 5
    if (strcmp (argv[i], "-blackpixel") == 0)	/* -blackpixel n */
    {
	CHECK_FOR_REQUIRED_ARGUMENTS(1);
	currentScreen->blackPixel = atoi(argv[++i]);
	return 2;
d352 4
a355 5
    if (strcmp (argv[i], "-whitepixel") == 0)	/* -whitepixel n */
    {
	CHECK_FOR_REQUIRED_ARGUMENTS(1);
	currentScreen->whitePixel = atoi(argv[++i]);
	return 2;
d358 4
a361 5
    if (strcmp (argv[i], "-linebias") == 0)	/* -linebias n */
    {
	CHECK_FOR_REQUIRED_ARGUMENTS(1);
	currentScreen->lineBias = atoi(argv[++i]);
	return 2;
d364 6
a369 7
#ifdef HAS_MMAP
    if (strcmp (argv[i], "-fbdir") == 0)	/* -fbdir directory */
    {
	CHECK_FOR_REQUIRED_ARGUMENTS(1);
	pfbdir = argv[++i];
	fbmemtype = MMAPPED_FILE_FB;
	return 2;
d371 1
a371 1
#endif /* HAS_MMAP */
d374 3
a376 4
    if (strcmp (argv[i], "-shmem") == 0)	/* -shmem */
    {
	fbmemtype = SHARED_MEMORY_FB;
	return 1;
d384 1
d391 1
a391 1
vfbListInstalledColormaps(ScreenPtr pScreen, Colormap *pmaps)
a398 1

d404 49
a452 49
    if (pmap != oldpmap)
    {
	int entries;
	XWDFileHeader *pXWDHeader;
	XWDColor *pXWDCmap;
	VisualPtr pVisual;
	Pixel *     ppix;
	xrgb *      prgb;
	xColorItem *defs;
	int i;

	if(oldpmap != (ColormapPtr)None)
	    WalkTree(pmap->pScreen, TellLostMap, (char *)&oldpmap->mid);
	/* Install pmap */
	SetInstalledColormap(pmap->pScreen, pmap);
	WalkTree(pmap->pScreen, TellGainedMap, (char *)&pmap->mid);

	entries = pmap->pVisual->ColormapEntries;
	pXWDHeader = vfbScreens[pmap->pScreen->myNum].pXWDHeader;
	pXWDCmap = vfbScreens[pmap->pScreen->myNum].pXWDCmap;
	pVisual = pmap->pVisual;

	swapcopy32(pXWDHeader->visual_class, pVisual->class);
	swapcopy32(pXWDHeader->red_mask, pVisual->redMask);
	swapcopy32(pXWDHeader->green_mask, pVisual->greenMask);
	swapcopy32(pXWDHeader->blue_mask, pVisual->blueMask);
	swapcopy32(pXWDHeader->bits_per_rgb, pVisual->bitsPerRGBValue);
	swapcopy32(pXWDHeader->colormap_entries, pVisual->ColormapEntries);

	ppix = (Pixel *)malloc(entries * sizeof(Pixel));
	prgb = (xrgb *)malloc(entries * sizeof(xrgb));
	defs = (xColorItem *)malloc(entries * sizeof(xColorItem));

	for (i = 0; i < entries; i++)  ppix[i] = i;
	/* XXX truecolor */
	QueryColors(pmap, entries, ppix, prgb, serverClient);

	for (i = 0; i < entries; i++) { /* convert xrgbs to xColorItems */
	    defs[i].pixel = ppix[i] & 0xff; /* change pixel to index */
	    defs[i].red = prgb[i].red;
	    defs[i].green = prgb[i].green;
	    defs[i].blue = prgb[i].blue;
	    defs[i].flags =  DoRed|DoGreen|DoBlue;
	}
	(*pmap->pScreen->StoreColors)(pmap, entries, defs);

	free(ppix);
	free(prgb);
	free(defs);
d461 8
a468 10
    if(pmap == curpmap)
    {
	if (pmap->mid != pmap->pScreen->defColormap)
	{
	    dixLookupResourceByType((pointer *)&curpmap,
				    pmap->pScreen->defColormap,
				    RT_COLORMAP, serverClient,
				    DixInstallAccess);
	    (*pmap->pScreen->InstallColormap)(curpmap);
	}
d473 1
a473 1
vfbStoreColors(ColormapPtr pmap, int ndef, xColorItem *pdefs)
d478 2
a479 3
    if (pmap != GetInstalledColormap(pmap->pScreen))
    {
	return;
d484 14
a497 19
    if ((pmap->pVisual->class | DynamicClass) == DirectColor)
    {
	return;
    }

    for (i = 0; i < ndef; i++)
    {
	if (pdefs[i].flags & DoRed)
	{
	    swapcopy16(pXWDCmap[pdefs[i].pixel].red, pdefs[i].red);
	}
	if (pdefs[i].flags & DoGreen)
	{
	    swapcopy16(pXWDCmap[pdefs[i].pixel].green, pdefs[i].green);
	}
	if (pdefs[i].flags & DoBlue)
	{
	    swapcopy16(pXWDCmap[pdefs[i].pixel].blue, pdefs[i].blue);
	}
d507 1
a507 1
#ifdef HAS_MMAP
d515 1
a515 2
    for (i = 0; i < vfbNumScreens; i++)
    {
d517 2
a518 2
	if (-1 == msync((caddr_t)vfbScreens[i].pXWDHeader,
			(size_t)vfbScreens[i].sizeInBytes, MS_ASYNC))
d520 8
a527 8
	/* silly NetBSD and who else? */
	if (-1 == msync((caddr_t)vfbScreens[i].pXWDHeader,
			(size_t)vfbScreens[i].sizeInBytes))
#endif
	{
	    perror("msync");
	    ErrorF("msync failed, %s", strerror(errno));
	}
a530 1

a535 1

d543 6
a548 6
    sprintf(pvfb->mmap_file, "%s/Xvfb_screen%d", pfbdir, (int) (pvfb - vfbScreens));
    if (-1 == (pvfb->mmap_fd = open(pvfb->mmap_file, O_CREAT|O_RDWR, 0666)))
    {
	perror("open");
	ErrorF("open %s failed, %s", pvfb->mmap_file, strerror(errno));
	return;
d555 9
a563 11
	 currentFileSize < pvfb->sizeInBytes;
	 currentFileSize += writeThisTime)
    {
	writeThisTime = min(DUMMY_BUFFER_SIZE,
			    pvfb->sizeInBytes - currentFileSize);
	if (-1 == write(pvfb->mmap_fd, dummyBuffer, writeThisTime))
	{
	    perror("write");
	    ErrorF("write %s failed, %s", pvfb->mmap_file, strerror(errno));
	    return;
	}
d568 9
a576 10
    pvfb->pXWDHeader = (XWDFileHeader *)mmap((caddr_t)NULL, pvfb->sizeInBytes,
				    PROT_READ|PROT_WRITE,
				    MAP_FILE|MAP_SHARED,
				    pvfb->mmap_fd, 0);
    if (-1 == (long)pvfb->pXWDHeader)
    {
	perror("mmap");
	ErrorF("mmap %s failed, %s", pvfb->mmap_file, strerror(errno));
	pvfb->pXWDHeader = NULL;
	return;
d580 2
a581 3
					NULL))
    {
	pvfb->pXWDHeader = NULL;
d584 1
a584 2
#endif /* HAS_MMAP */

d592 6
a597 6
    pvfb->shmid = shmget(IPC_PRIVATE, pvfb->sizeInBytes, IPC_CREAT|0777);
    if (pvfb->shmid < 0)
    {
	perror("shmget");
	ErrorF("shmget %d bytes failed, %s", pvfb->sizeInBytes, strerror(errno));
	return;
d602 6
a607 7
    pvfb->pXWDHeader = (XWDFileHeader *)shmat(pvfb->shmid, 0, 0);
    if (-1 == (long)pvfb->pXWDHeader)
    {
	perror("shmat");
	ErrorF("shmat failed, %s", strerror(errno));
	pvfb->pXWDHeader = NULL; 
	return;
d612 1
a612 1
#endif /* HAS_SHM */
d617 2
a618 1
    if (pvfb->pfbMemory) return pvfb->pfbMemory; /* already done */
d628 2
a629 3
    if (pvfb->depth <= 10)
    { /* single index colormaps */
	pvfb->ncolors = 1 << pvfb->depth;
d631 6
a636 5
    else
    { /* decomposed colormaps */
	int nplanes_per_color_component = pvfb->depth / 3;
	if (pvfb->depth % 3) nplanes_per_color_component++;
	pvfb->ncolors = 1 << nplanes_per_color_component;
d642 1
a642 1
		    pvfb->ncolors * SIZEOF(XWDColor);
d644 6
a649 5
    pvfb->pXWDHeader = NULL; 
    switch (fbmemtype)
    {
#ifdef HAS_MMAP
    case MMAPPED_FILE_FB:  vfbAllocateMmappedFramebuffer(pvfb); break;
d651 2
a652 1
    case MMAPPED_FILE_FB: break;
d656 3
a658 1
    case SHARED_MEMORY_FB: vfbAllocateSharedMemoryFramebuffer(pvfb); break;
d660 2
a661 1
    case SHARED_MEMORY_FB: break;
d665 2
a666 2
	pvfb->pXWDHeader = (XWDFileHeader *)malloc(pvfb->sizeInBytes);
	break;
d669 5
a673 5
    if (pvfb->pXWDHeader)
    {
	pvfb->pXWDCmap = (XWDColor *)((char *)pvfb->pXWDHeader
				+ SIZEOF(XWDheader) + XWD_WINDOW_NAME_LEN);
	pvfb->pfbMemory = (char *)(pvfb->pXWDCmap + pvfb->ncolors);
d675 1
a675 1
	return pvfb->pfbMemory;
d678 1
a678 1
	return NULL;
a680 1

d692 2
a693 1
    pXWDHeader->header_size = (char *)pvfb->pXWDCmap - (char *)pvfb->pXWDHeader;
d723 1
a723 1
	hostname[0] = 0;
d725 3
a727 3
	hostname[XWD_WINDOW_NAME_LEN-1] = 0;
    sprintf((char *)(pXWDHeader+1), "Xvfb %s:%s.%d", hostname, display,
	    pScreen->myNum);
d731 2
a732 3
    for (i = 0; i < pvfb->ncolors; i++)
    {
	pvfb->pXWDCmap[i].pixel = i;
d737 5
a741 8
    if (needswap)
    {
	SwapLongs((CARD32 *)pXWDHeader, SIZEOF(XWDheader)/4);
	for (i = 0; i < pvfb->ncolors; i++)
	{
	    register char n;
	    swapl(&pvfb->pXWDCmap[i].pixel, n);
	}
a744 1

d746 1
a746 1
vfbCursorOffScreen (ScreenPtr *ppScreen, int *x, int *y)
d752 1
a752 1
vfbCrossScreen (ScreenPtr pScreen, Bool entering)
d756 1
a756 2
static miPointerScreenFuncRec vfbPointerCursorFuncs =
{
d767 1
a767 1
 
d775 1
a775 1
	SetInstalledColormap(screenInfo.screens[i], NULL);
d787 1
a787 1
    
d789 1
a789 1
	return FALSE;
d792 1
a792 1
      dpix = 100;
d795 1
a795 1
      dpiy = 100;
d799 2
a800 2
    if (pvfb->bitsPerPixel >= 8 )
	pvfb->paddedWidth = pvfb->paddedBytesWidth / (pvfb->bitsPerPixel / 8);
d802 1
a802 1
	pvfb->paddedWidth = pvfb->paddedBytesWidth * 8;
d804 2
a805 1
    if (!pbits) return FALSE;
d809 8
a816 9
	miSetVisualTypesAndMasks (8,
				  ((1 << StaticGray) |
				   (1 << GrayScale) |
				   (1 << StaticColor) |
				   (1 << PseudoColor) |
				   (1 << TrueColor) |
				   (1 << DirectColor)),
				  8, PseudoColor, 0, 0, 0);
	break;
d818 5
a822 5
	miSetVisualTypesAndMasks (15,
				  ((1 << TrueColor) |
				   (1 << DirectColor)),
				  8, TrueColor, 0x7c00, 0x03e0, 0x001f);
	break;
d824 5
a828 5
	miSetVisualTypesAndMasks (16,
				  ((1 << TrueColor) |
				   (1 << DirectColor)),
				  8, TrueColor, 0xf800, 0x07e0, 0x001f);
	break;
d830 5
a834 5
	miSetVisualTypesAndMasks (24,
				  ((1 << TrueColor) |
				   (1 << DirectColor)),
				  8, TrueColor, 0xff0000, 0x00ff00, 0x0000ff);
	break;
d836 6
a841 5
	miSetVisualTypesAndMasks (30,
				  ((1 << TrueColor) |
				   (1 << DirectColor)),
				  10, TrueColor, 0x3ff00000, 0x000ffc00, 0x000003ff);
	break;
d843 1
a843 1
	return FALSE;
d846 1
a846 1
    miSetPixmapDepths ();
d849 3
a851 3
		       dpix, dpiy, pvfb->paddedWidth,pvfb->bitsPerPixel);
    if (ret && Render) 
	fbPictureInit (pScreen, 0, 0);
d853 2
a854 1
    if (!ret) return FALSE;
d879 1
a879 2
} /* end vfbScreenInit */

d882 1
a882 1
InitOutput(ScreenInfo *screenInfo, int argc, char **argv)
d890 2
a891 3
    for (i = 0; i < vfbNumScreens; i++)
    {
	vfbPixmapDepths[vfbScreens[i].depth] = TRUE;
d896 3
a898 3
	vfbPixmapDepths[1] = TRUE;
	vfbPixmapDepths[4] = TRUE;
	vfbPixmapDepths[8] = TRUE;
d900 1
a900 1
	vfbPixmapDepths[12] = TRUE;
d903 2
a904 2
	vfbPixmapDepths[16] = TRUE;
	vfbPixmapDepths[24] = TRUE;
d906 1
a906 1
	vfbPixmapDepths[30] = TRUE;
d908 1
a908 1
	vfbPixmapDepths[32] = TRUE;
d911 9
a919 11
    for (i = 1; i <= 32; i++)
    {
	if (vfbPixmapDepths[i])
	{
	    if (NumFormats >= MAXFORMATS)
		FatalError ("MAXFORMATS is too small for this server\n");
	    screenInfo->formats[NumFormats].depth = i;
	    screenInfo->formats[NumFormats].bitsPerPixel = vfbBitsPerPixel(i);
	    screenInfo->formats[NumFormats].scanlinePad = BITMAP_SCANLINE_PAD;
	    NumFormats++;
	}
d930 8
a937 11
    if (vfbNumScreens < 1)
    {
	vfbScreens = &defaultScreenInfo;
	vfbNumScreens = 1;
    }
    for (i = 0; i < vfbNumScreens; i++)
    {
	if (-1 == AddScreen(vfbScreenInit, argc, argv))
	{
	    FatalError("Couldn't add screen %d", i);
	}
d940 1
a940 1
} /* end InitOutput */
@


1.6
log
@Update to xserver 1.11.2
@
text
@d283 3
a285 1
	if (screenNum < 0)
d869 2
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d153 1
a153 1
ddxGiveUp(void)
d204 1
a204 1
AbortDDX(void)
d206 1
a206 1
    ddxGiveUp();
a876 7

    miInitializeBackingStore(pScreen);

    /*
     * Circumvent the backing store that was just initialised.  This amounts
     * to a truely bizarre way of initialising SaveDoomedAreas and friends.
     */
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a79 1
    int scrnum;
d107 9
a115 1
static vfbScreenInfo vfbScreens[MAXSCREENS];
a122 1
static int lastScreen = -1;
a142 19
static void
vfbInitializeDefaultScreens(void)
{
    int i;

    for (i = 0; i < MAXSCREENS; i++)
    {
	vfbScreens[i].scrnum = i;
	vfbScreens[i].width  = VFB_DEFAULT_WIDTH;
	vfbScreens[i].height = VFB_DEFAULT_HEIGHT;
	vfbScreens[i].depth  = VFB_DEFAULT_DEPTH;
	vfbScreens[i].blackPixel = VFB_DEFAULT_BLACKPIXEL;
	vfbScreens[i].whitePixel = VFB_DEFAULT_WHITEPIXEL;
	vfbScreens[i].lineBias = VFB_DEFAULT_LINEBIAS;
	vfbScreens[i].pfbMemory = NULL;
    }
    vfbNumScreens = 1;
}

d197 1
a197 1
	    Xfree(vfbScreens[i].pXWDHeader);
a237 1
#ifdef RENDER
a239 1
#endif
d257 2
a261 1
	vfbInitializeDefaultScreens();
d266 5
d283 1
a283 1
	if (screenNum < 0 || screenNum >= MAXSCREENS)
d290 10
a310 2
	if (screenNum >= vfbNumScreens)
	    vfbNumScreens = screenNum + 1;
a351 1
	Pixel pix;
d353 1
a353 13
	pix = atoi(argv[++i]);
	if (-1 == lastScreen)
	{
	    int i;
	    for (i = 0; i < MAXSCREENS; i++)
	    {
		vfbScreens[i].blackPixel = pix;
	    }
	}
	else
	{
	    vfbScreens[lastScreen].blackPixel = pix;
	}
a358 1
	Pixel pix;
d360 1
a360 13
	pix = atoi(argv[++i]);
	if (-1 == lastScreen)
	{
	    int i;
	    for (i = 0; i < MAXSCREENS; i++)
	    {
		vfbScreens[i].whitePixel = pix;
	    }
	}
	else
	{
	    vfbScreens[lastScreen].whitePixel = pix;
	}
a365 1
	unsigned int linebias;
d367 1
a367 13
	linebias = atoi(argv[++i]);
	if (-1 == lastScreen)
	{
	    int i;
	    for (i = 0; i < MAXSCREENS; i++)
	    {
		vfbScreens[i].lineBias = linebias;
	    }
	}
	else
	{
	    vfbScreens[lastScreen].lineBias = linebias;
	}
d392 5
a396 1
static ColormapPtr InstalledMaps[MAXSCREENS];
d403 2
a404 2
    *pmaps = InstalledMaps[pScreen->myNum]->mid;
    return (1);
d411 1
a411 2
    int index = pmap->pScreen->myNum;
    ColormapPtr oldpmap = InstalledMaps[index];
d427 1
a427 1
	InstalledMaps[index] = pmap;
d442 3
a444 3
	ppix = (Pixel *)xalloc(entries * sizeof(Pixel));
	prgb = (xrgb *)xalloc(entries * sizeof(xrgb));
	defs = (xColorItem *)xalloc(entries * sizeof(xColorItem));
d448 1
a448 1
	QueryColors(pmap, entries, ppix, prgb);
d459 3
a461 3
	xfree(ppix);
	xfree(prgb);
	xfree(defs);
d468 1
a468 1
    ColormapPtr curpmap = InstalledMaps[pmap->pScreen->myNum];
d489 1
a489 1
    if (pmap != InstalledMaps[pmap->pScreen->myNum])
d563 1
a563 1
    sprintf(pvfb->mmap_file, "%s/Xvfb_screen%d", pfbdir, pvfb->scrnum);
d573 1
a573 1
    bzero(dummyBuffer, DUMMY_BUFFER_SIZE);
d636 1
a636 1
    ErrorF("screen %d shmid %d\n", pvfb->scrnum, pvfb->shmid);
d685 1
a685 1
	pvfb->pXWDHeader = (XWDFileHeader *)Xalloc(pvfb->sizeInBytes);
d798 1
a798 1
     * clear InstalledMaps[] so that server reset works correctly.
d800 2
a801 2
    for (i = 0; i < MAXSCREENS; i++)
	InstalledMaps[i] = NULL;
d814 3
a872 1
#ifdef RENDER
a874 1
#endif
d963 5
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a37 1
#define NEED_EVENTS
d166 1
a166 1
ddxGiveUp()
d217 1
a217 1
AbortDDX()
d230 1
a230 1
OsVendorInit()
d235 1
a235 1
OsVendorFatalError()
d247 1
a247 1
ddxUseMsg()
d252 1
a252 1
    ErrorF("+/-render		   turn on/of RENDER extension support"
d511 4
a514 2
	    curpmap = (ColormapPtr) LookupIDByType(pmap->pScreen->defColormap,
						   RT_COLORMAP);
d894 6
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a268 5
/* ddxInitGlobals - called by |InitGlobals| from os/util.c */
void ddxInitGlobals(void)
{
}

a864 2
    miSetPixmapDepths ();

a875 14
#if 0
    /* 12bit PseudoColor with 12bit color resolution
     * (to simulate SGI hardware and the 12bit PseudoColor emulation layer) */
    case 12:
	miSetVisualTypesAndMasks (12,
				  ((1 << StaticGray) |
				   (1 << GrayScale) |
				   (1 << StaticColor) |
				   (1 << PseudoColor) |
				   (1 << TrueColor) |
				   (1 << DirectColor)),
				  12, PseudoColor, 0, 0, 0);
	break;
#endif
a893 10
#if 0
    /* 30bit TrueColor (to simulate Sun's XVR-1000/-4000 high quality
     * framebuffer series) */
    case 30:
	miSetVisualTypesAndMasks (30,
				  ((1 << TrueColor) |
				   (1 << DirectColor)),
				  10, TrueColor, 0x3ff00000, 0x000ffc00, 0x000003ff);
	break;
#endif
d895 3
a897 1
	
a1000 5

/* this is just to get the server to link on AIX */
#ifdef AIXV3
int SelectWaitTime = 10000; /* usec */
#endif
@


1.1
log
@Initial revision
@
text
@d182 2
a183 2
		ErrorF("unlink %s failed, errno %d",
		       vfbScreens[i].mmap_file, errno);
d199 1
a199 1
		ErrorF("shmdt failed, errno %d", errno);
d223 1
a223 1
#ifdef __DARWIN__
a227 16

void GlxExtensionInit();
void GlxWrapInitVisuals(void *procPtr);

void
DarwinGlxExtensionInit()
{
    GlxExtensionInit();
}

void
DarwinGlxWrapInitVisuals(
    void *procPtr)
{
    GlxWrapInitVisuals(procPtr);
}
d485 3
a487 3
	ppix = (Pixel *)ALLOCATE_LOCAL(entries * sizeof(Pixel));
	prgb = (xrgb *)ALLOCATE_LOCAL(entries * sizeof(xrgb));
	defs = (xColorItem *)ALLOCATE_LOCAL(entries * sizeof(xColorItem));
d502 3
a504 3
	DEALLOCATE_LOCAL(ppix);
	DEALLOCATE_LOCAL(prgb);
	DEALLOCATE_LOCAL(defs);
d585 1
a585 1
	    ErrorF("msync failed, errno %d", errno);
d608 1
a608 1
	ErrorF("open %s failed, errno %d", pvfb->mmap_file, errno);
d624 1
a624 1
	    ErrorF("write %s failed, errno %d", pvfb->mmap_file, errno);
d638 1
a638 1
	ErrorF("mmap %s failed, errno %d", pvfb->mmap_file, errno);
d662 1
a662 1
	ErrorF("shmget %d bytes failed, errno %d", pvfb->sizeInBytes, errno);
d672 1
a672 1
	ErrorF("shmat failed, errno %d", errno);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
