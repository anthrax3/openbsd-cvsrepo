head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.6
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.8
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.38;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2014.05.02.19.27.49;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.53;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.53;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.30;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.44;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.44;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.03.26;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*

Copyright 1993 by Davor Matic

Permission to use, copy, modify, distribute, and sell this software
and its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation.  Davor Matic makes no representations about
the suitability of this software for any purpose.  It is provided "as
is" without express or implied warranty.

*/

#ifdef HAVE_XNEST_CONFIG_H
#include <xnest-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "scrnintstr.h"
#include "dix.h"
#include "mi.h"
#include "micmap.h"
#include "colormapst.h"
#include "resource.h"

#include "Xnest.h"

#include "Display.h"
#include "Screen.h"
#include "XNGC.h"
#include "GCOps.h"
#include "Drawable.h"
#include "XNFont.h"
#include "Color.h"
#include "XNCursor.h"
#include "Visual.h"
#include "Events.h"
#include "Init.h"
#include "mipointer.h"
#include "Args.h"
#include "mipointrst.h"

Window xnestDefaultWindows[MAXSCREENS];
Window xnestScreenSaverWindows[MAXSCREENS];
DevPrivateKeyRec xnestCursorScreenKeyRec;

ScreenPtr
xnestScreen(Window window)
{
    int i;

    for (i = 0; i < xnestNumScreens; i++)
        if (xnestDefaultWindows[i] == window)
            return screenInfo.screens[i];

    return NULL;
}

static int
offset(unsigned long mask)
{
    int count;

    for (count = 0; !(mask & 1) && count < 32; count++)
        mask >>= 1;

    return count;
}

static Bool
xnestSaveScreen(ScreenPtr pScreen, int what)
{
    if (xnestSoftwareScreenSaver)
        return False;
    else {
        switch (what) {
        case SCREEN_SAVER_ON:
            XMapRaised(xnestDisplay, xnestScreenSaverWindows[pScreen->myNum]);
            xnestSetScreenSaverColormapWindow(pScreen);
            break;

        case SCREEN_SAVER_OFF:
            XUnmapWindow(xnestDisplay, xnestScreenSaverWindows[pScreen->myNum]);
            xnestSetInstalledColormapWindows(pScreen);
            break;

        case SCREEN_SAVER_FORCER:
            lastEventTime = GetTimeInMillis();
            XUnmapWindow(xnestDisplay, xnestScreenSaverWindows[pScreen->myNum]);
            xnestSetInstalledColormapWindows(pScreen);
            break;

        case SCREEN_SAVER_CYCLE:
            XUnmapWindow(xnestDisplay, xnestScreenSaverWindows[pScreen->myNum]);
            xnestSetInstalledColormapWindows(pScreen);
            break;
        }
        return True;
    }
}

static Bool
xnestCursorOffScreen(ScreenPtr *ppScreen, int *x, int *y)
{
    return FALSE;
}

static void
xnestCrossScreen(ScreenPtr pScreen, Bool entering)
{
}

static miPointerScreenFuncRec xnestPointerCursorFuncs = {
    xnestCursorOffScreen,
    xnestCrossScreen,
    miPointerWarpCursor
};

static miPointerSpriteFuncRec xnestPointerSpriteFuncs = {
    xnestRealizeCursor,
    xnestUnrealizeCursor,
    xnestSetCursor,
    xnestMoveCursor,
    xnestDeviceCursorInitialize,
    xnestDeviceCursorCleanup
};

Bool
xnestOpenScreen(ScreenPtr pScreen, int argc, char *argv[])
{
    VisualPtr visuals;
    DepthPtr depths;
    int numVisuals, numDepths;
    int i, j, depthIndex;
    unsigned long valuemask;
    XSetWindowAttributes attributes;
    XWindowAttributes gattributes;
    XSizeHints sizeHints;
    VisualID defaultVisual;
    int rootDepth;
    miPointerScreenPtr PointPriv;

    if (!dixRegisterPrivateKey
        (&xnestWindowPrivateKeyRec, PRIVATE_WINDOW, sizeof(xnestPrivWin)))
        return FALSE;
    if (!dixRegisterPrivateKey
        (&xnestGCPrivateKeyRec, PRIVATE_GC, sizeof(xnestPrivGC)))
        return FALSE;
    if (!dixRegisterPrivateKey
        (&xnestPixmapPrivateKeyRec, PRIVATE_PIXMAP, sizeof(xnestPrivPixmap)))
        return FALSE;
    if (!dixRegisterPrivateKey
        (&xnestColormapPrivateKeyRec, PRIVATE_COLORMAP,
         sizeof(xnestPrivColormap)))
        return FALSE;
    if (!dixRegisterPrivateKey(&xnestCursorScreenKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    visuals = xallocarray(xnestNumVisuals, sizeof(VisualRec));
    numVisuals = 0;

    depths = (DepthPtr) malloc(MAXDEPTH * sizeof(DepthRec));
    depths[0].depth = 1;
    depths[0].numVids = 0;
    depths[0].vids = (VisualID *) malloc(MAXVISUALSPERDEPTH * sizeof(VisualID));
    numDepths = 1;

    for (i = 0; i < xnestNumVisuals; i++) {
        visuals[numVisuals].class = xnestVisuals[i].class;
        visuals[numVisuals].bitsPerRGBValue = xnestVisuals[i].bits_per_rgb;
        visuals[numVisuals].ColormapEntries = xnestVisuals[i].colormap_size;
        visuals[numVisuals].nplanes = xnestVisuals[i].depth;
        visuals[numVisuals].redMask = xnestVisuals[i].red_mask;
        visuals[numVisuals].greenMask = xnestVisuals[i].green_mask;
        visuals[numVisuals].blueMask = xnestVisuals[i].blue_mask;
        visuals[numVisuals].offsetRed = offset(xnestVisuals[i].red_mask);
        visuals[numVisuals].offsetGreen = offset(xnestVisuals[i].green_mask);
        visuals[numVisuals].offsetBlue = offset(xnestVisuals[i].blue_mask);

        /* Check for and remove duplicates. */
        for (j = 0; j < numVisuals; j++) {
            if (visuals[numVisuals].class == visuals[j].class &&
                visuals[numVisuals].bitsPerRGBValue ==
                visuals[j].bitsPerRGBValue &&
                visuals[numVisuals].ColormapEntries ==
                visuals[j].ColormapEntries &&
                visuals[numVisuals].nplanes == visuals[j].nplanes &&
                visuals[numVisuals].redMask == visuals[j].redMask &&
                visuals[numVisuals].greenMask == visuals[j].greenMask &&
                visuals[numVisuals].blueMask == visuals[j].blueMask &&
                visuals[numVisuals].offsetRed == visuals[j].offsetRed &&
                visuals[numVisuals].offsetGreen == visuals[j].offsetGreen &&
                visuals[numVisuals].offsetBlue == visuals[j].offsetBlue)
                break;
        }
        if (j < numVisuals)
            break;

        visuals[numVisuals].vid = FakeClientID(0);

        depthIndex = UNDEFINED;
        for (j = 0; j < numDepths; j++)
            if (depths[j].depth == xnestVisuals[i].depth) {
                depthIndex = j;
                break;
            }

        if (depthIndex == UNDEFINED) {
            depthIndex = numDepths;
            depths[depthIndex].depth = xnestVisuals[i].depth;
            depths[depthIndex].numVids = 0;
            depths[depthIndex].vids =
                (VisualID *) malloc(MAXVISUALSPERDEPTH * sizeof(VisualID));
            numDepths++;
        }
        if (depths[depthIndex].numVids >= MAXVISUALSPERDEPTH) {
            FatalError("Visual table overflow");
        }
        depths[depthIndex].vids[depths[depthIndex].numVids] =
            visuals[numVisuals].vid;
        depths[depthIndex].numVids++;

        numVisuals++;
    }
    visuals = reallocarray(visuals, numVisuals, sizeof(VisualRec));

    defaultVisual = visuals[xnestDefaultVisualIndex].vid;
    rootDepth = visuals[xnestDefaultVisualIndex].nplanes;

    if (xnestParentWindow != 0) {
        XGetWindowAttributes(xnestDisplay, xnestParentWindow, &gattributes);
        xnestWidth = gattributes.width;
        xnestHeight = gattributes.height;
    }

    /* myNum */
    /* id */
    miScreenInit(pScreen, NULL, xnestWidth, xnestHeight, 1, 1, xnestWidth, rootDepth, numDepths, depths, defaultVisual, /* root visual */
                 numVisuals, visuals);

    pScreen->defColormap = (Colormap) FakeClientID(0);
    pScreen->minInstalledCmaps = MINCMAPS;
    pScreen->maxInstalledCmaps = MAXCMAPS;
    pScreen->backingStoreSupport = NotUseful;
    pScreen->saveUnderSupport = NotUseful;
    pScreen->whitePixel = xnestWhitePixel;
    pScreen->blackPixel = xnestBlackPixel;
    /* GCperDepth */
    /* PixmapPerDepth */
    pScreen->devPrivate = NULL;
    /* WindowPrivateLen */
    /* WindowPrivateSizes */
    /* totalWindowSize */
    /* GCPrivateLen */
    /* GCPrivateSizes */
    /* totalGCSize */

    /* Random screen procedures */

    pScreen->QueryBestSize = xnestQueryBestSize;
    pScreen->SaveScreen = xnestSaveScreen;
    pScreen->GetImage = xnestGetImage;
    pScreen->GetSpans = xnestGetSpans;
    pScreen->SourceValidate = NULL;

    /* Window Procedures */

    pScreen->CreateWindow = xnestCreateWindow;
    pScreen->DestroyWindow = xnestDestroyWindow;
    pScreen->PositionWindow = xnestPositionWindow;
    pScreen->ChangeWindowAttributes = xnestChangeWindowAttributes;
    pScreen->RealizeWindow = xnestRealizeWindow;
    pScreen->UnrealizeWindow = xnestUnrealizeWindow;
    pScreen->PostValidateTree = NULL;
    pScreen->WindowExposures = xnestWindowExposures;
    pScreen->CopyWindow = xnestCopyWindow;
    pScreen->ClipNotify = xnestClipNotify;

    /* Pixmap procedures */

    pScreen->CreatePixmap = xnestCreatePixmap;
    pScreen->DestroyPixmap = xnestDestroyPixmap;
    pScreen->ModifyPixmapHeader = xnestModifyPixmapHeader;

    /* Font procedures */

    pScreen->RealizeFont = xnestRealizeFont;
    pScreen->UnrealizeFont = xnestUnrealizeFont;

    /* GC procedures */

    pScreen->CreateGC = xnestCreateGC;

    /* Colormap procedures */

    pScreen->CreateColormap = xnestCreateColormap;
    pScreen->DestroyColormap = xnestDestroyColormap;
    pScreen->InstallColormap = xnestInstallColormap;
    pScreen->UninstallColormap = xnestUninstallColormap;
    pScreen->ListInstalledColormaps = xnestListInstalledColormaps;
    pScreen->StoreColors = xnestStoreColors;
    pScreen->ResolveColor = xnestResolveColor;

    pScreen->BitmapToRegion = xnestPixmapToRegion;

    /* OS layer procedures */

    pScreen->BlockHandler = (ScreenBlockHandlerProcPtr) NoopDDA;
    pScreen->WakeupHandler = (ScreenWakeupHandlerProcPtr) NoopDDA;

    miDCInitialize(pScreen, &xnestPointerCursorFuncs);  /* init SW rendering */
    PointPriv = dixLookupPrivate(&pScreen->devPrivates, miPointerScreenKey);
    xnestCursorFuncs.spriteFuncs = PointPriv->spriteFuncs;
    dixSetPrivate(&pScreen->devPrivates, xnestCursorScreenKey,
                  &xnestCursorFuncs);
    PointPriv->spriteFuncs = &xnestPointerSpriteFuncs;

    pScreen->mmWidth = xnestWidth * DisplayWidthMM(xnestDisplay,
                                                   DefaultScreen(xnestDisplay))
        / DisplayWidth(xnestDisplay, DefaultScreen(xnestDisplay));
    pScreen->mmHeight =
        xnestHeight * DisplayHeightMM(xnestDisplay,
                                      DefaultScreen(xnestDisplay)) /
        DisplayHeight(xnestDisplay, DefaultScreen(xnestDisplay));

    /* overwrite miCloseScreen with our own */
    pScreen->CloseScreen = xnestCloseScreen;

    if (!miScreenDevPrivateInit(pScreen, xnestWidth, NULL))
        return FALSE;

    /* overwrite miSetShape with our own */
    pScreen->SetShape = xnestSetShape;

    /* devPrivates */

#define POSITION_OFFSET (pScreen->myNum * (xnestWidth + xnestHeight) / 32)

    if (xnestDoFullGeneration) {

        valuemask = CWBackPixel | CWEventMask | CWColormap;
        attributes.background_pixel = xnestWhitePixel;
        attributes.event_mask = xnestEventMask;
        attributes.colormap =
            xnestDefaultVisualColormap(xnestDefaultVisual(pScreen));

        if (xnestParentWindow != 0) {
            xnestDefaultWindows[pScreen->myNum] = xnestParentWindow;
            XSelectInput(xnestDisplay, xnestDefaultWindows[pScreen->myNum],
                         xnestEventMask);
        }
        else
            xnestDefaultWindows[pScreen->myNum] =
                XCreateWindow(xnestDisplay,
                              DefaultRootWindow(xnestDisplay),
                              xnestX + POSITION_OFFSET,
                              xnestY + POSITION_OFFSET,
                              xnestWidth, xnestHeight,
                              xnestBorderWidth,
                              pScreen->rootDepth,
                              InputOutput,
                              xnestDefaultVisual(pScreen),
                              valuemask, &attributes);

        if (!xnestWindowName)
            xnestWindowName = argv[0];

        sizeHints.flags = PPosition | PSize | PMaxSize;
        sizeHints.x = xnestX + POSITION_OFFSET;
        sizeHints.y = xnestY + POSITION_OFFSET;
        sizeHints.width = sizeHints.max_width = xnestWidth;
        sizeHints.height = sizeHints.max_height = xnestHeight;
        if (xnestUserGeometry & XValue || xnestUserGeometry & YValue)
            sizeHints.flags |= USPosition;
        if (xnestUserGeometry & WidthValue || xnestUserGeometry & HeightValue)
            sizeHints.flags |= USSize;
        XSetStandardProperties(xnestDisplay,
                               xnestDefaultWindows[pScreen->myNum],
                               xnestWindowName,
                               xnestWindowName,
                               xnestIconBitmap, argv, argc, &sizeHints);

        XMapWindow(xnestDisplay, xnestDefaultWindows[pScreen->myNum]);

        valuemask = CWBackPixmap | CWColormap;
        attributes.background_pixmap = xnestScreenSaverPixmap;
        attributes.colormap =
            DefaultColormap(xnestDisplay, DefaultScreen(xnestDisplay));
        xnestScreenSaverWindows[pScreen->myNum] =
            XCreateWindow(xnestDisplay,
                          xnestDefaultWindows[pScreen->myNum],
                          0, 0, xnestWidth, xnestHeight, 0,
                          DefaultDepth(xnestDisplay,
                                       DefaultScreen(xnestDisplay)),
                          InputOutput, DefaultVisual(xnestDisplay,
                                                     DefaultScreen
                                                     (xnestDisplay)), valuemask,
                          &attributes);
    }

    if (!xnestCreateDefaultColormap(pScreen))
        return False;

    return True;
}

Bool
xnestCloseScreen(ScreenPtr pScreen)
{
    int i;

    for (i = 0; i < pScreen->numDepths; i++)
        free(pScreen->allowedDepths[i].vids);
    free(pScreen->allowedDepths);
    free(pScreen->visuals);
    free(pScreen->devPrivate);

    /*
       If xnestDoFullGeneration all x resources will be destroyed upon closing
       the display connection.  There is no need to generate extra protocol.
     */

    return True;
}
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d161 1
a161 1
    visuals = (VisualPtr) malloc(xnestNumVisuals * sizeof(VisualRec));
d227 1
a227 1
    visuals = (VisualPtr) realloc(visuals, numVisuals * sizeof(VisualRec));
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d285 1
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a23 1
#include "mibstore.h"
d131 1
a131 1
xnestOpenScreen(int index, ScreenPtr pScreen, int argc, char *argv[])
a310 2
    pScreen->blockData = NULL;
    pScreen->wakeupData = NULL;
d409 1
a409 1
xnestCloseScreen(int index, ScreenPtr pScreen)
@


1.5
log
@Update to xserver 1.11.2
@
text
@d53 1
a53 5
  int i;
  
  for (i = 0; i < xnestNumScreens; i++)
    if (xnestDefaultWindows[i] == window) 
      return screenInfo.screens[i];
d55 5
a59 1
  return NULL;
d65 6
a70 6
  int count;
  
  for (count = 0; !(mask & 1) && count < 32; count++)
    mask >>= 1;
  
  return count;
d76 26
a101 24
  if (xnestSoftwareScreenSaver)
    return False;
  else {
    switch (what) {
    case SCREEN_SAVER_ON:
      XMapRaised(xnestDisplay, xnestScreenSaverWindows[pScreen->myNum]);
      xnestSetScreenSaverColormapWindow(pScreen);
      break;
      
    case SCREEN_SAVER_OFF:
      XUnmapWindow(xnestDisplay, xnestScreenSaverWindows[pScreen->myNum]);
      xnestSetInstalledColormapWindows(pScreen);
      break;
      
    case SCREEN_SAVER_FORCER:
      lastEventTime = GetTimeInMillis();
      XUnmapWindow(xnestDisplay, xnestScreenSaverWindows[pScreen->myNum]);
      xnestSetInstalledColormapWindows(pScreen);
      break;
      
    case SCREEN_SAVER_CYCLE:
      XUnmapWindow(xnestDisplay, xnestScreenSaverWindows[pScreen->myNum]);
      xnestSetInstalledColormapWindows(pScreen);
      break;
a102 2
    return True;
  }
d116 1
a116 2
static miPointerScreenFuncRec xnestPointerCursorFuncs =
{
d122 1
a122 2
static miPointerSpriteFuncRec xnestPointerSpriteFuncs = 
{
d134 93
a226 57
  VisualPtr visuals;
  DepthPtr depths;
  int numVisuals, numDepths;
  int i, j, depthIndex;
  unsigned long valuemask;
  XSetWindowAttributes attributes;
  XWindowAttributes gattributes;
  XSizeHints sizeHints;
  VisualID defaultVisual;
  int rootDepth;
  miPointerScreenPtr PointPriv;

  if (!dixRegisterPrivateKey(&xnestWindowPrivateKeyRec, PRIVATE_WINDOW, sizeof(xnestPrivWin)))
      return FALSE;
  if (!dixRegisterPrivateKey(&xnestGCPrivateKeyRec, PRIVATE_GC, sizeof(xnestPrivGC)))
    return FALSE;
  if (!dixRegisterPrivateKey(&xnestPixmapPrivateKeyRec, PRIVATE_PIXMAP, sizeof (xnestPrivPixmap)))
      return FALSE;
  if (!dixRegisterPrivateKey(&xnestColormapPrivateKeyRec, PRIVATE_COLORMAP, sizeof (xnestPrivColormap)))
      return FALSE;
  if (!dixRegisterPrivateKey(&xnestCursorScreenKeyRec, PRIVATE_SCREEN, 0))
      return FALSE;

  visuals = (VisualPtr)malloc(xnestNumVisuals * sizeof(VisualRec));
  numVisuals = 0;

  depths = (DepthPtr)malloc(MAXDEPTH * sizeof(DepthRec));
  depths[0].depth = 1;
  depths[0].numVids = 0;
  depths[0].vids = (VisualID *)malloc(MAXVISUALSPERDEPTH * sizeof(VisualID));
  numDepths = 1;

  for (i = 0; i < xnestNumVisuals; i++) {
    visuals[numVisuals].class = xnestVisuals[i].class;
    visuals[numVisuals].bitsPerRGBValue = xnestVisuals[i].bits_per_rgb;
    visuals[numVisuals].ColormapEntries = xnestVisuals[i].colormap_size;
    visuals[numVisuals].nplanes = xnestVisuals[i].depth;
    visuals[numVisuals].redMask = xnestVisuals[i].red_mask;
    visuals[numVisuals].greenMask = xnestVisuals[i].green_mask;
    visuals[numVisuals].blueMask = xnestVisuals[i].blue_mask;
    visuals[numVisuals].offsetRed = offset(xnestVisuals[i].red_mask);
    visuals[numVisuals].offsetGreen = offset(xnestVisuals[i].green_mask);
    visuals[numVisuals].offsetBlue = offset(xnestVisuals[i].blue_mask);

    /* Check for and remove duplicates. */
    for (j = 0; j < numVisuals; j++) {
      if (visuals[numVisuals].class           == visuals[j].class           &&
	  visuals[numVisuals].bitsPerRGBValue == visuals[j].bitsPerRGBValue &&
	  visuals[numVisuals].ColormapEntries == visuals[j].ColormapEntries &&
	  visuals[numVisuals].nplanes         == visuals[j].nplanes         &&
	  visuals[numVisuals].redMask         == visuals[j].redMask         &&
	  visuals[numVisuals].greenMask       == visuals[j].greenMask       &&
	  visuals[numVisuals].blueMask        == visuals[j].blueMask        &&
	  visuals[numVisuals].offsetRed       == visuals[j].offsetRed       &&
	  visuals[numVisuals].offsetGreen     == visuals[j].offsetGreen     &&
	  visuals[numVisuals].offsetBlue      == visuals[j].offsetBlue)
	break;
d228 1
a228 2
    if (j < numVisuals)
      break;
d230 2
a231 1
    visuals[numVisuals].vid = FakeClientID(0);
d233 4
a236 14
    depthIndex = UNDEFINED;
    for (j = 0; j < numDepths; j++)
      if (depths[j].depth == xnestVisuals[i].depth) {
	depthIndex = j;
	break;
      }
    
    if (depthIndex == UNDEFINED) {
      depthIndex = numDepths;
      depths[depthIndex].depth = xnestVisuals[i].depth;
      depths[depthIndex].numVids = 0;
      depths[depthIndex].vids = 
	(VisualID *)malloc(MAXVISUALSPERDEPTH * sizeof(VisualID));
      numDepths++;
a237 116
    if (depths[depthIndex].numVids >= MAXVISUALSPERDEPTH) {
	FatalError("Visual table overflow");
    }
    depths[depthIndex].vids[depths[depthIndex].numVids] = 
      visuals[numVisuals].vid;
    depths[depthIndex].numVids++;
    
    numVisuals++;
  }
  visuals = (VisualPtr)realloc(visuals, numVisuals * sizeof(VisualRec));

  defaultVisual = visuals[xnestDefaultVisualIndex].vid;
  rootDepth = visuals[xnestDefaultVisualIndex].nplanes;

  if (xnestParentWindow != 0) {
    XGetWindowAttributes(xnestDisplay, xnestParentWindow, &gattributes);
    xnestWidth = gattributes.width;
    xnestHeight = gattributes.height;
  }

  /* myNum */
  /* id */
  miScreenInit(pScreen, NULL, xnestWidth, xnestHeight, 1, 1, xnestWidth,
	       rootDepth,
	       numDepths, depths,
	       defaultVisual, /* root visual */
	       numVisuals, visuals);

  pScreen->defColormap = (Colormap) FakeClientID(0);
  pScreen->minInstalledCmaps = MINCMAPS;
  pScreen->maxInstalledCmaps = MAXCMAPS;
  pScreen->backingStoreSupport = NotUseful;
  pScreen->saveUnderSupport = NotUseful;
  pScreen->whitePixel = xnestWhitePixel;
  pScreen->blackPixel = xnestBlackPixel;
  /* GCperDepth */
  /* PixmapPerDepth */
  pScreen->devPrivate = NULL;
  /* WindowPrivateLen */
  /* WindowPrivateSizes */
  /* totalWindowSize */
  /* GCPrivateLen */
  /* GCPrivateSizes */
  /* totalGCSize */

  /* Random screen procedures */

  pScreen->QueryBestSize = xnestQueryBestSize;
  pScreen->SaveScreen = xnestSaveScreen;
  pScreen->GetImage = xnestGetImage;
  pScreen->GetSpans = xnestGetSpans;
  pScreen->SourceValidate = NULL;

  /* Window Procedures */
  
  pScreen->CreateWindow = xnestCreateWindow;
  pScreen->DestroyWindow = xnestDestroyWindow;
  pScreen->PositionWindow = xnestPositionWindow;
  pScreen->ChangeWindowAttributes = xnestChangeWindowAttributes;
  pScreen->RealizeWindow = xnestRealizeWindow;
  pScreen->UnrealizeWindow = xnestUnrealizeWindow;
  pScreen->PostValidateTree = NULL;
  pScreen->WindowExposures = xnestWindowExposures;
  pScreen->CopyWindow = xnestCopyWindow;
  pScreen->ClipNotify = xnestClipNotify;

  /* Pixmap procedures */

  pScreen->CreatePixmap = xnestCreatePixmap;
  pScreen->DestroyPixmap = xnestDestroyPixmap;

  /* Font procedures */

  pScreen->RealizeFont = xnestRealizeFont;
  pScreen->UnrealizeFont = xnestUnrealizeFont;

  /* GC procedures */
  
  pScreen->CreateGC = xnestCreateGC;

  /* Colormap procedures */

  pScreen->CreateColormap = xnestCreateColormap;
  pScreen->DestroyColormap = xnestDestroyColormap;
  pScreen->InstallColormap = xnestInstallColormap;
  pScreen->UninstallColormap = xnestUninstallColormap;
  pScreen->ListInstalledColormaps = xnestListInstalledColormaps;
  pScreen->StoreColors = xnestStoreColors;
  pScreen->ResolveColor = xnestResolveColor;

   pScreen->BitmapToRegion = xnestPixmapToRegion;

  /* OS layer procedures */

  pScreen->BlockHandler = (ScreenBlockHandlerProcPtr)NoopDDA;
  pScreen->WakeupHandler = (ScreenWakeupHandlerProcPtr)NoopDDA;
  pScreen->blockData = NULL;
  pScreen->wakeupData = NULL;

  miDCInitialize(pScreen, &xnestPointerCursorFuncs); /* init SW rendering */
  PointPriv = dixLookupPrivate(&pScreen->devPrivates, miPointerScreenKey);
  xnestCursorFuncs.spriteFuncs = PointPriv->spriteFuncs;
  dixSetPrivate(&pScreen->devPrivates, xnestCursorScreenKey, &xnestCursorFuncs);
  PointPriv->spriteFuncs = &xnestPointerSpriteFuncs;

  pScreen->mmWidth = xnestWidth * DisplayWidthMM(xnestDisplay, 
		       DefaultScreen(xnestDisplay)) / 
			 DisplayWidth(xnestDisplay, 
			   DefaultScreen(xnestDisplay));
  pScreen->mmHeight = xnestHeight * DisplayHeightMM(xnestDisplay, 
		        DefaultScreen(xnestDisplay)) /
			  DisplayHeight(xnestDisplay, 
			    DefaultScreen(xnestDisplay));

  /* overwrite miCloseScreen with our own */
  pScreen->CloseScreen = xnestCloseScreen;
d239 96
a334 2
  if (!miScreenDevPrivateInit(pScreen, xnestWidth, NULL))
      return FALSE;
d336 2
a337 2
  /* overwrite miSetShape with our own */
  pScreen->SetShape = xnestSetShape;
d339 1
a339 1
  /* devPrivates */
a341 2
    
  if (xnestDoFullGeneration) {
d343 66
a408 60
    valuemask = CWBackPixel | CWEventMask | CWColormap;
    attributes.background_pixel = xnestWhitePixel;
    attributes.event_mask = xnestEventMask;
    attributes.colormap = xnestDefaultVisualColormap(xnestDefaultVisual(pScreen));
    
    if (xnestParentWindow != 0) {
      xnestDefaultWindows[pScreen->myNum] = xnestParentWindow;
      XSelectInput (xnestDisplay, xnestDefaultWindows[pScreen->myNum],
		    xnestEventMask);
    } else
      xnestDefaultWindows[pScreen->myNum] = 
	XCreateWindow(xnestDisplay, 
		      DefaultRootWindow(xnestDisplay),
		      xnestX + POSITION_OFFSET,
		      xnestY + POSITION_OFFSET,
		      xnestWidth, xnestHeight,
		      xnestBorderWidth,
		      pScreen->rootDepth,
		      InputOutput,
		      xnestDefaultVisual(pScreen),
		      valuemask, &attributes);

    if (!xnestWindowName)
      xnestWindowName = argv[0];
    
    sizeHints.flags = PPosition | PSize | PMaxSize;
    sizeHints.x = xnestX + POSITION_OFFSET;
    sizeHints.y = xnestY + POSITION_OFFSET;
    sizeHints.width = sizeHints.max_width = xnestWidth;
    sizeHints.height = sizeHints.max_height = xnestHeight;
    if (xnestUserGeometry & XValue || xnestUserGeometry & YValue)
      sizeHints.flags |= USPosition;
    if (xnestUserGeometry & WidthValue || xnestUserGeometry & HeightValue)
      sizeHints.flags |= USSize;
    XSetStandardProperties(xnestDisplay, 
			   xnestDefaultWindows[pScreen->myNum], 
			   xnestWindowName, 
			   xnestWindowName, 
			   xnestIconBitmap,
			   argv, argc, &sizeHints);
    
    XMapWindow(xnestDisplay, xnestDefaultWindows[pScreen->myNum]);

    valuemask = CWBackPixmap | CWColormap;
    attributes.background_pixmap = xnestScreenSaverPixmap;
    attributes.colormap = 
      DefaultColormap(xnestDisplay, DefaultScreen(xnestDisplay));
    xnestScreenSaverWindows[pScreen->myNum] =
      XCreateWindow(xnestDisplay, 
		    xnestDefaultWindows[pScreen->myNum],
		    0, 0, xnestWidth, xnestHeight, 0,
		    DefaultDepth(xnestDisplay, DefaultScreen(xnestDisplay)),
		    InputOutput, 
		    DefaultVisual(xnestDisplay, DefaultScreen(xnestDisplay)),
		    valuemask, &attributes);
  }
  
  if (!xnestCreateDefaultColormap(pScreen)) return False;
  
  return True;
d414 1
a414 12
  int i;
  
  for (i = 0; i < pScreen->numDepths; i++)
    free(pScreen->allowedDepths[i].vids);
  free(pScreen->allowedDepths);
  free(pScreen->visuals);
  free(pScreen->devPrivate);

  /*
    If xnestDoFullGeneration all x resources will be destroyed upon closing
    the display connection.  There is no need to generate extra protocol.
    */
d416 12
a427 1
  return True;
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d154 2
a240 2

/*  miInitializeBackingStore(pScreen); */
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d48 1
a48 2
static int xnestCursorScreenKeyIndex;
DevPrivateKey xnestCursorScreenKey = &xnestCursorScreenKeyIndex;
d148 8
a155 4
  if (!dixRequestPrivate(xnestWindowPrivateKey, sizeof(xnestPrivWin)))
      return False;
  if (!dixRequestPrivate(xnestGCPrivateKey, sizeof(xnestPrivGC)))
    return False;
d157 1
a157 1
  visuals = (VisualPtr)xalloc(xnestNumVisuals * sizeof(VisualRec));
d160 1
a160 1
  depths = (DepthPtr)xalloc(MAXDEPTH * sizeof(DepthRec));
d163 1
a163 1
  depths[0].vids = (VisualID *)xalloc(MAXVISUALSPERDEPTH * sizeof(VisualID));
d209 1
a209 1
	(VisualID *)xalloc(MAXVISUALSPERDEPTH * sizeof(VisualID));
d221 1
a221 1
  visuals = (VisualPtr)xrealloc(visuals, numVisuals * sizeof(VisualRec));
a248 1
  /* rgf */
a264 1
  pScreen->PointerNonInterestBox = NULL;
d411 4
a414 4
    xfree(pScreen->allowedDepths[i].vids);
  xfree(pScreen->allowedDepths);
  xfree(pScreen->visuals);
  xfree(pScreen->devPrivate);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d44 1
d48 2
d130 2
d147 1
a152 2
  if (!dixRequestPrivate(xnestPixmapPrivateKey, sizeof (xnestPrivPixmap)))
      return False;
d312 5
a316 2
  miPointerInitialize (pScreen, &xnestPointerSpriteFuncs, 
		       &xnestPointerCursorFuncs, True);
a332 1
#ifdef SHAPE
a334 1
#endif /* SHAPE */
@


1.1
log
@Initial revision
@
text
@a47 8
#ifdef GLXEXT
extern void GlxWrapInitVisuals(miInitVisualsProcPtr *);
#endif

#ifdef PIXPRIV
int xnestScreenGeneration = -1;
#endif

d143 3
a145 4
  if (!(AllocateWindowPrivate(pScreen, xnestWindowPrivateIndex,
			    sizeof(xnestPrivWin))  &&
	  AllocateGCPrivate(pScreen, xnestGCPrivateIndex, 
			    sizeof(xnestPrivGC)))) 
d147 2
a149 11
#ifdef PIXPRIV
  if (xnestScreenGeneration != serverGeneration) {
      if ((xnestPixmapPrivateIndex = AllocatePixmapPrivateIndex()) < 0)
	  return False;
      xnestScreenGeneration = serverGeneration;
  }
  
  if (!AllocatePixmapPrivate(pScreen,xnestPixmapPrivateIndex,
			     sizeof (xnestPrivPixmap)))
      return False;
#endif
a218 11
#ifdef GLXEXT
  {
    miInitVisualsProcPtr proc = NULL;

    GlxWrapInitVisuals(&proc);
    /* GlxInitVisuals ignores the last three arguments. */
    proc(&visuals, &depths, &numVisuals, &numDepths,
	 &rootDepth, &defaultVisual, 0, 0, 0);
  }
#endif

a271 2
  pScreen->PaintWindowBackground = xnestPaintWindowBackground;
  pScreen->PaintWindowBorder = xnestPaintWindowBorder;
a278 9

  /* Backing store procedures */
  
  pScreen->SaveDoomedAreas = NULL;
  pScreen->RestoreAreas = NULL;
  pScreen->ExposeCopy = NULL;
  pScreen->TranslateBackingStore = NULL;
  pScreen->ClearBackingStore = NULL;
  pScreen->DrawGuarantee = NULL;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d52 3
a54 1
static int xnestScreenGeneration = -1;
d157 1
d167 1
@

