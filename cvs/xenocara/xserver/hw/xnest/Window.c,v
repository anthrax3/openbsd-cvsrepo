head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.6
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.10
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.30;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.44;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.44;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*

Copyright 1993 by Davor Matic

Permission to use, copy, modify, distribute, and sell this software
and its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation.  Davor Matic makes no representations about
the suitability of this software for any purpose.  It is provided "as
is" without express or implied warranty.

*/

#ifdef HAVE_XNEST_CONFIG_H
#include <xnest-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "gcstruct.h"
#include "window.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "colormapst.h"
#include "scrnintstr.h"
#include "region.h"

#include "mi.h"

#include "Xnest.h"

#include "Display.h"
#include "Screen.h"
#include "XNGC.h"
#include "Drawable.h"
#include "Color.h"
#include "Visual.h"
#include "Events.h"
#include "Args.h"

DevPrivateKeyRec xnestWindowPrivateKeyRec;

static int
xnestFindWindowMatch(WindowPtr pWin, void *ptr)
{
    xnestWindowMatch *wm = (xnestWindowMatch *) ptr;

    if (wm->window == xnestWindow(pWin)) {
        wm->pWin = pWin;
        return WT_STOPWALKING;
    }
    else
        return WT_WALKCHILDREN;
}

WindowPtr
xnestWindowPtr(Window window)
{
    xnestWindowMatch wm;
    int i;

    wm.pWin = NullWindow;
    wm.window = window;

    for (i = 0; i < xnestNumScreens; i++) {
        WalkTree(screenInfo.screens[i], xnestFindWindowMatch, (void *) &wm);
        if (wm.pWin)
            break;
    }

    return wm.pWin;
}

Bool
xnestCreateWindow(WindowPtr pWin)
{
    unsigned long mask;
    XSetWindowAttributes attributes;
    Visual *visual;
    ColormapPtr pCmap;

    if (pWin->drawable.class == InputOnly) {
        mask = 0L;
        visual = CopyFromParent;
    }
    else {
        mask = CWEventMask | CWBackingStore;
        attributes.event_mask = ExposureMask;
        attributes.backing_store = NotUseful;

        if (pWin->parent) {
            if (pWin->optional &&
                pWin->optional->visual != wVisual(pWin->parent)) {
                visual =
                    xnestVisualFromID(pWin->drawable.pScreen, wVisual(pWin));
                mask |= CWColormap;
                if (pWin->optional->colormap) {
                    dixLookupResourceByType((void **) &pCmap, wColormap(pWin),
                                            RT_COLORMAP, serverClient,
                                            DixUseAccess);
                    attributes.colormap = xnestColormap(pCmap);
                }
                else
                    attributes.colormap = xnestDefaultVisualColormap(visual);
            }
            else
                visual = CopyFromParent;
        }
        else {                  /* root windows have their own colormaps at creation time */
            visual = xnestVisualFromID(pWin->drawable.pScreen, wVisual(pWin));
            dixLookupResourceByType((void **) &pCmap, wColormap(pWin),
                                    RT_COLORMAP, serverClient, DixUseAccess);
            mask |= CWColormap;
            attributes.colormap = xnestColormap(pCmap);
        }
    }

    xnestWindowPriv(pWin)->window = XCreateWindow(xnestDisplay,
                                                  xnestWindowParent(pWin),
                                                  pWin->origin.x -
                                                  wBorderWidth(pWin),
                                                  pWin->origin.y -
                                                  wBorderWidth(pWin),
                                                  pWin->drawable.width,
                                                  pWin->drawable.height,
                                                  pWin->borderWidth,
                                                  pWin->drawable.depth,
                                                  pWin->drawable.class,
                                                  visual, mask, &attributes);
    xnestWindowPriv(pWin)->parent = xnestWindowParent(pWin);
    xnestWindowPriv(pWin)->x = pWin->origin.x - wBorderWidth(pWin);
    xnestWindowPriv(pWin)->y = pWin->origin.y - wBorderWidth(pWin);
    xnestWindowPriv(pWin)->width = pWin->drawable.width;
    xnestWindowPriv(pWin)->height = pWin->drawable.height;
    xnestWindowPriv(pWin)->border_width = pWin->borderWidth;
    xnestWindowPriv(pWin)->sibling_above = None;
    if (pWin->nextSib)
        xnestWindowPriv(pWin->nextSib)->sibling_above = xnestWindow(pWin);
    xnestWindowPriv(pWin)->bounding_shape = RegionCreate(NULL, 1);
    xnestWindowPriv(pWin)->clip_shape = RegionCreate(NULL, 1);

    if (!pWin->parent)          /* only the root window will have the right colormap */
        xnestSetInstalledColormapWindows(pWin->drawable.pScreen);

    return True;
}

Bool
xnestDestroyWindow(WindowPtr pWin)
{
    if (pWin->nextSib)
        xnestWindowPriv(pWin->nextSib)->sibling_above =
            xnestWindowPriv(pWin)->sibling_above;
    RegionDestroy(xnestWindowPriv(pWin)->bounding_shape);
    RegionDestroy(xnestWindowPriv(pWin)->clip_shape);
    XDestroyWindow(xnestDisplay, xnestWindow(pWin));
    xnestWindowPriv(pWin)->window = None;

    if (pWin->optional && pWin->optional->colormap && pWin->parent)
        xnestSetInstalledColormapWindows(pWin->drawable.pScreen);

    return True;
}

Bool
xnestPositionWindow(WindowPtr pWin, int x, int y)
{
    xnestConfigureWindow(pWin,
                         CWParent |
                         CWX | CWY | CWWidth | CWHeight | CWBorderWidth);

    return True;
}

void
xnestConfigureWindow(WindowPtr pWin, unsigned int mask)
{
    unsigned int valuemask;
    XWindowChanges values;

    if (mask & CWParent &&
        xnestWindowPriv(pWin)->parent != xnestWindowParent(pWin)) {
        XReparentWindow(xnestDisplay, xnestWindow(pWin),
                        xnestWindowParent(pWin),
                        pWin->origin.x - wBorderWidth(pWin),
                        pWin->origin.y - wBorderWidth(pWin));
        xnestWindowPriv(pWin)->parent = xnestWindowParent(pWin);
        xnestWindowPriv(pWin)->x = pWin->origin.x - wBorderWidth(pWin);
        xnestWindowPriv(pWin)->y = pWin->origin.y - wBorderWidth(pWin);
        xnestWindowPriv(pWin)->sibling_above = None;
        if (pWin->nextSib)
            xnestWindowPriv(pWin->nextSib)->sibling_above = xnestWindow(pWin);
    }

    valuemask = 0;

    if (mask & CWX &&
        xnestWindowPriv(pWin)->x != pWin->origin.x - wBorderWidth(pWin)) {
        valuemask |= CWX;
        values.x =
            xnestWindowPriv(pWin)->x = pWin->origin.x - wBorderWidth(pWin);
    }

    if (mask & CWY &&
        xnestWindowPriv(pWin)->y != pWin->origin.y - wBorderWidth(pWin)) {
        valuemask |= CWY;
        values.y =
            xnestWindowPriv(pWin)->y = pWin->origin.y - wBorderWidth(pWin);
    }

    if (mask & CWWidth && xnestWindowPriv(pWin)->width != pWin->drawable.width) {
        valuemask |= CWWidth;
        values.width = xnestWindowPriv(pWin)->width = pWin->drawable.width;
    }

    if (mask & CWHeight &&
        xnestWindowPriv(pWin)->height != pWin->drawable.height) {
        valuemask |= CWHeight;
        values.height = xnestWindowPriv(pWin)->height = pWin->drawable.height;
    }

    if (mask & CWBorderWidth &&
        xnestWindowPriv(pWin)->border_width != pWin->borderWidth) {
        valuemask |= CWBorderWidth;
        values.border_width =
            xnestWindowPriv(pWin)->border_width = pWin->borderWidth;
    }

    if (valuemask)
        XConfigureWindow(xnestDisplay, xnestWindow(pWin), valuemask, &values);

    if (mask & CWStackingOrder &&
        xnestWindowPriv(pWin)->sibling_above != xnestWindowSiblingAbove(pWin)) {
        WindowPtr pSib;

        /* find the top sibling */
        for (pSib = pWin; pSib->prevSib != NullWindow; pSib = pSib->prevSib);

        /* the top sibling */
        valuemask = CWStackMode;
        values.stack_mode = Above;
        XConfigureWindow(xnestDisplay, xnestWindow(pSib), valuemask, &values);
        xnestWindowPriv(pSib)->sibling_above = None;

        /* the rest of siblings */
        for (pSib = pSib->nextSib; pSib != NullWindow; pSib = pSib->nextSib) {
            valuemask = CWSibling | CWStackMode;
            values.sibling = xnestWindowSiblingAbove(pSib);
            values.stack_mode = Below;
            XConfigureWindow(xnestDisplay, xnestWindow(pSib), valuemask,
                             &values);
            xnestWindowPriv(pSib)->sibling_above =
                xnestWindowSiblingAbove(pSib);
        }
    }
}

Bool
xnestChangeWindowAttributes(WindowPtr pWin, unsigned long mask)
{
    XSetWindowAttributes attributes;

    if (mask & CWBackPixmap)
        switch (pWin->backgroundState) {
        case None:
            attributes.background_pixmap = None;
            break;

        case ParentRelative:
            attributes.background_pixmap = ParentRelative;
            break;

        case BackgroundPixmap:
            attributes.background_pixmap = xnestPixmap(pWin->background.pixmap);
            break;

        case BackgroundPixel:
            mask &= ~CWBackPixmap;
            break;
        }

    if (mask & CWBackPixel) {
        if (pWin->backgroundState == BackgroundPixel)
            attributes.background_pixel = xnestPixel(pWin->background.pixel);
        else
            mask &= ~CWBackPixel;
    }

    if (mask & CWBorderPixmap) {
        if (pWin->borderIsPixel)
            mask &= ~CWBorderPixmap;
        else
            attributes.border_pixmap = xnestPixmap(pWin->border.pixmap);
    }

    if (mask & CWBorderPixel) {
        if (pWin->borderIsPixel)
            attributes.border_pixel = xnestPixel(pWin->border.pixel);
        else
            mask &= ~CWBorderPixel;
    }

    if (mask & CWBitGravity)
        attributes.bit_gravity = pWin->bitGravity;

    if (mask & CWWinGravity)    /* dix does this for us */
        mask &= ~CWWinGravity;

    if (mask & CWBackingStore)  /* this is really not useful */
        mask &= ~CWBackingStore;

    if (mask & CWBackingPlanes) /* this is really not useful */
        mask &= ~CWBackingPlanes;

    if (mask & CWBackingPixel)  /* this is really not useful */
        mask &= ~CWBackingPixel;

    if (mask & CWOverrideRedirect)
        attributes.override_redirect = pWin->overrideRedirect;

    if (mask & CWSaveUnder)     /* this is really not useful */
        mask &= ~CWSaveUnder;

    if (mask & CWEventMask)     /* events are handled elsewhere */
        mask &= ~CWEventMask;

    if (mask & CWDontPropagate) /* events are handled elsewhere */
        mask &= ~CWDontPropagate;

    if (mask & CWColormap) {
        ColormapPtr pCmap;

        dixLookupResourceByType((void **) &pCmap, wColormap(pWin),
                                RT_COLORMAP, serverClient, DixUseAccess);

        attributes.colormap = xnestColormap(pCmap);

        xnestSetInstalledColormapWindows(pWin->drawable.pScreen);
    }

    if (mask & CWCursor)        /* this is handeled in cursor code */
        mask &= ~CWCursor;

    if (mask)
        XChangeWindowAttributes(xnestDisplay, xnestWindow(pWin),
                                mask, &attributes);

    return True;
}

Bool
xnestRealizeWindow(WindowPtr pWin)
{
    xnestConfigureWindow(pWin, CWStackingOrder);
    xnestShapeWindow(pWin);
    XMapWindow(xnestDisplay, xnestWindow(pWin));

    return True;
}

Bool
xnestUnrealizeWindow(WindowPtr pWin)
{
    XUnmapWindow(xnestDisplay, xnestWindow(pWin));

    return True;
}

void
xnestCopyWindow(WindowPtr pWin, xPoint oldOrigin, RegionPtr oldRegion)
{
}

void
xnestClipNotify(WindowPtr pWin, int dx, int dy)
{
    xnestConfigureWindow(pWin, CWStackingOrder);
    xnestShapeWindow(pWin);
}

static Bool
xnestWindowExposurePredicate(Display * dpy, XEvent * event, XPointer ptr)
{
    return (event->type == Expose && event->xexpose.window == *(Window *) ptr);
}

void
xnestWindowExposures(WindowPtr pWin, RegionPtr pRgn)
{
    XEvent event;
    Window window;
    BoxRec Box;

    XSync(xnestDisplay, False);

    window = xnestWindow(pWin);

    while (XCheckIfEvent(xnestDisplay, &event,
                         xnestWindowExposurePredicate, (char *) &window)) {

        Box.x1 = pWin->drawable.x + wBorderWidth(pWin) + event.xexpose.x;
        Box.y1 = pWin->drawable.y + wBorderWidth(pWin) + event.xexpose.y;
        Box.x2 = Box.x1 + event.xexpose.width;
        Box.y2 = Box.y1 + event.xexpose.height;

        event.xexpose.type = ProcessedExpose;

        if (RegionContainsRect(pRgn, &Box) != rgnIN)
            XPutBackEvent(xnestDisplay, &event);
    }

    miWindowExposures(pWin, pRgn);
}

void
xnestSetShape(WindowPtr pWin, int kind)
{
    xnestShapeWindow(pWin);
    miSetShape(pWin, kind);
}

static Bool
xnestRegionEqual(RegionPtr pReg1, RegionPtr pReg2)
{
    BoxPtr pBox1, pBox2;
    unsigned int n1, n2;

    if (pReg1 == pReg2)
        return True;

    if (pReg1 == NullRegion || pReg2 == NullRegion)
        return False;

    pBox1 = RegionRects(pReg1);
    n1 = RegionNumRects(pReg1);

    pBox2 = RegionRects(pReg2);
    n2 = RegionNumRects(pReg2);

    if (n1 != n2)
        return False;

    if (pBox1 == pBox2)
        return True;

    if (memcmp(pBox1, pBox2, n1 * sizeof(BoxRec)))
        return False;

    return True;
}

void
xnestShapeWindow(WindowPtr pWin)
{
    Region reg;
    BoxPtr pBox;
    XRectangle rect;
    int i;

    if (!xnestRegionEqual(xnestWindowPriv(pWin)->bounding_shape,
                          wBoundingShape(pWin))) {

        if (wBoundingShape(pWin)) {
            RegionCopy(xnestWindowPriv(pWin)->bounding_shape,
                       wBoundingShape(pWin));

            reg = XCreateRegion();
            pBox = RegionRects(xnestWindowPriv(pWin)->bounding_shape);
            for (i = 0;
                 i < RegionNumRects(xnestWindowPriv(pWin)->bounding_shape);
                 i++) {
                rect.x = pBox[i].x1;
                rect.y = pBox[i].y1;
                rect.width = pBox[i].x2 - pBox[i].x1;
                rect.height = pBox[i].y2 - pBox[i].y1;
                XUnionRectWithRegion(&rect, reg, reg);
            }
            XShapeCombineRegion(xnestDisplay, xnestWindow(pWin),
                                ShapeBounding, 0, 0, reg, ShapeSet);
            XDestroyRegion(reg);
        }
        else {
            RegionEmpty(xnestWindowPriv(pWin)->bounding_shape);

            XShapeCombineMask(xnestDisplay, xnestWindow(pWin),
                              ShapeBounding, 0, 0, None, ShapeSet);
        }
    }

    if (!xnestRegionEqual(xnestWindowPriv(pWin)->clip_shape, wClipShape(pWin))) {

        if (wClipShape(pWin)) {
            RegionCopy(xnestWindowPriv(pWin)->clip_shape, wClipShape(pWin));

            reg = XCreateRegion();
            pBox = RegionRects(xnestWindowPriv(pWin)->clip_shape);
            for (i = 0;
                 i < RegionNumRects(xnestWindowPriv(pWin)->clip_shape); i++) {
                rect.x = pBox[i].x1;
                rect.y = pBox[i].y1;
                rect.width = pBox[i].x2 - pBox[i].x1;
                rect.height = pBox[i].y2 - pBox[i].y1;
                XUnionRectWithRegion(&rect, reg, reg);
            }
            XShapeCombineRegion(xnestDisplay, xnestWindow(pWin),
                                ShapeClip, 0, 0, reg, ShapeSet);
            XDestroyRegion(reg);
        }
        else {
            RegionEmpty(xnestWindowPriv(pWin)->clip_shape);

            XShapeCombineMask(xnestDisplay, xnestWindow(pWin),
                              ShapeClip, 0, 0, None, ShapeSet);
        }
    }
}
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d389 1
a389 1
xnestWindowExposures(WindowPtr pWin, RegionPtr pRgn, RegionPtr other_exposed)
d413 1
a413 1
    miWindowExposures(pWin, pRgn, other_exposed);
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d45 1
a45 1
xnestFindWindowMatch(WindowPtr pWin, pointer ptr)
d67 1
a67 1
        WalkTree(screenInfo.screens[i], xnestFindWindowMatch, (pointer) &wm);
d99 1
a99 1
                    dixLookupResourceByType((pointer *) &pCmap, wColormap(pWin),
d112 1
a112 1
            dixLookupResourceByType((pointer *) &pCmap, wColormap(pWin),
d334 1
a334 1
        dixLookupResourceByType((pointer *) &pCmap, wColormap(pWin),
d383 1
a383 1
xnestWindowExposurePredicate(Display * display, XEvent * event, XPointer ptr)
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d47 8
a54 7
  xnestWindowMatch *wm = (xnestWindowMatch *)ptr;
  if (wm->window == xnestWindow(pWin)) {
    wm->pWin = pWin;
    return WT_STOPWALKING;
  }
  else
    return WT_WALKCHILDREN;
d60 2
a61 2
  xnestWindowMatch wm;
  int i;
d63 8
a70 2
  wm.pWin = NullWindow;
  wm.window = window;
d72 1
a72 6
  for (i = 0; i < xnestNumScreens; i++) {
    WalkTree(screenInfo.screens[i], xnestFindWindowMatch, (pointer) &wm);
    if (wm.pWin) break;
  }
  
  return wm.pWin;
d74 1
a74 1
    
d78 69
a146 69
  unsigned long mask;
  XSetWindowAttributes attributes;
  Visual *visual;
  ColormapPtr pCmap;

  if (pWin->drawable.class == InputOnly) {
    mask = 0L;
    visual = CopyFromParent;
  }
  else {
    mask = CWEventMask | CWBackingStore;
    attributes.event_mask = ExposureMask;
    attributes.backing_store = NotUseful;
    
    if (pWin->parent) {
      if (pWin->optional && pWin->optional->visual != wVisual(pWin->parent)) {
	visual = xnestVisualFromID(pWin->drawable.pScreen, wVisual(pWin));
	mask |= CWColormap;
	if (pWin->optional->colormap) {
	  dixLookupResourceByType((pointer *)&pCmap, wColormap(pWin),
				  RT_COLORMAP, serverClient, DixUseAccess);
	  attributes.colormap = xnestColormap(pCmap);
	}
	else
	  attributes.colormap = xnestDefaultVisualColormap(visual);
      }
      else 
	visual = CopyFromParent;
    }
    else { /* root windows have their own colormaps at creation time */
      visual = xnestVisualFromID(pWin->drawable.pScreen, wVisual(pWin));      
      dixLookupResourceByType((pointer *)&pCmap, wColormap(pWin),
			      RT_COLORMAP, serverClient, DixUseAccess);
      mask |= CWColormap;
      attributes.colormap = xnestColormap(pCmap);
    }
  }
  
  xnestWindowPriv(pWin)->window = XCreateWindow(xnestDisplay,
						xnestWindowParent(pWin),
						pWin->origin.x - 
						wBorderWidth(pWin),
						pWin->origin.y - 
						wBorderWidth(pWin),
						pWin->drawable.width,
						pWin->drawable.height,
						pWin->borderWidth,
						pWin->drawable.depth, 
						pWin->drawable.class,
						visual,
						mask, &attributes);
  xnestWindowPriv(pWin)->parent = xnestWindowParent(pWin);
  xnestWindowPriv(pWin)->x = pWin->origin.x - wBorderWidth(pWin);
  xnestWindowPriv(pWin)->y = pWin->origin.y - wBorderWidth(pWin);
  xnestWindowPriv(pWin)->width = pWin->drawable.width;
  xnestWindowPriv(pWin)->height = pWin->drawable.height;
  xnestWindowPriv(pWin)->border_width = pWin->borderWidth;
  xnestWindowPriv(pWin)->sibling_above = None;
  if (pWin->nextSib)
    xnestWindowPriv(pWin->nextSib)->sibling_above = xnestWindow(pWin);
  xnestWindowPriv(pWin)->bounding_shape = 
    RegionCreate(NULL, 1);
  xnestWindowPriv(pWin)->clip_shape = 
    RegionCreate(NULL, 1);

  if (!pWin->parent) /* only the root window will have the right colormap */
    xnestSetInstalledColormapWindows(pWin->drawable.pScreen);
  
  return True;
d152 7
a158 7
  if (pWin->nextSib)
    xnestWindowPriv(pWin->nextSib)->sibling_above = 
      xnestWindowPriv(pWin)->sibling_above;
  RegionDestroy(xnestWindowPriv(pWin)->bounding_shape);
  RegionDestroy(xnestWindowPriv(pWin)->clip_shape);
  XDestroyWindow(xnestDisplay, xnestWindow(pWin));
  xnestWindowPriv(pWin)->window = None;
d160 2
a161 2
  if (pWin->optional && pWin->optional->colormap && pWin->parent)
    xnestSetInstalledColormapWindows(pWin->drawable.pScreen);
d163 1
a163 1
  return True;
d169 5
a173 7
  xnestConfigureWindow(pWin, 
		       CWParent |
		       CWX | CWY | 
		       CWWidth | CWHeight | 
		       CWBorderWidth);
  
  return True;
d179 32
a210 2
  unsigned int valuemask;
  XWindowChanges values;
d212 44
a255 79
  if (mask & CWParent &&
      xnestWindowPriv(pWin)->parent != xnestWindowParent(pWin)) {
    XReparentWindow(xnestDisplay, xnestWindow(pWin), 
		    xnestWindowParent(pWin), 
		    pWin->origin.x - wBorderWidth(pWin),
		    pWin->origin.y - wBorderWidth(pWin));
    xnestWindowPriv(pWin)->parent = xnestWindowParent(pWin);
    xnestWindowPriv(pWin)->x = pWin->origin.x - wBorderWidth(pWin);
    xnestWindowPriv(pWin)->y = pWin->origin.y - wBorderWidth(pWin);
    xnestWindowPriv(pWin)->sibling_above = None;
    if (pWin->nextSib)
      xnestWindowPriv(pWin->nextSib)->sibling_above = xnestWindow(pWin);
  }
  
  valuemask = 0;
  
  if (mask & CWX &&
      xnestWindowPriv(pWin)->x != pWin->origin.x - wBorderWidth(pWin)) {
    valuemask |= CWX;
    values.x =
      xnestWindowPriv(pWin)->x = 
	pWin->origin.x - wBorderWidth(pWin);
  }

  if (mask & CWY &&
      xnestWindowPriv(pWin)->y != pWin->origin.y - wBorderWidth(pWin)) {
    valuemask |= CWY;
    values.y =
      xnestWindowPriv(pWin)->y = 
	pWin->origin.y - wBorderWidth(pWin);
  }

  if (mask & CWWidth &&
      xnestWindowPriv(pWin)->width != pWin->drawable.width) {
    valuemask |= CWWidth;
    values.width = 
      xnestWindowPriv(pWin)->width = 
	pWin->drawable.width;
  }
  
  if (mask & CWHeight &&
      xnestWindowPriv(pWin)->height != pWin->drawable.height) {
    valuemask |= CWHeight;
    values.height = 
      xnestWindowPriv(pWin)->height = 
	pWin->drawable.height;
  }
  
  if (mask & CWBorderWidth &&
      xnestWindowPriv(pWin)->border_width != pWin->borderWidth) {
    valuemask |= CWBorderWidth;
    values.border_width = 
      xnestWindowPriv(pWin)->border_width = 
	pWin->borderWidth;
  }
 
  if (valuemask)
    XConfigureWindow(xnestDisplay, xnestWindow(pWin), valuemask, &values);  
  
  if (mask & CWStackingOrder &&
      xnestWindowPriv(pWin)->sibling_above != xnestWindowSiblingAbove(pWin)) {
    WindowPtr pSib;
    
    /* find the top sibling */
    for (pSib = pWin; pSib->prevSib != NullWindow; pSib = pSib->prevSib);
    
    /* the top sibling */
    valuemask = CWStackMode;
    values.stack_mode = Above;
    XConfigureWindow(xnestDisplay, xnestWindow(pSib), valuemask, &values); 
    xnestWindowPriv(pSib)->sibling_above = None;

    /* the rest of siblings */
    for (pSib = pSib->nextSib; pSib != NullWindow; pSib = pSib->nextSib) {
      valuemask = CWSibling | CWStackMode;
      values.sibling = xnestWindowSiblingAbove(pSib);
      values.stack_mode = Below;
      XConfigureWindow(xnestDisplay, xnestWindow(pSib), valuemask, &values);
      xnestWindowPriv(pSib)->sibling_above = xnestWindowSiblingAbove(pSib);
a256 1
  }
d262 65
a326 47
  XSetWindowAttributes attributes;
  
  if (mask & CWBackPixmap)
    switch (pWin->backgroundState) {
    case None:
      attributes.background_pixmap = None;
      break;
      
    case ParentRelative:
      attributes.background_pixmap = ParentRelative;
      break;
      
    case BackgroundPixmap:
      attributes.background_pixmap = xnestPixmap(pWin->background.pixmap);
      break;

    case BackgroundPixel:
      mask &= ~CWBackPixmap;  
      break;
    }

  if (mask & CWBackPixel) {
    if (pWin->backgroundState == BackgroundPixel)
      attributes.background_pixel = xnestPixel(pWin->background.pixel);
    else
      mask &= ~CWBackPixel;
  }
  
  if (mask & CWBorderPixmap) {
    if (pWin->borderIsPixel)
      mask &= ~CWBorderPixmap;
    else
      attributes.border_pixmap = xnestPixmap(pWin->border.pixmap);
  }
  
  if (mask & CWBorderPixel) {
    if (pWin->borderIsPixel)
      attributes.border_pixel = xnestPixel(pWin->border.pixel);
    else
      mask &= ~CWBorderPixel;
  }
  
  if (mask & CWBitGravity) 
    attributes.bit_gravity = pWin->bitGravity;
  
  if (mask & CWWinGravity) /* dix does this for us */
    mask &= ~CWWinGravity;
d328 2
a329 2
  if (mask & CWBackingStore) /* this is really not useful */
    mask &= ~CWBackingStore;
d331 2
a332 2
  if (mask & CWBackingPlanes) /* this is really not useful */
    mask &= ~CWBackingPlanes;
d334 2
a335 2
  if (mask & CWBackingPixel) /* this is really not useful */ 
    mask &= ~CWBackingPixel;
d337 1
a337 2
  if (mask & CWOverrideRedirect)
    attributes.override_redirect = pWin->overrideRedirect;
d339 2
a340 2
  if (mask & CWSaveUnder) /* this is really not useful */
    mask &= ~CWSaveUnder;
d342 2
a343 2
  if (mask & CWEventMask) /* events are handled elsewhere */
    mask &= ~CWEventMask;
d345 3
a347 2
  if (mask & CWDontPropagate) /* events are handled elsewhere */
    mask &= ~CWDontPropagate; 
d349 2
a350 20
  if (mask & CWColormap) {
    ColormapPtr pCmap;
    
    dixLookupResourceByType((pointer *)&pCmap, wColormap(pWin), RT_COLORMAP,
			    serverClient, DixUseAccess);

    attributes.colormap = xnestColormap(pCmap);

    xnestSetInstalledColormapWindows(pWin->drawable.pScreen);
  }

  if (mask & CWCursor) /* this is handeled in cursor code */
    mask &= ~CWCursor;

  if (mask)
    XChangeWindowAttributes(xnestDisplay, xnestWindow(pWin),
			    mask, &attributes);
  
  return True;
}	  
d355 3
a357 3
  xnestConfigureWindow(pWin, CWStackingOrder);
  xnestShapeWindow(pWin);
  XMapWindow(xnestDisplay, xnestWindow(pWin));
d359 1
a359 1
  return True;
d365 1
a365 1
  XUnmapWindow(xnestDisplay, xnestWindow(pWin));
d367 1
a367 1
  return True;
d378 2
a379 2
  xnestConfigureWindow(pWin, CWStackingOrder); 
  xnestShapeWindow(pWin);
d383 1
a383 1
xnestWindowExposurePredicate(Display *display, XEvent *event, XPointer ptr)
d385 1
a385 1
  return (event->type == Expose && event->xexpose.window == *(Window *)ptr);
d391 23
a413 23
  XEvent event;
  Window window;
  BoxRec Box;
  
  XSync(xnestDisplay, False);
  
  window = xnestWindow(pWin);
  
  while (XCheckIfEvent(xnestDisplay, &event, 
		       xnestWindowExposurePredicate, (char *)&window)) {
    
    Box.x1 = pWin->drawable.x + wBorderWidth(pWin) + event.xexpose.x;
    Box.y1 = pWin->drawable.y + wBorderWidth(pWin) + event.xexpose.y;
    Box.x2 = Box.x1 + event.xexpose.width;
    Box.y2 = Box.y1 + event.xexpose.height;
	
    event.xexpose.type = ProcessedExpose;
	
    if (RegionContainsRect(pRgn, &Box) != rgnIN)
      XPutBackEvent(xnestDisplay, &event);
  }
  
  miWindowExposures(pWin, pRgn, other_exposed);
d419 2
a420 2
  xnestShapeWindow(pWin);
  miSetShape(pWin, kind);
d426 2
a427 2
  BoxPtr pBox1, pBox2;
  unsigned int n1, n2;
d429 2
a430 1
  if (pReg1 == pReg2) return True;
d432 2
a433 1
  if (pReg1 == NullRegion || pReg2 == NullRegion) return False;
d435 2
a436 2
  pBox1 = RegionRects(pReg1);
  n1 = RegionNumRects(pReg1);
d438 2
a439 2
  pBox2 = RegionRects(pReg2);
  n2 = RegionNumRects(pReg2);
d441 2
a442 1
  if (n1 != n2) return False;
d444 2
a445 1
  if (pBox1 == pBox2) return True;
d447 2
a448 1
  if (memcmp(pBox1, pBox2, n1 * sizeof(BoxRec))) return False;
d450 1
a450 1
  return True;
d456 33
a488 25
  Region reg;
  BoxPtr pBox;
  XRectangle rect;
  int i;

  if (!xnestRegionEqual(xnestWindowPriv(pWin)->bounding_shape,
			wBoundingShape(pWin))) {
    
    if (wBoundingShape(pWin)) {
      RegionCopy(xnestWindowPriv(pWin)->bounding_shape, wBoundingShape(pWin));
      
      reg = XCreateRegion();
      pBox = RegionRects(xnestWindowPriv(pWin)->bounding_shape);
      for (i = 0; 
	   i < RegionNumRects(xnestWindowPriv(pWin)->bounding_shape);
	   i++) {
        rect.x = pBox[i].x1;
        rect.y = pBox[i].y1;
        rect.width = pBox[i].x2 - pBox[i].x1;
        rect.height = pBox[i].y2 - pBox[i].y1;
        XUnionRectWithRegion(&rect, reg, reg);
      }
      XShapeCombineRegion(xnestDisplay, xnestWindow(pWin),
			  ShapeBounding, 0, 0, reg, ShapeSet);
      XDestroyRegion(reg);
d490 26
a515 34
    else {
      RegionEmpty(xnestWindowPriv(pWin)->bounding_shape);
      
      XShapeCombineMask(xnestDisplay, xnestWindow(pWin),
			ShapeBounding, 0, 0, None, ShapeSet);
    }
  }
  
  if (!xnestRegionEqual(xnestWindowPriv(pWin)->clip_shape,
			wClipShape(pWin))) {
    
    if (wClipShape(pWin)) {
      RegionCopy(xnestWindowPriv(pWin)->clip_shape, wClipShape(pWin));
      
      reg = XCreateRegion();
      pBox = RegionRects(xnestWindowPriv(pWin)->clip_shape);
      for (i = 0; 
	   i < RegionNumRects(xnestWindowPriv(pWin)->clip_shape);
	   i++) {
        rect.x = pBox[i].x1;
        rect.y = pBox[i].y1;
        rect.width = pBox[i].x2 - pBox[i].x1;
        rect.height = pBox[i].y2 - pBox[i].y1;
        XUnionRectWithRegion(&rect, reg, reg);
      }
      XShapeCombineRegion(xnestDisplay, xnestWindow(pWin),
			  ShapeClip, 0, 0, reg, ShapeSet);
      XDestroyRegion(reg);
    }
    else {
      RegionEmpty(xnestWindowPriv(pWin)->clip_shape);
      
      XShapeCombineMask(xnestDisplay, xnestWindow(pWin),
			ShapeClip, 0, 0, None, ShapeSet);
a516 1
  }
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d42 1
a42 2
static int xnestWindowPrivateKeyIndex;
DevPrivateKey xnestWindowPrivateKey = &xnestWindowPrivateKeyIndex;
d137 1
a137 1
    REGION_CREATE(pWin->drawable.pScreen, NULL, 1);
d139 1
a139 1
    REGION_CREATE(pWin->drawable.pScreen, NULL, 1);
d153 2
a154 4
  REGION_DESTROY(pWin->drawable.pScreen, 
				xnestWindowPriv(pWin)->bounding_shape);
  REGION_DESTROY(pWin->drawable.pScreen, 
				xnestWindowPriv(pWin)->clip_shape);
d415 1
a415 1
    if (RECT_IN_REGION(pWin->drawable.pScreen, pRgn, &Box) != rgnIN)
d423 1
a423 1
xnestSetShape(WindowPtr pWin)
d426 1
a426 1
  miSetShape(pWin);
d439 2
a440 2
  pBox1 = REGION_RECTS(pReg1);
  n1 = REGION_NUM_RECTS(pReg1);
d442 2
a443 2
  pBox2 = REGION_RECTS(pReg2);
  n2 = REGION_NUM_RECTS(pReg2);
d466 1
a466 2
      REGION_COPY(pWin->drawable.pScreen, 
		xnestWindowPriv(pWin)->bounding_shape, wBoundingShape(pWin));
d469 1
a469 1
      pBox = REGION_RECTS(xnestWindowPriv(pWin)->bounding_shape);
d471 1
a471 1
	   i < REGION_NUM_RECTS(xnestWindowPriv(pWin)->bounding_shape);
d484 1
a484 2
      REGION_EMPTY(pWin->drawable.pScreen, 
				xnestWindowPriv(pWin)->bounding_shape);
d495 1
a495 2
      REGION_COPY(pWin->drawable.pScreen, 
			xnestWindowPriv(pWin)->clip_shape, wClipShape(pWin));
d498 1
a498 1
      pBox = REGION_RECTS(xnestWindowPriv(pWin)->clip_shape);
d500 1
a500 1
	   i < REGION_NUM_RECTS(xnestWindowPriv(pWin)->clip_shape);
d513 1
a513 2
      REGION_EMPTY(pWin->drawable.pScreen, 
				     xnestWindowPriv(pWin)->clip_shape);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d96 2
a97 1
	  pCmap = (ColormapPtr)LookupIDByType(wColormap(pWin), RT_COLORMAP);
d108 2
a109 1
      pCmap = (ColormapPtr)LookupIDByType(wColormap(pWin), RT_COLORMAP);
d343 2
a344 1
    pCmap = (ColormapPtr)LookupIDByType(wColormap(pWin), RT_COLORMAP);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d42 2
a43 1
DevPrivateKey xnestWindowPrivateKey = &xnestWindowPrivateKey;
a134 1
#ifdef SHAPE
a138 1
#endif /* SHAPE */
a151 1
#ifdef SHAPE
a155 1
#endif
a361 1
#ifdef SHAPE
a362 1
#endif /* SHAPE */
a384 1
#ifdef SHAPE
a385 1
#endif /* SHAPE */
a421 1
#ifdef SHAPE
a523 1
#endif /* SHAPE */
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
int xnestWindowPrivateIndex;
a378 24
}

void
xnestPaintWindowBackground(WindowPtr pWin, RegionPtr pRegion, int what)
{
  int i;
  BoxPtr pBox;

  xnestConfigureWindow(pWin, CWWidth | CWHeight);

  pBox = REGION_RECTS(pRegion);
  for (i = 0; i < REGION_NUM_RECTS(pRegion); i++)
    XClearArea(xnestDisplay, xnestWindow(pWin),
	       pBox[i].x1 - pWin->drawable.x,
	       pBox[i].y1 - pWin->drawable.y,
	       pBox[i].x2 - pBox[i].x1, 
	       pBox[i].y2 - pBox[i].y1,
	       False);
}

void
xnestPaintWindowBorder(WindowPtr pWin, RegionPtr pRegion, int what)
{
  xnestConfigureWindow(pWin, CWBorderWidth);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
