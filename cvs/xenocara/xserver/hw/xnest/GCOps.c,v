head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.10
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.8
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.6
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.8
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.1.1.0.16
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	cVXoV5PxI8YrEaVA;

1.4
date	2014.05.02.19.27.49;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.46;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.46;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*

Copyright 1993 by Davor Matic

Permission to use, copy, modify, distribute, and sell this software
and its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation.  Davor Matic makes no representations about
the suitability of this software for any purpose.  It is provided "as
is" without express or implied warranty.

*/

#ifdef HAVE_XNEST_CONFIG_H
#include <xnest-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "regionstr.h"
#include <X11/fonts/fontstruct.h>
#include "gcstruct.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "region.h"
#include "servermd.h"

#include "Xnest.h"

#include "Display.h"
#include "Screen.h"
#include "XNGC.h"
#include "XNFont.h"
#include "GCOps.h"
#include "Drawable.h"
#include "Visual.h"

void
xnestFillSpans(DrawablePtr pDrawable, GCPtr pGC, int nSpans, xPoint * pPoints,
               int *pWidths, int fSorted)
{
    ErrorF("xnest warning: function xnestFillSpans not implemented\n");
}

void
xnestSetSpans(DrawablePtr pDrawable, GCPtr pGC, char *pSrc,
              xPoint * pPoints, int *pWidths, int nSpans, int fSorted)
{
    ErrorF("xnest warning: function xnestSetSpans not implemented\n");
}

void
xnestGetSpans(DrawablePtr pDrawable, int maxWidth, DDXPointPtr pPoints,
              int *pWidths, int nSpans, char *pBuffer)
{
    ErrorF("xnest warning: function xnestGetSpans not implemented\n");
}

void
xnestQueryBestSize(int class, unsigned short *pWidth, unsigned short *pHeight,
                   ScreenPtr pScreen)
{
    unsigned int width, height;

    width = *pWidth;
    height = *pHeight;

    XQueryBestSize(xnestDisplay, class,
                   xnestDefaultWindows[pScreen->myNum],
                   width, height, &width, &height);

    *pWidth = width;
    *pHeight = height;
}

void
xnestPutImage(DrawablePtr pDrawable, GCPtr pGC, int depth, int x, int y,
              int w, int h, int leftPad, int format, char *pImage)
{
    XImage *ximage;

    ximage = XCreateImage(xnestDisplay, xnestDefaultVisual(pDrawable->pScreen),
                          depth, format, leftPad, (char *) pImage,
                          w, h, BitmapPad(xnestDisplay),
                          (format == ZPixmap) ?
                          PixmapBytePad(w, depth) : BitmapBytePad(w + leftPad));

    if (ximage) {
        XPutImage(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
                  ximage, 0, 0, x, y, w, h);
        XFree(ximage);
    }
}

static int
xnestIgnoreErrorHandler (Display     *dpy,
                         XErrorEvent *event)
{
    return False; /* return value is ignored */
}

void
xnestGetImage(DrawablePtr pDrawable, int x, int y, int w, int h,
              unsigned int format, unsigned long planeMask, char *pImage)
{
    XImage *ximage;
    int length;
    int (*old_handler)(Display*, XErrorEvent*);

    /* we may get BadMatch error when xnest window is minimized */
    XSync(xnestDisplay, False);
    old_handler = XSetErrorHandler (xnestIgnoreErrorHandler);

    ximage = XGetImage(xnestDisplay, xnestDrawable(pDrawable),
                       x, y, w, h, planeMask, format);
    XSetErrorHandler(old_handler);

    if (ximage) {
        length = ximage->bytes_per_line * ximage->height;

        memmove(pImage, ximage->data, length);

        XDestroyImage(ximage);
    }
}

static Bool
xnestBitBlitPredicate(Display * dpy, XEvent * event, char *args)
{
    return event->type == GraphicsExpose || event->type == NoExpose;
}

static RegionPtr
xnestBitBlitHelper(GCPtr pGC)
{
    if (!pGC->graphicsExposures)
        return NullRegion;
    else {
        XEvent event;
        RegionPtr pReg, pTmpReg;
        BoxRec Box;
        Bool pending, overlap;

        pReg = RegionCreate(NULL, 1);
        pTmpReg = RegionCreate(NULL, 1);
        if (!pReg || !pTmpReg)
            return NullRegion;

        pending = True;
        while (pending) {
            XIfEvent(xnestDisplay, &event, xnestBitBlitPredicate, NULL);

            switch (event.type) {
            case NoExpose:
                pending = False;
                break;

            case GraphicsExpose:
                Box.x1 = event.xgraphicsexpose.x;
                Box.y1 = event.xgraphicsexpose.y;
                Box.x2 = event.xgraphicsexpose.x + event.xgraphicsexpose.width;
                Box.y2 = event.xgraphicsexpose.y + event.xgraphicsexpose.height;
                RegionReset(pTmpReg, &Box);
                RegionAppend(pReg, pTmpReg);
                pending = event.xgraphicsexpose.count;
                break;
            }
        }

        RegionDestroy(pTmpReg);
        RegionValidate(pReg, &overlap);
        return pReg;
    }
}

RegionPtr
xnestCopyArea(DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable,
              GCPtr pGC, int srcx, int srcy, int width, int height,
              int dstx, int dsty)
{
    XCopyArea(xnestDisplay,
              xnestDrawable(pSrcDrawable), xnestDrawable(pDstDrawable),
              xnestGC(pGC), srcx, srcy, width, height, dstx, dsty);

    return xnestBitBlitHelper(pGC);
}

RegionPtr
xnestCopyPlane(DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable,
               GCPtr pGC, int srcx, int srcy, int width, int height,
               int dstx, int dsty, unsigned long plane)
{
    XCopyPlane(xnestDisplay,
               xnestDrawable(pSrcDrawable), xnestDrawable(pDstDrawable),
               xnestGC(pGC), srcx, srcy, width, height, dstx, dsty, plane);

    return xnestBitBlitHelper(pGC);
}

void
xnestPolyPoint(DrawablePtr pDrawable, GCPtr pGC, int mode, int nPoints,
               DDXPointPtr pPoints)
{
    XDrawPoints(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
                (XPoint *) pPoints, nPoints, mode);
}

void
xnestPolylines(DrawablePtr pDrawable, GCPtr pGC, int mode, int nPoints,
               DDXPointPtr pPoints)
{
    XDrawLines(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
               (XPoint *) pPoints, nPoints, mode);
}

void
xnestPolySegment(DrawablePtr pDrawable, GCPtr pGC, int nSegments,
                 xSegment * pSegments)
{
    XDrawSegments(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
                  (XSegment *) pSegments, nSegments);
}

void
xnestPolyRectangle(DrawablePtr pDrawable, GCPtr pGC, int nRectangles,
                   xRectangle *pRectangles)
{
    XDrawRectangles(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
                    (XRectangle *) pRectangles, nRectangles);
}

void
xnestPolyArc(DrawablePtr pDrawable, GCPtr pGC, int nArcs, xArc * pArcs)
{
    XDrawArcs(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
              (XArc *) pArcs, nArcs);
}

void
xnestFillPolygon(DrawablePtr pDrawable, GCPtr pGC, int shape, int mode,
                 int nPoints, DDXPointPtr pPoints)
{
    XFillPolygon(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
                 (XPoint *) pPoints, nPoints, shape, mode);
}

void
xnestPolyFillRect(DrawablePtr pDrawable, GCPtr pGC, int nRectangles,
                  xRectangle *pRectangles)
{
    XFillRectangles(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
                    (XRectangle *) pRectangles, nRectangles);
}

void
xnestPolyFillArc(DrawablePtr pDrawable, GCPtr pGC, int nArcs, xArc * pArcs)
{
    XFillArcs(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
              (XArc *) pArcs, nArcs);
}

int
xnestPolyText8(DrawablePtr pDrawable, GCPtr pGC, int x, int y, int count,
               char *string)
{
    int width;

    XDrawString(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
                x, y, string, count);

    width = XTextWidth(xnestFontStruct(pGC->font), string, count);

    return width + x;
}

int
xnestPolyText16(DrawablePtr pDrawable, GCPtr pGC, int x, int y, int count,
                unsigned short *string)
{
    int width;

    XDrawString16(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
                  x, y, (XChar2b *) string, count);

    width = XTextWidth16(xnestFontStruct(pGC->font), (XChar2b *) string, count);

    return width + x;
}

void
xnestImageText8(DrawablePtr pDrawable, GCPtr pGC, int x, int y, int count,
                char *string)
{
    XDrawImageString(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
                     x, y, string, count);
}

void
xnestImageText16(DrawablePtr pDrawable, GCPtr pGC, int x, int y, int count,
                 unsigned short *string)
{
    XDrawImageString16(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
                       x, y, (XChar2b *) string, count);
}

void
xnestImageGlyphBlt(DrawablePtr pDrawable, GCPtr pGC, int x, int y,
                   unsigned int nGlyphs, CharInfoPtr * pCharInfo,
                   void *pGlyphBase)
{
    ErrorF("xnest warning: function xnestImageGlyphBlt not implemented\n");
}

void
xnestPolyGlyphBlt(DrawablePtr pDrawable, GCPtr pGC, int x, int y,
                  unsigned int nGlyphs, CharInfoPtr * pCharInfo,
                  void *pGlyphBase)
{
    ErrorF("xnest warning: function xnestPolyGlyphBlt not implemented\n");
}

void
xnestPushPixels(GCPtr pGC, PixmapPtr pBitmap, DrawablePtr pDst,
                int width, int height, int x, int y)
{
    /* only works for solid bitmaps */
    if (pGC->fillStyle == FillSolid) {
        XSetStipple(xnestDisplay, xnestGC(pGC), xnestPixmap(pBitmap));
        XSetTSOrigin(xnestDisplay, xnestGC(pGC), x, y);
        XSetFillStyle(xnestDisplay, xnestGC(pGC), FillStippled);
        XFillRectangle(xnestDisplay, xnestDrawable(pDst),
                       xnestGC(pGC), x, y, width, height);
        XSetFillStyle(xnestDisplay, xnestGC(pGC), FillSolid);
    }
    else
        ErrorF("xnest warning: function xnestPushPixels not implemented\n");
}
@


1.4
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d98 1
a98 1
xnestIgnoreErrorHandler (Display     *display,
d130 1
a130 1
xnestBitBlitPredicate(Display * display, XEvent * event, char *args)
d311 1
a311 1
                   pointer pGlyphBase)
d319 1
a319 1
                  pointer pGlyphBase)
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d97 7
d110 5
d118 1
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d41 2
a42 2
xnestFillSpans(DrawablePtr pDrawable, GCPtr pGC, int nSpans, xPoint *pPoints,
	       int *pWidths, int fSorted)
d44 1
a44 1
  ErrorF("xnest warning: function xnestFillSpans not implemented\n");
d49 1
a49 1
	      xPoint *pPoints, int *pWidths, int nSpans, int fSorted)
d51 1
a51 1
  ErrorF("xnest warning: function xnestSetSpans not implemented\n");
d56 1
a56 1
	      int *pWidths, int nSpans, char *pBuffer)
d58 1
a58 1
  ErrorF("xnest warning: function xnestGetSpans not implemented\n");
d63 1
a63 1
		   ScreenPtr pScreen)
d65 1
a65 1
  unsigned int width, height;
d67 2
a68 2
  width = *pWidth;
  height = *pHeight;
d70 6
a75 6
  XQueryBestSize(xnestDisplay, class, 
		 xnestDefaultWindows[pScreen->myNum], 
		 width, height, &width, &height);
  
  *pWidth = width;
  *pHeight = height;
d80 1
a80 1
	      int w, int h, int leftPad, int format, char *pImage)
d82 13
a94 13
  XImage *ximage;
  
  ximage = XCreateImage(xnestDisplay, xnestDefaultVisual(pDrawable->pScreen), 
			depth, format, leftPad, (char *)pImage, 
			w, h, BitmapPad(xnestDisplay), 
			(format == ZPixmap) ? 
			   PixmapBytePad(w, depth) : BitmapBytePad(w+leftPad));
  
  if (ximage) {
      XPutImage(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC), 
		ximage, 0, 0, x, y, w, h);
      XFree(ximage);
  }
d99 1
a99 2
	      unsigned int format, unsigned long planeMask,
	      char *pImage)
d101 2
a102 2
  XImage *ximage;
  int length;
d104 2
a105 2
  ximage = XGetImage(xnestDisplay, xnestDrawable(pDrawable),
                     x, y, w, h, planeMask, format);
d107 7
a113 7
  if (ximage) {
      length = ximage->bytes_per_line * ximage->height;
  
      memmove(pImage, ximage->data, length);
  
      XDestroyImage(ximage);
  }
d117 1
a117 1
xnestBitBlitPredicate(Display *display, XEvent *event, char *args)
d119 1
a119 1
  return event->type == GraphicsExpose || event->type == NoExpose;
d125 37
a161 31
  if (!pGC->graphicsExposures) 
    return NullRegion;
  else {
    XEvent event;
    RegionPtr pReg, pTmpReg;
    BoxRec Box;
    Bool pending, overlap;

    pReg = RegionCreate(NULL, 1);
    pTmpReg = RegionCreate(NULL, 1);
    if(!pReg || !pTmpReg) return NullRegion;
    
    pending = True;
    while (pending) {
      XIfEvent(xnestDisplay, &event, xnestBitBlitPredicate, NULL);
      
      switch (event.type) {
      case NoExpose:
	pending = False;
	break;
	
      case GraphicsExpose:
	Box.x1 = event.xgraphicsexpose.x;
	Box.y1 = event.xgraphicsexpose.y;
	Box.x2 = event.xgraphicsexpose.x + event.xgraphicsexpose.width;
	Box.y2 = event.xgraphicsexpose.y + event.xgraphicsexpose.height;
	RegionReset(pTmpReg, &Box);
	RegionAppend(pReg, pTmpReg);
	pending = event.xgraphicsexpose.count;
	break;
      }
a162 5

    RegionDestroy(pTmpReg);
    RegionValidate(pReg, &overlap);
    return pReg;
  }
d167 2
a168 2
	      GCPtr pGC, int srcx, int srcy, int width, int height,
	      int dstx, int dsty)
d170 5
a174 5
  XCopyArea(xnestDisplay, 
	    xnestDrawable(pSrcDrawable), xnestDrawable(pDstDrawable),
	    xnestGC(pGC), srcx, srcy, width, height, dstx, dsty);
  
  return xnestBitBlitHelper(pGC);
d179 2
a180 2
	       GCPtr pGC, int srcx, int srcy, int width, int height,
	       int dstx, int dsty, unsigned long plane)
d182 5
a186 5
  XCopyPlane(xnestDisplay, 
	     xnestDrawable(pSrcDrawable), xnestDrawable(pDstDrawable),
	     xnestGC(pGC), srcx, srcy, width, height, dstx, dsty, plane);
  
  return xnestBitBlitHelper(pGC);
d191 1
a191 1
	       DDXPointPtr pPoints)
d193 2
a194 2
  XDrawPoints(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC), 
              (XPoint *)pPoints, nPoints, mode);
d199 1
a199 1
	       DDXPointPtr pPoints)
d201 2
a202 2
  XDrawLines(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC), 
              (XPoint *)pPoints, nPoints, mode);
d207 1
a207 1
		 xSegment *pSegments)
d209 2
a210 2
  XDrawSegments(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC), 
                (XSegment *)pSegments, nSegments);
d215 1
a215 1
		   xRectangle *pRectangles)
d217 2
a218 2
  XDrawRectangles(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
                  (XRectangle *)pRectangles, nRectangles);
d222 1
a222 1
xnestPolyArc(DrawablePtr pDrawable, GCPtr pGC, int nArcs, xArc *pArcs)
d224 2
a225 2
  XDrawArcs(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
            (XArc *)pArcs, nArcs);
d230 1
a230 1
		 int nPoints, DDXPointPtr pPoints)
d232 2
a233 2
  XFillPolygon(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC), 
               (XPoint *)pPoints, nPoints, shape, mode);
d238 1
a238 1
		  xRectangle *pRectangles)
d240 2
a241 2
  XFillRectangles(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
                  (XRectangle *)pRectangles, nRectangles);
d245 1
a245 1
xnestPolyFillArc(DrawablePtr pDrawable, GCPtr pGC, int nArcs, xArc *pArcs)
d247 2
a248 2
  XFillArcs(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
            (XArc *)pArcs, nArcs);
d253 1
a253 1
	       char *string)
d255 1
a255 1
  int width;
d257 6
a262 6
  XDrawString(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
              x, y, string, count);
  
  width = XTextWidth(xnestFontStruct(pGC->font), string, count);
  
  return width + x;
d267 1
a267 1
		unsigned short *string)
d269 1
a269 1
  int width;
d271 2
a272 2
  XDrawString16(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
                x, y, (XChar2b *)string, count);
d274 1
a274 1
  width = XTextWidth16(xnestFontStruct(pGC->font), (XChar2b *)string, count);
d276 1
a276 1
  return width + x;
d281 1
a281 1
		char *string)
d283 2
a284 2
  XDrawImageString(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
                   x, y, string, count);
d289 1
a289 1
		 unsigned short *string)
d291 2
a292 2
  XDrawImageString16(xnestDisplay, xnestDrawable(pDrawable), xnestGC(pGC),
                     x, y, (XChar2b *)string, count);
d297 2
a298 2
		   unsigned int nGlyphs, CharInfoPtr *pCharInfo,
		   pointer pGlyphBase)
d300 1
a300 1
  ErrorF("xnest warning: function xnestImageGlyphBlt not implemented\n");
d305 2
a306 2
		  unsigned int nGlyphs, CharInfoPtr *pCharInfo,
		  pointer pGlyphBase)
d308 1
a308 1
  ErrorF("xnest warning: function xnestPolyGlyphBlt not implemented\n");
d313 1
a313 1
		int width, int height, int x, int y)
d315 11
a325 12
  /* only works for solid bitmaps */
  if (pGC->fillStyle == FillSolid)
  {
    XSetStipple (xnestDisplay, xnestGC(pGC), xnestPixmap(pBitmap));
    XSetTSOrigin (xnestDisplay, xnestGC(pGC), x, y);
    XSetFillStyle (xnestDisplay, xnestGC(pGC), FillStippled);
    XFillRectangle (xnestDisplay, xnestDrawable(pDst),
		    xnestGC(pGC), x, y, width, height);
    XSetFillStyle (xnestDisplay, xnestGC(pGC), FillSolid);
  }
  else
    ErrorF("xnest warning: function xnestPushPixels not implemented\n");
@


1.1
log
@Initial revision
@
text
@d120 1
a120 1
  return (event->type == GraphicsExpose || event->type == NoExpose);
d134 2
a135 2
    pReg = REGION_CREATE(pGC->pScreen, NULL, 1);
    pTmpReg = REGION_CREATE(pGC->pScreen, NULL, 1);
d152 2
a153 2
	REGION_RESET(pGC->pScreen, pTmpReg, &Box);
	REGION_APPEND(pGC->pScreen, pReg, pTmpReg);
d159 3
a161 3
    REGION_DESTROY(pGC->pScreen, pTmpReg);
    REGION_VALIDATE(pGC->pScreen, pReg, &overlap);
    return(pReg);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
