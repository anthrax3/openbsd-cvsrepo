head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.4
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2016.05.29.12.02.38;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	s0SI41sEunLdyFfd;

1.7
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.53;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.44;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.44;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.03.25;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*

Copyright 1993 by Davor Matic

Permission to use, copy, modify, distribute, and sell this software
and its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation.  Davor Matic makes no representations about
the suitability of this software for any purpose.  It is provided "as
is" without express or implied warranty.

*/

#ifdef HAVE_XNEST_CONFIG_H
#include <xnest-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "scrnintstr.h"
#include "window.h"
#include "windowstr.h"
#include "colormapst.h"
#include "resource.h"

#include "Xnest.h"

#include "Display.h"
#include "Screen.h"
#include "Color.h"
#include "Visual.h"
#include "XNWindow.h"
#include "Args.h"

DevPrivateKeyRec xnestColormapPrivateKeyRec;

static DevPrivateKeyRec cmapScrPrivateKeyRec;

#define cmapScrPrivateKey (&cmapScrPrivateKeyRec)

#define GetInstalledColormap(s) ((ColormapPtr) dixLookupPrivate(&(s)->devPrivates, cmapScrPrivateKey))
#define SetInstalledColormap(s,c) (dixSetPrivate(&(s)->devPrivates, cmapScrPrivateKey, c))

Bool
xnestCreateColormap(ColormapPtr pCmap)
{
    VisualPtr pVisual;
    XColor *colors;
    int i, ncolors;
    Pixel red, green, blue;
    Pixel redInc, greenInc, blueInc;

    pVisual = pCmap->pVisual;
    ncolors = pVisual->ColormapEntries;

    xnestColormapPriv(pCmap)->colormap =
        XCreateColormap(xnestDisplay,
                        xnestDefaultWindows[pCmap->pScreen->myNum],
                        xnestVisual(pVisual),
                        (pVisual->class & DynamicClass) ? AllocAll : AllocNone);

    switch (pVisual->class) {
    case StaticGray:           /* read only */
        colors = xallocarray(ncolors, sizeof(XColor));
        for (i = 0; i < ncolors; i++)
            colors[i].pixel = i;
        XQueryColors(xnestDisplay, xnestColormap(pCmap), colors, ncolors);
        for (i = 0; i < ncolors; i++) {
            pCmap->red[i].co.local.red = colors[i].red;
            pCmap->red[i].co.local.green = colors[i].red;
            pCmap->red[i].co.local.blue = colors[i].red;
        }
        free(colors);
        break;

    case StaticColor:          /* read only */
        colors = xallocarray(ncolors, sizeof(XColor));
        for (i = 0; i < ncolors; i++)
            colors[i].pixel = i;
        XQueryColors(xnestDisplay, xnestColormap(pCmap), colors, ncolors);
        for (i = 0; i < ncolors; i++) {
            pCmap->red[i].co.local.red = colors[i].red;
            pCmap->red[i].co.local.green = colors[i].green;
            pCmap->red[i].co.local.blue = colors[i].blue;
        }
        free(colors);
        break;

    case TrueColor:            /* read only */
        colors = xallocarray(ncolors, sizeof(XColor));
        red = green = blue = 0L;
        redInc = lowbit(pVisual->redMask);
        greenInc = lowbit(pVisual->greenMask);
        blueInc = lowbit(pVisual->blueMask);
        for (i = 0; i < ncolors; i++) {
            colors[i].pixel = red | green | blue;
            red += redInc;
            if (red > pVisual->redMask)
                red = 0L;
            green += greenInc;
            if (green > pVisual->greenMask)
                green = 0L;
            blue += blueInc;
            if (blue > pVisual->blueMask)
                blue = 0L;
        }
        XQueryColors(xnestDisplay, xnestColormap(pCmap), colors, ncolors);
        for (i = 0; i < ncolors; i++) {
            pCmap->red[i].co.local.red = colors[i].red;
            pCmap->green[i].co.local.green = colors[i].green;
            pCmap->blue[i].co.local.blue = colors[i].blue;
        }
        free(colors);
        break;

    case GrayScale:            /* read and write */
        break;

    case PseudoColor:          /* read and write */
        break;

    case DirectColor:          /* read and write */
        break;
    }

    return True;
}

void
xnestDestroyColormap(ColormapPtr pCmap)
{
    XFreeColormap(xnestDisplay, xnestColormap(pCmap));
}

#define SEARCH_PREDICATE \
  (xnestWindow(pWin) != None && wColormap(pWin) == icws->cmapIDs[i])

static int
xnestCountInstalledColormapWindows(WindowPtr pWin, void *ptr)
{
    xnestInstalledColormapWindows *icws = (xnestInstalledColormapWindows *) ptr;
    int i;

    for (i = 0; i < icws->numCmapIDs; i++)
        if (SEARCH_PREDICATE) {
            icws->numWindows++;
            return WT_DONTWALKCHILDREN;
        }

    return WT_WALKCHILDREN;
}

static int
xnestGetInstalledColormapWindows(WindowPtr pWin, void *ptr)
{
    xnestInstalledColormapWindows *icws = (xnestInstalledColormapWindows *) ptr;
    int i;

    for (i = 0; i < icws->numCmapIDs; i++)
        if (SEARCH_PREDICATE) {
            icws->windows[icws->index++] = xnestWindow(pWin);
            return WT_DONTWALKCHILDREN;
        }

    return WT_WALKCHILDREN;
}

static Window *xnestOldInstalledColormapWindows = NULL;
static int xnestNumOldInstalledColormapWindows = 0;

static Bool
xnestSameInstalledColormapWindows(Window *windows, int numWindows)
{
    if (xnestNumOldInstalledColormapWindows != numWindows)
        return False;

    if (xnestOldInstalledColormapWindows == windows)
        return True;

    if (xnestOldInstalledColormapWindows == NULL || windows == NULL)
        return False;

    if (memcmp(xnestOldInstalledColormapWindows, windows,
               numWindows * sizeof(Window)))
        return False;

    return True;
}

void
xnestSetInstalledColormapWindows(ScreenPtr pScreen)
{
    xnestInstalledColormapWindows icws;
    int numWindows;

    icws.cmapIDs = xallocarray(pScreen->maxInstalledCmaps, sizeof(Colormap));
    icws.numCmapIDs = xnestListInstalledColormaps(pScreen, icws.cmapIDs);
    icws.numWindows = 0;
    WalkTree(pScreen, xnestCountInstalledColormapWindows, (void *) &icws);
    if (icws.numWindows) {
        icws.windows = xallocarray(icws.numWindows + 1, sizeof(Window));
        icws.index = 0;
        WalkTree(pScreen, xnestGetInstalledColormapWindows, (void *) &icws);
        icws.windows[icws.numWindows] = xnestDefaultWindows[pScreen->myNum];
        numWindows = icws.numWindows + 1;
    }
    else {
        icws.windows = NULL;
        numWindows = 0;
    }

    free(icws.cmapIDs);

    if (!xnestSameInstalledColormapWindows(icws.windows, icws.numWindows)) {
        free(xnestOldInstalledColormapWindows);

#ifdef _XSERVER64
        {
            int i;
            Window64 *windows = xallocarray(numWindows, sizeof(Window64));

            for (i = 0; i < numWindows; ++i)
                windows[i] = icws.windows[i];
            XSetWMColormapWindows(xnestDisplay,
                                  xnestDefaultWindows[pScreen->myNum], windows,
                                  numWindows);
            free(windows);
        }
#else
        XSetWMColormapWindows(xnestDisplay, xnestDefaultWindows[pScreen->myNum],
                              icws.windows, numWindows);
#endif

        xnestOldInstalledColormapWindows = icws.windows;
        xnestNumOldInstalledColormapWindows = icws.numWindows;

#ifdef DUMB_WINDOW_MANAGERS
        /*
           This code is for dumb window managers.
           This will only work with default local visual colormaps.
         */
        if (icws.numWindows) {
            WindowPtr pWin;
            Visual *visual;
            ColormapPtr pCmap;

            pWin = xnestWindowPtr(icws.windows[0]);
            visual = xnestVisualFromID(pScreen, wVisual(pWin));

            if (visual == xnestDefaultVisual(pScreen))
                dixLookupResourceByType((void **) &pCmap, wColormap(pWin),
                                        RT_COLORMAP, serverClient,
                                        DixUseAccess);
            else
                dixLookupResourceByType((void **) &pCmap,
                                        pScreen->defColormap, RT_COLORMAP,
                                        serverClient, DixUseAccess);

            XSetWindowColormap(xnestDisplay,
                               xnestDefaultWindows[pScreen->myNum],
                               xnestColormap(pCmap));
        }
#endif                          /* DUMB_WINDOW_MANAGERS */
    }
    else
        free(icws.windows);
}

void
xnestSetScreenSaverColormapWindow(ScreenPtr pScreen)
{
    free(xnestOldInstalledColormapWindows);

#ifdef _XSERVER64
    {
        Window64 window;

        window = xnestScreenSaverWindows[pScreen->myNum];
        XSetWMColormapWindows(xnestDisplay, xnestDefaultWindows[pScreen->myNum],
                              &window, 1);
        xnestScreenSaverWindows[pScreen->myNum] = window;
    }
#else
    XSetWMColormapWindows(xnestDisplay, xnestDefaultWindows[pScreen->myNum],
                          &xnestScreenSaverWindows[pScreen->myNum], 1);
#endif                          /* _XSERVER64 */

    xnestOldInstalledColormapWindows = NULL;
    xnestNumOldInstalledColormapWindows = 0;

    xnestDirectUninstallColormaps(pScreen);
}

void
xnestDirectInstallColormaps(ScreenPtr pScreen)
{
    int i, n;
    Colormap pCmapIDs[MAXCMAPS];

    if (!xnestDoDirectColormaps)
        return;

    n = (*pScreen->ListInstalledColormaps) (pScreen, pCmapIDs);

    for (i = 0; i < n; i++) {
        ColormapPtr pCmap;

        dixLookupResourceByType((void **) &pCmap, pCmapIDs[i], RT_COLORMAP,
                                serverClient, DixInstallAccess);
        if (pCmap)
            XInstallColormap(xnestDisplay, xnestColormap(pCmap));
    }
}

void
xnestDirectUninstallColormaps(ScreenPtr pScreen)
{
    int i, n;
    Colormap pCmapIDs[MAXCMAPS];

    if (!xnestDoDirectColormaps)
        return;

    n = (*pScreen->ListInstalledColormaps) (pScreen, pCmapIDs);

    for (i = 0; i < n; i++) {
        ColormapPtr pCmap;

        dixLookupResourceByType((void **) &pCmap, pCmapIDs[i], RT_COLORMAP,
                                serverClient, DixUninstallAccess);
        if (pCmap)
            XUninstallColormap(xnestDisplay, xnestColormap(pCmap));
    }
}

void
xnestInstallColormap(ColormapPtr pCmap)
{
    ColormapPtr pOldCmap = GetInstalledColormap(pCmap->pScreen);

    if (pCmap != pOldCmap) {
        xnestDirectUninstallColormaps(pCmap->pScreen);

        /* Uninstall pInstalledMap. Notify all interested parties. */
        if (pOldCmap != (ColormapPtr) None)
            WalkTree(pCmap->pScreen, TellLostMap, (void *) &pOldCmap->mid);

        SetInstalledColormap(pCmap->pScreen, pCmap);
        WalkTree(pCmap->pScreen, TellGainedMap, (void *) &pCmap->mid);

        xnestSetInstalledColormapWindows(pCmap->pScreen);
        xnestDirectInstallColormaps(pCmap->pScreen);
    }
}

void
xnestUninstallColormap(ColormapPtr pCmap)
{
    ColormapPtr pCurCmap = GetInstalledColormap(pCmap->pScreen);

    if (pCmap == pCurCmap) {
        if (pCmap->mid != pCmap->pScreen->defColormap) {
            dixLookupResourceByType((void **) &pCurCmap,
                                    pCmap->pScreen->defColormap,
                                    RT_COLORMAP,
                                    serverClient, DixInstallAccess);
            (*pCmap->pScreen->InstallColormap) (pCurCmap);
        }
    }
}

static Bool xnestInstalledDefaultColormap = False;

int
xnestListInstalledColormaps(ScreenPtr pScreen, Colormap * pCmapIDs)
{
    if (xnestInstalledDefaultColormap) {
        *pCmapIDs = GetInstalledColormap(pScreen)->mid;
        return 1;
    }
    else
        return 0;
}

void
xnestStoreColors(ColormapPtr pCmap, int nColors, xColorItem * pColors)
{
    if (pCmap->pVisual->class & DynamicClass)
#ifdef _XSERVER64
    {
        int i;
        XColor *pColors64 = xallocarray(nColors, sizeof(XColor));

        for (i = 0; i < nColors; ++i) {
            pColors64[i].pixel = pColors[i].pixel;
            pColors64[i].red = pColors[i].red;
            pColors64[i].green = pColors[i].green;
            pColors64[i].blue = pColors[i].blue;
            pColors64[i].flags = pColors[i].flags;
        }
        XStoreColors(xnestDisplay, xnestColormap(pCmap), pColors64, nColors);
        free(pColors64);
    }
#else
        XStoreColors(xnestDisplay, xnestColormap(pCmap),
                     (XColor *) pColors, nColors);
#endif
}

void
xnestResolveColor(unsigned short *pRed, unsigned short *pGreen,
                  unsigned short *pBlue, VisualPtr pVisual)
{
    int shift;
    unsigned int lim;

    shift = 16 - pVisual->bitsPerRGBValue;
    lim = (1 << pVisual->bitsPerRGBValue) - 1;

    if ((pVisual->class == PseudoColor) || (pVisual->class == DirectColor)) {
        /* rescale to rgb bits */
        *pRed = ((*pRed >> shift) * 65535) / lim;
        *pGreen = ((*pGreen >> shift) * 65535) / lim;
        *pBlue = ((*pBlue >> shift) * 65535) / lim;
    }
    else if (pVisual->class == GrayScale) {
        /* rescale to gray then rgb bits */
        *pRed = (30L * *pRed + 59L * *pGreen + 11L * *pBlue) / 100;
        *pBlue = *pGreen = *pRed = ((*pRed >> shift) * 65535) / lim;
    }
    else if (pVisual->class == StaticGray) {
        unsigned int limg;

        limg = pVisual->ColormapEntries - 1;
        /* rescale to gray then [0..limg] then [0..65535] then rgb bits */
        *pRed = (30L * *pRed + 59L * *pGreen + 11L * *pBlue) / 100;
        *pRed = ((((*pRed * (limg + 1))) >> 16) * 65535) / limg;
        *pBlue = *pGreen = *pRed = ((*pRed >> shift) * 65535) / lim;
    }
    else {
        unsigned limr, limg, limb;

        limr = pVisual->redMask >> pVisual->offsetRed;
        limg = pVisual->greenMask >> pVisual->offsetGreen;
        limb = pVisual->blueMask >> pVisual->offsetBlue;
        /* rescale to [0..limN] then [0..65535] then rgb bits */
        *pRed = ((((((*pRed * (limr + 1)) >> 16) *
                    65535) / limr) >> shift) * 65535) / lim;
        *pGreen = ((((((*pGreen * (limg + 1)) >> 16) *
                      65535) / limg) >> shift) * 65535) / lim;
        *pBlue = ((((((*pBlue * (limb + 1)) >> 16) *
                     65535) / limb) >> shift) * 65535) / lim;
    }
}

Bool
xnestCreateDefaultColormap(ScreenPtr pScreen)
{
    VisualPtr pVisual;
    ColormapPtr pCmap;
    unsigned short zero = 0, ones = 0xFFFF;
    Pixel wp, bp;

    if (!dixRegisterPrivateKey(&cmapScrPrivateKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    for (pVisual = pScreen->visuals;
         pVisual->vid != pScreen->rootVisual; pVisual++);

    if (CreateColormap(pScreen->defColormap, pScreen, pVisual, &pCmap,
                       (pVisual->class & DynamicClass) ? AllocNone : AllocAll,
                       0)
        != Success)
        return False;

    wp = pScreen->whitePixel;
    bp = pScreen->blackPixel;
    if ((AllocColor(pCmap, &ones, &ones, &ones, &wp, 0) !=
         Success) ||
        (AllocColor(pCmap, &zero, &zero, &zero, &bp, 0) != Success))
        return FALSE;
    pScreen->whitePixel = wp;
    pScreen->blackPixel = bp;
    (*pScreen->InstallColormap) (pCmap);

    xnestInstalledDefaultColormap = True;

    return True;
}
@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d65 1
a65 1
        colors = (XColor *) malloc(ncolors * sizeof(XColor));
d78 1
a78 1
        colors = (XColor *) malloc(ncolors * sizeof(XColor));
d91 1
a91 1
        colors = (XColor *) malloc(ncolors * sizeof(XColor));
d197 1
a197 2
    icws.cmapIDs = (Colormap *) malloc(pScreen->maxInstalledCmaps *
                                       sizeof(Colormap));
d202 1
a202 2
        icws.windows =
            (Window *) malloc((icws.numWindows + 1) * sizeof(Window));
d221 1
a221 2
            Window64 *windows =
                (Window64 *) malloc(numWindows * sizeof(Window64));
d393 1
a393 1
        XColor *pColors64 = (XColor *) malloc(nColors * sizeof(XColor));
@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d242 1
a242 1
        /* 
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d140 1
a140 1
xnestCountInstalledColormapWindows(WindowPtr pWin, pointer ptr)
d155 1
a155 1
xnestGetInstalledColormapWindows(WindowPtr pWin, pointer ptr)
d201 1
a201 1
    WalkTree(pScreen, xnestCountInstalledColormapWindows, (pointer) &icws);
d206 1
a206 1
        WalkTree(pScreen, xnestGetInstalledColormapWindows, (pointer) &icws);
d255 1
a255 1
                dixLookupResourceByType((pointer *) &pCmap, wColormap(pWin),
d259 1
a259 1
                dixLookupResourceByType((pointer *) &pCmap,
d312 1
a312 1
        dixLookupResourceByType((pointer *) &pCmap, pCmapIDs[i], RT_COLORMAP,
d333 1
a333 1
        dixLookupResourceByType((pointer *) &pCmap, pCmapIDs[i], RT_COLORMAP,
d350 1
a350 1
            WalkTree(pCmap->pScreen, TellLostMap, (pointer) &pOldCmap->mid);
d353 1
a353 1
        WalkTree(pCmap->pScreen, TellGainedMap, (pointer) &pCmap->mid);
d367 1
a367 1
            dixLookupResourceByType((pointer *) &pCurCmap,
@


1.4
log
@Update to xserver 1.11.2
@
text
@a28 1

d39 1
d48 80
a127 79
  VisualPtr pVisual;
  XColor *colors;
  int i, ncolors;
  Pixel red, green, blue;
  Pixel redInc, greenInc, blueInc;

  pVisual = pCmap->pVisual;
  ncolors = pVisual->ColormapEntries;

  xnestColormapPriv(pCmap)->colormap = 
    XCreateColormap(xnestDisplay,
		    xnestDefaultWindows[pCmap->pScreen->myNum],
		    xnestVisual(pVisual),
		    (pVisual->class & DynamicClass) ? 
		    AllocAll : AllocNone);
 
  
  switch (pVisual->class) {
  case StaticGray: /* read only */
    colors = (XColor *)malloc(ncolors * sizeof(XColor));
    for (i = 0; i < ncolors; i++)
      colors[i].pixel = i;
    XQueryColors(xnestDisplay, xnestColormap(pCmap), colors, ncolors);
    for (i = 0; i < ncolors; i++) {
      pCmap->red[i].co.local.red = colors[i].red;
      pCmap->red[i].co.local.green = colors[i].red;
      pCmap->red[i].co.local.blue = colors[i].red;
    }
    free(colors);
    break;

  case StaticColor: /* read only */
    colors = (XColor *)malloc(ncolors * sizeof(XColor));
    for (i = 0; i < ncolors; i++)
      colors[i].pixel = i;
    XQueryColors(xnestDisplay, xnestColormap(pCmap), colors, ncolors);
    for (i = 0; i < ncolors; i++) {
      pCmap->red[i].co.local.red = colors[i].red;
      pCmap->red[i].co.local.green = colors[i].green;
      pCmap->red[i].co.local.blue = colors[i].blue;
    }
    free(colors);
    break;
    
  case TrueColor: /* read only */
    colors = (XColor *)malloc(ncolors * sizeof(XColor));
    red = green = blue = 0L;
    redInc = lowbit(pVisual->redMask);
    greenInc = lowbit(pVisual->greenMask);
    blueInc = lowbit(pVisual->blueMask);
    for (i = 0; i < ncolors; i++) {
      colors[i].pixel = red | green | blue;
      red += redInc;
      if (red > pVisual->redMask) red = 0L;
      green += greenInc;
      if (green > pVisual->greenMask) green = 0L;
      blue += blueInc;
      if (blue > pVisual->blueMask) blue = 0L;
    }
    XQueryColors(xnestDisplay, xnestColormap(pCmap), colors, ncolors);
    for (i = 0; i < ncolors; i++) {
      pCmap->red[i].co.local.red = colors[i].red;
      pCmap->green[i].co.local.green = colors[i].green;
      pCmap->blue[i].co.local.blue = colors[i].blue;
    }
    free(colors);
    break;
    
  case GrayScale: /* read and write */
    break;

  case PseudoColor: /* read and write */
    break;

  case DirectColor: /* read and write */
    break;
  }
  
  return True;
d133 1
a133 1
  XFreeColormap(xnestDisplay, xnestColormap(pCmap));
d142 10
a151 10
  xnestInstalledColormapWindows *icws = (xnestInstalledColormapWindows *)ptr;
  int i;
  
  for (i = 0; i < icws->numCmapIDs; i++)
    if (SEARCH_PREDICATE) {
      icws->numWindows++;
      return WT_DONTWALKCHILDREN;
    }
  
  return WT_WALKCHILDREN;
d157 10
a166 10
  xnestInstalledColormapWindows *icws = (xnestInstalledColormapWindows *)ptr;
  int i;
  
  for (i = 0; i < icws->numCmapIDs; i++)
    if (SEARCH_PREDICATE) {
      icws->windows[icws->index++] = xnestWindow(pWin);
      return WT_DONTWALKCHILDREN;
    }
  
  return WT_WALKCHILDREN;
d175 2
a176 2
  if (xnestNumOldInstalledColormapWindows != numWindows) 
    return False;
d178 2
a179 2
  if (xnestOldInstalledColormapWindows == windows) 
    return True;
d181 2
a182 2
  if (xnestOldInstalledColormapWindows == NULL || windows == NULL) 
    return False;
d184 3
a186 3
  if (memcmp(xnestOldInstalledColormapWindows, windows, 
	   numWindows * sizeof(Window))) 
    return False;
d188 1
a188 1
  return True;
d194 25
a218 24
  xnestInstalledColormapWindows icws;
  int numWindows;
  
  icws.cmapIDs = (Colormap *)malloc(pScreen->maxInstalledCmaps *
				    sizeof(Colormap));
  icws.numCmapIDs = xnestListInstalledColormaps(pScreen, icws.cmapIDs);
  icws.numWindows = 0;
  WalkTree(pScreen, xnestCountInstalledColormapWindows, (pointer)&icws);
  if (icws.numWindows) {
    icws.windows = (Window *)malloc((icws.numWindows + 1) * sizeof(Window));
    icws.index = 0;
    WalkTree(pScreen, xnestGetInstalledColormapWindows, (pointer)&icws);
    icws.windows[icws.numWindows] = xnestDefaultWindows[pScreen->myNum];
    numWindows = icws.numWindows + 1;
  }
  else {
    icws.windows = NULL;
    numWindows = 0;
  }
  
  free(icws.cmapIDs);
  
  if (!xnestSameInstalledColormapWindows(icws.windows, icws.numWindows)) {
    free(xnestOldInstalledColormapWindows);
d221 12
a232 10
    {
      int i;
      Window64 *windows = (Window64 *)malloc(numWindows * sizeof(Window64));

      for(i = 0; i < numWindows; ++i)
	  windows[i] = icws.windows[i];
      XSetWMColormapWindows(xnestDisplay, xnestDefaultWindows[pScreen->myNum],
			    windows, numWindows);
      free(windows);
    }
d234 2
a235 2
    XSetWMColormapWindows(xnestDisplay, xnestDefaultWindows[pScreen->myNum],
			  icws.windows, numWindows);
d238 2
a239 2
    xnestOldInstalledColormapWindows = icws.windows;
    xnestNumOldInstalledColormapWindows = icws.numWindows;
d242 29
a270 28
    /* 
      This code is for dumb window managers.
      This will only work with default local visual colormaps.
      */
    if (icws.numWindows)
      {
	WindowPtr pWin;
	Visual *visual;
	ColormapPtr pCmap;

	pWin = xnestWindowPtr(icws.windows[0]);
	visual = xnestVisualFromID(pScreen, wVisual(pWin));
	
	if (visual == xnestDefaultVisual(pScreen))
	    dixLookupResourceByType((pointer *)&pCmap, wColormap(pWin),
				    RT_COLORMAP, serverClient, DixUseAccess);
	else
	    dixLookupResourceByType((pointer *)&pCmap, pScreen->defColormap,
				    RT_COLORMAP, serverClient, DixUseAccess);
	
	XSetWindowColormap(xnestDisplay, 
			   xnestDefaultWindows[pScreen->myNum],
			   xnestColormap(pCmap));
      }
#endif /* DUMB_WINDOW_MANAGERS */
  }
  else
    free(icws.windows);
d276 2
a277 2
  free(xnestOldInstalledColormapWindows);
  
d279 2
a280 2
  {
    Window64 window;
d282 6
a287 1
    window = xnestScreenSaverWindows[pScreen->myNum];
d289 5
a293 10
			  &window, 1);
    xnestScreenSaverWindows[pScreen->myNum] = window;
  }
#else
  XSetWMColormapWindows(xnestDisplay, xnestDefaultWindows[pScreen->myNum],
			&xnestScreenSaverWindows[pScreen->myNum], 1);
#endif /* _XSERVER64 */
  
  xnestOldInstalledColormapWindows = NULL;
  xnestNumOldInstalledColormapWindows = 0;
d295 1
a295 1
  xnestDirectUninstallColormaps(pScreen);
d301 7
a307 4
  int i, n;
  Colormap pCmapIDs[MAXCMAPS];
  
  if (!xnestDoDirectColormaps) return;
d309 2
a310 1
  n = (*pScreen->ListInstalledColormaps)(pScreen, pCmapIDs);
d312 5
a316 8
  for (i = 0; i < n; i++) {
    ColormapPtr pCmap;
    
    dixLookupResourceByType((pointer *)&pCmap, pCmapIDs[i], RT_COLORMAP,
			    serverClient, DixInstallAccess);
    if (pCmap)
      XInstallColormap(xnestDisplay, xnestColormap(pCmap));
  }
d322 2
a323 2
  int i, n;
  Colormap pCmapIDs[MAXCMAPS];
d325 2
a326 1
  if (!xnestDoDirectColormaps) return;
d328 1
a328 1
  n = (*pScreen->ListInstalledColormaps)(pScreen, pCmapIDs);
d330 8
a337 8
  for (i = 0; i < n; i++) {
    ColormapPtr pCmap;
    
    dixLookupResourceByType((pointer *)&pCmap, pCmapIDs[i], RT_COLORMAP,
			    serverClient, DixUninstallAccess);
    if (pCmap)
      XUninstallColormap(xnestDisplay, xnestColormap(pCmap));
  }
d343 11
a353 5
  ColormapPtr pOldCmap = GetInstalledColormap(pCmap->pScreen);
  
  if(pCmap != pOldCmap)
    {
      xnestDirectUninstallColormaps(pCmap->pScreen);
d355 2
a356 9
      /* Uninstall pInstalledMap. Notify all interested parties. */
      if(pOldCmap != (ColormapPtr)None)
	WalkTree(pCmap->pScreen, TellLostMap, (pointer)&pOldCmap->mid);
      
      SetInstalledColormap(pCmap->pScreen, pCmap);
      WalkTree(pCmap->pScreen, TellGainedMap, (pointer)&pCmap->mid);
      
      xnestSetInstalledColormapWindows(pCmap->pScreen);
      xnestDirectInstallColormaps(pCmap->pScreen);
d363 9
a371 11
  ColormapPtr pCurCmap = GetInstalledColormap(pCmap->pScreen);
  
  if(pCmap == pCurCmap)
    {
      if (pCmap->mid != pCmap->pScreen->defColormap)
        {
	  dixLookupResourceByType((pointer *)&pCurCmap,
				  pCmap->pScreen->defColormap,
				  RT_COLORMAP,
				  serverClient, DixInstallAccess);
	  (*pCmap->pScreen->InstallColormap)(pCurCmap);
d379 1
a379 1
xnestListInstalledColormaps(ScreenPtr pScreen, Colormap *pCmapIDs)
d381 6
a386 6
  if (xnestInstalledDefaultColormap) {
    *pCmapIDs = GetInstalledColormap(pScreen)->mid;
    return 1;
  }
  else
    return 0;
d390 1
a390 1
xnestStoreColors(ColormapPtr pCmap, int nColors, xColorItem *pColors)
d392 1
a392 1
  if (pCmap->pVisual->class & DynamicClass)
d394 3
a396 3
  {
    int i;
    XColor *pColors64 = (XColor *)malloc(nColors * sizeof(XColor) );
d398 10
a407 11
    for(i = 0; i < nColors; ++i)
    {
      pColors64[i].pixel = pColors[i].pixel;
      pColors64[i].red = pColors[i].red;
      pColors64[i].green = pColors[i].green;
      pColors64[i].blue = pColors[i].blue;
      pColors64[i].flags = pColors[i].flags;
    }
    XStoreColors(xnestDisplay, xnestColormap(pCmap), pColors64, nColors);
    free(pColors64);
  }
d409 2
a410 2
    XStoreColors(xnestDisplay, xnestColormap(pCmap),
		 (XColor *)pColors, nColors);
d416 1
a416 1
		  unsigned short *pBlue, VisualPtr pVisual)
d418 5
a422 5
  int shift;
  unsigned int lim;
  
  shift = 16 - pVisual->bitsPerRGBValue;
  lim = (1 << pVisual->bitsPerRGBValue) - 1;
d424 33
a456 37
  if ((pVisual->class == PseudoColor) || (pVisual->class == DirectColor))
    {
      /* rescale to rgb bits */
      *pRed = ((*pRed >> shift) * 65535) / lim;
      *pGreen = ((*pGreen >> shift) * 65535) / lim;
      *pBlue = ((*pBlue >> shift) * 65535) / lim;
    }
  else if (pVisual->class == GrayScale)
    {
      /* rescale to gray then rgb bits */
      *pRed = (30L * *pRed + 59L * *pGreen + 11L * *pBlue) / 100;
      *pBlue = *pGreen = *pRed = ((*pRed >> shift) * 65535) / lim;
    }
  else if (pVisual->class == StaticGray)
    {
      unsigned int limg;
 
      limg = pVisual->ColormapEntries - 1;
      /* rescale to gray then [0..limg] then [0..65535] then rgb bits */
      *pRed = (30L * *pRed + 59L * *pGreen + 11L * *pBlue) / 100;
      *pRed = ((((*pRed * (limg + 1))) >> 16) * 65535) / limg;
      *pBlue = *pGreen = *pRed = ((*pRed >> shift) * 65535) / lim;
    }
  else
    {
      unsigned limr, limg, limb;
      
      limr = pVisual->redMask >> pVisual->offsetRed;
      limg = pVisual->greenMask >> pVisual->offsetGreen;
      limb = pVisual->blueMask >> pVisual->offsetBlue;
      /* rescale to [0..limN] then [0..65535] then rgb bits */
      *pRed = ((((((*pRed * (limr + 1)) >> 16) *
		  65535) / limr) >> shift) * 65535) / lim;
      *pGreen = ((((((*pGreen * (limg + 1)) >> 16) *
		    65535) / limg) >> shift) * 65535) / lim;
      *pBlue = ((((((*pBlue * (limb + 1)) >> 16) *
		   65535) / limb) >> shift) * 65535) / lim;
d463 4
a466 27
  VisualPtr   pVisual;
  ColormapPtr pCmap;
  unsigned short zero = 0, ones = 0xFFFF;  
  Pixel wp, bp;

  if (!dixRegisterPrivateKey(&cmapScrPrivateKeyRec, PRIVATE_SCREEN, 0))
      return FALSE;

  for (pVisual = pScreen->visuals;
       pVisual->vid != pScreen->rootVisual;
       pVisual++);

  if (CreateColormap(pScreen->defColormap, pScreen, pVisual, &pCmap,
		     (pVisual->class & DynamicClass) ? AllocNone : AllocAll, 0)
      != Success)
    return False;

  wp = pScreen->whitePixel;
  bp = pScreen->blackPixel;
  if ((AllocColor(pCmap, &ones, &ones, &ones, &wp, 0) !=
       Success) ||
      (AllocColor(pCmap, &zero, &zero, &zero, &bp, 0) !=
       Success))
    return FALSE;
  pScreen->whitePixel = wp;
  pScreen->blackPixel = bp;
  (*pScreen->InstallColormap)(pCmap);
d468 2
a469 1
  xnestInstalledDefaultColormap = True;
d471 22
a492 1
  return True;
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d37 2
a56 2
  pCmap->devPriv = (pointer)malloc(sizeof(xnestPrivColormap));
  
a132 1
  free(pCmap->devPriv);
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d37 5
a41 1
static ColormapPtr InstalledMaps[MAXSCREENS];
d55 1
a55 1
  pCmap->devPriv = (pointer)xalloc(sizeof(xnestPrivColormap));
d67 1
a67 1
    colors = (XColor *)xalloc(ncolors * sizeof(XColor));
d76 1
a76 1
    xfree(colors);
d80 1
a80 1
    colors = (XColor *)xalloc(ncolors * sizeof(XColor));
d89 1
a89 1
    xfree(colors);
d93 1
a93 1
    colors = (XColor *)xalloc(ncolors * sizeof(XColor));
d113 1
a113 1
    xfree(colors);
d133 1
a133 1
  xfree(pCmap->devPriv);
d197 1
a197 1
  icws.cmapIDs = (Colormap *)xalloc(pScreen->maxInstalledCmaps *
d203 1
a203 1
    icws.windows = (Window *)xalloc((icws.numWindows + 1) * sizeof(Window));
d214 1
a214 1
  xfree(icws.cmapIDs);
d217 1
a217 2
    if (xnestOldInstalledColormapWindows)
      xfree(xnestOldInstalledColormapWindows);
d222 1
a222 1
      Window64 *windows = (Window64 *)xalloc(numWindows * sizeof(Window64));
d228 1
a228 1
      xfree(windows);
d266 1
a266 1
    if (icws.windows) xfree(icws.windows);
d272 1
a272 2
  if (xnestOldInstalledColormapWindows)
    xfree(xnestOldInstalledColormapWindows);
d337 1
a337 5
  int index;
  ColormapPtr pOldCmap;
  
  index = pCmap->pScreen->myNum;
  pOldCmap = InstalledMaps[index];
d347 1
a347 1
      InstalledMaps[index] = pCmap;
d358 1
a358 5
  int index;
  ColormapPtr pCurCmap;
  
  index = pCmap->pScreen->myNum;
  pCurCmap = InstalledMaps[index];
d379 1
a379 1
    *pCmapIDs = InstalledMaps[pScreen->myNum]->mid;
d393 1
a393 1
    XColor *pColors64 = (XColor *)xalloc(nColors * sizeof(XColor) );
d404 1
a404 1
    xfree(pColors64);
d469 3
@


1.1
log
@Initial revision
@
text
@a13 1
/* $XFree86$ */
d245 1
a245 1
	
d250 2
a251 2
	  pCmap = (ColormapPtr)LookupIDByType(wColormap(pWin), 
					      RT_COLORMAP);
d253 2
a254 2
	  pCmap = (ColormapPtr)LookupIDByType(pScreen->defColormap, 
					      RT_COLORMAP);
d305 2
a306 1
    pCmap = (ColormapPtr)LookupIDByType(pCmapIDs[i], RT_COLORMAP);
d325 2
a326 1
    pCmap = (ColormapPtr)LookupIDByType(pCmapIDs[i], RT_COLORMAP);
d370 4
a373 2
	  pCurCmap = (ColormapPtr)LookupIDByType(pCmap->pScreen->defColormap,
						 RT_COLORMAP);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d14 1
@

