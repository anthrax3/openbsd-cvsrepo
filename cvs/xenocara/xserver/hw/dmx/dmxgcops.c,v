head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.8
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.6
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.40;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.40;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Kevin E. Martin <kem@@redhat.com>
 *
 */

/** \file
 * This file provides support for GC operations. */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include "dmx.h"
#include "dmxsync.h"
#include "dmxgc.h"
#include "dmxgcops.h"
#include "dmxwindow.h"
#include "dmxpixmap.h"

#include "mi.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "dixfontstr.h"

#ifdef PANORAMIX
#include "panoramiXsrv.h"
#endif

#define DMX_GCOPS_SET_DRAWABLE(_pDraw, _draw)				\
do {									\
    if ((_pDraw)->type == DRAWABLE_WINDOW) {				\
	dmxWinPrivPtr  pWinPriv =					\
	    DMX_GET_WINDOW_PRIV((WindowPtr)(_pDraw));			\
	(_draw) = (Drawable)pWinPriv->window;				\
    } else {								\
	dmxPixPrivPtr  pPixPriv =					\
	    DMX_GET_PIXMAP_PRIV((PixmapPtr)(_pDraw));			\
	(_draw) = (Drawable)pPixPriv->pixmap;				\
    }									\
} while (0)

#define DMX_GCOPS_OFFSCREEN(_pDraw)					\
    (!dmxScreens[(_pDraw)->pScreen->myNum].beDisplay ||			\
     (dmxOffScreenOpt &&						\
      (_pDraw)->type == DRAWABLE_WINDOW &&				\
      (DMX_GET_WINDOW_PRIV((WindowPtr)(_pDraw))->offscreen ||		\
       !DMX_GET_WINDOW_PRIV((WindowPtr)(_pDraw))->window)))

/** Fill spans -- this function should never be called. */
void
dmxFillSpans(DrawablePtr pDrawable, GCPtr pGC,
             int nInit, DDXPointPtr pptInit, int *pwidthInit, int fSorted)
{
    /* Error -- this should never happen! */
}

/** Set spans -- this function should never be called. */
void
dmxSetSpans(DrawablePtr pDrawable, GCPtr pGC,
            char *psrc, DDXPointPtr ppt, int *pwidth, int nspans, int fSorted)
{
    /* Error -- this should never happen! */
}

/** Transfer \a pBits image to back-end server associated with \a
 *  pDrawable's screen.  If primitive subdivision optimization is
 *  enabled, then only transfer the sections of \a pBits that are
 *  visible (i.e., not-clipped) to the back-end server. */
void
dmxPutImage(DrawablePtr pDrawable, GCPtr pGC,
            int depth, int x, int y, int w, int h,
            int leftPad, int format, char *pBits)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pDrawable->pScreen->myNum];
    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(pGC);
    XImage *img;

    if (DMX_GCOPS_OFFSCREEN(pDrawable))
        return;

    img = XCreateImage(dmxScreen->beDisplay,
                       dmxScreen->beVisuals[dmxScreen->beDefVisualIndex].visual,
                       depth, format, leftPad, pBits, w, h,
                       BitmapPad(dmxScreen->beDisplay),
                       (format == ZPixmap) ?
                       PixmapBytePad(w, depth) : BitmapBytePad(w + leftPad));

    if (img) {
        Drawable draw;

        DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);

        if (dmxSubdividePrimitives && pGC->pCompositeClip) {
            RegionPtr pSubImages;
            RegionPtr pClip;
            BoxRec box;
            BoxPtr pBox;
            int nBox;

            box.x1 = x;
            box.y1 = y;
            box.x2 = x + w;
            box.y2 = y + h;
            pSubImages = RegionCreate(&box, 1);

            pClip = RegionCreate(NullBox, 1);
            RegionCopy(pClip, pGC->pCompositeClip);
            RegionTranslate(pClip, -pDrawable->x, -pDrawable->y);
            RegionIntersect(pSubImages, pSubImages, pClip);

            nBox = RegionNumRects(pSubImages);
            pBox = RegionRects(pSubImages);

            while (nBox--) {
                XPutImage(dmxScreen->beDisplay, draw, pGCPriv->gc, img,
                          pBox->x1 - box.x1,
                          pBox->y1 - box.y1,
                          pBox->x1,
                          pBox->y1, pBox->x2 - pBox->x1, pBox->y2 - pBox->y1);
                pBox++;
            }
            RegionDestroy(pClip);
            RegionDestroy(pSubImages);
        }
        else {
            XPutImage(dmxScreen->beDisplay, draw, pGCPriv->gc,
                      img, 0, 0, x, y, w, h);
        }
        XFree(img);             /* Use XFree instead of XDestroyImage
                                 * because pBits is passed in from the
                                 * caller. */

        dmxSync(dmxScreen, FALSE);
    }
    else {
        /* Error -- this should not happen! */
    }
}

/** Copy area from \a pSrc drawable to \a pDst drawable on the back-end
 *  server associated with \a pSrc drawable's screen.  If the offscreen
 *  optimization is enabled, only copy when both \a pSrc and \a pDst are
 *  at least partially visible. */
RegionPtr
dmxCopyArea(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
            int srcx, int srcy, int w, int h, int dstx, int dsty)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pSrc->pScreen->myNum];
    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable srcDraw, dstDraw;

    if (DMX_GCOPS_OFFSCREEN(pSrc) || DMX_GCOPS_OFFSCREEN(pDst))
        return miHandleExposures(pSrc, pDst, pGC, srcx, srcy, w, h,
                                 dstx, dsty);

    DMX_GCOPS_SET_DRAWABLE(pSrc, srcDraw);
    DMX_GCOPS_SET_DRAWABLE(pDst, dstDraw);

    XCopyArea(dmxScreen->beDisplay, srcDraw, dstDraw, pGCPriv->gc,
              srcx, srcy, w, h, dstx, dsty);
    dmxSync(dmxScreen, FALSE);

    return miHandleExposures(pSrc, pDst, pGC, srcx, srcy, w, h, dstx, dsty);
}

/** Copy plane number \a bitPlane from \a pSrc drawable to \a pDst
 *  drawable on the back-end server associated with \a pSrc drawable's
 *  screen.  If the offscreen optimization is enabled, only copy when
 *  both \a pSrc and \a pDst are at least partially visible. */
RegionPtr
dmxCopyPlane(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
             int srcx, int srcy, int width, int height,
             int dstx, int dsty, unsigned long bitPlane)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pSrc->pScreen->myNum];
    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable srcDraw, dstDraw;

    if (DMX_GCOPS_OFFSCREEN(pSrc) || DMX_GCOPS_OFFSCREEN(pDst))
        return miHandleExposures(pSrc, pDst, pGC, srcx, srcy, width, height,
                                 dstx, dsty);

    DMX_GCOPS_SET_DRAWABLE(pSrc, srcDraw);
    DMX_GCOPS_SET_DRAWABLE(pDst, dstDraw);

    XCopyPlane(dmxScreen->beDisplay, srcDraw, dstDraw, pGCPriv->gc,
               srcx, srcy, width, height, dstx, dsty, bitPlane);
    dmxSync(dmxScreen, FALSE);

    return miHandleExposures(pSrc, pDst, pGC, srcx, srcy, width, height,
                             dstx, dsty);
}

/** Render list of points, \a pptInit in \a pDrawable on the back-end
 *  server associated with \a pDrawable's screen.  If the offscreen
 *  optimization is enabled, only draw when \a pDrawable is at least
 *  partially visible. */
void
dmxPolyPoint(DrawablePtr pDrawable, GCPtr pGC,
             int mode, int npt, DDXPointPtr pptInit)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pDrawable->pScreen->myNum];
    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable draw;

    if (DMX_GCOPS_OFFSCREEN(pDrawable))
        return;

    DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);

    XDrawPoints(dmxScreen->beDisplay, draw, pGCPriv->gc,
                (XPoint *) pptInit, npt, mode);
    dmxSync(dmxScreen, FALSE);
}

/** Render list of connected lines, \a pptInit in \a pDrawable on the
 *  back-end server associated with \a pDrawable's screen.  If the
 *  offscreen optimization is enabled, only draw when \a pDrawable is at
 *  least partially visible. */
void
dmxPolylines(DrawablePtr pDrawable, GCPtr pGC,
             int mode, int npt, DDXPointPtr pptInit)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pDrawable->pScreen->myNum];
    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable draw;

    if (DMX_GCOPS_OFFSCREEN(pDrawable))
        return;

    DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);

    XDrawLines(dmxScreen->beDisplay, draw, pGCPriv->gc,
               (XPoint *) pptInit, npt, mode);
    dmxSync(dmxScreen, FALSE);
}

/** Render list of disjoint segments, \a pSegs in \a pDrawable on the
 *  back-end server associated with \a pDrawable's screen.  If the
 *  offscreen optimization is enabled, only draw when \a pDrawable is at
 *  least partially visible. */
void
dmxPolySegment(DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment * pSegs)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pDrawable->pScreen->myNum];
    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable draw;

    if (DMX_GCOPS_OFFSCREEN(pDrawable))
        return;

    DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);

    XDrawSegments(dmxScreen->beDisplay, draw, pGCPriv->gc,
                  (XSegment *) pSegs, nseg);
    dmxSync(dmxScreen, FALSE);
}

/** Render list of rectangle outlines, \a pRects in \a pDrawable on the
 *  back-end server associated with \a pDrawable's screen.  If the
 *  offscreen optimization is enabled, only draw when \a pDrawable is at
 *  least partially visible. */
void
dmxPolyRectangle(DrawablePtr pDrawable, GCPtr pGC,
                 int nrects, xRectangle *pRects)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pDrawable->pScreen->myNum];
    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable draw;

    if (DMX_GCOPS_OFFSCREEN(pDrawable))
        return;

    DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);

    XDrawRectangles(dmxScreen->beDisplay, draw, pGCPriv->gc,
                    (XRectangle *) pRects, nrects);

    dmxSync(dmxScreen, FALSE);
}

/** Render list of arc outlines, \a parcs in \a pDrawable on the
 *  back-end server associated with \a pDrawable's screen.  If the
 *  offscreen optimization is enabled, only draw when \a pDrawable is at
 *  least partially visible. */
void
dmxPolyArc(DrawablePtr pDrawable, GCPtr pGC, int narcs, xArc * parcs)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pDrawable->pScreen->myNum];
    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable draw;

    if (DMX_GCOPS_OFFSCREEN(pDrawable))
        return;

    DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);

    XDrawArcs(dmxScreen->beDisplay, draw, pGCPriv->gc, (XArc *) parcs, narcs);
    dmxSync(dmxScreen, FALSE);
}

/** Render a filled polygons in \a pDrawable on the back-end server
 *  associated with \a pDrawable's screen.  If the offscreen
 *  optimization is enabled, only draw when \a pDrawable is at least
 *  partially visible. */
void
dmxFillPolygon(DrawablePtr pDrawable, GCPtr pGC,
               int shape, int mode, int count, DDXPointPtr pPts)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pDrawable->pScreen->myNum];
    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable draw;

    if (DMX_GCOPS_OFFSCREEN(pDrawable))
        return;

    DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);

    XFillPolygon(dmxScreen->beDisplay, draw, pGCPriv->gc,
                 (XPoint *) pPts, count, shape, mode);
    dmxSync(dmxScreen, FALSE);
}

/** Render list of filled rectangles, \a prectInit in \a pDrawable on
 *  the back-end server associated with \a pDrawable's screen.  If the
 *  offscreen optimization is enabled, only draw when \a pDrawable is at
 *  least partially visible. */
void
dmxPolyFillRect(DrawablePtr pDrawable, GCPtr pGC,
                int nrectFill, xRectangle *prectInit)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pDrawable->pScreen->myNum];
    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable draw;

    if (DMX_GCOPS_OFFSCREEN(pDrawable))
        return;

    DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);

    XFillRectangles(dmxScreen->beDisplay, draw, pGCPriv->gc,
                    (XRectangle *) prectInit, nrectFill);
    dmxSync(dmxScreen, FALSE);
}

/** Render list of filled arcs, \a parcs in \a pDrawable on the back-end
 *  server associated with \a pDrawable's screen.  If the offscreen
 *  optimization is enabled, only draw when \a pDrawable is at least
 *  partially visible. */
void
dmxPolyFillArc(DrawablePtr pDrawable, GCPtr pGC, int narcs, xArc * parcs)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pDrawable->pScreen->myNum];
    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable draw;

    if (DMX_GCOPS_OFFSCREEN(pDrawable))
        return;

    DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);

    XFillArcs(dmxScreen->beDisplay, draw, pGCPriv->gc, (XArc *) parcs, narcs);
    dmxSync(dmxScreen, FALSE);
}

/** Render string of 8-bit \a chars (foreground only) in \a pDrawable on
 *  the back-end server associated with \a pDrawable's screen.  If the
 *  offscreen optimization is enabled, only draw when \a pDrawable is at
 *  least partially visible. */
int
dmxPolyText8(DrawablePtr pDrawable, GCPtr pGC,
             int x, int y, int count, char *chars)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pDrawable->pScreen->myNum];
    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(pGC);
    unsigned long n, i;
    int w;
    CharInfoPtr charinfo[255];
    Drawable draw;

    GetGlyphs(pGC->font, (unsigned long) count, (unsigned char *) chars,
              Linear8Bit, &n, charinfo);

    /* Calculate text width */
    w = 0;
    for (i = 0; i < n; i++)
        w += charinfo[i]->metrics.characterWidth;

    if (n != 0 && !DMX_GCOPS_OFFSCREEN(pDrawable)) {
        DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);

        XDrawString(dmxScreen->beDisplay, draw, pGCPriv->gc,
                    x, y, chars, count);
        dmxSync(dmxScreen, FALSE);
    }

    return x + w;
}

/** Render string of 16-bit \a chars (foreground only) in \a pDrawable
 *  on the back-end server associated with \a pDrawable's screen.  If
 *  the offscreen optimization is enabled, only draw when \a pDrawable
 *  is at least partially visible. */
int
dmxPolyText16(DrawablePtr pDrawable, GCPtr pGC,
              int x, int y, int count, unsigned short *chars)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pDrawable->pScreen->myNum];
    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(pGC);
    unsigned long n, i;
    int w;
    CharInfoPtr charinfo[255];
    Drawable draw;

    GetGlyphs(pGC->font, (unsigned long) count, (unsigned char *) chars,
              (FONTLASTROW(pGC->font) == 0) ? Linear16Bit : TwoD16Bit,
              &n, charinfo);

    /* Calculate text width */
    w = 0;
    for (i = 0; i < n; i++)
        w += charinfo[i]->metrics.characterWidth;

    if (n != 0 && !DMX_GCOPS_OFFSCREEN(pDrawable)) {
        DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);

        XDrawString16(dmxScreen->beDisplay, draw, pGCPriv->gc,
                      x, y, (XChar2b *) chars, count);
        dmxSync(dmxScreen, FALSE);
    }

    return x + w;
}

/** Render string of 8-bit \a chars (both foreground and background) in
 *  \a pDrawable on the back-end server associated with \a pDrawable's
 *  screen.  If the offscreen optimization is enabled, only draw when \a
 *  pDrawable is at least partially visible. */
void
dmxImageText8(DrawablePtr pDrawable, GCPtr pGC,
              int x, int y, int count, char *chars)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pDrawable->pScreen->myNum];
    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable draw;

    if (DMX_GCOPS_OFFSCREEN(pDrawable))
        return;

    DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);

    XDrawImageString(dmxScreen->beDisplay, draw, pGCPriv->gc,
                     x, y, chars, count);
    dmxSync(dmxScreen, FALSE);
}

/** Render string of 16-bit \a chars (both foreground and background) in
 *  \a pDrawable on the back-end server associated with \a pDrawable's
 *  screen.  If the offscreen optimization is enabled, only draw when \a
 *  pDrawable is at least partially visible. */
void
dmxImageText16(DrawablePtr pDrawable, GCPtr pGC,
               int x, int y, int count, unsigned short *chars)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pDrawable->pScreen->myNum];
    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable draw;

    if (DMX_GCOPS_OFFSCREEN(pDrawable))
        return;

    DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);

    XDrawImageString16(dmxScreen->beDisplay, draw, pGCPriv->gc,
                       x, y, (XChar2b *) chars, count);
    dmxSync(dmxScreen, FALSE);
}

/** Image Glyph Blt -- this function should never be called. */
void
dmxImageGlyphBlt(DrawablePtr pDrawable, GCPtr pGC,
                 int x, int y, unsigned int nglyph,
                 CharInfoPtr * ppci, void *pglyphBase)
{
    /* Error -- this should never happen! */
}

/** Poly Glyph Blt -- this function should never be called. */
void
dmxPolyGlyphBlt(DrawablePtr pDrawable, GCPtr pGC,
                int x, int y, unsigned int nglyph,
                CharInfoPtr * ppci, void *pglyphBase)
{
    /* Error -- this should never happen! */
}

/** Push Pixels -- this function should never be called. */
void
dmxPushPixels(GCPtr pGC, PixmapPtr pBitMap, DrawablePtr pDst,
              int w, int h, int x, int y)
{
    /* Error -- this should never happen! */
}

/**********************************************************************
 * Miscellaneous drawing commands
 */

/** When Xinerama is active, the client pixmaps are always obtained from
 * screen 0.  When screen 0 is detached, the pixmaps must be obtained
 * from any other screen that is not detached.  Usually, this is screen
 * 1. */
static DMXScreenInfo *
dmxFindAlternatePixmap(DrawablePtr pDrawable, XID *draw)
{
#ifdef PANORAMIX
    PanoramiXRes *pXinPix;
    int i;
    DMXScreenInfo *dmxScreen;

    if (noPanoramiXExtension)
        return NULL;
    if (pDrawable->type != DRAWABLE_PIXMAP)
        return NULL;

    if (Success != dixLookupResourceByType((void **) &pXinPix,
                                           pDrawable->id, XRT_PIXMAP,
                                           NullClient, DixUnknownAccess))
        return NULL;

    FOR_NSCREENS_FORWARD_SKIP(i) {
        dmxScreen = &dmxScreens[i];
        if (dmxScreen->beDisplay) {
            PixmapPtr pSrc;
            dmxPixPrivPtr pSrcPriv;

            dixLookupResourceByType((void **) &pSrc, pXinPix->info[i].id,
                                    RT_PIXMAP, NullClient, DixUnknownAccess);
            pSrcPriv = DMX_GET_PIXMAP_PRIV(pSrc);
            if (pSrcPriv->pixmap) {
                *draw = pSrcPriv->pixmap;
                return dmxScreen;
            }
        }
    }
#endif
    return NULL;
}

/** Get an image from the back-end server associated with \a pDrawable's
 *  screen.  If \a pDrawable is a window, it must be viewable to get an
 *  image from it.  If it is not viewable, then get the image from the
 *  first ancestor of \a pDrawable that is viewable.  If no viewable
 *  ancestor is found, then simply return without getting an image.  */
void
dmxGetImage(DrawablePtr pDrawable, int sx, int sy, int w, int h,
            unsigned int format, unsigned long planeMask, char *pdstLine)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pDrawable->pScreen->myNum];
    XImage *img;
    Drawable draw;

    /* Cannot get image from unviewable window */
    if (pDrawable->type == DRAWABLE_WINDOW) {
        WindowPtr pWindow = (WindowPtr) pDrawable;

        if (!pWindow->viewable) {
            while (!pWindow->viewable && pWindow->parent) {
                sx += pWindow->origin.x - wBorderWidth(pWindow);
                sx += pWindow->origin.y - wBorderWidth(pWindow);
                pWindow = pWindow->parent;
            }
            if (!pWindow->viewable) {
                return;
            }
        }
        DMX_GCOPS_SET_DRAWABLE(&pWindow->drawable, draw);
        if (DMX_GCOPS_OFFSCREEN(&pWindow->drawable))
            return;
    }
    else {
        DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);
        if (DMX_GCOPS_OFFSCREEN(pDrawable)) {
            /* Try to find the pixmap on a non-detached Xinerama screen */
            dmxScreen = dmxFindAlternatePixmap(pDrawable, &draw);
            if (!dmxScreen)
                return;
        }
    }

    img = XGetImage(dmxScreen->beDisplay, draw,
                    sx, sy, w, h, planeMask, format);
    if (img) {
        int len = img->bytes_per_line * img->height;

        memmove(pdstLine, img->data, len);
        XDestroyImage(img);
    }

    dmxSync(dmxScreen, FALSE);
}

/** Get Spans -- this function should never be called. */
void
dmxGetSpans(DrawablePtr pDrawable, int wMax,
            DDXPointPtr ppt, int *pwidth, int nspans, char *pdstStart)
{
    /* Error -- this should never happen! */
}
@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d182 1
a182 1
                                 dstx, dsty, 0L);
d191 1
a191 1
    return miHandleExposures(pSrc, pDst, pGC, srcx, srcy, w, h, dstx, dsty, 0L);
d209 1
a209 1
                                 dstx, dsty, bitPlane);
d219 1
a219 1
                             dstx, dsty, bitPlane);
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d511 1
a511 1
                 CharInfoPtr * ppci, pointer pglyphBase)
d520 1
a520 1
                CharInfoPtr * ppci, pointer pglyphBase)
d554 1
a554 1
    if (Success != dixLookupResourceByType((pointer *) &pXinPix,
d565 1
a565 1
            dixLookupResourceByType((pointer *) &pSrc, pXinPix->info[i].id,
@


1.4
log
@Update to xserver 1.11.2
@
text
@d78 3
a80 3
void dmxFillSpans(DrawablePtr pDrawable, GCPtr pGC,
		  int nInit, DDXPointPtr pptInit, int *pwidthInit,
		  int fSorted)
d86 3
a88 3
void dmxSetSpans(DrawablePtr pDrawable, GCPtr pGC,
		 char *psrc, DDXPointPtr ppt, int *pwidth, int nspans,
		 int fSorted)
d97 4
a100 3
void dmxPutImage(DrawablePtr pDrawable, GCPtr pGC,
		 int depth, int x, int y, int w, int h,
		 int leftPad, int format, char *pBits)
d103 2
a104 2
    dmxGCPrivPtr   pGCPriv = DMX_GET_GC_PRIV(pGC);
    XImage        *img;
d106 2
a107 1
    if (DMX_GCOPS_OFFSCREEN(pDrawable)) return;
d110 5
a114 5
		       dmxScreen->beVisuals[dmxScreen->beDefVisualIndex].visual,
		       depth, format, leftPad, pBits, w, h,
		       BitmapPad(dmxScreen->beDisplay),
		       (format == ZPixmap) ?
		       PixmapBytePad(w, depth) : BitmapBytePad(w+leftPad));
d117 1
a117 1
	Drawable draw;
d119 1
a119 1
	DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);
d121 29
a149 32
	if (dmxSubdividePrimitives && pGC->pCompositeClip) {
	    RegionPtr  pSubImages;
	    RegionPtr  pClip;
	    BoxRec     box;
	    BoxPtr     pBox;
	    int        nBox;

	    box.x1 = x;
	    box.y1 = y;
	    box.x2 = x + w;
	    box.y2 = y + h;
	    pSubImages = RegionCreate(&box, 1);

	    pClip = RegionCreate(NullBox, 1);
	    RegionCopy(pClip, pGC->pCompositeClip);
	    RegionTranslate(pClip,
			     -pDrawable->x, -pDrawable->y);
	    RegionIntersect(pSubImages, pSubImages, pClip);

	    nBox = RegionNumRects(pSubImages);
	    pBox = RegionRects(pSubImages);

	    while (nBox--) {
		XPutImage(dmxScreen->beDisplay, draw, pGCPriv->gc, img,
			  pBox->x1 - box.x1,
			  pBox->y1 - box.y1,
			  pBox->x1,
			  pBox->y1,
			  pBox->x2 - pBox->x1,
			  pBox->y2 - pBox->y1);
		pBox++;
	    }
d152 6
a157 5
	} else {
	    XPutImage(dmxScreen->beDisplay, draw, pGCPriv->gc,
		      img, 0, 0, x, y, w, h);
	}
	XFree(img);             /* Use XFree instead of XDestroyImage
d161 4
a164 3
	dmxSync(dmxScreen, FALSE);
    } else {
	/* Error -- this should not happen! */
d172 3
a174 2
RegionPtr dmxCopyArea(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
		      int srcx, int srcy, int w, int h, int dstx, int dsty)
d177 2
a178 2
    dmxGCPrivPtr   pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable       srcDraw, dstDraw;
d181 2
a182 2
	return miHandleExposures(pSrc, pDst, pGC, srcx, srcy, w, h,
				 dstx, dsty, 0L);
d188 1
a188 1
	      srcx, srcy, w, h, dstx, dsty);
d191 1
a191 2
    return miHandleExposures(pSrc, pDst, pGC, srcx, srcy, w, h,
			     dstx, dsty, 0L);
d198 4
a201 3
RegionPtr dmxCopyPlane(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
		       int srcx, int srcy, int width, int height,
		       int dstx, int dsty, unsigned long bitPlane)
d204 2
a205 2
    dmxGCPrivPtr   pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable       srcDraw, dstDraw;
d208 2
a209 2
	return miHandleExposures(pSrc, pDst, pGC, srcx, srcy, width, height,
				 dstx, dsty, bitPlane);
d215 1
a215 1
	       srcx, srcy, width, height, dstx, dsty, bitPlane);
d219 1
a219 1
			     dstx, dsty, bitPlane);
d226 3
a228 2
void dmxPolyPoint(DrawablePtr pDrawable, GCPtr pGC,
		  int mode, int npt, DDXPointPtr pptInit)
d231 2
a232 2
    dmxGCPrivPtr   pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable       draw;
d234 2
a235 1
    if (DMX_GCOPS_OFFSCREEN(pDrawable)) return;
d240 1
a240 1
		(XPoint *)pptInit, npt, mode);
d248 3
a250 2
void dmxPolylines(DrawablePtr pDrawable, GCPtr pGC,
		  int mode, int npt, DDXPointPtr pptInit)
d253 2
a254 2
    dmxGCPrivPtr   pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable       draw;
d256 2
a257 1
    if (DMX_GCOPS_OFFSCREEN(pDrawable)) return;
d262 1
a262 1
	       (XPoint *)pptInit, npt, mode);
d270 2
a271 2
void dmxPolySegment(DrawablePtr pDrawable, GCPtr pGC,
		    int nseg, xSegment *pSegs)
d274 2
a275 2
    dmxGCPrivPtr   pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable       draw;
d277 2
a278 1
    if (DMX_GCOPS_OFFSCREEN(pDrawable)) return;
d283 1
a283 1
		  (XSegment *)pSegs, nseg);
d291 3
a293 2
void dmxPolyRectangle(DrawablePtr pDrawable, GCPtr pGC,
		      int nrects, xRectangle *pRects)
d296 2
a297 2
    dmxGCPrivPtr   pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable       draw;
d299 2
a300 1
    if (DMX_GCOPS_OFFSCREEN(pDrawable)) return;
d305 1
a305 1
		    (XRectangle *)pRects, nrects);
d314 2
a315 2
void dmxPolyArc(DrawablePtr pDrawable, GCPtr pGC,
		int narcs, xArc *parcs)
d318 2
a319 2
    dmxGCPrivPtr   pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable       draw;
d321 2
a322 1
    if (DMX_GCOPS_OFFSCREEN(pDrawable)) return;
d326 1
a326 2
    XDrawArcs(dmxScreen->beDisplay, draw, pGCPriv->gc,
	      (XArc *)parcs, narcs);
d334 3
a336 2
void dmxFillPolygon(DrawablePtr pDrawable, GCPtr pGC,
		    int shape, int mode, int count, DDXPointPtr pPts)
d339 2
a340 2
    dmxGCPrivPtr   pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable       draw;
d342 2
a343 1
    if (DMX_GCOPS_OFFSCREEN(pDrawable)) return;
d348 1
a348 1
		 (XPoint *)pPts, count, shape, mode);
d356 3
a358 2
void dmxPolyFillRect(DrawablePtr pDrawable, GCPtr pGC,
		     int nrectFill, xRectangle *prectInit)
d361 2
a362 2
    dmxGCPrivPtr   pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable       draw;
d364 2
a365 1
    if (DMX_GCOPS_OFFSCREEN(pDrawable)) return;
d370 1
a370 1
		    (XRectangle *)prectInit, nrectFill);
d378 2
a379 2
void dmxPolyFillArc(DrawablePtr pDrawable, GCPtr pGC,
		    int narcs, xArc *parcs)
d382 2
a383 2
    dmxGCPrivPtr   pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable       draw;
d385 2
a386 1
    if (DMX_GCOPS_OFFSCREEN(pDrawable)) return;
d390 1
a390 2
    XFillArcs(dmxScreen->beDisplay, draw, pGCPriv->gc,
	      (XArc *)parcs, narcs);
d398 3
a400 2
int dmxPolyText8(DrawablePtr pDrawable, GCPtr pGC,
		 int x, int y, int count, char *chars)
d403 5
a407 5
    dmxGCPrivPtr   pGCPriv = DMX_GET_GC_PRIV(pGC);
    unsigned long  n, i;
    int            w;
    CharInfoPtr    charinfo[255];
    Drawable       draw;
d409 2
a410 2
    GetGlyphs(pGC->font, (unsigned long)count, (unsigned char *)chars,
	      Linear8Bit, &n, charinfo);
d414 2
a415 1
    for (i = 0; i < n; i++) w += charinfo[i]->metrics.characterWidth;
d418 1
a418 1
	DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);
d420 3
a422 3
	XDrawString(dmxScreen->beDisplay, draw, pGCPriv->gc,
		    x, y, chars, count);
	dmxSync(dmxScreen, FALSE);
d425 1
a425 1
    return x+w;
d432 3
a434 2
int dmxPolyText16(DrawablePtr pDrawable, GCPtr pGC,
		  int x, int y, int count, unsigned short *chars)
d437 9
a445 9
    dmxGCPrivPtr   pGCPriv = DMX_GET_GC_PRIV(pGC);
    unsigned long  n, i;
    int            w;
    CharInfoPtr    charinfo[255];
    Drawable       draw;

    GetGlyphs(pGC->font, (unsigned long)count, (unsigned char *)chars,
	      (FONTLASTROW(pGC->font) == 0) ? Linear16Bit : TwoD16Bit,
	      &n, charinfo);
d449 2
a450 1
    for (i = 0; i < n; i++) w += charinfo[i]->metrics.characterWidth;
d453 1
a453 1
	DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);
d455 3
a457 3
	XDrawString16(dmxScreen->beDisplay, draw, pGCPriv->gc,
		      x, y, (XChar2b *)chars, count);
	dmxSync(dmxScreen, FALSE);
d460 1
a460 1
    return x+w;
d467 3
a469 2
void dmxImageText8(DrawablePtr pDrawable, GCPtr pGC,
		   int x, int y, int count, char *chars)
d472 2
a473 2
    dmxGCPrivPtr   pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable       draw;
d475 2
a476 1
    if (DMX_GCOPS_OFFSCREEN(pDrawable)) return;
d481 1
a481 1
		     x, y, chars, count);
d489 3
a491 2
void dmxImageText16(DrawablePtr pDrawable, GCPtr pGC,
		    int x, int y, int count, unsigned short *chars)
d494 2
a495 2
    dmxGCPrivPtr   pGCPriv = DMX_GET_GC_PRIV(pGC);
    Drawable       draw;
d497 2
a498 1
    if (DMX_GCOPS_OFFSCREEN(pDrawable)) return;
d503 1
a503 1
		       x, y, (XChar2b *)chars, count);
d508 4
a511 3
void dmxImageGlyphBlt(DrawablePtr pDrawable, GCPtr pGC,
		      int x, int y, unsigned int nglyph,
		      CharInfoPtr *ppci, pointer pglyphBase)
d517 4
a520 3
void dmxPolyGlyphBlt(DrawablePtr pDrawable, GCPtr pGC,
		     int x, int y, unsigned int nglyph,
		     CharInfoPtr *ppci, pointer pglyphBase)
d526 3
a528 2
void dmxPushPixels(GCPtr pGC, PixmapPtr pBitMap, DrawablePtr pDst,
		   int w, int h, int x, int y)
d541 2
a542 1
static DMXScreenInfo *dmxFindAlternatePixmap(DrawablePtr pDrawable, XID *draw)
d545 2
a546 2
    PanoramiXRes  *pXinPix;
    int           i;
d548 9
a556 7
            
    if (noPanoramiXExtension)               return NULL;
    if (pDrawable->type != DRAWABLE_PIXMAP) return NULL;

    if (Success != dixLookupResourceByType((pointer*) &pXinPix,
					   pDrawable->id, XRT_PIXMAP,
					   NullClient, DixUnknownAccess))
d562 1
a562 1
            PixmapPtr     pSrc;
d564 3
a566 3
            
            dixLookupResourceByType((pointer*) &pSrc, pXinPix->info[i].id,
				    RT_PIXMAP, NullClient, DixUnknownAccess);
d583 3
a585 2
void dmxGetImage(DrawablePtr pDrawable, int sx, int sy, int w, int h,
		 unsigned int format, unsigned long planeMask, char *pdstLine)
d588 2
a589 2
    XImage        *img;
    Drawable       draw;
d593 19
a611 17
	WindowPtr pWindow = (WindowPtr)pDrawable;
	if (!pWindow->viewable) {
	    while (!pWindow->viewable && pWindow->parent) {
		sx += pWindow->origin.x - wBorderWidth(pWindow);
		sx += pWindow->origin.y - wBorderWidth(pWindow);
		pWindow = pWindow->parent;
	    }
	    if (!pWindow->viewable) {
		return;
	    }
	}
	DMX_GCOPS_SET_DRAWABLE(&pWindow->drawable, draw);
	if (DMX_GCOPS_OFFSCREEN(&pWindow->drawable))
	    return;
    } else {
	DMX_GCOPS_SET_DRAWABLE(pDrawable, draw);
	if (DMX_GCOPS_OFFSCREEN(pDrawable)) {
d614 2
a615 1
            if (!dmxScreen) return;
d620 1
a620 1
		    sx, sy, w, h, planeMask, format);
d622 4
a625 3
	int len = img->bytes_per_line * img->height;
	memmove(pdstLine, img->data, len);
	XDestroyImage(img);
d632 3
a634 3
void dmxGetSpans(DrawablePtr pDrawable, int wMax,
		 DDXPointPtr ppt, int *pwidth, int nspans,
		 char *pdstStart)
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d526 4
a529 2
    
    if (!(pXinPix = (PanoramiXRes *)LookupIDByType(pDrawable->id, XRT_PIXMAP)))
d532 1
a532 1
    for (i = 1; i < PanoramiXNumScreens; i++) {
d538 2
a539 2
            pSrc = (PixmapPtr)LookupIDByType(pXinPix->info[i].id,
                                             RT_PIXMAP);
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d130 1
a130 1
	    pSubImages = REGION_CREATE(pGC->pScreen, &box, 1);
d132 3
a134 3
	    pClip = REGION_CREATE(pGC->pScreen, NullBox, 1);
	    REGION_COPY(pGC->pScreen, pClip, pGC->pCompositeClip);
	    REGION_TRANSLATE(pGC->pScreen, pClip,
d136 1
a136 1
	    REGION_INTERSECT(pGC->pScreen, pSubImages, pSubImages, pClip);
d138 2
a139 2
	    nBox = REGION_NUM_RECTS(pSubImages);
	    pBox = REGION_RECTS(pSubImages);
d151 2
a152 2
            REGION_DESTROY(pGC->pScreen, pClip);
            REGION_DESTROY(pGC->pScreen, pSubImages);
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
d53 1
d55 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
@

