head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	Te1daavkBLskZ8gc;

1.5
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	cVXoV5PxI8YrEaVA;

1.4
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.05;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.23.32;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.23.32;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.33;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/* Portions of this file were derived from the following files:
 *
 **********************************************************************
 *
 * Xserver/hw/kdrive/linux/ms.c
 *
 * Copyright (c) 2001 by Juliusz Chroboczek
 * Copyright (c) 1999 by Keith Packard
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

/*
 * Copyright 2001-2003 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Rickard E. (Rik) Faith <faith@@redhat.com>
 *
 */

/** \file
 *
 * This code implements a low-level device driver for a serial MS mouse.
 * The code is derived from code by Juliusz Chroboczek and Keith Packard
 * (see the source code for complete references). */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include "inputstr.h"
#include <X11/Xos.h>
#include <errno.h>
#include <termios.h>

/*****************************************************************************/
/* Define some macros to make it easier to move this file to another
 * part of the Xserver tree.  All calls to the dmx* layer are #defined
 * here for the .c file.  The .h file will also have to be edited. */
#include "dmxinputinit.h"
#include "lnx-ms.h"

#define GETPRIV       myPrivate *priv                            \
                      = ((DMXLocalInputInfoPtr)(pDev->devicePrivate))->private

#define LOG0(f)       dmxLog(dmxDebug,f)
#define LOG1(f,a)     dmxLog(dmxDebug,f,a)
#define LOG2(f,a,b)   dmxLog(dmxDebug,f,a,b)
#define LOG3(f,a,b,c) dmxLog(dmxDebug,f,a,b,c)
#define FATAL0(f)     dmxLog(dmxFatal,f)
#define FATAL1(f,a)   dmxLog(dmxFatal,f,a)
#define FATAL2(f,a,b) dmxLog(dmxFatal,f,a,b)
#define MOTIONPROC    dmxMotionProcPtr
#define ENQUEUEPROC   dmxEnqueueProcPtr
#define CHECKPROC     dmxCheckSpecialProcPtr
#define BLOCK         DMXBlockType

/* End of interface definitions. */
/*****************************************************************************/

/* Private area for MS mouse devices. */
typedef struct _myPrivate {
    DeviceIntPtr pMouse;
    int fd;
    struct termios tty;
    enum {
        button1 = 0x0001,
        button2 = 0x0002,
        button3 = 0x0004,
        button4 = 0x0008,
        button5 = 0x0010
    } buttons;
} myPrivate;

static int
msLinuxReadBytes(int fd, unsigned char *buf, int len, int min)
{
    int n, tot;
    fd_set set;
    struct timeval tv;

    tot = 0;
    while (len) {
        n = read(fd, buf, len);
        if (n > 0) {
            tot += n;
            buf += n;
            len -= n;
        }
        if (tot % min == 0)
            break;
        FD_ZERO(&set);
        FD_SET(fd, &set);
        tv.tv_sec = 0;
        tv.tv_usec = 100 * 1000;
        n = select(fd + 1, &set, 0, 0, &tv);
        if (n <= 0)
            break;
    }
    return tot;
}

static void
msLinuxButton(DevicePtr pDev, ENQUEUEPROC enqueue, int buttons, BLOCK block)
{
    GETPRIV;

#define PRESS(b)                                         \
    do {                                                 \
        enqueue(pDev, ButtonPress, 0, 0, NULL, block);   \
    } while (0)

#define RELEASE(b)                                       \
    do {                                                 \
        enqueue(pDev, ButtonRelease, 0, 0, NULL, block); \
    } while (0)

    if ((buttons & button1) && !(priv->buttons & button1))
        PRESS(1);
    if (!(buttons & button1) && (priv->buttons & button1))
        RELEASE(1);

    if ((buttons & button2) && !(priv->buttons & button2))
        PRESS(2);
    if (!(buttons & button2) && (priv->buttons & button2))
        RELEASE(2);

    if ((buttons & button3) && !(priv->buttons & button3))
        PRESS(3);
    if (!(buttons & button3) && (priv->buttons & button3))
        RELEASE(3);

    if ((buttons & button4) && !(priv->buttons & button4))
        PRESS(4);
    if (!(buttons & button4) && (priv->buttons & button4))
        RELEASE(4);

    if ((buttons & button5) && !(priv->buttons & button5))
        PRESS(5);
    if (!(buttons & button5) && (priv->buttons & button5))
        RELEASE(5);

    priv->buttons = buttons;
}

/** Read an event from the \a pDev device.  If the event is a motion
 * event, enqueue it with the \a motion function.  Otherwise, check for
 * special keys with the \a checkspecial function and enqueue the event
 * with the \a enqueue function.  The \a block type is passed to the
 * functions so that they may block SIGIO handling as appropriate to the
 * caller of this function. */
void
msLinuxRead(DevicePtr pDev,
            MOTIONPROC motion,
            ENQUEUEPROC enqueue, CHECKPROC checkspecial, BLOCK block)
{
    GETPRIV;
    unsigned char buf[3 * 200]; /* RATS: Use ok */
    unsigned char *b;
    int n;
    int dx, dy, v[2];

    while ((n = msLinuxReadBytes(priv->fd, buf, sizeof(buf), 3)) > 0) {
        b = buf;
        while (n >= 3) {
            dx = (char) (((b[0] & 0x03) << 6) | (b[1] & 0x3f));
            dy = (char) (((b[0] & 0x0c) << 4) | (b[2] & 0x3f));
            v[0] = -dx;
            v[1] = -dy;

            motion(pDev, v, 0, 2, 1, block);
            msLinuxButton(pDev, enqueue, (((b[0] & 0x10) ? button3 : 0)
                                          | ((b[0] & 0x20) ? button1 : 0)),
                          block);
            n -= 3;
            b += 3;
        }
    }
}

/** Initialize \a pDev. */
void
msLinuxInit(DevicePtr pDev)
{
    GETPRIV;
    const char *names[] = { "/dev/serialmouse", "/dev/mouse", NULL };
    int i;

    if (priv->fd >= 0)
        return;

    for (i = 0; names[i]; i++) {
        if ((priv->fd = open(names[i], O_RDWR | O_NONBLOCK, 0)) >= 0)
            break;
    }
    if (priv->fd < 0)
        FATAL1("msLinuxInit: Cannot open mouse port (%s)\n", strerror(errno));

    if (!isatty(priv->fd))
        FATAL1("msLinuxInit: Mouse port %s is not a tty\n", names[i]);

    if (tcgetattr(priv->fd, &priv->tty) < 0)
        FATAL1("msLinuxInit: tcgetattr failed (%s)\n", strerror(errno));

    write(priv->fd, "*n", 2);   /* 1200 baud */
    usleep(100000);
}

/** Turn \a pDev on (i.e., take input from \a pDev). */
int
msLinuxOn(DevicePtr pDev)
{
    GETPRIV;
    struct termios nTty;

    if (priv->fd < 0)
        msLinuxInit(pDev);

    nTty = priv->tty;
    nTty.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR
                      | IGNCR | ICRNL | IXON | IXOFF);
    nTty.c_oflag &= ~OPOST;
    nTty.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
    nTty.c_cflag &= ~(CSIZE | PARENB);
    nTty.c_cflag |= CS8 | CLOCAL | CSTOPB;
    nTty.c_cc[VTIME] = 0;
    nTty.c_cc[VMIN] = 1;
    cfsetispeed(&nTty, B1200);
    cfsetospeed(&nTty, B1200);
    if (tcsetattr(priv->fd, TCSANOW, &nTty) < 0)
        FATAL1("msLinuxInit: tcsetattr failed (%s)\n", strerror(errno));
    write(priv->fd, "*V", 2);   /* 2 button 3 byte protocol */
    return priv->fd;
}

/** Turn \a pDev off (i.e., stop taking input from \a pDev). */
void
msLinuxOff(DevicePtr pDev)
{
    GETPRIV;

    tcsetattr(priv->fd, TCSANOW, &priv->tty);
    close(priv->fd);
    priv->fd = -1;
}

static void
msLinuxGetMap(DevicePtr pDev, unsigned char *map, int *nButtons)
{
    int i;

    if (nButtons)
        *nButtons = 3;
    if (map)
        for (i = 0; i <= *nButtons; i++)
            map[i] = i;
}

/** Currently unused hook called prior to an VT switch. */
void
msLinuxVTPreSwitch(void *p)
{
}

/** Currently unused hook called after returning from a VT switch. */
void
msLinuxVTPostSwitch(void *p)
{
}

/** Create a private structure for use within this file. */
void *
msLinuxCreatePrivate(DeviceIntPtr pMouse)
{
    myPrivate *priv = calloc(1, sizeof(*priv));

    priv->fd = -1;
    priv->pMouse = pMouse;
    return priv;
}

/** Destroy a private structure. */
void
msLinuxDestroyPrivate(void *priv)
{
    free(priv);
}

/** Fill the \a info structure with information needed to initialize \a
 * pDev. */
void
msLinuxGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info)
{
    info->buttonClass = 1;
    msLinuxGetMap(pDev, info->map, &info->numButtons);
    info->valuatorClass = 1;
    info->numRelAxes = 2;
    info->minval[0] = 0;
    info->maxval[0] = 0;
    info->res[0] = 1;
    info->minres[0] = 0;
    info->maxres[0] = 1;
    info->ptrFeedbackClass = 1;
}
@


1.5
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d20 1
a20 1
 * 
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d305 1
a305 1
msLinuxVTPreSwitch(pointer p)
d311 1
a311 1
msLinuxVTPostSwitch(pointer p)
d316 1
a316 1
pointer
d328 1
a328 1
msLinuxDestroyPrivate(pointer priv)
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d107 2
a108 2
    DeviceIntPtr   pMouse;
    int            fd;
d116 1
a116 1
    }              buttons;
d119 2
a120 1
static int msLinuxReadBytes(int fd, unsigned char *buf, int len, int min)
d122 4
a125 4
    int		    n, tot;
    fd_set	    set;
    struct timeval  tv;
    
d131 12
a142 10
	    buf += n;
	    len -= n;
	}
	if (tot % min == 0) break;
	FD_ZERO(&set);
	FD_SET(fd, &set);
	tv.tv_sec = 0;
	tv.tv_usec = 100 * 1000;
	n = select(fd + 1, &set, 0, 0, &tv);
	if (n <= 0) break;
d147 2
a148 2
static void msLinuxButton(DevicePtr pDev, ENQUEUEPROC enqueue, int buttons,
                          BLOCK block)
d161 25
a185 15
          
    if ((buttons & button1) && !(priv->buttons & button1)) PRESS(1);
    if (!(buttons & button1) && (priv->buttons & button1)) RELEASE(1);

    if ((buttons & button2) && !(priv->buttons & button2)) PRESS(2);
    if (!(buttons & button2) && (priv->buttons & button2)) RELEASE(2);

    if ((buttons & button3) && !(priv->buttons & button3)) PRESS(3);
    if (!(buttons & button3) && (priv->buttons & button3)) RELEASE(3);

    if ((buttons & button4) && !(priv->buttons & button4)) PRESS(4);
    if (!(buttons & button4) && (priv->buttons & button4)) RELEASE(4);
    
    if ((buttons & button5) && !(priv->buttons & button5)) PRESS(5);
    if (!(buttons & button5) && (priv->buttons & button5)) RELEASE(5);
d196 4
a199 5
void msLinuxRead(DevicePtr pDev,
                 MOTIONPROC motion,
                 ENQUEUEPROC enqueue,
                 CHECKPROC checkspecial,
                 BLOCK block)
d202 4
a205 4
    unsigned char   buf[3 * 200]; /* RATS: Use ok */
    unsigned char   *b;
    int		    n;
    int		    dx, dy, v[2];
d208 4
a211 4
	b = buf;
	while (n >= 3) {
	    dx   = (char)(((b[0] & 0x03) << 6) | (b[1] & 0x3f));
	    dy   = (char)(((b[0] & 0x0c) << 4) | (b[2] & 0x3f));
d214 1
a214 1
            
d221 1
a221 1
	}
d226 2
a227 1
void msLinuxInit(DevicePtr pDev)
d231 1
a231 1
    int        i;
d233 2
a234 1
    if (priv->fd >=0) return;
d237 2
a238 1
        if ((priv->fd = open(names[i], O_RDWR | O_NONBLOCK, 0)) >= 0) break;
d241 2
a242 3
        FATAL1("msLinuxInit: Cannot open mouse port (%s)\n",
               strerror(errno));
    
d254 2
a255 1
int msLinuxOn(DevicePtr pDev)
d260 10
a269 9
    if (priv->fd < 0) msLinuxInit(pDev);
    
    nTty             = priv->tty;
    nTty.c_iflag    &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR
                         | IGNCR | ICRNL | IXON | IXOFF);
    nTty.c_oflag    &= ~OPOST;
    nTty.c_lflag    &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
    nTty.c_cflag    &= ~(CSIZE | PARENB);
    nTty.c_cflag    |= CS8 | CLOCAL | CSTOPB;
d271 3
a273 3
    nTty.c_cc[VMIN]  = 1;
    cfsetispeed (&nTty, B1200);
    cfsetospeed (&nTty, B1200);
d281 2
a282 1
void msLinuxOff(DevicePtr pDev)
d291 2
a292 1
static void msLinuxGetMap(DevicePtr pDev, unsigned char *map, int *nButtons)
d295 6
a300 3
    
    if (nButtons) *nButtons = 3;
    if (map) for (i = 0; i <= *nButtons; i++) map[i] = i;
d304 2
a305 1
void msLinuxVTPreSwitch(pointer p)
d310 2
a311 1
void msLinuxVTPostSwitch(pointer p)
d316 2
a317 1
pointer msLinuxCreatePrivate(DeviceIntPtr pMouse)
d320 2
a321 1
    priv->fd     = -1;
d327 2
a328 1
void msLinuxDestroyPrivate(pointer priv)
d334 3
a336 2
 * pDev. */ 
void msLinuxGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info)
d338 1
a338 1
    info->buttonClass      = 1;
d340 7
a346 7
    info->valuatorClass    = 1;
    info->numRelAxes       = 2;
    info->minval[0]        = 0;
    info->maxval[0]        = 0;
    info->res[0]           = 1;
    info->minres[0]        = 0;
    info->maxres[0]        = 1;
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d304 1
a304 1
    if (priv) free(priv);
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
d295 1
a295 2
    myPrivate *priv = xalloc(sizeof(*priv));
    memset(priv, 0, sizeof(*priv));
d304 1
a304 1
    if (priv) xfree(priv);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
@

