head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.10
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	7pAEtF6Y5EgemkuY;

1.7
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.05;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.23.37;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.23.37;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 2002-2003 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Rickard E. (Rik) Faith <faith@@redhat.com>
 *
 */

/** \file
 * This file provides generic input support.  Functions here set up
 * input and lead to the calling of low-level device drivers for
 * input. */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#define DMX_WINDOW_DEBUG 0

#include "dmxinputinit.h"
#include "dmxextension.h"       /* For dmxInputCount */

#include "dmxdummy.h"
#include "dmxbackend.h"
#include "dmxconsole.h"
#include "dmxcommon.h"
#include "dmxevents.h"
#include "dmxmotion.h"
#include "dmxprop.h"
#include "config/dmxconfig.h"
#include "dmxcursor.h"

#include "lnx-keyboard.h"
#include "lnx-ms.h"
#include "lnx-ps2.h"
#include "usb-keyboard.h"
#include "usb-mouse.h"
#include "usb-other.h"
#include "usb-common.h"

#include "dmxsigio.h"
#include "dmxarg.h"

#include "inputstr.h"
#include "input.h"
#include "mipointer.h"
#include "windowstr.h"
#include "mi.h"
#include "xkbsrv.h"

#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "extinit.h"

DMXLocalInputInfoPtr dmxLocalCorePointer, dmxLocalCoreKeyboard;

static DMXLocalInputInfoRec DMXDummyMou = {
    "dummy-mou", DMX_LOCAL_MOUSE, DMX_LOCAL_TYPE_LOCAL, 1,
    NULL, NULL, NULL, NULL, NULL, dmxDummyMouGetInfo
};

static DMXLocalInputInfoRec DMXDummyKbd = {
    "dummy-kbd", DMX_LOCAL_KEYBOARD, DMX_LOCAL_TYPE_LOCAL, 1,
    NULL, NULL, NULL, NULL, NULL, dmxDummyKbdGetInfo
};

static DMXLocalInputInfoRec DMXBackendMou = {
    "backend-mou", DMX_LOCAL_MOUSE, DMX_LOCAL_TYPE_BACKEND, 2,
    dmxBackendCreatePrivate, dmxBackendDestroyPrivate,
    dmxBackendInit, NULL, dmxBackendLateReInit, dmxBackendMouGetInfo,
    dmxCommonMouOn, dmxCommonMouOff, dmxBackendUpdatePosition,
    NULL, NULL, NULL,
    dmxBackendCollectEvents, dmxBackendProcessInput, dmxBackendFunctions, NULL,
    dmxCommonMouCtrl
};

static DMXLocalInputInfoRec DMXBackendKbd = {
    "backend-kbd", DMX_LOCAL_KEYBOARD, DMX_LOCAL_TYPE_BACKEND,
    1,                          /* With backend-mou or console-mou */
    dmxCommonCopyPrivate, NULL,
    dmxBackendInit, NULL, NULL, dmxBackendKbdGetInfo,
    dmxCommonKbdOn, dmxCommonKbdOff, NULL,
    NULL, NULL, NULL,
    NULL, NULL, NULL, NULL,
    NULL, dmxCommonKbdCtrl, dmxCommonKbdBell
};

static DMXLocalInputInfoRec DMXConsoleMou = {
    "console-mou", DMX_LOCAL_MOUSE, DMX_LOCAL_TYPE_CONSOLE, 2,
    dmxConsoleCreatePrivate, dmxConsoleDestroyPrivate,
    dmxConsoleInit, dmxConsoleReInit, NULL, dmxConsoleMouGetInfo,
    dmxCommonMouOn, dmxCommonMouOff, dmxConsoleUpdatePosition,
    NULL, NULL, NULL,
    dmxConsoleCollectEvents, NULL, dmxConsoleFunctions, dmxConsoleUpdateInfo,
    dmxCommonMouCtrl
};

static DMXLocalInputInfoRec DMXConsoleKbd = {
    "console-kbd", DMX_LOCAL_KEYBOARD, DMX_LOCAL_TYPE_CONSOLE,
    1,                          /* With backend-mou or console-mou */
    dmxCommonCopyPrivate, NULL,
    dmxConsoleInit, dmxConsoleReInit, NULL, dmxConsoleKbdGetInfo,
    dmxCommonKbdOn, dmxCommonKbdOff, NULL,
    NULL, NULL, NULL,
    NULL, NULL, NULL, NULL,
    NULL, dmxCommonKbdCtrl, dmxCommonKbdBell
};

static DMXLocalInputInfoRec DMXLocalDevices[] = {
    /* Dummy drivers that can compile on any OS */
#ifdef __linux__
    /* Linux-specific drivers */
    {
     "kbd", DMX_LOCAL_KEYBOARD, DMX_LOCAL_TYPE_LOCAL, 1,
     kbdLinuxCreatePrivate, kbdLinuxDestroyPrivate,
     kbdLinuxInit, NULL, NULL, kbdLinuxGetInfo,
     kbdLinuxOn, kbdLinuxOff, NULL,
     kbdLinuxVTPreSwitch, kbdLinuxVTPostSwitch, kbdLinuxVTSwitch,
     kbdLinuxRead, NULL, NULL, NULL,
     NULL, kbdLinuxCtrl, kbdLinuxBell},
    {
     "ms", DMX_LOCAL_MOUSE, DMX_LOCAL_TYPE_LOCAL, 1,
     msLinuxCreatePrivate, msLinuxDestroyPrivate,
     msLinuxInit, NULL, NULL, msLinuxGetInfo,
     msLinuxOn, msLinuxOff, NULL,
     msLinuxVTPreSwitch, msLinuxVTPostSwitch, NULL,
     msLinuxRead},
    {
     "ps2", DMX_LOCAL_MOUSE, DMX_LOCAL_TYPE_LOCAL, 1,
     ps2LinuxCreatePrivate, ps2LinuxDestroyPrivate,
     ps2LinuxInit, NULL, NULL, ps2LinuxGetInfo,
     ps2LinuxOn, ps2LinuxOff, NULL,
     ps2LinuxVTPreSwitch, ps2LinuxVTPostSwitch, NULL,
     ps2LinuxRead},
#endif
#ifdef __linux__
    /* USB drivers, currently only for
       Linux, but relatively easy to port to
       other OSs */
    {
     "usb-kbd", DMX_LOCAL_KEYBOARD, DMX_LOCAL_TYPE_LOCAL, 1,
     usbCreatePrivate, usbDestroyPrivate,
     kbdUSBInit, NULL, NULL, kbdUSBGetInfo,
     kbdUSBOn, usbOff, NULL,
     NULL, NULL, NULL,
     kbdUSBRead, NULL, NULL, NULL,
     NULL, kbdUSBCtrl},
    {
     "usb-mou", DMX_LOCAL_MOUSE, DMX_LOCAL_TYPE_LOCAL, 1,
     usbCreatePrivate, usbDestroyPrivate,
     mouUSBInit, NULL, NULL, mouUSBGetInfo,
     mouUSBOn, usbOff, NULL,
     NULL, NULL, NULL,
     mouUSBRead},
    {
     "usb-oth", DMX_LOCAL_OTHER, DMX_LOCAL_TYPE_LOCAL, 1,
     usbCreatePrivate, usbDestroyPrivate,
     othUSBInit, NULL, NULL, othUSBGetInfo,
     othUSBOn, usbOff, NULL,
     NULL, NULL, NULL,
     othUSBRead},
#endif
    {
     "dummy-mou", DMX_LOCAL_MOUSE, DMX_LOCAL_TYPE_LOCAL, 1,
     NULL, NULL, NULL, NULL, NULL, dmxDummyMouGetInfo},
    {
     "dummy-kbd", DMX_LOCAL_KEYBOARD, DMX_LOCAL_TYPE_LOCAL, 1,
     NULL, NULL, NULL, NULL, NULL, dmxDummyKbdGetInfo},
    {NULL}                      /* Must be last */
};

#if 11 /*BP*/
    void
DDXRingBell(int volume, int pitch, int duration)
{
    /* NO-OP */
}

/* taken from kdrive/src/kinput.c: */
static void
dmxKbdCtrl(DeviceIntPtr pDevice, KeybdCtrl * ctrl)
{
#if 0
    KdKeyboardInfo *ki;

    for (ki = kdKeyboards; ki; ki = ki->next) {
        if (ki->dixdev && ki->dixdev->id == pDevice->id)
            break;
    }

    if (!ki || !ki->dixdev || ki->dixdev->id != pDevice->id || !ki->driver)
        return;

    KdSetLeds(ki, ctrl->leds);
    ki->bellPitch = ctrl->bell_pitch;
    ki->bellDuration = ctrl->bell_duration;
#endif
}

/* taken from kdrive/src/kinput.c: */
static void
dmxBell(int volume, DeviceIntPtr pDev, void *arg, int something)
{
#if 0
    KeybdCtrl *ctrl = arg;
    KdKeyboardInfo *ki = NULL;

    for (ki = kdKeyboards; ki; ki = ki->next) {
        if (ki->dixdev && ki->dixdev->id == pDev->id)
            break;
    }

    if (!ki || !ki->dixdev || ki->dixdev->id != pDev->id || !ki->driver)
        return;

    KdRingBell(ki, volume, ctrl->bell_pitch, ctrl->bell_duration);
#endif
}

#endif /*BP*/
    static void
_dmxChangePointerControl(DMXLocalInputInfoPtr dmxLocal, PtrCtrl * ctrl)
{
    if (!dmxLocal)
        return;
    dmxLocal->mctrl = *ctrl;
    if (dmxLocal->mCtrl)
        dmxLocal->mCtrl(&dmxLocal->pDevice->public, ctrl);
}

/** Change the pointer control information for the \a pDevice.  If the
 * device sends core events, then also change the control information
 * for all of the pointer devices that send core events. */
void
dmxChangePointerControl(DeviceIntPtr pDevice, PtrCtrl * ctrl)
{
    GETDMXLOCALFROMPDEVICE;
    int i, j;

    if (dmxLocal->sendsCore) {  /* Do for all core devices */
        for (i = 0; i < dmxNumInputs; i++) {
            DMXInputInfo *dmxInput = &dmxInputs[i];

            if (dmxInput->detached)
                continue;
            for (j = 0; j < dmxInput->numDevs; j++)
                if (dmxInput->devs[j]->sendsCore)
                    _dmxChangePointerControl(dmxInput->devs[j], ctrl);
        }
    }
    else {                      /* Do for this device only */
        _dmxChangePointerControl(dmxLocal, ctrl);
    }
}

static void
_dmxKeyboardKbdCtrlProc(DMXLocalInputInfoPtr dmxLocal, KeybdCtrl * ctrl)
{
    dmxLocal->kctrl = *ctrl;
    if (dmxLocal->kCtrl) {
        dmxLocal->kCtrl(&dmxLocal->pDevice->public, ctrl);
        if (dmxLocal->pDevice->kbdfeed) {
            XkbEventCauseRec cause;

            XkbSetCauseUnknown(&cause);
            /* Generate XKB events, as necessary */
            XkbUpdateIndicators(dmxLocal->pDevice, XkbAllIndicatorsMask, False,
                                NULL, &cause);
        }
    }
}

/** Change the keyboard control information for the \a pDevice.  If the
 * device sends core events, then also change the control information
 * for all of the keyboard devices that send core events. */
void
dmxKeyboardKbdCtrlProc(DeviceIntPtr pDevice, KeybdCtrl * ctrl)
{
    GETDMXLOCALFROMPDEVICE;
    int i, j;

    if (dmxLocal->sendsCore) {  /* Do for all core devices */
        for (i = 0; i < dmxNumInputs; i++) {
            DMXInputInfo *dmxInput = &dmxInputs[i];

            if (dmxInput->detached)
                continue;
            for (j = 0; j < dmxInput->numDevs; j++)
                if (dmxInput->devs[j]->sendsCore)
                    _dmxKeyboardKbdCtrlProc(dmxInput->devs[j], ctrl);
        }
    }
    else {                      /* Do for this device only */
        _dmxKeyboardKbdCtrlProc(dmxLocal, ctrl);
    }
}

static void
_dmxKeyboardBellProc(DMXLocalInputInfoPtr dmxLocal, int percent)
{
    if (dmxLocal->kBell)
        dmxLocal->kBell(&dmxLocal->pDevice->public,
                        percent,
                        dmxLocal->kctrl.bell,
                        dmxLocal->kctrl.bell_pitch,
                        dmxLocal->kctrl.bell_duration);
}

/** Sound the bell on the device.  If the device send core events, then
 * sound the bell on all of the devices that send core events. */
void
dmxKeyboardBellProc(int percent, DeviceIntPtr pDevice,
                    void *ctrl, int unknown)
{
    GETDMXLOCALFROMPDEVICE;
    int i, j;

    if (dmxLocal->sendsCore) {  /* Do for all core devices */
        for (i = 0; i < dmxNumInputs; i++) {
            DMXInputInfo *dmxInput = &dmxInputs[i];

            if (dmxInput->detached)
                continue;
            for (j = 0; j < dmxInput->numDevs; j++)
                if (dmxInput->devs[j]->sendsCore)
                    _dmxKeyboardBellProc(dmxInput->devs[j], percent);
        }
    }
    else {                      /* Do for this device only */
        _dmxKeyboardBellProc(dmxLocal, percent);
    }
}

static void
dmxKeyboardFreeNames(XkbComponentNamesPtr names)
{
    if (names->keycodes)
        XFree(names->keycodes);
    if (names->types)
        XFree(names->types);
    if (names->compat)
        XFree(names->compat);
    if (names->symbols)
        XFree(names->symbols);
    if (names->geometry)
        XFree(names->geometry);
}

static int
dmxKeyboardOn(DeviceIntPtr pDevice, DMXLocalInitInfo * info)
{
    GETDMXINPUTFROMPDEVICE;
    XkbRMLVOSet rmlvo;

    rmlvo.rules = dmxConfigGetXkbRules();
    rmlvo.model = dmxConfigGetXkbModel();
    rmlvo.layout = dmxConfigGetXkbLayout();
    rmlvo.variant = dmxConfigGetXkbVariant();
    rmlvo.options = dmxConfigGetXkbOptions();

    XkbSetRulesDflts(&rmlvo);
    if (!info->force && (dmxInput->keycodes
                         || dmxInput->symbols || dmxInput->geometry)) {
        if (info->freenames)
            dmxKeyboardFreeNames(&info->names);
        info->freenames = 0;
        info->names.keycodes = dmxInput->keycodes;
        info->names.types = NULL;
        info->names.compat = NULL;
        info->names.symbols = dmxInput->symbols;
        info->names.geometry = dmxInput->geometry;

        dmxLogInput(dmxInput, "XKEYBOARD: From command line: %s",
                    info->names.keycodes);
        if (info->names.symbols && *info->names.symbols)
            dmxLogInputCont(dmxInput, " %s", info->names.symbols);
        if (info->names.geometry && *info->names.geometry)
            dmxLogInputCont(dmxInput, " %s", info->names.geometry);
        dmxLogInputCont(dmxInput, "\n");
    }
    else if (info->names.keycodes) {
        dmxLogInput(dmxInput, "XKEYBOARD: From device: %s",
                    info->names.keycodes);
        if (info->names.symbols && *info->names.symbols)
            dmxLogInputCont(dmxInput, " %s", info->names.symbols);
        if (info->names.geometry && *info->names.geometry)
            dmxLogInputCont(dmxInput, " %s", info->names.geometry);
        dmxLogInputCont(dmxInput, "\n");
    }
    else {
        dmxLogInput(dmxInput, "XKEYBOARD: Defaults: %s %s %s %s %s\n",
                    dmxConfigGetXkbRules(),
                    dmxConfigGetXkbLayout(),
                    dmxConfigGetXkbModel(), dmxConfigGetXkbVariant()
                    ? dmxConfigGetXkbVariant() : "", dmxConfigGetXkbOptions()
                    ? dmxConfigGetXkbOptions() : "");
    }
    InitKeyboardDeviceStruct(pDevice, &rmlvo,
                             dmxKeyboardBellProc, dmxKeyboardKbdCtrlProc);

    if (info->freenames)
        dmxKeyboardFreeNames(&info->names);

    return Success;
}

static int
dmxDeviceOnOff(DeviceIntPtr pDevice, int what)
{
    GETDMXINPUTFROMPDEVICE;
    int fd;
    DMXLocalInitInfo info;
    int i;
    Atom btn_labels[MAX_BUTTONS] = { 0 };       /* FIXME */
    Atom axis_labels[MAX_VALUATORS] = { 0 };    /* FIXME */

    if (dmxInput->detached)
        return Success;

    memset(&info, 0, sizeof(info));
    switch (what) {
    case DEVICE_INIT:
        if (dmxLocal->init)
            dmxLocal->init(pDev);
        if (dmxLocal->get_info)
            dmxLocal->get_info(pDev, &info);
        if (info.keyboard) {    /* XKEYBOARD makes this a special case */
            dmxKeyboardOn(pDevice, &info);
            break;
        }
        if (info.keyClass) {
            XkbRMLVOSet rmlvo;

            rmlvo.rules = dmxConfigGetXkbRules();
            rmlvo.model = dmxConfigGetXkbModel();
            rmlvo.layout = dmxConfigGetXkbLayout();
            rmlvo.variant = dmxConfigGetXkbVariant();
            rmlvo.options = dmxConfigGetXkbOptions();

            InitKeyboardDeviceStruct(pDevice, &rmlvo, dmxBell, dmxKbdCtrl);
        }
        if (info.buttonClass) {
            InitButtonClassDeviceStruct(pDevice, info.numButtons,
                                        btn_labels, info.map);
        }
        if (info.valuatorClass) {
            if (info.numRelAxes && dmxLocal->sendsCore) {
                InitValuatorClassDeviceStruct(pDevice, info.numRelAxes,
                                              axis_labels,
                                              GetMaximumEventsNum(), Relative);
                for (i = 0; i < info.numRelAxes; i++)
                    InitValuatorAxisStruct(pDevice, i, axis_labels[i],
                                           info.minval[i], info.maxval[i],
                                           info.res[i],
                                           info.minres[i], info.maxres[i],
                                           Relative);
            }
            else if (info.numRelAxes) {
                InitValuatorClassDeviceStruct(pDevice, info.numRelAxes,
                                              axis_labels,
                                              dmxPointerGetMotionBufferSize(),
                                              Relative);
                for (i = 0; i < info.numRelAxes; i++)
                    InitValuatorAxisStruct(pDevice, i, axis_labels[i],
                                           info.minval[i],
                                           info.maxval[i], info.res[i],
                                           info.minres[i], info.maxres[i],
                                           Relative);
            }
            else if (info.numAbsAxes) {
                InitValuatorClassDeviceStruct(pDevice, info.numAbsAxes,
                                              axis_labels,
                                              dmxPointerGetMotionBufferSize(),
                                              Absolute);
                for (i = 0; i < info.numAbsAxes; i++)
                    InitValuatorAxisStruct(pDevice, i,
                                           axis_labels[i],
                                           info.minval[i], info.maxval[i],
                                           info.res[i], info.minres[i],
                                           info.maxres[i], Absolute);
            }
        }
        if (info.focusClass)
            InitFocusClassDeviceStruct(pDevice);
        if (info.proximityClass)
            InitProximityClassDeviceStruct(pDevice);
        if (info.ptrFeedbackClass)
            InitPtrFeedbackClassDeviceStruct(pDevice, dmxChangePointerControl);
        if (info.intFeedbackClass || info.strFeedbackClass)
            dmxLog(dmxWarning,
                   "Integer and string feedback not supported for %s\n",
                   pDevice->name);
        if (!info.keyboard && (info.ledFeedbackClass || info.belFeedbackClass))
            dmxLog(dmxWarning,
                   "Led and bel feedback not supported for non-keyboard %s\n",
                   pDevice->name);
        break;
    case DEVICE_ON:
        if (!pDev->on) {
            if (dmxLocal->on && (fd = dmxLocal->on(pDev)) >= 0)
                dmxSigioRegister(dmxInput, fd);
            pDev->on = TRUE;
        }
        break;
    case DEVICE_OFF:
    case DEVICE_CLOSE:
        /* This can get called twice consecutively: once for a
         * detached screen (DEVICE_OFF), and then again at server
         * generation time (DEVICE_CLOSE). */
        if (pDev->on) {
            dmxSigioUnregister(dmxInput);
            if (dmxLocal->off)
                dmxLocal->off(pDev);
            pDev->on = FALSE;
        }
        break;
    }
    if (info.keySyms.map && info.freemap) {
        XFree(info.keySyms.map);
        info.keySyms.map = NULL;
    }
    if (info.xkb)
        XkbFreeKeyboard(info.xkb, 0, True);
    return Success;
}

static void
dmxProcessInputEvents(DMXInputInfo * dmxInput)
{
    int i;

    mieqProcessInputEvents();
#if 00 /*BP*/
        miPointerUpdate();
#endif
    if (dmxInput->detached)
        return;
    for (i = 0; i < dmxInput->numDevs; i += dmxInput->devs[i]->binding)
        if (dmxInput->devs[i]->process_input) {
            dmxInput->devs[i]->process_input(dmxInput->devs[i]->private);
        }

#if 11 /*BP*/
        mieqProcessInputEvents();
#endif
}

static void
dmxUpdateWindowInformation(DMXInputInfo * dmxInput,
                           DMXUpdateType type, WindowPtr pWindow)
{
    int i;

#ifdef PANORAMIX
    if (!noPanoramiXExtension && pWindow &&
        pWindow->parent != screenInfo.screens[0]->root)
        return;
#endif
#if DMX_WINDOW_DEBUG
    {
        const char *name = "Unknown";

        switch (type) {
        case DMX_UPDATE_REALIZE:
            name = "Realize";
            break;
        case DMX_UPDATE_UNREALIZE:
            name = "Unrealize";
            break;
        case DMX_UPDATE_RESTACK:
            name = "Restack";
            break;
        case DMX_UPDATE_COPY:
            name = "Copy";
            break;
        case DMX_UPDATE_RESIZE:
            name = "Resize";
            break;
        case DMX_UPDATE_REPARENT:
            name = "Repaint";
            break;
        }
        dmxLog(dmxDebug, "Window %p changed: %s\n", pWindow, name);
    }
#endif

    if (dmxInput->detached)
        return;
    for (i = 0; i < dmxInput->numDevs; i += dmxInput->devs[i]->binding)
        if (dmxInput->devs[i]->update_info)
            dmxInput->devs[i]->update_info(dmxInput->devs[i]->private,
                                           type, pWindow);
}

static void
dmxCollectAll(DMXInputInfo * dmxInput)
{
    int i;

    if (dmxInput->detached)
        return;
    for (i = 0; i < dmxInput->numDevs; i += dmxInput->devs[i]->binding)
        if (dmxInput->devs[i]->collect_events)
            dmxInput->devs[i]->collect_events(&dmxInput->devs[i]->pDevice->
                                              public, dmxMotion, dmxEnqueue,
                                              dmxCheckSpecialKeys, DMX_BLOCK);
}

static void
dmxBlockHandler(void *blockData, OSTimePtr pTimeout, void *pReadMask)
{
    DMXInputInfo *dmxInput = &dmxInputs[(uintptr_t) blockData];
    static unsigned long generation = 0;

    if (generation != serverGeneration) {
        generation = serverGeneration;
        dmxCollectAll(dmxInput);
    }
}

static void
dmxSwitchReturn(void *p)
{
    DMXInputInfo *dmxInput = p;
    int i;

    dmxLog(dmxInfo, "Returning from VT %d\n", dmxInput->vt_switched);

    if (!dmxInput->vt_switched)
        dmxLog(dmxFatal, "dmxSwitchReturn called, but not switched\n");
    dmxSigioEnableInput();
    for (i = 0; i < dmxInput->numDevs; i++)
        if (dmxInput->devs[i]->vt_post_switch)
            dmxInput->devs[i]->vt_post_switch(dmxInput->devs[i]->private);
    dmxInput->vt_switched = 0;
}

static void
dmxWakeupHandler(void *blockData, int result, void *pReadMask)
{
    DMXInputInfo *dmxInput = &dmxInputs[(uintptr_t) blockData];
    int i;

    if (dmxInput->vt_switch_pending) {
        dmxLog(dmxInfo, "Switching to VT %d\n", dmxInput->vt_switch_pending);
        for (i = 0; i < dmxInput->numDevs; i++)
            if (dmxInput->devs[i]->vt_pre_switch)
                dmxInput->devs[i]->vt_pre_switch(dmxInput->devs[i]->private);
        dmxInput->vt_switched = dmxInput->vt_switch_pending;
        dmxInput->vt_switch_pending = 0;
        for (i = 0; i < dmxInput->numDevs; i++) {
            if (dmxInput->devs[i]->vt_switch) {
                dmxSigioDisableInput();
                if (!dmxInput->devs[i]->vt_switch(dmxInput->devs[i]->private,
                                                  dmxInput->vt_switched,
                                                  dmxSwitchReturn, dmxInput))
                    dmxSwitchReturn(dmxInput);
                break;          /* Only call one vt_switch routine */
            }
        }
    }
    dmxCollectAll(dmxInput);
}

static char *
dmxMakeUniqueDeviceName(DMXLocalInputInfoPtr dmxLocal)
{
    static int k = 0;
    static int m = 0;
    static int o = 0;
    static unsigned long dmxGeneration = 0;

#define LEN  32
    char *buf = malloc(LEN);

    if (dmxGeneration != serverGeneration) {
        k = m = o = 0;
        dmxGeneration = serverGeneration;
    }

    switch (dmxLocal->type) {
    case DMX_LOCAL_KEYBOARD:
        snprintf(buf, LEN, "Keyboard%d", k++);
        break;
    case DMX_LOCAL_MOUSE:
        snprintf(buf, LEN, "Mouse%d", m++);
        break;
    default:
        snprintf(buf, LEN, "Other%d", o++);
        break;
    }

    return buf;
}

static DeviceIntPtr
dmxAddDevice(DMXLocalInputInfoPtr dmxLocal)
{
    DeviceIntPtr pDevice;
    Atom atom;
    const char *name = NULL;
    char *devname;
    DMXInputInfo *dmxInput;

    if (!dmxLocal)
        return NULL;
    dmxInput = &dmxInputs[dmxLocal->inputIdx];

    if (dmxLocal->sendsCore) {
        if (dmxLocal->type == DMX_LOCAL_KEYBOARD && !dmxLocalCoreKeyboard) {
            dmxLocal->isCore = 1;
            dmxLocalCoreKeyboard = dmxLocal;
            name = "keyboard";
        }
        if (dmxLocal->type == DMX_LOCAL_MOUSE && !dmxLocalCorePointer) {
            dmxLocal->isCore = 1;
            dmxLocalCorePointer = dmxLocal;
            name = "pointer";
        }
    }

    if (!name) {
        name = "extension";
    }

    if (!name)
        dmxLog(dmxFatal, "Cannot add device %s\n", dmxLocal->name);

    pDevice = AddInputDevice(serverClient, dmxDeviceOnOff, TRUE);
    if (!pDevice) {
        dmxLog(dmxError, "Too many devices -- cannot add device %s\n",
               dmxLocal->name);
        return NULL;
    }
    pDevice->public.devicePrivate = dmxLocal;
    dmxLocal->pDevice = pDevice;

    devname = dmxMakeUniqueDeviceName(dmxLocal);
    atom = MakeAtom((char *) devname, strlen(devname), TRUE);
    pDevice->type = atom;
    pDevice->name = devname;

    if (dmxLocal->isCore && dmxLocal->type == DMX_LOCAL_MOUSE) {
#if 00   /*BP*/
            miRegisterPointerDevice(screenInfo.screens[0], pDevice);
#else
        /* Nothing? dmxDeviceOnOff() should get called to init, right? */
#endif
    }

    if (dmxLocal->create_private)
        dmxLocal->private = dmxLocal->create_private(pDevice);

    dmxLogInput(dmxInput, "Added %s as %s device called %s%s\n",
                dmxLocal->name, name, devname,
                dmxLocal->isCore
                ? " [core]"
                : (dmxLocal->sendsCore ? " [sends core events]" : ""));

    return pDevice;
}

static DMXLocalInputInfoPtr
dmxLookupLocal(const char *name)
{
    DMXLocalInputInfoPtr pt;

    for (pt = &DMXLocalDevices[0]; pt->name; ++pt)
        if (!strcmp(pt->name, name))
            return pt;          /* search for device name */
    return NULL;
}

/** Copy the local input information from \a s into a new \a devs slot
 * in \a dmxInput. */
DMXLocalInputInfoPtr
dmxInputCopyLocal(DMXInputInfo * dmxInput, DMXLocalInputInfoPtr s)
{
    DMXLocalInputInfoPtr dmxLocal = malloc(sizeof(*dmxLocal));

    if (!dmxLocal)
        dmxLog(dmxFatal, "DMXLocalInputInfoPtr: out of memory\n");

    memcpy(dmxLocal, s, sizeof(*dmxLocal));
    dmxLocal->inputIdx = dmxInput->inputIdx;
    dmxLocal->sendsCore = dmxInput->core;
    dmxLocal->savedSendsCore = dmxInput->core;
    dmxLocal->deviceId = -1;

    ++dmxInput->numDevs;
    dmxInput->devs = reallocarray(dmxInput->devs,
                                  dmxInput->numDevs, sizeof(*dmxInput->devs));
    dmxInput->devs[dmxInput->numDevs - 1] = dmxLocal;

    return dmxLocal;
}

static void
dmxPopulateLocal(DMXInputInfo * dmxInput, dmxArg a)
{
    int i;
    int help = 0;
    DMXLocalInputInfoRec *pt;

    for (i = 1; i < dmxArgC(a); i++) {
        const char *name = dmxArgV(a, i);

        if ((pt = dmxLookupLocal(name))) {
            dmxInputCopyLocal(dmxInput, pt);
        }
        else {
            if (strlen(name))
                dmxLog(dmxWarning, "Could not find a driver called %s\n", name);
            ++help;
        }
    }
    if (help) {
        dmxLog(dmxInfo, "Available local device drivers:\n");
        for (pt = &DMXLocalDevices[0]; pt->name; ++pt) {
            const char *type;

            switch (pt->type) {
            case DMX_LOCAL_KEYBOARD:
                type = "keyboard";
                break;
            case DMX_LOCAL_MOUSE:
                type = "pointer";
                break;
            default:
                type = "unknown";
                break;
            }
            dmxLog(dmxInfo, "   %s (%s)\n", pt->name, type);
        }
        dmxLog(dmxFatal, "Must have valid local device driver\n");
    }
}

int
dmxInputExtensionErrorHandler(Display * dsp, _Xconst char *name,
                              _Xconst char *reason)
{
    return 0;
}

static void
dmxInputScanForExtensions(DMXInputInfo * dmxInput, int doXI)
{
    XExtensionVersion *ext;
    XDeviceInfo *devices;
    Display *dsp;
    int num;
    int i, j;
    XextErrorHandler handler;

    if (!(dsp = XOpenDisplay(dmxInput->name)))
        return;

    /* Print out information about the XInput Extension. */
    handler = XSetExtensionErrorHandler(dmxInputExtensionErrorHandler);
    ext = XGetExtensionVersion(dsp, INAME);
    XSetExtensionErrorHandler(handler);

    if (!ext || ext == (XExtensionVersion *) NoSuchExtension) {
        dmxLogInput(dmxInput, "%s is not available\n", INAME);
    }
    else {
        dmxLogInput(dmxInput, "Locating devices on %s (%s version %d.%d)\n",
                    dmxInput->name, INAME,
                    ext->major_version, ext->minor_version);
        devices = XListInputDevices(dsp, &num);

        XFree(ext);
        ext = NULL;

        /* Print a list of all devices */
        for (i = 0; i < num; i++) {
            const char *use = "Unknown";

            switch (devices[i].use) {
            case IsXPointer:
                use = "XPointer";
                break;
            case IsXKeyboard:
                use = "XKeyboard";
                break;
            case IsXExtensionDevice:
                use = "XExtensionDevice";
                break;
            case IsXExtensionPointer:
                use = "XExtensionPointer";
                break;
            case IsXExtensionKeyboard:
                use = "XExtensionKeyboard";
                break;
            }
            dmxLogInput(dmxInput, "  %2d %-10.10s %-16.16s\n",
                        (int) devices[i].id,
                        devices[i].name ? devices[i].name : "", use);
        }

        /* Search for extensions */
        for (i = 0; i < num; i++) {
            switch (devices[i].use) {
            case IsXKeyboard:
                for (j = 0; j < dmxInput->numDevs; j++) {
                    DMXLocalInputInfoPtr dmxL = dmxInput->devs[j];

                    if (dmxL->type == DMX_LOCAL_KEYBOARD && dmxL->deviceId < 0) {
                        dmxL->deviceId = devices[i].id;
                        dmxL->deviceName = (devices[i].name
                                            ? strdup(devices[i].name)
                                            : NULL);
                    }
                }
                break;
            case IsXPointer:
                for (j = 0; j < dmxInput->numDevs; j++) {
                    DMXLocalInputInfoPtr dmxL = dmxInput->devs[j];

                    if (dmxL->type == DMX_LOCAL_MOUSE && dmxL->deviceId < 0) {
                        dmxL->deviceId = devices[i].id;
                        dmxL->deviceName = (devices[i].name
                                            ? xstrdup(devices[i].name)
                                            : NULL);
                    }
                }
                break;
            }
        }
        XFreeDeviceList(devices);
    }
    XCloseDisplay(dsp);
}

/** Re-initialize all the devices described in \a dmxInput.  Called from
    #dmxAdjustCursorBoundaries before the cursor is redisplayed. */
void
dmxInputReInit(DMXInputInfo * dmxInput)
{
    int i;

    for (i = 0; i < dmxInput->numDevs; i++) {
        DMXLocalInputInfoPtr dmxLocal = dmxInput->devs[i];

        if (dmxLocal->reinit)
            dmxLocal->reinit(&dmxLocal->pDevice->public);
    }
}

/** Re-initialize all the devices described in \a dmxInput.  Called from
    #dmxAdjustCursorBoundaries after the cursor is redisplayed. */
void
dmxInputLateReInit(DMXInputInfo * dmxInput)
{
    int i;

    for (i = 0; i < dmxInput->numDevs; i++) {
        DMXLocalInputInfoPtr dmxLocal = dmxInput->devs[i];

        if (dmxLocal->latereinit)
            dmxLocal->latereinit(&dmxLocal->pDevice->public);
    }
}

/** Initialize all of the devices described in \a dmxInput. */
void
dmxInputInit(DMXInputInfo * dmxInput)
{
    dmxArg a;
    const char *name;
    int i;
    int doXI = 1;               /* Include by default */
    int forceConsole = 0;
    int doWindows = 1;          /* On by default */
    int hasXkb = 0;

    a = dmxArgParse(dmxInput->name);

    for (i = 1; i < dmxArgC(a); i++) {
        switch (hasXkb) {
        case 1:
            dmxInput->keycodes = xstrdup(dmxArgV(a, i));
            ++hasXkb;
            break;
        case 2:
            dmxInput->symbols = xstrdup(dmxArgV(a, i));
            ++hasXkb;
            break;
        case 3:
            dmxInput->geometry = xstrdup(dmxArgV(a, i));
            hasXkb = 0;
            break;
        case 0:
            if (!strcmp(dmxArgV(a, i), "noxi"))
                doXI = 0;
            else if (!strcmp(dmxArgV(a, i), "xi"))
                doXI = 1;
            else if (!strcmp(dmxArgV(a, i), "console"))
                forceConsole = 1;
            else if (!strcmp(dmxArgV(a, i), "noconsole"))
                forceConsole = 0;
            else if (!strcmp(dmxArgV(a, i), "windows"))
                doWindows = 1;
            else if (!strcmp(dmxArgV(a, i), "nowindows"))
                doWindows = 0;
            else if (!strcmp(dmxArgV(a, i), "xkb"))
                hasXkb = 1;
            else {
                dmxLog(dmxFatal, "Unknown input argument: %s\n", dmxArgV(a, i));
            }
        }
    }

    name = dmxArgV(a, 0);

    if (!strcmp(name, "local")) {
        dmxPopulateLocal(dmxInput, a);
    }
    else if (!strcmp(name, "dummy")) {
        dmxInputCopyLocal(dmxInput, &DMXDummyMou);
        dmxInputCopyLocal(dmxInput, &DMXDummyKbd);
        dmxLogInput(dmxInput, "Using dummy input\n");
    }
    else {
        int found;

        for (found = 0, i = 0; i < dmxNumScreens; i++) {
            if (dmxPropertySameDisplay(&dmxScreens[i], name)) {
                if (dmxScreens[i].shared)
                    dmxLog(dmxFatal,
                           "Cannot take input from shared backend (%s)\n",
                           name);
                if (!dmxInput->core) {
                    dmxLog(dmxWarning,
                           "Cannot use core devices on a backend (%s)"
                           " as XInput devices\n", name);
                }
                else {
                    char *pt;

                    for (pt = (char *) dmxInput->name; pt && *pt; pt++)
                        if (*pt == ',')
                            *pt = '\0';
                    dmxInputCopyLocal(dmxInput, &DMXBackendMou);
                    dmxInputCopyLocal(dmxInput, &DMXBackendKbd);
                    dmxInput->scrnIdx = i;
                    dmxLogInput(dmxInput,
                                "Using backend input from %s\n", name);
                }
                ++found;
                break;
            }
        }
        if (!found || forceConsole) {
            char *pt;

            if (found)
                dmxInput->console = TRUE;
            for (pt = (char *) dmxInput->name; pt && *pt; pt++)
                if (*pt == ',')
                    *pt = '\0';
            dmxInputCopyLocal(dmxInput, &DMXConsoleMou);
            dmxInputCopyLocal(dmxInput, &DMXConsoleKbd);
            if (doWindows) {
                dmxInput->windows = TRUE;
                dmxInput->updateWindowInfo = dmxUpdateWindowInformation;
            }
            dmxLogInput(dmxInput,
                        "Using console input from %s (%s windows)\n",
                        name, doWindows ? "with" : "without");
        }
    }

    dmxArgFree(a);

    /* Locate extensions we may be interested in */
    dmxInputScanForExtensions(dmxInput, doXI);

    for (i = 0; i < dmxInput->numDevs; i++) {
        DMXLocalInputInfoPtr dmxLocal = dmxInput->devs[i];

        dmxLocal->pDevice = dmxAddDevice(dmxLocal);
    }

    dmxInput->processInputEvents = dmxProcessInputEvents;
    dmxInput->detached = False;

    RegisterBlockAndWakeupHandlers(dmxBlockHandler, dmxWakeupHandler,
                                   (void *) (uintptr_t) dmxInput->inputIdx);
}

static void
dmxInputFreeLocal(DMXLocalInputInfoRec * local)
{
    if (!local)
        return;
    if (local->isCore && local->type == DMX_LOCAL_MOUSE)
        dmxLocalCorePointer = NULL;
    if (local->isCore && local->type == DMX_LOCAL_KEYBOARD)
        dmxLocalCoreKeyboard = NULL;
    if (local->destroy_private)
        local->destroy_private(local->private);
    free(local->history);
    free(local->valuators);
    free((void *) local->deviceName);
    local->private = NULL;
    local->history = NULL;
    local->deviceName = NULL;
    free(local);
}

/** Free all of the memory associated with \a dmxInput */
void
dmxInputFree(DMXInputInfo * dmxInput)
{
    int i;

    if (!dmxInput)
        return;

    free(dmxInput->keycodes);
    free(dmxInput->symbols);
    free(dmxInput->geometry);

    for (i = 0; i < dmxInput->numDevs; i++) {
        dmxInputFreeLocal(dmxInput->devs[i]);
        dmxInput->devs[i] = NULL;
    }
    free(dmxInput->devs);
    dmxInput->devs = NULL;
    dmxInput->numDevs = 0;
    if (dmxInput->freename)
        free((void *) dmxInput->name);
    dmxInput->name = NULL;
}

/** Log information about all of the known devices using #dmxLog(). */
void
dmxInputLogDevices(void)
{
    int i, j;

    dmxLog(dmxInfo, "%d devices:\n", dmxGetInputCount());
    dmxLog(dmxInfo, "  Id  Name                 Classes\n");
    for (j = 0; j < dmxNumInputs; j++) {
        DMXInputInfo *dmxInput = &dmxInputs[j];
        const char *pt = strchr(dmxInput->name, ',');
        int len = (pt ? (size_t) (pt - dmxInput->name)
                   : strlen(dmxInput->name));

        for (i = 0; i < dmxInput->numDevs; i++) {
            DeviceIntPtr pDevice = dmxInput->devs[i]->pDevice;

            if (pDevice) {
                dmxLog(dmxInfo, "  %2d%c %-20.20s",
                       pDevice->id,
                       dmxInput->detached ? 'D' : ' ', pDevice->name);
                if (pDevice->key)
                    dmxLogCont(dmxInfo, " key");
                if (pDevice->valuator)
                    dmxLogCont(dmxInfo, " val");
                if (pDevice->button)
                    dmxLogCont(dmxInfo, " btn");
                if (pDevice->focus)
                    dmxLogCont(dmxInfo, " foc");
                if (pDevice->kbdfeed)
                    dmxLogCont(dmxInfo, " fb/kbd");
                if (pDevice->ptrfeed)
                    dmxLogCont(dmxInfo, " fb/ptr");
                if (pDevice->intfeed)
                    dmxLogCont(dmxInfo, " fb/int");
                if (pDevice->stringfeed)
                    dmxLogCont(dmxInfo, " fb/str");
                if (pDevice->bell)
                    dmxLogCont(dmxInfo, " fb/bel");
                if (pDevice->leds)
                    dmxLogCont(dmxInfo, " fb/led");
                if (!pDevice->key && !pDevice->valuator && !pDevice->button
                    && !pDevice->focus && !pDevice->kbdfeed
                    && !pDevice->ptrfeed && !pDevice->intfeed
                    && !pDevice->stringfeed && !pDevice->bell && !pDevice->leds)
                    dmxLogCont(dmxInfo, " (none)");

                dmxLogCont(dmxInfo, "\t[i%d/%*.*s",
                           dmxInput->inputIdx, len, len, dmxInput->name);
                if (dmxInput->devs[i]->deviceId >= 0)
                    dmxLogCont(dmxInfo, "/id%d", (int) dmxInput->devs[i]->deviceId);
                if (dmxInput->devs[i]->deviceName)
                    dmxLogCont(dmxInfo, "=%s", dmxInput->devs[i]->deviceName);
                dmxLogCont(dmxInfo, "] %s\n",
                           dmxInput->devs[i]->isCore
                           ? "core"
                           : (dmxInput->devs[i]->sendsCore
                              ? "extension (sends core events)" : "extension"));
            }
        }
    }
}

/** Detach an input */
int
dmxInputDetach(DMXInputInfo * dmxInput)
{
    int i;

    if (dmxInput->detached)
        return BadAccess;

    for (i = 0; i < dmxInput->numDevs; i++) {
        DMXLocalInputInfoPtr dmxLocal = dmxInput->devs[i];

        dmxLogInput(dmxInput, "Detaching device id %d: %s%s\n",
                    dmxLocal->pDevice->id,
                    dmxLocal->pDevice->name,
                    dmxLocal->isCore
                    ? " [core]"
                    : (dmxLocal->sendsCore ? " [sends core events]" : ""));
        DisableDevice(dmxLocal->pDevice, TRUE);
    }
    dmxInput->detached = True;
    dmxInputLogDevices();
    return 0;
}

/** Search for input associated with \a dmxScreen, and detach. */
void
dmxInputDetachAll(DMXScreenInfo * dmxScreen)
{
    int i;

    for (i = 0; i < dmxNumInputs; i++) {
        DMXInputInfo *dmxInput = &dmxInputs[i];

        if (dmxInput->scrnIdx == dmxScreen->index)
            dmxInputDetach(dmxInput);
    }
}

/** Search for input associated with \a deviceId, and detach. */
int
dmxInputDetachId(int id)
{
    DMXInputInfo *dmxInput = dmxInputLocateId(id);

    if (!dmxInput)
        return BadValue;

    return dmxInputDetach(dmxInput);
}

DMXInputInfo *
dmxInputLocateId(int id)
{
    int i, j;

    for (i = 0; i < dmxNumInputs; i++) {
        DMXInputInfo *dmxInput = &dmxInputs[i];

        for (j = 0; j < dmxInput->numDevs; j++) {
            DMXLocalInputInfoPtr dmxLocal = dmxInput->devs[j];

            if (dmxLocal->pDevice->id == id)
                return dmxInput;
        }
    }
    return NULL;
}

static int
dmxInputAttachNew(DMXInputInfo * dmxInput, int *id)
{
    dmxInputInit(dmxInput);
    InitAndStartDevices();
    if (id && dmxInput->devs)
        *id = dmxInput->devs[0]->pDevice->id;
    dmxInputLogDevices();
    return 0;
}

static int
dmxInputAttachOld(DMXInputInfo * dmxInput, int *id)
{
    int i;

    dmxInput->detached = False;
    for (i = 0; i < dmxInput->numDevs; i++) {
        DMXLocalInputInfoPtr dmxLocal = dmxInput->devs[i];

        if (id)
            *id = dmxLocal->pDevice->id;
        dmxLogInput(dmxInput,
                    "Attaching device id %d: %s%s\n",
                    dmxLocal->pDevice->id,
                    dmxLocal->pDevice->name,
                    dmxLocal->isCore
                    ? " [core]"
                    : (dmxLocal->sendsCore ? " [sends core events]" : ""));
        EnableDevice(dmxLocal->pDevice, TRUE);
    }
    dmxInputLogDevices();
    return 0;
}

int
dmxInputAttachConsole(const char *name, int isCore, int *id)
{
    DMXInputInfo *dmxInput;
    int i;

    for (i = 0; i < dmxNumInputs; i++) {
        dmxInput = &dmxInputs[i];
        if (dmxInput->scrnIdx == -1
            && dmxInput->detached && !strcmp(dmxInput->name, name)) {
            /* Found match */
            dmxLogInput(dmxInput, "Reattaching detached console input\n");
            return dmxInputAttachOld(dmxInput, id);
        }
    }

    /* No match found */
    dmxInput = dmxConfigAddInput(xstrdup(name), isCore);
    dmxInput->freename = TRUE;
    dmxLogInput(dmxInput, "Attaching new console input\n");
    return dmxInputAttachNew(dmxInput, id);
}

int
dmxInputAttachBackend(int physicalScreen, int isCore, int *id)
{
    DMXInputInfo *dmxInput;
    DMXScreenInfo *dmxScreen;
    int i;

    if (physicalScreen < 0 || physicalScreen >= dmxNumScreens)
        return BadValue;
    for (i = 0; i < dmxNumInputs; i++) {
        dmxInput = &dmxInputs[i];
        if (dmxInput->scrnIdx != -1 && dmxInput->scrnIdx == physicalScreen) {
            /* Found match */
            if (!dmxInput->detached)
                return BadAccess;       /* Already attached */
            dmxScreen = &dmxScreens[physicalScreen];
            if (!dmxScreen->beDisplay)
                return BadAccess;       /* Screen detached */
            dmxLogInput(dmxInput, "Reattaching detached backend input\n");
            return dmxInputAttachOld(dmxInput, id);
        }
    }
    /* No match found */
    dmxScreen = &dmxScreens[physicalScreen];
    if (!dmxScreen->beDisplay)
        return BadAccess;       /* Screen detached */
    dmxInput = dmxConfigAddInput(dmxScreen->name, isCore);
    dmxLogInput(dmxInput, "Attaching new backend input\n");
    return dmxInputAttachNew(dmxInput, id);
}
@


1.8
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d817 2
a818 2
    dmxInput->devs = realloc(dmxInput->devs,
                             dmxInput->numDevs * sizeof(*dmxInput->devs));
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d877 1
a877 1
    Display *display;
d882 1
a882 1
    if (!(display = XOpenDisplay(dmxInput->name)))
d887 1
a887 1
    ext = XGetExtensionVersion(display, INAME);
d897 1
a897 1
        devices = XListInputDevices(display, &num);
d959 1
a959 1
    XCloseDisplay(display);
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d228 1
a228 1
dmxBell(int volume, DeviceIntPtr pDev, pointer arg, int something)
d339 1
a339 1
                    pointer ctrl, int unknown)
d636 1
a636 1
dmxBlockHandler(pointer blockData, OSTimePtr pTimeout, pointer pReadMask)
d648 1
a648 1
dmxSwitchReturn(pointer p)
d665 1
a665 1
dmxWakeupHandler(pointer blockData, int result, pointer pReadMask)
d924 1
a924 1
                        devices[i].id,
a995 1
    DeviceIntPtr pPointer = NULL, pKeyboard = NULL;
a1109 6
        if (dmxLocal->isCore) {
            if (dmxLocal->type == DMX_LOCAL_MOUSE)
                pPointer = dmxLocal->pDevice;
            if (dmxLocal->type == DMX_LOCAL_KEYBOARD)
                pKeyboard = dmxLocal->pDevice;
        }
d1132 1
a1132 1
    free(local->deviceName);
d1160 1
a1160 1
        free(dmxInput->name);
d1214 1
a1214 1
                    dmxLogCont(dmxInfo, "/id%d", dmxInput->devs[i]->deviceId);
@


1.5
log
@Update to xserver 1.11.2
@
text
@d105 1
a105 1
    1, /* With backend-mou or console-mou */
d126 1
a126 1
    1, /* With backend-mou or console-mou */
d136 1
a136 1
                                /* Dummy drivers that can compile on any OS */
d138 1
a138 1
                                /* Linux-specific drivers */
d140 7
a146 8
        "kbd", DMX_LOCAL_KEYBOARD, DMX_LOCAL_TYPE_LOCAL, 1,
        kbdLinuxCreatePrivate, kbdLinuxDestroyPrivate,
        kbdLinuxInit, NULL, NULL, kbdLinuxGetInfo,
        kbdLinuxOn, kbdLinuxOff, NULL,
        kbdLinuxVTPreSwitch, kbdLinuxVTPostSwitch, kbdLinuxVTSwitch,
        kbdLinuxRead, NULL, NULL, NULL,
        NULL, kbdLinuxCtrl, kbdLinuxBell
    },
d148 6
a153 7
        "ms", DMX_LOCAL_MOUSE, DMX_LOCAL_TYPE_LOCAL, 1,
        msLinuxCreatePrivate, msLinuxDestroyPrivate,
        msLinuxInit, NULL, NULL, msLinuxGetInfo,
        msLinuxOn, msLinuxOff, NULL,
        msLinuxVTPreSwitch, msLinuxVTPostSwitch, NULL,
        msLinuxRead
    },
d155 6
a160 7
        "ps2", DMX_LOCAL_MOUSE, DMX_LOCAL_TYPE_LOCAL, 1,
        ps2LinuxCreatePrivate, ps2LinuxDestroyPrivate,
        ps2LinuxInit, NULL, NULL, ps2LinuxGetInfo,
        ps2LinuxOn, ps2LinuxOff, NULL,
        ps2LinuxVTPreSwitch, ps2LinuxVTPostSwitch, NULL,
        ps2LinuxRead
    },
d163 3
a165 3
                                /* USB drivers, currently only for
                                   Linux, but relatively easy to port to
                                   other OSs */
d167 7
a173 8
        "usb-kbd", DMX_LOCAL_KEYBOARD, DMX_LOCAL_TYPE_LOCAL, 1,
        usbCreatePrivate, usbDestroyPrivate,
        kbdUSBInit, NULL, NULL, kbdUSBGetInfo,
        kbdUSBOn, usbOff, NULL,
        NULL, NULL, NULL,
        kbdUSBRead, NULL, NULL, NULL,
        NULL, kbdUSBCtrl
    },
d175 6
a180 7
        "usb-mou", DMX_LOCAL_MOUSE, DMX_LOCAL_TYPE_LOCAL, 1,
        usbCreatePrivate, usbDestroyPrivate,
        mouUSBInit, NULL, NULL, mouUSBGetInfo,
        mouUSBOn, usbOff, NULL,
        NULL, NULL, NULL,
        mouUSBRead
    },
d182 6
a187 7
        "usb-oth", DMX_LOCAL_OTHER, DMX_LOCAL_TYPE_LOCAL, 1,
        usbCreatePrivate, usbDestroyPrivate,
        othUSBInit, NULL, NULL, othUSBGetInfo,
        othUSBOn, usbOff, NULL,
        NULL, NULL, NULL,
        othUSBRead
    },
d190 2
a191 3
        "dummy-mou", DMX_LOCAL_MOUSE, DMX_LOCAL_TYPE_LOCAL, 1,
        NULL, NULL, NULL, NULL, NULL, dmxDummyMouGetInfo
    },
d193 3
a195 4
        "dummy-kbd", DMX_LOCAL_KEYBOARD, DMX_LOCAL_TYPE_LOCAL, 1,
        NULL, NULL, NULL, NULL, NULL, dmxDummyKbdGetInfo
    },
    { NULL }                    /* Must be last */
a197 1

d199 1
a199 1
void
d202 1
a202 1
   /* NO-OP */
d207 1
a207 1
dmxKbdCtrl (DeviceIntPtr pDevice, KeybdCtrl *ctrl)
d222 1
a222 1
    ki->bellDuration = ctrl->bell_duration; 
d233 1
a233 1
    
d241 1
a241 1
    
d247 2
a248 3

static void _dmxChangePointerControl(DMXLocalInputInfoPtr dmxLocal,
                                     PtrCtrl *ctrl)
d250 2
a251 1
    if (!dmxLocal) return;
d253 2
a254 1
    if (dmxLocal->mCtrl) dmxLocal->mCtrl(&dmxLocal->pDevice->public, ctrl);
d260 2
a261 1
void dmxChangePointerControl(DeviceIntPtr pDevice, PtrCtrl *ctrl)
d266 1
a266 1
    if (dmxLocal->sendsCore) {       /* Do for all core devices */
d269 3
a271 1
            if (dmxInput->detached) continue;
d276 2
a277 1
    } else {                    /* Do for this device only */
d282 2
a283 2
static void _dmxKeyboardKbdCtrlProc(DMXLocalInputInfoPtr dmxLocal,
                                    KeybdCtrl *ctrl)
d290 1
a298 1

d302 2
a303 1
void dmxKeyboardKbdCtrlProc(DeviceIntPtr pDevice, KeybdCtrl *ctrl)
d308 1
a308 1
    if (dmxLocal->sendsCore) {       /* Do for all core devices */
d311 3
a313 1
            if (dmxInput->detached) continue;
d318 2
a319 1
    } else {                    /* Do for this device only */
d324 2
a325 1
static void _dmxKeyboardBellProc(DMXLocalInputInfoPtr dmxLocal, int percent)
d327 6
a332 5
    if (dmxLocal->kBell) dmxLocal->kBell(&dmxLocal->pDevice->public,
                                         percent,
                                         dmxLocal->kctrl.bell,
                                         dmxLocal->kctrl.bell_pitch,
                                         dmxLocal->kctrl.bell_duration);
d337 3
a339 2
void dmxKeyboardBellProc(int percent, DeviceIntPtr pDevice,
                         pointer ctrl, int unknown)
d344 1
a344 1
    if (dmxLocal->sendsCore) {       /* Do for all core devices */
d347 3
a349 1
            if (dmxInput->detached) continue;
d354 2
a355 1
    } else {                    /* Do for this device only */
d360 2
a361 1
static void dmxKeyboardFreeNames(XkbComponentNamesPtr names)
d363 10
a372 5
    if (names->keycodes) XFree(names->keycodes);
    if (names->types)    XFree(names->types);
    if (names->compat)   XFree(names->compat);
    if (names->symbols)  XFree(names->symbols);
    if (names->geometry) XFree(names->geometry);
d375 2
a376 2

static int dmxKeyboardOn(DeviceIntPtr pDevice, DMXLocalInitInfo *info)
d389 4
a392 4
                         || dmxInput->symbols
                         || dmxInput->geometry)) {
        if (info->freenames) dmxKeyboardFreeNames(&info->names);
        info->freenames      = 0;
d394 3
a396 3
        info->names.types    = NULL;
        info->names.compat   = NULL;
        info->names.symbols  = dmxInput->symbols;
d406 2
a407 1
    } else if (info->names.keycodes) {
d415 2
a416 1
    } else {
d420 2
a421 4
                    dmxConfigGetXkbModel(),
                    dmxConfigGetXkbVariant()
                    ? dmxConfigGetXkbVariant() : "",
                    dmxConfigGetXkbOptions()
d425 1
a425 2
                                dmxKeyboardBellProc,
                                dmxKeyboardKbdCtrlProc);
d427 2
a428 1
    if (info->freenames) dmxKeyboardFreeNames(&info->names);
d433 2
a434 2
    
static int dmxDeviceOnOff(DeviceIntPtr pDevice, int what)
d437 1
a437 1
    int              fd;
d439 3
a441 3
    int              i;
    Atom             btn_labels[MAX_BUTTONS] = {0}; /* FIXME */
    Atom             axis_labels[MAX_VALUATORS] = {0}; /* FIXME */
d443 2
a444 1
    if (dmxInput->detached) return Success;
d466 1
a466 3
            InitKeyboardDeviceStruct(pDevice,
                                     &rmlvo,
                                     dmxBell, dmxKbdCtrl);
d476 1
a476 2
                                              GetMaximumEventsNum(),
                                              Relative);
d483 2
a484 1
            } else if (info.numRelAxes) {
d495 2
a496 1
            } else if (info.numAbsAxes) {
d509 4
a512 2
        if (info.focusClass)       InitFocusClassDeviceStruct(pDevice);
        if (info.proximityClass)   InitProximityClassDeviceStruct(pDevice);
d533 3
a535 3
            /* This can get called twice consecutively: once for a
             * detached screen (DEVICE_OFF), and then again at server
             * generation time (DEVICE_CLOSE). */
d538 2
a539 1
            if (dmxLocal->off) dmxLocal->off(pDev);
d548 2
a549 1
    if (info.xkb) XkbFreeKeyboard(info.xkb, 0, True);
d553 2
a554 1
static void dmxProcessInputEvents(DMXInputInfo *dmxInput)
d560 1
a560 1
    miPointerUpdate();
d570 1
a570 1
    mieqProcessInputEvents();
d574 3
a576 3
static void dmxUpdateWindowInformation(DMXInputInfo *dmxInput,
                                       DMXUpdateType type,
                                       WindowPtr pWindow)
d581 2
a582 1
    if (!noPanoramiXExtension && pWindow && pWindow->parent != screenInfo.screens[0]->root)
d588 1
d590 18
a607 6
        case DMX_UPDATE_REALIZE:            name = "Realize";         break;
        case DMX_UPDATE_UNREALIZE:          name = "Unrealize";       break;
        case DMX_UPDATE_RESTACK:            name = "Restack";         break;
        case DMX_UPDATE_COPY:               name = "Copy";            break;
        case DMX_UPDATE_RESIZE:             name = "Resize";          break;
        case DMX_UPDATE_REPARENT:           name = "Repaint";         break;
d621 2
a622 1
static void dmxCollectAll(DMXInputInfo *dmxInput)
d630 2
a631 3
            dmxInput->devs[i]->collect_events(&dmxInput->devs[i]->pDevice->public,
                                              dmxMotion,
                                              dmxEnqueue,
d635 2
a636 2
static void dmxBlockHandler(pointer blockData, OSTimePtr pTimeout,
                            pointer pReadMask)
d638 1
a638 1
    DMXInputInfo    *dmxInput = &dmxInputs[(uintptr_t)blockData];
d640 1
a640 1
    
d647 2
a648 1
static void dmxSwitchReturn(pointer p)
d651 2
a652 2
    int          i;
    
d664 2
a665 1
static void dmxWakeupHandler(pointer blockData, int result, pointer pReadMask)
d667 2
a668 2
    DMXInputInfo *dmxInput = &dmxInputs[(uintptr_t)blockData];
    int          i;
d675 1
a675 1
        dmxInput->vt_switched       = dmxInput->vt_switch_pending;
d682 1
a682 2
                                                  dmxSwitchReturn,
                                                  dmxInput))
d691 2
a692 1
static char *dmxMakeUniqueDeviceName(DMXLocalInputInfoPtr dmxLocal)
d694 3
a696 3
    static int           k = 0;
    static int           m = 0;
    static int           o = 0;
d698 1
d700 1
a700 1
    char *               buf = malloc(LEN);
d703 1
a703 1
        k = m = o     = 0;
d708 9
a716 3
    case DMX_LOCAL_KEYBOARD: XmuSnprintf(buf, LEN, "Keyboard%d", k++); break;
    case DMX_LOCAL_MOUSE:    XmuSnprintf(buf, LEN, "Mouse%d", m++);    break;
    default:                 XmuSnprintf(buf, LEN, "Other%d", o++);    break;
d722 2
a723 1
static DeviceIntPtr dmxAddDevice(DMXLocalInputInfoPtr dmxLocal)
d726 3
a728 3
    Atom         atom;
    const char   *name = NULL;
    char         *devname;
d737 1
a737 1
            dmxLocal->isCore     = 1;
d739 1
a739 1
            name                 = "keyboard";
d742 3
a744 3
            dmxLocal->isCore     = 1;
            dmxLocalCorePointer  = dmxLocal;
            name                 = "pointer";
d749 1
a749 1
        name            = "extension";
d755 1
a755 1
    pDevice                       = AddInputDevice(serverClient, dmxDeviceOnOff, TRUE);
d762 1
a762 1
    dmxLocal->pDevice             = pDevice;
d764 2
a765 2
    devname       = dmxMakeUniqueDeviceName(dmxLocal);
    atom          = MakeAtom((char *)devname, strlen(devname), TRUE);
d770 2
a771 2
#if 00 /*BP*/
        miRegisterPointerDevice(screenInfo.screens[0], pDevice);
d784 1
a784 3
                : (dmxLocal->sendsCore
                   ? " [sends core events]"
                   : ""));
d789 2
a790 1
static DMXLocalInputInfoPtr dmxLookupLocal(const char *name)
d793 1
a793 1
    
d795 2
a796 1
        if (!strcmp(pt->name, name)) return pt; /* search for device name */
d802 2
a803 2
DMXLocalInputInfoPtr dmxInputCopyLocal(DMXInputInfo *dmxInput,
                                       DMXLocalInputInfoPtr s)
d806 1
a806 1
    
d811 2
a812 2
    dmxLocal->inputIdx       = dmxInput->inputIdx;
    dmxLocal->sendsCore      = dmxInput->core;
d814 1
a814 1
    dmxLocal->deviceId       = -1;
d818 3
a820 3
                              dmxInput->numDevs * sizeof(*dmxInput->devs));
    dmxInput->devs[dmxInput->numDevs-1] = dmxLocal;
    
d824 2
a825 1
static void dmxPopulateLocal(DMXInputInfo *dmxInput, dmxArg a)
d827 2
a828 2
    int                  i;
    int                  help = 0;
d833 1
d836 2
a837 1
        } else {
d839 1
a839 2
                dmxLog(dmxWarning,
                       "Could not find a driver called %s\n", name);
d847 1
d849 9
a857 3
            case DMX_LOCAL_KEYBOARD: type = "keyboard"; break;
            case DMX_LOCAL_MOUSE:    type = "pointer";  break;
            default:                 type = "unknown";  break;
d865 3
a867 1
int dmxInputExtensionErrorHandler(Display *dsp, _Xconst char *name, _Xconst char *reason)
d872 2
a873 1
static void dmxInputScanForExtensions(DMXInputInfo *dmxInput, int doXI)
d875 9
a883 6
    XExtensionVersion    *ext;
    XDeviceInfo          *devices;
    Display              *display;
    int                  num;
    int                  i, j;
    XextErrorHandler     handler;
a884 2
    if (!(display = XOpenDisplay(dmxInput->name))) return;
    
d887 1
a887 1
    ext     = XGetExtensionVersion(display, INAME);
d889 2
a890 2
    
    if (!ext || ext == (XExtensionVersion *)NoSuchExtension) {
d892 2
a893 1
    } else {
d902 1
a902 1
                                /* Print a list of all devices */
d905 1
d907 15
a921 5
            case IsXPointer:           use = "XPointer";         break;
            case IsXKeyboard:          use = "XKeyboard";        break;
            case IsXExtensionDevice:   use = "XExtensionDevice"; break;
            case IsXExtensionPointer:  use = "XExtensionPointer"; break;
            case IsXExtensionKeyboard: use = "XExtensionKeyboard"; break;
d925 1
a925 2
                        devices[i].name ? devices[i].name : "",
                        use);
d928 1
a928 1
                                /* Search for extensions */
d934 3
a936 3
                    if (dmxL->type == DMX_LOCAL_KEYBOARD
                        && dmxL->deviceId < 0) {
                        dmxL->deviceId   = devices[i].id;
d946 1
d948 1
a948 1
                        dmxL->deviceId   = devices[i].id;
d964 2
a965 1
void dmxInputReInit(DMXInputInfo *dmxInput)
d971 1
d979 2
a980 1
void dmxInputLateReInit(DMXInputInfo *dmxInput)
d986 1
d993 2
a994 1
void dmxInputInit(DMXInputInfo *dmxInput)
d996 8
a1003 8
    DeviceIntPtr         pPointer = NULL, pKeyboard = NULL;
    dmxArg               a;
    const char           *name;
    int                  i;
    int                  doXI               = 1; /* Include by default */
    int                  forceConsole       = 0;
    int                  doWindows          = 1; /* On by default */
    int                  hasXkb             = 0;
d1014 1
a1014 1
            dmxInput->symbols  = xstrdup(dmxArgV(a, i));
d1022 14
a1035 7
            if      (!strcmp(dmxArgV(a, i), "noxi"))      doXI         = 0;
            else if (!strcmp(dmxArgV(a, i), "xi"))        doXI         = 1;
            else if (!strcmp(dmxArgV(a, i), "console"))   forceConsole = 1;
            else if (!strcmp(dmxArgV(a, i), "noconsole")) forceConsole = 0;
            else if (!strcmp(dmxArgV(a, i), "windows"))   doWindows    = 1;
            else if (!strcmp(dmxArgV(a, i), "nowindows")) doWindows    = 0;
            else if (!strcmp(dmxArgV(a, i), "xkb"))       hasXkb       = 1;
d1037 1
a1037 2
                dmxLog(dmxFatal,
                       "Unknown input argument: %s\n", dmxArgV(a, i));
d1046 2
a1047 1
    } else if (!strcmp(name, "dummy")) {
d1051 2
a1052 1
    } else {
d1065 2
a1066 1
                } else {
d1068 4
a1071 2
                    for (pt = (char *)dmxInput->name; pt && *pt; pt++)
                        if (*pt == ',') *pt = '\0';
d1084 6
a1089 3
            if (found) dmxInput->console = TRUE;
            for (pt = (char *)dmxInput->name; pt && *pt; pt++)
                if (*pt == ',') *pt = '\0';
d1093 1
a1093 1
                dmxInput->windows          = TRUE;
d1104 1
a1104 1
                                /* Locate extensions we may be interested in */
d1106 1
a1106 1
    
d1109 1
d1113 1
a1113 1
                pPointer  = dmxLocal->pDevice;
d1118 4
a1121 4
    
    dmxInput->processInputEvents    = dmxProcessInputEvents;
    dmxInput->detached              = False;
    
d1123 1
a1123 1
                                   (void *)(uintptr_t)dmxInput->inputIdx);
d1126 2
a1127 1
static void dmxInputFreeLocal(DMXLocalInputInfoRec *local)
d1129 2
a1130 1
    if (!local) return;
d1132 1
a1132 1
        dmxLocalCorePointer  = NULL;
d1135 2
a1136 1
    if (local->destroy_private) local->destroy_private(local->private);
d1140 2
a1141 2
    local->private    = NULL;
    local->history    = NULL;
d1147 2
a1148 1
void dmxInputFree(DMXInputInfo *dmxInput)
d1151 3
a1153 2
    
    if (!dmxInput) return;
d1164 1
a1164 1
    dmxInput->devs    = NULL;
d1166 3
a1168 2
    if (dmxInput->freename) free(dmxInput->name);
    dmxInput->name    = NULL;
d1172 2
a1173 1
void dmxInputLogDevices(void)
d1181 3
a1183 4
        const char   *pt = strchr(dmxInput->name, ',');
        int          len = (pt
                            ? (size_t)(pt-dmxInput->name)
                            : strlen(dmxInput->name));
d1187 1
d1191 21
a1211 12
                       dmxInput->detached ? 'D' : ' ',
                       pDevice->name);
                if (pDevice->key)        dmxLogCont(dmxInfo, " key");
                if (pDevice->valuator)   dmxLogCont(dmxInfo, " val");
                if (pDevice->button)     dmxLogCont(dmxInfo, " btn");
                if (pDevice->focus)      dmxLogCont(dmxInfo, " foc");
                if (pDevice->kbdfeed)    dmxLogCont(dmxInfo, " fb/kbd");
                if (pDevice->ptrfeed)    dmxLogCont(dmxInfo, " fb/ptr");
                if (pDevice->intfeed)    dmxLogCont(dmxInfo, " fb/int");
                if (pDevice->stringfeed) dmxLogCont(dmxInfo, " fb/str");
                if (pDevice->bell)       dmxLogCont(dmxInfo, " fb/bel");
                if (pDevice->leds)       dmxLogCont(dmxInfo, " fb/led");
d1215 3
a1217 3
                    && !pDevice->stringfeed && !pDevice->bell
                    && !pDevice->leds)   dmxLogCont(dmxInfo, " (none)");
                                                                 
d1228 1
a1228 2
                              ? "extension (sends core events)"
                              : "extension"));
d1235 2
a1236 1
int dmxInputDetach(DMXInputInfo *dmxInput)
d1240 3
a1242 2
    if (dmxInput->detached) return BadAccess;
    
d1245 1
d1251 1
a1251 3
                    : (dmxLocal->sendsCore
                       ? " [sends core events]"
                       : ""));
d1260 2
a1261 1
void dmxInputDetachAll(DMXScreenInfo *dmxScreen)
d1267 3
a1269 1
        if (dmxInput->scrnIdx == dmxScreen->index) dmxInputDetach(dmxInput);
d1274 2
a1275 1
int dmxInputDetachId(int id)
d1279 3
a1281 2
    if (!dmxInput) return BadValue;
    
d1285 2
a1286 1
DMXInputInfo *dmxInputLocateId(int id)
d1289 1
a1289 1
    
d1292 1
d1295 3
a1297 1
            if (dmxLocal->pDevice->id == id) return dmxInput;
d1303 2
a1304 1
static int dmxInputAttachNew(DMXInputInfo *dmxInput, int *id)
d1308 2
a1309 1
    if (id && dmxInput->devs) *id = dmxInput->devs[0]->pDevice->id;
d1314 2
a1315 1
static int dmxInputAttachOld(DMXInputInfo *dmxInput, int *id)
d1318 1
a1318 1
    
d1322 3
a1324 1
        if (id) *id = dmxLocal->pDevice->id;
d1331 1
a1331 3
                    : (dmxLocal->sendsCore
                       ? " [sends core events]"
                       : ""));
d1338 2
a1339 1
int dmxInputAttachConsole(const char *name, int isCore, int *id)
d1341 2
a1342 2
    DMXInputInfo  *dmxInput;
    int           i;
d1347 2
a1348 3
            && dmxInput->detached
            && !strcmp(dmxInput->name, name)) {
                                /* Found match */
d1354 1
a1354 1
                                /* No match found */
d1361 2
a1362 1
int dmxInputAttachBackend(int physicalScreen, int isCore, int *id)
d1364 1
a1364 1
    DMXInputInfo  *dmxInput;
d1366 4
a1369 3
    int           i;
    
    if (physicalScreen < 0 || physicalScreen >= dmxNumScreens) return BadValue;
d1373 3
a1375 2
                                /* Found match */
            if (!dmxInput->detached) return BadAccess; /* Already attached */
d1377 2
a1378 1
            if (!dmxScreen->beDisplay) return BadAccess; /* Screen detached */
d1383 1
a1383 1
                                /* No match found */
d1385 2
a1386 1
    if (!dmxScreen->beDisplay) return BadAccess; /* Screen detached */
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a134 8
static DMXLocalInputInfoRec DMXCommonOth = {
    "common-oth", DMX_LOCAL_OTHER, DMX_LOCAL_TYPE_COMMON, 1,
    dmxCommonCopyPrivate, NULL,
    NULL, NULL, NULL, dmxCommonOthGetInfo,
    dmxCommonOthOn, dmxCommonOthOff
};


d471 2
a472 1
                                           info.minres[i], info.maxres[i]);
d482 2
a483 1
                                           info.minres[i], info.maxres[i]);
d494 1
a494 1
                                           info.maxres[i]);
a548 3
#if 11 /*BP*/
            miPointerUpdateSprite(dmxInput->devs[i]->pDevice);
#endif
d607 1
a607 1
    DMXInputInfo    *dmxInput = &dmxInputs[(int)blockData];
d634 1
a634 1
    DMXInputInfo *dmxInput = &dmxInputs[(int)blockData];
a686 1
    void         (*registerProcPtr)(DeviceIntPtr)   = NULL;
a698 1
            registerProcPtr      = RegisterKeyboardDevice;
a703 1
            registerProcPtr      = RegisterPointerDevice;
a708 1
        registerProcPtr = RegisterOtherDevice;
d711 1
a711 1
    if (!name || !registerProcPtr)
a727 2
    registerProcPtr(pDevice);

a888 23
#if 0
            case IsXExtensionDevice:
            case IsXExtensionKeyboard:
            case IsXExtensionPointer:
                if (doXI) {
                    if (!dmxInput->numDevs) {
                        dmxLog(dmxWarning,
                               "Cannot use remote (%s) XInput devices if"
                               " not also using core devices\n",
                               dmxInput->name);
                    } else {
                        dmxLocal             = dmxInputCopyLocal(dmxInput,
                                                                &DMXCommonOth);
                        dmxLocal->isCore     = FALSE;
                        dmxLocal->sendsCore  = FALSE;
                        dmxLocal->deviceId   = devices[i].id;
                        dmxLocal->deviceName = (devices[i].name
                                                ? strdup(devices[i].name)
                                                : NULL);
                    }
                }
                break;
#endif
d1036 2
a1037 3
    RegisterBlockAndWakeupHandlers(dmxBlockHandler,
                                   dmxWakeupHandler,
                                   (void *)dmxInput->inputIdx);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d573 1
a573 1
    if (!noPanoramiXExtension && pWindow && pWindow->parent != WindowTable[0])
d675 1
a675 1
    char *               buf = xalloc(LEN);
d779 1
a779 1
    DMXLocalInputInfoPtr dmxLocal = xalloc(sizeof(*dmxLocal));
d791 1
a791 1
    dmxInput->devs = xrealloc(dmxInput->devs,
d830 1
a830 1
int dmxInputExtensionErrorHandler(Display *dsp, char *name, char *reason)
d842 1
a842 2
    DMXLocalInputInfoPtr dmxLocal;
    int                  (*handler)(Display *, char *, char *);
d888 1
a888 1
                                            ? xstrdup(devices[i].name)
d921 1
a921 1
                                                ? xstrdup(devices[i].name)
d1087 3
a1089 3
    if (local->history)         xfree(local->history);
    if (local->valuators)       xfree(local->valuators);
    if (local->deviceName)      xfree(local->deviceName);
d1093 1
a1093 1
    xfree(local);
d1103 3
a1105 3
    if (dmxInput->keycodes) xfree(dmxInput->keycodes);
    if (dmxInput->symbols)  xfree(dmxInput->symbols);
    if (dmxInput->geometry) xfree(dmxInput->geometry);
d1111 1
a1111 1
    xfree(dmxInput->devs);
d1114 1
a1114 1
    if (dmxInput->freename) xfree(dmxInput->name);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a53 1
#include "dmxeq.h"
d74 1
a78 1
#define EXTENSION_PROC_ARGS void *
a80 8
/* From XI.h */
#ifndef Relative
#define Relative 0
#endif
#ifndef Absolute
#define Absolute 1
#endif

d300 1
a300 2
#ifdef XKB
        if (!noXkbExtension && dmxLocal->pDevice->kbdfeed) {
a306 1
#endif
a361 1
#ifdef XKB
a363 1
    if (names->keymap)   XFree(names->keymap);
a369 1
#endif
a373 1
#ifdef XKB
d375 1
a375 3
#else
    DevicePtr pDev = &pDevice->public;
#endif
d377 33
a409 8
#ifdef XKB
    if (noXkbExtension) {
#endif
        if (!InitKeyboardDeviceStruct(pDev, &info->keySyms, info->modMap,
                                      dmxKeyboardBellProc,
                                      dmxKeyboardKbdCtrlProc))
            return BadImplementation;
#ifdef XKB
d411 13
a423 48
        XkbSetRulesDflts(dmxConfigGetXkbRules(),
                         dmxConfigGetXkbModel(),
                         dmxConfigGetXkbLayout(),
                         dmxConfigGetXkbVariant(),
                         dmxConfigGetXkbOptions());
        if (!info->force && (dmxInput->keycodes
                             || dmxInput->symbols
                             || dmxInput->geometry)) {
            if (info->freenames) dmxKeyboardFreeNames(&info->names);
            info->freenames      = 0;
            info->names.keycodes = dmxInput->keycodes;
            info->names.types    = NULL;
            info->names.compat   = NULL;
            info->names.symbols  = dmxInput->symbols;
            info->names.geometry = dmxInput->geometry;
            
            dmxLogInput(dmxInput, "XKEYBOARD: From command line: %s",
                        info->names.keycodes);
            if (info->names.symbols && *info->names.symbols)
                dmxLogInputCont(dmxInput, " %s", info->names.symbols);
            if (info->names.geometry && *info->names.geometry)
                dmxLogInputCont(dmxInput, " %s", info->names.geometry);
            dmxLogInputCont(dmxInput, "\n");
        } else if (info->names.keycodes) {
            dmxLogInput(dmxInput, "XKEYBOARD: From device: %s",
                        info->names.keycodes);
            if (info->names.symbols && *info->names.symbols)
                dmxLogInputCont(dmxInput, " %s", info->names.symbols);
            if (info->names.geometry && *info->names.geometry)
                dmxLogInputCont(dmxInput, " %s", info->names.geometry);
            dmxLogInputCont(dmxInput, "\n");
        } else {
            dmxLogInput(dmxInput, "XKEYBOARD: Defaults: %s %s %s %s %s\n",
                        dmxConfigGetXkbRules(),
                        dmxConfigGetXkbLayout(),
                        dmxConfigGetXkbModel(),
                        dmxConfigGetXkbVariant()
                        ? dmxConfigGetXkbVariant() : "",
                        dmxConfigGetXkbOptions()
                        ? dmxConfigGetXkbOptions() : "");
        }
        XkbInitKeyboardDeviceStruct(pDevice,
                                    &info->names,
                                    &info->keySyms,
                                    info->modMap,
                                    dmxKeyboardBellProc,
                                    dmxKeyboardKbdCtrlProc);
    }
a424 1
#endif
d436 3
a438 1
    
d453 10
a462 4
            DevicePtr pDev = (DevicePtr) pDevice;
            InitKeyboardDeviceStruct(pDev,
                                     &info.keySyms,
                                     info.modMap,
d466 2
a467 1
            InitButtonClassDeviceStruct(pDevice, info.numButtons, info.map);
d472 1
d476 4
a479 3
                    InitValuatorAxisStruct(pDevice, i, info.minval[0],
                                           info.maxval[0], info.res[0],
                                           info.minres[0], info.maxres[0]);
d482 1
d486 4
a489 3
                    InitValuatorAxisStruct(pDevice, i, info.minval[0],
                                           info.maxval[0], info.res[0],
                                           info.minres[0], info.maxres[0]);
d492 1
d496 5
a500 4
                    InitValuatorAxisStruct(pDevice, i+info.numRelAxes,
                                           info.minval[i+1], info.maxval[i+1],
                                           info.res[i+1], info.minres[i+1],
                                           info.maxres[i+1]);
a506 3
        if (info.kbdFeedbackClass)
            InitKbdFeedbackClassDeviceStruct(pDevice, dmxKeyboardBellProc,
                                             dmxKeyboardKbdCtrlProc);
a538 1
#ifdef XKB
a539 1
#endif
d547 1
a547 1
    dmxeqProcessInputEvents();
d607 1
a607 2
            dmxInput->devs[i]->collect_events(&dmxInput->devs[i]
                                              ->pDevice->public,
d936 1
a936 1
    #dmxReconfig before the cursor is redisplayed. */ 
d949 1
a949 1
    #dmxReconfig after the cursor is redisplayed. */ 
a1071 6
    if (pPointer && pKeyboard) {
        if (dmxeqInit(&pKeyboard->public, &pPointer->public))
            dmxLogInput(dmxInput, "Using %s and %s as true core devices\n",
                        pKeyboard->name, pPointer->name);
    }

d1190 1
a1190 1
        DisableDevice(dmxLocal->pDevice);
d1258 1
a1258 1
        EnableDevice(dmxLocal->pDevice);
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
d74 1
a75 1
#ifdef XINPUT
a80 1
#endif
d223 51
a462 1
#ifdef XINPUT
a463 1
#endif
d470 4
a473 2
        if (dmxLocal->init) dmxLocal->init(pDev);
        if (dmxLocal->get_info) dmxLocal->get_info(pDev, &info);
d479 5
a483 1
            InitKeyClassDeviceStruct(pDevice, &info.keySyms, info.modMap);
d491 1
a491 2
                                              miPointerGetMotionEvents,
                                              miPointerGetMotionBufferSize(),
a492 1
#ifdef XINPUT
a496 1
#endif
a498 1
                                              dmxPointerGetMotionEvents,
a500 1
#ifdef XINPUT
a504 1
#endif
a506 1
                                              dmxPointerGetMotionEvents,
a508 1
#ifdef XINPUT
a513 1
#endif
a516 1
#ifdef XINPUT
a517 1
#endif
d566 1
d568 3
a570 1
    if (dmxInput->detached) return;
d572 4
a575 1
        if (dmxInput->devs[i]->process_input)
d577 5
d609 2
a610 1
    if (dmxInput->detached) return;
d621 2
a622 1
    if (dmxInput->detached) return;
d719 2
a720 1
    if (!dmxLocal) return NULL;
a737 1
#ifdef XINPUT
a741 6
#else
    if (!name)
        dmxLog(dmxFatal,
               "Server not build with XINPUT support (cannot add %s)\n",
               dmxLocal->name);
#endif
d746 1
a746 1
    pDevice                       = AddInputDevice(dmxDeviceOnOff, TRUE);
d762 2
a763 1
    if (dmxLocal->isCore && dmxLocal->type == DMX_LOCAL_MOUSE)
d765 4
d886 5
a890 3
            case IsXPointer:         use = "XPointer";         break;
            case IsXKeyboard:        use = "XKeyboard";        break;
            case IsXExtensionDevice: use = "XExtensionDevice"; break;
d924 1
d926 2
d946 1
a1081 7
#ifndef XINPUT
        if (!dmxLocal->isCore)
            dmxLog(dmxFatal,
                   "This server was not compiled to support the XInput"
                   " extension, but %s is not a core device.\n",
                   dmxLocal->name);
#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
a74 1
#include "mi.h"
a224 51

#if 11 /*BP*/
void
DDXRingBell(int volume, int pitch, int duration)
{
   /* NO-OP */
}

/* taken from kdrive/src/kinput.c: */
static void
dmxKbdCtrl (DeviceIntPtr pDevice, KeybdCtrl *ctrl)
{
#if 0
    KdKeyboardInfo *ki;

    for (ki = kdKeyboards; ki; ki = ki->next) {
        if (ki->dixdev && ki->dixdev->id == pDevice->id)
            break;
    }

    if (!ki || !ki->dixdev || ki->dixdev->id != pDevice->id || !ki->driver)
        return;

    KdSetLeds(ki, ctrl->leds);
    ki->bellPitch = ctrl->bell_pitch;
    ki->bellDuration = ctrl->bell_duration; 
#endif
}

/* taken from kdrive/src/kinput.c: */
static void
dmxBell(int volume, DeviceIntPtr pDev, pointer arg, int something)
{
#if 0
    KeybdCtrl *ctrl = arg;
    KdKeyboardInfo *ki = NULL;
    
    for (ki = kdKeyboards; ki; ki = ki->next) {
        if (ki->dixdev && ki->dixdev->id == pDev->id)
            break;
    }

    if (!ki || !ki->dixdev || ki->dixdev->id != pDev->id || !ki->driver)
        return;
    
    KdRingBell(ki, volume, ctrl->bell_pitch, ctrl->bell_duration);
#endif
}

#endif /*BP*/

d423 2
a424 4
        if (dmxLocal->init)
            dmxLocal->init(pDev);
        if (dmxLocal->get_info)
            dmxLocal->get_info(pDev, &info);
a429 1
#if 00 /*BP*/
a430 7
#else
            DevicePtr pDev = (DevicePtr) pDevice;
            InitKeyboardDeviceStruct(pDev,
                                     &info.keySyms,
                                     info.modMap,
                                     dmxBell, dmxKbdCtrl);
#endif
a437 1
#if 00 /*BP*/
a439 4
#else
                                              GetMotionHistory,
                                              GetMaximumEventsNum(),
#endif
a523 1
#if 00 /*BP*/
d525 1
a525 3
#endif
    if (dmxInput->detached)
        return;
d527 1
a527 4
        if (dmxInput->devs[i]->process_input) {
#if 11 /*BP*/
            miPointerUpdateSprite(dmxInput->devs[i]->pDevice);
#endif
a528 5
        }

#if 11 /*BP*/
    mieqProcessInputEvents();
#endif
d556 1
a556 2
    if (dmxInput->detached)
        return;
d567 1
a567 2
    if (dmxInput->detached)
        return;
d664 1
a664 2
    if (!dmxLocal)
        return NULL;
d713 1
a713 2
    if (dmxLocal->isCore && dmxLocal->type == DMX_LOCAL_MOUSE) {
#if 00 /*BP*/
a714 4
#else
        /* Nothing? dmxDeviceOnOff() should get called to init, right? */
#endif
    }
@

