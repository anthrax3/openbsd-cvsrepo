head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.12
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.10
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.8
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.6
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	cVXoV5PxI8YrEaVA;

1.4
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.05;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.23.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.23.33;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright 2002 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Rickard E. (Rik) Faith <faith@@redhat.com>
 *
 */

/** \file
 * Interface for low-level input support.  \see dmxinputinit.c */

#ifndef _DMXINPUTINIT_H_
#define _DMXINPUTINIT_H_

#include "dmx.h"
#include "dmxinput.h"
#include "dmxlog.h"

#define DMX_LOCAL_DEFAULT_KEYBOARD "kbd"
#define DMX_LOCAL_DEFAULT_POINTER  "ps2"
#define DMX_MAX_BUTTONS            256
#define DMX_MOTION_SIZE            256
#define DMX_MAX_VALUATORS          32
#define DMX_MAX_AXES               32
#define DMX_MAX_XINPUT_EVENT_TYPES 100
#define DMX_MAP_ENTRIES            16   /* Must be a power of 2 */
#define DMX_MAP_MASK               (DMX_MAP_ENTRIES - 1)

typedef enum {
    DMX_FUNCTION_GRAB,
    DMX_FUNCTION_TERMINATE,
    DMX_FUNCTION_FINE
} DMXFunctionType;

typedef enum {
    DMX_LOCAL_HIGHLEVEL,
    DMX_LOCAL_KEYBOARD,
    DMX_LOCAL_MOUSE,
    DMX_LOCAL_OTHER
} DMXLocalInputType;

typedef enum {
    DMX_LOCAL_TYPE_LOCAL,
    DMX_LOCAL_TYPE_CONSOLE,
    DMX_LOCAL_TYPE_BACKEND,
    DMX_LOCAL_TYPE_COMMON
} DMXLocalInputExtType;

typedef enum {
    DMX_RELATIVE,
    DMX_ABSOLUTE,
    DMX_ABSOLUTE_CONFINED
} DMXMotionType;

/** Stores information from low-level device that is used to initialize
 * the device at the dix level. */
typedef struct _DMXLocalInitInfo {
    int keyboard;                  /**< Non-zero if the device is a keyboard */

    int keyClass;                  /**< Non-zero if keys are present */
    KeySymsRec keySyms;            /**< Key symbols */
    int freemap;                   /**< If non-zero, free keySyms.map */
    CARD8 modMap[MAP_LENGTH];                /**< Modifier map */
    XkbDescPtr xkb;                 /**< XKB description */
    XkbComponentNamesRec names;     /**< XKB component names */
    int freenames;                  /**< Non-zero if names should be free'd */
    int force;                      /**< Do not allow command line override */

    int buttonClass;                  /**< Non-zero if buttons are present */
    int numButtons;                   /**< Number of buttons */
    unsigned char map[DMX_MAX_BUTTONS];        /**< Button map */

    int valuatorClass;                  /**< Non-zero if valuators are
                                         * present */
    int numRelAxes;                     /**< Number of relative axes */
    int numAbsAxes;                     /**< Number of absolute axes */
    int minval[DMX_MAX_AXES];                  /**< Minimum values */
    int maxval[DMX_MAX_AXES];                  /**< Maximum values */
    int res[DMX_MAX_AXES];                     /**< Resolution */
    int minres[DMX_MAX_AXES];                  /**< Minimum resolutions */
    int maxres[DMX_MAX_AXES];                  /**< Maximum resolutions */

    int focusClass;                        /**< Non-zero if device can
                                            * cause focus */
    int proximityClass;                    /**< Non-zero if device
                                            * causes proximity events */
    int kbdFeedbackClass;                  /**< Non-zero if device has
                                            * keyboard feedback */
    int ptrFeedbackClass;                  /**< Non-zero if device has
                                            * pointer feedback */
    int ledFeedbackClass;                  /**< Non-zero if device has
                                            * LED indicators */
    int belFeedbackClass;                  /**< Non-zero if device has a
                                            * bell */
    int intFeedbackClass;                  /**< Non-zero if device has
                                            * integer feedback */
    int strFeedbackClass;                  /**< Non-zero if device has
                                            * string feedback */

    int maxSymbols;                           /**< Maximum symbols */
    int maxSymbolsSupported;                  /**< Maximum symbols supported */
    KeySym *symbols;                          /**< Key symbols */
} DMXLocalInitInfo, *DMXLocalInitInfoPtr;

typedef void *(*dmxCreatePrivateProcPtr) (DeviceIntPtr);
typedef void (*dmxDestroyPrivateProcPtr) (void *);

typedef void (*dmxInitProcPtr) (DevicePtr);
typedef void (*dmxReInitProcPtr) (DevicePtr);
typedef void (*dmxLateReInitProcPtr) (DevicePtr);
typedef void (*dmxGetInfoProcPtr) (DevicePtr, DMXLocalInitInfoPtr);
typedef int (*dmxOnProcPtr) (DevicePtr);
typedef void (*dmxOffProcPtr) (DevicePtr);
typedef void (*dmxUpdatePositionProcPtr) (void *, int x, int y);

typedef void (*dmxVTPreSwitchProcPtr) (void *);        /* Turn I/O Off */
typedef void (*dmxVTPostSwitchProcPtr) (void *);       /* Turn I/O On */
typedef void (*dmxVTSwitchReturnProcPtr) (void *);
typedef int (*dmxVTSwitchProcPtr) (void *, int vt,
                                   dmxVTSwitchReturnProcPtr, void *);

typedef void (*dmxMotionProcPtr) (DevicePtr,
                                  int *valuators,
                                  int firstAxis,
                                  int axesCount,
                                  DMXMotionType type, DMXBlockType block);
typedef void (*dmxEnqueueProcPtr) (DevicePtr, int type, int detail,
                                   KeySym keySym, XEvent * e,
                                   DMXBlockType block);
typedef int (*dmxCheckSpecialProcPtr) (DevicePtr, KeySym keySym);
typedef void (*dmxCollectEventsProcPtr) (DevicePtr,
                                         dmxMotionProcPtr,
                                         dmxEnqueueProcPtr,
                                         dmxCheckSpecialProcPtr, DMXBlockType);
typedef void (*dmxProcessInputProcPtr) (void *);
typedef void (*dmxUpdateInfoProcPtr) (void *, DMXUpdateType, WindowPtr);
typedef int (*dmxFunctionsProcPtr) (void *, DMXFunctionType);

typedef void (*dmxKBCtrlProcPtr) (DevicePtr, KeybdCtrl * ctrl);
typedef void (*dmxMCtrlProcPtr) (DevicePtr, PtrCtrl * ctrl);
typedef void (*dmxKBBellProcPtr) (DevicePtr, int percent,
                                  int volume, int pitch, int duration);

/** Stores a mapping between the device id on the remote X server and
 * the id on the DMX server */
typedef struct _DMXEventMap {
    int remote;                 /**< Event number on remote X server */
    int server;                 /**< Event number (unbiased) on DMX server */
} DMXEventMap;

/** This is the device-independent structure used by the low-level input
 * routines.  The contents are not exposed to top-level .c files (except
 * dmxextensions.c).  \see dmxinput.h \see dmxextensions.c */
typedef struct _DMXLocalInputInfo {
    const char *name;                 /**< Device name */
    DMXLocalInputType type;           /**< Device type  */
    DMXLocalInputExtType extType;     /**< Extended device type */
    int binding;                      /**< Count of how many consecutive
                                       * structs are bound to the same
                                       * device */

    /* Low-level (e.g., keyboard/mouse drivers) */

    dmxCreatePrivateProcPtr create_private;   /**< Create
                                               * device-dependent
                                               * private */
    dmxDestroyPrivateProcPtr destroy_private; /**< Destroy
                                               * device-dependent
                                               * private */
    dmxInitProcPtr init;                      /**< Initialize device  */
    dmxReInitProcPtr reinit;                  /**< Reinitialize device
                                               * (during a
                                               * reconfiguration) */
    dmxLateReInitProcPtr latereinit;          /**< Reinitialize a device
                                               * (called very late
                                               * during a
                                               * reconfiguration) */
    dmxGetInfoProcPtr get_info;               /**< Get device information */
    dmxOnProcPtr on;                          /**< Turn device on */
    dmxOffProcPtr off;                        /**< Turn device off */
    dmxUpdatePositionProcPtr update_position; /**< Called when another
                                               * device updates the
                                               * cursor position */
    dmxVTPreSwitchProcPtr vt_pre_switch;      /**< Called before a VT switch */
    dmxVTPostSwitchProcPtr vt_post_switch;    /**< Called after a VT switch */
    dmxVTSwitchProcPtr vt_switch;             /**< Causes a VT switch */

    dmxCollectEventsProcPtr collect_events;   /**< Collect and enqueue
                                               * events from the
                                               * device*/
    dmxProcessInputProcPtr process_input;     /**< Process event (from
                                               * queue)  */
    dmxFunctionsProcPtr functions;
    dmxUpdateInfoProcPtr update_info;         /**< Update window layout
                                               * information */

    dmxMCtrlProcPtr mCtrl;                    /**< Pointer control */
    dmxKBCtrlProcPtr kCtrl;                   /**< Keyboard control */
    dmxKBBellProcPtr kBell;                   /**< Bell control */

    void *private;                            /**< Device-dependent private  */
    int isCore;                               /**< Is a DMX core device  */
    int sendsCore;                            /**< Sends DMX core events */
    KeybdCtrl kctrl;                          /**< Keyboard control */
    PtrCtrl mctrl;                            /**< Pointer control */

    DeviceIntPtr pDevice;                     /**< X-level device  */
    int inputIdx;                             /**< High-level index */
    int lastX, lastY;                         /**< Last known position;
                                               * for XInput in
                                               * dmxevents.c */

    int head;                                 /**< XInput motion history
                                               * head */
    int tail;                                 /**< XInput motion history
                                               * tail */
    unsigned long *history;                   /**< XInput motion history */
    int *valuators;                           /**< Cache of previous values */

    /* for XInput ChangePointerDevice */
    int (*savedMotionProc) (DeviceIntPtr,
                            xTimecoord *,
                            unsigned long, unsigned long, ScreenPtr);
    int savedMotionEvents;                      /**< Saved motion events */
    int savedSendsCore;                         /**< Saved sends-core flag */

    DMXEventMap map[DMX_MAP_ENTRIES];              /**< XInput device id map */
    int mapOptimize;                               /**< XInput device id
                                                    * map
                                                    * optimization */

    long deviceId;                        /**< device id on remote side,
                                           * if any */
    const char *deviceName;               /**< devive name on remote
                                           * side, if any */
} DMXLocalInputInfoRec;

extern DMXLocalInputInfoPtr dmxLocalCorePointer, dmxLocalCoreKeyboard;

extern void dmxLocalInitInput(DMXInputInfo * dmxInput);
extern DMXLocalInputInfoPtr dmxInputCopyLocal(DMXInputInfo * dmxInput,
                                              DMXLocalInputInfoPtr s);

extern void dmxChangePointerControl(DeviceIntPtr pDevice, PtrCtrl * ctrl);
extern void dmxKeyboardKbdCtrlProc(DeviceIntPtr pDevice, KeybdCtrl * ctrl);
extern void dmxKeyboardBellProc(int percent, DeviceIntPtr pDevice,
                                void *ctrl, int unknown);

extern int dmxInputExtensionErrorHandler(Display * dsp, _Xconst char *name,
                                         _Xconst char *reason);

extern int dmxInputDetach(DMXInputInfo * dmxInput);
extern void dmxInputDetachAll(DMXScreenInfo * dmxScreen);
extern int dmxInputDetachId(int id);
extern DMXInputInfo *dmxInputLocateId(int id);
extern int dmxInputAttachConsole(const char *name, int isCore, int *id);
extern int dmxInputAttachBackend(int physicalScreen, int isCore, int *id);

#endif
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d130 2
a131 2
typedef pointer (*dmxCreatePrivateProcPtr) (DeviceIntPtr);
typedef void (*dmxDestroyPrivateProcPtr) (pointer);
d139 1
a139 1
typedef void (*dmxUpdatePositionProcPtr) (pointer, int x, int y);
d141 5
a145 5
typedef void (*dmxVTPreSwitchProcPtr) (pointer);        /* Turn I/O Off */
typedef void (*dmxVTPostSwitchProcPtr) (pointer);       /* Turn I/O On */
typedef void (*dmxVTSwitchReturnProcPtr) (pointer);
typedef int (*dmxVTSwitchProcPtr) (pointer, int vt,
                                   dmxVTSwitchReturnProcPtr, pointer);
d160 3
a162 3
typedef void (*dmxProcessInputProcPtr) (pointer);
typedef void (*dmxUpdateInfoProcPtr) (pointer, DMXUpdateType, WindowPtr);
typedef int (*dmxFunctionsProcPtr) (pointer, DMXFunctionType);
d226 1
a226 1
    pointer private;                          /**< Device-dependent private  */
d272 1
a272 1
                                pointer ctrl, int unknown);
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a43 1

d51 1
a51 1
#define DMX_MAP_ENTRIES            16 /* Must be a power of 2 */
d83 7
a89 7
    int                  keyboard; /**< Non-zero if the device is a keyboard */
    
    int                  keyClass; /**< Non-zero if keys are present */
    KeySymsRec           keySyms;  /**< Key symbols */
    int                  freemap;  /**< If non-zero, free keySyms.map */
    CARD8                modMap[MAP_LENGTH]; /**< Modifier map */
    XkbDescPtr           xkb;       /**< XKB description */
d91 2
a92 2
    int                  freenames; /**< Non-zero if names should be free'd */
    int                  force;     /**< Do not allow command line override */
d94 3
a96 3
    int                  buttonClass; /**< Non-zero if buttons are present */
    int                  numButtons;  /**< Number of buttons */
    unsigned char        map[DMX_MAX_BUTTONS]; /**< Button map */
d98 1
a98 1
    int                  valuatorClass; /**< Non-zero if valuators are
d100 7
a106 7
    int                  numRelAxes;    /**< Number of relative axes */
    int                  numAbsAxes;    /**< Number of absolute axes */
    int                  minval[DMX_MAX_AXES]; /**< Minimum values */
    int                  maxval[DMX_MAX_AXES]; /**< Maximum values */
    int                  res[DMX_MAX_AXES];    /**< Resolution */
    int                  minres[DMX_MAX_AXES]; /**< Minimum resolutions */
    int                  maxres[DMX_MAX_AXES]; /**< Maximum resolutions */
d108 1
a108 1
    int                  focusClass;       /**< Non-zero if device can
d110 1
a110 1
    int                  proximityClass;   /**< Non-zero if device
d112 3
a114 3
    int                  kbdFeedbackClass; /**< Non-zero if device has
                                            * keyboard feedback */ 
    int                  ptrFeedbackClass; /**< Non-zero if device has
d116 1
a116 1
    int                  ledFeedbackClass; /**< Non-zero if device has
d118 3
a120 3
    int                  belFeedbackClass; /**< Non-zero if device has a
                                            * bell */ 
    int                  intFeedbackClass; /**< Non-zero if device has
d122 1
a122 1
    int                  strFeedbackClass; /**< Non-zero if device has
d125 3
a127 3
    int                  maxSymbols;          /**< Maximum symbols */
    int                  maxSymbolsSupported; /**< Maximum symbols supported */
    KeySym               *symbols;            /**< Key symbols */
d130 38
a167 40
typedef pointer (*dmxCreatePrivateProcPtr)(DeviceIntPtr);
typedef void    (*dmxDestroyPrivateProcPtr)(pointer);
                
typedef void    (*dmxInitProcPtr)(DevicePtr);
typedef void    (*dmxReInitProcPtr)(DevicePtr);
typedef void    (*dmxLateReInitProcPtr)(DevicePtr);
typedef void    (*dmxGetInfoProcPtr)(DevicePtr, DMXLocalInitInfoPtr);
typedef int     (*dmxOnProcPtr)(DevicePtr);
typedef void    (*dmxOffProcPtr)(DevicePtr);
typedef void    (*dmxUpdatePositionProcPtr)(pointer, int x, int y);
                
typedef void    (*dmxVTPreSwitchProcPtr)(pointer);  /* Turn I/O Off */
typedef void    (*dmxVTPostSwitchProcPtr)(pointer); /* Turn I/O On */
typedef void    (*dmxVTSwitchReturnProcPtr)(pointer);
typedef int     (*dmxVTSwitchProcPtr)(pointer, int vt,
                                      dmxVTSwitchReturnProcPtr, pointer);
                
typedef void    (*dmxMotionProcPtr)(DevicePtr,
                                    int *valuators,
                                    int firstAxis,
                                    int axesCount,
                                    DMXMotionType type,
                                    DMXBlockType block);
typedef void    (*dmxEnqueueProcPtr)(DevicePtr, int type, int detail,
                                     KeySym keySym, XEvent *e,
                                     DMXBlockType block);
typedef int     (*dmxCheckSpecialProcPtr)(DevicePtr, KeySym keySym);
typedef void    (*dmxCollectEventsProcPtr)(DevicePtr,
                                           dmxMotionProcPtr,
                                           dmxEnqueueProcPtr,
                                           dmxCheckSpecialProcPtr,
                                           DMXBlockType);
typedef void    (*dmxProcessInputProcPtr)(pointer);
typedef void    (*dmxUpdateInfoProcPtr)(pointer, DMXUpdateType, WindowPtr);
typedef int     (*dmxFunctionsProcPtr)(pointer, DMXFunctionType);
                
typedef void    (*dmxKBCtrlProcPtr)(DevicePtr, KeybdCtrl *ctrl);
typedef void    (*dmxMCtrlProcPtr)(DevicePtr, PtrCtrl *ctrl);
typedef void    (*dmxKBBellProcPtr)(DevicePtr, int percent,
                                    int volume, int pitch, int duration);
d180 4
a183 4
    const char               *name;   /**< Device name */
    DMXLocalInputType        type;    /**< Device type  */
    DMXLocalInputExtType     extType; /**< Extended device type */
    int                      binding; /**< Count of how many consecutive
a185 2
    
                                /* Low-level (e.g., keyboard/mouse drivers) */
d187 3
a189 1
    dmxCreatePrivateProcPtr  create_private;  /**< Create
d195 2
a196 2
    dmxInitProcPtr           init;            /**< Initialize device  */
    dmxReInitProcPtr         reinit;          /**< Reinitialize device
d199 1
a199 1
    dmxLateReInitProcPtr     latereinit;      /**< Reinitialize a device
d203 3
a205 3
    dmxGetInfoProcPtr        get_info;        /**< Get device information */
    dmxOnProcPtr             on;              /**< Turn device on */
    dmxOffProcPtr            off;             /**< Turn device off */
d209 3
a211 3
    dmxVTPreSwitchProcPtr    vt_pre_switch;   /**< Called before a VT switch */
    dmxVTPostSwitchProcPtr   vt_post_switch;  /**< Called after a VT switch */
    dmxVTSwitchProcPtr       vt_switch;       /**< Causes a VT switch */
d213 1
a213 1
    dmxCollectEventsProcPtr  collect_events;  /**< Collect and enqueue
d216 1
a216 1
    dmxProcessInputProcPtr   process_input;   /**< Process event (from
d218 2
a219 2
    dmxFunctionsProcPtr      functions;
    dmxUpdateInfoProcPtr     update_info;     /**< Update window layout
d222 13
a234 13
    dmxMCtrlProcPtr          mCtrl;           /**< Pointer control */
    dmxKBCtrlProcPtr         kCtrl;           /**< Keyboard control */
    dmxKBBellProcPtr         kBell;           /**< Bell control */

    pointer                  private;         /**< Device-dependent private  */
    int                      isCore;          /**< Is a DMX core device  */
    int                      sendsCore;       /**< Sends DMX core events */
    KeybdCtrl                kctrl;           /**< Keyboard control */
    PtrCtrl                  mctrl;           /**< Pointer control */

    DeviceIntPtr             pDevice;         /**< X-level device  */
    int                      inputIdx;        /**< High-level index */
    int                      lastX, lastY;    /**< Last known position;
d236 1
a236 1
                                               * dmxevents.c */ 
d238 1
a238 1
    int                      head;            /**< XInput motion history
d240 1
a240 1
    int                      tail;            /**< XInput motion history
d242 9
a250 11
    unsigned long            *history;        /**< XInput motion history */
    int                      *valuators;      /**< Cache of previous values */
    
                                /* for XInput ChangePointerDevice */
    int                      (*savedMotionProc)(DeviceIntPtr,
                                                xTimecoord *,
                                                unsigned long,
                                                unsigned long,
                                                ScreenPtr);
    int                      savedMotionEvents; /**< Saved motion events */
    int                      savedSendsCore;    /**< Saved sends-core flag */
d252 2
a253 2
    DMXEventMap              map[DMX_MAP_ENTRIES]; /**< XInput device id map */
    int                      mapOptimize;          /**< XInput device id
d257 1
a257 1
    long                     deviceId;    /**< device id on remote side,
d259 1
a259 1
    const char               *deviceName; /**< devive name on remote
d265 2
a266 2
extern void                 dmxLocalInitInput(DMXInputInfo *dmxInput);
extern DMXLocalInputInfoPtr dmxInputCopyLocal(DMXInputInfo *dmxInput,
d269 2
a270 2
extern void dmxChangePointerControl(DeviceIntPtr pDevice, PtrCtrl *ctrl);
extern void dmxKeyboardKbdCtrlProc(DeviceIntPtr pDevice, KeybdCtrl *ctrl);
d274 2
a275 2
extern int  dmxInputExtensionErrorHandler(Display *dsp, _Xconst char *name,
                                          _Xconst char *reason);
d277 3
a279 3
extern int          dmxInputDetach(DMXInputInfo *dmxInput);
extern void         dmxInputDetachAll(DMXScreenInfo *dmxScreen);
extern int          dmxInputDetachId(int id);
d281 2
a282 4
extern int          dmxInputAttachConsole(const char *name, int isCore,
                                          int *id);
extern int          dmxInputAttachBackend(int physicalScreen, int isCore,
                                          int *id);
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d279 2
a280 2
extern int  dmxInputExtensionErrorHandler(Display *dsp, char *name,
                                          char *reason);
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
a89 1
#ifdef XKB
a93 1
#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
@

