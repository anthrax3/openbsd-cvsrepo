head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.23.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.23.36;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.37;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 2002-2003 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Rickard E. (Rik) Faith <faith@@redhat.com>
 *
 */

/** \file
 * Provide support and helper functions for enqueing events received by
 * the low-level input drivers. */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#define DMX_EVENTS_DEBUG 0

#include "dmxinputinit.h"
#include "dmxevents.h"
#include "dmxcb.h"
#include "dmxcommon.h"
#include "dmxcursor.h"
#include "dmxmotion.h"
#include "dmxsigio.h"
#include "dmxmap.h"

#include <X11/keysym.h>
#include "opaque.h"
#include "inputstr.h"
#include "inpututils.h"
#include "mipointer.h"
#include "mi.h"
#include "exglobals.h"

#include "xkbsrv.h"
#include "XIstubs.h"

static int dmxGlobalX, dmxGlobalY;      /* Global cursor position */
static int dmxGlobalInvalid;    /* Flag indicating dmxCoreMotion
                                 * should move the mouse anyway. */

#if DMX_EVENTS_DEBUG
#define DMXDBG0(f)               dmxLog(dmxDebug,f)
#define DMXDBG1(f,a)             dmxLog(dmxDebug,f,a)
#define DMXDBG2(f,a,b)           dmxLog(dmxDebug,f,a,b)
#define DMXDBG3(f,a,b,c)         dmxLog(dmxDebug,f,a,b,c)
#define DMXDBG4(f,a,b,c,d)       dmxLog(dmxDebug,f,a,b,c,d)
#define DMXDBG5(f,a,b,c,d,e)     dmxLog(dmxDebug,f,a,b,c,d,e)
#define DMXDBG6(f,a,b,c,d,e,g)   dmxLog(dmxDebug,f,a,b,c,d,e,g)
#define DMXDBG7(f,a,b,c,d,e,g,h) dmxLog(dmxDebug,f,a,b,c,d,e,g,h)
#else
#define DMXDBG0(f)
#define DMXDBG1(f,a)
#define DMXDBG2(f,a,b)
#define DMXDBG3(f,a,b,c)
#define DMXDBG4(f,a,b,c,d)
#define DMXDBG5(f,a,b,c,d,e)
#define DMXDBG6(f,a,b,c,d,e,g)
#define DMXDBG7(f,a,b,c,d,e,g,h)
#endif

static int
dmxApplyFunctions(DMXInputInfo * dmxInput, DMXFunctionType f)
{
    int i;
    int rc = 0;

    for (i = 0; i < dmxInput->numDevs; i += dmxInput->devs[i]->binding)
        if (dmxInput->devs[i]->functions)
            rc += dmxInput->devs[i]->functions(dmxInput->devs[i]->private, f);
    return rc;
}

static int
dmxCheckFunctionKeys(DMXLocalInputInfoPtr dmxLocal, int type, KeySym keySym)
{
    DMXInputInfo *dmxInput = &dmxInputs[dmxLocal->inputIdx];

#if 1                           /* hack to detect ctrl-alt-q, etc */
    static int ctrl = 0, alt = 0;

    /* keep track of ctrl/alt key status */
    if (type == KeyPress && keySym == 0xffe3) {
        ctrl = 1;
    }
    else if (type == KeyRelease && keySym == 0xffe3) {
        ctrl = 0;
    }
    else if (type == KeyPress && keySym == 0xffe9) {
        alt = 1;
    }
    else if (type == KeyRelease && keySym == 0xffe9) {
        alt = 0;
    }
    if (!ctrl || !alt)
        return 0;
#else
    unsigned short state = 0;

    if (dmxLocal->sendsCore)
        state = dmxLocalCoreKeyboard->pDevice->key->state;
    else if (dmxLocal->pDevice->key)
        state = dmxLocal->pDevice->key->state;

    DMXDBG3("dmxCheckFunctionKeys: keySym=0x%04x %s state=0x%04x\n",
            keySym, type == KeyPress ? "press" : "release", state);

    if ((state & (ControlMask | Mod1Mask)) != (ControlMask | Mod1Mask))
        return 0;
#endif

    switch (keySym) {
    case XK_g:
        if (type == KeyPress)
            dmxApplyFunctions(dmxInput, DMX_FUNCTION_GRAB);
        return 1;
    case XK_f:
        if (type == KeyPress)
            dmxApplyFunctions(dmxInput, DMX_FUNCTION_FINE);
        return 1;
    case XK_q:
        if (type == KeyPress && dmxLocal->sendsCore)
            if (dmxApplyFunctions(dmxInput, DMX_FUNCTION_TERMINATE)) {
                dmxLog(dmxInfo, "User request for termination\n");
                dispatchException |= DE_TERMINATE;
            }
        return 1;
    }

    return 0;
}

DMXScreenInfo *
dmxFindFirstScreen(int x, int y)
{
    int i;

    for (i = 0; i < dmxNumScreens; i++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[i];

        if (dmxOnScreen(x, y, dmxScreen))
            return dmxScreen;
    }
    return NULL;
}

/**
 * Enqueue a motion event.
 */
static void
enqueueMotion(DevicePtr pDev, int x, int y)
{
    GETDMXLOCALFROMPDEV;
    DeviceIntPtr p = dmxLocal->pDevice;
    int valuators[3];
    int detail = 0;             /* XXX should this be mask of pressed buttons? */
    ValuatorMask mask;

    valuators[0] = x;
    valuators[1] = y;

    valuator_mask_set_range(&mask, 0, 2, valuators);
    QueuePointerEvents(p, MotionNotify, detail,
                       POINTER_ABSOLUTE | POINTER_SCREEN, &mask);
    return;
}

void
dmxCoreMotion(DevicePtr pDev, int x, int y, int delta, DMXBlockType block)
{
    DMXScreenInfo *dmxScreen;
    DMXInputInfo *dmxInput;
    ScreenPtr pScreen;
    int localX;
    int localY;
    int i;

    if (!dmxGlobalInvalid && dmxGlobalX == x && dmxGlobalY == y)
        return;

    DMXDBG5("dmxCoreMotion(%d,%d,%d) dmxGlobalX=%d dmxGlobalY=%d\n",
            x, y, delta, dmxGlobalX, dmxGlobalY);

    dmxGlobalInvalid = 0;
    dmxGlobalX = x;
    dmxGlobalY = y;

    if (dmxGlobalX < 0)
        dmxGlobalX = 0;
    if (dmxGlobalY < 0)
        dmxGlobalY = 0;
    if (dmxGlobalX >= dmxGlobalWidth)
        dmxGlobalX = dmxGlobalWidth + delta - 1;
    if (dmxGlobalY >= dmxGlobalHeight)
        dmxGlobalY = dmxGlobalHeight + delta - 1;

    if ((dmxScreen = dmxFindFirstScreen(dmxGlobalX, dmxGlobalY))) {
        localX = dmxGlobalX - dmxScreen->rootXOrigin;
        localY = dmxGlobalY - dmxScreen->rootYOrigin;
        if ((pScreen = miPointerGetScreen(inputInfo.pointer))
            && pScreen->myNum == dmxScreen->index) {
            /* Screen is old screen */
            if (block)
                OsBlockSIGIO();
            if (pDev)
                enqueueMotion(pDev, localX, localY);
            if (block)
                OsReleaseSIGIO();
        }
        else {
            /* Screen is new */
            DMXDBG4("   New screen: old=%d new=%d localX=%d localY=%d\n",
                    pScreen->myNum, dmxScreen->index, localX, localY);
            if (block)
                OsBlockSIGIO();
            mieqProcessInputEvents();
            miPointerSetScreen(inputInfo.pointer, dmxScreen->index,
                               localX, localY);
            if (pDev)
                enqueueMotion(pDev, localX, localY);
            if (block)
                OsReleaseSIGIO();
        }
#if 00
        miPointerGetPosition(inputInfo.pointer, &localX, &localY);

        if ((pScreen = miPointerGetScreen(inputInfo.pointer))) {
            dmxGlobalX = localX + dmxScreens[pScreen->myNum].rootXOrigin;
            dmxGlobalY = localY + dmxScreens[pScreen->myNum].rootYOrigin;
            ErrorF("Global is now %d, %d  %d, %d\n", dmxGlobalX, dmxGlobalY,
                   localX, localY);
            DMXDBG6("   Moved to dmxGlobalX=%d dmxGlobalY=%d"
                    " on screen index=%d/%d localX=%d localY=%d\n",
                    dmxGlobalX, dmxGlobalY,
                    dmxScreen ? dmxScreen->index : -1, pScreen->myNum,
                    localX, localY);
        }
#endif
    }
    /* Send updates down to all core input
     * drivers */
    for (i = 0, dmxInput = &dmxInputs[0]; i < dmxNumInputs; i++, dmxInput++) {
        int j;

        for (j = 0; j < dmxInput->numDevs; j += dmxInput->devs[j]->binding)
            if (!dmxInput->detached
                && dmxInput->devs[j]->sendsCore
                && dmxInput->devs[j]->update_position)
                dmxInput->devs[j]->update_position(dmxInput->devs[j]->private,
                                                   dmxGlobalX, dmxGlobalY);
    }
    if (!dmxScreen)
        ProcessInputEvents();
}

#define DMX_MAX_AXES 32         /* Max axes reported by this routine */
static void
dmxExtMotion(DMXLocalInputInfoPtr dmxLocal,
             int *v, int firstAxis, int axesCount,
             DMXMotionType type, DMXBlockType block)
{
    DeviceIntPtr pDevice = dmxLocal->pDevice;
    xEvent xE[2 * DMX_MAX_AXES / 6];
    deviceKeyButtonPointer *xev = (deviceKeyButtonPointer *) xE;
    deviceValuator *xv = (deviceValuator *) xev + 1;
    int thisX = 0;
    int thisY = 0;
    int count;
    ValuatorMask mask;

    memset(xE, 0, sizeof(xE));

    if (axesCount > DMX_MAX_AXES)
        axesCount = DMX_MAX_AXES;

    if ((valuator_get_mode(pDevice, 0) == Relative) && axesCount == 2) {
        /* The dmx console is a relative mode
         * device that sometimes reports
         * absolute motion.  It only has two
         * axes. */
        if (type == DMX_RELATIVE) {
            thisX = -v[0];
            thisY = -v[1];
            dmxLocal->lastX += thisX;
            dmxLocal->lastY += thisY;
            if (dmxLocal->update_position)
                dmxLocal->update_position(dmxLocal->private,
                                          dmxLocal->lastX, dmxLocal->lastY);
        }
        else {                  /* Convert to relative */
            if (dmxLocal->lastX || dmxLocal->lastY) {
                thisX = v[0] - dmxLocal->lastX;
                thisY = v[1] - dmxLocal->lastY;
            }
            dmxLocal->lastX = v[0];
            dmxLocal->lastY = v[1];
        }
        v[0] = thisX;
        v[1] = thisY;
    }

    if (axesCount <= 6) {
        /* Optimize for the common case when
         * only 1 or 2 axes change. */
        xev->time = GetTimeInMillis();
        xev->type = DeviceMotionNotify;
        xev->detail = 0;
        xev->deviceid = pDevice->id | MORE_EVENTS;

        xv->type = DeviceValuator;
        xv->deviceid = pDevice->id;
        xv->num_valuators = axesCount;
        xv->first_valuator = firstAxis;
        switch (xv->num_valuators) {
        case 6:
            xv->valuator5 = v[5];
        case 5:
            xv->valuator4 = v[4];
        case 4:
            xv->valuator3 = v[3];
        case 3:
            xv->valuator2 = v[2];
        case 2:
            xv->valuator1 = v[1];
        case 1:
            xv->valuator0 = v[0];
        }
        count = 2;
    }
    else {
        int i;

        for (i = 0, count = 0; i < axesCount; i += 6) {
            xev->time = GetTimeInMillis();
            xev->type = DeviceMotionNotify;
            xev->detail = 0;
            xev->deviceid = pDevice->id | MORE_EVENTS;
            xev += 2;

            xv->type = DeviceValuator;
            xv->deviceid = pDevice->id;
            xv->num_valuators = (i + 6 >= axesCount ? axesCount - i : 6);
            xv->first_valuator = firstAxis + i;
            switch (xv->num_valuators) {
            case 6:
                xv->valuator5 = v[i + 5];
            case 5:
                xv->valuator4 = v[i + 4];
            case 4:
                xv->valuator3 = v[i + 3];
            case 3:
                xv->valuator2 = v[i + 2];
            case 2:
                xv->valuator1 = v[i + 1];
            case 1:
                xv->valuator0 = v[i + 0];
            }
            xv += 2;
            count += 2;
        }
    }

    if (block)
        OsBlockSIGIO();
    valuator_mask_set_range(&mask, firstAxis, axesCount, v);
    QueuePointerEvents(pDevice, MotionNotify, 0, POINTER_ABSOLUTE, &mask);

    if (block)
        OsReleaseSIGIO();
}

static int
dmxTranslateAndEnqueueExtEvent(DMXLocalInputInfoPtr dmxLocal,
                               XEvent * e, DMXBlockType block)
{
    int type;
    int event = -1;
    XDeviceKeyEvent *ke = (XDeviceKeyEvent *) e;
    XDeviceMotionEvent *me = (XDeviceMotionEvent *) e;
    DeviceIntPtr pDevice = dmxLocal->pDevice;
    int valuators[MAX_VALUATORS];
    ValuatorMask mask;

    if (!e)
        return -1;              /* No extended event passed, cannot handle */

    if ((XID) dmxLocal->deviceId != ke->deviceid) {
        /* Search for the correct dmxLocal,
         * since backend and console events are
         * picked up for the first device on
         * that X server. */
        int i;
        DMXInputInfo *dmxInput = &dmxInputs[dmxLocal->inputIdx];

        for (i = 0; i < dmxInput->numDevs; i++) {
            dmxLocal = dmxInput->devs[i];
            if ((XID) dmxLocal->deviceId == ke->deviceid)
                break;
        }
    }

    if ((XID) dmxLocal->deviceId != ke->deviceid
        || (type = dmxMapLookup(dmxLocal, e->type)) < 0)
        return -1;              /* No mapping, so this event is unhandled */

    switch (type) {
    case XI_DeviceValuator:
        event = DeviceValuator;
        break;
    case XI_DeviceKeyPress:
        event = KeyPress;
        break;
    case XI_DeviceKeyRelease:
        event = KeyRelease;
        break;
    case XI_DeviceButtonPress:
        event = ButtonPress;
        break;
    case XI_DeviceButtonRelease:
        event = ButtonRelease;
        break;
    case XI_DeviceMotionNotify:
        event = MotionNotify;
        break;
    case XI_DeviceFocusIn:
        event = DeviceFocusIn;
        break;
    case XI_DeviceFocusOut:
        event = DeviceFocusOut;
        break;
    case XI_ProximityIn:
        event = ProximityIn;
        break;
    case XI_ProximityOut:
        event = ProximityOut;
        break;
    case XI_DeviceStateNotify:
        event = DeviceStateNotify;
        break;
    case XI_DeviceMappingNotify:
        event = DeviceMappingNotify;
        break;
    case XI_ChangeDeviceNotify:
        event = ChangeDeviceNotify;
        break;
    case XI_DeviceKeystateNotify:
        event = DeviceStateNotify;
        break;
    case XI_DeviceButtonstateNotify:
        event = DeviceStateNotify;
        break;
    }

#define EXTRACT_VALUATORS(ke, valuators) \
        valuators[0] = ke->axis_data[0]; \
        valuators[1] = ke->axis_data[1]; \
        valuators[2] = ke->axis_data[2]; \
        valuators[3] = ke->axis_data[3]; \
        valuators[4] = ke->axis_data[4]; \
        valuators[5] = ke->axis_data[5]; \

    switch (type) {
    case XI_DeviceKeyPress:
    case XI_DeviceKeyRelease:
        if (block)
            OsBlockSIGIO();
        QueueKeyboardEvents(pDevice, event, ke->keycode);
        if (block)
            OsReleaseSIGIO();
        break;
    case XI_DeviceButtonPress:
    case XI_DeviceButtonRelease:
        EXTRACT_VALUATORS(ke, valuators);
        valuator_mask_set_range(&mask, ke->first_axis, ke->axes_count,
                                valuators);
        if (block)
            OsBlockSIGIO();
        QueuePointerEvents(pDevice, event, ke->keycode,
                           POINTER_ABSOLUTE, &mask);
        if (block)
            OsReleaseSIGIO();
        break;
    case XI_ProximityIn:
    case XI_ProximityOut:
        EXTRACT_VALUATORS(ke, valuators);
        valuator_mask_set_range(&mask, ke->first_axis, ke->axes_count,
                                valuators);
        if (block)
            OsBlockSIGIO();
        QueueProximityEvents(pDevice, event, &mask);
        if (block)
            OsReleaseSIGIO();
        break;

        break;

    case XI_DeviceMotionNotify:
        dmxExtMotion(dmxLocal, me->axis_data, me->first_axis, me->axes_count,
                     DMX_ABSOLUTE, block);
        break;
    case XI_DeviceFocusIn:
    case XI_DeviceFocusOut:
    case XI_DeviceStateNotify:
    case XI_DeviceMappingNotify:
    case XI_ChangeDeviceNotify:
    case XI_DeviceKeystateNotify:
    case XI_DeviceButtonstateNotify:
        /* These are ignored, since DMX will
         * generate its own events of these
         * types, as necessary.

         * Perhaps ChangeDeviceNotify should
         * generate an error, because it is
         * unexpected? */
        break;
    case XI_DeviceValuator:
    default:
        dmxLog(dmxWarning,
               "XInput extension event (remote=%d -> zero-based=%d)"
               " not supported yet\n", e->type, type);
        return -1;
    }
    return 0;
}

static int
dmxGetButtonMapping(DMXLocalInputInfoPtr dmxLocal, int button)
{
    ButtonClassPtr b = dmxLocal->pDevice->button;

    if (button > b->numButtons) {       /* This shouldn't happen. */
        dmxLog(dmxWarning, "Button %d pressed, but only %d buttons?!?\n",
               button, b->numButtons);
        return button;
    }
    return b->map[button];
}

/** Return DMX's notion of the pointer position in the global coordinate
 * space. */
void
dmxGetGlobalPosition(int *x, int *y)
{
    *x = dmxGlobalX;
    *y = dmxGlobalY;
}

/** Invalidate the global position for #dmxCoreMotion. */
void
dmxInvalidateGlobalPosition(void)
{
    dmxGlobalInvalid = 1;
}

/** Enqueue a motion event for \a pDev.  The \a v vector has length \a
 * axesCount, and contains values for each of the axes, starting at \a
 * firstAxes.
 *
 * The \a type of the motion may be \a DMX_RELATIVE, \a DMX_ABSOLUTE, or
 * \a DMX_ABSOLUTE_CONFINED (in the latter case, the pointer will not be
 * allowed to move outside the global boundaires).
 *
 * If \a block is set to \a DMX_BLOCK, then the SIGIO handler will be
 * blocked around calls to \a enqueueMotion(). */
void
dmxMotion(DevicePtr pDev, int *v, int firstAxes, int axesCount,
          DMXMotionType type, DMXBlockType block)
{
    GETDMXLOCALFROMPDEV;

    if (!dmxLocal->sendsCore) {
        dmxExtMotion(dmxLocal, v, firstAxes, axesCount, type, block);
        return;
    }
    if (axesCount == 2) {
        switch (type) {
        case DMX_RELATIVE:
            dmxCoreMotion(pDev, dmxGlobalX - v[0], dmxGlobalY - v[1], 0, block);
            break;
        case DMX_ABSOLUTE:
            dmxCoreMotion(pDev, v[0], v[1], 0, block);
            break;
        case DMX_ABSOLUTE_CONFINED:
            dmxCoreMotion(pDev, v[0], v[1], -1, block);
            break;
        }
    }
}

static KeySym
dmxKeyCodeToKeySym(DMXLocalInputInfoPtr dmxLocal, KeyCode keyCode)
{
    KeySym keysym = NoSymbol;
    int effectiveGroup;
    XkbSrvInfoPtr xkbi;

    if (!dmxLocal || !dmxLocal->pDevice || !dmxLocal->pDevice->key)
        goto out;

    xkbi = dmxLocal->pDevice->key->xkbInfo;
    effectiveGroup = XkbGetEffectiveGroup(xkbi, &xkbi->state, keyCode);

    if (effectiveGroup == -1)
        goto out;

    keysym = XkbKeySym(xkbi->desc, keyCode, effectiveGroup);
    DMXDBG2("dmxKeyCodeToKeySym: Translated keyCode=%d to keySym=0x%04x\n",
            keyCode, keysym);

 out:
    return keysym;
}

static KeyCode
dmxKeySymToKeyCode(DMXLocalInputInfoPtr dmxLocal, KeySym keySym, int tryFirst)
{
    /* FIXME: this is quite ineffective, converting to a core map first and
     * then extracting the info from there. It'd be better to run the actual
     * xkb map */
    XkbSrvInfoPtr xkbi = dmxLocal->pDevice->key->xkbInfo;
    KeySymsPtr pKeySyms = XkbGetCoreMap(dmxLocal->pDevice);
    int i;

    /* Optimize for similar maps */
    if (XkbKeycodeInRange(xkbi->desc, tryFirst)
        && pKeySyms->map[(tryFirst - xkbi->desc->min_key_code)
                         * pKeySyms->mapWidth] == keySym)
        return tryFirst;

    for (i = pKeySyms->minKeyCode; i <= pKeySyms->maxKeyCode; i++) {
        if (pKeySyms->map[(i - pKeySyms->minKeyCode)
                          * pKeySyms->mapWidth] == keySym) {
            DMXDBG3("dmxKeySymToKeyCode: Translated keySym=0x%04x to"
                    " keyCode=%d (reverses to core keySym=0x%04x)\n",
                    keySym, i, dmxKeyCodeToKeySym(dmxLocalCoreKeyboard, i));
            return i;
        }
    }
    return 0;
}

static int
dmxFixup(DevicePtr pDev, int detail, KeySym keySym)
{
    GETDMXLOCALFROMPDEV;
    int keyCode;

    if (!dmxLocal->pDevice->key) {
        dmxLog(dmxWarning, "dmxFixup: not a keyboard device (%s)\n",
               dmxLocal->pDevice->name);
        return NoSymbol;
    }
    if (!keySym)
        keySym = dmxKeyCodeToKeySym(dmxLocal, detail);
    if (keySym == NoSymbol)
        return detail;
    keyCode = dmxKeySymToKeyCode(dmxLocalCoreKeyboard, keySym, detail);

    return keyCode ? keyCode : detail;
}

/** Enqueue an event from the \a pDev device with the
 * specified \a type and \a detail.  If the event is a KeyPress or
 * KeyRelease event, then the \a keySym is also specified.
 *
 * FIXME: make the code do what the comment says, or remove this comment.
 * If \a block is set to \a DMX_BLOCK, then the SIGIO handler will be
 * blocked around calls to dmxeqEnqueue(). */

void
dmxEnqueue(DevicePtr pDev, int type, int detail, KeySym keySym,
           XEvent * e, DMXBlockType block)
{
    GETDMXINPUTFROMPDEV;
    DeviceIntPtr p = dmxLocal->pDevice;
    int valuators[3];
    ValuatorMask mask;

    DMXDBG2("dmxEnqueue: Enqueuing type=%d detail=0x%0x\n", type, detail);

    switch (type) {
    case KeyPress:
    case KeyRelease:
        if (!keySym)
            keySym = dmxKeyCodeToKeySym(dmxLocal, detail);
        if (dmxCheckFunctionKeys(dmxLocal, type, keySym))
            return;
        if (dmxLocal->sendsCore && dmxLocal != dmxLocalCoreKeyboard)
            detail = dmxFixup(pDev, detail, keySym);

        /*ErrorF("KEY %d  sym %d\n", detail, (int) keySym); */
        QueueKeyboardEvents(p, type, detail);
        return;

    case ButtonPress:
    case ButtonRelease:
        detail = dmxGetButtonMapping(dmxLocal, detail);
        valuator_mask_zero(&mask);
        QueuePointerEvents(p, type, detail, 0, &mask);
        return;

    case MotionNotify:
        valuators[0] = e->xmotion.x;
        valuators[1] = e->xmotion.y;
        valuators[2] = e->xmotion.state;        /* FIXME: WTF?? */
        valuator_mask_set_range(&mask, 0, 3, valuators);
        QueuePointerEvents(p, type, detail,
                           POINTER_ABSOLUTE | POINTER_SCREEN, &mask);
        return;

    case EnterNotify:
    case LeaveNotify:
    case KeymapNotify:
    case MappingNotify:        /* This is sent because we change the
                                 * modifier map on the backend/console
                                 * input device so that we have complete
                                 * control of the input device LEDs. */
        return;
    default:
        if (type == ProximityIn || type == ProximityOut) {
            if (dmxLocal->sendsCore)
                return;         /* Not a core event */
            break;
        }
        if (type >= LASTEvent) {
            if (dmxTranslateAndEnqueueExtEvent(dmxLocal, e, block))
                dmxLogInput(dmxInput, "Unhandled extension event: %d\n", type);
        }
        else {
            dmxLogInput(dmxInput, "Unhandled event: %d (%s)\n",
                        type, dmxEventName(type));
        }
        return;
    }

}

/** A pointer to this routine is passed to low-level input drivers so
 * that all special keychecking is unified to this file.  This function
 * returns 0 if no special keys have been pressed.  If the user has
 * requested termination of the DMX server, -1 is returned.  If the user
 * has requested a switch to a VT, then the (1-based) number of that VT
 * is returned. */
int
dmxCheckSpecialKeys(DevicePtr pDev, KeySym keySym)
{
    GETDMXINPUTFROMPDEV;
    int vt = 0;
    unsigned short state = 0;

    if (dmxLocal->sendsCore)
        state =
            XkbStateFieldFromRec(&dmxLocalCoreKeyboard->pDevice->key->xkbInfo->
                                 state);
    else if (dmxLocal->pDevice->key)
        state = XkbStateFieldFromRec(&dmxLocal->pDevice->key->xkbInfo->state);

    if (!dmxLocal->sendsCore)
        return 0;               /* Only for core devices */

    DMXDBG2("dmxCheckSpecialKeys: keySym=0x%04x state=0x%04x\n", keySym, state);

    if ((state & (ControlMask | Mod1Mask)) != (ControlMask | Mod1Mask))
        return 0;

    switch (keySym) {
    case XK_F1:
    case XK_F2:
    case XK_F3:
    case XK_F4:
    case XK_F5:
    case XK_F6:
    case XK_F7:
    case XK_F8:
    case XK_F9:
    case XK_F10:
        vt = keySym - XK_F1 + 1;
        break;

    case XK_F11:
    case XK_F12:
        vt = keySym - XK_F11 + 11;
        break;

    case XK_q:                 /* To avoid confusion  */
    case XK_BackSpace:
    case XK_Delete:
    case XK_KP_Delete:
        dmxLog(dmxInfo, "User request for termination\n");
        dispatchException |= DE_TERMINATE;
        return -1;              /* Terminate */
    }

    if (vt) {
        dmxLog(dmxInfo, "Request to switch to VT %d\n", vt);
        dmxInput->vt_switch_pending = vt;
        return vt;
    }

    return 0;                   /* Do nothing */
}
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a490 3
        EXTRACT_VALUATORS(ke, valuators);
        valuator_mask_set_range(&mask, ke->first_axis, ke->axes_count,
                                valuators);
d493 1
a493 1
        QueueKeyboardEvents(pDevice, event, ke->keycode, &mask);
d718 1
a718 1
        QueueKeyboardEvents(p, type, detail, NULL);
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a703 1
    xEvent xE;
d718 1
a718 1
            xE.u.u.detail = dmxFixup(pDev, detail, keySym);
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d729 1
a729 2
        QueuePointerEvents(p, type, detail,
                           POINTER_ABSOLUTE | POINTER_SCREEN, &mask);
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d230 1
a230 1
                dmxSigioBlock();
d234 1
a234 1
                dmxSigioUnblock();
d241 1
a241 1
                dmxSigioBlock();
d248 1
a248 1
                dmxSigioUnblock();
d390 1
a390 1
        dmxSigioBlock();
d395 1
a395 1
        dmxSigioUnblock();
d495 1
a495 1
            dmxSigioBlock();
d498 1
a498 1
            dmxSigioUnblock();
d506 1
a506 1
            dmxSigioBlock();
d510 1
a510 1
            dmxSigioUnblock();
d518 1
a518 1
            dmxSigioBlock();
d521 1
a521 1
            dmxSigioUnblock();
@


1.4
log
@Update to xserver 1.11.2
@
text
@d64 3
a66 3
static int  dmxGlobalX, dmxGlobalY; /* Global cursor position */
static int  dmxGlobalInvalid;       /* Flag indicating dmxCoreMotion
                                     * should move the mouse anyway. */
d88 2
a89 1
static int dmxApplyFunctions(DMXInputInfo *dmxInput, DMXFunctionType f)
d94 1
a94 1
    for (i = 0; i < dmxInput->numDevs; i+= dmxInput->devs[i]->binding)
d100 2
a101 3
static int dmxCheckFunctionKeys(DMXLocalInputInfoPtr dmxLocal,
                                int type,
                                KeySym keySym)
d103 1
a103 1
    DMXInputInfo   *dmxInput = &dmxInputs[dmxLocal->inputIdx];
d105 1
a105 1
#if 1 /* hack to detect ctrl-alt-q, etc */
d107 1
d130 1
a130 1
    
d134 1
a134 1
    if ((state & (ControlMask|Mod1Mask)) != (ControlMask|Mod1Mask))
d155 1
a155 1
    
d159 2
a160 2

DMXScreenInfo *dmxFindFirstScreen(int x, int y)
d166 1
a172 1

d176 2
a177 1
static void enqueueMotion(DevicePtr pDev, int x, int y)
d182 1
a182 1
    int detail = 0;  /* XXX should this be mask of pressed buttons? */
d184 1
a193 1

d198 5
a202 5
    DMXInputInfo  *dmxInput;
    ScreenPtr     pScreen;
    int           localX;
    int           localY;
    int           i;
d206 1
a206 1
    
d211 2
a212 2
    dmxGlobalX       = x;
    dmxGlobalY       = y;
d219 1
a219 1
        dmxGlobalX = dmxGlobalWidth  + delta -1;
d221 2
a222 2
        dmxGlobalY = dmxGlobalHeight + delta -1;
    
d228 1
a228 1
                                /* Screen is old screen */
d232 1
a232 1
               enqueueMotion(pDev, localX, localY);
d235 3
a237 2
        } else {
                                /* Screen is new */
d246 1
a246 1
               enqueueMotion(pDev, localX, localY);
d266 2
a267 2
                                /* Send updates down to all core input
                                 * drivers */
d270 1
d278 2
a279 1
    if (!dmxScreen) ProcessInputEvents();
a281 2


d283 13
a295 12
static void dmxExtMotion(DMXLocalInputInfoPtr dmxLocal,
                         int *v, int firstAxis, int axesCount,
                         DMXMotionType type, DMXBlockType block)
{
    DeviceIntPtr           pDevice = dmxLocal->pDevice;
    xEvent                 xE[2 * DMX_MAX_AXES/6];
    deviceKeyButtonPointer *xev    = (deviceKeyButtonPointer *)xE;
    deviceValuator         *xv     = (deviceValuator *)xev+1;
    int                    thisX   = 0;
    int                    thisY   = 0;
    int                    count;
    ValuatorMask           mask;
d299 2
a300 1
    if (axesCount > DMX_MAX_AXES) axesCount = DMX_MAX_AXES;
d302 5
a306 5
    if ((valuator_get_mode(pDevice,0) == Relative) && axesCount == 2) {
                                /* The dmx console is a relative mode
                                 * device that sometimes reports
                                 * absolute motion.  It only has two
                                 * axes. */
d315 2
a316 1
        } else {                    /* Convert to relative */
d329 28
a356 21
                                /* Optimize for the common case when
                                 * only 1 or 2 axes change. */
            xev->time          = GetTimeInMillis();
            xev->type          = DeviceMotionNotify;
            xev->detail        = 0;
            xev->deviceid      = pDevice->id | MORE_EVENTS;
            
            xv->type           = DeviceValuator;
            xv->deviceid       = pDevice->id;
            xv->num_valuators  = axesCount;
            xv->first_valuator = firstAxis;
            switch (xv->num_valuators) {
            case 6: xv->valuator5 = v[5];
            case 5: xv->valuator4 = v[4];
            case 4: xv->valuator3 = v[3];
            case 3: xv->valuator2 = v[2];
            case 2: xv->valuator1 = v[1];
            case 1: xv->valuator0 = v[0];
            }
            count              = 2;
    } else {
d358 1
d360 9
a368 9
            xev->time          = GetTimeInMillis();
            xev->type          = DeviceMotionNotify;
            xev->detail        = 0;
            xev->deviceid      = pDevice->id | MORE_EVENTS;
            xev               += 2;
            
            xv->type           = DeviceValuator;
            xv->deviceid       = pDevice->id;
            xv->num_valuators  = (i+6 >= axesCount ? axesCount - i : 6);
d371 12
a382 6
            case 6: xv->valuator5 = v[i+5];
            case 5: xv->valuator4 = v[i+4];
            case 4: xv->valuator3 = v[i+3];
            case 3: xv->valuator2 = v[i+2];
            case 2: xv->valuator1 = v[i+1];
            case 1: xv->valuator0 = v[i+0];
d384 2
a385 2
            xv                += 2;
            count             += 2;
d392 1
a392 2
    QueuePointerEvents(pDevice, MotionNotify, 0,
                       POINTER_ABSOLUTE, &mask);
d398 11
a408 10
static int dmxTranslateAndEnqueueExtEvent(DMXLocalInputInfoPtr dmxLocal,
                                          XEvent *e, DMXBlockType block)
{
    int                    type;
    int                    event   = -1;
    XDeviceKeyEvent        *ke     = (XDeviceKeyEvent *)e;
    XDeviceMotionEvent     *me     = (XDeviceMotionEvent *)e;
    DeviceIntPtr           pDevice = dmxLocal->pDevice;
    int                    valuators[MAX_VALUATORS];
    ValuatorMask           mask;
d411 1
a411 1
        return -1;          /* No extended event passed, cannot handle */
d413 5
a417 5
    if ((XID)dmxLocal->deviceId != ke->deviceid) {
                                /* Search for the correct dmxLocal,
                                 * since backend and console events are
                                 * picked up for the first device on
                                 * that X server. */
d420 1
d423 1
a423 1
            if ((XID)dmxLocal->deviceId == ke->deviceid)
d428 1
a428 1
    if ((XID)dmxLocal->deviceId != ke->deviceid
d430 1
a430 1
        return -1;    /* No mapping, so this event is unhandled */
d433 45
a477 15
    case XI_DeviceValuator:          event = DeviceValuator;          break;
    case XI_DeviceKeyPress:          event = KeyPress;                break;
    case XI_DeviceKeyRelease:        event = KeyRelease;              break;
    case XI_DeviceButtonPress:       event = ButtonPress;             break;
    case XI_DeviceButtonRelease:     event = ButtonRelease;           break;
    case XI_DeviceMotionNotify:      event = MotionNotify;            break;
    case XI_DeviceFocusIn:           event = DeviceFocusIn;           break;
    case XI_DeviceFocusOut:          event = DeviceFocusOut;          break;
    case XI_ProximityIn:             event = ProximityIn;             break;
    case XI_ProximityOut:            event = ProximityOut;            break;
    case XI_DeviceStateNotify:       event = DeviceStateNotify;       break;
    case XI_DeviceMappingNotify:     event = DeviceMappingNotify;     break;
    case XI_ChangeDeviceNotify:      event = ChangeDeviceNotify;      break;
    case XI_DeviceKeystateNotify:    event = DeviceStateNotify;       break;
    case XI_DeviceButtonstateNotify: event = DeviceStateNotify;       break;
d492 2
a493 1
        valuator_mask_set_range(&mask, ke->first_axis, ke->axes_count, valuators);
d503 2
a504 1
        valuator_mask_set_range(&mask, ke->first_axis, ke->axes_count, valuators);
d515 2
a516 1
        valuator_mask_set_range(&mask, ke->first_axis, ke->axes_count, valuators);
d537 7
a543 7
                                /* These are ignored, since DMX will
                                 * generate its own events of these
                                 * types, as necessary.

                                 * Perhaps ChangeDeviceNotify should
                                 * generate an error, because it is
                                 * unexpected? */
d555 2
a556 1
static int dmxGetButtonMapping(DMXLocalInputInfoPtr dmxLocal, int button)
d560 1
a560 1
    if (button > b->numButtons) { /* This shouldn't happen. */
d570 2
a571 1
void dmxGetGlobalPosition(int *x, int *y)
d578 2
a579 1
void dmxInvalidateGlobalPosition(void)
d594 3
a596 2
void dmxMotion(DevicePtr pDev, int *v, int firstAxes, int axesCount,
               DMXMotionType type, DMXBlockType block)
d619 2
a620 2
static KeySym dmxKeyCodeToKeySym(DMXLocalInputInfoPtr dmxLocal,
                                 KeyCode keyCode)
d639 1
a639 1
out:
d643 2
a644 2
static KeyCode dmxKeySymToKeyCode(DMXLocalInputInfoPtr dmxLocal, KeySym keySym,
                                  int tryFirst)
d651 1
a651 1
    int        i;
d653 1
a653 1
                                /* Optimize for similar maps */
d664 1
a664 1
                    keySym, i, dmxKeyCodeToKeySym(dmxLocalCoreKeyboard,i));
d671 2
a672 1
static int dmxFixup(DevicePtr pDev, int detail, KeySym keySym)
d676 1
a676 1
    
d698 4
a701 3
    
void dmxEnqueue(DevicePtr pDev, int type, int detail, KeySym keySym,
                XEvent *e, DMXBlockType block)
d721 1
a721 1
        /*ErrorF("KEY %d  sym %d\n", detail, (int) keySym);*/
d736 1
a736 1
        valuators[2] = e->xmotion.state; /* FIXME: WTF?? */
d745 1
a745 1
    case MappingNotify:         /* This is sent because we change the
d753 1
a753 1
                return; /* Not a core event */
d759 2
a760 1
        } else {
d775 2
a776 1
int dmxCheckSpecialKeys(DevicePtr pDev, KeySym keySym)
d779 1
a779 1
    int            vt    = 0;
d783 3
a785 1
        state = XkbStateFieldFromRec(&dmxLocalCoreKeyboard->pDevice->key->xkbInfo->state);
d789 7
a795 1
    if (!dmxLocal->sendsCore) return 0; /* Only for core devices */
a796 4
    DMXDBG2("dmxCheckSpecialKeys: keySym=0x%04x state=0x%04x\n", keySym,state);
    
    if ((state & (ControlMask|Mod1Mask)) != (ControlMask|Mod1Mask)) return 0;
    
d816 1
a816 1
    case XK_q:                  /* To avoid confusion  */
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d56 1
d179 1
a179 2
    int i, nevents, valuators[3];
    EventListPtr events;
d181 1
d185 3
a187 5
    GetEventList(&events);
    nevents = GetPointerEvents(events, p, MotionNotify, detail,
                               POINTER_ABSOLUTE | POINTER_SCREEN, 0, 2, valuators);
    for (i = 0; i < nevents; i++)
       mieqEnqueue(p, (InternalEvent*)(events + i)->event);
a289 1
    int                    i;
d291 1
a291 2
    EventListPtr           events;
    int                    nevents;
d297 1
a297 1
    if (!pDevice->valuator->mode && axesCount == 2) {
d344 1
d371 3
a373 5
    GetEventList(&events);
    nevents = GetPointerEvents(events, pDevice, MotionNotify, 0, POINTER_ABSOLUTE,
                               firstAxis, axesCount, v);
    for (i = 0; i < nevents; i++)
        mieqEnqueue(pDevice, (InternalEvent*)(events + i)->event);
d387 2
a388 3
    int                    valuators[6];
    EventListPtr           events;
    int                    nevents, i;
d392 1
a392 1
    
d430 6
a435 6
        valuators[0]       = ke->axis_data[0]; \
        valuators[1]       = ke->axis_data[1]; \
        valuators[2]       = ke->axis_data[2]; \
        valuators[3]       = ke->axis_data[3]; \
        valuators[4]       = ke->axis_data[4]; \
        valuators[5]       = ke->axis_data[5]; \
d441 1
d444 1
a444 7
        GetEventList(&events);
        nevents = GetKeyboardValuatorEvents(events, pDevice, event,
                                            ke->keycode, ke->first_axis,
                                            ke->axes_count, valuators);
        for (i = 0; i < nevents; i++)
            mieqEnqueue(pDevice, (InternalEvent*)(events + i)->event);

d451 1
d454 2
a455 7
        GetEventList(&events);
        nevents = GetPointerEvents(events, pDevice, event, ke->keycode,
                                   POINTER_ABSOLUTE, ke->first_axis,
                                   ke->axes_count, valuators);
        for (i = 0; i < nevents; i++)
            mieqEnqueue(pDevice, (InternalEvent*)(events + i)->event);

d462 1
d465 1
a465 7
        GetEventList(&events);
        nevents = GetProximityEvents(events, pDevice, event,
                                     ke->first_axis, ke->axes_count,
                                     valuators);
        for (i = 0; i < nevents; i++)
            mieqEnqueue(pDevice, (InternalEvent*)(events + i)->event);

d646 2
a647 2
    int i, nevents, valuators[3];
    EventListPtr events;
a660 1
        GetEventList(&events);
d662 1
a662 3
        nevents = GetKeyboardEvents(events, p, type, detail);
        for (i = 0; i < nevents; i++)
            mieqEnqueue(p, (InternalEvent*)(events + i)->event);
d668 3
a670 8
        GetEventList(&events);
        nevents = GetPointerEvents(events, p, type, detail,
                                   POINTER_ABSOLUTE | POINTER_SCREEN,
                                   0,   /* first_valuator = 0 */
                                   0,   /* num_valuators = 0 */
                                   valuators);
        for (i = 0; i < nevents; i++)
            mieqEnqueue(p, (InternalEvent*)(events + i)->event);
a673 1
        GetEventList(&events);
d677 3
a679 4
        nevents = GetPointerEvents(events, p, type, detail, 
                                   POINTER_ABSOLUTE | POINTER_SCREEN, 0, 3, valuators);
        for (i = 0; i < nevents; i++)
            mieqEnqueue(p, (InternalEvent*)(events + i)->event);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a49 1
#include "dmxeq.h"
d58 1
d60 1
a102 1
    unsigned short state = 0;
d122 2
a156 53
static void dmxEnqueueExtEvent(DMXLocalInputInfoPtr dmxLocal, xEvent *e,
                               DMXBlockType block)
{
    xEvent                 xE[2];
    deviceKeyButtonPointer *xev      = (deviceKeyButtonPointer *)xE;
    deviceValuator         *xv       = (deviceValuator *)xev+1;
    DeviceIntPtr           pDevice   = dmxLocal->pDevice;
    DMXInputInfo           *dmxInput = &dmxInputs[dmxLocal->inputIdx];
    int                    type      = e->u.u.type;

    switch (e->u.u.type) {
    case KeyPress:
        type = DeviceKeyPress;
        break;
    case KeyRelease:
        type = DeviceKeyRelease;
        break;
    case ButtonPress:
        type = DeviceButtonPress;
        break;
    case ButtonRelease:
        type = DeviceButtonRelease;
        break;
    case MotionNotify:
        dmxLog(dmxError,
               "dmxEnqueueExtEvent: MotionNotify not allowed here\n");
        return;
    default:
        if (e->u.u.type == ProximityIn || e->u.u.type == ProximityOut)
            break;
        dmxLogInput(dmxInput,
                    "dmxEnqueueExtEvent: Unhandled %s event (%d)\n",
                    e->u.u.type >= LASTEvent ? "extension" : "non-extension",
                    e->u.u.type);
        return;
    }

    xev->type          = type;
    xev->detail        = e->u.u.detail;
    xev->deviceid      = pDevice->id | MORE_EVENTS;
    xev->time          = e->u.keyButtonPointer.time;

    xv->type           = DeviceValuator;
    xv->deviceid       = pDevice->id;
    xv->num_valuators  = 0;
    xv->first_valuator = 0;

    if (block)
        dmxSigioBlock();
    dmxeqEnqueue(pDevice, xE);
    if (block)
        dmxSigioUnblock();
}
d186 1
a186 1
                               POINTER_ABSOLUTE, 0, 2, valuators);
d188 1
a188 1
       mieqEnqueue(p, (events + i)->event);
d240 1
a240 1
            dmxeqProcessInputEvents();
d293 2
d373 6
a378 2
    dmxPointerPutMotionEvent(pDevice, firstAxis, axesCount, v, xev->time);
    dmxeqEnqueue(pDevice, xE);
a385 3
    xEvent                 xE[2];
    deviceKeyButtonPointer *xev    = (deviceKeyButtonPointer *)xE;
    deviceValuator         *xv     = (deviceValuator *)xev+1;
d391 3
d418 5
a422 5
    case XI_DeviceKeyPress:          event = DeviceKeyPress;          break;
    case XI_DeviceKeyRelease:        event = DeviceKeyRelease;        break;
    case XI_DeviceButtonPress:       event = DeviceButtonPress;       break;
    case XI_DeviceButtonRelease:     event = DeviceButtonRelease;     break;
    case XI_DeviceMotionNotify:      event = DeviceMotionNotify;      break;
d434 8
d443 1
a443 1
    case XI_DeviceKeyPress: 
d445 13
d460 13
d475 1
a475 16
        xev->type          = event;
        xev->detail        = ke->keycode; /* same as ->button */
        xev->deviceid      = dmxLocal->pDevice->id | MORE_EVENTS;
        xev->time          = GetTimeInMillis();

        xv->type           = DeviceValuator;
        xv->deviceid       = dmxLocal->pDevice->id;
        xv->num_valuators  = ke->axes_count;
        xv->first_valuator = ke->first_axis;
        xv->valuator0      = ke->axis_data[0];
        xv->valuator1      = ke->axis_data[1];
        xv->valuator2      = ke->axis_data[2];
        xv->valuator3      = ke->axis_data[3];
        xv->valuator4      = ke->axis_data[4];
        xv->valuator5      = ke->axis_data[5];

d478 7
a484 1
        dmxeqEnqueue(pDevice, xE);
d489 2
d555 1
a555 1
 * blocked around calls to #dmxeqEnqueue(). */
d583 3
a585 1
    KeySymsPtr pKeySyms = NULL;
d588 14
a601 15
        return NoSymbol;
    pKeySyms = &dmxLocal->pDevice->key->curKeySyms;
    if (!pKeySyms)
        return NoSymbol;
    
    if (keyCode > pKeySyms->minKeyCode && keyCode <= pKeySyms->maxKeyCode) {
        DMXDBG2("dmxKeyCodeToKeySym: Translated keyCode=%d to keySym=0x%04x\n",
                keyCode,
                pKeySyms->map[(keyCode - pKeySyms->minKeyCode)
                              * pKeySyms->mapWidth]);
               
        return pKeySyms->map[(keyCode - pKeySyms->minKeyCode)
                             * pKeySyms->mapWidth];
    }
    return NoSymbol;
d607 5
a611 1
    KeySymsPtr pKeySyms = &dmxLocal->pDevice->key->curKeySyms;
d615 2
a616 3
    if (tryFirst >= pKeySyms->minKeyCode
        && tryFirst <= pKeySyms->maxKeyCode
        && pKeySyms->map[(tryFirst - pKeySyms->minKeyCode)
d655 1
d657 1
a657 1
 * blocked around calls to #dmxeqEnqueue(). */
d684 1
a684 1
            mieqEnqueue(p, (events + i)->event);
d692 1
a692 1
                                   POINTER_ABSOLUTE,
d697 1
a697 1
            mieqEnqueue(p, (events + i)->event);
d704 1
a704 1
        valuators[2] = e->xmotion.state;
d706 1
a706 1
                                   POINTER_ABSOLUTE, 0, 3, valuators);
d708 1
a708 1
            mieqEnqueue(p, (events + i)->event);
a734 11
#if 00 /* dead code? */
    memset(&xE, 0, sizeof(xE));
    xE.u.u.type                = type;
    xE.u.u.detail              = detail;
    xE.u.keyButtonPointer.time = GetTimeInMillis();

    if (!dmxLocal->sendsCore)
        dmxEnqueueExtEvent(dmxLocal, &xE, block);
    else
        dmxeqEnqueue(&xE);
#endif /*00*/
d750 1
a750 1
        state = dmxLocalCoreKeyboard->pDevice->key->state;
d752 1
a752 1
        state = dmxLocal->pDevice->key->state;
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
d58 1
a59 1
#ifdef XINPUT
a60 1
#endif
d103 19
a121 1
    
d130 3
a132 1
    if ((state & (ControlMask|Mod1Mask)) != (ControlMask|Mod1Mask)) return 0;
a154 1
#ifdef XINPUT
d166 12
a177 4
    case KeyPress:      type = DeviceKeyPress;      break;
    case KeyRelease:    type = DeviceKeyRelease;    break;
    case ButtonPress:   type = DeviceButtonPress;   break;
    case ButtonRelease: type = DeviceButtonRelease; break;
d183 2
a184 1
        if (e->u.u.type == ProximityIn || e->u.u.type == ProximityOut) break;
d202 5
a206 3
    if (block) dmxSigioBlock();
    dmxeqEnqueue(xE);
    if (block) dmxSigioUnblock();
a207 1
#endif
d215 2
a216 1
        if (dmxOnScreen(x, y, dmxScreen)) return dmxScreen;
d221 25
a245 1
void dmxCoreMotion(int x, int y, int delta, DMXBlockType block)
d254 2
a255 1
    if (!dmxGlobalInvalid && dmxGlobalX == x && dmxGlobalY == y) return;
d264 8
a271 4
    if (dmxGlobalX < 0)                dmxGlobalX = 0;
    if (dmxGlobalY < 0)                dmxGlobalY = 0;
    if (dmxGlobalX >= dmxGlobalWidth)  dmxGlobalX = dmxGlobalWidth  + delta -1;
    if (dmxGlobalY >= dmxGlobalHeight) dmxGlobalY = dmxGlobalHeight + delta -1;
d276 1
a276 1
        if ((pScreen = miPointerCurrentScreen())
d279 6
a284 3
            if (block) dmxSigioBlock();
            miPointerAbsoluteCursor(localX, localY, GetTimeInMillis());
            if (block) dmxSigioUnblock();
d289 2
a290 1
            if (block) dmxSigioBlock();
d292 6
a297 3
            miPointerSetNewScreen(dmxScreen->index, localX, localY);
            miPointerAbsoluteCursor(localX, localY, GetTimeInMillis());
            if (block) dmxSigioUnblock();
d299 2
a300 1
        miPointerPosition(&localX, &localY);
d302 1
a302 1
        if ((pScreen = miPointerCurrentScreen())) {
d305 2
d313 1
a318 1

d329 2
a330 1
#ifdef XINPUT
d420 2
a421 1
    if (block) dmxSigioBlock();
d423 3
a425 2
    dmxeqEnqueue(xE);
    if (block) dmxSigioUnblock();
d438 1
d440 2
a441 1
    if (!e) return -1;          /* No extended event passed, cannot handle */
d452 2
a453 1
            if ((XID)dmxLocal->deviceId == ke->deviceid) break;
d502 5
a506 3
        if (block) dmxSigioBlock();
        dmxeqEnqueue(xE);
        if (block) dmxSigioUnblock();
a536 1
#endif
a576 1
#ifdef XINPUT
d583 12
a594 7
#endif
    if (axesCount == 2) switch (type) {
      case DMX_RELATIVE:          dmxCoreMotion(dmxGlobalX - v[0],
                                                dmxGlobalY - v[1],
                                                0, block);              break;
      case DMX_ABSOLUTE:          dmxCoreMotion(v[0], v[1], 0, block);  break;
      case DMX_ABSOLUTE_CONFINED: dmxCoreMotion(v[0], v[1], -1, block); break;
d606 2
a607 1
    if (!pKeySyms) return NoSymbol;
d656 4
a659 2
    if (!keySym) keySym = dmxKeyCodeToKeySym(dmxLocal, detail);
    if (keySym == NoSymbol) return detail;
d665 1
a665 1
/** Enqueue a non-motion event from the \a pDev device with the
d677 3
d686 2
a687 1
        if (!keySym) keySym = dmxKeyCodeToKeySym(dmxLocal, detail);
d692 8
a699 1
        break;
d703 10
a712 1
        break;
d714 10
a723 6
        /* All MotionNotify events should be sent via dmxCoreMotion and
         * dmxExtMotion -- no input driver should build motion events by
         * hand. */
        dmxLog(dmxError, "dmxEnqueueXEvent: MotionNotify not allowed here\n");
        break;
                                /* Always ignore these events */
a732 1
#ifdef XINPUT
d734 2
a735 1
            if (dmxLocal->sendsCore) return; /* Not a core event */
a737 1
#endif
a738 1
#ifdef XINPUT
a739 1
#endif
d748 1
d754 2
a755 2
#ifdef XINPUT
    if (!dmxLocal->sendsCore) dmxEnqueueExtEvent(dmxLocal, &xE, block);
a756 1
#endif
d758 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
a58 1
#include "mi.h"
d105 1
a105 19

#if 1 /* hack to detect ctrl-alt-q, etc */
    static int ctrl = 0, alt = 0;
    /* keep track of ctrl/alt key status */
    if (type == KeyPress && keySym == 0xffe3) {
        ctrl = 1;
    }
    else if (type == KeyRelease && keySym == 0xffe3) {
        ctrl = 0;
    }
    else if (type == KeyPress && keySym == 0xffe9) {
        alt = 1;
    }
    else if (type == KeyRelease && keySym == 0xffe9) {
        alt = 0;
    }
    if (!ctrl || !alt)
        return 0;
#else
d114 1
a114 3
    if ((state & (ControlMask|Mod1Mask)) != (ControlMask|Mod1Mask))
        return 0;
#endif
d149 4
a152 12
    case KeyPress:
        type = DeviceKeyPress;
        break;
    case KeyRelease:
        type = DeviceKeyRelease;
        break;
    case ButtonPress:
        type = DeviceButtonPress;
        break;
    case ButtonRelease:
        type = DeviceButtonRelease;
        break;
d158 1
a158 2
        if (e->u.u.type == ProximityIn || e->u.u.type == ProximityOut)
            break;
d176 1
a176 2
    if (block)
        dmxSigioBlock();
d178 1
a178 2
    if (block)
        dmxSigioUnblock();
d188 1
a188 2
        if (dmxOnScreen(x, y, dmxScreen))
            return dmxScreen;
d193 1
a193 24

/**
 * Enqueue a motion event.
 */
static void enqueueMotion(DevicePtr pDev, int x, int y)
{
    GETDMXLOCALFROMPDEV;
    DeviceIntPtr p = dmxLocal->pDevice;
    int i, nevents, valuators[3];
    xEvent *events = Xcalloc(sizeof(xEvent), GetMaximumEventsNum());
    int detail = 0;  /* XXX should this be mask of pressed buttons? */
    valuators[0] = x;
    valuators[1] = y;
    nevents = GetPointerEvents(events, p, MotionNotify, detail,
                               POINTER_ABSOLUTE, 0, 2, valuators);
    for (i = 0; i < nevents; i++)
       mieqEnqueue(p, events + i);
    xfree(events);
    return;
}


void
dmxCoreMotion(DevicePtr pDev, int x, int y, int delta, DMXBlockType block)
d202 1
a202 2
    if (!dmxGlobalInvalid && dmxGlobalX == x && dmxGlobalY == y)
        return;
d211 4
a214 8
    if (dmxGlobalX < 0)
        dmxGlobalX = 0;
    if (dmxGlobalY < 0)
        dmxGlobalY = 0;
    if (dmxGlobalX >= dmxGlobalWidth)
        dmxGlobalX = dmxGlobalWidth  + delta -1;
    if (dmxGlobalY >= dmxGlobalHeight)
        dmxGlobalY = dmxGlobalHeight + delta -1;
d219 1
a219 1
        if ((pScreen = miPointerGetScreen(inputInfo.pointer))
d222 3
a224 6
            if (block)
                dmxSigioBlock();
            if (pDev)
               enqueueMotion(pDev, localX, localY);
            if (block)
                dmxSigioUnblock();
d229 1
a229 2
            if (block)
                dmxSigioBlock();
d231 3
a233 6
            miPointerSetScreen(inputInfo.pointer, dmxScreen->index,
                               localX, localY);
            if (pDev)
               enqueueMotion(pDev, localX, localY);
            if (block)
                dmxSigioUnblock();
d235 1
a235 2
#if 00
        miPointerGetPosition(inputInfo.pointer, &localX, &localY);
d237 1
a237 1
        if ((pScreen = miPointerGetScreen(inputInfo.pointer))) {
a239 2
            ErrorF("Global is now %d, %d  %d, %d\n", dmxGlobalX, dmxGlobalY,
                   localX, localY);
a245 1
#endif
d251 1
a261 2


d352 1
a352 2
    if (block)
        dmxSigioBlock();
d355 1
a355 2
    if (block)
        dmxSigioUnblock();
d369 1
a369 2
    if (!e)
        return -1;          /* No extended event passed, cannot handle */
d380 1
a380 2
            if ((XID)dmxLocal->deviceId == ke->deviceid)
                break;
d429 1
a429 2
        if (block)
            dmxSigioBlock();
d431 1
a431 2
        if (block)
            dmxSigioUnblock();
d511 6
a516 12
    if (axesCount == 2) {
        switch (type) {
        case DMX_RELATIVE:
            dmxCoreMotion(pDev, dmxGlobalX - v[0], dmxGlobalY - v[1], 0, block);
            break;
        case DMX_ABSOLUTE:
            dmxCoreMotion(pDev, v[0], v[1], 0, block);
            break;
        case DMX_ABSOLUTE_CONFINED:
            dmxCoreMotion(pDev, v[0], v[1], -1, block);
            break;
        }
d528 1
a528 2
    if (!pKeySyms)
        return NoSymbol;
d577 2
a578 4
    if (!keySym)
        keySym = dmxKeyCodeToKeySym(dmxLocal, detail);
    if (keySym == NoSymbol)
        return detail;
d584 1
a584 1
/** Enqueue an event from the \a pDev device with the
a595 3
    DeviceIntPtr p = dmxLocal->pDevice;
    int i, nevents, valuators[3];
    xEvent *events;
d602 1
a602 2
        if (!keySym)
            keySym = dmxKeyCodeToKeySym(dmxLocal, detail);
d607 1
a607 9

        events = Xcalloc(sizeof(xEvent), GetMaximumEventsNum());
        /*ErrorF("KEY %d  sym %d\n", detail, (int) keySym);*/
        nevents = GetKeyboardEvents(events, p, type, detail);
        for (i = 0; i < nevents; i++)
            mieqEnqueue(p, events + i);
        xfree(events);
        return;

d611 1
a611 11
        events = Xcalloc(sizeof(xEvent), GetMaximumEventsNum());
        nevents = GetPointerEvents(events, p, type, detail,
                                   POINTER_ABSOLUTE,
                                   0,   /* first_valuator = 0 */
                                   0,   /* num_valuators = 0 */
                                   valuators);
        for (i = 0; i < nevents; i++)
            mieqEnqueue(p, events + i);
        xfree(events);
        return;

d613 6
a618 11
        events = Xcalloc(sizeof(xEvent), GetMaximumEventsNum());
        valuators[0] = e->xmotion.x;
        valuators[1] = e->xmotion.y;
        valuators[2] = e->xmotion.state;
        nevents = GetPointerEvents(events, p, type, detail, 
                                   POINTER_ABSOLUTE, 0, 3, valuators);
        for (i = 0; i < nevents; i++)
            mieqEnqueue(p, events + i);
        xfree(events);
        return;

d630 1
a630 2
            if (dmxLocal->sendsCore)
                return; /* Not a core event */
a645 1
#if 00 /* dead code? */
d652 1
a652 2
    if (!dmxLocal->sendsCore)
        dmxEnqueueExtEvent(dmxLocal, &xE, block);
a655 1
#endif /*00*/
@

