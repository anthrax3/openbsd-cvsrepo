head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.12
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.10
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.8
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.6
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.27;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.46;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.46;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.24;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright 2002, 2003 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Rickard E. (Rik) Faith <faith@@redhat.com>
 *
 */

/** \file
 *
 * The DMX server code is written to call #dmxSync() whenever an XSync()
 * might be necessary.  However, since XSync() requires a two way
 * communication with the other X server, eliminating unnecessary
 * XSync() calls is a key performance optimization.  Support for this
 * optimization is provided in \a dmxsync.c.  This file provides routines
 * that evaluate this optimization by counting the number of XSync()
 * calls and monitoring their latency.  This functionality can be turned
 * on using the -stat command-line parameter. */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include "dmx.h"
#include "dmxstat.h"
#include "dmxlog.h"
#include <X11/Xos.h>            /* For sys/time.h */

/** Used to compute a running average of value. */
typedef struct _DMXStatAvg {
    int pos;
    int count;
    unsigned long value[DMX_STAT_LENGTH];
} DMXStatAvg;

/** Statistical information about XSync calls. */
struct _DMXStatInfo {
    unsigned long syncCount;
    unsigned long oldSyncCount;

    DMXStatAvg usec;
    DMXStatAvg pending;

    unsigned long bins[DMX_STAT_BINS];
};

/* Interval in mS between statistic message log entries. */
int dmxStatInterval;
static int dmxStatDisplays;
static OsTimerPtr dmxStatTimer;

/** Return the number of microseconds as an unsigned long.
 * Unfortunately, this is only useful for intervals < about 4 sec.  */
static unsigned long
usec(struct timeval *stop, struct timeval *start)
{
    return (stop->tv_sec - start->tv_sec) * 1000000
        + stop->tv_usec - start->tv_usec;
}

static unsigned long
avg(DMXStatAvg * data, unsigned long *max)
{
    unsigned long sum;
    int i;

    *max = 0;
    if (!data->count)
        return 0;

    for (i = 0, sum = 0; i < data->count; i++) {
        if (data->value[i] > *max)
            *max = data->value[i];
        sum += data->value[i];
    }
    return sum / data->count;
}

/** Turn on XSync statistic gathering and printing.  Print every \a
 * interval seconds, with lines for the first \a displays.  If \a
 * interval is NULL, 1 will be used.  If \a displays is NULL, 0 will be
 * used (meaning a line for every display will be printed).  Note that
 * this function takes string arguments because it will usually be
 * called from #ddxProcessArgument in \a dmxinit.c. */
void
dmxStatActivate(const char *interval, const char *displays)
{
    dmxStatInterval = (interval ? atoi(interval) : 1) * 1000;
    dmxStatDisplays = (displays ? atoi(displays) : 0);

    if (dmxStatInterval < 1000)
        dmxStatInterval = 1000;
    if (dmxStatDisplays < 0)
        dmxStatDisplays = 0;
}

/** Allocate a \a DMXStatInfo structure. */
DMXStatInfo *
dmxStatAlloc(void)
{
    DMXStatInfo *pt = calloc(1, sizeof(*pt));

    return pt;
}

/** Free the memory used by a \a DMXStatInfo structure. */
void
dmxStatFree(DMXStatInfo * pt)
{
    free(pt);
}

static void
dmxStatValue(DMXStatAvg * data, unsigned long value)
{
    if (data->count != DMX_STAT_LENGTH)
        ++data->count;
    if (data->pos >= DMX_STAT_LENGTH - 1)
        data->pos = 0;
    data->value[data->pos++] = value;
}

/** Note that a XSync() was just done on \a dmxScreen with the \a start
 * and \a stop times (from gettimeofday()) and the number of
 * pending-but-not-yet-processed XSync requests.  This routine is called
 * from #dmxDoSync in \a dmxsync.c */
void
dmxStatSync(DMXScreenInfo * dmxScreen,
            struct timeval *stop, struct timeval *start, unsigned long pending)
{
    DMXStatInfo *s = dmxScreen->stat;
    unsigned long elapsed = usec(stop, start);
    unsigned long thresh;
    int i;

    ++s->syncCount;
    dmxStatValue(&s->usec, elapsed);
    dmxStatValue(&s->pending, pending);

    for (i = 0, thresh = DMX_STAT_BIN0; i < DMX_STAT_BINS - 1; i++) {
        if (elapsed < thresh) {
            ++s->bins[i];
            break;
        }
        thresh *= DMX_STAT_BINMULT;
    }
    if (i == DMX_STAT_BINS - 1)
        ++s->bins[i];
}

/* Actually do the work of printing out the human-readable message. */
static CARD32
dmxStatCallback(OsTimerPtr timer, CARD32 t, void *arg)
{
    int i, j;
    static int header = 0;
    int limit = dmxNumScreens;

    if (!dmxNumScreens) {
        header = 0;
        return DMX_STAT_INTERVAL;
    }

    if (!header++ || !(header % 10)) {
        dmxLog(dmxDebug,
               " S SyncCount  Sync/s avSync mxSync avPend mxPend | "
               "<10ms   <1s   >1s\n");
    }

    if (dmxStatDisplays && dmxStatDisplays < limit)
        limit = dmxStatDisplays;
    for (i = 0; i < limit; i++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[i];
        DMXStatInfo *s = dmxScreen->stat;
        unsigned long aSync, mSync;
        unsigned long aPend, mPend;

        if (!s)
            continue;

        aSync = avg(&s->usec, &mSync);
        aPend = avg(&s->pending, &mPend);
        dmxLog(dmxDebug, "%2d %9lu %7lu %6lu %6lu %6lu %6lu |", i,      /* S */
               s->syncCount,    /* SyncCount */
               (s->syncCount - s->oldSyncCount) * 1000 / dmxStatInterval,       /* Sync/s */
               aSync,           /* us/Sync */
               mSync,           /* max/Sync */
               aPend,           /* avgPend */
               mPend);          /* maxPend */
        for (j = 0; j < DMX_STAT_BINS; j++)
            dmxLogCont(dmxDebug, " %5lu", s->bins[j]);
        dmxLogCont(dmxDebug, "\n");

        /* Reset/clear */
        s->oldSyncCount = s->syncCount;
        for (j = 0; j < DMX_STAT_BINS; j++)
            s->bins[j] = 0;
    }
    return DMX_STAT_INTERVAL;   /* Place on queue again */
}

/** Try to initialize the statistic gathering and printing routines.
 * Initialization only takes place if #dmxStatActivate has already been
 * called.  We don't need the same generation protection that we used in
 * dmxSyncInit because our timer is always on a queue -- hence, server
 * generation will always free it. */
void
dmxStatInit(void)
{
    if (dmxStatInterval)
        dmxStatTimer = TimerSet(NULL, 0,
                                dmxStatInterval, dmxStatCallback, NULL);
}
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d178 1
a178 1
dmxStatCallback(OsTimerPtr timer, CARD32 t, pointer arg)
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d52 1
a52 1
#include <X11/Xos.h>                /* For sys/time.h */
d56 2
a57 2
    int           pos;
    int           count;
d66 2
a67 2
    DMXStatAvg    usec;
    DMXStatAvg    pending;
d73 2
a74 2
       int        dmxStatInterval;
static int        dmxStatDisplays;
d79 2
a80 1
static unsigned long usec(struct timeval *stop, struct timeval *start)
d86 2
a87 1
static unsigned long avg(DMXStatAvg *data, unsigned long *max)
d90 1
a90 1
    int           i;
d93 2
a94 1
    if (!data->count) return 0;
d97 2
a98 1
        if (data->value[i] > *max) *max = data->value[i];
d110 2
a111 1
void dmxStatActivate(const char *interval, const char *displays)
d116 4
a119 2
    if (dmxStatInterval < 1000) dmxStatInterval = 1000;
    if (dmxStatDisplays < 0)    dmxStatDisplays = 0;
d123 2
a124 1
DMXStatInfo *dmxStatAlloc(void)
d127 1
d132 2
a133 1
void dmxStatFree(DMXStatInfo *pt)
d138 2
a139 1
static void dmxStatValue(DMXStatAvg *data, unsigned long value)
d141 4
a144 2
    if (data->count != DMX_STAT_LENGTH) ++data->count;
    if (data->pos >= DMX_STAT_LENGTH-1) data->pos = 0;
d152 3
a154 3
void dmxStatSync(DMXScreenInfo *dmxScreen,
                 struct timeval *stop, struct timeval *start,
                 unsigned long pending)
d156 1
a156 1
    DMXStatInfo   *s      = dmxScreen->stat;
d159 1
a159 1
    int           i;
d164 2
a165 2
    
    for (i = 0, thresh = DMX_STAT_BIN0; i < DMX_STAT_BINS-1; i++) {
d172 2
a173 1
    if (i == DMX_STAT_BINS-1) ++s->bins[i];
d177 2
a178 1
static CARD32 dmxStatCallback(OsTimerPtr timer, CARD32 t, pointer arg)
d180 3
a182 3
    int         i, j;
    static int  header = 0;
    int         limit = dmxNumScreens;
d195 2
a196 1
    if (dmxStatDisplays && dmxStatDisplays < limit) limit = dmxStatDisplays;
d199 1
a199 1
        DMXStatInfo   *s         = dmxScreen->stat;
a201 2
        
        if (!s) continue;
d203 4
a206 1
        aSync = avg(&s->usec,    &mSync);
d208 7
a214 9
        dmxLog(dmxDebug, "%2d %9lu %7lu %6lu %6lu %6lu %6lu |",
               i,                                               /* S */
               s->syncCount,                                    /* SyncCount */
               (s->syncCount
                - s->oldSyncCount) * 1000 / dmxStatInterval,    /* Sync/s */
               aSync,                                           /* us/Sync */
               mSync,                                           /* max/Sync */
               aPend,                                           /* avgPend */
               mPend);                                          /* maxPend */
d219 1
a219 1
                                /* Reset/clear */
d221 2
a222 1
        for (j = 0; j < DMX_STAT_BINS; j++) s->bins[j] = 0;
d232 2
a233 1
void dmxStatInit(void)
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d125 1
a125 1
    if (pt) free(pt);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d40 1
a40 1
 * optimization is provided in #dmxsync.c.  This file provides routines
d105 1
a105 1
 * called from #ddxProcessArgument in #dmxinit.c. */
d138 1
a138 1
 * from #dmxDoSync in #dmxsync.c */
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
d118 1
a118 2
    DMXStatInfo *pt = malloc(sizeof(*pt));
    memset(pt, 0, sizeof(*pt));
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
@

