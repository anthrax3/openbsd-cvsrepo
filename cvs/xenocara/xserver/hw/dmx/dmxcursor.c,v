head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.8
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.16;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.41;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.41;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.19;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   David H. Dawes <dawes@@xfree86.org>
 *   Kevin E. Martin <kem@@redhat.com>
 *   Rickard E. (Rik) Faith <faith@@redhat.com>
 *
 */

/** \file
 * This file contains code than supports cursor movement, including the
 * code that initializes and reinitializes the screen positions and
 * computes screen overlap.
 *
 * "This code is based very closely on the XFree86 equivalent
 * (xfree86/common/xf86Cursor.c)."  --David Dawes.
 *
 * "This code was then extensively re-written, as explained here."
 * --Rik Faith
 *
 * The code in xf86Cursor.c used edge lists to implement the
 * CursorOffScreen function.  The edge list computation was complex
 * (especially in the face of arbitrarily overlapping screens) compared
 * with the speed savings in the CursorOffScreen function.  The new
 * implementation has erred on the side of correctness, readability, and
 * maintainability over efficiency.  For the common (non-edge) case, the
 * dmxCursorOffScreen function does avoid a loop over all the screens.
 * When the cursor has left the screen, all the screens are searched,
 * and the first screen (in dmxScreens order) containing the cursor will
 * be returned.  If run-time profiling shows that this routing is a
 * performance bottle-neck, then an edge list may have to be
 * reimplemented.  An edge list algorithm is O(edges) whereas the new
 * algorithm is O(dmxNumScreens).  Since edges is usually 1-3 and
 * dmxNumScreens may be 30-60 for large backend walls, this trade off
 * may be compelling.
 *
 * The xf86InitOrigins routine uses bit masks during the computation and
 * is therefore limited to the length of a word (e.g., 32 or 64 bits)
 * screens.  Because Xdmx is expected to be used with a large number of
 * backend displays, this limitation was removed.  The new
 * implementation has erred on the side of readability over efficiency,
 * using the dmxSL* routines to manage a screen list instead of a
 * bitmap, and a function call to decrease the length of the main
 * routine.  Both algorithms are of the same order, and both are called
 * only at server generation time, so trading clarity and long-term
 * maintainability for efficiency does not seem justified in this case.
 */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#define DMX_CURSOR_DEBUG 0

#include "dmx.h"
#include "dmxsync.h"
#include "dmxcursor.h"
#include "dmxlog.h"
#include "dmxprop.h"
#include "dmxinput.h"

#include "mipointer.h"
#include "windowstr.h"
#include "globals.h"
#include "cursorstr.h"
#include "dixevents.h"          /* For GetSpriteCursor() */
#include "inputstr.h"           /* for inputInfo.pointer */

#if DMX_CURSOR_DEBUG
#define DMXDBG0(f)               dmxLog(dmxDebug,f)
#define DMXDBG1(f,a)             dmxLog(dmxDebug,f,a)
#define DMXDBG2(f,a,b)           dmxLog(dmxDebug,f,a,b)
#define DMXDBG3(f,a,b,c)         dmxLog(dmxDebug,f,a,b,c)
#define DMXDBG4(f,a,b,c,d)       dmxLog(dmxDebug,f,a,b,c,d)
#define DMXDBG5(f,a,b,c,d,e)     dmxLog(dmxDebug,f,a,b,c,d,e)
#define DMXDBG6(f,a,b,c,d,e,g)   dmxLog(dmxDebug,f,a,b,c,d,e,g)
#define DMXDBG7(f,a,b,c,d,e,g,h) dmxLog(dmxDebug,f,a,b,c,d,e,g,h)
#else
#define DMXDBG0(f)
#define DMXDBG1(f,a)
#define DMXDBG2(f,a,b)
#define DMXDBG3(f,a,b,c)
#define DMXDBG4(f,a,b,c,d)
#define DMXDBG5(f,a,b,c,d,e)
#define DMXDBG6(f,a,b,c,d,e,g)
#define DMXDBG7(f,a,b,c,d,e,g,h)
#endif

static int dmxCursorDoMultiCursors = 1;

/** Turn off support for displaying multiple cursors on overlapped
    back-end displays.  See #dmxCursorDoMultiCursors. */
void
dmxCursorNoMulti(void)
{
    dmxCursorDoMultiCursors = 0;
}

static Bool
dmxCursorOffScreen(ScreenPtr *ppScreen, int *x, int *y)
{
    DMXScreenInfo *dmxScreen;
    int i;
    int localX = *x;
    int localY = *y;
    int globalX;
    int globalY;

    if (screenInfo.numScreens == 1)
        return FALSE;

    /* On current screen? */
    dmxScreen = &dmxScreens[(*ppScreen)->myNum];
    if (localX >= 0
        && localX < dmxScreen->rootWidth
        && localY >= 0 && localY < dmxScreen->rootHeight)
        return FALSE;

    /* Convert to global coordinate space */
    globalX = dmxScreen->rootXOrigin + localX;
    globalY = dmxScreen->rootYOrigin + localY;

    /* Is cursor on the current screen?
     * This efficiently exits this routine
     * for the most common case. */
    if (ppScreen && *ppScreen) {
        dmxScreen = &dmxScreens[(*ppScreen)->myNum];
        if (globalX >= dmxScreen->rootXOrigin
            && globalX < dmxScreen->rootXOrigin + dmxScreen->rootWidth
            && globalY >= dmxScreen->rootYOrigin
            && globalY < dmxScreen->rootYOrigin + dmxScreen->rootHeight)
            return FALSE;
    }

    /* Find first screen cursor is on */
    for (i = 0; i < dmxNumScreens; i++) {
        dmxScreen = &dmxScreens[i];
        if (globalX >= dmxScreen->rootXOrigin
            && globalX < dmxScreen->rootXOrigin + dmxScreen->rootWidth
            && globalY >= dmxScreen->rootYOrigin
            && globalY < dmxScreen->rootYOrigin + dmxScreen->rootHeight) {
            if (dmxScreen->index == (*ppScreen)->myNum)
                return FALSE;
            *ppScreen = screenInfo.screens[dmxScreen->index];
            *x = globalX - dmxScreen->rootXOrigin;
            *y = globalY - dmxScreen->rootYOrigin;
            return TRUE;
        }
    }
    return FALSE;
}

static void
dmxCrossScreen(ScreenPtr pScreen, Bool entering)
{
}

static void
dmxWarpCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
{
    DMXDBG3("dmxWarpCursor(%d,%d,%d)\n", pScreen->myNum, x, y);
#if 11 /*BP*/
        /* This call is depracated.  Replace with???? */
        miPointerWarpCursor(pDev, pScreen, x, y);
#else
    pScreen->SetCursorPosition(pDev, pScreen, x, y, FALSE);
#endif
}

miPointerScreenFuncRec dmxPointerCursorFuncs = {
    dmxCursorOffScreen,
    dmxCrossScreen,
    dmxWarpCursor,
};

/** Create a list of screens that we'll manipulate. */
static int *
dmxSLCreate(void)
{
    int *list = xallocarray(dmxNumScreens, sizeof(*list));
    int i;

    for (i = 0; i < dmxNumScreens; i++)
        list[i] = 1;
    return list;
}

/** Free list. */
static void
dmxSLFree(int *list)
{
    free(list);
}

/** Find next uninitialized entry in list. */
static int
dmxSLFindNext(int *list)
{
    int i;

    for (i = 0; i < dmxNumScreens; i++)
        if (list[i])
            return i;
    return -1;
}

/** Make one pass over all the screens and return the number updated. */
static int
dmxTryComputeScreenOrigins(int *screensLeft)
{
    ScreenPtr pScreen, refScreen;
    DMXScreenInfo *screen;
    int i, ref;
    int changed = 0;

    for (i = 0; i < dmxNumScreens; i++) {
        if (!screensLeft[i])
            continue;
        screen = &dmxScreens[i];
        pScreen = screenInfo.screens[i];
        switch (screen->where) {
        case PosAbsolute:
            pScreen->x = screen->whereX;
            pScreen->y = screen->whereY;
            ++changed, screensLeft[i] = 0;
            break;
        case PosRelative:
            ref = screen->whereRefScreen;
            if (screensLeft[ref])
                break;
            refScreen = screenInfo.screens[ref];
            pScreen->x = refScreen->x + screen->whereX;
            pScreen->y = refScreen->y + screen->whereY;
            ++changed, screensLeft[i] = 0;
            break;
        case PosRightOf:
            ref = screen->whereRefScreen;
            if (screensLeft[ref])
                break;
            refScreen = screenInfo.screens[ref];
            pScreen->x = refScreen->x + refScreen->width;
            pScreen->y = refScreen->y;
            ++changed, screensLeft[i] = 0;
            break;
        case PosLeftOf:
            ref = screen->whereRefScreen;
            if (screensLeft[ref])
                break;
            refScreen = screenInfo.screens[ref];
            pScreen->x = refScreen->x - pScreen->width;
            pScreen->y = refScreen->y;
            ++changed, screensLeft[i] = 0;
            break;
        case PosBelow:
            ref = screen->whereRefScreen;
            if (screensLeft[ref])
                break;
            refScreen = screenInfo.screens[ref];
            pScreen->x = refScreen->x;
            pScreen->y = refScreen->y + refScreen->height;
            ++changed, screensLeft[i] = 0;
            break;
        case PosAbove:
            ref = screen->whereRefScreen;
            if (screensLeft[ref])
                break;
            refScreen = screenInfo.screens[ref];
            pScreen->x = refScreen->x;
            pScreen->y = refScreen->y - pScreen->height;
            ++changed, screensLeft[i] = 0;
            break;
        case PosNone:
            dmxLog(dmxFatal, "No position information for screen %d\n", i);
        }
    }
    return changed;
}

static void
dmxComputeScreenOrigins(void)
{
    ScreenPtr pScreen;
    int *screensLeft;
    int i, ref;
    int minX, minY;

    /* Compute origins based on
     * configuration information. */
    screensLeft = dmxSLCreate();
    while ((i = dmxSLFindNext(screensLeft)) >= 0) {
        while (dmxTryComputeScreenOrigins(screensLeft));
        if ((i = dmxSLFindNext(screensLeft)) >= 0) {
            /* All of the remaining screens are referencing each other.
             * Assign a value to one of them and go through again.  This
             * guarantees that we will eventually terminate.
             */
            ref = dmxScreens[i].whereRefScreen;
            pScreen = screenInfo.screens[ref];
            pScreen->x = pScreen->y = 0;
            screensLeft[ref] = 0;
        }
    }
    dmxSLFree(screensLeft);

    /* Justify the topmost and leftmost to
     * (0,0). */
    minX = screenInfo.screens[0]->x;
    minY = screenInfo.screens[0]->y;
    for (i = 1; i < dmxNumScreens; i++) {       /* Compute minX, minY */
        if (screenInfo.screens[i]->x < minX)
            minX = screenInfo.screens[i]->x;
        if (screenInfo.screens[i]->y < minY)
            minY = screenInfo.screens[i]->y;
    }
    if (minX || minY) {
        for (i = 0; i < dmxNumScreens; i++) {
            screenInfo.screens[i]->x -= minX;
            screenInfo.screens[i]->y -= minY;
        }
    }

    update_desktop_dimensions();
}

/** Recompute origin information in the #dmxScreens list.  This is
 * called from #dmxInitOrigins. */
void
dmxReInitOrigins(void)
{
    int i;

    if (dmxNumScreens > MAXSCREENS)
        dmxLog(dmxFatal, "dmxNumScreens = %d > MAXSCREENS = %d\n",
               dmxNumScreens, MAXSCREENS);

    for (i = 0; i < dmxNumScreens; i++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[i];

        dmxLogOutput(dmxScreen,
                     "s=%dx%d%+d%+d r=%dx%d%+d%+d @@%d,%d"
                     " (be=%dx%d depth=%d bpp=%d)\n",
                     dmxScreen->scrnWidth, dmxScreen->scrnHeight,
                     dmxScreen->scrnX, dmxScreen->scrnY,
                     dmxScreen->rootWidth, dmxScreen->rootHeight,
                     dmxScreen->rootX, dmxScreen->rootY,
                     dmxScreen->rootXOrigin, dmxScreen->rootYOrigin,
                     dmxScreen->beWidth, dmxScreen->beHeight,
                     dmxScreen->beDepth, dmxScreen->beBPP);
    }
}

/** Initialize screen origins (and relative position).  This is called
 * for each server generation.  For dynamic reconfiguration, use
 * #dmxReInitOrigins() instead. */
void
dmxInitOrigins(void)
{
    int i;

    if (dmxNumScreens > MAXSCREENS)
        dmxLog(dmxFatal, "dmxNumScreens = %d > MAXSCREENS = %d\n",
               dmxNumScreens, MAXSCREENS);

    for (i = 0; i < dmxNumScreens; i++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[i];

        dmxLogOutput(dmxScreen,
                     "(request) s=%dx%d%+d%+d r=%dx%d%+d%+d @@%d,%d (%d)"
                     " (be=%dx%d depth=%d bpp=%d)\n",
                     dmxScreen->scrnWidth, dmxScreen->scrnHeight,
                     dmxScreen->scrnX, dmxScreen->scrnY,
                     dmxScreen->rootWidth, dmxScreen->rootHeight,
                     dmxScreen->rootX, dmxScreen->rootY,
                     dmxScreen->whereX, dmxScreen->whereY,
                     dmxScreen->where,
                     dmxScreen->beWidth, dmxScreen->beHeight,
                     dmxScreen->beDepth, dmxScreen->beBPP);
    }

    dmxComputeScreenOrigins();

    for (i = 0; i < dmxNumScreens; i++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[i];

        dmxScreen->rootXOrigin = screenInfo.screens[i]->x;
        dmxScreen->rootYOrigin = screenInfo.screens[i]->y;
    }

    dmxReInitOrigins();
}

/** Returns non-zero if the global \a x, \a y coordinate is on the
 * screen window of the \a dmxScreen. */
int
dmxOnScreen(int x, int y, DMXScreenInfo * dmxScreen)
{
#if DMX_CURSOR_DEBUG > 1
    dmxLog(dmxDebug,
           "dmxOnScreen %d %d,%d (r=%dx%d%+d%+d@@%d,%d s=%dx%d%+d%+d)\n",
           dmxScreen->index, x, y,
           dmxScreen->rootWidth, dmxScreen->rootHeight,
           dmxScreen->rootX, dmxScreen->rootY,
           dmxScreen->rootXOrigin, dmxScreen->rootYOrigin,
           dmxScreen->scrnWidth, dmxScreen->scrnHeight,
           dmxScreen->scrnX, dmxScreen->scrnY);
#endif
    if (x >= dmxScreen->rootXOrigin
        && x < dmxScreen->rootXOrigin + dmxScreen->rootWidth
        && y >= dmxScreen->rootYOrigin
        && y < dmxScreen->rootYOrigin + dmxScreen->rootHeight)
        return 1;
    return 0;
}

/** Returns non-zero if \a a overlaps \a b. */
static int
dmxDoesOverlap(DMXScreenInfo * a, DMXScreenInfo * b)
{
    if (dmxOnScreen(a->rootXOrigin, a->rootYOrigin, b))
        return 1;

    if (dmxOnScreen(a->rootXOrigin, a->rootYOrigin + a->scrnWidth, b))
        return 1;

    if (dmxOnScreen(a->rootXOrigin + a->scrnHeight, a->rootYOrigin, b))
        return 1;

    if (dmxOnScreen(a->rootXOrigin + a->scrnHeight,
                    a->rootYOrigin + a->scrnWidth, b))
        return 1;

    if (dmxOnScreen(b->rootXOrigin, b->rootYOrigin, a))
        return 1;

    if (dmxOnScreen(b->rootXOrigin, b->rootYOrigin + b->scrnWidth, a))
        return 1;

    if (dmxOnScreen(b->rootXOrigin + b->scrnHeight, b->rootYOrigin, a))
        return 1;

    if (dmxOnScreen(b->rootXOrigin + b->scrnHeight,
                    b->rootYOrigin + b->scrnWidth, a))
        return 1;

    return 0;
}

/** Used with \a dmxInterateOverlap to print out a list of screens which
 * overlap each other. */
static void *
dmxPrintOverlap(DMXScreenInfo * dmxScreen, void *closure)
{
    DMXScreenInfo *a = closure;

    if (dmxScreen != a) {
        if (dmxScreen->cursorNotShared)
            dmxLogOutputCont(a, " [%d/%s]", dmxScreen->index, dmxScreen->name);
        else
            dmxLogOutputCont(a, " %d/%s", dmxScreen->index, dmxScreen->name);
    }
    return NULL;
}

/** Iterate over the screens which overlap with the \a start screen,
 * calling \a f with the \a closure for each argument.  Often used with
 * #dmxPrintOverlap. */
static void *
dmxIterateOverlap(DMXScreenInfo * start,
                  void *(*f) (DMXScreenInfo * dmxScreen, void *), void *closure)
{
    DMXScreenInfo *pt;

    if (!start->over)
        return f(start, closure);

    for (pt = start->over; /* condition at end of loop */ ; pt = pt->over) {
        void *retval;

        if ((retval = f(pt, closure)))
            return retval;
        if (pt == start)
            break;
    }
    return NULL;
}

/** Used with #dmxPropertyIterate to determine if screen \a a is the
 * same as the screen \a closure. */
static void *
dmxTestSameDisplay(DMXScreenInfo * a, void *closure)
{
    DMXScreenInfo *b = closure;

    if (a == b)
        return a;
    return NULL;
}

/** Detects overlapping dmxScreens and creates circular lists.  This
 * uses an O(dmxNumScreens^2) algorithm, but dmxNumScreens is < 100 and
 * the computation only needs to be performed for every server
 * generation or dynamic reconfiguration . */
void
dmxInitOverlap(void)
{
    int i, j;
    DMXScreenInfo *a, *b, *pt;

    for (i = 0; i < dmxNumScreens; i++)
        dmxScreens[i].over = NULL;

    for (i = 0; i < dmxNumScreens; i++) {
        a = &dmxScreens[i];

        for (j = i + 1; j < dmxNumScreens; j++) {
            b = &dmxScreens[j];
            if (b->over)
                continue;

            if (dmxDoesOverlap(a, b)) {
                DMXDBG6("%d overlaps %d: a=%p %p b=%p %p\n",
                        a->index, b->index, a, a->over, b, b->over);
                b->over = (a->over ? a->over : a);
                a->over = b;
            }
        }
    }

    for (i = 0; i < dmxNumScreens; i++) {
        a = &dmxScreens[i];

        if (!a->over)
            continue;

        /* Flag all pairs that are on same display */
        for (pt = a->over; pt != a; pt = pt->over) {
            if (dmxPropertyIterate(a, dmxTestSameDisplay, pt)) {
                /* The ->over sets contain the transitive set of screens
                 * that overlap.  For screens that are on the same
                 * backend display, we only want to exclude pairs of
                 * screens that mutually overlap on the backend display,
                 * so we call dmxDoesOverlap, which is stricter than the
                 * ->over set. */
                if (!dmxDoesOverlap(a, pt))
                    continue;
                a->cursorNotShared = 1;
                pt->cursorNotShared = 1;
                dmxLog(dmxInfo,
                       "Screen %d and %d overlap on %s\n",
                       a->index, pt->index, a->name);
            }
        }
    }

    for (i = 0; i < dmxNumScreens; i++) {
        a = &dmxScreens[i];

        if (a->over) {
            dmxLogOutput(a, "Overlaps");
            dmxIterateOverlap(a, dmxPrintOverlap, a);
            dmxLogOutputCont(a, "\n");
        }
    }
}

/** Create \a pCursor on the back-end associated with \a pScreen. */
void
dmxBECreateCursor(ScreenPtr pScreen, CursorPtr pCursor)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxCursorPrivPtr pCursorPriv = DMX_GET_CURSOR_PRIV(pCursor, pScreen);
    CursorBitsPtr pBits = pCursor->bits;
    Pixmap src, msk;
    XColor fg, bg;
    XImage *img;
    XlibGC gc = NULL;
    XGCValues v;
    unsigned long m;
    int i;

    if (!pCursorPriv)
        return;

    m = GCFunction | GCPlaneMask | GCForeground | GCBackground | GCClipMask;
    v.function = GXcopy;
    v.plane_mask = AllPlanes;
    v.foreground = 1L;
    v.background = 0L;
    v.clip_mask = None;

    for (i = 0; i < dmxScreen->beNumPixmapFormats; i++) {
        if (dmxScreen->bePixmapFormats[i].depth == 1) {
            /* Create GC in the back-end servers */
            gc = XCreateGC(dmxScreen->beDisplay, dmxScreen->scrnDefDrawables[i],
                           m, &v);
            break;
        }
    }
    if (!gc)
        dmxLog(dmxFatal, "dmxRealizeCursor: gc not initialized\n");

    src = XCreatePixmap(dmxScreen->beDisplay, dmxScreen->scrnWin,
                        pBits->width, pBits->height, 1);
    msk = XCreatePixmap(dmxScreen->beDisplay, dmxScreen->scrnWin,
                        pBits->width, pBits->height, 1);

    img = XCreateImage(dmxScreen->beDisplay,
                       dmxScreen->beVisuals[dmxScreen->beDefVisualIndex].visual,
                       1, XYBitmap, 0, (char *) pBits->source,
                       pBits->width, pBits->height,
                       BitmapPad(dmxScreen->beDisplay), 0);

    XPutImage(dmxScreen->beDisplay, src, gc, img, 0, 0, 0, 0,
              pBits->width, pBits->height);

    XFree(img);

    img = XCreateImage(dmxScreen->beDisplay,
                       dmxScreen->beVisuals[dmxScreen->beDefVisualIndex].visual,
                       1, XYBitmap, 0, (char *) pBits->mask,
                       pBits->width, pBits->height,
                       BitmapPad(dmxScreen->beDisplay), 0);

    XPutImage(dmxScreen->beDisplay, msk, gc, img, 0, 0, 0, 0,
              pBits->width, pBits->height);

    XFree(img);

    fg.red = pCursor->foreRed;
    fg.green = pCursor->foreGreen;
    fg.blue = pCursor->foreBlue;

    bg.red = pCursor->backRed;
    bg.green = pCursor->backGreen;
    bg.blue = pCursor->backBlue;

    pCursorPriv->cursor = XCreatePixmapCursor(dmxScreen->beDisplay,
                                              src, msk,
                                              &fg, &bg,
                                              pBits->xhot, pBits->yhot);

    XFreePixmap(dmxScreen->beDisplay, src);
    XFreePixmap(dmxScreen->beDisplay, msk);
    XFreeGC(dmxScreen->beDisplay, gc);

    dmxSync(dmxScreen, FALSE);
}

static Bool
_dmxRealizeCursor(ScreenPtr pScreen, CursorPtr pCursor)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxCursorPrivPtr pCursorPriv;

    DMXDBG2("_dmxRealizeCursor(%d,%p)\n", pScreen->myNum, pCursor);

    DMX_SET_CURSOR_PRIV(pCursor, pScreen, malloc(sizeof(*pCursorPriv)));
    if (!DMX_GET_CURSOR_PRIV(pCursor, pScreen))
        return FALSE;

    pCursorPriv = DMX_GET_CURSOR_PRIV(pCursor, pScreen);
    pCursorPriv->cursor = (Cursor) 0;

    if (!dmxScreen->beDisplay)
        return TRUE;

    dmxBECreateCursor(pScreen, pCursor);
    return TRUE;
}

/** Free \a pCursor on the back-end associated with \a pScreen. */
Bool
dmxBEFreeCursor(ScreenPtr pScreen, CursorPtr pCursor)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxCursorPrivPtr pCursorPriv = DMX_GET_CURSOR_PRIV(pCursor, pScreen);

    if (pCursorPriv) {
        XFreeCursor(dmxScreen->beDisplay, pCursorPriv->cursor);
        pCursorPriv->cursor = (Cursor) 0;
        return TRUE;
    }

    return FALSE;
}

static Bool
_dmxUnrealizeCursor(ScreenPtr pScreen, CursorPtr pCursor)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];

    DMXDBG2("_dmxUnrealizeCursor(%d,%p)\n", pScreen->myNum, pCursor);

    if (dmxScreen->beDisplay) {
        if (dmxBEFreeCursor(pScreen, pCursor))
            free(DMX_GET_CURSOR_PRIV(pCursor, pScreen));
    }
    DMX_SET_CURSOR_PRIV(pCursor, pScreen, NULL);

    return TRUE;
}

static void
_dmxMoveCursor(ScreenPtr pScreen, int x, int y)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    int newX = x + dmxScreen->rootX;
    int newY = y + dmxScreen->rootY;

    if (newX < 0)
        newX = 0;
    if (newY < 0)
        newY = 0;

    DMXDBG5("_dmxMoveCursor(%d,%d,%d) -> %d,%d\n",
            pScreen->myNum, x, y, newX, newY);
    if (dmxScreen->beDisplay) {
        XWarpPointer(dmxScreen->beDisplay, None, dmxScreen->scrnWin,
                     0, 0, 0, 0, newX, newY);
        dmxSync(dmxScreen, TRUE);
    }
}

static void
_dmxSetCursor(ScreenPtr pScreen, CursorPtr pCursor, int x, int y)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];

    DMXDBG4("_dmxSetCursor(%d,%p,%d,%d)\n", pScreen->myNum, pCursor, x, y);

    if (pCursor) {
        dmxCursorPrivPtr pCursorPriv = DMX_GET_CURSOR_PRIV(pCursor, pScreen);

        if (pCursorPriv && dmxScreen->curCursor != pCursorPriv->cursor) {
            if (dmxScreen->beDisplay)
                XDefineCursor(dmxScreen->beDisplay, dmxScreen->scrnWin,
                              pCursorPriv->cursor);
            dmxScreen->cursor = pCursor;
            dmxScreen->curCursor = pCursorPriv->cursor;
            dmxScreen->cursorVisible = 1;
        }
        _dmxMoveCursor(pScreen, x, y);
    }
    else {
        if (dmxScreen->beDisplay)
            XDefineCursor(dmxScreen->beDisplay, dmxScreen->scrnWin,
                          dmxScreen->noCursor);
        dmxScreen->cursor = NULL;
        dmxScreen->curCursor = (Cursor) 0;
        dmxScreen->cursorVisible = 0;
    }
    if (dmxScreen->beDisplay)
        dmxSync(dmxScreen, TRUE);
}

static Bool
dmxRealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
{
    DMXScreenInfo *start = &dmxScreens[pScreen->myNum];
    DMXScreenInfo *pt;

    if (!start->over || !dmxCursorDoMultiCursors || start->cursorNotShared)
        return _dmxRealizeCursor(pScreen, pCursor);

    for (pt = start->over; /* condition at end of loop */ ; pt = pt->over) {
        if (pt->cursorNotShared)
            continue;
        _dmxRealizeCursor(screenInfo.screens[pt->index], pCursor);
        if (pt == start)
            break;
    }
    return TRUE;
}

static Bool
dmxUnrealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
{
    DMXScreenInfo *start = &dmxScreens[pScreen->myNum];
    DMXScreenInfo *pt;

    if (!start->over || !dmxCursorDoMultiCursors || start->cursorNotShared)
        return _dmxUnrealizeCursor(pScreen, pCursor);

    for (pt = start->over; /* condition at end of loop */ ; pt = pt->over) {
        if (pt->cursorNotShared)
            continue;
        _dmxUnrealizeCursor(screenInfo.screens[pt->index], pCursor);
        if (pt == start)
            break;
    }
    return TRUE;
}

static CursorPtr
dmxFindCursor(DMXScreenInfo * start)
{
    DMXScreenInfo *pt;

    if (!start || !start->over)
        return GetSpriteCursor(inputInfo.pointer);
    for (pt = start->over; /* condition at end of loop */ ; pt = pt->over) {
        if (pt->cursor)
            return pt->cursor;
        if (pt == start)
            break;
    }
    return GetSpriteCursor(inputInfo.pointer);
}

/** Move the cursor to coordinates (\a x, \a y)on \a pScreen.  This
 * function is usually called via #dmxPointerSpriteFuncs, except during
 * reconfiguration when the cursor is repositioned to force an update on
 * newley overlapping screens and on screens that no longer overlap.
 *
 * The coords (x,y) are in global coord space.  We'll loop over the
 * back-end screens and see if they contain the global coord.  If so, call
 * _dmxMoveCursor() (XWarpPointer) to position the pointer on that screen.
 */
void
dmxMoveCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
{
    DMXScreenInfo *start = &dmxScreens[pScreen->myNum];
    DMXScreenInfo *pt;

    DMXDBG3("dmxMoveCursor(%d,%d,%d)\n", pScreen->myNum, x, y);

    if (!start->over || !dmxCursorDoMultiCursors || start->cursorNotShared) {
        _dmxMoveCursor(pScreen, x, y);
        return;
    }

    for (pt = start->over; /* condition at end of loop */ ; pt = pt->over) {
        if (pt->cursorNotShared)
            continue;
        if (dmxOnScreen(x + start->rootXOrigin, y + start->rootYOrigin, pt)) {
            if ( /* pt != start && */ !pt->cursorVisible) {
                if (!pt->cursor) {
                    /* This only happens during
                     * reconfiguration when a new overlap
                     * occurs. */
                    CursorPtr pCursor;

                    if ((pCursor = dmxFindCursor(start)))
                        _dmxRealizeCursor(screenInfo.screens[pt->index],
                                          pt->cursor = pCursor);

                }
                _dmxSetCursor(screenInfo.screens[pt->index],
                              pt->cursor,
                              x + start->rootXOrigin - pt->rootXOrigin,
                              y + start->rootYOrigin - pt->rootYOrigin);
            }
            _dmxMoveCursor(screenInfo.screens[pt->index],
                           x + start->rootXOrigin - pt->rootXOrigin,
                           y + start->rootYOrigin - pt->rootYOrigin);
        }
        else if ( /* pt != start && */ pt->cursorVisible) {
            _dmxSetCursor(screenInfo.screens[pt->index],
                          NULL,
                          x + start->rootXOrigin - pt->rootXOrigin,
                          y + start->rootYOrigin - pt->rootYOrigin);
        }
        if (pt == start)
            break;
    }
}

static void
dmxSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor, int x,
             int y)
{
    DMXScreenInfo *start = &dmxScreens[pScreen->myNum];
    DMXScreenInfo *pt;
    int GX, GY, gx, gy;

    DMXDBG5("dmxSetCursor(%d %p, %p,%d,%d)\n",
            pScreen->myNum, start, pCursor, x, y);

    /* We do this check here because of two cases:
     *
     * 1) if a client calls XWarpPointer()
     * and Xinerama is not running, we can
     * have mi's notion of the pointer
     * position out of phase with DMX's
     * notion.
     *
     * 2) if a down button is held while the
     * cursor moves outside the root window,
     * mi's notion of the pointer position
     * is out of phase with DMX's notion and
     * the cursor can remain visible when it
     * shouldn't be. */

    dmxGetGlobalPosition(&GX, &GY);
    gx = start->rootXOrigin + x;
    gy = start->rootYOrigin + y;
    if (x && y && (GX != gx || GY != gy))
        dmxCoreMotion(NULL, gx, gy, 0, DMX_NO_BLOCK);

    if (!start->over || !dmxCursorDoMultiCursors || start->cursorNotShared) {
        _dmxSetCursor(pScreen, pCursor, x, y);
        return;
    }

    for (pt = start->over; /* condition at end of loop */ ; pt = pt->over) {
        if (pt->cursorNotShared)
            continue;
        if (dmxOnScreen(x + start->rootXOrigin, y + start->rootYOrigin, pt)) {
            _dmxSetCursor(screenInfo.screens[pt->index], pCursor,
                          x + start->rootXOrigin - pt->rootXOrigin,
                          y + start->rootYOrigin - pt->rootYOrigin);
        }
        else {
            _dmxSetCursor(screenInfo.screens[pt->index], NULL,
                          x + start->rootXOrigin - pt->rootXOrigin,
                          y + start->rootYOrigin - pt->rootYOrigin);
        }
        if (pt == start)
            break;
    }
}

/** This routine is used by the backend input routines to hide the
 * cursor on a screen that is being used for relative input.  \see
 * dmxbackend.c */
void
dmxHideCursor(DMXScreenInfo * dmxScreen)
{
    int x, y;
    ScreenPtr pScreen = screenInfo.screens[dmxScreen->index];

    dmxGetGlobalPosition(&x, &y);
    _dmxSetCursor(pScreen, NULL, x, y);
}

/** This routine is called during reconfiguration to make sure the
 * cursor is visible. */
void
dmxCheckCursor(void)
{
    int i;
    int x, y;
    ScreenPtr pScreen;
    DMXScreenInfo *firstScreen;

    dmxGetGlobalPosition(&x, &y);
    firstScreen = dmxFindFirstScreen(x, y);

    DMXDBG2("dmxCheckCursor %d %d\n", x, y);
    for (i = 0; i < dmxNumScreens; i++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[i];

        pScreen = screenInfo.screens[dmxScreen->index];

        if (!dmxOnScreen(x, y, dmxScreen)) {
            if (firstScreen &&
                i == miPointerGetScreen(inputInfo.pointer)->myNum)
                 miPointerSetScreen(inputInfo.pointer, firstScreen->index, x,
                                    y);
            _dmxSetCursor(pScreen, NULL, x - dmxScreen->rootXOrigin,
                          y - dmxScreen->rootYOrigin);
        }
        else {
            if (!dmxScreen->cursor) {
                CursorPtr pCursor;

                if ((pCursor = dmxFindCursor(dmxScreen))) {
                    _dmxRealizeCursor(pScreen, dmxScreen->cursor = pCursor);
                }
            }
            _dmxSetCursor(pScreen, dmxScreen->cursor,
                          x - dmxScreen->rootXOrigin,
                          y - dmxScreen->rootYOrigin);
        }
    }
    DMXDBG2("   leave dmxCheckCursor %d %d\n", x, y);
}

static Bool
dmxDeviceCursorInitialize(DeviceIntPtr pDev, ScreenPtr pScr)
{
    return TRUE;
}

static void
dmxDeviceCursorCleanup(DeviceIntPtr pDev, ScreenPtr pScr)
{
}

miPointerSpriteFuncRec dmxPointerSpriteFuncs = {
    dmxRealizeCursor,
    dmxUnrealizeCursor,
    dmxSetCursor,
    dmxMoveCursor,
    dmxDeviceCursorInitialize,
    dmxDeviceCursorCleanup
};
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d206 1
a206 1
    int *list = malloc(dmxNumScreens * sizeof(*list));
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a199 2
    NULL,
    NULL,
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d349 2
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d119 2
a120 1
void dmxCursorNoMulti(void)
d125 2
a126 1
static Bool dmxCursorOffScreen(ScreenPtr *ppScreen, int *x, int *y)
d129 6
a134 6
    int           i;
    int           localX = *x;
    int           localY = *y;
    int           globalX;
    int           globalY;
    
d138 1
a138 1
                                /* On current screen? */
d142 1
a142 2
        && localY >= 0
        && localY < dmxScreen->rootHeight)
d145 1
a145 1
                                /* Convert to global coordinate space */
d149 3
a151 3
                                /* Is cursor on the current screen?
                                 * This efficiently exits this routine
                                 * for the most common case. */
d161 1
a161 1
                                /* Find first screen cursor is on */
d171 2
a172 2
            *x        = globalX - dmxScreen->rootXOrigin;
            *y        = globalY - dmxScreen->rootYOrigin;
d179 2
a180 1
static void dmxCrossScreen(ScreenPtr pScreen, Bool entering)
d184 2
a185 1
static void dmxWarpCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
d189 2
a190 2
    /* This call is depracated.  Replace with???? */
    miPointerWarpCursor(pDev, pScreen, x, y);
d196 1
a196 2
miPointerScreenFuncRec dmxPointerCursorFuncs =
{
a203 1

d205 2
a206 1
static int *dmxSLCreate(void)
d210 1
a210 1
    
d217 2
a218 1
static void dmxSLFree(int *list)
d224 2
a225 1
static int dmxSLFindNext(int *list)
d228 1
d236 2
a237 1
static int dmxTryComputeScreenOrigins(int *screensLeft)
d239 4
a242 4
    ScreenPtr       pScreen, refScreen;
    DMXScreenInfo   *screen;
    int             i, ref;
    int             changed = 0;
d247 1
a247 1
        screen  = &dmxScreens[i];
d307 2
a308 1
static void dmxComputeScreenOrigins(void)
d310 4
a313 4
    ScreenPtr       pScreen;
    int             *screensLeft;
    int             i, ref;
    int             minX, minY;
d315 2
a316 2
                                /* Compute origins based on
                                 * configuration information. */
d321 9
a329 9
	    /* All of the remaining screens are referencing each other.
	     * Assign a value to one of them and go through again.  This
	     * guarantees that we will eventually terminate.
	     */
	    ref                     = dmxScreens[i].whereRefScreen;
	    pScreen                 = screenInfo.screens[ref];
	    pScreen->x = pScreen->y = 0;
	    screensLeft[ref]        = 0;
	}
d333 2
a334 3

                                /* Justify the topmost and leftmost to
                                 * (0,0). */
d337 2
a338 2
    for (i = 1; i < dmxNumScreens; i++) { /* Compute minX, minY */
	if (screenInfo.screens[i]->x < minX)
d340 1
a340 1
	if (screenInfo.screens[i]->y < minY)
d344 4
a347 4
	for (i = 0; i < dmxNumScreens; i++) {
	    screenInfo.screens[i]->x -= minX;
	    screenInfo.screens[i]->y -= minY;
	}
d353 2
a354 1
void dmxReInitOrigins(void)
d356 1
a356 1
    int        i;
d363 2
a364 1
        DMXScreenInfo    *dmxScreen  = &dmxScreens[i];
a369 1

a371 1
                     
d381 2
a382 1
void dmxInitOrigins(void)
d384 1
a384 1
    int  i;
d391 2
a392 1
        DMXScreenInfo    *dmxScreen  = &dmxScreens[i];
a397 1

a399 1

a401 1

d409 2
a410 1
        DMXScreenInfo  *dmxScreen = &dmxScreens[i];
d420 2
a421 1
int dmxOnScreen(int x, int y, DMXScreenInfo *dmxScreen)
d436 2
a437 1
        && y < dmxScreen->rootYOrigin + dmxScreen->rootHeight) return 1;
d442 2
a443 1
static int dmxDoesOverlap(DMXScreenInfo *a, DMXScreenInfo *b)
d445 1
a445 2
    if (dmxOnScreen(a->rootXOrigin,
                    a->rootYOrigin,                 b))
d448 1
a448 2
    if (dmxOnScreen(a->rootXOrigin,
                    a->rootYOrigin + a->scrnWidth,  b))
d451 1
a451 2
    if (dmxOnScreen(a->rootXOrigin + a->scrnHeight,
                    a->rootYOrigin,                 b))
d455 1
a455 1
                    a->rootYOrigin + a->scrnWidth,  b))
d458 1
a458 2
    if (dmxOnScreen(b->rootXOrigin,
                    b->rootYOrigin,                 a))
d461 1
a461 2
    if (dmxOnScreen(b->rootXOrigin,
                    b->rootYOrigin + b->scrnWidth,  a))
d464 1
a464 2
    if (dmxOnScreen(b->rootXOrigin + b->scrnHeight,
                    b->rootYOrigin,                 a))
d468 1
a468 1
                    b->rootYOrigin + b->scrnWidth,  a))
d476 2
a477 1
static void *dmxPrintOverlap(DMXScreenInfo *dmxScreen, void *closure)
d480 1
d493 3
a495 3
static void *dmxIterateOverlap(DMXScreenInfo *start,
                               void *(*f)(DMXScreenInfo *dmxScreen, void *),
                               void *closure)
d499 2
a500 1
    if (!start->over) return f(start, closure);
d502 1
a502 1
    for (pt = start->over; /* condition at end of loop */; pt = pt->over) {
d504 5
a508 2
        if ((retval = f(pt, closure))) return retval;
        if (pt == start) break;
d515 2
a516 1
static void *dmxTestSameDisplay(DMXScreenInfo *a, void *closure)
d529 2
a530 1
void dmxInitOverlap(void)
d532 1
a532 1
    int           i, j;
d540 2
a541 2
        
        for (j = i+1; j < dmxNumScreens; j++) {
d545 1
a545 1
            
d557 1
a557 1
        
d560 2
a561 2
        
                                /* Flag all pairs that are on same display */
d572 1
a572 1
                a->cursorNotShared  = 1;
d583 1
a583 1
        
d593 2
a594 1
void dmxBECreateCursor(ScreenPtr pScreen, CursorPtr pCursor)
d596 10
a605 10
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxCursorPrivPtr  pCursorPriv = DMX_GET_CURSOR_PRIV(pCursor, pScreen);
    CursorBitsPtr     pBits = pCursor->bits;
    Pixmap            src, msk;
    XColor            fg, bg;
    XImage           *img;
    XlibGC            gc = NULL;
    XGCValues         v;
    unsigned long     m;
    int               i;
d608 1
a608 1
	return;
d618 6
a623 6
	if (dmxScreen->bePixmapFormats[i].depth == 1) {
	    /* Create GC in the back-end servers */
	    gc = XCreateGC(dmxScreen->beDisplay, dmxScreen->scrnDefDrawables[i],
			   m, &v);
	    break;
	}
d629 1
a629 1
			pBits->width, pBits->height, 1);
d631 1
a631 1
			pBits->width, pBits->height, 1);
d634 4
a637 4
		       dmxScreen->beVisuals[dmxScreen->beDefVisualIndex].visual,
		       1, XYBitmap, 0, (char *)pBits->source,
		       pBits->width, pBits->height,
		       BitmapPad(dmxScreen->beDisplay), 0);
d640 1
a640 1
	      pBits->width, pBits->height);
d643 1
a643 1
  
d645 4
a648 4
		       dmxScreen->beVisuals[dmxScreen->beDefVisualIndex].visual,
		       1, XYBitmap, 0, (char *)pBits->mask,
		       pBits->width, pBits->height,
		       BitmapPad(dmxScreen->beDisplay), 0);
d651 1
a651 1
	      pBits->width, pBits->height);
d655 1
a655 1
    fg.red   = pCursor->foreRed;
d657 1
a657 1
    fg.blue  = pCursor->foreBlue;
d659 1
a659 1
    bg.red   = pCursor->backRed;
d661 1
a661 1
    bg.blue  = pCursor->backBlue;
d664 3
a666 3
					      src, msk,
					      &fg, &bg,
					      pBits->xhot, pBits->yhot);
d675 2
a676 1
static Bool _dmxRealizeCursor(ScreenPtr pScreen, CursorPtr pCursor)
d678 2
a679 2
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxCursorPrivPtr  pCursorPriv;
d685 1
a685 1
	return FALSE;
d688 1
a688 1
    pCursorPriv->cursor = (Cursor)0;
d691 1
a691 1
	return TRUE;
d698 2
a699 1
Bool dmxBEFreeCursor(ScreenPtr pScreen, CursorPtr pCursor)
d701 2
a702 2
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxCursorPrivPtr  pCursorPriv = DMX_GET_CURSOR_PRIV(pCursor, pScreen);
d705 3
a707 3
	XFreeCursor(dmxScreen->beDisplay, pCursorPriv->cursor);
	pCursorPriv->cursor = (Cursor)0;
	return TRUE;
d713 2
a714 1
static Bool _dmxUnrealizeCursor(ScreenPtr pScreen, CursorPtr pCursor)
d716 1
a716 1
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
d718 1
a718 2
    DMXDBG2("_dmxUnrealizeCursor(%d,%p)\n",
            pScreen->myNum, pCursor);
d721 2
a722 2
	if (dmxBEFreeCursor(pScreen, pCursor))
	    free(DMX_GET_CURSOR_PRIV(pCursor, pScreen));
d729 2
a730 1
static void _dmxMoveCursor(ScreenPtr pScreen, int x, int y)
d733 2
a734 2
    int           newX       = x + dmxScreen->rootX;
    int           newY       = y + dmxScreen->rootY;
d736 4
a739 2
    if (newX < 0) newX = 0;
    if (newY < 0) newY = 0;
d744 3
a746 3
	XWarpPointer(dmxScreen->beDisplay, None, dmxScreen->scrnWin,
		     0, 0, 0, 0, newX, newY);
	dmxSync(dmxScreen, TRUE);
d750 2
a751 1
static void _dmxSetCursor(ScreenPtr pScreen, CursorPtr pCursor, int x, int y)
d753 1
a753 1
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
d758 8
a765 7
	dmxCursorPrivPtr  pCursorPriv = DMX_GET_CURSOR_PRIV(pCursor, pScreen);
	if (pCursorPriv && dmxScreen->curCursor != pCursorPriv->cursor) {
	    if (dmxScreen->beDisplay)
		XDefineCursor(dmxScreen->beDisplay, dmxScreen->scrnWin,
			      pCursorPriv->cursor);
            dmxScreen->cursor        = pCursor;
	    dmxScreen->curCursor     = pCursorPriv->cursor;
d767 9
a775 8
	}
	_dmxMoveCursor(pScreen, x, y);
    } else {
	if (dmxScreen->beDisplay)
	    XDefineCursor(dmxScreen->beDisplay, dmxScreen->scrnWin,
			  dmxScreen->noCursor);
        dmxScreen->cursor        = NULL;
	dmxScreen->curCursor     = (Cursor)0;
d778 2
a779 1
    if (dmxScreen->beDisplay) dmxSync(dmxScreen, TRUE);
d782 2
a783 1
static Bool dmxRealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
d791 1
a791 1
    for (pt = start->over; /* condition at end of loop */; pt = pt->over) {
d801 2
a802 1
static Bool dmxUnrealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
d810 1
a810 1
    for (pt = start->over; /* condition at end of loop */; pt = pt->over) {
d820 2
a821 1
static CursorPtr dmxFindCursor(DMXScreenInfo *start)
d827 1
a827 1
    for (pt = start->over; /* condition at end of loop */; pt = pt->over) {
d845 2
a846 1
void dmxMoveCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
d858 1
a858 1
    for (pt = start->over; /* condition at end of loop */; pt = pt->over) {
d862 1
a862 1
            if (/* pt != start && */ !pt->cursorVisible) {
d864 3
a866 3
                                /* This only happens during
                                 * reconfiguration when a new overlap
                                 * occurs. */
d868 1
a868 1
                    
d872 1
a872 1
                    
d882 2
a883 1
        } else if (/* pt != start && */ pt->cursorVisible) {
d894 3
a896 1
static void dmxSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor, int x, int y)
d900 1
a900 1
    int           GX, GY, gx, gy;
d905 14
a918 14
                                /* We do this check here because of two cases:
                                 *
                                 * 1) if a client calls XWarpPointer()
                                 * and Xinerama is not running, we can
                                 * have mi's notion of the pointer
                                 * position out of phase with DMX's
                                 * notion.
                                 *
                                 * 2) if a down button is held while the
                                 * cursor moves outside the root window,
                                 * mi's notion of the pointer position
                                 * is out of phase with DMX's notion and
                                 * the cursor can remain visible when it
                                 * shouldn't be. */
d925 1
a925 1
    
d931 1
a931 1
    for (pt = start->over; /* condition at end of loop */; pt = pt->over) {
d938 2
a939 1
        } else {
a948 1

d952 2
a953 1
void dmxHideCursor(DMXScreenInfo *dmxScreen)
d955 1
a955 1
    int       x, y;
d964 2
a965 1
void dmxCheckCursor(void)
d967 3
a969 3
    int           i;
    int           x, y;
    ScreenPtr     pScreen;
d978 2
a979 1
        pScreen                  = screenInfo.screens[dmxScreen->index];
d982 5
a986 4
            if (firstScreen && i == miPointerGetScreen(inputInfo.pointer)->myNum)
                miPointerSetScreen(inputInfo.pointer, firstScreen->index, x, y);
            _dmxSetCursor(pScreen, NULL,
                          x - dmxScreen->rootXOrigin,
d988 2
a989 1
        } else {
d992 1
a992 1
                
d1005 2
a1006 1
static Bool dmxDeviceCursorInitialize(DeviceIntPtr pDev, ScreenPtr pScr)
d1011 2
a1012 1
static void dmxDeviceCursorCleanup(DeviceIntPtr pDev, ScreenPtr pScr)
d1016 1
a1016 2
miPointerSpriteFuncRec dmxPointerSpriteFuncs =
{
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d233 1
a233 1
    ScreenPtr       pScreen;
d242 1
d245 2
a246 2
            dixScreenOrigins[i].x = screen->whereX;
            dixScreenOrigins[i].y = screen->whereY;
d253 3
a255 2
            dixScreenOrigins[i].x = dixScreenOrigins[ref].x + screen->whereX;
            dixScreenOrigins[i].y = dixScreenOrigins[ref].y + screen->whereY;
d262 3
a264 3
            pScreen = screenInfo.screens[ref];
            dixScreenOrigins[i].x = dixScreenOrigins[ref].x + pScreen->width;
            dixScreenOrigins[i].y = dixScreenOrigins[ref].y;
d271 3
a273 3
            pScreen = screenInfo.screens[i];
            dixScreenOrigins[i].x = dixScreenOrigins[ref].x - pScreen->width;
            dixScreenOrigins[i].y = dixScreenOrigins[ref].y;
d280 3
a282 3
            pScreen = screenInfo.screens[ref];
            dixScreenOrigins[i].x = dixScreenOrigins[ref].x;
            dixScreenOrigins[i].y = dixScreenOrigins[ref].y + pScreen->height;
d289 3
a291 3
            pScreen = screenInfo.screens[i];
            dixScreenOrigins[i].x = dixScreenOrigins[ref].x;
            dixScreenOrigins[i].y = dixScreenOrigins[ref].y - pScreen->height;
d303 1
d319 3
a321 2
	    dixScreenOrigins[ref].x = dixScreenOrigins[ref].y = 0;
            screensLeft[ref]        = 0;
d329 2
a330 2
    minX = dixScreenOrigins[0].x;
    minY = dixScreenOrigins[0].y;
d332 4
a335 4
	if (dixScreenOrigins[i].x < minX)
            minX = dixScreenOrigins[i].x;
	if (dixScreenOrigins[i].y < minY)
            minY = dixScreenOrigins[i].y;
d339 2
a340 2
	    dixScreenOrigins[i].x -= minX;
	    dixScreenOrigins[i].y -= minY;
d405 2
a406 2
        dmxScreen->rootXOrigin = dixScreenOrigins[i].x;
        dmxScreen->rootYOrigin = dixScreenOrigins[i].y;
d670 1
a670 1
    DMX_SET_CURSOR_PRIV(pCursor, pScreen, xalloc(sizeof(*pCursorPriv)));
d708 1
a708 1
	    xfree(DMX_GET_CURSOR_PRIV(pCursor, pScreen));
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d93 1
d198 2
a199 2
    dmxeqEnqueue,        /*XXX incompatible type/function! */
    dmxeqSwitchScreen
d342 1
a342 1
 * either called from #dmxInitOrigins() or from #dmxReconfig(). */
d467 1
a467 1
/** Used with #dmxInterateOverlap to print out a list of screens which
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d181 1
a181 1
static void dmxWarpCursor(ScreenPtr pScreen, int x, int y)
d186 1
a186 1
    miPointerWarpCursor(pScreen, x, y);
d188 1
a188 1
    pScreen->SetCursorPosition(pScreen, x, y, FALSE);
d736 1
a736 1
	if (dmxScreen->curCursor != pCursorPriv->cursor) {
d756 1
a756 1
static Bool dmxRealizeCursor(ScreenPtr pScreen, CursorPtr pCursor)
d774 1
a774 1
static Bool dmxUnrealizeCursor(ScreenPtr pScreen, CursorPtr pCursor)
d797 1
a797 1
        return GetSpriteCursor();
d804 1
a804 1
    return GetSpriteCursor();
d816 1
a816 1
void dmxMoveCursor(ScreenPtr pScreen, int x, int y)
d863 1
a863 1
static void dmxSetCursor(ScreenPtr pScreen, CursorPtr pCursor, int x, int y)
a945 4
#if 00
            if (firstScreen && i == miPointerCurrentScreen()->myNum)
                miPointerSetNewScreen(firstScreen->index, x, y);
#else
a947 1
#endif
d967 9
d982 2
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
d132 2
a133 1
    if (screenInfo.numScreens == 1) return FALSE;
d140 2
a141 1
        && localY < dmxScreen->rootHeight) return FALSE;
d166 2
a167 1
            if (dmxScreen->index == (*ppScreen)->myNum) return FALSE;
d184 2
d187 3
d197 1
a197 1
    dmxeqEnqueue,
d208 2
a209 1
    for (i = 0; i < dmxNumScreens; i++) list[i] = 1;
d223 3
a225 1
    for (i = 0; i < dmxNumScreens; i++) if (list[i]) return i;
d238 2
a239 1
        if (!screensLeft[i]) continue;
d249 2
a250 1
            if (screensLeft[ref]) break;
d257 2
a258 1
            if (screensLeft[ref]) break;
d266 2
a267 1
            if (screensLeft[ref]) break;
d275 2
a276 1
            if (screensLeft[ref]) break;
d284 2
a285 1
            if (screensLeft[ref]) break;
d327 4
a330 2
	if (dixScreenOrigins[i].x < minX) minX = dixScreenOrigins[i].x;
	if (dixScreenOrigins[i].y < minY) minY = dixScreenOrigins[i].y;
d432 2
a433 1
                    a->rootYOrigin,                 b)) return 1;
d436 2
a437 1
                    a->rootYOrigin + a->scrnWidth,  b)) return 1;
d440 2
a441 1
                    a->rootYOrigin,                 b)) return 1;
d444 2
a445 1
                    a->rootYOrigin + a->scrnWidth,  b)) return 1;
d448 2
a449 1
                    b->rootYOrigin,                 a)) return 1;
d452 2
a453 1
                    b->rootYOrigin + b->scrnWidth,  a)) return 1;
d456 2
a457 1
                    b->rootYOrigin,                 a)) return 1;
d460 2
a461 1
                    b->rootYOrigin + b->scrnWidth,  a)) return 1;
d505 2
a506 1
    if (a == b) return a;
d519 2
a520 1
    for (i = 0; i < dmxNumScreens; i++) dmxScreens[i].over = NULL;
d527 2
a528 1
            if (b->over) continue;
d542 2
a543 1
        if (!a->over) continue;
d554 2
a555 1
                if (!dmxDoesOverlap(a, pt)) continue;
d665 2
a666 2
    pCursor->devPriv[pScreen->myNum] = xalloc(sizeof(*pCursorPriv));
    if (!pCursor->devPriv[pScreen->myNum])
d703 1
a703 1
	    xfree(pCursor->devPriv[pScreen->myNum]);
d705 1
a705 1
    pCursor->devPriv[pScreen->myNum] = NULL;
d765 2
a766 1
        if (pt->cursorNotShared) continue;
d768 2
a769 1
        if (pt == start) break;
d783 2
a784 1
        if (pt->cursorNotShared) continue;
d786 2
a787 1
        if (pt == start) break;
d796 2
a797 1
    if (!start || !start->over) return GetSpriteCursor();
d799 4
a802 2
        if (pt->cursor) return pt->cursor;
        if (pt == start) break;
d810 6
a815 1
 * newley overlapping screens and on screens that no longer overlap. */
d829 2
a830 1
        if (pt->cursorNotShared) continue;
d858 2
a859 1
        if (pt == start) break;
d891 1
a891 1
        dmxCoreMotion(gx, gy, 0, DMX_NO_BLOCK);
d899 2
a900 1
        if (pt->cursorNotShared) continue;
d910 2
a911 1
        if (pt == start) break;
d946 1
d949 4
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
d133 1
a133 2
    if (screenInfo.numScreens == 1)
        return FALSE;
d140 1
a140 2
        && localY < dmxScreen->rootHeight)
        return FALSE;
d165 1
a165 2
            if (dmxScreen->index == (*ppScreen)->myNum)
                return FALSE;
a181 2
#if 11 /*BP*/
    /* This call is depracated.  Replace with???? */
a182 3
#else
    pScreen->SetCursorPosition(pScreen, x, y, FALSE);
#endif
d190 1
a190 1
    dmxeqEnqueue,        /*XXX incompatible type/function! */
d201 1
a201 2
    for (i = 0; i < dmxNumScreens; i++)
        list[i] = 1;
d215 1
a215 3
    for (i = 0; i < dmxNumScreens; i++)
        if (list[i])
            return i;
d228 1
a228 2
        if (!screensLeft[i])
            continue;
d238 1
a238 2
            if (screensLeft[ref])
                break;
d245 1
a245 2
            if (screensLeft[ref])
                break;
d253 1
a253 2
            if (screensLeft[ref])
                break;
d261 1
a261 2
            if (screensLeft[ref])
                break;
d269 1
a269 2
            if (screensLeft[ref])
                break;
d311 2
a312 4
	if (dixScreenOrigins[i].x < minX)
            minX = dixScreenOrigins[i].x;
	if (dixScreenOrigins[i].y < minY)
            minY = dixScreenOrigins[i].y;
d414 1
a414 2
                    a->rootYOrigin,                 b))
        return 1;
d417 1
a417 2
                    a->rootYOrigin + a->scrnWidth,  b))
        return 1;
d420 1
a420 2
                    a->rootYOrigin,                 b))
        return 1;
d423 1
a423 2
                    a->rootYOrigin + a->scrnWidth,  b))
        return 1;
d426 1
a426 2
                    b->rootYOrigin,                 a))
        return 1;
d429 1
a429 2
                    b->rootYOrigin + b->scrnWidth,  a))
        return 1;
d432 1
a432 2
                    b->rootYOrigin,                 a))
        return 1;
d435 1
a435 2
                    b->rootYOrigin + b->scrnWidth,  a))
        return 1;
d479 1
a479 2
    if (a == b)
        return a;
d492 1
a492 2
    for (i = 0; i < dmxNumScreens; i++)
        dmxScreens[i].over = NULL;
d499 1
a499 2
            if (b->over)
                continue;
d513 1
a513 2
        if (!a->over)
            continue;
d524 1
a524 2
                if (!dmxDoesOverlap(a, pt))
                    continue;
d734 1
a734 2
        if (pt->cursorNotShared)
            continue;
d736 1
a736 2
        if (pt == start)
            break;
d750 1
a750 2
        if (pt->cursorNotShared)
            continue;
d752 1
a752 2
        if (pt == start)
            break;
d761 1
a761 2
    if (!start || !start->over)
        return GetSpriteCursor();
d763 2
a764 4
        if (pt->cursor)
            return pt->cursor;
        if (pt == start)
            break;
d772 1
a772 6
 * newley overlapping screens and on screens that no longer overlap.
 *
 * The coords (x,y) are in global coord space.  We'll loop over the
 * back-end screens and see if they contain the global coord.  If so, call
 * _dmxMoveCursor() (XWarpPointer) to position the pointer on that screen.
 */
d786 1
a786 2
        if (pt->cursorNotShared)
            continue;
d814 1
a814 2
        if (pt == start)
            break;
d846 1
a846 1
        dmxCoreMotion(NULL, gx, gy, 0, DMX_NO_BLOCK);
d854 1
a854 2
        if (pt->cursorNotShared)
            continue;
d864 1
a864 2
        if (pt == start)
            break;
a898 1
#if 00
a900 4
#else
            if (firstScreen && i == miPointerGetScreen(inputInfo.pointer)->myNum)
                miPointerSetScreen(inputInfo.pointer, firstScreen->index, x, y);
#endif
@

