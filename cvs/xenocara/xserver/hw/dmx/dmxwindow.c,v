head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	7pAEtF6Y5EgemkuY;

1.10
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.16;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.44;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.44;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.24;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Kevin E. Martin <kem@@redhat.com>
 *
 */

/** \file
 * This file provides support for window-related functions. */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include "dmx.h"
#include "dmxsync.h"
#include "dmxwindow.h"
#include "dmxpixmap.h"
#include "dmxcmap.h"
#include "dmxvisual.h"
#include "dmxinput.h"
#include "dmxextension.h"
#include "dmxpict.h"

#include "windowstr.h"

static void dmxDoRestackWindow(WindowPtr pWindow);
static void dmxDoChangeWindowAttributes(WindowPtr pWindow,
                                        unsigned long *mask,
                                        XSetWindowAttributes * attribs);

static void dmxDoSetShape(WindowPtr pWindow);

/** Initialize the private area for the window functions. */
Bool
dmxInitWindow(ScreenPtr pScreen)
{
    if (!dixRegisterPrivateKey
        (&dmxWinPrivateKeyRec, PRIVATE_WINDOW, sizeof(dmxWinPrivRec)))
        return FALSE;

    return TRUE;
}

Window
dmxCreateRootWindow(WindowPtr pWindow)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    Window parent;
    Visual *visual;
    unsigned long mask;
    XSetWindowAttributes attribs;
    ColormapPtr pCmap;
    dmxColormapPrivPtr pCmapPriv;

    /* Create root window */

    parent = dmxScreen->scrnWin;        /* This is our "Screen" window */
    visual = dmxScreen->beVisuals[dmxScreen->beDefVisualIndex].visual;

    dixLookupResourceByType((void **) &pCmap, wColormap(pWindow),
                            RT_COLORMAP, NullClient, DixUnknownAccess);
    pCmapPriv = DMX_GET_COLORMAP_PRIV(pCmap);

    mask = CWEventMask | CWBackingStore | CWColormap | CWBorderPixel;
    attribs.event_mask = ExposureMask;
    attribs.backing_store = NotUseful;
    attribs.colormap = pCmapPriv->cmap;
    attribs.border_pixel = 0;

    /* Incorporate new attributes, if needed */
    if (pWinPriv->attribMask) {
        dmxDoChangeWindowAttributes(pWindow, &pWinPriv->attribMask, &attribs);
        mask |= pWinPriv->attribMask;
    }

    return XCreateWindow(dmxScreen->beDisplay,
                         parent,
                         pWindow->origin.x - wBorderWidth(pWindow),
                         pWindow->origin.y - wBorderWidth(pWindow),
                         pWindow->drawable.width,
                         pWindow->drawable.height,
                         pWindow->borderWidth,
                         pWindow->drawable.depth,
                         pWindow->drawable.class, visual, mask, &attribs);
}

/** Change the location and size of the "screen" window.  Called from
 *  dmxextension.c dmxConfigureScreenWindow(). */
void
dmxResizeScreenWindow(ScreenPtr pScreen, int x, int y, int w, int h)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    unsigned int m;
    XWindowChanges c;

    if (!dmxScreen->beDisplay)
        return;

    /* Handle resizing on back-end server */
    m = CWX | CWY | CWWidth | CWHeight;
    c.x = x;
    c.y = y;
    c.width = w;
    c.height = h;

    XConfigureWindow(dmxScreen->beDisplay, dmxScreen->scrnWin, m, &c);
    dmxSync(dmxScreen, False);
}

/** Change the location and size of the "root" window.  Called from
 *  #dmxCreateWindow. */
void
dmxResizeRootWindow(WindowPtr pRoot, int x, int y, int w, int h)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pRoot->drawable.pScreen->myNum];
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pRoot);
    unsigned int m;
    XWindowChanges c;

    /* Handle resizing on back-end server */
    if (dmxScreen->beDisplay) {
        m = CWX | CWY | CWWidth | CWHeight;
        c.x = x;
        c.y = y;
        c.width = (w > 0) ? w : 1;
        c.height = (h > 0) ? h : 1;

        XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
    }

    if (w == 0 || h == 0) {
        if (pWinPriv->mapped) {
            if (dmxScreen->beDisplay)
                XUnmapWindow(dmxScreen->beDisplay, pWinPriv->window);
            pWinPriv->mapped = FALSE;
        }
    }
    else if (!pWinPriv->mapped) {
        if (dmxScreen->beDisplay)
            XMapWindow(dmxScreen->beDisplay, pWinPriv->window);
        pWinPriv->mapped = TRUE;
    }

    if (dmxScreen->beDisplay)
        dmxSync(dmxScreen, False);
}

void
dmxGetDefaultWindowAttributes(WindowPtr pWindow,
                              Colormap * cmap, Visual ** visual)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;

    if (pWindow->drawable.class != InputOnly &&
        pWindow->optional &&
        pWindow->optional->visual != wVisual(pWindow->parent)) {

        /* Find the matching visual */
        *visual = dmxLookupVisualFromID(pScreen, wVisual(pWindow));

        /* Handle optional colormaps */
        if (pWindow->optional->colormap) {
            ColormapPtr pCmap;
            dmxColormapPrivPtr pCmapPriv;

            dixLookupResourceByType((void **) &pCmap, wColormap(pWindow),
                                    RT_COLORMAP, NullClient, DixUnknownAccess);
            pCmapPriv = DMX_GET_COLORMAP_PRIV(pCmap);
            *cmap = pCmapPriv->cmap;
        }
        else {
            *cmap = dmxColormapFromDefaultVisual(pScreen, *visual);
        }
    }
    else {
        *visual = CopyFromParent;
        *cmap = (Colormap) 0;
    }
}

static Window
dmxCreateNonRootWindow(WindowPtr pWindow)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    Window parent;
    unsigned long mask = 0L;
    XSetWindowAttributes attribs;
    dmxWinPrivPtr pParentPriv = DMX_GET_WINDOW_PRIV(pWindow->parent);

    /* Create window on back-end server */

    parent = pParentPriv->window;

    /* The parent won't exist if this call to CreateNonRootWindow came
       from ReparentWindow and the grandparent window has not yet been
       created */
    if (!parent) {
        dmxCreateAndRealizeWindow(pWindow->parent, FALSE);
        parent = pParentPriv->window;
    }

    /* Incorporate new attributes, if needed */
    if (pWinPriv->attribMask) {
        dmxDoChangeWindowAttributes(pWindow, &pWinPriv->attribMask, &attribs);
        mask |= pWinPriv->attribMask;
    }

    /* Add in default attributes */
    if (pWindow->drawable.class != InputOnly) {
        mask |= CWBackingStore;
        attribs.backing_store = NotUseful;

        if (!(mask & CWColormap) && pWinPriv->cmap) {
            mask |= CWColormap;
            attribs.colormap = pWinPriv->cmap;
            if (!(mask & CWBorderPixel)) {
                mask |= CWBorderPixel;
                attribs.border_pixel = 0;
            }
        }
    }

    /* Handle case where subwindows are being mapped, but created out of
       order -- if current window has a previous sibling, then it cannot
       be created on top of the stack, so we must restack the windows */
    pWinPriv->restacked = (pWindow->prevSib != NullWindow);

    return XCreateWindow(dmxScreen->beDisplay,
                         parent,
                         pWindow->origin.x - wBorderWidth(pWindow),
                         pWindow->origin.y - wBorderWidth(pWindow),
                         pWindow->drawable.width,
                         pWindow->drawable.height,
                         pWindow->borderWidth,
                         pWindow->drawable.depth,
                         pWindow->drawable.class,
                         pWinPriv->visual, mask, &attribs);
}

/** This function handles lazy window creation and realization.  Window
 *  creation is handled by #dmxCreateNonRootWindow().  It also handles
 *  any stacking changes that have occured since the window was
 *  originally created by calling #dmxDoRestackWindow().  If the window
 *  is shaped, the shape is set on the back-end server by calling
 *  #dmxDoSetShape(), and if the window has pictures (from RENDER)
 *  associated with it, those pictures are created on the back-end
 *  server by calling #dmxCreatePictureList().  If \a doSync is TRUE,
 *  then #dmxSync() is called. */
void
dmxCreateAndRealizeWindow(WindowPtr pWindow, Bool doSync)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);

    if (!dmxScreen->beDisplay)
        return;

    pWinPriv->window = dmxCreateNonRootWindow(pWindow);
    if (pWinPriv->restacked)
        dmxDoRestackWindow(pWindow);
    if (pWinPriv->isShaped)
        dmxDoSetShape(pWindow);
    if (pWinPriv->hasPict)
        dmxCreatePictureList(pWindow);
    if (pWinPriv->mapped)
        XMapWindow(dmxScreen->beDisplay, pWinPriv->window);
    if (doSync)
        dmxSync(dmxScreen, False);
}

/** Create \a pWindow on the back-end server.  If the lazy window
 *  creation optimization is enabled, then the actual creation and
 *  realization of the window is handled by
 *  #dmxCreateAndRealizeWindow(). */
Bool
dmxCreateWindow(WindowPtr pWindow)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    Bool ret = TRUE;

    DMX_UNWRAP(CreateWindow, dmxScreen, pScreen);
#if 0
    if (pScreen->CreateWindow)
        ret = pScreen->CreateWindow(pWindow);
#endif

    /* Set up the defaults */
    pWinPriv->window = (Window) 0;
    pWinPriv->offscreen = TRUE;
    pWinPriv->mapped = FALSE;
    pWinPriv->restacked = FALSE;
    pWinPriv->attribMask = 0;
    pWinPriv->isShaped = FALSE;
    pWinPriv->hasPict = FALSE;
#ifdef GLXEXT
    pWinPriv->swapGroup = NULL;
    pWinPriv->barrier = 0;
#endif

    if (dmxScreen->beDisplay) {
        /* Only create the root window at this stage -- non-root windows are
           created when they are mapped and are on-screen */
        if (!pWindow->parent) {
            dmxScreen->rootWin = pWinPriv->window
                = dmxCreateRootWindow(pWindow);
            if (dmxScreen->scrnX != dmxScreen->rootX
                || dmxScreen->scrnY != dmxScreen->rootY
                || dmxScreen->scrnWidth != dmxScreen->rootWidth
                || dmxScreen->scrnHeight != dmxScreen->rootHeight) {
                dmxResizeRootWindow(pWindow,
                                    dmxScreen->rootX,
                                    dmxScreen->rootY,
                                    dmxScreen->rootWidth,
                                    dmxScreen->rootHeight);
                dmxUpdateScreenResources(screenInfo.screens[dmxScreen->index],
                                         dmxScreen->rootX,
                                         dmxScreen->rootY,
                                         dmxScreen->rootWidth,
                                         dmxScreen->rootHeight);
                pWindow->origin.x = dmxScreen->rootX;
                pWindow->origin.y = dmxScreen->rootY;
            }
        }
        else {
            dmxGetDefaultWindowAttributes(pWindow,
                                          &pWinPriv->cmap, &pWinPriv->visual);

            if (dmxLazyWindowCreation) {
                /* Save parent's visual for use later */
                if (pWinPriv->visual == CopyFromParent)
                    pWinPriv->visual =
                        dmxLookupVisualFromID(pScreen,
                                              wVisual(pWindow->parent));
            }
            else {
                pWinPriv->window = dmxCreateNonRootWindow(pWindow);
            }
        }

        dmxSync(dmxScreen, False);
    }

    DMX_WRAP(CreateWindow, dmxCreateWindow, dmxScreen, pScreen);

    return ret;
}

/** Destroy \a pWindow on the back-end server. */
Bool
dmxBEDestroyWindow(WindowPtr pWindow)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);

    if (pWinPriv->window) {
        XDestroyWindow(dmxScreen->beDisplay, pWinPriv->window);
        pWinPriv->window = (Window) 0;
        return TRUE;
    }

    return FALSE;
}

/** Destroy \a pWindow on the back-end server.  If any RENDER pictures
    were created, destroy them as well. */
Bool
dmxDestroyWindow(WindowPtr pWindow)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    Bool ret = TRUE;
    Bool needSync = FALSE;

#ifdef GLXEXT
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
#endif

    DMX_UNWRAP(DestroyWindow, dmxScreen, pScreen);

    /* Destroy any picture list associated with this window */
    needSync |= dmxDestroyPictureList(pWindow);

    /* Destroy window on back-end server */
    needSync |= dmxBEDestroyWindow(pWindow);
    if (needSync)
        dmxSync(dmxScreen, FALSE);

#ifdef GLXEXT
    if (pWinPriv->swapGroup && pWinPriv->windowDestroyed)
        pWinPriv->windowDestroyed(pWindow);
#endif

    if (pScreen->DestroyWindow)
        ret = pScreen->DestroyWindow(pWindow);

    DMX_WRAP(DestroyWindow, dmxDestroyWindow, dmxScreen, pScreen);

    return ret;
}

/** Change the position of \a pWindow to be \a x, \a y. */
Bool
dmxPositionWindow(WindowPtr pWindow, int x, int y)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    Bool ret = TRUE;
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    unsigned int m;
    XWindowChanges c;

    DMX_UNWRAP(PositionWindow, dmxScreen, pScreen);
#if 0
    if (pScreen->PositionWindow)
        ret = pScreen->PositionWindow(pWindow, x, y);
#endif

    /* Determine if the window is completely off the visible portion of
       the screen */
    pWinPriv->offscreen = DMX_WINDOW_OFFSCREEN(pWindow);

    /* If the window is now on-screen and it is mapped and it has not
       been created yet, create it and map it */
    if (!pWinPriv->window && pWinPriv->mapped && !pWinPriv->offscreen) {
        dmxCreateAndRealizeWindow(pWindow, TRUE);
    }
    else if (pWinPriv->window) {
        /* Position window on back-end server */
        m = CWX | CWY | CWWidth | CWHeight;
        c.x = pWindow->origin.x - wBorderWidth(pWindow);
        c.y = pWindow->origin.y - wBorderWidth(pWindow);
        c.width = pWindow->drawable.width;
        c.height = pWindow->drawable.height;
        if (pWindow->drawable.class != InputOnly) {
            m |= CWBorderWidth;
            c.border_width = pWindow->borderWidth;
        }

        XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
        dmxSync(dmxScreen, False);
    }

    DMX_WRAP(PositionWindow, dmxPositionWindow, dmxScreen, pScreen);

    return ret;
}

static void
dmxDoChangeWindowAttributes(WindowPtr pWindow,
                            unsigned long *mask, XSetWindowAttributes * attribs)
{
    dmxPixPrivPtr pPixPriv;

    if (*mask & CWBackPixmap) {
        switch (pWindow->backgroundState) {
        case None:
            attribs->background_pixmap = None;
            break;

        case ParentRelative:
            attribs->background_pixmap = ParentRelative;
            break;

        case BackgroundPixmap:
            pPixPriv = DMX_GET_PIXMAP_PRIV(pWindow->background.pixmap);
            attribs->background_pixmap = pPixPriv->pixmap;
            break;

        case BackgroundPixel:
            *mask &= ~CWBackPixmap;
            break;
        }
    }

    if (*mask & CWBackPixel) {
        if (pWindow->backgroundState == BackgroundPixel)
            attribs->background_pixel = pWindow->background.pixel;
        else
            *mask &= ~CWBackPixel;
    }

    if (*mask & CWBorderPixmap) {
        if (pWindow->borderIsPixel)
            *mask &= ~CWBorderPixmap;
        else {
            pPixPriv = DMX_GET_PIXMAP_PRIV(pWindow->border.pixmap);
            attribs->border_pixmap = pPixPriv->pixmap;
        }
    }

    if (*mask & CWBorderPixel) {
        if (pWindow->borderIsPixel)
            attribs->border_pixel = pWindow->border.pixel;
        else
            *mask &= ~CWBorderPixel;
    }

    if (*mask & CWBitGravity)
        attribs->bit_gravity = pWindow->bitGravity;

    if (*mask & CWWinGravity)
        *mask &= ~CWWinGravity; /* Handled by dix */

    if (*mask & CWBackingStore)
        *mask &= ~CWBackingStore;       /* Backing store not supported */

    if (*mask & CWBackingPlanes)
        *mask &= ~CWBackingPlanes;      /* Backing store not supported */

    if (*mask & CWBackingPixel)
        *mask &= ~CWBackingPixel;       /* Backing store not supported */

    if (*mask & CWOverrideRedirect)
        attribs->override_redirect = pWindow->overrideRedirect;

    if (*mask & CWSaveUnder)
        *mask &= ~CWSaveUnder;  /* Save unders not supported */

    if (*mask & CWEventMask)
        *mask &= ~CWEventMask;  /* Events are handled by dix */

    if (*mask & CWDontPropagate)
        *mask &= ~CWDontPropagate;      /* Events are handled by dix */

    if (*mask & CWColormap) {
        ColormapPtr pCmap;
        dmxColormapPrivPtr pCmapPriv;

        dixLookupResourceByType((void **) &pCmap, wColormap(pWindow),
                                RT_COLORMAP, NullClient, DixUnknownAccess);
        pCmapPriv = DMX_GET_COLORMAP_PRIV(pCmap);
        attribs->colormap = pCmapPriv->cmap;
    }

    if (*mask & CWCursor)
        *mask &= ~CWCursor;     /* Handled by the cursor code */
}

/** Change the window attributes of \a pWindow. */
Bool
dmxChangeWindowAttributes(WindowPtr pWindow, unsigned long mask)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    Bool ret = TRUE;
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    XSetWindowAttributes attribs;

    DMX_UNWRAP(ChangeWindowAttributes, dmxScreen, pScreen);
#if 0
    if (pScreen->ChangeWindowAttributes)
        ret = pScreen->ChangeWindowAttributes(pWindow, mask);
#endif

    /* Change window attribs on back-end server */
    dmxDoChangeWindowAttributes(pWindow, &mask, &attribs);

    /* Save mask for lazy window creation optimization */
    pWinPriv->attribMask |= mask;

    if (mask && pWinPriv->window) {
        XChangeWindowAttributes(dmxScreen->beDisplay, pWinPriv->window,
                                mask, &attribs);
        dmxSync(dmxScreen, False);
    }

    DMX_WRAP(ChangeWindowAttributes, dmxChangeWindowAttributes, dmxScreen,
             pScreen);

    return ret;
}

/** Realize \a pWindow on the back-end server.  If the lazy window
 *  creation optimization is enabled, the window is only realized when
 *  it at least partially overlaps the screen. */
Bool
dmxRealizeWindow(WindowPtr pWindow)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    Bool ret = TRUE;
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);

    DMX_UNWRAP(RealizeWindow, dmxScreen, pScreen);
#if 0
    if (pScreen->RealizeWindow)
        ret = pScreen->RealizeWindow(pWindow);
#endif

    /* Determine if the window is completely off the visible portion of
       the screen */
    pWinPriv->offscreen = DMX_WINDOW_OFFSCREEN(pWindow);

    /* If the window hasn't been created and it's not offscreen, then
       create it */
    if (!pWinPriv->window && !pWinPriv->offscreen) {
        dmxCreateAndRealizeWindow(pWindow, FALSE);
    }

    if (pWinPriv->window) {
        /* Realize window on back-end server */
        XMapWindow(dmxScreen->beDisplay, pWinPriv->window);
        dmxSync(dmxScreen, False);
    }

    /* Let the other functions know that the window is now mapped */
    pWinPriv->mapped = TRUE;

    DMX_WRAP(RealizeWindow, dmxRealizeWindow, dmxScreen, pScreen);

    dmxUpdateWindowInfo(DMX_UPDATE_REALIZE, pWindow);
    return ret;
}

/** Unrealize \a pWindow on the back-end server. */
Bool
dmxUnrealizeWindow(WindowPtr pWindow)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    Bool ret = TRUE;
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);

    DMX_UNWRAP(UnrealizeWindow, dmxScreen, pScreen);
#if 0
    if (pScreen->UnrealizeWindow)
        ret = pScreen->UnrealizeWindow(pWindow);
#endif

    if (pWinPriv->window) {
        /* Unrealize window on back-end server */
        XUnmapWindow(dmxScreen->beDisplay, pWinPriv->window);
        dmxSync(dmxScreen, False);
    }

    /* When unrealized (i.e., unmapped), the window is always considered
       off of the visible portion of the screen */
    pWinPriv->offscreen = TRUE;
    pWinPriv->mapped = FALSE;

#ifdef GLXEXT
    if (pWinPriv->swapGroup && pWinPriv->windowUnmapped)
        pWinPriv->windowUnmapped(pWindow);
#endif

    DMX_WRAP(UnrealizeWindow, dmxUnrealizeWindow, dmxScreen, pScreen);

    dmxUpdateWindowInfo(DMX_UPDATE_UNREALIZE, pWindow);
    return ret;
}

static void
dmxDoRestackWindow(WindowPtr pWindow)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    WindowPtr pNextSib = pWindow->nextSib;
    unsigned int m;
    XWindowChanges c;

    if (pNextSib == NullWindow) {
        /* Window is at the bottom of the stack */
        m = CWStackMode;
        c.sibling = (Window) 0;
        c.stack_mode = Below;
        XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
    }
    else {
        /* Window is not at the bottom of the stack */
        dmxWinPrivPtr pNextSibPriv = DMX_GET_WINDOW_PRIV(pNextSib);

        /* Handle case where siblings have not yet been created due to
           lazy window creation optimization by first finding the next
           sibling in the sibling list that has been created (if any)
           and then putting the current window just above that sibling,
           and if no next siblings have been created yet, then put it at
           the bottom of the stack (since it might have a previous
           sibling that should be above it). */
        while (!pNextSibPriv->window) {
            pNextSib = pNextSib->nextSib;
            if (pNextSib == NullWindow) {
                /* Window is at the bottom of the stack */
                m = CWStackMode;
                c.sibling = (Window) 0;
                c.stack_mode = Below;
                XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
                return;
            }
            pNextSibPriv = DMX_GET_WINDOW_PRIV(pNextSib);
        }

        m = CWStackMode | CWSibling;
        c.sibling = pNextSibPriv->window;
        c.stack_mode = Above;
        XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
    }
}

/** Handle window restacking.  The actual restacking occurs in
 *  #dmxDoRestackWindow(). */
void
dmxRestackWindow(WindowPtr pWindow, WindowPtr pOldNextSib)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);

    DMX_UNWRAP(RestackWindow, dmxScreen, pScreen);
#if 0
    if (pScreen->RestackWindow)
        pScreen->RestackWindow(pWindow, pOldNextSib);
#endif

    if (pOldNextSib != pWindow->nextSib) {
        /* Track restacking for lazy window creation optimization */
        pWinPriv->restacked = TRUE;

        /* Restack window on back-end server */
        if (pWinPriv->window) {
            dmxDoRestackWindow(pWindow);
            dmxSync(dmxScreen, False);
        }
    }

    DMX_WRAP(RestackWindow, dmxRestackWindow, dmxScreen, pScreen);
    dmxUpdateWindowInfo(DMX_UPDATE_RESTACK, pWindow);
}

static Bool
dmxWindowExposurePredicate(Display * dpy, XEvent * ev, XPointer ptr)
{
    return (ev->type == Expose && ev->xexpose.window == *(Window *) ptr);
}

/** Handle exposures on \a pWindow.  Since window exposures are handled
 *  in DMX, the events that are generated by the back-end server are
 *  redundant, so we eat them here. */
void
dmxWindowExposures(WindowPtr pWindow, RegionPtr prgn)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    XEvent ev;

    DMX_UNWRAP(WindowExposures, dmxScreen, pScreen);

    dmxSync(dmxScreen, False);

    if (pWinPriv->window) {
        while (XCheckIfEvent(dmxScreen->beDisplay, &ev,
                             dmxWindowExposurePredicate,
                             (XPointer) &pWinPriv->window)) {
            /* Handle expose events -- this should not be necessary
               since the base window in which the root window was
               created is guaranteed to be on top (override_redirect),
               so we should just swallow these events.  If for some
               reason the window is not on top, then we'd need to
               collect these events and send them to the client later
               (e.g., during the block handler as Xnest does). */
        }
    }

#if 1
    if (pScreen->WindowExposures)
        pScreen->WindowExposures(pWindow, prgn);
#endif
    DMX_WRAP(WindowExposures, dmxWindowExposures, dmxScreen, pScreen);
}

/** Move \a pWindow on the back-end server.  Determine whether or not it
 *  is on or offscreen, and realize it if it is newly on screen and the
 *  lazy window creation optimization is enabled. */
void
dmxCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    unsigned int m;
    XWindowChanges c;

    DMX_UNWRAP(CopyWindow, dmxScreen, pScreen);
#if 0
    if (pScreen->CopyWindow)
        pScreen->CopyWindow(pWindow, ptOldOrg, prgnSrc);
#endif

    /* Determine if the window is completely off the visible portion of
       the screen */
    pWinPriv->offscreen = DMX_WINDOW_OFFSCREEN(pWindow);

    /* If the window is now on-screen and it is mapped and it has not
       been created yet, create it and map it */
    if (!pWinPriv->window && pWinPriv->mapped && !pWinPriv->offscreen) {
        dmxCreateAndRealizeWindow(pWindow, TRUE);
    }
    else if (pWinPriv->window) {
        /* Move window on back-end server */
        m = CWX | CWY | CWWidth | CWHeight;
        c.x = pWindow->origin.x - wBorderWidth(pWindow);
        c.y = pWindow->origin.y - wBorderWidth(pWindow);
        c.width = pWindow->drawable.width;
        c.height = pWindow->drawable.height;

        XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
        dmxSync(dmxScreen, False);
    }

    DMX_WRAP(CopyWindow, dmxCopyWindow, dmxScreen, pScreen);
    dmxUpdateWindowInfo(DMX_UPDATE_COPY, pWindow);
}

/** Resize \a pWindow on the back-end server.  Determine whether or not
 *  it is on or offscreen, and realize it if it is newly on screen and
 *  the lazy window creation optimization is enabled. */
void
dmxResizeWindow(WindowPtr pWindow, int x, int y,
                unsigned int w, unsigned int h, WindowPtr pSib)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    unsigned int m;
    XWindowChanges c;

    DMX_UNWRAP(ResizeWindow, dmxScreen, pScreen);
#if 1
    if (pScreen->ResizeWindow)
        pScreen->ResizeWindow(pWindow, x, y, w, h, pSib);
#endif

    /* Determine if the window is completely off the visible portion of
       the screen */
    pWinPriv->offscreen = DMX_WINDOW_OFFSCREEN(pWindow);

    /* If the window is now on-screen and it is mapped and it has not
       been created yet, create it and map it */
    if (!pWinPriv->window && pWinPriv->mapped && !pWinPriv->offscreen) {
        dmxCreateAndRealizeWindow(pWindow, TRUE);
    }
    else if (pWinPriv->window) {
        /* Handle resizing on back-end server */
        m = CWX | CWY | CWWidth | CWHeight;
        c.x = pWindow->origin.x - wBorderWidth(pWindow);
        c.y = pWindow->origin.y - wBorderWidth(pWindow);
        c.width = pWindow->drawable.width;
        c.height = pWindow->drawable.height;

        XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
        dmxSync(dmxScreen, False);
    }

    DMX_WRAP(ResizeWindow, dmxResizeWindow, dmxScreen, pScreen);
    dmxUpdateWindowInfo(DMX_UPDATE_RESIZE, pWindow);
}

/** Reparent \a pWindow on the back-end server. */
void
dmxReparentWindow(WindowPtr pWindow, WindowPtr pPriorParent)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    dmxWinPrivPtr pParentPriv = DMX_GET_WINDOW_PRIV(pWindow->parent);

    DMX_UNWRAP(ReparentWindow, dmxScreen, pScreen);
#if 0
    if (pScreen->ReparentWindow)
        pScreen->ReparentWindow(pWindow, pPriorParent);
#endif

    if (pWinPriv->window) {
        if (!pParentPriv->window) {
            dmxCreateAndRealizeWindow(pWindow->parent, FALSE);
        }

        /* Handle reparenting on back-end server */
        XReparentWindow(dmxScreen->beDisplay, pWinPriv->window,
                        pParentPriv->window,
                        pWindow->origin.x - wBorderWidth(pWindow),
                        pWindow->origin.x - wBorderWidth(pWindow));
        dmxSync(dmxScreen, False);
    }

    DMX_WRAP(ReparentWindow, dmxReparentWindow, dmxScreen, pScreen);
    dmxUpdateWindowInfo(DMX_UPDATE_REPARENT, pWindow);
}

/** Change border width for \a pWindow to \a width pixels. */
void
dmxChangeBorderWidth(WindowPtr pWindow, unsigned int width)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    unsigned int m;
    XWindowChanges c;

    DMX_UNWRAP(ChangeBorderWidth, dmxScreen, pScreen);
#if 1
    if (pScreen->ChangeBorderWidth)
        pScreen->ChangeBorderWidth(pWindow, width);
#endif

    /* NOTE: Do we need to check for on/off screen here? */

    if (pWinPriv->window) {
        /* Handle border width change on back-end server */
        m = CWBorderWidth;
        c.border_width = width;

        XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
        dmxSync(dmxScreen, False);
    }

    DMX_WRAP(ChangeBorderWidth, dmxChangeBorderWidth, dmxScreen, pScreen);
}

static void
dmxDoSetShape(WindowPtr pWindow)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    int nBox;
    BoxPtr pBox;
    int nRect;
    XRectangle *pRect;
    XRectangle *pRectFirst;

    /* First, set the bounding shape */
    if (wBoundingShape(pWindow)) {
        pBox = RegionRects(wBoundingShape(pWindow));
        nRect = nBox = RegionNumRects(wBoundingShape(pWindow));
        pRectFirst = pRect = xallocarray(nRect, sizeof(*pRect));
        while (nBox--) {
            pRect->x = pBox->x1;
            pRect->y = pBox->y1;
            pRect->width = pBox->x2 - pBox->x1;
            pRect->height = pBox->y2 - pBox->y1;
            pBox++;
            pRect++;
        }
        XShapeCombineRectangles(dmxScreen->beDisplay, pWinPriv->window,
                                ShapeBounding, 0, 0,
                                pRectFirst, nRect, ShapeSet, YXBanded);
        free(pRectFirst);
    }
    else {
        XShapeCombineMask(dmxScreen->beDisplay, pWinPriv->window,
                          ShapeBounding, 0, 0, None, ShapeSet);
    }

    /* Next, set the clip shape */
    if (wClipShape(pWindow)) {
        pBox = RegionRects(wClipShape(pWindow));
        nRect = nBox = RegionNumRects(wClipShape(pWindow));
        pRectFirst = pRect = xallocarray(nRect, sizeof(*pRect));
        while (nBox--) {
            pRect->x = pBox->x1;
            pRect->y = pBox->y1;
            pRect->width = pBox->x2 - pBox->x1;
            pRect->height = pBox->y2 - pBox->y1;
            pBox++;
            pRect++;
        }
        XShapeCombineRectangles(dmxScreen->beDisplay, pWinPriv->window,
                                ShapeClip, 0, 0,
                                pRectFirst, nRect, ShapeSet, YXBanded);
        free(pRectFirst);
    }
    else {
        XShapeCombineMask(dmxScreen->beDisplay, pWinPriv->window,
                          ShapeClip, 0, 0, None, ShapeSet);
    }

    if (XShapeInputSelected(dmxScreen->beDisplay, pWinPriv->window)) {
        ErrorF("Input selected for window %x on Screen %d\n",
               (unsigned int) pWinPriv->window, pScreen->myNum);
    }
}

/** Set shape of \a pWindow on the back-end server. */
void
dmxSetShape(WindowPtr pWindow, int kind)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);

    DMX_UNWRAP(SetShape, dmxScreen, pScreen);
#if 1
    if (pScreen->SetShape)
        pScreen->SetShape(pWindow, kind);
#endif

    if (pWinPriv->window) {
        /* Handle setting the current shape on the back-end server */
        dmxDoSetShape(pWindow);
        dmxSync(dmxScreen, False);
    }
    else {
        pWinPriv->isShaped = TRUE;
    }

    DMX_WRAP(SetShape, dmxSetShape, dmxScreen, pScreen);
}
@


1.11
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d972 1
a972 1
        pRectFirst = pRect = malloc(nRect * sizeof(*pRect));
d995 1
a995 1
        pRectFirst = pRect = malloc(nRect * sizeof(*pRect));
@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a859 1
    dmxWinPrivPtr pSibPriv;
a861 3

    if (pSib)
        pSibPriv = DMX_GET_WINDOW_PRIV(pSib);
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d775 1
a775 1
dmxWindowExposures(WindowPtr pWindow, RegionPtr prgn, RegionPtr other_exposed)
d802 1
a802 1
        pScreen->WindowExposures(pWindow, prgn, other_exposed);
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d89 1
a89 1
    dixLookupResourceByType((pointer *) &pCmap, wColormap(pWindow),
d195 1
a195 1
            dixLookupResourceByType((pointer *) &pCmap, wColormap(pWindow),
d564 1
a564 1
        dixLookupResourceByType((pointer *) &pCmap, wColormap(pWindow),
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d789 1
a789 1
                             (XPointer) & pWinPriv->window)) {
@


1.6
log
@Update to xserver 1.11.2
@
text
@d55 2
a56 2
					unsigned long *mask,
					XSetWindowAttributes *attribs);
d61 2
a62 1
Bool dmxInitWindow(ScreenPtr pScreen)
d64 3
a66 2
    if (!dixRegisterPrivateKey(&dmxWinPrivateKeyRec, PRIVATE_WINDOW, sizeof(dmxWinPrivRec)))
	return FALSE;
d71 2
a72 2

Window dmxCreateRootWindow(WindowPtr pWindow)
d74 9
a82 9
    ScreenPtr             pScreen   = pWindow->drawable.pScreen;
    DMXScreenInfo        *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr         pWinPriv  = DMX_GET_WINDOW_PRIV(pWindow);
    Window                parent;
    Visual               *visual;
    unsigned long         mask;
    XSetWindowAttributes  attribs;
    ColormapPtr           pCmap;
    dmxColormapPrivPtr    pCmapPriv;
d86 1
a86 1
    parent = dmxScreen->scrnWin; /* This is our "Screen" window */
d89 2
a90 2
    dixLookupResourceByType((pointer*) &pCmap, wColormap(pWindow),
			    RT_COLORMAP, NullClient, DixUnknownAccess);
d94 1
a94 1
    attribs.event_mask    = ExposureMask;
d96 2
a97 2
    attribs.colormap      = pCmapPriv->cmap;
    attribs.border_pixel  = 0;
d101 2
a102 2
	dmxDoChangeWindowAttributes(pWindow, &pWinPriv->attribMask, &attribs);
	mask |= pWinPriv->attribMask;
d106 8
a113 11
			 parent,
			 pWindow->origin.x - wBorderWidth(pWindow),
			 pWindow->origin.y - wBorderWidth(pWindow),
			 pWindow->drawable.width,
			 pWindow->drawable.height,
			 pWindow->borderWidth,
			 pWindow->drawable.depth,
			 pWindow->drawable.class,
			 visual,
			 mask,
			 &attribs);
d118 2
a119 2
void dmxResizeScreenWindow(ScreenPtr pScreen,
			   int x, int y, int w, int h)
d121 3
a123 3
    DMXScreenInfo  *dmxScreen = &dmxScreens[pScreen->myNum];
    unsigned int    m;
    XWindowChanges  c;
d126 1
a126 1
	return;
d141 2
a142 2
void dmxResizeRootWindow(WindowPtr pRoot,
			 int x, int y, int w, int h)
d144 4
a147 4
    DMXScreenInfo  *dmxScreen = &dmxScreens[pRoot->drawable.pScreen->myNum];
    dmxWinPrivPtr   pWinPriv = DMX_GET_WINDOW_PRIV(pRoot);
    unsigned int    m;
    XWindowChanges  c;
d151 5
a155 5
	m = CWX | CWY | CWWidth | CWHeight;
	c.x = x;
	c.y = y;
	c.width = (w > 0) ? w : 1;
	c.height = (h > 0) ? h : 1;
d157 1
a157 1
	XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
d161 10
a170 9
	if (pWinPriv->mapped) {
	    if (dmxScreen->beDisplay)
		XUnmapWindow(dmxScreen->beDisplay, pWinPriv->window);
	    pWinPriv->mapped = FALSE;
	}
    } else if (!pWinPriv->mapped) {
	if (dmxScreen->beDisplay)
	    XMapWindow(dmxScreen->beDisplay, pWinPriv->window);
	pWinPriv->mapped = TRUE;
d174 1
a174 1
	dmxSync(dmxScreen, False);
d177 3
a179 3
void dmxGetDefaultWindowAttributes(WindowPtr pWindow,
				   Colormap *cmap,
				   Visual **visual)
d181 1
a181 1
    ScreenPtr  pScreen = pWindow->drawable.pScreen;
d184 5
a188 2
	pWindow->optional &&
	pWindow->optional->visual != wVisual(pWindow->parent)) {
d190 4
a193 2
	/* Find the matching visual */
	*visual = dmxLookupVisualFromID(pScreen, wVisual(pWindow));
d195 12
a206 15
	/* Handle optional colormaps */
	if (pWindow->optional->colormap) {
	    ColormapPtr         pCmap;
	    dmxColormapPrivPtr  pCmapPriv;

	    dixLookupResourceByType((pointer*) &pCmap, wColormap(pWindow),
				    RT_COLORMAP, NullClient, DixUnknownAccess);
	    pCmapPriv = DMX_GET_COLORMAP_PRIV(pCmap);
	    *cmap = pCmapPriv->cmap;
	} else {
	    *cmap = dmxColormapFromDefaultVisual(pScreen, *visual);
	}
    } else {
	*visual = CopyFromParent;
	*cmap = (Colormap)0;
d210 10
a219 9
static Window dmxCreateNonRootWindow(WindowPtr pWindow)
{
    ScreenPtr             pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo        *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr         pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    Window                parent;
    unsigned long         mask = 0L;
    XSetWindowAttributes  attribs;
    dmxWinPrivPtr         pParentPriv = DMX_GET_WINDOW_PRIV(pWindow->parent);
d229 2
a230 2
	dmxCreateAndRealizeWindow(pWindow->parent, FALSE);
	parent = pParentPriv->window;
d235 2
a236 2
	dmxDoChangeWindowAttributes(pWindow, &pWinPriv->attribMask, &attribs);
	mask |= pWinPriv->attribMask;
d241 2
a242 2
	mask |= CWBackingStore;
	attribs.backing_store = NotUseful;
d244 8
a251 8
	if (!(mask & CWColormap) && pWinPriv->cmap) {
	    mask |= CWColormap;
	    attribs.colormap = pWinPriv->cmap;
	    if (!(mask & CWBorderPixel)) {
		mask |= CWBorderPixel;
		attribs.border_pixel = 0;
	    }
	}
d260 9
a268 11
			 parent,
			 pWindow->origin.x - wBorderWidth(pWindow),
			 pWindow->origin.y - wBorderWidth(pWindow),
			 pWindow->drawable.width,
			 pWindow->drawable.height,
			 pWindow->borderWidth,
			 pWindow->drawable.depth,
			 pWindow->drawable.class,
			 pWinPriv->visual,
			 mask,
			 &attribs);
d280 2
a281 1
void dmxCreateAndRealizeWindow(WindowPtr pWindow, Bool doSync)
d283 1
a283 1
    ScreenPtr      pScreen = pWindow->drawable.pScreen;
d285 1
a285 1
    dmxWinPrivPtr  pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
d287 2
a288 1
    if (!dmxScreen->beDisplay) return;
d291 10
a300 6
    if (pWinPriv->restacked) dmxDoRestackWindow(pWindow);
    if (pWinPriv->isShaped) dmxDoSetShape(pWindow);
    if (pWinPriv->hasPict) dmxCreatePictureList(pWindow);
    if (pWinPriv->mapped) XMapWindow(dmxScreen->beDisplay,
				      pWinPriv->window);
    if (doSync) dmxSync(dmxScreen, False);
d307 2
a308 1
Bool dmxCreateWindow(WindowPtr pWindow)
d310 4
a313 4
    ScreenPtr             pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo        *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr         pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    Bool                  ret = TRUE;
d318 1
a318 1
	ret = pScreen->CreateWindow(pWindow);
d322 4
a325 4
    pWinPriv->window     = (Window)0;
    pWinPriv->offscreen  = TRUE;
    pWinPriv->mapped     = FALSE;
    pWinPriv->restacked  = FALSE;
d327 2
a328 2
    pWinPriv->isShaped   = FALSE;
    pWinPriv->hasPict    = FALSE;
d330 2
a331 2
    pWinPriv->swapGroup  = NULL;
    pWinPriv->barrier    = 0;
d335 38
a372 37
	/* Only create the root window at this stage -- non-root windows are
	   created when they are mapped and are on-screen */
	if (!pWindow->parent) {
	    dmxScreen->rootWin = pWinPriv->window
		= dmxCreateRootWindow(pWindow);
	    if (dmxScreen->scrnX         != dmxScreen->rootX
		|| dmxScreen->scrnY      != dmxScreen->rootY
		|| dmxScreen->scrnWidth  != dmxScreen->rootWidth
		|| dmxScreen->scrnHeight != dmxScreen->rootHeight) {
		dmxResizeRootWindow(pWindow,
				    dmxScreen->rootX,
				    dmxScreen->rootY,
				    dmxScreen->rootWidth,
				    dmxScreen->rootHeight);
		dmxUpdateScreenResources(screenInfo.screens[dmxScreen->index],
					 dmxScreen->rootX,
					 dmxScreen->rootY,
					 dmxScreen->rootWidth,
					 dmxScreen->rootHeight);
		pWindow->origin.x = dmxScreen->rootX;
		pWindow->origin.y = dmxScreen->rootY;
	    }
	} else {
	    dmxGetDefaultWindowAttributes(pWindow,
					  &pWinPriv->cmap,
					  &pWinPriv->visual);

	    if (dmxLazyWindowCreation) {
		/* Save parent's visual for use later */
		if (pWinPriv->visual == CopyFromParent)
		    pWinPriv->visual =
			dmxLookupVisualFromID(pScreen,
					      wVisual(pWindow->parent));
	    } else {
		pWinPriv->window = dmxCreateNonRootWindow(pWindow);
	    }
	}
d374 1
a374 1
	dmxSync(dmxScreen, False);
d383 2
a384 1
Bool dmxBEDestroyWindow(WindowPtr pWindow)
d386 1
a386 1
    ScreenPtr      pScreen = pWindow->drawable.pScreen;
d388 1
a388 1
    dmxWinPrivPtr  pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
d391 3
a393 3
	XDestroyWindow(dmxScreen->beDisplay, pWinPriv->window);
	pWinPriv->window = (Window)0;
	return TRUE;
d401 2
a402 1
Bool dmxDestroyWindow(WindowPtr pWindow)
d404 1
a404 1
    ScreenPtr      pScreen = pWindow->drawable.pScreen;
d406 3
a408 2
    Bool           ret = TRUE;
    Bool           needSync = FALSE;
d410 1
a410 1
    dmxWinPrivPtr  pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
d420 2
a421 1
    if (needSync) dmxSync(dmxScreen, FALSE);
d425 1
a425 1
	pWinPriv->windowDestroyed(pWindow);
d429 1
a429 1
	ret = pScreen->DestroyWindow(pWindow);
d437 2
a438 1
Bool dmxPositionWindow(WindowPtr pWindow, int x, int y)
d440 6
a445 6
    ScreenPtr       pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo  *dmxScreen = &dmxScreens[pScreen->myNum];
    Bool            ret = TRUE;
    dmxWinPrivPtr   pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    unsigned int    m;
    XWindowChanges  c;
d450 1
a450 1
	ret = pScreen->PositionWindow(pWindow, x, y);
d460 13
a472 12
	dmxCreateAndRealizeWindow(pWindow, TRUE);
    } else if (pWinPriv->window) {
	/* Position window on back-end server */
	m = CWX | CWY | CWWidth | CWHeight;
	c.x = pWindow->origin.x - wBorderWidth(pWindow);
	c.y = pWindow->origin.y - wBorderWidth(pWindow);
	c.width = pWindow->drawable.width;
	c.height = pWindow->drawable.height;
	if (pWindow->drawable.class != InputOnly) {
	    m |= CWBorderWidth;
	    c.border_width = pWindow->borderWidth;
	}
d474 2
a475 2
	XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
	dmxSync(dmxScreen, False);
d483 3
a485 3
static void dmxDoChangeWindowAttributes(WindowPtr pWindow,
					unsigned long *mask,
					XSetWindowAttributes *attribs)
d487 1
a487 1
    dmxPixPrivPtr         pPixPriv;
d490 18
a507 18
	switch (pWindow->backgroundState) {
	case None:
	    attribs->background_pixmap = None;
	    break;

	case ParentRelative:
	    attribs->background_pixmap = ParentRelative;
	    break;

	case BackgroundPixmap:
	    pPixPriv = DMX_GET_PIXMAP_PRIV(pWindow->background.pixmap);
	    attribs->background_pixmap = pPixPriv->pixmap;
	    break;

	case BackgroundPixel:
	    *mask &= ~CWBackPixmap;
	    break;
	}
d511 4
a514 4
	if (pWindow->backgroundState == BackgroundPixel)
	    attribs->background_pixel = pWindow->background.pixel;
	else
	    *mask &= ~CWBackPixel;
d518 6
a523 6
	if (pWindow->borderIsPixel)
	    *mask &= ~CWBorderPixmap;
	else {
	    pPixPriv = DMX_GET_PIXMAP_PRIV(pWindow->border.pixmap);
	    attribs->border_pixmap = pPixPriv->pixmap;
	}
d527 4
a530 4
	if (pWindow->borderIsPixel)
	    attribs->border_pixel = pWindow->border.pixel;
	else
	    *mask &= ~CWBorderPixel;
d534 1
a534 1
	attribs->bit_gravity = pWindow->bitGravity;
d537 1
a537 1
	*mask &= ~CWWinGravity; /* Handled by dix */
d540 1
a540 1
	*mask &= ~CWBackingStore; /* Backing store not supported */
d543 1
a543 1
	*mask &= ~CWBackingPlanes; /* Backing store not supported */
d546 1
a546 1
	*mask &= ~CWBackingPixel; /* Backing store not supported */
d549 1
a549 1
	attribs->override_redirect = pWindow->overrideRedirect;
d552 1
a552 1
	*mask &= ~CWSaveUnder; /* Save unders not supported */
d555 1
a555 1
	*mask &= ~CWEventMask; /* Events are handled by dix */
d558 1
a558 1
	*mask &= ~CWDontPropagate; /* Events are handled by dix */
d561 2
a562 2
	ColormapPtr         pCmap;
	dmxColormapPrivPtr  pCmapPriv;
d564 4
a567 4
	dixLookupResourceByType((pointer*) &pCmap, wColormap(pWindow),
				RT_COLORMAP, NullClient, DixUnknownAccess);
	pCmapPriv = DMX_GET_COLORMAP_PRIV(pCmap);
	attribs->colormap = pCmapPriv->cmap;
d571 1
a571 1
	*mask &= ~CWCursor; /* Handled by the cursor code */
d575 2
a576 1
Bool dmxChangeWindowAttributes(WindowPtr pWindow, unsigned long mask)
d578 5
a582 5
    ScreenPtr             pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo        *dmxScreen = &dmxScreens[pScreen->myNum];
    Bool                  ret = TRUE;
    dmxWinPrivPtr         pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    XSetWindowAttributes  attribs;
d587 1
a587 1
	ret = pScreen->ChangeWindowAttributes(pWindow, mask);
d597 3
a599 3
	XChangeWindowAttributes(dmxScreen->beDisplay, pWinPriv->window,
				mask, &attribs);
	dmxSync(dmxScreen, False);
d603 1
a603 1
	     pScreen);
d611 2
a612 1
Bool dmxRealizeWindow(WindowPtr pWindow)
d614 1
a614 1
    ScreenPtr      pScreen = pWindow->drawable.pScreen;
d616 2
a617 2
    Bool           ret = TRUE;
    dmxWinPrivPtr  pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
d622 1
a622 1
	ret = pScreen->RealizeWindow(pWindow);
d632 1
a632 1
	dmxCreateAndRealizeWindow(pWindow, FALSE);
d636 3
a638 3
	/* Realize window on back-end server */
	XMapWindow(dmxScreen->beDisplay, pWinPriv->window);
	dmxSync(dmxScreen, False);
d651 2
a652 1
Bool dmxUnrealizeWindow(WindowPtr pWindow)
d654 1
a654 1
    ScreenPtr      pScreen = pWindow->drawable.pScreen;
d656 2
a657 2
    Bool           ret = TRUE;
    dmxWinPrivPtr  pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
d662 1
a662 1
	ret = pScreen->UnrealizeWindow(pWindow);
d666 3
a668 3
	/* Unrealize window on back-end server */
	XUnmapWindow(dmxScreen->beDisplay, pWinPriv->window);
	dmxSync(dmxScreen, False);
d678 1
a678 1
	pWinPriv->windowUnmapped(pWindow);
d687 2
a688 1
static void dmxDoRestackWindow(WindowPtr pWindow)
d690 6
a695 6
    ScreenPtr       pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo  *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr   pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    WindowPtr       pNextSib = pWindow->nextSib;
    unsigned int    m;
    XWindowChanges  c;
d698 9
a706 8
	/* Window is at the bottom of the stack */
	m = CWStackMode;
	c.sibling = (Window)0;
	c.stack_mode = Below;
	XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
    } else {
	/* Window is not at the bottom of the stack */
	dmxWinPrivPtr  pNextSibPriv = DMX_GET_WINDOW_PRIV(pNextSib);
d708 1
a708 1
	/* Handle case where siblings have not yet been created due to
d715 17
a731 17
	while (!pNextSibPriv->window) {
	    pNextSib = pNextSib->nextSib;
	    if (pNextSib == NullWindow) {
		/* Window is at the bottom of the stack */
		m = CWStackMode;
		c.sibling = (Window)0;
		c.stack_mode = Below;
		XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
		return;
	    }
	    pNextSibPriv = DMX_GET_WINDOW_PRIV(pNextSib);
	}

	m = CWStackMode | CWSibling;
	c.sibling = pNextSibPriv->window;
	c.stack_mode = Above;
	XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
d737 2
a738 1
void dmxRestackWindow(WindowPtr pWindow, WindowPtr pOldNextSib)
d740 3
a742 3
    ScreenPtr       pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo  *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr   pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
d747 1
a747 1
	pScreen->RestackWindow(pWindow, pOldNextSib);
d751 2
a752 2
	/* Track restacking for lazy window creation optimization */
	pWinPriv->restacked = TRUE;
d754 5
a758 5
	/* Restack window on back-end server */
	if (pWinPriv->window) {
	    dmxDoRestackWindow(pWindow);
	    dmxSync(dmxScreen, False);
	}
d765 2
a766 1
static Bool dmxWindowExposurePredicate(Display *dpy, XEvent *ev, XPointer ptr)
d768 1
a768 1
    return (ev->type == Expose && ev->xexpose.window == *(Window *)ptr);
d774 2
a775 2
void dmxWindowExposures(WindowPtr pWindow, RegionPtr prgn,
			RegionPtr other_exposed)
d777 1
a777 1
    ScreenPtr      pScreen = pWindow->drawable.pScreen;
d779 2
a780 2
    dmxWinPrivPtr  pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    XEvent         ev;
d787 11
a797 11
	while (XCheckIfEvent(dmxScreen->beDisplay, &ev,
			     dmxWindowExposurePredicate,
			     (XPointer)&pWinPriv->window)) {
	    /* Handle expose events -- this should not be necessary
	       since the base window in which the root window was
	       created is guaranteed to be on top (override_redirect),
	       so we should just swallow these events.  If for some
	       reason the window is not on top, then we'd need to
	       collect these events and send them to the client later
	       (e.g., during the block handler as Xnest does). */
	}
d802 1
a802 1
	pScreen->WindowExposures(pWindow, prgn, other_exposed);
d810 2
a811 1
void dmxCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
d813 5
a817 5
    ScreenPtr       pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo  *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr   pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    unsigned int    m;
    XWindowChanges  c;
d822 1
a822 1
	pScreen->CopyWindow(pWindow, ptOldOrg, prgnSrc);
d832 9
a840 8
	dmxCreateAndRealizeWindow(pWindow, TRUE);
    } else if (pWinPriv->window) {
	/* Move window on back-end server */
	m = CWX | CWY | CWWidth | CWHeight;
	c.x = pWindow->origin.x - wBorderWidth(pWindow);
	c.y = pWindow->origin.y - wBorderWidth(pWindow);
	c.width = pWindow->drawable.width;
	c.height = pWindow->drawable.height;
d842 2
a843 2
	XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
	dmxSync(dmxScreen, False);
d853 3
a855 2
void dmxResizeWindow(WindowPtr pWindow, int x, int y,
		     unsigned int w, unsigned int h, WindowPtr pSib)
d857 6
a862 6
    ScreenPtr       pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo  *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr   pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    dmxWinPrivPtr   pSibPriv;
    unsigned int    m;
    XWindowChanges  c;
d865 1
a865 1
	pSibPriv = DMX_GET_WINDOW_PRIV(pSib);
d870 1
a870 1
	pScreen->ResizeWindow(pWindow, x, y, w, h, pSib);
d880 9
a888 8
	dmxCreateAndRealizeWindow(pWindow, TRUE);
    } else if (pWinPriv->window) {
	/* Handle resizing on back-end server */
	m = CWX | CWY | CWWidth | CWHeight;
	c.x = pWindow->origin.x - wBorderWidth(pWindow);
	c.y = pWindow->origin.y - wBorderWidth(pWindow);
	c.width = pWindow->drawable.width;
	c.height = pWindow->drawable.height;
d890 2
a891 2
	XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
	dmxSync(dmxScreen, False);
d899 2
a900 1
void dmxReparentWindow(WindowPtr pWindow, WindowPtr pPriorParent)
d902 1
a902 1
    ScreenPtr      pScreen = pWindow->drawable.pScreen;
d904 2
a905 2
    dmxWinPrivPtr  pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    dmxWinPrivPtr  pParentPriv = DMX_GET_WINDOW_PRIV(pWindow->parent);
d910 1
a910 1
	pScreen->ReparentWindow(pWindow, pPriorParent);
d914 10
a923 10
	if (!pParentPriv->window) {
	    dmxCreateAndRealizeWindow(pWindow->parent, FALSE);
	}

	/* Handle reparenting on back-end server */
	XReparentWindow(dmxScreen->beDisplay, pWinPriv->window,
			pParentPriv->window,
			pWindow->origin.x - wBorderWidth(pWindow),
			pWindow->origin.x - wBorderWidth(pWindow));
	dmxSync(dmxScreen, False);
d931 2
a932 1
void dmxChangeBorderWidth(WindowPtr pWindow, unsigned int width)
d934 5
a938 5
    ScreenPtr       pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo  *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr   pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    unsigned int    m;
    XWindowChanges  c;
d943 1
a943 1
	pScreen->ChangeBorderWidth(pWindow, width);
d949 3
a951 3
	/* Handle border width change on back-end server */
	m = CWBorderWidth;
	c.border_width = width;
d953 2
a954 2
	XConfigureWindow(dmxScreen->beDisplay, pWinPriv->window, m, &c);
	dmxSync(dmxScreen, False);
d960 2
a961 1
static void dmxDoSetShape(WindowPtr pWindow)
d963 8
a970 8
    ScreenPtr       pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo  *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr   pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    int             nBox;
    BoxPtr          pBox;
    int             nRect;
    XRectangle     *pRect;
    XRectangle     *pRectFirst;
d974 19
a992 19
	pBox = RegionRects(wBoundingShape(pWindow));
	nRect = nBox = RegionNumRects(wBoundingShape(pWindow));
	pRectFirst = pRect = malloc(nRect * sizeof(*pRect));
	while (nBox--) {
	    pRect->x      = pBox->x1;
	    pRect->y      = pBox->y1;
	    pRect->width  = pBox->x2 - pBox->x1;
	    pRect->height = pBox->y2 - pBox->y1;
	    pBox++;
	    pRect++;
	}
	XShapeCombineRectangles(dmxScreen->beDisplay, pWinPriv->window,
				ShapeBounding, 0, 0,
				pRectFirst, nRect,
				ShapeSet, YXBanded);
	free(pRectFirst);
    } else {
	XShapeCombineMask(dmxScreen->beDisplay, pWinPriv->window,
			  ShapeBounding, 0, 0, None, ShapeSet);
d997 19
a1015 19
	pBox = RegionRects(wClipShape(pWindow));
	nRect = nBox = RegionNumRects(wClipShape(pWindow));
	pRectFirst = pRect = malloc(nRect * sizeof(*pRect));
	while (nBox--) {
	    pRect->x      = pBox->x1;
	    pRect->y      = pBox->y1;
	    pRect->width  = pBox->x2 - pBox->x1;
	    pRect->height = pBox->y2 - pBox->y1;
	    pBox++;
	    pRect++;
	}
	XShapeCombineRectangles(dmxScreen->beDisplay, pWinPriv->window,
				ShapeClip, 0, 0,
				pRectFirst, nRect,
				ShapeSet, YXBanded);
	free(pRectFirst);
    } else {
	XShapeCombineMask(dmxScreen->beDisplay, pWinPriv->window,
			  ShapeClip, 0, 0, None, ShapeSet);
d1019 2
a1020 2
	ErrorF("Input selected for window %x on Screen %d\n",
	       (unsigned int)pWinPriv->window, pScreen->myNum);
d1025 2
a1026 1
void dmxSetShape(WindowPtr pWindow, int kind)
d1028 3
a1030 3
    ScreenPtr       pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo  *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr   pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
d1035 1
a1035 1
	pScreen->SetShape(pWindow, kind);
d1039 6
a1044 5
	/* Handle setting the current shape on the back-end server */
	dmxDoSetShape(pWindow);
	dmxSync(dmxScreen, False);
    } else {
	pWinPriv->isShaped = TRUE;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d87 2
a88 1
    pCmap = (ColormapPtr)LookupIDByType(wColormap(pWindow), RT_COLORMAP);
d118 1
a118 1
 *  #dmxConfigureScreenWindow(). */
d141 1
a141 1
 *  #dmxConfigureRootWindow. */
d195 2
a196 2
	    pCmap = (ColormapPtr)LookupIDByType(wColormap(pWindow),
						RT_COLORMAP);
d549 2
a550 1
	pCmap = (ColormapPtr)LookupIDByType(wColormap(pWindow), RT_COLORMAP);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a48 1
#ifdef RENDER
a49 1
#endif
d63 1
a63 1
    if (!dixRequestPrivate(dmxWinPrivateKey, sizeof(dmxWinPrivRec)))
a288 1
#ifdef RENDER
a289 1
#endif
a318 1
#ifdef RENDER
a319 1
#endif
a401 1
#ifdef RENDER
a403 1
#endif
d943 3
a945 3
	pBox = REGION_RECTS(wBoundingShape(pWindow));
	nRect = nBox = REGION_NUM_RECTS(wBoundingShape(pWindow));
	pRectFirst = pRect = xalloc(nRect * sizeof(*pRect));
d958 1
a958 1
	xfree(pRectFirst);
d966 3
a968 3
	pBox = REGION_RECTS(wClipShape(pWindow));
	nRect = nBox = REGION_NUM_RECTS(wClipShape(pWindow));
	pRectFirst = pRect = xalloc(nRect * sizeof(*pRect));
d981 1
a981 1
	xfree(pRectFirst);
d994 1
a994 1
void dmxSetShape(WindowPtr pWindow)
d1003 1
a1003 1
	pScreen->SetShape(pWindow);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d119 1
a119 1
 *  #dmxReconfigureScreenWindow(). */
d142 1
a142 1
 *  #dmxReconfigureRootWindow(). */
a421 1
#if 0
d424 1
a424 1
#endif
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a59 1
#ifdef SHAPE
a60 1
#endif
a289 1
#ifdef SHAPE
a290 1
#endif
a321 1
#ifdef SHAPE
a322 1
#endif
a938 1
#ifdef SHAPE
a1024 1
#endif
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
d67 1
a67 2
    if (!AllocateWindowPrivate(pScreen, dmxWinPrivateIndex,
			       sizeof(dmxWinPrivRec)))
a795 51
}

/** Paint background of \a pWindow in \a pRegion. */
void dmxPaintWindowBackground(WindowPtr pWindow, RegionPtr pRegion, int what)
{
    ScreenPtr      pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxWinPrivPtr  pWinPriv = DMX_GET_WINDOW_PRIV(pWindow);
    BoxPtr         pBox;
    int            nBox;

    DMX_UNWRAP(PaintWindowBackground, dmxScreen, pScreen);
#if 0
    if (pScreen->PaintWindowBackground)
	pScreen->PaintWindowBackground(pWindow, pRegion, what);
#endif

    if (pWinPriv->window) {
	/* Paint window background on back-end server */
	pBox = REGION_RECTS(pRegion);
	nBox = REGION_NUM_RECTS(pRegion);
	while (nBox--) {
	    XClearArea(dmxScreen->beDisplay, pWinPriv->window,
		       pBox->x1 - pWindow->drawable.x,
		       pBox->y1 - pWindow->drawable.y,
		       pBox->x2 - pBox->x1,
		       pBox->y2 - pBox->y1,
		       False);
	    pBox++;
	}
	dmxSync(dmxScreen, False);
    }

    DMX_WRAP(PaintWindowBackground, dmxPaintWindowBackground, dmxScreen, pScreen);
}

/** Paint window border for \a pWindow in \a pRegion. */
void dmxPaintWindowBorder(WindowPtr pWindow, RegionPtr pRegion, int what)
{
    ScreenPtr      pScreen = pWindow->drawable.pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];

    DMX_UNWRAP(PaintWindowBorder, dmxScreen, pScreen);
#if 0
    if (pScreen->PaintWindowBorder)
	pScreen->PaintWindowBorder(pWindow, pRegion, what);
#endif

    /* Paint window border on back-end server */

    DMX_WRAP(PaintWindowBorder, dmxPaintWindowBorder, dmxScreen, pScreen);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
@

