head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.6
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	7pAEtF6Y5EgemkuY;

1.9
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.05;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.23.42;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.23.42;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@/* DO NOT EDIT - THIS FILE IS AUTOMATICALLY GENERATED */
/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include "dmx.h"
#include "dmxwindow.h"
#include "dmxpixmap.h"
#include "dmxfont.h"

#include "glxserver.h"
#include "glxext.h"
#include "g_disptab.h"
/* #include "g_disptab_EXT.h" */
#include "unpack.h"
#include "glxutil.h"
#include "glxcmds.h"
#include "glxvendor.h"

#include "GL/glxproto.h"

#ifdef PANORAMIX
#include "panoramiXsrv.h"
#endif

/*
 * GetReqVendorPrivate - this is the equivalent of GetReq macro
 *    from Xlibint.h but it does not set the reqType field (the opcode).
 *    this is because the GL single opcodes has different naming convension
 *    the other X opcodes (ie. X_GLsop_GetFloatv).
 */
#if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
#define GetReqVendorPrivate(name, req) \
        WORD64ALIGN\
	if ((dpy->bufptr + SIZEOF(x##name##Req)) > dpy->bufmax)\
		_XFlush(dpy);\
	req = (x##name##Req *)(dpy->last_req = dpy->bufptr);\
	req->length = (SIZEOF(x##name##Req))>>2;\
	dpy->bufptr += SIZEOF(x##name##Req);\
	dpy->request++

#else                           /* non-ANSI C uses empty comment instead of "##" for token concatenation */
#define GetReqVendorPrivate(name, req) \
        WORD64ALIGN\
	if ((dpy->bufptr + SIZEOF(x/**/name/**/Req)) > dpy->bufmax)\
		_XFlush(dpy);\
	req = (x/**/name/**/Req *)(dpy->last_req = dpy->bufptr);\
	req->length = (SIZEOF(x/**/name/**/Req))>>2;\
	dpy->bufptr += SIZEOF(x/**/name/**/Req);\
	dpy->request++
#endif

static int swap_vec_element_size = 0;

static void
SendSwappedReply(ClientPtr client,
                 xGLXVendorPrivReply * reply, char *buf, int buf_size)
{
    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->retval);
    __GLX_SWAP_INT(&reply->size);

    if ((buf_size == 0) && (swap_vec_element_size > 0)) {
        /*
         * the reply has single component - need to swap pad3
         */
        if (swap_vec_element_size == 2) {
            __GLX_SWAP_SHORT(&reply->pad3);
        }
        else if (swap_vec_element_size == 4) {
            __GLX_SWAP_INT(&reply->pad3);
            __GLX_SWAP_INT(&reply->pad4);
        }
        else if (swap_vec_element_size == 8) {
            __GLX_SWAP_DOUBLE(&reply->pad3);
        }
    }
    else if ((buf_size > 0) && (swap_vec_element_size > 0)) {
        /*
         * the reply has vector of elements which needs to be swapped
         */
        int vsize = buf_size / swap_vec_element_size;
        char *p = buf;
        int i;

        for (i = 0; i < vsize; i++) {
            if (swap_vec_element_size == 2) {
                __GLX_SWAP_SHORT(p);
            }
            else if (swap_vec_element_size == 4) {
                __GLX_SWAP_INT(p);
            }
            else if (swap_vec_element_size == 8) {
                __GLX_SWAP_DOUBLE(p);
            }

            p += swap_vec_element_size;
        }

        __GLX_SWAP_INT(&reply->pad3);
        __GLX_SWAP_INT(&reply->pad4);
        __GLX_SWAP_INT(&reply->pad5);
        __GLX_SWAP_INT(&reply->pad6);

    }

    WriteToClient(client, sizeof(xGLXVendorPrivReply), reply);
    if (buf_size > 0)
        WriteToClient(client, buf_size, buf);

}

int
__glXVForwardSingleReq(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;
    xGLXVendorPrivateReq *be_req;
    __GLXcontext *glxc;
    int from_screen = 0;
    int to_screen = 0;
    int buf_size;
    int s;

    glxc = __glXLookupContextByTag(cl, req->contextTag);
    if (!glxc) {
        return 0;
    }
    from_screen = to_screen = glxc->pScreen->myNum;

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    pc += sz_xGLXVendorPrivateReq;
    buf_size = (req->length << 2) - sz_xGLXVendorPrivateReq;

    /*
     * just forward the request to back-end server(s)
     */
    for (s = from_screen; s <= to_screen; s++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = GetBackEndDisplay(cl, s);

        LockDisplay(dpy);
        GetReqVendorPrivate(GLXVendorPrivate, be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = req->glxCode;
        be_req->length = req->length;
        be_req->vendorCode = req->vendorCode;
        be_req->contextTag = GetCurrentBackEndTag(cl, req->contextTag, s);
        if (buf_size > 0)
            _XSend(dpy, (const char *) pc, buf_size);
        UnlockDisplay(dpy);
        SyncHandle();
    }

    return Success;
}

int
__glXVForwardPipe0WithReply(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;
    xGLXVendorPrivateReq *be_req;
    xGLXVendorPrivReply reply;
    xGLXVendorPrivReply be_reply;
    __GLXcontext *glxc;
    int buf_size;
    char *be_buf = NULL;
    int be_buf_size;
    DMXScreenInfo *dmxScreen;
    Display *dpy;

    glxc = __glXLookupContextByTag(cl, req->contextTag);
    if (!glxc) {
        return __glXBadContext;
    }

    pc += sz_xGLXVendorPrivateReq;
    buf_size = (req->length << 2) - sz_xGLXVendorPrivateReq;

    dmxScreen = &dmxScreens[glxc->pScreen->myNum];
    dpy = GetBackEndDisplay(cl, glxc->pScreen->myNum);

    /*
     * send the request to the first back-end server
     */
    LockDisplay(dpy);
    GetReqVendorPrivate(GLXVendorPrivate, be_req);
    be_req->reqType = dmxScreen->glxMajorOpcode;
    be_req->glxCode = req->glxCode;
    be_req->length = req->length;
    be_req->vendorCode = req->vendorCode;
    be_req->contextTag =
        GetCurrentBackEndTag(cl, req->contextTag, glxc->pScreen->myNum);
    if (buf_size > 0)
        _XSend(dpy, (const char *) pc, buf_size);

    /*
     * get the reply from the back-end server
     */
    _XReply(dpy, (xReply *) &be_reply, 0, False);
    be_buf_size = be_reply.length << 2;
    if (be_buf_size > 0) {
        be_buf = (char *) malloc(be_buf_size);
        if (be_buf) {
            _XRead(dpy, be_buf, be_buf_size);
        }
        else {
            /* Throw data on the floor */
            _XEatDataWords(dpy, be_reply.length);
            return BadAlloc;
        }
    }

    UnlockDisplay(dpy);
    SyncHandle();

    /*
     * send the reply to the client
     */
    memcpy(&reply, &be_reply, sz_xGLXVendorPrivReply);
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;

    if (client->swapped) {
        SendSwappedReply(client, &reply, be_buf, be_buf_size);
    }
    else {
        WriteToClient(client, sizeof(xGLXVendorPrivReply), &reply);
        if (be_buf_size > 0)
            WriteToClient(client, be_buf_size, be_buf);
    }

    if (be_buf_size > 0)
        free(be_buf);

    return Success;
}

int
__glXVForwardAllWithReply(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;
    xGLXVendorPrivateReq *be_req;
    xGLXVendorPrivReply reply;
    xGLXVendorPrivReply be_reply;
    __GLXcontext *glxc;
    int buf_size;
    char *be_buf = NULL;
    int be_buf_size = 0;
    int from_screen = 0;
    int to_screen = 0;
    int s;

    DMXScreenInfo *dmxScreen;
    Display *dpy;

    glxc = __glXLookupContextByTag(cl, req->contextTag);
    if (!glxc) {
        return 0;
    }
    from_screen = to_screen = glxc->pScreen->myNum;

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    pc += sz_xGLXVendorPrivateReq;
    buf_size = (req->length << 2) - sz_xGLXVendorPrivateReq;

    /*
     * send the request to the first back-end server(s)
     */
    for (s = to_screen; s >= from_screen; s--) {
        dmxScreen = &dmxScreens[s];
        dpy = GetBackEndDisplay(cl, s);

        LockDisplay(dpy);
        GetReqVendorPrivate(GLXVendorPrivate, be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = req->glxCode;
        be_req->length = req->length;
        be_req->vendorCode = req->vendorCode;
        be_req->contextTag = GetCurrentBackEndTag(cl, req->contextTag, s);
        if (buf_size > 0)
            _XSend(dpy, (const char *) pc, buf_size);

        /*
         * get the reply from the back-end server
         */
        _XReply(dpy, (xReply *) &be_reply, 0, False);
        if (s == from_screen) {
            /* Save data from last reply to send on to client */
            be_buf_size = be_reply.length << 2;
            if (be_buf_size > 0) {
                be_buf = malloc(be_buf_size);
                if (be_buf) {
                    _XRead(dpy, be_buf, be_buf_size);
                }
                else {
                    /* Throw data on the floor */
                    _XEatDataWords(dpy, be_reply.length);
                    return BadAlloc;
                }
            }
        }
        else {
            /* Just discard data from all replies before the last one */
            if (be_reply.length > 0)
                _XEatDataWords(dpy, be_reply.length);
        }

        UnlockDisplay(dpy);
        SyncHandle();
    }

    /*
     * send the reply to the client
     */
    memcpy(&reply, &be_reply, sz_xGLXVendorPrivReply);
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;

    if (client->swapped) {
        SendSwappedReply(client, &reply, be_buf, be_buf_size);
    }
    else {
        WriteToClient(client, sizeof(xGLXVendorPrivReply), &reply);
        if (be_buf_size > 0)
            WriteToClient(client, be_buf_size, be_buf);
    }

    if (be_buf_size > 0)
        free(be_buf);

    return Success;
}

int
__glXVForwardSingleReqSwap(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->vendorCode);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 0;

    return (__glXVForwardSingleReq(cl, pc));
}

int
__glXVForwardPipe0WithReplySwap(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->vendorCode);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 0;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXVendorPrivateReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXVendorPrivateReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXVForwardPipe0WithReply(cl, pc));
}

int
__glXVForwardPipe0WithReplySwapsv(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->vendorCode);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 2;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXVendorPrivateReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXVendorPrivateReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXVForwardPipe0WithReply(cl, pc));
}

int
__glXVForwardPipe0WithReplySwapiv(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->vendorCode);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 4;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXVendorPrivateReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXVendorPrivateReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXVForwardPipe0WithReply(cl, pc));
}

int
__glXVForwardPipe0WithReplySwapdv(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->vendorCode);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 8;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXVendorPrivateReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXVendorPrivateReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXVForwardPipe0WithReply(cl, pc));
}

int
__glXVForwardAllWithReplySwap(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->vendorCode);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 0;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXVendorPrivateReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXVendorPrivateReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXVForwardAllWithReply(cl, pc));
}

int
__glXVForwardAllWithReplySwapsv(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->vendorCode);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 2;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXVendorPrivateReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXVendorPrivateReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXVForwardAllWithReply(cl, pc));
}

int
__glXVForwardAllWithReplySwapiv(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->vendorCode);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 4;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXVendorPrivateReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXVendorPrivateReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXVForwardAllWithReply(cl, pc));
}

int
__glXVForwardAllWithReplySwapdv(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->vendorCode);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 8;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXVendorPrivateReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXVendorPrivateReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXVForwardAllWithReply(cl, pc));
}
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d47 2
a81 4

extern Display *GetBackEndDisplay(__GLXclientState * cl, int s);
extern int GetCurrentBackEndTag(__GLXclientState * cl, GLXContextTag tag,
                                int s);
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d223 1
a223 1
    /* 
d314 1
a314 1
    /* 
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d249 1
a249 1
            _XEatData(dpy, be_buf_size);
d335 13
a347 10
        be_buf_size = be_reply.length << 2;
        if (be_buf_size > 0) {
            be_buf = (char *) malloc(be_buf_size);
            if (be_buf) {
                _XRead(dpy, be_buf, be_buf_size);
            }
            else {
                /* Throw data on the floor */
                _XEatData(dpy, be_buf_size);
                return BadAlloc;
d349 5
a357 4

        if (s > from_screen && be_buf_size > 0) {
            free(be_buf);
        }
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d141 1
a141 1
    WriteToClient(client, sizeof(xGLXVendorPrivReply), (char *) reply);
d143 1
a143 1
        WriteToClient(client, buf_size, (char *) buf);
d240 1
a240 1
    _XReply(dpy, (xReply *) & be_reply, 0, False);
d268 1
a268 1
        WriteToClient(client, sizeof(xGLXVendorPrivReply), (char *) &reply);
d270 1
a270 1
            WriteToClient(client, be_buf_size, (char *) be_buf);
d334 1
a334 1
        _XReply(dpy, (xReply *) & be_reply, 0, False);
d367 1
a367 1
        WriteToClient(client, sizeof(xGLXVendorPrivReply), (char *) &reply);
d369 1
a369 1
            WriteToClient(client, be_buf_size, (char *) be_buf);
@


1.5
log
@Update to xserver 1.11.2
@
text
@d70 1
a70 1
#else  /* non-ANSI C uses empty comment instead of "##" for token concatenation */
d81 3
a83 2
extern Display *GetBackEndDisplay( __GLXclientState *cl, int s );
extern int GetCurrentBackEndTag(__GLXclientState *cl, GLXContextTag tag, int s);
d87 51
a137 52
static void SendSwappedReply( ClientPtr client,
                              xGLXVendorPrivReply *reply, 
			      char *buf,
			      int   buf_size )
{
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_SWAP_SHORT(&reply->sequenceNumber);
   __GLX_SWAP_INT(&reply->length);
   __GLX_SWAP_INT(&reply->retval);
   __GLX_SWAP_INT(&reply->size);

   if ( (buf_size == 0) && (swap_vec_element_size > 0) ) {
      /*
       * the reply has single component - need to swap pad3
       */
      if (swap_vec_element_size == 2) {
	 __GLX_SWAP_SHORT(&reply->pad3);
      }
      else if (swap_vec_element_size == 4) {
	 __GLX_SWAP_INT(&reply->pad3);
	 __GLX_SWAP_INT(&reply->pad4);
      }
      else if (swap_vec_element_size == 8) {
	 __GLX_SWAP_DOUBLE(&reply->pad3);
      }
   }
   else if ( (buf_size > 0) && (swap_vec_element_size > 0) ) {
      /*
       * the reply has vector of elements which needs to be swapped
       */
      int vsize = buf_size / swap_vec_element_size;
      char *p = buf;
      int i;

      for (i=0; i<vsize; i++) {
	 if (swap_vec_element_size == 2) {
	    __GLX_SWAP_SHORT(p);
	 }
	 else if (swap_vec_element_size == 4) {
	    __GLX_SWAP_INT(p);
	 }
	 else if (swap_vec_element_size == 8) {
	    __GLX_SWAP_DOUBLE(p);
	 }

	 p += swap_vec_element_size;
      }

      __GLX_SWAP_INT(&reply->pad3);
      __GLX_SWAP_INT(&reply->pad4);
      __GLX_SWAP_INT(&reply->pad5);
      __GLX_SWAP_INT(&reply->pad6);
d139 1
a139 1
   }
d141 1
a141 1
    WriteToClient(client, sizeof(xGLXVendorPrivReply),(char *)reply);
d143 1
a143 1
       WriteToClient(client, buf_size, (char *)buf);
d147 2
a148 1
int __glXVForwardSingleReq( __GLXclientState *cl, GLbyte *pc )
d150 2
a151 2
   xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *)pc;
   xGLXVendorPrivateReq *be_req;
d153 4
a156 4
   int from_screen = 0;
   int to_screen = 0;
   int buf_size;
   int s;
d160 1
a160 1
	return 0;
d166 2
a167 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d177 15
a191 15
    for (s=from_screen; s<=to_screen; s++) {
       DMXScreenInfo *dmxScreen = &dmxScreens[s];
       Display *dpy = GetBackEndDisplay(cl,s);

       LockDisplay(dpy);
       GetReqVendorPrivate(GLXVendorPrivate,be_req);
       be_req->reqType = dmxScreen->glxMajorOpcode;
       be_req->glxCode = req->glxCode;
       be_req->length = req->length;
       be_req->vendorCode = req->vendorCode;
       be_req->contextTag = GetCurrentBackEndTag(cl,req->contextTag,s);
       if (buf_size > 0) 
	  _XSend(dpy, (const char *)pc, buf_size);
       UnlockDisplay(dpy);
       SyncHandle();
d197 2
a198 1
int __glXVForwardPipe0WithReply( __GLXclientState *cl, GLbyte *pc )
d200 5
a204 5
   ClientPtr client = cl->client;
   xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *)pc;
   xGLXVendorPrivateReq *be_req;
   xGLXVendorPrivReply reply;
   xGLXVendorPrivReply be_reply;
d206 5
a210 5
   int buf_size;
   char *be_buf = NULL;
   int   be_buf_size;
   DMXScreenInfo *dmxScreen;
   Display *dpy;
d214 1
a214 1
	return __glXBadContext;
d227 1
a227 1
    GetReqVendorPrivate(GLXVendorPrivate,be_req);
d232 4
a235 3
    be_req->contextTag = GetCurrentBackEndTag(cl,req->contextTag, glxc->pScreen->myNum);
    if (buf_size > 0) 
       _XSend(dpy, (const char *)pc, buf_size);
d240 1
a240 1
    _XReply(dpy, (xReply*) &be_reply, 0, False);
d243 9
a251 9
       be_buf = (char *)malloc( be_buf_size );
       if (be_buf) {
	  _XRead(dpy, be_buf, be_buf_size);
       }
       else {
	  /* Throw data on the floor */
	  _XEatData(dpy, be_buf_size);
	  return BadAlloc;
       }
d260 1
a260 1
    memcpy( &reply, &be_reply, sz_xGLXVendorPrivReply );
d265 1
a265 1
       SendSwappedReply( client, &reply, be_buf, be_buf_size );
d268 3
a270 3
       WriteToClient(client, sizeof(xGLXVendorPrivReply),(char *)&reply);
       if (be_buf_size > 0)
	  WriteToClient(client, be_buf_size, (char *)be_buf);
d273 2
a274 1
    if (be_buf_size > 0) free(be_buf);
d279 2
a280 1
int __glXVForwardAllWithReply( __GLXclientState *cl, GLbyte *pc )
d282 5
a286 5
   ClientPtr client = cl->client;
   xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *)pc;
   xGLXVendorPrivateReq *be_req;
   xGLXVendorPrivReply reply;
   xGLXVendorPrivReply be_reply;
d288 6
a293 6
   int buf_size;
   char *be_buf = NULL;
   int   be_buf_size = 0;
   int from_screen = 0;
   int to_screen = 0;
   int s;
d295 2
a296 2
   DMXScreenInfo *dmxScreen;
   Display *dpy;
d300 1
a300 1
	return 0;
d306 2
a307 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d317 37
a353 37
    for (s=to_screen; s>=from_screen; s--) {
       dmxScreen = &dmxScreens[s];
       dpy = GetBackEndDisplay(cl,s);

       LockDisplay(dpy);
       GetReqVendorPrivate(GLXVendorPrivate,be_req);
       be_req->reqType = dmxScreen->glxMajorOpcode;
       be_req->glxCode = req->glxCode;
       be_req->length = req->length;
       be_req->vendorCode = req->vendorCode;
       be_req->contextTag = GetCurrentBackEndTag(cl,req->contextTag,s);
       if (buf_size > 0) 
	  _XSend(dpy, (const char *)pc, buf_size);

       /*
	* get the reply from the back-end server
	*/
       _XReply(dpy, (xReply*) &be_reply, 0, False);
       be_buf_size = be_reply.length << 2;
       if (be_buf_size > 0) {
	  be_buf = (char *)malloc( be_buf_size );
	  if (be_buf) {
	     _XRead(dpy, be_buf, be_buf_size);
	  }
	  else {
	     /* Throw data on the floor */
	     _XEatData(dpy, be_buf_size);
	     return BadAlloc;
	  }
       }

       UnlockDisplay(dpy);
       SyncHandle();

       if (s > from_screen && be_buf_size > 0) {
	  free(be_buf);
       }
d359 1
a359 1
    memcpy( &reply, &be_reply, sz_xGLXVendorPrivReply );
d364 1
a364 1
       SendSwappedReply( client, &reply, be_buf, be_buf_size );
d367 3
a369 3
       WriteToClient(client, sizeof(xGLXVendorPrivReply),(char *)&reply);
       if (be_buf_size > 0)
	  WriteToClient(client, be_buf_size, (char *)be_buf);
d372 2
a373 1
    if (be_buf_size > 0) free(be_buf);
d378 2
a379 1
int __glXVForwardSingleReqSwap( __GLXclientState *cl, GLbyte *pc )
d381 3
a383 2
   xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
d385 3
a387 3
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->vendorCode);
   __GLX_SWAP_INT(&req->contextTag);
d389 1
a389 1
   swap_vec_element_size = 0;
d391 1
a391 1
   return( __glXVForwardSingleReq( cl, pc ) );
d394 2
a395 1
int __glXVForwardPipe0WithReplySwap( __GLXclientState *cl, GLbyte *pc )
d397 1
a397 3
   xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d399 2
a400 3
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->vendorCode);
   __GLX_SWAP_INT(&req->contextTag);
d402 3
a404 1
   swap_vec_element_size = 0;
d406 9
a414 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXVendorPrivateReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXVendorPrivateReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d416 4
a419 1
   return( __glXVForwardPipe0WithReply( cl, pc ) );
d422 2
a423 1
int __glXVForwardPipe0WithReplySwapsv( __GLXclientState *cl, GLbyte *pc )
d425 4
a428 3
   xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d430 3
a432 3
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->vendorCode);
   __GLX_SWAP_INT(&req->contextTag);
d434 9
a442 1
   swap_vec_element_size = 2;
d444 2
a445 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXVendorPrivateReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXVendorPrivateReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d447 1
a447 1
   return( __glXVForwardPipe0WithReply( cl, pc ) );
d450 2
a451 1
int __glXVForwardPipe0WithReplySwapiv( __GLXclientState *cl, GLbyte *pc )
d453 4
a456 3
   xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d458 3
a460 3
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->vendorCode);
   __GLX_SWAP_INT(&req->contextTag);
d462 1
a462 1
   swap_vec_element_size = 4;
d464 7
a470 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXVendorPrivateReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXVendorPrivateReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d472 4
a475 1
   return( __glXVForwardPipe0WithReply( cl, pc ) );
d478 2
a479 1
int __glXVForwardPipe0WithReplySwapdv( __GLXclientState *cl, GLbyte *pc )
d481 8
a488 3
   xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d490 1
a490 3
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->vendorCode);
   __GLX_SWAP_INT(&req->contextTag);
d492 7
a498 1
   swap_vec_element_size = 8;
d500 2
a501 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXVendorPrivateReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXVendorPrivateReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d503 1
a503 1
   return( __glXVForwardPipe0WithReply( cl, pc ) );
d506 2
a507 1
int __glXVForwardAllWithReplySwap( __GLXclientState *cl, GLbyte *pc )
d509 8
a516 3
   xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d518 1
a518 3
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->vendorCode);
   __GLX_SWAP_INT(&req->contextTag);
d520 7
a526 1
   swap_vec_element_size = 0;
d528 2
a529 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXVendorPrivateReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXVendorPrivateReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d531 1
a531 1
   return( __glXVForwardAllWithReply( cl, pc ) );
d534 2
a535 1
int __glXVForwardAllWithReplySwapsv( __GLXclientState *cl, GLbyte *pc )
d537 1
a537 3
   xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d539 2
a540 3
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->vendorCode);
   __GLX_SWAP_INT(&req->contextTag);
d542 3
a544 1
   swap_vec_element_size = 2;
d546 12
a557 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXVendorPrivateReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXVendorPrivateReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d559 1
a559 1
   return( __glXVForwardAllWithReply( cl, pc ) );
d562 2
a563 1
int __glXVForwardAllWithReplySwapiv( __GLXclientState *cl, GLbyte *pc )
d565 1
a565 3
   xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d567 2
a568 3
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->vendorCode);
   __GLX_SWAP_INT(&req->contextTag);
d570 3
a572 1
   swap_vec_element_size = 4;
d574 1
a574 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXVendorPrivateReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXVendorPrivateReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d576 12
a587 1
   return( __glXVForwardAllWithReply( cl, pc ) );
d590 2
a591 1
int __glXVForwardAllWithReplySwapdv( __GLXclientState *cl, GLbyte *pc )
d593 1
a593 3
   xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d595 2
a596 3
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->vendorCode);
   __GLX_SWAP_INT(&req->contextTag);
d598 3
a600 1
   swap_vec_element_size = 8;
d602 1
a602 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXVendorPrivateReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXVendorPrivateReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d604 12
a615 1
   return( __glXVForwardAllWithReply( cl, pc ) );
a616 1

@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a40 5
#undef Xmalloc
#undef Xcalloc
#undef Xrealloc
#undef Xfree

d205 1
a205 1
   char *be_buf;
d284 2
a285 2
   char *be_buf;
   int   be_buf_size;
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d245 1
a245 1
       be_buf = (char *)Xalloc( be_buf_size );
d275 1
a275 1
    if (be_buf_size > 0) Xfree(be_buf);
d337 1
a337 1
	  be_buf = (char *)Xalloc( be_buf_size );
d352 1
a352 1
	  Xfree(be_buf);
d372 1
a372 1
    if (be_buf_size > 0) Xfree(be_buf);
d395 1
d420 1
d445 1
d470 1
d495 1
d520 1
d545 1
d570 1
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a45 1
#define NEED_REPLIES
@


1.1
log
@Initial revision
@
text
@d3 28
a30 27
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: This software was created using the
** OpenGL(R) version 1.2.1 Sample Implementation published by SGI, but has
** not been independently verified as being compliant with the OpenGL(R)
** version 1.2.1 Specification.
*/
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
