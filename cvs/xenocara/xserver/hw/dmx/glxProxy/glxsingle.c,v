head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	7pAEtF6Y5EgemkuY;

1.9
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.23.41;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.23.41;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/* DO NOT EDIT - THIS FILE IS AUTOMATICALLY GENERATED */
/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include "dmx.h"
#include "dmxwindow.h"
#include "dmxpixmap.h"
#include "dmxfont.h"
#include "dmxcb.h"

#include "glxserver.h"
#include "glxext.h"
#include "g_disptab.h"
/* #include "g_disptab_EXT.h" */
#include "unpack.h"
#include "glxutil.h"
#include "glxcmds.h"
#include "glxsingle.h"

#include "GL/glxproto.h"

#ifdef PANORAMIX
#include "panoramiXsrv.h"
#endif

/*
 * GetReqSingle - this is the equivalent of GetReq macro
 *    from Xlibint.h but it does not set the reqType field (the opcode).
 *    this is because the GL single opcodes has different naming convension
 *    the other X opcodes (ie. X_GLsop_GetFloatv).
 */
#if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
#define GetReqSingle(name, req) \
        WORD64ALIGN\
	if ((dpy->bufptr + SIZEOF(x##name##Req)) > dpy->bufmax)\
		_XFlush(dpy);\
	req = (x##name##Req *)(dpy->last_req = dpy->bufptr);\
	req->length = (SIZEOF(x##name##Req))>>2;\
	dpy->bufptr += SIZEOF(x##name##Req);\
	dpy->request++

#else                           /* non-ANSI C uses empty comment instead of "##" for token concatenation */
#define GetReqSingle(name, req) \
        WORD64ALIGN\
	if ((dpy->bufptr + SIZEOF(x/**/name/**/Req)) > dpy->bufmax)\
		_XFlush(dpy);\
	req = (x/**/name/**/Req *)(dpy->last_req = dpy->bufptr);\
	req->length = (SIZEOF(x/**/name/**/Req))>>2;\
	dpy->bufptr += SIZEOF(x/**/name/**/Req);\
	dpy->request++
#endif

#define X_GLXSingle 0           /* needed by GetReqExtra */

static int swap_vec_element_size = 0;

static void
SendSwappedReply(ClientPtr client,
                 xGLXSingleReply * reply, char *buf, int buf_size)
{
    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->retval);
    __GLX_SWAP_INT(&reply->size);

    if ((buf_size == 0) && (swap_vec_element_size > 0)) {
        /*
         * the reply has single component - need to swap pad3
         */
        if (swap_vec_element_size == 2) {
            __GLX_SWAP_SHORT(&reply->pad3);
        }
        else if (swap_vec_element_size == 4) {
            __GLX_SWAP_INT(&reply->pad3);
            __GLX_SWAP_INT(&reply->pad4);       /* some requests use also pad4
                                                 * i.e GetConvolutionFilter
                                                 */
        }
        else if (swap_vec_element_size == 8) {
            __GLX_SWAP_DOUBLE(&reply->pad3);
        }
    }
    else if ((buf_size > 0) && (swap_vec_element_size > 0)) {
        /*
         * the reply has vector of elements which needs to be swapped
         */
        int vsize = buf_size / swap_vec_element_size;
        char *p = buf;
        int i;

        for (i = 0; i < vsize; i++) {
            if (swap_vec_element_size == 2) {
                __GLX_SWAP_SHORT(p);
            }
            else if (swap_vec_element_size == 4) {
                __GLX_SWAP_INT(p);
            }
            else if (swap_vec_element_size == 8) {
                __GLX_SWAP_DOUBLE(p);
            }

            p += swap_vec_element_size;
        }

        /*
         * swap pad words as well - for case that some single reply uses
         * them as well
         */
        __GLX_SWAP_INT(&reply->pad3);
        __GLX_SWAP_INT(&reply->pad4);
        __GLX_SWAP_INT(&reply->pad5);
        __GLX_SWAP_INT(&reply->pad6);

    }

    WriteToClient(client, sizeof(xGLXSingleReply), reply);
    if (buf_size > 0)
        WriteToClient(client, buf_size, buf);

}

int
__glXForwardSingleReq(__GLXclientState * cl, GLbyte * pc)
{
    xGLXSingleReq *req = (xGLXSingleReq *) pc;
    xGLXSingleReq *be_req;
    __GLXcontext *glxc;
    int from_screen = 0;
    int to_screen = 0;
    int buf_size;
    int s;

    glxc = __glXLookupContextByTag(cl, req->contextTag);
    if (!glxc) {
        return 0;
    }
    from_screen = to_screen = glxc->pScreen->myNum;

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    pc += sz_xGLXSingleReq;
    buf_size = (req->length << 2) - sz_xGLXSingleReq;

    /*
     * just forward the request to back-end server(s)
     */
    for (s = from_screen; s <= to_screen; s++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = GetBackEndDisplay(cl, s);

        LockDisplay(dpy);
        GetReqSingle(GLXSingle, be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = req->glxCode;
        be_req->length = req->length;
        be_req->contextTag = GetCurrentBackEndTag(cl, req->contextTag, s);
        if (buf_size > 0)
            _XSend(dpy, (const char *) pc, buf_size);
        UnlockDisplay(dpy);
        SyncHandle();

        if (req->glxCode == X_GLsop_Flush) {
            XFlush(dpy);
        }

    }

    return Success;
}

int
__glXForwardPipe0WithReply(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXSingleReq *req = (xGLXSingleReq *) pc;
    xGLXSingleReq *be_req;
    xGLXSingleReply reply;
    xGLXSingleReply be_reply;
    __GLXcontext *glxc;
    int buf_size;
    char *be_buf = NULL;
    int be_buf_size;
    DMXScreenInfo *dmxScreen;
    Display *dpy;

    glxc = __glXLookupContextByTag(cl, req->contextTag);
    if (!glxc) {
        return __glXBadContext;
    }

    pc += sz_xGLXSingleReq;
    buf_size = (req->length << 2) - sz_xGLXSingleReq;

    dmxScreen = &dmxScreens[glxc->pScreen->myNum];
    dpy = GetBackEndDisplay(cl, glxc->pScreen->myNum);

    /*
     * send the request to the first back-end server
     */
    LockDisplay(dpy);
    GetReqSingle(GLXSingle, be_req);
    be_req->reqType = dmxScreen->glxMajorOpcode;
    be_req->glxCode = req->glxCode;
    be_req->length = req->length;
    be_req->contextTag =
        GetCurrentBackEndTag(cl, req->contextTag, glxc->pScreen->myNum);
    if (buf_size > 0)
        _XSend(dpy, (const char *) pc, buf_size);

    /*
     * get the reply from the back-end server
     */
    _XReply(dpy, (xReply *) &be_reply, 0, False);
    be_buf_size = be_reply.length << 2;
    if (be_buf_size > 0) {
        be_buf = (char *) malloc(be_buf_size);
        if (be_buf) {
            _XRead(dpy, be_buf, be_buf_size);
        }
        else {
            /* Throw data on the floor */
            _XEatDataWords(dpy, be_reply.length);
            return BadAlloc;
        }
    }

    UnlockDisplay(dpy);
    SyncHandle();

    /*
     * send the reply to the client
     */
    reply = (xGLXSingleReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = be_reply.length,
        .retval = be_reply.retval,
        .size = be_reply.size,
        .pad3 = be_reply.pad3,
        .pad4 = be_reply.pad4
    };

    if (client->swapped) {
        SendSwappedReply(client, &reply, be_buf, be_buf_size);
    }
    else {
        WriteToClient(client, sizeof(xGLXSingleReply), &reply);
        if (be_buf_size > 0)
            WriteToClient(client, be_buf_size, be_buf);
    }

    if (be_buf_size > 0)
        free(be_buf);

    return Success;
}

int
__glXForwardAllWithReply(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXSingleReq *req = (xGLXSingleReq *) pc;
    xGLXSingleReq *be_req;
    xGLXSingleReply reply;
    xGLXSingleReply be_reply;
    __GLXcontext *glxc;
    int buf_size;
    char *be_buf = NULL;
    int be_buf_size = 0;
    int from_screen = 0;
    int to_screen = 0;
    int s;

    DMXScreenInfo *dmxScreen;
    Display *dpy;

    glxc = __glXLookupContextByTag(cl, req->contextTag);
    if (!glxc) {
        return 0;
    }
    from_screen = to_screen = glxc->pScreen->myNum;

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    pc += sz_xGLXSingleReq;
    buf_size = (req->length << 2) - sz_xGLXSingleReq;

    /*
     * send the request to the first back-end server(s)
     */
    for (s = to_screen; s >= from_screen; s--) {
        dmxScreen = &dmxScreens[s];
        dpy = GetBackEndDisplay(cl, s);

        LockDisplay(dpy);
        GetReqSingle(GLXSingle, be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = req->glxCode;
        be_req->length = req->length;
        be_req->contextTag = GetCurrentBackEndTag(cl, req->contextTag, s);
        if (buf_size > 0)
            _XSend(dpy, (const char *) pc, buf_size);

        /*
         * get the reply from the back-end server
         */
        _XReply(dpy, (xReply *) &be_reply, 0, False);
        if (s == from_screen) {
            /* Save data from last reply to send on to client */
            be_buf_size = be_reply.length << 2;
            if (be_buf_size > 0) {
                be_buf = malloc(be_buf_size);
                if (be_buf) {
                    _XRead(dpy, be_buf, be_buf_size);
                }
                else {
                    /* Throw data on the floor */
                    _XEatDataWords(dpy, be_reply.length);
                    return BadAlloc;
                }
            }
        }
        else {
            /* Just discard data from all replies before the last one */
            if (be_reply.length > 0)
                _XEatDataWords(dpy, be_reply.length);
        }

        UnlockDisplay(dpy);
        SyncHandle();
    }

    /*
     * send the reply to the client
     */
    reply = (xGLXSingleReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = be_reply.length,
        .retval = be_reply.retval,
        .size = be_reply.size,
        .pad3 = be_reply.pad3,
        .pad4 = be_reply.pad4
    };

    if (client->swapped) {
        SendSwappedReply(client, &reply, be_buf, be_buf_size);
    }
    else {
        WriteToClient(client, sizeof(xGLXSingleReply), &reply);
        if (be_buf_size > 0)
            WriteToClient(client, be_buf_size, be_buf);
    }

    if (be_buf_size > 0)
        free(be_buf);

    return Success;
}

int
__glXForwardSingleReqSwap(__GLXclientState * cl, GLbyte * pc)
{
    xGLXSingleReq *req = (xGLXSingleReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 0;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXSingleReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXSingleReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXForwardSingleReq(cl, pc));
}

int
__glXForwardPipe0WithReplySwap(__GLXclientState * cl, GLbyte * pc)
{
    xGLXSingleReq *req = (xGLXSingleReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 0;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXSingleReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXSingleReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXForwardPipe0WithReply(cl, pc));
}

int
__glXForwardPipe0WithReplySwapsv(__GLXclientState * cl, GLbyte * pc)
{
    xGLXSingleReq *req = (xGLXSingleReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 2;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXSingleReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXSingleReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXForwardPipe0WithReply(cl, pc));
}

int
__glXForwardPipe0WithReplySwapiv(__GLXclientState * cl, GLbyte * pc)
{
    xGLXSingleReq *req = (xGLXSingleReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 4;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXSingleReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXSingleReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXForwardPipe0WithReply(cl, pc));
}

int
__glXForwardPipe0WithReplySwapdv(__GLXclientState * cl, GLbyte * pc)
{
    xGLXSingleReq *req = (xGLXSingleReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 8;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXSingleReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXSingleReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXForwardPipe0WithReply(cl, pc));
}

int
__glXForwardAllWithReplySwap(__GLXclientState * cl, GLbyte * pc)
{
    xGLXSingleReq *req = (xGLXSingleReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 0;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXSingleReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXSingleReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXForwardAllWithReply(cl, pc));
}

int
__glXForwardAllWithReplySwapsv(__GLXclientState * cl, GLbyte * pc)
{
    xGLXSingleReq *req = (xGLXSingleReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 2;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXSingleReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXSingleReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXForwardAllWithReply(cl, pc));
}

int
__glXForwardAllWithReplySwapiv(__GLXclientState * cl, GLbyte * pc)
{
    xGLXSingleReq *req = (xGLXSingleReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 4;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXSingleReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXSingleReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXForwardAllWithReply(cl, pc));
}

int
__glXForwardAllWithReplySwapdv(__GLXclientState * cl, GLbyte * pc)
{
    xGLXSingleReq *req = (xGLXSingleReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);

    swap_vec_element_size = 8;

    /*
     * swap extra data in request - assuming all data
     * (if available) are arrays of 4 bytes components !
     */
    if (req->length > sz_xGLXSingleReq / 4) {
        int *data = (int *) (req + 1);
        int count = req->length - sz_xGLXSingleReq / 4;

        __GLX_SWAP_INT_ARRAY(data, count);
    }

    return (__glXForwardAllWithReply(cl, pc));
}

static GLint
__glReadPixels_size(GLenum format, GLenum type, GLint w, GLint h,
                    int *elementbits_return, int *rowbytes_return)
{
    GLint elements, esize;
    GLint rowsize, padding;

    if (w < 0 || h < 0) {
        return -1;
    }
    switch (format) {
    case GL_COLOR_INDEX:
    case GL_STENCIL_INDEX:
    case GL_DEPTH_COMPONENT:
        elements = 1;
        break;
    case GL_RED:
    case GL_GREEN:
    case GL_BLUE:
    case GL_ALPHA:
    case GL_LUMINANCE:
        elements = 1;
        break;
    case GL_LUMINANCE_ALPHA:
        elements = 2;
        break;
    case GL_RGB:
    case GL_BGR:
        elements = 3;
        break;
    case GL_RGBA:
    case GL_BGRA:
    case GL_ABGR_EXT:
        elements = 4;
        break;
    default:
        return -1;
    }
    /*
     ** According to the GLX protocol, each row must be padded to a multiple of
     ** 4 bytes.  4 bytes also happens to be the default alignment in the pixel
     ** store modes of the GL.
     */
    switch (type) {
    case GL_BITMAP:
        if (format == GL_COLOR_INDEX || format == GL_STENCIL_INDEX) {
            rowsize = ((w * elements) + 7) / 8;
            padding = rowsize % 4;
            if (padding) {
                rowsize += 4 - padding;
            }
            if (elementbits_return)
                *elementbits_return = elements;
            if (rowbytes_return)
                *rowbytes_return = rowsize;
            return rowsize * h;
        }
        else {
            return -1;
        }
    case GL_BYTE:
    case GL_UNSIGNED_BYTE:
        esize = 1;
        break;
    case GL_UNSIGNED_BYTE_3_3_2:
    case GL_UNSIGNED_BYTE_2_3_3_REV:
        esize = 1;
        elements = 1;
        break;
    case GL_SHORT:
    case GL_UNSIGNED_SHORT:
        esize = 2;
        break;
    case GL_UNSIGNED_SHORT_5_6_5:
    case GL_UNSIGNED_SHORT_5_6_5_REV:
    case GL_UNSIGNED_SHORT_4_4_4_4:
    case GL_UNSIGNED_SHORT_4_4_4_4_REV:
    case GL_UNSIGNED_SHORT_5_5_5_1:
    case GL_UNSIGNED_SHORT_1_5_5_5_REV:
        esize = 2;
        elements = 1;
        break;
    case GL_INT:
    case GL_UNSIGNED_INT:
    case GL_FLOAT:
        esize = 4;
        break;
    case GL_UNSIGNED_INT_8_8_8_8:
    case GL_UNSIGNED_INT_8_8_8_8_REV:
    case GL_UNSIGNED_INT_10_10_10_2:
    case GL_UNSIGNED_INT_2_10_10_10_REV:
        esize = 4;
        elements = 1;
        break;
    default:
        return -1;
    }
    rowsize = w * elements * esize;
    padding = rowsize % 4;
    if (padding) {
        rowsize += 4 - padding;
    }

    if (elementbits_return)
        *elementbits_return = esize * elements * 8;
    if (rowbytes_return)
        *rowbytes_return = rowsize;

    return rowsize * h;
}

static int
intersectRect(int x1, int x2, int y1, int y2,
              int X1, int X2, int Y1, int Y2,
              int *ix1, int *ix2, int *iy1, int *iy2)
{
    int right = (x2 < X2 ? x2 : X2);
    int bottom = (y2 < Y2 ? y2 : Y2);
    int left = (x1 > X1 ? x1 : X1);
    int top = (y1 > Y1 ? y1 : Y1);
    int width = right - left + 1;
    int height = bottom - top + 1;

    if ((width <= 0) || (height <= 0)) {
        *ix1 = *ix2 = *iy1 = *iy2 = 0;
        return 0;
    }
    else {
        *ix1 = left;
        *ix2 = right;
        *iy1 = top;
        *iy2 = bottom;
        return width * height;
    }

}

int
__glXDisp_ReadPixels(__GLXclientState * cl, GLbyte * pc)
{
    xGLXSingleReq *req = (xGLXSingleReq *) pc;
    xGLXSingleReq *be_req;
    xGLXReadPixelsReply reply;
    xGLXReadPixelsReply be_reply;
    GLbyte *be_pc;
    GLint x, y;
    GLsizei width, height;
    GLenum format, type;
    GLboolean swapBytes, lsbFirst;
    ClientPtr client = cl->client;
    DrawablePtr pDraw;
    __GLXcontext *glxc;
    int from_screen = 0;
    int to_screen = 0;
    char *buf;
    int buf_size;
    int s;
    int win_x1, win_x2;
    int win_y1, win_y2;
    int ebits, rowsize;

    if (client->swapped) {
        __GLX_DECLARE_SWAP_VARIABLES;
        __GLX_SWAP_INT(&req->contextTag);
    }

    glxc = __glXLookupContextByTag(cl, req->contextTag);
    if (!glxc) {
        return 0;
    }
    from_screen = to_screen = glxc->pScreen->myNum;

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    pc += sz_xGLXSingleReq;
    x = *(GLint *) (pc + 0);
    y = *(GLint *) (pc + 4);
    width = *(GLsizei *) (pc + 8);
    height = *(GLsizei *) (pc + 12);
    format = *(GLenum *) (pc + 16);
    type = *(GLenum *) (pc + 20);
    swapBytes = *(GLboolean *) (pc + 24);
    lsbFirst = *(GLboolean *) (pc + 25);

    if (client->swapped) {
        __GLX_DECLARE_SWAP_VARIABLES;
        __GLX_SWAP_INT(&x);
        __GLX_SWAP_INT(&y);
        __GLX_SWAP_INT(&width);
        __GLX_SWAP_INT(&height);
        __GLX_SWAP_INT(&format);
        __GLX_SWAP_INT(&type);
        swapBytes = !swapBytes;
    }

    buf_size =
        __glReadPixels_size(format, type, width, height, &ebits, &rowsize);
    if (buf_size > 0) {
        buf = (char *) malloc(buf_size);
        if (!buf) {
            return BadAlloc;
        }
    }
    else {
        buf_size = 0;
        buf = NULL;
    }

    if (buf_size > 0) {
        /*
         * Get the current drawable this context is bound to
         */
        pDraw = __glXLookupDrawableByTag(cl, req->contextTag);
        win_x1 = pDraw->x + x;
        win_x2 = win_x1 + width - 1;
        win_y1 = (dmxGlobalHeight - pDraw->y - pDraw->height) + y;
        win_y2 = win_y1 + height - 1;
        if (pDraw->type != DRAWABLE_WINDOW) {
            from_screen = to_screen = 0;
        }

        for (s = from_screen; s <= to_screen; s++) {
            DMXScreenInfo *dmxScreen = &dmxScreens[s];
            Display *dpy = GetBackEndDisplay(cl, s);
            int scr_x1 = dmxScreen->rootXOrigin;
            int scr_x2 = dmxScreen->rootXOrigin + dmxScreen->scrnWidth - 1;
            int scr_y1 = dmxScreen->rootYOrigin;
            int scr_y2 = dmxScreen->rootYOrigin + dmxScreen->scrnHeight - 1;
            int wx1, wx2, wy1, wy2;
            int sx, sy, sw, sh;
            int npixels;

            /*
             * find the window portion that is on the current screen
             */
            if (pDraw->type == DRAWABLE_WINDOW) {
                npixels = intersectRect(scr_x1, scr_x2, scr_y1, scr_y2,
                                        win_x1, win_x2, win_y1, win_y2,
                                        &wx1, &wx2, &wy1, &wy2);
            }
            else {
                wx1 = win_x1;
                wx2 = win_x2;
                wy1 = win_y1;
                wy2 = win_y2;
                npixels = (wx2 - wx1 + 1) * (wy2 - wy1 + 1);
            }

            if (npixels > 0) {

                /* send the request to the back-end server */
                LockDisplay(dpy);
                GetReqExtra(GLXSingle, __GLX_PAD(26), be_req);
                be_req->reqType = dmxScreen->glxMajorOpcode;
                be_req->glxCode = X_GLsop_ReadPixels;
                be_req->contextTag =
                    GetCurrentBackEndTag(cl, req->contextTag, s);
                be_pc = ((GLbyte *) (be_req) + sz_xGLXSingleReq);

                sx = wx1 - pDraw->x;
                sy = wy1 - (dmxGlobalHeight - pDraw->y - pDraw->height);
                sw = (wx2 - wx1 + 1);
                sh = (wy2 - wy1 + 1);

                *(GLint *) (be_pc + 0) = sx;    /* x */
                *(GLint *) (be_pc + 4) = sy;    /* y */
                *(GLsizei *) (be_pc + 8) = sw;  /* width */
                *(GLsizei *) (be_pc + 12) = sh; /* height */
                *(GLenum *) (be_pc + 16) = format;
                *(GLenum *) (be_pc + 20) = type;
                *(GLboolean *) (be_pc + 24) = swapBytes;
                *(GLboolean *) (be_pc + 25) = lsbFirst;

                _XReply(dpy, (xReply *) &be_reply, 0, False);

                if (be_reply.length > 0) {
                    char *be_buf;
                    int be_buf_size = be_reply.length << 2;

                    be_buf = (char *) malloc(be_buf_size);
                    if (be_buf) {
                        _XRead(dpy, be_buf, be_buf_size);

                        /* copy pixels data to the right location of the */
                        /* reply buffer */
                        if (type != GL_BITMAP) {
                            int pbytes = ebits / 8;
                            char *dst =
                                buf + (sy - y) * rowsize + (sx - x) * pbytes;
                            char *src = be_buf;
                            int pad = (pbytes * sw) % 4;
                            int r;

                            for (r = 0; r < sh; r++) {
                                memcpy(dst, src, pbytes * sw);
                                dst += rowsize;
                                src += (pbytes * sw + (pad ? 4 - pad : 0));
                            }
                        }
                        else {
                            /* this is a GL_BITMAP pixel type, should copy bits */
                            int r;
                            int src_rowsize = bits_to_bytes(sw * ebits);
                            int src_pad = src_rowsize % 4;

                            if (src_pad) {
                                src_rowsize += (4 - src_pad);
                            }

                            for (r = 0; r < sh; r++) {
                                unsigned char dst_mask = 0x80 >> (sx % 8);
                                unsigned char src_mask = 0x80;
                                char *dst =
                                    buf + (sy - y + r) * rowsize + (sx - x) / 8;
                                char *src = be_buf + r * src_rowsize;
                                int b;

                                for (b = 0; b < sw * ebits; b++) {
                                    if (*src & src_mask) {
                                        *dst |= dst_mask;
                                    }
                                    else {
                                        *dst &= ~dst_mask;
                                    }

                                    if (dst_mask > 1)
                                        dst_mask >>= 1;
                                    else {
                                        dst_mask = 0x80;
                                        dst++;
                                    }

                                    if (src_mask > 1)
                                        src_mask >>= 1;
                                    else {
                                        src_mask = 0x80;
                                        src++;
                                    }
                                }
                            }

                        }

                        free(be_buf);
                    }
                    else {
                        /* Throw data on the floor */
                        _XEatDataWords(dpy, be_reply.length);
                        free(buf);
                        return BadAlloc;
                    }
                }

                UnlockDisplay(dpy);
                SyncHandle();

            }                   /* of npixels > 0 */

        }                       /* of for loop */

    }                           /* of if buf_size > 0 */

    reply = (xGLXReadPixelsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = buf_size >> 2
    };

    if (client->swapped) {
        __GLX_DECLARE_SWAP_VARIABLES;
        __GLX_SWAP_SHORT(&reply.sequenceNumber);
        __GLX_SWAP_INT(&reply.length);
    }

    WriteToClient(client, sizeof(xGLXReadPixelsReply), &reply);
    if (buf_size > 0) {
        WriteToClient(client, buf_size, buf);
        free(buf);
    }

    return Success;
}

int
__glXDispSwap_GetTexImage(__GLXclientState * cl, GLbyte * pc)
{
    __GLX_DECLARE_SWAP_VARIABLES;
    GLbyte *lpc = pc;

    lpc += sz_xGLXSingleReq;
    __GLX_SWAP_INT(lpc + 0);
    __GLX_SWAP_INT(lpc + 4);
    __GLX_SWAP_INT(lpc + 8);
    __GLX_SWAP_INT(lpc + 12);

    /* reverse swapBytes */
    *(GLboolean *) (lpc + 16) = !*(GLboolean *) (lpc + 16);

    return (__glXForwardPipe0WithReplySwap(cl, pc));
}

int
__glXDispSwap_GetColorTable(__GLXclientState * cl, GLbyte * pc)
{
    __GLX_DECLARE_SWAP_VARIABLES;
    GLbyte *lpc = pc;

    lpc += sz_xGLXSingleReq;
    __GLX_SWAP_INT(lpc + 0);
    __GLX_SWAP_INT(lpc + 4);
    __GLX_SWAP_INT(lpc + 8);

    /* reverse swapBytes */
    *(GLboolean *) (lpc + 12) = !*(GLboolean *) (lpc + 12);

    return (__glXForwardPipe0WithReplySwap(cl, pc));
}
@


1.10
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@a806 2
    __GLX_DECLARE_SWAP_VARIABLES;

d808 1
d836 1
d1020 1
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d48 2
a84 4

extern Display *GetBackEndDisplay(__GLXclientState * cl, int s);
extern int GetCurrentBackEndTag(__GLXclientState * cl, GLXContextTag tag,
                                int s);
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d236 1
a236 1
    /* 
d332 1
a332 1
    /* 
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d261 1
a261 1
            _XEatData(dpy, be_buf_size);
d352 13
a364 10
        be_buf_size = be_reply.length << 2;
        if (be_buf_size > 0) {
            be_buf = (char *) malloc(be_buf_size);
            if (be_buf) {
                _XRead(dpy, be_buf, be_buf_size);
            }
            else {
                /* Throw data on the floor */
                _XEatData(dpy, be_buf_size);
                return BadAlloc;
d366 5
a374 4

        if (s > from_screen && be_buf_size > 0) {
            free(be_buf);
        }
d1000 1
a1000 1
                        _XEatData(dpy, be_buf_size);
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d150 1
a150 1
    WriteToClient(client, sizeof(xGLXSingleReply), (char *) reply);
d152 1
a152 1
        WriteToClient(client, buf_size, (char *) buf);
d252 1
a252 1
    _XReply(dpy, (xReply *) & be_reply, 0, False);
d272 9
a280 7
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = be_reply.length;
    reply.retval = be_reply.retval;
    reply.size = be_reply.size;
    reply.pad3 = be_reply.pad3;
    reply.pad4 = be_reply.pad4;
d286 1
a286 1
        WriteToClient(client, sizeof(xGLXSingleReply), (char *) &reply);
d288 1
a288 1
            WriteToClient(client, be_buf_size, (char *) be_buf);
d351 1
a351 1
        _XReply(dpy, (xReply *) & be_reply, 0, False);
d376 9
a384 7
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = be_reply.length;
    reply.retval = be_reply.retval;
    reply.size = be_reply.size;
    reply.pad3 = be_reply.pad3;
    reply.pad4 = be_reply.pad4;
d390 1
a390 1
        WriteToClient(client, sizeof(xGLXSingleReply), (char *) &reply);
d392 1
a392 1
            WriteToClient(client, be_buf_size, (char *) be_buf);
d922 1
a922 1
                _XReply(dpy, (xReply *) & be_reply, 0, False);
d1011 5
a1015 3
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = buf_size >> 2;
d1022 1
a1022 1
    WriteToClient(client, sizeof(xGLXReadPixelsReply), (char *) &reply);
d1024 1
a1024 1
        WriteToClient(client, buf_size, (char *) buf);
@


1.5
log
@Update to xserver 1.11.2
@
text
@d71 1
a71 1
#else  /* non-ANSI C uses empty comment instead of "##" for token concatenation */
d82 1
a82 1
#define X_GLXSingle 0   /* needed by GetReqExtra */
d84 3
a86 2
extern Display *GetBackEndDisplay( __GLXclientState *cl, int s );
extern int GetCurrentBackEndTag(__GLXclientState *cl, GLXContextTag tag, int s);
d90 57
a146 58
static void SendSwappedReply( ClientPtr client,
                              xGLXSingleReply *reply, 
			      char *buf,
			      int   buf_size )
{
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_SWAP_SHORT(&reply->sequenceNumber);
   __GLX_SWAP_INT(&reply->length);
   __GLX_SWAP_INT(&reply->retval);
   __GLX_SWAP_INT(&reply->size);

   if ( (buf_size == 0) && (swap_vec_element_size > 0) ) {
      /*
       * the reply has single component - need to swap pad3
       */
      if (swap_vec_element_size == 2) {
	 __GLX_SWAP_SHORT(&reply->pad3);
      }
      else if (swap_vec_element_size == 4) {
	 __GLX_SWAP_INT(&reply->pad3);
	 __GLX_SWAP_INT(&reply->pad4);    /* some requests use also pad4
                                          * i.e GetConvolutionFilter
					  */
      }
      else if (swap_vec_element_size == 8) {
	 __GLX_SWAP_DOUBLE(&reply->pad3);
      }
   }
   else if ( (buf_size > 0) && (swap_vec_element_size > 0) ) {
      /*
       * the reply has vector of elements which needs to be swapped
       */
      int vsize = buf_size / swap_vec_element_size;
      char *p = buf;
      int i;

      for (i=0; i<vsize; i++) {
	 if (swap_vec_element_size == 2) {
	    __GLX_SWAP_SHORT(p);
	 }
	 else if (swap_vec_element_size == 4) {
	    __GLX_SWAP_INT(p);
	 }
	 else if (swap_vec_element_size == 8) {
	    __GLX_SWAP_DOUBLE(p);
	 }

	 p += swap_vec_element_size;
      }

      /*
       * swap pad words as well - for case that some single reply uses
       * them as well
       */
      __GLX_SWAP_INT(&reply->pad3);
      __GLX_SWAP_INT(&reply->pad4);
      __GLX_SWAP_INT(&reply->pad5);
      __GLX_SWAP_INT(&reply->pad6);
d148 1
a148 1
   }
d150 1
a150 1
    WriteToClient(client, sizeof(xGLXSingleReply),(char *)reply);
d152 1
a152 1
       WriteToClient(client, buf_size, (char *)buf);
d156 2
a157 1
int __glXForwardSingleReq( __GLXclientState *cl, GLbyte *pc )
d159 2
a160 2
   xGLXSingleReq *req = (xGLXSingleReq *)pc;
   xGLXSingleReq *be_req;
d162 4
a165 4
   int from_screen = 0;
   int to_screen = 0;
   int buf_size;
   int s;
d169 1
a169 1
	return 0;
d175 2
a176 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d186 18
a203 18
    for (s=from_screen; s<=to_screen; s++) {
       DMXScreenInfo *dmxScreen = &dmxScreens[s];
       Display *dpy = GetBackEndDisplay(cl,s);

       LockDisplay(dpy);
       GetReqSingle(GLXSingle,be_req);
       be_req->reqType = dmxScreen->glxMajorOpcode;
       be_req->glxCode = req->glxCode;
       be_req->length = req->length;
       be_req->contextTag = GetCurrentBackEndTag(cl,req->contextTag,s);
       if (buf_size > 0) 
	  _XSend(dpy, (const char *)pc, buf_size);
       UnlockDisplay(dpy);
       SyncHandle();

       if (req->glxCode == X_GLsop_Flush) {
	  XFlush(dpy);
       }
d210 2
a211 1
int __glXForwardPipe0WithReply( __GLXclientState *cl, GLbyte *pc )
d213 5
a217 5
   ClientPtr client = cl->client;
   xGLXSingleReq *req = (xGLXSingleReq *)pc;
   xGLXSingleReq *be_req;
   xGLXSingleReply reply;
   xGLXSingleReply be_reply;
d219 5
a223 5
   int buf_size;
   char *be_buf = NULL;
   int   be_buf_size;
   DMXScreenInfo *dmxScreen;
   Display *dpy;
d227 1
a227 1
	return __glXBadContext;
d240 1
a240 1
    GetReqSingle(GLXSingle,be_req);
d244 4
a247 3
    be_req->contextTag = GetCurrentBackEndTag(cl,req->contextTag,glxc->pScreen->myNum);
    if (buf_size > 0) 
       _XSend(dpy, (const char *)pc, buf_size);
d252 1
a252 1
    _XReply(dpy, (xReply*) &be_reply, 0, False);
d255 9
a263 9
       be_buf = (char *)malloc( be_buf_size );
       if (be_buf) {
	  _XRead(dpy, be_buf, be_buf_size);
       }
       else {
	  /* Throw data on the floor */
	  _XEatData(dpy, be_buf_size);
	  return BadAlloc;
       }
d281 1
a281 1
       SendSwappedReply( client, &reply, be_buf, be_buf_size );
d284 3
a286 3
       WriteToClient(client, sizeof(xGLXSingleReply),(char *)&reply);
       if (be_buf_size > 0)
	  WriteToClient(client, be_buf_size, (char *)be_buf);
d289 2
a290 1
    if (be_buf_size > 0) free(be_buf);
d295 2
a296 1
int __glXForwardAllWithReply( __GLXclientState *cl, GLbyte *pc )
d298 5
a302 5
   ClientPtr client = cl->client;
   xGLXSingleReq *req = (xGLXSingleReq *)pc;
   xGLXSingleReq *be_req;
   xGLXSingleReply reply;
   xGLXSingleReply be_reply;
d304 6
a309 6
   int buf_size;
   char *be_buf = NULL;
   int   be_buf_size = 0;
   int from_screen = 0;
   int to_screen = 0;
   int s;
d311 2
a312 2
   DMXScreenInfo *dmxScreen;
   Display *dpy;
d316 1
a316 1
	return 0;
d322 2
a323 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d333 36
a368 36
    for (s=to_screen; s>=from_screen; s--) {
       dmxScreen = &dmxScreens[s];
       dpy = GetBackEndDisplay(cl,s);

       LockDisplay(dpy);
       GetReqSingle(GLXSingle,be_req);
       be_req->reqType = dmxScreen->glxMajorOpcode;
       be_req->glxCode = req->glxCode;
       be_req->length = req->length;
       be_req->contextTag = GetCurrentBackEndTag(cl,req->contextTag,s);
       if (buf_size > 0) 
	  _XSend(dpy, (const char *)pc, buf_size);

       /*
	* get the reply from the back-end server
	*/
       _XReply(dpy, (xReply*) &be_reply, 0, False);
       be_buf_size = be_reply.length << 2;
       if (be_buf_size > 0) {
	  be_buf = (char *)malloc( be_buf_size );
	  if (be_buf) {
	     _XRead(dpy, be_buf, be_buf_size);
	  }
	  else {
	     /* Throw data on the floor */
	     _XEatData(dpy, be_buf_size);
	     return BadAlloc;
	  }
       }

       UnlockDisplay(dpy);
       SyncHandle();

       if (s > from_screen && be_buf_size > 0) {
	  free(be_buf);
       }
d383 1
a383 1
       SendSwappedReply( client, &reply, be_buf, be_buf_size );
d386 3
a388 3
       WriteToClient(client, sizeof(xGLXSingleReply),(char *)&reply);
       if (be_buf_size > 0)
	  WriteToClient(client, be_buf_size, (char *)be_buf);
d391 2
a392 1
    if (be_buf_size > 0) free(be_buf);
d397 2
a398 1
int __glXForwardSingleReqSwap( __GLXclientState *cl, GLbyte *pc )
d400 1
a400 3
   xGLXSingleReq *req = (xGLXSingleReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d402 2
a403 2
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->contextTag);
d405 2
a406 1
   swap_vec_element_size = 0;
d408 1
a408 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXSingleReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXSingleReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d410 12
a421 1
   return( __glXForwardSingleReq( cl, pc ) );
d424 2
a425 1
int __glXForwardPipe0WithReplySwap( __GLXclientState *cl, GLbyte *pc )
d427 1
a427 3
   xGLXSingleReq *req = (xGLXSingleReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d429 5
a433 2
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->contextTag);
d435 9
a443 1
   swap_vec_element_size = 0;
d445 2
a446 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXSingleReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXSingleReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d448 1
a448 1
   return( __glXForwardPipe0WithReply( cl, pc ) );
d451 2
a452 1
int __glXForwardPipe0WithReplySwapsv( __GLXclientState *cl, GLbyte *pc )
d454 1
a454 3
   xGLXSingleReq *req = (xGLXSingleReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d456 2
a457 2
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->contextTag);
d459 2
a460 1
   swap_vec_element_size = 2;
d462 1
a462 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXSingleReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXSingleReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d464 7
d472 4
a475 1
   return( __glXForwardPipe0WithReply( cl, pc ) );
d478 2
a479 1
int __glXForwardPipe0WithReplySwapiv( __GLXclientState *cl, GLbyte *pc )
d481 4
a484 3
   xGLXSingleReq *req = (xGLXSingleReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d486 2
a487 2
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->contextTag);
d489 1
a489 1
   swap_vec_element_size = 4;
d491 7
a497 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXSingleReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXSingleReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d499 2
d502 1
a502 1
   return( __glXForwardPipe0WithReply( cl, pc ) );
d505 2
a506 1
int __glXForwardPipe0WithReplySwapdv( __GLXclientState *cl, GLbyte *pc )
d508 4
a511 3
   xGLXSingleReq *req = (xGLXSingleReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d513 2
a514 2
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->contextTag);
d516 1
a516 1
   swap_vec_element_size = 8;
d518 7
a524 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXSingleReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXSingleReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d526 2
d529 1
a529 1
   return( __glXForwardPipe0WithReply( cl, pc ) );
d532 2
a533 1
int __glXForwardAllWithReplySwap( __GLXclientState *cl, GLbyte *pc )
d535 1
a535 3
   xGLXSingleReq *req = (xGLXSingleReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d537 2
a538 2
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->contextTag);
d540 2
a541 1
   swap_vec_element_size = 0;
d543 1
a543 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXSingleReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXSingleReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d545 10
d556 1
a556 1
   return( __glXForwardAllWithReply( cl, pc ) );
d559 2
a560 1
int __glXForwardAllWithReplySwapsv( __GLXclientState *cl, GLbyte *pc )
d562 1
a562 3
   xGLXSingleReq *req = (xGLXSingleReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d564 2
a565 2
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->contextTag);
d567 2
a568 1
   swap_vec_element_size = 2;
d570 1
a570 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXSingleReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXSingleReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d572 10
d583 1
a583 1
   return( __glXForwardAllWithReply( cl, pc ) );
d586 2
a587 1
int __glXForwardAllWithReplySwapiv( __GLXclientState *cl, GLbyte *pc )
d589 1
a589 3
   xGLXSingleReq *req = (xGLXSingleReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d591 2
a592 2
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->contextTag);
d594 2
a595 1
   swap_vec_element_size = 4;
d597 1
a597 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXSingleReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXSingleReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d599 7
d607 4
a610 1
   return( __glXForwardAllWithReply( cl, pc ) );
d613 2
a614 1
int __glXForwardAllWithReplySwapdv( __GLXclientState *cl, GLbyte *pc )
d616 1
a616 3
   xGLXSingleReq *req = (xGLXSingleReq *)pc;
   __GLX_DECLARE_SWAP_VARIABLES;
   __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
d618 2
a619 2
   __GLX_SWAP_SHORT(&req->length);
   __GLX_SWAP_INT(&req->contextTag);
d621 2
a622 1
   swap_vec_element_size = 8;
d624 1
a624 9
   /*
    * swap extra data in request - assuming all data
    * (if available) are arrays of 4 bytes components !
    */
   if (req->length > sz_xGLXSingleReq/4) {
      int *data = (int *)(req+1);
      int count = req->length - sz_xGLXSingleReq/4;
      __GLX_SWAP_INT_ARRAY(data, count );
   }
d626 10
d637 1
a637 1
   return( __glXForwardAllWithReply( cl, pc ) );
d640 3
a642 2
static GLint __glReadPixels_size(GLenum format, GLenum type, GLint w, GLint h, 
                          int *elementbits_return, int *rowbytes_return )
d648 1
a648 1
	return -1;
d651 32
a682 32
      case GL_COLOR_INDEX:
      case GL_STENCIL_INDEX:
      case GL_DEPTH_COMPONENT:
	elements = 1;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_LUMINANCE:
	elements = 1;
	break;
      case GL_LUMINANCE_ALPHA:
	elements = 2;
	break;
      case GL_RGB:
      case GL_BGR:
	elements = 3;
	break;
      case GL_RGBA:
      case GL_BGRA:
      case GL_ABGR_EXT:
	elements = 4;
	break;
      default:
	return -1;
    }
    /*
    ** According to the GLX protocol, each row must be padded to a multiple of
    ** 4 bytes.  4 bytes also happens to be the default alignment in the pixel
    ** store modes of the GL.
    */
d684 52
a735 49
      case GL_BITMAP:
	if (format == GL_COLOR_INDEX || format == GL_STENCIL_INDEX) {
	   rowsize = ((w * elements)+7)/8;
	   padding = rowsize % 4;
	   if (padding) {
	      rowsize += 4 - padding;
	   }
	   if (elementbits_return) *elementbits_return = elements;
	   if (rowbytes_return) *rowbytes_return = rowsize;
	   return rowsize * h;
	} else {
	   return -1;
	}
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
	esize = 1;
	break;
      case GL_UNSIGNED_BYTE_3_3_2:
      case GL_UNSIGNED_BYTE_2_3_3_REV:
	esize = 1;
	elements = 1;
	break;
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
	esize = 2;
	break;
      case GL_UNSIGNED_SHORT_5_6_5:
      case GL_UNSIGNED_SHORT_5_6_5_REV:
      case GL_UNSIGNED_SHORT_4_4_4_4:
      case GL_UNSIGNED_SHORT_4_4_4_4_REV:
      case GL_UNSIGNED_SHORT_5_5_5_1:
      case GL_UNSIGNED_SHORT_1_5_5_5_REV:
	esize = 2;
	elements = 1;
	break;
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	esize = 4;
	break;
      case GL_UNSIGNED_INT_8_8_8_8:
      case GL_UNSIGNED_INT_8_8_8_8_REV:
      case GL_UNSIGNED_INT_10_10_10_2:
      case GL_UNSIGNED_INT_2_10_10_10_REV:
	esize = 4;
	elements = 1;
	break;
      default:
	return -1;
d740 1
a740 1
	rowsize += 4 - padding;
d743 4
a746 2
    if (elementbits_return) *elementbits_return = esize*elements*8;
    if (rowbytes_return) *rowbytes_return = rowsize;
d751 23
a773 22
static int intersectRect( int x1, int x2, int y1, int y2,
                    int X1, int X2, int Y1, int Y2,
		    int *ix1, int *ix2, int *iy1, int *iy2 )
{
   int right = (x2 < X2 ? x2 : X2);
   int bottom = (y2 < Y2 ? y2 : Y2);
   int left = (x1 > X1 ? x1 : X1);
   int top = (y1 > Y1 ? y1 : Y1);
   int width = right - left + 1;
   int height = bottom - top + 1;

   if ( (width <= 0) || (height <= 0) ) {
      *ix1 = *ix2 = *iy1 = *iy2 = 0;
      return 0;
   }
   else {
      *ix1 = left;
      *ix2 = right;
      *iy1 = top;
      *iy2 = bottom;
      return width * height;
   }
d777 2
a778 1
int __glXDisp_ReadPixels(__GLXclientState *cl, GLbyte *pc)
d780 1
a780 1
    xGLXSingleReq *req = (xGLXSingleReq *)pc;
d785 1
a785 1
    GLint x,y;
d800 1
d804 1
a804 1
       __GLX_SWAP_INT(&req->contextTag);
d809 1
a809 1
	return 0;
d815 2
a816 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d821 8
a828 8
    x = *(GLint *)(pc + 0);
    y = *(GLint *)(pc + 4);
    width = *(GLsizei *)(pc + 8);
    height = *(GLsizei *)(pc + 12);
    format = *(GLenum *)(pc + 16);
    type = *(GLenum *)(pc + 20);
    swapBytes = *(GLboolean *)(pc + 24);
    lsbFirst = *(GLboolean *)(pc + 25);
d831 7
a837 7
       __GLX_SWAP_INT(&x);
       __GLX_SWAP_INT(&y);
       __GLX_SWAP_INT(&width);
       __GLX_SWAP_INT(&height);
       __GLX_SWAP_INT(&format);
       __GLX_SWAP_INT(&type);
       swapBytes = !swapBytes;
d840 2
a841 1
    buf_size = __glReadPixels_size(format,type,width,height, &ebits, &rowsize);
d843 4
a846 4
       buf = (char *) malloc( buf_size );
       if ( !buf ) {
	  return BadAlloc;
       }
d849 2
a850 2
       buf_size = 0;
       buf = NULL;
d854 143
a996 137
       /*
	* Get the current drawable this context is bound to
	*/
       pDraw = __glXLookupDrawableByTag( cl, req->contextTag );
       win_x1 = pDraw->x + x;
       win_x2 = win_x1 + width - 1;
       win_y1 = (dmxGlobalHeight - pDraw->y - pDraw->height) + y;
       win_y2 = win_y1 + height - 1;
       if (pDraw->type != DRAWABLE_WINDOW) {
	  from_screen = to_screen = 0;
       }

       for (s=from_screen; s<=to_screen; s++) {
	  DMXScreenInfo *dmxScreen = &dmxScreens[s];
	  Display *dpy = GetBackEndDisplay(cl,s);
	  int scr_x1 = dmxScreen->rootXOrigin;
	  int scr_x2 = dmxScreen->rootXOrigin + dmxScreen->scrnWidth - 1;
	  int scr_y1 = dmxScreen->rootYOrigin;
	  int scr_y2 = dmxScreen->rootYOrigin + dmxScreen->scrnHeight - 1;
	  int wx1, wx2, wy1, wy2;
	  int sx, sy, sw, sh;
	  int npixels;

	  /*
	   * find the window portion that is on the current screen
	   */
	  if (pDraw->type == DRAWABLE_WINDOW) {
	     npixels = intersectRect( scr_x1, scr_x2, scr_y1, scr_y2,
		   win_x1, win_x2, win_y1, win_y2,
		   &wx1, &wx2, &wy1, &wy2 );
	  }
	  else {
	     wx1 = win_x1;
	     wx2 = win_x2;
	     wy1 = win_y1;
	     wy2 = win_y2;
	     npixels = (wx2-wx1+1) * (wy2-wy1+1);
	  }

   	  if (npixels > 0) {

   	     /* send the request to the back-end server */
   	     LockDisplay(dpy);
   	     GetReqExtra(GLXSingle,__GLX_PAD(26),be_req);
   	     be_req->reqType = dmxScreen->glxMajorOpcode;
   	     be_req->glxCode = X_GLsop_ReadPixels;
   	     be_req->contextTag = GetCurrentBackEndTag(cl,req->contextTag,s);
   	     be_pc = ((GLbyte *)(be_req) + sz_xGLXSingleReq);

   	     sx = wx1 - pDraw->x;
   	     sy = wy1 - (dmxGlobalHeight - pDraw->y - pDraw->height); 
   	     sw = (wx2-wx1+1); 
   	     sh = (wy2-wy1+1); 
	     
	     *(GLint *)(be_pc + 0) = sx;    /* x */
	     *(GLint *)(be_pc + 4) = sy;    /* y */
	     *(GLsizei *)(be_pc + 8) = sw;    /* width */
	     *(GLsizei *)(be_pc + 12) = sh;   /* height */
	     *(GLenum *)(be_pc + 16) = format; 
	     *(GLenum *)(be_pc + 20) = type;
	     *(GLboolean *)(be_pc + 24) = swapBytes;
	     *(GLboolean *)(be_pc + 25) = lsbFirst;

	     _XReply(dpy, (xReply*) &be_reply, 0, False);
         
	     if (be_reply.length > 0) {
		char *be_buf;
		int be_buf_size = be_reply.length << 2;

		be_buf = (char *) malloc( be_buf_size );
		if (be_buf) {
		   _XRead(dpy, be_buf, be_buf_size);

		   /* copy pixels data to the right location of the */
		   /* reply buffer */
		   if ( type != GL_BITMAP ) {
		      int pbytes = ebits / 8;
		      char *dst = buf + (sy-y)*rowsize + (sx-x)*pbytes;
		      char *src = be_buf;
		      int pad = (pbytes * sw) % 4;
		      int r;

		      for (r=0; r<sh; r++) {
			 memcpy( dst, src, pbytes*sw );
			 dst += rowsize;
			 src += (pbytes*sw + (pad ? 4-pad : 0) );
		      }
		   }
		   else {
		      /* this is a GL_BITMAP pixel type, should copy bits */
		      int r;
		      int src_rowsize = bits_to_bytes(sw * ebits);
		      int src_pad = src_rowsize % 4;
                      if ( src_pad ) {
			 src_rowsize += (4 - src_pad);
		      }

		      for (r=0; r<sh; r++) {
			 unsigned char dst_mask = 0x80 >> (sx % 8);
			 unsigned char src_mask = 0x80;
			 char *dst = buf + (sy-y+r)*rowsize + (sx-x)/8;
			 char *src = be_buf + r*src_rowsize;
			 int b;

			 for (b=0; b<sw*ebits; b++) {
			    if ( *src & src_mask ) {
			       *dst |= dst_mask;
			    }
			    else {
			       *dst &= ~dst_mask;
			    }

			    if (dst_mask > 1) dst_mask >>= 1;
			    else { 
			       dst_mask = 0x80;
			       dst++;
			    }

			    if (src_mask > 1) src_mask >>= 1;
			    else {
			       src_mask = 0x80;
			       src++;
			    }
			 }
		      }

		   }

		   free( be_buf );
		}
		else {
		   /* Throw data on the floor */
		   _XEatData(dpy, be_buf_size);
		   free( buf );
		   return BadAlloc;
		}
	     }
d998 2
a999 2
	     UnlockDisplay(dpy);
	     SyncHandle();
d1001 1
a1001 1
	  } /* of npixels > 0 */ 
d1003 1
a1003 1
       }  /* of for loop */
d1005 1
a1005 1
    } /* of if buf_size > 0 */
d1012 2
a1013 2
       __GLX_SWAP_SHORT(&reply.sequenceNumber);
       __GLX_SWAP_INT(&reply.length);
d1016 1
a1016 1
    WriteToClient(client, sizeof(xGLXReadPixelsReply),(char *)&reply);
d1018 2
a1019 2
       WriteToClient(client, buf_size, (char *)buf);
       free( buf );
d1025 2
a1026 1
int __glXDispSwap_GetTexImage(__GLXclientState *cl, GLbyte *pc)
d1032 4
a1035 4
    __GLX_SWAP_INT(lpc+0);
    __GLX_SWAP_INT(lpc+4);
    __GLX_SWAP_INT(lpc+8);
    __GLX_SWAP_INT(lpc+12);
d1038 1
a1038 1
    *(GLboolean *)(lpc + 16) = ! *(GLboolean *)(lpc + 16);
d1040 1
a1040 1
    return( __glXForwardPipe0WithReplySwap( cl, pc ) );
d1043 2
a1044 1
int __glXDispSwap_GetColorTable(__GLXclientState *cl, GLbyte *pc)
d1050 3
a1052 3
    __GLX_SWAP_INT(lpc+0);
    __GLX_SWAP_INT(lpc+4);
    __GLX_SWAP_INT(lpc+8);
d1055 1
a1055 1
    *(GLboolean *)(lpc + 12) = ! *(GLboolean *)(lpc + 12);
d1057 1
a1057 1
    return( __glXForwardPipe0WithReplySwap( cl, pc ) );
a1058 2


@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a41 5
#undef Xmalloc
#undef Xcalloc
#undef Xrealloc
#undef Xfree

d218 1
a218 1
   char *be_buf;
d300 2
a301 2
   char *be_buf;
   int   be_buf_size;
d814 1
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d257 1
a257 1
       be_buf = (char *)Xalloc( be_buf_size );
d291 1
a291 1
    if (be_buf_size > 0) Xfree(be_buf);
d352 1
a352 1
	  be_buf = (char *)Xalloc( be_buf_size );
d367 1
a367 1
	  Xfree(be_buf);
d391 1
a391 1
    if (be_buf_size > 0) Xfree(be_buf);
d400 1
d424 1
d448 1
d473 1
d498 1
d523 1
d548 1
d573 1
d598 1
d671 1
a671 1
	   return (rowsize * h);
d721 1
a721 1
    return (rowsize * h);
d737 1
a737 1
      return(0);
d744 1
a744 1
      return( width * height );
a761 1
    int error;
d812 1
a812 1
       buf = (char *) Xalloc( buf_size );
d814 1
a814 1
	  return( BadAlloc );
d891 1
a891 1
		be_buf = (char *) Xalloc( be_buf_size );
d950 1
a950 1
		   Xfree( be_buf );
d955 1
a955 1
		   Xfree( buf );
d981 1
a981 1
       Xfree( buf );
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a46 1
#define NEED_REPLIES
d905 1
a905 1
		      int src_rowsize = ((sw * ebits) + 7) / 8;
@


1.1
log
@Initial revision
@
text
@d3 28
a30 27
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: This software was created using the
** OpenGL(R) version 1.2.1 Sample Implementation published by SGI, but has
** not been independently verified as being compliant with the OpenGL(R)
** version 1.2.1 Specification.
*/
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
