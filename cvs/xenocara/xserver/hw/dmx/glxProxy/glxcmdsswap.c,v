head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.10
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.8
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	7pAEtF6Y5EgemkuY;

1.9
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.21.20.10.46;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.23.38;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.23.38;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

#include "glxserver.h"
#include "glxutil.h"
#include <GL/glxtokens.h>
#include <g_disptab.h>
#include <pixmapstr.h>
#include <windowstr.h>
#include "unpack.h"
#include "glxcmds.h"
#include "glxext.h"
#include "glxvendor.h"

int __glXSwapGetFBConfigsSGIX(__GLXclientState * cl, GLbyte * pc);

/************************************************************************/

/*
** Byteswapping versions of GLX commands.  In most cases they just swap
** the incoming arguments and then call the unswapped routine.  For commands
** that have replies, a separate swapping routine for the reply is provided;
** it is called at the end of the unswapped routine.
*/

int
__glXSwapCreateContext(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->context);
    __GLX_SWAP_INT(&req->visual);
    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->shareList);

    return __glXCreateContext(cl, pc);
}

int
__glXSwapCreateNewContext(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreateNewContextReq *req = (xGLXCreateNewContextReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->context);
    __GLX_SWAP_INT(&req->fbconfig);
    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->shareList);

    return __glXCreateNewContext(cl, pc);
}

int
__glXSwapCreateContextWithConfigSGIX(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreateContextWithConfigSGIXReq *req =
        (xGLXCreateContextWithConfigSGIXReq *) pc;
    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->context);
    __GLX_SWAP_INT(&req->fbconfig);
    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->shareList);

    return __glXCreateContextWithConfigSGIX(cl, pc);
}

int
__glXSwapQueryMaxSwapBarriersSGIX(__GLXclientState * cl, GLbyte * pc)
{
    xGLXQueryMaxSwapBarriersSGIXReq *req =
        (xGLXQueryMaxSwapBarriersSGIXReq *) pc;
    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->screen);

    return __glXQueryMaxSwapBarriersSGIX(cl, pc);
}

int
__glXSwapBindSwapBarrierSGIX(__GLXclientState * cl, GLbyte * pc)
{
    xGLXBindSwapBarrierSGIXReq *req = (xGLXBindSwapBarrierSGIXReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->drawable);
    __GLX_SWAP_INT(&req->barrier);

    return __glXBindSwapBarrierSGIX(cl, pc);
}

int
__glXSwapJoinSwapGroupSGIX(__GLXclientState * cl, GLbyte * pc)
{
    xGLXJoinSwapGroupSGIXReq *req = (xGLXJoinSwapGroupSGIXReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->drawable);
    __GLX_SWAP_INT(&req->member);

    return __glXJoinSwapGroupSGIX(cl, pc);
}

int
__glXSwapDestroyContext(__GLXclientState * cl, GLbyte * pc)
{
    xGLXDestroyContextReq *req = (xGLXDestroyContextReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->context);

    return __glXDestroyContext(cl, pc);
}

int
__glXSwapMakeCurrent(__GLXclientState * cl, GLbyte * pc)
{
    xGLXMakeCurrentReq *req = (xGLXMakeCurrentReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->drawable);
    __GLX_SWAP_INT(&req->context);
    __GLX_SWAP_INT(&req->oldContextTag);

    return __glXMakeCurrent(cl, pc);
}

int
__glXSwapMakeContextCurrent(__GLXclientState * cl, GLbyte * pc)
{
    xGLXMakeContextCurrentReq *req = (xGLXMakeContextCurrentReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->drawable);
    __GLX_SWAP_INT(&req->readdrawable);
    __GLX_SWAP_INT(&req->context);
    __GLX_SWAP_INT(&req->oldContextTag);

    return __glXMakeContextCurrent(cl, pc);
}

int
__glXSwapMakeCurrentReadSGI(__GLXclientState * cl, GLbyte * pc)
{
    xGLXMakeCurrentReadSGIReq *req = (xGLXMakeCurrentReadSGIReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->drawable);
    __GLX_SWAP_INT(&req->readable);
    __GLX_SWAP_INT(&req->context);
    __GLX_SWAP_INT(&req->oldContextTag);

    return __glXMakeCurrentReadSGI(cl, pc);
}

int
__glXSwapIsDirect(__GLXclientState * cl, GLbyte * pc)
{
    xGLXIsDirectReq *req = (xGLXIsDirectReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->context);

    return __glXIsDirect(cl, pc);
}

int
__glXSwapQueryVersion(__GLXclientState * cl, GLbyte * pc)
{
    xGLXQueryVersionReq *req = (xGLXQueryVersionReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->majorVersion);
    __GLX_SWAP_INT(&req->minorVersion);

    return __glXQueryVersion(cl, pc);
}

int
__glXSwapWaitGL(__GLXclientState * cl, GLbyte * pc)
{
    xGLXWaitGLReq *req = (xGLXWaitGLReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);

    return __glXWaitGL(cl, pc);
}

int
__glXSwapWaitX(__GLXclientState * cl, GLbyte * pc)
{
    xGLXWaitXReq *req = (xGLXWaitXReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);

    return __glXWaitX(cl, pc);
}

int
__glXSwapCopyContext(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCopyContextReq *req = (xGLXCopyContextReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->source);
    __GLX_SWAP_INT(&req->dest);
    __GLX_SWAP_INT(&req->mask);

    return __glXCopyContext(cl, pc);
}

int
__glXSwapGetVisualConfigs(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXGetVisualConfigsReq *req = (xGLXGetVisualConfigsReq *) pc;
    xGLXGetVisualConfigsReply reply;
    __GLXscreenInfo *pGlxScreen;
    __GLXvisualConfig *pGlxVisual;
    CARD32 buf[__GLX_TOTAL_CONFIG];
    unsigned int screen;
    int i, p;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_INT(&req->screen);
    screen = req->screen;
    if (screen >= screenInfo.numScreens) {
        /* The client library must send a valid screen number. */
        client->errorValue = screen;
        return BadValue;
    }
    pGlxScreen = &__glXActiveScreens[screen];

    reply = (xGLXGetVisualConfigsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = (pGlxScreen->numGLXVisuals * __GLX_SIZE_CARD32 *
                   __GLX_TOTAL_CONFIG) >> 2,
        .numVisuals = pGlxScreen->numGLXVisuals,
        .numProps = __GLX_TOTAL_CONFIG
    };

    __GLX_SWAP_SHORT(&reply.sequenceNumber);
    __GLX_SWAP_INT(&reply.length);
    __GLX_SWAP_INT(&reply.numVisuals);
    __GLX_SWAP_INT(&reply.numProps);
    WriteToClient(client, sz_xGLXGetVisualConfigsReply, &reply);

    for (i = 0; i < pGlxScreen->numVisuals; i++) {
        pGlxVisual = &pGlxScreen->pGlxVisual[i];
        if (!pGlxScreen->isGLXvis[i] || pGlxVisual->vid == 0) {
            /* not a usable visual */
            continue;
        }
        p = 0;
        buf[p++] = pGlxVisual->vid;
        buf[p++] = pGlxVisual->class;
        buf[p++] = pGlxVisual->rgba;

        buf[p++] = pGlxVisual->redSize;
        buf[p++] = pGlxVisual->greenSize;
        buf[p++] = pGlxVisual->blueSize;
        buf[p++] = pGlxVisual->alphaSize;
        buf[p++] = pGlxVisual->accumRedSize;
        buf[p++] = pGlxVisual->accumGreenSize;
        buf[p++] = pGlxVisual->accumBlueSize;
        buf[p++] = pGlxVisual->accumAlphaSize;

        buf[p++] = pGlxVisual->doubleBuffer;
        buf[p++] = pGlxVisual->stereo;

        buf[p++] = pGlxVisual->bufferSize;
        buf[p++] = pGlxVisual->depthSize;
        buf[p++] = pGlxVisual->stencilSize;
        buf[p++] = pGlxVisual->auxBuffers;
        buf[p++] = pGlxVisual->level;
        /*
         ** Add token/value pairs for extensions.
         */
        buf[p++] = GLX_VISUAL_CAVEAT_EXT;
        buf[p++] = pGlxVisual->visualRating;
        buf[p++] = GLX_TRANSPARENT_TYPE_EXT;
        buf[p++] = pGlxVisual->transparentPixel;
        buf[p++] = GLX_TRANSPARENT_RED_VALUE_EXT;
        buf[p++] = pGlxVisual->transparentRed;
        buf[p++] = GLX_TRANSPARENT_GREEN_VALUE_EXT;
        buf[p++] = pGlxVisual->transparentGreen;
        buf[p++] = GLX_TRANSPARENT_BLUE_VALUE_EXT;
        buf[p++] = pGlxVisual->transparentBlue;
        buf[p++] = GLX_TRANSPARENT_ALPHA_VALUE_EXT;
        buf[p++] = pGlxVisual->transparentAlpha;
        buf[p++] = GLX_TRANSPARENT_INDEX_VALUE_EXT;
        buf[p++] = pGlxVisual->transparentIndex;

        __GLX_SWAP_INT_ARRAY(buf, __GLX_TOTAL_CONFIG);
        WriteToClient(client, __GLX_SIZE_CARD32 * __GLX_TOTAL_CONFIG, buf);
    }
    return Success;
}

int
__glXSwapCreateGLXPixmap(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreateGLXPixmapReq *req = (xGLXCreateGLXPixmapReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->visual);
    __GLX_SWAP_INT(&req->pixmap);
    __GLX_SWAP_INT(&req->glxpixmap);

    return __glXCreateGLXPixmap(cl, pc);
}

int
__glXSwapCreatePixmap(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreatePixmapReq *req = (xGLXCreatePixmapReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->fbconfig);
    __GLX_SWAP_INT(&req->pixmap);
    __GLX_SWAP_INT(&req->glxpixmap);
    __GLX_SWAP_INT(&req->numAttribs);

    return __glXCreatePixmap(cl, pc);
}

int
__glXSwapDestroyGLXPixmap(__GLXclientState * cl, GLbyte * pc)
{
    xGLXDestroyGLXPixmapReq *req = (xGLXDestroyGLXPixmapReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->glxpixmap);

    return __glXDestroyGLXPixmap(cl, pc);
}

int
__glXSwapSwapBuffers(__GLXclientState * cl, GLbyte * pc)
{
    xGLXSwapBuffersReq *req = (xGLXSwapBuffersReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);
    __GLX_SWAP_INT(&req->drawable);

    return __glXSwapBuffers(cl, pc);
}

int
__glXSwapUseXFont(__GLXclientState * cl, GLbyte * pc)
{
    xGLXUseXFontReq *req = (xGLXUseXFontReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);
    __GLX_SWAP_INT(&req->font);
    __GLX_SWAP_INT(&req->first);
    __GLX_SWAP_INT(&req->count);
    __GLX_SWAP_INT(&req->listBase);

    return __glXUseXFont(cl, pc);
}

int
__glXSwapQueryExtensionsString(__GLXclientState * cl, GLbyte * pc)
{
    xGLXQueryExtensionsStringReq *req = (xGLXQueryExtensionsStringReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->screen);

    return __glXQueryExtensionsString(cl, pc);
}

int
__glXSwapQueryServerString(__GLXclientState * cl, GLbyte * pc)
{
    xGLXQueryServerStringReq *req = (xGLXQueryServerStringReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->name);

    return __glXQueryServerString(cl, pc);
}

int
__glXSwapClientInfo(__GLXclientState * cl, GLbyte * pc)
{
    xGLXClientInfoReq *req = (xGLXClientInfoReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->major);
    __GLX_SWAP_INT(&req->minor);
    __GLX_SWAP_INT(&req->numbytes);

    return __glXClientInfo(cl, pc);
}

int
__glXSwapQueryContextInfoEXT(__GLXclientState * cl, char *pc)
{
    xGLXQueryContextInfoEXTReq *req = (xGLXQueryContextInfoEXTReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->context);

    return __glXQueryContextInfoEXT(cl, (GLbyte *) pc);
}

/************************************************************************/

/*
** Swap replies.
*/

void
__glXSwapMakeCurrentReply(ClientPtr client, xGLXMakeCurrentReadSGIReply * reply)
{
    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->contextTag);
    __GLX_SWAP_INT(&reply->writeVid);
    __GLX_SWAP_INT(&reply->writeType);
    __GLX_SWAP_INT(&reply->readVid);
    __GLX_SWAP_INT(&reply->readType);
    WriteToClient(client, sz_xGLXMakeCurrentReadSGIReply, reply);
}

void
__glXSwapIsDirectReply(ClientPtr client, xGLXIsDirectReply * reply)
{
    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    WriteToClient(client, sz_xGLXIsDirectReply, reply);
}

void
__glXSwapQueryVersionReply(ClientPtr client, xGLXQueryVersionReply * reply)
{
    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->majorVersion);
    __GLX_SWAP_INT(&reply->minorVersion);
    WriteToClient(client, sz_xGLXQueryVersionReply, reply);
}

void
glxSwapQueryExtensionsStringReply(ClientPtr client,
                                  xGLXQueryExtensionsStringReply * reply,
                                  char *buf)
{
    int length = reply->length;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->n);
    WriteToClient(client, sz_xGLXQueryExtensionsStringReply, reply);
    __GLX_SWAP_INT_ARRAY((int *) buf, length);
    WriteToClient(client, length << 2, buf);
}

void
glxSwapQueryServerStringReply(ClientPtr client,
                              xGLXQueryServerStringReply * reply, char *buf)
{
    int length = reply->length;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->n);
    WriteToClient(client, sz_xGLXQueryServerStringReply, reply);
    /** no swap is needed for an array of chars **/
    /* __GLX_SWAP_INT_ARRAY((int *)buf, length); */
    WriteToClient(client, length << 2, buf);
}

void
__glXSwapQueryContextInfoEXTReply(ClientPtr client,
                                  xGLXQueryContextInfoEXTReply * reply,
                                  int *buf)
{
    int length = reply->length;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->n);
    WriteToClient(client, sz_xGLXQueryContextInfoEXTReply, reply);
    __GLX_SWAP_INT_ARRAY((int *) buf, length);
    WriteToClient(client, length << 2, buf);
}

void
__glXSwapQueryContextReply(ClientPtr client,
                           xGLXQueryContextReply * reply, int *buf)
{
    int length = reply->length;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->n);
    WriteToClient(client, sz_xGLXQueryContextReply, reply);
    __GLX_SWAP_INT_ARRAY((int *) buf, length);
    WriteToClient(client, length << 2, buf);
}

void
__glXSwapGetDrawableAttributesReply(ClientPtr client,
                                    xGLXGetDrawableAttributesReply * reply,
                                    int *buf)
{
    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->numAttribs);
    __GLX_SWAP_INT_ARRAY(buf, reply->length);
    WriteToClient(client, sz_xGLXGetDrawableAttributesReply, reply);
    WriteToClient(client, reply->length << 2, buf);
}

void
__glXSwapQueryMaxSwapBarriersSGIXReply(ClientPtr client,
                                       xGLXQueryMaxSwapBarriersSGIXReply *
                                       reply)
{
    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_SWAP_SHORT(&reply->sequenceNumber);
    __GLX_SWAP_INT(&reply->length);
    __GLX_SWAP_INT(&reply->max);
    WriteToClient(client, sz_xGLXQueryMaxSwapBarriersSGIXReply, reply);
}

/************************************************************************/

/*
** Render and Renderlarge are not in the GLX API.  They are used by the GLX
** client library to send batches of GL rendering commands.
*/

int
__glXSwapRender(__GLXclientState * cl, GLbyte * pc)
{
    xGLXRenderReq *req;
    int left;
    __GLXrenderHeader *hdr;
    ClientPtr client = cl->client;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    /*
     ** NOTE: much of this code also appears in the nonswapping version of this
     ** routine, __glXRender().  Any changes made here should also be
     ** duplicated there.
     */

    req = (xGLXRenderReq *) pc;
    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);

    pc += sz_xGLXRenderReq;
    left = (req->length << 2) - sz_xGLXRenderReq;
    while (left > 0) {
        void (*proc) (GLbyte *);
        CARD16 opcode;

        /*
         ** Verify that the header length and the overall length agree.
         ** Also, each command must be word aligned.
         */
        hdr = (__GLXrenderHeader *) pc;
        __GLX_SWAP_SHORT(&hdr->length);
        __GLX_SWAP_SHORT(&hdr->opcode);

        /*
         * call the command procedure to swap any arguments
         */
        opcode = hdr->opcode;
        if ((opcode >= __GLX_MIN_RENDER_OPCODE) &&
            (opcode <= __GLX_MAX_RENDER_OPCODE)) {
            proc = __glXSwapRenderTable[opcode];
#if __GLX_MAX_RENDER_OPCODE_EXT > __GLX_MIN_RENDER_OPCODE_EXT
        }
        else if ((opcode >= __GLX_MIN_RENDER_OPCODE_EXT) &&
                 (opcode <= __GLX_MAX_RENDER_OPCODE_EXT)) {
            int index = opcode - __GLX_MIN_RENDER_OPCODE_EXT;
            __GLXRenderSwapInfo *info = &__glXSwapRenderTable_EXT[index];

            if (info->swapfunc) {
                proc = info->swapfunc;
            }
            else {
                proc = NULL;
                if (info->elem_size == 4 && info->nelems > 0) {
                    __GLX_SWAP_INT_ARRAY((int *) (pc + __GLX_RENDER_HDR_SIZE),
                                         info->nelems);
                }
                else if (info->elem_size == 2 && info->nelems > 0) {
                    __GLX_SWAP_SHORT_ARRAY((short *) (pc +
                                                      __GLX_RENDER_HDR_SIZE),
                                           info->nelems);
                }
                else if (info->elem_size == 8 && info->nelems > 0) {
                    __GLX_SWAP_DOUBLE_ARRAY((double *) (pc +
                                                        __GLX_RENDER_HDR_SIZE),
                                            info->nelems);
                }
            }
#endif                          /* __GLX_MAX_RENDER_OPCODE_EXT > __GLX_MIN_RENDER_OPCODE_EXT */
        }
        else {
            client->errorValue = 0;
            return __glXBadRenderRequest;
        }

        if (proc != NULL)
            (*proc) (pc + __GLX_RENDER_HDR_SIZE);

        /*
         * proceed to the next command
         */
        pc += hdr->length;
        left -= hdr->length;
    }

    return __glXRender(cl, (GLbyte *) req);
}

/*
** Execute a large rendering request (one that spans multiple X requests).
*/
int
__glXSwapRenderLarge(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXRenderLargeReq *req;
    __GLXrenderLargeHeader *hdr;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    req = (xGLXRenderLargeReq *) pc;
    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->contextTag);
    __GLX_SWAP_INT(&req->dataBytes);
    __GLX_SWAP_SHORT(&req->requestNumber);
    __GLX_SWAP_SHORT(&req->requestTotal);

    pc += sz_xGLXRenderLargeReq;

    if (req->requestNumber == 1) {
        void (*proc) (GLbyte *) = NULL;
        __GLXRenderSwapInfo *info = NULL;
        CARD16 opcode;

        hdr = (__GLXrenderLargeHeader *) pc;
        __GLX_SWAP_INT(&hdr->length);
        __GLX_SWAP_INT(&hdr->opcode);

        /*
         * call the command procedure to swap any arguments
         * Note that we are assuming that all arguments that needs to be
         * swaped are on the first req only !
         */
        opcode = hdr->opcode;
        if ((opcode >= __GLX_MIN_RENDER_OPCODE) &&
            (opcode <= __GLX_MAX_RENDER_OPCODE)) {
            proc = __glXSwapRenderTable[opcode];
#if __GLX_MAX_RENDER_OPCODE_EXT > __GLX_MIN_RENDER_OPCODE_EXT
        }
        else if ((opcode >= __GLX_MIN_RENDER_OPCODE_EXT) &&
                 (opcode <= __GLX_MAX_RENDER_OPCODE_EXT)) {
            int index = opcode - __GLX_MIN_RENDER_OPCODE_EXT;

            info = &__glXSwapRenderTable_EXT[index];
            if (info->swapfunc) {
                proc = info->swapfunc;
            }
#endif                          /* __GLX_MAX_RENDER_OPCODE_EXT > __GLX_MIN_RENDER_OPCODE_EXT */
        }
        else {
            client->errorValue = 0;
            cl->largeCmdRequestsTotal = 0;
            return __glXBadLargeRequest;
        }

        /*
         ** Make enough space in the buffer, then copy the entire request.
         */
        if (cl->largeCmdBufSize < hdr->length) {
            if (!cl->largeCmdBuf) {
                cl->largeCmdBuf = (GLbyte *) malloc(hdr->length);
            }
            else {
                cl->largeCmdBuf =
                    (GLbyte *) realloc(cl->largeCmdBuf, hdr->length);
            }
            if (!cl->largeCmdBuf) {
                cl->largeCmdRequestsTotal = 0;
                return BadAlloc;
            }
            cl->largeCmdBufSize = hdr->length;
        }
        memcpy(cl->largeCmdBuf, pc, req->dataBytes);

        cl->largeCmdBytesSoFar = req->dataBytes;
        cl->largeCmdBytesTotal = hdr->length;
        cl->largeCmdRequestsSoFar = 1;
        cl->largeCmdRequestsTotal = req->requestTotal;
        cl->largeCmdRequestsSwapProc = proc;
        cl->largeCmdMaxReqDataSize = req->dataBytes;
        cl->largeCmdRequestsSwap_info = info;

        return Success;

    }
    else if (req->requestNumber < cl->largeCmdRequestsTotal) {
        /*
         * This is not the first nor last request - just copy the data
         */
        if (cl->largeCmdBytesSoFar + req->dataBytes > cl->largeCmdBytesTotal) {
            cl->largeCmdRequestsTotal = 0;
            return __glXBadLargeRequest;
        }

        memcpy(cl->largeCmdBuf + cl->largeCmdBytesSoFar, pc, req->dataBytes);

        cl->largeCmdBytesSoFar += req->dataBytes;

        if (req->dataBytes > cl->largeCmdMaxReqDataSize)
            cl->largeCmdMaxReqDataSize = req->dataBytes;

        return Success;
    }
    else if (req->requestNumber == cl->largeCmdRequestsTotal) {
        /*
         * this is the last request
         * copy the remainder bytes, call the procedure to swap any
         * needed data, and then call to transfer the command to all
         * back-end servers
         */
        if (cl->largeCmdBytesSoFar + req->dataBytes > cl->largeCmdBytesTotal) {
            cl->largeCmdRequestsTotal = 0;
            return __glXBadLargeRequest;
        }

        memcpy(cl->largeCmdBuf + cl->largeCmdBytesSoFar, pc, req->dataBytes);

        cl->largeCmdBytesSoFar += req->dataBytes;

        if (req->dataBytes > cl->largeCmdMaxReqDataSize)
            cl->largeCmdMaxReqDataSize = req->dataBytes;

        if (cl->largeCmdRequestsSwapProc != NULL) {
            (*cl->largeCmdRequestsSwapProc) (cl->largeCmdBuf +
                                             __GLX_RENDER_LARGE_HDR_SIZE);
        }
        else if (cl->largeCmdRequestsSwap_info &&
                 cl->largeCmdRequestsSwap_info->nelems > 0) {
            if (cl->largeCmdRequestsSwap_info->elem_size == 4) {
                __GLX_SWAP_INT_ARRAY((int *) (pc + __GLX_RENDER_LARGE_HDR_SIZE),
                                     cl->largeCmdRequestsSwap_info->nelems);
            }
            else if (cl->largeCmdRequestsSwap_info->elem_size == 2) {
                __GLX_SWAP_SHORT_ARRAY((short *) (pc +
                                                  __GLX_RENDER_LARGE_HDR_SIZE),
                                       cl->largeCmdRequestsSwap_info->nelems);
            }
            else if (cl->largeCmdRequestsSwap_info->elem_size == 8) {
                __GLX_SWAP_DOUBLE_ARRAY((double *) (pc +
                                                    __GLX_RENDER_LARGE_HDR_SIZE),
                                        cl->largeCmdRequestsSwap_info->nelems);
            }
        }

        cl->largeCmdRequestsTotal = 0;
        return (__glXSendLargeCommand(cl, req->contextTag));

    }
    else {
        cl->largeCmdRequestsTotal = 0;
        return __glXBadLargeRequest;
    }

}

/************************************************************************/

/*
** No support is provided for the vendor-private requests other than
** allocating these entry points in the dispatch table.
*/

int
__glXSwapVendorPrivate(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateReq *req;
    CARD32 vendorCode;

    __GLX_DECLARE_SWAP_VARIABLES;

    req = (xGLXVendorPrivateReq *) pc;
    vendorCode = req->vendorCode;
    __GLX_SWAP_INT(&vendorCode);

    switch (vendorCode) {

    case X_GLvop_DeleteTexturesEXT:
        return __glXVForwardSingleReqSwap(cl, pc);
        break;

    case X_GLXvop_SwapIntervalSGI:
        if (glxIsExtensionSupported("SGI_swap_control")) {
            return __glXVForwardSingleReqSwap(cl, pc);
        }
        else {
            return Success;
        }
        break;

#if 0                           /* glx 1.3 */
    case X_GLXvop_CreateGLXVideoSourceSGIX:
        break;
    case X_GLXvop_DestroyGLXVideoSourceSGIX:
        break;
    case X_GLXvop_CreateGLXPixmapWithConfigSGIX:
        break;
    case X_GLXvop_DestroyGLXPbufferSGIX:
        break;
    case X_GLXvop_ChangeDrawableAttributesSGIX:
        break;
#endif

    case X_GLXvop_JoinSwapGroupSGIX:
        return __glXSwapJoinSwapGroupSGIX(cl, pc);
        break;

    case X_GLXvop_BindSwapBarrierSGIX:
        return __glXSwapBindSwapBarrierSGIX(cl, pc);
        break;

    case X_GLXvop_CreateContextWithConfigSGIX:
        return __glXSwapCreateContextWithConfigSGIX(cl, pc);
        break;

    default:
        /*
         ** unsupported private request
         */
        cl->client->errorValue = req->vendorCode;
        return __glXUnsupportedPrivateRequest;
    }

}

int
__glXSwapVendorPrivateWithReply(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateWithReplyReq *req;
    CARD32 vendorCode;

    __GLX_DECLARE_SWAP_VARIABLES;

    req = (xGLXVendorPrivateWithReplyReq *) pc;
    vendorCode = req->vendorCode;
    __GLX_SWAP_INT(&vendorCode);

    switch (vendorCode) {

    case X_GLvop_GetConvolutionFilterEXT:
    case X_GLvop_GetSeparableFilterEXT:
    case X_GLvop_GetHistogramEXT:
    case X_GLvop_GetMinmaxEXT:
        return (__glXNoSuchSingleOpcode(cl, pc));
        break;

    case X_GLvop_GetConvolutionParameterfvEXT:
    case X_GLvop_GetConvolutionParameterivEXT:
    case X_GLvop_GetHistogramParameterivEXT:
    case X_GLvop_GetMinmaxParameterfvEXT:
    case X_GLvop_GetMinmaxParameterivEXT:
    case X_GLvop_GenTexturesEXT:
        return (__glXVForwardAllWithReplySwapiv(cl, pc));
        break;

    case X_GLvop_AreTexturesResidentEXT:
    case X_GLvop_IsTextureEXT:
        return (__glXVForwardPipe0WithReplySwap(cl, pc));
        break;

#if 0                           /* glx1.3 */
    case X_GLvop_GetDetailTexFuncSGIS:
    case X_GLvop_GetSharpenTexFuncSGIS:
    case X_GLvop_GetColorTableSGI:
    case X_GLvop_GetColorTableParameterfvSGI:
    case X_GLvop_GetColorTableParameterivSGI:
    case X_GLvop_GetTexFilterFuncSGIS:
    case X_GLvop_GetInstrumentsSGIX:
    case X_GLvop_InstrumentsBufferSGIX:
    case X_GLvop_PollInstrumentsSGIX:
    case X_GLvop_FlushRasterSGIX:
    case X_GLXvop_CreateGLXPbufferSGIX:
    case X_GLXvop_GetDrawableAttributesSGIX:
    case X_GLXvop_QueryHyperpipeNetworkSGIX:
    case X_GLXvop_QueryHyperpipeConfigSGIX:
    case X_GLXvop_HyperpipeConfigSGIX:
    case X_GLXvop_DestroyHyperpipeConfigSGIX:
#endif
    case X_GLXvop_QueryMaxSwapBarriersSGIX:
        return (__glXSwapQueryMaxSwapBarriersSGIX(cl, pc));
        break;

    case X_GLXvop_GetFBConfigsSGIX:
        return (__glXSwapGetFBConfigsSGIX(cl, pc));
        break;

    case X_GLXvop_MakeCurrentReadSGI:
        return (__glXSwapMakeCurrentReadSGI(cl, pc));
        break;

    case X_GLXvop_QueryContextInfoEXT:
        return (__glXSwapQueryContextInfoEXT(cl, (char *) pc));
        break;

    default:
        /*
         ** unsupported private request
         */
        cl->client->errorValue = req->vendorCode;
        return __glXUnsupportedPrivateRequest;
    }

}

int
__glXSwapGetFBConfigs(__GLXclientState * cl, GLbyte * pc)
{
    xGLXGetFBConfigsReq *req = (xGLXGetFBConfigsReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->screen);

    return __glXGetFBConfigs(cl, pc);
}

int
__glXSwapGetFBConfigsSGIX(__GLXclientState * cl, GLbyte * pc)
{
    xGLXGetFBConfigsSGIXReq *req = (xGLXGetFBConfigsSGIXReq *) pc;
    xGLXGetFBConfigsReq new_req;

    new_req.reqType = req->reqType;
    new_req.glxCode = req->glxCode;
    new_req.length = req->length;
    new_req.screen = req->screen;

    return (__glXSwapGetFBConfigs(cl, (GLbyte *) &new_req));
}

int
__glXSwapCreateWindow(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreateWindowReq *req = (xGLXCreateWindowReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->fbconfig);
    __GLX_SWAP_INT(&req->window);
    __GLX_SWAP_INT(&req->glxwindow);
    __GLX_SWAP_INT(&req->numAttribs);

    return (__glXCreateWindow(cl, (GLbyte *) pc));
}

int
__glXSwapDestroyWindow(__GLXclientState * cl, GLbyte * pc)
{
    xGLXDestroyWindowReq *req = (xGLXDestroyWindowReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->glxwindow);

    return (__glXDestroyWindow(cl, (GLbyte *) pc));
}

int
__glXSwapQueryContext(__GLXclientState * cl, GLbyte * pc)
{
    xGLXQueryContextReq *req = (xGLXQueryContextReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->context);

    return (__glXQueryContext(cl, (GLbyte *) pc));

}

int
__glXSwapCreatePbuffer(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreatePbufferReq *req = (xGLXCreatePbufferReq *) pc;
    int nattr = req->numAttribs;

    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->screen);
    __GLX_SWAP_INT(&req->fbconfig);
    __GLX_SWAP_INT(&req->pbuffer);
    __GLX_SWAP_INT(&req->numAttribs);
    __GLX_SWAP_INT_ARRAY((int *) (req + 1), nattr * 2);

    return (__glXCreatePbuffer(cl, pc));
}

int
__glXSwapDestroyPbuffer(__GLXclientState * cl, GLbyte * pc)
{
    xGLXDestroyPbufferReq *req = (xGLXDestroyPbufferReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->pbuffer);

    return (__glXDestroyPbuffer(cl, (GLbyte *) pc));
}

int
__glXSwapGetDrawableAttributes(__GLXclientState * cl, GLbyte * pc)
{
    xGLXGetDrawableAttributesReq *req = (xGLXGetDrawableAttributesReq *) pc;

    __GLX_DECLARE_SWAP_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->drawable);

    return (__glXGetDrawableAttributes(cl, pc));
}

int
__glXSwapChangeDrawableAttributes(__GLXclientState * cl, GLbyte * pc)
{
    xGLXChangeDrawableAttributesReq *req =
        (xGLXChangeDrawableAttributesReq *) pc;
    __GLX_DECLARE_SWAP_VARIABLES;
    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;

    __GLX_SWAP_SHORT(&req->length);
    __GLX_SWAP_INT(&req->drawable);
    __GLX_SWAP_INT(&req->numAttribs);
    __GLX_SWAP_INT_ARRAY((int *) (req + 1), req->numAttribs * 2);

    return (__glXChangeDrawableAttributes(cl, pc));
}
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a41 2
extern int glxIsExtensionSupported(char *ext);

d441 1
a441 1
    xGLXQueryExtensionsStringReq *req = NULL;
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d296 8
a303 6
    reply.numVisuals = pGlxScreen->numGLXVisuals;
    reply.numProps = __GLX_TOTAL_CONFIG;
    reply.length = (pGlxScreen->numGLXVisuals * __GLX_SIZE_CARD32 *
                    __GLX_TOTAL_CONFIG) >> 2;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
d309 1
a309 1
    WriteToClient(client, sz_xGLXGetVisualConfigsReply, (char *) &reply);
d358 1
a358 2
        WriteToClient(client, __GLX_SIZE_CARD32 * __GLX_TOTAL_CONFIG,
                      (char *) buf);
d512 1
a512 1
    WriteToClient(client, sz_xGLXMakeCurrentReadSGIReply, (char *) reply);
d521 1
a521 1
    WriteToClient(client, sz_xGLXIsDirectReply, (char *) reply);
d532 1
a532 1
    WriteToClient(client, sz_xGLXQueryVersionReply, (char *) reply);
d547 1
a547 1
    WriteToClient(client, sz_xGLXQueryExtensionsStringReply, (char *) reply);
d562 1
a562 1
    WriteToClient(client, sz_xGLXQueryServerStringReply, (char *) reply);
d580 1
a580 1
    WriteToClient(client, sz_xGLXQueryContextInfoEXTReply, (char *) reply);
d582 1
a582 1
    WriteToClient(client, length << 2, (char *) buf);
d596 1
a596 1
    WriteToClient(client, sz_xGLXQueryContextReply, (char *) reply);
d598 1
a598 1
    WriteToClient(client, length << 2, (char *) buf);
d612 2
a613 2
    WriteToClient(client, sz_xGLXGetDrawableAttributesReply, (char *) reply);
    WriteToClient(client, reply->length << 2, (char *) buf);
d625 1
a625 1
    WriteToClient(client, sz_xGLXQueryMaxSwapBarriersSGIXReply, (char *) reply);
d1054 1
a1054 1
    return (__glXSwapGetFBConfigs(cl, (GLbyte *) & new_req));
@


1.7
log
@Bugfix Update to xserver 1.11.3
@
text
@d42 1
a42 1
extern int glxIsExtensionSupported( char *ext );
d44 1
a44 1
int __glXSwapGetFBConfigsSGIX(__GLXclientState *cl, GLbyte *pc);
d55 2
a56 1
int __glXSwapCreateContext(__GLXclientState *cl, GLbyte *pc)
d59 1
d71 2
a72 1
int __glXSwapCreateNewContext(__GLXclientState *cl, GLbyte *pc)
d75 1
d87 2
a88 1
int __glXSwapCreateContextWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)
d90 2
a91 1
    xGLXCreateContextWithConfigSGIXReq *req = (xGLXCreateContextWithConfigSGIXReq *) pc;
d103 2
a104 1
int __glXSwapQueryMaxSwapBarriersSGIX(__GLXclientState *cl, GLbyte *pc)
d107 1
a107 1
	(xGLXQueryMaxSwapBarriersSGIXReq *)pc;
d116 2
a117 1
int __glXSwapBindSwapBarrierSGIX(__GLXclientState *cl, GLbyte *pc)
d119 2
a120 1
    xGLXBindSwapBarrierSGIXReq *req = (xGLXBindSwapBarrierSGIXReq *)pc;
d130 2
a131 1
int __glXSwapJoinSwapGroupSGIX(__GLXclientState *cl, GLbyte *pc)
d133 2
a134 1
    xGLXJoinSwapGroupSGIXReq *req = (xGLXJoinSwapGroupSGIXReq *)pc;
d144 2
a145 1
int __glXSwapDestroyContext(__GLXclientState *cl, GLbyte *pc)
d148 1
d157 2
a158 1
int __glXSwapMakeCurrent(__GLXclientState *cl, GLbyte *pc)
d161 1
d172 2
a173 1
int __glXSwapMakeContextCurrent(__GLXclientState *cl, GLbyte *pc)
d176 1
d188 2
a189 1
int __glXSwapMakeCurrentReadSGI(__GLXclientState *cl, GLbyte *pc)
d192 1
d204 2
a205 1
int __glXSwapIsDirect(__GLXclientState *cl, GLbyte *pc)
d208 1
d217 2
a218 1
int __glXSwapQueryVersion(__GLXclientState *cl, GLbyte *pc)
d221 1
d231 2
a232 1
int __glXSwapWaitGL(__GLXclientState *cl, GLbyte *pc)
d235 1
d244 2
a245 1
int __glXSwapWaitX(__GLXclientState *cl, GLbyte *pc)
d248 1
d257 2
a258 1
int __glXSwapCopyContext(__GLXclientState *cl, GLbyte *pc)
d261 1
d272 2
a273 1
int __glXSwapGetVisualConfigs(__GLXclientState *cl, GLbyte *pc)
d275 1
a275 1
   ClientPtr client = cl->client;
d283 1
d290 3
a292 3
	/* The client library must send a valid screen number. */
	client->errorValue = screen;
	return BadValue;
d299 1
a299 1
		    __GLX_TOTAL_CONFIG) >> 2;
d302 1
a302 1
    
d307 1
a307 1
    WriteToClient(client, sz_xGLXGetVisualConfigsReply, (char *)&reply);
d309 28
a336 28
    for (i=0; i < pGlxScreen->numVisuals; i++) {
	pGlxVisual = &pGlxScreen->pGlxVisual[i];
	if (!pGlxScreen->isGLXvis[i] || pGlxVisual->vid == 0) {
	    /* not a usable visual */
	    continue;
	}
	p = 0;
	buf[p++] = pGlxVisual->vid;
	buf[p++] = pGlxVisual->class;
	buf[p++] = pGlxVisual->rgba;

	buf[p++] = pGlxVisual->redSize;
	buf[p++] = pGlxVisual->greenSize;
	buf[p++] = pGlxVisual->blueSize;
	buf[p++] = pGlxVisual->alphaSize;
	buf[p++] = pGlxVisual->accumRedSize;
	buf[p++] = pGlxVisual->accumGreenSize;
	buf[p++] = pGlxVisual->accumBlueSize;
	buf[p++] = pGlxVisual->accumAlphaSize;

	buf[p++] = pGlxVisual->doubleBuffer;
	buf[p++] = pGlxVisual->stereo;

	buf[p++] = pGlxVisual->bufferSize;
	buf[p++] = pGlxVisual->depthSize;
	buf[p++] = pGlxVisual->stencilSize;
	buf[p++] = pGlxVisual->auxBuffers;
	buf[p++] = pGlxVisual->level;
d338 2
a339 2
        ** Add token/value pairs for extensions.
        */
d355 3
a357 3
	__GLX_SWAP_INT_ARRAY(buf, __GLX_TOTAL_CONFIG);
	WriteToClient(client, __GLX_SIZE_CARD32 * __GLX_TOTAL_CONFIG, 
			(char *)buf);
d362 2
a363 1
int __glXSwapCreateGLXPixmap(__GLXclientState *cl, GLbyte *pc)
d366 1
d378 2
a379 1
int __glXSwapCreatePixmap(__GLXclientState *cl, GLbyte *pc)
d382 1
d395 2
a396 1
int __glXSwapDestroyGLXPixmap(__GLXclientState *cl, GLbyte *pc)
d399 1
d408 2
a409 1
int __glXSwapSwapBuffers(__GLXclientState *cl, GLbyte *pc)
d412 1
d422 2
a423 1
int __glXSwapUseXFont(__GLXclientState *cl, GLbyte *pc)
d426 1
d439 2
a440 2

int __glXSwapQueryExtensionsString(__GLXclientState *cl, GLbyte *pc)
d443 1
d452 2
a453 1
int __glXSwapQueryServerString(__GLXclientState *cl, GLbyte *pc)
d455 2
a456 1
    xGLXQueryServerStringReq *req = (xGLXQueryServerStringReq *)pc;
d466 2
a467 1
int __glXSwapClientInfo(__GLXclientState *cl, GLbyte *pc)
d469 2
a470 1
    xGLXClientInfoReq *req = (xGLXClientInfoReq *)pc;
d481 2
a482 1
int __glXSwapQueryContextInfoEXT(__GLXclientState *cl, char *pc)
d485 1
d491 1
a491 1
    return __glXQueryContextInfoEXT(cl, (GLbyte *)pc);
d500 2
a501 1
void __glXSwapMakeCurrentReply(ClientPtr client,  xGLXMakeCurrentReadSGIReply *reply)
d511 1
a511 1
    WriteToClient(client, sz_xGLXMakeCurrentReadSGIReply, (char *)reply);
d514 2
a515 1
void __glXSwapIsDirectReply(ClientPtr client, xGLXIsDirectReply *reply)
d520 1
a520 1
    WriteToClient(client, sz_xGLXIsDirectReply, (char *)reply);
d523 2
a524 1
void __glXSwapQueryVersionReply(ClientPtr client, xGLXQueryVersionReply *reply)
d531 1
a531 1
    WriteToClient(client, sz_xGLXQueryVersionReply, (char *)reply);
d534 4
a537 2
void glxSwapQueryExtensionsStringReply(ClientPtr client,
				       xGLXQueryExtensionsStringReply *reply, char *buf)
d540 1
d546 2
a547 2
    WriteToClient(client, sz_xGLXQueryExtensionsStringReply, (char *)reply);
    __GLX_SWAP_INT_ARRAY((int *)buf, length);
d551 3
a553 2
void glxSwapQueryServerStringReply(ClientPtr client,
				   xGLXQueryServerStringReply *reply, char *buf)
d556 1
d561 1
a561 1
    WriteToClient(client, sz_xGLXQueryServerStringReply, (char *)reply);
d567 4
a570 1
void __glXSwapQueryContextInfoEXTReply(ClientPtr client, xGLXQueryContextInfoEXTReply *reply, int *buf)
d573 1
d579 3
a581 3
    WriteToClient(client, sz_xGLXQueryContextInfoEXTReply, (char *)reply);
    __GLX_SWAP_INT_ARRAY((int *)buf, length);
    WriteToClient(client, length << 2, (char *)buf);
d584 3
a586 3

void __glXSwapQueryContextReply(ClientPtr client,
                                xGLXQueryContextReply *reply, int *buf)
d589 1
d595 3
a597 3
    WriteToClient(client, sz_xGLXQueryContextReply, (char *)reply);
    __GLX_SWAP_INT_ARRAY((int *)buf, length);
    WriteToClient(client, length << 2, (char *)buf);
d600 4
a603 2
void __glXSwapGetDrawableAttributesReply(ClientPtr client,
                                 xGLXGetDrawableAttributesReply *reply, int *buf) 
d610 3
a612 3
    __GLX_SWAP_INT_ARRAY( buf, reply->length );
    WriteToClient(client, sz_xGLXGetDrawableAttributesReply, (char *)reply);
    WriteToClient(client, reply->length << 2, (char *)buf);
d615 4
a618 1
void __glXSwapQueryMaxSwapBarriersSGIXReply(ClientPtr client, xGLXQueryMaxSwapBarriersSGIXReply *reply)
d624 1
a624 1
    WriteToClient(client, sz_xGLXQueryMaxSwapBarriersSGIXReply, (char *)reply);
d634 2
a635 1
int __glXSwapRender(__GLXclientState *cl, GLbyte *pc)
d641 1
d646 5
a650 5
    ** NOTE: much of this code also appears in the nonswapping version of this
    ** routine, __glXRender().  Any changes made here should also be
    ** duplicated there.
    */
    
d658 2
a659 2
	void (* proc)(GLbyte *);
	CARD16 opcode;
d661 7
a667 7
	/*
	** Verify that the header length and the overall length agree.
	** Also, each command must be word aligned.
	*/
	hdr = (__GLXrenderHeader *) pc;
	__GLX_SWAP_SHORT(&hdr->length);
	__GLX_SWAP_SHORT(&hdr->opcode);
d669 1
a669 1
	/*
d671 5
a675 5
	 */
	opcode = hdr->opcode;
	if ( (opcode >= __GLX_MIN_RENDER_OPCODE) && 
	     (opcode <= __GLX_MAX_RENDER_OPCODE) ) {
	    proc = __glXSwapRenderTable[opcode];
d677 41
a717 36
	} else if ( (opcode >= __GLX_MIN_RENDER_OPCODE_EXT) && 
	     (opcode <= __GLX_MAX_RENDER_OPCODE_EXT) ) {
	    int index = opcode - __GLX_MIN_RENDER_OPCODE_EXT;
	    __GLXRenderSwapInfo *info = &__glXSwapRenderTable_EXT[index];
	    if (info->swapfunc) {
	       proc = info->swapfunc;
	    }
	    else {
	       proc = NULL;
	       if (info->elem_size == 4 && info->nelems > 0) {
		  __GLX_SWAP_INT_ARRAY( (int *)(pc + __GLX_RENDER_HDR_SIZE), 
			                info->nelems );
	       }
	       else if (info->elem_size == 2 && info->nelems > 0) {
		  __GLX_SWAP_SHORT_ARRAY( (short *)(pc + __GLX_RENDER_HDR_SIZE), 
			                info->nelems );
	       }
	       else if (info->elem_size == 8 && info->nelems > 0) {
		  __GLX_SWAP_DOUBLE_ARRAY( (double *)(pc + __GLX_RENDER_HDR_SIZE), 
			                info->nelems );
	       }
	    }
#endif /* __GLX_MAX_RENDER_OPCODE_EXT > __GLX_MIN_RENDER_OPCODE_EXT */
	} else {
	    client->errorValue = 0;
	    return __glXBadRenderRequest;
	}

	if (proc != NULL) 
	   (*proc)(pc + __GLX_RENDER_HDR_SIZE);

	/*
	 * proceed to the next command
	 */ 
	pc += hdr->length;
	left -= hdr->length;
d720 1
a720 1
    return __glXRender( cl, (GLbyte *)req );
d726 2
a727 1
int __glXSwapRenderLarge(__GLXclientState *cl, GLbyte *pc)
d729 1
a729 1
   ClientPtr client = cl->client;
d732 1
d744 1
a744 1
   
d746 7
a752 7
	void (* proc)(GLbyte *) = NULL;
	__GLXRenderSwapInfo *info = NULL;
	CARD16 opcode;

	hdr = (__GLXrenderLargeHeader *) pc;
	__GLX_SWAP_INT(&hdr->length);
	__GLX_SWAP_INT(&hdr->opcode);
d754 1
a754 1
	/*
d756 7
a762 7
	 * Note that we are assuming that all arguments that needs to be
	 * swaped are on the first req only !
	 */
	opcode = hdr->opcode;
	if ( (opcode >= __GLX_MIN_RENDER_OPCODE) && 
	     (opcode <= __GLX_MAX_RENDER_OPCODE) ) {
	    proc = __glXSwapRenderTable[opcode];
d764 16
a779 38
	} else if ( (opcode >= __GLX_MIN_RENDER_OPCODE_EXT) && 
	     (opcode <= __GLX_MAX_RENDER_OPCODE_EXT) ) {
	    int index = opcode - __GLX_MIN_RENDER_OPCODE_EXT;
	    info = &__glXSwapRenderTable_EXT[index];
	    if (info->swapfunc) {
	       proc = info->swapfunc;
	    }
#endif /* __GLX_MAX_RENDER_OPCODE_EXT > __GLX_MIN_RENDER_OPCODE_EXT */
	} else {
	    client->errorValue = 0;
	    cl->largeCmdRequestsTotal = 0;
	    return __glXBadLargeRequest;
	}

	/*
	** Make enough space in the buffer, then copy the entire request.
	*/
	if (cl->largeCmdBufSize < hdr->length) {
	    if (!cl->largeCmdBuf) {
		cl->largeCmdBuf = (GLbyte *) malloc(hdr->length);
	    } else {
		cl->largeCmdBuf = (GLbyte *) realloc(cl->largeCmdBuf, hdr->length);
	    }
	    if (!cl->largeCmdBuf) {
	       cl->largeCmdRequestsTotal = 0;
		return BadAlloc;
	    }
	    cl->largeCmdBufSize = hdr->length;
	}
	memcpy(cl->largeCmdBuf, pc, req->dataBytes);

	cl->largeCmdBytesSoFar = req->dataBytes;
	cl->largeCmdBytesTotal = hdr->length;
	cl->largeCmdRequestsSoFar = 1;
	cl->largeCmdRequestsTotal = req->requestTotal;
	cl->largeCmdRequestsSwapProc = proc;
	cl->largeCmdMaxReqDataSize = req->dataBytes;
	cl->largeCmdRequestsSwap_info = info;
d781 28
a808 2
	return Success;
	
d812 7
a818 10
       /*
        * This is not the first nor last request - just copy the data
	*/
       if (  cl->largeCmdBytesSoFar + req->dataBytes > cl->largeCmdBytesTotal) {
	    cl->largeCmdRequestsTotal = 0;
	    return __glXBadLargeRequest;
       }

       memcpy(cl->largeCmdBuf + cl->largeCmdBytesSoFar, 
	           pc, req->dataBytes);
d820 1
a820 1
       cl->largeCmdBytesSoFar += req->dataBytes;
d822 1
a822 2
       if (req->dataBytes > cl->largeCmdMaxReqDataSize)
	  cl->largeCmdMaxReqDataSize = req->dataBytes;
d824 4
a827 1
	return Success;
d830 39
a868 37
       /*
        * this is the last request
        * copy the remainder bytes, call the procedure to swap any
	* needed data, and then call to transfer the command to all
	* back-end servers
	*/
       if (  cl->largeCmdBytesSoFar + req->dataBytes > cl->largeCmdBytesTotal) {
	    cl->largeCmdRequestsTotal = 0;
	    return __glXBadLargeRequest;
       }

       memcpy(cl->largeCmdBuf + cl->largeCmdBytesSoFar, 
	           pc, req->dataBytes);

       cl->largeCmdBytesSoFar += req->dataBytes;

       if (req->dataBytes > cl->largeCmdMaxReqDataSize)
	  cl->largeCmdMaxReqDataSize = req->dataBytes;

	if (cl->largeCmdRequestsSwapProc != NULL) {
	   (*cl->largeCmdRequestsSwapProc)(cl->largeCmdBuf + __GLX_RENDER_LARGE_HDR_SIZE);
	}
	else if (cl->largeCmdRequestsSwap_info &&
	         cl->largeCmdRequestsSwap_info->nelems > 0) {
    	   if (cl->largeCmdRequestsSwap_info->elem_size == 4) {
	      __GLX_SWAP_INT_ARRAY( (int *)(pc + __GLX_RENDER_LARGE_HDR_SIZE), 
		       cl->largeCmdRequestsSwap_info->nelems );
	   }
	   else if (cl->largeCmdRequestsSwap_info->elem_size == 2) {
	      __GLX_SWAP_SHORT_ARRAY( (short *)(pc + __GLX_RENDER_LARGE_HDR_SIZE), 
		       cl->largeCmdRequestsSwap_info->nelems );
	   }
	   else if (cl->largeCmdRequestsSwap_info->elem_size == 8) {
	      __GLX_SWAP_DOUBLE_ARRAY( (double *)(pc + __GLX_RENDER_LARGE_HDR_SIZE), 
		       cl->largeCmdRequestsSwap_info->nelems );
	   }
	}
d870 2
a871 2
	cl->largeCmdRequestsTotal = 0;
        return( __glXSendLargeCommand(cl, req->contextTag) );
d875 2
a876 2
       cl->largeCmdRequestsTotal = 0;
       return __glXBadLargeRequest;
d888 2
a889 1
int __glXSwapVendorPrivate(__GLXclientState *cl, GLbyte *pc)
d900 1
d902 25
a926 1
    switch( vendorCode ) {
d928 11
a938 25
       case X_GLvop_DeleteTexturesEXT:
	  return __glXVForwardSingleReqSwap( cl, pc );
	  break;

       case X_GLXvop_SwapIntervalSGI:
	  if (glxIsExtensionSupported("SGI_swap_control")) {
	     return __glXVForwardSingleReqSwap( cl, pc );
	  }
	  else {
	     return Success;
	  }
	  break;

#if 0 /* glx 1.3 */
       case X_GLXvop_CreateGLXVideoSourceSGIX:
	  break;
       case X_GLXvop_DestroyGLXVideoSourceSGIX:
	  break;
       case X_GLXvop_CreateGLXPixmapWithConfigSGIX:
	  break;
       case X_GLXvop_DestroyGLXPbufferSGIX:
	  break;
       case X_GLXvop_ChangeDrawableAttributesSGIX:
	  break;
#endif
d940 6
a945 18
       case X_GLXvop_JoinSwapGroupSGIX:
	  return __glXSwapJoinSwapGroupSGIX( cl, pc );
	  break;

       case X_GLXvop_BindSwapBarrierSGIX:
	  return __glXSwapBindSwapBarrierSGIX( cl, pc );
	  break;

       case X_GLXvop_CreateContextWithConfigSGIX:
	  return __glXSwapCreateContextWithConfigSGIX( cl, pc );
	  break;

       default:
	  /*
	   ** unsupported private request
	   */
	  cl->client->errorValue = req->vendorCode;
	  return __glXUnsupportedPrivateRequest;
d950 2
a951 1
int __glXSwapVendorPrivateWithReply(__GLXclientState *cl, GLbyte *pc)
d962 1
a962 1
    switch( vendorCode ) {
d964 38
a1001 38
       case X_GLvop_GetConvolutionFilterEXT:
       case X_GLvop_GetSeparableFilterEXT:
       case X_GLvop_GetHistogramEXT:
       case X_GLvop_GetMinmaxEXT:
	  return( __glXNoSuchSingleOpcode(cl, pc) );
	  break;

       case X_GLvop_GetConvolutionParameterfvEXT:
       case X_GLvop_GetConvolutionParameterivEXT:
       case X_GLvop_GetHistogramParameterivEXT:
       case X_GLvop_GetMinmaxParameterfvEXT:
       case X_GLvop_GetMinmaxParameterivEXT:
       case X_GLvop_GenTexturesEXT:
	  return( __glXVForwardAllWithReplySwapiv(cl, pc) );
	  break;

       case X_GLvop_AreTexturesResidentEXT:
       case X_GLvop_IsTextureEXT:
	  return( __glXVForwardPipe0WithReplySwap(cl, pc) );
	  break;

#if 0 /* glx1.3 */
       case X_GLvop_GetDetailTexFuncSGIS:
       case X_GLvop_GetSharpenTexFuncSGIS:
       case X_GLvop_GetColorTableSGI:
       case X_GLvop_GetColorTableParameterfvSGI:
       case X_GLvop_GetColorTableParameterivSGI:
       case X_GLvop_GetTexFilterFuncSGIS:
       case X_GLvop_GetInstrumentsSGIX:
       case X_GLvop_InstrumentsBufferSGIX:
       case X_GLvop_PollInstrumentsSGIX:
       case X_GLvop_FlushRasterSGIX:
       case X_GLXvop_CreateGLXPbufferSGIX:
       case X_GLXvop_GetDrawableAttributesSGIX:
       case X_GLXvop_QueryHyperpipeNetworkSGIX:
       case X_GLXvop_QueryHyperpipeConfigSGIX:
       case X_GLXvop_HyperpipeConfigSGIX:
       case X_GLXvop_DestroyHyperpipeConfigSGIX:
d1003 22
a1024 22
       case X_GLXvop_QueryMaxSwapBarriersSGIX:
	  return( __glXSwapQueryMaxSwapBarriersSGIX(cl, pc) );
	  break;

       case X_GLXvop_GetFBConfigsSGIX:
	  return( __glXSwapGetFBConfigsSGIX(cl, pc) );
	  break;

       case X_GLXvop_MakeCurrentReadSGI:
	  return( __glXSwapMakeCurrentReadSGI(cl, pc) );
	  break;

       case X_GLXvop_QueryContextInfoEXT:
	  return( __glXSwapQueryContextInfoEXT(cl,(char *)pc) );
	  break;

       default:
	  /*
	   ** unsupported private request
	   */
	  cl->client->errorValue = req->vendorCode;
	  return __glXUnsupportedPrivateRequest;
d1029 2
a1030 1
int __glXSwapGetFBConfigs(__GLXclientState *cl, GLbyte *pc)
d1033 1
d1042 2
a1043 1
int __glXSwapGetFBConfigsSGIX(__GLXclientState *cl, GLbyte *pc)
d1045 2
a1046 2
   xGLXGetFBConfigsSGIXReq *req = (xGLXGetFBConfigsSGIXReq *)pc;
   xGLXGetFBConfigsReq new_req;
d1048 4
a1051 4
   new_req.reqType = req->reqType;
   new_req.glxCode = req->glxCode;
   new_req.length = req->length;
   new_req.screen = req->screen;
d1053 1
a1053 1
   return( __glXSwapGetFBConfigs( cl, (GLbyte *)&new_req ) );
d1056 2
a1057 1
int __glXSwapCreateWindow(__GLXclientState *cl, GLbyte *pc)
d1060 1
d1070 1
a1070 1
    return( __glXCreateWindow( cl, (GLbyte *)pc ) );
d1073 2
a1074 1
int __glXSwapDestroyWindow(__GLXclientState *cl, GLbyte *pc)
d1077 1
d1083 1
a1083 1
    return( __glXDestroyWindow( cl, (GLbyte *)pc ) );
d1086 2
a1087 1
int __glXSwapQueryContext(__GLXclientState *cl, GLbyte *pc)
d1089 1
a1089 1
    xGLXQueryContextReq *req = (xGLXQueryContextReq *)pc;
d1096 2
a1097 2
    return( __glXQueryContext(cl, (GLbyte *)pc) );
 
d1100 2
a1101 1
int __glXSwapCreatePbuffer(__GLXclientState *cl, GLbyte *pc)
d1103 1
a1103 1
    xGLXCreatePbufferReq *req = (xGLXCreatePbufferReq *)pc;
d1105 1
d1114 1
a1114 1
    __GLX_SWAP_INT_ARRAY( (int *)(req+1), nattr*2 );
d1116 1
a1116 1
    return( __glXCreatePbuffer( cl, pc ) );
d1119 2
a1120 1
int __glXSwapDestroyPbuffer(__GLXclientState *cl, GLbyte *pc)
d1123 1
d1129 1
a1129 1
    return( __glXDestroyPbuffer( cl, (GLbyte *)pc ) );
d1132 2
a1133 1
int __glXSwapGetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
d1135 2
a1136 1
   xGLXGetDrawableAttributesReq *req = (xGLXGetDrawableAttributesReq *)pc;
d1142 1
a1142 1
    return( __glXGetDrawableAttributes(cl, pc) );
d1145 2
a1146 1
int __glXSwapChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
d1148 2
a1149 1
   xGLXChangeDrawableAttributesReq *req = (xGLXChangeDrawableAttributesReq *)pc;
d1156 1
a1156 1
    __GLX_SWAP_INT_ARRAY( (int *)(req+1), req->numAttribs * 2 );
d1158 1
a1158 1
    return( __glXChangeDrawableAttributes(cl, pc) );
@


1.6
log
@Update to xserver 1.11.2
@
text
@d38 1
d43 2
@


1.5
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d705 1
a705 1
		cl->largeCmdBuf = (GLbyte *) __glXMalloc(hdr->length);
d707 1
a707 1
		cl->largeCmdBuf = (GLbyte *) __glXRealloc(cl->largeCmdBuf, hdr->length);
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d255 1
a255 1
    if (screen > screenInfo.numScreens) {
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d251 1
d485 1
d512 1
d527 1
d540 1
d572 1
d656 1
d1013 1
d1051 1
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a30 2
#define NEED_REPLIES
#define FONT_PCF
@


1.1
log
@Initial revision
@
text
@d2 28
a29 33
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: The application programming interfaces
** established by SGI in conjunction with the Original Code are The
** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
** Window System(R) (Version 1.3), released October 19, 1998. This software
** was created using the OpenGL(R) version 1.2.1 Sample Implementation
** published by SGI, but has not been independently verified as being
** compliant with the OpenGL(R) version 1.2.1 Specification.
**
*/
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
