head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.6
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	7pAEtF6Y5EgemkuY;

1.7
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.23.40;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.23.40;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include "dmx.h"
#include "dmxlog.h"

#include "glxserver.h"

#include <windowstr.h>

#include "glxfbconfig.h"

#ifdef PANORAMIX
#include "panoramiXsrv.h"
#endif

__GLXscreenInfo *__glXActiveScreens;
GLint __glXNumActiveScreens;

__GLXFBConfig **__glXFBConfigs;
int __glXNumFBConfigs;

static char GLXServerVendorName[] = "SGI DMX/glxProxy";
static char GLXServerVersion[64];
static char GLXServerExtensions[] =
    "GLX_EXT_visual_info "
    "GLX_EXT_visual_rating "
    "GLX_EXT_import_context "
    "GLX_SGIX_fbconfig " "GLX_SGI_make_current_read " "GLX_SGI_swap_control ";

static char ExtensionsString[1024];

static void
CalcServerVersionAndExtensions(void)
{
    int s;
    char **be_extensions;
    char *ext;
    char *denied_extensions;

    /*
     * set the server glx version to be the minimum version
     * supported by all back-end servers
     */
    __glXVersionMajor = 0;
    __glXVersionMinor = 0;
    for (s = 0; s < __glXNumActiveScreens; s++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = dmxScreen->beDisplay;
        xGLXQueryVersionReq *req;
        xGLXQueryVersionReply reply;

        /* Send the glXQueryVersion request */
        LockDisplay(dpy);
        GetReq(GLXQueryVersion, req);
        req->reqType = dmxScreen->glxMajorOpcode;
        req->glxCode = X_GLXQueryVersion;
        req->majorVersion = GLX_SERVER_MAJOR_VERSION;
        req->minorVersion = GLX_SERVER_MINOR_VERSION;
        _XReply(dpy, (xReply *) &reply, 0, False);
        UnlockDisplay(dpy);
        SyncHandle();

        if (s == 0) {
            __glXVersionMajor = reply.majorVersion;
            __glXVersionMinor = reply.minorVersion;
        }
        else {
            if (reply.majorVersion < __glXVersionMajor) {
                __glXVersionMajor = reply.majorVersion;
                __glXVersionMinor = reply.minorVersion;
            }
            else if ((reply.majorVersion == __glXVersionMajor) &&
                     (reply.minorVersion < __glXVersionMinor)) {
                __glXVersionMinor = reply.minorVersion;
            }
        }

    }

    if (GLX_SERVER_MAJOR_VERSION < __glXVersionMajor) {
        __glXVersionMajor = GLX_SERVER_MAJOR_VERSION;
        __glXVersionMinor = GLX_SERVER_MINOR_VERSION;
    }
    else if ((GLX_SERVER_MAJOR_VERSION == __glXVersionMajor) &&
             (GLX_SERVER_MINOR_VERSION < __glXVersionMinor)) {
        __glXVersionMinor = GLX_SERVER_MINOR_VERSION;
    }

    snprintf(GLXServerVersion, sizeof(GLXServerVersion),
             "%d.%d DMX %d back-end server(s)",
             __glXVersionMajor, __glXVersionMinor, __glXNumActiveScreens);
    /*
     * set the ExtensionsString to the minimum extensions string
     */
    ExtensionsString[0] = '\0';

    /*
     * read extensions strings of all back-end servers
     */
    be_extensions = xallocarray(__glXNumActiveScreens, sizeof(char *));
    if (!be_extensions)
        return;

    for (s = 0; s < __glXNumActiveScreens; s++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = dmxScreen->beDisplay;
        xGLXQueryServerStringReq *req;
        xGLXQueryServerStringReply reply;
        int length, numbytes;

        /* Send the glXQueryServerString request */
        LockDisplay(dpy);
        GetReq(GLXQueryServerString, req);
        req->reqType = dmxScreen->glxMajorOpcode;
        req->glxCode = X_GLXQueryServerString;
        req->screen = DefaultScreen(dpy);
        req->name = GLX_EXTENSIONS;
        _XReply(dpy, (xReply *) &reply, 0, False);

        length = (int) reply.length;
        numbytes = (int) reply.n;
        be_extensions[s] = (char *) malloc(numbytes);
        if (!be_extensions[s]) {
            /* Throw data on the floor */
            _XEatDataWords(dpy, length);
        }
        else {
            _XReadPad(dpy, (char *) be_extensions[s], numbytes);
        }
        UnlockDisplay(dpy);
        SyncHandle();
    }

    /*
     * extensions string will include only extensions that our
     * server supports as well as all back-end servers supports.
     * extensions that are in the DMX_DENY_EXTENSIONS string will
     * not be supported.
     */
    denied_extensions = getenv("DMX_DENY_GLX_EXTENSIONS");
    ext = strtok(GLXServerExtensions, " ");
    while (ext) {
        int supported = 1;

        if (denied_extensions && strstr(denied_extensions, ext)) {
            supported = 0;
        }
        else {
            for (s = 0; s < __glXNumActiveScreens && supported; s++) {
                if (!strstr(be_extensions[s], ext)) {
                    supported = 0;
                }
            }
        }

        if (supported) {
            strcat(ExtensionsString, ext);
            strcat(ExtensionsString, " ");
        }

        ext = strtok(NULL, " ");
    }

    /*
     * release temporary storage
     */
    for (s = 0; s < __glXNumActiveScreens; s++) {
        free(be_extensions[s]);
    }
    free(be_extensions);

    if (dmxGLXSwapGroupSupport) {
        if (!denied_extensions ||
            !strstr(denied_extensions, "GLX_SGIX_swap_group")) {
            strcat(ExtensionsString, "GLX_SGIX_swap_group");
            if (!denied_extensions ||
                !strstr(denied_extensions, "GLX_SGIX_swap_barrier")) {
                strcat(ExtensionsString, " GLX_SGIX_swap_barrier");
            }
        }
    }

}

void
__glXScreenInit(GLint numscreens)
{
    int s;
    int c;
    DMXScreenInfo *dmxScreen0 = &dmxScreens[0];

    __glXNumActiveScreens = numscreens;

    CalcServerVersionAndExtensions();

    __glXFBConfigs = NULL;
    __glXNumFBConfigs = 0;

    if ((__glXVersionMajor == 1 && __glXVersionMinor >= 3) ||
        (__glXVersionMajor > 1) ||
        (strstr(ExtensionsString, "GLX_SGIX_fbconfig"))) {

        /*
           // Initialize FBConfig info.
           // find the set of FBConfigs that are present on all back-end
           // servers - only those configs will be supported
         */
        __glXFBConfigs =
            xallocarray(dmxScreen0->numFBConfigs * (numscreens + 1),
                        sizeof(__GLXFBConfig *));
        __glXNumFBConfigs = 0;

        for (c = 0; c < dmxScreen0->numFBConfigs; c++) {
            __GLXFBConfig *cfg = NULL;

            if (numscreens > 1) {
                for (s = 1; s < numscreens; s++) {
                    DMXScreenInfo *dmxScreen = &dmxScreens[s];

                    cfg = FindMatchingFBConfig(&dmxScreen0->fbconfigs[c],
                                               dmxScreen->fbconfigs,
                                               dmxScreen->numFBConfigs);
                    __glXFBConfigs[__glXNumFBConfigs * (numscreens + 1) + s +
                                   1] = cfg;
                    if (!cfg) {
                        dmxLog(dmxInfo,
                               "screen0 FBConfig 0x%x is missing on screen#%d\n",
                               dmxScreen0->fbconfigs[c].id, s);
                        break;
                    }
                    else {
                        dmxLog(dmxInfo,
                               "screen0 FBConfig 0x%x matched to  0x%x on screen#%d\n",
                               dmxScreen0->fbconfigs[c].id, cfg->id, s);
                    }
                }
            }
            else {
                cfg = &dmxScreen0->fbconfigs[c];
            }

            if (cfg) {

                /* filter out overlay visuals */
                if (cfg->level == 0) {
                    __GLXFBConfig *proxy_cfg;

                    __glXFBConfigs[__glXNumFBConfigs * (numscreens + 1) + 1] =
                        &dmxScreen0->fbconfigs[c];

                    proxy_cfg = malloc(sizeof(__GLXFBConfig));
                    memcpy(proxy_cfg, cfg, sizeof(__GLXFBConfig));
                    proxy_cfg->id = FakeClientID(0);
                    /* visual will be associated later in __glXGetFBConfigs */
                    proxy_cfg->associatedVisualId = (unsigned int) -1;

                    __glXFBConfigs[__glXNumFBConfigs * (numscreens + 1) + 0] =
                        proxy_cfg;

                    __glXNumFBConfigs++;
                }

            }

        }

    }

}

void
__glXScreenReset(void)
{
    __glXNumActiveScreens = 0;
}

char *
__glXGetServerString(unsigned int name)
{
    char *ret = NULL;

    switch (name) {

    case GLX_VENDOR:
        ret = GLXServerVendorName;
        break;

    case GLX_VERSION:
        ret = GLXServerVersion;
        break;

    case GLX_EXTENSIONS:
        ret = ExtensionsString;
        break;

    default:
        break;
    }

    return ret;

}

int
glxIsExtensionSupported(const char *ext)
{
    return (strstr(ExtensionsString, ext) != NULL);
}
@


1.8
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d132 1
a132 1
    be_extensions = (char **) malloc(__glXNumActiveScreens * sizeof(char *));
d240 3
a242 4
        __glXFBConfigs = (__GLXFBConfig **) malloc(dmxScreen0->numFBConfigs *
                                                   (numscreens +
                                                    1) *
                                                   sizeof(__GLXFBConfig *));
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a67 2
    xGLXQueryVersionReq *req;
    xGLXQueryVersionReply reply;
d81 2
d338 1
a338 1
glxIsExtensionSupported(char *ext)
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d141 1
a141 1
        int length, numbytes, slop;
a153 1
        slop = numbytes * __GLX_SIZE_INT8 & 3;
d157 1
a157 1
            _XEatData(dpy, length);
d160 1
a160 3
            _XRead(dpy, (char *) be_extensions[s], numbytes);
            if (slop)
                _XEatData(dpy, 4 - slop);
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d91 1
a91 1
        _XReply(dpy, (xReply *) & reply, 0, False);
d150 1
a150 1
        _XReply(dpy, (xReply *) & reply, 0, False);
@


1.4
log
@Update to xserver 1.11.2
@
text
@d52 1
a52 1
int            __glXNumFBConfigs;
d57 4
a60 7
            "GLX_EXT_visual_info "
            "GLX_EXT_visual_rating "
            "GLX_EXT_import_context "
	    "GLX_SGIX_fbconfig "
	    "GLX_SGI_make_current_read "
	    "GLX_SGI_swap_control "
            ;
d64 2
a65 1
static void CalcServerVersionAndExtensions( void )
d67 42
a108 147
   int s;
   xGLXQueryVersionReq *req;
   xGLXQueryVersionReply reply;
   char **be_extensions;
   char *ext;
   char *denied_extensions;

   /*
    * set the server glx version to be the minimum version
    * supported by all back-end servers
    */
   __glXVersionMajor = 0;
   __glXVersionMinor = 0;
   for (s=0; s<__glXNumActiveScreens; s++) {
      DMXScreenInfo *dmxScreen = &dmxScreens[s];
      Display *dpy = dmxScreen->beDisplay;

      /* Send the glXQueryVersion request */
      LockDisplay(dpy);
      GetReq(GLXQueryVersion,req);
      req->reqType = dmxScreen->glxMajorOpcode;
      req->glxCode = X_GLXQueryVersion;
      req->majorVersion = GLX_SERVER_MAJOR_VERSION;
      req->minorVersion = GLX_SERVER_MINOR_VERSION;
      _XReply(dpy, (xReply*) &reply, 0, False);
      UnlockDisplay(dpy);
      SyncHandle();

      if (s == 0) {
	 __glXVersionMajor = reply.majorVersion;
	 __glXVersionMinor = reply.minorVersion;
      }
      else {
	 if (reply.majorVersion < __glXVersionMajor) {
	    __glXVersionMajor = reply.majorVersion;
	    __glXVersionMinor = reply.minorVersion;
	 }
	 else if ( (reply.majorVersion == __glXVersionMajor) &&
	           (reply.minorVersion < __glXVersionMinor)  ) {
	    __glXVersionMinor = reply.minorVersion;
	 }
      }

   }

   if (GLX_SERVER_MAJOR_VERSION < __glXVersionMajor) {
      __glXVersionMajor = GLX_SERVER_MAJOR_VERSION;
      __glXVersionMinor = GLX_SERVER_MINOR_VERSION;
   }
   else if ( (GLX_SERVER_MAJOR_VERSION == __glXVersionMajor) &&
	     (GLX_SERVER_MINOR_VERSION < __glXVersionMinor)  ) {
      __glXVersionMinor = GLX_SERVER_MINOR_VERSION;
   }

   sprintf(GLXServerVersion, "%d.%d DMX %d back-end server(s)",
              __glXVersionMajor, __glXVersionMinor, __glXNumActiveScreens );	 
   /*
    * set the ExtensionsString to the minimum extensions string
    */
   ExtensionsString[0] = '\0';

   /*
    * read extensions strings of all back-end servers
    */
   be_extensions = (char **)malloc( __glXNumActiveScreens * sizeof(char *) );
   if (!be_extensions)
      return;

   for (s=0; s<__glXNumActiveScreens; s++) {
      DMXScreenInfo *dmxScreen = &dmxScreens[s];
      Display *dpy = dmxScreen->beDisplay;
      xGLXQueryServerStringReq *req;
      xGLXQueryServerStringReply reply;
      int length, numbytes, slop;

      /* Send the glXQueryServerString request */
      LockDisplay(dpy);
      GetReq(GLXQueryServerString,req);
      req->reqType = dmxScreen->glxMajorOpcode;
      req->glxCode = X_GLXQueryServerString;
      req->screen = DefaultScreen(dpy);
      req->name = GLX_EXTENSIONS;
      _XReply(dpy, (xReply*) &reply, 0, False);

      length = (int)reply.length;
      numbytes = (int)reply.n;
      slop = numbytes * __GLX_SIZE_INT8 & 3;
      be_extensions[s] = (char *)malloc(numbytes);
      if (!be_extensions[s]) {
	 /* Throw data on the floor */
	 _XEatData(dpy, length);
      } else {
	 _XRead(dpy, (char *)be_extensions[s], numbytes);
	 if (slop) _XEatData(dpy,4-slop);
      }
      UnlockDisplay(dpy);
      SyncHandle();
   }

   /*
    * extensions string will include only extensions that our
    * server supports as well as all back-end servers supports.
    * extensions that are in the DMX_DENY_EXTENSIONS string will
    * not be supported.
    */
   denied_extensions = getenv("DMX_DENY_GLX_EXTENSIONS");
   ext = strtok(GLXServerExtensions, " ");
   while( ext ) {
      int supported = 1;

      if (denied_extensions && strstr(denied_extensions, ext)) {
	 supported = 0;
      }
      else {
	 for (s=0; s<__glXNumActiveScreens && supported; s++) {
	    if ( !strstr(be_extensions[s], ext) ) {
	       supported = 0;
	    }
	 }
      }

      if (supported) {
	 strcat(ExtensionsString, ext);
	 strcat(ExtensionsString, " ");
      }

      ext = strtok(NULL, " ");
   }

   /*
    * release temporary storage
    */
   for (s=0; s<__glXNumActiveScreens; s++) {
      free(be_extensions[s]);
   }
   free( be_extensions );

   if (dmxGLXSwapGroupSupport) {
       if (!denied_extensions ||
	   !strstr(denied_extensions, "GLX_SGIX_swap_group")) {
	   strcat(ExtensionsString, "GLX_SGIX_swap_group");
	   if (!denied_extensions ||
	       !strstr(denied_extensions, "GLX_SGIX_swap_barrier")) {
	       strcat(ExtensionsString, " GLX_SGIX_swap_barrier");
	   }
       }
   }
d110 1
a110 1
}
d112 8
a119 6
void __glXScreenInit(GLint numscreens)
{
   int s;
   int c;
   DMXScreenInfo *dmxScreen0 = &dmxScreens[0];
    __glXNumActiveScreens = numscreens;
d121 47
d169 26
a194 1
   CalcServerVersionAndExtensions();
d196 2
d199 7
a205 63
   __glXFBConfigs = NULL;
   __glXNumFBConfigs = 0;

   if ( (__glXVersionMajor == 1 && __glXVersionMinor >= 3) ||
        (__glXVersionMajor > 1) ||
	( strstr(ExtensionsString, "GLX_SGIX_fbconfig") )      ) {

      /*
      // Initialize FBConfig info.
      // find the set of FBConfigs that are present on all back-end
      // servers - only those configs will be supported
       */
      __glXFBConfigs = (__GLXFBConfig **)malloc( dmxScreen0->numFBConfigs *
	                      (numscreens+1) * sizeof(__GLXFBConfig *) );
      __glXNumFBConfigs = 0;
   
      for (c=0; c<dmxScreen0->numFBConfigs; c++) { 
	 __GLXFBConfig *cfg = NULL;

	 if (numscreens > 1) {
	    for (s=1; s<numscreens; s++) {
	       DMXScreenInfo *dmxScreen = &dmxScreens[s];
	  
	       cfg = FindMatchingFBConfig( &dmxScreen0->fbconfigs[c],
		                           dmxScreen->fbconfigs, 
		                           dmxScreen->numFBConfigs );
	       __glXFBConfigs[ __glXNumFBConfigs * (numscreens+1) + s + 1 ] = cfg;
	       if (!cfg) {
		  dmxLog(dmxInfo,"screen0 FBConfig 0x%x is missing on screen#%d\n", dmxScreen0->fbconfigs[c].id, s);
		  break;
	       }
	       else {
		  dmxLog(dmxInfo,"screen0 FBConfig 0x%x matched to  0x%x on screen#%d\n", dmxScreen0->fbconfigs[c].id, cfg->id, s);
	       }
	    }
         }
	 else {
	    cfg = &dmxScreen0->fbconfigs[c];
	 }

	 if (cfg) {

	    /* filter out overlay visuals */
	    if (cfg->level == 0) {
	       __GLXFBConfig *proxy_cfg;

	       __glXFBConfigs[ __glXNumFBConfigs * (numscreens+1) + 1 ] = 
	               &dmxScreen0->fbconfigs[c];

	       proxy_cfg = malloc( sizeof(__GLXFBConfig) );
	       memcpy( proxy_cfg, cfg, sizeof(__GLXFBConfig) );
	       proxy_cfg->id =  FakeClientID(0);
	       /* visual will be associated later in __glXGetFBConfigs */
	       proxy_cfg->associatedVisualId =  (unsigned int)-1;

	       __glXFBConfigs[ __glXNumFBConfigs * (numscreens+1) + 0 ] = proxy_cfg;

	       __glXNumFBConfigs++;
	    }

	 }

      }
d207 9
d220 2
a221 1
void __glXScreenReset(void)
d223 7
a229 2
  __glXNumActiveScreens = 0;
}
d231 2
a232 3
char *__glXGetServerString( unsigned int name ) 
{
   char *ret = NULL;
d234 3
a236 1
   switch( name) {
d238 57
a294 3
      case GLX_VENDOR:
	 ret = GLXServerVendorName;
	 break;
d296 2
a297 3
      case GLX_VERSION:
	 ret = GLXServerVersion;
	 break;
d299 1
a299 3
      case GLX_EXTENSIONS:
	 ret = ExtensionsString;
	 break;
d301 1
a301 3
      default:
	 break;
   }
d303 1
a303 1
   return ret;
d307 2
a308 2

__GLXFBConfig *glxLookupFBConfig( GLXFBConfigID id )
d310 1
a310 8
   int i,j;

   for (i=0, j=0; i<__glXNumFBConfigs; i++,j+=(__glXNumActiveScreens+1) ) {
      if ( __glXFBConfigs[j]->id == id) 
	 return __glXFBConfigs[j];
   }

   return NULL;
d313 2
a314 1
__GLXFBConfig *glxLookupFBConfigByVID( VisualID vid )
d316 3
a318 1
   int i,j;
d320 3
a322 4
   for (i=0, j=0; i<__glXNumFBConfigs; i++,j+=(__glXNumActiveScreens+1) ) {
      if ( __glXFBConfigs[j]->associatedVisualId == vid) 
	 return __glXFBConfigs[j];
   }
d324 3
a326 2
   return NULL;
}
d328 3
a330 4
__GLXFBConfig *glxLookupBackEndFBConfig( GLXFBConfigID id, int screen )
{
   int i;
   int j;
d332 3
a334 4
   for (i=0, j=0; i<__glXNumFBConfigs; i++,j+=(__glXNumActiveScreens+1) ) {
      if ( __glXFBConfigs[j]->id == id) 
	 return __glXFBConfigs[j+screen+1];
   }
d336 1
a336 1
   return NULL;
d340 2
a341 1
int glxIsExtensionSupported( char *ext )
d343 1
a343 1
   return( strstr(ExtensionsString, ext) != NULL );
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a37 5
#undef Xmalloc
#undef Xcalloc
#undef Xrealloc
#undef Xfree

@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d138 1
a138 1
   be_extensions = (char **)Xalloc( __glXNumActiveScreens * sizeof(char *) );
d161 1
a161 1
      be_extensions[s] = (char *)Xalloc(numbytes);
d207 1
a207 1
      if (be_extensions[s]) Xfree(be_extensions[s]); 
d209 1
a209 1
   Xfree( be_extensions );
d247 1
a247 1
      __glXFBConfigs = (__GLXFBConfig **)Xalloc( dmxScreen0->numFBConfigs * 
a256 1
	       __GLXscreenInfo *glxScreen = &__glXActiveScreens[s];
d284 1
a284 1
	       proxy_cfg = Xalloc( sizeof(__GLXFBConfig) );
d330 1
a330 1
   return( ret );
d341 1
a341 1
	 return( __glXFBConfigs[j] );
d344 1
a344 1
   return(NULL);
d353 1
a353 1
	 return( __glXFBConfigs[j] );
d356 1
a356 1
   return(NULL);
d366 1
a366 1
	 return( __glXFBConfigs[j+screen+1] );
d369 1
a369 1
   return(NULL);
@


1.1
log
@Initial revision
@
text
@d2 28
a29 33
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: The application programming interfaces
** established by SGI in conjunction with the Original Code are The
** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
** Window System(R) (Version 1.3), released October 19, 1998. This software
** was created using the OpenGL(R) version 1.2.1 Sample Implementation
** published by SGI, but has not been independently verified as being
** compliant with the OpenGL(R) version 1.2.1 Specification.
**
*/
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
