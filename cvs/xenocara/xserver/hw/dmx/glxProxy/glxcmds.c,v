head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.6
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	s0SI41sEunLdyFfd;

1.14
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	7pAEtF6Y5EgemkuY;

1.13
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	Te1daavkBLskZ8gc;

1.12
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	cVXoV5PxI8YrEaVA;

1.11
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.21.20.10.46;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.17;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.23.39;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.23.39;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.28;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
 * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice including the dates of first publication and
 * either this permission notice or a reference to
 * http://oss.sgi.com/projects/FreeB/
 * shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of Silicon Graphics, Inc.
 * shall not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization from
 * Silicon Graphics, Inc.
 */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include "dmx.h"
#include "dmxwindow.h"
#include "dmxpixmap.h"
#include "dmxfont.h"
#include "dmxsync.h"

#include "glxserver.h"
#include <GL/glxtokens.h>
#include "g_disptab.h"
#include <pixmapstr.h>
#include <windowstr.h>
#include "glxutil.h"
#include "glxext.h"
#include "unpack.h"

#include "GL/glxproto.h"
#include "glxvendor.h"
#include "glxvisuals.h"
#include "glxswap.h"

#include "glxcmds.h"

#ifdef PANORAMIX
#include "panoramiXsrv.h"
#endif

extern __GLXFBConfig **__glXFBConfigs;
extern int __glXNumFBConfigs;

extern int __glXGetFBConfigsSGIX(__GLXclientState * cl, GLbyte * pc);

#define BE_TO_CLIENT_ERROR(x) \
           ( (x) >= __glXerrorBase ? \
             (x) - dmxScreen->glxErrorBase + __glXerrorBase \
	     : (x) )

static __GLXFBConfig *
glxLookupFBConfig(GLXFBConfigID id)
{
    int i, j;

    for (i = 0, j = 0; i < __glXNumFBConfigs;
         i++, j += (__glXNumActiveScreens + 1)) {
        if (__glXFBConfigs[j]->id == id)
            return __glXFBConfigs[j];
    }

    return NULL;
}

static __GLXFBConfig *
glxLookupFBConfigByVID(VisualID vid)
{
    int i, j;

    for (i = 0, j = 0; i < __glXNumFBConfigs;
         i++, j += (__glXNumActiveScreens + 1)) {
        if (__glXFBConfigs[j]->associatedVisualId == vid)
            return __glXFBConfigs[j];
    }

    return NULL;
}

static __GLXFBConfig *
glxLookupBackEndFBConfig(GLXFBConfigID id, int screen)
{
    int i;
    int j;

    for (i = 0, j = 0; i < __glXNumFBConfigs;
         i++, j += (__glXNumActiveScreens + 1)) {
        if (__glXFBConfigs[j]->id == id)
            return __glXFBConfigs[j + screen + 1];
    }

    return NULL;

}

Display *
GetBackEndDisplay(__GLXclientState * cl, int s)
{
    if (!cl->be_displays[s]) {
        cl->be_displays[s] =
            XOpenDisplay(DisplayString(dmxScreens[s].beDisplay));
    }
    return cl->be_displays[s];
}

/**
 * Convert the render type bits from fbconfig into context render type.
 */
static int
renderTypeBitsToRenderTypeEnum(int fbRenderType)
{
    if (fbRenderType & GLX_RGBA_BIT)
        return GLX_RGBA_TYPE;

    if (fbRenderType & GLX_COLOR_INDEX_BIT)
        return  GLX_COLOR_INDEX_TYPE;

    if (fbRenderType & GLX_RGBA_FLOAT_BIT_ARB)
        return GLX_RGBA_FLOAT_TYPE_ARB;

    if (fbRenderType & GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT)
        return GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT;

    /* There's no recognized renderType in the config */
    return GLX_RGBA_TYPE;
}

/*
** Create a GL context with the given properties.
*/
static int
CreateContext(__GLXclientState * cl,
              GLXContextID gcId,
              VisualID vid, GLXFBConfigID fbconfigId,
              int screen, GLXContextID shareList, int isDirect)
{
    ClientPtr client = cl->client;
    xGLXCreateContextReq *be_req;
    xGLXCreateNewContextReq *be_new_req;
    VisualPtr pVisual;
    ScreenPtr pScreen;
    __GLXcontext *glxc, *shareglxc;
    __GLXvisualConfig *pGlxVisual;
    __GLXscreenInfo *pGlxScreen;
    VisualID visual = vid;
    GLint i;
    int from_screen = screen;
    int to_screen = screen;
    DMXScreenInfo *dmxScreen;
    VisualID be_vid = 0;
    GLXFBConfigID be_fbconfigId = 0;
    int num_be_screens;
    Display *dpy;

    /*
     ** Check if screen exists.
     */
    if (screen >= screenInfo.numScreens) {
        client->errorValue = screen;
        return BadValue;
    }

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    /*
     ** Find the display list space that we want to share.
     **
     */
    if (shareList == None) {
        shareglxc = NULL;
    }
    else {
        dixLookupResourceByType((void **) &shareglxc, shareList,
                                __glXContextRes, NullClient, DixUnknownAccess);
        if (!shareglxc) {
            client->errorValue = shareList;
            return __glXBadContext;
        }
    }

    /*
     ** Allocate memory for the new context
     */
    glxc = calloc(1, sizeof(__GLXcontext));
    if (!glxc) {
        return BadAlloc;
    }

    pScreen = screenInfo.screens[screen];
    pGlxScreen = &__glXActiveScreens[screen];

    if (fbconfigId != None) {
        glxc->pFBConfig = glxLookupFBConfig(fbconfigId);
        if (!glxc->pFBConfig) {
            client->errorValue = fbconfigId;
            free(glxc);
            return BadValue;
        }
        visual = glxc->pFBConfig->associatedVisualId;
    }
    else {
        glxc->pFBConfig = NULL;
    }

    if (visual != None) {
        /*
         ** Check if the visual ID is valid for this screen.
         */
        pVisual = pScreen->visuals;
        for (i = 0; i < pScreen->numVisuals; i++, pVisual++) {
            if (pVisual->vid == visual) {
                break;
            }
        }
        if (i == pScreen->numVisuals) {
            client->errorValue = visual;
            free(glxc);
            return BadValue;
        }

        pGlxVisual = pGlxScreen->pGlxVisual;
        for (i = 0; i < pGlxScreen->numVisuals; i++, pGlxVisual++) {
            if (pGlxVisual->vid == visual) {
                break;
            }
        }
        if (i == pGlxScreen->numVisuals) {
            /*
             ** Visual not support on this screen by this OpenGL implementation.
             */
            client->errorValue = visual;
            free(glxc);
            return BadValue;
        }

        if (glxc->pFBConfig == NULL) {
            glxc->pFBConfig = glxLookupFBConfigByVID(visual);

            if (glxc->pFBConfig == NULL) {
                /*
                 * visual does not have an FBConfig ???
                 client->errorValue = visual;
                 free( glxc );
                 return BadValue;
                 */
            }
        }
    }
    else {
        pVisual = NULL;
        pGlxVisual = NULL;
    }

    glxc->pScreen = pScreen;
    glxc->pGlxScreen = pGlxScreen;
    glxc->pVisual = pVisual;
    glxc->pGlxVisual = pGlxVisual;

    /*
     * allocate memory for back-end servers info
     */
    num_be_screens = to_screen - from_screen + 1;
    glxc->real_ids = xallocarray(num_be_screens, sizeof(XID));
    if (!glxc->real_ids) {
        return BadAlloc;
    }
    glxc->real_vids = xallocarray(num_be_screens, sizeof(XID));
    if (!glxc->real_vids) {
        return BadAlloc;
    }

    for (screen = from_screen; screen <= to_screen; screen++) {
        int sent = 0;

        pScreen = screenInfo.screens[screen];
        pGlxScreen = &__glXActiveScreens[screen];
        dmxScreen = &dmxScreens[screen];

        if (glxc->pFBConfig) {
            __GLXFBConfig *beFBConfig =
                glxLookupBackEndFBConfig(glxc->pFBConfig->id,
                                         screen);

            be_fbconfigId = beFBConfig->id;
        }

        if (pGlxVisual) {

            be_vid = glxMatchGLXVisualInConfigList(pGlxVisual,
                                                   dmxScreen->glxVisuals,
                                                   dmxScreen->numGlxVisuals);

            if (!be_vid) {
                /* visual is not supported on the back-end server */
                free(glxc->real_ids);
                free(glxc->real_vids);
                free(glxc);
                return BadValue;
            }
        }

        glxc->real_ids[screen - from_screen] =
            XAllocID(GetBackEndDisplay(cl, screen));

        /* send the create context request to the back-end server */
        dpy = GetBackEndDisplay(cl, screen);
        if (glxc->pFBConfig) {
            /* For a specific visual, multiple render types (i.e., both RGB
             * and COLOR INDEX) can be accessible. The only parameter to
             * choose the renderType should be the class of the colormap,
             * since the first classes do not support RGB mode (only COLOR
             * INDEX), and TrueColor and DirectColor do not support COLOR
             * INDEX.
             */
            int renderType = GLX_RGBA_TYPE;

            if (pVisual) {
                switch (pVisual->class) {
                case PseudoColor:
                case StaticColor:
                case GrayScale:
                case StaticGray:
                    renderType = GLX_COLOR_INDEX_TYPE;
                    break;
                case TrueColor:
                case DirectColor:
                default:
                    renderType = GLX_RGBA_TYPE;
                    break;
                }
            } else {
                renderType =
                    renderTypeBitsToRenderTypeEnum(glxc->pFBConfig->renderType);
            }

            if (__GLX_IS_VERSION_SUPPORTED(1, 3)) {
                LockDisplay(dpy);
                GetReq(GLXCreateNewContext, be_new_req);
                be_new_req->reqType = dmxScreen->glxMajorOpcode;
                be_new_req->glxCode = X_GLXCreateNewContext;
                be_new_req->context =
                    (unsigned int) glxc->real_ids[screen - from_screen];
                be_new_req->fbconfig = (unsigned int) be_fbconfigId;
                be_new_req->screen = DefaultScreen(dpy);
                be_new_req->renderType = renderType;

                be_new_req->shareList =
                    (shareglxc ? shareglxc->real_ids[screen - from_screen] : 0);
                be_new_req->isDirect = 0;
                UnlockDisplay(dpy);
                glxc->real_vids[screen - from_screen] = be_fbconfigId;
                sent = 1;
            }
            else if (glxIsExtensionSupported("GLX_SGIX_fbconfig")) {

                xGLXCreateContextWithConfigSGIXReq *ext_req;
                xGLXVendorPrivateReq *vpreq;

                LockDisplay(dpy);
                GetReqExtra(GLXVendorPrivate,
                            sz_xGLXCreateContextWithConfigSGIXReq -
                            sz_xGLXVendorPrivateReq, vpreq);
                ext_req = (xGLXCreateContextWithConfigSGIXReq *) vpreq;
                ext_req->reqType = dmxScreen->glxMajorOpcode;
                ext_req->glxCode = X_GLXVendorPrivate;
                ext_req->vendorCode = X_GLXvop_CreateContextWithConfigSGIX;
                ext_req->context =
                    (unsigned int) glxc->real_ids[screen - from_screen];
                ext_req->fbconfig = (unsigned int) be_fbconfigId;
                ext_req->screen = DefaultScreen(dpy);
                ext_req->renderType = renderType;
                ext_req->shareList =
                    (shareglxc ? shareglxc->real_ids[screen - from_screen] : 0);
                ext_req->isDirect = 0;
                UnlockDisplay(dpy);
                glxc->real_vids[screen - from_screen] = be_fbconfigId;
                sent = 1;
            }
        }

        if (!sent) {
            LockDisplay(dpy);
            GetReq(GLXCreateContext, be_req);
            be_req->reqType = dmxScreen->glxMajorOpcode;
            be_req->glxCode = X_GLXCreateContext;
            be_req->context =
                (unsigned int) glxc->real_ids[screen - from_screen];
            be_req->visual = (unsigned int) be_vid;
            be_req->screen = DefaultScreen(dpy);
            be_req->shareList =
                (shareglxc ? shareglxc->real_ids[screen - from_screen] : 0);
            be_req->isDirect = 0;
            UnlockDisplay(dpy);
            glxc->real_vids[screen - from_screen] = be_vid;
        }
        SyncHandle();

    }

    /*
     ** Register this context as a resource.
     */
    if (!AddResource(gcId, __glXContextRes, (void *) glxc)) {
        free(glxc->real_ids);
        free(glxc->real_vids);
        free(glxc);
        client->errorValue = gcId;
        return BadAlloc;
    }

    /*
     ** Finally, now that everything is working, setup the rest of the
     ** context.
     */
    glxc->id = gcId;
    glxc->share_id = shareList;
    glxc->idExists = GL_TRUE;
    glxc->isCurrent = GL_FALSE;

    return Success;
}

int
__glXCreateContext(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;

    return (CreateContext(cl, req->context, req->visual, None,
                          req->screen, req->shareList, req->isDirect));

}

int
__glXCreateNewContext(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreateNewContextReq *req = (xGLXCreateNewContextReq *) pc;

    return (CreateContext(cl, req->context, None, req->fbconfig,
                          req->screen, req->shareList, req->isDirect));

}

int
__glXCreateContextWithConfigSGIX(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreateContextWithConfigSGIXReq *req =
        (xGLXCreateContextWithConfigSGIXReq *) pc;

    return (CreateContext(cl, req->context, None, req->fbconfig,
                          req->screen, req->shareList, req->isDirect));

}

int
__glXQueryMaxSwapBarriersSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXQueryMaxSwapBarriersSGIXReq *req =
        (xGLXQueryMaxSwapBarriersSGIXReq *) pc;
    xGLXQueryMaxSwapBarriersSGIXReply reply = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .max = QueryMaxSwapBarriersSGIX(req->screen)
    };

    if (client->swapped) {
        __glXSwapQueryMaxSwapBarriersSGIXReply(client, &reply);
    }
    else {
        WriteToClient(client, sz_xGLXQueryMaxSwapBarriersSGIXReply, &reply);
    }

    return Success;
}

int
__glXBindSwapBarrierSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXBindSwapBarrierSGIXReq *req = (xGLXBindSwapBarrierSGIXReq *) pc;
    DrawablePtr pDraw;
    __GLXpixmap *pGlxPixmap = NULL;
    __glXWindow *pGlxWindow = NULL;
    int rc;

    rc = dixLookupDrawable(&pDraw, req->drawable, client, 0, DixGetAttrAccess);
    if (rc != Success) {
        dixLookupResourceByType((void **) &pGlxPixmap, req->drawable,
                                __glXPixmapRes, NullClient, DixUnknownAccess);
        if (pGlxPixmap)
            pDraw = pGlxPixmap->pDraw;
    }

    if (!pDraw && __GLX_IS_VERSION_SUPPORTED(1, 3)) {
        dixLookupResourceByType((void **) &pGlxWindow, req->drawable,
                                __glXWindowRes, NullClient, DixUnknownAccess);
        if (pGlxWindow)
            pDraw = pGlxWindow->pDraw;
    }

    if (!pDraw) {
        client->errorValue = req->drawable;
        return __glXBadDrawable;
    }

    return BindSwapBarrierSGIX(pDraw, req->barrier);
}

int
__glXJoinSwapGroupSGIX(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXJoinSwapGroupSGIXReq *req = (xGLXJoinSwapGroupSGIXReq *) pc;
    DrawablePtr pDraw, pMember = NULL;
    __GLXpixmap *pGlxPixmap = NULL;
    __glXWindow *pGlxWindow = NULL;
    int rc;

    rc = dixLookupDrawable(&pDraw, req->drawable, client, 0, DixManageAccess);
    if (rc != Success) {
        dixLookupResourceByType((void **) &pGlxPixmap, req->drawable,
                                __glXPixmapRes, NullClient, DixUnknownAccess);
        if (pGlxPixmap)
            pDraw = pGlxPixmap->pDraw;
    }

    if (!pDraw && __GLX_IS_VERSION_SUPPORTED(1, 3)) {
        dixLookupResourceByType((void **) &pGlxWindow, req->drawable,
                                __glXWindowRes, NullClient, DixUnknownAccess);
        if (pGlxWindow)
            pDraw = pGlxWindow->pDraw;
    }

    if (!pDraw) {
        client->errorValue = req->drawable;
        return __glXBadDrawable;
    }

    if (req->member != None) {
        rc = dixLookupDrawable(&pMember, req->member, client, 0,
                               DixGetAttrAccess);
        if (rc != Success) {
            dixLookupResourceByType((void **) &pGlxPixmap, req->member,
                                    __glXPixmapRes, NullClient,
                                    DixUnknownAccess);
            if (pGlxPixmap)
                pMember = pGlxPixmap->pDraw;
        }

        if (!pMember && __GLX_IS_VERSION_SUPPORTED(1, 3)) {
            dixLookupResourceByType((void **) &pGlxWindow, req->member,
                                    __glXWindowRes, NullClient,
                                    DixUnknownAccess);
            if (pGlxWindow)
                pMember = pGlxWindow->pDraw;
        }

        if (!pMember) {
            client->errorValue = req->member;
            return __glXBadDrawable;
        }
    }

    return JoinSwapGroupSGIX(pDraw, pMember);
}

/*
** Destroy a GL context as an X resource.
*/
int
__glXDestroyContext(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyContextReq *req = (xGLXDestroyContextReq *) pc;
    xGLXDestroyContextReq *be_req;
    GLXContextID gcId = req->context;
    __GLXcontext *glxc;
    int from_screen = 0;
    int to_screen = 0;
    int s;

    dixLookupResourceByType((void **) &glxc, gcId, __glXContextRes,
                            NullClient, DixUnknownAccess);
    if (glxc) {
        /*
         ** Just free the resource; don't actually destroy the context,
         ** because it might be in use.  The
         ** destroy method will be called by the resource destruction routine
         ** if necessary.
         */
        FreeResourceByType(gcId, __glXContextRes, FALSE);

        from_screen = to_screen = glxc->pScreen->myNum;

    }
    else {
        client->errorValue = gcId;
        return __glXBadContext;
    }

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    /*
     * send DestroyContext request to all back-end servers
     */
    for (s = from_screen; s <= to_screen; s++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = GetBackEndDisplay(cl, s);

        LockDisplay(dpy);
        GetReq(GLXDestroyContext, be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = X_GLXDestroyContext;
        be_req->context = glxc->real_ids[s - from_screen];
        UnlockDisplay(dpy);
        SyncHandle();
    }

    return Success;
}

/*****************************************************************************/

/*
** For each client, the server keeps a table of all the contexts that are
** current for that client (each thread of a client may have its own current
** context).  These routines add, change, and lookup contexts in the table.
*/

/*
** Add a current context, and return the tag that will be used to refer to it.
*/
static int
AddCurrentContext(__GLXclientState * cl, __GLXcontext * glxc, DrawablePtr pDraw)
{
    int i;
    int num = cl->numCurrentContexts;
    __GLXcontext **table = cl->currentContexts;

    if (!glxc)
        return -1;

    /*
     ** Try to find an empty slot and use it.
     */
    for (i = 0; i < num; i++) {
        if (!table[i]) {
            table[i] = glxc;
            return i + 1;
        }
    }
    /*
     ** Didn't find a free slot, so we'll have to grow the table.
     */
    if (!num) {
        table = (__GLXcontext **) malloc(sizeof(__GLXcontext *));
        cl->currentDrawables = (DrawablePtr *) malloc(sizeof(DrawablePtr));
        cl->be_currentCTag = xallocarray(screenInfo.numScreens,
                                         sizeof(GLXContextTag));
    }
    else {
        table = reallocarray(table, num + 1, sizeof(__GLXcontext *));
        cl->currentDrawables = reallocarray(cl->currentDrawables, num + 1,
                                            sizeof(DrawablePtr));
        cl->be_currentCTag = reallocarray(cl->be_currentCTag,
                                          (num + 1) * screenInfo.numScreens,
                                          sizeof(GLXContextTag));
    }
    table[num] = glxc;
    cl->currentDrawables[num] = pDraw;
    cl->currentContexts = table;
    cl->numCurrentContexts++;

    memset(cl->be_currentCTag + num * screenInfo.numScreens, 0,
           screenInfo.numScreens * sizeof(GLXContextTag));

    return num + 1;
}

/*
** Given a tag, change the current context for the corresponding entry.
*/
static void
ChangeCurrentContext(__GLXclientState * cl, __GLXcontext * glxc,
                     GLXContextTag tag)
{
    __GLXcontext **table = cl->currentContexts;

    table[tag - 1] = glxc;
}

/*
** Given a tag, and back-end screen number, retrives the current back-end
** tag.
*/
int
GetCurrentBackEndTag(__GLXclientState * cl, GLXContextTag tag, int s)
{
    if (tag > 0) {
        return (cl->be_currentCTag[(tag - 1) * screenInfo.numScreens + s]);
    }
    else {
        return 0;
    }
}

/*
** Given a tag, and back-end screen number, sets the current back-end
** tag.
*/
static void
SetCurrentBackEndTag(__GLXclientState * cl, GLXContextTag tag, int s,
                     GLXContextTag be_tag)
{
    if (tag > 0) {
        cl->be_currentCTag[(tag - 1) * screenInfo.numScreens + s] = be_tag;
    }
}

/*
** For this implementation we have chosen to simply use the index of the
** context's entry in the table as the context tag.  A tag must be greater
** than 0.
*/
__GLXcontext *
__glXLookupContextByTag(__GLXclientState * cl, GLXContextTag tag)
{
    int num = cl->numCurrentContexts;

    if (tag < 1 || tag > num) {
        return 0;
    }
    else {
        return cl->currentContexts[tag - 1];
    }
}

DrawablePtr
__glXLookupDrawableByTag(__GLXclientState * cl, GLXContextTag tag)
{
    int num = cl->numCurrentContexts;

    if (tag < 1 || tag > num) {
        return 0;
    }
    else {
        return cl->currentDrawables[tag - 1];
    }
}

/*****************************************************************************/

static void
StopUsingContext(__GLXcontext * glxc)
{
    if (glxc) {
        if (glxc == __glXLastContext) {
            /* Tell server GL library */
            __glXLastContext = 0;
        }
        glxc->isCurrent = GL_FALSE;
        if (!glxc->idExists) {
            __glXFreeContext(glxc);
        }
    }
}

static void
StartUsingContext(__GLXclientState * cl, __GLXcontext * glxc)
{
    glxc->isCurrent = GL_TRUE;
}

/*****************************************************************************/
/*
** Make an OpenGL context and drawable current.
*/
static int
MakeCurrent(__GLXclientState * cl,
            GLXDrawable drawable,
            GLXDrawable readdrawable,
            GLXContextID context, GLXContextTag oldContextTag)
{
    ClientPtr client = cl->client;
    DrawablePtr pDraw = NULL;
    DrawablePtr pReadDraw = NULL;
    xGLXMakeCurrentReadSGIReply new_reply = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };
    xGLXMakeCurrentReq *be_req;
    xGLXMakeCurrentReply be_reply;
    xGLXMakeContextCurrentReq *be_new_req;
    xGLXMakeContextCurrentReply be_new_reply;
    GLXDrawable drawId = drawable;
    GLXDrawable readId = readdrawable;
    GLXContextID contextId = context;
    __GLXpixmap *pGlxPixmap = 0;
    __GLXpixmap *pReadGlxPixmap = 0;
    __GLXcontext *glxc, *prevglxc;
    GLXContextTag tag = oldContextTag;
    WindowPtr pWin = NULL;
    WindowPtr pReadWin = NULL;
    __glXWindow *pGlxWindow = NULL;
    __glXWindow *pGlxReadWindow = NULL;
    __glXPbuffer *pGlxPbuffer = NULL;
    __glXPbuffer *pGlxReadPbuffer = NULL;

#ifdef PANORAMIX
    PanoramiXRes *pXinDraw = NULL;
    PanoramiXRes *pXinReadDraw = NULL;
#endif
    int from_screen = 0;
    int to_screen = 0;
    int s, rc;

    /*
     ** If one is None and the other isn't, it's a bad match.
     */
    if ((drawId == None && contextId != None) ||
        (drawId != None && contextId == None)) {
        return BadMatch;
    }

    /*
     ** Lookup old context.  If we have one, it must be in a usable state.
     */
    if (tag != 0) {
        prevglxc = __glXLookupContextByTag(cl, tag);
        if (!prevglxc) {
            /*
             ** Tag for previous context is invalid.
             */
            return __glXBadContextTag;
        }
    }
    else {
        prevglxc = 0;
    }

    /*
     ** Lookup new context.  It must not be current for someone else.
     */
    if (contextId != None) {
        dixLookupResourceByType((void **) &glxc, contextId, __glXContextRes,
                                NullClient, DixUnknownAccess);
        if (!glxc) {
            client->errorValue = contextId;
            return __glXBadContext;
        }
        if ((glxc != prevglxc) && glxc->isCurrent) {
            /* Context is current to somebody else */
            return BadAccess;
        }
    }
    else {
        /* Switching to no context.  Ignore new drawable. */
        glxc = 0;
    }

    if (drawId != None) {
        rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixWriteAccess);
        if (rc == Success) {
            if (pDraw->type == DRAWABLE_WINDOW) {
                /*
                 ** Drawable is an X Window.
                 */
                VisualID vid;

                pWin = (WindowPtr) pDraw;
                vid = wVisual(pWin);

                new_reply.writeVid =
                    (glxc->pFBConfig ? glxc->pFBConfig->id : vid);
                new_reply.writeType = GLX_WINDOW_TYPE;

                /*
                 ** Check if window and context are similar.
                 */
                if ((vid != glxc->pVisual->vid) ||
                    (pWin->drawable.pScreen != glxc->pScreen)) {
                    client->errorValue = drawId;
                    return BadMatch;
                }

                from_screen = to_screen = pWin->drawable.pScreen->myNum;

            }
            else {
                /*
                 ** An X Pixmap is not allowed as a parameter (a GLX Pixmap
                 ** is, but it must first be created with glxCreateGLXPixmap).
                 */
                client->errorValue = drawId;
                return __glXBadDrawable;
            }
        }

        if (!pDraw) {
            dixLookupResourceByType((void **) &pGlxPixmap, drawId,
                                    __glXPixmapRes, NullClient,
                                    DixUnknownAccess);
            if (pGlxPixmap) {
                /*
                 ** Check if pixmap and context are similar.
                 */
                if (pGlxPixmap->pScreen != glxc->pScreen ||
                    pGlxPixmap->pGlxVisual != glxc->pGlxVisual) {
                    client->errorValue = drawId;
                    return BadMatch;
                }
                pDraw = pGlxPixmap->pDraw;

                new_reply.writeVid = (glxc->pFBConfig ? glxc->pFBConfig->id :
                                      pGlxPixmap->pGlxVisual->vid);

                new_reply.writeType = GLX_PIXMAP_TYPE;

                from_screen = to_screen = pGlxPixmap->pScreen->myNum;

            }
        }

        if (!pDraw && __GLX_IS_VERSION_SUPPORTED(1, 3)) {
            dixLookupResourceByType((void **) &pGlxWindow, drawId,
                                    __glXWindowRes, NullClient,
                                    DixUnknownAccess);
            if (pGlxWindow) {
                /*
                 ** Drawable is a GLXWindow.
                 **
                 ** Check if GLX window and context are similar.
                 */
                if (pGlxWindow->pScreen != glxc->pScreen ||
                    pGlxWindow->pGlxFBConfig != glxc->pFBConfig) {
                    client->errorValue = drawId;
                    return BadMatch;
                }

                pDraw = pGlxWindow->pDraw;
                new_reply.writeVid = pGlxWindow->pGlxFBConfig->id;
                new_reply.writeType = GLX_GLXWINDOW_TYPE;
            }

        }

        if (!pDraw && __GLX_IS_VERSION_SUPPORTED(1, 3)) {
            dixLookupResourceByType((void **) &pGlxPbuffer, drawId,
                                    __glXPbufferRes, NullClient,
                                    DixUnknownAccess);
            if (pGlxPbuffer) {
                if (pGlxPbuffer->pScreen != glxc->pScreen ||
                    pGlxPbuffer->pFBConfig != glxc->pFBConfig) {
                    client->errorValue = drawId;
                    return BadMatch;
                }

                pDraw = (DrawablePtr) pGlxPbuffer;
                new_reply.writeVid = pGlxPbuffer->pFBConfig->id;
                new_reply.writeType = GLX_PBUFFER_TYPE;
            }
        }

        if (!pDraw) {
            /*
             ** Drawable is not a Window , GLXWindow or a GLXPixmap.
             */
            client->errorValue = drawId;
            return __glXBadDrawable;
        }

    }
    else {
        pDraw = 0;
    }

    if (readId != None && readId != drawId) {
        rc = dixLookupDrawable(&pReadDraw, readId, client, 0, DixReadAccess);
        if (rc == Success) {
            if (pReadDraw->type == DRAWABLE_WINDOW) {
                /*
                 ** Drawable is an X Window.
                 */
                VisualID vid;

                pReadWin = (WindowPtr) pDraw;
                vid = wVisual(pReadWin);

                new_reply.readVid =
                    (glxc->pFBConfig ? glxc->pFBConfig->id : vid);
                new_reply.readType = GLX_WINDOW_TYPE;

                /*
                 ** Check if window and context are similar.
                 */
                if ((vid != glxc->pVisual->vid) ||
                    (pReadWin->drawable.pScreen != glxc->pScreen)) {
                    client->errorValue = readId;
                    return BadMatch;
                }

            }
            else {

                /*
                 ** An X Pixmap is not allowed as a parameter (a GLX Pixmap
                 ** is, but it must first be created with glxCreateGLXPixmap).
                 */
                client->errorValue = readId;
                return __glXBadDrawable;
            }
        }

        if (!pReadDraw) {
            dixLookupResourceByType((void **) &pReadGlxPixmap, readId,
                                    __glXPixmapRes, NullClient,
                                    DixUnknownAccess);
            if (pReadGlxPixmap) {
                /*
                 ** Check if pixmap and context are similar.
                 */
                if (pReadGlxPixmap->pScreen != glxc->pScreen ||
                    pReadGlxPixmap->pGlxVisual != glxc->pGlxVisual) {
                    client->errorValue = readId;
                    return BadMatch;
                }
                pReadDraw = pReadGlxPixmap->pDraw;

                new_reply.readVid = (glxc->pFBConfig ? glxc->pFBConfig->id :
                                     pReadGlxPixmap->pGlxVisual->vid);
                new_reply.readType = GLX_PIXMAP_TYPE;

            }
        }

        if (!pReadDraw && __GLX_IS_VERSION_SUPPORTED(1, 3)) {
            dixLookupResourceByType((void **) &pGlxReadWindow, readId,
                                    __glXWindowRes, NullClient,
                                    DixUnknownAccess);
            if (pGlxReadWindow) {
                /*
                 ** Drawable is a GLXWindow.
                 **
                 ** Check if GLX window and context are similar.
                 */
                if (pGlxReadWindow->pScreen != glxc->pScreen ||
                    pGlxReadWindow->pGlxFBConfig != glxc->pFBConfig) {
                    client->errorValue = readId;
                    return BadMatch;
                }

                pReadDraw = pGlxReadWindow->pDraw;
                new_reply.readVid = pGlxReadWindow->pGlxFBConfig->id;
                new_reply.readType = GLX_GLXWINDOW_TYPE;
            }
        }

        if (!pReadDraw && __GLX_IS_VERSION_SUPPORTED(1, 3)) {
            dixLookupResourceByType((void **) &pGlxReadPbuffer, readId,
                                    __glXPbufferRes, NullClient,
                                    DixUnknownAccess);
            if (pGlxReadPbuffer) {
                if (pGlxReadPbuffer->pScreen != glxc->pScreen ||
                    pGlxReadPbuffer->pFBConfig != glxc->pFBConfig) {
                    client->errorValue = drawId;
                    return BadMatch;
                }

                pReadDraw = (DrawablePtr) pGlxReadPbuffer;
                new_reply.readVid = pGlxReadPbuffer->pFBConfig->id;
                new_reply.readType = GLX_PBUFFER_TYPE;
            }
        }

        if (!pReadDraw) {
            /*
             ** Drawable is neither a Window nor a GLXPixmap.
             */
            client->errorValue = readId;
            return __glXBadDrawable;
        }

    }
    else {
        pReadDraw = pDraw;
        pReadGlxPixmap = pGlxPixmap;
        pReadWin = pWin;
        new_reply.readVid = new_reply.writeVid;
        new_reply.readType = new_reply.writeType;
    }

    if (prevglxc) {

        if (prevglxc->pGlxPixmap) {
            /*
             ** The previous drawable was a glx pixmap, release it.
             */
            prevglxc->pGlxPixmap->refcnt--;
            __glXFreeGLXPixmap(prevglxc->pGlxPixmap);
            prevglxc->pGlxPixmap = 0;
        }

        if (prevglxc->pGlxReadPixmap) {
            /*
             ** The previous drawable was a glx pixmap, release it.
             */
            prevglxc->pGlxReadPixmap->refcnt--;
            __glXFreeGLXPixmap(prevglxc->pGlxReadPixmap);
            prevglxc->pGlxReadPixmap = 0;
        }

        if (prevglxc->pGlxWindow) {
            /*
             ** The previous drawable was a glx window, release it.
             */
            prevglxc->pGlxWindow->refcnt--;
            __glXFreeGLXWindow(prevglxc->pGlxWindow);
            prevglxc->pGlxWindow = 0;
        }

        if (prevglxc->pGlxReadWindow) {
            /*
             ** The previous drawable was a glx window, release it.
             */
            prevglxc->pGlxReadWindow->refcnt--;
            __glXFreeGLXWindow(prevglxc->pGlxReadWindow);
            prevglxc->pGlxReadWindow = 0;
        }

        if (prevglxc->pGlxPbuffer) {
            /*
             ** The previous drawable was a glx Pbuffer, release it.
             */
            prevglxc->pGlxPbuffer->refcnt--;
            __glXFreeGLXPbuffer(prevglxc->pGlxPbuffer);
            prevglxc->pGlxPbuffer = 0;
        }

        if (prevglxc->pGlxReadPbuffer) {
            /*
             ** The previous drawable was a glx Pbuffer, release it.
             */
            prevglxc->pGlxReadPbuffer->refcnt--;
            __glXFreeGLXPbuffer(prevglxc->pGlxReadPbuffer);
            prevglxc->pGlxReadPbuffer = 0;
        }

        ChangeCurrentContext(cl, glxc, tag);
        ChangeCurrentContext(cl, glxc, tag);
        StopUsingContext(prevglxc);
    }
    else {
        tag = AddCurrentContext(cl, glxc, pDraw);
    }
    if (glxc) {

        glxc->pGlxPixmap = pGlxPixmap;
        glxc->pGlxReadPixmap = pReadGlxPixmap;
        glxc->pGlxWindow = pGlxWindow;
        glxc->pGlxReadWindow = pGlxReadWindow;
        glxc->pGlxPbuffer = pGlxPbuffer;
        glxc->pGlxReadPbuffer = pGlxReadPbuffer;

        if (pGlxPixmap) {
            pGlxPixmap->refcnt++;
        }

        if (pReadGlxPixmap) {
            pReadGlxPixmap->refcnt++;
        }

        if (pGlxWindow) {
            pGlxWindow->refcnt++;
        }

        if (pGlxReadWindow) {
            pGlxReadWindow->refcnt++;
        }

        if (pGlxPbuffer) {
            pGlxPbuffer->refcnt++;
        }

        if (pGlxReadPbuffer) {
            pGlxReadPbuffer->refcnt++;
        }

        StartUsingContext(cl, glxc);
        new_reply.contextTag = tag;
    }
    else {
        new_reply.contextTag = 0;
    }

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;

        if (pDraw && new_reply.writeType != GLX_PBUFFER_TYPE) {
            dixLookupResourceByClass((void **) &pXinDraw,
                                     pDraw->id, XRC_DRAWABLE,
                                     client, DixReadAccess);
        }

        if (pReadDraw && pReadDraw != pDraw &&
            new_reply.readType != GLX_PBUFFER_TYPE) {
            dixLookupResourceByClass((void **) &pXinReadDraw,
                                     pReadDraw->id, XRC_DRAWABLE,
                                     client, DixReadAccess);
        }
        else {
            pXinReadDraw = pXinDraw;
        }
    }
#endif

    /* send the MakeCurrent request to all required
     * back-end servers.
     */
    for (s = from_screen; s <= to_screen; s++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = GetBackEndDisplay(cl, s);
        unsigned int be_draw = None;
        unsigned int be_read_draw = None;

        if (pGlxPixmap) {
            be_draw = pGlxPixmap->be_xids[s];
        }
        else if (pGlxPbuffer) {
            be_draw = pGlxPbuffer->be_xids[s];
        }
#ifdef PANORAMIX
        else if (pXinDraw) {
            dixLookupWindow(&pWin, pXinDraw->info[s].id, client, DixReadAccess);
        }
#endif
        else if (pGlxWindow) {
            pWin = (WindowPtr) pGlxWindow->pDraw;
        }

        if (pWin && be_draw == None) {
            be_draw = (unsigned int) (DMX_GET_WINDOW_PRIV(pWin))->window;
            if (!be_draw) {
                /* it might be that the window did not created yet on the */
                /* back-end server (lazy window creation option), force   */
                /* creation of the window */
                dmxCreateAndRealizeWindow(pWin, TRUE);
                be_draw = (unsigned int) (DMX_GET_WINDOW_PRIV(pWin))->window;
            }
        }

        /*
         * Before sending the MakeCurrent request - sync the
         * X11 connection to the back-end servers to make sure
         * that drawable is already created
         */
        dmxSync(dmxScreen, 1);

        if (drawId == readId) {
            LockDisplay(dpy);
            GetReq(GLXMakeCurrent, be_req);
            be_req->reqType = dmxScreen->glxMajorOpcode;
            be_req->glxCode = X_GLXMakeCurrent;
            be_req->drawable = be_draw;
            be_req->context =
                (unsigned int) (glxc ? glxc->real_ids[s - from_screen] : 0);
            be_req->oldContextTag = GetCurrentBackEndTag(cl, tag, s);
            if (!_XReply(dpy, (xReply *) &be_reply, 0, False)) {

                /* The make current failed */
                UnlockDisplay(dpy);
                SyncHandle();
                return (BE_TO_CLIENT_ERROR(dmxLastErrorEvent.error_code));
            }

            UnlockDisplay(dpy);
            SyncHandle();

            SetCurrentBackEndTag(cl, tag, s, be_reply.contextTag);
        }
        else {

            if (pReadGlxPixmap) {
                be_read_draw = pReadGlxPixmap->be_xids[s];
            }
            else if (pGlxReadPbuffer) {
                be_read_draw = pGlxReadPbuffer->be_xids[s];
            }
#ifdef PANORAMIX
            else if (pXinReadDraw) {
                dixLookupWindow(&pReadWin, pXinReadDraw->info[s].id, client,
                                DixReadAccess);
            }
#endif
            else if (pGlxReadWindow) {
                pReadWin = (WindowPtr) pGlxReadWindow->pDraw;
            }

            if (pReadWin && be_read_draw == None) {
                be_read_draw =
                    (unsigned int) (DMX_GET_WINDOW_PRIV(pReadWin))->window;
                if (!be_read_draw) {
                    /* it might be that the window did not created yet on the */
                    /* back-end server (lazy window creation option), force   */
                    /* creation of the window */
                    dmxCreateAndRealizeWindow(pReadWin, TRUE);
                    be_read_draw =
                        (unsigned int) (DMX_GET_WINDOW_PRIV(pReadWin))->window;
                    dmxSync(dmxScreen, 1);
                }
            }

            if (__GLX_IS_VERSION_SUPPORTED(1, 3)) {
                LockDisplay(dpy);
                GetReq(GLXMakeContextCurrent, be_new_req);
                be_new_req->reqType = dmxScreen->glxMajorOpcode;
                be_new_req->glxCode = X_GLXMakeContextCurrent;
                be_new_req->drawable = be_draw;
                be_new_req->readdrawable = be_read_draw;
                be_new_req->context =
                    (unsigned int) (glxc ? glxc->real_ids[s - from_screen] : 0);
                be_new_req->oldContextTag = GetCurrentBackEndTag(cl, tag, s);
                if (!_XReply(dpy, (xReply *) &be_new_reply, 0, False)) {

                    /* The make current failed */
                    UnlockDisplay(dpy);
                    SyncHandle();
                    return (BE_TO_CLIENT_ERROR(dmxLastErrorEvent.error_code));
                }

                UnlockDisplay(dpy);
                SyncHandle();

                SetCurrentBackEndTag(cl, tag, s, be_new_reply.contextTag);
            }
            else if (glxIsExtensionSupported("GLX_SGI_make_current_read")) {
                xGLXMakeCurrentReadSGIReq *ext_req;
                xGLXVendorPrivateWithReplyReq *vpreq;
                xGLXMakeCurrentReadSGIReply ext_reply;

                LockDisplay(dpy);
                GetReqExtra(GLXVendorPrivateWithReply,
                            sz_xGLXMakeCurrentReadSGIReq -
                            sz_xGLXVendorPrivateWithReplyReq, vpreq);
                ext_req = (xGLXMakeCurrentReadSGIReq *) vpreq;
                ext_req->reqType = dmxScreen->glxMajorOpcode;
                ext_req->glxCode = X_GLXVendorPrivateWithReply;
                ext_req->vendorCode = X_GLXvop_MakeCurrentReadSGI;
                ext_req->drawable = be_draw;
                ext_req->readable = be_read_draw;
                ext_req->context =
                    (unsigned int) (glxc ? glxc->real_ids[s - from_screen] : 0);
                ext_req->oldContextTag = GetCurrentBackEndTag(cl, tag, s);
                if (!_XReply(dpy, (xReply *) &ext_reply, 0, False)) {

                    /* The make current failed */
                    UnlockDisplay(dpy);
                    SyncHandle();
                    return (BE_TO_CLIENT_ERROR(dmxLastErrorEvent.error_code));
                }

                UnlockDisplay(dpy);
                SyncHandle();

                SetCurrentBackEndTag(cl, tag, s, ext_reply.contextTag);

            }
            else {
                return BadMatch;
            }
        }

        XFlush(dpy);
    }

    if (client->swapped) {
        __glXSwapMakeCurrentReply(client, &new_reply);
    }
    else {
        WriteToClient(client, sz_xGLXMakeContextCurrentReply, &new_reply);
    }

    return Success;
}

int
__glXMakeCurrent(__GLXclientState * cl, GLbyte * pc)
{
    xGLXMakeCurrentReq *req = (xGLXMakeCurrentReq *) pc;

    return (MakeCurrent(cl, req->drawable, req->drawable,
                        req->context, req->oldContextTag));
}

int
__glXMakeContextCurrent(__GLXclientState * cl, GLbyte * pc)
{
    xGLXMakeContextCurrentReq *req = (xGLXMakeContextCurrentReq *) pc;

    return (MakeCurrent(cl, req->drawable, req->readdrawable,
                        req->context, req->oldContextTag));
}

int
__glXMakeCurrentReadSGI(__GLXclientState * cl, GLbyte * pc)
{
    xGLXMakeCurrentReadSGIReq *req = (xGLXMakeCurrentReadSGIReq *) pc;

    return (MakeCurrent(cl, req->drawable, req->readable,
                        req->context, req->oldContextTag));
}

int
__glXIsDirect(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXIsDirectReq *req = (xGLXIsDirectReq *) pc;
    xGLXIsDirectReply reply;
    __GLXcontext *glxc;

    /*
     ** Find the GL context.
     */
    dixLookupResourceByType((void **) &glxc, req->context, __glXContextRes,
                            NullClient, DixUnknownAccess);
    if (!glxc) {
        client->errorValue = req->context;
        return __glXBadContext;
    }

    reply = (xGLXIsDirectReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .isDirect = 0
    };

    if (client->swapped) {
        __glXSwapIsDirectReply(client, &reply);
    }
    else {
        WriteToClient(client, sz_xGLXIsDirectReply, &reply);
    }

    return Success;
}

int
__glXQueryVersion(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;

/*    xGLXQueryVersionReq *req = (xGLXQueryVersionReq *) pc; */

    xGLXQueryVersionReply reply = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
    /*
     ** Server should take into consideration the version numbers sent by the
     ** client if it wants to work with older clients; however, in this
     ** implementation the server just returns its version number.
     */
        .majorVersion = __glXVersionMajor,
        .minorVersion = __glXVersionMinor
    };

    if (client->swapped) {
        __glXSwapQueryVersionReply(client, &reply);
    }
    else {
        WriteToClient(client, sz_xGLXQueryVersionReply, &reply);
    }
    return Success;
}

int
__glXWaitGL(__GLXclientState * cl, GLbyte * pc)
{
    xGLXWaitGLReq *req = (xGLXWaitGLReq *) pc;
    xGLXWaitGLReq *be_req = (xGLXWaitGLReq *) pc;
    int from_screen = 0;
    int to_screen = 0;
    int s;
    __GLXcontext *glxc = NULL;

    if (req->contextTag != 0) {
        glxc = __glXLookupContextByTag(cl, req->contextTag);
        if (glxc) {
            from_screen = to_screen = glxc->pScreen->myNum;
        }
    }

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    for (s = from_screen; s <= to_screen; s++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = GetBackEndDisplay(cl, s);

        LockDisplay(dpy);
        GetReq(GLXWaitGL, be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = X_GLXWaitGL;
        be_req->contextTag =
            (glxc ? GetCurrentBackEndTag(cl, req->contextTag, s) : 0);
        UnlockDisplay(dpy);
        SyncHandle();

        XSync(dpy, False);
    }

    return Success;
}

int
__glXWaitX(__GLXclientState * cl, GLbyte * pc)
{
    xGLXWaitXReq *req = (xGLXWaitXReq *) pc;
    xGLXWaitXReq *be_req;
    int from_screen = 0;
    int to_screen = 0;
    int s;
    __GLXcontext *glxc = NULL;

    if (req->contextTag != 0) {
        glxc = __glXLookupContextByTag(cl, req->contextTag);
        if (glxc) {
            from_screen = to_screen = glxc->pScreen->myNum;
        }
    }

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    for (s = from_screen; s <= to_screen; s++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = GetBackEndDisplay(cl, s);

        dmxSync(dmxScreen, 1);

        LockDisplay(dpy);
        GetReq(GLXWaitX, be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = X_GLXWaitX;
        be_req->contextTag =
            (glxc ? GetCurrentBackEndTag(cl, req->contextTag, s) : 0);
        UnlockDisplay(dpy);
        SyncHandle();

        XFlush(dpy);
    }

    return Success;
}

int
__glXCopyContext(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCopyContextReq *be_req;
    xGLXCopyContextReq *req = (xGLXCopyContextReq *) pc;
    GLXContextID source = req->source;
    GLXContextID dest = req->dest;
    GLXContextTag tag = req->contextTag;
    unsigned long mask = req->mask;
    __GLXcontext *src, *dst;
    int s;
    int from_screen = 0;
    int to_screen = 0;

    /*
     ** Check that each context exists.
     */
    dixLookupResourceByType((void **) &src, source, __glXContextRes,
                            NullClient, DixUnknownAccess);
    if (!src) {
        client->errorValue = source;
        return __glXBadContext;
    }
    dixLookupResourceByType((void **) &dst, dest, __glXContextRes,
                            NullClient, DixUnknownAccess);
    if (!dst) {
        client->errorValue = dest;
        return __glXBadContext;
    }

    /*
     ** They must be in the same address space, and same screen.
     */
    if (src->pGlxScreen != dst->pGlxScreen) {
        client->errorValue = source;
        return BadMatch;
    }

    /*
     ** The destination context must not be current for any client.
     */
    if (dst->isCurrent) {
        client->errorValue = dest;
        return BadAccess;
    }

    if (tag) {
        __GLXcontext *tagcx = __glXLookupContextByTag(cl, tag);

        if (!tagcx) {
            return __glXBadContextTag;
        }
        if (tagcx != src) {
            /*
             ** This would be caused by a faulty implementation of the client
             ** library.
             */
            return BadMatch;
        }
    }

    from_screen = to_screen = src->pScreen->myNum;

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    for (s = from_screen; s <= to_screen; s++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = GetBackEndDisplay(cl, s);

        LockDisplay(dpy);
        GetReq(GLXCopyContext, be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = X_GLXCopyContext;
        be_req->source = (unsigned int) src->real_ids[s - from_screen];
        be_req->dest = (unsigned int) dst->real_ids[s - from_screen];
        be_req->mask = mask;
        be_req->contextTag =
            (tag ? GetCurrentBackEndTag(cl, req->contextTag, s) : 0);
        UnlockDisplay(dpy);
        SyncHandle();
    }

    return Success;
}

int
__glXGetVisualConfigs(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXGetVisualConfigsReq *req = (xGLXGetVisualConfigsReq *) pc;
    xGLXGetVisualConfigsReply reply;
    __GLXscreenInfo *pGlxScreen;
    __GLXvisualConfig *pGlxVisual;
    CARD32 buf[__GLX_TOTAL_CONFIG];
    unsigned int screen;
    int i, p;

    screen = req->screen;
    if (screen >= screenInfo.numScreens) {
        /* The client library must send a valid screen number. */
        client->errorValue = screen;
        return BadValue;
    }
    pGlxScreen = &__glXActiveScreens[screen];

    reply = (xGLXGetVisualConfigsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .numVisuals = pGlxScreen->numGLXVisuals,
        .numProps = __GLX_TOTAL_CONFIG,
        .length = (pGlxScreen->numGLXVisuals * __GLX_SIZE_CARD32 *
                    __GLX_TOTAL_CONFIG) >> 2
    };

    WriteToClient(client, sz_xGLXGetVisualConfigsReply, &reply);

    for (i = 0; i < pGlxScreen->numVisuals; i++) {
        pGlxVisual = &pGlxScreen->pGlxVisual[i];
        if (!pGlxScreen->isGLXvis[i] || pGlxVisual->vid == 0) {
            /* not a usable visual */
            continue;
        }
        p = 0;
        buf[p++] = pGlxVisual->vid;
        buf[p++] = pGlxVisual->class;
        buf[p++] = pGlxVisual->rgba;

        buf[p++] = pGlxVisual->redSize;
        buf[p++] = pGlxVisual->greenSize;
        buf[p++] = pGlxVisual->blueSize;
        buf[p++] = pGlxVisual->alphaSize;
        buf[p++] = pGlxVisual->accumRedSize;
        buf[p++] = pGlxVisual->accumGreenSize;
        buf[p++] = pGlxVisual->accumBlueSize;
        buf[p++] = pGlxVisual->accumAlphaSize;

        buf[p++] = pGlxVisual->doubleBuffer;
        buf[p++] = pGlxVisual->stereo;

        buf[p++] = pGlxVisual->bufferSize;
        buf[p++] = pGlxVisual->depthSize;
        buf[p++] = pGlxVisual->stencilSize;
        buf[p++] = pGlxVisual->auxBuffers;
        buf[p++] = pGlxVisual->level;
        /*
         ** Add token/value pairs for extensions.
         */
        buf[p++] = GLX_VISUAL_CAVEAT_EXT;
        buf[p++] = pGlxVisual->visualRating;
        buf[p++] = GLX_TRANSPARENT_TYPE_EXT;
        buf[p++] = pGlxVisual->transparentPixel;
        buf[p++] = GLX_TRANSPARENT_RED_VALUE_EXT;
        buf[p++] = pGlxVisual->transparentRed;
        buf[p++] = GLX_TRANSPARENT_GREEN_VALUE_EXT;
        buf[p++] = pGlxVisual->transparentGreen;
        buf[p++] = GLX_TRANSPARENT_BLUE_VALUE_EXT;
        buf[p++] = pGlxVisual->transparentBlue;
        buf[p++] = GLX_TRANSPARENT_ALPHA_VALUE_EXT;
        buf[p++] = pGlxVisual->transparentAlpha;
        buf[p++] = GLX_TRANSPARENT_INDEX_VALUE_EXT;
        buf[p++] = pGlxVisual->transparentIndex;
        buf[p++] = GLX_SAMPLES_SGIS;
        buf[p++] = pGlxVisual->multiSampleSize;
        buf[p++] = GLX_SAMPLE_BUFFERS_SGIS;
        buf[p++] = pGlxVisual->nMultiSampleBuffers;
        buf[p++] = GLX_VISUAL_SELECT_GROUP_SGIX;
        buf[p++] = pGlxVisual->visualSelectGroup;

        WriteToClient(client, __GLX_SIZE_CARD32 * __GLX_TOTAL_CONFIG, buf);
    }
    return Success;
}

/*
** Create a GLX Pixmap from an X Pixmap.
*/
static int
CreateGLXPixmap(__GLXclientState * cl,
                VisualID visual, GLXFBConfigID fbconfigId,
                int screenNum, XID pixmapId, XID glxpixmapId)
{
    ClientPtr client = cl->client;
    xGLXCreateGLXPixmapReq *be_req;
    xGLXCreatePixmapReq *be_new_req;
    DrawablePtr pDraw;
    ScreenPtr pScreen;
    VisualPtr pVisual;
    __GLXpixmap *pGlxPixmap;
    __GLXscreenInfo *pGlxScreen;
    __GLXvisualConfig *pGlxVisual;
    __GLXFBConfig *pFBConfig;
    int i, s, rc;
    int from_screen, to_screen;

#ifdef PANORAMIX
    PanoramiXRes *pXinDraw = NULL;
#endif

    rc = dixLookupDrawable(&pDraw, pixmapId, client, M_DRAWABLE_PIXMAP,
                           DixAddAccess);
    if (rc != Success)
        return rc;

    /*
     ** Check if screen of visual matches screen of pixmap.
     */
    pScreen = pDraw->pScreen;
    if (screenNum != pScreen->myNum) {
        return BadMatch;
    }

    if (fbconfigId == 0 && visual == 0) {
        return BadValue;
    }

    if (fbconfigId != None) {
        pFBConfig = glxLookupFBConfig(fbconfigId);
        if (!pFBConfig) {
            client->errorValue = fbconfigId;
            return BadValue;
        }
        visual = pFBConfig->associatedVisualId;
    }
    else {
        pFBConfig = NULL;
    }

    if (visual != None) {
        /*
         ** Find the VisualRec for this visual.
         */
        pVisual = pScreen->visuals;
        for (i = 0; i < pScreen->numVisuals; i++, pVisual++) {
            if (pVisual->vid == visual) {
                break;
            }
        }
        if (i == pScreen->numVisuals) {
            client->errorValue = visual;
            return BadValue;
        }
        /*
         ** Check if depth of visual matches depth of pixmap.
         */
        if (pVisual->nplanes != pDraw->depth) {
            client->errorValue = visual;
            return BadMatch;
        }

        /*
         ** Get configuration of the visual.
         */
        pGlxScreen = &__glXActiveScreens[screenNum];
        pGlxVisual = pGlxScreen->pGlxVisual;
        for (i = 0; i < pGlxScreen->numVisuals; i++, pGlxVisual++) {
            if (pGlxVisual->vid == visual) {
                break;
            }
        }
        if (i == pGlxScreen->numVisuals) {
            /*
             ** Visual not support on this screen by this OpenGL implementation.
             */
            client->errorValue = visual;
            return BadValue;
        }

        /* find the FBConfig for that visual (if any) */
        if (pFBConfig == NULL) {
            pFBConfig = glxLookupFBConfigByVID(visual);

            if (pFBConfig == NULL) {
                /*
                 * visual does not have an FBConfig ???
                 client->errorValue = visual;
                 return BadValue;
                 */
            }
        }
    }
    else {
        pVisual = NULL;
        pGlxVisual = NULL;
        pGlxScreen = &__glXActiveScreens[pDraw->pScreen->myNum];
    }

    pGlxPixmap = (__GLXpixmap *) malloc(sizeof(__GLXpixmap));
    if (!pGlxPixmap) {
        return BadAlloc;
    }
    pGlxPixmap->be_xids = xallocarray(screenInfo.numScreens, sizeof(XID));
    if (!pGlxPixmap->be_xids) {
        free(pGlxPixmap);
        return BadAlloc;
    }

    pGlxPixmap->pDraw = pDraw;
    pGlxPixmap->pGlxScreen = pGlxScreen;
    pGlxPixmap->pGlxVisual = pGlxVisual;
    pGlxPixmap->pFBConfig = pFBConfig;
    pGlxPixmap->pScreen = pScreen;
    pGlxPixmap->idExists = True;
    pGlxPixmap->refcnt = 0;

    /*
     ** Bump the ref count on the X pixmap so it won't disappear.
     */
    ((PixmapPtr) pDraw)->refcnt++;

    /*
     * send the request to the back-end server(s)
     */
    from_screen = to_screen = screenNum;
#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;

        dixLookupResourceByClass((void **) &pXinDraw,
                                 pDraw->id, XRC_DRAWABLE,
                                 client, DixReadAccess);
    }
#endif

    for (s = from_screen; s <= to_screen; s++) {

        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = GetBackEndDisplay(cl, s);
        Pixmap be_pixmap;
        DrawablePtr pRealDraw = pDraw;

#ifdef PANORAMIX
        if (pXinDraw) {
            dixLookupDrawable(&pRealDraw, pXinDraw->info[s].id, client, 0,
                              DixAddAccess);
        }
#endif

        be_pixmap = (DMX_GET_PIXMAP_PRIV((PixmapPtr) pRealDraw))->pixmap;

        /* make sure pixmap already created on back-end */
        dmxSync(dmxScreen, 1);

        if (pFBConfig && __GLX_IS_VERSION_SUPPORTED(1, 3)) {
            __GLXFBConfig *be_FBConfig =
                glxLookupBackEndFBConfig(pFBConfig->id, s);

            LockDisplay(dpy);
            pGlxPixmap->be_xids[s] = XAllocID(dpy);
            GetReq(GLXCreatePixmap, be_new_req);
            be_new_req->reqType = dmxScreen->glxMajorOpcode;
            be_new_req->glxCode = X_GLXCreatePixmap;
            be_new_req->screen = DefaultScreen(dpy);
            be_new_req->fbconfig = be_FBConfig->id;
            be_new_req->pixmap = (unsigned int) be_pixmap;
            be_new_req->glxpixmap = (unsigned int) pGlxPixmap->be_xids[s];
            be_new_req->numAttribs = 0;
            UnlockDisplay(dpy);
            SyncHandle();
        }
        else if (pFBConfig && glxIsExtensionSupported("GLX_SGIX_fbconfig")) {
            __GLXFBConfig *be_FBConfig =
                glxLookupBackEndFBConfig(pFBConfig->id, s);
            xGLXCreateGLXPixmapWithConfigSGIXReq *ext_req;
            xGLXVendorPrivateReq *vpreq;

            LockDisplay(dpy);
            pGlxPixmap->be_xids[s] = XAllocID(dpy);
            GetReqExtra(GLXVendorPrivate,
                        sz_xGLXCreateGLXPixmapWithConfigSGIXReq -
                        sz_xGLXVendorPrivateReq, vpreq);
            ext_req = (xGLXCreateGLXPixmapWithConfigSGIXReq *) vpreq;
            ext_req->reqType = dmxScreen->glxMajorOpcode;
            ext_req->glxCode = X_GLXVendorPrivate;
            ext_req->vendorCode = X_GLXvop_CreateGLXPixmapWithConfigSGIX;
            ext_req->screen = DefaultScreen(dpy);
            ext_req->fbconfig = be_FBConfig->id;
            ext_req->pixmap = (unsigned int) be_pixmap;
            ext_req->glxpixmap = (unsigned int) pGlxPixmap->be_xids[s];
            UnlockDisplay(dpy);
            SyncHandle();
        }
        else if (pGlxVisual) {
            LockDisplay(dpy);
            pGlxPixmap->be_xids[s] = XAllocID(dpy);
            GetReq(GLXCreateGLXPixmap, be_req);
            be_req->reqType = dmxScreen->glxMajorOpcode;
            be_req->glxCode = X_GLXCreateGLXPixmap;
            be_req->screen = DefaultScreen(dpy);
            be_req->visual =
                (unsigned int) glxMatchGLXVisualInConfigList(pGlxVisual,
                                                             dmxScreen->
                                                             glxVisuals,
                                                             dmxScreen->
                                                             numGlxVisuals);
            be_req->pixmap = (unsigned int) be_pixmap;
            be_req->glxpixmap = (unsigned int) pGlxPixmap->be_xids[s];
            UnlockDisplay(dpy);
            SyncHandle();
        }
        else {
            client->errorValue = (visual ? visual : fbconfigId);
            free(pGlxPixmap->be_xids);
            free(pGlxPixmap);
            return BadValue;
        }

        XFlush(dpy);
    }

    if (!(AddResource(glxpixmapId, __glXPixmapRes, pGlxPixmap)))
        return BadAlloc;

    return Success;
}

int
__glXCreateGLXPixmap(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreateGLXPixmapReq *req = (xGLXCreateGLXPixmapReq *) pc;

    return (CreateGLXPixmap(cl, req->visual, None,
                            req->screen, req->pixmap, req->glxpixmap));
}

int
__glXCreatePixmap(__GLXclientState * cl, GLbyte * pc)
{
    xGLXCreatePixmapReq *req = (xGLXCreatePixmapReq *) pc;

    return (CreateGLXPixmap(cl, None, req->fbconfig,
                            req->screen, req->pixmap, req->glxpixmap));
}

int
__glXDestroyGLXPixmap(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyGLXPixmapReq *req = (xGLXDestroyGLXPixmapReq *) pc;
    XID glxpixmap = req->glxpixmap;
    __GLXpixmap *pGlxPixmap;
    int s;
    int from_screen, to_screen;

    /*
     ** Check if it's a valid GLX pixmap.
     */
    dixLookupResourceByType((void **) &pGlxPixmap, glxpixmap,
                            __glXPixmapRes, NullClient, DixUnknownAccess);
    if (!pGlxPixmap) {
        client->errorValue = glxpixmap;
        return __glXBadPixmap;
    }
    FreeResource(glxpixmap, FALSE);

    /*
     * destroy the pixmap on the back-end server(s).
     */
    from_screen = to_screen = pGlxPixmap->pDraw->pScreen->myNum;
#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    for (s = from_screen; s <= to_screen; s++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = GetBackEndDisplay(cl, s);

        /* make sure pixmap exist in back-end */
        dmxSync(dmxScreen, 1);

        LockDisplay(dpy);
        GetReq(GLXDestroyGLXPixmap, req);
        req->reqType = dmxScreen->glxMajorOpcode;
        req->glxCode = X_GLXDestroyGLXPixmap;
        req->glxpixmap = (unsigned int) pGlxPixmap->be_xids[s];
        UnlockDisplay(dpy);
        SyncHandle();
    }

    return Success;
}

/*****************************************************************************/

/*
** NOTE: There is no portable implementation for swap buffers as of
** this time that is of value.  Consequently, this code must be
** implemented by somebody other than SGI.
*/
int
__glXDoSwapBuffers(__GLXclientState * cl, XID drawId, GLXContextTag tag)
{
    ClientPtr client = cl->client;
    DrawablePtr pDraw;
    xGLXSwapBuffersReq *be_req;
    WindowPtr pWin = NULL;
    __GLXpixmap *pGlxPixmap = NULL;
    __GLXcontext *glxc = NULL;

#ifdef PANORAMIX
    PanoramiXRes *pXinDraw = NULL;
#endif
    __glXWindow *pGlxWindow = NULL;
    int from_screen = 0;
    int to_screen = 0;
    int s, rc;

    /*
     ** Check that the GLX drawable is valid.
     */
    rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixWriteAccess);
    if (rc == Success) {
        from_screen = to_screen = pDraw->pScreen->myNum;

        if (pDraw->type == DRAWABLE_WINDOW) {
            /*
             ** Drawable is an X window.
             */
            pWin = (WindowPtr) pDraw;
        }
        else {
            /*
             ** Drawable is an X pixmap, which is not allowed.
             */
            client->errorValue = drawId;
            return __glXBadDrawable;
        }
    }

    if (!pDraw) {
        dixLookupResourceByType((void **) &pGlxPixmap, drawId,
                                __glXPixmapRes, NullClient, DixUnknownAccess);
        if (pGlxPixmap) {
            /*
             ** Drawable is a GLX pixmap.
             */
            pDraw = pGlxPixmap->pDraw;
            from_screen = to_screen = pGlxPixmap->pScreen->myNum;
        }
    }

    if (!pDraw && __GLX_IS_VERSION_SUPPORTED(1, 3)) {
        dixLookupResourceByType((void **) &pGlxWindow, drawId,
                                __glXWindowRes, NullClient, DixUnknownAccess);
        if (pGlxWindow) {
            /*
             ** Drawable is a GLXWindow.
             */
            pDraw = pGlxWindow->pDraw;
            from_screen = to_screen = pGlxWindow->pScreen->myNum;
        }
    }

    if (!pDraw) {
        /*
         ** Drawable is neither a X window nor a GLX pixmap.
         */
        client->errorValue = drawId;
        return __glXBadDrawable;
    }

    if (tag) {
        glxc = __glXLookupContextByTag(cl, tag);
        if (!glxc) {
            return __glXBadContextTag;
        }
    }

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
        dixLookupResourceByClass((void **) &pXinDraw,
                                 pDraw->id, XRC_DRAWABLE,
                                 client, DixReadAccess);
    }
#endif

    /* If requested, send a glFinish to all back-end servers before swapping. */
    if (dmxGLXFinishSwap) {
        for (s = from_screen; s <= to_screen; s++) {
            Display *dpy = GetBackEndDisplay(cl, s);
            DMXScreenInfo *dmxScreen = &dmxScreens[s];
            xGLXSingleReq *finishReq;
            xGLXSingleReply reply;

#define X_GLXSingle 0           /* needed by GetReq below */

            LockDisplay(dpy);
            GetReq(GLXSingle, finishReq);
            finishReq->reqType = dmxScreen->glxMajorOpcode;
            finishReq->glxCode = X_GLsop_Finish;
            finishReq->contextTag =
                (tag ? GetCurrentBackEndTag(cl, tag, s) : 0);
            (void) _XReply(dpy, (xReply *) &reply, 0, False);
            UnlockDisplay(dpy);
            SyncHandle();
        }
    }

    /* If requested, send an XSync to all back-end servers before swapping. */
    if (dmxGLXSyncSwap) {
        for (s = from_screen; s <= to_screen; s++)
            XSync(GetBackEndDisplay(cl, s), False);
    }

    /* send the SwapBuffers request to all back-end servers */

    for (s = from_screen; s <= to_screen; s++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = GetBackEndDisplay(cl, s);
        unsigned int be_draw = 0;

        if (pGlxPixmap) {
            be_draw = (unsigned int) pGlxPixmap->be_xids[s];
        }
#ifdef PANORAMIX
        else if (pXinDraw) {
            dixLookupWindow(&pWin, pXinDraw->info[s].id, client, DixReadAccess);
        }
#endif
        else if (pGlxWindow) {
            pWin = (WindowPtr) pGlxWindow->pDraw;
        }

        if (pWin && !be_draw) {
            be_draw = (unsigned int) (DMX_GET_WINDOW_PRIV(pWin))->window;
            if (!be_draw) {
                /* it might be that the window did not created yet on the */
                /* back-end server (lazy window creation option), force   */
                /* creation of the window */
                dmxCreateAndRealizeWindow(pWin, TRUE);
                be_draw = (unsigned int) (DMX_GET_WINDOW_PRIV(pWin))->window;
            }
        }

        dmxSync(dmxScreen, 1);

        LockDisplay(dpy);
        GetReq(GLXSwapBuffers, be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = X_GLXSwapBuffers;
        be_req->drawable = be_draw;
        be_req->contextTag = (tag ? GetCurrentBackEndTag(cl, tag, s) : 0);
        UnlockDisplay(dpy);
        SyncHandle();
        XFlush(dpy);
    }

    return Success;
}

int
__glXSwapBuffers(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    DrawablePtr pDraw;
    xGLXSwapBuffersReq *req = (xGLXSwapBuffersReq *) pc;
    GLXContextTag tag = req->contextTag;
    XID drawId = req->drawable;
    __GLXpixmap *pGlxPixmap = NULL;
    __GLXcontext *glxc = NULL;
    __glXWindow *pGlxWindow = NULL;
    int rc;

    /*
     ** Check that the GLX drawable is valid.
     */
    rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixWriteAccess);
    if (rc == Success) {
        if (pDraw->type != DRAWABLE_WINDOW) {
            /*
             ** Drawable is an X pixmap, which is not allowed.
             */
            client->errorValue = drawId;
            return __glXBadDrawable;
        }
    }

    if (!pDraw) {
        dixLookupResourceByType((void **) &pGlxPixmap, drawId,
                                __glXPixmapRes, NullClient, DixUnknownAccess);
        if (pGlxPixmap) {
            /*
             ** Drawable is a GLX pixmap.
             */
            pDraw = pGlxPixmap->pDraw;
        }
    }

    if (!pDraw && __GLX_IS_VERSION_SUPPORTED(1, 3)) {
        dixLookupResourceByType((void **) &pGlxWindow, drawId,
                                __glXWindowRes, NullClient, DixUnknownAccess);
        if (pGlxWindow) {
            /*
             ** Drawable is a GLXWindow.
             */
            pDraw = pGlxWindow->pDraw;
        }
    }

    if (!pDraw) {
        /*
         ** Drawable is neither a X window nor a GLX pixmap.
         */
        client->errorValue = drawId;
        return __glXBadDrawable;
    }

    if (tag) {
        glxc = __glXLookupContextByTag(cl, tag);
        if (!glxc) {
            return __glXBadContextTag;
        }
    }

    if (pDraw &&
        pDraw->type == DRAWABLE_WINDOW &&
        DMX_GET_WINDOW_PRIV((WindowPtr) pDraw)->swapGroup) {
        return SGSwapBuffers(cl, drawId, tag, pDraw);
    }

    return __glXDoSwapBuffers(cl, drawId, tag);
}

/************************************************************************/

/*
** Render and Renderlarge are not in the GLX API.  They are used by the GLX
** client library to send batches of GL rendering commands.
*/

/*
** Execute all the drawing commands in a request.
*/
int
__glXRender(__GLXclientState * cl, GLbyte * pc)
{
    xGLXRenderReq *req;
    xGLXRenderReq *be_req;
    int size;
    __GLXcontext *glxc;
    int from_screen = 0;
    int to_screen = 0;
    int s;

    /*
     ** NOTE: much of this code also appears in the byteswapping version of this
     ** routine, __glXSwapRender().  Any changes made here should also be
     ** duplicated there.
     */

    req = (xGLXRenderReq *) pc;

    glxc = __glXLookupContextByTag(cl, req->contextTag);
    if (!glxc) {
        return 0;
    }
    from_screen = to_screen = glxc->pScreen->myNum;

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    pc += sz_xGLXRenderReq;
    size = (req->length << 2) - sz_xGLXRenderReq;

    /*
     * just forward the request to back-end server(s)
     */
    for (s = from_screen; s <= to_screen; s++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = GetBackEndDisplay(cl, s);

        LockDisplay(dpy);
        GetReq(GLXRender, be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = X_GLXRender;
        be_req->length = req->length;
        be_req->contextTag = GetCurrentBackEndTag(cl, req->contextTag, s);
        _XSend(dpy, (const char *) pc, size);
        UnlockDisplay(dpy);
        SyncHandle();
    }

    return Success;
}

/*
** Execute a large rendering request (one that spans multiple X requests).
*/
int
__glXRenderLarge(__GLXclientState * cl, GLbyte * pc)
{
    xGLXRenderLargeReq *req;
    xGLXRenderLargeReq *be_req;
    __GLXcontext *glxc;
    int from_screen = 0;
    int to_screen = 0;
    int s;

    /*
     ** NOTE: much of this code also appears in the byteswapping version of this
     ** routine, __glXSwapRenderLarge().  Any changes made here should also be
     ** duplicated there.
     */

    req = (xGLXRenderLargeReq *) pc;
    glxc = __glXLookupContextByTag(cl, req->contextTag);
    if (!glxc) {
        return 0;
    }
    from_screen = to_screen = glxc->pScreen->myNum;

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    pc += sz_xGLXRenderLargeReq;

    /*
     * just forward the request to back-end server(s)
     */
    for (s = from_screen; s <= to_screen; s++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = GetBackEndDisplay(cl, s);

        GetReq(GLXRenderLarge, be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = X_GLXRenderLarge;
        be_req->contextTag = GetCurrentBackEndTag(cl, req->contextTag, s);
        be_req->length = req->length;
        be_req->requestNumber = req->requestNumber;
        be_req->requestTotal = req->requestTotal;
        be_req->dataBytes = req->dataBytes;
        Data(dpy, (const char *) pc, req->dataBytes);
        UnlockDisplay(dpy);
        SyncHandle();

    }

    return Success;
}

/************************************************************************/

int
__glXVendorPrivate(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateReq *req;

    req = (xGLXVendorPrivateReq *) pc;

    switch (req->vendorCode) {

    case X_GLvop_DeleteTexturesEXT:
        return __glXVForwardSingleReq(cl, pc);
        break;

    case X_GLXvop_SwapIntervalSGI:
        if (glxIsExtensionSupported("SGI_swap_control")) {
            return __glXVForwardSingleReq(cl, pc);
        }
        else {
            return Success;
        }
        break;

#if 0                           /* glx 1.3 */
    case X_GLXvop_CreateGLXVideoSourceSGIX:
        break;
    case X_GLXvop_DestroyGLXVideoSourceSGIX:
        break;
    case X_GLXvop_CreateGLXPixmapWithConfigSGIX:
        break;
    case X_GLXvop_DestroyGLXPbufferSGIX:
        break;
    case X_GLXvop_ChangeDrawableAttributesSGIX:
        break;
#endif

    case X_GLXvop_BindSwapBarrierSGIX:
        return __glXBindSwapBarrierSGIX(cl, pc);
        break;

    case X_GLXvop_JoinSwapGroupSGIX:
        return __glXJoinSwapGroupSGIX(cl, pc);
        break;

    case X_GLXvop_CreateContextWithConfigSGIX:
        return __glXCreateContextWithConfigSGIX(cl, pc);
        break;

    default:
        /*
         ** unsupported private request
         */
        cl->client->errorValue = req->vendorCode;
        return __glXUnsupportedPrivateRequest;
    }

    cl->client->errorValue = req->vendorCode;
    return __glXUnsupportedPrivateRequest;

}

int
__glXVendorPrivateWithReply(__GLXclientState * cl, GLbyte * pc)
{
    xGLXVendorPrivateWithReplyReq *req;

    req = (xGLXVendorPrivateWithReplyReq *) pc;

    switch (req->vendorCode) {

    case X_GLvop_GetConvolutionFilterEXT:
    case X_GLvop_GetConvolutionParameterfvEXT:
    case X_GLvop_GetConvolutionParameterivEXT:
    case X_GLvop_GetSeparableFilterEXT:
    case X_GLvop_GetHistogramEXT:
    case X_GLvop_GetHistogramParameterivEXT:
    case X_GLvop_GetMinmaxEXT:
    case X_GLvop_GetMinmaxParameterfvEXT:
    case X_GLvop_GetMinmaxParameterivEXT:
    case X_GLvop_AreTexturesResidentEXT:
    case X_GLvop_IsTextureEXT:
        return (__glXVForwardPipe0WithReply(cl, pc));
        break;

    case X_GLvop_GenTexturesEXT:
        return (__glXVForwardAllWithReply(cl, pc));
        break;

#if 0                           /* glx1.3 */
    case X_GLvop_GetDetailTexFuncSGIS:
    case X_GLvop_GetSharpenTexFuncSGIS:
    case X_GLvop_GetColorTableSGI:
    case X_GLvop_GetColorTableParameterfvSGI:
    case X_GLvop_GetColorTableParameterivSGI:
    case X_GLvop_GetTexFilterFuncSGIS:
    case X_GLvop_GetInstrumentsSGIX:
    case X_GLvop_InstrumentsBufferSGIX:
    case X_GLvop_PollInstrumentsSGIX:
    case X_GLvop_FlushRasterSGIX:
    case X_GLXvop_CreateGLXPbufferSGIX:
    case X_GLXvop_GetDrawableAttributesSGIX:
    case X_GLXvop_QueryHyperpipeNetworkSGIX:
    case X_GLXvop_QueryHyperpipeConfigSGIX:
    case X_GLXvop_HyperpipeConfigSGIX:
    case X_GLXvop_DestroyHyperpipeConfigSGIX:
#endif
    case X_GLXvop_QueryMaxSwapBarriersSGIX:
        return (__glXQueryMaxSwapBarriersSGIX(cl, pc));
        break;

    case X_GLXvop_GetFBConfigsSGIX:
        return (__glXGetFBConfigsSGIX(cl, pc));
        break;

    case X_GLXvop_MakeCurrentReadSGI:
        return (__glXMakeCurrentReadSGI(cl, pc));
        break;

    case X_GLXvop_QueryContextInfoEXT:
        return (__glXQueryContextInfoEXT(cl, pc));
        break;

    default:
        /*
         ** unsupported private request
         */
        cl->client->errorValue = req->vendorCode;
        return __glXUnsupportedPrivateRequest;
    }

}

int
__glXQueryExtensionsString(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXQueryExtensionsStringReq *req = (xGLXQueryExtensionsStringReq *) pc;
    xGLXQueryExtensionsStringReply reply;
    GLint screen;
    size_t length;
    int len, numbytes;
    char *be_buf;

#ifdef FWD_QUERY_REQ
    xGLXQueryExtensionsStringReq *be_req;
    xGLXQueryExtensionsStringReply be_reply;
    DMXScreenInfo *dmxScreen;
    Display *dpy;
#endif

    screen = req->screen;

    /*
     ** Check if screen exists.
     */
    if ((screen < 0) || (screen >= screenInfo.numScreens)) {
        client->errorValue = screen;
        return BadValue;
    }

#ifdef FWD_QUERY_REQ
    dmxScreen = &dmxScreens[screen];

    /* Send the glXQueryServerString request */
    dpy = GetBackEndDisplay(cl, screen);
    LockDisplay(dpy);
    GetReq(GLXQueryExtensionsString, be_req);
    be_req->reqType = dmxScreen->glxMajorOpcode;
    be_req->glxCode = X_GLXQueryServerString;
    be_req->screen = DefaultScreen(dpy);
    _XReply(dpy, (xReply *) &be_reply, 0, False);
    len = (int) be_reply.length;
    numbytes = (int) be_reply.n;
    be_buf = (char *) malloc(numbytes);
    if (!be_buf) {
        /* Throw data on the floor */
        _XEatDataWords(dpy, len);
    }
    else {
        _XReadPad(dpy, (char *) be_buf, numbytes);
    }
    UnlockDisplay(dpy);
    SyncHandle();

#else

    be_buf = __glXGetServerString(GLX_EXTENSIONS);
    numbytes = strlen(be_buf) + 1;
    len = __GLX_PAD(numbytes) >> 2;

#endif

    length = len;
    reply = (xGLXQueryExtensionsStringReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = len,
        .n = numbytes
    };

    if (client->swapped) {
        glxSwapQueryExtensionsStringReply(client, &reply, be_buf);
    }
    else {
        WriteToClient(client, sz_xGLXQueryExtensionsStringReply, &reply);
        WriteToClient(client, (int) (length << 2), be_buf);
    }

    return Success;
}

int
__glXQueryServerString(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXQueryServerStringReq *req = (xGLXQueryServerStringReq *) pc;
    xGLXQueryServerStringReply reply;
    int name;
    GLint screen;
    size_t length;
    int len, numbytes;
    char *be_buf;

#ifdef FWD_QUERY_REQ
    xGLXQueryServerStringReq *be_req;
    xGLXQueryServerStringReply be_reply;
    DMXScreenInfo *dmxScreen;
    Display *dpy;
#endif

    name = req->name;
    screen = req->screen;
    /*
     ** Check if screen exists.
     */
    if ((screen < 0) || (screen >= screenInfo.numScreens)) {
        client->errorValue = screen;
        return BadValue;
    }

#ifdef FWD_QUERY_REQ
    dmxScreen = &dmxScreens[screen];

    /* Send the glXQueryServerString request */
    dpy = GetBackEndDisplay(cl, screen);
    LockDisplay(dpy);
    GetReq(GLXQueryServerString, be_req);
    be_req->reqType = dmxScreen->glxMajorOpcode;
    be_req->glxCode = X_GLXQueryServerString;
    be_req->screen = DefaultScreen(dpy);
    be_req->name = name;
    _XReply(dpy, (xReply *) &be_reply, 0, False);
    len = (int) be_reply.length;
    numbytes = (int) be_reply.n;
    be_buf = (char *) malloc(numbytes);
    if (!be_buf) {
        /* Throw data on the floor */
        _XEatDataWords(dpy, len);
    }
    else {
        _XReadPad(dpy, (char *) be_buf, numbytes);
    }
    UnlockDisplay(dpy);
    SyncHandle();

#else
    be_buf = __glXGetServerString(name);
    numbytes = strlen(be_buf) + 1;
    len = __GLX_PAD(numbytes) >> 2;
#endif

    length = len;
    reply = (xGLXQueryServerStringReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = length,
        .n = numbytes
    };

    if (client->swapped) {
        glxSwapQueryServerStringReply(client, &reply, be_buf);
    }
    else {
        WriteToClient(client, sz_xGLXQueryServerStringReply, &reply);
        WriteToClient(client, (int) (length << 2), be_buf);
    }

    return Success;
}

int
__glXClientInfo(__GLXclientState * cl, GLbyte * pc)
{
    xGLXClientInfoReq *req = (xGLXClientInfoReq *) pc;
    xGLXClientInfoReq *be_req;
    const char *buf;
    int from_screen = 0;
    int to_screen = 0;
    int s;

    free(cl->GLClientextensions);
    buf = (const char *) (req + 1);
    cl->GLClientextensions = strdup(buf);

    to_screen = screenInfo.numScreens - 1;

    for (s = from_screen; s <= to_screen; s++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = GetBackEndDisplay(cl, s);

        LockDisplay(dpy);
        GetReq(GLXClientInfo, be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = X_GLXClientInfo;
        be_req->major = req->major;
        be_req->minor = req->minor;
        be_req->length = req->length;
        be_req->numbytes = req->numbytes;
        Data(dpy, buf, req->numbytes);

        UnlockDisplay(dpy);
        SyncHandle();
    }

    return Success;
}

int
__glXUseXFont(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXUseXFontReq *req;
    xGLXUseXFontReq *be_req;
    FontPtr pFont;
    __GLXcontext *glxc = NULL;
    int from_screen = 0;
    int to_screen = 0;
    int s;
    dmxFontPrivPtr pFontPriv;
    DMXScreenInfo *dmxScreen;
    Display *dpy;

    req = (xGLXUseXFontReq *) pc;

    if (req->contextTag != 0) {
        glxc = __glXLookupContextByTag(cl, req->contextTag);
        if (glxc) {
            from_screen = to_screen = glxc->pScreen->myNum;
        }
    }

    /*
     ** Font can actually be either the ID of a font or the ID of a GC
     ** containing a font.
     */
    dixLookupResourceByType((void **) &pFont, req->font, RT_FONT,
                            NullClient, DixUnknownAccess);
    if (!pFont) {
        GC *pGC;

        dixLookupResourceByType((void **) &pGC, req->font,
                                RT_GC, NullClient, DixUnknownAccess);
        if (!pGC) {
            client->errorValue = req->font;
            return BadFont;
        }
        pFont = pGC->font;
    }

    pFontPriv = FontGetPrivate(pFont, dmxFontPrivateIndex);

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    for (s = from_screen; s <= to_screen; s++) {
        dmxScreen = &dmxScreens[s];
        dpy = GetBackEndDisplay(cl, s);

        dmxSync(dmxScreen, 1);

        LockDisplay(dpy);
        GetReq(GLXUseXFont, be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = X_GLXUseXFont;
        be_req->contextTag =
            (glxc ? GetCurrentBackEndTag(cl, req->contextTag, s) : 0);
        be_req->font = pFontPriv->font[s]->fid;
        be_req->first = req->first;
        be_req->count = req->count;
        be_req->listBase = req->listBase;
        UnlockDisplay(dpy);
        SyncHandle();

        XSync(dpy, False);
    }

    return Success;
}

/*
 * start GLX 1.3 here
 */

int
__glXGetFBConfigs(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXGetFBConfigsReq *req = (xGLXGetFBConfigsReq *) pc;
    xGLXGetFBConfigsReply reply;
    __GLXFBConfig *pFBConfig;
    CARD32 buf[2 * __GLX_TOTAL_FBCONFIG_PROPS];
    int numAttribs = __GLX_TOTAL_FBCONFIG_PROPS;
    unsigned int screen = req->screen;
    int numFBConfigs, i, p;
    __GLXscreenInfo *pGlxScreen;

    if (screen >= screenInfo.numScreens) {
        /* The client library must send a valid screen number. */
        client->errorValue = screen;
        return BadValue;
    }

    pGlxScreen = &__glXActiveScreens[screen];
    numFBConfigs = __glXNumFBConfigs;

    reply = (xGLXGetFBConfigsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = (numFBConfigs * 2 * numAttribs * __GLX_SIZE_CARD32) >> 2,
        .numFBConfigs = numFBConfigs,
        .numAttribs = numAttribs
    };

    if (client->swapped) {
        __GLX_DECLARE_SWAP_VARIABLES;
        __GLX_SWAP_SHORT(&reply.sequenceNumber);
        __GLX_SWAP_INT(&reply.length);
        __GLX_SWAP_INT(&reply.numFBConfigs);
        __GLX_SWAP_INT(&reply.numAttribs);
    }
    WriteToClient(client, sz_xGLXGetFBConfigsReply, &reply);

    for (i = 0; i < numFBConfigs; i++) {
        int associatedVisualId = 0;
        int drawableTypeIndex;

        pFBConfig = __glXFBConfigs[i * (screenInfo.numScreens + 1)];

        p = 0;
        /* core attributes */
        buf[p++] = GLX_FBCONFIG_ID;
        buf[p++] = pFBConfig->id;
        buf[p++] = GLX_BUFFER_SIZE;
        buf[p++] = pFBConfig->indexBits;
        buf[p++] = GLX_LEVEL;
        buf[p++] = pFBConfig->level;
        buf[p++] = GLX_DOUBLEBUFFER;
        buf[p++] = pFBConfig->doubleBufferMode;
        buf[p++] = GLX_STEREO;
        buf[p++] = pFBConfig->stereoMode;
        buf[p++] = GLX_AUX_BUFFERS;
        buf[p++] = pFBConfig->maxAuxBuffers;
        buf[p++] = GLX_RED_SIZE;
        buf[p++] = pFBConfig->redBits;
        buf[p++] = GLX_GREEN_SIZE;
        buf[p++] = pFBConfig->greenBits;
        buf[p++] = GLX_BLUE_SIZE;
        buf[p++] = pFBConfig->blueBits;
        buf[p++] = GLX_ALPHA_SIZE;
        buf[p++] = pFBConfig->alphaBits;
        buf[p++] = GLX_DEPTH_SIZE;
        buf[p++] = pFBConfig->depthBits;
        buf[p++] = GLX_STENCIL_SIZE;
        buf[p++] = pFBConfig->stencilBits;
        buf[p++] = GLX_ACCUM_RED_SIZE;
        buf[p++] = pFBConfig->accumRedBits;
        buf[p++] = GLX_ACCUM_GREEN_SIZE;
        buf[p++] = pFBConfig->accumGreenBits;
        buf[p++] = GLX_ACCUM_BLUE_SIZE;
        buf[p++] = pFBConfig->accumBlueBits;
        buf[p++] = GLX_ACCUM_ALPHA_SIZE;
        buf[p++] = pFBConfig->accumAlphaBits;
        buf[p++] = GLX_RENDER_TYPE;
        buf[p++] = pFBConfig->renderType;
        buf[p++] = GLX_DRAWABLE_TYPE;
        drawableTypeIndex = p;
        buf[p++] = pFBConfig->drawableType;
        buf[p++] = GLX_X_VISUAL_TYPE;
        buf[p++] = pFBConfig->visualType;
        buf[p++] = GLX_CONFIG_CAVEAT;
        buf[p++] = pFBConfig->visualCaveat;
        buf[p++] = GLX_TRANSPARENT_TYPE;
        buf[p++] = pFBConfig->transparentType;
        buf[p++] = GLX_TRANSPARENT_RED_VALUE;
        buf[p++] = pFBConfig->transparentRed;
        buf[p++] = GLX_TRANSPARENT_GREEN_VALUE;
        buf[p++] = pFBConfig->transparentGreen;
        buf[p++] = GLX_TRANSPARENT_BLUE_VALUE;
        buf[p++] = pFBConfig->transparentBlue;
        buf[p++] = GLX_TRANSPARENT_ALPHA_VALUE;
        buf[p++] = pFBConfig->transparentAlpha;
        buf[p++] = GLX_TRANSPARENT_INDEX_VALUE;
        buf[p++] = pFBConfig->transparentIndex;
        buf[p++] = GLX_MAX_PBUFFER_WIDTH;
        buf[p++] = pFBConfig->maxPbufferWidth;
        buf[p++] = GLX_MAX_PBUFFER_HEIGHT;
        buf[p++] = pFBConfig->maxPbufferHeight;
        buf[p++] = GLX_MAX_PBUFFER_PIXELS;
        buf[p++] = pFBConfig->maxPbufferPixels;

        /*
         * find the visual of the back-end server and match a visual
         * on the proxy.
         * do only once - if a visual is not yet associated.
         */
        if (pFBConfig->associatedVisualId == (unsigned int) -1) {
            DMXScreenInfo *dmxScreen = &dmxScreens[screen];
            __GLXFBConfig *be_pFBConfig =
                __glXFBConfigs[i * (screenInfo.numScreens + 1) + screen + 1];
            __GLXvisualConfig *pGlxVisual = NULL;
            int v;
            int found = 0;

            for (v = 0; v < dmxScreen->numGlxVisuals; v++) {
                if (dmxScreen->glxVisuals[v].vid ==
                    be_pFBConfig->associatedVisualId) {
                    pGlxVisual = &dmxScreen->glxVisuals[v];
                    break;
                }
            }

            if (pGlxVisual) {
                for (v = 0; v < pGlxScreen->numVisuals; v++) {
                    if (glxVisualsMatch(&pGlxScreen->pGlxVisual[v], pGlxVisual)) {
                        associatedVisualId = pGlxScreen->pGlxVisual[v].vid;
                        found = 1;
                        break;
                    }
                }
            }

            if (!found) {
                associatedVisualId = 0;
                pFBConfig->drawableType &= ~(GLX_WINDOW_BIT);
                buf[drawableTypeIndex] = pFBConfig->drawableType;
            }
#ifdef PANORAMIX
            else if (!noPanoramiXExtension) {
                /* convert the associated visualId to the panoramix one */
                pFBConfig->associatedVisualId =
                    PanoramiXTranslateVisualID(screen, v);
            }
#endif
        }
        else {
            associatedVisualId = pFBConfig->associatedVisualId;
        }

        buf[p++] = GLX_VISUAL_ID;
        buf[p++] = associatedVisualId;

        /* SGIS_multisample attributes */
        buf[p++] = GLX_SAMPLES_SGIS;
        buf[p++] = pFBConfig->multiSampleSize;
        buf[p++] = GLX_SAMPLE_BUFFERS_SGIS;
        buf[p++] = pFBConfig->nMultiSampleBuffers;

        /* SGIX_pbuffer specific attributes */
        buf[p++] = GLX_OPTIMAL_PBUFFER_WIDTH_SGIX;
        buf[p++] = pFBConfig->optimalPbufferWidth;
        buf[p++] = GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX;
        buf[p++] = pFBConfig->optimalPbufferHeight;

        buf[p++] = GLX_VISUAL_SELECT_GROUP_SGIX;
        buf[p++] = pFBConfig->visualSelectGroup;

        if (client->swapped) {
            __GLX_DECLARE_SWAP_VARIABLES;
            __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
            __GLX_SWAP_INT_ARRAY((int *) buf, 2 * numAttribs);
        }
        WriteToClient(client, 2 * numAttribs * __GLX_SIZE_CARD32, buf);
    }
    return Success;
}

int
__glXGetFBConfigsSGIX(__GLXclientState * cl, GLbyte * pc)
{
    xGLXGetFBConfigsSGIXReq *req = (xGLXGetFBConfigsSGIXReq *) pc;
    xGLXGetFBConfigsReq new_req;

    new_req.reqType = req->reqType;
    new_req.glxCode = req->glxCode;
    new_req.length = req->length;
    new_req.screen = req->screen;

    return (__glXGetFBConfigs(cl, (GLbyte *) &new_req));
}

int
__glXCreateWindow(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreateWindowReq *req = (xGLXCreateWindowReq *) pc;
    int screen = req->screen;
    GLXFBConfigID fbconfigId = req->fbconfig;
    XID windowId = req->window;
    XID glxwindowId = req->glxwindow;
    DrawablePtr pDraw;
    ScreenPtr pScreen;
    __glXWindow *pGlxWindow;
    __GLXFBConfig *pGlxFBConfig = NULL;
    VisualPtr pVisual;
    VisualID visId;
    int i, rc;
    void *val;

    /*
     ** Check if windowId is valid
     */
    rc = dixLookupDrawable(&pDraw, windowId, client, M_DRAWABLE_WINDOW,
                           DixAddAccess);
    if (rc != Success)
        return rc;

    /*
     ** Check if screen of window matches screen of fbconfig.
     */
    pScreen = pDraw->pScreen;
    if (screen != pScreen->myNum) {
        return BadMatch;
    }

    /*
     ** Find the FBConfigRec for this fbconfigid.
     */
    if (!(pGlxFBConfig = glxLookupFBConfig(fbconfigId))) {
        client->errorValue = fbconfigId;
        return __glXBadFBConfig;
    }
    visId = pGlxFBConfig->associatedVisualId;

    /*
     ** Check if the fbconfig supports rendering to windows
     */
    if (!(pGlxFBConfig->drawableType & GLX_WINDOW_BIT)) {
        return BadMatch;
    }

    if (visId != None) {
        /*
         ** Check if the visual ID is valid for this screen.
         */
        pVisual = pScreen->visuals;
        for (i = 0; i < pScreen->numVisuals; i++, pVisual++) {
            if (pVisual->vid == visId) {
                break;
            }
        }
        if (i == pScreen->numVisuals) {
            client->errorValue = visId;
            return BadValue;
        }

        /*
         ** Check if color buffer depth of fbconfig matches depth
         ** of window.
         */
        if (pVisual->nplanes != pDraw->depth) {
            return BadMatch;
        }
    }
    else
        /*
         ** The window was created with no visual that corresponds
         ** to fbconfig
         */
        return BadMatch;

    /*
     ** Check if there is already a fbconfig associated with this window
     */
    if (Success == dixLookupResourceByType(&val,
                                           glxwindowId, __glXWindowRes,
                                           NullClient, DixUnknownAccess)) {
        client->errorValue = glxwindowId;
        return BadAlloc;
    }

    pGlxWindow = (__glXWindow *) malloc(sizeof(__glXWindow));
    if (!pGlxWindow) {
        return BadAlloc;
    }

    /*
     ** Register this GLX window as a resource
     */
    if (!(AddResource(glxwindowId, __glXWindowRes, pGlxWindow))) {
        return BadAlloc;
    }

    pGlxWindow->pDraw = pDraw;
    pGlxWindow->type = GLX_GLXWINDOW_TYPE;
    pGlxWindow->idExists = True;
    pGlxWindow->refcnt = 0;
    pGlxWindow->pGlxFBConfig = pGlxFBConfig;
    pGlxWindow->pScreen = pScreen;

    return Success;
}

int
__glXDestroyWindow(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyWindowReq *req = (xGLXDestroyWindowReq *) pc;
    XID glxwindow = req->glxwindow;
    void *val;

    /*
     ** Check if it's a valid GLX window.
     */
    if (Success != dixLookupResourceByType(&val,
                                           glxwindow, __glXWindowRes,
                                           NullClient, DixUnknownAccess)) {
        client->errorValue = glxwindow;
        return __glXBadDrawable;
    }
    /*
     ** The glx window destructor will check whether it's current before
     ** freeing anything.
     */
    FreeResource(glxwindow, RT_NONE);

    return Success;
}

int
__glXQueryContext(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    __GLXcontext *ctx;
    xGLXQueryContextReq *req;
    xGLXQueryContextReply reply;
    int nProps;
    int *sendBuf, *pSendBuf;
    int nReplyBytes;

    req = (xGLXQueryContextReq *) pc;
    dixLookupResourceByType((void **) &ctx, req->context, __glXContextRes,
                            NullClient, DixUnknownAccess);
    if (!ctx) {
        client->errorValue = req->context;
        return __glXBadContext;
    }

    nProps = 3;

    reply = (xGLXQueryContextReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = nProps << 1,
        .n = nProps
    };

    nReplyBytes = reply.length << 2;
    sendBuf = (int *) malloc(nReplyBytes);
    pSendBuf = sendBuf;
    *pSendBuf++ = GLX_FBCONFIG_ID;
    *pSendBuf++ = (int) (ctx->pFBConfig->id);
    *pSendBuf++ = GLX_RENDER_TYPE;
    *pSendBuf++ = renderTypeBitsToRenderTypeEnum(ctx->pFBConfig->renderType);
    *pSendBuf++ = GLX_SCREEN;
    *pSendBuf++ = (int) (ctx->pScreen->myNum);

    if (client->swapped) {
        __glXSwapQueryContextReply(client, &reply, sendBuf);
    }
    else {
        WriteToClient(client, sz_xGLXQueryContextReply, &reply);
        WriteToClient(client, nReplyBytes, sendBuf);
    }
    free((char *) sendBuf);

    return Success;
}

int
__glXQueryContextInfoEXT(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    __GLXcontext *ctx;
    xGLXQueryContextInfoEXTReq *req;
    xGLXQueryContextInfoEXTReply reply;
    int nProps;
    int *sendBuf, *pSendBuf;
    int nReplyBytes;

    req = (xGLXQueryContextInfoEXTReq *) pc;
    dixLookupResourceByType((void **) &ctx,
                            req->context, __glXContextRes,
                            client, DixReadAccess);

    if (!ctx) {
        client->errorValue = req->context;
        return __glXBadContext;
    }

    nProps = 4;

    reply = (xGLXQueryContextInfoEXTReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = nProps << 1,
        .n = nProps
    };

    nReplyBytes = reply.length << 2;
    sendBuf = (int *) malloc(nReplyBytes);
    pSendBuf = sendBuf;
    *pSendBuf++ = GLX_SHARE_CONTEXT_EXT;
    *pSendBuf++ = (int) (ctx->share_id);
    *pSendBuf++ = GLX_VISUAL_ID_EXT;
    *pSendBuf++ = (int) (ctx->pVisual ? ctx->pVisual->vid : 0);
    *pSendBuf++ = GLX_SCREEN_EXT;
    *pSendBuf++ = (int) (ctx->pScreen->myNum);
    *pSendBuf++ = GLX_FBCONFIG_ID;
    *pSendBuf++ = (int) (ctx->pFBConfig ? ctx->pFBConfig->id : 0);

    if (client->swapped) {
        __glXSwapQueryContextInfoEXTReply(client, &reply, sendBuf);
    }
    else {
        WriteToClient(client, sz_xGLXQueryContextInfoEXTReply, &reply);
        WriteToClient(client, nReplyBytes, sendBuf);
    }
    free((char *) sendBuf);

    return Success;
}

int
__glXCreatePbuffer(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXCreatePbufferReq *req = (xGLXCreatePbufferReq *) pc;
    xGLXCreatePbufferReq *be_req;
    int screen = req->screen;
    GLXFBConfigID fbconfigId = req->fbconfig;
    GLXPbuffer pbuffer = req->pbuffer;
    __glXPbuffer *pGlxPbuffer;
    int numAttribs = req->numAttribs;
    int *attr;
    ScreenPtr pScreen;
    __GLXFBConfig *pGlxFBConfig;
    __GLXFBConfig *be_pGlxFBConfig;
    XID be_xid;
    Display *dpy;
    DMXScreenInfo *dmxScreen;
    int s;
    int from_screen, to_screen;

    /*
     ** Look up screen and FBConfig.
     */
    if (screen >= screenInfo.numScreens) {
        /* The client library must send a valid screen number. */
        client->errorValue = screen;
        return BadValue;
    }
    pScreen = screenInfo.screens[screen];

    /*
     ** Find the FBConfigRec for this fbconfigid.
     */
    if (!(pGlxFBConfig = glxLookupFBConfig(fbconfigId))) {
        client->errorValue = fbconfigId;
        return __glXBadFBConfig;
    }

    /*
     ** Create the GLX part of the Pbuffer.
     */
    pGlxPbuffer = (__glXPbuffer *) malloc(sizeof(__glXPbuffer));
    if (!pGlxPbuffer) {
        return BadAlloc;
    }

    pGlxPbuffer->be_xids = xallocarray(screenInfo.numScreens, sizeof(XID));
    if (!pGlxPbuffer->be_xids) {
        free(pGlxPbuffer);
        return BadAlloc;
    }

    /*
     * Allocate an XID on the back-end server(s) and send him the request
     */
    from_screen = to_screen = screen;
#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    for (s = from_screen; s <= to_screen; s++) {
        dpy = GetBackEndDisplay(cl, s);
        be_xid = XAllocID(dpy);
        dmxScreen = &dmxScreens[s];
        be_pGlxFBConfig = glxLookupBackEndFBConfig(pGlxFBConfig->id, s);

        attr = (int *) (req + 1);

        LockDisplay(dpy);
        GetReqExtra(GLXCreatePbuffer, 2 * numAttribs * __GLX_SIZE_CARD32,
                    be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = X_GLXCreatePbuffer;
        be_req->screen = be_pGlxFBConfig->screen;
        be_req->fbconfig = be_pGlxFBConfig->id;
        be_req->pbuffer = be_xid;
        be_req->numAttribs = numAttribs;

        /* Send attributes */
        if (attr != NULL) {
            CARD32 *pca = (CARD32 *) (be_req + 1);

            while (numAttribs-- > 0) {
                *pca++ = *attr++;        /* token */
                *pca++ = *attr++;        /* value */
            }
        }

        UnlockDisplay(dpy);
        SyncHandle();

        pGlxPbuffer->be_xids[s] = be_xid;
    }

    pGlxPbuffer->idExists = True;
    pGlxPbuffer->refcnt = 0;
    pGlxPbuffer->pFBConfig = pGlxFBConfig;
    pGlxPbuffer->pScreen = pScreen;

    /*
     ** Register the resource.
     */
    if (!(AddResource(pbuffer, __glXPbufferRes, pGlxPbuffer))) {
        return BadAlloc;
    }

    return Success;

}

int
__glXDestroyPbuffer(__GLXclientState * cl, GLbyte * pc)
{
    ClientPtr client = cl->client;
    xGLXDestroyPbufferReq *req = (xGLXDestroyPbufferReq *) pc;
    xGLXDestroyPbufferReq *be_req;
    GLXPbuffer pbuffer = req->pbuffer;
    Display *dpy;
    int screen;
    DMXScreenInfo *dmxScreen;
    __glXPbuffer *pGlxPbuffer;
    int s;
    int from_screen, to_screen;

    /*
     ** Check if it's a valid Pbuffer
     */
    dixLookupResourceByType((void **) &pGlxPbuffer, pbuffer,
                            __glXPbufferRes, NullClient, DixUnknownAccess);
    if (!pGlxPbuffer) {
        client->errorValue = pbuffer;
        return __glXBadPbuffer;
    }

    screen = pGlxPbuffer->pScreen->myNum;

    from_screen = to_screen = screen;
#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    for (s = from_screen; s <= to_screen; s++) {
        dpy = GetBackEndDisplay(cl, s);
        dmxScreen = &dmxScreens[s];

        /* send the destroy request to the back-end server */
        LockDisplay(dpy);
        GetReq(GLXDestroyPbuffer, be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = X_GLXDestroyPbuffer;
        be_req->pbuffer = pGlxPbuffer->be_xids[s];
        UnlockDisplay(dpy);
        SyncHandle();
    }

    FreeResource(pbuffer, RT_NONE);

    return Success;
}

int
__glXGetDrawableAttributes(__GLXclientState * cl, GLbyte * pc)
{
    xGLXGetDrawableAttributesReq *req = (xGLXGetDrawableAttributesReq *) pc;
    xGLXGetDrawableAttributesReq *be_req;
    xGLXGetDrawableAttributesReply reply;
    ClientPtr client = cl->client;
    GLXDrawable drawId = req->drawable;
    GLXDrawable be_drawable = 0;
    DrawablePtr pDraw = NULL;
    Display *dpy;
    int screen, rc;
    DMXScreenInfo *dmxScreen;
    CARD32 *attribs = NULL;
    int attribs_size = 0;

#ifdef PANORAMIX
    PanoramiXRes *pXinDraw = NULL;
#endif

    if (drawId != None) {
        rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixGetAttrAccess);
        if (rc == Success && pDraw->type == DRAWABLE_WINDOW) {
            WindowPtr pWin = (WindowPtr) pDraw;

            be_drawable = 0;
            screen = pWin->drawable.pScreen->myNum;
        }
        else {
            /*
             ** Drawable is not a Window , GLXWindow or a GLXPixmap.
             */
            client->errorValue = drawId;
            return __glXBadDrawable;
        }

        if (!pDraw) {
            __GLXpixmap *pGlxPixmap;

            dixLookupResourceByType((void **) &pGlxPixmap,
                                    drawId, __glXPixmapRes,
                                    NullClient, DixUnknownAccess);
            if (pGlxPixmap) {
                pDraw = pGlxPixmap->pDraw;
                screen = pGlxPixmap->pScreen->myNum;
                be_drawable = pGlxPixmap->be_xids[screen];
            }
        }

        if (!pDraw) {
            __glXWindow *pGlxWindow;

            dixLookupResourceByType((void **) &pGlxWindow,
                                    drawId, __glXWindowRes,
                                    NullClient, DixUnknownAccess);
            if (pGlxWindow) {
                pDraw = pGlxWindow->pDraw;
                screen = pGlxWindow->pScreen->myNum;
                be_drawable = 0;
            }
        }

        if (!pDraw) {
            __glXPbuffer *pGlxPbuffer;

            dixLookupResourceByType((void **) &pGlxPbuffer,
                                    drawId, __glXPbufferRes,
                                    NullClient, DixUnknownAccess);
            if (pGlxPbuffer) {
                pDraw = (DrawablePtr) pGlxPbuffer;
                screen = pGlxPbuffer->pScreen->myNum;
                be_drawable = pGlxPbuffer->be_xids[screen];
            }
        }
    }

    if (!pDraw) {
        /*
         ** Drawable is not a Window , GLXWindow or a GLXPixmap.
         */
        client->errorValue = drawId;
        return __glXBadDrawable;
    }

    /* if the drawable is a window or GLXWindow -
     * we need to find the base id on the back-end server
     */
    if (!be_drawable) {
        WindowPtr pWin = (WindowPtr) pDraw;

#ifdef PANORAMIX
        if (!noPanoramiXExtension) {
            if (Success != dixLookupResourceByClass((void **) &pXinDraw,
                                                    pDraw->id, XRC_DRAWABLE,
                                                    client, DixReadAccess)) {
                client->errorValue = drawId;
                return __glXBadDrawable;
            }

            dixLookupWindow(&pWin, pXinDraw->info[screen].id, client,
                            DixReadAccess);
        }
#endif

        if (pWin) {
            be_drawable = (unsigned int) (DMX_GET_WINDOW_PRIV(pWin))->window;
            if (!be_drawable) {
                /* it might be that the window did not created yet on the */
                /* back-end server (lazy window creation option), force   */
                /* creation of the window */
                dmxCreateAndRealizeWindow(pWin, TRUE);
                be_drawable =
                    (unsigned int) (DMX_GET_WINDOW_PRIV(pWin))->window;
            }
        }
        else {
            client->errorValue = drawId;
            return __glXBadDrawable;
        }
    }

    /* send the request to the back-end server */
    dpy = GetBackEndDisplay(cl, screen);
    dmxScreen = &dmxScreens[screen];

    /* make sure drawable exists on back-end */
    dmxSync(dmxScreen, 1);

    LockDisplay(dpy);
    GetReq(GLXGetDrawableAttributes, be_req);
    be_req->reqType = dmxScreen->glxMajorOpcode;
    be_req->glxCode = X_GLXGetDrawableAttributes;
    be_req->drawable = be_drawable;
    be_req->length = req->length;
    if (!_XReply(dpy, (xReply *) &reply, 0, False)) {
        UnlockDisplay(dpy);
        SyncHandle();
        return (BE_TO_CLIENT_ERROR(dmxLastErrorEvent.error_code));
    }

    if (reply.numAttribs) {
        attribs = xallocarray(reply.numAttribs, 2 * __GLX_SIZE_CARD32);
        if (attribs == NULL) {
            UnlockDisplay(dpy);
            SyncHandle();
            return BadAlloc;
        }
        attribs_size = 2 * reply.numAttribs * __GLX_SIZE_CARD32;

        _XRead(dpy, (char *) attribs, attribs_size);
    }

    UnlockDisplay(dpy);
    SyncHandle();

    /* send the reply back to the client */
    reply.sequenceNumber = client->sequence;
    if (client->swapped) {
        __glXSwapGetDrawableAttributesReply(client, &reply, (int *) attribs);
    }
    else {
        WriteToClient(client, sz_xGLXGetDrawableAttributesReply, &reply);
        WriteToClient(client, attribs_size, attribs);
    }

    free(attribs);

    return Success;
}

int
__glXChangeDrawableAttributes(__GLXclientState * cl, GLbyte * pc)
{
    xGLXChangeDrawableAttributesReq *req =
        (xGLXChangeDrawableAttributesReq *) pc;
    xGLXChangeDrawableAttributesReq *be_req;
    ClientPtr client = cl->client;
    GLXDrawable drawId = req->drawable;
    GLXDrawable be_drawable = 0;
    DrawablePtr pDraw = NULL;
    Display *dpy;
    int screen, rc;
    DMXScreenInfo *dmxScreen;

    if (drawId != None) {
        rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixSetAttrAccess);
        if (rc == Success && pDraw->type == DRAWABLE_WINDOW) {
            be_drawable = 0;
            screen = pDraw->pScreen->myNum;
        }
        else {
            /*
             ** Drawable is not a Window , GLXWindow or a GLXPixmap.
             */
            client->errorValue = drawId;
            return __glXBadDrawable;
        }

        if (!pDraw) {
            __GLXpixmap *pGlxPixmap;

            dixLookupResourceByType((void **) &pGlxPixmap,
                                    drawId, __glXPixmapRes,
                                    NullClient, DixUnknownAccess);
            if (pGlxPixmap) {
                pDraw = pGlxPixmap->pDraw;
                screen = pGlxPixmap->pScreen->myNum;
                be_drawable = pGlxPixmap->be_xids[screen];
            }
        }

        if (!pDraw) {
            __glXWindow *pGlxWindow;

            dixLookupResourceByType((void **) &pGlxWindow,
                                    drawId, __glXWindowRes,
                                    NullClient, DixUnknownAccess);
            if (pGlxWindow) {
                pDraw = pGlxWindow->pDraw;
                screen = pGlxWindow->pScreen->myNum;
                be_drawable = 0;
            }
        }

        if (!pDraw) {
            __glXPbuffer *pGlxPbuffer;

            dixLookupResourceByType((void **) &pGlxPbuffer,
                                    drawId, __glXPbufferRes,
                                    NullClient, DixUnknownAccess);
            if (pGlxPbuffer) {
                pDraw = (DrawablePtr) pGlxPbuffer;
                screen = pGlxPbuffer->pScreen->myNum;
                be_drawable = pGlxPbuffer->be_xids[screen];
            }
        }
    }

    if (!pDraw) {
        /*
         ** Drawable is not a Window , GLXWindow or a GLXPixmap.
         */
        client->errorValue = drawId;
        return __glXBadDrawable;
    }

    /* if the drawable is a window or GLXWindow -
     * we need to find the base id on the back-end server
     */
    if (!be_drawable) {
        WindowPtr pWin = (WindowPtr) pDraw;

#ifdef PANORAMIX
        if (!noPanoramiXExtension) {
            PanoramiXRes *pXinDraw;

            if (Success != dixLookupResourceByClass((void **) &pXinDraw,
                                                    pDraw->id, XRC_DRAWABLE,
                                                    client, DixReadAccess)) {
                client->errorValue = drawId;
                return __glXBadDrawable;
            }

            dixLookupWindow(&pWin, pXinDraw->info[screen].id, client,
                            DixReadAccess);
        }
#endif

        if (pWin) {
            be_drawable = (unsigned int) (DMX_GET_WINDOW_PRIV(pWin))->window;
            if (!be_drawable) {
                /* it might be that the window did not created yet on the */
                /* back-end server (lazy window creation option), force   */
                /* creation of the window */
                dmxCreateAndRealizeWindow(pWin, TRUE);
                be_drawable =
                    (unsigned int) (DMX_GET_WINDOW_PRIV(pWin))->window;
            }
        }
        else {
            client->errorValue = drawId;
            return __glXBadDrawable;
        }
    }

    /* send the request to the back-end server */
    dpy = GetBackEndDisplay(cl, screen);
    dmxScreen = &dmxScreens[screen];

    /* make sure drawable exists on back-end */
    dmxSync(dmxScreen, 1);

    LockDisplay(dpy);
    GetReqExtra(GLXChangeDrawableAttributes,
                2 * req->numAttribs * __GLX_SIZE_CARD32, be_req);
    be_req->reqType = dmxScreen->glxMajorOpcode;
    be_req->glxCode = X_GLXChangeDrawableAttributes;
    be_req->drawable = be_drawable;
    be_req->numAttribs = req->numAttribs;
    be_req->length = req->length;

    UnlockDisplay(dpy);
    SyncHandle();

    return Success;
}

int
__glXSendLargeCommand(__GLXclientState * cl, GLXContextTag contextTag)
{
    ClientPtr client = cl->client;
    xGLXRenderLargeReq *req;
    GLint maxSize, amount;
    GLint totalRequests, requestNumber;
    GLint dataLen;
    GLbyte *data;
    __GLXcontext *glxc;
    int s;
    int from_screen, to_screen;

    maxSize = cl->largeCmdMaxReqDataSize - (GLint) sizeof(xGLXRenderLargeReq);
    dataLen = cl->largeCmdBytesTotal;
    totalRequests = (dataLen / maxSize);
    if (dataLen % maxSize)
        totalRequests++;

    glxc = __glXLookupContextByTag(cl, contextTag);
    if (!glxc) {
        client->errorValue = contextTag;
        return __glXBadContext;
    }
    from_screen = to_screen = glxc->pScreen->myNum;

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        from_screen = 0;
        to_screen = screenInfo.numScreens - 1;
    }
#endif

    /*
     ** Send enough requests until the whole array is sent.
     */
    requestNumber = 1;
    data = cl->largeCmdBuf;
    while (dataLen > 0) {
        amount = dataLen;
        if (amount > maxSize) {
            amount = maxSize;
        }

        for (s = from_screen; s <= to_screen; s++) {

            Display *dpy = GetBackEndDisplay(cl, s);
            DMXScreenInfo *dmxScreen = &dmxScreens[s];

            LockDisplay(dpy);
            GetReq(GLXRenderLarge, req);
            req->reqType = dmxScreen->glxMajorOpcode;
            req->glxCode = X_GLXRenderLarge;
            req->contextTag = GetCurrentBackEndTag(cl, contextTag, s);
            req->length += (amount + 3) >> 2;
            req->requestNumber = requestNumber++;
            req->requestTotal = totalRequests;
            req->dataBytes = amount;
            Data(dpy, ((const char *) data), amount);
            dataLen -= amount;
            data = ((GLbyte *) data) + amount;
            UnlockDisplay(dpy);
            SyncHandle();
        }
    }

    return Success;
}
@


1.14
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d287 1
a287 1
    glxc->real_ids = (XID *) malloc(sizeof(XID) * num_be_screens);
d291 1
a291 1
    glxc->real_vids = (XID *) malloc(sizeof(XID) * num_be_screens);
d688 10
a697 16
        cl->be_currentCTag =
            (GLXContextTag *) malloc(screenInfo.numScreens *
                                     sizeof(GLXContextTag));
    }
    else {
        table = (__GLXcontext **) realloc(table,
                                          (num + 1) * sizeof(__GLXcontext *));
        cl->currentDrawables = (DrawablePtr *) realloc(cl->currentDrawables,
                                                       (num +
                                                        1) *
                                                       sizeof(DrawablePtr));
        cl->be_currentCTag =
            (GLXContextTag *) realloc(cl->be_currentCTag,
                                      (num +
                                       1) * screenInfo.numScreens *
                                      sizeof(GLXContextTag));
d1893 1
a1893 1
    pGlxPixmap->be_xids = (XID *) malloc(sizeof(XID) * screenInfo.numScreens);
d2013 1
a2013 3
    if (!(AddResource(glxpixmapId, __glXPixmapRes, pGlxPixmap))) {
        free(pGlxPixmap->be_xids);
        free(pGlxPixmap);
a2014 1
    }
d3350 1
a3350 1
    pGlxPbuffer->be_xids = (XID *) malloc(sizeof(XID) * screenInfo.numScreens);
d3611 1
a3611 2
        attribs_size = 2 * reply.numAttribs * __GLX_SIZE_CARD32;
        attribs = (CARD32 *) malloc(attribs_size);
d3617 1
@


1.13
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a63 1
extern int glxIsExtensionSupported(char *ext);
d3396 1
a3396 1
            CARD32 *pc = (CARD32 *) (be_req + 1);
d3399 2
a3400 2
                *pc++ = *attr++;        /* token */
                *pc++ = *attr++;        /* value */
@


1.12
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d191 1
a191 1
     ** Find the display list space that we want to share.  
d1754 1
a1754 1
        /* 
d3090 1
a3090 1
     ** Check if windowId is valid 
d3115 1
a3115 1
     ** Check if the fbconfig supports rendering to windows 
d3137 1
a3137 1
         ** Check if color buffer depth of fbconfig matches depth 
d3147 1
a3147 1
         ** to fbconfig 
d3564 1
a3564 1
    /* if the drawable is a window or GLXWindow - 
d3726 1
a3726 1
    /* if the drawable is a window or GLXWindow - 
@


1.11
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d198 1
a198 1
        dixLookupResourceByType((pointer *) &shareglxc, shareList,
d428 1
a428 1
    if (!AddResource(gcId, __glXContextRes, (pointer) glxc)) {
d514 1
a514 1
        dixLookupResourceByType((pointer *) &pGlxPixmap, req->drawable,
d521 1
a521 1
        dixLookupResourceByType((pointer *) &pGlxWindow, req->drawable,
d547 1
a547 1
        dixLookupResourceByType((pointer *) &pGlxPixmap, req->drawable,
d554 1
a554 1
        dixLookupResourceByType((pointer *) &pGlxWindow, req->drawable,
d569 1
a569 1
            dixLookupResourceByType((pointer *) &pGlxPixmap, req->member,
d577 1
a577 1
            dixLookupResourceByType((pointer *) &pGlxWindow, req->member,
d608 1
a608 1
    dixLookupResourceByType((pointer *) &glxc, gcId, __glXContextRes,
d883 1
a883 1
        dixLookupResourceByType((pointer *) &glxc, contextId, __glXContextRes,
d938 1
a938 1
            dixLookupResourceByType((pointer *) &pGlxPixmap, drawId,
d963 1
a963 1
            dixLookupResourceByType((pointer *) &pGlxWindow, drawId,
d986 1
a986 1
            dixLookupResourceByType((pointer *) &pGlxPbuffer, drawId,
d1053 1
a1053 1
            dixLookupResourceByType((pointer *) &pReadGlxPixmap, readId,
d1075 1
a1075 1
            dixLookupResourceByType((pointer *) &pGlxReadWindow, readId,
d1097 1
a1097 1
            dixLookupResourceByType((pointer *) &pGlxReadPbuffer, readId,
d1239 1
a1239 1
            dixLookupResourceByClass((pointer *) &pXinDraw,
d1246 1
a1246 1
            dixLookupResourceByClass((pointer *) &pXinReadDraw,
d1463 1
a1463 1
    dixLookupResourceByType((pointer *) &glxc, req->context, __glXContextRes,
d1622 1
a1622 1
    dixLookupResourceByType((pointer *) &src, source, __glXContextRes,
d1628 1
a1628 1
    dixLookupResourceByType((pointer *) &dst, dest, __glXContextRes,
d1928 1
a1928 1
        dixLookupResourceByClass((pointer *) &pXinDraw,
d2012 1
d2021 1
d2060 1
a2060 1
    dixLookupResourceByType((pointer *) &pGlxPixmap, glxpixmap,
d2146 1
a2146 1
        dixLookupResourceByType((pointer *) &pGlxPixmap, drawId,
d2158 1
a2158 1
        dixLookupResourceByType((pointer *) &pGlxWindow, drawId,
d2188 1
a2188 1
        dixLookupResourceByClass((pointer *) &pXinDraw,
d2296 1
a2296 1
        dixLookupResourceByType((pointer *) &pGlxPixmap, drawId,
d2307 1
a2307 1
        dixLookupResourceByType((pointer *) &pGlxWindow, drawId,
d2822 1
a2822 1
    dixLookupResourceByType((pointer *) &pFont, req->font, RT_FONT,
d2827 1
a2827 1
        dixLookupResourceByType((pointer *) &pGC, req->font,
d3087 1
a3087 1
    pointer val;
d3189 1
a3189 1
    pointer val;
d3221 1
a3221 1
    dixLookupResourceByType((pointer *) &ctx, req->context, __glXContextRes,
d3271 1
a3271 1
    dixLookupResourceByType((pointer *) &ctx,
d3444 1
a3444 1
    dixLookupResourceByType((pointer *) &pGlxPbuffer, pbuffer,
d3519 1
a3519 1
            dixLookupResourceByType((pointer *) &pGlxPixmap,
d3532 1
a3532 1
            dixLookupResourceByType((pointer *) &pGlxWindow,
d3545 1
a3545 1
            dixLookupResourceByType((pointer *) &pGlxPbuffer,
d3572 1
a3572 1
            if (Success != dixLookupResourceByClass((pointer *) &pXinDraw,
d3681 1
a3681 1
            dixLookupResourceByType((pointer *) &pGlxPixmap,
d3694 1
a3694 1
            dixLookupResourceByType((pointer *) &pGlxWindow,
d3707 1
a3707 1
            dixLookupResourceByType((pointer *) &pGlxPbuffer,
d3736 1
a3736 1
            if (Success != dixLookupResourceByClass((pointer *) &pXinDraw,
@


1.10
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d126 22
d333 8
a340 6
            /*Since for a certain visual both RGB and COLOR INDEX
             *can be on then the only parmeter to choose the renderType
             * should be the class of the colormap since all 4 first 
             * classes does not support RGB mode only COLOR INDEX ,
             * and so TrueColor and DirectColor does not support COLOR INDEX*/
            int renderType = glxc->pFBConfig->renderType;
d356 3
d360 1
a2612 1
    int slop;
a2637 1
    slop = numbytes * __GLX_SIZE_INT8 & 3;
d2641 1
a2641 1
        _XEatData(dpy, len);
d2644 1
a2644 3
        _XRead(dpy, (char *) be_buf, numbytes);
        if (slop)
            _XEatData(dpy, 4 - slop);
a2692 1
    int slop;
a2718 1
    slop = numbytes * __GLX_SIZE_INT8 & 3;
d2722 1
a2722 1
        _XEatData(dpy, len);
d2725 1
a2725 3
        _XRead(dpy, (char *) be_buf, numbytes);
        if (slop)
            _XEatData(dpy, 4 - slop);
a2764 2
    cl->GLClientmajorVersion = req->major;
    cl->GLClientminorVersion = req->minor;
d3241 1
a3241 1
    *pSendBuf++ = (int) (ctx->pFBConfig->renderType);
@


1.9
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d457 6
a462 6
    xGLXQueryMaxSwapBarriersSGIXReply reply;

    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = 0;
    reply.max = QueryMaxSwapBarriersSGIX(req->screen);
d468 1
a468 2
        WriteToClient(client, sz_xGLXQueryMaxSwapBarriersSGIXReply,
                      (char *) &reply);
d796 5
a800 1
    xGLXMakeCurrentReadSGIReply new_reply;
a1203 3
    new_reply.length = 0;
    new_reply.type = X_Reply;
    new_reply.sequenceNumber = client->sequence;
d1279 1
a1279 1
            if (!_XReply(dpy, (xReply *) & be_reply, 0, False)) {
d1334 1
a1334 1
                if (!_XReply(dpy, (xReply *) & be_new_reply, 0, False)) {
d1365 1
a1365 1
                if (!_XReply(dpy, (xReply *) & ext_reply, 0, False)) {
d1391 1
a1391 2
        WriteToClient(client, sz_xGLXMakeContextCurrentReply,
                      (char *) &new_reply);
d1442 6
a1447 4
    reply.isDirect = 0;
    reply.length = 0;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
d1453 1
a1453 1
        WriteToClient(client, sz_xGLXIsDirectReply, (char *) &reply);
a1464 1
    xGLXQueryVersionReply reply;
d1466 4
d1475 3
a1477 5
    reply.majorVersion = __glXVersionMajor;
    reply.minorVersion = __glXVersionMinor;
    reply.length = 0;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
d1483 1
a1483 1
        WriteToClient(client, sz_xGLXQueryVersionReply, (char *) &reply);
d1687 8
a1694 6
    reply.numVisuals = pGlxScreen->numGLXVisuals;
    reply.numProps = __GLX_TOTAL_CONFIG;
    reply.length = (pGlxScreen->numGLXVisuals * __GLX_SIZE_CARD32 *
                    __GLX_TOTAL_CONFIG) >> 2;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
d1696 1
a1696 1
    WriteToClient(client, sz_xGLXGetVisualConfigsReply, (char *) &reply);
d1750 1
a1750 2
        WriteToClient(client, __GLX_SIZE_CARD32 * __GLX_TOTAL_CONFIG,
                      (char *) buf);
d2180 1
a2180 1
            (void) _XReply(dpy, (xReply *) & reply, 0, False);
d2608 1
a2608 1
    _XReply(dpy, (xReply *) & be_reply, 0, False);
d2634 6
a2639 4
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = len;
    reply.n = numbytes;
d2645 2
a2646 3
        WriteToClient(client, sz_xGLXQueryExtensionsStringReply,
                      (char *) &reply);
        WriteToClient(client, (int) (length << 2), (char *) be_buf);
d2693 1
a2693 1
    _XReply(dpy, (xReply *) & be_reply, 0, False);
d2717 6
a2722 4
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = length;
    reply.n = numbytes;
d2728 1
a2728 1
        WriteToClient(client, sz_xGLXQueryServerStringReply, (char *) &reply);
d2876 7
a2882 5
    reply.numFBConfigs = numFBConfigs;
    reply.numAttribs = numAttribs;
    reply.length = (numFBConfigs * 2 * numAttribs * __GLX_SIZE_CARD32) >> 2;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
d2891 1
a2891 1
    WriteToClient(client, sz_xGLXGetFBConfigsReply, (char *) &reply);
d3032 1
a3032 1
        WriteToClient(client, 2 * numAttribs * __GLX_SIZE_CARD32, (char *) buf);
d3048 1
a3048 1
    return (__glXGetFBConfigs(cl, (GLbyte *) & new_req));
d3210 6
a3215 4
    reply.length = nProps << 1;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.n = nProps;
d3231 2
a3232 2
        WriteToClient(client, sz_xGLXQueryContextReply, (char *) &reply);
        WriteToClient(client, nReplyBytes, (char *) sendBuf);
d3262 6
a3267 4
    reply.length = nProps << 1;
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.n = nProps;
d3285 2
a3286 2
        WriteToClient(client, sz_xGLXQueryContextInfoEXTReply, (char *) &reply);
        WriteToClient(client, nReplyBytes, (char *) sendBuf);
d3594 1
a3594 1
    if (!_XReply(dpy, (xReply *) & reply, 0, False)) {
d3621 2
a3622 3
        WriteToClient(client, sz_xGLXGetDrawableAttributesReply,
                      (char *) &reply);
        WriteToClient(client, attribs_size, (char *) attribs);
@


1.8
log
@Bugfix Update to xserver 1.11.3
@
text
@d62 1
a62 1
extern int            __glXNumFBConfigs;
d64 2
a65 5
extern __GLXFBConfig *glxLookupFBConfig( GLXFBConfigID id );
extern __GLXFBConfig *glxLookupFBConfigByVID( VisualID vid );
extern __GLXFBConfig *glxLookupBackEndFBConfig( GLXFBConfigID id, int screen );
extern int glxIsExtensionSupported( char *ext );
extern int __glXGetFBConfigsSGIX(__GLXclientState *cl, GLbyte *pc);
d72 2
a73 1
Display *GetBackEndDisplay( __GLXclientState *cl, int s )
d75 49
a123 4
   if (! cl->be_displays[s] ) {
      cl->be_displays[s] = XOpenDisplay( DisplayString(dmxScreens[s].beDisplay) );
   }
   return cl->be_displays[s];
d129 5
a133 6
static int CreateContext(__GLXclientState *cl, 
                         GLXContextID gcId,
			 VisualID vid, GLXFBConfigID fbconfigId,
			 int screen,
			 GLXContextID shareList,
			 int isDirect )
d152 1
a152 1
    
d154 2
a155 2
    ** Check if screen exists.
    */
d157 2
a158 2
	client->errorValue = screen;
	return BadValue;
a160 1

d163 2
a164 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d173 9
a181 8
       shareglxc = NULL;
    } else {
       dixLookupResourceByType((pointer*) &shareglxc, shareList,
                               __glXContextRes, NullClient, DixUnknownAccess);
       if (!shareglxc) {
	  client->errorValue = shareList;
	  return __glXBadContext;
       }
d185 2
a186 2
    ** Allocate memory for the new context
    */
d189 1
a189 1
	return BadAlloc;
d196 7
a202 7
       glxc->pFBConfig = glxLookupFBConfig( fbconfigId );
       if (!glxc->pFBConfig) {
	  client->errorValue = fbconfigId;
	  free( glxc );
	  return BadValue;
       }
       visual = glxc->pFBConfig->associatedVisualId;
d205 1
a205 1
       glxc->pFBConfig = NULL;
d209 42
a250 42
       /*
	** Check if the visual ID is valid for this screen.
	*/
       pVisual = pScreen->visuals;
       for (i = 0; i < pScreen->numVisuals; i++, pVisual++) {
	  if (pVisual->vid == visual) {
	     break;
	  }
       }
       if (i == pScreen->numVisuals) {
	  client->errorValue = visual;
	  free( glxc );
	  return BadValue;
       }

       pGlxVisual = pGlxScreen->pGlxVisual;
       for (i = 0; i < pGlxScreen->numVisuals; i++, pGlxVisual++) {
	  if (pGlxVisual->vid == visual) {
	     break;
	  }
       }
       if (i == pGlxScreen->numVisuals) {
	  /*
	   ** Visual not support on this screen by this OpenGL implementation.
	   */
	  client->errorValue = visual;
	  free( glxc );
	  return BadValue;
       }

       if ( glxc->pFBConfig == NULL ) {
	   glxc->pFBConfig = glxLookupFBConfigByVID( visual );

	   if ( glxc->pFBConfig == NULL ) {
	      /*
               * visual does not have an FBConfig ???
	      client->errorValue = visual;
	      free( glxc );
	      return BadValue;
	       */
	   }
       }
d253 2
a254 2
       pVisual = NULL;
       pGlxVisual = NULL;
d266 1
a266 1
    glxc->real_ids = (XID *)malloc(sizeof(XID) * num_be_screens);
d268 1
a268 1
	return BadAlloc;
d270 1
a270 1
    glxc->real_vids = (XID *)malloc(sizeof(XID) * num_be_screens);
d272 1
a272 1
	return BadAlloc;
d276 136
a411 124
       int sent = 0;
       pScreen = screenInfo.screens[screen];
       pGlxScreen = &__glXActiveScreens[screen];
       dmxScreen = &dmxScreens[screen];

       if (glxc->pFBConfig) {
	  __GLXFBConfig *beFBConfig = glxLookupBackEndFBConfig( glxc->pFBConfig->id, 
		                                                screen );
	  be_fbconfigId = beFBConfig->id;
       }

       if (pGlxVisual) {

	  be_vid = glxMatchGLXVisualInConfigList( pGlxVisual,
	                                    dmxScreen->glxVisuals,
					    dmxScreen->numGlxVisuals  );

	  if (!be_vid) {
	     /* visual is not supported on the back-end server */
	     free( glxc->real_ids );
	     free( glxc->real_vids );
	     free( glxc );
	     return BadValue;
	  }
       }

       glxc->real_ids[screen-from_screen] = XAllocID(GetBackEndDisplay(cl,screen));

       /* send the create context request to the back-end server */
       dpy = GetBackEndDisplay(cl,screen);
       if (glxc->pFBConfig) {
	     /*Since for a certain visual both RGB and COLOR INDEX
	      *can be on then the only parmeter to choose the renderType
	      * should be the class of the colormap since all 4 first 
	      * classes does not support RGB mode only COLOR INDEX ,
	      * and so TrueColor and DirectColor does not support COLOR INDEX*/
	     int renderType =  glxc->pFBConfig->renderType;  
	     if ( pVisual ) {
		 switch ( pVisual->class ){
		     case PseudoColor:
                     case StaticColor:
                     case GrayScale:
                     case StaticGray:
                         renderType = GLX_COLOR_INDEX_TYPE;
                         break;
                     case TrueColor:
                     case DirectColor:
                     default:
                         renderType = GLX_RGBA_TYPE;
                     break;
		 }
	     }
	  if ( __GLX_IS_VERSION_SUPPORTED(1,3) ) {
	     LockDisplay(dpy);
	     GetReq(GLXCreateNewContext,be_new_req);
	     be_new_req->reqType = dmxScreen->glxMajorOpcode;
	     be_new_req->glxCode = X_GLXCreateNewContext;
	     be_new_req->context = (unsigned int)glxc->real_ids[screen-from_screen];
	     be_new_req->fbconfig = (unsigned int)be_fbconfigId;
	     be_new_req->screen = DefaultScreen(dpy);
	     be_new_req->renderType = renderType;  

	     be_new_req->shareList = (shareglxc ? shareglxc->real_ids[screen-from_screen] : 0);
	     be_new_req->isDirect = 0;
	     UnlockDisplay(dpy);
	     glxc->real_vids[screen-from_screen] = be_fbconfigId;
	     sent = 1;
	  }
	  else if (glxIsExtensionSupported("GLX_SGIX_fbconfig")) {

	     xGLXCreateContextWithConfigSGIXReq *ext_req;
	     xGLXVendorPrivateReq *vpreq;
	     LockDisplay(dpy);
	     GetReqExtra(GLXVendorPrivate,
		         sz_xGLXCreateContextWithConfigSGIXReq - sz_xGLXVendorPrivateReq,
			vpreq);
	     ext_req = (xGLXCreateContextWithConfigSGIXReq *)vpreq;
	     ext_req->reqType = dmxScreen->glxMajorOpcode;
	     ext_req->glxCode = X_GLXVendorPrivate;
	     ext_req->vendorCode = X_GLXvop_CreateContextWithConfigSGIX;
	     ext_req->context = (unsigned int)glxc->real_ids[screen-from_screen];
	     ext_req->fbconfig = (unsigned int)be_fbconfigId;
	     ext_req->screen = DefaultScreen(dpy);
	     ext_req->renderType = renderType;  
	     ext_req->shareList = (shareglxc ? shareglxc->real_ids[screen-from_screen] : 0);
	     ext_req->isDirect = 0;
	     UnlockDisplay(dpy);
	     glxc->real_vids[screen-from_screen] = be_fbconfigId;
	     sent = 1;
	  }
       }

       if (!sent) {
	  LockDisplay(dpy);
	  GetReq(GLXCreateContext,be_req);
	  be_req->reqType = dmxScreen->glxMajorOpcode;
	  be_req->glxCode = X_GLXCreateContext;
	  be_req->context = (unsigned int)glxc->real_ids[screen-from_screen];
	  be_req->visual = (unsigned int)be_vid;
	  be_req->screen = DefaultScreen(dpy);
	  be_req->shareList = (shareglxc ? shareglxc->real_ids[screen-from_screen] : 0);
	  be_req->isDirect = 0;
	  UnlockDisplay(dpy);
	  glxc->real_vids[screen-from_screen] = be_vid;
       }
       SyncHandle();

    }

    /*
    ** Register this context as a resource.
    */
    if (!AddResource(gcId, __glXContextRes, (pointer)glxc)) {
       free( glxc->real_ids );
       free( glxc->real_vids );
       free( glxc );
	client->errorValue = gcId;
	return BadAlloc;
    }
    
    /*
    ** Finally, now that everything is working, setup the rest of the
    ** context.
    */
d420 2
a421 1
int __glXCreateContext(__GLXclientState *cl, GLbyte *pc)
d425 2
a426 2
    return( CreateContext(cl, req->context,req->visual, None,
	                  req->screen, req->shareList, req->isDirect) );
d430 2
a431 1
int __glXCreateNewContext(__GLXclientState *cl, GLbyte *pc)
d435 2
a436 2
    return( CreateContext(cl, req->context,None, req->fbconfig,
	                  req->screen, req->shareList, req->isDirect) );
d440 2
a441 1
int __glXCreateContextWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)
d443 2
a444 1
    xGLXCreateContextWithConfigSGIXReq *req = (xGLXCreateContextWithConfigSGIXReq *) pc;
d446 2
a447 2
    return( CreateContext(cl, req->context, None, req->fbconfig,
	                  req->screen, req->shareList, req->isDirect) );
d451 2
a452 1
int __glXQueryMaxSwapBarriersSGIX(__GLXclientState *cl, GLbyte *pc)
d456 1
a456 1
	(xGLXQueryMaxSwapBarriersSGIXReq *)pc;
d465 5
a469 4
	__glXSwapQueryMaxSwapBarriersSGIXReply(client, &reply);
    } else {
	WriteToClient(client, sz_xGLXQueryMaxSwapBarriersSGIXReply,
		      (char *)&reply);
d475 2
a476 1
int __glXBindSwapBarrierSGIX(__GLXclientState *cl, GLbyte *pc)
d479 1
a479 1
    xGLXBindSwapBarrierSGIXReq *req = (xGLXBindSwapBarrierSGIXReq *)pc;
d487 4
a490 3
	dixLookupResourceByType((pointer*) &pGlxPixmap, req->drawable,
				__glXPixmapRes, NullClient, DixUnknownAccess);
	if (pGlxPixmap) pDraw = pGlxPixmap->pDraw;
d493 5
a497 4
    if (!pDraw && __GLX_IS_VERSION_SUPPORTED(1,3) ) {
       dixLookupResourceByType((pointer*) &pGlxWindow, req->drawable,
                               __glXWindowRes, NullClient, DixUnknownAccess);
       if (pGlxWindow) pDraw = pGlxWindow->pDraw;
d501 2
a502 2
       client->errorValue = req->drawable;
       return __glXBadDrawable;
d508 2
a509 1
int __glXJoinSwapGroupSGIX(__GLXclientState *cl, GLbyte *pc)
d512 1
a512 1
    xGLXJoinSwapGroupSGIXReq *req = (xGLXJoinSwapGroupSGIXReq *)pc;
d520 4
a523 3
	dixLookupResourceByType((pointer*) &pGlxPixmap, req->drawable,
				__glXPixmapRes, NullClient, DixUnknownAccess);
	if (pGlxPixmap) pDraw = pGlxPixmap->pDraw;
d526 5
a530 4
    if (!pDraw && __GLX_IS_VERSION_SUPPORTED(1,3) ) {
       dixLookupResourceByType((pointer*) &pGlxWindow, req->drawable,
                               __glXWindowRes, NullClient, DixUnknownAccess);
       if (pGlxWindow) pDraw = pGlxWindow->pDraw;
d534 2
a535 2
       client->errorValue = req->drawable;
       return __glXBadDrawable;
d539 4
a542 4
	rc = dixLookupDrawable(&pMember, req->member, client, 0,
			       DixGetAttrAccess);
	if (rc != Success) {
	    dixLookupResourceByType((pointer*) &pGlxPixmap, req->member,
d545 3
a547 2
	    if (pGlxPixmap) pMember = pGlxPixmap->pDraw;
	}
d549 2
a550 2
	if (!pMember && __GLX_IS_VERSION_SUPPORTED(1,3) ) {
	    dixLookupResourceByType((pointer*) &pGlxWindow, req->member,
d553 8
a560 7
	    if (pGlxWindow) pMember = pGlxWindow->pDraw;
	}

	if (!pMember) {
	    client->errorValue = req->member;
	    return __glXBadDrawable;
	}
a565 1

d569 2
a570 1
int __glXDestroyContext(__GLXclientState *cl, GLbyte *pc)
d580 3
a582 3
    
    dixLookupResourceByType((pointer*) &glxc, gcId, __glXContextRes,
			    NullClient, DixUnknownAccess);
d584 14
a597 13
	/*
	** Just free the resource; don't actually destroy the context,
	** because it might be in use.  The
	** destroy method will be called by the resource destruction routine
	** if necessary.
	*/
	FreeResourceByType(gcId, __glXContextRes, FALSE);

	from_screen = to_screen = glxc->pScreen->myNum;

    } else {
	client->errorValue = gcId;
	return __glXBadContext;
d602 2
a603 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d610 11
a620 11
    for (s=from_screen; s<=to_screen; s++) {
       DMXScreenInfo *dmxScreen = &dmxScreens[s];
       Display *dpy = GetBackEndDisplay(cl,s);

       LockDisplay(dpy);
       GetReq(GLXDestroyContext,be_req);
       be_req->reqType = dmxScreen->glxMajorOpcode;
       be_req->glxCode = X_GLXDestroyContext;
       be_req->context = glxc->real_ids[s-from_screen];
       UnlockDisplay(dpy);
       SyncHandle();
d637 2
a638 1
static int AddCurrentContext(__GLXclientState *cl, __GLXcontext *glxc, DrawablePtr pDraw)
d644 3
a646 2
    if (!glxc) return -1;
    
d648 7
a654 7
    ** Try to find an empty slot and use it.
    */
    for (i=0; i < num; i++) {
	if (!table[i]) {
	    table[i] = glxc;
	    return i+1;
	}
d657 2
a658 2
    ** Didn't find a free slot, so we'll have to grow the table.
    */
d660 18
a677 11
	table = (__GLXcontext **) malloc(sizeof(__GLXcontext *));
	cl->currentDrawables = (DrawablePtr *) malloc(sizeof(DrawablePtr));
	cl->be_currentCTag = (GLXContextTag *) malloc(screenInfo.numScreens *sizeof(GLXContextTag));
    } else {
	table = (__GLXcontext **) realloc(table,
					   (num+1)*sizeof(__GLXcontext *));
	cl->currentDrawables = (DrawablePtr *) realloc(
	                                          cl->currentDrawables ,
						  (num+1)*sizeof(DrawablePtr));
	cl->be_currentCTag = (GLXContextTag *) realloc(cl->be_currentCTag,
	            (num+1)*screenInfo.numScreens*sizeof(GLXContextTag));
d684 2
a685 2
    memset(cl->be_currentCTag + num*screenInfo.numScreens, 0, 
	         screenInfo.numScreens * sizeof(GLXContextTag));
d687 1
a687 1
    return num+1;
d693 3
a695 2
static void ChangeCurrentContext(__GLXclientState *cl, __GLXcontext *glxc,
				GLXContextTag tag)
d698 2
a699 1
    table[tag-1] = glxc;
d706 2
a707 1
int GetCurrentBackEndTag(__GLXclientState *cl, GLXContextTag tag, int s)
d709 6
a714 6
   if (tag >0) {
      return( cl->be_currentCTag[ (tag-1)*screenInfo.numScreens + s ] );
   }
   else {
      return 0;
   }
d721 3
a723 1
static void SetCurrentBackEndTag(__GLXclientState *cl, GLXContextTag tag, int s, GLXContextTag be_tag)
d725 3
a727 3
   if (tag >0) {
      cl->be_currentCTag[ (tag-1)*screenInfo.numScreens + s ] = be_tag;
   }
d735 2
a736 1
__GLXcontext *__glXLookupContextByTag(__GLXclientState *cl, GLXContextTag tag)
d741 4
a744 3
	return 0;
    } else {
	return cl->currentContexts[tag-1];
d748 2
a749 1
DrawablePtr __glXLookupDrawableByTag(__GLXclientState *cl, GLXContextTag tag)
d754 4
a757 3
	return 0;
    } else {
	return cl->currentDrawables[tag-1];
d763 2
a764 1
static void StopUsingContext(__GLXcontext *glxc)
d767 8
a774 8
	if (glxc == __glXLastContext) {
	    /* Tell server GL library */
	    __glXLastContext = 0;
	}
	glxc->isCurrent = GL_FALSE;
	if (!glxc->idExists) {
	    __glXFreeContext(glxc);
	}
d778 2
a779 1
static void StartUsingContext(__GLXclientState *cl, __GLXcontext *glxc)
d788 5
a792 5
static int MakeCurrent(__GLXclientState *cl,
                       GLXDrawable drawable,
                       GLXDrawable readdrawable,
		       GLXContextID context,
		       GLXContextTag oldContextTag)
d815 1
d825 2
a826 2
    ** If one is None and the other isn't, it's a bad match.
    */
d828 2
a829 2
	(drawId != None && contextId == None)) {
	return BadMatch;
d831 1
a831 1
    
d833 2
a834 2
    ** Lookup old context.  If we have one, it must be in a usable state.
    */
d836 10
a845 9
	prevglxc = __glXLookupContextByTag(cl, tag);
	if (!prevglxc) {
	    /*
	    ** Tag for previous context is invalid.
	    */
	    return __glXBadContextTag;
	}
    } else {
	prevglxc = 0;
d849 2
a850 2
    ** Lookup new context.  It must not be current for someone else.
    */
d852 14
a865 13
	dixLookupResourceByType((pointer*) &glxc, contextId, __glXContextRes,
				NullClient, DixUnknownAccess);
	if (!glxc) {
	    client->errorValue = contextId;
	    return __glXBadContext;
	}
	if ((glxc != prevglxc) && glxc->isCurrent) {
	    /* Context is current to somebody else */
	    return BadAccess;
	}
    } else {
	/* Switching to no context.  Ignore new drawable. */
	glxc = 0;
d869 36
a904 33
	rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixWriteAccess);
	if (rc == Success) {
	    if (pDraw->type == DRAWABLE_WINDOW) {
		/*
		** Drawable is an X Window.
		*/
	        VisualID vid;
		pWin = (WindowPtr)pDraw;
		vid = wVisual(pWin);

		new_reply.writeVid = (glxc->pFBConfig ? glxc->pFBConfig->id : vid);
		new_reply.writeType = GLX_WINDOW_TYPE;

		/*
		** Check if window and context are similar.
		*/
		if ((vid != glxc->pVisual->vid) ||
		    (pWin->drawable.pScreen != glxc->pScreen)) {
		    client->errorValue = drawId;
		    return BadMatch;
		}

		from_screen = to_screen = pWin->drawable.pScreen->myNum;

	    } else {
		/*
		** An X Pixmap is not allowed as a parameter (a GLX Pixmap
		** is, but it must first be created with glxCreateGLXPixmap).
		*/
		client->errorValue = drawId;
		return __glXBadDrawable;
	    }
	}
d907 28
a934 28
	    dixLookupResourceByType((pointer*) &pGlxPixmap, drawId,
				    __glXPixmapRes, NullClient,
				    DixUnknownAccess);
	    if (pGlxPixmap) {
		/*
		** Check if pixmap and context are similar.
		*/
		if (pGlxPixmap->pScreen != glxc->pScreen ||
		    pGlxPixmap->pGlxVisual != glxc->pGlxVisual) {
		    client->errorValue = drawId;
		    return BadMatch;
		}
		pDraw = pGlxPixmap->pDraw;

		new_reply.writeVid = (glxc->pFBConfig ? glxc->pFBConfig->id : 
		                      pGlxPixmap->pGlxVisual->vid);

		new_reply.writeType = GLX_PIXMAP_TYPE;

		from_screen = to_screen = pGlxPixmap->pScreen->myNum;

	    }
	}

	if (!pDraw && __GLX_IS_VERSION_SUPPORTED(1,3) ) {
	   dixLookupResourceByType((pointer*) &pGlxWindow, drawId,
                                   __glXWindowRes, NullClient,
                                   DixUnknownAccess);
d937 4
a940 4
                ** Drawable is a GLXWindow.
                **
                ** Check if GLX window and context are similar.
                */
d952 1
a952 1
	}
d954 5
a958 5
	if (!pDraw && __GLX_IS_VERSION_SUPPORTED(1,3) ) {
	   dixLookupResourceByType((pointer*) &pGlxPbuffer, drawId,
                                   __glXPbufferRes, NullClient,
                                   DixUnknownAccess);
	   if (pGlxPbuffer) {
d965 1
a965 1
		pDraw = (DrawablePtr)pGlxPbuffer;
d968 40
a1007 2
	   }
	}
d1009 38
a1046 72
	if (!pDraw) {
	   /*
    	    ** Drawable is not a Window , GLXWindow or a GLXPixmap.
	    */
	   client->errorValue = drawId;
	   return __glXBadDrawable;
	}

    } else {
	pDraw = 0;
    }

    if (readId != None && readId != drawId ) {
	rc = dixLookupDrawable(&pReadDraw, readId, client, 0, DixReadAccess);
	if (rc == Success) {
	    if (pReadDraw->type == DRAWABLE_WINDOW) {
		/*
		** Drawable is an X Window.
		*/
	        VisualID vid;
		pReadWin = (WindowPtr)pDraw;
		vid = wVisual(pReadWin);

		new_reply.readVid = (glxc->pFBConfig ? glxc->pFBConfig->id : vid);
		new_reply.readType = GLX_WINDOW_TYPE;

		/*
		** Check if window and context are similar.
		*/
		if ((vid != glxc->pVisual->vid) ||
		    (pReadWin->drawable.pScreen != glxc->pScreen)) {
		    client->errorValue = readId;
		    return BadMatch;
		}

	    } else {

		/*
		** An X Pixmap is not allowed as a parameter (a GLX Pixmap
		** is, but it must first be created with glxCreateGLXPixmap).
		*/
		client->errorValue = readId;
		return __glXBadDrawable;
	    }
	}

	if (!pReadDraw) {
	    dixLookupResourceByType((pointer*) &pReadGlxPixmap, readId,
				    __glXPixmapRes, NullClient,
				    DixUnknownAccess);
	    if (pReadGlxPixmap) {
		/*
		** Check if pixmap and context are similar.
		*/
		if (pReadGlxPixmap->pScreen != glxc->pScreen ||
		    pReadGlxPixmap->pGlxVisual != glxc->pGlxVisual) {
		    client->errorValue = readId;
		    return BadMatch;
		}
		pReadDraw = pReadGlxPixmap->pDraw;

		new_reply.readVid = (glxc->pFBConfig ? glxc->pFBConfig->id :
		                     pReadGlxPixmap->pGlxVisual->vid );
		new_reply.readType = GLX_PIXMAP_TYPE;

	    }
	}

	if (!pReadDraw && __GLX_IS_VERSION_SUPPORTED(1,3) ) {
	   dixLookupResourceByType((pointer*) &pGlxReadWindow, readId,
                                   __glXWindowRes, NullClient,
                                   DixUnknownAccess);
d1049 4
a1052 4
                ** Drawable is a GLXWindow.
                **
                ** Check if GLX window and context are similar.
                */
d1063 1
a1063 1
	}
d1065 5
a1069 5
	if (!pReadDraw && __GLX_IS_VERSION_SUPPORTED(1,3) ) {
	   dixLookupResourceByType((pointer*) &pGlxReadPbuffer, readId,
                                   __glXPbufferRes, NullClient,
                                   DixUnknownAccess);
	   if (pGlxReadPbuffer) {
d1076 1
a1076 1
		pReadDraw = (DrawablePtr)pGlxReadPbuffer;
d1079 10
a1088 2
	   }
	}
d1090 7
a1096 14
	if (!pReadDraw) {
	   /*
    	    ** Drawable is neither a Window nor a GLXPixmap.
	    */
	   client->errorValue = readId;
	   return __glXBadDrawable;
	}

    } else {
	pReadDraw = pDraw;
	pReadGlxPixmap = pGlxPixmap;
	pReadWin = pWin;
	new_reply.readVid = new_reply.writeVid;
	new_reply.readType = new_reply.writeType;
d1101 60
a1160 59
	if (prevglxc->pGlxPixmap) {
	    /*
	    ** The previous drawable was a glx pixmap, release it.
	    */
	    prevglxc->pGlxPixmap->refcnt--;
	    __glXFreeGLXPixmap( prevglxc->pGlxPixmap );
	    prevglxc->pGlxPixmap = 0;
	}

	if (prevglxc->pGlxReadPixmap) {
	    /*
	    ** The previous drawable was a glx pixmap, release it.
	    */
	    prevglxc->pGlxReadPixmap->refcnt--;
	    __glXFreeGLXPixmap( prevglxc->pGlxReadPixmap );
	    prevglxc->pGlxReadPixmap = 0;
	}

	if (prevglxc->pGlxWindow) {
	    /*
	    ** The previous drawable was a glx window, release it.
	    */
	    prevglxc->pGlxWindow->refcnt--;
	    __glXFreeGLXWindow( prevglxc->pGlxWindow );
	    prevglxc->pGlxWindow = 0;   
	}

	if (prevglxc->pGlxReadWindow) {
	    /*
	    ** The previous drawable was a glx window, release it.
	    */
	    prevglxc->pGlxReadWindow->refcnt--;
	    __glXFreeGLXWindow( prevglxc->pGlxReadWindow );
	    prevglxc->pGlxReadWindow = 0;   
	}

	if (prevglxc->pGlxPbuffer) {
	    /*
	    ** The previous drawable was a glx Pbuffer, release it.
	    */
	    prevglxc->pGlxPbuffer->refcnt--;
	    __glXFreeGLXPbuffer( prevglxc->pGlxPbuffer );
	    prevglxc->pGlxPbuffer = 0;   
	}

	if (prevglxc->pGlxReadPbuffer) {
	    /*
	    ** The previous drawable was a glx Pbuffer, release it.
	    */
	    prevglxc->pGlxReadPbuffer->refcnt--;
	    __glXFreeGLXPbuffer( prevglxc->pGlxReadPbuffer );
	    prevglxc->pGlxReadPbuffer = 0;   
	}

	ChangeCurrentContext(cl, glxc, tag);
	ChangeCurrentContext(cl, glxc, tag);
	StopUsingContext(prevglxc);
    } else {
	tag = AddCurrentContext(cl, glxc, pDraw);
d1164 36
a1199 35
       glxc->pGlxPixmap = pGlxPixmap;
       glxc->pGlxReadPixmap = pReadGlxPixmap;
       glxc->pGlxWindow = pGlxWindow;
       glxc->pGlxReadWindow = pGlxReadWindow;
       glxc->pGlxPbuffer = pGlxPbuffer;
       glxc->pGlxReadPbuffer = pGlxReadPbuffer;

	if (pGlxPixmap) {
	    pGlxPixmap->refcnt++;
	}

	if (pReadGlxPixmap) {
	    pReadGlxPixmap->refcnt++;
	}

	if (pGlxWindow) {
	   pGlxWindow->refcnt++;
	}

	if (pGlxReadWindow) {
	   pGlxReadWindow->refcnt++;
	}

	if (pGlxPbuffer) {
	   pGlxPbuffer->refcnt++;
	}

	if (pGlxReadPbuffer) {
	   pGlxReadPbuffer->refcnt++;
	}

	StartUsingContext(cl, glxc);
	new_reply.contextTag = tag;
    } else {
	new_reply.contextTag = 0;
d1207 2
a1208 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d1210 15
a1224 15
       if (pDraw && new_reply.writeType != GLX_PBUFFER_TYPE) {
	  dixLookupResourceByClass((pointer*) &pXinDraw,
				   pDraw->id, XRC_DRAWABLE,
				   client, DixReadAccess);
       }

       if (pReadDraw && pReadDraw != pDraw && 
	     new_reply.readType != GLX_PBUFFER_TYPE) {
	  dixLookupResourceByClass((pointer*) &pXinReadDraw,
				   pReadDraw->id, XRC_DRAWABLE,
				   client, DixReadAccess);
       }
       else {
	  pXinReadDraw = pXinDraw;
       }
a1227 1

d1231 152
a1382 147
    for (s = from_screen; s<=to_screen; s++) {
       DMXScreenInfo *dmxScreen = &dmxScreens[s];
       Display *dpy = GetBackEndDisplay(cl,s);
       unsigned int be_draw = None;
       unsigned int be_read_draw = None;

       if (pGlxPixmap) {
	   be_draw = pGlxPixmap->be_xids[s];
       }
       else if (pGlxPbuffer) {
	  be_draw = pGlxPbuffer->be_xids[s];
       }
#ifdef PANORAMIX
       else if (pXinDraw) {
	  dixLookupWindow(&pWin, pXinDraw->info[s].id, client, DixReadAccess);
       }
#endif
       else if (pGlxWindow) {
	  pWin = (WindowPtr)pGlxWindow->pDraw;
       }

       if (pWin && be_draw == None) {
	   be_draw = (unsigned int)(DMX_GET_WINDOW_PRIV(pWin))->window;
	   if (!be_draw) {
	      /* it might be that the window did not created yet on the */
	      /* back-end server (lazy window creation option), force   */
	      /* creation of the window */
	      dmxCreateAndRealizeWindow( pWin, TRUE );
	      be_draw = (unsigned int)(DMX_GET_WINDOW_PRIV(pWin))->window;
	   }
       }

       /*
	* Before sending the MakeCurrent request - sync the
	* X11 connection to the back-end servers to make sure
	* that drawable is already created
	*/
       dmxSync( dmxScreen, 1 ); 

       if (drawId == readId) {
	  LockDisplay(dpy);
	  GetReq(GLXMakeCurrent, be_req);
	  be_req->reqType = dmxScreen->glxMajorOpcode;
	  be_req->glxCode = X_GLXMakeCurrent;
	  be_req->drawable = be_draw;
	  be_req->context = (unsigned int)(glxc ? glxc->real_ids[s-from_screen] : 0);
	  be_req->oldContextTag = GetCurrentBackEndTag(cl, tag, s);
	  if (!_XReply(dpy, (xReply *) &be_reply, 0, False)) {

	     /* The make current failed */
	     UnlockDisplay(dpy);
	     SyncHandle();
	     return( BE_TO_CLIENT_ERROR(dmxLastErrorEvent.error_code) );
	  }

	  UnlockDisplay(dpy);
       	  SyncHandle();

	  SetCurrentBackEndTag( cl, tag, s, be_reply.contextTag );
       }
       else {

	  if (pReadGlxPixmap) {
	     be_read_draw = pReadGlxPixmap->be_xids[s];
	  }
	  else if (pGlxReadPbuffer) {
	     be_read_draw = pGlxReadPbuffer->be_xids[s];
	  }
#ifdef PANORAMIX
	  else if (pXinReadDraw) {
	     dixLookupWindow(&pReadWin, pXinReadDraw->info[s].id, client,
			     DixReadAccess);
   	  }
#endif
	  else if (pGlxReadWindow) {
	     pReadWin = (WindowPtr)pGlxReadWindow->pDraw;
	  }

      	  if (pReadWin && be_read_draw == None) {
  	     be_read_draw = (unsigned int)(DMX_GET_WINDOW_PRIV(pReadWin))->window;
	   if (!be_read_draw) {
	      /* it might be that the window did not created yet on the */
	      /* back-end server (lazy window creation option), force   */
	      /* creation of the window */
	      dmxCreateAndRealizeWindow( pReadWin, TRUE );
	      be_read_draw = (unsigned int)(DMX_GET_WINDOW_PRIV(pReadWin))->window;
              dmxSync( dmxScreen, 1 ); 
	   }
     	  }

	  if ( __GLX_IS_VERSION_SUPPORTED(1,3) ) {
	     LockDisplay(dpy);
	     GetReq(GLXMakeContextCurrent, be_new_req);
	     be_new_req->reqType = dmxScreen->glxMajorOpcode;
	     be_new_req->glxCode = X_GLXMakeContextCurrent;
	     be_new_req->drawable = be_draw;
	     be_new_req->readdrawable = be_read_draw;
	     be_new_req->context = (unsigned int)(glxc ? glxc->real_ids[s-from_screen] : 0);
	     be_new_req->oldContextTag = GetCurrentBackEndTag(cl, tag, s);
	     if (!_XReply(dpy, (xReply *) &be_new_reply, 0, False)) {

		/* The make current failed */
		UnlockDisplay(dpy);
   		SyncHandle();
   		return( BE_TO_CLIENT_ERROR(dmxLastErrorEvent.error_code) );
   	     }

   	     UnlockDisplay(dpy);
      	     SyncHandle();

   	     SetCurrentBackEndTag( cl, tag, s, be_new_reply.contextTag );
	  }
	  else if (glxIsExtensionSupported("GLX_SGI_make_current_read")) {
	     xGLXMakeCurrentReadSGIReq *ext_req;
	     xGLXVendorPrivateWithReplyReq *vpreq;
             xGLXMakeCurrentReadSGIReply ext_reply;

	     LockDisplay(dpy);
	     GetReqExtra(GLXVendorPrivateWithReply, 
		         sz_xGLXMakeCurrentReadSGIReq - sz_xGLXVendorPrivateWithReplyReq,
		         vpreq);
	     ext_req = (xGLXMakeCurrentReadSGIReq *)vpreq;
	     ext_req->reqType = dmxScreen->glxMajorOpcode;
	     ext_req->glxCode = X_GLXVendorPrivateWithReply;
	     ext_req->vendorCode = X_GLXvop_MakeCurrentReadSGI;
	     ext_req->drawable = be_draw;
	     ext_req->readable = be_read_draw;
	     ext_req->context = (unsigned int)(glxc ? glxc->real_ids[s-from_screen] : 0);
	     ext_req->oldContextTag = GetCurrentBackEndTag(cl, tag, s);
	     if (!_XReply(dpy, (xReply *) &ext_reply, 0, False)) {

		/* The make current failed */
		UnlockDisplay(dpy);
   		SyncHandle();
   		return( BE_TO_CLIENT_ERROR(dmxLastErrorEvent.error_code) );
   	     }

   	     UnlockDisplay(dpy);
      	     SyncHandle();

   	     SetCurrentBackEndTag( cl, tag, s, ext_reply.contextTag );

	  }
	  else {
	     return BadMatch;
	  }
       }
d1384 1
a1384 1
       XFlush( dpy );
d1388 5
a1392 3
	__glXSwapMakeCurrentReply(client, &new_reply);
    } else {
	WriteToClient(client, sz_xGLXMakeContextCurrentReply, (char *)&new_reply);
d1398 2
a1399 1
int __glXMakeCurrent(__GLXclientState *cl, GLbyte *pc)
d1403 2
a1404 2
    return( MakeCurrent(cl, req->drawable, req->drawable,
	                req->context, req->oldContextTag ) );
d1407 2
a1408 1
int __glXMakeContextCurrent(__GLXclientState *cl, GLbyte *pc)
d1412 2
a1413 2
    return( MakeCurrent(cl, req->drawable, req->readdrawable,
	                req->context, req->oldContextTag ) );
d1416 2
a1417 1
int __glXMakeCurrentReadSGI(__GLXclientState *cl, GLbyte *pc)
d1421 2
a1422 2
    return( MakeCurrent(cl, req->drawable, req->readable,
	                req->context, req->oldContextTag ) );
d1425 2
a1426 1
int __glXIsDirect(__GLXclientState *cl, GLbyte *pc)
d1434 3
a1436 3
    ** Find the GL context.
    */
    dixLookupResourceByType((pointer*) &glxc, req->context, __glXContextRes,
d1439 2
a1440 2
	client->errorValue = req->context;
	return __glXBadContext;
d1449 4
a1452 3
	__glXSwapIsDirectReply(client, &reply);
    } else {
	WriteToClient(client, sz_xGLXIsDirectReply, (char *)&reply);
d1458 2
a1459 1
int __glXQueryVersion(__GLXclientState *cl, GLbyte *pc)
d1462 1
d1467 4
a1470 4
    ** Server should take into consideration the version numbers sent by the
    ** client if it wants to work with older clients; however, in this
    ** implementation the server just returns its version number.
    */
d1478 4
a1481 3
	__glXSwapQueryVersionReply(client, &reply);
    } else {
	WriteToClient(client, sz_xGLXQueryVersionReply, (char *)&reply);
d1486 2
a1487 1
int __glXWaitGL(__GLXclientState *cl, GLbyte *pc)
d1489 2
a1490 2
    xGLXWaitGLReq *req = (xGLXWaitGLReq *)pc;
    xGLXWaitGLReq *be_req = (xGLXWaitGLReq *)pc;
d1495 1
a1495 1
    
d1497 4
a1500 4
	glxc = __glXLookupContextByTag(cl, req->contextTag);
	if (glxc) {
	   from_screen = to_screen = glxc->pScreen->myNum;
	}
d1505 2
a1506 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d1510 3
a1512 3
    for (s=from_screen; s<=to_screen; s++) {
       DMXScreenInfo *dmxScreen = &dmxScreens[s];
       Display *dpy = GetBackEndDisplay(cl,s);
d1514 8
a1521 7
       LockDisplay(dpy);
       GetReq(GLXWaitGL,be_req);
       be_req->reqType = dmxScreen->glxMajorOpcode;
       be_req->glxCode = X_GLXWaitGL;
       be_req->contextTag = (glxc ? GetCurrentBackEndTag(cl,req->contextTag,s) : 0);
       UnlockDisplay(dpy);
       SyncHandle();
d1523 1
a1523 1
       XSync(dpy, False);
d1525 1
a1525 1
    
d1529 2
a1530 1
int __glXWaitX(__GLXclientState *cl, GLbyte *pc)
d1532 1
a1532 1
    xGLXWaitXReq *req = (xGLXWaitXReq *)pc;
d1538 1
a1538 1
    
d1540 4
a1543 4
	glxc = __glXLookupContextByTag(cl, req->contextTag);
	if (glxc) {
	   from_screen = to_screen = glxc->pScreen->myNum;
	}
d1548 2
a1549 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d1553 3
a1555 3
    for (s=from_screen; s<=to_screen; s++) {
       DMXScreenInfo *dmxScreen = &dmxScreens[s];
       Display *dpy = GetBackEndDisplay(cl,s);
d1557 1
a1557 1
       dmxSync( dmxScreen, 1 );
d1559 8
a1566 7
       LockDisplay(dpy);
       GetReq(GLXWaitX,be_req);
       be_req->reqType = dmxScreen->glxMajorOpcode;
       be_req->glxCode = X_GLXWaitX;
       be_req->contextTag = (glxc ? GetCurrentBackEndTag(cl,req->contextTag,s) : 0);
       UnlockDisplay(dpy);
       SyncHandle();
d1568 1
a1568 1
       XFlush( dpy );
d1574 2
a1575 1
int __glXCopyContext(__GLXclientState *cl, GLbyte *pc)
d1590 3
a1592 3
    ** Check that each context exists.
    */
    dixLookupResourceByType((pointer*) &src, source, __glXContextRes,
d1595 2
a1596 2
	client->errorValue = source;
	return __glXBadContext;
d1598 1
a1598 1
    dixLookupResourceByType((pointer*) &dst, dest, __glXContextRes,
d1601 2
a1602 2
	client->errorValue = dest;
	return __glXBadContext;
d1606 2
a1607 2
    ** They must be in the same address space, and same screen.
    */
d1609 2
a1610 2
	client->errorValue = source;
	return BadMatch;
d1614 2
a1615 2
    ** The destination context must not be current for any client.
    */
d1617 2
a1618 2
	client->errorValue = dest;
	return BadAccess;
d1622 12
a1633 12
	__GLXcontext *tagcx = __glXLookupContextByTag(cl, tag);
	
	if (!tagcx) {
	    return __glXBadContextTag;
	}
	if (tagcx != src) {
	    /*
	    ** This would be caused by a faulty implementation of the client
	    ** library.
	    */
	    return BadMatch;
	}
d1640 2
a1641 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d1645 3
a1647 3
    for (s=from_screen; s<=to_screen; s++) {
       DMXScreenInfo *dmxScreen = &dmxScreens[s];
       Display *dpy = GetBackEndDisplay(cl,s);
d1649 11
a1659 10
       LockDisplay(dpy);
       GetReq(GLXCopyContext,be_req);
       be_req->reqType = dmxScreen->glxMajorOpcode;
       be_req->glxCode = X_GLXCopyContext;
       be_req->source = (unsigned int)src->real_ids[s-from_screen];
       be_req->dest = (unsigned int)dst->real_ids[s-from_screen];
       be_req->mask = mask;
       be_req->contextTag = (tag ? GetCurrentBackEndTag(cl,req->contextTag,s) : 0);
       UnlockDisplay(dpy);
       SyncHandle();
d1665 2
a1666 1
int __glXGetVisualConfigs(__GLXclientState *cl, GLbyte *pc)
d1679 3
a1681 3
	/* The client library must send a valid screen number. */
	client->errorValue = screen;
	return BadValue;
d1688 1
a1688 1
		    __GLX_TOTAL_CONFIG) >> 2;
d1692 1
a1692 1
    WriteToClient(client, sz_xGLXGetVisualConfigsReply, (char *)&reply);
d1694 51
a1744 51
    for (i=0; i < pGlxScreen->numVisuals; i++) {
	pGlxVisual = &pGlxScreen->pGlxVisual[i];
	if (!pGlxScreen->isGLXvis[i] || pGlxVisual->vid == 0) {
	    /* not a usable visual */
	    continue;
	}
	p = 0;
	buf[p++] = pGlxVisual->vid;
	buf[p++] = pGlxVisual->class;
	buf[p++] = pGlxVisual->rgba;

	buf[p++] = pGlxVisual->redSize;
	buf[p++] = pGlxVisual->greenSize;
	buf[p++] = pGlxVisual->blueSize;
	buf[p++] = pGlxVisual->alphaSize;
	buf[p++] = pGlxVisual->accumRedSize;
	buf[p++] = pGlxVisual->accumGreenSize;
	buf[p++] = pGlxVisual->accumBlueSize;
	buf[p++] = pGlxVisual->accumAlphaSize;

	buf[p++] = pGlxVisual->doubleBuffer;
	buf[p++] = pGlxVisual->stereo;

	buf[p++] = pGlxVisual->bufferSize;
	buf[p++] = pGlxVisual->depthSize;
	buf[p++] = pGlxVisual->stencilSize;
	buf[p++] = pGlxVisual->auxBuffers;
	buf[p++] = pGlxVisual->level;
	/* 
	** Add token/value pairs for extensions.
	*/
	buf[p++] = GLX_VISUAL_CAVEAT_EXT;
	buf[p++] = pGlxVisual->visualRating;
	buf[p++] = GLX_TRANSPARENT_TYPE_EXT;
	buf[p++] = pGlxVisual->transparentPixel;
	buf[p++] = GLX_TRANSPARENT_RED_VALUE_EXT;
	buf[p++] = pGlxVisual->transparentRed;
	buf[p++] = GLX_TRANSPARENT_GREEN_VALUE_EXT;
	buf[p++] = pGlxVisual->transparentGreen;
	buf[p++] = GLX_TRANSPARENT_BLUE_VALUE_EXT;
	buf[p++] = pGlxVisual->transparentBlue;
	buf[p++] = GLX_TRANSPARENT_ALPHA_VALUE_EXT;
	buf[p++] = pGlxVisual->transparentAlpha;
	buf[p++] = GLX_TRANSPARENT_INDEX_VALUE_EXT;
	buf[p++] = pGlxVisual->transparentIndex;
	buf[p++] = GLX_SAMPLES_SGIS;
	buf[p++] = pGlxVisual->multiSampleSize;
	buf[p++] = GLX_SAMPLE_BUFFERS_SGIS;
	buf[p++] = pGlxVisual->nMultiSampleBuffers;
	buf[p++] = GLX_VISUAL_SELECT_GROUP_SGIX;
	buf[p++] = pGlxVisual->visualSelectGroup;
d1746 2
a1747 2
	WriteToClient(client, __GLX_SIZE_CARD32 * __GLX_TOTAL_CONFIG, 
		(char *)buf);
d1755 4
a1758 3
static int CreateGLXPixmap(__GLXclientState *cl,
                    VisualID visual, GLXFBConfigID fbconfigId,
		    int screenNum, XID pixmapId, XID glxpixmapId )
d1772 1
d1778 1
a1778 1
			   DixAddAccess);
d1780 1
a1780 1
	return rc;
d1783 2
a1784 2
    ** Check if screen of visual matches screen of pixmap.
    */
d1787 1
a1787 1
	return BadMatch;
d1791 1
a1791 1
	  return BadValue;
d1795 6
a1800 6
       pFBConfig = glxLookupFBConfig( fbconfigId );
       if (!pFBConfig) {
	  client->errorValue = fbconfigId;
	  return BadValue;
       }
       visual = pFBConfig->associatedVisualId;
d1803 1
a1803 1
       pFBConfig = NULL;
d1807 56
a1862 57
       /*
	** Find the VisualRec for this visual.
	*/
       pVisual = pScreen->visuals;
       for (i=0; i < pScreen->numVisuals; i++, pVisual++) {
	  if (pVisual->vid == visual) {
	     break;
	  }
       }
       if (i == pScreen->numVisuals) {
	  client->errorValue = visual;
	  return BadValue;
       }
       /*
	** Check if depth of visual matches depth of pixmap.
	*/
       if (pVisual->nplanes != pDraw->depth) {
	  client->errorValue = visual;
	  return BadMatch;
       }

       /*
	** Get configuration of the visual.
	*/
       pGlxScreen = &__glXActiveScreens[screenNum];
       pGlxVisual = pGlxScreen->pGlxVisual;
       for (i = 0; i < pGlxScreen->numVisuals; i++, pGlxVisual++) {
	  if (pGlxVisual->vid == visual) {
	     break;
	  }
       }
       if (i == pGlxScreen->numVisuals) {
	  /*
	   ** Visual not support on this screen by this OpenGL implementation.
	   */
	  client->errorValue = visual;
	  return BadValue;
       }


       /* find the FBConfig for that visual (if any) */
       if ( pFBConfig == NULL ) {
	   pFBConfig = glxLookupFBConfigByVID( visual );

	   if ( pFBConfig == NULL ) {
	      /*
               * visual does not have an FBConfig ???
	      client->errorValue = visual;
	      return BadValue;
	       */
	   }
       }
    }
    else {
       pVisual = NULL;
       pGlxVisual = NULL;
       pGlxScreen = &__glXActiveScreens[pDraw->pScreen->myNum];
d1867 1
a1867 1
	return BadAlloc;
d1871 2
a1872 2
        free( pGlxPixmap );
	return BadAlloc;
d1884 2
a1885 2
    ** Bump the ref count on the X pixmap so it won't disappear.
    */
d1894 2
a1895 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d1897 87
a1983 83
       dixLookupResourceByClass((pointer*) &pXinDraw,
				pDraw->id, XRC_DRAWABLE,
				client, DixReadAccess);
    }
#endif

    for (s=from_screen; s<=to_screen; s++) {

       DMXScreenInfo *dmxScreen = &dmxScreens[s];
       Display *dpy = GetBackEndDisplay(cl,s);
       Pixmap  be_pixmap;
       DrawablePtr pRealDraw = pDraw;

#ifdef PANORAMIX
       if (pXinDraw) {
	   dixLookupDrawable(&pRealDraw, pXinDraw->info[s].id, client, 0,
			     DixAddAccess);
       }
#endif

       be_pixmap = (DMX_GET_PIXMAP_PRIV((PixmapPtr)pRealDraw))->pixmap;

       /* make sure pixmap already created on back-end */
       dmxSync( dmxScreen, 1 );

       if ( pFBConfig && __GLX_IS_VERSION_SUPPORTED(1,3) ) {
       	  __GLXFBConfig *be_FBConfig = glxLookupBackEndFBConfig( pFBConfig->id, s );
	  
	  LockDisplay(dpy);
	  pGlxPixmap->be_xids[s] = XAllocID(dpy);
	  GetReq(GLXCreatePixmap,be_new_req);
	  be_new_req->reqType = dmxScreen->glxMajorOpcode;
	  be_new_req->glxCode = X_GLXCreatePixmap;
	  be_new_req->screen = DefaultScreen(dpy);
	  be_new_req->fbconfig = be_FBConfig->id;
	  be_new_req->pixmap = (unsigned int)be_pixmap;
	  be_new_req->glxpixmap = (unsigned int)pGlxPixmap->be_xids[s];
	  be_new_req->numAttribs = 0;
	  UnlockDisplay(dpy);
	  SyncHandle();
       }
       else if (pFBConfig && glxIsExtensionSupported("GLX_SGIX_fbconfig")) {
	  __GLXFBConfig *be_FBConfig = glxLookupBackEndFBConfig( pFBConfig->id, s );
	  xGLXCreateGLXPixmapWithConfigSGIXReq *ext_req;
	  xGLXVendorPrivateReq *vpreq;
	  
	  LockDisplay(dpy);
	  pGlxPixmap->be_xids[s] = XAllocID(dpy);
	  GetReqExtra(GLXVendorPrivate,
		      sz_xGLXCreateGLXPixmapWithConfigSGIXReq-sz_xGLXVendorPrivateReq,
		      vpreq);
	  ext_req = (xGLXCreateGLXPixmapWithConfigSGIXReq *)vpreq;
	  ext_req->reqType = dmxScreen->glxMajorOpcode;
	  ext_req->glxCode = X_GLXVendorPrivate;
	  ext_req->vendorCode = X_GLXvop_CreateGLXPixmapWithConfigSGIX;
	  ext_req->screen = DefaultScreen(dpy);
	  ext_req->fbconfig = be_FBConfig->id;
	  ext_req->pixmap = (unsigned int)be_pixmap;
	  ext_req->glxpixmap = (unsigned int)pGlxPixmap->be_xids[s];
	  UnlockDisplay(dpy);
	  SyncHandle();
       }
       else if (pGlxVisual) {
	  LockDisplay(dpy);
	  pGlxPixmap->be_xids[s] = XAllocID(dpy);
	  GetReq(GLXCreateGLXPixmap,be_req);
	  be_req->reqType = dmxScreen->glxMajorOpcode;
	  be_req->glxCode = X_GLXCreateGLXPixmap;
	  be_req->screen = DefaultScreen(dpy);
	  be_req->visual = (unsigned int)glxMatchGLXVisualInConfigList( 
	 	pGlxVisual,
		dmxScreen->glxVisuals,
		dmxScreen->numGlxVisuals );
   	  be_req->pixmap = (unsigned int)be_pixmap;
      	  be_req->glxpixmap = (unsigned int)pGlxPixmap->be_xids[s];
	  UnlockDisplay(dpy);
	  SyncHandle();
       }
       else {
	  client->errorValue = ( visual ? visual : fbconfigId );
          free( pGlxPixmap );
	  return BadValue;
       }
d1985 1
a1985 1
       XFlush( dpy );
d1989 2
a1990 2
        free( pGlxPixmap );
	return BadAlloc;
d1996 2
a1997 1
int __glXCreateGLXPixmap(__GLXclientState *cl, GLbyte *pc)
d2001 2
a2002 2
    return( CreateGLXPixmap(cl, req->visual, None,
	                    req->screen, req->pixmap, req->glxpixmap) );
d2005 2
a2006 1
int __glXCreatePixmap(__GLXclientState *cl, GLbyte *pc)
d2010 2
a2011 2
    return( CreateGLXPixmap(cl, None, req->fbconfig,
	                    req->screen, req->pixmap, req->glxpixmap) );
d2014 2
a2015 1
int __glXDestroyGLXPixmap(__GLXclientState *cl, GLbyte *pc)
d2025 3
a2027 3
    ** Check if it's a valid GLX pixmap.
    */
    dixLookupResourceByType((pointer*) &pGlxPixmap, glxpixmap,
d2030 2
a2031 2
	client->errorValue = glxpixmap;
	return __glXBadPixmap;
d2041 2
a2042 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d2046 3
a2048 3
    for (s=from_screen; s<=to_screen; s++) {
       DMXScreenInfo *dmxScreen = &dmxScreens[s];
       Display *dpy = GetBackEndDisplay(cl,s);
d2050 2
a2051 2
       /* make sure pixmap exist in back-end */
       dmxSync( dmxScreen, 1 );
d2053 7
a2059 7
       LockDisplay(dpy);
       GetReq(GLXDestroyGLXPixmap,req);
       req->reqType = dmxScreen->glxMajorOpcode;
       req->glxCode = X_GLXDestroyGLXPixmap;
       req->glxpixmap = (unsigned int)pGlxPixmap->be_xids[s];
       UnlockDisplay(dpy);
       SyncHandle();
a2061 1
    
d2072 2
a2073 1
int __glXDoSwapBuffers(__GLXclientState *cl, XID drawId, GLXContextTag tag)
d2081 1
d2089 1
a2089 1
    
d2091 2
a2092 2
    ** Check that the GLX drawable is valid.
    */
d2097 14
a2110 13
	if (pDraw->type == DRAWABLE_WINDOW) {
	    /*
	    ** Drawable is an X window.
	    */
	   pWin = (WindowPtr)pDraw;
	} else {
	    /*
	    ** Drawable is an X pixmap, which is not allowed.
	    */
	    client->errorValue = drawId;
	    return __glXBadDrawable;
	}
    } 
d2113 21
a2133 21
	dixLookupResourceByType((pointer*) &pGlxPixmap, drawId,
				__glXPixmapRes, NullClient, DixUnknownAccess);
	if (pGlxPixmap) {
	    /*
	    ** Drawable is a GLX pixmap.
	    */
	   pDraw = pGlxPixmap->pDraw;
	   from_screen = to_screen = pGlxPixmap->pScreen->myNum;
	}
    }

    if (!pDraw && __GLX_IS_VERSION_SUPPORTED(1,3) ) {
       dixLookupResourceByType((pointer*) &pGlxWindow, drawId,
                               __glXWindowRes, NullClient, DixUnknownAccess);
       if (pGlxWindow) {
	  /*
	   ** Drawable is a GLXWindow.
	   */
	  pDraw = pGlxWindow->pDraw;
	  from_screen = to_screen = pGlxWindow->pScreen->myNum;
       }
d2137 5
a2141 5
       /*
	** Drawable is neither a X window nor a GLX pixmap.
	*/
       client->errorValue = drawId;
       return __glXBadDrawable;
d2145 4
a2148 4
	glxc = __glXLookupContextByTag(cl, tag);
	if (!glxc) {
	    return __glXBadContextTag;
	}
d2153 5
a2157 5
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
       dixLookupResourceByClass((pointer*) &pXinDraw,
				pDraw->id, XRC_DRAWABLE,
				client, DixReadAccess);
d2163 18
a2180 17
	for (s=from_screen; s<=to_screen; s++) {
	    Display *dpy = GetBackEndDisplay(cl,s);
	    DMXScreenInfo *dmxScreen = &dmxScreens[s];
	    xGLXSingleReq *finishReq;
	    xGLXSingleReply reply;

#define X_GLXSingle 0    /* needed by GetReq below */

	    LockDisplay(dpy);
	    GetReq(GLXSingle,finishReq);
	    finishReq->reqType = dmxScreen->glxMajorOpcode;
	    finishReq->glxCode = X_GLsop_Finish;
	    finishReq->contextTag = (tag ? GetCurrentBackEndTag(cl,tag,s) : 0);
	    (void) _XReply(dpy, (xReply*) &reply, 0, False);
	    UnlockDisplay(dpy);
	    SyncHandle();
	}
d2185 2
a2186 2
	for (s=from_screen; s<=to_screen; s++)
	    XSync(GetBackEndDisplay(cl,s), False);
d2189 29
d2219 1
a2219 1
    /* send the SwapBuffers request to all back-end servers */
d2221 9
a2229 39
    for (s=from_screen; s<=to_screen; s++) {
       DMXScreenInfo *dmxScreen = &dmxScreens[s];
       Display *dpy = GetBackEndDisplay(cl,s);
       unsigned int be_draw = 0;

       if (pGlxPixmap) {
	  be_draw = (unsigned int)pGlxPixmap->be_xids[s];
       }
#ifdef PANORAMIX
       else if (pXinDraw) {
	  dixLookupWindow(&pWin, pXinDraw->info[s].id, client, DixReadAccess);
       }
#endif
       else if (pGlxWindow) {
	  pWin = (WindowPtr)pGlxWindow->pDraw;
       }

       if (pWin && !be_draw) {
	   be_draw = (unsigned int)(DMX_GET_WINDOW_PRIV(pWin))->window;
	   if (!be_draw) {
	      /* it might be that the window did not created yet on the */
	      /* back-end server (lazy window creation option), force   */
	      /* creation of the window */
	      dmxCreateAndRealizeWindow( pWin, TRUE );
	      be_draw = (unsigned int)(DMX_GET_WINDOW_PRIV(pWin))->window;
	   }
       }

       dmxSync( dmxScreen, 1 );

       LockDisplay(dpy);
       GetReq(GLXSwapBuffers,be_req);
       be_req->reqType = dmxScreen->glxMajorOpcode;
       be_req->glxCode = X_GLXSwapBuffers;
       be_req->drawable = be_draw;
       be_req->contextTag = ( tag ? GetCurrentBackEndTag(cl,tag,s) : 0 );
       UnlockDisplay(dpy);
       SyncHandle();
       XFlush(dpy);
d2235 2
a2236 1
int __glXSwapBuffers(__GLXclientState *cl, GLbyte *pc)
d2247 1
a2247 1
    
d2249 2
a2250 2
    ** Check that the GLX drawable is valid.
    */
d2253 8
a2260 8
	if (pDraw->type != DRAWABLE_WINDOW) {
	    /*
	    ** Drawable is an X pixmap, which is not allowed.
	    */
	    client->errorValue = drawId;
	    return __glXBadDrawable;
	}
    } 
d2263 19
a2281 19
	dixLookupResourceByType((pointer*) &pGlxPixmap, drawId,
				__glXPixmapRes, NullClient, DixUnknownAccess);
	if (pGlxPixmap) {
	    /*
	    ** Drawable is a GLX pixmap.
	    */
	   pDraw = pGlxPixmap->pDraw;
	}
    }

    if (!pDraw && __GLX_IS_VERSION_SUPPORTED(1,3) ) {
       dixLookupResourceByType((pointer*) &pGlxWindow, drawId,
                               __glXWindowRes, NullClient, DixUnknownAccess);
       if (pGlxWindow) {
	  /*
	   ** Drawable is a GLXWindow.
	   */
	  pDraw = pGlxWindow->pDraw;
       }
d2285 5
a2289 5
       /*
	** Drawable is neither a X window nor a GLX pixmap.
	*/
       client->errorValue = drawId;
       return __glXBadDrawable;
d2293 4
a2296 4
	glxc = __glXLookupContextByTag(cl, tag);
	if (!glxc) {
	    return __glXBadContextTag;
	}
d2300 3
a2302 3
	pDraw->type == DRAWABLE_WINDOW &&
	DMX_GET_WINDOW_PRIV((WindowPtr)pDraw)->swapGroup) {
	return SGSwapBuffers(cl, drawId, tag, pDraw);
a2307 1

d2318 2
a2319 1
int __glXRender(__GLXclientState *cl, GLbyte *pc)
d2330 5
a2334 5
    ** NOTE: much of this code also appears in the byteswapping version of this
    ** routine, __glXSwapRender().  Any changes made here should also be
    ** duplicated there.
    */
    
d2339 1
a2339 1
	return 0;
d2345 2
a2346 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d2356 13
a2368 13
    for (s=from_screen; s<=to_screen; s++) {
       DMXScreenInfo *dmxScreen = &dmxScreens[s];
       Display *dpy = GetBackEndDisplay(cl,s);

       LockDisplay(dpy);
       GetReq(GLXRender,be_req);
       be_req->reqType = dmxScreen->glxMajorOpcode;
       be_req->glxCode = X_GLXRender;
       be_req->length = req->length;
       be_req->contextTag = GetCurrentBackEndTag(cl,req->contextTag,s);
       _XSend(dpy, (const char *)pc, size);
       UnlockDisplay(dpy);
       SyncHandle();
d2377 2
a2378 1
int __glXRenderLarge(__GLXclientState *cl, GLbyte *pc)
d2388 5
a2392 5
    ** NOTE: much of this code also appears in the byteswapping version of this
    ** routine, __glXSwapRenderLarge().  Any changes made here should also be
    ** duplicated there.
    */
    
d2396 1
a2396 1
	return 0;
d2402 2
a2403 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d2412 15
a2426 15
    for (s=from_screen; s<=to_screen; s++) {
       DMXScreenInfo *dmxScreen = &dmxScreens[s];
       Display *dpy = GetBackEndDisplay(cl,s);

       GetReq(GLXRenderLarge,be_req);
       be_req->reqType = dmxScreen->glxMajorOpcode;
       be_req->glxCode = X_GLXRenderLarge;
       be_req->contextTag = GetCurrentBackEndTag(cl,req->contextTag,s);
       be_req->length = req->length;
       be_req->requestNumber = req->requestNumber;
       be_req->requestTotal = req->requestTotal;
       be_req->dataBytes = req->dataBytes;
       Data(dpy, (const char *)pc, req->dataBytes);
       UnlockDisplay(dpy);
       SyncHandle();
a2432 1

d2435 2
a2436 1
int __glXVendorPrivate(__GLXclientState *cl, GLbyte *pc)
d2442 1
a2442 1
    switch( req->vendorCode ) {
d2444 44
a2487 44
       case X_GLvop_DeleteTexturesEXT:
	  return __glXVForwardSingleReq( cl, pc );
	  break;

       case X_GLXvop_SwapIntervalSGI:
	  if (glxIsExtensionSupported("SGI_swap_control")) {
	     return __glXVForwardSingleReq( cl, pc );
	  }
	  else {
	     return Success;
	  }
	  break;

#if 0 /* glx 1.3 */
       case X_GLXvop_CreateGLXVideoSourceSGIX:
	  break;
       case X_GLXvop_DestroyGLXVideoSourceSGIX:
	  break;
       case X_GLXvop_CreateGLXPixmapWithConfigSGIX:
	  break;
       case X_GLXvop_DestroyGLXPbufferSGIX:
	  break;
       case X_GLXvop_ChangeDrawableAttributesSGIX:
	  break;
#endif

       case X_GLXvop_BindSwapBarrierSGIX:
	  return __glXBindSwapBarrierSGIX( cl, pc );
	  break;

       case X_GLXvop_JoinSwapGroupSGIX:
	  return __glXJoinSwapGroupSGIX( cl, pc );
	  break;

       case X_GLXvop_CreateContextWithConfigSGIX:
	  return __glXCreateContextWithConfigSGIX( cl, pc );
	  break;

       default:
	  /*
	   ** unsupported private request
	   */
	  cl->client->errorValue = req->vendorCode;
	  return __glXUnsupportedPrivateRequest;
d2495 2
a2496 1
int __glXVendorPrivateWithReply(__GLXclientState *cl, GLbyte *pc)
d2502 1
a2502 1
    switch( req->vendorCode ) {
d2504 58
a2561 59
       case X_GLvop_GetConvolutionFilterEXT:
       case X_GLvop_GetConvolutionParameterfvEXT:
       case X_GLvop_GetConvolutionParameterivEXT:
       case X_GLvop_GetSeparableFilterEXT:
       case X_GLvop_GetHistogramEXT:
       case X_GLvop_GetHistogramParameterivEXT:
       case X_GLvop_GetMinmaxEXT:
       case X_GLvop_GetMinmaxParameterfvEXT:
       case X_GLvop_GetMinmaxParameterivEXT:
       case X_GLvop_AreTexturesResidentEXT:
       case X_GLvop_IsTextureEXT:
	  return( __glXVForwardPipe0WithReply(cl, pc) );
	  break;

       case X_GLvop_GenTexturesEXT:
	  return( __glXVForwardAllWithReply(cl, pc) );
	  break;


#if 0 /* glx1.3 */
       case X_GLvop_GetDetailTexFuncSGIS:
       case X_GLvop_GetSharpenTexFuncSGIS:
       case X_GLvop_GetColorTableSGI:
       case X_GLvop_GetColorTableParameterfvSGI:
       case X_GLvop_GetColorTableParameterivSGI:
       case X_GLvop_GetTexFilterFuncSGIS:
       case X_GLvop_GetInstrumentsSGIX:
       case X_GLvop_InstrumentsBufferSGIX:
       case X_GLvop_PollInstrumentsSGIX:
       case X_GLvop_FlushRasterSGIX:
       case X_GLXvop_CreateGLXPbufferSGIX:
       case X_GLXvop_GetDrawableAttributesSGIX:
       case X_GLXvop_QueryHyperpipeNetworkSGIX:
       case X_GLXvop_QueryHyperpipeConfigSGIX:
       case X_GLXvop_HyperpipeConfigSGIX:
       case X_GLXvop_DestroyHyperpipeConfigSGIX:
#endif
       case X_GLXvop_QueryMaxSwapBarriersSGIX:
	  return( __glXQueryMaxSwapBarriersSGIX(cl, pc) );
	  break;

       case X_GLXvop_GetFBConfigsSGIX:
	  return( __glXGetFBConfigsSGIX(cl, pc) );
	  break;

       case X_GLXvop_MakeCurrentReadSGI:
	  return( __glXMakeCurrentReadSGI(cl, pc) );
	  break;

       case X_GLXvop_QueryContextInfoEXT:
	  return( __glXQueryContextInfoEXT(cl,pc) );
	  break;

       default:
	  /*
	   ** unsupported private request
	   */
	  cl->client->errorValue = req->vendorCode;
	  return __glXUnsupportedPrivateRequest;
d2566 2
a2567 1
int __glXQueryExtensionsString(__GLXclientState *cl, GLbyte *pc)
d2588 2
a2589 2
    ** Check if screen exists.
    */
d2591 2
a2592 2
	client->errorValue = screen;
	return BadValue;
d2599 1
a2599 1
    dpy = GetBackEndDisplay(cl,screen);
d2601 1
a2601 1
    GetReq(GLXQueryExtensionsString,be_req);
d2605 3
a2607 3
    _XReply(dpy, (xReply*) &be_reply, 0, False);
    len = (int)be_reply.length;
    numbytes = (int)be_reply.n;
d2609 1
a2609 1
    be_buf = (char *)malloc(numbytes);
d2613 5
a2617 3
    } else {
        _XRead(dpy, (char *)be_buf, numbytes);
        if (slop) _XEatData(dpy,4-slop);
d2638 5
a2642 3
    } else {
        WriteToClient(client, sz_xGLXQueryExtensionsStringReply,(char *)&reply);
        WriteToClient(client, (int)(length << 2), (char *)be_buf);
d2648 2
a2649 1
int __glXQueryServerString(__GLXclientState *cl, GLbyte *pc)
d2659 1
d2665 1
a2665 1
    int  slop;
d2671 2
a2672 2
    ** Check if screen exists.
    */
d2674 2
a2675 2
	client->errorValue = screen;
	return BadValue;
d2682 1
a2682 1
    dpy = GetBackEndDisplay(cl,screen);
d2684 1
a2684 1
    GetReq(GLXQueryServerString,be_req);
d2689 3
a2691 3
    _XReply(dpy, (xReply*) &be_reply, 0, False);
    len = (int)be_reply.length;
    numbytes = (int)be_reply.n;
d2693 1
a2693 1
    be_buf = (char *)malloc(numbytes);
d2697 5
a2701 3
    } else {
        _XRead(dpy, (char *)be_buf, numbytes);
        if (slop) _XEatData(dpy,4-slop);
d2720 4
a2723 3
    } else {
        WriteToClient(client, sz_xGLXQueryServerStringReply, (char *)&reply);
        WriteToClient(client, (int)(length << 2), be_buf);
d2729 2
a2730 1
int __glXClientInfo(__GLXclientState *cl, GLbyte *pc)
d2738 1
a2738 1
   
d2742 1
a2742 1
    buf = (const char *)(req+1);
d2747 3
a2749 4
    for (s=from_screen; s<=to_screen; s++)
    {
       DMXScreenInfo *dmxScreen = &dmxScreens[s];
       Display *dpy = GetBackEndDisplay(cl,s);
d2751 9
a2759 9
       LockDisplay(dpy);
       GetReq(GLXClientInfo,be_req);
       be_req->reqType = dmxScreen->glxMajorOpcode;
       be_req->glxCode = X_GLXClientInfo;
       be_req->major = req->major;
       be_req->minor = req->minor;
       be_req->length = req->length;
       be_req->numbytes = req->numbytes;
       Data(dpy, buf, req->numbytes);
d2761 2
a2762 2
       UnlockDisplay(dpy);
       SyncHandle();
d2768 2
a2769 1
int __glXUseXFont(__GLXclientState *cl, GLbyte *pc)
d2779 1
a2779 1
    dmxFontPrivPtr  pFontPriv;
d2786 4
a2789 4
	glxc = __glXLookupContextByTag(cl, req->contextTag);
	if (glxc) {
	   from_screen = to_screen = glxc->pScreen->myNum;
	}
d2793 4
a2796 4
    ** Font can actually be either the ID of a font or the ID of a GC
    ** containing a font.
    */
    dixLookupResourceByType((pointer*) &pFont, req->font, RT_FONT,
d2800 3
a2802 3
        dixLookupResourceByType((pointer*) &pGC, req->font,
				RT_GC, NullClient,
				DixUnknownAccess);
d2804 1
a2804 1
	    client->errorValue = req->font;
d2806 2
a2807 2
	}
	pFont = pGC->font;
d2814 2
a2815 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d2819 18
d2838 1
a2838 19
    for (s=from_screen; s<=to_screen; s++) {
       dmxScreen = &dmxScreens[s];
       dpy = GetBackEndDisplay(cl,s);

       dmxSync( dmxScreen, 1 );

       LockDisplay(dpy);
       GetReq(GLXUseXFont,be_req);
       be_req->reqType = dmxScreen->glxMajorOpcode;
       be_req->glxCode = X_GLXUseXFont;
       be_req->contextTag = (glxc ? GetCurrentBackEndTag(cl,req->contextTag,s) : 0);
       be_req->font = pFontPriv->font[s]->fid;
       be_req->first = req->first;
       be_req->count = req->count;
       be_req->listBase = req->listBase;
       UnlockDisplay(dpy);
       SyncHandle();

       XSync( dpy, False );
d2848 2
a2849 1
int __glXGetFBConfigs(__GLXclientState *cl, GLbyte *pc)
d2862 3
a2864 3
	/* The client library must send a valid screen number. */
	client->errorValue = screen;
	return BadValue;
d2877 75
a2951 74
	__GLX_DECLARE_SWAP_VARIABLES;
	__GLX_SWAP_SHORT(&reply.sequenceNumber);
	__GLX_SWAP_INT(&reply.length);
	__GLX_SWAP_INT(&reply.numFBConfigs);
	__GLX_SWAP_INT(&reply.numAttribs);
    }
    WriteToClient(client, sz_xGLXGetFBConfigsReply, (char *)&reply);

    for (i=0; i < numFBConfigs; i++) {
       int associatedVisualId = 0;
       int drawableTypeIndex;
       pFBConfig = __glXFBConfigs[ i * (screenInfo.numScreens+1) ];

	p = 0;
	/* core attributes */
	buf[p++] = GLX_FBCONFIG_ID;
	buf[p++] = pFBConfig->id;
	buf[p++] = GLX_BUFFER_SIZE;
	buf[p++] = pFBConfig->indexBits;
	buf[p++] = GLX_LEVEL;
	buf[p++] = pFBConfig->level;
	buf[p++] = GLX_DOUBLEBUFFER;
	buf[p++] = pFBConfig->doubleBufferMode;
	buf[p++] = GLX_STEREO;
	buf[p++] = pFBConfig->stereoMode;
	buf[p++] = GLX_AUX_BUFFERS;
	buf[p++] = pFBConfig->maxAuxBuffers;
	buf[p++] = GLX_RED_SIZE;
	buf[p++] = pFBConfig->redBits;
	buf[p++] = GLX_GREEN_SIZE;
	buf[p++] = pFBConfig->greenBits;
	buf[p++] = GLX_BLUE_SIZE;
	buf[p++] = pFBConfig->blueBits;
	buf[p++] = GLX_ALPHA_SIZE;
	buf[p++] = pFBConfig->alphaBits;
	buf[p++] = GLX_DEPTH_SIZE;
	buf[p++] = pFBConfig->depthBits;
	buf[p++] = GLX_STENCIL_SIZE;
	buf[p++] = pFBConfig->stencilBits;
	buf[p++] = GLX_ACCUM_RED_SIZE;
	buf[p++] = pFBConfig->accumRedBits;
	buf[p++] = GLX_ACCUM_GREEN_SIZE;
	buf[p++] = pFBConfig->accumGreenBits;
	buf[p++] = GLX_ACCUM_BLUE_SIZE;
	buf[p++] = pFBConfig->accumBlueBits;
	buf[p++] = GLX_ACCUM_ALPHA_SIZE;
	buf[p++] = pFBConfig->accumAlphaBits;
	buf[p++] = GLX_RENDER_TYPE;
	buf[p++] = pFBConfig->renderType;
	buf[p++] = GLX_DRAWABLE_TYPE;
	drawableTypeIndex = p;
	buf[p++] = pFBConfig->drawableType;
	buf[p++] = GLX_X_VISUAL_TYPE;
	buf[p++] = pFBConfig->visualType;
	buf[p++] = GLX_CONFIG_CAVEAT;
	buf[p++] = pFBConfig->visualCaveat;
	buf[p++] = GLX_TRANSPARENT_TYPE;
	buf[p++] = pFBConfig->transparentType;
	buf[p++] = GLX_TRANSPARENT_RED_VALUE;
	buf[p++] = pFBConfig->transparentRed;
	buf[p++] = GLX_TRANSPARENT_GREEN_VALUE;
	buf[p++] = pFBConfig->transparentGreen;
	buf[p++] = GLX_TRANSPARENT_BLUE_VALUE;
	buf[p++] = pFBConfig->transparentBlue;
	buf[p++] = GLX_TRANSPARENT_ALPHA_VALUE;
	buf[p++] = pFBConfig->transparentAlpha;
	buf[p++] = GLX_TRANSPARENT_INDEX_VALUE;
	buf[p++] = pFBConfig->transparentIndex;
	buf[p++] = GLX_MAX_PBUFFER_WIDTH;
	buf[p++] = pFBConfig->maxPbufferWidth;
	buf[p++] = GLX_MAX_PBUFFER_HEIGHT;
	buf[p++] = pFBConfig->maxPbufferHeight;
	buf[p++] = GLX_MAX_PBUFFER_PIXELS;
	buf[p++] = pFBConfig->maxPbufferPixels;
d2953 1
a2953 1
	/*
d2955 18
a2972 80
	 * on the proxy.
	 * do only once - if a visual is not yet associated.
	 */
	if (pFBConfig->associatedVisualId == (unsigned int)-1) {
	   DMXScreenInfo *dmxScreen = &dmxScreens[screen];
	   __GLXFBConfig *be_pFBConfig = __glXFBConfigs[ i * (screenInfo.numScreens+1)+screen+1 ];
	   __GLXvisualConfig *pGlxVisual = NULL;
	   int v;
	   int found = 0;
	   for (v=0; v<dmxScreen->numGlxVisuals; v++) {
	      if (dmxScreen->glxVisuals[v].vid == be_pFBConfig->associatedVisualId) {
		 pGlxVisual = &dmxScreen->glxVisuals[v];
		 break;
	      }
	   }

	   if (pGlxVisual) {
	      for (v=0; v<pGlxScreen->numVisuals; v++) {
		 if (glxVisualsMatch(&pGlxScreen->pGlxVisual[v], pGlxVisual)) {
		    associatedVisualId = pGlxScreen->pGlxVisual[v].vid;
		    found = 1;
		    break;
		 }
	      }
	   }

	   if (!found) {
	      associatedVisualId = 0;
	      pFBConfig->drawableType &= ~(GLX_WINDOW_BIT);
	      buf[drawableTypeIndex] = pFBConfig->drawableType;
	   }
#ifdef PANORAMIX
	   else if (!noPanoramiXExtension) {
	      /* convert the associated visualId to the panoramix one */
	      pFBConfig->associatedVisualId =
		  PanoramiXTranslateVisualID(screen, v);
	   }
#endif
	}
	else {
	   associatedVisualId = pFBConfig->associatedVisualId;
	}

	buf[p++] = GLX_VISUAL_ID;
	buf[p++] = associatedVisualId;

	/* SGIS_multisample attributes */
	buf[p++] = GLX_SAMPLES_SGIS;
	buf[p++] = pFBConfig->multiSampleSize;
	buf[p++] = GLX_SAMPLE_BUFFERS_SGIS;
	buf[p++] = pFBConfig->nMultiSampleBuffers;

	/* SGIX_pbuffer specific attributes */
	buf[p++] = GLX_OPTIMAL_PBUFFER_WIDTH_SGIX;
	buf[p++] = pFBConfig->optimalPbufferWidth;
	buf[p++] = GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX;
	buf[p++] = pFBConfig->optimalPbufferHeight;

	buf[p++] = GLX_VISUAL_SELECT_GROUP_SGIX;
	buf[p++] = pFBConfig->visualSelectGroup;

	if (client->swapped) {
	    __GLX_DECLARE_SWAP_VARIABLES;
	    __GLX_DECLARE_SWAP_ARRAY_VARIABLES;
	    __GLX_SWAP_INT_ARRAY((int *)buf, 2*numAttribs);
	}
	WriteToClient(client, 2*numAttribs * __GLX_SIZE_CARD32, (char *)buf);
    }
    return Success;
}

int __glXGetFBConfigsSGIX(__GLXclientState *cl, GLbyte *pc)
{
   xGLXGetFBConfigsSGIXReq *req = (xGLXGetFBConfigsSGIXReq *)pc;
   xGLXGetFBConfigsReq new_req;

   new_req.reqType = req->reqType;
   new_req.glxCode = req->glxCode;
   new_req.length = req->length;
   new_req.screen = req->screen;
d2974 53
a3026 1
   return( __glXGetFBConfigs( cl, (GLbyte *)&new_req ) );
d3029 10
d3040 5
a3044 1
int __glXCreateWindow(__GLXclientState *cl, GLbyte *pc)
d3062 2
a3063 2
    ** Check if windowId is valid 
    */
d3065 1
a3065 1
			   DixAddAccess);
d3067 1
a3067 1
	return rc;
d3070 2
a3071 2
    ** Check if screen of window matches screen of fbconfig.
    */
d3074 1
a3074 1
	return BadMatch;
d3078 2
a3079 2
    ** Find the FBConfigRec for this fbconfigid.
    */
d3081 2
a3082 2
	client->errorValue = fbconfigId;
	return __glXBadFBConfig;
d3087 4
a3090 4
    ** Check if the fbconfig supports rendering to windows 
    */
    if( !(pGlxFBConfig->drawableType & GLX_WINDOW_BIT) ) {
	return BadMatch;	
a3093 14
       /*
	** Check if the visual ID is valid for this screen.
	*/
       pVisual = pScreen->visuals;
       for (i = 0; i < pScreen->numVisuals; i++, pVisual++) {
	  if (pVisual->vid == visId) {
	     break;
	  }
       }
       if (i == pScreen->numVisuals) {
	  client->errorValue = visId;
	  return BadValue;
       }
	
d3095 17
a3111 3
        ** Check if color buffer depth of fbconfig matches depth 
	** of window.
        */
d3113 9
a3121 8
	    return BadMatch;
	}
    } else
	/*
	** The window was created with no visual that corresponds
	** to fbconfig 
	*/
	return BadMatch;
d3124 2
a3125 2
    ** Check if there is already a fbconfig associated with this window
    */
d3127 4
a3130 4
					   glxwindowId, __glXWindowRes,
					   NullClient, DixUnknownAccess)) {
	client->errorValue = glxwindowId;
	return BadAlloc;
d3135 1
a3135 1
	return BadAlloc;
d3139 2
a3140 2
    ** Register this GLX window as a resource
    */
d3142 1
a3142 1
	return BadAlloc;
d3155 2
a3156 1
int __glXDestroyWindow(__GLXclientState *cl, GLbyte *pc)
d3164 2
a3165 2
    ** Check if it's a valid GLX window.
    */
d3167 4
a3170 4
					   glxwindow, __glXWindowRes,
					   NullClient, DixUnknownAccess)) {
	client->errorValue = glxwindow;
	return __glXBadDrawable;
d3173 4
a3176 4
    ** The glx window destructor will check whether it's current before
    ** freeing anything.
    */
    FreeResource(glxwindow, RT_NONE);	
d3181 2
a3182 1
int __glXQueryContext(__GLXclientState *cl, GLbyte *pc)
d3192 2
a3193 2
    req = (xGLXQueryContextReq *)pc;
    dixLookupResourceByType((pointer*) &ctx, req->context, __glXContextRes,
d3208 1
a3208 1
    sendBuf = (int *)malloc(nReplyBytes);
d3211 1
a3211 1
    *pSendBuf++ = (int)(ctx->pFBConfig->id);
d3213 1
a3213 1
    *pSendBuf++ = (int)(ctx->pFBConfig->renderType);
d3215 1
a3215 1
    *pSendBuf++ = (int)(ctx->pScreen->myNum);
a3218 3
    } else {
        WriteToClient(client, sz_xGLXQueryContextReply, (char *)&reply);
        WriteToClient(client, nReplyBytes, (char *)sendBuf);
d3220 5
a3224 1
    free((char *)sendBuf);
d3229 2
a3230 1
int __glXQueryContextInfoEXT(__GLXclientState *cl, GLbyte *pc)
d3240 4
a3243 4
    req = (xGLXQueryContextInfoEXTReq *)pc;
    dixLookupResourceByType((pointer*) &ctx,
			    req->context, __glXContextRes,
			    client,  DixReadAccess);
d3258 1
a3258 1
    sendBuf = (int *)malloc(nReplyBytes);
d3261 1
a3261 1
    *pSendBuf++ = (int)(ctx->share_id);
d3263 1
a3263 1
    *pSendBuf++ = (int)(ctx->pVisual ? ctx->pVisual->vid : 0);
d3265 1
a3265 1
    *pSendBuf++ = (int)(ctx->pScreen->myNum);
d3267 1
a3267 1
    *pSendBuf++ = (int)(ctx->pFBConfig ? ctx->pFBConfig->id : 0);
a3270 3
    } else {
        WriteToClient(client, sz_xGLXQueryContextInfoEXTReply, (char *)&reply);
        WriteToClient(client, nReplyBytes, (char *)sendBuf);
d3272 5
a3276 1
    free((char *)sendBuf);
d3281 2
a3282 1
int __glXCreatePbuffer(__GLXclientState *cl, GLbyte *pc)
d3285 1
a3285 1
    xGLXCreatePbufferReq *req = (xGLXCreatePbufferReq *)pc;
d3302 3
a3304 3
   /*
    ** Look up screen and FBConfig.
    */
d3313 2
a3314 2
    ** Find the FBConfigRec for this fbconfigid.
    */
d3316 2
a3317 2
	client->errorValue = fbconfigId;
	return __glXBadFBConfig;
d3321 2
a3322 2
    ** Create the GLX part of the Pbuffer.
    */
d3328 1
a3328 1
    pGlxPbuffer->be_xids = (XID *) malloc( sizeof(XID) * screenInfo.numScreens );
d3340 2
a3341 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d3345 27
a3371 26
    for (s=from_screen; s<=to_screen; s++) {
       dpy = GetBackEndDisplay(cl,s);
       be_xid = XAllocID(dpy);
       dmxScreen = &dmxScreens[s];
       be_pGlxFBConfig = glxLookupBackEndFBConfig( pGlxFBConfig->id, s );
       
       attr = (int *)( req+1 );

       LockDisplay(dpy);
       GetReqExtra(GLXCreatePbuffer, 2 * numAttribs * __GLX_SIZE_CARD32, be_req);
       be_req->reqType = dmxScreen->glxMajorOpcode;
       be_req->glxCode = X_GLXCreatePbuffer;
       be_req->screen = be_pGlxFBConfig->screen;
       be_req->fbconfig = be_pGlxFBConfig->id;
       be_req->pbuffer = be_xid;
       be_req->numAttribs = numAttribs;
    
       /* Send attributes */
       if ( attr != NULL ) {
	  CARD32 *pc = (CARD32 *)(be_req + 1);

	  while (numAttribs-- > 0) {
	     *pc++ = *attr++;     /* token */
	     *pc++ = *attr++;     /* value */
	  }
       }
d3373 2
a3374 2
       UnlockDisplay(dpy);
       SyncHandle();
d3376 1
a3376 1
       pGlxPbuffer->be_xids[s] = be_xid;
a3378 1

d3385 2
a3386 2
    ** Register the resource.
    */
d3395 2
a3396 1
int __glXDestroyPbuffer(__GLXclientState *cl, GLbyte *pc)
d3410 3
a3412 3
    ** Check if it's a valid Pbuffer
    */
    dixLookupResourceByType((pointer*) &pGlxPbuffer, pbuffer,
d3415 2
a3416 2
	client->errorValue = pbuffer;
	return __glXBadPbuffer;
d3424 2
a3425 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d3429 3
a3431 3
    for (s=from_screen; s<=to_screen; s++) {
       dpy = GetBackEndDisplay(cl,s);
       dmxScreen = &dmxScreens[s];
d3433 8
a3440 8
       /* send the destroy request to the back-end server */
       LockDisplay(dpy);
       GetReq(GLXDestroyPbuffer, be_req);
       be_req->reqType = dmxScreen->glxMajorOpcode;
       be_req->glxCode = X_GLXDestroyPbuffer;
       be_req->pbuffer = pGlxPbuffer->be_xids[s];
       UnlockDisplay(dpy);
       SyncHandle();
d3443 1
a3443 1
    FreeResource(pbuffer, RT_NONE);	
d3448 2
a3449 1
int __glXGetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
d3451 13
a3463 12
   xGLXGetDrawableAttributesReq *req = (xGLXGetDrawableAttributesReq *)pc;
   xGLXGetDrawableAttributesReq *be_req;
   xGLXGetDrawableAttributesReply reply;
   ClientPtr client = cl->client;
   GLXDrawable drawId = req->drawable;
   GLXDrawable be_drawable = 0;
   DrawablePtr pDraw = NULL;
   Display *dpy;
   int screen, rc;
   DMXScreenInfo *dmxScreen;
   CARD32 *attribs = NULL;
   int attribs_size = 0;
d3468 25
a3492 22
   if (drawId != None) {
      rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixGetAttrAccess);
      if (rc == Success && pDraw->type == DRAWABLE_WINDOW) {
	 WindowPtr pWin = (WindowPtr)pDraw;
	 be_drawable = 0;
	 screen = pWin->drawable.pScreen->myNum;
      } else {
	 /*
	  ** Drawable is not a Window , GLXWindow or a GLXPixmap.
	  */
	 client->errorValue = drawId;
	 return __glXBadDrawable;
      }

      if (!pDraw) {
	 __GLXpixmap *pGlxPixmap;
	 dixLookupResourceByType((pointer*) &pGlxPixmap,
				 drawId, __glXPixmapRes,
				 NullClient, DixUnknownAccess);
	 if (pGlxPixmap) {
		pDraw = pGlxPixmap->pDraw;
		screen = pGlxPixmap->pScreen->myNum;
d3494 5
a3498 2
	 }
      }
d3500 22
a3521 23
      if (!pDraw) {
	 __glXWindow *pGlxWindow;
	 dixLookupResourceByType((pointer*) &pGlxWindow,
				 drawId, __glXWindowRes,
				 NullClient, DixUnknownAccess);
	 if (pGlxWindow) {
	    pDraw = pGlxWindow->pDraw;
	    screen = pGlxWindow->pScreen->myNum;
	    be_drawable = 0;
     	 }
      }

      if (!pDraw) {
	 __glXPbuffer *pGlxPbuffer;
	 dixLookupResourceByType((pointer*) &pGlxPbuffer,
				 drawId, __glXPbufferRes,
				 NullClient, DixUnknownAccess);
	 if (pGlxPbuffer) {
    	    pDraw = (DrawablePtr)pGlxPbuffer;
	    screen = pGlxPbuffer->pScreen->myNum;
	    be_drawable = pGlxPbuffer->be_xids[screen];
	 }
      }
d3525 131
a3655 127
	/*
	 ** Drawable is not a Window , GLXWindow or a GLXPixmap.
	 */
	client->errorValue = drawId;
	return __glXBadDrawable;
   }

   /* if the drawable is a window or GLXWindow - 
    * we need to find the base id on the back-end server
    */
   if (!be_drawable) {
       WindowPtr pWin = (WindowPtr)pDraw;

#ifdef PANORAMIX
       if (!noPanoramiXExtension) {
	  if (Success != dixLookupResourceByClass((pointer*) &pXinDraw,
						  pDraw->id, XRC_DRAWABLE,
						  client, DixReadAccess)) {
	     client->errorValue = drawId;
	     return __glXBadDrawable;
	  }

	  dixLookupWindow(&pWin, pXinDraw->info[screen].id, client,
			  DixReadAccess);
       }
#endif

       if (pWin) {
	   be_drawable = (unsigned int)(DMX_GET_WINDOW_PRIV(pWin))->window;
	   if (!be_drawable) {
	      /* it might be that the window did not created yet on the */
	      /* back-end server (lazy window creation option), force   */
	      /* creation of the window */
	      dmxCreateAndRealizeWindow( pWin, TRUE );
	      be_drawable = (unsigned int)(DMX_GET_WINDOW_PRIV(pWin))->window;
	   }
       }
       else {
	  client->errorValue = drawId;
	  return __glXBadDrawable;
       }
   }


   /* send the request to the back-end server */
   dpy = GetBackEndDisplay(cl,screen);
   dmxScreen = &dmxScreens[screen];

   /* make sure drawable exists on back-end */
   dmxSync( dmxScreen, 1 );

   LockDisplay(dpy);
   GetReq(GLXGetDrawableAttributes, be_req);
   be_req->reqType = dmxScreen->glxMajorOpcode;
   be_req->glxCode = X_GLXGetDrawableAttributes;
   be_req->drawable = be_drawable;
   be_req->length = req->length;
   if (!_XReply(dpy, (xReply *) &reply, 0, False)) {
      UnlockDisplay(dpy);
      SyncHandle();
      return( BE_TO_CLIENT_ERROR(dmxLastErrorEvent.error_code) );
   }

   if (reply.numAttribs) {
      attribs_size = 2 * reply.numAttribs * __GLX_SIZE_CARD32;
      attribs = (CARD32 *) malloc(attribs_size);
      if (attribs == NULL) {
	 UnlockDisplay(dpy);
	 SyncHandle();
	 return BadAlloc;
      }

      _XRead(dpy, (char *) attribs, attribs_size);
   }

   UnlockDisplay(dpy);
   SyncHandle();


   /* send the reply back to the client */
   reply.sequenceNumber = client->sequence;
   if (client->swapped) {
      __glXSwapGetDrawableAttributesReply(client, &reply, (int *)attribs);
   }
   else {
      WriteToClient(client, sz_xGLXGetDrawableAttributesReply, (char *)&reply);
      WriteToClient(client, attribs_size, (char *)attribs);
   }

   free(attribs);

   return Success;
}

int __glXChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
{
   xGLXChangeDrawableAttributesReq *req = (xGLXChangeDrawableAttributesReq *)pc;
   xGLXChangeDrawableAttributesReq *be_req;
   ClientPtr client = cl->client;
   GLXDrawable drawId = req->drawable;
   GLXDrawable be_drawable = 0;
   DrawablePtr pDraw = NULL;
   Display *dpy;
   int screen, rc;
   DMXScreenInfo *dmxScreen;

   if (drawId != None) {
      rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixSetAttrAccess);
      if (rc == Success && pDraw->type == DRAWABLE_WINDOW) {
	  be_drawable = 0;
	  screen = pDraw->pScreen->myNum;
      } else {
	 /*
	  ** Drawable is not a Window , GLXWindow or a GLXPixmap.
	  */
	 client->errorValue = drawId;
	 return __glXBadDrawable;
      }

      if (!pDraw) {
	 __GLXpixmap *pGlxPixmap;
	 dixLookupResourceByType((pointer*) &pGlxPixmap,
				 drawId, __glXPixmapRes,
				 NullClient, DixUnknownAccess);
	 if (pGlxPixmap) {
		pDraw = pGlxPixmap->pDraw;
		screen = pGlxPixmap->pScreen->myNum;
d3657 29
a3685 2
	 }
      }
d3687 46
a3732 89
      if (!pDraw) {
	 __glXWindow *pGlxWindow;
	 dixLookupResourceByType((pointer*) &pGlxWindow,
				 drawId, __glXWindowRes,
				 NullClient, DixUnknownAccess);
	 if (pGlxWindow) {
	    pDraw = pGlxWindow->pDraw;
	    screen = pGlxWindow->pScreen->myNum;
	    be_drawable = 0;
     	 }
      }

      if (!pDraw) {
	 __glXPbuffer *pGlxPbuffer;
	 dixLookupResourceByType((pointer*) &pGlxPbuffer,
				 drawId, __glXPbufferRes,
				 NullClient, DixUnknownAccess);
	 if (pGlxPbuffer) {
    	    pDraw = (DrawablePtr)pGlxPbuffer;
	    screen = pGlxPbuffer->pScreen->myNum;
	    be_drawable = pGlxPbuffer->be_xids[screen];
	 }
      }
   }

   if (!pDraw) {
	 /*
	  ** Drawable is not a Window , GLXWindow or a GLXPixmap.
	  */
	 client->errorValue = drawId;
	 return __glXBadDrawable;
   }

   /* if the drawable is a window or GLXWindow - 
    * we need to find the base id on the back-end server
    */
   if (!be_drawable) {
       WindowPtr pWin = (WindowPtr)pDraw;

#ifdef PANORAMIX
       if (!noPanoramiXExtension) {
	  PanoramiXRes *pXinDraw;
	  if (Success != dixLookupResourceByClass((pointer*) &pXinDraw,
						  pDraw->id, XRC_DRAWABLE,
						  client, DixReadAccess)) {
	     client->errorValue = drawId;
	     return __glXBadDrawable;
	  }

	  dixLookupWindow(&pWin, pXinDraw->info[screen].id, client,
			  DixReadAccess);
       }
#endif

       if (pWin) {
	   be_drawable = (unsigned int)(DMX_GET_WINDOW_PRIV(pWin))->window;
	   if (!be_drawable) {
	      /* it might be that the window did not created yet on the */
	      /* back-end server (lazy window creation option), force   */
	      /* creation of the window */
	      dmxCreateAndRealizeWindow( pWin, TRUE );
	      be_drawable = (unsigned int)(DMX_GET_WINDOW_PRIV(pWin))->window;
	   }
       }
       else {
	  client->errorValue = drawId;
	  return __glXBadDrawable;
       }
   }


   /* send the request to the back-end server */
   dpy = GetBackEndDisplay(cl,screen);
   dmxScreen = &dmxScreens[screen];

   /* make sure drawable exists on back-end */
   dmxSync( dmxScreen, 1 );

   LockDisplay(dpy);
   GetReqExtra(GLXChangeDrawableAttributes,
                        2 * req->numAttribs * __GLX_SIZE_CARD32, be_req);
   be_req->reqType = dmxScreen->glxMajorOpcode;
   be_req->glxCode = X_GLXChangeDrawableAttributes;
   be_req->drawable = be_drawable;
   be_req->numAttribs = req->numAttribs;
   be_req->length = req->length;

   UnlockDisplay(dpy);
   SyncHandle();
d3734 20
a3753 1
   return Success;
d3756 2
a3757 1
int __glXSendLargeCommand(__GLXclientState *cl, GLXContextTag contextTag)
d3759 1
a3759 1
   ClientPtr client = cl->client;
d3769 1
a3769 1
    maxSize = cl->largeCmdMaxReqDataSize - (GLint)sizeof(xGLXRenderLargeReq);
d3772 2
a3773 1
    if (dataLen % maxSize) totalRequests++;
d3777 2
a3778 2
       client->errorValue = contextTag;
       return __glXBadContext;
d3784 2
a3785 2
       from_screen = 0;
       to_screen = screenInfo.numScreens - 1;
d3790 2
a3791 2
    ** Send enough requests until the whole array is sent.
    */
d3795 25
a3819 25
	amount = dataLen;
	if (amount > maxSize) {
	    amount = maxSize;
	}

	for (s=from_screen; s<=to_screen; s++) {

	   Display *dpy = GetBackEndDisplay(cl,s);
	   DMXScreenInfo *dmxScreen = &dmxScreens[s];

	   LockDisplay(dpy);
	   GetReq(GLXRenderLarge,req); 
	   req->reqType = dmxScreen->glxMajorOpcode;
	   req->glxCode = X_GLXRenderLarge; 
	   req->contextTag = GetCurrentBackEndTag(cl,contextTag,s);
	   req->length += (amount + 3) >> 2;
	   req->requestNumber = requestNumber++;
	   req->requestTotal = totalRequests;
	   req->dataBytes = amount;
	   Data(dpy, ((const char*)data), amount);
	   dataLen -= amount;
	   data = ((GLbyte *) data) + amount;
	   UnlockDisplay(dpy);
	   SyncHandle();
	}
@


1.7
log
@Update to xserver 1.11.2
@
text
@d55 2
@


1.6
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@a40 5
#undef Xmalloc
#undef Xcalloc
#undef Xrealloc
#undef Xfree

d104 2
a105 2
    VisualID be_vid;
    GLXFBConfigID be_fbconfigId;
d132 2
a133 1
       shareglxc = (__GLXcontext *) LookupIDByType(shareList, __glXContextRes);
d143 1
a143 1
    glxc = __glXCalloc(1, sizeof(__GLXcontext));
d155 1
a155 1
	  __glXFree( glxc );
d176 1
a176 1
	  __glXFree( glxc );
d191 1
a191 1
	  __glXFree( glxc );
d202 1
a202 1
	      __glXFree( glxc );
d222 1
a222 1
    glxc->real_ids = (XID *)__glXMalloc(sizeof(XID) * num_be_screens);
d226 1
a226 1
    glxc->real_vids = (XID *)__glXMalloc(sizeof(XID) * num_be_screens);
d251 3
a253 3
	     __glXFree( glxc->real_ids );
	     __glXFree( glxc->real_vids );
	     __glXFree( glxc );
d345 3
a347 3
       __glXFree( glxc->real_ids );
       __glXFree( glxc->real_vids );
       __glXFree( glxc );
d424 2
a425 2
	pGlxPixmap = (__GLXpixmap *) LookupIDByType(req->drawable,
						    __glXPixmapRes);
d430 2
a431 2
       pGlxWindow = (__glXWindow *) LookupIDByType(req->drawable,
						   __glXWindowRes);
d454 2
a455 2
	pGlxPixmap = (__GLXpixmap *) LookupIDByType(req->drawable,
						    __glXPixmapRes);
d460 2
a461 2
       pGlxWindow = (__glXWindow *) LookupIDByType(req->drawable,
						   __glXWindowRes);
d474 3
a476 2
	    pGlxPixmap = (__GLXpixmap *) LookupIDByType(req->member,
							__glXPixmapRes);
d481 3
a483 2
	    pGlxWindow = (__glXWindow *) LookupIDByType(req->member,
							__glXWindowRes);
d511 2
a512 1
    glxc = (__GLXcontext *) LookupIDByType(gcId, __glXContextRes);
d587 3
a589 3
	table = (__GLXcontext **) __glXMalloc(sizeof(__GLXcontext *));
	cl->currentDrawables = (DrawablePtr *) __glXMalloc(sizeof(DrawablePtr));
	cl->be_currentCTag = (GLXContextTag *) __glXMalloc(screenInfo.numScreens *sizeof(GLXContextTag));
d591 1
a591 1
	table = (__GLXcontext **) __glXRealloc(table,
d593 1
a593 1
	cl->currentDrawables = (DrawablePtr *) __glXRealloc(
d596 1
a596 1
	cl->be_currentCTag = (GLXContextTag *) __glXRealloc(cl->be_currentCTag,
d759 2
a760 1
	glxc = (__GLXcontext *) LookupIDByType(contextId, __glXContextRes);
d810 3
a812 2
	    pGlxPixmap = (__GLXpixmap *) LookupIDByType(drawId,
							__glXPixmapRes);
d835 3
a837 1
	   pGlxWindow = (__glXWindow *) LookupIDByType(drawId, __glXWindowRes);
d858 3
a860 1
	   pGlxPbuffer = (__glXPbuffer *)LookupIDByType(drawId, __glXPbufferRes);
d921 3
a923 2
	    pReadGlxPixmap = (__GLXpixmap *) LookupIDByType(readId,
							__glXPixmapRes);
d943 3
a945 2
	   pGlxReadWindow = (__glXWindow *)
                                LookupIDByType(readId, __glXWindowRes);
d965 3
a967 1
	   pGlxReadPbuffer = (__glXPbuffer *)LookupIDByType(readId, __glXPbufferRes);
d1107 3
a1109 2
	  pXinDraw = (PanoramiXRes *)
	     SecurityLookupIDByClass(client, pDraw->id, XRC_DRAWABLE, DixReadAccess);
d1114 3
a1116 2
	  pXinReadDraw = (PanoramiXRes *)
	     SecurityLookupIDByClass(client, pReadDraw->id, XRC_DRAWABLE, DixReadAccess);
d1322 2
a1323 1
    glxc = (__GLXcontext *) LookupIDByType(req->context, __glXContextRes);
d1469 2
a1470 1
    src = (__GLXcontext *) LookupIDByType(source, __glXContextRes);
d1475 2
a1476 1
    dst = (__GLXcontext *) LookupIDByType(dest, __glXContextRes);
d1663 1
a1663 1
    if (fbconfigId == NULL && visual == NULL) {
d1736 1
d1739 1
a1739 1
    pGlxPixmap = (__GLXpixmap *) __glXMalloc(sizeof(__GLXpixmap));
d1743 1
a1743 1
    pGlxPixmap->be_xids = (XID *) __glXMalloc(sizeof(XID) * screenInfo.numScreens);
d1745 1
a1745 1
        __glXFree( pGlxPixmap );
d1771 3
a1773 2
       pXinDraw = (PanoramiXRes *)
	  SecurityLookupIDByClass(client, pDraw->id, XRC_DRAWABLE, DixReadAccess);
d1851 1
a1851 1
          __glXFree( pGlxPixmap );
d1859 1
a1859 1
        __glXFree( pGlxPixmap );
d1894 2
a1895 1
    pGlxPixmap = (__GLXpixmap *)LookupIDByType(glxpixmap, __glXPixmapRes);
d1978 2
a1979 2
	pGlxPixmap = (__GLXpixmap *) LookupIDByType(drawId,
						    __glXPixmapRes);
d1990 2
a1991 1
       pGlxWindow = (__glXWindow *) LookupIDByType(drawId, __glXWindowRes);
d2020 3
a2022 2
       pXinDraw = (PanoramiXRes *)
        SecurityLookupIDByClass(client, pDraw->id, XRC_DRAWABLE, DixReadAccess);
d2127 2
a2128 2
	pGlxPixmap = (__GLXpixmap *) LookupIDByType(drawId,
						    __glXPixmapRes);
d2138 2
a2139 1
       pGlxWindow = (__glXWindow *) LookupIDByType(drawId, __glXWindowRes);
d2593 1
a2593 1
    if (cl->GLClientextensions) __glXFree(cl->GLClientextensions);
d2648 2
a2649 1
    pFont = (FontPtr)LookupIDByType(req->font, RT_FONT);
d2651 4
a2654 1
        GC *pGC = (GC *)LookupIDByType(req->font, RT_GC);
d2905 1
d2971 3
a2973 1
    if ( LookupIDByType(glxwindowId, __glXWindowRes) ) {
d3005 1
d3010 3
a3012 1
    if (!LookupIDByType(glxwindow, __glXWindowRes)) {
d3036 2
a3037 1
    ctx = (__GLXcontext *) LookupIDByType(req->context, __glXContextRes);
d3082 4
a3085 1
    ctx = (__GLXcontext *) SecurityLookupIDByType(client, req->context, __glXContextRes, DixReadAccess);
d3250 2
a3251 1
    pGlxPbuffer = (__glXPbuffer *)LookupIDByType(pbuffer, __glXPbufferRes);
d3299 1
a3299 1
   int attribs_size;
d3306 10
a3315 14
      if (rc == Success) {
	 if (pDraw->type == DRAWABLE_WINDOW) {
		WindowPtr pWin = (WindowPtr)pDraw;
		be_drawable = 0;
		screen = pWin->drawable.pScreen->myNum;

	 }
	 else {
	    /*
	     ** Drawable is not a Window , GLXWindow or a GLXPixmap.
	     */
	    client->errorValue = drawId;
	    return __glXBadDrawable;
	 }
d3319 4
a3322 2
	 __GLXpixmap *pGlxPixmap = (__GLXpixmap *) LookupIDByType(drawId,
							__glXPixmapRes);
d3331 4
a3334 1
	 __glXWindow *pGlxWindow = (__glXWindow *) LookupIDByType(drawId, __glXWindowRes);
d3343 4
a3346 1
	 __glXPbuffer *pGlxPbuffer = (__glXPbuffer *)LookupIDByType(drawId, __glXPbufferRes);
a3352 9


      if (!pDraw) {
	 /*
	  ** Drawable is not a Window , GLXWindow or a GLXPixmap.
	  */
	 client->errorValue = drawId;
	 return __glXBadDrawable;
      }
d3355 7
d3371 3
a3373 3
	  pXinDraw = (PanoramiXRes *)
	     SecurityLookupIDByClass(client, pDraw->id, XRC_DRAWABLE, DixReadAccess);
	  if (!pXinDraw) {
d3464 9
a3472 14
      if (rc == Success) {
	 if (pDraw->type == DRAWABLE_WINDOW) {
		WindowPtr pWin = (WindowPtr)pDraw;
		be_drawable = 0;
		screen = pWin->drawable.pScreen->myNum;

	 }
	 else {
	    /*
	     ** Drawable is not a Window , GLXWindow or a GLXPixmap.
	     */
	    client->errorValue = drawId;
	    return __glXBadDrawable;
	 }
d3476 4
a3479 2
	 __GLXpixmap *pGlxPixmap = (__GLXpixmap *) LookupIDByType(drawId,
							__glXPixmapRes);
d3488 4
a3491 1
	 __glXWindow *pGlxWindow = (__glXWindow *) LookupIDByType(drawId, __glXWindowRes);
d3500 4
a3503 1
	 __glXPbuffer *pGlxPbuffer = (__glXPbuffer *)LookupIDByType(drawId, __glXPbufferRes);
d3510 1
d3512 1
a3512 2

      if (!pDraw) {
d3518 1
a3518 3
      }
    }

d3528 4
a3531 3
	  PanoramiXRes *pXinDraw = (PanoramiXRes *)
	     SecurityLookupIDByClass(client, pDraw->id, XRC_DRAWABLE, DixReadAccess);
	  if (!pXinDraw) {
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d1539 1
a1539 1
    if (screen > screenInfo.numScreens) {
d2688 1
a2688 1
    if (screen > screenInfo.numScreens) {
d3110 1
a3110 1
    if (screen > screenInfo.numScreens) {
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d83 1
a83 1
   return( cl->be_displays[s] );
d631 1
a631 1
      return( 0 );
d2451 1
a2451 1
    be_buf = (char *)Xalloc(numbytes);
d2529 1
a2529 1
    be_buf = (char *)Xalloc(numbytes);
d2844 1
d2951 1
a2951 1
    pGlxWindow = (__glXWindow *) xalloc(sizeof(__glXWindow));
d3020 1
a3020 1
    sendBuf = (int *)xalloc(nReplyBytes);
d3035 1
a3035 1
    xfree((char *)sendBuf);
d3065 1
a3065 1
    sendBuf = (int *)xalloc(nReplyBytes);
d3082 1
a3082 1
    xfree((char *)sendBuf);
d3128 1
a3128 1
    pGlxPbuffer = (__glXPbuffer *) xalloc(sizeof(__glXPbuffer));
d3133 1
a3133 1
    pGlxPbuffer->be_xids = (XID *) xalloc( sizeof(XID) * screenInfo.numScreens );
d3135 1
a3135 1
        xfree(pGlxPbuffer);
d3384 1
a3384 1
      attribs = (CARD32 *) Xalloc(attribs_size);
d3408 1
a3408 1
   Xfree(attribs);
a3423 5
   char *attrbuf;
#ifdef PANORAMIX
    PanoramiXRes *pXinDraw = NULL;
    PanoramiXRes *pXinReadDraw = NULL;
#endif
d3490 1
a3490 1
	  pXinDraw = (PanoramiXRes *)
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a45 2
#define NEED_REPLIES
#define FONT_PCF
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d2 28
a29 33
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: The application programming interfaces
** established by SGI in conjunction with the Original Code are The
** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
** Window System(R) (Version 1.3), released October 19, 1998. This software
** was created using the OpenGL(R) version 1.2.1 Sample Implementation
** published by SGI, but has not been independently verified as being
** compliant with the OpenGL(R) version 1.2.1 Specification.
**
*/
d149 1
a149 1
    glxc = (__GLXcontext *) __glXMalloc(sizeof(__GLXcontext));
a152 1
    memset(glxc, 0, sizeof(__GLXcontext));
@


1.1
log
@Initial revision
@
text
@a68 1
extern XID *PanoramiXVisualTable;
d432 1
d434 2
a435 2
    pDraw = (DrawablePtr) LookupDrawable(req->drawable, client);
    if (!pDraw) {
d462 1
d464 2
a465 2
    pDraw = (DrawablePtr) LookupDrawable(req->drawable, client);
    if (!pDraw) {
d483 3
a485 2
	pMember = (DrawablePtr) LookupDrawable(req->member, client);
	if (!pMember) {
d739 1
a739 1
    int s;
d783 2
a784 2
	pDraw = (DrawablePtr) LookupDrawable(drawId, client);
	if (pDraw) {
d890 2
a891 2
	pReadDraw = (DrawablePtr) LookupDrawable(readId, client);
	if (pReadDraw) {
d1007 1
a1007 2
	if (prevglxc->pGlxReadPixmap && 
	    prevglxc->pGlxReadPixmap != prevglxc->pGlxPixmap ) {
d1025 1
a1025 2
	if (prevglxc->pGlxReadWindow &&
	    prevglxc->pGlxReadWindow != prevglxc->pGlxWindow) {
d1043 1
a1043 2
	if (prevglxc->pGlxReadPbuffer &&
	    prevglxc->pGlxReadPbuffer != prevglxc->pGlxPbuffer ) {
d1071 1
a1071 1
	if (pReadGlxPixmap && pReadGlxPixmap != pGlxPixmap) {
d1079 1
a1079 1
	if (pGlxReadWindow && pGlxReadWindow != pGlxWindow) {
d1087 1
a1087 1
	if (pGlxReadPbuffer && pGlxReadPbuffer != pGlxPbuffer) {
d1107 1
a1107 1
	     SecurityLookupIDByClass(client, pDraw->id, XRC_DRAWABLE, SecurityReadAccess);
d1113 1
a1113 1
	     SecurityLookupIDByClass(client, pReadDraw->id, XRC_DRAWABLE, SecurityReadAccess);
d1139 1
a1139 3
	  pWin = (WindowPtr)SecurityLookupWindow(pXinDraw->info[s].id,
		                                 client,
                                                 SecurityReadAccess);
d1195 2
a1196 3
   	     pReadWin = (WindowPtr)SecurityLookupWindow(pXinReadDraw->info[s].id,
		   client,
		   SecurityReadAccess);
d1638 1
a1638 2
    int i;
    int s;
d1644 4
a1647 5
    pDraw = (DrawablePtr) LookupDrawable(pixmapId, client);
    if (!pDraw || pDraw->type != DRAWABLE_PIXMAP) {
	client->errorValue = pixmapId;
	return BadPixmap;
    }
d1765 1
a1765 1
	  SecurityLookupIDByClass(client, pDraw->id, XRC_DRAWABLE, SecurityReadAccess);
d1778 2
a1779 1
	  pRealDraw = (DrawablePtr) LookupDrawable(pXinDraw->info[s].id,client);
d1945 1
a1945 1
    int s;
d1950 2
a1951 3
    pDraw = (DrawablePtr) LookupDrawable(drawId, client);
    if (pDraw) {

d2011 1
a2011 1
        SecurityLookupIDByClass(client, pDraw->id, XRC_DRAWABLE, SecurityReadAccess);
d2055 1
a2055 3
	  pWin = (WindowPtr)SecurityLookupWindow(pXinDraw->info[s].id,
		                                 client,
                                                 SecurityReadAccess);
d2099 1
d2104 2
a2105 2
    pDraw = (DrawablePtr) LookupDrawable(drawId, client);
    if (pDraw) {
d2823 2
a2824 8
              for (v=0; v<255; v++) {
		 if ( PanoramiXVisualTable[ v * MAXSCREENS + screen ] ==
		      associatedVisualId ) {
		    associatedVisualId = v;
		    break;
		 } 
	      }
	      pFBConfig->associatedVisualId = associatedVisualId;
d2887 1
a2887 1
    int i;
d2892 4
a2895 5
    pDraw = (DrawablePtr) LookupDrawable(windowId, client);
    if (!pDraw || pDraw->type != DRAWABLE_WINDOW) {
	client->errorValue = windowId;
	return BadWindow;
    }
d3058 1
a3058 1
    ctx = (__GLXcontext *) SecurityLookupIDByType(client, req->context, __glXContextRes, SecurityReadAccess);
d3268 1
a3268 1
   int screen;
d3277 2
a3278 2
      pDraw = (DrawablePtr) LookupDrawable(drawId, client);
      if (pDraw) {
d3342 1
a3342 1
	     SecurityLookupIDByClass(client, pDraw->id, XRC_DRAWABLE, SecurityReadAccess);
d3348 2
a3349 3
	  pWin = (WindowPtr)SecurityLookupWindow(pXinDraw->info[screen].id,
		client,
		SecurityReadAccess);
d3429 1
a3429 1
   int screen;
d3438 2
a3439 2
      pDraw = (DrawablePtr) LookupDrawable(drawId, client);
      if (pDraw) {
d3503 1
a3503 1
	     SecurityLookupIDByClass(client, pDraw->id, XRC_DRAWABLE, SecurityReadAccess);
d3509 2
a3510 3
	  pWin = (WindowPtr)SecurityLookupWindow(pXinDraw->info[screen].id,
		client,
		SecurityReadAccess);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a432 1
    int rc;
d434 2
a435 2
    rc = dixLookupDrawable(&pDraw, req->drawable, client, 0, DixUnknownAccess);
    if (rc != Success) {
a461 1
    int rc;
d463 2
a464 2
    rc = dixLookupDrawable(&pDraw, req->drawable, client, 0, DixUnknownAccess);
    if (rc != Success) {
d482 2
a483 3
	rc = dixLookupDrawable(&pMember, req->member, client, 0,
			       DixUnknownAccess);
	if (rc != Success) {
d737 1
a737 1
    int s, rc;
d781 2
a782 2
	rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixUnknownAccess);
	if (rc == Success) {
d888 2
a889 2
	rc = dixLookupDrawable(&pReadDraw, readId, client, 0,DixUnknownAccess);
	if (rc == Success) {
d1108 1
a1108 1
	     SecurityLookupIDByClass(client, pDraw->id, XRC_DRAWABLE, DixReadAccess);
d1114 1
a1114 1
	     SecurityLookupIDByClass(client, pReadDraw->id, XRC_DRAWABLE, DixReadAccess);
d1140 3
a1142 1
	  dixLookupWindow(&pWin, pXinDraw->info[s].id, client, DixReadAccess);
d1198 3
a1200 2
	     dixLookupWindow(&pReadWin, pXinReadDraw->info[s].id, client,
			     DixReadAccess);
d1642 2
a1643 1
    int i, s, rc;
d1649 5
a1653 4
    rc = dixLookupDrawable(&pDraw, pixmapId, client, M_DRAWABLE_PIXMAP,
			   DixUnknownAccess);
    if (rc != Success)
	return rc;
d1771 1
a1771 1
	  SecurityLookupIDByClass(client, pDraw->id, XRC_DRAWABLE, DixReadAccess);
d1784 1
a1784 2
	   dixLookupDrawable(&pRealDraw, pXinDraw->info[s].id, client, 0,
			     DixUnknownAccess);
d1950 1
a1950 1
    int s, rc;
d1955 3
a1957 2
    rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixUnknownAccess);
    if (rc == Success) {
d2017 1
a2017 1
        SecurityLookupIDByClass(client, pDraw->id, XRC_DRAWABLE, DixReadAccess);
d2061 3
a2063 1
	  dixLookupWindow(&pWin, pXinDraw->info[s].id, client, DixReadAccess);
a2106 1
    int rc;
d2111 2
a2112 2
    rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixUnknownAccess);
    if (rc == Success) {
d2900 1
a2900 1
    int i, rc;
d2905 5
a2909 4
    rc = dixLookupDrawable(&pDraw, windowId, client, M_DRAWABLE_WINDOW,
			   DixUnknownAccess);
    if (rc != Success)
	return rc;
d3072 1
a3072 1
    ctx = (__GLXcontext *) SecurityLookupIDByType(client, req->context, __glXContextRes, DixReadAccess);
d3282 1
a3282 1
   int screen, rc;
d3291 2
a3292 2
      rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixUnknownAccess);
      if (rc == Success) {
d3356 1
a3356 1
	     SecurityLookupIDByClass(client, pDraw->id, XRC_DRAWABLE, DixReadAccess);
d3362 3
a3364 2
	  dixLookupWindow(&pWin, pXinDraw->info[screen].id, client,
			  DixReadAccess);
d3444 1
a3444 1
   int screen, rc;
d3453 2
a3454 2
      rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixUnknownAccess);
      if (rc == Success) {
d3518 1
a3518 1
	     SecurityLookupIDByClass(client, pDraw->id, XRC_DRAWABLE, DixReadAccess);
d3524 3
a3526 2
	  dixLookupWindow(&pWin, pXinDraw->info[screen].id, client,
			  DixReadAccess);
@

