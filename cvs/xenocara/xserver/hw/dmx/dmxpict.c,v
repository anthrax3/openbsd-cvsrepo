head	1.11;
access;
symbols
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.8
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	7pAEtF6Y5EgemkuY;

1.9
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.16;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.42;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.42;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.11.04;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.18.02.23;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Kevin E. Martin <kem@@redhat.com>
 *
 */

/** \file
 *  Provide support for the RENDER extension (version 0.8).
 */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include "dmx.h"
#include "dmxsync.h"
#include "dmxpict.h"
#include "dmxwindow.h"
#include "dmxpixmap.h"

#include "fb.h"
#include "pixmapstr.h"
#include "dixstruct.h"

#include <X11/extensions/render.h>
#include <X11/extensions/renderproto.h>
#include <X11/extensions/Xfixes.h>
#include "picture.h"
#include "picturestr.h"
#include "mipict.h"
#include "fbpict.h"

extern int (*ProcRenderVector[RenderNumberRequests]) (ClientPtr);

static int (*dmxSaveRenderVector[RenderNumberRequests]) (ClientPtr);

static int dmxProcRenderCreateGlyphSet(ClientPtr client);
static int dmxProcRenderFreeGlyphSet(ClientPtr client);
static int dmxProcRenderAddGlyphs(ClientPtr client);
static int dmxProcRenderFreeGlyphs(ClientPtr client);
static int dmxProcRenderCompositeGlyphs(ClientPtr client);
static int dmxProcRenderSetPictureTransform(ClientPtr client);
static int dmxProcRenderSetPictureFilter(ClientPtr client);

#if 0
/* FIXME: Not (yet) supported */
static int dmxProcRenderCreateCursor(ClientPtr client);
static int dmxProcRenderCreateAnimCursor(ClientPtr client);
#endif

/** Catch errors that might occur when allocating Glyph Sets.  Errors
 *  are saved in dmxGlyphLastError for later handling. */
static int dmxGlyphLastError;
static int
dmxGlyphErrorHandler(Display * dpy, XErrorEvent * ev)
{
    dmxGlyphLastError = ev->error_code;
    return 0;
}

/** Initialize the Proc Vector for the RENDER extension.  The functions
 *  here cannot be handled by the mi layer RENDER hooks either because
 *  the required information is no longer available when it reaches the
 *  mi layer or no mi layer hooks exist.  This function is called from
 *  InitOutput() since it should be initialized only once per server
 *  generation. */
void
dmxInitRender(void)
{
    int i;

    for (i = 0; i < RenderNumberRequests; i++)
        dmxSaveRenderVector[i] = ProcRenderVector[i];

    ProcRenderVector[X_RenderCreateGlyphSet]
        = dmxProcRenderCreateGlyphSet;
    ProcRenderVector[X_RenderFreeGlyphSet]
        = dmxProcRenderFreeGlyphSet;
    ProcRenderVector[X_RenderAddGlyphs]
        = dmxProcRenderAddGlyphs;
    ProcRenderVector[X_RenderFreeGlyphs]
        = dmxProcRenderFreeGlyphs;
    ProcRenderVector[X_RenderCompositeGlyphs8]
        = dmxProcRenderCompositeGlyphs;
    ProcRenderVector[X_RenderCompositeGlyphs16]
        = dmxProcRenderCompositeGlyphs;
    ProcRenderVector[X_RenderCompositeGlyphs32]
        = dmxProcRenderCompositeGlyphs;
    ProcRenderVector[X_RenderSetPictureTransform]
        = dmxProcRenderSetPictureTransform;
    ProcRenderVector[X_RenderSetPictureFilter]
        = dmxProcRenderSetPictureFilter;
}

/** Reset the Proc Vector for the RENDER extension back to the original
 *  functions.  This function is called from dmxCloseScreen() during the
 *  server reset (only for screen #0). */
void
dmxResetRender(void)
{
    int i;

    for (i = 0; i < RenderNumberRequests; i++)
        ProcRenderVector[i] = dmxSaveRenderVector[i];
}

/** Initialize the RENDER extension, allocate the picture privates and
 *  wrap mi function hooks.  If the shadow frame buffer is used, then
 *  call the appropriate fb initialization function. */
Bool
dmxPictureInit(ScreenPtr pScreen, PictFormatPtr formats, int nformats)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr ps;

    if (!miPictureInit(pScreen, formats, nformats))
        return FALSE;

    if (!dixRegisterPrivateKey
        (&dmxPictPrivateKeyRec, PRIVATE_PICTURE, sizeof(dmxPictPrivRec)))
        return FALSE;

    ps = GetPictureScreen(pScreen);

    DMX_WRAP(CreatePicture, dmxCreatePicture, dmxScreen, ps);
    DMX_WRAP(DestroyPicture, dmxDestroyPicture, dmxScreen, ps);

    DMX_WRAP(ChangePictureClip, dmxChangePictureClip, dmxScreen, ps);
    DMX_WRAP(DestroyPictureClip, dmxDestroyPictureClip, dmxScreen, ps);

    DMX_WRAP(ChangePicture, dmxChangePicture, dmxScreen, ps);
    DMX_WRAP(ValidatePicture, dmxValidatePicture, dmxScreen, ps);

    DMX_WRAP(Composite, dmxComposite, dmxScreen, ps);
    DMX_WRAP(Glyphs, dmxGlyphs, dmxScreen, ps);
    DMX_WRAP(CompositeRects, dmxCompositeRects, dmxScreen, ps);

    DMX_WRAP(Trapezoids, dmxTrapezoids, dmxScreen, ps);
    DMX_WRAP(Triangles, dmxTriangles, dmxScreen, ps);

    return TRUE;
}

/** Find the appropriate format on the requested screen given the
 *  internal format requested.  The list of formats is searched
 *  sequentially as the XRenderFindFormat() function does not always
 *  find the appropriate format when a specific format is requested. */
static XRenderPictFormat *
dmxFindFormat(DMXScreenInfo * dmxScreen, PictFormatPtr pFmt)
{
    XRenderPictFormat *pFormat = NULL;
    int i = 0;

    if (!pFmt || !dmxScreen->beDisplay)
        return pFormat;

    while (1) {
        pFormat = XRenderFindFormat(dmxScreen->beDisplay, 0, 0, i++);
        if (!pFormat)
            break;

        if (pFormat->type != pFmt->type)
            continue;
        if (pFormat->depth != pFmt->depth)
            continue;
        if (pFormat->direct.red != pFmt->direct.red)
            continue;
        if (pFormat->direct.redMask != pFmt->direct.redMask)
            continue;
        if (pFormat->direct.green != pFmt->direct.green)
            continue;
        if (pFormat->direct.greenMask != pFmt->direct.greenMask)
            continue;
        if (pFormat->direct.blue != pFmt->direct.blue)
            continue;
        if (pFormat->direct.blueMask != pFmt->direct.blueMask)
            continue;
        if (pFormat->direct.alpha != pFmt->direct.alpha)
            continue;
        if (pFormat->direct.alphaMask != pFmt->direct.alphaMask)
            continue;

        /* We have a match! */
        break;
    }

    return pFormat;
}

/** Free \a glyphSet on back-end screen number \a idx. */
Bool
dmxBEFreeGlyphSet(ScreenPtr pScreen, GlyphSetPtr glyphSet)
{
    dmxGlyphPrivPtr glyphPriv = DMX_GET_GLYPH_PRIV(glyphSet);
    int idx = pScreen->myNum;
    DMXScreenInfo *dmxScreen = &dmxScreens[idx];

    if (glyphPriv->glyphSets[idx]) {
        XRenderFreeGlyphSet(dmxScreen->beDisplay, glyphPriv->glyphSets[idx]);
        glyphPriv->glyphSets[idx] = (GlyphSet) 0;
        return TRUE;
    }

    return FALSE;
}

/** Create \a glyphSet on the backend screen number \a idx. */
int
dmxBECreateGlyphSet(int idx, GlyphSetPtr glyphSet)
{
    XRenderPictFormat *pFormat;
    DMXScreenInfo *dmxScreen = &dmxScreens[idx];
    dmxGlyphPrivPtr glyphPriv = DMX_GET_GLYPH_PRIV(glyphSet);
    PictFormatPtr pFmt = glyphSet->format;
    int (*oldErrorHandler) (Display *, XErrorEvent *);

    pFormat = dmxFindFormat(dmxScreen, pFmt);
    if (!pFormat) {
        return BadMatch;
    }

    dmxGlyphLastError = 0;
    oldErrorHandler = XSetErrorHandler(dmxGlyphErrorHandler);

    /* Catch when this fails */
    glyphPriv->glyphSets[idx]
        = XRenderCreateGlyphSet(dmxScreen->beDisplay, pFormat);

    XSetErrorHandler(oldErrorHandler);

    if (dmxGlyphLastError) {
        return dmxGlyphLastError;
    }

    return Success;
}

/** Create a Glyph Set on each screen.  Save the glyphset ID from each
 *  screen in the Glyph Set's private structure.  Fail if the format
 *  requested is not available or if the Glyph Set cannot be created on
 *  the screen. */
static int
dmxProcRenderCreateGlyphSet(ClientPtr client)
{
    int ret;

    REQUEST(xRenderCreateGlyphSetReq);

    ret = dmxSaveRenderVector[stuff->renderReqType] (client);

    if (ret == Success) {
        GlyphSetPtr glyphSet;
        dmxGlyphPrivPtr glyphPriv;
        int i;

        /* Look up glyphSet that was just created ???? */
        /* Store glyphsets from backends in glyphSet->devPrivate ????? */
        /* Make sure we handle all errors here!! */

        dixLookupResourceByType((void **) &glyphSet,
                                stuff->gsid, GlyphSetType,
                                client, DixDestroyAccess);

        glyphPriv = malloc(sizeof(dmxGlyphPrivRec));
        if (!glyphPriv)
            return BadAlloc;
        glyphPriv->glyphSets = NULL;
        MAXSCREENSALLOC_RETURN(glyphPriv->glyphSets, BadAlloc);
        DMX_SET_GLYPH_PRIV(glyphSet, glyphPriv);

        for (i = 0; i < dmxNumScreens; i++) {
            DMXScreenInfo *dmxScreen = &dmxScreens[i];
            int beret;

            if (!dmxScreen->beDisplay) {
                glyphPriv->glyphSets[i] = 0;
                continue;
            }

            if ((beret = dmxBECreateGlyphSet(i, glyphSet)) != Success) {
                int j;

                /* Free the glyph sets we've allocated thus far */
                for (j = 0; j < i; j++)
                    dmxBEFreeGlyphSet(screenInfo.screens[j], glyphSet);

                /* Free the resource created by render */
                FreeResource(stuff->gsid, RT_NONE);

                return beret;
            }
        }
    }

    return ret;
}

/** Free the previously allocated Glyph Sets for each screen. */
static int
dmxProcRenderFreeGlyphSet(ClientPtr client)
{
    GlyphSetPtr glyphSet;

    REQUEST(xRenderFreeGlyphSetReq);

    REQUEST_SIZE_MATCH(xRenderFreeGlyphSetReq);
    dixLookupResourceByType((void **) &glyphSet,
                            stuff->glyphset, GlyphSetType,
                            client, DixDestroyAccess);

    if (glyphSet && glyphSet->refcnt == 1) {
        dmxGlyphPrivPtr glyphPriv = DMX_GET_GLYPH_PRIV(glyphSet);
        int i;

        for (i = 0; i < dmxNumScreens; i++) {
            DMXScreenInfo *dmxScreen = &dmxScreens[i];

            if (dmxScreen->beDisplay) {
                if (dmxBEFreeGlyphSet(screenInfo.screens[i], glyphSet))
                    dmxSync(dmxScreen, FALSE);
            }
        }

        MAXSCREENSFREE(glyphPriv->glyphSets);
        free(glyphPriv);
        DMX_SET_GLYPH_PRIV(glyphSet, NULL);
    }

    return dmxSaveRenderVector[stuff->renderReqType] (client);
}

/** Add glyphs to the Glyph Set on each screen. */
static int
dmxProcRenderAddGlyphs(ClientPtr client)
{
    int ret;

    REQUEST(xRenderAddGlyphsReq);

    ret = dmxSaveRenderVector[stuff->renderReqType] (client);

    if (ret == Success) {
        GlyphSetPtr glyphSet;
        dmxGlyphPrivPtr glyphPriv;
        int i;
        int nglyphs;
        CARD32 *gids;
        Glyph *gidsCopy;
        xGlyphInfo *gi;
        CARD8 *bits;
        int nbytes;

        dixLookupResourceByType((void **) &glyphSet,
                                stuff->glyphset, GlyphSetType,
                                client, DixReadAccess);
        glyphPriv = DMX_GET_GLYPH_PRIV(glyphSet);

        nglyphs = stuff->nglyphs;
        gids = (CARD32 *) (stuff + 1);
        gi = (xGlyphInfo *) (gids + nglyphs);
        bits = (CARD8 *) (gi + nglyphs);
        nbytes = ((stuff->length << 2) -
                  sizeof(xRenderAddGlyphsReq) -
                  (sizeof(CARD32) + sizeof(xGlyphInfo)) * nglyphs);

        gidsCopy = xallocarray(nglyphs, sizeof(*gidsCopy));
        for (i = 0; i < nglyphs; i++)
            gidsCopy[i] = gids[i];

        /* FIXME: Will this ever fail? */
        for (i = 0; i < dmxNumScreens; i++) {
            DMXScreenInfo *dmxScreen = &dmxScreens[i];

            if (dmxScreen->beDisplay) {
                XRenderAddGlyphs(dmxScreen->beDisplay,
                                 glyphPriv->glyphSets[i],
                                 gidsCopy,
                                 (XGlyphInfo *) gi,
                                 nglyphs, (char *) bits, nbytes);
                dmxSync(dmxScreen, FALSE);
            }
        }
        free(gidsCopy);
    }

    return ret;
}

/** Free glyphs from the Glyph Set for each screen. */
static int
dmxProcRenderFreeGlyphs(ClientPtr client)
{
    GlyphSetPtr glyphSet;

    REQUEST(xRenderFreeGlyphsReq);

    REQUEST_AT_LEAST_SIZE(xRenderFreeGlyphsReq);
    dixLookupResourceByType((void **) &glyphSet,
                            stuff->glyphset, GlyphSetType,
                            client, DixWriteAccess);

    if (glyphSet) {
        dmxGlyphPrivPtr glyphPriv = DMX_GET_GLYPH_PRIV(glyphSet);
        int i;
        int nglyphs;
        Glyph *gids;

        nglyphs = ((client->req_len << 2) - sizeof(xRenderFreeGlyphsReq)) >> 2;
        if (nglyphs) {
            gids = xallocarray(nglyphs, sizeof(*gids));
            for (i = 0; i < nglyphs; i++)
                gids[i] = ((CARD32 *) (stuff + 1))[i];

            for (i = 0; i < dmxNumScreens; i++) {
                DMXScreenInfo *dmxScreen = &dmxScreens[i];

                if (dmxScreen->beDisplay) {
                    XRenderFreeGlyphs(dmxScreen->beDisplay,
                                      glyphPriv->glyphSets[i], gids, nglyphs);
                    dmxSync(dmxScreen, FALSE);
                }
            }
            free(gids);
        }
    }

    return dmxSaveRenderVector[stuff->renderReqType] (client);
}

/** Composite glyphs on each screen into the requested picture.  If
 *  either the src or dest picture has not been allocated due to lazy
 *  window creation, this request will gracefully return. */
static int
dmxProcRenderCompositeGlyphs(ClientPtr client)
{
    int ret;

    REQUEST(xRenderCompositeGlyphsReq);

    ret = dmxSaveRenderVector[stuff->renderReqType] (client);

    /* For the following to work with PanoramiX, it assumes that Render
     * wraps the ProcRenderVector after dmxRenderInit has been called.
     */
    if (ret == Success) {
        PicturePtr pSrc;
        dmxPictPrivPtr pSrcPriv;
        PicturePtr pDst;
        dmxPictPrivPtr pDstPriv;
        PictFormatPtr pFmt;
        XRenderPictFormat *pFormat;
        int size;

        int scrnNum;
        DMXScreenInfo *dmxScreen;

        CARD8 *buffer;
        CARD8 *end;
        int space;

        int nglyph;
        char *glyphs;
        char *curGlyph;

        xGlyphElt *elt;
        int nelt;
        XGlyphElt8 *elts;
        XGlyphElt8 *curElt;

        GlyphSetPtr glyphSet;
        dmxGlyphPrivPtr glyphPriv;

        dixLookupResourceByType((void **) &pSrc,
                                stuff->src, PictureType, client, DixReadAccess);

        pSrcPriv = DMX_GET_PICT_PRIV(pSrc);
        if (!pSrcPriv->pict)
            return ret;

        dixLookupResourceByType((void **) &pDst,
                                stuff->dst, PictureType,
                                client, DixWriteAccess);

        pDstPriv = DMX_GET_PICT_PRIV(pDst);
        if (!pDstPriv->pict)
            return ret;

        scrnNum = pDst->pDrawable->pScreen->myNum;
        dmxScreen = &dmxScreens[scrnNum];

        /* Note: If the back-end display has been detached, then it
         * should not be possible to reach here since the pSrcPriv->pict
         * and pDstPriv->pict will have already been set to 0.
         */
        if (!dmxScreen->beDisplay)
            return ret;

        if (stuff->maskFormat)
            dixLookupResourceByType((void **) &pFmt,
                                    stuff->maskFormat, PictFormatType,
                                    client, DixReadAccess);
        else
            pFmt = NULL;

        pFormat = dmxFindFormat(dmxScreen, pFmt);

        switch (stuff->renderReqType) {
        case X_RenderCompositeGlyphs8:
            size = sizeof(CARD8);
            break;
        case X_RenderCompositeGlyphs16:
            size = sizeof(CARD16);
            break;
        case X_RenderCompositeGlyphs32:
            size = sizeof(CARD32);
            break;
        default:
            return BadPictOp;   /* Can't happen */
        }

        buffer = (CARD8 *) (stuff + 1);
        end = (CARD8 *) stuff + (stuff->length << 2);
        nelt = 0;
        nglyph = 0;
        while (buffer + sizeof(xGlyphElt) < end) {
            elt = (xGlyphElt *) buffer;
            buffer += sizeof(xGlyphElt);

            if (elt->len == 0xff) {
                buffer += 4;
            }
            else {
                nelt++;
                nglyph += elt->len;
                space = size * elt->len;
                if (space & 3)
                    space += 4 - (space & 3);
                buffer += space;
            }
        }

        /* The following only works for Render version > 0.2 */

        /* All of the XGlyphElt* structure sizes are identical */
        elts = xallocarray(nelt, sizeof(XGlyphElt8));
        if (!elts)
            return BadAlloc;

        glyphs = xallocarray(nglyph, size);
        if (!glyphs) {
            free(elts);
            return BadAlloc;
        }

        buffer = (CARD8 *) (stuff + 1);
        end = (CARD8 *) stuff + (stuff->length << 2);
        curGlyph = glyphs;
        curElt = elts;

        dixLookupResourceByType((void **) &glyphSet,
                                stuff->glyphset, GlyphSetType,
                                client, DixReadAccess);
        glyphPriv = DMX_GET_GLYPH_PRIV(glyphSet);

        while (buffer + sizeof(xGlyphElt) < end) {
            elt = (xGlyphElt *) buffer;
            buffer += sizeof(xGlyphElt);

            if (elt->len == 0xff) {
                dixLookupResourceByType((void **) &glyphSet,
                                        *((CARD32 *) buffer),
                                        GlyphSetType, client, DixReadAccess);
                glyphPriv = DMX_GET_GLYPH_PRIV(glyphSet);
                buffer += 4;
            }
            else {
                curElt->glyphset = glyphPriv->glyphSets[scrnNum];
                curElt->xOff = elt->deltax;
                curElt->yOff = elt->deltay;
                curElt->nchars = elt->len;
                curElt->chars = curGlyph;

                memcpy(curGlyph, buffer, size * elt->len);
                curGlyph += size * elt->len;

                curElt++;

                space = size * elt->len;
                if (space & 3)
                    space += 4 - (space & 3);
                buffer += space;
            }
        }

        switch (stuff->renderReqType) {
        case X_RenderCompositeGlyphs8:
            XRenderCompositeText8(dmxScreen->beDisplay, stuff->op,
                                  pSrcPriv->pict, pDstPriv->pict,
                                  pFormat,
                                  stuff->xSrc, stuff->ySrc, 0, 0, elts, nelt);
            break;
        case X_RenderCompositeGlyphs16:
            XRenderCompositeText16(dmxScreen->beDisplay, stuff->op,
                                   pSrcPriv->pict, pDstPriv->pict,
                                   pFormat,
                                   stuff->xSrc, stuff->ySrc,
                                   0, 0, (XGlyphElt16 *) elts, nelt);
            break;
        case X_RenderCompositeGlyphs32:
            XRenderCompositeText32(dmxScreen->beDisplay, stuff->op,
                                   pSrcPriv->pict, pDstPriv->pict,
                                   pFormat,
                                   stuff->xSrc, stuff->ySrc,
                                   0, 0, (XGlyphElt32 *) elts, nelt);
            break;
        }

        dmxSync(dmxScreen, FALSE);

        free(elts);
        free(glyphs);
    }

    return ret;
}

/** Set the picture transform on each screen. */
static int
dmxProcRenderSetPictureTransform(ClientPtr client)
{
    DMXScreenInfo *dmxScreen;
    PicturePtr pPicture;
    dmxPictPrivPtr pPictPriv;
    XTransform xform;

    REQUEST(xRenderSetPictureTransformReq);

    REQUEST_SIZE_MATCH(xRenderSetPictureTransformReq);
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixWriteAccess);

    /* For the following to work with PanoramiX, it assumes that Render
     * wraps the ProcRenderVector after dmxRenderInit has been called.
     */
    dmxScreen = &dmxScreens[pPicture->pDrawable->pScreen->myNum];
    pPictPriv = DMX_GET_PICT_PRIV(pPicture);

    if (pPictPriv->pict) {
        xform.matrix[0][0] = stuff->transform.matrix11;
        xform.matrix[0][1] = stuff->transform.matrix12;
        xform.matrix[0][2] = stuff->transform.matrix13;
        xform.matrix[1][0] = stuff->transform.matrix21;
        xform.matrix[1][1] = stuff->transform.matrix22;
        xform.matrix[1][2] = stuff->transform.matrix23;
        xform.matrix[2][0] = stuff->transform.matrix31;
        xform.matrix[2][1] = stuff->transform.matrix32;
        xform.matrix[2][2] = stuff->transform.matrix33;

        XRenderSetPictureTransform(dmxScreen->beDisplay,
                                   pPictPriv->pict, &xform);
        dmxSync(dmxScreen, FALSE);
    }

    return dmxSaveRenderVector[stuff->renderReqType] (client);
}

/** Set the picture filter on each screen. */
static int
dmxProcRenderSetPictureFilter(ClientPtr client)
{
    DMXScreenInfo *dmxScreen;
    PicturePtr pPicture;
    dmxPictPrivPtr pPictPriv;
    char *filter;
    XFixed *params;
    int nparams;

    REQUEST(xRenderSetPictureFilterReq);

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureFilterReq);
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixWriteAccess);

    /* For the following to work with PanoramiX, it assumes that Render
     * wraps the ProcRenderVector after dmxRenderInit has been called.
     */
    dmxScreen = &dmxScreens[pPicture->pDrawable->pScreen->myNum];
    pPictPriv = DMX_GET_PICT_PRIV(pPicture);

    if (pPictPriv->pict) {
        filter = (char *) (stuff + 1);
        params = (XFixed *) (filter + ((stuff->nbytes + 3) & ~3));
        nparams = ((XFixed *) stuff + client->req_len) - params;

        XRenderSetPictureFilter(dmxScreen->beDisplay,
                                pPictPriv->pict, filter, params, nparams);
        dmxSync(dmxScreen, FALSE);
    }

    return dmxSaveRenderVector[stuff->renderReqType] (client);
}

/** Create a picture on the appropriate screen.  This is the actual
 *  function that creates the picture.  However, if the associated
 *  window has not yet been created due to lazy window creation, then
 *  delay the picture creation until the window is mapped. */
static Picture
dmxDoCreatePicture(PicturePtr pPicture)
{
    DrawablePtr pDraw = pPicture->pDrawable;
    ScreenPtr pScreen = pDraw->pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    XRenderPictFormat *pFormat;
    Drawable draw;

    if (pPicture->pDrawable->type == DRAWABLE_WINDOW) {
        dmxWinPrivPtr pWinPriv = DMX_GET_WINDOW_PRIV((WindowPtr) (pDraw));

        if (!(draw = pWinPriv->window)) {
            /* Window has not been created yet due to the window
             * optimization.  Delay picture creation until window is
             * mapped.
             */
            pWinPriv->hasPict = TRUE;
            return 0;
        }
    }
    else {
        dmxPixPrivPtr pPixPriv = DMX_GET_PIXMAP_PRIV((PixmapPtr) (pDraw));

        if (!(draw = pPixPriv->pixmap)) {
            /* FIXME: Zero width/height pixmap?? */
            return 0;
        }
    }

    /* This should not be reached if the back-end display has been
     * detached because the pWinPriv->window or the pPixPriv->pixmap
     * will be NULL; however, we add it here for completeness
     */
    if (!dmxScreen->beDisplay)
        return 0;

    pFormat = dmxFindFormat(dmxScreen, pPicture->pFormat);

    return XRenderCreatePicture(dmxScreen->beDisplay, draw, pFormat, 0, 0);
}

/** Create a list of pictures.  This function is called by
 *  dmxCreateAndRealizeWindow() during the lazy window creation
 *  realization process.  It creates the entire list of pictures that
 *  are associated with the given window. */
void
dmxCreatePictureList(WindowPtr pWindow)
{
    PicturePtr pPicture = GetPictureWindow(pWindow);

    while (pPicture) {
        dmxPictPrivPtr pPictPriv = DMX_GET_PICT_PRIV(pPicture);

        /* Create the picture for this window */
        pPictPriv->pict = dmxDoCreatePicture(pPicture);

        /* ValidatePicture takes care of the state changes */

        pPicture = pPicture->pNext;
    }
}

/** Create \a pPicture on the backend. */
int
dmxBECreatePicture(PicturePtr pPicture)
{
    dmxPictPrivPtr pPictPriv = DMX_GET_PICT_PRIV(pPicture);

    /* Create picutre on BE */
    pPictPriv->pict = dmxDoCreatePicture(pPicture);

    /* Flush changes to the backend server */
    dmxValidatePicture(pPicture, (1 << (CPLastBit + 1)) - 1);

    return Success;
}

/** Create a picture.  This function handles the CreatePicture
 *  unwrapping/wrapping and calls dmxDoCreatePicture to actually create
 *  the picture on the appropriate screen.  */
int
dmxCreatePicture(PicturePtr pPicture)
{
    ScreenPtr pScreen = pPicture->pDrawable->pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    dmxPictPrivPtr pPictPriv = DMX_GET_PICT_PRIV(pPicture);
    int ret = Success;

    DMX_UNWRAP(CreatePicture, dmxScreen, ps);
#if 1
    if (ps->CreatePicture)
        ret = ps->CreatePicture(pPicture);
#endif

    /* Create picture on back-end server */
    pPictPriv->pict = dmxDoCreatePicture(pPicture);
    pPictPriv->savedMask = 0;

    DMX_WRAP(CreatePicture, dmxCreatePicture, dmxScreen, ps);

    return ret;
}

/** Destroy \a pPicture on the back-end server. */
Bool
dmxBEFreePicture(PicturePtr pPicture)
{
    ScreenPtr pScreen = pPicture->pDrawable->pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxPictPrivPtr pPictPriv = DMX_GET_PICT_PRIV(pPicture);

    if (pPictPriv->pict) {
        XRenderFreePicture(dmxScreen->beDisplay, pPictPriv->pict);
        pPictPriv->pict = (Picture) 0;
        return TRUE;
    }

    return FALSE;
}

/** Destroy a list of pictures that are associated with the window that
 *  is being destroyed.  This function is called by #dmxDestroyWindow().
 *  */
Bool
dmxDestroyPictureList(WindowPtr pWindow)
{
    PicturePtr pPicture = GetPictureWindow(pWindow);
    Bool ret = FALSE;

    while (pPicture) {
        ret |= dmxBEFreePicture(pPicture);
        pPicture = pPicture->pNext;
    }

    return ret;
}

/** Destroy a picture.  This function calls the wrapped function that
 *  frees the resources in the DMX server associated with this
 *  picture. */
void
dmxDestroyPicture(PicturePtr pPicture)
{
    ScreenPtr pScreen = pPicture->pDrawable->pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr ps = GetPictureScreen(pScreen);

    DMX_UNWRAP(DestroyPicture, dmxScreen, ps);

    /* Destroy picture on back-end server */
    if (dmxBEFreePicture(pPicture))
        dmxSync(dmxScreen, FALSE);

#if 1
    if (ps->DestroyPicture)
        ps->DestroyPicture(pPicture);
#endif
    DMX_WRAP(DestroyPicture, dmxDestroyPicture, dmxScreen, ps);
}

/** Change the picture's list of clip rectangles. */
int
dmxChangePictureClip(PicturePtr pPicture, int clipType, void *value, int n)
{
    ScreenPtr pScreen = pPicture->pDrawable->pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    dmxPictPrivPtr pPictPriv = DMX_GET_PICT_PRIV(pPicture);

    DMX_UNWRAP(ChangePictureClip, dmxScreen, ps);
#if 1
    if (ps->ChangePictureClip)
        ps->ChangePictureClip(pPicture, clipType, value, n);
#endif

    /* Change picture clip rects on back-end server */
    if (pPictPriv->pict) {
        /* The clip has already been changed into a region by the mi
         * routine called above.
         */
        if (clipType == CT_NONE) {
            /* Disable clipping, show all */
            XFixesSetPictureClipRegion(dmxScreen->beDisplay,
                                       pPictPriv->pict, 0, 0, None);
        }
        else if (pPicture->clientClip) {
            RegionPtr pClip = pPicture->clientClip;
            BoxPtr pBox = RegionRects(pClip);
            int nBox = RegionNumRects(pClip);
            XRectangle *pRects;
            XRectangle *pRect;
            int nRects;

            nRects = nBox;
            pRects = pRect = xallocarray(nRects, sizeof(*pRect));

            while (nBox--) {
                pRect->x = pBox->x1;
                pRect->y = pBox->y1;
                pRect->width = pBox->x2 - pBox->x1;
                pRect->height = pBox->y2 - pBox->y1;
                pBox++;
                pRect++;
            }

            XRenderSetPictureClipRectangles(dmxScreen->beDisplay,
                                            pPictPriv->pict,
                                            0, 0, pRects, nRects);
            free(pRects);
        }
        else {
            XRenderSetPictureClipRectangles(dmxScreen->beDisplay,
                                            pPictPriv->pict, 0, 0, NULL, 0);
        }
        dmxSync(dmxScreen, FALSE);
    }
    else {
        /* FIXME: Handle saving clip region when offscreen */
    }

    DMX_WRAP(ChangePictureClip, dmxChangePictureClip, dmxScreen, ps);

    return Success;
}

/** Destroy the picture's list of clip rectangles. */
void
dmxDestroyPictureClip(PicturePtr pPicture)
{
    ScreenPtr pScreen = pPicture->pDrawable->pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    dmxPictPrivPtr pPictPriv = DMX_GET_PICT_PRIV(pPicture);

    DMX_UNWRAP(DestroyPictureClip, dmxScreen, ps);
#if 1
    if (ps->DestroyPictureClip)
        ps->DestroyPictureClip(pPicture);
#endif

    /* Destroy picture clip rects on back-end server */
    if (pPictPriv->pict) {
        XRenderSetPictureClipRectangles(dmxScreen->beDisplay,
                                        pPictPriv->pict, 0, 0, NULL, 0);
        dmxSync(dmxScreen, FALSE);
    }
    else {
        /* FIXME: Handle destroying clip region when offscreen */
    }

    DMX_WRAP(DestroyPictureClip, dmxDestroyPictureClip, dmxScreen, ps);
}

/** Change the attributes of the pictures.  If the picture has not yet
 *  been created due to lazy window creation, save the mask so that it
 *  can be used to appropriately initialize the picture's attributes
 *  when it is created later. */
void
dmxChangePicture(PicturePtr pPicture, Mask mask)
{
    ScreenPtr pScreen = pPicture->pDrawable->pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    dmxPictPrivPtr pPictPriv = DMX_GET_PICT_PRIV(pPicture);

    DMX_UNWRAP(ChangePicture, dmxScreen, ps);
#if 1
    if (ps->ChangePicture)
        ps->ChangePicture(pPicture, mask);
#endif

    /* Picture attribute changes are handled in ValidatePicture */
    pPictPriv->savedMask |= mask;

    DMX_WRAP(ChangePicture, dmxChangePicture, dmxScreen, ps);
}

/** Validate the picture's attributes before rendering to it.  Update
 *  any picture attributes that have been changed by one of the higher
 *  layers. */
void
dmxValidatePicture(PicturePtr pPicture, Mask mask)
{
    ScreenPtr pScreen = pPicture->pDrawable->pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    dmxPictPrivPtr pPictPriv = DMX_GET_PICT_PRIV(pPicture);

    DMX_UNWRAP(ValidatePicture, dmxScreen, ps);

    /* Change picture attributes on back-end server */
    if (pPictPriv->pict) {
        XRenderPictureAttributes attribs;

        if (mask & CPRepeat) {
            attribs.repeat = pPicture->repeatType;
        }
        if (mask & CPAlphaMap) {
            if (pPicture->alphaMap) {
                dmxPictPrivPtr pAlphaPriv;

                pAlphaPriv = DMX_GET_PICT_PRIV(pPicture->alphaMap);
                if (pAlphaPriv->pict) {
                    attribs.alpha_map = pAlphaPriv->pict;
                }
                else {
                    /* FIXME: alpha picture drawable has not been created?? */
                    return;     /* or should this be: attribs.alpha_map = None; */
                }
            }
            else {
                attribs.alpha_map = None;
            }
        }
        if (mask & CPAlphaXOrigin)
            attribs.alpha_x_origin = pPicture->alphaOrigin.x;
        if (mask & CPAlphaYOrigin)
            attribs.alpha_y_origin = pPicture->alphaOrigin.y;
        if (mask & CPClipXOrigin)
            attribs.clip_x_origin = pPicture->clipOrigin.x;
        if (mask & CPClipYOrigin)
            attribs.clip_y_origin = pPicture->clipOrigin.y;
        if (mask & CPClipMask)
            mask &= ~CPClipMask;        /* Handled in ChangePictureClip */
        if (mask & CPGraphicsExposure)
            attribs.graphics_exposures = pPicture->graphicsExposures;
        if (mask & CPSubwindowMode)
            attribs.subwindow_mode = pPicture->subWindowMode;
        if (mask & CPPolyEdge)
            attribs.poly_edge = pPicture->polyEdge;
        if (mask & CPPolyMode)
            attribs.poly_mode = pPicture->polyMode;
        if (mask & CPComponentAlpha)
            attribs.component_alpha = pPicture->componentAlpha;

        XRenderChangePicture(dmxScreen->beDisplay, pPictPriv->pict,
                             mask, &attribs);
        dmxSync(dmxScreen, FALSE);
    }
    else {
        pPictPriv->savedMask |= mask;
    }

#if 1
    if (ps->ValidatePicture)
        ps->ValidatePicture(pPicture, mask);
#endif

    DMX_WRAP(ValidatePicture, dmxValidatePicture, dmxScreen, ps);
}

/** Composite a picture on the appropriate screen by combining the
 *  specified rectangle of the transformed src and mask operands with
 *  the specified rectangle of the dst using op as the compositing
 *  operator.  For a complete description see the protocol document of
 *  the RENDER library. */
void
dmxComposite(CARD8 op,
             PicturePtr pSrc, PicturePtr pMask, PicturePtr pDst,
             INT16 xSrc, INT16 ySrc,
             INT16 xMask, INT16 yMask,
             INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    dmxPictPrivPtr pSrcPriv = DMX_GET_PICT_PRIV(pSrc);
    dmxPictPrivPtr pMaskPriv = NULL;
    dmxPictPrivPtr pDstPriv = DMX_GET_PICT_PRIV(pDst);

    if (pMask)
        pMaskPriv = DMX_GET_PICT_PRIV(pMask);

    DMX_UNWRAP(Composite, dmxScreen, ps);
#if 0
    if (ps->Composite)
        ps->Composite(op, pSrc, pMask, pDst,
                      xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);
#endif

    /* Composite on back-end server */
    if (pSrcPriv->pict && pDstPriv->pict &&
        ((pMaskPriv && pMaskPriv->pict) || !pMaskPriv)) {
        XRenderComposite(dmxScreen->beDisplay,
                         op,
                         pSrcPriv->pict,
                         pMaskPriv ? pMaskPriv->pict : None,
                         pDstPriv->pict,
                         xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);
        dmxSync(dmxScreen, FALSE);
    }

    DMX_WRAP(Composite, dmxComposite, dmxScreen, ps);
}

/** Null function to catch when/if RENDER calls lower level mi hooks.
 *  Compositing glyphs is handled by dmxProcRenderCompositeGlyphs().
 *  This function should never be called. */
void
dmxGlyphs(CARD8 op,
          PicturePtr pSrc, PicturePtr pDst,
          PictFormatPtr maskFormat,
          INT16 xSrc, INT16 ySrc,
          int nlists, GlyphListPtr lists, GlyphPtr * glyphs)
{
    /* This won't work, so we need to wrap ProcRenderCompositeGlyphs */
}

/** Fill a rectangle on the appropriate screen by combining the color
 *  with the dest picture in the area specified by the list of
 *  rectangles.  For a complete description see the protocol document of
 *  the RENDER library. */
void
dmxCompositeRects(CARD8 op,
                  PicturePtr pDst,
                  xRenderColor * color, int nRect, xRectangle *rects)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    dmxPictPrivPtr pPictPriv = DMX_GET_PICT_PRIV(pDst);

    DMX_UNWRAP(CompositeRects, dmxScreen, ps);
#if 0
    if (ps->CompositeRects)
        ps->CompositeRects(op, pDst, color, nRect, rects);
#endif

    /* CompositeRects on back-end server */
    if (pPictPriv->pict) {
        XRenderFillRectangles(dmxScreen->beDisplay,
                              op,
                              pPictPriv->pict,
                              (XRenderColor *) color,
                              (XRectangle *) rects, nRect);
        dmxSync(dmxScreen, FALSE);
    }

    DMX_WRAP(CompositeRects, dmxCompositeRects, dmxScreen, ps);
}

/** Indexed color visuals are not yet supported. */
Bool
dmxInitIndexed(ScreenPtr pScreen, PictFormatPtr pFormat)
{
    return TRUE;
}

/** Indexed color visuals are not yet supported. */
void
dmxCloseIndexed(ScreenPtr pScreen, PictFormatPtr pFormat)
{
}

/** Indexed color visuals are not yet supported. */
void
dmxUpdateIndexed(ScreenPtr pScreen, PictFormatPtr pFormat,
                 int ndef, xColorItem * pdef)
{
}

/** Composite a list of trapezoids on the appropriate screen.  For a
 *  complete description see the protocol document of the RENDER
 *  library. */
void
dmxTrapezoids(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
              PictFormatPtr maskFormat,
              INT16 xSrc, INT16 ySrc, int ntrap, xTrapezoid * traps)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    dmxPictPrivPtr pSrcPriv = DMX_GET_PICT_PRIV(pSrc);
    dmxPictPrivPtr pDstPriv = DMX_GET_PICT_PRIV(pDst);

    DMX_UNWRAP(Trapezoids, dmxScreen, ps);
#if 0
    if (ps->Trapezoids)
        ps->Trapezoids(op, pSrc, pDst, maskFormat, xSrc, ySrc, ntrap, *traps);
#endif

    /* Draw trapezoids on back-end server */
    if (pDstPriv->pict) {
        XRenderPictFormat *pFormat;

        pFormat = dmxFindFormat(dmxScreen, maskFormat);
        if (!pFormat) {
            /* FIXME: Error! */
        }

        XRenderCompositeTrapezoids(dmxScreen->beDisplay,
                                   op,
                                   pSrcPriv->pict,
                                   pDstPriv->pict,
                                   pFormat,
                                   xSrc, ySrc, (XTrapezoid *) traps, ntrap);
        dmxSync(dmxScreen, FALSE);
    }

    DMX_WRAP(Trapezoids, dmxTrapezoids, dmxScreen, ps);
}

/** Composite a list of triangles on the appropriate screen.  For a
 *  complete description see the protocol document of the RENDER
 *  library. */
void
dmxTriangles(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
             PictFormatPtr maskFormat,
             INT16 xSrc, INT16 ySrc, int ntri, xTriangle * tris)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    dmxPictPrivPtr pSrcPriv = DMX_GET_PICT_PRIV(pSrc);
    dmxPictPrivPtr pDstPriv = DMX_GET_PICT_PRIV(pDst);

    DMX_UNWRAP(Triangles, dmxScreen, ps);
#if 0
    if (ps->Triangles)
        ps->Triangles(op, pSrc, pDst, maskFormat, xSrc, ySrc, ntri, *tris);
#endif

    /* Draw trapezoids on back-end server */
    if (pDstPriv->pict) {
        XRenderPictFormat *pFormat;

        pFormat = dmxFindFormat(dmxScreen, maskFormat);
        if (!pFormat) {
            /* FIXME: Error! */
        }

        XRenderCompositeTriangles(dmxScreen->beDisplay,
                                  op,
                                  pSrcPriv->pict,
                                  pDstPriv->pict,
                                  pFormat,
                                  xSrc, ySrc, (XTriangle *) tris, ntri);
        dmxSync(dmxScreen, FALSE);
    }

    DMX_WRAP(Triangles, dmxTriangles, dmxScreen, ps);
}
@


1.10
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d393 1
a393 1
        gidsCopy = malloc(sizeof(*gidsCopy) * nglyphs);
d437 1
a437 1
            gids = malloc(sizeof(*gids) * nglyphs);
d572 1
a572 1
        elts = malloc(nelt * sizeof(XGlyphElt8));
d576 1
a576 1
        glyphs = malloc(nglyph * size);
d928 1
a928 1
            pRects = pRect = malloc(nRects * sizeof(*pRect));
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a59 1
extern int RenderErrBase;
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d288 1
a288 1
        dixLookupResourceByType((pointer *) &glyphSet,
d335 1
a335 1
    dixLookupResourceByType((pointer *) &glyphSet,
d381 1
a381 1
        dixLookupResourceByType((pointer *) &glyphSet,
d426 1
a426 1
    dixLookupResourceByType((pointer *) &glyphSet,
d501 1
a501 1
        dixLookupResourceByType((pointer *) &pSrc,
d508 1
a508 1
        dixLookupResourceByType((pointer *) &pDst,
d527 1
a527 1
            dixLookupResourceByType((pointer *) &pFmt,
d588 1
a588 1
        dixLookupResourceByType((pointer *) &glyphSet,
d598 1
a598 1
                dixLookupResourceByType((pointer *) &glyphSet,
d897 1
a897 1
dmxChangePictureClip(PicturePtr pPicture, int clipType, pointer value, int n)
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a143 4
    /* The shadow framebuffer only relies on FB to be initialized */
    if (dmxShadowFB)
        return fbPictureInit(pScreen, formats, nformats);

@


1.6
log
@Update to xserver 1.11.2
@
text
@a59 1

d61 1
a61 3
extern int (*ProcRenderVector[RenderNumberRequests])(ClientPtr);

static int (*dmxSaveRenderVector[RenderNumberRequests])(ClientPtr);
d63 1
d72 1
d82 2
a83 1
static int dmxGlyphErrorHandler(Display *dpy, XErrorEvent *ev)
a88 1

d95 2
a96 1
void dmxInitRender(void)
d104 1
a104 1
	= dmxProcRenderCreateGlyphSet;
d106 1
a106 1
	= dmxProcRenderFreeGlyphSet;
d108 1
a108 1
	= dmxProcRenderAddGlyphs;
d110 1
a110 1
	= dmxProcRenderFreeGlyphs;
d112 1
a112 1
	= dmxProcRenderCompositeGlyphs;
d114 1
a114 1
	= dmxProcRenderCompositeGlyphs;
d116 1
a116 1
	= dmxProcRenderCompositeGlyphs;
d118 1
a118 1
	= dmxProcRenderSetPictureTransform;
d120 1
a120 1
	= dmxProcRenderSetPictureFilter;
d126 2
a127 1
void dmxResetRender(void)
d138 2
a139 1
Bool dmxPictureInit(ScreenPtr pScreen, PictFormatPtr formats, int nformats)
d141 2
a142 2
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr  ps;
d145 2
a146 1
    if (dmxShadowFB) return fbPictureInit(pScreen, formats, nformats);
d149 1
a149 1
	return FALSE;
d151 3
a153 2
    if (!dixRegisterPrivateKey(&dmxPictPrivateKeyRec, PRIVATE_PICTURE, sizeof(dmxPictPrivRec)))
	return FALSE;
d157 2
a158 2
    DMX_WRAP(CreatePicture,      dmxCreatePicture,      dmxScreen, ps);
    DMX_WRAP(DestroyPicture,     dmxDestroyPicture,     dmxScreen, ps);
d160 1
a160 1
    DMX_WRAP(ChangePictureClip,  dmxChangePictureClip,  dmxScreen, ps);
d163 2
a164 2
    DMX_WRAP(ChangePicture,      dmxChangePicture,      dmxScreen, ps);
    DMX_WRAP(ValidatePicture,    dmxValidatePicture,    dmxScreen, ps);
d166 3
a168 3
    DMX_WRAP(Composite,          dmxComposite,          dmxScreen, ps);
    DMX_WRAP(Glyphs,             dmxGlyphs,             dmxScreen, ps);
    DMX_WRAP(CompositeRects,     dmxCompositeRects,     dmxScreen, ps);
d170 2
a171 2
    DMX_WRAP(Trapezoids,         dmxTrapezoids,         dmxScreen, ps);
    DMX_WRAP(Triangles,          dmxTriangles,          dmxScreen, ps);
a175 1

d180 2
a181 2
static XRenderPictFormat *dmxFindFormat(DMXScreenInfo *dmxScreen,
					PictFormatPtr pFmt)
d184 1
a184 1
    int                i       = 0;
d186 2
a187 1
    if (!pFmt || !dmxScreen->beDisplay) return pFormat;
d190 24
a213 2
	pFormat = XRenderFindFormat(dmxScreen->beDisplay, 0, 0, i++);
	if (!pFormat) break;
d215 2
a216 13
	if (pFormat->type             != pFmt->type)             continue;
	if (pFormat->depth            != pFmt->depth)            continue;
	if (pFormat->direct.red       != pFmt->direct.red)       continue;
	if (pFormat->direct.redMask   != pFmt->direct.redMask)   continue;
	if (pFormat->direct.green     != pFmt->direct.green)     continue;
	if (pFormat->direct.greenMask != pFmt->direct.greenMask) continue;
	if (pFormat->direct.blue      != pFmt->direct.blue)      continue;
	if (pFormat->direct.blueMask  != pFmt->direct.blueMask)  continue;
	if (pFormat->direct.alpha     != pFmt->direct.alpha)     continue;
	if (pFormat->direct.alphaMask != pFmt->direct.alphaMask) continue;

	/* We have a match! */
	break;
d223 2
a224 1
Bool dmxBEFreeGlyphSet(ScreenPtr pScreen, GlyphSetPtr glyphSet)
d226 3
a228 3
    dmxGlyphPrivPtr  glyphPriv = DMX_GET_GLYPH_PRIV(glyphSet);
    int              idx       = pScreen->myNum;
    DMXScreenInfo   *dmxScreen = &dmxScreens[idx];
d231 3
a233 3
	XRenderFreeGlyphSet(dmxScreen->beDisplay, glyphPriv->glyphSets[idx]);
	glyphPriv->glyphSets[idx] = (GlyphSet)0;
	return TRUE;
d240 2
a241 1
int dmxBECreateGlyphSet(int idx, GlyphSetPtr glyphSet)
d244 4
a247 4
    DMXScreenInfo     *dmxScreen = &dmxScreens[idx];
    dmxGlyphPrivPtr    glyphPriv = DMX_GET_GLYPH_PRIV(glyphSet);
    PictFormatPtr      pFmt      = glyphSet->format;
    int              (*oldErrorHandler)(Display *, XErrorEvent *);
d251 1
a251 1
	return BadMatch;
d259 1
a259 1
	= XRenderCreateGlyphSet(dmxScreen->beDisplay, pFormat);
d264 1
a264 1
	return dmxGlyphLastError;
d274 2
a275 1
static int dmxProcRenderCreateGlyphSet(ClientPtr client)
d277 2
a278 1
    int  ret;
d281 1
a281 1
    ret = dmxSaveRenderVector[stuff->renderReqType](client);
d284 15
a298 14
	GlyphSetPtr        glyphSet;
	dmxGlyphPrivPtr    glyphPriv;
	int                i;

	/* Look up glyphSet that was just created ???? */
	/* Store glyphsets from backends in glyphSet->devPrivate ????? */
	/* Make sure we handle all errors here!! */

	dixLookupResourceByType((pointer*) &glyphSet,
				stuff->gsid, GlyphSetType,
				client, DixDestroyAccess);

	glyphPriv = malloc(sizeof(dmxGlyphPrivRec));
	if (!glyphPriv) return BadAlloc;
d301 1
a301 1
	DMX_SET_GLYPH_PRIV(glyphSet, glyphPriv);
d303 22
a324 22
	for (i = 0; i < dmxNumScreens; i++) {
	    DMXScreenInfo *dmxScreen = &dmxScreens[i];
	    int beret;

	    if (!dmxScreen->beDisplay) {
		glyphPriv->glyphSets[i] = 0;
		continue;
	    }

	    if ((beret = dmxBECreateGlyphSet(i, glyphSet)) != Success) {
		int  j;

		/* Free the glyph sets we've allocated thus far */
		for (j = 0; j < i; j++)
		    dmxBEFreeGlyphSet(screenInfo.screens[j], glyphSet);

		/* Free the resource created by render */
		FreeResource(stuff->gsid, RT_NONE);

		return beret;
	    }
	}
d331 2
a332 1
static int dmxProcRenderFreeGlyphSet(ClientPtr client)
d334 2
a335 1
    GlyphSetPtr  glyphSet;
d339 3
a341 3
    dixLookupResourceByType((pointer*) &glyphSet,
			    stuff->glyphset, GlyphSetType,
			    client, DixDestroyAccess);
d344 2
a345 2
	dmxGlyphPrivPtr  glyphPriv = DMX_GET_GLYPH_PRIV(glyphSet);
	int              i;
d347 8
a354 8
	for (i = 0; i < dmxNumScreens; i++) {
	    DMXScreenInfo *dmxScreen = &dmxScreens[i];
	    
	    if (dmxScreen->beDisplay) {
		if (dmxBEFreeGlyphSet(screenInfo.screens[i], glyphSet))
		    dmxSync(dmxScreen, FALSE);
	    }
	}
d357 2
a358 2
	free(glyphPriv);
	DMX_SET_GLYPH_PRIV(glyphSet, NULL);
d361 1
a361 1
    return dmxSaveRenderVector[stuff->renderReqType](client);
d365 2
a366 1
static int dmxProcRenderAddGlyphs(ClientPtr client)
d368 2
a369 1
    int  ret;
d372 1
a372 1
    ret = dmxSaveRenderVector[stuff->renderReqType](client);
d375 22
a396 22
	GlyphSetPtr      glyphSet;
	dmxGlyphPrivPtr  glyphPriv;
	int              i;
	int              nglyphs;
	CARD32          *gids;
	Glyph           *gidsCopy;
	xGlyphInfo      *gi;
	CARD8           *bits;
	int              nbytes;

	dixLookupResourceByType((pointer*) &glyphSet,
				stuff->glyphset, GlyphSetType,
				client, DixReadAccess);
	glyphPriv = DMX_GET_GLYPH_PRIV(glyphSet);

	nglyphs = stuff->nglyphs;
	gids = (CARD32 *)(stuff + 1);
	gi = (xGlyphInfo *)(gids + nglyphs);
	bits = (CARD8 *)(gi + nglyphs);
	nbytes = ((stuff->length << 2) -
		  sizeof(xRenderAddGlyphsReq) -
		  (sizeof(CARD32) + sizeof(xGlyphInfo)) * nglyphs);
d399 2
a400 1
        for (i = 0; i < nglyphs; i++) gidsCopy[i] = gids[i];
d402 13
a414 15
	/* FIXME: Will this ever fail? */
	for (i = 0; i < dmxNumScreens; i++) {
	    DMXScreenInfo *dmxScreen = &dmxScreens[i];

	    if (dmxScreen->beDisplay) {
		XRenderAddGlyphs(dmxScreen->beDisplay,
				 glyphPriv->glyphSets[i],
				 gidsCopy,
				 (XGlyphInfo *)gi,
				 nglyphs,
				 (char *)bits,
				 nbytes);
		dmxSync(dmxScreen, FALSE);
	    }
	}
d422 2
a423 1
static int dmxProcRenderFreeGlyphs(ClientPtr client)
d425 2
a426 1
    GlyphSetPtr  glyphSet;
d430 3
a432 3
    dixLookupResourceByType((pointer*) &glyphSet,
			    stuff->glyphset, GlyphSetType,
			    client, DixWriteAccess);
d435 8
a442 8
	dmxGlyphPrivPtr  glyphPriv = DMX_GET_GLYPH_PRIV(glyphSet);
	int              i;
	int              nglyphs;
	Glyph           *gids;

	nglyphs = ((client->req_len << 2) - sizeof(xRenderFreeGlyphsReq)) >> 2;
	if (nglyphs) {
            gids    = malloc(sizeof(*gids) * nglyphs);
d444 11
a454 11
                gids[i] = ((CARD32 *)(stuff + 1))[i];
            
	    for (i = 0; i < dmxNumScreens; i++) {
		DMXScreenInfo *dmxScreen = &dmxScreens[i];

		if (dmxScreen->beDisplay) {
		    XRenderFreeGlyphs(dmxScreen->beDisplay,
				      glyphPriv->glyphSets[i], gids, nglyphs);
		    dmxSync(dmxScreen, FALSE);
		}
	    }
d456 1
a456 1
	}
d459 1
a459 1
    return dmxSaveRenderVector[stuff->renderReqType](client);
d465 2
a466 1
static int dmxProcRenderCompositeGlyphs(ClientPtr client)
d468 2
a469 1
    int  ret;
d472 1
a472 1
    ret = dmxSaveRenderVector[stuff->renderReqType](client);
d478 171
a648 164
	PicturePtr         pSrc;
	dmxPictPrivPtr     pSrcPriv;
	PicturePtr         pDst;
	dmxPictPrivPtr     pDstPriv;
	PictFormatPtr      pFmt;
	XRenderPictFormat *pFormat;
	int                size;

	int                scrnNum;
	DMXScreenInfo     *dmxScreen;

	CARD8             *buffer;
	CARD8             *end;
	int                space;

	int                nglyph;
	char              *glyphs;
	char              *curGlyph;

	xGlyphElt         *elt;
	int                nelt;
	XGlyphElt8        *elts;
	XGlyphElt8        *curElt;

	GlyphSetPtr        glyphSet;
	dmxGlyphPrivPtr    glyphPriv;

	dixLookupResourceByType((pointer*) &pSrc,
				stuff->src, PictureType,
				client, DixReadAccess);

	pSrcPriv = DMX_GET_PICT_PRIV(pSrc);
	if (!pSrcPriv->pict)
	    return ret;

	dixLookupResourceByType((pointer*) &pDst,
				stuff->dst, PictureType,
				client, DixWriteAccess);

	pDstPriv = DMX_GET_PICT_PRIV(pDst);
	if (!pDstPriv->pict)
	    return ret;

	scrnNum = pDst->pDrawable->pScreen->myNum;
	dmxScreen = &dmxScreens[scrnNum];

	/* Note: If the back-end display has been detached, then it
	 * should not be possible to reach here since the pSrcPriv->pict
	 * and pDstPriv->pict will have already been set to 0.
	 */
	if (!dmxScreen->beDisplay)
	    return ret;

	if (stuff->maskFormat)
	    dixLookupResourceByType((pointer*) &pFmt,
				    stuff->maskFormat, PictFormatType,
				    client, DixReadAccess);
	else
	    pFmt = NULL;

	pFormat = dmxFindFormat(dmxScreen, pFmt);

	switch (stuff->renderReqType) {
	case X_RenderCompositeGlyphs8:  size = sizeof(CARD8);  break;
	case X_RenderCompositeGlyphs16: size = sizeof(CARD16); break;
	case X_RenderCompositeGlyphs32: size = sizeof(CARD32); break;
        default:                        return BadPictOp; /* Can't happen */
	}

	buffer = (CARD8 *)(stuff + 1);
	end = (CARD8 *)stuff + (stuff->length << 2);
	nelt = 0;
	nglyph = 0;
	while (buffer + sizeof(xGlyphElt) < end) {
	    elt = (xGlyphElt *)buffer;
	    buffer += sizeof(xGlyphElt);

	    if (elt->len == 0xff) {
		buffer += 4;
	    } else {
		nelt++;
		nglyph += elt->len;
		space = size * elt->len;
		if (space & 3) space += 4 - (space & 3);
		buffer += space;
	    }
	}

	/* The following only works for Render version > 0.2 */

	/* All of the XGlyphElt* structure sizes are identical */
	elts = malloc(nelt * sizeof(XGlyphElt8));
	if (!elts)
	    return BadAlloc;

	glyphs = malloc(nglyph * size);
	if (!glyphs) {
	    free(elts);
	    return BadAlloc;
	}

	buffer = (CARD8 *)(stuff + 1);
	end = (CARD8 *)stuff + (stuff->length << 2);
	curGlyph = glyphs;
	curElt = elts;

	dixLookupResourceByType((pointer*) &glyphSet,
				stuff->glyphset, GlyphSetType,
				client, DixReadAccess);
	glyphPriv = DMX_GET_GLYPH_PRIV(glyphSet);

	while (buffer + sizeof(xGlyphElt) < end) {
	    elt = (xGlyphElt *)buffer;
	    buffer += sizeof(xGlyphElt);

	    if (elt->len == 0xff) {
		dixLookupResourceByType((pointer*) &glyphSet,
					*((CARD32 *)buffer),
					GlyphSetType,
					client,
					DixReadAccess);
		glyphPriv = DMX_GET_GLYPH_PRIV(glyphSet);
		buffer += 4;
	    } else {
		curElt->glyphset = glyphPriv->glyphSets[scrnNum];
		curElt->xOff = elt->deltax;
		curElt->yOff = elt->deltay;
		curElt->nchars = elt->len;
		curElt->chars = curGlyph;

		memcpy(curGlyph, buffer, size*elt->len);
		curGlyph += size * elt->len;

		curElt++;

		space = size * elt->len;
		if (space & 3) space += 4 - (space & 3);
		buffer += space;
	    }
	}

	switch (stuff->renderReqType) {
	case X_RenderCompositeGlyphs8:
	    XRenderCompositeText8(dmxScreen->beDisplay, stuff->op,
				  pSrcPriv->pict, pDstPriv->pict,
				  pFormat,
				  stuff->xSrc, stuff->ySrc,
				  0, 0, elts, nelt);
	    break;
	case X_RenderCompositeGlyphs16:
	    XRenderCompositeText16(dmxScreen->beDisplay, stuff->op,
				   pSrcPriv->pict, pDstPriv->pict,
				   pFormat,
				   stuff->xSrc, stuff->ySrc,
				   0, 0, (XGlyphElt16 *)elts, nelt);
	    break;
	case X_RenderCompositeGlyphs32:
	    XRenderCompositeText32(dmxScreen->beDisplay, stuff->op,
				   pSrcPriv->pict, pDstPriv->pict,
				   pFormat,
				   stuff->xSrc, stuff->ySrc,
				   0, 0, (XGlyphElt32 *)elts, nelt);
	    break;
	}
d650 1
a650 1
	dmxSync(dmxScreen, FALSE);
d652 2
a653 2
	free(elts);
	free(glyphs);
d660 2
a661 1
static int dmxProcRenderSetPictureTransform(ClientPtr client)
d663 5
a667 4
    DMXScreenInfo  *dmxScreen;
    PicturePtr      pPicture;
    dmxPictPrivPtr  pPictPriv;
    XTransform      xform;
d680 13
a692 14
	xform.matrix[0][0] = stuff->transform.matrix11;
	xform.matrix[0][1] = stuff->transform.matrix12;
	xform.matrix[0][2] = stuff->transform.matrix13;
	xform.matrix[1][0] = stuff->transform.matrix21;
	xform.matrix[1][1] = stuff->transform.matrix22;
	xform.matrix[1][2] = stuff->transform.matrix23;
	xform.matrix[2][0] = stuff->transform.matrix31;
	xform.matrix[2][1] = stuff->transform.matrix32;
	xform.matrix[2][2] = stuff->transform.matrix33;

	XRenderSetPictureTransform(dmxScreen->beDisplay,
				   pPictPriv->pict,
				   &xform);
	dmxSync(dmxScreen, FALSE);
d695 1
a695 1
    return dmxSaveRenderVector[stuff->renderReqType](client);
d699 2
a700 1
static int dmxProcRenderSetPictureFilter(ClientPtr client)
d702 7
a708 6
    DMXScreenInfo  *dmxScreen;
    PicturePtr      pPicture;
    dmxPictPrivPtr  pPictPriv;
    char           *filter;
    XFixed         *params;
    int             nparams;
d721 7
a727 10
	filter  = (char *)(stuff + 1);
	params  = (XFixed *)(filter + ((stuff->nbytes + 3) & ~3));
	nparams = ((XFixed *)stuff + client->req_len) - params;

	XRenderSetPictureFilter(dmxScreen->beDisplay,
				pPictPriv->pict,
				filter,
				params,
				nparams);
	dmxSync(dmxScreen, FALSE);
d730 1
a730 1
    return dmxSaveRenderVector[stuff->renderReqType](client);
a732 1

d737 2
a738 1
static Picture dmxDoCreatePicture(PicturePtr pPicture)
d740 5
a744 5
    DrawablePtr               pDraw     = pPicture->pDrawable;
    ScreenPtr                 pScreen   = pDraw->pScreen;
    DMXScreenInfo            *dmxScreen = &dmxScreens[pScreen->myNum];
    XRenderPictFormat        *pFormat;
    Drawable                  draw;
d747 1
a747 1
	dmxWinPrivPtr  pWinPriv = DMX_GET_WINDOW_PRIV((WindowPtr)(pDraw));
d749 16
a764 15
	if (!(draw = pWinPriv->window)) {
	    /* Window has not been created yet due to the window
	     * optimization.  Delay picture creation until window is
	     * mapped.
	     */
	    pWinPriv->hasPict = TRUE;
	    return 0;
	}
    } else {
	dmxPixPrivPtr  pPixPriv = DMX_GET_PIXMAP_PRIV((PixmapPtr)(pDraw));

	if (!(draw = pPixPriv->pixmap)) {
	    /* FIXME: Zero width/height pixmap?? */
	    return 0;
	}
d772 1
a772 1
	return 0;
d783 2
a784 1
void dmxCreatePictureList(WindowPtr pWindow)
d786 1
a786 1
    PicturePtr  pPicture = GetPictureWindow(pWindow);
d789 1
a789 1
	dmxPictPrivPtr  pPictPriv = DMX_GET_PICT_PRIV(pPicture);
d791 2
a792 2
	/* Create the picture for this window */
	pPictPriv->pict = dmxDoCreatePicture(pPicture);
d794 1
a794 1
	/* ValidatePicture takes care of the state changes */
d796 1
a796 1
	pPicture = pPicture->pNext;
d801 2
a802 1
int dmxBECreatePicture(PicturePtr pPicture)
d804 1
a804 1
    dmxPictPrivPtr    pPictPriv = DMX_GET_PICT_PRIV(pPicture);
d810 1
a810 1
    dmxValidatePicture(pPicture, (1 << (CPLastBit+1)) - 1);
d818 2
a819 1
int dmxCreatePicture(PicturePtr pPicture)
d821 5
a825 5
    ScreenPtr         pScreen   = pPicture->pDrawable->pScreen;
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr  ps        = GetPictureScreen(pScreen);
    dmxPictPrivPtr    pPictPriv = DMX_GET_PICT_PRIV(pPicture);
    int               ret       = Success;
d830 1
a830 1
	ret = ps->CreatePicture(pPicture);
d834 1
a834 1
    pPictPriv->pict      = dmxDoCreatePicture(pPicture);
d843 2
a844 1
Bool dmxBEFreePicture(PicturePtr pPicture)
d846 1
a846 1
    ScreenPtr      pScreen   = pPicture->pDrawable->pScreen;
d851 3
a853 3
	XRenderFreePicture(dmxScreen->beDisplay, pPictPriv->pict);
	pPictPriv->pict = (Picture)0;
	return TRUE;
d862 2
a863 1
Bool dmxDestroyPictureList(WindowPtr pWindow)
d865 2
a866 2
    PicturePtr  pPicture = GetPictureWindow(pWindow);
    Bool        ret      = FALSE;
d869 2
a870 2
	ret |= dmxBEFreePicture(pPicture);
	pPicture = pPicture->pNext;
d879 2
a880 1
void dmxDestroyPicture(PicturePtr pPicture)
d882 3
a884 3
    ScreenPtr         pScreen   = pPicture->pDrawable->pScreen;
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr  ps        = GetPictureScreen(pScreen);
d890 1
a890 1
	dmxSync(dmxScreen, FALSE);
d894 1
a894 1
	ps->DestroyPicture(pPicture);
d900 2
a901 2
int dmxChangePictureClip(PicturePtr pPicture, int clipType,
			 pointer value, int n)
d903 4
a906 4
    ScreenPtr         pScreen   = pPicture->pDrawable->pScreen;
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr  ps        = GetPictureScreen(pScreen);
    dmxPictPrivPtr    pPictPriv = DMX_GET_PICT_PRIV(pPicture);
d911 1
a911 1
	ps->ChangePictureClip(pPicture, clipType, value, n);
d916 41
a956 41
	/* The clip has already been changed into a region by the mi
	 * routine called above.
	 */
	if (clipType == CT_NONE) {
	    /* Disable clipping, show all */
	    XFixesSetPictureClipRegion(dmxScreen->beDisplay,
				       pPictPriv->pict, 0, 0, None);
	} else if (pPicture->clientClip) {
	    RegionPtr   pClip = pPicture->clientClip;
	    BoxPtr      pBox  = RegionRects(pClip);
	    int         nBox  = RegionNumRects(pClip);
	    XRectangle *pRects;
	    XRectangle *pRect;
	    int         nRects;

	    nRects = nBox;
	    pRects = pRect = malloc(nRects * sizeof(*pRect));

	    while (nBox--) {
		pRect->x      = pBox->x1;
		pRect->y      = pBox->y1;
		pRect->width  = pBox->x2 - pBox->x1;
		pRect->height = pBox->y2 - pBox->y1;
		pBox++;
		pRect++;
	    }

	    XRenderSetPictureClipRectangles(dmxScreen->beDisplay,
					    pPictPriv->pict,
					    0, 0,
					    pRects,
					    nRects);
	    free(pRects);
	} else {
	    XRenderSetPictureClipRectangles(dmxScreen->beDisplay,
					    pPictPriv->pict,
					    0, 0, NULL, 0);
	}
	dmxSync(dmxScreen, FALSE);
    } else {
	/* FIXME: Handle saving clip region when offscreen */
d960 1
a960 1
    
d965 2
a966 1
void dmxDestroyPictureClip(PicturePtr pPicture)
d968 4
a971 4
    ScreenPtr         pScreen   = pPicture->pDrawable->pScreen;
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr  ps        = GetPictureScreen(pScreen);
    dmxPictPrivPtr    pPictPriv = DMX_GET_PICT_PRIV(pPicture);
d976 1
a976 1
	ps->DestroyPictureClip(pPicture);
d981 6
a986 6
	XRenderSetPictureClipRectangles(dmxScreen->beDisplay,
					pPictPriv->pict,
					0, 0, NULL, 0);
	dmxSync(dmxScreen, FALSE);
    } else {
	/* FIXME: Handle destroying clip region when offscreen */
d996 2
a997 1
void dmxChangePicture(PicturePtr pPicture, Mask mask)
d999 4
a1002 4
    ScreenPtr         pScreen   = pPicture->pDrawable->pScreen;
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr  ps        = GetPictureScreen(pScreen);
    dmxPictPrivPtr    pPictPriv = DMX_GET_PICT_PRIV(pPicture);
d1007 1
a1007 1
	ps->ChangePicture(pPicture, mask);
d1019 2
a1020 1
void dmxValidatePicture(PicturePtr pPicture, Mask mask)
d1022 4
a1025 4
    ScreenPtr         pScreen   = pPicture->pDrawable->pScreen;
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr  ps        = GetPictureScreen(pScreen);
    dmxPictPrivPtr    pPictPriv = DMX_GET_PICT_PRIV(pPicture);
d1031 1
a1031 1
	XRenderPictureAttributes  attribs;
d1033 47
a1079 43
	if (mask & CPRepeat) {
	    attribs.repeat = pPicture->repeatType;
	}
	if (mask & CPAlphaMap) {
	    if (pPicture->alphaMap) {
		dmxPictPrivPtr  pAlphaPriv;
		pAlphaPriv = DMX_GET_PICT_PRIV(pPicture->alphaMap);
		if (pAlphaPriv->pict) {
		    attribs.alpha_map = pAlphaPriv->pict;
		} else {
		    /* FIXME: alpha picture drawable has not been created?? */
		    return; /* or should this be: attribs.alpha_map = None; */
		}
	    } else {
		attribs.alpha_map = None;
	    }
	}
	if (mask & CPAlphaXOrigin)
	    attribs.alpha_x_origin = pPicture->alphaOrigin.x;
	if (mask & CPAlphaYOrigin)
	    attribs.alpha_y_origin = pPicture->alphaOrigin.y;
	if (mask & CPClipXOrigin)
	    attribs.clip_x_origin = pPicture->clipOrigin.x;
	if (mask & CPClipYOrigin)
	    attribs.clip_y_origin = pPicture->clipOrigin.y;
	if (mask & CPClipMask)
	    mask &= ~CPClipMask; /* Handled in ChangePictureClip */
	if (mask & CPGraphicsExposure)
	    attribs.graphics_exposures = pPicture->graphicsExposures;
	if (mask & CPSubwindowMode)
	    attribs.subwindow_mode = pPicture->subWindowMode;
	if (mask & CPPolyEdge)
	    attribs.poly_edge = pPicture->polyEdge;
	if (mask & CPPolyMode)
	    attribs.poly_mode = pPicture->polyMode;
	if (mask & CPComponentAlpha)
	    attribs.component_alpha = pPicture->componentAlpha;

	XRenderChangePicture(dmxScreen->beDisplay, pPictPriv->pict,
			     mask, &attribs);
	dmxSync(dmxScreen, FALSE);
    } else {
	pPictPriv->savedMask |= mask;
d1084 1
a1084 1
	ps->ValidatePicture(pPicture, mask);
d1095 13
a1107 13
void dmxComposite(CARD8 op,
		  PicturePtr pSrc, PicturePtr pMask, PicturePtr pDst,
		  INT16 xSrc, INT16 ySrc,
		  INT16 xMask, INT16 yMask,
		  INT16 xDst, INT16 yDst,
		  CARD16 width, CARD16 height)
{
    ScreenPtr         pScreen   = pDst->pDrawable->pScreen;
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr  ps        = GetPictureScreen(pScreen);
    dmxPictPrivPtr    pSrcPriv  = DMX_GET_PICT_PRIV(pSrc);
    dmxPictPrivPtr    pMaskPriv = NULL;
    dmxPictPrivPtr    pDstPriv  = DMX_GET_PICT_PRIV(pDst);
d1109 2
a1110 1
    if (pMask) pMaskPriv = DMX_GET_PICT_PRIV(pMask);
d1115 2
a1116 3
	ps->Composite(op, pSrc, pMask, pDst,
		      xSrc, ySrc, xMask, yMask, xDst, yDst,
		      width, height);
d1121 8
a1128 11
	((pMaskPriv && pMaskPriv->pict) || !pMaskPriv)) {
	XRenderComposite(dmxScreen->beDisplay,
			 op,
			 pSrcPriv->pict,
			 pMaskPriv ? pMaskPriv->pict : None,
			 pDstPriv->pict,
			 xSrc, ySrc,
			 xMask, yMask,
			 xDst, yDst,
			 width, height);
	dmxSync(dmxScreen, FALSE);
a1130 1

d1137 6
a1142 5
void dmxGlyphs(CARD8 op,
	       PicturePtr pSrc, PicturePtr pDst,
	       PictFormatPtr maskFormat,
	       INT16 xSrc, INT16 ySrc,
	       int nlists, GlyphListPtr lists, GlyphPtr *glyphs)
d1151 9
a1159 9
void dmxCompositeRects(CARD8 op,
		       PicturePtr pDst,
		       xRenderColor *color,
		       int nRect, xRectangle *rects)
{
    ScreenPtr         pScreen   = pDst->pDrawable->pScreen;
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr  ps        = GetPictureScreen(pScreen);
    dmxPictPrivPtr    pPictPriv = DMX_GET_PICT_PRIV(pDst);
d1164 1
a1164 1
	ps->CompositeRects(op, pDst, color, nRect, rects);
d1169 6
a1174 7
	XRenderFillRectangles(dmxScreen->beDisplay,
			      op,
			      pPictPriv->pict,
			      (XRenderColor *)color,
			      (XRectangle *)rects,
			      nRect);
	dmxSync(dmxScreen, FALSE);
d1181 2
a1182 1
Bool dmxInitIndexed(ScreenPtr pScreen, PictFormatPtr pFormat)
d1188 2
a1189 1
void dmxCloseIndexed(ScreenPtr pScreen, PictFormatPtr pFormat)
d1194 3
a1196 2
void dmxUpdateIndexed(ScreenPtr pScreen, PictFormatPtr pFormat,
		      int ndef, xColorItem *pdef)
d1203 10
a1212 10
void dmxTrapezoids(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
		   PictFormatPtr maskFormat,
		   INT16 xSrc, INT16 ySrc,
		   int ntrap, xTrapezoid *traps)
{
    ScreenPtr         pScreen   = pDst->pDrawable->pScreen;
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr  ps        = GetPictureScreen(pScreen);
    dmxPictPrivPtr    pSrcPriv  = DMX_GET_PICT_PRIV(pSrc);
    dmxPictPrivPtr    pDstPriv  = DMX_GET_PICT_PRIV(pDst);
d1217 1
a1217 1
	ps->Trapezoids(op, pSrc, pDst, maskFormat, xSrc, ySrc, ntrap, *traps);
d1222 1
a1222 1
	XRenderPictFormat *pFormat;
d1224 12
a1235 14
	pFormat = dmxFindFormat(dmxScreen, maskFormat);
	if (!pFormat) {
	    /* FIXME: Error! */
	}

	XRenderCompositeTrapezoids(dmxScreen->beDisplay,
				   op,
				   pSrcPriv->pict,
				   pDstPriv->pict,
				   pFormat,
				   xSrc, ySrc,
				   (XTrapezoid *)traps,
				   ntrap);
	dmxSync(dmxScreen, FALSE);
d1244 10
a1253 10
void dmxTriangles(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
		  PictFormatPtr maskFormat,
		  INT16 xSrc, INT16 ySrc,
		  int ntri, xTriangle *tris)
{
    ScreenPtr         pScreen   = pDst->pDrawable->pScreen;
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr  ps        = GetPictureScreen(pScreen);
    dmxPictPrivPtr    pSrcPriv  = DMX_GET_PICT_PRIV(pSrc);
    dmxPictPrivPtr    pDstPriv  = DMX_GET_PICT_PRIV(pDst);
d1258 1
a1258 1
	ps->Triangles(op, pSrc, pDst, maskFormat, xSrc, ySrc, ntri, *tris);
d1263 1
a1263 1
	XRenderPictFormat *pFormat;
d1265 12
a1276 14
	pFormat = dmxFindFormat(dmxScreen, maskFormat);
	if (!pFormat) {
	    /* FIXME: Error! */
	}

	XRenderCompositeTriangles(dmxScreen->beDisplay,
				  op,
				  pSrcPriv->pict,
				  pDstPriv->pict,
				  pFormat,
				  xSrc, ySrc,
				  (XTriangle *)tris,
				  ntri);
	dmxSync(dmxScreen, FALSE);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a167 2
    DMX_WRAP(TriStrip,           dmxTriStrip,           dmxScreen, ps);
    DMX_WRAP(TriFan,             dmxTriFan,             dmxScreen, ps);
d272 5
a276 3
	
	glyphSet = SecurityLookupIDByType(client, stuff->gsid, GlyphSetType,
					  DixDestroyAccess);
d317 3
a319 2
    glyphSet = SecurityLookupIDByType(client, stuff->glyphset, GlyphSetType,
				      DixDestroyAccess);
d361 3
a363 2
	glyphSet = SecurityLookupIDByType(client, stuff->glyphset,
					  GlyphSetType, DixReadAccess);
d405 3
a407 2
    glyphSet = SecurityLookupIDByType(client, stuff->glyphset, GlyphSetType,
				      DixWriteAccess);
d478 4
a481 2
	pSrc = SecurityLookupIDByType(client, stuff->src, PictureType,
				      DixReadAccess);
d486 4
a489 2
	pDst = SecurityLookupIDByType(client, stuff->dst, PictureType,
				      DixWriteAccess);
d505 3
a507 2
	    pFmt = SecurityLookupIDByType(client, stuff->maskFormat,
					  PictFormatType, DixReadAccess);
d557 3
a559 2
	glyphSet = SecurityLookupIDByType(client, stuff->glyphset,
					  GlyphSetType, DixReadAccess);
d567 5
a571 4
		glyphSet = SecurityLookupIDByType(client,
						  *((CARD32 *)buffer),
						  GlyphSetType,
						  DixReadAccess);
a1023 2
	if (mask & CPDither)
	    attribs.dither = pPicture->dither;
a1236 85
}

/** Composite a triangle strip on the appropriate screen.  For a
 *  complete description see the protocol document of the RENDER
 *  library. */
void dmxTriStrip(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
		 PictFormatPtr maskFormat,
		 INT16 xSrc, INT16 ySrc,
		 int npoint, xPointFixed *points)
{
    ScreenPtr         pScreen   = pDst->pDrawable->pScreen;
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr  ps        = GetPictureScreen(pScreen);
    dmxPictPrivPtr    pSrcPriv  = DMX_GET_PICT_PRIV(pSrc);
    dmxPictPrivPtr    pDstPriv  = DMX_GET_PICT_PRIV(pDst);

    DMX_UNWRAP(TriStrip, dmxScreen, ps);
#if 0
    if (ps->TriStrip)
	ps->TriStrip(op, pSrc, pDst, maskFormat, xSrc, ySrc, npoint, *points);
#endif

    /* Draw trapezoids on back-end server */
    if (pDstPriv->pict) {
	XRenderPictFormat *pFormat;

	pFormat = dmxFindFormat(dmxScreen, maskFormat);
	if (!pFormat) {
	    /* FIXME: Error! */
	}

	XRenderCompositeTriStrip(dmxScreen->beDisplay,
				 op,
				 pSrcPriv->pict,
				 pDstPriv->pict,
				 pFormat,
				 xSrc, ySrc,
				 (XPointFixed *)points,
				 npoint);
	dmxSync(dmxScreen, FALSE);
    }

    DMX_WRAP(TriStrip, dmxTriStrip, dmxScreen, ps);
}

/** Composite a triangle fan on the appropriate screen.  For a complete
 *  description see the protocol document of the RENDER library. */
void dmxTriFan(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
	       PictFormatPtr maskFormat,
	       INT16 xSrc, INT16 ySrc,
	       int npoint, xPointFixed *points)
{
    ScreenPtr         pScreen   = pDst->pDrawable->pScreen;
    DMXScreenInfo    *dmxScreen = &dmxScreens[pScreen->myNum];
    PictureScreenPtr  ps        = GetPictureScreen(pScreen);
    dmxPictPrivPtr    pSrcPriv  = DMX_GET_PICT_PRIV(pSrc);
    dmxPictPrivPtr    pDstPriv  = DMX_GET_PICT_PRIV(pDst);

    DMX_UNWRAP(TriFan, dmxScreen, ps);
#if 0
    if (ps->TriFan)
	ps->TriFan(op, pSrc, pDst, maskFormat, xSrc, ySrc, npoint, *points);
#endif

    /* Draw trapezoids on back-end server */
    if (pDstPriv->pict) {
	XRenderPictFormat *pFormat;

	pFormat = dmxFindFormat(dmxScreen, maskFormat);
	if (!pFormat) {
	    /* FIXME: Error! */
	}

	XRenderCompositeTriFan(dmxScreen->beDisplay,
			       op,
			       pSrcPriv->pict,
			       pDstPriv->pict,
			       pFormat,
			       xSrc, ySrc,
			       (XPointFixed *)points,
			       npoint);
	dmxSync(dmxScreen, FALSE);
    }

    DMX_WRAP(TriFan, dmxTriFan, dmxScreen, ps);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d148 1
a148 1
    if (!dixRequestPrivate(dmxPictPrivateKey, sizeof(dmxPictPrivRec)))
d277 1
a277 1
	glyphPriv = xalloc(sizeof(dmxGlyphPrivRec));
d334 1
a334 1
	xfree(glyphPriv);
d372 1
a372 1
        gidsCopy = xalloc(sizeof(*gidsCopy) * nglyphs);
d390 1
a390 1
        xfree(gidsCopy);
d414 1
a414 1
            gids    = xalloc(sizeof(*gids) * nglyphs);
d427 1
a427 1
            xfree(gids);
d534 1
a534 1
	elts = xalloc(nelt * sizeof(XGlyphElt8));
d538 1
a538 1
	glyphs = xalloc(nglyph * size);
d540 1
a540 1
	    xfree(elts);
d608 2
a609 2
	xfree(elts);
	xfree(glyphs);
d625 1
a625 2
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixWriteAccess,
		   RenderErrBase + BadPicture);
d665 1
a665 2
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixWriteAccess,
		   RenderErrBase + BadPicture);
d874 2
a875 2
	    BoxPtr      pBox  = REGION_RECTS(pClip);
	    int         nBox  = REGION_NUM_RECTS(pClip);
d881 1
a881 1
	    pRects = pRect = xalloc(nRects * sizeof(*pRect));
d897 1
a897 1
	    xfree(pRects);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d54 1
a58 6

#undef Xmalloc
#undef Xcalloc
#undef Xrealloc
#undef Xfree

@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d59 6
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
d147 1
a147 2
    if (!AllocatePicturePrivate(pScreen, dmxPictPrivateIndex,
				sizeof(dmxPictPrivRec)))
d224 30
a265 1
	int              (*oldErrorHandler)(Display *, XErrorEvent *);
a268 2
	PictFormatPtr      pFmt;
	XRenderPictFormat *pFormat;
d275 1
a275 1
					  SecurityDestroyAccess);
a281 5
	pFmt = SecurityLookupIDByType(client, stuff->format, PictFormatType,
				      SecurityReadAccess);

	oldErrorHandler = XSetErrorHandler(dmxGlyphErrorHandler);

d284 1
d291 1
a291 2
	    pFormat = dmxFindFormat(dmxScreen, pFmt);
	    if (!pFormat) {
d301 1
a301 20
		ret = BadMatch;
		break;
	    }

	    /* Catch when this fails */
	    glyphPriv->glyphSets[i]
		= XRenderCreateGlyphSet(dmxScreen->beDisplay, pFormat);

	    if (dmxGlyphLastError) {
		int  j;

		/* Free the glyph sets we've allocated thus far */
		for (j = 0; j < i; j++)
		    dmxBEFreeGlyphSet(screenInfo.screens[j], glyphSet);

		/* Free the resource created by render */
		FreeResource(stuff->gsid, RT_NONE);

		ret = dmxGlyphLastError;
		break;
a303 2

	XSetErrorHandler(oldErrorHandler);
d317 1
a317 1
				      SecurityDestroyAccess);
d360 1
a360 1
					  GlyphSetType, SecurityReadAccess);
d403 1
a403 1
				      SecurityWriteAccess);
d475 1
a475 1
				      SecurityReadAccess);
d481 1
a481 1
				      SecurityWriteAccess);
d498 1
a498 1
					  PictFormatType, SecurityReadAccess);
d533 1
a533 1
	elts = ALLOCATE_LOCAL(nelt * sizeof(XGlyphElt8));
d537 1
a537 1
	glyphs = ALLOCATE_LOCAL(nglyph * size);
d539 1
a539 1
	    DEALLOCATE_LOCAL(elts);
d549 1
a549 1
					  GlyphSetType, SecurityReadAccess);
d560 1
a560 1
						  SecurityReadAccess);
d607 2
a608 2
	DEALLOCATE_LOCAL(elts);
	DEALLOCATE_LOCAL(glyphs);
d624 1
a624 1
    VERIFY_PICTURE(pPicture, stuff->picture, client, SecurityWriteAccess,
d665 1
a665 1
    VERIFY_PICTURE(pPicture, stuff->picture, client, SecurityWriteAccess,
d755 14
d869 5
a873 1
	if (pPicture->clientClip) {
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@Import xserver version 1.2.0 (X.Org 7.2 final).
@
text
@a225 30
/** Create \a glyphSet on the backend screen number \a idx. */
int dmxBECreateGlyphSet(int idx, GlyphSetPtr glyphSet)
{
    XRenderPictFormat *pFormat;
    DMXScreenInfo     *dmxScreen = &dmxScreens[idx];
    dmxGlyphPrivPtr    glyphPriv = DMX_GET_GLYPH_PRIV(glyphSet);
    PictFormatPtr      pFmt      = glyphSet->format;
    int              (*oldErrorHandler)(Display *, XErrorEvent *);

    pFormat = dmxFindFormat(dmxScreen, pFmt);
    if (!pFormat) {
	return BadMatch;
    }

    dmxGlyphLastError = 0;
    oldErrorHandler = XSetErrorHandler(dmxGlyphErrorHandler);

    /* Catch when this fails */
    glyphPriv->glyphSets[idx]
	= XRenderCreateGlyphSet(dmxScreen->beDisplay, pFormat);

    XSetErrorHandler(oldErrorHandler);

    if (dmxGlyphLastError) {
	return dmxGlyphLastError;
    }

    return Success;
}

d238 1
d242 2
d257 5
a263 1
	    int beret;
d270 20
a289 1
	    if ((beret = dmxBECreateGlyphSet(i, glyphSet)) != Success) {
d299 2
a300 1
		return beret;
d303 2
a755 14
/** Create \a pPicture on the backend. */
int dmxBECreatePicture(PicturePtr pPicture)
{
    dmxPictPrivPtr    pPictPriv = DMX_GET_PICT_PRIV(pPicture);

    /* Create picutre on BE */
    pPictPriv->pict = dmxDoCreatePicture(pPicture);

    /* Flush changes to the backend server */
    dmxValidatePicture(pPicture, (1 << (CPLastBit+1)) - 1);

    return Success;
}

d856 1
a856 5
	if (clipType == CT_NONE) {
	    /* Disable clipping, show all */
	    XFixesSetPictureClipRegion(dmxScreen->beDisplay,
				       pPictPriv->pict, 0, 0, None);
	} else if (pPicture->clientClip) {
@


1.1.1.3
log
@xserver 1.4
@
text
@d1 1
d277 1
a277 1
					  DixDestroyAccess);
d319 1
a319 1
				      DixDestroyAccess);
d362 1
a362 1
					  GlyphSetType, DixReadAccess);
d405 1
a405 1
				      DixWriteAccess);
d477 1
a477 1
				      DixReadAccess);
d483 1
a483 1
				      DixWriteAccess);
d500 1
a500 1
					  PictFormatType, DixReadAccess);
d551 1
a551 1
					  GlyphSetType, DixReadAccess);
d562 1
a562 1
						  DixReadAccess);
d626 1
a626 1
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixWriteAccess,
d667 1
a667 1
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixWriteAccess,
@


