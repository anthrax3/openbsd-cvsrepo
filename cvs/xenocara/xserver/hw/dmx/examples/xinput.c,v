head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.14
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.12
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.10
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.8
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.8
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.17;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.50;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.50;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.44;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@/*
 * Copyright 2001,2002 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Rickard E. (Rik) Faith <faith@@redhat.com>
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <X11/Xlib.h>
#include <X11/XKBlib.h>
#include <X11/extensions/XInput.h>
#include <X11/extensions/XKB.h>
#include <X11/extensions/XKBstr.h>
#include <X11/extensions/dmxext.h>
#include <sys/time.h>

static const char *
core(DMXInputAttributes * iinf)
{
    if (iinf->isCore)
        return "core";
    else if (iinf->sendsCore)
        return "extension (sends core events)";
    else
        return "extension";
}

static void
printdmxinfo(Display * display, int id)
{
    int event_base;
    int error_base;
    int major_version, minor_version, patch_version;
    DMXInputAttributes iinf;
    Display *backend;
    char *backendname = NULL;

    if (!DMXQueryExtension(display, &event_base, &error_base))
        return;
    if (!DMXQueryVersion(display, &major_version, &minor_version,
                         &patch_version))
        return;
    if (major_version == 1 && minor_version == 0)
        return;                 /* too old */
    if (!DMXGetInputAttributes(display, id, &iinf))
        return;

    printf("   DMX Information: ");
    if (iinf.detached)
        printf("detached ");
    else
        printf("active   ");
    switch (iinf.inputType) {
    case DMXLocalInputType:
        printf("local, %s", core(&iinf));
        break;
    case DMXConsoleInputType:
        printf("console %s, %s", iinf.name, core(&iinf));
        break;
    case DMXBackendInputType:
        if (iinf.physicalId >= 0) {
            if ((backend = XOpenDisplay(iinf.name))) {
                XExtensionVersion *ext = XGetExtensionVersion(backend, INAME);

                if (ext && ext != (XExtensionVersion *) NoSuchExtension) {
                    int count, i;
                    XDeviceInfo *devInfo = XListInputDevices(backend, &count);

                    if (devInfo) {
                        for (i = 0; i < count; i++) {
                            if ((unsigned) iinf.physicalId == devInfo[i].id
                                && devInfo[i].name) {
                                backendname = strdup(devInfo[i].name);
                                break;
                            }
                        }
                        XFreeDeviceList(devInfo);
                    }
                }
                XCloseDisplay(backend);
            }
        }
        printf("backend o%d/%s", iinf.physicalScreen, iinf.name);
        if (iinf.physicalId >= 0)
            printf("/id%d", iinf.physicalId);
        if (backendname) {
            printf("=%s", backendname);
            free(backendname);
        }
        printf(" %s", core(&iinf));
        break;
    }
    printf("\n");
}

int
main(int argc, char **argv)
{
    Display *display = NULL;
    int device = -1;
    int newmouse = -1;
    int newkbd = -1;
    int count;
    int i, j;
    XDeviceInfo *devInfo;
    XExtensionVersion *ext;

    if (argc == 2 || argc == 3 || argc == 4 || argc == 5) {
        if (!(display = XOpenDisplay(argv[1]))) {
            printf("Cannot open display %s\n", argv[1]);
            return -1;
        }
        if (argc >= 3)
            device = strtol(argv[2], NULL, 0);
        if (argc >= 4)
            newmouse = strtol(argv[3], NULL, 0);
        if (argc >= 5)
            newkbd = strtol(argv[4], NULL, 0);
    }
    else {
        printf("Usage: %s display [device] [newmouse] [newkbd]\n", argv[0]);
        return -1;
    }

    if (!display && !(display = XOpenDisplay(NULL))) {
        printf("Cannot open default display\n");
        return -1;
    }

    ext = XGetExtensionVersion(display, INAME);
    if (!ext || ext == (XExtensionVersion *) NoSuchExtension) {
        printf("No XInputExtension\n");
        return -1;
    }
    printf("%s version %d.%d\n", INAME, ext->major_version, ext->minor_version);

    if (!(devInfo = XListInputDevices(display, &count)) || !count) {
        printf("Cannot list devices\n");
        return -1;
    }

    for (i = 0; i < count; i++) {
        XAnyClassPtr any;
        const char *kind = "Unknown";
        int has_key = 0;

        switch (devInfo[i].use) {
        case IsXPointer:
            kind = "XPointer";
            break;
        case IsXKeyboard:
            kind = "XKeyboard";
            break;
        case IsXExtensionDevice:
            kind = "XExtensionDevice";
            break;
        }
        printf("%2lu %-20.20s %-16.16s",
               (long unsigned) devInfo[i].id,
               devInfo[i].name ? devInfo[i].name : "", kind);

        for (j = 0, any = devInfo[i].inputclassinfo;
             j < devInfo[i].num_classes;
             any = (XAnyClassPtr) ((char *) any + any->length), j++) {
            const char *class = "unk";

            switch (any->class) {
            case KeyClass:
                class = "key";
                ++has_key;
                break;
            case ButtonClass:
                class = "btn";
                break;
            case ValuatorClass:
                class = "val";
                break;
            case FeedbackClass:
                class = "fdb";
                break;
            case ProximityClass:
                class = "prx";
                break;
            case FocusClass:
                class = "foc";
                break;
            case OtherClass:
                class = "oth";
                break;
            }
            printf(" %s", class);
        }
        printf("\n");
        printdmxinfo(display, i);

        if (has_key) {
            XkbDescPtr xkb;

            if ((xkb = XkbGetKeyboard(display,
                                      XkbAllComponentsMask, devInfo[i].id))) {
                printf("   Xkb Information:\n");
                printf("      Device id = %d\n", xkb->device_spec);
                printf("      Min keycode = 0x%02x\n", xkb->min_key_code);
                printf("      Max keycode = 0x%02x\n", xkb->max_key_code);
#define PRINTNAME(x)                                                     \
    printf("      %s = %s\n",                                            \
           #x, xkb->names->x ? XGetAtomName(display, xkb->names->x) : "")
                PRINTNAME(keycodes);
                PRINTNAME(geometry);
                PRINTNAME(symbols);
                PRINTNAME(types);
                PRINTNAME(compat);
            }
        }
    }

    if (newmouse >= 0) {
        XDevice *dev;

        printf("Trying to make device %d core mouse\n", newmouse);
        dev = XOpenDevice(display, devInfo[newmouse].id);
        printf("Status = %d\n", XChangePointerDevice(display, dev, 0, 1));
        return 0;
    }

    if (newkbd >= 0) {
        XDevice *dev;

        printf("Trying to make device %d core keyboard\n", newkbd);
        dev = XOpenDevice(display, devInfo[newkbd].id);
        printf("Status = %d\n", XChangeKeyboardDevice(display, dev));
        return 0;
    }

    if (device >= 0) {
#define MAX_EVENTS 100
        int cnt = 0;
        XDevice *dev;
        XEventClass event_list[MAX_EVENTS];
        int event_type[MAX_EVENTS];
        const char *names[MAX_EVENTS];
        int total = 0;

#define ADD(type)                                     \
        if (cnt >= MAX_EVENTS) abort();             \
        names[cnt] = #type;                           \
        type(dev, event_type[cnt], event_list[cnt]);  \
        if (event_type[cnt]) ++cnt

        dev = XOpenDevice(display, devInfo[device].id);
        ADD(DeviceKeyPress);
        ADD(DeviceKeyRelease);
        ADD(DeviceButtonPress);
        ADD(DeviceButtonRelease);
        ADD(DeviceMotionNotify);
        ADD(DeviceFocusIn);
        ADD(DeviceFocusOut);
        ADD(ProximityIn);
        ADD(ProximityOut);
        ADD(DeviceStateNotify);
        ADD(DeviceMappingNotify);
        ADD(ChangeDeviceNotify);

        for (i = 0; i < cnt; i++) {
            printf("Waiting for %s events of type %d (%lu) on 0x%08lx\n",
                   names[i],
                   event_type[i], (unsigned long) event_list[i],
                   (long unsigned) DefaultRootWindow(display));
        }
        XSelectExtensionEvent(display, DefaultRootWindow(display),
                              event_list, cnt);

        for (;;) {
            XEvent event;

            XNextEvent(display, &event);
            for (i = 0; i < cnt; i++) {
                XDeviceMotionEvent *e = (XDeviceMotionEvent *) &event;
                XDeviceButtonEvent *b = (XDeviceButtonEvent *) &event;

                if (event.type == event_type[i]) {
                    printf("%s id=%lu (%d @@ %d,%d; s=0x%04x, d=%d, t=%lu)"
                           " axes_count=%d first=%d %d %d %d %d %d %d\n",
                           names[i],
                           (long unsigned) e->deviceid,
                           e->type,
                           e->x, e->y,
                           e->device_state,
                           b->button,
                           (long unsigned) b->time,
                           e->axes_count,
                           e->first_axis,
                           e->axis_data[0],
                           e->axis_data[1],
                           e->axis_data[2],
                           e->axis_data[3], e->axis_data[4], e->axis_data[5]);
                }
            }
            ++total;
#if 0
            /* Used to check motion history for
             * extension devices. */
            if (!(total % 10)) {
                XDeviceTimeCoord *tc;
                int n, m, a;
                struct timeval tv;
                unsigned long ms;

                gettimeofday(&tv, NULL);
                ms = tv.tv_sec * 1000 + tv.tv_usec / 1000;
                tc = XGetDeviceMotionEvents(display, dev, ms - 1000, ms,
                                            &n, &m, &a);
                printf("Got %d events of mode %s with %d axes\n",
                       n, m == Absolute ? "Absolute" : "Relative", a);
                for (i = 0; i < n && i < 10; i++) {
                    printf("  %d: %lu %d %d\n",
                           i, tc[i].time, tc[i].data[0], tc[i].data[1]);
                }
                XFreeDeviceMotionEvents(tc);
            }
#endif
        }
    }

    XCloseDisplay(display);
    return 0;
}
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d306 2
a307 2
                XDeviceMotionEvent *e = (XDeviceMotionEvent *) & event;
                XDeviceButtonEvent *b = (XDeviceButtonEvent *) & event;
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d45 2
a46 1
static const char *core(DMXInputAttributes *iinf)
d48 6
a53 3
    if (iinf->isCore)         return "core";
    else if (iinf->sendsCore) return "extension (sends core events)";
    else                      return "extension";
d56 2
a57 1
static void printdmxinfo(Display *display, int id)
d59 6
a64 6
    int                  event_base;
    int                  error_base;
    int                  major_version, minor_version, patch_version;
    DMXInputAttributes   iinf;
    Display              *backend;
    char                 *backendname = NULL;
d66 2
a67 1
    if (!DMXQueryExtension(display, &event_base, &error_base)) return;
d69 6
a74 3
                         &patch_version)) return;
    if (major_version == 1 && minor_version == 0) return; /* too old */
    if (!DMXGetInputAttributes(display, id, &iinf)) return;
d77 4
a80 2
    if (iinf.detached) printf("detached ");
    else               printf("active   ");
d92 2
a93 1
                if (ext && ext != (XExtensionVersion *)NoSuchExtension) {
d96 1
d99 1
a99 1
                            if ((unsigned)iinf.physicalId == devInfo[i].id
d111 3
a113 2
        printf("backend o%d/%s",iinf.physicalScreen,  iinf.name);
        if (iinf.physicalId >= 0) printf("/id%d", iinf.physicalId);
d124 2
a125 1
int main(int argc, char **argv)
d127 8
a134 8
    Display              *display = NULL;
    int                  device   = -1;
    int                  newmouse = -1;
    int                  newkbd   = -1;
    int                  count;
    int                  i, j;
    XDeviceInfo          *devInfo;
    XExtensionVersion    *ext;
d141 8
a148 4
        if (argc >= 3) device   = strtol(argv[2], NULL, 0);
        if (argc >= 4) newmouse = strtol(argv[3], NULL, 0);
        if (argc >= 5) newkbd   = strtol(argv[4], NULL, 0);
    } else {
d159 1
a159 1
    if (!ext || ext == (XExtensionVersion *)NoSuchExtension) {
d163 1
a163 2
    printf("%s version %d.%d\n",
           INAME, ext->major_version, ext->minor_version);
d172 3
a174 3
        const char   *kind   = "Unknown";
        int          has_key = 0;
        
d176 9
a184 3
        case IsXPointer:         kind = "XPointer";         break;
        case IsXKeyboard:        kind = "XKeyboard";        break;
        case IsXExtensionDevice: kind = "XExtensionDevice"; break;
d187 1
a187 1
               (long unsigned)devInfo[i].id,
d192 3
a194 2
             any = (XAnyClassPtr)((char *)any + any->length), j++) {
            const char   *class = "unk";
d196 22
a217 7
            case KeyClass:       class = "key"; ++has_key; break;
            case ButtonClass:    class = "btn"; break;
            case ValuatorClass:  class = "val"; break;
            case FeedbackClass:  class = "fdb"; break;
            case ProximityClass: class = "prx"; break;
            case FocusClass:     class = "foc"; break;
            case OtherClass:     class = "oth"; break;
d225 2
a226 1
            XkbDescPtr           xkb;
d228 1
a228 2
                                      XkbAllComponentsMask,
                                      devInfo[i].id))) {
d246 1
a246 1
        XDevice     *dev;
d250 1
a250 2
        printf("Status = %d\n",
               XChangePointerDevice(display, dev, 0, 1));
d255 1
a255 1
        XDevice     *dev;
d259 1
a259 2
        printf("Status = %d\n",
               XChangeKeyboardDevice(display, dev));
a261 1
            
d263 1
a263 1
    if (device >=0){
d265 2
a266 2
        int         cnt = 0;
        XDevice     *dev;
d268 3
a270 3
        int         event_type[MAX_EVENTS];
        const char  *names[MAX_EVENTS];
        int         total = 0;
a276 1
        
d291 1
a291 1
        
d295 2
a296 2
                   event_type[i], (unsigned long)event_list[i],
                   (long unsigned)DefaultRootWindow(display));
d300 1
a300 1
        
d303 1
d306 3
a308 2
                XDeviceMotionEvent *e = (XDeviceMotionEvent *)&event;
                XDeviceButtonEvent *b = (XDeviceButtonEvent *)&event;
d313 1
a313 1
                           (long unsigned)e->deviceid,
d318 1
a318 1
                           (long unsigned)b->time,
d324 1
a324 3
                           e->axis_data[3],
                           e->axis_data[4],
                           e->axis_data[5]);
d329 2
a330 2
                                /* Used to check motion history for
                                 * extension devices. */
d333 4
a336 3
                int              n, m, a;
                struct timeval   tv;
                unsigned long    ms;
d339 1
a339 1
                tc = XGetDeviceMotionEvents(display, dev, ms-1000, ms,
d349 1
a349 1
#endif                
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d236 1
a236 1
        if (cnt >= MAX_EVENTS) abort();               \
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d41 1
a41 1
#include "xkbstr.h"
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
d41 1
a41 1
#include <X11/extensions/XKBstr.h>
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
@

