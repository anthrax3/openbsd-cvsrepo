head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.22
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.20
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.18
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.16
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.14
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.12
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.10
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.8
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.18
	OPENBSD_5_0:1.1.1.2.0.16
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.12
	OPENBSD_4_9_BASE:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.14
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.50;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.50;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.43;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@/*
 * Copyright (c) 2003 by the XFree86 Project, Inc.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Create a window and use the DMX extension to query the window's
 * back-end properties.  Display the info inside the window itself.
 *
 * Brian Paul
 * 23 Jan 2003
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/extensions/dmxext.h>

static const char *FontName = "fixed";

static void
EventLoop(Display * dpy, Window win, GC gc)
{
    XEvent ev;

    while (1) {
        XNextEvent(dpy, &ev);
        switch (ev.type) {
        case ReparentNotify:
            break;
        case MapNotify:
            break;
        case ConfigureNotify:
        case Expose:
        {
            int numScreens, count, i;
            DMXWindowAttributes *winInfo;
            int x, y;
            const char *msg = "DMX window info:";

            DMXGetScreenCount(dpy, &numScreens);
            winInfo = (DMXWindowAttributes *)
                malloc(numScreens * sizeof(DMXWindowAttributes));
            assert(winInfo);
            if (!DMXGetWindowAttributes(dpy, win, &count, numScreens, winInfo)) {
                printf("Could not get window information for 0x%08lx\n",
                       (long unsigned) win);
            }
            x = y = 50;
            XClearWindow(dpy, win);
            XDrawString(dpy, win, gc, x, y, msg, strlen(msg));
            y += 20;
            for (i = 0; i < count; i++) {
                char str[500];

                snprintf(str, sizeof(str),
                         "screen %d:  pos: %dx%d+%d+%d  visible: %dx%d+%d+%d",
                         winInfo[i].screen,
                         winInfo[i].pos.width, winInfo[i].pos.height,
                         winInfo[i].pos.x, winInfo[i].pos.y,
                         winInfo[i].vis.width, winInfo[i].vis.height,
                         winInfo[i].vis.x, winInfo[i].vis.y);
                XDrawString(dpy, win, gc, x, y, str, strlen(str));
                y += 20;
            }
            free(winInfo);
        }
            break;
        default:
            printf("Event type 0x%x\n", ev.type);
        }
    }
}

int
main(int argc, char *argv[])
{
    const char *displayName = NULL;
    Display *dpy;
    int event_base, error_base;
    int scr, n;
    long vinfoMask, attrMask;
    XVisualInfo vinfoTemp, *visInfo;
    Visual *vis;
    Window win, root;
    XSetWindowAttributes attr;
    XFontStruct *fontInfo;
    GC gc;

    if (argc > 1) {
        displayName = argv[1];
    }

    dpy = XOpenDisplay(displayName);
    if (!dpy) {
        fprintf(stderr, "Unable to open display %s\n", displayName);
        return -1;
    }

    if (!DMXQueryExtension(dpy, &event_base, &error_base)) {
        fprintf(stderr, "DMX extension not available on this display.\n");
        return -1;
    }

    scr = DefaultScreen(dpy);
    root = RootWindow(dpy, scr);
    vis = DefaultVisual(dpy, scr);

    vinfoMask = VisualIDMask;
    vinfoTemp.visualid = vis->visualid;
    visInfo = XGetVisualInfo(dpy, vinfoMask, &vinfoTemp, &n);
    if (!visInfo || n != 1) {
        fprintf(stderr, "Unable to get visual!\n");
        XCloseDisplay(dpy);
        return -1;
    }

    attr.background_pixel = 0;
    attr.border_pixel = 0;
    attr.colormap = XCreateColormap(dpy, root, visInfo->visual, AllocNone);
    attr.event_mask = StructureNotifyMask | ExposureMask;
    attrMask = CWBackPixel | CWBorderPixel | CWColormap | CWEventMask;

    win = XCreateWindow(dpy, root, 500, 500, 600, 400,  /* x, y, w, h */
                        0,      /* border_width */
                        visInfo->depth, InputOutput,
                        visInfo->visual, attrMask, &attr);

    if (!win) {
        fprintf(stderr, "Unable to create window!\n");
        XCloseDisplay(dpy);
        return -1;
    }

    fontInfo = XLoadQueryFont(dpy, FontName);
    if (!fontInfo) {
        fprintf(stderr, "Error: font %s not found\n", FontName);
        exit(0);
    }

    gc = XCreateGC(dpy, win, 0, NULL);
    XSetBackground(dpy, gc, BlackPixel(dpy, scr));
    XSetForeground(dpy, gc, WhitePixel(dpy, scr));
    XSetFont(dpy, gc, fontInfo->fid);

    XMapWindow(dpy, win);

    EventLoop(dpy, win, gc);

    XDestroyWindow(dpy, win);
    XCloseDisplay(dpy);
    return 0;
}

#if 00

static void
make_window(char *title, int color_flag)
{
    int x = 10, y = 10, width = 400, height = 300;
    Display *dpy;
    int scr;
    Window root, win;
    Colormap cmap;
    XColor xcolor;
    int attr_flags;
    XVisualInfo *visinfo;
    XSetWindowAttributes attr;
    XTextProperty tp;
    XSizeHints sh;
    XEvent e;
    XMesaContext context;
    XMesaVisual visual;
    XMesaBuffer buffer;

    /*
     * Do the usual X things to make a window.
     */

    dpy = XOpenDisplay(NULL);
    if (!dpy) {
        printf("Couldn't open default display!\n");
        exit(1);
    }

    scr = DefaultScreen(dpy);
    root = RootWindow(dpy, scr);

    /* alloc visinfo struct */
    visinfo = (XVisualInfo *) malloc(sizeof(XVisualInfo));

    /* Get a visual and colormap */
    if (color_flag) {
        /* Open TrueColor window */

/*
      if (!XMatchVisualInfo( dpy, scr, 24, TrueColor, visinfo )) {
	 printf("Couldn't get 24-bit TrueColor visual!\n");
	 exit(1);
      }
*/
        if (!XMatchVisualInfo(dpy, scr, 8, PseudoColor, visinfo)) {
            printf("Couldn't get 8-bit PseudoColor visual!\n");
            exit(1);
        }

        cmap = XCreateColormap(dpy, root, visinfo->visual, AllocNone);
        Black = Red = Green = Blue = 0;
    }
    else {
        /* Open color index window */

        if (!XMatchVisualInfo(dpy, scr, 8, PseudoColor, visinfo)) {
            printf("Couldn't get 8-bit PseudoColor visual\n");
            exit(1);
        }

        cmap = XCreateColormap(dpy, root, visinfo->visual, AllocNone);

        /* Allocate colors */
        xcolor.red = 0x0;
        xcolor.green = 0x0;
        xcolor.blue = 0x0;
        xcolor.flags = DoRed | DoGreen | DoBlue;
        if (!XAllocColor(dpy, cmap, &xcolor)) {
            printf("Couldn't allocate black!\n");
            exit(1);
        }
        Black = xcolor.pixel;

        xcolor.red = 0xffff;
        xcolor.green = 0x0;
        xcolor.blue = 0x0;
        xcolor.flags = DoRed | DoGreen | DoBlue;
        if (!XAllocColor(dpy, cmap, &xcolor)) {
            printf("Couldn't allocate red!\n");
            exit(1);
        }
        Red = xcolor.pixel;

        xcolor.red = 0x0;
        xcolor.green = 0xffff;
        xcolor.blue = 0x0;
        xcolor.flags = DoRed | DoGreen | DoBlue;
        if (!XAllocColor(dpy, cmap, &xcolor)) {
            printf("Couldn't allocate green!\n");
            exit(1);
        }
        Green = xcolor.pixel;

        xcolor.red = 0x0;
        xcolor.green = 0x0;
        xcolor.blue = 0xffff;
        xcolor.flags = DoRed | DoGreen | DoBlue;
        if (!XAllocColor(dpy, cmap, &xcolor)) {
            printf("Couldn't allocate blue!\n");
            exit(1);
        }
        Blue = xcolor.pixel;
    }

    /* set window attributes */
    attr.colormap = cmap;
    attr.event_mask = ExposureMask | StructureNotifyMask;
    attr.border_pixel = BlackPixel(dpy, scr);
    attr.background_pixel = BlackPixel(dpy, scr);
    attr_flags = CWColormap | CWEventMask | CWBorderPixel | CWBackPixel;

    /* Create the window */
    win = XCreateWindow(dpy, root, x, y, width, height, 0,
                        visinfo->depth, InputOutput,
                        visinfo->visual, attr_flags, &attr);
    if (!win) {
        printf("Couldn't open window!\n");
        exit(1);
    }

    XStringListToTextProperty(&title, 1, &tp);
    sh.flags = USPosition | USSize;
    XSetWMProperties(dpy, win, &tp, &tp, 0, 0, &sh, 0, 0);
    XMapWindow(dpy, win);
    while (1) {
        XNextEvent(dpy, &e);
        if (e.type == MapNotify && e.xmap.window == win) {
            break;
        }
    }

    /*
     * Now do the special Mesa/Xlib stuff!
     */

    visual = XMesaCreateVisual(dpy, visinfo, (GLboolean) color_flag, GL_FALSE,  /* alpha_flag */
                               GL_FALSE,        /* db_flag */
                               GL_FALSE,        /* stereo flag */
                               GL_FALSE,        /* ximage_flag */
                               0,       /* depth size */
                               0,       /* stencil size */
                               0, 0, 0, 0,      /* accum_size */
                               0,       /* num samples */
                               0,       /* level */
                               0        /* caveat */
        );
    if (!visual) {
        printf("Couldn't create Mesa/X visual!\n");
        exit(1);
    }

    /* Create a Mesa rendering context */
    context = XMesaCreateContext(visual, NULL   /* share_list */
        );
    if (!context) {
        printf("Couldn't create Mesa/X context!\n");
        exit(1);
    }

    buffer = XMesaCreateWindowBuffer(visual, win);
    if (!buffer) {
        printf("Couldn't create Mesa/X buffer!\n");
        exit(1);
    }

    XMesaMakeCurrent(context, buffer);

    /* Ready to render! */
}

static void
draw_cube(void)
{
    /* X faces */
    glIndexi(Red);
    glColor3f(1.0, 0.0, 0.0);
    glBegin(GL_POLYGON);
    glVertex3f(1.0, 1.0, 1.0);
    glVertex3f(1.0, -1.0, 1.0);
    glVertex3f(1.0, -1.0, -1.0);
    glVertex3f(1.0, 1.0, -1.0);
    glEnd();

    glBegin(GL_POLYGON);
    glVertex3f(-1.0, 1.0, 1.0);
    glVertex3f(-1.0, 1.0, -1.0);
    glVertex3f(-1.0, -1.0, -1.0);
    glVertex3f(-1.0, -1.0, 1.0);
    glEnd();

    /* Y faces */
    glIndexi(Green);
    glColor3f(0.0, 1.0, 0.0);
    glBegin(GL_POLYGON);
    glVertex3f(1.0, 1.0, 1.0);
    glVertex3f(1.0, 1.0, -1.0);
    glVertex3f(-1.0, 1.0, -1.0);
    glVertex3f(-1.0, 1.0, 1.0);
    glEnd();

    glBegin(GL_POLYGON);
    glVertex3f(1.0, -1.0, 1.0);
    glVertex3f(-1.0, -1.0, 1.0);
    glVertex3f(-1.0, -1.0, -1.0);
    glVertex3f(1.0, -1.0, -1.0);
    glEnd();

    /* Z faces */
    glIndexi(Blue);
    glColor3f(0.0, 0.0, 1.0);
    glBegin(GL_POLYGON);
    glVertex3f(1.0, 1.0, 1.0);
    glVertex3f(-1.0, 1.0, 1.0);
    glVertex3f(-1.0, -1.0, 1.0);
    glVertex3f(1.0, -1.0, 1.0);
    glEnd();

    glBegin(GL_POLYGON);
    glVertex3f(1.0, 1.0, -1.0);
    glVertex3f(1.0, -1.0, -1.0);
    glVertex3f(-1.0, -1.0, -1.0);
    glVertex3f(-1.0, 1.0, -1.0);
    glEnd();
}

static void
display_loop(void)
{
    GLfloat xrot, yrot, zrot;

    xrot = yrot = zrot = 0.0;

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearIndex(Black);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-1.0, 1.0, -1.0, 1.0, 1.0, 10.0);
    glTranslatef(0.0, 0.0, -5.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glCullFace(GL_BACK);
    glEnable(GL_CULL_FACE);

    glShadeModel(GL_FLAT);

    while (1) {
        glClear(GL_COLOR_BUFFER_BIT);
        glPushMatrix();
        glRotatef(xrot, 1.0, 0.0, 0.0);
        glRotatef(yrot, 0.0, 1.0, 0.0);
        glRotatef(zrot, 0.0, 0.0, 1.0);

        draw_cube();

        glPopMatrix();
        glFinish();

        xrot += 10.0;
        yrot += 7.0;
        zrot -= 3.0;
    }

}

int
main(int argc, char *argv[])
{
    int mode = 0;

    if (argc >= 2) {
        if (strcmp(argv[1], "-ci") == 0)
            mode = 0;
        else if (strcmp(argv[1], "-rgb") == 0)
            mode = 1;
        else {
            printf("Bad flag: %s\n", argv[1]);
            printf("Specify -ci for 8-bit color index or -rgb for RGB mode\n");
            exit(1);
        }
    }
    else {
        printf("Specify -ci for 8-bit color index or -rgb for RGB mode\n");
        printf("Defaulting to  8-bit color index\n");
    }

    make_window(argv[0], mode);

    display_loop();
    return 0;
}

#endif
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
a41 1
#include <X11/Xmu/SysUtil.h>
a45 1

d47 1
a47 1
EventLoop(Display *dpy, Window win, GC gc)
d49 12
a60 11
   XEvent ev;
   while (1) {
      XNextEvent( dpy, &ev );
      switch (ev.type) {
      case ReparentNotify:
         break;
      case MapNotify:
         break;
      case ConfigureNotify:
      case Expose:
         {         
d67 1
a67 2
            winInfo
                = (DMXWindowAttributes *)
d70 3
a72 4
            if (!DMXGetWindowAttributes(dpy, win, &count,
                                        numScreens, winInfo)) {
               printf("Could not get window information for 0x%08lx\n",
                      (long unsigned)win);
d79 11
a89 10
               char str[500];
               XmuSnprintf(str, sizeof(str),
                       "screen %d:  pos: %dx%d+%d+%d  visible: %dx%d+%d+%d",
                       winInfo[i].screen,
                       winInfo[i].pos.width, winInfo[i].pos.height,
                       winInfo[i].pos.x, winInfo[i].pos.y,
                       winInfo[i].vis.width, winInfo[i].vis.height, 
                       winInfo[i].vis.x, winInfo[i].vis.y);
               XDrawString(dpy, win, gc, x, y, str, strlen(str));
               y += 20;
d92 6
a97 6
         }
         break;
      default:
         printf("Event type 0x%x\n", ev.type);
      }
   }
d103 75
a177 77
   const char *displayName = NULL;
   Display *dpy;
   int event_base, error_base;
   int scr, n;
   long vinfoMask, attrMask;
   XVisualInfo vinfoTemp, *visInfo;
   Visual *vis;
   Window win, root;
   XSetWindowAttributes attr;
   XFontStruct *fontInfo;
   GC gc;

   if (argc > 1) {
      displayName = argv[1];
   }

   dpy = XOpenDisplay(displayName);
   if (!dpy) {
      fprintf(stderr, "Unable to open display %s\n", displayName);
      return -1;
   }

   if (!DMXQueryExtension(dpy, &event_base, &error_base)) {
      fprintf(stderr, "DMX extension not available on this display.\n");
      return -1;
   }

   scr = DefaultScreen(dpy);
   root = RootWindow(dpy, scr);
   vis = DefaultVisual(dpy, scr);

   vinfoMask = VisualIDMask;
   vinfoTemp.visualid = vis->visualid;
   visInfo = XGetVisualInfo(dpy, vinfoMask, &vinfoTemp, &n);
   if (!visInfo || n != 1) {
      fprintf(stderr, "Unable to get visual!\n");
      XCloseDisplay(dpy);
      return -1;
   }

   attr.background_pixel = 0;
   attr.border_pixel = 0;
   attr.colormap = XCreateColormap(dpy, root, visInfo->visual, AllocNone);
   attr.event_mask = StructureNotifyMask | ExposureMask;
   attrMask = CWBackPixel | CWBorderPixel | CWColormap | CWEventMask;

   win = XCreateWindow(dpy, root,
                       500, 500, 600, 400,  /* x, y, w, h */
                       0, /* border_width */
                       visInfo->depth, InputOutput,
		       visInfo->visual, attrMask, &attr);


   if (!win) {
      fprintf(stderr, "Unable to create window!\n");
      XCloseDisplay(dpy);
      return -1;
   }

   fontInfo = XLoadQueryFont(dpy, FontName);
   if (!fontInfo) {
      fprintf(stderr, "Error: font %s not found\n", FontName);
      exit(0);
   }

   gc = XCreateGC(dpy, win, 0, NULL);
   XSetBackground(dpy, gc, BlackPixel(dpy, scr));
   XSetForeground(dpy, gc, WhitePixel(dpy, scr));
   XSetFont(dpy, gc, fontInfo->fid);

   XMapWindow(dpy, win);

   EventLoop(dpy, win, gc);

   XDestroyWindow(dpy, win);
   XCloseDisplay(dpy);
   return 0;
d182 2
a183 1
static void make_window( char *title, int color_flag )
d185 35
a219 36
   int x = 10, y = 10, width = 400, height = 300;
   Display *dpy;
   int scr;
   Window root, win;
   Colormap cmap;
   XColor xcolor;
   int attr_flags;
   XVisualInfo *visinfo;
   XSetWindowAttributes attr;
   XTextProperty tp;
   XSizeHints sh;
   XEvent e;
   XMesaContext context;
   XMesaVisual visual;
   XMesaBuffer buffer;


   /*
    * Do the usual X things to make a window.
    */

   dpy = XOpenDisplay(NULL);
   if (!dpy) {
      printf("Couldn't open default display!\n");
      exit(1);
   }

   scr = DefaultScreen(dpy);
   root = RootWindow(dpy, scr);

   /* alloc visinfo struct */
   visinfo = (XVisualInfo *) malloc( sizeof(XVisualInfo) );

   /* Get a visual and colormap */
   if (color_flag) {
      /* Open TrueColor window */
d227 4
a230 4
      if (!XMatchVisualInfo( dpy, scr, 8, PseudoColor, visinfo )) {
	 printf("Couldn't get 8-bit PseudoColor visual!\n");
	 exit(1);
      }
d232 10
a241 5
      cmap = XCreateColormap( dpy, root, visinfo->visual, AllocNone );
      Black = Red = Green = Blue = 0;
   }
   else {
      /* Open color index window */
d243 1
a243 4
      if (!XMatchVisualInfo( dpy, scr, 8, PseudoColor, visinfo )) {
	 printf("Couldn't get 8-bit PseudoColor visual\n");
	 exit(1);
      }
d245 10
a254 1
      cmap = XCreateColormap( dpy, root, visinfo->visual, AllocNone );
d256 9
a264 10
      /* Allocate colors */
      xcolor.red   = 0x0;
      xcolor.green = 0x0;
      xcolor.blue  = 0x0;
      xcolor.flags = DoRed | DoGreen | DoBlue;
      if (!XAllocColor( dpy, cmap, &xcolor )) {
	 printf("Couldn't allocate black!\n");
	 exit(1);
      }
      Black = xcolor.pixel;
d266 9
a274 9
      xcolor.red   = 0xffff;
      xcolor.green = 0x0;
      xcolor.blue  = 0x0;
      xcolor.flags = DoRed | DoGreen | DoBlue;
      if (!XAllocColor( dpy, cmap, &xcolor )) {
	 printf("Couldn't allocate red!\n");
	 exit(1);
      }
      Red = xcolor.pixel;
d276 10
a285 9
      xcolor.red   = 0x0;
      xcolor.green = 0xffff;
      xcolor.blue  = 0x0;
      xcolor.flags = DoRed | DoGreen | DoBlue;
      if (!XAllocColor( dpy, cmap, &xcolor )) {
	 printf("Couldn't allocate green!\n");
	 exit(1);
      }
      Green = xcolor.pixel;
d287 26
a312 38
      xcolor.red   = 0x0;
      xcolor.green = 0x0;
      xcolor.blue  = 0xffff;
      xcolor.flags = DoRed | DoGreen | DoBlue;
      if (!XAllocColor( dpy, cmap, &xcolor )) {
	 printf("Couldn't allocate blue!\n");
	 exit(1);
      }
      Blue = xcolor.pixel;
   }

   /* set window attributes */
   attr.colormap = cmap;
   attr.event_mask = ExposureMask | StructureNotifyMask;
   attr.border_pixel = BlackPixel( dpy, scr );
   attr.background_pixel = BlackPixel( dpy, scr );
   attr_flags = CWColormap | CWEventMask | CWBorderPixel | CWBackPixel;

   /* Create the window */
   win = XCreateWindow( dpy, root, x,y, width, height, 0,
			    visinfo->depth, InputOutput,
			    visinfo->visual,
			    attr_flags, &attr);
   if (!win) {
      printf("Couldn't open window!\n");
      exit(1);
   }

   XStringListToTextProperty(&title, 1, &tp);
   sh.flags = USPosition | USSize;
   XSetWMProperties(dpy, win, &tp, &tp, 0, 0, &sh, 0, 0);
   XMapWindow(dpy, win);
   while (1) {
      XNextEvent( dpy, &e );
      if (e.type == MapNotify && e.xmap.window == win) {
	 break;
      }
   }
d314 33
d348 1
a348 36
   /*
    * Now do the special Mesa/Xlib stuff!
    */

   visual = XMesaCreateVisual( dpy, visinfo,
                              (GLboolean) color_flag,
                               GL_FALSE,  /* alpha_flag */
                               GL_FALSE,  /* db_flag */
                               GL_FALSE,  /* stereo flag */
                               GL_FALSE,  /* ximage_flag */
                               0,         /* depth size */
                               0,         /* stencil size */
                               0,0,0,0,   /* accum_size */
                               0,         /* num samples */
                               0,         /* level */
                               0          /* caveat */
                              );
   if (!visual) {
      printf("Couldn't create Mesa/X visual!\n");
      exit(1);
   }

   /* Create a Mesa rendering context */
   context = XMesaCreateContext( visual,
                                 NULL       /* share_list */
                               );
   if (!context) {
      printf("Couldn't create Mesa/X context!\n");
      exit(1);
   }

   buffer = XMesaCreateWindowBuffer( visual, win );
   if (!buffer) {
      printf("Couldn't create Mesa/X buffer!\n");
      exit(1);
   }
d350 1
a350 4

   XMesaMakeCurrent( context, buffer );

   /* Ready to render! */
d353 2
a354 3


static void draw_cube( void )
d356 50
a405 50
   /* X faces */
   glIndexi( Red );
   glColor3f( 1.0, 0.0, 0.0 );
   glBegin( GL_POLYGON );
   glVertex3f( 1.0, 1.0, 1.0 );
   glVertex3f( 1.0, -1.0, 1.0 );
   glVertex3f( 1.0, -1.0, -1.0 );
   glVertex3f( 1.0, 1.0, -1.0 );
   glEnd();

   glBegin( GL_POLYGON );
   glVertex3f( -1.0, 1.0, 1.0 );
   glVertex3f( -1.0, 1.0, -1.0 );
   glVertex3f( -1.0, -1.0, -1.0 );
   glVertex3f( -1.0, -1.0, 1.0 );
   glEnd();

   /* Y faces */
   glIndexi( Green );
   glColor3f( 0.0, 1.0, 0.0 );
   glBegin( GL_POLYGON );
   glVertex3f(  1.0, 1.0,  1.0 );
   glVertex3f(  1.0, 1.0, -1.0 );
   glVertex3f( -1.0, 1.0, -1.0 );
   glVertex3f( -1.0, 1.0,  1.0 );
   glEnd();

   glBegin( GL_POLYGON );
   glVertex3f(  1.0, -1.0,  1.0 );
   glVertex3f( -1.0, -1.0,  1.0 );
   glVertex3f( -1.0, -1.0, -1.0 );
   glVertex3f(  1.0, -1.0, -1.0 );
   glEnd();

   /* Z faces */
   glIndexi( Blue );
   glColor3f( 0.0, 0.0, 1.0 );
   glBegin( GL_POLYGON );
   glVertex3f(  1.0,  1.0,  1.0 );
   glVertex3f( -1.0,  1.0,  1.0 );
   glVertex3f( -1.0, -1.0,  1.0 );
   glVertex3f(  1.0, -1.0,  1.0 );
   glEnd();

   glBegin( GL_POLYGON );
   glVertex3f(  1.0, 1.0, -1.0 );
   glVertex3f(  1.0,-1.0, -1.0 );
   glVertex3f( -1.0,-1.0, -1.0 );
   glVertex3f( -1.0, 1.0, -1.0 );
   glEnd();
d408 2
a409 4



static void display_loop( void )
d411 1
a411 1
   GLfloat xrot, yrot, zrot;
d413 1
a413 1
   xrot = yrot = zrot = 0.0;
d415 2
a416 2
   glClearColor( 0.0, 0.0, 0.0, 0.0 );
   glClearIndex( Black );
d418 4
a421 4
   glMatrixMode( GL_PROJECTION );
   glLoadIdentity();
   glFrustum( -1.0, 1.0,  -1.0, 1.0,  1.0, 10.0 );
   glTranslatef( 0.0, 0.0, -5.0 );
d423 2
a424 2
   glMatrixMode( GL_MODELVIEW );
   glLoadIdentity();
d426 2
a427 2
   glCullFace( GL_BACK );
   glEnable( GL_CULL_FACE );
d429 1
a429 1
   glShadeModel( GL_FLAT );
d431 6
a436 6
   while (1) {
      glClear( GL_COLOR_BUFFER_BIT );
      glPushMatrix();
      glRotatef( xrot, 1.0, 0.0, 0.0 );
      glRotatef( yrot, 0.0, 1.0, 0.0 );
      glRotatef( zrot, 0.0, 0.0, 1.0 );
d438 1
a438 1
      draw_cube();
d440 2
a441 2
      glPopMatrix();
      glFinish();
d443 4
a446 4
      xrot += 10.0;
      yrot += 7.0;
      zrot -= 3.0;
   }
d450 2
a451 4



int main( int argc, char *argv[] )
d453 1
a453 1
   int mode = 0;
d455 9
a463 11
   if (argc >= 2)
   {
        if (strcmp(argv[1],"-ci")==0)
           mode = 0;
        else if (strcmp(argv[1],"-rgb")==0)
           mode = 1;
        else
        {
           printf("Bad flag: %s\n", argv[1]);
           printf("Specify -ci for 8-bit color index or -rgb for RGB mode\n");
           exit(1);
d465 2
a466 3
   }
   else
   {
d469 1
a469 1
   }
d471 1
a471 1
   make_window( argv[0], mode );
d473 2
a474 2
   display_loop();
   return 0;
a475 1

@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
@

