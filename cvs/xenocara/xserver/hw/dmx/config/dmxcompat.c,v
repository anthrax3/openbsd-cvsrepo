head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.2
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.3.0.8
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.2.0.8
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.18
	OPENBSD_5_0:1.1.1.2.0.16
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.12
	OPENBSD_4_9_BASE:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.14
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.3;
commitid	s0SI41sEunLdyFfd;

1.3
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.23.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.23.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.40;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 2002 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Rickard E. (Rik) Faith <faith@@redhat.com>
 */

/** \file
 * This file provides some compatibility support for reading VDL files
 * that are used by xmovie
 * (http://www.llnl.gov/icc/sdd/img/xmovie/xmovie.shtml).
 *
 * This file is not used by the DMX server.
 */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include "os.h"
#include "dmxconfig.h"
#include "dmxparse.h"
#include "dmxcompat.h"
#include "parser.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

static int
dmxVDLReadLine(FILE * str, char *buf, int len)
{
    if (fgets(buf, len, str))
        return strlen(buf);
    return 0;
}

static int
dmxVDLCount(const char *buf)
{
    return strtol(buf, NULL, 10);
}

static void
dmxVDLVirtualEntry(const char *buf, char *name, int *len, int *x, int *y)
{
    char *end;
    const char *s;
    char *d;
    int start;

    *x = strtol(buf, &end, 10);
    *y = strtol(end, &end, 10);

    for (s = end, d = name, start = 1; *s && *s != '['; ++s) {
        if (start && isspace(*s))
            continue;
        *d++ = *s;
        start = 0;
    }
    *d = '\0';
    while (d > name && isspace(d[-1]))
        *--d = '\0';            /* remove trailing space */
    *len = strlen(name);
}

static void
dmxVDLDisplayEntry(const char *buf,
                   char *name, int *len,
                   int *x, int *y, int *xoff, int *yoff, int *xorig, int *yorig)
{
    const char *pt;
    char *end;

    pt = strchr(buf, ' ');
    strlcpy(name, buf, 1 + pt - buf);
    *len = strlen(name);

    *x = strtol(pt, &end, 10);
    *y = strtol(end, &end, 10);
    *xorig = strtol(end, &end, 10);
    *yorig = strtol(end, &end, 10);
    *xoff = strtol(end, &end, 10);
    *yoff = strtol(end, NULL, 10);
}

/** Read from the VDL format \a filename and return a newly allocated \a
 * DMXConfigEntryPtr */
DMXConfigEntryPtr
dmxVDLRead(const char *filename)
{
    FILE *str;
    char buf[2048];             /* RATS: Use ok */
    char *pt;
    int lineno = 0;
    DMXConfigEntryPtr entry = NULL;
    DMXConfigVirtualPtr virtual = NULL;
    DMXConfigSubPtr sub = NULL;
    DMXConfigDisplayPtr display = NULL;
    DMXConfigFullDimPtr fdim = NULL;
    int dcount = 0;
    int icount = 0;
    int x, y, xoff, yoff, xorig, yorig;
    char name[2048];            /* RATS: Use ok */
    const char *tmp;
    int len;
    enum {
        simulateFlag,
        virtualCount,
        virtualEntry,
        displayCount,
        displayEntry,
        ignoreCount,
        ignoreEntry
    } state = simulateFlag;

    if (!filename)
        str = stdin;
    else
        str = fopen(filename, "r");
    if (!str)
        return NULL;

    while (dmxVDLReadLine(str, buf, sizeof(buf))) {
        DMXConfigCommentPtr comment = NULL;

        ++lineno;
        for (pt = buf; *pt; pt++)
            if (*pt == '\r' || *pt == '\n') {
                *pt = '\0';
                break;
            }
        if (buf[0] == '#') {
            tmp = dmxConfigCopyString(buf + 1, strlen(buf + 1));
            comment = dmxConfigCreateComment(T_COMMENT, lineno, tmp);
            entry = dmxConfigAddEntry(entry, dmxConfigComment, comment, NULL);
            continue;
        }
        switch (state) {
        case simulateFlag:
            state = virtualCount;
            break;
        case virtualCount:
            state = virtualEntry;
            break;
        case virtualEntry:
            len = sizeof(name);
            dmxVDLVirtualEntry(buf, name, &len, &x, &y);
            tmp = dmxConfigCopyString(name, len);
            virtual = dmxConfigCreateVirtual(NULL,
                                             dmxConfigCreateString(T_STRING,
                                                                   lineno,
                                                                   NULL,
                                                                   tmp),
                                             dmxConfigCreatePair(T_DIMENSION,
                                                                 lineno,
                                                                 NULL,
                                                                 x, y, 0, 0),
                                             NULL, NULL, NULL);
            state = displayCount;
            break;
        case displayCount:
            dcount = dmxVDLCount(buf);
            state = displayEntry;
            break;
        case displayEntry:
            dmxVDLDisplayEntry(buf, name, &len, &x, &y, &xoff, &yoff,
                               &xorig, &yorig);
            tmp = dmxConfigCopyString(name, len);
            fdim =
                dmxConfigCreateFullDim(dmxConfigCreatePartDim
                                       (dmxConfigCreatePair
                                        (T_DIMENSION, lineno, NULL, x, y, 0, 0),
                                        dmxConfigCreatePair(T_OFFSET, lineno,
                                                            NULL, xoff, yoff,
                                                            xoff, yoff)), NULL);
            display =
                dmxConfigCreateDisplay(NULL,
                                       dmxConfigCreateString(T_STRING, lineno,
                                                             NULL, tmp), fdim,
                                       dmxConfigCreatePair(T_ORIGIN, lineno,
                                                           NULL, xorig, yorig,
                                                           0, 0), NULL);
            sub = dmxConfigAddSub(sub, dmxConfigSubDisplay(display));
            if (!--dcount) {
                state = ignoreCount;
                virtual->subentry = sub;
                entry = dmxConfigAddEntry(entry,
                                          dmxConfigVirtual, NULL, virtual);
                virtual = NULL;
                sub = NULL;
            }
            break;
        case ignoreCount:
            icount = dmxVDLCount(buf);
            state = ignoreEntry;
            break;
        case ignoreEntry:
            if (!--icount)
                state = virtualEntry;
            break;
        }
    }

    if (str != stdin)
        fclose(str);

    return entry;
}
@


1.3
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a125 1
    int vcount = 0;
a168 1
            vcount = dmxVDLCount(buf);
@


1.2
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d231 4
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
d45 1
d55 2
a56 1
static int dmxVDLReadLine(FILE *str, char *buf, int len)
d58 2
a59 1
    if (fgets(buf, len, str)) return strlen(buf);
d63 2
a64 1
static int dmxVDLCount(const char *buf)
d69 2
a70 3
static void dmxVDLVirtualEntry(const char *buf,
                               char *name, int *len,
                               int *x, int *y)
d72 1
a72 1
    char       *end;
d74 3
a76 3
    char       *d;
    int        start;
    
d81 3
a83 2
        if (start && isspace(*s)) continue;
        *d++  = *s;
d87 2
a88 1
    while (d > name && isspace(d[-1])) *--d = '\0'; /* remove trailing space */
d92 4
a95 5
static void dmxVDLDisplayEntry(const char *buf,
                               char *name, int *len,
                               int *x, int *y,
                               int *xoff, int *yoff,
                               int *xorig, int *yorig)
d98 5
a102 1
    char       *end;
d104 2
a105 7
    pt   = strchr(buf, ' ');
    strncpy(name, buf, pt-buf);
    name[pt-buf] = '\0';
    *len  = strlen(name);
    
    *x     = strtol(pt, &end, 10);
    *y     = strtol(end, &end, 10);
d108 2
a109 2
    *xoff  = strtol(end, &end, 10);
    *yoff  = strtol(end, NULL, 10);
d114 2
a115 1
DMXConfigEntryPtr dmxVDLRead(const char *filename)
d117 5
a121 5
    FILE                *str;
    char                buf[2048]; /* RATS: Use ok */
    char                *pt;
    int                 lineno  = 0;
    DMXConfigEntryPtr   entry   = NULL;
d123 1
a123 1
    DMXConfigSubPtr     sub     = NULL;
d125 8
a132 8
    DMXConfigFullDimPtr fdim    = NULL;
    int                 vcount  = 0;
    int                 dcount  = 0;
    int                 icount  = 0;
    int                 x, y, xoff, yoff, xorig, yorig;
    char                name[2048]; /* RATS: Use ok */
    const char          *tmp;
    int                 len;
d141 1
a141 1
    }                 state = simulateFlag;
d143 6
a148 3
    if (!filename) str = stdin;
    else           str = fopen(filename, "r");
    if (!str) return NULL;
d152 1
a152 1
        
d176 1
a176 1
            tmp     = dmxConfigCopyString(name, len);
d196 15
a210 25
            tmp     = dmxConfigCopyString(name, len);
            fdim    = dmxConfigCreateFullDim(
                dmxConfigCreatePartDim(
                    dmxConfigCreatePair(T_DIMENSION,
                                        lineno,
                                        NULL,
                                        x, y, 0, 0),
                    dmxConfigCreatePair(T_OFFSET,
                                        lineno,
                                        NULL,
                                        xoff, yoff,
                                        xoff, yoff)),
                NULL);
            display = dmxConfigCreateDisplay(NULL,
                                             dmxConfigCreateString(T_STRING,
                                                                   lineno,
                                                                   NULL,
                                                                   tmp),
                                             fdim,
                                             dmxConfigCreatePair(T_ORIGIN,
                                                                 lineno,
                                                                 NULL,
                                                                 xorig, yorig,
                                                                 0, 0),
                                             NULL);
d213 1
a213 1
                state             = ignoreCount;
d215 4
a218 6
                entry             = dmxConfigAddEntry(entry,
                                                      dmxConfigVirtual,
                                                      NULL,
                                                      virtual);
                virtual           = NULL;
                sub               = NULL;
d226 2
a227 1
            if (!--icount) state = virtualEntry;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
@

