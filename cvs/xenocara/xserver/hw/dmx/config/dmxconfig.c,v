head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.2
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.3.0.16
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.14
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.12
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.10
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.8
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.8
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.3;
commitid	s0SI41sEunLdyFfd;

1.3
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.23.27;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.23.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.41;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 2002-2003 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Rickard E. (Rik) Faith <faith@@redhat.com>
 *
 */

/** \file
 * Provides interface for reading DMX configuration files and for
 * combining that information with command-line configuration parameters. */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include "dmx.h"
#include "dmxinput.h"
#include "dmxconfig.h"
#include "dmxparse.h"
#include "dmxlog.h"
#include "dmxcb.h"
#include "dmxstat.h"
#include "parser.h"

extern int yydebug;
extern FILE *yyin;

static char *dmxXkbRules;
static char *dmxXkbModel;
static char *dmxXkbLayout;
static char *dmxXkbVariant;
static char *dmxXkbOptions;

/** Stores lists of configuration information. */
typedef struct DMXConfigListStruct {
    const char *name;
    struct DMXConfigListStruct *next;
} DMXConfigList, *DMXConfigListPtr;

/** This stucture stores the parsed configuration information. */
typedef struct DMXConfigCmdStruct {
    const char *filename;
    const char *config;
    DMXConfigList *displays;
    DMXConfigList *inputs;
    DMXConfigList *xinputs;
} DMXConfigCmd, *DMXConfigCmdPtr;

DMXConfigEntryPtr dmxConfigEntry;
static DMXConfigCmd dmxConfigCmd;

static int dmxDisplaysFromCommandLine;

/** Make a note that \a display is the name of an X11 display that
 * should be initialized as a backend (output) display.  Called from
 * #ddxProcessArgument. */
void
dmxConfigStoreDisplay(const char *display)
{
    DMXConfigListPtr entry = malloc(sizeof(*entry));

    entry->name = strdup(display);
    entry->next = NULL;
    if (!dmxConfigCmd.displays)
        dmxConfigCmd.displays = entry;
    else {
        DMXConfigList *pt;

        for (pt = dmxConfigCmd.displays; pt->next; pt = pt->next);
        if (!pt)
            dmxLog(dmxFatal, "dmxConfigStoreDisplay: end of list non-NULL\n");
        pt->next = entry;
    }
    ++dmxDisplaysFromCommandLine;
}

/** Make a note that \a input is the name of an X11 display that should
 * be used for input (either a backend or a console input device). */
void
dmxConfigStoreInput(const char *input)
{
    DMXConfigListPtr entry = malloc(sizeof(*entry));

    entry->name = strdup(input);
    entry->next = NULL;
    if (!dmxConfigCmd.inputs)
        dmxConfigCmd.inputs = entry;
    else {
        DMXConfigList *pt;

        for (pt = dmxConfigCmd.inputs; pt->next; pt = pt->next);
        if (!pt)
            dmxLog(dmxFatal, "dmxConfigStoreInput: end of list non-NULL\n");
        pt->next = entry;
    }
}

/** Make a note that \a input is the name of an X11 display that should
 * be used for input from XInput extension devices. */
void
dmxConfigStoreXInput(const char *input)
{
    DMXConfigListPtr entry = malloc(sizeof(*entry));

    entry->name = strdup(input);
    entry->next = NULL;
    if (!dmxConfigCmd.xinputs)
        dmxConfigCmd.xinputs = entry;
    else {
        DMXConfigList *pt;

        for (pt = dmxConfigCmd.xinputs; pt->next; pt = pt->next);
        if (!pt)
            dmxLog(dmxFatal, "dmxConfigStoreXInput: end of list non-NULL\n");
        pt->next = entry;
    }
}

/** Make a note that \a file is the configuration file. */
void
dmxConfigStoreFile(const char *file)
{
    if (dmxConfigCmd.filename)
        dmxLog(dmxFatal, "Only one -configfile allowed\n");
    dmxConfigCmd.filename = strdup(file);
}

/** Make a note that \a config should be used as the configuration for
 * current instantiation of the DMX server. */
void
dmxConfigStoreConfig(const char *config)
{
    if (dmxConfigCmd.config)
        dmxLog(dmxFatal, "Only one -config allowed\n");
    dmxConfigCmd.config = strdup(config);
}

static int
dmxConfigReadFile(const char *filename, int debug)
{
    FILE *str;

    if (!(str = fopen(filename, "r")))
        return -1;
    dmxLog(dmxInfo, "Reading configuration file \"%s\"\n", filename);
    yyin = str;
    yydebug = debug;
    yyparse();
    fclose(str);
    return 0;
}

static const char *
dmxConfigMatch(const char *target, DMXConfigEntryPtr entry)
{
    DMXConfigVirtualPtr v = entry->virtual;
    const char *name = NULL;

    if (v && v->name)
        name = v->name;

    if (v && !dmxConfigCmd.config)
        return v->name ? v->name : "<noname>";
    if (!name)
        return NULL;
    if (!strcmp(name, target))
        return name;
    return NULL;
}

static DMXScreenInfo *
dmxConfigAddDisplay(const char *name,
                    int scrnWidth, int scrnHeight,
                    int scrnX, int scrnY,
                    int scrnXSign, int scrnYSign,
                    int rootWidth, int rootHeight,
                    int rootX, int rootY, int rootXSign, int rootYSign)
{
    DMXScreenInfo *dmxScreen;

    if (!(dmxScreens = reallocarray(dmxScreens, dmxNumScreens + 1,
                                    sizeof(*dmxScreens))))
        dmxLog(dmxFatal,
               "dmxConfigAddDisplay: realloc failed for screen %d (%s)\n",
               dmxNumScreens, name);

    dmxScreen = &dmxScreens[dmxNumScreens];
    memset(dmxScreen, 0, sizeof(*dmxScreen));
    dmxScreen->name = name;
    dmxScreen->index = dmxNumScreens;
    dmxScreen->scrnWidth = scrnWidth;
    dmxScreen->scrnHeight = scrnHeight;
    dmxScreen->scrnX = scrnX;
    dmxScreen->scrnY = scrnY;
    dmxScreen->scrnXSign = scrnXSign;
    dmxScreen->scrnYSign = scrnYSign;
    dmxScreen->rootWidth = rootWidth;
    dmxScreen->rootHeight = rootHeight;
    dmxScreen->rootX = rootX;
    dmxScreen->rootY = rootY;
    dmxScreen->stat = dmxStatAlloc();
    ++dmxNumScreens;
    return dmxScreen;
}

DMXInputInfo *
dmxConfigAddInput(const char *name, int core)
{
    DMXInputInfo *dmxInput;

    if (!(dmxInputs = reallocarray(dmxInputs, dmxNumInputs + 1,
                                   sizeof(*dmxInputs))))
        dmxLog(dmxFatal,
               "dmxConfigAddInput: realloc failed for input %d (%s)\n",
               dmxNumInputs, name);

    dmxInput = &dmxInputs[dmxNumInputs];

    memset(dmxInput, 0, sizeof(*dmxInput));
    dmxInput->name = name;
    dmxInput->inputIdx = dmxNumInputs;
    dmxInput->scrnIdx = -1;
    dmxInput->core = core;
    ++dmxNumInputs;
    return dmxInput;
}

static void
dmxConfigCopyFromDisplay(DMXConfigDisplayPtr d)
{
    DMXScreenInfo *dmxScreen;

    dmxScreen = dmxConfigAddDisplay(d->name,
                                    d->scrnWidth, d->scrnHeight,
                                    d->scrnX, d->scrnY,
                                    d->scrnXSign, d->scrnYSign,
                                    d->rootWidth, d->rootHeight,
                                    d->rootX, d->rootY,
                                    d->rootXSign, d->rootXSign);
    dmxScreen->where = PosAbsolute;
    dmxScreen->whereX = d->rootXOrigin;
    dmxScreen->whereY = d->rootYOrigin;
}

static void
dmxConfigCopyFromWall(DMXConfigWallPtr w)
{
    DMXConfigStringPtr pt;
    DMXScreenInfo *dmxScreen;
    int edge = dmxNumScreens;
    int last = dmxNumScreens;

    if (!w->xwall && !w->ywall) {       /* Try to make it square */
        int count;

        for (pt = w->nameList, count = 0; pt; pt = pt->next)
            ++count;
        w->xwall = sqrt(count) + .5;
    }

    for (pt = w->nameList; pt; pt = pt->next) {
        dmxScreen = dmxConfigAddDisplay(pt->string, w->width, w->height,
                                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        if (pt == w->nameList) {        /* Upper left */
            dmxScreen->where = PosAbsolute;
            dmxScreen->whereX = 0;
            dmxScreen->whereY = 0;
        }
        else if (w->xwall) {    /* Tile left to right, then top to bottom */
            if (!((dmxNumScreens - 1) % w->xwall)) {
                dmxScreen->where = PosBelow;
                dmxScreen->whereRefScreen = edge;
                edge = dmxNumScreens - 1;
            }
            else {
                dmxScreen->where = PosRightOf;
                dmxScreen->whereRefScreen = last;
            }
        }
        else {                  /* Tile top to bottom, then left to right */
            if (!((dmxNumScreens - 1) % w->ywall)) {
                dmxScreen->where = PosRightOf;
                dmxScreen->whereRefScreen = edge;
                edge = dmxNumScreens - 1;
            }
            else {
                dmxScreen->where = PosBelow;
                dmxScreen->whereRefScreen = last;
            }

        }
        last = dmxNumScreens - 1;
        if (dmxScreen->where == PosAbsolute)
            dmxLog(dmxInfo, "Added %s at %d %d\n",
                   pt->string, dmxScreen->whereX, dmxScreen->whereY);
        else
            dmxLog(dmxInfo, "Added %s %s %s\n",
                   pt->string,
                   dmxScreen->where == PosBelow ? "below" : "right of",
                   dmxScreens[dmxScreen->whereRefScreen].name);
    }
}

static void
dmxConfigCopyFromOption(DMXConfigOptionPtr o)
{
    DMXConfigStringPtr pt;
    int argc = 0;
    char **argv = NULL;

    if (serverGeneration != 1)
        return;                 /* FIXME: only do once, for now */
    if (!o || !o->string)
        return;
    for (pt = o->option; pt; pt = pt->next) {
        if (pt->string) {
            ++argc;
            argv = reallocarray(argv, argc + 1, sizeof(*argv));
            argv[argc] = (char *) pt->string;
        }
    }
    argv[0] = NULL;
    ProcessCommandLine(argc + 1, argv);
    free(argv);
}

static void
dmxConfigCopyFromParam(DMXConfigParamPtr p)
{
    const char **argv;
    int argc;

    if ((argv = dmxConfigLookupParam(p, "xkbrules", &argc)) && argc == 2) {
        dmxConfigSetXkbRules(argv[1]);
    }
    else if ((argv = dmxConfigLookupParam(p, "xkbmodel", &argc))
             && argc == 2) {
        dmxConfigSetXkbModel(argv[1]);
    }
    else if ((argv = dmxConfigLookupParam(p, "xkblayout", &argc))
             && argc == 2) {
        dmxConfigSetXkbLayout(argv[1]);
    }
    else if ((argv = dmxConfigLookupParam(p, "xkbvariant", &argc))
             && argc == 2) {
        dmxConfigSetXkbVariant(argv[1]);
    }
    else if ((argv = dmxConfigLookupParam(p, "xkboptions", &argc))
             && argc == 2) {
        dmxConfigSetXkbOptions(argv[1]);
    }
}

static void
dmxConfigCopyData(DMXConfigVirtualPtr v)
{
    DMXConfigSubPtr sub;

    if (v->dim)
        dmxSetWidthHeight(v->dim->x, v->dim->y);
    else
        dmxSetWidthHeight(0, 0);
    for (sub = v->subentry; sub; sub = sub->next) {
        switch (sub->type) {
        case dmxConfigDisplay:
            dmxConfigCopyFromDisplay(sub->display);
            break;
        case dmxConfigWall:
            dmxConfigCopyFromWall(sub->wall);
            break;
        case dmxConfigOption:
            dmxConfigCopyFromOption(sub->option);
            break;
        case dmxConfigParam:
            dmxConfigCopyFromParam(sub->param);
            break;
        default:
            dmxLog(dmxFatal,
                   "dmxConfigCopyData: not a display, wall, or value\n");
        }
    }
}

static void
dmxConfigFromCommandLine(void)
{
    DMXConfigListPtr pt;

    dmxLog(dmxInfo, "Using configuration from command line\n");
    for (pt = dmxConfigCmd.displays; pt; pt = pt->next) {
        DMXScreenInfo *dmxScreen = dmxConfigAddDisplay(pt->name,
                                                       0, 0, 0, 0, 0, 0,
                                                       0, 0, 0, 0, 0, 0);

        if (dmxNumScreens == 1) {
            dmxScreen->where = PosAbsolute;
            dmxScreen->whereX = 0;
            dmxScreen->whereY = 0;
            dmxLog(dmxInfo, "Added %s at %d %d\n",
                   dmxScreen->name, dmxScreen->whereX, dmxScreen->whereY);
        }
        else {
            dmxScreen->where = PosRightOf;
            dmxScreen->whereRefScreen = dmxNumScreens - 2;
            if (dmxScreen->whereRefScreen < 0)
                dmxScreen->whereRefScreen = 0;
            dmxLog(dmxInfo, "Added %s %s %s\n",
                   dmxScreen->name,
                   dmxScreen->where == PosBelow ? "below" : "right of",
                   dmxScreens[dmxScreen->whereRefScreen].name);
        }
    }
}

static void
dmxConfigFromConfigFile(void)
{
    DMXConfigEntryPtr pt;
    const char *name;

    for (pt = dmxConfigEntry; pt; pt = pt->next) {
        /* FIXME -- if an input is specified, use it */
        if (pt->type != dmxConfigVirtual)
            continue;
        if ((name = dmxConfigMatch(dmxConfigCmd.config, pt))) {
            dmxLog(dmxInfo, "Using configuration \"%s\"\n", name);
            dmxConfigCopyData(pt->virtual);
            return;
        }
    }
    dmxLog(dmxFatal, "Could not find configuration \"%s\" in \"%s\"\n",
           dmxConfigCmd.config, dmxConfigCmd.filename);
}

static void
dmxConfigConfigInputs(void)
{
    DMXConfigListPtr pt;

    if (dmxNumInputs)
        return;

    if (dmxConfigCmd.inputs) {  /* Use command line */
        for (pt = dmxConfigCmd.inputs; pt; pt = pt->next)
            dmxConfigAddInput(pt->name, TRUE);
    }
    else if (dmxNumScreens) {   /* Use first display */
        dmxConfigAddInput(dmxScreens[0].name, TRUE);
    }
    else {                      /* Use dummy */
        dmxConfigAddInput("dummy", TRUE);
    }

    if (dmxConfigCmd.xinputs) { /* Non-core devices from command line */
        for (pt = dmxConfigCmd.xinputs; pt; pt = pt->next)
            dmxConfigAddInput(pt->name, FALSE);
    }
}

/** Set up the appropriate global variables so that the DMX server will
 * be initialized using the configuration specified in the config file
 * and on the command line. */
void
dmxConfigConfigure(void)
{
    if (dmxConfigEntry) {
        dmxConfigFreeEntry(dmxConfigEntry);
        dmxConfigEntry = NULL;
    }
    if (dmxConfigCmd.filename) {
        if (dmxConfigCmd.displays)
            dmxLog(dmxWarning,
                   "Using configuration file \"%s\" instead of command line\n",
                   dmxConfigCmd.filename);
        dmxConfigReadFile(dmxConfigCmd.filename, 0);
        dmxConfigFromConfigFile();
    }
    else {
        if (dmxConfigCmd.config)
            dmxLog(dmxWarning,
                   "Configuration name (%s) without configuration file\n",
                   dmxConfigCmd.config);
        dmxConfigFromCommandLine();
    }
    dmxConfigConfigInputs();
}

/** This function determines the number of displays we WILL have and
 * sets MAXSCREENS to that value.  This is difficult since the number
 * depends on the command line (which is easy to count) or on the config
 * file, which has to be parsed. */
void
dmxConfigSetMaxScreens(void)
{
    static int processing = 0;

    if (processing)
        return;                 /* Prevent reentry via ProcessCommandLine */
    processing = 1;
    if (dmxConfigCmd.filename) {
        if (!dmxNumScreens)
            dmxConfigConfigure();
#ifndef MAXSCREENS
        SetMaxScreens(dmxNumScreens);
#endif
    }
    else
#ifndef MAXSCREENS
        SetMaxScreens(dmxDisplaysFromCommandLine);
#endif
    processing = 0;
}

/** This macro is used to generate the following access methods:
 * - dmxConfig{Set,Get}rules
 * - dmxConfig{Set,Get}model
 * - dmxConfig{Set,Get}layout
 * - dmxConfig{Set,Get}variant
 * - dmxConfig{Set,Get}options
 * These methods are used to read and write information about the keyboard. */

#define GEN(param,glob,def)                                                   \
 void dmxConfigSet##glob(const char *param) {                                 \
     if (dmx##glob) free((void *)dmx##glob);                                  \
     dmx##glob = strdup(param);                                               \
 }                                                                            \
 char *dmxConfigGet##glob(void) {                                             \
     return (char *)(dmx##glob ? dmx##glob : def);                            \
 }

GEN(rules, XkbRules, XKB_DFLT_RULES)
    GEN(model, XkbModel, XKB_DFLT_MODEL)
    GEN(layout, XkbLayout, XKB_DFLT_LAYOUT)
    GEN(variant, XkbVariant, XKB_DFLT_VARIANT)
    GEN(options, XkbOptions, XKB_DFLT_OPTIONS)
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d51 1
a51 1
extern int yyparse(void);
d207 2
a208 2
    if (!(dmxScreens = realloc(dmxScreens,
                               (dmxNumScreens + 1) * sizeof(*dmxScreens))))
d237 2
a238 2
    if (!(dmxInputs = realloc(dmxInputs,
                              (dmxNumInputs + 1) * sizeof(*dmxInputs))))
d344 1
a344 1
            argv = realloc(argv, (argc + 1) * sizeof(*argv));
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a36 1
    
d51 1
a51 1
extern int  yyparse(void);
d62 1
a62 1
    const char                 *name;
d68 2
a69 2
    const char    *filename;
    const char    *config;
d75 2
a76 2
DMXConfigEntryPtr    dmxConfigEntry;
static DMXConfigCmd  dmxConfigCmd;
d83 2
a84 1
void dmxConfigStoreDisplay(const char *display)
d87 1
d90 2
a91 1
    if (!dmxConfigCmd.displays) dmxConfigCmd.displays = entry;
d94 1
d105 2
a106 1
void dmxConfigStoreInput(const char *input)
d109 1
d112 2
a113 1
    if (!dmxConfigCmd.inputs) dmxConfigCmd.inputs = entry;
d116 1
d126 2
a127 1
void dmxConfigStoreXInput(const char *input)
d130 1
d133 2
a134 1
    if (!dmxConfigCmd.xinputs) dmxConfigCmd.xinputs = entry;
d137 1
d146 2
a147 1
void dmxConfigStoreFile(const char *file)
d156 2
a157 1
void dmxConfigStoreConfig(const char *config)
d159 2
a160 1
    if (dmxConfigCmd.config) dmxLog(dmxFatal, "Only one -config allowed\n");
d164 2
a165 1
static int dmxConfigReadFile(const char *filename, int debug)
d169 2
a170 1
    if (!(str = fopen(filename, "r"))) return -1;
d172 1
a172 1
    yyin    = str;
d179 2
a180 1
static const char *dmxConfigMatch(const char *target, DMXConfigEntryPtr entry)
d182 2
a183 2
    DMXConfigVirtualPtr v     = entry->virtual;
    const char          *name = NULL;
d185 2
a186 1
    if (v && v->name) name = v->name;
d188 6
a193 3
    if (v && !dmxConfigCmd.config) return v->name ? v->name : "<noname>";
    if (!name)                     return NULL;
    if (!strcmp(name, target))     return name;
d197 7
a203 7
static DMXScreenInfo *dmxConfigAddDisplay(const char *name,
                                          int scrnWidth,   int scrnHeight,
                                          int scrnX,       int scrnY,
                                          int scrnXSign,   int scrnYSign,
                                          int rootWidth,   int rootHeight,
                                          int rootX,       int rootY,
                                          int rootXSign,   int rootYSign)
d206 1
a206 1
    
d208 1
a208 1
                               (dmxNumScreens+1) * sizeof(*dmxScreens))))
d212 1
a212 1
    
d215 3
a217 3
    dmxScreen->name       = name;
    dmxScreen->index      = dmxNumScreens;
    dmxScreen->scrnWidth  = scrnWidth;
d219 5
a223 5
    dmxScreen->scrnX      = scrnX;
    dmxScreen->scrnY      = scrnY;
    dmxScreen->scrnXSign  = scrnXSign;
    dmxScreen->scrnYSign  = scrnYSign;
    dmxScreen->rootWidth  = rootWidth;
d225 3
a227 3
    dmxScreen->rootX      = rootX;
    dmxScreen->rootY      = rootY;
    dmxScreen->stat       = dmxStatAlloc();
d232 2
a233 1
DMXInputInfo *dmxConfigAddInput(const char *name, int core)
d238 1
a238 1
                              (dmxNumInputs+1) * sizeof(*dmxInputs))))
d246 1
a246 1
    dmxInput->name     = name;
d248 2
a249 2
    dmxInput->scrnIdx  = -1;
    dmxInput->core     = core;
d254 2
a255 1
static void dmxConfigCopyFromDisplay(DMXConfigDisplayPtr d)
d259 8
a266 8
    dmxScreen         = dmxConfigAddDisplay(d->name,
                                            d->scrnWidth, d->scrnHeight,
                                            d->scrnX,     d->scrnY,
                                            d->scrnXSign, d->scrnYSign,
                                            d->rootWidth, d->rootHeight,
                                            d->rootX,     d->rootY,
                                            d->rootXSign, d->rootXSign);
    dmxScreen->where  = PosAbsolute;
d271 2
a272 1
static void dmxConfigCopyFromWall(DMXConfigWallPtr w)
d275 3
a277 3
    DMXScreenInfo      *dmxScreen;
    int                edge = dmxNumScreens;
    int                last = dmxNumScreens;
d279 1
a279 1
    if (!w->xwall && !w->ywall) { /* Try to make it square */
d281 3
a283 1
        for (pt = w->nameList, count = 0; pt; pt = pt->next) ++count;
d290 2
a291 2
        if (pt == w->nameList) { /* Upper left */
            dmxScreen->where  = PosAbsolute;
d294 4
a297 3
        } else if (w->xwall) {  /* Tile left to right, then top to bottom */
            if (!((dmxNumScreens-1) % w->xwall)) {
                dmxScreen->where          = PosBelow;
d299 4
a302 3
                edge                      = dmxNumScreens-1;
            } else {
                dmxScreen->where          = PosRightOf;
d305 4
a308 3
        } else {                /* Tile top to bottom, then left to right */
            if (!((dmxNumScreens-1) % w->ywall)) {
                dmxScreen->where          = PosRightOf;
d310 4
a313 3
                edge                      = dmxNumScreens-1;
            } else {
                dmxScreen->where          = PosBelow;
d318 1
a318 1
        last = dmxNumScreens-1;
d330 2
a331 1
static void dmxConfigCopyFromOption(DMXConfigOptionPtr o)
d334 2
a335 2
    int                argc   = 0;
    char               **argv = NULL;
d337 4
a340 2
    if (serverGeneration != 1) return; /* FIXME: only do once, for now */
    if (!o || !o->string) return;
d344 2
a345 2
            argv = realloc(argv, (argc+1) * sizeof(*argv));
            argv[argc] = (char *)pt->string;
d349 1
a349 1
    ProcessCommandLine(argc+1, argv);
d353 2
a354 1
static void dmxConfigCopyFromParam(DMXConfigParamPtr p)
d357 2
a358 2
    int        argc;
    
d361 3
a363 2
    } else if ((argv = dmxConfigLookupParam(p, "xkbmodel", &argc))
               && argc == 2) {
d365 3
a367 2
    } else if ((argv = dmxConfigLookupParam(p, "xkblayout", &argc))
               && argc == 2) {
d369 3
a371 2
    } else if ((argv = dmxConfigLookupParam(p, "xkbvariant", &argc))
               && argc == 2) {
d373 3
a375 2
    } else if ((argv = dmxConfigLookupParam(p, "xkboptions", &argc))
               && argc == 2) {
d380 2
a381 1
static void dmxConfigCopyData(DMXConfigVirtualPtr v)
d384 5
a388 3
    
    if (v->dim) dmxSetWidthHeight(v->dim->x, v->dim->y);
    else        dmxSetWidthHeight(0, 0);
d391 12
a402 4
        case dmxConfigDisplay: dmxConfigCopyFromDisplay(sub->display); break;
        case dmxConfigWall:    dmxConfigCopyFromWall(sub->wall);       break;
        case dmxConfigOption:  dmxConfigCopyFromOption(sub->option);   break;
        case dmxConfigParam:   dmxConfigCopyFromParam(sub->param);     break;
d410 2
a411 1
static void dmxConfigFromCommandLine(void)
d414 1
a414 1
    
d420 1
d422 1
a422 1
            dmxScreen->where  = PosAbsolute;
d427 3
a429 2
        } else {
            dmxScreen->where          = PosRightOf;
d431 2
a432 1
            if (dmxScreen->whereRefScreen < 0) dmxScreen->whereRefScreen = 0;
d441 2
a442 1
static void dmxConfigFromConfigFile(void)
d445 1
a445 1
    const char        *name;
d448 3
a450 2
                                /* FIXME -- if an input is specified, use it */
        if (pt->type != dmxConfigVirtual) continue;
d461 2
a462 1
static void dmxConfigConfigInputs(void)
d466 4
a469 3
    if (dmxNumInputs) return;
    
    if (dmxConfigCmd.inputs) {   /* Use command line */
d472 2
a473 1
    } else if (dmxNumScreens) { /* Use first display */
d475 2
a476 1
    } else {                     /* Use dummy */
d480 1
a480 1
    if (dmxConfigCmd.xinputs) {  /* Non-core devices from command line */
d489 2
a490 1
void dmxConfigConfigure(void)
d503 2
a504 1
    } else {
d518 2
a519 1
void dmxConfigSetMaxScreens(void)
d523 2
a524 1
    if (processing) return;     /* Prevent reentry via ProcessCommandLine */
d532 2
a533 1
    } else
d557 5
a561 5
GEN(rules,   XkbRules,   XKB_DFLT_RULES)
GEN(model,   XkbModel,   XKB_DFLT_MODEL)
GEN(layout,  XkbLayout,  XKB_DFLT_LAYOUT)
GEN(variant, XkbVariant, XKB_DFLT_VARIANT)
GEN(options, XkbOptions, XKB_DFLT_OPTIONS)
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
d493 5
a497 6
GEN(rules,   XkbRules,   DMX_DEFAULT_XKB_RULES)
GEN(model,   XkbModel,   DMX_DEFAULT_XKB_MODEL)
GEN(layout,  XkbLayout,  DMX_DEFAULT_XKB_LAYOUT)
GEN(variant, XkbVariant, DMX_DEFAULT_XKB_VARIANT)
GEN(options, XkbOptions, DMX_DEFAULT_XKB_OPTIONS)
    
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
@

