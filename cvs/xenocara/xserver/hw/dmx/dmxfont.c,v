head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.7.0.6
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.10
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	s0SI41sEunLdyFfd;

1.7
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.16;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.45;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.45;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.20;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Kevin E. Martin <kem@@redhat.com>
 *
 */

/** \file
 * This file provides support for fonts. */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#define DMX_FONTPATH_DEBUG 0

#include "dmx.h"
#include "dmxsync.h"
#include "dmxfont.h"
#include "dmxlog.h"

#include <X11/fonts/fontstruct.h>
#include "dixfont.h"
#include "dixstruct.h"

static int (*dmxSaveProcVector[256]) (ClientPtr);
static int dmxFontLastError;

static int
dmxFontErrorHandler(Display * dpy, XErrorEvent * ev)
{
    dmxFontLastError = ev->error_code;

    return 0;
}

static char **
dmxGetFontPath(int *npaths)
{
    char **fp;
    unsigned char *c, *paths;
    char *newfp;
    int len, l, i;

    GetFontPath(serverClient, npaths, &len, &paths);

    newfp = malloc(*npaths + len);
    c = (unsigned char *) newfp;
    fp = xallocarray(*npaths, sizeof(*fp));

    memmove(newfp, paths + 1, *npaths + len - 1);
    l = *paths;
    for (i = 0; i < *npaths; i++) {
        fp[i] = (char *) c;
        c += l;
        l = *c;
        *c++ = '\0';
    }

#if DMX_FONTPATH_DEBUG
    for (i = 0; i < *npaths; i++)
        dmxLog(dmxDebug, "FontPath[%d] = %s\n", i, fp[i]);
#endif

    return fp;
}

static void
dmxFreeFontPath(char **fp)
{
    free(fp[0]);
    free(fp);
}

static Bool
dmxCheckFontPathElement(DMXScreenInfo * dmxScreen, char *fp)
{
    int (*oldErrorHandler) (Display *, XErrorEvent *);

    if (!dmxScreen->beDisplay)
        return TRUE;

    dmxFontLastError = 0;
    oldErrorHandler = XSetErrorHandler(dmxFontErrorHandler);
    XSetFontPath(dmxScreen->beDisplay, &fp, 1);
    dmxSync(dmxScreen, TRUE);   /* Must complete before removing handler */
    XSetErrorHandler(oldErrorHandler);

    return dmxFontLastError == 0;
}

static int
dmxSetFontPath(DMXScreenInfo * dmxScreen)
{
    int (*oldErrorHandler) (Display *, XErrorEvent *);
    char **fp;
    int result = Success;
    int npaths;

    if (!dmxScreen->beDisplay)
        return result;

    fp = dmxGetFontPath(&npaths);
    if (!fp)
        return BadAlloc;

    dmxFontLastError = 0;
    oldErrorHandler = XSetErrorHandler(dmxFontErrorHandler);
    XSetFontPath(dmxScreen->beDisplay, fp, npaths);
    dmxSync(dmxScreen, TRUE);   /* Must complete before removing handler */
    XSetErrorHandler(oldErrorHandler);

    if (dmxFontLastError) {
        result = dmxFontLastError;
        /* We could set *error here to the offending path, but it is
         * ignored, so we don't bother figuring out which path is bad.
         * If we do add this support in the future, we'll need to add
         * error to the function's argument list.
         */
    }

    dmxFreeFontPath(fp);

    return result;
}

static int
dmxCheckFontPath(DMXScreenInfo * dmxScreen, int *error)
{
    char **oldFontPath;
    int nOldPaths;
    int result = Success;

    if (!dmxScreen->beDisplay)
        return result;

    /* Save old font path */
    oldFontPath = XGetFontPath(dmxScreen->beDisplay, &nOldPaths);

    result = dmxSetFontPath(dmxScreen);

    /* Restore old font path */
    XSetFontPath(dmxScreen->beDisplay, oldFontPath, nOldPaths);
    XFreeFontPath(oldFontPath);
    dmxSync(dmxScreen, FALSE);

    return result;
}

static int
dmxProcSetFontPath(ClientPtr client)
{
    unsigned char *ptr;
    unsigned long nbytes, total, n;
    long nfonts;
    int i, result;
    unsigned char *oldFontPath, *tmpFontPath;
    int nOldPaths;
    int lenOldPaths;

    REQUEST(xSetFontPathReq);

    REQUEST_AT_LEAST_SIZE(xSetFontPathReq);

    nbytes = (client->req_len << 2) - sizeof(xSetFontPathReq);
    total = nbytes;
    ptr = (unsigned char *) &stuff[1];
    nfonts = stuff->nFonts;

    while (--nfonts >= 0) {
        if ((total == 0) || (total < (n = (*ptr + 1))))
            return BadLength;
        total -= n;
        ptr += n;
    }
    if (total >= 4)
        return BadLength;

    GetFontPath(serverClient, &nOldPaths, &lenOldPaths, &tmpFontPath);
    oldFontPath = malloc(nOldPaths + lenOldPaths);
    memmove(oldFontPath, tmpFontPath, nOldPaths + lenOldPaths);

    result = SetFontPath(client, stuff->nFonts, (unsigned char *) &stuff[1]);
    if (!result) {
        int error = 0;

        for (i = 0; i < dmxNumScreens; i++)
            if ((result = dmxCheckFontPath(&dmxScreens[i], &error)))
                break;

        if (result) {
            /* Restore old fontpath in the DMX server */
            SetFontPath(client, nOldPaths, oldFontPath);
            client->errorValue = error;
        }
    }

    free(oldFontPath);
    return result;
}

/** Initialize font support.  In addition to the screen function call
 *  pointers, DMX also hooks in at the ProcVector[] level.  Here the old
 *  ProcVector function pointers are saved and the new ProcVector
 *  function pointers are initialized. */
void
dmxInitFonts(void)
{
    int i;

    for (i = 0; i < 256; i++)
        dmxSaveProcVector[i] = ProcVector[i];

    ProcVector[X_SetFontPath] = dmxProcSetFontPath;
}

/** Reset font support by restoring the original ProcVector function
 *  pointers. */
void
dmxResetFonts(void)
{
    int i;

    for (i = 0; i < 256; i++)
        ProcVector[i] = dmxSaveProcVector[i];
}

/** Load the font, \a pFont, on the back-end server associated with \a
 *  pScreen.  When a font is loaded, the font path on back-end server is
 *  first initialized to that specified on the command line with the
 *  -fontpath options, and then the font is loaded. */
Bool
dmxBELoadFont(ScreenPtr pScreen, FontPtr pFont)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxFontPrivPtr pFontPriv = FontGetPrivate(pFont, dmxFontPrivateIndex);
    const char *name;
    char **oldFontPath = NULL;
    int nOldPaths;
    Atom name_atom, value_atom;
    int i;

    /* Make sure we have a font private struct to work with */
    if (!pFontPriv)
        return FALSE;

    /* Don't load a font over top of itself */
    if (pFontPriv->font[pScreen->myNum]) {
        return TRUE;            /* Already loaded font */
    }

    /* Save old font path */
    oldFontPath = XGetFontPath(dmxScreen->beDisplay, &nOldPaths);

    /* Set the font path for the font about to be loaded on the back-end */
    if (dmxSetFontPath(dmxScreen)) {
        char **fp;
        int npaths;
        Bool *goodfps;

        /* This could fail only when first starting the X server and
         * loading the default font.  If it fails here, then the default
         * font path is invalid, no default font path will be set, the
         * DMX server will fail to load the default font, and it will
         * exit with an error unless we remove the offending font paths
         * with the -ignorebadfontpaths command line option.
         */

        fp = dmxGetFontPath(&npaths);
        if (!fp) {
            dmxLog(dmxError, "No default font path set.\n");
            dmxLog(dmxError,
                   "Please see the Xdmx man page for information on how to\n");
            dmxLog(dmxError,
                   "initialize the DMX server's default font path.\n");
            XFreeFontPath(oldFontPath);
            return FALSE;
        }

        if (!dmxFontPath)
            dmxLog(dmxWarning, "No default font path is set.\n");

        goodfps = xallocarray(npaths, sizeof(*goodfps));

        dmxLog(dmxError,
               "The DMX server failed to set the following font paths on "
               "screen #%d:\n", pScreen->myNum);

        for (i = 0; i < npaths; i++)
            if (!(goodfps[i] = dmxCheckFontPathElement(dmxScreen, fp[i])))
                dmxLog(dmxError, "    %s\n", fp[i]);

        if (dmxIgnoreBadFontPaths) {
            char *newfp;
            int newnpaths = 0;
            int len = 0;
            int j = 0;

            dmxLog(dmxError,
                   "These font paths will not be used because the "
                   "\"-ignorebadfontpaths\"\n");
            dmxLog(dmxError, "option is set.\n");

            for (i = 0; i < npaths; i++)
                if (goodfps[i]) {
                    len += strlen(fp[i]) + 1;
                    newnpaths++;
                }

            if (!newnpaths) {
                /* No valid font paths were found */
                dmxLog(dmxError,
                       "After removing the font paths above, no valid font "
                       "paths were\n");
                dmxLog(dmxError,
                       "available.  Please check that the font paths set on "
                       "the command\n");
                dmxLog(dmxError,
                       "line or in the configuration file via the "
                       "\"-fontpath\" option\n");
                dmxLog(dmxError,
                       "are valid on all back-end servers.  See the Xdmx man "
                       "page for\n");
                dmxLog(dmxError, "more information on font paths.\n");
                dmxFreeFontPath(fp);
                XFreeFontPath(oldFontPath);
                free(goodfps);
                return FALSE;
            }

            newfp = xallocarray(len, sizeof(*newfp));
            for (i = 0; i < npaths; i++) {
                if (goodfps[i]) {
                    int n = strlen(fp[i]);

                    newfp[j++] = n;
                    strncpy(&newfp[j], fp[i], n);
                    j += n;
                }
            }

            if (SetFontPath(serverClient, newnpaths, (unsigned char *) newfp)) {
                /* Note that this should never happen since all of the
                 * FPEs were previously valid. */
                dmxLog(dmxError, "Cannot reset the default font path.\n");
            }
        }
        else if (dmxFontPath) {
            dmxLog(dmxError,
                   "Please remove these font paths from the command line "
                   "or\n");
            dmxLog(dmxError,
                   "configuration file, or set the \"-ignorebadfontpaths\" "
                   "option to\n");
            dmxLog(dmxError,
                   "ignore them.  For more information on these options, see "
                   "the\n");
            dmxLog(dmxError, "Xdmx man page.\n");
        }
        else {
            dmxLog(dmxError,
                   "Please specify the font paths that are available on all "
                   "back-end\n");
            dmxLog(dmxError,
                   "servers with the \"-fontpath\" option, or use the "
                   "\"-ignorebadfontpaths\"\n");
            dmxLog(dmxError,
                   "to ignore bad defaults.  For more information on "
                   "these and other\n");
            dmxLog(dmxError,
                   "font-path-related options, see the Xdmx man page.\n");
        }

        free(goodfps);
        if (!dmxIgnoreBadFontPaths ||
            (dmxIgnoreBadFontPaths && dmxSetFontPath(dmxScreen))) {
            /* We still have errors so return with error */
            dmxFreeFontPath(fp);
            XFreeFontPath(oldFontPath);
            return FALSE;
        }
    }

    /* Find requested font on back-end server */
    name_atom = MakeAtom("FONT", 4, TRUE);
    value_atom = 0L;

    for (i = 0; i < pFont->info.nprops; i++) {
        if ((Atom) pFont->info.props[i].name == name_atom) {
            value_atom = pFont->info.props[i].value;
            break;
        }
    }
    if (!value_atom)
        return FALSE;

    name = NameForAtom(value_atom);
    if (!name)
        return FALSE;

    pFontPriv->font[pScreen->myNum] =
        XLoadQueryFont(dmxScreen->beDisplay, name);

    /* Restore old font path */
    XSetFontPath(dmxScreen->beDisplay, oldFontPath, nOldPaths);
    XFreeFontPath(oldFontPath);
    dmxSync(dmxScreen, FALSE);

    if (!pFontPriv->font[pScreen->myNum])
        return FALSE;

    return TRUE;
}

/** Realize the font, \a pFont, on the back-end server associated with
 *  \a pScreen. */
Bool
dmxRealizeFont(ScreenPtr pScreen, FontPtr pFont)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxFontPrivPtr pFontPriv;

    if (!(pFontPriv = FontGetPrivate(pFont, dmxFontPrivateIndex))) {
        FontSetPrivate(pFont, dmxFontPrivateIndex, NULL);
        pFontPriv = malloc(sizeof(dmxFontPrivRec));
        if (!pFontPriv)
            return FALSE;
        pFontPriv->font = NULL;
        MAXSCREENSALLOC(pFontPriv->font);
        if (!pFontPriv->font) {
            free(pFontPriv);
            return FALSE;
        }
        pFontPriv->refcnt = 0;
    }

    FontSetPrivate(pFont, dmxFontPrivateIndex, (void *) pFontPriv);

    if (dmxScreen->beDisplay) {
        if (!dmxBELoadFont(pScreen, pFont))
            return FALSE;

        pFontPriv->refcnt++;
    }
    else {
        pFontPriv->font[pScreen->myNum] = NULL;
    }

    return TRUE;
}

/** Free \a pFont on the back-end associated with \a pScreen. */
Bool
dmxBEFreeFont(ScreenPtr pScreen, FontPtr pFont)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxFontPrivPtr pFontPriv = FontGetPrivate(pFont, dmxFontPrivateIndex);

    if (pFontPriv && pFontPriv->font[pScreen->myNum]) {
        XFreeFont(dmxScreen->beDisplay, pFontPriv->font[pScreen->myNum]);
        pFontPriv->font[pScreen->myNum] = NULL;
        return TRUE;
    }

    return FALSE;
}

/** Unrealize the font, \a pFont, on the back-end server associated with
 *  \a pScreen. */
Bool
dmxUnrealizeFont(ScreenPtr pScreen, FontPtr pFont)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxFontPrivPtr pFontPriv;

    if ((pFontPriv = FontGetPrivate(pFont, dmxFontPrivateIndex))) {
        /* In case the font failed to load properly */
        if (!pFontPriv->refcnt) {
            MAXSCREENSFREE(pFontPriv->font);
            free(pFontPriv);
            FontSetPrivate(pFont, dmxFontPrivateIndex, NULL);
        }
        else if (pFontPriv->font[pScreen->myNum]) {
            if (dmxScreen->beDisplay)
                dmxBEFreeFont(pScreen, pFont);

            /* The code below is non-obvious, so here's an explanation...
             *
             * When creating the default GC, the server opens up the
             * default font once for each screen, which in turn calls
             * the RealizeFont function pointer once for each screen.
             * During this process both dix's font refcnt and DMX's font
             * refcnt are incremented once for each screen.
             *
             * Later, when shutting down the X server, dix shuts down
             * each screen in reverse order.  During this shutdown
             * procedure, each screen's default GC is freed and then
             * that screen is closed by calling the CloseScreen function
             * pointer.  screenInfo.numScreens is then decremented after
             * closing each screen.  This procedure means that the dix's
             * font refcnt for the font used by the default GC's is
             * decremented once for each screen # greater than 0.
             * However, since dix's refcnt for the default font is not
             * yet 0 for each screen greater than 0, no call to the
             * UnrealizeFont function pointer is made for those screens.
             * Then, when screen 0 is being closed, dix's font refcnt
             * for the default GC's font is finally 0 and the font is
             * unrealized.  However, since screenInfo.numScreens has
             * been decremented already down to 1, only one call to
             * UnrealizeFont is made (for screen 0).  Thus, even though
             * RealizeFont was called once for each screen,
             * UnrealizeFont is only called for screen 0.
             *
             * This is a bug in dix.
             *
             * To avoid the memory leak of pFontPriv for each server
             * generation, we can also free pFontPriv if the refcnt is
             * not yet 0 but the # of screens is 1 -- i.e., the case
             * described in the dix bug above.  This is only a temporary
             * workaround until the bug in dix is solved.
             *
             * The other problem is that the font structure allocated by
             * XLoadQueryFont() above is not freed for screens > 0.
             * This problem cannot be worked around here since the back-
             * end displays for screens > 0 have already been closed by
             * the time this code is called from dix.
             *
             * When the bug in dix described above is fixed, then we can
             * remove the "|| screenInfo.numScreens == 1" code below and
             * the memory leaks will be eliminated.
             */
            if (--pFontPriv->refcnt == 0
#if 1
                /* Remove this code when the dix bug is fixed */
                || screenInfo.numScreens == 1
#endif
                ) {
                MAXSCREENSFREE(pFontPriv->font);
                free(pFontPriv);
                FontSetPrivate(pFont, dmxFontPrivateIndex, NULL);
            }
        }
    }

    return TRUE;
}
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d75 1
a75 1
    fp = malloc(*npaths * sizeof(*fp));
d309 1
a309 1
        goodfps = malloc(npaths * sizeof(*goodfps));
d357 1
a357 1
            newfp = malloc(len * sizeof(*newfp));
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d400 1
a405 1
            free(goodfps);
d463 1
a463 1
    FontSetPrivate(pFont, dmxFontPrivateIndex, (pointer) pFontPriv);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d52 2
a53 2
static int (*dmxSaveProcVector[256])(ClientPtr);
static int   dmxFontLastError;
d55 2
a56 1
static int dmxFontErrorHandler(Display *dpy, XErrorEvent *ev)
d63 2
a64 1
static char **dmxGetFontPath(int *npaths)
d66 4
a69 4
    char          **fp;
    unsigned char  *c, *paths;
    char           *newfp;
    int             len, l, i;
d74 1
a74 1
    c = (unsigned char *)newfp;
d77 1
a77 1
    memmove(newfp, paths+1, *npaths + len - 1);
d80 4
a83 4
	fp[i] = (char *)c;
	c += l;
	l = *c;
	*c++ = '\0';
d94 2
a95 1
static void dmxFreeFontPath(char **fp)
d101 2
a102 1
static Bool dmxCheckFontPathElement(DMXScreenInfo *dmxScreen, char *fp)
d104 1
a104 1
    int  (*oldErrorHandler)(Display *, XErrorEvent *);
d107 1
a107 1
	return TRUE;
d118 2
a119 1
static int dmxSetFontPath(DMXScreenInfo *dmxScreen)
d121 1
a121 1
    int  (*oldErrorHandler)(Display *, XErrorEvent *);
d123 2
a124 2
    int    result = Success;
    int    npaths;
d127 1
a127 1
	return result;
d130 2
a131 1
    if (!fp) return BadAlloc;
d140 6
a145 6
	result = dmxFontLastError;
	/* We could set *error here to the offending path, but it is
	 * ignored, so we don't bother figuring out which path is bad.
	 * If we do add this support in the future, we'll need to add
	 * error to the function's argument list.
	 */
d153 2
a154 1
static int dmxCheckFontPath(DMXScreenInfo *dmxScreen, int *error)
d157 2
a158 2
    int    nOldPaths;
    int    result = Success;
d161 1
a161 1
	return result;
d176 2
a177 1
static int dmxProcSetFontPath(ClientPtr client)
d180 3
a182 3
    unsigned long  nbytes, total, n;
    long           nfonts;
    int            i, result;
d184 3
a186 2
    int            nOldPaths;
    int            lenOldPaths;
d188 1
a188 1
    
d190 1
a190 1
    
d193 1
a193 1
    ptr = (unsigned char *)&stuff[1];
d197 4
a200 4
	if ((total == 0) || (total < (n = (*ptr + 1))))
	    return BadLength;
	total -= n;
	ptr += n;
d209 1
a209 1
    result = SetFontPath(client, stuff->nFonts, (unsigned char *)&stuff[1]);
d211 11
a221 10
	int error = 0;
	for (i = 0; i < dmxNumScreens; i++)
	    if ((result = dmxCheckFontPath(&dmxScreens[i], &error)))
		break;

	if (result) {
	    /* Restore old fontpath in the DMX server */
	    SetFontPath(client, nOldPaths, oldFontPath);
	    client->errorValue = error;
	}
d232 2
a233 1
void dmxInitFonts(void)
d235 1
a235 1
    int  i;
d238 1
a238 1
	dmxSaveProcVector[i] = ProcVector[i];
d245 2
a246 1
void dmxResetFonts(void)
d248 1
a248 1
    int  i;
d251 1
a251 1
	ProcVector[i] = dmxSaveProcVector[i];
d258 2
a259 1
Bool dmxBELoadFont(ScreenPtr pScreen, FontPtr pFont)
d261 7
a267 7
    DMXScreenInfo  *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxFontPrivPtr  pFontPriv = FontGetPrivate(pFont, dmxFontPrivateIndex);
    const char     *name;
    char          **oldFontPath = NULL;
    int             nOldPaths;
    Atom            name_atom, value_atom;
    int             i;
d271 1
a271 1
	return FALSE;
d275 1
a275 1
	return TRUE; /* Already loaded font */
d283 109
a391 110
	char **fp;
	int    npaths;
	Bool  *goodfps;

	/* This could fail only when first starting the X server and
	 * loading the default font.  If it fails here, then the default
	 * font path is invalid, no default font path will be set, the
	 * DMX server will fail to load the default font, and it will
	 * exit with an error unless we remove the offending font paths
	 * with the -ignorebadfontpaths command line option.
	 */

	fp = dmxGetFontPath(&npaths);
	if (!fp) {
	    dmxLog(dmxError,
		   "No default font path set.\n");
	    dmxLog(dmxError,
		   "Please see the Xdmx man page for information on how to\n");
	    dmxLog(dmxError,
		   "initialize the DMX server's default font path.\n");
	    XFreeFontPath(oldFontPath);
	    return FALSE;
	}

	if (!dmxFontPath)
	    dmxLog(dmxWarning, "No default font path is set.\n");

	goodfps = malloc(npaths * sizeof(*goodfps));

	dmxLog(dmxError,
	       "The DMX server failed to set the following font paths on "
	       "screen #%d:\n", pScreen->myNum);
	
	for (i = 0; i < npaths; i++)
	    if (!(goodfps[i] = dmxCheckFontPathElement(dmxScreen, fp[i])))
		dmxLog(dmxError, "    %s\n", fp[i]);

	if (dmxIgnoreBadFontPaths) {
	    char *newfp;
	    int   newnpaths = 0;
	    int   len = 0;
	    int   j = 0;

	    dmxLog(dmxError,
		   "These font paths will not be used because the "
		   "\"-ignorebadfontpaths\"\n");
	    dmxLog(dmxError,
		   "option is set.\n");

	    for (i = 0; i < npaths; i++)
		if (goodfps[i]) {
		    len += strlen(fp[i]) + 1;
		    newnpaths++;
		}

	    if (!newnpaths) {
		/* No valid font paths were found */
		dmxLog(dmxError,
		       "After removing the font paths above, no valid font "
		       "paths were\n");
		dmxLog(dmxError,
		       "available.  Please check that the font paths set on "
		       "the command\n");
		dmxLog(dmxError,
		       "line or in the configuration file via the "
		       "\"-fontpath\" option\n");
		dmxLog(dmxError,
		       "are valid on all back-end servers.  See the Xdmx man "
		       "page for\n");
		dmxLog(dmxError,
		       "more information on font paths.\n");
		dmxFreeFontPath(fp);
		XFreeFontPath(oldFontPath);
		free(goodfps);
		return FALSE;
	    }

	    newfp = malloc(len * sizeof(*newfp));
	    for (i = 0; i < npaths; i++) {
		if (goodfps[i]) {
		    int n = strlen(fp[i]);
		    newfp[j++] = n;
		    strncpy(&newfp[j], fp[i], n);
		    j += n;
		}
	    }

	    if (SetFontPath(serverClient, newnpaths, (unsigned char *)newfp)) {
		/* Note that this should never happen since all of the
		 * FPEs were previously valid. */
		dmxLog(dmxError, "Cannot reset the default font path.\n");
	    }
	} else if (dmxFontPath) {
	    dmxLog(dmxError,
		   "Please remove these font paths from the command line "
		   "or\n");
	    dmxLog(dmxError,
		   "configuration file, or set the \"-ignorebadfontpaths\" "
		   "option to\n");
	    dmxLog(dmxError,
		   "ignore them.  For more information on these options, see "
		   "the\n");
	    dmxLog(dmxError,
		   "Xdmx man page.\n");
	} else {
	    dmxLog(dmxError,
		   "Please specify the font paths that are available on all "
		   "back-end\n");
	    dmxLog(dmxError,
		   "servers with the \"-fontpath\" option, or use the "
d396 12
a407 12
	    dmxLog(dmxError,
		   "font-path-related options, see the Xdmx man page.\n");
	}

	if (!dmxIgnoreBadFontPaths ||
	    (dmxIgnoreBadFontPaths && dmxSetFontPath(dmxScreen))) {
	    /* We still have errors so return with error */
	    dmxFreeFontPath(fp);
	    XFreeFontPath(oldFontPath);
	    free(goodfps);
	    return FALSE;
	}
d415 4
a418 4
	if ((Atom)pFont->info.props[i].name == name_atom) {
	    value_atom = pFont->info.props[i].value;
	    break;
	}
d420 2
a421 1
    if (!value_atom) return FALSE;
d424 2
a425 1
    if (!name) return FALSE;
d427 2
a428 2
    pFontPriv->font[pScreen->myNum] = 
	XLoadQueryFont(dmxScreen->beDisplay, name);
d435 2
a436 1
    if (!pFontPriv->font[pScreen->myNum]) return FALSE;
d443 2
a444 1
Bool dmxRealizeFont(ScreenPtr pScreen, FontPtr pFont)
d446 2
a447 2
    DMXScreenInfo  *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxFontPrivPtr  pFontPriv;
d450 4
a453 3
	FontSetPrivate(pFont, dmxFontPrivateIndex, NULL);
	pFontPriv = malloc(sizeof(dmxFontPrivRec));
	if (!pFontPriv) return FALSE;
d460 1
a460 1
	pFontPriv->refcnt = 0;
d463 1
a463 1
    FontSetPrivate(pFont, dmxFontPrivateIndex, (pointer)pFontPriv);
d466 2
a467 2
	if (!dmxBELoadFont(pScreen, pFont))
	    return FALSE;
d469 4
a472 3
	pFontPriv->refcnt++;
    } else {
	pFontPriv->font[pScreen->myNum] = NULL;
d479 2
a480 1
Bool dmxBEFreeFont(ScreenPtr pScreen, FontPtr pFont)
d482 2
a483 2
    DMXScreenInfo  *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxFontPrivPtr  pFontPriv = FontGetPrivate(pFont, dmxFontPrivateIndex);
d486 3
a488 3
	XFreeFont(dmxScreen->beDisplay, pFontPriv->font[pScreen->myNum]);
	pFontPriv->font[pScreen->myNum] = NULL;
	return TRUE;
d496 2
a497 1
Bool dmxUnrealizeFont(ScreenPtr pScreen, FontPtr pFont)
d499 2
a500 2
    DMXScreenInfo  *dmxScreen = &dmxScreens[pScreen->myNum];
    dmxFontPrivPtr  pFontPriv;
d503 2
a504 2
	/* In case the font failed to load properly */
	if (!pFontPriv->refcnt) {
d506 53
a558 52
	    free(pFontPriv);
	    FontSetPrivate(pFont, dmxFontPrivateIndex, NULL);
	} else if (pFontPriv->font[pScreen->myNum]) {
	    if (dmxScreen->beDisplay)
		dmxBEFreeFont(pScreen, pFont);

	    /* The code below is non-obvious, so here's an explanation...
	     *
	     * When creating the default GC, the server opens up the
	     * default font once for each screen, which in turn calls
	     * the RealizeFont function pointer once for each screen.
	     * During this process both dix's font refcnt and DMX's font
	     * refcnt are incremented once for each screen.
	     *
	     * Later, when shutting down the X server, dix shuts down
	     * each screen in reverse order.  During this shutdown
	     * procedure, each screen's default GC is freed and then
	     * that screen is closed by calling the CloseScreen function
	     * pointer.  screenInfo.numScreens is then decremented after
	     * closing each screen.  This procedure means that the dix's
	     * font refcnt for the font used by the default GC's is
	     * decremented once for each screen # greater than 0.
	     * However, since dix's refcnt for the default font is not
	     * yet 0 for each screen greater than 0, no call to the
	     * UnrealizeFont function pointer is made for those screens.
	     * Then, when screen 0 is being closed, dix's font refcnt
	     * for the default GC's font is finally 0 and the font is
	     * unrealized.  However, since screenInfo.numScreens has
	     * been decremented already down to 1, only one call to
	     * UnrealizeFont is made (for screen 0).  Thus, even though
	     * RealizeFont was called once for each screen,
	     * UnrealizeFont is only called for screen 0.
	     *
	     * This is a bug in dix.
	     *
	     * To avoid the memory leak of pFontPriv for each server
	     * generation, we can also free pFontPriv if the refcnt is
	     * not yet 0 but the # of screens is 1 -- i.e., the case
	     * described in the dix bug above.  This is only a temporary
	     * workaround until the bug in dix is solved.
	     *
	     * The other problem is that the font structure allocated by
	     * XLoadQueryFont() above is not freed for screens > 0.
	     * This problem cannot be worked around here since the back-
	     * end displays for screens > 0 have already been closed by
	     * the time this code is called from dix.
	     *
	     * When the bug in dix described above is fixed, then we can
	     * remove the "|| screenInfo.numScreens == 1" code below and
	     * the memory leaks will be eliminated.
	     */
	    if (--pFontPriv->refcnt == 0
d560 2
a561 2
		/* Remove this code when the dix bug is fixed */
		|| screenInfo.numScreens == 1
d563 1
a563 1
		) {
d565 4
a568 4
		free(pFontPriv);
		FontSetPrivate(pFont, dmxFontPrivateIndex, NULL);
	    }
	}
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d71 1
a71 1
    newfp = xalloc(*npaths + len);
d73 1
a73 1
    fp = xalloc(*npaths * sizeof(*fp));
d94 2
a95 2
    xfree(fp[0]);
    xfree(fp);
d111 1
a111 1
    return (dmxFontLastError == 0);
a174 1
    int            error;
d197 1
a197 1
    oldFontPath = xalloc(nOldPaths + lenOldPaths);
d200 1
a200 2
    result = SetFontPath(client, stuff->nFonts, (unsigned char *)&stuff[1],
			 &error);
d202 1
a207 2
	    int  ignoreresult, ignoreerror;

d209 1
a209 4
	    ignoreresult = SetFontPath(client, nOldPaths, oldFontPath,
				       &ignoreerror);
	} else {
	    result = client->noClientException;
d214 1
a214 1
    xfree(oldFontPath);
d297 1
a297 1
	goodfps = xalloc(npaths * sizeof(*goodfps));
a311 1
	    int   error;
d343 1
a343 1
		xfree(goodfps);
d347 1
a347 1
	    newfp = xalloc(len * sizeof(*newfp));
d357 1
a357 2
	    if (SetFontPath(serverClient, newnpaths, (unsigned char *)newfp,
			    &error)) {
d393 1
a393 1
	    xfree(goodfps);
d435 1
a435 1
	pFontPriv = xalloc(sizeof(dmxFontPrivRec));
d440 1
a440 1
            xfree(pFontPriv);
d486 1
a486 1
	    xfree(pFontPriv);
d544 1
a544 1
		xfree(pFontPriv);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a51 6
#undef Xmalloc
#undef Xcalloc
#undef Xrealloc
#undef Xfree


d256 1
a256 1
    char           *name;
d418 1
a418 1
    name = (char *)NameForAtom(value_atom);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d52 6
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
d69 1
a69 1
    paths = GetFontPath(npaths, &len);
d197 1
a197 1
    tmpFontPath = GetFontPath(&nOldPaths, &lenOldPaths);
d364 2
a365 1
	    if (SetFontPath(NULL, newnpaths, (unsigned char *)newfp, &error)) {
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
@

