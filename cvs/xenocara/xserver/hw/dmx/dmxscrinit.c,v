head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.8
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.6
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	7pAEtF6Y5EgemkuY;

1.9
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.16;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.44;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.44;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.23;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@/*
 * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Kevin E. Martin <kem@@redhat.com>
 *   David H. Dawes <dawes@@xfree86.org>
 *
 */

/** \file
 * This file provides support for screen initialization. */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include "dmx.h"
#include "dmxsync.h"
#include "dmxscrinit.h"
#include "dmxcursor.h"
#include "dmxgc.h"
#include "dmxgcops.h"
#include "dmxwindow.h"
#include "dmxpixmap.h"
#include "dmxfont.h"
#include "dmxcmap.h"
#include "dmxprop.h"
#include "dmxdpms.h"

#include "dmxpict.h"

#include "fb.h"
#include "mipointer.h"
#include "micmap.h"

extern Bool dmxCloseScreen(ScreenPtr pScreen);
static Bool dmxSaveScreen(ScreenPtr pScreen, int what);

static unsigned long dmxGeneration;
static unsigned long *dmxCursorGeneration;

DevPrivateKeyRec dmxGCPrivateKeyRec;
DevPrivateKeyRec dmxWinPrivateKeyRec;
DevPrivateKeyRec dmxPixPrivateKeyRec;
int dmxFontPrivateIndex;        /**< Private index for Fonts     */
DevPrivateKeyRec dmxScreenPrivateKeyRec;
DevPrivateKeyRec dmxColormapPrivateKeyRec;
DevPrivateKeyRec dmxPictPrivateKeyRec;
DevPrivateKeyRec dmxGlyphSetPrivateKeyRec;

/** Initialize the parts of screen \a idx that require access to the
 *  back-end server. */
void
dmxBEScreenInit(ScreenPtr pScreen)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    XSetWindowAttributes attribs;
    unsigned long mask;
    int i, j;

    /* FIXME: The dmxScreenInit() code currently assumes that it will
     * not be called if the Xdmx server is started with this screen
     * detached -- i.e., it assumes that dmxScreen->beDisplay is always
     * valid.  This is not necessarily a valid assumption when full
     * addition/removal of screens is implemented, but when this code is
     * broken out for screen reattachment, then we will reevaluate this
     * assumption.
     */

    pScreen->mmWidth = DisplayWidthMM(dmxScreen->beDisplay,
                                      DefaultScreen(dmxScreen->beDisplay));
    pScreen->mmHeight = DisplayHeightMM(dmxScreen->beDisplay,
                                        DefaultScreen(dmxScreen->beDisplay));

    pScreen->whitePixel = dmxScreen->beWhitePixel;
    pScreen->blackPixel = dmxScreen->beBlackPixel;

    /* Handle screen savers and DPMS on the backend */
    dmxDPMSInit(dmxScreen);

    /* Create root window for screen */
    mask = CWBackPixel | CWEventMask | CWColormap | CWOverrideRedirect;
    attribs.background_pixel = dmxScreen->beBlackPixel;
    attribs.event_mask = (KeyPressMask
                          | KeyReleaseMask
                          | ButtonPressMask
                          | ButtonReleaseMask
                          | EnterWindowMask
                          | LeaveWindowMask
                          | PointerMotionMask
                          | KeymapStateMask | FocusChangeMask);
    attribs.colormap = dmxScreen->beDefColormaps[dmxScreen->beDefVisualIndex];
    attribs.override_redirect = True;

    dmxScreen->scrnWin =
        XCreateWindow(dmxScreen->beDisplay,
                      DefaultRootWindow(dmxScreen->beDisplay),
                      dmxScreen->scrnX,
                      dmxScreen->scrnY,
                      dmxScreen->scrnWidth,
                      dmxScreen->scrnHeight,
                      0,
                      pScreen->rootDepth,
                      InputOutput,
                      dmxScreen->beVisuals[dmxScreen->beDefVisualIndex].visual,
                      mask, &attribs);
    dmxPropertyWindow(dmxScreen);

    /*
     * This turns off the cursor by defining a cursor with no visible
     * components.
     */
    {
        char noCursorData[] = { 0, 0, 0, 0,
            0, 0, 0, 0
        };
        Pixmap pixmap;
        XColor color, tmp;

        pixmap = XCreateBitmapFromData(dmxScreen->beDisplay, dmxScreen->scrnWin,
                                       noCursorData, 8, 8);
        XAllocNamedColor(dmxScreen->beDisplay, dmxScreen->beDefColormaps[0],
                         "black", &color, &tmp);
        dmxScreen->noCursor = XCreatePixmapCursor(dmxScreen->beDisplay,
                                                  pixmap, pixmap,
                                                  &color, &color, 0, 0);
        XDefineCursor(dmxScreen->beDisplay, dmxScreen->scrnWin,
                      dmxScreen->noCursor);

        XFreePixmap(dmxScreen->beDisplay, pixmap);
    }

    XMapWindow(dmxScreen->beDisplay, dmxScreen->scrnWin);

    /* Create default drawables (used during GC creation) */
    for (i = 0; i < dmxScreen->beNumPixmapFormats; i++)
	for (j = 0; j < dmxScreen->beNumDepths; j++)
	    if ((dmxScreen->bePixmapFormats[i].depth == 1) ||
		(dmxScreen->bePixmapFormats[i].depth ==
		 dmxScreen->beDepths[j])) {
		dmxScreen->scrnDefDrawables[i] = (Drawable)
		    XCreatePixmap(dmxScreen->beDisplay, dmxScreen->scrnWin,
				  1, 1,
				  dmxScreen->bePixmapFormats[i].depth);
		break;
	    }
}

/** Initialize screen number \a pScreen->myNum. */
Bool
dmxScreenInit(ScreenPtr pScreen, int argc, char *argv[])
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    int i, j;

    if (!dixRegisterPrivateKey(&dmxScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;
    if (!dixRegisterPrivateKey(&dmxColormapPrivateKeyRec, PRIVATE_COLORMAP, 0))
        return FALSE;
    if (!dixRegisterPrivateKey(&dmxGlyphSetPrivateKeyRec, PRIVATE_GLYPHSET, 0))
        return FALSE;

    if (dmxGeneration != serverGeneration) {
        /* Allocate font private index */
        dmxFontPrivateIndex = AllocateFontPrivateIndex();
        if (dmxFontPrivateIndex == -1)
            return FALSE;

        dmxGeneration = serverGeneration;
    }

    if (!dmxInitGC(pScreen))
	return FALSE;
    if (!dmxInitWindow(pScreen))
	return FALSE;
    if (!dmxInitPixmap(pScreen))
	return FALSE;

    /*
     * Initalise the visual types.  miSetVisualTypesAndMasks() requires
     * that all of the types for each depth be collected together.  It's
     * intended for slightly different usage to what we would like here.
     * Maybe a miAddVisualTypeAndMask() function will be added to make
     * things easier here.
     */
    for (i = 0; i < dmxScreen->beNumDepths; i++) {
        int depth;
        int visuals = 0;
        int bitsPerRgb = 0;
        int preferredClass = -1;
        Pixel redMask = 0;
        Pixel greenMask = 0;
        Pixel blueMask = 0;

        depth = dmxScreen->beDepths[i];
        for (j = 0; j < dmxScreen->beNumVisuals; j++) {
            XVisualInfo *vi;

            vi = &dmxScreen->beVisuals[j];
            if (vi->depth == depth) {
                /* Assume the masks are all the same. */
                visuals |= (1 << vi->class);
                bitsPerRgb = vi->bits_per_rgb;
                redMask = vi->red_mask;
                greenMask = vi->green_mask;
                blueMask = vi->blue_mask;
                if (j == dmxScreen->beDefVisualIndex) {
                    preferredClass = vi->class;
                }
            }
        }
        miSetVisualTypesAndMasks(depth, visuals, bitsPerRgb, preferredClass,
                                 redMask, greenMask, blueMask);
    }

    fbScreenInit(pScreen,
                 NULL,
                 dmxScreen->scrnWidth,
                 dmxScreen->scrnHeight,
                 dmxScreen->beXDPI,
                 dmxScreen->beXDPI, dmxScreen->scrnWidth, dmxScreen->beBPP);
    (void) dmxPictureInit(pScreen, 0, 0);

    /* Not yet... */
    pScreen->GetWindowPixmap = NULL;
    pScreen->SetWindowPixmap = NULL;

    MAXSCREENSALLOC(dmxCursorGeneration);
    if (dmxCursorGeneration[pScreen->myNum] != serverGeneration) {
	if (!(miPointerInitialize(pScreen,
				  &dmxPointerSpriteFuncs,
				  &dmxPointerCursorFuncs, FALSE)))
	    return FALSE;

	dmxCursorGeneration[pScreen->myNum] = serverGeneration;
    }

    DMX_WRAP(CloseScreen, dmxCloseScreen, dmxScreen, pScreen);
    DMX_WRAP(SaveScreen, dmxSaveScreen, dmxScreen, pScreen);

    dmxBEScreenInit(pScreen);

    /* Wrap GC functions */
    DMX_WRAP(CreateGC, dmxCreateGC, dmxScreen, pScreen);

    /* Wrap Window functions */
    DMX_WRAP(CreateWindow, dmxCreateWindow, dmxScreen, pScreen);
    DMX_WRAP(DestroyWindow, dmxDestroyWindow, dmxScreen, pScreen);
    DMX_WRAP(PositionWindow, dmxPositionWindow, dmxScreen, pScreen);
    DMX_WRAP(ChangeWindowAttributes, dmxChangeWindowAttributes, dmxScreen,
	     pScreen);
    DMX_WRAP(RealizeWindow, dmxRealizeWindow, dmxScreen, pScreen);
    DMX_WRAP(UnrealizeWindow, dmxUnrealizeWindow, dmxScreen, pScreen);
    DMX_WRAP(RestackWindow, dmxRestackWindow, dmxScreen, pScreen);
    DMX_WRAP(WindowExposures, dmxWindowExposures, dmxScreen, pScreen);
    DMX_WRAP(CopyWindow, dmxCopyWindow, dmxScreen, pScreen);

    DMX_WRAP(ResizeWindow, dmxResizeWindow, dmxScreen, pScreen);
    DMX_WRAP(ReparentWindow, dmxReparentWindow, dmxScreen, pScreen);

    DMX_WRAP(ChangeBorderWidth, dmxChangeBorderWidth, dmxScreen, pScreen);

    /* Wrap Image functions */
    DMX_WRAP(GetImage, dmxGetImage, dmxScreen, pScreen);
    DMX_WRAP(GetSpans, dmxGetSpans, dmxScreen, pScreen);

    /* Wrap Pixmap functions */
    DMX_WRAP(CreatePixmap, dmxCreatePixmap, dmxScreen, pScreen);
    DMX_WRAP(DestroyPixmap, dmxDestroyPixmap, dmxScreen, pScreen);
    DMX_WRAP(BitmapToRegion, dmxBitmapToRegion, dmxScreen, pScreen);

    /* Wrap Font functions */
    DMX_WRAP(RealizeFont, dmxRealizeFont, dmxScreen, pScreen);
    DMX_WRAP(UnrealizeFont, dmxUnrealizeFont, dmxScreen, pScreen);

    /* Wrap Colormap functions */
    DMX_WRAP(CreateColormap, dmxCreateColormap, dmxScreen, pScreen);
    DMX_WRAP(DestroyColormap, dmxDestroyColormap, dmxScreen, pScreen);
    DMX_WRAP(InstallColormap, dmxInstallColormap, dmxScreen, pScreen);
    DMX_WRAP(StoreColors, dmxStoreColors, dmxScreen, pScreen);

    /* Wrap Shape functions */
    DMX_WRAP(SetShape, dmxSetShape, dmxScreen, pScreen);

    if (!dmxCreateDefColormap(pScreen))
        return FALSE;

    return TRUE;
}

/** Close the \a pScreen resources on the back-end server. */
void
dmxBECloseScreen(ScreenPtr pScreen)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];
    int i;

    /* Restore the back-end screen-saver and DPMS state. */
    dmxDPMSTerm(dmxScreen);

    /* Free the screen resources */

    XFreeCursor(dmxScreen->beDisplay, dmxScreen->noCursor);
    dmxScreen->noCursor = (Cursor) 0;

    XUnmapWindow(dmxScreen->beDisplay, dmxScreen->scrnWin);
    XDestroyWindow(dmxScreen->beDisplay, dmxScreen->scrnWin);
    dmxScreen->scrnWin = (Window) 0;

    /* Free the default drawables */
    for (i = 0; i < dmxScreen->beNumPixmapFormats; i++) {
	if (dmxScreen->scrnDefDrawables[i]) {
	    XFreePixmap(dmxScreen->beDisplay,
			dmxScreen->scrnDefDrawables[i]);
	    dmxScreen->scrnDefDrawables[i] = (Drawable) 0;
	}
    }

    /* Free resources allocated during initialization (in dmxinit.c) */
    for (i = 0; i < dmxScreen->beNumDefColormaps; i++)
        XFreeColormap(dmxScreen->beDisplay, dmxScreen->beDefColormaps[i]);
    free(dmxScreen->beDefColormaps);
    dmxScreen->beDefColormaps = NULL;

#if 0
    /* Do not free visuals, depths and pixmap formats here.  Free them
     * in dmxCloseScreen() instead -- see comment below. */
    XFree(dmxScreen->beVisuals);
    dmxScreen->beVisuals = NULL;

    XFree(dmxScreen->beDepths);
    dmxScreen->beDepths = NULL;

    XFree(dmxScreen->bePixmapFormats);
    dmxScreen->bePixmapFormats = NULL;
#endif

#ifdef GLXEXT
    if (dmxScreen->glxVisuals) {
        XFree(dmxScreen->glxVisuals);
        dmxScreen->glxVisuals = NULL;
        dmxScreen->numGlxVisuals = 0;
    }
#endif

    /* Close display */
    XCloseDisplay(dmxScreen->beDisplay);
    dmxScreen->beDisplay = NULL;
}

/** Close screen number \a idx. */
Bool
dmxCloseScreen(ScreenPtr pScreen)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];

    /* Reset the proc vectors */
    if (pScreen->myNum == 0) {
        dmxResetRender();
        dmxResetFonts();
    }

    /* Unwrap Shape functions */
    DMX_UNWRAP(SetShape, dmxScreen, pScreen);

    /* Unwrap the pScreen functions */
    DMX_UNWRAP(CreateGC, dmxScreen, pScreen);

    DMX_UNWRAP(CreateWindow, dmxScreen, pScreen);
    DMX_UNWRAP(DestroyWindow, dmxScreen, pScreen);
    DMX_UNWRAP(PositionWindow, dmxScreen, pScreen);
    DMX_UNWRAP(ChangeWindowAttributes, dmxScreen, pScreen);
    DMX_UNWRAP(RealizeWindow, dmxScreen, pScreen);
    DMX_UNWRAP(UnrealizeWindow, dmxScreen, pScreen);
    DMX_UNWRAP(RestackWindow, dmxScreen, pScreen);
    DMX_UNWRAP(WindowExposures, dmxScreen, pScreen);
    DMX_UNWRAP(CopyWindow, dmxScreen, pScreen);

    DMX_UNWRAP(ResizeWindow, dmxScreen, pScreen);
    DMX_UNWRAP(ReparentWindow, dmxScreen, pScreen);

    DMX_UNWRAP(ChangeBorderWidth, dmxScreen, pScreen);

    DMX_UNWRAP(GetImage, dmxScreen, pScreen);
    DMX_UNWRAP(GetSpans, dmxScreen, pScreen);

    DMX_UNWRAP(CreatePixmap, dmxScreen, pScreen);
    DMX_UNWRAP(DestroyPixmap, dmxScreen, pScreen);
    DMX_UNWRAP(BitmapToRegion, dmxScreen, pScreen);

    DMX_UNWRAP(RealizeFont, dmxScreen, pScreen);
    DMX_UNWRAP(UnrealizeFont, dmxScreen, pScreen);

    DMX_UNWRAP(CreateColormap, dmxScreen, pScreen);
    DMX_UNWRAP(DestroyColormap, dmxScreen, pScreen);
    DMX_UNWRAP(InstallColormap, dmxScreen, pScreen);
    DMX_UNWRAP(StoreColors, dmxScreen, pScreen);

    DMX_UNWRAP(SaveScreen, dmxScreen, pScreen);

    if (dmxScreen->beDisplay) {
        dmxBECloseScreen(pScreen);

#if 1
        /* Free visuals, depths and pixmap formats here so that they
         * won't be freed when a screen is detached, thereby allowing
         * the screen to be reattached to be compared to the one
         * previously removed.
         */
        XFree(dmxScreen->beVisuals);
        dmxScreen->beVisuals = NULL;

        XFree(dmxScreen->beDepths);
        dmxScreen->beDepths = NULL;

        XFree(dmxScreen->bePixmapFormats);
        dmxScreen->bePixmapFormats = NULL;
#endif
    }

    DMX_UNWRAP(CloseScreen, dmxScreen, pScreen);
    return pScreen->CloseScreen(pScreen);
}

static Bool
dmxSaveScreen(ScreenPtr pScreen, int what)
{
    DMXScreenInfo *dmxScreen = &dmxScreens[pScreen->myNum];

    if (dmxScreen->beDisplay) {
        switch (what) {
        case SCREEN_SAVER_OFF:
        case SCREEN_SAVER_FORCER:
            XResetScreenSaver(dmxScreen->beDisplay);
            dmxSync(dmxScreen, FALSE);
            break;
        case SCREEN_SAVER_ON:
        case SCREEN_SAVER_CYCLE:
            XActivateScreenSaver(dmxScreen->beDisplay);
            dmxSync(dmxScreen, FALSE);
            break;
        }
    }

    return TRUE;
}
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a82 1
    XGCValues gcvals;
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a43 1
#include "dmxshadow.h"
d161 12
a172 31
    if (dmxShadowFB) {
        mask = (GCFunction | GCPlaneMask | GCClipMask);
        gcvals.function = GXcopy;
        gcvals.plane_mask = AllPlanes;
        gcvals.clip_mask = None;

        dmxScreen->shadowGC = XCreateGC(dmxScreen->beDisplay,
                                        dmxScreen->scrnWin, mask, &gcvals);

        dmxScreen->shadowFBImage =
            XCreateImage(dmxScreen->beDisplay,
                         dmxScreen->beVisuals[dmxScreen->beDefVisualIndex].
                         visual, dmxScreen->beDepth, ZPixmap, 0,
                         (char *) dmxScreen->shadow, dmxScreen->scrnWidth,
                         dmxScreen->scrnHeight, dmxScreen->beBPP,
                         PixmapBytePad(dmxScreen->scrnWidth, dmxScreen->beBPP));
    }
    else {
        /* Create default drawables (used during GC creation) */
        for (i = 0; i < dmxScreen->beNumPixmapFormats; i++)
            for (j = 0; j < dmxScreen->beNumDepths; j++)
                if ((dmxScreen->bePixmapFormats[i].depth == 1) ||
                    (dmxScreen->bePixmapFormats[i].depth ==
                     dmxScreen->beDepths[j])) {
                    dmxScreen->scrnDefDrawables[i] = (Drawable)
                        XCreatePixmap(dmxScreen->beDisplay, dmxScreen->scrnWin,
                                      1, 1,
                                      dmxScreen->bePixmapFormats[i].depth);
                    break;
                }
    }
d198 6
a203 13
    if (dmxShadowFB) {
        dmxScreen->shadow = shadowAlloc(dmxScreen->scrnWidth,
                                        dmxScreen->scrnHeight,
                                        dmxScreen->beBPP);
    }
    else {
        if (!dmxInitGC(pScreen))
            return FALSE;
        if (!dmxInitWindow(pScreen))
            return FALSE;
        if (!dmxInitPixmap(pScreen))
            return FALSE;
    }
d243 1
a243 1
                 dmxShadowFB ? dmxScreen->shadow : NULL,
d254 6
a259 13
    if (dmxShadowFB && !shadowInit(pScreen, dmxShadowUpdateProc, NULL))
        return FALSE;

    if (dmxShadowFB) {
        miDCInitialize(pScreen, &dmxPointerCursorFuncs);
    }
    else {
        MAXSCREENSALLOC(dmxCursorGeneration);
        if (dmxCursorGeneration[pScreen->myNum] != serverGeneration) {
            if (!(miPointerInitialize(pScreen,
                                      &dmxPointerSpriteFuncs,
                                      &dmxPointerCursorFuncs, FALSE)))
                return FALSE;
d261 1
a261 2
            dmxCursorGeneration[pScreen->myNum] = serverGeneration;
        }
d269 38
a306 39
    if (!dmxShadowFB) {
        /* Wrap GC functions */
        DMX_WRAP(CreateGC, dmxCreateGC, dmxScreen, pScreen);

        /* Wrap Window functions */
        DMX_WRAP(CreateWindow, dmxCreateWindow, dmxScreen, pScreen);
        DMX_WRAP(DestroyWindow, dmxDestroyWindow, dmxScreen, pScreen);
        DMX_WRAP(PositionWindow, dmxPositionWindow, dmxScreen, pScreen);
        DMX_WRAP(ChangeWindowAttributes, dmxChangeWindowAttributes, dmxScreen,
                 pScreen);
        DMX_WRAP(RealizeWindow, dmxRealizeWindow, dmxScreen, pScreen);
        DMX_WRAP(UnrealizeWindow, dmxUnrealizeWindow, dmxScreen, pScreen);
        DMX_WRAP(RestackWindow, dmxRestackWindow, dmxScreen, pScreen);
        DMX_WRAP(WindowExposures, dmxWindowExposures, dmxScreen, pScreen);
        DMX_WRAP(CopyWindow, dmxCopyWindow, dmxScreen, pScreen);

        DMX_WRAP(ResizeWindow, dmxResizeWindow, dmxScreen, pScreen);
        DMX_WRAP(ReparentWindow, dmxReparentWindow, dmxScreen, pScreen);

        DMX_WRAP(ChangeBorderWidth, dmxChangeBorderWidth, dmxScreen, pScreen);

        /* Wrap Image functions */
        DMX_WRAP(GetImage, dmxGetImage, dmxScreen, pScreen);
        DMX_WRAP(GetSpans, dmxGetSpans, dmxScreen, pScreen);

        /* Wrap Pixmap functions */
        DMX_WRAP(CreatePixmap, dmxCreatePixmap, dmxScreen, pScreen);
        DMX_WRAP(DestroyPixmap, dmxDestroyPixmap, dmxScreen, pScreen);
        DMX_WRAP(BitmapToRegion, dmxBitmapToRegion, dmxScreen, pScreen);

        /* Wrap Font functions */
        DMX_WRAP(RealizeFont, dmxRealizeFont, dmxScreen, pScreen);
        DMX_WRAP(UnrealizeFont, dmxUnrealizeFont, dmxScreen, pScreen);

        /* Wrap Colormap functions */
        DMX_WRAP(CreateColormap, dmxCreateColormap, dmxScreen, pScreen);
        DMX_WRAP(DestroyColormap, dmxDestroyColormap, dmxScreen, pScreen);
        DMX_WRAP(InstallColormap, dmxInstallColormap, dmxScreen, pScreen);
        DMX_WRAP(StoreColors, dmxStoreColors, dmxScreen, pScreen);
d308 2
a309 3
        /* Wrap Shape functions */
        DMX_WRAP(SetShape, dmxSetShape, dmxScreen, pScreen);
    }
d336 7
a342 16
    if (dmxShadowFB) {
        /* Free the shadow GC and image assocated with the back-end server */
        XFreeGC(dmxScreen->beDisplay, dmxScreen->shadowGC);
        dmxScreen->shadowGC = NULL;
        XFree(dmxScreen->shadowFBImage);
        dmxScreen->shadowFBImage = NULL;
    }
    else {
        /* Free the default drawables */
        for (i = 0; i < dmxScreen->beNumPixmapFormats; i++) {
            if (dmxScreen->scrnDefDrawables[i]) {
                XFreePixmap(dmxScreen->beDisplay,
                            dmxScreen->scrnDefDrawables[i]);
                dmxScreen->scrnDefDrawables[i] = (Drawable) 0;
            }
        }
d389 2
a390 5
    if (dmxShadowFB) {
        /* Free the shadow framebuffer */
        free(dmxScreen->shadow);
    }
    else {
d392 2
a393 2
        /* Unwrap Shape functions */
        DMX_UNWRAP(SetShape, dmxScreen, pScreen);
d395 29
a423 33
        /* Unwrap the pScreen functions */
        DMX_UNWRAP(CreateGC, dmxScreen, pScreen);

        DMX_UNWRAP(CreateWindow, dmxScreen, pScreen);
        DMX_UNWRAP(DestroyWindow, dmxScreen, pScreen);
        DMX_UNWRAP(PositionWindow, dmxScreen, pScreen);
        DMX_UNWRAP(ChangeWindowAttributes, dmxScreen, pScreen);
        DMX_UNWRAP(RealizeWindow, dmxScreen, pScreen);
        DMX_UNWRAP(UnrealizeWindow, dmxScreen, pScreen);
        DMX_UNWRAP(RestackWindow, dmxScreen, pScreen);
        DMX_UNWRAP(WindowExposures, dmxScreen, pScreen);
        DMX_UNWRAP(CopyWindow, dmxScreen, pScreen);

        DMX_UNWRAP(ResizeWindow, dmxScreen, pScreen);
        DMX_UNWRAP(ReparentWindow, dmxScreen, pScreen);

        DMX_UNWRAP(ChangeBorderWidth, dmxScreen, pScreen);

        DMX_UNWRAP(GetImage, dmxScreen, pScreen);
        DMX_UNWRAP(GetSpans, dmxScreen, pScreen);

        DMX_UNWRAP(CreatePixmap, dmxScreen, pScreen);
        DMX_UNWRAP(DestroyPixmap, dmxScreen, pScreen);
        DMX_UNWRAP(BitmapToRegion, dmxScreen, pScreen);

        DMX_UNWRAP(RealizeFont, dmxScreen, pScreen);
        DMX_UNWRAP(UnrealizeFont, dmxScreen, pScreen);

        DMX_UNWRAP(CreateColormap, dmxScreen, pScreen);
        DMX_UNWRAP(DestroyColormap, dmxScreen, pScreen);
        DMX_UNWRAP(InstallColormap, dmxScreen, pScreen);
        DMX_UNWRAP(StoreColors, dmxScreen, pScreen);
    }
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d62 1
a62 1
extern Bool dmxCloseScreen(int idx, ScreenPtr pScreen);
d80 1
a80 1
dmxBEScreenInit(int idx, ScreenPtr pScreen)
d82 1
a82 1
    DMXScreenInfo *dmxScreen = &dmxScreens[idx];
d195 1
a195 1
/** Initialize screen number \a idx. */
d197 1
a197 1
dmxScreenInit(int idx, ScreenPtr pScreen, int argc, char *argv[])
d199 1
a199 1
    DMXScreenInfo *dmxScreen = &dmxScreens[idx];
d289 1
a289 1
        if (dmxCursorGeneration[idx] != serverGeneration) {
d295 1
a295 1
            dmxCursorGeneration[idx] = serverGeneration;
d302 1
a302 1
    dmxBEScreenInit(idx, pScreen);
d425 1
a425 1
dmxCloseScreen(int idx, ScreenPtr pScreen)
d427 1
a427 1
    DMXScreenInfo *dmxScreen = &dmxScreens[idx];
d430 1
a430 1
    if (idx == 0) {
d501 1
a501 1
    return pScreen->CloseScreen(idx, pScreen);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d79 2
a80 1
void dmxBEScreenInit(int idx, ScreenPtr pScreen)
d82 5
a86 5
    DMXScreenInfo        *dmxScreen = &dmxScreens[idx];
    XSetWindowAttributes  attribs;
    XGCValues             gcvals;
    unsigned long         mask;
    int                   i, j;
d97 4
a100 4
    pScreen->mmWidth = DisplayWidthMM(dmxScreen->beDisplay, 
				      DefaultScreen(dmxScreen->beDisplay));
    pScreen->mmHeight = DisplayHeightMM(dmxScreen->beDisplay, 
					DefaultScreen(dmxScreen->beDisplay));
d118 1
a118 2
                          | KeymapStateMask
                          | FocusChangeMask);
d121 1
a121 1
    
d123 11
a133 12
	XCreateWindow(dmxScreen->beDisplay, 
		      DefaultRootWindow(dmxScreen->beDisplay),
		      dmxScreen->scrnX,
		      dmxScreen->scrnY,
		      dmxScreen->scrnWidth,
		      dmxScreen->scrnHeight,
		      0,
		      pScreen->rootDepth,
		      InputOutput,
		      dmxScreen->beVisuals[dmxScreen->beDefVisualIndex].visual,
		      mask,
		      &attribs);
d141 15
a155 14
	char noCursorData[] = {0, 0, 0, 0,
			       0, 0, 0, 0};
	Pixmap pixmap;
	XColor color, tmp;

	pixmap = XCreateBitmapFromData(dmxScreen->beDisplay, dmxScreen->scrnWin,
				       noCursorData, 8, 8);
	XAllocNamedColor(dmxScreen->beDisplay, dmxScreen->beDefColormaps[0],
			 "black", &color, &tmp);
	dmxScreen->noCursor = XCreatePixmapCursor(dmxScreen->beDisplay,
						  pixmap, pixmap,
						  &color, &color, 0, 0);
	XDefineCursor(dmxScreen->beDisplay, dmxScreen->scrnWin,
		      dmxScreen->noCursor);
d157 1
a157 1
	XFreePixmap(dmxScreen->beDisplay, pixmap);
d163 29
a191 34
	mask = (GCFunction
		| GCPlaneMask
		| GCClipMask);
	gcvals.function = GXcopy;
	gcvals.plane_mask = AllPlanes;
	gcvals.clip_mask = None;

	dmxScreen->shadowGC = XCreateGC(dmxScreen->beDisplay,
					dmxScreen->scrnWin,
					mask, &gcvals);

	dmxScreen->shadowFBImage =
	    XCreateImage(dmxScreen->beDisplay,
			 dmxScreen->beVisuals[dmxScreen->beDefVisualIndex].visual,
			 dmxScreen->beDepth,
			 ZPixmap,
			 0,
			 (char *)dmxScreen->shadow,
			 dmxScreen->scrnWidth, dmxScreen->scrnHeight,
			 dmxScreen->beBPP,
			 PixmapBytePad(dmxScreen->scrnWidth,
				       dmxScreen->beBPP));
    } else {
	/* Create default drawables (used during GC creation) */
	for (i = 0; i < dmxScreen->beNumPixmapFormats; i++) 
	    for (j = 0; j < dmxScreen->beNumDepths; j++)
		if ((dmxScreen->bePixmapFormats[i].depth == 1) ||
		    (dmxScreen->bePixmapFormats[i].depth ==
		     dmxScreen->beDepths[j])) {
		    dmxScreen->scrnDefDrawables[i] = (Drawable)
			XCreatePixmap(dmxScreen->beDisplay, dmxScreen->scrnWin,
				      1, 1, dmxScreen->bePixmapFormats[i].depth);
		    break;
		}
d196 2
a197 1
Bool dmxScreenInit(int idx, ScreenPtr pScreen, int argc, char *argv[])
d199 2
a200 2
    DMXScreenInfo        *dmxScreen = &dmxScreens[idx];
    int                   i, j;
d203 1
a203 1
	return FALSE;
d205 1
a205 1
	return FALSE;
d207 1
a207 1
	return FALSE;
d210 4
a213 4
	/* Allocate font private index */
	dmxFontPrivateIndex = AllocateFontPrivateIndex();
	if (dmxFontPrivateIndex == -1)
	    return FALSE;
d215 1
a215 1
	dmxGeneration = serverGeneration;
d219 11
a229 7
	dmxScreen->shadow = shadowAlloc(dmxScreen->scrnWidth,
					dmxScreen->scrnHeight,
					dmxScreen->beBPP);
    } else {
	if (!dmxInitGC(pScreen)) return FALSE;
	if (!dmxInitWindow(pScreen)) return FALSE;
	if (!dmxInitPixmap(pScreen)) return FALSE;
d240 27
a266 27
	int    depth;
	int    visuals        = 0;
	int    bitsPerRgb     = 0;
	int    preferredClass = -1;
	Pixel  redMask        = 0;
	Pixel  greenMask      = 0;
	Pixel  blueMask       = 0;

	depth = dmxScreen->beDepths[i];
	for (j = 0; j < dmxScreen->beNumVisuals; j++) {
	    XVisualInfo *vi;

	    vi = &dmxScreen->beVisuals[j];
	    if (vi->depth == depth) {
		/* Assume the masks are all the same. */
		visuals |= (1 << vi->class);
		bitsPerRgb = vi->bits_per_rgb;
		redMask = vi->red_mask;
		greenMask = vi->green_mask;
		blueMask = vi->blue_mask;
		if (j == dmxScreen->beDefVisualIndex) {
		    preferredClass = vi->class;
		}
	    }
	}
	miSetVisualTypesAndMasks(depth, visuals, bitsPerRgb, preferredClass,
				 redMask, greenMask, blueMask);
d270 6
a275 8
		 dmxShadowFB ? dmxScreen->shadow : NULL,
		 dmxScreen->scrnWidth,
		 dmxScreen->scrnHeight,
		 dmxScreen->beXDPI,
		 dmxScreen->beXDPI,
		 dmxScreen->scrnWidth,
		 dmxScreen->beBPP);
    (void)dmxPictureInit(pScreen, 0, 0);
d282 1
a282 1
	return FALSE;
d285 3
a287 2
	miDCInitialize(pScreen, &dmxPointerCursorFuncs);
    } else {
d289 5
a293 6
	if (dmxCursorGeneration[idx] != serverGeneration) {
	    if (!(miPointerInitialize(pScreen,
				      &dmxPointerSpriteFuncs,
				      &dmxPointerCursorFuncs,
				      FALSE)))
		return FALSE;
d295 2
a296 2
	    dmxCursorGeneration[idx] = serverGeneration;
	}
d305 2
a306 2
	/* Wrap GC functions */
	DMX_WRAP(CreateGC, dmxCreateGC, dmxScreen, pScreen);
d308 35
a342 35
	/* Wrap Window functions */
	DMX_WRAP(CreateWindow, dmxCreateWindow, dmxScreen, pScreen);
	DMX_WRAP(DestroyWindow, dmxDestroyWindow, dmxScreen, pScreen);
	DMX_WRAP(PositionWindow, dmxPositionWindow, dmxScreen, pScreen);
	DMX_WRAP(ChangeWindowAttributes, dmxChangeWindowAttributes, dmxScreen,
		 pScreen);
	DMX_WRAP(RealizeWindow, dmxRealizeWindow, dmxScreen, pScreen);
	DMX_WRAP(UnrealizeWindow, dmxUnrealizeWindow, dmxScreen, pScreen);
	DMX_WRAP(RestackWindow, dmxRestackWindow, dmxScreen, pScreen);
	DMX_WRAP(WindowExposures, dmxWindowExposures, dmxScreen, pScreen);
	DMX_WRAP(CopyWindow, dmxCopyWindow, dmxScreen, pScreen);

	DMX_WRAP(ResizeWindow, dmxResizeWindow, dmxScreen, pScreen);
	DMX_WRAP(ReparentWindow, dmxReparentWindow, dmxScreen, pScreen);

	DMX_WRAP(ChangeBorderWidth, dmxChangeBorderWidth, dmxScreen, pScreen);

	/* Wrap Image functions */
	DMX_WRAP(GetImage, dmxGetImage, dmxScreen, pScreen);
	DMX_WRAP(GetSpans, dmxGetSpans, dmxScreen, pScreen);

	/* Wrap Pixmap functions */
	DMX_WRAP(CreatePixmap, dmxCreatePixmap, dmxScreen, pScreen);
	DMX_WRAP(DestroyPixmap, dmxDestroyPixmap, dmxScreen, pScreen);
	DMX_WRAP(BitmapToRegion, dmxBitmapToRegion, dmxScreen, pScreen);

	/* Wrap Font functions */
	DMX_WRAP(RealizeFont, dmxRealizeFont, dmxScreen, pScreen);
	DMX_WRAP(UnrealizeFont, dmxUnrealizeFont, dmxScreen, pScreen);

	/* Wrap Colormap functions */
	DMX_WRAP(CreateColormap, dmxCreateColormap, dmxScreen, pScreen);
	DMX_WRAP(DestroyColormap, dmxDestroyColormap, dmxScreen, pScreen);
	DMX_WRAP(InstallColormap, dmxInstallColormap, dmxScreen, pScreen);
	DMX_WRAP(StoreColors, dmxStoreColors, dmxScreen, pScreen);
d344 2
a345 2
	/* Wrap Shape functions */
	DMX_WRAP(SetShape, dmxSetShape, dmxScreen, pScreen);
d349 1
a349 1
	return FALSE;
d355 2
a356 1
void dmxBECloseScreen(ScreenPtr pScreen)
d359 1
a359 1
    int            i;
d367 1
a367 1
    dmxScreen->noCursor = (Cursor)0;
d371 1
a371 1
    dmxScreen->scrnWin = (Window)0;
d374 15
a388 14
	/* Free the shadow GC and image assocated with the back-end server */
	XFreeGC(dmxScreen->beDisplay, dmxScreen->shadowGC);
	dmxScreen->shadowGC = NULL;
	XFree(dmxScreen->shadowFBImage);
	dmxScreen->shadowFBImage = NULL;
    } else {
	/* Free the default drawables */
	for (i = 0; i < dmxScreen->beNumPixmapFormats; i++) {
	    if (dmxScreen->scrnDefDrawables[i]) {
		XFreePixmap(dmxScreen->beDisplay,
			    dmxScreen->scrnDefDrawables[i]);
		dmxScreen->scrnDefDrawables[i] = (Drawable)0;
	    }
	}
d393 1
a393 1
	XFreeColormap(dmxScreen->beDisplay, dmxScreen->beDefColormaps[i]);
d412 3
a414 3
	XFree(dmxScreen->glxVisuals);
	dmxScreen->glxVisuals = NULL;
	dmxScreen->numGlxVisuals = 0;
d424 2
a425 1
Bool dmxCloseScreen(int idx, ScreenPtr pScreen)
d431 2
a432 2
	dmxResetRender();
	dmxResetFonts();
d436 40
a475 39
	/* Free the shadow framebuffer */
	free(dmxScreen->shadow);
    } else {

	/* Unwrap Shape functions */
	DMX_UNWRAP(SetShape, dmxScreen, pScreen);

	/* Unwrap the pScreen functions */
	DMX_UNWRAP(CreateGC, dmxScreen, pScreen);

	DMX_UNWRAP(CreateWindow, dmxScreen, pScreen);
	DMX_UNWRAP(DestroyWindow, dmxScreen, pScreen);
	DMX_UNWRAP(PositionWindow, dmxScreen, pScreen);
	DMX_UNWRAP(ChangeWindowAttributes, dmxScreen, pScreen);
	DMX_UNWRAP(RealizeWindow, dmxScreen, pScreen);
	DMX_UNWRAP(UnrealizeWindow, dmxScreen, pScreen);
	DMX_UNWRAP(RestackWindow, dmxScreen, pScreen);
	DMX_UNWRAP(WindowExposures, dmxScreen, pScreen);
	DMX_UNWRAP(CopyWindow, dmxScreen, pScreen);

	DMX_UNWRAP(ResizeWindow, dmxScreen, pScreen);
	DMX_UNWRAP(ReparentWindow, dmxScreen, pScreen);

	DMX_UNWRAP(ChangeBorderWidth, dmxScreen, pScreen);

	DMX_UNWRAP(GetImage, dmxScreen, pScreen);
	DMX_UNWRAP(GetSpans, dmxScreen, pScreen);

	DMX_UNWRAP(CreatePixmap, dmxScreen, pScreen);
	DMX_UNWRAP(DestroyPixmap, dmxScreen, pScreen);
	DMX_UNWRAP(BitmapToRegion, dmxScreen, pScreen);

	DMX_UNWRAP(RealizeFont, dmxScreen, pScreen);
	DMX_UNWRAP(UnrealizeFont, dmxScreen, pScreen);

	DMX_UNWRAP(CreateColormap, dmxScreen, pScreen);
	DMX_UNWRAP(DestroyColormap, dmxScreen, pScreen);
	DMX_UNWRAP(InstallColormap, dmxScreen, pScreen);
	DMX_UNWRAP(StoreColors, dmxScreen, pScreen);
d481 1
a481 1
	dmxBECloseScreen(pScreen);
d484 7
a490 7
	/* Free visuals, depths and pixmap formats here so that they
	 * won't be freed when a screen is detached, thereby allowing
	 * the screen to be reattached to be compared to the one
	 * previously removed.
	 */
	XFree(dmxScreen->beVisuals);
	dmxScreen->beVisuals = NULL;
d492 2
a493 2
	XFree(dmxScreen->beDepths);
	dmxScreen->beDepths = NULL;
d495 2
a496 2
	XFree(dmxScreen->bePixmapFormats);
	dmxScreen->bePixmapFormats = NULL;
d504 2
a505 1
static Bool dmxSaveScreen(ScreenPtr pScreen, int what)
d510 12
a521 12
	switch (what) {
	case SCREEN_SAVER_OFF:
	case SCREEN_SAVER_FORCER:
	    XResetScreenSaver(dmxScreen->beDisplay);
	    dmxSync(dmxScreen, FALSE);
	    break;
	case SCREEN_SAVER_ON:
	case SCREEN_SAVER_CYCLE:
	    XActivateScreenSaver(dmxScreen->beDisplay);
	    dmxSync(dmxScreen, FALSE);
	    break;
	}
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a285 2
    miInitializeBackingStore(pScreen);

@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a55 1
#ifdef RENDER
a56 1
#endif
d68 3
a70 6
static int dmxGCPrivateKeyIndex;
DevPrivateKey dmxGCPrivateKey = &dmxGCPrivateKeyIndex; /**< Private index for GCs       */
static int dmxWinPrivateKeyIndex;
DevPrivateKey dmxWinPrivateKey = &dmxWinPrivateKeyIndex; /**< Private index for Windows   */
static int dmxPixPrivateKeyIndex;
DevPrivateKey dmxPixPrivateKey = &dmxPixPrivateKeyIndex; /**< Private index for Pixmaps   */
d72 4
a75 10
static int dmxScreenPrivateKeyIndex;
DevPrivateKey dmxScreenPrivateKey = &dmxScreenPrivateKeyIndex; /**< Private index for Screens   */
static int dmxColormapPrivateKeyIndex;
DevPrivateKey dmxColormapPrivateKey = &dmxColormapPrivateKeyIndex; /**< Private index for Colormaps */
#ifdef RENDER
static int dmxPictPrivateKeyIndex;
DevPrivateKey dmxPictPrivateKey = &dmxPictPrivateKeyIndex; /**< Private index for Picts     */
static int dmxGlyphSetPrivateKeyIndex;
DevPrivateKey dmxGlyphSetPrivateKey = &dmxGlyphSetPrivateKeyIndex; /**< Private index for GlyphSets */
#endif
d206 7
a276 1
#ifdef RENDER
a277 1
#endif
d396 1
a396 1
    xfree(dmxScreen->beDefColormaps);
a431 1
#ifdef RENDER
a432 1
#endif
d438 1
a438 1
	xfree(dmxScreen->shadow);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a63 6
#undef Xmalloc
#undef Xcalloc
#undef Xrealloc
#undef Xfree


d71 1
a71 1
DevPrivateKey dmxGCPrivateKey = &dmxGCPrivateKey; /**< Private index for GCs       */
d285 4
d391 5
a395 2
	    XFreePixmap(dmxScreen->beDisplay, dmxScreen->scrnDefDrawables[i]);
	    dmxScreen->scrnDefDrawables[i] = (Drawable)0;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d64 6
d76 1
d78 4
a81 2
DevPrivateKey dmxWinPrivateKey = &dmxWinPrivateKey; /**< Private index for Windows   */
DevPrivateKey dmxPixPrivateKey = &dmxPixPrivateKey; /**< Private index for Pixmaps   */
d83 4
a86 2
DevPrivateKey dmxScreenPrivateKey = &dmxScreenPrivateKey; /**< Private index for Screens   */
DevPrivateKey dmxColormapPrivateKey = &dmxColormapPrivateKey; /**< Private index for Colormaps */
d88 4
a91 2
DevPrivateKey dmxPictPrivateKey = &dmxPictPrivateKey; /**< Private index for Picts     */
DevPrivateKey dmxGlyphSetPrivateKey = &dmxGlyphSetPrivateKey; /**< Private index for GlyphSets */
a355 1
#ifdef SHAPE
a357 1
#endif
a447 1
#ifdef SHAPE
a449 1
#endif
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
d70 3
a72 5
int dmxGCPrivateIndex;          /**< Private index for GCs       */
int dmxWinPrivateIndex;         /**< Private index for Windows   */
#ifdef PIXPRIV
int dmxPixPrivateIndex;         /**< Private index for Pixmaps   */
#endif
d74 2
a75 2
int dmxScreenPrivateIndex;      /**< Private index for Screens   */
int dmxColormapPrivateIndex;    /**< Private index for Colormaps */
d77 2
a78 2
int dmxPictPrivateIndex;        /**< Private index for Picts     */
int dmxGlyphSetPrivateIndex;    /**< Private index for GlyphSets */
a210 31
#ifdef RENDER
	/* Allocate picture private index */
	dmxPictPrivateIndex = AllocatePicturePrivateIndex();
	if (dmxPictPrivateIndex == -1)
	    return FALSE;

	/* Allocate glyph set private index */
	dmxGlyphSetPrivateIndex = AllocateGlyphSetPrivateIndex();
	if (dmxGlyphSetPrivateIndex == -1)
	    return FALSE;
#endif

	/* Allocate GC private index */
	dmxGCPrivateIndex = AllocateGCPrivateIndex();
	if (dmxGCPrivateIndex == -1)
	    return FALSE;

	/* Allocate window private index */
	dmxWinPrivateIndex = AllocateWindowPrivateIndex();
	if (dmxWinPrivateIndex == -1)
	    return FALSE;

#ifdef PIXPRIV
	/* Allocate pixmap private index */
	dmxPixPrivateIndex = AllocatePixmapPrivateIndex();
	if (dmxPixPrivateIndex == -1)
	    return FALSE;
#else
#error Must define PIXPRIV to compile DMX X server
#endif

a215 5
        /* Allocate screen private index */
        dmxScreenPrivateIndex = AllocateScreenPrivateIndex();
        if (dmxScreenPrivateIndex == -1)
            return FALSE;

a316 3
	DMX_WRAP(PaintWindowBackground, dmxPaintWindowBackground, dmxScreen,
		 pScreen);
	DMX_WRAP(PaintWindowBorder, dmxPaintWindowBorder, dmxScreen, pScreen);
a452 2
	DMX_UNWRAP(PaintWindowBackground, dmxScreen, pScreen);
	DMX_UNWRAP(PaintWindowBorder, dmxScreen, pScreen);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
d73 1
d75 1
d236 1
d241 3
@

