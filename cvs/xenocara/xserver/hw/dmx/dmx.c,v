head	1.11;
access;
symbols
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	7pAEtF6Y5EgemkuY;

1.9
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.16;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.43;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.18;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 2002-2004 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Rickard E. (Rik) Faith <faith@@redhat.com>
 *
 */

/** \file
 * This file implements the server-side part of the DMX protocol. A
 * vector of fucntions is provided at extension initialization time, so
 * most all of the useful functions in this file are declared static and
 * do not appear in the doxygen documentation.
 *
 * Much of the low-level work is done by functions in \a dmxextension.c
 *
 * Please see the Client-to-Server DMX Extension to the X Protocol
 * document for details about the protocol.  */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "extinit.h"
#include "opaque.h"

#include "dmx.h"
#include "dmxextension.h"
#include <X11/extensions/dmxproto.h>
#include <X11/extensions/dmx.h>
#include "protocol-versions.h"

#ifdef PANORAMIX
#include "panoramiX.h"
extern unsigned long XRT_WINDOW;
extern int PanoramiXNumScreens;
#endif

static unsigned char DMXCode;

static int
_DMXXineramaActive(void)
{
#ifdef PANORAMIX
    return !noPanoramiXExtension;
#else
    return 0;
#endif
}

static void
dmxSetScreenAttribute(int bit, DMXScreenAttributesPtr attr, CARD32 value)
{
    switch (1 << bit) {
    case DMXScreenWindowWidth:
        attr->screenWindowWidth = value;
        break;
    case DMXScreenWindowHeight:
        attr->screenWindowHeight = value;
        break;
    case DMXScreenWindowXoffset:
        attr->screenWindowXoffset = value;
        break;
    case DMXScreenWindowYoffset:
        attr->screenWindowYoffset = value;
        break;
    case DMXRootWindowWidth:
        attr->rootWindowWidth = value;
        break;
    case DMXRootWindowHeight:
        attr->rootWindowHeight = value;
        break;
    case DMXRootWindowXoffset:
        attr->rootWindowXoffset = value;
        break;
    case DMXRootWindowYoffset:
        attr->rootWindowYoffset = value;
        break;
    case DMXRootWindowXorigin:
        attr->rootWindowXorigin = value;
        break;
    case DMXRootWindowYorigin:
        attr->rootWindowYorigin = value;
        break;
    }
}

static int
dmxFetchScreenAttributes(unsigned int mask,
                         DMXScreenAttributesPtr attr, CARD32 *value_list)
{
    int i;
    CARD32 *value = value_list;
    int count = 0;

    for (i = 0; i < 32; i++) {
        if (mask & (1 << i)) {
            dmxSetScreenAttribute(i, attr, *value);
            ++value;
            ++count;
        }
    }
    return count;
}

static void
dmxSetDesktopAttribute(int bit, DMXDesktopAttributesPtr attr, CARD32 value)
{
    switch (1 << bit) {
    case DMXDesktopWidth:
        attr->width = value;
        break;
    case DMXDesktopHeight:
        attr->height = value;
        break;
    case DMXDesktopShiftX:
        attr->shiftX = value;
        break;
    case DMXDesktopShiftY:
        attr->shiftY = value;
        break;
    }
}

static int
dmxFetchDesktopAttributes(unsigned int mask,
                          DMXDesktopAttributesPtr attr, CARD32 *value_list)
{
    int i;
    CARD32 *value = value_list;
    int count = 0;

    for (i = 0; i < 32; i++) {
        if (mask & (1 << i)) {
            dmxSetDesktopAttribute(i, attr, *value);
            ++value;
            ++count;
        }
    }
    return count;
}

static void
dmxSetInputAttribute(int bit, DMXInputAttributesPtr attr, CARD32 value)
{
    switch (1 << bit) {
    case DMXInputType:
        attr->inputType = value;
        break;
    case DMXInputPhysicalScreen:
        attr->physicalScreen = value;
        break;
    case DMXInputSendsCore:
        attr->sendsCore = ! !value;
        break;
    }
}

static int
dmxFetchInputAttributes(unsigned int mask,
                        DMXInputAttributesPtr attr, CARD32 *value_list)
{
    int i;
    CARD32 *value = value_list;
    int count = 0;

    for (i = 0; i < 32; i++) {
        if (mask & (1 << i)) {
            dmxSetInputAttribute(i, attr, *value);
            ++value;
            ++count;
        }
    }
    return count;
}

static int
ProcDMXQueryVersion(ClientPtr client)
{
    xDMXQueryVersionReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .majorVersion = SERVER_DMX_MAJOR_VERSION,
        .minorVersion = SERVER_DMX_MINOR_VERSION,
        .patchVersion = SERVER_DMX_PATCH_VERSION
    };

    REQUEST_SIZE_MATCH(xDMXQueryVersionReq);

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.majorVersion);
        swapl(&rep.minorVersion);
        swapl(&rep.patchVersion);
    }
    WriteToClient(client, sizeof(xDMXQueryVersionReply), &rep);
    return Success;
}

static int
ProcDMXSync(ClientPtr client)
{
    xDMXSyncReply rep;

    REQUEST_SIZE_MATCH(xDMXSyncReq);

    dmxFlushPendingSyncs();

    rep = (xDMXSyncReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .status = 0
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.status);
    }
    WriteToClient(client, sizeof(xDMXSyncReply), &rep);
    return Success;
}

static int
ProcDMXForceWindowCreation(ClientPtr client)
{
    xDMXForceWindowCreationReply rep;

    REQUEST(xDMXForceWindowCreationReq);
    WindowPtr pWin;

    REQUEST_SIZE_MATCH(xDMXForceWindowCreationReq);

#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        PanoramiXRes *win;
        int i;

        if (Success != dixLookupResourceByType((void **) &win,
                                               stuff->window, XRT_WINDOW,
                                               client, DixReadAccess))
            return -1;          /* BadWindow */

        FOR_NSCREENS(i) {
            if (Success != dixLookupWindow(&pWin, win->info[i].id, client,
                                           DixReadAccess))
                return -1;      /* BadWindow */

            dmxForceWindowCreation(pWin);
        }
        goto doreply;
    }
#endif

    if (Success != dixLookupWindow(&pWin, stuff->window, client, DixReadAccess))
        return -1;              /* BadWindow */

    dmxForceWindowCreation(pWin);
 doreply:
    dmxFlushPendingSyncs();
    rep = (xDMXForceWindowCreationReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .status = 0
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.status);
    }
    WriteToClient(client, sizeof(xDMXForceWindowCreationReply), &rep);
    return Success;
}

static int
ProcDMXGetScreenCount(ClientPtr client)
{
    xDMXGetScreenCountReply rep;

    REQUEST_SIZE_MATCH(xDMXGetScreenCountReq);

    rep = (xDMXGetScreenCountReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .screenCount = dmxGetNumScreens()
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.screenCount);
    }
    WriteToClient(client, sizeof(xDMXGetScreenCountReply), &rep);
    return Success;
}

static int
ProcDMXGetScreenAttributes(ClientPtr client)
{
    REQUEST(xDMXGetScreenAttributesReq);
    xDMXGetScreenAttributesReply rep;
    int length;
    int paddedLength;
    DMXScreenAttributesRec attr;

    REQUEST_SIZE_MATCH(xDMXGetScreenAttributesReq);

    if (stuff->physicalScreen < 0
        || stuff->physicalScreen >= dmxGetNumScreens())
        return BadValue;

    if (!dmxGetScreenAttributes(stuff->physicalScreen, &attr))
        return BadValue;

    length = attr.displayName ? strlen(attr.displayName) : 0;
    paddedLength = pad_to_int32(length);

    rep = (xDMXGetScreenAttributesReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length =
            bytes_to_int32((sizeof(xDMXGetScreenAttributesReply) -
                            sizeof(xGenericReply))
                           + paddedLength),
        .displayNameLength = length,
        .logicalScreen = attr.logicalScreen,
        .screenWindowWidth = attr.screenWindowWidth,
        .screenWindowHeight = attr.screenWindowHeight,
        .screenWindowXoffset = attr.screenWindowXoffset,
        .screenWindowYoffset = attr.screenWindowYoffset,
        .rootWindowWidth = attr.rootWindowWidth,
        .rootWindowHeight = attr.rootWindowHeight,
        .rootWindowXoffset = attr.rootWindowXoffset,
        .rootWindowYoffset = attr.rootWindowYoffset,
        .rootWindowXorigin = attr.rootWindowXorigin,
        .rootWindowYorigin = attr.rootWindowYorigin
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.displayNameLength);
        swapl(&rep.logicalScreen);
        swaps(&rep.screenWindowWidth);
        swaps(&rep.screenWindowHeight);
        swaps(&rep.screenWindowXoffset);
        swaps(&rep.screenWindowYoffset);
        swaps(&rep.rootWindowWidth);
        swaps(&rep.rootWindowHeight);
        swaps(&rep.rootWindowXoffset);
        swaps(&rep.rootWindowYoffset);
        swaps(&rep.rootWindowXorigin);
        swaps(&rep.rootWindowYorigin);
    }
    WriteToClient(client, sizeof(xDMXGetScreenAttributesReply), &rep);
    if (length)
        WriteToClient(client, length, attr.displayName);
    return Success;
}

static int
ProcDMXChangeScreensAttributes(ClientPtr client)
{
    REQUEST(xDMXChangeScreensAttributesReq);
    xDMXChangeScreensAttributesReply rep;
    int status = DMX_BAD_XINERAMA;
    unsigned int mask = 0;
    unsigned int i;
    CARD32 *screen_list;
    CARD32 *mask_list;
    CARD32 *value_list;
    DMXScreenAttributesPtr attribs;
    int errorScreen = 0;
    unsigned int len;
    int ones = 0;

    REQUEST_AT_LEAST_SIZE(xDMXChangeScreensAttributesReq);
    len =
        client->req_len -
        bytes_to_int32(sizeof(xDMXChangeScreensAttributesReq));
    if (len < stuff->screenCount + stuff->maskCount)
        return BadLength;

    screen_list = (CARD32 *) (stuff + 1);
    mask_list = &screen_list[stuff->screenCount];
    value_list = &mask_list[stuff->maskCount];

    for (i = 0; i < stuff->maskCount; i++)
        ones += Ones(mask_list[i]);
    if (len != stuff->screenCount + stuff->maskCount + ones)
        return BadLength;

    if (!_DMXXineramaActive())
        goto noxinerama;

    if (!(attribs = xallocarray(stuff->screenCount, sizeof(*attribs))))
        return BadAlloc;

    for (i = 0; i < stuff->screenCount; i++) {
        int count;

        if (i < stuff->maskCount)
            mask = mask_list[i];
        dmxGetScreenAttributes(screen_list[i], &attribs[i]);
        count = dmxFetchScreenAttributes(mask, &attribs[i], value_list);
        value_list += count;
    }

#if PANORAMIX
    status = dmxConfigureScreenWindows(stuff->screenCount,
                                       screen_list, attribs, &errorScreen);
#endif

    free(attribs);

    if (status == BadValue)
        return status;

 noxinerama:
    rep = (xDMXChangeScreensAttributesReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .status = status,
        .errorScreen = errorScreen
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.status);
        swapl(&rep.errorScreen);
    }
    WriteToClient(client, sizeof(xDMXChangeScreensAttributesReply), &rep);
    return Success;
}

static int
ProcDMXAddScreen(ClientPtr client)
{
    REQUEST(xDMXAddScreenReq);
    xDMXAddScreenReply rep;
    int status = 0;
    CARD32 *value_list;
    DMXScreenAttributesRec attr;
    int count;
    char *name;
    int len;
    int paddedLength;

    REQUEST_AT_LEAST_SIZE(xDMXAddScreenReq);
    paddedLength = pad_to_int32(stuff->displayNameLength);
    len = client->req_len - bytes_to_int32(sizeof(xDMXAddScreenReq));
    if (len != Ones(stuff->valueMask) + paddedLength / 4)
        return BadLength;

    memset(&attr, 0, sizeof(attr));
    dmxGetScreenAttributes(stuff->physicalScreen, &attr);
    value_list = (CARD32 *) (stuff + 1);
    count = dmxFetchScreenAttributes(stuff->valueMask, &attr, value_list);

    if (!(name = malloc(stuff->displayNameLength + 1 + 4)))
        return BadAlloc;
    memcpy(name, &value_list[count], stuff->displayNameLength);
    name[stuff->displayNameLength] = '\0';
    attr.displayName = name;

    status = dmxAttachScreen(stuff->physicalScreen, &attr);

    free(name);

    rep = (xDMXAddScreenReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .status = status,
        .physicalScreen = stuff->physicalScreen
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.status);
        swapl(&rep.physicalScreen);
    }
    WriteToClient(client, sizeof(xDMXAddScreenReply), &rep);
    return Success;
}

static int
ProcDMXRemoveScreen(ClientPtr client)
{
    REQUEST(xDMXRemoveScreenReq);
    xDMXRemoveScreenReply rep;
    int status = 0;

    REQUEST_SIZE_MATCH(xDMXRemoveScreenReq);

    status = dmxDetachScreen(stuff->physicalScreen);

    rep = (xDMXRemoveScreenReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .status = status
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.status);
    }
    WriteToClient(client, sizeof(xDMXRemoveScreenReply), &rep);
    return Success;
}

#ifdef PANORAMIX
static int
dmxPopulatePanoramiX(ClientPtr client, Window window,
                     CARD32 *screens, CARD32 *windows,
                     xRectangle *pos, xRectangle *vis)
{
    WindowPtr pWin;
    PanoramiXRes *win;
    int i;
    int count = 0;
    DMXWindowAttributesRec attr;

    if (Success != dixLookupResourceByType((void **) &win,
                                           window, XRT_WINDOW,
                                           client, DixReadAccess))
        return -1;              /* BadWindow */

    FOR_NSCREENS(i) {
        if (Success != dixLookupWindow(&pWin, win->info[i].id, client,
                                       DixReadAccess))
            return -1;          /* BadWindow */
        if (dmxGetWindowAttributes(pWin, &attr)) {
            screens[count] = attr.screen;
            windows[count] = attr.window;
            pos[count] = attr.pos;
            vis[count] = attr.vis;
            ++count;            /* Only count existing windows */
        }
    }
    return count;
}
#endif

static int
dmxPopulate(ClientPtr client, Window window, CARD32 *screens,
            CARD32 *windows, xRectangle *pos, xRectangle *vis)
{
    WindowPtr pWin;
    DMXWindowAttributesRec attr;

#ifdef PANORAMIX
    if (!noPanoramiXExtension)
        return dmxPopulatePanoramiX(client, window, screens, windows, pos, vis);
#endif

    if (Success != dixLookupWindow(&pWin, window, client, DixReadAccess))
        return -1;              /* BadWindow */

    dmxGetWindowAttributes(pWin, &attr);
    *screens = attr.screen;
    *windows = attr.window;
    *pos = attr.pos;
    *vis = attr.vis;
    return 1;
}

static int
dmxMaxNumScreens(void)
{
#ifdef PANORAMIX
    if (!noPanoramiXExtension)
        return PanoramiXNumScreens;
#endif
    return 1;
}

static int
ProcDMXGetWindowAttributes(ClientPtr client)
{
    REQUEST(xDMXGetWindowAttributesReq);
    xDMXGetWindowAttributesReply rep;
    int i;
    CARD32 *screens;
    CARD32 *windows;
    xRectangle *pos, *vis;
    int count = dmxMaxNumScreens();

    REQUEST_SIZE_MATCH(xDMXGetWindowAttributesReq);

    if (!(screens = xallocarray(count, sizeof(*screens))))
        return BadAlloc;
    if (!(windows = xallocarray(count, sizeof(*windows)))) {
        free(screens);
        return BadAlloc;
    }
    if (!(pos = xallocarray(count, sizeof(*pos)))) {
        free(windows);
        free(screens);
        return BadAlloc;
    }
    if (!(vis = xallocarray(count, sizeof(*vis)))) {
        free(pos);
        free(windows);
        free(screens);
        return BadAlloc;
    }

    if ((count = dmxPopulate(client, stuff->window, screens, windows,
                             pos, vis)) < 0) {
        free(vis);
        free(pos);
        free(windows);
        free(screens);
        return BadWindow;
    }

    rep = (xDMXGetWindowAttributesReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = count * 6,
        .screenCount = count
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.screenCount);
        for (i = 0; i < count; i++) {
            swapl(&screens[i]);
            swapl(&windows[i]);

            swaps(&pos[i].x);
            swaps(&pos[i].y);
            swaps(&pos[i].width);
            swaps(&pos[i].height);

            swaps(&vis[i].x);
            swaps(&vis[i].y);
            swaps(&vis[i].width);
            swaps(&vis[i].height);
        }
    }

    dmxFlushPendingSyncs();

    WriteToClient(client, sizeof(xDMXGetWindowAttributesReply), &rep);
    if (count) {
        WriteToClient(client, count * sizeof(*screens), screens);
        WriteToClient(client, count * sizeof(*windows), windows);
        WriteToClient(client, count * sizeof(*pos), pos);
        WriteToClient(client, count * sizeof(*vis), vis);
    }

    free(vis);
    free(pos);
    free(windows);
    free(screens);

    return Success;
}

static int
ProcDMXGetDesktopAttributes(ClientPtr client)
{
    xDMXGetDesktopAttributesReply rep;
    DMXDesktopAttributesRec attr;

    REQUEST_SIZE_MATCH(xDMXGetDesktopAttributesReq);

    dmxGetDesktopAttributes(&attr);

    rep = (xDMXGetDesktopAttributesReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .width = attr.width,
        .height = attr.height,
        .shiftX = attr.shiftX,
        .shiftY = attr.shiftY
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.width);
        swaps(&rep.height);
        swaps(&rep.shiftX);
        swaps(&rep.shiftY);
    }
    WriteToClient(client, sizeof(xDMXGetDesktopAttributesReply), &rep);
    return Success;
}

static int
ProcDMXChangeDesktopAttributes(ClientPtr client)
{
    REQUEST(xDMXChangeDesktopAttributesReq);
    xDMXChangeDesktopAttributesReply rep;
    int status = DMX_BAD_XINERAMA;
    CARD32 *value_list;
    DMXDesktopAttributesRec attr;
    int len;

    REQUEST_AT_LEAST_SIZE(xDMXChangeDesktopAttributesReq);
    len = client->req_len - (sizeof(xDMXChangeDesktopAttributesReq) >> 2);
    if (len != Ones(stuff->valueMask))
        return BadLength;

    if (!_DMXXineramaActive())
        goto noxinerama;

    value_list = (CARD32 *) (stuff + 1);

    dmxGetDesktopAttributes(&attr);
    dmxFetchDesktopAttributes(stuff->valueMask, &attr, value_list);

#if PANORAMIX
    status = dmxConfigureDesktop(&attr);
#endif
    if (status == BadValue)
        return status;

 noxinerama:
    rep = (xDMXChangeDesktopAttributesReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .status = status
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.status);
    }
    WriteToClient(client, sizeof(xDMXChangeDesktopAttributesReply), &rep);
    return Success;
}

static int
ProcDMXGetInputCount(ClientPtr client)
{
    xDMXGetInputCountReply rep;

    REQUEST_SIZE_MATCH(xDMXGetInputCountReq);

    rep = (xDMXGetInputCountReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .inputCount = dmxGetInputCount()
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.inputCount);
    }
    WriteToClient(client, sizeof(xDMXGetInputCountReply), &rep);
    return Success;
}

static int
ProcDMXGetInputAttributes(ClientPtr client)
{
    REQUEST(xDMXGetInputAttributesReq);
    xDMXGetInputAttributesReply rep;
    int length;
    int paddedLength;
    DMXInputAttributesRec attr;

    REQUEST_SIZE_MATCH(xDMXGetInputAttributesReq);

    if (dmxGetInputAttributes(stuff->deviceId, &attr))
        return BadValue;

    length = attr.name ? strlen(attr.name) : 0;
    paddedLength = pad_to_int32(length);

    rep = (xDMXGetInputAttributesReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(paddedLength),

        .inputType = attr.inputType,
        .physicalScreen = attr.physicalScreen,
        .physicalId = attr.physicalId,
        .nameLength = length,
        .isCore = attr.isCore,
        .sendsCore = attr.sendsCore,
        .detached = attr.detached
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.inputType);
        swapl(&rep.physicalScreen);
        swapl(&rep.physicalId);
        swapl(&rep.nameLength);
    }
    WriteToClient(client, sizeof(xDMXGetInputAttributesReply), &rep);
    if (length)
        WriteToClient(client, length, attr.name);
    return Success;
}

static int
ProcDMXAddInput(ClientPtr client)
{
    REQUEST(xDMXAddInputReq);
    xDMXAddInputReply rep;
    int status = 0;
    CARD32 *value_list;
    DMXInputAttributesRec attr;
    int count;
    char *name;
    int len;
    int paddedLength;
    int id = -1;

    REQUEST_AT_LEAST_SIZE(xDMXAddInputReq);
    paddedLength = pad_to_int32(stuff->displayNameLength);
    len = client->req_len - (sizeof(xDMXAddInputReq) >> 2);
    if (len != Ones(stuff->valueMask) + paddedLength / 4)
        return BadLength;

    memset(&attr, 0, sizeof(attr));
    value_list = (CARD32 *) (stuff + 1);
    count = dmxFetchInputAttributes(stuff->valueMask, &attr, value_list);

    if (!(name = malloc(stuff->displayNameLength + 1 + 4)))
        return BadAlloc;
    memcpy(name, &value_list[count], stuff->displayNameLength);
    name[stuff->displayNameLength] = '\0';
    attr.name = name;

    status = dmxAddInput(&attr, &id);

    free(name);

    if (status)
        return status;

    rep = (xDMXAddInputReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .status = status,
        .physicalId = id
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.status);
        swapl(&rep.physicalId);
    }
    WriteToClient(client, sizeof(xDMXAddInputReply), &rep);
    return Success;
}

static int
ProcDMXRemoveInput(ClientPtr client)
{
    REQUEST(xDMXRemoveInputReq);
    xDMXRemoveInputReply rep;
    int status = 0;

    REQUEST_SIZE_MATCH(xDMXRemoveInputReq);

    status = dmxRemoveInput(stuff->physicalId);

    if (status)
        return status;

    rep = (xDMXRemoveInputReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .status = status
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.status);
    }
    WriteToClient(client, sizeof(xDMXRemoveInputReply), &rep);
    return Success;
}

static int
ProcDMXDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_DMXQueryVersion:
        return ProcDMXQueryVersion(client);
    case X_DMXSync:
        return ProcDMXSync(client);
    case X_DMXForceWindowCreation:
        return ProcDMXForceWindowCreation(client);
    case X_DMXGetScreenCount:
        return ProcDMXGetScreenCount(client);
    case X_DMXGetScreenAttributes:
        return ProcDMXGetScreenAttributes(client);
    case X_DMXChangeScreensAttributes:
        return ProcDMXChangeScreensAttributes(client);
    case X_DMXAddScreen:
        return ProcDMXAddScreen(client);
    case X_DMXRemoveScreen:
        return ProcDMXRemoveScreen(client);
    case X_DMXGetWindowAttributes:
        return ProcDMXGetWindowAttributes(client);
    case X_DMXGetDesktopAttributes:
        return ProcDMXGetDesktopAttributes(client);
    case X_DMXChangeDesktopAttributes:
        return ProcDMXChangeDesktopAttributes(client);
    case X_DMXGetInputCount:
        return ProcDMXGetInputCount(client);
    case X_DMXGetInputAttributes:
        return ProcDMXGetInputAttributes(client);
    case X_DMXAddInput:
        return ProcDMXAddInput(client);
    case X_DMXRemoveInput:
        return ProcDMXRemoveInput(client);

    case X_DMXGetScreenInformationDEPRECATED:
    case X_DMXForceWindowCreationDEPRECATED:
    case X_DMXReconfigureScreenDEPRECATED:
        return BadImplementation;

    default:
        return BadRequest;
    }
}

static int
SProcDMXQueryVersion(ClientPtr client)
{
    REQUEST(xDMXQueryVersionReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDMXQueryVersionReq);
    return ProcDMXQueryVersion(client);
}

static int
SProcDMXSync(ClientPtr client)
{
    REQUEST(xDMXSyncReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDMXSyncReq);
    return ProcDMXSync(client);
}

static int
SProcDMXForceWindowCreation(ClientPtr client)
{
    REQUEST(xDMXForceWindowCreationReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDMXForceWindowCreationReq);
    swapl(&stuff->window);
    return ProcDMXForceWindowCreation(client);
}

static int
SProcDMXGetScreenCount(ClientPtr client)
{
    REQUEST(xDMXGetScreenCountReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDMXGetScreenCountReq);
    return ProcDMXGetScreenCount(client);
}

static int
SProcDMXGetScreenAttributes(ClientPtr client)
{
    REQUEST(xDMXGetScreenAttributesReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDMXGetScreenAttributesReq);
    swapl(&stuff->physicalScreen);
    return ProcDMXGetScreenAttributes(client);
}

static int
SProcDMXChangeScreensAttributes(ClientPtr client)
{
    REQUEST(xDMXChangeScreensAttributesReq);

    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xDMXGetScreenAttributesReq);
    swapl(&stuff->screenCount);
    swapl(&stuff->maskCount);
    SwapRestL(stuff);
    return ProcDMXGetScreenAttributes(client);
}

static int
SProcDMXAddScreen(ClientPtr client)
{
    int paddedLength;

    REQUEST(xDMXAddScreenReq);

    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xDMXAddScreenReq);
    swapl(&stuff->displayNameLength);
    swapl(&stuff->valueMask);
    paddedLength = pad_to_int32(stuff->displayNameLength);
    SwapLongs((CARD32 *) (stuff + 1), LengthRestL(stuff) - paddedLength / 4);
    return ProcDMXAddScreen(client);
}

static int
SProcDMXRemoveScreen(ClientPtr client)
{
    REQUEST(xDMXRemoveScreenReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDMXRemoveScreenReq);
    swapl(&stuff->physicalScreen);
    return ProcDMXRemoveScreen(client);
}

static int
SProcDMXGetWindowAttributes(ClientPtr client)
{
    REQUEST(xDMXGetWindowAttributesReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDMXGetWindowAttributesReq);
    swapl(&stuff->window);
    return ProcDMXGetWindowAttributes(client);
}

static int
SProcDMXGetDesktopAttributes(ClientPtr client)
{
    REQUEST(xDMXGetDesktopAttributesReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDMXGetDesktopAttributesReq);
    return ProcDMXGetDesktopAttributes(client);
}

static int
SProcDMXChangeDesktopAttributes(ClientPtr client)
{
    REQUEST(xDMXChangeDesktopAttributesReq);

    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xDMXChangeDesktopAttributesReq);
    swapl(&stuff->valueMask);
    SwapRestL(stuff);
    return ProcDMXChangeDesktopAttributes(client);
}

static int
SProcDMXGetInputCount(ClientPtr client)
{
    REQUEST(xDMXGetInputCountReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDMXGetInputCountReq);
    return ProcDMXGetInputCount(client);
}

static int
SProcDMXGetInputAttributes(ClientPtr client)
{
    REQUEST(xDMXGetInputAttributesReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDMXGetInputAttributesReq);
    swapl(&stuff->deviceId);
    return ProcDMXGetInputAttributes(client);
}

static int
SProcDMXAddInput(ClientPtr client)
{
    int paddedLength;

    REQUEST(xDMXAddInputReq);

    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xDMXAddInputReq);
    swapl(&stuff->displayNameLength);
    swapl(&stuff->valueMask);
    paddedLength = pad_to_int32(stuff->displayNameLength);
    SwapLongs((CARD32 *) (stuff + 1), LengthRestL(stuff) - paddedLength / 4);
    return ProcDMXAddInput(client);
}

static int
SProcDMXRemoveInput(ClientPtr client)
{
    REQUEST(xDMXRemoveInputReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xDMXRemoveInputReq);
    swapl(&stuff->physicalId);
    return ProcDMXRemoveInput(client);
}

static int
SProcDMXDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_DMXQueryVersion:
        return SProcDMXQueryVersion(client);
    case X_DMXSync:
        return SProcDMXSync(client);
    case X_DMXForceWindowCreation:
        return SProcDMXForceWindowCreation(client);
    case X_DMXGetScreenCount:
        return SProcDMXGetScreenCount(client);
    case X_DMXGetScreenAttributes:
        return SProcDMXGetScreenAttributes(client);
    case X_DMXChangeScreensAttributes:
        return SProcDMXChangeScreensAttributes(client);
    case X_DMXAddScreen:
        return SProcDMXAddScreen(client);
    case X_DMXRemoveScreen:
        return SProcDMXRemoveScreen(client);
    case X_DMXGetWindowAttributes:
        return SProcDMXGetWindowAttributes(client);
    case X_DMXGetDesktopAttributes:
        return SProcDMXGetDesktopAttributes(client);
    case X_DMXChangeDesktopAttributes:
        return SProcDMXChangeDesktopAttributes(client);
    case X_DMXGetInputCount:
        return SProcDMXGetInputCount(client);
    case X_DMXGetInputAttributes:
        return SProcDMXGetInputAttributes(client);
    case X_DMXAddInput:
        return SProcDMXAddInput(client);
    case X_DMXRemoveInput:
        return SProcDMXRemoveInput(client);

    case X_DMXGetScreenInformationDEPRECATED:
    case X_DMXForceWindowCreationDEPRECATED:
    case X_DMXReconfigureScreenDEPRECATED:
        return BadImplementation;

    default:
        return BadRequest;
    }
}

/** Initialize the extension. */
void
DMXExtensionInit(void)
{
    ExtensionEntry *extEntry;

    if ((extEntry = AddExtension(DMX_EXTENSION_NAME, 0, 0,
                                 ProcDMXDispatch, SProcDMXDispatch,
                                 NULL, StandardMinorOpcode)))
        DMXCode = extEntry->base;
}
@


1.10
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d430 1
a430 1
    if (!(attribs = malloc(stuff->screenCount * sizeof(*attribs))))
d627 1
a627 1
    if (!(screens = malloc(count * sizeof(*screens))))
d629 1
a629 1
    if (!(windows = malloc(count * sizeof(*windows)))) {
d633 1
a633 1
    if (!(pos = malloc(count * sizeof(*pos)))) {
d638 1
a638 1
    if (!(vis = malloc(count * sizeof(*vis)))) {
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d58 1
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d271 1
a271 1
        if (Success != dixLookupResourceByType((pointer *) &win,
d559 1
a559 1
    if (Success != dixLookupResourceByType((pointer *) &win,
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d55 1
a68 2
extern void DMXExtensionInit(void);

d76 2
a78 1
    return 0;
d210 8
a217 1
    xDMXQueryVersionReply rep;
a220 6
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.majorVersion = SERVER_DMX_MAJOR_VERSION;
    rep.minorVersion = SERVER_DMX_MINOR_VERSION;
    rep.patchVersion = SERVER_DMX_PATCH_VERSION;
d228 1
a228 1
    WriteToClient(client, sizeof(xDMXQueryVersionReply), (char *) &rep);
d241 6
a246 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.status = 0;
d252 1
a252 1
    WriteToClient(client, sizeof(xDMXSyncReply), (char *) &rep);
d293 6
a298 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.status = 0;
d304 1
a304 1
    WriteToClient(client, sizeof(xDMXForceWindowCreationReply), (char *) &rep);
d315 6
a320 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.screenCount = dmxGetNumScreens();
d326 1
a326 1
    WriteToClient(client, sizeof(xDMXGetScreenCountReply), (char *) &rep);
a347 12
    rep.logicalScreen = attr.logicalScreen;
    rep.screenWindowWidth = attr.screenWindowWidth;
    rep.screenWindowHeight = attr.screenWindowHeight;
    rep.screenWindowXoffset = attr.screenWindowXoffset;
    rep.screenWindowYoffset = attr.screenWindowYoffset;
    rep.rootWindowWidth = attr.rootWindowWidth;
    rep.rootWindowHeight = attr.rootWindowHeight;
    rep.rootWindowXoffset = attr.rootWindowXoffset;
    rep.rootWindowYoffset = attr.rootWindowYoffset;
    rep.rootWindowXorigin = attr.rootWindowXorigin;
    rep.rootWindowYorigin = attr.rootWindowYorigin;

d350 21
a370 7
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length =
        bytes_to_int32((sizeof(xDMXGetScreenAttributesReply) -
                        sizeof(xGenericReply))
                       + paddedLength);
    rep.displayNameLength = length;
d388 1
a388 1
    WriteToClient(client, sizeof(xDMXGetScreenAttributesReply), (char *) &rep);
d390 1
a390 1
        WriteToClient(client, length, (char *) attr.displayName);
d453 7
a459 5
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.status = status;
    rep.errorScreen = errorScreen;
d466 1
a466 2
    WriteToClient(client,
                  sizeof(xDMXChangeScreensAttributesReply), (char *) &rep);
d504 7
a510 5
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.status = status;
    rep.physicalScreen = stuff->physicalScreen;
d517 1
a517 1
    WriteToClient(client, sizeof(xDMXAddScreenReply), (char *) &rep);
d532 6
a537 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.status = status;
d543 1
a543 1
    WriteToClient(client, sizeof(xDMXRemoveScreenReply), (char *) &rep);
d653 6
a658 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = count * 6;
    rep.screenCount = count;
d681 1
a681 1
    WriteToClient(client, sizeof(xDMXGetWindowAttributesReply), (char *) &rep);
d683 4
a686 4
        WriteToClient(client, count * sizeof(*screens), (char *) screens);
        WriteToClient(client, count * sizeof(*windows), (char *) windows);
        WriteToClient(client, count * sizeof(*pos), (char *) pos);
        WriteToClient(client, count * sizeof(*vis), (char *) vis);
d707 9
a715 8
    rep.width = attr.width;
    rep.height = attr.height;
    rep.shiftX = attr.shiftX;
    rep.shiftY = attr.shiftY;

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
d725 1
a725 1
    WriteToClient(client, sizeof(xDMXGetDesktopAttributesReply), (char *) &rep);
d759 6
a764 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.status = status;
d770 1
a770 2
    WriteToClient(client,
                  sizeof(xDMXChangeDesktopAttributesReply), (char *) &rep);
d781 6
a786 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.inputCount = dmxGetInputCount();
d792 1
a792 1
    WriteToClient(client, sizeof(xDMXGetInputCountReply), (char *) &rep);
a808 6
    rep.inputType = attr.inputType;
    rep.physicalScreen = attr.physicalScreen;
    rep.physicalId = attr.physicalId;
    rep.isCore = attr.isCore;
    rep.sendsCore = attr.sendsCore;
    rep.detached = attr.detached;
d812 15
a826 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = bytes_to_int32(paddedLength);
    rep.nameLength = length;
d835 1
a835 1
    WriteToClient(client, sizeof(xDMXGetInputAttributesReply), (char *) &rep);
d837 1
a837 1
        WriteToClient(client, length, (char *) attr.name);
d878 7
a884 5
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.status = status;
    rep.physicalId = id;
d891 1
a891 1
    WriteToClient(client, sizeof(xDMXAddInputReply), (char *) &rep);
d909 6
a914 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.status = status;
d920 1
a920 1
    WriteToClient(client, sizeof(xDMXRemoveInputReply), (char *) &rep);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d65 1
a65 1
extern int           PanoramiXNumScreens;
d72 2
a73 3


static int _DMXXineramaActive(void)
d81 2
a82 2
static void dmxSetScreenAttribute(int bit, DMXScreenAttributesPtr attr,
                                  CARD32 value)
d85 30
a114 10
    case DMXScreenWindowWidth:   attr->screenWindowWidth   = value; break;
    case DMXScreenWindowHeight:  attr->screenWindowHeight  = value; break;
    case DMXScreenWindowXoffset: attr->screenWindowXoffset = value; break;
    case DMXScreenWindowYoffset: attr->screenWindowYoffset = value; break;
    case DMXRootWindowWidth:     attr->rootWindowWidth     = value; break;
    case DMXRootWindowHeight:    attr->rootWindowHeight    = value; break;
    case DMXRootWindowXoffset:   attr->rootWindowXoffset   = value; break;
    case DMXRootWindowYoffset:   attr->rootWindowYoffset   = value; break;
    case DMXRootWindowXorigin:   attr->rootWindowXorigin   = value; break;
    case DMXRootWindowYorigin:   attr->rootWindowYorigin   = value; break;
d118 3
a120 3
static int dmxFetchScreenAttributes(unsigned int mask,
                                    DMXScreenAttributesPtr attr,
                                    CARD32 *value_list)
d122 1
a122 1
    int    i;
d124 2
a125 2
    int    count  = 0;
        
d136 2
a137 2
static void dmxSetDesktopAttribute(int bit, DMXDesktopAttributesPtr attr,
                                   CARD32 value)
d140 12
a151 4
    case DMXDesktopWidth:  attr->width  = value; break;
    case DMXDesktopHeight: attr->height = value; break;
    case DMXDesktopShiftX: attr->shiftX = value; break;
    case DMXDesktopShiftY: attr->shiftY = value; break;
d155 3
a157 3
static int dmxFetchDesktopAttributes(unsigned int mask,
                                     DMXDesktopAttributesPtr attr,
                                     CARD32 *value_list)
d159 1
a159 1
    int    i;
d161 2
a162 2
    int    count  = 0;
        
d166 1
a166 1
	    ++value;
d173 2
a174 2
static void dmxSetInputAttribute(int bit, DMXInputAttributesPtr attr,
                                 CARD32 value)
d177 9
a185 3
    case DMXInputType:           attr->inputType      = value;   break;
    case DMXInputPhysicalScreen: attr->physicalScreen = value;   break;
    case DMXInputSendsCore:      attr->sendsCore      = !!value; break;
d189 3
a191 3
static int dmxFetchInputAttributes(unsigned int mask,
                                   DMXInputAttributesPtr attr,
                                   CARD32 *value_list)
d193 1
a193 1
    int    i;
d195 1
a195 1
    int    count  = 0;
d207 2
a208 1
static int ProcDMXQueryVersion(ClientPtr client)
a210 1
    int                   n;
d214 1
a214 1
    rep.type           = X_Reply;
d216 4
a219 4
    rep.length         = 0;
    rep.majorVersion   = SERVER_DMX_MAJOR_VERSION;
    rep.minorVersion   = SERVER_DMX_MINOR_VERSION;
    rep.patchVersion   = SERVER_DMX_PATCH_VERSION;
d221 5
a225 5
    	swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
	swapl(&rep.majorVersion, n);
	swapl(&rep.minorVersion, n);
	swapl(&rep.patchVersion, n);
d227 1
a227 1
    WriteToClient(client, sizeof(xDMXQueryVersionReply), (char *)&rep);
d231 2
a232 1
static int ProcDMXSync(ClientPtr client)
a234 1
    int           n;
d240 1
a240 1
    rep.type           = X_Reply;
d242 2
a243 2
    rep.length         = 0;
    rep.status         = 0;
d245 3
a247 3
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.status, n);
d249 1
a249 1
    WriteToClient(client, sizeof(xDMXSyncReply), (char *)&rep);
d253 2
a254 1
static int ProcDMXForceWindowCreation(ClientPtr client)
d257 1
d259 1
a259 2
    WindowPtr     pWin;
    int           n;
d266 1
a266 1
        int          i;
d268 4
a271 4
        if (Success != dixLookupResourceByType((pointer*) &win,
					       stuff->window, XRT_WINDOW,
					       client, DixReadAccess))
            return -1;           /* BadWindow */
d275 2
a276 2
					   DixReadAccess))
                return -1;       /* BadWindow */
d284 2
a285 3
    if (Success != dixLookupWindow(&pWin, stuff->window, client,
				   DixReadAccess))
        return -1;               /* BadWindow */
d288 1
a288 1
  doreply:
d290 1
a290 1
    rep.type           = X_Reply;
d292 2
a293 2
    rep.length         = 0;
    rep.status         = 0;
d295 3
a297 3
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.status, n);
d299 1
a299 1
    WriteToClient(client, sizeof(xDMXForceWindowCreationReply), (char *)&rep);
d303 2
a304 1
static int ProcDMXGetScreenCount(ClientPtr client)
a306 1
    int                     n;
d310 1
a310 1
    rep.type           = X_Reply;
d312 2
a313 2
    rep.length         = 0;
    rep.screenCount    = dmxGetNumScreens();
d315 3
a317 3
    	swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.screenCount, n);
d319 1
a319 1
    WriteToClient(client, sizeof(xDMXGetScreenCountReply), (char *)&rep);
d323 2
a324 1
static int ProcDMXGetScreenAttributes(ClientPtr client)
d328 3
a330 4
    int                          n;
    int                          length;
    int                          paddedLength;
    DMXScreenAttributesRec       attr;
d335 2
a336 1
        || stuff->physicalScreen >= dmxGetNumScreens()) return BadValue;
d341 3
a343 3
    rep.logicalScreen       = attr.logicalScreen;
    rep.screenWindowWidth   = attr.screenWindowWidth;
    rep.screenWindowHeight  = attr.screenWindowHeight;
d346 16
a361 14
    rep.rootWindowWidth     = attr.rootWindowWidth;
    rep.rootWindowHeight    = attr.rootWindowHeight;
    rep.rootWindowXoffset   = attr.rootWindowXoffset;
    rep.rootWindowYoffset   = attr.rootWindowYoffset;
    rep.rootWindowXorigin   = attr.rootWindowXorigin;
    rep.rootWindowYorigin   = attr.rootWindowYorigin;
                                 
    length                  = attr.displayName ? strlen(attr.displayName) : 0;
    paddedLength            = pad_to_int32(length);
    rep.type                = X_Reply;
    rep.sequenceNumber      = client->sequence;
    rep.length              = bytes_to_int32((sizeof(xDMXGetScreenAttributesReply) - sizeof(xGenericReply))
                                             + paddedLength);
    rep.displayNameLength   = length;
d364 18
a381 17
    	swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.displayNameLength, n);
        swapl(&rep.logicalScreen, n);
        swaps(&rep.screenWindowWidth, n);
        swaps(&rep.screenWindowHeight, n);
        swaps(&rep.screenWindowXoffset, n);
        swaps(&rep.screenWindowYoffset, n);
        swaps(&rep.rootWindowWidth, n);
        swaps(&rep.rootWindowHeight, n);
        swaps(&rep.rootWindowXoffset, n);
        swaps(&rep.rootWindowYoffset, n);
        swaps(&rep.rootWindowXorigin, n);
        swaps(&rep.rootWindowYorigin, n);
    }
    WriteToClient(client, sizeof(xDMXGetScreenAttributesReply), (char *)&rep);
    if (length) WriteToClient(client, length, (char *)attr.displayName);
d385 2
a386 1
static int ProcDMXChangeScreensAttributes(ClientPtr client)
d390 10
a399 12
    int                              n;
    int                              status = DMX_BAD_XINERAMA;
    unsigned int                     mask   = 0;
    unsigned int                     i;
    CARD32                           *screen_list;
    CARD32                           *mask_list;
    CARD32                           *value_list;
    DMXScreenAttributesPtr           attribs;
    int                              errorScreen = 0;
    unsigned int                     len;
    int                              ones = 0;
    
d402 3
a404 1
    len = client->req_len - bytes_to_int32(sizeof(xDMXChangeScreensAttributesReq));
d408 3
a410 3
    screen_list = (CARD32 *)(stuff + 1);
    mask_list   = &screen_list[stuff->screenCount];
    value_list  = &mask_list[stuff->maskCount];
d412 2
a413 1
    for (i = 0; i < stuff->maskCount; i++) ones += Ones(mask_list[i]);
d416 3
a418 2
    
    if (!_DMXXineramaActive()) goto noxinerama;
d425 3
a427 2
        
        if (i < stuff->maskCount) mask = mask_list[i];
d435 1
a435 3
				       screen_list,
				       attribs,
				       &errorScreen);
d440 2
a441 1
    if (status == BadValue) return status;
d443 2
a444 2
  noxinerama:
    rep.type           = X_Reply;
d446 3
a448 3
    rep.length         = 0;
    rep.status         = status;
    rep.errorScreen    = errorScreen;
d450 4
a453 4
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.status, n);
        swapl(&rep.errorScreen, n);
d456 1
a456 2
                  sizeof(xDMXChangeScreensAttributesReply),
                  (char *)&rep);
d460 2
a461 1
static int ProcDMXAddScreen(ClientPtr client)
d464 3
a466 4
    xDMXAddScreenReply     rep;
    int                    n;
    int                    status = 0;
    CARD32                 *value_list;
d468 4
a471 4
    int                    count;
    char                   *name;
    int                    len;
    int                    paddedLength;
d475 2
a476 2
    len          = client->req_len - bytes_to_int32(sizeof(xDMXAddScreenReq));
    if (len != Ones(stuff->valueMask) + paddedLength/4)
d481 3
a483 3
    value_list = (CARD32 *)(stuff + 1);
    count      = dmxFetchScreenAttributes(stuff->valueMask, &attr, value_list);
    
d494 1
a494 1
    rep.type           = X_Reply;
d496 2
a497 2
    rep.length         = 0;
    rep.status         = status;
d500 4
a503 4
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.status, n);
        swapl(&rep.physicalScreen, n);
d505 1
a505 3
    WriteToClient(client,
                  sizeof(xDMXAddScreenReply),
                  (char *)&rep);
d509 2
a510 1
static int ProcDMXRemoveScreen(ClientPtr client)
d514 1
a514 2
    int                   n;
    int                   status = 0;
d520 1
a520 1
    rep.type           = X_Reply;
d522 2
a523 2
    rep.length         = 0;
    rep.status         = status;
d525 3
a527 3
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.status, n);
d529 1
a529 3
    WriteToClient(client,
                  sizeof(xDMXRemoveScreenReply),
                  (char *)&rep);
a532 1

d534 9
a542 8
static int dmxPopulatePanoramiX(ClientPtr client, Window window,
                                CARD32 *screens, CARD32 *windows,
                                xRectangle *pos, xRectangle *vis)
{
    WindowPtr              pWin;
    PanoramiXRes           *win;
    int                    i;
    int                    count = 0;
d544 6
a549 6
    
    if (Success != dixLookupResourceByType((pointer*) &win,
					   window, XRT_WINDOW,
					   client, DixReadAccess))
        return -1;               /* BadWindow */
    
d552 1
a552 1
				       DixReadAccess))
d557 2
a558 2
            pos[count]     = attr.pos;
            vis[count]     = attr.vis;
d566 3
a568 2
static int dmxPopulate(ClientPtr client, Window window, CARD32 *screens,
                       CARD32 *windows, xRectangle *pos, xRectangle *vis)
d570 1
a570 1
    WindowPtr              pWin;
d575 1
a575 2
        return dmxPopulatePanoramiX(client, window, screens, windows,
                                    pos, vis);
d577 1
a577 1
    
d579 1
a579 1
        return -1;               /* BadWindow */
d584 2
a585 2
    *pos     = attr.pos;
    *vis     = attr.vis;
d589 2
a590 1
static int dmxMaxNumScreens(void)
d593 2
a594 1
    if (!noPanoramiXExtension) return PanoramiXNumScreens;
d599 2
a600 1
static int ProcDMXGetWindowAttributes(ClientPtr client)
d604 5
a608 5
    int                          i, n;
    CARD32                       *screens;
    CARD32                       *windows;
    xRectangle                   *pos, *vis;
    int                          count = dmxMaxNumScreens();
d639 1
a639 1
    rep.type           = X_Reply;
d641 2
a642 2
    rep.length         = count * 6;
    rep.screenCount    = count;
d644 3
a646 3
    	swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.screenCount, n);
d648 12
a659 12
            swapl(&screens[i], n);
            swapl(&windows[i], n);
            
            swaps(&pos[i].x, n);
            swaps(&pos[i].y, n);
            swaps(&pos[i].width, n);
            swaps(&pos[i].height, n);
            
            swaps(&vis[i].x, n);
            swaps(&vis[i].y, n);
            swaps(&vis[i].width, n);
            swaps(&vis[i].height, n);
d665 1
a665 1
    WriteToClient(client, sizeof(xDMXGetWindowAttributesReply), (char *)&rep);
d667 4
a670 4
        WriteToClient(client, count * sizeof(*screens), (char *)screens);
        WriteToClient(client, count * sizeof(*windows), (char *)windows);
        WriteToClient(client, count * sizeof(*pos),     (char *)pos);
        WriteToClient(client, count * sizeof(*vis),     (char *)vis);
d681 2
a682 1
static int ProcDMXGetDesktopAttributes(ClientPtr client)
d685 1
a685 2
    int                           n;
    DMXDesktopAttributesRec       attr;
d691 8
a698 8
    rep.width               = attr.width;
    rep.height              = attr.height;
    rep.shiftX              = attr.shiftX;
    rep.shiftY              = attr.shiftY;

    rep.type                = X_Reply;
    rep.sequenceNumber      = client->sequence;
    rep.length              = 0;
d701 6
a706 6
    	swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.width, n);
        swapl(&rep.height, n);
        swapl(&rep.shiftX, n);
        swapl(&rep.shiftY, n);
d708 1
a708 1
    WriteToClient(client, sizeof(xDMXGetDesktopAttributesReply), (char *)&rep);
d712 2
a713 1
static int ProcDMXChangeDesktopAttributes(ClientPtr client)
d717 4
a720 5
    int                              n;
    int                              status = DMX_BAD_XINERAMA;
    CARD32                           *value_list;
    DMXDesktopAttributesRec          attr;
    int                              len;
d727 4
a730 1
    if (!_DMXXineramaActive()) goto noxinerama;
a731 2
    value_list = (CARD32 *)(stuff + 1);
    
d738 2
a739 1
    if (status == BadValue) return status;
d741 2
a742 2
  noxinerama:
    rep.type           = X_Reply;
d744 2
a745 2
    rep.length         = 0;
    rep.status         = status;
d747 3
a749 3
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.status, n);
d752 1
a752 2
                  sizeof(xDMXChangeDesktopAttributesReply),
                  (char *)&rep);
d756 2
a757 1
static int ProcDMXGetInputCount(ClientPtr client)
a759 1
    int                     n;
d763 1
a763 1
    rep.type           = X_Reply;
d765 2
a766 2
    rep.length         = 0;
    rep.inputCount     = dmxGetInputCount();
d768 3
a770 3
    	swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.inputCount, n);
d772 1
a772 1
    WriteToClient(client, sizeof(xDMXGetInputCountReply), (char *)&rep);
d776 2
a777 1
static int ProcDMXGetInputAttributes(ClientPtr client)
d781 3
a783 4
    int                          n;
    int                          length;
    int                          paddedLength;
    DMXInputAttributesRec        attr;
d787 3
a789 2
    if (dmxGetInputAttributes(stuff->deviceId, &attr)) return BadValue;
    rep.inputType      = attr.inputType;
d791 8
a798 8
    rep.physicalId     = attr.physicalId;
    rep.isCore         = attr.isCore;
    rep.sendsCore      = attr.sendsCore;
    rep.detached       = attr.detached;
    
    length             = attr.name ? strlen(attr.name) : 0;
    paddedLength       = pad_to_int32(length);
    rep.type           = X_Reply;
d800 2
a801 2
    rep.length         = bytes_to_int32(paddedLength);
    rep.nameLength     = length;
d803 10
a812 9
    	swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.inputType, n);
        swapl(&rep.physicalScreen, n);
        swapl(&rep.physicalId, n);
        swapl(&rep.nameLength, n);
    }
    WriteToClient(client, sizeof(xDMXGetInputAttributesReply), (char *)&rep);
    if (length) WriteToClient(client, length, (char *)attr.name);
d816 2
a817 1
static int ProcDMXAddInput(ClientPtr client)
d820 9
a828 10
    xDMXAddInputReply      rep;
    int                    n;
    int                    status = 0;
    CARD32                 *value_list;
    DMXInputAttributesRec  attr;
    int                    count;
    char                   *name;
    int                    len;
    int                    paddedLength;
    int                    id     = -1;
d832 2
a833 2
    len          = client->req_len - (sizeof(xDMXAddInputReq) >> 2);
    if (len != Ones(stuff->valueMask) + paddedLength/4)
d837 3
a839 3
    value_list = (CARD32 *)(stuff + 1);
    count      = dmxFetchInputAttributes(stuff->valueMask, &attr, value_list);
    
d850 2
a851 1
    if (status) return status;
d853 1
a853 1
    rep.type           = X_Reply;
d855 3
a857 3
    rep.length         = 0;
    rep.status         = status;
    rep.physicalId     = id;
d859 4
a862 4
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.status, n);
        swapl(&rep.physicalId, n);
d864 1
a864 1
    WriteToClient(client, sizeof(xDMXAddInputReply), (char *)&rep);
d868 2
a869 1
static int ProcDMXRemoveInput(ClientPtr client)
d872 2
a873 3
    xDMXRemoveInputReply     rep;
    int                      n;
    int                      status = 0;
d879 2
a880 1
    if (status) return status;
d882 1
a882 1
    rep.type           = X_Reply;
d884 2
a885 2
    rep.length         = 0;
    rep.status         = status;
d887 3
a889 3
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.status, n);
d891 1
a891 1
    WriteToClient(client, sizeof(xDMXRemoveInputReply), (char *)&rep);
d895 2
a896 1
static int ProcDMXDispatch(ClientPtr client)
d901 10
a910 5
    case X_DMXQueryVersion:         return ProcDMXQueryVersion(client);
    case X_DMXSync:                 return ProcDMXSync(client);
    case X_DMXForceWindowCreation:  return ProcDMXForceWindowCreation(client);
    case X_DMXGetScreenCount:       return ProcDMXGetScreenCount(client);
    case X_DMXGetScreenAttributes:  return ProcDMXGetScreenAttributes(client);
d913 8
a920 4
    case X_DMXAddScreen:            return ProcDMXAddScreen(client);
    case X_DMXRemoveScreen:         return ProcDMXRemoveScreen(client);
    case X_DMXGetWindowAttributes:  return ProcDMXGetWindowAttributes(client);
    case X_DMXGetDesktopAttributes: return ProcDMXGetDesktopAttributes(client);
d923 9
a931 5
    case X_DMXGetInputCount:        return ProcDMXGetInputCount(client);
    case X_DMXGetInputAttributes:   return ProcDMXGetInputAttributes(client);
    case X_DMXAddInput:             return ProcDMXAddInput(client);
    case X_DMXRemoveInput:          return ProcDMXRemoveInput(client);
        
d937 2
a938 1
    default:                        return BadRequest;
d942 2
a943 1
static int SProcDMXQueryVersion(ClientPtr client)
a944 1
    int n;
d947 1
a947 1
    swaps(&stuff->length, n);
d952 2
a953 1
static int SProcDMXSync(ClientPtr client)
a954 1
    int n;
d957 1
a957 1
    swaps(&stuff->length, n);
d962 2
a963 1
static int SProcDMXForceWindowCreation(ClientPtr client)
a964 1
    int n;
d967 1
a967 1
    swaps(&stuff->length, n);
d969 1
a969 1
    swaps(&stuff->window, n);
d973 2
a974 1
static int SProcDMXGetScreenCount(ClientPtr client)
a975 1
    int n;
d978 1
a978 1
    swaps(&stuff->length, n);
d983 2
a984 1
static int SProcDMXGetScreenAttributes(ClientPtr client)
a985 1
    int n;
d988 1
a988 1
    swaps(&stuff->length, n);
d990 1
a990 1
    swapl(&stuff->physicalScreen, n);
d994 2
a995 1
static int SProcDMXChangeScreensAttributes(ClientPtr client)
a996 1
    int n;
d999 1
a999 1
    swaps(&stuff->length, n);
d1001 2
a1002 2
    swapl(&stuff->screenCount, n);
    swapl(&stuff->maskCount, n);
d1007 2
a1008 1
static int SProcDMXAddScreen(ClientPtr client)
a1009 1
    int n;
d1011 1
d1014 1
a1014 1
    swaps(&stuff->length, n);
d1016 2
a1017 2
    swapl(&stuff->displayNameLength, n);
    swapl(&stuff->valueMask, n);
d1019 1
a1019 1
    SwapLongs((CARD32 *)(stuff+1), LengthRestL(stuff) - paddedLength/4);
d1023 2
a1024 1
static int SProcDMXRemoveScreen(ClientPtr client)
a1025 1
    int n;
d1028 1
a1028 1
    swaps(&stuff->length, n);
d1030 1
a1030 1
    swapl(&stuff->physicalScreen, n);
d1034 2
a1035 1
static int SProcDMXGetWindowAttributes(ClientPtr client)
a1036 1
    int n;
d1039 1
a1039 1
    swaps(&stuff->length, n);
d1041 1
a1041 1
    swapl(&stuff->window, n);
d1045 2
a1046 1
static int SProcDMXGetDesktopAttributes(ClientPtr client)
a1047 1
    int n;
d1050 1
a1050 1
    swaps(&stuff->length, n);
d1055 2
a1056 1
static int SProcDMXChangeDesktopAttributes(ClientPtr client)
a1057 1
    int n;
d1060 1
a1060 1
    swaps(&stuff->length, n);
d1062 1
a1062 1
    swapl(&stuff->valueMask, n);
d1067 2
a1068 1
static int SProcDMXGetInputCount(ClientPtr client)
a1069 1
    int n;
d1072 1
a1072 1
    swaps(&stuff->length, n);
d1077 2
a1078 1
static int SProcDMXGetInputAttributes(ClientPtr client)
a1079 1
    int n;
d1082 1
a1082 1
    swaps(&stuff->length, n);
d1084 1
a1084 1
    swapl(&stuff->deviceId, n);
d1088 2
a1089 1
static int SProcDMXAddInput(ClientPtr client)
a1090 1
    int n;
d1092 1
d1095 1
a1095 1
    swaps(&stuff->length, n);
d1097 2
a1098 2
    swapl(&stuff->displayNameLength, n);
    swapl(&stuff->valueMask, n);
d1100 1
a1100 1
    SwapLongs((CARD32 *)(stuff+1), LengthRestL(stuff) - paddedLength/4);
d1104 2
a1105 1
static int SProcDMXRemoveInput(ClientPtr client)
a1106 1
    int n;
d1109 1
a1109 1
    swaps(&stuff->length, n);
d1111 1
a1111 1
    swapl(&stuff->physicalId, n);
d1115 2
a1116 1
static int SProcDMXDispatch (ClientPtr client)
d1121 10
a1130 5
    case X_DMXQueryVersion:         return SProcDMXQueryVersion(client);
    case X_DMXSync:                 return SProcDMXSync(client);
    case X_DMXForceWindowCreation:  return SProcDMXForceWindowCreation(client);
    case X_DMXGetScreenCount:       return SProcDMXGetScreenCount(client);
    case X_DMXGetScreenAttributes:  return SProcDMXGetScreenAttributes(client);
d1133 6
a1138 3
    case X_DMXAddScreen:            return SProcDMXAddScreen(client);
    case X_DMXRemoveScreen:         return SProcDMXRemoveScreen(client);
    case X_DMXGetWindowAttributes:  return SProcDMXGetWindowAttributes(client);
d1143 9
a1151 5
    case X_DMXGetInputCount:        return SProcDMXGetInputCount(client);
    case X_DMXGetInputAttributes:   return SProcDMXGetInputAttributes(client);
    case X_DMXAddInput:             return SProcDMXAddInput(client);
    case X_DMXRemoveInput:          return SProcDMXRemoveInput(client);
        
d1157 2
a1158 1
    default:                        return BadRequest;
d1163 2
a1164 1
void DMXExtensionInit(void)
d1167 1
a1167 1
    
d1171 1
a1171 1
	DMXCode = extEntry->base;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d72 1
a72 33
static DISPATCH_PROC(ProcDMXDispatch);
static DISPATCH_PROC(ProcDMXQueryVersion);
static DISPATCH_PROC(ProcDMXSync);
static DISPATCH_PROC(ProcDMXForceWindowCreation);
static DISPATCH_PROC(ProcDMXGetScreenCount);
static DISPATCH_PROC(ProcDMXGetScreenAttributes);
static DISPATCH_PROC(ProcDMXChangeScreensAttributes);
static DISPATCH_PROC(ProcDMXAddScreen);
static DISPATCH_PROC(ProcDMXRemoveScreen);
static DISPATCH_PROC(ProcDMXGetWindowAttributes);
static DISPATCH_PROC(ProcDMXGetDesktopAttributes);
static DISPATCH_PROC(ProcDMXChangeDesktopAttributes);
static DISPATCH_PROC(ProcDMXGetInputCount);
static DISPATCH_PROC(ProcDMXGetInputAttributes);
static DISPATCH_PROC(ProcDMXAddInput);
static DISPATCH_PROC(ProcDMXRemoveInput);

static DISPATCH_PROC(SProcDMXDispatch);
static DISPATCH_PROC(SProcDMXQueryVersion);
static DISPATCH_PROC(SProcDMXSync);
static DISPATCH_PROC(SProcDMXForceWindowCreation);
static DISPATCH_PROC(SProcDMXGetScreenCount);
static DISPATCH_PROC(SProcDMXGetScreenAttributes);
static DISPATCH_PROC(SProcDMXChangeScreensAttributes);
static DISPATCH_PROC(SProcDMXAddScreen);
static DISPATCH_PROC(SProcDMXRemoveScreen);
static DISPATCH_PROC(SProcDMXGetWindowAttributes);
static DISPATCH_PROC(SProcDMXGetDesktopAttributes);
static DISPATCH_PROC(SProcDMXChangeDesktopAttributes);
static DISPATCH_PROC(SProcDMXGetInputCount);
static DISPATCH_PROC(SProcDMXGetInputAttributes);
static DISPATCH_PROC(SProcDMXAddInput);
static DISPATCH_PROC(SProcDMXRemoveInput);
a81 11
/** Initialize the extension. */
void DMXExtensionInit(void)
{
    ExtensionEntry *extEntry;
    
    if ((extEntry = AddExtension(DMX_EXTENSION_NAME, 0, 0,
                                 ProcDMXDispatch, SProcDMXDispatch,
                                 NULL, StandardMinorOpcode)))
	DMXCode = extEntry->base;
}

d234 3
a236 2
        if (!(win = SecurityLookupIDByType(client, stuff->window, XRT_WINDOW,
                                           DixReadAccess)))
d510 3
a512 2
    if (!(win = SecurityLookupIDByType(client, window, XRT_WINDOW,
                                       DixReadAccess)))
d1086 11
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d238 1
a238 1
    return client->noClientException;
d260 1
a260 1
    return client->noClientException;
d329 1
a329 1
    return client->noClientException;
d387 1
a387 1
    return client->noClientException;
d422 1
a422 1
    if (!(attribs = xalloc(stuff->screenCount * sizeof(*attribs))))
d441 1
a441 1
    xfree(attribs);
d460 1
a460 1
    return client->noClientException;
d487 1
a487 1
    if (!(name = xalloc(stuff->displayNameLength + 1 + 4)))
d495 1
a495 1
    xfree(name);
d511 1
a511 1
    return client->noClientException;
d537 1
a537 1
    return client->noClientException;
d615 1
a615 1
    if (!(screens = xalloc(count * sizeof(*screens))))
d617 2
a618 2
    if (!(windows = xalloc(count * sizeof(*windows)))) {
        xfree(screens);
d621 3
a623 3
    if (!(pos = xalloc(count * sizeof(*pos)))) {
        xfree(windows);
        xfree(screens);
d626 4
a629 4
    if (!(vis = xalloc(count * sizeof(*vis)))) {
        xfree(pos);
        xfree(windows);
        xfree(screens);
d635 4
a638 4
        xfree(vis);
        xfree(pos);
        xfree(windows);
        xfree(screens);
d676 4
a679 4
    xfree(vis);
    xfree(pos);
    xfree(windows);
    xfree(screens);
d681 1
a681 1
    return client->noClientException;
d712 1
a712 1
    return client->noClientException;
d755 1
a755 1
    return client->noClientException;
d775 1
a775 1
    return client->noClientException;
d813 1
a813 1
    return client->noClientException;
d840 1
a840 1
    if (!(name = xalloc(stuff->displayNameLength + 1 + 4)))
d848 1
a848 1
    xfree(name);
d864 1
a864 1
    return client->noClientException;
d890 1
a890 1
    return client->noClientException;
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d40 1
a40 1
 * Much of the low-level work is done by functions in #dmxextension.c
a53 1
#define EXTENSION_PROC_ARGS void *
d59 2
a60 3

#define _DMX_SERVER_
#include <X11/extensions/dmxext.h>
d227 3
a229 3
    rep.majorVersion   = DMX_EXTENSION_MAJOR;
    rep.minorVersion   = DMX_EXTENSION_MINOR;
    rep.patchVersion   = DMX_EXTENSION_PATCH;
d362 1
a362 1
    paddedLength            = (length + 3) & ~3;
d365 2
a366 1
    rep.length              = paddedLength >> 2;
d408 1
a408 1
    len = client->req_len - (sizeof(xDMXChangeScreensAttributesReq) >> 2);
d477 2
a478 2
    paddedLength = (stuff->displayNameLength + 3) & ~3;
    len          = client->req_len - (sizeof(xDMXAddScreenReq) >> 2);
d798 1
a798 1
    paddedLength       = (length + 3) & ~3;
d801 1
a801 1
    rep.length         = paddedLength >> 2;
d831 1
a831 1
    paddedLength = (stuff->displayNameLength + 3) & ~3;
d1000 1
a1000 1
    paddedLength = (stuff->displayNameLength + 3) & ~3;
d1080 1
a1080 1
    paddedLength = (stuff->displayNameLength + 3) & ~3;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a115 4
static void DMXResetProc(ExtensionEntry *extEntry)
{
}

d123 1
a123 1
                                 DMXResetProc, StandardMinorOpcode)))
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
d284 1
a284 1
                                           SecurityReadAccess)))
d288 2
a289 2
            if (!(pWin = SecurityLookupWindow(win->info[i].id, client,
                                              SecurityReadAccess)))
d298 2
a299 2
    if (!(pWin = SecurityLookupWindow(stuff->window, client,
                                      SecurityReadAccess)))
d427 1
a427 1
    if (!(attribs = ALLOCATE_LOCAL(stuff->screenCount * sizeof(*attribs))))
d446 1
a446 1
    DEALLOCATE_LOCAL(attribs);
d492 1
a492 1
    if (!(name = ALLOCATE_LOCAL(stuff->displayNameLength + 1 + 4)))
d500 1
a500 1
    DEALLOCATE_LOCAL(name);
d558 1
a558 1
                                       SecurityReadAccess)))
d562 2
a563 2
        if (!(pWin = SecurityLookupWindow(win->info[i].id, client,
                                          SecurityReadAccess)))
d589 1
a589 1
    if (!(pWin = SecurityLookupWindow(window, client, SecurityReadAccess)))
d620 1
a620 1
    if (!(screens = ALLOCATE_LOCAL(count * sizeof(*screens))))
d622 2
a623 2
    if (!(windows = ALLOCATE_LOCAL(count * sizeof(*windows)))) {
        DEALLOCATE_LOCAL(screens);
d626 3
a628 3
    if (!(pos = ALLOCATE_LOCAL(count * sizeof(*pos)))) {
        DEALLOCATE_LOCAL(windows);
        DEALLOCATE_LOCAL(screens);
d631 4
a634 4
    if (!(vis = ALLOCATE_LOCAL(count * sizeof(*vis)))) {
        DEALLOCATE_LOCAL(pos);
        DEALLOCATE_LOCAL(windows);
        DEALLOCATE_LOCAL(screens);
d640 4
a643 4
        DEALLOCATE_LOCAL(vis);
        DEALLOCATE_LOCAL(pos);
        DEALLOCATE_LOCAL(windows);
        DEALLOCATE_LOCAL(screens);
d681 4
a684 4
    DEALLOCATE_LOCAL(vis);
    DEALLOCATE_LOCAL(pos);
    DEALLOCATE_LOCAL(windows);
    DEALLOCATE_LOCAL(screens);
d845 1
a845 1
    if (!(name = ALLOCATE_LOCAL(stuff->displayNameLength + 1 + 4)))
d853 1
a853 1
    DEALLOCATE_LOCAL(name);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
d285 1
a285 1
                                           DixReadAccess)))
d289 2
a290 2
            if (Success != dixLookupWindow(&pWin, win->info[i].id, client,
					   DixReadAccess))
d299 2
a300 2
    if (Success != dixLookupWindow(&pWin, stuff->window, client,
				   DixReadAccess))
d559 1
a559 1
                                       DixReadAccess)))
d563 2
a564 2
        if (Success != dixLookupWindow(&pWin, win->info[i].id, client,
				       DixReadAccess))
d590 1
a590 1
    if (Success != dixLookupWindow(&pWin, window, client, DixReadAccess))
@

