head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.10
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.8
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.16;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.02.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@/*
 * Copyright 2001-2003 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Kevin E. Martin <kem@@redhat.com>
 *   David H. Dawes <dawes@@xfree86.org>
 *   Rickard E. (Rik) Faith <faith@@redhat.com>
 *
 */

/** \file
 * Main header file included by all other DMX-related files.
 */

/** \mainpage
 * - <a href="http://dmx.sourceforge.net">DMX Home Page</a>
 * - <a href="http://sourceforge.net/projects/dmx">DMX Project Page (on
 * Source Forge)</a>
 * - <a href="http://dmx.sourceforge.net/dmx.html">Distributed Multihead
 * X design</a>, the design document for DMX
 * - <a href="http://dmx.sourceforge.net/DMXSpec.txt">Client-to-Server
 * DMX Extension to the X Protocol</a>
 */

#ifndef DMX_H
#define DMX_H

#if HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include "gcstruct.h"

/* Handle client-side include files in one place. */
#include "dmxclient.h"

#include "globals.h"
#include "scrnintstr.h"

#include "picturestr.h"

#ifdef GLXEXT
#include <GL/glx.h>
#include <GL/glxint.h>
#endif

typedef enum {
    PosNone = -1,
    PosAbsolute = 0,
    PosRightOf,
    PosLeftOf,
    PosAbove,
    PosBelow,
    PosRelative
} PositionType;

/** Provide the typedef globally, but keep the contents opaque outside
 * of the input routines.  \see dmxinput.h */
typedef struct _DMXInputInfo DMXInputInfo;

/** Provide the typedef globally, but keep the contents opaque outside
 * of the XSync statistic routines.  \see dmxstat.c */
typedef struct _DMXStatInfo DMXStatInfo;

/** Global structure containing information about each backend screen. */
typedef struct _DMXScreenInfo {
    const char *name;             /**< Name from command line or config file */
    int index;                    /**< Index into dmxScreens global          */

    /*---------- Back-end X server information ----------*/

    Display *beDisplay;           /**< Back-end X server's display */
    int beWidth;                  /**< Width of BE display */
    int beHeight;                 /**< Height of BE display */
    int beDepth;                  /**< Depth of BE display */
    int beBPP;                    /**< Bits per pixel of BE display */
    int beXDPI;                   /**< Horizontal dots per inch of BE */
    int beYDPI;                   /**< Vertical dots per inch of BE */

    int beNumDepths;              /**< Number of depths on BE server */
    int *beDepths;                /**< Depths from BE server */

    int beNumPixmapFormats;           /**< Number of pixmap formats on BE */
    XPixmapFormatValues *bePixmapFormats; /**< Pixmap formats on BE */

    int beNumVisuals;             /**< Number of visuals on BE */
    XVisualInfo *beVisuals;       /**< Visuals from BE server */
    int beDefVisualIndex;           /**< Default visual index of BE */

    int beNumDefColormaps;           /**< Number of default colormaps */
    Colormap *beDefColormaps;     /**< Default colormaps for DMX server */

    Pixel beBlackPixel;           /**< Default black pixel for BE */
    Pixel beWhitePixel;           /**< Default white pixel for BE */

    /*---------- Screen window information ----------*/

    Window scrnWin;               /**< "Screen" window on backend display */
    int scrnX;                    /**< X offset of "screen" WRT BE display */
    int scrnY;                    /**< Y offset of "screen" WRT BE display */
    int scrnWidth;                /**< Width of "screen" */
    int scrnHeight;               /**< Height of "screen" */
    int scrnXSign;                /**< X offset sign of "screen" */
    int scrnYSign;                /**< Y offset sign of "screen" */

                                  /** Default drawables for "screen" */
    Drawable scrnDefDrawables[MAXFORMATS];

    struct _DMXScreenInfo *next;  /**< List of "screens" on same display */
    struct _DMXScreenInfo *over;  /**< List of "screens" that overlap */

    /*---------- Root window information ----------*/

    Window rootWin;               /**< "Root" window on backend display */
    int rootX;                    /**< X offset of "root" window WRT "screen"*/
    int rootY;                    /**< Y offset of "root" window WRT "screen"*/
    int rootWidth;                /**< Width of "root" window */
    int rootHeight;               /**< Height of "root" window */

    int rootXOrigin;              /**< Global X origin of "root" window */
    int rootYOrigin;              /**< Global Y origin of "root" window */

    /*---------- Shadow framebuffer information ----------*/

    void *shadow;                 /**< Shadow framebuffer data (if enabled) */
    XlibGC shadowGC;              /**< Default GC used by shadow FB code */
    XImage *shadowFBImage;        /**< Screen image used by shadow FB code */

    /*---------- Other related information ----------*/

    int shared;                   /**< Non-zero if another Xdmx is running */

    Bool WMRunningOnBE;

    Cursor noCursor;
    Cursor curCursor;
    /* Support for cursors on overlapped
     * backend displays. */
    CursorPtr cursor;
    int cursorVisible;
    int cursorNotShared;        /* for overlapping screens on a backend */

    PositionType where;             /**< Relative layout information */
    int whereX;                     /**< Relative layout information */
    int whereY;                     /**< Relative layout information */
    int whereRefScreen;             /**< Relative layout information */

    int savedTimeout;               /**< Original screen saver timeout */
    int dpmsCapable;                /**< Non-zero if backend is DPMS capable */
    int dpmsEnabled;                /**< Non-zero if DPMS enabled */
    int dpmsStandby;                /**< Original DPMS standby value  */
    int dpmsSuspend;                /**< Original DPMS suspend value  */
    int dpmsOff;                    /**< Original DPMS off value  */

    DMXStatInfo *stat;              /**< Statistics about XSync  */
    Bool needsSync;                 /**< True if an XSync is pending  */

#ifdef GLXEXT
                                  /** Visual information for glxProxy */
    int numGlxVisuals;
    __GLXvisualConfig *glxVisuals;
    int glxMajorOpcode;
    int glxErrorBase;

                                  /** FB config information for glxProxy */
    __GLXFBConfig *fbconfigs;
    int numFBConfigs;
#endif

                                    /** Function pointers to wrapped screen
				     *  functions */
    CloseScreenProcPtr CloseScreen;
    SaveScreenProcPtr SaveScreen;

    CreateGCProcPtr CreateGC;

    CreateWindowProcPtr CreateWindow;
    DestroyWindowProcPtr DestroyWindow;
    PositionWindowProcPtr PositionWindow;
    ChangeWindowAttributesProcPtr ChangeWindowAttributes;
    RealizeWindowProcPtr RealizeWindow;
    UnrealizeWindowProcPtr UnrealizeWindow;
    RestackWindowProcPtr RestackWindow;
    WindowExposuresProcPtr WindowExposures;
    CopyWindowProcPtr CopyWindow;

    ResizeWindowProcPtr ResizeWindow;
    ReparentWindowProcPtr ReparentWindow;

    ChangeBorderWidthProcPtr ChangeBorderWidth;

    GetImageProcPtr GetImage;
    GetSpansProcPtr GetSpans;

    CreatePixmapProcPtr CreatePixmap;
    DestroyPixmapProcPtr DestroyPixmap;
    BitmapToRegionProcPtr BitmapToRegion;

    RealizeFontProcPtr RealizeFont;
    UnrealizeFontProcPtr UnrealizeFont;

    CreateColormapProcPtr CreateColormap;
    DestroyColormapProcPtr DestroyColormap;
    InstallColormapProcPtr InstallColormap;
    StoreColorsProcPtr StoreColors;

    SetShapeProcPtr SetShape;

    CreatePictureProcPtr CreatePicture;
    DestroyPictureProcPtr DestroyPicture;
    ChangePictureClipProcPtr ChangePictureClip;
    DestroyPictureClipProcPtr DestroyPictureClip;

    ChangePictureProcPtr ChangePicture;
    ValidatePictureProcPtr ValidatePicture;

    CompositeProcPtr Composite;
    GlyphsProcPtr Glyphs;
    CompositeRectsProcPtr CompositeRects;

    InitIndexedProcPtr InitIndexed;
    CloseIndexedProcPtr CloseIndexed;
    UpdateIndexedProcPtr UpdateIndexed;

    TrapezoidsProcPtr Trapezoids;
    TrianglesProcPtr Triangles;
} DMXScreenInfo;

/* Global variables available to all Xserver/hw/dmx routines. */
extern int dmxNumScreens;                       /**< Number of dmxScreens */
extern DMXScreenInfo *dmxScreens;               /**< List of outputs */
extern XErrorEvent dmxLastErrorEvent;           /**< Last error that

                                                 * occurred */
extern Bool dmxErrorOccurred;                   /**< True if an error

                                                 * occurred */
extern Bool dmxOffScreenOpt;                    /**< True if using off

                                                 * screen
                                                 * optimizations */
extern Bool dmxSubdividePrimitives;             /**< True if using the

                                                 * primitive subdivision
                                                 * optimization */
extern Bool dmxLazyWindowCreation;              /**< True if using the

                                                 * lazy window creation
                                                 * optimization */
extern Bool dmxUseXKB;                          /**< True if the XKB

                                                 * extension should be
                                                 * used with the backend
                                                 * servers */
extern int dmxDepth;                            /**< Requested depth if

                                                 * non-zero */
#ifdef GLXEXT
extern Bool dmxGLXProxy;                        /**< True if glxProxy

						 * support is enabled */
extern Bool dmxGLXSwapGroupSupport;             /**< True if glxProxy

						 * support for swap
						 * groups and barriers
						 * is enabled */
extern Bool dmxGLXSyncSwap;                     /**< True if glxProxy

						 * should force an XSync
						 * request after each
						 * swap buffers call */
extern Bool dmxGLXFinishSwap;                   /**< True if glxProxy

						 * should force a
						 * glFinish request
						 * after each swap
						 * buffers call */
#endif
extern char *dmxFontPath;                       /**< NULL if no font

						 * path is set on the
						 * command line;
						 * otherwise, a string
						 * of comma separated
						 * paths built from the
						 * command line
						 * specified font
						 * paths */
extern Bool dmxIgnoreBadFontPaths;              /**< True if bad font

						 * paths should be
						 * ignored during server
						 * init */
extern Bool dmxAddRemoveScreens;                /**< True if add and

						 * remove screens support
						 * is enabled */

/** Wrap screen or GC function pointer */
#define DMX_WRAP(_entry, _newfunc, _saved, _actual)			\
do {									\
    (_saved)->_entry  = (_actual)->_entry;				\
    (_actual)->_entry = (_newfunc);					\
} while (0)

/** Unwrap screen or GC function pointer */
#define DMX_UNWRAP(_entry, _saved, _actual)				\
do {									\
    (_actual)->_entry = (_saved)->_entry;				\
} while (0)

/* Define the MAXSCREENSALLOC/FREE macros, when MAXSCREENS patch has not
 * been applied to sources. */
#ifdef MAXSCREENS
#define MAXSCREEN_MAKECONSTSTR1(x) #x
#define MAXSCREEN_MAKECONSTSTR2(x) MAXSCREEN_MAKECONSTSTR1(x)

#define MAXSCREEN_FAILED_TXT "Failed at ["                              \
   MAXSCREEN_MAKECONSTSTR2(__LINE__) ":" __FILE__ "] to allocate object: "

#define _MAXSCREENSALLOCF(o,size,fatal)                                 \
    do {                                                                \
        if (!o) {                                                       \
            o = calloc((size), sizeof(*(o)));                          \
            if (!o && fatal) FatalError(MAXSCREEN_FAILED_TXT #o);       \
        }                                                               \
    } while (0)
#define _MAXSCREENSALLOCR(o,size,retval)                                \
    do {                                                                \
        if (!o) {                                                       \
            o = calloc((size), sizeof(*(o)));                          \
            if (!o) return retval;                                      \
        }                                                               \
    } while (0)

#define MAXSCREENSFREE(o)                                               \
    do {                                                                \
        free(o);                                                \
        o = NULL;                                                       \
    } while (0)

#define MAXSCREENSALLOC(o)              _MAXSCREENSALLOCF(o,MAXSCREENS,  0)
#define MAXSCREENSALLOC_FATAL(o)        _MAXSCREENSALLOCF(o,MAXSCREENS,  1)
#define MAXSCREENSALLOC_RETURN(o,r)     _MAXSCREENSALLOCR(o,MAXSCREENS, (r))
#define MAXSCREENSALLOCPLUSONE(o)       _MAXSCREENSALLOCF(o,MAXSCREENS+1,0)
#define MAXSCREENSALLOCPLUSONE_FATAL(o) _MAXSCREENSALLOCF(o,MAXSCREENS+1,1)
#define MAXSCREENSCALLOC(o,m)           _MAXSCREENSALLOCF(o,MAXSCREENS*(m),0)
#define MAXSCREENSCALLOC_FATAL(o,m)     _MAXSCREENSALLOCF(o,MAXSCREENS*(m),1)
#endif

extern DevPrivateKeyRec dmxGCPrivateKeyRec;

#define dmxGCPrivateKey (&dmxGCPrivateKeyRec) /**< Private index for GCs       */

extern DevPrivateKeyRec dmxWinPrivateKeyRec;

#define dmxWinPrivateKey (&dmxWinPrivateKeyRec) /**< Private index for Windows   */

extern DevPrivateKeyRec dmxPixPrivateKeyRec;

#define dmxPixPrivateKey (&dmxPixPrivateKeyRec) /**< Private index for Pixmaps   */

extern int dmxFontPrivateIndex;        /**< Private index for Fonts     */

extern DevPrivateKeyRec dmxScreenPrivateKeyRec;

#define dmxScreenPrivateKey (&dmxScreenPrivateKeyRec) /**< Private index for Screens   */

extern DevPrivateKeyRec dmxColormapPrivateKeyRec;

#define dmxColormapPrivateKey (&dmxColormapPrivateKeyRec) /**< Private index for Colormaps */

extern DevPrivateKeyRec dmxPictPrivateKeyRec;

#define dmxPictPrivateKey (&dmxPictPrivateKeyRec) /**< Private index for Picts     */

extern DevPrivateKeyRec dmxGlyphSetPrivateKeyRec;

#define dmxGlyphSetPrivateKey (&dmxGlyphSetPrivateKeyRec) /**< Private index for GlyphSets */

void DMXExtensionInit(void);

#endif                          /* DMX_H */
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a256 4
extern int dmxShadowFB;                         /**< Non-zero if using

                                                 * shadow frame-buffer
                                                 * (deprecated) */
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d410 2
@


1.6
log
@Update to xserver 1.11.2
@
text
@d92 2
a93 2
    const char   *name;           /**< Name from command line or config file */
    int           index;          /**< Index into dmxScreens global          */
d97 7
a103 7
    Display      *beDisplay;      /**< Back-end X server's display */
    int           beWidth;        /**< Width of BE display */
    int           beHeight;       /**< Height of BE display */
    int           beDepth;        /**< Depth of BE display */
    int           beBPP;          /**< Bits per pixel of BE display */
    int           beXDPI;         /**< Horizontal dots per inch of BE */
    int           beYDPI;         /**< Vertical dots per inch of BE */
d105 2
a106 2
    int           beNumDepths;    /**< Number of depths on BE server */
    int          *beDepths;       /**< Depths from BE server */
d108 1
a108 1
    int           beNumPixmapFormats; /**< Number of pixmap formats on BE */
d111 3
a113 3
    int           beNumVisuals;   /**< Number of visuals on BE */
    XVisualInfo  *beVisuals;      /**< Visuals from BE server */
    int           beDefVisualIndex; /**< Default visual index of BE */
d115 2
a116 2
    int           beNumDefColormaps; /**< Number of default colormaps */
    Colormap     *beDefColormaps; /**< Default colormaps for DMX server */ 
d118 2
a119 2
    Pixel         beBlackPixel;   /**< Default black pixel for BE */
    Pixel         beWhitePixel;   /**< Default white pixel for BE */
d123 7
a129 7
    Window        scrnWin;        /**< "Screen" window on backend display */
    int           scrnX;          /**< X offset of "screen" WRT BE display */
    int           scrnY;          /**< Y offset of "screen" WRT BE display */
    int           scrnWidth;      /**< Width of "screen" */
    int           scrnHeight;     /**< Height of "screen" */
    int           scrnXSign;      /**< X offset sign of "screen" */
    int           scrnYSign;      /**< Y offset sign of "screen" */
d132 1
a132 1
    Drawable      scrnDefDrawables[MAXFORMATS];
d139 5
a143 5
    Window        rootWin;        /**< "Root" window on backend display */
    int           rootX;          /**< X offset of "root" window WRT "screen"*/
    int           rootY;          /**< Y offset of "root" window WRT "screen"*/
    int           rootWidth;      /**< Width of "root" window */
    int           rootHeight;     /**< Height of "root" window */
d145 2
a146 2
    int           rootXOrigin;    /**< Global X origin of "root" window */
    int           rootYOrigin;    /**< Global Y origin of "root" window */
d150 3
a152 3
    void         *shadow;         /**< Shadow framebuffer data (if enabled) */
    XlibGC        shadowGC;       /**< Default GC used by shadow FB code */
    XImage       *shadowFBImage;  /**< Screen image used by shadow FB code */
d156 1
a156 1
    int           shared;         /**< Non-zero if another Xdmx is running */
d158 1
a158 1
    Bool          WMRunningOnBE;
d160 19
a178 19
    Cursor        noCursor;
    Cursor        curCursor;
                                /* Support for cursors on overlapped
                                 * backend displays. */
    CursorPtr     cursor;
    int           cursorVisible;
    int           cursorNotShared; /* for overlapping screens on a backend */

    PositionType  where;            /**< Relative layout information */
    int           whereX;           /**< Relative layout information */
    int           whereY;           /**< Relative layout information */
    int           whereRefScreen;   /**< Relative layout information */

    int           savedTimeout;     /**< Original screen saver timeout */
    int           dpmsCapable;      /**< Non-zero if backend is DPMS capable */
    int           dpmsEnabled;      /**< Non-zero if DPMS enabled */
    int           dpmsStandby;      /**< Original DPMS standby value  */
    int           dpmsSuspend;      /**< Original DPMS suspend value  */
    int           dpmsOff;          /**< Original DPMS off value  */
d180 2
a181 2
    DMXStatInfo  *stat;             /**< Statistics about XSync  */
    Bool          needsSync;        /**< True if an XSync is pending  */
d185 1
a185 1
    int           numGlxVisuals;
d187 2
a188 2
    int           glxMajorOpcode;
    int           glxErrorBase;
d192 1
a192 1
    int           numFBConfigs;
d197 2
a198 2
    CloseScreenProcPtr             CloseScreen;
    SaveScreenProcPtr              SaveScreen;
d200 1
a200 1
    CreateGCProcPtr                CreateGC;
d202 9
a210 47
    CreateWindowProcPtr            CreateWindow;
    DestroyWindowProcPtr           DestroyWindow;
    PositionWindowProcPtr          PositionWindow;
    ChangeWindowAttributesProcPtr  ChangeWindowAttributes;
    RealizeWindowProcPtr           RealizeWindow;
    UnrealizeWindowProcPtr         UnrealizeWindow;
    RestackWindowProcPtr           RestackWindow;
    WindowExposuresProcPtr         WindowExposures;
    CopyWindowProcPtr              CopyWindow;

    ResizeWindowProcPtr            ResizeWindow;
    ReparentWindowProcPtr          ReparentWindow;

    ChangeBorderWidthProcPtr       ChangeBorderWidth;

    GetImageProcPtr                GetImage;
    GetSpansProcPtr                GetSpans;

    CreatePixmapProcPtr            CreatePixmap;
    DestroyPixmapProcPtr           DestroyPixmap;
    BitmapToRegionProcPtr          BitmapToRegion;

    RealizeFontProcPtr             RealizeFont;
    UnrealizeFontProcPtr           UnrealizeFont;

    CreateColormapProcPtr          CreateColormap;
    DestroyColormapProcPtr         DestroyColormap;
    InstallColormapProcPtr         InstallColormap;
    StoreColorsProcPtr             StoreColors;

    SetShapeProcPtr                SetShape;

    CreatePictureProcPtr           CreatePicture;
    DestroyPictureProcPtr          DestroyPicture;
    ChangePictureClipProcPtr       ChangePictureClip;
    DestroyPictureClipProcPtr      DestroyPictureClip;
    
    ChangePictureProcPtr           ChangePicture;
    ValidatePictureProcPtr         ValidatePicture;

    CompositeProcPtr               Composite;
    GlyphsProcPtr                  Glyphs;
    CompositeRectsProcPtr          CompositeRects;

    InitIndexedProcPtr             InitIndexed;
    CloseIndexedProcPtr            CloseIndexed;
    UpdateIndexedProcPtr           UpdateIndexed;
d212 40
a251 2
    TrapezoidsProcPtr              Trapezoids;
    TrianglesProcPtr               Triangles;
d255 4
a258 3
extern int              dmxNumScreens;          /**< Number of dmxScreens */
extern DMXScreenInfo   *dmxScreens;             /**< List of outputs */
extern int              dmxShadowFB;            /**< Non-zero if using
d261 2
a262 1
extern XErrorEvent      dmxLastErrorEvent;      /**< Last error that
d264 2
a265 1
extern Bool             dmxErrorOccurred;       /**< True if an error
d267 2
a268 1
extern Bool             dmxOffScreenOpt;        /**< True if using off
d271 2
a272 1
extern Bool             dmxSubdividePrimitives; /**< True if using the
d275 2
a276 1
extern Bool             dmxLazyWindowCreation;  /**< True if using the
d279 2
a280 1
extern Bool             dmxUseXKB;              /**< True if the XKB
d284 2
a285 1
extern int              dmxDepth;               /**< Requested depth if
d288 2
a289 1
extern Bool             dmxGLXProxy;            /**< True if glxProxy
d291 2
a292 1
extern Bool             dmxGLXSwapGroupSupport; /**< True if glxProxy
d296 2
a297 1
extern Bool             dmxGLXSyncSwap;         /**< True if glxProxy
d301 2
a302 1
extern Bool             dmxGLXFinishSwap;       /**< True if glxProxy
d308 2
a309 1
extern char            *dmxFontPath;            /**< NULL if no font
d318 2
a319 1
extern Bool             dmxIgnoreBadFontPaths;  /**< True if bad font
d323 2
a324 1
extern Bool             dmxAddRemoveScreens;    /**< True if add and
d364 1
a364 1
        
d381 1
d385 1
d389 1
d395 1
d399 1
d403 1
d407 1
d410 1
a410 1
#endif /* DMX_H */
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a251 2
    TriStripProcPtr                TriStrip;
    TriFanProcPtr                  TriFan;
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a64 1
#ifdef RENDER
a65 1
#endif
a233 1
#ifdef RENDER
a253 1
#endif
d354 1
a354 1
        if (o) free(o);                                                \
d366 23
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d344 1
a344 1
            o = xcalloc((size), sizeof(*(o)));                          \
d351 1
a351 1
            o = xcalloc((size), sizeof(*(o)));                          \
d358 1
a358 1
        if (o) xfree(o);                                                \
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a233 1
#ifdef SHAPE
a234 1
#endif
d344 1
a344 2
            o = xalloc((size) * sizeof(*(o)));                          \
            if (o) memset(o, 0, (size) * sizeof(*(o)));                 \
d351 1
a351 2
            o = xalloc((size) * sizeof(*(o)));                          \
            if (o) memset(o, 0, (size) * sizeof(*(o)));                 \
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
a211 2
    PaintWindowBackgroundProcPtr   PaintWindowBackground;
    PaintWindowBorderProcPtr       PaintWindowBorder;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
@

