head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.3.0.8
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.6
	OPENBSD_4_5_BASE:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	7pAEtF6Y5EgemkuY;

1.9
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.22;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.27;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.46;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.46;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.11.04;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.18.02.22;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * Authors:
 *   Kevin E. Martin <kem@@redhat.com>
 *   David H. Dawes <dawes@@xfree86.org>
 *   Rickard E. (Rik) Faith <faith@@redhat.com>
 *
 */

/** \file
 * Provide expected functions for initialization from the ddx layer and
 * global variables for the DMX server. */

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include "dmx.h"
#include "dmxinit.h"
#include "dmxsync.h"
#include "dmxlog.h"
#include "dmxinput.h"
#include "dmxscrinit.h"
#include "dmxcursor.h"
#include "dmxfont.h"
#include "config/dmxconfig.h"
#include "dmxcb.h"
#include "dmxprop.h"
#include "dmxstat.h"
#include "dmxpict.h"

#include <X11/Xos.h>            /* For gettimeofday */
#include <X11/Xmu/SysUtil.h>    /* For XmuGetHostname */
#include "dixstruct.h"
#ifdef PANORAMIX
#include "panoramiXsrv.h"
#endif

#include <signal.h>             /* For SIGQUIT */

#ifdef GLXEXT
#include <GL/glx.h>
#include <GL/glxint.h>
#include "dmx_glxvisuals.h"
#include "glx_extinit.h"
#include <X11/extensions/Xext.h>
#include <X11/extensions/extutil.h>
#endif                          /* GLXEXT */

#include <X11/extensions/dmxproto.h>

/* Global variables available to all Xserver/hw/dmx routines. */
int dmxNumScreens;
DMXScreenInfo *dmxScreens;

int dmxNumInputs;
DMXInputInfo *dmxInputs;

XErrorEvent dmxLastErrorEvent;
Bool dmxErrorOccurred = FALSE;

char *dmxFontPath = NULL;

Bool dmxOffScreenOpt = TRUE;

Bool dmxSubdividePrimitives = TRUE;

Bool dmxLazyWindowCreation = TRUE;

Bool dmxUseXKB = TRUE;

int dmxDepth = 0;

#ifndef GLXEXT
static Bool dmxGLXProxy = FALSE;
#else
Bool dmxGLXProxy = TRUE;

Bool dmxGLXSwapGroupSupport = TRUE;

Bool dmxGLXSyncSwap = FALSE;

Bool dmxGLXFinishSwap = FALSE;
#endif

RESTYPE RRProviderType = 0;

Bool dmxIgnoreBadFontPaths = FALSE;

Bool dmxAddRemoveScreens = FALSE;

/* dmxErrorHandler catches errors that occur when calling one of the
 * back-end servers.  Some of this code is based on _XPrintDefaultError
 * in xc/lib/X11/XlibInt.c */
static int
dmxErrorHandler(Display * dpy, XErrorEvent * ev)
{
#define DMX_ERROR_BUF_SIZE 256
    /* RATS: these buffers are only used in
     * length-limited calls. */
    char buf[DMX_ERROR_BUF_SIZE];
    char request[DMX_ERROR_BUF_SIZE];
    _XExtension *ext = NULL;

    dmxErrorOccurred = TRUE;
    dmxLastErrorEvent = *ev;

    XGetErrorText(dpy, ev->error_code, buf, sizeof(buf));
    dmxLog(dmxWarning, "dmxErrorHandler: %s\n", buf);

    /* Find major opcode name */
    if (ev->request_code < 128) {
        snprintf(request, sizeof(request), "%d", ev->request_code);
        XGetErrorDatabaseText(dpy, "XRequest", request, "", buf, sizeof(buf));
    }
    else {
        for (ext = dpy->ext_procs;
             ext && ext->codes.major_opcode != ev->request_code;
             ext = ext->next);
        if (ext)
            strlcpy(buf, ext->name, sizeof(buf));
        else
            buf[0] = '\0';
    }
    dmxLog(dmxWarning, "                 Major opcode: %d (%s)\n",
           ev->request_code, buf);

    /* Find minor opcode name */
    if (ev->request_code >= 128 && ext) {
        snprintf(request, sizeof(request), "%d", ev->request_code);
        snprintf(request, sizeof(request), "%s.%d", ext->name, ev->minor_code);
        XGetErrorDatabaseText(dpy, "XRequest", request, "", buf, sizeof(buf));
        dmxLog(dmxWarning, "                 Minor opcode: %d (%s)\n",
               ev->minor_code, buf);
    }

    /* Provide value information */
    switch (ev->error_code) {
    case BadValue:
        dmxLog(dmxWarning, "                 Value:        0x%x\n",
               (unsigned int) ev->resourceid);
        break;
    case BadAtom:
        dmxLog(dmxWarning, "                 AtomID:       0x%x\n",
               (unsigned int) ev->resourceid);
        break;
    default:
        dmxLog(dmxWarning, "                 ResourceID:   0x%x\n",
               (unsigned int) ev->resourceid);
        break;
    }

    /* Provide serial number information */
    dmxLog(dmxWarning, "                 Failed serial number:  %d\n",
           (unsigned int) ev->serial);
    dmxLog(dmxWarning, "                 Current serial number: %d\n",
           (unsigned int) dpy->request);
    return 0;
}

#ifdef GLXEXT
static int
dmxNOPErrorHandler(Display * dpy, XErrorEvent * ev)
{
    return 0;
}
#endif

Bool
dmxOpenDisplay(DMXScreenInfo * dmxScreen)
{
    if (!(dmxScreen->beDisplay = XOpenDisplay(dmxScreen->name)))
        return FALSE;

    dmxPropertyDisplay(dmxScreen);
    return TRUE;
}

void
dmxSetErrorHandler(DMXScreenInfo * dmxScreen)
{
    XSetErrorHandler(dmxErrorHandler);
}

static void
dmxPrintScreenInfo(DMXScreenInfo * dmxScreen)
{
    XWindowAttributes attribs;
    int ndepths = 0, *depths = NULL;
    int i;
    Display *dpy = dmxScreen->beDisplay;
    Screen *s = DefaultScreenOfDisplay(dpy);
    int scr = DefaultScreen(dpy);

    XGetWindowAttributes(dpy, DefaultRootWindow(dpy), &attribs);
    if (!(depths = XListDepths(dpy, scr, &ndepths)))
        ndepths = 0;

    dmxLogOutput(dmxScreen, "Name of display: %s\n", DisplayString(dpy));
    dmxLogOutput(dmxScreen, "Version number:  %d.%d\n",
                 ProtocolVersion(dpy), ProtocolRevision(dpy));
    dmxLogOutput(dmxScreen, "Vendor string:   %s\n", ServerVendor(dpy));
    if (!strstr(ServerVendor(dpy), "XFree86")) {
        dmxLogOutput(dmxScreen, "Vendor release:  %d\n", VendorRelease(dpy));
    }
    else {
        /* This code based on xdpyinfo.c */
        int v = VendorRelease(dpy);
        int major = -1, minor = -1, patch = -1, subpatch = -1;

        if (v < 336)
            major = v / 100, minor = (v / 10) % 10, patch = v % 10;
        else if (v < 3900) {
            major = v / 1000;
            minor = (v / 100) % 10;
            if (((v / 10) % 10) || (v % 10)) {
                patch = (v / 10) % 10;
                if (v % 10)
                    subpatch = v % 10;
            }
        }
        else if (v < 40000000) {
            major = v / 1000;
            minor = (v / 10) % 10;
            if (v % 10)
                patch = v % 10;
        }
        else {
            major = v / 10000000;
            minor = (v / 100000) % 100;
            patch = (v / 1000) % 100;
            if (v % 1000)
                subpatch = v % 1000;
        }
        dmxLogOutput(dmxScreen, "Vendor release:  %d (XFree86 version: %d.%d",
                     v, major, minor);
        if (patch > 0)
            dmxLogOutputCont(dmxScreen, ".%d", patch);
        if (subpatch > 0)
            dmxLogOutputCont(dmxScreen, ".%d", subpatch);
        dmxLogOutputCont(dmxScreen, ")\n");
    }

    dmxLogOutput(dmxScreen, "Dimensions:      %dx%d pixels\n",
                 attribs.width, attribs.height);
    dmxLogOutput(dmxScreen, "%d depths on screen %d: ", ndepths, scr);
    for (i = 0; i < ndepths; i++)
        dmxLogOutputCont(dmxScreen, "%c%d", i ? ',' : ' ', depths[i]);
    dmxLogOutputCont(dmxScreen, "\n");
    dmxLogOutput(dmxScreen, "Depth of root window:  %d plane%s (%d)\n",
                 attribs.depth, attribs.depth == 1 ? "" : "s",
                 DisplayPlanes(dpy, scr));
    dmxLogOutput(dmxScreen, "Number of colormaps:   %d min, %d max\n",
                 MinCmapsOfScreen(s), MaxCmapsOfScreen(s));
    dmxLogOutput(dmxScreen, "Options: backing-store %s, save-unders %s\n",
                 (DoesBackingStore(s) == NotUseful) ? "no" :
                 ((DoesBackingStore(s) == Always) ? "yes" : "when mapped"),
                 DoesSaveUnders(s) ? "yes" : "no");
    dmxLogOutput(dmxScreen, "Window Manager running: %s\n",
                 (dmxScreen->WMRunningOnBE) ? "yes" : "no");

    if (dmxScreen->WMRunningOnBE) {
        dmxLogOutputWarning(dmxScreen,
                            "Window manager running "
                            "-- colormaps not supported\n");
    }
    XFree(depths);
}

void
dmxGetScreenAttribs(DMXScreenInfo * dmxScreen)
{
    XWindowAttributes attribs;
    Display *dpy = dmxScreen->beDisplay;

#ifdef GLXEXT
    int dummy;
#endif

    XGetWindowAttributes(dpy, DefaultRootWindow(dpy), &attribs);

    dmxScreen->beWidth = attribs.width;
    dmxScreen->beHeight = attribs.height;

    /* Fill in missing geometry information */
    if (dmxScreen->scrnXSign < 0) {
        if (dmxScreen->scrnWidth) {
            dmxScreen->scrnX = (attribs.width - dmxScreen->scrnWidth
                                - dmxScreen->scrnX);
        }
        else {
            dmxScreen->scrnWidth = attribs.width - dmxScreen->scrnX;
            dmxScreen->scrnX = 0;
        }
    }
    if (dmxScreen->scrnYSign < 0) {
        if (dmxScreen->scrnHeight) {
            dmxScreen->scrnY = (attribs.height - dmxScreen->scrnHeight
                                - dmxScreen->scrnY);
        }
        else {
            dmxScreen->scrnHeight = attribs.height - dmxScreen->scrnY;
            dmxScreen->scrnY = 0;
        }
    }
    if (!dmxScreen->scrnWidth)
        dmxScreen->scrnWidth = attribs.width - dmxScreen->scrnX;
    if (!dmxScreen->scrnHeight)
        dmxScreen->scrnHeight = attribs.height - dmxScreen->scrnY;

    if (!dmxScreen->rootWidth)
        dmxScreen->rootWidth = dmxScreen->scrnWidth;
    if (!dmxScreen->rootHeight)
        dmxScreen->rootHeight = dmxScreen->scrnHeight;
    if (dmxScreen->rootWidth + dmxScreen->rootX > dmxScreen->scrnWidth)
        dmxScreen->rootWidth = dmxScreen->scrnWidth - dmxScreen->rootX;
    if (dmxScreen->rootHeight + dmxScreen->rootY > dmxScreen->scrnHeight)
        dmxScreen->rootHeight = dmxScreen->scrnHeight - dmxScreen->rootY;

    /* FIXME: Get these from the back-end server */
    dmxScreen->beXDPI = 75;
    dmxScreen->beYDPI = 75;

    dmxScreen->beDepth = attribs.depth; /* FIXME: verify that this
                                         * works always.  In
                                         * particular, this will work
                                         * well for depth=16, will fail
                                         * because of colormap issues
                                         * at depth 8.  More work needs
                                         * to be done here. */

    if (dmxScreen->beDepth <= 8)
        dmxScreen->beBPP = 8;
    else if (dmxScreen->beDepth <= 16)
        dmxScreen->beBPP = 16;
    else
        dmxScreen->beBPP = 32;

#ifdef GLXEXT
    /* get the majorOpcode for the back-end GLX extension */
    XQueryExtension(dpy, "GLX", &dmxScreen->glxMajorOpcode,
                    &dummy, &dmxScreen->glxErrorBase);
#endif

    dmxPrintScreenInfo(dmxScreen);
    dmxLogOutput(dmxScreen, "%dx%d+%d+%d on %dx%d at depth=%d, bpp=%d\n",
                 dmxScreen->scrnWidth, dmxScreen->scrnHeight,
                 dmxScreen->scrnX, dmxScreen->scrnY,
                 dmxScreen->beWidth, dmxScreen->beHeight,
                 dmxScreen->beDepth, dmxScreen->beBPP);
    if (dmxScreen->beDepth == 8)
        dmxLogOutputWarning(dmxScreen,
                            "Support for depth == 8 is not complete\n");
}

Bool
dmxGetVisualInfo(DMXScreenInfo * dmxScreen)
{
    int i;
    XVisualInfo visinfo;

    visinfo.screen = DefaultScreen(dmxScreen->beDisplay);
    dmxScreen->beVisuals = XGetVisualInfo(dmxScreen->beDisplay,
                                          VisualScreenMask,
                                          &visinfo, &dmxScreen->beNumVisuals);

    dmxScreen->beDefVisualIndex = -1;

    if (defaultColorVisualClass >= 0 || dmxDepth > 0) {
        for (i = 0; i < dmxScreen->beNumVisuals; i++)
            if (defaultColorVisualClass >= 0) {
                if (dmxScreen->beVisuals[i].class == defaultColorVisualClass) {
                    if (dmxDepth > 0) {
                        if (dmxScreen->beVisuals[i].depth == dmxDepth) {
                            dmxScreen->beDefVisualIndex = i;
                            break;
                        }
                    }
                    else {
                        dmxScreen->beDefVisualIndex = i;
                        break;
                    }
                }
            }
            else if (dmxScreen->beVisuals[i].depth == dmxDepth) {
                dmxScreen->beDefVisualIndex = i;
                break;
            }
    }
    else {
        visinfo.visualid =
            XVisualIDFromVisual(DefaultVisual(dmxScreen->beDisplay,
                                              visinfo.screen));

        for (i = 0; i < dmxScreen->beNumVisuals; i++)
            if (visinfo.visualid == dmxScreen->beVisuals[i].visualid) {
                dmxScreen->beDefVisualIndex = i;
                break;
            }
    }

    for (i = 0; i < dmxScreen->beNumVisuals; i++)
        dmxLogVisual(dmxScreen, &dmxScreen->beVisuals[i],
                     (i == dmxScreen->beDefVisualIndex));

    return dmxScreen->beDefVisualIndex >= 0;
}

void
dmxGetColormaps(DMXScreenInfo * dmxScreen)
{
    int i;

    dmxScreen->beNumDefColormaps = dmxScreen->beNumVisuals;
    dmxScreen->beDefColormaps = xallocarray(dmxScreen->beNumDefColormaps,
                                       sizeof(*dmxScreen->beDefColormaps));

    for (i = 0; i < dmxScreen->beNumDefColormaps; i++)
        dmxScreen->beDefColormaps[i] =
            XCreateColormap(dmxScreen->beDisplay,
                            DefaultRootWindow(dmxScreen->beDisplay),
                            dmxScreen->beVisuals[i].visual, AllocNone);

    dmxScreen->beBlackPixel = BlackPixel(dmxScreen->beDisplay,
                                         DefaultScreen(dmxScreen->beDisplay));
    dmxScreen->beWhitePixel = WhitePixel(dmxScreen->beDisplay,
                                         DefaultScreen(dmxScreen->beDisplay));
}

void
dmxGetPixmapFormats(DMXScreenInfo * dmxScreen)
{
    dmxScreen->beDepths =
        XListDepths(dmxScreen->beDisplay, DefaultScreen(dmxScreen->beDisplay),
                    &dmxScreen->beNumDepths);

    dmxScreen->bePixmapFormats =
        XListPixmapFormats(dmxScreen->beDisplay,
                           &dmxScreen->beNumPixmapFormats);
}

static Bool
dmxSetPixmapFormats(ScreenInfo * pScreenInfo, DMXScreenInfo * dmxScreen)
{
    XPixmapFormatValues *bePixmapFormat;
    PixmapFormatRec *format;
    int i, j;

    pScreenInfo->imageByteOrder = ImageByteOrder(dmxScreen->beDisplay);
    pScreenInfo->bitmapScanlineUnit = BitmapUnit(dmxScreen->beDisplay);
    pScreenInfo->bitmapScanlinePad = BitmapPad(dmxScreen->beDisplay);
    pScreenInfo->bitmapBitOrder = BitmapBitOrder(dmxScreen->beDisplay);

    pScreenInfo->numPixmapFormats = 0;
    for (i = 0; i < dmxScreen->beNumPixmapFormats; i++) {
        bePixmapFormat = &dmxScreen->bePixmapFormats[i];
        for (j = 0; j < dmxScreen->beNumDepths; j++)
            if ((bePixmapFormat->depth == 1) ||
                (bePixmapFormat->depth == dmxScreen->beDepths[j])) {
                format = &pScreenInfo->formats[pScreenInfo->numPixmapFormats];

                format->depth = bePixmapFormat->depth;
                format->bitsPerPixel = bePixmapFormat->bits_per_pixel;
                format->scanlinePad = bePixmapFormat->scanline_pad;

                pScreenInfo->numPixmapFormats++;
                break;
            }
    }

    return TRUE;
}

void
dmxCheckForWM(DMXScreenInfo * dmxScreen)
{
    Status status;
    XWindowAttributes xwa;

    status = XGetWindowAttributes(dmxScreen->beDisplay,
                                  DefaultRootWindow(dmxScreen->beDisplay),
                                  &xwa);
    dmxScreen->WMRunningOnBE =
        (status &&
         ((xwa.all_event_masks & SubstructureRedirectMask) ||
          (xwa.all_event_masks & SubstructureNotifyMask)));
}

/** Initialize the display and collect relevant information about the
 *  display properties */
static void
dmxDisplayInit(DMXScreenInfo * dmxScreen)
{
    if (!dmxOpenDisplay(dmxScreen))
        dmxLog(dmxFatal,
               "dmxOpenDisplay: Unable to open display %s\n", dmxScreen->name);

    dmxSetErrorHandler(dmxScreen);
    dmxCheckForWM(dmxScreen);
    dmxGetScreenAttribs(dmxScreen);

    if (!dmxGetVisualInfo(dmxScreen))
        dmxLog(dmxFatal, "dmxGetVisualInfo: No matching visuals found\n");

    dmxGetColormaps(dmxScreen);
    dmxGetPixmapFormats(dmxScreen);
}

/* If this doesn't compile, just add || defined(yoursystem) to the line
 * below.  This information is to help with bug reports and is not
 * critical. */
#if !defined(_POSIX_SOURCE)
static const char *
dmxExecOS(void)
{
    return "";
}
#else
#include <sys/utsname.h>
static const char *
dmxExecOS(void)
{
    static char buffer[128];
    static int initialized = 0;
    struct utsname u;

    if (!initialized++) {
        memset(buffer, 0, sizeof(buffer));
        uname(&u);
        snprintf(buffer, sizeof(buffer) - 1, "%s %s %s",
                 u.sysname, u.release, u.version);
    }
    return buffer;
}
#endif

static const char *
dmxBuildCompiler(void)
{
    static char buffer[128];
    static int initialized = 0;

    if (!initialized++) {
        memset(buffer, 0, sizeof(buffer));
#if defined(__GNUC__) && defined(__GNUC_MINOR__) &&defined(__GNUC_PATCHLEVEL__)
        snprintf(buffer, sizeof(buffer) - 1, "gcc %d.%d.%d",
                 __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);
#endif
    }
    return buffer;
}

static const char *
dmxExecHost(void)
{
    static char buffer[128];
    static int initialized = 0;

    if (!initialized++) {
        memset(buffer, 0, sizeof(buffer));
        XmuGetHostname(buffer, sizeof(buffer) - 1);
    }
    return buffer;
}

static void dmxAddExtensions(Bool glxSupported)
{
    const ExtensionModule dmxExtensions[] = {
        { DMXExtensionInit, DMX_EXTENSION_NAME, NULL },
#ifdef GLXEXT
        { GlxExtensionInit, "GLX", &glxSupported },
#endif
    };

    LoadExtensionList(dmxExtensions, ARRAY_SIZE(dmxExtensions), TRUE);
}

/** This routine is called in Xserver/dix/main.c from \a main(). */
void
InitOutput(ScreenInfo * pScreenInfo, int argc, char *argv[])
{
    int i;
    static unsigned long dmxGeneration = 0;

#ifdef GLXEXT
    static Bool glxSupported = TRUE;
#else
    const Bool glxSupported = FALSE;
#endif

    if (dmxGeneration != serverGeneration) {
        int vendrel = VENDOR_RELEASE;
        int major, minor, year, month, day;

        dmxGeneration = serverGeneration;

        major = vendrel / 100000000;
        vendrel -= major * 100000000;
        minor = vendrel / 1000000;
        vendrel -= minor * 1000000;
        year = vendrel / 10000;
        vendrel -= year * 10000;
        month = vendrel / 100;
        vendrel -= month * 100;
        day = vendrel;

        /* Add other epoch tests here */
        if (major > 0 && minor > 0)
            year += 2000;

        dmxLog(dmxInfo, "Generation:         %lu\n", dmxGeneration);
        dmxLog(dmxInfo, "DMX version:        %d.%d.%02d%02d%02d (%s)\n",
               major, minor, year, month, day, VENDOR_STRING);

        SetVendorRelease(VENDOR_RELEASE);
        SetVendorString(VENDOR_STRING);

        if (dmxGeneration == 1) {
            dmxLog(dmxInfo, "DMX Build OS:       %s (%s)\n", OSNAME, OSVENDOR);
            dmxLog(dmxInfo, "DMX Build Compiler: %s\n", dmxBuildCompiler());
            dmxLog(dmxInfo, "DMX Execution OS:   %s\n", dmxExecOS());
            dmxLog(dmxInfo, "DMX Execution Host: %s\n", dmxExecHost());
        }
        dmxLog(dmxInfo, "MAXSCREENS:         %d\n", MAXSCREENS);

        for (i = 0; i < dmxNumScreens; i++) {
            if (dmxScreens[i].beDisplay)
                dmxLog(dmxWarning, "Display \"%s\" still open\n",
                       dmxScreens[i].name);
            dmxStatFree(dmxScreens[i].stat);
            dmxScreens[i].stat = NULL;
        }
        for (i = 0; i < dmxNumInputs; i++)
            dmxInputFree(&dmxInputs[i]);
        free(dmxScreens);
        free(dmxInputs);
        dmxScreens = NULL;
        dmxInputs = NULL;
        dmxNumScreens = 0;
        dmxNumInputs = 0;
    }

    /* Make sure that the command-line arguments are sane. */
    if (dmxAddRemoveScreens && dmxGLXProxy) {
        /* Currently it is not possible to support GLX and Render
         * extensions with dynamic screen addition/removal due to the
         * state that each extension keeps, which cannot be restored. */
        dmxLog(dmxWarning,
               "GLX Proxy and Render extensions do not yet support dynamic\n");
        dmxLog(dmxWarning,
               "screen addition and removal.  Please specify -noglxproxy\n");
        dmxLog(dmxWarning,
               "and -norender on the command line or in the configuration\n");
        dmxLog(dmxWarning,
               "file to disable these two extensions if you wish to use\n");
        dmxLog(dmxWarning,
               "the dynamic addition and removal of screens support.\n");
        dmxLog(dmxFatal,
               "Dynamic screen addition/removal error (see above).\n");
    }

    /* ddxProcessArgument has been called at this point, but any data
     * from the configuration file has not been applied.  Do so, and be
     * sure we have at least one back-end display. */
    dmxConfigConfigure();
    if (!dmxNumScreens)
        dmxLog(dmxFatal, "InitOutput: no back-end displays found\n");
    if (!dmxNumInputs)
        dmxLog(dmxInfo, "InitOutput: no inputs found\n");

    /* Disable lazy window creation optimization if offscreen
     * optimization is disabled */
    if (!dmxOffScreenOpt && dmxLazyWindowCreation) {
        dmxLog(dmxInfo,
               "InitOutput: Disabling lazy window creation optimization\n");
        dmxLog(dmxInfo,
               "            since it requires the offscreen optimization\n");
        dmxLog(dmxInfo, "            to function properly.\n");
        dmxLazyWindowCreation = FALSE;
    }

    /* Open each display and gather information about it. */
    for (i = 0; i < dmxNumScreens; i++)
        dmxDisplayInit(&dmxScreens[i]);

#if PANORAMIX
    /* Register a Xinerama callback which will run from within
     * PanoramiXCreateConnectionBlock.  We can use the callback to
     * determine if Xinerama is loaded and to check the visuals
     * determined by PanoramiXConsolidate. */
    XineramaRegisterConnectionBlockCallback(dmxConnectionBlockCallback);
#endif

    /* Since we only have a single screen thus far, we only need to set
       the pixmap formats to match that screen.  FIXME: this isn't true. */
    if (!dmxSetPixmapFormats(pScreenInfo, &dmxScreens[0]))
        return;

    /* Might want to install a signal handler to allow cleaning up after
     * unexpected signals.  The DIX/OS layer already handles SIGINT and
     * SIGTERM, so everything is OK for expected signals. --DD
     *
     * SIGHUP, SIGINT, and SIGTERM are trapped in os/connection.c
     * SIGQUIT is another common signal that is sent from the keyboard.
     * Trap it here, to ensure that the keyboard modifier map and other
     * state for the input devices are restored. (This makes the
     * behavior of SIGQUIT somewhat unexpected, since it will be the
     * same as the behavior of SIGINT.  However, leaving the modifier
     * map of the input devices empty is even more unexpected.) --RF
     */
    OsSignal(SIGQUIT, GiveUp);

#ifdef GLXEXT
    /* Check if GLX extension exists on all back-end servers */
    for (i = 0; i < dmxNumScreens; i++)
        glxSupported &= (dmxScreens[i].glxMajorOpcode > 0);
#endif

    if (serverGeneration == 1)
        dmxAddExtensions(glxSupported);

    /* Tell dix layer about the backend displays */
    for (i = 0; i < dmxNumScreens; i++) {

#ifdef GLXEXT
        if (glxSupported) {
            /*
             * Builds GLX configurations from the list of visuals
             * supported by the back-end server, and give that
             * configuration list to the glx layer - so that he will
             * build the visuals accordingly.
             */

            DMXScreenInfo *dmxScreen = &dmxScreens[i];
            __GLXvisualConfig *configs = NULL;
            dmxGlxVisualPrivate **configprivs = NULL;
            int nconfigs = 0;
            int (*oldErrorHandler) (Display *, XErrorEvent *);

            /* Catch errors if when using an older GLX w/o FBconfigs */
            oldErrorHandler = XSetErrorHandler(dmxNOPErrorHandler);

            /* Get FBConfigs of the back-end server */
            dmxScreen->fbconfigs = GetGLXFBConfigs(dmxScreen->beDisplay,
                                                   dmxScreen->glxMajorOpcode,
                                                   &dmxScreen->numFBConfigs);

            XSetErrorHandler(oldErrorHandler);

            dmxScreen->glxVisuals =
                GetGLXVisualConfigs(dmxScreen->beDisplay,
                                    DefaultScreen(dmxScreen->beDisplay),
                                    &dmxScreen->numGlxVisuals);

            if (dmxScreen->fbconfigs) {
                configs =
                    GetGLXVisualConfigsFromFBConfigs(dmxScreen->fbconfigs,
                                                     dmxScreen->numFBConfigs,
                                                     dmxScreen->beVisuals,
                                                     dmxScreen->beNumVisuals,
                                                     dmxScreen->glxVisuals,
                                                     dmxScreen->numGlxVisuals,
                                                     &nconfigs);
            }
            else {
                configs = dmxScreen->glxVisuals;
                nconfigs = dmxScreen->numGlxVisuals;
            }

            configprivs = xallocarray(nconfigs, sizeof(dmxGlxVisualPrivate *));

            if (configs != NULL && configprivs != NULL) {
                int j;

                /* Initialize our private info for each visual
                 * (currently only x_visual_depth and x_visual_class)
                 */
                for (j = 0; j < nconfigs; j++) {

                    configprivs[j] = (dmxGlxVisualPrivate *)
                        malloc(sizeof(dmxGlxVisualPrivate));
                    configprivs[j]->x_visual_depth = 0;
                    configprivs[j]->x_visual_class = 0;

                    /* Find the visual depth */
                    if (configs[j].vid > 0) {
                        int k;

                        for (k = 0; k < dmxScreen->beNumVisuals; k++) {
                            if (dmxScreen->beVisuals[k].visualid ==
                                configs[j].vid) {
                                configprivs[j]->x_visual_depth =
                                    dmxScreen->beVisuals[k].depth;
                                configprivs[j]->x_visual_class =
                                    dmxScreen->beVisuals[k].class;
                                break;
                            }
                        }
                    }
                }

                XFlush(dmxScreen->beDisplay);
            }
        }
#endif                          /* GLXEXT */

        AddScreen(dmxScreenInit, argc, argv);
    }

    /* Compute origin information. */
    dmxInitOrigins();

    /* Compute overlap information. */
    dmxInitOverlap();

    /* Make sure there is a global width/height available */
    dmxComputeWidthHeight(DMX_NO_RECOMPUTE_BOUNDING_BOX);

    /* FIXME: The following is temporarily placed here.  When the DMX
     * extension is available, it will be move there.
     */
    dmxInitFonts();

    /* Initialize the render extension */
    if (!noRenderExtension)
        dmxInitRender();

    /* Initialized things that need timer hooks */
    dmxStatInit();
    dmxSyncInit();              /* Calls RegisterBlockAndWakeupHandlers */
}

/* RATS: Assuming the fp string (which comes from the command-line argv
         vector) is NULL-terminated, the buffer is large enough for the
         strcpy. */
static void
dmxSetDefaultFontPath(const char *fp)
{
    if (dmxFontPath) {
        int fplen = strlen(fp) + 1;
        int len = strlen(dmxFontPath);

        dmxFontPath = realloc(dmxFontPath, len + fplen + 1);
        dmxFontPath[len] = ',';
        strncpy(&dmxFontPath[len + 1], fp, fplen);
    }
    else {
        dmxFontPath = strdup(fp);
    }

    defaultFontPath = dmxFontPath;
}

/** This function is called in Xserver/os/utils.c from \a AbortServer().
 * We must ensure that backend and console state is restored in the
 * event the server shutdown wasn't clean. */
void
AbortDDX(enum ExitCode error)
{
    int i;

    for (i = 0; i < dmxNumScreens; i++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[i];

        if (dmxScreen->beDisplay)
            XCloseDisplay(dmxScreen->beDisplay);
        dmxScreen->beDisplay = NULL;
    }
}

#ifdef DDXBEFORERESET
void
ddxBeforeReset(void)
{
}
#endif

/** This function is called in Xserver/dix/main.c from \a main() when
 * dispatchException & DE_TERMINATE (which is the only way to exit the
 * main loop without an interruption. */
void
ddxGiveUp(enum ExitCode error)
{
    AbortDDX(error);
}

/** This function is called in Xserver/os/osinit.c from \a OsInit(). */
void
OsVendorInit(void)
{
}

/** This function is called in Xserver/os/utils.c from \a FatalError()
 * and \a VFatalError().  (Note that setting the function pointer \a
 * OsVendorVErrorFProc will cause \a VErrorF() (which is called by the
 * two routines mentioned here, as well as by others) to use the
 * referenced routine instead of \a vfprintf().) */
void
OsVendorFatalError(const char *f, va_list args)
{
}

/** Process our command line arguments. */
int
ddxProcessArgument(int argc, char *argv[], int i)
{
    int retval = 0;

    if (!strcmp(argv[i], "-display")) {
        if (++i < argc)
            dmxConfigStoreDisplay(argv[i]);
        retval = 2;
    }
    else if (!strcmp(argv[i], "-inputfrom") || !strcmp(argv[i], "-input")) {
        if (++i < argc)
            dmxConfigStoreInput(argv[i]);
        retval = 2;
    }
    else if (!strcmp(argv[i], "-xinputfrom") || !strcmp(argv[i], "-xinput")) {
        if (++i < argc)
            dmxConfigStoreXInput(argv[i]);
        retval = 2;
    }
    else if (!strcmp(argv[i], "-noshadowfb")) {
        retval = 1;
    }
    else if (!strcmp(argv[i], "-nomulticursor")) {
        dmxCursorNoMulti();
        retval = 1;
    }
    else if (!strcmp(argv[i], "-shadowfb")) {
        retval = 1;
    }
    else if (!strcmp(argv[i], "-configfile")) {
        if (++i < argc)
            dmxConfigStoreFile(argv[i]);
        retval = 2;
    }
    else if (!strcmp(argv[i], "-config")) {
        if (++i < argc)
            dmxConfigStoreConfig(argv[i]);
        retval = 2;
    }
    else if (!strcmp(argv[i], "-fontpath")) {
        if (++i < argc)
            dmxSetDefaultFontPath(argv[i]);
        retval = 2;
    }
    else if (!strcmp(argv[i], "-stat")) {
        if ((i += 2) < argc)
            dmxStatActivate(argv[i - 1], argv[i]);
        retval = 3;
    }
    else if (!strcmp(argv[i], "-syncbatch")) {
        if (++i < argc)
            dmxSyncActivate(argv[i]);
        retval = 2;
    }
    else if (!strcmp(argv[i], "-nooffscreenopt")) {
        dmxOffScreenOpt = FALSE;
        retval = 1;
    }
    else if (!strcmp(argv[i], "-nosubdivprims")) {
        dmxSubdividePrimitives = FALSE;
        retval = 1;
    }
    else if (!strcmp(argv[i], "-nowindowopt")) {
        dmxLazyWindowCreation = FALSE;
        retval = 1;
    }
    else if (!strcmp(argv[i], "-noxkb")) {
        dmxUseXKB = FALSE;
        retval = 1;
    }
    else if (!strcmp(argv[i], "-depth")) {
        if (++i < argc)
            dmxDepth = atoi(argv[i]);
        retval = 2;
    }
    else if (!strcmp(argv[i], "-norender")) {
        noRenderExtension = TRUE;
        retval = 1;
#ifdef GLXEXT
    }
    else if (!strcmp(argv[i], "-noglxproxy")) {
        dmxGLXProxy = FALSE;
        retval = 1;
    }
    else if (!strcmp(argv[i], "-noglxswapgroup")) {
        dmxGLXSwapGroupSupport = FALSE;
        retval = 1;
    }
    else if (!strcmp(argv[i], "-glxsyncswap")) {
        dmxGLXSyncSwap = TRUE;
        retval = 1;
    }
    else if (!strcmp(argv[i], "-glxfinishswap")) {
        dmxGLXFinishSwap = TRUE;
        retval = 1;
#endif
    }
    else if (!strcmp(argv[i], "-ignorebadfontpaths")) {
        dmxIgnoreBadFontPaths = TRUE;
        retval = 1;
    }
    else if (!strcmp(argv[i], "-addremovescreens")) {
        dmxAddRemoveScreens = TRUE;
        retval = 1;
    }
    else if (!strcmp(argv[i], "-param")) {
        if ((i += 2) < argc) {
            if (!strcasecmp(argv[i - 1], "xkbrules"))
                dmxConfigSetXkbRules(argv[i]);
            else if (!strcasecmp(argv[i - 1], "xkbmodel"))
                dmxConfigSetXkbModel(argv[i]);
            else if (!strcasecmp(argv[i - 1], "xkblayout"))
                dmxConfigSetXkbLayout(argv[i]);
            else if (!strcasecmp(argv[i - 1], "xkbvariant"))
                dmxConfigSetXkbVariant(argv[i]);
            else if (!strcasecmp(argv[i - 1], "xkboptions"))
                dmxConfigSetXkbOptions(argv[i]);
            else
                dmxLog(dmxWarning,
                       "-param requires: XkbRules, XkbModel, XkbLayout,"
                       " XkbVariant, or XkbOptions\n");
        }
        retval = 3;
    }
    if (!serverGeneration)
        dmxConfigSetMaxScreens();
    return retval;
}

/** Provide succinct usage information for the DMX server. */
void
ddxUseMsg(void)
{
    ErrorF("\n\nDevice Dependent Usage:\n");
    ErrorF("-display string      Specify the back-end display(s)\n");
    ErrorF("-input string        Specify input source for core device\n");
    ErrorF("-xinput string       Specify input source for XInput device\n");
    ErrorF("-shadowfb            Enable shadow frame buffer\n");
    ErrorF("-configfile file     Read from a configuration file\n");
    ErrorF("-config config       Select a specific configuration\n");
    ErrorF("-nomulticursor       Turn of multiple cursor support\n");
    ErrorF("-fontpath            Sets the default font path\n");
    ErrorF("-stat inter scrns    Print out performance statistics\n");
    ErrorF("-syncbatch inter     Set interval for XSync batching\n");
    ErrorF("-nooffscreenopt      Disable offscreen optimization\n");
    ErrorF("-nosubdivprims       Disable primitive subdivision\n");
    ErrorF("                     optimization\n");
    ErrorF("-nowindowopt         Disable lazy window creation optimization\n");
    ErrorF("-noxkb               Disable use of the XKB extension with\n");
    ErrorF("                     backend displays (cf. -kb).\n");
    ErrorF("-depth               Specify the default root window depth\n");
    ErrorF("-norender            Disable RENDER extension support\n");
#ifdef GLXEXT
    ErrorF("-noglxproxy          Disable GLX Proxy\n");
    ErrorF("-noglxswapgroup      Disable swap group and swap barrier\n");
    ErrorF("                     extensions in GLX proxy\n");
    ErrorF("-glxsyncswap         Force XSync after swap buffers\n");
    ErrorF("-glxfinishswap       Force glFinish after swap buffers\n");
#endif
    ErrorF
        ("-ignorebadfontpaths  Ignore bad font paths during initialization\n");
    ErrorF("-addremovescreens    Enable dynamic screen addition/removal\n");
    ErrorF("-param ...           Specify configuration parameters (e.g.,\n");
    ErrorF("                     XkbRules, XkbModel, XkbLayout, etc.)\n");
    ErrorF("\n");
    ErrorF("    If the -input string matches a -display string, then input\n"
           "    is taken from that backend display.  (XInput cannot be taken\n"
           "    from a backend display.)  Placing \",console\" after the\n"
           "    display name will force a console window to be opened on\n"
           "    that display in addition to the backend input.  This is\n"
           "    useful if the backend window does not cover the whole\n"
           "    physical display.\n\n");

    ErrorF("    Otherwise, if the -input or -xinput string specifies another\n"
           "    X display, then a console window will be created on that\n"
           "    display.  Placing \",windows\" or \",nowindows\" after the\n"
           "    display name will control the display of window outlines in\n"
           "    the console.\n\n");

    ErrorF("    -input or -xinput dummy specifies no input.\n");
    ErrorF("    -input or -xinput local specifies the use of a raw keyboard,\n"
           "    mouse, or other (extension) device:\n"
           "        -input local,kbd,ps2 will use a ps2 mouse\n"
           "        -input local,kbd,ms  will use a serial mouse\n"
           "        -input local,usb-kbd,usb-mou will use USB devices \n"
           "        -xinput local,usb-oth will use a non-mouse and\n"
           "                non-keyboard USB device with XInput\n\n");

    ErrorF("    Special Keys:\n");
    ErrorF("        Ctrl-Alt-g    Server grab/ungrab (console only)\n");
    ErrorF("        Ctrl-Alt-f    Fine (1-pixel) mouse mode (console only)\n");
    ErrorF("        Ctrl-Alt-q    Quit (core devices only)\n");
    ErrorF("        Ctrl-Alt-F*   Switch to VC (local only)\n");
}
@


1.10
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d441 1
a441 1
    dmxScreen->beDefColormaps = malloc(dmxScreen->beNumDefColormaps *
d796 1
a796 1
            configprivs = malloc(nconfigs * sizeof(dmxGlxVisualPrivate *));
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d167 1
a167 1
               ev->resourceid);
d171 1
a171 1
               ev->resourceid);
d175 1
a175 1
               ev->resourceid);
d181 1
a181 1
           ev->serial);
d183 1
a183 1
           dpy->request);
d637 1
a637 1
        dmxLog(dmxInfo, "Generation:         %d\n", dmxGeneration);
a764 1
            int i;
d799 1
d804 1
a804 1
                for (i = 0; i < nconfigs; i++) {
d806 1
a806 1
                    configprivs[i] = (dmxGlxVisualPrivate *)
d808 2
a809 2
                    configprivs[i]->x_visual_depth = 0;
                    configprivs[i]->x_visual_class = 0;
d812 2
a813 2
                    if (configs[i].vid > 0) {
                        int j;
d815 7
a821 7
                        for (j = 0; j < dmxScreen->beNumVisuals; j++) {
                            if (dmxScreen->beVisuals[j].visualid ==
                                configs[i].vid) {
                                configprivs[i]->x_visual_depth =
                                    dmxScreen->beVisuals[j].depth;
                                configprivs[i]->x_visual_class =
                                    dmxScreen->beVisuals[j].class;
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a599 1
    int i;
d601 1
a601 2
    for (i = 0; i < ARRAY_SIZE(dmxExtensions); i++)
        LoadExtension(&dmxExtensions[i], TRUE);
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a84 2
int dmxShadowFB = FALSE;

d112 2
d615 2
d745 1
a748 1
#endif
a858 3

    dmxLog(dmxInfo, "Shadow framebuffer support %s\n",
           dmxShadowFB ? "enabled" : "disabled");
a952 4
        dmxLog(dmxWarning,
               "-noshadowfb has been deprecated "
               "since it is now the default\n");
        dmxShadowFB = FALSE;
a959 1
        dmxShadowFB = TRUE;
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d71 1
d76 2
d592 14
d614 1
a614 1
    Bool glxSupported = TRUE;
d743 3
d928 1
a928 1
OsVendorFatalError(void)
@


1.5
log
@Update to xserver 1.11.2
@
text
@d58 2
a59 1
#include <X11/Xos.h>                /* For gettimeofday */
d73 1
a73 1
#endif /* GLXEXT */
d76 2
a77 2
int             dmxNumScreens;
DMXScreenInfo  *dmxScreens;
d79 2
a80 2
int             dmxNumInputs;
DMXInputInfo   *dmxInputs;
d82 1
a82 1
int             dmxShadowFB = FALSE;
d84 2
a85 2
XErrorEvent     dmxLastErrorEvent;
Bool            dmxErrorOccurred = FALSE;
d87 1
a87 1
char           *dmxFontPath = NULL;
d89 1
a89 1
Bool            dmxOffScreenOpt = TRUE;
d91 1
a91 1
Bool            dmxSubdividePrimitives = TRUE;
d93 1
a93 1
Bool            dmxLazyWindowCreation = TRUE;
d95 1
a95 1
Bool            dmxUseXKB = TRUE;
d97 1
a97 1
int             dmxDepth = 0;
d100 1
a100 1
static Bool     dmxGLXProxy = FALSE;
d102 1
a102 1
Bool            dmxGLXProxy = TRUE;
d104 1
a104 1
Bool            dmxGLXSwapGroupSupport = TRUE;
d106 1
a106 1
Bool            dmxGLXSyncSwap = FALSE;
d108 1
a108 1
Bool            dmxGLXFinishSwap = FALSE;
d111 1
a111 1
Bool            dmxIgnoreBadFontPaths = FALSE;
d113 1
a113 1
Bool            dmxAddRemoveScreens = FALSE;
d118 2
a119 1
static int dmxErrorHandler(Display *dpy, XErrorEvent *ev)
d122 4
a125 4
                                /* RATS: these buffers are only used in
                                 * length-limited calls. */
    char        buf[DMX_ERROR_BUF_SIZE];
    char        request[DMX_ERROR_BUF_SIZE];
d128 1
a128 1
    dmxErrorOccurred  = TRUE;
d134 1
a134 1
                                /* Find major opcode name */
d136 1
a136 1
        XmuSnprintf(request, sizeof(request), "%d", ev->request_code);
d138 2
a139 1
    } else {
d143 4
a146 2
        if (ext) strncpy(buf, ext->name, sizeof(buf));
        else     buf[0] = '\0';
d151 1
a151 1
                                /* Find minor opcode name */
d153 2
a154 3
        XmuSnprintf(request, sizeof(request), "%d", ev->request_code);
        XmuSnprintf(request, sizeof(request), "%s.%d",
                    ext->name, ev->minor_code);
d160 1
a160 1
                                /* Provide value information */
d176 1
a176 1
                                /* Provide serial number information */
d185 2
a186 1
static int dmxNOPErrorHandler(Display *dpy, XErrorEvent *ev)
d192 2
a193 1
Bool dmxOpenDisplay(DMXScreenInfo *dmxScreen)
d196 1
a196 1
	return FALSE;
d202 2
a203 1
void dmxSetErrorHandler(DMXScreenInfo *dmxScreen)
d208 2
a209 1
static void dmxPrintScreenInfo(DMXScreenInfo *dmxScreen)
d212 5
a216 5
    int               ndepths = 0, *depths = NULL;
    int               i;
    Display           *dpy   = dmxScreen->beDisplay;
    Screen            *s     = DefaultScreenOfDisplay(dpy);
    int               scr    = DefaultScreen(dpy);
d219 3
a221 2
    if (!(depths = XListDepths(dpy, scr, &ndepths))) ndepths = 0;
    
d228 4
a231 3
    } else {
                                /* This code based on xdpyinfo.c */
    	int v = VendorRelease(dpy);
d241 2
a242 1
                if (v % 10) subpatch = v % 10;
d244 2
a245 1
        } else if (v < 40000000) {
d248 4
a251 2
            if (v % 10) patch = v % 10;
	} else {
d255 3
a257 2
            if (v % 1000) subpatch = v % 1000;
	}
d260 4
a263 2
        if (patch > 0)    dmxLogOutputCont(dmxScreen, ".%d", patch);
        if (subpatch > 0) dmxLogOutputCont(dmxScreen, ".%d", subpatch);
d267 1
a267 2
    
    dmxLogOutput(dmxScreen, "Dimensions:      %dx%d pixels\n", 
d279 3
a281 3
                 (DoesBackingStore (s) == NotUseful) ? "no" :
                 ((DoesBackingStore (s) == Always) ? "yes" : "when mapped"),
                 DoesSaveUnders (s) ? "yes" : "no");
d283 1
a283 1
		 (dmxScreen->WMRunningOnBE) ? "yes" : "no");
d286 3
a288 3
	dmxLogOutputWarning(dmxScreen,
			    "Window manager running "
			    "-- colormaps not supported\n");
d293 2
a294 1
void dmxGetScreenAttribs(DMXScreenInfo *dmxScreen)
d297 2
a298 1
    Display           *dpy   = dmxScreen->beDisplay;
d300 1
a300 1
    int               dummy;
d305 1
a305 1
    dmxScreen->beWidth  = attribs.width;
d307 2
a308 2
    
                                /* Fill in missing geometry information */
d311 6
a316 5
            dmxScreen->scrnX   = (attribs.width - dmxScreen->scrnWidth
				  - dmxScreen->scrnX);
        } else {
            dmxScreen->scrnWidth  = attribs.width - dmxScreen->scrnX;
            dmxScreen->scrnX   = 0;
d321 4
a324 3
            dmxScreen->scrnY   = (attribs.height - dmxScreen->scrnHeight
				  - dmxScreen->scrnY);
        } else {
d326 1
a326 1
            dmxScreen->scrnY   = 0;
d330 1
a330 1
        dmxScreen->scrnWidth  = attribs.width  - dmxScreen->scrnX;
d334 4
a337 2
    if (!dmxScreen->rootWidth)  dmxScreen->rootWidth  = dmxScreen->scrnWidth;
    if (!dmxScreen->rootHeight) dmxScreen->rootHeight = dmxScreen->scrnHeight;
d347 14
a360 11
    dmxScreen->beDepth  = attribs.depth; /* FIXME: verify that this
					  * works always.  In
					  * particular, this will work
					  * well for depth=16, will fail
					  * because of colormap issues
					  * at depth 8.  More work needs
					  * to be done here. */

    if (dmxScreen->beDepth <= 8)       dmxScreen->beBPP = 8;
    else if (dmxScreen->beDepth <= 16) dmxScreen->beBPP = 16;
    else                               dmxScreen->beBPP = 32;
d365 1
a365 1
		    &dummy, &dmxScreen->glxErrorBase);
d379 2
a380 1
Bool dmxGetVisualInfo(DMXScreenInfo *dmxScreen)
d387 2
a388 3
					  VisualScreenMask,
					  &visinfo,
					  &dmxScreen->beNumVisuals);
d393 30
a422 27
	for (i = 0; i < dmxScreen->beNumVisuals; i++)
	    if (defaultColorVisualClass >= 0) {
		if (dmxScreen->beVisuals[i].class == defaultColorVisualClass) {
		    if (dmxDepth > 0) {
			if (dmxScreen->beVisuals[i].depth == dmxDepth) {
			    dmxScreen->beDefVisualIndex = i;
			    break;
			}
		    } else {
			dmxScreen->beDefVisualIndex = i;
			break;
		    }
		}
	    } else if (dmxScreen->beVisuals[i].depth == dmxDepth) {
		dmxScreen->beDefVisualIndex = i;
		break;
	    }
    } else {
	visinfo.visualid =
	    XVisualIDFromVisual(DefaultVisual(dmxScreen->beDisplay,
					      visinfo.screen));

	for (i = 0; i < dmxScreen->beNumVisuals; i++)
	    if (visinfo.visualid == dmxScreen->beVisuals[i].visualid) {
		dmxScreen->beDefVisualIndex = i;
		break;
	    }
d432 2
a433 1
void dmxGetColormaps(DMXScreenInfo *dmxScreen)
d439 1
a439 1
				       sizeof(*dmxScreen->beDefColormaps));
d442 4
a445 5
	dmxScreen->beDefColormaps[i] =
	    XCreateColormap(dmxScreen->beDisplay,
			    DefaultRootWindow(dmxScreen->beDisplay),
			    dmxScreen->beVisuals[i].visual,
			    AllocNone);
d448 1
a448 1
					 DefaultScreen(dmxScreen->beDisplay));
d450 1
a450 1
					 DefaultScreen(dmxScreen->beDisplay));
d453 2
a454 1
void dmxGetPixmapFormats(DMXScreenInfo *dmxScreen)
d457 2
a458 2
	XListDepths(dmxScreen->beDisplay, DefaultScreen(dmxScreen->beDisplay),
		    &dmxScreen->beNumDepths);
d461 2
a462 2
	XListPixmapFormats(dmxScreen->beDisplay,
			   &dmxScreen->beNumPixmapFormats);
d465 2
a466 2
static Bool dmxSetPixmapFormats(ScreenInfo *pScreenInfo,
				DMXScreenInfo *dmxScreen)
d469 2
a470 2
    PixmapFormatRec     *format;
    int                  i, j;
d479 13
a491 13
	bePixmapFormat = &dmxScreen->bePixmapFormats[i];
	for (j = 0; j < dmxScreen->beNumDepths; j++)
	    if ((bePixmapFormat->depth == 1) ||
		(bePixmapFormat->depth == dmxScreen->beDepths[j])) {
		format = &pScreenInfo->formats[pScreenInfo->numPixmapFormats];

		format->depth        = bePixmapFormat->depth;
		format->bitsPerPixel = bePixmapFormat->bits_per_pixel;
		format->scanlinePad  = bePixmapFormat->scanline_pad;

		pScreenInfo->numPixmapFormats++;
		break;
	    }
d497 2
a498 1
void dmxCheckForWM(DMXScreenInfo *dmxScreen)
d504 2
a505 2
				  DefaultRootWindow(dmxScreen->beDisplay),
				  &xwa);
d507 3
a509 3
	(status &&
	 ((xwa.all_event_masks & SubstructureRedirectMask) ||
	  (xwa.all_event_masks & SubstructureNotifyMask)));
d514 2
a515 1
static void dmxDisplayInit(DMXScreenInfo *dmxScreen)
d518 2
a519 3
	dmxLog(dmxFatal,
               "dmxOpenDisplay: Unable to open display %s\n",
               dmxScreen->name);
d526 1
a526 1
	dmxLog(dmxFatal, "dmxGetVisualInfo: No matching visuals found\n");
d535 6
a540 2
#if !defined(_POSIX_SOURCE) 
static const char *dmxExecOS(void) { return ""; }
d543 2
a544 1
static const char *dmxExecOS(void)
d547 1
a547 1
    static int  initialized = 0;
d553 2
a554 2
        XmuSnprintf(buffer, sizeof(buffer)-1, "%s %s %s",
                    u.sysname, u.release, u.version);
d560 2
a561 1
static const char *dmxBuildCompiler(void)
d564 1
a564 1
    static int  initialized = 0;
d569 2
a570 2
        XmuSnprintf(buffer, sizeof(buffer)-1, "gcc %d.%d.%d",
                    __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);
d576 2
a577 1
static const char *dmxExecHost(void)
d580 1
a580 1
    static int  initialized = 0;
d590 2
a591 1
void InitOutput(ScreenInfo *pScreenInfo, int argc, char *argv[])
d593 1
a593 1
    int                  i;
d595 1
d597 1
a597 1
    Bool                 glxSupported  = TRUE;
d601 1
a601 1
	int vendrel = VENDOR_RELEASE;
d603 1
a603 1
        
d606 13
a618 12
        major    = vendrel / 100000000;
        vendrel -= major   * 100000000;
        minor    = vendrel /   1000000;
        vendrel -= minor   *   1000000;
        year     = vendrel /     10000;
        vendrel -= year    *     10000;
        month    = vendrel /       100;
        vendrel -= month   *       100;
        day      = vendrel;

                                /* Add other epoch tests here */
        if (major > 0 && minor > 0) year += 2000;
d642 2
a643 1
        for (i = 0; i < dmxNumInputs; i++) dmxInputFree(&dmxInputs[i]);
d646 2
a647 2
        dmxScreens    = NULL;
        dmxInputs     = NULL;
d649 1
a649 1
        dmxNumInputs  = 0;
d654 3
a656 3
	/* Currently it is not possible to support GLX and Render
	 * extensions with dynamic screen addition/removal due to the
	 * state that each extension keeps, which cannot be restored. */
d658 1
a658 1
	       "GLX Proxy and Render extensions do not yet support dynamic\n");
d660 1
a660 1
	       "screen addition and removal.  Please specify -noglxproxy\n");
d662 1
a662 1
	       "and -norender on the command line or in the configuration\n");
d664 1
a664 1
	       "file to disable these two extensions if you wish to use\n");
d666 1
a666 1
	       "the dynamic addition and removal of screens support.\n");
d668 1
a668 1
	       "Dynamic screen addition/removal error (see above).\n");
d679 1
a679 1
    
d684 1
a684 1
	       "InitOutput: Disabling lazy window creation optimization\n");
d686 3
a688 4
	       "            since it requires the offscreen optimization\n");
        dmxLog(dmxInfo,
	       "            to function properly.\n");
	dmxLazyWindowCreation = FALSE;
d704 3
a706 2
       the pixmap formats to match that screen.  FIXME: this isn't true.*/
    if (!dmxSetPixmapFormats(pScreenInfo, &dmxScreens[0])) return;
d725 1
a725 1
	glxSupported &= (dmxScreens[i].glxMajorOpcode > 0);
d732 75
a806 73
	if (glxSupported) {
	    /*
	     * Builds GLX configurations from the list of visuals
	     * supported by the back-end server, and give that
	     * configuration list to the glx layer - so that he will
	     * build the visuals accordingly.
	     */

	    DMXScreenInfo       *dmxScreen    = &dmxScreens[i];
	    __GLXvisualConfig   *configs      = NULL;
	    dmxGlxVisualPrivate **configprivs = NULL;
	    int                 nconfigs      = 0;
	    int                 (*oldErrorHandler)(Display *, XErrorEvent *);
	    int                 i;

	    /* Catch errors if when using an older GLX w/o FBconfigs */
	    oldErrorHandler = XSetErrorHandler(dmxNOPErrorHandler);

	    /* Get FBConfigs of the back-end server */
	    dmxScreen->fbconfigs = GetGLXFBConfigs(dmxScreen->beDisplay,
						   dmxScreen->glxMajorOpcode,
						   &dmxScreen->numFBConfigs);

	    XSetErrorHandler(oldErrorHandler);

	    dmxScreen->glxVisuals = 
		GetGLXVisualConfigs(dmxScreen->beDisplay,
				    DefaultScreen(dmxScreen->beDisplay),
				    &dmxScreen->numGlxVisuals);

	    if (dmxScreen->fbconfigs) {
		configs =
		    GetGLXVisualConfigsFromFBConfigs(dmxScreen->fbconfigs,
						     dmxScreen->numFBConfigs,
						     dmxScreen->beVisuals,
						     dmxScreen->beNumVisuals,
						     dmxScreen->glxVisuals,
						     dmxScreen->numGlxVisuals,
						     &nconfigs);
	    } else {
		configs = dmxScreen->glxVisuals;
		nconfigs = dmxScreen->numGlxVisuals;
	    }

	    configprivs = malloc(nconfigs * sizeof(dmxGlxVisualPrivate*));

	    if (configs != NULL && configprivs != NULL) {

		/* Initialize our private info for each visual
		 * (currently only x_visual_depth and x_visual_class)
		 */
		for (i = 0; i < nconfigs; i++) {

		    configprivs[i] = (dmxGlxVisualPrivate *)
			malloc(sizeof(dmxGlxVisualPrivate));
		    configprivs[i]->x_visual_depth = 0;
		    configprivs[i]->x_visual_class = 0;

		    /* Find the visual depth */
		    if (configs[i].vid > 0) {
			int  j;
			for (j = 0; j < dmxScreen->beNumVisuals; j++) {
			    if (dmxScreen->beVisuals[j].visualid ==
				configs[i].vid) {
				configprivs[i]->x_visual_depth =
				    dmxScreen->beVisuals[j].depth;
				configprivs[i]->x_visual_class =
				    dmxScreen->beVisuals[j].class;
				break;
			    }
			}
		    }
		}
d809 3
a811 3
	    }
	}
#endif  /* GLXEXT */
d813 1
a813 1
	AddScreen(dmxScreenInit, argc, argv);
d832 1
a832 1
	dmxInitRender();
d839 1
a839 1
	   dmxShadowFB ? "enabled" : "disabled");
d844 3
a846 2
         strcpy. */ 
static void dmxSetDefaultFontPath(char *fp)
a847 2
    int fplen = strlen(fp) + 1;
    
d849 2
a850 1
	int len;
d852 6
a857 7
	len = strlen(dmxFontPath);
	dmxFontPath = realloc(dmxFontPath, len+fplen+1);
	dmxFontPath[len] = ',';
	strncpy(&dmxFontPath[len+1], fp, fplen);
    } else {
	dmxFontPath = malloc(fplen);
	strncpy(dmxFontPath, fp, fplen);
d866 2
a867 1
void AbortDDX(enum ExitCode error)
d871 1
a871 1
    for (i=0; i < dmxNumScreens; i++) {
d873 3
a875 2
        
        if (dmxScreen->beDisplay) XCloseDisplay(dmxScreen->beDisplay);
d881 2
a882 1
void ddxBeforeReset(void)
d890 2
a891 1
void ddxGiveUp(enum ExitCode error)
d897 2
a898 1
void OsVendorInit(void)
d907 2
a908 1
void OsVendorFatalError(void)
d913 2
a914 1
int ddxProcessArgument(int argc, char *argv[], int i)
d917 1
a917 1
    
d919 2
a920 1
	if (++i < argc) dmxConfigStoreDisplay(argv[i]);
d922 4
a925 2
    } else if (!strcmp(argv[i], "-inputfrom") || !strcmp(argv[i], "-input")) {
	if (++i < argc) dmxConfigStoreInput(argv[i]);
d927 4
a930 2
    } else if (!strcmp(argv[i], "-xinputfrom") || !strcmp(argv[i],"-xinput")) {
        if (++i < argc) dmxConfigStoreXInput(argv[i]);
d932 2
a933 1
    } else if (!strcmp(argv[i], "-noshadowfb")) {
d936 5
a940 4
	       "since it is now the default\n");
	dmxShadowFB = FALSE;
	retval = 1;
    } else if (!strcmp(argv[i], "-nomulticursor")) {
d942 9
a950 6
	retval = 1;
    } else if (!strcmp(argv[i], "-shadowfb")) {
	dmxShadowFB = TRUE;
	retval = 1;
    } else if (!strcmp(argv[i], "-configfile")) {
        if (++i < argc) dmxConfigStoreFile(argv[i]);
d952 4
a955 2
    } else if (!strcmp(argv[i], "-config")) {
        if (++i < argc) dmxConfigStoreConfig(argv[i]);
d957 4
a960 2
    } else if (!strcmp(argv[i], "-fontpath")) {
        if (++i < argc) dmxSetDefaultFontPath(argv[i]);
d962 4
a965 2
    } else if (!strcmp(argv[i], "-stat")) {
        if ((i += 2) < argc) dmxStatActivate(argv[i-1], argv[i]);
d967 4
a970 2
    } else if (!strcmp(argv[i], "-syncbatch")) {
        if (++i < argc) dmxSyncActivate(argv[i]);
d972 3
a974 2
    } else if (!strcmp(argv[i], "-nooffscreenopt")) {
	dmxOffScreenOpt = FALSE;
d976 3
a978 2
    } else if (!strcmp(argv[i], "-nosubdivprims")) {
	dmxSubdividePrimitives = FALSE;
d980 3
a982 2
    } else if (!strcmp(argv[i], "-nowindowopt")) {
	dmxLazyWindowCreation = FALSE;
d984 3
a986 2
    } else if (!strcmp(argv[i], "-noxkb")) {
	dmxUseXKB = FALSE;
d988 4
a991 2
    } else if (!strcmp(argv[i], "-depth")) {
        if (++i < argc) dmxDepth = atoi(argv[i]);
d993 3
a995 2
    } else if (!strcmp(argv[i], "-norender")) {
	noRenderExtension = TRUE;
d998 3
a1000 2
    } else if (!strcmp(argv[i], "-noglxproxy")) {
	dmxGLXProxy = FALSE;
d1002 3
a1004 2
    } else if (!strcmp(argv[i], "-noglxswapgroup")) {
	dmxGLXSwapGroupSupport = FALSE;
d1006 3
a1008 2
    } else if (!strcmp(argv[i], "-glxsyncswap")) {
	dmxGLXSyncSwap = TRUE;
d1010 3
a1012 2
    } else if (!strcmp(argv[i], "-glxfinishswap")) {
	dmxGLXFinishSwap = TRUE;
d1015 3
a1017 2
    } else if (!strcmp(argv[i], "-ignorebadfontpaths")) {
	dmxIgnoreBadFontPaths = TRUE;
d1019 3
a1021 2
    } else if (!strcmp(argv[i], "-addremovescreens")) {
	dmxAddRemoveScreens = TRUE;
d1023 2
a1024 1
    } else if (!strcmp(argv[i], "-param")) {
d1026 1
a1026 1
            if (!strcasecmp(argv[i-1], "xkbrules"))
d1028 1
a1028 1
            else if (!strcasecmp(argv[i-1], "xkbmodel"))
d1030 1
a1030 1
            else if (!strcasecmp(argv[i-1], "xkblayout"))
d1032 1
a1032 1
            else if (!strcasecmp(argv[i-1], "xkbvariant"))
d1034 1
a1034 1
            else if (!strcasecmp(argv[i-1], "xkboptions"))
d1043 2
a1044 1
    if (!serverGeneration) dmxConfigSetMaxScreens();
d1049 2
a1050 1
void ddxUseMsg(void)
d1078 2
a1079 1
    ErrorF("-ignorebadfontpaths  Ignore bad font paths during initialization\n");
d1091 1
a1091 1
    
d1097 1
a1097 1
    
d1106 1
a1106 1
    
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a71 6

extern void GlxSetVisualConfigs(
    int               nconfigs,
    __GLXvisualConfig *configs,
    void              **configprivs
);
a764 3
		/* Hand out the glx configs to glx extension */
		GlxSetVisualConfigs(nconfigs, configs, (void**)configprivs);

d824 1
a824 1
void AbortDDX(void)
d845 1
a845 1
void ddxGiveUp(void)
d847 1
a847 1
    AbortDDX();
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a55 1
#ifdef RENDER
a56 1
#endif
d407 1
a407 1
    return (dmxScreen->beDefVisualIndex >= 0);
d415 1
a415 1
    dmxScreen->beDefColormaps = xalloc(dmxScreen->beNumDefColormaps *
d609 2
a610 2
        if (dmxScreens) free(dmxScreens);
        if (dmxInputs)  free(dmxInputs);
d741 1
a741 1
	    configprivs = xalloc(nconfigs * sizeof(dmxGlxVisualPrivate*));
d751 1
a751 1
			xalloc(sizeof(dmxGlxVisualPrivate));
a795 1
#ifdef RENDER
a798 1
#endif
d819 1
a819 1
	dmxFontPath = xrealloc(dmxFontPath, len+fplen+1);
d823 1
a823 1
	dmxFontPath = xalloc(fplen);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d62 1
d64 1
d848 6
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86$ */
d511 1
a511 1
#if !defined(_POSIX_SOURCE) && !defined(__sgi)
a540 8
#elif defined(__sgi) && defined(_COMPILER_VERSION) && !defined(__GNUC__)
        {
            int a = _COMPILER_VERSION / 100;
            int b = (_COMPILER_VERSION - a * 100) / 10;
            int c = _COMPILER_VERSION - a * 100 - b * 10;
            XmuSnprintf(buffer, sizeof(buffer)-1, "SGI MIPSpro %d.%d.%d",
                        a, b, c);
        }
d618 1
a618 1
    if (dmxAddRemoveScreens && (!noRenderExtension || dmxGLXProxy)) {
d741 1
a741 2
	    configprivs = xalloc(dmxScreen->beNumVisuals *
				 sizeof(dmxGlxVisualPrivate*));
d773 2
a865 7
{
}

/** This funciton is called by InitGlobals from Xserver/os/utils.c to
 * initialize any ddx specific globals at a very early point in the
 * server startup. */
void ddxInitGlobals(void)
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@Import xserver version 1.2.0 (X.Org 7.2 final).
@
text
@d627 1
a627 1
    if (dmxAddRemoveScreens && dmxGLXProxy) {
@


1.1.1.3
log
@xserver 1.4
@
text
@d1 1
@


