head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.8
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.6
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.21.20.10.48;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.09;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/**************************************************************************

   Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
   Copyright 2000 VA Linux Systems, Inc.
   Copyright (c) 2002-2012 Apple Computer, Inc.
   All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the
   "Software"), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sub license, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:

   The above copyright notice and this permission notice (including the
   next paragraph) shall be included in all copies or substantial portions
   of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
   IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
   ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Jens Owen <jens@@valinux.com>
 *   Rickard E. (Rik) Faith <faith@@valinux.com>
 *   Jeremy Huddleston <jeremyhu@@apple.com>
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <sys/time.h>
#include <unistd.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "misc.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "extinit.h"
#include "colormapst.h"
#include "cursorstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "servermd.h"
#define _APPLEDRI_SERVER_
#include "appledristr.h"
#include "swaprep.h"
#include "dri.h"
#include "dristruct.h"
#include "mi.h"
#include "mipointer.h"
#include "rootless.h"
#include "rootlessCommon.h"
#include "x-hash.h"
#include "x-hook.h"
#include "driWrap.h"

#include <AvailabilityMacros.h>

static DevPrivateKeyRec DRIScreenPrivKeyRec;
#define DRIScreenPrivKey       (&DRIScreenPrivKeyRec)
static DevPrivateKeyRec DRIWindowPrivKeyRec;
#define DRIWindowPrivKey       (&DRIWindowPrivKeyRec)
static DevPrivateKeyRec DRIPixmapPrivKeyRec;
#define DRIPixmapPrivKey       (&DRIPixmapPrivKeyRec)
static DevPrivateKeyRec DRIPixmapBufferPrivKeyRec;
#define DRIPixmapBufferPrivKey (&DRIPixmapBufferPrivKeyRec)

static RESTYPE DRIDrawablePrivResType;

static x_hash_table *surface_hash;      /* maps surface ids -> drawablePrivs */

static Bool
DRIFreePixmapImp(DrawablePtr pDrawable);

typedef struct {
    DrawablePtr pDrawable;
    int refCount;
    int bytesPerPixel;
    int width;
    int height;
    char shmPath[PATH_MAX];
    int fd; /* From shm_open (for now) */
    size_t length; /* length of buffer */
    void *buffer;
} DRIPixmapBuffer, *DRIPixmapBufferPtr;

Bool
DRIScreenInit(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv;
    int i;

    if (!dixRegisterPrivateKey(&DRIScreenPrivKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;
    if (!dixRegisterPrivateKey(&DRIWindowPrivKeyRec, PRIVATE_WINDOW, 0))
        return FALSE;
    if (!dixRegisterPrivateKey(&DRIPixmapPrivKeyRec, PRIVATE_PIXMAP, 0))
        return FALSE;
    if (!dixRegisterPrivateKey(&DRIPixmapBufferPrivKeyRec, PRIVATE_PIXMAP, 0))
        return FALSE;

    pDRIPriv = (DRIScreenPrivPtr)calloc(1, sizeof(DRIScreenPrivRec));
    if (!pDRIPriv) {
        dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, NULL);
        return FALSE;
    }

    dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, pDRIPriv);
    pDRIPriv->directRenderingSupport = TRUE;
    pDRIPriv->nrWindows = 0;

    /* Initialize drawable tables */
    for (i = 0; i < DRI_MAX_DRAWABLES; i++) {
        pDRIPriv->DRIDrawables[i] = NULL;
    }

    return TRUE;
}

Bool
DRIFinishScreenInit(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    /* Wrap DRI support */
    pDRIPriv->wrap.CopyWindow = pScreen->CopyWindow;
    pScreen->CopyWindow = DRICopyWindow;

    pDRIPriv->wrap.ClipNotify = pScreen->ClipNotify;
    pScreen->ClipNotify = DRIClipNotify;

    //    ErrorF("[DRI] screen %d installation complete\n", pScreen->myNum);

    return DRIWrapInit(pScreen);
}

void
DRICloseScreen(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (pDRIPriv && pDRIPriv->directRenderingSupport) {
        free(pDRIPriv);
        dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, NULL);
    }
}

Bool
DRIExtensionInit(void)
{
    DRIDrawablePrivResType = CreateNewResourceType(DRIDrawablePrivDelete,
                                                   "DRIDrawable");

    return DRIDrawablePrivResType != 0;
}

void
DRIReset(void)
{
    /*
     * This stub routine is called when the X Server recycles, resources
     * allocated by DRIExtensionInit need to be managed here.
     *
     * Currently this routine is a stub because all the interesting resources
     * are managed via the screen init process.
     */
}

Bool
DRIQueryDirectRenderingCapable(ScreenPtr pScreen, Bool* isCapable)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (pDRIPriv)
        *isCapable = pDRIPriv->directRenderingSupport;
    else
        *isCapable = FALSE;

    return TRUE;
}

Bool
DRIAuthConnection(ScreenPtr pScreen, unsigned int magic)
{
#if 0
    /* FIXME: something? */

    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (drmAuthMagic(pDRIPriv->drmFD, magic)) return FALSE;
#endif
    return TRUE;
}

static void
DRIUpdateSurface(DRIDrawablePrivPtr pDRIDrawablePriv, DrawablePtr pDraw)
{
    xp_window_changes wc;
    unsigned int flags = 0;

    if (pDRIDrawablePriv->sid == 0)
        return;

#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1030
    wc.depth = (pDraw->bitsPerPixel == 32 ? XP_DEPTH_ARGB8888
                : pDraw->bitsPerPixel == 16 ? XP_DEPTH_RGB555 : XP_DEPTH_NIL);
    if (wc.depth != XP_DEPTH_NIL)
        flags |= XP_DEPTH;
#endif

    if (pDraw->type == DRAWABLE_WINDOW) {
        WindowPtr pWin = (WindowPtr)pDraw;
        WindowPtr pTopWin = TopLevelParent(pWin);

        wc.x = pWin->drawable.x - (pTopWin->drawable.x - pTopWin->borderWidth);
        wc.y = pWin->drawable.y - (pTopWin->drawable.y - pTopWin->borderWidth);
        wc.width = pWin->drawable.width + 2 * pWin->borderWidth;
        wc.height = pWin->drawable.height + 2 * pWin->borderWidth;
        wc.bit_gravity = XP_GRAVITY_NONE;

        wc.shape_nrects = RegionNumRects(&pWin->clipList);
        wc.shape_rects = RegionRects(&pWin->clipList);
        wc.shape_tx = -(pTopWin->drawable.x - pTopWin->borderWidth);
        wc.shape_ty = -(pTopWin->drawable.y - pTopWin->borderWidth);

        flags |= XP_BOUNDS | XP_SHAPE;

    }
    else if (pDraw->type == DRAWABLE_PIXMAP) {
        wc.x = 0;
        wc.y = 0;
        wc.width = pDraw->width;
        wc.height = pDraw->height;
        wc.bit_gravity = XP_GRAVITY_NONE;
        flags |= XP_BOUNDS;
    }

    xp_configure_surface(pDRIDrawablePriv->sid, flags, &wc);
}

/* Return NULL if an error occurs. */
static DRIDrawablePrivPtr
CreateSurfaceForWindow(ScreenPtr pScreen, WindowPtr pWin,
                       xp_window_id *widPtr)
{
    DRIDrawablePrivPtr pDRIDrawablePriv;
    xp_window_id wid = 0;

    *widPtr = 0;

    pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);

    if (pDRIDrawablePriv == NULL) {
        xp_error err;
        xp_window_changes wc;

        /* allocate a DRI Window Private record */
        if (!(pDRIDrawablePriv = malloc(sizeof(*pDRIDrawablePriv)))) {
            return NULL;
        }

        pDRIDrawablePriv->pDraw = (DrawablePtr)pWin;
        pDRIDrawablePriv->pScreen = pScreen;
        pDRIDrawablePriv->refCount = 0;
        pDRIDrawablePriv->drawableIndex = -1;
        pDRIDrawablePriv->notifiers = NULL;

        /* find the physical window */
        wid = x_cvt_vptr_to_uint(RootlessFrameForWindow(pWin, TRUE));

        if (wid == 0) {
            free(pDRIDrawablePriv);
            return NULL;
        }

        /* allocate the physical surface */
        err = xp_create_surface(wid, &pDRIDrawablePriv->sid);

        if (err != Success) {
            free(pDRIDrawablePriv);
            return NULL;
        }

        /* Make it visible */
        wc.stack_mode = XP_MAPPED_ABOVE;
        wc.sibling = 0;
        err = xp_configure_surface(pDRIDrawablePriv->sid, XP_STACKING, &wc);

        if (err != Success) {
            xp_destroy_surface(pDRIDrawablePriv->sid);
            free(pDRIDrawablePriv);
            return NULL;
        }

        /* save private off of preallocated index */
        dixSetPrivate(&pWin->devPrivates, DRIWindowPrivKey,
                      pDRIDrawablePriv);
    }

    *widPtr = wid;

    return pDRIDrawablePriv;
}

/* Return NULL if an error occurs. */
static DRIDrawablePrivPtr
CreateSurfaceForPixmap(ScreenPtr pScreen, PixmapPtr pPix)
{
    DRIDrawablePrivPtr pDRIDrawablePriv;

    pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_PIXMAP(pPix);

    if (pDRIDrawablePriv == NULL) {
        xp_error err;

        /* allocate a DRI Window Private record */
        if (!(pDRIDrawablePriv = calloc(1, sizeof(*pDRIDrawablePriv)))) {
            return NULL;
        }

        pDRIDrawablePriv->pDraw = (DrawablePtr)pPix;
        pDRIDrawablePriv->pScreen = pScreen;
        pDRIDrawablePriv->refCount = 0;
        pDRIDrawablePriv->drawableIndex = -1;
        pDRIDrawablePriv->notifiers = NULL;

        /* Passing a null window id to Xplugin in 10.3+ asks for
           an accelerated offscreen surface. */

        err = xp_create_surface(0, &pDRIDrawablePriv->sid);
        if (err != Success) {
            free(pDRIDrawablePriv);
            return NULL;
        }

        /*
         * The DRIUpdateSurface will be called to resize the surface
         * after this function, if the export is successful.
         */

        /* save private off of preallocated index */
        dixSetPrivate(&pPix->devPrivates, DRIPixmapPrivKey,
                      pDRIDrawablePriv);
    }

    return pDRIDrawablePriv;
}

Bool
DRICreateSurface(ScreenPtr pScreen, Drawable id,
                 DrawablePtr pDrawable, xp_client_id client_id,
                 xp_surface_id *surface_id, unsigned int ret_key[2],
                 void (*notify)(void *arg, void *data), void *notify_data)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    xp_window_id wid = 0;
    DRIDrawablePrivPtr pDRIDrawablePriv;

    if (pDrawable->type == DRAWABLE_WINDOW) {
        /* <rdar://problem/12338921>
         * http://bugs.winehq.org/show_bug.cgi?id=31751
         */
        RootlessStopDrawing((WindowPtr)pDrawable, FALSE);

        pDRIDrawablePriv = CreateSurfaceForWindow(pScreen,
                                                  (WindowPtr)pDrawable, &wid);

        if (NULL == pDRIDrawablePriv)
            return FALSE;  /*error*/
    }
#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1030
    else if (pDrawable->type == DRAWABLE_PIXMAP) {
        pDRIDrawablePriv = CreateSurfaceForPixmap(pScreen,
                                                  (PixmapPtr)pDrawable);

        if (NULL == pDRIDrawablePriv)
            return FALSE;  /*error*/
    }
#endif
    else {
        /* We handle GLXPbuffers in a different way (via CGL). */
        return FALSE;
    }

    /* Finish initialization of new surfaces */
    if (pDRIDrawablePriv->refCount == 0) {
        unsigned int key[2] = { 0 };
        xp_error err;

        /* try to give the client access to the surface */
        if (client_id != 0) {
            /*
             * Xplugin accepts a 0 wid if the surface id is offscreen, such
             * as for a pixmap.
             */
            err = xp_export_surface(wid, pDRIDrawablePriv->sid,
                                    client_id, key);
            if (err != Success) {
                xp_destroy_surface(pDRIDrawablePriv->sid);
                free(pDRIDrawablePriv);

                /*
                 * Now set the dix privates to NULL that were previously set.
                 * This prevents reusing an invalid pointer.
                 */
                if (pDrawable->type == DRAWABLE_WINDOW) {
                    WindowPtr pWin = (WindowPtr)pDrawable;

                    dixSetPrivate(&pWin->devPrivates, DRIWindowPrivKey, NULL);
                }
                else if (pDrawable->type == DRAWABLE_PIXMAP) {
                    PixmapPtr pPix = (PixmapPtr)pDrawable;

                    dixSetPrivate(&pPix->devPrivates, DRIPixmapPrivKey, NULL);
                }

                return FALSE;
            }
        }

        pDRIDrawablePriv->key[0] = key[0];
        pDRIDrawablePriv->key[1] = key[1];

        ++pDRIPriv->nrWindows;

        /* and stash it by surface id */
        if (surface_hash == NULL)
            surface_hash = x_hash_table_new(NULL, NULL, NULL, NULL);
        x_hash_table_insert(surface_hash,
                            x_cvt_uint_to_vptr(
                                pDRIDrawablePriv->sid), pDRIDrawablePriv);

        /* track this in case this window is destroyed */
        AddResource(id, DRIDrawablePrivResType, (void *)pDrawable);

        /* Initialize shape */
        DRIUpdateSurface(pDRIDrawablePriv, pDrawable);
    }

    pDRIDrawablePriv->refCount++;

    *surface_id = pDRIDrawablePriv->sid;

    if (ret_key != NULL) {
        ret_key[0] = pDRIDrawablePriv->key[0];
        ret_key[1] = pDRIDrawablePriv->key[1];
    }

    if (notify != NULL) {
        pDRIDrawablePriv->notifiers = x_hook_add(pDRIDrawablePriv->notifiers,
                                                 notify, notify_data);
    }

    return TRUE;
}

Bool
DRIDestroySurface(ScreenPtr pScreen, Drawable id, DrawablePtr pDrawable,
                  void (*notify)(void *, void *), void *notify_data)
{
    DRIDrawablePrivPtr pDRIDrawablePriv;

    if (pDrawable->type == DRAWABLE_WINDOW) {
        pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW((WindowPtr)pDrawable);
    }
    else if (pDrawable->type == DRAWABLE_PIXMAP) {
        pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_PIXMAP((PixmapPtr)pDrawable);
    }
    else {
        return FALSE;
    }

    if (pDRIDrawablePriv != NULL) {
        /*
         * This doesn't seem to be used, because notify is NULL in all callers.
         */

        if (notify != NULL) {
            pDRIDrawablePriv->notifiers = x_hook_remove(
                pDRIDrawablePriv->notifiers,
                notify, notify_data);
        }

        --pDRIDrawablePriv->refCount;

        /*
         * Check if the drawable privates still have a reference to the
         * surface.
         */

        if (pDRIDrawablePriv->refCount <= 0) {
            /*
             * This calls back to DRIDrawablePrivDelete which
             * frees the private area and dispatches events, if needed.
             */
            FreeResourceByType(id, DRIDrawablePrivResType, FALSE);
        }
    }

    return TRUE;
}

/*
 * The assumption is that this is called when the refCount of a surface
 * drops to <= 0, or the window/pixmap is destroyed.
 */
Bool
DRIDrawablePrivDelete(void *pResource, XID id)
{
    DrawablePtr pDrawable = (DrawablePtr)pResource;
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pDrawable->pScreen);
    DRIDrawablePrivPtr pDRIDrawablePriv = NULL;
    WindowPtr pWin = NULL;
    PixmapPtr pPix = NULL;

    if (pDrawable->type == DRAWABLE_WINDOW) {
        pWin = (WindowPtr)pDrawable;
        pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
    }
    else if (pDrawable->type == DRAWABLE_PIXMAP) {
        pPix = (PixmapPtr)pDrawable;
        pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_PIXMAP(pPix);
    }

    if (pDRIDrawablePriv == NULL) {
        /*
         * We reuse __func__ and the resource type for the GLXPixmap code.
         * Attempt to free a pixmap buffer associated with the resource
         * if possible.
         */
        return DRIFreePixmapImp(pDrawable);
    }

    if (pDRIDrawablePriv->drawableIndex != -1) {
        /* release drawable table entry */
        pDRIPriv->DRIDrawables[pDRIDrawablePriv->drawableIndex] = NULL;
    }

    if (pDRIDrawablePriv->sid != 0) {
        DRISurfaceNotify(pDRIDrawablePriv->sid,
                         AppleDRISurfaceNotifyDestroyed);
    }

    if (pDRIDrawablePriv->notifiers != NULL)
        x_hook_free(pDRIDrawablePriv->notifiers);

    free(pDRIDrawablePriv);

    if (pDrawable->type == DRAWABLE_WINDOW) {
        dixSetPrivate(&pWin->devPrivates, DRIWindowPrivKey, NULL);
    }
    else if (pDrawable->type == DRAWABLE_PIXMAP) {
        dixSetPrivate(&pPix->devPrivates, DRIPixmapPrivKey, NULL);
    }

    --pDRIPriv->nrWindows;

    return TRUE;
}

void
DRICopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIDrawablePrivPtr pDRIDrawablePriv;

    if (pDRIPriv->nrWindows > 0) {
        pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
        if (pDRIDrawablePriv != NULL) {
            DRIUpdateSurface(pDRIDrawablePriv, &pWin->drawable);
        }
    }

    /* unwrap */
    pScreen->CopyWindow = pDRIPriv->wrap.CopyWindow;

    /* call lower layers */
    (*pScreen->CopyWindow)(pWin, ptOldOrg, prgnSrc);

    /* rewrap */
    pScreen->CopyWindow = DRICopyWindow;
}

void
DRIClipNotify(WindowPtr pWin, int dx, int dy)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIDrawablePrivPtr pDRIDrawablePriv;

    if ((pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin))) {
        DRIUpdateSurface(pDRIDrawablePriv, &pWin->drawable);
    }

    if (pDRIPriv->wrap.ClipNotify) {
        pScreen->ClipNotify = pDRIPriv->wrap.ClipNotify;

        (*pScreen->ClipNotify)(pWin, dx, dy);

        pScreen->ClipNotify = DRIClipNotify;
    }
}

/* This lets us get at the unwrapped functions so that they can correctly
 * call the lower level functions, and choose whether they will be
 * called at every level of recursion (eg in validatetree).
 */
DRIWrappedFuncsRec *
DRIGetWrappedFuncs(ScreenPtr pScreen)
{
    return &(DRI_SCREEN_PRIV(pScreen)->wrap);
}

void
DRIQueryVersion(int *majorVersion,
                int *minorVersion,
                int *patchVersion)
{
    *majorVersion = APPLE_DRI_MAJOR_VERSION;
    *minorVersion = APPLE_DRI_MINOR_VERSION;
    *patchVersion = APPLE_DRI_PATCH_VERSION;
}

/*
 * Note: this also cleans up the hash table in addition to notifying clients.
 * The sid/surface-id should not be used after this, because it will be
 * invalid.
 */
void
DRISurfaceNotify(xp_surface_id id, int kind)
{
    DRIDrawablePrivPtr pDRIDrawablePriv = NULL;
    DRISurfaceNotifyArg arg;

    arg.id = id;
    arg.kind = kind;

    if (surface_hash != NULL) {
        pDRIDrawablePriv = x_hash_table_lookup(surface_hash,
                                               x_cvt_uint_to_vptr(id), NULL);
    }

    if (pDRIDrawablePriv == NULL)
        return;

    if (kind == AppleDRISurfaceNotifyDestroyed) {
        x_hash_table_remove(surface_hash, x_cvt_uint_to_vptr(id));
    }

    x_hook_run(pDRIDrawablePriv->notifiers, &arg);

    if (kind == AppleDRISurfaceNotifyDestroyed) {
        xp_error error;

        error = xp_destroy_surface(pDRIDrawablePriv->sid);

        if (error)
            ErrorF("%s: xp_destroy_surface failed: %d\n", __func__, error);

        /* Guard against reuse, even though we are freeing after this. */
        pDRIDrawablePriv->sid = 0;

        FreeResourceByType(pDRIDrawablePriv->pDraw->id,
                           DRIDrawablePrivResType, FALSE);
    }
}

/*
 * This creates a shared memory buffer for use with GLXPixmaps
 * and AppleSGLX.
 */
Bool
DRICreatePixmap(ScreenPtr pScreen, Drawable id,
                DrawablePtr pDrawable, char *path,
                size_t pathmax)
{
    DRIPixmapBufferPtr shared;
    PixmapPtr pPix;

    if (pDrawable->type != DRAWABLE_PIXMAP)
        return FALSE;

    pPix = (PixmapPtr)pDrawable;

    shared = malloc(sizeof(*shared));
    if (NULL == shared) {
        FatalError("failed to allocate DRIPixmapBuffer in %s\n", __func__);
    }

    shared->pDrawable = pDrawable;
    shared->refCount = 1;

    if (pDrawable->bitsPerPixel >= 24) {
        shared->bytesPerPixel = 4;
    }
    else if (pDrawable->bitsPerPixel <= 16) {
        shared->bytesPerPixel = 2;
    }

    shared->width = pDrawable->width;
    shared->height = pDrawable->height;

    if (-1 == snprintf(shared->shmPath, sizeof(shared->shmPath),
                       "%d_0x%lx", getpid(),
                       (unsigned long)id)) {
        FatalError("buffer overflow in %s\n", __func__);
    }

    shared->fd = shm_open(shared->shmPath,
                          O_RDWR | O_EXCL | O_CREAT,
                          S_IRUSR | S_IWUSR | S_IROTH | S_IWOTH);

    if (-1 == shared->fd) {
        free(shared);
        return FALSE;
    }

    shared->length = shared->width * shared->height * shared->bytesPerPixel;

    if (-1 == ftruncate(shared->fd, shared->length)) {
        ErrorF("failed to ftruncate (extend) file.");
        shm_unlink(shared->shmPath);
        close(shared->fd);
        free(shared);
        return FALSE;
    }

    shared->buffer = mmap(NULL, shared->length,
                          PROT_READ | PROT_WRITE,
                          MAP_FILE | MAP_SHARED, shared->fd, 0);

    if (MAP_FAILED == shared->buffer) {
        ErrorF("failed to mmap shared memory.");
        shm_unlink(shared->shmPath);
        close(shared->fd);
        free(shared);
        return FALSE;
    }

    strlcpy(path, shared->shmPath, pathmax);

    dixSetPrivate(&pPix->devPrivates, DRIPixmapBufferPrivKey, shared);

    AddResource(id, DRIDrawablePrivResType, (void *)pDrawable);

    return TRUE;
}

Bool
DRIGetPixmapData(DrawablePtr pDrawable, int *width, int *height,
                 int *pitch, int *bpp, void **ptr)
{
    PixmapPtr pPix;
    DRIPixmapBufferPtr shared;

    if (pDrawable->type != DRAWABLE_PIXMAP)
        return FALSE;

    pPix = (PixmapPtr)pDrawable;

    shared = dixLookupPrivate(&pPix->devPrivates, DRIPixmapBufferPrivKey);

    if (NULL == shared)
        return FALSE;

    assert(pDrawable->width == shared->width);
    assert(pDrawable->height == shared->height);

    *width = shared->width;
    *height = shared->height;
    *bpp = shared->bytesPerPixel;
    *pitch = shared->width * shared->bytesPerPixel;
    *ptr = shared->buffer;

    return TRUE;
}

static Bool
DRIFreePixmapImp(DrawablePtr pDrawable)
{
    DRIPixmapBufferPtr shared;
    PixmapPtr pPix;

    if (pDrawable->type != DRAWABLE_PIXMAP)
        return FALSE;

    pPix = (PixmapPtr)pDrawable;

    shared = dixLookupPrivate(&pPix->devPrivates, DRIPixmapBufferPrivKey);

    if (NULL == shared)
        return FALSE;

    close(shared->fd);
    munmap(shared->buffer, shared->length);
    shm_unlink(shared->shmPath);
    free(shared);

    dixSetPrivate(&pPix->devPrivates, DRIPixmapBufferPrivKey, (void *)NULL);

    return TRUE;
}

void
DRIDestroyPixmap(DrawablePtr pDrawable)
{
    if (DRIFreePixmapImp(pDrawable))
        FreeResourceByType(pDrawable->id, DRIDrawablePrivResType, FALSE);

}
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a140 9
    pDRIPriv->wrap.ValidateTree = pScreen->ValidateTree;
    pScreen->ValidateTree = DRIValidateTree;

    pDRIPriv->wrap.PostValidateTree = pScreen->PostValidateTree;
    pScreen->PostValidateTree = DRIPostValidateTree;

    pDRIPriv->wrap.WindowExposures = pScreen->WindowExposures;
    pScreen->WindowExposures = DRIWindowExposures;

a576 18
DRIWindowExposures(WindowPtr pWin, RegionPtr prgn, RegionPtr bsreg)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIDrawablePrivPtr pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);

    if (pDRIDrawablePriv) {
        /* FIXME: something? */
    }

    pScreen->WindowExposures = pDRIPriv->wrap.WindowExposures;

    (*pScreen->WindowExposures)(pWin, prgn, bsreg);

    pScreen->WindowExposures = DRIWindowExposures;
}

void
a597 45
}

int
DRIValidateTree(WindowPtr pParent, WindowPtr pChild, VTKind kind)
{
    ScreenPtr pScreen = pParent->drawable.pScreen;
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    int returnValue;

    /* unwrap */
    pScreen->ValidateTree = pDRIPriv->wrap.ValidateTree;

    /* call lower layers */
    returnValue = (*pScreen->ValidateTree)(pParent, pChild, kind);

    /* rewrap */
    pScreen->ValidateTree = DRIValidateTree;

    return returnValue;
}

void
DRIPostValidateTree(WindowPtr pParent, WindowPtr pChild, VTKind kind)
{
    ScreenPtr pScreen;
    DRIScreenPrivPtr pDRIPriv;

    if (pParent) {
        pScreen = pParent->drawable.pScreen;
    }
    else {
        pScreen = pChild->drawable.pScreen;
    }
    pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (pDRIPriv->wrap.PostValidateTree) {
        /* unwrap */
        pScreen->PostValidateTree = pDRIPriv->wrap.PostValidateTree;

        /* call lower layers */
        (*pScreen->PostValidateTree)(pParent, pChild, kind);

        /* rewrap */
        pScreen->PostValidateTree = DRIPostValidateTree;
    }
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d458 1
a458 1
        AddResource(id, DRIDrawablePrivResType, (pointer)pDrawable);
d532 1
a532 1
DRIDrawablePrivDelete(pointer pResource, XID id)
d832 1
a832 1
    AddResource(id, DRIDrawablePrivResType, (pointer)pDrawable);
d887 1
a887 1
    dixSetPrivate(&pPix->devPrivates, DRIPixmapBufferPrivKey, (pointer)NULL);
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a40 4
#ifdef XFree86LOADER
#include "xf86.h"
#include "xf86_ansic.h"
#else
a42 1
#endif
d53 1
d67 1
d384 5
@


1.6
log
@Update to xserver 1.11.2
@
text
@d3 24
a26 24
Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
Copyright 2000 VA Linux Systems, Inc.
Copyright (c) 2002, 2009 Apple Computer, Inc.
All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sub license, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d34 1
a34 1
 *
d78 1
a78 1
#define DRIScreenPrivKey (&DRIScreenPrivKeyRec)
d80 1
a80 1
#define DRIWindowPrivKey (&DRIWindowPrivKeyRec)
d82 1
a82 1
#define DRIPixmapPrivKey (&DRIPixmapPrivKeyRec)
d90 2
a91 1
static Bool DRIFreePixmapImp(DrawablePtr pDrawable);
d102 1
a102 1
    void *buffer;       
d108 2
a109 2
    DRIScreenPrivPtr    pDRIPriv;
    int                 i;
d112 1
a112 1
	return FALSE;
d114 1
a114 1
	return FALSE;
d116 1
a116 1
	return FALSE;
d118 1
a118 1
	return FALSE;
d120 1
a120 1
    pDRIPriv = (DRIScreenPrivPtr) calloc(1, sizeof(DRIScreenPrivRec));
d122 1
a122 1
	dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, NULL);
d141 1
a141 1
    DRIScreenPrivPtr  pDRIPriv = DRI_SCREEN_PRIV(pScreen);
d171 1
a171 1
	dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, NULL);
d179 1
a179 1
						   "DRIDrawable");
d239 1
a239 1
        WindowPtr pWin = (WindowPtr) pDraw;
d250 2
a251 2
        wc.shape_tx = - (pTopWin->drawable.x - pTopWin->borderWidth);
        wc.shape_ty = - (pTopWin->drawable.y - pTopWin->borderWidth);
d255 2
a256 1
    } else if (pDraw->type == DRAWABLE_PIXMAP) {
d270 3
a272 1
CreateSurfaceForWindow(ScreenPtr pScreen, WindowPtr pWin, xp_window_id *widPtr) {
d281 44
a324 44
	xp_error err;
	xp_window_changes wc;
	
	/* allocate a DRI Window Private record */
	if (!(pDRIDrawablePriv = malloc(sizeof(*pDRIDrawablePriv)))) {
	    return NULL;
	}
	
	pDRIDrawablePriv->pDraw = (DrawablePtr)pWin;
	pDRIDrawablePriv->pScreen = pScreen;
	pDRIDrawablePriv->refCount = 0;
	pDRIDrawablePriv->drawableIndex = -1;
	pDRIDrawablePriv->notifiers = NULL;
	
	/* find the physical window */
	wid = x_cvt_vptr_to_uint(RootlessFrameForWindow(pWin, TRUE));

	if (wid == 0) {
	    free(pDRIDrawablePriv);
	    return NULL;
	}
	
	/* allocate the physical surface */
	err = xp_create_surface(wid, &pDRIDrawablePriv->sid);

	if (err != Success) {
	    free(pDRIDrawablePriv);
	    return NULL;
	}

	/* Make it visible */
	wc.stack_mode = XP_MAPPED_ABOVE;
	wc.sibling = 0;
	err = xp_configure_surface(pDRIDrawablePriv->sid, XP_STACKING, &wc);

	if (err != Success) {
	    xp_destroy_surface(pDRIDrawablePriv->sid);
	    free(pDRIDrawablePriv);
	    return NULL;
	}

	/* save private off of preallocated index */
	dixSetPrivate(&pWin->devPrivates, DRIWindowPrivKey,
		      pDRIDrawablePriv);
d334 2
a335 1
CreateSurfaceForPixmap(ScreenPtr pScreen, PixmapPtr pPix) {
d337 1
a337 1
     
d341 6
a346 1
	xp_error err;
d348 23
a370 28
	/* allocate a DRI Window Private record */
	if (!(pDRIDrawablePriv = calloc(1, sizeof(*pDRIDrawablePriv)))) {
	    return NULL;
	}
	
	pDRIDrawablePriv->pDraw = (DrawablePtr)pPix;
	pDRIDrawablePriv->pScreen = pScreen;
	pDRIDrawablePriv->refCount = 0;
	pDRIDrawablePriv->drawableIndex = -1;
	pDRIDrawablePriv->notifiers = NULL;
	
	/* Passing a null window id to Xplugin in 10.3+ asks for
	   an accelerated offscreen surface. */
	
	err = xp_create_surface(0, &pDRIDrawablePriv->sid);
	if (err != Success) {
	    free(pDRIDrawablePriv);
	    return NULL;
	}

	/* 
	 * The DRIUpdateSurface will be called to resize the surface
	 * after this function, if the export is successful.
	 */

	/* save private off of preallocated index */
	dixSetPrivate(&pPix->devPrivates, DRIPixmapPrivKey,
		      pDRIDrawablePriv);
d372 1
a372 1
    
a375 1

d380 1
a380 1
                 void (*notify) (void *arg, void *data), void *notify_data)
d382 3
a384 3
    DRIScreenPrivPtr    pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    xp_window_id        wid = 0;
    DRIDrawablePrivPtr  pDRIDrawablePriv;
d387 2
a388 2
	pDRIDrawablePriv = CreateSurfaceForWindow(pScreen, 
						  (WindowPtr)pDrawable, &wid);
d390 2
a391 2
	if(NULL == pDRIDrawablePriv)
	    return FALSE; /*error*/
d395 2
a396 2
	pDRIDrawablePriv = CreateSurfaceForPixmap(pScreen, 
						  (PixmapPtr)pDrawable);
d398 2
a399 2
	if(NULL == pDRIDrawablePriv)
	    return FALSE; /*error*/
d403 1
a403 1
	/* We handle GLXPbuffers in a different way (via CGL). */
d406 1
a406 2
    
    
d409 1
a409 1
        unsigned int key[2] = {0};
d414 4
a417 4
	    /*
	     * Xplugin accepts a 0 wid if the surface id is offscreen, such 
	     * as for a pixmap.
	     */
d423 16
a438 15
		
		/* 
		 * Now set the dix privates to NULL that were previously set.
		 * This prevents reusing an invalid pointer.
		 */
		if(pDrawable->type == DRAWABLE_WINDOW) {
		    WindowPtr pWin = (WindowPtr)pDrawable;
		    
		    dixSetPrivate(&pWin->devPrivates, DRIWindowPrivKey, NULL);
		} else if(pDrawable->type == DRAWABLE_PIXMAP) {
		    PixmapPtr pPix = (PixmapPtr)pDrawable;
		    
		    dixSetPrivate(&pPix->devPrivates, DRIPixmapPrivKey, NULL);
		}
		
d452 2
a453 1
                            x_cvt_uint_to_vptr(pDRIDrawablePriv->sid), pDRIDrawablePriv);
d481 1
a481 1
                  void (*notify) (void *, void *), void *notify_data)
d483 1
a483 1
    DRIDrawablePrivPtr  pDRIDrawablePriv;
d487 2
a488 1
    } else if (pDrawable->type == DRAWABLE_PIXMAP) {
d490 2
a491 1
    } else {
d496 3
a498 3
	/*
	 * This doesn't seem to be used, because notify is NULL in all callers.
	 */
d501 3
a503 2
            pDRIDrawablePriv->notifiers = x_hook_remove(pDRIDrawablePriv->notifiers,
                                                        notify, notify_data);
d506 1
a506 1
	--pDRIDrawablePriv->refCount;
d508 4
a511 4
	/* 
	 * Check if the drawable privates still have a reference to the
	 * surface.
	 */
d515 3
a517 3
	     * This calls back to DRIDrawablePrivDelete which
	     * frees the private area and dispatches events, if needed. 
	     */
d525 1
a525 1
/* 
d527 1
a527 1
 * drops to <= 0, or the window/pixmap is destroyed.  
d532 5
a536 5
    DrawablePtr         pDrawable = (DrawablePtr)pResource;
    DRIScreenPrivPtr    pDRIPriv = DRI_SCREEN_PRIV(pDrawable->pScreen);
    DRIDrawablePrivPtr  pDRIDrawablePriv = NULL;
    WindowPtr           pWin = NULL;
    PixmapPtr           pPix = NULL;
d541 2
a542 1
    } else if (pDrawable->type == DRAWABLE_PIXMAP) {
d548 6
a553 6
	/* 
	 * We reuse __func__ and the resource type for the GLXPixmap code.
	 * Attempt to free a pixmap buffer associated with the resource
	 * if possible.
	 */
	return DRIFreePixmapImp(pDrawable);
d555 1
a555 1
    
d562 2
a563 1
	DRISurfaceNotify(pDRIDrawablePriv->sid, AppleDRISurfaceNotifyDestroyed);
a564 1
  
d572 4
a575 3
	dixSetPrivate(&pWin->devPrivates, DRIWindowPrivKey, NULL);
    } else if (pDrawable->type == DRAWABLE_PIXMAP) {
	dixSetPrivate(&pPix->devPrivates, DRIPixmapPrivKey, NULL);
d609 2
a610 2
       pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
       if (pDRIDrawablePriv != NULL) {
d612 1
a612 1
       }
d652 2
a653 1
    } else {
d675 1
a675 1
    DRIDrawablePrivPtr  pDRIDrawablePriv;
d710 1
a710 1
/* 
d714 1
a714 1
 */ 
d724 1
a724 2
    if (surface_hash != NULL)
    {
d732 2
a733 3
    if (kind == AppleDRISurfaceNotifyDestroyed)
    {
	x_hash_table_remove(surface_hash, x_cvt_uint_to_vptr(id));
d738 10
a747 11
    if (kind == AppleDRISurfaceNotifyDestroyed)
    {
	xp_error error;
	
	error = xp_destroy_surface(pDRIDrawablePriv->sid);
	
	if(error) 
	    ErrorF("%s: xp_destroy_surface failed: %d\n", __func__, error);
		
	/* Guard against reuse, even though we are freeing after this. */
	pDRIDrawablePriv->sid = 0;
d758 4
a761 3
Bool DRICreatePixmap(ScreenPtr pScreen, Drawable id,
		     DrawablePtr pDrawable, char *path,
		     size_t pathmax) 
d765 3
a767 3
    
    if(pDrawable->type != DRAWABLE_PIXMAP)
	return FALSE;
d772 1
a772 1
    if(NULL == shared) {
d775 1
a775 1
        
d779 5
a783 4
    if(pDrawable->bitsPerPixel >= 24) {
	shared->bytesPerPixel = 4;
    } else if(pDrawable->bitsPerPixel <= 16) {
	shared->bytesPerPixel = 2;
d785 1
a785 1
    
d788 4
a791 4
    
    if(-1 == snprintf(shared->shmPath, sizeof(shared->shmPath),
                      "%d_0x%lx", getpid(),
                      (unsigned long)id)) {
d794 3
a796 3
    
    shared->fd = shm_open(shared->shmPath, 
                          O_RDWR | O_EXCL | O_CREAT, 
d798 3
a800 3
    
    if(-1 == shared->fd) {
	free(shared);
d802 2
a803 2
    }   
    
d805 7
a811 7
    
    if(-1 == ftruncate(shared->fd, shared->length)) {
	ErrorF("failed to ftruncate (extend) file.");
	shm_unlink(shared->shmPath);
	close(shared->fd);
	free(shared);
	return FALSE;
d817 11
a827 12
    
    if(MAP_FAILED == shared->buffer) {
	ErrorF("failed to mmap shared memory.");
	shm_unlink(shared->shmPath);
	close(shared->fd);
	free(shared);
	return FALSE;
    }
    
    strncpy(path, shared->shmPath, pathmax);
    path[pathmax - 1] = '\0';
    
d835 4
a838 3

Bool DRIGetPixmapData(DrawablePtr pDrawable, int *width, int *height,
		      int *pitch, int *bpp, void **ptr) {
d842 2
a843 2
    if(pDrawable->type != DRAWABLE_PIXMAP)
	return FALSE;
d849 2
a850 2
    if(NULL == shared)
	return FALSE;
d854 1
a854 1
    
d859 1
a859 1
    *ptr = shared->buffer;    
d865 2
a866 1
DRIFreePixmapImp(DrawablePtr pDrawable) {
d870 2
a871 2
    if(pDrawable->type != DRAWABLE_PIXMAP)
	return FALSE;
d877 2
a878 2
    if(NULL == shared)
	return FALSE;
d890 5
a894 4
void 
DRIDestroyPixmap(DrawablePtr pDrawable) {
    if(DRIFreePixmapImp(pDrawable))
	FreeResourceByType(pDrawable->id, DRIDrawablePrivResType, FALSE);
@


1.5
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d398 2
a399 2
    else { /* for GLX 1.3, a PBuffer */
        /* NOT_DONE */
d489 4
d497 13
a509 3
        if (--pDRIDrawablePriv->refCount <= 0) {
            /* This calls back to DRIDrawablePrivDelete
               which frees the private area */
d517 4
d539 5
d546 1
a546 1

d553 1
a553 2
        xp_destroy_surface(pDRIDrawablePriv->sid);
        x_hash_table_remove(surface_hash, x_cvt_uint_to_vptr(pDRIDrawablePriv->sid));
d555 1
a587 1
    pDRIPriv->wrap.WindowExposures = pScreen->WindowExposures;
a611 1
    pDRIPriv->wrap.CopyWindow = pScreen->CopyWindow;
a628 1
    pDRIPriv->wrap.ValidateTree = pScreen->ValidateTree;
a654 1
        pDRIPriv->wrap.PostValidateTree = pScreen->PostValidateTree;
a674 1
        pDRIPriv->wrap.ClipNotify = pScreen->ClipNotify;
d699 5
d724 1
a724 2
        pDRIDrawablePriv->sid = 0;
        x_hash_table_remove(surface_hash, x_cvt_uint_to_vptr(id));
d731 9
a739 1
        /* Kill off the handle. */
d746 4
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a91 8
/* FIXME: don't hardcode this? */
#define CG_INFO_FILE "/System/Library/Frameworks/ApplicationServices.framework/Frameworks/CoreGraphics.framework/Resources/Info-macos.plist"

/* Corresponds to SU Jaguar Green */
#define CG_REQUIRED_MAJOR 1
#define CG_REQUIRED_MINOR 157
#define CG_REQUIRED_MICRO 11

a103 90
/* Returns version as major.minor.micro in 10.10.10 fixed form */
static unsigned int
get_cg_version (void)
{
    static unsigned int version;

    FILE *fh;
    char *ptr;

    if (version != 0)
        return version;

    /* I tried CFBundleGetVersion, but it returns zero, so.. */

    fh = fopen (CG_INFO_FILE, "r");
    if (fh != NULL)
    {
        char buf[256];

        while (fgets (buf, sizeof (buf), fh) != NULL)
        {
            unsigned char c;

            if (!strstr (buf, "<key>CFBundleShortVersionString</key>")
                || fgets (buf, sizeof (buf), fh) == NULL)
            {
                continue;
            }

            ptr = strstr (buf, "<string>");
            if (ptr == NULL)
                continue;

            ptr += strlen ("<string>");

            /* Now PTR points to "MAJOR.MINOR.MICRO". */

            version = 0;

        again:
            switch ((c = *ptr++))
            {
            case '.':
                version = version * 1024;
                goto again;

            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                version = ((version & ~0x3ff)
                          + (version & 0x3ff) * 10 + (c - '0'));
                goto again;
            }
            break;
        }

        fclose (fh);
    }

    return version;
}

static Bool
test_cg_version (unsigned int major, unsigned int minor, unsigned int micro)
{
    unsigned int cg_ver = get_cg_version ();

    unsigned int cg_major = (cg_ver >> 20) & 0x3ff;
    unsigned int cg_minor = (cg_ver >> 10) & 0x3ff;
    unsigned int cg_micro =  cg_ver        & 0x3ff;

    if (cg_major > major)
        return TRUE;
    else if (cg_major < major)
        return FALSE;

    /* cg_major == major */

    if (cg_minor > minor)
        return TRUE;
    else if (cg_minor < minor)
        return FALSE;

    /* cg_minor == minor */

    if (cg_micro < micro)
        return FALSE;

    return TRUE;
}

a127 14

    /* Need recent cg for window access update */
    if (!test_cg_version (CG_REQUIRED_MAJOR,
                          CG_REQUIRED_MINOR,
                          CG_REQUIRED_MICRO))
    {
        ErrorF ("[DRI] disabled direct rendering; requires CoreGraphics %d.%d.%d\n",
                CG_REQUIRED_MAJOR, CG_REQUIRED_MINOR, CG_REQUIRED_MICRO);

        pDRIPriv->directRenderingSupport = FALSE;

        /* Note we don't nuke the dri private, since we need it for
           managing indirect surfaces. */
    }
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d77 8
a84 8
static int DRIScreenPrivKeyIndex;
static DevPrivateKey DRIScreenPrivKey = &DRIScreenPrivKeyIndex;
static int DRIWindowPrivKeyIndex;
static DevPrivateKey DRIWindowPrivKey = &DRIWindowPrivKeyIndex;
static int DRIPixmapPrivKeyIndex;
static DevPrivateKey DRIPixmapPrivKey = &DRIPixmapPrivKeyIndex;
static int DRIPixmapBufferPrivKeyIndex;
static DevPrivateKey DRIPixmapBufferPrivKey = &DRIPixmapBufferPrivKeyIndex;
d208 10
a217 1
    pDRIPriv = (DRIScreenPrivPtr) xcalloc(1, sizeof(DRIScreenPrivRec));
d281 1
a281 1
        xfree(pDRIPriv);
d292 1
a292 1
    return (DRIDrawablePrivResType != 0);
d359 2
a360 2
        wc.shape_nrects = REGION_NUM_RECTS(&pWin->clipList);
        wc.shape_rects = REGION_RECTS(&pWin->clipList);
d393 1
a393 1
	if (!(pDRIDrawablePriv = xalloc(sizeof(*pDRIDrawablePriv)))) {
d407 1
a407 1
	    xfree(pDRIDrawablePriv);
d415 1
a415 1
	    xfree(pDRIDrawablePriv);
d426 1
a426 1
	    xfree(pDRIDrawablePriv);
d451 1
a451 1
	if (!(pDRIDrawablePriv = xcalloc(1, sizeof(*pDRIDrawablePriv)))) {
d466 1
a466 1
	    xfree(pDRIDrawablePriv);
d531 1
a531 1
                xfree(pDRIDrawablePriv);
d649 1
a649 1
    xfree(pDRIDrawablePriv);
d840 1
a840 1
    shared = xalloc(sizeof(*shared));
d868 1
a868 1
	xfree(shared);
d878 1
a878 1
	xfree(shared);
d890 1
a890 1
	xfree(shared);
d950 1
a950 1
    xfree(shared);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d5 1
a5 1
Copyright (c) 2002 Apple Computer, Inc.
a48 2
#define NEED_REPLIES
#define NEED_EVENTS
d51 4
d73 1
d83 2
d90 2
d100 12
d263 1
a263 1
    return TRUE;
d280 2
a281 1
    DRIDrawablePrivResType = CreateNewResourceType(DRIDrawablePrivDelete);
d283 1
a283 1
    return TRUE;
d431 1
a431 1
/* Return FALSE if an error occurs. */
a439 1
	xp_window_changes wc;
d461 4
a464 12
	wc.x = 0;
        wc.y = 0;
        wc.width = pPix->drawable.width;
        wc.height = pPix->drawable.height;

	err = xp_configure_surface(pDRIDrawablePriv->sid, XP_BOUNDS, &wc);

	if(err != Success) {
	    xp_destroy_surface(pDRIDrawablePriv->sid);
	    xfree(pDRIDrawablePriv);
	    return NULL;
	}
a504 1

d506 1
a506 1

d513 5
a517 1
        if (client_id != 0 && wid != 0) {
d523 15
d623 3
a625 2
    if (pDRIDrawablePriv == NULL)
        return FALSE;
d817 136
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d74 6
a79 3
static DevPrivateKey DRIScreenPrivKey = &DRIScreenPrivKey;
static DevPrivateKey DRIWindowPrivKey = &DRIWindowPrivKey;
static DevPrivateKey DRIPixmapPrivKey = &DRIPixmapPrivKey;
d349 115
d471 1
a472 1
    xp_window_id        wid = 0;
d475 2
a476 42
        WindowPtr pWin = (WindowPtr)pDrawable;

        pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
        if (pDRIDrawablePriv == NULL) {
            xp_error err;
            xp_window_changes wc;

            /* allocate a DRI Window Private record */
            if (!(pDRIDrawablePriv = xalloc(sizeof(DRIDrawablePrivRec)))) {
                return FALSE;
            }

            pDRIDrawablePriv->pDraw = pDrawable;
            pDRIDrawablePriv->pScreen = pScreen;
            pDRIDrawablePriv->refCount = 0;
            pDRIDrawablePriv->drawableIndex = -1;
            pDRIDrawablePriv->notifiers = NULL;

            /* find the physical window */
            wid = (xp_window_id) RootlessFrameForWindow(pWin, TRUE);
            if (wid == 0) {
                xfree(pDRIDrawablePriv);
                return FALSE;
            }

            /* allocate the physical surface */
            err = xp_create_surface(wid, &pDRIDrawablePriv->sid);
            if (err != Success) {
                xfree(pDRIDrawablePriv);
                return FALSE;
            }

            /* Make it visible */
            wc.stack_mode = XP_MAPPED_ABOVE;
            wc.sibling = 0;
            err = xp_configure_surface(pDRIDrawablePriv->sid, XP_STACKING, &wc);
            if (err != Success)
            {
                xp_destroy_surface(pDRIDrawablePriv->sid);
                xfree(pDRIDrawablePriv);
                return FALSE;
            }
d478 2
a479 4
            /* save private off of preallocated index */
	    dixSetPrivate(&pWin->devPrivates, DRIWindowPrivKey,
			  pDRIDrawablePriv);
        }
a480 1

d483 2
a484 1
        PixmapPtr pPix = (PixmapPtr)pDrawable;
d486 2
a487 28
        pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_PIXMAP(pPix);
        if (pDRIDrawablePriv == NULL) {
            xp_error err;

            /* allocate a DRI Window Private record */
            if (!(pDRIDrawablePriv = xcalloc(1, sizeof(DRIDrawablePrivRec)))) {
                return FALSE;
            }

            pDRIDrawablePriv->pDraw = pDrawable;
            pDRIDrawablePriv->pScreen = pScreen;
            pDRIDrawablePriv->refCount = 0;
            pDRIDrawablePriv->drawableIndex = -1;
            pDRIDrawablePriv->notifiers = NULL;

            /* Passing a null window id to Xplugin in 10.3+ asks for
               an accelerated offscreen surface. */

            err = xp_create_surface(0, &pDRIDrawablePriv->sid);
            if (err != Success) {
                xfree(pDRIDrawablePriv);
                return FALSE;
            }

            /* save private off of preallocated index */
	    dixSetPrivate(&pPix->devPrivates, DRIPixmapPrivKey,
			  pDRIDrawablePriv);
        }
a489 1

d495 2
d503 1
a503 2
        if (client_id != 0 && wid != 0)
        {
d522 1
a522 1
                            (void *) pDRIDrawablePriv->sid, pDRIDrawablePriv);
d604 1
a604 1
        x_hash_table_remove(surface_hash, (void *) pDRIDrawablePriv->sid);
d766 1
a766 1
                                               (void *) id, NULL);
d775 1
a775 1
        x_hash_table_remove(surface_hash, (void *) id);
@

