head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.10
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.8
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.09;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@/**************************************************************************

   Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
   Copyright 2000 VA Linux Systems, Inc.
   Copyright (c) 2002, 2009-2012 Apple Inc.
   All Rights Reserved.

   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the
   "Software"), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sub license, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:

   The above copyright notice and this permission notice (including the
   next paragraph) shall be included in all copies or substantial portions
   of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
   IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
   ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Kevin E. Martin <martin@@valinux.com>
 *   Jens Owen <jens@@valinux.com>
 *   Rickard E. (Rik) Faith <faith@@valinux.com>
 *   Jeremy Huddleston <jeremyhu@@apple.com>
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "colormapst.h"
#include "cursorstr.h"
#include "scrnintstr.h"
#include "servermd.h"
#define _APPLEDRI_SERVER_
#include "appledristr.h"
#include "swaprep.h"
#include "dri.h"
#include "dristruct.h"
#include "xpr.h"
#include "x-hash.h"
#include "protocol-versions.h"

static int DRIErrorBase = 0;

static void
AppleDRIResetProc(ExtensionEntry* extEntry);
static int
ProcAppleDRICreatePixmap(ClientPtr client);

static unsigned char DRIReqCode = 0;
static int DRIEventBase = 0;

static void
SNotifyEvent(xAppleDRINotifyEvent *from, xAppleDRINotifyEvent *to);

typedef struct _DRIEvent *DRIEventPtr;
typedef struct _DRIEvent {
    DRIEventPtr next;
    ClientPtr client;
    XID clientResource;
    unsigned int mask;
} DRIEventRec;

/*ARGSUSED*/
static void
AppleDRIResetProc(ExtensionEntry* extEntry)
{
    DRIReset();
}

static int
ProcAppleDRIQueryVersion(register ClientPtr client)
{
    xAppleDRIQueryVersionReply rep;

    REQUEST_SIZE_MATCH(xAppleDRIQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_APPLEDRI_MAJOR_VERSION;
    rep.minorVersion = SERVER_APPLEDRI_MINOR_VERSION;
    rep.patchVersion = SERVER_APPLEDRI_PATCH_VERSION;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.majorVersion);
        swaps(&rep.minorVersion);
        swapl(&rep.patchVersion);
    }
    WriteToClient(client, sizeof(xAppleDRIQueryVersionReply), &rep);
    return Success;
}

/* surfaces */

static int
ProcAppleDRIQueryDirectRenderingCapable(register ClientPtr client)
{
    xAppleDRIQueryDirectRenderingCapableReply rep;
    Bool isCapable;

    REQUEST(xAppleDRIQueryDirectRenderingCapableReq);
    REQUEST_SIZE_MATCH(xAppleDRIQueryDirectRenderingCapableReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    if (stuff->screen >= screenInfo.numScreens) {
        return BadValue;
    }

    if (!DRIQueryDirectRenderingCapable(screenInfo.screens[stuff->screen],
                                        &isCapable)) {
        return BadValue;
    }
    rep.isCapable = isCapable;

    if (!client->local)
        rep.isCapable = 0;

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
    }

    WriteToClient(client,
                  sizeof(xAppleDRIQueryDirectRenderingCapableReply),
                  &rep);
    return Success;
}

static int
ProcAppleDRIAuthConnection(register ClientPtr client)
{
    xAppleDRIAuthConnectionReply rep;

    REQUEST(xAppleDRIAuthConnectionReq);
    REQUEST_SIZE_MATCH(xAppleDRIAuthConnectionReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.authenticated = 1;

    if (!DRIAuthConnection(screenInfo.screens[stuff->screen],
                           stuff->magic)) {
        ErrorF("Failed to authenticate %u\n", (unsigned int)stuff->magic);
        rep.authenticated = 0;
    }

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.authenticated); /* Yes, this is a CARD32 ... sigh */
    }

    WriteToClient(client, sizeof(xAppleDRIAuthConnectionReply), &rep);
    return Success;
}

static void
surface_notify(void *_arg,
               void *data)
{
    DRISurfaceNotifyArg *arg = _arg;
    int client_index = (int)x_cvt_vptr_to_uint(data);
    xAppleDRINotifyEvent se;

    if (client_index < 0 || client_index >= currentMaxClients)
        return;

    se.type = DRIEventBase + AppleDRISurfaceNotify;
    se.kind = arg->kind;
    se.arg = arg->id;
    se.time = currentTime.milliseconds;
    WriteEventsToClient(clients[client_index], 1, (xEvent *)&se);
}

static int
ProcAppleDRICreateSurface(ClientPtr client)
{
    xAppleDRICreateSurfaceReply rep;
    DrawablePtr pDrawable;
    xp_surface_id sid;
    unsigned int key[2];
    int rc;

    REQUEST(xAppleDRICreateSurfaceReq);
    REQUEST_SIZE_MATCH(xAppleDRICreateSurfaceReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
                           DixReadAccess);
    if (rc != Success)
        return rc;

    rep.key_0 = rep.key_1 = rep.uid = 0;

    if (!DRICreateSurface(screenInfo.screens[stuff->screen],
                          (Drawable)stuff->drawable, pDrawable,
                          stuff->client_id, &sid, key,
                          surface_notify,
                          x_cvt_uint_to_vptr(client->index))) {
        return BadValue;
    }

    rep.key_0 = key[0];
    rep.key_1 = key[1];
    rep.uid = sid;

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.key_0);
        swapl(&rep.key_1);
        swapl(&rep.uid);
    }

    WriteToClient(client, sizeof(xAppleDRICreateSurfaceReply), &rep);
    return Success;
}

static int
ProcAppleDRIDestroySurface(register ClientPtr client)
{
    int rc;
    REQUEST(xAppleDRIDestroySurfaceReq);
    DrawablePtr pDrawable;
    REQUEST_SIZE_MATCH(xAppleDRIDestroySurfaceReq);

    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
                           DixReadAccess);
    if (rc != Success)
        return rc;

    if (!DRIDestroySurface(screenInfo.screens[stuff->screen],
                           (Drawable)stuff->drawable,
                           pDrawable, NULL, NULL)) {
        return BadValue;
    }

    return Success;
}

static int
ProcAppleDRICreatePixmap(ClientPtr client)
{
    REQUEST(xAppleDRICreatePixmapReq);
    DrawablePtr pDrawable;
    int rc;
    char path[PATH_MAX];
    xAppleDRICreatePixmapReply rep;
    int width, height, pitch, bpp;
    void *ptr;

    REQUEST_SIZE_MATCH(xAppleDRICreatePixmapReq);

    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
                           DixReadAccess);

    if (rc != Success)
        return rc;

    if (!DRICreatePixmap(screenInfo.screens[stuff->screen],
                         (Drawable)stuff->drawable,
                         pDrawable,
                         path, PATH_MAX)) {
        return BadValue;
    }

    if (!DRIGetPixmapData(pDrawable, &width, &height,
                          &pitch, &bpp, &ptr)) {
        return BadValue;
    }

    rep.stringLength = strlen(path) + 1;

    rep.type = X_Reply;
    rep.length = bytes_to_int32(rep.stringLength);
    rep.sequenceNumber = client->sequence;
    rep.width = width;
    rep.height = height;
    rep.pitch = pitch;
    rep.bpp = bpp;
    rep.size = pitch * height;

    if (sizeof(rep) != sz_xAppleDRICreatePixmapReply)
        ErrorF("error sizeof(rep) is %zu\n", sizeof(rep));

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.stringLength);
        swapl(&rep.width);
        swapl(&rep.height);
        swapl(&rep.pitch);
        swapl(&rep.bpp);
        swapl(&rep.size);
    }

    WriteToClient(client, sizeof(rep), &rep);
    WriteToClient(client, rep.stringLength, path);

    return Success;
}

static int
ProcAppleDRIDestroyPixmap(ClientPtr client)
{
    DrawablePtr pDrawable;
    int rc;
    REQUEST(xAppleDRIDestroyPixmapReq);
    REQUEST_SIZE_MATCH(xAppleDRIDestroyPixmapReq);

    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,
                           DixReadAccess);

    if (rc != Success)
        return rc;

    DRIDestroyPixmap(pDrawable);

    return Success;
}

/* dispatch */

static int
ProcAppleDRIDispatch(register ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_AppleDRIQueryVersion:
        return ProcAppleDRIQueryVersion(client);

    case X_AppleDRIQueryDirectRenderingCapable:
        return ProcAppleDRIQueryDirectRenderingCapable(client);
    }

    if (!client->local)
        return DRIErrorBase + AppleDRIClientNotLocal;

    switch (stuff->data) {
    case X_AppleDRIAuthConnection:
        return ProcAppleDRIAuthConnection(client);

    case X_AppleDRICreateSurface:
        return ProcAppleDRICreateSurface(client);

    case X_AppleDRIDestroySurface:
        return ProcAppleDRIDestroySurface(client);

    case X_AppleDRICreatePixmap:
        return ProcAppleDRICreatePixmap(client);

    case X_AppleDRIDestroyPixmap:
        return ProcAppleDRIDestroyPixmap(client);

    default:
        return BadRequest;
    }
}

static void
SNotifyEvent(xAppleDRINotifyEvent *from,
             xAppleDRINotifyEvent *to)
{
    to->type = from->type;
    to->kind = from->kind;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->time, to->time);
    cpswapl(from->arg, to->arg);
}

static int
SProcAppleDRIQueryVersion(register ClientPtr client)
{
    REQUEST(xAppleDRIQueryVersionReq);
    swaps(&stuff->length);
    return ProcAppleDRIQueryVersion(client);
}

static int
SProcAppleDRIQueryDirectRenderingCapable(register ClientPtr client)
{
    REQUEST(xAppleDRIQueryDirectRenderingCapableReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xAppleDRIQueryDirectRenderingCapableReq);
    swapl(&stuff->screen);
    return ProcAppleDRIQueryDirectRenderingCapable(client);
}

static int
SProcAppleDRIAuthConnection(register ClientPtr client)
{
    REQUEST(xAppleDRIAuthConnectionReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xAppleDRIAuthConnectionReq);
    swapl(&stuff->screen);
    swapl(&stuff->magic);
    return ProcAppleDRIAuthConnection(client);
}

static int
SProcAppleDRICreateSurface(register ClientPtr client)
{
    REQUEST(xAppleDRICreateSurfaceReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xAppleDRICreateSurfaceReq);
    swapl(&stuff->screen);
    swapl(&stuff->drawable);
    swapl(&stuff->client_id);
    return ProcAppleDRICreateSurface(client);
}

static int
SProcAppleDRIDestroySurface(register ClientPtr client)
{
    REQUEST(xAppleDRIDestroySurfaceReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xAppleDRIDestroySurfaceReq);
    swapl(&stuff->screen);
    swapl(&stuff->drawable);
    return ProcAppleDRIDestroySurface(client);
}

static int
SProcAppleDRICreatePixmap(register ClientPtr client)
{
    REQUEST(xAppleDRICreatePixmapReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xAppleDRICreatePixmapReq);
    swapl(&stuff->screen);
    swapl(&stuff->drawable);
    return ProcAppleDRICreatePixmap(client);
}

static int
SProcAppleDRIDestroyPixmap(register ClientPtr client)
{
    REQUEST(xAppleDRIDestroyPixmapReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xAppleDRIDestroyPixmapReq);
    swapl(&stuff->drawable);
    return ProcAppleDRIDestroyPixmap(client);
}

static int
SProcAppleDRIDispatch(register ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_AppleDRIQueryVersion:
        return SProcAppleDRIQueryVersion(client);

    case X_AppleDRIQueryDirectRenderingCapable:
        return SProcAppleDRIQueryDirectRenderingCapable(client);
    }

    if (!client->local)
        return DRIErrorBase + AppleDRIClientNotLocal;

    switch (stuff->data) {
    case X_AppleDRIAuthConnection:
        return SProcAppleDRIAuthConnection(client);

    case X_AppleDRICreateSurface:
        return SProcAppleDRICreateSurface(client);

    case X_AppleDRIDestroySurface:
        return SProcAppleDRIDestroySurface(client);

    case X_AppleDRICreatePixmap:
        return SProcAppleDRICreatePixmap(client);

    case X_AppleDRIDestroyPixmap:
        return SProcAppleDRIDestroyPixmap(client);

    default:
        return BadRequest;
    }
}

void
AppleDRIExtensionInit(void)
{
    ExtensionEntry* extEntry;

    if (DRIExtensionInit() &&
        (extEntry = AddExtension(APPLEDRINAME,
                                 AppleDRINumberEvents,
                                 AppleDRINumberErrors,
                                 ProcAppleDRIDispatch,
                                 SProcAppleDRIDispatch,
                                 AppleDRIResetProc,
                                 StandardMinorOpcode))) {
        size_t i;
        DRIReqCode = (unsigned char)extEntry->base;
        DRIErrorBase = extEntry->errorBase;
        DRIEventBase = extEntry->eventBase;
        for (i = 0; i < AppleDRINumberEvents; i++)
            EventSwapVector[DRIEventBase + i] = (EventSwapPtr)SNotifyEvent;
    }
}
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d126 4
d409 1
d419 1
d430 1
d442 1
d453 1
d464 1
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d108 1
a108 1
    WriteToClient(client, sizeof(xAppleDRIQueryVersionReply), (char *)&rep);
d132 1
a132 1
    if (!LocalClient(client))
d142 1
a142 1
                  (char *)&rep);
d171 1
a171 1
    WriteToClient(client, sizeof(xAppleDRIAuthConnectionReply), (char *)&rep);
d235 1
a235 1
    WriteToClient(client, sizeof(xAppleDRICreateSurfaceReply), (char *)&rep);
d357 1
a357 1
    if (!LocalClient(client))
d472 1
a472 1
    if (!LocalClient(client))
@


1.5
log
@Update to xserver 1.11.2
@
text
@d3 24
a26 24
Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
Copyright 2000 VA Linux Systems, Inc.
Copyright (c) 2002, 2009-2011 Apple Inc.
All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sub license, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d35 1
d63 4
a66 3

static void AppleDRIResetProc(ExtensionEntry* extEntry);
static int ProcAppleDRICreatePixmap(ClientPtr client);
d71 2
a72 1
static void SNotifyEvent(xAppleDRINotifyEvent *from, xAppleDRINotifyEvent *to);
d76 4
a79 4
    DRIEventPtr     next;
    ClientPtr       client;
    XID             clientResource;
    unsigned int    mask;
d84 1
a84 3
AppleDRIResetProc (
    ExtensionEntry* extEntry
)
d90 1
a90 3
ProcAppleDRIQueryVersion(
    register ClientPtr client
)
d102 5
a106 6
        register int n;
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swaps(&rep.majorVersion, n);
        swaps(&rep.minorVersion, n);
        swapl(&rep.patchVersion, n);
a111 1

d115 1
a115 3
ProcAppleDRIQueryDirectRenderingCapable(
    register ClientPtr client
)
d126 2
a127 2
    if (!DRIQueryDirectRenderingCapable( screenInfo.screens[stuff->screen], 
                                         &isCapable)) {
d136 2
a137 3
        register int n;
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
d140 3
a142 2
    WriteToClient(client, 
        sizeof(xAppleDRIQueryDirectRenderingCapableReply), (char *)&rep);
d147 1
a147 3
ProcAppleDRIAuthConnection(
    register ClientPtr client
)
d150 1
a150 1
    
d159 2
a160 1
    if (!DRIAuthConnection( screenInfo.screens[stuff->screen], stuff->magic)) {
d166 3
a168 4
        register int n;
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.authenticated, n); /* Yes, this is a CARD32 ... sigh */
d175 3
a177 4
static void surface_notify(
    void *_arg,
    void *data
)
d180 1
a180 1
    int client_index = (int) x_cvt_vptr_to_uint(data);
d190 1
a190 1
    WriteEventsToClient (clients[client_index], 1, (xEvent *) &se);
d194 1
a194 3
ProcAppleDRICreateSurface(
    ClientPtr client
)
d209 1
a209 1
			   DixReadAccess);
d211 1
a211 1
	return rc;
d215 5
a219 5
    if (!DRICreateSurface( screenInfo.screens[stuff->screen],
                           (Drawable)stuff->drawable, pDrawable,
                           stuff->client_id, &sid, key,
                           surface_notify,
                           x_cvt_uint_to_vptr(client->index))) {
d228 5
a232 6
        register int n;
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.key_0, n);
        swapl(&rep.key_1, n);
        swapl(&rep.uid, n);
d240 1
a240 3
ProcAppleDRIDestroySurface(
    register ClientPtr client
)
d248 1
a248 1
			   DixReadAccess);
d250 1
a250 1
	return rc;
d252 3
a254 3
    if (!DRIDestroySurface( screenInfo.screens[stuff->screen], 
                            (Drawable)stuff->drawable,
                            pDrawable, NULL, NULL)) {
d277 1
a277 1
    if(rc != Success)
d279 10
a288 5
    
    if(!DRICreatePixmap(screenInfo.screens[stuff->screen],
                              (Drawable)stuff->drawable,
                              pDrawable,
			      path, PATH_MAX)) {
a291 5
    if(!DRIGetPixmapData(pDrawable, &width, &height,
			 &pitch, &bpp, &ptr)) {
	return BadValue;
    } 
	
d293 1
a293 1
		
d303 3
a305 3
    if(sizeof(rep) != sz_xAppleDRICreatePixmapReply)
	ErrorF("error sizeof(rep) is %zu\n", sizeof(rep)); 
    
d307 8
a314 9
        register int n;
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.stringLength, n);
        swapl(&rep.width, n);
        swapl(&rep.height, n);
        swapl(&rep.pitch, n);
        swapl(&rep.bpp, n);
        swapl(&rep.size, n);
d332 4
a335 1
			    DixReadAccess);
a336 3
    if(rc != Success)
	return rc;
    
d345 1
a345 3
ProcAppleDRIDispatch (
    register ClientPtr client
)
d349 1
a349 2
    switch (stuff->data)
    {
d352 1
d360 1
a360 2
    switch (stuff->data)
    {
d363 1
d366 1
d369 1
d371 2
a372 1
	return ProcAppleDRICreatePixmap(client);
d374 1
a374 1
	return ProcAppleDRIDestroyPixmap(client);
d382 2
a383 4
SNotifyEvent(
    xAppleDRINotifyEvent *from,
    xAppleDRINotifyEvent *to
)
d387 3
a389 3
    cpswaps (from->sequenceNumber, to->sequenceNumber);
    cpswapl (from->time, to->time);
    cpswapl (from->arg, to->arg);
d393 1
a393 3
SProcAppleDRIQueryVersion(
    register ClientPtr client
)
a394 1
    register int n;
d396 1
a396 1
    swaps(&stuff->length, n);
d401 1
a401 3
SProcAppleDRIQueryDirectRenderingCapable(
    register ClientPtr client
)
a402 1
    register int n;
d404 2
a405 2
    swaps(&stuff->length, n);
    swapl(&stuff->screen, n);
d410 1
a410 3
SProcAppleDRIAuthConnection(
    register ClientPtr client
)
a411 1
    register int n;
d413 3
a415 3
    swaps(&stuff->length, n);
    swapl(&stuff->screen, n);
    swapl(&stuff->magic, n);
d420 1
a420 3
SProcAppleDRICreateSurface(
    register ClientPtr client
)
a421 1
    register int n;
d423 4
a426 4
    swaps(&stuff->length, n);
    swapl(&stuff->screen, n);
    swapl(&stuff->drawable, n);
    swapl(&stuff->client_id, n);
d431 1
a431 3
SProcAppleDRIDestroySurface(
    register ClientPtr client
)
a432 1
    register int n;
d434 3
a436 3
    swaps(&stuff->length, n);
    swapl(&stuff->screen, n);
    swapl(&stuff->drawable, n);
d441 1
a441 3
SProcAppleDRICreatePixmap(
    register ClientPtr client
)
a442 1
    register int n;
d444 3
a446 3
    swaps(&stuff->length, n);
    swapl(&stuff->screen, n);
    swapl(&stuff->drawable, n);
d451 1
a451 3
SProcAppleDRIDestroyPixmap(
    register ClientPtr client
)
a452 1
    register int n;
d454 2
a455 2
    swaps(&stuff->length, n);
    swapl(&stuff->drawable, n);
d460 1
a460 3
SProcAppleDRIDispatch (
    register ClientPtr client
)
d464 1
a464 2
    switch (stuff->data)
    {
d467 1
d475 1
a475 2
    switch (stuff->data)
    {
d478 1
d481 1
d484 1
d486 2
a487 1
	return SProcAppleDRICreatePixmap(client);
d489 1
a489 1
	return SProcAppleDRIDestroyPixmap(client);
d513 2
a514 2
        for (i=0; i < AppleDRINumberEvents; i++)
            EventSwapVector[DRIEventBase + i] = (EventSwapPtr) SNotifyEvent;
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d5 1
a5 1
Copyright (c) 2002, 2009 Apple Computer, Inc.
a61 2
static DISPATCH_PROC(ProcAppleDRIDispatch);
static DISPATCH_PROC(SProcAppleDRIDispatch);
a78 21

void
AppleDRIExtensionInit(void)
{
    ExtensionEntry* extEntry;

    if (DRIExtensionInit() &&
        (extEntry = AddExtension(APPLEDRINAME,
                                 AppleDRINumberEvents,
                                 AppleDRINumberErrors,
                                 ProcAppleDRIDispatch,
                                 SProcAppleDRIDispatch,
                                 AppleDRIResetProc,
                                 StandardMinorOpcode))) {
        DRIReqCode = (unsigned char)extEntry->base;
        DRIErrorBase = extEntry->errorBase;
        DRIEventBase = extEntry->eventBase;
        EventSwapVector[DRIEventBase] = (EventSwapPtr) SNotifyEvent;
    }
}

a93 1
    register int n;
d103 1
d106 3
d140 6
d170 8
d237 9
a306 1
    /* No need for swapping, because this only runs if LocalClient is true. */
d308 1
a308 1
    rep.length = sizeof(rep) + rep.stringLength;
d319 14
a332 2
    WriteReplyToClient(client, sizeof(rep), &rep);
    (void)WriteToClient(client, rep.stringLength, path);
d419 77
d502 8
a509 1
    /* It is bound to be non-local when there is byte swapping */
a512 1
    /* only local clients are allowed DRI access */
d515 11
a525 2
    case X_AppleDRIQueryVersion:
        return SProcAppleDRIQueryVersion(client);
d528 22
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d131 1
a131 1
    return (client->noClientException);
d162 1
a162 1
    return (client->noClientException);
d185 1
a185 1
    return (client->noClientException);
a194 1
    ClientPtr client;
a199 4
    client = clients[client_index];
    if (client == NULL || client == serverClient || client->clientGone)
        return;

a202 1
    se.sequenceNumber = client->sequence;
d204 1
a204 1
    WriteEventsToClient (client, 1, (xEvent *) &se);
d244 1
a244 1
    return (client->noClientException);
d268 1
a268 1
    return (client->noClientException);
d320 1
a320 1
    return (client->noClientException);
d339 1
a339 1
    return (client->noClientException);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d5 1
a5 1
Copyright (c) 2002 Apple Computer, Inc.
a41 2
#define NEED_REPLIES
#define NEED_EVENTS
d58 1
d66 1
d123 3
a125 3
    rep.majorVersion = APPLE_DRI_MAJOR_VERSION;
    rep.minorVersion = APPLE_DRI_MINOR_VERSION;
    rep.patchVersion = APPLE_DRI_PATCH_VERSION;
d258 1
a261 1
    int rc;
d277 70
d376 5
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d59 1
d194 1
a194 1
    int client_index = (int) data;
d240 2
a241 1
                           surface_notify, (void *) client->index)) {
@

