head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.20
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.18
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.16
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.14
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.12
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.10
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.8
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.8
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@/* x-list.c
 *
 * Copyright (c) 2002-2012 Apple Inc. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT
 * HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above
 * copyright holders shall not be used in advertising or otherwise to
 * promote the sale, use or other dealings in this Software without
 * prior written authorization.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "x-list.h"
#include <stdlib.h>
#include <assert.h>
#include <pthread.h>

/* Allocate in ~4k blocks */
#define NODES_PER_BLOCK 508

typedef struct x_list_block_struct x_list_block;

struct x_list_block_struct {
    x_list l[NODES_PER_BLOCK];
};

static x_list *freelist;

static pthread_mutex_t freelist_lock = PTHREAD_MUTEX_INITIALIZER;

static inline void
list_free_1(x_list *node)
{
    node->next = freelist;
    freelist = node;
}

X_EXTERN void
X_PFX(list_free_1) (x_list * node) {
    assert(node != NULL);

    pthread_mutex_lock(&freelist_lock);

    list_free_1(node);

    pthread_mutex_unlock(&freelist_lock);
}

X_EXTERN void
X_PFX(list_free) (x_list * lst) {
    x_list *next;

    pthread_mutex_lock(&freelist_lock);

    for (; lst != NULL; lst = next) {
        next = lst->next;
        list_free_1(lst);
    }

    pthread_mutex_unlock(&freelist_lock);
}

X_EXTERN x_list *
X_PFX(list_prepend) (x_list * lst, void *data) {
    x_list *node;

    pthread_mutex_lock(&freelist_lock);

    if (freelist == NULL) {
        x_list_block *b;
        int i;

        b = malloc(sizeof(x_list_block));
        assert(b != NULL);

        for (i = 0; i < NODES_PER_BLOCK - 1; i++)
            b->l[i].next = &(b->l[i + 1]);
        b->l[i].next = NULL;

        freelist = b->l;
    }

    node = freelist;
    freelist = node->next;

    pthread_mutex_unlock(&freelist_lock);

    node->next = lst;
    node->data = data;

    return node;
}

X_EXTERN x_list *
X_PFX(list_append) (x_list * lst, void *data) {
    x_list *head = lst;

    if (lst == NULL)
        return X_PFX(list_prepend) (NULL, data);

    while (lst->next != NULL)
        lst = lst->next;

    lst->next = X_PFX(list_prepend) (NULL, data);

    return head;
}

X_EXTERN x_list *
X_PFX(list_reverse) (x_list * lst) {
    x_list *head = NULL, *next;

    while (lst != NULL)
    {
        next = lst->next;
        lst->next = head;
        head = lst;
        lst = next;
    }

    return head;
}

X_EXTERN x_list *
X_PFX(list_find) (x_list * lst, void *data) {
    for (; lst != NULL; lst = lst->next) {
        if (lst->data == data)
            return lst;
    }

    return NULL;
}

X_EXTERN x_list *
X_PFX(list_nth) (x_list * lst, int n) {
    while (n-- > 0 && lst != NULL)
        lst = lst->next;

    return lst;
}

X_EXTERN x_list *
X_PFX(list_pop) (x_list * lst, void **data_ret) {
    void *data = NULL;

    if (lst != NULL) {
        x_list *tem = lst;
        data = lst->data;
        lst = lst->next;
        X_PFX(list_free_1) (tem);
    }

    if (data_ret != NULL)
        *data_ret = data;

    return lst;
}

X_EXTERN x_list *
X_PFX(list_filter) (x_list * lst,
                    int (*pred)(void *item, void *data), void *data) {
    x_list *ret = NULL, *node;

    for (node = lst; node != NULL; node = node->next) {
        if ((*pred)(node->data, data))
            ret = X_PFX(list_prepend) (ret, node->data);
    }

    return X_PFX(list_reverse) (ret);
}

X_EXTERN x_list *
X_PFX(list_map) (x_list * lst,
                 void *(*fun)(void *item, void *data), void *data) {
    x_list *ret = NULL, *node;

    for (node = lst; node != NULL; node = node->next) {
        X_PFX(list_prepend) (ret, fun(node->data, data));
    }

    return X_PFX(list_reverse) (ret);
}

X_EXTERN x_list *
X_PFX(list_copy) (x_list * lst) {
    x_list *copy = NULL;

    for (; lst != NULL; lst = lst->next) {
        copy = X_PFX(list_prepend) (copy, lst->data);
    }

    return X_PFX(list_reverse) (copy);
}

X_EXTERN x_list *
X_PFX(list_remove) (x_list * lst, void *data) {
    x_list **ptr, *node;

    for (ptr = &lst; *ptr != NULL;) {
        node = *ptr;

        if (node->data == data) {
            *ptr = node->next;
            X_PFX(list_free_1) (node);
        }
        else
            ptr = &((*ptr)->next);
    }

    return lst;
}

X_EXTERN unsigned int
X_PFX(list_length) (x_list * lst) {
    unsigned int n;

    n = 0;
    for (; lst != NULL; lst = lst->next)
        n++;

    return n;
}

X_EXTERN void
X_PFX(list_foreach) (x_list * lst,
                     void (*fun)(void *data, void *user_data),
                     void *user_data) {
    for (; lst != NULL; lst = lst->next) {
        (*fun)(lst->data, user_data);
    }
}

static x_list *
list_sort_1(x_list *lst, int length,
            int (*less)(const void *, const void *))
{
    x_list *mid, *ptr;
    x_list *out_head, *out;
    int mid_point, i;

    /* This is a standard (stable) list merge sort */

    if (length < 2)
        return lst;

    /* Calculate the halfway point. Split the list into two sub-lists. */

    mid_point = length / 2;
    ptr = lst;
    for (i = mid_point - 1; i > 0; i--)
        ptr = ptr->next;
    mid = ptr->next;
    ptr->next = NULL;

    /* Sort each sub-list. */

    lst = list_sort_1(lst, mid_point, less);
    mid = list_sort_1(mid, length - mid_point, less);

    /* Then merge them back together. */

    assert(lst != NULL && mid != NULL);

    if ((*less)(mid->data, lst->data))
        out = out_head = mid, mid = mid->next;
    else
        out = out_head = lst, lst = lst->next;

    while (lst != NULL && mid != NULL)
    {
        if ((*less)(mid->data, lst->data))
            out = out->next = mid, mid = mid->next;
        else
            out = out->next = lst, lst = lst->next;
    }

    if (lst != NULL)
        out->next = lst;
    else
        out->next = mid;

    return out_head;
}

X_EXTERN x_list *
X_PFX(list_sort) (x_list * lst, int (*less)(const void *, const void *)) {
    int length;

    length = X_PFX(list_length) (lst);

    return list_sort_1(lst, length, less);
}
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d2 28
a29 27

   Copyright (c) 2002 Apple Computer, Inc. All rights reserved.

   Permission is hereby granted, free of charge, to any person
   obtaining a copy of this software and associated documentation files
   (the "Software"), to deal in the Software without restriction,
   including without limitation the rights to use, copy, modify, merge,
   publish, distribute, sublicense, and/or sell copies of the Software,
   and to permit persons to whom the Software is furnished to do so,
   subject to the following conditions:

   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT
   HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.

   Except as contained in this notice, the name(s) of the above
   copyright holders shall not be used in advertising or otherwise to
   promote the sale, use or other dealings in this Software without
   prior written authorization. */
d54 1
a54 1
list_free_1 (x_list *node)
d61 2
a62 3
X_PFX (list_free_1) (x_list *node)
{
    assert (node != NULL);
d64 1
a64 1
    pthread_mutex_lock (&freelist_lock);
d66 1
a66 1
    list_free_1 (node);
d68 1
a68 1
    pthread_mutex_unlock (&freelist_lock);
d72 1
a72 2
X_PFX (list_free) (x_list *lst)
{
d75 1
a75 1
    pthread_mutex_lock (&freelist_lock);
d77 1
a77 2
    for (; lst != NULL; lst = next)
    {
d79 1
a79 1
        list_free_1 (lst);
d82 1
a82 1
    pthread_mutex_unlock (&freelist_lock);
d86 1
a86 2
X_PFX (list_prepend) (x_list *lst, void *data)
{
d89 1
a89 1
    pthread_mutex_lock (&freelist_lock);
d91 1
a91 2
    if (freelist == NULL)
    {
d95 1
a95 1
        b = malloc (sizeof (x_list_block));
d99 1
a99 1
            b->l[i].next = &(b->l[i+1]);
d108 1
a108 1
    pthread_mutex_unlock (&freelist_lock);
d117 1
a117 2
X_PFX (list_append) (x_list *lst, void *data)
{
d121 1
a121 1
        return X_PFX (list_prepend) (NULL, data);
d126 1
a126 1
    lst->next = X_PFX (list_prepend) (NULL, data);
d132 1
a132 2
X_PFX (list_reverse) (x_list *lst)
{
d134 1
a134 1
    
d147 2
a148 4
X_PFX (list_find) (x_list *lst, void *data)
{
    for (; lst != NULL; lst = lst->next)
    {
d157 1
a157 2
X_PFX (list_nth) (x_list *lst, int n)
{
d165 1
a165 2
X_PFX (list_pop) (x_list *lst, void **data_ret)
{
d168 1
a168 2
    if (lst != NULL)
    {
d172 1
a172 1
        X_PFX (list_free_1) (tem);
d182 2
a183 3
X_PFX (list_filter) (x_list *lst,
                     int (*pred) (void *item, void *data), void *data)
{
d186 3
a188 4
    for (node = lst; node != NULL; node = node->next)
    {
        if ((*pred) (node->data, data))
            ret = X_PFX (list_prepend) (ret, node->data);
d191 1
a191 1
    return X_PFX (list_reverse) (ret);
d195 2
a196 3
X_PFX (list_map) (x_list *lst,
                  void *(*fun) (void *item, void *data), void *data)
{
d199 2
a200 3
    for (node = lst; node != NULL; node = node->next)
    {
        X_PFX (list_prepend) (ret, fun (node->data, data));
d203 1
a203 1
    return X_PFX (list_reverse) (ret);
d207 1
a207 2
X_PFX (list_copy) (x_list *lst)
{
d210 2
a211 3
    for (; lst != NULL; lst = lst->next)
    {
        copy = X_PFX (list_prepend) (copy, lst->data);
d214 1
a214 1
    return X_PFX (list_reverse) (copy);
d218 1
a218 2
X_PFX (list_remove) (x_list *lst, void *data)
{
d221 1
a221 2
    for (ptr = &lst; *ptr != NULL;)
    {
d224 1
a224 2
        if (node->data == data)
        {
d226 1
a226 1
            X_PFX (list_free_1) (node);
d236 1
a236 2
X_PFX (list_length) (x_list *lst)
{
d247 5
a251 7
X_PFX (list_foreach) (x_list *lst,
                      void (*fun) (void *data, void *user_data),
                      void *user_data)
{
    for (; lst != NULL; lst = lst->next)
    {
        (*fun) (lst->data, user_data);
d256 2
a257 2
list_sort_1 (x_list *lst, int length,
             int (*less) (const void *, const void *))
d279 2
a280 2
    lst = list_sort_1 (lst, mid_point, less);
    mid = list_sort_1 (mid, length - mid_point, less);
d284 1
a284 1
    assert (lst != NULL && mid != NULL);
d286 1
a286 1
    if ((*less) (mid->data, lst->data))
d293 1
a293 1
        if ((*less) (mid->data, lst->data))
d308 1
a308 2
X_PFX (list_sort) (x_list *lst, int (*less) (const void *, const void *))
{
d311 1
a311 1
    length = X_PFX (list_length) (lst);
d313 1
a313 1
    return list_sort_1 (lst, length, less);
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d100 1
@

