head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.6
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2014.07.11.08.13.44;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	QZ1xfp0adMyURB7B;

1.8
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.02.16.08.40;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.09;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Xplugin rootless implementation screen functions
 *
 * Copyright (c) 2002-2012 Apple Computer, Inc. All Rights Reserved.
 * Copyright (c) 2004 Torrey T. Lyons. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
 */

#include "sanitizedCarbon.h"

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "quartzCommon.h"
#include "inputstr.h"
#include "quartz.h"
#include "quartzRandR.h"
#include "xpr.h"
#include "xprEvent.h"
#include "pseudoramiX.h"
#include "darwinEvents.h"
#include "rootless.h"
#include "dri.h"
#include "globals.h"
#include <Xplugin.h>
#include "applewmExt.h"
#include "micmap.h"

#include "rootlessCommon.h"

#ifdef DAMAGE
#include "damage.h"
#endif

#include "nonsdk_extinit.h"

#if MAC_OS_X_VERSION_MIN_REQUIRED < 1090
// From NSApplication.h
extern const double NSAppKitVersionNumber;
#endif

/* 10.4's deferred update makes X slower.. have to live with the tearing
 * for now.. */
#define XP_NO_DEFERRED_UPDATES 8

// Name of GLX bundle for native OpenGL
static const char *xprOpenGLBundle = "glxCGL.bundle";

/*
 * eventHandler
 *  Callback handler for Xplugin events.
 */
static void
eventHandler(unsigned int type, const void *arg,
             unsigned int arg_size, void *data)
{

    switch (type) {
    case XP_EVENT_DISPLAY_CHANGED:
        DEBUG_LOG("XP_EVENT_DISPLAY_CHANGED\n");
        DarwinSendDDXEvent(kXquartzDisplayChanged, 0);
        break;

    case XP_EVENT_WINDOW_STATE_CHANGED:
        if (arg_size >= sizeof(xp_window_state_event)) {
            const xp_window_state_event *ws_arg = arg;

            DEBUG_LOG("XP_EVENT_WINDOW_STATE_CHANGED: id=%d, state=%d\n",
                      ws_arg->id,
                      ws_arg->state);
            DarwinSendDDXEvent(kXquartzWindowState, 2,
                               ws_arg->id, ws_arg->state);
        }
        else {
            DEBUG_LOG("XP_EVENT_WINDOW_STATE_CHANGED: ignored\n");
        }
        break;

    case XP_EVENT_WINDOW_MOVED:
        DEBUG_LOG("XP_EVENT_WINDOW_MOVED\n");
        if (arg_size == sizeof(xp_window_id)) {
            xp_window_id id = *(xp_window_id *)arg;
            DarwinSendDDXEvent(kXquartzWindowMoved, 1, id);
        }
        break;

    case XP_EVENT_SURFACE_DESTROYED:
        DEBUG_LOG("XP_EVENT_SURFACE_DESTROYED\n");

    case XP_EVENT_SURFACE_CHANGED:
        DEBUG_LOG("XP_EVENT_SURFACE_CHANGED\n");
        if (arg_size == sizeof(xp_surface_id)) {
            int kind;

            if (type == XP_EVENT_SURFACE_DESTROYED)
                kind = AppleDRISurfaceNotifyDestroyed;
            else
                kind = AppleDRISurfaceNotifyChanged;

            DRISurfaceNotify(*(xp_surface_id *)arg, kind);
        }
        break;

#ifdef XP_EVENT_SPACE_CHANGED
    case  XP_EVENT_SPACE_CHANGED:
        DEBUG_LOG("XP_EVENT_SPACE_CHANGED\n");
        if (arg_size == sizeof(uint32_t)) {
            uint32_t space_id = *(uint32_t *)arg;
            DarwinSendDDXEvent(kXquartzSpaceChanged, 1, space_id);
        }
        break;

#endif
    default:
        ErrorF("Unknown XP_EVENT type (%d) in xprScreen:eventHandler\n", type);
    }
}

/*
 * displayAtIndex
 *  Return the display ID for a particular display index.
 */
static CGDirectDisplayID
displayAtIndex(int index)
{
    CGError err;
    CGDisplayCount cnt;
    CGDirectDisplayID dpy[index + 1];

    err = CGGetActiveDisplayList(index + 1, dpy, &cnt);
    if (err == kCGErrorSuccess && cnt == index + 1)
        return dpy[index];
    else
        return kCGNullDirectDisplay;
}

/*
 * displayScreenBounds
 *  Return the bounds of a particular display.
 */
static CGRect
displayScreenBounds(CGDirectDisplayID id)
{
    CGRect frame;

    frame = CGDisplayBounds(id);

    DEBUG_LOG("    %dx%d @@ (%d,%d).\n",
              (int)frame.size.width, (int)frame.size.height,
              (int)frame.origin.x, (int)frame.origin.y);

    Boolean spacePerDisplay = false;
#if MAC_OS_X_VERSION_MIN_REQUIRED < 1090
    if (NSAppKitVersionNumber >= 1265)
#endif
    {
        Boolean ok;
        (void)CFPreferencesAppSynchronize(CFSTR("com.apple.spaces"));
        spacePerDisplay = ! CFPreferencesGetAppBooleanValue(CFSTR("spans-displays"),
                                                            CFSTR("com.apple.spaces"),
                                                            &ok);
        if (!ok)
            spacePerDisplay = true;
    }

    /* Remove menubar to help standard X11 window managers.
     * On Mavericks and later, the menu bar is on all displays when spans-displays is false or unset.
     */
    if (XQuartzIsRootless &&
        (spacePerDisplay || (frame.origin.x == 0 && frame.origin.y == 0))) {
        frame.origin.y += aquaMenuBarHeight;
        frame.size.height -= aquaMenuBarHeight;
    }

    DEBUG_LOG("    %dx%d @@ (%d,%d).\n",
              (int)frame.size.width, (int)frame.size.height,
              (int)frame.origin.x, (int)frame.origin.y);

    return frame;
}

/*
 * xprAddPseudoramiXScreens
 *  Add a single virtual screen encompassing all the physical screens
 *  with PseudoramiX.
 */
static void
xprAddPseudoramiXScreens(int *x, int *y, int *width, int *height,
                         ScreenPtr pScreen)
{
    CGDisplayCount i, displayCount;
    CGDirectDisplayID *displayList = NULL;
    CGRect unionRect = CGRectNull, frame;

    // Find all the CoreGraphics displays
    CGGetActiveDisplayList(0, NULL, &displayCount);
    DEBUG_LOG("displayCount: %d\n", (int)displayCount);

    if (!displayCount) {
        ErrorF(
            "CoreGraphics has reported no connected displays.  Creating a stub 800x600 display.\n");
        *x = *y = 0;
        *width = 800;
        *height = 600;
        PseudoramiXAddScreen(*x, *y, *width, *height);
        QuartzCopyDisplayIDs(pScreen, 0, NULL);
        return;
    }

    /* If the displays are captured, we are in a RandR game mode
     * on the primary display, so we only want to include the first
     * display.  The others are covered by the shield window.
     */
    if (CGDisplayIsCaptured(kCGDirectMainDisplay))
        displayCount = 1;

    displayList = malloc(displayCount * sizeof(CGDirectDisplayID));
    if (!displayList)
        FatalError("Unable to allocate memory for list of displays.\n");
    CGGetActiveDisplayList(displayCount, displayList, &displayCount);
    QuartzCopyDisplayIDs(pScreen, displayCount, displayList);

    /* Get the union of all screens */
    for (i = 0; i < displayCount; i++) {
        CGDirectDisplayID dpy = displayList[i];
        frame = displayScreenBounds(dpy);
        unionRect = CGRectUnion(unionRect, frame);
    }

    /* Use unionRect as the screen size for the X server. */
    *x = unionRect.origin.x;
    *y = unionRect.origin.y;
    *width = unionRect.size.width;
    *height = unionRect.size.height;

    DEBUG_LOG("  screen union origin: (%d,%d) size: (%d,%d).\n",
              *x, *y, *width, *height);

    /* Tell PseudoramiX about the real screens. */
    for (i = 0; i < displayCount; i++) {
        CGDirectDisplayID dpy = displayList[i];

        frame = displayScreenBounds(dpy);
        frame.origin.x -= unionRect.origin.x;
        frame.origin.y -= unionRect.origin.y;

        DEBUG_LOG("    placed at X11 coordinate (%d,%d).\n",
                  (int)frame.origin.x, (int)frame.origin.y);

        PseudoramiXAddScreen(frame.origin.x, frame.origin.y,
                             frame.size.width, frame.size.height);
    }

    free(displayList);
}

/*
 * xprDisplayInit
 *  Find number of CoreGraphics displays and initialize Xplugin.
 */
static void
xprDisplayInit(void)
{
    CGDisplayCount displayCount;

    TRACE();

    CGGetActiveDisplayList(0, NULL, &displayCount);

    /* With PseudoramiX, the X server only sees one screen; only PseudoramiX
       itself knows about all of the screens. */

    if (noPseudoramiXExtension)
        darwinScreensFound = displayCount;
    else
        darwinScreensFound = 1;

    if (xp_init(XP_BACKGROUND_EVENTS | XP_NO_DEFERRED_UPDATES) != Success)
        FatalError("Could not initialize the Xplugin library.");

    xp_select_events(XP_EVENT_DISPLAY_CHANGED
                     | XP_EVENT_WINDOW_STATE_CHANGED
                     | XP_EVENT_WINDOW_MOVED
#ifdef XP_EVENT_SPACE_CHANGED
                     | XP_EVENT_SPACE_CHANGED
#endif
                     | XP_EVENT_SURFACE_CHANGED
                     | XP_EVENT_SURFACE_DESTROYED,
                     eventHandler, NULL);

    AppleDRIExtensionInit();
    xprAppleWMInit();

    XQuartzIsRootless = XQuartzRootlessDefault;
    if (!XQuartzIsRootless)
        RootlessHideAllWindows();
}

/*
 * xprAddScreen
 *  Init the framebuffer and record pixmap parameters for the screen.
 */
static Bool
xprAddScreen(int index, ScreenPtr pScreen)
{
    DarwinFramebufferPtr dfb = SCREEN_PRIV(pScreen);
    int depth = darwinDesiredDepth;

    DEBUG_LOG("index=%d depth=%d\n", index, depth);

    if (depth == -1) {
#if MAC_OS_X_VERSION_MIN_REQUIRED < 1060
        depth = CGDisplaySamplesPerPixel(kCGDirectMainDisplay) *
                CGDisplayBitsPerSample(kCGDirectMainDisplay);
#else
        CGDisplayModeRef modeRef;
        CFStringRef encStrRef;

        modeRef = CGDisplayCopyDisplayMode(kCGDirectMainDisplay);
        if (!modeRef)
            goto have_depth;

        encStrRef = CGDisplayModeCopyPixelEncoding(modeRef);
        CFRelease(modeRef);
        if (!encStrRef)
            goto have_depth;

        if (CFStringCompare(encStrRef, CFSTR(IO32BitDirectPixels),
                            kCFCompareCaseInsensitive) ==
            kCFCompareEqualTo) {
            depth = 24;
        }
        else if (CFStringCompare(encStrRef, CFSTR(IO16BitDirectPixels),
                                 kCFCompareCaseInsensitive) ==
                 kCFCompareEqualTo) {
            depth = 15;
        }
        else if (CFStringCompare(encStrRef, CFSTR(IO8BitIndexedPixels),
                                 kCFCompareCaseInsensitive) ==
                 kCFCompareEqualTo) {
            depth = 8;
        }

        CFRelease(encStrRef);
#endif
    }

#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
have_depth:
#endif
    switch (depth) {
    case 8:     // pseudo-working
        dfb->visuals = PseudoColorMask;
        dfb->preferredCVC = PseudoColor;
        dfb->depth = 8;
        dfb->bitsPerRGB = 8;
        dfb->bitsPerPixel = 8;
        dfb->redMask = 0;
        dfb->greenMask = 0;
        dfb->blueMask = 0;
        break;

#if 0
    // Removed because Mountain Lion removed support for
    // 15bit backing stores.  We can possibly re-add
    // this once libXplugin is updated to work around it.
    case 15:
        dfb->visuals = TrueColorMask;     //LARGE_VISUALS;
        dfb->preferredCVC = TrueColor;
        dfb->depth = 15;
        dfb->bitsPerRGB = 5;
        dfb->bitsPerPixel = 16;
        dfb->redMask = RM_ARGB(0, 5, 5, 5);
        dfb->greenMask = GM_ARGB(0, 5, 5, 5);
        dfb->blueMask = BM_ARGB(0, 5, 5, 5);
        break;
#endif

    //        case 24:
    default:
        if (depth != 24)
            ErrorF(
                "Unsupported color depth requested.  Defaulting to 24bit. (depth=%d darwinDesiredDepth=%d)\n",
                depth, darwinDesiredDepth);
        dfb->visuals = TrueColorMask;     //LARGE_VISUALS;
        dfb->preferredCVC = TrueColor;
        dfb->depth = 24;
        dfb->bitsPerRGB = 8;
        dfb->bitsPerPixel = 32;
        dfb->redMask = RM_ARGB(0, 8, 8, 8);
        dfb->greenMask = GM_ARGB(0, 8, 8, 8);
        dfb->blueMask = BM_ARGB(0, 8, 8, 8);
        break;
    }

    if (noPseudoramiXExtension) {
        CGDirectDisplayID dpy;
        CGRect frame;

        ErrorF("Warning: noPseudoramiXExtension!\n");

        dpy = displayAtIndex(index);
        QuartzCopyDisplayIDs(pScreen, 1, &dpy);

        frame = displayScreenBounds(dpy);

        dfb->x = frame.origin.x;
        dfb->y = frame.origin.y;
        dfb->width = frame.size.width;
        dfb->height = frame.size.height;
    }
    else {
        xprAddPseudoramiXScreens(&dfb->x, &dfb->y, &dfb->width, &dfb->height,
                                 pScreen);
    }

    /* Passing zero width (pitch) makes miCreateScreenResources set the
       screen pixmap to the framebuffer pointer, i.e. NULL. The generic
       rootless code takes care of making this work. */
    dfb->pitch = 0;
    dfb->framebuffer = NULL;

    DRIScreenInit(pScreen);

    return TRUE;
}

/*
 * xprSetupScreen
 *  Setup the screen for rootless access.
 */
static Bool
xprSetupScreen(int index, ScreenPtr pScreen)
{
#ifdef DAMAGE
    // The Damage extension needs to wrap underneath the
    // generic rootless layer, so do it now.
    if (!DamageSetup(pScreen))
        return FALSE;
#endif

    // Initialize generic rootless code
    if (!xprInit(pScreen))
        return FALSE;

    return DRIFinishScreenInit(pScreen);
}

/*
 * xprUpdateScreen
 *  Update screen after configuation change.
 */
static void
xprUpdateScreen(ScreenPtr pScreen)
{
    rootlessGlobalOffsetX = darwinMainScreenX;
    rootlessGlobalOffsetY = darwinMainScreenY;

    AppleWMSetScreenOrigin(pScreen->root);

    RootlessRepositionWindows(pScreen);
    RootlessUpdateScreenPixmap(pScreen);
}

/*
 * xprInitInput
 *  Finalize xpr specific setup.
 */
static void
xprInitInput(int argc, char **argv)
{
    int i;

    rootlessGlobalOffsetX = darwinMainScreenX;
    rootlessGlobalOffsetY = darwinMainScreenY;

    for (i = 0; i < screenInfo.numScreens; i++)
        AppleWMSetScreenOrigin(screenInfo.screens[i]->root);
}

/*
 * Quartz display mode function list.
 */
static QuartzModeProcsRec xprModeProcs = {
    xprDisplayInit,
    xprAddScreen,
    xprSetupScreen,
    xprInitInput,
    QuartzInitCursor,
    QuartzSuspendXCursor,
    QuartzResumeXCursor,
    xprAddPseudoramiXScreens,
    xprUpdateScreen,
    xprIsX11Window,
    xprHideWindows,
    RootlessFrameForWindow,
    TopLevelParent,
    DRICreateSurface,
    DRIDestroySurface
};

/*
 * QuartzModeBundleInit
 *  Initialize the display mode bundle after loading.
 */
Bool
QuartzModeBundleInit(void)
{
    quartzProcs = &xprModeProcs;
    quartzOpenGLBundle = xprOpenGLBundle;
    return TRUE;
}
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d57 2
@


1.9
log
@Update to xorg-server 1.15.2. bug fixes.
@
text
@d172 14
d187 1
a187 1
     * On Mavericks and later, the menu bar is on all displays.
d189 2
a190 5
    if (XQuartzIsRootless
#if MAC_OS_X_VERSION_MIN_REQUIRED < 1090
        && (NSAppKitVersionNumber >= 1265 || (frame.origin.x == 0 && frame.origin.y == 0))
#endif
        ) {
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d57 5
d172 8
a179 3
    /* Remove menubar to help standard X11 window managers. */
    if (XQuartzIsRootless &&
        frame.origin.x == 0 && frame.origin.y == 0) {
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d362 4
d376 1
@


1.6
log
@Update to xserver 1.11.2
@
text
@d4 1
a4 1
 * Copyright (c) 2002 Apple Computer, Inc. All Rights Reserved.
d54 1
a54 1
# include "damage.h"
d58 1
a58 1
   for now.. */
d68 5
a72 3
static void eventHandler(unsigned int type, const void *arg,
                         unsigned int arg_size, void *data) {
    
d74 45
a118 40
        case XP_EVENT_DISPLAY_CHANGED:
            DEBUG_LOG("XP_EVENT_DISPLAY_CHANGED\n");
            DarwinSendDDXEvent(kXquartzDisplayChanged, 0);
            break;
            
        case XP_EVENT_WINDOW_STATE_CHANGED:
            if (arg_size >= sizeof(xp_window_state_event)) {
                const xp_window_state_event *ws_arg = arg;
                
                DEBUG_LOG("XP_EVENT_WINDOW_STATE_CHANGED: id=%d, state=%d\n", ws_arg->id, ws_arg->state);
                DarwinSendDDXEvent(kXquartzWindowState, 2,
                                          ws_arg->id, ws_arg->state);
            } else {
                DEBUG_LOG("XP_EVENT_WINDOW_STATE_CHANGED: ignored\n");
            }
            break;
            
        case XP_EVENT_WINDOW_MOVED:
            DEBUG_LOG("XP_EVENT_WINDOW_MOVED\n");
            if (arg_size == sizeof(xp_window_id))  {
                xp_window_id id = * (xp_window_id *) arg;
                DarwinSendDDXEvent(kXquartzWindowMoved, 1, id);
            }
            break;
            
        case XP_EVENT_SURFACE_DESTROYED:
            DEBUG_LOG("XP_EVENT_SURFACE_DESTROYED\n");
        case XP_EVENT_SURFACE_CHANGED:
            DEBUG_LOG("XP_EVENT_SURFACE_CHANGED\n");
            if (arg_size == sizeof(xp_surface_id)) {
                int kind;
                
                if (type == XP_EVENT_SURFACE_DESTROYED)
                    kind = AppleDRISurfaceNotifyDestroyed;
                else
                    kind = AppleDRISurfaceNotifyChanged;
                
                DRISurfaceNotify(*(xp_surface_id *) arg, kind);
            }
            break;
d120 8
a127 7
        case  XP_EVENT_SPACE_CHANGED:
            DEBUG_LOG("XP_EVENT_SPACE_CHANGED\n");
            if(arg_size == sizeof(uint32_t)) {
                uint32_t space_id = *(uint32_t *)arg;
                DarwinSendDDXEvent(kXquartzSpaceChanged, 1, space_id);
            }
            break;
d129 2
a130 2
        default:
            ErrorF("Unknown XP_EVENT type (%d) in xprScreen:eventHandler\n", type);
d143 1
a143 1
    CGDirectDisplayID dpy[index+1];
d166 1
a166 1
    
d168 1
a168 1
    if (XQuartzIsRootless && 
d187 2
a188 1
xprAddPseudoramiXScreens(int *x, int *y, int *width, int *height, ScreenPtr pScreen)
d198 3
a200 2
    if(!displayCount) {
        ErrorF("CoreGraphics has reported no connected displays.  Creating a stub 800x600 display.\n");
d217 1
a217 1
    if(!displayList)
d239 1
a239 2
    for (i = 0; i < displayCount; i++)
    {
d275 1
a275 1
        darwinScreensFound =  1;
d309 2
a310 2
    
    if(depth == -1) {
d312 2
a313 1
        depth = CGDisplaySamplesPerPixel(kCGDirectMainDisplay) * CGDisplayBitsPerSample(kCGDirectMainDisplay);
d317 1
a317 1
        
d319 1
a319 1
        if(!modeRef)
d324 1
a324 1
        if(!encStrRef)
d326 4
a329 2
        
        if(CFStringCompare(encStrRef, CFSTR(IO32BitDirectPixels), kCFCompareCaseInsensitive) == kCFCompareEqualTo) {
d331 4
a334 1
        } else if(CFStringCompare(encStrRef, CFSTR(IO16BitDirectPixels), kCFCompareCaseInsensitive) == kCFCompareEqualTo) {
d336 4
a339 1
        } else if(CFStringCompare(encStrRef, CFSTR(IO8BitIndexedPixels), kCFCompareCaseInsensitive) == kCFCompareEqualTo) {
d346 1
a346 1
    
d350 38
a387 34
    switch(depth) {
        case 8: // pseudo-working
            dfb->visuals = PseudoColorMask;
            dfb->preferredCVC = PseudoColor;
            dfb->depth = 8;
            dfb->bitsPerRGB = 8;
            dfb->bitsPerPixel = 8;
            dfb->redMask = 0;
            dfb->greenMask = 0;
            dfb->blueMask = 0;
            break;
        case 15:
            dfb->visuals = TrueColorMask; //LARGE_VISUALS;
            dfb->preferredCVC = TrueColor;
            dfb->depth = 15;
            dfb->bitsPerRGB = 5;
            dfb->bitsPerPixel = 16;
            dfb->redMask   = RM_ARGB(0,5,5,5);
            dfb->greenMask = GM_ARGB(0,5,5,5);
            dfb->blueMask  = BM_ARGB(0,5,5,5);
            break;
//        case 24:
        default:
            if(depth != 24)
                ErrorF("Unsupported color depth requested.  Defaulting to 24bit. (depth=%d darwinDesiredDepth=%d)\n", depth, darwinDesiredDepth);
            dfb->visuals = TrueColorMask; //LARGE_VISUALS;
            dfb->preferredCVC = TrueColor;
            dfb->depth = 24;
            dfb->bitsPerRGB = 8;
            dfb->bitsPerPixel = 32;
            dfb->redMask   = RM_ARGB(0,8,8,8);
            dfb->greenMask = GM_ARGB(0,8,8,8);
            dfb->blueMask  = BM_ARGB(0,8,8,8);
            break;
d390 1
a390 2
    if (noPseudoramiXExtension)
    {
d395 1
a395 1
        
d403 1
a403 1
        dfb->width =  frame.size.width;
d406 3
a408 3
    else
    {
        xprAddPseudoramiXScreens(&dfb->x, &dfb->y, &dfb->width, &dfb->height, pScreen);
@


1.5
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@a42 1
#include "darwin.h"
d195 1
d256 1
a256 1
    DEBUG_LOG("");
d329 1
d331 1
a407 6
    // Initialize accelerated rootless drawing
    // Note that this must be done before DamageSetup().

    // These are crashing ugly... better to be stable and not crash for now.
    //RootlessAccelInit(pScreen);

@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d199 7
d302 1
d304 23
d329 1
d354 1
a354 1
                ErrorF("Unsupported color depth requested.  Defaulting to 24bit. (depth=%d darwinDesiredDepth=%d CGDisplaySamplesPerPixel=%d CGDisplayBitsPerSample=%d)\n",  darwinDesiredDepth, depth, (int)CGDisplaySamplesPerPixel(kCGDirectMainDisplay), (int)CGDisplayBitsPerSample(kCGDirectMainDisplay));
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d39 1
d161 1
a161 1
    if (quartzEnableRootless && 
d180 1
a180 1
xprAddPseudoramiXScreens(int *x, int *y, int *width, int *height)
d199 1
a199 1
    displayList = xalloc(displayCount * sizeof(CGDirectDisplayID));
d203 1
d237 1
a237 1
    xfree(displayList);
d277 2
a278 1
    if (!quartzEnableRootless)
d342 1
d353 1
a353 1
        xprAddPseudoramiXScreens(&dfb->x, &dfb->y, &dfb->width, &dfb->height);
d404 1
a404 1
    AppleWMSetScreenOrigin(WindowTable[pScreen->myNum]);
d423 1
a423 1
        AppleWMSetScreenOrigin(WindowTable[i]);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d51 2
d187 11
d199 2
d274 3
a292 3
        //dfb->depth = CGDisplaySamplesPerPixel(kCGDirectMainDisplay) * CGDisplayBitsPerSample(kCGDirectMainDisplay);
        //dfb->bitsPerRGB = CGDisplayBitsPerSample(kCGDirectMainDisplay);
        //dfb->bitsPerPixel = CGDisplayBitsPerPixel(kCGDirectMainDisplay);
a295 10
//        case -8: // broken
//            dfb->visuals = (1 << StaticGray) | (1 << GrayScale);
//            dfb->preferredCVC = GrayScale;
//            dfb->depth = 8;
//            dfb->bitsPerRGB = 8;
//            dfb->bitsPerPixel = 8;
//            dfb->redMask = 0;
//            dfb->greenMask = 0;
//            dfb->blueMask = 0;
//            break;
d307 1
a307 1
            dfb->visuals = LARGE_VISUALS;
d312 3
a314 3
            dfb->redMask   = 0x7c00;
            dfb->greenMask = 0x03e0;
            dfb->blueMask  = 0x001f;
d320 1
a320 1
            dfb->visuals = LARGE_VISUALS;
d325 3
a327 3
            dfb->redMask   = 0x00ff0000;
            dfb->greenMask = 0x0000ff00;
            dfb->blueMask  = 0x000000ff;
a332 2
        ErrorF("Warning: noPseudoramiXExtension!\n");
        
d336 2
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d30 2
d37 1
d40 1
d43 1
a44 1
#include "safeAlpha/safeAlpha.h"
d47 1
a47 1
#include "Xplugin.h"
a50 3
// From xprFrame.c
WindowPtr xprGetXWindow(xp_window_id wid);

d68 1
d72 1
a72 1
            QuartzMessageServerThread(kXDarwinDisplayChanged, 0);
d80 1
a80 1
                QuartzMessageServerThread(kXDarwinWindowState, 2,
d91 1
a91 2
                WindowPtr pWin = xprGetXWindow(id);
                QuartzMessageServerThread(kXDarwinWindowMoved, 1, pWin);
d110 9
d153 4
d158 2
a159 3

    if (frame.origin.x == 0 && frame.origin.y == 0)
    {
d164 4
d189 1
a189 2
    for (i = 0; i < displayCount; i++)
    {
d201 3
a209 5

	/*        ErrorF("PseudoramiX screen %d added: %dx%d @@ (%d,%d).\n", i,
               (int)frame.size.width, (int)frame.size.height,
               (int)frame.origin.x, (int)frame.origin.y); */

d213 2
a214 2
	/*        ErrorF("PseudoramiX screen %d placed at X11 coordinate (%d,%d).\n",
		  i, (int)frame.origin.x, (int)frame.origin.y); */
d232 1
a232 1
    //    ErrorF("Display mode: Rootless Quartz -- Xplugin implementation\n");
d250 3
d270 2
d281 11
a291 12
        case -8: // broken
            FatalError("Unsupported color depth %d\n", darwinDesiredDepth);
            dfb->visuals = (1 << StaticGray) | (1 << GrayScale);
            dfb->preferredCVC = GrayScale;
            dfb->depth = 8;
            dfb->bitsPerRGB = 8;
            dfb->bitsPerPixel = 8;
            dfb->redMask = 0;
            dfb->greenMask = 0;
            dfb->blueMask = 0;
            break;
        case 8: // broken
d311 4
a314 1
        case 24:
a323 2
        default:
            FatalError("Unsupported color depth %d\n", darwinDesiredDepth);
d328 2
a364 9
    // Add alpha protecting replacements for fb screen functions

#ifdef RENDER
    {
        PictureScreenPtr ps = GetPictureScreen(pScreen);
        ps->Composite = SafeAlphaComposite;
    }
#endif /* RENDER */

d367 3
a369 1
    RootlessAccelInit(pScreen);
a425 1
    NULL,               // No need to update cursor
a427 3
    NULL,               // No capture or release in rootless mode
    NULL,
    NULL,               // Xplugin sends screen change events directly
@

