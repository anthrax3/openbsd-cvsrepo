head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.10
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.8
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.6
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	cVXoV5PxI8YrEaVA;

1.4
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.09;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright (c) 2009-2012 Apple Inc. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT
 * HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above
 * copyright holders shall not be used in advertising or otherwise to
 * promote the sale, use or other dealings in this Software without
 * prior written authorization.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stddef.h>
#include "mi.h"
#include "scrnintstr.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "dixfontstr.h"
#include "mivalidate.h"
#include "driWrap.h"
#include "dri.h"

#include <OpenGL/OpenGL.h>

typedef struct {
    GCOps *originalOps;
} DRIGCRec;

typedef struct {
    GCOps *originalOps;
    CreateGCProcPtr CreateGC;
} DRIWrapScreenRec;

typedef struct {
    Bool didSave;
    int devKind;
    DevUnion devPrivate;
} DRISavedDrawableState;

static DevPrivateKeyRec driGCKeyRec;
#define driGCKey (&driGCKeyRec)

static DevPrivateKeyRec driWrapScreenKeyRec;
#define driWrapScreenKey (&driWrapScreenKeyRec)

static GCOps driGCOps;

#define wrap(priv, real, member, func) { \
        priv->member = real->member; \
        real->member = func; \
}

#define unwrap(priv, real, member)     { \
        real->member = priv->member; \
}

static DRIGCRec *
DRIGetGCPriv(GCPtr pGC)
{
    return dixLookupPrivate(&pGC->devPrivates, driGCKey);
}

static void
DRIUnwrapGC(GCPtr pGC)
{
    DRIGCRec *pGCPriv = DRIGetGCPriv(pGC);

    pGC->ops = pGCPriv->originalOps;
}

static void
DRIWrapGC(GCPtr pGC)
{
    pGC->ops = &driGCOps;
}

static void
DRISurfaceSetDrawable(DrawablePtr pDraw,
                      DRISavedDrawableState *saved)
{
    saved->didSave = FALSE;

    if (pDraw->type == DRAWABLE_PIXMAP) {
        int pitch, width, height, bpp;
        void *buffer;

        if (DRIGetPixmapData(pDraw, &width, &height, &pitch, &bpp,
                             &buffer)) {
            PixmapPtr pPix = (PixmapPtr)pDraw;

            saved->devKind = pPix->devKind;
            saved->devPrivate.ptr = pPix->devPrivate.ptr;
            saved->didSave = TRUE;

            pPix->devKind = pitch;
            pPix->devPrivate.ptr = buffer;
        }
    }
}

static void
DRISurfaceRestoreDrawable(DrawablePtr pDraw,
                          DRISavedDrawableState *saved)
{
    PixmapPtr pPix = (PixmapPtr)pDraw;

    if (!saved->didSave)
        return;

    pPix->devKind = saved->devKind;
    pPix->devPrivate.ptr = saved->devPrivate.ptr;
}

static void
DRIFillSpans(DrawablePtr dst, GCPtr pGC, int nInit,
             DDXPointPtr pptInit, int *pwidthInit,
             int sorted)
{
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    pGC->ops->FillSpans(dst, pGC, nInit, pptInit, pwidthInit, sorted);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);
}

static void
DRISetSpans(DrawablePtr dst, GCPtr pGC, char *pSrc,
            DDXPointPtr pptInit, int *pwidthInit,
            int nspans, int sorted)
{
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    pGC->ops->SetSpans(dst, pGC, pSrc, pptInit, pwidthInit, nspans, sorted);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);
}

static void
DRIPutImage(DrawablePtr dst, GCPtr pGC,
            int depth, int x, int y, int w, int h,
            int leftPad, int format, char *pBits)
{
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    pGC->ops->PutImage(dst, pGC, depth, x, y, w, h, leftPad, format, pBits);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);
}

static RegionPtr
DRICopyArea(DrawablePtr pSrc, DrawablePtr dst, GCPtr pGC,
            int srcx, int srcy, int w, int h,
            int dstx, int dsty)
{
    RegionPtr pReg;
    DRISavedDrawableState pSrcSaved, dstSaved;

    DRISurfaceSetDrawable(pSrc, &pSrcSaved);
    DRISurfaceSetDrawable(dst, &dstSaved);

    DRIUnwrapGC(pGC);

    pReg = pGC->ops->CopyArea(pSrc, dst, pGC, srcx, srcy, w, h, dstx, dsty);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(pSrc, &pSrcSaved);
    DRISurfaceRestoreDrawable(dst, &dstSaved);

    return pReg;
}

static RegionPtr
DRICopyPlane(DrawablePtr pSrc, DrawablePtr dst,
             GCPtr pGC, int srcx, int srcy,
             int w, int h, int dstx, int dsty,
             unsigned long plane)
{
    RegionPtr pReg;
    DRISavedDrawableState pSrcSaved, dstSaved;

    DRISurfaceSetDrawable(pSrc, &pSrcSaved);
    DRISurfaceSetDrawable(dst, &dstSaved);

    DRIUnwrapGC(pGC);

    pReg = pGC->ops->CopyPlane(pSrc, dst, pGC, srcx, srcy, w, h, dstx, dsty,
                               plane);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(pSrc, &pSrcSaved);
    DRISurfaceRestoreDrawable(dst, &dstSaved);

    return pReg;
}

static void
DRIPolyPoint(DrawablePtr dst, GCPtr pGC,
             int mode, int npt, DDXPointPtr pptInit)
{
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    pGC->ops->PolyPoint(dst, pGC, mode, npt, pptInit);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);
}

static void
DRIPolylines(DrawablePtr dst, GCPtr pGC,
             int mode, int npt, DDXPointPtr pptInit)
{
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    pGC->ops->Polylines(dst, pGC, mode, npt, pptInit);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);
}

static void
DRIPolySegment(DrawablePtr dst, GCPtr pGC,
               int nseg, xSegment *pSeg)
{
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    pGC->ops->PolySegment(dst, pGC, nseg, pSeg);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);
}

static void
DRIPolyRectangle(DrawablePtr dst, GCPtr pGC,
                 int nRects, xRectangle *pRects)
{
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    pGC->ops->PolyRectangle(dst, pGC, nRects, pRects);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);
}
static void
DRIPolyArc(DrawablePtr dst, GCPtr pGC, int narcs, xArc *parcs)
{
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    pGC->ops->PolyArc(dst, pGC, narcs, parcs);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);
}

static void
DRIFillPolygon(DrawablePtr dst, GCPtr pGC,
               int shape, int mode, int count,
               DDXPointPtr pptInit)
{
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    pGC->ops->FillPolygon(dst, pGC, shape, mode, count, pptInit);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);
}

static void
DRIPolyFillRect(DrawablePtr dst, GCPtr pGC,
                int nRectsInit, xRectangle *pRectsInit)
{
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    pGC->ops->PolyFillRect(dst, pGC, nRectsInit, pRectsInit);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);
}

static void
DRIPolyFillArc(DrawablePtr dst, GCPtr pGC,
               int narcsInit, xArc *parcsInit)
{
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    pGC->ops->PolyFillArc(dst, pGC, narcsInit, parcsInit);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);
}

static int
DRIPolyText8(DrawablePtr dst, GCPtr pGC,
             int x, int y, int count, char *chars)
{
    int ret;
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    ret = pGC->ops->PolyText8(dst, pGC, x, y, count, chars);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);

    return ret;
}

static int
DRIPolyText16(DrawablePtr dst, GCPtr pGC,
              int x, int y, int count, unsigned short *chars)
{
    int ret;
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    ret = pGC->ops->PolyText16(dst, pGC, x, y, count, chars);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);

    return ret;
}

static void
DRIImageText8(DrawablePtr dst, GCPtr pGC,
              int x, int y, int count, char *chars)
{
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    pGC->ops->ImageText8(dst, pGC, x, y, count, chars);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);
}

static void
DRIImageText16(DrawablePtr dst, GCPtr pGC,
               int x, int y, int count, unsigned short *chars)
{
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    pGC->ops->ImageText16(dst, pGC, x, y, count, chars);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);
}

static void
DRIImageGlyphBlt(DrawablePtr dst, GCPtr pGC,
                 int x, int y, unsigned int nglyphInit,
                 CharInfoPtr *ppciInit, void *unused)
{
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    pGC->ops->ImageGlyphBlt(dst, pGC, x, y, nglyphInit, ppciInit, unused);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);
}

static void
DRIPolyGlyphBlt(DrawablePtr dst, GCPtr pGC,
                int x, int y, unsigned int nglyph,
                CharInfoPtr *ppci, void *pglyphBase)
{
    DRISavedDrawableState saved;

    DRISurfaceSetDrawable(dst, &saved);

    DRIUnwrapGC(pGC);

    pGC->ops->PolyGlyphBlt(dst, pGC, x, y, nglyph, ppci, pglyphBase);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(dst, &saved);
}

static void
DRIPushPixels(GCPtr pGC, PixmapPtr pBitMap, DrawablePtr dst,
              int dx, int dy, int xOrg, int yOrg)
{
    DRISavedDrawableState bitMapSaved, dstSaved;

    DRISurfaceSetDrawable(&pBitMap->drawable, &bitMapSaved);
    DRISurfaceSetDrawable(dst, &dstSaved);

    DRIUnwrapGC(pGC);

    pGC->ops->PushPixels(pGC, pBitMap, dst, dx, dy, xOrg, yOrg);

    DRIWrapGC(pGC);

    DRISurfaceRestoreDrawable(&pBitMap->drawable, &bitMapSaved);
    DRISurfaceRestoreDrawable(dst, &dstSaved);
}

static GCOps driGCOps = {
    DRIFillSpans,
    DRISetSpans,
    DRIPutImage,
    DRICopyArea,
    DRICopyPlane,
    DRIPolyPoint,
    DRIPolylines,
    DRIPolySegment,
    DRIPolyRectangle,
    DRIPolyArc,
    DRIFillPolygon,
    DRIPolyFillRect,
    DRIPolyFillArc,
    DRIPolyText8,
    DRIPolyText16,
    DRIImageText8,
    DRIImageText16,
    DRIImageGlyphBlt,
    DRIPolyGlyphBlt,
    DRIPushPixels
};

static Bool
DRICreateGC(GCPtr pGC)
{
    ScreenPtr pScreen = pGC->pScreen;
    DRIWrapScreenRec *pScreenPriv;
    DRIGCRec *pGCPriv;
    Bool ret;

    pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, driWrapScreenKey);

    pGCPriv = DRIGetGCPriv(pGC);

    unwrap(pScreenPriv, pScreen, CreateGC);
    ret = pScreen->CreateGC(pGC);

    if (ret) {
        pGCPriv->originalOps = pGC->ops;
        pGC->ops = &driGCOps;
    }

    wrap(pScreenPriv, pScreen, CreateGC, DRICreateGC);

    return ret;
}

/* Return false if an error occurred. */
Bool
DRIWrapInit(ScreenPtr pScreen)
{
    DRIWrapScreenRec *pScreenPriv;

    if (!dixRegisterPrivateKey(&driGCKeyRec, PRIVATE_GC, sizeof(DRIGCRec)))
        return FALSE;

    if (!dixRegisterPrivateKey(&driWrapScreenKeyRec, PRIVATE_SCREEN,
                               sizeof(DRIWrapScreenRec)))
        return FALSE;

    pScreenPriv = dixGetPrivateAddr(&pScreen->devPrivates,
                                    &driWrapScreenKeyRec);
    pScreenPriv->CreateGC = pScreen->CreateGC;
    pScreen->CreateGC = DRICreateGC;

    return TRUE;
}
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d450 1
a450 1
                 CharInfoPtr *ppciInit, pointer unused)
d468 1
a468 1
                CharInfoPtr *ppci, pointer pglyphBase)
@


1.3
log
@Update to xserver 1.11.2
@
text
@d2 27
a28 2
Copyright (c) 2009 Apple Computer, Inc.
All Rights Reserved.
a29 20
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sub license, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
d71 3
a73 3
	priv->member = real->member; \
	real->member = func; \
    }
d75 3
a77 3
#define unwrap(priv, real, member) { \
	real->member = priv->member; \
    }
d80 2
a81 1
DRIGetGCPriv(GCPtr pGC) {
d86 2
a87 1
DRIUnwrapGC(GCPtr pGC) {
d93 3
a95 2
static void 
DRIWrapGC(GCPtr pGC) {
d100 3
a102 2
DRISurfaceSetDrawable(DrawablePtr pDraw, 
				  DRISavedDrawableState *saved) {
d104 16
a119 15
    
    if(pDraw->type == DRAWABLE_PIXMAP) {
	int pitch, width, height, bpp;
	void *buffer;

	if(DRIGetPixmapData(pDraw, &width, &height, &pitch, &bpp, &buffer)) {
	    PixmapPtr pPix = (PixmapPtr)pDraw;

	    saved->devKind = pPix->devKind;
	    saved->devPrivate.ptr = pPix->devPrivate.ptr;
	    saved->didSave = TRUE;

	    pPix->devKind = pitch;
	    pPix->devPrivate.ptr = buffer;
	}
d125 2
a126 1
				      DRISavedDrawableState *saved) {
d129 2
a130 2
    if(!saved->didSave) 
	return;
d138 3
a140 2
			 DDXPointPtr pptInit, int *pwidthInit, 
			 int sorted) {
d148 1
a148 1
    
d150 1
a150 1
    
d156 3
a158 2
			DDXPointPtr pptInit, int *pwidthInit,
			int nspans, int sorted) {
d160 1
a160 1
    
d164 1
a164 1
    
d168 1
a168 1
    
d174 3
a176 2
			int depth, int x, int y, int w, int h,
			int leftPad, int format, char *pBits) {
d184 1
a184 1
   
d192 3
a194 2
			     int srcx, int srcy, int w, int h,
			     int dstx, int dsty) {
d197 1
a197 1
    
d200 1
a200 1
      
d208 1
a208 1
    DRISurfaceRestoreDrawable(dst, &dstSaved);     
d215 4
a218 3
			     GCPtr pGC, int srcx, int srcy,
			     int w, int h, int dstx, int dsty,
			     unsigned long plane) {
d225 1
a226 2
    DRIUnwrapGC(pGC);
    
d228 2
a229 2
			       plane);
    
d240 2
a241 1
			 int mode, int npt, DDXPointPtr pptInit) {
d243 1
a243 1
    
d245 1
a245 1
    
d247 1
a247 1
    
d257 2
a258 1
			 int mode, int npt, DDXPointPtr pptInit) {
d260 1
a260 1
    
d264 1
a264 1
	
d268 1
a268 1
    
d274 2
a275 1
			   int nseg, xSegment *pSeg) {
d277 1
a277 1
    
d283 1
a283 1
    
d291 2
a292 1
                                  int nRects, xRectangle *pRects) {
d294 1
a294 1
    
d296 1
a296 1
    
d298 1
a298 1
 
d300 1
a300 1
   
d306 2
a307 1
DRIPolyArc(DrawablePtr dst, GCPtr pGC, int narcs, xArc *parcs) {
d309 1
a309 1
      
d313 1
a313 1
    
d317 1
a317 1
    
d323 3
a325 2
			   int shape, int mode, int count,
			   DDXPointPtr pptInit) {
d327 1
a327 1
    
d329 1
a329 1
      
d331 1
a331 1
    
d341 2
a342 1
			    int nRectsInit, xRectangle *pRectsInit) {
d344 1
a344 1
    
d350 1
a350 1
    
d358 2
a359 1
			   int narcsInit, xArc *parcsInit) {
d361 1
a361 1
    
d367 1
a367 1
    
d375 2
a376 1
			int x, int y, int count, char *chars) {
d379 1
a379 1
    
d383 1
a383 1
    
d385 1
a385 1
    
d387 1
a387 1
    
d395 2
a396 1
			 int x, int y, int count, unsigned short *chars) {
d399 1
a399 1
    
d403 1
a403 1
    
d407 1
a407 1
    
d415 2
a416 1
			  int x, int y, int count, char *chars) {
d418 1
a418 1
    
d422 1
a422 1
    
d426 1
a426 1
    
d432 2
a433 1
			   int x, int y, int count, unsigned short *chars) {
d435 1
a435 1
    
d441 1
a441 1
    
d449 3
a451 2
			     int x, int y, unsigned int nglyphInit,
			     CharInfoPtr *ppciInit, pointer unused) {
d453 1
a453 1
    
d459 1
a459 1
    
d465 5
a469 3
static void DRIPolyGlyphBlt(DrawablePtr dst, GCPtr pGC,
			    int x, int y, unsigned int nglyph,
			    CharInfoPtr *ppci, pointer pglyphBase) {
d471 1
a471 1
    
d477 1
a477 1
    
d485 2
a486 1
			  int dx, int dy, int xOrg, int yOrg) {
d488 1
a488 1
        
d495 1
a495 1
    
a501 1

a524 1

d526 2
a527 1
DRICreateGC(GCPtr pGC) {
d534 1
a534 1
    
d540 3
a542 3
    if(ret) {
	pGCPriv->originalOps = pGC->ops;
	pGC->ops = &driGCOps;
d546 1
a546 1
    
a549 1

d551 3
a553 2
Bool 
DRIWrapInit(ScreenPtr pScreen) {
d556 2
a557 2
    if(!dixRegisterPrivateKey(&driGCKeyRec, PRIVATE_GC, sizeof(DRIGCRec)))
	return FALSE;
d559 3
a561 2
    if(!dixRegisterPrivateKey(&driWrapScreenKeyRec, PRIVATE_SCREEN, sizeof(DRIWrapScreenRec)))
	return FALSE;
d563 2
a564 1
    pScreenPriv = dixGetPrivateAddr(&pScreen->devPrivates, &driWrapScreenKeyRec);
d567 1
a567 1
    
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a43 1
    GCOps *driOps;
d88 1
a88 3
    DRIGCRec *pGCPriv = DRIGetGCPriv(pGC);
    
    pGC->ops = pGCPriv->driOps;
a512 1
	pGCPriv->driOps = &driGCOps;
@


1.1
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d58 2
a59 2
static int driGCKeyIndex;
static DevPrivateKey driGCKey = &driGCKeyIndex;
d61 2
a62 2
static int driWrapScreenKeyIndex;
static DevPrivateKey driWrapScreenKey = &driWrapScreenKeyIndex;
d530 1
a530 1
    if(!dixRequestPrivate(driGCKey, sizeof(DRIGCRec)))
d533 1
a533 6
    if(!dixRequestPrivate(driWrapScreenKey, sizeof(DRIWrapScreenRec)))
	return FALSE;
    
    pScreenPriv = xalloc(sizeof(*pScreenPriv));

    if(NULL == pScreenPriv)
d536 1
a539 2
    dixSetPrivate(&pScreen->devPrivates, driWrapScreenKey, pScreenPriv);
        
@

