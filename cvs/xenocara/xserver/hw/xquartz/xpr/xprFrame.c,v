head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.16
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.14
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.12
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.10
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.8
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.02.16.08.40;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.09;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@/*
 * Xplugin rootless implementation frame functions
 *
 * Copyright (c) 2002-2012 Apple Computer, Inc. All rights reserved.
 * Copyright (c) 2003 Torrey T. Lyons. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xpr.h"
#include "rootlessCommon.h"
#include <Xplugin.h>
#include "x-hash.h"
#include "applewmExt.h"

#include "propertyst.h"
#include "dix.h"
#include <X11/Xatom.h>
#include "windowstr.h"
#include "quartz.h"

#ifdef HAVE_LIBDISPATCH
#include <dispatch/dispatch.h>
#else
#include <pthread.h>
#endif

#ifdef DEBUG_XP_LOCK_WINDOW
#include <execinfo.h>
#endif

#define DEFINE_ATOM_HELPER(func, atom_name)                      \
    static Atom func(void) {                                       \
        static int generation;                                      \
        static Atom atom;                                           \
        if (generation != serverGeneration) {                       \
            generation = serverGeneration;                          \
            atom = MakeAtom(atom_name, strlen(atom_name), TRUE);  \
        }                                                           \
        return atom;                                                \
    }

DEFINE_ATOM_HELPER(xa_native_window_id, "_NATIVE_WINDOW_ID")

/* Maps xp_window_id -> RootlessWindowRec */
static x_hash_table * window_hash;

/* Need to guard window_hash since xprIsX11Window can be called from any thread. */
#ifdef HAVE_LIBDISPATCH
static dispatch_queue_t window_hash_serial_q;
#else
static pthread_rwlock_t window_hash_rwlock;
#endif

/* Prototypes for static functions */
static Bool
xprCreateFrame(RootlessWindowPtr pFrame, ScreenPtr pScreen, int newX,
               int newY,
               RegionPtr pShape);
static void
xprDestroyFrame(RootlessFrameID wid);
static void
xprMoveFrame(RootlessFrameID wid, ScreenPtr pScreen, int newX, int newY);
static void
xprResizeFrame(RootlessFrameID wid, ScreenPtr pScreen, int newX, int newY,
               unsigned int newW, unsigned int newH,
               unsigned int gravity);
static void
xprRestackFrame(RootlessFrameID wid, RootlessFrameID nextWid);
static void
xprReshapeFrame(RootlessFrameID wid, RegionPtr pShape);
static void
xprUnmapFrame(RootlessFrameID wid);
static void
xprStartDrawing(RootlessFrameID wid, char **pixelData, int *bytesPerRow);
static void
xprStopDrawing(RootlessFrameID wid, Bool flush);
static void
xprUpdateRegion(RootlessFrameID wid, RegionPtr pDamage);
static void
xprDamageRects(RootlessFrameID wid, int nrects, const BoxRec *rects,
               int shift_x,
               int shift_y);
static void
xprSwitchWindow(RootlessWindowPtr pFrame, WindowPtr oldWin);
static Bool
xprDoReorderWindow(RootlessWindowPtr pFrame);
static void
xprHideWindow(RootlessFrameID wid);
static void
xprUpdateColormap(RootlessFrameID wid, ScreenPtr pScreen);
static void
xprCopyWindow(RootlessFrameID wid, int dstNrects, const BoxRec *dstRects,
              int dx,
              int dy);

static inline xp_error
xprConfigureWindow(xp_window_id id, unsigned int mask,
                   const xp_window_changes *values)
{
    return xp_configure_window(id, mask, values);
}

static void
xprSetNativeProperty(RootlessWindowPtr pFrame)
{
    xp_error err;
    unsigned int native_id;
    long data;

    err = xp_get_native_window(x_cvt_vptr_to_uint(pFrame->wid), &native_id);
    if (err == Success) {
        /* FIXME: move this to AppleWM extension */

        data = native_id;
        dixChangeWindowProperty(serverClient, pFrame->win,
                                xa_native_window_id(),
                                XA_INTEGER, 32, PropModeReplace, 1, &data,
                                TRUE);
    }
}

static xp_error
xprColormapCallback(void *data, int first_color, int n_colors,
                    uint32_t *colors)
{
    return (RootlessResolveColormap(data, first_color, n_colors,
                                    colors) ? XP_Success : XP_BadMatch);
}

/*
 * Create and display a new frame.
 */
static Bool
xprCreateFrame(RootlessWindowPtr pFrame, ScreenPtr pScreen,
               int newX, int newY, RegionPtr pShape)
{
    WindowPtr pWin = pFrame->win;
    xp_window_changes wc;
    unsigned int mask = 0;
    xp_error err;

    wc.x = newX;
    wc.y = newY;
    wc.width = pFrame->width;
    wc.height = pFrame->height;
    wc.bit_gravity = XP_GRAVITY_NONE;
    mask |= XP_BOUNDS;

    if (pWin->drawable.depth == 8) {
        wc.depth = XP_DEPTH_INDEX8;
        wc.colormap = xprColormapCallback;
        wc.colormap_data = pScreen;
        mask |= XP_COLORMAP;
    }
    else if (pWin->drawable.depth == 15)
        wc.depth = XP_DEPTH_RGB555;
    else if (pWin->drawable.depth == 24)
        wc.depth = XP_DEPTH_ARGB8888;
    else
        wc.depth = XP_DEPTH_NIL;
    mask |= XP_DEPTH;

    if (pShape != NULL) {
        wc.shape_nrects = RegionNumRects(pShape);
        wc.shape_rects = RegionRects(pShape);
        wc.shape_tx = wc.shape_ty = 0;
        mask |= XP_SHAPE;
    }

    pFrame->level =
        !IsRoot(pWin) ? AppleWMWindowLevelNormal : AppleWMNumWindowLevels;

    if (XQuartzIsRootless)
        wc.window_level = normal_window_levels[pFrame->level];
    else if (XQuartzShieldingWindowLevel)
        wc.window_level = XQuartzShieldingWindowLevel + 1;
    else
        wc.window_level = rooted_window_levels[pFrame->level];
    mask |= XP_WINDOW_LEVEL;

    err = xp_create_window(mask, &wc, (xp_window_id *)&pFrame->wid);

    if (err != Success) {
        return FALSE;
    }

#ifdef HAVE_LIBDISPATCH
    dispatch_async(window_hash_serial_q, ^ {
                       x_hash_table_insert(window_hash, pFrame->wid, pFrame);
                   });
#else
    pthread_rwlock_wrlock(&window_hash_rwlock);
    x_hash_table_insert(window_hash, pFrame->wid, pFrame);
    pthread_rwlock_unlock(&window_hash_rwlock);
#endif

    xprSetNativeProperty(pFrame);

    return TRUE;
}

/*
 * Destroy a frame.
 */
static void
xprDestroyFrame(RootlessFrameID wid)
{
    xp_error err;

#ifdef HAVE_LIBDISPATCH
    dispatch_async(window_hash_serial_q, ^ {
                       x_hash_table_remove(window_hash, wid);
                   });
#else
    pthread_rwlock_wrlock(&window_hash_rwlock);
    x_hash_table_remove(window_hash, wid);
    pthread_rwlock_unlock(&window_hash_rwlock);
#endif

    err = xp_destroy_window(x_cvt_vptr_to_uint(wid));
    if (err != Success)
        FatalError("Could not destroy window %d (%d).",
                   (int)x_cvt_vptr_to_uint(
                       wid), (int)err);
}

/*
 * Move a frame on screen.
 */
static void
xprMoveFrame(RootlessFrameID wid, ScreenPtr pScreen, int newX, int newY)
{
    xp_window_changes wc;

    wc.x = newX;
    wc.y = newY;
    //    ErrorF("xprMoveFrame(%d, %p, %d, %d)\n", wid, pScreen, newX, newY);
    xprConfigureWindow(x_cvt_vptr_to_uint(wid), XP_ORIGIN, &wc);
}

/*
 * Resize and move a frame.
 */
static void
xprResizeFrame(RootlessFrameID wid, ScreenPtr pScreen,
               int newX, int newY, unsigned int newW, unsigned int newH,
               unsigned int gravity)
{
    xp_window_changes wc;

    wc.x = newX;
    wc.y = newY;
    wc.width = newW;
    wc.height = newH;
    wc.bit_gravity = gravity;

    /* It's unlikely that being async will save us anything here.
       But it can't hurt. */

    xprConfigureWindow(x_cvt_vptr_to_uint(wid), XP_BOUNDS, &wc);
}

/*
 * Change frame stacking.
 */
static void
xprRestackFrame(RootlessFrameID wid, RootlessFrameID nextWid)
{
    xp_window_changes wc;
    unsigned int mask = XP_STACKING;
#ifdef HAVE_LIBDISPATCH
    __block
#endif
    RootlessWindowRec * winRec;

    /* Stack frame below nextWid it if it exists, or raise
       frame above everything otherwise. */

    if (nextWid == NULL) {
        wc.stack_mode = XP_MAPPED_ABOVE;
        wc.sibling = 0;
    }
    else {
        wc.stack_mode = XP_MAPPED_BELOW;
        wc.sibling = x_cvt_vptr_to_uint(nextWid);
    }

#ifdef HAVE_LIBDISPATCH
    dispatch_sync(window_hash_serial_q, ^ {
                      winRec = x_hash_table_lookup(window_hash, wid, NULL);
                  });
#else
    pthread_rwlock_rdlock(&window_hash_rwlock);
    winRec = x_hash_table_lookup(window_hash, wid, NULL);
    pthread_rwlock_unlock(&window_hash_rwlock);
#endif

    if (winRec) {
        if (XQuartzIsRootless)
            wc.window_level = normal_window_levels[winRec->level];
        else if (XQuartzShieldingWindowLevel)
            wc.window_level = XQuartzShieldingWindowLevel + 1;
        else
            wc.window_level = rooted_window_levels[winRec->level];
        mask |= XP_WINDOW_LEVEL;
    }

    xprConfigureWindow(x_cvt_vptr_to_uint(wid), mask, &wc);
}

/*
 * Change the frame's shape.
 */
static void
xprReshapeFrame(RootlessFrameID wid, RegionPtr pShape)
{
    xp_window_changes wc;

    if (pShape != NULL) {
        wc.shape_nrects = RegionNumRects(pShape);
        wc.shape_rects = RegionRects(pShape);
    }
    else {
        wc.shape_nrects = -1;
        wc.shape_rects = NULL;
    }

    wc.shape_tx = wc.shape_ty = 0;

    xprConfigureWindow(x_cvt_vptr_to_uint(wid), XP_SHAPE, &wc);
}

/*
 * Unmap a frame.
 */
static void
xprUnmapFrame(RootlessFrameID wid)
{
    xp_window_changes wc;

    wc.stack_mode = XP_UNMAPPED;
    wc.sibling = 0;

    xprConfigureWindow(x_cvt_vptr_to_uint(wid), XP_STACKING, &wc);
}

/*
 * Start drawing to a frame.
 *  Prepare for direct access to its backing buffer.
 */
static void
xprStartDrawing(RootlessFrameID wid, char **pixelData, int *bytesPerRow)
{
    void *data[2];
    unsigned int rowbytes[2];
    xp_error err;

#ifdef DEBUG_XP_LOCK_WINDOW
    void* callstack[128];
    int i, frames = backtrace(callstack, 128);
    char** strs = backtrace_symbols(callstack, frames);

    ErrorF("=== LOCK %d ===\n", (int)x_cvt_vptr_to_uint(wid));
    for (i = 0; i < frames; ++i) {
        ErrorF("    %s\n", strs[i]);
    }
    free(strs);
#endif

    err = xp_lock_window(x_cvt_vptr_to_uint(
                             wid), NULL, NULL, data, rowbytes, NULL);
    if (err != Success)
        FatalError("Could not lock window %d for drawing (%d).",
                   (int)x_cvt_vptr_to_uint(
                       wid), (int)err);

    *pixelData = data[0];
    *bytesPerRow = rowbytes[0];
}

/*
 * Stop drawing to a frame.
 */
static void
xprStopDrawing(RootlessFrameID wid, Bool flush)
{
    xp_error err;

#ifdef DEBUG_XP_LOCK_WINDOW
    void* callstack[128];
    int i, frames = backtrace(callstack, 128);
    char** strs = backtrace_symbols(callstack, frames);

    ErrorF("=== UNLOCK %d ===\n", (int)x_cvt_vptr_to_uint(wid));
    for (i = 0; i < frames; ++i) {
        ErrorF("    %s\n", strs[i]);
    }
    free(strs);
#endif

    err = xp_unlock_window(x_cvt_vptr_to_uint(wid), flush);
    /* This should be a FatalError, but we started tripping over it.  Make it a
     * FatalError after http://xquartz.macosforge.org/trac/ticket/482 is fixed.
     */
    if (err != Success)
        ErrorF("Could not unlock window %d after drawing (%d).",
               (int)x_cvt_vptr_to_uint(
                   wid), (int)err);
}

/*
 * Flush drawing updates to the screen.
 */
static void
xprUpdateRegion(RootlessFrameID wid, RegionPtr pDamage)
{
    xp_flush_window(x_cvt_vptr_to_uint(wid));
}

/*
 * Mark damaged rectangles as requiring redisplay to screen.
 */
static void
xprDamageRects(RootlessFrameID wid, int nrects, const BoxRec *rects,
               int shift_x, int shift_y)
{
    xp_mark_window(x_cvt_vptr_to_uint(wid), nrects, rects, shift_x, shift_y);
}

/*
 * Called after the window associated with a frame has been switched
 * to a new top-level parent.
 */
static void
xprSwitchWindow(RootlessWindowPtr pFrame, WindowPtr oldWin)
{
    DeleteProperty(serverClient, oldWin, xa_native_window_id());

    xprSetNativeProperty(pFrame);
}

/*
 * Called to check if the frame should be reordered when it is restacked.
 */
static Bool
xprDoReorderWindow(RootlessWindowPtr pFrame)
{
    WindowPtr pWin = pFrame->win;

    return AppleWMDoReorderWindow(pWin);
}

/*
 * Copy area in frame to another part of frame.
 *  Used to accelerate scrolling.
 */
static void
xprCopyWindow(RootlessFrameID wid, int dstNrects, const BoxRec *dstRects,
              int dx, int dy)
{
    xp_copy_window(x_cvt_vptr_to_uint(wid), x_cvt_vptr_to_uint(wid),
                   dstNrects, dstRects, dx, dy);
}

static RootlessFrameProcsRec xprRootlessProcs = {
    xprCreateFrame,
    xprDestroyFrame,
    xprMoveFrame,
    xprResizeFrame,
    xprRestackFrame,
    xprReshapeFrame,
    xprUnmapFrame,
    xprStartDrawing,
    xprStopDrawing,
    xprUpdateRegion,
    xprDamageRects,
    xprSwitchWindow,
    xprDoReorderWindow,
    xprHideWindow,
    xprUpdateColormap,
    xp_copy_bytes,
    xprCopyWindow
};

/*
 * Initialize XPR implementation
 */
Bool
xprInit(ScreenPtr pScreen)
{
    RootlessInit(pScreen, &xprRootlessProcs);

    rootless_CopyBytes_threshold = xp_copy_bytes_threshold;
    rootless_CopyWindow_threshold = xp_scroll_area_threshold;

    assert((window_hash = x_hash_table_new(NULL, NULL, NULL, NULL)));
#ifdef HAVE_LIBDISPATCH
    assert((window_hash_serial_q =
                dispatch_queue_create(BUNDLE_ID_PREFIX ".X11.xpr_window_hash",
                                      NULL)));
#else
    assert(0 == pthread_rwlock_init(&window_hash_rwlock, NULL));
#endif

    return TRUE;
}

/*
 * Given the id of a physical window, try to find the top-level (or root)
 * X window that it represents.
 */
WindowPtr
xprGetXWindow(xp_window_id wid)
{
#ifdef HAVE_LIBDISPATCH
    RootlessWindowRec *winRec __block;
    dispatch_sync(window_hash_serial_q, ^ {
                      winRec =
                          x_hash_table_lookup(window_hash,
                                              x_cvt_uint_to_vptr(wid), NULL);
                  });
#else
    RootlessWindowRec *winRec;
    pthread_rwlock_rdlock(&window_hash_rwlock);
    winRec = x_hash_table_lookup(window_hash, x_cvt_uint_to_vptr(wid), NULL);
    pthread_rwlock_unlock(&window_hash_rwlock);
#endif

    return winRec != NULL ? winRec->win : NULL;
}

/*
 * The windowNumber is an AppKit window number. Returns TRUE if xpr is
 * displaying a window with that number.
 */
Bool
xprIsX11Window(int windowNumber)
{
    Bool ret;
    xp_window_id wid;

    if (xp_lookup_native_window(windowNumber, &wid))
        ret = xprGetXWindow(wid) != NULL;
    else
        ret = FALSE;

    return ret;
}

/*
 * xprHideWindows
 *  Hide or unhide all top level windows. This is called for application hide/
 *  unhide events if the window manager is not Apple-WM aware. Xplugin windows
 *  do not hide or unhide themselves.
 */
void
xprHideWindows(Bool hide)
{
    int screen;
    WindowPtr pRoot, pWin;

    for (screen = 0; screen < screenInfo.numScreens; screen++) {
        RootlessFrameID prevWid = NULL;
        pRoot = screenInfo.screens[screen]->root;

        for (pWin = pRoot->firstChild; pWin; pWin = pWin->nextSib) {
            RootlessWindowRec *winRec = WINREC(pWin);

            if (winRec != NULL) {
                if (hide) {
                    xprUnmapFrame(winRec->wid);
                }
                else {
                    BoxRec box;

                    xprRestackFrame(winRec->wid, prevWid);
                    prevWid = winRec->wid;

                    box.x1 = 0;
                    box.y1 = 0;
                    box.x2 = winRec->width;
                    box.y2 = winRec->height;

                    xprDamageRects(winRec->wid, 1, &box, 0, 0);
                    RootlessQueueRedisplay(screenInfo.screens[screen]);
                }
            }
        }
    }
}

// XXX: identical to x_cvt_vptr_to_uint ?
#define MAKE_WINDOW_ID(x) ((xp_window_id)((size_t)(x)))

Bool no_configure_window;

static inline int
configure_window(xp_window_id id, unsigned int mask,
                 const xp_window_changes *values)
{
    if (!no_configure_window)
        return xp_configure_window(id, mask, values);
    else
        return XP_Success;
}

static
void
xprUpdateColormap(RootlessFrameID wid, ScreenPtr pScreen)
{
    /* This is how we tell xp that the colormap may have changed. */
    xp_window_changes wc;
    wc.colormap = xprColormapCallback;
    wc.colormap_data = pScreen;

    configure_window(MAKE_WINDOW_ID(wid), XP_COLORMAP, &wc);
}

static
void
xprHideWindow(RootlessFrameID wid)
{
    xp_window_changes wc;
    wc.stack_mode = XP_UNMAPPED;
    wc.sibling = 0;
    configure_window(MAKE_WINDOW_ID(wid), XP_STACKING, &wc);
}
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d52 4
d383 12
d413 12
@


1.6
log
@Update to xserver 1.11.2
@
text
@d4 1
a4 1
 * Copyright (c) 2002-2011 Apple Computer, Inc. All rights reserved.
d52 10
a61 10
#define DEFINE_ATOM_HELPER(func,atom_name)                      \
static Atom func (void) {                                       \
    static int generation;                                      \
    static Atom atom;                                           \
    if (generation != serverGeneration) {                       \
        generation = serverGeneration;                          \
        atom = MakeAtom (atom_name, strlen (atom_name), TRUE);  \
    }                                                           \
    return atom;                                                \
}
d66 1
a66 1
static x_hash_table *window_hash;
d76 11
a86 6
static Bool xprCreateFrame(RootlessWindowPtr pFrame, ScreenPtr pScreen,
               int newX, int newY, RegionPtr pShape);
static void xprDestroyFrame(RootlessFrameID wid);
static void xprMoveFrame(RootlessFrameID wid, ScreenPtr pScreen, int newX, int newY);
static void xprResizeFrame(RootlessFrameID wid, ScreenPtr pScreen,
               int newX, int newY, unsigned int newW, unsigned int newH,
d88 28
a115 15
static void xprRestackFrame(RootlessFrameID wid, RootlessFrameID nextWid);
static void xprReshapeFrame(RootlessFrameID wid, RegionPtr pShape);
static void xprUnmapFrame(RootlessFrameID wid);
static void xprStartDrawing(RootlessFrameID wid, char **pixelData, int *bytesPerRow);
static void xprStopDrawing(RootlessFrameID wid, Bool flush);
static void xprUpdateRegion(RootlessFrameID wid, RegionPtr pDamage);
static void xprDamageRects(RootlessFrameID wid, int nrects, const BoxRec *rects,
               int shift_x, int shift_y);
static void xprSwitchWindow(RootlessWindowPtr pFrame, WindowPtr oldWin);
static Bool xprDoReorderWindow(RootlessWindowPtr pFrame);
static void xprHideWindow(RootlessFrameID wid);
static void xprUpdateColormap(RootlessFrameID wid, ScreenPtr pScreen);
static void xprCopyWindow(RootlessFrameID wid, int dstNrects, const BoxRec *dstRects,
              int dx, int dy);

a123 1

d132 1
a132 2
    if (err == Success)
    {
d136 4
a139 2
        dixChangeWindowProperty(serverClient, pFrame->win, xa_native_window_id(),
				XA_INTEGER, 32, PropModeReplace, 1, &data, TRUE);
d144 2
a145 1
xprColormapCallback(void *data, int first_color, int n_colors, uint32_t *colors)
d147 2
a148 1
    return (RootlessResolveColormap (data, first_color, n_colors, colors) ? XP_Success : XP_BadMatch);
d170 1
a170 2
    if (pWin->drawable.depth == 8)
    {
d184 1
a184 2
    if (pShape != NULL)
    {
d191 2
a192 1
    pFrame->level = !IsRoot (pWin) ? AppleWMWindowLevelNormal : AppleWMNumWindowLevels;
d194 1
a194 1
    if(XQuartzIsRootless)
d196 1
a196 1
    else if(XQuartzShieldingWindowLevel)
d202 1
a202 1
    err = xp_create_window(mask, &wc, (xp_window_id *) &pFrame->wid);
d204 1
a204 2
    if (err != Success)
    {
d209 3
a211 3
    dispatch_async(window_hash_serial_q, ^{
        x_hash_table_insert(window_hash, pFrame->wid, pFrame);
    });
d215 1
a215 1
    pthread_rwlock_wrlock(&window_hash_rwlock);
a222 1

d232 3
a234 3
    dispatch_async(window_hash_serial_q, ^{
        x_hash_table_remove(window_hash, wid);
    });
d243 3
a245 1
        FatalError("Could not destroy window %d (%d).", (int)x_cvt_vptr_to_uint(wid), (int)err);
a247 1

a261 1

a283 1

d287 3
a289 1
static void xprRestackFrame(RootlessFrameID wid, RootlessFrameID nextWid) {
d295 1
a295 1
    RootlessWindowRec *winRec;
d300 1
a300 1
    if(nextWid == NULL) {
d303 2
a304 1
    } else {
d310 3
a312 3
    dispatch_sync(window_hash_serial_q, ^{
        winRec = x_hash_table_lookup(window_hash, wid, NULL);
    });
d318 3
a320 3
    
    if(winRec) {
        if(XQuartzIsRootless)
d322 1
a322 1
        else if(XQuartzShieldingWindowLevel)
a331 1

d340 1
a340 2
    if (pShape != NULL)
    {
d344 1
a344 2
    else
    {
a353 1

a367 1

d379 2
a380 1
    err = xp_lock_window(x_cvt_vptr_to_uint(wid), NULL, NULL, data, rowbytes, NULL);
d382 3
a384 1
        FatalError("Could not lock window %d for drawing (%d).", (int)x_cvt_vptr_to_uint(wid), (int)err);
a389 1

d402 4
a405 2
    if(err != Success)
        ErrorF("Could not unlock window %d after drawing (%d).", (int)x_cvt_vptr_to_uint(wid), (int)err);
a407 1

a416 1

a426 1

a438 1

d442 2
a443 1
static Bool xprDoReorderWindow(RootlessWindowPtr pFrame)
a449 1

a461 1

a481 1

d495 3
a497 1
    assert((window_hash_serial_q = dispatch_queue_create(BUNDLE_ID_PREFIX".X11.xpr_window_hash", NULL)));
d501 1
a501 1
    
a504 1

d514 5
a518 3
    dispatch_sync(window_hash_serial_q, ^{
        winRec = x_hash_table_lookup(window_hash, x_cvt_uint_to_vptr(wid), NULL);
    });
a546 1

d569 2
a570 1
                } else {
d590 1
a590 1
#define MAKE_WINDOW_ID(x)		((xp_window_id)((size_t)(x)))
d595 2
a596 2
configure_window (xp_window_id id, unsigned int mask,
                  const xp_window_changes *values)
d598 4
a601 4
  if (!no_configure_window)
    return xp_configure_window (id, mask, values);
  else
    return XP_Success;
a603 1

d605 2
a606 1
void xprUpdateColormap(RootlessFrameID wid, ScreenPtr pScreen)
d608 4
a611 4
  /* This is how we tell xp that the colormap may have changed. */
  xp_window_changes wc;
  wc.colormap = xprColormapCallback;
  wc.colormap_data = pScreen;
d613 1
a613 1
  configure_window(MAKE_WINDOW_ID(wid), XP_COLORMAP, &wc);
d617 2
a618 1
void xprHideWindow(RootlessFrameID wid)
d620 4
a623 4
  xp_window_changes wc;
  wc.stack_mode = XP_UNMAPPED;
  wc.sibling = 0;
  configure_window(MAKE_WINDOW_ID(wid), XP_STACKING, &wc);
@


1.5
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d4 1
a4 1
 * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
a37 1
#include "x-list.h"
d46 3
a48 2
#include "threadSafety.h"

d50 1
d67 7
a73 1
static pthread_mutex_t window_hash_mutex;
a102 2
    TA_SERVER();

a113 2
    TA_SERVER();
    
a142 2
    TA_SERVER();
    
d190 6
a195 7
    if (window_hash == NULL)
    {
        window_hash = x_hash_table_new(NULL, NULL, NULL, NULL);
        pthread_mutex_init(&window_hash_mutex, NULL);
    }

    pthread_mutex_lock(&window_hash_mutex);
d197 2
a198 1
    pthread_mutex_unlock(&window_hash_mutex);
d213 7
a219 3
    TA_SERVER();
    
    pthread_mutex_lock(&window_hash_mutex);
d221 2
a222 1
    pthread_mutex_unlock(&window_hash_mutex);
d226 1
a226 1
        FatalError("Could not destroy window %i.", (int)x_cvt_vptr_to_uint(wid));
a237 2
    TA_SERVER();
    
a254 2
    TA_SERVER();
    
d274 4
a278 2
    TA_SERVER();
    
d290 18
a307 12
    if(window_hash) {
        RootlessWindowRec *winRec = x_hash_table_lookup(window_hash, wid, NULL);

        if(winRec) {
            if(XQuartzIsRootless)
                wc.window_level = normal_window_levels[winRec->level];
            else if(XQuartzShieldingWindowLevel)
                wc.window_level = XQuartzShieldingWindowLevel + 1;
            else
                wc.window_level = rooted_window_levels[winRec->level];
            mask |= XP_WINDOW_LEVEL;
        }
a321 2
    TA_SERVER();
    
a346 2
    TA_SERVER();
    
a364 2
    TA_SERVER();
    
d367 1
a367 1
        FatalError("Could not lock window %i for drawing.", (int)x_cvt_vptr_to_uint(wid));
d381 1
a381 2
    TA_SERVER();
    
d383 3
d387 1
a387 1
        FatalError("Could not unlock window %i after drawing.", (int)x_cvt_vptr_to_uint(wid));
a396 2
    TA_SERVER();
    
a407 2
    TA_SERVER();
    
a420 2
    TA_SERVER();
    
a431 2
    TA_SERVER();
    
a443 2
    TA_SERVER();
    
a465 2
    xp_fill_bytes,
    xp_composite_pixels,
a477 2
    TA_SERVER();
    
a478 2
    rootless_FillBytes_threshold = xp_fill_bytes_threshold;
    rootless_CompositePixels_threshold = xp_composite_area_threshold;
d481 7
d499 6
d506 1
a506 4

    if (window_hash == NULL)
        return NULL;

d508 2
a513 33
#ifdef UNUSED_CODE
/*
 * Given the id of a physical window, try to find the top-level (or root)
 * X window that it represents.
 */
WindowPtr
xprGetXWindowFromAppKit(int windowNumber)
{
    RootlessWindowRec *winRec;
    Bool ret;
    xp_window_id wid;

    if (window_hash == NULL)
        return FALSE;

    /* need to lock, since this function can be called by any thread */

    pthread_mutex_lock(&window_hash_mutex);

    if (xp_lookup_native_window(windowNumber, &wid))
        ret = xprGetXWindow(wid) != NULL;
    else
        ret = FALSE;

    pthread_mutex_unlock(&window_hash_mutex);

    if (!ret) return NULL;
    winRec = x_hash_table_lookup(window_hash, x_cvt_uint_to_vptr(wid), NULL);

    return winRec != NULL ? winRec->win : NULL;
}
#endif

d519 1
a519 1
xprIsX11Window(void *nsWindow, int windowNumber)
a523 7
    if (window_hash == NULL)
        return FALSE;

    /* need to lock, since this function can be called by any thread */

    pthread_mutex_lock(&window_hash_mutex);

a528 2
    pthread_mutex_unlock(&window_hash_mutex);

a544 2
    TA_SERVER();
    
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d176 2
d292 2
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d166 2
a167 2
        wc.shape_nrects = REGION_NUM_RECTS(pShape);
        wc.shape_rects = REGION_RECTS(pShape);
d174 1
a174 1
    if(quartzEnableRootless)
d209 1
d216 3
a218 1
    xp_destroy_window(x_cvt_vptr_to_uint(wid));
d288 1
a288 1
            if(quartzEnableRootless)
d312 2
a313 2
        wc.shape_nrects = REGION_NUM_RECTS(pShape);
        wc.shape_rects = REGION_RECTS(pShape);
d372 1
d375 3
a377 1
    xp_unlock_window(x_cvt_vptr_to_uint(wid), flush);
d585 1
a585 1
        pRoot = WindowTable[screenInfo.screens[screen]->myNum];
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d45 1
d86 2
d122 5
d131 1
a131 1
Bool
d152 1
a152 1
        wc.colormap = RootlessColormapCallback;
d172 8
d206 1
a206 1
void
d222 1
a222 1
void
d225 2
a228 2
    xp_window_changes wc;

d239 1
a239 1
void
d264 1
a264 3
void
xprRestackFrame(RootlessFrameID wid, RootlessFrameID nextWid)
{
d266 1
d270 1
a270 1
   /* Stack frame below nextWid it if it exists, or raise
d273 1
a273 2
    if (nextWid == NULL)
    {
d276 1
a276 3
    }
    else
    {
d281 13
a293 1
    xprConfigureWindow(x_cvt_vptr_to_uint(wid), XP_STACKING, &wc);
d300 1
a300 1
void
d327 1
a327 1
void
d345 1
a345 1
void
d366 1
a366 1
void
d378 1
a378 1
void
d390 1
a390 1
void
d404 1
a404 1
void
d418 1
a418 1
Bool xprDoReorderWindow(RootlessWindowPtr pFrame)
d432 1
a432 1
void
d457 2
d502 1
d533 1
a533 1

d578 1
a579 1
        RootlessFrameID prevWid = NULL;
d604 36
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d36 1
a36 1
#include "Xplugin.h"
d46 2
d67 20
a86 1
static Bool no_configure_window;
d93 3
a95 5
  //  ErrorF("xprConfigureWindow()\n");
    if (!no_configure_window)
        return xp_configure_window(id, mask, values);
    else
        return XP_Success;
d106 3
a108 1
    err = xp_get_native_window((xp_window_id) pFrame->wid, &native_id);
d132 2
d144 1
a144 2
#if 0
        wc.colormap = xprColormapCallback;
a146 1
#endif
d193 2
d199 1
a199 1
    xp_destroy_window((xp_window_id) wid);
d209 2
d216 1
a216 1
    xprConfigureWindow((xp_window_id) wid, XP_ORIGIN, &wc);
d230 2
d241 1
a241 1
    xprConfigureWindow((xp_window_id) wid, XP_BOUNDS, &wc);
d253 3
a255 1
    /* Stack frame below nextWid it if it exists, or raise
d266 1
a266 1
        wc.sibling = (xp_window_id) nextWid;
d269 1
a269 1
    xprConfigureWindow((xp_window_id) wid, XP_STACKING, &wc);
d281 2
d296 1
a296 1
    xprConfigureWindow((xp_window_id) wid, XP_SHAPE, &wc);
d308 2
d313 1
a313 1
    xprConfigureWindow((xp_window_id) wid, XP_STACKING, &wc);
d328 3
a330 1
    err = xp_lock_window((xp_window_id) wid, NULL, NULL, data, rowbytes, NULL);
d332 1
a332 1
        FatalError("Could not lock window %i for drawing.", (int) wid);
d345 3
a347 1
    xp_unlock_window((xp_window_id) wid, flush);
d357 3
a359 1
    xp_flush_window((xp_window_id) wid);
d370 3
a372 1
    xp_mark_window((xp_window_id) wid, nrects, rects, shift_x, shift_y);
d385 2
d398 2
d412 3
a414 1
    xp_copy_window((xp_window_id) wid, (xp_window_id) wid,
d448 2
a454 2
    no_configure_window = FALSE;

d471 1
a471 1
    winRec = x_hash_table_lookup(window_hash, (void *) wid, NULL);
d502 1
a502 1
    winRec = x_hash_table_lookup(window_hash, (void *) wid, NULL);
d548 2
@

