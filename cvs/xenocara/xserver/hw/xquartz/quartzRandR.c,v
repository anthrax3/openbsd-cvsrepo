head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.20
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.18
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.16
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.14
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.12
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.53;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.04.02.16.08.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.21.20.10.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@/*
 * Quartz-specific support for the XRandR extension
 *
 * Copyright (c) 2001-2004 Greg Parker and Torrey T. Lyons,
 *               2010      Jan Hauffa.
 *               2010-2012 Apple Inc.
 *                 All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
 */

#include "sanitizedCarbon.h"

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "quartzCommon.h"
#include "quartzRandR.h"
#include "quartz.h"
#include "darwin.h"

#include "X11Application.h"

#include <AvailabilityMacros.h>

#include <X11/extensions/randr.h>
#include <randrstr.h>
#include <IOKit/graphics/IOGraphicsTypes.h>

/* TODO: UGLY, find a better way!
 * We want to ignore kXquartzDisplayChanged which are generated by us
 */
static Bool ignore_next_fake_mode_update = FALSE;

#define FAKE_REFRESH_ROOTLESS   1
#define FAKE_REFRESH_FULLSCREEN 2

#define DEFAULT_REFRESH         60
#define kDisplayModeUsableFlags (kDisplayModeValidFlag | kDisplayModeSafeFlag)

#define CALLBACK_SUCCESS        0
#define CALLBACK_CONTINUE       1
#define CALLBACK_ERROR          -1

typedef int (*QuartzModeCallback)
    (ScreenPtr, QuartzModeInfoPtr, void *);

#if MAC_OS_X_VERSION_MIN_REQUIRED < 1060

static long
getDictLong(CFDictionaryRef dictRef, CFStringRef key)
{
    long value;

    CFNumberRef numRef = (CFNumberRef)CFDictionaryGetValue(dictRef, key);
    if (!numRef)
        return 0;

    if (!CFNumberGetValue(numRef, kCFNumberLongType, &value))
        return 0;
    return value;
}

static double
getDictDouble(CFDictionaryRef dictRef, CFStringRef key)
{
    double value;

    CFNumberRef numRef = (CFNumberRef)CFDictionaryGetValue(dictRef, key);
    if (!numRef)
        return 0.0;

    if (!CFNumberGetValue(numRef, kCFNumberDoubleType, &value))
        return 0.0;
    return value;
}

static void
QuartzRandRGetModeInfo(CFDictionaryRef modeRef,
                       QuartzModeInfoPtr pMode)
{
    pMode->width = (size_t)getDictLong(modeRef, kCGDisplayWidth);
    pMode->height = (size_t)getDictLong(modeRef, kCGDisplayHeight);
    pMode->refresh =
        (int)(getDictDouble(modeRef, kCGDisplayRefreshRate) + 0.5);
    if (pMode->refresh == 0)
        pMode->refresh = DEFAULT_REFRESH;
    pMode->ref = NULL;
    pMode->pSize = NULL;
}

static Bool
QuartzRandRCopyCurrentModeInfo(CGDirectDisplayID screenId,
                               QuartzModeInfoPtr pMode)
{
    CFDictionaryRef curModeRef = CGDisplayCurrentMode(screenId);
    if (!curModeRef)
        return FALSE;

    QuartzRandRGetModeInfo(curModeRef, pMode);
    pMode->ref = (void *)curModeRef;
    CFRetain(pMode->ref);
    return TRUE;
}

static Bool
QuartzRandRSetCGMode(CGDirectDisplayID screenId,
                     QuartzModeInfoPtr pMode)
{
    CFDictionaryRef modeRef = (CFDictionaryRef)pMode->ref;
    return (CGDisplaySwitchToMode(screenId, modeRef) == kCGErrorSuccess);
}

static Bool
QuartzRandREnumerateModes(ScreenPtr pScreen,
                          QuartzModeCallback callback,
                          void *data)
{
    Bool retval = FALSE;
    QuartzScreenPtr pQuartzScreen = QUARTZ_PRIV(pScreen);

    /* Just an 800x600 fallback if we have no attached heads */
    if (pQuartzScreen->displayIDs) {
        CFDictionaryRef curModeRef, modeRef;
        long curBpp;
        CFArrayRef modes;
        QuartzModeInfo modeInfo;
        int i;
        CGDirectDisplayID screenId = pQuartzScreen->displayIDs[0];

        curModeRef = CGDisplayCurrentMode(screenId);
        if (!curModeRef)
            return FALSE;
        curBpp = getDictLong(curModeRef, kCGDisplayBitsPerPixel);

        modes = CGDisplayAvailableModes(screenId);
        if (!modes)
            return FALSE;
        for (i = 0; i < CFArrayGetCount(modes); i++) {
            int cb;
            modeRef = (CFDictionaryRef)CFArrayGetValueAtIndex(modes, i);

            /* Skip modes that are not usable on the current display or have a
               different pixel encoding than the current mode. */
            if (((unsigned long)getDictLong(modeRef, kCGDisplayIOFlags) &
                 kDisplayModeUsableFlags) != kDisplayModeUsableFlags)
                continue;
            if (getDictLong(modeRef, kCGDisplayBitsPerPixel) != curBpp)
                continue;

            QuartzRandRGetModeInfo(modeRef, &modeInfo);
            modeInfo.ref = (void *)modeRef;
            cb = callback(pScreen, &modeInfo, data);
            if (cb == CALLBACK_CONTINUE)
                retval = TRUE;
            else if (cb == CALLBACK_SUCCESS)
                return TRUE;
            else if (cb == CALLBACK_ERROR)
                return FALSE;
        }
    }

    switch (callback(pScreen, &pQuartzScreen->rootlessMode, data)) {
    case CALLBACK_SUCCESS:
        return TRUE;

    case CALLBACK_ERROR:
        return FALSE;

    case CALLBACK_CONTINUE:
        retval = TRUE;

    default:
        break;
    }

    switch (callback(pScreen, &pQuartzScreen->fullscreenMode, data)) {
    case CALLBACK_SUCCESS:
        return TRUE;

    case CALLBACK_ERROR:
        return FALSE;

    case CALLBACK_CONTINUE:
        retval = TRUE;

    default:
        break;
    }

    return retval;
}

#else /* we have the new CG APIs from Snow Leopard */

static void
QuartzRandRGetModeInfo(CGDisplayModeRef modeRef,
                       QuartzModeInfoPtr pMode)
{
    pMode->width = CGDisplayModeGetWidth(modeRef);
    pMode->height = CGDisplayModeGetHeight(modeRef);
    pMode->refresh = (int)(CGDisplayModeGetRefreshRate(modeRef) + 0.5);
    if (pMode->refresh == 0)
        pMode->refresh = DEFAULT_REFRESH;
    pMode->ref = NULL;
    pMode->pSize = NULL;
}

static Bool
QuartzRandRCopyCurrentModeInfo(CGDirectDisplayID screenId,
                               QuartzModeInfoPtr pMode)
{
    CGDisplayModeRef curModeRef = CGDisplayCopyDisplayMode(screenId);
    if (!curModeRef)
        return FALSE;

    QuartzRandRGetModeInfo(curModeRef, pMode);
    pMode->ref = curModeRef;
    return TRUE;
}

static Bool
QuartzRandRSetCGMode(CGDirectDisplayID screenId,
                     QuartzModeInfoPtr pMode)
{
    CGDisplayModeRef modeRef = (CGDisplayModeRef)pMode->ref;
    if (!modeRef)
        return FALSE;

    return (CGDisplaySetDisplayMode(screenId, modeRef,
                                    NULL) == kCGErrorSuccess);
}

static Bool
QuartzRandREnumerateModes(ScreenPtr pScreen,
                          QuartzModeCallback callback,
                          void *data)
{
    Bool retval = FALSE;
    QuartzScreenPtr pQuartzScreen = QUARTZ_PRIV(pScreen);

    /* Just an 800x600 fallback if we have no attached heads */
    if (pQuartzScreen->displayIDs) {
        CGDisplayModeRef curModeRef, modeRef;
        CFStringRef curPixelEnc, pixelEnc;
        CFComparisonResult pixelEncEqual;
        CFArrayRef modes;
        QuartzModeInfo modeInfo;
        int i;
        CGDirectDisplayID screenId = pQuartzScreen->displayIDs[0];

        curModeRef = CGDisplayCopyDisplayMode(screenId);
        if (!curModeRef)
            return FALSE;
        curPixelEnc = CGDisplayModeCopyPixelEncoding(curModeRef);
        CGDisplayModeRelease(curModeRef);

        modes = CGDisplayCopyAllDisplayModes(screenId, NULL);
        if (!modes) {
            CFRelease(curPixelEnc);
            return FALSE;
        }
        for (i = 0; i < CFArrayGetCount(modes); i++) {
            int cb;
            modeRef = (CGDisplayModeRef)CFArrayGetValueAtIndex(modes, i);

            /* Skip modes that are not usable on the current display or have a
               different pixel encoding than the current mode. */
            if ((CGDisplayModeGetIOFlags(modeRef) &
                 kDisplayModeUsableFlags) !=
                kDisplayModeUsableFlags)
                continue;
            pixelEnc = CGDisplayModeCopyPixelEncoding(modeRef);
            pixelEncEqual = CFStringCompare(pixelEnc, curPixelEnc, 0);
            CFRelease(pixelEnc);
            if (pixelEncEqual != kCFCompareEqualTo)
                continue;

            QuartzRandRGetModeInfo(modeRef, &modeInfo);
            modeInfo.ref = modeRef;
            cb = callback(pScreen, &modeInfo, data);
            if (cb == CALLBACK_CONTINUE) {
                retval = TRUE;
            }
            else if (cb == CALLBACK_SUCCESS) {
                CFRelease(modes);
                CFRelease(curPixelEnc);
                return TRUE;
            }
            else if (cb == CALLBACK_ERROR) {
                CFRelease(modes);
                CFRelease(curPixelEnc);
                return FALSE;
            }
        }

        CFRelease(modes);
        CFRelease(curPixelEnc);
    }

    switch (callback(pScreen, &pQuartzScreen->rootlessMode, data)) {
    case CALLBACK_SUCCESS:
        return TRUE;

    case CALLBACK_ERROR:
        return FALSE;

    case CALLBACK_CONTINUE:
        retval = TRUE;

    default:
        break;
    }

    switch (callback(pScreen, &pQuartzScreen->fullscreenMode, data)) {
    case CALLBACK_SUCCESS:
        return TRUE;

    case CALLBACK_ERROR:
        return FALSE;

    case CALLBACK_CONTINUE:
        retval = TRUE;

    default:
        break;
    }

    return retval;
}

#endif  /* Snow Leopard CoreGraphics APIs */

static Bool
QuartzRandRModesEqual(QuartzModeInfoPtr pMode1,
                      QuartzModeInfoPtr pMode2)
{
    return (pMode1->width == pMode2->width) &&
           (pMode1->height == pMode2->height) &&
           (pMode1->refresh == pMode2->refresh);
}

static Bool
QuartzRandRRegisterMode(ScreenPtr pScreen,
                        QuartzModeInfoPtr pMode)
{
    QuartzScreenPtr pQuartzScreen = QUARTZ_PRIV(pScreen);
    Bool isCurrentMode = QuartzRandRModesEqual(&pQuartzScreen->currentMode,
                                               pMode);

    /* TODO: DPI */
    pMode->pSize =
        RRRegisterSize(pScreen, pMode->width, pMode->height, pScreen->mmWidth,
                       pScreen->mmHeight);
    if (pMode->pSize) {
        //DEBUG_LOG("registering: %d x %d @@ %d %s\n", (int)pMode->width, (int)pMode->height, (int)pMode->refresh, isCurrentMode ? "*" : "");
        RRRegisterRate(pScreen, pMode->pSize, pMode->refresh);

        if (isCurrentMode)
            RRSetCurrentConfig(pScreen, RR_Rotate_0, pMode->refresh,
                               pMode->pSize);

        return TRUE;
    }
    return FALSE;
}

static int
QuartzRandRRegisterModeCallback(ScreenPtr pScreen,
                                QuartzModeInfoPtr pMode,
                                void *data __unused)
{
    if (QuartzRandRRegisterMode(pScreen, pMode)) {
        return CALLBACK_CONTINUE;
    }
    else {
        return CALLBACK_ERROR;
    }
}

static Bool
QuartzRandRSetMode(ScreenPtr pScreen, QuartzModeInfoPtr pMode,
                   BOOL doRegister)
{
    QuartzScreenPtr pQuartzScreen = QUARTZ_PRIV(pScreen);
    Bool captureDisplay =
        (pMode->refresh != FAKE_REFRESH_FULLSCREEN && pMode->refresh !=
    FAKE_REFRESH_ROOTLESS);
    CGDirectDisplayID screenId;

    if (pQuartzScreen->displayIDs == NULL)
        return FALSE;

    screenId = pQuartzScreen->displayIDs[0];
    if (XQuartzShieldingWindowLevel == 0 && captureDisplay) {
        if (!X11ApplicationCanEnterRandR())
            return FALSE;
        CGCaptureAllDisplays();
        XQuartzShieldingWindowLevel = CGShieldingWindowLevel(); // 2147483630
        DEBUG_LOG("Display captured.  ShieldWindowID: %u, Shield level: %d\n",
                  CGShieldingWindowID(screenId), XQuartzShieldingWindowLevel);
    }

    if (pQuartzScreen->currentMode.ref &&
        CFEqual(pMode->ref, pQuartzScreen->currentMode.ref)) {
        DEBUG_LOG("Requested RandR resolution matches current CG mode\n");
    }
    if (QuartzRandRSetCGMode(screenId, pMode)) {
        ignore_next_fake_mode_update = TRUE;
    }
    else {
        DEBUG_LOG("Error while requesting CG resolution change.\n");
        return FALSE;
    }

    /* If the client requested the fake rootless mode, switch to rootless.
     * Otherwise, force fullscreen mode.
     */
    QuartzSetRootless(pMode->refresh == FAKE_REFRESH_ROOTLESS);
    if (pMode->refresh != FAKE_REFRESH_ROOTLESS) {
        QuartzShowFullscreen(TRUE);
    }

    if (pQuartzScreen->currentMode.ref)
        CFRelease(pQuartzScreen->currentMode.ref);
    pQuartzScreen->currentMode = *pMode;
    if (pQuartzScreen->currentMode.ref)
        CFRetain(pQuartzScreen->currentMode.ref);

    if (XQuartzShieldingWindowLevel != 0 && !captureDisplay) {
        CGReleaseAllDisplays();
        XQuartzShieldingWindowLevel = 0;
    }

    return TRUE;
}

static int
QuartzRandRSetModeCallback(ScreenPtr pScreen,
                           QuartzModeInfoPtr pMode,
                           void *data)
{
    QuartzModeInfoPtr pReqMode = (QuartzModeInfoPtr)data;

    if (!QuartzRandRModesEqual(pMode, pReqMode))
        return CALLBACK_CONTINUE;  /* continue enumeration */

    DEBUG_LOG("Found a match for requested RandR resolution (%dx%d@@%d).\n",
              (int)pMode->width, (int)pMode->height, (int)pMode->refresh);

    if (QuartzRandRSetMode(pScreen, pMode, FALSE))
        return CALLBACK_SUCCESS;
    else
        return CALLBACK_ERROR;
}

static Bool
QuartzRandRGetInfo(ScreenPtr pScreen, Rotation *rotations)
{
    *rotations = RR_Rotate_0;  /* TODO: support rotation */

    return QuartzRandREnumerateModes(pScreen, QuartzRandRRegisterModeCallback,
                                     NULL);
}

static Bool
QuartzRandRSetConfig(ScreenPtr pScreen,
                     Rotation randr,
                     int rate,
                     RRScreenSizePtr pSize)
{
    QuartzScreenPtr pQuartzScreen = QUARTZ_PRIV(pScreen);
    QuartzModeInfo reqMode;

    reqMode.width = pSize->width;
    reqMode.height = pSize->height;
    reqMode.refresh = rate;

    /* Do not switch modes if requested mode is equal to current mode. */
    if (QuartzRandRModesEqual(&reqMode, &pQuartzScreen->currentMode))
        return TRUE;

    if (QuartzRandREnumerateModes(pScreen, QuartzRandRSetModeCallback,
                                  &reqMode)) {
        return TRUE;
    }

    DEBUG_LOG("Unable to find a matching config: %d x %d @@ %d\n",
              (int)reqMode.width, (int)reqMode.height,
              (int)reqMode.refresh);
    return FALSE;
}

static Bool
_QuartzRandRUpdateFakeModes(ScreenPtr pScreen)
{
    QuartzScreenPtr pQuartzScreen = QUARTZ_PRIV(pScreen);
    QuartzModeInfo activeMode;

    if (pQuartzScreen->displayCount > 0) {
        if (!QuartzRandRCopyCurrentModeInfo(pQuartzScreen->displayIDs[0],
                                            &activeMode)) {
            ErrorF("Unable to determine current display mode.\n");
            return FALSE;
        }
    }
    else {
        memset(&activeMode, 0, sizeof(activeMode));
        activeMode.width = 800;
        activeMode.height = 600;
        activeMode.refresh = 60;
    }

    if (pQuartzScreen->fullscreenMode.ref)
        CFRelease(pQuartzScreen->fullscreenMode.ref);
    if (pQuartzScreen->currentMode.ref)
        CFRelease(pQuartzScreen->currentMode.ref);

    if (pQuartzScreen->displayCount > 1) {
        activeMode.width = pScreen->width;
        activeMode.height = pScreen->height;
        if (XQuartzIsRootless)
            activeMode.height += aquaMenuBarHeight;
    }

    pQuartzScreen->fullscreenMode = activeMode;
    pQuartzScreen->fullscreenMode.refresh = FAKE_REFRESH_FULLSCREEN;

    pQuartzScreen->rootlessMode = activeMode;
    pQuartzScreen->rootlessMode.refresh = FAKE_REFRESH_ROOTLESS;
    pQuartzScreen->rootlessMode.height -= aquaMenuBarHeight;

    if (XQuartzIsRootless) {
        pQuartzScreen->currentMode = pQuartzScreen->rootlessMode;
    }
    else {
        pQuartzScreen->currentMode = pQuartzScreen->fullscreenMode;
    }

    /* This extra retain is for currentMode's copy.
     * fullscreen and rootless share a retain.
     */
    if (pQuartzScreen->currentMode.ref)
        CFRetain(pQuartzScreen->currentMode.ref);

    DEBUG_LOG("rootlessMode: %d x %d\n",
              (int)pQuartzScreen->rootlessMode.width,
              (int)pQuartzScreen->rootlessMode.height);
    DEBUG_LOG("fullscreenMode: %d x %d\n",
              (int)pQuartzScreen->fullscreenMode.width,
              (int)pQuartzScreen->fullscreenMode.height);
    DEBUG_LOG("currentMode: %d x %d\n", (int)pQuartzScreen->currentMode.width,
              (int)pQuartzScreen->currentMode.height);

    return TRUE;
}

Bool
QuartzRandRUpdateFakeModes(BOOL force_update)
{
    ScreenPtr pScreen = screenInfo.screens[0];

    if (ignore_next_fake_mode_update) {
        DEBUG_LOG(
            "Ignoring update request caused by RandR resolution change.\n");
        ignore_next_fake_mode_update = FALSE;
        return TRUE;
    }

    if (!_QuartzRandRUpdateFakeModes(pScreen))
        return FALSE;

    if (force_update)
        RRGetInfo(pScreen, TRUE);

    return TRUE;
}

Bool
QuartzRandRInit(ScreenPtr pScreen)
{
    rrScrPrivPtr pScrPriv;

    if (!RRScreenInit(pScreen)) return FALSE;
    if (!_QuartzRandRUpdateFakeModes(pScreen)) return FALSE;

    pScrPriv = rrGetScrPriv(pScreen);
    pScrPriv->rrGetInfo = QuartzRandRGetInfo;
    pScrPriv->rrSetConfig = QuartzRandRSetConfig;
    return TRUE;
}

void
QuartzRandRSetFakeRootless(void)
{
    int i;

    DEBUG_LOG("QuartzRandRSetFakeRootless called.\n");

    for (i = 0; i < screenInfo.numScreens; i++) {
        ScreenPtr pScreen = screenInfo.screens[i];
        QuartzScreenPtr pQuartzScreen = QUARTZ_PRIV(pScreen);

        QuartzRandRSetMode(pScreen, &pQuartzScreen->rootlessMode, TRUE);
    }
}

void
QuartzRandRSetFakeFullscreen(BOOL state)
{
    int i;

    DEBUG_LOG("QuartzRandRSetFakeFullscreen called.\n");

    for (i = 0; i < screenInfo.numScreens; i++) {
        ScreenPtr pScreen = screenInfo.screens[i];
        QuartzScreenPtr pQuartzScreen = QUARTZ_PRIV(pScreen);

        QuartzRandRSetMode(pScreen, &pQuartzScreen->fullscreenMode, TRUE);
    }

    QuartzShowFullscreen(state);
}

/* Toggle fullscreen mode.  If "fake" fullscreen is the current mode,
 * this will just show/hide the X11 windows.  If we are in a RandR fullscreen
 * mode, this will toggles us to the default fake mode and hide windows if
 * it is fullscreen
 */
void
QuartzRandRToggleFullscreen(void)
{
    ScreenPtr pScreen = screenInfo.screens[0];
    QuartzScreenPtr pQuartzScreen = QUARTZ_PRIV(pScreen);

    if (pQuartzScreen->currentMode.ref == NULL) {
        ErrorF(
            "Ignoring QuartzRandRToggleFullscreen because don't have a current mode set.\n");
    }
    else if (pQuartzScreen->currentMode.refresh == FAKE_REFRESH_ROOTLESS) {
        ErrorF(
            "Ignoring QuartzRandRToggleFullscreen because we are in rootless mode.\n");
    }
    else if (pQuartzScreen->currentMode.refresh == FAKE_REFRESH_FULLSCREEN) {
        /* Legacy fullscreen mode.  Hide/Show */
        QuartzShowFullscreen(!XQuartzFullscreenVisible);
    }
    else {
        /* RandR fullscreen mode.  Return to default mode and hide if it is fullscreen. */
        if (XQuartzRootlessDefault) {
            QuartzRandRSetFakeRootless();
        }
        else {
            QuartzRandRSetFakeFullscreen(FALSE);
        }
    }
}
@


1.4
log
@Update to xserver 1.11.2
@
text
@d6 1
a6 1
 *               2010-2011 Apple Inc.
d56 1
a56 1
#define FAKE_REFRESH_ROOTLESS 1
d59 2
a60 2
#define DEFAULT_REFRESH  60
#define kDisplayModeUsableFlags  (kDisplayModeValidFlag | kDisplayModeSafeFlag)
d62 3
a64 3
#define CALLBACK_SUCCESS 0
#define CALLBACK_CONTINUE 1
#define CALLBACK_ERROR -1
d71 3
a73 1
static long getDictLong (CFDictionaryRef dictRef, CFStringRef key) {
d76 1
a76 1
    CFNumberRef numRef = (CFNumberRef) CFDictionaryGetValue(dictRef, key);
d85 3
a87 1
static double getDictDouble (CFDictionaryRef dictRef, CFStringRef key) {
d90 1
a90 1
    CFNumberRef numRef = (CFNumberRef) CFDictionaryGetValue(dictRef, key);
d99 8
a106 5
static void QuartzRandRGetModeInfo (CFDictionaryRef modeRef,
                                    QuartzModeInfoPtr pMode) {
    pMode->width = (size_t) getDictLong(modeRef, kCGDisplayWidth);
    pMode->height = (size_t) getDictLong(modeRef, kCGDisplayHeight);
    pMode->refresh = (int)(getDictDouble(modeRef, kCGDisplayRefreshRate) + 0.5);
d113 4
a116 2
static Bool QuartzRandRCopyCurrentModeInfo (CGDirectDisplayID screenId,
                                           QuartzModeInfoPtr pMode) {
d127 5
a131 3
static Bool QuartzRandRSetCGMode (CGDirectDisplayID screenId,
                                QuartzModeInfoPtr pMode) {
    CFDictionaryRef modeRef = (CFDictionaryRef) pMode->ref;
d135 5
a139 3
static Bool QuartzRandREnumerateModes (ScreenPtr pScreen,
                                       QuartzModeCallback callback,
                                       void *data) {
d144 1
a144 1
    if(pQuartzScreen->displayIDs) {
d162 1
a162 1
            modeRef = (CFDictionaryRef) CFArrayGetValueAtIndex(modes, i);
d166 1
a166 1
            if (((unsigned long) getDictLong(modeRef, kCGDisplayIOFlags) &
d184 12
a195 9
    switch(callback(pScreen, &pQuartzScreen->rootlessMode, data)) {
        case CALLBACK_SUCCESS:
            return TRUE;
        case CALLBACK_ERROR:
            return FALSE;
        case CALLBACK_CONTINUE:
            retval = TRUE;
        default:
            break;
d198 12
a209 9
    switch(callback(pScreen, &pQuartzScreen->fullscreenMode, data)) {
        case CALLBACK_SUCCESS:
            return TRUE;
        case CALLBACK_ERROR:
            return FALSE;
        case CALLBACK_CONTINUE:
            retval = TRUE;
        default:
            break;
d217 4
a220 2
static void QuartzRandRGetModeInfo (CGDisplayModeRef modeRef,
                                    QuartzModeInfoPtr pMode) {
d223 1
a223 1
    pMode->refresh = (int) (CGDisplayModeGetRefreshRate(modeRef) + 0.5);
d230 4
a233 2
static Bool QuartzRandRCopyCurrentModeInfo (CGDirectDisplayID screenId,
                                            QuartzModeInfoPtr pMode) {
d243 5
a247 3
static Bool QuartzRandRSetCGMode (CGDirectDisplayID screenId,
                                QuartzModeInfoPtr pMode) {
    CGDisplayModeRef modeRef = (CGDisplayModeRef) pMode->ref;
d251 2
a252 1
    return (CGDisplaySetDisplayMode(screenId, modeRef, NULL) == kCGErrorSuccess);
d255 5
a259 3
static Bool QuartzRandREnumerateModes (ScreenPtr pScreen,
                                       QuartzModeCallback callback,
                                       void *data) {
d264 1
a264 1
    if(pQuartzScreen->displayIDs) {
d286 1
a286 1
            modeRef = (CGDisplayModeRef) CFArrayGetValueAtIndex(modes, i);
d290 2
a291 1
            if ((CGDisplayModeGetIOFlags(modeRef) & kDisplayModeUsableFlags) !=
d305 2
a306 1
            } else if (cb == CALLBACK_SUCCESS) {
d310 2
a311 1
            } else if (cb == CALLBACK_ERROR) {
d322 12
a333 9
    switch(callback(pScreen, &pQuartzScreen->rootlessMode, data)) {
        case CALLBACK_SUCCESS:
            return TRUE;
        case CALLBACK_ERROR:
            return FALSE;
        case CALLBACK_CONTINUE:
            retval = TRUE;
        default:
            break;
d336 12
a347 9
    switch(callback(pScreen, &pQuartzScreen->fullscreenMode, data)) {
        case CALLBACK_SUCCESS:
            return TRUE;
        case CALLBACK_ERROR:
            return FALSE;
        case CALLBACK_CONTINUE:
            retval = TRUE;
        default:
            break;
d355 4
a358 3

static Bool QuartzRandRModesEqual (QuartzModeInfoPtr pMode1,
                                   QuartzModeInfoPtr pMode2) {
d364 4
a367 2
static Bool QuartzRandRRegisterMode (ScreenPtr pScreen,
                                     QuartzModeInfoPtr pMode) {
d369 2
a370 1
    Bool isCurrentMode = QuartzRandRModesEqual(&pQuartzScreen->currentMode, pMode);
d373 3
a375 1
    pMode->pSize = RRRegisterSize(pScreen, pMode->width, pMode->height, pScreen->mmWidth, pScreen->mmHeight);
d381 2
a382 1
            RRSetCurrentConfig(pScreen, RR_Rotate_0, pMode->refresh, pMode->pSize);
d389 6
a394 4
static int QuartzRandRRegisterModeCallback (ScreenPtr pScreen,
                                        QuartzModeInfoPtr pMode,
                                        void *data __unused) {
    if(QuartzRandRRegisterMode(pScreen, pMode)) {
d396 2
a397 1
    } else {
d402 4
a405 1
static Bool QuartzRandRSetMode(ScreenPtr pScreen, QuartzModeInfoPtr pMode, BOOL doRegister) {
d407 3
a409 1
    Bool captureDisplay = (pMode->refresh != FAKE_REFRESH_FULLSCREEN && pMode->refresh != FAKE_REFRESH_ROOTLESS);
d412 1
a412 1
    if(pQuartzScreen->displayIDs == NULL)
d416 2
a417 2
    if(XQuartzShieldingWindowLevel == 0 && captureDisplay) {
        if(!X11ApplicationCanEnterRandR())
d425 2
a426 1
    if (pQuartzScreen->currentMode.ref && CFEqual(pMode->ref, pQuartzScreen->currentMode.ref)) {
d428 2
a429 1
    } if (QuartzRandRSetCGMode(screenId, pMode)) {
d431 2
a432 1
    } else {
d445 1
a445 1
    if(pQuartzScreen->currentMode.ref)
d448 1
a448 1
    if(pQuartzScreen->currentMode.ref)
d450 2
a451 2
    
    if(XQuartzShieldingWindowLevel != 0 && !captureDisplay) {
d459 7
a465 5
static int QuartzRandRSetModeCallback (ScreenPtr pScreen,
                                       QuartzModeInfoPtr pMode,
                                       void *data) {
    QuartzModeInfoPtr pReqMode = (QuartzModeInfoPtr) data;
	
d469 2
a470 1
    DEBUG_LOG("Found a match for requested RandR resolution (%dx%d@@%d).\n", (int)pMode->width, (int)pMode->height, (int)pMode->refresh);
d472 1
a472 1
    if(QuartzRandRSetMode(pScreen, pMode, FALSE))
d478 3
a480 1
static Bool QuartzRandRGetInfo (ScreenPtr pScreen, Rotation *rotations) {
d483 2
a484 1
    return QuartzRandREnumerateModes(pScreen, QuartzRandRRegisterModeCallback, NULL);
d487 6
a492 4
static Bool QuartzRandRSetConfig (ScreenPtr           pScreen,
                                  Rotation            randr,
                                  int                 rate,
                                  RRScreenSizePtr     pSize) {
d503 3
a505 2
        
    if (QuartzRandREnumerateModes(pScreen, QuartzRandRSetModeCallback, &reqMode)) {
d508 4
a511 2
    
    DEBUG_LOG("Unable to find a matching config: %d x %d @@ %d\n", (int)reqMode.width, (int)reqMode.height, (int)reqMode.refresh);
d515 3
a517 1
static Bool _QuartzRandRUpdateFakeModes (ScreenPtr pScreen) {
d521 3
a523 2
    if(pQuartzScreen->displayCount > 0) {
        if(!QuartzRandRCopyCurrentModeInfo(pQuartzScreen->displayIDs[0], &activeMode)) {
d527 2
a528 1
    } else {
d535 1
a535 1
    if(pQuartzScreen->fullscreenMode.ref)
d537 1
a537 1
    if(pQuartzScreen->currentMode.ref)
d540 1
a540 1
    if(pQuartzScreen->displayCount > 1) {
d543 1
a543 1
        if(XQuartzIsRootless)
d547 1
a547 1
    pQuartzScreen->fullscreenMode = activeMode; 
d554 1
a554 1
    if(XQuartzIsRootless) {
d556 2
a557 1
    } else {
d564 1
a564 1
    if(pQuartzScreen->currentMode.ref)
d566 10
a575 5
    
    DEBUG_LOG("rootlessMode: %d x %d\n", (int)pQuartzScreen->rootlessMode.width, (int)pQuartzScreen->rootlessMode.height);
    DEBUG_LOG("fullscreenMode: %d x %d\n", (int)pQuartzScreen->fullscreenMode.width, (int)pQuartzScreen->fullscreenMode.height);
    DEBUG_LOG("currentMode: %d x %d\n", (int)pQuartzScreen->currentMode.width, (int)pQuartzScreen->currentMode.height);
    
d579 3
a581 1
Bool QuartzRandRUpdateFakeModes (BOOL force_update) {
d583 4
a586 3
    
    if(ignore_next_fake_mode_update) {
        DEBUG_LOG("Ignoring update request caused by RandR resolution change.\n");
d590 2
a591 2
    
    if(!_QuartzRandRUpdateFakeModes(pScreen))
d593 2
a594 2
    
    if(force_update)
d600 7
a606 5
Bool QuartzRandRInit (ScreenPtr pScreen) {
    rrScrPrivPtr    pScrPriv;
    
    if (!RRScreenInit (pScreen)) return FALSE;
    if (!_QuartzRandRUpdateFakeModes (pScreen)) return FALSE;
d614 3
a616 1
void QuartzRandRSetFakeRootless (void) {
d618 1
a618 1
    
d620 2
a621 2
    
    for (i=0; i < screenInfo.numScreens; i++) {
d629 3
a631 1
void QuartzRandRSetFakeFullscreen (BOOL state) {
d635 2
a636 2
    
    for (i=0; i < screenInfo.numScreens; i++) {
d642 1
a642 1
    
d651 3
a653 1
void QuartzRandRToggleFullscreen (void) {
d658 8
a665 4
        ErrorF("Ignoring QuartzRandRToggleFullscreen because don't have a current mode set.\n");
    } else if (pQuartzScreen->currentMode.refresh == FAKE_REFRESH_ROOTLESS) {
        ErrorF("Ignoring QuartzRandRToggleFullscreen because we are in rootless mode.\n");
    } else if (pQuartzScreen->currentMode.refresh == FAKE_REFRESH_FULLSCREEN) {
d668 2
a669 1
    } else {
d671 1
a671 1
        if(XQuartzRootlessDefault) {
d673 2
a674 1
        } else {
d677 1
a677 1
    }    
@


1.3
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d6 1
a6 1
 *               2010      Apple Inc.
d127 1
a127 6
    CFDictionaryRef curModeRef, modeRef;
    long curBpp;
    CFArrayRef modes;
    QuartzModeInfo modeInfo;
    int i;
    BOOL retval = FALSE;
a128 1
    CGDirectDisplayID screenId = pQuartzScreen->displayIDs[0];
d130 13
a142 4
    curModeRef = CGDisplayCurrentMode(screenId);
    if (!curModeRef)
        return FALSE;
    curBpp = getDictLong(curModeRef, kCGDisplayBitsPerPixel);
d144 2
a145 23
    modes = CGDisplayAvailableModes(screenId);
    if (!modes)
        return FALSE;
    for (i = 0; i < CFArrayGetCount(modes); i++) {
        int cb;
        modeRef = (CFDictionaryRef) CFArrayGetValueAtIndex(modes, i);

        /* Skip modes that are not usable on the current display or have a
           different pixel encoding than the current mode. */
        if (((unsigned long) getDictLong(modeRef, kCGDisplayIOFlags) &
             kDisplayModeUsableFlags) != kDisplayModeUsableFlags)
            continue;
        if (getDictLong(modeRef, kCGDisplayBitsPerPixel) != curBpp)
            continue;

        QuartzRandRGetModeInfo(modeRef, &modeInfo);
        modeInfo.ref = (void *)modeRef;
        cb = callback(pScreen, &modeInfo, data);
        if (cb == CALLBACK_CONTINUE)
            retval = TRUE;
        else if (cb == CALLBACK_SUCCESS)
            return TRUE;
        else if (cb == CALLBACK_ERROR)
d147 22
a231 6
    CGDisplayModeRef curModeRef, modeRef;
    CFStringRef curPixelEnc, pixelEnc;
    CFComparisonResult pixelEncEqual;
    CFArrayRef modes;
    QuartzModeInfo modeInfo;
    int i;
d233 1
d235 9
a243 2
    QuartzScreenPtr pQuartzScreen = QUARTZ_PRIV(pScreen);
    CGDirectDisplayID screenId = pQuartzScreen->displayIDs[0];
d245 5
a249 5
    curModeRef = CGDisplayCopyDisplayMode(screenId);
    if (!curModeRef)
        return FALSE;
    curPixelEnc = CGDisplayModeCopyPixelEncoding(curModeRef);
    CGDisplayModeRelease(curModeRef);
d251 2
a252 31
    modes = CGDisplayCopyAllDisplayModes(screenId, NULL);
    if (!modes) {
        CFRelease(curPixelEnc);
        return FALSE;
    }
    for (i = 0; i < CFArrayGetCount(modes); i++) {
        int cb;
        modeRef = (CGDisplayModeRef) CFArrayGetValueAtIndex(modes, i);

        /* Skip modes that are not usable on the current display or have a
           different pixel encoding than the current mode. */
        if ((CGDisplayModeGetIOFlags(modeRef) & kDisplayModeUsableFlags) !=
            kDisplayModeUsableFlags)
            continue;
        pixelEnc = CGDisplayModeCopyPixelEncoding(modeRef);
        pixelEncEqual = CFStringCompare(pixelEnc, curPixelEnc, 0);
        CFRelease(pixelEnc);
        if (pixelEncEqual != kCFCompareEqualTo)
            continue;

        QuartzRandRGetModeInfo(modeRef, &modeInfo);
        modeInfo.ref = modeRef;
        cb = callback(pScreen, &modeInfo, data);
        if (cb == CALLBACK_CONTINUE) {
            retval = TRUE;
        } else if (cb == CALLBACK_SUCCESS) {
            CFRelease(modes);
            CFRelease(curPixelEnc);
            return TRUE;
        } else if (cb == CALLBACK_ERROR) {
            CFRelease(modes);
d256 33
a290 3
    CFRelease(modes);
    CFRelease(curPixelEnc);

a356 1
    CGDirectDisplayID screenId = pQuartzScreen->displayIDs[0];
d358 4
d363 1
d393 2
a394 1
    CFRetain(pQuartzScreen->currentMode.ref);
a420 2
    QuartzScreenPtr pQuartzScreen = QUARTZ_PRIV(pScreen);

a422 3
    if (pQuartzScreen->displayCount == 0)
        return FALSE;

a436 3
    if (pQuartzScreen->displayCount == 0)
        return FALSE;

d451 13
a468 4
        
    if (!QuartzRandRCopyCurrentModeInfo(pQuartzScreen->displayIDs[0],
                                        &pQuartzScreen->fullscreenMode))
        return FALSE;
d470 3
a472 3
    if (pQuartzScreen->displayCount > 1) {
        pQuartzScreen->fullscreenMode.width = pScreen->width;
        pQuartzScreen->fullscreenMode.height = pScreen->height;
d474 1
a474 1
            pQuartzScreen->fullscreenMode.height += aquaMenuBarHeight;
d477 1
d480 1
a480 1
    pQuartzScreen->rootlessMode = pQuartzScreen->fullscreenMode;
d493 2
a494 1
    CFRetain(pQuartzScreen->currentMode.ref);
@


1.2
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d43 2
d351 10
d384 5
a414 10

    if (pQuartzScreen->displayCount > 1) {
        /* RandR operations are not well-defined for an X11 screen spanning
           multiple CG displays. Create two entries for the current virtual
           resolution including/excluding the menu bar. */

        QuartzRandRRegisterMode(pScreen, &pQuartzScreen->rootlessMode);
        QuartzRandRRegisterMode(pScreen, &pQuartzScreen->fullscreenMode);
        return TRUE;
    }
@


1.1
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d441 4
a444 5
    if (pQuartzScreen->displayCount == 1) {
        if(pQuartzScreen->fullscreenMode.ref)
            CFRelease(pQuartzScreen->fullscreenMode.ref);
        if(pQuartzScreen->currentMode.ref)
            CFRelease(pQuartzScreen->currentMode.ref);
d446 3
a448 3
        if (!QuartzRandRCopyCurrentModeInfo(pQuartzScreen->displayIDs[0],
                                            &pQuartzScreen->fullscreenMode))
            return FALSE;
d450 1
a450 2
        CFRetain(pQuartzScreen->fullscreenMode.ref);  /* This extra retain is for currentMode's copy */
    } else {
d468 5
@

