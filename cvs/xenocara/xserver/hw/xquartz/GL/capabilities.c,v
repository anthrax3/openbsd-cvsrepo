head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.14
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.12
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.10
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.8
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.53;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.09.06.19.44.33;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@/*
 * Copyright (c) 2008-2012 Apple Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#define Cursor Mac_Cursor
#define BOOL   Mac_BOOL
#include <OpenGL/OpenGL.h>
#include <OpenGL/gl.h>
#include <OpenGL/glu.h>
#include <OpenGL/glext.h>
#include <ApplicationServices/ApplicationServices.h>
#undef Cursor
#undef BOOL

#include "capabilities.h"

#include "os.h"

static void
handleBufferModes(struct glCapabilitiesConfig *c, GLint bufferModes)
{
    if (bufferModes & kCGLStereoscopicBit) {
        c->stereo = true;
    }

    if (bufferModes & kCGLDoubleBufferBit) {
        c->buffers = 2;
    }
    else {
        c->buffers = 1;
    }
}

static void
handleStencilModes(struct glCapabilitiesConfig *c, GLint smodes)
{
    int offset = 0;

    if (kCGL0Bit & smodes)
        c->stencil_bit_depths[offset++] = 0;

    if (kCGL1Bit & smodes)
        c->stencil_bit_depths[offset++] = 1;

    if (kCGL2Bit & smodes)
        c->stencil_bit_depths[offset++] = 2;

    if (kCGL3Bit & smodes)
        c->stencil_bit_depths[offset++] = 3;

    if (kCGL4Bit & smodes)
        c->stencil_bit_depths[offset++] = 4;

    if (kCGL5Bit & smodes)
        c->stencil_bit_depths[offset++] = 5;

    if (kCGL6Bit & smodes)
        c->stencil_bit_depths[offset++] = 6;

    if (kCGL8Bit & smodes)
        c->stencil_bit_depths[offset++] = 8;

    if (kCGL10Bit & smodes)
        c->stencil_bit_depths[offset++] = 10;

    if (kCGL12Bit & smodes)
        c->stencil_bit_depths[offset++] = 12;

    if (kCGL16Bit & smodes)
        c->stencil_bit_depths[offset++] = 16;

    if (kCGL24Bit & smodes)
        c->stencil_bit_depths[offset++] = 24;

    if (kCGL32Bit & smodes)
        c->stencil_bit_depths[offset++] = 32;

    if (kCGL48Bit & smodes)
        c->stencil_bit_depths[offset++] = 48;

    if (kCGL64Bit & smodes)
        c->stencil_bit_depths[offset++] = 64;

    if (kCGL96Bit & smodes)
        c->stencil_bit_depths[offset++] = 96;

    if (kCGL128Bit & smodes)
        c->stencil_bit_depths[offset++] = 128;

    assert(offset < GLCAPS_STENCIL_BIT_DEPTH_BUFFERS);

    c->total_stencil_bit_depths = offset;
}

static int
handleColorAndAccumulation(struct glColorBufCapabilities *c,
                           GLint cmodes, int forAccum)
{
    int offset = 0;

    /*1*/
    if (kCGLRGB444Bit & cmodes) {
        c[offset].r = 4;
        c[offset].g = 4;
        c[offset].b = 4;
        ++offset;
    }

    /*2*/
    if (kCGLARGB4444Bit & cmodes) {
        c[offset].a = 4;
        c[offset].r = 4;
        c[offset].g = 4;
        c[offset].b = 4;
        c[offset].is_argb = true;
        ++offset;
    }

    /*3*/
    if (kCGLRGB444A8Bit & cmodes) {
        c[offset].r = 4;
        c[offset].g = 4;
        c[offset].b = 4;
        c[offset].a = 8;
        ++offset;
    }

    /*4*/
    if (kCGLRGB555Bit & cmodes) {
        c[offset].r = 5;
        c[offset].g = 5;
        c[offset].b = 5;
        ++offset;
    }

    /*5*/
    if (kCGLARGB1555Bit & cmodes) {
        c[offset].a = 1;
        c[offset].r = 5;
        c[offset].g = 5;
        c[offset].b = 5;
        c[offset].is_argb = true;
        ++offset;
    }

    /*6*/
    if (kCGLRGB555A8Bit & cmodes) {
        c[offset].r = 5;
        c[offset].g = 5;
        c[offset].b = 5;
        c[offset].a = 8;
        ++offset;
    }

    /*7*/
    if (kCGLRGB565Bit & cmodes) {
        c[offset].r = 5;
        c[offset].g = 6;
        c[offset].b = 5;
        ++offset;
    }

    /*8*/
    if (kCGLRGB565A8Bit & cmodes) {
        c[offset].r = 5;
        c[offset].g = 6;
        c[offset].b = 5;
        c[offset].a = 8;
        ++offset;
    }

    /*9*/
    if (kCGLRGB888Bit & cmodes) {
        c[offset].r = 8;
        c[offset].g = 8;
        c[offset].b = 8;
        ++offset;
    }

    /*10*/
    if (kCGLARGB8888Bit & cmodes) {
        c[offset].a = 8;
        c[offset].r = 8;
        c[offset].g = 8;
        c[offset].b = 8;
        c[offset].is_argb = true;
        ++offset;
    }

    /*11*/
    if (kCGLRGB888A8Bit & cmodes) {
        c[offset].r = 8;
        c[offset].g = 8;
        c[offset].b = 8;
        c[offset].a = 8;
        ++offset;
    }

    if (forAccum) {
        //#if 0
        /* FIXME
         * Disable this path, because some part of libGL, X, or Xplugin
         * doesn't work with sizes greater than 8.
         * When this is enabled and visuals are chosen using depths
         * such as 16, the result is that the windows don't redraw
         * and are often white, until a resize.
         */

        /*12*/
        if (kCGLRGB101010Bit & cmodes) {
            c[offset].r = 10;
            c[offset].g = 10;
            c[offset].b = 10;
            ++offset;
        }

        /*13*/
        if (kCGLARGB2101010Bit & cmodes) {
            c[offset].a = 2;
            c[offset].r = 10;
            c[offset].g = 10;
            c[offset].b = 10;
            c[offset].is_argb = true;
            ++offset;
        }

        /*14*/
        if (kCGLRGB101010_A8Bit & cmodes) {
            c[offset].r = 10;
            c[offset].g = 10;
            c[offset].b = 10;
            c[offset].a = 8;
            ++offset;
        }

        /*15*/
        if (kCGLRGB121212Bit & cmodes) {
            c[offset].r = 12;
            c[offset].g = 12;
            c[offset].b = 12;
            ++offset;
        }

        /*16*/
        if (kCGLARGB12121212Bit & cmodes) {
            c[offset].a = 12;
            c[offset].r = 12;
            c[offset].g = 12;
            c[offset].b = 12;
            c[offset].is_argb = true;
            ++offset;
        }

        /*17*/
        if (kCGLRGB161616Bit & cmodes) {
            c[offset].r = 16;
            c[offset].g = 16;
            c[offset].b = 16;
            ++offset;
        }

        /*18*/
        if (kCGLRGBA16161616Bit & cmodes) {
            c[offset].r = 16;
            c[offset].g = 16;
            c[offset].b = 16;
            c[offset].a = 16;
            ++offset;
        }
    }
    //#endif

    /* FIXME should we handle the floating point color modes, and if so, how? */

    return offset;
}

static void
handleColorModes(struct glCapabilitiesConfig *c, GLint cmodes)
{
    c->total_color_buffers = handleColorAndAccumulation(c->color_buffers,
                                                        cmodes, 0);

    assert(c->total_color_buffers < GLCAPS_COLOR_BUFFERS);
}

static void
handleAccumulationModes(struct glCapabilitiesConfig *c, GLint cmodes)
{
    c->total_accum_buffers = handleColorAndAccumulation(c->accum_buffers,
                                                        cmodes, 1);
    assert(c->total_accum_buffers < GLCAPS_COLOR_BUFFERS);
}

static void
handleDepthModes(struct glCapabilitiesConfig *c, GLint dmodes)
{
    int offset = 0;
#define DEPTH(flag, value) do { \
        if (dmodes & flag) { \
            c->depth_buffers[offset++] = value; \
        } \
} while (0)

    /*1*/
    DEPTH(kCGL0Bit, 0);
    /*2*/
    DEPTH(kCGL1Bit, 1);
    /*3*/
    DEPTH(kCGL2Bit, 2);
    /*4*/
    DEPTH(kCGL3Bit, 3);
    /*5*/
    DEPTH(kCGL4Bit, 4);
    /*6*/
    DEPTH(kCGL5Bit, 5);
    /*7*/
    DEPTH(kCGL6Bit, 6);
    /*8*/
    DEPTH(kCGL8Bit, 8);
    /*9*/
    DEPTH(kCGL10Bit, 10);
    /*10*/
    DEPTH(kCGL12Bit, 12);
    /*11*/
    DEPTH(kCGL16Bit, 16);
    /*12*/
    DEPTH(kCGL24Bit, 24);
    /*13*/
    DEPTH(kCGL32Bit, 32);
    /*14*/
    DEPTH(kCGL48Bit, 48);
    /*15*/
    DEPTH(kCGL64Bit, 64);
    /*16*/
    DEPTH(kCGL96Bit, 96);
    /*17*/
    DEPTH(kCGL128Bit, 128);

#undef DEPTH

    c->total_depth_buffer_depths = offset;
    assert(c->total_depth_buffer_depths < GLCAPS_DEPTH_BUFFERS);
}

/* Return non-zero if an error occured. */
static CGLError
handleRendererDescriptions(CGLRendererInfoObj info, GLint r,
                           struct glCapabilitiesConfig *c)
{
    CGLError err;
    GLint accelerated = 0, flags = 0, aux = 0, samplebufs = 0, samples = 0;

    err = CGLDescribeRenderer(info, r, kCGLRPAccelerated, &accelerated);

    if (err)
        return err;

    c->accelerated = accelerated;

    /* Buffering modes: single/double, stereo */
    err = CGLDescribeRenderer(info, r, kCGLRPBufferModes, &flags);

    if (err)
        return err;

    handleBufferModes(c, flags);

    /* AUX buffers */
    err = CGLDescribeRenderer(info, r, kCGLRPMaxAuxBuffers, &aux);

    if (err)
        return err;

    c->aux_buffers = aux;

    /* Depth buffer size */
    err = CGLDescribeRenderer(info, r, kCGLRPDepthModes, &flags);

    if (err)
        return err;

    handleDepthModes(c, flags);

    /* Multisample buffers */
    err = CGLDescribeRenderer(info, r, kCGLRPMaxSampleBuffers, &samplebufs);

    if (err)
        return err;

    c->multisample_buffers = samplebufs;

    /* Multisample samples per multisample buffer */
    err = CGLDescribeRenderer(info, r, kCGLRPMaxSamples, &samples);

    if (err)
        return err;

    c->multisample_samples = samples;

    /* Stencil bit depths */
    err = CGLDescribeRenderer(info, r, kCGLRPStencilModes, &flags);

    if (err)
        return err;

    handleStencilModes(c, flags);

    /* Color modes (RGB/RGBA depths supported */
    err = CGLDescribeRenderer(info, r, kCGLRPColorModes, &flags);

    if (err)
        return err;

    handleColorModes(c, flags);

    err = CGLDescribeRenderer(info, r, kCGLRPAccumModes, &flags);

    if (err)
        return err;

    handleAccumulationModes(c, flags);

    return kCGLNoError;
}

static void
initCapabilities(struct glCapabilities *cap)
{
    cap->configurations = NULL;
    cap->total_configurations = 0;
}

static void
initConfig(struct glCapabilitiesConfig *c)
{
    int i;

    c->accelerated = false;
    c->stereo = false;
    c->aux_buffers = 0;
    c->buffers = 0;

    c->total_depth_buffer_depths = 0;

    for (i = 0; i < GLCAPS_DEPTH_BUFFERS; ++i) {
        c->depth_buffers[i] = GLCAPS_INVALID_DEPTH_VALUE;
    }

    c->multisample_buffers = 0;
    c->multisample_samples = 0;

    c->total_stencil_bit_depths = 0;

    for (i = 0; i < GLCAPS_STENCIL_BIT_DEPTH_BUFFERS; ++i) {
        c->stencil_bit_depths[i] = GLCAPS_INVALID_STENCIL_DEPTH;
    }

    c->total_color_buffers = 0;

    for (i = 0; i < GLCAPS_COLOR_BUFFERS; ++i) {
        c->color_buffers[i].r = c->color_buffers[i].g =
                                    c->color_buffers[i].b =
                                        c->color_buffers[i].a =
                                            GLCAPS_COLOR_BUF_INVALID_VALUE;
        c->color_buffers[i].is_argb = false;
    }

    c->total_accum_buffers = 0;

    for (i = 0; i < GLCAPS_COLOR_BUFFERS; ++i) {
        c->accum_buffers[i].r = c->accum_buffers[i].g =
                                    c->accum_buffers[i].b =
                                        c->accum_buffers[i].a =
                                            GLCAPS_COLOR_BUF_INVALID_VALUE;
        c->accum_buffers[i].is_argb = false;
    }

    c->next = NULL;
}

void
freeGlCapabilities(struct glCapabilities *cap)
{
    struct glCapabilitiesConfig *conf, *next;

    conf = cap->configurations;

    while (conf) {
        next = conf->next;
        free(conf);
        conf = next;
    }

    cap->configurations = NULL;
}

/*Return true if an error occured. */
bool
getGlCapabilities(struct glCapabilities *cap)
{
    CGLRendererInfoObj info;
    CGLError err;
    GLint numRenderers = 0, r;

    initCapabilities(cap);

    err = CGLQueryRendererInfo((GLuint) - 1, &info, &numRenderers);
    if (err) {
        ErrorF("CGLQueryRendererInfo error: %s\n", CGLErrorString(err));
        return err;
    }

    for (r = 0; r < numRenderers; r++) {
        struct glCapabilitiesConfig tmpconf, *conf;

        initConfig(&tmpconf);

        err = handleRendererDescriptions(info, r, &tmpconf);
        if (err) {
            ErrorF("handleRendererDescriptions returned error: %s\n",
                   CGLErrorString(
                       err));
            ErrorF("trying to continue...\n");
            continue;
        }

        conf = malloc(sizeof(*conf));
        if (NULL == conf) {
            FatalError("Unable to allocate memory for OpenGL capabilities\n");
        }

        /* Copy the struct. */
        *conf = tmpconf;

        /* Now link the configuration into the list. */
        conf->next = cap->configurations;
        cap->configurations = conf;
    }

    CGLDestroyRendererInfo(info);

    /* No error occured.  We are done. */
    return kCGLNoError;
}
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d23 4
@


1.3
log
@Update to xserver 1.11.2
@
text
@d2 1
a2 1
 * Copyright (c) 2008 Apple Inc.
d26 3
d34 2
a38 1
#define Cursor X_Cursor
a39 1
#undef Cursor
d41 5
a45 3
static void handleBufferModes(struct glCapabilitiesConfig *c, GLint bufferModes) {
    if(bufferModes & kCGLStereoscopicBit) {
	c->stereo = true;
d48 5
a52 4
    if(bufferModes & kCGLDoubleBufferBit) {
	c->buffers = 2;
    } else {
	c->buffers = 1;
d56 3
a58 1
static void handleStencilModes(struct glCapabilitiesConfig *c, GLint smodes) {
d60 51
a110 51
    
    if(kCGL0Bit & smodes)
	c->stencil_bit_depths[offset++] = 0;

    if(kCGL1Bit & smodes)
	c->stencil_bit_depths[offset++] = 1;

    if(kCGL2Bit & smodes)
	c->stencil_bit_depths[offset++] = 2;
    
    if(kCGL3Bit & smodes)
	c->stencil_bit_depths[offset++] = 3;

    if(kCGL4Bit & smodes)
	c->stencil_bit_depths[offset++] = 4;

    if(kCGL5Bit & smodes)
	c->stencil_bit_depths[offset++] = 5;
    
    if(kCGL6Bit & smodes)
	c->stencil_bit_depths[offset++] = 6;

    if(kCGL8Bit & smodes)
	c->stencil_bit_depths[offset++] = 8;

    if(kCGL10Bit & smodes)
	c->stencil_bit_depths[offset++] = 10;

    if(kCGL12Bit & smodes)
	c->stencil_bit_depths[offset++] = 12;

    if(kCGL16Bit & smodes)
	c->stencil_bit_depths[offset++] = 16;

    if(kCGL24Bit & smodes)
	c->stencil_bit_depths[offset++] = 24;

    if(kCGL32Bit & smodes)
	c->stencil_bit_depths[offset++] = 32;
    
    if(kCGL48Bit & smodes)
	c->stencil_bit_depths[offset++] = 48;
    
    if(kCGL64Bit & smodes)
	c->stencil_bit_depths[offset++] = 64;
    
    if(kCGL96Bit & smodes)
	c->stencil_bit_depths[offset++] = 96;
    
    if(kCGL128Bit & smodes)
	c->stencil_bit_depths[offset++] = 128;
d117 4
a120 2
static int handleColorAndAccumulation(struct glColorBufCapabilities *c, 
				       GLint cmodes, int forAccum) {
d122 1
a122 1
        
d124 5
a128 5
    if(kCGLRGB444Bit & cmodes) {
	c[offset].r = 4;
	c[offset].g = 4; 
	c[offset].b = 4;
	++offset;
d130 1
a130 1
    
d132 7
a138 7
    if(kCGLARGB4444Bit & cmodes) {
	c[offset].a = 4;
	c[offset].r = 4;
	c[offset].g = 4;
	c[offset].b = 4;
	c[offset].is_argb = true;
	++offset;
d140 1
a140 1
    
d142 6
a147 6
    if(kCGLRGB444A8Bit & cmodes) {
	c[offset].r = 4;
	c[offset].g = 4;
	c[offset].b = 4;
	c[offset].a = 8;
	++offset;
d151 5
a155 5
    if(kCGLRGB555Bit & cmodes) {
	c[offset].r = 5;
	c[offset].g = 5;
	c[offset].b = 5;
	++offset;
d159 7
a165 7
    if(kCGLARGB1555Bit & cmodes) {
	c[offset].a = 1;
	c[offset].r = 5;
	c[offset].g = 5;
	c[offset].b = 5;
	c[offset].is_argb = true;
	++offset;
d169 6
a174 6
    if(kCGLRGB555A8Bit & cmodes) {
	c[offset].r = 5;
	c[offset].g = 5; 
	c[offset].b = 5;
	c[offset].a = 8;
	++offset;
d178 5
a182 5
    if(kCGLRGB565Bit & cmodes) {
	c[offset].r = 5;
	c[offset].g = 6;
	c[offset].b = 5;
	++offset;
d186 6
a191 6
    if(kCGLRGB565A8Bit & cmodes) {
	c[offset].r = 5;
	c[offset].g = 6;
	c[offset].b = 5;
	c[offset].a = 8;
	++offset;
d195 5
a199 5
    if(kCGLRGB888Bit & cmodes) {
	c[offset].r = 8;
	c[offset].g = 8;
	c[offset].b = 8;
	++offset;
d203 7
a209 7
    if(kCGLARGB8888Bit & cmodes) {
	c[offset].a = 8;
	c[offset].r = 8;
	c[offset].g = 8;
	c[offset].b = 8;
	c[offset].is_argb = true;
	++offset;
d213 79
a291 24
    if(kCGLRGB888A8Bit & cmodes) {
	c[offset].r = 8;
	c[offset].g = 8;
	c[offset].b = 8;
	c[offset].a = 8;
	++offset;
    }

    if(forAccum) {
//#if 0
    /* FIXME
     * Disable this path, because some part of libGL, X, or Xplugin 
     * doesn't work with sizes greater than 8.
     * When this is enabled and visuals are chosen using depths
     * such as 16, the result is that the windows don't redraw
     * and are often white, until a resize.
     */

    /*12*/
    if(kCGLRGB101010Bit & cmodes) {
	c[offset].r = 10;
	c[offset].g = 10;
	c[offset].b = 10;
	++offset;
d293 1
d295 1
a295 26
    /*13*/
    if(kCGLARGB2101010Bit & cmodes) {
	c[offset].a = 2;
	c[offset].r = 10;
	c[offset].g = 10;
	c[offset].b = 10;
	c[offset].is_argb = true;
	++offset;
    }

    /*14*/
    if(kCGLRGB101010_A8Bit & cmodes) {
	c[offset].r = 10;
	c[offset].g = 10;
	c[offset].b = 10;
	c[offset].a = 8;
	++offset;
    }

    /*15*/
    if(kCGLRGB121212Bit & cmodes) {
	c[offset].r = 12;
	c[offset].g = 12;
	c[offset].b = 12;
	++offset;	
    }
a296 31
    /*16*/
    if(kCGLARGB12121212Bit & cmodes) {
	c[offset].a = 12;
	c[offset].r = 12;
	c[offset].g = 12;
	c[offset].b = 12;
	c[offset].is_argb = true;
	++offset;
    }

    /*17*/
    if(kCGLRGB161616Bit & cmodes) {
	c[offset].r = 16;
	c[offset].g = 16;
	c[offset].b = 16;
	++offset;
    }

    /*18*/
    if(kCGLRGBA16161616Bit & cmodes) {
	c[offset].r = 16;
	c[offset].g = 16;
	c[offset].b = 16;
	c[offset].a = 16;
	++offset;
    }
    }
//#endif

    /* FIXME should we handle the floating point color modes, and if so, how? */
      
d300 5
a305 4
static void handleColorModes(struct glCapabilitiesConfig *c, GLint cmodes) {
    c->total_color_buffers = handleColorAndAccumulation(c->color_buffers,
							cmodes, 0);
    
d309 3
a311 1
static void handleAccumulationModes(struct glCapabilitiesConfig *c, GLint cmodes) {
d313 1
a313 1
							cmodes, 1);
d317 3
a319 1
static void handleDepthModes(struct glCapabilitiesConfig *c, GLint dmodes) {
d321 5
a325 5
#define DEPTH(flag,value) do { \
	if(dmodes & flag) { \
	    c->depth_buffers[offset++] = value; \
	} \
    } while(0)
d369 4
a372 2
static CGLError handleRendererDescriptions(CGLRendererInfoObj info, GLint r, 
					   struct glCapabilitiesConfig *c) {
d376 4
a379 1
    err = CGLDescribeRenderer (info, r, kCGLRPAccelerated, &accelerated);
a380 3
    if(err)
	return err;
    
d386 3
a388 3
    if(err)
	return err;
    
d390 1
a390 1
    
d394 3
a396 3
    if(err)
	return err;
    
a398 1
    
d401 3
a403 3
    
    if(err)
	return err;
a406 1

d410 2
a411 2
    if(err)
	return err;
a413 1
    
d418 2
a419 2
    if(err)
	return err;
a422 1

d426 2
a427 4
    if(err)
	return err;

    handleStencilModes(c, flags);   
d429 1
d434 3
a436 3
    if(err)
	return err;
    
d441 2
a442 2
    if(err)
	return err;
d445 1
a445 1
    
d449 3
a451 1
static void initCapabilities(struct glCapabilities *cap) {
d456 3
a458 1
static void initConfig(struct glCapabilitiesConfig *c) {
d468 2
a469 2
    for(i = 0; i < GLCAPS_DEPTH_BUFFERS; ++i) {
	c->depth_buffers[i] = GLCAPS_INVALID_DEPTH_VALUE;
d477 2
a478 2
    for(i = 0; i < GLCAPS_STENCIL_BIT_DEPTH_BUFFERS; ++i) {
	c->stencil_bit_depths[i] = GLCAPS_INVALID_STENCIL_DEPTH;
d480 1
a480 1
   
d483 7
a489 6
    for(i = 0; i < GLCAPS_COLOR_BUFFERS; ++i) {
	c->color_buffers[i].r =	c->color_buffers[i].g =
	    c->color_buffers[i].b = c->color_buffers[i].a = 
	    GLCAPS_COLOR_BUF_INVALID_VALUE;
	c->color_buffers[i].is_argb = false;
     }
d493 6
a498 5
    for(i = 0; i < GLCAPS_COLOR_BUFFERS; ++i) {
	c->accum_buffers[i].r = c->accum_buffers[i].g =
	    c->accum_buffers[i].b = c->accum_buffers[i].a =
	    GLCAPS_COLOR_BUF_INVALID_VALUE;
	c->accum_buffers[i].is_argb = false;
d504 3
a506 1
void freeGlCapabilities(struct glCapabilities *cap) {
d508 1
a508 1
    
d511 4
a514 4
    while(conf) {
	next = conf->next;
	free(conf);
	conf = next;
d517 1
a517 1
    cap->configurations = NULL;    
d521 4
a524 2
bool getGlCapabilities(struct glCapabilities *cap) {
	CGLRendererInfoObj info;
d526 1
a526 1
	GLint numRenderers = 0, r;
d530 3
a532 3
	err = CGLQueryRendererInfo((GLuint)-1, &info, &numRenderers);
    if(err) {
	    ErrorF("CGLQueryRendererInfo error: %s\n", CGLErrorString(err));
d534 1
a534 1
	}
d536 2
a537 2
	for(r = 0; r < numRenderers; r++) {
	    struct glCapabilitiesConfig tmpconf, *conf;
d539 1
a539 1
	    initConfig(&tmpconf);
d541 5
a545 3
	    err = handleRendererDescriptions(info, r, &tmpconf);
	    if(err) {
            ErrorF("handleRendererDescriptions returned error: %s\n", CGLErrorString(err));
d548 1
a548 1
	    }
d550 12
a561 12
	    conf = malloc(sizeof(*conf));
	    if(NULL == conf) {
                FatalError("Unable to allocate memory for OpenGL capabilities\n");
	    }

	    /* Copy the struct. */
	    *conf = tmpconf;

	    /* Now link the configuration into the list. */
	    conf->next = cap->configurations;
	    cap->configurations = conf;
	}
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d510 1
a510 1
	    fprintf(stderr, "CGLQueryRendererInfo error: %s\n", CGLErrorString(err));
d521 2
a522 2
            fprintf(stderr, "handleRendererDescriptions returned error: %s\n", CGLErrorString(err));
            fprintf(stderr, "trying to continue...\n");
@


1.1
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d34 4
d110 1
a110 1
				       GLint cmodes) {
d211 3
a213 2
#if 0
    /* 
d282 2
a283 1
#endif
d293 1
a293 1
							cmodes);
d300 1
a300 1
							cmodes);
d434 1
a434 1
    return 0;
a499 2
enum { MAX_DISPLAYS = 3 };

d502 3
a504 4
    CGDirectDisplayID dspys[MAX_DISPLAYS];
    CGDisplayErr err;
    CGOpenGLDisplayMask displayMask;
    CGDisplayCount i, displayCount = 0;
d507 2
a508 2
    
    err = CGGetActiveDisplayList(MAX_DISPLAYS, dspys, &displayCount);
a509 13
	fprintf(stderr, "CGGetActiveDisplayList error: %s\n", CGLErrorString(err));
	return true;
    }
 
    for(i = 0; i < displayCount; ++i) {
        displayMask = CGDisplayIDToOpenGLDisplayMask(dspys[i]);
       
	CGLRendererInfoObj info;
	GLint numRenderers = 0, r, renderCount = 0;
	    
	err = CGLQueryRendererInfo(displayMask, &info, &numRenderers);

        if(err) {
d511 1
a511 2
	    fprintf(stderr, "trying to continue...\n");
	    continue;
a512 2
			
	CGLDescribeRenderer(info, 0, kCGLRPRendererCount, &renderCount);
d514 1
a514 2
	for(r = 0; r < renderCount; ++r) {
	    CGLError derr;
d519 5
a523 5
	    derr = handleRendererDescriptions(info, r, &tmpconf);
	    if(derr) {
		fprintf(stderr, "error: %s\n", CGLErrorString(derr));
		fprintf(stderr, "trying to continue...\n");
		continue;
d528 1
a528 2
		perror("malloc");
		abort();
d539 2
a540 3
    	CGLDestroyRendererInfo(info);
    }
    
d542 1
a542 1
    return false;
@

