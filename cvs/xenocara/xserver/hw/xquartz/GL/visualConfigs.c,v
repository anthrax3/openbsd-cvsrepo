head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.14
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.12
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.10
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.8
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.53;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.09.06.19.44.33;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@/*
 * Copyright (c) 2007, 2008 Apple Inc.
 * Copyright (c) 2004 Torrey T. Lyons. All Rights Reserved.
 * Copyright (c) 2002 Greg Parker. All Rights Reserved.
 *
 * Portions of this file are copied from Mesa's xf86glx.c,
 * which contains the following copyright:
 *
 * Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "dri.h"

#include <OpenGL/OpenGL.h>
#include <OpenGL/gl.h>
#include <OpenGL/glext.h>
#include <OpenGL/CGLContext.h>

#include <GL/glxproto.h>
#include <windowstr.h>
#include <resource.h>
#include <GL/glxint.h>
#include <GL/glxtokens.h>
#include <scrnintstr.h>
#include <glxserver.h>
#include <glxscreens.h>
#include <glxdrawable.h>
#include <glxcontext.h>
#include <glxext.h>
#include <glxutil.h>
#include <GL/internal/glcore.h>

#include "capabilities.h"
#include "visualConfigs.h"
#include "darwinfb.h"

/* Based originally on code from indirect.c which was based on code from i830_dri.c. */
__GLXconfig *__glXAquaCreateVisualConfigs(int *numConfigsPtr, int screenNumber) {
    int numConfigs = 0;
    __GLXconfig *visualConfigs, *c;
    struct glCapabilities caps;
    struct glCapabilitiesConfig *conf;
    int stereo, depth, aux, buffers, stencil, accum, color, msample;

    if(getGlCapabilities(&caps)) {
        ErrorF("error from getGlCapabilities()!\n");
        return NULL;
    }

    /*
     conf->stereo is 0 or 1, but we need at least 1 iteration of the loop,
     so we treat a true conf->stereo as 2.

     The depth size is 0 or 24.  Thus we do 2 iterations for that.

     conf->aux_buffers (when available/non-zero) result in 2 iterations instead of 1.

     conf->buffers indicates whether we have single or double buffering.

     conf->total_stencil_bit_depths

     conf->total_color_buffers indicates the RGB/RGBA color depths.

     conf->total_accum_buffers iterations for accum (with at least 1 if equal to 0)

     conf->total_depth_buffer_depths

     conf->multisample_buffers iterations (with at least 1 if equal to 0).  We add 1
     for the 0 multisampling config.

     */

    assert(NULL != caps.configurations);

    numConfigs = 0;

    for(conf = caps.configurations; conf; conf = conf->next) {
        if(conf->total_color_buffers <= 0)
            continue;

        numConfigs += (conf->stereo ? 2 : 1)
	    * (conf->aux_buffers ? 2 : 1)
	    * conf->buffers
	    * ((conf->total_stencil_bit_depths > 0) ? conf->total_stencil_bit_depths : 1)
	    * conf->total_color_buffers
	    * ((conf->total_accum_buffers > 0) ? conf->total_accum_buffers : 1)
	    * conf->total_depth_buffer_depths
	    * (conf->multisample_buffers + 1);
    }

    if(numConfigsPtr)
        *numConfigsPtr = numConfigs;

    visualConfigs = calloc(sizeof(*visualConfigs), numConfigs);

    if(NULL == visualConfigs) {
        ErrorF("xcalloc failure when allocating visualConfigs\n");
        freeGlCapabilities(&caps);
        return NULL;
    }

    c = visualConfigs; /* current buffer */
    for(conf = caps.configurations; conf; conf = conf->next) {
        for(stereo = 0; stereo < (conf->stereo ? 2 : 1); ++stereo) {
            for(aux = 0; aux < (conf->aux_buffers ? 2 : 1); ++aux) {
                for(buffers = 0; buffers < conf->buffers; ++buffers) {
                    for(stencil = 0; stencil < ((conf->total_stencil_bit_depths > 0) ?
                                                conf->total_stencil_bit_depths : 1); ++stencil) {
                        for(color = 0; color < conf->total_color_buffers; ++color) {
                            for(accum = 0; accum < ((conf->total_accum_buffers > 0) ?
                                                    conf->total_accum_buffers : 1); ++accum) {
                                for(depth = 0; depth < conf->total_depth_buffer_depths; ++depth) {
                                    for(msample = 0; msample < (conf->multisample_buffers + 1); ++msample) {

                                        // Global
                                        c->visualID = -1;
                                        c->visualType = GLX_TRUE_COLOR;
                                        c->next = c + 1;

                                        c->level = 0;
                                        c->indexBits = 0;

                                        if(conf->accelerated) {
                                            c->visualRating = GLX_NONE;
                                        } else {
                                            c->visualRating = GLX_SLOW_VISUAL_EXT;
                                        }

                                        c->transparentPixel = GLX_NONE;
                                        c->transparentRed = GLX_NONE;
                                        c->transparentGreen = GLX_NONE;
                                        c->transparentBlue = GLX_NONE;
                                        c->transparentAlpha = GLX_NONE;
                                        c->transparentIndex = GLX_NONE;

                                        c->visualSelectGroup = 0;

                                        c->swapMethod = GLX_SWAP_UNDEFINED_OML;

                                        // Stereo
                                        c->stereoMode = stereo ? TRUE : FALSE;

                                        // Aux buffers
                                        c->numAuxBuffers = aux ? conf->aux_buffers : 0;

                                        // Double Buffered
                                        c->doubleBufferMode = buffers ? TRUE : FALSE;

                                        // Stencil Buffer
                                        if(conf->total_stencil_bit_depths > 0) {
                                            c->stencilBits = conf->stencil_bit_depths[stencil];
                                        } else {
                                            c->stencilBits = 0;
                                        }

                                        // Color
                                        if(GLCAPS_COLOR_BUF_INVALID_VALUE != conf->color_buffers[color].a) {
                                            c->alphaBits = conf->color_buffers[color].a;
                                        } else {
                                            c->alphaBits = 0;
                                        }
                                        c->redBits   = conf->color_buffers[color].r;
                                        c->greenBits = conf->color_buffers[color].g;
                                        c->blueBits  = conf->color_buffers[color].b;

                                        c->rgbBits = c->alphaBits + c->redBits + c->greenBits + c->blueBits;

                                        c->alphaMask = AM_ARGB(c->alphaBits, c->redBits, c->greenBits, c->blueBits);
                                        c->redMask   = RM_ARGB(c->alphaBits, c->redBits, c->greenBits, c->blueBits);
                                        c->greenMask = GM_ARGB(c->alphaBits, c->redBits, c->greenBits, c->blueBits);
                                        c->blueMask  = BM_ARGB(c->alphaBits, c->redBits, c->greenBits, c->blueBits);

                                        // Accumulation Buffers
                                        if(conf->total_accum_buffers > 0) {
                                            c->accumRedBits = conf->accum_buffers[accum].r;
                                            c->accumGreenBits = conf->accum_buffers[accum].g;
                                            c->accumBlueBits = conf->accum_buffers[accum].b;
                                            if(GLCAPS_COLOR_BUF_INVALID_VALUE != conf->accum_buffers[accum].a) {
                                                c->accumAlphaBits = conf->accum_buffers[accum].a;
                                            } else {
                                                c->accumAlphaBits = 0;
                                            }
                                        } else {
                                            c->accumRedBits = 0;
                                            c->accumGreenBits = 0;
                                            c->accumBlueBits = 0;
                                            c->accumAlphaBits = 0;
                                        }

                                        // Depth
                                        c->depthBits = conf->depth_buffers[depth];

                                        // MultiSample
                                        if(msample > 0) {
                                            c->samples = conf->multisample_samples;
                                            c->sampleBuffers = conf->multisample_buffers;
                                        } else {
                                            c->samples = 0;
                                            c->sampleBuffers = 0;
                                        }

                                        /*
                                         * The Apple libGL supports GLXPixmaps and
                                         * GLXPbuffers in direct mode.
                                         */
                                        /* SGIX_fbconfig / GLX 1.3 */
                                        c->drawableType = GLX_WINDOW_BIT | GLX_PIXMAP_BIT | GLX_PBUFFER_BIT;
                                        c->renderType = GLX_RGBA_BIT;
                                        c->xRenderable = GL_TRUE;
                                        c->fbconfigID = -1;

                                        /* SGIX_pbuffer / GLX 1.3 */

                                        /*
                                         * The CGL layer provides a way of retrieving
                                         * the maximum pbuffer width/height, but only
                                         * if we create a context and call glGetIntegerv.
                                         *
                                         * The following values are from a test program
                                         * that does so.
                                         */
                                        c->maxPbufferWidth = 8192;
                                        c->maxPbufferHeight = 8192;
                                        c->maxPbufferPixels = /*Do we need this?*/ 0;
                                        /*
                                         * There is no introspection for this sort of thing
                                         * with CGL.  What should we do realistically?
                                         */
                                        c->optimalPbufferWidth = 0;
                                        c->optimalPbufferHeight = 0;

                                        /* EXT_texture_from_pixmap */
                                        c->bindToTextureRgb = 0;
                                        c->bindToTextureRgba = 0;
                                        c->bindToMipmapTexture = 0;
                                        c->bindToTextureTargets = 0;
                                        c->yInverted = 0;

                                        /* EXT_framebuffer_sRGB */
                                        c->sRGBCapable = GL_FALSE;

                                        c = c->next;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    (c-1)->next = NULL;

    if (c - visualConfigs != numConfigs) {
        FatalError("numConfigs calculation error in setVisualConfigs!  numConfigs is %d  i is %d\n", numConfigs, (int)(c - visualConfigs));
    }

    freeGlCapabilities(&caps);
    return visualConfigs;
}
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a142 2
                                        c->screen = screenNumber;

a144 1
                                        c->pixmapMode = 0; // TODO: What should this be?
d261 3
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d61 1
a61 3
__GLXconfig *
__glXAquaCreateVisualConfigs(int *numConfigsPtr, int screenNumber)
{
d68 1
a68 1
    if (getGlCapabilities(&caps)) {
d74 2
a75 2
       conf->stereo is 0 or 1, but we need at least 1 iteration of the loop,
       so we treat a true conf->stereo as 2.
d77 1
a77 1
       The depth size is 0 or 24.  Thus we do 2 iterations for that.
d79 1
a79 1
       conf->aux_buffers (when available/non-zero) result in 2 iterations instead of 1.
d81 1
a81 1
       conf->buffers indicates whether we have single or double buffering.
d83 1
a83 1
       conf->total_stencil_bit_depths
d85 1
a85 1
       conf->total_color_buffers indicates the RGB/RGBA color depths.
d87 1
a87 1
       conf->total_accum_buffers iterations for accum (with at least 1 if equal to 0)
d89 1
a89 1
       conf->total_depth_buffer_depths
d91 2
a92 2
       conf->multisample_buffers iterations (with at least 1 if equal to 0).  We add 1
       for the 0 multisampling config.
d100 2
a101 2
    for (conf = caps.configurations; conf; conf = conf->next) {
        if (conf->total_color_buffers <= 0)
d105 7
a111 9
                      * (conf->aux_buffers ? 2 : 1)
                      * conf->buffers
                      * ((conf->total_stencil_bit_depths >
                          0) ? conf->total_stencil_bit_depths : 1)
                      * conf->total_color_buffers
                      * ((conf->total_accum_buffers >
                          0) ? conf->total_accum_buffers : 1)
                      * conf->total_depth_buffer_depths
                      * (conf->multisample_buffers + 1);
d114 1
a114 1
    if (numConfigsPtr)
d119 1
a119 1
    if (NULL == visualConfigs) {
d126 11
a136 23
    for (conf = caps.configurations; conf; conf = conf->next) {
        for (stereo = 0; stereo < (conf->stereo ? 2 : 1); ++stereo) {
            for (aux = 0; aux < (conf->aux_buffers ? 2 : 1); ++aux) {
                for (buffers = 0; buffers < conf->buffers; ++buffers) {
                    for (stencil = 0;
                         stencil < ((conf->total_stencil_bit_depths > 0) ?
                                    conf->
                                    total_stencil_bit_depths : 1);
                         ++stencil) {
                        for (color = 0; color < conf->total_color_buffers;
                             ++color) {
                            for (accum = 0;
                                 accum < ((conf->total_accum_buffers > 0) ?
                                          conf->
                                          total_accum_buffers : 1);
                                 ++accum) {
                                for (depth = 0;
                                     depth < conf->total_depth_buffer_depths;
                                     ++depth) {
                                    for (msample = 0;
                                         msample <
                                         (conf->multisample_buffers + 1);
                                         ++msample) {
d149 1
a149 1
                                        if (conf->accelerated) {
d151 2
a152 4
                                        }
                                        else {
                                            c->visualRating =
                                                GLX_SLOW_VISUAL_EXT;
d164 1
a164 2
                                        c->swapMethod =
                                            GLX_SWAP_UNDEFINED_OML;
d170 1
a170 2
                                        c->numAuxBuffers =
                                            aux ? conf->aux_buffers : 0;
d173 1
a173 2
                                        c->doubleBufferMode =
                                            buffers ? TRUE : FALSE;
d176 3
a178 7
                                        if (conf->total_stencil_bit_depths >
                                            0) {
                                            c->stencilBits =
                                                conf->stencil_bit_depths[
                                                    stencil];
                                        }
                                        else {
d183 3
a185 6
                                        if (GLCAPS_COLOR_BUF_INVALID_VALUE !=
                                            conf->color_buffers[color].a) {
                                            c->alphaBits =
                                                conf->color_buffers[color].a;
                                        }
                                        else {
d188 10
a197 28
                                        c->redBits =
                                            conf->color_buffers[color].r;
                                        c->greenBits =
                                            conf->color_buffers[color].g;
                                        c->blueBits =
                                            conf->color_buffers[color].b;

                                        c->rgbBits = c->alphaBits +
                                                     c->redBits +
                                                     c->greenBits +
                                                     c->blueBits;

                                        c->alphaMask =
                                            AM_ARGB(c->alphaBits, c->redBits,
                                                    c->greenBits,
                                                    c->blueBits);
                                        c->redMask =
                                            RM_ARGB(c->alphaBits, c->redBits,
                                                    c->greenBits,
                                                    c->blueBits);
                                        c->greenMask =
                                            GM_ARGB(c->alphaBits, c->redBits,
                                                    c->greenBits,
                                                    c->blueBits);
                                        c->blueMask =
                                            BM_ARGB(c->alphaBits, c->redBits,
                                                    c->greenBits,
                                                    c->blueBits);
d200 7
a206 17
                                        if (conf->total_accum_buffers > 0) {
                                            c->accumRedBits =
                                                conf->accum_buffers[accum].r;
                                            c->accumGreenBits =
                                                conf->accum_buffers[accum].g;
                                            c->accumBlueBits =
                                                conf->accum_buffers[accum].b;
                                            if (
                                                GLCAPS_COLOR_BUF_INVALID_VALUE
                                                !=
                                                conf->accum_buffers[accum].a)
                                            {
                                                c->accumAlphaBits =
                                                    conf->accum_buffers[accum
                                                    ].a;
                                            }
                                            else {
d209 1
a209 2
                                        }
                                        else {
d217 1
a217 2
                                        c->depthBits =
                                            conf->depth_buffers[depth];
d220 4
a223 7
                                        if (msample > 0) {
                                            c->samples =
                                                conf->multisample_samples;
                                            c->sampleBuffers =
                                                conf->multisample_buffers;
                                        }
                                        else {
d233 1
a233 3
                                        c->drawableType = GLX_WINDOW_BIT |
                                                          GLX_PIXMAP_BIT |
                                                          GLX_PBUFFER_BIT;
d250 1
a250 2
                                        c->maxPbufferPixels =
                                            /*Do we need this?*/ 0;
d276 1
a276 1
    (c - 1)->next = NULL;
d279 1
a279 3
        FatalError(
            "numConfigs calculation error in setVisualConfigs!  numConfigs is %d  i is %d\n",
            numConfigs, (int)(c - visualConfigs));
@


1.4
log
@Update to xserver 1.11.2
@
text
@d61 3
a63 1
__GLXconfig *__glXAquaCreateVisualConfigs(int *numConfigsPtr, int screenNumber) {
d69 2
a70 2
    
    if(getGlCapabilities(&caps)) {
d74 1
a74 1
    
d76 20
a95 20
     conf->stereo is 0 or 1, but we need at least 1 iteration of the loop, 
     so we treat a true conf->stereo as 2.
     
     The depth size is 0 or 24.  Thus we do 2 iterations for that.
     
     conf->aux_buffers (when available/non-zero) result in 2 iterations instead of 1.
     
     conf->buffers indicates whether we have single or double buffering.
     
     conf->total_stencil_bit_depths
     
     conf->total_color_buffers indicates the RGB/RGBA color depths.
     
     conf->total_accum_buffers iterations for accum (with at least 1 if equal to 0) 
     
     conf->total_depth_buffer_depths 
     
     conf->multisample_buffers iterations (with at least 1 if equal to 0).  We add 1
     for the 0 multisampling config.
     
d97 1
a97 1
    
d99 1
a99 1
    
d101 3
a103 3
    
    for(conf = caps.configurations; conf; conf = conf->next) {
        if(conf->total_color_buffers <= 0)
d105 11
a115 9
        
        numConfigs += (conf->stereo ? 2 : 1) 
	    * (conf->aux_buffers ? 2 : 1) 
	    * conf->buffers
	    * ((conf->total_stencil_bit_depths > 0) ? conf->total_stencil_bit_depths : 1)
	    * conf->total_color_buffers
	    * ((conf->total_accum_buffers > 0) ? conf->total_accum_buffers : 1)
	    * conf->total_depth_buffer_depths
	    * (conf->multisample_buffers + 1);
d117 4
a120 4
    
    if(numConfigsPtr)
        *numConfigsPtr = numConfigs; 
    
d122 2
a123 2
    
    if(NULL == visualConfigs) {
d128 1
a128 1
    
d130 24
a153 12
    for(conf = caps.configurations; conf; conf = conf->next) {
        for(stereo = 0; stereo < (conf->stereo ? 2 : 1); ++stereo) {
            for(aux = 0; aux < (conf->aux_buffers ? 2 : 1); ++aux) {
                for(buffers = 0; buffers < conf->buffers; ++buffers) {
                    for(stencil = 0; stencil < ((conf->total_stencil_bit_depths > 0) ? 
                                                conf->total_stencil_bit_depths : 1); ++stencil) {
                        for(color = 0; color < conf->total_color_buffers; ++color) {
                            for(accum = 0; accum < ((conf->total_accum_buffers > 0) ?
                                                    conf->total_accum_buffers : 1); ++accum) {
                                for(depth = 0; depth < conf->total_depth_buffer_depths; ++depth) {
                                    for(msample = 0; msample < (conf->multisample_buffers + 1); ++msample) {
                                        
d164 2
a165 2
                                        
                                        if(conf->accelerated) {
a166 2
                                        } else {
                                            c->visualRating = GLX_SLOW_VISUAL_EXT;
d168 5
a172 1
                                        
d179 1
a179 1
                                        
d181 4
a184 3
                                        
                                        c->swapMethod = GLX_SWAP_UNDEFINED_OML;
                                        
d189 3
a191 2
                                        c->numAuxBuffers = aux ? conf->aux_buffers : 0;
                                        
d193 2
a194 1
                                        c->doubleBufferMode = buffers ? TRUE : FALSE;
d197 7
a203 3
                                        if(conf->total_stencil_bit_depths > 0) {
                                            c->stencilBits = conf->stencil_bit_depths[stencil];
                                        } else {
d206 1
a206 1
                                        
d208 6
a213 3
                                        if(GLCAPS_COLOR_BUF_INVALID_VALUE != conf->color_buffers[color].a) {
                                            c->alphaBits = conf->color_buffers[color].a;
                                        } else {
d216 29
a244 11
                                        c->redBits   = conf->color_buffers[color].r;
                                        c->greenBits = conf->color_buffers[color].g;
                                        c->blueBits  = conf->color_buffers[color].b;
                                        
                                        c->rgbBits = c->alphaBits + c->redBits + c->greenBits + c->blueBits;

                                        c->alphaMask = AM_ARGB(c->alphaBits, c->redBits, c->greenBits, c->blueBits);
                                        c->redMask   = RM_ARGB(c->alphaBits, c->redBits, c->greenBits, c->blueBits);
                                        c->greenMask = GM_ARGB(c->alphaBits, c->redBits, c->greenBits, c->blueBits);
                                        c->blueMask  = BM_ARGB(c->alphaBits, c->redBits, c->greenBits, c->blueBits);
                                                                                
d246 17
a262 7
                                        if(conf->total_accum_buffers > 0) {
                                            c->accumRedBits = conf->accum_buffers[accum].r;
                                            c->accumGreenBits = conf->accum_buffers[accum].g;
                                            c->accumBlueBits = conf->accum_buffers[accum].b;
                                            if(GLCAPS_COLOR_BUF_INVALID_VALUE != conf->accum_buffers[accum].a) {
                                                c->accumAlphaBits = conf->accum_buffers[accum].a;
                                            } else {
d265 2
a266 1
                                        } else {
d271 1
a271 1
                                        } 
d274 3
a276 2
                                        c->depthBits = conf->depth_buffers[depth];
                                        
d278 7
a284 4
                                        if(msample > 0) {
                                            c->samples = conf->multisample_samples;
                                            c->sampleBuffers = conf->multisample_buffers;
                                        } else {
d288 3
a290 3
										
                                        /* 
                                         * The Apple libGL supports GLXPixmaps and 
d294 3
a296 1
                                        c->drawableType = GLX_WINDOW_BIT | GLX_PIXMAP_BIT | GLX_PBUFFER_BIT;
d300 1
a300 1
                                        
d302 2
a303 2
                                        
                                        /* 
d307 1
a307 1
                                         * 
d313 3
a315 2
                                        c->maxPbufferPixels = /*Do we need this?*/ 0;
                                        /* 
d321 1
a321 1
                                        
d328 1
a328 1
                                        
d340 1
a340 1
    (c-1)->next = NULL;
d343 3
a345 1
        FatalError("numConfigs calculation error in setVisualConfigs!  numConfigs is %d  i is %d\n", numConfigs, (int)(c - visualConfigs));
d347 1
a347 1
    
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a53 1
#include <glxscreens.h>
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d118 1
a118 1
    visualConfigs = xcalloc(sizeof(*visualConfigs), numConfigs);
@


1.1
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d38 2
a41 1
#include <GL/gl.h>
d59 1
d62 1
a62 1
void setVisualConfigs(void) {
d64 1
a64 2
    __GLXvisualConfig *visualConfigs = NULL;
    void **visualPrivates = NULL;
d66 1
a66 1
    struct glCapabilitiesConfig *conf = NULL;
a67 1
    int i = 0; 
d70 2
a71 2
	ErrorF("error from getGlCapabilities()!\n");
	return;
d75 19
a93 8
      conf->stereo is 0 or 1, but we need at least 1 iteration of the loop, 
      so we treat a true conf->stereo as 2.

      The depth size is 0 or 24.  Thus we do 2 iterations for that.

      conf->aux_buffers (when available/non-zero) result in 2 iterations instead of 1.

      conf->buffers indicates whether we have single or double buffering.
a94 11
      conf->total_stencil_bit_depths
       
      conf->total_color_buffers indicates the RGB/RGBA color depths.
      
      conf->total_accum_buffers iterations for accum (with at least 1 if equal to 0) 
	
      conf->total_depth_buffer_depths 

      conf->multisample_buffers iterations (with at least 1 if equal to 0).  We add 1
      for the 0 multisampling config.
      
d96 1
a96 1

d98 1
a98 2
    conf = caps.configurations;
  
d100 1
a100 1

d102 4
a105 4
	if(conf->total_color_buffers <= 0)
	    continue;

	numConfigs += (conf->stereo ? 2 : 1) 
d114 4
a117 1

d119 1
a119 1

d121 3
a123 3
	ErrorF("xcalloc failure when allocating visualConfigs\n");
	freeGlCapabilities(&caps);
	return;
d126 1
a126 10
    visualPrivates = xcalloc(sizeof(void *), numConfigs);

    if(NULL == visualPrivates) {
	ErrorF("xcalloc failure when allocating visualPrivates");
	freeGlCapabilities(&caps);
	xfree(visualConfigs);
	return;
    }
    
    i = 0; /* current buffer */
d128 100
a227 100
	for(stereo = 0; stereo < (conf->stereo ? 2 : 1); ++stereo) {
	    for(aux = 0; aux < (conf->aux_buffers ? 2 : 1); ++aux) {
		for(buffers = 0; buffers < conf->buffers; ++buffers) {
		    for(stencil = 0; stencil < ((conf->total_stencil_bit_depths > 0) ? 
						conf->total_stencil_bit_depths : 1); ++stencil) {
			for(color = 0; color < conf->total_color_buffers; ++color) {
			    for(accum = 0; accum < ((conf->total_accum_buffers > 0) ?
						    conf->total_accum_buffers : 1); ++accum) {
				for(depth = 0; depth < conf->total_depth_buffer_depths; ++depth) {
				    for(msample = 0; msample < (conf->multisample_buffers + 1); ++msample) {
					visualConfigs[i].vid = (VisualID)(-1);
					visualConfigs[i].class = TrueColor;
					
					visualConfigs[i].rgba = true;
					visualConfigs[i].redSize = conf->color_buffers[color].r;
					visualConfigs[i].greenSize = conf->color_buffers[color].g;
					visualConfigs[i].blueSize = conf->color_buffers[color].b;

					if(GLCAPS_COLOR_BUF_INVALID_VALUE == conf->color_buffers[color].a) {
					    /* This visual has no alpha. */
					    visualConfigs[i].alphaSize = 0;
					} else {
					    visualConfigs[i].alphaSize = conf->color_buffers[color].a;
					}
	
					/* 
					 * If the .a/alpha value is unset, then don't add it to the
					 * bufferSize specification.  The INVALID_VALUE indicates that it
					 * was unset.
					 * 
					 * This prevents odd bufferSizes, such as 14.
					 */
					if(GLCAPS_COLOR_BUF_INVALID_VALUE == conf->color_buffers[color].a) {
					    visualConfigs[i].bufferSize = conf->color_buffers[color].r +
						conf->color_buffers[color].g + conf->color_buffers[color].b;
					} else {
					    visualConfigs[i].bufferSize = conf->color_buffers[color].r +
						conf->color_buffers[color].g + conf->color_buffers[color].b +
						conf->color_buffers[color].a;
					}

					/*
					 * I'm uncertain about these masks.
					 * I don't think we actually care what the values are in our
					 * libGL, so it doesn't seem to make a difference.
					 */
					visualConfigs[i].redMask = -1;
					visualConfigs[i].greenMask = -1;
					visualConfigs[i].blueMask = -1;
					visualConfigs[i].alphaMask = -1;
					
					if(conf->total_accum_buffers > 0) {
					    visualConfigs[i].accumRedSize = conf->accum_buffers[accum].r;
					    visualConfigs[i].accumGreenSize = conf->accum_buffers[accum].g;
					    visualConfigs[i].accumBlueSize = conf->accum_buffers[accum].b;
					    if(GLCAPS_COLOR_BUF_INVALID_VALUE != conf->accum_buffers[accum].a) {
						visualConfigs[i].accumAlphaSize = conf->accum_buffers[accum].a;
					    } else {
						visualConfigs[i].accumAlphaSize = 0;
					    }
					} else {
					    visualConfigs[i].accumRedSize = 0;
					    visualConfigs[i].accumGreenSize = 0;
					    visualConfigs[i].accumBlueSize = 0;
					    visualConfigs[i].accumAlphaSize = 0;
					}
					
					visualConfigs[i].doubleBuffer = buffers ? TRUE : FALSE;
					visualConfigs[i].stereo = stereo ? TRUE : FALSE;

  					visualConfigs[i].depthSize = conf->depth_buffers[depth];
				
					if(conf->total_stencil_bit_depths > 0) {
					    visualConfigs[i].stencilSize = conf->stencil_bit_depths[stencil];
					} else {
					    visualConfigs[i].stencilSize = 0;
					}
					visualConfigs[i].auxBuffers = aux ? conf->aux_buffers : 0;
					visualConfigs[i].level = 0;
				
					if(conf->accelerated) {
					    visualConfigs[i].visualRating = GLX_NONE;
					} else {
					    visualConfigs[i].visualRating = GLX_SLOW_VISUAL_EXT;
					}
					
					visualConfigs[i].transparentPixel = GLX_NONE;
					visualConfigs[i].transparentRed = GLX_NONE;
					visualConfigs[i].transparentGreen = GLX_NONE;
					visualConfigs[i].transparentBlue = GLX_NONE;
					visualConfigs[i].transparentAlpha = GLX_NONE;
					visualConfigs[i].transparentIndex = GLX_NONE;
					
					if(msample > 0) {
					    visualConfigs[i].multiSampleSize = conf->multisample_samples;
					    visualConfigs[i].nMultiSampleBuffers = conf->multisample_buffers;
					} else {
					    visualConfigs[i].multiSampleSize = 0;
					    visualConfigs[i].nMultiSampleBuffers = 0;
					}
d229 46
a274 9
					++i;
				    }
				}
			    }
			}
		    }
		}
	    }
	}
d277 4
a280 3
    if (i != numConfigs) {
	ErrorF("numConfigs calculation error in setVisualConfigs!  numConfigs is %d  i is %d\n", numConfigs, i);
	abort();
d282 1
a282 1

d284 1
a284 2

    GlxSetVisualConfigs(numConfigs, visualConfigs, visualPrivates);
@

