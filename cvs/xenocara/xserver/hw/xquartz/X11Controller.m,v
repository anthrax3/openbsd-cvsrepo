head	1.12;
access;
symbols
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.4
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@// @;


1.12
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	7pAEtF6Y5EgemkuY;

1.11
date	2014.07.11.08.13.44;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	QZ1xfp0adMyURB7B;

1.10
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.12.28.14.40.02;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.53;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.53;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.02.16.08.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.29;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@/* X11Controller.m -- connect the IB ui, also the NSApp delegate
 *
 * Copyright (c) 2002-2012 Apple Inc. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT
 * HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above
 * copyright holders shall not be used in advertising or otherwise to
 * promote the sale, use or other dealings in this Software without
 * prior written authorization.
 */

#include "sanitizedCarbon.h"
#include <AvailabilityMacros.h>

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "quartzCommon.h"

#import "X11Controller.h"
#import "X11Application.h"

#include "opaque.h"
#include "darwin.h"
#include "darwinEvents.h"
#include "quartz.h"
#include "quartzKeyboard.h"
#include <X11/extensions/applewmconst.h>
#include "applewmExt.h"

#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <asl.h>
#include <stdlib.h>

extern aslclient aslc;
extern char *bundle_id_prefix;

@@implementation X11Controller

- (void) awakeFromNib
{
    X11Application *xapp = NSApp;
    NSArray *array;

    /* Point X11Application at ourself. */
    [xapp set_controller:self];

    array = [xapp prefs_get_array:@@PREFS_APPSMENU];
    if (array != nil) {
        int count;

        /* convert from [TITLE1 COMMAND1 TITLE2 COMMAND2 ...]
           to [[TITLE1 COMMAND1] [TITLE2 COMMAND2] ...] format. */

        count = [array count];
        if (count > 0
            && ![[array objectAtIndex:0] isKindOfClass:[NSArray class]]) {
            int i;
            NSMutableArray *copy, *sub;

            copy = [NSMutableArray arrayWithCapacity:(count / 2)];

            for (i = 0; i < count / 2; i++) {
                sub = [[NSMutableArray alloc] initWithCapacity:3];
                [sub addObject:[array objectAtIndex:i * 2]];
                [sub addObject:[array objectAtIndex:i * 2 + 1]];
                [sub addObject:@@""];
                [copy addObject:sub];
                [sub release];
            }

            array = copy;
        }

        [self set_apps_menu:array];
    }

    [[NSNotificationCenter defaultCenter]
     addObserver: self
        selector: @@selector(apps_table_done:)
            name: NSWindowWillCloseNotification
          object: [apps_table window]];

    // Setup data about our Windows menu
    if (window_separator) {
        [[window_separator menu] removeItem:window_separator];
        window_separator = nil;
    }

    windows_menu_start = [[X11App windowsMenu] numberOfItems];
}

- (void) item_selected:sender
{
    [NSApp activateIgnoringOtherApps:YES];

    DarwinSendDDXEvent(kXquartzControllerNotify, 2,
                       AppleWMWindowMenuItem, [sender tag]);
}

- (void) remove_window_menu
{
    NSMenu *menu;
    int count, i;

    /* Work backwards so we don't mess up the indices */
    menu = [X11App windowsMenu];
    count = [menu numberOfItems];
    for (i = count - 1; i >= windows_menu_start; i--)
        [menu removeItemAtIndex:i];

    count = [dock_menu indexOfItem:dock_window_separator];
    for (i = 0; i < count; i++)
        [dock_menu removeItemAtIndex:0];
}

- (void) install_window_menu:(NSArray *)list
{
    NSMenu *menu;
    NSMenuItem *item;
    int first, count, i;

    menu = [X11App windowsMenu];
    first = windows_menu_start + 1;
    count = [list count];

    // Push a Separator
    if (count) {
        [menu addItem:[NSMenuItem separatorItem]];
    }

    for (i = 0; i < count; i++) {
        NSString *name, *shortcut;

        name = [[list objectAtIndex:i] objectAtIndex:0];
        shortcut = [[list objectAtIndex:i] objectAtIndex:1];

        if (windowItemModMask == 0 || windowItemModMask == -1)
            shortcut = @@"";

        item =
            (NSMenuItem *)[menu addItemWithTitle:name action:
                           @@selector
                           (item_selected:) keyEquivalent:shortcut];
        [item setKeyEquivalentModifierMask:(NSUInteger)windowItemModMask];
        [item setTarget:self];
        [item setTag:i];
        [item setEnabled:YES];

        item = (NSMenuItem *)[dock_menu  insertItemWithTitle:name
                                                      action:@@selector
                              (item_selected:) keyEquivalent:shortcut
                                                     atIndex:i];
        [item setKeyEquivalentModifierMask:(NSUInteger)windowItemModMask];
        [item setTarget:self];
        [item setTag:i];
        [item setEnabled:YES];
    }

    if (checked_window_item >= 0 && checked_window_item < count) {
        item = (NSMenuItem *)[menu itemAtIndex:first + checked_window_item];
        [item setState:NSOnState];
        item = (NSMenuItem *)[dock_menu itemAtIndex:checked_window_item];
        [item setState:NSOnState];
    }
}

- (void) remove_apps_menu
{
    NSMenu *menu;
    NSMenuItem *item;
    int i;

    if (apps == nil || apps_separator == nil) return;

    menu = [apps_separator menu];

    if (menu != nil) {
        for (i = [menu numberOfItems] - 1; i >= 0; i--) {
            item = (NSMenuItem *)[menu itemAtIndex:i];
            if ([item tag] != 0)
                [menu removeItemAtIndex:i];
        }
    }

    if (dock_apps_menu != nil) {
        for (i = [dock_apps_menu numberOfItems] - 1; i >= 0; i--) {
            item = (NSMenuItem *)[dock_apps_menu itemAtIndex:i];
            if ([item tag] != 0)
                [dock_apps_menu removeItemAtIndex:i];
        }
    }

    [apps release];
    apps = nil;
}

- (void) prepend_apps_item:(NSArray *)list index:(int)i menu:(NSMenu *)menu
{
    NSString *title, *shortcut = @@"";
    NSArray *group;
    NSMenuItem *item;

    group = [list objectAtIndex:i];
    title = [group objectAtIndex:0];
    if ([group count] >= 3)
        shortcut = [group objectAtIndex:2];

    if ([title length] != 0) {
        item = (NSMenuItem *)[menu insertItemWithTitle:title
                                                action:@@selector (
                                  app_selected:)
                              keyEquivalent:shortcut atIndex:0];
        [item setTarget:self];
        [item setEnabled:YES];
    }
    else {
        item = (NSMenuItem *)[NSMenuItem separatorItem];
        [menu insertItem:item atIndex:0];
    }

    [item setTag:i + 1];                  /* can't be zero, so add one */
}

- (void) install_apps_menu:(NSArray *)list
{
    NSMenu *menu;
    int i, count;

    count = [list count];

    if (count == 0 || apps_separator == nil) return;

    menu = [apps_separator menu];

    for (i = count - 1; i >= 0; i--) {
        if (menu != nil)
            [self prepend_apps_item:list index:i menu:menu];
        if (dock_apps_menu != nil)
            [self prepend_apps_item:list index:i menu:dock_apps_menu];
    }

    apps = [list retain];
}

- (void) set_window_menu:(NSArray *)list
{
    [self remove_window_menu];
    [self install_window_menu:list];

    DarwinSendDDXEvent(kXquartzControllerNotify, 1,
                       AppleWMWindowMenuNotify);
}

- (void) set_window_menu_check:(NSNumber *)nn
{
    NSMenu *menu;
    NSMenuItem *item;
    int first, count;
    int n = [nn intValue];

    menu = [X11App windowsMenu];
    first = windows_menu_start + 1;
    count = [menu numberOfItems] - first;

    if (checked_window_item >= 0 && checked_window_item < count) {
        item = (NSMenuItem *)[menu itemAtIndex:first + checked_window_item];
        [item setState:NSOffState];
        item = (NSMenuItem *)[dock_menu itemAtIndex:checked_window_item];
        [item setState:NSOffState];
    }
    if (n >= 0 && n < count) {
        item = (NSMenuItem *)[menu itemAtIndex:first + n];
        [item setState:NSOnState];
        item = (NSMenuItem *)[dock_menu itemAtIndex:n];
        [item setState:NSOnState];
    }
    checked_window_item = n;
}

- (void) set_apps_menu:(NSArray *)list
{
    [self remove_apps_menu];
    [self install_apps_menu:list];
}

#ifdef XQUARTZ_SPARKLE
- (void) setup_sparkle
{
    if (check_for_updates_item)
        return;  // already did it...

    NSMenu *menu = [x11_about_item menu];

    check_for_updates_item =
        [menu insertItemWithTitle:NSLocalizedString(
             @@"Check for X11 Updates...",
             @@"Check for X11 Updates...")
         action:@@selector (
             checkForUpdates:)
         keyEquivalent:@@""
         atIndex:1];
    [check_for_updates_item setTarget:[SUUpdater sharedUpdater]];
    [check_for_updates_item setEnabled:YES];

    // Set X11Controller as the delegate for the updater.
    [[SUUpdater sharedUpdater] setDelegate:self];
}

// Sent immediately before installing the specified update.
- (void)updater:(SUUpdater *)updater willInstallUpdate:(SUAppcastItem *)
   update
{
    //[self set_can_quit:YES];
}

#endif

- (void) launch_client:(NSString *)filename
{
    int child1, child2 = 0;
    int status;
    const char *newargv[4];
    char buf[128];
    char *s;
#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
    int stdout_pipe[2];
    int stderr_pipe[2];
#endif

    newargv[0] = [X11App prefs_get_string:@@PREFS_LOGIN_SHELL default:"/bin/sh"];
    newargv[1] = "-c";
    newargv[2] = [filename UTF8String];
    newargv[3] = NULL;

    s = getenv("DISPLAY");
    if (s == NULL || s[0] == 0) {
        snprintf(buf, sizeof(buf), ":%s", display);
        setenv("DISPLAY", buf, TRUE);
    }

#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
    if (&asl_log_descriptor) {
        char *asl_sender;
        aslmsg amsg = asl_new(ASL_TYPE_MSG);
        assert(amsg);

        asprintf(&asl_sender, "%s.%s", bundle_id_prefix, newargv[2]);
        assert(asl_sender);
        for(s = asl_sender + strlen(bundle_id_prefix) + 1; *s; s++) {
            if(! ((*s >= 'a' && *s <= 'z') ||
                  (*s >= 'A' && *s <= 'Z') ||
                  (*s >= '0' && *s <= '9'))) {
                *s = '_';
            }
        }

        (void)asl_set(amsg, ASL_KEY_SENDER, asl_sender);
        free(asl_sender);

        assert(0 == pipe(stdout_pipe));
        fcntl(stdout_pipe[0], F_SETFD, FD_CLOEXEC);
        fcntl(stdout_pipe[0], F_SETFL, O_NONBLOCK);

        assert(0 == pipe(stderr_pipe));
        fcntl(stderr_pipe[0], F_SETFD, FD_CLOEXEC);
        fcntl(stderr_pipe[0], F_SETFL, O_NONBLOCK);

        asl_log_descriptor(aslc, amsg, ASL_LEVEL_INFO, stdout_pipe[0], ASL_LOG_DESCRIPTOR_READ);
        asl_log_descriptor(aslc, amsg, ASL_LEVEL_NOTICE, stderr_pipe[0], ASL_LOG_DESCRIPTOR_READ);

        asl_free(amsg);
    }
#endif

    /* Do the fork-twice trick to avoid having to reap zombies */
    child1 = fork();
    switch (child1) {
    case -1:                                    /* error */
        break;

    case 0:                                     /* child1 */
        child2 = fork();

        switch (child2) {
            int max_files, i;

        case -1:                                    /* error */
            _exit(1);

        case 0:                                     /* child2 */
#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
            if (&asl_log_descriptor) {
                /* Replace our stdout/stderr */
                dup2(stdout_pipe[1], STDOUT_FILENO);
                dup2(stderr_pipe[1], STDERR_FILENO);
            }
#endif

            /* close all open files except for standard streams */
            max_files = sysconf(_SC_OPEN_MAX);
            for (i = 3; i < max_files; i++)
                close(i);

            /* ensure stdin is on /dev/null */
            close(0);
            open("/dev/null", O_RDONLY);

            execvp(newargv[0], (char * *const)newargv);
            _exit(2);

        default:                                    /* parent (child1) */
            _exit(0);
        }
        break;

    default:                                    /* parent */
        waitpid(child1, &status, 0);
    }

#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
    if (&asl_log_descriptor) {
        /* Close the write ends of the pipe */
        close(stdout_pipe[1]);
        close(stderr_pipe[1]);
    }
#endif
}

- (void) app_selected:sender
{
    int tag;
    NSString *item;

    tag = [sender tag] - 1;
    if (apps == nil || tag < 0 || tag >= [apps count])
        return;

    item = [[apps objectAtIndex:tag] objectAtIndex:1];

    [self launch_client:item];
}

- (IBAction) apps_table_show:sender
{
    NSArray *columns;
    NSMutableArray *oldapps = nil;

    if (table_apps != nil)
        oldapps = table_apps;

    table_apps = [[NSMutableArray alloc] initWithCapacity:1];
    if (apps != nil)
        [table_apps addObjectsFromArray:apps];

    columns = [apps_table tableColumns];
    [[columns objectAtIndex:0] setIdentifier:@@"0"];
    [[columns objectAtIndex:1] setIdentifier:@@"1"];
    [[columns objectAtIndex:2] setIdentifier:@@"2"];

    [apps_table setDataSource:self];
    [apps_table selectRowIndexes:[NSIndexSet indexSetWithIndex:0]
     byExtendingSelection:NO];

    [[apps_table window] makeKeyAndOrderFront:sender];
    [apps_table reloadData];
    if (oldapps != nil)
        [oldapps release];
}

- (IBAction) apps_table_done:sender
{
    [apps_table deselectAll:sender];    /* flush edits? */

    [self remove_apps_menu];
    [self install_apps_menu:table_apps];

    [NSApp prefs_set_array:@@PREFS_APPSMENU value:table_apps];
    [NSApp prefs_synchronize];

    [[apps_table window] orderOut:sender];

    [table_apps release];
    table_apps = nil;
}

- (IBAction) apps_table_new:sender
{
    NSMutableArray *item;

    int row = [apps_table selectedRow], i;

    if (row < 0) row = 0;
    else row = row + 1;

    i = row;
    if (i > [table_apps count])
        return;                         /* avoid exceptions */

    [apps_table deselectAll:sender];

    item = [[NSMutableArray alloc] initWithCapacity:3];
    [item addObject:@@""];
    [item addObject:@@""];
    [item addObject:@@""];

    [table_apps insertObject:item atIndex:i];
    [item release];

    [apps_table reloadData];
    [apps_table selectRowIndexes:[NSIndexSet indexSetWithIndex:row]
     byExtendingSelection:NO];
}

- (IBAction) apps_table_duplicate:sender
{
    int row = [apps_table selectedRow], i;
    NSObject *item;

    if (row < 0) {
        [self apps_table_new:sender];
        return;
    }

    i = row;
    if (i > [table_apps count] - 1) return;                             /* avoid exceptions */

    [apps_table deselectAll:sender];

    item = [[table_apps objectAtIndex:i] mutableCopy];
    [table_apps insertObject:item atIndex:i];
    [item release];

    [apps_table reloadData];
    [apps_table selectRowIndexes:[NSIndexSet indexSetWithIndex:row +
                                  1] byExtendingSelection:NO];
}

- (IBAction) apps_table_delete:sender
{
    int row = [apps_table selectedRow];

    if (row >= 0) {
        int i = row;

        if (i > [table_apps count] - 1) return;                 /* avoid exceptions */

        [apps_table deselectAll:sender];

        [table_apps removeObjectAtIndex:i];
    }

    [apps_table reloadData];

    row = MIN(row, [table_apps count] - 1);
    if (row >= 0)
        [apps_table selectRowIndexes:[NSIndexSet indexSetWithIndex:row]
         byExtendingSelection:NO];
}

- (NSInteger) numberOfRowsInTableView:(NSTableView *)tableView
{
    if (table_apps == nil) return 0;

    return [table_apps count];
}

- (id)             tableView:(NSTableView *)tableView
   objectValueForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row
{
    NSArray *item;
    int col;

    if (table_apps == nil) return nil;

    col = [[tableColumn identifier] intValue];

    item = [table_apps objectAtIndex:row];
    if ([item count] > col)
        return [item objectAtIndex:col];
    else
        return @@"";
}

- (void) tableView:(NSTableView *)tableView setObjectValue:(id)object
    forTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row
{
    NSMutableArray *item;
    int col;

    if (table_apps == nil) return;

    col = [[tableColumn identifier] intValue];

    item = [table_apps objectAtIndex:row];
    [item replaceObjectAtIndex:col withObject:object];
}

- (void) hide_window:sender
{
    if ([X11App x_active])
        DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMHideWindow);
    else
        NSBeep();                       /* FIXME: something here */
}

- (IBAction)bring_to_front:sender
{
    DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMBringAllToFront);
}

- (IBAction)close_window:sender
{
    if ([X11App x_active])
        DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMCloseWindow);
    else
        [[NSApp keyWindow] performClose:sender];
}

- (IBAction)minimize_window:sender
{
    if ([X11App x_active])
        DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMMinimizeWindow);
    else
        [[NSApp keyWindow] performMiniaturize:sender];
}

- (IBAction)zoom_window:sender
{
    if ([X11App x_active])
        DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMZoomWindow);
    else
        [[NSApp keyWindow] performZoom:sender];
}

- (IBAction) next_window:sender
{
    DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMNextWindow);
}

- (IBAction) previous_window:sender
{
    DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMPreviousWindow);
}

- (IBAction) enable_fullscreen_changed:sender
{
    XQuartzRootlessDefault = ![enable_fullscreen intValue];

    [enable_fullscreen_menu setEnabled:!XQuartzRootlessDefault];
    [enable_fullscreen_menu_text setTextColor:XQuartzRootlessDefault ?[
         NSColor disabledControlTextColor] : [NSColor controlTextColor]];

    DarwinSendDDXEvent(kXquartzSetRootless, 1, XQuartzRootlessDefault);

    [NSApp prefs_set_boolean:@@PREFS_ROOTLESS value:XQuartzRootlessDefault];
    [NSApp prefs_synchronize];
}

- (IBAction) toggle_fullscreen:sender
{
    DarwinSendDDXEvent(kXquartzToggleFullscreen, 0);
}

- (void) set_can_quit:(OSX_BOOL)state
{
    can_quit = state;
}

- (IBAction)prefs_changed:sender
{
    if (!sender)
        return;

    if (sender == fake_buttons) {
        darwinFakeButtons = [fake_buttons intValue];
        [NSApp prefs_set_boolean:@@PREFS_FAKEBUTTONS value:darwinFakeButtons];
    }
    else if (sender == enable_keyequivs) {
        XQuartzEnableKeyEquivalents = [enable_keyequivs intValue];
        [NSApp prefs_set_boolean:@@PREFS_KEYEQUIVS value:
         XQuartzEnableKeyEquivalents];
    }
    else if (sender == sync_keymap) {
        darwinSyncKeymap = [sync_keymap intValue];
        [NSApp prefs_set_boolean:@@PREFS_SYNC_KEYMAP value:darwinSyncKeymap];
    }
    else if (sender == enable_fullscreen_menu) {
        XQuartzFullscreenMenu = [enable_fullscreen_menu intValue];
        [NSApp prefs_set_boolean:@@PREFS_FULLSCREEN_MENU value:
         XQuartzFullscreenMenu];
    }
    else if (sender == option_sends_alt) {
        BOOL prev_opt_sends_alt = XQuartzOptionSendsAlt;

        XQuartzOptionSendsAlt = [option_sends_alt intValue];
        [NSApp prefs_set_boolean:@@PREFS_OPTION_SENDS_ALT value:
         XQuartzOptionSendsAlt];

        if (prev_opt_sends_alt != XQuartzOptionSendsAlt)
            QuartsResyncKeymap(TRUE);
    }
    else if (sender == click_through) {
        [NSApp prefs_set_boolean:@@PREFS_CLICK_THROUGH value:[click_through
                                                             intValue]];
    }
    else if (sender == focus_follows_mouse) {
        [NSApp prefs_set_boolean:@@PREFS_FFM value:[focus_follows_mouse
                                                   intValue]];
    }
    else if (sender == focus_on_new_window) {
        [NSApp prefs_set_boolean:@@PREFS_FOCUS_ON_NEW_WINDOW value:[
             focus_on_new_window intValue]];
    }
    else if (sender == enable_auth) {
        [NSApp prefs_set_boolean:@@PREFS_NO_AUTH value:![enable_auth intValue]
        ];
    }
    else if (sender == enable_tcp) {
        [NSApp prefs_set_boolean:@@PREFS_NO_TCP value:![enable_tcp intValue]];
    }
    else if (sender == depth) {
        [NSApp prefs_set_integer:@@PREFS_DEPTH value:[depth selectedTag]];
    }
    else if (sender == sync_pasteboard) {
        BOOL pbproxy_active = [sync_pasteboard intValue];
        [NSApp prefs_set_boolean:@@PREFS_SYNC_PB value:pbproxy_active];

        [sync_pasteboard_to_clipboard setEnabled:pbproxy_active];
        [sync_pasteboard_to_primary setEnabled:pbproxy_active];
        [sync_clipboard_to_pasteboard setEnabled:pbproxy_active];
        [sync_primary_immediately setEnabled:pbproxy_active];

        // setEnabled doesn't do this...
        [sync_text1 setTextColor:pbproxy_active ?[NSColor controlTextColor] :
         [NSColor disabledControlTextColor]];
        [sync_text2 setTextColor:pbproxy_active ?[NSColor controlTextColor] :
         [NSColor disabledControlTextColor]];
    }
    else if (sender == sync_pasteboard_to_clipboard) {
        [NSApp prefs_set_boolean:@@PREFS_SYNC_PB_TO_CLIPBOARD value:[
             sync_pasteboard_to_clipboard intValue]];
    }
    else if (sender == sync_pasteboard_to_primary) {
        [NSApp prefs_set_boolean:@@PREFS_SYNC_PB_TO_PRIMARY value:[
             sync_pasteboard_to_primary intValue]];
    }
    else if (sender == sync_clipboard_to_pasteboard) {
        [NSApp prefs_set_boolean:@@PREFS_SYNC_CLIPBOARD_TO_PB value:[
             sync_clipboard_to_pasteboard intValue]];
    }
    else if (sender == sync_primary_immediately) {
        [NSApp prefs_set_boolean:@@PREFS_SYNC_PRIMARY_ON_SELECT value:[
             sync_primary_immediately intValue]];
    }
    else if (sender == scroll_in_device_direction) {
        XQuartzScrollInDeviceDirection =
            [scroll_in_device_direction intValue];
        [NSApp prefs_set_boolean:@@PREFS_SCROLL_IN_DEV_DIRECTION value:
         XQuartzScrollInDeviceDirection];
    }

    [NSApp prefs_synchronize];

    DarwinSendDDXEvent(kXquartzReloadPreferences, 0);
}

- (IBAction) prefs_show:sender
{
    BOOL pbproxy_active =
        [NSApp prefs_get_boolean:@@PREFS_SYNC_PB default:YES];

    // Remove preferences from the GUI which are not supported
    // TODO: Change 1117 to NSAppKitVersionNumber10_7 when it is defined
    if (scroll_in_device_direction && NSAppKitVersionNumber < 1117) {
        [scroll_in_device_direction removeFromSuperview];
        scroll_in_device_direction = nil;
    }
    else {
        [scroll_in_device_direction setIntValue:
         XQuartzScrollInDeviceDirection];
    }

    [fake_buttons setIntValue:darwinFakeButtons];
    [enable_keyequivs setIntValue:XQuartzEnableKeyEquivalents];
    [sync_keymap setIntValue:darwinSyncKeymap];
    [option_sends_alt setIntValue:XQuartzOptionSendsAlt];
    [click_through setIntValue:[NSApp prefs_get_boolean:@@PREFS_CLICK_THROUGH
                                default:NO]];
    [focus_follows_mouse setIntValue:[NSApp prefs_get_boolean:@@PREFS_FFM
                                      default:NO]];
    [focus_on_new_window setIntValue:[NSApp prefs_get_boolean:
                                      @@PREFS_FOCUS_ON_NEW_WINDOW default:YES]
    ];

    [enable_auth setIntValue:![NSApp prefs_get_boolean:@@PREFS_NO_AUTH default
                               :NO]];
    [enable_tcp setIntValue:![NSApp prefs_get_boolean:@@PREFS_NO_TCP default:
                              NO]];

    [depth selectItemAtIndex:[depth indexOfItemWithTag:[NSApp
                                                        prefs_get_integer:
                                                        @@PREFS_DEPTH default:
                                                        -1]]];

    [sync_pasteboard setIntValue:pbproxy_active];
    [sync_pasteboard_to_clipboard setIntValue:[NSApp prefs_get_boolean:
                                               @@PREFS_SYNC_PB_TO_CLIPBOARD
                                               default:YES]];
    [sync_pasteboard_to_primary setIntValue:[NSApp prefs_get_boolean:
                                             @@PREFS_SYNC_PB_TO_PRIMARY
                                             default:YES]];
    [sync_clipboard_to_pasteboard setIntValue:[NSApp prefs_get_boolean:
                                               @@PREFS_SYNC_CLIPBOARD_TO_PB
                                               default:YES]];
    [sync_primary_immediately setIntValue:[NSApp prefs_get_boolean:
                                           @@PREFS_SYNC_PRIMARY_ON_SELECT
                                           default:NO]];

    [sync_pasteboard_to_clipboard setEnabled:pbproxy_active];
    [sync_pasteboard_to_primary setEnabled:pbproxy_active];
    [sync_clipboard_to_pasteboard setEnabled:pbproxy_active];
    [sync_primary_immediately setEnabled:pbproxy_active];

    // setEnabled doesn't do this...
    [sync_text1 setTextColor:pbproxy_active ?[NSColor controlTextColor] : [
         NSColor disabledControlTextColor]];
    [sync_text2 setTextColor:pbproxy_active ?[NSColor controlTextColor] : [
         NSColor disabledControlTextColor]];

    [enable_fullscreen setIntValue:!XQuartzRootlessDefault];
    [enable_fullscreen_menu setIntValue:XQuartzFullscreenMenu];
    [enable_fullscreen_menu setEnabled:!XQuartzRootlessDefault];
    [enable_fullscreen_menu_text setTextColor:XQuartzRootlessDefault ?[
         NSColor disabledControlTextColor] : [NSColor controlTextColor]];

    [prefs_panel makeKeyAndOrderFront:sender];
}

- (IBAction) quit:sender
{
    DarwinSendDDXEvent(kXquartzQuit, 0);
}

- (IBAction) x11_help:sender
{
#if MAC_OS_X_VERSION_MIN_REQUIRED < 1060
    AHLookupAnchor((CFStringRef)NSLocalizedString(@@"Mac Help",
                                                  no comment),
                   CFSTR("mchlp2276"));
#else
    AHLookupAnchor(CFSTR("com.apple.machelp"), CFSTR("mchlp2276"));
#endif
}

- (OSX_BOOL) validateMenuItem:(NSMenuItem *)item
{
    NSMenu *menu = [item menu];

    if (item == toggle_fullscreen_item)
        return !XQuartzIsRootless;
    else if (menu == [X11App windowsMenu] || menu == dock_menu
             || (menu == [x11_about_item menu] && [item tag] == 42))
        return (AppleWMSelectedEvents() & AppleWMControllerNotifyMask) != 0;
    else
        return TRUE;
}

- (void) applicationDidHide:(NSNotification *)notify
{
    DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMHideAll);

    /* Toggle off fullscreen mode to leave our non-default video
     * mode and hide our guard window.
     */
    if (!XQuartzIsRootless && XQuartzFullscreenVisible) {
        DarwinSendDDXEvent(kXquartzToggleFullscreen, 0);
    }
}

- (void) applicationDidUnhide:(NSNotification *)notify
{
    DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMShowAll);
}

- (NSApplicationTerminateReply) applicationShouldTerminate:sender
{
    NSString *msg;
    NSString *title;

    if (can_quit ||
        [X11App prefs_get_boolean:@@PREFS_NO_QUIT_ALERT default:NO])
        return NSTerminateNow;

    /* Make sure we're frontmost. */
    [NSApp activateIgnoringOtherApps:YES];

    title = NSLocalizedString(@@"Do you really want to quit X11?",
                              @@"Dialog title when quitting");
    msg = NSLocalizedString(
        @@"Any open X11 applications will stop immediately, and you will lose any unsaved changes.",
        @@"Dialog when quitting");

    /* FIXME: safe to run the alert in here? Or should we return Later
     *        and then run the alert on a timer? It seems to work here, so..
     */

    NSInteger result = NSRunAlertPanel(title, @@"%@@", NSLocalizedString(@@"Quit", @@""),
                                       NSLocalizedString(@@"Cancel", @@""), nil, msg);
    return (result == NSAlertDefaultReturn) ? NSTerminateNow : NSTerminateCancel;
}

- (void) applicationWillTerminate:(NSNotification *)aNotification _X_NORETURN
{
    [X11App prefs_synchronize];

    /* shutdown the X server, it will exit () for us. */
    DarwinSendDDXEvent(kXquartzQuit, 0);

    /* In case it doesn't, exit anyway after 5s. */
    [NSThread sleepForTimeInterval:5.0];

    exit(1);
}

- (void) server_ready
{
    x_list *node;

    finished_launching = YES;

    for (node = pending_apps; node != NULL; node = node->next) {
        NSString *filename = node->data;
        [self launch_client:filename];
        [filename release];
    }

    x_list_free(pending_apps);
    pending_apps = NULL;
}

- (OSX_BOOL) application:(NSApplication *)app openFile:(NSString *)filename
{
    const char *name = [filename UTF8String];

    if (finished_launching)
        [self launch_client:filename];
    else if (name[0] != ':')            /* ignore display names */
        pending_apps = x_list_prepend(pending_apps, [filename retain]);

    /* FIXME: report failures. */
    return YES;
}

@@end

void
X11ControllerMain(int argc, char **argv, char **envp)
{
    X11ApplicationMain(argc, argv, envp);
}
@


1.11
log
@Update to xorg-server 1.15.2. bug fixes.
@
text
@d367 1
a367 1
    if (asl_log_descriptor) {
d417 1
a417 1
            if (asl_log_descriptor) {
d446 1
a446 1
    if (asl_log_descriptor) {
d932 3
a934 3
    return (NSRunAlertPanel(title, msg, NSLocalizedString(@@"Quit", @@""),
                            NSLocalizedString(@@"Cancel", @@""), nil)
            == NSAlertDefaultReturn) ? NSTerminateNow : NSTerminateCancel;
a938 1
    int remain;
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d945 2
a946 3
    /* In case it doesn't, exit anyway after a while. */
    remain = 10000000;
    while ((remain = usleep(remain)) > 0) ;
@


1.9
log
@Update to xserver 1.14.5
@
text
@d350 1
a350 1
#if 0 && MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
d366 1
a366 1
#if 0 && MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
d416 1
a416 1
#if 0 && MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
d445 1
a445 1
#if 0 && MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
d937 1
a937 1
- (void) applicationWillTerminate:(NSNotification *)aNotification
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d939 1
a939 1
    unsigned remain;
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d56 5
d350 4
d355 1
a355 2
    newargv[0] =
        [X11App prefs_get_string:@@PREFS_LOGIN_SHELL default:"/bin/sh"];
d366 34
d416 8
d444 8
@


1.6
log
@Update to xserver 1.11.2
@
text
@d2 28
a29 27
 
   Copyright (c) 2002-2008 Apple Inc. All rights reserved.
 
   Permission is hereby granted, free of charge, to any person
   obtaining a copy of this software and associated documentation files
   (the "Software"), to deal in the Software without restriction,
   including without limitation the rights to use, copy, modify, merge,
   publish, distribute, sublicense, and/or sell copies of the Software,
   and to permit persons to whom the Software is furnished to do so,
   subject to the following conditions:
 
   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.
 
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT
   HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.
 
   Except as contained in this notice, the name(s) of the above
   copyright holders shall not be used in advertising or otherwise to
   promote the sale, use or other dealings in this Software without
   prior written authorization. */
d61 34
a94 37
  X11Application *xapp = NSApp;
  NSArray *array;
	
  /* Point X11Application at ourself. */
  [xapp set_controller:self];
	
  array = [xapp prefs_get_array:@@PREFS_APPSMENU];
  if (array != nil)
    {
      int count;
		
      /* convert from [TITLE1 COMMAND1 TITLE2 COMMAND2 ...]
	 to [[TITLE1 COMMAND1] [TITLE2 COMMAND2] ...] format. */
		
      count = [array count];
      if (count > 0
	  && ![[array objectAtIndex:0] isKindOfClass:[NSArray class]])
	{
	  int i;
	  NSMutableArray *copy, *sub;
			
	  copy = [NSMutableArray arrayWithCapacity:(count / 2)];
			
	  for (i = 0; i < count / 2; i++)
	    {
	      sub = [[NSMutableArray alloc] initWithCapacity:3];
	      [sub addObject:[array objectAtIndex:i*2]];
	      [sub addObject:[array objectAtIndex:i*2+1]];
	      [sub addObject:@@""];
	      [copy addObject:sub];
	      [sub release];
	    }
			
	  array = copy;
	}
		
      [self set_apps_menu:array];
d96 1
a96 1
    
d99 3
a101 3
     selector: @@selector(apps_table_done:)
     name: NSWindowWillCloseNotification
     object: [apps_table window]];
d104 1
a104 1
    if(window_separator) {
d108 1
a108 1
    
d114 4
a117 4
  [NSApp activateIgnoringOtherApps:YES];
	
  DarwinSendDDXEvent(kXquartzControllerNotify, 2,
			     AppleWMWindowMenuItem, [sender tag]);
d122 2
a123 2
  NSMenu *menu;
  int count, i;
d125 9
a133 9
  /* Work backwards so we don't mess up the indices */
  menu = [X11App windowsMenu];
  count = [menu numberOfItems];
  for (i = count - 1; i >= windows_menu_start; i--)
    [menu removeItemAtIndex:i];
	
  count = [dock_menu indexOfItem:dock_window_separator];
  for (i = 0; i < count; i++)
    [dock_menu removeItemAtIndex:0];
d138 46
a183 46
  NSMenu *menu;
  NSMenuItem *item;
  int first, count, i;

  menu = [X11App windowsMenu];
  first = windows_menu_start + 1;
  count = [list count];
  
  // Push a Separator
  if(count) {
      [menu addItem:[NSMenuItem separatorItem]];
  }

  for (i = 0; i < count; i++)
    {
      NSString *name, *shortcut;
		
      name = [[list objectAtIndex:i] objectAtIndex:0];
      shortcut = [[list objectAtIndex:i] objectAtIndex:1];
        
      if(windowItemModMask == 0 || windowItemModMask == -1)
          shortcut = @@"";

      item = (NSMenuItem *) [menu addItemWithTitle:name action:@@selector
				  (item_selected:) keyEquivalent:shortcut];
      [item setKeyEquivalentModifierMask:(NSUInteger) windowItemModMask];
      [item setTarget:self];
      [item setTag:i];
      [item setEnabled:YES];

      item = (NSMenuItem *) [dock_menu insertItemWithTitle:name
				       action:@@selector
				       (item_selected:) keyEquivalent:shortcut
				       atIndex:i];
      [item setKeyEquivalentModifierMask:(NSUInteger) windowItemModMask];
      [item setTarget:self];
      [item setTag:i];
      [item setEnabled:YES];
    }
	
  if (checked_window_item >= 0 && checked_window_item < count)
    {
      item = (NSMenuItem *) [menu itemAtIndex:first + checked_window_item];
      [item setState:NSOnState];
      item = (NSMenuItem *) [dock_menu itemAtIndex:checked_window_item];
      [item setState:NSOnState];
d189 26
a214 30
  NSMenu *menu;
  NSMenuItem *item;
  int i;
	
  if (apps == nil || apps_separator == nil) return;
	
  menu = [apps_separator menu];
	
  if (menu != nil)
    {
      for (i = [menu numberOfItems] - 1; i >= 0; i--)
	{
	  item = (NSMenuItem *) [menu itemAtIndex:i];
	  if ([item tag] != 0)
	    [menu removeItemAtIndex:i];
	}
    }
    
  if (dock_apps_menu != nil)
    {
      for (i = [dock_apps_menu numberOfItems] - 1; i >= 0; i--)
	{
	  item = (NSMenuItem *) [dock_apps_menu itemAtIndex:i];
	  if ([item tag] != 0)
	    [dock_apps_menu removeItemAtIndex:i];
	}
    }
    
  [apps release];
  apps = nil;
d219 20
a238 21
  NSString *title, *shortcut = @@"";
  NSArray *group;
  NSMenuItem *item;
	
  group = [list objectAtIndex:i];
  title = [group objectAtIndex:0];
  if ([group count] >= 3)
    shortcut = [group objectAtIndex:2];
	
  if ([title length] != 0)
    {
      item = (NSMenuItem *) [menu insertItemWithTitle:title
				  action:@@selector (app_selected:)
				  keyEquivalent:shortcut atIndex:0];
      [item setTarget:self];
      [item setEnabled:YES];
    }
  else
    {
      item = (NSMenuItem *) [NSMenuItem separatorItem];
      [menu insertItem:item atIndex:0];
d240 2
a241 2
	
  [item setTag:i+1];			/* can't be zero, so add one */
d246 14
a259 15
  NSMenu *menu;
  int i, count;
	
  count = [list count];
	
  if (count == 0 || apps_separator == nil) return;
	
  menu = [apps_separator menu];
	
  for (i = count - 1; i >= 0; i--)
    {
      if (menu != nil)
	[self prepend_apps_item:list index:i menu:menu];
      if (dock_apps_menu != nil)
	[self prepend_apps_item:list index:i menu:dock_apps_menu];
d261 2
a262 2
	
  apps = [list retain];
d267 5
a271 5
  [self remove_window_menu];
  [self install_window_menu:list];
	
  DarwinSendDDXEvent(kXquartzControllerNotify, 1,
			     AppleWMWindowMenuNotify);
d276 20
a295 22
  NSMenu *menu;
  NSMenuItem *item;
  int first, count;
  int n = [nn intValue];

  menu = [X11App windowsMenu];
  first = windows_menu_start + 1;
  count = [menu numberOfItems] - first;
	
  if (checked_window_item >= 0 && checked_window_item < count)
    {
      item = (NSMenuItem *) [menu itemAtIndex:first + checked_window_item];
      [item setState:NSOffState];
      item = (NSMenuItem *) [dock_menu itemAtIndex:checked_window_item];
      [item setState:NSOffState];
    }
  if (n >= 0 && n < count)
    {
      item = (NSMenuItem *) [menu itemAtIndex:first + n];
      [item setState:NSOnState];
      item = (NSMenuItem *) [dock_menu itemAtIndex:n];
      [item setState:NSOnState];
d297 1
a297 1
  checked_window_item = n;
d302 2
a303 2
  [self remove_apps_menu];
  [self install_apps_menu:list];
d307 4
a310 3
- (void) setup_sparkle {
    if(check_for_updates_item)
        return; // already did it...
d314 8
a321 4
    check_for_updates_item = [menu insertItemWithTitle:NSLocalizedString(@@"Check for X11 Updates...", @@"Check for X11 Updates...")
                                               action:@@selector (checkForUpdates:)
                                        keyEquivalent:@@""
                                              atIndex:1];
d330 3
a332 1
- (void)updater:(SUUpdater *)updater willInstallUpdate:(SUAppcastItem *)update {
d345 3
a347 2
    
    newargv[0] = [X11App prefs_get_string:@@PREFS_LOGIN_SHELL default:"/bin/sh"];
d351 1
a351 1
    
d361 32
a392 32
        case -1:                                /* error */
            break;
      
        case 0:                                 /* child1 */
            child2 = fork();
      
            switch (child2) {
                int max_files, i;
	
                case -1:                            /* error */
                    _exit(1);
	 
                case 0:                             /* child2 */
                /* close all open files except for standard streams */
                max_files = sysconf(_SC_OPEN_MAX);
                for(i = 3; i < max_files; i++)
                    close(i);
	
                /* ensure stdin is on /dev/null */
                close(0);
                open("/dev/null", O_RDONLY);
	
                execvp(newargv[0], (char **const) newargv);
                _exit(2);
	
                default:                            /* parent (child1) */
                _exit(0);
            }
            break;
      
        default:                                /* parent */
            waitpid(child1, &status, 0);
d398 10
a407 10
  int tag;
  NSString *item;
  
  tag = [sender tag] - 1;
  if (apps == nil || tag < 0 || tag >= [apps count])
    return;
  
  item = [[apps objectAtIndex:tag] objectAtIndex:1];
  
  [self launch_client:item];
d412 23
a434 22
  NSArray *columns;
  NSMutableArray *oldapps = nil;
	
  if (table_apps != nil)
    oldapps = table_apps;

  table_apps = [[NSMutableArray alloc] initWithCapacity:1];
  if(apps != nil)
      [table_apps addObjectsFromArray:apps];
	
  columns = [apps_table tableColumns];
  [[columns objectAtIndex:0] setIdentifier:@@"0"];
  [[columns objectAtIndex:1] setIdentifier:@@"1"];
  [[columns objectAtIndex:2] setIdentifier:@@"2"];
	
  [apps_table setDataSource:self];
  [apps_table selectRowIndexes:[NSIndexSet indexSetWithIndex:0] byExtendingSelection:NO];

  [[apps_table window] makeKeyAndOrderFront:sender];
  [apps_table reloadData];
  if(oldapps != nil)
    [oldapps release];
d439 12
a450 12
  [apps_table deselectAll:sender];	/* flush edits? */
	
  [self remove_apps_menu];
  [self install_apps_menu:table_apps];
	
  [NSApp prefs_set_array:@@PREFS_APPSMENU value:table_apps];
  [NSApp prefs_synchronize];
	
  [[apps_table window] orderOut:sender];
	
  [table_apps release];
  table_apps = nil;
d455 24
a478 23
  NSMutableArray *item;
	
  int row = [apps_table selectedRow], i;
	
  if (row < 0) row = 0;
  else row = row + 1;
	
  i = row;
  if (i > [table_apps count])
    return;				/* avoid exceptions */
	
  [apps_table deselectAll:sender];
	
  item = [[NSMutableArray alloc] initWithCapacity:3];
  [item addObject:@@""];
  [item addObject:@@""];
  [item addObject:@@""];
	
  [table_apps insertObject:item atIndex:i];
  [item release];
	
  [apps_table reloadData];
  [apps_table selectRowIndexes:[NSIndexSet indexSetWithIndex:row] byExtendingSelection:NO];
d483 20
a502 19
  int row = [apps_table selectedRow], i;
  NSObject *item;
	
  if (row < 0) {
    [self apps_table_new:sender];
    return;
  }
	
  i = row;
  if (i > [table_apps count] - 1) return;				/* avoid exceptions */
    
  [apps_table deselectAll:sender];
	
  item = [[table_apps objectAtIndex:i] mutableCopy];
  [table_apps insertObject:item atIndex:i];
  [item release];
	
  [apps_table reloadData];
  [apps_table selectRowIndexes:[NSIndexSet indexSetWithIndex:row+1] byExtendingSelection:NO];
d507 18
a524 18
  int row = [apps_table selectedRow];
	
  if (row >= 0)
    {
      int i = row;
      
      if (i > [table_apps count] - 1) return;			/* avoid exceptions */
      
      [apps_table deselectAll:sender];
      
      [table_apps removeObjectAtIndex:i];
    }
	
  [apps_table reloadData];
	
  row = MIN (row, [table_apps count] - 1);
  if (row >= 0)
    [apps_table selectRowIndexes:[NSIndexSet indexSetWithIndex:row] byExtendingSelection:NO];
d529 20
a548 20
  if (table_apps == nil) return 0;
  
  return [table_apps count];
}

- (id) tableView:(NSTableView *)tableView
objectValueForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row
{
  NSArray *item;
  int col;
	
  if (table_apps == nil) return nil;
	
  col = [[tableColumn identifier] intValue];
	
  item = [table_apps objectAtIndex:row];
  if ([item count] > col)
    return [item objectAtIndex:col];
  else
    return @@"";
d554 9
a562 9
  NSMutableArray *item;
  int col;
	
  if (table_apps == nil) return;
	
  col = [[tableColumn identifier] intValue];
	
  item = [table_apps objectAtIndex:row];
  [item replaceObjectAtIndex:col withObject:object];
d567 4
a570 4
  if ([X11App x_active])
    DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMHideWindow);
  else
    NSBeep ();			/* FIXME: something here */
d575 1
a575 1
  DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMBringAllToFront);
d580 4
a583 4
  if ([X11App x_active])
    DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMCloseWindow);
  else
    [[NSApp keyWindow] performClose:sender];
d588 4
a591 4
  if ([X11App x_active])
    DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMMinimizeWindow);
  else
    [[NSApp keyWindow] performMiniaturize:sender];
d596 4
a599 4
  if ([X11App x_active])
    DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMZoomWindow);
  else
    [[NSApp keyWindow] performZoom:sender];
d604 1
a604 1
  DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMNextWindow);
d609 1
a609 1
  DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMPreviousWindow);
d612 2
a613 1
- (IBAction) enable_fullscreen_changed:sender {
d617 2
a618 1
    [enable_fullscreen_menu_text setTextColor:XQuartzRootlessDefault ? [NSColor disabledControlTextColor] : [NSColor controlTextColor]];
d628 1
a628 1
  DarwinSendDDXEvent(kXquartzToggleFullscreen, 0);
d633 1
a633 1
  can_quit = state;
d638 1
a638 1
    if(!sender)
d640 2
a641 2
    
    if(sender == fake_buttons) {
d644 7
a650 4
    } else if(sender == enable_keyequivs) {
        XQuartzEnableKeyEquivalents =  [enable_keyequivs intValue];
        [NSApp prefs_set_boolean:@@PREFS_KEYEQUIVS value:XQuartzEnableKeyEquivalents];
    } else if(sender == sync_keymap) {
d653 2
a654 1
    } else if(sender == enable_fullscreen_menu) {
d656 4
a659 2
        [NSApp prefs_set_boolean:@@PREFS_FULLSCREEN_MENU value:XQuartzFullscreenMenu];
    } else if(sender == option_sends_alt) {
d661 1
a661 1
        
d663 2
a664 1
        [NSApp prefs_set_boolean:@@PREFS_OPTION_SENDS_ALT value:XQuartzOptionSendsAlt];
d666 1
a666 1
        if(prev_opt_sends_alt != XQuartzOptionSendsAlt)
d668 18
a685 9
    } else if(sender == click_through) {
        [NSApp prefs_set_boolean:@@PREFS_CLICK_THROUGH value:[click_through intValue]];
    } else if(sender == focus_follows_mouse) {
        [NSApp prefs_set_boolean:@@PREFS_FFM value:[focus_follows_mouse intValue]];
    } else if(sender == focus_on_new_window) {
        [NSApp prefs_set_boolean:@@PREFS_FOCUS_ON_NEW_WINDOW value:[focus_on_new_window intValue]];
    } else if(sender == enable_auth) {
        [NSApp prefs_set_boolean:@@PREFS_NO_AUTH value:![enable_auth intValue]];
    } else if(sender == enable_tcp) {
d687 2
a688 1
    } else if(sender == depth) {
d690 2
a691 1
    } else if(sender == sync_pasteboard) {
d701 26
a726 13
        [sync_text1 setTextColor:pbproxy_active ? [NSColor controlTextColor] : [NSColor disabledControlTextColor]];
        [sync_text2 setTextColor:pbproxy_active ? [NSColor controlTextColor] : [NSColor disabledControlTextColor]];
    } else if(sender == sync_pasteboard_to_clipboard) {
        [NSApp prefs_set_boolean:@@PREFS_SYNC_PB_TO_CLIPBOARD value:[sync_pasteboard_to_clipboard intValue]];
    } else if(sender == sync_pasteboard_to_primary) {
        [NSApp prefs_set_boolean:@@PREFS_SYNC_PB_TO_PRIMARY value:[sync_pasteboard_to_primary intValue]];
    } else if(sender == sync_clipboard_to_pasteboard) {
        [NSApp prefs_set_boolean:@@PREFS_SYNC_CLIPBOARD_TO_PB value:[sync_clipboard_to_pasteboard intValue]];
    } else if(sender == sync_primary_immediately) {
        [NSApp prefs_set_boolean:@@PREFS_SYNC_PRIMARY_ON_SELECT value:[sync_primary_immediately intValue]];
    } else if(sender == scroll_in_device_direction) {
        XQuartzScrollInDeviceDirection = [scroll_in_device_direction intValue];
        [NSApp prefs_set_boolean:@@PREFS_SCROLL_IN_DEV_DIRECTION value:XQuartzScrollInDeviceDirection];
d730 1
a730 1
    
d736 2
a737 1
    BOOL pbproxy_active = [NSApp prefs_get_boolean:@@PREFS_SYNC_PB default:YES];
d741 1
a741 1
    if(scroll_in_device_direction && NSAppKitVersionNumber < 1117) {
a743 2
    } else {
        [scroll_in_device_direction setIntValue:XQuartzScrollInDeviceDirection];
d745 5
a749 1
    
d754 17
a770 8
    [click_through setIntValue:[NSApp prefs_get_boolean:@@PREFS_CLICK_THROUGH default:NO]];
    [focus_follows_mouse setIntValue:[NSApp prefs_get_boolean:@@PREFS_FFM default:NO]];
    [focus_on_new_window setIntValue:[NSApp prefs_get_boolean:@@PREFS_FOCUS_ON_NEW_WINDOW default:YES]];
    
    [enable_auth setIntValue:![NSApp prefs_get_boolean:@@PREFS_NO_AUTH default:NO]];
    [enable_tcp setIntValue:![NSApp prefs_get_boolean:@@PREFS_NO_TCP default:NO]];

    [depth selectItemAtIndex:[depth indexOfItemWithTag:[NSApp prefs_get_integer:@@PREFS_DEPTH default:-1]]];
d773 12
a784 4
    [sync_pasteboard_to_clipboard setIntValue:[NSApp prefs_get_boolean:@@PREFS_SYNC_PB_TO_CLIPBOARD default:YES]];
    [sync_pasteboard_to_primary setIntValue:[NSApp prefs_get_boolean:@@PREFS_SYNC_PB_TO_PRIMARY default:YES]];
    [sync_clipboard_to_pasteboard setIntValue:[NSApp prefs_get_boolean:@@PREFS_SYNC_CLIPBOARD_TO_PB default:YES]];
    [sync_primary_immediately setIntValue:[NSApp prefs_get_boolean:@@PREFS_SYNC_PRIMARY_ON_SELECT default:NO]];
d792 5
a796 3
    [sync_text1 setTextColor:pbproxy_active ? [NSColor controlTextColor] : [NSColor disabledControlTextColor]];
    [sync_text2 setTextColor:pbproxy_active ? [NSColor controlTextColor] : [NSColor disabledControlTextColor]];
	
d800 2
a801 1
    [enable_fullscreen_menu_text setTextColor:XQuartzRootlessDefault ? [NSColor disabledControlTextColor] : [NSColor controlTextColor]];
d806 2
a807 1
- (IBAction) quit:sender {
d811 2
a812 1
- (IBAction) x11_help:sender {
d814 3
a816 1
    AHLookupAnchor((CFStringRef)NSLocalizedString(@@"Mac Help", no comment), CFSTR("mchlp2276"));
d822 11
a832 10
- (OSX_BOOL) validateMenuItem:(NSMenuItem *)item {
  NSMenu *menu = [item menu];
    
  if (item == toggle_fullscreen_item)
    return !XQuartzIsRootless;
  else if (menu == [X11App windowsMenu] || menu == dock_menu
	   || (menu == [x11_about_item menu] && [item tag] == 42))
    return (AppleWMSelectedEvents () & AppleWMControllerNotifyMask) != 0;
  else
    return TRUE;
d837 8
a844 1
  DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMHideAll);
d849 1
a849 1
  DarwinSendDDXEvent(kXquartzControllerNotify, 1, AppleWMShowAll);
d852 2
a853 1
- (NSApplicationTerminateReply) applicationShouldTerminate:sender {
d856 3
a858 2
	
    if (can_quit || [X11App prefs_get_boolean:@@PREFS_NO_QUIT_ALERT default:NO])
d860 1
a860 1
	
d863 6
a868 3
	
    title = NSLocalizedString(@@"Do you really want to quit X11?", @@"Dialog title when quitting");
    msg = NSLocalizedString(@@"Any open X11 applications will stop immediately, and you will lose any unsaved changes.", @@"Dialog when quitting");
d873 3
a875 3
	
    return (NSRunAlertPanel (title, msg, NSLocalizedString (@@"Quit", @@""),
                             NSLocalizedString (@@"Cancel", @@""), nil)
d881 2
a882 9
  unsigned remain;
  [X11App prefs_synchronize];
	
  /* shutdown the X server, it will exit () for us. */
  DarwinSendDDXEvent(kXquartzQuit, 0);
	
  /* In case it doesn't, exit anyway after a while. */
  remain = 10000000;
  while((remain = usleep(remain)) > 0);
d884 8
a891 1
  exit (1);
d896 12
a907 13
  x_list *node;
	
  finished_launching = YES;
	
  for (node = pending_apps; node != NULL; node = node->next)
    {
      NSString *filename = node->data;
      [self launch_client:filename];
      [filename release];
    }
	
  x_list_free (pending_apps);
  pending_apps = NULL;
d913 1
a913 1
    
d916 3
a918 3
    else if (name[0] != ':')		/* ignore display names */
        pending_apps = x_list_prepend (pending_apps, [filename retain]);
    
d925 4
a928 2
void X11ControllerMain(int argc, char **argv, char **envp) {
    X11ApplicationMain (argc, argv, envp);
@


1.5
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d615 1
d690 3
d703 9
d742 1
d744 2
a745 2
    [enable_fullscreen_menu setIntValue:XQuartzFullscreenMenu];
    
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a639 3
    } else if(sender == use_sysbeep) {
        XQuartzUseSysBeep = [use_sysbeep intValue];
        [NSApp prefs_set_boolean:@@PREFS_SYSBEEP value:XQuartzUseSysBeep];
a700 1
    [use_sysbeep setIntValue:XQuartzUseSysBeep];
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d612 1
a612 1
    int value = ![enable_fullscreen intValue];
d614 1
a614 1
    [enable_fullscreen_menu setEnabled:!value];
d616 1
a616 1
    DarwinSendDDXEvent(kXquartzSetRootless, 1, value);
d618 1
a618 1
    [NSApp prefs_set_boolean:@@PREFS_ROOTLESS value:value];
d641 2
a642 2
        quartzUseSysBeep = [use_sysbeep intValue];
        [NSApp prefs_set_boolean:@@PREFS_SYSBEEP value:quartzUseSysBeep];
d644 2
a645 2
        X11EnableKeyEquivalents =  [enable_keyequivs intValue];
        [NSApp prefs_set_boolean:@@PREFS_KEYEQUIVS value:X11EnableKeyEquivalents];
d650 2
a651 2
        quartzFullscreenMenu = [enable_fullscreen_menu intValue];
        [NSApp prefs_set_boolean:@@PREFS_FULLSCREEN_MENU value:quartzFullscreenMenu];
d653 1
a653 1
        BOOL prev_opt_sends_alt = quartzOptionSendsAlt;
d655 2
a656 2
        quartzOptionSendsAlt = [option_sends_alt intValue];
        [NSApp prefs_set_boolean:@@PREFS_OPTION_SENDS_ALT value:quartzOptionSendsAlt];
d658 1
a658 1
        if(prev_opt_sends_alt != quartzOptionSendsAlt)
d704 2
a705 2
    [use_sysbeep setIntValue:quartzUseSysBeep];
    [enable_keyequivs setIntValue:X11EnableKeyEquivalents];
d707 1
a707 1
    [option_sends_alt setIntValue:quartzOptionSendsAlt];
d732 3
a734 3
    [enable_fullscreen setIntValue:!quartzEnableRootless];
    [enable_fullscreen_menu setEnabled:!quartzEnableRootless];
    [enable_fullscreen_menu setIntValue:quartzFullscreenMenu];
d755 1
a755 1
    return !quartzEnableRootless;
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d46 2
a47 2
#define _APPLEWM_SERVER_
#include "X11/extensions/applewm.h"
a55 2
BOOL xquartz_resetenv_display = NO;

d104 6
d111 1
d125 2
a126 2
  int first, count, i;
	
d128 1
a128 2
  menu = [window_separator menu];
  first = [menu indexOfItem:window_separator] + 1;
d130 1
a130 1
  for (i = count - 1; i >= first; i--)
d133 1
a133 2
  menu = [dock_window_separator menu];
  count = [menu indexOfItem:dock_window_separator];
d144 2
a145 2
  menu = [window_separator menu];
  first = [menu indexOfItem:window_separator] + 1;
d147 6
a164 1
#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
a165 3
#else
      [item setKeyEquivalentModifierMask:windowItemModMask];
#endif
a173 1
#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
a174 3
#else
      [item setKeyEquivalentModifierMask:windowItemModMask];
#endif
d289 2
a290 2
  menu = [window_separator menu];
  first = [menu indexOfItem:window_separator] + 1;
d316 25
d355 1
a355 1
    if (xquartz_resetenv_display || s == NULL || s[0] == 0) {
d430 2
a431 2
  [apps_table selectRow:0 byExtendingSelection:NO];
	
d478 1
a478 1
  [apps_table selectRow:row byExtendingSelection:NO];
d501 1
a501 1
  [apps_table selectRow:row+1 byExtendingSelection:NO];
d523 1
a523 1
    [apps_table selectRow:row byExtendingSelection:NO];
d526 1
a526 1
- (int) numberOfRowsInTableView:(NSTableView *)tableView
d534 1
a534 1
objectValueForTableColumn:(NSTableColumn *)tableColumn row:(int)row
d551 1
a551 1
    forTableColumn:(NSTableColumn *)tableColumn row:(int)row
d634 59
a692 28
    darwinFakeButtons = [fake_buttons intValue];
    quartzUseSysBeep = [use_sysbeep intValue];
    X11EnableKeyEquivalents = [enable_keyequivs intValue];
    darwinSyncKeymap = [sync_keymap intValue];
    quartzFullscreenMenu = [enable_fullscreen_menu intValue];

    /* after adding prefs here, also add to [X11Application read_defaults]
     and prefs_show */

    [NSApp prefs_set_boolean:@@PREFS_FAKEBUTTONS value:darwinFakeButtons];
    [NSApp prefs_set_boolean:@@PREFS_SYSBEEP value:quartzUseSysBeep];
    [NSApp prefs_set_boolean:@@PREFS_KEYEQUIVS value:X11EnableKeyEquivalents];
    [NSApp prefs_set_boolean:@@PREFS_SYNC_KEYMAP value:darwinSyncKeymap];
    [NSApp prefs_set_boolean:@@PREFS_FULLSCREEN_MENU value:quartzFullscreenMenu];
    [NSApp prefs_set_boolean:@@PREFS_CLICK_THROUGH value:[click_through intValue]];
    [NSApp prefs_set_boolean:@@PREFS_FFM value:[focus_follows_mouse intValue]];
    [NSApp prefs_set_boolean:@@PREFS_FOCUS_ON_NEW_WINDOW value:[focus_on_new_window intValue]];
    [NSApp prefs_set_boolean:@@PREFS_NO_AUTH value:![enable_auth intValue]];
    [NSApp prefs_set_boolean:@@PREFS_NO_TCP value:![enable_tcp intValue]];
    [NSApp prefs_set_integer:@@PREFS_DEPTH value:[depth selectedTag]];

    BOOL pbproxy_active = [sync_pasteboard intValue];

    [NSApp prefs_set_boolean:@@PREFS_SYNC_PB value:pbproxy_active];
    [NSApp prefs_set_boolean:@@PREFS_SYNC_PB_TO_CLIPBOARD value:[sync_pasteboard_to_clipboard intValue]];
    [NSApp prefs_set_boolean:@@PREFS_SYNC_PB_TO_PRIMARY value:[sync_pasteboard_to_primary intValue]];
    [NSApp prefs_set_boolean:@@PREFS_SYNC_CLIPBOARD_TO_PB value:[sync_clipboard_to_pasteboard intValue]];
    [NSApp prefs_set_boolean:@@PREFS_SYNC_PRIMARY_ON_SELECT value:[sync_primary_immediately intValue]];
a694 9

    [sync_pasteboard_to_clipboard setEnabled:pbproxy_active];
    [sync_pasteboard_to_primary setEnabled:pbproxy_active];
    [sync_clipboard_to_pasteboard setEnabled:pbproxy_active];
    [sync_primary_immediately setEnabled:pbproxy_active];
    
    // setEnabled doesn't do this...
    [sync_text1 setTextColor:pbproxy_active ? [NSColor controlTextColor] : [NSColor disabledControlTextColor]];
    [sync_text2 setTextColor:pbproxy_active ? [NSColor controlTextColor] : [NSColor disabledControlTextColor]];
d696 1
a696 1
	DarwinSendDDXEvent(kXquartzReloadPreferences, 0);
d707 1
d756 1
a756 3
  else   if (item == copy_menu_item) // For some reason, this isn't working...
      return NO;
  else if (menu == [window_separator menu] || menu == dock_menu
d797 1
d804 3
a806 1
  while (sleep (10) != 0) ;
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d3 1
a3 1
   Copyright (c) 2002-2007 Apple Inc. All rights reserved.
d30 3
a36 2
#define DEFAULT_PATH "/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/X11/bin"

a40 1
#import <Carbon/Carbon.h>
a41 2
/* ouch! */
#define BOOL X_BOOL
d43 6
a48 6
# include "darwin.h"
# include "quartz.h"
# define _APPLEWM_SERVER_
# include "X11/extensions/applewm.h"
# include "applewmExt.h"
#undef BOOL
d56 2
d100 7
d113 1
a113 1
  QuartzMessageServerThread (kXDarwinControllerNotify, 2,
d140 1
a140 1
	
d150 4
a153 1
		
d156 5
d164 1
a164 1
		
d169 5
d277 1
a277 1
  QuartzMessageServerThread (kXDarwinControllerNotify, 1,
d317 22
a338 20
  const char *command = [filename UTF8String];
  const char *argv[7];
  int child1, child2 = 0;
  int status;
	
  argv[0] = "/usr/bin/login";
  argv[1] = "-fp";
  argv[2] = getlogin();
  argv[3] = [X11App prefs_get_string:@@PREFS_LOGIN_SHELL default:"/bin/sh"];
  argv[4] = "-c";
  argv[5] = command;
  argv[6] = NULL;

  /* Do the fork-twice trick to avoid having to reap zombies */
    
  child1 = fork();
    
  switch (child1) {
  case -1:                                /* error */
    break;
d340 2
a341 2
  case 0:                                 /* child1 */
    child2 = fork();
d343 2
a344 33
    switch (child2) {
      int max_files, i;
      char buf[1024], *temp;
	
    case -1:                            /* error */
      _exit(1);
	
    case 0:                             /* child2 */
      /* close all open files except for standard streams */
      max_files = sysconf(_SC_OPEN_MAX);
      for (i = 3; i < max_files; i++)	close(i);
	
      /* ensure stdin is on /dev/null */
      close(0);
      open("/dev/null", O_RDONLY);
	
      /* Setup environment */
      temp = getenv("DISPLAY");
      if (temp == NULL || temp[0] == 0) {
    snprintf(buf, sizeof(buf), ":%s", display);
	setenv("DISPLAY", buf, TRUE);
      }
	
      temp = getenv("PATH");
      if (temp == NULL || temp[0] == 0) 
	setenv ("PATH", DEFAULT_PATH, TRUE);
      else if (strnstr(temp, "/usr/X11/bin", sizeof(temp)) == NULL) {
	snprintf(buf, sizeof(buf), "%s:/usr/X11/bin", temp);            
	setenv("PATH", buf, TRUE);      
      }
      /* cd $HOME */
      temp = getenv("HOME");
      if (temp != NULL && temp[0]!=0) chdir(temp);
d346 23
a368 6
      execvp(argv[0], (char **const) argv);
	
      _exit(2);
	
    default:                            /* parent (child1) */
      _exit(0);
a369 5
    break;
      
  default:                                /* parent */
    waitpid(child1, &status, 0);
  }
d389 1
d391 6
a396 5
  if (table_apps == nil) {
    table_apps = [[NSMutableArray alloc] initWithCapacity:1];
      
    if (apps != nil)[table_apps addObjectsFromArray:apps];
  }
a406 5
}

- (IBAction) apps_table_cancel:sender
{
  [[apps_table window] orderOut:sender];
d408 2
a409 3
	
  [table_apps release];
  table_apps = nil;
d541 1
a541 1
    QuartzMessageServerThread (kXDarwinControllerNotify, 1, AppleWMHideWindow);
d548 1
a548 1
  QuartzMessageServerThread(kXDarwinControllerNotify, 1, AppleWMBringAllToFront);
d554 1
a554 1
    QuartzMessageServerThread (kXDarwinControllerNotify, 1, AppleWMCloseWindow);
d562 1
a562 1
    QuartzMessageServerThread (kXDarwinControllerNotify, 1, AppleWMMinimizeWindow);
d570 1
a570 1
    QuartzMessageServerThread (kXDarwinControllerNotify, 1, AppleWMZoomWindow);
d577 1
a577 1
  QuartzMessageServerThread (kXDarwinControllerNotify, 1, AppleWMNextWindow);
d582 1
a582 1
  QuartzMessageServerThread (kXDarwinControllerNotify, 1, AppleWMPreviousWindow);
d585 9
a593 10
- (IBAction) enable_fullscreen_changed:sender
{
  int value = ![enable_fullscreen intValue];
	
#ifdef DARWIN_DDX_MISSING
  QuartzMessageServerThread (kXDarwinSetRootless, 1, value);
#endif
	
  [NSApp prefs_set_boolean:@@PREFS_ROOTLESS value:value];
  [NSApp prefs_synchronize];
d598 1
a598 3
#ifdef DARWIN_DDX_MISSING
  QuartzMessageServerThread (kXDarwinToggleFullscreen, 0);
#endif
d601 1
a601 1
- (void) set_can_quit:(BOOL)state
d608 41
a648 18
  darwinFakeButtons = [fake_buttons intValue];
  quartzUseSysBeep = [use_sysbeep intValue];
  X11EnableKeyEquivalents = [enable_keyequivs intValue];
  darwinSyncKeymap = [sync_keymap intValue];

  /* after adding prefs here, also add to [X11Application read_defaults]
     and below */
	
  [NSApp prefs_set_boolean:@@PREFS_FAKEBUTTONS value:darwinFakeButtons];
  [NSApp prefs_set_boolean:@@PREFS_SYSBEEP value:quartzUseSysBeep];
  [NSApp prefs_set_boolean:@@PREFS_KEYEQUIVS value:X11EnableKeyEquivalents];
  [NSApp prefs_set_boolean:@@PREFS_SYNC_KEYMAP value:darwinSyncKeymap];
  [NSApp prefs_set_boolean:@@PREFS_QUARTZ_WM_CLICK_THROUGH value:[click_through intValue]];
  [NSApp prefs_set_boolean:@@PREFS_NO_AUTH value:![enable_auth intValue]];
  [NSApp prefs_set_boolean:@@PREFS_NO_TCP value:![enable_tcp intValue]];
  [NSApp prefs_set_integer:@@PREFS_DEPTH value:[depth selectedTag]];
	
  [NSApp prefs_synchronize];
d653 35
a687 14
  [fake_buttons setIntValue:darwinFakeButtons];
  [use_sysbeep setIntValue:quartzUseSysBeep];
  [enable_keyequivs setIntValue:X11EnableKeyEquivalents];
  [sync_keymap setIntValue:darwinSyncKeymap];
  [sync_keymap setEnabled:darwinKeymapFile == NULL];
  [click_through setIntValue:[NSApp prefs_get_boolean:@@PREFS_QUARTZ_WM_CLICK_THROUGH default:NO]];
	
  [enable_auth setIntValue:![NSApp prefs_get_boolean:@@PREFS_NO_AUTH default:NO]];
  [enable_tcp setIntValue:![NSApp prefs_get_boolean:@@PREFS_NO_TCP default:NO]];
  [depth selectItemAtIndex:[depth indexOfItemWithTag:[NSApp prefs_get_integer:@@PREFS_DEPTH default:-1]]];
	
  [enable_fullscreen setIntValue:!quartzEnableRootless];
	
  [prefs_panel makeKeyAndOrderFront:sender];
d690 2
a691 3
- (IBAction) quit:sender
{
  QuartzMessageServerThread (kXDarwinQuit, 0);
d694 6
a699 3
- (IBAction) x11_help:sender
{
  AHLookupAnchor ((CFStringRef)NSLocalizedString(@@"Mac Help", no comment), CFSTR ("mchlp2276"));
d702 1
a702 2
- (BOOL) validateMenuItem:(NSMenuItem *)item
{
d704 1
a704 1
	
d707 2
d718 1
a718 1
  QuartzMessageServerThread (kXDarwinControllerNotify, 1, AppleWMHideAll);
d723 1
a723 1
  QuartzMessageServerThread (kXDarwinControllerNotify, 1, AppleWMShowAll);
d726 3
a728 6
- (NSApplicationTerminateReply) applicationShouldTerminate:sender
{
  NSString *msg;
	
  if (can_quit || [X11App prefs_get_boolean:@@PREFS_NO_QUIT_ALERT default:NO])
    return NSTerminateNow;
d730 2
a731 2
  /* Make sure we're frontmost. */
  [NSApp activateIgnoringOtherApps:YES];
d733 2
a734 1
  msg = NSLocalizedString (@@"Are you sure you want to quit X11?\n\nIf you quit X11, any X11 applications you are running will stop immediately and you will lose any changes you have not saved.", @@"Dialog when quitting");
d736 6
a741 2
  /* FIXME: safe to run the alert in here? Or should we return Later
     and then run the alert on a timer? It seems to work here, so.. */
d743 3
a745 3
  return (NSRunAlertPanel (nil, msg, NSLocalizedString (@@"Quit", @@""),
			   NSLocalizedString (@@"Cancel", @@""), nil)
	  == NSAlertDefaultReturn) ? NSTerminateNow : NSTerminateCancel;
d753 1
a753 1
  QuartzMessageServerThread (kXDarwinQuit, 0);
d777 1
a777 1
- (BOOL) application:(NSApplication *)app openFile:(NSString *)filename
d779 9
a787 9
  const char *name = [filename UTF8String];
	
  if (finished_launching)
    [self launch_client:filename];
  else if (name[0] != ':')		/* ignore display names */
    pending_apps = x_list_prepend (pending_apps, [filename retain]);
	
  /* FIXME: report failures. */
  return YES;
d792 2
a793 2
void X11ControllerMain(int argc, const char **argv, void (*server_thread) (void *), void *server_arg) {
    X11ApplicationMain (argc, argv, server_thread, server_arg);
@

