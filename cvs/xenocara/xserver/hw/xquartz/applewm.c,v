head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.53;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.29;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright (c) 2003 Torrey T. Lyons. All Rights Reserved.
 * Copyright (c) 2002-2012 Apple Inc. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT
 * HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above
 * copyright holders shall not be used in advertising or otherwise to
 * promote the sale, use or other dealings in this Software without
 * prior written authorization.
 */

#include "sanitizedCarbon.h"

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "quartzCommon.h"

#include "misc.h"
#include "dixstruct.h"
#include "globals.h"
#include "extnsionst.h"
#include "colormapst.h"
#include "cursorstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "servermd.h"
#include "swaprep.h"
#include "propertyst.h"
#include <X11/Xatom.h>
#include "darwin.h"
#define _APPLEWM_SERVER_
#include <X11/extensions/applewmproto.h>
#include "applewmExt.h"
#include "X11Application.h"
#include "protocol-versions.h"

#define DEFINE_ATOM_HELPER(func, atom_name)                      \
    static Atom func(void) {                                       \
        static int generation;                                      \
        static Atom atom;                                           \
        if (generation != serverGeneration) {                       \
            generation = serverGeneration;                          \
            atom = MakeAtom(atom_name, strlen(atom_name), TRUE);  \
        }                                                           \
        return atom;                                                \
    }

DEFINE_ATOM_HELPER(xa_native_screen_origin, "_NATIVE_SCREEN_ORIGIN")
DEFINE_ATOM_HELPER(xa_apple_no_order_in, "_APPLE_NO_ORDER_IN")

static AppleWMProcsPtr appleWMProcs;

static int WMErrorBase;

static unsigned char WMReqCode = 0;
static int WMEventBase = 0;

static RESTYPE ClientType, EventType; /* resource types for event masks */
static XID eventResource;

/* Currently selected events */
static unsigned int eventMask = 0;

static int
WMFreeClient(void *data, XID id);
static int
WMFreeEvents(void *data, XID id);
static void
SNotifyEvent(xAppleWMNotifyEvent *from, xAppleWMNotifyEvent *to);

typedef struct _WMEvent *WMEventPtr;
typedef struct _WMEvent {
    WMEventPtr next;
    ClientPtr client;
    XID clientResource;
    unsigned int mask;
} WMEventRec;

static inline BoxRec
make_box(int x, int y, int w, int h)
{
    BoxRec r;
    r.x1 = x;
    r.y1 = y;
    r.x2 = x + w;
    r.y2 = y + h;
    return r;
}

/* Updates the _NATIVE_SCREEN_ORIGIN property on the given root window. */
void
AppleWMSetScreenOrigin(WindowPtr pWin)
{
    int32_t data[2];

    data[0] = pWin->drawable.pScreen->x + darwinMainScreenX;
    data[1] = pWin->drawable.pScreen->y + darwinMainScreenY;

    dixChangeWindowProperty(serverClient, pWin, xa_native_screen_origin(),
                            XA_INTEGER, 32, PropModeReplace, 2, data, TRUE);
}

/* Window managers can set the _APPLE_NO_ORDER_IN property on windows
   that are being genie-restored from the Dock. We want them to
   be mapped but remain ordered-out until the animation
   completes (when the Dock will order them in). */
Bool
AppleWMDoReorderWindow(WindowPtr pWin)
{
    Atom atom;
    PropertyPtr prop;
    int rc;

    atom = xa_apple_no_order_in();
    rc = dixLookupProperty(&prop, pWin, atom, serverClient, DixReadAccess);

    if (Success == rc && prop->type == atom)
        return 0;

    return 1;
}

static int
ProcAppleWMQueryVersion(register ClientPtr client)
{
    xAppleWMQueryVersionReply rep;

    REQUEST_SIZE_MATCH(xAppleWMQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_APPLEWM_MAJOR_VERSION;
    rep.minorVersion = SERVER_APPLEWM_MINOR_VERSION;
    rep.patchVersion = SERVER_APPLEWM_PATCH_VERSION;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
    }
    WriteToClient(client, sizeof(xAppleWMQueryVersionReply),&rep);
    return Success;
}

/* events */

static inline void
updateEventMask(WMEventPtr *pHead)
{
    WMEventPtr pCur;

    eventMask = 0;
    for (pCur = *pHead; pCur != NULL; pCur = pCur->next)
        eventMask |= pCur->mask;
}

/*ARGSUSED*/
static int
WMFreeClient(void *data, XID id)
{
    WMEventPtr pEvent;
    WMEventPtr   *pHead, pCur, pPrev;
    int i;

    pEvent = (WMEventPtr)data;
    i = dixLookupResourceByType(
        (void **)&pHead, eventResource, EventType, serverClient,
        DixReadAccess |
        DixWriteAccess | DixDestroyAccess);
    if (i == Success && pHead) {
        pPrev = 0;
        for (pCur = *pHead; pCur && pCur != pEvent; pCur = pCur->next)
            pPrev = pCur;
        if (pCur) {
            if (pPrev)
                pPrev->next = pEvent->next;
            else
                *pHead = pEvent->next;
        }
        updateEventMask(pHead);
    }
    free((void *)pEvent);
    return 1;
}

/*ARGSUSED*/
static int
WMFreeEvents(void *data, XID id)
{
    WMEventPtr   *pHead, pCur, pNext;

    pHead = (WMEventPtr *)data;
    for (pCur = *pHead; pCur; pCur = pNext) {
        pNext = pCur->next;
        FreeResource(pCur->clientResource, ClientType);
        free((void *)pCur);
    }
    free((void *)pHead);
    eventMask = 0;
    return 1;
}

static int
ProcAppleWMSelectInput(register ClientPtr client)
{
    REQUEST(xAppleWMSelectInputReq);
    WMEventPtr pEvent, pNewEvent, *pHead;
    XID clientResource;
    int i;

    REQUEST_SIZE_MATCH(xAppleWMSelectInputReq);
    i =
        dixLookupResourceByType((void **)&pHead, eventResource, EventType,
                                client,
                                DixWriteAccess);
    if (stuff->mask != 0) {
        if (i == Success && pHead) {
            /* check for existing entry. */
            for (pEvent = *pHead; pEvent; pEvent = pEvent->next) {
                if (pEvent->client == client) {
                    pEvent->mask = stuff->mask;
                    updateEventMask(pHead);
                    return Success;
                }
            }
        }

        /* build the entry */
        pNewEvent = (WMEventPtr)malloc(sizeof(WMEventRec));
        if (!pNewEvent)
            return BadAlloc;
        pNewEvent->next = 0;
        pNewEvent->client = client;
        pNewEvent->mask = stuff->mask;
        /*
         * add a resource that will be deleted when
         * the client goes away
         */
        clientResource = FakeClientID(client->index);
        pNewEvent->clientResource = clientResource;
        if (!AddResource(clientResource, ClientType, (void *)pNewEvent))
            return BadAlloc;
        /*
         * create a resource to contain a pointer to the list
         * of clients selecting input.  This must be indirect as
         * the list may be arbitrarily rearranged which cannot be
         * done through the resource database.
         */
        if (i != Success || !pHead) {
            pHead = (WMEventPtr *)malloc(sizeof(WMEventPtr));
            if (!pHead ||
                !AddResource(eventResource, EventType, (void *)pHead)) {
                FreeResource(clientResource, RT_NONE);
                return BadAlloc;
            }
            *pHead = 0;
        }
        pNewEvent->next = *pHead;
        *pHead = pNewEvent;
        updateEventMask(pHead);
    }
    else if (stuff->mask == 0) {
        /* delete the interest */
        if (i == Success && pHead) {
            pNewEvent = 0;
            for (pEvent = *pHead; pEvent; pEvent = pEvent->next) {
                if (pEvent->client == client)
                    break;
                pNewEvent = pEvent;
            }
            if (pEvent) {
                FreeResource(pEvent->clientResource, ClientType);
                if (pNewEvent)
                    pNewEvent->next = pEvent->next;
                else
                    *pHead = pEvent->next;
                free(pEvent);
                updateEventMask(pHead);
            }
        }
    }
    else {
        client->errorValue = stuff->mask;
        return BadValue;
    }
    return Success;
}

/*
 * deliver the event
 */

void
AppleWMSendEvent(int type, unsigned int mask, int which, int arg)
{
    WMEventPtr      *pHead, pEvent;
    xAppleWMNotifyEvent se;
    int i;

    i =
        dixLookupResourceByType((void **)&pHead, eventResource, EventType,
                                serverClient,
                                DixReadAccess);
    if (i != Success || !pHead)
        return;
    for (pEvent = *pHead; pEvent; pEvent = pEvent->next) {
        if ((pEvent->mask & mask) == 0)
            continue;
        se.type = type + WMEventBase;
        se.kind = which;
        se.arg = arg;
        se.time = currentTime.milliseconds;
        WriteEventsToClient(pEvent->client, 1, (xEvent *)&se);
    }
}

/* Safe to call from any thread. */
unsigned int
AppleWMSelectedEvents(void)
{
    return eventMask;
}

/* general utility functions */

static int
ProcAppleWMDisableUpdate(register ClientPtr client)
{
    REQUEST_SIZE_MATCH(xAppleWMDisableUpdateReq);

    appleWMProcs->DisableUpdate();

    return Success;
}

static int
ProcAppleWMReenableUpdate(register ClientPtr client)
{
    REQUEST_SIZE_MATCH(xAppleWMReenableUpdateReq);

    appleWMProcs->EnableUpdate();

    return Success;
}

/* window functions */

static int
ProcAppleWMSetWindowMenu(register ClientPtr client)
{
    const char *bytes, **items;
    char *shortcuts;
    int max_len, nitems, i, j;
    REQUEST(xAppleWMSetWindowMenuReq);

    REQUEST_AT_LEAST_SIZE(xAppleWMSetWindowMenuReq);

    nitems = stuff->nitems;
    items = malloc(sizeof(char *) * nitems);
    shortcuts = malloc(sizeof(char) * nitems);

    if (!items || !shortcuts) {
        free(items);
        free(shortcuts);

        return BadAlloc;
    }

    max_len = (stuff->length << 2) - sizeof(xAppleWMSetWindowMenuReq);
    bytes = (char *)&stuff[1];

    for (i = j = 0; i < max_len && j < nitems;) {
        shortcuts[j] = bytes[i++];
        items[j++] = bytes + i;

        while (i < max_len)
        {
            if (bytes[i++] == 0)
                break;
        }
    }

    /* Check if we bailed out of the above loop due to a request that was too long */
    if (j < nitems) {
        free(items);
        free(shortcuts);

        return BadRequest;
    }

    X11ApplicationSetWindowMenu(nitems, items, shortcuts);
    free(items);
    free(shortcuts);

    return Success;
}

static int
ProcAppleWMSetWindowMenuCheck(register ClientPtr client)
{
    REQUEST(xAppleWMSetWindowMenuCheckReq);

    REQUEST_SIZE_MATCH(xAppleWMSetWindowMenuCheckReq);
    X11ApplicationSetWindowMenuCheck(stuff->index);
    return Success;
}

static int
ProcAppleWMSetFrontProcess(register ClientPtr client)
{
    REQUEST_SIZE_MATCH(xAppleWMSetFrontProcessReq);

    X11ApplicationSetFrontProcess();
    return Success;
}

static int
ProcAppleWMSetWindowLevel(register ClientPtr client)
{
    REQUEST(xAppleWMSetWindowLevelReq);
    WindowPtr pWin;
    int err;

    REQUEST_SIZE_MATCH(xAppleWMSetWindowLevelReq);

    if (Success != dixLookupWindow(&pWin, stuff->window, client,
                                   DixReadAccess))
        return BadValue;

    if (stuff->level >= AppleWMNumWindowLevels) {
        return BadValue;
    }

    err = appleWMProcs->SetWindowLevel(pWin, stuff->level);
    if (err != Success) {
        return err;
    }

    return Success;
}

static int
ProcAppleWMSendPSN(register ClientPtr client)
{
    REQUEST(xAppleWMSendPSNReq);
    int err;

    REQUEST_SIZE_MATCH(xAppleWMSendPSNReq);

    if (!appleWMProcs->SendPSN)
        return BadRequest;

    err = appleWMProcs->SendPSN(stuff->psn_hi, stuff->psn_lo);
    if (err != Success) {
        return err;
    }

    return Success;
}

static int
ProcAppleWMAttachTransient(register ClientPtr client)
{
    WindowPtr pWinChild, pWinParent;
    REQUEST(xAppleWMAttachTransientReq);
    int err;

    REQUEST_SIZE_MATCH(xAppleWMAttachTransientReq);

    if (!appleWMProcs->AttachTransient)
        return BadRequest;

    if (Success !=
        dixLookupWindow(&pWinChild, stuff->child, client, DixReadAccess))
        return BadValue;

    if (stuff->parent) {
        if (Success !=
            dixLookupWindow(&pWinParent, stuff->parent, client, DixReadAccess))
            return BadValue;
    }
    else {
        pWinParent = NULL;
    }

    err = appleWMProcs->AttachTransient(pWinChild, pWinParent);
    if (err != Success) {
        return err;
    }

    return Success;
}

static int
ProcAppleWMSetCanQuit(register ClientPtr client)
{
    REQUEST(xAppleWMSetCanQuitReq);

    REQUEST_SIZE_MATCH(xAppleWMSetCanQuitReq);

    X11ApplicationSetCanQuit(stuff->state);
    return Success;
}

/* frame functions */

static int
ProcAppleWMFrameGetRect(register ClientPtr client)
{
    xAppleWMFrameGetRectReply rep;
    BoxRec ir, or, rr;
    REQUEST(xAppleWMFrameGetRectReq);

    REQUEST_SIZE_MATCH(xAppleWMFrameGetRectReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    ir = make_box(stuff->ix, stuff->iy, stuff->iw, stuff->ih);
    or = make_box(stuff->ox, stuff->oy, stuff->ow, stuff->oh);

    if (appleWMProcs->FrameGetRect(stuff->frame_rect,
                                   stuff->frame_class,
                                   &or, &ir, &rr) != Success) {
        return BadValue;
    }

    rep.x = rr.x1;
    rep.y = rr.y1;
    rep.w = rr.x2 - rr.x1;
    rep.h = rr.y2 - rr.y1;

    WriteToClient(client, sizeof(xAppleWMFrameGetRectReply),&rep);
    return Success;
}

static int
ProcAppleWMFrameHitTest(register ClientPtr client)
{
    xAppleWMFrameHitTestReply rep;
    BoxRec ir, or;
    int ret;
    REQUEST(xAppleWMFrameHitTestReq);

    REQUEST_SIZE_MATCH(xAppleWMFrameHitTestReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    ir = make_box(stuff->ix, stuff->iy, stuff->iw, stuff->ih);
    or = make_box(stuff->ox, stuff->oy, stuff->ow, stuff->oh);

    if (appleWMProcs->FrameHitTest(stuff->frame_class, stuff->px,
                                   stuff->py, &or, &ir, &ret) != Success) {
        return BadValue;
    }

    rep.ret = ret;

    WriteToClient(client, sizeof(xAppleWMFrameHitTestReply),&rep);
    return Success;
}

static int
ProcAppleWMFrameDraw(register ClientPtr client)
{
    BoxRec ir, or;
    unsigned int title_length, title_max;
    unsigned char *title_bytes;
    REQUEST(xAppleWMFrameDrawReq);
    WindowPtr pWin;

    REQUEST_AT_LEAST_SIZE(xAppleWMFrameDrawReq);

    if (Success != dixLookupWindow(&pWin, stuff->window, client,
                                   DixReadAccess))
        return BadValue;

    ir = make_box(stuff->ix, stuff->iy, stuff->iw, stuff->ih);
    or = make_box(stuff->ox, stuff->oy, stuff->ow, stuff->oh);

    title_length = stuff->title_length;
    title_max = (stuff->length << 2) - sizeof(xAppleWMFrameDrawReq);

    if (title_max < title_length)
        return BadValue;

    title_bytes = (unsigned char *)&stuff[1];

    errno = appleWMProcs->FrameDraw(pWin, stuff->frame_class,
                                    stuff->frame_attr, &or, &ir,
                                    title_length, title_bytes);
    if (errno != Success) {
        return errno;
    }

    return Success;
}

/* dispatch */

static int
ProcAppleWMDispatch(register ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_AppleWMQueryVersion:
        return ProcAppleWMQueryVersion(client);
    }

    if (!client->local)
        return WMErrorBase + AppleWMClientNotLocal;

    switch (stuff->data) {
    case X_AppleWMSelectInput:
        return ProcAppleWMSelectInput(client);

    case X_AppleWMDisableUpdate:
        return ProcAppleWMDisableUpdate(client);

    case X_AppleWMReenableUpdate:
        return ProcAppleWMReenableUpdate(client);

    case X_AppleWMSetWindowMenu:
        return ProcAppleWMSetWindowMenu(client);

    case X_AppleWMSetWindowMenuCheck:
        return ProcAppleWMSetWindowMenuCheck(client);

    case X_AppleWMSetFrontProcess:
        return ProcAppleWMSetFrontProcess(client);

    case X_AppleWMSetWindowLevel:
        return ProcAppleWMSetWindowLevel(client);

    case X_AppleWMSetCanQuit:
        return ProcAppleWMSetCanQuit(client);

    case X_AppleWMFrameGetRect:
        return ProcAppleWMFrameGetRect(client);

    case X_AppleWMFrameHitTest:
        return ProcAppleWMFrameHitTest(client);

    case X_AppleWMFrameDraw:
        return ProcAppleWMFrameDraw(client);

    case X_AppleWMSendPSN:
        return ProcAppleWMSendPSN(client);

    case X_AppleWMAttachTransient:
        return ProcAppleWMAttachTransient(client);

    default:
        return BadRequest;
    }
}

static void
SNotifyEvent(xAppleWMNotifyEvent *from, xAppleWMNotifyEvent *to)
{
    to->type = from->type;
    to->kind = from->kind;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->time, to->time);
    cpswapl(from->arg, to->arg);
}

static int
SProcAppleWMQueryVersion(register ClientPtr client)
{
    REQUEST(xAppleWMQueryVersionReq);
    swaps(&stuff->length);
    return ProcAppleWMQueryVersion(client);
}

static int
SProcAppleWMDispatch(register ClientPtr client)
{
    REQUEST(xReq);

    /* It is bound to be non-local when there is byte swapping */
    if (!client->local)
        return WMErrorBase + AppleWMClientNotLocal;

    /* only local clients are allowed WM access */
    switch (stuff->data) {
    case X_AppleWMQueryVersion:
        return SProcAppleWMQueryVersion(client);

    default:
        return BadRequest;
    }
}

void
AppleWMExtensionInit(AppleWMProcsPtr procsPtr)
{
    ExtensionEntry* extEntry;

    ClientType = CreateNewResourceType(WMFreeClient, "WMClient");
    EventType = CreateNewResourceType(WMFreeEvents, "WMEvent");
    eventResource = FakeClientID(0);

    if (ClientType && EventType &&
        (extEntry = AddExtension(APPLEWMNAME,
                                 AppleWMNumberEvents,
                                 AppleWMNumberErrors,
                                 ProcAppleWMDispatch,
                                 SProcAppleWMDispatch,
                                 NULL,
                                 StandardMinorOpcode))) {
        size_t i;
        WMReqCode = (unsigned char)extEntry->base;
        WMErrorBase = extEntry->errorBase;
        WMEventBase = extEntry->eventBase;
        for (i = 0; i < AppleWMNumberEvents; i++)
            EventSwapVector[WMEventBase + i] = (EventSwapPtr)SNotifyEvent;
        appleWMProcs = procsPtr;
    }
}
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d86 1
a86 1
WMFreeClient(pointer data, XID id);
d88 1
a88 1
WMFreeEvents(pointer data, XID id);
d178 1
a178 1
WMFreeClient(pointer data, XID id)
d186 1
a186 1
        (pointer *)&pHead, eventResource, EventType, serverClient,
d201 1
a201 1
    free((pointer)pEvent);
d207 1
a207 1
WMFreeEvents(pointer data, XID id)
d215 1
a215 1
        free((pointer)pCur);
d217 1
a217 1
    free((pointer)pHead);
d232 1
a232 1
        dixLookupResourceByType((pointer *)&pHead, eventResource, EventType,
d260 1
a260 1
        if (!AddResource(clientResource, ClientType, (pointer)pNewEvent))
d271 1
a271 1
                !AddResource(eventResource, EventType, (pointer)pHead)) {
d320 1
a320 1
        dixLookupResourceByType((pointer *)&pHead, eventResource, EventType,
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d381 7
d401 9
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d160 1
a160 1
    WriteToClient(client, sizeof(xAppleWMQueryVersionReply), (char *)&rep);
d536 1
a536 1
    WriteToClient(client, sizeof(xAppleWMFrameGetRectReply), (char *)&rep);
d563 1
a563 1
    WriteToClient(client, sizeof(xAppleWMFrameHitTestReply), (char *)&rep);
d615 1
a615 1
    if (!LocalClient(client))
d687 1
a687 1
    if (!LocalClient(client))
@


1.5
log
@Update to xserver 1.11.2
@
text
@d1 29
a29 26
/**************************************************************************

Copyright (c) 2002-2007 Apple Inc. All Rights Reserved.
Copyright (c) 2003 Torrey T. Lyons. All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sub license, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/
d58 10
a67 10
#define DEFINE_ATOM_HELPER(func,atom_name)                      \
static Atom func (void) {                                       \
    static int generation;                                      \
    static Atom atom;                                           \
    if (generation != serverGeneration) {                       \
        generation = serverGeneration;                          \
        atom = MakeAtom (atom_name, strlen (atom_name), TRUE);  \
    }                                                           \
    return atom;                                                \
}
d70 1
a70 1
DEFINE_ATOM_HELPER (xa_apple_no_order_in, "_APPLE_NO_ORDER_IN")
a75 1

d85 6
a90 3
static int WMFreeClient (pointer data, XID id);
static int WMFreeEvents (pointer data, XID id);
static void SNotifyEvent(xAppleWMNotifyEvent *from, xAppleWMNotifyEvent *to);
d94 4
a97 4
    WMEventPtr      next;
    ClientPtr       client;
    XID             clientResource;
    unsigned int    mask;
d101 1
a101 1
make_box (int x, int y, int w, int h)
d113 1
a113 3
AppleWMSetScreenOrigin(
    WindowPtr pWin
)
d121 1
a121 1
			    XA_INTEGER, 32, PropModeReplace, 2, data, TRUE);
d129 1
a129 3
AppleWMDoReorderWindow(
    WindowPtr pWin
)
d137 4
a140 4
    
    if(Success == rc && prop->type == atom)
	return 0;
    
a143 1

d145 1
a145 3
ProcAppleWMQueryVersion(
    register ClientPtr client
)
a147 1
    register int n;
d157 2
a158 2
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
a163 1

d167 1
a167 1
updateEventMask (WMEventPtr *pHead)
d178 3
a180 2
WMFreeClient (pointer data, XID id) {
    WMEventPtr   pEvent;
d184 5
a188 2
    pEvent = (WMEventPtr) data;
    i = dixLookupResourceByType((pointer *)&pHead, eventResource, EventType, serverClient, DixReadAccess | DixWriteAccess | DixDestroyAccess);
d191 1
a191 1
        for (pCur = *pHead; pCur && pCur != pEvent; pCur=pCur->next)
d199 1
a199 1
        updateEventMask (pHead);
d201 1
a201 1
    free((pointer) pEvent);
d207 2
a208 1
WMFreeEvents (pointer data, XID id) {
d211 1
a211 1
    pHead = (WMEventPtr *) data;
d214 2
a215 2
        FreeResource (pCur->clientResource, ClientType);
        free((pointer) pCur);
d217 1
a217 1
    free((pointer) pHead);
d223 1
a223 1
ProcAppleWMSelectInput (register ClientPtr client)
d226 3
a228 3
    WMEventPtr      pEvent, pNewEvent, *pHead;
    XID             clientResource;
    int             i;
d230 5
a234 2
    REQUEST_SIZE_MATCH (xAppleWMSelectInputReq);
    i = dixLookupResourceByType((pointer *)&pHead, eventResource, EventType, client, DixWriteAccess);
d238 2
a239 4
            for (pEvent = *pHead; pEvent; pEvent = pEvent->next)
            {
                if (pEvent->client == client)
                {
d241 1
a241 1
                    updateEventMask (pHead);
d248 1
a248 1
        pNewEvent = (WMEventPtr) malloc(sizeof (WMEventRec));
d258 1
a258 1
        clientResource = FakeClientID (client->index);
d260 1
a260 1
        if (!AddResource (clientResource, ClientType, (pointer)pNewEvent))
d268 2
a269 3
        if (i != Success || !pHead)
        {
            pHead = (WMEventPtr *) malloc(sizeof (WMEventPtr));
d271 2
a272 3
                !AddResource (eventResource, EventType, (pointer)pHead))
            {
                FreeResource (clientResource, RT_NONE);
d279 3
a281 2
        updateEventMask (pHead);
    } else if (stuff->mask == 0) {
d291 1
a291 1
                FreeResource (pEvent->clientResource, ClientType);
d297 1
a297 1
                updateEventMask (pHead);
d300 2
a301 1
    } else {
d313 2
a314 1
AppleWMSendEvent (int type, unsigned int mask, int which, int arg) {
d317 1
a317 1
    int             i;
d319 4
a322 1
    i = dixLookupResourceByType((pointer *)&pHead, eventResource, EventType, serverClient, DixReadAccess);
d332 1
a332 1
        WriteEventsToClient (pEvent->client, 1, (xEvent *) &se);
d338 1
a338 1
AppleWMSelectedEvents (void)
a342 1

d346 1
a346 3
ProcAppleWMDisableUpdate(
    register ClientPtr client
)
d356 1
a356 3
ProcAppleWMReenableUpdate(
    register ClientPtr client
)
a364 1

d368 1
a368 3
ProcAppleWMSetWindowMenu(
    register ClientPtr client
)
d378 2
a379 2
    items = malloc(sizeof (char *) * nitems);
    shortcuts = malloc(sizeof (char) * nitems);
d382 1
a382 1
    bytes = (char *) &stuff[1];
d384 1
a384 2
    for (i = j = 0; i < max_len && j < nitems;)
    {
d394 1
a394 1
    X11ApplicationSetWindowMenu (nitems, items, shortcuts);
d402 1
a402 3
ProcAppleWMSetWindowMenuCheck(
    register ClientPtr client
)
d412 1
a412 3
ProcAppleWMSetFrontProcess(
    register ClientPtr client
)
d430 1
a430 1
				   DixReadAccess))
d437 2
a438 2
     err = appleWMProcs->SetWindowLevel(pWin, stuff->level);
     if (err != Success) {
d450 1
a450 1
    
d452 2
a453 2
    
    if(!appleWMProcs->SendPSN)
d470 1
a470 1
    
d472 2
a473 2
    
    if(!appleWMProcs->AttachTransient)
d476 2
a477 1
    if (Success != dixLookupWindow(&pWinChild, stuff->child, client, DixReadAccess))
d480 3
a482 2
    if(stuff->parent) {
        if(Success != dixLookupWindow(&pWinParent, stuff->parent, client, DixReadAccess))
d484 2
a485 1
    } else {
d498 1
a498 3
ProcAppleWMSetCanQuit(
    register ClientPtr client
)
a507 1

d511 1
a511 3
ProcAppleWMFrameGetRect(
    register ClientPtr client
)
d522 2
a523 2
    ir = make_box (stuff->ix, stuff->iy, stuff->iw, stuff->ih);
    or = make_box (stuff->ox, stuff->oy, stuff->ow, stuff->oh);
d527 1
a527 2
                                   &or, &ir, &rr) != Success)
    {
d541 1
a541 3
ProcAppleWMFrameHitTest(
    register ClientPtr client
)
d553 2
a554 2
    ir = make_box (stuff->ix, stuff->iy, stuff->iw, stuff->ih);
    or = make_box (stuff->ox, stuff->oy, stuff->ow, stuff->oh);
d557 1
a557 2
                                   stuff->py, &or, &ir, &ret) != Success)
    {
d568 1
a568 3
ProcAppleWMFrameDraw(
    register ClientPtr client
)
d579 1
a579 1
				   DixReadAccess))
d582 2
a583 2
    ir = make_box (stuff->ix, stuff->iy, stuff->iw, stuff->ih);
    or = make_box (stuff->ox, stuff->oy, stuff->ow, stuff->oh);
d591 1
a591 1
    title_bytes = (unsigned char *) &stuff[1];
a602 1

d606 1
a606 3
ProcAppleWMDispatch (
    register ClientPtr  client
)
d610 1
a610 2
    switch (stuff->data)
    {
d618 1
a618 2
    switch (stuff->data)
    {
d621 1
d624 1
d627 1
d630 1
d633 1
d636 1
d639 1
d642 1
d645 1
d648 1
d651 1
d654 1
d657 1
d664 2
a665 1
SNotifyEvent(xAppleWMNotifyEvent *from, xAppleWMNotifyEvent *to) {
d668 3
a670 3
    cpswaps (from->sequenceNumber, to->sequenceNumber);
    cpswapl (from->time, to->time);
    cpswapl (from->arg, to->arg);
d674 1
a674 3
SProcAppleWMQueryVersion(
    register ClientPtr  client
)
a675 1
    register int n;
d677 1
a677 1
    swaps(&stuff->length, n);
d682 1
a682 3
SProcAppleWMDispatch (
    register ClientPtr  client
)
d691 1
a691 2
    switch (stuff->data)
    {
d694 1
d701 1
a701 2
AppleWMExtensionInit(
    AppleWMProcsPtr procsPtr)
d716 1
a716 2
                                 StandardMinorOpcode)))
    {
d721 2
a722 2
        for (i=0; i < AppleWMNumberEvents; i++)
            EventSwapVector[WMEventBase + i] = (EventSwapPtr) SNotifyEvent;
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a72 2
static DISPATCH_PROC(ProcAppleWMDispatch);
static DISPATCH_PROC(SProcAppleWMDispatch);
a105 27
void
AppleWMExtensionInit(
    AppleWMProcsPtr procsPtr)
{
    ExtensionEntry* extEntry;

    ClientType = CreateNewResourceType(WMFreeClient, "WMClient");
    EventType = CreateNewResourceType(WMFreeEvents, "WMEvent");
    eventResource = FakeClientID(0);

    if (ClientType && EventType &&
        (extEntry = AddExtension(APPLEWMNAME,
                                 AppleWMNumberEvents,
                                 AppleWMNumberErrors,
                                 ProcAppleWMDispatch,
                                 SProcAppleWMDispatch,
                                 NULL,
                                 StandardMinorOpcode)))
    {
        WMReqCode = (unsigned char)extEntry->base;
        WMErrorBase = extEntry->errorBase;
        WMEventBase = extEntry->eventBase;
        EventSwapVector[WMEventBase] = (EventSwapPtr) SNotifyEvent;
        appleWMProcs = procsPtr;
    }
}

d440 1
a440 1
    if (stuff->level < 0 || stuff->level >= AppleWMNumWindowLevels) {
d708 29
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d143 2
a144 4
    data[0] = (dixScreenOrigins[pWin->drawable.pScreen->myNum].x
                + darwinMainScreenX);
    data[1] = (dixScreenOrigins[pWin->drawable.pScreen->myNum].y
                + darwinMainScreenY);
d193 1
a193 1
    return (client->noClientException);
d230 1
a230 1
    xfree ((pointer) pEvent);
d243 1
a243 1
        xfree ((pointer) pCur);
d245 1
a245 1
    xfree ((pointer) pHead);
d275 1
a275 1
        pNewEvent = (WMEventPtr) xalloc (sizeof (WMEventRec));
d297 1
a297 1
            pHead = (WMEventPtr *) xalloc (sizeof (WMEventPtr));
d324 1
a324 1
                xfree (pEvent);
a341 1
    ClientPtr       client;
d349 1
a349 4
        client = pEvent->client;
        if ((pEvent->mask & mask) == 0
            || client == serverClient || client->clientGone)
        {
a350 1
        }
a353 1
        se.sequenceNumber = client->sequence;
d355 1
a355 1
        WriteEventsToClient (client, 1, (xEvent *) &se);
d378 1
a378 1
    return (client->noClientException);
d390 1
a390 1
    return (client->noClientException);
d409 2
a410 2
    items = xalloc (sizeof (char *) * nitems);
    shortcuts = xalloc (sizeof (char) * nitems);
d430 1
a430 1
    return (client->noClientException);
d442 1
a442 1
    return (client->noClientException);
d453 1
a453 1
    return (client->noClientException);
d478 1
a478 1
    return (client->noClientException);
d497 1
a497 1
    return (client->noClientException);
d527 1
a527 1
    return (client->noClientException);
d540 1
a540 1
    return (client->noClientException);
d576 1
a576 1
    return (client->noClientException);
d606 1
a606 1
    return (client->noClientException);
d644 1
a644 1
    return (client->noClientException);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a35 2
#define NEED_REPLIES
#define NEED_EVENTS
d50 1
a50 1
#include "X11/extensions/applewmstr.h"
d53 1
d114 2
a115 2
    ClientType = CreateNewResourceType(WMFreeClient);
    EventType = CreateNewResourceType(WMFreeEvents);
d141 1
a141 1
    long data[2];
d187 3
a189 3
    rep.majorVersion = APPLE_WM_MAJOR_VERSION;
    rep.minorVersion = APPLE_WM_MINOR_VERSION;
    rep.patchVersion = APPLE_WM_PATCH_VERSION;
d213 1
a213 4
WMFreeClient (data, id)
    pointer     data;
    XID         id;
{
d216 1
d219 2
a220 2
    pHead = (WMEventPtr *) LookupIDByType(eventResource, EventType);
    if (pHead) {
d238 1
a238 4
WMFreeEvents (data, id)
    pointer     data;
    XID         id;
{
d258 1
d261 1
a261 2
    pHead = (WMEventPtr *)SecurityLookupIDByType(client,
                        eventResource, EventType, DixWriteAccess);
d263 1
a263 1
        if (pHead) {
d297 1
a297 1
        if (!pHead)
d313 1
a313 1
        if (pHead) {
d342 1
a342 4
AppleWMSendEvent (type, mask, which, arg)
    int type, which, arg;
    unsigned int mask;
{
d346 1
d348 2
a349 2
    pHead = (WMEventPtr *) LookupIDByType(eventResource, EventType);
    if (!pHead)
d490 49
d698 4
d708 1
a708 3
SNotifyEvent(from, to)
    xAppleWMNotifyEvent *from, *to;
{
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d28 2
a76 2
static void AppleWMResetProc(ExtensionEntry* extEntry);

d125 1
a125 1
                                 AppleWMResetProc,
a135 8
/*ARGSUSED*/
static void
AppleWMResetProc (
    ExtensionEntry* extEntry
)
{
}

d168 5
a172 1
    return (rc == Success) && (prop->type == atom);
@

