head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.6
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.07.11.08.13.44;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	QZ1xfp0adMyURB7B;

1.7
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.53;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.29;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/**************************************************************
 *
 * Xquartz initialization code
 *
 * Copyright (c) 2007-2012 Apple Inc.
 * Copyright (c) 2001-2004 Torrey T. Lyons. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "os.h"
#include "servermd.h"
#include "inputstr.h"
#include "scrnintstr.h"
#include "mipointer.h"          // mi software cursor
#include "micmap.h"             // mi colormap code
#include "fb.h"                 // fb framebuffer code
#include "site.h"
#include "globals.h"
#include "dix.h"
#include "xkbsrv.h"

#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exevents.h"
#include "extinit.h"

#include "xserver-properties.h"

#include <sys/types.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/syslimits.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdarg.h>

#define HAS_UTSNAME 1
#include <sys/utsname.h>

#define NO_CFPLUGIN
#include <IOKit/hidsystem/IOHIDLib.h>

#ifdef MITSHM
#include "shmint.h"
#endif

#include "darwin.h"
#include "darwinEvents.h"
#include "quartzKeyboard.h"
#include "quartz.h"

#include "X11Application.h"

aslclient aslc;

void
xq_asl_log(int level, const char *subsystem, const char *file,
           const char *function, int line, const char *fmt,
           ...)
{
    va_list args;
    aslmsg msg = asl_new(ASL_TYPE_MSG);

    if (msg) {
        char *_line;

        asl_set(msg, "File", file);
        asl_set(msg, "Function", function);
        asprintf(&_line, "%d", line);
        if (_line) {
            asl_set(msg, "Line", _line);
            free(_line);
        }
        if (subsystem)
            asl_set(msg, "Subsystem", subsystem);
    }

    va_start(args, fmt);
    asl_vlog(aslc, msg, level, fmt, args);
    va_end(args);

    if (msg)
        asl_free(msg);
}

/*
 * X server shared global variables
 */
int darwinScreensFound = 0;
DevPrivateKeyRec darwinScreenKeyRec;
io_connect_t darwinParamConnect = 0;
int darwinEventReadFD = -1;
int darwinEventWriteFD = -1;
// int                     darwinMouseAccelChange = 1;
int darwinFakeButtons = 0;

// location of X11's (0,0) point in global screen coordinates
int darwinMainScreenX = 0;
int darwinMainScreenY = 0;

// parameters read from the command line or user preferences
int darwinDesiredDepth = -1;
int darwinSyncKeymap = FALSE;

// modifier masks for faking mouse buttons - ANY of these bits trigger it  (not all)
#ifdef NX_DEVICELCMDKEYMASK
int darwinFakeMouse2Mask = NX_DEVICELALTKEYMASK | NX_DEVICERALTKEYMASK;
int darwinFakeMouse3Mask = NX_DEVICELCMDKEYMASK | NX_DEVICERCMDKEYMASK;
#else
int darwinFakeMouse2Mask = NX_ALTERNATEMASK;
int darwinFakeMouse3Mask = NX_COMMANDMASK;
#endif

// Modifier mask for overriding event delivery to appkit (might be useful to set this to rcommand for input menu
unsigned int darwinAppKitModMask = 0;            // Any of these bits

// Modifier mask for items in the Window menu (0 and -1 cause shortcuts to be disabled)
unsigned int windowItemModMask = NX_COMMANDMASK;

// devices
DeviceIntPtr darwinKeyboard = NULL;
DeviceIntPtr darwinPointer = NULL;
DeviceIntPtr darwinTabletStylus = NULL;
DeviceIntPtr darwinTabletCursor = NULL;
DeviceIntPtr darwinTabletEraser = NULL;

// Common pixmap formats
static PixmapFormatRec formats[] = {
    { 1,  1,  BITMAP_SCANLINE_PAD    },
    { 4,  8,  BITMAP_SCANLINE_PAD    },
    { 8,  8,  BITMAP_SCANLINE_PAD    },
    { 15, 16, BITMAP_SCANLINE_PAD    },
    { 16, 16, BITMAP_SCANLINE_PAD    },
    { 24, 32, BITMAP_SCANLINE_PAD    },
    { 32, 32, BITMAP_SCANLINE_PAD    }
};
const int NUMFORMATS = sizeof(formats) / sizeof(formats[0]);

void
DarwinPrintBanner(void)
{
    ErrorF("Xquartz starting:\n");
    ErrorF("X.Org X Server %s\n", XSERVER_VERSION);
    ErrorF("Build Date: %s\n", BUILD_DATE);
}

/*
 * DarwinSaveScreen
 *  X screensaver support. Not implemented.
 */
static Bool
DarwinSaveScreen(ScreenPtr pScreen, int on)
{
    // FIXME
    if (on == SCREEN_SAVER_FORCER) {}
    else if (on == SCREEN_SAVER_ON) {}
    else {}
    return TRUE;
}

/*
 * DarwinScreenInit
 *  This is a callback from dix during AddScreen() from InitOutput().
 *  Initialize the screen and communicate information about it back to dix.
 */
static Bool
DarwinScreenInit(ScreenPtr pScreen, int argc, char **argv)
{
    int dpi;
    static int foundIndex = 0;
    Bool ret;
    DarwinFramebufferPtr dfb;

    if (!dixRegisterPrivateKey(&darwinScreenKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    // reset index of found screens for each server generation
    if (pScreen->myNum == 0) {
        foundIndex = 0;

        // reset the visual list
        miClearVisualTypes();
    }

    // allocate space for private per screen storage
    dfb = malloc(sizeof(DarwinFramebufferRec));

    // SCREEN_PRIV(pScreen) = dfb;
    dixSetPrivate(&pScreen->devPrivates, darwinScreenKey, dfb);

    // setup hardware/mode specific details
    ret = QuartzAddScreen(foundIndex, pScreen);
    foundIndex++;
    if (!ret)
        return FALSE;

    // setup a single visual appropriate for our pixel type
    if (!miSetVisualTypesAndMasks(dfb->depth, dfb->visuals, dfb->bitsPerRGB,
                                  dfb->preferredCVC, dfb->redMask,
                                  dfb->greenMask, dfb->blueMask)) {
        return FALSE;
    }

    // TODO: Make PseudoColor visuals not suck in TrueColor mode
    // if(dfb->depth > 8)
    //    miSetVisualTypesAndMasks(8, PseudoColorMask, 8, PseudoColor, 0, 0, 0);
    //
    // TODO: Re-add support for 15bit
    // if (dfb->depth > 15)
    //    miSetVisualTypesAndMasks(15, TrueColorMask, 5, TrueColor,
    //                             RM_ARGB(0, 5, 5, 5), GM_ARGB(0, 5, 5,
    //                                                          5),
    //                             BM_ARGB(0, 5, 5, 5));
    if (dfb->depth > 24)
        miSetVisualTypesAndMasks(24, TrueColorMask, 8, TrueColor,
                                 RM_ARGB(0, 8, 8, 8), GM_ARGB(0, 8, 8,
                                                              8),
                                 BM_ARGB(0, 8, 8, 8));

    miSetPixmapDepths();

    // machine independent screen init
    // setup _Screen structure in pScreen
    if (monitorResolution)
        dpi = monitorResolution;
    else
        dpi = 96;

    // initialize fb
    if (!fbScreenInit(pScreen,
                      dfb->framebuffer,                  // pointer to screen bitmap
                      dfb->width, dfb->height,           // screen size in pixels
                      dpi, dpi,                          // dots per inch
                      dfb->pitch / (dfb->bitsPerPixel / 8), // pixel width of framebuffer
                      dfb->bitsPerPixel)) {              // bits per pixel for screen
        return FALSE;
    }

    if (!fbPictureInit(pScreen, 0, 0)) {
        return FALSE;
    }

#ifdef MITSHM
    ShmRegisterFbFuncs(pScreen);
#endif

    // this must be initialized (why doesn't X have a default?)
    pScreen->SaveScreen = DarwinSaveScreen;

    // finish mode dependent screen setup including cursor support
    if (!QuartzSetupScreen(pScreen->myNum, pScreen)) {
        return FALSE;
    }

    // create and install the default colormap and
    // set pScreen->blackPixel / pScreen->white
    if (!miCreateDefColormap(pScreen)) {
        return FALSE;
    }

    pScreen->x = dfb->x;
    pScreen->y = dfb->y;

    /*    ErrorF("Screen %d added: %dx%d @@ (%d,%d)\n",
       index, dfb->width, dfb->height, dfb->x, dfb->y); */

    return TRUE;
}

/*
   =============================================================================

   mouse and keyboard callbacks

   =============================================================================
 */

/*
 * DarwinMouseProc: Handle the initialization, etc. of a mouse
 */
static int
DarwinMouseProc(DeviceIntPtr pPointer, int what)
{
#define NBUTTONS 3
#define NAXES    6
    // 3 buttons: left, middle, right
    CARD8 map[NBUTTONS + 1] = { 0, 1, 2, 3};
    Atom btn_labels[NBUTTONS] = { 0 };
    Atom axes_labels[NAXES] = { 0 };

    switch (what) {
    case DEVICE_INIT:
        pPointer->public.on = FALSE;

        btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
        btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
        btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);

        axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_X);
        axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_Y);
        axes_labels[2] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
        axes_labels[3] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);
        axes_labels[4] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_WHEEL);
        axes_labels[5] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_HWHEEL);

        // Set button map.
        InitPointerDeviceStruct((DevicePtr)pPointer, map, NBUTTONS,
                                btn_labels,
                                (PtrCtrlProcPtr)NoopDDA,
                                GetMotionHistorySize(), NAXES,
                                axes_labels);
        InitValuatorAxisStruct(pPointer, 0, axes_labels[0],
                               NO_AXIS_LIMITS, NO_AXIS_LIMITS,
                               0, 0, 0, Absolute);
        InitValuatorAxisStruct(pPointer, 1, axes_labels[1],
                               NO_AXIS_LIMITS, NO_AXIS_LIMITS,
                               0, 0, 0, Absolute);
        InitValuatorAxisStruct(pPointer, 2, axes_labels[2],
                               NO_AXIS_LIMITS, NO_AXIS_LIMITS,
                               1, 0, 1, Relative);
        InitValuatorAxisStruct(pPointer, 3, axes_labels[3],
                               NO_AXIS_LIMITS, NO_AXIS_LIMITS,
                               1, 0, 1, Relative);
        InitValuatorAxisStruct(pPointer, 4, axes_labels[4],
                               NO_AXIS_LIMITS, NO_AXIS_LIMITS,
                               1, 0, 1, Relative);
        InitValuatorAxisStruct(pPointer, 5, axes_labels[5],
                               NO_AXIS_LIMITS, NO_AXIS_LIMITS,
                               1, 0, 1, Relative);

        SetScrollValuator(pPointer, 4, SCROLL_TYPE_VERTICAL, -1.0, SCROLL_FLAG_PREFERRED);
        SetScrollValuator(pPointer, 5, SCROLL_TYPE_HORIZONTAL, -1.0, SCROLL_FLAG_NONE);
        break;

    case DEVICE_ON:
        pPointer->public.on = TRUE;
        AddEnabledDevice(darwinEventReadFD);
        return Success;

    case DEVICE_CLOSE:
    case DEVICE_OFF:
        pPointer->public.on = FALSE;
        RemoveEnabledDevice(darwinEventReadFD);
        return Success;
    }

    return Success;
#undef NBUTTONS
#undef NAXES
}

static int
DarwinTabletProc(DeviceIntPtr pPointer, int what)
{
#define NBUTTONS 3
#define NAXES    5
    CARD8 map[NBUTTONS + 1] = { 0, 1, 2, 3 };
    Atom btn_labels[NBUTTONS] = { 0 };
    Atom axes_labels[NAXES] = { 0 };

    switch (what) {
    case DEVICE_INIT:
        pPointer->public.on = FALSE;

        btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
        btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
        btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);

        axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_X);
        axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_Y);
        axes_labels[2] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_PRESSURE);
        axes_labels[3] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_TILT_X);
        axes_labels[4] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_TILT_Y);

        // Set button map.
        InitPointerDeviceStruct((DevicePtr)pPointer, map, NBUTTONS,
                                btn_labels,
                                (PtrCtrlProcPtr)NoopDDA,
                                GetMotionHistorySize(), NAXES,
                                axes_labels);
        InitProximityClassDeviceStruct(pPointer);

        InitValuatorAxisStruct(pPointer, 0, axes_labels[0],
                               0, XQUARTZ_VALUATOR_LIMIT,
                               1, 0, 1, Absolute);
        InitValuatorAxisStruct(pPointer, 1, axes_labels[1],
                               0, XQUARTZ_VALUATOR_LIMIT,
                               1, 0, 1, Absolute);
        InitValuatorAxisStruct(pPointer, 2, axes_labels[2],
                               0, XQUARTZ_VALUATOR_LIMIT,
                               1, 0, 1, Absolute);
        InitValuatorAxisStruct(pPointer, 3, axes_labels[3],
                               -XQUARTZ_VALUATOR_LIMIT,
                               XQUARTZ_VALUATOR_LIMIT,
                               1, 0, 1, Absolute);
        InitValuatorAxisStruct(pPointer, 4, axes_labels[4],
                               -XQUARTZ_VALUATOR_LIMIT,
                               XQUARTZ_VALUATOR_LIMIT,
                               1, 0, 1, Absolute);

        //          pPointer->use = IsXExtensionDevice;
        break;

    case DEVICE_ON:
        pPointer->public.on = TRUE;
        AddEnabledDevice(darwinEventReadFD);
        return Success;

    case DEVICE_CLOSE:
    case DEVICE_OFF:
        pPointer->public.on = FALSE;
        RemoveEnabledDevice(darwinEventReadFD);
        return Success;
    }
    return Success;
#undef NBUTTONS
#undef NAXES
}

/*
 * DarwinKeybdProc
 *  Callback from X
 */
static int
DarwinKeybdProc(DeviceIntPtr pDev, int onoff)
{
    switch (onoff) {
    case DEVICE_INIT:
        DarwinKeyboardInit(pDev);
        break;

    case DEVICE_ON:
        pDev->public.on = TRUE;
        AddEnabledDevice(darwinEventReadFD);
        break;

    case DEVICE_OFF:
        pDev->public.on = FALSE;
        RemoveEnabledDevice(darwinEventReadFD);
        break;

    case DEVICE_CLOSE:
        break;
    }

    return Success;
}

/*
   ===========================================================================

   Utility routines

   ===========================================================================
 */

/*
 * DarwinParseModifierList
 *  Parse a list of modifier names and return a corresponding modifier mask
 */
int
DarwinParseModifierList(const char *constmodifiers, int separatelr)
{
    int result = 0;

    if (constmodifiers) {
        char *modifiers = strdup(constmodifiers);
        char *modifier;
        int nxkey;
        char *p = modifiers;

        while (p) {
            modifier = strsep(&p, " ,+&|/"); // allow lots of separators
            nxkey = DarwinModifierStringToNXMask(modifier, separatelr);
            if (nxkey)
                result |= nxkey;
            else
                ErrorF("fakebuttons: Unknown modifier \"%s\"\n", modifier);
        }
        free(modifiers);
    }
    return result;
}

/*
   ===========================================================================

   Functions needed to link against device independent X

   ===========================================================================
 */

/*
 * InitInput
 *  Register the keyboard and mouse devices
 */
void
InitInput(int argc, char **argv)
{
    XkbRMLVOSet rmlvo = {
        .rules   = "base", .model         = "empty", .layout = "empty",
        .variant = NULL,   .options       = NULL
    };

    /* We need to really have rules... or something... */
    XkbSetRulesDflts(&rmlvo);

    assert(Success == AllocDevicePair(serverClient, "xquartz virtual",
                                      &darwinPointer, &darwinKeyboard,
                                      DarwinMouseProc, DarwinKeybdProc, FALSE));

    /* here's the snippet from the current gdk sources:
       if (!strcmp (tmp_name, "pointer"))
       gdkdev->info.source = GDK_SOURCE_MOUSE;
       else if (!strcmp (tmp_name, "wacom") ||
       !strcmp (tmp_name, "pen"))
       gdkdev->info.source = GDK_SOURCE_PEN;
       else if (!strcmp (tmp_name, "eraser"))
       gdkdev->info.source = GDK_SOURCE_ERASER;
       else if (!strcmp (tmp_name, "cursor"))
       gdkdev->info.source = GDK_SOURCE_CURSOR;
       else
       gdkdev->info.source = GDK_SOURCE_PEN;
     */

    darwinTabletStylus = AddInputDevice(serverClient, DarwinTabletProc, TRUE);
    assert(darwinTabletStylus);
    darwinTabletStylus->name = strdup("pen");

    darwinTabletCursor = AddInputDevice(serverClient, DarwinTabletProc, TRUE);
    assert(darwinTabletCursor);
    darwinTabletCursor->name = strdup("cursor");

    darwinTabletEraser = AddInputDevice(serverClient, DarwinTabletProc, TRUE);
    assert(darwinTabletEraser);
    darwinTabletEraser->name = strdup("eraser");

    DarwinEQInit();

    QuartzInitInput(argc, argv);
}

void
CloseInput(void)
{
    DarwinEQFini();
}

/*
 * DarwinAdjustScreenOrigins
 *  Shift all screens so the X11 (0, 0) coordinate is at the top
 *  left of the global screen coordinates.
 *
 *  Screens can be arranged so the top left isn't on any screen, so
 *  instead use the top left of the leftmost screen as (0,0). This
 *  may mean some screen space is in -y, but it's better that (0,0)
 *  be onscreen, or else default xterms disappear. It's better that
 *  -y be used than -x, because when popup menus are forced
 *  "onscreen" by dumb window managers like twm, they'll shift the
 *  menus down instead of left, which still looks funny but is an
 *  easier target to hit.
 */
void
DarwinAdjustScreenOrigins(ScreenInfo *pScreenInfo)
{
    int i, left, top;

    left = pScreenInfo->screens[0]->x;
    top = pScreenInfo->screens[0]->y;

    /* Find leftmost screen. If there's a tie, take the topmost of the two. */
    for (i = 1; i < pScreenInfo->numScreens; i++) {
        if (pScreenInfo->screens[i]->x < left ||
            (pScreenInfo->screens[i]->x == left &&
             pScreenInfo->screens[i]->y < top)) {
            left = pScreenInfo->screens[i]->x;
            top = pScreenInfo->screens[i]->y;
        }
    }

    darwinMainScreenX = left;
    darwinMainScreenY = top;

    DEBUG_LOG("top = %d, left=%d\n", top, left);

    /* Shift all screens so that there is a screen whose top left
     * is at X11 (0,0) and at global screen coordinate
     * (darwinMainScreenX, darwinMainScreenY).
     */

    if (darwinMainScreenX != 0 || darwinMainScreenY != 0) {
        for (i = 0; i < pScreenInfo->numScreens; i++) {
            pScreenInfo->screens[i]->x -= darwinMainScreenX;
            pScreenInfo->screens[i]->y -= darwinMainScreenY;
            DEBUG_LOG("Screen %d placed at X11 coordinate (%d,%d).\n",
                      i, pScreenInfo->screens[i]->x,
                      pScreenInfo->screens[i]->y);
        }
    }

    /* Update screenInfo.x/y */
    update_desktop_dimensions();
}

/*
 * InitOutput
 *  Initialize screenInfo for all actually accessible framebuffers.
 *
 *  The display mode dependent code gets called three times. The mode
 *  specific InitOutput routines are expected to discover the number
 *  of potentially useful screens and cache routes to them internally.
 *  Inside DarwinScreenInit are two other mode specific calls.
 *  A mode specific AddScreen routine is called for each screen to
 *  actually initialize the screen with the ScreenPtr structure.
 *  After other screen setup has been done, a mode specific
 *  SetupScreen function can be called to finalize screen setup.
 */
void
InitOutput(ScreenInfo *pScreenInfo, int argc, char **argv)
{
    int i;

    pScreenInfo->imageByteOrder = IMAGE_BYTE_ORDER;
    pScreenInfo->bitmapScanlineUnit = BITMAP_SCANLINE_UNIT;
    pScreenInfo->bitmapScanlinePad = BITMAP_SCANLINE_PAD;
    pScreenInfo->bitmapBitOrder = BITMAP_BIT_ORDER;

    // List how we want common pixmap formats to be padded
    pScreenInfo->numPixmapFormats = NUMFORMATS;
    for (i = 0; i < NUMFORMATS; i++)
        pScreenInfo->formats[i] = formats[i];

    // Discover screens and do mode specific initialization
    QuartzInitOutput(argc, argv);

    // Add screens
    for (i = 0; i < darwinScreensFound; i++) {
        AddScreen(DarwinScreenInit, argc, argv);
    }

    DarwinAdjustScreenOrigins(pScreenInfo);
}

/*
 * OsVendorFatalError
 */
void
OsVendorFatalError(const char *f, va_list args)
{
    X11ApplicationFatalError(f, args);
}

/*
 * OsVendorInit
 *  Initialization of Darwin OS support.
 */
void
OsVendorInit(void)
{
    if (serverGeneration == 1) {
        char *lf;
        char *home = getenv("HOME");
        assert(home);
        assert(0 < asprintf(&lf, "%s/Library/Logs/X11", home));

        /* Ignore errors.  If EEXIST, we don't care.  If anything else,
         * LogInit will handle it for us.
         */
        (void)mkdir(lf, S_IRWXU | S_IRWXG | S_IRWXO);
        free(lf);

        assert(0 <
               asprintf(&lf, "%s/Library/Logs/X11/%s.log", home,
                        bundle_id_prefix));
        LogInit(lf, ".old");
        free(lf);

        DarwinPrintBanner();
    }
}

/*
 * ddxProcessArgument
 *  Process device-dependent command line args. Returns 0 if argument is
 *  not device dependent, otherwise Count of number of elements of argv
 *  that are part of a device dependent commandline option.
 */
int
ddxProcessArgument(int argc, char *argv[], int i)
{
    //    if ( !strcmp( argv[i], "-fullscreen" ) ) {
    //        ErrorF( "Running full screen in parallel with Mac OS X Quartz window server.\n" );
    //        return 1;
    //    }

    //    if ( !strcmp( argv[i], "-rootless" ) ) {
    //        ErrorF( "Running rootless inside Mac OS X window server.\n" );
    //        return 1;
    //    }

    // This command line arg is passed when launched from the Aqua GUI.
    if (!strncmp(argv[i], "-psn_", 5)) {
        return 1;
    }

    if (!strcmp(argv[i], "-fakebuttons")) {
        darwinFakeButtons = TRUE;
        ErrorF("Faking a three button mouse\n");
        return 1;
    }

    if (!strcmp(argv[i], "-nofakebuttons")) {
        darwinFakeButtons = FALSE;
        ErrorF("Not faking a three button mouse\n");
        return 1;
    }

    if (!strcmp(argv[i], "-fakemouse2")) {
        if (i == argc - 1) {
            FatalError("-fakemouse2 must be followed by a modifer list\n");
        }
        if (!strcasecmp(argv[i + 1], "none") || !strcmp(argv[i + 1], ""))
            darwinFakeMouse2Mask = 0;
        else
            darwinFakeMouse2Mask = DarwinParseModifierList(argv[i + 1], 1);
        ErrorF("Modifier mask to fake mouse button 2 = 0x%x\n",
               darwinFakeMouse2Mask);
        return 2;
    }

    if (!strcmp(argv[i], "-fakemouse3")) {
        if (i == argc - 1) {
            FatalError("-fakemouse3 must be followed by a modifer list\n");
        }
        if (!strcasecmp(argv[i + 1], "none") || !strcmp(argv[i + 1], ""))
            darwinFakeMouse3Mask = 0;
        else
            darwinFakeMouse3Mask = DarwinParseModifierList(argv[i + 1], 1);
        ErrorF("Modifier mask to fake mouse button 3 = 0x%x\n",
               darwinFakeMouse3Mask);
        return 2;
    }

    if (!strcmp(argv[i], "+synckeymap")) {
        darwinSyncKeymap = TRUE;
        return 1;
    }

    if (!strcmp(argv[i], "-synckeymap")) {
        darwinSyncKeymap = FALSE;
        return 1;
    }

    if (!strcmp(argv[i], "-depth")) {
        if (i == argc - 1) {
            FatalError("-depth must be followed by a number\n");
        }
        darwinDesiredDepth = atoi(argv[i + 1]);
        if (darwinDesiredDepth != -1 &&
            darwinDesiredDepth != 8 &&
            darwinDesiredDepth != 15 &&
            darwinDesiredDepth != 24) {
            FatalError("Unsupported pixel depth. Use 8, 15, or 24 bits\n");
        }

        ErrorF("Attempting to use pixel depth of %i\n", darwinDesiredDepth);
        return 2;
    }

    if (!strcmp(argv[i], "-showconfig") || !strcmp(argv[i], "-version")) {
        DarwinPrintBanner();
        exit(0);
    }

    return 0;
}

/*
 * ddxUseMsg --
 *  Print out correct use of device dependent commandline options.
 *  Maybe the user now knows what really to do ...
 */
void
ddxUseMsg(void)
{
    ErrorF("\n");
    ErrorF("\n");
    ErrorF("Device Dependent Usage:\n");
    ErrorF("\n");
    ErrorF("-depth <8,15,24> : use this bit depth.\n");
    ErrorF(
        "-fakebuttons : fake a three button mouse with Command and Option keys.\n");
    ErrorF("-nofakebuttons : don't fake a three button mouse.\n");
    ErrorF(
        "-fakemouse2 <modifiers> : fake middle mouse button with modifier keys.\n");
    ErrorF(
        "-fakemouse3 <modifiers> : fake right mouse button with modifier keys.\n");
    ErrorF(
        "  ex: -fakemouse2 \"option,shift\" = option-shift-click is middle button.\n");
    ErrorF("-version : show the server version.\n");
    ErrorF("\n");
}

/*
 * ddxGiveUp --
 *      Device dependent cleanup. Called by dix before normal server death.
 */
void
ddxGiveUp(enum ExitCode error)
{
    LogClose(error);
}

/*
 * AbortDDX --
 *      DDX - specific abort routine.  Called by AbortServer(). The attempt is
 *      made to restore all original setting of the displays. Also all devices
 *      are closed.
 */
_X_NORETURN
void
AbortDDX(enum ExitCode error)
{
    ErrorF("   AbortDDX\n");
    OsAbort();
}
@


1.8
log
@Update to xorg-server 1.15.2. bug fixes.
@
text
@d346 1
a346 1
        InitValuatorAxisStruct(pPointer, 2, axes_labels[2], 
d349 1
a349 1
        InitValuatorAxisStruct(pPointer, 3, axes_labels[3], 
d352 1
a352 1
        InitValuatorAxisStruct(pPointer, 4, axes_labels[4], 
d355 1
a355 1
        InitValuatorAxisStruct(pPointer, 5, axes_labels[5], 
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a706 16
#ifdef ENABLE_DEBUG_LOG
        {
            char *home_dir = NULL, *log_file_path = NULL;
            home_dir = getenv("HOME");
            if (home_dir) asprintf(&log_file_path, "%s/%s", home_dir,
                                   DEBUG_LOG_NAME);
            if (log_file_path) {
                if (!access(log_file_path, F_OK)) {
                    debug_log_fp = fopen(log_file_path, "a");
                    if (debug_log_fp) ErrorF("Debug logging enabled to %s\n",
                                             log_file_path);
                }
                free(log_file_path);
            }
        }
#endif
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a40 1
#include "mibstore.h"           // mi backing store implementation
d80 2
d195 1
a195 1
DarwinScreenInit(int index, ScreenPtr pScreen, int argc, char **argv)
d206 1
a206 1
    if (index == 0) {
d233 9
a241 7
    //    if(dfb->depth > 8)
    //        miSetVisualTypesAndMasks(8, PseudoColorMask, 8, PseudoColor, 0, 0, 0);
    if (dfb->depth > 15)
        miSetVisualTypesAndMasks(15, TrueColorMask, 5, TrueColor,
                                 RM_ARGB(0, 5, 5, 5), GM_ARGB(0, 5, 5,
                                                              5),
                                 BM_ARGB(0, 5, 5, 5));
d279 1
a279 1
    if (!QuartzSetupScreen(index, pScreen)) {
d676 1
a676 1
OsVendorFatalError(void)
d678 1
a678 1
    ErrorF("   OsVendorFatalError\n");
@


1.5
log
@Update to xserver 1.11.2
@
text
@d5 1
a5 1
 * Copyright (c) 2007-2008 Apple Inc.
d41 4
a44 4
#include "mibstore.h"		// mi backing store implementation
#include "mipointer.h"		// mi software cursor
#include "micmap.h"		// mi colormap code
#include "fb.h"			// fb framebuffer code
d59 1
d83 5
a87 1
void xq_asl_log (int level, const char *subsystem, const char *file, const char *function, int line, const char *fmt, ...) {
d91 1
a91 1
    if(msg) {
d97 1
a97 1
        if(_line) {
d101 1
a101 1
        if(subsystem)
d109 1
a109 1
    if(msg)
d116 5
a120 5
int                     darwinScreensFound = 0;
DevPrivateKeyRec        darwinScreenKeyRec;
io_connect_t            darwinParamConnect = 0;
int                     darwinEventReadFD = -1;
int                     darwinEventWriteFD = -1;
d122 1
a122 1
int                     darwinFakeButtons = 0;
d125 2
a126 2
int                     darwinMainScreenX = 0;
int                     darwinMainScreenY = 0;
d129 2
a130 2
int                     darwinDesiredDepth = -1;
int                     darwinSyncKeymap = FALSE;
d134 2
a135 2
int                     darwinFakeMouse2Mask = NX_DEVICELALTKEYMASK | NX_DEVICERALTKEYMASK;
int                     darwinFakeMouse3Mask = NX_DEVICELCMDKEYMASK | NX_DEVICERCMDKEYMASK;
d137 2
a138 2
int                     darwinFakeMouse2Mask = NX_ALTERNATEMASK;
int                     darwinFakeMouse3Mask = NX_COMMANDMASK;
d142 1
a142 1
unsigned int            darwinAppKitModMask = 0; // Any of these bits
d145 1
a145 1
unsigned int            windowItemModMask = NX_COMMANDMASK;
d148 5
a152 5
DeviceIntPtr            darwinKeyboard = NULL;
DeviceIntPtr            darwinPointer = NULL;
DeviceIntPtr            darwinTabletStylus = NULL;
DeviceIntPtr            darwinTabletCursor = NULL;
DeviceIntPtr            darwinTabletEraser = NULL;
d156 7
a162 7
        { 1,    1,      BITMAP_SCANLINE_PAD },
        { 4,    8,      BITMAP_SCANLINE_PAD },
        { 8,    8,      BITMAP_SCANLINE_PAD },
        { 15,   16,     BITMAP_SCANLINE_PAD },
        { 16,   16,     BITMAP_SCANLINE_PAD },
        { 24,   32,     BITMAP_SCANLINE_PAD },
        { 32,   32,     BITMAP_SCANLINE_PAD }
d164 1
a164 1
const int NUMFORMATS = sizeof(formats)/sizeof(formats[0]);
d168 4
a171 4
{ 
  ErrorF("Xquartz starting:\n");
  ErrorF("X.Org X Server %s\n", XSERVER_VERSION);
  ErrorF("Build Date: %s\n", BUILD_DATE );
a173 1

d178 2
a179 1
static Bool DarwinSaveScreen(ScreenPtr pScreen, int on)
d182 3
a184 4
    if (on == SCREEN_SAVER_FORCER) {
    } else if (on == SCREEN_SAVER_ON) {
    } else {
    }
d193 6
a198 4
static Bool DarwinScreenInit(int index, ScreenPtr pScreen, int argc, char **argv) {
    int         dpi;
    static int  foundIndex = 0;
    Bool        ret;
d202 1
a202 1
	return FALSE;
d221 1
a221 1
    if (! ret)
d225 3
a227 3
    if(!miSetVisualTypesAndMasks(dfb->depth, dfb->visuals, dfb->bitsPerRGB,
                                 dfb->preferredCVC, dfb->redMask,
                                 dfb->greenMask, dfb->blueMask)) {
d230 14
a243 8
  
// TODO: Make PseudoColor visuals not suck in TrueColor mode  
//    if(dfb->depth > 8)
//        miSetVisualTypesAndMasks(8, PseudoColorMask, 8, PseudoColor, 0, 0, 0);
    if(dfb->depth > 15)
        miSetVisualTypesAndMasks(15, TrueColorMask, 5, TrueColor, RM_ARGB(0,5,5,5), GM_ARGB(0,5,5,5), BM_ARGB(0,5,5,5));
    if(dfb->depth > 24)
        miSetVisualTypesAndMasks(24, TrueColorMask, 8, TrueColor, RM_ARGB(0,8,8,8), GM_ARGB(0,8,8,8), BM_ARGB(0,8,8,8));
d255 6
a260 7
    if (! fbScreenInit(pScreen,
                dfb->framebuffer,                 // pointer to screen bitmap
                dfb->width, dfb->height,          // screen size in pixels
                dpi, dpi,                         // dots per inch
                dfb->pitch/(dfb->bitsPerPixel/8), // pixel width of framebuffer
                dfb->bitsPerPixel))               // bits per pixel for screen
    {
d264 1
a264 1
    if (! fbPictureInit(pScreen, 0, 0)) {
d282 1
a282 1
    if (!miCreateDefColormap( pScreen )) {
d290 1
a290 1
	  index, dfb->width, dfb->height, dfb->x, dfb->y); */
d296 1
a296 1
 =============================================================================
d298 1
a298 1
 mouse and keyboard callbacks
d300 2
a301 2
 =============================================================================
*/
d306 9
a314 7
static int DarwinMouseProc(DeviceIntPtr pPointer, int what) {
#define NBUTTONS 7
#define NAXES 2
	// 7 buttons: left, right, middle, then four scroll wheel "buttons"
    CARD8 map[NBUTTONS + 1] = {0, 1, 2, 3, 4, 5, 6, 7};
    Atom btn_labels[NBUTTONS] = {0};
    Atom axes_labels[NAXES] = {0};
d317 2
a318 2
        case DEVICE_INIT:
            pPointer->public.on = FALSE;
d320 50
a369 30
            btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
            btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
            btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
            btn_labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
            btn_labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
            btn_labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
            btn_labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);

            axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
            axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);


            // Set button map.
            InitPointerDeviceStruct((DevicePtr)pPointer, map, NBUTTONS,
                                    btn_labels,
                                    (PtrCtrlProcPtr)NoopDDA,
                                    GetMotionHistorySize(), NAXES,
                                    axes_labels);
            InitValuatorAxisStruct(pPointer, 0, axes_labels[0], NO_AXIS_LIMITS, NO_AXIS_LIMITS, 0, 0, 0, Absolute);
            InitValuatorAxisStruct(pPointer, 1, axes_labels[1], NO_AXIS_LIMITS, NO_AXIS_LIMITS, 0, 0, 0, Absolute);
            break;
        case DEVICE_ON:
            pPointer->public.on = TRUE;
            AddEnabledDevice( darwinEventReadFD );
            return Success;
        case DEVICE_CLOSE:
        case DEVICE_OFF:
            pPointer->public.on = FALSE;
            RemoveEnabledDevice(darwinEventReadFD);
            return Success;
d371 1
a371 1
    
d377 3
a379 1
static int DarwinTabletProc(DeviceIntPtr pPointer, int what) {
d381 4
a384 4
#define NAXES 5
    CARD8 map[NBUTTONS + 1] = {0, 1, 2, 3};
    Atom btn_labels[NBUTTONS] = {0};
    Atom axes_labels[NAXES] = {0};
d387 2
a388 2
        case DEVICE_INIT:
            pPointer->public.on = FALSE;
d390 49
a438 34
            btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
            btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
            btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);

            axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_X);
            axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_Y);
            axes_labels[2] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_PRESSURE);
            axes_labels[3] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_TILT_X);
            axes_labels[4] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_TILT_Y);

            // Set button map.
            InitPointerDeviceStruct((DevicePtr)pPointer, map, NBUTTONS,
                                    btn_labels,
                                    (PtrCtrlProcPtr)NoopDDA,
                                    GetMotionHistorySize(), NAXES,
                                    axes_labels);
            InitProximityClassDeviceStruct(pPointer);

            InitValuatorAxisStruct(pPointer, 0, axes_labels[0], 0, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1, Absolute);
            InitValuatorAxisStruct(pPointer, 1, axes_labels[1], 0, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1, Absolute);
            InitValuatorAxisStruct(pPointer, 2, axes_labels[2], 0, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1, Absolute);
            InitValuatorAxisStruct(pPointer, 3, axes_labels[3], -XQUARTZ_VALUATOR_LIMIT, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1, Absolute);
            InitValuatorAxisStruct(pPointer, 4, axes_labels[4], -XQUARTZ_VALUATOR_LIMIT, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1, Absolute);
//          pPointer->use = IsXExtensionDevice;
            break;
        case DEVICE_ON:
            pPointer->public.on = TRUE;
            AddEnabledDevice( darwinEventReadFD );
            return Success;
        case DEVICE_CLOSE:
        case DEVICE_OFF:
            pPointer->public.on = FALSE;
            RemoveEnabledDevice(darwinEventReadFD);
            return Success;
d449 2
a450 1
static int DarwinKeybdProc( DeviceIntPtr pDev, int onoff )
d452 17
a468 14
    switch ( onoff ) {
        case DEVICE_INIT:
            DarwinKeyboardInit( pDev );
            break;
        case DEVICE_ON:
            pDev->public.on = TRUE;
            AddEnabledDevice( darwinEventReadFD );
            break;
        case DEVICE_OFF:
            pDev->public.on = FALSE;
            RemoveEnabledDevice( darwinEventReadFD );
            break;
        case DEVICE_CLOSE:
            break;
d475 1
a475 1
===========================================================================
d477 1
a477 1
 Utility routines
d479 2
a480 2
===========================================================================
*/
d486 2
a487 1
int DarwinParseModifierList(const char *constmodifiers, int separatelr)
d500 1
a500 1
            if(nxkey)
d511 1
a511 1
===========================================================================
d513 1
a513 1
 Functions needed to link against device independent X
d515 2
a516 2
===========================================================================
*/
d522 2
a523 1
void InitInput( int argc, char **argv )
d525 5
a529 2
    XkbRMLVOSet rmlvo = { .rules = "base", .model = "empty", .layout = "empty",
                          .variant = NULL, .options = NULL };
d533 3
a535 2
    darwinKeyboard = AddInputDevice(serverClient, DarwinKeybdProc, TRUE);
    darwinKeyboard->name = strdup("keyboard");
d538 12
a549 15
    if (!strcmp (tmp_name, "pointer"))
        gdkdev->info.source = GDK_SOURCE_MOUSE;
    else if (!strcmp (tmp_name, "wacom") ||
             !strcmp (tmp_name, "pen"))
        gdkdev->info.source = GDK_SOURCE_PEN;
    else if (!strcmp (tmp_name, "eraser"))
        gdkdev->info.source = GDK_SOURCE_ERASER;
    else if (!strcmp (tmp_name, "cursor"))
        gdkdev->info.source = GDK_SOURCE_CURSOR;
    else
        gdkdev->info.source = GDK_SOURCE_PEN;
    */

    darwinPointer = AddInputDevice(serverClient, DarwinMouseProc, TRUE);
    darwinPointer->name = strdup("pointer");
d552 1
d556 1
d560 1
d568 2
a569 1
void CloseInput(void)
d594 1
a594 1
    top  = pScreenInfo->screens[0]->y;
d598 3
a600 3
        if (pScreenInfo->screens[i]->x < left  ||
            (pScreenInfo->screens[i]->x == left && pScreenInfo->screens[i]->y < top))
        {
d608 1
a608 1
    
d621 2
a622 1
                      i, pScreenInfo->screens[i]->x, pScreenInfo->screens[i]->y);
d625 3
a629 1

d643 2
a644 1
void InitOutput( ScreenInfo *pScreenInfo, int argc, char **argv )
a668 1

d672 2
a673 1
void OsVendorFatalError( void )
d675 1
a675 1
    ErrorF( "   OsVendorFatalError\n" );
a677 1

d682 2
a683 1
void OsVendorInit(void)
d689 11
a699 1
        assert(0 < asprintf(&lf, "%s/Library/Logs/X11.%s.log", home, bundle_id_prefix));
d705 14
a718 12
	{
	  char *home_dir=NULL, *log_file_path=NULL;
	  home_dir = getenv("HOME");
	  if (home_dir) asprintf(&log_file_path, "%s/%s", home_dir, DEBUG_LOG_NAME);
	  if (log_file_path) {
	    if (!access(log_file_path, F_OK)) {
	      debug_log_fp = fopen(log_file_path, "a");
	      if (debug_log_fp) ErrorF("Debug logging enabled to %s\n", log_file_path);
	    }
	    free(log_file_path);
	  }
	}
a722 1

d729 2
a730 1
int ddxProcessArgument( int argc, char *argv[], int i )
d732 9
a740 9
//    if ( !strcmp( argv[i], "-fullscreen" ) ) {
//        ErrorF( "Running full screen in parallel with Mac OS X Quartz window server.\n" );
//        return 1;
//    }

//    if ( !strcmp( argv[i], "-rootless" ) ) {
//        ErrorF( "Running rootless inside Mac OS X window server.\n" );
//        return 1;
//    }
d743 1
a743 1
    if ( !strncmp( argv[i], "-psn_", 5 ) ) {
d747 1
a747 1
    if ( !strcmp( argv[i], "-fakebuttons" ) ) {
d749 1
a749 1
        ErrorF( "Faking a three button mouse\n" );
d753 1
a753 1
    if ( !strcmp( argv[i], "-nofakebuttons" ) ) {
d755 1
a755 1
        ErrorF( "Not faking a three button mouse\n" );
d759 3
a761 3
    if (!strcmp( argv[i], "-fakemouse2" ) ) {
        if ( i == argc-1 ) {
            FatalError( "-fakemouse2 must be followed by a modifer list\n" );
d763 1
a763 1
        if (!strcasecmp(argv[i+1], "none") || !strcmp(argv[i+1], ""))
d766 1
a766 1
            darwinFakeMouse2Mask = DarwinParseModifierList(argv[i+1], 1);
d772 3
a774 3
    if (!strcmp( argv[i], "-fakemouse3" ) ) {
        if ( i == argc-1 ) {
            FatalError( "-fakemouse3 must be followed by a modifer list\n" );
d776 1
a776 1
        if (!strcasecmp(argv[i+1], "none") || !strcmp(argv[i+1], ""))
d779 1
a779 1
            darwinFakeMouse3Mask = DarwinParseModifierList(argv[i+1], 1);
d785 1
a785 1
    if ( !strcmp( argv[i], "+synckeymap" ) ) {
d790 1
a790 1
    if ( !strcmp( argv[i], "-synckeymap" ) ) {
d795 3
a797 3
    if ( !strcmp( argv[i], "-depth" ) ) {
        if ( i == argc-1 ) {
            FatalError( "-depth must be followed by a number\n" );
d799 6
a804 6
        darwinDesiredDepth = atoi( argv[i+1] );
        if(darwinDesiredDepth != -1 &&
           darwinDesiredDepth != 8 &&
           darwinDesiredDepth != 15 &&
           darwinDesiredDepth != 24) {
            FatalError( "Unsupported pixel depth. Use 8, 15, or 24 bits\n" );
d807 1
a807 1
        ErrorF( "Attempting to use pixel depth of %i\n", darwinDesiredDepth );
d811 1
a811 1
    if (!strcmp( argv[i], "-showconfig" ) || !strcmp( argv[i], "-version" )) {
a818 1

d824 2
a825 1
void ddxUseMsg( void )
d832 2
a833 1
    ErrorF("-fakebuttons : fake a three button mouse with Command and Option keys.\n");
d835 6
a840 3
    ErrorF("-fakemouse2 <modifiers> : fake middle mouse button with modifier keys.\n");
    ErrorF("-fakemouse3 <modifiers> : fake right mouse button with modifier keys.\n");
    ErrorF("  ex: -fakemouse2 \"option,shift\" = option-shift-click is middle button.\n");
a844 1

d849 2
a850 1
void ddxGiveUp( enum ExitCode error )
a854 1

d862 4
a865 2
void AbortDDX( enum ExitCode error ) {
    ErrorF( "   AbortDDX\n" );
a867 1

@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d63 1
d80 27
a106 3
#ifdef ENABLE_DEBUG_LOG
FILE *debug_log_fp = NULL;
#endif
a144 1
DeviceIntPtr            darwinTabletCurrent = NULL;
a160 16
#ifndef OSNAME
#define OSNAME " Darwin"
#endif
#ifndef OSVENDOR
#define OSVENDOR ""
#endif
#ifndef PRE_RELEASE
#define PRE_RELEASE XORG_VERSION_SNAP
#endif
#ifndef BUILD_DATE
#define BUILD_DATE ""
#endif
#ifndef XORG_RELEASE
#define XORG_RELEASE "?"
#endif

a163 1
  // this should change depending on which specific server we are building
d165 2
a166 1
  ErrorF("X.Org X Server %s\nBuild Date: %s\n", XSERVER_VERSION, BUILD_DATE );
d325 2
a326 4
            pPointer->valuator->mode = Absolute; // Relative
            InitAbsoluteClassDeviceStruct(pPointer);
//            InitValuatorAxisStruct(pPointer, 0, 0, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1);
//            InitValuatorAxisStruct(pPointer, 1, 0, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1);
a370 1
            pPointer->valuator->mode = Absolute; // Relative
a371 1
			InitAbsoluteClassDeviceStruct(pPointer);
d373 5
a377 5
            InitValuatorAxisStruct(pPointer, 0, axes_labels[0], 0, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1);
            InitValuatorAxisStruct(pPointer, 1, axes_labels[1], 0, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1);
            InitValuatorAxisStruct(pPointer, 2, axes_labels[2], 0, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1);
            InitValuatorAxisStruct(pPointer, 3, axes_labels[3], -XQUARTZ_VALUATOR_LIMIT, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1);
            InitValuatorAxisStruct(pPointer, 4, axes_labels[4], -XQUARTZ_VALUATOR_LIMIT, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1);
a474 1
    RegisterKeyboardDevice( darwinKeyboard );
a491 1
    RegisterPointerDevice( darwinPointer );
a494 1
    RegisterPointerDevice( darwinTabletStylus );
a497 1
    RegisterPointerDevice( darwinTabletCursor );
a500 1
    RegisterPointerDevice( darwinTabletEraser );
a502 2
    darwinTabletCurrent = darwinTabletStylus;

d508 4
d621 7
d769 1
a769 1
void ddxGiveUp( void )
d771 1
a771 1
    ErrorF( "Quitting Xquartz\n" );
d781 2
a782 2
void AbortDDX( void )
{
a786 132
#include "mivalidate.h" // for union _Validate used by windowstr.h
#include "windowstr.h"  // for struct _Window
#include "scrnintstr.h" // for struct _Screen

// This is copied from Xserver/hw/xfree86/common/xf86Helper.c.
// Quartz mode uses this when switching in and out of Quartz.
// Quartz or IOKit can use this when waking from sleep.
// Copyright (c) 1997-1998 by The XFree86 Project, Inc.

/*
 * xf86SetRootClip --
 *	Enable or disable rendering to the screen by
 *	setting the root clip list and revalidating
 *	all of the windows
 */

void
xf86SetRootClip (ScreenPtr pScreen, int enable)
{
    WindowPtr	pWin = pScreen->root;
    WindowPtr	pChild;
    Bool	WasViewable = (Bool)(pWin->viewable);
    Bool	anyMarked = TRUE;
    RegionPtr	pOldClip = NULL, bsExposed;
    WindowPtr   pLayerWin;
    BoxRec	box;

    if (WasViewable)
    {
	for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib)
	{
	    (void) (*pScreen->MarkOverlappedWindows)(pChild,
						     pChild,
						     &pLayerWin);
	}
	(*pScreen->MarkWindow) (pWin);
	anyMarked = TRUE;
	if (pWin->valdata)
	{
	    if (HasBorder (pWin))
	    {
		RegionPtr	borderVisible;

		borderVisible = RegionCreate(NullBox, 1);
		RegionSubtract(borderVisible,
				&pWin->borderClip, &pWin->winSize);
		pWin->valdata->before.borderVisible = borderVisible;
	    }
	    pWin->valdata->before.resized = TRUE;
	}
    }

    /*
     * Use REGION_BREAK to avoid optimizations in ValidateTree
     * that assume the root borderClip can't change well, normally
     * it doesn't...)
     */
    if (enable)
    {
	box.x1 = 0;
	box.y1 = 0;
	box.x2 = pScreen->width;
	box.y2 = pScreen->height;
	RegionReset(&pWin->borderClip, &box);
	RegionBreak(&pWin->clipList);
    }
    else
    {
	RegionEmpty(&pWin->borderClip);
	RegionBreak(&pWin->clipList);
    }

    ResizeChildrenWinSize (pWin, 0, 0, 0, 0);

    if (WasViewable)
    {
	if (pWin->backStorage)
	{
	    pOldClip = RegionCreate(NullBox, 1);
	    RegionCopy(pOldClip, &pWin->clipList);
	}

	if (pWin->firstChild)
	{
	    anyMarked |= (*pScreen->MarkOverlappedWindows)(pWin->firstChild,
							   pWin->firstChild,
							   (WindowPtr *)NULL);
	}
	else
	{
	    (*pScreen->MarkWindow) (pWin);
	    anyMarked = TRUE;
	}


	if (anyMarked)
	    (*pScreen->ValidateTree)(pWin, NullWindow, VTOther);
    }

    if (pWin->backStorage &&
	((pWin->backingStore == Always) || WasViewable))
    {
	if (!WasViewable)
	    pOldClip = &pWin->clipList; /* a convenient empty region */
	bsExposed = (*pScreen->TranslateBackingStore)
			     (pWin, 0, 0, pOldClip,
			      pWin->drawable.x, pWin->drawable.y);
	if (WasViewable)
	    RegionDestroy(pOldClip);
	if (bsExposed)
	{
	    RegionPtr	valExposed = NullRegion;

	    if (pWin->valdata)
		valExposed = &pWin->valdata->after.exposed;
	    (*pScreen->WindowExposures) (pWin, valExposed, bsExposed);
	    if (valExposed)
		RegionEmpty(valExposed);
	    RegionDestroy(bsExposed);
	}
    }
    if (WasViewable)
    {
	if (anyMarked)
	    (*pScreen->HandleExposures)(pWin);
	if (anyMarked && pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pWin, NullWindow, VTOther);
    }
    if (pWin->realized)
	WindowsRestructured ();
    FlushAllOutput ();
}
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d87 1
a87 2
static int              darwinScreenKeyIndex;
DevPrivateKey           darwinScreenKey = &darwinScreenKeyIndex;
d187 3
d199 1
a199 1
    dfb = xalloc(sizeof(DarwinFramebufferRec));
a244 1
#ifdef RENDER
a247 1
#endif
d267 2
a268 2
    dixScreenOrigins[index].x = dfb->x;
    dixScreenOrigins[index].y = dfb->y;
d531 2
a532 2
    left = dixScreenOrigins[0].x;
    top  = dixScreenOrigins[0].y;
d536 2
a537 2
        if (dixScreenOrigins[i].x < left  ||
            (dixScreenOrigins[i].x == left && dixScreenOrigins[i].y < top))
d539 2
a540 2
            left = dixScreenOrigins[i].x;
            top = dixScreenOrigins[i].y;
d556 2
a557 2
            dixScreenOrigins[i].x -= darwinMainScreenX;
            dixScreenOrigins[i].y -= darwinMainScreenY;
d559 1
a559 1
                      i, dixScreenOrigins[i].x, dixScreenOrigins[i].y);
d798 1
a798 1
    WindowPtr	pWin = WindowTable[pScreen->myNum];
d822 2
a823 2
		borderVisible = REGION_CREATE(pScreen, NullBox, 1);
		REGION_SUBTRACT(pScreen, borderVisible,
d842 2
a843 2
	REGION_RESET(pScreen, &pWin->borderClip, &box);
	REGION_BREAK (pWin->drawable.pScreen, &pWin->clipList);
d847 2
a848 2
	REGION_EMPTY(pScreen, &pWin->borderClip);
	REGION_BREAK (pWin->drawable.pScreen, &pWin->clipList);
d857 2
a858 2
	    pOldClip = REGION_CREATE(pScreen, NullBox, 1);
	    REGION_COPY(pScreen, pOldClip, &pWin->clipList);
d887 1
a887 1
	    REGION_DESTROY(pScreen, pOldClip);
d896 2
a897 2
		REGION_EMPTY(pScreen, valExposed);
	    REGION_DESTROY(pScreen, bsExposed);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d48 1
d55 2
d71 1
a71 2
#define _XSHM_SERVER_
#include <X11/extensions/XShm.h>
a77 4
//#include "darwinClut8.h"

#include "GL/visualConfigs.h"

a99 1
unsigned int            darwinDesiredWidth = 0, darwinDesiredHeight = 0;
a100 1
int                     darwinDesiredRefresh = -1;
a153 4
void DDXRingBell(int volume, int pitch, int duration) {
  // FIXME -- make some noise, yo
}

d178 1
a178 1
 * DarwinAddScreen
d182 1
a182 1
static Bool DarwinAddScreen(int index, ScreenPtr pScreen, int argc, char **argv) {
d189 6
a194 1
    if (index == 0) foundIndex = 0;
a207 3
    // reset the visual list
    miClearVisualTypes();

a217 6

#if 0
    /*
     * These aren't used anymore.  xpr/xprScreen.c initializes the dfb struct
     * above based on the display properties.
     */
d219 1
a219 1
        miSetVisualTypesAndMasks(15, LARGE_VISUALS, 5, TrueColor, 0x7c00, 0x03e0, 0x001f);
d221 1
a221 2
        miSetVisualTypesAndMasks(24, LARGE_VISUALS, 8, TrueColor, 0x00ff0000, 0x0000ff00, 0x000000ff);
#endif
a242 23
//    ErrorF("Screen type: %d, %d=%d, %d=%d, %d=%d, %x=%x=%x, %x=%x=%x, %x=%x=%x\n", pScreen->visuals->class,
//           pScreen->visuals->offsetRed, dfb->bitsPerRGB * 2,
//           pScreen->visuals->offsetGreen, dfb->bitsPerRGB,
//           pScreen->visuals->offsetBlue, 0,
//           pScreen->visuals->redMask, dfb->redMask, ((1<<dfb->bitsPerRGB)-1) << pScreen->visuals->offsetRed,
//           pScreen->visuals->greenMask, dfb->greenMask, ((1<<dfb->bitsPerRGB)-1) << pScreen->visuals->offsetGreen,
//           pScreen->visuals->blueMask, dfb->blueMask, ((1<<dfb->bitsPerRGB)-1) << pScreen->visuals->offsetBlue);

    // set the RGB order correctly for TrueColor
//    if (dfb->bitsPerPixel > 8) {
//        for (i = 0, visual = pScreen->visuals;  // someday we may have more than 1
//            i < pScreen->numVisuals; i++, visual++) {
//            if (visual->class == TrueColor) {
//                visual->offsetRed = bitsPerRGB * 2;
//                visual->offsetGreen = bitsPerRGB;
//                visual->offsetBlue = 0;
//                visual->redMask = ((1<<bitsPerRGB)-1) << visual->offsetRed;
//                visual->greenMask = ((1<<bitsPerRGB)-1) << visual->offsetGreen;
//                visual->blueMask = ((1<<bitsPerRGB)-1) << visual->offsetBlue;
//            }
//        }
//    }

a266 15
    /* Set the colormap to the statically defined one if we're in 8 bit
     * mode and we're using a fixed color map.  Essentially this translates
     * to Darwin/x86 in 8-bit mode.
     */
//    if(dfb->depth == 8) {
//        ColormapPtr map = RootlessGetColormap (pScreen);
//        for( i = 0; i < map->pVisual->ColormapEntries; i++ ) {
//            Entry *ent = map->red + i;
//            ErrorF("Setting lo %d -> r: %04x g: %04x b: %04x\n", i, darwinClut8[i].red, darwinClut8[i].green, darwinClut8[i].blue);
//            ent->co.local.red   = darwinClut8[i].red;
//            ent->co.local.green = darwinClut8[i].green;
//            ent->co.local.blue  = darwinClut8[i].blue;
//        }
//    }

d288 2
d291 4
a294 2
    CARD8 map[8] = {0, 1, 2, 3, 4, 5, 6, 7};
    
d298 13
a310 1
            
d312 2
a313 1
            InitPointerDeviceStruct((DevicePtr)pPointer, map, 7,
d315 2
a316 1
                                    GetMotionHistorySize(), 2);
d334 2
d339 6
a344 2
    CARD8 map[4] = {0, 1, 2, 3};
    
d348 11
a358 1
            
d360 2
a361 1
            InitPointerDeviceStruct((DevicePtr)pPointer, map, 3,
d363 2
a364 1
                                    GetMotionHistorySize(), 5);
d369 5
a373 5
            InitValuatorAxisStruct(pPointer, 0, 0, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1);
            InitValuatorAxisStruct(pPointer, 1, 0, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1);
            InitValuatorAxisStruct(pPointer, 2, 0, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1);
            InitValuatorAxisStruct(pPointer, 3, -XQUARTZ_VALUATOR_LIMIT, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1);
            InitValuatorAxisStruct(pPointer, 4, -XQUARTZ_VALUATOR_LIMIT, XQUARTZ_VALUATOR_LIMIT, 1, 0, 1);
d387 2
d465 5
d572 1
a572 1
 *  Inside DarwinAddScreen are two other mode specific calls.
a591 4
#ifdef GLXEXT
    setVisualConfigs();    
#endif

d597 1
a597 1
        AddScreen( DarwinAddScreen, argc, argv );
d605 1
a605 1
 * OsVendorFataError
a709 15
    if ( !strcmp( argv[i], "-size" ) ) {
        if ( i >= argc-2 ) {
            FatalError( "-size must be followed by two numbers\n" );
        }
#ifdef OLD_POWERBOOK_G3
        ErrorF( "Ignoring unsupported -size option on old PowerBook G3\n" );
#else
        darwinDesiredWidth = atoi( argv[i+1] );
        darwinDesiredHeight = atoi( argv[i+2] );
        ErrorF( "Attempting to use width x height = %i x %i\n",
                darwinDesiredWidth, darwinDesiredHeight );
#endif
        return 3;
    }

a713 3
#ifdef OLD_POWERBOOK_G3
        ErrorF( "Ignoring unsupported -depth option on old PowerBook G3\n");
#else
a722 14
#endif
        return 2;
    }

    if ( !strcmp( argv[i], "-refresh" ) ) {
        if ( i == argc-1 ) {
            FatalError( "-refresh must be followed by a number\n" );
        }
#ifdef OLD_POWERBOOK_G3
        ErrorF( "Ignoring unsupported -refresh option on old PowerBook G3\n");
#else
        darwinDesiredRefresh = atoi( argv[i+1] );
        ErrorF( "Attempting to use refresh rate of %i\n", darwinDesiredRefresh );
#endif
d746 1
a753 6
    ErrorF("\n");
    ErrorF("Options ignored in rootless mode:\n");
    ErrorF("-size <height> <width> : use a screen resolution of <height> x <width>.\n");
    ErrorF("-depth <8,15,24> : use this bit depth.\n");
    ErrorF("-refresh <rate> : use a monitor refresh rate of <rate> Hz.\n");
    ErrorF("\n");
d763 1
a763 1
    ErrorF( "Quitting Xquartz...\n" );
d776 1
a776 5
    /*
     * This is needed for a abnormal server exit, since the normal exit stuff
     * MUST also be performed (i.e. the vt must be left in a defined state)
     */
    ddxGiveUp();
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d3 1
a3 2
 * Shared code for the Darwin X Server
 * running with Quartz or IOKit display mode
d5 1
a6 1
 * Copyright (c) 2007 Apple Inc.
d49 4
a52 6
#ifdef XINPUT
# include <X11/extensions/XI.h>
# include <X11/extensions/XIproto.h>
# include "exevents.h"
# include "extinit.h"
#endif
a64 1
#include <IOKit/IOKitLib.h>
a65 1
#include <IOKit/hidsystem/ev_keymap.h>
d74 1
a74 1
#include "darwinKeyboard.h"
d78 3
d89 2
a90 1
DevPrivateKey           darwinScreenKey = &darwinScreenKey;
a104 1
char                    *darwinKeymapFile = "USA.keymapping";
d107 5
a111 1
// modifier masks for faking mouse buttons
d114 7
d123 1
d125 4
a128 1
DeviceIntPtr            darwinKeyboard = NULL;
d166 1
a166 2
  ErrorF("XQuartz starting:\n");
  ErrorF("X.org Release 7.2\n"); // This is here to help fink until they fix their packages.
a184 1

d220 15
d243 1
a243 1
        dpi = 75;
a334 1
#if 0
d336 1
a336 3
 * DarwinChangePointerControl
 *  Set mouse acceleration and thresholding
 *  FIXME: We currently ignore the threshold in ctrl->threshold.
d338 29
a366 14
static void DarwinChangePointerControl(
    DeviceIntPtr    device,
    PtrCtrl         *ctrl )
{
    kern_return_t   kr;
    double          acceleration;

    if (!darwinMouseAccelChange)
        return;

    acceleration = ctrl->num / ctrl->den;
    kr = IOHIDSetMouseAcceleration( darwinParamConnect, acceleration );
    if (kr != KERN_SUCCESS)
        ErrorF( "Could not set mouse acceleration with kernel return = 0x%x.\n", kr );
a367 11
#endif

/*
 * DarwinMouseProc
 *  Handle the initialization, etc. of a mouse
 */
static int DarwinMouseProc(
    DeviceIntPtr    pPointer,
    int             what )
{
    CARD8 map[6];
d369 3
a372 1

d375 1
a375 1

d377 13
a389 26
            map[1] = 1;
            map[2] = 2;
            map[3] = 3;
            map[4] = 4;
            map[5] = 5;
            InitPointerDeviceStruct( (DevicePtr)pPointer, map, 5,
				     GetMotionHistory,
				     (PtrCtrlProcPtr)NoopDDA,
				     GetMotionHistorySize(), 2);

#ifdef XINPUT
            InitValuatorAxisStruct( pPointer,
                                    0,     // X axis
                                    0,     // min value
                                    16000, // max value (fixme screen size?)
                                    1,     // resolution (fixme ?)
                                    1,     // min resolution
                                    1 );   // max resolution
            InitValuatorAxisStruct( pPointer,
                                    1,     // X axis
                                    0,     // min value
                                    16000, // max value (fixme screen size?)
                                    1,     // resolution (fixme ?)
                                    1,     // min resolution
                                    1 );   // max resolution
#endif
a390 1

a394 1

d398 1
a398 1
            RemoveEnabledDevice( darwinEventReadFD );
a400 1

a403 1

a437 56
 * DarwinFindLibraryFile
 *  Search for a file in the standard Library paths, which are (in order):
 *
 *      ~/Library/              user specific
 *      /Library/               host specific
 *      /Network/Library/       LAN specific
 *      /System/Library/        OS specific
 *
 *  A sub-path can be specified to search in below the various Library
 *  directories. Returns a new character string (owned by the caller)
 *  containing the full path to the first file found.
 */
static char * DarwinFindLibraryFile(
    const char *file,
    const char *pathext )
{
    // Library search paths
    char *pathList[] = {
        "",
        "/Network",
        "/System",
        NULL
    };
    char *home;
    char *fullPath;
    int i = 0;

    // Return the file name as is if it is already a fully qualified path.
    if (!access(file, F_OK)) {
        fullPath = xalloc(strlen(file)+1);
        strcpy(fullPath, file);
        return fullPath;
    }

    fullPath = xalloc(PATH_MAX);

    home = getenv("HOME");
    if (home) {
        snprintf(fullPath, PATH_MAX, "%s/Library/%s/%s", home, pathext, file);
        if (!access(fullPath, F_OK))
            return fullPath;
    }

    while (pathList[i]) {
        snprintf(fullPath, PATH_MAX, "%s/Library/%s/%s", pathList[i++],
                 pathext, file);
        if (!access(fullPath, F_OK))
            return fullPath;
    }

    xfree(fullPath);
    return NULL;
}


/*
d441 1
a441 2
int DarwinParseModifierList(
    const char *constmodifiers) // string containing list of modifier names
d453 3
a455 3
            nxkey = DarwinModifierStringToNXKey(modifier);
            if (nxkey != -1)
                result |= DarwinModifierNXKeyToNXMask(nxkey);
d478 19
a496 1
    darwinPointer = AddInputDevice(DarwinMouseProc, TRUE);
d498 9
d508 5
a512 2
    darwinKeyboard = AddInputDevice(DarwinKeybdProc, TRUE);
    RegisterKeyboardDevice( darwinKeyboard );
d514 1
a514 1
    DarwinEQInit( (DevicePtr)darwinKeyboard, (DevicePtr)darwinPointer );
d545 1
a545 2
            (dixScreenOrigins[i].x == left &&
             dixScreenOrigins[i].y < top))
d554 2
d558 3
a560 2
       is at X11 (0,0) and at global screen coordinate
       (darwinMainScreenX, darwinMainScreenY). */
d566 2
a567 2
    /*            ErrorF("Screen %d placed at X11 coordinate (%d,%d).\n",
		  i, dixScreenOrigins[i].x, dixScreenOrigins[i].y); */
d600 4
a647 21
    //    DEBUG_LOG("Xquartz started at %s\n", ctime(time(NULL)));

    // Find the full path to the keymapping file.
    if ( darwinKeymapFile ) {
        char *tempStr = DarwinFindLibraryFile(darwinKeymapFile, "Keyboards");
        if ( !tempStr ) {
            ErrorF("Could not find keymapping file %s.\n", darwinKeymapFile);
        } else {
            ErrorF("Using keymapping provided in %s.\n", tempStr);
        }
        darwinKeymapFile = tempStr;
    }
}


/*
 * ddxInitGlobals
 *  Called by InitGlobals() from os/util.c.
 */
void ddxInitGlobals(void)
{
d693 1
a693 1
            darwinFakeMouse2Mask = DarwinParseModifierList(argv[i+1]);
d706 1
a706 1
            darwinFakeMouse3Mask = DarwinParseModifierList(argv[i+1]);
a711 13
    if ( !strcmp( argv[i], "-keymap" ) ) {
        if ( i == argc-1 ) {
            FatalError( "-keymap must be followed by a filename\n" );
        }
        darwinKeymapFile = argv[i+1];
        return 2;
    }

    if ( !strcmp( argv[i], "-nokeymap" ) ) {
        darwinKeymapFile = NULL;
        return 1;
    }

a794 1
    ErrorF("-keymap <file> : read the keymapping from a file instead of the kernel.\n");
a796 3
//    ErrorF("Quartz modes (Experimental / In Development):\n");
//    ErrorF("-fullscreen : run full screen in parallel with Mac OS X window server.\n");
//    ErrorF("-rootless : run rootless inside Mac OS X window server.\n");
d812 1
a812 4
    ErrorF( "Quitting XQuartz...\n" );

    //if (!quartzRootless)
    //    quartzProcs->ReleaseScreens();
d849 1
a849 1
xf86SetRootClip (ScreenPtr pScreen, BOOL enable)
a855 3
#ifdef DO_SAVE_UNDERS
    Bool	dosave = FALSE;
#endif
a925 6
#ifdef DO_SAVE_UNDERS
	if (DO_SAVE_UNDERS(pWin))
	{
	    dosave = (*pScreen->ChangeSaveUnder)(pLayerWin, pLayerWin);
	}
#endif /* DO_SAVE_UNDERS */
a956 4
#ifdef DO_SAVE_UNDERS
	if (dosave)
	    (*pScreen->PostChangeSaveUnder)(pLayerWin, pLayerWin);
#endif /* DO_SAVE_UNDERS */
@

