head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@// @;


1.10
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	7pAEtF6Y5EgemkuY;

1.9
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.53;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.53;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.02.16.08.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.29;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@/* X11Application.m -- subclass of NSApplication to multiplex events
 *
 * Copyright (c) 2002-2012 Apple Inc. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT
 * HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above
 * copyright holders shall not be used in advertising or otherwise to
 * promote the sale, use or other dealings in this Software without
 * prior written authorization.
 */

#include "sanitizedCarbon.h"

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "quartzCommon.h"

#import "X11Application.h"

#include "darwin.h"
#include "quartz.h"
#include "darwinEvents.h"
#include "quartzKeyboard.h"
#include <X11/extensions/applewmconst.h>
#include "micmap.h"
#include "exglobals.h"

#include <mach/mach.h>
#include <unistd.h>
#include <AvailabilityMacros.h>

#include <pthread.h>

#include <Xplugin.h>

// pbproxy/pbproxy.h
extern int
xpbproxy_run(void);

#define DEFAULTS_FILE X11LIBDIR "/X11/xserver/Xquartz.plist"

#ifndef XSERVER_VERSION
#define XSERVER_VERSION "?"
#endif

#ifdef HAVE_LIBDISPATCH
#include <dispatch/dispatch.h>

static dispatch_queue_t eventTranslationQueue;
#endif

#ifndef __has_feature
#define __has_feature(x) 0
#endif

#ifndef CF_RETURNS_RETAINED
#if __has_feature(attribute_cf_returns_retained)
#define CF_RETURNS_RETAINED __attribute__((cf_returns_retained))
#else
#define CF_RETURNS_RETAINED
#endif
#endif

extern Bool noTestExtensions;
extern Bool noRenderExtension;
extern BOOL serverRunning;

#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
static TISInputSourceRef last_key_layout;
#else
static KeyboardLayoutRef last_key_layout;
#endif

/* This preference is only tested on Lion or later as it's not relevant to
 * earlier OS versions.
 */
Bool XQuartzScrollInDeviceDirection = FALSE;

extern int darwinFakeButtons;

/* Store the mouse location while in the background, and update X11's pointer
 * location when we become the foreground application
 */
static NSPoint bgMouseLocation;
static BOOL bgMouseLocationUpdated = FALSE;

X11Application *X11App;

CFStringRef app_prefs_domain_cfstr = NULL;

#define ALL_KEY_MASKS (NSShiftKeyMask | NSControlKeyMask | \
                       NSAlternateKeyMask | NSCommandKeyMask)

@@interface X11Application (Private)
- (void) sendX11NSEvent:(NSEvent *)e;
@@end

@@implementation X11Application

typedef struct message_struct message;
struct message_struct {
    mach_msg_header_t hdr;
    SEL selector;
    NSObject *arg;
};

static mach_port_t _port;

/* Quartz mode initialization routine. This is often dynamically loaded
   but is statically linked into this X server. */
Bool
QuartzModeBundleInit(void);

static void
init_ports(void)
{
    kern_return_t r;
    NSPort *p;

    if (_port != MACH_PORT_NULL) return;

    r = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &_port);
    if (r != KERN_SUCCESS) return;

    p = [NSMachPort portWithMachPort:_port];
    [p setDelegate:NSApp];
    [p scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:
     NSDefaultRunLoopMode];
}

static void
message_kit_thread(SEL selector, NSObject *arg)
{
    message msg;
    kern_return_t r;

    msg.hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg.hdr.msgh_size = sizeof(msg);
    msg.hdr.msgh_remote_port = _port;
    msg.hdr.msgh_local_port = MACH_PORT_NULL;
    msg.hdr.msgh_reserved = 0;
    msg.hdr.msgh_id = 0;

    msg.selector = selector;
    msg.arg = [arg retain];

    r = mach_msg(&msg.hdr, MACH_SEND_MSG, msg.hdr.msgh_size,
                 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);
    if (r != KERN_SUCCESS)
        ErrorF("%s: mach_msg failed: %x\n", __FUNCTION__, r);
}

- (void) handleMachMessage:(void *)_msg
{
    message *msg = _msg;

    [self performSelector:msg->selector withObject:msg->arg];
    [msg->arg release];
}

- (void) set_controller:obj
{
    if (_controller == nil) _controller = [obj retain];
}

- (void) dealloc
{
    if (_controller != nil) [_controller release];

    if (_port != MACH_PORT_NULL)
        mach_port_deallocate(mach_task_self(), _port);

    [super dealloc];
}

- (void) orderFrontStandardAboutPanel: (id) sender
{
    NSMutableDictionary *dict;
    NSDictionary *infoDict;
    NSString *tem;

    dict = [NSMutableDictionary dictionaryWithCapacity:3];
    infoDict = [[NSBundle mainBundle] infoDictionary];

    [dict setObject: NSLocalizedString(@@"The X Window System", @@"About panel")
             forKey:@@"ApplicationName"];

    tem = [infoDict objectForKey:@@"CFBundleShortVersionString"];

    [dict setObject:[NSString stringWithFormat:@@"XQuartz %@@", tem]
             forKey:@@"ApplicationVersion"];

    [dict setObject:[NSString stringWithFormat:@@"xorg-server %s",
                     XSERVER_VERSION]
     forKey:@@"Version"];

    [self orderFrontStandardAboutPanelWithOptions: dict];
}

- (void) activateX:(OSX_BOOL)state
{
    if (_x_active == state)
        return;

    DEBUG_LOG("state=%d, _x_active=%d, \n", state, _x_active);
    if (state) {
        if (bgMouseLocationUpdated) {
            DarwinSendPointerEvents(darwinPointer, MotionNotify, 0,
                                    bgMouseLocation.x, bgMouseLocation.y,
                                    0.0, 0.0);
            bgMouseLocationUpdated = FALSE;
        }
        DarwinSendDDXEvent(kXquartzActivate, 0);
    }
    else {

        if (darwin_all_modifier_flags)
            DarwinUpdateModKeys(0);

        DarwinInputReleaseButtonsAndKeys(darwinKeyboard);
        DarwinInputReleaseButtonsAndKeys(darwinPointer);
        DarwinInputReleaseButtonsAndKeys(darwinTabletCursor);
        DarwinInputReleaseButtonsAndKeys(darwinTabletStylus);
        DarwinInputReleaseButtonsAndKeys(darwinTabletEraser);

        DarwinSendDDXEvent(kXquartzDeactivate, 0);
    }

    _x_active = state;
}

- (void) became_key:(NSWindow *)win
{
    [self activateX:NO];
}

- (void) sendEvent:(NSEvent *)e
{
    OSX_BOOL for_appkit, for_x;

    /* By default pass down the responder chain and to X. */
    for_appkit = YES;
    for_x = YES;

    switch ([e type]) {
    case NSLeftMouseDown:
    case NSRightMouseDown:
    case NSOtherMouseDown:
    case NSLeftMouseUp:
    case NSRightMouseUp:
    case NSOtherMouseUp:
        if ([e window] != nil) {
            /* Pointer event has an (AppKit) window. Probably something for the kit. */
            for_x = NO;
            if (_x_active) [self activateX:NO];
        }
        else if ([self modalWindow] == nil) {
            /* Must be an X window. Tell appkit it doesn't have focus. */
            for_appkit = NO;

            if ([self isActive]) {
                [self deactivate];
                if (!_x_active && quartzProcs->IsX11Window([e windowNumber]))
                    [self activateX:YES];
            }
        }

        /* We want to force sending to appkit if we're over the menu bar */
        if (!for_appkit) {
            NSPoint NSlocation = [e locationInWindow];
            NSWindow *window = [e window];
            NSRect NSframe, NSvisibleFrame;
            CGRect CGframe, CGvisibleFrame;
            CGPoint CGlocation;

            if (window != nil) {
                NSRect frame = [window frame];
                NSlocation.x += frame.origin.x;
                NSlocation.y += frame.origin.y;
            }

            NSframe = [[NSScreen mainScreen] frame];
            NSvisibleFrame = [[NSScreen mainScreen] visibleFrame];

            CGframe = CGRectMake(NSframe.origin.x, NSframe.origin.y,
                                 NSframe.size.width, NSframe.size.height);
            CGvisibleFrame = CGRectMake(NSvisibleFrame.origin.x,
                                        NSvisibleFrame.origin.y,
                                        NSvisibleFrame.size.width,
                                        NSvisibleFrame.size.height);
            CGlocation = CGPointMake(NSlocation.x, NSlocation.y);

            if (CGRectContainsPoint(CGframe, CGlocation) &&
                !CGRectContainsPoint(CGvisibleFrame, CGlocation))
                for_appkit = YES;
        }

        break;

    case NSKeyDown:
    case NSKeyUp:

        if (_x_active) {
            static BOOL do_swallow = NO;
            static int swallow_keycode;

            if ([e type] == NSKeyDown) {
                /* Before that though, see if there are any global
                 * shortcuts bound to it. */

                if (darwinAppKitModMask &[e modifierFlags]) {
                    /* Override to force sending to Appkit */
                    swallow_keycode = [e keyCode];
                    do_swallow = YES;
                    for_x = NO;
#if XPLUGIN_VERSION >= 1
                }
                else if (XQuartzEnableKeyEquivalents &&
                         xp_is_symbolic_hotkey_event([e eventRef])) {
                    swallow_keycode = [e keyCode];
                    do_swallow = YES;
                    for_x = NO;
#endif
                }
                else if (XQuartzEnableKeyEquivalents &&
                         [[self mainMenu] performKeyEquivalent:e]) {
                    swallow_keycode = [e keyCode];
                    do_swallow = YES;
                    for_appkit = NO;
                    for_x = NO;
                }
                else if (!XQuartzIsRootless
                         && ([e modifierFlags] & ALL_KEY_MASKS) ==
                         (NSCommandKeyMask | NSAlternateKeyMask)
                         && ([e keyCode] == 0 /*a*/ || [e keyCode] ==
                             53 /*Esc*/)) {
                    /* We have this here to force processing fullscreen
                     * toggle even if XQuartzEnableKeyEquivalents is disabled */
                    swallow_keycode = [e keyCode];
                    do_swallow = YES;
                    for_x = NO;
                    for_appkit = NO;
                    DarwinSendDDXEvent(kXquartzToggleFullscreen, 0);
                }
                else {
                    /* No kit window is focused, so send it to X. */
                    for_appkit = NO;
                }
            }
            else {       /* KeyUp */
                /* If we saw a key equivalent on the down, don't pass
                 * the up through to X. */
                if (do_swallow && [e keyCode] == swallow_keycode) {
                    do_swallow = NO;
                    for_x = NO;
                }
            }
        }
        else {       /* !_x_active */
            for_x = NO;
        }
        break;

    case NSFlagsChanged:
        /* Don't tell X11 about modifiers changing while it's not active */
        if (!_x_active)
            for_x = NO;
        break;

    case NSAppKitDefined:
        switch ([e subtype]) {
            static BOOL x_was_active = NO;

        case NSApplicationActivatedEventType:
            for_x = NO;
            if ([e window] == nil && x_was_active) {
                BOOL order_all_windows = YES, workspaces, ok;
                for_appkit = NO;

                /* FIXME: This is a hack to avoid passing the event to AppKit which
                 *        would result in it raising one of its windows.
                 */
                _appFlags._active = YES;

                [self set_front_process:nil];

                /* Get the Spaces preference for SwitchOnActivate */
                (void)CFPreferencesAppSynchronize(CFSTR("com.apple.dock"));
                workspaces =
                    CFPreferencesGetAppBooleanValue(CFSTR("workspaces"),
                                                    CFSTR(
                                                        "com.apple.dock"),
                                                    &ok);
                if (!ok)
                    workspaces = NO;

                if (workspaces) {
                    (void)CFPreferencesAppSynchronize(CFSTR(
                                                          ".GlobalPreferences"));
                    order_all_windows =
                        CFPreferencesGetAppBooleanValue(CFSTR(
                                                            "AppleSpacesSwitchOnActivate"),
                                                        CFSTR(
                                                            ".GlobalPreferences"),
                                                        &ok);
                    if (!ok)
                        order_all_windows = YES;
                }

                /* TODO: In the workspaces && !AppleSpacesSwitchOnActivate case, the windows are ordered
                 *       correctly, but we need to activate the top window on this space if there is
                 *       none active.
                 *
                 *       If there are no active windows, and there are minimized windows, we should
                 *       be restoring one of them.
                 */
                if ([e data2] & 0x10) {         // 0x10 (bfCPSOrderAllWindowsForward) is set when we use cmd-tab or the dock icon
                    DarwinSendDDXEvent(kXquartzBringAllToFront, 1,
                                       order_all_windows);
                }
            }
            break;

        case 18:         /* ApplicationDidReactivate */
            if (XQuartzFullscreenVisible) for_appkit = NO;
            break;

        case NSApplicationDeactivatedEventType:
            for_x = NO;

            x_was_active = _x_active;
            if (_x_active)
                [self activateX:NO];
            break;
        }
        break;

    default:
        break;          /* for gcc */
    }

    if (for_appkit) [super sendEvent:e];

    if (for_x) {
#ifdef HAVE_LIBDISPATCH
        dispatch_async(eventTranslationQueue, ^{
                           [self sendX11NSEvent:e];
                       });
#else
        [self sendX11NSEvent:e];
#endif
    }
}

- (void) set_window_menu:(NSArray *)list
{
    [_controller set_window_menu:list];
}

- (void) set_window_menu_check:(NSNumber *)n
{
    [_controller set_window_menu_check:n];
}

- (void) set_apps_menu:(NSArray *)list
{
    [_controller set_apps_menu:list];
}

- (void) set_front_process:unused
{
    [NSApp activateIgnoringOtherApps:YES];

    if ([self modalWindow] == nil)
        [self activateX:YES];
}

- (void) set_can_quit:(NSNumber *)state
{
    [_controller set_can_quit:[state boolValue]];
}

- (void) server_ready:unused
{
    [_controller server_ready];
}

- (void) show_hide_menubar:(NSNumber *)state
{
    /* Also shows/hides the dock */
    if ([state boolValue])
        SetSystemUIMode(kUIModeNormal, 0);
    else
        SetSystemUIMode(kUIModeAllHidden,
                        XQuartzFullscreenMenu ? kUIOptionAutoShowMenuBar : 0);                   // kUIModeAllSuppressed or kUIOptionAutoShowMenuBar can be used to allow "mouse-activation"
}

- (void) launch_client:(NSString *)cmd
{
    (void)[_controller application:self openFile:cmd];
}

/* user preferences */

/* Note that these functions only work for arrays whose elements
   can be toll-free-bridged between NS and CF worlds. */

static const void *
cfretain(CFAllocatorRef a, const void *b)
{
    return CFRetain(b);
}

static void
cfrelease(CFAllocatorRef a, const void *b)
{
    CFRelease(b);
}

CF_RETURNS_RETAINED
static CFMutableArrayRef
nsarray_to_cfarray(NSArray *in)
{
    CFMutableArrayRef out;
    CFArrayCallBacks cb;
    NSObject *ns;
    const CFTypeRef *cf;
    int i, count;

    memset(&cb, 0, sizeof(cb));
    cb.version = 0;
    cb.retain = cfretain;
    cb.release = cfrelease;

    count = [in count];
    out = CFArrayCreateMutable(NULL, count, &cb);

    for (i = 0; i < count; i++) {
        ns = [in objectAtIndex:i];

        if ([ns isKindOfClass:[NSArray class]])
            cf = (CFTypeRef)nsarray_to_cfarray((NSArray *)ns);
        else
            cf = CFRetain((CFTypeRef)ns);

        CFArrayAppendValue(out, cf);
        CFRelease(cf);
    }

    return out;
}

static NSMutableArray *
cfarray_to_nsarray(CFArrayRef in)
{
    NSMutableArray *out;
    const CFTypeRef *cf;
    NSObject *ns;
    int i, count;

    count = CFArrayGetCount(in);
    out = [[NSMutableArray alloc] initWithCapacity:count];

    for (i = 0; i < count; i++) {
        cf = CFArrayGetValueAtIndex(in, i);

        if (CFGetTypeID(cf) == CFArrayGetTypeID())
            ns = cfarray_to_nsarray((CFArrayRef)cf);
        else
            ns = [(id) cf retain];

        [out addObject:ns];
        [ns release];
    }

    return out;
}

- (CFPropertyListRef) prefs_get_copy:(NSString *)key
{
    CFPropertyListRef value;

    value = CFPreferencesCopyAppValue((CFStringRef)key,
                                      app_prefs_domain_cfstr);

    if (value == NULL) {
        static CFDictionaryRef defaults;

        if (defaults == NULL) {
            CFStringRef error = NULL;
            CFDataRef data;
            CFURLRef url;
            SInt32 error_code;

            url = (CFURLCreateFromFileSystemRepresentation
                       (NULL, (unsigned char *)DEFAULTS_FILE,
                       strlen(DEFAULTS_FILE), false));
            if (CFURLCreateDataAndPropertiesFromResource(NULL, url, &data,
                                                         NULL, NULL,
                                                         &error_code)) {
                defaults = (CFPropertyListCreateFromXMLData
                                (NULL, data,
                                kCFPropertyListMutableContainersAndLeaves,
                                &error));
                if (error != NULL) CFRelease(error);
                CFRelease(data);
            }
            CFRelease(url);

            if (defaults != NULL) {
                NSMutableArray *apps, *elt;
                int count, i;
                NSString *name, *nname;

                /* Localize the names in the default apps menu. */

                apps =
                    [(NSDictionary *) defaults objectForKey:@@PREFS_APPSMENU];
                if (apps != nil) {
                    count = [apps count];
                    for (i = 0; i < count; i++) {
                        elt = [apps objectAtIndex:i];
                        if (elt != nil &&
                            [elt isKindOfClass:[NSArray class]]) {
                            name = [elt objectAtIndex:0];
                            if (name != nil) {
                                nname = NSLocalizedString(name, nil);
                                if (nname != nil && nname != name)
                                    [elt replaceObjectAtIndex:0 withObject:
                                     nname];
                            }
                        }
                    }
                }
            }
        }

        if (defaults != NULL) value = CFDictionaryGetValue(defaults, key);
        if (value != NULL) CFRetain(value);
    }

    return value;
}

- (int) prefs_get_integer:(NSString *)key default:(int)def
{
    CFPropertyListRef value;
    int ret;

    value = [self prefs_get_copy:key];

    if (value != NULL && CFGetTypeID(value) == CFNumberGetTypeID())
        CFNumberGetValue(value, kCFNumberIntType, &ret);
    else if (value != NULL && CFGetTypeID(value) == CFStringGetTypeID())
        ret = CFStringGetIntValue(value);
    else
        ret = def;

    if (value != NULL) CFRelease(value);

    return ret;
}

- (const char *) prefs_get_string:(NSString *)key default:(const char *)def
{
    CFPropertyListRef value;
    const char *ret = NULL;

    value = [self prefs_get_copy:key];

    if (value != NULL && CFGetTypeID(value) == CFStringGetTypeID()) {
        NSString *s = (NSString *)value;

        ret = [s UTF8String];
    }

    if (value != NULL) CFRelease(value);

    return ret != NULL ? ret : def;
}

- (NSURL *) prefs_copy_url:(NSString *)key default:(NSURL *)def
{
    CFPropertyListRef value;
    NSURL *ret = NULL;

    value = [self prefs_get_copy:key];

    if (value != NULL && CFGetTypeID(value) == CFStringGetTypeID()) {
        NSString *s = (NSString *)value;

        ret = [NSURL URLWithString:s];
        [ret retain];
    }

    if (value != NULL) CFRelease(value);

    return ret != NULL ? ret : def;
}

- (float) prefs_get_float:(NSString *)key default:(float)def
{
    CFPropertyListRef value;
    float ret = def;

    value = [self prefs_get_copy:key];

    if (value != NULL
        && CFGetTypeID(value) == CFNumberGetTypeID()
        && CFNumberIsFloatType(value))
        CFNumberGetValue(value, kCFNumberFloatType, &ret);
    else if (value != NULL && CFGetTypeID(value) == CFStringGetTypeID())
        ret = CFStringGetDoubleValue(value);

    if (value != NULL) CFRelease(value);

    return ret;
}

- (int) prefs_get_boolean:(NSString *)key default:(int)def
{
    CFPropertyListRef value;
    int ret = def;

    value = [self prefs_get_copy:key];

    if (value != NULL) {
        if (CFGetTypeID(value) == CFNumberGetTypeID())
            CFNumberGetValue(value, kCFNumberIntType, &ret);
        else if (CFGetTypeID(value) == CFBooleanGetTypeID())
            ret = CFBooleanGetValue(value);
        else if (CFGetTypeID(value) == CFStringGetTypeID()) {
            const char *tem = [(NSString *) value UTF8String];
            if (strcasecmp(tem, "true") == 0 || strcasecmp(tem, "yes") == 0)
                ret = YES;
            else
                ret = NO;
        }

        CFRelease(value);
    }
    return ret;
}

- (NSArray *) prefs_get_array:(NSString *)key
{
    NSArray *ret = nil;
    CFPropertyListRef value;

    value = [self prefs_get_copy:key];

    if (value != NULL) {
        if (CFGetTypeID(value) == CFArrayGetTypeID())
            ret = [cfarray_to_nsarray (value)autorelease];

        CFRelease(value);
    }

    return ret;
}

- (void) prefs_set_integer:(NSString *)key value:(int)value
{
    CFNumberRef x;

    x = CFNumberCreate(NULL, kCFNumberIntType, &value);

    CFPreferencesSetValue((CFStringRef)key, (CFTypeRef)x,
                          app_prefs_domain_cfstr,
                          kCFPreferencesCurrentUser,
                          kCFPreferencesAnyHost);

    CFRelease(x);
}

- (void) prefs_set_float:(NSString *)key value:(float)value
{
    CFNumberRef x;

    x = CFNumberCreate(NULL, kCFNumberFloatType, &value);

    CFPreferencesSetValue((CFStringRef)key, (CFTypeRef)x,
                          app_prefs_domain_cfstr,
                          kCFPreferencesCurrentUser,
                          kCFPreferencesAnyHost);

    CFRelease(x);
}

- (void) prefs_set_boolean:(NSString *)key value:(int)value
{
    CFPreferencesSetValue(
        (CFStringRef)key,
        (CFTypeRef)(value ? kCFBooleanTrue
                    : kCFBooleanFalse),
        app_prefs_domain_cfstr,
        kCFPreferencesCurrentUser, kCFPreferencesAnyHost);

}

- (void) prefs_set_array:(NSString *)key value:(NSArray *)value
{
    CFArrayRef cfarray;

    cfarray = nsarray_to_cfarray(value);
    CFPreferencesSetValue((CFStringRef)key,
                          (CFTypeRef)cfarray,
                          app_prefs_domain_cfstr,
                          kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    CFRelease(cfarray);
}

- (void) prefs_set_string:(NSString *)key value:(NSString *)value
{
    CFPreferencesSetValue((CFStringRef)key, (CFTypeRef)value,
                          app_prefs_domain_cfstr, kCFPreferencesCurrentUser,
                          kCFPreferencesAnyHost);
}

- (void) prefs_synchronize
{
    CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication);
}

- (void) read_defaults
{
    NSString *nsstr;
    const char *tem;

    XQuartzRootlessDefault = [self prefs_get_boolean:@@PREFS_ROOTLESS
                              default               :XQuartzRootlessDefault];
    XQuartzFullscreenMenu = [self prefs_get_boolean:@@PREFS_FULLSCREEN_MENU
                             default               :XQuartzFullscreenMenu];
    XQuartzFullscreenDisableHotkeys =
        ![self prefs_get_boolean:@@PREFS_FULLSCREEN_HOTKEYS
          default               :!
          XQuartzFullscreenDisableHotkeys];
    darwinFakeButtons = [self prefs_get_boolean:@@PREFS_FAKEBUTTONS
                         default               :darwinFakeButtons];
    XQuartzOptionSendsAlt = [self prefs_get_boolean:@@PREFS_OPTION_SENDS_ALT
                             default               :XQuartzOptionSendsAlt];

    if (darwinFakeButtons) {
        const char *fake2, *fake3;

        fake2 = [self prefs_get_string:@@PREFS_FAKE_BUTTON2 default:NULL];
        fake3 = [self prefs_get_string:@@PREFS_FAKE_BUTTON3 default:NULL];

        if (fake2 != NULL) darwinFakeMouse2Mask = DarwinParseModifierList(
                fake2, TRUE);
        if (fake3 != NULL) darwinFakeMouse3Mask = DarwinParseModifierList(
                fake3, TRUE);
    }

    tem = [self prefs_get_string:@@PREFS_APPKIT_MODIFIERS default:NULL];
    if (tem != NULL) darwinAppKitModMask = DarwinParseModifierList(tem, TRUE);

    tem = [self prefs_get_string:@@PREFS_WINDOW_ITEM_MODIFIERS default:NULL];
    if (tem != NULL) {
        windowItemModMask = DarwinParseModifierList(tem, FALSE);
    }
    else {
        nsstr = NSLocalizedString(@@"window item modifiers",
                                  @@"window item modifiers");
        if (nsstr != NULL) {
            tem = [nsstr UTF8String];
            if ((tem != NULL) && strcmp(tem, "window item modifiers")) {
                windowItemModMask = DarwinParseModifierList(tem, FALSE);
            }
        }
    }

    XQuartzEnableKeyEquivalents = [self prefs_get_boolean:@@PREFS_KEYEQUIVS
                                   default               :
                                   XQuartzEnableKeyEquivalents];

    darwinSyncKeymap = [self prefs_get_boolean:@@PREFS_SYNC_KEYMAP
                        default               :darwinSyncKeymap];

    darwinDesiredDepth = [self prefs_get_integer:@@PREFS_DEPTH
                          default               :darwinDesiredDepth];

    noTestExtensions = ![self prefs_get_boolean:@@PREFS_TEST_EXTENSIONS
                         default               :FALSE];

    noRenderExtension = ![self prefs_get_boolean:@@PREFS_RENDER_EXTENSION
                          default               :TRUE];

    XQuartzScrollInDeviceDirection =
        [self prefs_get_boolean:@@PREFS_SCROLL_IN_DEV_DIRECTION
         default               :
         XQuartzScrollInDeviceDirection];

#if XQUARTZ_SPARKLE
    NSURL *url = [self prefs_copy_url:@@PREFS_UPDATE_FEED default:nil];
    if (url) {
        [[SUUpdater sharedUpdater] setFeedURL:url];
        [url release];
    }
#endif
}

/* This will end up at the end of the responder chain. */
- (void) copy:sender
{
    DarwinSendDDXEvent(kXquartzPasteboardNotify, 1,
                       AppleWMCopyToPasteboard);
}

- (X11Controller *) controller
{
    return _controller;
}

- (OSX_BOOL) x_active
{
    return _x_active;
}

@@end

static NSArray *
array_with_strings_and_numbers(int nitems, const char **items,
                               const char *numbers)
{
    NSMutableArray *array, *subarray;
    NSString *string, *number;
    int i;

    /* (Can't autorelease on the X server thread) */

    array = [[NSMutableArray alloc] initWithCapacity:nitems];

    for (i = 0; i < nitems; i++) {
        subarray = [[NSMutableArray alloc] initWithCapacity:2];

        string = [[NSString alloc] initWithUTF8String:items[i]];
        [subarray addObject:string];
        [string release];

        if (numbers[i] != 0) {
            number = [[NSString alloc] initWithFormat:@@"%d", numbers[i]];
            [subarray addObject:number];
            [number release];
        }
        else
            [subarray addObject:@@""];

        [array addObject:subarray];
        [subarray release];
    }

    return array;
}

void
X11ApplicationSetWindowMenu(int nitems, const char **items,
                            const char *shortcuts)
{
    NSArray *array;
    array = array_with_strings_and_numbers(nitems, items, shortcuts);

    /* Send the array of strings over to the appkit thread */

    message_kit_thread(@@selector (set_window_menu:), array);
    [array release];
}

void
X11ApplicationSetWindowMenuCheck(int idx)
{
    NSNumber *n;

    n = [[NSNumber alloc] initWithInt:idx];

    message_kit_thread(@@selector (set_window_menu_check:), n);

    [n release];
}

void
X11ApplicationSetFrontProcess(void)
{
    message_kit_thread(@@selector (set_front_process:), nil);
}

void
X11ApplicationSetCanQuit(int state)
{
    NSNumber *n;

    n = [[NSNumber alloc] initWithBool:state];

    message_kit_thread(@@selector (set_can_quit:), n);

    [n release];
}

void
X11ApplicationServerReady(void)
{
    message_kit_thread(@@selector (server_ready:), nil);
}

void
X11ApplicationShowHideMenubar(int state)
{
    NSNumber *n;

    n = [[NSNumber alloc] initWithBool:state];

    message_kit_thread(@@selector (show_hide_menubar:), n);

    [n release];
}

void
X11ApplicationLaunchClient(const char *cmd)
{
    NSString *string;

    string = [[NSString alloc] initWithUTF8String:cmd];

    message_kit_thread(@@selector (launch_client:), string);

    [string release];
}

/* This is a special function in that it is run from the *SERVER* thread and
 * not the AppKit thread.  We want to block entering a screen-capturing RandR
 * mode until we notify the user about how to get out if the X11 client crashes.
 */
Bool
X11ApplicationCanEnterRandR(void)
{
    NSString *title, *msg;

    if ([X11App prefs_get_boolean:@@PREFS_NO_RANDR_ALERT default:NO] ||
        XQuartzShieldingWindowLevel != 0)
        return TRUE;

    title = NSLocalizedString(@@"Enter RandR mode?",
                              @@"Dialog title when switching to RandR");
    msg = NSLocalizedString(
        @@"An application has requested X11 to change the resolution of your display.  X11 will restore the display to its previous state when the requesting application requests to return to the previous state.  Alternatively, you can use the ⌥⌘A key sequence to force X11 to return to the previous state.",
        @@"Dialog when switching to RandR");

    if (!XQuartzIsRootless)
        QuartzShowFullscreen(FALSE);

    switch (NSRunAlertPanel(title, @@"%@@",
                            NSLocalizedString(@@"Allow",
                                              @@""),
                            NSLocalizedString(@@"Cancel",
                                              @@""),
                            NSLocalizedString(@@"Always Allow", @@""), msg)) {
    case NSAlertOtherReturn:
        [X11App prefs_set_boolean:@@PREFS_NO_RANDR_ALERT value:YES];
        [X11App prefs_synchronize];

    case NSAlertDefaultReturn:
        return YES;

    default:
        return NO;
    }
}

void
X11ApplicationFatalError(const char *f, va_list args)
{
#ifdef HAVE_LIBDISPATCH
    NSString *title, *msg;
    char *error_msg;

    /* This is called by FatalError() in the server thread just before
     * we would abort.  If the server never got off the ground, We should
     * inform the user of the error rather than letting the ever-so-friendly
     * CrashReporter do it for us.
     *
     * This also has the benefit of forcing user interaction rather than
     * allowing an infinite throttled-restart if the crash occurs before
     * we can drain the launchd socket.
     */

    if (serverRunning) {
        return;
    }

    title = NSLocalizedString(@@"The application X11 could not be opened.",
                              @@"Dialog title when encountering a fatal error");
    msg = NSLocalizedString(
        @@"An error occurred while starting the X11 server: \"%s\"\n\nClick Quit to quit X11. Click Report to see more details or send a report to Apple.",
        @@"Dialog when encountering a fatal error");

    vasprintf(&error_msg, f, args);
    msg = [NSString stringWithFormat:msg, error_msg];

    /* We want the AppKit thread to actually service the alert or we will race [NSApp run] and create an
     * 'NSInternalInconsistencyException', reason: 'NSApp with wrong _running count'
     */
    dispatch_sync(dispatch_get_main_queue(), ^{
                      if (NSAlertDefaultReturn ==
                          NSRunAlertPanel (title, @@"%@@",
                                           NSLocalizedString (@@"Quit", @@""),
                                           NSLocalizedString (@@"Report...", @@""),
                                           nil, msg)) {
                          exit (EXIT_FAILURE);
                      }
                  });

    /* fall back to caller to do the abort() in the DIX */
#endif
}

static void
check_xinitrc(void)
{
    char *tem, buf[1024];
    NSString *msg;

    if ([X11App prefs_get_boolean:@@PREFS_DONE_XINIT_CHECK default:NO])
        return;

    tem = getenv("HOME");
    if (tem == NULL) goto done;

    snprintf(buf, sizeof(buf), "%s/.xinitrc", tem);
    if (access(buf, F_OK) != 0)
        goto done;

    msg =
        NSLocalizedString(
            @@"You have an existing ~/.xinitrc file.\n\n\
                             Windows displayed by X11 applications may not have titlebars, or may look \
                             different to windows displayed by native applications.\n\n\
                             Would you like to move aside the existing file and use the standard X11 \
                             environment the next time you start X11?"                                                                                                                                                                                                                                                                                                                                                                  ,
            @@"Startup xinitrc dialog");

    if (NSAlertDefaultReturn ==
        NSRunAlertPanel(nil, @@"%@@", NSLocalizedString(@@"Yes", @@""),
                        NSLocalizedString(@@"No", @@""), nil, msg)) {
        char buf2[1024];
        int i = -1;

        snprintf(buf2, sizeof(buf2), "%s.old", buf);

        for (i = 1; access(buf2, F_OK) == 0; i++)
            snprintf(buf2, sizeof(buf2), "%s.old.%d", buf, i);

        rename(buf, buf2);
    }

done:
    [X11App prefs_set_boolean:@@PREFS_DONE_XINIT_CHECK value:YES];
    [X11App prefs_synchronize];
}

static inline pthread_t
create_thread(void *(*func)(void *), void *arg)
{
    pthread_attr_t attr;
    pthread_t tid;

    pthread_attr_init(&attr);
    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    pthread_create(&tid, &attr, func, arg);
    pthread_attr_destroy(&attr);

    return tid;
}

static void *
xpbproxy_x_thread(void *args)
{
    xpbproxy_run();

    ErrorF("xpbproxy thread is terminating unexpectedly.\n");
    return NULL;
}

void
X11ApplicationMain(int argc, char **argv, char **envp)
{
    NSAutoreleasePool *pool;

#ifdef DEBUG
    while (access("/tmp/x11-block", F_OK) == 0) sleep(1);
#endif

    pool = [[NSAutoreleasePool alloc] init];
    X11App = (X11Application *)[X11Application sharedApplication];
    init_ports();

    app_prefs_domain_cfstr =
        (CFStringRef)[[NSBundle mainBundle] bundleIdentifier];

    if (app_prefs_domain_cfstr == NULL) {
        ErrorF(
            "X11ApplicationMain: Unable to determine bundle identifier.  Your installation of XQuartz may be broken.\n");
        app_prefs_domain_cfstr = CFSTR(BUNDLE_ID_PREFIX ".X11");
    }

    [NSApp read_defaults];
    [NSBundle loadNibNamed:@@"main" owner:NSApp];
    [[NSNotificationCenter defaultCenter] addObserver:NSApp
                                             selector:@@selector (became_key:)
                                                 name:
     NSWindowDidBecomeKeyNotification object:nil];

    /*
     * The xpr Quartz mode is statically linked into this server.
     * Initialize all the Quartz functions.
     */
    QuartzModeBundleInit();

    /* Calculate the height of the menubar so we can avoid it. */
    aquaMenuBarHeight = [[NSApp mainMenu] menuBarHeight];
#if ! __LP64__
    if (!aquaMenuBarHeight) {
        aquaMenuBarHeight = [NSMenuView menuBarHeight];
    }
#endif
    if (!aquaMenuBarHeight) {
        NSScreen* primaryScreen = [[NSScreen screens] objectAtIndex:0];
        aquaMenuBarHeight = NSHeight([primaryScreen frame]) - NSMaxY([primaryScreen visibleFrame]);
    }

#ifdef HAVE_LIBDISPATCH
    eventTranslationQueue = dispatch_queue_create(
        BUNDLE_ID_PREFIX ".X11.NSEventsToX11EventsQueue", NULL);
    assert(eventTranslationQueue != NULL);
#endif

    /* Set the key layout seed before we start the server */
#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
    last_key_layout = TISCopyCurrentKeyboardLayoutInputSource();

    if (!last_key_layout)
        ErrorF(
            "X11ApplicationMain: Unable to determine TISCopyCurrentKeyboardLayoutInputSource() at startup.\n");
#else
    KLGetCurrentKeyboardLayout(&last_key_layout);
    if (!last_key_layout)
        ErrorF(
            "X11ApplicationMain: Unable to determine KLGetCurrentKeyboardLayout() at startup.\n");
#endif

    if (!QuartsResyncKeymap(FALSE)) {
        ErrorF("X11ApplicationMain: Could not build a valid keymap.\n");
    }

    /* Tell the server thread that it can proceed */
    QuartzInitServer(argc, argv, envp);

    /* This must be done after QuartzInitServer because it can result in
     * an mieqEnqueue() - <rdar://problem/6300249>
     */
    check_xinitrc();

    create_thread(xpbproxy_x_thread, NULL);

#if XQUARTZ_SPARKLE
    [[X11App controller] setup_sparkle];
    [[SUUpdater sharedUpdater] resetUpdateCycle];
    //    [[SUUpdater sharedUpdater] checkForUpdates:X11App];
#endif

    [pool release];
    [NSApp run];
    /* not reached */
}

@@implementation X11Application (Private)

#ifdef NX_DEVICELCMDKEYMASK
/* This is to workaround a bug in the VNC server where we sometimes see the L
 * modifier and sometimes see no "side"
 */
static inline int
ensure_flag(int flags, int device_independent, int device_dependents,
            int device_dependent_default)
{
    if ((flags & device_independent) &&
        !(flags & device_dependents))
        flags |= device_dependent_default;
    return flags;
}
#endif

#ifdef DEBUG_UNTRUSTED_POINTER_DELTA
static const char *
untrusted_str(NSEvent *e)
{
    switch ([e type]) {
    case NSScrollWheel:
        return "NSScrollWheel";

    case NSTabletPoint:
        return "NSTabletPoint";

    case NSOtherMouseDown:
        return "NSOtherMouseDown";

    case NSOtherMouseUp:
        return "NSOtherMouseUp";

    case NSLeftMouseDown:
        return "NSLeftMouseDown";

    case NSLeftMouseUp:
        return "NSLeftMouseUp";

    default:
        switch ([e subtype]) {
        case NSTabletPointEventSubtype:
            return "NSTabletPointEventSubtype";

        case NSTabletProximityEventSubtype:
            return "NSTabletProximityEventSubtype";

        default:
            return "Other";
        }
    }
}
#endif

extern void
darwinEvents_lock(void);
extern void
darwinEvents_unlock(void);

- (void) sendX11NSEvent:(NSEvent *)e
{
    NSPoint location = NSZeroPoint;
    int ev_button, ev_type;
    static float pressure = 0.0;       // static so ProximityOut will have the value from the previous tablet event
    static NSPoint tilt;               // static so ProximityOut will have the value from the previous tablet event
    static DeviceIntPtr darwinTabletCurrent = NULL;
    static BOOL needsProximityIn = NO; // Do we do need to handle a pending ProximityIn once we have pressure/tilt?
    DeviceIntPtr pDev;
    int modifierFlags;
    BOOL isMouseOrTabletEvent, isTabletEvent;

    if (!darwinTabletCurrent) {
        /* Ensure that the event system is initialized */
        darwinEvents_lock();
        darwinEvents_unlock();
        assert(darwinTabletStylus);

        tilt = NSZeroPoint;
        darwinTabletCurrent = darwinTabletStylus;
    }

    isMouseOrTabletEvent = [e type] == NSLeftMouseDown ||
                           [e type] == NSOtherMouseDown ||
                           [e type] == NSRightMouseDown ||
                           [e type] == NSLeftMouseUp ||
                           [e type] == NSOtherMouseUp ||
                           [e type] == NSRightMouseUp ||
                           [e type] == NSLeftMouseDragged ||
                           [e type] == NSOtherMouseDragged ||
                           [e type] == NSRightMouseDragged ||
                           [e type] == NSMouseMoved ||
                           [e type] == NSTabletPoint || 
                           [e type] == NSScrollWheel;

    isTabletEvent = ([e type] == NSTabletPoint) ||
                    (isMouseOrTabletEvent &&
                     ([e subtype] == NSTabletPointEventSubtype ||
                      [e subtype] == NSTabletProximityEventSubtype));

    if (isMouseOrTabletEvent) {
        static NSPoint lastpt;
        NSWindow *window = [e window];
        NSRect screen = [[[NSScreen screens] objectAtIndex:0] frame];
        BOOL hasUntrustedPointerDelta;

        // NSEvents for tablets are not consistent wrt deltaXY between events, so we cannot rely on that
        // Thus tablets will be subject to the warp-pointer bug worked around by the delta, but tablets
        // are not normally used in cases where that bug would present itself, so this is a fair tradeoff
        // <rdar://problem/7111003> deltaX and deltaY are incorrect for NSMouseMoved, NSTabletPointEventSubtype
        // http://xquartz.macosforge.org/trac/ticket/288
        hasUntrustedPointerDelta = isTabletEvent;

        // The deltaXY for middle click events also appear erroneous after fast user switching
        // <rdar://problem/7979468> deltaX and deltaY are incorrect for NSOtherMouseDown and NSOtherMouseUp after FUS
        // http://xquartz.macosforge.org/trac/ticket/389
        hasUntrustedPointerDelta |= [e type] == NSOtherMouseDown ||
                                    [e type] == NSOtherMouseUp;

        // The deltaXY for scroll events correspond to the scroll delta, not the pointer delta
        // <rdar://problem/7989690> deltaXY for wheel events are being sent as mouse movement
        hasUntrustedPointerDelta |= [e type] == NSScrollWheel;

#ifdef DEBUG_UNTRUSTED_POINTER_DELTA
        hasUntrustedPointerDelta |= [e type] == NSLeftMouseDown ||
                                    [e type] == NSLeftMouseUp;
#endif

        if (window != nil) {
            NSRect frame = [window frame];
            location = [e locationInWindow];
            location.x += frame.origin.x;
            location.y += frame.origin.y;
            lastpt = location;
        }
        else if (hasUntrustedPointerDelta) {
#ifdef DEBUG_UNTRUSTED_POINTER_DELTA
            ErrorF("--- Begin Event Debug ---\n");
            ErrorF("Event type: %s\n", untrusted_str(e));
            ErrorF("old lastpt: (%0.2f, %0.2f)\n", lastpt.x, lastpt.y);
            ErrorF("     delta: (%0.2f, %0.2f)\n", [e deltaX], -[e deltaY]);
            ErrorF("  location: (%0.2f, %0.2f)\n", lastpt.x + [e deltaX],
                   lastpt.y - [e deltaY]);
            ErrorF("workaround: (%0.2f, %0.2f)\n", [e locationInWindow].x,
                   [e locationInWindow].y);
            ErrorF("--- End Event Debug ---\n");

            location.x = lastpt.x + [e deltaX];
            location.y = lastpt.y - [e deltaY];
            lastpt = [e locationInWindow];
#else
            location = [e locationInWindow];
            lastpt = location;
#endif
        }
        else {
            location.x = lastpt.x + [e deltaX];
            location.y = lastpt.y - [e deltaY];
            lastpt = [e locationInWindow];
        }

        /* Convert coordinate system */
        location.y = (screen.origin.y + screen.size.height) - location.y;
    }

    modifierFlags = [e modifierFlags];

#ifdef NX_DEVICELCMDKEYMASK
    /* This is to workaround a bug in the VNC server where we sometimes see the L
     * modifier and sometimes see no "side"
     */
    modifierFlags = ensure_flag(modifierFlags, NX_CONTROLMASK,
                                NX_DEVICELCTLKEYMASK | NX_DEVICERCTLKEYMASK,
                                NX_DEVICELCTLKEYMASK);
    modifierFlags = ensure_flag(modifierFlags, NX_SHIFTMASK,
                                NX_DEVICELSHIFTKEYMASK | NX_DEVICERSHIFTKEYMASK, 
                                NX_DEVICELSHIFTKEYMASK);
    modifierFlags = ensure_flag(modifierFlags, NX_COMMANDMASK,
                                NX_DEVICELCMDKEYMASK | NX_DEVICERCMDKEYMASK,
                                NX_DEVICELCMDKEYMASK);
    modifierFlags = ensure_flag(modifierFlags, NX_ALTERNATEMASK,
                                NX_DEVICELALTKEYMASK | NX_DEVICERALTKEYMASK,
                                NX_DEVICELALTKEYMASK);
#endif

    modifierFlags &= darwin_all_modifier_mask;

    /* We don't receive modifier key events while out of focus, and 3button
     * emulation mucks this up, so we need to check our modifier flag state
     * on every event... ugg
     */

    if (darwin_all_modifier_flags != modifierFlags)
        DarwinUpdateModKeys(modifierFlags);

    switch ([e type]) {
    case NSLeftMouseDown:
        ev_button = 1;
        ev_type = ButtonPress;
        goto handle_mouse;

    case NSOtherMouseDown:
        ev_button = 2;
        ev_type = ButtonPress;
        goto handle_mouse;

    case NSRightMouseDown:
        ev_button = 3;
        ev_type = ButtonPress;
        goto handle_mouse;

    case NSLeftMouseUp:
        ev_button = 1;
        ev_type = ButtonRelease;
        goto handle_mouse;

    case NSOtherMouseUp:
        ev_button = 2;
        ev_type = ButtonRelease;
        goto handle_mouse;

    case NSRightMouseUp:
        ev_button = 3;
        ev_type = ButtonRelease;
        goto handle_mouse;

    case NSLeftMouseDragged:
        ev_button = 1;
        ev_type = MotionNotify;
        goto handle_mouse;

    case NSOtherMouseDragged:
        ev_button = 2;
        ev_type = MotionNotify;
        goto handle_mouse;

    case NSRightMouseDragged:
        ev_button = 3;
        ev_type = MotionNotify;
        goto handle_mouse;

    case NSMouseMoved:
        ev_button = 0;
        ev_type = MotionNotify;
        goto handle_mouse;

    case NSTabletPoint:
        ev_button = 0;
        ev_type = MotionNotify;
        goto handle_mouse;

handle_mouse:
        pDev = darwinPointer;

        /* NSTabletPoint can have no subtype */
        if ([e type] != NSTabletPoint &&
            [e subtype] == NSTabletProximityEventSubtype) {
            switch ([e pointingDeviceType]) {
            case NSEraserPointingDevice:
                darwinTabletCurrent = darwinTabletEraser;
                break;

            case NSPenPointingDevice:
                darwinTabletCurrent = darwinTabletStylus;
                break;

            case NSCursorPointingDevice:
            case NSUnknownPointingDevice:
            default:
                darwinTabletCurrent = darwinTabletCursor;
                break;
            }

            if ([e isEnteringProximity])
                needsProximityIn = YES;
            else
                DarwinSendTabletEvents(darwinTabletCurrent, ProximityOut, 0,
                                       location.x, location.y, pressure,
                                       tilt.x, tilt.y);
            return;
        }

        if ([e type] == NSTabletPoint ||
            [e subtype] == NSTabletPointEventSubtype) {
            pressure = [e pressure];
            tilt = [e tilt];

            pDev = darwinTabletCurrent;

            if (needsProximityIn) {
                DarwinSendTabletEvents(darwinTabletCurrent, ProximityIn, 0,
                                       location.x, location.y, pressure,
                                       tilt.x, tilt.y);

                needsProximityIn = NO;
            }
        }

        if (!XQuartzServerVisible && noTestExtensions) {
#if defined(XPLUGIN_VERSION) && XPLUGIN_VERSION > 0
            /* Older libXplugin (Tiger/"Stock" Leopard) aren't thread safe, so we can't call xp_find_window from the Appkit thread */
            xp_window_id wid = 0;
            xp_error err;

            /* Sigh. Need to check that we're really over one of
             * our windows. (We need to receive pointer events while
             * not in the foreground, but we don't want to receive them
             * when another window is over us or we might show a tooltip)
             */

            err = xp_find_window(location.x, location.y, 0, &wid);

            if (err != XP_Success || (err == XP_Success && wid == 0))
#endif
            {
                bgMouseLocation = location;
                bgMouseLocationUpdated = TRUE;
                return;
            }
        }

        if (bgMouseLocationUpdated) {
            if (!(ev_type == MotionNotify && ev_button == 0)) {
                DarwinSendPointerEvents(darwinPointer, MotionNotify, 0,
                                        location.x, location.y,
                                        0.0, 0.0);
            }
            bgMouseLocationUpdated = FALSE;
        }

        if (pDev == darwinPointer) {
            DarwinSendPointerEvents(pDev, ev_type, ev_button,
                                    location.x, location.y,
                                    [e deltaX], [e deltaY]);
        } else {
            DarwinSendTabletEvents(pDev, ev_type, ev_button,
                                   location.x, location.y, pressure,
                                   tilt.x, tilt.y);
        }

        break;

    case NSTabletProximity:
        switch ([e pointingDeviceType]) {
        case NSEraserPointingDevice:
            darwinTabletCurrent = darwinTabletEraser;
            break;

        case NSPenPointingDevice:
            darwinTabletCurrent = darwinTabletStylus;
            break;

        case NSCursorPointingDevice:
        case NSUnknownPointingDevice:
        default:
            darwinTabletCurrent = darwinTabletCursor;
            break;
        }

        if ([e isEnteringProximity])
            needsProximityIn = YES;
        else
            DarwinSendTabletEvents(darwinTabletCurrent, ProximityOut, 0,
                                   location.x, location.y, pressure,
                                   tilt.x, tilt.y);
        break;

    case NSScrollWheel:
    {
#if MAC_OS_X_VERSION_MAX_ALLOWED < 1050
        float deltaX = [e deltaX];
        float deltaY = [e deltaY];
        BOOL isContinuous = NO;
#else
        CGFloat deltaX = [e deltaX];
        CGFloat deltaY = [e deltaY];
        CGEventRef cge = [e CGEvent];
        BOOL isContinuous =
            CGEventGetIntegerValueField(cge, kCGScrollWheelEventIsContinuous);

#if 0
        /* Scale the scroll value by line height */
        CGEventSourceRef source = CGEventCreateSourceFromEvent(cge);
        if (source) {
            double lineHeight = CGEventSourceGetPixelsPerLine(source);
            CFRelease(source);
            
            /* There's no real reason for the 1/5 ratio here other than that
             * it feels like a good ratio after some testing.
             */
            
            deltaX *= lineHeight / 5.0;
            deltaY *= lineHeight / 5.0;
        }
#endif
#endif
        
#if !defined(XPLUGIN_VERSION) || XPLUGIN_VERSION == 0
        /* If we're in the background, we need to send a MotionNotify event
         * first, since we aren't getting them on background mouse motion
         */
        if (!XQuartzServerVisible && noTestExtensions) {
            bgMouseLocationUpdated = FALSE;
            DarwinSendPointerEvents(darwinPointer, MotionNotify, 0,
                                    location.x, location.y,
                                    0.0, 0.0);
        }
#endif
#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1070
        // TODO: Change 1117 to NSAppKitVersionNumber10_7 when it is defined
        if (NSAppKitVersionNumber >= 1117 &&
            XQuartzScrollInDeviceDirection &&
            [e isDirectionInvertedFromDevice]) {
            deltaX *= -1;
            deltaY *= -1;
        }
#endif
        /* This hack is in place to better deal with "clicky" scroll wheels:
         * http://xquartz.macosforge.org/trac/ticket/562
         */
        if (!isContinuous) {
            static NSTimeInterval lastScrollTime = 0.0;

            /* These store how much extra we have already scrolled.
             * ie, this is how much we ignore on the next event.
             */
            static double deficit_x = 0.0;
            static double deficit_y = 0.0;

            /* If we have past a second since the last scroll, wipe the slate
             * clean
             */
            if ([e timestamp] - lastScrollTime > 1.0) {
                deficit_x = deficit_y = 0.0;
            }
            lastScrollTime = [e timestamp];

            if (deltaX != 0.0) {
                /* If we changed directions, wipe the slate clean */
                if ((deficit_x < 0.0 && deltaX > 0.0) ||
                    (deficit_x > 0.0 && deltaX < 0.0)) {
                    deficit_x = 0.0;
                }

                /* Eat up the deficit, but ensure that something is
                 * always sent 
                 */
                if (fabs(deltaX) > fabs(deficit_x)) {
                    deltaX -= deficit_x;

                    if (deltaX > 0.0) {
                        deficit_x = ceil(deltaX) - deltaX;
                        deltaX = ceil(deltaX);
                    } else {
                        deficit_x = floor(deltaX) - deltaX;
                        deltaX = floor(deltaX);
                    }
                } else {
                    deficit_x -= deltaX;

                    if (deltaX > 0.0) {
                        deltaX = 1.0;
                    } else {
                        deltaX = -1.0;
                    }

                    deficit_x += deltaX;
                }
            }

            if (deltaY != 0.0) {
                /* If we changed directions, wipe the slate clean */
                if ((deficit_y < 0.0 && deltaY > 0.0) ||
                    (deficit_y > 0.0 && deltaY < 0.0)) {
                    deficit_y = 0.0;
                }

                /* Eat up the deficit, but ensure that something is
                 * always sent 
                 */
                if (fabs(deltaY) > fabs(deficit_y)) {
                    deltaY -= deficit_y;

                    if (deltaY > 0.0) {
                        deficit_y = ceil(deltaY) - deltaY;
                        deltaY = ceil(deltaY);
                    } else {
                        deficit_y = floor(deltaY) - deltaY;
                        deltaY = floor(deltaY);
                    }
                } else {
                    deficit_y -= deltaY;

                    if (deltaY > 0.0) {
                        deltaY = 1.0;
                    } else {
                        deltaY = -1.0;
                    }

                    deficit_y += deltaY;
                }
            }
        }

        DarwinSendScrollEvents(deltaX, deltaY);
        break;
    }

    case NSKeyDown:
    case NSKeyUp:
    {
        /* XKB clobbers our keymap at startup, so we need to force it on the first keypress.
         * TODO: Make this less of a kludge.
         */
        static int force_resync_keymap = YES;
        if (force_resync_keymap) {
            DarwinSendDDXEvent(kXquartzReloadKeymap, 0);
            force_resync_keymap = NO;
        }
    }

        if (darwinSyncKeymap) {
#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
            TISInputSourceRef key_layout = 
                TISCopyCurrentKeyboardLayoutInputSource();
            TISInputSourceRef clear;
            if (CFEqual(key_layout, last_key_layout)) {
                CFRelease(key_layout);
            }
            else {
                /* Swap/free thread-safely */
                clear = last_key_layout;
                last_key_layout = key_layout;
                CFRelease(clear);
#else
            KeyboardLayoutRef key_layout;
            KLGetCurrentKeyboardLayout(&key_layout);
            if (key_layout != last_key_layout) {
                last_key_layout = key_layout;
#endif
                /* Update keyInfo */
                if (!QuartsResyncKeymap(TRUE)) {
                    ErrorF(
                        "sendX11NSEvent: Could not build a valid keymap.\n");
                }
            }
        }

        ev_type = ([e type] == NSKeyDown) ? KeyPress : KeyRelease;
        DarwinSendKeyboardEvents(ev_type, [e keyCode]);
        break;

    default:
        break;              /* for gcc */
    }
}
@@end
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d1072 1
a1072 1
    switch (NSRunAlertPanel(title, msg,
d1077 1
a1077 1
                            NSLocalizedString(@@"Always Allow", @@""))) {
d1125 1
a1125 1
                          NSRunAlertPanel (title, msg,
d1127 2
a1128 2
                                           NSLocalizedString (
                                               @@"Report...", @@""), nil)) {
d1163 2
a1164 3
        NSRunAlertPanel(nil, msg, NSLocalizedString(@@"Yes", @@""),
                        NSLocalizedString(@@"No",
                                          @@""), nil)) {
d1241 10
a1250 2
    aquaMenuBarHeight = NSHeight([[NSScreen mainScreen] frame]) -
                        NSMaxY([[NSScreen mainScreen] visibleFrame]);
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d73 12
d541 1
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d75 1
d1075 47
@


1.6
log
@Update to xserver 1.11.2
@
text
@d2 28
a29 27
 
 Copyright (c) 2002-2008 Apple Inc.
 
 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation files
 (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge,
 publish, distribute, sublicense, and/or sell copies of the Software,
 and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:
 
 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT
 HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 DEALINGS IN THE SOFTWARE.
 
 Except as contained in this notice, the name(s) of the above
 copyright holders shall not be used in advertising or otherwise to
 promote the sale, use or other dealings in this Software without
 prior written authorization. */
d58 2
a59 1
extern int xpbproxy_run (void);
d61 1
a61 1
#define DEFAULTS_FILE X11LIBDIR"/X11/xserver/Xquartz.plist"
a72 3
/* Stuck modifier / button state... force release when we context switch */
static NSEventType keyState[NUM_KEYCODES];

d74 1
d99 2
a100 1
#define ALL_KEY_MASKS (NSShiftKeyMask | NSControlKeyMask | NSAlternateKeyMask | NSCommandKeyMask)
d119 2
a120 1
Bool QuartzModeBundleInit(void);
d122 3
a124 1
static void init_ports (void) {
d127 1
a127 1
	
d129 2
a130 2
	
    r = mach_port_allocate (mach_task_self (), MACH_PORT_RIGHT_RECEIVE, &_port);
d132 1
a132 1
	
d135 2
a136 1
    [p scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
d139 3
a141 1
static void message_kit_thread (SEL selector, NSObject *arg) {
d144 3
a146 3
	
    msg.hdr.msgh_bits = MACH_MSGH_BITS (MACH_MSG_TYPE_MAKE_SEND, 0);
    msg.hdr.msgh_size = sizeof (msg);
d151 1
a151 1
	
d154 3
a156 3
	
    r = mach_msg (&msg.hdr, MACH_SEND_MSG, msg.hdr.msgh_size,
		  0, MACH_PORT_NULL, 0, MACH_PORT_NULL);
d158 1
a158 1
		ErrorF("%s: mach_msg failed: %x\n", __FUNCTION__, r);
d161 2
a162 1
- (void) handleMachMessage:(void *)_msg {
d164 1
a164 1
	
d169 2
a170 1
- (void) set_controller:obj {
d174 2
a175 1
- (void) dealloc {
d177 1
a177 1
	
d179 2
a180 2
		mach_port_deallocate (mach_task_self (), _port);
	
d184 2
a185 1
- (void) orderFrontStandardAboutPanel: (id) sender {
d189 1
a189 1
    
d192 4
a195 4
    
    [dict setObject: NSLocalizedString (@@"The X Window System", @@"About panel")
          forKey:@@"ApplicationName"];
    
d197 1
a197 1
    
d199 5
a203 1
          forKey:@@"ApplicationVersion"];
a204 3
    [dict setObject:[NSString stringWithFormat:@@"xorg-server %s", XSERVER_VERSION]
          forKey:@@"Version"];
    
d208 5
a212 2
- (void) activateX:(OSX_BOOL)state {
    size_t i;
d215 4
a218 2
        if(bgMouseLocationUpdated) {
            DarwinSendPointerEvents(darwinPointer, MotionNotify, 0, bgMouseLocation.x, bgMouseLocation.y, 0.0, 0.0, 0.0);
d222 2
a223 1
    } else {
d225 1
a225 1
        if(darwin_all_modifier_flags)
d227 7
a233 7
        for(i=0; i < NUM_KEYCODES; i++) {
            if(keyState[i] == NSKeyDown) {
                DarwinSendKeyboardEvents(KeyRelease, i);
                keyState[i] = NSKeyUp;
            }
        }
        
d240 3
a242 2
- (void) became_key:(NSWindow *)win {
	[self activateX:NO];
d245 2
a246 1
- (void) sendEvent:(NSEvent *)e {
d248 1
a248 1
    
d252 1
a252 1
    
d254 110
a363 14
        case NSLeftMouseDown: case NSRightMouseDown: case NSOtherMouseDown:
        case NSLeftMouseUp: case NSRightMouseUp: case NSOtherMouseUp:
            if ([e window] != nil) {
                /* Pointer event has an (AppKit) window. Probably something for the kit. */
                for_x = NO;
                if (_x_active) [self activateX:NO];
            } else if ([self modalWindow] == nil) {
                /* Must be an X window. Tell appkit it doesn't have focus. */
                for_appkit = NO;
                
                if ([self isActive]) {
                    [self deactivate];
                    if (!_x_active && quartzProcs->IsX11Window([e windowNumber]))
                        [self activateX:YES];
d366 21
d388 28
a415 12
            /* We want to force sending to appkit if we're over the menu bar */
            if(!for_appkit) {
                NSPoint NSlocation = [e locationInWindow];
                NSWindow *window = [e window];
                NSRect NSframe, NSvisibleFrame;
                CGRect CGframe, CGvisibleFrame;
                CGPoint CGlocation;

                if (window != nil)	{
                    NSRect frame = [window frame];
                    NSlocation.x += frame.origin.x;
                    NSlocation.y += frame.origin.y;
d418 10
a427 67
                NSframe = [[NSScreen mainScreen] frame];
                NSvisibleFrame = [[NSScreen mainScreen] visibleFrame];
                
                CGframe = CGRectMake(NSframe.origin.x, NSframe.origin.y,
                                            NSframe.size.width, NSframe.size.height);
                CGvisibleFrame = CGRectMake(NSvisibleFrame.origin.x,
                                                   NSvisibleFrame.origin.y,
                                                   NSvisibleFrame.size.width,
                                                   NSvisibleFrame.size.height);
                CGlocation = CGPointMake(NSlocation.x, NSlocation.y);
                
                if(CGRectContainsPoint(CGframe, CGlocation) &&
                   !CGRectContainsPoint(CGvisibleFrame, CGlocation))
                    for_appkit = YES;
            }
            
            break;
            
        case NSKeyDown: case NSKeyUp:
            
            if(_x_active) {
                static BOOL do_swallow = NO;
                static int swallow_keycode;
                
                if([e type] == NSKeyDown) {
                    /* Before that though, see if there are any global
                     * shortcuts bound to it. */

                    if(darwinAppKitModMask & [e modifierFlags]) {
                        /* Override to force sending to Appkit */
                        swallow_keycode = [e keyCode];
                        do_swallow = YES;
                        for_x = NO;
#if XPLUGIN_VERSION >= 1
                    } else if(XQuartzEnableKeyEquivalents &&
                             xp_is_symbolic_hotkey_event([e eventRef])) {
                        swallow_keycode = [e keyCode];
                        do_swallow = YES;
                        for_x = NO;
#endif
                    } else if(XQuartzEnableKeyEquivalents &&
                              [[self mainMenu] performKeyEquivalent:e]) {
                        swallow_keycode = [e keyCode];
                        do_swallow = YES;
                        for_appkit = NO;
                        for_x = NO;
                    } else if(!XQuartzIsRootless
                              && ([e modifierFlags] & ALL_KEY_MASKS) == (NSCommandKeyMask | NSAlternateKeyMask)
                              && ([e keyCode] == 0 /*a*/ || [e keyCode] == 53 /*Esc*/)) {
                        /* We have this here to force processing fullscreen 
                         * toggle even if XQuartzEnableKeyEquivalents is disabled */
                        swallow_keycode = [e keyCode];
                        do_swallow = YES;
                        for_x = NO;
                        for_appkit = NO;
                        DarwinSendDDXEvent(kXquartzToggleFullscreen, 0);
                    } else {
                        /* No kit window is focused, so send it to X. */
                        for_appkit = NO;
                    }
                } else { /* KeyUp */
                    /* If we saw a key equivalent on the down, don't pass
                     * the up through to X. */
                    if (do_swallow && [e keyCode] == swallow_keycode) {
                        do_swallow = NO;
                        for_x = NO;
                    }
a428 2
            } else { /* !_x_active */
                for_x = NO;
d431 3
a433 5
            
        case NSFlagsChanged:
            /* Don't tell X11 about modifiers changing while it's not active */
            if (!_x_active)
                for_x = NO;
a434 4
            
        case NSAppKitDefined:
            switch ([e subtype]) {
                static BOOL x_was_active = NO;
d436 2
a437 45
                case NSApplicationActivatedEventType:
                    for_x = NO;
                    if ([e window] == nil && x_was_active) {
                        BOOL order_all_windows = YES, workspaces, ok;
                        for_appkit = NO;

                        /* FIXME: This is a hack to avoid passing the event to AppKit which
                         *        would result in it raising one of its windows.
                         */
                        _appFlags._active = YES;

                        [self set_front_process:nil];

                        /* Get the Spaces preference for SwitchOnActivate */
                        (void)CFPreferencesAppSynchronize(CFSTR("com.apple.dock"));
                        workspaces = CFPreferencesGetAppBooleanValue(CFSTR("workspaces"), CFSTR("com.apple.dock"), &ok);
                        if (!ok)
                            workspaces = NO;

                        if (workspaces) {
                            (void)CFPreferencesAppSynchronize(CFSTR(".GlobalPreferences"));
                            order_all_windows = CFPreferencesGetAppBooleanValue(CFSTR("AppleSpacesSwitchOnActivate"), CFSTR(".GlobalPreferences"), &ok);
                            if (!ok)
                                order_all_windows = YES;
                        }
                        
                        /* TODO: In the workspaces && !AppleSpacesSwitchOnActivate case, the windows are ordered
                         *       correctly, but we need to activate the top window on this space if there is
                         *       none active.
                         *
                         *       If there are no active windows, and there are minimized windows, we should
                         *       be restoring one of them.
                         */
                        if ([e data2] & 0x10) { // 0x10 (bfCPSOrderAllWindowsForward) is set when we use cmd-tab or the dock icon
                            DarwinSendDDXEvent(kXquartzBringAllToFront, 1, order_all_windows);
                        }
                    }
                    break;
                    
                case 18: /* ApplicationDidReactivate */
                    if (XQuartzFullscreenVisible) for_appkit = NO;
                    break;
                    
                case NSApplicationDeactivatedEventType:
                    for_x = NO;
d439 3
a441 5
                    x_was_active = _x_active;
                    if(_x_active)
                        [self activateX:NO];
                    break;
            }
d443 5
a447 2
            
        default: break; /* for gcc */
d449 1
a449 1
    
d451 1
a451 1
    
d455 4
a458 4
#endif
            [self sendX11NSEvent:e];
#ifdef HAVE_LIBDISPATCH
        });
d463 3
a465 2
- (void) set_window_menu:(NSArray *)list {
	[_controller set_window_menu:list];
d468 3
a470 2
- (void) set_window_menu_check:(NSNumber *)n {
	[_controller set_window_menu_check:n];
d473 3
a475 2
- (void) set_apps_menu:(NSArray *)list {
	[_controller set_apps_menu:list];
d478 3
a480 2
- (void) set_front_process:unused {
	[NSApp activateIgnoringOtherApps:YES];
d482 2
a483 2
	if ([self modalWindow] == nil)
		[self activateX:YES];
d486 3
a488 2
- (void) set_can_quit:(NSNumber *)state {
	[_controller set_can_quit:[state boolValue]];
d491 3
a493 2
- (void) server_ready:unused {
	[_controller server_ready];
d496 2
a497 1
- (void) show_hide_menubar:(NSNumber *)state {
d500 1
a500 1
        SetSystemUIMode(kUIModeNormal, 0); 
d502 2
a503 1
        SetSystemUIMode(kUIModeAllHidden, XQuartzFullscreenMenu ? kUIOptionAutoShowMenuBar : 0); // kUIModeAllSuppressed or kUIOptionAutoShowMenuBar can be used to allow "mouse-activation"
d506 2
a507 1
- (void) launch_client:(NSString *)cmd {
d514 1
a514 1
 can be toll-free-bridged between NS and CF worlds. */
d516 4
a519 2
static const void *cfretain (CFAllocatorRef a, const void *b) {
    return CFRetain (b);
d522 4
a525 2
static void cfrelease (CFAllocatorRef a, const void *b) {
    CFRelease (b);
d528 24
a551 6
static CFMutableArrayRef nsarray_to_cfarray (NSArray *in) {
	CFMutableArrayRef out;
	CFArrayCallBacks cb;
	NSObject *ns;
	const CFTypeRef *cf;
	int i, count;
d553 3
a555 4
	memset (&cb, 0, sizeof (cb));
	cb.version = 0;
	cb.retain = cfretain;
	cb.release = cfrelease;
d557 2
a558 2
	count = [in count];
	out = CFArrayCreateMutable (NULL, count, &cb);
d560 22
a581 2
	for (i = 0; i < count; i++) {
		ns = [in objectAtIndex:i];
d583 2
a584 4
		if ([ns isKindOfClass:[NSArray class]])
			cf = (CFTypeRef) nsarray_to_cfarray ((NSArray *) ns);
		else
			cf = CFRetain ((CFTypeRef) ns);
d586 3
a588 3
		CFArrayAppendValue (out, cf);
		CFRelease (cf);
	}
d590 60
a649 1
	return out;
d652 4
a655 5
static NSMutableArray * cfarray_to_nsarray (CFArrayRef in) {
	NSMutableArray *out;
	const CFTypeRef *cf;
	NSObject *ns;
	int i, count;
d657 1
a657 2
	count = CFArrayGetCount (in);
	out = [[NSMutableArray alloc] initWithCapacity:count];
d659 6
a664 2
	for (i = 0; i < count; i++) {
		cf = CFArrayGetValueAtIndex (in, i);
d666 1
a666 4
		if (CFGetTypeID (cf) == CFArrayGetTypeID ())
			ns = cfarray_to_nsarray ((CFArrayRef) cf);
		else
			ns = [(id)cf retain];
d668 1
a668 5
		[out addObject:ns];
		[ns release];
	}

	return out;
d671 2
a672 1
- (CFPropertyListRef) prefs_get_copy:(NSString *)key {
d674 8
a681 50
	
    value = CFPreferencesCopyAppValue ((CFStringRef) key, app_prefs_domain_cfstr);
	
    if (value == NULL) {
      static CFDictionaryRef defaults;
      
      if (defaults == NULL) {
	CFStringRef error = NULL;
	CFDataRef data;
	CFURLRef url;
	SInt32 error_code;
	
	url = (CFURLCreateFromFileSystemRepresentation
	       (NULL, (unsigned char *)DEFAULTS_FILE, strlen (DEFAULTS_FILE), false));
	if (CFURLCreateDataAndPropertiesFromResource (NULL, url, &data,
						      NULL, NULL, &error_code)) {
	  defaults = (CFPropertyListCreateFromXMLData
		      (NULL, data, kCFPropertyListMutableContainersAndLeaves, &error));
	  if (error != NULL) CFRelease (error);
	  CFRelease (data);
	}
	CFRelease (url);
			
	if (defaults != NULL) {
	  NSMutableArray *apps, *elt;
	  int count, i;
	  NSString *name, *nname;
	  
	  /* Localize the names in the default apps menu. */
	  
	  apps = [(NSDictionary *)defaults objectForKey:@@PREFS_APPSMENU];
	  if (apps != nil) {
	    count = [apps count];
	    for (i = 0; i < count; i++)	{
	      elt = [apps objectAtIndex:i];
	      if (elt != nil && [elt isKindOfClass:[NSArray class]]) {
		name = [elt objectAtIndex:0];
		if (name != nil) {
		  nname = NSLocalizedString (name, nil);
		  if (nname != nil && nname != name)
		    [elt replaceObjectAtIndex:0 withObject:nname];
		}
	      }
	    }
	  }
	}
      }
		
      if (defaults != NULL) value = CFDictionaryGetValue (defaults, key);
      if (value != NULL) CFRetain (value);
a682 3
	
    return value;
}
d684 3
a686 33
- (int) prefs_get_integer:(NSString *)key default:(int)def {
  CFPropertyListRef value;
  int ret;
  
  value = [self prefs_get_copy:key];
  
  if (value != NULL && CFGetTypeID (value) == CFNumberGetTypeID ())
    CFNumberGetValue (value, kCFNumberIntType, &ret);
  else if (value != NULL && CFGetTypeID (value) == CFStringGetTypeID ())
    ret = CFStringGetIntValue (value);
  else
    ret = def;
  
  if (value != NULL) CFRelease (value);
  
  return ret;
}

- (const char *) prefs_get_string:(NSString *)key default:(const char *)def {
  CFPropertyListRef value;
  const char *ret = NULL;
  
  value = [self prefs_get_copy:key];
  
  if (value != NULL && CFGetTypeID (value) == CFStringGetTypeID ()) {
    NSString *s = (NSString *) value;
    
    ret = [s UTF8String];
  }
  
  if (value != NULL) CFRelease (value);
  
  return ret != NULL ? ret : def;
d689 2
a690 1
- (NSURL *) prefs_copy_url:(NSString *)key default:(NSURL *)def {
d693 1
a693 1
    
d695 3
a697 3
    
    if (value != NULL && CFGetTypeID (value) == CFStringGetTypeID ()) {
        NSString *s = (NSString *) value;
d702 3
a704 3
    
    if (value != NULL) CFRelease (value);
    
d708 42
a749 56
- (float) prefs_get_float:(NSString *)key default:(float)def {
  CFPropertyListRef value;
  float ret = def;
  
  value = [self prefs_get_copy:key];
  
  if (value != NULL
      && CFGetTypeID (value) == CFNumberGetTypeID ()
      && CFNumberIsFloatType (value))
    CFNumberGetValue (value, kCFNumberFloatType, &ret);
  else if (value != NULL && CFGetTypeID (value) == CFStringGetTypeID ())
    ret = CFStringGetDoubleValue (value);
	
  if (value != NULL) CFRelease (value);
  
  return ret;
}

- (int) prefs_get_boolean:(NSString *)key default:(int)def {
  CFPropertyListRef value;
  int ret = def;
  
  value = [self prefs_get_copy:key];
  
  if (value != NULL) {
    if (CFGetTypeID (value) == CFNumberGetTypeID ())
      CFNumberGetValue (value, kCFNumberIntType, &ret);
    else if (CFGetTypeID (value) == CFBooleanGetTypeID ())
      ret = CFBooleanGetValue (value);
    else if (CFGetTypeID (value) == CFStringGetTypeID ()) {
      const char *tem = [(NSString *) value UTF8String];
      if (strcasecmp (tem, "true") == 0 || strcasecmp (tem, "yes") == 0)
	ret = YES;
      else
	ret = NO;
    }
    
    CFRelease (value);
  }
  return ret;
}

- (NSArray *) prefs_get_array:(NSString *)key {
  NSArray *ret = nil;
  CFPropertyListRef value;
  
  value = [self prefs_get_copy:key];
  
  if (value != NULL) {
    if (CFGetTypeID (value) == CFArrayGetTypeID ())
      ret = [cfarray_to_nsarray (value) autorelease];
    
    CFRelease (value);
  }
  
  return ret;
d752 19
a770 1
- (void) prefs_set_integer:(NSString *)key value:(int)value {
d772 9
a780 7
	
    x = CFNumberCreate (NULL, kCFNumberIntType, &value);
	
    CFPreferencesSetValue ((CFStringRef) key, (CFTypeRef) x, app_prefs_domain_cfstr,
			   kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
	
    CFRelease (x);
d783 2
a784 1
- (void) prefs_set_float:(NSString *)key value:(float)value {
d786 39
a824 32
	
    x = CFNumberCreate (NULL, kCFNumberFloatType, &value);
	
    CFPreferencesSetValue ((CFStringRef) key, (CFTypeRef) x, app_prefs_domain_cfstr,
			   kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
	
    CFRelease (x);
}

- (void) prefs_set_boolean:(NSString *)key value:(int)value {
  CFPreferencesSetValue ((CFStringRef) key,
			 (CFTypeRef) (value ? kCFBooleanTrue
			 : kCFBooleanFalse), app_prefs_domain_cfstr,
			 kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  
}

- (void) prefs_set_array:(NSString *)key value:(NSArray *)value {
  CFArrayRef cfarray;
  
  cfarray = nsarray_to_cfarray (value);
  CFPreferencesSetValue ((CFStringRef) key,
			 (CFTypeRef) cfarray,
			 app_prefs_domain_cfstr,
			 kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  CFRelease (cfarray);
}

- (void) prefs_set_string:(NSString *)key value:(NSString *)value {
  CFPreferencesSetValue ((CFStringRef) key, (CFTypeRef) value,
			 app_prefs_domain_cfstr, kCFPreferencesCurrentUser,
			 kCFPreferencesAnyHost);
d827 3
a829 2
- (void) prefs_synchronize {
    CFPreferencesAppSynchronize (kCFPreferencesCurrentApplication);
d836 1
a836 1
	
d838 1
a838 1
                                           default:XQuartzRootlessDefault];
d840 5
a844 3
                                           default:XQuartzFullscreenMenu];
    XQuartzFullscreenDisableHotkeys = ![self prefs_get_boolean:@@PREFS_FULLSCREEN_HOTKEYS
                                                      default:!XQuartzFullscreenDisableHotkeys];
d846 1
a846 1
                                        default:darwinFakeButtons];
d848 1
a848 1
                                           default:XQuartzOptionSendsAlt];
d856 4
a859 2
        if (fake2 != NULL) darwinFakeMouse2Mask = DarwinParseModifierList(fake2, TRUE);
        if (fake3 != NULL) darwinFakeMouse3Mask = DarwinParseModifierList(fake3, TRUE);
d864 1
a864 1
	
d868 5
a872 3
    } else {
        nsstr = NSLocalizedString (@@"window item modifiers", @@"window item modifiers");
        if(nsstr != NULL) {
d874 1
a874 1
            if((tem != NULL) && strcmp(tem, "window item modifiers")) {
d881 3
a883 2
                                              default:XQuartzEnableKeyEquivalents];
	
d885 2
a886 2
                                       default:darwinSyncKeymap];
		
d888 2
a889 2
                                         default:darwinDesiredDepth];
    
d891 9
a899 4
                                        default:FALSE];
    
    XQuartzScrollInDeviceDirection = [self prefs_get_boolean:@@PREFS_SCROLL_IN_DEV_DIRECTION
                                                     default:XQuartzScrollInDeviceDirection];
d902 2
a903 2
    NSURL *url =  [self prefs_copy_url:@@PREFS_UPDATE_FEED default:nil];
    if(url) {
d911 4
a914 3
- (void) copy:sender {
  DarwinSendDDXEvent(kXquartzPasteboardNotify, 1,
			     AppleWMCopyToPasteboard);
d917 2
a918 1
- (X11Controller *) controller {
d922 2
a923 1
- (OSX_BOOL) x_active {
d930 56
a985 50
array_with_strings_and_numbers (int nitems, const char **items,
				const char *numbers) {
  NSMutableArray *array, *subarray;
  NSString *string, *number;
  int i;
	
  /* (Can't autorelease on the X server thread) */
  
  array = [[NSMutableArray alloc] initWithCapacity:nitems];
  
  for (i = 0; i < nitems; i++) {
    subarray = [[NSMutableArray alloc] initWithCapacity:2];
    
    string = [[NSString alloc] initWithUTF8String:items[i]];
    [subarray addObject:string];
    [string release];
    
    if (numbers[i] != 0) {
      number = [[NSString alloc] initWithFormat:@@"%d", numbers[i]];
      [subarray addObject:number];
      [number release];
    } else
      [subarray addObject:@@""];
    
    [array addObject:subarray];
    [subarray release];
  }
  
  return array;
}

void X11ApplicationSetWindowMenu (int nitems, const char **items,
				  const char *shortcuts) {
  NSArray *array;
  array = array_with_strings_and_numbers (nitems, items, shortcuts);
  
  /* Send the array of strings over to the appkit thread */
  
  message_kit_thread (@@selector (set_window_menu:), array);
  [array release];
}

void X11ApplicationSetWindowMenuCheck (int idx) {
  NSNumber *n;
  
  n = [[NSNumber alloc] initWithInt:idx];
  
  message_kit_thread (@@selector (set_window_menu_check:), n);
  
  [n release];
d988 4
a991 2
void X11ApplicationSetFrontProcess (void) {
    message_kit_thread (@@selector (set_front_process:), nil);
d994 3
a996 1
void X11ApplicationSetCanQuit (int state) {
d998 1
a998 1
	
d1000 3
a1002 3
	
    message_kit_thread (@@selector (set_can_quit:), n);
	
d1006 4
a1009 2
void X11ApplicationServerReady (void) {
    message_kit_thread (@@selector (server_ready:), nil);
d1012 3
a1014 1
void X11ApplicationShowHideMenubar (int state) {
d1016 1
a1016 1
	
d1018 3
a1020 3
	
    message_kit_thread (@@selector (show_hide_menubar:), n);
	
d1024 3
a1026 1
void X11ApplicationLaunchClient (const char *cmd) {
d1028 1
a1028 1
    
d1030 3
a1032 3
	
    message_kit_thread (@@selector (launch_client:), string);
	
d1040 3
a1042 1
Bool X11ApplicationCanEnterRandR(void) {
d1044 3
a1046 2
    
    if([X11App prefs_get_boolean:@@PREFS_NO_RANDR_ALERT default:NO] || XQuartzShieldingWindowLevel != 0)
a1047 4
    
    title = NSLocalizedString(@@"Enter RandR mode?", @@"Dialog title when switching to RandR");
    msg = NSLocalizedString(@@"An application has requested X11 to change the resolution of your display.  X11 will restore the display to its previous state when the requesting application requests to return to the previous state.  Alternatively, you can use the ⌥⌘A key sequence to force X11 to return to the previous state.",
                            @@"Dialog when switching to RandR");
d1049 7
a1055 1
    if(!XQuartzIsRootless)
a1056 7
    
    switch(NSRunAlertPanel(title, msg, NSLocalizedString(@@"Allow", @@""), NSLocalizedString (@@"Cancel", @@""), NSLocalizedString (@@"Always Allow", @@""))) {
        case NSAlertOtherReturn:
            [X11App prefs_set_boolean:@@PREFS_NO_RANDR_ALERT value:YES];
            [X11App prefs_synchronize];
        case NSAlertDefaultReturn:
            return YES;
d1058 15
a1072 2
        default:
            return NO;
d1076 3
a1078 1
static void check_xinitrc (void) {
d1081 1
a1081 1
	
d1083 3
a1085 3
		return;
	
    tem = getenv ("HOME");
a1086 10
	
    snprintf (buf, sizeof (buf), "%s/.xinitrc", tem);
    if (access (buf, F_OK) != 0)
		goto done;
	
    msg = NSLocalizedString (@@"You have an existing ~/.xinitrc file.\n\n\
Windows displayed by X11 applications may not have titlebars, or may look \
different to windows displayed by native applications.\n\n\
Would you like to move aside the existing file and use the standard X11 \
environment the next time you start X11?", @@"Startup xinitrc dialog");
d1088 17
a1104 2
    if(NSAlertDefaultReturn == NSRunAlertPanel (nil, msg, NSLocalizedString (@@"Yes", @@""),
                                                NSLocalizedString (@@"No", @@""), nil)) {
a1106 5
      
        snprintf (buf2, sizeof (buf2), "%s.old", buf);
      
        for(i = 1; access (buf2, F_OK) == 0; i++)
            snprintf (buf2, sizeof (buf2), "%s.old.%d", buf, i);
d1108 6
a1113 1
        rename (buf, buf2);
d1115 2
a1116 2
    
 done:
d1121 3
a1123 1
static inline pthread_t create_thread(void *(*func)(void *), void *arg) {
d1126 1
a1126 1
    
d1132 1
a1132 1
    
d1136 3
a1138 1
static void *xpbproxy_x_thread(void *args) {
d1145 3
a1147 1
void X11ApplicationMain (int argc, char **argv, char **envp) {
d1151 1
a1151 1
    while (access ("/tmp/x11-block", F_OK) == 0) sleep (1);
d1153 1
a1153 1
  
d1155 5
a1159 4
    X11App = (X11Application *) [X11Application sharedApplication];
    init_ports ();
    
    app_prefs_domain_cfstr = (CFStringRef)[[NSBundle mainBundle] bundleIdentifier];
d1162 3
a1164 2
        ErrorF("X11ApplicationMain: Unable to determine bundle identifier.  Your installation of XQuartz may be broken.\n");
        app_prefs_domain_cfstr = CFSTR(BUNDLE_ID_PREFIX".X11");
d1170 3
a1172 2
					selector:@@selector (became_key:)
					name:NSWindowDidBecomeKeyNotification object:nil];
d1182 1
a1182 1
    NSMaxY([[NSScreen mainScreen] visibleFrame]);
d1185 2
a1186 1
    eventTranslationQueue = dispatch_queue_create(BUNDLE_ID_PREFIX".X11.NSEventsToX11EventsQueue", NULL);
d1189 1
a1189 1
    
d1192 1
a1192 1
    last_key_layout = TISCopyCurrentKeyboardLayoutInputSource();    
d1194 3
a1196 2
    if(!last_key_layout)
        ErrorF("X11ApplicationMain: Unable to determine TISCopyCurrentKeyboardLayoutInputSource() at startup.\n");
d1199 3
a1201 2
    if(!last_key_layout)
        ErrorF("X11ApplicationMain: Unable to determine KLGetCurrentKeyboardLayout() at startup.\n");
d1210 1
a1210 1
    
d1215 1
a1215 1
    
d1221 1
a1221 1
//    [[SUUpdater sharedUpdater] checkForUpdates:X11App];
d1235 6
a1240 3
static inline int ensure_flag(int flags, int device_independent, int device_dependents, int device_dependent_default) {
    if( (flags & device_independent) &&
       !(flags & device_dependents))
d1247 30
a1276 14
static const char *untrusted_str(NSEvent *e) {
    switch([e type]) {
        case NSScrollWheel:
            return "NSScrollWheel";
        case NSTabletPoint:
            return "NSTabletPoint";
        case NSOtherMouseDown:
            return "NSOtherMouseDown";
        case NSOtherMouseUp:
            return "NSOtherMouseUp";
        case NSLeftMouseDown:
            return "NSLeftMouseDown";
        case NSLeftMouseUp:
            return "NSLeftMouseUp";
d1278 2
a1279 8
            switch([e subtype]) {
                case NSTabletPointEventSubtype:
                    return "NSTabletPointEventSubtype";
                case NSTabletProximityEventSubtype:
                    return "NSTabletProximityEventSubtype";
                default:
                    return "Other";
            }
d1284 7
a1290 1
- (void) sendX11NSEvent:(NSEvent *)e {
d1301 6
a1306 8
#ifdef HAVE_LIBDISPATCH
    static dispatch_once_t once_pred;
    dispatch_once(&once_pred, ^{
        tilt = NSZeroPoint;
        darwinTabletCurrent = darwinTabletStylus;
    });
#else
    if(!darwinTabletCurrent) {
d1310 13
a1322 6
#endif
    
    isMouseOrTabletEvent =  [e type] == NSLeftMouseDown    ||  [e type] == NSOtherMouseDown    ||  [e type] == NSRightMouseDown    ||
                            [e type] == NSLeftMouseUp      ||  [e type] == NSOtherMouseUp      ||  [e type] == NSRightMouseUp      ||
                            [e type] == NSLeftMouseDragged ||  [e type] == NSOtherMouseDragged ||  [e type] == NSRightMouseDragged ||
                            [e type] == NSMouseMoved       ||  [e type] == NSTabletPoint       ||  [e type] == NSScrollWheel;
d1325 3
a1327 1
                    (isMouseOrTabletEvent && ([e subtype] == NSTabletPointEventSubtype || [e subtype] == NSTabletProximityEventSubtype));
d1329 1
a1329 1
    if(isMouseOrTabletEvent) {
d1333 2
a1334 2
	    BOOL hasUntrustedPointerDelta;
        
d1341 1
a1341 1
        
d1345 2
a1346 1
        hasUntrustedPointerDelta = hasUntrustedPointerDelta || [e type] == NSOtherMouseDown || [e type] == NSOtherMouseUp;
d1350 1
a1350 1
        hasUntrustedPointerDelta = hasUntrustedPointerDelta || [e type] == NSScrollWheel;
d1353 2
a1354 1
        hasUntrustedPointerDelta = hasUntrustedPointerDelta || [e type] == NSLeftMouseDown || [e type] == NSLeftMouseUp;
d1356 2
a1357 2
        
        if (window != nil)	{
d1363 2
a1364 1
        } else if(hasUntrustedPointerDelta) {
d1370 4
a1373 2
            ErrorF("  location: (%0.2f, %0.2f)\n", lastpt.x + [e deltaX], lastpt.y - [e deltaY]);
            ErrorF("workaround: (%0.2f, %0.2f)\n", [e locationInWindow].x, [e locationInWindow].y);
d1383 2
a1384 1
        } else {
d1389 1
a1389 1
        
d1393 1
a1393 1
    
d1395 1
a1395 1
    
d1400 12
a1411 4
    modifierFlags = ensure_flag(modifierFlags, NX_CONTROLMASK,   NX_DEVICELCTLKEYMASK   | NX_DEVICERCTLKEYMASK,     NX_DEVICELCTLKEYMASK);
    modifierFlags = ensure_flag(modifierFlags, NX_SHIFTMASK,     NX_DEVICELSHIFTKEYMASK | NX_DEVICERSHIFTKEYMASK,   NX_DEVICELSHIFTKEYMASK);
    modifierFlags = ensure_flag(modifierFlags, NX_COMMANDMASK,   NX_DEVICELCMDKEYMASK   | NX_DEVICERCMDKEYMASK,     NX_DEVICELCMDKEYMASK);
    modifierFlags = ensure_flag(modifierFlags, NX_ALTERNATEMASK, NX_DEVICELALTKEYMASK   | NX_DEVICERALTKEYMASK,     NX_DEVICELALTKEYMASK);
d1420 2
a1421 2
    
    if(darwin_all_modifier_flags != modifierFlags)
a1422 16
    
	switch ([e type]) {
		case NSLeftMouseDown:     ev_button=1; ev_type=ButtonPress;   goto handle_mouse;
		case NSOtherMouseDown:    ev_button=2; ev_type=ButtonPress;   goto handle_mouse;
		case NSRightMouseDown:    ev_button=3; ev_type=ButtonPress;   goto handle_mouse;
		case NSLeftMouseUp:       ev_button=1; ev_type=ButtonRelease; goto handle_mouse;
		case NSOtherMouseUp:      ev_button=2; ev_type=ButtonRelease; goto handle_mouse;
		case NSRightMouseUp:      ev_button=3; ev_type=ButtonRelease; goto handle_mouse;
		case NSLeftMouseDragged:  ev_button=1; ev_type=MotionNotify;  goto handle_mouse;
		case NSOtherMouseDragged: ev_button=2; ev_type=MotionNotify;  goto handle_mouse;
		case NSRightMouseDragged: ev_button=3; ev_type=MotionNotify;  goto handle_mouse;
		case NSMouseMoved:        ev_button=0; ev_type=MotionNotify;  goto handle_mouse;
        case NSTabletPoint:       ev_button=0; ev_type=MotionNotify;  goto handle_mouse;
            
        handle_mouse:
            pDev = darwinPointer;
d1424 70
a1493 16
            /* NSTabletPoint can have no subtype */
            if([e type] != NSTabletPoint &&
               [e subtype] == NSTabletProximityEventSubtype) {
                switch([e pointingDeviceType]) {
                    case NSEraserPointingDevice:
                        darwinTabletCurrent=darwinTabletEraser;
                        break;
                    case NSPenPointingDevice:
                        darwinTabletCurrent=darwinTabletStylus;
                        break;
                    case NSCursorPointingDevice:
                    case NSUnknownPointingDevice:
                    default:
                        darwinTabletCurrent=darwinTabletCursor;
                        break;
                }
d1495 5
a1499 7
                if([e isEnteringProximity])
                    needsProximityIn = YES;
                else
                    DarwinSendProximityEvents(darwinTabletCurrent, ProximityOut,
                                              location.x, location.y, pressure,
                                              tilt.x, tilt.y);
                return;
d1502 8
a1509 10
			if ([e type] == NSTabletPoint || [e subtype] == NSTabletPointEventSubtype) {
                pressure = [e pressure];
                tilt     = [e tilt];
                
                pDev = darwinTabletCurrent;
                
                if(needsProximityIn) {
                    DarwinSendProximityEvents(darwinTabletCurrent, ProximityIn,
                                              location.x, location.y, pressure,
                                              tilt.x, tilt.y);
d1511 13
a1523 2
                    needsProximityIn = NO;
                }
d1525 1
d1527 1
a1527 1
            if(!XQuartzServerVisible && noTestExtensions) {
d1529 9
a1537 9
/* Older libXplugin (Tiger/"Stock" Leopard) aren't thread safe, so we can't call xp_find_window from the Appkit thread */
                xp_window_id wid = 0;
                xp_error err;

                /* Sigh. Need to check that we're really over one of
                 * our windows. (We need to receive pointer events while
                 * not in the foreground, but we don't want to receive them
                 * when another window is over us or we might show a tooltip)
                 */
d1539 1
a1539 1
                err = xp_find_window(location.x, location.y, 0, &wid);
d1541 1
a1541 1
                if (err != XP_Success || (err == XP_Success && wid == 0))
d1543 4
a1546 5
                {
                    bgMouseLocation = location;
                    bgMouseLocationUpdated = TRUE;
                    return;
                }
d1548 7
a1554 7
            
            if(bgMouseLocationUpdated) {
                if(!(ev_type == MotionNotify && ev_button == 0)) {
                    DarwinSendPointerEvents(pDev, MotionNotify, 0, location.x,
                                            location.y, pressure, tilt.x, tilt.y);
                }
                bgMouseLocationUpdated = FALSE;
d1556 24
d1581 4
a1584 3
            DarwinSendPointerEvents(pDev, ev_type, ev_button, location.x, location.y,
                                    pressure, tilt.x, tilt.y);
            
d1586 29
d1616 3
a1618 14
		case NSTabletProximity:
            switch([e pointingDeviceType]) {
                case NSEraserPointingDevice:
                    darwinTabletCurrent=darwinTabletEraser;
                    break;
                case NSPenPointingDevice:
                    darwinTabletCurrent=darwinTabletStylus;
                    break;
                case NSCursorPointingDevice:
                case NSUnknownPointingDevice:
                default:
                    darwinTabletCurrent=darwinTabletCursor;
                    break;
            }
d1620 6
a1625 12
            if([e isEnteringProximity])
                needsProximityIn = YES;
            else
                DarwinSendProximityEvents(darwinTabletCurrent, ProximityOut,
                                          location.x, location.y, pressure,
                                          tilt.x, tilt.y);
            break;
            
		case NSScrollWheel:
            {
                float deltaX = [e deltaX];
                float deltaY = [e deltaY];
d1627 9
a1635 8
                /* If we're in the background, we need to send a MotionNotify event
                * first, since we aren't getting them on background mouse motion
                */
                if(!XQuartzServerVisible && noTestExtensions) {
                    bgMouseLocationUpdated = FALSE;
                    DarwinSendPointerEvents(darwinPointer, MotionNotify, 0, location.x,
                                            location.y, pressure, tilt.x, tilt.y);
                }
d1638 58
a1695 4
                // TODO: Change 1117 to NSAppKitVersionNumber10_7 when it is defined
                if(NSAppKitVersionNumber >= 1117 && XQuartzScrollInDeviceDirection && [e isDirectionInvertedFromDevice]) {
                    deltaX *= -1;
                    deltaY *= -1;
a1696 4
#endif
                DarwinSendScrollEvents(deltaX, deltaY, location.x, location.y,
                                       pressure, tilt.x, tilt.y);
                break;
d1698 10
a1707 4
        case NSKeyDown: case NSKeyUp:
            {
                /* XKB clobbers our keymap at startup, so we need to force it on the first keypress.
                 * TODO: Make this less of a kludge.
d1709 20
a1728 4
                static int force_resync_keymap = YES;
                if(force_resync_keymap) {
                    DarwinSendDDXEvent(kXquartzReloadKeymap, 0);
                    force_resync_keymap = NO;
d1731 18
d1750 1
a1750 1
            if(darwinSyncKeymap) {
d1752 11
a1762 9
                TISInputSourceRef key_layout = TISCopyCurrentKeyboardLayoutInputSource();
                TISInputSourceRef clear;
                if (CFEqual(key_layout, last_key_layout)) {
                    CFRelease(key_layout);
                } else {
                    /* Swap/free thread-safely */
                    clear = last_key_layout;
                    last_key_layout = key_layout;
                    CFRelease(clear);
d1764 9
a1772 9
                KeyboardLayoutRef key_layout;
                KLGetCurrentKeyboardLayout(&key_layout);
                if(key_layout != last_key_layout) {
                    last_key_layout = key_layout;
#endif
                    /* Update keyInfo */
                    if (!QuartsResyncKeymap(TRUE)) {
                        ErrorF("sendX11NSEvent: Could not build a valid keymap.\n");
                    }
d1775 1
d1777 3
a1779 4
            /* Avoid stuck keys on context switch */
            if(keyState[[e keyCode]] == [e type])
                return;
            keyState[[e keyCode]] = [e type];
d1781 3
a1783 5
            DarwinSendKeyboardEvents(([e type] == NSKeyDown) ? KeyPress : KeyRelease, [e keyCode]);
            break;
            
        default: break; /* for gcc */
	}	
@


1.5
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@a43 1
#include "quartz.h"
d52 2
d65 6
d82 5
d198 1
a198 1
    DEBUG_LOG("state=%d, _x_active=%d, \n", state, _x_active)
d246 1
a246 2
                    if (!_x_active && quartzProcs->IsX11Window([e window],
                                                               [e windowNumber]))
d346 2
d350 1
a350 1
                    if ([self modalWindow] == nil) {
d353 4
a356 3
                        
                        /* FIXME: hack to avoid having to pass the event to appkit,
                         which would cause it to raise one of its windows. */
d358 3
a360 3
                        
                        [self activateX:YES];
                        
d381 1
a381 1
                        if ([e data2] & 0x10) // 0x10 is set when we use cmd-tab or the dock icon
d383 1
d393 4
a396 1
                    [self activateX:NO];
d406 9
a414 1
    if (for_x) [self sendX11NSEvent:e];
d795 3
d982 1
a982 1
static inline pthread_t create_thread(void *func, void *arg) {
d998 1
a998 1
    fprintf(stderr, "xpbproxy thread is terminating unexpectedly.\n");
d1015 5
d1036 5
d1046 1
a1046 1
        fprintf(stderr, "X11ApplicationMain: Unable to determine TISCopyCurrentKeyboardLayoutInputSource() at startup.\n");
d1050 1
a1050 1
        fprintf(stderr, "X11ApplicationMain: Unable to determine KLGetCurrentKeyboardLayout() at startup.\n");
d1054 1
a1054 1
        fprintf(stderr, "X11ApplicationMain: Could not build a valid keymap.\n");
d1092 28
d1121 1
a1121 1
    NSPoint location = NSZeroPoint, tilt = NSZeroPoint;
d1123 4
a1126 1
    float pressure = 0.0;
d1131 13
d1173 4
d1185 13
d1200 1
a1264 10
                
                /* NSTabletProximityEventSubtype doesn't encode pressure ant tilt
                 * So we just pretend the motion was caused by the mouse.  Hopefully
                 * we'll have a better solution for this in the future (like maybe
                 * NSTabletProximityEventSubtype will come from NSTabletPoint
                 * rather than NSMouseMoved.
                pressure = [e pressure];
                tilt     = [e tilt];
                pDev = darwinTabletCurrent;                
                 */
d1266 7
a1272 2
                DarwinSendProximityEvents([e isEnteringProximity] ? ProximityIn : ProximityOut,
                                          location.x, location.y);
d1280 8
d1294 1
a1294 1
                xp_error e;
d1302 1
a1302 1
                e = xp_find_window(location.x, location.y, 0, &wid);
d1304 1
a1304 1
                if (e != XP_Success || (e == XP_Success && wid == 0))
d1341 6
a1346 2
			DarwinSendProximityEvents([e isEnteringProximity] ? ProximityIn : ProximityOut,
                                      location.x, location.y);
d1350 3
d1354 19
a1372 7
            /* If we're in the background, we need to send a MotionNotify event
             * first, since we aren't getting them on background mouse motion
             */
            if(!XQuartzServerVisible && noTestExtensions) {
                bgMouseLocationUpdated = FALSE;
                DarwinSendPointerEvents(darwinPointer, MotionNotify, 0, location.x,
                                        location.y, pressure, tilt.x, tilt.y);
a1373 5
#endif
			DarwinSendScrollEvents([e deltaX], [e deltaY], location.x, location.y,
                                   pressure, tilt.x, tilt.y);
            break;
            
d1405 1
a1405 1
                        fprintf(stderr, "sendX11NSEvent: Could not build a valid keymap.\n");
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a720 2
    XQuartzUseSysBeep = [self prefs_get_boolean:@@PREFS_SYSBEEP
                                       default:XQuartzUseSysBeep];
d884 29
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d41 1
a66 3
int X11EnableKeyEquivalents = TRUE, quartzFullscreenMenu = FALSE;
int quartzHasRoot = FALSE, quartzEnableRootless = TRUE;

d288 1
a288 1
                    } else if(X11EnableKeyEquivalents &&
d294 1
a294 1
                    } else if(X11EnableKeyEquivalents &&
d300 1
a300 1
                    } else if(!quartzEnableRootless
d304 1
a304 1
                         * toggle even if X11EnableKeyEquivalents is disabled */
d338 1
a338 1
                        BOOL switch_on_activate, ok;
d348 11
a358 4
                        (void)CFPreferencesAppSynchronize(CFSTR(".GlobalPreferences"));
                        switch_on_activate = CFPreferencesGetAppBooleanValue(CFSTR("AppleSpacesSwitchOnActivate"), CFSTR(".GlobalPreferences"), &ok);
                        if(!ok)
                            switch_on_activate = YES;
d360 9
a368 2
                        if ([e data2] & 0x10 && switch_on_activate) // 0x10 is set when we use cmd-tab or the dock icon
                            DarwinSendDDXEvent(kXquartzBringAllToFront, 0);
d373 1
a373 1
                    if (quartzHasRoot) for_appkit = NO;
d423 1
a423 1
        SetSystemUIMode(kUIModeAllHidden, quartzFullscreenMenu ? kUIOptionAutoShowMenuBar : 0); // kUIModeAllSuppressed or kUIOptionAutoShowMenuBar can be used to allow "mouse-activation"
d721 8
a728 8
    quartzUseSysBeep = [self prefs_get_boolean:@@PREFS_SYSBEEP
                                       default:quartzUseSysBeep];
    quartzEnableRootless = [self prefs_get_boolean:@@PREFS_ROOTLESS
                                           default:quartzEnableRootless];
    quartzFullscreenMenu = [self prefs_get_boolean:@@PREFS_FULLSCREEN_MENU
                                           default:quartzFullscreenMenu];
    quartzFullscreenDisableHotkeys = ![self prefs_get_boolean:@@PREFS_FULLSCREEN_HOTKEYS
                                                      default:!quartzFullscreenDisableHotkeys];
d731 2
a732 2
    quartzOptionSendsAlt = [self prefs_get_boolean:@@PREFS_OPTION_SENDS_ALT
                                           default:quartzOptionSendsAlt];
d760 2
a761 2
    X11EnableKeyEquivalents = [self prefs_get_boolean:@@PREFS_KEYEQUIVS
                                              default:X11EnableKeyEquivalents];
d1159 1
a1159 1
            if(!quartzServerVisible && noTestExtensions) {
d1219 1
a1219 1
            if(!quartzServerVisible && noTestExtensions) {
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d44 1
a44 2
#define _APPLEWM_SERVER_
#include "X11/extensions/applewm.h"
d46 1
d55 1
a55 1
extern BOOL xpbproxy_init (void);
a62 3
#define ProximityIn    0
#define ProximityOut   1

a64 1
static int modifierFlagsMask;
d79 6
a186 3
    /* Create a TSM document that supports full Unicode input, and
     have it activated while X is active */
    static TSMDocumentID x11_document;
d190 4
a194 10

        if (!_x_active) {
            if (x11_document == 0) {
                OSType types[1];
                types[0] = kUnicodeDocument;
                NewTSMDocument (1, types, &x11_document, 0);
            }

            if (x11_document != 0)	ActivateTSMDocument (x11_document);
        }
d197 1
a197 1
        if(darwin_modifier_flags)
a206 3

        if (_x_active && x11_document != 0)
            DeactivateTSMDocument (x11_document);
d246 4
a249 1
                
d256 2
a257 2
                NSRect NSframe = [[NSScreen mainScreen] frame];
                NSRect NSvisibleFrame = [[NSScreen mainScreen] visibleFrame];
d259 1
a259 1
                CGRect CGframe = CGRectMake(NSframe.origin.x, NSframe.origin.y,
d261 1
a261 1
                CGRect CGvisibleFrame = CGRectMake(NSvisibleFrame.origin.x,
d265 1
a265 1
                CGPoint CGlocation = CGPointMake(NSlocation.x, NSlocation.y);
d340 1
a350 1
                        BOOL switch_on_activate, ok;
d355 1
a355 1
                        if ([e data2] & 0x10 && switch_on_activate)
d414 3
d485 1
a485 1
- (CFPropertyListRef) prefs_get:(NSString *)key {
d546 1
a546 1
  value = [self prefs_get:key];
d564 1
a564 1
  value = [self prefs_get:key];
d577 18
d599 1
a599 1
  value = [self prefs_get:key];
d617 1
a617 1
  value = [self prefs_get:key];
d641 1
a641 1
  value = [self prefs_get:key];
d715 2
a716 2
    quartzFullscreenDisableHotkeys = ![self prefs_get_boolean:
                            @@PREFS_FULLSCREEN_HOTKEYS default:!quartzFullscreenDisableHotkeys];
d719 3
d759 8
d775 4
d866 10
d914 20
a935 1
    int *p;
d975 1
a975 2
    memset(keyInfo.keyMap, 0, sizeof(keyInfo.keyMap));
    if (!QuartzReadSystemKeymap(&keyInfo)) {
a978 4
    for(p=darwin_modifier_mask_list, modifierFlagsMask=0; *p; p++) {
        modifierFlagsMask |= *p;
    }
    
d987 9
a995 3
    if(!xpbproxy_init())
        fprintf(stderr, "Error initializing xpbproxy\n");
           
d1015 1
a1015 3
    NSRect screen;
    NSPoint location;
    NSWindow *window;
d1017 1
a1017 1
    float pointer_x, pointer_y, pressure, tilt_x, tilt_y;
d1020 1
d1022 47
a1068 13
    /* convert location to be relative to top-left of primary display */
    location = [e locationInWindow];
    window = [e window];
    screen = [[[NSScreen screens] objectAtIndex:0] frame];

    if (window != nil)	{
        NSRect frame = [window frame];
        pointer_x = location.x + frame.origin.x;
        pointer_y = (screen.origin.y + screen.size.height)
                    - (location.y + frame.origin.y);
    } else {
        pointer_x = location.x;
        pointer_y = (screen.origin.y + screen.size.height) - location.y;
a1069 5

    /* Setup our valuators.  These will range from 0 to 1 */
    pressure = 0;
    tilt_x = 0;
    tilt_y = 0;
d1083 1
a1083 1
    modifierFlags &= modifierFlagsMask;
d1090 1
a1090 1
    if(darwin_modifier_flags != modifierFlags)
d1132 1
a1132 2
                tilt_x   = [e tilt].x;
                tilt_y   = [e tilt].y;
d1136 2
a1137 2
                DarwinSendProximityEvents([e isEnteringProximity]?ProximityIn:ProximityOut,
                                          pointer_x, pointer_y);
d1142 1
a1142 2
                tilt_x   = [e tilt].x;
                tilt_y   = [e tilt].y;
d1147 2
d1150 2
a1151 4
#ifdef XPLUGIN_VERSION
#if XPLUGIN_VERSION > 0
            if(!quartzServerVisible) {
                xp_window_id wid;
d1158 10
a1167 6
                
                wid = 0;
                
                if (xp_find_window(pointer_x, pointer_y, 0, &wid) == XP_Success &&
                    wid == 0)
                    return;        
a1168 2
#endif
#endif
d1170 10
a1179 2
            DarwinSendPointerEvents(pDev, ev_type, ev_button, pointer_x, pointer_y,
                                    pressure, tilt_x, tilt_y);
d1198 2
a1199 2
			DarwinSendProximityEvents([e isEnteringProximity]?ProximityIn:ProximityOut,
                                      pointer_x, pointer_y);
d1203 12
a1214 2
			DarwinSendScrollEvents([e deltaX], [e deltaY], pointer_x, pointer_y,
                                   pressure, tilt_x, tilt_y);
d1218 11
a1245 1

d1247 1
a1247 3
                    pthread_mutex_lock(&keyInfo_mutex);
                    memset(keyInfo.keyMap, 0, sizeof(keyInfo.keyMap));
                    if (!QuartzReadSystemKeymap(&keyInfo)) {
a1249 4
                    pthread_mutex_unlock(&keyInfo_mutex);
                    
                    /* Tell server thread to deal with new keyInfo */
                    DarwinSendDDXEvent(kXquartzReloadKeymap, 0);
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d3 1
a3 1
 Copyright (c) 2002-2007 Apple Inc.
d30 2
a36 1
#include "quartzForeground.h"
a38 1
#include <Carbon/Carbon.h>
d40 7
a46 9
/* ouch! */
#define BOOL X_BOOL
# include "darwin.h"
# include "darwinEvents.h"
# include "quartz.h"
# define _APPLEWM_SERVER_
# include "X11/extensions/applewm.h"
# include "micmap.h"
#undef BOOL
d50 6
a55 1
#include <pthread.h>
d57 5
a61 1
#include "rootlessCommon.h"
d63 2
a64 1
WindowPtr xprGetXWindowFromAppKit(int windowNumber); // xpr/xprFrame.c
d66 3
a68 1
#define DEFAULTS_FILE "/usr/X11/lib/X11/xserver/Xquartz.plist"
d70 1
a70 1
int X11EnableKeyEquivalents = TRUE;
d73 1
a73 2
extern int darwinFakeButtons, input_check_flag;
extern Bool enable_stereo; 
d75 7
a81 1
extern xEvent *darwinEvents;
d85 2
d89 4
a103 2
static void send_nsevent (NSEventType type, NSEvent *e);

d166 2
a167 2
	
    dict = [NSMutableDictionary dictionaryWithCapacity:2];
d169 1
a169 1
	
d171 2
a172 2
			 forKey:@@"ApplicationName"];
	
d174 7
a180 4
	
    [dict setObject:[NSString stringWithFormat:@@"XQuartz %@@ - (xorg-server %s)", tem, XSERVER_VERSION] 
	  forKey:@@"ApplicationVersion"];
	
d184 1
a184 1
- (void) activateX:(BOOL)state {
d186 1
a186 2
	 have it activated while X is active (unless using the old
	 keymapping files) */
d188 2
a189 1
	DEBUG_LOG("state=%d, _x_active=%d, \n", state, _x_active)
d191 11
a201 11
      QuartzMessageServerThread (kXDarwinActivate, 0);
      
      if (!_x_active) {
	if (x11_document == 0 && darwinKeymapFile == NULL) {
	  OSType types[1];
	  types[0] = kUnicodeDocument;
	  NewTSMDocument (1, types, &x11_document, 0);
	}
	
	if (x11_document != 0)	ActivateTSMDocument (x11_document);
      }
d203 14
a216 4
      QuartzMessageServerThread (kXDarwinDeactivate, 0);
      
      if (_x_active && x11_document != 0)
	DeactivateTSMDocument (x11_document);
d218 1
a218 1
    
d223 1
a223 1
    [self activateX:NO];
d227 152
a378 29
  NSEventType type;
  BOOL for_appkit, for_x;
  
  type = [e type];
  
  /* By default pass down the responder chain and to X. */
  for_appkit = YES;
  for_x = YES;
  
  switch (type) {
  case NSLeftMouseDown: case NSRightMouseDown: case NSOtherMouseDown:
  case NSLeftMouseUp: case NSRightMouseUp: case NSOtherMouseUp:
    if ([e window] != nil) {
      /* Pointer event has an (AppKit) window. Probably something for the kit. */
      for_x = NO;
      if (_x_active) [self activateX:NO];
    } else if ([self modalWindow] == nil) {
      /* Must be an X window. Tell appkit it doesn't have focus. */
      WindowPtr pWin = xprGetXWindowFromAppKit([e windowNumber]);
      if (pWin) RootlessReorderWindow(pWin);
      for_appkit = NO;
      
      if ([self isActive]) {
	[self deactivate];
	
	if (!_x_active && quartzProcs->IsX11Window([e window],
						   [e windowNumber]))
	  [self activateX:YES];
      }
a379 38
    break;
      
  case NSKeyDown: case NSKeyUp:
    if (_x_active) {
      static int swallow_up;
      
      /* No kit window is focused, so send it to X. */
      for_appkit = NO;
      if (type == NSKeyDown) {
	/* Before that though, see if there are any global
	   shortcuts bound to it. */
	
	if (X11EnableKeyEquivalents
	    && [[self mainMenu] performKeyEquivalent:e]) {
	  swallow_up = [e keyCode];
	  for_x = NO;
	} else if (!quartzEnableRootless
		   && ([e modifierFlags] & ALL_KEY_MASKS)
		   == (NSCommandKeyMask | NSAlternateKeyMask)
		   && ([e keyCode] == 0 /*a*/
		    || [e keyCode] == 53 /*Esc*/)) {
	  swallow_up = 0;
	  for_x = NO;
#ifdef DARWIN_DDX_MISSING
	  QuartzMessageServerThread (kXDarwinToggleFullscreen, 0);
#endif
	}
      } else {
	/* If we saw a key equivalent on the down, don't pass
	   the up through to X. */
	
	if (swallow_up != 0 && [e keyCode] == swallow_up) {
	  swallow_up = 0;
	  for_x = NO;
	}
      }
    } else for_x = NO;
    break;
d381 1
a381 31
  case NSFlagsChanged:
    /* For the l33t X users who remap modifier keys to normal keysyms. */
    if (!_x_active) for_x = NO;
    break;
    
  case NSAppKitDefined:
    switch ([e subtype]) {
    case NSApplicationActivatedEventType:
      for_x = NO;
      if ([self modalWindow] == nil) {
	for_appkit = NO;
	
	/* FIXME: hack to avoid having to pass the event to appkit,
	   which would cause it to raise one of its windows. */
	_appFlags._active = YES;
	
	[self activateX:YES];
	if ([e data2] & 0x10) X11ApplicationSetFrontProcess();
      }
      break;
      
    case 18: /* ApplicationDidReactivate */
      if (quartzHasRoot) for_appkit = NO;
      break;
      
    case NSApplicationDeactivatedEventType:
      for_x = NO;
      [self activateX:NO];
      break;
    }
    break;
d383 1
a383 6
  default: break; /* for gcc */
  }
  
  if (for_appkit) [super sendEvent:e];
  
  if (for_x) send_nsevent (type, e);
d387 1
a387 1
    [_controller set_window_menu:list];
d391 1
a391 1
    [_controller set_window_menu_check:n];
d395 1
a395 1
    [_controller set_apps_menu:list];
d399 1
a399 4
    /* Hackery needed due to argv[0] hackery */
    //    [self activateX:YES];
    ProcessSerialNumber psn = { 0, kCurrentProcess };
    SetFrontProcess(&psn);
d401 2
a402 1
    QuartzMessageServerThread(kXDarwinBringAllToFront, 0);
d406 1
a406 1
    [_controller set_can_quit:[state boolValue]];
d410 1
a410 1
    [_controller server_ready];
d414 5
a418 2
    if ([state boolValue]) ShowMenuBar ();
    else HideMenuBar ();
d436 27
a462 27
    CFMutableArrayRef out;
    CFArrayCallBacks cb;
    NSObject *ns;
    const CFTypeRef *cf;
    int i, count;
	
    memset (&cb, 0, sizeof (cb));
    cb.version = 0;
    cb.retain = cfretain;
    cb.release = cfrelease;
	
    count = [in count];
    out = CFArrayCreateMutable (NULL, count, &cb);
	
    for (i = 0; i < count; i++) {
      ns = [in objectAtIndex:i];
      
      if ([ns isKindOfClass:[NSArray class]])
	cf = (CFTypeRef) nsarray_to_cfarray ((NSArray *) ns);
      else
	cf = CFRetain ((CFTypeRef) ns);
      
      CFArrayAppendValue (out, cf);
      CFRelease (cf);
    }
    
    return out;
d466 21
a486 21
    NSMutableArray *out;
    const CFTypeRef *cf;
    NSObject *ns;
    int i, count;
	
    count = CFArrayGetCount (in);
    out = [[NSMutableArray alloc] initWithCapacity:count];
	
    for (i = 0; i < count; i++) {
      cf = CFArrayGetValueAtIndex (in, i);
		
      if (CFGetTypeID (cf) == CFArrayGetTypeID ())
	ns = cfarray_to_nsarray ((CFArrayRef) cf);
      else
	ns = [(id)cf retain];
      
      [out addObject:ns];
      [ns release];
    }
    
    return out;
d492 1
a492 1
    value = CFPreferencesCopyAppValue ((CFStringRef) key, CFSTR (APP_PREFS));
d589 1
a589 1
      && CFNumberIsFloatType (value)) 
d644 1
a644 1
    CFPreferencesSetValue ((CFStringRef) key, (CFTypeRef) x, CFSTR (APP_PREFS),
d655 1
a655 1
    CFPreferencesSetValue ((CFStringRef) key, (CFTypeRef) x, CFSTR (APP_PREFS),
d663 2
a664 2
			 (CFTypeRef) value ? kCFBooleanTrue
			 : kCFBooleanFalse, CFSTR (APP_PREFS),
d675 1
a675 1
			 CFSTR (APP_PREFS),
d682 1
a682 1
			 CFSTR (APP_PREFS), kCFPreferencesCurrentUser,
d692 1
d696 1
a696 1
                        default:quartzUseSysBeep];
d698 3
a700 2
                        default:quartzEnableRootless];
#ifdef DARWIN_DDX_MISSING
d702 1
a702 5
					      @@PREFS_FULLSCREEN_HOTKEYS default:
					      !quartzFullscreenDisableHotkeys];
    quartzXpluginOptions = [self prefs_get_integer:@@PREFS_XP_OPTIONS
                            default:quartzXpluginOptions];
#endif
d704 1
a704 1
                         default:darwinFakeButtons];
d706 7
a712 7
      const char *fake2, *fake3;
      
      fake2 = [self prefs_get_string:@@PREFS_FAKE_BUTTON2 default:NULL];
      fake3 = [self prefs_get_string:@@PREFS_FAKE_BUTTON3 default:NULL];
      
      if (fake2 != NULL) darwinFakeMouse2Mask = DarwinParseModifierList(fake2);
      if (fake3 != NULL) darwinFakeMouse3Mask = DarwinParseModifierList(fake3);
d714 3
d718 13
d732 1
a732 1
                               default:X11EnableKeyEquivalents];
d735 2
a736 6
                        default:darwinSyncKeymap];
	
    tem = [self prefs_get_string:@@PREFS_KEYMAP_FILE default:NULL];
    if (tem != NULL) darwinKeymapFile = strdup (tem);
    else             darwinKeymapFile = NULL;
	
d738 4
a741 4
                          default:darwinDesiredDepth];
	
    enable_stereo = [self prefs_get_boolean:@@PREFS_ENABLE_STEREO
                     default:false];
d746 1
a746 1
  QuartzMessageServerThread (kXDarwinPasteboardNotify, 1,
d750 1
a750 1
- (BOOL) x_active {
a836 13
static void * create_thread (void *func, void *arg) {
    pthread_attr_t attr;
    pthread_t tid;
	
    pthread_attr_init (&attr);
    pthread_attr_setscope (&attr, PTHREAD_SCOPE_SYSTEM);
    pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);
    pthread_create (&tid, &attr, func, arg);
    pthread_attr_destroy (&attr);
	
    return (void *) tid;
}

a850 2
    /* FIXME: put localized strings into Resources/English.lproj */
	
d855 6
a860 7
environment?", @@"Startup xinitrc dialog");
	
    if (NSRunAlertPanel (nil, msg, NSLocalizedString (@@"Yes", @@""),
			 NSLocalizedString (@@"No", @@""), nil)
	== NSAlertDefaultReturn) {
      char buf2[1024];
      int i = -1;
d862 1
a862 1
      snprintf (buf2, sizeof (buf2), "%s.old", buf);
d864 4
a867 4
      for (i = 1; access (buf2, F_OK) == 0; i++)
	snprintf (buf2, sizeof (buf2), "%s.old.%d", buf, i);
      
      rename (buf, buf2);
d875 1
a875 1
void X11ApplicationMain (int argc, const char **argv, void (*server_thread) (void *), void *server_arg) {
d877 1
d886 3
a893 1
    check_xinitrc ();
d904 16
a919 4
  
    if (!create_thread (server_thread, server_arg)) {
        ErrorF("can't create secondary thread\n");
        exit (1);
d922 15
a936 2
    QuartzMoveToForeground();

d941 1
a941 1
/* event conversion */
d943 9
a951 14
static inline unsigned short
convert_flags (unsigned int nsflags) {
    unsigned int xflags = 0;
	
    if (nsflags == ~0) return 0xffff;
	
    if (nsflags & NSAlphaShiftKeyMask)	xflags |= LockMask;
    if (nsflags & NSShiftKeyMask)	xflags |= ShiftMask;
    if (nsflags & NSControlKeyMask)	xflags |= ControlMask;
    if (nsflags & NSAlternateKeyMask)	xflags |= Mod1Mask;
    if (nsflags & NSCommandKeyMask)	xflags |= Mod2Mask;
    /* FIXME: secondaryfn? */
	
    return xflags;
d953 1
d955 1
a955 4

// This code should probably be merged with that in XDarwin's XServer.m - BB
static void send_nsevent (NSEventType type, NSEvent *e) {
  //    static unsigned int button_state = 0;
d959 6
a964 5
    int pointer_x, pointer_y, ev_button, ev_type; 
    //    int num_events=0, i=0, state;
    // xEvent xe;
	
    /* convert location to global top-left coordinates */
d968 1
a968 1
		
d970 4
a973 4
      NSRect frame = [window frame];
      pointer_x = location.x + frame.origin.x;
      pointer_y = (((screen.origin.y + screen.size.height)
		    - location.y) - frame.origin.y);
d975 2
a976 2
      pointer_x = location.x;
      pointer_y = (screen.origin.y + screen.size.height) - location.y;
d978 24
d1003 2
a1004 2
    pointer_y -= aquaMenuBarHeight;
    //    state = convert_flags ([e modifierFlags]);
d1006 148
a1153 39
    switch (type) {
    case NSLeftMouseDown:    ev_button=1; ev_type=ButtonPress; goto handle_mouse;
    case NSOtherMouseDown:   ev_button=2; ev_type=ButtonPress; goto handle_mouse;
    case NSRightMouseDown:   ev_button=3; ev_type=ButtonPress; goto handle_mouse;
    case NSLeftMouseUp:      ev_button=1; ev_type=ButtonRelease; goto handle_mouse;
    case NSOtherMouseUp:     ev_button=2; ev_type=ButtonRelease; goto handle_mouse;
    case NSRightMouseUp:     ev_button=3; ev_type=ButtonRelease; goto handle_mouse;
    case NSLeftMouseDragged:  ev_button=1; ev_type=MotionNotify; goto handle_mouse;
    case NSOtherMouseDragged: ev_button=2; ev_type=MotionNotify; goto handle_mouse;
    case NSRightMouseDragged: ev_button=3; ev_type=MotionNotify; goto handle_mouse;
    case NSMouseMoved: ev_button=0; ev_type=MotionNotify; goto handle_mouse;
    handle_mouse:
      
      /* I'm not sure the below code is necessary or useful (-bb)
	if(ev_type==ButtonPress) {
	if (!quartzProcs->IsX11Window([e window], [e windowNumber])) {
	  fprintf(stderr, "Dropping event because it's not a window\n");
	  break;
	}
	button_state |= (1 << ev_button);
	DarwinSendPointerEvents(ev_type, ev_button, pointer_x, pointer_y);
      } else if (ev_type==ButtonRelease && (button_state & (1 << ev_button)) == 0) break;
      */
      DarwinSendPointerEvents(ev_type, ev_button, pointer_x, pointer_y);
      break;
    case NSScrollWheel: 
      DarwinSendScrollEvents([e deltaY], pointer_x, pointer_y);
      break;
      
    case NSKeyDown:  // do we need to translate these keyCodes?
    case NSKeyUp:
      DarwinSendKeyboardEvents((type == NSKeyDown)?KeyPress:KeyRelease, [e keyCode]);
      break;

    case NSFlagsChanged:
      DarwinUpdateModKeys([e modifierFlags]);
      break;
    default: break; /* for gcc */
    }	
d1155 1
@

