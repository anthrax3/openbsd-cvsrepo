head	1.8;
access;
symbols
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.14
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.12
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.10
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.8
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	7pAEtF6Y5EgemkuY;

1.7
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.53;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.02.16.08.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.29;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@/*
   quartzKeyboard.c: Keyboard support for Xquartz

   Copyright (c) 2003-2012 Apple Inc.
   Copyright (c) 2001-2004 Torrey T. Lyons. All Rights Reserved.
   Copyright 2004 Kaleb S. KEITHLEY. All Rights Reserved.

   Copyright (C) 1999,2000 by Eric Sunshine <sunshine@@sunshineco.com>
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the author may not be used to endorse or promote products
        derived from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
   NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "sanitizedCarbon.h"

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#define HACK_MISSING   1
#define HACK_KEYPAD    1
#define HACK_BLACKLIST 1

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/stat.h>
#include <AvailabilityMacros.h>

#include "quartz.h"
#include "darwin.h"
#include "darwinEvents.h"

#include "quartzKeyboard.h"

#include "X11Application.h"

#include <assert.h>
#include <pthread.h>

#include "xkbsrv.h"
#include "exevents.h"
#include "X11/keysym.h"
#include "keysym2ucs.h"

extern void
CopyKeyClass(DeviceIntPtr device, DeviceIntPtr master);

enum {
    MOD_COMMAND = 256,
    MOD_SHIFT = 512,
    MOD_OPTION = 2048,
    MOD_CONTROL = 4096,
};

#define UKEYSYM(u) ((u) | 0x01000000)

#if HACK_MISSING
/* Table of keycode->keysym mappings we use to fallback on for important
   keys that are often not in the Unicode mapping. */

const static struct {
    unsigned short keycode;
    KeySym keysym;
} known_keys[] = {
    { 55,  XK_Meta_L        },
    { 56,  XK_Shift_L       },
    { 57,  XK_Caps_Lock     },
    { 58,  XK_Alt_L         },
    { 59,  XK_Control_L     },

    { 60,  XK_Shift_R       },
    { 61,  XK_Alt_R         },
    { 62,  XK_Control_R     },
    { 63,  XK_Meta_R        },

    { 122, XK_F1            },
    { 120, XK_F2            },
    { 99,  XK_F3            },
    { 118, XK_F4            },
    { 96,  XK_F5            },
    { 97,  XK_F6            },
    { 98,  XK_F7            },
    { 100, XK_F8            },
    { 101, XK_F9            },
    { 109, XK_F10           },
    { 103, XK_F11           },
    { 111, XK_F12           },
    { 105, XK_F13           },
    { 107, XK_F14           },
    { 113, XK_F15           },
};
#endif

#if HACK_KEYPAD
/* Table of keycode->old,new-keysym mappings we use to fixup the numeric
   keypad entries. */

const static struct {
    unsigned short keycode;
    KeySym normal, keypad;
} known_numeric_keys[] = {
    { 65, XK_period,   XK_KP_Decimal                              },
    { 67, XK_asterisk, XK_KP_Multiply                             },
    { 69, XK_plus,     XK_KP_Add                                  },
    { 75, XK_slash,    XK_KP_Divide                               },
    { 76, 0x01000003,  XK_KP_Enter                                },
    { 78, XK_minus,    XK_KP_Subtract                             },
    { 81, XK_equal,    XK_KP_Equal                                },
    { 82, XK_0,        XK_KP_0                                    },
    { 83, XK_1,        XK_KP_1                                    },
    { 84, XK_2,        XK_KP_2                                    },
    { 85, XK_3,        XK_KP_3                                    },
    { 86, XK_4,        XK_KP_4                                    },
    { 87, XK_5,        XK_KP_5                                    },
    { 88, XK_6,        XK_KP_6                                    },
    { 89, XK_7,        XK_KP_7                                    },
    { 91, XK_8,        XK_KP_8                                    },
    { 92, XK_9,        XK_KP_9                                    },
};
#endif

#if HACK_BLACKLIST
/* <rdar://problem/7824370> wine notepad produces wrong characters on shift+arrow
 * http://xquartz.macosforge.org/trac/ticket/295
 * http://developer.apple.com/legacy/mac/library/documentation/mac/Text/Text-579.html
 *
 * legacy Mac keycodes for arrow keys that shift-modify to math symbols
 */
const static unsigned short keycode_blacklist[] = { 66, 70, 72, 77 };
#endif

/* Table mapping normal keysyms to their dead equivalents.
   FIXME: all the unicode keysyms (apart from circumflex) were guessed. */

const static struct {
    KeySym normal, dead;
} dead_keys[] = {
    { XK_grave,       XK_dead_grave                                },
    { XK_apostrophe,  XK_dead_acute                                }, /* US:"=" on a Czech keyboard */
    { XK_acute,       XK_dead_acute                                },
    { UKEYSYM(0x384), XK_dead_acute                                }, /* US:";" on a Greek keyboard */
    //    {XK_Greek_accentdieresis, XK_dead_diaeresis},   /* US:"opt+;" on a Greek keyboard ... replace with dead_accentdieresis if there is one */
    { XK_asciicircum, XK_dead_circumflex                           },
    { UKEYSYM(0x2c6), XK_dead_circumflex                           }, /* MODIFIER LETTER CIRCUMFLEX ACCENT */
    { XK_asciitilde,  XK_dead_tilde                                },
    { UKEYSYM(0x2dc), XK_dead_tilde                                }, /* SMALL TILDE */
    { XK_macron,      XK_dead_macron                               },
    { XK_breve,       XK_dead_breve                                },
    { XK_abovedot,    XK_dead_abovedot                             },
    { XK_diaeresis,   XK_dead_diaeresis                            },
    { UKEYSYM(0x2da), XK_dead_abovering                            }, /* DOT ABOVE */
    { XK_doubleacute, XK_dead_doubleacute                          },
    { XK_caron,       XK_dead_caron                                },
    { XK_cedilla,     XK_dead_cedilla                              },
    { XK_ogonek,      XK_dead_ogonek                               },
    { UKEYSYM(0x269), XK_dead_iota                                 }, /* LATIN SMALL LETTER IOTA */
    { UKEYSYM(0x2ec), XK_dead_voiced_sound                         }, /* MODIFIER LETTER VOICING */
    /*  {XK_semivoiced_sound, XK_dead_semivoiced_sound}, */
    { UKEYSYM(0x323), XK_dead_belowdot                             }, /* COMBINING DOT BELOW */
    { UKEYSYM(0x309), XK_dead_hook                                 }, /* COMBINING HOOK ABOVE */
    { UKEYSYM(0x31b), XK_dead_horn                                 }, /* COMBINING HORN */
};

typedef struct darwinKeyboardInfo_struct {
    CARD8 modMap[MAP_LENGTH];
    KeySym keyMap[MAP_LENGTH * GLYPHS_PER_KEY];
    unsigned char modifierKeycodes[32][2];
} darwinKeyboardInfo;

darwinKeyboardInfo keyInfo;
pthread_mutex_t keyInfo_mutex = PTHREAD_MUTEX_INITIALIZER;

static void
DarwinChangeKeyboardControl(DeviceIntPtr device, KeybdCtrl *ctrl)
{
    // FIXME: to be implemented
    // keyclick, bell volume / pitch, autorepead, LED's
}

//-----------------------------------------------------------------------------
// Utility functions to help parse Darwin keymap
//-----------------------------------------------------------------------------

/*
 * DarwinBuildModifierMaps
 *      Use the keyMap field of keyboard info structure to populate
 *      the modMap and modifierKeycodes fields.
 */
static void
DarwinBuildModifierMaps(darwinKeyboardInfo *info)
{
    int i;
    KeySym *k;

    memset(info->modMap, NoSymbol, sizeof(info->modMap));
    memset(info->modifierKeycodes, 0, sizeof(info->modifierKeycodes));

    for (i = 0; i < NUM_KEYCODES; i++) {
        k = info->keyMap + i * GLYPHS_PER_KEY;

        switch (*k) {
        case XK_Shift_L:
            info->modifierKeycodes[NX_MODIFIERKEY_SHIFT][0] = i;
            info->modMap[MIN_KEYCODE + i] = ShiftMask;
            break;

        case XK_Shift_R:
#ifdef NX_MODIFIERKEY_RSHIFT
            info->modifierKeycodes[NX_MODIFIERKEY_RSHIFT][0] = i;
#else
            info->modifierKeycodes[NX_MODIFIERKEY_SHIFT][0] = i;
#endif
            info->modMap[MIN_KEYCODE + i] = ShiftMask;
            break;

        case XK_Control_L:
            info->modifierKeycodes[NX_MODIFIERKEY_CONTROL][0] = i;
            info->modMap[MIN_KEYCODE + i] = ControlMask;
            break;

        case XK_Control_R:
#ifdef NX_MODIFIERKEY_RCONTROL
            info->modifierKeycodes[NX_MODIFIERKEY_RCONTROL][0] = i;
#else
            info->modifierKeycodes[NX_MODIFIERKEY_CONTROL][0] = i;
#endif
            info->modMap[MIN_KEYCODE + i] = ControlMask;
            break;

        case XK_Caps_Lock:
            info->modifierKeycodes[NX_MODIFIERKEY_ALPHALOCK][0] = i;
            info->modMap[MIN_KEYCODE + i] = LockMask;
            break;

        case XK_Alt_L:
            info->modifierKeycodes[NX_MODIFIERKEY_ALTERNATE][0] = i;
            info->modMap[MIN_KEYCODE + i] = Mod1Mask;
            if (!XQuartzOptionSendsAlt)
                *k = XK_Mode_switch;     // Yes, this is ugly.  This needs to be cleaned up when we integrate quartzKeyboard with this code and refactor.
            break;

        case XK_Alt_R:
#ifdef NX_MODIFIERKEY_RALTERNATE
            info->modifierKeycodes[NX_MODIFIERKEY_RALTERNATE][0] = i;
#else
            info->modifierKeycodes[NX_MODIFIERKEY_ALTERNATE][0] = i;
#endif
            if (!XQuartzOptionSendsAlt)
                *k = XK_Mode_switch;     // Yes, this is ugly.  This needs to be cleaned up when we integrate quartzKeyboard with this code and refactor.
            info->modMap[MIN_KEYCODE + i] = Mod1Mask;
            break;

        case XK_Mode_switch:
            ErrorF(
                "DarwinBuildModifierMaps: XK_Mode_switch encountered, unable to determine side.\n");
            info->modifierKeycodes[NX_MODIFIERKEY_ALTERNATE][0] = i;
#ifdef NX_MODIFIERKEY_RALTERNATE
            info->modifierKeycodes[NX_MODIFIERKEY_RALTERNATE][0] = i;
#endif
            info->modMap[MIN_KEYCODE + i] = Mod1Mask;
            break;

        case XK_Meta_L:
            info->modifierKeycodes[NX_MODIFIERKEY_COMMAND][0] = i;
            info->modMap[MIN_KEYCODE + i] = Mod2Mask;
            break;

        case XK_Meta_R:
#ifdef NX_MODIFIERKEY_RCOMMAND
            info->modifierKeycodes[NX_MODIFIERKEY_RCOMMAND][0] = i;
#else
            info->modifierKeycodes[NX_MODIFIERKEY_COMMAND][0] = i;
#endif
            info->modMap[MIN_KEYCODE + i] = Mod2Mask;
            break;

        case XK_Num_Lock:
            info->modMap[MIN_KEYCODE + i] = Mod3Mask;
            break;
        }
    }
}

/*
 * DarwinKeyboardInit
 *      Get the Darwin keyboard map and compute an equivalent
 *      X keyboard map and modifier map. Set the new keyboard
 *      device structure.
 */
void
DarwinKeyboardInit(DeviceIntPtr pDev)
{
    // Open a shared connection to the HID System.
    // Note that the Event Status Driver is really just a wrapper
    // for a kIOHIDParamConnectType connection.
    assert(darwinParamConnect = NXOpenEventStatus());

    InitKeyboardDeviceStruct(pDev, NULL, NULL, DarwinChangeKeyboardControl);

    DarwinKeyboardReloadHandler();

    CopyKeyClass(pDev, inputInfo.keyboard);
}

/* Set the repeat rates based on global preferences and keycodes for modifiers.
 * Precondition: Has the keyInfo_mutex lock.
 */
static void
DarwinKeyboardSetRepeat(DeviceIntPtr pDev, int initialKeyRepeatValue,
                        int keyRepeatValue)
{
    if (initialKeyRepeatValue == 300000) { // off
        /* Turn off repeats globally */
        XkbSetRepeatKeys(pDev, -1, AutoRepeatModeOff);
    }
    else {
        int i;
        XkbControlsPtr ctrl;
        XkbControlsRec old;

        /* Turn on repeats globally */
        XkbSetRepeatKeys(pDev, -1, AutoRepeatModeOn);

        /* Setup the bit mask for individual key repeats */
        ctrl = pDev->key->xkbInfo->desc->ctrls;
        old = *ctrl;

        ctrl->repeat_delay = initialKeyRepeatValue * 15;
        ctrl->repeat_interval = keyRepeatValue * 15;

        /* Turn off key-repeat for modifier keys, on for others */
        /* First set them all on */
        for (i = 0; i < XkbPerKeyBitArraySize; i++)
            ctrl->per_key_repeat[i] = -1;

        /* Now turn off the modifiers */
        for (i = 0; i < 32; i++) {
            unsigned char keycode;

            keycode = keyInfo.modifierKeycodes[i][0];
            if (keycode)
                ClearBit(ctrl->per_key_repeat, keycode + MIN_KEYCODE);

            keycode = keyInfo.modifierKeycodes[i][1];
            if (keycode)
                ClearBit(ctrl->per_key_repeat, keycode + MIN_KEYCODE);
        }

        /* Hurray for data duplication */
        if (pDev->kbdfeed)
            memcpy(pDev->kbdfeed->ctrl.autoRepeats, ctrl->per_key_repeat,
                   XkbPerKeyBitArraySize);

        //ErrorF("per_key_repeat =\n");
        //for(i=0; i < XkbPerKeyBitArraySize; i++)
        //    ErrorF("%02x%s", ctrl->per_key_repeat[i], (i + 1) & 7 ? "" : "\n");

        /* And now we notify the puppies about the changes */
        XkbDDXChangeControls(pDev, &old, ctrl);
    }
}

void
DarwinKeyboardReloadHandler(void)
{
    KeySymsRec keySyms;
    CFIndex initialKeyRepeatValue, keyRepeatValue;
    BOOL ok;
    DeviceIntPtr pDev;
    const char *xmodmap = PROJECTROOT "/bin/xmodmap";
    const char *sysmodmap = PROJECTROOT "/lib/X11/xinit/.Xmodmap";
    const char *homedir = getenv("HOME");
    char usermodmap[PATH_MAX], cmd[PATH_MAX];

    DEBUG_LOG("DarwinKeyboardReloadHandler\n");

    /* Get our key repeat settings from GlobalPreferences */
    (void)CFPreferencesAppSynchronize(CFSTR(".GlobalPreferences"));

    initialKeyRepeatValue =
        CFPreferencesGetAppIntegerValue(CFSTR("InitialKeyRepeat"),
                                        CFSTR(".GlobalPreferences"), &ok);
    if (!ok)
        initialKeyRepeatValue = 35;

    keyRepeatValue = CFPreferencesGetAppIntegerValue(CFSTR(
                                                         "KeyRepeat"),
                                                     CFSTR(
                                                         ".GlobalPreferences"),
                                                     &ok);
    if (!ok)
        keyRepeatValue = 6;

    pthread_mutex_lock(&keyInfo_mutex);
    {
        /* Initialize our keySyms */
        keySyms.map = keyInfo.keyMap;
        keySyms.mapWidth = GLYPHS_PER_KEY;
        keySyms.minKeyCode = MIN_KEYCODE;
        keySyms.maxKeyCode = MAX_KEYCODE;

        // TODO: We should build the entire XkbDescRec and use XkbCopyKeymap
        /* Apply the mappings to darwinKeyboard */
        XkbApplyMappingChange(darwinKeyboard, &keySyms, keySyms.minKeyCode,
                              keySyms.maxKeyCode - keySyms.minKeyCode + 1,
                              keyInfo.modMap, serverClient);
        DarwinKeyboardSetRepeat(darwinKeyboard, initialKeyRepeatValue,
                                keyRepeatValue);

        /* Apply the mappings to the core keyboard */
        for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
            if ((pDev->coreEvents ||
                 pDev == inputInfo.keyboard) && pDev->key) {
                XkbApplyMappingChange(
                    pDev, &keySyms, keySyms.minKeyCode,
                    keySyms.maxKeyCode -
                    keySyms.minKeyCode + 1,
                    keyInfo.modMap, serverClient);
                DarwinKeyboardSetRepeat(pDev, initialKeyRepeatValue,
                                        keyRepeatValue);
            }
        }
    } pthread_mutex_unlock(&keyInfo_mutex);

    /* Modify with xmodmap */
    if (access(xmodmap, F_OK) == 0) {
        /* Check for system .Xmodmap */
        if (access(sysmodmap, F_OK) == 0) {
            if (snprintf(cmd, sizeof(cmd), "%s %s", xmodmap,
                         sysmodmap) < sizeof(cmd)) {
                X11ApplicationLaunchClient(cmd);
            }
            else {
                ErrorF(
                    "X11.app: Unable to create / execute xmodmap command line");
            }
        }

        /* Check for user's local .Xmodmap */
        if ((homedir != NULL) &&
            (snprintf(usermodmap, sizeof(usermodmap), "%s/.Xmodmap",
                      homedir) < sizeof(usermodmap))) {
            if (access(usermodmap, F_OK) == 0) {
                if (snprintf(cmd, sizeof(cmd), "%s %s", xmodmap,
                             usermodmap) < sizeof(cmd)) {
                    X11ApplicationLaunchClient(cmd);
                }
                else {
                    ErrorF(
                        "X11.app: Unable to create / execute xmodmap command line");
                }
            }
        }
        else {
            ErrorF("X11.app: Unable to determine path to user's .Xmodmap");
        }
    }
}

//-----------------------------------------------------------------------------
// Modifier translation functions
//
// There are three different ways to specify a Mac modifier key:
// keycode - specifies hardware key, read from keymapping
// key     - NX_MODIFIERKEY_*, really an index
// mask    - NX_*MASK, mask for modifier flags in event record
// Left and right side have different keycodes but the same key and mask.
//-----------------------------------------------------------------------------

/*
 * DarwinModifierNXKeyToNXKeycode
 *      Return the keycode for an NX_MODIFIERKEY_* modifier.
 *      side = 0 for left or 1 for right.
 *      Returns 0 if key+side is not a known modifier.
 */
int
DarwinModifierNXKeyToNXKeycode(int key, int side)
{
    int retval;
    pthread_mutex_lock(&keyInfo_mutex);
    retval = keyInfo.modifierKeycodes[key][side];
    pthread_mutex_unlock(&keyInfo_mutex);

    return retval;
}

/*
 * DarwinModifierNXKeycodeToNXKey
 *      Returns -1 if keycode+side is not a modifier key
 *      outSide may be NULL, else it gets 0 for left and 1 for right.
 */
int
DarwinModifierNXKeycodeToNXKey(unsigned char keycode, int *outSide)
{
    int key, side;

    keycode += MIN_KEYCODE;

    // search modifierKeycodes for this keycode+side
    pthread_mutex_lock(&keyInfo_mutex);
    for (key = 0; key < NX_NUMMODIFIERS; key++) {
        for (side = 0; side <= 1; side++) {
            if (keyInfo.modifierKeycodes[key][side] == keycode) break;
        }
    }
    pthread_mutex_unlock(&keyInfo_mutex);

    if (key == NX_NUMMODIFIERS) {
        return -1;
    }
    if (outSide) *outSide = side;

    return key;
}

/*
 * DarwinModifierNXMaskToNXKey
 *      Returns -1 if mask is not a known modifier mask.
 */
int
DarwinModifierNXMaskToNXKey(int mask)
{
    switch (mask) {
    case NX_ALPHASHIFTMASK:
        return NX_MODIFIERKEY_ALPHALOCK;

    case NX_SHIFTMASK:
        return NX_MODIFIERKEY_SHIFT;

#ifdef NX_DEVICELSHIFTKEYMASK
    case NX_DEVICELSHIFTKEYMASK:
        return NX_MODIFIERKEY_SHIFT;

    case NX_DEVICERSHIFTKEYMASK:
        return NX_MODIFIERKEY_RSHIFT;

#endif
    case NX_CONTROLMASK:
        return NX_MODIFIERKEY_CONTROL;

#ifdef NX_DEVICELCTLKEYMASK
    case NX_DEVICELCTLKEYMASK:
        return NX_MODIFIERKEY_CONTROL;

    case NX_DEVICERCTLKEYMASK:
        return NX_MODIFIERKEY_RCONTROL;

#endif
    case NX_ALTERNATEMASK:
        return NX_MODIFIERKEY_ALTERNATE;

#ifdef NX_DEVICELALTKEYMASK
    case NX_DEVICELALTKEYMASK:
        return NX_MODIFIERKEY_ALTERNATE;

    case NX_DEVICERALTKEYMASK:
        return NX_MODIFIERKEY_RALTERNATE;

#endif
    case NX_COMMANDMASK:
        return NX_MODIFIERKEY_COMMAND;

#ifdef NX_DEVICELCMDKEYMASK
    case NX_DEVICELCMDKEYMASK:
        return NX_MODIFIERKEY_COMMAND;

    case NX_DEVICERCMDKEYMASK:
        return NX_MODIFIERKEY_RCOMMAND;

#endif
    case NX_NUMERICPADMASK:
        return NX_MODIFIERKEY_NUMERICPAD;

    case NX_HELPMASK:
        return NX_MODIFIERKEY_HELP;

    case NX_SECONDARYFNMASK:
        return NX_MODIFIERKEY_SECONDARYFN;
    }
    return -1;
}

/*
 * DarwinModifierNXKeyToNXMask
 *      Returns 0 if key is not a known modifier key.
 */
int
DarwinModifierNXKeyToNXMask(int key)
{
    switch (key) {
    case NX_MODIFIERKEY_ALPHALOCK:
        return NX_ALPHASHIFTMASK;

#ifdef NX_DEVICELSHIFTKEYMASK
    case NX_MODIFIERKEY_SHIFT:
        return NX_DEVICELSHIFTKEYMASK;

    case NX_MODIFIERKEY_RSHIFT:
        return NX_DEVICERSHIFTKEYMASK;

    case NX_MODIFIERKEY_CONTROL:
        return NX_DEVICELCTLKEYMASK;

    case NX_MODIFIERKEY_RCONTROL:
        return NX_DEVICERCTLKEYMASK;

    case NX_MODIFIERKEY_ALTERNATE:
        return NX_DEVICELALTKEYMASK;

    case NX_MODIFIERKEY_RALTERNATE:
        return NX_DEVICERALTKEYMASK;

    case NX_MODIFIERKEY_COMMAND:
        return NX_DEVICELCMDKEYMASK;

    case NX_MODIFIERKEY_RCOMMAND:
        return NX_DEVICERCMDKEYMASK;

#else
    case NX_MODIFIERKEY_SHIFT:
        return NX_SHIFTMASK;

    case NX_MODIFIERKEY_CONTROL:
        return NX_CONTROLMASK;

    case NX_MODIFIERKEY_ALTERNATE:
        return NX_ALTERNATEMASK;

    case NX_MODIFIERKEY_COMMAND:
        return NX_COMMANDMASK;

#endif
    case NX_MODIFIERKEY_NUMERICPAD:
        return NX_NUMERICPADMASK;

    case NX_MODIFIERKEY_HELP:
        return NX_HELPMASK;

    case NX_MODIFIERKEY_SECONDARYFN:
        return NX_SECONDARYFNMASK;
    }
    return 0;
}

/*
 * DarwinModifierStringToNXMask
 *      Returns 0 if string is not a known modifier.
 */
int
DarwinModifierStringToNXMask(const char *str, int separatelr)
{
#ifdef NX_DEVICELSHIFTKEYMASK
    if (separatelr) {
        if (!strcasecmp(str,
                        "shift")) return NX_DEVICELSHIFTKEYMASK |
                   NX_DEVICERSHIFTKEYMASK;
        if (!strcasecmp(str,
                        "control")) return NX_DEVICELCTLKEYMASK |
                   NX_DEVICERCTLKEYMASK;
        if (!strcasecmp(str,
                        "option")) return NX_DEVICELALTKEYMASK |
                   NX_DEVICERALTKEYMASK;
        if (!strcasecmp(str,
                        "alt")) return NX_DEVICELALTKEYMASK |
                   NX_DEVICERALTKEYMASK;
        if (!strcasecmp(str,
                        "command")) return NX_DEVICELCMDKEYMASK |
                   NX_DEVICERCMDKEYMASK;
        if (!strcasecmp(str, "lshift")) return NX_DEVICELSHIFTKEYMASK;
        if (!strcasecmp(str, "rshift")) return NX_DEVICERSHIFTKEYMASK;
        if (!strcasecmp(str, "lcontrol")) return NX_DEVICELCTLKEYMASK;
        if (!strcasecmp(str, "rcontrol")) return NX_DEVICERCTLKEYMASK;
        if (!strcasecmp(str, "loption")) return NX_DEVICELALTKEYMASK;
        if (!strcasecmp(str, "roption")) return NX_DEVICERALTKEYMASK;
        if (!strcasecmp(str, "lalt")) return NX_DEVICELALTKEYMASK;
        if (!strcasecmp(str, "ralt")) return NX_DEVICERALTKEYMASK;
        if (!strcasecmp(str, "lcommand")) return NX_DEVICELCMDKEYMASK;
        if (!strcasecmp(str, "rcommand")) return NX_DEVICERCMDKEYMASK;
    }
    else {
#endif
    if (!strcasecmp(str, "shift")) return NX_SHIFTMASK;
    if (!strcasecmp(str, "control")) return NX_CONTROLMASK;
    if (!strcasecmp(str, "option")) return NX_ALTERNATEMASK;
    if (!strcasecmp(str, "alt")) return NX_ALTERNATEMASK;
    if (!strcasecmp(str, "command")) return NX_COMMANDMASK;
    if (!strcasecmp(str, "lshift")) return NX_SHIFTMASK;
    if (!strcasecmp(str, "rshift")) return NX_SHIFTMASK;
    if (!strcasecmp(str, "lcontrol")) return NX_CONTROLMASK;
    if (!strcasecmp(str, "rcontrol")) return NX_CONTROLMASK;
    if (!strcasecmp(str, "loption")) return NX_ALTERNATEMASK;
    if (!strcasecmp(str, "roption")) return NX_ALTERNATEMASK;
    if (!strcasecmp(str, "lalt")) return NX_ALTERNATEMASK;
    if (!strcasecmp(str, "ralt")) return NX_ALTERNATEMASK;
    if (!strcasecmp(str, "lcommand")) return NX_COMMANDMASK;
    if (!strcasecmp(str, "rcommand")) return NX_COMMANDMASK;
#ifdef NX_DEVICELSHIFTKEYMASK
}
#endif
    if (!strcasecmp(str, "lock")) return NX_ALPHASHIFTMASK;
    if (!strcasecmp(str, "fn")) return NX_SECONDARYFNMASK;
    if (!strcasecmp(str, "help")) return NX_HELPMASK;
    if (!strcasecmp(str, "numlock")) return NX_NUMERICPADMASK;
    return 0;
}

/*
 * LegalModifier
 *      This allows the ddx layer to prevent some keys from being remapped
 *      as modifier keys.
 */
Bool
LegalModifier(unsigned int key, DeviceIntPtr pDev)
{
    return 1;
}

#if !defined(__LP64__) || MAC_OS_X_VERSION_MIN_REQUIRED < 1050
static inline UniChar
macroman2ucs(unsigned char c)
{
    /* Precalculated table mapping MacRoman-128 to Unicode. Generated
       by creating single element CFStringRefs then extracting the
       first character. */

    static const unsigned short table[128] = {
        0xc4,   0xc5,     0xc7,       0xc9,       0xd1,       0xd6,       0xdc,
        0xe1,
        0xe0,   0xe2,     0xe4,     0xe3,     0xe5,   0xe7,     0xe9,
        0xe8,
        0xea,   0xeb,     0xed,     0xec,     0xee,   0xef,     0xf1,
        0xf3,
        0xf2,   0xf4,     0xf6,     0xf5,     0xfa,   0xf9,     0xfb,
        0xfc,
        0x2020, 0xb0,     0xa2,     0xa3,     0xa7,   0x2022,   0xb6,
        0xdf,
        0xae,   0xa9,     0x2122,   0xb4,     0xa8,   0x2260,   0xc6,
        0xd8,
        0x221e, 0xb1,     0x2264,   0x2265,   0xa5,   0xb5,     0x2202,
        0x2211,
        0x220f, 0x3c0,    0x222b,   0xaa,     0xba,   0x3a9,    0xe6,
        0xf8,
        0xbf,   0xa1,     0xac,     0x221a,   0x192,  0x2248,   0x2206,
        0xab,
        0xbb,   0x2026,   0xa0,     0xc0,     0xc3,   0xd5,     0x152,
        0x153,
        0x2013, 0x2014,   0x201c,   0x201d,   0x2018, 0x2019,   0xf7,
        0x25ca,
        0xff,   0x178,    0x2044,   0x20ac,   0x2039, 0x203a,   0xfb01,
        0xfb02,
        0x2021, 0xb7,     0x201a,   0x201e,   0x2030, 0xc2,     0xca,
        0xc1,
        0xcb,   0xc8,     0xcd,     0xce,     0xcf,   0xcc,     0xd3,
        0xd4,
        0xf8ff, 0xd2,     0xda,     0xdb,     0xd9,   0x131,    0x2c6,
        0x2dc,
        0xaf,   0x2d8,    0x2d9,    0x2da,    0xb8,   0x2dd,    0x2db,
        0x2c7,
    };

    if (c < 128) return c;
    else return table[c - 128];
}
#endif

static KeySym
make_dead_key(KeySym in)
{
    int i;

    for (i = 0; i < sizeof(dead_keys) / sizeof(dead_keys[0]); i++)
        if (dead_keys[i].normal == in) return dead_keys[i].dead;

    return in;
}

static Bool
QuartzReadSystemKeymap(darwinKeyboardInfo *info)
{
#if !defined(__LP64__) || MAC_OS_X_VERSION_MIN_REQUIRED < 1050
    KeyboardLayoutRef key_layout;
    int is_uchr = 1;
#endif
    const void *chr_data = NULL;
    int num_keycodes = NUM_KEYCODES;
    UInt32 keyboard_type = LMGetKbdType();
    int i, j;
    OSStatus err;
    KeySym *k;
    CFDataRef currentKeyLayoutDataRef = NULL;

#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
    TISInputSourceRef currentKeyLayoutRef =
        TISCopyCurrentKeyboardLayoutInputSource();

    if (currentKeyLayoutRef) {
        currentKeyLayoutDataRef = (CFDataRef)TISGetInputSourceProperty(
            currentKeyLayoutRef, kTISPropertyUnicodeKeyLayoutData);
        if (currentKeyLayoutDataRef)
            chr_data = CFDataGetBytePtr(currentKeyLayoutDataRef);
    }
#endif

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations" // KLGetCurrentKeyboardLayout, KLGetKeyboardLayoutProperty
#endif

#if !defined(__LP64__) || MAC_OS_X_VERSION_MIN_REQUIRED < 1050
    if (chr_data == NULL) {
#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
        ErrorF(
            "X11.app: Error detected in determining keyboard layout.  If you are using an Apple-provided keyboard layout, please report this error at http://xquartz.macosforge.org and http://bugreport.apple.com\n");
        ErrorF(
            "X11.app: Debug Info: keyboard_type=%u, currentKeyLayoutRef=%p, currentKeyLayoutDataRef=%p, chr_data=%p\n",
            (unsigned)keyboard_type, currentKeyLayoutRef,
            currentKeyLayoutDataRef, chr_data);
#endif

        KLGetCurrentKeyboardLayout(&key_layout);
        KLGetKeyboardLayoutProperty(key_layout, kKLuchrData, &chr_data);

#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
        if (chr_data != NULL) {
            ErrorF(
                "X11.app: Fallback succeeded, but this is still a bug.  Please report the above information.\n");
        }
#endif
    }

    if (chr_data == NULL) {
        ErrorF(
            "X11.app: Debug Info: kKLuchrData failed, trying kKLKCHRData.\n");
        ErrorF(
            "If you are using a 3rd party keyboard layout, please see http://xquartz.macosforge.org/trac/ticket/154\n");
        KLGetKeyboardLayoutProperty(key_layout, kKLKCHRData, &chr_data);
        is_uchr = 0;
        num_keycodes = 128;

#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
        if (chr_data != NULL) {
            ErrorF(
                "X11.app: Fallback succeeded, but this is still a bug.  Please report the above information.\n");
        }
#endif
    }
#endif

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
    if (currentKeyLayoutRef)
        CFRelease(currentKeyLayoutRef);
#endif

    if (chr_data == NULL) {
        ErrorF("Couldn't get uchr or kchr resource\n");
        return FALSE;
    }

    /* Scan the keycode range for the Unicode character that each
       key produces in the four shift states. Then convert that to
       an X11 keysym (which may just the bit that says "this is
       Unicode" if it can't find the real symbol.) */

    /* KeyTranslate is not available on 64-bit platforms; UCKeyTranslate
       must be used instead. */

    for (i = 0; i < num_keycodes; i++) {
        static const int mods[4] = {
            0, MOD_SHIFT, MOD_OPTION,
            MOD_OPTION | MOD_SHIFT
        };

        k = info->keyMap + i * GLYPHS_PER_KEY;

        for (j = 0; j < 4; j++) {
#if !defined(__LP64__) || MAC_OS_X_VERSION_MIN_REQUIRED < 1050
            if (is_uchr) {
#endif
            UniChar s[8];
            UniCharCount len;
            UInt32 dead_key_state = 0, extra_dead = 0;

            err = UCKeyTranslate(chr_data, i, kUCKeyActionDown,
                                 mods[j] >> 8, keyboard_type, 0,
                                 &dead_key_state, 8, &len, s);
            if (err != noErr) continue;

            if (len == 0 && dead_key_state != 0) {
                /* Found a dead key. Work out which one it is, but
                   remembering that it's dead. */
                err = UCKeyTranslate(chr_data, i, kUCKeyActionDown,
                                     mods[j] >> 8, keyboard_type,
                                     kUCKeyTranslateNoDeadKeysMask,
                                     &extra_dead, 8, &len, s);
                if (err != noErr) continue;
            }

            /* Not sure why 0x0010 is there.
             * 0x0000 - <rdar://problem/7793566> 'Unicode Hex Input' ...
             */
            if (len > 0 && s[0] != 0x0010 && s[0] != 0x0000) {
                k[j] = ucs2keysym(s[0]);
                if (dead_key_state != 0) k[j] = make_dead_key(k[j]);
            }
#if !defined(__LP64__) || MAC_OS_X_VERSION_MIN_REQUIRED < 1050
        }
        else {       // kchr
            UInt32 c, state = 0, state2 = 0;
            UInt16 code;

            code = i | mods[j];

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations" // KeyTranslate
#endif

            c = KeyTranslate(chr_data, code, &state);

            /* Dead keys are only processed on key-down, so ask
               to translate those events. When we find a dead key,
               translating the matching key up event will give
               us the actual dead character. */

            if (state != 0)
                c = KeyTranslate(chr_data, code | 128, &state2);

#ifdef __clang__
#pragma clang diagnostic pop
#endif

            /* Characters seem to be in MacRoman encoding. */

            if (c != 0 && c != 0x0010) {
                k[j] = ucs2keysym(macroman2ucs(c & 255));

                if (state != 0) k[j] = make_dead_key(k[j]);
            }
        }
#endif
        }

        if (k[3] == k[2]) k[3] = NoSymbol;
        if (k[1] == k[0]) k[1] = NoSymbol;
        if (k[0] == k[2] && k[1] == k[3]) k[2] = k[3] = NoSymbol;
        if (k[3] == k[0] && k[2] == k[1] && k[2] == NoSymbol) k[3] = NoSymbol;
    }

#if HACK_MISSING
    /* Fix up some things that are normally missing.. */

    for (i = 0; i < sizeof(known_keys) / sizeof(known_keys[0]); i++) {
        k = info->keyMap + known_keys[i].keycode * GLYPHS_PER_KEY;

        if (k[0] == NoSymbol && k[1] == NoSymbol
            && k[2] == NoSymbol && k[3] == NoSymbol)
            k[0] = known_keys[i].keysym;
    }
#endif

#if HACK_KEYPAD
    /* And some more things. We find the right symbols for the numeric
       keypad, but not the KP_ keysyms. So try to convert known keycodes. */
    for (i = 0; i < sizeof(known_numeric_keys) / sizeof(known_numeric_keys[0]);
         i++) {
        k = info->keyMap + known_numeric_keys[i].keycode * GLYPHS_PER_KEY;

        if (k[0] == known_numeric_keys[i].normal)
            k[0] = known_numeric_keys[i].keypad;
    }
#endif

#if HACK_BLACKLIST
    for (i = 0; i < sizeof(keycode_blacklist) / sizeof(keycode_blacklist[0]);
         i++) {
        k = info->keyMap + keycode_blacklist[i] * GLYPHS_PER_KEY;
        k[0] = k[1] = k[2] = k[3] = NoSymbol;
    }
#endif

    DarwinBuildModifierMaps(info);

    return TRUE;
}

Bool
QuartsResyncKeymap(Bool sendDDXEvent)
{
    Bool retval;
    /* Update keyInfo */
    pthread_mutex_lock(&keyInfo_mutex);
    memset(keyInfo.keyMap, 0, sizeof(keyInfo.keyMap));
    retval = QuartzReadSystemKeymap(&keyInfo);
    pthread_mutex_unlock(&keyInfo_mutex);

    /* Tell server thread to deal with new keyInfo */
    if (sendDDXEvent)
        DarwinSendDDXEvent(kXquartzReloadKeymap, 0);

    return retval;
}
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d740 1
d786 1
@


1.6
log
@Update to xserver 1.11.2
@
text
@d4 1
a4 1
   Copyright (c) 2003-2008 Apple Inc.
d32 1
a32 1
*/
d40 2
a41 2
#define HACK_MISSING 1
#define HACK_KEYPAD 1
d87 26
a112 26
    {55,  XK_Meta_L},
    {56,  XK_Shift_L},
    {57,  XK_Caps_Lock},
    {58,  XK_Alt_L},
    {59,  XK_Control_L},

    {60,  XK_Shift_R},
    {61,  XK_Alt_R},
    {62,  XK_Control_R},
    {63,  XK_Meta_R},

    {122, XK_F1},
    {120, XK_F2},
    {99,  XK_F3},
    {118, XK_F4},
    {96,  XK_F5},
    {97,  XK_F6},
    {98,  XK_F7},
    {100, XK_F8},
    {101, XK_F9},
    {109, XK_F10},
    {103, XK_F11},
    {111, XK_F12},
    {105, XK_F13},
    {107, XK_F14},
    {113, XK_F15},
d124 17
a140 17
    {65, XK_period, XK_KP_Decimal},
    {67, XK_asterisk, XK_KP_Multiply},
    {69, XK_plus, XK_KP_Add},
    {75, XK_slash, XK_KP_Divide},
    {76, 0x01000003, XK_KP_Enter},
    {78, XK_minus, XK_KP_Subtract},
    {81, XK_equal, XK_KP_Equal},
    {82, XK_0, XK_KP_0},
    {83, XK_1, XK_KP_1},
    {84, XK_2, XK_KP_2},
    {85, XK_3, XK_KP_3},
    {86, XK_4, XK_KP_4},
    {87, XK_5, XK_KP_5},
    {88, XK_6, XK_KP_6},
    {89, XK_7, XK_KP_7},
    {91, XK_8, XK_KP_8},
    {92, XK_9, XK_KP_9},
d151 1
a151 1
const static unsigned short keycode_blacklist[] = {66, 70, 72, 77};
d160 24
a183 24
    {XK_grave, XK_dead_grave},
    {XK_apostrophe, XK_dead_acute},             /* US:"=" on a Czech keyboard */
    {XK_acute, XK_dead_acute},
    {UKEYSYM (0x384), XK_dead_acute},           /* US:";" on a Greek keyboard */
//    {XK_Greek_accentdieresis, XK_dead_diaeresis},   /* US:"opt+;" on a Greek keyboard ... replace with dead_accentdieresis if there is one */
    {XK_asciicircum, XK_dead_circumflex},
    {UKEYSYM (0x2c6), XK_dead_circumflex},	/* MODIFIER LETTER CIRCUMFLEX ACCENT */
    {XK_asciitilde, XK_dead_tilde},
    {UKEYSYM (0x2dc), XK_dead_tilde},		/* SMALL TILDE */
    {XK_macron, XK_dead_macron},
    {XK_breve, XK_dead_breve},
    {XK_abovedot, XK_dead_abovedot},
    {XK_diaeresis, XK_dead_diaeresis},
    {UKEYSYM (0x2da), XK_dead_abovering},	/* DOT ABOVE */
    {XK_doubleacute, XK_dead_doubleacute},
    {XK_caron, XK_dead_caron},
    {XK_cedilla, XK_dead_cedilla},
    {XK_ogonek, XK_dead_ogonek},
    {UKEYSYM (0x269), XK_dead_iota},		/* LATIN SMALL LETTER IOTA */
    {UKEYSYM (0x2ec), XK_dead_voiced_sound},	/* MODIFIER LETTER VOICING */
/*  {XK_semivoiced_sound, XK_dead_semivoiced_sound}, */
    {UKEYSYM (0x323), XK_dead_belowdot},	/* COMBINING DOT BELOW */
    {UKEYSYM (0x309), XK_dead_hook}, 		/* COMBINING HOOK ABOVE */
    {UKEYSYM (0x31b), XK_dead_horn},		/* COMBINING HORN */
d195 3
a197 1
static void DarwinChangeKeyboardControl(DeviceIntPtr device, KeybdCtrl *ctrl) {
d211 3
a213 1
static void DarwinBuildModifierMaps(darwinKeyboardInfo *info) {
d224 4
a227 4
            case XK_Shift_L:
                info->modifierKeycodes[NX_MODIFIERKEY_SHIFT][0] = i;
                info->modMap[MIN_KEYCODE + i] = ShiftMask;
                break;
d229 1
a229 1
            case XK_Shift_R:
d231 1
a231 1
                info->modifierKeycodes[NX_MODIFIERKEY_RSHIFT][0] = i;
d233 1
a233 1
                info->modifierKeycodes[NX_MODIFIERKEY_SHIFT][0] = i;
d235 2
a236 2
                info->modMap[MIN_KEYCODE + i] = ShiftMask;
                break;
d238 4
a241 4
            case XK_Control_L:
                info->modifierKeycodes[NX_MODIFIERKEY_CONTROL][0] = i;
                info->modMap[MIN_KEYCODE + i] = ControlMask;
                break;
d243 1
a243 1
            case XK_Control_R:
d245 1
a245 1
                info->modifierKeycodes[NX_MODIFIERKEY_RCONTROL][0] = i;
d247 1
a247 1
                info->modifierKeycodes[NX_MODIFIERKEY_CONTROL][0] = i;
d249 2
a250 2
                info->modMap[MIN_KEYCODE + i] = ControlMask;
                break;
d252 11
a262 11
            case XK_Caps_Lock:
                info->modifierKeycodes[NX_MODIFIERKEY_ALPHALOCK][0] = i;
                info->modMap[MIN_KEYCODE + i] = LockMask;
                break;

            case XK_Alt_L:
                info->modifierKeycodes[NX_MODIFIERKEY_ALTERNATE][0] = i;
                info->modMap[MIN_KEYCODE + i] = Mod1Mask;
                if(!XQuartzOptionSendsAlt)
                    *k = XK_Mode_switch; // Yes, this is ugly.  This needs to be cleaned up when we integrate quartzKeyboard with this code and refactor.
                break;
d264 1
a264 1
            case XK_Alt_R:
d266 1
a266 1
                info->modifierKeycodes[NX_MODIFIERKEY_RALTERNATE][0] = i;
d268 1
a268 1
                info->modifierKeycodes[NX_MODIFIERKEY_ALTERNATE][0] = i;
d270 9
a278 8
                if(!XQuartzOptionSendsAlt)
                    *k = XK_Mode_switch; // Yes, this is ugly.  This needs to be cleaned up when we integrate quartzKeyboard with this code and refactor.
                info->modMap[MIN_KEYCODE + i] = Mod1Mask;
                break;

            case XK_Mode_switch:
                ErrorF("DarwinBuildModifierMaps: XK_Mode_switch encountered, unable to determine side.\n");
                info->modifierKeycodes[NX_MODIFIERKEY_ALTERNATE][0] = i;
d280 1
a280 1
                info->modifierKeycodes[NX_MODIFIERKEY_RALTERNATE][0] = i;
d282 2
a283 2
                info->modMap[MIN_KEYCODE + i] = Mod1Mask;
                break;
d285 4
a288 4
            case XK_Meta_L:
                info->modifierKeycodes[NX_MODIFIERKEY_COMMAND][0] = i;
                info->modMap[MIN_KEYCODE + i] = Mod2Mask;
                break;
d290 1
a290 1
            case XK_Meta_R:
d292 1
a292 1
                info->modifierKeycodes[NX_MODIFIERKEY_RCOMMAND][0] = i;
d294 1
a294 1
                info->modifierKeycodes[NX_MODIFIERKEY_COMMAND][0] = i;
d296 2
a297 2
                info->modMap[MIN_KEYCODE + i] = Mod2Mask;
                break;
d299 3
a301 3
            case XK_Num_Lock:
                info->modMap[MIN_KEYCODE + i] = Mod3Mask;
                break;
d312 3
a314 1
void DarwinKeyboardInit(DeviceIntPtr pDev) {
d330 5
a334 2
static void DarwinKeyboardSetRepeat(DeviceIntPtr pDev, int initialKeyRepeatValue, int keyRepeatValue) {
    if(initialKeyRepeatValue == 300000) { // off
d337 2
a338 1
    } else {
d340 2
a341 2
        XkbControlsPtr      ctrl;
        XkbControlsRec      old;
d345 1
a345 1
        
d348 2
a349 2
        old= *ctrl;
        
d355 1
a355 1
        for(i=0; i < XkbPerKeyBitArraySize; i++)
d359 1
a359 1
        for(i=0; i < 32; i++) {
d361 1
a361 1
            
d363 1
a363 1
            if(keycode)
d367 1
a367 1
            if(keycode)
d373 2
a374 1
            memcpy(pDev->kbdfeed->ctrl.autoRepeats, ctrl->per_key_repeat, XkbPerKeyBitArraySize);
d385 3
a387 1
void DarwinKeyboardReloadHandler(void) {
d401 5
a405 3
    
    initialKeyRepeatValue = CFPreferencesGetAppIntegerValue(CFSTR("InitialKeyRepeat"), CFSTR(".GlobalPreferences"), &ok);
    if(!ok)
d407 7
a413 3
    
    keyRepeatValue = CFPreferencesGetAppIntegerValue(CFSTR("KeyRepeat"), CFSTR(".GlobalPreferences"), &ok);
    if(!ok)
d415 3
a417 2
    
    pthread_mutex_lock(&keyInfo_mutex); {
d420 1
a420 1
        keySyms.mapWidth   = GLYPHS_PER_KEY;
d424 1
a424 1
	// TODO: We should build the entire XkbDescRec and use XkbCopyKeymap
d429 2
a430 1
        DarwinKeyboardSetRepeat(darwinKeyboard, initialKeyRepeatValue, keyRepeatValue);
d434 9
a442 5
            if ((pDev->coreEvents || pDev == inputInfo.keyboard) && pDev->key) {
                XkbApplyMappingChange(pDev, &keySyms, keySyms.minKeyCode,
                                      keySyms.maxKeyCode - keySyms.minKeyCode + 1,
                                      keyInfo.modMap, serverClient);
                DarwinKeyboardSetRepeat(pDev, initialKeyRepeatValue, keyRepeatValue);    
d451 2
a452 1
            if(snprintf (cmd, sizeof(cmd), "%s %s", xmodmap, sysmodmap) < sizeof(cmd)) {
d454 4
a457 2
            } else {
                ErrorF("X11.app: Unable to create / execute xmodmap command line");
d462 3
a464 1
        if ((homedir != NULL) && (snprintf (usermodmap, sizeof(usermodmap), "%s/.Xmodmap", homedir) < sizeof(usermodmap))) {
d466 2
a467 1
                if(snprintf (cmd, sizeof(cmd), "%s %s", xmodmap, usermodmap) < sizeof(cmd)) {
d469 4
a472 2
                } else {
                    ErrorF("X11.app: Unable to create / execute xmodmap command line");
d475 2
a476 1
        } else {
d498 3
a500 1
int DarwinModifierNXKeyToNXKeycode(int key, int side) {
d514 3
a516 1
int DarwinModifierNXKeycodeToNXKey(unsigned char keycode, int *outSide) {
d542 3
a544 1
int DarwinModifierNXMaskToNXKey(int mask) {
d546 6
a551 2
        case NX_ALPHASHIFTMASK:       return NX_MODIFIERKEY_ALPHALOCK;
        case NX_SHIFTMASK:            return NX_MODIFIERKEY_SHIFT;
d553 6
a558 2
        case NX_DEVICELSHIFTKEYMASK:  return NX_MODIFIERKEY_SHIFT;
        case NX_DEVICERSHIFTKEYMASK:  return NX_MODIFIERKEY_RSHIFT;
d560 3
a562 1
        case NX_CONTROLMASK:          return NX_MODIFIERKEY_CONTROL;
d564 6
a569 2
        case NX_DEVICELCTLKEYMASK:    return NX_MODIFIERKEY_CONTROL;
        case NX_DEVICERCTLKEYMASK:    return NX_MODIFIERKEY_RCONTROL;
d571 3
a573 1
        case NX_ALTERNATEMASK:        return NX_MODIFIERKEY_ALTERNATE;
d575 6
a580 2
        case NX_DEVICELALTKEYMASK:    return NX_MODIFIERKEY_ALTERNATE;
        case NX_DEVICERALTKEYMASK:    return NX_MODIFIERKEY_RALTERNATE;
d582 3
a584 1
        case NX_COMMANDMASK:          return NX_MODIFIERKEY_COMMAND;
d586 6
a591 2
        case NX_DEVICELCMDKEYMASK:    return NX_MODIFIERKEY_COMMAND;
        case NX_DEVICERCMDKEYMASK:    return NX_MODIFIERKEY_RCOMMAND;
d593 8
a600 3
        case NX_NUMERICPADMASK:       return NX_MODIFIERKEY_NUMERICPAD;
        case NX_HELPMASK:             return NX_MODIFIERKEY_HELP;
        case NX_SECONDARYFNMASK:      return NX_MODIFIERKEY_SECONDARYFN;
d609 3
a611 1
int DarwinModifierNXKeyToNXMask(int key) {
d613 3
a615 1
        case NX_MODIFIERKEY_ALPHALOCK:   return NX_ALPHASHIFTMASK;
d617 24
a640 8
        case NX_MODIFIERKEY_SHIFT:       return NX_DEVICELSHIFTKEYMASK;
        case NX_MODIFIERKEY_RSHIFT:      return NX_DEVICERSHIFTKEYMASK;
        case NX_MODIFIERKEY_CONTROL:     return NX_DEVICELCTLKEYMASK;
        case NX_MODIFIERKEY_RCONTROL:    return NX_DEVICERCTLKEYMASK;
        case NX_MODIFIERKEY_ALTERNATE:   return NX_DEVICELALTKEYMASK;
        case NX_MODIFIERKEY_RALTERNATE:  return NX_DEVICERALTKEYMASK;
        case NX_MODIFIERKEY_COMMAND:     return NX_DEVICELCMDKEYMASK;
        case NX_MODIFIERKEY_RCOMMAND:    return NX_DEVICERCMDKEYMASK;
d642 21
a662 8
        case NX_MODIFIERKEY_SHIFT:       return NX_SHIFTMASK;
        case NX_MODIFIERKEY_CONTROL:     return NX_CONTROLMASK;
        case NX_MODIFIERKEY_ALTERNATE:   return NX_ALTERNATEMASK;
        case NX_MODIFIERKEY_COMMAND:     return NX_COMMANDMASK;
#endif
        case NX_MODIFIERKEY_NUMERICPAD:  return NX_NUMERICPADMASK;
        case NX_MODIFIERKEY_HELP:        return NX_HELPMASK;
        case NX_MODIFIERKEY_SECONDARYFN: return NX_SECONDARYFNMASK;
d671 3
a673 1
int DarwinModifierStringToNXMask(const char *str, int separatelr) {
d675 18
a692 8
    if(separatelr) {
        if (!strcasecmp(str, "shift"))    return NX_DEVICELSHIFTKEYMASK | NX_DEVICERSHIFTKEYMASK;
        if (!strcasecmp(str, "control"))  return NX_DEVICELCTLKEYMASK | NX_DEVICERCTLKEYMASK;
        if (!strcasecmp(str, "option"))   return NX_DEVICELALTKEYMASK | NX_DEVICERALTKEYMASK;
        if (!strcasecmp(str, "alt"))   return NX_DEVICELALTKEYMASK | NX_DEVICERALTKEYMASK;
        if (!strcasecmp(str, "command"))  return NX_DEVICELCMDKEYMASK | NX_DEVICERCMDKEYMASK;
        if (!strcasecmp(str, "lshift"))   return NX_DEVICELSHIFTKEYMASK;
        if (!strcasecmp(str, "rshift"))   return NX_DEVICERSHIFTKEYMASK;
d695 4
a698 4
        if (!strcasecmp(str, "loption"))  return NX_DEVICELALTKEYMASK;
        if (!strcasecmp(str, "roption"))  return NX_DEVICERALTKEYMASK;
        if (!strcasecmp(str, "lalt"))  return NX_DEVICELALTKEYMASK;
        if (!strcasecmp(str, "ralt"))  return NX_DEVICERALTKEYMASK;
d701 2
a702 1
    } else {
d704 15
a718 15
        if (!strcasecmp(str, "shift"))    return NX_SHIFTMASK;
        if (!strcasecmp(str, "control"))  return NX_CONTROLMASK;
        if (!strcasecmp(str, "option"))   return NX_ALTERNATEMASK;
        if (!strcasecmp(str, "alt"))   return NX_ALTERNATEMASK;
        if (!strcasecmp(str, "command"))  return NX_COMMANDMASK;
        if (!strcasecmp(str, "lshift"))   return NX_SHIFTMASK;
        if (!strcasecmp(str, "rshift"))   return NX_SHIFTMASK;
        if (!strcasecmp(str, "lcontrol")) return NX_CONTROLMASK;
        if (!strcasecmp(str, "rcontrol")) return NX_CONTROLMASK;
        if (!strcasecmp(str, "loption"))  return NX_ALTERNATEMASK;
        if (!strcasecmp(str, "roption"))  return NX_ALTERNATEMASK;
        if (!strcasecmp(str, "lalt"))  return NX_ALTERNATEMASK;
        if (!strcasecmp(str, "ralt"))  return NX_ALTERNATEMASK;
        if (!strcasecmp(str, "lcommand")) return NX_COMMANDMASK;
        if (!strcasecmp(str, "rcommand")) return NX_COMMANDMASK;
d720 1
a720 1
    }
d722 4
a725 4
    if (!strcasecmp(str, "lock"))     return NX_ALPHASHIFTMASK;
    if (!strcasecmp(str, "fn"))       return NX_SECONDARYFNMASK;
    if (!strcasecmp(str, "help"))     return NX_HELPMASK;
    if (!strcasecmp(str, "numlock"))  return NX_NUMERICPADMASK;
d734 2
a735 1
Bool LegalModifier(unsigned int key, DeviceIntPtr pDev)
d740 3
a742 1
static inline UniChar macroman2ucs(unsigned char c) {
d748 32
a779 16
        0xc4, 0xc5, 0xc7, 0xc9, 0xd1, 0xd6, 0xdc, 0xe1,
        0xe0, 0xe2, 0xe4, 0xe3, 0xe5, 0xe7, 0xe9, 0xe8,
        0xea, 0xeb, 0xed, 0xec, 0xee, 0xef, 0xf1, 0xf3,
        0xf2, 0xf4, 0xf6, 0xf5, 0xfa, 0xf9, 0xfb, 0xfc,
        0x2020, 0xb0, 0xa2, 0xa3, 0xa7, 0x2022, 0xb6, 0xdf,
        0xae, 0xa9, 0x2122, 0xb4, 0xa8, 0x2260, 0xc6, 0xd8,
        0x221e, 0xb1, 0x2264, 0x2265, 0xa5, 0xb5, 0x2202, 0x2211,
        0x220f, 0x3c0, 0x222b, 0xaa, 0xba, 0x3a9, 0xe6, 0xf8,
        0xbf, 0xa1, 0xac, 0x221a, 0x192, 0x2248, 0x2206, 0xab,
        0xbb, 0x2026, 0xa0, 0xc0, 0xc3, 0xd5, 0x152, 0x153,
        0x2013, 0x2014, 0x201c, 0x201d, 0x2018, 0x2019, 0xf7, 0x25ca,
        0xff, 0x178, 0x2044, 0x20ac, 0x2039, 0x203a, 0xfb01, 0xfb02,
        0x2021, 0xb7, 0x201a, 0x201e, 0x2030, 0xc2, 0xca, 0xc1,
        0xcb, 0xc8, 0xcd, 0xce, 0xcf, 0xcc, 0xd3, 0xd4,
        0xf8ff, 0xd2, 0xda, 0xdb, 0xd9, 0x131, 0x2c6, 0x2dc,
        0xaf, 0x2d8, 0x2d9, 0x2da, 0xb8, 0x2dd, 0x2db, 0x2c7,
d783 1
a783 1
    else         return table[c - 128];
d786 3
a788 1
static KeySym make_dead_key(KeySym in) {
d791 1
a791 1
    for (i = 0; i < sizeof (dead_keys) / sizeof (dead_keys[0]); i++)
d797 3
a799 1
static Bool QuartzReadSystemKeymap(darwinKeyboardInfo *info) {
d813 2
a814 1
    TISInputSourceRef currentKeyLayoutRef = TISCopyCurrentKeyboardLayoutInputSource();
d817 4
a820 3
      currentKeyLayoutDataRef = (CFDataRef )TISGetInputSourceProperty(currentKeyLayoutRef, kTISPropertyUnicodeKeyLayoutData);
      if (currentKeyLayoutDataRef)
          chr_data = CFDataGetBytePtr(currentKeyLayoutDataRef);
d832 6
a837 3
        ErrorF("X11.app: Error detected in determining keyboard layout.  If you are using an Apple-provided keyboard layout, please report this error at http://xquartz.macosforge.org and http://bugreport.apple.com\n");
        ErrorF("X11.app: Debug Info: keyboard_type=%u, currentKeyLayoutRef=%p, currentKeyLayoutDataRef=%p, chr_data=%p\n",
               (unsigned)keyboard_type, currentKeyLayoutRef, currentKeyLayoutDataRef, chr_data);
d840 2
a841 2
        KLGetCurrentKeyboardLayout (&key_layout);
        KLGetKeyboardLayoutProperty (key_layout, kKLuchrData, &chr_data);
d844 3
a846 2
        if(chr_data != NULL) {
            ErrorF("X11.app: Fallback succeeded, but this is still a bug.  Please report the above information.\n");
d852 5
a856 3
        ErrorF("X11.app: Debug Info: kKLuchrData failed, trying kKLKCHRData.\n");
        ErrorF("If you are using a 3rd party keyboard layout, please see http://xquartz.macosforge.org/trac/ticket/154\n");
        KLGetKeyboardLayoutProperty (key_layout, kKLKCHRData, &chr_data);
d859 1
a859 1
        
d861 3
a863 2
        if(chr_data != NULL) {
            ErrorF("X11.app: Fallback succeeded, but this is still a bug.  Please report the above information.\n");
d874 1
a874 1
    if(currentKeyLayoutRef)
d877 1
a877 1
    
d879 2
a880 2
      ErrorF ( "Couldn't get uchr or kchr resource\n");
      return FALSE;
d882 1
a882 1
    
d887 1
a887 1
       
d892 4
a895 2
        static const int mods[4] = {0, MOD_SHIFT, MOD_OPTION,
                                    MOD_OPTION | MOD_SHIFT};
d901 1
a901 1
            if (is_uchr)  {
d903 16
a918 7
                UniChar s[8];
                UniCharCount len;
                UInt32 dead_key_state = 0, extra_dead = 0;

                err = UCKeyTranslate (chr_data, i, kUCKeyActionDown,
                                      mods[j] >> 8, keyboard_type, 0,
                                      &dead_key_state, 8, &len, s);
d920 1
d922 7
a928 17
                if (len == 0 && dead_key_state != 0) {
                    /* Found a dead key. Work out which one it is, but
                       remembering that it's dead. */
                    err = UCKeyTranslate (chr_data, i, kUCKeyActionDown,
                                          mods[j] >> 8, keyboard_type,
                                          kUCKeyTranslateNoDeadKeysMask,
                                          &extra_dead, 8, &len, s);
                    if (err != noErr) continue;
                }

                /* Not sure why 0x0010 is there.
                 * 0x0000 - <rdar://problem/7793566> 'Unicode Hex Input' ...
                 */
                if (len > 0 && s[0] != 0x0010 && s[0] != 0x0000) {
                    k[j] = ucs2keysym (s[0]);
                    if (dead_key_state != 0) k[j] = make_dead_key (k[j]);
                }
d930 4
a933 3
            } else { // kchr
                UInt32 c, state = 0, state2 = 0;
                UInt16 code;
d935 1
a935 1
                code = i | mods[j];
d942 1
a942 1
                c = KeyTranslate (chr_data, code, &state);
d944 4
a947 4
                /* Dead keys are only processed on key-down, so ask
                   to translate those events. When we find a dead key,
                   translating the matching key up event will give
                   us the actual dead character. */
d949 2
a950 2
                if (state != 0)
                    c = KeyTranslate (chr_data, code | 128, &state2);
d956 1
a956 1
                /* Characters seem to be in MacRoman encoding. */
d958 2
a959 2
                if (c != 0 && c != 0x0010) {
                    k[j] = ucs2keysym (macroman2ucs (c & 255));
d961 1
a961 2
                    if (state != 0) k[j] = make_dead_key (k[j]);
                }
d963 1
d975 2
a976 2
    
    for (i = 0; i < sizeof (known_keys) / sizeof (known_keys[0]); i++) {
d978 2
a979 2
        
        if (   k[0] == NoSymbol && k[1] == NoSymbol
d984 1
a984 1
    
d987 3
a989 2
     keypad, but not the KP_ keysyms. So try to convert known keycodes. */
    for (i = 0; i < sizeof (known_numeric_keys) / sizeof (known_numeric_keys[0]); i++) {
d991 1
a991 1
        
d996 1
a996 1
    
d998 2
a999 1
    for (i = 0; i < sizeof (keycode_blacklist) / sizeof (keycode_blacklist[0]); i++) {
d1010 3
a1012 1
Bool QuartsResyncKeymap(Bool sendDDXEvent) {
d1021 1
a1021 1
    if(sendDDXEvent)
@


1.5
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@a58 7
#include "threadSafety.h"

#ifdef NDEBUG
#undef NDEBUG
#include <assert.h>
#define NDEBUG 1
#else
a59 1
#endif
d364 1
a364 1
        //fprintf(stderr, "per_key_repeat =\n");
d366 1
a366 1
        //    fprintf(stderr, "%02x%s", ctrl->per_key_repeat[i], (i + 1) & 7 ? "" : "\n");
d681 5
d719 4
d779 1
a779 1
	      UInt32 c, state = 0, state2 = 0;
d783 6
d798 4
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a55 1
#include "quartzAudio.h"
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d51 1
a51 1
#include "quartzCommon.h"
d265 1
a265 1
                if(!quartzOptionSendsAlt)
d275 1
a275 1
                if(!quartzOptionSendsAlt)
d430 1
a430 1
    /* Check for system .Xmodmap */
d432 1
d434 5
a438 2
            snprintf (cmd, sizeof(cmd), "%s %s", xmodmap, sysmodmap);
            X11ApplicationLaunchClient(cmd);
d440 12
a451 8
    }
        
    /* Check for user's local .Xmodmap */
    if (homedir != NULL) {
        snprintf (usermodmap, sizeof(usermodmap), "%s/.Xmodmap", homedir);
        if (access(usermodmap, F_OK) == 0) {
            snprintf (cmd, sizeof(cmd), "%s %s", xmodmap, usermodmap);
            X11ApplicationLaunchClient(cmd);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d42 1
d44 1
d53 1
d58 2
d76 3
d88 1
d123 1
d125 1
d151 11
d173 1
d195 6
d265 2
a266 1
                *k = XK_Mode_switch; // Yes, this is ugly.  This needs to be cleaned up when we integrate quartzKeyboard with this code and refactor.
d275 2
a276 1
                *k = XK_Mode_switch; // Yes, this is ugly.  This needs to be cleaned up when we integrate quartzKeyboard with this code and refactor.
d281 5
a310 44
 * DarwinLoadKeyboardMapping
 *  Load the keyboard map from a file or system and convert
 *  it to an equivalent X keyboard map and modifier map.
 */
static void DarwinLoadKeyboardMapping(KeySymsRec *keySyms) {
    pthread_mutex_lock(&keyInfo_mutex);
    
    DarwinBuildModifierMaps(&keyInfo);

    keySyms->map        = keyInfo.keyMap;
    keySyms->mapWidth   = GLYPHS_PER_KEY;
    keySyms->minKeyCode = MIN_KEYCODE;
    keySyms->maxKeyCode = MAX_KEYCODE;

    pthread_mutex_unlock(&keyInfo_mutex);
}

/*
 * DarwinKeyboardSetDeviceKeyMap
 * Load a keymap into the keyboard device
 */
static void DarwinKeyboardSetDeviceKeyMap(KeySymsRec *keySyms) {
    DeviceIntPtr pDev;

    /* From ProcSetModifierMapping */
    SendMappingNotify(darwinKeyboard, MappingModifier, 0, 0, serverClient);
    for (pDev = inputInfo.devices; pDev; pDev = pDev->next)
        if (pDev->key && pDev->coreEvents)
            SendDeviceMappingNotify(serverClient, MappingModifier, 0, 0, pDev);
    
    /* From ProcChangeKeyboardMapping */
    for (pDev = inputInfo.devices; pDev; pDev = pDev->next)
        if ((pDev->coreEvents || pDev == inputInfo.keyboard) && pDev->key)
            assert(SetKeySymsMap(&pDev->key->curKeySyms, keySyms));

    SendMappingNotify(darwinKeyboard, MappingKeyboard, keySyms->minKeyCode,
                      keySyms->maxKeyCode - keySyms->minKeyCode + 1, serverClient);
    for (pDev = inputInfo.devices; pDev; pDev = pDev->next)
        if (pDev->key && pDev->coreEvents)
            SendDeviceMappingNotify(serverClient, MappingKeyboard, keySyms->minKeyCode,
                                    keySyms->maxKeyCode - keySyms->minKeyCode + 1, pDev);    
}

/*
a316 5
    KeySymsRec keySyms;
    XkbComponentNamesRec names;
    CFIndex value;
    BOOL ok;

d322 1
a322 1
    DarwinLoadKeyboardMapping(&keySyms);
d324 1
a324 1
    bzero(&names, sizeof(names));
d326 2
a327 7
    /* We need to really have rules... or something... */
    //XkbSetRulesDflts("base", "pc105", "us", NULL, NULL);
    
    pthread_mutex_lock(&keyInfo_mutex);
    assert(XkbInitKeyboardDeviceStruct(pDev, &names, &keySyms, keyInfo.modMap,
                                       QuartzBell, DarwinChangeKeyboardControl));
    pthread_mutex_unlock(&keyInfo_mutex);
d329 6
a334 7
    /* Get our key repeat settings from GlobalPreferences */
    (void)CFPreferencesAppSynchronize(CFSTR(".GlobalPreferences"));
    value = CFPreferencesGetAppIntegerValue(CFSTR("InitialKeyRepeat"), CFSTR(".GlobalPreferences"), &ok);
    if(!ok)
        value = 35;

    if(value == 300000) { // off
d337 35
a371 1
        pDev->key->xkbInfo->desc->ctrls->repeat_delay = value * 15;
d373 3
a375 4
        value = CFPreferencesGetAppIntegerValue(CFSTR("KeyRepeat"), CFSTR(".GlobalPreferences"), &ok);
        if(!ok)
            value = 6;
        pDev->key->xkbInfo->desc->ctrls->repeat_interval = value * 15;
d377 2
a378 1
        XkbSetRepeatKeys(pDev, -1, AutoRepeatModeOn);
a379 2

    DarwinKeyboardSetDeviceKeyMap(&keySyms);
d382 1
a382 1
void DarwinKeyboardReloadHandler(int screenNum, xEventPtr xe, DeviceIntPtr pDev, int nevents) {
d384 7
d394 52
a445 2
    DarwinLoadKeyboardMapping(&keySyms);
    DarwinKeyboardSetDeviceKeyMap(&keySyms);
a480 1
    pthread_mutex_lock(&keyInfo_mutex);
d482 1
d484 1
d490 2
a492 1
        pthread_mutex_unlock(&keyInfo_mutex);
a496 1
    pthread_mutex_unlock(&keyInfo_mutex);
d659 1
a659 1
Bool QuartzReadSystemKeymap(darwinKeyboardInfo *info) {
d762 4
a765 1
                if (len > 0 && s[0] != 0x0010) {
d795 1
a795 1
	
a796 1
        if (k[2] == k[1]) k[2] = NoSymbol;
d799 1
d802 1
d804 27
d832 1
a832 9
    if (HACK_MISSING) {
        for (i = 0; i < sizeof (known_keys) / sizeof (known_keys[0]); i++) {
            k = info->keyMap + known_keys[i].keycode * GLYPHS_PER_KEY;

            if    (k[0] == NoSymbol && k[1] == NoSymbol
                && k[2] == NoSymbol && k[3] == NoSymbol)
	      k[0] = known_keys[i].keysym;
        }
    }
d834 2
a835 2
    /* And some more things. We find the right symbols for the numeric
       keypad, but not the KP_ keysyms. So try to convert known keycodes. */
d837 7
a843 4
    if (HACK_KEYPAD) {
        for (i = 0; i < sizeof (known_numeric_keys)
                        / sizeof (known_numeric_keys[0]); i++) {
            k = info->keyMap + known_numeric_keys[i].keycode * GLYPHS_PER_KEY;
d845 3
a847 4
            if (k[0] == known_numeric_keys[i].normal)
                k[0] = known_numeric_keys[i].keypad;
        }
    }
d849 1
a849 1
    return TRUE;
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d2 1
a2 1
   quartzKeyboard.c
d4 29
a32 3
   Code to build a keymap using the Carbon Keyboard Layout API.

   Copyright (c) 2003-2007 Apple Inc.
d34 1
a34 25
   Permission is hereby granted, free of charge, to any person
   obtaining a copy of this software and associated documentation files
   (the "Software"), to deal in the Software without restriction,
   including without limitation the rights to use, copy, modify, merge,
   publish, distribute, sublicense, and/or sell copies of the Software,
   and to permit persons to whom the Software is furnished to do so,
   subject to the following conditions:

   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT
   HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.

   Except as contained in this notice, the name(s) of the above
   copyright holders shall not be used in advertising or otherwise to
   promote the sale, use or other dealings in this Software without
   prior written authorization.
*/
d40 9
d50 1
d52 13
a64 2
#include <CoreServices/CoreServices.h>
#include <Carbon/Carbon.h>
d66 2
a67 1
#include "quartzKeyboard.h"
a70 3
#define HACK_MISSING 1
#define HACK_KEYPAD 1

d148 1
d150 1
d172 290
a461 4
unsigned int QuartzSystemKeymapSeed(void) {
    static unsigned int seed;
    static KeyboardLayoutRef last_key_layout;
    KeyboardLayoutRef key_layout;
d463 28
a490 3
    KLGetCurrentKeyboardLayout (&key_layout);
    if (key_layout != last_key_layout) seed++;
    last_key_layout = key_layout;
d492 57
a548 1
    return seed;
d589 1
d591 2
d595 2
a596 2
    UInt32 keyboard_type = 0;
    int is_uchr = 1, i, j;
d599 1
d601 1
d603 1
a603 1
    keyboard_type = LMGetKbdType ();
d605 3
a607 2
      CFDataRef currentKeyLayoutDataRef = (CFDataRef )TISGetInputSourceProperty(currentKeyLayoutRef, kTISPropertyUnicodeKeyLayoutData);
      if (currentKeyLayoutDataRef) chr_data = CFDataGetBytePtr(currentKeyLayoutDataRef);
d609 3
a611 1
    
d613 14
a626 2
      KLGetCurrentKeyboardLayout (&key_layout);
      KLGetKeyboardLayoutProperty (key_layout, kKLuchrData, &chr_data);
d628 1
a628 1
    
d630 11
a640 3
      KLGetKeyboardLayoutProperty (key_layout, kKLKCHRData, &chr_data);
      is_uchr = 0;
      num_keycodes = 128;
d642 6
d653 1
a653 1

d658 3
d669 1
d671 1
d695 1
d719 1
d752 1
a752 2
    if(currentKeyLayoutRef)	CFRelease(currentKeyLayoutRef);
    
@

