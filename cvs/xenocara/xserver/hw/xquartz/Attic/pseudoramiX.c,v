head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.05.02.19.27.50;	author matthieu;	state dead;
branches;
next	1.6;

1.6
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.29;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@/*
 * Minimal implementation of PanoramiX/Xinerama
 *
 * This is used in rootless mode where the underlying window server
 * already provides an abstracted view of multiple screens as one
 * large screen area.
 *
 * This code is largely based on panoramiX.c, which contains the
 * following copyright notice:
 */
/*****************************************************************
   Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.
   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software.

   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
   DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
   BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
   IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

   Except as contained in this notice, the name of Digital Equipment Corporation
   shall not be used in advertising or otherwise to promote the sale, use or other
   dealings in this Software without prior written authorization from Digital
   Equipment Corporation.
 ******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "pseudoramiX.h"
#include "extnsionst.h"
#include "extinit.h"
#include "dixstruct.h"
#include "window.h"
#include <X11/extensions/panoramiXproto.h>
#include "globals.h"

#define TRACE PseudoramiXTrace("TRACE " __FILE__ ":%s",__FUNCTION__)
#define DEBUG_LOG PseudoramiXDebug

Bool noPseudoramiXExtension = FALSE;

extern int
ProcPanoramiXQueryVersion(ClientPtr client);

static void
PseudoramiXResetProc(ExtensionEntry *extEntry);

static int
ProcPseudoramiXQueryVersion(ClientPtr client);
static int
ProcPseudoramiXGetState(ClientPtr client);
static int
ProcPseudoramiXGetScreenCount(ClientPtr client);
static int
ProcPseudoramiXGetScreenSize(ClientPtr client);
static int
ProcPseudoramiXIsActive(ClientPtr client);
static int
ProcPseudoramiXQueryScreens(ClientPtr client);
static int
ProcPseudoramiXDispatch(ClientPtr client);

static int
SProcPseudoramiXQueryVersion(ClientPtr client);
static int
SProcPseudoramiXGetState(ClientPtr client);
static int
SProcPseudoramiXGetScreenCount(ClientPtr client);
static int
SProcPseudoramiXGetScreenSize(ClientPtr client);
static int
SProcPseudoramiXIsActive(ClientPtr client);
static int
SProcPseudoramiXQueryScreens(ClientPtr client);
static int
SProcPseudoramiXDispatch(ClientPtr client);

typedef struct {
    int x;
    int y;
    int w;
    int h;
} PseudoramiXScreenRec;

static PseudoramiXScreenRec *pseudoramiXScreens = NULL;
static int pseudoramiXScreensAllocated = 0;
static int pseudoramiXNumScreens = 0;
static unsigned long pseudoramiXGeneration = 0;

static void
PseudoramiXTrace(const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    LogVMessageVerb(X_NONE, 10, format, ap);
    va_end(ap);
}

static void
PseudoramiXDebug(const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    LogVMessageVerb(X_NONE, 3, format, ap);
    va_end(ap);
}

// Add a PseudoramiX screen.
// The rest of the X server will know nothing about this screen.
// Can be called before or after extension init.
// Screens must be re-added once per generation.
void
PseudoramiXAddScreen(int x, int y, int w, int h)
{
    PseudoramiXScreenRec *s;

    if (noPseudoramiXExtension) return;

    if (pseudoramiXNumScreens == pseudoramiXScreensAllocated) {
        pseudoramiXScreensAllocated += pseudoramiXScreensAllocated + 1;
        pseudoramiXScreens = realloc(pseudoramiXScreens,
                                     pseudoramiXScreensAllocated *
                                     sizeof(PseudoramiXScreenRec));
    }

    DEBUG_LOG("x: %d, y: %d, w: %d, h: %d\n", x, y, w, h);

    s = &pseudoramiXScreens[pseudoramiXNumScreens++];
    s->x = x;
    s->y = y;
    s->w = w;
    s->h = h;
}

// Initialize PseudoramiX.
// Copied from PanoramiXExtensionInit
void
PseudoramiXExtensionInit(void)
{
    Bool success = FALSE;
    ExtensionEntry      *extEntry;

    if (noPseudoramiXExtension) return;

    TRACE;

    /* Even with only one screen we need to enable PseudoramiX to allow
       dynamic screen configuration changes. */
#if 0
    if (pseudoramiXNumScreens == 1) {
        // Only one screen - disable Xinerama extension.
        noPseudoramiXExtension = TRUE;
        return;
    }
#endif

    if (pseudoramiXGeneration != serverGeneration) {
        extEntry = AddExtension(PANORAMIX_PROTOCOL_NAME, 0, 0,
                                ProcPseudoramiXDispatch,
                                SProcPseudoramiXDispatch,
                                PseudoramiXResetProc,
                                StandardMinorOpcode);
        if (!extEntry) {
            ErrorF("PseudoramiXExtensionInit(): AddExtension failed\n");
        }
        else {
            pseudoramiXGeneration = serverGeneration;
            success = TRUE;
        }
    }

    if (!success) {
        ErrorF("%s Extension (PseudoramiX) failed to initialize\n",
               PANORAMIX_PROTOCOL_NAME);
        return;
    }
}

void
PseudoramiXResetScreens(void)
{
    TRACE;

    pseudoramiXNumScreens = 0;
}

static void
PseudoramiXResetProc(ExtensionEntry *extEntry)
{
    TRACE;

    PseudoramiXResetScreens();
}

// was PanoramiX
static int
ProcPseudoramiXQueryVersion(ClientPtr client)
{
    TRACE;

    return ProcPanoramiXQueryVersion(client);
}

// was PanoramiX
static int
ProcPseudoramiXGetState(ClientPtr client)
{
    REQUEST(xPanoramiXGetStateReq);
    WindowPtr pWin;
    xPanoramiXGetStateReply rep;
    register int rc;

    TRACE;

    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.state = !noPseudoramiXExtension;
    rep.window = stuff->window;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.window);
    }
    WriteToClient(client, sizeof(xPanoramiXGetStateReply),&rep);
    return Success;
}

// was PanoramiX
static int
ProcPseudoramiXGetScreenCount(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenCountReq);
    WindowPtr pWin;
    xPanoramiXGetScreenCountReply rep;
    register int rc;

    TRACE;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.ScreenCount = pseudoramiXNumScreens;
    rep.window = stuff->window;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.window);
    }
    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply),&rep);
    return Success;
}

// was PanoramiX
static int
ProcPseudoramiXGetScreenSize(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenSizeReq);
    WindowPtr pWin;
    xPanoramiXGetScreenSizeReply rep;
    register int rc;

    TRACE;

    if (stuff->screen >= pseudoramiXNumScreens)
      return BadMatch;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    /* screen dimensions */
    rep.width = pseudoramiXScreens[stuff->screen].w;
    // was screenInfo.screens[stuff->screen]->width;
    rep.height = pseudoramiXScreens[stuff->screen].h;
    // was screenInfo.screens[stuff->screen]->height;
    rep.window = stuff->window;
    rep.screen = stuff->screen;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.width);
        swapl(&rep.height);
        swapl(&rep.window);
        swapl(&rep.screen);
    }
    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply),&rep);
    return Success;
}

// was Xinerama
static int
ProcPseudoramiXIsActive(ClientPtr client)
{
    /* REQUEST(xXineramaIsActiveReq); */
    xXineramaIsActiveReply rep;

    TRACE;

    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.state = !noPseudoramiXExtension;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.state);
    }
    WriteToClient(client, sizeof(xXineramaIsActiveReply),&rep);
    return Success;
}

// was Xinerama
static int
ProcPseudoramiXQueryScreens(ClientPtr client)
{
    /* REQUEST(xXineramaQueryScreensReq); */
    xXineramaQueryScreensReply rep;

    DEBUG_LOG("noPseudoramiXExtension=%d, pseudoramiXNumScreens=%d\n",
              noPseudoramiXExtension,
              pseudoramiXNumScreens);

    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.number = noPseudoramiXExtension ? 0 : pseudoramiXNumScreens;
    rep.length = bytes_to_int32(rep.number * sz_XineramaScreenInfo);
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.number);
    }
    WriteToClient(client, sizeof(xXineramaQueryScreensReply),&rep);

    if (!noPseudoramiXExtension) {
        xXineramaScreenInfo scratch;
        int i;

        for (i = 0; i < pseudoramiXNumScreens; i++) {
            scratch.x_org = pseudoramiXScreens[i].x;
            scratch.y_org = pseudoramiXScreens[i].y;
            scratch.width = pseudoramiXScreens[i].w;
            scratch.height = pseudoramiXScreens[i].h;

            if (client->swapped) {
                swaps(&scratch.x_org);
                swaps(&scratch.y_org);
                swaps(&scratch.width);
                swaps(&scratch.height);
            }
            WriteToClient(client, sz_XineramaScreenInfo,&scratch);
        }
    }

    return Success;
}

// was PanoramiX
static int
ProcPseudoramiXDispatch(ClientPtr client)
{
    REQUEST(xReq);
    TRACE;
    switch (stuff->data) {
    case X_PanoramiXQueryVersion:
        return ProcPseudoramiXQueryVersion(client);

    case X_PanoramiXGetState:
        return ProcPseudoramiXGetState(client);

    case X_PanoramiXGetScreenCount:
        return ProcPseudoramiXGetScreenCount(client);

    case X_PanoramiXGetScreenSize:
        return ProcPseudoramiXGetScreenSize(client);

    case X_XineramaIsActive:
        return ProcPseudoramiXIsActive(client);

    case X_XineramaQueryScreens:
        return ProcPseudoramiXQueryScreens(client);
    }
    return BadRequest;
}

static int
SProcPseudoramiXQueryVersion(ClientPtr client)
{
    REQUEST(xPanoramiXQueryVersionReq);

    TRACE;

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xPanoramiXQueryVersionReq);
    return ProcPseudoramiXQueryVersion(client);
}

static int
SProcPseudoramiXGetState(ClientPtr client)
{
    REQUEST(xPanoramiXGetStateReq);

    TRACE;

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
    return ProcPseudoramiXGetState(client);
}

static int
SProcPseudoramiXGetScreenCount(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenCountReq);

    TRACE;

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
    return ProcPseudoramiXGetScreenCount(client);
}

static int
SProcPseudoramiXGetScreenSize(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenSizeReq);

    TRACE;

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
    return ProcPseudoramiXGetScreenSize(client);
}

static int
SProcPseudoramiXIsActive(ClientPtr client)
{
    REQUEST(xXineramaIsActiveReq);

    TRACE;

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
    return ProcPseudoramiXIsActive(client);
}

static int
SProcPseudoramiXQueryScreens(ClientPtr client)
{
    REQUEST(xXineramaQueryScreensReq);

    TRACE;

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
    return ProcPseudoramiXQueryScreens(client);
}

static int
SProcPseudoramiXDispatch(ClientPtr client)
{
    REQUEST(xReq);

    TRACE;

    switch (stuff->data) {
    case X_PanoramiXQueryVersion:
        return SProcPseudoramiXQueryVersion(client);

    case X_PanoramiXGetState:
        return SProcPseudoramiXGetState(client);

    case X_PanoramiXGetScreenCount:
        return SProcPseudoramiXGetScreenCount(client);

    case X_PanoramiXGetScreenSize:
        return SProcPseudoramiXGetScreenSize(client);

    case X_XineramaIsActive:
        return SProcPseudoramiXIsActive(client);

    case X_XineramaQueryScreens:
        return SProcPseudoramiXQueryScreens(client);
    }
    return BadRequest;
}
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a39 1
#include "darwin.h"
d42 1
d48 3
d101 20
d151 1
a151 1
PseudoramiXExtensionInit(int argc, char *argv[])
d158 1
a158 1
    TRACE();
d195 1
a195 1
    TRACE();
d203 1
a203 1
    TRACE();
d212 1
a212 1
    TRACE();
d226 1
a226 1
    TRACE();
d237 1
d241 1
a241 1
        swaps(&rep.state);
d243 1
a243 1
    WriteToClient(client, sizeof(xPanoramiXGetStateReply), (char *)&rep);
d256 1
a256 1
    TRACE();
d267 1
d271 1
a271 1
        swaps(&rep.ScreenCount);
d273 1
a273 1
    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), (char *)&rep);
d284 3
a286 1
    register int n, rc;
d288 2
a289 1
    TRACE();
d304 2
d309 4
a312 2
        swaps(&rep.width);
        swaps(&rep.height);
d314 1
a314 1
    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), (char *)&rep);
d325 1
a325 1
    TRACE();
d338 1
a338 1
    WriteToClient(client, sizeof(xXineramaIsActiveReply), (char *)&rep);
d364 1
a364 1
    WriteToClient(client, sizeof(xXineramaQueryScreensReply), (char *)&rep);
d382 1
a382 1
            WriteToClient(client, sz_XineramaScreenInfo, (char *)&scratch);
d394 1
a394 1
    TRACE();
d422 1
a422 1
    TRACE();
d434 1
a434 1
    TRACE();
d446 1
a446 1
    TRACE();
d458 1
a458 1
    TRACE();
d470 1
a470 1
    TRACE();
d482 1
a482 1
    TRACE();
d494 1
a494 1
    TRACE();
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d12 23
a34 23
Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.
******************************************************************/
d50 2
a51 1
extern int ProcPanoramiXQueryVersion (ClientPtr client);
d53 2
a54 1
static void PseudoramiXResetProc(ExtensionEntry *extEntry);
d56 14
a69 15
static int ProcPseudoramiXQueryVersion(ClientPtr client);
static int ProcPseudoramiXGetState(ClientPtr client);
static int ProcPseudoramiXGetScreenCount(ClientPtr client);
static int ProcPseudoramiXGetScreenSize(ClientPtr client);
static int ProcPseudoramiXIsActive(ClientPtr client);
static int ProcPseudoramiXQueryScreens(ClientPtr client);
static int ProcPseudoramiXDispatch(ClientPtr client);

static int SProcPseudoramiXQueryVersion(ClientPtr client);
static int SProcPseudoramiXGetState(ClientPtr client);
static int SProcPseudoramiXGetScreenCount(ClientPtr client);
static int SProcPseudoramiXGetScreenSize(ClientPtr client);
static int SProcPseudoramiXIsActive(ClientPtr client);
static int SProcPseudoramiXQueryScreens(ClientPtr client);
static int SProcPseudoramiXDispatch(ClientPtr client);
d71 14
a97 1

d112 2
a113 2
                                      pseudoramiXScreensAllocated *
                                      sizeof(PseudoramiXScreenRec));
a124 1

d127 2
a128 1
void PseudoramiXExtensionInit(int argc, char *argv[])
d130 2
a131 2
    Bool	     	success = FALSE;
    ExtensionEntry 	*extEntry;
d155 2
a156 1
        } else {
d169 2
a170 2

void PseudoramiXResetScreens(void)
d177 2
a178 2

static void PseudoramiXResetProc(ExtensionEntry *extEntry)
a184 1

d186 2
a187 1
static int ProcPseudoramiXQueryVersion(ClientPtr client)
a193 1

d195 2
a196 1
static int ProcPseudoramiXGetState(ClientPtr client)
d201 1
a201 1
    register int n, rc;
d204 1
a204 1
    
d208 1
a208 1
	return rc;
d215 3
a217 3
        swaps (&rep.sequenceNumber, n);
        swapl (&rep.length, n);
        swaps (&rep.state, n);
d219 1
a219 1
    WriteToClient (client, sizeof (xPanoramiXGetStateReply), (char *) &rep);
a222 1

d224 2
a225 1
static int ProcPseudoramiXGetScreenCount(ClientPtr client)
d230 1
a230 1
    register int n, rc;
d233 1
a233 1
    
d237 1
a237 1
	return rc;
d244 3
a246 3
        swaps (&rep.sequenceNumber, n);
        swapl (&rep.length, n);
        swaps (&rep.ScreenCount, n);
d248 1
a248 1
    WriteToClient (client, sizeof(xPanoramiXGetScreenCountReply), (char *)&rep);
a251 1

d253 2
a254 1
static int ProcPseudoramiXGetScreenSize(ClientPtr client)
d257 3
a259 3
    WindowPtr			pWin;
    xPanoramiXGetScreenSizeReply	rep;
    register int			n, rc;
d262 1
a262 1
    
d266 1
a266 1
	return rc;
d272 1
a272 1
    rep.width  = pseudoramiXScreens[stuff->screen].w;
d277 4
a280 4
        swaps (&rep.sequenceNumber, n);
        swapl (&rep.length, n);
        swaps (&rep.width, n);
        swaps (&rep.height, n);
d282 1
a282 1
    WriteToClient (client, sizeof(xPanoramiXGetScreenSizeReply), (char *)&rep);
a285 1

d287 2
a288 1
static int ProcPseudoramiXIsActive(ClientPtr client)
d291 1
a291 1
    xXineramaIsActiveReply	rep;
d294 1
a294 1
    
d302 3
a304 4
	register int n;
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swapl (&rep.state, n);
d306 1
a306 1
    WriteToClient (client, sizeof (xXineramaIsActiveReply), (char *) &rep);
a309 1

d311 2
a312 1
static int ProcPseudoramiXQueryScreens(ClientPtr client)
d315 5
a319 1
    xXineramaQueryScreensReply	rep;
a320 2
    DEBUG_LOG("noPseudoramiXExtension=%d, pseudoramiXNumScreens=%d\n", noPseudoramiXExtension, pseudoramiXNumScreens);
    
d328 3
a330 4
	register int n;
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swapl (&rep.number, n);
d332 1
a332 1
    WriteToClient (client, sizeof (xXineramaQueryScreensReply), (char *) &rep);
d335 2
a336 2
	xXineramaScreenInfo scratch;
	int i;
d338 14
a351 15
	for(i = 0; i < pseudoramiXNumScreens; i++) {
	    scratch.x_org  = pseudoramiXScreens[i].x;
	    scratch.y_org  = pseudoramiXScreens[i].y;
	    scratch.width  = pseudoramiXScreens[i].w;
	    scratch.height = pseudoramiXScreens[i].h;

	    if(client->swapped) {
		register int n;
		swaps (&scratch.x_org, n);
		swaps (&scratch.y_org, n);
		swaps (&scratch.width, n);
		swaps (&scratch.height, n);
	    }
	    WriteToClient (client, sz_XineramaScreenInfo, (char *) &scratch);
	}
a356 1

d358 4
a361 2
static int ProcPseudoramiXDispatch (ClientPtr client)
{   REQUEST(xReq);
d363 18
a380 14
    switch (stuff->data)
    {
	case X_PanoramiXQueryVersion:
	     return ProcPseudoramiXQueryVersion(client);
	case X_PanoramiXGetState:
	     return ProcPseudoramiXGetState(client);
	case X_PanoramiXGetScreenCount:
	     return ProcPseudoramiXGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return ProcPseudoramiXGetScreenSize(client);
	case X_XineramaIsActive:
	     return ProcPseudoramiXIsActive(client);
	case X_XineramaQueryScreens:
	     return ProcPseudoramiXQueryScreens(client);
a384 2


d386 1
a386 1
SProcPseudoramiXQueryVersion (ClientPtr client)
d388 1
a388 2
	REQUEST(xPanoramiXQueryVersionReq);
	register int n;
d392 3
a394 3
	swaps(&stuff->length,n);
	REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
	return ProcPseudoramiXQueryVersion(client);
d400 1
a400 2
	REQUEST(xPanoramiXGetStateReq);
	register int n;
d404 3
a406 3
 	swaps (&stuff->length, n);
	REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
	return ProcPseudoramiXGetState(client);
d412 1
a412 2
	REQUEST(xPanoramiXGetScreenCountReq);
	register int n;
d416 3
a418 3
	swaps (&stuff->length, n);
	REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
	return ProcPseudoramiXGetScreenCount(client);
d424 1
a424 2
	REQUEST(xPanoramiXGetScreenSizeReq);
	register int n;
d428 3
a430 3
	swaps (&stuff->length, n);
	REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
	return ProcPseudoramiXGetScreenSize(client);
a432 1

d436 1
a436 2
	REQUEST(xXineramaIsActiveReq);
	register int n;
d440 3
a442 3
	swaps (&stuff->length, n);
	REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
	return ProcPseudoramiXIsActive(client);
a444 1

d448 1
a448 2
	REQUEST(xXineramaQueryScreensReq);
	register int n;
d452 3
a454 3
	swaps (&stuff->length, n);
	REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
	return ProcPseudoramiXQueryScreens(client);
a456 1

d458 3
a460 2
SProcPseudoramiXDispatch (ClientPtr client)
{   REQUEST(xReq);
d464 18
a481 14
    switch (stuff->data)
    {
	case X_PanoramiXQueryVersion:
	     return SProcPseudoramiXQueryVersion(client);
	case X_PanoramiXGetState:
	     return SProcPseudoramiXGetState(client);
	case X_PanoramiXGetScreenCount:
	     return SProcPseudoramiXGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return SProcPseudoramiXGetScreenSize(client);
	case X_XineramaIsActive:
	     return SProcPseudoramiXIsActive(client);
	case X_XineramaQueryScreens:
	     return SProcPseudoramiXQueryScreens(client);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d97 1
a97 1
        pseudoramiXScreens = xrealloc(pseudoramiXScreens,
d205 1
a205 1
    return client->noClientException;
d234 1
a234 1
    return client->noClientException;
d258 1
a258 1
    // was panoramiXdataPtr[stuff->screen].width;
d260 1
a260 1
    // was panoramiXdataPtr[stuff->screen].height;
d268 1
a268 1
    return client->noClientException;
d293 1
a293 1
    return client->noClientException;
d340 1
a340 1
    return client->noClientException;
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d310 1
a310 1
    rep.length = rep.number * sz_XineramaScreenInfo >> 2;
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d40 1
a48 1
extern int noPanoramiXExtension;
d102 2
d121 2
a132 3
    // The server must not run the PanoramiX operations.
    noPanoramiXExtension = TRUE;

d157 2
d165 2
d174 2
d188 2
d217 2
d246 2
d278 2
d303 2
d347 1
d374 2
d387 2
d400 2
d413 2
d427 2
d441 2
d452 3
@

