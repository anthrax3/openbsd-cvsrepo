head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.16
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.14
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.12
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.10
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.8
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.54;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.21.20.10.48;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.09;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.09.06.19.44.35;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@/* main.c -- X application launcher
 * Copyright (c) 2007 Jeremy Huddleston
 * Copyright (c) 2007-2012 Apple Inc. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT
 * HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above
 * copyright holders shall not be used in advertising or otherwise to
 * promote the sale, use or other dealings in this Software without
 * prior written authorization.
 */

#include <CoreFoundation/CoreFoundation.h>
#include <AvailabilityMacros.h>

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/Xlib.h>
#include <assert.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <signal.h>

#ifdef HAVE_LIBDISPATCH
#include <dispatch/dispatch.h>
#else
#include <pthread.h>
#endif

#include <sys/socket.h>
#include <sys/un.h>

#include <fcntl.h>

#include <mach/mach.h>
#include <mach/mach_error.h>
#include <servers/bootstrap.h>
#include "mach_startup.h"
#include "mach_startupServer.h"

#include "console_redirect.h"

/* From darwinEvents.c ... but don't want to pull in all the server cruft */
void
DarwinListenOnOpenFD(int fd);

extern aslclient aslc;

/* Ditto, from os/log.c */
extern void
ErrorF(const char *f, ...) _X_ATTRIBUTE_PRINTF(1, 2);
extern void
FatalError(const char *f, ...) _X_ATTRIBUTE_PRINTF(1, 2) _X_NORETURN;

extern int noPanoramiXExtension;

#define DEFAULT_CLIENT X11BINDIR "/xterm"
#define DEFAULT_STARTX X11BINDIR "/startx -- " X11BINDIR "/Xquartz"
#define DEFAULT_SHELL  "/bin/sh"

#ifndef BUILD_DATE
#define BUILD_DATE ""
#endif
#ifndef XSERVER_VERSION
#define XSERVER_VERSION "?"
#endif

static char __crashreporter_info_buff__[4096] = { 0 };
static const char *__crashreporter_info__ __attribute__((__used__)) =
    &__crashreporter_info_buff__[0];
#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
// This is actually a toolchain requirement, but I'm not sure the correct check,
// but it should be fine to just only include it for Leopard and later.  This line
// just tells the linker to never strip this symbol (such as for space optimization)
asm (".desc ___crashreporter_info__, 0x10");
#endif

static const char *__crashreporter_info__base =
    "X.Org X Server " XSERVER_VERSION " Build Date: " BUILD_DATE;

char *bundle_id_prefix = NULL;
static char *server_bootstrap_name = NULL;

#define DEBUG 1

/* This is in quartzStartup.c */
int
server_main(int argc, char **argv, char **envp);

static int
execute(const char *command);
static char *
command_from_prefs(const char *key, const char *default_value);

static char *pref_app_to_run;
static char *pref_login_shell;
static char *pref_startx_script;

#ifndef HAVE_LIBDISPATCH
/*** Pthread Magics ***/
static pthread_t
create_thread(void *(*func)(void *), void *arg)
{
    pthread_attr_t attr;
    pthread_t tid;

    pthread_attr_init(&attr);
    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    pthread_create(&tid, &attr, func, arg);
    pthread_attr_destroy(&attr);

    return tid;
}
#endif

/*** Mach-O IPC Stuffs ***/

union MaxMsgSize {
    union __RequestUnion__mach_startup_subsystem req;
    union __ReplyUnion__mach_startup_subsystem rep;
};

static mach_port_t
checkin_or_register(char *bname)
{
    kern_return_t kr;
    mach_port_t mp;

    /* If we're started by launchd or the old mach_init */
    kr = bootstrap_check_in(bootstrap_port, bname, &mp);
    if (kr == KERN_SUCCESS)
        return mp;

    /* We probably were not started by launchd or the old mach_init */
    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &mp);
    if (kr != KERN_SUCCESS) {
        ErrorF("mach_port_allocate(): %s\n", mach_error_string(kr));
        exit(EXIT_FAILURE);
    }

    kr = mach_port_insert_right(
        mach_task_self(), mp, mp, MACH_MSG_TYPE_MAKE_SEND);
    if (kr != KERN_SUCCESS) {
        ErrorF("mach_port_insert_right(): %s\n", mach_error_string(kr));
        exit(EXIT_FAILURE);
    }

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations" // bootstrap_register
#endif
    kr = bootstrap_register(bootstrap_port, bname, mp);
#ifdef __clang__
#pragma clang diagnostic pop
#endif

    if (kr != KERN_SUCCESS) {
        ErrorF("bootstrap_register(): %s\n", mach_error_string(kr));
        exit(EXIT_FAILURE);
    }

    return mp;
}

/*** $DISPLAY handoff ***/
static int
accept_fd_handoff(int connected_fd)
{
    int launchd_fd;

    char databuf[] = "display";
    struct iovec iov[1];

    union {
        struct cmsghdr hdr;
        char bytes[CMSG_SPACE(sizeof(int))];
    } buf;

    struct msghdr msg;
    struct cmsghdr *cmsg;

    iov[0].iov_base = databuf;
    iov[0].iov_len = sizeof(databuf);

    msg.msg_iov = iov;
    msg.msg_iovlen = 1;
    msg.msg_control = buf.bytes;
    msg.msg_controllen = sizeof(buf);
    msg.msg_name = 0;
    msg.msg_namelen = 0;
    msg.msg_flags = 0;

    cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_level = SOL_SOCKET;
    cmsg->cmsg_type = SCM_RIGHTS;
    cmsg->cmsg_len = CMSG_LEN(sizeof(int));

    msg.msg_controllen = cmsg->cmsg_len;

    *((int *)CMSG_DATA(cmsg)) = -1;

    if (recvmsg(connected_fd, &msg, 0) < 0) {
        ErrorF(
            "X11.app: Error receiving $DISPLAY file descriptor.  recvmsg() error: %s\n",
            strerror(errno));
        return -1;
    }

    launchd_fd = *((int *)CMSG_DATA(cmsg));

    return launchd_fd;
}

typedef struct {
    int fd;
    string_t filename;
} socket_handoff_t;

/* This thread accepts an incoming connection and hands off the file
 * descriptor for the new connection to accept_fd_handoff()
 */
#ifdef HAVE_LIBDISPATCH
static void
socket_handoff(socket_handoff_t *handoff_data)
{
#else
static void *
socket_handoff_thread(void *arg)
{
    socket_handoff_t *handoff_data = (socket_handoff_t *)arg;
#endif

    int launchd_fd = -1;
    int connected_fd;

    /* Now actually get the passed file descriptor from this connection
     * If we encounter an error, keep listening.
     */
    while (launchd_fd == -1) {
        connected_fd = accept(handoff_data->fd, NULL, NULL);
        if (connected_fd == -1) {
            ErrorF(
                "X11.app: Failed to accept incoming connection on socket (fd=%d): %s\n",
                handoff_data->fd, strerror(errno));
            sleep(2);
            continue;
        }

        launchd_fd = accept_fd_handoff(connected_fd);
        if (launchd_fd == -1)
            ErrorF(
                "X11.app: Error receiving $DISPLAY file descriptor, no descriptor received?  Waiting for another connection.\n");

        close(connected_fd);
    }

    close(handoff_data->fd);
    unlink(handoff_data->filename);
    free(handoff_data);

    ErrorF(
        "X11.app Handing off fd to server thread via DarwinListenOnOpenFD(%d)\n",
        launchd_fd);
    DarwinListenOnOpenFD(launchd_fd);

#ifndef HAVE_LIBDISPATCH
    return NULL;
#endif
}

static int
create_socket(char *filename_out)
{
    struct sockaddr_un servaddr_un;
    struct sockaddr *servaddr;
    socklen_t servaddr_len;
    int ret_fd;
    size_t try, try_max;

    for (try = 0, try_max = 5; try < try_max; try++) {
        tmpnam(filename_out);

        /* Setup servaddr_un */
        memset(&servaddr_un, 0, sizeof(struct sockaddr_un));
        servaddr_un.sun_family = AF_UNIX;
        strlcpy(servaddr_un.sun_path, filename_out,
                sizeof(servaddr_un.sun_path));

        servaddr = (struct sockaddr *)&servaddr_un;
        servaddr_len = sizeof(struct sockaddr_un) -
                       sizeof(servaddr_un.sun_path) + strlen(filename_out);

        ret_fd = socket(PF_UNIX, SOCK_STREAM, 0);
        if (ret_fd == -1) {
            ErrorF(
                "X11.app: Failed to create socket (try %d / %d): %s - %s\n",
                (int)try + 1, (int)try_max, filename_out, strerror(errno));
            continue;
        }

        if (bind(ret_fd, servaddr, servaddr_len) != 0) {
            ErrorF("X11.app: Failed to bind socket: %d - %s\n", errno,
                   strerror(
                       errno));
            close(ret_fd);
            return 0;
        }

        if (listen(ret_fd, 10) != 0) {
            ErrorF("X11.app: Failed to listen to socket: %s - %d - %s\n",
                   filename_out, errno, strerror(
                       errno));
            close(ret_fd);
            return 0;
        }

#ifdef DEBUG
        ErrorF("X11.app: Listening on socket for fd handoff:  (%d) %s\n",
               ret_fd,
               filename_out);
#endif

        return ret_fd;
    }

    return 0;
}

static int launchd_socket_handed_off = 0;

kern_return_t
do_request_fd_handoff_socket(mach_port_t port, string_t filename)
{
    socket_handoff_t *handoff_data;

    launchd_socket_handed_off = 1;

    handoff_data = (socket_handoff_t *)calloc(1, sizeof(socket_handoff_t));
    if (!handoff_data) {
        ErrorF("X11.app: Error allocating memory for handoff_data\n");
        return KERN_FAILURE;
    }

    handoff_data->fd = create_socket(handoff_data->filename);
    if (!handoff_data->fd) {
        free(handoff_data);
        return KERN_FAILURE;
    }

    strlcpy(filename, handoff_data->filename, STRING_T_SIZE);

#ifdef HAVE_LIBDISPATCH
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,
                                             0), ^ {
                       socket_handoff(handoff_data);
                   });
#else
    create_thread(socket_handoff_thread, handoff_data);
#endif

#ifdef DEBUG
    ErrorF(
        "X11.app: Thread created for handoff.  Returning success to tell caller to connect and push the fd.\n");
#endif

    return KERN_SUCCESS;
}

kern_return_t
do_request_pid(mach_port_t port, int *my_pid)
{
    *my_pid = getpid();
    return KERN_SUCCESS;
}

/*** Server Startup ***/
kern_return_t
do_start_x11_server(mach_port_t port, string_array_t argv,
                    mach_msg_type_number_t argvCnt,
                    string_array_t envp,
                    mach_msg_type_number_t envpCnt)
{
    /* And now back to char ** */
    char **_argv = alloca((argvCnt + 1) * sizeof(char *));
    char **_envp = alloca((envpCnt + 1) * sizeof(char *));
    size_t i;

    /* If we didn't get handed a launchd DISPLAY socket, we should
     * unset DISPLAY or we can run into problems with pbproxy
     */
    if (!launchd_socket_handed_off) {
        ErrorF("X11.app: No launchd socket handed off, unsetting DISPLAY\n");
        unsetenv("DISPLAY");
    }

    if (!_argv || !_envp) {
        return KERN_FAILURE;
    }

    ErrorF("X11.app: do_start_x11_server(): argc=%d\n", argvCnt);
    for (i = 0; i < argvCnt; i++) {
        _argv[i] = argv[i];
        ErrorF("\targv[%u] = %s\n", (unsigned)i, argv[i]);
    }
    _argv[argvCnt] = NULL;

    for (i = 0; i < envpCnt; i++) {
        _envp[i] = envp[i];
    }
    _envp[envpCnt] = NULL;

    if (server_main(argvCnt, _argv, _envp) == 0)
        return KERN_SUCCESS;
    else
        return KERN_FAILURE;
}

static int
startup_trigger(int argc, char **argv, char **envp)
{
    Display *display;
    const char *s;

    /* Take care of the case where we're called like a normal DDX */
    if (argc > 1 && argv[1][0] == ':') {
        size_t i;
        kern_return_t kr;
        mach_port_t mp;
        string_array_t newenvp;
        string_array_t newargv;

        /* We need to count envp */
        int envpc;
        for (envpc = 0; envp[envpc]; envpc++) ;

        /* We have fixed-size string lengths due to limitations in IPC,
         * so we need to copy our argv and envp.
         */
        newargv = (string_array_t)alloca(argc * sizeof(string_t));
        newenvp = (string_array_t)alloca(envpc * sizeof(string_t));

        if (!newargv || !newenvp) {
            ErrorF("Memory allocation failure\n");
            exit(EXIT_FAILURE);
        }

        for (i = 0; i < argc; i++) {
            strlcpy(newargv[i], argv[i], STRING_T_SIZE);
        }
        for (i = 0; i < envpc; i++) {
            strlcpy(newenvp[i], envp[i], STRING_T_SIZE);
        }

        kr = bootstrap_look_up(bootstrap_port, server_bootstrap_name, &mp);
        if (kr != KERN_SUCCESS) {
#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
            ErrorF("bootstrap_look_up(%s): %s\n", server_bootstrap_name,
                   bootstrap_strerror(
                       kr));
#else
            ErrorF("bootstrap_look_up(%s): %ul\n", server_bootstrap_name,
                   (unsigned long)kr);
#endif
            exit(EXIT_FAILURE);
        }

        kr = start_x11_server(mp, newargv, argc, newenvp, envpc);
        if (kr != KERN_SUCCESS) {
            ErrorF("start_x11_server: %s\n", mach_error_string(kr));
            exit(EXIT_FAILURE);
        }
        exit(EXIT_SUCCESS);
    }

    /* If we have a process serial number and it's our only arg, act as if
     * the user double clicked the app bundle: launch app_to_run if possible
     */
    if (argc == 1 || (argc == 2 && !strncmp(argv[1], "-psn_", 5))) {
        /* Now, try to open a display, if so, run the launcher */
        display = XOpenDisplay(NULL);
        if (display) {
            /* Could open the display, start the launcher */
            XCloseDisplay(display);

            return execute(pref_app_to_run);
        }
    }

    /* Start the server */
    if ((s = getenv("DISPLAY"))) {
        ErrorF(
            "X11.app: Could not connect to server (DISPLAY=\"%s\", unsetting).  Starting X server.\n",
            s);
        unsetenv("DISPLAY");
    }
    else {
        ErrorF(
            "X11.app: Could not connect to server (DISPLAY is not set).  Starting X server.\n");
    }
    return execute(pref_startx_script);
}

/** Setup the environment we want our child processes to inherit */
static void
ensure_path(const char *dir)
{
    char buf[1024], *temp;

    /* Make sure /usr/X11/bin is in the $PATH */
    temp = getenv("PATH");
    if (temp == NULL || temp[0] == 0) {
        snprintf(buf, sizeof(buf),
                 "/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:%s",
                 dir);
        setenv("PATH", buf, TRUE);
    }
    else if (strnstr(temp, X11BINDIR, sizeof(temp)) == NULL) {
        snprintf(buf, sizeof(buf), "%s:%s", temp, dir);
        setenv("PATH", buf, TRUE);
    }
}

static void
setup_console_redirect(const char *bundle_id)
{
    char *asl_sender;
    char *asl_facility;

    asprintf(&asl_sender, "%s.server", bundle_id);
    assert(asl_sender);

    asl_facility = strdup(bundle_id);
    assert(asl_facility);
    if (strcmp(asl_facility + strlen(asl_facility) - 4, ".X11") == 0)
        asl_facility[strlen(asl_facility) - 4] = '\0';

    assert(aslc = asl_open(asl_sender, asl_facility, ASL_OPT_NO_DELAY));
    free(asl_sender);
    free(asl_facility);

    asl_set_filter(aslc, ASL_FILTER_MASK_UPTO(ASL_LEVEL_WARNING));

#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
# if MAC_OS_X_VERSION_MIN_REQUIRED < 1080
    if (asl_log_descriptor)
# endif
    {
        asl_log_descriptor(aslc, NULL, ASL_LEVEL_INFO, STDOUT_FILENO, ASL_LOG_DESCRIPTOR_WRITE);
        asl_log_descriptor(aslc, NULL, ASL_LEVEL_NOTICE, STDERR_FILENO, ASL_LOG_DESCRIPTOR_WRITE);
    }
# if MAC_OS_X_VERSION_MIN_REQUIRED < 1080
    else {
        xq_asl_capture_fd(aslc, NULL, ASL_LEVEL_INFO, STDOUT_FILENO);
        xq_asl_capture_fd(aslc, NULL, ASL_LEVEL_NOTICE, STDERR_FILENO);
    }
# endif
#else
    xq_asl_capture_fd(aslc, NULL, ASL_LEVEL_INFO, STDOUT_FILENO);
    xq_asl_capture_fd(aslc, NULL, ASL_LEVEL_NOTICE, STDERR_FILENO);
#endif
}

static void
setup_env(void)
{
    char *temp;
    const char *pds = NULL;
    const char *disp = getenv("DISPLAY");
    size_t len;

    /* Pass on our prefs domain to startx and its inheritors (mainly for
     * quartz-wm and the Xquartz stub's MachIPC)
     */
    CFBundleRef bundle = CFBundleGetMainBundle();
    if (bundle) {
        CFStringRef pd = CFBundleGetIdentifier(bundle);
        if (pd) {
            pds = CFStringGetCStringPtr(pd, 0);
        }
    }

    /* fallback to hardcoded value if we can't discover it */
    if (!pds) {
        pds = BUNDLE_ID_PREFIX ".X11";
    }

    setup_console_redirect(pds);

    server_bootstrap_name = strdup(pds);
    if (!server_bootstrap_name) {
        ErrorF("X11.app: Memory allocation error.\n");
        exit(1);
    }
    setenv("X11_PREFS_DOMAIN", server_bootstrap_name, 1);

    len = strlen(server_bootstrap_name);
    bundle_id_prefix = malloc(sizeof(char) * (len - 3));
    if (!bundle_id_prefix) {
        ErrorF("X11.app: Memory allocation error.\n");
        exit(1);
    }
    strlcpy(bundle_id_prefix, server_bootstrap_name, len - 3);

    /* We need to unset DISPLAY if it is not our socket */
    if (disp) {
        /* s = basename(disp) */
        const char *d, *s;
        for (s = NULL, d = disp; *d; d++) {
            if (*d == '/')
                s = d + 1;
        }

        if (s && *s) {
            if (strcmp(bundle_id_prefix,
                       "org.x") == 0 && strcmp(s, ":0") == 0) {
                ErrorF(
                    "X11.app: Detected old style launchd DISPLAY, please update xinit.\n");
            }
            else {
                temp = (char *)malloc(sizeof(char) * len);
                if (!temp) {
                    ErrorF(
                        "X11.app: Memory allocation error creating space for socket name test.\n");
                    exit(1);
                }
                strlcpy(temp, bundle_id_prefix, len);
                strlcat(temp, ":0", len);

                if (strcmp(temp, s) != 0) {
                    /* If we don't have a match, unset it. */
                    ErrorF(
                        "X11.app: DISPLAY (\"%s\") does not match our id (\"%s\"), unsetting.\n",
                        disp, bundle_id_prefix);
                    unsetenv("DISPLAY");
                }
                free(temp);
            }
        }
        else {
            /* The DISPLAY environment variable is not formatted like a launchd socket, so reset. */
            ErrorF(
                "X11.app: DISPLAY does not look like a launchd set variable, unsetting.\n");
            unsetenv("DISPLAY");
        }
    }

    /* Make sure PATH is right */
    ensure_path(X11BINDIR);

    /* cd $HOME */
    temp = getenv("HOME");
    if (temp != NULL && temp[0] != '\0')
        chdir(temp);
}

/*** Main ***/
int
main(int argc, char **argv, char **envp)
{
    Bool listenOnly = FALSE;
    int i;
    mach_msg_size_t mxmsgsz = sizeof(union MaxMsgSize) + MAX_TRAILER_SIZE;
    mach_port_t mp;
    kern_return_t kr;

    /* Setup our environment for our children */
    setup_env();

    /* The server must not run the PanoramiX operations. */
    noPanoramiXExtension = TRUE;

    /* Setup the initial crasherporter info */
    strlcpy(__crashreporter_info_buff__, __crashreporter_info__base,
            sizeof(__crashreporter_info_buff__));

    ErrorF("X11.app: main(): argc=%d\n", argc);
    for (i = 0; i < argc; i++) {
        ErrorF("\targv[%u] = %s\n", (unsigned)i, argv[i]);
        if (!strcmp(argv[i], "--listenonly")) {
            listenOnly = TRUE;
        }
    }

    mp = checkin_or_register(server_bootstrap_name);
    if (mp == MACH_PORT_NULL) {
        ErrorF("NULL mach service: %s", server_bootstrap_name);
        return EXIT_FAILURE;
    }

    /* Check if we need to do something other than listen, and make another
     * thread handle it.
     */
    if (!listenOnly) {
        pid_t child1, child2;
        int status;

        pref_app_to_run = command_from_prefs("app_to_run", DEFAULT_CLIENT);
        assert(pref_app_to_run);

        pref_login_shell = command_from_prefs("login_shell", DEFAULT_SHELL);
        assert(pref_login_shell);

        pref_startx_script = command_from_prefs("startx_script",
                                                DEFAULT_STARTX);
        assert(pref_startx_script);

        /* Do the fork-twice trick to avoid having to reap zombies */
        child1 = fork();
        switch (child1) {
        case -1:                                    /* error */
            FatalError("fork() failed: %s\n", strerror(errno));

        case 0:                                     /* child1 */
            child2 = fork();

            switch (child2) {
                int max_files;

            case -1:                                    /* error */
                FatalError("fork() failed: %s\n", strerror(errno));

            case 0:                                     /* child2 */
                /* close all open files except for standard streams */
                max_files = sysconf(_SC_OPEN_MAX);
                for (i = 3; i < max_files; i++)
                    close(i);

                /* ensure stdin is on /dev/null */
                close(0);
                open("/dev/null", O_RDONLY);

                return startup_trigger(argc, argv, envp);

            default:                                    /* parent (child1) */
                _exit(0);
            }
            break;

        default:                                    /* parent */
            waitpid(child1, &status, 0);
        }

        free(pref_app_to_run);
        free(pref_login_shell);
        free(pref_startx_script);
    }

    /* Main event loop */
    ErrorF("Waiting for startup parameters via Mach IPC.\n");
    kr = mach_msg_server(mach_startup_server, mxmsgsz, mp, 0);
    if (kr != KERN_SUCCESS) {
        ErrorF("%s.X11(mp): %s\n", BUNDLE_ID_PREFIX, mach_error_string(kr));
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

static int
execute(const char *command)
{
    const char *newargv[4];
    const char **p;

    newargv[0] = pref_login_shell;
    newargv[1] = "-c";
    newargv[2] = command;
    newargv[3] = NULL;

    ErrorF("X11.app: Launching %s:\n", command);
    for (p = newargv; *p; p++) {
        ErrorF("\targv[%ld] = %s\n", (long int)(p - newargv), *p);
    }

    execvp(newargv[0], (char *const *)newargv);
    perror("X11.app: Couldn't exec.");
    return 1;
}

static char *
command_from_prefs(const char *key, const char *default_value)
{
    char *command = NULL;

    CFStringRef cfKey;
    CFPropertyListRef PlistRef;

    if (!key)
        return NULL;

    cfKey = CFStringCreateWithCString(NULL, key, kCFStringEncodingASCII);

    if (!cfKey)
        return NULL;

    PlistRef = CFPreferencesCopyAppValue(cfKey,
                                         kCFPreferencesCurrentApplication);

    if ((PlistRef == NULL) ||
        (CFGetTypeID(PlistRef) != CFStringGetTypeID())) {
        CFStringRef cfDefaultValue = CFStringCreateWithCString(
            NULL, default_value, kCFStringEncodingASCII);
        int len = strlen(default_value) + 1;

        if (!cfDefaultValue)
            goto command_from_prefs_out;

        CFPreferencesSetAppValue(cfKey, cfDefaultValue,
                                 kCFPreferencesCurrentApplication);
        CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication);
        CFRelease(cfDefaultValue);

        command = (char *)malloc(len * sizeof(char));
        if (!command)
            goto command_from_prefs_out;
        strcpy(command, default_value);
    }
    else {
        int len = CFStringGetLength((CFStringRef)PlistRef) + 1;
        command = (char *)malloc(len * sizeof(char));
        if (!command)
            goto command_from_prefs_out;
        CFStringGetCString((CFStringRef)PlistRef, command, len,
                           kCFStringEncodingASCII);
    }

command_from_prefs_out:
    if (PlistRef)
        CFRelease(PlistRef);
    if (cfKey)
        CFRelease(cfKey);
    return command;
}
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d566 16
d584 1
@


1.5
log
@Update to xserver 1.11.2
@
text
@d2 28
a29 28
 
 Copyright (c) 2007 Jeremy Huddleston
 Copyright (c) 2007 Apple Inc
 
 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation files
 (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge,
 publish, distribute, sublicense, and/or sell copies of the Software,
 and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:
 
 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT
 HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 DEALINGS IN THE SOFTWARE.
 
 Except as contained in this notice, the name(s) of the above
 copyright holders shall not be used in advertising or otherwise to
 promote the sale, use or other dealings in this Software without
 prior written authorization. */
d67 2
a68 1
void DarwinListenOnOpenFD(int fd);
d73 4
a76 2
extern void ErrorF(const char *f, ...) _X_ATTRIBUTE_PRINTF(1,2);
extern void FatalError(const char *f, ...) _X_ATTRIBUTE_PRINTF(1,2) _X_NORETURN;
d81 1
a81 1
#define DEFAULT_STARTX X11BINDIR "/startx"
d91 3
a93 2
static char __crashreporter_info_buff__[4096] = {0};
static const char *__crashreporter_info__ __attribute__((__used__)) = &__crashreporter_info_buff__[0];
d101 2
a102 1
static const char *__crashreporter_info__base = "X.Org X Server " XSERVER_VERSION " Build Date: " BUILD_DATE;
d110 2
a111 1
int server_main(int argc, char **argv, char **envp);
d113 4
a116 2
static int execute(const char *command);
static char *command_from_prefs(const char *key, const char *default_value);
d124 3
a126 1
static pthread_t create_thread(void *(*func)(void *), void *arg) {
d129 7
a135 7
	
    pthread_attr_init (&attr);
    pthread_attr_setscope (&attr, PTHREAD_SCOPE_SYSTEM);
    pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);
    pthread_create (&tid, &attr, func, arg);
    pthread_attr_destroy (&attr);
	
d143 2
a144 2
	union __RequestUnion__mach_startup_subsystem req;
	union __ReplyUnion__mach_startup_subsystem rep; 
d147 3
a149 1
static mach_port_t checkin_or_register(char *bname) {
d165 2
a166 1
    kr = mach_port_insert_right(mach_task_self(), mp, mp, MACH_MSG_TYPE_MAKE_SEND);
d190 3
a192 1
static int accept_fd_handoff(int connected_fd) {
d194 1
a194 1
    
d197 1
a197 1
    
d202 1
a202 1
    
d207 2
a208 2
    iov[0].iov_len  = sizeof(databuf);
    
d216 2
a217 2
    
    cmsg = CMSG_FIRSTHDR (&msg);
d221 1
a221 1
    
d223 7
a229 5
    
    *((int*)CMSG_DATA(cmsg)) = -1;
    
    if(recvmsg(connected_fd, &msg, 0) < 0) {
        ErrorF("X11.app: Error receiving $DISPLAY file descriptor.  recvmsg() error: %s\n", strerror(errno));
d232 3
a234 3
    
    launchd_fd = *((int*)CMSG_DATA(cmsg));
    
d247 3
a249 1
static void socket_handoff(socket_handoff_t *handoff_data) {
d251 3
a253 1
static void *socket_handoff_thread(void *arg) {
d263 1
a263 1
    while(launchd_fd == -1) {
d265 4
a268 2
        if(connected_fd == -1) {
            ErrorF("X11.app: Failed to accept incoming connection on socket (fd=%d): %s\n", handoff_data->fd, strerror(errno));
d274 3
a276 2
        if(launchd_fd == -1)
            ErrorF("X11.app: Error receiving $DISPLAY file descriptor, no descriptor received?  Waiting for another connection.\n");
d284 4
a287 2
        
    ErrorF("X11.app Handing off fd to server thread via DarwinListenOnOpenFD(%d)\n", launchd_fd);
d295 3
a297 1
static int create_socket(char *filename_out) {
d303 2
a304 2
    
    for(try=0, try_max=5; try < try_max; try++) {
d306 1
a306 1
        
d308 1
a308 1
        memset (&servaddr_un, 0, sizeof (struct sockaddr_un));
d310 7
a316 5
        strlcpy(servaddr_un.sun_path, filename_out, sizeof(servaddr_un.sun_path));
        
        servaddr = (struct sockaddr *) &servaddr_un;
        servaddr_len = sizeof(struct sockaddr_un) - sizeof(servaddr_un.sun_path) + strlen(filename_out);
        
d318 4
a321 2
        if(ret_fd == -1) {
            ErrorF("X11.app: Failed to create socket (try %d / %d): %s - %s\n", (int)try+1, (int)try_max, filename_out, strerror(errno));
d324 5
a328 3
        
        if(bind(ret_fd, servaddr, servaddr_len) != 0) {
            ErrorF("X11.app: Failed to bind socket: %d - %s\n", errno, strerror(errno));
d332 5
a336 3
        
        if(listen(ret_fd, 10) != 0) {
            ErrorF("X11.app: Failed to listen to socket: %s - %d - %s\n", filename_out, errno, strerror(errno));
d340 1
a340 1
        
d342 3
a344 1
        ErrorF("X11.app: Listening on socket for fd handoff:  (%d) %s\n", ret_fd, filename_out);
d346 1
a346 1
        
d349 1
a349 1
    
d355 3
a357 1
kern_return_t do_request_fd_handoff_socket(mach_port_t port, string_t filename) {
d359 1
a359 1
    
d362 2
a363 2
    handoff_data = (socket_handoff_t *)calloc(1,sizeof(socket_handoff_t));
    if(!handoff_data) {
d369 1
a369 1
    if(!handoff_data->fd) {
d377 4
a380 3
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^{
        socket_handoff(handoff_data);
    });
d384 1
a384 1
    
d386 2
a387 1
    ErrorF("X11.app: Thread created for handoff.  Returning success to tell caller to connect and push the fd.\n");
d393 3
a395 1
kern_return_t do_request_pid(mach_port_t port, int *my_pid) {
d401 6
a406 4
kern_return_t do_start_x11_server(mach_port_t port, string_array_t argv,
                                  mach_msg_type_number_t argvCnt,
                                  string_array_t envp,
                                  mach_msg_type_number_t envpCnt) {
d411 1
a411 1
    
d415 1
a415 1
    if(!launchd_socket_handed_off) {
d419 2
a420 2
    
    if(!_argv || !_envp) {
d425 1
a425 1
    for(i=0; i < argvCnt; i++) {
d430 2
a431 2
    
    for(i=0; i < envpCnt; i++) {
d435 2
a436 2
    
    if(server_main(argvCnt, _argv, _envp) == 0)
d442 3
a444 1
static int startup_trigger(int argc, char **argv, char **envp) {
d447 1
a447 1
    
d449 1
a449 1
    if(argc > 1 && argv[1][0] == ':') {
d458 1
a458 1
        for(envpc=0; envp[envpc]; envpc++);
d465 2
a466 2
        
        if(!newargv || !newenvp) {
d470 2
a471 2
        
        for(i=0; i < argc; i++) {
d474 1
a474 1
        for(i=0; i < envpc; i++) {
d481 3
a483 1
            ErrorF("bootstrap_look_up(%s): %s\n", server_bootstrap_name, bootstrap_strerror(kr));
d485 2
a486 1
            ErrorF("bootstrap_look_up(%s): %ul\n", server_bootstrap_name, (unsigned long)kr);
d502 1
a502 1
    if(argc == 1 || (argc == 2 && !strncmp(argv[1], "-psn_", 5))) {
d505 1
a505 1
        if(display) {
d514 4
a517 2
    if((s = getenv("DISPLAY"))) {
        ErrorF("X11.app: Could not connect to server (DISPLAY=\"%s\", unsetting).  Starting X server.\n", s);
d519 4
a522 2
    } else {
        ErrorF("X11.app: Could not connect to server (DISPLAY is not set).  Starting X server.\n");
d528 3
a530 1
static void ensure_path(const char *dir) {
d532 1
a532 1
    
d535 4
a538 2
    if(temp == NULL || temp[0] == 0) {
        snprintf(buf, sizeof(buf), "/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:%s", dir);
d540 2
a541 1
    } else if(strnstr(temp, X11BINDIR, sizeof(temp)) == NULL) {
d547 3
a549 1
static void setup_console_redirect(const char *bundle_id) {
d558 1
a558 1
    if(strcmp(asl_facility + strlen(asl_facility) - 4, ".X11") == 0)
d570 3
a572 1
static void setup_env(void) {
d582 1
a582 1
    if(bundle) {
d584 1
a584 1
        if(pd) {
d590 2
a591 2
    if(!pds) {
        pds = BUNDLE_ID_PREFIX".X11";
d597 1
a597 1
    if(!server_bootstrap_name) {
d602 1
a602 1
    
d605 1
a605 1
    if(!bundle_id_prefix) {
d610 1
a610 1
    
d612 1
a612 1
    if(disp) {
d615 2
a616 2
	    for(s = NULL, d = disp; *d; d++) {
            if(*d == '/')
d620 7
a626 4
        if(s && *s) {
            if(strcmp(bundle_id_prefix, "org.x") == 0 && strcmp(s, ":0") == 0) {
                ErrorF("X11.app: Detected old style launchd DISPLAY, please update xinit.\n");
            } else {
d628 3
a630 2
                if(!temp) {
                    ErrorF("X11.app: Memory allocation error creating space for socket name test.\n");
d635 2
a636 2
            
                if(strcmp(temp, s) != 0) {
d638 3
a640 1
                    ErrorF("X11.app: DISPLAY (\"%s\") does not match our id (\"%s\"), unsetting.\n", disp, bundle_id_prefix);
d645 2
a646 1
        } else {
d648 2
a649 1
            ErrorF("X11.app: DISPLAY does not look like a launchd set variable, unsetting.\n");
d656 1
a656 1
    
d659 1
a659 1
    if(temp != NULL && temp[0] != '\0')
d664 3
a666 1
int main(int argc, char **argv, char **envp) {
d675 1
a675 1
    
d680 3
a682 2
    strlcpy(__crashreporter_info_buff__, __crashreporter_info__base, sizeof(__crashreporter_info_buff__));
    
d684 1
a684 1
    for(i=0; i < argc; i++) {
d686 1
a686 1
        if(!strcmp(argv[i], "--listenonly")) {
d692 1
a692 1
    if(mp == MACH_PORT_NULL) {
d696 1
a696 1
    
d700 1
a700 1
    if(!listenOnly) {
d710 2
a711 1
        pref_startx_script = command_from_prefs("startx_script", DEFAULT_STARTX);
d717 2
a718 2
            case -1:                                /* error */
                FatalError("fork() failed: %s\n", strerror(errno));
d720 2
a721 2
            case 0:                                 /* child1 */
                child2 = fork();
d723 2
a724 2
                switch (child2) {
                    int max_files;
d726 2
a727 2
                    case -1:                            /* error */
                        FatalError("fork() failed: %s\n", strerror(errno));
d729 9
a737 5
                    case 0:                             /* child2 */
                        /* close all open files except for standard streams */
                        max_files = sysconf(_SC_OPEN_MAX);
                        for(i = 3; i < max_files; i++)
                            close(i);
d739 1
a739 3
                        /* ensure stdin is on /dev/null */
                        close(0);
                        open("/dev/null", O_RDONLY);
d741 4
a744 1
                        return startup_trigger(argc, argv, envp);
d746 2
a747 7
                    default:                            /* parent (child1) */
                        _exit(0);
                }
                break;

            default:                                /* parent */
              waitpid(child1, &status, 0);
d754 1
a754 1
    
d762 1
a762 1
    
d766 3
a768 1
static int execute(const char *command) {
d771 1
a771 1
    
d776 1
a776 1
    
d778 1
a778 1
    for(p=newargv; *p; p++) {
d782 2
a783 2
    execvp (newargv[0], (char * const *) newargv);
    perror ("X11.app: Couldn't exec.");
d787 3
a789 1
static char *command_from_prefs(const char *key, const char *default_value) {
d791 1
a791 1
    
d795 1
a795 1
    if(!key)
d800 1
a800 1
    if(!cfKey)
d803 7
a809 4
    PlistRef = CFPreferencesCopyAppValue(cfKey, kCFPreferencesCurrentApplication);
    
    if ((PlistRef == NULL) || (CFGetTypeID(PlistRef) != CFStringGetTypeID())) {
        CFStringRef cfDefaultValue = CFStringCreateWithCString(NULL, default_value, kCFStringEncodingASCII);
d812 1
a812 1
        if(!cfDefaultValue)
d815 2
a816 1
        CFPreferencesSetAppValue(cfKey, cfDefaultValue, kCFPreferencesCurrentApplication);
d819 1
a819 1
        
d821 1
a821 1
        if(!command)
d824 2
a825 1
    } else {
d828 1
a828 1
        if(!command)
d830 2
a831 1
        CFStringGetCString((CFStringRef)PlistRef, command, len,  kCFStringEncodingASCII);
d837 1
a837 1
    if(cfKey)
@


1.4
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d39 1
a43 1
#include <pthread.h>
d47 6
a55 1
#include <sys/time.h>
d64 2
a65 1
#include "launchd_fd.h"
d69 6
d99 1
a99 1
static char *launchd_id_prefix = NULL;
d110 5
d116 1
a116 1
static pthread_t create_thread(void *func, void *arg) {
d128 1
d149 1
a149 1
        fprintf(stderr, "mach_port_allocate(): %s\n", mach_error_string(kr));
d155 1
a155 1
        fprintf(stderr, "mach_port_insert_right(): %s\n", mach_error_string(kr));
d159 4
d164 4
d169 1
a169 1
        fprintf(stderr, "bootstrap_register(): %s\n", mach_error_string(kr));
d212 1
a212 1
        fprintf(stderr, "X11.app: Error receiving $DISPLAY file descriptor.  recvmsg() error: %s\n", strerror(errno));
d229 4
a232 1
static void socket_handoff_thread(void *arg) {
d234 2
a237 1
    unsigned remain;
d245 1
a245 1
            fprintf(stderr, "X11.app: Failed to accept incoming connection on socket (fd=%d): %s\n", handoff_data->fd, strerror(errno));
d252 1
a252 1
            fprintf(stderr, "X11.app: Error receiving $DISPLAY file descriptor, no descriptor received?  Waiting for another connection.\n");
d260 2
a261 15
    
    /* TODO: Clean up this race better... giving xinitrc time to run... need to wait for 1.5 branch:
     *
     * From ajax:
     * There's already an internal callback chain for setting selection [in 1.5]
     * ownership.  See the CallSelectionCallback at the bottom of
     * ProcSetSelectionOwner, and xfixes/select.c for an example of how to hook
     * into it.
     */
    
    remain = 3000000;
    fprintf(stderr, "X11.app: Received new $DISPLAY fd: %d ... sleeping to allow xinitrc to catchup.\n", launchd_fd);
    while((remain = usleep(remain)) > 0);
    
    fprintf(stderr, "X11.app Handing off fd to server thread via DarwinListenOnOpenFD(%d)\n", launchd_fd);
d263 4
d289 1
a289 1
            fprintf(stderr, "X11.app: Failed to create socket (try %d / %d): %s - %s\n", (int)try+1, (int)try_max, filename_out, strerror(errno));
d294 1
a294 1
            fprintf(stderr, "X11.app: Failed to bind socket: %d - %s\n", errno, strerror(errno));
d300 1
a300 1
            fprintf(stderr, "X11.app: Failed to listen to socket: %s - %d - %s\n", filename_out, errno, strerror(errno));
d306 1
a306 1
        fprintf(stderr, "X11.app: Listening on socket for fd handoff:  (%d) %s\n", ret_fd, filename_out);
d324 1
a324 1
        fprintf(stderr, "X11.app: Error allocating memory for handoff_data\n");
d335 6
a340 1
    
d342 1
d345 1
a345 1
    fprintf(stderr, "X11.app: Thread created for handoff.  Returning success to tell caller to connect and push the fd.\n");
d370 1
a370 1
        fprintf(stderr, "X11.app: No launchd socket handed off, unsetting DISPLAY\n");
d378 1
a378 1
    fprintf(stderr, "X11.app: do_start_x11_server(): argc=%d\n", argvCnt);
d381 1
a381 1
        fprintf(stderr, "\targv[%u] = %s\n", (unsigned)i, argv[i]);
d419 1
a419 1
            fprintf(stderr, "Memory allocation failure\n");
d433 1
a433 1
            fprintf(stderr, "bootstrap_look_up(%s): %s\n", server_bootstrap_name, bootstrap_strerror(kr));
d435 1
a435 1
            fprintf(stderr, "bootstrap_look_up(%s): %ul\n", server_bootstrap_name, (unsigned long)kr);
d442 1
a442 1
            fprintf(stderr, "start_x11_server: %s\n", mach_error_string(kr));
d458 1
a458 1
            return execute(command_from_prefs("app_to_run", DEFAULT_CLIENT));
d464 1
a464 1
        fprintf(stderr, "X11.app: Could not connect to server (DISPLAY=\"%s\", unsetting).  Starting X server.\n", s);
d467 1
a467 1
        fprintf(stderr, "X11.app: Could not connect to server (DISPLAY is not set).  Starting X server.\n");
d469 1
a469 1
    return execute(command_from_prefs("startx_script", DEFAULT_STARTX));
d487 21
d527 1
a527 1
        pds = LAUNCHD_ID_PREFIX".X11";
d530 3
a532 1
    server_bootstrap_name = malloc(sizeof(char) * (strlen(pds) + 1));
d534 1
a534 1
        fprintf(stderr, "X11.app: Memory allocation error.\n");
a536 1
    strcpy(server_bootstrap_name, pds);
d540 3
a542 3
    launchd_id_prefix = malloc(sizeof(char) * (len - 3));
    if(!launchd_id_prefix) {
        fprintf(stderr, "X11.app: Memory allocation error.\n");
d545 1
a545 1
    strlcpy(launchd_id_prefix, server_bootstrap_name, len - 3);
d557 2
a558 2
            if(strcmp(launchd_id_prefix, "org.x") == 0 && strcmp(s, ":0") == 0) {
                fprintf(stderr, "X11.app: Detected old style launchd DISPLAY, please update xinit.\n");
d562 1
a562 1
                    fprintf(stderr, "X11.app: Memory allocation error creating space for socket name test.\n");
d565 1
a565 1
                strlcpy(temp, launchd_id_prefix, len);
d570 1
a570 1
                    fprintf(stderr, "X11.app: DISPLAY (\"%s\") does not match our id (\"%s\"), unsetting.\n", disp, launchd_id_prefix);
d577 1
a577 1
            fprintf(stderr, "X11.app: DISPLAY does not look like a launchd set variable, unsetting.\n");
d608 1
a608 1
    fprintf(stderr, "X11.app: main(): argc=%d\n", argc);
d610 1
a610 1
        fprintf(stderr, "\targv[%u] = %s\n", (unsigned)i, argv[i]);
d618 1
a618 1
        fprintf(stderr, "NULL mach service: %s", server_bootstrap_name);
d629 9
d642 1
a642 1
                break;
d648 1
a648 1
                    int max_files, i;
d651 1
a651 1
                        break;
d673 4
d680 1
a680 1
    fprintf(stderr, "Waiting for startup parameters via Mach IPC.\n");
d683 1
a683 1
        fprintf(stderr, "%s.X11(mp): %s\n", LAUNCHD_ID_PREFIX, mach_error_string(kr));
d694 1
a694 1
    newargv[0] = command_from_prefs("login_shell", DEFAULT_SHELL);
d699 1
a699 1
    fprintf(stderr, "X11.app: Launching %s:\n", command);
d701 1
a701 1
        fprintf(stderr, "\targv[%ld] = %s\n", (long int)(p - newargv), *p);
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d77 1
a77 1
static const char *__crashreporter_info__ = &__crashreporter_info_buff__[0];
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d644 1
a644 1
    return(1);
@


1.1
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d34 4
d51 1
a64 2
extern int xquartz_resetenv_display;

d76 8
a83 4
const int __crashreporter_info__len = 4096;
const char *__crashreporter_info__base = "X.Org X Server " XSERVER_VERSION " Build Date: " BUILD_DATE;
char __crashreporter_info__buf[4096];
char *__crashreporter_info__ = __crashreporter_info__buf;
d85 4
a88 1
static char *server_bootstrap_name = "org.x.X11";
a156 3
    iov[0].iov_base = databuf;
    iov[0].iov_len  = sizeof(databuf);
    
d163 5
d176 1
a176 1
    struct cmsghdr *cmsg = CMSG_FIRSTHDR (&msg);
d207 1
d240 1
a240 1
    unsigned remain = 3000000;
d309 1
d339 1
a339 1
    /* If we didn't get handed a launchd DISPLAY socket, we shoul
d342 2
a343 1
    if(!launchd_socket_handed_off)
d345 1
d369 1
a369 1
int startup_trigger(int argc, char **argv, char **envp) {
d406 1
a406 1
            fprintf(stderr, "bootstrap_look_up(): %s\n", bootstrap_strerror(kr));
d408 1
a408 1
            fprintf(stderr, "bootstrap_look_up(): %ul\n", (unsigned long)kr);
a438 3
        
        /* This tells X11Controller to not use the environment's DISPLAY and reset it based on the server's display */
        xquartz_resetenv_display = 1;
d460 1
a460 1
static void setup_env() {
d463 2
d474 51
a524 4
            if(pds) {
                server_bootstrap_name = malloc(sizeof(char) * (strlen(pds) + 1));
                strcpy(server_bootstrap_name, pds);
                setenv("X11_PREFS_DOMAIN", pds, 1);
d526 4
a532 6
    /* If we're not org.x.X11, we want to unset DISPLAY, so we don't
     * use the launchd DISPLAY socket.
     */
    if(pds == NULL || strcmp(pds, "org.x.X11") != 0)
        unsetenv("DISPLAY");

d557 1
a557 1
    strlcpy(__crashreporter_info__, __crashreporter_info__base, __crashreporter_info__len);
d577 37
a613 2
        if(fork() == 0) {
            return startup_trigger(argc, argv, envp);
d621 1
a621 1
        fprintf(stderr, "org.x.X11(mp): %s\n", mach_error_string(kr));
d650 12
a661 2
    CFStringRef cfKey = CFStringCreateWithCString(NULL, key, kCFStringEncodingASCII);
    CFPropertyListRef PlistRef = CFPreferencesCopyAppValue(cfKey, kCFPreferencesCurrentApplication);
d665 4
d672 1
a673 1
        int len = strlen(default_value) + 1;
d676 1
a676 1
            return NULL;
d682 1
a682 1
            return NULL;
d684 3
a686 2
	}
    
d689 2
a690 1
    
@

