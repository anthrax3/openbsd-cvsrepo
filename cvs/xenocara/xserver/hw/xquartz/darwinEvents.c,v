head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.7.0.14
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.12
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.10
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.8
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	7pAEtF6Y5EgemkuY;

1.8
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.53;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.02.16.08.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.29;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Darwin event queue and event handling
 *
 * Copyright 2007-2008 Apple Inc.
 * Copyright 2004 Kaleb S. KEITHLEY. All Rights Reserved.
 * Copyright (c) 2002-2004 Torrey T. Lyons. All Rights Reserved.
 *
 * This file is based on mieq.c by Keith Packard,
 * which contains the following copyright:
 * Copyright 1990, 1998  The Open Group
 *
 *
 * Copyright (c) 2002-2012 Apple Inc. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT
 * HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above
 * copyright holders shall not be used in advertising or otherwise to
 * promote the sale, use or other dealings in this Software without
 * prior written authorization.
 */

#include "sanitizedCarbon.h"

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xmd.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "inputstr.h"
#include "inpututils.h"
#include "eventstr.h"
#include "mi.h"
#include "scrnintstr.h"
#include "mipointer.h"
#include "os.h"
#include "exglobals.h"

#include "darwin.h"
#include "quartz.h"
#include "quartzKeyboard.h"
#include "quartzRandR.h"
#include "darwinEvents.h"

#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>
#include <pthread.h>
#include <errno.h>
#include <time.h>

#include <IOKit/hidsystem/IOLLEvent.h>

#include <X11/extensions/applewmconst.h>
#include "applewmExt.h"

/* FIXME: Abstract this better */
extern Bool
QuartzModeEventHandler(int screenNum, XQuartzEvent *e, DeviceIntPtr dev);

int darwin_all_modifier_flags = 0;  // last known modifier state
int darwin_all_modifier_mask = 0;
int darwin_x11_modifier_mask = 0;

#define FD_ADD_MAX 128
static int fd_add[FD_ADD_MAX];
int fd_add_count = 0;
static pthread_mutex_t fd_add_lock = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t fd_add_ready_cond = PTHREAD_COND_INITIALIZER;
static pthread_t fd_add_tid = NULL;

static InternalEvent* darwinEvents = NULL;

static pthread_mutex_t mieq_lock = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t mieq_ready_cond = PTHREAD_COND_INITIALIZER;

/*** Pthread Magics ***/
static pthread_t
create_thread(void *(*func)(void *), void *arg)
{
    pthread_attr_t attr;
    pthread_t tid;

    pthread_attr_init(&attr);
    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    pthread_create(&tid, &attr, func, arg);
    pthread_attr_destroy(&attr);

    return tid;
}

void
darwinEvents_lock(void);
void
darwinEvents_lock(void)
{
    int err;
    if ((err = pthread_mutex_lock(&mieq_lock))) {
        ErrorF("%s:%s:%d: Failed to lock mieq_lock: %d\n",
               __FILE__, __FUNCTION__, __LINE__, err);
        xorg_backtrace();
    }
    if (darwinEvents == NULL) {
        pthread_cond_wait(&mieq_ready_cond, &mieq_lock);
    }
}

void
darwinEvents_unlock(void);
void
darwinEvents_unlock(void)
{
    int err;
    if ((err = pthread_mutex_unlock(&mieq_lock))) {
        ErrorF("%s:%s:%d: Failed to unlock mieq_lock: %d\n",
               __FILE__, __FUNCTION__, __LINE__, err);
        xorg_backtrace();
    }
}

/*
 * DarwinPressModifierKey
 * Press or release the given modifier key (one of NX_MODIFIERKEY_* constants)
 */
static void
DarwinPressModifierKey(int pressed, int key)
{
    int keycode = DarwinModifierNXKeyToNXKeycode(key, 0);

    if (keycode == 0) {
        ErrorF("DarwinPressModifierKey bad keycode: key=%d\n", key);
        return;
    }

    DarwinSendKeyboardEvents(pressed, keycode);
}

/*
 * DarwinUpdateModifiers
 *  Send events to update the modifier state.
 */

static int darwin_x11_modifier_mask_list[] = {
#ifdef NX_DEVICELCMDKEYMASK
    NX_DEVICELCTLKEYMASK,   NX_DEVICERCTLKEYMASK,
    NX_DEVICELSHIFTKEYMASK, NX_DEVICERSHIFTKEYMASK,
    NX_DEVICELCMDKEYMASK,   NX_DEVICERCMDKEYMASK,
    NX_DEVICELALTKEYMASK,   NX_DEVICERALTKEYMASK,
#else
    NX_CONTROLMASK,         NX_SHIFTMASK,          NX_COMMANDMASK,
    NX_ALTERNATEMASK,
#endif
    NX_ALPHASHIFTMASK,
    0
};

static int darwin_all_modifier_mask_additions[] = { NX_SECONDARYFNMASK, 0 };

static void
DarwinUpdateModifiers(int pressed,                    // KeyPress or KeyRelease
                      int flags)                      // modifier flags that have changed
{
    int *f;
    int key;

    /* Capslock is special.  This mask is the state of capslock (on/off),
     * not the state of the button.  Hopefully we can find a better solution.
     */
    if (NX_ALPHASHIFTMASK & flags) {
        DarwinPressModifierKey(KeyPress, NX_MODIFIERKEY_ALPHALOCK);
        DarwinPressModifierKey(KeyRelease, NX_MODIFIERKEY_ALPHALOCK);
    }

    for (f = darwin_x11_modifier_mask_list; *f; f++)
        if (*f & flags && *f != NX_ALPHASHIFTMASK) {
            key = DarwinModifierNXMaskToNXKey(*f);
            if (key == -1)
                ErrorF("DarwinUpdateModifiers: Unsupported NXMask: 0x%x\n",
                       *f);
            else
                DarwinPressModifierKey(pressed, key);
        }
}

/* Generic handler for Xquartz-specifc events.  When possible, these should
   be moved into their own individual functions and set as handlers using
   mieqSetHandler. */

static void
DarwinEventHandler(int screenNum, InternalEvent *ie, DeviceIntPtr dev)
{
    XQuartzEvent *e = &(ie->xquartz_event);

    switch (e->subtype) {
    case kXquartzControllerNotify:
        DEBUG_LOG("kXquartzControllerNotify\n");
        AppleWMSendEvent(AppleWMControllerNotify,
                         AppleWMControllerNotifyMask,
                         e->data[0],
                         e->data[1]);
        break;

    case kXquartzPasteboardNotify:
        DEBUG_LOG("kXquartzPasteboardNotify\n");
        AppleWMSendEvent(AppleWMPasteboardNotify,
                         AppleWMPasteboardNotifyMask,
                         e->data[0],
                         e->data[1]);
        break;

    case kXquartzActivate:
        DEBUG_LOG("kXquartzActivate\n");
        QuartzShow();
        AppleWMSendEvent(AppleWMActivationNotify,
                         AppleWMActivationNotifyMask,
                         AppleWMIsActive, 0);
        break;

    case kXquartzDeactivate:
        DEBUG_LOG("kXquartzDeactivate\n");
        AppleWMSendEvent(AppleWMActivationNotify,
                         AppleWMActivationNotifyMask,
                         AppleWMIsInactive, 0);
        QuartzHide();
        break;

    case kXquartzReloadPreferences:
        DEBUG_LOG("kXquartzReloadPreferences\n");
        AppleWMSendEvent(AppleWMActivationNotify,
                         AppleWMActivationNotifyMask,
                         AppleWMReloadPreferences, 0);
        break;

    case kXquartzToggleFullscreen:
        DEBUG_LOG("kXquartzToggleFullscreen\n");
        if (XQuartzIsRootless)
            ErrorF(
                "Ignoring kXquartzToggleFullscreen because of rootless mode.");
        else
            QuartzRandRToggleFullscreen();
        break;

    case kXquartzSetRootless:
        DEBUG_LOG("kXquartzSetRootless\n");
        if (e->data[0]) {
            QuartzRandRSetFakeRootless();
        }
        else {
            QuartzRandRSetFakeFullscreen(FALSE);
        }
        break;

    case kXquartzSetRootClip:
        QuartzSetRootClip(e->data[0]);
        break;

    case kXquartzQuit:
        GiveUp(0);
        break;

    case kXquartzSpaceChanged:
        DEBUG_LOG("kXquartzSpaceChanged\n");
        QuartzSpaceChanged(e->data[0]);
        break;

    case kXquartzListenOnOpenFD:
        ErrorF("Calling ListenOnOpenFD() for new fd: %d\n", (int)e->data[0]);
        ListenOnOpenFD((int)e->data[0], 1);
        break;

    case kXquartzReloadKeymap:
        DarwinKeyboardReloadHandler();
        break;

    case kXquartzDisplayChanged:
        DEBUG_LOG("kXquartzDisplayChanged\n");
        QuartzUpdateScreens();

        /* Update our RandR info */
        QuartzRandRUpdateFakeModes(TRUE);
        break;

    default:
        if (!QuartzModeEventHandler(screenNum, e, dev))
            ErrorF("Unknown application defined event type %d.\n", e->subtype);
    }
}

void
DarwinListenOnOpenFD(int fd)
{
    ErrorF("DarwinListenOnOpenFD: %d\n", fd);

    pthread_mutex_lock(&fd_add_lock);
    if (fd_add_count < FD_ADD_MAX)
        fd_add[fd_add_count++] = fd;
    else
        ErrorF("FD Addition buffer at max.  Dropping fd addition request.\n");

    pthread_cond_broadcast(&fd_add_ready_cond);
    pthread_mutex_unlock(&fd_add_lock);
}

static void *
DarwinProcessFDAdditionQueue_thread(void *args)
{
    /* TODO: Possibly adjust this to no longer be a race... maybe trigger this
     *       once a client connects and claims to be the WM.
     *
     * From ajax:
     * There's already an internal callback chain for setting selection [in 1.5]
     * ownership.  See the CallSelectionCallback at the bottom of
     * ProcSetSelectionOwner, and xfixes/select.c for an example of how to hook
     * into it.
     */

    struct timespec sleep_for;
    struct timespec sleep_remaining;

    sleep_for.tv_sec = 3;
    sleep_for.tv_nsec = 0;

    ErrorF(
        "X11.app: DarwinProcessFDAdditionQueue_thread: Sleeping to allow xinitrc to catchup.\n");
    while (nanosleep(&sleep_for, &sleep_remaining) != 0) {
        sleep_for = sleep_remaining;
    }

    pthread_mutex_lock(&fd_add_lock);
    while (true) {
        while (fd_add_count) {
            DarwinSendDDXEvent(kXquartzListenOnOpenFD, 1,
                               fd_add[--fd_add_count]);
        }
        pthread_cond_wait(&fd_add_ready_cond, &fd_add_lock);
    }

    return NULL;
}

Bool
DarwinEQInit(void)
{
    int *p;

    for (p = darwin_x11_modifier_mask_list; *p; p++) {
        darwin_x11_modifier_mask |= *p;
    }

    darwin_all_modifier_mask = darwin_x11_modifier_mask;
    for (p = darwin_all_modifier_mask_additions; *p; p++) {
        darwin_all_modifier_mask |= *p;
    }

    mieqInit();
    mieqSetHandler(ET_XQuartz, DarwinEventHandler);

    /* Note that this *could* cause a potential async issue, since we're checking
     * darwinEvents without holding the lock, but darwinEvents is only ever set
     * here, so I don't bother.
     */
    if (!darwinEvents) {
        darwinEvents = InitEventList(GetMaximumEventsNum());

        if (!darwinEvents)
            FatalError("Couldn't allocate event buffer\n");

        darwinEvents_lock();
        pthread_cond_broadcast(&mieq_ready_cond);
        darwinEvents_unlock();
    }

    if (!fd_add_tid)
        fd_add_tid = create_thread(DarwinProcessFDAdditionQueue_thread, NULL);

    return TRUE;
}

void
DarwinEQFini(void)
{
    mieqFini();
}

/*
 * ProcessInputEvents
 *  Read and process events from the event queue until it is empty.
 */
void
ProcessInputEvents(void)
{
    char nullbyte;
    int x = sizeof(nullbyte);

    mieqProcessInputEvents();

    // Empty the signaling pipe
    while (x == sizeof(nullbyte)) {
        x = read(darwinEventReadFD, &nullbyte, sizeof(nullbyte));
    }
}

/* Sends a null byte down darwinEventWriteFD, which will cause the
   Dispatch() event loop to check out event queue */
static void
DarwinPokeEQ(void)
{
    char nullbyte = 0;
    //  <daniels> oh, i ... er ... christ.
    write(darwinEventWriteFD, &nullbyte, sizeof(nullbyte));
}

void
DarwinInputReleaseButtonsAndKeys(DeviceIntPtr pDev)
{
    darwinEvents_lock();
    {
        int i;
        if (pDev->button) {
            for (i = 0; i < pDev->button->numButtons; i++) {
                if (BitIsOn(pDev->button->down, i)) {
                    QueuePointerEvents(pDev, ButtonRelease, i,
                                       POINTER_ABSOLUTE,
                                       NULL);
                }
            }
        }

        if (pDev->key) {
            for (i = 0; i < NUM_KEYCODES; i++) {
                if (BitIsOn(pDev->key->down, i + MIN_KEYCODE)) {
                    QueueKeyboardEvents(pDev, KeyRelease, i + MIN_KEYCODE);
                }
            }
        }
        DarwinPokeEQ();
    } darwinEvents_unlock();
}

void
DarwinSendTabletEvents(DeviceIntPtr pDev, int ev_type, int ev_button,
                       double pointer_x, double pointer_y,
                       double pressure, double tilt_x,
                       double tilt_y)
{
    ScreenPtr screen;
    ValuatorMask valuators;

    if (!darwinEvents) {
        DEBUG_LOG("%s called before darwinEvents was initialized\n",
                  __FUNCTION__);
        return;
    }

    screen = miPointerGetScreen(pDev);
    if (!screen) {
        DEBUG_LOG("%s called before screen was initialized\n",
                  __FUNCTION__);
        return;
    }

    /* Fix offset between darwin and X screens */
    pointer_x -= darwinMainScreenX + screen->x;
    pointer_y -= darwinMainScreenY + screen->y;

    /* Adjust our pointer location to the [0,1] range */
    pointer_x = pointer_x / (double)screenInfo.width;
    pointer_y = pointer_y / (double)screenInfo.height;

    valuator_mask_zero(&valuators);
    valuator_mask_set_double(&valuators, 0, XQUARTZ_VALUATOR_LIMIT * pointer_x);
    valuator_mask_set_double(&valuators, 1, XQUARTZ_VALUATOR_LIMIT * pointer_y);
    valuator_mask_set_double(&valuators, 2, XQUARTZ_VALUATOR_LIMIT * pressure);
    valuator_mask_set_double(&valuators, 3, XQUARTZ_VALUATOR_LIMIT * tilt_x);
    valuator_mask_set_double(&valuators, 4, XQUARTZ_VALUATOR_LIMIT * tilt_y);

    darwinEvents_lock();
    {
        if (ev_type == ProximityIn || ev_type == ProximityOut) {
            QueueProximityEvents(pDev, ev_type, &valuators);
        } else {
            QueuePointerEvents(pDev, ev_type, ev_button, POINTER_ABSOLUTE,
                               &valuators);
        }
        DarwinPokeEQ();
    } darwinEvents_unlock();
}

void
DarwinSendPointerEvents(DeviceIntPtr pDev, int ev_type, int ev_button,
                        double pointer_x, double pointer_y,
                        double pointer_dx, double pointer_dy)
{
    static int darwinFakeMouseButtonDown = 0;
    ScreenPtr screen;
    ValuatorMask valuators;

    if (!darwinEvents) {
        DEBUG_LOG("%s called before darwinEvents was initialized\n",
                  __FUNCTION__);
        return;
    }

    screen = miPointerGetScreen(pDev);
    if (!screen) {
        DEBUG_LOG("%s called before screen was initialized\n",
                  __FUNCTION__);
        return;
    }

    /* Handle fake click */
    if (ev_type == ButtonPress && darwinFakeButtons && ev_button == 1) {
        if (darwinFakeMouseButtonDown != 0) {
            /* We're currently "down" with another button, so release it first */
            DarwinSendPointerEvents(pDev, ButtonRelease,
                                    darwinFakeMouseButtonDown,
                                    pointer_x, pointer_y, 0.0, 0.0);
            darwinFakeMouseButtonDown = 0;
        }
        if (darwin_all_modifier_flags & darwinFakeMouse2Mask) {
            ev_button = 2;
            darwinFakeMouseButtonDown = 2;
            DarwinUpdateModKeys(
                darwin_all_modifier_flags & ~darwinFakeMouse2Mask);
        }
        else if (darwin_all_modifier_flags & darwinFakeMouse3Mask) {
            ev_button = 3;
            darwinFakeMouseButtonDown = 3;
            DarwinUpdateModKeys(
                darwin_all_modifier_flags & ~darwinFakeMouse3Mask);
        }
    }

    if (ev_type == ButtonRelease && ev_button == 1) {
        if (darwinFakeMouseButtonDown) {
            ev_button = darwinFakeMouseButtonDown;
        }

        if (darwinFakeMouseButtonDown == 2) {
            DarwinUpdateModKeys(
                darwin_all_modifier_flags & ~darwinFakeMouse2Mask);
        }
        else if (darwinFakeMouseButtonDown == 3) {
            DarwinUpdateModKeys(
                darwin_all_modifier_flags & ~darwinFakeMouse3Mask);
        }

        darwinFakeMouseButtonDown = 0;
    }

    /* Fix offset between darwin and X screens */
    pointer_x -= darwinMainScreenX + screen->x;
    pointer_y -= darwinMainScreenY + screen->y;

    valuator_mask_zero(&valuators);
    valuator_mask_set_double(&valuators, 0, pointer_x);
    valuator_mask_set_double(&valuators, 1, pointer_y);

    if (ev_type == MotionNotify) {
        if (pointer_dx != 0.0)
            valuator_mask_set_double(&valuators, 2, pointer_dx);
        if (pointer_dy != 0.0)
            valuator_mask_set_double(&valuators, 3, pointer_dy);
    }

    darwinEvents_lock();
    {
        QueuePointerEvents(pDev, ev_type, ev_button, POINTER_ABSOLUTE,
                           &valuators);
        DarwinPokeEQ();
    } darwinEvents_unlock();
}

void
DarwinSendKeyboardEvents(int ev_type, int keycode)
{

    if (!darwinEvents) {
        DEBUG_LOG(
            "DarwinSendKeyboardEvents called before darwinEvents was initialized\n");
        return;
    }

    darwinEvents_lock();
    {
        QueueKeyboardEvents(darwinKeyboard, ev_type, keycode + MIN_KEYCODE);
        DarwinPokeEQ();
    } darwinEvents_unlock();
}

/* Send the appropriate number of button clicks to emulate scroll wheel */
void
DarwinSendScrollEvents(double scroll_x, double scroll_y) {
    ScreenPtr screen;
    ValuatorMask valuators;

    if (!darwinEvents) {
        DEBUG_LOG(
            "DarwinSendScrollEvents called before darwinEvents was initialized\n");
        return;
    }

    screen = miPointerGetScreen(darwinPointer);
    if (!screen) {
        DEBUG_LOG(
            "DarwinSendScrollEvents called before screen was initialized\n");
        return;
    }

    valuator_mask_zero(&valuators);
    valuator_mask_set_double(&valuators, 4, scroll_y);
    valuator_mask_set_double(&valuators, 5, scroll_x);

    darwinEvents_lock();
    {
        QueuePointerEvents(darwinPointer, MotionNotify, 0,
                           POINTER_RELATIVE, &valuators);
        DarwinPokeEQ();
    } darwinEvents_unlock();
}

/* Send the appropriate KeyPress/KeyRelease events to GetKeyboardEvents to
   reflect changing modifier flags (alt, control, meta, etc) */
void
DarwinUpdateModKeys(int flags)
{
    DarwinUpdateModifiers(
        KeyRelease, darwin_all_modifier_flags & ~flags &
        darwin_x11_modifier_mask);
    DarwinUpdateModifiers(
        KeyPress, ~darwin_all_modifier_flags & flags &
        darwin_x11_modifier_mask);
    darwin_all_modifier_flags = flags;
}

/*
 * DarwinSendDDXEvent
 *  Send the X server thread a message by placing it on the event queue.
 */
void
DarwinSendDDXEvent(int type, int argc, ...)
{
    XQuartzEvent e;
    int i;
    va_list args;

    memset(&e, 0, sizeof(e));
    e.header = ET_Internal;
    e.type = ET_XQuartz;
    e.length = sizeof(e);
    e.time = GetTimeInMillis();
    e.subtype = type;

    if (argc > 0 && argc < XQUARTZ_EVENT_MAXARGS) {
        va_start(args, argc);
        for (i = 0; i < argc; i++)
            e.data[i] = (uint32_t)va_arg(args, uint32_t);
        va_end(args);
    }

    darwinEvents_lock();
    {
        mieqEnqueue(NULL, (InternalEvent *)&e);
        DarwinPokeEQ();
    } darwinEvents_unlock();
}
@


1.9
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d278 1
a278 1
        QuartzSetRootClip((Bool)e->data[0]);
d456 1
a456 2
                    QueueKeyboardEvents(pDev, KeyRelease, i + MIN_KEYCODE,
                                        NULL);
d610 1
a610 2
        QueueKeyboardEvents(darwinKeyboard, ev_type, keycode + MIN_KEYCODE,
                            NULL);
@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d181 1
a181 1
static int darwin_all_modifier_mask_additions[] = { NX_SECONDARYFNMASK, };
d370 1
a370 2
    for (p = darwin_x11_modifier_mask_list, darwin_all_modifier_mask = 0; *p;
         p++) {
d374 2
a375 3
    for (p = darwin_all_modifier_mask_additions,
         darwin_all_modifier_mask = darwin_x11_modifier_mask;
         *p; p++) {
a387 1
        ;
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d599 1
a599 1
    } darwinEvents_unlock();   
d648 1
a648 1
    } darwinEvents_unlock();    
@


1.6
log
@Update to xserver 1.11.2
@
text
@d2 37
a38 29
Darwin event queue and event handling

Copyright 2007-2008 Apple Inc.
Copyright 2004 Kaleb S. KEITHLEY. All Rights Reserved.
Copyright (c) 2002-2004 Torrey T. Lyons. All Rights Reserved.

This file is based on mieq.c by Keith Packard,
which contains the following copyright:
Copyright 1990, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.
d47 14
a60 13
#include   <X11/X.h>
#include   <X11/Xmd.h>
#include   <X11/Xproto.h>
#include   "misc.h"
#include   "windowstr.h"
#include   "pixmapstr.h"
#include   "inputstr.h"
#include   "inpututils.h"
#include   "eventstr.h"
#include   "mi.h"
#include   "scrnintstr.h"
#include   "mipointer.h"
#include   "os.h"
a76 6
/* Fake button press/release for scroll wheel move. */
#define SCROLLWHEELUPFAKE    4
#define SCROLLWHEELDOWNFAKE  5
#define SCROLLWHEELLEFTFAKE  6
#define SCROLLWHEELRIGHTFAKE 7

d81 2
a82 1
extern Bool QuartzModeEventHandler(int screenNum, XQuartzEvent *e, DeviceIntPtr dev);
d101 3
a103 1
static pthread_t create_thread(void *(*func)(void *), void *arg) {
d107 5
a111 5
    pthread_attr_init (&attr);
    pthread_attr_setscope (&attr, PTHREAD_SCOPE_SYSTEM);
    pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);
    pthread_create (&tid, &attr, func, arg);
    pthread_attr_destroy (&attr);
d116 5
a120 2
void darwinEvents_lock(void);
void darwinEvents_lock(void) {
d122 1
a122 1
    if((err = pthread_mutex_lock(&mieq_lock))) {
d127 1
a127 1
    if(darwinEvents == NULL) {
d132 5
a136 2
void darwinEvents_unlock(void);
void darwinEvents_unlock(void) {
d138 1
a138 1
    if((err = pthread_mutex_unlock(&mieq_lock))) {
d149 3
a151 1
static void DarwinPressModifierKey(int pressed, int key) {
d169 1
a169 1
    NX_DEVICELCTLKEYMASK, NX_DEVICERCTLKEYMASK,
d171 2
a172 2
    NX_DEVICELCMDKEYMASK, NX_DEVICERCMDKEYMASK,
    NX_DEVICELALTKEYMASK, NX_DEVICERALTKEYMASK,
d174 2
a175 1
    NX_CONTROLMASK, NX_SHIFTMASK, NX_COMMANDMASK, NX_ALTERNATEMASK,
d183 3
a185 3
static void DarwinUpdateModifiers(
    int pressed,        // KeyPress or KeyRelease
    int flags )         // modifier flags that have changed
d193 1
a193 1
    if(NX_ALPHASHIFTMASK & flags) {
d197 3
a199 3
    
    for(f=darwin_x11_modifier_mask_list; *f; f++)
        if(*f & flags && *f != NX_ALPHASHIFTMASK) {
d201 3
a203 2
            if(key == -1)
                ErrorF("DarwinUpdateModifiers: Unsupported NXMask: 0x%x\n", *f);
d213 3
a215 1
static void DarwinEventHandler(int screenNum, InternalEvent *ie, DeviceIntPtr dev) {
d218 93
a310 91
    switch(e->subtype) {
        case kXquartzControllerNotify:
            DEBUG_LOG("kXquartzControllerNotify\n");
            AppleWMSendEvent(AppleWMControllerNotify,
                             AppleWMControllerNotifyMask,
                             e->data[0],
                             e->data[1]);
            break;
            
        case kXquartzPasteboardNotify:
            DEBUG_LOG("kXquartzPasteboardNotify\n");
            AppleWMSendEvent(AppleWMPasteboardNotify,
                             AppleWMPasteboardNotifyMask,
                             e->data[0],
                             e->data[1]);
            break;
            
        case kXquartzActivate:
            DEBUG_LOG("kXquartzActivate\n");
            QuartzShow();
            AppleWMSendEvent(AppleWMActivationNotify,
                             AppleWMActivationNotifyMask,
                             AppleWMIsActive, 0);
            break;
            
        case kXquartzDeactivate:
            DEBUG_LOG("kXquartzDeactivate\n");
            AppleWMSendEvent(AppleWMActivationNotify,
                             AppleWMActivationNotifyMask,
                             AppleWMIsInactive, 0);
            QuartzHide();
            break;

        case kXquartzReloadPreferences:
            DEBUG_LOG("kXquartzReloadPreferences\n");
            AppleWMSendEvent(AppleWMActivationNotify,
                             AppleWMActivationNotifyMask,
                             AppleWMReloadPreferences, 0);
            break;
            
        case kXquartzToggleFullscreen:
            DEBUG_LOG("kXquartzToggleFullscreen\n");
            if(XQuartzIsRootless)
                ErrorF("Ignoring kXquartzToggleFullscreen because of rootless mode.");
            else 
                QuartzRandRToggleFullscreen();
            break;
            
        case kXquartzSetRootless:
            DEBUG_LOG("kXquartzSetRootless\n");
            if(e->data[0]) {
                QuartzRandRSetFakeRootless();
            } else {
                QuartzRandRSetFakeFullscreen(FALSE);
            }
            break;
            
        case kXquartzSetRootClip:
            QuartzSetRootClip((Bool)e->data[0]);
            break;
            
        case kXquartzQuit:
            GiveUp(0);
            break;
            
        case kXquartzSpaceChanged:
            DEBUG_LOG("kXquartzSpaceChanged\n");
            QuartzSpaceChanged(e->data[0]);
            break;

        case kXquartzListenOnOpenFD:
            ErrorF("Calling ListenOnOpenFD() for new fd: %d\n", (int)e->data[0]);
            ListenOnOpenFD((int)e->data[0], 1);
            break;
            
        case kXquartzReloadKeymap:
            DarwinKeyboardReloadHandler();
            break;
            
        case kXquartzDisplayChanged:
            DEBUG_LOG("kXquartzDisplayChanged\n");
            QuartzUpdateScreens();

            /* Update our RandR info */
            QuartzRandRUpdateFakeModes(TRUE);
            break;
            
        default:
            if(!QuartzModeEventHandler(screenNum, e, dev))
                ErrorF("Unknown application defined event type %d.\n", e->subtype);
    }	
d313 3
a315 1
void DarwinListenOnOpenFD(int fd) {
d317 1
a317 1
    
d319 1
a319 1
    if(fd_add_count < FD_ADD_MAX)
d328 3
a330 1
static void *DarwinProcessFDAdditionQueue_thread(void *args) {
d347 3
a349 2
    ErrorF("X11.app: DarwinProcessFDAdditionQueue_thread: Sleeping to allow xinitrc to catchup.\n");
    while(nanosleep(&sleep_for, &sleep_remaining) != 0) {
d354 4
a357 3
    while(true) {
        while(fd_add_count) {
            DarwinSendDDXEvent(kXquartzListenOnOpenFD, 1, fd_add[--fd_add_count]);
d365 3
a367 1
Bool DarwinEQInit(void) { 
d370 2
a371 1
    for(p=darwin_x11_modifier_mask_list, darwin_all_modifier_mask=0; *p; p++) {
d374 4
a377 2
    
    for(p=darwin_all_modifier_mask_additions, darwin_all_modifier_mask= darwin_x11_modifier_mask; *p; p++) {
d380 1
a380 1
    
d389 3
a391 2
        darwinEvents = InitEventList(GetMaximumEventsNum());;
        
d394 1
a394 1
        
d400 1
a400 1
    if(!fd_add_tid)
d402 1
a402 1
    
d406 3
a408 1
void DarwinEQFini(void) {
d416 3
a418 1
void ProcessInputEvents(void) {
d420 2
a421 2
	int x = sizeof(nullbyte);
    
d426 1
a426 1
      x = read(darwinEventReadFD, &nullbyte, sizeof(nullbyte));
d432 6
a437 4
static void DarwinPokeEQ(void) {
	char nullbyte=0;
	//  <daniels> oh, i ... er ... christ.
	write(darwinEventWriteFD, &nullbyte, sizeof(nullbyte));
d440 50
a489 7
/* Convert from Appkit pointer input values to X input values:
 * Note: pointer_x and pointer_y are relative to the upper-left of primary
 *       display.
 */
static void DarwinPrepareValuators(DeviceIntPtr pDev, int *valuators, ScreenPtr screen,
                                   float pointer_x, float pointer_y, 
                                   float pressure, float tilt_x, float tilt_y) {
d494 22
a515 2
    if(pointer_x < 0.0)
        pointer_x = 0.0;
d517 6
a522 24
    if(pointer_y < 0.0)
        pointer_y = 0.0;
    
    if(pDev == darwinPointer) {
        valuators[0] = pointer_x;
        valuators[1] = pointer_y;
        valuators[2] = 0;
        valuators[3] = 0;
        valuators[4] = 0;
    } else {
        /* Setup our array of values */
        valuators[0] = XQUARTZ_VALUATOR_LIMIT * (pointer_x / (float)screenInfo.screens[0]->width);
        valuators[1] = XQUARTZ_VALUATOR_LIMIT * (pointer_y / (float)screenInfo.screens[0]->height);
        valuators[2] = XQUARTZ_VALUATOR_LIMIT * pressure;
        valuators[3] = XQUARTZ_VALUATOR_LIMIT * tilt_x;
        valuators[4] = XQUARTZ_VALUATOR_LIMIT * tilt_y;
    }
    //DEBUG_LOG("Pointer (%f, %f), Valuators: {%d,%d,%d,%d,%d}\n", pointer_x, pointer_y,
    //          valuators[0], valuators[1], valuators[2], valuators[3], valuators[4]);
}

void DarwinSendPointerEvents(DeviceIntPtr pDev, int ev_type, int ev_button, float pointer_x, float pointer_y, 
			     float pressure, float tilt_x, float tilt_y) {
	static int darwinFakeMouseButtonDown = 0;
d524 7
a530 8
    int valuators[5];
	
    //DEBUG_LOG("x=%f, y=%f, p=%f, tx=%f, ty=%f\n", pointer_x, pointer_y, pressure, tilt_x, tilt_y);
    
	if(!darwinEvents) {
		DEBUG_LOG("DarwinSendPointerEvents called before darwinEvents was initialized\n");
		return;
	}
d533 3
a535 2
    if(!screen) {
        DEBUG_LOG("DarwinSendPointerEvents called before screen was initialized\n");
d540 2
a541 2
	if (ev_type == ButtonPress && darwinFakeButtons && ev_button == 1) {
        if(darwinFakeMouseButtonDown != 0) {
d543 4
a546 2
            DarwinSendPointerEvents(pDev, ButtonRelease, darwinFakeMouseButtonDown, pointer_x, pointer_y, pressure, tilt_x, tilt_y);
            darwinFakeMouseButtonDown=0;
d548 1
a548 1
		if (darwin_all_modifier_flags & darwinFakeMouse2Mask) {
d550 5
a554 3
			darwinFakeMouseButtonDown = 2;
            DarwinUpdateModKeys(darwin_all_modifier_flags & ~darwinFakeMouse2Mask);
		} else if (darwin_all_modifier_flags & darwinFakeMouse3Mask) {
d556 5
a560 4
			darwinFakeMouseButtonDown = 3;
            DarwinUpdateModKeys(darwin_all_modifier_flags & ~darwinFakeMouse3Mask);
		}
	}
d562 2
a563 2
	if (ev_type == ButtonRelease && ev_button == 1) {
        if(darwinFakeMouseButtonDown) {
d567 7
a573 4
        if(darwinFakeMouseButtonDown == 2) {
            DarwinUpdateModKeys(darwin_all_modifier_flags & ~darwinFakeMouse2Mask);
        } else if(darwinFakeMouseButtonDown == 3) {
            DarwinUpdateModKeys(darwin_all_modifier_flags & ~darwinFakeMouse3Mask);
d577 5
a581 1
	}
d583 15
a597 5
    DarwinPrepareValuators(pDev, valuators, screen, pointer_x, pointer_y, pressure, tilt_x, tilt_y);
    darwinEvents_lock(); {
        ValuatorMask mask;
        valuator_mask_set_range(&mask, 0, (pDev == darwinPointer) ? 2 : 5, valuators);
        QueuePointerEvents(pDev, ev_type, ev_button, POINTER_ABSOLUTE, &mask);
d599 1
a599 1
    } darwinEvents_unlock();
d602 3
a604 1
void DarwinSendKeyboardEvents(int ev_type, int keycode) {
d606 5
a610 4
	if(!darwinEvents) {
		DEBUG_LOG("DarwinSendKeyboardEvents called before darwinEvents was initialized\n");
		return;
	}
d612 4
a615 2
    darwinEvents_lock(); {
        QueueKeyboardEvents(darwinKeyboard, ev_type, keycode + MIN_KEYCODE, NULL);
d620 3
a622 2
void DarwinSendProximityEvents(DeviceIntPtr pDev, int ev_type, float pointer_x, float pointer_y,  
                               float pressure, float tilt_x, float tilt_y) {
d624 1
a624 1
    int valuators[5];
d626 5
a630 1
    DEBUG_LOG("DarwinSendProximityEvents: %d l:%f,%f p:%f t:%f,%f\n", ev_type, pointer_x, pointer_y, pressure, tilt_x, tilt_y);
d632 4
a635 2
    if(!darwinEvents) {
        DEBUG_LOG("DarwinSendProximityEvents called before darwinEvents was initialized\n");
a637 6
    
    screen = miPointerGetScreen(pDev);
    if(!screen) {
        DEBUG_LOG("DarwinSendPointerEvents called before screen was initialized\n");
        return;
    }    
d639 8
a646 5
    DarwinPrepareValuators(pDev, valuators, screen, pointer_x, pointer_y, pressure, tilt_x, tilt_y);
    darwinEvents_lock(); {
        ValuatorMask mask;
        valuator_mask_set_range(&mask, 0, 5, valuators);
        QueueProximityEvents(pDev, ev_type, &mask);
d648 1
a648 31
    } darwinEvents_unlock();
}


/* Send the appropriate number of button clicks to emulate scroll wheel */
void DarwinSendScrollEvents(float count_x, float count_y, 
							float pointer_x, float pointer_y, 
			    			float pressure, float tilt_x, float tilt_y) {
	int sign_x, sign_y;
	if(!darwinEvents) {
		DEBUG_LOG("DarwinSendScrollEvents called before darwinEvents was initialized\n");
		return;
	}

	sign_x = count_x > 0.0f ? SCROLLWHEELLEFTFAKE : SCROLLWHEELRIGHTFAKE;
	sign_y = count_y > 0.0f ? SCROLLWHEELUPFAKE : SCROLLWHEELDOWNFAKE;
	count_x = fabs(count_x);
	count_y = fabs(count_y);
	
	while ((count_x > 0.0f) || (count_y > 0.0f)) {
		if (count_x > 0.0f) {
			DarwinSendPointerEvents(darwinPointer, ButtonPress, sign_x, pointer_x, pointer_y, pressure, tilt_x, tilt_y);
			DarwinSendPointerEvents(darwinPointer, ButtonRelease, sign_x, pointer_x, pointer_y, pressure, tilt_x, tilt_y);
			count_x = count_x - 1.0f;
		}
		if (count_y > 0.0f) {
			DarwinSendPointerEvents(darwinPointer, ButtonPress, sign_y, pointer_x, pointer_y, pressure, tilt_x, tilt_y);
			DarwinSendPointerEvents(darwinPointer, ButtonRelease, sign_y, pointer_x, pointer_y, pressure, tilt_x, tilt_y);
			count_y = count_y - 1.0f;
		}
	}
d653 10
a662 4
void DarwinUpdateModKeys(int flags) {
	DarwinUpdateModifiers(KeyRelease, darwin_all_modifier_flags & ~flags & darwin_x11_modifier_mask);
	DarwinUpdateModifiers(KeyPress, ~darwin_all_modifier_flags & flags & darwin_x11_modifier_mask);
	darwin_all_modifier_flags = flags;
d669 3
a671 1
void DarwinSendDDXEvent(int type, int argc, ...) {
d684 1
a684 1
        va_start (args, argc);
d686 2
a687 2
            e.data[i] = (uint32_t) va_arg (args, uint32_t);
        va_end (args);
d690 3
a692 2
    darwinEvents_lock(); {
        mieqEnqueue(NULL, (InternalEvent*)&e);
@


1.5
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d46 1
d64 1
d91 1
a91 1
static EventListPtr darwinEvents = NULL;
d97 1
a97 1
static pthread_t create_thread(void *func, void *arg) {
d116 1
a116 1
        spewCallStack();
d129 1
a129 1
        spewCallStack();
a199 2
    TA_SERVER();

d306 22
a327 1
static void DarwinProcessFDAdditionQueue_thread(void *args) {
d335 2
d374 4
a385 2
    TA_SERVER();

a439 1
	int i, num_events;
d490 4
a493 4
        num_events = GetPointerEvents(darwinEvents, pDev, ev_type, ev_button, 
                                      POINTER_ABSOLUTE, 0, pDev==darwinTabletCurrent?5:2, valuators);
        for(i=0; i<num_events; i++) mieqEnqueue (pDev, (InternalEvent*)darwinEvents[i].event);
        if(num_events > 0) DarwinPokeEQ();
a497 1
	int i, num_events;
d505 2
a506 3
        num_events = GetKeyboardEvents(darwinEvents, darwinKeyboard, ev_type, keycode + MIN_KEYCODE);
        for(i=0; i<num_events; i++) mieqEnqueue(darwinKeyboard, (InternalEvent*)darwinEvents[i].event);
        if(num_events > 0) DarwinPokeEQ();
d510 2
a511 2
void DarwinSendProximityEvents(int ev_type, float pointer_x, float pointer_y) {
	int i, num_events;
a512 1
    DeviceIntPtr pDev = darwinTabletCurrent;
d515 1
a515 1
	DEBUG_LOG("DarwinSendProximityEvents(%d, %f, %f)\n", ev_type, pointer_x, pointer_y);
d517 4
a520 4
	if(!darwinEvents) {
		DEBUG_LOG("DarwinSendProximityEvents called before darwinEvents was initialized\n");
		return;
	}
d528 1
a528 1
    DarwinPrepareValuators(pDev, valuators, screen, pointer_x, pointer_y, 0.0f, 0.0f, 0.0f);
d530 4
a533 4
        num_events = GetProximityEvents(darwinEvents, pDev, ev_type,
                                        0, 5, valuators);
        for(i=0; i<num_events; i++) mieqEnqueue (pDev, (InternalEvent*)darwinEvents[i].event);
        if(num_events > 0) DarwinPokeEQ();
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d282 1
a282 1
#ifdef RANDR
a284 1
#endif
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d55 1
d242 4
a245 6
            if (quartzEnableRootless) 
                QuartzSetFullscreen(!quartzHasRoot);
            else if (quartzHasRoot)
                QuartzHide();
            else
                QuartzShow();
d250 5
a254 3
            QuartzSetRootless(e->data[0]);
            if (!quartzEnableRootless && !quartzHasRoot)
                QuartzHide();
d280 1
d282 4
d386 2
a387 2
    pointer_x -= darwinMainScreenX + dixScreenOrigins[screen->myNum].x;
    pointer_y -= darwinMainScreenY + dixScreenOrigins[screen->myNum].y;
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a38 1
#define NEED_EVENTS
d46 1
d71 1
a71 1
#define _APPLEWM_SERVER_
a72 1
#include <X11/extensions/applewm.h>
d75 1
a75 1
void QuartzModeEQInit(void);
d77 3
a79 1
int darwin_modifier_flags = 0;  // last known modifier state
d88 1
a88 1
static EventList *darwinEvents = NULL;
d150 1
a150 1
int darwin_modifier_mask_list[] = {
d163 2
d180 1
a180 1
    for(f=darwin_modifier_mask_list; *f; f++)
d194 3
a196 3
static void DarwinEventHandler(int screenNum, xEventPtr xe, DeviceIntPtr dev, int nevents) {
    int i;
    
d199 54
a252 33
//    DEBUG_LOG("DarwinEventHandler(%d, %p, %p, %d)\n", screenNum, xe, dev, nevents);
    for (i=0; i<nevents; i++) {
        switch(xe[i].u.u.type) {
            case kXquartzControllerNotify:
                DEBUG_LOG("kXquartzControllerNotify\n");
                AppleWMSendEvent(AppleWMControllerNotify,
                                 AppleWMControllerNotifyMask,
                                 xe[i].u.clientMessage.u.l.longs0,
                                 xe[i].u.clientMessage.u.l.longs1);
                break;
                
            case kXquartzPasteboardNotify:
                DEBUG_LOG("kXquartzPasteboardNotify\n");
                AppleWMSendEvent(AppleWMPasteboardNotify,
                                 AppleWMPasteboardNotifyMask,
                                 xe[i].u.clientMessage.u.l.longs0,
                                 xe[i].u.clientMessage.u.l.longs1);
                break;
                
            case kXquartzActivate:
                DEBUG_LOG("kXquartzActivate\n");
                QuartzShow(xe[i].u.keyButtonPointer.rootX,
                           xe[i].u.keyButtonPointer.rootY);
                AppleWMSendEvent(AppleWMActivationNotify,
                                 AppleWMActivationNotifyMask,
                                 AppleWMIsActive, 0);
                break;
                
            case kXquartzDeactivate:
                DEBUG_LOG("kXquartzDeactivate\n");
                AppleWMSendEvent(AppleWMActivationNotify,
                                 AppleWMActivationNotifyMask,
                                 AppleWMIsInactive, 0);
d254 32
a285 44
                break;

            case kXquartzReloadPreferences:
                DEBUG_LOG("kXquartzReloadPreferences\n");
                AppleWMSendEvent(AppleWMActivationNotify,
                                 AppleWMActivationNotifyMask,
                                 AppleWMReloadPreferences, 0);
                break;
                
            case kXquartzToggleFullscreen:
                DEBUG_LOG("kXquartzToggleFullscreen\n");
                if (quartzEnableRootless) 
                    QuartzSetFullscreen(!quartzHasRoot);
                else if (quartzHasRoot)
                    QuartzHide();
                else
                    QuartzShow(xe[i].u.keyButtonPointer.rootX,
                               xe[i].u.keyButtonPointer.rootY);
                break;
                
            case kXquartzSetRootless:
                DEBUG_LOG("kXquartzSetRootless\n");
                QuartzSetRootless(xe[i].u.clientMessage.u.l.longs0);
                if (!quartzEnableRootless && !quartzHasRoot)
                    QuartzHide();
                break;
                
            case kXquartzSetRootClip:
                QuartzSetRootClip((Bool)xe[i].u.clientMessage.u.l.longs0);
                break;
                
            case kXquartzQuit:
                GiveUp(0);
                break;
                
            case kXquartzSpaceChanged:
                DEBUG_LOG("kXquartzSpaceChanged\n");
                QuartzSpaceChanged(xe[i].u.clientMessage.u.l.longs0);
                break;

            default:
                ErrorF("Unknown application defined event type %d.\n", xe[i].u.u.type);
		}	
    }
d311 6
a316 3
static void kXquartzListenOnOpenFDHandler(int screenNum, xEventPtr xe, DeviceIntPtr dev, int nevents) {
    size_t i;
    TA_SERVER();
d318 2
a319 3
    for (i=0; i<nevents; i++) {
        ErrorF("Calling ListenOnOpenFD() for new fd: %d\n", (int)xe[i].u.clientMessage.u.l.longs0);
        ListenOnOpenFD((int)xe[i].u.clientMessage.u.l.longs0, 1);
d321 1
a321 3
}

Bool DarwinEQInit(void) { 
d323 1
a323 17
    mieqSetHandler(kXquartzReloadKeymap, DarwinKeyboardReloadHandler);
    mieqSetHandler(kXquartzActivate, DarwinEventHandler);
    mieqSetHandler(kXquartzDeactivate, DarwinEventHandler);
    mieqSetHandler(kXquartzReloadPreferences, DarwinEventHandler);
    mieqSetHandler(kXquartzSetRootClip, DarwinEventHandler);
    mieqSetHandler(kXquartzQuit, DarwinEventHandler);
    mieqSetHandler(kXquartzReadPasteboard, QuartzReadPasteboard);
    mieqSetHandler(kXquartzWritePasteboard, QuartzWritePasteboard);
    mieqSetHandler(kXquartzToggleFullscreen, DarwinEventHandler);
    mieqSetHandler(kXquartzSetRootless, DarwinEventHandler);
    mieqSetHandler(kXquartzSpaceChanged, DarwinEventHandler);
    mieqSetHandler(kXquartzControllerNotify, DarwinEventHandler);
    mieqSetHandler(kXquartzPasteboardNotify, DarwinEventHandler);
    mieqSetHandler(kXquartzDisplayChanged, QuartzDisplayChangedHandler);
    mieqSetHandler(kXquartzListenOnOpenFD, kXquartzListenOnOpenFDHandler);
    
    QuartzModeEQInit();
d351 2
a352 2
    xEvent  xe;
	int x = sizeof(xe);
d359 2
a360 2
    while (x == sizeof(xe)) {
      x = read(darwinEventReadFD, &xe, sizeof(xe));
d369 1
a369 1
	write(darwinEventWriteFD, &nullbyte, 1);
d434 1
a434 1
		if (darwin_modifier_flags & darwinFakeMouse2Mask) {
d437 2
a438 2
            DarwinUpdateModKeys(darwin_modifier_flags & ~darwinFakeMouse2Mask);
		} else if (darwin_modifier_flags & darwinFakeMouse3Mask) {
d441 1
a441 1
            DarwinUpdateModKeys(darwin_modifier_flags & ~darwinFakeMouse3Mask);
d451 1
a451 1
            DarwinUpdateModKeys(darwin_modifier_flags & ~darwinFakeMouse2Mask);
d453 1
a453 1
            DarwinUpdateModKeys(darwin_modifier_flags & ~darwinFakeMouse3Mask);
d463 2
a464 2
        for(i=0; i<num_events; i++) mieqEnqueue (pDev, darwinEvents[i].event);
        DarwinPokeEQ();
d478 2
a479 2
        for(i=0; i<num_events; i++) mieqEnqueue(darwinKeyboard,darwinEvents[i].event);
        DarwinPokeEQ();
d506 2
a507 2
        for(i=0; i<num_events; i++) mieqEnqueue (pDev,darwinEvents[i].event);
        DarwinPokeEQ();
d516 1
d522 2
a523 2
	int sign_x = count_x > 0.0f ? SCROLLWHEELLEFTFAKE : SCROLLWHEELRIGHTFAKE;
	int sign_y = count_y > 0.0f ? SCROLLWHEELUPFAKE : SCROLLWHEELDOWNFAKE;
d544 3
a546 3
	DarwinUpdateModifiers(KeyRelease, darwin_modifier_flags & ~flags);
	DarwinUpdateModifiers(KeyPress, ~darwin_modifier_flags & flags);
	darwin_modifier_flags = flags;
d554 2
a555 3
    xEvent xe;
    INT32 *argv;
    int i, max_args;
d558 6
a563 6
    memset(&xe, 0, sizeof(xe));
    xe.u.u.type = type;
    xe.u.clientMessage.u.l.type = type;

    argv = &xe.u.clientMessage.u.l.longs0;
    max_args = 4;
d565 1
a565 1
    if (argc > 0 && argc <= max_args) {
d568 1
a568 1
            argv[i] = (int) va_arg (args, int);
d573 1
a573 1
        mieqEnqueue(darwinPointer, &xe);
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d4 1
a4 1
Copyright 2007 Apple Inc.
d33 6
d50 1
d54 1
a54 1
#include "darwinKeyboard.h"
d60 3
d66 52
a117 2
#define SCROLLWHEELUPFAKE   4
#define SCROLLWHEELDOWNFAKE 5
d119 9
a127 23
#define QUEUE_SIZE 256

typedef struct _Event {
    xEvent      event;
    ScreenPtr   pScreen;
} EventRec, *EventPtr;

int input_check_zero, input_check_flag;

static int old_flags = 0;  // last known modifier state

typedef struct _EventQueue {
    HWEventQueueType    head, tail; /* long for SetInputCheck */
    CARD32      lastEventTime;      /* to avoid time running backwards */
    Bool        lastMotion;
    EventRec    events[QUEUE_SIZE]; /* static allocation for signals */
    DevicePtr   pKbd, pPtr;         /* device pointer, to get funcs */
    ScreenPtr   pEnqueueScreen;     /* screen events are being delivered to */
    ScreenPtr   pDequeueScreen;     /* screen events are being dispatched to */
} EventQueueRec, *EventQueuePtr;

static EventQueueRec darwinEventQueue;
xEvent *darwinEvents;
d130 2
a131 2
 * DarwinPressModifierMask
 *  Press or release the given modifier key, specified by its mask.
d133 2
a134 5
static void DarwinPressModifierMask(
    int pressed,				    
    int mask)       // one of NX_*MASK constants
{
    int key = DarwinModifierNXMaskToNXKey(mask);
d136 3
a138 4
    if (key != -1) {
        int keycode = DarwinModifierNXKeyToNXKeycode(key, 0);
        if (keycode != 0)
	  DarwinSendKeyboardEvents(pressed, keycode);
d140 2
d144 4
a147 11
#ifdef NX_DEVICELCTLKEYMASK
#define CONTROL_MASK(flags) (flags & (NX_DEVICELCTLKEYMASK|NX_DEVICERCTLKEYMASK))
#else
#define CONTROL_MASK(flags) (NX_CONTROLMASK)
#endif /* NX_DEVICELCTLKEYMASK */

#ifdef NX_DEVICELSHIFTKEYMASK
#define SHIFT_MASK(flags) (flags & (NX_DEVICELSHIFTKEYMASK|NX_DEVICERSHIFTKEYMASK))
#else
#define SHIFT_MASK(flags) (NX_SHIFTMASK)
#endif /* NX_DEVICELSHIFTKEYMASK */
d149 1
d151 4
a154 7
#define COMMAND_MASK(flags) (flags & (NX_DEVICELCMDKEYMASK|NX_DEVICERCMDKEYMASK))
#else
#define COMMAND_MASK(flags) (NX_COMMANDMASK)
#endif /* NX_DEVICELCMDKEYMASK */

#ifdef NX_DEVICELALTKEYMASK
#define ALTERNATE_MASK(flags) (flags & (NX_DEVICELALTKEYMASK|NX_DEVICERALTKEYMASK))
d156 5
a160 2
#define ALTERNATE_MASK(flags) (NX_ALTERNATEMASK)
#endif /* NX_DEVICELALTKEYMASK */
a161 4
/*
 * DarwinUpdateModifiers
 *  Send events to update the modifier state.
 */
d166 2
a167 19
    if (flags & NX_ALPHASHIFTMASK) {
        DarwinPressModifierMask(pressed, NX_ALPHASHIFTMASK);
    }
    if (flags & NX_COMMANDMASK) {
        DarwinPressModifierMask(pressed, COMMAND_MASK(flags));
    }
    if (flags & NX_CONTROLMASK) {
        DarwinPressModifierMask(pressed, CONTROL_MASK(flags));
    }
    if (flags & NX_ALTERNATEMASK) {
        DarwinPressModifierMask(pressed, ALTERNATE_MASK(flags));
    }
    if (flags & NX_SHIFTMASK) {
        DarwinPressModifierMask(pressed, SHIFT_MASK(flags));
    }
    if (flags & NX_SECONDARYFNMASK) {
        DarwinPressModifierMask(pressed, NX_SECONDARYFNMASK);
    }
}
d169 16
a184 8
/*
 * DarwinReleaseModifiers
 * This hacky function releases all modifier keys.  It should be called when X11.app
 * is deactivated (kXDarwinDeactivate) to prevent modifiers from getting stuck if they
 * are held down during a "context" switch -- otherwise, we would miss the KeyUp.
 */
static void DarwinReleaseModifiers(void) {
	DarwinUpdateModifiers(KeyRelease, COMMAND_MASK(-1) | CONTROL_MASK(-1) | ALTERNATE_MASK(-1) | SHIFT_MASK(-1));
d187 44
a230 22
/*
 * DarwinSimulateMouseClick
 *  Send a mouse click to X when multiple mouse buttons are simulated
 *  with modifier-clicks, such as command-click for button 2. The dix
 *  layer is told that the previously pressed modifier key(s) are
 *  released, the simulated click event is sent. After the mouse button
 *  is released, the modifier keys are reverted to their actual state,
 *  which may or may not be pressed at that point. This is usually
 *  closest to what the user wants. Ie. the user typically wants to
 *  simulate a button 2 press instead of Command-button 2.
 */
static void DarwinSimulateMouseClick(
    int pointer_x,
    int pointer_y,
    int whichButton,    // mouse button to be pressed
    int modifierMask)   // modifiers used for the fake click
{
    // first fool X into forgetting about the keys
	// for some reason, it's not enough to tell X we released the Command key -- 
	// it has to be the *left* Command key.
	if (modifierMask & NX_COMMANDMASK) modifierMask |=NX_DEVICELCMDKEYMASK ;
    DarwinUpdateModifiers(KeyRelease, modifierMask);
d232 37
a268 3
    // push the mouse button
    DarwinSendPointerEvents(ButtonPress, whichButton, pointer_x, pointer_y);
    DarwinSendPointerEvents(ButtonRelease, whichButton, pointer_x, pointer_y);
d270 4
a273 2
    // restore old modifiers
    DarwinUpdateModifiers(KeyPress, modifierMask);
d276 8
d285 2
a286 11
Bool DarwinEQInit(DevicePtr pKbd, DevicePtr pPtr) { 
    darwinEvents = (xEvent *)malloc(sizeof(xEvent) * GetMaximumEventsNum());
    mieqInit();
    darwinEventQueue.head = darwinEventQueue.tail = 0;
    darwinEventQueue.lastEventTime = GetTimeInMillis ();
    darwinEventQueue.pKbd = pKbd;
    darwinEventQueue.pPtr = pPtr;
    darwinEventQueue.pEnqueueScreen = screenInfo.screens[0];
    darwinEventQueue.pDequeueScreen = darwinEventQueue.pEnqueueScreen;
    SetInputCheck(&input_check_zero, &input_check_flag);
    return TRUE;
d289 7
a295 34

/*
 * DarwinEQEnqueue
 *  Must be thread safe with ProcessInputEvents.
 *    DarwinEQEnqueue    - called from event gathering thread
 *    ProcessInputEvents - called from X server thread
 *  DarwinEQEnqueue should never be called from more than one thread.
 * 
 * This should be deprecated in favor of miEQEnqueue -- BB
 */
void DarwinEQEnqueue(const xEventPtr e) {
    HWEventQueueType oldtail, newtail;

    oldtail = darwinEventQueue.tail;

    // mieqEnqueue() collapses successive motion events into one event.
    // This is difficult to do in a thread-safe way and rarely useful.

    newtail = oldtail + 1;
    if (newtail == QUEUE_SIZE) newtail = 0;
    /* Toss events which come in late */
    if (newtail == darwinEventQueue.head) return;

    darwinEventQueue.events[oldtail].event = *e;

    /*
     * Make sure that event times don't go backwards - this
     * is "unnecessary", but very useful
     */
    if (e->u.keyButtonPointer.time < darwinEventQueue.lastEventTime &&
        darwinEventQueue.lastEventTime - e->u.keyButtonPointer.time < 10000)
    {
        darwinEventQueue.events[oldtail].event.u.keyButtonPointer.time =
        darwinEventQueue.lastEventTime;
a296 7
    darwinEventQueue.events[oldtail].pScreen = darwinEventQueue.pEnqueueScreen;

    // Update the tail after the event is prepared
    darwinEventQueue.tail = newtail;

    // Signal there is an event ready to handle
    DarwinPokeEQ();
d299 8
a306 8

/*
 * DarwinEQPointerPost
 *  Post a pointer event. Used by the mipointer.c routines.
 */
void DarwinEQPointerPost(DeviceIntPtr pdev, xEventPtr e) {
    (*darwinEventQueue.pPtr->processInputProc)
            (e, (DeviceIntPtr)darwinEventQueue.pPtr, 1);
d309 34
d344 4
a347 4
void DarwinEQSwitchScreen(ScreenPtr pScreen, Bool fromDIX) {
    darwinEventQueue.pEnqueueScreen = pScreen;
    if (fromDIX)
        darwinEventQueue.pDequeueScreen = pScreen;
a349 1

a354 2
    EventRec *e;
    int     x, y;
d356 3
a358 2
    // button number and modifier mask of currently pressed fake button
    input_check_flag=0;
a359 1
    //    ErrorF("calling mieqProcessInputEvents\n");
d363 54
a416 18
    x = sizeof(xe);
    while (x == sizeof(xe)) 
        x = read(darwinEventReadFD, &xe, sizeof(xe));

    while (darwinEventQueue.head != darwinEventQueue.tail)
    {
        if (screenIsSaved == SCREEN_SAVER_ON)
            dixSaveScreens (serverClient, SCREEN_SAVER_OFF, ScreenSaverReset);

        e = &darwinEventQueue.events[darwinEventQueue.head];
        xe = e->event;

        // Shift from global screen coordinates to coordinates relative to
        // the origin of the current screen.
        xe.u.keyButtonPointer.rootX -= darwinMainScreenX +
                dixScreenOrigins[miPointerCurrentScreen()->myNum].x;
        xe.u.keyButtonPointer.rootY -= darwinMainScreenY +
                dixScreenOrigins[miPointerCurrentScreen()->myNum].y;
d418 34
a451 19
	/*	ErrorF("old rootX = (%d,%d) darwinMainScreen = (%d,%d) dixScreenOrigins[%d]=(%d,%d)\n",
	       xe.u.keyButtonPointer.rootX, xe.u.keyButtonPointer.rootY,
	       darwinMainScreenX, darwinMainScreenY,
	       miPointerCurrentScreen()->myNum,
	       dixScreenOrigins[miPointerCurrentScreen()->myNum].x,
	       dixScreenOrigins[miPointerCurrentScreen()->myNum].y); */

	//Assumption - screen switching can only occur on motion events

        if (e->pScreen != darwinEventQueue.pDequeueScreen)
        {
            darwinEventQueue.pDequeueScreen = e->pScreen;
            x = xe.u.keyButtonPointer.rootX;
            y = xe.u.keyButtonPointer.rootY;
            if (darwinEventQueue.head == QUEUE_SIZE - 1)
                darwinEventQueue.head = 0;
            else
                ++darwinEventQueue.head;
            NewCurrentScreen (darwinEventQueue.pDequeueScreen, x, y);
a452 11
        else
        {
            if (darwinEventQueue.head == QUEUE_SIZE - 1)
                darwinEventQueue.head = 0;
            else
                ++darwinEventQueue.head;
            switch (xe.u.u.type) {
            case KeyPress:
            case KeyRelease:
	      ErrorF("Unexpected Keyboard event in DarwinProcessInputEvents\n");
	      break;
d454 5
a458 3
            case ButtonPress:
	      ErrorF("Unexpected ButtonPress event in DarwinProcessInputEvents\n");
                break;
d460 2
a461 3
            case ButtonRelease:
	      ErrorF("Unexpected ButtonRelease event in DarwinProcessInputEvents\n");
                break;
d463 8
a470 3
            case MotionNotify:
	      ErrorF("Unexpected ButtonRelease event in DarwinProcessInputEvents\n");
                break;
d472 2
a473 21
            case kXDarwinUpdateModifiers:
	      ErrorF("Unexpected ButtonRelease event in DarwinProcessInputEvents\n");
	      break;

            case kXDarwinUpdateButtons:
	      ErrorF("Unexpected XDarwinScrollWheel event in DarwinProcessInputEvents\n");
	      break;

            case kXDarwinScrollWheel: 
	      ErrorF("Unexpected XDarwinScrollWheel event in DarwinProcessInputEvents\n");
	      break;

			case kXDarwinDeactivate:
				DarwinReleaseModifiers();
				// fall through
            default:
                // Check for mode specific event
                QuartzProcessEvent(&xe);
            }
        }
    }
d475 38
a512 1
    //    miPointerUpdate();
a514 45
/* Sends a null byte down darwinEventWriteFD, which will cause the
   Dispatch() event loop to check out event queue */
void DarwinPokeEQ(void) {
  char nullbyte=0;
  input_check_flag++;
  //  <daniels> bushing: oh, i ... er ... christ.
  write(darwinEventWriteFD, &nullbyte, 1);
}

void DarwinSendPointerEvents(int ev_type, int ev_button, int pointer_x, int pointer_y) {
  static int darwinFakeMouseButtonDown = 0;
  static int darwinFakeMouseButtonMask = 0;
  int i, num_events;
  int valuators[2] = {pointer_x, pointer_y};
  if (ev_type == ButtonPress && darwinFakeButtons && ev_button == 1) {
    // Mimic multi-button mouse with modifier-clicks
    // If both sets of modifiers are pressed,
    // button 2 is clicked.
    if ((old_flags & darwinFakeMouse2Mask) == darwinFakeMouse2Mask) {
      DarwinSimulateMouseClick(pointer_x, pointer_y, 2, darwinFakeMouse2Mask);
      darwinFakeMouseButtonDown = 2;
      darwinFakeMouseButtonMask = darwinFakeMouse2Mask;
    } else if ((old_flags & darwinFakeMouse3Mask) == darwinFakeMouse3Mask) {
      DarwinSimulateMouseClick(pointer_x, pointer_y, 3, darwinFakeMouse3Mask);
      darwinFakeMouseButtonDown = 3;
      darwinFakeMouseButtonMask = darwinFakeMouse3Mask;
    }
  }
  if (ev_type == ButtonRelease && darwinFakeButtons && darwinFakeMouseButtonDown) {
    // If last mousedown was a fake click, don't check for
    // mouse modifiers here. The user may have released the
    // modifiers before the mouse button.
    ev_button = darwinFakeMouseButtonDown;
    darwinFakeMouseButtonDown = 0;
    // Bring modifiers back up to date
    DarwinUpdateModifiers(KeyPress, darwinFakeMouseButtonMask & old_flags);
    darwinFakeMouseButtonMask = 0;
  } 

  num_events = GetPointerEvents(darwinEvents, darwinPointer, ev_type, ev_button, 
				POINTER_ABSOLUTE, 0, 2, valuators);
      
  for(i=0; i<num_events; i++) mieqEnqueue (darwinPointer,&darwinEvents[i]);
  DarwinPokeEQ();
}
d516 26
a541 35
void DarwinSendKeyboardEvents(int ev_type, int keycode) {
  int i, num_events;
  if (old_flags == 0 && darwinSyncKeymap && darwinKeymapFile == NULL) {
    /* See if keymap has changed. */

    static unsigned int last_seed;
    unsigned int this_seed;

    this_seed = QuartzSystemKeymapSeed();
    if (this_seed != last_seed) {
      last_seed = this_seed;
      DarwinKeyboardReload(darwinKeyboard);
    }
  }

  num_events = GetKeyboardEvents(darwinEvents, darwinKeyboard, ev_type, keycode + MIN_KEYCODE);
  for(i=0; i<num_events; i++) mieqEnqueue(darwinKeyboard,&darwinEvents[i]);
  DarwinPokeEQ();
}

/* Send the appropriate number of button 4 / 5 clicks to emulate scroll wheel */
void DarwinSendScrollEvents(float count, int pointer_x, int pointer_y) {
  int i;
  int ev_button = count > 0.0f ? 4 : 5;
  int valuators[2] = {pointer_x, pointer_y};

  for (count = fabs(count); count > 0.0; count = count - 1.0f) {
    int num_events = GetPointerEvents(darwinEvents, darwinPointer, ButtonPress, ev_button, 
				      POINTER_ABSOLUTE, 0, 2, valuators);
    for(i=0; i<num_events; i++) mieqEnqueue(darwinPointer,&darwinEvents[i]);
    num_events = GetPointerEvents(darwinEvents, darwinPointer, ButtonRelease, ev_button, 
				      POINTER_ABSOLUTE, 0, 2, valuators);
    for(i=0; i<num_events; i++) mieqEnqueue(darwinPointer,&darwinEvents[i]);
  }
  DarwinPokeEQ();
d547 33
a579 3
  DarwinUpdateModifiers(KeyRelease, old_flags & ~flags);
  DarwinUpdateModifiers(KeyPress, ~old_flags & flags);
  old_flags = flags;
@

