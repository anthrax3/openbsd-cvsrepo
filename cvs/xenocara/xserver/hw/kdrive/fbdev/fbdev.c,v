head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.8
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.8
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.18;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.16;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.04.09;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright Â© 1999 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif
#include "fbdev.h"
#include <sys/ioctl.h>

#include <errno.h>

const char *fbdevDevicePath = NULL;

static Bool
fbdevInitialize(KdCardInfo * card, FbdevPriv * priv)
{
    unsigned long off;

    if (fbdevDevicePath == NULL)
        fbdevDevicePath = "/dev/fb0";

    if ((priv->fd = open(fbdevDevicePath, O_RDWR)) < 0) {
        ErrorF("Error opening framebuffer %s: %s\n",
               fbdevDevicePath, strerror(errno));
        return FALSE;
    }

    /* quiet valgrind */
    memset(&priv->fix, '\0', sizeof(priv->fix));
    if (ioctl(priv->fd, FBIOGET_FSCREENINFO, &priv->fix) < 0) {
        perror("Error with /dev/fb ioctl FIOGET_FSCREENINFO");
        close(priv->fd);
        return FALSE;
    }
    /* quiet valgrind */
    memset(&priv->var, '\0', sizeof(priv->var));
    if (ioctl(priv->fd, FBIOGET_VSCREENINFO, &priv->var) < 0) {
        perror("Error with /dev/fb ioctl FIOGET_VSCREENINFO");
        close(priv->fd);
        return FALSE;
    }

    priv->fb_base = (char *) mmap((caddr_t) NULL,
                                  priv->fix.smem_len,
                                  PROT_READ | PROT_WRITE,
                                  MAP_SHARED, priv->fd, 0);

    if (priv->fb_base == (char *) -1) {
        perror("ERROR: mmap framebuffer fails!");
        close(priv->fd);
        return FALSE;
    }
    off = (unsigned long) priv->fix.smem_start % (unsigned long) getpagesize();
    priv->fb = priv->fb_base + off;
    return TRUE;
}

Bool
fbdevCardInit(KdCardInfo * card)
{
    FbdevPriv *priv;

    priv = (FbdevPriv *) malloc(sizeof(FbdevPriv));
    if (!priv)
        return FALSE;

    if (!fbdevInitialize(card, priv)) {
        free(priv);
        return FALSE;
    }
    card->driver = priv;

    return TRUE;
}

static Pixel
fbdevMakeContig(Pixel orig, Pixel others)
{
    Pixel low;

    low = lowbit(orig) >> 1;
    while (low && (others & low) == 0) {
        orig |= low;
        low >>= 1;
    }
    return orig;
}

static Bool
fbdevModeSupported(KdScreenInfo * screen, const KdMonitorTiming * t)
{
    return TRUE;
}

static void
fbdevConvertMonitorTiming(const KdMonitorTiming * t,
                          struct fb_var_screeninfo *var)
{
    memset(var, 0, sizeof(struct fb_var_screeninfo));

    var->xres = t->horizontal;
    var->yres = t->vertical;
    var->xres_virtual = t->horizontal;
    var->yres_virtual = t->vertical;
    var->xoffset = 0;
    var->yoffset = 0;
    var->pixclock = t->clock ? 1000000000 / t->clock : 0;
    var->left_margin = t->hbp;
    var->right_margin = t->hfp;
    var->upper_margin = t->vbp;
    var->lower_margin = t->vfp;
    var->hsync_len = t->hblank - t->hfp - t->hbp;
    var->vsync_len = t->vblank - t->vfp - t->vbp;

    var->sync = 0;
    var->vmode = 0;

    if (t->hpol == KdSyncPositive)
        var->sync |= FB_SYNC_HOR_HIGH_ACT;
    if (t->vpol == KdSyncPositive)
        var->sync |= FB_SYNC_VERT_HIGH_ACT;
}

static Bool
fbdevScreenInitialize(KdScreenInfo * screen, FbdevScrPriv * scrpriv)
{
    FbdevPriv *priv = screen->card->driver;
    Pixel allbits;
    int depth;
    Bool gray;
    struct fb_var_screeninfo var;
    const KdMonitorTiming *t;
    int k;

    k = ioctl(priv->fd, FBIOGET_VSCREENINFO, &var);

    if (!screen->width || !screen->height) {
        if (k >= 0) {
            screen->width = var.xres;
            screen->height = var.yres;
        }
        else {
            screen->width = 1024;
            screen->height = 768;
        }
        screen->rate = 103;     /* FIXME: should get proper value from fb driver */
    }
    if (!screen->fb.depth) {
        if (k >= 0)
            screen->fb.depth = var.bits_per_pixel;
        else
            screen->fb.depth = 16;
    }

    if ((screen->width != var.xres) || (screen->height != var.yres)) {
        t = KdFindMode(screen, fbdevModeSupported);
        screen->rate = t->rate;
        screen->width = t->horizontal;
        screen->height = t->vertical;

        /* Now try setting the mode */
        if (k < 0 || (t->horizontal != var.xres || t->vertical != var.yres))
            fbdevConvertMonitorTiming(t, &var);
    }

    var.activate = FB_ACTIVATE_NOW;
    var.bits_per_pixel = screen->fb.depth;
    var.nonstd = 0;
    var.grayscale = 0;

    k = ioctl(priv->fd, FBIOPUT_VSCREENINFO, &var);

    if (k < 0) {
        fprintf(stderr, "error: %s\n", strerror(errno));
        return FALSE;
    }

    /* Re-get the "fixed" parameters since they might have changed */
    k = ioctl(priv->fd, FBIOGET_FSCREENINFO, &priv->fix);
    if (k < 0)
        perror("FBIOGET_FSCREENINFO");

    /* Now get the new screeninfo */
    ioctl(priv->fd, FBIOGET_VSCREENINFO, &priv->var);
    depth = priv->var.bits_per_pixel;
    gray = priv->var.grayscale;

    /* Calculate fix.line_length if it's zero */
    if (!priv->fix.line_length)
        priv->fix.line_length = (priv->var.xres_virtual * depth + 7) / 8;

    switch (priv->fix.visual) {
    case FB_VISUAL_MONO01:
    case FB_VISUAL_MONO10:
        screen->fb.visuals = (1 << StaticGray);
        break;
    case FB_VISUAL_PSEUDOCOLOR:
        screen->fb.visuals = (1 << StaticGray);
        if (priv->var.bits_per_pixel == 1) {
            /* Override to monochrome, to have preallocated black/white */
            priv->fix.visual = FB_VISUAL_MONO01;
        } else if (gray) {
            /* could also support GrayScale, but what's the point? */
        } else {
            screen->fb.visuals = ((1 << StaticGray) |
                                  (1 << GrayScale) |
                                  (1 << StaticColor) |
                                  (1 << PseudoColor) |
                                  (1 << TrueColor) | (1 << DirectColor));
        }
        screen->fb.blueMask = 0x00;
        screen->fb.greenMask = 0x00;
        screen->fb.redMask = 0x00;
        break;
    case FB_VISUAL_STATIC_PSEUDOCOLOR:
        if (gray) {
            screen->fb.visuals = (1 << StaticGray);
        }
        else {
            screen->fb.visuals = (1 << StaticColor);
        }
        screen->fb.blueMask = 0x00;
        screen->fb.greenMask = 0x00;
        screen->fb.redMask = 0x00;
        break;
    case FB_VISUAL_TRUECOLOR:
    case FB_VISUAL_DIRECTCOLOR:
        screen->fb.visuals = (1 << TrueColor);
#define Mask(o,l)   (((1 << l) - 1) << o)
        screen->fb.redMask = Mask (priv->var.red.offset, priv->var.red.length);
        screen->fb.greenMask =
            Mask (priv->var.green.offset, priv->var.green.length);
        screen->fb.blueMask =
            Mask (priv->var.blue.offset, priv->var.blue.length);

        /*
         * This is a kludge so that Render will work -- fill in the gaps
         * in the pixel
         */
        screen->fb.redMask = fbdevMakeContig(screen->fb.redMask,
                                             screen->fb.greenMask |
                                             screen->fb.blueMask);

        screen->fb.greenMask = fbdevMakeContig(screen->fb.greenMask,
                                               screen->fb.redMask |
                                               screen->fb.blueMask);

        screen->fb.blueMask = fbdevMakeContig(screen->fb.blueMask,
                                              screen->fb.redMask |
                                              screen->fb.greenMask);

        allbits =
            screen->fb.redMask | screen->fb.greenMask | screen->fb.blueMask;
        depth = 32;
        while (depth && !(allbits & (1 << (depth - 1))))
            depth--;
        break;
    default:
        return FALSE;
        break;
    }
    screen->fb.depth = depth;
    screen->fb.bitsPerPixel = priv->var.bits_per_pixel;

    scrpriv->randr = screen->randr;

    return fbdevMapFramebuffer(screen);
}

Bool
fbdevScreenInit(KdScreenInfo * screen)
{
    FbdevScrPriv *scrpriv;

    scrpriv = calloc(1, sizeof(FbdevScrPriv));
    if (!scrpriv)
        return FALSE;
    screen->driver = scrpriv;
    if (!fbdevScreenInitialize(screen, scrpriv)) {
        screen->driver = 0;
        free(scrpriv);
        return FALSE;
    }
    return TRUE;
}

static void *
fbdevWindowLinear(ScreenPtr pScreen,
                  CARD32 row,
                  CARD32 offset, int mode, CARD32 *size, void *closure)
{
    KdScreenPriv(pScreen);
    FbdevPriv *priv = pScreenPriv->card->driver;

    if (!pScreenPriv->enabled)
        return 0;
    *size = priv->fix.line_length;
    return (CARD8 *) priv->fb + row * priv->fix.line_length + offset;
}

static void *
fbdevWindowAfb(ScreenPtr pScreen,
               CARD32 row,
               CARD32 offset, int mode, CARD32 *size, void *closure)
{
    KdScreenPriv(pScreen);
    FbdevPriv *priv = pScreenPriv->card->driver;

    if (!pScreenPriv->enabled)
        return 0;
    /* offset to next plane */
    *size = priv->var.yres_virtual * priv->fix.line_length;
    return (CARD8 *) priv->fb + row * priv->fix.line_length + offset;
}

Bool
fbdevMapFramebuffer(KdScreenInfo * screen)
{
    FbdevScrPriv *scrpriv = screen->driver;
    KdPointerMatrix m;
    FbdevPriv *priv = screen->card->driver;

    if (scrpriv->randr != RR_Rotate_0 ||
        priv->fix.type != FB_TYPE_PACKED_PIXELS)
        scrpriv->shadow = TRUE;
    else
        scrpriv->shadow = FALSE;

    KdComputePointerMatrix(&m, scrpriv->randr, screen->width, screen->height);

    KdSetPointerMatrix(&m);

    screen->width = priv->var.xres;
    screen->height = priv->var.yres;

    if (scrpriv->shadow) {
        if (!KdShadowFbAlloc(screen,
                             scrpriv->randr & (RR_Rotate_90 | RR_Rotate_270)))
            return FALSE;
    }
    else {
        screen->fb.byteStride = priv->fix.line_length;
        screen->fb.pixelStride = (priv->fix.line_length * 8 /
                                  priv->var.bits_per_pixel);
        screen->fb.frameBuffer = (CARD8 *) (priv->fb);
    }

    return TRUE;
}

static void
fbdevSetScreenSizes(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    FbdevScrPriv *scrpriv = screen->driver;
    FbdevPriv *priv = screen->card->driver;

    if (scrpriv->randr & (RR_Rotate_0 | RR_Rotate_180)) {
        pScreen->width = priv->var.xres;
        pScreen->height = priv->var.yres;
        pScreen->mmWidth = screen->width_mm;
        pScreen->mmHeight = screen->height_mm;
    }
    else {
        pScreen->width = priv->var.yres;
        pScreen->height = priv->var.xres;
        pScreen->mmWidth = screen->height_mm;
        pScreen->mmHeight = screen->width_mm;
    }
}

static Bool
fbdevUnmapFramebuffer(KdScreenInfo * screen)
{
    KdShadowFbFree(screen);
    return TRUE;
}

static Bool
fbdevSetShadow(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    FbdevScrPriv *scrpriv = screen->driver;
    FbdevPriv *priv = screen->card->driver;
    ShadowUpdateProc update;
    ShadowWindowProc window;
    int useYX = 0;

#ifdef __arm__
    /* Use variant copy routines that always read left to right in the
       shadow framebuffer.  Reading vertical strips is exceptionally
       slow on XScale due to cache effects.  */
    useYX = 1;
#endif

    window = fbdevWindowLinear;
    update = 0;
    switch (priv->fix.type) {
    case FB_TYPE_PACKED_PIXELS:
        if (scrpriv->randr)
            if (priv->var.bits_per_pixel == 16) {
                switch (scrpriv->randr) {
                case RR_Rotate_90:
                    if (useYX)
                        update = shadowUpdateRotate16_90YX;
                    else
                        update = shadowUpdateRotate16_90;
                    break;
                case RR_Rotate_180:
                    update = shadowUpdateRotate16_180;
                    break;
                case RR_Rotate_270:
                    if (useYX)
                        update = shadowUpdateRotate16_270YX;
                    else
                        update = shadowUpdateRotate16_270;
                    break;
                default:
                    update = shadowUpdateRotate16;
                    break;
                }
            }
            else
                update = shadowUpdateRotatePacked;
        else
            update = shadowUpdatePacked;
        break;

    case FB_TYPE_PLANES:
        window = fbdevWindowAfb;
        switch (priv->var.bits_per_pixel) {
        case 4:
            update = shadowUpdateAfb4;
            break;

        case 8:
            update = shadowUpdateAfb8;
            break;

        default:
            FatalError("Bitplanes with bpp %u are not yet supported\n",
                       priv->var.bits_per_pixel);
        }
        break;

    case FB_TYPE_INTERLEAVED_PLANES:
        if (priv->fix.type_aux == 2) {
            switch (priv->var.bits_per_pixel) {
            case 4:
                update = shadowUpdateIplan2p4;
                break;

            case 8:
                update = shadowUpdateIplan2p8;
                break;

            default:
                FatalError("Atari interleaved bitplanes with bpp %u are not yet supported\n",
                           priv->var.bits_per_pixel);
            }
        } else {
            FatalError("Interleaved bitplanes with interleave %u are not yet supported\n",
                       priv->fix.type_aux);
        }
        break;

    case FB_TYPE_TEXT:
        FatalError("Text frame buffers are not yet supported\n");
        break;

    case FB_TYPE_VGA_PLANES:
        FatalError("VGA planes are not yet supported\n");
        break;

    default:
        FatalError("Unsupported frame buffer type %u\n", priv->fix.type);
        break;
    }

    return KdShadowSet(pScreen, scrpriv->randr, update, window);
}

#ifdef RANDR
static Bool
fbdevRandRGetInfo(ScreenPtr pScreen, Rotation * rotations)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    FbdevScrPriv *scrpriv = screen->driver;
    RRScreenSizePtr pSize;
    Rotation randr;
    int n;

    *rotations = RR_Rotate_All | RR_Reflect_All;

    for (n = 0; n < pScreen->numDepths; n++)
        if (pScreen->allowedDepths[n].numVids)
            break;
    if (n == pScreen->numDepths)
        return FALSE;

    pSize = RRRegisterSize(pScreen,
                           screen->width,
                           screen->height, screen->width_mm, screen->height_mm);

    randr = KdSubRotation(scrpriv->randr, screen->randr);

    RRSetCurrentConfig(pScreen, randr, 0, pSize);

    return TRUE;
}

static Bool
fbdevRandRSetConfig(ScreenPtr pScreen,
                    Rotation randr, int rate, RRScreenSizePtr pSize)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    FbdevScrPriv *scrpriv = screen->driver;
    Bool wasEnabled = pScreenPriv->enabled;
    FbdevScrPriv oldscr;
    int oldwidth;
    int oldheight;
    int oldmmwidth;
    int oldmmheight;
    int newwidth, newheight, newmmwidth, newmmheight;

    if (screen->randr & (RR_Rotate_0 | RR_Rotate_180)) {
        newwidth = pSize->width;
        newheight = pSize->height;
        newmmwidth = pSize->mmWidth;
        newmmheight = pSize->mmHeight;
    }
    else {
        newwidth = pSize->height;
        newheight = pSize->width;
        newmmwidth = pSize->mmHeight;
        newmmheight = pSize->mmWidth;
    }

    if (wasEnabled)
        KdDisableScreen(pScreen);

    oldscr = *scrpriv;

    oldwidth = screen->width;
    oldheight = screen->height;
    oldmmwidth = pScreen->mmWidth;
    oldmmheight = pScreen->mmHeight;

    /*
     * Set new configuration
     */

    scrpriv->randr = KdAddRotation(screen->randr, randr);
    pScreen->width = newwidth;
    pScreen->height = newheight;
    pScreen->mmWidth = newmmwidth;
    pScreen->mmHeight = newmmheight;

    fbdevUnmapFramebuffer(screen);

    if (!fbdevMapFramebuffer(screen))
        goto bail4;

    KdShadowUnset(screen->pScreen);

    if (!fbdevSetShadow(screen->pScreen))
        goto bail4;

    fbdevSetScreenSizes(screen->pScreen);

    /*
     * Set frame buffer mapping
     */
    (*pScreen->ModifyPixmapHeader) (fbGetScreenPixmap(pScreen),
                                    pScreen->width,
                                    pScreen->height,
                                    screen->fb.depth,
                                    screen->fb.bitsPerPixel,
                                    screen->fb.byteStride,
                                    screen->fb.frameBuffer);

    /* set the subpixel order */

    KdSetSubpixelOrder(pScreen, scrpriv->randr);
    if (wasEnabled)
        KdEnableScreen(pScreen);

    return TRUE;

 bail4:
    fbdevUnmapFramebuffer(screen);
    *scrpriv = oldscr;
    (void) fbdevMapFramebuffer(screen);
    pScreen->width = oldwidth;
    pScreen->height = oldheight;
    pScreen->mmWidth = oldmmwidth;
    pScreen->mmHeight = oldmmheight;

    if (wasEnabled)
        KdEnableScreen(pScreen);
    return FALSE;
}

static Bool
fbdevRandRInit(ScreenPtr pScreen)
{
    rrScrPrivPtr pScrPriv;

    if (!RRScreenInit(pScreen))
        return FALSE;

    pScrPriv = rrGetScrPriv(pScreen);
    pScrPriv->rrGetInfo = fbdevRandRGetInfo;
    pScrPriv->rrSetConfig = fbdevRandRSetConfig;
    return TRUE;
}
#endif

static Bool
fbdevCreateColormap(ColormapPtr pmap)
{
    ScreenPtr pScreen = pmap->pScreen;

    KdScreenPriv(pScreen);
    FbdevPriv *priv = pScreenPriv->card->driver;
    VisualPtr pVisual;
    int i;
    int nent;
    xColorItem *pdefs;

    switch (priv->fix.visual) {
    case FB_VISUAL_MONO01:
        pScreen->whitePixel = 0;
        pScreen->blackPixel = 1;
        pmap->red[0].co.local.red = 65535;
        pmap->red[0].co.local.green = 65535;
        pmap->red[0].co.local.blue = 65535;
        pmap->red[1].co.local.red = 0;
        pmap->red[1].co.local.green = 0;
        pmap->red[1].co.local.blue = 0;
        return TRUE;
    case FB_VISUAL_MONO10:
        pScreen->blackPixel = 0;
        pScreen->whitePixel = 1;
        pmap->red[0].co.local.red = 0;
        pmap->red[0].co.local.green = 0;
        pmap->red[0].co.local.blue = 0;
        pmap->red[1].co.local.red = 65535;
        pmap->red[1].co.local.green = 65535;
        pmap->red[1].co.local.blue = 65535;
        return TRUE;
    case FB_VISUAL_STATIC_PSEUDOCOLOR:
        pVisual = pmap->pVisual;
        nent = pVisual->ColormapEntries;
        pdefs = xallocarray(nent, sizeof(xColorItem));
        if (!pdefs)
            return FALSE;
        for (i = 0; i < nent; i++)
            pdefs[i].pixel = i;
        fbdevGetColors(pScreen, nent, pdefs);
        for (i = 0; i < nent; i++) {
            pmap->red[i].co.local.red = pdefs[i].red;
            pmap->red[i].co.local.green = pdefs[i].green;
            pmap->red[i].co.local.blue = pdefs[i].blue;
        }
        free(pdefs);
        return TRUE;
    default:
        return fbInitializeColormap(pmap);
    }
}

Bool
fbdevInitScreen(ScreenPtr pScreen)
{
    pScreen->CreateColormap = fbdevCreateColormap;
    return TRUE;
}

Bool
fbdevFinishInitScreen(ScreenPtr pScreen)
{
    if (!shadowSetup(pScreen))
        return FALSE;

#ifdef RANDR
    if (!fbdevRandRInit(pScreen))
        return FALSE;
#endif

    return TRUE;
}

Bool
fbdevCreateResources(ScreenPtr pScreen)
{
    return fbdevSetShadow(pScreen);
}

void
fbdevPreserve(KdCardInfo * card)
{
}

static int
fbdevUpdateFbColormap(FbdevPriv * priv, int minidx, int maxidx)
{
    struct fb_cmap cmap;

    cmap.start = minidx;
    cmap.len = maxidx - minidx + 1;
    cmap.red = &priv->red[minidx];
    cmap.green = &priv->green[minidx];
    cmap.blue = &priv->blue[minidx];
    cmap.transp = 0;

    return ioctl(priv->fd, FBIOPUTCMAP, &cmap);
}

Bool
fbdevEnable(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    FbdevPriv *priv = pScreenPriv->card->driver;
    int k;

    priv->var.activate = FB_ACTIVATE_NOW | FB_CHANGE_CMAP_VBL;

    /* display it on the LCD */
    k = ioctl(priv->fd, FBIOPUT_VSCREENINFO, &priv->var);
    if (k < 0) {
        perror("FBIOPUT_VSCREENINFO");
        return FALSE;
    }

    if (priv->fix.visual == FB_VISUAL_DIRECTCOLOR) {
        int i;

        for (i = 0;
             i < (1 << priv->var.red.length) ||
             i < (1 << priv->var.green.length) ||
             i < (1 << priv->var.blue.length); i++) {
            priv->red[i] = i * 65535 / ((1 << priv->var.red.length) - 1);
            priv->green[i] = i * 65535 / ((1 << priv->var.green.length) - 1);
            priv->blue[i] = i * 65535 / ((1 << priv->var.blue.length) - 1);
        }

        fbdevUpdateFbColormap(priv, 0, i);
    }
    return TRUE;
}

Bool
fbdevDPMS(ScreenPtr pScreen, int mode)
{
    KdScreenPriv(pScreen);
    FbdevPriv *priv = pScreenPriv->card->driver;
    static int oldmode = -1;

    if (mode == oldmode)
        return TRUE;
#ifdef FBIOPUT_POWERMODE
    if (ioctl(priv->fd, FBIOPUT_POWERMODE, &mode) >= 0) {
        oldmode = mode;
        return TRUE;
    }
#endif
#ifdef FBIOBLANK
    if (ioctl(priv->fd, FBIOBLANK, mode ? mode + 1 : 0) >= 0) {
        oldmode = mode;
        return TRUE;
    }
#endif
    return FALSE;
}

void
fbdevDisable(ScreenPtr pScreen)
{
}

void
fbdevRestore(KdCardInfo * card)
{
}

void
fbdevScreenFini(KdScreenInfo * screen)
{
}

void
fbdevCardFini(KdCardInfo * card)
{
    FbdevPriv *priv = card->driver;

    munmap(priv->fb_base, priv->fix.smem_len);
    close(priv->fd);
    free(priv);
}

/*
 * Retrieve actual colormap and return selected n entries in pdefs.
 */
void
fbdevGetColors(ScreenPtr pScreen, int n, xColorItem * pdefs)
{
    KdScreenPriv(pScreen);
    FbdevPriv *priv = pScreenPriv->card->driver;
    struct fb_cmap cmap;
    int p;
    int k;
    int min, max;

    min = 256;
    max = 0;
    for (k = 0; k < n; k++) {
        if (pdefs[k].pixel < min)
            min = pdefs[k].pixel;
        if (pdefs[k].pixel > max)
            max = pdefs[k].pixel;
    }
    cmap.start = min;
    cmap.len = max - min + 1;
    cmap.red = &priv->red[min];
    cmap.green = &priv->green[min];
    cmap.blue = &priv->blue[min];
    cmap.transp = 0;
    k = ioctl(priv->fd, FBIOGETCMAP, &cmap);
    if (k < 0) {
        perror("can't get colormap");
        return;
    }
    while (n--) {
        p = pdefs->pixel;
        pdefs->red = priv->red[p];
        pdefs->green = priv->green[p];
        pdefs->blue = priv->blue[p];
        pdefs++;
    }
}

/*
 * Change colormap by updating n entries described in pdefs.
 */
void
fbdevPutColors(ScreenPtr pScreen, int n, xColorItem * pdefs)
{
    KdScreenPriv(pScreen);
    FbdevPriv *priv = pScreenPriv->card->driver;
    int p;
    int min, max;

    min = 256;
    max = 0;
    while (n--) {
        p = pdefs->pixel;
        priv->red[p] = pdefs->red;
        priv->green[p] = pdefs->green;
        priv->blue[p] = pdefs->blue;
        if (p < min)
            min = p;
        if (p > max)
            max = p;
        pdefs++;
    }

    fbdevUpdateFbColormap(priv, min, max);
}
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a30 2
extern int KdTsPhyScreen;

d678 1
a678 1
        pdefs = malloc(nent * sizeof(xColorItem));
a698 4
#ifdef TOUCHSCREEN
    KdTsPhyScreen = pScreen->myNum;
#endif

@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d33 1
a33 1
char *fbdevDevicePath = NULL;
d209 4
d214 4
d219 5
a223 2
        if (gray) {
            screen->fb.visuals = (1 << StaticGray);
d225 1
a225 2
        }
        else {
d322 15
d344 2
a345 1
    if (scrpriv->randr != RR_Rotate_0)
d421 53
a473 8
    if (scrpriv->randr)
        if (priv->var.bits_per_pixel == 16) {
            switch (scrpriv->randr) {
            case RR_Rotate_90:
                if (useYX)
                    update = shadowUpdateRotate16_90YX;
                else
                    update = shadowUpdateRotate16_90;
d475 3
a477 8
            case RR_Rotate_180:
                update = shadowUpdateRotate16_180;
                break;
            case RR_Rotate_270:
                if (useYX)
                    update = shadowUpdateRotate16_270YX;
                else
                    update = shadowUpdateRotate16_270;
d479 1
d481 2
a482 2
                update = shadowUpdateRotate16;
                break;
d484 3
d488 15
a502 4
        else
            update = shadowUpdateRotatePacked;
    else
        update = shadowUpdatePacked;
d549 1
a549 1
    int newwidth, newheight;
d554 2
d560 2
d579 4
d657 20
@


1.6
log
@Update to xserver 1.11.2
@
text
@d36 1
a36 1
fbdevInitialize (KdCardInfo *card, FbdevPriv *priv)
d38 1
a38 1
    unsigned long   off;
d41 1
a41 1
      fbdevDevicePath = "/dev/fb0";
d43 3
a45 4
    if ((priv->fd = open(fbdevDevicePath, O_RDWR)) < 0)
      {
	ErrorF("Error opening framebuffer %s: %s\n",
	       fbdevDevicePath, strerror(errno));
d47 1
a47 1
      }
d50 1
a50 1
    memset (&priv->fix, '\0', sizeof (priv->fix));
d52 3
a54 3
	perror("Error with /dev/fb ioctl FIOGET_FSCREENINFO");
	close (priv->fd);
	return FALSE;
d57 1
a57 1
    memset (&priv->var, '\0', sizeof (priv->var));
d59 3
a61 3
	perror("Error with /dev/fb ioctl FIOGET_VSCREENINFO");
	close (priv->fd);
	return FALSE;
d64 4
a67 5
    priv->fb_base = (char *) mmap ((caddr_t) NULL,
				   priv->fix.smem_len,
				   PROT_READ|PROT_WRITE,
				   MAP_SHARED,
				   priv->fd, 0);
d69 1
a69 2
    if (priv->fb_base == (char *)-1)
    {
d71 2
a72 2
	close (priv->fd);
	return FALSE;
d80 1
a80 1
fbdevCardInit (KdCardInfo *card)
d82 1
a82 1
    FbdevPriv	*priv;
d84 1
a84 1
    priv = (FbdevPriv *) malloc(sizeof (FbdevPriv));
d86 1
a86 1
	return FALSE;
d88 3
a90 4
    if (!fbdevInitialize (card, priv))
    {
	free(priv);
	return FALSE;
d98 1
a98 1
fbdevMakeContig (Pixel orig, Pixel others)
d100 1
a100 1
    Pixel   low;
d102 4
a105 5
    low = lowbit (orig) >> 1;
    while (low && (others & low) == 0)
    {
	orig |= low;
	low >>= 1;
d111 1
a111 2
fbdevModeSupported (KdScreenInfo		*screen,
		    const KdMonitorTiming	*t)
d117 2
a118 1
fbdevConvertMonitorTiming (const KdMonitorTiming *t, struct fb_var_screeninfo *var)
d120 1
a120 1
    memset (var, 0, sizeof (struct fb_var_screeninfo));
d140 1
a140 1
      var->sync |= FB_SYNC_HOR_HIGH_ACT;
d142 1
a142 1
      var->sync |= FB_SYNC_VERT_HIGH_ACT;
d146 1
a146 1
fbdevScreenInitialize (KdScreenInfo *screen, FbdevScrPriv *scrpriv)
d148 4
a151 4
    FbdevPriv	*priv = screen->card->driver;
    Pixel	allbits;
    int		depth;
    Bool	gray;
d156 1
a156 1
    k = ioctl (priv->fd, FBIOGET_VSCREENINFO, &var);
d158 27
a184 32
    if (!screen->width || !screen->height)
    {
	if (k >= 0)
	{
	    screen->width = var.xres;
	    screen->height = var.yres;
	}
	else
	{
	    screen->width = 1024;
	    screen->height = 768;
	}
	screen->rate = 103; /* FIXME: should get proper value from fb driver */
    }
    if (!screen->fb.depth)
    {
	if (k >= 0)
	    screen->fb.depth = var.bits_per_pixel;
	else
	    screen->fb.depth = 16;
    }

    if ((screen->width != var.xres) || (screen->height != var.yres))
    {
      t = KdFindMode (screen, fbdevModeSupported);
      screen->rate = t->rate;
      screen->width = t->horizontal;
      screen->height = t->vertical;

      /* Now try setting the mode */
      if (k < 0 || (t->horizontal != var.xres || t->vertical != var.yres))
          fbdevConvertMonitorTiming (t, &var);
d192 1
a192 1
    k = ioctl (priv->fd, FBIOPUT_VSCREENINFO, &var);
d194 3
a196 4
    if (k < 0)
    {
	fprintf (stderr, "error: %s\n", strerror (errno));
	return FALSE;
d200 1
a200 1
    k = ioctl (priv->fd, FBIOGET_FSCREENINFO, &priv->fix);
d202 1
a202 1
        perror ("FBIOGET_FSCREENINFO");
d205 1
a205 1
    ioctl (priv->fd, FBIOGET_VSCREENINFO, &priv->var);
d211 15
a225 18
	if (gray)
	{
	    screen->fb.visuals = (1 << StaticGray);
	    /* could also support GrayScale, but what's the point? */
	}
	else
	{
	    screen->fb.visuals = ((1 << StaticGray) |
			       (1 << GrayScale) |
			       (1 << StaticColor) |
			       (1 << PseudoColor) |
			       (1 << TrueColor) |
			       (1 << DirectColor));
	}
	screen->fb.blueMask  = 0x00;
	screen->fb.greenMask = 0x00;
	screen->fb.redMask   = 0x00;
	break;
d227 10
a236 12
	if (gray)
	{
	    screen->fb.visuals = (1 << StaticGray);
	}
	else
	{
	    screen->fb.visuals = (1 << StaticColor);
	}
	screen->fb.blueMask  = 0x00;
	screen->fb.greenMask = 0x00;
	screen->fb.redMask   = 0x00;
	break;
d239 1
a239 1
	screen->fb.visuals = (1 << TrueColor);
d241 28
a268 25
	screen->fb.redMask = Mask (priv->var.red.offset, priv->var.red.length);
	screen->fb.greenMask = Mask (priv->var.green.offset, priv->var.green.length);
	screen->fb.blueMask = Mask (priv->var.blue.offset, priv->var.blue.length);

	/*
	 * This is a kludge so that Render will work -- fill in the gaps
	 * in the pixel
	 */
	screen->fb.redMask = fbdevMakeContig (screen->fb.redMask,
						 screen->fb.greenMask|
						 screen->fb.blueMask);

	screen->fb.greenMask = fbdevMakeContig (screen->fb.greenMask,
						   screen->fb.redMask|
						   screen->fb.blueMask);

	screen->fb.blueMask = fbdevMakeContig (screen->fb.blueMask,
						  screen->fb.redMask|
						  screen->fb.greenMask);

	allbits = screen->fb.redMask | screen->fb.greenMask | screen->fb.blueMask;
	depth = 32;
	while (depth && !(allbits & (1 << (depth - 1))))
	    depth--;
	break;
d270 2
a271 2
	return FALSE;
	break;
d278 1
a278 1
    return fbdevMapFramebuffer (screen);
d282 1
a282 1
fbdevScreenInit (KdScreenInfo *screen)
d286 1
a286 1
    scrpriv = calloc(1, sizeof (FbdevScrPriv));
d288 1
a288 1
	return FALSE;
d290 4
a293 5
    if (!fbdevScreenInitialize (screen, scrpriv))
    {
	screen->driver = 0;
	free(scrpriv);
	return FALSE;
d299 3
a301 6
fbdevWindowLinear (ScreenPtr	pScreen,
		   CARD32	row,
		   CARD32	offset,
		   int		mode,
		   CARD32	*size,
		   void		*closure)
d304 1
a304 1
    FbdevPriv	    *priv = pScreenPriv->card->driver;
d307 1
a307 1
	return 0;
d313 1
a313 1
fbdevMapFramebuffer (KdScreenInfo *screen)
d315 3
a317 3
    FbdevScrPriv	*scrpriv = screen->driver;
    KdPointerMatrix	m;
    FbdevPriv		*priv = screen->card->driver;
d320 1
a320 1
	scrpriv->shadow = TRUE;
d322 1
a322 1
	scrpriv->shadow = FALSE;
d324 1
a324 1
    KdComputePointerMatrix (&m, scrpriv->randr, screen->width, screen->height);
d326 1
a326 1
    KdSetPointerMatrix (&m);
d331 4
a334 5
    if (scrpriv->shadow)
    {
	if (!KdShadowFbAlloc (screen,
			      scrpriv->randr & (RR_Rotate_90|RR_Rotate_270)))
	    return FALSE;
d336 1
a336 2
    else
    {
d339 1
a339 1
    				 priv->var.bits_per_pixel);
d347 1
a347 1
fbdevSetScreenSizes (ScreenPtr pScreen)
d350 15
a364 17
    KdScreenInfo	*screen = pScreenPriv->screen;
    FbdevScrPriv	*scrpriv = screen->driver;
    FbdevPriv		*priv = screen->card->driver;

    if (scrpriv->randr & (RR_Rotate_0|RR_Rotate_180))
    {
	pScreen->width = priv->var.xres;
	pScreen->height = priv->var.yres;
	pScreen->mmWidth = screen->width_mm;
	pScreen->mmHeight = screen->height_mm;
    }
    else
    {
	pScreen->width = priv->var.yres;
	pScreen->height = priv->var.xres;
	pScreen->mmWidth = screen->height_mm;
	pScreen->mmHeight = screen->width_mm;
d369 1
a369 1
fbdevUnmapFramebuffer (KdScreenInfo *screen)
d371 1
a371 1
    KdShadowFbFree (screen);
d376 1
a376 1
fbdevSetShadow (ScreenPtr pScreen)
d379 6
a384 6
    KdScreenInfo	*screen = pScreenPriv->screen;
    FbdevScrPriv	*scrpriv = screen->driver;
    FbdevPriv		*priv = screen->card->driver;
    ShadowUpdateProc	update;
    ShadowWindowProc	window;
    int			useYX = 0;
d396 24
a419 23
	if (priv->var.bits_per_pixel == 16) {
	    switch (scrpriv->randr) {
	    case RR_Rotate_90:
		if (useYX)
		    update = shadowUpdateRotate16_90YX;
		else
		    update =  shadowUpdateRotate16_90;
		break;
	    case RR_Rotate_180:
		update = shadowUpdateRotate16_180;
		break;
	    case RR_Rotate_270:
		if (useYX)
		    update = shadowUpdateRotate16_270YX;
		else
		    update =  shadowUpdateRotate16_270;
		break;
	    default:
		update = shadowUpdateRotate16;
		break;
	    }
	} else
	    update = shadowUpdateRotatePacked;
d421 2
a422 2
	update = shadowUpdatePacked;
    return KdShadowSet (pScreen, scrpriv->randr, update, window);
a424 1

d427 1
a427 1
fbdevRandRGetInfo (ScreenPtr pScreen, Rotation *rotations)
d430 5
a434 5
    KdScreenInfo	    *screen = pScreenPriv->screen;
    FbdevScrPriv	    *scrpriv = screen->driver;
    RRScreenSizePtr	    pSize;
    Rotation		    randr;
    int			    n;
d436 1
a436 1
    *rotations = RR_Rotate_All|RR_Reflect_All;
d439 2
a440 2
	if (pScreen->allowedDepths[n].numVids)
	    break;
d442 1
a442 1
	return FALSE;
d444 3
a446 5
    pSize = RRRegisterSize (pScreen,
			    screen->width,
			    screen->height,
			    screen->width_mm,
			    screen->height_mm);
d448 1
a448 1
    randr = KdSubRotation (scrpriv->randr, screen->randr);
d450 1
a450 1
    RRSetCurrentConfig (pScreen, randr, 0, pSize);
d456 2
a457 4
fbdevRandRSetConfig (ScreenPtr		pScreen,
		     Rotation		randr,
		     int		rate,
		     RRScreenSizePtr	pSize)
d460 17
a476 19
    KdScreenInfo	*screen = pScreenPriv->screen;
    FbdevScrPriv	*scrpriv = screen->driver;
    Bool		wasEnabled = pScreenPriv->enabled;
    FbdevScrPriv	oldscr;
    int			oldwidth;
    int			oldheight;
    int			oldmmwidth;
    int			oldmmheight;
    int			newwidth, newheight;

    if (screen->randr & (RR_Rotate_0|RR_Rotate_180))
    {
	newwidth = pSize->width;
	newheight = pSize->height;
    }
    else
    {
	newwidth = pSize->height;
	newheight = pSize->width;
d480 1
a480 1
	KdDisableScreen (pScreen);
d493 1
a493 1
    scrpriv->randr = KdAddRotation (screen->randr, randr);
d495 1
a495 1
    fbdevUnmapFramebuffer (screen);
d497 2
a498 2
    if (!fbdevMapFramebuffer (screen))
	goto bail4;
d500 1
a500 1
    KdShadowUnset (screen->pScreen);
d502 2
a503 2
    if (!fbdevSetShadow (screen->pScreen))
	goto bail4;
d505 1
a505 1
    fbdevSetScreenSizes (screen->pScreen);
d510 7
a516 7
    (*pScreen->ModifyPixmapHeader) (fbGetScreenPixmap (pScreen),
				    pScreen->width,
				    pScreen->height,
				    screen->fb.depth,
				    screen->fb.bitsPerPixel,
				    screen->fb.byteStride,
				    screen->fb.frameBuffer);
d520 1
a520 1
    KdSetSubpixelOrder (pScreen, scrpriv->randr);
d522 1
a522 1
	KdEnableScreen (pScreen);
d526 2
a527 2
bail4:
    fbdevUnmapFramebuffer (screen);
d529 1
a529 1
    (void) fbdevMapFramebuffer (screen);
d536 1
a536 1
	KdEnableScreen (pScreen);
d541 1
a541 1
fbdevRandRInit (ScreenPtr pScreen)
d543 1
a543 1
    rrScrPrivPtr    pScrPriv;
d545 2
a546 2
    if (!RRScreenInit (pScreen))
	return FALSE;
d556 1
a556 1
fbdevCreateColormap (ColormapPtr pmap)
d558 2
a559 1
    ScreenPtr		pScreen = pmap->pScreen;
d561 5
a565 5
    FbdevPriv		*priv = pScreenPriv->card->driver;
    VisualPtr		pVisual;
    int			i;
    int			nent;
    xColorItem		*pdefs;
d569 15
a583 16
	pVisual = pmap->pVisual;
	nent = pVisual->ColormapEntries;
	pdefs = malloc(nent * sizeof (xColorItem));
	if (!pdefs)
	    return FALSE;
	for (i = 0; i < nent; i++)
	    pdefs[i].pixel = i;
	fbdevGetColors (pScreen, nent, pdefs);
	for (i = 0; i < nent; i++)
	{
	    pmap->red[i].co.local.red = pdefs[i].red;
	    pmap->red[i].co.local.green = pdefs[i].green;
	    pmap->red[i].co.local.blue = pdefs[i].blue;
	}
	free(pdefs);
	return TRUE;
d585 1
a585 1
	return fbInitializeColormap (pmap);
d590 1
a590 1
fbdevInitScreen (ScreenPtr pScreen)
d601 1
a601 1
fbdevFinishInitScreen (ScreenPtr pScreen)
d603 2
a604 2
    if (!shadowSetup (pScreen))
	return FALSE;
d607 2
a608 2
    if (!fbdevRandRInit (pScreen))
	return FALSE;
a613 1

d615 1
a615 1
fbdevCreateResources (ScreenPtr pScreen)
d617 1
a617 1
    return fbdevSetShadow (pScreen);
d621 1
a621 1
fbdevPreserve (KdCardInfo *card)
d626 1
a626 1
fbdevUpdateFbColormap(FbdevPriv *priv, int minidx, int maxidx)
d641 1
a641 1
fbdevEnable (ScreenPtr pScreen)
d644 2
a645 2
    FbdevPriv		*priv = pScreenPriv->card->driver;
    int			k;
d647 1
a647 1
    priv->var.activate = FB_ACTIVATE_NOW|FB_CHANGE_CMAP_VBL;
d650 17
a666 20
    k = ioctl (priv->fd, FBIOPUT_VSCREENINFO, &priv->var);
    if (k < 0)
    {
	perror ("FBIOPUT_VSCREENINFO");
	return FALSE;
    }

    if (priv->fix.visual == FB_VISUAL_DIRECTCOLOR)
    {
	int		i;

	for (i = 0;
	     i < (1 << priv->var.red.length) ||
	     i < (1 << priv->var.green.length) ||
	     i < (1 << priv->var.blue.length); i++)
	{
	    priv->red[i] = i * 65535 / ((1 << priv->var.red.length) - 1);
	    priv->green[i] = i * 65535 / ((1 << priv->var.green.length) - 1);
	    priv->blue[i] = i * 65535 / ((1 << priv->var.blue.length) - 1);
	}
d668 1
a668 1
	fbdevUpdateFbColormap(priv, 0, i);
d674 1
a674 1
fbdevDPMS (ScreenPtr pScreen, int mode)
d677 1
a677 1
    FbdevPriv	*priv = pScreenPriv->card->driver;
d681 1
a681 1
	return TRUE;
d683 3
a685 4
    if (ioctl (priv->fd, FBIOPUT_POWERMODE, &mode) >= 0)
    {
	oldmode = mode;
	return TRUE;
d689 3
a691 4
    if (ioctl (priv->fd, FBIOBLANK, mode ? mode + 1 : 0) >= 0)
    {
	oldmode = mode;
	return TRUE;
d698 1
a698 1
fbdevDisable (ScreenPtr pScreen)
d703 1
a703 1
fbdevRestore (KdCardInfo *card)
d708 1
a708 1
fbdevScreenFini (KdScreenInfo *screen)
d713 1
a713 1
fbdevCardFini (KdCardInfo *card)
d715 1
a715 1
    FbdevPriv	*priv = card->driver;
d717 2
a718 2
    munmap (priv->fb_base, priv->fix.smem_len);
    close (priv->fd);
d726 1
a726 1
fbdevGetColors (ScreenPtr pScreen, int n, xColorItem *pdefs)
d729 5
a733 5
    FbdevPriv	    *priv = pScreenPriv->card->driver;
    struct fb_cmap  cmap;
    int		    p;
    int		    k;
    int		    min, max;
d737 5
a741 6
    for (k = 0; k < n; k++)
    {
	if (pdefs[k].pixel < min)
	    min = pdefs[k].pixel;
	if (pdefs[k].pixel > max)
	    max = pdefs[k].pixel;
d749 11
a759 13
    k = ioctl (priv->fd, FBIOGETCMAP, &cmap);
    if (k < 0)
    {
	perror ("can't get colormap");
	return;
    }
    while (n--)
    {
	p = pdefs->pixel;
	pdefs->red = priv->red[p];
	pdefs->green = priv->green[p];
	pdefs->blue = priv->blue[p];
	pdefs++;
d767 1
a767 1
fbdevPutColors (ScreenPtr pScreen, int n, xColorItem *pdefs)
d770 3
a772 3
    FbdevPriv	*priv = pScreenPriv->card->driver;
    int		    p;
    int		    min, max;
d776 10
a785 11
    while (n--)
    {
	p = pdefs->pixel;
	priv->red[p] = pdefs->red;
	priv->green[p] = pdefs->green;
	priv->blue[p] = pdefs->blue;
	if (p < min)
	    min = p;
	if (p > max)
	    max = p;
	pdefs++;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d2 1
a2 1
 * Copyright © 1999 Keith Packard
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d87 1
a87 1
    priv = (FbdevPriv *) xalloc (sizeof (FbdevPriv));
d93 1
a93 1
	xfree (priv);
d299 1
a299 1
    scrpriv = xcalloc (1, sizeof (FbdevScrPriv));
d306 1
a306 1
	xfree (scrpriv);
d597 1
a597 1
	pdefs = xalloc (nent * sizeof (xColorItem));
d609 1
a609 1
	xfree (pdefs);
d752 1
a752 1
    xfree (priv);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d35 1
a35 1
Bool
a37 1
    int		    k;
d40 1
a40 1
    if (fbdevDevicePath == NULL) 
d45 1
a45 1
	ErrorF("Error opening framebuffer %s: %s\n", 
d52 1
a52 1
    if ((k=ioctl(priv->fd, FBIOGET_FSCREENINFO, &priv->fix)) < 0) {
d59 1
a59 1
    if ((k=ioctl(priv->fd, FBIOGET_VSCREENINFO, &priv->var)) < 0) {
d70 2
a71 2
    
    if (priv->fb_base == (char *)-1) 
d90 1
a90 1
    
d97 1
a97 1
    
d126 1
a126 1
    
d150 1
a150 1
Bool
d162 1
a162 1
    
d165 1
a165 1
	if (k >= 0) 
d177 1
a177 1
    if (!screen->fb[0].depth)
d179 2
a180 2
	if (k >= 0) 
	    screen->fb[0].depth = var.bits_per_pixel;
d182 1
a182 1
	    screen->fb[0].depth = 16;
d198 1
a198 1
    var.bits_per_pixel = screen->fb[0].depth;
d219 1
a219 1
    
d224 1
a224 1
	    screen->fb[0].visuals = (1 << StaticGray);
d229 1
a229 1
	    screen->fb[0].visuals = ((1 << StaticGray) |
d236 3
a238 3
	screen->fb[0].blueMask  = 0x00;
	screen->fb[0].greenMask = 0x00;
	screen->fb[0].redMask   = 0x00;
d243 1
a243 1
	    screen->fb[0].visuals = (1 << StaticGray);
d247 1
a247 1
	    screen->fb[0].visuals = (1 << StaticColor);
d249 3
a251 3
	screen->fb[0].blueMask  = 0x00;
	screen->fb[0].greenMask = 0x00;
	screen->fb[0].redMask   = 0x00;
d255 1
a255 1
	screen->fb[0].visuals = (1 << TrueColor);
d257 3
a259 3
	screen->fb[0].redMask = Mask (priv->var.red.offset, priv->var.red.length);
	screen->fb[0].greenMask = Mask (priv->var.green.offset, priv->var.green.length);
	screen->fb[0].blueMask = Mask (priv->var.blue.offset, priv->var.blue.length);
d265 11
a275 11
	screen->fb[0].redMask = fbdevMakeContig (screen->fb[0].redMask,
						 screen->fb[0].greenMask|
						 screen->fb[0].blueMask);

	screen->fb[0].greenMask = fbdevMakeContig (screen->fb[0].greenMask,
						   screen->fb[0].redMask|
						   screen->fb[0].blueMask);

	screen->fb[0].blueMask = fbdevMakeContig (screen->fb[0].blueMask,
						  screen->fb[0].redMask|
						  screen->fb[0].greenMask);
d277 1
a277 1
	allbits = screen->fb[0].redMask | screen->fb[0].greenMask | screen->fb[0].blueMask;
d286 2
a287 2
    screen->fb[0].depth = depth;
    screen->fb[0].bitsPerPixel = priv->var.bits_per_pixel;
d311 2
a312 2
    
void *
d340 1
a340 1
    
d342 1
a342 1
    
d344 1
a344 1
    
d347 1
a347 3
    screen->memory_base = (CARD8 *) (priv->fb);
    screen->memory_size = priv->fix.smem_len;
    
d350 1
a350 1
	if (!KdShadowFbAlloc (screen, 0, 
a352 1
	screen->off_screen_base = screen->memory_size;
d356 2
a357 2
        screen->fb[0].byteStride = priv->fix.line_length;
        screen->fb[0].pixelStride = (priv->fix.line_length * 8 / 
d359 1
a359 2
        screen->fb[0].frameBuffer = (CARD8 *) (priv->fb);
	screen->off_screen_base = screen->fb[0].byteStride * screen->height;
d361 1
a361 1
    
d365 1
a365 1
void
d389 1
a389 1
Bool
d392 1
a392 1
    KdShadowFbFree (screen, 0);
d396 1
a396 1
Bool
d447 1
a447 1
Bool
d456 1
a456 1
    
d458 1
a458 1
    
d464 1
a464 1
    
d470 1
a470 1
    
d472 1
a472 1
    
d474 1
a474 1
    
d478 1
a478 1
Bool
d510 1
a510 1
    
d515 1
a515 1
    
d519 1
a519 1
    
d523 1
a523 1
    
d540 5
a544 5
				    screen->fb[0].depth,
				    screen->fb[0].bitsPerPixel,
				    screen->fb[0].byteStride,
				    screen->fb[0].frameBuffer);
    
d546 1
a546 1
    
d561 1
a561 1
    
d567 1
a567 1
Bool
d571 1
a571 1
    
d582 1
a582 1
Bool
d592 1
a592 1
    
d602 1
a602 1
	fbdevGetColors (pScreen, 0, nent, pdefs);
d637 1
a637 1
    
d653 15
d676 1
a676 1
    
d684 1
a684 1
    
a686 1
	struct fb_cmap	cmap;
d689 1
a689 1
	for (i = 0; 
d698 2
a699 7
	cmap.start = 0;
	cmap.len = i;
	cmap.red = &priv->red[0];
	cmap.green = &priv->green[0];
	cmap.blue = &priv->blue[0];
	cmap.transp = 0;
	ioctl (priv->fd, FBIOPUTCMAP, &cmap);
d749 1
a749 1
    
d755 3
d759 1
a759 1
fbdevGetColors (ScreenPtr pScreen, int fb, int n, xColorItem *pdefs)
d799 3
d803 1
a803 1
fbdevPutColors (ScreenPtr pScreen, int fb, int n, xColorItem *pdefs)
a806 1
    struct fb_cmap  cmap;
d824 2
a825 7
    cmap.start = min;
    cmap.len = max - min + 1;
    cmap.red = &priv->red[min];
    cmap.green = &priv->green[min];
    cmap.blue = &priv->blue[min];
    cmap.transp = 0;
    ioctl (priv->fd, FBIOPUTCMAP, &cmap);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a101 2
#define FBDEV_KLUDGE_FORMAT
#ifdef FBDEV_KLUDGE_FORMAT
a114 1
#endif
d179 6
a184 1
	screen->fb[0].depth = 16;
d186 11
a196 8
    t = KdFindMode (screen, fbdevModeSupported);
    screen->rate = t->rate;
    screen->width = t->horizontal;
    screen->height = t->vertical;

    /* Now try setting the mode */
    if (k < 0 || (t->horizontal != var.xres || t->vertical != var.yres))
        fbdevConvertMonitorTiming (t, &var);
d261 1
a261 1
#ifdef FBDEV_KLUDGE_FORMAT
a277 1
#endif
d300 1
a300 1
    scrpriv = xalloc (sizeof (FbdevScrPriv));
a302 1
    memset (scrpriv, '\0', sizeof (FbdevScrPriv));
a526 2
    KdOffscreenSwapOut (screen->pScreen);

d773 1
a773 1
    cmap.green = &priv->green[min];;
@


1.1
log
@Initial revision
@
text
@a1 2
 * Id: fbdev.c,v 1.1 1999/11/02 03:54:46 keithp Exp $
 *
a21 1
/* $RCSId: xc/programs/Xserver/hw/kdrive/fbdev/fbdev.c,v 1.31 2002/10/14 18:01:40 keithp Exp $ */
d331 1
a331 1
    KdMouseMatrix	m;
d339 1
a339 1
    KdComputeMouseMatrix (&m, scrpriv->randr, screen->width, screen->height);
d341 1
a341 1
    KdSetMouseMatrix (&m);
d601 1
a601 1
	pdefs = ALLOCATE_LOCAL (nent * sizeof (xColorItem));
d613 1
a613 1
	DEALLOCATE_LOCAL (pdefs);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d24 1
d334 1
a334 1
    KdPointerMatrix	m;
d342 1
a342 1
    KdComputePointerMatrix (&m, scrpriv->randr, screen->width, screen->height);
d344 1
a344 1
    KdSetPointerMatrix (&m);
@

