head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	s0SI41sEunLdyFfd;

1.13
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	7pAEtF6Y5EgemkuY;

1.12
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.08.24.19.44.35;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.05;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.18;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.51;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.51;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.04.11;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Xephyr - A kdrive X server thats runs in a host X window.
 *          Authored by Matthew Allum <mallum@@o-hand.com>
 *
 * Copyright Â© 2004 Nokia
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Nokia not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission. Nokia makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * NOKIA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL NOKIA BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif

#include "hostx.h"
#include "input.h"

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>             /* for memset */
#include <errno.h>
#include <time.h>
#include <err.h>

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/time.h>

#include <X11/keysym.h>
#include <xcb/xcb.h>
#include <xcb/xproto.h>
#include <xcb/xcb_icccm.h>
#include <xcb/xcb_aux.h>
#include <xcb/shm.h>
#include <xcb/xcb_image.h>
#include <xcb/shape.h>
#include <xcb/xcb_keysyms.h>
#include <xcb/randr.h>
#ifdef XF86DRI
#include <xcb/xf86dri.h>
#include <xcb/glx.h>
#endif /* XF86DRI */
#ifdef GLAMOR
#include <epoxy/gl.h>
#include "glamor.h"
#include "ephyr_glamor_glx.h"
#endif
#include "ephyrlog.h"
#include "ephyr.h"

struct EphyrHostXVars {
    char *server_dpy_name;
    xcb_connection_t *conn;
    int screen;
    xcb_visualtype_t *visual;
    Window winroot;
    xcb_gcontext_t  gc;
    xcb_render_pictformat_t argb_format;
    xcb_cursor_t empty_cursor;
    int depth;
    Bool use_sw_cursor;
    Bool use_fullscreen;
    Bool have_shm;

    int n_screens;
    KdScreenInfo **screens;

    long damage_debug_msec;
};

/* memset ( missing> ) instead of below  */
/*static EphyrHostXVars HostX = { "?", 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};*/
static EphyrHostXVars HostX;

static int HostXWantDamageDebug = 0;

extern EphyrKeySyms ephyrKeySyms;

extern Bool EphyrWantResize;

char *ephyrResName = NULL;
int ephyrResNameFromCmd = 0;
char *ephyrTitle = NULL;
Bool ephyr_glamor = FALSE;

Bool
hostx_has_extension(xcb_extension_t *extension)
{
    const xcb_query_extension_reply_t *rep;

    rep = xcb_get_extension_data(HostX.conn, extension);

    return rep && rep->present;
}

static void
 hostx_set_fullscreen_hint(void);

#define host_depth_matches_server(_vars) (HostX.depth == (_vars)->server_depth)

int
hostx_want_screen_geometry(KdScreenInfo *screen, int *width, int *height, int *x, int *y)
{
    EphyrScrPriv *scrpriv = screen->driver;

    if (scrpriv && (scrpriv->win_pre_existing != None ||
                    scrpriv->output != NULL ||
                    HostX.use_fullscreen == TRUE)) {
        *x = scrpriv->win_x;
        *y = scrpriv->win_y;
        *width = scrpriv->win_width;
        *height = scrpriv->win_height;
        return 1;
    }

    return 0;
}

void
hostx_add_screen(KdScreenInfo *screen, unsigned long win_id, int screen_num, Bool use_geometry, const char *output)
{
    EphyrScrPriv *scrpriv = screen->driver;
    int index = HostX.n_screens;

    HostX.n_screens += 1;
    HostX.screens = reallocarray(HostX.screens,
                                 HostX.n_screens, sizeof(HostX.screens[0]));
    HostX.screens[index] = screen;

    scrpriv->screen = screen;
    scrpriv->win_pre_existing = win_id;
    scrpriv->win_explicit_position = use_geometry;
    scrpriv->output = output;
}

void
hostx_set_display_name(char *name)
{
    HostX.server_dpy_name = strdup(name);
}

void
hostx_set_screen_number(KdScreenInfo *screen, int number)
{
    EphyrScrPriv *scrpriv = screen->driver;

    if (scrpriv) {
        scrpriv->mynum = number;
        hostx_set_win_title(screen, "");
    }
}

void
hostx_set_win_title(KdScreenInfo *screen, const char *extra_text)
{
    EphyrScrPriv *scrpriv = screen->driver;

    if (!scrpriv)
        return;

    if (ephyrTitle) {
        xcb_icccm_set_wm_name(HostX.conn,
                              scrpriv->win,
                              XCB_ATOM_STRING,
                              8,
                              strlen(ephyrTitle),
                              ephyrTitle);
    } else {
#define BUF_LEN 256
        char buf[BUF_LEN + 1];

        memset(buf, 0, BUF_LEN + 1);
        snprintf(buf, BUF_LEN, "Xephyr on %s.%d %s",
                 HostX.server_dpy_name ? HostX.server_dpy_name : ":0",
                 scrpriv->mynum, (extra_text != NULL) ? extra_text : "");

        xcb_icccm_set_wm_name(HostX.conn,
                              scrpriv->win,
                              XCB_ATOM_STRING,
                              8,
                              strlen(buf),
                              buf);
        xcb_flush(HostX.conn);
    }
}

int
hostx_want_host_cursor(void)
{
    return !HostX.use_sw_cursor;
}

void
hostx_use_sw_cursor(void)
{
    HostX.use_sw_cursor = TRUE;
}

xcb_cursor_t
hostx_get_empty_cursor(void)
{
    return HostX.empty_cursor;
}

int
hostx_want_preexisting_window(KdScreenInfo *screen)
{
    EphyrScrPriv *scrpriv = screen->driver;

    if (scrpriv && scrpriv->win_pre_existing) {
        return 1;
    }
    else {
        return 0;
    }
}

void
hostx_get_output_geometry(const char *output,
                          int *x, int *y,
                          int *width, int *height)
{
    int i, name_len = 0, output_found = FALSE;
    char *name = NULL;
    xcb_generic_error_t *error;
    xcb_randr_query_version_cookie_t version_c;
    xcb_randr_query_version_reply_t *version_r;
    xcb_randr_get_screen_resources_cookie_t screen_resources_c;
    xcb_randr_get_screen_resources_reply_t *screen_resources_r;
    xcb_randr_output_t *randr_outputs;
    xcb_randr_get_output_info_cookie_t output_info_c;
    xcb_randr_get_output_info_reply_t *output_info_r;
    xcb_randr_get_crtc_info_cookie_t crtc_info_c;
    xcb_randr_get_crtc_info_reply_t *crtc_info_r;

    /* First of all, check for extension */
    if (!hostx_has_extension(&xcb_randr_id))
    {
        fprintf(stderr, "\nHost X server does not support RANDR extension (or it's disabled).\n");
        exit(1);
    }

    /* Check RandR version */
    version_c = xcb_randr_query_version(HostX.conn, 1, 2);
    version_r = xcb_randr_query_version_reply(HostX.conn,
                                              version_c,
                                              &error);

    if (error != NULL || version_r == NULL)
    {
        fprintf(stderr, "\nFailed to get RandR version supported by host X server.\n");
        exit(1);
    }
    else if (version_r->major_version < 1 || version_r->minor_version < 2)
    {
        free(version_r);
        fprintf(stderr, "\nHost X server doesn't support RandR 1.2, needed for -output usage.\n");
        exit(1);
    }

    free(version_r);

    /* Get list of outputs from screen resources */
    screen_resources_c = xcb_randr_get_screen_resources(HostX.conn,
                                                        HostX.winroot);
    screen_resources_r = xcb_randr_get_screen_resources_reply(HostX.conn,
                                                              screen_resources_c,
                                                              NULL);
    randr_outputs = xcb_randr_get_screen_resources_outputs(screen_resources_r);

    for (i = 0; !output_found && i < screen_resources_r->num_outputs; i++)
    {
        /* Get info on the output */
        output_info_c = xcb_randr_get_output_info(HostX.conn,
                                                  randr_outputs[i],
                                                  XCB_CURRENT_TIME);
        output_info_r = xcb_randr_get_output_info_reply(HostX.conn,
                                                        output_info_c,
                                                        NULL);

        /* Get output name */
        name_len = xcb_randr_get_output_info_name_length(output_info_r);
        name = malloc(name_len + 1);
        strncpy(name, (char*)xcb_randr_get_output_info_name(output_info_r), name_len);
        name[name_len] = '\0';

        if (!strcmp(name, output))
        {
            output_found = TRUE;

            /* Check if output is connected */
            if (output_info_r->crtc == XCB_NONE)
            {
                free(name);
                free(output_info_r);
                free(screen_resources_r);
                fprintf(stderr, "\nOutput %s is currently disabled (or not connected).\n", output);
                exit(1);
            }

            /* Get CRTC from output info */
            crtc_info_c = xcb_randr_get_crtc_info(HostX.conn,
                                                  output_info_r->crtc,
                                                  XCB_CURRENT_TIME);
            crtc_info_r = xcb_randr_get_crtc_info_reply(HostX.conn,
                                                        crtc_info_c,
                                                        NULL);

            /* Get CRTC geometry */
            *x = crtc_info_r->x;
            *y = crtc_info_r->y;
            *width = crtc_info_r->width;
            *height = crtc_info_r->height;

            free(crtc_info_r);
        }

        free(name);
        free(output_info_r);
    }

    free(screen_resources_r);

    if (!output_found)
    {
        fprintf(stderr, "\nOutput %s not available in host X server.\n", output);
        exit(1);
    }
}

void
hostx_use_fullscreen(void)
{
    HostX.use_fullscreen = TRUE;
}

int
hostx_want_fullscreen(void)
{
    return HostX.use_fullscreen;
}

static xcb_intern_atom_cookie_t cookie_WINDOW_STATE,
				cookie_WINDOW_STATE_FULLSCREEN;

static void
hostx_set_fullscreen_hint(void)
{
    xcb_atom_t atom_WINDOW_STATE, atom_WINDOW_STATE_FULLSCREEN;
    int index;
    xcb_intern_atom_reply_t *reply;

    reply = xcb_intern_atom_reply(HostX.conn, cookie_WINDOW_STATE, NULL);
    atom_WINDOW_STATE = reply->atom;
    free(reply);

    reply = xcb_intern_atom_reply(HostX.conn, cookie_WINDOW_STATE_FULLSCREEN,
                                  NULL);
    atom_WINDOW_STATE_FULLSCREEN = reply->atom;
    free(reply);

    for (index = 0; index < HostX.n_screens; index++) {
        EphyrScrPriv *scrpriv = HostX.screens[index]->driver;
        xcb_change_property(HostX.conn,
                            PropModeReplace,
                            scrpriv->win,
                            atom_WINDOW_STATE,
                            XCB_ATOM_ATOM,
                            32,
                            1,
                            &atom_WINDOW_STATE_FULLSCREEN);
    }
}

static void
hostx_toggle_damage_debug(void)
{
    HostXWantDamageDebug ^= 1;
}

void
hostx_handle_signal(int signum)
{
    hostx_toggle_damage_debug();
    EPHYR_DBG("Signal caught. Damage Debug:%i\n", HostXWantDamageDebug);
}

void
hostx_use_resname(char *name, int fromcmd)
{
    ephyrResName = name;
    ephyrResNameFromCmd = fromcmd;
}

void
hostx_set_title(char *title)
{
    ephyrTitle = title;
}

#ifdef __SUNPRO_C
/* prevent "Function has no return statement" error for x_io_error_handler */
#pragma does_not_return(exit)
#endif

int
hostx_init(void)
{
    uint32_t attrs[2];
    uint32_t attr_mask = 0;
    xcb_pixmap_t cursor_pxm;
    xcb_gcontext_t cursor_gc;
    uint16_t red, green, blue;
    uint32_t pixel;
    int index;
    char *tmpstr;
    char *class_hint;
    size_t class_len;
    xcb_screen_t *xscreen;
    xcb_rectangle_t rect = { 0, 0, 1, 1 };

    attrs[0] =
        XCB_EVENT_MASK_BUTTON_PRESS
        | XCB_EVENT_MASK_BUTTON_RELEASE
        | XCB_EVENT_MASK_POINTER_MOTION
        | XCB_EVENT_MASK_KEY_PRESS
        | XCB_EVENT_MASK_KEY_RELEASE
        | XCB_EVENT_MASK_EXPOSURE
        | XCB_EVENT_MASK_STRUCTURE_NOTIFY;
    attr_mask |= XCB_CW_EVENT_MASK;

    EPHYR_DBG("mark");
#ifdef GLAMOR
    if (ephyr_glamor)
        HostX.conn = ephyr_glamor_connect();
    else
#endif
        HostX.conn = xcb_connect(NULL, &HostX.screen);
    if (!HostX.conn || xcb_connection_has_error(HostX.conn)) {
        fprintf(stderr, "\nXephyr cannot open host display. Is DISPLAY set?\n");
        exit(1);
    }

    xscreen = xcb_aux_get_screen(HostX.conn, HostX.screen);
    HostX.winroot = xscreen->root;
    HostX.gc = xcb_generate_id(HostX.conn);
    HostX.depth = xscreen->root_depth;
#ifdef GLAMOR
    if (ephyr_glamor) {
        HostX.visual = ephyr_glamor_get_visual();
        if (HostX.visual->visual_id != xscreen->root_visual) {
            attrs[1] = xcb_generate_id(HostX.conn);
            attr_mask |= XCB_CW_COLORMAP;
            xcb_create_colormap(HostX.conn,
                                XCB_COLORMAP_ALLOC_NONE,
                                attrs[1],
                                HostX.winroot,
                                HostX.visual->visual_id);
        }
    } else
#endif
        HostX.visual = xcb_aux_find_visual_by_id(xscreen,xscreen->root_visual);

    xcb_create_gc(HostX.conn, HostX.gc, HostX.winroot, 0, NULL);
    cookie_WINDOW_STATE = xcb_intern_atom(HostX.conn, FALSE,
                                          strlen("_NET_WM_STATE"),
                                          "_NET_WM_STATE");
    cookie_WINDOW_STATE_FULLSCREEN =
        xcb_intern_atom(HostX.conn, FALSE,
                        strlen("_NET_WM_STATE_FULLSCREEN"),
                        "_NET_WM_STATE_FULLSCREEN");

    for (index = 0; index < HostX.n_screens; index++) {
        KdScreenInfo *screen = HostX.screens[index];
        EphyrScrPriv *scrpriv = screen->driver;

        scrpriv->win = xcb_generate_id(HostX.conn);
        scrpriv->server_depth = HostX.depth;
        scrpriv->ximg = NULL;
        scrpriv->win_x = 0;
        scrpriv->win_y = 0;

        if (scrpriv->win_pre_existing != XCB_WINDOW_NONE) {
            xcb_get_geometry_reply_t *prewin_geom;
            xcb_get_geometry_cookie_t cookie;
            xcb_generic_error_t *e = NULL;

            /* Get screen size from existing window */
            cookie = xcb_get_geometry(HostX.conn,
                                      scrpriv->win_pre_existing);
            prewin_geom = xcb_get_geometry_reply(HostX.conn, cookie, &e);

            if (e) {
                free(e);
                free(prewin_geom);
                fprintf (stderr, "\nXephyr -parent window' does not exist!\n");
                exit (1);
            }

            scrpriv->win_width  = prewin_geom->width;
            scrpriv->win_height = prewin_geom->height;

            free(prewin_geom);

            xcb_create_window(HostX.conn,
                              XCB_COPY_FROM_PARENT,
                              scrpriv->win,
                              scrpriv->win_pre_existing,
                              0,0,
                              scrpriv->win_width,
                              scrpriv->win_height,
                              0,
                              XCB_WINDOW_CLASS_COPY_FROM_PARENT,
                              HostX.visual->visual_id,
                              attr_mask,
                              attrs);
        }
        else {
            xcb_create_window(HostX.conn,
                              XCB_COPY_FROM_PARENT,
                              scrpriv->win,
                              HostX.winroot,
                              0,0,100,100, /* will resize */
                              0,
                              XCB_WINDOW_CLASS_COPY_FROM_PARENT,
                              HostX.visual->visual_id,
                              attr_mask,
                              attrs);

            hostx_set_win_title(screen,
                                "(ctrl+shift grabs mouse and keyboard)");

            if (HostX.use_fullscreen) {
                scrpriv->win_width  = xscreen->width_in_pixels;
                scrpriv->win_height = xscreen->height_in_pixels;

                hostx_set_fullscreen_hint();
            }
            else if (scrpriv->output) {
                hostx_get_output_geometry(scrpriv->output,
                                          &scrpriv->win_x,
                                          &scrpriv->win_y,
                                          &scrpriv->win_width,
                                          &scrpriv->win_height);

                HostX.use_fullscreen = TRUE;
                hostx_set_fullscreen_hint();
            }


            tmpstr = getenv("RESOURCE_NAME");
            if (tmpstr && (!ephyrResNameFromCmd))
                ephyrResName = tmpstr;
            class_len = strlen(ephyrResName) + 1 + strlen("Xephyr") + 1;
            class_hint = malloc(class_len);
            if (class_hint) {
                strcpy(class_hint, ephyrResName);
                strcpy(class_hint + strlen(ephyrResName) + 1, "Xephyr");
                xcb_change_property(HostX.conn,
                                    XCB_PROP_MODE_REPLACE,
                                    scrpriv->win,
                                    XCB_ATOM_WM_CLASS,
                                    XCB_ATOM_STRING,
                                    8,
                                    class_len,
                                    class_hint);
                free(class_hint);
            }
        }
    }

    if (!xcb_aux_parse_color("red", &red, &green, &blue)) {
        xcb_lookup_color_cookie_t c =
            xcb_lookup_color(HostX.conn, xscreen->default_colormap, 3, "red");
        xcb_lookup_color_reply_t *reply =
            xcb_lookup_color_reply(HostX.conn, c, NULL);
        red = reply->exact_red;
        green = reply->exact_green;
        blue = reply->exact_blue;
        free(reply);
    }

    {
        xcb_alloc_color_cookie_t c = xcb_alloc_color(HostX.conn,
                                                     xscreen->default_colormap,
                                                     red, green, blue);
        xcb_alloc_color_reply_t *r = xcb_alloc_color_reply(HostX.conn, c, NULL);
        red = r->red;
        green = r->green;
        blue = r->blue;
        pixel = r->pixel;
        free(r);
    }

    xcb_change_gc(HostX.conn, HostX.gc, XCB_GC_FOREGROUND, &pixel);

    cursor_pxm = xcb_generate_id(HostX.conn);
    xcb_create_pixmap(HostX.conn, 1, cursor_pxm, HostX.winroot, 1, 1);
    cursor_gc = xcb_generate_id(HostX.conn);
    pixel = 0;
    xcb_create_gc(HostX.conn, cursor_gc, cursor_pxm,
                  XCB_GC_FOREGROUND, &pixel);
    xcb_poly_fill_rectangle(HostX.conn, cursor_pxm, cursor_gc, 1, &rect);
    xcb_free_gc(HostX.conn, cursor_gc);
    HostX.empty_cursor = xcb_generate_id(HostX.conn);
    xcb_create_cursor(HostX.conn,
                      HostX.empty_cursor,
                      cursor_pxm, cursor_pxm,
                      0,0,0,
                      0,0,0,
                      1,1);
    xcb_free_pixmap(HostX.conn, cursor_pxm);
    if (!hostx_want_host_cursor ()) {
        CursorVisible = TRUE;
        /* Ditch the cursor, we provide our 'own' */
        for (index = 0; index < HostX.n_screens; index++) {
            KdScreenInfo *screen = HostX.screens[index];
            EphyrScrPriv *scrpriv = screen->driver;

            xcb_change_window_attributes(HostX.conn,
                                         scrpriv->win,
                                         XCB_CW_CURSOR,
                                         &HostX.empty_cursor);
        }
    }

    /* Try to get share memory ximages for a little bit more speed */
    if (!hostx_has_extension(&xcb_shm_id) || getenv("XEPHYR_NO_SHM")) {
        fprintf(stderr, "\nXephyr unable to use SHM XImages\n");
        HostX.have_shm = FALSE;
    }
    else {
        /* Really really check we have shm - better way ?*/
        xcb_shm_segment_info_t shminfo;
        xcb_generic_error_t *e;
        xcb_void_cookie_t cookie;
        xcb_shm_seg_t shmseg;

        HostX.have_shm = TRUE;

        shminfo.shmid = shmget(IPC_PRIVATE, 1, IPC_CREAT|0777);
        shminfo.shmaddr = shmat(shminfo.shmid,0,0);

        shmseg = xcb_generate_id(HostX.conn);
        cookie = xcb_shm_attach_checked(HostX.conn, shmseg, shminfo.shmid,
                                        TRUE);
        e = xcb_request_check(HostX.conn, cookie);

        if (e) {
            fprintf(stderr, "\nXephyr unable to use SHM XImages\n");
            HostX.have_shm = FALSE;
            free(e);
        }

        shmdt(shminfo.shmaddr);
        shmctl(shminfo.shmid, IPC_RMID, 0);
    }

    xcb_flush(HostX.conn);

    /* Setup the pause time between paints when debugging updates */

    HostX.damage_debug_msec = 20000;    /* 1/50 th of a second */

    if (getenv("XEPHYR_PAUSE")) {
        HostX.damage_debug_msec = strtol(getenv("XEPHYR_PAUSE"), NULL, 0);
        EPHYR_DBG("pause is %li\n", HostX.damage_debug_msec);
    }

    return 1;
}

int
hostx_get_depth(void)
{
    return HostX.depth;
}

int
hostx_get_server_depth(KdScreenInfo *screen)
{
    EphyrScrPriv *scrpriv = screen->driver;

    return scrpriv ? scrpriv->server_depth : 0;
}

int
hostx_get_bpp(KdScreenInfo *screen)
{
    EphyrScrPriv *scrpriv = screen->driver;

    if (!scrpriv)
        return 0;

    if (host_depth_matches_server(scrpriv))
        return HostX.visual->bits_per_rgb_value;
    else
        return scrpriv->server_depth; /*XXX correct ?*/
}

void
hostx_get_visual_masks(KdScreenInfo *screen,
                       CARD32 *rmsk, CARD32 *gmsk, CARD32 *bmsk)
{
    EphyrScrPriv *scrpriv = screen->driver;

    if (!scrpriv)
        return;

    if (host_depth_matches_server(scrpriv)) {
        *rmsk = HostX.visual->red_mask;
        *gmsk = HostX.visual->green_mask;
        *bmsk = HostX.visual->blue_mask;
    }
    else if (scrpriv->server_depth == 16) {
        /* Assume 16bpp 565 */
        *rmsk = 0xf800;
        *gmsk = 0x07e0;
        *bmsk = 0x001f;
    }
    else {
        *rmsk = 0x0;
        *gmsk = 0x0;
        *bmsk = 0x0;
    }
}

static int
hostx_calculate_color_shift(unsigned long mask)
{
    int shift = 1;

    /* count # of bits in mask */
    while ((mask = (mask >> 1)))
        shift++;
    /* cmap entry is an unsigned char so adjust it by size of that */
    shift = shift - sizeof(unsigned char) * 8;
    if (shift < 0)
        shift = 0;
    return shift;
}

void
hostx_set_cmap_entry(ScreenPtr pScreen, unsigned char idx,
                     unsigned char r, unsigned char g, unsigned char b)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    EphyrScrPriv *scrpriv = screen->driver;
/* need to calculate the shifts for RGB because server could be BGR. */
/* XXX Not sure if this is correct for 8 on 16, but this works for 8 on 24.*/
    static int rshift, bshift, gshift = 0;
    static int first_time = 1;

    if (first_time) {
        first_time = 0;
        rshift = hostx_calculate_color_shift(HostX.visual->red_mask);
        gshift = hostx_calculate_color_shift(HostX.visual->green_mask);
        bshift = hostx_calculate_color_shift(HostX.visual->blue_mask);
    }
    scrpriv->cmap[idx] = ((r << rshift) & HostX.visual->red_mask) |
        ((g << gshift) & HostX.visual->green_mask) |
        ((b << bshift) & HostX.visual->blue_mask);
}

/**
 * hostx_screen_init creates the XImage that will contain the front buffer of
 * the ephyr screen, and possibly offscreen memory.
 *
 * @@param width width of the screen
 * @@param height height of the screen
 * @@param buffer_height  height of the rectangle to be allocated.
 *
 * hostx_screen_init() creates an XImage, using MIT-SHM if it's available.
 * buffer_height can be used to create a larger offscreen buffer, which is used
 * by fakexa for storing offscreen pixmap data.
 */
void *
hostx_screen_init(KdScreenInfo *screen,
                  int x, int y,
                  int width, int height, int buffer_height,
                  int *bytes_per_line, int *bits_per_pixel)
{
    EphyrScrPriv *scrpriv = screen->driver;
    Bool shm_success = FALSE;

    if (!scrpriv) {
        fprintf(stderr, "%s: Error in accessing hostx data\n", __func__);
        exit(1);
    }

    EPHYR_DBG("host_screen=%p x=%d, y=%d, wxh=%dx%d, buffer_height=%d",
              screen, x, y, width, height, buffer_height);

    if (scrpriv->ximg != NULL) {
        /* Free up the image data if previously used
         * i.ie called by server reset
         */

        if (HostX.have_shm) {
            xcb_shm_detach(HostX.conn, scrpriv->shminfo.shmseg);
            xcb_image_destroy(scrpriv->ximg);
            shmdt(scrpriv->shminfo.shmaddr);
            shmctl(scrpriv->shminfo.shmid, IPC_RMID, 0);
        }
        else {
            free(scrpriv->ximg->data);
            scrpriv->ximg->data = NULL;

            xcb_image_destroy(scrpriv->ximg);
        }
    }

    if (!ephyr_glamor && HostX.have_shm) {
        scrpriv->ximg = xcb_image_create_native(HostX.conn,
                                                width,
                                                buffer_height,
                                                XCB_IMAGE_FORMAT_Z_PIXMAP,
                                                HostX.depth,
                                                NULL,
                                                ~0,
                                                NULL);

        scrpriv->shminfo.shmid =
            shmget(IPC_PRIVATE,
                   scrpriv->ximg->stride * buffer_height,
                   IPC_CREAT | 0777);
        scrpriv->ximg->data = shmat(scrpriv->shminfo.shmid, 0, 0);
        scrpriv->shminfo.shmaddr = scrpriv->ximg->data;

        if (scrpriv->ximg->data == (uint8_t *) -1) {
            EPHYR_DBG
                ("Can't attach SHM Segment, falling back to plain XImages");
            HostX.have_shm = FALSE;
            xcb_image_destroy (scrpriv->ximg);
            shmctl(scrpriv->shminfo.shmid, IPC_RMID, 0);
        }
        else {
            EPHYR_DBG("SHM segment attached %p", scrpriv->shminfo.shmaddr);
            scrpriv->shminfo.shmseg = xcb_generate_id(HostX.conn);
            xcb_shm_attach(HostX.conn,
                           scrpriv->shminfo.shmseg,
                           scrpriv->shminfo.shmid,
                           FALSE);
            shm_success = TRUE;
        }
    }

    if (!ephyr_glamor && !shm_success) {
        EPHYR_DBG("Creating image %dx%d for screen scrpriv=%p\n",
                  width, buffer_height, scrpriv);
        scrpriv->ximg = xcb_image_create_native(HostX.conn,
                                                    width,
                                                    buffer_height,
                                                    XCB_IMAGE_FORMAT_Z_PIXMAP,
                                                    HostX.depth,
                                                    NULL,
                                                    ~0,
                                                    NULL);

        /* Match server byte order so that the image can be converted to
         * the native byte order by xcb_image_put() before drawing */
        if (host_depth_matches_server(scrpriv))
            scrpriv->ximg->byte_order = IMAGE_BYTE_ORDER;

        scrpriv->ximg->data =
            xallocarray(scrpriv->ximg->stride, buffer_height);
    }

    {
        uint32_t mask = XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT;
        uint32_t values[2] = {width, height};
        xcb_configure_window(HostX.conn, scrpriv->win, mask, values);
    }

    if (scrpriv->win_pre_existing == None && !EphyrWantResize) {
        /* Ask the WM to keep our size static */
        xcb_size_hints_t size_hints = {0};
        size_hints.max_width = size_hints.min_width = width;
        size_hints.max_height = size_hints.min_height = height;
        size_hints.flags = (XCB_ICCCM_SIZE_HINT_P_MIN_SIZE |
                            XCB_ICCCM_SIZE_HINT_P_MAX_SIZE);
        xcb_icccm_set_wm_normal_hints(HostX.conn, scrpriv->win,
                                      &size_hints);
    }

    xcb_map_window(HostX.conn, scrpriv->win);

    /* Set explicit window position if it was informed in
     * -screen option (WxH+X or WxH+X+Y). Otherwise, accept the
     * position set by WM.
     * The trick here is putting this code after xcb_map_window() call,
     * so these values won't be overriden by WM. */
    if (scrpriv->win_explicit_position)
    {
        uint32_t mask = XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y;
        uint32_t values[2] = {x, y};
        xcb_configure_window(HostX.conn, scrpriv->win, mask, values);
    }


    xcb_aux_sync(HostX.conn);

    scrpriv->win_width = width;
    scrpriv->win_height = height;
    scrpriv->win_x = x;
    scrpriv->win_y = y;

#ifdef GLAMOR
    if (ephyr_glamor) {
        *bytes_per_line = 0;
        *bits_per_pixel = 0;
        ephyr_glamor_set_window_size(scrpriv->glamor,
                                     scrpriv->win_width, scrpriv->win_height);
        return NULL;
    } else
#endif
    if (host_depth_matches_server(scrpriv)) {
        *bytes_per_line = scrpriv->ximg->stride;
        *bits_per_pixel = scrpriv->ximg->bpp;

        EPHYR_DBG("Host matches server");
        return scrpriv->ximg->data;
    }
    else {
        int bytes_per_pixel = scrpriv->server_depth >> 3;
        int stride = (width * bytes_per_pixel + 0x3) & ~0x3;

        *bytes_per_line = stride;
        *bits_per_pixel = scrpriv->server_depth;

        EPHYR_DBG("server bpp %i", bytes_per_pixel);
        scrpriv->fb_data = xallocarray (stride, buffer_height);
        return scrpriv->fb_data;
    }
}

static void hostx_paint_debug_rect(KdScreenInfo *screen,
                                   int x, int y, int width, int height);

void
hostx_paint_rect(KdScreenInfo *screen,
                 int sx, int sy, int dx, int dy, int width, int height)
{
    EphyrScrPriv *scrpriv = screen->driver;

    EPHYR_DBG("painting in screen %d\n", scrpriv->mynum);

#ifdef GLAMOR
    if (ephyr_glamor) {
        BoxRec box;
        RegionRec region;

        box.x1 = dx;
        box.y1 = dy;
        box.x2 = dx + width;
        box.y2 = dy + height;

        RegionInit(&region, &box, 1);
        ephyr_glamor_damage_redisplay(scrpriv->glamor, &region);
        RegionUninit(&region);
        return;
    }
#endif

    /*
     *  Copy the image data updated by the shadow layer
     *  on to the window
     */

    if (HostXWantDamageDebug) {
        hostx_paint_debug_rect(screen, dx, dy, width, height);
    }

    /*
     * If the depth of the ephyr server is less than that of the host,
     * the kdrive fb does not point to the ximage data but to a buffer
     * ( fb_data ), we shift the various bits from this onto the XImage
     * so they match the host.
     *
     * Note, This code is pretty new ( and simple ) so may break on
     *       endian issues, 32 bpp host etc.
     *       Not sure if 8bpp case is right either.
     *       ... and it will be slower than the matching depth case.
     */

    if (!host_depth_matches_server(scrpriv)) {
        int x, y, idx, bytes_per_pixel = (scrpriv->server_depth >> 3);
        int stride = (scrpriv->win_width * bytes_per_pixel + 0x3) & ~0x3;
        unsigned char r, g, b;
        unsigned long host_pixel;

        EPHYR_DBG("Unmatched host depth scrpriv=%p\n", scrpriv);
        for (y = sy; y < sy + height; y++)
            for (x = sx; x < sx + width; x++) {
                idx = y * stride + x * bytes_per_pixel;

                switch (scrpriv->server_depth) {
                case 16:
                {
                    unsigned short pixel =
                        *(unsigned short *) (scrpriv->fb_data + idx);

                    r = ((pixel & 0xf800) >> 8);
                    g = ((pixel & 0x07e0) >> 3);
                    b = ((pixel & 0x001f) << 3);

                    host_pixel = (r << 16) | (g << 8) | (b);

                    xcb_image_put_pixel(scrpriv->ximg, x, y, host_pixel);
                    break;
                }
                case 8:
                {
                    unsigned char pixel =
                        *(unsigned char *) (scrpriv->fb_data + idx);
                    xcb_image_put_pixel(scrpriv->ximg, x, y,
                                        scrpriv->cmap[pixel]);
                    break;
                }
                default:
                    break;
                }
            }
    }

    if (HostX.have_shm) {
        xcb_image_shm_put(HostX.conn, scrpriv->win,
                          HostX.gc, scrpriv->ximg,
                          scrpriv->shminfo,
                          sx, sy, dx, dy, width, height, FALSE);
    }
    else {
        xcb_image_t *subimg = xcb_image_subimage(scrpriv->ximg, sx, sy,
                                                 width, height, 0, 0, 0);
        xcb_image_t *img = xcb_image_native(HostX.conn, subimg, 1);
        xcb_image_put(HostX.conn, scrpriv->win, HostX.gc, img, dx, dy, 0);
        if (subimg != img)
            xcb_image_destroy(img);
        xcb_image_destroy(subimg);
    }

    xcb_aux_sync(HostX.conn);
}

static void
hostx_paint_debug_rect(KdScreenInfo *screen,
                       int x, int y, int width, int height)
{
    EphyrScrPriv *scrpriv = screen->driver;
    struct timespec tspec;
    xcb_rectangle_t rect = { .x = x, .y = y, .width = width, .height = height };
    xcb_void_cookie_t cookie;
    xcb_generic_error_t *e;

    tspec.tv_sec = HostX.damage_debug_msec / (1000000);
    tspec.tv_nsec = (HostX.damage_debug_msec % 1000000) * 1000;

    EPHYR_DBG("msec: %li tv_sec %li, tv_msec %li",
              HostX.damage_debug_msec, tspec.tv_sec, tspec.tv_nsec);

    /* fprintf(stderr, "Xephyr updating: %i+%i %ix%i\n", x, y, width, height); */

    cookie = xcb_poly_fill_rectangle_checked(HostX.conn, scrpriv->win,
                                             HostX.gc, 1, &rect);
    e = xcb_request_check(HostX.conn, cookie);
    free(e);

    /* nanosleep seems to work better than usleep for me... */
    nanosleep(&tspec, NULL);
}

void
hostx_load_keymap(void)
{
    int min_keycode, max_keycode;

    min_keycode = xcb_get_setup(HostX.conn)->min_keycode;
    max_keycode = xcb_get_setup(HostX.conn)->max_keycode;

    EPHYR_DBG("min: %d, max: %d", min_keycode, max_keycode);

    ephyrKeySyms.minKeyCode = min_keycode;
    ephyrKeySyms.maxKeyCode = max_keycode;
}

xcb_connection_t *
hostx_get_xcbconn(void)
{
    return HostX.conn;
}

int
hostx_get_screen(void)
{
    return HostX.screen;
}

int
hostx_get_window(int a_screen_number)
{
    EphyrScrPriv *scrpriv;
    if (a_screen_number < 0 || a_screen_number >= HostX.n_screens) {
        EPHYR_LOG_ERROR("bad screen number:%d\n", a_screen_number);
        return 0;
    }
    scrpriv = HostX.screens[a_screen_number]->driver;
    return scrpriv->win;
}

int
hostx_get_window_attributes(int a_window, EphyrHostWindowAttributes * a_attrs)
{
    xcb_get_geometry_cookie_t geom_cookie;
    xcb_get_window_attributes_cookie_t attr_cookie;
    xcb_get_geometry_reply_t *geom_reply;
    xcb_get_window_attributes_reply_t *attr_reply;

    geom_cookie = xcb_get_geometry(HostX.conn, a_window);
    attr_cookie = xcb_get_window_attributes(HostX.conn, a_window);
    geom_reply = xcb_get_geometry_reply(HostX.conn, geom_cookie, NULL);
    attr_reply = xcb_get_window_attributes_reply(HostX.conn, attr_cookie, NULL);

    a_attrs->x = geom_reply->x;
    a_attrs->y = geom_reply->y;
    a_attrs->width = geom_reply->width;
    a_attrs->height = geom_reply->height;
    a_attrs->visualid = attr_reply->visual;

    free(geom_reply);
    free(attr_reply);
    return TRUE;
}

int
hostx_get_visuals_info(EphyrHostVisualInfo ** a_visuals, int *a_num_entries)
{
    Bool is_ok = FALSE;
    EphyrHostVisualInfo *host_visuals = NULL;
    int nb_items = 0, i = 0, screen_num;
    xcb_screen_iterator_t screens;
    xcb_depth_iterator_t depths;

    EPHYR_RETURN_VAL_IF_FAIL(a_visuals && a_num_entries, FALSE);
    EPHYR_LOG("enter\n");

    screens = xcb_setup_roots_iterator(xcb_get_setup(HostX.conn));
    for (screen_num = 0; screens.rem; screen_num++, xcb_screen_next(&screens)) {
        depths = xcb_screen_allowed_depths_iterator(screens.data);
        for (; depths.rem; xcb_depth_next(&depths)) {
            xcb_visualtype_t *visuals = xcb_depth_visuals(depths.data);
            EphyrHostVisualInfo *tmp_visuals =
                reallocarray(host_visuals,
                             nb_items + depths.data->visuals_len,
                             sizeof(EphyrHostVisualInfo));
            if (!tmp_visuals) {
                goto out;
            }
            host_visuals = tmp_visuals;
            for (i = 0; i < depths.data->visuals_len; i++) {
                host_visuals[nb_items + i].visualid = visuals[i].visual_id;
                host_visuals[nb_items + i].screen = screen_num;
                host_visuals[nb_items + i].depth = depths.data->depth;
                host_visuals[nb_items + i].class = visuals[i]._class;
                host_visuals[nb_items + i].red_mask = visuals[i].red_mask;
                host_visuals[nb_items + i].green_mask = visuals[i].green_mask;
                host_visuals[nb_items + i].blue_mask = visuals[i].blue_mask;
                host_visuals[nb_items + i].colormap_size = visuals[i].colormap_entries;
                host_visuals[nb_items + i].bits_per_rgb = visuals[i].bits_per_rgb_value;
            }
            nb_items += depths.data->visuals_len;
        }
    }

    EPHYR_LOG("host advertises %d visuals\n", nb_items);
    *a_visuals = host_visuals;
    *a_num_entries = nb_items;
    host_visuals = NULL;

    is_ok = TRUE;
out:
    free(host_visuals);
    host_visuals = NULL;
    EPHYR_LOG("leave\n");
    return is_ok;

}

int
hostx_create_window(int a_screen_number,
                    EphyrBox * a_geometry,
                    int a_visual_id, int *a_host_peer /*out parameter */ )
{
    Bool is_ok = FALSE;
    xcb_window_t win;
    int winmask = 0;
    uint32_t attrs[2];
    xcb_screen_t *screen = xcb_aux_get_screen(HostX.conn, hostx_get_screen());
    xcb_visualtype_t *visual;
    int depth = 0;
    EphyrScrPriv *scrpriv = HostX.screens[a_screen_number]->driver;

    EPHYR_RETURN_VAL_IF_FAIL(screen && a_geometry, FALSE);

    EPHYR_LOG("enter\n");

    visual = xcb_aux_find_visual_by_id(screen, a_visual_id);
    if (!visual) {
        EPHYR_LOG_ERROR ("argh, could not find a remote visual with id:%d\n",
                         a_visual_id);
        goto out;
    }
    depth = xcb_aux_get_depth_of_visual(screen, a_visual_id);

    winmask = XCB_CW_EVENT_MASK | XCB_CW_COLORMAP;
    attrs[0] = XCB_EVENT_MASK_BUTTON_PRESS
              |XCB_EVENT_MASK_BUTTON_RELEASE
              |XCB_EVENT_MASK_POINTER_MOTION
              |XCB_EVENT_MASK_KEY_PRESS
              |XCB_EVENT_MASK_KEY_RELEASE
              |XCB_EVENT_MASK_EXPOSURE;
    attrs[1] = xcb_generate_id(HostX.conn);
    xcb_create_colormap(HostX.conn,
                        XCB_COLORMAP_ALLOC_NONE,
                        attrs[1],
                        hostx_get_window(a_screen_number),
                        a_visual_id);

    win = xcb_generate_id(HostX.conn);
    xcb_create_window(HostX.conn,
                      depth,
                      win,
                      hostx_get_window (a_screen_number),
                      a_geometry->x, a_geometry->y,
                      a_geometry->width, a_geometry->height, 0,
                      XCB_WINDOW_CLASS_COPY_FROM_PARENT,
                      a_visual_id, winmask, attrs);

    if (scrpriv->peer_win == XCB_NONE) {
        scrpriv->peer_win = win;
    }
    else {
        EPHYR_LOG_ERROR("multiple peer windows created for same screen\n");
    }
    xcb_flush(HostX.conn);
    xcb_map_window(HostX.conn, win);
    *a_host_peer = win;
    is_ok = TRUE;
 out:
    EPHYR_LOG("leave\n");
    return is_ok;
}

int
hostx_destroy_window(int a_win)
{
    xcb_destroy_window(HostX.conn, a_win);
    xcb_flush(HostX.conn);
    return TRUE;
}

int
hostx_set_window_geometry(int a_win, EphyrBox * a_geo)
{
    uint32_t mask = XCB_CONFIG_WINDOW_X
                  | XCB_CONFIG_WINDOW_Y
                  | XCB_CONFIG_WINDOW_WIDTH
                  | XCB_CONFIG_WINDOW_HEIGHT;
    uint32_t values[4];

    EPHYR_RETURN_VAL_IF_FAIL(a_geo, FALSE);

    EPHYR_LOG("enter. x,y,w,h:(%d,%d,%d,%d)\n",
              a_geo->x, a_geo->y, a_geo->width, a_geo->height);

    values[0] = a_geo->x;
    values[1] = a_geo->y;
    values[2] = a_geo->width;
    values[3] = a_geo->height;
    xcb_configure_window(HostX.conn, a_win, mask, values);

    EPHYR_LOG("leave\n");
    return TRUE;
}

int
hostx_set_window_bounding_rectangles(int a_window,
                                     EphyrRect * a_rects, int a_num_rects)
{
    Bool is_ok = FALSE;
    int i = 0;
    xcb_rectangle_t *rects = NULL;

    EPHYR_RETURN_VAL_IF_FAIL(a_rects, FALSE);

    EPHYR_LOG("enter. num rects:%d\n", a_num_rects);

    rects = calloc(a_num_rects, sizeof (xcb_rectangle_t));
    if (!rects)
        goto out;
    for (i = 0; i < a_num_rects; i++) {
        rects[i].x = a_rects[i].x1;
        rects[i].y = a_rects[i].y1;
        rects[i].width = abs(a_rects[i].x2 - a_rects[i].x1);
        rects[i].height = abs(a_rects[i].y2 - a_rects[i].y1);
        EPHYR_LOG("borders clipped to rect[x:%d,y:%d,w:%d,h:%d]\n",
                  rects[i].x, rects[i].y, rects[i].width, rects[i].height);
    }
    xcb_shape_rectangles(HostX.conn,
                         XCB_SHAPE_SO_SET,
                         XCB_SHAPE_SK_BOUNDING,
                         XCB_CLIP_ORDERING_YX_BANDED,
                         a_window,
                         0, 0,
                         a_num_rects,
                         rects);
    is_ok = TRUE;

out:
    free(rects);
    rects = NULL;
    EPHYR_LOG("leave\n");
    return is_ok;
}

#ifdef XF86DRI
typedef struct {
    int is_valid;
    int local_id;
    int remote_id;
} ResourcePair;

#define RESOURCE_PEERS_SIZE 1024*10
static ResourcePair resource_peers[RESOURCE_PEERS_SIZE];

int
hostx_allocate_resource_id_peer(int a_local_resource_id,
                                int *a_remote_resource_id)
{
    int i = 0;
    ResourcePair *peer = NULL;

    /*
     * first make sure a resource peer
     * does not exist already for
     * a_local_resource_id
     */
    for (i = 0; i < RESOURCE_PEERS_SIZE; i++) {
        if (resource_peers[i].is_valid
            && resource_peers[i].local_id == a_local_resource_id) {
            peer = &resource_peers[i];
            break;
        }
    }
    /*
     * find one free peer entry, an feed it with
     */
    if (!peer) {
        for (i = 0; i < RESOURCE_PEERS_SIZE; i++) {
            if (!resource_peers[i].is_valid) {
                peer = &resource_peers[i];
                break;
            }
        }
        if (peer) {
            peer->remote_id = xcb_generate_id(HostX.conn);
            peer->local_id = a_local_resource_id;
            peer->is_valid = TRUE;
        }
    }
    if (peer) {
        *a_remote_resource_id = peer->remote_id;
        return TRUE;
    }
    return FALSE;
}

int
hostx_get_resource_id_peer(int a_local_resource_id, int *a_remote_resource_id)
{
    int i = 0;
    ResourcePair *peer = NULL;

    for (i = 0; i < RESOURCE_PEERS_SIZE; i++) {
        if (resource_peers[i].is_valid
            && resource_peers[i].local_id == a_local_resource_id) {
            peer = &resource_peers[i];
            break;
        }
    }
    if (peer) {
        *a_remote_resource_id = peer->remote_id;
        return TRUE;
    }
    return FALSE;
}

#endif                          /* XF86DRI */

#ifdef GLAMOR
Bool
ephyr_glamor_init(ScreenPtr screen)
{
    KdScreenPriv(screen);
    KdScreenInfo *kd_screen = pScreenPriv->screen;
    EphyrScrPriv *scrpriv = kd_screen->driver;

    scrpriv->glamor = ephyr_glamor_glx_screen_init(scrpriv->win);
    ephyr_glamor_set_window_size(scrpriv->glamor,
                                 scrpriv->win_width, scrpriv->win_height);

    if (!glamor_init(screen, 0)) {
        FatalError("Failed to initialize glamor\n");
        return FALSE;
    }

    return TRUE;
}

Bool
ephyr_glamor_create_screen_resources(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *kd_screen = pScreenPriv->screen;
    EphyrScrPriv *scrpriv = kd_screen->driver;
    PixmapPtr screen_pixmap;
    uint32_t tex;

    if (!ephyr_glamor)
        return TRUE;

    /* kdrive's fbSetupScreen() told mi to have
     * miCreateScreenResources() (which is called before this) make a
     * scratch pixmap wrapping ephyr-glamor's NULL
     * KdScreenInfo->fb.framebuffer.
     *
     * We want a real (texture-based) screen pixmap at this point.
     * This is what glamor will render into, and we'll then texture
     * out of that into the host's window to present the results.
     *
     * Thus, delete the current screen pixmap, and put a fresh one in.
     */
    screen_pixmap = pScreen->GetScreenPixmap(pScreen);
    pScreen->DestroyPixmap(screen_pixmap);

    screen_pixmap = pScreen->CreatePixmap(pScreen,
                                          pScreen->width,
                                          pScreen->height,
                                          pScreen->rootDepth,
                                          GLAMOR_CREATE_NO_LARGE);

    pScreen->SetScreenPixmap(screen_pixmap);

    /* Tell the GLX code what to GL texture to read from. */
    tex = glamor_get_pixmap_texture(screen_pixmap);
    ephyr_glamor_set_texture(scrpriv->glamor, tex);

    return TRUE;
}

void
ephyr_glamor_enable(ScreenPtr screen)
{
}

void
ephyr_glamor_disable(ScreenPtr screen)
{
}

void
ephyr_glamor_fini(ScreenPtr screen)
{
    KdScreenPriv(screen);
    KdScreenInfo *kd_screen = pScreenPriv->screen;
    EphyrScrPriv *scrpriv = kd_screen->driver;

    glamor_fini(screen);
    ephyr_glamor_glx_screen_fini(scrpriv->glamor);
    scrpriv->glamor = NULL;
}
#endif
@


1.13
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d102 10
d142 2
a143 2
    HostX.screens = realloc(HostX.screens,
                            HostX.n_screens * sizeof(HostX.screens[0]));
d253 1
a253 1
    if (!xcb_get_extension_data(HostX.conn, &xcb_randr_id)->present)
a434 1
    const xcb_query_extension_reply_t *shm_rep;
d644 1
a644 2
    shm_rep = xcb_get_extension_data(HostX.conn, &xcb_shm_id);
    if (!shm_rep || !shm_rep->present || getenv("XEPHYR_NO_SHM")) {
d883 1
a883 1
            malloc(scrpriv->ximg->stride * buffer_height);
d949 1
a949 1
        scrpriv->fb_data = malloc (stride * buffer_height);
d1169 3
a1171 3
                realloc(host_visuals,
                        (nb_items + depths.data->visuals_len)
                        * sizeof(EphyrHostVisualInfo));
d1428 1
a1428 3
    if (!glamor_init(screen,
                     GLAMOR_USE_SCREEN |
                     GLAMOR_USE_PICTURE_SCREEN)) {
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d1042 5
a1046 4
        /* This is slow and could be done better */
        xcb_image_t *img = xcb_image_native (HostX.conn, scrpriv->ximg, 1);
        xcb_image_put(HostX.conn, scrpriv->win, HostX.gc, img, 0, 0, 0);
        if (scrpriv->ximg != img)
d1048 1
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d4 2
a5 2
 * 
 * Copyright Â© 2004 Nokia 
d54 1
d74 2
a84 2

    unsigned long cmap[256];
d108 1
a108 1
hostx_want_screen_size(KdScreenInfo *screen, int *width, int *height)
d113 1
d115 2
d126 1
a126 1
hostx_add_screen(KdScreenInfo *screen, unsigned long win_id, int screen_num)
d138 2
d180 1
a180 1
                 HostX.server_dpy_name,
d205 6
d225 113
d415 2
a416 2
    uint32_t attr;
    xcb_cursor_t empty_cursor;
d418 1
d427 1
d429 1
a429 1
    attr =
d437 1
d446 1
a446 1
    if (xcb_connection_has_error(HostX.conn)) {
d456 1
a456 1
    if (ephyr_glamor)
d458 10
a467 1
    else
d487 2
d521 3
a523 3
                              XCB_COPY_FROM_PARENT,
                              XCB_CW_EVENT_MASK,
                              &attr);
d533 3
a535 3
                              XCB_COPY_FROM_PARENT,
                              XCB_CW_EVENT_MASK,
                              &attr);
d546 11
d604 16
a622 9
        cursor_pxm = xcb_generate_id(HostX.conn);
        xcb_create_pixmap(HostX.conn, 1, cursor_pxm, HostX.winroot, 1, 1);
        empty_cursor = xcb_generate_id(HostX.conn);
        xcb_create_cursor(HostX.conn,
                          empty_cursor,
                          cursor_pxm, cursor_pxm,
                          0,0,0,
                          0,0,0,
                          1,1);
d630 1
a630 1
                                         &empty_cursor);
a631 1
        xcb_free_pixmap(HostX.conn, cursor_pxm);
d752 1
a752 1
hostx_set_cmap_entry(unsigned char idx,
d755 3
d769 1
a769 1
    HostX.cmap[idx] = ((r << rshift) & HostX.visual->red_mask) |
d788 1
d800 2
a801 2
    EPHYR_DBG("host_screen=%p wxh=%dx%d, buffer_height=%d",
              host_screen, width, height, buffer_height);
d869 5
d897 13
d914 2
d983 1
a983 1
    /* 
d989 3
a991 3
     * Note, This code is pretty new ( and simple ) so may break on 
     *       endian issues, 32 bpp host etc. 
     *       Not sure if 8bpp case is right either. 
d1026 1
a1026 1
                                        HostX.cmap[pixel]);
d1042 5
a1046 2
        xcb_image_put(HostX.conn, scrpriv->win, HostX.gc, scrpriv->ximg,
                      dx, dy, 0);
d1418 6
a1423 4
    glamor_init(screen,
                GLAMOR_USE_SCREEN |
                GLAMOR_USE_PICTURE_SCREEN |
                GLAMOR_INVERTED_Y_AXIS);
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d39 1
d58 5
a93 2
extern int monitorResolution;

d99 1
d312 6
a317 1
    HostX.conn = xcb_connect(NULL, &HostX.screen);
d327 6
a332 1
    HostX.visual  = xcb_aux_find_visual_by_id(xscreen, xscreen->root_visual);
d662 1
a662 1
    if (HostX.have_shm) {
d697 1
a697 1
    if (!shm_success) {
d737 9
d777 17
d1222 84
@


1.9
log
@Uodate to xserver 1.14.2. Tested by krw@@, shadchin@@, todd@@
@
text
@a29 11
/*
 * including some server headers (like kdrive-config.h)
 * might define the macro _XSERVER64
 * on 64 bits machines. That macro must _NOT_ be defined for Xlib
 * client code, otherwise bad things happen.
 * So let's undef that macro if necessary.
 */
#ifdef _XSERVER64
#undef _XSERVER64
#endif

d31 1
a43 3
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>
d45 8
a52 2
#include <X11/extensions/XShm.h>
#include <X11/extensions/shape.h>
d54 3
a56 2
#include <GL/glx.h>
#endif                          /* XF86DRI */
d58 1
a58 25

#ifdef XF86DRI
extern Bool XF86DRIQueryExtension(Display * dpy,
                                  int *event_basep, int *error_basep);
#endif

/*  
 * All xlib calls go here, which gets built as its own .a .
 * Mixing kdrive and xlib headers causes all sorts of types
 * to get clobbered. 
 */

struct EphyrHostScreen {
    Window win;
    Window win_pre_existing;    /* Set via -parent option like xnest */
    Window peer_win;            /* Used for GL; should be at most one */
    XImage *ximg;
    int win_width, win_height;
    int server_depth;
    unsigned char *fb_data;     /* only used when host bpp != server bpp */
    XShmSegmentInfo shminfo;

    void *info;                 /* Pointer to the screen this is associated with */
    int mynum;                  /* Screen number */
};
d62 1
a62 1
    Display *dpy;
d64 1
a64 1
    Visual *visual;
d66 1
a66 1
    GC gc;
d68 1
a68 1
    Bool use_host_cursor;
d73 1
a73 1
    struct EphyrHostScreen *screens;
d90 2
a98 5
/* X Error traps */

static int trapped_error_code = 0;
static int (*old_error_handler) (Display * d, XErrorEvent * e);

a100 34
static struct EphyrHostScreen *
host_screen_from_screen_info(EphyrScreenInfo * screen)
{
    int i;

    for (i = 0; i < HostX.n_screens; i++) {
        if (HostX.screens[i].info == screen) {
            return &HostX.screens[i];
        }
    }
    return NULL;
}

static int
error_handler(Display * display, XErrorEvent * error)
{
    trapped_error_code = error->error_code;
    return 0;
}

static void
hostx_errors_trap(void)
{
    trapped_error_code = 0;
    old_error_handler = XSetErrorHandler(error_handler);
}

static int
hostx_errors_untrap(void)
{
    XSetErrorHandler(old_error_handler);
    return trapped_error_code;
}

d102 1
a102 1
hostx_want_screen_size(EphyrScreenInfo screen, int *width, int *height)
d104 1
a104 1
    struct EphyrHostScreen *host_screen = host_screen_from_screen_info(screen);
d106 4
a109 5
    if (host_screen &&
        (host_screen->win_pre_existing != None ||
         HostX.use_fullscreen == True)) {
        *width = host_screen->win_width;
        *height = host_screen->win_height;
d117 1
a117 1
hostx_add_screen(EphyrScreenInfo screen, unsigned long win_id, int screen_num)
d119 1
d124 2
a125 2
                            HostX.n_screens * sizeof(struct EphyrHostScreen));
    memset(&HostX.screens[index], 0, sizeof(struct EphyrHostScreen));
d127 2
a128 2
    HostX.screens[index].info = screen;
    HostX.screens[index].win_pre_existing = win_id;
d138 1
a138 1
hostx_set_screen_number(EphyrScreenInfo screen, int number)
d140 1
a140 1
    struct EphyrHostScreen *host_screen = host_screen_from_screen_info(screen);
d142 3
a144 3
    if (host_screen) {
        host_screen->mynum = number;
        hostx_set_win_title(host_screen->info, "");
d149 1
a149 1
hostx_set_win_title(EphyrScreenInfo screen, char *extra_text)
d151 1
a151 1
    struct EphyrHostScreen *host_screen = host_screen_from_screen_info(screen);
d153 1
a153 1
    if (!host_screen)
d157 7
a163 3
        XStoreName(HostX.dpy, host_screen->win, ephyrTitle);
    }
    else {
d170 1
a170 1
                 host_screen->mynum, (extra_text != NULL) ? extra_text : "");
d172 7
a178 1
        XStoreName(HostX.dpy, host_screen->win, buf);
d185 1
a185 1
    return HostX.use_host_cursor;
d189 1
a189 1
hostx_use_host_cursor(void)
d191 1
a191 1
    HostX.use_host_cursor = True;
d195 1
a195 1
hostx_want_preexisting_window(EphyrScreenInfo screen)
d197 1
a197 1
    struct EphyrHostScreen *host_screen = host_screen_from_screen_info(screen);
d199 1
a199 1
    if (host_screen && host_screen->win_pre_existing) {
d210 1
a210 1
    HostX.use_fullscreen = True;
d219 3
d225 1
a225 1
    Atom atom_WINDOW_STATE, atom_WINDOW_STATE_FULLSCREEN;
d227 1
d229 8
a236 3
    atom_WINDOW_STATE = XInternAtom(HostX.dpy, "_NET_WM_STATE", False);
    atom_WINDOW_STATE_FULLSCREEN
        = XInternAtom(HostX.dpy, "_NET_WM_STATE_FULLSCREEN", False);
d239 9
a247 4
        XChangeProperty(HostX.dpy, HostX.screens[index].win,
                        atom_WINDOW_STATE, XA_ATOM, 32,
                        PropModeReplace,
                        (unsigned char *) &atom_WINDOW_STATE_FULLSCREEN, 1);
a281 9
static int _X_NORETURN
x_io_error_handler(Display * dpy)
{
    ErrorF("Lost connection to X server: %s\n", strerror(errno));
    CloseWellKnownConnections();
    OsCleanup(1);
    exit(1);
}

d285 5
a289 4
    XSetWindowAttributes attr;
    Cursor empty_cursor;
    Pixmap cursor_pxm;
    XColor col;
d292 13
a304 10
    XClassHint *class_hint;

    attr.event_mask =
        ButtonPressMask
        | ButtonReleaseMask
        | PointerMotionMask
        | KeyPressMask
        | KeyReleaseMask
        | ExposureMask
        | StructureNotifyMask;
d307 2
a308 2

    if ((HostX.dpy = XOpenDisplay(getenv("DISPLAY"))) == NULL) {
d313 14
a326 9
    XSetIOErrorHandler(x_io_error_handler);

    HostX.screen = DefaultScreen(HostX.dpy);
    HostX.winroot = RootWindow(HostX.dpy, HostX.screen);
    HostX.gc = XCreateGC(HostX.dpy, HostX.winroot, 0, NULL);
    HostX.depth = DefaultDepth(HostX.dpy, HostX.screen);
    HostX.visual = DefaultVisual(HostX.dpy, HostX.screen);

    class_hint = XAllocClassHint();
d329 2
a330 1
        struct EphyrHostScreen *host_screen = &HostX.screens[index];
d332 8
a339 4
        host_screen->server_depth = HostX.depth;
        if (host_screen->win_pre_existing != None) {
            Status result;
            XWindowAttributes prewin_attr;
d342 10
d353 2
a354 10
            hostx_errors_trap();

            result = XGetWindowAttributes(HostX.dpy,
                                          host_screen->win_pre_existing,
                                          &prewin_attr);

            if (hostx_errors_untrap() || !result) {
                fprintf(stderr, "\nXephyr -parent window' does not exist!\n");
                exit(1);
            }
d356 1
a356 2
            host_screen->win_width = prewin_attr.width;
            host_screen->win_height = prewin_attr.height;
d358 12
a369 10
            host_screen->win = XCreateWindow(HostX.dpy,
                                             host_screen->win_pre_existing,
                                             0, 0,
                                             host_screen->win_width,
                                             host_screen->win_height,
                                             0,
                                             CopyFromParent,
                                             CopyFromParent,
                                             CopyFromParent,
                                             CWEventMask, &attr);
d372 10
a381 6
            host_screen->win = XCreateWindow(HostX.dpy, HostX.winroot, 0, 0, 100, 100,  /* will resize */
                                             0,
                                             CopyFromParent,
                                             CopyFromParent,
                                             CopyFromParent,
                                             CWEventMask, &attr);
d383 1
a383 1
            hostx_set_win_title(host_screen->info,
d387 2
a388 3
                host_screen->win_width = DisplayWidth(HostX.dpy, HostX.screen);
                host_screen->win_height =
                    DisplayHeight(HostX.dpy, HostX.screen);
d393 5
d399 11
a409 8
                tmpstr = getenv("RESOURCE_NAME");
                if (tmpstr && (!ephyrResNameFromCmd))
                    ephyrResName = tmpstr;
                class_hint->res_name = ephyrResName;
                class_hint->res_class = "Xephyr";
                XSetClassHint(hostx_get_display(), host_screen->win,
                              class_hint);

a410 1

d414 22
a435 2
    if (class_hint)
        XFree(class_hint);
d437 1
a437 4
    XParseColor(HostX.dpy, DefaultColormap(HostX.dpy, HostX.screen),
                "red", &col);
    XAllocColor(HostX.dpy, DefaultColormap(HostX.dpy, HostX.screen), &col);
    XSetForeground(HostX.dpy, HostX.gc, col.pixel);
d439 2
a440 1
    if (!hostx_want_host_cursor()) {
d442 9
a450 5
        cursor_pxm = XCreatePixmap(HostX.dpy, HostX.winroot, 1, 1, 1);
        memset(&col, 0, sizeof(col));
        empty_cursor = XCreatePixmapCursor(HostX.dpy,
                                           cursor_pxm, cursor_pxm,
                                           &col, &col, 1, 1);
d452 7
a458 1
            XDefineCursor(HostX.dpy, HostX.screens[index].win, empty_cursor);
d460 1
a460 1
        XFreePixmap(HostX.dpy, cursor_pxm);
a462 3
    for (index = 0; index < HostX.n_screens; index++) {
        HostX.screens[index].ximg = NULL;
    }
d464 2
a465 2

    if (!XShmQueryExtension(HostX.dpy) || getenv("XEPHYR_NO_SHM")) {
d467 1
a467 1
        HostX.have_shm = False;
d470 15
a484 4
        /* Really really check we have shm - better way ? */
        XShmSegmentInfo shminfo;

        HostX.have_shm = True;
d486 1
a486 10
        shminfo.shmid = shmget(IPC_PRIVATE, 1, IPC_CREAT | 0777);
        shminfo.shmaddr = shmat(shminfo.shmid, 0, 0);
        shminfo.readOnly = True;

        hostx_errors_trap();

        XShmAttach(HostX.dpy, &shminfo);
        XSync(HostX.dpy, False);

        if (hostx_errors_untrap()) {
d488 2
a489 1
            HostX.have_shm = False;
d496 1
a496 1
    XFlush(HostX.dpy);
d517 1
a517 9
hostx_get_server_depth(EphyrScreenInfo screen)
{
    struct EphyrHostScreen *host_screen = host_screen_from_screen_info(screen);

    return host_screen ? host_screen->server_depth : 0;
}

void
hostx_set_server_depth(EphyrScreenInfo screen, int depth)
d519 1
a519 1
    struct EphyrHostScreen *host_screen = host_screen_from_screen_info(screen);
d521 1
a521 2
    if (host_screen)
        host_screen->server_depth = depth;
d525 1
a525 1
hostx_get_bpp(EphyrScreenInfo screen)
d527 1
a527 1
    struct EphyrHostScreen *host_screen = host_screen_from_screen_info(screen);
d529 1
a529 1
    if (!host_screen)
d532 2
a533 2
    if (host_depth_matches_server(host_screen))
        return HostX.visual->bits_per_rgb;
d535 1
a535 1
        return host_screen->server_depth;       /*XXX correct ? */
d539 1
a539 1
hostx_get_visual_masks(EphyrScreenInfo screen,
d542 1
a542 1
    struct EphyrHostScreen *host_screen = host_screen_from_screen_info(screen);
d544 1
a544 1
    if (!host_screen)
d547 1
a547 1
    if (host_depth_matches_server(host_screen)) {
d552 1
a552 1
    else if (host_screen->server_depth == 16) {
d613 1
a613 1
hostx_screen_init(EphyrScreenInfo screen,
d617 2
a618 5
    int bitmap_pad;
    Bool shm_success = False;
    XSizeHints *size_hints;

    struct EphyrHostScreen *host_screen = host_screen_from_screen_info(screen);
d620 1
a620 1
    if (!host_screen) {
d628 1
a628 1
    if (host_screen->ximg != NULL) {
d634 4
a637 4
            XShmDetach(HostX.dpy, &host_screen->shminfo);
            XDestroyImage(host_screen->ximg);
            shmdt(host_screen->shminfo.shmaddr);
            shmctl(host_screen->shminfo.shmid, IPC_RMID, 0);
d640 2
a641 2
            free(host_screen->ximg->data);
            host_screen->ximg->data = NULL;
d643 1
a643 1
            XDestroyImage(host_screen->ximg);
d648 8
a655 3
        host_screen->ximg =
            XShmCreateImage(HostX.dpy, HostX.visual, HostX.depth, ZPixmap, NULL,
                            &host_screen->shminfo, width, buffer_height);
d657 1
a657 1
        host_screen->shminfo.shmid =
d659 1
a659 1
                   host_screen->ximg->bytes_per_line * buffer_height,
d661 2
a662 2
        host_screen->ximg->data = shmat(host_screen->shminfo.shmid, 0, 0);
        host_screen->shminfo.shmaddr = host_screen->ximg->data;
d664 1
a664 1
        if (host_screen->ximg->data == (char *) -1) {
d667 3
a669 3
            HostX.have_shm = False;
            XDestroyImage(host_screen->ximg);
            shmctl(host_screen->shminfo.shmid, IPC_RMID, 0);
d672 7
a678 4
            EPHYR_DBG("SHM segment attached %p", host_screen->shminfo.shmaddr);
            host_screen->shminfo.readOnly = False;
            XShmAttach(HostX.dpy, &host_screen->shminfo);
            shm_success = True;
d683 42
a724 1
        bitmap_pad = (HostX.depth > 16) ? 32 : ((HostX.depth > 8) ? 16 : 8);
d726 2
a727 10
        EPHYR_DBG("Creating image %dx%d for screen host_screen=%p\n",
                  width, buffer_height, host_screen);
        host_screen->ximg = XCreateImage(HostX.dpy,
                                         HostX.visual,
                                         HostX.depth,
                                         ZPixmap, 0, 0,
                                         width, buffer_height, bitmap_pad, 0);

        host_screen->ximg->data =
            malloc(host_screen->ximg->bytes_per_line * buffer_height);
d729 3
d733 2
a734 21
    *bytes_per_line = host_screen->ximg->bytes_per_line;
    *bits_per_pixel = host_screen->ximg->bits_per_pixel;

    XResizeWindow(HostX.dpy, host_screen->win, width, height);

    /* Ask the WM to keep our size static */
    if (host_screen->win_pre_existing == None) {
        size_hints = XAllocSizeHints();
        size_hints->max_width = size_hints->min_width = width;
        size_hints->max_height = size_hints->min_height = height;
        size_hints->flags = PMinSize | PMaxSize;
        XSetWMNormalHints(HostX.dpy, host_screen->win, size_hints);
        XFree(size_hints);
    }

    XMapWindow(HostX.dpy, host_screen->win);

    XSync(HostX.dpy, False);

    host_screen->win_width = width;
    host_screen->win_height = height;
d736 3
a738 9
    if (host_depth_matches_server(host_screen)) {
        EPHYR_DBG("Host matches server");
        return host_screen->ximg->data;
    }
    else {
        EPHYR_DBG("server bpp %i", host_screen->server_depth >> 3);
        host_screen->fb_data =
            malloc(width * buffer_height * (host_screen->server_depth >> 3));
        return host_screen->fb_data;
d742 1
a742 1
static void hostx_paint_debug_rect(struct EphyrHostScreen *host_screen,
d746 1
a746 1
hostx_paint_rect(EphyrScreenInfo screen,
d749 1
a749 1
    struct EphyrHostScreen *host_screen = host_screen_from_screen_info(screen);
d751 1
a751 1
    EPHYR_DBG("painting in screen %d\n", host_screen->mynum);
d759 1
a759 1
        hostx_paint_debug_rect(host_screen, dx, dy, width, height);
d774 3
a776 2
    if (!host_depth_matches_server(host_screen)) {
        int x, y, idx, bytes_per_pixel = (host_screen->server_depth >> 3);
d780 1
a780 1
        EPHYR_DBG("Unmatched host depth host_screen=%p\n", host_screen);
d783 1
a783 3
                idx =
                    (host_screen->win_width * y * bytes_per_pixel) +
                    (x * bytes_per_pixel);
d785 1
a785 1
                switch (host_screen->server_depth) {
d789 1
a789 1
                        *(unsigned short *) (host_screen->fb_data + idx);
d797 1
a797 1
                    XPutPixel(host_screen->ximg, x, y, host_pixel);
d803 3
a805 2
                        *(unsigned char *) (host_screen->fb_data + idx);
                    XPutPixel(host_screen->ximg, x, y, HostX.cmap[pixel]);
d815 4
a818 3
        XShmPutImage(HostX.dpy, host_screen->win,
                     HostX.gc, host_screen->ximg,
                     sx, sy, dx, dy, width, height, False);
d821 2
a822 2
        XPutImage(HostX.dpy, host_screen->win, HostX.gc, host_screen->ximg,
                  sx, sy, dx, dy, width, height);
d825 1
a825 1
    XSync(HostX.dpy, False);
d829 1
a829 1
hostx_paint_debug_rect(struct EphyrHostScreen *host_screen,
d832 1
d834 3
d846 4
a849 2
    XFillRectangle(HostX.dpy, host_screen->win, HostX.gc, x, y, width, height);
    XSync(HostX.dpy, False);
d858 1
a858 3
    XID *keymap;
    int host_width, min_keycode, max_keycode, width;
    int i, j;
d860 2
a861 1
    XDisplayKeycodes(HostX.dpy, &min_keycode, &max_keycode);
a864 25
    keymap = XGetKeyboardMapping(HostX.dpy,
                                 min_keycode,
                                 max_keycode - min_keycode + 1, &host_width);

    /* Try and copy the hosts keymap into our keymap to avoid loads
     * of messing around.
     *
     * kdrive cannot can have more than 4 keysyms per keycode
     * so we only copy at most the first 4 ( xorg has 6 per keycode, XVNC 2 )
     */
    width = (host_width > 4) ? 4 : host_width;

    ephyrKeySyms.map = (CARD32 *) calloc(sizeof(CARD32),
                                         (max_keycode - min_keycode + 1) *
                                         width);
    if (!ephyrKeySyms.map)
        return;

    for (i = 0; i < (max_keycode - min_keycode + 1); i++)
        for (j = 0; j < width; j++)
            ephyrKeySyms.map[(i * width) + j] =
                (CARD32) keymap[(i * host_width) + j];

    EPHYR_DBG("keymap width, host:%d kdrive:%d", host_width, width);

a866 3
    ephyrKeySyms.mapWidth = width;

    XFree(keymap);
d869 2
a870 2
static struct EphyrHostScreen *
host_screen_from_window(Window w)
d872 1
a872 14
    int index = 0;
    struct EphyrHostScreen *result = NULL;

    for (index = 0; index < HostX.n_screens; index++) {
        if (HostX.screens[index].win == w
            || HostX.screens[index].peer_win == w
            || HostX.screens[index].win_pre_existing == w) {
            result = &HostX.screens[index];
            goto out;
        }
    }

 out:
    return result;
d876 1
a876 141
hostx_get_event(EphyrHostXEvent * ev)
{
    XEvent xev;
    static int grabbed_screen = -1;

    if (XPending(HostX.dpy)) {
        XNextEvent(HostX.dpy, &xev);

        switch (xev.type) {
        case Expose:
            /* Not so great event compression, but works ok */
            while (XCheckTypedWindowEvent(HostX.dpy, xev.xexpose.window,
                                          Expose, &xev));
            {
                struct EphyrHostScreen *host_screen =
                    host_screen_from_window(xev.xexpose.window);
                if (host_screen) {
                    hostx_paint_rect(host_screen->info, 0, 0, 0, 0,
                                     host_screen->win_width,
                                     host_screen->win_height);
                }
                else {
                    EPHYR_LOG_ERROR("failed to get host screen\n");
                    ev->type = EPHYR_EV_EXPOSE;
                    ev->data.expose.window = xev.xexpose.window;
                    return 1;
                }
            }
            return 0;

        case MotionNotify:
        {
            struct EphyrHostScreen *host_screen =
                host_screen_from_window(xev.xmotion.window);

            ev->type = EPHYR_EV_MOUSE_MOTION;
            ev->data.mouse_motion.x = xev.xmotion.x;
            ev->data.mouse_motion.y = xev.xmotion.y;
            ev->data.mouse_motion.window = xev.xmotion.window;
            ev->data.mouse_motion.screen =
                (host_screen ? host_screen->mynum : -1);
        }
            return 1;

        case ButtonPress:
            ev->type = EPHYR_EV_MOUSE_PRESS;
            ev->key_state = xev.xkey.state;
            /* 
             * This is a bit hacky. will break for button 5 ( defined as 0x10 )
             * Check KD_BUTTON defines in kdrive.h 
             */
            ev->data.mouse_down.button_num = 1 << (xev.xbutton.button - 1);
            return 1;

        case ButtonRelease:
            ev->type = EPHYR_EV_MOUSE_RELEASE;
            ev->key_state = xev.xkey.state;
            ev->data.mouse_up.button_num = 1 << (xev.xbutton.button - 1);
            return 1;

        case KeyPress:
        {
            ev->type = EPHYR_EV_KEY_PRESS;
            ev->key_state = xev.xkey.state;
            ev->data.key_down.scancode = xev.xkey.keycode;
            return 1;
        }
        case KeyRelease:

            if ((XKeycodeToKeysym(HostX.dpy, xev.xkey.keycode, 0) == XK_Shift_L
                 || XKeycodeToKeysym(HostX.dpy, xev.xkey.keycode,
                                     0) == XK_Shift_R)
                && (xev.xkey.state & ControlMask)) {
                struct EphyrHostScreen *host_screen =
                    host_screen_from_window(xev.xexpose.window);

                if (grabbed_screen != -1) {
                    XUngrabKeyboard(HostX.dpy, CurrentTime);
                    XUngrabPointer(HostX.dpy, CurrentTime);
                    grabbed_screen = -1;
                    hostx_set_win_title(host_screen->info,
                                        "(ctrl+shift grabs mouse and keyboard)");
                }
                else {
                    /* Attempt grab */
                    if (XGrabKeyboard(HostX.dpy, host_screen->win, True,
                                      GrabModeAsync,
                                      GrabModeAsync, CurrentTime) == 0) {
                        if (XGrabPointer(HostX.dpy, host_screen->win, True,
                                         NoEventMask,
                                         GrabModeAsync,
                                         GrabModeAsync,
                                         host_screen->win, None,
                                         CurrentTime) == 0) {
                            grabbed_screen = host_screen->mynum;
                            hostx_set_win_title
                                (host_screen->info,
                                 "(ctrl+shift releases mouse and keyboard)");
                        }
                        else    /* Failed pointer grabm  ungrab keyboard */
                            XUngrabKeyboard(HostX.dpy, CurrentTime);
                    }
                }
            }

            /* Still send the release event even if above has happened
             * server will get confused with just an up event. 
             * Maybe it would be better to just block shift+ctrls getting to
             * kdrive all togeather. 
             */
            ev->type = EPHYR_EV_KEY_RELEASE;
            ev->key_state = xev.xkey.state;
            ev->data.key_up.scancode = xev.xkey.keycode;
            return 1;

        case ConfigureNotify:
        {
            struct EphyrHostScreen *host_screen =
                host_screen_from_window(xev.xconfigure.window);

            if (host_screen && host_screen->win_pre_existing != None) {
                ev->type = EPHYR_EV_CONFIGURE;
                ev->data.configure.width = xev.xconfigure.width;
                ev->data.configure.height = xev.xconfigure.height;
                ev->data.configure.window = xev.xconfigure.window;
                ev->data.configure.screen = host_screen->mynum;
                return 1;
            }

            return 0;
        }
        default:
            break;

        }
    }
    return 0;
}

void *
hostx_get_display(void)
d878 1
a878 1
    return HostX.dpy;
d884 1
d889 2
a890 1
    return HostX.screens[a_screen_number].win;
d896 15
a910 3
    XWindowAttributes attrs;

    memset(&attrs, 0, sizeof(attrs));
d912 2
a913 9
    if (!XGetWindowAttributes(hostx_get_display(), a_window, &attrs)) {
        return FALSE;
    }
    a_attrs->x = attrs.x;
    a_attrs->y = attrs.y;
    a_attrs->width = attrs.width;
    a_attrs->height = attrs.height;
    if (attrs.visual)
        a_attrs->visualid = attrs.visual->visualid;
a917 15
hostx_get_extension_info(const char *a_ext_name,
                         int *a_major_opcode,
                         int *a_first_event, int *a_first_error)
{
    if (!a_ext_name || !a_major_opcode || !a_first_event || !a_first_error)
        return 0;
    if (!XQueryExtension(HostX.dpy,
                         a_ext_name,
                         a_major_opcode, a_first_event, a_first_error)) {
        return 0;
    }
    return 1;
}

int
d920 1
a920 3
    Display *dpy = hostx_get_display();
    Bool is_ok = False;
    XVisualInfo templ, *visuals = NULL;
d922 3
a924 1
    int nb_items = 0, i = 0;
d926 1
a926 1
    EPHYR_RETURN_VAL_IF_FAIL(a_visuals && a_num_entries && dpy, False);
d928 27
a954 5
    memset(&templ, 0, sizeof(templ));
    visuals = XGetVisualInfo(dpy, VisualNoMask, &templ, &nb_items);
    if (!visuals) {
        EPHYR_LOG_ERROR("host does not advertise any visual\n");
        goto out;
d956 1
a957 12
    host_visuals = calloc(nb_items, sizeof(EphyrHostVisualInfo));
    for (i = 0; i < nb_items; i++) {
        host_visuals[i].visualid = visuals[i].visualid;
        host_visuals[i].screen = visuals[i].screen;
        host_visuals[i].depth = visuals[i].depth;
        host_visuals[i].class = visuals[i].class;
        host_visuals[i].red_mask = visuals[i].red_mask;
        host_visuals[i].green_mask = visuals[i].green_mask;
        host_visuals[i].blue_mask = visuals[i].blue_mask;
        host_visuals[i].colormap_size = visuals[i].colormap_size;
        host_visuals[i].bits_per_rgb = visuals[i].bits_per_rgb;
    }
d963 1
a963 5
 out:
    if (visuals) {
        XFree(visuals);
        visuals = NULL;
    }
d977 7
a983 6
    Display *dpy = hostx_get_display();
    XVisualInfo *visual_info = NULL, visual_info_templ;
    int visual_mask = VisualIDMask;
    Window win = None;
    int nb_visuals = 0, winmask = 0;
    XSetWindowAttributes attrs;
d985 1
a985 1
    EPHYR_RETURN_VAL_IF_FAIL(dpy && a_geometry, FALSE);
d989 4
a992 8
    /*get visual */
    memset(&visual_info, 0, sizeof(visual_info));
    visual_info_templ.visualid = a_visual_id;
    visual_info = XGetVisualInfo(dpy, visual_mask,
                                 &visual_info_templ, &nb_visuals);
    if (!visual_info) {
        EPHYR_LOG_ERROR("argh, could not find a remote visual with id:%d\n",
                        a_visual_id);
d995 28
a1022 21
    memset(&attrs, 0, sizeof(attrs));
    attrs.colormap = XCreateColormap(dpy,
                                     RootWindow(dpy,
                                                visual_info->screen),
                                     visual_info->visual, AllocNone);
    attrs.event_mask = ButtonPressMask
        | ButtonReleaseMask
        | PointerMotionMask | KeyPressMask | KeyReleaseMask | ExposureMask;
    winmask = CWColormap | CWEventMask;

    win = XCreateWindow(dpy, hostx_get_window(a_screen_number),
                        a_geometry->x, a_geometry->y,
                        a_geometry->width, a_geometry->height, 0,
                        visual_info->depth, CopyFromParent,
                        visual_info->visual, winmask, &attrs);
    if (win == None) {
        EPHYR_LOG_ERROR("failed to create peer window\n");
        goto out;
    }
    if (HostX.screens[a_screen_number].peer_win == None) {
        HostX.screens[a_screen_number].peer_win = win;
d1027 2
a1028 2
    XFlush(dpy);
    XMapWindow(dpy, win);
d1039 2
a1040 5
    Display *dpy = hostx_get_display();

    EPHYR_RETURN_VAL_IF_FAIL(dpy, FALSE);
    XDestroyWindow(dpy, a_win);
    XFlush(dpy);
d1047 5
a1051 1
    Display *dpy = hostx_get_display();
d1053 1
a1053 1
    EPHYR_RETURN_VAL_IF_FAIL(dpy && a_geo, FALSE);
d1058 6
a1063 2
    XMoveWindow(dpy, a_win, a_geo->x, a_geo->y);
    XResizeWindow(dpy, a_win, a_geo->width, a_geo->height);
a1072 1
    Display *dpy = hostx_get_display();
d1074 1
a1074 1
    XRectangle *rects = NULL;
d1076 1
a1076 1
    EPHYR_RETURN_VAL_IF_FAIL(dpy && a_rects, FALSE);
d1080 3
a1082 1
    rects = calloc(a_num_rects, sizeof(XRectangle));
d1091 8
a1098 36
    /*this aways returns 1 */
    XShapeCombineRectangles(dpy, a_window, ShapeBounding, 0, 0,
                            rects, a_num_rects, ShapeSet, YXBanded);
    is_ok = TRUE;

    free(rects);
    rects = NULL;
    EPHYR_LOG("leave\n");
    return is_ok;
}

int
hostx_set_window_clipping_rectangles(int a_window,
                                     EphyrRect * a_rects, int a_num_rects)
{
    Bool is_ok = FALSE;
    Display *dpy = hostx_get_display();
    int i = 0;
    XRectangle *rects = NULL;

    EPHYR_RETURN_VAL_IF_FAIL(dpy && a_rects, FALSE);

    EPHYR_LOG("enter. num rects:%d\n", a_num_rects);

    rects = calloc(a_num_rects, sizeof(XRectangle));
    for (i = 0; i < a_num_rects; i++) {
        rects[i].x = a_rects[i].x1;
        rects[i].y = a_rects[i].y1;
        rects[i].width = abs(a_rects[i].x2 - a_rects[i].x1);
        rects[i].height = abs(a_rects[i].y2 - a_rects[i].y1);
        EPHYR_LOG("clipped to rect[x:%d,y:%d,w:%d,h:%d]\n",
                  rects[i].x, rects[i].y, rects[i].width, rects[i].height);
    }
    /*this aways returns 1 */
    XShapeCombineRectangles(dpy, a_window, ShapeClip, 0, 0,
                            rects, a_num_rects, ShapeSet, YXBanded);
d1101 1
a1107 12
int
hostx_has_xshape(void)
{
    int event_base = 0, error_base = 0;
    Display *dpy = hostx_get_display();

    if (!XShapeQueryExtension(dpy, &event_base, &error_base)) {
        return FALSE;
    }
    return TRUE;
}

a1123 1
    Display *dpy = hostx_get_display();
d1148 1
a1148 1
            peer->remote_id = XAllocID(dpy);
a1177 27
}

int
hostx_has_dri(void)
{
    int event_base = 0, error_base = 0;
    Display *dpy = hostx_get_display();

    if (!dpy)
        return FALSE;

    if (!XF86DRIQueryExtension(dpy, &event_base, &error_base)) {
        return FALSE;
    }
    return TRUE;
}

int
hostx_has_glx(void)
{
    Display *dpy = hostx_get_display();
    int event_base = 0, error_base = 0;

    if (!glXQueryExtension(dpy, &event_base, &error_base)) {
        return FALSE;
    }
    return TRUE;
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d620 2
a621 1
                  int width, int height, int buffer_height)
d697 3
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d348 5
a352 1
        | PointerMotionMask | KeyPressMask | KeyReleaseMask | ExposureMask;
d700 8
a707 6
    size_hints = XAllocSizeHints();
    size_hints->max_width = size_hints->min_width = width;
    size_hints->max_height = size_hints->min_height = height;
    size_hints->flags = PMinSize | PMaxSize;
    XSetWMNormalHints(HostX.dpy, host_screen->win, size_hints);
    XFree(size_hints);
d884 3
a886 1
        if (HostX.screens[index].win == w || HostX.screens[index].peer_win == w) {
d1012 16
@


1.6
log
@Update to xserver 1.11.2
@
text
@a40 1

d46 2
a47 1
#include <string.h> 		/* for memset */
d62 1
a62 1
#endif /* XF86DRI */
d66 2
a67 3
extern Bool XF86DRIQueryExtension (Display *dpy,
                                   int *event_basep,
                                   int *error_basep);
d76 9
a84 10
struct EphyrHostScreen
{
  Window          win;
  Window          win_pre_existing; 	/* Set via -parent option like xnest */
  Window          peer_win;          /* Used for GL; should be at most one */
  XImage         *ximg;
  int             win_width, win_height;
  int             server_depth;
  unsigned char  *fb_data;   	/* only used when host bpp != server bpp */
  XShmSegmentInfo shminfo;
d86 2
a87 2
  void           *info;   /* Pointer to the screen this is associated with */
  int             mynum;  /* Screen number */
d90 11
a100 12
struct EphyrHostXVars
{
  char           *server_dpy_name;
  Display        *dpy;
  int             screen;
  Visual         *visual;
  Window          winroot;
  GC              gc;
  int             depth;
  Bool            use_host_cursor;
  Bool            use_fullscreen;
  Bool            have_shm;
d102 2
a103 2
  int             n_screens;
  struct EphyrHostScreen *screens;
d105 1
a105 1
  long            damage_debug_msec;
d107 1
a107 1
  unsigned long   cmap[256];
d114 1
a114 1
static int            HostXWantDamageDebug = 0;
d116 1
a116 1
extern EphyrKeySyms   ephyrKeySyms;
d118 1
a118 1
extern int            monitorResolution;
d120 3
a122 3
char           *ephyrResName = NULL;
int             ephyrResNameFromCmd = 0;
char	       *ephyrTitle = NULL;
d125 1
a125 1
hostx_set_fullscreen_hint(void);
d130 1
a130 1
static int (*old_error_handler) (Display *d, XErrorEvent *e);
d135 1
a135 1
host_screen_from_screen_info (EphyrScreenInfo *screen)
d137 1
a137 1
  int i;
d139 3
a141 5
  for (i = 0 ; i < HostX.n_screens ; i++)
    {
      if ( HostX.screens[i].info == screen)
        {
          return &HostX.screens[i];
d144 1
a144 1
  return NULL;
d148 1
a148 2
error_handler(Display     *display,
              XErrorEvent *error)
d150 2
a151 2
  trapped_error_code = error->error_code;
  return 0;
d157 2
a158 2
  trapped_error_code = 0;
  old_error_handler = XSetErrorHandler(error_handler);
d164 2
a165 2
  XSetErrorHandler(old_error_handler);
  return trapped_error_code;
d169 1
a169 1
hostx_want_screen_size (EphyrScreenInfo screen, int *width, int *height )
d171 1
a171 1
  struct EphyrHostScreen *host_screen = host_screen_from_screen_info (screen);
d173 6
a178 7
  if (host_screen &&
       (host_screen->win_pre_existing != None ||
         HostX.use_fullscreen == True))
    {
      *width  = host_screen->win_width;
      *height = host_screen->win_height;
      return 1;
d181 1
a181 1
 return 0;
d185 8
a192 10
hostx_add_screen (EphyrScreenInfo screen,
                  unsigned long win_id,
                  int screen_num)
{
  int index = HostX.n_screens;

  HostX.n_screens += 1;
  HostX.screens = realloc (HostX.screens,
                           HostX.n_screens * sizeof(struct EphyrHostScreen));
  memset (&HostX.screens[index], 0, sizeof (struct EphyrHostScreen));
d194 2
a195 2
  HostX.screens[index].info       = screen;
  HostX.screens[index].win_pre_existing = win_id;
a197 1

d199 1
a199 1
hostx_set_display_name (char *name)
d201 1
a201 1
  HostX.server_dpy_name = strdup (name);
d207 7
a213 5
  struct EphyrHostScreen *host_screen = host_screen_from_screen_info (screen);
  if (host_screen) {
    host_screen->mynum = number;
    hostx_set_win_title (host_screen->info, "") ;
  }}
d216 1
a216 1
hostx_set_win_title (EphyrScreenInfo screen, char *extra_text)
d218 1
a218 1
    struct EphyrHostScreen *host_screen = host_screen_from_screen_info (screen);
d221 1
a221 1
    return;
d224 3
a226 2
      XStoreName(HostX.dpy, host_screen->win, ephyrTitle);
    } else {
d228 1
a228 1
      char buf[BUF_LEN+1];
d230 4
a233 5
      memset (buf, 0, BUF_LEN+1) ;
      snprintf (buf, BUF_LEN, "Xephyr on %s.%d %s", 
		HostX.server_dpy_name, 
		host_screen->mynum,
		(extra_text != NULL) ? extra_text : "");
d235 1
a235 1
      XStoreName (HostX.dpy, host_screen->win, buf);
d240 1
a240 1
hostx_want_host_cursor (void)
d242 1
a242 1
  return HostX.use_host_cursor;
d246 1
a246 1
hostx_use_host_cursor (void)
d248 1
a248 1
  HostX.use_host_cursor = True;
d252 1
a252 1
hostx_want_preexisting_window (EphyrScreenInfo screen)
d254 1
a254 1
  struct EphyrHostScreen *host_screen = host_screen_from_screen_info (screen);
d256 2
a257 3
  if (host_screen && host_screen->win_pre_existing)
    {
      return 1;
d259 2
a260 3
  else
    {
    return 0;
d265 1
a265 1
hostx_use_fullscreen (void)
d267 1
a267 1
  HostX.use_fullscreen = True;
d271 1
a271 1
hostx_want_fullscreen (void)
d273 1
a273 1
  return HostX.use_fullscreen;
d277 1
a277 1
hostx_set_fullscreen_hint (void)
d279 2
a280 2
  Atom atom_WINDOW_STATE, atom_WINDOW_STATE_FULLSCREEN;
  int index;
d282 9
a290 11
  atom_WINDOW_STATE 
    = XInternAtom(HostX.dpy, "_NET_WM_STATE", False);
  atom_WINDOW_STATE_FULLSCREEN 
    = XInternAtom(HostX.dpy, "_NET_WM_STATE_FULLSCREEN",False);

  for (index = 0 ; index < HostX.n_screens ; index++)
    {
      XChangeProperty (HostX.dpy, HostX.screens[index].win,
                       atom_WINDOW_STATE, XA_ATOM, 32,
                       PropModeReplace,
                       (unsigned char *)&atom_WINDOW_STATE_FULLSCREEN, 1);
a293 1

d295 1
a295 1
hostx_toggle_damage_debug (void)
d297 1
a297 1
  HostXWantDamageDebug ^= 1;
d301 1
a301 1
hostx_handle_signal (int signum)
d303 2
a304 3
  hostx_toggle_damage_debug();
  EPHYR_DBG ("Signal caught. Damage Debug:%i\n",
              HostXWantDamageDebug);
d308 1
a308 1
hostx_use_resname (char *name, int fromcmd)
d310 2
a311 2
  ephyrResName = name;
  ephyrResNameFromCmd = fromcmd;
d315 12
a326 1
hostx_set_title (char *title)
d328 4
a331 1
  ephyrTitle = title;
d335 1
a335 1
hostx_init (void)
d337 7
a343 7
  XSetWindowAttributes  attr;
  Cursor                empty_cursor;
  Pixmap                cursor_pxm;
  XColor                col;
  int                   index;
  char                  *tmpstr;
  XClassHint            *class_hint;
d345 4
a348 7
  attr.event_mask =
    ButtonPressMask
    |ButtonReleaseMask
    |PointerMotionMask
    |KeyPressMask
    |KeyReleaseMask
    |ExposureMask;
d350 1
a350 1
  EPHYR_DBG("mark");
d352 3
a354 4
  if ((HostX.dpy = XOpenDisplay(getenv("DISPLAY"))) == NULL)
    {
      fprintf(stderr, "\nXephyr cannot open host display. Is DISPLAY set?\n");
      exit(1);
d357 9
a365 5
  HostX.screen  = DefaultScreen(HostX.dpy);
  HostX.winroot = RootWindow(HostX.dpy, HostX.screen);
  HostX.gc      = XCreateGC(HostX.dpy, HostX.winroot, 0, NULL);
  HostX.depth   = DefaultDepth(HostX.dpy, HostX.screen);
  HostX.visual  = DefaultVisual(HostX.dpy, HostX.screen);
d367 2
a368 1
  class_hint = XAllocClassHint();
d370 4
a373 3
  for (index = 0 ; index < HostX.n_screens ; index++)
    {
      struct EphyrHostScreen *host_screen = &HostX.screens[index];
d375 1
a375 5
      host_screen->server_depth = HostX.depth;
      if (host_screen->win_pre_existing != None)
        {
          Status            result;
          XWindowAttributes prewin_attr;
d377 1
a377 1
          /* Get screen size from existing window */
d379 3
a381 1
          hostx_errors_trap();
d383 4
a386 37
          result = XGetWindowAttributes (HostX.dpy,
                                         host_screen->win_pre_existing,
                                         &prewin_attr);


          if (hostx_errors_untrap() || !result)
          {
              fprintf (stderr, "\nXephyr -parent window' does not exist!\n");
              exit (1);
          }

          host_screen->win_width  = prewin_attr.width;
          host_screen->win_height = prewin_attr.height;

          host_screen->win = XCreateWindow (HostX.dpy,
                                            host_screen->win_pre_existing,
                                            0,0,
                                            host_screen->win_width,
                                            host_screen->win_height,
                                            0,
                                            CopyFromParent,
                                            CopyFromParent,
                                            CopyFromParent,
                                            CWEventMask,
                                            &attr);
        }
      else
        {
          host_screen->win = XCreateWindow (HostX.dpy,
                                            HostX.winroot,
                                            0,0,100,100, /* will resize */
                                            0,
                                            CopyFromParent,
                                            CopyFromParent,
                                            CopyFromParent,
                                            CWEventMask,
                                            &attr);
d388 2
a389 2
          hostx_set_win_title (host_screen->info,
                               "(ctrl+shift grabs mouse and keyboard)");
d391 26
a416 4
          if (HostX.use_fullscreen)
            {
              host_screen->win_width  = DisplayWidth(HostX.dpy, HostX.screen);
              host_screen->win_height = DisplayHeight(HostX.dpy, HostX.screen);
d418 1
a418 1
              hostx_set_fullscreen_hint();
d421 8
a428 8
          if (class_hint) 
            {
              tmpstr = getenv("RESOURCE_NAME");
              if (tmpstr && (!ephyrResNameFromCmd))
                ephyrResName = tmpstr;
              class_hint->res_name = ephyrResName;
              class_hint->res_class = "Xephyr";
              XSetClassHint(hostx_get_display(), host_screen->win, class_hint);
d435 2
a436 2
  if (class_hint)
      XFree(class_hint);
d438 14
a451 19
  XParseColor (HostX.dpy, DefaultColormap (HostX.dpy,HostX.screen),
               "red", &col);
  XAllocColor (HostX.dpy, DefaultColormap (HostX.dpy, HostX.screen),
               &col);
  XSetForeground (HostX.dpy, HostX.gc, col.pixel);

  if (!hostx_want_host_cursor ())
    {
      /* Ditch the cursor, we provide our 'own' */
      cursor_pxm = XCreatePixmap (HostX.dpy, HostX.winroot, 1, 1, 1);
      memset (&col, 0, sizeof (col));
      empty_cursor = XCreatePixmapCursor (HostX.dpy,
                                          cursor_pxm, cursor_pxm, 
                                          &col, &col, 1, 1);
      for ( index = 0 ; index < HostX.n_screens ; index++ )
        {
          XDefineCursor (HostX.dpy,
                         HostX.screens[index].win,
                         empty_cursor);
d453 1
a453 1
      XFreePixmap (HostX.dpy, cursor_pxm);
d456 2
a457 3
  for (index = 0 ; index < HostX.n_screens ; index++)
    {
      HostX.screens[index].ximg   = NULL;
d459 1
a459 1
  /* Try to get share memory ximages for a little bit more speed */
d461 3
a463 4
  if (!XShmQueryExtension(HostX.dpy) || getenv("XEPHYR_NO_SHM"))
    {
      fprintf(stderr, "\nXephyr unable to use SHM XImages\n");
      HostX.have_shm = False;
d465 3
a467 4
  else
    {
      /* Really really check we have shm - better way ?*/
      XShmSegmentInfo shminfo;
d471 3
a473 3
        shminfo.shmid=shmget(IPC_PRIVATE, 1, IPC_CREAT|0777);
        shminfo.shmaddr=shmat(shminfo.shmid,0,0);
        shminfo.readOnly=True;
d480 1
a480 2
        if (hostx_errors_untrap())
          {
d483 1
a483 1
          }
d487 1
a487 1
}
d489 1
a489 1
  XFlush(HostX.dpy);
d491 1
a491 1
  /* Setup the pause time between paints when debugging updates */
d493 1
a493 1
  HostX.damage_debug_msec = 20000; /* 1/50 th of a second */
d495 3
a497 4
  if (getenv ("XEPHYR_PAUSE"))
    {
      HostX.damage_debug_msec = strtol (getenv ("XEPHYR_PAUSE"), NULL, 0);
      EPHYR_DBG ("pause is %li\n", HostX.damage_debug_msec);
d500 1
a500 1
  return 1;
d504 1
a504 1
hostx_get_depth (void)
d506 1
a506 1
  return HostX.depth;
d510 1
a510 1
hostx_get_server_depth (EphyrScreenInfo screen)
d512 1
a512 1
  struct EphyrHostScreen *host_screen = host_screen_from_screen_info (screen);
d514 1
a514 1
  return host_screen ? host_screen->server_depth : 0;
d518 1
a518 1
hostx_set_server_depth (EphyrScreenInfo screen, int depth)
d520 1
a520 1
  struct EphyrHostScreen *host_screen = host_screen_from_screen_info (screen);
d522 2
a523 2
  if (host_screen)
    host_screen->server_depth = depth;
d527 1
a527 1
hostx_get_bpp (EphyrScreenInfo screen)
d529 1
a529 1
  struct EphyrHostScreen *host_screen = host_screen_from_screen_info (screen);
d531 2
a532 2
  if (!host_screen)
    return 0;
d534 4
a537 4
  if (host_depth_matches_server (host_screen))
    return HostX.visual->bits_per_rgb;
  else
    return host_screen->server_depth; /*XXX correct ?*/
d541 23
a563 28
hostx_get_visual_masks (EphyrScreenInfo screen,
			CARD32 *rmsk,
			CARD32 *gmsk,
			CARD32 *bmsk)
{
  struct EphyrHostScreen *host_screen = host_screen_from_screen_info (screen);

  if (!host_screen)
    return;

  if (host_depth_matches_server(host_screen))
    {
      *rmsk = HostX.visual->red_mask;
      *gmsk = HostX.visual->green_mask;
      *bmsk = HostX.visual->blue_mask;
    }
  else if (host_screen->server_depth == 16)
    {
      /* Assume 16bpp 565 */
      *rmsk = 0xf800;
      *gmsk = 0x07e0;
      *bmsk = 0x001f;
    }
  else
    {
      *rmsk = 0x0;
      *gmsk = 0x0;
      *bmsk = 0x0;
d567 1
a567 1
static int 
d571 1
d573 2
a574 1
    while ((mask = (mask >> 1))) shift++;
d577 2
a578 1
    if (shift < 0) shift = 0;
d584 1
a584 3
		     unsigned char r,
		     unsigned char g,
		     unsigned char b)
d590 1
d592 4
a595 4
	first_time = 0;
	rshift = hostx_calculate_color_shift(HostX.visual->red_mask);
	gshift = hostx_calculate_color_shift(HostX.visual->green_mask);
	bshift = hostx_calculate_color_shift(HostX.visual->blue_mask);
d598 2
a599 2
		      ((g << gshift) & HostX.visual->green_mask) |
		      ((b << bshift) & HostX.visual->blue_mask);
d614 110
a723 122
void*
hostx_screen_init (EphyrScreenInfo screen,
                   int width, int height,
                   int buffer_height)
{
  int         bitmap_pad;
  Bool        shm_success = False;
  XSizeHints *size_hints;

  struct EphyrHostScreen *host_screen = host_screen_from_screen_info (screen);
  if (!host_screen)
    {
      fprintf (stderr, "%s: Error in accessing hostx data\n", __func__ );
      exit(1);
    }

  EPHYR_DBG ("host_screen=%p wxh=%dx%d, buffer_height=%d",
             host_screen, width, height, buffer_height);

  if (host_screen->ximg != NULL)
    {
      /* Free up the image data if previously used
       * i.ie called by server reset
       */

      if (HostX.have_shm)
	{
	  XShmDetach(HostX.dpy, &host_screen->shminfo);
	  XDestroyImage (host_screen->ximg);
	  shmdt(host_screen->shminfo.shmaddr);
	  shmctl(host_screen->shminfo.shmid, IPC_RMID, 0);
	}
      else
	{
	  free(host_screen->ximg->data);
	  host_screen->ximg->data = NULL;

	  XDestroyImage(host_screen->ximg);
	}
    }

  if (HostX.have_shm)
    {
      host_screen->ximg = XShmCreateImage (HostX.dpy, HostX.visual, HostX.depth,
                                           ZPixmap, NULL, &host_screen->shminfo,
                                           width, buffer_height );

      host_screen->shminfo.shmid =
                      shmget(IPC_PRIVATE,
                             host_screen->ximg->bytes_per_line * buffer_height,
                             IPC_CREAT|0777);
      host_screen->ximg->data = shmat(host_screen->shminfo.shmid, 0, 0);
      host_screen->shminfo.shmaddr = host_screen->ximg->data;

      if (host_screen->ximg->data == (char *)-1)
	{
	  EPHYR_DBG("Can't attach SHM Segment, falling back to plain XImages");
	  HostX.have_shm = False;
	  XDestroyImage(host_screen->ximg);
	  shmctl(host_screen->shminfo.shmid, IPC_RMID, 0);
	}
      else
	{
	  EPHYR_DBG("SHM segment attached %p", host_screen->shminfo.shmaddr);
	  host_screen->shminfo.readOnly = False;
	  XShmAttach(HostX.dpy, &host_screen->shminfo);
	  shm_success = True;
	}
    }

  if (!shm_success)
    {
      bitmap_pad = ( HostX.depth > 16 )? 32 : (( HostX.depth > 8 )? 16 : 8 );

      EPHYR_DBG("Creating image %dx%d for screen host_screen=%p\n",
                width, buffer_height, host_screen );
      host_screen->ximg = XCreateImage (HostX.dpy,
                                        HostX.visual,
                                        HostX.depth,
                                        ZPixmap, 0, 0,
                                        width,
                                        buffer_height,
                                        bitmap_pad,
                                        0);

      host_screen->ximg->data =
              malloc (host_screen->ximg->bytes_per_line * buffer_height);
    }

  XResizeWindow (HostX.dpy, host_screen->win, width, height);

  /* Ask the WM to keep our size static */
  size_hints = XAllocSizeHints();
  size_hints->max_width = size_hints->min_width = width;
  size_hints->max_height = size_hints->min_height = height;
  size_hints->flags = PMinSize|PMaxSize;
  XSetWMNormalHints(HostX.dpy, host_screen->win, size_hints);
  XFree(size_hints);

  XMapWindow(HostX.dpy, host_screen->win);

  XSync(HostX.dpy, False);

  host_screen->win_width  = width;
  host_screen->win_height = height;

  if (host_depth_matches_server(host_screen))
    {
      EPHYR_DBG("Host matches server");
      return host_screen->ximg->data;
    }
  else
    {
      EPHYR_DBG("server bpp %i", host_screen->server_depth>>3);
      host_screen->fb_data = malloc(width*buffer_height*(host_screen->server_depth>>3));
      return host_screen->fb_data;
    }
}

static void hostx_paint_debug_rect (struct EphyrHostScreen *host_screen,
                                    int x,     int y,
                                    int width, int height);
d726 66
a791 80
hostx_paint_rect (EphyrScreenInfo screen,
                  int sx,    int sy,
                  int dx,    int dy,
                  int width, int height)
{
  struct EphyrHostScreen *host_screen = host_screen_from_screen_info (screen);

  EPHYR_DBG ("painting in screen %d\n", host_screen->mynum) ;

  /*
   *  Copy the image data updated by the shadow layer
   *  on to the window
   */

  if (HostXWantDamageDebug)
    {
      hostx_paint_debug_rect(host_screen, dx, dy, width, height);
    }

  /* 
   * If the depth of the ephyr server is less than that of the host,
   * the kdrive fb does not point to the ximage data but to a buffer
   * ( fb_data ), we shift the various bits from this onto the XImage
   * so they match the host.
   *
   * Note, This code is pretty new ( and simple ) so may break on 
   *       endian issues, 32 bpp host etc. 
   *       Not sure if 8bpp case is right either. 
   *       ... and it will be slower than the matching depth case.
   */

  if (!host_depth_matches_server(host_screen))
    {
      int            x,y,idx, bytes_per_pixel = (host_screen->server_depth>>3);
      unsigned char  r,g,b;
      unsigned long  host_pixel;

      EPHYR_DBG("Unmatched host depth host_screen=%p\n", host_screen);
      for (y=sy; y<sy+height; y++)
	for (x=sx; x<sx+width; x++)
	  {
	    idx = (host_screen->win_width*y*bytes_per_pixel)+(x*bytes_per_pixel);

	    switch (host_screen->server_depth)
	      {
	      case 16:
		{
		  unsigned short pixel = *(unsigned short*)(host_screen->fb_data+idx);

		  r = ((pixel & 0xf800) >> 8);
		  g = ((pixel & 0x07e0) >> 3);
		  b = ((pixel & 0x001f) << 3);

		  host_pixel = (r << 16) | (g << 8) | (b);
		  
		  XPutPixel(host_screen->ximg, x, y, host_pixel);
		  break;
		}
	      case 8:
		{
		  unsigned char pixel = *(unsigned char*)(host_screen->fb_data+idx);
		  XPutPixel(host_screen->ximg, x, y, HostX.cmap[pixel]);
		  break;
		}
	      default:
		break;
	      }
	  }
    }

  if (HostX.have_shm)
    {
      XShmPutImage (HostX.dpy, host_screen->win,
                    HostX.gc, host_screen->ximg,
                    sx, sy, dx, dy, width, height, False);
    }
  else
    {
      XPutImage (HostX.dpy, host_screen->win, HostX.gc, host_screen->ximg, 
                 sx, sy, dx, dy, width, height);
d794 11
a804 1
  XSync (HostX.dpy, False);
d808 2
a809 3
hostx_paint_debug_rect (struct EphyrHostScreen *host_screen,
                        int x,     int y,
                        int width, int height)
d811 1
a811 1
  struct timespec tspec;
d813 2
a814 2
  tspec.tv_sec  = HostX.damage_debug_msec / (1000000);
  tspec.tv_nsec = (HostX.damage_debug_msec % 1000000) * 1000;
d816 2
a817 2
  EPHYR_DBG("msec: %li tv_sec %li, tv_msec %li", 
	    HostX.damage_debug_msec, tspec.tv_sec, tspec.tv_nsec);
d819 1
a819 1
  /* fprintf(stderr, "Xephyr updating: %i+%i %ix%i\n", x, y, width, height); */
d821 2
a822 2
  XFillRectangle (HostX.dpy, host_screen->win, HostX.gc, x, y, width,height);
  XSync (HostX.dpy, False);
d824 2
a825 2
  /* nanosleep seems to work better than usleep for me... */
  nanosleep(&tspec, NULL);
d831 24
a854 25
  XID             *keymap;
  int              host_width, min_keycode, max_keycode, width;
  int              i,j;

  XDisplayKeycodes (HostX.dpy, &min_keycode, &max_keycode);

  EPHYR_DBG ("min: %d, max: %d", min_keycode, max_keycode);

  keymap = XGetKeyboardMapping (HostX.dpy,
			        min_keycode,
			        max_keycode - min_keycode + 1,
			        &host_width);

  /* Try and copy the hosts keymap into our keymap to avoid loads
   * of messing around.
   *
   * kdrive cannot can have more than 4 keysyms per keycode
   * so we only copy at most the first 4 ( xorg has 6 per keycode, XVNC 2 )
   */
  width = (host_width > 4) ? 4 : host_width;

  ephyrKeySyms.map = (CARD32 *)calloc(sizeof(CARD32),
                                      (max_keycode - min_keycode + 1) *
                                      width);
  if (!ephyrKeySyms.map)
d857 10
a866 5
  for (i=0; i<(max_keycode - min_keycode+1); i++)
    for (j=0; j<width; j++)
      ephyrKeySyms.map[(i*width)+j] = (CARD32) keymap[(i*host_width) + j];

  EPHYR_DBG("keymap width, host:%d kdrive:%d", host_width, width);
d868 1
a868 5
  ephyrKeySyms.minKeyCode  = min_keycode;
  ephyrKeySyms.maxKeyCode  = max_keycode;
  ephyrKeySyms.mapWidth    = width;

  XFree(keymap);
d872 1
a872 1
host_screen_from_window (Window w)
d874 2
a875 2
  int index = 0;
  struct EphyrHostScreen *result  = NULL;
d877 4
a880 6
  for (index = 0 ; index < HostX.n_screens ; index++)
    {
      if (HostX.screens[index].win == w || HostX.screens[index].peer_win == w)
        {
          result = &HostX.screens[index];
          goto out;
d884 2
a885 2
out:
  return result;
d889 1
a889 1
hostx_get_event(EphyrHostXEvent *ev)
d891 41
a931 122
  XEvent      xev;
  static int  grabbed_screen = -1;

  if (XPending(HostX.dpy))
    {
      XNextEvent(HostX.dpy, &xev);

      switch (xev.type) 
	{
	case Expose:
	  /* Not so great event compression, but works ok */
	  while (XCheckTypedWindowEvent(HostX.dpy, xev.xexpose.window,
					Expose, &xev));
	  {
	    struct EphyrHostScreen *host_screen =
                host_screen_from_window (xev.xexpose.window);
            if (host_screen)
              {
                hostx_paint_rect (host_screen->info, 0, 0, 0, 0,
                                  host_screen->win_width,
                                  host_screen->win_height);
              }
            else
              {
                EPHYR_LOG_ERROR ("failed to get host screen\n");
                ev->type = EPHYR_EV_EXPOSE;
                ev->data.expose.window = xev.xexpose.window;
                return 1;
              }
	  }
	  return 0;

	case MotionNotify:
	  {
	    struct EphyrHostScreen *host_screen =
                host_screen_from_window (xev.xmotion.window);

	    ev->type = EPHYR_EV_MOUSE_MOTION;
	    ev->data.mouse_motion.x = xev.xmotion.x;
	    ev->data.mouse_motion.y = xev.xmotion.y;
	    ev->data.mouse_motion.window = xev.xmotion.window;
	    ev->data.mouse_motion.screen = (host_screen ? host_screen->mynum : -1);
	  }
	  return 1;

	case ButtonPress:
	  ev->type = EPHYR_EV_MOUSE_PRESS;
	  ev->key_state = xev.xkey.state;
	  /* 
	   * This is a bit hacky. will break for button 5 ( defined as 0x10 )
           * Check KD_BUTTON defines in kdrive.h 
	   */
	  ev->data.mouse_down.button_num = 1<<(xev.xbutton.button-1);
	  return 1;

	case ButtonRelease:
	  ev->type = EPHYR_EV_MOUSE_RELEASE;
	  ev->key_state = xev.xkey.state;
	  ev->data.mouse_up.button_num = 1<<(xev.xbutton.button-1);
	  return 1;

	case KeyPress:
	  {
	    ev->type = EPHYR_EV_KEY_PRESS;
	    ev->key_state = xev.xkey.state;
	    ev->data.key_down.scancode = xev.xkey.keycode;  
	    return 1;
	  }
	case KeyRelease:

	  if ((XKeycodeToKeysym(HostX.dpy,xev.xkey.keycode,0) == XK_Shift_L
	       || XKeycodeToKeysym(HostX.dpy,xev.xkey.keycode,0) == XK_Shift_R)
	      && (xev.xkey.state & ControlMask))
	    {
	      struct EphyrHostScreen *host_screen =
                  host_screen_from_window (xev.xexpose.window);

	      if (grabbed_screen != -1)
		{
		  XUngrabKeyboard (HostX.dpy, CurrentTime);
		  XUngrabPointer (HostX.dpy, CurrentTime);
		  grabbed_screen = -1;
		  hostx_set_win_title (host_screen->info,
                                       "(ctrl+shift grabs mouse and keyboard)");
		}
	      else
		{
		  /* Attempt grab */
		  if (XGrabKeyboard (HostX.dpy, host_screen->win, True, 
				     GrabModeAsync, 
				     GrabModeAsync, 
				     CurrentTime) == 0)
		    {
		      if (XGrabPointer (HostX.dpy, host_screen->win, True, 
					NoEventMask, 
					GrabModeAsync, 
					GrabModeAsync, 
					host_screen->win, None, CurrentTime) == 0)
			{
			  grabbed_screen = host_screen->mynum;
			  hostx_set_win_title
                                  (host_screen->info,
                                   "(ctrl+shift releases mouse and keyboard)");
			}
		      else 	/* Failed pointer grabm  ungrab keyboard */
			XUngrabKeyboard (HostX.dpy, CurrentTime);
		    }
		}
	    }

	  /* Still send the release event even if above has happened
           * server will get confused with just an up event. 
           * Maybe it would be better to just block shift+ctrls getting to
           * kdrive all togeather. 
 	   */
	  ev->type = EPHYR_EV_KEY_RELEASE;
	  ev->key_state = xev.xkey.state;
	  ev->data.key_up.scancode = xev.xkey.keycode;
	  return 1;

	default:
	  break;
d933 75
a1007 1
	}
d1009 1
a1009 1
  return 0;
d1012 1
a1012 1
void*
d1015 1
a1015 1
    return HostX.dpy ;
d1019 1
a1019 1
hostx_get_window (int a_screen_number)
d1022 1
a1022 1
        EPHYR_LOG_ERROR ("bad screen number:%d\n", a_screen_number) ;
d1025 1
a1025 1
    return HostX.screens[a_screen_number].win ;
d1029 1
a1029 1
hostx_get_window_attributes (int a_window, EphyrHostWindowAttributes *a_attrs)
d1031 1
a1031 1
    XWindowAttributes attrs ;
d1033 1
a1033 1
    memset (&attrs, 0, sizeof (attrs)) ;
d1035 2
a1036 4
    if (!XGetWindowAttributes (hostx_get_display (),
                               a_window,
                               &attrs)) {
        return FALSE ;
d1038 4
a1041 4
    a_attrs->x = attrs.x ;
    a_attrs->y = attrs.y ;
    a_attrs->width = attrs.width ;
    a_attrs->height = attrs.height ;
d1043 2
a1044 2
        a_attrs->visualid = attrs.visual->visualid ;
    return TRUE ;
d1048 3
a1050 4
hostx_get_extension_info (const char *a_ext_name,
                          int *a_major_opcode,
                          int *a_first_event,
                          int *a_first_error)
d1053 2
a1054 2
      return 0 ;
   if (!XQueryExtension (HostX.dpy,
d1056 4
a1059 7
                         a_major_opcode,
                         a_first_event,
                         a_first_error))
     {
       return 0 ;
     }
   return 1 ;
d1063 12
a1074 14
hostx_get_visuals_info (EphyrHostVisualInfo **a_visuals,
                        int *a_num_entries)
{
    Display *dpy=hostx_get_display () ;
    Bool is_ok=False ;
    XVisualInfo templ, *visuals=NULL;
    EphyrHostVisualInfo *host_visuals=NULL ;
    int nb_items=0, i=0;

    EPHYR_RETURN_VAL_IF_FAIL (a_visuals && a_num_entries && dpy,
                              False) ;
    EPHYR_LOG ("enter\n") ;
    memset (&templ, 0, sizeof (templ)) ;
    visuals = XGetVisualInfo (dpy, VisualNoMask, &templ, &nb_items) ;
d1076 2
a1077 2
        EPHYR_LOG_ERROR ("host does not advertise any visual\n") ;
        goto out ;
d1079 12
a1090 12
    EPHYR_LOG ("host advertises %d visuals\n", nb_items) ;
    host_visuals = calloc (nb_items, sizeof (EphyrHostVisualInfo)) ;
    for (i=0; i<nb_items; i++) {
        host_visuals[i].visualid = visuals[i].visualid ;
        host_visuals[i].screen = visuals[i].screen ;
        host_visuals[i].depth = visuals[i].depth ;
        host_visuals[i].class = visuals[i].class ;
        host_visuals[i].red_mask = visuals[i].red_mask ;
        host_visuals[i].green_mask = visuals[i].green_mask ;
        host_visuals[i].blue_mask = visuals[i].blue_mask ;
        host_visuals[i].colormap_size = visuals[i].colormap_size ;
        host_visuals[i].bits_per_rgb = visuals[i].bits_per_rgb ;
d1092 1
a1092 1
    *a_visuals = host_visuals ;
d1094 1
a1094 1
    host_visuals=NULL;
d1097 1
a1097 1
out:
d1099 1
a1099 1
        XFree (visuals) ;
d1104 2
a1105 2
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d1110 10
a1119 11
hostx_create_window (int a_screen_number,
                     EphyrBox *a_geometry,
                     int a_visual_id,
                     int *a_host_peer /*out parameter*/)
{
    Bool is_ok=FALSE ;
    Display *dpy=hostx_get_display () ;
    XVisualInfo *visual_info=NULL, visual_info_templ;
    int visual_mask=VisualIDMask ;
    Window win=None ;
    int nb_visuals=0, winmask=0;
d1122 1
a1122 1
    EPHYR_RETURN_VAL_IF_FAIL (dpy && a_geometry, FALSE) ;
d1124 1
a1124 1
    EPHYR_LOG ("enter\n") ;
d1126 5
a1130 6
     /*get visual*/
    memset (&visual_info, 0, sizeof (visual_info)) ;
    visual_info_templ.visualid = a_visual_id ;
    visual_info = XGetVisualInfo (dpy, visual_mask,
                                  &visual_info_templ,
                                  &nb_visuals) ;
d1132 9
a1140 10
        EPHYR_LOG_ERROR ("argh, could not find a remote visual with id:%d\n",
                         a_visual_id) ;
        goto out ;
    }
    memset (&attrs, 0, sizeof (attrs)) ;
    attrs.colormap = XCreateColormap (dpy,
                                      RootWindow (dpy,
                                                  visual_info->screen),
                                      visual_info->visual,
                                      AllocNone) ;
d1142 9
a1150 12
                       |ButtonReleaseMask
                       |PointerMotionMask
                       |KeyPressMask
                       |KeyReleaseMask
                       |ExposureMask;
    winmask = CWColormap|CWEventMask;

    win = XCreateWindow (dpy, hostx_get_window (a_screen_number),
                         a_geometry->x, a_geometry->y,
                         a_geometry->width, a_geometry->height, 0,
                         visual_info->depth, CopyFromParent,
                         visual_info->visual, winmask, &attrs) ;
d1152 2
a1153 2
        EPHYR_LOG_ERROR ("failed to create peer window\n") ;
        goto out ;
d1156 4
a1159 3
	HostX.screens[a_screen_number].peer_win = win;
    } else {
        EPHYR_LOG_ERROR ("multiple peer windows created for same screen\n") ;
d1161 7
a1167 7
    XFlush (dpy) ;
    XMapWindow (dpy, win) ;
    *a_host_peer = win ;
    is_ok = TRUE ;
out:
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d1171 1
a1171 1
hostx_destroy_window (int a_win)
d1173 1
a1173 1
    Display *dpy=hostx_get_display () ;
d1175 4
a1178 4
    EPHYR_RETURN_VAL_IF_FAIL (dpy, FALSE) ;
    XDestroyWindow (dpy, a_win) ;
    XFlush (dpy) ;
    return TRUE ;
d1182 1
a1182 1
hostx_set_window_geometry (int a_win, EphyrBox *a_geo)
d1184 1
a1184 1
    Display *dpy=hostx_get_display ();
d1186 1
a1186 1
    EPHYR_RETURN_VAL_IF_FAIL (dpy && a_geo, FALSE) ;
d1188 2
a1189 3
    EPHYR_LOG ("enter. x,y,w,h:(%d,%d,%d,%d)\n",
               a_geo->x, a_geo->y,
               a_geo->width, a_geo->height) ;
d1191 3
a1193 3
    XMoveWindow (dpy, a_win, a_geo->x, a_geo->y) ;
    XResizeWindow (dpy, a_win, a_geo->width, a_geo->height) ;
    EPHYR_LOG ("leave\n") ;
d1198 25
a1222 27
hostx_set_window_bounding_rectangles (int a_window,
                                      EphyrRect *a_rects,
                                      int a_num_rects)
{
    Bool is_ok=FALSE;
    Display *dpy=hostx_get_display () ;
    int i=0 ;
    XRectangle *rects=NULL ;

    EPHYR_RETURN_VAL_IF_FAIL (dpy && a_rects, FALSE) ;

    EPHYR_LOG ("enter. num rects:%d\n", a_num_rects) ;

    rects = calloc (a_num_rects, sizeof (XRectangle)) ;
    for (i=0; i<a_num_rects; i++) {
        rects[i].x = a_rects[i].x1 ;
        rects[i].y = a_rects[i].y1 ;
        rects[i].width = abs (a_rects[i].x2 - a_rects[i].x1);
        rects[i].height = abs (a_rects[i].y2 - a_rects[i].y1) ;
        EPHYR_LOG ("borders clipped to rect[x:%d,y:%d,w:%d,h:%d]\n",
                   rects[i].x, rects[i].y,
                   rects[i].width, rects[i].height) ;
    }
    /*this aways returns 1*/
    XShapeCombineRectangles (dpy, a_window, ShapeBounding, 0, 0,
                             rects, a_num_rects, ShapeSet, YXBanded) ;
    is_ok = TRUE ;
d1226 1
a1226 1
    EPHYR_LOG ("leave\n") ;
d1231 25
a1255 27
hostx_set_window_clipping_rectangles (int a_window,
                                      EphyrRect *a_rects,
                                      int a_num_rects)
{
    Bool is_ok=FALSE;
    Display *dpy=hostx_get_display () ;
    int i=0 ;
    XRectangle *rects=NULL ;

    EPHYR_RETURN_VAL_IF_FAIL (dpy && a_rects, FALSE) ;

    EPHYR_LOG ("enter. num rects:%d\n", a_num_rects) ;

    rects = calloc (a_num_rects, sizeof (XRectangle)) ;
    for (i=0; i<a_num_rects; i++) {
        rects[i].x = a_rects[i].x1 ;
        rects[i].y = a_rects[i].y1 ;
        rects[i].width = abs (a_rects[i].x2 - a_rects[i].x1);
        rects[i].height = abs (a_rects[i].y2 - a_rects[i].y1) ;
        EPHYR_LOG ("clipped to rect[x:%d,y:%d,w:%d,h:%d]\n",
                   rects[i].x, rects[i].y,
                   rects[i].width, rects[i].height) ;
    }
    /*this aways returns 1*/
    XShapeCombineRectangles (dpy, a_window, ShapeClip, 0, 0,
                             rects, a_num_rects, ShapeSet, YXBanded) ;
    is_ok = TRUE ;
d1259 1
a1259 1
    EPHYR_LOG ("leave\n") ;
d1264 1
a1264 1
hostx_has_xshape (void)
d1266 5
a1270 6
    int event_base=0, error_base=0 ;
    Display *dpy=hostx_get_display () ;
    if (!XShapeQueryExtension (dpy,
                               &event_base,
                               &error_base)) {
        return FALSE ;
d1277 4
a1280 4
    int is_valid ;
    int local_id ;
    int remote_id ;
} ResourcePair ;
d1283 1
a1283 2
static ResourcePair resource_peers[RESOURCE_PEERS_SIZE] ;

d1286 2
a1287 2
hostx_allocate_resource_id_peer (int a_local_resource_id,
                                 int *a_remote_resource_id)
d1289 3
a1291 3
    int i=0 ;
    ResourcePair *peer=NULL ;
    Display *dpy=hostx_get_display ();
d1298 1
a1298 1
    for (i=0; i<RESOURCE_PEERS_SIZE; i++) {
d1301 2
a1302 2
            peer = &resource_peers[i] ;
            break ;
d1309 1
a1309 1
        for (i=0; i<RESOURCE_PEERS_SIZE; i++) {
d1311 2
a1312 2
                peer = &resource_peers[i] ;
                break ;
d1316 3
a1318 3
            peer->remote_id = XAllocID (dpy);
            peer->local_id = a_local_resource_id ;
            peer->is_valid = TRUE ;
d1322 2
a1323 2
        *a_remote_resource_id = peer->remote_id ;
        return TRUE ;
d1325 1
a1325 1
    return FALSE ;
d1329 1
a1329 2
hostx_get_resource_id_peer (int a_local_resource_id,
                            int *a_remote_resource_id)
d1331 4
a1334 3
    int i=0 ;
    ResourcePair *peer=NULL ;
    for (i=0; i<RESOURCE_PEERS_SIZE; i++) {
d1337 2
a1338 2
            peer = &resource_peers[i] ;
            break ;
d1342 2
a1343 2
        *a_remote_resource_id = peer->remote_id ;
        return TRUE ;
d1345 1
a1345 1
    return FALSE ;
d1349 1
a1349 1
hostx_has_dri (void)
d1351 2
a1352 2
    int event_base=0, error_base=0 ;
    Display *dpy=hostx_get_display () ;
d1355 1
a1355 1
        return FALSE ;
d1357 2
a1358 4
    if (!XF86DRIQueryExtension (dpy,
                                &event_base,
                                &error_base)) {
        return FALSE ;
d1360 1
a1360 1
    return TRUE ;
d1364 1
a1364 1
hostx_has_glx (void)
d1366 2
a1367 2
    Display *dpy=hostx_get_display () ;
    int event_base=0, error_base=0 ;
d1369 2
a1370 2
    if (!glXQueryExtension (dpy, &event_base, &error_base)) {
        return FALSE ;
d1372 1
a1372 1
    return TRUE ;
d1375 1
a1375 1
#endif /* XF86DRI */
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d5 1
a5 1
 * Copyright © 2004 Nokia 
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d535 1
a535 1
  return (host_screen ? host_screen->server_depth : 0);
d672 2
a673 5
	  if (host_screen->ximg->data) 
	    {
	      free(host_screen->ximg->data);
	      host_screen->ximg->data = NULL;
	    } 
d1160 2
a1161 4
    if (host_visuals) {
        free (host_visuals) ;
        host_visuals = NULL;
    }
d1290 2
a1291 4
    if (rects) {
        free (rects) ;
        rects = NULL ;
    }
d1325 2
a1326 4
    if (rects) {
        free (rects) ;
        rects = NULL ;
    }
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d81 1
d125 1
d226 1
a226 3
  struct EphyrHostScreen *host_screen = host_screen_from_screen_info (screen);
#define BUF_LEN 256
  char buf[BUF_LEN+1];
d228 1
a228 1
  if (!host_screen)
d231 11
a241 5
  memset (buf, 0, BUF_LEN+1) ;
  snprintf (buf, BUF_LEN, "Xephyr on %s.%d %s", 
            HostX.server_dpy_name, 
            host_screen->mynum,
            (extra_text != NULL) ? extra_text : "");
d243 2
a244 1
  XStoreName (HostX.dpy, host_screen->win, buf);
d328 6
d598 1
a598 1
    while (mask=(mask>>1)) shift++;
a919 4
#if 0
  unsigned int num_children = 0;
  Window root = None, parent = None, *children = NULL;
#endif
d923 1
a923 1
      if (HostX.screens[index].win == w)
a928 7
#if 0
  XQueryTree (hostx_get_display (), w, &root, &parent,
              &children, &num_children);
  if (parent == root || parent == None)
      goto out;
  result = host_screen_from_window (parent);
#endif
a930 7
#if 0
  if (children)
      {
        XFree (children);
        children = NULL;
      }
#endif
d1223 5
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d60 1
a60 1
#ifdef XEPHYR_DRI
d62 1
a62 1
#endif /*XEPHYR_DRI*/
d65 1
a65 1
#ifdef XEPHYR_DRI
d580 12
d598 13
a610 2
  /* XXX Will likely break for 8 on 16, not sure if this is correct */
  HostX.cmap[idx] = (r << 16) | (g << 8) | (b);
d1353 1
a1353 1
#ifdef XEPHYR_DRI
d1456 1
a1456 2
#endif /*XEPHYR_DRI*/

@


1.1
log
@Initial revision
@
text
@d26 16
d59 11
d77 14
d97 1
a97 2
  Window          win, winroot;
  Window          win_pre_existing; 	/* Set via -parent option like xnest */
a99 3
  int             server_depth;
  XImage         *ximg;
  int             win_width, win_height;
d104 3
a108 1
  unsigned char  *fb_data;   	/* only used when host bpp != server bpp */
a109 2

  XShmSegmentInfo shminfo;
d113 2
a114 1
static EphyrHostXVars HostX = { "?", 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
d118 1
a118 1
extern KeySym         EphyrKeymap[];
a119 6
extern KeySym	      kdKeymap[];
extern int	      kdMinScanCode;
extern int	      kdMaxScanCode;
extern int	      kdMinKeyCode;
extern int	      kdMaxKeyCode;
extern int	      kdKeymapWidth;
d122 3
d133 6
a138 1
#define host_depth_matches_server() (HostX.depth == HostX.server_depth)
d140 9
d173 1
a173 1
hostx_want_screen_size(int *width, int *height)
d175 5
a179 2
 if (HostX.win_pre_existing != None
     || HostX.use_fullscreen == True)
d181 2
a182 2
      *width  = HostX.win_width;
      *height = HostX.win_height;
d190 18
a207 1
hostx_set_display_name(char *name)
d209 1
a209 1
  HostX.server_dpy_name = strdup(name);
d213 1
a213 1
hostx_set_win_title(char *extra_text)
d215 5
a219 1
  char buf[256];
d221 15
a235 3
  snprintf(buf, 256, "Xephyr on %s %s", 
	   HostX.server_dpy_name,
	   (extra_text != NULL) ? extra_text : "");
d237 1
a237 1
  XStoreName(HostX.dpy, HostX.win, buf);
d241 1
a241 1
hostx_want_host_cursor(void)
d247 1
a247 1
hostx_use_host_cursor(void)
d253 1
a253 1
hostx_want_preexisting_window(void)
d255 6
a260 2
  if (HostX.win_pre_existing) 
    return 1;
d262 1
d264 1
d268 1
a268 1
hostx_use_fullscreen(void)
d274 1
a274 1
hostx_want_fullscreen(void)
d280 1
a280 1
hostx_set_fullscreen_hint(void)
d283 1
d290 7
a296 4
  XChangeProperty(HostX.dpy, HostX.win,
		  atom_WINDOW_STATE, XA_ATOM, 32,
		  PropModeReplace,
		  (unsigned char *)&atom_WINDOW_STATE_FULLSCREEN, 1);
a298 5
void
hostx_use_preexisting_window(unsigned long win_id)
{
  HostX.win_pre_existing = win_id;
}
d301 1
a301 1
hostx_toggle_damage_debug(void)
d306 2
a307 2
void 
hostx_handle_signal(int signum)
d310 9
a318 1
  EPHYR_DBG("Signal caught. Damage Debug:%i\n", HostXWantDamageDebug);
d322 1
a322 1
hostx_init(void)
d328 3
d332 1
a332 1
  attr.event_mask = 
d343 4
a346 4
  {
    fprintf(stderr, "\nXephyr cannot open host display. Is DISPLAY set?\n");
    exit(1);
  }
d352 1
a352 10
  HostX.visual  = DefaultVisual(HostX.dpy, HostX.screen); 

  HostX.server_depth = HostX.depth;
 
  if (HostX.win_pre_existing != None)
    {
      Status            result;
      XWindowAttributes prewin_attr;

      /* Get screen size from existing window */
d354 1
a354 1
      hostx_errors_trap();
d356 1
a356 25
      result = XGetWindowAttributes(HostX.dpy, 
				    HostX.win_pre_existing, 
				    &prewin_attr);


      if (hostx_errors_untrap() || !result)
	{
	  fprintf(stderr, "\nXephyr -parent window' does not exist!\n");
	  exit(1);
	}

      HostX.win_width  = prewin_attr.width;
      HostX.win_height = prewin_attr.height;

      HostX.win = XCreateWindow(HostX.dpy,
				HostX.win_pre_existing,
				0,0,HostX.win_width,HostX.win_height,
				0,
				CopyFromParent,
				CopyFromParent,
				CopyFromParent,
				CWEventMask,
				&attr);
    }
  else
d358 1
a358 9
      HostX.win = XCreateWindow(HostX.dpy,
				HostX.winroot,
				0,0,100,100, /* will resize  */
				0,
			        CopyFromParent,
				CopyFromParent,
				CopyFromParent,
				CWEventMask,
				&attr);
d360 67
a426 1
      hostx_set_win_title("( ctrl+shift grabs mouse and keyboard )");
d428 1
a428 4
      if (HostX.use_fullscreen)
	{
	  HostX.win_width  = DisplayWidth(HostX.dpy, HostX.screen); 
	  HostX.win_height = DisplayHeight(HostX.dpy, HostX.screen); 
d430 1
a430 2
	  hostx_set_fullscreen_hint();
	}
d433 2
d436 5
a440 3
  XParseColor(HostX.dpy, DefaultColormap(HostX.dpy,HostX.screen), "red", &col);
  XAllocColor(HostX.dpy, DefaultColormap(HostX.dpy, HostX.screen), &col);
  XSetForeground(HostX.dpy, HostX.gc, col.pixel);
d442 1
a442 1
  if (!hostx_want_host_cursor())
d447 9
a455 4
      empty_cursor = XCreatePixmapCursor (HostX.dpy, 
					  cursor_pxm, cursor_pxm, 
					  &col, &col, 1, 1);
      XDefineCursor (HostX.dpy, HostX.win, empty_cursor);
d459 4
a462 2
  HostX.ximg   = NULL;

d465 1
a465 1
  if (!XShmQueryExtension(HostX.dpy) || getenv("XEPHYR_NO_SHM")) 
d469 3
a471 3
    } 
  else 		            
    {	
d473 3
a475 1
      XShmSegmentInfo shminfo; 
d477 3
a479 1
      HostX.have_shm = True;
d481 1
a481 3
      shminfo.shmid=shmget(IPC_PRIVATE, 1, IPC_CREAT|0777);
      shminfo.shmaddr=shmat(shminfo.shmid,0,0);
      shminfo.readOnly=True;
d483 2
a484 4
      hostx_errors_trap();
      
      XShmAttach(HostX.dpy, &shminfo);
      XSync(HostX.dpy, False);
d486 5
a490 5
      if (hostx_errors_untrap())
	{
	  fprintf(stderr, "\nXephyr unable to use SHM XImages\n");
	  HostX.have_shm = False;
	}
d492 3
a494 3
      shmdt(shminfo.shmaddr);
      shmctl(shminfo.shmid, IPC_RMID, 0);
    }
d502 1
a502 1
  if (getenv("XEPHYR_PAUSE"))
d504 2
a505 2
      HostX.damage_debug_msec = strtol(getenv("XEPHYR_PAUSE"), NULL, 0);
      EPHYR_DBG("pause is %li\n", HostX.damage_debug_msec);
d518 1
a518 1
hostx_get_server_depth (void)
d520 3
a522 1
  return HostX.server_depth;
d526 1
a526 1
hostx_set_server_depth(int depth)
d528 4
a531 1
  HostX.server_depth = depth;
d535 1
a535 1
hostx_get_bpp(void)
d537 7
a543 2
  if (host_depth_matches_server())
    return  HostX.visual->bits_per_rgb;
d545 1
a545 1
    return HostX.server_depth; 	/* XXX correct ? */
d549 4
a552 3
hostx_get_visual_masks (unsigned long *rmsk, 
			unsigned long *gmsk, 
			unsigned long *bmsk)
d554 6
a559 1
  if (host_depth_matches_server())
d565 1
a565 1
  else if (HostX.server_depth == 16)
d581 3
a583 3
hostx_set_cmap_entry(unsigned char idx, 
		     unsigned char r, 
		     unsigned char g, 
d603 3
a605 1
hostx_screen_init (int width, int height, int buffer_height)
d611 9
a619 1
  EPHYR_DBG("mark");
d621 1
a621 1
  if (HostX.ximg != NULL)
d629 4
a632 4
	  XShmDetach(HostX.dpy, &HostX.shminfo);
	  XDestroyImage (HostX.ximg);
	  shmdt(HostX.shminfo.shmaddr);
	  shmctl(HostX.shminfo.shmid, IPC_RMID, 0);
d636 1
a636 1
	  if (HostX.ximg->data) 
d638 2
a639 2
	      free(HostX.ximg->data);
	      HostX.ximg->data = NULL;
d642 1
a642 1
	  XDestroyImage(HostX.ximg);
d648 10
a657 9
      HostX.ximg = XShmCreateImage(HostX.dpy, HostX.visual, HostX.depth, 
				   ZPixmap, NULL, &HostX.shminfo,
				   width, buffer_height );
	  
      HostX.shminfo.shmid = shmget(IPC_PRIVATE,
				   HostX.ximg->bytes_per_line * buffer_height,
				   IPC_CREAT|0777);
      HostX.shminfo.shmaddr = HostX.ximg->data = shmat(HostX.shminfo.shmid,
						       0, 0);
d659 1
a659 1
      if (HostX.ximg->data == (char *)-1)
d663 2
a664 2
	  XDestroyImage(HostX.ximg);
	  shmctl(HostX.shminfo.shmid, IPC_RMID, 0);
d668 3
a670 3
	  EPHYR_DBG("SHM segment attached");
	  HostX.shminfo.readOnly = False;
	  XShmAttach(HostX.dpy, &HostX.shminfo);
a677 9
	  
      HostX.ximg = XCreateImage( HostX.dpy, 
				 HostX.visual, 
				 HostX.depth, 
				 ZPixmap, 0, 0,
				 width, 
				 buffer_height, 
				 bitmap_pad, 
				 0);
d679 13
a691 1
      HostX.ximg->data = malloc( HostX.ximg->bytes_per_line * buffer_height );
d694 1
a694 2

  XResizeWindow(HostX.dpy, HostX.win, width, height);
d701 1
a701 1
  XSetWMNormalHints(HostX.dpy, HostX.win, size_hints);
d704 1
a704 1
  XMapWindow(HostX.dpy, HostX.win);
d708 2
a709 2
  HostX.win_width  = width;
  HostX.win_height = height;
d711 1
a711 1
  if (host_depth_matches_server())
d714 1
a714 1
      return HostX.ximg->data;
d718 3
a720 3
      EPHYR_DBG("server bpp %i", HostX.server_depth>>3);
      HostX.fb_data = malloc(width*buffer_height*(HostX.server_depth>>3));
      return HostX.fb_data;
d724 4
d729 4
a732 3
hostx_paint_rect(int sx,    int sy,
		 int dx,    int dy, 
		 int width, int height)
d734 5
a738 1
  /* 
d745 1
a745 1
      hostx_paint_debug_rect(dx, dy, width, height);
d760 1
a760 1
  if (!host_depth_matches_server())
d762 1
a762 1
      int            x,y,idx, bytes_per_pixel = (HostX.server_depth>>3);
d766 1
d770 3
a772 3
	    idx = (HostX.win_width*y*bytes_per_pixel)+(x*bytes_per_pixel);
	    
	    switch (HostX.server_depth)
d776 1
a776 1
		  unsigned short pixel = *(unsigned short*)(HostX.fb_data+idx);
d784 1
a784 1
		  XPutPixel(HostX.ximg, x, y, host_pixel);
d789 2
a790 2
		  unsigned char pixel = *(unsigned char*)(HostX.fb_data+idx);
		  XPutPixel(HostX.ximg, x, y, HostX.cmap[pixel]);
d801 3
a803 2
      XShmPutImage(HostX.dpy, HostX.win, HostX.gc, HostX.ximg, 
		       sx, sy, dx, dy, width, height, False);
d807 2
a808 2
      XPutImage(HostX.dpy, HostX.win, HostX.gc, HostX.ximg, 
		sx, sy, dx, dy, width, height);
d811 1
a811 1
  XSync(HostX.dpy, False);
d814 4
a817 3
void
hostx_paint_debug_rect(int x,     int y, 
		       int width, int height)
d829 2
a830 2
  XFillRectangle(HostX.dpy, HostX.win, HostX.gc, x, y, width,height); 
  XSync(HostX.dpy, False);
d839 1
a839 1
  KeySym          *keymap;
d843 1
a843 1
  XDisplayKeycodes(HostX.dpy, &min_keycode, &max_keycode);
d845 1
a845 1
  EPHYR_DBG("min: %d, max: %d", min_keycode, max_keycode);
d847 4
a850 4
  keymap = XGetKeyboardMapping(HostX.dpy, 
			       min_keycode,
			       max_keycode - min_keycode + 1,
			       &host_width);
d860 6
d868 1
a868 1
      kdKeymap[ (i*width)+j ] = keymap[ (i*host_width) + j ];
a870 2
  
  /* all kdrive vars - see kkeymap.c */
d872 3
a874 5
  kdMinScanCode = min_keycode;
  kdMaxScanCode = max_keycode;
  kdMinKeyCode  = min_keycode;
  kdMaxKeyCode  = max_keycode;
  kdKeymapWidth = width;
d879 37
d920 1
a920 1
  static Bool grabbed;
d930 1
a930 1
	  while (XCheckTypedWindowEvent(HostX.dpy, xev.xexpose.window, 
d932 17
a948 1
	  hostx_paint_rect(0, 0, 0, 0, HostX.win_width, HostX.win_height);
d952 10
a961 3
	  ev->type = EPHYR_EV_MOUSE_MOTION;
	  ev->data.mouse_motion.x = xev.xmotion.x; 
	  ev->data.mouse_motion.y = xev.xmotion.y;
d993 4
a996 1
	      if (grabbed) 
d1000 5
a1004 4
		  grabbed = False;
		  hostx_set_win_title("( ctrl+shift grabs mouse and keyboard )");
		} 
	      else 
d1007 1
a1007 1
		  if (XGrabKeyboard (HostX.dpy, HostX.win, True, 
d1012 1
a1012 1
		      if (XGrabPointer (HostX.dpy, HostX.win, True, 
d1016 1
a1016 1
					HostX.win, None, CurrentTime) == 0)
d1018 4
a1021 2
			  grabbed = True;
			  hostx_set_win_title("( ctrl+shift releases mouse and keyboard )");
d1046 388
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d80 1
a80 1
extern EphyrKeySyms   ephyrKeySyms;
d82 6
d406 3
a408 3
hostx_get_visual_masks (CARD32 *rmsk, 
			CARD32 *gmsk, 
			CARD32 *bmsk)
d665 1
a665 1
  XID             *keymap;
a685 6
  ephyrKeySyms.map = (CARD32 *)calloc(sizeof(CARD32),
                                      (max_keycode - min_keycode + 1) *
                                      width);
  if (!ephyrKeySyms.map)
        return;

d688 1
a688 1
      ephyrKeySyms.map[(i*width)+j] = (CARD32) keymap[(i*host_width) + j];
d692 7
a698 3
  ephyrKeySyms.minKeyCode  = min_keycode;
  ephyrKeySyms.maxKeyCode  = max_keycode;
  ephyrKeySyms.mapWidth    = width;
@

