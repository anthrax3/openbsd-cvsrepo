head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.14
	OPENBSD_5_0:1.1.0.12
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.8
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.10
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.05.02.19.27.48;	author matthieu;	state dead;
branches;
next	1.3;

1.3
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.18;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@/*
 * Xephyr - A kdrive X server thats runs in a host X window.
 *          Authored by Matthew Allum <mallum@@openedhand.com>
 * 
 * Copyright Â© 2007 OpenedHand Ltd 
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of OpenedHand Ltd not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission. OpenedHand Ltd makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * OpenedHand Ltd DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OpenedHand Ltd BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors:
 *    Dodji Seketeli <dodji@@openedhand.com>
 */

/*
 * \file
 * This file defines a proxy extension that forwards requests.
 * When a request to extension FOO is sent to Xephyr, that request is forwared
 * to the host X, without even trying to know what the request means.
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif

#include "misc.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "ephyrproxyext.h"
#define _HAVE_XALLOC_DECLS
#include "ephyrlog.h"
#include "ephyrhostproxy.h"
#include "hostx.h"

static Bool ephyrProxyGetHostExtensionInfo(const char *a_ext_name,
                                           int *a_major_opcode,
                                           int *a_first_event,
                                           int *a_first_error);

static int ephyrProxyProcDispatch(ClientPtr client);

static Bool
ephyrProxyGetHostExtensionInfo(const char *a_ext_name,
                               int *a_major_opcode,
                               int *a_first_event, int *a_first_error)
{
    return hostx_get_extension_info(a_ext_name, a_major_opcode,
                                    a_first_event, a_first_error);
}

static int
ephyrProxyProcDispatch(ClientPtr a_client)
{
    int res = BadImplementation;
    struct XReply reply;

    if (!ephyrHostProxyDoForward(a_client->requestBuffer, &reply, FALSE)) {
        EPHYR_LOG_ERROR("forwarding failed\n");
        goto out;
    }
    reply.sequence_number = a_client->sequence;
    res = Success;

    WriteToClient(a_client, 32, &reply);

 out:
    return res;
}

static void
ephyrProxyProcReset(ExtensionEntry * a_entry)
{
}

Bool
ephyrProxyExtensionInit(const char *a_extension_name)
{
    Bool is_ok = FALSE;
    int major_opcode = 0, first_event = 0, first_error = 0;
    ExtensionEntry *ext = NULL;

    if (!ephyrProxyGetHostExtensionInfo(a_extension_name,
                                        &major_opcode,
                                        &first_event, &first_error)) {
        EPHYR_LOG("failed to query extension %s from host\n", a_extension_name);
        goto out;
    }
    ext = AddExtension((char *) a_extension_name, 0, 0,
                       ephyrProxyProcDispatch,
                       ephyrProxyProcDispatch,
                       ephyrProxyProcReset, StandardMinorOpcode);
    if (!ext) {
        EPHYR_LOG_ERROR("failed to add the extension\n");
        goto out;
    }
    is_ok = TRUE;

 out:
    EPHYR_LOG("leave\n");
    return is_ok;
}
@


1.3
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@@


1.2
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d78 1
a78 1
    WriteToClient(a_client, 32, (char *) &reply);
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d49 4
a52 4
static Bool ephyrProxyGetHostExtensionInfo (const char *a_ext_name,
                                            int *a_major_opcode,
                                            int *a_first_event,
                                            int *a_first_error) ;
d54 1
a54 1
static int ephyrProxyProcDispatch (ClientPtr client) ;
d57 3
a59 4
ephyrProxyGetHostExtensionInfo (const char *a_ext_name,
                                int *a_major_opcode,
                                int *a_first_event,
                                int *a_first_error)
d61 2
a62 2
    return hostx_get_extension_info (a_ext_name, a_major_opcode,
                                     a_first_event, a_first_error) ;
d66 1
a66 1
ephyrProxyProcDispatch (ClientPtr a_client)
d68 2
a69 2
    int res=BadImplementation ;
    struct XReply reply ;
d71 3
a73 3
    if (!ephyrHostProxyDoForward (a_client->requestBuffer, &reply, FALSE)) {
        EPHYR_LOG_ERROR ("forwarding failed\n") ;
        goto out ;
d76 1
a76 1
    res = Success ;
d78 1
a78 1
    WriteToClient(a_client, 32, (char *)&reply);
d80 2
a81 2
out:
    return res ;
d85 1
a85 1
ephyrProxyProcReset (ExtensionEntry *a_entry)
d90 1
a90 1
ephyrProxyExtensionInit (const char *a_extension_name)
d92 8
a99 9
    Bool is_ok = FALSE ;
    int major_opcode=0, first_event=0, first_error=0;
    ExtensionEntry *ext=NULL ;

    if (!ephyrProxyGetHostExtensionInfo (a_extension_name,
                                         &major_opcode,
                                         &first_event,
                                         &first_error)) {
        EPHYR_LOG ("failed to query extension %s from host\n", a_extension_name) ;
d102 4
a105 5
    ext = AddExtension ((char*)a_extension_name, 0, 0,
                        ephyrProxyProcDispatch,
                        ephyrProxyProcDispatch,
                        ephyrProxyProcReset,
                        StandardMinorOpcode) ;
d107 2
a108 2
        EPHYR_LOG_ERROR ("failed to add the extension\n") ;
        goto out ;
d110 1
a110 1
    is_ok = TRUE ;
d112 3
a114 3
out:
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
a115 1

@

