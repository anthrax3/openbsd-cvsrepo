head	1.6;
access;
symbols
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.05.02.19.27.48;	author matthieu;	state dead;
branches;
next	1.5;

1.5
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.05;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.18;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@/*
 * Xephyr - A kdrive X server thats runs in a host X window.
 *          Authored by Matthew Allum <mallum@@openedhand.com>
 * 
 * Copyright Â© 2007 OpenedHand Ltd 
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of OpenedHand Ltd not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission. OpenedHand Ltd makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * OpenedHand Ltd DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OpenedHand Ltd BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors:
 *    Dodji Seketeli <dodji@@openedhand.com>
 */
#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif
/*
 * including some server headers (like kdrive-config.h)
 * might define the macro _XSERVER64
 * on 64 bits machines. That macro must _NOT_ be defined for Xlib
 * client code, otherwise bad things happen.
 * So let's undef that macro if necessary.
 */
#ifdef _XSERVER64
#undef _XSERVER64
#endif
#include <X11/Xutil.h>
#include <X11/Xlibint.h>
#include <X11/extensions/Xvlib.h>
#include <X11/extensions/Xvproto.h>
#include <X11/extensions/Xext.h>
#include <X11/extensions/extutil.h>
#define _HAVE_XALLOC_DECLS

#include "hostx.h"
#include "ephyrhostvideo.h"
#include "ephyrlog.h"

#ifndef TRUE
#define TRUE 1
#endif /*TRUE*/
#ifndef FALSE
#define FALSE 0
#endif /*FALSE*/
static XExtensionInfo _xv_info_data;
static XExtensionInfo *xv_info = &_xv_info_data;
static char *xv_extension_name = XvName;
static char *xv_error_string(Display * dpy, int code, XExtCodes * codes,
                             char *buf, int n);
static int xv_close_display(Display * dpy, XExtCodes * codes);
static Bool xv_wire_to_event(Display * dpy, XEvent * host, xEvent *wire);

static XExtensionHooks xv_extension_hooks = {
    NULL,                       /* create_gc */
    NULL,                       /* copy_gc */
    NULL,                       /* flush_gc */
    NULL,                       /* free_gc */
    NULL,                       /* create_font */
    NULL,                       /* free_font */
    xv_close_display,           /* close_display */
    xv_wire_to_event,           /* wire_to_event */
    NULL,                       /* event_to_wire */
    NULL,                       /* error */
    xv_error_string             /* error_string */
};

static char *xv_error_list[] = {
    "BadPort",                  /* XvBadPort     */
    "BadEncoding",              /* XvBadEncoding */
    "BadControl"                /* XvBadControl  */
};

#define XvCheckExtension(dpy, i, val) \
  XextCheckExtension(dpy, i, xv_extension_name, val)
#define XvGetReq(name, req) \
        WORD64ALIGN\
        if ((dpy->bufptr + SIZEOF(xv##name##Req)) > dpy->bufmax)\
                _XFlush(dpy);\
        req = (xv##name##Req *)(dpy->last_req = dpy->bufptr);\
        req->reqType = info->codes->major_opcode;\
        req->xvReqType = xv_##name; \
        req->length = (SIZEOF(xv##name##Req))>>2;\
        dpy->bufptr += SIZEOF(xv##name##Req);\
        dpy->request++

static
XEXT_GENERATE_CLOSE_DISPLAY(xv_close_display, xv_info)

static
XEXT_GENERATE_FIND_DISPLAY(xv_find_display, xv_info,
                           xv_extension_name,
                           &xv_extension_hooks, XvNumEvents, NULL)

static
XEXT_GENERATE_ERROR_STRING(xv_error_string, xv_extension_name,
                           XvNumErrors, xv_error_list)

struct _EphyrHostXVAdaptorArray {
    XvAdaptorInfo *adaptors;
    unsigned int nb_adaptors;
};

/*heavily copied from libx11*/
#define BUFSIZE 2048
static void
ephyrHostXVLogXErrorEvent(Display * a_display,
                          XErrorEvent * a_err_event, FILE * a_fp)
{
    char buffer[BUFSIZ];
    char mesg[BUFSIZ];
    char number[32];
    const char *mtype = "XlibMessage";
    register _XExtension *ext = (_XExtension *) NULL;
    _XExtension *bext = (_XExtension *) NULL;
    Display *dpy = a_display;

    XGetErrorText(dpy, a_err_event->error_code, buffer, BUFSIZ);
    XGetErrorDatabaseText(dpy, mtype, "XError", "X Error", mesg, BUFSIZ);
    (void) fprintf(a_fp, "%s:  %s\n  ", mesg, buffer);
    XGetErrorDatabaseText(dpy, mtype, "MajorCode", "Request Major code %d",
                          mesg, BUFSIZ);
    (void) fprintf(a_fp, mesg, a_err_event->request_code);
    if (a_err_event->request_code < 128) {
        snprintf(number, sizeof(number), "%d", a_err_event->request_code);
        XGetErrorDatabaseText(dpy, "XRequest", number, "", buffer, BUFSIZ);
    }
    else {
        for (ext = dpy->ext_procs;
             ext && (ext->codes.major_opcode != a_err_event->request_code);
             ext = ext->next);
        if (ext)
            strcpy(buffer, ext->name);
        else
            buffer[0] = '\0';
    }
    (void) fprintf(a_fp, " (%s)\n", buffer);
    if (a_err_event->request_code >= 128) {
        XGetErrorDatabaseText(dpy, mtype, "MinorCode", "Request Minor code %d",
                              mesg, BUFSIZ);
        fputs("  ", a_fp);
        (void) fprintf(a_fp, mesg, a_err_event->minor_code);
        if (ext) {
            snprintf(mesg, sizeof(mesg), "%s.%d",
                     ext->name, a_err_event->minor_code);
            XGetErrorDatabaseText(dpy, "XRequest", mesg, "", buffer, BUFSIZ);
            (void) fprintf(a_fp, " (%s)", buffer);
        }
        fputs("\n", a_fp);
    }
    if (a_err_event->error_code >= 128) {
        /* kludge, try to find the extension that caused it */
        buffer[0] = '\0';
        for (ext = dpy->ext_procs; ext; ext = ext->next) {
            if (ext->error_string)
                (*ext->error_string) (dpy, a_err_event->error_code, &ext->codes,
                                      buffer, BUFSIZ);
            if (buffer[0]) {
                bext = ext;
                break;
            }
            if (ext->codes.first_error &&
                ext->codes.first_error < (int) a_err_event->error_code &&
                (!bext || ext->codes.first_error > bext->codes.first_error))
                bext = ext;
        }
        if (bext)
            snprintf(buffer, sizeof(buffer), "%s.%d", bext->name,
                     a_err_event->error_code - bext->codes.first_error);
        else
            strcpy(buffer, "Value");
        XGetErrorDatabaseText(dpy, mtype, buffer, "", mesg, BUFSIZ);
        if (mesg[0]) {
            fputs("  ", a_fp);
            (void) fprintf(a_fp, mesg, a_err_event->resourceid);
            fputs("\n", a_fp);
        }
        /* let extensions try to print the values */
        for (ext = dpy->ext_procs; ext; ext = ext->next) {
            if (ext->error_values)
                (*ext->error_values) (dpy, a_err_event, a_fp);
        }
    }
    else if ((a_err_event->error_code == BadWindow) ||
             (a_err_event->error_code == BadPixmap) ||
             (a_err_event->error_code == BadCursor) ||
             (a_err_event->error_code == BadFont) ||
             (a_err_event->error_code == BadDrawable) ||
             (a_err_event->error_code == BadColor) ||
             (a_err_event->error_code == BadGC) ||
             (a_err_event->error_code == BadIDChoice) ||
             (a_err_event->error_code == BadValue) ||
             (a_err_event->error_code == BadAtom)) {
        if (a_err_event->error_code == BadValue)
            XGetErrorDatabaseText(dpy, mtype, "Value", "Value 0x%x",
                                  mesg, BUFSIZ);
        else if (a_err_event->error_code == BadAtom)
            XGetErrorDatabaseText(dpy, mtype, "AtomID", "AtomID 0x%x",
                                  mesg, BUFSIZ);
        else
            XGetErrorDatabaseText(dpy, mtype, "ResourceID", "ResourceID 0x%x",
                                  mesg, BUFSIZ);
        fputs("  ", a_fp);
        (void) fprintf(a_fp, mesg, a_err_event->resourceid);
        fputs("\n", a_fp);
    }
    XGetErrorDatabaseText(dpy, mtype, "ErrorSerial", "Error Serial #%d",
                          mesg, BUFSIZ);
    fputs("  ", a_fp);
    (void) fprintf(a_fp, mesg, a_err_event->serial);
    XGetErrorDatabaseText(dpy, mtype, "CurrentSerial", "Current Serial #%d",
                          mesg, BUFSIZ);
    fputs("\n  ", a_fp);
    (void) fprintf(a_fp, mesg, dpy->request);
    fputs("\n", a_fp);
}

static int
ephyrHostXVErrorHandler(Display * a_display, XErrorEvent * a_error_event)
{
    EPHYR_LOG_ERROR("got an error from the host xserver:\n");
    ephyrHostXVLogXErrorEvent(a_display, a_error_event, stderr);
    return Success;
}

void
ephyrHostXVInit(void)
{
    static Bool s_initialized;

    if (s_initialized)
        return;
    XSetErrorHandler(ephyrHostXVErrorHandler);
    s_initialized = TRUE;
}

Bool
ephyrHostXVQueryAdaptors(EphyrHostXVAdaptorArray ** a_adaptors)
{
    EphyrHostXVAdaptorArray *result = NULL;
    int ret = 0;
    Bool is_ok = FALSE;

    EPHYR_RETURN_VAL_IF_FAIL(a_adaptors, FALSE);

    EPHYR_LOG("enter\n");

    result = calloc(1, sizeof(EphyrHostXVAdaptorArray));
    if (!result)
        goto out;

    ret = XvQueryAdaptors(hostx_get_display(),
                          DefaultRootWindow(hostx_get_display()),
                          &result->nb_adaptors, &result->adaptors);
    if (ret != Success) {
        EPHYR_LOG_ERROR("failed to query host adaptors: %d\n", ret);
        goto out;
    }
    *a_adaptors = result;
    is_ok = TRUE;

 out:
    EPHYR_LOG("leave\n");
    return is_ok;
}

void
ephyrHostXVAdaptorArrayDelete(EphyrHostXVAdaptorArray * a_adaptors)
{
    if (!a_adaptors)
        return;
    if (a_adaptors->adaptors) {
        XvFreeAdaptorInfo(a_adaptors->adaptors);
        a_adaptors->adaptors = NULL;
        a_adaptors->nb_adaptors = 0;
    }
    XFree(a_adaptors);
}

int
ephyrHostXVAdaptorArrayGetSize(const EphyrHostXVAdaptorArray * a_this)
{
    EPHYR_RETURN_VAL_IF_FAIL(a_this, -1);
    return a_this->nb_adaptors;
}

EphyrHostXVAdaptor *
ephyrHostXVAdaptorArrayAt(const EphyrHostXVAdaptorArray * a_this, int a_index)
{
    EPHYR_RETURN_VAL_IF_FAIL(a_this, NULL);

    if (a_index >= a_this->nb_adaptors)
        return NULL;
    return (EphyrHostXVAdaptor *) &a_this->adaptors[a_index];
}

char
ephyrHostXVAdaptorGetType(const EphyrHostXVAdaptor * a_this)
{
    EPHYR_RETURN_VAL_IF_FAIL(a_this, -1);
    return ((XvAdaptorInfo *) a_this)->type;
}

const char *
ephyrHostXVAdaptorGetName(const EphyrHostXVAdaptor * a_this)
{
    EPHYR_RETURN_VAL_IF_FAIL(a_this, NULL);

    return ((XvAdaptorInfo *) a_this)->name;
}

EphyrHostVideoFormat *
ephyrHostXVAdaptorGetVideoFormats(const EphyrHostXVAdaptor * a_this,
                                  int *a_nb_formats)
{
    EphyrHostVideoFormat *formats = NULL;
    int nb_formats = 0, i = 0;
    XVisualInfo *visual_info, visual_info_template;
    int nb_visual_info;

    EPHYR_RETURN_VAL_IF_FAIL(a_this, NULL);

    nb_formats = ((XvAdaptorInfo *) a_this)->num_formats;
    formats = calloc(nb_formats, sizeof(EphyrHostVideoFormat));
    for (i = 0; i < nb_formats; i++) {
        memset(&visual_info_template, 0, sizeof(visual_info_template));
        visual_info_template.visualid =
            ((XvAdaptorInfo *) a_this)->formats[i].visual_id;
        visual_info = XGetVisualInfo(hostx_get_display(),
                                     VisualIDMask,
                                     &visual_info_template, &nb_visual_info);
        formats[i].depth = ((XvAdaptorInfo *) a_this)->formats[i].depth;
        formats[i].visual_class = visual_info->class;
        XFree(visual_info);
    }
    if (a_nb_formats)
        *a_nb_formats = nb_formats;
    return formats;
}

int
ephyrHostXVAdaptorGetNbPorts(const EphyrHostXVAdaptor * a_this)
{
    EPHYR_RETURN_VAL_IF_FAIL(a_this, -1);

    return ((XvAdaptorInfo *) a_this)->num_ports;
}

int
ephyrHostXVAdaptorGetFirstPortID(const EphyrHostXVAdaptor * a_this)
{
    EPHYR_RETURN_VAL_IF_FAIL(a_this, -1);

    return ((XvAdaptorInfo *) a_this)->base_id;
}

Bool
ephyrHostXVAdaptorHasPutVideo(const EphyrHostXVAdaptor * a_this, Bool *a_result)
{
    EPHYR_RETURN_VAL_IF_FAIL(a_this && a_result, FALSE);

    if ((((XvAdaptorInfo *) a_this)->type & (XvVideoMask | XvInputMask)) ==
        (XvVideoMask | XvInputMask))
        *a_result = TRUE;
    else
        *a_result = FALSE;
    return TRUE;
}

Bool
ephyrHostXVAdaptorHasGetVideo(const EphyrHostXVAdaptor * a_this, Bool *a_result)
{
    if ((((XvAdaptorInfo *) a_this)->type & (XvVideoMask | XvOutputMask)) ==
        (XvVideoMask | XvOutputMask))
        *a_result = TRUE;
    else
        *a_result = FALSE;
    return TRUE;
}

Bool
ephyrHostXVAdaptorHasPutStill(const EphyrHostXVAdaptor * a_this, Bool *a_result)
{
    EPHYR_RETURN_VAL_IF_FAIL(a_this && a_result, FALSE);

    if ((((XvAdaptorInfo *) a_this)->type & (XvStillMask | XvInputMask)) ==
        (XvStillMask | XvInputMask))
        *a_result = TRUE;
    else
        *a_result = FALSE;
    return TRUE;
}

Bool
ephyrHostXVAdaptorHasGetStill(const EphyrHostXVAdaptor * a_this, Bool *a_result)
{
    EPHYR_RETURN_VAL_IF_FAIL(a_this && a_result, FALSE);

    if ((((XvAdaptorInfo *) a_this)->type & (XvStillMask | XvOutputMask)) ==
        (XvStillMask | XvOutputMask))
        *a_result = TRUE;
    else
        *a_result = FALSE;
    return TRUE;
}

Bool
ephyrHostXVAdaptorHasPutImage(const EphyrHostXVAdaptor * a_this, Bool *a_result)
{
    EPHYR_RETURN_VAL_IF_FAIL(a_this && a_result, FALSE);

    if ((((XvAdaptorInfo *) a_this)->type & (XvImageMask | XvInputMask)) ==
        (XvImageMask | XvInputMask))
        *a_result = TRUE;
    else
        *a_result = FALSE;
    return TRUE;
}

Bool
ephyrHostXVQueryEncodings(int a_port_id,
                          EphyrHostEncoding ** a_encodings,
                          unsigned int *a_num_encodings)
{
    EphyrHostEncoding *encodings = NULL;
    XvEncodingInfo *encoding_info = NULL;
    unsigned int num_encodings = 0, i;
    int ret = 0;

    EPHYR_RETURN_VAL_IF_FAIL(a_encodings && a_num_encodings, FALSE);

    ret = XvQueryEncodings(hostx_get_display(),
                           a_port_id, &num_encodings, &encoding_info);
    if (num_encodings && encoding_info) {
        encodings = calloc(num_encodings, sizeof(EphyrHostEncoding));
        for (i = 0; i < num_encodings; i++) {
            encodings[i].id = encoding_info[i].encoding_id;
            encodings[i].name = strdup(encoding_info[i].name);
            encodings[i].width = encoding_info[i].width;
            encodings[i].height = encoding_info[i].height;
            encodings[i].rate.numerator = encoding_info[i].rate.numerator;
            encodings[i].rate.denominator = encoding_info[i].rate.denominator;
        }
    }
    if (encoding_info) {
        XvFreeEncodingInfo(encoding_info);
        encoding_info = NULL;
    }
    *a_encodings = encodings;
    *a_num_encodings = num_encodings;

    if (ret != Success)
        return FALSE;
    return TRUE;
}

void
ephyrHostEncodingsDelete(EphyrHostEncoding * a_encodings, int a_num_encodings)
{
    int i = 0;

    if (!a_encodings)
        return;
    for (i = 0; i < a_num_encodings; i++) {
        free(a_encodings[i].name);
        a_encodings[i].name = NULL;
    }
    free(a_encodings);
}

void
ephyrHostAttributesDelete(EphyrHostAttribute * a_attributes)
{
    if (!a_attributes)
        return;
    XFree(a_attributes);
}

Bool
ephyrHostXVQueryPortAttributes(int a_port_id,
                               EphyrHostAttribute ** a_attributes,
                               int *a_num_attributes)
{
    EPHYR_RETURN_VAL_IF_FAIL(a_attributes && a_num_attributes, FALSE);

    *a_attributes =
        (EphyrHostAttribute *) XvQueryPortAttributes(hostx_get_display(),
                                                     a_port_id,
                                                     a_num_attributes);

    return TRUE;
}

Bool
ephyrHostXVQueryImageFormats(int a_port_id,
                             EphyrHostImageFormat ** a_formats,
                             int *a_num_format)
{
    XvImageFormatValues *result = NULL;

    EPHYR_RETURN_VAL_IF_FAIL(a_formats && a_num_format, FALSE);

    result = XvListImageFormats(hostx_get_display(), a_port_id, a_num_format);
    *a_formats = (EphyrHostImageFormat *) result;
    return TRUE;

}

Bool
ephyrHostXVSetPortAttribute(int a_port_id, int a_atom, int a_attr_value)
{
    int res = Success;

    EPHYR_LOG("atom,name,value: (%d,%s,%d)\n",
              a_atom, XGetAtomName(hostx_get_display(), a_atom), a_attr_value);

    res = XvSetPortAttribute(hostx_get_display(),
                             a_port_id, a_atom, a_attr_value);
    if (res != Success) {
        EPHYR_LOG_ERROR("XvSetPortAttribute() failed: %d\n", res);
        return FALSE;
    }
    XFlush(hostx_get_display());
    EPHYR_LOG("leave\n");

    return TRUE;
}

Bool
ephyrHostXVGetPortAttribute(int a_port_id, int a_atom, int *a_attr_value)
{
    int res = Success;
    Bool ret = FALSE;

    EPHYR_RETURN_VAL_IF_FAIL(a_attr_value, FALSE);

    EPHYR_LOG("enter, a_port_id: %d, a_atomid: %d, attr_name: %s\n",
              a_port_id, a_atom, XGetAtomName(hostx_get_display(), a_atom));

    res = XvGetPortAttribute(hostx_get_display(),
                             a_port_id, a_atom, a_attr_value);
    if (res != Success) {
        EPHYR_LOG_ERROR("XvGetPortAttribute() failed: %d \n", res);
        goto out;
    }
    EPHYR_LOG("atom,value: (%d, %d)\n", a_atom, *a_attr_value);

    ret = TRUE;

 out:
    EPHYR_LOG("leave\n");
    return ret;
}

Bool
ephyrHostXVQueryBestSize(int a_port_id,
                         Bool a_motion,
                         unsigned int a_frame_w,
                         unsigned int a_frame_h,
                         unsigned int a_drw_w,
                         unsigned int a_drw_h,
                         unsigned int *a_actual_w, unsigned int *a_actual_h)
{
    int res = 0;
    Bool is_ok = FALSE;

    EPHYR_RETURN_VAL_IF_FAIL(a_actual_w && a_actual_h, FALSE);

    EPHYR_LOG("enter: frame (%dx%d), drw (%dx%d)\n",
              a_frame_w, a_frame_h, a_drw_w, a_drw_h);

    res = XvQueryBestSize(hostx_get_display(),
                          a_port_id,
                          a_motion,
                          a_frame_w, a_frame_h,
                          a_drw_w, a_drw_h, a_actual_w, a_actual_h);
    if (res != Success) {
        EPHYR_LOG_ERROR("XvQueryBestSize() failed: %d\n", res);
        goto out;
    }
    XSync(hostx_get_display(), FALSE);

    EPHYR_LOG("actual (%dx%d)\n", *a_actual_w, *a_actual_h);
    is_ok = TRUE;

 out:
    EPHYR_LOG("leave\n");
    return is_ok;
}

static Bool
xv_wire_to_event(Display * dpy, XEvent * host, xEvent *wire)
{
    XExtDisplayInfo *info = xv_find_display(dpy);
    XvEvent *re = (XvEvent *) host;
    xvEvent *event = (xvEvent *) wire;

    XvCheckExtension(dpy, info, False);

    switch ((event->u.u.type & 0x7F) - info->codes->first_event) {
    case XvVideoNotify:
        re->xvvideo.type = event->u.u.type & 0x7f;
        re->xvvideo.serial = _XSetLastRequestRead(dpy, (xGenericReply *) event);
        re->xvvideo.send_event = ((event->u.u.type & 0x80) != 0);
        re->xvvideo.display = dpy;
        re->xvvideo.time = event->u.videoNotify.time;
        re->xvvideo.reason = event->u.videoNotify.reason;
        re->xvvideo.drawable = event->u.videoNotify.drawable;
        re->xvvideo.port_id = event->u.videoNotify.port;
        break;
    case XvPortNotify:
        re->xvport.type = event->u.u.type & 0x7f;
        re->xvport.serial = _XSetLastRequestRead(dpy, (xGenericReply *) event);
        re->xvport.send_event = ((event->u.u.type & 0x80) != 0);
        re->xvport.display = dpy;
        re->xvport.time = event->u.portNotify.time;
        re->xvport.port_id = event->u.portNotify.port;
        re->xvport.attribute = event->u.portNotify.attribute;
        re->xvport.value = event->u.portNotify.value;
        break;
    default:
        return False;
    }

    return True;
}

Bool
ephyrHostXVQueryImageAttributes(int a_port_id,
                                int a_image_id /*image fourcc code */ ,
                                unsigned short *a_width,
                                unsigned short *a_height,
                                int *a_image_size,
                                int *a_pitches, int *a_offsets)
{
    Display *dpy = hostx_get_display();
    Bool ret = FALSE;
    XExtDisplayInfo *info = xv_find_display(dpy);
    xvQueryImageAttributesReq *req = NULL;
    xvQueryImageAttributesReply rep;

    EPHYR_RETURN_VAL_IF_FAIL(a_width, FALSE);
    EPHYR_RETURN_VAL_IF_FAIL(a_height, FALSE);
    EPHYR_RETURN_VAL_IF_FAIL(a_image_size, FALSE);

    XvCheckExtension(dpy, info, FALSE);

    LockDisplay(dpy);

    XvGetReq(QueryImageAttributes, req);
    req->id = a_image_id;
    req->port = a_port_id;
    req->width = *a_width;
    req->height = *a_height;
    /*
     * read the reply
     */
    if (!_XReply(dpy, (xReply *) &rep, 0, xFalse)) {
        EPHYR_LOG_ERROR("QeryImageAttribute req failed\n");
        goto out;
    }
    if (a_pitches && a_offsets) {
        _XRead(dpy, (char *) a_pitches, rep.num_planes << 2);
        _XRead(dpy, (char *) a_offsets, rep.num_planes << 2);
    }
    else {
        _XEatData(dpy, rep.length << 2);
    }
    *a_width = rep.width;
    *a_height = rep.height;
    *a_image_size = rep.data_size;

    ret = TRUE;

 out:
    UnlockDisplay(dpy);
    SyncHandle();
    return ret;
}

Bool
ephyrHostGetAtom(const char *a_name, Bool a_create_if_not_exists, int *a_atom)
{
    int atom = None;

    EPHYR_RETURN_VAL_IF_FAIL(a_atom, FALSE);

    atom = XInternAtom(hostx_get_display(), a_name, a_create_if_not_exists);
    if (atom == None) {
        return FALSE;
    }
    *a_atom = atom;
    return TRUE;
}

char *
ephyrHostGetAtomName(int a_atom)
{
    return XGetAtomName(hostx_get_display(), a_atom);
}

void
ephyrHostFree(void *a_pointer)
{
    if (a_pointer)
        XFree(a_pointer);
}

Bool
ephyrHostXVPutImage(int a_screen_num,
                    int a_port_id,
                    int a_image_id,
                    int a_drw_x,
                    int a_drw_y,
                    int a_drw_w,
                    int a_drw_h,
                    int a_src_x,
                    int a_src_y,
                    int a_src_w,
                    int a_src_h,
                    int a_image_width,
                    int a_image_height,
                    unsigned char *a_buf,
                    EphyrHostBox * a_clip_rects, int a_clip_rect_nums)
{
    Bool is_ok = TRUE;
    XvImage *xv_image = NULL;
    GC gc = 0;
    XGCValues gc_values;
    Display *dpy = hostx_get_display();
    XRectangle *rects = NULL;
    int res = 0;

    EPHYR_RETURN_VAL_IF_FAIL(a_buf, FALSE);

    EPHYR_LOG("enter, num_clip_rects: %d\n", a_clip_rect_nums);

    memset(&gc_values, 0, sizeof(gc_values));
    gc = XCreateGC(dpy, hostx_get_window(a_screen_num), 0L, &gc_values);
    if (!gc) {
        EPHYR_LOG_ERROR("failed to create gc \n");
        goto out;
    }
    xv_image = (XvImage *) XvCreateImage(hostx_get_display(),
                                         a_port_id, a_image_id,
                                         NULL, a_image_width, a_image_height);
    if (!xv_image) {
        EPHYR_LOG_ERROR("failed to create image\n");
        goto out;
    }
    xv_image->data = (char *) a_buf;
    if (a_clip_rect_nums) {
        int i = 0;

        rects = calloc(a_clip_rect_nums, sizeof(XRectangle));
        for (i = 0; i < a_clip_rect_nums; i++) {
            rects[i].x = a_clip_rects[i].x1;
            rects[i].y = a_clip_rects[i].y1;
            rects[i].width = a_clip_rects[i].x2 - a_clip_rects[i].x1;
            rects[i].height = a_clip_rects[i].y2 - a_clip_rects[i].y1;
            EPHYR_LOG("(x,y,w,h): (%d,%d,%d,%d)\n",
                      rects[i].x, rects[i].y, rects[i].width, rects[i].height);
        }
        XSetClipRectangles(dpy, gc, 0, 0, rects, a_clip_rect_nums, YXBanded);
        /*this always returns 1 */
    }
    res = XvPutImage(dpy, a_port_id,
                     hostx_get_window(a_screen_num),
                     gc, xv_image,
                     a_src_x, a_src_y, a_src_w, a_src_h,
                     a_drw_x, a_drw_y, a_drw_w, a_drw_h);
    if (res != Success) {
        EPHYR_LOG_ERROR("XvPutImage() failed: %d\n", res);
        goto out;
    }
    is_ok = TRUE;

 out:
    if (xv_image) {
        XFree(xv_image);
        xv_image = NULL;
    }
    if (gc) {
        XFreeGC(dpy, gc);
        gc = NULL;
    }
    free(rects);
    rects = NULL;
    EPHYR_LOG("leave\n");
    return is_ok;
}

Bool
ephyrHostXVPutVideo(int a_screen_num, int a_port_id,
                    int a_vid_x, int a_vid_y, int a_vid_w, int a_vid_h,
                    int a_drw_x, int a_drw_y, int a_drw_w, int a_drw_h)
{
    Bool is_ok = FALSE;
    int res = FALSE;
    GC gc = 0;
    XGCValues gc_values;
    Display *dpy = hostx_get_display();

    EPHYR_RETURN_VAL_IF_FAIL(dpy, FALSE);

    gc = XCreateGC(dpy, hostx_get_window(a_screen_num), 0L, &gc_values);
    if (!gc) {
        EPHYR_LOG_ERROR("failed to create gc \n");
        goto out;
    }
    res = XvPutVideo(dpy, a_port_id, hostx_get_window(a_screen_num), gc,
                     a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                     a_drw_x, a_drw_y, a_drw_w, a_drw_h);

    if (res != Success) {
        EPHYR_LOG_ERROR("XvPutVideo() failed: %d\n", res);
        goto out;
    }

    is_ok = TRUE;

 out:
    if (gc) {
        XFreeGC(dpy, gc);
        gc = NULL;
    }
    return is_ok;
}

Bool
ephyrHostXVGetVideo(int a_screen_num, int a_port_id,
                    int a_vid_x, int a_vid_y, int a_vid_w, int a_vid_h,
                    int a_drw_x, int a_drw_y, int a_drw_w, int a_drw_h)
{
    Bool is_ok = FALSE;
    int res = FALSE;
    GC gc = 0;
    XGCValues gc_values;
    Display *dpy = hostx_get_display();

    EPHYR_RETURN_VAL_IF_FAIL(dpy, FALSE);

    gc = XCreateGC(dpy, hostx_get_window(a_screen_num), 0L, &gc_values);
    if (!gc) {
        EPHYR_LOG_ERROR("failed to create gc \n");
        goto out;
    }
    res = XvGetVideo(dpy, a_port_id, hostx_get_window(a_screen_num), gc,
                     a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                     a_drw_x, a_drw_y, a_drw_w, a_drw_h);

    if (res != Success) {
        EPHYR_LOG_ERROR("XvGetVideo() failed: %d\n", res);
        goto out;
    }

    is_ok = TRUE;

 out:
    if (gc) {
        XFreeGC(dpy, gc);
        gc = NULL;
    }
    return is_ok;
}

Bool
ephyrHostXVPutStill(int a_screen_num, int a_port_id,
                    int a_vid_x, int a_vid_y, int a_vid_w, int a_vid_h,
                    int a_drw_x, int a_drw_y, int a_drw_w, int a_drw_h)
{
    Bool is_ok = FALSE;
    int res = FALSE;
    GC gc = 0;
    XGCValues gc_values;
    Display *dpy = hostx_get_display();

    EPHYR_RETURN_VAL_IF_FAIL(dpy, FALSE);

    gc = XCreateGC(dpy, hostx_get_window(a_screen_num), 0L, &gc_values);
    if (!gc) {
        EPHYR_LOG_ERROR("failed to create gc \n");
        goto out;
    }
    res = XvPutStill(dpy, a_port_id, hostx_get_window(a_screen_num), gc,
                     a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                     a_drw_x, a_drw_y, a_drw_w, a_drw_h);

    if (res != Success) {
        EPHYR_LOG_ERROR("XvPutStill() failed: %d\n", res);
        goto out;
    }

    is_ok = TRUE;

 out:
    if (gc) {
        XFreeGC(dpy, gc);
        gc = NULL;
    }
    return is_ok;
}

Bool
ephyrHostXVGetStill(int a_screen_num, int a_port_id,
                    int a_vid_x, int a_vid_y, int a_vid_w, int a_vid_h,
                    int a_drw_x, int a_drw_y, int a_drw_w, int a_drw_h)
{
    Bool is_ok = FALSE;
    int res = FALSE;
    GC gc = 0;
    XGCValues gc_values;
    Display *dpy = hostx_get_display();

    EPHYR_RETURN_VAL_IF_FAIL(dpy, FALSE);

    gc = XCreateGC(dpy, hostx_get_window(a_screen_num), 0L, &gc_values);
    if (!gc) {
        EPHYR_LOG_ERROR("failed to create gc \n");
        goto out;
    }
    res = XvGetStill(dpy, a_port_id, hostx_get_window(a_screen_num), gc,
                     a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                     a_drw_x, a_drw_y, a_drw_w, a_drw_h);

    if (res != Success) {
        EPHYR_LOG_ERROR("XvGetStill() failed: %d\n", res);
        goto out;
    }

    is_ok = TRUE;

 out:
    if (gc) {
        XFreeGC(dpy, gc);
        gc = NULL;
    }
    return is_ok;
}

Bool
ephyrHostXVStopVideo(int a_screen_num, int a_port_id)
{
    int ret = 0;
    Bool is_ok = FALSE;
    Display *dpy = hostx_get_display();

    EPHYR_RETURN_VAL_IF_FAIL(dpy, FALSE);

    EPHYR_LOG("enter\n");

    ret = XvStopVideo(dpy, a_port_id, hostx_get_window(a_screen_num));
    if (ret != Success) {
        EPHYR_LOG_ERROR("XvStopVideo() failed: %d \n", ret);
        goto out;
    }
    is_ok = TRUE;

 out:
    EPHYR_LOG("leave\n");
    return is_ok;
}
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d307 1
a307 1
    return (EphyrHostXVAdaptor *) & a_this->adaptors[a_index];
d671 1
a671 1
    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse)) {
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a55 1

a58 1

d62 4
a65 4
static char *xv_error_string(Display *dpy, int code, XExtCodes *codes,
                             char * buf, int n);
static int xv_close_display(Display *dpy, XExtCodes *codes);
static Bool xv_wire_to_event(Display *dpy, XEvent *host, xEvent *wire);
d68 11
a78 11
    NULL,                               /* create_gc */
    NULL,                               /* copy_gc */
    NULL,                               /* flush_gc */
    NULL,                               /* free_gc */
    NULL,                               /* create_font */
    NULL,                               /* free_font */
    xv_close_display,                   /* close_display */
    xv_wire_to_event,                   /* wire_to_event */
    NULL,                               /* event_to_wire */
    NULL,                               /* error */
    xv_error_string                     /* error_string */
d81 4
a84 6

static char *xv_error_list[] =
{
   "BadPort",       /* XvBadPort     */
   "BadEncoding",   /* XvBadEncoding */
   "BadControl"     /* XvBadControl  */
a86 1

d100 2
a101 2
static XEXT_GENERATE_CLOSE_DISPLAY (xv_close_display, xv_info)

d103 8
a110 7
static XEXT_GENERATE_FIND_DISPLAY (xv_find_display, xv_info,
                                   xv_extension_name,
                                   &xv_extension_hooks,
                                   XvNumEvents, NULL)

static XEXT_GENERATE_ERROR_STRING (xv_error_string, xv_extension_name,
                                   XvNumErrors, xv_error_list)
d113 2
a114 2
    XvAdaptorInfo *adaptors ;
    unsigned int nb_adaptors ;
d120 2
a121 3
ephyrHostXVLogXErrorEvent (Display *a_display,
                           XErrorEvent *a_err_event,
                           FILE *a_fp)
d127 3
a129 3
    register _XExtension *ext = (_XExtension *)NULL;
    _XExtension *bext = (_XExtension *)NULL;
    Display *dpy = a_display ;
d135 1
a135 1
            mesg, BUFSIZ);
d138 1
a138 1
        sprintf(number, "%d", a_err_event->request_code);
d140 2
a141 1
    } else {
d143 2
a144 3
                ext && (ext->codes.major_opcode != a_err_event->request_code);
                ext = ext->next)
            ; 
d153 1
a153 1
                mesg, BUFSIZ);
d157 2
a158 1
            sprintf(mesg, "%s.%d", ext->name, a_err_event->minor_code);
d164 1
a164 1
    if (a_err_event->error_code >= 128) { 
d169 2
a170 2
                (*ext->error_string)(dpy, a_err_event->error_code, &ext->codes,
                        buffer, BUFSIZ);
d176 2
a177 2
                    ext->codes.first_error < (int)a_err_event->error_code &&
                    (!bext || ext->codes.first_error > bext->codes.first_error))
d181 2
a182 2
            sprintf(buffer, "%s.%d", bext->name,
                    a_err_event->error_code - bext->codes.first_error);
d194 1
a194 1
                (*ext->error_values)(dpy, a_err_event, a_fp);
d196 11
a206 10
    } else if ((a_err_event->error_code == BadWindow) ||
            (a_err_event->error_code == BadPixmap) ||
            (a_err_event->error_code == BadCursor) ||
            (a_err_event->error_code == BadFont) ||
            (a_err_event->error_code == BadDrawable) ||
            (a_err_event->error_code == BadColor) ||
            (a_err_event->error_code == BadGC) ||
            (a_err_event->error_code == BadIDChoice) ||
            (a_err_event->error_code == BadValue) ||
            (a_err_event->error_code == BadAtom)) {
d209 1
a209 1
                    mesg, BUFSIZ);
d212 1
a212 1
                    mesg, BUFSIZ);
d215 1
a215 1
                    mesg, BUFSIZ);
d221 1
a221 1
            mesg, BUFSIZ);
d225 1
a225 1
            mesg, BUFSIZ);
d232 1
a232 2
ephyrHostXVErrorHandler (Display *a_display,
                         XErrorEvent *a_error_event)
d234 3
a236 3
    EPHYR_LOG_ERROR ("got an error from the host xserver:\n") ;
    ephyrHostXVLogXErrorEvent (a_display, a_error_event, stderr) ;
    return Success ;
d240 1
a240 1
ephyrHostXVInit (void)
d242 1
a242 1
    static Bool s_initialized ;
d245 3
a247 3
        return ;
    XSetErrorHandler (ephyrHostXVErrorHandler) ;
    s_initialized = TRUE ;
d251 1
a251 1
ephyrHostXVQueryAdaptors (EphyrHostXVAdaptorArray **a_adaptors)
d253 3
a255 3
    EphyrHostXVAdaptorArray *result=NULL ;
    int ret=0 ;
    Bool is_ok=FALSE ;
d257 1
a257 1
    EPHYR_RETURN_VAL_IF_FAIL (a_adaptors, FALSE) ;
d259 1
a259 1
    EPHYR_LOG ("enter\n") ;
d261 1
a261 1
    result = calloc (1, sizeof (EphyrHostXVAdaptorArray)) ;
d263 1
a263 1
        goto out ;
d265 3
a267 4
    ret = XvQueryAdaptors (hostx_get_display (),
                           DefaultRootWindow (hostx_get_display ()),
                           &result->nb_adaptors,
                           &result->adaptors) ;
d269 2
a270 2
        EPHYR_LOG_ERROR ("failed to query host adaptors: %d\n", ret) ;
        goto out ;
d272 2
a273 2
    *a_adaptors = result ;
    is_ok = TRUE ;
d275 3
a277 3
out:
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d281 1
a281 1
ephyrHostXVAdaptorArrayDelete (EphyrHostXVAdaptorArray *a_adaptors)
d284 1
a284 1
        return ;
d286 3
a288 3
        XvFreeAdaptorInfo (a_adaptors->adaptors) ;
        a_adaptors->adaptors = NULL ;
        a_adaptors->nb_adaptors = 0 ;
d290 1
a290 1
    XFree (a_adaptors) ;
d294 1
a294 1
ephyrHostXVAdaptorArrayGetSize (const EphyrHostXVAdaptorArray *a_this)
d296 2
a297 2
    EPHYR_RETURN_VAL_IF_FAIL (a_this, -1) ;
    return a_this->nb_adaptors ;
d300 2
a301 3
EphyrHostXVAdaptor*
ephyrHostXVAdaptorArrayAt (const EphyrHostXVAdaptorArray *a_this,
                           int a_index)
d303 1
a303 1
    EPHYR_RETURN_VAL_IF_FAIL (a_this, NULL) ;
d306 2
a307 2
        return NULL ;
    return (EphyrHostXVAdaptor*)&a_this->adaptors[a_index] ;
d311 1
a311 1
ephyrHostXVAdaptorGetType (const EphyrHostXVAdaptor *a_this)
d313 2
a314 2
    EPHYR_RETURN_VAL_IF_FAIL (a_this, -1) ;
    return ((XvAdaptorInfo*)a_this)->type ;
d317 2
a318 2
const char*
ephyrHostXVAdaptorGetName (const EphyrHostXVAdaptor *a_this)
d320 1
a320 1
    EPHYR_RETURN_VAL_IF_FAIL (a_this, NULL) ;
d322 1
a322 1
    return ((XvAdaptorInfo*)a_this)->name ;
d325 3
a327 3
EphyrHostVideoFormat*
ephyrHostXVAdaptorGetVideoFormats (const EphyrHostXVAdaptor *a_this,
                                   int *a_nb_formats)
d329 4
a332 4
    EphyrHostVideoFormat *formats=NULL ;
    int nb_formats=0, i=0 ;
    XVisualInfo *visual_info, visual_info_template ;
    int nb_visual_info ;
d334 1
a334 1
    EPHYR_RETURN_VAL_IF_FAIL (a_this, NULL) ;
d336 4
a339 4
    nb_formats = ((XvAdaptorInfo*)a_this)->num_formats ;
    formats = calloc (nb_formats, sizeof (EphyrHostVideoFormat)) ;
    for (i=0; i < nb_formats; i++) {
        memset (&visual_info_template, 0, sizeof (visual_info_template)) ;
d341 7
a347 8
                            ((XvAdaptorInfo*)a_this)->formats[i].visual_id;
        visual_info = XGetVisualInfo (hostx_get_display (),
                                      VisualIDMask,
                                      &visual_info_template,
                                      &nb_visual_info) ;
        formats[i].depth = ((XvAdaptorInfo*)a_this)->formats[i].depth ;
        formats[i].visual_class = visual_info->class ;
        XFree (visual_info) ;
d350 2
a351 2
        *a_nb_formats = nb_formats ;
    return formats ;
d355 1
a355 1
ephyrHostXVAdaptorGetNbPorts (const EphyrHostXVAdaptor *a_this)
d357 1
a357 1
    EPHYR_RETURN_VAL_IF_FAIL (a_this, -1) ;
d359 1
a359 1
    return ((XvAdaptorInfo*)a_this)->num_ports ;
d363 1
a363 1
ephyrHostXVAdaptorGetFirstPortID (const EphyrHostXVAdaptor *a_this)
d365 1
a365 1
    EPHYR_RETURN_VAL_IF_FAIL (a_this, -1) ;
d367 1
a367 1
    return ((XvAdaptorInfo*)a_this)->base_id ;
d371 1
a371 2
ephyrHostXVAdaptorHasPutVideo (const EphyrHostXVAdaptor *a_this,
                               Bool *a_result)
d373 1
a373 1
    EPHYR_RETURN_VAL_IF_FAIL (a_this && a_result, FALSE) ;
d375 3
a377 3
    if ((((XvAdaptorInfo*)a_this)->type & (XvVideoMask | XvInputMask)) ==
		    (XvVideoMask | XvInputMask))
        *a_result = TRUE ;
d379 2
a380 2
        *a_result = FALSE ;
    return TRUE ;
d384 1
a384 2
ephyrHostXVAdaptorHasGetVideo (const EphyrHostXVAdaptor *a_this,
                               Bool *a_result)
d386 3
a388 3
    if ((((XvAdaptorInfo*)a_this)->type & (XvVideoMask | XvOutputMask)) ==
		    (XvVideoMask | XvOutputMask))
        *a_result = TRUE ;
d390 2
a391 2
        *a_result = FALSE ;
    return TRUE ;
d395 1
a395 2
ephyrHostXVAdaptorHasPutStill (const EphyrHostXVAdaptor *a_this,
                               Bool *a_result)
d397 1
a397 1
    EPHYR_RETURN_VAL_IF_FAIL (a_this && a_result, FALSE) ;
d399 3
a401 3
    if ((((XvAdaptorInfo*)a_this)->type & (XvStillMask | XvInputMask)) ==
		    (XvStillMask | XvInputMask))
        *a_result = TRUE ;
d403 2
a404 2
        *a_result = FALSE ;
    return TRUE ;
d408 1
a408 2
ephyrHostXVAdaptorHasGetStill (const EphyrHostXVAdaptor *a_this,
                               Bool *a_result)
d410 1
a410 1
    EPHYR_RETURN_VAL_IF_FAIL (a_this && a_result, FALSE) ;
d412 3
a414 3
    if ((((XvAdaptorInfo*)a_this)->type & (XvStillMask | XvOutputMask)) ==
		    (XvStillMask | XvOutputMask))
        *a_result = TRUE ;
d416 2
a417 2
        *a_result = FALSE ;
    return TRUE ;
d421 1
a421 2
ephyrHostXVAdaptorHasPutImage (const EphyrHostXVAdaptor *a_this,
                               Bool *a_result)
d423 1
a423 1
    EPHYR_RETURN_VAL_IF_FAIL (a_this && a_result, FALSE) ;
d425 3
a427 3
    if ((((XvAdaptorInfo*)a_this)->type & (XvImageMask | XvInputMask)) ==
		    (XvImageMask | XvInputMask))
        *a_result = TRUE ;
d429 2
a430 2
        *a_result = FALSE ;
    return TRUE ;
d434 3
a436 3
ephyrHostXVQueryEncodings (int a_port_id,
                           EphyrHostEncoding **a_encodings,
                           unsigned int *a_num_encodings)
d438 4
a441 4
    EphyrHostEncoding *encodings=NULL ;
    XvEncodingInfo *encoding_info=NULL ;
    unsigned int num_encodings=0, i;
    int ret=0 ;
d443 1
a443 1
    EPHYR_RETURN_VAL_IF_FAIL (a_encodings && a_num_encodings, FALSE) ;
d445 2
a446 4
    ret = XvQueryEncodings (hostx_get_display (),
                            a_port_id,
                            &num_encodings,
                            &encoding_info) ;
d448 8
a455 8
        encodings = calloc (num_encodings, sizeof (EphyrHostEncoding)) ;
        for (i=0; i<num_encodings; i++) {
            encodings[i].id = encoding_info[i].encoding_id ;
            encodings[i].name = strdup (encoding_info[i].name) ;
            encodings[i].width = encoding_info[i].width ;
            encodings[i].height = encoding_info[i].height ;
            encodings[i].rate.numerator = encoding_info[i].rate.numerator ;
            encodings[i].rate.denominator = encoding_info[i].rate.denominator ;
d459 2
a460 2
        XvFreeEncodingInfo (encoding_info) ;
        encoding_info = NULL ;
d462 2
a463 2
    *a_encodings = encodings ;
    *a_num_encodings = num_encodings ;
d466 2
a467 2
        return FALSE ;
    return TRUE ;
d471 1
a471 2
ephyrHostEncodingsDelete (EphyrHostEncoding *a_encodings,
                          int a_num_encodings)
d473 1
a473 1
    int i=0 ;
d476 4
a479 4
        return ;
    for (i=0; i < a_num_encodings; i++) {
        free(a_encodings[i].name) ;
        a_encodings[i].name = NULL ;
d481 1
a481 1
    free(a_encodings) ;
d485 1
a485 1
ephyrHostAttributesDelete (EphyrHostAttribute *a_attributes)
d488 2
a489 2
        return ;
    XFree (a_attributes) ;
d493 3
a495 3
ephyrHostXVQueryPortAttributes (int a_port_id,
                                EphyrHostAttribute **a_attributes,
                                int *a_num_attributes)
d497 1
a497 1
    EPHYR_RETURN_VAL_IF_FAIL (a_attributes && a_num_attributes, FALSE) ;
d500 3
a502 3
        (EphyrHostAttribute*)XvQueryPortAttributes (hostx_get_display (),
                                                    a_port_id,
                                                    a_num_attributes);
d504 1
a504 1
    return TRUE ;
d508 3
a510 3
ephyrHostXVQueryImageFormats (int a_port_id,
                              EphyrHostImageFormat **a_formats,
                              int *a_num_format)
d512 1
a512 1
    XvImageFormatValues *result=NULL ;
d514 1
a514 1
    EPHYR_RETURN_VAL_IF_FAIL (a_formats && a_num_format, FALSE) ;
d516 3
a518 5
    result = XvListImageFormats (hostx_get_display (),
                                 a_port_id,
                                 a_num_format) ;
    *a_formats = (EphyrHostImageFormat*) result ;
    return TRUE ;
d523 1
a523 3
ephyrHostXVSetPortAttribute (int a_port_id,
                             int a_atom,
                             int a_attr_value)
d525 1
a525 1
    int res=Success ;
d527 2
a528 4
    EPHYR_LOG ("atom,name,value: (%d,%s,%d)\n",
               a_atom,
               XGetAtomName (hostx_get_display (), a_atom),
               a_attr_value) ;
d530 2
a531 4
    res = XvSetPortAttribute (hostx_get_display (),
                              a_port_id,
                              a_atom,
                              a_attr_value) ;
d533 2
a534 2
        EPHYR_LOG_ERROR ("XvSetPortAttribute() failed: %d\n", res) ;
        return FALSE ;
d536 2
a537 2
    XFlush (hostx_get_display ()) ;
    EPHYR_LOG ("leave\n") ;
d539 1
a539 1
    return TRUE ;
d543 1
a543 3
ephyrHostXVGetPortAttribute (int a_port_id,
                             int a_atom,
                             int *a_attr_value)
d545 2
a546 2
    int res=Success ;
    Bool ret=FALSE ;
d548 1
a548 1
    EPHYR_RETURN_VAL_IF_FAIL (a_attr_value, FALSE) ;
d550 2
a551 2
    EPHYR_LOG ("enter, a_port_id: %d, a_atomid: %d, attr_name: %s\n",
               a_port_id, a_atom, XGetAtomName (hostx_get_display (), a_atom)) ;
d553 2
a554 4
    res = XvGetPortAttribute (hostx_get_display (),
                              a_port_id,
                              a_atom,
                              a_attr_value) ;
d556 2
a557 2
        EPHYR_LOG_ERROR ("XvGetPortAttribute() failed: %d \n", res) ;
        goto out ;
d559 1
a559 1
    EPHYR_LOG ("atom,value: (%d, %d)\n", a_atom, *a_attr_value) ;
d561 1
a561 1
    ret = TRUE ;
d563 3
a565 3
out:
    EPHYR_LOG ("leave\n") ;
    return ret ;
d569 7
a575 8
ephyrHostXVQueryBestSize (int a_port_id,
                          Bool a_motion,
                          unsigned int a_frame_w,
                          unsigned int a_frame_h,
                          unsigned int a_drw_w,
                          unsigned int a_drw_h,
                          unsigned int *a_actual_w,
                          unsigned int *a_actual_h)
d577 2
a578 2
    int res=0 ;
    Bool is_ok=FALSE ;
d580 1
a580 1
    EPHYR_RETURN_VAL_IF_FAIL (a_actual_w && a_actual_h, FALSE) ;
d582 2
a583 3
    EPHYR_LOG ("enter: frame (%dx%d), drw (%dx%d)\n",
               a_frame_w, a_frame_h,
               a_drw_w, a_drw_h) ;
d585 5
a589 6
    res = XvQueryBestSize (hostx_get_display (),
                           a_port_id,
                           a_motion,
                           a_frame_w, a_frame_h,
                           a_drw_w, a_drw_h,
                           a_actual_w, a_actual_h) ;
d591 2
a592 2
        EPHYR_LOG_ERROR ("XvQueryBestSize() failed: %d\n", res) ;
        goto out ;
d594 1
a594 1
    XSync (hostx_get_display (), FALSE) ;
d596 2
a597 2
    EPHYR_LOG ("actual (%dx%d)\n", *a_actual_w, *a_actual_h) ;
    is_ok = TRUE ;
d599 3
a601 3
out:
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d605 1
a605 1
xv_wire_to_event(Display *dpy, XEvent *host, xEvent *wire)
d607 3
a609 3
    XExtDisplayInfo *info = xv_find_display (dpy);
    XvEvent *re    = (XvEvent *)host;
    xvEvent *event = (xvEvent *)wire;
d614 25
a638 27
        case XvVideoNotify:
            re->xvvideo.type = event->u.u.type & 0x7f;
            re->xvvideo.serial =
            _XSetLastRequestRead(dpy, (xGenericReply *)event);
            re->xvvideo.send_event = ((event->u.u.type & 0x80) != 0);
            re->xvvideo.display = dpy;
            re->xvvideo.time = event->u.videoNotify.time;
            re->xvvideo.reason = event->u.videoNotify.reason;
            re->xvvideo.drawable = event->u.videoNotify.drawable;
            re->xvvideo.port_id = event->u.videoNotify.port;
            break;
        case XvPortNotify:
            re->xvport.type = event->u.u.type & 0x7f;
            re->xvport.serial =
            _XSetLastRequestRead(dpy, (xGenericReply *)event);
            re->xvport.send_event = ((event->u.u.type & 0x80) != 0);
            re->xvport.display = dpy;
            re->xvport.time = event->u.portNotify.time;
            re->xvport.port_id = event->u.portNotify.port;
            re->xvport.attribute = event->u.portNotify.attribute;
            re->xvport.value = event->u.portNotify.value;
            break;
        default:
            return False;
    }

    return True ;
d642 11
a652 12
ephyrHostXVQueryImageAttributes (int a_port_id,
                                 int a_image_id /*image fourcc code*/,
                                 unsigned short *a_width,
                                 unsigned short *a_height,
                                 int *a_image_size,
                                 int *a_pitches,
                                 int *a_offsets)
{
    Display *dpy = hostx_get_display () ;
    Bool ret=FALSE ;
    XExtDisplayInfo *info = xv_find_display (dpy);
    xvQueryImageAttributesReq *req=NULL;
d655 3
a657 3
    EPHYR_RETURN_VAL_IF_FAIL (a_width, FALSE) ;
    EPHYR_RETURN_VAL_IF_FAIL (a_height, FALSE) ;
    EPHYR_RETURN_VAL_IF_FAIL (a_image_size, FALSE) ;
d659 1
a659 1
    XvCheckExtension (dpy, info, FALSE);
d661 1
a661 1
    LockDisplay (dpy);
d663 1
a663 1
    XvGetReq (QueryImageAttributes, req);
d671 3
a673 3
    if (!_XReply (dpy, (xReply *)&rep, 0, xFalse)) {
        EPHYR_LOG_ERROR ("QeryImageAttribute req failed\n") ;
        goto out ;
d676 4
a679 7
        _XRead (dpy,
                (char*)a_pitches,
                rep.num_planes << 2);
        _XRead (dpy,
                (char*)a_offsets,
                rep.num_planes << 2);
    } else {
d682 3
a684 3
    *a_width = rep.width ;
    *a_height = rep.height ;
    *a_image_size = rep.data_size ;
d686 1
a686 1
    ret = TRUE ;
d688 4
a691 4
out:
    UnlockDisplay (dpy) ;
    SyncHandle ();
    return ret ;
d695 1
a695 3
ephyrHostGetAtom (const char* a_name,
                  Bool a_create_if_not_exists,
                  int *a_atom)
d697 1
a697 1
    int atom=None ;
d699 1
a699 1
    EPHYR_RETURN_VAL_IF_FAIL (a_atom, FALSE) ;
d701 1
a701 1
    atom = XInternAtom (hostx_get_display (), a_name, a_create_if_not_exists);
d703 1
a703 1
        return FALSE ;
d705 2
a706 2
    *a_atom = atom ;
    return TRUE ;
d709 2
a710 2
char*
ephyrHostGetAtomName (int a_atom)
d712 1
a712 1
    return XGetAtomName (hostx_get_display (), a_atom) ;
d716 1
a716 1
ephyrHostFree (void *a_pointer)
d719 1
a719 1
        XFree (a_pointer) ;
d723 19
a741 20
ephyrHostXVPutImage (int a_screen_num,
                     int a_port_id,
                     int a_image_id,
                     int a_drw_x,
                     int a_drw_y,
                     int a_drw_w,
                     int a_drw_h,
                     int a_src_x,
                     int a_src_y,
                     int a_src_w,
                     int a_src_h,
                     int a_image_width,
                     int a_image_height,
                     unsigned char *a_buf,
                     EphyrHostBox *a_clip_rects,
                     int a_clip_rect_nums )
{
    Bool is_ok=TRUE ;
    XvImage *xv_image=NULL ;
    GC gc=0 ;
d743 3
a745 3
    Display *dpy = hostx_get_display () ;
    XRectangle *rects=NULL ;
    int res = 0 ;
d747 1
a747 1
    EPHYR_RETURN_VAL_IF_FAIL (a_buf, FALSE) ;
d749 1
a749 1
    EPHYR_LOG ("enter, num_clip_rects: %d\n", a_clip_rect_nums) ;
d751 2
a752 2
    memset (&gc_values, 0, sizeof (gc_values)) ;
    gc = XCreateGC (dpy, hostx_get_window (a_screen_num), 0L, &gc_values);
d754 2
a755 2
        EPHYR_LOG_ERROR ("failed to create gc \n") ;
        goto out ;
d757 1
a757 1
    xv_image = (XvImage*) XvCreateImage (hostx_get_display (),
d759 1
a759 1
                                         NULL, a_image_width, a_image_height) ;
d761 2
a762 2
        EPHYR_LOG_ERROR ("failed to create image\n") ;
        goto out ;
d764 1
a764 1
    xv_image->data = (char*)a_buf ;
d766 6
a771 5
        int i=0 ;
        rects = calloc (a_clip_rect_nums, sizeof (XRectangle)) ;
        for (i=0; i < a_clip_rect_nums; i++) {
            rects[i].x = a_clip_rects[i].x1 ;
            rects[i].y = a_clip_rects[i].y1 ;
d774 2
a775 3
            EPHYR_LOG ("(x,y,w,h): (%d,%d,%d,%d)\n",
                       rects[i].x, rects[i].y,
                       rects[i].width, rects[i].height) ;
d777 2
a778 2
        XSetClipRectangles (dpy, gc, 0, 0, rects, a_clip_rect_nums, YXBanded) ;
        /*this always returns 1*/
d780 5
a784 5
    res = XvPutImage (dpy, a_port_id,
                      hostx_get_window (a_screen_num),
                      gc, xv_image,
                      a_src_x, a_src_y, a_src_w, a_src_h,
                      a_drw_x, a_drw_y, a_drw_w, a_drw_h) ;
d786 2
a787 2
        EPHYR_LOG_ERROR ("XvPutImage() failed: %d\n", res) ;
        goto out ;
d789 1
a789 1
    is_ok = TRUE ;
d791 1
a791 1
out:
d793 2
a794 2
        XFree (xv_image) ;
        xv_image = NULL ;
d797 2
a798 2
        XFreeGC (dpy, gc) ;
        gc = NULL ;
d802 2
a803 2
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
d807 3
a809 3
ephyrHostXVPutVideo (int a_screen_num, int a_port_id,
                     int a_vid_x, int a_vid_y, int a_vid_w, int a_vid_h,
                     int a_drw_x, int a_drw_y, int a_drw_w, int a_drw_h)
d811 3
a813 3
    Bool is_ok=FALSE ;
    int res=FALSE ;
    GC gc=0 ;
d815 1
a815 1
    Display *dpy=hostx_get_display () ;
d817 1
a817 1
    EPHYR_RETURN_VAL_IF_FAIL (dpy, FALSE) ;
d819 1
a819 1
    gc = XCreateGC (dpy, hostx_get_window (a_screen_num), 0L, &gc_values);
d821 2
a822 2
        EPHYR_LOG_ERROR ("failed to create gc \n") ;
        goto out ;
d824 3
a826 3
    res = XvPutVideo (dpy, a_port_id, hostx_get_window (a_screen_num), gc,
                      a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                      a_drw_x, a_drw_y, a_drw_w, a_drw_h) ;
d829 2
a830 2
        EPHYR_LOG_ERROR ("XvPutVideo() failed: %d\n", res) ;
        goto out ;
d833 1
a833 1
    is_ok = TRUE ;
d835 1
a835 1
out:
d837 2
a838 2
        XFreeGC (dpy, gc) ;
        gc = NULL ;
d840 1
a840 1
    return is_ok ;
d844 3
a846 3
ephyrHostXVGetVideo (int a_screen_num, int a_port_id,
                     int a_vid_x, int a_vid_y, int a_vid_w, int a_vid_h,
                     int a_drw_x, int a_drw_y, int a_drw_w, int a_drw_h)
d848 3
a850 3
    Bool is_ok=FALSE ;
    int res=FALSE ;
    GC gc=0 ;
d852 1
a852 1
    Display *dpy=hostx_get_display () ;
d854 1
a854 1
    EPHYR_RETURN_VAL_IF_FAIL (dpy, FALSE) ;
d856 1
a856 1
    gc = XCreateGC (dpy, hostx_get_window (a_screen_num), 0L, &gc_values);
d858 2
a859 2
        EPHYR_LOG_ERROR ("failed to create gc \n") ;
        goto out ;
d861 3
a863 3
    res = XvGetVideo (dpy, a_port_id, hostx_get_window (a_screen_num), gc,
                      a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                      a_drw_x, a_drw_y, a_drw_w, a_drw_h) ;
d866 2
a867 2
        EPHYR_LOG_ERROR ("XvGetVideo() failed: %d\n", res) ;
        goto out ;
d870 1
a870 1
    is_ok = TRUE ;
d872 1
a872 1
out:
d874 2
a875 2
        XFreeGC (dpy, gc) ;
        gc = NULL ;
d877 1
a877 1
    return is_ok ;
d881 3
a883 3
ephyrHostXVPutStill (int a_screen_num, int a_port_id,
                     int a_vid_x, int a_vid_y, int a_vid_w, int a_vid_h,
                     int a_drw_x, int a_drw_y, int a_drw_w, int a_drw_h)
d885 3
a887 3
    Bool is_ok=FALSE ;
    int res=FALSE ;
    GC gc=0 ;
d889 1
a889 1
    Display *dpy=hostx_get_display () ;
d891 1
a891 1
    EPHYR_RETURN_VAL_IF_FAIL (dpy, FALSE) ;
d893 1
a893 1
    gc = XCreateGC (dpy, hostx_get_window (a_screen_num), 0L, &gc_values);
d895 2
a896 2
        EPHYR_LOG_ERROR ("failed to create gc \n") ;
        goto out ;
d898 3
a900 3
    res = XvPutStill (dpy, a_port_id, hostx_get_window (a_screen_num), gc,
                      a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                      a_drw_x, a_drw_y, a_drw_w, a_drw_h) ;
d903 2
a904 2
        EPHYR_LOG_ERROR ("XvPutStill() failed: %d\n", res) ;
        goto out ;
d907 1
a907 1
    is_ok = TRUE ;
d909 1
a909 1
out:
d911 2
a912 2
        XFreeGC (dpy, gc) ;
        gc = NULL ;
d914 1
a914 1
    return is_ok ;
d918 3
a920 3
ephyrHostXVGetStill (int a_screen_num, int a_port_id,
                     int a_vid_x, int a_vid_y, int a_vid_w, int a_vid_h,
                     int a_drw_x, int a_drw_y, int a_drw_w, int a_drw_h)
d922 3
a924 3
    Bool is_ok=FALSE ;
    int res=FALSE ;
    GC gc=0 ;
d926 1
a926 1
    Display *dpy=hostx_get_display () ;
d928 1
a928 1
    EPHYR_RETURN_VAL_IF_FAIL (dpy, FALSE) ;
d930 1
a930 1
    gc = XCreateGC (dpy, hostx_get_window (a_screen_num), 0L, &gc_values);
d932 2
a933 2
        EPHYR_LOG_ERROR ("failed to create gc \n") ;
        goto out ;
d935 3
a937 3
    res = XvGetStill (dpy, a_port_id, hostx_get_window (a_screen_num), gc,
                      a_vid_x, a_vid_y, a_vid_w, a_vid_h,
                      a_drw_x, a_drw_y, a_drw_w, a_drw_h) ;
d940 2
a941 2
        EPHYR_LOG_ERROR ("XvGetStill() failed: %d\n", res) ;
        goto out ;
d944 1
a944 1
    is_ok = TRUE ;
d946 1
a946 1
out:
d948 2
a949 2
        XFreeGC (dpy, gc) ;
        gc = NULL ;
d951 1
a951 1
    return is_ok ;
d955 1
a955 1
ephyrHostXVStopVideo (int a_screen_num, int a_port_id)
d957 3
a959 3
    int ret=0 ;
    Bool is_ok=FALSE ;
    Display *dpy = hostx_get_display () ;
d961 1
a961 1
    EPHYR_RETURN_VAL_IF_FAIL (dpy, FALSE) ;
d963 1
a963 1
    EPHYR_LOG ("enter\n") ;
d965 1
a965 1
    ret = XvStopVideo (dpy, a_port_id, hostx_get_window (a_screen_num)) ;
d967 2
a968 2
        EPHYR_LOG_ERROR ("XvStopVideo() failed: %d \n", ret) ;
        goto out ;
d970 1
a970 1
    is_ok = TRUE ;
d972 3
a974 3
out:
    EPHYR_LOG ("leave\n") ;
    return is_ok ;
a975 1

@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d265 1
a265 1
    result = Xcalloc (1, sizeof (EphyrHostXVAdaptorArray)) ;
d343 1
a343 1
    formats = Xcalloc (nb_formats, sizeof (EphyrHostVideoFormat)) ;
d383 2
a384 1
    if (((XvAdaptorInfo*)a_this)->type & XvVideoMask & XvInputMask)
d395 2
a396 1
    if (((XvAdaptorInfo*)a_this)->type & XvVideoMask & XvOutputMask)
d409 2
a410 1
    if (((XvAdaptorInfo*)a_this)->type & XvStillMask && XvInputMask)
d423 2
a424 1
    if (((XvAdaptorInfo*)a_this)->type & XvStillMask && XvOutputMask)
d437 2
a438 1
    if (((XvAdaptorInfo*)a_this)->type & XvImageMask && XvInputMask)
d462 1
a462 1
        encodings = Xcalloc (num_encodings, sizeof (EphyrHostEncoding)) ;
d493 1
a493 1
        xfree (a_encodings[i].name) ;
d496 1
a496 1
    xfree (a_encodings) ;
d839 2
a840 4
    if (rects) {
        free (rects) ;
        rects = NULL ;
    }
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d488 2
a489 4
        if (a_encodings[i].name) {
            xfree (a_encodings[i].name) ;
            a_encodings[i].name = NULL ;
        }
@

