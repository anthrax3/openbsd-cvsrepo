head	1.12;
access;
symbols
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.31.14.09.44;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.18;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.50;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.50;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.04.11;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.13.21.15.46;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Xephyr - A kdrive X server thats runs in a host X window.
 *          Authored by Matthew Allum <mallum@@o-hand.com>
 *
 * Copyright Â© 2004 Nokia
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Nokia not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission. Nokia makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * NOKIA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL NOKIA BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif
#include "ephyr.h"
#include "ephyrlog.h"
#include "glx_extinit.h"

extern Window EphyrPreExistingHostWin;
extern Bool EphyrWantGrayScale;
extern Bool EphyrWantResize;
extern Bool EphyrWantNoHostGrab;
extern Bool kdHasPointer;
extern Bool kdHasKbd;
extern Bool ephyr_glamor, ephyr_glamor_gles2;

#ifdef GLXEXT
extern Bool ephyrNoDRI;
#endif
extern Bool ephyrNoXV;

#ifdef KDRIVE_EVDEV
extern KdPointerDriver LinuxEvdevMouseDriver;
extern KdKeyboardDriver LinuxEvdevKeyboardDriver;
#endif

void processScreenOrOutputArg(const char *screen_size, const char *output, char *parent_id);
void processOutputArg(const char *output, char *parent_id);
void processScreenArg(const char *screen_size, char *parent_id);

int
main(int argc, char *argv[], char *envp[])
{
    hostx_use_resname(basename(argv[0]), 0);
    return dix_main(argc, argv, envp);
}

void
InitCard(char *name)
{
    EPHYR_DBG("mark");
    KdCardInfoAdd(&ephyrFuncs, 0);
}

static const ExtensionModule ephyrExtensions[] = {
#ifdef GLXEXT
 { GlxExtensionInit, "GLX", &noGlxExtension },
#endif
};

static
void ephyrExtensionInit(void)
{
    LoadExtensionList(ephyrExtensions, ARRAY_SIZE(ephyrExtensions), TRUE);
}


void
InitOutput(ScreenInfo * pScreenInfo, int argc, char **argv)
{
    if (serverGeneration == 1)
        ephyrExtensionInit();

    KdInitOutput(pScreenInfo, argc, argv);
}

void
InitInput(int argc, char **argv)
{
    KdKeyboardInfo *ki;
    KdPointerInfo *pi;

    KdAddKeyboardDriver(&EphyrKeyboardDriver);
#ifdef KDRIVE_EVDEV
    KdAddKeyboardDriver(&LinuxEvdevKeyboardDriver);
#endif
    KdAddPointerDriver(&EphyrMouseDriver);
#ifdef KDRIVE_EVDEV
    KdAddPointerDriver(&LinuxEvdevMouseDriver);
#endif

    if (!kdHasKbd) {
        ki = KdNewKeyboard();
        if (!ki)
            FatalError("Couldn't create Xephyr keyboard\n");
        ki->driver = &EphyrKeyboardDriver;
        KdAddKeyboard(ki);
    }

    if (!kdHasPointer) {
        pi = KdNewPointer();
        if (!pi)
            FatalError("Couldn't create Xephyr pointer\n");
        pi->driver = &EphyrMouseDriver;
        KdAddPointer(pi);
    }

    KdInitInput();
}

void
CloseInput(void)
{
    KdCloseInput();
}

#ifdef DDXBEFORERESET
void
ddxBeforeReset(void)
{
}
#endif

void
ddxUseMsg(void)
{
    KdUseMsg();

    ErrorF("\nXephyr Option Usage:\n");
    ErrorF("-parent <XID>        Use existing window as Xephyr root win\n");
    ErrorF("-sw-cursor           Render cursors in software in Xephyr\n");
    ErrorF("-fullscreen          Attempt to run Xephyr fullscreen\n");
    ErrorF("-output <NAME>       Attempt to run Xephyr fullscreen (restricted to given output geometry)\n");
    ErrorF("-grayscale           Simulate 8bit grayscale\n");
    ErrorF("-resizeable          Make Xephyr windows resizeable\n");
#ifdef GLAMOR
    ErrorF("-glamor              Enable 2D acceleration using glamor\n");
    ErrorF("-glamor_gles2        Enable 2D acceleration using glamor (with GLES2 only)\n");
#endif
    ErrorF
        ("-fakexa              Simulate acceleration using software rendering\n");
    ErrorF("-verbosity <level>   Set log verbosity level\n");
#ifdef GLXEXT
    ErrorF("-nodri               do not use DRI\n");
#endif
    ErrorF("-noxv                do not use XV\n");
    ErrorF("-name [name]         define the name in the WM_CLASS property\n");
    ErrorF
        ("-title [title]       set the window title in the WM_NAME property\n");
    ErrorF("-no-host-grab        Disable grabbing the keyboard and mouse.\n");
    ErrorF("\n");
}

void
processScreenOrOutputArg(const char *screen_size, const char *output, char *parent_id)
{
    KdCardInfo *card;

    InitCard(0);                /*Put each screen on a separate card */
    card = KdCardInfoLast();

    if (card) {
        KdScreenInfo *screen;
        unsigned long p_id = 0;
        Bool use_geometry;

        screen = KdScreenInfoAdd(card);
        KdParseScreen(screen, screen_size);
        screen->driver = calloc(1, sizeof(EphyrScrPriv));
        if (!screen->driver)
            FatalError("Couldn't alloc screen private\n");

        if (parent_id) {
            p_id = strtol(parent_id, NULL, 0);
        }

        use_geometry = (strchr(screen_size, '+') != NULL);
        EPHYR_DBG("screen number:%d\n", screen->mynum);
        hostx_add_screen(screen, p_id, screen->mynum, use_geometry, output);
    }
    else {
        ErrorF("No matching card found!\n");
    }
}

void
processScreenArg(const char *screen_size, char *parent_id)
{
    processScreenOrOutputArg(screen_size, NULL, parent_id);
}

void
processOutputArg(const char *output, char *parent_id)
{
    processScreenOrOutputArg("100x100+0+0", output, parent_id);
}

int
ddxProcessArgument(int argc, char **argv, int i)
{
    static char *parent = NULL;

    EPHYR_DBG("mark argv[%d]='%s'", i, argv[i]);

    if (!strcmp(argv[i], "-parent")) {
        if (i + 1 < argc) {
            int j;

            /* If parent is specified and a screen argument follows, don't do
             * anything, let the -screen handling init the rest */
            for (j = i; j < argc; j++) {
                if (!strcmp(argv[j], "-screen")) {
                    parent = argv[i + 1];
                    return 2;
                }
            }

            processScreenArg("100x100", argv[i + 1]);
            return 2;
        }

        UseMsg();
        exit(1);
    }
    else if (!strcmp(argv[i], "-screen")) {
        if ((i + 1) < argc) {
            processScreenArg(argv[i + 1], parent);
            parent = NULL;
            return 2;
        }

        UseMsg();
        exit(1);
    }
    else if (!strcmp(argv[i], "-output")) {
        if (i + 1 < argc) {
            processOutputArg(argv[i + 1], NULL);
            return 2;
        }

        UseMsg();
        exit(1);
    }
    else if (!strcmp(argv[i], "-sw-cursor")) {
        hostx_use_sw_cursor();
        return 1;
    }
    else if (!strcmp(argv[i], "-host-cursor")) {
        /* Compatibility with the old command line argument, now the default. */
        return 1;
    }
    else if (!strcmp(argv[i], "-fullscreen")) {
        hostx_use_fullscreen();
        return 1;
    }
    else if (!strcmp(argv[i], "-grayscale")) {
        EphyrWantGrayScale = 1;
        return 1;
    }
    else if (!strcmp(argv[i], "-resizeable")) {
        EphyrWantResize = 1;
        return 1;
    }
#ifdef GLAMOR
    else if (!strcmp (argv[i], "-glamor")) {
        ephyr_glamor = TRUE;
        ephyrFuncs.initAccel = ephyr_glamor_init;
        ephyrFuncs.enableAccel = ephyr_glamor_enable;
        ephyrFuncs.disableAccel = ephyr_glamor_disable;
        ephyrFuncs.finiAccel = ephyr_glamor_fini;
        return 1;
    }
    else if (!strcmp (argv[i], "-glamor_gles2")) {
        ephyr_glamor = TRUE;
        ephyr_glamor_gles2 = TRUE;
        ephyrFuncs.initAccel = ephyr_glamor_init;
        ephyrFuncs.enableAccel = ephyr_glamor_enable;
        ephyrFuncs.disableAccel = ephyr_glamor_disable;
        ephyrFuncs.finiAccel = ephyr_glamor_fini;
        return 1;
    }
#endif
    else if (!strcmp(argv[i], "-fakexa")) {
        ephyrFuncs.initAccel = ephyrDrawInit;
        ephyrFuncs.enableAccel = ephyrDrawEnable;
        ephyrFuncs.disableAccel = ephyrDrawDisable;
        ephyrFuncs.finiAccel = ephyrDrawFini;
        return 1;
    }
    else if (!strcmp(argv[i], "-verbosity")) {
        if (i + 1 < argc && argv[i + 1][0] != '-') {
            int verbosity = atoi(argv[i + 1]);

            LogSetParameter(XLOG_VERBOSITY, verbosity);
            EPHYR_LOG("set verbosiry to %d\n", verbosity);
            return 2;
        }
        else {
            UseMsg();
            exit(1);
        }
    }
#ifdef GLXEXT
    else if (!strcmp(argv[i], "-nodri")) {
        ephyrNoDRI = TRUE;
        EPHYR_LOG("no direct rendering enabled\n");
        return 1;
    }
#endif
    else if (!strcmp(argv[i], "-noxv")) {
        ephyrNoXV = TRUE;
        EPHYR_LOG("no XVideo enabled\n");
        return 1;
    }
    else if (!strcmp(argv[i], "-name")) {
        if (i + 1 < argc && argv[i + 1][0] != '-') {
            hostx_use_resname(argv[i + 1], 1);
            return 2;
        }
        else {
            UseMsg();
            return 0;
        }
    }
    else if (!strcmp(argv[i], "-title")) {
        if (i + 1 < argc && argv[i + 1][0] != '-') {
            hostx_set_title(argv[i + 1]);
            return 2;
        }
        else {
            UseMsg();
            return 0;
        }
    }
    else if (argv[i][0] == ':') {
        hostx_set_display_name(argv[i]);
    }
    /* Xnest compatibility */
    else if (!strcmp(argv[i], "-display")) {
        hostx_set_display_name(argv[i + 1]);
        return 2;
    }
    else if (!strcmp(argv[i], "-sync") ||
             !strcmp(argv[i], "-full") ||
             !strcmp(argv[i], "-sss") || !strcmp(argv[i], "-install")) {
        return 1;
    }
    else if (!strcmp(argv[i], "-bw") ||
             !strcmp(argv[i], "-class") ||
             !strcmp(argv[i], "-geometry") || !strcmp(argv[i], "-scrns")) {
        return 2;
    }
    /* end Xnest compat */
    else if (!strcmp(argv[i], "-no-host-grab")) {
        EphyrWantNoHostGrab = 1;
        return 1;
    }

    return KdProcessArgument(argc, argv, i);
}

void
OsVendorInit(void)
{
    EPHYR_DBG("mark");

    if (hostx_want_host_cursor())
        ephyrFuncs.initCursor = &ephyrCursorInit;

    KdOsInit(&EphyrOsFuncs);
}

KdCardFuncs ephyrFuncs = {
    ephyrCardInit,              /* cardinit */
    ephyrScreenInitialize,      /* scrinit */
    ephyrInitScreen,            /* initScreen */
    ephyrFinishInitScreen,      /* finishInitScreen */
    ephyrCreateResources,       /* createRes */
    ephyrPreserve,              /* preserve */
    ephyrEnable,                /* enable */
    ephyrDPMS,                  /* dpms */
    ephyrDisable,               /* disable */
    ephyrRestore,               /* restore */
    ephyrScreenFini,            /* scrfini */
    ephyrCardFini,              /* cardfini */

    0,                          /* initCursor */
    0,                          /* enableCursor */
    0,                          /* disableCursor */
    0,                          /* finiCursor */
    0,                          /* recolorCursor */

    0,                          /* initAccel */
    0,                          /* enableAccel */
    0,                          /* disableAccel */
    0,                          /* finiAccel */

    ephyrGetColors,             /* getColors */
    ephyrPutColors,             /* putColors */

    ephyrCloseScreen,           /* closeScreen */
};
@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d370 1
a370 1
        return 2;
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d4 2
a5 2
 * 
 * Copyright Â© 2004 Nokia 
d36 1
d39 1
a39 1
extern Bool ephyr_glamor;
d51 2
d55 7
d147 1
d152 1
d164 1
d169 1
a169 1
processScreenArg(const char *screen_size, char *parent_id)
d179 1
d190 2
d193 1
a193 1
        hostx_add_screen(screen, p_id, screen->mynum);
d200 12
a218 4
    if (i == 1) {
        hostx_use_resname(basename(argv[0]), 0);
    }

d249 9
d287 9
d368 4
d381 1
a381 1
    if (hostx_want_host_cursor()) {
a382 2
        ephyrFuncs.enableCursor = &ephyrCursorEnable;
    }
a386 63
/* 'Fake' cursor stuff, could be improved */

static Bool
ephyrRealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
{
    return TRUE;
}

static Bool
ephyrUnrealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
{
    return TRUE;
}

static void
ephyrSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor, int x,
               int y)
{
    ;
}

static void
ephyrMoveCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
{
    ;
}

static Bool
ephyrDeviceCursorInitialize(DeviceIntPtr pDev, ScreenPtr pScreen)
{
    return TRUE;
}

static void
ephyrDeviceCursorCleanup(DeviceIntPtr pDev, ScreenPtr pScreen)
{
}

miPointerSpriteFuncRec EphyrPointerSpriteFuncs = {
    ephyrRealizeCursor,
    ephyrUnrealizeCursor,
    ephyrSetCursor,
    ephyrMoveCursor,
    ephyrDeviceCursorInitialize,
    ephyrDeviceCursorCleanup
};

Bool
ephyrCursorInit(ScreenPtr pScreen)
{
    miPointerInitialize(pScreen,
                        &EphyrPointerSpriteFuncs,
                        &ephyrPointerScreenFuncs, FALSE);

    return TRUE;
}

void
ephyrCursorEnable(ScreenPtr pScreen)
{
    ;
}

d414 2
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d38 1
d68 1
a68 4
 int i;

 for (i = 0; i < ARRAY_SIZE(ephyrExtensions); i++)
 LoadExtension(&ephyrExtensions[i], TRUE);
d139 3
a152 2

    exit(1);
d245 10
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d31 1
d35 1
d49 1
a49 1
void processScreenArg(char *screen_size, char *parent_id);
d58 16
d77 3
d137 1
a137 1
    ErrorF("-host-cursor         Re-use exisiting X host server cursor\n");
d140 1
d157 1
a157 1
processScreenArg(char *screen_size, char *parent_id)
d170 3
d226 4
d231 1
a231 1
        hostx_use_host_cursor();
d242 4
d399 1
a399 1
    ephyrScreenInit,            /* scrinit */
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a38 1
extern Bool noGlxVisualInit;
a234 1
        noGlxVisualInit = FALSE;
@


1.6
log
@Update to xserver 1.11.2
@
text
@d33 3
a35 3
extern Bool   EphyrWantGrayScale;
extern Bool   kdHasPointer;
extern Bool   kdHasKbd;
d38 1
a38 1
extern Bool   ephyrNoDRI;
d41 1
a41 1
extern Bool   ephyrNoXV;
d44 1
a44 1
extern KdPointerDriver	LinuxEvdevMouseDriver;
d48 1
a48 1
void processScreenArg (char *screen_size, char *parent_id) ;
d51 1
a51 1
InitCard (char *name)
d54 1
a54 1
    KdCardInfoAdd (&ephyrFuncs, 0);
d58 1
a58 1
InitOutput (ScreenInfo *pScreenInfo, int argc, char **argv)
d60 1
a60 1
  KdInitOutput (pScreenInfo, argc, argv);
d64 1
a64 1
InitInput (int argc, char **argv)
d66 2
a67 2
  KdKeyboardInfo *ki;
  KdPointerInfo *pi;
d69 1
a69 1
  KdAddKeyboardDriver(&EphyrKeyboardDriver);
d71 1
a71 1
  KdAddKeyboardDriver(&LinuxEvdevKeyboardDriver);
d73 1
a73 1
  KdAddPointerDriver(&EphyrMouseDriver);
d75 1
a75 1
  KdAddPointerDriver(&LinuxEvdevMouseDriver);
d78 15
a92 15
  if (!kdHasKbd) {
    ki = KdNewKeyboard();
    if (!ki)
      FatalError("Couldn't create Xephyr keyboard\n");
    ki->driver = &EphyrKeyboardDriver;
    KdAddKeyboard(ki);
  }

  if (!kdHasPointer) {
    pi = KdNewPointer();
    if (!pi)
      FatalError("Couldn't create Xephyr pointer\n");
    pi->driver = &EphyrMouseDriver;
    KdAddPointer(pi);
  }
d94 1
a94 1
  KdInitInput();
d98 1
a98 1
CloseInput (void)
d100 1
a100 1
  KdCloseInput();
d105 1
a105 1
ddxBeforeReset (void)
d111 1
a111 1
ddxUseMsg (void)
d113 1
a113 1
  KdUseMsg();
d115 8
a122 7
  ErrorF("\nXephyr Option Usage:\n");
  ErrorF("-parent <XID>        Use existing window as Xephyr root win\n");
  ErrorF("-host-cursor         Re-use exisiting X host server cursor\n");
  ErrorF("-fullscreen          Attempt to run Xephyr fullscreen\n");
  ErrorF("-grayscale           Simulate 8bit grayscale\n");
  ErrorF("-fakexa              Simulate acceleration using software rendering\n");
  ErrorF("-verbosity <level>   Set log verbosity level\n");
d124 1
a124 1
  ErrorF("-nodri               do not use DRI\n");
d126 5
a130 4
  ErrorF("-noxv                do not use XV\n");
  ErrorF("-name [name]         define the name in the WM_CLASS property\n");
  ErrorF("-title [title]       set the window title in the WM_NAME property\n");
  ErrorF("\n");
d132 1
a132 1
  exit(1);
d136 1
a136 1
processScreenArg (char *screen_size, char *parent_id)
d138 1
a138 1
  KdCardInfo   *card;
d140 2
a141 2
  InitCard (0);  /*Put each screen on a separate card*/
  card = KdCardInfoLast ();
d143 3
a145 4
  if (card)
    {
      KdScreenInfo *screen;
      unsigned long p_id = 0;
d147 2
a148 2
      screen = KdScreenInfoAdd (card);
      KdParseScreen (screen, screen_size);
d150 2
a151 3
      if (parent_id)
        {
          p_id = strtol (parent_id, NULL, 0);
d153 2
a154 2
      EPHYR_DBG ("screen number:%d\n", screen->mynum) ;
      hostx_add_screen (screen, p_id, screen->mynum);
d156 2
a157 3
  else
    {
      ErrorF("No matching card found!\n");
d162 1
a162 1
ddxProcessArgument (int argc, char **argv, int i)
d164 3
a166 2
  static char* parent = NULL;
  EPHYR_DBG("mark argv[%d]='%s'", i, argv[i] );
d168 65
a232 77
  if (i == 1)
    {
      hostx_use_resname(basename(argv[0]), 0);
    }

  if (!strcmp (argv[i], "-parent"))
    {
      if(i+1 < argc)
	{
	  int j;
	  /* If parent is specified and a screen argument follows, don't do
           * anything, let the -screen handling init the rest */
	  for (j = i; j < argc; j++)
	    {
	      if (!strcmp(argv[j], "-screen"))
		{
		  parent = argv[i + 1];
		  return 2;
		}
	    }

	  processScreenArg ("100x100", argv[i+1]);
	  return 2;
	}

      UseMsg();
      exit(1);
    }
  else if (!strcmp (argv[i], "-screen"))
    {
      if ((i+1) < argc)
	{
	  processScreenArg (argv[i+1], parent);
	  parent = NULL;
	  return 2;
	}

      UseMsg();
      exit(1);
    }
  else if (!strcmp (argv[i], "-host-cursor"))
    {
      hostx_use_host_cursor();
      return 1;
    }
  else if (!strcmp (argv[i], "-fullscreen"))
    {
      hostx_use_fullscreen();
      return 1;
    }
  else if (!strcmp (argv[i], "-grayscale"))
    {
      EphyrWantGrayScale = 1;      
      return 1;
    }
  else if (!strcmp (argv[i], "-fakexa"))
    {
      ephyrFuncs.initAccel = ephyrDrawInit;
      ephyrFuncs.enableAccel = ephyrDrawEnable;
      ephyrFuncs.disableAccel = ephyrDrawDisable;
      ephyrFuncs.finiAccel = ephyrDrawFini;
      return 1;
    }
  else if (!strcmp (argv[i], "-verbosity"))
    {
      if(i+1 < argc && argv[i+1][0] != '-')
	{
	  int verbosity=atoi (argv[i+1]) ;
	  LogSetParameter (XLOG_VERBOSITY, verbosity) ;
	  EPHYR_LOG ("set verbosiry to %d\n", verbosity) ;
	  return 2 ;
	}
      else
	{
	  UseMsg() ;
	  exit(1) ;
	}
d235 6
a240 7
  else if (!strcmp (argv[i], "-nodri"))
   {
       noGlxVisualInit = FALSE ;
       ephyrNoDRI = TRUE ;
       EPHYR_LOG ("no direct rendering enabled\n") ;
       return 1 ;
   }
d242 44
a285 57
  else if (!strcmp (argv[i], "-noxv"))
   {
       ephyrNoXV = TRUE ;
       EPHYR_LOG ("no XVideo enabled\n") ;
       return 1 ;
   }
  else if (!strcmp (argv[i], "-name"))
   {
       if (i+1 < argc && argv[i+1][0] != '-')
         {
           hostx_use_resname(argv[i+1], 1);
           return 2;
         }
       else
         {
           UseMsg();
           return 0;
         }
   }
  else if (!strcmp (argv[i], "-title"))
   {
       if (i+1 < argc && argv[i+1][0] != '-')
         {
           hostx_set_title(argv[i+1]);
           return 2;
         }
       else
         {
           UseMsg();
           return 0;
         }
   }
  else if (argv[i][0] == ':')
    {
      hostx_set_display_name(argv[i]);
    }
  /* Xnest compatibility */
  else if (!strcmp(argv[i], "-display"))
  {
      hostx_set_display_name(argv[i+1]);
      return 2;
  }
  else if (!strcmp(argv[i], "-sync") ||
	   !strcmp(argv[i], "-full") ||
	   !strcmp(argv[i], "-sss") ||
	   !strcmp(argv[i], "-install"))
  {
      return 1;
  }
  else if (!strcmp(argv[i], "-bw") ||
	   !strcmp(argv[i], "-class") ||
	   !strcmp(argv[i], "-geometry") ||
	   !strcmp(argv[i], "-scrns"))
  {
      return 2;
  }
  /* end Xnest compat */
d287 1
a287 1
  return KdProcessArgument (argc, argv, i);
d291 1
a291 1
OsVendorInit (void)
d293 1
a293 1
  EPHYR_DBG("mark");
d295 3
a297 4
  if (hostx_want_host_cursor())
    {
      ephyrFuncs.initCursor   = &ephyrCursorInit;
      ephyrFuncs.enableCursor = &ephyrCursorEnable;
d300 1
a300 1
  KdOsInit (&EphyrOsFuncs);
d308 1
a308 1
  return TRUE;
d314 1
a314 1
  return TRUE;
d318 2
a319 1
ephyrSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor, int x, int y)
d321 1
a321 1
  ;
d327 1
a327 1
  ;
d333 1
a333 1
  return TRUE;
d342 6
a347 6
	ephyrRealizeCursor,
	ephyrUnrealizeCursor,
	ephyrSetCursor,
	ephyrMoveCursor,
	ephyrDeviceCursorInitialize,
	ephyrDeviceCursorCleanup
a349 1

d353 3
a355 4
  miPointerInitialize(pScreen,
		      &EphyrPointerSpriteFuncs,
		      &ephyrPointerScreenFuncs,
		      FALSE);
d357 1
a357 1
  return TRUE;
d363 1
a363 1
  ;
d367 23
a389 23
    ephyrCardInit,	    /* cardinit */
    ephyrScreenInit,	    /* scrinit */
    ephyrInitScreen,	    /* initScreen */
    ephyrFinishInitScreen,  /* finishInitScreen */
    ephyrCreateResources,   /* createRes */
    ephyrPreserve,	    /* preserve */
    ephyrEnable,	    /* enable */
    ephyrDPMS,		    /* dpms */
    ephyrDisable,	    /* disable */
    ephyrRestore,	    /* restore */
    ephyrScreenFini,	    /* scrfini */
    ephyrCardFini,	    /* cardfini */

    0,			    /* initCursor */
    0,			    /* enableCursor */
    0,			    /* disableCursor */
    0,			    /* finiCursor */
    0,			    /* recolorCursor */

    0,			    /* initAccel */
    0,			    /* enableAccel */
    0,			    /* disableAccel */
    0,			    /* finiAccel */
d391 2
a392 2
    ephyrGetColors,/* getColors */
    ephyrPutColors,	    /* putColors */
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d5 1
a5 1
 * Copyright © 2004 Nokia 
d100 1
d362 5
d373 1
a373 1
	NULL
@


1.4
log
@Update to server 1.6.5.
@
text
@d43 5
a52 2
    KdCardAttr	attr;

d54 1
a54 3


    KdCardInfoAdd (&ephyrFuncs, &attr, 0);
d70 1
a70 1
#ifdef linux
d74 1
a74 1
#ifdef linux
d98 12
d126 1
d273 13
d290 21
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d150 1
d162 12
d185 2
a186 1
	  processScreenArg (argv[i+1], NULL);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d67 1
a67 1
        
d270 1
a270 1
ephyrRealizeCursor(ScreenPtr pScreen, CursorPtr pCursor)
d276 1
a276 1
ephyrUnrealizeCursor(ScreenPtr pScreen, CursorPtr pCursor)
d282 1
a282 1
ephyrSetCursor(ScreenPtr pScreen, CursorPtr pCursor, int x, int y)
d288 1
a288 1
ephyrMoveCursor(ScreenPtr pScreen, int x, int y)
d293 6
d304 2
d312 1
a312 1
  miPointerInitialize(pScreen, 
d314 1
a314 1
		      &ephyrPointerScreenFuncs, 
d339 3
a341 3
    
    0,	                    /* initCursor */
    0,          	    /* enableCursor */
d345 1
a345 1
    
d350 2
a351 2
    
    ephyrGetColors,    	    /* getColors */
@


1.1
log
@Initial revision
@
text
@d30 1
d34 10
d65 29
a93 1
  KdInitInput (&EphyrMouseFuncs, &EphyrKeyboardFuncs);
d102 11
a112 5
  ErrorF("-parent XID   Use existing window as Xephyr root win\n");
  ErrorF("-host-cursor  Re-use exisiting X host server cursor\n");
  ErrorF("-fullscreen   Attempt to run Xephyr fullscreen\n");
  ErrorF("-grayscale    Simulate 8bit grayscale\n");
  ErrorF("-fakexa	Simulate acceleration using software rendering\n");
d118 29
d150 6
a155 1
  EPHYR_DBG("mark");
d159 1
a159 1
      if(i+1 < argc) 
d161 1
a161 1
	  hostx_use_preexisting_window(strtol(argv[i+1], NULL, 0));
d163 13
a175 2
	} 
      
d202 43
d304 4
a307 2
  miPointerInitialize(pScreen, &EphyrPointerSpriteFuncs,
		      &kdPointerScreenFuncs, FALSE);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a32 2
extern Bool   kdHasPointer;
extern Bool   kdHasKbd;
d54 1
a54 29
  KdKeyboardInfo *ki;
  KdPointerInfo *pi;
        
  KdAddKeyboardDriver(&EphyrKeyboardDriver);
#ifdef linux
  KdAddKeyboardDriver(&LinuxEvdevKeyboardDriver);
#endif
  KdAddPointerDriver(&EphyrMouseDriver);
#ifdef linux
  KdAddPointerDriver(&LinuxEvdevMouseDriver);
#endif

  if (!kdHasKbd) {
    ki = KdNewKeyboard();
    if (!ki)
      FatalError("Couldn't create Xephyr keyboard\n");
    ki->driver = &EphyrKeyboardDriver;
    KdAddKeyboard(ki);
  }

  if (!kdHasPointer) {
    pi = KdNewPointer();
    if (!pi)
      FatalError("Couldn't create Xephyr pointer\n");
    pi->driver = &EphyrMouseDriver;
    KdAddPointer(pi);
  }

  KdInitInput();
d67 1
a67 1
  ErrorF("-fakexa       Simulate acceleration using software rendering\n");
@


1.1.1.3
log
@xserver 1.4.0.90
@
text
@a49 3
#ifdef GLXEXT
  noGlxExtension=TRUE;
#endif
@


