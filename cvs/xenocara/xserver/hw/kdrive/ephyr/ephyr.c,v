head	1.14;
access;
symbols
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	s0SI41sEunLdyFfd;

1.13
date	2015.09.16.19.10.21;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	Te1daavkBLskZ8gc;

1.12
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	cVXoV5PxI8YrEaVA;

1.11
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.08.24.19.44.35;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.05;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.29;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.51;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.51;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.04.11;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Xephyr - A kdrive X server thats runs in a host X window.
 *          Authored by Matthew Allum <mallum@@openedhand.com>
 *
 * Copyright Â© 2004 Nokia
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Nokia not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission. Nokia makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * NOKIA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL NOKIA BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif

#include <xcb/xcb_keysyms.h>
#include <X11/keysym.h>

#include "ephyr.h"

#include "inputstr.h"
#include "scrnintstr.h"
#include "ephyrlog.h"

#ifdef XF86DRI
#include <xcb/xf86dri.h>
#include "ephyrdri.h"
#include "ephyrdriext.h"
#include "ephyrglxext.h"
#endif                          /* XF86DRI */

#ifdef GLAMOR
#include "glamor.h"
#endif
#include "ephyr_glamor_glx.h"

#include "xkbsrv.h"

extern Bool ephyr_glamor;

KdKeyboardInfo *ephyrKbd;
KdPointerInfo *ephyrMouse;
EphyrKeySyms ephyrKeySyms;
Bool ephyrNoDRI = FALSE;
Bool ephyrNoXV = FALSE;

static int mouseState = 0;
static Rotation ephyrRandr = RR_Rotate_0;

typedef struct _EphyrInputPrivate {
    Bool enabled;
} EphyrKbdPrivate, EphyrPointerPrivate;

Bool EphyrWantGrayScale = 0;
Bool EphyrWantResize = 0;
Bool EphyrWantNoHostGrab = 0;

Bool
ephyrInitialize(KdCardInfo * card, EphyrPriv * priv)
{
    OsSignal(SIGUSR1, hostx_handle_signal);

    priv->base = 0;
    priv->bytes_per_line = 0;
    return TRUE;
}

Bool
ephyrCardInit(KdCardInfo * card)
{
    EphyrPriv *priv;

    priv = (EphyrPriv *) malloc(sizeof(EphyrPriv));
    if (!priv)
        return FALSE;

    if (!ephyrInitialize(card, priv)) {
        free(priv);
        return FALSE;
    }
    card->driver = priv;

    return TRUE;
}

Bool
ephyrScreenInitialize(KdScreenInfo *screen)
{
    EphyrScrPriv *scrpriv = screen->driver;
    int x = 0, y = 0;
    int width = 640, height = 480;
    CARD32 redMask, greenMask, blueMask;

    if (hostx_want_screen_geometry(screen, &width, &height, &x, &y)
        || !screen->width || !screen->height) {
        screen->width = width;
        screen->height = height;
        screen->x = x;
        screen->y = y;
    }

    if (EphyrWantGrayScale)
        screen->fb.depth = 8;

    if (screen->fb.depth && screen->fb.depth != hostx_get_depth()) {
        if (screen->fb.depth < hostx_get_depth()
            && (screen->fb.depth == 24 || screen->fb.depth == 16
                || screen->fb.depth == 8)) {
            scrpriv->server_depth = screen->fb.depth;
        }
        else
            ErrorF
                ("\nXephyr: requested screen depth not supported, setting to match hosts.\n");
    }

    screen->fb.depth = hostx_get_server_depth(screen);
    screen->rate = 72;

    if (screen->fb.depth <= 8) {
        if (EphyrWantGrayScale)
            screen->fb.visuals = ((1 << StaticGray) | (1 << GrayScale));
        else
            screen->fb.visuals = ((1 << StaticGray) |
                                  (1 << GrayScale) |
                                  (1 << StaticColor) |
                                  (1 << PseudoColor) |
                                  (1 << TrueColor) | (1 << DirectColor));

        screen->fb.redMask = 0x00;
        screen->fb.greenMask = 0x00;
        screen->fb.blueMask = 0x00;
        screen->fb.depth = 8;
        screen->fb.bitsPerPixel = 8;
    }
    else {
        screen->fb.visuals = (1 << TrueColor);

        if (screen->fb.depth <= 15) {
            screen->fb.depth = 15;
            screen->fb.bitsPerPixel = 16;
        }
        else if (screen->fb.depth <= 16) {
            screen->fb.depth = 16;
            screen->fb.bitsPerPixel = 16;
        }
        else if (screen->fb.depth <= 24) {
            screen->fb.depth = 24;
            screen->fb.bitsPerPixel = 32;
        }
        else if (screen->fb.depth <= 30) {
            screen->fb.depth = 30;
            screen->fb.bitsPerPixel = 32;
        }
        else {
            ErrorF("\nXephyr: Unsupported screen depth %d\n", screen->fb.depth);
            return FALSE;
        }

        hostx_get_visual_masks(screen, &redMask, &greenMask, &blueMask);

        screen->fb.redMask = (Pixel) redMask;
        screen->fb.greenMask = (Pixel) greenMask;
        screen->fb.blueMask = (Pixel) blueMask;

    }

    scrpriv->randr = screen->randr;

    return ephyrMapFramebuffer(screen);
}

void *
ephyrWindowLinear(ScreenPtr pScreen,
                  CARD32 row,
                  CARD32 offset, int mode, CARD32 *size, void *closure)
{
    KdScreenPriv(pScreen);
    EphyrPriv *priv = pScreenPriv->card->driver;

    if (!pScreenPriv->enabled)
        return 0;

    *size = priv->bytes_per_line;
    return priv->base + row * priv->bytes_per_line + offset;
}

/**
 * Figure out display buffer size. If fakexa is enabled, allocate a larger
 * buffer so that fakexa has space to put offscreen pixmaps.
 */
int
ephyrBufferHeight(KdScreenInfo * screen)
{
    int buffer_height;

    if (ephyrFuncs.initAccel == NULL)
        buffer_height = screen->height;
    else
        buffer_height = 3 * screen->height;
    return buffer_height;
}

Bool
ephyrMapFramebuffer(KdScreenInfo * screen)
{
    EphyrScrPriv *scrpriv = screen->driver;
    EphyrPriv *priv = screen->card->driver;
    KdPointerMatrix m;
    int buffer_height;

    EPHYR_LOG("screen->width: %d, screen->height: %d index=%d",
              screen->width, screen->height, screen->mynum);

    /*
     * Use the rotation last applied to ourselves (in the Xephyr case the fb
     * coordinate system moves independently of the pointer coordiante system).
     */
    KdComputePointerMatrix(&m, ephyrRandr, screen->width, screen->height);
    KdSetPointerMatrix(&m);

    buffer_height = ephyrBufferHeight(screen);

    priv->base =
        hostx_screen_init(screen, screen->x, screen->y,
                          screen->width, screen->height, buffer_height,
                          &priv->bytes_per_line, &screen->fb.bitsPerPixel);

    if ((scrpriv->randr & RR_Rotate_0) && !(scrpriv->randr & RR_Reflect_All)) {
        scrpriv->shadow = FALSE;

        screen->fb.byteStride = priv->bytes_per_line;
        screen->fb.pixelStride = screen->width;
        screen->fb.frameBuffer = (CARD8 *) (priv->base);
    }
    else {
        /* Rotated/Reflected so we need to use shadow fb */
        scrpriv->shadow = TRUE;

        EPHYR_LOG("allocing shadow");

        KdShadowFbAlloc(screen,
                        scrpriv->randr & (RR_Rotate_90 | RR_Rotate_270));
    }

    return TRUE;
}

void
ephyrSetScreenSizes(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    EphyrScrPriv *scrpriv = screen->driver;

    if (scrpriv->randr & (RR_Rotate_0 | RR_Rotate_180)) {
        pScreen->width = screen->width;
        pScreen->height = screen->height;
        pScreen->mmWidth = screen->width_mm;
        pScreen->mmHeight = screen->height_mm;
    }
    else {
        pScreen->width = screen->height;
        pScreen->height = screen->width;
        pScreen->mmWidth = screen->height_mm;
        pScreen->mmHeight = screen->width_mm;
    }
}

Bool
ephyrUnmapFramebuffer(KdScreenInfo * screen)
{
    EphyrScrPriv *scrpriv = screen->driver;

    if (scrpriv->shadow)
        KdShadowFbFree(screen);

    /* Note, priv->base will get freed when XImage recreated */

    return TRUE;
}

void
ephyrShadowUpdate(ScreenPtr pScreen, shadowBufPtr pBuf)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;

    EPHYR_LOG("slow paint");

    /* FIXME: Slow Rotated/Reflected updates could be much
     * much faster efficiently updating via tranforming
     * pBuf->pDamage  regions
     */
    shadowUpdateRotatePacked(pScreen, pBuf);
    hostx_paint_rect(screen, 0, 0, 0, 0, screen->width, screen->height);
}

static void
ephyrInternalDamageRedisplay(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    EphyrScrPriv *scrpriv = screen->driver;
    RegionPtr pRegion;

    if (!scrpriv || !scrpriv->pDamage)
        return;

    pRegion = DamageRegion(scrpriv->pDamage);

    if (RegionNotEmpty(pRegion)) {
        int nbox;
        BoxPtr pbox;

        if (ephyr_glamor) {
            ephyr_glamor_damage_redisplay(scrpriv->glamor, pRegion);
        } else {
            nbox = RegionNumRects(pRegion);
            pbox = RegionRects(pRegion);

            while (nbox--) {
                hostx_paint_rect(screen,
                                 pbox->x1, pbox->y1,
                                 pbox->x1, pbox->y1,
                                 pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
                pbox++;
            }
        }
        DamageEmpty(scrpriv->pDamage);
    }
}

static void
ephyrInternalDamageBlockHandler(void *data, OSTimePtr pTimeout, void *pRead)
{
    ScreenPtr pScreen = (ScreenPtr) data;

    ephyrInternalDamageRedisplay(pScreen);
}

static void
ephyrInternalDamageWakeupHandler(void *data, int i, void *LastSelectMask)
{
    /* FIXME: Not needed ? */
}

Bool
ephyrSetInternalDamage(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    EphyrScrPriv *scrpriv = screen->driver;
    PixmapPtr pPixmap = NULL;

    scrpriv->pDamage = DamageCreate((DamageReportFunc) 0,
                                    (DamageDestroyFunc) 0,
                                    DamageReportNone, TRUE, pScreen, pScreen);

    if (!RegisterBlockAndWakeupHandlers(ephyrInternalDamageBlockHandler,
                                        ephyrInternalDamageWakeupHandler,
                                        (void *) pScreen))
        return FALSE;

    pPixmap = (*pScreen->GetScreenPixmap) (pScreen);

    DamageRegister(&pPixmap->drawable, scrpriv->pDamage);

    return TRUE;
}

void
ephyrUnsetInternalDamage(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    EphyrScrPriv *scrpriv = screen->driver;

    DamageDestroy(scrpriv->pDamage);

    RemoveBlockAndWakeupHandlers(ephyrInternalDamageBlockHandler,
                                 ephyrInternalDamageWakeupHandler,
                                 (void *) pScreen);
}

#ifdef RANDR
Bool
ephyrRandRGetInfo(ScreenPtr pScreen, Rotation * rotations)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    EphyrScrPriv *scrpriv = screen->driver;
    RRScreenSizePtr pSize;
    Rotation randr;
    int n = 0;

    struct {
        int width, height;
    } sizes[] = {
        {1600, 1200},
        {1400, 1050},
        {1280, 960},
        {1280, 1024},
        {1152, 864},
        {1024, 768},
        {832, 624},
        {800, 600},
        {720, 400},
        {480, 640},
        {640, 480},
        {640, 400},
        {320, 240},
        {240, 320},
        {160, 160},
        {0, 0}
    };

    EPHYR_LOG("mark");

    *rotations = RR_Rotate_All | RR_Reflect_All;

    if (!hostx_want_preexisting_window(screen)
        && !hostx_want_fullscreen()) {  /* only if no -parent switch */
        while (sizes[n].width != 0 && sizes[n].height != 0) {
            RRRegisterSize(pScreen,
                           sizes[n].width,
                           sizes[n].height,
                           (sizes[n].width * screen->width_mm) / screen->width,
                           (sizes[n].height * screen->height_mm) /
                           screen->height);
            n++;
        }
    }

    pSize = RRRegisterSize(pScreen,
                           screen->width,
                           screen->height, screen->width_mm, screen->height_mm);

    randr = KdSubRotation(scrpriv->randr, screen->randr);

    RRSetCurrentConfig(pScreen, randr, 0, pSize);

    return TRUE;
}

Bool
ephyrRandRSetConfig(ScreenPtr pScreen,
                    Rotation randr, int rate, RRScreenSizePtr pSize)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    EphyrScrPriv *scrpriv = screen->driver;
    Bool wasEnabled = pScreenPriv->enabled;
    EphyrScrPriv oldscr;
    int oldwidth, oldheight, oldmmwidth, oldmmheight;
    Bool oldshadow;
    int newwidth, newheight;

    if (screen->randr & (RR_Rotate_0 | RR_Rotate_180)) {
        newwidth = pSize->width;
        newheight = pSize->height;
    }
    else {
        newwidth = pSize->height;
        newheight = pSize->width;
    }

    if (wasEnabled)
        KdDisableScreen(pScreen);

    oldscr = *scrpriv;

    oldwidth = screen->width;
    oldheight = screen->height;
    oldmmwidth = pScreen->mmWidth;
    oldmmheight = pScreen->mmHeight;
    oldshadow = scrpriv->shadow;

    /*
     * Set new configuration
     */

    /*
     * We need to store the rotation value for pointer coords transformation;
     * though initially the pointer and fb rotation are identical, when we map
     * the fb, the screen will be reinitialized and return into an unrotated
     * state (presumably the HW is taking care of the rotation of the fb), but the
     * pointer still needs to be transformed.
     */
    ephyrRandr = KdAddRotation(screen->randr, randr);
    scrpriv->randr = ephyrRandr;

    ephyrUnmapFramebuffer(screen);

    screen->width = newwidth;
    screen->height = newheight;

    if (!ephyrMapFramebuffer(screen))
        goto bail4;

    /* FIXME below should go in own call */

    if (oldshadow)
        KdShadowUnset(screen->pScreen);
    else
        ephyrUnsetInternalDamage(screen->pScreen);

    if (scrpriv->shadow) {
        if (!KdShadowSet(screen->pScreen,
                         scrpriv->randr, ephyrShadowUpdate, ephyrWindowLinear))
            goto bail4;
    }
    else {
        /* Without shadow fb ( non rotated ) we need
         * to use damage to efficiently update display
         * via signal regions what to copy from 'fb'.
         */
        if (!ephyrSetInternalDamage(screen->pScreen))
            goto bail4;
    }

    ephyrSetScreenSizes(screen->pScreen);

    /*
     * Set frame buffer mapping
     */
    (*pScreen->ModifyPixmapHeader) (fbGetScreenPixmap(pScreen),
                                    pScreen->width,
                                    pScreen->height,
                                    screen->fb.depth,
                                    screen->fb.bitsPerPixel,
                                    screen->fb.byteStride,
                                    screen->fb.frameBuffer);

    /* set the subpixel order */

    KdSetSubpixelOrder(pScreen, scrpriv->randr);

    if (wasEnabled)
        KdEnableScreen(pScreen);

    RRScreenSizeNotify(pScreen);

    return TRUE;

 bail4:
    EPHYR_LOG("bailed");

    ephyrUnmapFramebuffer(screen);
    *scrpriv = oldscr;
    (void) ephyrMapFramebuffer(screen);

    pScreen->width = oldwidth;
    pScreen->height = oldheight;
    pScreen->mmWidth = oldmmwidth;
    pScreen->mmHeight = oldmmheight;

    if (wasEnabled)
        KdEnableScreen(pScreen);
    return FALSE;
}

Bool
ephyrRandRInit(ScreenPtr pScreen)
{
    rrScrPrivPtr pScrPriv;

    if (!RRScreenInit(pScreen))
        return FALSE;

    pScrPriv = rrGetScrPriv(pScreen);
    pScrPriv->rrGetInfo = ephyrRandRGetInfo;
    pScrPriv->rrSetConfig = ephyrRandRSetConfig;
    return TRUE;
}

static Bool
ephyrResizeScreen (ScreenPtr           pScreen,
                  int                  newwidth,
                  int                  newheight)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    RRScreenSize size = {0};
    Bool ret;
    int t;

    if (screen->randr & (RR_Rotate_90|RR_Rotate_270)) {
        t = newwidth;
        newwidth = newheight;
        newheight = t;
    }

    if (newwidth == screen->width && newheight == screen->height) {
        return FALSE;
    }

    size.width = newwidth;
    size.height = newheight;

    ret = ephyrRandRSetConfig (pScreen, screen->randr, 0, &size);
    if (ret) {
        RROutputPtr output;

        output = RRFirstOutput(pScreen);
        if (!output)
            return FALSE;
        RROutputSetModes(output, NULL, 0, 0);
    }

    return ret;
}
#endif

Bool
ephyrCreateColormap(ColormapPtr pmap)
{
    return fbInitializeColormap(pmap);
}

Bool
ephyrInitScreen(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;

    EPHYR_LOG("pScreen->myNum:%d\n", pScreen->myNum);
    hostx_set_screen_number(screen, pScreen->myNum);
    if (EphyrWantNoHostGrab) {
        hostx_set_win_title(screen, "xephyr");
    } else {
        hostx_set_win_title(screen, "(ctrl+shift grabs mouse and keyboard)");
    }
    pScreen->CreateColormap = ephyrCreateColormap;

#ifdef XV
    if (!ephyrNoXV) {
        if (ephyr_glamor)
            ephyr_glamor_xv_init(pScreen);
        else if (!ephyrInitVideo(pScreen)) {
            EPHYR_LOG_ERROR("failed to initialize xvideo\n");
        }
        else {
            EPHYR_LOG("initialized xvideo okay\n");
        }
    }
#endif /*XV*/
#ifdef XF86DRI
    if (!ephyrNoDRI && !hostx_has_extension(&xcb_xf86dri_id)) {
        EPHYR_LOG("host x does not support DRI. Disabling DRI forwarding\n");
        ephyrNoDRI = TRUE;
    }
    if (!ephyrNoDRI) {
        ephyrDRIExtensionInit(pScreen);
        ephyrHijackGLXExtension();
    }
#endif

    return TRUE;
}


Bool
ephyrFinishInitScreen(ScreenPtr pScreen)
{
    /* FIXME: Calling this even if not using shadow.
     * Seems harmless enough. But may be safer elsewhere.
     */
    if (!shadowSetup(pScreen))
        return FALSE;

#ifdef RANDR
    if (!ephyrRandRInit(pScreen))
        return FALSE;
#endif

    return TRUE;
}

/**
 * Called by kdrive after calling down the
 * pScreen->CreateScreenResources() chain, this gives us a chance to
 * make any pixmaps after the screen and all extensions have been
 * initialized.
 */
Bool
ephyrCreateResources(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    EphyrScrPriv *scrpriv = screen->driver;

    EPHYR_LOG("mark pScreen=%p mynum=%d shadow=%d",
              pScreen, pScreen->myNum, scrpriv->shadow);

    if (scrpriv->shadow)
        return KdShadowSet(pScreen,
                           scrpriv->randr,
                           ephyrShadowUpdate, ephyrWindowLinear);
    else {
#ifdef GLAMOR
        if (ephyr_glamor)
            ephyr_glamor_create_screen_resources(pScreen);
#endif
        return ephyrSetInternalDamage(pScreen);
    }
}

void
ephyrPreserve(KdCardInfo * card)
{
}

Bool
ephyrEnable(ScreenPtr pScreen)
{
    return TRUE;
}

Bool
ephyrDPMS(ScreenPtr pScreen, int mode)
{
    return TRUE;
}

void
ephyrDisable(ScreenPtr pScreen)
{
}

void
ephyrRestore(KdCardInfo * card)
{
}

void
ephyrScreenFini(KdScreenInfo * screen)
{
    EphyrScrPriv *scrpriv = screen->driver;

    if (scrpriv->shadow) {
        KdShadowFbFree(screen);
    }
}

void
ephyrCloseScreen(ScreenPtr pScreen)
{
    ephyrUnsetInternalDamage(pScreen);
}

/*
 * Port of Mark McLoughlin's Xnest fix for focus in + modifier bug.
 * See https://bugs.freedesktop.org/show_bug.cgi?id=3030
 */
void
ephyrUpdateModifierState(unsigned int state)
{

    DeviceIntPtr pDev = inputInfo.keyboard;
    KeyClassPtr keyc = pDev->key;
    int i;
    CARD8 mask;
    int xkb_state;

    if (!pDev)
        return;

    xkb_state = XkbStateFieldFromRec(&pDev->key->xkbInfo->state);
    state = state & 0xff;

    if (xkb_state == state)
        return;

    for (i = 0, mask = 1; i < 8; i++, mask <<= 1) {
        int key;

        /* Modifier is down, but shouldn't be
         */
        if ((xkb_state & mask) && !(state & mask)) {
            int count = keyc->modifierKeyCount[i];

            for (key = 0; key < MAP_LENGTH; key++)
                if (keyc->xkbInfo->desc->map->modmap[key] & mask) {
                    if (mask == XCB_MOD_MASK_LOCK) {
                        KdEnqueueKeyboardEvent(ephyrKbd, key, FALSE);
                        KdEnqueueKeyboardEvent(ephyrKbd, key, TRUE);
                    }
                    else if (key_is_down(pDev, key, KEY_PROCESSED))
                        KdEnqueueKeyboardEvent(ephyrKbd, key, TRUE);

                    if (--count == 0)
                        break;
                }
        }

        /* Modifier shoud be down, but isn't
         */
        if (!(xkb_state & mask) && (state & mask))
            for (key = 0; key < MAP_LENGTH; key++)
                if (keyc->xkbInfo->desc->map->modmap[key] & mask) {
                    KdEnqueueKeyboardEvent(ephyrKbd, key, FALSE);
                    if (mask == XCB_MOD_MASK_LOCK)
                        KdEnqueueKeyboardEvent(ephyrKbd, key, TRUE);
                    break;
                }
    }
}

static Bool
ephyrCursorOffScreen(ScreenPtr *ppScreen, int *x, int *y)
{
    return FALSE;
}

static void
ephyrCrossScreen(ScreenPtr pScreen, Bool entering)
{
}

ScreenPtr ephyrCursorScreen; /* screen containing the cursor */

static void
ephyrWarpCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
{
    OsBlockSIGIO();
    ephyrCursorScreen = pScreen;
    miPointerWarpCursor(inputInfo.pointer, pScreen, x, y);

    OsReleaseSIGIO();
}

miPointerScreenFuncRec ephyrPointerScreenFuncs = {
    ephyrCursorOffScreen,
    ephyrCrossScreen,
    ephyrWarpCursor,
};

#ifdef XF86DRI
/**
 * find if the remote window denoted by a_remote
 * is paired with an internal Window within the Xephyr server.
 * If the remove window is paired with an internal window, send an
 * expose event to the client insterested in the internal window expose event.
 *
 * Pairing happens when a drawable inside Xephyr is associated with
 * a GL surface in a DRI environment.
 * Look at the function ProcXF86DRICreateDrawable in ephyrdriext.c to
 * know a paired window is created.
 *
 * This is useful to make GL drawables (only windows for now) handle
 * expose events and send those events to clients.
 */
static void
ephyrExposePairedWindow(int a_remote)
{
    EphyrWindowPair *pair = NULL;
    RegionRec reg;
    ScreenPtr screen;

    if (!findWindowPairFromRemote(a_remote, &pair)) {
        EPHYR_LOG("did not find a pair for this window\n");
        return;
    }
    screen = pair->local->drawable.pScreen;
    RegionNull(&reg);
    RegionCopy(&reg, &pair->local->clipList);
    screen->WindowExposures(pair->local, &reg);
    RegionUninit(&reg);
}
#endif                          /* XF86DRI */

static KdScreenInfo *
screen_from_window(Window w)
{
    int i = 0;

    for (i = 0; i < screenInfo.numScreens; i++) {
        ScreenPtr pScreen = screenInfo.screens[i];
        KdPrivScreenPtr kdscrpriv = KdGetScreenPriv(pScreen);
        KdScreenInfo *screen = kdscrpriv->screen;
        EphyrScrPriv *scrpriv = screen->driver;

        if (scrpriv->win == w
            || scrpriv->peer_win == w
            || scrpriv->win_pre_existing == w) {
            return screen;
        }
    }

    return NULL;
}

static void
ephyrProcessErrorEvent(xcb_generic_event_t *xev)
{
    xcb_generic_error_t *e = (xcb_generic_error_t *)xev;

    FatalError("X11 error\n"
               "Error code: %hhu\n"
               "Sequence number: %hu\n"
               "Major code: %hhu\tMinor code: %hu\n"
               "Error value: %u\n",
               e->error_code,
               e->sequence,
               e->major_code, e->minor_code,
               e->resource_id);
}

static void
ephyrProcessExpose(xcb_generic_event_t *xev)
{
    xcb_expose_event_t *expose = (xcb_expose_event_t *)xev;
    KdScreenInfo *screen = screen_from_window(expose->window);
    EphyrScrPriv *scrpriv = screen->driver;

    /* Wait for the last expose event in a series of cliprects
     * to actually paint our screen.
     */
    if (expose->count != 0)
        return;

    if (scrpriv) {
        hostx_paint_rect(scrpriv->screen, 0, 0, 0, 0,
                         scrpriv->win_width,
                         scrpriv->win_height);
    } else {
        EPHYR_LOG_ERROR("failed to get host screen\n");
#ifdef XF86DRI
        /*
         * We only receive expose events when the expose event
         * have be generated for a drawable that is a host X
         * window managed by Xephyr. Host X windows managed by
         * Xephyr exists for instance when Xephyr is asked to
         * create a GL drawable in a DRI environment.
         */
        ephyrExposePairedWindow(expose->window);
#endif                          /* XF86DRI */
    }
}

static void
ephyrProcessMouseMotion(xcb_generic_event_t *xev)
{
    xcb_motion_notify_event_t *motion = (xcb_motion_notify_event_t *)xev;
    KdScreenInfo *screen = screen_from_window(motion->event);

    if (!ephyrMouse ||
        !((EphyrPointerPrivate *) ephyrMouse->driverPrivate)->enabled) {
        EPHYR_LOG("skipping mouse motion:%d\n", screen->pScreen->myNum);
        return;
    }

    if (ephyrCursorScreen != screen->pScreen) {
        EPHYR_LOG("warping mouse cursor. "
                  "cur_screen:%d, motion_screen:%d\n",
                  ephyrCursorScreen->myNum, screen->pScreen->myNum);
        ephyrWarpCursor(inputInfo.pointer, screen->pScreen,
                        motion->event_x, motion->event_y);
    }
    else {
        int x = 0, y = 0;

#ifdef XF86DRI
        EphyrWindowPair *pair = NULL;
#endif
        EPHYR_LOG("enqueuing mouse motion:%d\n", screen->pScreen->myNum);
        x = motion->event_x;
        y = motion->event_y;
        EPHYR_LOG("initial (x,y):(%d,%d)\n", x, y);
#ifdef XF86DRI
        EPHYR_LOG("is this window peered by a gl drawable ?\n");
        if (findWindowPairFromRemote(motion->event, &pair)) {
            EPHYR_LOG("yes, it is peered\n");
            x += pair->local->drawable.x;
            y += pair->local->drawable.y;
        }
        else {
            EPHYR_LOG("no, it is not peered\n");
        }
        EPHYR_LOG("final (x,y):(%d,%d)\n", x, y);
#endif

        /* convert coords into desktop-wide coordinates.
         * fill_pointer_events will convert that back to
         * per-screen coordinates where needed */
        x += screen->pScreen->x;
        y += screen->pScreen->y;

        KdEnqueuePointerEvent(ephyrMouse, mouseState | KD_POINTER_DESKTOP, x, y, 0);
    }
}

static void
ephyrProcessButtonPress(xcb_generic_event_t *xev)
{
    xcb_button_press_event_t *button = (xcb_button_press_event_t *)xev;

    if (!ephyrMouse ||
        !((EphyrPointerPrivate *) ephyrMouse->driverPrivate)->enabled) {
        EPHYR_LOG("skipping mouse press:%d\n", screen_from_window(button->event)->pScreen->myNum);
        return;
    }

    ephyrUpdateModifierState(button->state);
    /* This is a bit hacky. will break for button 5 ( defined as 0x10 )
     * Check KD_BUTTON defines in kdrive.h
     */
    mouseState |= 1 << (button->detail - 1);

    EPHYR_LOG("enqueuing mouse press:%d\n", screen_from_window(button->event)->pScreen->myNum);
    KdEnqueuePointerEvent(ephyrMouse, mouseState | KD_MOUSE_DELTA, 0, 0, 0);
}

static void
ephyrProcessButtonRelease(xcb_generic_event_t *xev)
{
    xcb_button_press_event_t *button = (xcb_button_press_event_t *)xev;

    if (!ephyrMouse ||
        !((EphyrPointerPrivate *) ephyrMouse->driverPrivate)->enabled) {
        return;
    }

    ephyrUpdateModifierState(button->state);
    mouseState &= ~(1 << (button->detail - 1));

    EPHYR_LOG("enqueuing mouse release:%d\n", screen_from_window(button->event)->pScreen->myNum);
    KdEnqueuePointerEvent(ephyrMouse, mouseState | KD_MOUSE_DELTA, 0, 0, 0);
}

/* Xephyr wants ctrl+shift to grab the window, but that conflicts with
   ctrl+alt+shift key combos. Remember the modifier state on key presses and
   releases, if mod1 is pressed, we need ctrl, shift and mod1 released
   before we allow a shift-ctrl grab activation.

   note: a key event contains the mask _before_ the current key takes
   effect, so mod1_was_down will be reset on the first key press after all
   three were released, not on the last release. That'd require some more
   effort.
 */
static int
ephyrUpdateGrabModifierState(int state)
{
    static int mod1_was_down = 0;

    if ((state & (XCB_MOD_MASK_CONTROL|XCB_MOD_MASK_SHIFT|XCB_MOD_MASK_1)) == 0)
        mod1_was_down = 0;
    else if (state & XCB_MOD_MASK_1)
        mod1_was_down = 1;

    return mod1_was_down;
}

static void
ephyrProcessKeyPress(xcb_generic_event_t *xev)
{
    xcb_key_press_event_t *key = (xcb_key_press_event_t *)xev;

    if (!ephyrKbd ||
        !((EphyrKbdPrivate *) ephyrKbd->driverPrivate)->enabled) {
        return;
    }

    ephyrUpdateGrabModifierState(key->state);
    ephyrUpdateModifierState(key->state);
    KdEnqueueKeyboardEvent(ephyrKbd, key->detail, FALSE);
}

static void
ephyrProcessKeyRelease(xcb_generic_event_t *xev)
{
    xcb_connection_t *conn = hostx_get_xcbconn();
    xcb_key_release_event_t *key = (xcb_key_release_event_t *)xev;
    static xcb_key_symbols_t *keysyms;
    static int grabbed_screen = -1;
    int mod1_down = ephyrUpdateGrabModifierState(key->state);

    if (!keysyms)
        keysyms = xcb_key_symbols_alloc(conn);

    if (!EphyrWantNoHostGrab &&
        (((xcb_key_symbols_get_keysym(keysyms, key->detail, 0) == XK_Shift_L
          || xcb_key_symbols_get_keysym(keysyms, key->detail, 0) == XK_Shift_R)
         && (key->state & XCB_MOD_MASK_CONTROL)) ||
        ((xcb_key_symbols_get_keysym(keysyms, key->detail, 0) == XK_Control_L
          || xcb_key_symbols_get_keysym(keysyms, key->detail, 0) == XK_Control_R)
         && (key->state & XCB_MOD_MASK_SHIFT)))) {
        KdScreenInfo *screen = screen_from_window(key->event);
        EphyrScrPriv *scrpriv = screen->driver;

        if (grabbed_screen != -1) {
            xcb_ungrab_keyboard(conn, XCB_TIME_CURRENT_TIME);
            xcb_ungrab_pointer(conn, XCB_TIME_CURRENT_TIME);
            grabbed_screen = -1;
            hostx_set_win_title(screen,
                                "(ctrl+shift grabs mouse and keyboard)");
        }
        else if (!mod1_down) {
            /* Attempt grab */
            xcb_grab_keyboard_cookie_t kbgrabc =
                xcb_grab_keyboard(conn,
                                  TRUE,
                                  scrpriv->win,
                                  XCB_TIME_CURRENT_TIME,
                                  XCB_GRAB_MODE_ASYNC,
                                  XCB_GRAB_MODE_ASYNC);
            xcb_grab_keyboard_reply_t *kbgrabr;
            xcb_grab_pointer_cookie_t pgrabc =
                xcb_grab_pointer(conn,
                                 TRUE,
                                 scrpriv->win,
                                 0,
                                 XCB_GRAB_MODE_ASYNC,
                                 XCB_GRAB_MODE_ASYNC,
                                 scrpriv->win,
                                 XCB_NONE,
                                 XCB_TIME_CURRENT_TIME);
            xcb_grab_pointer_reply_t *pgrabr;
            kbgrabr = xcb_grab_keyboard_reply(conn, kbgrabc, NULL);
            if (!kbgrabr || kbgrabr->status != XCB_GRAB_STATUS_SUCCESS) {
                xcb_discard_reply(conn, pgrabc.sequence);
                xcb_ungrab_pointer(conn, XCB_TIME_CURRENT_TIME);
            } else {
                pgrabr = xcb_grab_pointer_reply(conn, pgrabc, NULL);
                if (!pgrabr || pgrabr->status != XCB_GRAB_STATUS_SUCCESS)
                    {
                        xcb_ungrab_keyboard(conn,
                                            XCB_TIME_CURRENT_TIME);
                    } else {
                    grabbed_screen = scrpriv->mynum;
                    hostx_set_win_title
                        (screen,
                         "(ctrl+shift releases mouse and keyboard)");
                }
            }
        }
    }

    if (!ephyrKbd ||
        !((EphyrKbdPrivate *) ephyrKbd->driverPrivate)->enabled) {
        return;
    }

    /* Still send the release event even if above has happened server
     * will get confused with just an up event.  Maybe it would be
     * better to just block shift+ctrls getting to kdrive all
     * together.
     */
    ephyrUpdateModifierState(key->state);
    KdEnqueueKeyboardEvent(ephyrKbd, key->detail, TRUE);
}

static void
ephyrProcessConfigureNotify(xcb_generic_event_t *xev)
{
    xcb_configure_notify_event_t *configure =
        (xcb_configure_notify_event_t *)xev;
    KdScreenInfo *screen = screen_from_window(configure->window);
    EphyrScrPriv *scrpriv = screen->driver;

    if (!scrpriv ||
        (scrpriv->win_pre_existing == None && !EphyrWantResize)) {
        return;
    }

#ifdef RANDR
    ephyrResizeScreen(screen->pScreen, configure->width, configure->height);
#endif /* RANDR */
}

void
ephyrPoll(void)
{
    xcb_connection_t *conn = hostx_get_xcbconn();

    while (TRUE) {
        xcb_generic_event_t *xev = xcb_poll_for_event(conn);
        if (!xev) {
            /* If our XCB connection has died (for example, our window was
             * closed), exit now.
             */
            if (xcb_connection_has_error(conn)) {
                CloseWellKnownConnections();
                OsCleanup(1);
                exit(1);
            }

            break;
        }

        switch (xev->response_type & 0x7f) {
        case 0:
            ephyrProcessErrorEvent(xev);
            break;

        case XCB_EXPOSE:
            ephyrProcessExpose(xev);
            break;

        case XCB_MOTION_NOTIFY:
            ephyrProcessMouseMotion(xev);
            break;

        case XCB_KEY_PRESS:
            ephyrProcessKeyPress(xev);
            break;

        case XCB_KEY_RELEASE:
            ephyrProcessKeyRelease(xev);
            break;

        case XCB_BUTTON_PRESS:
            ephyrProcessButtonPress(xev);
            break;

        case XCB_BUTTON_RELEASE:
            ephyrProcessButtonRelease(xev);
            break;

        case XCB_CONFIGURE_NOTIFY:
            ephyrProcessConfigureNotify(xev);
            break;
        }

        if (ephyr_glamor)
            ephyr_glamor_process_event(xev);

        free(xev);
    }
}

void
ephyrCardFini(KdCardInfo * card)
{
    EphyrPriv *priv = card->driver;

    free(priv);
}

void
ephyrGetColors(ScreenPtr pScreen, int n, xColorItem * pdefs)
{
    /* XXX Not sure if this is right */

    EPHYR_LOG("mark");

    while (n--) {
        pdefs->red = 0;
        pdefs->green = 0;
        pdefs->blue = 0;
        pdefs++;
    }

}

void
ephyrPutColors(ScreenPtr pScreen, int n, xColorItem * pdefs)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    EphyrScrPriv *scrpriv = screen->driver;
    int min, max, p;

    /* XXX Not sure if this is right */

    min = 256;
    max = 0;

    while (n--) {
        p = pdefs->pixel;
        if (p < min)
            min = p;
        if (p > max)
            max = p;

        hostx_set_cmap_entry(pScreen, p,
                             pdefs->red >> 8,
                             pdefs->green >> 8, pdefs->blue >> 8);
        pdefs++;
    }
    if (scrpriv->pDamage) {
        BoxRec box;
        RegionRec region;

        box.x1 = 0;
        box.y1 = 0;
        box.x2 = pScreen->width;
        box.y2 = pScreen->height;
        RegionInit(&region, &box, 1);
        DamageReportDamage(scrpriv->pDamage, &region);
        RegionUninit(&region);
    }
}

/* Mouse calls */

static Status
MouseInit(KdPointerInfo * pi)
{
    pi->driverPrivate = (EphyrPointerPrivate *)
        calloc(sizeof(EphyrPointerPrivate), 1);
    ((EphyrPointerPrivate *) pi->driverPrivate)->enabled = FALSE;
    pi->nAxes = 3;
    pi->nButtons = 32;
    free(pi->name);
    pi->name = strdup("Xephyr virtual mouse");

    /*
     * Must transform pointer coords since the pointer position
     * relative to the Xephyr window is controlled by the host server and
     * remains constant regardless of any rotation applied to the Xephyr screen.
     */
    pi->transformCoordinates = TRUE;

    ephyrMouse = pi;
    return Success;
}

static Status
MouseEnable(KdPointerInfo * pi)
{
    ((EphyrPointerPrivate *) pi->driverPrivate)->enabled = TRUE;
    return Success;
}

static void
MouseDisable(KdPointerInfo * pi)
{
    ((EphyrPointerPrivate *) pi->driverPrivate)->enabled = FALSE;
    return;
}

static void
MouseFini(KdPointerInfo * pi)
{
    ephyrMouse = NULL;
    return;
}

KdPointerDriver EphyrMouseDriver = {
    "ephyr",
    MouseInit,
    MouseEnable,
    MouseDisable,
    MouseFini,
    NULL,
};

/* Keyboard */

static Status
EphyrKeyboardInit(KdKeyboardInfo * ki)
{
    ki->driverPrivate = (EphyrKbdPrivate *)
        calloc(sizeof(EphyrKbdPrivate), 1);
    hostx_load_keymap();
    if (!ephyrKeySyms.minKeyCode) {
        ErrorF("Couldn't load keymap from host\n");
        return BadAlloc;
    }
    ki->minScanCode = ephyrKeySyms.minKeyCode;
    ki->maxScanCode = ephyrKeySyms.maxKeyCode;
    free(ki->name);
    ki->name = strdup("Xephyr virtual keyboard");
    ephyrKbd = ki;
    return Success;
}

static Status
EphyrKeyboardEnable(KdKeyboardInfo * ki)
{
    ((EphyrKbdPrivate *) ki->driverPrivate)->enabled = TRUE;

    return Success;
}

static void
EphyrKeyboardDisable(KdKeyboardInfo * ki)
{
    ((EphyrKbdPrivate *) ki->driverPrivate)->enabled = FALSE;
}

static void
EphyrKeyboardFini(KdKeyboardInfo * ki)
{
    ephyrKbd = NULL;
    return;
}

static void
EphyrKeyboardLeds(KdKeyboardInfo * ki, int leds)
{
}

static void
EphyrKeyboardBell(KdKeyboardInfo * ki, int volume, int frequency, int duration)
{
}

KdKeyboardDriver EphyrKeyboardDriver = {
    "ephyr",
    EphyrKeyboardInit,
    EphyrKeyboardEnable,
    EphyrKeyboardLeds,
    EphyrKeyboardBell,
    EphyrKeyboardDisable,
    EphyrKeyboardFini,
    NULL,
};
@


1.13
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a52 1
extern int KdTsPhyScreen;
a72 10
host_has_extension(xcb_extension_t *extension)
{
    const xcb_query_extension_reply_t *rep;

    rep = xcb_get_extension_data(hostx_get_xcbconn(), extension);

    return rep && rep->present;
}

Bool
d662 1
a662 1
    if (!ephyrNoDRI && !host_has_extension(&xcb_xf86dri_id)) {
d969 2
a970 2
                  "cur_screen%d, motion_screen:%d\n",
                  ephyrCursorScreen, screen->pScreen->myNum);
@


1.12
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d4 2
a5 2
 * 
 * Copyright Â© 2004 Nokia 
d71 1
d115 1
d119 1
a119 1
    if (hostx_want_screen_size(screen, &width, &height)
d123 2
d249 2
a250 1
        hostx_screen_init(screen, screen->width, screen->height, buffer_height,
d316 2
a317 2
     * much faster efficiently updating via tranforming 
     * pBuf->pDamage  regions     
d538 1
a538 1
        /* Without shadow fb ( non rotated ) we need 
d653 5
a657 1
    hostx_set_win_title(screen, "(ctrl+shift grabs mouse and keyboard)");
d662 3
a664 1
        if (!ephyrInitVideo(pScreen)) {
d690 1
a690 1
    /* FIXME: Calling this even if not using shadow.  
d770 7
a776 1
/*  
d809 5
a813 1
                    if (key_is_down(pDev, key, KEY_PROCESSED))
d827 2
d892 1
a892 1
    screen->WindowExposures(pair->local, &reg, NullRegion);
d1106 2
a1107 1
    if (((xcb_key_symbols_get_keysym(keysyms, key->detail, 0) == XK_Shift_L
d1112 1
a1112 1
         && (key->state & XCB_MOD_MASK_SHIFT))) {
d1301 1
a1301 1
        hostx_set_cmap_entry(p,
@


1.11
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d46 5
d54 1
d335 13
a347 9
        nbox = RegionNumRects(pRegion);
        pbox = RegionRects(pRegion);

        while (nbox--) {
            hostx_paint_rect(screen,
                             pbox->x1, pbox->y1,
                             pbox->x1, pbox->y1,
                             pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
            pbox++;
d354 1
a354 1
ephyrInternalDamageBlockHandler(pointer data, OSTimePtr pTimeout, pointer pRead)
d362 1
a362 1
ephyrInternalDamageWakeupHandler(pointer data, int i, pointer LastSelectMask)
d381 1
a381 1
                                        (pointer) pScreen))
d402 1
a402 1
                                 (pointer) pScreen);
d675 1
d693 6
d713 5
a717 1
    else
d719 1
d1033 23
d1066 1
d1078 1
d1099 1
a1099 1
        else {
d1226 3
d1260 3
d1281 12
@


1.10
log
@Uodate to xserver 1.14.2. Tested by krw@@, shadchin@@, todd@@
@
text
@d29 4
d40 1
d64 11
d105 1
a105 1
ephyrScreenInitialize(KdScreenInfo * screen, EphyrScrPriv * scrpriv)
d107 1
d124 1
a124 1
            hostx_set_server_depth(screen, screen->fb.depth);
a186 21
Bool
ephyrScreenInit(KdScreenInfo * screen)
{
    EphyrScrPriv *scrpriv;

    scrpriv = calloc(1, sizeof(EphyrScrPriv));

    if (!scrpriv)
        return FALSE;

    screen->driver = scrpriv;

    if (!ephyrScreenInitialize(screen, scrpriv)) {
        screen->driver = 0;
        free(scrpriv);
        return FALSE;
    }

    return TRUE;
}

a386 1
    PixmapPtr pPixmap = NULL;
a387 2
    pPixmap = (*pScreen->GetScreenPixmap) (pScreen);
    DamageUnregister(&pPixmap->drawable, scrpriv->pDamage);
d652 1
a652 1
    if (!ephyrNoDRI && !hostx_has_dri()) {
a734 2
    free(screen->driver);
    screen->driver = NULL;
d800 1
a800 1
int ephyrCurScreen;             /*current event screen */
d806 1
a806 1
    ephyrCurScreen = pScreen->myNum;
a815 2
    NULL,
    NULL
d852 71
a922 2
void
ephyrPoll(void)
d924 8
a931 1
    EphyrHostXEvent ev;
d933 9
a941 23
    while (hostx_get_event(&ev)) {
        switch (ev.type) {
        case EPHYR_EV_MOUSE_MOTION:
            if (!ephyrMouse ||
                !((EphyrPointerPrivate *) ephyrMouse->driverPrivate)->enabled) {
                EPHYR_LOG("skipping mouse motion:%d\n", ephyrCurScreen);
                continue;
            }
            {
                if (ev.data.mouse_motion.screen >= 0
                    && (ephyrCurScreen != ev.data.mouse_motion.screen)) {
                    EPHYR_LOG("warping mouse cursor. "
                              "cur_screen%d, motion_screen:%d\n",
                              ephyrCurScreen, ev.data.mouse_motion.screen);
                    if (ev.data.mouse_motion.screen >= 0) {
                        ephyrWarpCursor
                            (inputInfo.pointer,
                             screenInfo.screens[ev.data.mouse_motion.screen],
                             ev.data.mouse_motion.x, ev.data.mouse_motion.y);
                    }
                }
                else {
                    int x = 0, y = 0;
d944 1
a944 1
                    EphyrWindowPair *pair = NULL;
d946 4
a949 4
                    EPHYR_LOG("enqueuing mouse motion:%d\n", ephyrCurScreen);
                    x = ev.data.mouse_motion.x;
                    y = ev.data.mouse_motion.y;
                    EPHYR_LOG("initial (x,y):(%d,%d)\n", x, y);
d951 10
a960 11
                    EPHYR_LOG("is this window peered by a gl drawable ?\n");
                    if (findWindowPairFromRemote(ev.data.mouse_motion.window,
                                                 &pair)) {
                        EPHYR_LOG("yes, it is peered\n");
                        x += pair->local->drawable.x;
                        y += pair->local->drawable.y;
                    }
                    else {
                        EPHYR_LOG("no, it is not peered\n");
                    }
                    EPHYR_LOG("final (x,y):(%d,%d)\n", x, y);
d962 126
a1087 1
                    KdEnqueuePointerEvent(ephyrMouse, mouseState, x, y, 0);
d1090 52
d1143 1
d1145 7
a1151 11
        case EPHYR_EV_MOUSE_PRESS:
            if (!ephyrMouse ||
                !((EphyrPointerPrivate *) ephyrMouse->driverPrivate)->enabled) {
                EPHYR_LOG("skipping mouse press:%d\n", ephyrCurScreen);
                continue;
            }
            EPHYR_LOG("enqueuing mouse press:%d\n", ephyrCurScreen);
            ephyrUpdateModifierState(ev.key_state);
            mouseState |= ev.data.mouse_down.button_num;
            KdEnqueuePointerEvent(ephyrMouse, mouseState | KD_MOUSE_DELTA, 0, 0,
                                  0);
d1154 2
a1155 9
        case EPHYR_EV_MOUSE_RELEASE:
            if (!ephyrMouse ||
                !((EphyrPointerPrivate *) ephyrMouse->driverPrivate)->enabled)
                continue;
            ephyrUpdateModifierState(ev.key_state);
            mouseState &= ~ev.data.mouse_up.button_num;
            EPHYR_LOG("enqueuing mouse release:%d\n", ephyrCurScreen);
            KdEnqueuePointerEvent(ephyrMouse, mouseState | KD_MOUSE_DELTA, 0, 0,
                                  0);
d1158 2
a1159 6
        case EPHYR_EV_KEY_PRESS:
            if (!ephyrKbd ||
                !((EphyrKbdPrivate *) ephyrKbd->driverPrivate)->enabled)
                continue;
            ephyrUpdateModifierState(ev.key_state);
            KdEnqueueKeyboardEvent(ephyrKbd, ev.data.key_down.scancode, FALSE);
d1162 2
a1163 6
        case EPHYR_EV_KEY_RELEASE:
            if (!ephyrKbd ||
                !((EphyrKbdPrivate *) ephyrKbd->driverPrivate)->enabled)
                continue;
            ephyrUpdateModifierState(ev.key_state);
            KdEnqueueKeyboardEvent(ephyrKbd, ev.data.key_up.scancode, TRUE);
d1166 2
a1167 9
#ifdef XF86DRI
        case EPHYR_EV_EXPOSE:
            /*
             * We only receive expose events when the expose event have
             * be generated for a drawable that is a host X window managed
             * by Xephyr. Host X windows managed by Xephyr exists for instance
             * when Xephyr is asked to create a GL drawable in a DRI environment.
             */
            ephyrExposePairedWindow(ev.data.expose.window);
a1168 1
#endif                          /* XF86DRI */
d1170 2
a1171 5
#ifdef RANDR
        case EPHYR_EV_CONFIGURE:
            ephyrResizeScreen(screenInfo.screens[ev.data.configure.screen],
                              ev.data.configure.width,
                              ev.data.configure.height);
a1172 1
#endif /* RANDR */
d1174 2
a1175 1
        default:
d1178 2
d1293 1
a1293 1
    if (!ephyrKeySyms.map) {
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a239 3
    priv->bytes_per_line =
        ((screen->width * screen->fb.bitsPerPixel + 31) >> 5) << 2;

d243 2
a244 1
        hostx_screen_init(screen, screen->width, screen->height, buffer_height);
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a44 4
#ifdef GLXEXT
extern Bool noGlxVisualInit;
#endif

d418 16
a433 17
        {
        1600, 1200}, {
        1400, 1050}, {
        1280, 960}, {
        1280, 1024}, {
        1152, 864}, {
        1024, 768}, {
        832, 624}, {
        800, 600}, {
        720, 400}, {
        480, 640}, {
        640, 480}, {
        640, 400}, {
        320, 240}, {
        240, 320}, {
        160, 160}, {
        0, 0}
d560 2
d594 37
d661 1
a661 1
        if (!ephyrNoDRI && !hostx_has_dri()) {
a663 3
#ifdef GLXEXT
        noGlxVisualInit = FALSE;
#endif
a670 6
#ifdef GLXEXT
    if (ephyrNoDRI) {
        noGlxVisualInit = FALSE;
    }
#endif

a799 20
static void
ephyrBlockSigio(void)
{
    sigset_t set;

    sigemptyset(&set);
    sigaddset(&set, SIGIO);
    sigprocmask(SIG_BLOCK, &set, 0);
}

static void
ephyrUnblockSigio(void)
{
    sigset_t set;

    sigemptyset(&set);
    sigaddset(&set, SIGIO);
    sigprocmask(SIG_UNBLOCK, &set, 0);
}

d816 1
a816 1
    ephyrBlockSigio();
d820 1
a820 1
    ephyrUnblockSigio();
d970 8
@


1.7
log
@Update to xserver 1.11.2
@
text
@d39 1
a39 1
#endif /* XF86DRI */
d44 1
d52 2
a53 2
Bool ephyrNoDRI=FALSE ;
Bool ephyrNoXV=FALSE ;
d59 1
a59 1
    Bool    enabled;
d62 1
a62 2
Bool   EphyrWantGrayScale = 0;

d65 1
a65 1
ephyrInitialize (KdCardInfo *card, EphyrPriv *priv)
d67 5
a71 5
  OsSignal(SIGUSR1, hostx_handle_signal);
  
  priv->base = 0;
  priv->bytes_per_line = 0;
  return TRUE;
d75 1
a75 1
ephyrCardInit (KdCardInfo *card)
d77 13
a89 14
  EphyrPriv	*priv;
  
  priv = (EphyrPriv *) malloc(sizeof (EphyrPriv));
  if (!priv)
    return FALSE;
  
  if (!ephyrInitialize (card, priv))
    {
      free(priv);
      return FALSE;
    }
  card->driver = priv;
  
  return TRUE;
d93 1
a93 1
ephyrScreenInitialize (KdScreenInfo *screen, EphyrScrPriv *scrpriv)
d95 71
a165 82
  int width = 640, height = 480; 
  CARD32 redMask, greenMask, blueMask;
  
  if (hostx_want_screen_size(screen, &width, &height)
      || !screen->width || !screen->height)
    {
      screen->width = width;
      screen->height = height;
    }

  if (EphyrWantGrayScale)
    screen->fb.depth = 8;

  if (screen->fb.depth && screen->fb.depth != hostx_get_depth())
    {
      if (screen->fb.depth < hostx_get_depth()
	  && (screen->fb.depth == 24 || screen->fb.depth == 16
	      || screen->fb.depth == 8))
	{
	  hostx_set_server_depth(screen, screen->fb.depth);
	}
      else
	ErrorF("\nXephyr: requested screen depth not supported, setting to match hosts.\n");
    }
  
  screen->fb.depth = hostx_get_server_depth(screen);
  screen->rate = 72;
  
  if (screen->fb.depth <= 8)
    {
      if (EphyrWantGrayScale)
	screen->fb.visuals = ((1 << StaticGray) | (1 << GrayScale));
      else
	screen->fb.visuals = ((1 << StaticGray) |
			      (1 << GrayScale) |
			      (1 << StaticColor) |
			      (1 << PseudoColor) |
			      (1 << TrueColor) |
			      (1 << DirectColor));
      
      screen->fb.redMask   = 0x00;
      screen->fb.greenMask = 0x00;
      screen->fb.blueMask  = 0x00;
      screen->fb.depth        = 8;
      screen->fb.bitsPerPixel = 8;
    }
  else 
    {
      screen->fb.visuals = (1 << TrueColor);
      
      if (screen->fb.depth <= 15)
	{
	  screen->fb.depth = 15;
	  screen->fb.bitsPerPixel = 16;
	}
      else if (screen->fb.depth <= 16)
	{
	  screen->fb.depth = 16;
	  screen->fb.bitsPerPixel = 16;
	}
      else if (screen->fb.depth <= 24)
	{
	  screen->fb.depth = 24;
	  screen->fb.bitsPerPixel = 32;
	}
      else if (screen->fb.depth <= 30)
	{
	  screen->fb.depth = 30;
	  screen->fb.bitsPerPixel = 32;
	}
      else
	{
	  ErrorF("\nXephyr: Unsupported screen depth %d\n",
	         screen->fb.depth);
	  return FALSE;
	}

      hostx_get_visual_masks (screen, &redMask, &greenMask, &blueMask);

      screen->fb.redMask = (Pixel) redMask;
      screen->fb.greenMask = (Pixel) greenMask;
      screen->fb.blueMask = (Pixel) blueMask;
a167 2
  
  scrpriv->randr = screen->randr;
d169 3
a171 1
  return ephyrMapFramebuffer (screen);
d175 1
a175 1
ephyrScreenInit (KdScreenInfo *screen)
d177 8
a184 3
  EphyrScrPriv *scrpriv;
  
  scrpriv = calloc(1, sizeof (EphyrScrPriv));
d186 8
a193 2
  if (!scrpriv)
    return FALSE;
d195 7
a201 1
  screen->driver = scrpriv;
d203 2
a204 23
  if (!ephyrScreenInitialize (screen, scrpriv))
    {
      screen->driver = 0;
      free(scrpriv);
      return FALSE;
    }

  return TRUE;
}
    
void*
ephyrWindowLinear (ScreenPtr	pScreen,
		   CARD32	row,
		   CARD32	offset,
		   int		mode,
		   CARD32	*size,
		   void		*closure)
{
  KdScreenPriv(pScreen);
  EphyrPriv	    *priv = pScreenPriv->card->driver;
  
  if (!pScreenPriv->enabled)
    return 0;
d206 2
a207 2
  *size = priv->bytes_per_line;
  return priv->base + row * priv->bytes_per_line + offset;
d215 1
a215 1
ephyrBufferHeight(KdScreenInfo *screen)
d218 1
d220 1
a220 1
	buffer_height = screen->height;
d222 1
a222 1
	buffer_height = 3 * screen->height;
a225 1

d227 1
a227 1
ephyrMapFramebuffer (KdScreenInfo *screen)
d229 38
a266 38
  EphyrScrPriv  *scrpriv = screen->driver;
  EphyrPriv	  *priv    = screen->card->driver;
  KdPointerMatrix m;
  int buffer_height;
  
  EPHYR_LOG("screen->width: %d, screen->height: %d index=%d",
	     screen->width, screen->height, screen->mynum);
  
  /*
   * Use the rotation last applied to ourselves (in the Xephyr case the fb
   * coordinate system moves independently of the pointer coordiante system).
   */
  KdComputePointerMatrix (&m, ephyrRandr, screen->width, screen->height);
  KdSetPointerMatrix (&m);
  
  priv->bytes_per_line = ((screen->width * screen->fb.bitsPerPixel + 31) >> 5) << 2;

  buffer_height = ephyrBufferHeight(screen);

  priv->base = hostx_screen_init (screen, screen->width, screen->height, buffer_height);

  if ((scrpriv->randr & RR_Rotate_0) && !(scrpriv->randr & RR_Reflect_All))
    {
      scrpriv->shadow = FALSE;
      
      screen->fb.byteStride = priv->bytes_per_line;
      screen->fb.pixelStride = screen->width;
      screen->fb.frameBuffer = (CARD8 *) (priv->base);
    }
  else
    {
      /* Rotated/Reflected so we need to use shadow fb */
      scrpriv->shadow = TRUE;
      
      EPHYR_LOG("allocing shadow");
      
      KdShadowFbAlloc (screen,
		       scrpriv->randr & (RR_Rotate_90|RR_Rotate_270));
d268 2
a269 2
  
  return TRUE;
d273 1
a273 1
ephyrSetScreenSizes (ScreenPtr pScreen)
d275 15
a289 17
  KdScreenPriv(pScreen);
  KdScreenInfo	*screen = pScreenPriv->screen;
  EphyrScrPriv	*scrpriv = screen->driver;
  
  if (scrpriv->randr & (RR_Rotate_0|RR_Rotate_180))
    {
      pScreen->width = screen->width;
      pScreen->height = screen->height;
      pScreen->mmWidth = screen->width_mm;
      pScreen->mmHeight = screen->height_mm;
    }
  else 
    {
      pScreen->width = screen->height;
      pScreen->height = screen->width;
      pScreen->mmWidth = screen->height_mm;
      pScreen->mmHeight = screen->width_mm;
d294 1
a294 1
ephyrUnmapFramebuffer (KdScreenInfo *screen)
d296 8
a303 24
  EphyrScrPriv  *scrpriv = screen->driver;
  
  if (scrpriv->shadow)
    KdShadowFbFree (screen);
  
  /* Note, priv->base will get freed when XImage recreated */
  
  return TRUE;
}

void 
ephyrShadowUpdate (ScreenPtr pScreen, shadowBufPtr pBuf)
{
  KdScreenPriv(pScreen);
  KdScreenInfo *screen = pScreenPriv->screen;
  
  EPHYR_LOG("slow paint");
  
  /* FIXME: Slow Rotated/Reflected updates could be much
   * much faster efficiently updating via tranforming 
   * pBuf->pDamage  regions     
  */
  shadowUpdateRotatePacked(pScreen, pBuf);
  hostx_paint_rect(screen, 0,0,0,0, screen->width, screen->height);
d306 2
a307 2
static void
ephyrInternalDamageRedisplay (ScreenPtr pScreen)
d309 2
a310 4
  KdScreenPriv(pScreen);
  KdScreenInfo	*screen = pScreenPriv->screen;
  EphyrScrPriv	*scrpriv = screen->driver;
  RegionPtr	 pRegion;
d312 1
a312 2
  if (!scrpriv || !scrpriv->pDamage)
    return;
d314 7
a320 1
  pRegion = DamageRegion (scrpriv->pDamage);
d322 26
a347 16
  if (RegionNotEmpty(pRegion))
    {
      int           nbox;
      BoxPtr        pbox;

      nbox = RegionNumRects (pRegion);
      pbox = RegionRects (pRegion);

      while (nbox--)
        {
          hostx_paint_rect(screen,
                           pbox->x1, pbox->y1,
                           pbox->x1, pbox->y1,
                           pbox->x2 - pbox->x1,
                           pbox->y2 - pbox->y1);
          pbox++;
d349 1
a349 1
      DamageEmpty (scrpriv->pDamage);
d354 5
a358 7
ephyrInternalDamageBlockHandler (pointer   data,
				 OSTimePtr pTimeout,
				 pointer   pRead)
{
  ScreenPtr pScreen = (ScreenPtr) data;
  
  ephyrInternalDamageRedisplay (pScreen);
d362 1
a362 1
ephyrInternalDamageWakeupHandler (pointer data, int i, pointer LastSelectMask)
d364 1
a364 1
  /* FIXME: Not needed ? */
d368 1
a368 1
ephyrSetInternalDamage (ScreenPtr pScreen)
d370 19
a388 22
  KdScreenPriv(pScreen);
  KdScreenInfo	*screen = pScreenPriv->screen;
  EphyrScrPriv	*scrpriv = screen->driver;
  PixmapPtr      pPixmap = NULL;
  
  scrpriv->pDamage = DamageCreate ((DamageReportFunc) 0,
				   (DamageDestroyFunc) 0,
				   DamageReportNone,
				   TRUE,
				   pScreen,
				   pScreen);
  
  if (!RegisterBlockAndWakeupHandlers (ephyrInternalDamageBlockHandler,
				       ephyrInternalDamageWakeupHandler,
				       (pointer) pScreen))
    return FALSE;
  
  pPixmap = (*pScreen->GetScreenPixmap) (pScreen);
  
  DamageRegister (&pPixmap->drawable, scrpriv->pDamage);
      
  return TRUE;
d392 1
a392 1
ephyrUnsetInternalDamage (ScreenPtr pScreen)
d394 12
a405 12
  KdScreenPriv(pScreen);
  KdScreenInfo	*screen = pScreenPriv->screen;
  EphyrScrPriv	*scrpriv = screen->driver;
  PixmapPtr      pPixmap = NULL;
  
  pPixmap = (*pScreen->GetScreenPixmap) (pScreen);
  DamageUnregister (&pPixmap->drawable, scrpriv->pDamage);
  DamageDestroy (scrpriv->pDamage);
  
  RemoveBlockAndWakeupHandlers (ephyrInternalDamageBlockHandler,
				ephyrInternalDamageWakeupHandler,
				(pointer) pScreen);
d410 1
a410 1
ephyrRandRGetInfo (ScreenPtr pScreen, Rotation *rotations)
d412 27
a438 25
  KdScreenPriv(pScreen);
  KdScreenInfo	    *screen = pScreenPriv->screen;
  EphyrScrPriv	    *scrpriv = screen->driver;
  RRScreenSizePtr	    pSize;
  Rotation		    randr;
  int			    n = 0;
 
  struct { int width, height; } sizes[] = 
    {
      { 1600, 1200 },
      { 1400, 1050 },
      { 1280, 960  },
      { 1280, 1024 },
      { 1152, 864 },
      { 1024, 768 },
      { 832, 624 },
      { 800, 600 },
      { 720, 400 },
      { 480, 640 },
      { 640, 480 },
      { 640, 400 },
      { 320, 240 },
      { 240, 320 },
      { 160, 160 }, 
      { 0, 0 }
d441 1
a441 1
  EPHYR_LOG("mark");
d443 1
a443 1
  *rotations = RR_Rotate_All|RR_Reflect_All;
d445 22
a466 26
  if (!hostx_want_preexisting_window (screen)
      && !hostx_want_fullscreen ()) /* only if no -parent switch */
    {
      while (sizes[n].width != 0 && sizes[n].height != 0)
	{
	  RRRegisterSize (pScreen,
			  sizes[n].width,
			  sizes[n].height, 
			  (sizes[n].width * screen->width_mm)/screen->width,
			  (sizes[n].height *screen->height_mm)/screen->height
			  );
	  n++;
	}
    }
  
  pSize = RRRegisterSize (pScreen,
			  screen->width,
			  screen->height, 
			  screen->width_mm,
			  screen->height_mm);
    
  randr = KdSubRotation (scrpriv->randr, screen->randr);
  
  RRSetCurrentConfig (pScreen, randr, 0, pSize);
    
  return TRUE;
d470 97
a566 105
ephyrRandRSetConfig (ScreenPtr		pScreen,
		     Rotation		randr,
		     int		rate,
		     RRScreenSizePtr	pSize)
{
  KdScreenPriv(pScreen);
  KdScreenInfo	*screen    = pScreenPriv->screen;
  EphyrScrPriv	*scrpriv   = screen->driver;
  Bool		wasEnabled = pScreenPriv->enabled;
  EphyrScrPriv	oldscr;
  int		oldwidth, oldheight, oldmmwidth, oldmmheight;
  Bool          oldshadow;
  int		newwidth, newheight;
  
  if (screen->randr & (RR_Rotate_0|RR_Rotate_180))
    {
      newwidth = pSize->width;
      newheight = pSize->height;
    }
  else
    {
      newwidth = pSize->height;
      newheight = pSize->width;
    }
  
  if (wasEnabled)
    KdDisableScreen (pScreen);

  oldscr = *scrpriv;
    
  oldwidth    = screen->width;
  oldheight   = screen->height;
  oldmmwidth  = pScreen->mmWidth;
  oldmmheight = pScreen->mmHeight;
  oldshadow   = scrpriv->shadow;
  
  /*
   * Set new configuration
   */
  
  /*
   * We need to store the rotation value for pointer coords transformation;
   * though initially the pointer and fb rotation are identical, when we map
   * the fb, the screen will be reinitialized and return into an unrotated
   * state (presumably the HW is taking care of the rotation of the fb), but the
   * pointer still needs to be transformed.
   */
  ephyrRandr = KdAddRotation (screen->randr, randr);
  scrpriv->randr = ephyrRandr;
  
  ephyrUnmapFramebuffer (screen); 
  
  screen->width  = newwidth;
  screen->height = newheight;
  
  if (!ephyrMapFramebuffer (screen))
    goto bail4;
  
  /* FIXME below should go in own call */
  
  if (oldshadow)
    KdShadowUnset (screen->pScreen);
  else
    ephyrUnsetInternalDamage(screen->pScreen);
  
  if (scrpriv->shadow)
    {
      if (!KdShadowSet (screen->pScreen, 
			scrpriv->randr, 
			ephyrShadowUpdate, 
			ephyrWindowLinear))
	goto bail4;
    }
  else
    {
      /* Without shadow fb ( non rotated ) we need 
       * to use damage to efficiently update display
       * via signal regions what to copy from 'fb'.
       */
      if (!ephyrSetInternalDamage(screen->pScreen))
	goto bail4;
    }
  
  ephyrSetScreenSizes (screen->pScreen);
  
  /*
   * Set frame buffer mapping
   */
  (*pScreen->ModifyPixmapHeader) (fbGetScreenPixmap (pScreen),
				  pScreen->width,
				  pScreen->height,
				  screen->fb.depth,
				  screen->fb.bitsPerPixel,
				  screen->fb.byteStride,
				  screen->fb.frameBuffer);
  
  /* set the subpixel order */
  
  KdSetSubpixelOrder (pScreen, scrpriv->randr);
  
  if (wasEnabled)
    KdEnableScreen (pScreen);
  
  return TRUE;
  
d568 14
a581 14
  EPHYR_LOG("bailed");
  
  ephyrUnmapFramebuffer (screen);
  *scrpriv = oldscr;
  (void) ephyrMapFramebuffer (screen);
  
  pScreen->width = oldwidth;
  pScreen->height = oldheight;
  pScreen->mmWidth = oldmmwidth;
  pScreen->mmHeight = oldmmheight;
  
  if (wasEnabled)
    KdEnableScreen (pScreen);
  return FALSE;
d585 1
a585 1
ephyrRandRInit (ScreenPtr pScreen)
d587 9
a595 9
  rrScrPrivPtr    pScrPriv;
  
  if (!RRScreenInit (pScreen))
    return FALSE;
  
  pScrPriv = rrGetScrPriv(pScreen);
  pScrPriv->rrGetInfo = ephyrRandRGetInfo;
  pScrPriv->rrSetConfig = ephyrRandRSetConfig;
  return TRUE;
d600 1
a600 1
ephyrCreateColormap (ColormapPtr pmap)
d602 1
a602 1
  return fbInitializeColormap (pmap);
d606 1
a606 1
ephyrInitScreen (ScreenPtr pScreen)
d608 2
a609 2
  KdScreenPriv(pScreen);
  KdScreenInfo	*screen    = pScreenPriv->screen;
d611 4
a614 4
  EPHYR_LOG ("pScreen->myNum:%d\n", pScreen->myNum) ;
  hostx_set_screen_number (screen, pScreen->myNum);
  hostx_set_win_title (screen, "(ctrl+shift grabs mouse and keyboard)") ;
  pScreen->CreateColormap = ephyrCreateColormap;
d617 8
a624 7
  if (!ephyrNoXV) {
      if (!ephyrInitVideo (pScreen)) {
          EPHYR_LOG_ERROR ("failed to initialize xvideo\n") ;
      } else {
          EPHYR_LOG ("initialized xvideo okay\n") ;
      }
  }
a625 1

d627 3
a629 3
  if (!ephyrNoDRI && !hostx_has_dri ()) {
      EPHYR_LOG ("host x does not support DRI. Disabling DRI forwarding\n") ;
      ephyrNoDRI = TRUE ;
d631 1
a631 1
      noGlxVisualInit = FALSE ;
d633 5
a637 5
  }
  if (!ephyrNoDRI) {
    ephyrDRIExtensionInit (pScreen) ;
    ephyrHijackGLXExtension () ;
  }
d641 3
a643 3
  if (ephyrNoDRI) {
      noGlxVisualInit = FALSE ;
  }
d646 1
a646 1
  return TRUE;
d650 1
a650 1
ephyrFinishInitScreen (ScreenPtr pScreen)
d652 5
a656 5
  /* FIXME: Calling this even if not using shadow.  
   * Seems harmless enough. But may be safer elsewhere.
   */
  if (!shadowSetup (pScreen))
    return FALSE;
d659 2
a660 2
  if (!ephyrRandRInit (pScreen))
    return FALSE;
d663 1
a663 1
  return TRUE;
d667 1
a667 1
ephyrCreateResources (ScreenPtr pScreen)
d669 13
a681 14
  KdScreenPriv(pScreen);
  KdScreenInfo	*screen    = pScreenPriv->screen;
  EphyrScrPriv	*scrpriv   = screen->driver;

  EPHYR_LOG("mark pScreen=%p mynum=%d shadow=%d",
            pScreen, pScreen->myNum, scrpriv->shadow);

  if (scrpriv->shadow) 
    return KdShadowSet (pScreen, 
			scrpriv->randr, 
			ephyrShadowUpdate, 
			ephyrWindowLinear);
  else
    return ephyrSetInternalDamage(pScreen); 
d685 1
a685 1
ephyrPreserve (KdCardInfo *card)
d690 1
a690 1
ephyrEnable (ScreenPtr pScreen)
d692 1
a692 1
  return TRUE;
d696 1
a696 1
ephyrDPMS (ScreenPtr pScreen, int mode)
d698 1
a698 1
  return TRUE;
d702 1
a702 1
ephyrDisable (ScreenPtr pScreen)
d707 1
a707 1
ephyrRestore (KdCardInfo *card)
d712 1
a712 1
ephyrScreenFini (KdScreenInfo *screen)
d714 2
a715 1
    EphyrScrPriv  *scrpriv = screen->driver;
d717 1
a717 1
        KdShadowFbFree (screen);
d731 32
a762 22
  DeviceIntPtr pDev = inputInfo.keyboard;
  KeyClassPtr keyc = pDev->key;
  int i;
  CARD8 mask;
  int xkb_state;
  
  if (!pDev)
      return;

  xkb_state = XkbStateFieldFromRec(&pDev->key->xkbInfo->state);
  state = state & 0xff;

  if (xkb_state == state)
    return;
      
  for (i = 0, mask = 1; i < 8; i++, mask <<= 1) {
    int key;

    /* Modifier is down, but shouldn't be
     */
    if ((xkb_state & mask) && !(state & mask)) {
      int count = keyc->modifierKeyCount[i];
d764 8
a771 8
      for (key = 0; key < MAP_LENGTH; key++)
        if (keyc->xkbInfo->desc->map->modmap[key] & mask) {
          if (key_is_down(pDev, key, KEY_PROCESSED))
	        KdEnqueueKeyboardEvent (ephyrKbd, key, TRUE);

          if (--count == 0)
            break;
        }
a772 10

    /* Modifier shoud be down, but isn't
     */
    if (!(xkb_state & mask) && (state & mask))
      for (key = 0; key < MAP_LENGTH; key++)
        if (keyc->xkbInfo->desc->map->modmap[key] & mask) {
	        KdEnqueueKeyboardEvent (ephyrKbd, key, FALSE);
          break;
        }
  }
d776 1
a776 1
ephyrBlockSigio (void)
d780 3
a782 3
    sigemptyset (&set);
    sigaddset (&set, SIGIO);
    sigprocmask (SIG_BLOCK, &set, 0);
d786 1
a786 1
ephyrUnblockSigio (void)
d790 3
a792 3
    sigemptyset (&set);
    sigaddset (&set, SIGIO);
    sigprocmask (SIG_UNBLOCK, &set, 0);
d798 1
a798 1
  return FALSE;
d802 1
a802 1
ephyrCrossScreen (ScreenPtr pScreen, Bool entering)
d806 1
a806 1
int ephyrCurScreen; /*current event screen*/
d809 1
a809 1
ephyrWarpCursor (DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
d811 1
a811 1
    ephyrBlockSigio ();
d813 3
a815 2
    miPointerWarpCursor (inputInfo.pointer, pScreen, x, y);
    ephyrUnblockSigio ();
d818 6
a823 7
miPointerScreenFuncRec ephyrPointerScreenFuncs =
{
  ephyrCursorOffScreen,
  ephyrCrossScreen,
  ephyrWarpCursor,
  NULL,
  NULL
d842 1
a842 1
ephyrExposePairedWindow (int a_remote)
d848 3
a850 3
    if (!findWindowPairFromRemote (a_remote, &pair)) {
	EPHYR_LOG ("did not find a pair for this window\n");
	return;
d855 1
a855 1
    screen->WindowExposures (pair->local, &reg, NullRegion);
d858 1
a858 1
#endif /* XF86DRI */
d863 1
a863 1
  EphyrHostXEvent ev;
d865 2
a866 4
  while (hostx_get_event(&ev))
    {
      switch (ev.type)
        {
d868 16
a883 18
          if (!ephyrMouse ||
              !((EphyrPointerPrivate *)ephyrMouse->driverPrivate)->enabled) {
              EPHYR_LOG ("skipping mouse motion:%d\n", ephyrCurScreen) ;
              continue;
          }
          {
            if (ev.data.mouse_motion.screen >=0
                && (ephyrCurScreen != ev.data.mouse_motion.screen))
              {
                  EPHYR_LOG ("warping mouse cursor. "
                             "cur_screen%d, motion_screen:%d\n",
                             ephyrCurScreen, ev.data.mouse_motion.screen) ;
                  if (ev.data.mouse_motion.screen >= 0)
                    {
                      ephyrWarpCursor
                            (inputInfo.pointer, screenInfo.screens[ev.data.mouse_motion.screen],
                             ev.data.mouse_motion.x,
                             ev.data.mouse_motion.y );
d885 4
a888 4
              }
            else
              {
                  int x=0, y=0;
d890 1
a890 1
                  EphyrWindowPair *pair = NULL;
d892 4
a895 4
                  EPHYR_LOG ("enqueuing mouse motion:%d\n", ephyrCurScreen) ;
                  x = ev.data.mouse_motion.x;
                  y = ev.data.mouse_motion.y;
                  EPHYR_LOG ("initial (x,y):(%d,%d)\n", x, y) ;
d897 4
a900 5
                  EPHYR_LOG ("is this window peered by a gl drawable ?\n") ;
                  if (findWindowPairFromRemote (ev.data.mouse_motion.window,
                                                &pair))
                    {
                        EPHYR_LOG ("yes, it is peered\n") ;
d904 2
a905 3
                  else
                    {
                        EPHYR_LOG ("no, it is not peered\n") ;
d907 1
a907 1
                  EPHYR_LOG ("final (x,y):(%d,%d)\n", x, y) ;
d909 4
a912 4
                  KdEnqueuePointerEvent(ephyrMouse, mouseState, x, y, 0);
              }
          }
          break;
d915 38
a952 36
          if (!ephyrMouse ||
              !((EphyrPointerPrivate *)ephyrMouse->driverPrivate)->enabled) {
              EPHYR_LOG ("skipping mouse press:%d\n", ephyrCurScreen) ;
              continue;
          }
          EPHYR_LOG ("enqueuing mouse press:%d\n", ephyrCurScreen) ;
	  ephyrUpdateModifierState(ev.key_state);
	  mouseState |= ev.data.mouse_down.button_num;
	  KdEnqueuePointerEvent(ephyrMouse, mouseState|KD_MOUSE_DELTA, 0, 0, 0);
	  break;

	case EPHYR_EV_MOUSE_RELEASE:
          if (!ephyrMouse ||
              !((EphyrPointerPrivate *)ephyrMouse->driverPrivate)->enabled)
              continue;
	  ephyrUpdateModifierState(ev.key_state);
	  mouseState &= ~ev.data.mouse_up.button_num;
          EPHYR_LOG ("enqueuing mouse release:%d\n", ephyrCurScreen) ;
	  KdEnqueuePointerEvent(ephyrMouse, mouseState|KD_MOUSE_DELTA, 0, 0, 0);
	  break;

	case EPHYR_EV_KEY_PRESS:
          if (!ephyrKbd ||
              !((EphyrKbdPrivate *)ephyrKbd->driverPrivate)->enabled)
              continue;
	  ephyrUpdateModifierState(ev.key_state);
	  KdEnqueueKeyboardEvent (ephyrKbd, ev.data.key_down.scancode, FALSE);
	  break;

	case EPHYR_EV_KEY_RELEASE:
          if (!ephyrKbd ||
              !((EphyrKbdPrivate *)ephyrKbd->driverPrivate)->enabled)
              continue;
	  ephyrUpdateModifierState(ev.key_state);
	  KdEnqueueKeyboardEvent (ephyrKbd, ev.data.key_up.scancode, TRUE);
	  break;
d955 14
a968 14
	case EPHYR_EV_EXPOSE:
	  /*
	   * We only receive expose events when the expose event have
	   * be generated for a drawable that is a host X window managed
	   * by Xephyr. Host X windows managed by Xephyr exists for instance
	   * when Xephyr is asked to create a GL drawable in a DRI environment.
	   */
	  ephyrExposePairedWindow (ev.data.expose.window);
	  break;
#endif /* XF86DRI */

	default:
	  break;
	}
d973 1
a973 1
ephyrCardFini (KdCardInfo *card)
d975 3
a977 2
  EphyrPriv	*priv = card->driver;
  free(priv);
d981 1
a981 1
ephyrGetColors (ScreenPtr pScreen, int n, xColorItem *pdefs)
d983 9
a991 10
  /* XXX Not sure if this is right */
  
  EPHYR_LOG("mark");
  
  while (n--)
    {
      pdefs->red = 0;
      pdefs->green = 0;
      pdefs->blue = 0;
      pdefs++;
d997 1
a997 1
ephyrPutColors (ScreenPtr pScreen, int n, xColorItem *pdefs)
d999 3
a1001 1
  int min, max, p;
d1003 2
a1004 1
  /* XXX Not sure if this is right */
d1006 11
a1016 16
  min = 256;
  max = 0;
  
  while (n--)
    {
      p = pdefs->pixel;
      if (p < min)
	min = p;
      if (p > max)
	max = p;

      hostx_set_cmap_entry(p, 		
			   pdefs->red >> 8,
			   pdefs->green >> 8,
			   pdefs->blue >> 8);
      pdefs++;
d1023 1
a1023 1
MouseInit (KdPointerInfo *pi)
d1026 2
a1027 2
                         calloc(sizeof(EphyrPointerPrivate), 1);
    ((EphyrPointerPrivate *)pi->driverPrivate)->enabled = FALSE;
d1045 1
a1045 1
MouseEnable (KdPointerInfo *pi)
d1047 1
a1047 1
    ((EphyrPointerPrivate *)pi->driverPrivate)->enabled = TRUE;
d1052 1
a1052 1
MouseDisable (KdPointerInfo *pi)
d1054 1
a1054 1
    ((EphyrPointerPrivate *)pi->driverPrivate)->enabled = FALSE;
d1059 1
a1059 1
MouseFini (KdPointerInfo *pi)
d1061 1
a1061 1
    ephyrMouse = NULL; 
d1077 1
a1077 1
EphyrKeyboardInit (KdKeyboardInfo *ki)
d1079 13
a1091 13
  ki->driverPrivate = (EphyrKbdPrivate *)
                       calloc(sizeof(EphyrKbdPrivate), 1);
  hostx_load_keymap();
  if (!ephyrKeySyms.map) {
      ErrorF("Couldn't load keymap from host\n");
      return BadAlloc;
  }
  ki->minScanCode = ephyrKeySyms.minKeyCode;
  ki->maxScanCode = ephyrKeySyms.maxKeyCode;
  free(ki->name);
  ki->name = strdup("Xephyr virtual keyboard");
  ephyrKbd = ki;
  return Success;
d1095 1
a1095 1
EphyrKeyboardEnable (KdKeyboardInfo *ki)
d1097 1
a1097 1
    ((EphyrKbdPrivate *)ki->driverPrivate)->enabled = TRUE;
d1103 1
a1103 1
EphyrKeyboardDisable (KdKeyboardInfo *ki)
d1105 1
a1105 1
    ((EphyrKbdPrivate *)ki->driverPrivate)->enabled = FALSE;
d1109 1
a1109 1
EphyrKeyboardFini (KdKeyboardInfo *ki)
d1116 1
a1116 1
EphyrKeyboardLeds (KdKeyboardInfo *ki, int leds)
d1121 1
a1121 1
EphyrKeyboardBell (KdKeyboardInfo *ki, int volume, int frequency, int duration)
a1123 1

@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d5 1
a5 1
 * Copyright © 2004 Nokia 
d55 1
d253 5
a257 1
  KdComputePointerMatrix (&m, scrpriv->randr, screen->width, screen->height);
d538 9
a546 1
  scrpriv->randr = KdAddRotation (screen->randr, randr);
d1074 8
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d41 2
d78 1
a78 1
  priv = (EphyrPriv *) xalloc (sizeof (EphyrPriv));
d84 1
a84 1
      xfree (priv);
d190 1
a190 1
  scrpriv = xcalloc (1, sizeof (EphyrScrPriv));
d200 1
a200 1
      xfree (scrpriv);
d348 1
a348 1
  if (REGION_NOTEMPTY (pScreen, pRegion))
d353 2
a354 2
      nbox = REGION_NUM_RECTS (pRegion);
      pbox = REGION_RECTS (pRegion);
d742 1
a742 1
    xfree(screen->driver);
a752 7
#if 0
  DeviceIntPtr pkeydev;
  KeyClassPtr  keyc;
  int          i;
  CARD8        mask;

  pkeydev = inputInfo.keyboard;
d754 5
a758 2
  if (!pkeydev)
    return;
d760 2
a761 11
/* This is pretty broken.
 *
 * What should happen is that focus out should do as a VT switch does in
 * traditional servers: fake releases for all keys (and buttons too, come
 * to think of it) currently down.  Then, on focus in, get the state from
 * the host, and fake keypresses for everything currently down.
 *
 * So I'm leaving this broken for a little while.  Sorry, folks.
 *
 * -daniels
 */
d763 1
a763 2
  keyc = pkeydev->key;
  
d765 2
a766 2
  
  if (keyc->state == state)
a767 4
  
  for (i = 0, mask = 1; i < 8; i++, mask <<= 1) 
    {
      int key;
d769 16
a784 33
      /* Modifier is down, but shouldn't be   */
      if ((keyc->state & mask) && !(state & mask)) 
	{
	  int count = keyc->modifierKeyCount[i];
	  
	  for (key = 0; key < MAP_LENGTH; key++)
	    if (keyc->xkbInfo->desc->map->modmap[key] & mask)
	      {
		int bit;
		BYTE *kptr;
		
		kptr = &keyc->down[key >> 3];
		bit = 1 << (key & 7);
		
		if (*kptr & bit && ephyrKbd &&
                    ((EphyrKbdPrivate *)ephyrKbd->driverPrivate)->enabled)
		  KdEnqueueKeyboardEvent(ephyrKbd, key, TRUE); /* release */
		
		if (--count == 0)
		  break;
	      }
	}
       
      /* Modifier shoud be down, but isn't   */
      if (!(keyc->state & mask) && (state & mask))
	for (key = 0; key < MAP_LENGTH; key++)
	  if (keyc->xkbInfo->desc->map->modmap[key] & mask)
	    {
              if (keyc->xkbInfo->desc->map->modmap[key] & mask && ephyrKbd &&
                  ((EphyrKbdPrivate *)ephyrKbd->driverPrivate)->enabled)
	          KdEnqueueKeyboardEvent(ephyrKbd, key, FALSE); /* press */
	      break;
	    }
d786 10
a795 1
#endif
d876 2
a877 2
    REGION_NULL (screen, &reg);
    REGION_COPY (screen, &reg, &pair->local->clipList);
d879 1
a879 1
    REGION_UNINIT (screen, &reg);
d977 1
d1003 1
a1003 1
  xfree (priv);
d1055 1
a1055 1
                         xcalloc(sizeof(EphyrPointerPrivate), 1);
d1059 1
a1059 1
    xfree(pi->name);
d1101 1
a1101 1
                       xcalloc(sizeof(EphyrKbdPrivate), 1);
d1109 1
a1109 1
  xfree(ki->name);
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d104 1
a104 1
    screen->fb[0].depth = 8;
d106 1
a106 1
  if (screen->fb[0].depth && screen->fb[0].depth != hostx_get_depth())
d108 3
a110 3
      if (screen->fb[0].depth < hostx_get_depth()
	  && (screen->fb[0].depth == 24 || screen->fb[0].depth == 16
	      || screen->fb[0].depth == 8))
d112 1
a112 1
	  hostx_set_server_depth(screen, screen->fb[0].depth);
d118 1
a118 1
  screen->fb[0].depth = hostx_get_server_depth(screen);
d121 1
a121 1
  if (screen->fb[0].depth <= 8)
d124 1
a124 1
	screen->fb[0].visuals = ((1 << StaticGray) | (1 << GrayScale));
d126 6
a131 6
	screen->fb[0].visuals = ((1 << StaticGray) |
				 (1 << GrayScale) |
				 (1 << StaticColor) |
				 (1 << PseudoColor) |
				 (1 << TrueColor) |
				 (1 << DirectColor));
d133 5
a137 5
      screen->fb[0].redMask   = 0x00;
      screen->fb[0].greenMask = 0x00;
      screen->fb[0].blueMask  = 0x00;
      screen->fb[0].depth        = 8;
      screen->fb[0].bitsPerPixel = 8;
d141 1
a141 1
      screen->fb[0].visuals = (1 << TrueColor);
d143 1
a143 1
      if (screen->fb[0].depth <= 15)
d145 2
a146 2
	  screen->fb[0].depth = 15;
	  screen->fb[0].bitsPerPixel = 16;
d148 1
a148 1
      else if (screen->fb[0].depth <= 16)
d150 2
a151 2
	  screen->fb[0].depth = 16;
	  screen->fb[0].bitsPerPixel = 16;
d153 1
a153 1
      else if (screen->fb[0].depth <= 24)
d155 2
a156 2
	  screen->fb[0].depth = 24;
	  screen->fb[0].bitsPerPixel = 32;
d158 1
a158 1
      else if (screen->fb[0].depth <= 30)
d160 2
a161 2
	  screen->fb[0].depth = 30;
	  screen->fb[0].bitsPerPixel = 32;
d166 1
a166 1
	         screen->fb[0].depth);
d172 3
a174 3
      screen->fb[0].redMask = (Pixel) redMask;
      screen->fb[0].greenMask = (Pixel) greenMask;
      screen->fb[0].blueMask = (Pixel) blueMask;
d223 16
d253 3
a255 10
  priv->bytes_per_line = ((screen->width * screen->fb[0].bitsPerPixel + 31) >> 5) << 2;
  
  /* point the framebuffer to the data in an XImage */
  /* If fakexa is enabled, allocate a larger buffer so that fakexa has space to
   * put offscreen pixmaps.
   */
  if (ephyrFuncs.initAccel == NULL)
    buffer_height = screen->height;
  else
    buffer_height = 3 * screen->height;
a258 4
  screen->memory_base  = (CARD8 *) (priv->base);
  screen->memory_size  = priv->bytes_per_line * buffer_height;
  screen->off_screen_base = priv->bytes_per_line * screen->height;
  
d263 3
a265 3
      screen->fb[0].byteStride = priv->bytes_per_line;
      screen->fb[0].pixelStride = screen->width;
      screen->fb[0].frameBuffer = (CARD8 *) (priv->base);
d274 1
a274 1
      KdShadowFbAlloc (screen, 0, 
d310 1
a310 1
    KdShadowFbFree (screen, 0);
d437 1
a437 3
  
  EPHYR_LOG("mark");
  
d458 2
d574 4
a577 4
				  screen->fb[0].depth,
				  screen->fb[0].bitsPerPixel,
				  screen->fb[0].byteStride,
				  screen->fb[0].frameBuffer);
d738 1
a738 1
        KdShadowFbFree (screen, 0);
d751 1
d762 12
d791 1
a791 1
	    if (keyc->modifierMap[key] & mask) 
d811 1
a811 1
	  if (keyc->modifierMap[key] & mask) 
d813 1
a813 1
              if (keyc->modifierMap[key] & mask && ephyrKbd &&
d819 1
d1030 1
a1030 1
ephyrGetColors (ScreenPtr pScreen, int fb, int n, xColorItem *pdefs)
d1047 1
a1047 1
ephyrPutColors (ScreenPtr pScreen, int fb, int n, xColorItem *pdefs)
d1082 2
a1083 1
    pi->name = KdSaveString("Xephyr virtual mouse");
d1130 4
a1133 8
  ki->keySyms.minKeyCode = ephyrKeySyms.minKeyCode;
  ki->keySyms.maxKeyCode = ephyrKeySyms.maxKeyCode;
  ki->minScanCode = ki->keySyms.minKeyCode;
  ki->maxScanCode = ki->keySyms.maxKeyCode;
  ki->keySyms.mapWidth = ephyrKeySyms.mapWidth;
  xfree(ki->keySyms.map);
  ki->keySyms.map = ephyrKeySyms.map;
  ki->name = KdSaveString("Xephyr virtual keyboard");
a1154 2
    /* not xfree: we call malloc from hostx.c. */
    free(ki->keySyms.map);
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d35 1
a35 1
#ifdef XEPHYR_DRI
d39 1
a39 1
#endif /*XEPHYR_DRI*/
d94 1
a94 1
  unsigned long redMask, greenMask, blueMask;
d153 1
a153 1
      else
d158 11
d188 1
a188 1
  scrpriv = xalloc (sizeof (EphyrScrPriv));
a192 1
  memset (scrpriv, 0, sizeof (EphyrScrPriv));
a527 2
  KdOffscreenSwapOut (screen->pScreen);
  
d642 1
a642 1
#ifdef XEPHYR_DRI
d837 1
a837 1
ephyrWarpCursor (ScreenPtr pScreen, int x, int y)
d841 1
a841 1
    miPointerWarpCursor (pScreen, x, y);
d849 3
a851 1
  ephyrWarpCursor
d854 1
a854 1
#ifdef XEPHYR_DRI
d886 1
a886 1
#endif /*XEPHYR_DRI*/
d913 1
a913 1
                            (screenInfo.screens[ev.data.mouse_motion.screen],
d921 1
a921 1
#ifdef XEPHYR_DRI
d928 1
a928 1
#ifdef XEPHYR_DRI
d985 1
a985 1
#ifdef XEPHYR_DRI
d995 1
a995 1
#endif /*XEPHYR_DRI*/
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@a25 5
/*  TODO:
 *
 *  o Support multiple screens, shouldn't be hard just alot of rejigging.
 */

d32 8
d42 4
d49 2
d60 1
d96 1
a96 1
  if (hostx_want_screen_size(&width, &height) 
d112 1
a112 1
	  hostx_set_server_depth(screen->fb[0].depth);
d114 1
a114 1
      else 
d118 1
a118 1
  screen->fb[0].depth = hostx_get_server_depth();
d159 1
a159 1
      hostx_get_visual_masks (&redMask, &greenMask, &blueMask);
d207 1
a207 3
    {
      return 0;
    }
d221 2
a222 2
  EPHYR_DBG(" screen->width: %d, screen->height: %d",
	    screen->width, screen->height);
d237 2
a238 2
  
  priv->base = hostx_screen_init (screen->width, screen->height, buffer_height);
d257 1
a257 1
      EPHYR_DBG("allocing shadow");
d308 1
a308 1
  EPHYR_DBG("slow paint");
d315 1
a315 1
  hostx_paint_rect(0,0,0,0, screen->width, screen->height);
d325 1
a325 1
  
d328 1
a328 1
  
d330 1
a330 1
  
d335 1
a335 1
      
d338 1
a338 1
      
d340 8
a347 8
	{
	  hostx_paint_rect(pbox->x1, pbox->y1,
			   pbox->x1, pbox->y1,
			   pbox->x2 - pbox->x1,
			   pbox->y2 - pbox->y1);
	  pbox++;
	}
      
d423 1
a423 1
  EPHYR_DBG("mark");
d444 1
a444 1
  
d446 3
a448 3
  
  if (!hostx_want_preexisting_window()
      && !hostx_want_fullscreen()) /* only if no -parent switch */
d576 1
a576 1
  EPHYR_DBG("bailed");
d598 1
a598 3
    {
      return FALSE;
    }
d616 6
d623 31
d665 1
a665 1
  
d670 1
a670 1
    
d681 2
a682 1
  EPHYR_DBG("mark");
d723 4
d743 1
a743 1
  pkeydev = (DeviceIntPtr)LookupKeyboardDevice();
d795 83
d886 2
a887 2
	{
	case EPHYR_EV_MOUSE_MOTION:
d889 2
a890 1
              !((EphyrPointerPrivate *)ephyrMouse->driverPrivate)->enabled)
d892 47
a938 7
	  KdEnqueuePointerEvent(ephyrMouse, mouseState,  
			        ev.data.mouse_motion.x, 
			        ev.data.mouse_motion.y,
                                0);
	  break;
	  
	case EPHYR_EV_MOUSE_PRESS:
d940 2
a941 1
              !((EphyrPointerPrivate *)ephyrMouse->driverPrivate)->enabled)
d943 2
d956 1
a971 1
	  ephyrUpdateModifierState(ev.key_state);
d975 12
d1005 1
a1005 1
  EPHYR_DBG("mark");
d1144 1
@


1.1
log
@Initial revision
@
text
@d39 3
a41 1
extern DeviceIntPtr pKdKeyboard;
d45 4
d84 2
a85 1

a136 5
	  
	  hostx_get_visual_masks (&screen->fb[0].redMask,
				  &screen->fb[0].greenMask,
				  &screen->fb[0].blueMask);
	  
a141 4
	  
	  hostx_get_visual_masks (&screen->fb[0].redMask,
				  &screen->fb[0].greenMask,
				  &screen->fb[0].blueMask);
a146 4
	  
	  hostx_get_visual_masks (&screen->fb[0].redMask,
				  &screen->fb[0].greenMask,
				  &screen->fb[0].blueMask);
d148 7
d210 1
a210 1
  KdMouseMatrix m;
d216 2
a217 3
  KdComputeMouseMatrix (&m, scrpriv->randr, screen->width, screen->height);
    
  KdSetMouseMatrix (&m);
d397 1
d679 2
d725 3
a727 2
		if (*kptr & bit)
		  KdEnqueueKeyboardEvent(key, TRUE); /* release */
d739 3
a741 1
	      KdEnqueueKeyboardEvent(key, FALSE); /* press */
d757 7
a763 3
	  KdEnqueueMouseEvent(kdMouseInfo, mouseState,  
			      ev.data.mouse_motion.x, 
			      ev.data.mouse_motion.y);
d767 3
d772 1
a772 1
	  KdEnqueueMouseEvent(kdMouseInfo, mouseState|KD_MOUSE_DELTA, 0, 0);
d776 3
d781 1
a781 1
	  KdEnqueueMouseEvent(kdMouseInfo, mouseState|KD_MOUSE_DELTA, 0, 0);
d785 3
d789 1
a789 1
	  KdEnqueueKeyboardEvent (ev.data.key_down.scancode, FALSE);
d793 3
d797 1
a797 1
	  KdEnqueueKeyboardEvent (ev.data.key_up.scancode, TRUE);
d858 2
a859 2
static Bool
MouseInit (void)
d861 15
a875 1
    return TRUE;
d879 1
a879 1
MouseFini (void)
d881 2
a882 1
  ;
d885 9
a893 1
KdMouseFuncs EphyrMouseFuncs = {
d895 2
d898 1
d903 24
a926 2
static void
EphyrKeyboardLoad (void)
d928 1
a928 1
  EPHYR_DBG("mark");
d930 1
a930 1
  hostx_load_keymap();
d933 2
a934 2
static int
EphyrKeyboardInit (void)
d936 1
a936 1
  return 0;
d940 1
a940 1
EphyrKeyboardFini (void)
d942 4
d949 1
a949 1
EphyrKeyboardLeds (int leds)
d954 1
a954 1
EphyrKeyboardBell (int volume, int frequency, int duration)
d958 2
a959 2
KdKeyboardFuncs	EphyrKeyboardFuncs = {
    EphyrKeyboardLoad,
d961 1
d964 1
d966 1
a966 1
    0,
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d39 1
a39 3
KdKeyboardInfo *ephyrKbd;
KdPointerInfo *ephyrMouse;
EphyrKeySyms ephyrKeySyms;
a42 4
typedef struct _EphyrInputPrivate {
    Bool    enabled;
} EphyrKbdPrivate, EphyrPointerPrivate;

d78 1
a78 2
  unsigned long redMask, greenMask, blueMask;
  
d130 5
d140 4
d149 4
a153 7

      hostx_get_visual_masks (&redMask, &greenMask, &blueMask);

      screen->fb[0].redMask = (Pixel) redMask;
      screen->fb[0].greenMask = (Pixel) greenMask;
      screen->fb[0].blueMask = (Pixel) blueMask;

d209 1
a209 1
  KdPointerMatrix m;
d215 3
a217 2
  KdComputePointerMatrix (&m, scrpriv->randr, screen->width, screen->height);
  KdSetPointerMatrix (&m);
a677 2
    xfree(screen->driver);
    screen->driver = NULL;
d722 2
a723 3
		if (*kptr & bit && ephyrKbd &&
                    ((EphyrKbdPrivate *)ephyrKbd->driverPrivate)->enabled)
		  KdEnqueueKeyboardEvent(ephyrKbd, key, TRUE); /* release */
d735 1
a735 3
              if (keyc->modifierMap[key] & mask && ephyrKbd &&
                  ((EphyrKbdPrivate *)ephyrKbd->driverPrivate)->enabled)
	          KdEnqueueKeyboardEvent(ephyrKbd, key, FALSE); /* press */
d751 3
a753 7
          if (!ephyrMouse ||
              !((EphyrPointerPrivate *)ephyrMouse->driverPrivate)->enabled)
              continue;
	  KdEnqueuePointerEvent(ephyrMouse, mouseState,  
			        ev.data.mouse_motion.x, 
			        ev.data.mouse_motion.y,
                                0);
a756 3
          if (!ephyrMouse ||
              !((EphyrPointerPrivate *)ephyrMouse->driverPrivate)->enabled)
              continue;
d759 1
a759 1
	  KdEnqueuePointerEvent(ephyrMouse, mouseState|KD_MOUSE_DELTA, 0, 0, 0);
a762 3
          if (!ephyrMouse ||
              !((EphyrPointerPrivate *)ephyrMouse->driverPrivate)->enabled)
              continue;
d765 1
a765 1
	  KdEnqueuePointerEvent(ephyrMouse, mouseState|KD_MOUSE_DELTA, 0, 0, 0);
a768 3
          if (!ephyrKbd ||
              !((EphyrKbdPrivate *)ephyrKbd->driverPrivate)->enabled)
              continue;
d770 1
a770 1
	  KdEnqueueKeyboardEvent (ephyrKbd, ev.data.key_down.scancode, FALSE);
a773 3
          if (!ephyrKbd ||
              !((EphyrKbdPrivate *)ephyrKbd->driverPrivate)->enabled)
              continue;
d775 1
a775 1
	  KdEnqueueKeyboardEvent (ephyrKbd, ev.data.key_up.scancode, TRUE);
d836 2
a837 2
static Status
MouseInit (KdPointerInfo *pi)
d839 1
a839 15
    pi->driverPrivate = (EphyrPointerPrivate *)
                         xcalloc(sizeof(EphyrPointerPrivate), 1);
    ((EphyrPointerPrivate *)pi->driverPrivate)->enabled = FALSE;
    pi->nAxes = 3;
    pi->nButtons = 32;
    pi->name = KdSaveString("Xephyr virtual mouse");
    ephyrMouse = pi;
    return Success;
}

static Status
MouseEnable (KdPointerInfo *pi)
{
    ((EphyrPointerPrivate *)pi->driverPrivate)->enabled = TRUE;
    return Success;
d843 1
a843 1
MouseDisable (KdPointerInfo *pi)
d845 1
a845 2
    ((EphyrPointerPrivate *)pi->driverPrivate)->enabled = FALSE;
    return;
d848 1
a848 9
static void
MouseFini (KdPointerInfo *pi)
{
    ephyrMouse = NULL; 
    return;
}

KdPointerDriver EphyrMouseDriver = {
    "ephyr",
a849 2
    MouseEnable,
    MouseDisable,
a850 1
    NULL,
d855 2
a856 2
static Status
EphyrKeyboardInit (KdKeyboardInfo *ki)
d858 2
a859 2
  ki->driverPrivate = (EphyrKbdPrivate *)
                       xcalloc(sizeof(EphyrKbdPrivate), 1);
a860 13
  if (!ephyrKeySyms.map) {
      ErrorF("Couldn't load keymap from host\n");
      return BadAlloc;
  }
  ki->keySyms.minKeyCode = ephyrKeySyms.minKeyCode;
  ki->keySyms.maxKeyCode = ephyrKeySyms.maxKeyCode;
  ki->minScanCode = ki->keySyms.minKeyCode;
  ki->maxScanCode = ki->keySyms.maxKeyCode;
  ki->keySyms.mapWidth = ephyrKeySyms.mapWidth;
  ki->keySyms.map = ephyrKeySyms.map;
  ki->name = KdSaveString("Xephyr virtual keyboard");
  ephyrKbd = ki;
  return Success;
d863 2
a864 2
static Status
EphyrKeyboardEnable (KdKeyboardInfo *ki)
d866 1
a866 3
    ((EphyrKbdPrivate *)ki->driverPrivate)->enabled = TRUE;

    return Success;
d870 1
a870 1
EphyrKeyboardDisable (KdKeyboardInfo *ki)
a871 10
    ((EphyrKbdPrivate *)ki->driverPrivate)->enabled = FALSE;
}

static void
EphyrKeyboardFini (KdKeyboardInfo *ki)
{
    /* not xfree: we call malloc from hostx.c. */
    free(ki->keySyms.map);
    ephyrKbd = NULL;
    return;
d875 1
a875 1
EphyrKeyboardLeds (KdKeyboardInfo *ki, int leds)
d880 1
a880 1
EphyrKeyboardBell (KdKeyboardInfo *ki, int volume, int frequency, int duration)
d884 2
a885 2
KdKeyboardDriver EphyrKeyboardDriver = {
    "ephyr",
a886 1
    EphyrKeyboardEnable,
a888 1
    EphyrKeyboardDisable,
d890 1
a890 1
    NULL,
@

