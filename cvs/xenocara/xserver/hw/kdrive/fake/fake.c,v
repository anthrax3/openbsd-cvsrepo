head	1.7;
access;
symbols
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.16
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.14
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.12
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.10
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	s0SI41sEunLdyFfd;

1.6
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.49;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.49;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.04.19;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright Â© 2004 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif
#include "fake.h"

Bool
fakeInitialize(KdCardInfo * card, FakePriv * priv)
{
    priv->base = 0;
    priv->bytes_per_line = 0;
    return TRUE;
}

Bool
fakeCardInit(KdCardInfo * card)
{
    FakePriv *priv;

    priv = (FakePriv *) malloc(sizeof(FakePriv));
    if (!priv)
        return FALSE;

    if (!fakeInitialize(card, priv)) {
        free(priv);
        return FALSE;
    }
    card->driver = priv;

    return TRUE;
}

Bool
fakeScreenInitialize(KdScreenInfo * screen, FakeScrPriv * scrpriv)
{
    if (!screen->width || !screen->height) {
        screen->width = 1024;
        screen->height = 768;
        screen->rate = 72;
    }

    if (screen->width <= 0)
        screen->width = 1;
    if (screen->height <= 0)
        screen->height = 1;

    if (!screen->fb.depth)
        screen->fb.depth = 16;

    if (screen->fb.depth <= 8) {
        screen->fb.visuals = ((1 << StaticGray) |
                              (1 << GrayScale) |
                              (1 << StaticColor) |
                              (1 << PseudoColor) |
                              (1 << TrueColor) | (1 << DirectColor));
    }
    else {
        screen->fb.visuals = (1 << TrueColor);
#define Mask(o,l)   (((1 << l) - 1) << o)
        if (screen->fb.depth <= 15) {
            screen->fb.depth = 15;
            screen->fb.bitsPerPixel = 16;
            screen->fb.redMask = Mask (10, 5);
            screen->fb.greenMask = Mask (5, 5);
            screen->fb.blueMask = Mask (0, 5);
        }
        else if (screen->fb.depth <= 16) {
            screen->fb.depth = 16;
            screen->fb.bitsPerPixel = 16;
            screen->fb.redMask = Mask (11, 5);
            screen->fb.greenMask = Mask (5, 6);
            screen->fb.blueMask = Mask (0, 5);
        }
        else {
            screen->fb.depth = 24;
            screen->fb.bitsPerPixel = 32;
            screen->fb.redMask = Mask (16, 8);
            screen->fb.greenMask = Mask (8, 8);
            screen->fb.blueMask = Mask (0, 8);
        }
    }

    scrpriv->randr = screen->randr;

    return fakeMapFramebuffer(screen);
}

Bool
fakeScreenInit(KdScreenInfo * screen)
{
    FakeScrPriv *scrpriv;

    scrpriv = calloc(1, sizeof(FakeScrPriv));
    if (!scrpriv)
        return FALSE;
    screen->driver = scrpriv;
    if (!fakeScreenInitialize(screen, scrpriv)) {
        screen->driver = 0;
        free(scrpriv);
        return FALSE;
    }
    return TRUE;
}

void *
fakeWindowLinear(ScreenPtr pScreen,
                 CARD32 row,
                 CARD32 offset, int mode, CARD32 *size, void *closure)
{
    KdScreenPriv(pScreen);
    FakePriv *priv = pScreenPriv->card->driver;

    if (!pScreenPriv->enabled)
        return 0;
    *size = priv->bytes_per_line;
    return priv->base + row * priv->bytes_per_line;
}

Bool
fakeMapFramebuffer(KdScreenInfo * screen)
{
    FakeScrPriv *scrpriv = screen->driver;
    KdPointerMatrix m;
    FakePriv *priv = screen->card->driver;

    if (scrpriv->randr != RR_Rotate_0)
        scrpriv->shadow = TRUE;
    else
        scrpriv->shadow = FALSE;

    KdComputePointerMatrix(&m, scrpriv->randr, screen->width, screen->height);

    KdSetPointerMatrix(&m);

    priv->bytes_per_line =
        ((screen->width * screen->fb.bitsPerPixel + 31) >> 5) << 2;
    free(priv->base);
    priv->base = xallocarray(priv->bytes_per_line, screen->height);

    if (scrpriv->shadow) {
        if (!KdShadowFbAlloc
            (screen, scrpriv->randr & (RR_Rotate_90 | RR_Rotate_270)))
            return FALSE;
    }
    else {
        screen->fb.byteStride = priv->bytes_per_line;
        screen->fb.pixelStride = (priv->bytes_per_line * 8 /
                                  screen->fb.bitsPerPixel);
        screen->fb.frameBuffer = (CARD8 *) (priv->base);
    }

    return TRUE;
}

void
fakeSetScreenSizes(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    FakeScrPriv *scrpriv = screen->driver;

    if (scrpriv->randr & (RR_Rotate_0 | RR_Rotate_180)) {
        pScreen->width = screen->width;
        pScreen->height = screen->height;
        pScreen->mmWidth = screen->width_mm;
        pScreen->mmHeight = screen->height_mm;
    }
    else {
        pScreen->width = screen->width;
        pScreen->height = screen->height;
        pScreen->mmWidth = screen->height_mm;
        pScreen->mmHeight = screen->width_mm;
    }
}

Bool
fakeUnmapFramebuffer(KdScreenInfo * screen)
{
    FakePriv *priv = screen->card->driver;

    KdShadowFbFree(screen);
    free(priv->base);
    priv->base = NULL;
    return TRUE;
}

Bool
fakeSetShadow(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    FakeScrPriv *scrpriv = screen->driver;
    ShadowUpdateProc update;
    ShadowWindowProc window;

    window = fakeWindowLinear;
    update = 0;
    if (scrpriv->randr)
        update = shadowUpdateRotatePacked;
    else
        update = shadowUpdatePacked;
    return KdShadowSet(pScreen, scrpriv->randr, update, window);
}

#ifdef RANDR
Bool
fakeRandRGetInfo(ScreenPtr pScreen, Rotation * rotations)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    FakeScrPriv *scrpriv = screen->driver;
    RRScreenSizePtr pSize;
    Rotation randr;
    int n;

    *rotations = RR_Rotate_All | RR_Reflect_All;

    for (n = 0; n < pScreen->numDepths; n++)
        if (pScreen->allowedDepths[n].numVids)
            break;
    if (n == pScreen->numDepths)
        return FALSE;

    pSize = RRRegisterSize(pScreen,
                           screen->width,
                           screen->height, screen->width_mm, screen->height_mm);

    randr = KdSubRotation(scrpriv->randr, screen->randr);

    RRSetCurrentConfig(pScreen, randr, 0, pSize);

    return TRUE;
}

Bool
fakeRandRSetConfig(ScreenPtr pScreen,
                   Rotation randr, int rate, RRScreenSizePtr pSize)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    FakeScrPriv *scrpriv = screen->driver;
    Bool wasEnabled = pScreenPriv->enabled;
    FakeScrPriv oldscr;
    int oldwidth;
    int oldheight;
    int oldmmwidth;
    int oldmmheight;
    int newwidth, newheight;

    if (screen->randr & (RR_Rotate_0 | RR_Rotate_180)) {
        newwidth = pSize->width;
        newheight = pSize->height;
    }
    else {
        newwidth = pSize->height;
        newheight = pSize->width;
    }

    if (wasEnabled)
        KdDisableScreen(pScreen);

    oldscr = *scrpriv;

    oldwidth = screen->width;
    oldheight = screen->height;
    oldmmwidth = pScreen->mmWidth;
    oldmmheight = pScreen->mmHeight;

    /*
     * Set new configuration
     */

    scrpriv->randr = KdAddRotation(screen->randr, randr);

    fakeUnmapFramebuffer(screen);

    if (!fakeMapFramebuffer(screen))
        goto bail4;

    KdShadowUnset(screen->pScreen);

    if (!fakeSetShadow(screen->pScreen))
        goto bail4;

    fakeSetScreenSizes(screen->pScreen);

    /*
     * Set frame buffer mapping
     */
    (*pScreen->ModifyPixmapHeader) (fbGetScreenPixmap(pScreen),
                                    pScreen->width,
                                    pScreen->height,
                                    screen->fb.depth,
                                    screen->fb.bitsPerPixel,
                                    screen->fb.byteStride,
                                    screen->fb.frameBuffer);

    /* set the subpixel order */

    KdSetSubpixelOrder(pScreen, scrpriv->randr);
    if (wasEnabled)
        KdEnableScreen(pScreen);

    return TRUE;

 bail4:
    fakeUnmapFramebuffer(screen);
    *scrpriv = oldscr;
    (void) fakeMapFramebuffer(screen);
    pScreen->width = oldwidth;
    pScreen->height = oldheight;
    pScreen->mmWidth = oldmmwidth;
    pScreen->mmHeight = oldmmheight;

    if (wasEnabled)
        KdEnableScreen(pScreen);
    return FALSE;
}

Bool
fakeRandRInit(ScreenPtr pScreen)
{
    rrScrPrivPtr pScrPriv;

    if (!RRScreenInit(pScreen))
        return FALSE;

    pScrPriv = rrGetScrPriv(pScreen);
    pScrPriv->rrGetInfo = fakeRandRGetInfo;
    pScrPriv->rrSetConfig = fakeRandRSetConfig;
    return TRUE;
}
#endif

Bool
fakeCreateColormap(ColormapPtr pmap)
{
    return fbInitializeColormap(pmap);
}

Bool
fakeInitScreen(ScreenPtr pScreen)
{
    pScreen->CreateColormap = fakeCreateColormap;
    return TRUE;
}

Bool
fakeFinishInitScreen(ScreenPtr pScreen)
{
    if (!shadowSetup(pScreen))
        return FALSE;

#ifdef RANDR
    if (!fakeRandRInit(pScreen))
        return FALSE;
#endif

    return TRUE;
}

Bool
fakeCreateResources(ScreenPtr pScreen)
{
    return fakeSetShadow(pScreen);
}

void
fakePreserve(KdCardInfo * card)
{
}

Bool
fakeEnable(ScreenPtr pScreen)
{
    return TRUE;
}

Bool
fakeDPMS(ScreenPtr pScreen, int mode)
{
    return TRUE;
}

void
fakeDisable(ScreenPtr pScreen)
{
}

void
fakeRestore(KdCardInfo * card)
{
}

void
fakeScreenFini(KdScreenInfo * screen)
{
}

void
fakeCardFini(KdCardInfo * card)
{
    FakePriv *priv = card->driver;

    free(priv->base);
    free(priv);
}

void
fakeGetColors(ScreenPtr pScreen, int n, xColorItem * pdefs)
{
    while (n--) {
        pdefs->red = 0;
        pdefs->green = 0;
        pdefs->blue = 0;
        pdefs++;
    }
}

void
fakePutColors(ScreenPtr pScreen, int n, xColorItem * pdefs)
{
}
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a27 2
extern int KdTsPhyScreen;

d159 1
a159 1
    priv->base = malloc(priv->bytes_per_line * screen->height);
a364 4
#ifdef TOUCHSCREEN
    KdTsPhyScreen = pScreen->myNum;
#endif

@


1.5
log
@Update to xserver 1.11.2
@
text
@d31 1
a31 1
fakeInitialize (KdCardInfo *card, FakePriv *priv)
d39 1
a39 1
fakeCardInit (KdCardInfo *card)
d41 1
a41 1
    FakePriv	*priv;
d43 1
a43 1
    priv = (FakePriv *) malloc(sizeof (FakePriv));
d45 5
a49 6
	return FALSE;
    
    if (!fakeInitialize (card, priv))
    {
	free(priv);
	return FALSE;
d52 1
a52 1
    
d57 1
a57 1
fakeScreenInitialize (KdScreenInfo *screen, FakeScrPriv *scrpriv)
d59 4
a62 5
    if (!screen->width || !screen->height)
    {
	screen->width = 1024;
	screen->height = 768;
	screen->rate = 72;
d66 1
a66 1
	screen->width = 1;
d68 2
a69 2
	screen->height = 1;
    
d71 1
a71 1
	screen->fb.depth = 16;
d73 9
a81 12
    if (screen->fb.depth <= 8)
    {
	screen->fb.visuals = ((1 << StaticGray) |
			      (1 << GrayScale) |
			      (1 << StaticColor) |
			      (1 << PseudoColor) |
			      (1 << TrueColor) |
			      (1 << DirectColor));
    }
    else 
    {
	screen->fb.visuals = (1 << TrueColor);
d83 21
a103 24
	if (screen->fb.depth <= 15)
	{
	    screen->fb.depth = 15;
	    screen->fb.bitsPerPixel = 16;
	    screen->fb.redMask = Mask (10, 5);
	    screen->fb.greenMask = Mask (5, 5);
	    screen->fb.blueMask = Mask (0, 5);
	}
	else if (screen->fb.depth <= 16)
	{
	    screen->fb.depth = 16;
	    screen->fb.bitsPerPixel = 16;
	    screen->fb.redMask = Mask (11, 5);
	    screen->fb.greenMask = Mask (5, 6);
	    screen->fb.blueMask = Mask (0, 5);
	}
	else
	{
	    screen->fb.depth = 24;
	    screen->fb.bitsPerPixel = 32;
	    screen->fb.redMask = Mask (16, 8);
	    screen->fb.greenMask = Mask (8, 8);
	    screen->fb.blueMask = Mask (0, 8);
	}
d108 1
a108 1
    return fakeMapFramebuffer (screen);
d112 1
a112 1
fakeScreenInit (KdScreenInfo *screen)
d116 1
a116 1
    scrpriv = calloc(1, sizeof (FakeScrPriv));
d118 1
a118 1
	return FALSE;
d120 4
a123 5
    if (!fakeScreenInitialize (screen, scrpriv))
    {
	screen->driver = 0;
	free(scrpriv);
	return FALSE;
d127 1
a127 1
    
d129 3
a131 6
fakeWindowLinear (ScreenPtr	pScreen,
		   CARD32	row,
		   CARD32	offset,
		   int		mode,
		   CARD32	*size,
		   void		*closure)
d134 1
a134 1
    FakePriv	    *priv = pScreenPriv->card->driver;
d137 1
a137 1
	return 0;
d143 1
a143 1
fakeMapFramebuffer (KdScreenInfo *screen)
d145 3
a147 3
    FakeScrPriv	*scrpriv = screen->driver;
    KdPointerMatrix	m;
    FakePriv		*priv = screen->card->driver;
d150 1
a150 1
	scrpriv->shadow = TRUE;
d152 8
a159 7
	scrpriv->shadow = FALSE;
    
    KdComputePointerMatrix (&m, scrpriv->randr, screen->width, screen->height);
    
    KdSetPointerMatrix (&m);
    
    priv->bytes_per_line = ((screen->width * screen->fb.bitsPerPixel + 31) >> 5) << 2;
d161 6
a166 6
    priv->base = malloc (priv->bytes_per_line * screen->height);
    
    if (scrpriv->shadow)
    {
	if (!KdShadowFbAlloc (screen, scrpriv->randr & (RR_Rotate_90|RR_Rotate_270)))
	    return FALSE;
d168 1
a168 2
    else
    {
d170 2
a171 2
        screen->fb.pixelStride = (priv->bytes_per_line * 8/
				     screen->fb.bitsPerPixel);
d174 1
a174 1
    
d179 1
a179 1
fakeSetScreenSizes (ScreenPtr pScreen)
d182 2
a183 2
    KdScreenInfo	*screen = pScreenPriv->screen;
    FakeScrPriv	*scrpriv = screen->driver;
d185 5
a189 6
    if (scrpriv->randr & (RR_Rotate_0|RR_Rotate_180))
    {
	pScreen->width = screen->width;
	pScreen->height = screen->height;
	pScreen->mmWidth = screen->width_mm;
	pScreen->mmHeight = screen->height_mm;
d191 5
a195 6
    else
    {
	pScreen->width = screen->width;
	pScreen->height = screen->height;
	pScreen->mmWidth = screen->height_mm;
	pScreen->mmHeight = screen->width_mm;
d200 1
a200 1
fakeUnmapFramebuffer (KdScreenInfo *screen)
d202 3
a204 2
    FakePriv		*priv = screen->card->driver;
    KdShadowFbFree (screen);
d211 1
a211 1
fakeSetShadow (ScreenPtr pScreen)
d214 4
a217 4
    KdScreenInfo	*screen = pScreenPriv->screen;
    FakeScrPriv	*scrpriv = screen->driver;
    ShadowUpdateProc	update;
    ShadowWindowProc	window;
d222 1
a222 1
	update = shadowUpdateRotatePacked;
d224 2
a225 2
	update = shadowUpdatePacked;
    return KdShadowSet (pScreen, scrpriv->randr, update, window);
a227 1

d230 1
a230 1
fakeRandRGetInfo (ScreenPtr pScreen, Rotation *rotations)
d233 8
a240 8
    KdScreenInfo	    *screen = pScreenPriv->screen;
    FakeScrPriv	    *scrpriv = screen->driver;
    RRScreenSizePtr	    pSize;
    Rotation		    randr;
    int			    n;
    
    *rotations = RR_Rotate_All|RR_Reflect_All;
    
d242 2
a243 2
	if (pScreen->allowedDepths[n].numVids)
	    break;
d245 10
a254 12
	return FALSE;
    
    pSize = RRRegisterSize (pScreen,
			    screen->width,
			    screen->height,
			    screen->width_mm,
			    screen->height_mm);
    
    randr = KdSubRotation (scrpriv->randr, screen->randr);
    
    RRSetCurrentConfig (pScreen, randr, 0, pSize);
    
d259 2
a260 4
fakeRandRSetConfig (ScreenPtr		pScreen,
		     Rotation		randr,
		     int		rate,
		     RRScreenSizePtr	pSize)
d263 17
a279 19
    KdScreenInfo	*screen = pScreenPriv->screen;
    FakeScrPriv	*scrpriv = screen->driver;
    Bool		wasEnabled = pScreenPriv->enabled;
    FakeScrPriv	oldscr;
    int			oldwidth;
    int			oldheight;
    int			oldmmwidth;
    int			oldmmheight;
    int			newwidth, newheight;

    if (screen->randr & (RR_Rotate_0|RR_Rotate_180))
    {
	newwidth = pSize->width;
	newheight = pSize->height;
    }
    else
    {
	newwidth = pSize->height;
	newheight = pSize->width;
d283 1
a283 1
	KdDisableScreen (pScreen);
d286 1
a286 1
    
d291 1
a291 1
    
a294 2
    
    scrpriv->randr = KdAddRotation (screen->randr, randr);
d296 3
a298 4
    fakeUnmapFramebuffer (screen);
    
    if (!fakeMapFramebuffer (screen))
	goto bail4;
d300 2
a301 1
    KdShadowUnset (screen->pScreen);
d303 1
a303 2
    if (!fakeSetShadow (screen->pScreen))
	goto bail4;
d305 4
a308 1
    fakeSetScreenSizes (screen->pScreen);
d313 8
a320 8
    (*pScreen->ModifyPixmapHeader) (fbGetScreenPixmap (pScreen),
				    pScreen->width,
				    pScreen->height,
				    screen->fb.depth,
				    screen->fb.bitsPerPixel,
				    screen->fb.byteStride,
				    screen->fb.frameBuffer);
    
d322 2
a323 2
    
    KdSetSubpixelOrder (pScreen, scrpriv->randr);
d325 1
a325 1
	KdEnableScreen (pScreen);
d329 2
a330 2
bail4:
    fakeUnmapFramebuffer (screen);
d332 1
a332 1
    (void) fakeMapFramebuffer (screen);
d337 1
a337 1
    
d339 1
a339 1
	KdEnableScreen (pScreen);
d344 1
a344 1
fakeRandRInit (ScreenPtr pScreen)
d346 4
a349 4
    rrScrPrivPtr    pScrPriv;
    
    if (!RRScreenInit (pScreen))
	return FALSE;
d359 1
a359 1
fakeCreateColormap (ColormapPtr pmap)
d361 1
a361 1
    return fbInitializeColormap (pmap);
d365 1
a365 1
fakeInitScreen (ScreenPtr pScreen)
d376 1
a376 1
fakeFinishInitScreen (ScreenPtr pScreen)
d378 2
a379 2
    if (!shadowSetup (pScreen))
	return FALSE;
d382 2
a383 2
    if (!fakeRandRInit (pScreen))
	return FALSE;
d385 1
a385 1
    
a388 1

d390 1
a390 1
fakeCreateResources (ScreenPtr pScreen)
d392 1
a392 1
    return fakeSetShadow (pScreen);
d396 1
a396 1
fakePreserve (KdCardInfo *card)
d401 1
a401 1
fakeEnable (ScreenPtr pScreen)
d407 1
a407 1
fakeDPMS (ScreenPtr pScreen, int mode)
d413 1
a413 1
fakeDisable (ScreenPtr pScreen)
d418 1
a418 1
fakeRestore (KdCardInfo *card)
d423 1
a423 1
fakeScreenFini (KdScreenInfo *screen)
d428 1
a428 1
fakeCardFini (KdCardInfo *card)
d430 1
a430 1
    FakePriv	*priv = card->driver;
d432 1
a432 1
    free (priv->base);
d437 1
a437 1
fakeGetColors (ScreenPtr pScreen, int n, xColorItem *pdefs)
d439 5
a443 6
    while (n--)
    {
	pdefs->red = 0;
	pdefs->green = 0;
	pdefs->blue = 0;
	pdefs++;
d448 1
a448 1
fakePutColors (ScreenPtr pScreen, int n, xColorItem *pdefs)
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d218 2
a219 5
    if (priv->base)
    {
	free (priv->base);
	priv->base = 0;
    }
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d43 1
a43 1
    priv = (FakePriv *) xalloc (sizeof (FakePriv));
d49 1
a49 1
	xfree (priv);
d124 1
a124 1
    scrpriv = xcalloc (1, sizeof (FakeScrPriv));
d131 1
a131 1
	xfree (scrpriv);
d171 1
a171 2
    if (priv->base)
	free (priv->base);
d457 1
a457 1
    xfree (priv);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d72 2
a73 2
    if (!screen->fb[0].depth)
	screen->fb[0].depth = 16;
d75 1
a75 1
    if (screen->fb[0].depth <= 8)
d77 6
a82 6
	screen->fb[0].visuals = ((1 << StaticGray) |
				 (1 << GrayScale) |
				 (1 << StaticColor) |
				 (1 << PseudoColor) |
				 (1 << TrueColor) |
				 (1 << DirectColor));
d86 1
a86 1
	screen->fb[0].visuals = (1 << TrueColor);
d88 1
a88 1
	if (screen->fb[0].depth <= 15)
d90 5
a94 5
	    screen->fb[0].depth = 15;
	    screen->fb[0].bitsPerPixel = 16;
	    screen->fb[0].redMask = Mask (10, 5);
	    screen->fb[0].greenMask = Mask (5, 5);
	    screen->fb[0].blueMask = Mask (0, 5);
d96 1
a96 1
	else if (screen->fb[0].depth <= 16)
d98 5
a102 5
	    screen->fb[0].depth = 16;
	    screen->fb[0].bitsPerPixel = 16;
	    screen->fb[0].redMask = Mask (11, 5);
	    screen->fb[0].greenMask = Mask (5, 6);
	    screen->fb[0].blueMask = Mask (0, 5);
d106 5
a110 5
	    screen->fb[0].depth = 24;
	    screen->fb[0].bitsPerPixel = 32;
	    screen->fb[0].redMask = Mask (16, 8);
	    screen->fb[0].greenMask = Mask (8, 8);
	    screen->fb[0].blueMask = Mask (0, 8);
d170 1
a170 1
    priv->bytes_per_line = ((screen->width * screen->fb[0].bitsPerPixel + 31) >> 5) << 2;
a173 3
    screen->memory_base = (CARD8 *) (priv->base);
    screen->memory_size = 0;
    screen->off_screen_base = 0;
d177 1
a177 2
	if (!KdShadowFbAlloc (screen, 0, 
			      scrpriv->randr & (RR_Rotate_90|RR_Rotate_270)))
d182 4
a185 4
        screen->fb[0].byteStride = priv->bytes_per_line;
        screen->fb[0].pixelStride = (priv->bytes_per_line * 8/
				     screen->fb[0].bitsPerPixel);
        screen->fb[0].frameBuffer = (CARD8 *) (priv->base);
d218 1
a218 1
    KdShadowFbFree (screen, 0);
d340 4
a343 4
				    screen->fb[0].depth,
				    screen->fb[0].bitsPerPixel,
				    screen->fb[0].byteStride,
				    screen->fb[0].frameBuffer);
d456 2
a457 3
    
    if (priv->base)
	free (priv->base);
d462 1
a462 1
fakeGetColors (ScreenPtr pScreen, int fb, int n, xColorItem *pdefs)
d474 1
a474 1
fakePutColors (ScreenPtr pScreen, int fb, int n, xColorItem *pdefs)
@


1.1
log
@Initial revision
@
text
@a1 2
 * $Id$
 *
d124 1
a124 1
    scrpriv = xalloc (sizeof (FakeScrPriv));
a126 1
    memset (scrpriv, '\0', sizeof (FakeScrPriv));
d158 1
a158 1
    KdMouseMatrix	m;
d166 1
a166 1
    KdComputeMouseMatrix (&m, scrpriv->randr, screen->width, screen->height);
d168 1
a168 1
    KdSetMouseMatrix (&m);
a324 2

    KdOffscreenSwapOut (screen->pScreen);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d161 1
a161 1
    KdPointerMatrix	m;
d169 1
a169 1
    KdComputePointerMatrix (&m, scrpriv->randr, screen->width, screen->height);
d171 1
a171 1
    KdSetPointerMatrix (&m);
@

