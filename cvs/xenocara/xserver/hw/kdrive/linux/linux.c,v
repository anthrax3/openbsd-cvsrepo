head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.6
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.19;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.14;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.04.18;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright Â© 1999 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif
#include "kdrive.h"
#include <errno.h>
#include <signal.h>
#include <linux/vt.h>
#include <linux/kd.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <X11/keysym.h>
#include <linux/apm_bios.h>

#ifdef KDRIVE_MOUSE
extern KdPointerDriver LinuxMouseDriver;
extern KdPointerDriver Ps2MouseDriver;
extern KdPointerDriver MsMouseDriver;
#endif
#ifdef TSLIB
extern KdPointerDriver TsDriver;
#endif
#ifdef KDRIVE_EVDEV
extern KdPointerDriver LinuxEvdevMouseDriver;
extern KdKeyboardDriver LinuxEvdevKeyboardDriver;
#endif
#ifdef KDRIVE_KBD
extern KdKeyboardDriver LinuxKeyboardDriver;
#endif

static int vtno;
int LinuxConsoleFd;
int LinuxApmFd = -1;
static int activeVT;
static Bool enabled;

static void
LinuxVTRequest(int sig)
{
    kdSwitchPending = TRUE;
}

/* Check before chowning -- this avoids touching the file system */
static void
LinuxCheckChown(const char *file)
{
    struct stat st;
    __uid_t u;
    __gid_t g;
    int r;

    if (stat(file, &st) < 0)
        return;
    u = getuid();
    g = getgid();
    if (st.st_uid != u || st.st_gid != g) {
        r = chown(file, u, g);
        (void) r;
    }
}

static int
LinuxInit(void)
{
    int fd = -1;
    char vtname[11];
    struct vt_stat vts;

    LinuxConsoleFd = -1;
    /* check if we're run with euid==0 */
    if (geteuid() != 0) {
        FatalError("LinuxInit: Server must be suid root\n");
    }

    if (kdVirtualTerminal >= 0)
        vtno = kdVirtualTerminal;
    else {
        if ((fd = open("/dev/tty0", O_WRONLY, 0)) < 0) {
            FatalError("LinuxInit: Cannot open /dev/tty0 (%s)\n",
                       strerror(errno));
        }
        if ((ioctl(fd, VT_OPENQRY, &vtno) < 0) || (vtno == -1)) {
            FatalError("xf86OpenConsole: Cannot find a free VT\n");
        }
        close(fd);
    }

    snprintf(vtname, sizeof(vtname), "/dev/tty%d", vtno);       /* /dev/tty1-64 */

    if ((LinuxConsoleFd = open(vtname, O_RDWR | O_NDELAY, 0)) < 0) {
        FatalError("LinuxInit: Cannot open %s (%s)\n", vtname, strerror(errno));
    }

    /* change ownership of the vt */
    LinuxCheckChown(vtname);

    /*
     * the current VT device we're running on is not "console", we want
     * to grab all consoles too
     *
     * Why is this needed?
     */
    LinuxCheckChown("/dev/tty0");
    /*
     * Linux doesn't switch to an active vt after the last close of a vt,
     * so we do this ourselves by remembering which is active now.
     */
    memset(&vts, '\0', sizeof(vts));    /* valgrind */
    if (ioctl(LinuxConsoleFd, VT_GETSTATE, &vts) == 0) {
        activeVT = vts.v_active;
    }

    return 1;
}

static void
LinuxSetSwitchMode(int mode)
{
    struct sigaction act;
    struct vt_mode VT;

    if (ioctl(LinuxConsoleFd, VT_GETMODE, &VT) < 0) {
        FatalError("LinuxInit: VT_GETMODE failed\n");
    }

    if (mode == VT_PROCESS) {
        act.sa_handler = LinuxVTRequest;
        sigemptyset(&act.sa_mask);
        act.sa_flags = 0;
        sigaction(SIGUSR1, &act, 0);

        VT.mode = mode;
        VT.relsig = SIGUSR1;
        VT.acqsig = SIGUSR1;
    }
    else {
        act.sa_handler = SIG_IGN;
        sigemptyset(&act.sa_mask);
        act.sa_flags = 0;
        sigaction(SIGUSR1, &act, 0);

        VT.mode = mode;
        VT.relsig = 0;
        VT.acqsig = 0;
    }
    if (ioctl(LinuxConsoleFd, VT_SETMODE, &VT) < 0) {
        FatalError("LinuxInit: VT_SETMODE failed\n");
    }
}

static void
LinuxApmBlock(void *blockData, OSTimePtr pTimeout, void *pReadmask)
{
}

static Bool LinuxApmRunning;

static void
LinuxApmWakeup(void *blockData, int result, void *pReadmask)
{
    fd_set *readmask = (fd_set *) pReadmask;

    if (result > 0 && LinuxApmFd >= 0 && FD_ISSET(LinuxApmFd, readmask)) {
        apm_event_t event;
        Bool running = LinuxApmRunning;
        int cmd = APM_IOC_SUSPEND;

        while (read(LinuxApmFd, &event, sizeof(event)) == sizeof(event)) {
            switch (event) {
            case APM_SYS_STANDBY:
            case APM_USER_STANDBY:
                running = FALSE;
                cmd = APM_IOC_STANDBY;
                break;
            case APM_SYS_SUSPEND:
            case APM_USER_SUSPEND:
            case APM_CRITICAL_SUSPEND:
                running = FALSE;
                cmd = APM_IOC_SUSPEND;
                break;
            case APM_NORMAL_RESUME:
            case APM_CRITICAL_RESUME:
            case APM_STANDBY_RESUME:
                running = TRUE;
                break;
            }
        }
        if (running && !LinuxApmRunning) {
            KdResume();
            LinuxApmRunning = TRUE;
        }
        else if (!running && LinuxApmRunning) {
            KdSuspend();
            LinuxApmRunning = FALSE;
            ioctl(LinuxApmFd, cmd, 0);
        }
    }
}

#ifdef FNONBLOCK
#define NOBLOCK FNONBLOCK
#else
#define NOBLOCK FNDELAY
#endif

static void
LinuxEnable(void)
{
    if (enabled)
        return;
    if (kdSwitchPending) {
        kdSwitchPending = FALSE;
        ioctl(LinuxConsoleFd, VT_RELDISP, VT_ACKACQ);
    }
    /*
     * Open the APM driver
     */
    LinuxApmFd = open("/dev/apm_bios", 2);
    if (LinuxApmFd < 0 && errno == ENOENT)
        LinuxApmFd = open("/dev/misc/apm_bios", 2);
    if (LinuxApmFd >= 0) {
        LinuxApmRunning = TRUE;
        fcntl(LinuxApmFd, F_SETFL, fcntl(LinuxApmFd, F_GETFL) | NOBLOCK);
        RegisterBlockAndWakeupHandlers(LinuxApmBlock, LinuxApmWakeup, 0);
        AddEnabledDevice(LinuxApmFd);
    }

    /*
     * now get the VT
     */
    LinuxSetSwitchMode(VT_AUTO);
    if (ioctl(LinuxConsoleFd, VT_ACTIVATE, vtno) != 0) {
        FatalError("LinuxInit: VT_ACTIVATE failed\n");
    }
    if (ioctl(LinuxConsoleFd, VT_WAITACTIVE, vtno) != 0) {
        FatalError("LinuxInit: VT_WAITACTIVE failed\n");
    }
    LinuxSetSwitchMode(VT_PROCESS);
    if (ioctl(LinuxConsoleFd, KDSETMODE, KD_GRAPHICS) < 0) {
        FatalError("LinuxInit: KDSETMODE KD_GRAPHICS failed\n");
    }
    enabled = TRUE;
}

static void
LinuxDisable(void)
{
    ioctl(LinuxConsoleFd, KDSETMODE, KD_TEXT);  /* Back to text mode ... */
    if (kdSwitchPending) {
        kdSwitchPending = FALSE;
        ioctl(LinuxConsoleFd, VT_RELDISP, 1);
    }
    enabled = FALSE;
    if (LinuxApmFd >= 0) {
        RemoveBlockAndWakeupHandlers(LinuxApmBlock, LinuxApmWakeup, 0);
        RemoveEnabledDevice(LinuxApmFd);
        close(LinuxApmFd);
        LinuxApmFd = -1;
    }
}

static void
LinuxFini(void)
{
    struct vt_mode VT;
    struct vt_stat vts;
    int fd;

    if (LinuxConsoleFd < 0)
        return;

    if (ioctl(LinuxConsoleFd, VT_GETMODE, &VT) != -1) {
        VT.mode = VT_AUTO;
        ioctl(LinuxConsoleFd, VT_SETMODE, &VT); /* set dflt vt handling */
    }
    memset(&vts, '\0', sizeof(vts));    /* valgrind */
    ioctl(LinuxConsoleFd, VT_GETSTATE, &vts);
    if (vtno == vts.v_active) {
        /*
         * Find a legal VT to switch to, either the one we started from
         * or the lowest active one that isn't ours
         */
        if (activeVT < 0 ||
            activeVT == vts.v_active || !(vts.v_state & (1 << activeVT))) {
            for (activeVT = 1; activeVT < 16; activeVT++)
                if (activeVT != vtno && (vts.v_state & (1 << activeVT)))
                    break;
            if (activeVT == 16)
                activeVT = -1;
        }
        /*
         * Perform a switch back to the active VT when we were started
         */
        if (activeVT >= -1) {
            ioctl(LinuxConsoleFd, VT_ACTIVATE, activeVT);
            ioctl(LinuxConsoleFd, VT_WAITACTIVE, activeVT);
            activeVT = -1;
        }
    }
    close(LinuxConsoleFd);      /* make the vt-manager happy */
    LinuxConsoleFd = -1;
    fd = open("/dev/tty0", O_RDWR | O_NDELAY, 0);
    if (fd >= 0) {
        memset(&vts, '\0', sizeof(vts));        /* valgrind */
        ioctl(fd, VT_GETSTATE, &vts);
        if (ioctl(fd, VT_DISALLOCATE, vtno) < 0)
            fprintf(stderr, "Can't deallocate console %d %s\n", vtno,
                    strerror(errno));
        close(fd);
    }
    return;
}

void
KdOsAddInputDrivers(void)
{
#ifdef KDRIVE_MOUSE
    KdAddPointerDriver(&LinuxMouseDriver);
    KdAddPointerDriver(&MsMouseDriver);
    KdAddPointerDriver(&Ps2MouseDriver);
#endif
#ifdef TSLIB
    KdAddPointerDriver(&TsDriver);
#endif
#ifdef KDRIVE_EVDEV
    KdAddPointerDriver(&LinuxEvdevMouseDriver);
    KdAddKeyboardDriver(&LinuxEvdevKeyboardDriver);
#endif
#ifdef KDRIVE_KBD
    KdAddKeyboardDriver(&LinuxKeyboardDriver);
#endif
}

static void
LinuxBell(int volume, int pitch, int duration)
{
    if (volume && pitch)
        ioctl(LinuxConsoleFd, KDMKTONE, ((1193190 / pitch) & 0xffff) |
              (((unsigned long) duration * volume / 50) << 16));
}

KdOsFuncs LinuxFuncs = {
    .Init = LinuxInit,
    .Enable = LinuxEnable,
    .Disable = LinuxDisable,
    .Fini = LinuxFini,
    .Bell = LinuxBell,
};

void
OsVendorInit(void)
{
    KdOsInit(&LinuxFuncs);
}
@


1.6
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d71 1
d77 4
a80 2
    if (st.st_uid != u || st.st_gid != g)
        chown(file, u, g);
d173 1
a173 1
LinuxApmBlock(pointer blockData, OSTimePtr pTimeout, pointer pReadmask)
d180 1
a180 1
LinuxApmWakeup(pointer blockData, int result, pointer pReadmask)
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d66 1
a66 1
LinuxCheckChown(char *file)
@


1.4
log
@Update to xserver 1.11.2
@
text
@d37 3
a39 3
extern KdPointerDriver	LinuxMouseDriver;
extern KdPointerDriver	Ps2MouseDriver;
extern KdPointerDriver	MsMouseDriver;
d42 1
a42 1
extern KdPointerDriver	TsDriver;
d45 1
a45 1
extern KdPointerDriver	LinuxEvdevMouseDriver;
d49 1
a49 1
extern KdKeyboardDriver	LinuxKeyboardDriver;
d52 4
a55 4
static int  vtno;
int  LinuxConsoleFd;
int  LinuxApmFd = -1;
static int  activeVT;
d59 1
a59 1
LinuxVTRequest (int sig)
d66 1
a66 1
LinuxCheckChown (char *file)
d68 8
a75 8
    struct stat	    st;
    __uid_t	    u;
    __gid_t	    g;

    if (stat (file, &st) < 0)
	return;
    u = getuid ();
    g = getgid ();
d77 1
a77 1
	chown (file, u, g);
d81 1
a81 1
LinuxInit (void)
d89 2
a90 3
    if (geteuid() != 0)
    {
	FatalError("LinuxInit: Server must be suid root\n");
d94 16
a109 23
	vtno = kdVirtualTerminal;
    else
    {
	if ((fd = open("/dev/tty0",O_WRONLY,0)) < 0)
	{
	    FatalError(
		       "LinuxInit: Cannot open /dev/tty0 (%s)\n",
		       strerror(errno));
	}
	if ((ioctl(fd, VT_OPENQRY, &vtno) < 0) ||
	    (vtno == -1))
	{
	    FatalError("xf86OpenConsole: Cannot find a free VT\n");
	}
	close(fd);
    }

    sprintf(vtname,"/dev/tty%d",vtno); /* /dev/tty1-64 */

    if ((LinuxConsoleFd = open(vtname, O_RDWR|O_NDELAY, 0)) < 0)
    {
	FatalError("LinuxInit: Cannot open %s (%s)\n",
		   vtname, strerror(errno));
d113 1
a113 1
    LinuxCheckChown (vtname);
d121 1
a121 1
    LinuxCheckChown ("/dev/tty0");
d126 3
a128 4
    memset (&vts, '\0', sizeof (vts));	/* valgrind */
    if (ioctl(LinuxConsoleFd, VT_GETSTATE, &vts) == 0)
    {
	activeVT = vts.v_active;
d135 1
a135 1
LinuxSetSwitchMode (int mode)
d137 6
a142 2
    struct sigaction	act;
    struct vt_mode	VT;
d144 22
a165 30
    if (ioctl(LinuxConsoleFd, VT_GETMODE, &VT) < 0)
    {
	FatalError ("LinuxInit: VT_GETMODE failed\n");
    }

    if (mode == VT_PROCESS)
    {
	act.sa_handler = LinuxVTRequest;
	sigemptyset (&act.sa_mask);
	act.sa_flags = 0;
	sigaction (SIGUSR1, &act, 0);

	VT.mode = mode;
	VT.relsig = SIGUSR1;
	VT.acqsig = SIGUSR1;
    }
    else
    {
	act.sa_handler = SIG_IGN;
	sigemptyset (&act.sa_mask);
	act.sa_flags = 0;
	sigaction (SIGUSR1, &act, 0);

	VT.mode = mode;
	VT.relsig = 0;
	VT.acqsig = 0;
    }
    if (ioctl(LinuxConsoleFd, VT_SETMODE, &VT) < 0)
    {
	FatalError("LinuxInit: VT_SETMODE failed\n");
d170 1
a170 1
LinuxApmBlock (pointer blockData, OSTimePtr pTimeout, pointer pReadmask)
d177 1
a177 1
LinuxApmWakeup (pointer blockData, int result, pointer pReadmask)
d179 1
a179 1
    fd_set  *readmask = (fd_set *) pReadmask;
d181 34
a214 38
    if (result > 0 && LinuxApmFd >= 0 && FD_ISSET (LinuxApmFd, readmask))
    {
	apm_event_t event;
	Bool	    running = LinuxApmRunning;
	int	    cmd = APM_IOC_SUSPEND;

	while (read (LinuxApmFd, &event, sizeof (event)) == sizeof (event))
	{
	    switch (event) {
	    case APM_SYS_STANDBY:
	    case APM_USER_STANDBY:
		running = FALSE;
		cmd = APM_IOC_STANDBY;
		break;
	    case APM_SYS_SUSPEND:
	    case APM_USER_SUSPEND:
	    case APM_CRITICAL_SUSPEND:
		running = FALSE;
		cmd = APM_IOC_SUSPEND;
		break;
	    case APM_NORMAL_RESUME:
	    case APM_CRITICAL_RESUME:
	    case APM_STANDBY_RESUME:
		running = TRUE;
		break;
	    }
	}
	if (running && !LinuxApmRunning)
	{
	    KdResume ();
	    LinuxApmRunning = TRUE;
	}
	else if (!running && LinuxApmRunning)
	{
	    KdSuspend ();
	    LinuxApmRunning = FALSE;
	    ioctl (LinuxApmFd, cmd, 0);
	}
d225 1
a225 1
LinuxEnable (void)
d228 4
a231 5
	return;
    if (kdSwitchPending)
    {
	kdSwitchPending = FALSE;
	ioctl (LinuxConsoleFd, VT_RELDISP, VT_ACKACQ);
d236 1
a236 1
    LinuxApmFd = open ("/dev/apm_bios", 2);
d238 6
a243 7
	LinuxApmFd = open ("/dev/misc/apm_bios", 2);
    if (LinuxApmFd >= 0)
    {
	LinuxApmRunning = TRUE;
	fcntl (LinuxApmFd, F_SETFL, fcntl (LinuxApmFd, F_GETFL) | NOBLOCK);
	RegisterBlockAndWakeupHandlers (LinuxApmBlock, LinuxApmWakeup, 0);
	AddEnabledDevice (LinuxApmFd);
d249 10
a258 13
    LinuxSetSwitchMode (VT_AUTO);
    if (ioctl(LinuxConsoleFd, VT_ACTIVATE, vtno) != 0)
    {
	FatalError("LinuxInit: VT_ACTIVATE failed\n");
    }
    if (ioctl(LinuxConsoleFd, VT_WAITACTIVE, vtno) != 0)
    {
	FatalError("LinuxInit: VT_WAITACTIVE failed\n");
    }
    LinuxSetSwitchMode (VT_PROCESS);
    if (ioctl(LinuxConsoleFd, KDSETMODE, KD_GRAPHICS) < 0)
    {
	FatalError("LinuxInit: KDSETMODE KD_GRAPHICS failed\n");
d264 1
a264 1
LinuxDisable (void)
d267 3
a269 4
    if (kdSwitchPending)
    {
	kdSwitchPending = FALSE;
	ioctl (LinuxConsoleFd, VT_RELDISP, 1);
d272 5
a276 6
    if (LinuxApmFd >= 0)
    {
	RemoveBlockAndWakeupHandlers (LinuxApmBlock, LinuxApmWakeup, 0);
	RemoveEnabledDevice (LinuxApmFd);
	close (LinuxApmFd);
	LinuxApmFd = -1;
d281 1
a281 1
LinuxFini (void)
d283 3
a285 3
    struct vt_mode   VT;
    struct vt_stat  vts;
    int		    fd;
d288 1
a288 1
	return;
d290 27
a316 32
    if (ioctl(LinuxConsoleFd, VT_GETMODE, &VT) != -1)
    {
	VT.mode = VT_AUTO;
	ioctl(LinuxConsoleFd, VT_SETMODE, &VT); /* set dflt vt handling */
    }
    memset (&vts, '\0', sizeof (vts));	/* valgrind */
    ioctl (LinuxConsoleFd, VT_GETSTATE, &vts);
    if (vtno == vts.v_active)
    {
	/*
	 * Find a legal VT to switch to, either the one we started from
	 * or the lowest active one that isn't ours
	 */
	if (activeVT < 0 ||
	    activeVT == vts.v_active ||
	    !(vts.v_state & (1 << activeVT)))
	{
	    for (activeVT = 1; activeVT < 16; activeVT++)
		if (activeVT != vtno && (vts.v_state & (1 << activeVT)))
		    break;
	    if (activeVT == 16)
		activeVT = -1;
	}
	/*
	 * Perform a switch back to the active VT when we were started
	 */
	if (activeVT >= -1)
	{
	    ioctl (LinuxConsoleFd, VT_ACTIVATE, activeVT);
	    ioctl (LinuxConsoleFd, VT_WAITACTIVE, activeVT);
	    activeVT = -1;
	}
d318 1
a318 1
    close(LinuxConsoleFd);                /* make the vt-manager happy */
d320 8
a327 8
    fd = open ("/dev/tty0", O_RDWR|O_NDELAY, 0);
    if (fd >= 0)
    {
	memset (&vts, '\0', sizeof (vts));	/* valgrind */
	ioctl (fd, VT_GETSTATE, &vts);
	if (ioctl (fd, VT_DISALLOCATE, vtno) < 0)
	    fprintf (stderr, "Can't deallocate console %d %s\n", vtno, strerror(errno));
	close (fd);
d333 1
a333 1
KdOsAddInputDrivers (void)
d357 1
a357 1
              (((unsigned long)duration * volume / 50) << 16));
d360 1
a360 1
KdOsFuncs   LinuxFuncs = {
d369 1
a369 1
OsVendorInit (void)
d371 1
a371 1
    KdOsInit (&LinuxFuncs);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d2 1
a2 1
 * Copyright © 1999 Keith Packard
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a26 1
#include "klinux.h"
d36 16
d98 1
a98 1
	if ((fd = open("/dev/tty0",O_WRONLY,0)) < 0) 
d109 1
a110 1
    close(fd);
a142 104
Bool
LinuxFindPci (CARD16 vendor, CARD16 device, CARD32 count, KdCardAttr *attr)
{
    FILE    *f;
    char    line[2048], *l, *end;
    CARD32  bus, id, addr;
    int	    n;
    CARD32  ven_dev;
    Bool    ret = FALSE;
    int	    i;

    attr->vendorID = vendor;
    attr->deviceID = device;
    ven_dev = (((CARD32) vendor) << 16) | ((CARD32) device);
    f = fopen ("/proc/bus/pci/devices", "r");
    if (!f)
	return FALSE;
    attr->io = 0;
    while (fgets (line, sizeof (line)-1, f))
    {
	line[sizeof(line)-1] = '\0';
	l = line;
	bus = strtoul (l, &end, 16);
	if (end == l)
	    continue;
	l = end;
	id = strtoul (l, &end, 16);
	if (end == l)
	    continue;
	l = end;
	if (id != ven_dev)
	    continue;
	if (count--)
	    continue;
	(void) strtoul (l, &end, 16);	/* IRQ */
	if (end == l)
	    continue;
	l = end;
	n = 0;
	for (i = 0; i < 6; i++)
	{
	    addr = strtoul (l, &end, 16);
	    if (end == l)
		break;
	    if (addr & 1)
		attr->io = addr & ~0xf;
	    else
	    {
		if (n == KD_MAX_CARD_ADDRESS)
		    break;
		attr->address[n++] = addr & ~0xf;
	    }
	    l = end;
	}
	while (n > 0)
	{
	    if (attr->address[n-1] != 0)
		break;
	    n--;
	}
	attr->naddr = n;
	attr->domain = 0; /* XXX */
	attr->bus = (bus >> 8) & 0xff;
	attr->slot = (bus >> 3) & 0x1f;
	attr->func = bus & 0x07;
	ret = TRUE;
	break;
    }
    fclose (f);
    return ret;
}

unsigned char *
LinuxGetPciCfg(KdCardAttr *attr) 
{
    char filename[256];
    FILE *f;
    unsigned char *cfg;
    int r;

    snprintf(filename, 255, "/proc/bus/pci/%02x/%02x.%x",
             attr->bus >> 8, (attr->bus & 0xff) >> 3, attr->bus & 7);
/*     fprintf(stderr,"Find card on path %s\n",filename); */

    if (!(f=fopen(filename,"r"))) 
        return NULL;

    if (!(cfg=xalloc(256))) 
    {
        fclose(f);
        return NULL;
    }

    if (256 != (r=fread(cfg, 1, 256, f)))
    {
        fprintf(stderr,"LinuxGetPciCfg: read %d, expected 256\n",r);
        free(cfg);
        cfg=NULL;
    }
    fclose(f);
/*     fprintf(stderr,"LinuxGetPciCfg: success, returning %p\n",cfg); */
    return cfg;
}

d148 2
a149 2
    
    if (ioctl(LinuxConsoleFd, VT_GETMODE, &VT) < 0) 
d160 1
a160 1
    
d171 1
a171 1
    
d176 1
a176 1
    if (ioctl(LinuxConsoleFd, VT_SETMODE, &VT) < 0) 
d256 1
a256 1
	LinuxApmFd = open ("/dev/misc/apm_bios", 2); 
d264 1
a264 1
	
d327 2
a328 2
	if (activeVT < 0 || 
	    activeVT == vts.v_active || 
d362 1
a362 1
KdOsAddInputDrivers ()
d364 1
d368 1
d372 1
d374 3
d378 1
a378 1
    KdAddKeyboardDriver(&LinuxEvdevKeyboardDriver);
@


1.1
log
@Initial revision
@
text
@a1 2
 * $RCSId: xc/programs/Xserver/hw/kdrive/linux/linux.c,v 1.6 2001/07/24 21:26:17 keithp Exp $
 *
a373 20
static Bool
LinuxSpecialKey (KeySym sym)
{
    struct vt_stat  vts;
    int		    con;
    
    if (XK_F1 <= sym && sym <= XK_F12)
    {
	con = sym - XK_F1 + 1;
	memset (&vts, '\0', sizeof (vts));	/* valgrind */
	ioctl (LinuxConsoleFd, VT_GETSTATE, &vts);
	if (con != vts.v_active && (vts.v_state & (1 << con)))
	{
	    ioctl (LinuxConsoleFd, VT_ACTIVATE, con);
	    return TRUE;
	}
    }
    return FALSE;
}

d437 1
d444 1
a444 1
	    fprintf (stderr, "Can't deallocate console %d errno %d\n", vtno, errno);
d450 22
d473 5
a477 6
    LinuxInit,
    LinuxEnable,
    LinuxSpecialKey,
    LinuxDisable,
    LinuxFini,
    0
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d376 20
a458 1
    LinuxConsoleFd = -1;
a470 22
void
KdOsAddInputDrivers ()
{
    KdAddPointerDriver(&LinuxMouseDriver);
    KdAddPointerDriver(&MsMouseDriver);
    KdAddPointerDriver(&Ps2MouseDriver);
#ifdef TSLIB
    KdAddPointerDriver(&TsDriver);
#endif
    KdAddPointerDriver(&LinuxEvdevMouseDriver);
    KdAddKeyboardDriver(&LinuxKeyboardDriver);
    KdAddKeyboardDriver(&LinuxEvdevKeyboardDriver);
}

static void
LinuxBell(int volume, int pitch, int duration)
{
    if (volume && pitch)
        ioctl(LinuxConsoleFd, KDMKTONE, ((1193190 / pitch) & 0xffff) |
              (((unsigned long)duration * volume / 50) << 16));
}

d472 6
a477 5
    .Init = LinuxInit,
    .Enable = LinuxEnable,
    .Disable = LinuxDisable,
    .Fini = LinuxFini,
    .Bell = LinuxBell,
@

