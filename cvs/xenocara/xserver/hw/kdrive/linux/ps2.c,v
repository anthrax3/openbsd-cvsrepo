head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.10
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.8
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.01.31.07.52.36;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.14;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.04.18;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@/*
 * Copyright Â© 1999 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/Xpoll.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "kdrive.h"

static int
Ps2ReadBytes(int fd, char *buf, int len, int min)
{
    int n, tot;
    fd_set set;
    struct timeval tv;

    tot = 0;
    while (len) {
        n = read(fd, buf, len);
        if (n > 0) {
            tot += n;
            buf += n;
            len -= n;
        }
        if (tot % min == 0)
            break;
        FD_ZERO(&set);
        FD_SET(fd, &set);
        tv.tv_sec = 0;
        tv.tv_usec = 100 * 1000;
        n = select(fd + 1, &set, 0, 0, &tv);
        if (n <= 0)
            break;
    }
    return tot;
}

const char *Ps2Names[] = {
    "/dev/psaux",
/*    "/dev/mouse", */
    "/dev/input/mice",
};

#define NUM_PS2_NAMES	(sizeof (Ps2Names) / sizeof (Ps2Names[0]))

static void
Ps2Read(int ps2Port, void *closure)
{
    unsigned char buf[3 * 200];
    unsigned char *b;
    int n;
    int dx, dy;
    unsigned long flags;
    unsigned long left_button = KD_BUTTON_1;
    unsigned long right_button = KD_BUTTON_3;

#undef SWAP_USB
#ifdef SWAP_USB
    if (id == 2) {
        left_button = KD_BUTTON_3;
        right_button = KD_BUTTON_1;
    }
#endif
    while ((n = Ps2ReadBytes(ps2Port, (char *) buf, sizeof(buf), 3)) > 0) {
        b = buf;
        while (n >= 3) {
            flags = KD_MOUSE_DELTA;
            if (b[0] & 4)
                flags |= KD_BUTTON_2;
            if (b[0] & 2)
                flags |= right_button;
            if (b[0] & 1)
                flags |= left_button;

            dx = b[1];
            if (b[0] & 0x10)
                dx -= 256;
            dy = b[2];
            if (b[0] & 0x20)
                dy -= 256;
            dy = -dy;
            n -= 3;
            b += 3;
            KdEnqueuePointerEvent(closure, flags, dx, dy, 0);
        }
    }
}

static Status
Ps2Init(KdPointerInfo * pi)
{
    int ps2Port, i;

    if (!pi->path) {
        for (i = 0; i < NUM_PS2_NAMES; i++) {
            ps2Port = open(Ps2Names[i], 0);
            if (ps2Port >= 0) {
                pi->path = strdup(Ps2Names[i]);
                break;
            }
        }
    }
    else {
        ps2Port = open(pi->path, 0);
    }

    if (ps2Port < 0)
        return BadMatch;

    close(ps2Port);
    if (!pi->name)
        pi->name = strdup("PS/2 Mouse");

    return Success;
}

static Status
Ps2Enable(KdPointerInfo * pi)
{
    int fd;

    if (!pi)
        return BadImplementation;

    fd = open(pi->path, 0);
    if (fd < 0)
        return BadMatch;

    if (!KdRegisterFd(fd, Ps2Read, pi)) {
        close(fd);
        return BadAlloc;
    }

    pi->driverPrivate = (void *) (intptr_t) fd;

    return Success;
}

static void
Ps2Disable(KdPointerInfo * pi)
{
    KdUnregisterFd(pi, (int) (intptr_t) pi->driverPrivate, TRUE);
}

static void
Ps2Fini(KdPointerInfo * pi)
{
}

KdPointerDriver Ps2MouseDriver = {
    "ps2",
    Ps2Init,
    Ps2Enable,
    Ps2Disable,
    Ps2Fini,
    NULL,
};
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d61 1
a61 1
char *Ps2Names[] = {
@


1.4
log
@Update to xserver 1.11.4. tested by krw@@, shadchin@@.
@
text
@d34 1
a34 1
Ps2ReadBytes (int fd, char *buf, int len, int min)
d36 3
a38 3
    int		    n, tot;
    fd_set	    set;
    struct timeval  tv;
d41 16
a56 18
    while (len)
    {
	n = read (fd, buf, len);
	if (n > 0)
	{
	    tot += n;
	    buf += n;
	    len -= n;
	}
	if (tot % min == 0)
	    break;
	FD_ZERO (&set);
	FD_SET (fd, &set);
	tv.tv_sec = 0;
	tv.tv_usec = 100 * 1000;
	n = select (fd + 1, &set, 0, 0, &tv);
	if (n <= 0)
	    break;
d61 1
a61 1
char	*Ps2Names[] = {
d70 1
a70 1
Ps2Read (int ps2Port, void *closure)
d72 7
a78 7
    unsigned char   buf[3 * 200];
    unsigned char   *b;
    int		    n;
    int		    dx, dy;
    unsigned long   flags;
    unsigned long   left_button = KD_BUTTON_1;
    unsigned long   right_button = KD_BUTTON_3;
d82 3
a84 4
    if (id == 2)
    {
	left_button = KD_BUTTON_3;
	right_button = KD_BUTTON_1;
d87 22
a108 24
    while ((n = Ps2ReadBytes (ps2Port, (char *) buf, sizeof (buf), 3)) > 0)
    {
	b = buf;
	while (n >= 3)
	{
	    flags = KD_MOUSE_DELTA;
	    if (b[0] & 4)
		flags |= KD_BUTTON_2;
	    if (b[0] & 2)
		flags |= right_button;
	    if (b[0] & 1)
		flags |= left_button;

	    dx = b[1];
	    if (b[0] & 0x10)
		dx -= 256;
	    dy = b[2];
	    if (b[0] & 0x20)
		dy -= 256;
	    dy = -dy;
	    n -= 3;
	    b += 3;
	    KdEnqueuePointerEvent (closure, flags, dx, dy, 0);
	}
d113 1
a113 1
Ps2Init (KdPointerInfo *pi)
d115 1
a115 1
    int	ps2Port, i;
d119 1
a119 1
            ps2Port = open (Ps2Names[i], 0);
d121 1
a121 1
                pi->path = strdup (Ps2Names[i]);
d124 1
a124 1
	}
d127 1
a127 1
        ps2Port = open (pi->path, 0);
d135 1
a135 1
        pi->name = strdup ("PS/2 Mouse");
d141 1
a141 1
Ps2Enable (KdPointerInfo *pi)
d148 1
a148 1
    fd = open (pi->path, 0);
d152 1
a152 1
    if (!KdRegisterFd (fd, Ps2Read, pi)) {
d157 1
a157 1
    pi->driverPrivate = (void *)(intptr_t)fd;
a161 1

d163 1
a163 1
Ps2Disable (KdPointerInfo *pi)
d165 1
a165 1
    KdUnregisterFd (pi, (int)(intptr_t)pi->driverPrivate, TRUE);
d169 1
a169 1
Ps2Fini (KdPointerInfo *pi)
@


1.3
log
@Update to xserver 1.11.2
@
text
@d162 1
a162 1
    pi->driverPrivate = (void *)fd;
d171 1
a171 1
    KdUnregisterFd (pi, (int)pi->driverPrivate, TRUE);
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d2 1
a2 1
 * Copyright © 1999 Keith Packard
@


1.1
log
@Initial revision
@
text
@a1 2
 * $RCSId: xc/programs/Xserver/hw/kdrive/linux/ps2.c,v 1.6 2001/10/12 06:33:10 keithp Exp $
 *
a25 1
#define NEED_EVENTS
d102 1
a102 1
		
d112 1
a112 1
	    KdEnqueueMouseEvent (kdMouseInfo, flags, dx, dy);
d117 24
a140 1
int Ps2InputType;
d142 5
a146 2
static int
Ps2Init (void)
d148 12
a159 15
    int	    i;
    int	    ps2Port;
    int	    n;

    if (!Ps2InputType)
	Ps2InputType = KdAllocInputType ();
    n = 0;
    for (i = 0; i < NUM_PS2_NAMES; i++)
    {
	ps2Port = open (Ps2Names[i], 0);
	if (ps2Port >= 0)
	{
	    if (KdRegisterFd (Ps2InputType, ps2Port, Ps2Read, (void *) i))
		n++;
	}
d161 11
a171 1
    return n;
d175 1
a175 1
Ps2Fini (void)
a176 1
    KdUnregisterFds (Ps2InputType, TRUE);
d179 2
a180 1
KdMouseFuncs Ps2MouseFuncs = {
d182 4
a185 1
    Ps2Fini
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d115 1
a115 1
	    KdEnqueuePointerEvent (closure, flags, dx, dy, 0);
d120 4
a123 2
static Status
Ps2Init (KdPointerInfo *pi)
d125 14
a138 9
    int	ps2Port, i;

    if (!pi->path) {
        for (i = 0; i < NUM_PS2_NAMES; i++) {
            ps2Port = open (Ps2Names[i], 0);
            if (ps2Port >= 0) {
                pi->path = KdSaveString (Ps2Names[i]);
                break;
            }
d141 1
a141 41
    else {
        ps2Port = open (pi->path, 0);
    }

    if (ps2Port < 0)
        return BadMatch;

    close(ps2Port);
    if (!pi->name)
        pi->name = KdSaveString ("PS/2 Mouse");

    return Success;
}

static Status
Ps2Enable (KdPointerInfo *pi)
{
    int fd;
    
    if (!pi)
        return BadImplementation;

    fd = open (pi->path, 0);
    if (fd < 0)
        return BadMatch;

    if (!KdRegisterFd (fd, Ps2Read, pi)) {
        close(fd);
        return BadAlloc;
    }

    pi->driverPrivate = (void *)fd;

    return Success;
}


static void
Ps2Disable (KdPointerInfo *pi)
{
    KdUnregisterFd (pi, (int)pi->driverPrivate, TRUE);
d145 1
a145 1
Ps2Fini (KdPointerInfo *pi)
d147 1
d150 1
a150 2
KdPointerDriver Ps2MouseDriver = {
    "ps2",
d152 1
a152 4
    Ps2Enable,
    Ps2Disable,
    Ps2Fini,
    NULL,
@

