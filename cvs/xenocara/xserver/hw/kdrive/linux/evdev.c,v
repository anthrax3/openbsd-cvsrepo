head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.8
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.05.29.12.02.36;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	s0SI41sEunLdyFfd;

1.6
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.24;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.13;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.13;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.04.18;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright Â© 2004 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif
#include <errno.h>
#include <linux/input.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/Xpoll.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "kdrive.h"

#define NUM_EVENTS  128
#define ABS_UNSET   -65535

#define BITS_PER_LONG (sizeof(long) * 8)
#define NBITS(x) ((((x)-1)/BITS_PER_LONG)+1)
#define ISBITSET(x,y) ((x)[LONG(y)] & BIT(y))
#define OFF(x)   ((x)%BITS_PER_LONG)
#define LONG(x)  ((x)/BITS_PER_LONG)
#define BIT(x)         (1 << OFF(x))

typedef struct _kevdev {
    /* current device state */
    int rel[REL_MAX + 1];
    int abs[ABS_MAX + 1];
    int prevabs[ABS_MAX + 1];
    long key[NBITS(KEY_MAX + 1)];

    /* supported device info */
    long relbits[NBITS(REL_MAX + 1)];
    long absbits[NBITS(ABS_MAX + 1)];
    long keybits[NBITS(KEY_MAX + 1)];
    struct input_absinfo absinfo[ABS_MAX + 1];
    int max_rel;
    int max_abs;

    int fd;
} Kevdev;

static void
EvdevPtrBtn(KdPointerInfo * pi, struct input_event *ev)
{
    int flags = KD_MOUSE_DELTA | pi->buttonState;

    if (ev->code >= BTN_MOUSE && ev->code < BTN_JOYSTICK) {
        switch (ev->code) {
        case BTN_LEFT:
            if (ev->value == 1)
                flags |= KD_BUTTON_1;
            else
                flags &= ~KD_BUTTON_1;
            break;
        case BTN_MIDDLE:
            if (ev->value == 1)
                flags |= KD_BUTTON_2;
            else
                flags &= ~KD_BUTTON_2;
            break;
        case BTN_RIGHT:
            if (ev->value == 1)
                flags |= KD_BUTTON_3;
            else
                flags &= ~KD_BUTTON_3;
            break;
        default:
            /* Unknow button */
            break;
        }

        KdEnqueuePointerEvent(pi, flags, 0, 0, 0);
    }
}

static void
EvdevPtrMotion(KdPointerInfo * pi, struct input_event *ev)
{
    Kevdev *ke = pi->driverPrivate;
    int i;
    int flags = KD_MOUSE_DELTA | pi->buttonState;

    for (i = 0; i <= ke->max_rel; i++)
        if (ke->rel[i]) {
            int a;

            for (a = 0; a <= ke->max_rel; a++) {
                if (ISBITSET(ke->relbits, a)) {
                    if (a == 0)
                        KdEnqueuePointerEvent(pi, flags, ke->rel[a], 0, 0);
                    else if (a == 1)
                        KdEnqueuePointerEvent(pi, flags, 0, ke->rel[a], 0);
                }
                ke->rel[a] = 0;
            }
            break;
        }
    for (i = 0; i < ke->max_abs; i++)
        if (ke->abs[i] != ke->prevabs[i]) {
            int a;

            ErrorF("abs");
            for (a = 0; a <= ke->max_abs; a++) {
                if (ISBITSET(ke->absbits, a))
                    ErrorF(" %d=%d", a, ke->abs[a]);
                ke->prevabs[a] = ke->abs[a];
            }
            ErrorF("\n");
            break;
        }

    if (ev->code == REL_WHEEL) {
        for (i = 0; i < abs(ev->value); i++) {
            if (ev->value > 0)
                flags |= KD_BUTTON_4;
            else
                flags |= KD_BUTTON_5;

            KdEnqueuePointerEvent(pi, flags, 0, 0, 0);

            if (ev->value > 0)
                flags &= ~KD_BUTTON_4;
            else
                flags &= ~KD_BUTTON_5;

            KdEnqueuePointerEvent(pi, flags, 0, 0, 0);
        }
    }

}

static void
EvdevPtrRead(int evdevPort, void *closure)
{
    KdPointerInfo *pi = closure;
    Kevdev *ke = pi->driverPrivate;
    int i;
    struct input_event events[NUM_EVENTS];
    int n;

    n = read(evdevPort, &events, NUM_EVENTS * sizeof(struct input_event));
    if (n <= 0) {
        if (errno == ENODEV)
            DeleteInputDeviceRequest(pi->dixdev);
        return;
    }

    n /= sizeof(struct input_event);
    for (i = 0; i < n; i++) {
        switch (events[i].type) {
        case EV_SYN:
            break;
        case EV_KEY:
            EvdevPtrBtn(pi, &events[i]);
            break;
        case EV_REL:
            ke->rel[events[i].code] += events[i].value;
            EvdevPtrMotion(pi, &events[i]);
            break;
        case EV_ABS:
            ke->abs[events[i].code] = events[i].value;
            EvdevPtrMotion(pi, &events[i]);
            break;
        }
    }
}

const char *kdefaultEvdev[] = {
    "/dev/input/event0",
    "/dev/input/event1",
    "/dev/input/event2",
    "/dev/input/event3",
};

#define NUM_DEFAULT_EVDEV    (sizeof (kdefaultEvdev) / sizeof (kdefaultEvdev[0]))

static Status
EvdevPtrInit(KdPointerInfo * pi)
{
    int i;
    int fd;

    if (!pi->path) {
        for (i = 0; i < NUM_DEFAULT_EVDEV; i++) {
            fd = open(kdefaultEvdev[i], 2);
            if (fd >= 0) {
                pi->path = strdup(kdefaultEvdev[i]);
                break;
            }
        }
    }
    else {
        fd = open(pi->path, O_RDWR);
        if (fd < 0) {
            ErrorF("Failed to open evdev device %s\n", pi->path);
            return BadMatch;
        }
    }

    close(fd);

    pi->name = strdup("Evdev mouse");

    return Success;
}

static Status
EvdevPtrEnable(KdPointerInfo * pi)
{
    int fd;
    unsigned long ev[NBITS(EV_MAX)];
    Kevdev *ke;

    if (!pi || !pi->path)
        return BadImplementation;

    fd = open(pi->path, 2);
    if (fd < 0)
        return BadMatch;

    if (ioctl(fd, EVIOCGRAB, 1) < 0)
        perror("Grabbing evdev mouse device failed");

    if (ioctl(fd, EVIOCGBIT(0 /*EV*/, sizeof(ev)), ev) < 0) {
        perror("EVIOCGBIT 0");
        close(fd);
        return BadMatch;
    }
    ke = calloc(1, sizeof(Kevdev));
    if (!ke) {
        close(fd);
        return BadAlloc;
    }
    if (ISBITSET(ev, EV_KEY)) {
        if (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(ke->keybits)), ke->keybits) < 0) {
            perror("EVIOCGBIT EV_KEY");
            free(ke);
            close(fd);
            return BadMatch;
        }
    }
    if (ISBITSET(ev, EV_REL)) {
        if (ioctl(fd, EVIOCGBIT(EV_REL, sizeof(ke->relbits)), ke->relbits) < 0) {
            perror("EVIOCGBIT EV_REL");
            free(ke);
            close(fd);
            return BadMatch;
        }
        for (ke->max_rel = REL_MAX; ke->max_rel >= 0; ke->max_rel--)
            if (ISBITSET(ke->relbits, ke->max_rel))
                break;
    }
    if (ISBITSET(ev, EV_ABS)) {
        int i;

        if (ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(ke->absbits)), ke->absbits) < 0) {
            perror("EVIOCGBIT EV_ABS");
            free(ke);
            close(fd);
            return BadMatch;
        }
        for (ke->max_abs = ABS_MAX; ke->max_abs >= 0; ke->max_abs--)
            if (ISBITSET(ke->absbits, ke->max_abs))
                break;
        for (i = 0; i <= ke->max_abs; i++) {
            if (ISBITSET(ke->absbits, i))
                if (ioctl(fd, EVIOCGABS(i), &ke->absinfo[i]) < 0) {
                    perror("EVIOCGABS");
                    break;
                }
            ke->prevabs[i] = ABS_UNSET;
        }
        if (i <= ke->max_abs) {
            free(ke);
            close(fd);
            return BadValue;
        }
    }
    if (!KdRegisterFd(fd, EvdevPtrRead, pi)) {
        free(ke);
        close(fd);
        return BadAlloc;
    }
    pi->driverPrivate = ke;
    ke->fd = fd;

    return Success;
}

static void
EvdevPtrDisable(KdPointerInfo * pi)
{
    Kevdev *ke;

    ke = pi->driverPrivate;

    if (!pi || !pi->driverPrivate)
        return;

    KdUnregisterFd(pi, ke->fd, TRUE);

    if (ioctl(ke->fd, EVIOCGRAB, 0) < 0)
        perror("Ungrabbing evdev mouse device failed");

    free(ke);
    pi->driverPrivate = 0;
}

static void
EvdevPtrFini(KdPointerInfo * pi)
{
}

/*
 * Evdev keyboard functions
 */

static void
readMapping(KdKeyboardInfo * ki)
{
    if (!ki)
        return;

    ki->minScanCode = 0;
    ki->maxScanCode = 247;
}

static void
EvdevKbdRead(int evdevPort, void *closure)
{
    KdKeyboardInfo *ki = closure;
    struct input_event events[NUM_EVENTS];
    int i, n;

    n = read(evdevPort, &events, NUM_EVENTS * sizeof(struct input_event));
    if (n <= 0) {
        if (errno == ENODEV)
            DeleteInputDeviceRequest(ki->dixdev);
        return;
    }

    n /= sizeof(struct input_event);
    for (i = 0; i < n; i++) {
        if (events[i].type == EV_KEY)
            KdEnqueueKeyboardEvent(ki, events[i].code, !events[i].value);
/* FIXME: must implement other types of events
        else
            ErrorF("Event type (%d) not delivered\n", events[i].type);
*/
    }
}

static Status
EvdevKbdInit(KdKeyboardInfo * ki)
{
    int fd;

    if (!ki->path) {
        ErrorF("Couldn't find evdev device path\n");
        return BadValue;
    }
    else {
        fd = open(ki->path, O_RDWR);
        if (fd < 0) {
            ErrorF("Failed to open evdev device %s\n", ki->path);
            return BadMatch;
        }
    }

    close(fd);

    ki->name = strdup("Evdev keyboard");

    readMapping(ki);

    return Success;
}

static Status
EvdevKbdEnable(KdKeyboardInfo * ki)
{
    unsigned long ev[NBITS(EV_MAX)];
    Kevdev *ke;
    int fd;

    if (!ki || !ki->path)
        return BadImplementation;

    fd = open(ki->path, O_RDWR);
    if (fd < 0)
        return BadMatch;

    if (ioctl(fd, EVIOCGRAB, 1) < 0)
        perror("Grabbing evdev keyboard device failed");

    if (ioctl(fd, EVIOCGBIT(0 /*EV*/, sizeof(ev)), ev) < 0) {
        perror("EVIOCGBIT 0");
        close(fd);
        return BadMatch;
    }

    ke = calloc(1, sizeof(Kevdev));
    if (!ke) {
        close(fd);
        return BadAlloc;
    }

    if (!KdRegisterFd(fd, EvdevKbdRead, ki)) {
        free(ke);
        close(fd);
        return BadAlloc;
    }
    ki->driverPrivate = ke;
    ke->fd = fd;

    return Success;
}

static void
EvdevKbdLeds(KdKeyboardInfo * ki, int leds)
{
    struct input_event event;
    Kevdev             *ke;

    if (!ki)
        return;

    ke = ki->driverPrivate;

    if (!ke)
        return;

    memset(&event, 0, sizeof(event));

    event.type = EV_LED;
    event.code = LED_CAPSL;
    event.value = leds & (1 << 0) ? 1 : 0;
    write(ke->fd, (char *) &event, sizeof(event));

    event.type = EV_LED;
    event.code = LED_NUML;
    event.value = leds & (1 << 1) ? 1 : 0;
    write(ke->fd, (char *) &event, sizeof(event));

    event.type = EV_LED;
    event.code = LED_SCROLLL;
    event.value = leds & (1 << 2) ? 1 : 0;
    write(ke->fd, (char *) &event, sizeof(event));

    event.type = EV_LED;
    event.code = LED_COMPOSE;
    event.value = leds & (1 << 3) ? 1 : 0;
    write(ke->fd, (char *) &event, sizeof(event));
}

static void
EvdevKbdBell(KdKeyboardInfo * ki, int volume, int frequency, int duration)
{
}

static void
EvdevKbdDisable(KdKeyboardInfo * ki)
{
    Kevdev *ke;

    ke = ki->driverPrivate;

    if (!ki || !ki->driverPrivate)
        return;

    KdUnregisterFd(ki, ke->fd, TRUE);

    if (ioctl(ke->fd, EVIOCGRAB, 0) < 0)
        perror("Ungrabbing evdev keyboard device failed");

    free(ke);
    ki->driverPrivate = 0;
}

static void
EvdevKbdFini(KdKeyboardInfo * ki)
{
}

KdPointerDriver LinuxEvdevMouseDriver = {
    "evdev",
    EvdevPtrInit,
    EvdevPtrEnable,
    EvdevPtrDisable,
    EvdevPtrFini,
    NULL,
};

KdKeyboardDriver LinuxEvdevKeyboardDriver = {
    "evdev",
    EvdevKbdInit,
    EvdevKbdEnable,
    EvdevKbdLeds,
    EvdevKbdBell,
    EvdevKbdDisable,
    EvdevKbdFini,
    NULL,
};
@


1.6
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d443 1
a443 1
/*    struct input_event event;
d446 7
a452 1
    ki->driverPrivate = ke;
a474 1
*/
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d189 1
a189 1
char *kdefaultEvdev[] = {
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d47 4
a50 4
    int                            rel[REL_MAX + 1];
    int                            abs[ABS_MAX + 1];
    int                            prevabs[ABS_MAX + 1];
    long                    key[NBITS(KEY_MAX + 1)];
d53 6
a58 6
    long                    relbits[NBITS(REL_MAX + 1)];
    long                    absbits[NBITS(ABS_MAX + 1)];
    long                    keybits[NBITS(KEY_MAX + 1)];
    struct input_absinfo    absinfo[ABS_MAX + 1];
    int                            max_rel;
    int                            max_abs;
d60 1
a60 1
    int                     fd;
d64 1
a64 1
EvdevPtrBtn (KdPointerInfo    *pi, struct input_event *ev)
d73 1
a73 1
	    else
d75 1
a75 1
             break;
d79 2
a80 2
	    else
		flags &= ~KD_BUTTON_2;
d85 2
a86 2
	    else
		flags &= ~KD_BUTTON_3;
d93 1
a93 1
        KdEnqueuePointerEvent (pi, flags, 0, 0, 0);
d96 1
d98 1
a98 1
EvdevPtrMotion (KdPointerInfo    *pi, struct input_event *ev)
d100 1
a100 1
    Kevdev                *ke = pi->driverPrivate;
d105 1
a105 2
        if (ke->rel[i])
        {
d107 3
a109 4
            for (a = 0; a <= ke->max_rel; a++)
            {
                if (ISBITSET (ke->relbits, a))
		{
d115 1
a115 1
		ke->rel[a] = 0;
d120 1
a120 2
        if (ke->abs[i] != ke->prevabs[i])
        {
d122 5
a126 5
            ErrorF ("abs");
            for (a = 0; a <= ke->max_abs; a++)
            {
                if (ISBITSET (ke->absbits, a))
                    ErrorF (" %d=%d", a, ke->abs[a]);
d129 1
a129 1
            ErrorF ("\n");
d134 5
a138 6
      for (i = 0; i < abs (ev->value); i++)
      {
        if (ev->value > 0)
          flags |= KD_BUTTON_4;
        else
          flags |= KD_BUTTON_5;
d140 1
a140 1
        KdEnqueuePointerEvent (pi, flags, 0, 0, 0);
d142 4
a145 4
        if (ev->value > 0)
          flags &= ~KD_BUTTON_4;
        else
          flags &= ~KD_BUTTON_5;
d147 2
a148 2
        KdEnqueuePointerEvent (pi, flags, 0, 0, 0);
      }
d154 1
a154 1
EvdevPtrRead (int evdevPort, void *closure)
d156 5
a160 5
    KdPointerInfo                *pi = closure;
    Kevdev                       *ke = pi->driverPrivate;
    int                        i;
    struct input_event        events[NUM_EVENTS];
    int                        n;
d162 1
a162 1
    n = read (evdevPort, &events, NUM_EVENTS * sizeof (struct input_event));
d169 2
a170 3
    n /= sizeof (struct input_event);
    for (i = 0; i < n; i++)
    {
d175 1
a175 1
            EvdevPtrBtn (pi, &events[i]);
d179 1
a179 1
            EvdevPtrMotion (pi, &events[i]);
d183 1
a183 1
            EvdevPtrMotion (pi, &events[i]);
d189 1
a189 1
char *kdefaultEvdev[] =  {
d199 1
a199 1
EvdevPtrInit (KdPointerInfo *pi)
d201 2
a202 2
    int                i;
    int                fd;
d206 1
a206 1
            fd = open (kdefaultEvdev[i], 2);
d208 1
a208 1
                pi->path = strdup (kdefaultEvdev[i]);
d214 1
a214 1
        fd = open (pi->path, O_RDWR);
d229 1
a229 1
EvdevPtrEnable (KdPointerInfo *pi)
d232 2
a233 2
    unsigned long   ev[NBITS(EV_MAX)];
    Kevdev            *ke;
d242 2
a243 2
    if (ioctl (fd, EVIOCGRAB, 1) < 0)
        perror ("Grabbing evdev mouse device failed");
d245 3
a247 4
    if (ioctl (fd, EVIOCGBIT(0 /*EV*/, sizeof (ev)), ev) < 0)
    {
        perror ("EVIOCGBIT 0");
        close (fd);
d250 3
a252 4
    ke = calloc(1, sizeof (Kevdev));
    if (!ke)
    {
        close (fd);
d255 3
a257 6
    if (ISBITSET (ev, EV_KEY))
    {
        if (ioctl (fd, EVIOCGBIT (EV_KEY, sizeof (ke->keybits)),
                   ke->keybits) < 0)
        {
            perror ("EVIOCGBIT EV_KEY");
d259 1
a259 1
            close (fd);
d263 3
a265 6
    if (ISBITSET (ev, EV_REL))
    {
        if (ioctl (fd, EVIOCGBIT (EV_REL, sizeof (ke->relbits)),
                       ke->relbits) < 0)
        {
            perror ("EVIOCGBIT EV_REL");
d267 1
a267 1
            close (fd);
d274 1
a274 2
    if (ISBITSET (ev, EV_ABS))
    {
d277 2
a278 4
        if (ioctl (fd, EVIOCGBIT (EV_ABS, sizeof (ke->absbits)),
                   ke->absbits) < 0)
            {
            perror ("EVIOCGBIT EV_ABS");
d280 1
a280 1
            close (fd);
d286 4
a289 6
        for (i = 0; i <= ke->max_abs; i++)
        {
            if (ISBITSET (ke->absbits, i))
                if (ioctl (fd, EVIOCGABS(i), &ke->absinfo[i]) < 0)
                {
                    perror ("EVIOCGABS");
d294 1
a294 2
        if (i <= ke->max_abs)
        {
d296 1
a296 1
            close (fd);
d300 1
a300 1
    if (!KdRegisterFd (fd, EvdevPtrRead, pi)) {
d302 1
a302 1
        close (fd);
d312 1
a312 1
EvdevPtrDisable (KdPointerInfo *pi)
d314 1
a314 1
    Kevdev              *ke;
d321 1
a321 1
    KdUnregisterFd (pi, ke->fd, TRUE);
d323 2
a324 2
    if (ioctl (ke->fd, EVIOCGRAB, 0) < 0)
        perror ("Ungrabbing evdev mouse device failed");
d331 1
a331 1
EvdevPtrFini (KdPointerInfo *pi)
a334 1

d340 1
a340 1
readMapping (KdKeyboardInfo *ki)
d350 1
a350 1
EvdevKbdRead (int evdevPort, void *closure)
d352 3
a354 3
    KdKeyboardInfo	 *ki = closure;
    struct input_event	 events[NUM_EVENTS];
    int			 i, n;
d356 1
a356 1
    n = read (evdevPort, &events, NUM_EVENTS * sizeof (struct input_event));
d363 2
a364 3
    n /= sizeof (struct input_event);
    for (i = 0; i < n; i++)
    {
d366 1
a366 1
	    KdEnqueueKeyboardEvent (ki, events[i].code, !events[i].value);
d375 1
a375 1
EvdevKbdInit (KdKeyboardInfo *ki)
d384 1
a384 1
        fd = open (ki->path, O_RDWR);
d391 1
a391 1
    close (fd);
d401 1
a401 1
EvdevKbdEnable (KdKeyboardInfo *ki)
d403 3
a405 3
    unsigned long       ev[NBITS(EV_MAX)];
    Kevdev              *ke;
    int                 fd;
d414 2
a415 2
    if (ioctl (fd, EVIOCGRAB, 1) < 0)
        perror ("Grabbing evdev keyboard device failed");
d417 3
a419 3
    if (ioctl (fd, EVIOCGBIT(0 /*EV*/, sizeof (ev)), ev) < 0) {
        perror ("EVIOCGBIT 0");
        close (fd);
d423 1
a423 1
    ke = calloc(1, sizeof (Kevdev));
d425 1
a425 1
        close (fd);
d429 1
a429 1
    if (!KdRegisterFd (fd, EvdevKbdRead, ki)) {
d431 1
a431 1
        close (fd);
d441 1
a441 1
EvdevKbdLeds (KdKeyboardInfo *ki, int leds)
d473 1
a473 1
EvdevKbdBell (KdKeyboardInfo *ki, int volume, int frequency, int duration)
d478 1
a478 1
EvdevKbdDisable (KdKeyboardInfo *ki)
d480 1
a480 1
    Kevdev              *ke;
d487 1
a487 1
    KdUnregisterFd (ki, ke->fd, TRUE);
d489 2
a490 2
    if (ioctl (ke->fd, EVIOCGRAB, 0) < 0)
        perror ("Ungrabbing evdev keyboard device failed");
d497 1
a497 1
EvdevKbdFini (KdKeyboardInfo *ki)
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d255 1
a255 1
    ke = xcalloc (1, sizeof (Kevdev));
d267 1
a267 1
            xfree (ke);
d278 1
a278 1
            xfree (ke);
d294 1
a294 1
            xfree (ke);
d313 1
a313 1
            xfree (ke);
d319 1
a319 1
        xfree (ke);
d344 1
a344 1
    xfree (ke);
d443 1
a443 1
    ke = xcalloc (1, sizeof (Kevdev));
d450 1
a450 1
        xfree (ke);
d512 1
a512 1
    xfree (ke);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a25 1
#define NEED_EVENTS
d51 1
a51 1
    
d109 1
a109 1
                if (ISBITSET (ke->relbits, a)) 
d114 1
a114 1
                        KdEnqueuePointerEvent(pi, flags, 0, ke->rel[a], 0); 
d134 3
a136 3
    
    if (ev->code == REL_WHEEL) {           
      for (i = 0; i < abs (ev->value); i++) 
d153 1
a153 1
    
d167 1
a167 1
        if (errno == ENODEV) 
d212 1
a212 1
                pi->path = KdSaveString (kdefaultEvdev[i]);
d227 1
a227 1
    pi->name = KdSaveString("Evdev mouse");
d234 1
a234 1
{        
d236 2
d246 3
a248 3
    unsigned long   ev[NBITS(EV_MAX)];
    Kevdev            *ke;
        
d340 4
d355 1
a355 1
 * Evdev keyboard functions 
a360 2
    int             minScanCode, maxScanCode;

d364 2
a365 7
    minScanCode = 0;
    maxScanCode = 193;

    ki->keySyms.mapWidth = 2;

    ki->minScanCode = minScanCode;
    ki->maxScanCode = maxScanCode;		
d377 1
a377 1
        if (errno == ENODEV) 
d398 1
a398 1
    
d413 1
a413 1
    ki->name = KdSaveString("Evdev keyboard");
d434 3
d508 4
@


1.1
log
@Initial revision
@
text
@a1 2
 * $Id$
 *
d44 1
a44 4
#define BIT(x)	 (1 << OFF(x))
#define SETBIT(x,y) ((x)[LONG(y)] |= BIT(y))
#define CLRBIT(x,y) ((x)[LONG(y)] &= ~BIT(y))
#define ASSIGNBIT(x,y,z)    ((x)[LONG(y)] = ((x)[LONG(y)] & ~BIT(y)) | (z << OFF(y)))
d46 1
a46 1
typedef struct _kevdevMouse {
d48 4
a51 4
    int			    rel[REL_MAX + 1];
    int			    abs[ABS_MAX + 1];
    int			    prevabs[ABS_MAX + 1];
    long		    key[NBITS(KEY_MAX + 1)];
d54 3
a56 3
    long		    relbits[NBITS(REL_MAX + 1)];
    long		    absbits[NBITS(ABS_MAX + 1)];
    long		    keybits[NBITS(KEY_MAX + 1)];
d58 4
a61 2
    int			    max_rel;
    int			    max_abs;
d65 34
a98 1
EvdevMotion (KdMouseInfo    *mi)
d100 3
a102 2
    Kevdev		*ke = mi->driver;
    int			i;
d105 12
a116 8
	if (ke->rel[i])
	{
	    int a;
	    ErrorF ("rel");
	    for (a = 0; a <= ke->max_rel; a++)
	    {
		if (ISBITSET (ke->relbits, a))
		    ErrorF (" %d=%d", a, ke->rel[a]);
d118 3
a120 4
	    }
	    ErrorF ("\n");
	    break;
	}
d122 33
a154 13
	if (ke->abs[i] != ke->prevabs[i])
	{
	    int a;
	    ErrorF ("abs");
	    for (a = 0; a <= ke->max_abs; a++)
	    {
		if (ISBITSET (ke->absbits, a))
		    ErrorF (" %d=%d", a, ke->abs[a]);
		ke->prevabs[a] = ke->abs[a];
	    }
	    ErrorF ("\n");
	    break;
	}
d158 7
a164 7
EvdevRead (int evdevPort, void *closure)
{
    KdMouseInfo		*mi = closure;
    Kevdev		*ke = mi->driver;
    int			i;
    struct input_event	events[NUM_EVENTS];
    int			n;
d167 6
a172 2
    if (n <= 0)
	return;
d176 15
a190 18
	switch (events[i].type) {
	case EV_SYN:
	    break;
	case EV_KEY:
	    EvdevMotion (mi);
	    ASSIGNBIT(ke->key,events[i].code, events[i].value);
	    if (events[i].code < 0x100)
		ErrorF ("key %d %d\n", events[i].code, events[i].value);
	    else
		ErrorF ("key 0x%x %d\n", events[i].code, events[i].value);
	    break;
	case EV_REL:
	    ke->rel[events[i].code] += events[i].value;
	    break;
	case EV_ABS:
	    ke->abs[events[i].code] = events[i].value;
	    break;
	}
a191 1
    EvdevMotion (mi);
a193 2
int EvdevInputType;

d203 2
a204 2
static Bool
EvdevInit (void)
d206 2
a207 5
    int		i;
    int		fd;
    KdMouseInfo	*mi, *next;
    int		n = 0;
    char	*prot;
d209 20
a228 2
    if (!EvdevInputType)
	EvdevInputType = KdAllocInputType ();
d230 56
a285 1
    for (mi = kdMouseInfo; mi; mi = next)
d287 1
a287 65
	next = mi->next;
	prot = mi->prot;
	if (mi->inputType)
	    continue;
	if (!mi->name)
	{
	    for (i = 0; i < NUM_DEFAULT_EVDEV; i++)
	    {
		fd = open (kdefaultEvdev[i], 2);
		if (fd >= 0)
		{
		    mi->name = KdSaveString (kdefaultEvdev[i]);
		    break;
		}
	    }
	}
	else
	    fd = open (mi->name, 2);
	    
	if (fd >= 0)
	{
	    unsigned long   ev[NBITS(EV_MAX)];
	    Kevdev	    *ke;
	    
	    if (ioctl (fd, EVIOCGBIT(0 /*EV*/, sizeof (ev)), ev) < 0)
	    {
		perror ("EVIOCGBIT 0");
		close (fd);
		continue;
	    }
	    ke = xalloc (sizeof (Kevdev));
	    if (!ke)
	    {
		close (fd);
		continue;
	    }
	    memset (ke, '\0', sizeof (Kevdev));
	    if (ISBITSET (ev, EV_KEY))
	    {
		if (ioctl (fd, EVIOCGBIT (EV_KEY, sizeof (ke->keybits)),
			   ke->keybits) < 0)
		{
		    perror ("EVIOCGBIT EV_KEY");
		    xfree (ke);
		    close (fd);
		    continue;
		}
	    }
	    if (ISBITSET (ev, EV_REL))
	    {
		if (ioctl (fd, EVIOCGBIT (EV_REL, sizeof (ke->relbits)),
			   ke->relbits) < 0)
		{
		    perror ("EVIOCGBIT EV_REL");
		    xfree (ke);
		    close (fd);
		    continue;
		}
		for (ke->max_rel = REL_MAX; ke->max_rel >= 0; ke->max_rel--)
		    if (ISBITSET(ke->relbits, ke->max_rel))
			break;
	    }
	    if (ISBITSET (ev, EV_ABS))
	    {
		int i;
d289 32
a320 33
		if (ioctl (fd, EVIOCGBIT (EV_ABS, sizeof (ke->absbits)),
			   ke->absbits) < 0)
		{
		    perror ("EVIOCGBIT EV_ABS");
		    xfree (ke);
		    close (fd);
		    continue;
		}
		for (ke->max_abs = ABS_MAX; ke->max_abs >= 0; ke->max_abs--)
		    if (ISBITSET(ke->absbits, ke->max_abs))
			break;
		for (i = 0; i <= ke->max_abs; i++)
		{
		    if (ISBITSET (ke->absbits, i))
			if (ioctl (fd, EVIOCGABS(i), &ke->absinfo[i]) < 0)
			{
			    perror ("EVIOCGABS");
			    break;
			}
		    ke->prevabs[i] = ABS_UNSET;
		}
		if (i <= ke->max_abs)
		{
		    xfree (ke);
		    close (fd);
		    continue;
		}
	    }
	    mi->driver = ke;
	    mi->inputType = EvdevInputType;
	    if (KdRegisterFd (EvdevInputType, fd, EvdevRead, (void *) mi))
		n++;
	}
d322 46
a367 1
    return TRUE;
d371 1
a371 1
EvdevFini (void)
d373 3
a375 1
    KdMouseInfo	*mi;
d377 9
a385 2
    KdUnregisterFds (EvdevInputType, TRUE);
    for (mi = kdMouseInfo; mi; mi = mi->next)
d387 53
a439 6
	if (mi->inputType == EvdevInputType)
	{
	    xfree (mi->driver);
	    mi->driver = 0;
	    mi->inputType = 0;
	}
d441 68
d511 12
a522 3
KdMouseFuncs LinuxEvdevMouseFuncs = {
    EvdevInit,
    EvdevFini,
d525 2
a526 3
#if 0
KdKeyboardFuncs LinuxEvdevKeyboardFuncs = {
    EvdevKbdLoad,
d528 1
d531 1
d533 1
a533 1
    0,
a534 1
#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d46 4
a49 1
#define BIT(x)         (1 << OFF(x))
d51 1
a51 1
typedef struct _kevdev {
d53 4
a56 4
    int                            rel[REL_MAX + 1];
    int                            abs[ABS_MAX + 1];
    int                            prevabs[ABS_MAX + 1];
    long                    key[NBITS(KEY_MAX + 1)];
d59 3
a61 3
    long                    relbits[NBITS(REL_MAX + 1)];
    long                    absbits[NBITS(ABS_MAX + 1)];
    long                    keybits[NBITS(KEY_MAX + 1)];
d63 2
a64 4
    int                            max_rel;
    int                            max_abs;

    int                     fd;
d68 1
a68 34
EvdevPtrBtn (KdPointerInfo    *pi, struct input_event *ev)
{
    int flags = KD_MOUSE_DELTA | pi->buttonState;

    if (ev->code >= BTN_MOUSE && ev->code < BTN_JOYSTICK) {
        switch (ev->code) {
        case BTN_LEFT:
            if (ev->value == 1)
                flags |= KD_BUTTON_1;
	    else
                flags &= ~KD_BUTTON_1;
             break;
        case BTN_MIDDLE:
            if (ev->value == 1)
                flags |= KD_BUTTON_2;
	    else
		flags &= ~KD_BUTTON_2;
            break;
        case BTN_RIGHT:
            if (ev->value == 1)
                flags |= KD_BUTTON_3;
	    else
		flags &= ~KD_BUTTON_3;
            break;
        default:
            /* Unknow button */
            break;
        }

        KdEnqueuePointerEvent (pi, flags, 0, 0, 0);
    }
}
static void
EvdevPtrMotion (KdPointerInfo    *pi, struct input_event *ev)
d70 2
a71 3
    Kevdev                *ke = pi->driverPrivate;
    int i;
    int flags = KD_MOUSE_DELTA | pi->buttonState;
d74 8
a81 12
        if (ke->rel[i])
        {
            int a;
            for (a = 0; a <= ke->max_rel; a++)
            {
                if (ISBITSET (ke->relbits, a)) 
		{
                    if (a == 0)
                        KdEnqueuePointerEvent(pi, flags, ke->rel[a], 0, 0);
                    else if (a == 1)
                        KdEnqueuePointerEvent(pi, flags, 0, ke->rel[a], 0); 
                }
d83 4
a86 3
            }
            break;
        }
d88 13
a100 33
        if (ke->abs[i] != ke->prevabs[i])
        {
            int a;
            ErrorF ("abs");
            for (a = 0; a <= ke->max_abs; a++)
            {
                if (ISBITSET (ke->absbits, a))
                    ErrorF (" %d=%d", a, ke->abs[a]);
                ke->prevabs[a] = ke->abs[a];
            }
            ErrorF ("\n");
            break;
        }
    
    if (ev->code == REL_WHEEL) {           
      for (i = 0; i < abs (ev->value); i++) 
      {
        if (ev->value > 0)
          flags |= KD_BUTTON_4;
        else
          flags |= KD_BUTTON_5;

        KdEnqueuePointerEvent (pi, flags, 0, 0, 0);

        if (ev->value > 0)
          flags &= ~KD_BUTTON_4;
        else
          flags &= ~KD_BUTTON_5;

        KdEnqueuePointerEvent (pi, flags, 0, 0, 0);
      }
    }
    
d104 7
a110 7
EvdevPtrRead (int evdevPort, void *closure)
{
    KdPointerInfo                *pi = closure;
    Kevdev                       *ke = pi->driverPrivate;
    int                        i;
    struct input_event        events[NUM_EVENTS];
    int                        n;
d113 2
a114 6
    if (n <= 0) {
        if (errno == ENODEV) 
            DeleteInputDeviceRequest(pi->dixdev);
        return;
    }

d118 18
a135 15
        switch (events[i].type) {
        case EV_SYN:
            break;
        case EV_KEY:
            EvdevPtrBtn (pi, &events[i]);
            break;
        case EV_REL:
            ke->rel[events[i].code] += events[i].value;
            EvdevPtrMotion (pi, &events[i]);
            break;
        case EV_ABS:
            ke->abs[events[i].code] = events[i].value;
            EvdevPtrMotion (pi, &events[i]);
            break;
        }
d137 1
d140 2
d151 2
a152 2
static Status
EvdevPtrInit (KdPointerInfo *pi)
d154 5
a158 2
    int                i;
    int                fd;
d160 2
a161 20
    if (!pi->path) {
        for (i = 0; i < NUM_DEFAULT_EVDEV; i++) {
            fd = open (kdefaultEvdev[i], 2);
            if (fd >= 0) {
                pi->path = KdSaveString (kdefaultEvdev[i]);
                break;
            }
        }
    }
    else {
        fd = open (pi->path, O_RDWR);
        if (fd < 0) {
            ErrorF("Failed to open evdev device %s\n", pi->path);
            return BadMatch;
        }
    }

    close(fd);

    pi->name = KdSaveString("Evdev mouse");
d163 1
a163 19
    return Success;
}

static Status
EvdevPtrEnable (KdPointerInfo *pi)
{        
    int fd;

    if (!pi || !pi->path)
        return BadImplementation;

    fd = open(pi->path, 2);
    if (fd < 0)
        return BadMatch;

    unsigned long   ev[NBITS(EV_MAX)];
    Kevdev            *ke;
        
    if (ioctl (fd, EVIOCGBIT(0 /*EV*/, sizeof (ev)), ev) < 0)
d165 65
a229 39
        perror ("EVIOCGBIT 0");
        close (fd);
        return BadMatch;
    }
    ke = xalloc (sizeof (Kevdev));
    if (!ke)
    {
        close (fd);
        return BadAlloc;
    }
    memset (ke, '\0', sizeof (Kevdev));
    if (ISBITSET (ev, EV_KEY))
    {
        if (ioctl (fd, EVIOCGBIT (EV_KEY, sizeof (ke->keybits)),
                   ke->keybits) < 0)
        {
            perror ("EVIOCGBIT EV_KEY");
            xfree (ke);
            close (fd);
            return BadMatch;
        }
    }
    if (ISBITSET (ev, EV_REL))
    {
        if (ioctl (fd, EVIOCGBIT (EV_REL, sizeof (ke->relbits)),
                       ke->relbits) < 0)
        {
            perror ("EVIOCGBIT EV_REL");
            xfree (ke);
            close (fd);
            return BadMatch;
        }
        for (ke->max_rel = REL_MAX; ke->max_rel >= 0; ke->max_rel--)
            if (ISBITSET(ke->relbits, ke->max_rel))
                break;
    }
    if (ISBITSET (ev, EV_ABS))
    {
        int i;
d231 33
a263 32
        if (ioctl (fd, EVIOCGBIT (EV_ABS, sizeof (ke->absbits)),
                   ke->absbits) < 0)
            {
            perror ("EVIOCGBIT EV_ABS");
            xfree (ke);
            close (fd);
            return BadMatch;
        }
        for (ke->max_abs = ABS_MAX; ke->max_abs >= 0; ke->max_abs--)
            if (ISBITSET(ke->absbits, ke->max_abs))
                break;
        for (i = 0; i <= ke->max_abs; i++)
        {
            if (ISBITSET (ke->absbits, i))
                if (ioctl (fd, EVIOCGABS(i), &ke->absinfo[i]) < 0)
                {
                    perror ("EVIOCGABS");
                    break;
                }
            ke->prevabs[i] = ABS_UNSET;
        }
        if (i <= ke->max_abs)
        {
            xfree (ke);
            close (fd);
            return BadValue;
        }
    }
    if (!KdRegisterFd (fd, EvdevPtrRead, pi)) {
        xfree (ke);
        close (fd);
        return BadAlloc;
d265 1
a265 46
    pi->driverPrivate = ke;
    ke->fd = fd;

    return Success;
}

static void
EvdevPtrDisable (KdPointerInfo *pi)
{
    Kevdev              *ke;

    ke = pi->driverPrivate;

    if (!pi || !pi->driverPrivate)
        return;

    KdUnregisterFd (pi, ke->fd, TRUE);
    xfree (ke);
    pi->driverPrivate = 0;
}

static void
EvdevPtrFini (KdPointerInfo *pi)
{
}


/*
 * Evdev keyboard functions 
 */

static void
readMapping (KdKeyboardInfo *ki)
{
    int             minScanCode, maxScanCode;

    if (!ki)
        return;

    minScanCode = 0;
    maxScanCode = 193;

    ki->keySyms.mapWidth = 2;

    ki->minScanCode = minScanCode;
    ki->maxScanCode = maxScanCode;		
d269 1
a269 1
EvdevKbdRead (int evdevPort, void *closure)
d271 1
a271 3
    KdKeyboardInfo	 *ki = closure;
    struct input_event	 events[NUM_EVENTS];
    int			 i, n;
d273 2
a274 9
    n = read (evdevPort, &events, NUM_EVENTS * sizeof (struct input_event));
    if (n <= 0) {
        if (errno == ENODEV) 
            DeleteInputDeviceRequest(ki->dixdev);
        return;
    }

    n /= sizeof (struct input_event);
    for (i = 0; i < n; i++)
d276 6
a281 53
        if (events[i].type == EV_KEY)
	    KdEnqueueKeyboardEvent (ki, events[i].code, !events[i].value);
/* FIXME: must implement other types of events
        else
            ErrorF("Event type (%d) not delivered\n", events[i].type);
*/
    }
}

static Status
EvdevKbdInit (KdKeyboardInfo *ki)
{
    int fd;
    
    if (!ki->path) {
        ErrorF("Couldn't find evdev device path\n");
        return BadValue;
    }
    else {
        fd = open (ki->path, O_RDWR);
        if (fd < 0) {
            ErrorF("Failed to open evdev device %s\n", ki->path);
            return BadMatch;
        }
    }

    close (fd);

    ki->name = KdSaveString("Evdev keyboard");

    readMapping(ki);

    return Success;
}

static Status
EvdevKbdEnable (KdKeyboardInfo *ki)
{
    unsigned long       ev[NBITS(EV_MAX)];
    Kevdev              *ke;
    int                 fd;

    if (!ki || !ki->path)
        return BadImplementation;

    fd = open(ki->path, O_RDWR);
    if (fd < 0)
        return BadMatch;

    if (ioctl (fd, EVIOCGBIT(0 /*EV*/, sizeof (ev)), ev) < 0) {
        perror ("EVIOCGBIT 0");
        close (fd);
        return BadMatch;
a282 69

    ke = xalloc (sizeof (Kevdev));
    if (!ke) {
        close (fd);
        return BadAlloc;
    }
    memset (ke, '\0', sizeof (Kevdev));

    if (!KdRegisterFd (fd, EvdevKbdRead, ki)) {
        xfree (ke);
        close (fd);
        return BadAlloc;
    }
    ki->driverPrivate = ke;
    ke->fd = fd;

    return Success;
}

static void
EvdevKbdLeds (KdKeyboardInfo *ki, int leds)
{
/*    struct input_event event;
    Kevdev             *ke;

    ki->driverPrivate = ke;

    memset(&event, 0, sizeof(event));

    event.type = EV_LED;
    event.code = LED_CAPSL;
    event.value = leds & (1 << 0) ? 1 : 0;
    write(ke->fd, (char *) &event, sizeof(event));

    event.type = EV_LED;
    event.code = LED_NUML;
    event.value = leds & (1 << 1) ? 1 : 0;
    write(ke->fd, (char *) &event, sizeof(event));

    event.type = EV_LED;
    event.code = LED_SCROLLL;
    event.value = leds & (1 << 2) ? 1 : 0;
    write(ke->fd, (char *) &event, sizeof(event));

    event.type = EV_LED;
    event.code = LED_COMPOSE;
    event.value = leds & (1 << 3) ? 1 : 0;
    write(ke->fd, (char *) &event, sizeof(event));
*/
}

static void
EvdevKbdBell (KdKeyboardInfo *ki, int volume, int frequency, int duration)
{
}

static void
EvdevKbdDisable (KdKeyboardInfo *ki)
{
    Kevdev              *ke;

    ke = ki->driverPrivate;

    if (!ki || !ki->driverPrivate)
        return;

    KdUnregisterFd (ki, ke->fd, TRUE);
    xfree (ke);
    ki->driverPrivate = 0;
d285 3
a287 12
static void
EvdevKbdFini (KdKeyboardInfo *ki)
{
}

KdPointerDriver LinuxEvdevMouseDriver = {
    "evdev",
    EvdevPtrInit,
    EvdevPtrEnable,
    EvdevPtrDisable,
    EvdevPtrFini,
    NULL,
d290 3
a292 2
KdKeyboardDriver LinuxEvdevKeyboardDriver = {
    "evdev",
a293 1
    EvdevKbdEnable,
a295 1
    EvdevKbdDisable,
d297 1
a297 1
    NULL,
d299 1
@

