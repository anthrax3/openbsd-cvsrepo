head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.12
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.10
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.8
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.15;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.15;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.04.17;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@/*
 * Copyright Â© 2001 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif
#include <errno.h>
#include <termios.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/Xpoll.h>
#include "inputstr.h"
#include "scrnintstr.h"
#include "kdrive.h"

#undef DEBUG
#undef DEBUG_BYTES
#define KBUFIO_SIZE 256
#define MOUSE_TIMEOUT	100

typedef struct _kbufio {
    int fd;
    unsigned char buf[KBUFIO_SIZE];
    int avail;
    int used;
} Kbufio;

static Bool
MouseWaitForReadable(int fd, int timeout)
{
    fd_set set;
    struct timeval tv, *tp;
    int n;
    CARD32 done;

    done = GetTimeInMillis() + timeout;
    for (;;) {
        FD_ZERO(&set);
        FD_SET(fd, &set);
        if (timeout == -1)
            tp = 0;
        else {
            tv.tv_sec = timeout / 1000;
            tv.tv_usec = (timeout % 1000) * 1000;
            tp = &tv;
        }
        n = select(fd + 1, &set, 0, 0, tp);
        if (n > 0)
            return TRUE;
        if (n < 0 && (errno == EAGAIN || errno == EINTR)) {
            timeout = (int) (done - GetTimeInMillis());
            if (timeout > 0)
                continue;
        }
        break;
    }
    return FALSE;
}

static int
MouseReadByte(Kbufio * b, int timeout)
{
    int n;

    if (b->avail <= b->used) {
        if (timeout && !MouseWaitForReadable(b->fd, timeout)) {
#ifdef DEBUG_BYTES
            ErrorF("\tTimeout %d\n", timeout);
#endif
            return -1;
        }
        n = read(b->fd, b->buf, KBUFIO_SIZE);
        if (n <= 0)
            return -1;
        b->avail = n;
        b->used = 0;
    }
#ifdef DEBUG_BYTES
    ErrorF("\tget %02x\n", b->buf[b->used]);
#endif
    return b->buf[b->used++];
}

#if NOTUSED
static int
MouseFlush(Kbufio * b, char *buf, int size)
{
    CARD32 now = GetTimeInMillis();
    CARD32 done = now + 100;
    int c;
    int n = 0;

    while ((c = MouseReadByte(b, done - now)) != -1) {
        if (buf) {
            if (n == size) {
                memmove(buf, buf + 1, size - 1);
                n--;
            }
            buf[n++] = c;
        }
        now = GetTimeInMillis();
        if ((INT32) (now - done) >= 0)
            break;
    }
    return n;
}

static int
MousePeekByte(Kbufio * b, int timeout)
{
    int c;

    c = MouseReadByte(b, timeout);
    if (c != -1)
        --b->used;
    return c;
}
#endif                          /* NOTUSED */

static Bool
MouseWaitForWritable(int fd, int timeout)
{
    fd_set set;
    struct timeval tv, *tp;
    int n;

    FD_ZERO(&set);
    FD_SET(fd, &set);
    if (timeout == -1)
        tp = 0;
    else {
        tv.tv_sec = timeout / 1000;
        tv.tv_usec = (timeout % 1000) * 1000;
        tp = &tv;
    }
    n = select(fd + 1, 0, &set, 0, tp);
    if (n > 0)
        return TRUE;
    return FALSE;
}

static Bool
MouseWriteByte(int fd, unsigned char c, int timeout)
{
    int ret;

#ifdef DEBUG_BYTES
    ErrorF("\tput %02x\n", c);
#endif
    for (;;) {
        ret = write(fd, &c, 1);
        if (ret == 1)
            return TRUE;
        if (ret == 0)
            return FALSE;
        if (errno != EWOULDBLOCK)
            return FALSE;
        if (!MouseWaitForWritable(fd, timeout))
            return FALSE;
    }
}

static Bool
MouseWriteBytes(int fd, unsigned char *c, int n, int timeout)
{
    while (n--)
        if (!MouseWriteByte(fd, *c++, timeout))
            return FALSE;
    return TRUE;
}

#define MAX_MOUSE   10          /* maximum length of mouse protocol */
#define MAX_SKIP    16          /* number of error bytes before switching */
#define MAX_VALID   4           /* number of valid packets before accepting */

typedef struct _kmouseProt {
    const char *name;
    Bool (*Complete) (KdPointerInfo * pi, unsigned char *ev, int ne);
    int (*Valid) (KdPointerInfo * pi, unsigned char *ev, int ne);
    Bool (*Parse) (KdPointerInfo * pi, unsigned char *ev, int ne);
    Bool (*Init) (KdPointerInfo * pi);
    unsigned char headerMask, headerValid;
    unsigned char dataMask, dataValid;
    Bool tty;
    unsigned int c_iflag;
    unsigned int c_oflag;
    unsigned int c_lflag;
    unsigned int c_cflag;
    unsigned int speed;
    unsigned char *init;
    unsigned long state;
} KmouseProt;

typedef enum _kmouseStage {
    MouseBroken, MouseTesting, MouseWorking
} KmouseStage;

typedef struct _kmouse {
    Kbufio iob;
    const KmouseProt *prot;
    int i_prot;
    KmouseStage stage;          /* protocol verification stage */
    Bool tty;                   /* mouse device is a tty */
    int valid;                  /* sequential valid events */
    int tested;                 /* bytes scanned during Testing phase */
    int invalid;                /* total invalid bytes for this protocol */
    unsigned long state;        /* private per protocol, init to prot->state */
} Kmouse;

static int
mouseValid(KdPointerInfo * pi, unsigned char *ev, int ne)
{
    Kmouse *km = pi->driverPrivate;
    const KmouseProt *prot = km->prot;
    int i;

    for (i = 0; i < ne; i++)
        if ((ev[i] & prot->headerMask) == prot->headerValid)
            break;
    if (i != 0)
        return i;
    for (i = 1; i < ne; i++)
        if ((ev[i] & prot->dataMask) != prot->dataValid)
            return -1;
    return 0;
}

static Bool
threeComplete(KdPointerInfo * pi, unsigned char *ev, int ne)
{
    return ne == 3;
}

static Bool
fourComplete(KdPointerInfo * pi, unsigned char *ev, int ne)
{
    return ne == 4;
}

static Bool
fiveComplete(KdPointerInfo * pi, unsigned char *ev, int ne)
{
    return ne == 5;
}

static Bool
MouseReasonable(KdPointerInfo * pi, unsigned long flags, int dx, int dy)
{
    Kmouse *km = pi->driverPrivate;

    if (km->stage == MouseWorking)
        return TRUE;
    if (dx < -50 || dx > 50) {
#ifdef DEBUG
        ErrorF("Large X %d\n", dx);
#endif
        return FALSE;
    }
    if (dy < -50 || dy > 50) {
#ifdef DEBUG
        ErrorF("Large Y %d\n", dy);
#endif
        return FALSE;
    }
    return TRUE;
}

/*
 * Standard PS/2 mouse protocol
 */
static Bool
ps2Parse(KdPointerInfo * pi, unsigned char *ev, int ne)
{
    Kmouse *km = pi->driverPrivate;
    int dx, dy, dz;
    unsigned long flags;
    unsigned long flagsrelease = 0;

    flags = KD_MOUSE_DELTA;
    if (ev[0] & 4)
        flags |= KD_BUTTON_2;
    if (ev[0] & 2)
        flags |= KD_BUTTON_3;
    if (ev[0] & 1)
        flags |= KD_BUTTON_1;

    if (ne > 3) {
        dz = (int) (signed char) ev[3];
        if (dz < 0) {
            flags |= KD_BUTTON_4;
            flagsrelease = KD_BUTTON_4;
        }
        else if (dz > 0) {
            flags |= KD_BUTTON_5;
            flagsrelease = KD_BUTTON_5;
        }
    }

    dx = ev[1];
    if (ev[0] & 0x10)
        dx -= 256;
    dy = ev[2];
    if (ev[0] & 0x20)
        dy -= 256;
    dy = -dy;
    if (!MouseReasonable(pi, flags, dx, dy))
        return FALSE;
    if (km->stage == MouseWorking) {
        KdEnqueuePointerEvent(pi, flags, dx, dy, 0);
        if (flagsrelease) {
            flags &= ~flagsrelease;
            KdEnqueuePointerEvent(pi, flags, dx, dy, 0);
        }
    }
    return TRUE;
}

static Bool ps2Init(KdPointerInfo * pi);

static const KmouseProt ps2Prot = {
    "ps/2",
    threeComplete, mouseValid, ps2Parse, ps2Init,
    0x08, 0x08, 0x00, 0x00,
    FALSE
};

static const KmouseProt imps2Prot = {
    "imps/2",
    fourComplete, mouseValid, ps2Parse, ps2Init,
    0x08, 0x08, 0x00, 0x00,
    FALSE
};

static const KmouseProt exps2Prot = {
    "exps/2",
    fourComplete, mouseValid, ps2Parse, ps2Init,
    0x08, 0x08, 0x00, 0x00,
    FALSE
};

/*
 * Once the mouse is known to speak ps/2 protocol, go and find out
 * what advanced capabilities it has and turn them on
 */

/* these extracted from FreeBSD 4.3 sys/dev/kbd/atkbdcreg.h */

/* aux device commands (sent to KBD_DATA_PORT) */
#define PSMC_SET_SCALING11      0x00e6
#define PSMC_SET_SCALING21      0x00e7
#define PSMC_SET_RESOLUTION     0x00e8
#define PSMC_SEND_DEV_STATUS    0x00e9
#define PSMC_SET_STREAM_MODE    0x00ea
#define PSMC_SEND_DEV_DATA      0x00eb
#define PSMC_SET_REMOTE_MODE    0x00f0
#define PSMC_SEND_DEV_ID        0x00f2
#define PSMC_SET_SAMPLING_RATE  0x00f3
#define PSMC_ENABLE_DEV         0x00f4
#define PSMC_DISABLE_DEV        0x00f5
#define PSMC_SET_DEFAULTS       0x00f6
#define PSMC_RESET_DEV          0x00ff

/* PSMC_SET_RESOLUTION argument */
#define PSMD_RES_LOW            0       /* typically 25ppi */
#define PSMD_RES_MEDIUM_LOW     1       /* typically 50ppi */
#define PSMD_RES_MEDIUM_HIGH    2       /* typically 100ppi (default) */
#define PSMD_RES_HIGH           3       /* typically 200ppi */
#define PSMD_MAX_RESOLUTION     PSMD_RES_HIGH

/* PSMC_SET_SAMPLING_RATE */
#define PSMD_MAX_RATE           255     /* FIXME: not sure if it's possible */

/* aux device ID */
#define PSM_MOUSE_ID            0
#define PSM_BALLPOINT_ID        2
#define PSM_INTELLI_ID          3
#define PSM_EXPLORER_ID         4
#define PSM_4DMOUSE_ID          6
#define PSM_4DPLUS_ID           8

static unsigned char ps2_init[] = {
    PSMC_ENABLE_DEV,
    0,
};

#define NINIT_PS2   1

static unsigned char wheel_3button_init[] = {
    PSMC_SET_SAMPLING_RATE, 200,
    PSMC_SET_SAMPLING_RATE, 100,
    PSMC_SET_SAMPLING_RATE, 80,
    PSMC_SEND_DEV_ID,
    0,
};

#define NINIT_IMPS2 4

static unsigned char wheel_5button_init[] = {
    PSMC_SET_SAMPLING_RATE, 200,
    PSMC_SET_SAMPLING_RATE, 100,
    PSMC_SET_SAMPLING_RATE, 80,
    PSMC_SET_SAMPLING_RATE, 200,
    PSMC_SET_SAMPLING_RATE, 200,
    PSMC_SET_SAMPLING_RATE, 80,
    PSMC_SEND_DEV_ID,
    0
};

#define NINIT_EXPS2 7

static unsigned char intelli_init[] = {
    PSMC_SET_SAMPLING_RATE, 200,
    PSMC_SET_SAMPLING_RATE, 100,
    PSMC_SET_SAMPLING_RATE, 80,
    0
};

#define NINIT_INTELLI	3

static int
ps2SkipInit(KdPointerInfo * pi, int ninit, Bool ret_next)
{
    Kmouse *km = pi->driverPrivate;
    int c = -1;
    Bool waiting;

    waiting = FALSE;
    while (ninit || ret_next) {
        c = MouseReadByte(&km->iob, MOUSE_TIMEOUT);
        if (c == -1)
            break;
        /* look for ACK */
        if (c == 0xfa) {
            ninit--;
            if (ret_next)
                waiting = TRUE;
        }
        /* look for packet start -- not the response */
        else if ((c & 0x08) == 0x08)
            waiting = FALSE;
        else if (waiting)
            break;
    }
    return c;
}

static Bool
ps2Init(KdPointerInfo * pi)
{
    Kmouse *km = pi->driverPrivate;
    int id;
    unsigned char *init;
    int ninit;

    /* Send Intellimouse initialization sequence */
    MouseWriteBytes(km->iob.fd, intelli_init, strlen((char *) intelli_init),
                    100);
    /*
     * Send ID command
     */
    if (!MouseWriteByte(km->iob.fd, PSMC_SEND_DEV_ID, 100))
        return FALSE;
    id = ps2SkipInit(pi, 0, TRUE);
    switch (id) {
    case 3:
        init = wheel_3button_init;
        ninit = NINIT_IMPS2;
        km->prot = &imps2Prot;
        break;
    case 4:
        init = wheel_5button_init;
        ninit = NINIT_EXPS2;
        km->prot = &exps2Prot;
        break;
    default:
        init = ps2_init;
        ninit = NINIT_PS2;
        km->prot = &ps2Prot;
        break;
    }
    if (init)
        MouseWriteBytes(km->iob.fd, init, strlen((char *) init), 100);
    /*
     * Flush out the available data to eliminate responses to the
     * initialization string.  Make sure any partial event is
     * skipped
     */
    (void) ps2SkipInit(pi, ninit, FALSE);
    return TRUE;
}

static Bool
busParse(KdPointerInfo * pi, unsigned char *ev, int ne)
{
    Kmouse *km = pi->driverPrivate;
    int dx, dy;
    unsigned long flags;

    flags = KD_MOUSE_DELTA;
    dx = (signed char) ev[1];
    dy = -(signed char) ev[2];
    if ((ev[0] & 4) == 0)
        flags |= KD_BUTTON_1;
    if ((ev[0] & 2) == 0)
        flags |= KD_BUTTON_2;
    if ((ev[0] & 1) == 0)
        flags |= KD_BUTTON_3;
    if (!MouseReasonable(pi, flags, dx, dy))
        return FALSE;
    if (km->stage == MouseWorking)
        KdEnqueuePointerEvent(pi, flags, dx, dy, 0);
    return TRUE;
}

static const KmouseProt busProt = {
    "bus",
    threeComplete, mouseValid, busParse, 0,
    0xf8, 0x00, 0x00, 0x00,
    FALSE
};

/*
 * Standard MS serial protocol, three bytes
 */

static Bool
msParse(KdPointerInfo * pi, unsigned char *ev, int ne)
{
    Kmouse *km = pi->driverPrivate;
    int dx, dy;
    unsigned long flags;

    flags = KD_MOUSE_DELTA;

    if (ev[0] & 0x20)
        flags |= KD_BUTTON_1;
    if (ev[0] & 0x10)
        flags |= KD_BUTTON_3;

    dx = (signed char) (((ev[0] & 0x03) << 6) | (ev[1] & 0x3F));
    dy = (signed char) (((ev[0] & 0x0C) << 4) | (ev[2] & 0x3F));
    if (!MouseReasonable(pi, flags, dx, dy))
        return FALSE;
    if (km->stage == MouseWorking)
        KdEnqueuePointerEvent(pi, flags, dx, dy, 0);
    return TRUE;
}

static const KmouseProt msProt = {
    "ms",
    threeComplete, mouseValid, msParse, 0,
    0xc0, 0x40, 0xc0, 0x00,
    TRUE,
    IGNPAR,
    0,
    0,
    CS7 | CSTOPB | CREAD | CLOCAL,
    B1200,
};

/*
 * Logitech mice send 3 or 4 bytes, the only way to tell is to look at the
 * first byte of a synchronized protocol stream and see if it's got
 * any bits turned on that can't occur in that fourth byte
 */
static Bool
logiComplete(KdPointerInfo * pi, unsigned char *ev, int ne)
{
    Kmouse *km = pi->driverPrivate;

    if ((ev[0] & 0x40) == 0x40)
        return ne == 3;
    if (km->stage != MouseBroken && (ev[0] & ~0x23) == 0)
        return ne == 1;
    return FALSE;
}

static int
logiValid(KdPointerInfo * pi, unsigned char *ev, int ne)
{
    Kmouse *km = pi->driverPrivate;
    const KmouseProt *prot = km->prot;
    int i;

    for (i = 0; i < ne; i++) {
        if ((ev[i] & 0x40) == 0x40)
            break;
        if (km->stage != MouseBroken && (ev[i] & ~0x23) == 0)
            break;
    }
    if (i != 0)
        return i;
    for (i = 1; i < ne; i++)
        if ((ev[i] & prot->dataMask) != prot->dataValid)
            return -1;
    return 0;
}

static Bool
logiParse(KdPointerInfo * pi, unsigned char *ev, int ne)
{
    Kmouse *km = pi->driverPrivate;
    int dx, dy;
    unsigned long flags;

    flags = KD_MOUSE_DELTA;

    if (ne == 3) {
        if (ev[0] & 0x20)
            flags |= KD_BUTTON_1;
        if (ev[0] & 0x10)
            flags |= KD_BUTTON_3;

        dx = (signed char) (((ev[0] & 0x03) << 6) | (ev[1] & 0x3F));
        dy = (signed char) (((ev[0] & 0x0C) << 4) | (ev[2] & 0x3F));
        flags |= km->state & KD_BUTTON_2;
    }
    else {
        if (ev[0] & 0x20)
            flags |= KD_BUTTON_2;
        dx = 0;
        dy = 0;
        flags |= km->state & (KD_BUTTON_1 | KD_BUTTON_3);
    }

    if (!MouseReasonable(pi, flags, dx, dy))
        return FALSE;
    if (km->stage == MouseWorking)
        KdEnqueuePointerEvent(pi, flags, dx, dy, 0);
    return TRUE;
}

static const KmouseProt logiProt = {
    "logitech",
    logiComplete, logiValid, logiParse, 0,
    0xc0, 0x40, 0xc0, 0x00,
    TRUE,
    IGNPAR,
    0,
    0,
    CS7 | CSTOPB | CREAD | CLOCAL,
    B1200,
};

/*
 * Mouse systems protocol, 5 bytes
 */
static Bool
mscParse(KdPointerInfo * pi, unsigned char *ev, int ne)
{
    Kmouse *km = pi->driverPrivate;
    int dx, dy;
    unsigned long flags;

    flags = KD_MOUSE_DELTA;

    if (!(ev[0] & 0x4))
        flags |= KD_BUTTON_1;
    if (!(ev[0] & 0x2))
        flags |= KD_BUTTON_2;
    if (!(ev[0] & 0x1))
        flags |= KD_BUTTON_3;
    dx = (signed char) (ev[1]) + (signed char) (ev[3]);
    dy = -((signed char) (ev[2]) + (signed char) (ev[4]));

    if (!MouseReasonable(pi, flags, dx, dy))
        return FALSE;
    if (km->stage == MouseWorking)
        KdEnqueuePointerEvent(pi, flags, dx, dy, 0);
    return TRUE;
}

static const KmouseProt mscProt = {
    "msc",
    fiveComplete, mouseValid, mscParse, 0,
    0xf8, 0x80, 0x00, 0x00,
    TRUE,
    IGNPAR,
    0,
    0,
    CS8 | CSTOPB | CREAD | CLOCAL,
    B1200,
};

/*
 * Use logitech before ms -- they're the same except that
 * logitech sometimes has a fourth byte
 */
static const KmouseProt *kmouseProts[] = {
    &ps2Prot, &imps2Prot, &exps2Prot, &busProt, &logiProt, &msProt, &mscProt,
};

#define NUM_PROT    (sizeof (kmouseProts) / sizeof (kmouseProts[0]))

static void
MouseInitProtocol(Kmouse * km)
{
    int ret;
    struct termios t;

    if (km->prot->tty) {
        ret = tcgetattr(km->iob.fd, &t);

        if (ret >= 0) {
            t.c_iflag = km->prot->c_iflag;
            t.c_oflag = km->prot->c_oflag;
            t.c_lflag = km->prot->c_lflag;
            t.c_cflag = km->prot->c_cflag;
            cfsetispeed(&t, km->prot->speed);
            cfsetospeed(&t, km->prot->speed);
            ret = tcsetattr(km->iob.fd, TCSANOW, &t);
        }
    }
    km->stage = MouseBroken;
    km->valid = 0;
    km->tested = 0;
    km->invalid = 0;
    km->state = km->prot->state;
}

static void
MouseFirstProtocol(Kmouse * km, const char *prot)
{
    if (prot) {
        for (km->i_prot = 0; km->i_prot < NUM_PROT; km->i_prot++)
            if (!strcmp(prot, kmouseProts[km->i_prot]->name))
                break;
        if (km->i_prot == NUM_PROT) {
            int i;

            ErrorF("Unknown mouse protocol \"%s\". Pick one of:", prot);
            for (i = 0; i < NUM_PROT; i++)
                ErrorF(" %s", kmouseProts[i]->name);
            ErrorF("\n");
        }
        else {
            km->prot = kmouseProts[km->i_prot];
            if (km->tty && !km->prot->tty)
                ErrorF
                    ("Mouse device is serial port, protocol %s is not serial protocol\n",
                     prot);
            else if (!km->tty && km->prot->tty)
                ErrorF
                    ("Mouse device is not serial port, protocol %s is serial protocol\n",
                     prot);
        }
    }
    if (!km->prot) {
        for (km->i_prot = 0; kmouseProts[km->i_prot]->tty != km->tty;
             km->i_prot++);
        km->prot = kmouseProts[km->i_prot];
    }
    MouseInitProtocol(km);
}

static void
MouseNextProtocol(Kmouse * km)
{
    do {
        if (!km->prot)
            km->i_prot = 0;
        else if (++km->i_prot == NUM_PROT)
            km->i_prot = 0;
        km->prot = kmouseProts[km->i_prot];
    } while (km->prot->tty != km->tty);
    MouseInitProtocol(km);
    ErrorF("Switching to mouse protocol \"%s\"\n", km->prot->name);
}

static void
MouseRead(int mousePort, void *closure)
{
    KdPointerInfo *pi = closure;
    Kmouse *km = pi->driverPrivate;
    unsigned char event[MAX_MOUSE];
    int ne;
    int c;
    int i;
    int timeout;

    timeout = 0;
    ne = 0;
    for (;;) {
        c = MouseReadByte(&km->iob, timeout);
        if (c == -1) {
            if (ne) {
                km->invalid += ne + km->tested;
                km->valid = 0;
                km->tested = 0;
                km->stage = MouseBroken;
            }
            break;
        }
        event[ne++] = c;
        i = (*km->prot->Valid) (pi, event, ne);
        if (i != 0) {
#ifdef DEBUG
            ErrorF("Mouse protocol %s broken %d of %d bytes bad\n",
                   km->prot->name, i > 0 ? i : ne, ne);
#endif
            if (i > 0 && i < ne) {
                ne -= i;
                memmove(event, event + i, ne);
            }
            else {
                i = ne;
                ne = 0;
            }
            km->invalid += i + km->tested;
            km->valid = 0;
            km->tested = 0;
            if (km->stage == MouseWorking)
                km->i_prot--;
            km->stage = MouseBroken;
            if (km->invalid > MAX_SKIP) {
                MouseNextProtocol(km);
                ne = 0;
            }
            timeout = 0;
        }
        else {
            if ((*km->prot->Complete) (pi, event, ne)) {
                if ((*km->prot->Parse) (pi, event, ne)) {
                    switch (km->stage) {
                    case MouseBroken:
#ifdef DEBUG
                        ErrorF("Mouse protocol %s seems OK\n", km->prot->name);
#endif
                        /* do not zero invalid to accumulate invalid bytes */
                        km->valid = 0;
                        km->tested = 0;
                        km->stage = MouseTesting;
                        /* fall through ... */
                    case MouseTesting:
                        km->valid++;
                        km->tested += ne;
                        if (km->valid > MAX_VALID) {
#ifdef DEBUG
                            ErrorF("Mouse protocol %s working\n",
                                   km->prot->name);
#endif
                            km->stage = MouseWorking;
                            km->invalid = 0;
                            km->tested = 0;
                            km->valid = 0;
                            if (km->prot->Init && !(*km->prot->Init) (pi))
                                km->stage = MouseBroken;
                        }
                        break;
                    case MouseWorking:
                        break;
                    }
                }
                else {
                    km->invalid += ne + km->tested;
                    km->valid = 0;
                    km->tested = 0;
                    km->stage = MouseBroken;
                }
                ne = 0;
                timeout = 0;
            }
            else
                timeout = MOUSE_TIMEOUT;
        }
    }
}

int MouseInputType;

const char *kdefaultMouse[] = {
    "/dev/input/mice",
    "/dev/mouse",
    "/dev/psaux",
    "/dev/adbmouse",
    "/dev/ttyS0",
    "/dev/ttyS1",
};

#define NUM_DEFAULT_MOUSE    (sizeof (kdefaultMouse) / sizeof (kdefaultMouse[0]))

static Status
MouseInit(KdPointerInfo * pi)
{
    int i;
    int fd;
    Kmouse *km;

    if (!pi)
        return BadImplementation;

    if (!pi->path || strcmp(pi->path, "auto") == 0) {
        for (i = 0; i < NUM_DEFAULT_MOUSE; i++) {
            fd = open(kdefaultMouse[i], 2);
            if (fd >= 0) {
                pi->path = strdup(kdefaultMouse[i]);
                break;
            }
        }
    }
    else {
        fd = open(pi->path, 2);
    }

    if (fd < 0)
        return BadMatch;

    close(fd);

    km = (Kmouse *) malloc(sizeof(Kmouse));
    if (km) {
        km->iob.avail = km->iob.used = 0;
        MouseFirstProtocol(km, pi->protocol ? pi->protocol : "exps/2");
        /* MouseFirstProtocol sets state to MouseBroken for later protocol
         * checks. Skip these checks if a protocol was supplied */
        if (pi->protocol)
            km->state = MouseWorking;
        km->i_prot = 0;
        km->tty = isatty(fd);
        km->iob.fd = -1;
        pi->driverPrivate = km;
    }
    else {
        close(fd);
        return BadAlloc;
    }

    return Success;
}

static Status
MouseEnable(KdPointerInfo * pi)
{
    Kmouse *km;

    if (!pi || !pi->driverPrivate || !pi->path)
        return BadImplementation;

    km = pi->driverPrivate;

    km->iob.fd = open(pi->path, 2);
    if (km->iob.fd < 0)
        return BadMatch;

    if (!KdRegisterFd(km->iob.fd, MouseRead, pi)) {
        close(km->iob.fd);
        return BadAlloc;
    }

    return Success;
}

static void
MouseDisable(KdPointerInfo * pi)
{
    Kmouse *km;

    if (!pi || !pi->driverPrivate)
        return;

    km = pi->driverPrivate;
    KdUnregisterFd(pi, km->iob.fd, TRUE);
}

static void
MouseFini(KdPointerInfo * pi)
{
    free(pi->driverPrivate);
    pi->driverPrivate = NULL;
}

KdPointerDriver LinuxMouseDriver = {
    "mouse",
    MouseInit,
    MouseEnable,
    MouseDisable,
    MouseFini,
    NULL,
};
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d196 1
a196 1
    char *name;
a443 1
    int skipping;
a445 1
    skipping = 0;
a469 2
    int skipping;
    Bool waiting;
a481 2
    skipping = 0;
    waiting = FALSE;
d741 1
a741 1
MouseFirstProtocol(Kmouse * km, char *prot)
d890 1
a890 1
char *kdefaultMouse[] = {
@


1.4
log
@Update to xserver 1.11.2
@
text
@d41 4
a44 4
    int		    fd;
    unsigned char   buf[KBUFIO_SIZE];
    int		    avail;
    int		    used;
d48 1
a48 1
MouseWaitForReadable (int fd, int timeout)
d50 25
a74 28
    fd_set	    set;
    struct timeval  tv, *tp;
    int		    n;
    CARD32	    done;

    done = GetTimeInMillis () + timeout;
    for (;;)
    {
	FD_ZERO (&set);
	FD_SET (fd, &set);
	if (timeout == -1)
	    tp = 0;
	else
	{
	    tv.tv_sec = timeout / 1000;
	    tv.tv_usec = (timeout % 1000) * 1000;
	    tp = &tv;
	}
	n = select (fd + 1, &set, 0, 0, tp);
	if (n > 0)
	    return TRUE;
	if (n < 0 && (errno == EAGAIN || errno == EINTR))
	{
	    timeout = (int) (done - GetTimeInMillis ());
	    if (timeout > 0)
		continue;
	}
	break;
d80 1
a80 1
MouseReadByte (Kbufio *b, int timeout)
d82 4
a85 5
    int	n;
    if (b->avail <= b->used)
    {
	if (timeout && !MouseWaitForReadable (b->fd, timeout))
	{
d87 1
a87 1
	    ErrorF ("\tTimeout %d\n", timeout);
d89 5
a93 5
	    return -1;
	}
	n = read (b->fd, b->buf, KBUFIO_SIZE);
	if (n <= 0)
	    return -1;
d98 1
a98 1
    ErrorF ("\tget %02x\n", b->buf[b->used]);
d105 1
a105 1
MouseFlush (Kbufio *b, char *buf, int size)
d107 16
a122 19
    CARD32  now = GetTimeInMillis ();
    CARD32  done = now + 100;
    int	    c;
    int	    n = 0;

    while ((c = MouseReadByte (b, done - now)) != -1)
    {
	if (buf)
	{
	    if (n == size)
	    {
		memmove (buf, buf + 1, size - 1);
		n--;
	    }
	    buf[n++] = c;
	}
	now = GetTimeInMillis ();
	if ((INT32) (now - done) >= 0)
	    break;
d128 1
a128 1
MousePeekByte (Kbufio *b, int timeout)
d130 1
a130 1
    int	    c;
d132 1
a132 1
    c = MouseReadByte (b, timeout);
d134 1
a134 1
	--b->used;
d137 1
a137 1
#endif /* NOTUSED */
d140 1
a140 1
MouseWaitForWritable (int fd, int timeout)
d142 3
a144 3
    fd_set	    set;
    struct timeval  tv, *tp;
    int		    n;
d146 2
a147 2
    FD_ZERO (&set);
    FD_SET (fd, &set);
d149 5
a153 6
	tp = 0;
    else
    {
	tv.tv_sec = timeout / 1000;
	tv.tv_usec = (timeout % 1000) * 1000;
	tp = &tv;
d155 1
a155 1
    n = select (fd + 1, 0, &set, 0, tp);
d157 1
a157 1
	return TRUE;
d162 1
a162 1
MouseWriteByte (int fd, unsigned char c, int timeout)
d164 1
a164 1
    int	ret;
d167 1
a167 1
    ErrorF ("\tput %02x\n", c);
d169 10
a178 11
    for (;;)
    {
	ret = write (fd, &c, 1);
	if (ret == 1)
	    return TRUE;
	if (ret == 0)
	    return FALSE;
	if (errno != EWOULDBLOCK)
	    return FALSE;
	if (!MouseWaitForWritable (fd, timeout))
	    return FALSE;
d183 1
a183 1
MouseWriteBytes (int fd, unsigned char *c, int n, int timeout)
d186 2
a187 2
	if (!MouseWriteByte (fd, *c++, timeout))
	    return FALSE;
d191 3
a193 3
#define MAX_MOUSE   10	    /* maximum length of mouse protocol */
#define MAX_SKIP    16	    /* number of error bytes before switching */
#define MAX_VALID   4	    /* number of valid packets before accepting */
d196 15
a210 15
    char	    *name;
    Bool	    (*Complete) (KdPointerInfo *pi, unsigned char *ev, int ne);
    int		    (*Valid) (KdPointerInfo *pi, unsigned char *ev, int ne);
    Bool	    (*Parse) (KdPointerInfo *pi, unsigned char *ev, int ne);
    Bool	    (*Init) (KdPointerInfo *pi);
    unsigned char   headerMask, headerValid;
    unsigned char   dataMask, dataValid;
    Bool	    tty;
    unsigned int    c_iflag;
    unsigned int    c_oflag;
    unsigned int    c_lflag;
    unsigned int    c_cflag;
    unsigned int    speed;
    unsigned char   *init;
    unsigned long   state;
d218 9
a226 9
    Kbufio		iob;
    const KmouseProt	*prot;
    int			i_prot;
    KmouseStage		stage;	/* protocol verification stage */
    Bool		tty;	/* mouse device is a tty */
    int			valid;	/* sequential valid events */
    int			tested;	/* bytes scanned during Testing phase */
    int			invalid;/* total invalid bytes for this protocol */
    unsigned long	state;	/* private per protocol, init to prot->state */
d229 2
a230 1
static int mouseValid (KdPointerInfo *pi, unsigned char *ev, int ne)
d232 3
a234 3
    Kmouse		*km = pi->driverPrivate;
    const KmouseProt	*prot = km->prot;
    int	    i;
d237 2
a238 2
	if ((ev[i] & prot->headerMask) == prot->headerValid)
	    break;
d240 1
a240 1
	return i;
d242 2
a243 2
	if ((ev[i] & prot->dataMask) != prot->dataValid)
	    return -1;
d247 2
a248 1
static Bool threeComplete (KdPointerInfo *pi, unsigned char *ev, int ne)
d253 2
a254 1
static Bool fourComplete (KdPointerInfo *pi, unsigned char *ev, int ne)
d259 2
a260 1
static Bool fiveComplete (KdPointerInfo *pi, unsigned char *ev, int ne)
d265 2
a266 1
static Bool MouseReasonable (KdPointerInfo *pi, unsigned long flags, int dx, int dy)
d268 1
a268 1
    Kmouse		*km = pi->driverPrivate;
d271 2
a272 3
	return TRUE;
    if (dx < -50 || dx > 50)
    {
d274 1
a274 1
	ErrorF ("Large X %d\n", dx);
d276 1
a276 1
	return FALSE;
d278 1
a278 2
    if (dy < -50 || dy > 50)
    {
d280 1
a280 1
	ErrorF ("Large Y %d\n", dy);
d282 1
a282 1
	return FALSE;
d290 2
a291 1
static Bool ps2Parse (KdPointerInfo *pi, unsigned char *ev, int ne)
d293 4
a296 4
    Kmouse	    *km = pi->driverPrivate;
    int		    dx, dy, dz;
    unsigned long   flags;
    unsigned long   flagsrelease = 0;
d300 1
a300 1
	flags |= KD_BUTTON_2;
d302 1
a302 1
	flags |= KD_BUTTON_3;
d304 1
a304 1
	flags |= KD_BUTTON_1;
d306 10
a315 13
    if (ne > 3)
    {
	dz = (int) (signed char) ev[3];
	if (dz < 0)
	{
	    flags |= KD_BUTTON_4;
	    flagsrelease = KD_BUTTON_4;
	}
	else if (dz > 0)
	{
	    flags |= KD_BUTTON_5;
	    flagsrelease = KD_BUTTON_5;
	}
d320 1
a320 1
	dx -= 256;
d323 1
a323 1
	dy -= 256;
d325 8
a332 10
    if (!MouseReasonable (pi, flags, dx, dy))
	return FALSE;
    if (km->stage == MouseWorking)
    {
	KdEnqueuePointerEvent (pi, flags, dx, dy, 0);
	if (flagsrelease)
	{
	    flags &= ~flagsrelease;
	    KdEnqueuePointerEvent (pi, flags, dx, dy, 0);
	}
d337 1
a337 1
static Bool ps2Init (KdPointerInfo *pi);
d400 1
a400 1
static unsigned char	ps2_init[] = {
d407 1
a407 1
static unsigned char    wheel_3button_init[] = {
d410 1
a410 1
    PSMC_SET_SAMPLING_RATE,  80,
d417 1
a417 1
static unsigned char    wheel_5button_init[] = {
d420 1
a420 1
    PSMC_SET_SAMPLING_RATE,  80,
d423 1
a423 1
    PSMC_SET_SAMPLING_RATE,  80,
d430 1
a430 1
static unsigned char	intelli_init[] = {
d433 1
a433 1
    PSMC_SET_SAMPLING_RATE,  80,
d440 1
a440 1
ps2SkipInit (KdPointerInfo *pi, int ninit, Bool ret_next)
d442 4
a445 4
    Kmouse  *km = pi->driverPrivate;
    int	    c = -1;
    int	    skipping;
    Bool    waiting;
d449 15
a463 17
    while (ninit || ret_next)
    {
	c = MouseReadByte (&km->iob, MOUSE_TIMEOUT);
	if (c == -1)
	    break;
	/* look for ACK */
	if (c == 0xfa)
	{
	    ninit--;
	    if (ret_next)
		waiting = TRUE;
	}
	/* look for packet start -- not the response */
	else if ((c & 0x08) == 0x08)
	    waiting = FALSE;
	else if (waiting)
	    break;
d469 1
a469 1
ps2Init (KdPointerInfo *pi)
d471 6
a476 6
    Kmouse	    *km = pi->driverPrivate;
    int		    skipping;
    Bool	    waiting;
    int		    id;
    unsigned char   *init;
    int		    ninit;
d479 2
a480 1
    MouseWriteBytes (km->iob.fd, intelli_init, strlen ((char *) intelli_init), 100);
d484 2
a485 2
    if (!MouseWriteByte (km->iob.fd, PSMC_SEND_DEV_ID, 100))
	return FALSE;
d488 1
a488 1
    id = ps2SkipInit (pi, 0, TRUE);
d491 4
a494 4
	init = wheel_3button_init;
	ninit = NINIT_IMPS2;
	km->prot = &imps2Prot;
	break;
d496 4
a499 4
	init = wheel_5button_init;
	ninit = NINIT_EXPS2;
	km->prot = &exps2Prot;
	break;
d501 4
a504 4
	init = ps2_init;
	ninit = NINIT_PS2;
	km->prot = &ps2Prot;
	break;
d507 1
a507 1
	MouseWriteBytes (km->iob.fd, init, strlen ((char *) init), 100);
d513 1
a513 1
    (void) ps2SkipInit (pi, ninit, FALSE);
d517 2
a518 1
static Bool busParse (KdPointerInfo *pi, unsigned char *ev, int ne)
d520 3
a522 3
    Kmouse	    *km = pi->driverPrivate;
    int		    dx, dy;
    unsigned long   flags;
d528 1
a528 1
	flags |= KD_BUTTON_1;
d530 1
a530 1
	flags |= KD_BUTTON_2;
d532 3
a534 3
	flags |= KD_BUTTON_3;
    if (!MouseReasonable (pi, flags, dx, dy))
	return FALSE;
d536 1
a536 1
	KdEnqueuePointerEvent (pi, flags, dx, dy, 0);
d551 2
a552 1
static Bool msParse (KdPointerInfo *pi, unsigned char *ev, int ne)
d554 3
a556 3
    Kmouse	    *km = pi->driverPrivate;
    int		    dx, dy;
    unsigned long   flags;
d561 1
a561 1
	flags |= KD_BUTTON_1;
d563 1
a563 1
	flags |= KD_BUTTON_3;
d565 4
a568 4
    dx = (signed char)(((ev[0] & 0x03) << 6) | (ev[1] & 0x3F));
    dy = (signed char)(((ev[0] & 0x0C) << 4) | (ev[2] & 0x3F));
    if (!MouseReasonable (pi, flags, dx, dy))
	return FALSE;
d570 1
a570 1
	KdEnqueuePointerEvent (pi, flags, dx, dy, 0);
d591 2
a592 1
static Bool logiComplete (KdPointerInfo *pi, unsigned char *ev, int ne)
d594 1
a594 1
    Kmouse		*km = pi->driverPrivate;
d597 1
a597 1
	return ne == 3;
d599 1
a599 1
	return ne == 1;
d603 2
a604 1
static int logiValid (KdPointerInfo *pi, unsigned char *ev, int ne)
d606 9
a614 10
    Kmouse		*km = pi->driverPrivate;
    const KmouseProt	*prot = km->prot;
    int	    i;

    for (i = 0; i < ne; i++)
    {
	if ((ev[i] & 0x40) == 0x40)
	    break;
	if (km->stage != MouseBroken && (ev[i] & ~0x23) == 0)
	    break;
d617 1
a617 1
	return i;
d619 2
a620 2
	if ((ev[i] & prot->dataMask) != prot->dataValid)
	    return -1;
d624 2
a625 1
static Bool logiParse (KdPointerInfo *pi, unsigned char *ev, int ne)
d627 3
a629 3
    Kmouse	    *km = pi->driverPrivate;
    int		    dx, dy;
    unsigned long   flags;
d633 16
a648 18
    if (ne == 3)
    {
	if (ev[0] & 0x20)
	    flags |= KD_BUTTON_1;
	if (ev[0] & 0x10)
	    flags |= KD_BUTTON_3;

	dx = (signed char)(((ev[0] & 0x03) << 6) | (ev[1] & 0x3F));
	dy = (signed char)(((ev[0] & 0x0C) << 4) | (ev[2] & 0x3F));
	flags |= km->state & KD_BUTTON_2;
    }
    else
    {
	if (ev[0] & 0x20)
	    flags |= KD_BUTTON_2;
	dx = 0;
	dy = 0;
	flags |= km->state & (KD_BUTTON_1|KD_BUTTON_3);
d651 2
a652 2
    if (!MouseReasonable (pi, flags, dx, dy))
	return FALSE;
d654 1
a654 1
	KdEnqueuePointerEvent (pi, flags, dx, dy, 0);
d673 2
a674 1
static Bool mscParse (KdPointerInfo *pi, unsigned char *ev, int ne)
d676 3
a678 3
    Kmouse	    *km = pi->driverPrivate;
    int		    dx, dy;
    unsigned long   flags;
d683 1
a683 1
	flags |= KD_BUTTON_1;
d685 1
a685 1
	flags |= KD_BUTTON_2;
d687 3
a689 3
	flags |= KD_BUTTON_3;
    dx =    (signed char)(ev[1]) + (signed char)(ev[3]);
    dy = - ((signed char)(ev[2]) + (signed char)(ev[4]));
d691 2
a692 2
    if (!MouseReasonable (pi, flags, dx, dy))
	return FALSE;
d694 1
a694 1
	KdEnqueuePointerEvent (pi, flags, dx, dy, 0);
d721 1
a721 1
MouseInitProtocol (Kmouse *km)
d723 5
a727 2
    int		    ret;
    struct termios  t;
d729 9
a737 14
    if (km->prot->tty)
    {
	ret = tcgetattr (km->iob.fd, &t);

	if (ret >= 0)
	{
	    t.c_iflag = km->prot->c_iflag;
	    t.c_oflag = km->prot->c_oflag;
	    t.c_lflag = km->prot->c_lflag;
	    t.c_cflag = km->prot->c_cflag;
	    cfsetispeed (&t, km->prot->speed);
	    cfsetospeed (&t, km->prot->speed);
	    ret = tcsetattr (km->iob.fd, TCSANOW, &t);
	}
d747 1
a747 1
MouseFirstProtocol (Kmouse *km, char *prot)
d749 23
a771 29
    if (prot)
    {
	for (km->i_prot = 0; km->i_prot < NUM_PROT; km->i_prot++)
	    if (!strcmp (prot, kmouseProts[km->i_prot]->name))
		break;
	if (km->i_prot == NUM_PROT)
	{
	    int	i;
	    ErrorF ("Unknown mouse protocol \"%s\". Pick one of:", prot);
	    for (i = 0; i < NUM_PROT; i++)
		ErrorF (" %s", kmouseProts[i]->name);
	    ErrorF ("\n");
	}
	else
	{
	    km->prot = kmouseProts[km->i_prot];
	    if (km->tty && !km->prot->tty)
		ErrorF ("Mouse device is serial port, protocol %s is not serial protocol\n",
			prot);
	    else if (!km->tty && km->prot->tty)
		ErrorF ("Mouse device is not serial port, protocol %s is serial protocol\n",
			prot);
	}
    }
    if (!km->prot)
    {
	for (km->i_prot = 0; kmouseProts[km->i_prot]->tty != km->tty; km->i_prot++)
	    ;
	km->prot = kmouseProts[km->i_prot];
d773 6
a778 1
    MouseInitProtocol (km);
d782 1
a782 1
MouseNextProtocol (Kmouse *km)
d784 6
a789 7
    do
    {
	if (!km->prot)
	    km->i_prot = 0;
	else
	    if (++km->i_prot == NUM_PROT) km->i_prot = 0;
	km->prot = kmouseProts[km->i_prot];
d791 2
a792 2
    MouseInitProtocol (km);
    ErrorF ("Switching to mouse protocol \"%s\"\n", km->prot->name);
d796 1
a796 1
MouseRead (int mousePort, void *closure)
d798 7
a804 7
    KdPointerInfo   *pi = closure;
    Kmouse	    *km = pi->driverPrivate;
    unsigned char   event[MAX_MOUSE];
    int		    ne;
    int		    c;
    int		    i;
    int		    timeout;
d808 14
a821 18
    for(;;)
    {
	c = MouseReadByte (&km->iob, timeout);
	if (c == -1)
	{
	    if (ne)
	    {
		km->invalid += ne + km->tested;
		km->valid = 0;
		km->tested = 0;
		km->stage = MouseBroken;
	    }
	    break;
	}
	event[ne++] = c;
	i = (*km->prot->Valid) (pi, event, ne);
	if (i != 0)
	{
d823 2
a824 2
	    ErrorF ("Mouse protocol %s broken %d of %d bytes bad\n",
		    km->prot->name, i > 0 ? i : ne, ne);
d826 25
a850 32
	    if (i > 0 && i < ne)
	    {
		ne -= i;
		memmove (event, event + i, ne);
	    }
	    else
	    {
		i = ne;
		ne = 0;
	    }
	    km->invalid += i + km->tested;
	    km->valid = 0;
	    km->tested = 0;
	    if (km->stage == MouseWorking)
		km->i_prot--;
	    km->stage = MouseBroken;
	    if (km->invalid > MAX_SKIP)
	    {
		MouseNextProtocol (km);
		ne = 0;
	    }
	    timeout = 0;
	}
	else
	{
	    if ((*km->prot->Complete) (pi, event, ne))
	    {
		if ((*km->prot->Parse) (pi, event, ne))
		{
		    switch (km->stage)
		    {
		    case MouseBroken:
d852 1
a852 2
			ErrorF ("Mouse protocol %s seems OK\n",
				km->prot->name);
d854 9
a862 10
			/* do not zero invalid to accumulate invalid bytes */
			km->valid = 0;
			km->tested = 0;
			km->stage = MouseTesting;
			/* fall through ... */
		    case MouseTesting:
			km->valid++;
			km->tested += ne;
			if (km->valid > MAX_VALID)
			{
d864 2
a865 2
			    ErrorF ("Mouse protocol %s working\n",
				    km->prot->name);
d867 24
a890 25
			    km->stage = MouseWorking;
			    km->invalid = 0;
			    km->tested = 0;
			    km->valid = 0;
			    if (km->prot->Init && !(*km->prot->Init) (pi))
				km->stage = MouseBroken;
			}
			break;
		    case MouseWorking:
			break;
		    }
		}
		else
		{
		    km->invalid += ne + km->tested;
		    km->valid = 0;
		    km->tested = 0;
		    km->stage = MouseBroken;
		}
		ne = 0;
		timeout = 0;
	    }
	    else
		timeout = MOUSE_TIMEOUT;
	}
d896 1
a896 1
char *kdefaultMouse[] =  {
d908 1
a908 1
MouseInit (KdPointerInfo *pi)
d910 3
a912 3
    int		i;
    int		fd;
    Kmouse	*km;
d919 1
a919 1
            fd = open (kdefaultMouse[i], 2);
d921 1
a921 1
                pi->path = strdup (kdefaultMouse[i]);
d927 1
a927 1
        fd = open (pi->path, 2);
d935 1
a935 1
    km = (Kmouse *) malloc(sizeof (Kmouse));
d942 1
a942 1
                km->state = MouseWorking;
d944 1
a944 1
        km->tty = isatty (fd);
d949 1
a949 1
        close (fd);
d957 1
a957 1
MouseEnable (KdPointerInfo *pi)
d970 1
a970 2
    if (!KdRegisterFd (km->iob.fd, MouseRead, pi))
    {
d979 1
a979 1
MouseDisable (KdPointerInfo *pi)
d982 1
d987 1
a987 1
    KdUnregisterFd (pi, km->iob.fd, TRUE);
d991 1
a991 1
MouseFini (KdPointerInfo *pi)
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d2 1
a2 1
 * Copyright © 2001 Keith Packard
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d961 1
a961 1
    km = (Kmouse *) xalloc (sizeof (Kmouse));
d1019 1
a1019 1
    xfree (pi->driverPrivate);
@


1.1
log
@Initial revision
@
text
@a1 2
 * $RCSId: xc/programs/Xserver/hw/kdrive/linux/mouse.c,v 1.6 2002/08/02 16:11:35 keithp Exp $
 *
a25 1
#define NEED_EVENTS
d115 1
a115 1
    
d173 1
a173 1
    
d206 4
a209 4
    Bool	    (*Complete) (KdMouseInfo *mi, unsigned char *ev, int ne);
    int		    (*Valid) (KdMouseInfo *mi, unsigned char *ev, int ne);
    Bool	    (*Parse) (KdMouseInfo *mi, unsigned char *ev, int ne);
    Bool	    (*Init) (KdMouseInfo *mi);
d237 2
a238 2
    
static int mouseValid (KdMouseInfo *mi, unsigned char *ev, int ne)
d240 1
a240 1
    Kmouse		*km = mi->driver;
d255 1
a255 1
static Bool threeComplete (KdMouseInfo *mi, unsigned char *ev, int ne)
d260 1
a260 1
static Bool fourComplete (KdMouseInfo *mi, unsigned char *ev, int ne)
d265 1
a265 1
static Bool fiveComplete (KdMouseInfo *mi, unsigned char *ev, int ne)
d270 1
a270 1
static Bool MouseReasonable (KdMouseInfo *mi, unsigned long flags, int dx, int dy)
d272 1
a272 1
    Kmouse		*km = mi->driver;
d274 1
a274 1
    if (km->stage == MouseWorking) 
d276 1
a276 1
    if (dx < -50 || dx > 50) 
d283 1
a283 1
    if (dy < -50 || dy > 50) 
d296 1
a296 1
static Bool ps2Parse (KdMouseInfo *mi, unsigned char *ev, int ne)
d298 1
a298 1
    Kmouse	    *km = mi->driver;
d302 1
a302 1
    
d310 1
a310 1
    
d325 1
a325 1
	
d333 1
a333 1
    if (!MouseReasonable (mi, flags, dx, dy))
d337 1
a337 1
	KdEnqueueMouseEvent (mi, flags, dx, dy);
d341 1
a341 1
	    KdEnqueueMouseEvent (mi, flags, dx, dy);
d347 1
a347 1
static Bool ps2Init (KdMouseInfo *mi);
d410 1
a410 1
static unsigned char	ps2_init[] = { 
d417 1
a417 1
static unsigned char    wheel_3button_init[] = { 
d434 1
a434 1
    PSMC_SEND_DEV_ID, 
d442 2
a443 2
    PSMC_SET_SAMPLING_RATE, 100, 
    PSMC_SET_SAMPLING_RATE,  80, 
d450 1
a450 1
ps2SkipInit (KdMouseInfo *mi, int ninit, Bool ret_next)
d452 1
a452 1
    Kmouse  *km = mi->driver;
d456 1
a456 1
    
d481 1
a481 1
ps2Init (KdMouseInfo *mi)
d483 1
a483 1
    Kmouse	    *km = mi->driver;
d489 1
a489 1
    
d499 1
a499 1
    id = ps2SkipInit (mi, 0, TRUE);
d524 1
a524 1
    (void) ps2SkipInit (mi, ninit, FALSE);
d528 1
a528 1
static Bool busParse (KdMouseInfo *mi, unsigned char *ev, int ne)
d530 1
a530 1
    Kmouse	    *km = mi->driver;
d533 1
a533 1
    
d543 1
a543 1
    if (!MouseReasonable (mi, flags, dx, dy))
d546 1
a546 1
	KdEnqueueMouseEvent (mi, flags, dx, dy);
d561 1
a561 1
static Bool msParse (KdMouseInfo *mi, unsigned char *ev, int ne)
d563 1
a563 1
    Kmouse	    *km = mi->driver;
d576 1
a576 1
    if (!MouseReasonable (mi, flags, dx, dy))
d579 1
a579 1
	KdEnqueueMouseEvent (mi, flags, dx, dy);
d600 1
a600 1
static Bool logiComplete (KdMouseInfo *mi, unsigned char *ev, int ne)
d602 1
a602 1
    Kmouse		*km = mi->driver;
d611 1
a611 1
static int logiValid (KdMouseInfo *mi, unsigned char *ev, int ne)
d613 1
a613 1
    Kmouse		*km = mi->driver;
d632 1
a632 1
static Bool logiParse (KdMouseInfo *mi, unsigned char *ev, int ne)
d634 1
a634 1
    Kmouse	    *km = mi->driver;
d639 1
a639 1
    
d646 1
a646 1
    
d660 1
a660 1
    if (!MouseReasonable (mi, flags, dx, dy))
d663 1
a663 1
	KdEnqueueMouseEvent (mi, flags, dx, dy);
d682 1
a682 1
static Bool mscParse (KdMouseInfo *mi, unsigned char *ev, int ne)
d684 1
a684 1
    Kmouse	    *km = mi->driver;
d689 1
a689 1
    
d699 1
a699 1
    if (!MouseReasonable (mi, flags, dx, dy))
d702 1
a702 1
	KdEnqueueMouseEvent (mi, flags, dx, dy);
d810 2
a811 2
    KdMouseInfo	    *mi = closure;
    Kmouse	    *km = mi->driver;
d835 1
a835 1
	i = (*km->prot->Valid) (mi, event, ne);
d867 1
a867 1
	    if ((*km->prot->Complete) (mi, event, ne))
d869 1
a869 1
		if ((*km->prot->Parse) (mi, event, ne))
d874 1
a874 1
#ifdef DEBUG			
d896 1
a896 1
			    if (km->prot->Init && !(*km->prot->Init) (mi))
d923 1
a925 1
    "/dev/input/mice",
d933 2
a934 2
static Bool
MouseInit (void)
d939 38
a976 47
    KdMouseInfo	*mi, *next;
    int		n = 0;
    char	*prot;

    if (!MouseInputType)
	MouseInputType = KdAllocInputType ();

    for (mi = kdMouseInfo; mi; mi = next)
    {
	next = mi->next;
	prot = mi->prot;
	if (mi->inputType)
	    continue;
	if (!mi->name)
	{
	    for (i = 0; i < NUM_DEFAULT_MOUSE; i++)
	    {
		fd = open (kdefaultMouse[i], 2);
		if (fd >= 0)
		{
		    mi->name = KdSaveString (kdefaultMouse[i]);
		    break;
		}
	    }
	}
	else
	    fd = open (mi->name, 2);
	    
	if (fd >= 0)
	{
	    km = (Kmouse *) xalloc (sizeof (Kmouse));
	    if (km)
	    {
		km->iob.fd = fd;
		km->iob.avail = km->iob.used = 0;
		km->prot = 0;
		km->i_prot = 0;
		km->tty = isatty (fd);
		mi->driver = km;
		mi->inputType = MouseInputType;
		MouseFirstProtocol (km, mi->prot);
		if (KdRegisterFd (MouseInputType, fd, MouseRead, (void *) mi))
		    n++;
	    }
	    else
		close (fd);
	}
d978 2
a979 1
    return TRUE;
d982 2
a983 2
static void
MouseFini (void)
d985 4
a988 1
    KdMouseInfo	*mi;
d990 7
a996 2
    KdUnregisterFds (MouseInputType, TRUE);
    for (mi = kdMouseInfo; mi; mi = mi->next)
d998 2
a999 6
	if (mi->inputType == MouseInputType)
	{
	    xfree (mi->driver);
	    mi->driver = 0;
	    mi->inputType = 0;
	}
d1001 20
d1023 2
a1024 1
KdMouseFuncs LinuxMouseFuncs = {
d1026 2
d1029 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d209 4
a212 4
    Bool	    (*Complete) (KdPointerInfo *pi, unsigned char *ev, int ne);
    int		    (*Valid) (KdPointerInfo *pi, unsigned char *ev, int ne);
    Bool	    (*Parse) (KdPointerInfo *pi, unsigned char *ev, int ne);
    Bool	    (*Init) (KdPointerInfo *pi);
d241 1
a241 1
static int mouseValid (KdPointerInfo *pi, unsigned char *ev, int ne)
d243 1
a243 1
    Kmouse		*km = pi->driverPrivate;
d258 1
a258 1
static Bool threeComplete (KdPointerInfo *pi, unsigned char *ev, int ne)
d263 1
a263 1
static Bool fourComplete (KdPointerInfo *pi, unsigned char *ev, int ne)
d268 1
a268 1
static Bool fiveComplete (KdPointerInfo *pi, unsigned char *ev, int ne)
d273 1
a273 1
static Bool MouseReasonable (KdPointerInfo *pi, unsigned long flags, int dx, int dy)
d275 1
a275 1
    Kmouse		*km = pi->driverPrivate;
d299 1
a299 1
static Bool ps2Parse (KdPointerInfo *pi, unsigned char *ev, int ne)
d301 1
a301 1
    Kmouse	    *km = pi->driverPrivate;
d336 1
a336 1
    if (!MouseReasonable (pi, flags, dx, dy))
d340 1
a340 1
	KdEnqueuePointerEvent (pi, flags, dx, dy, 0);
d344 1
a344 1
	    KdEnqueuePointerEvent (pi, flags, dx, dy, 0);
d350 1
a350 1
static Bool ps2Init (KdPointerInfo *pi);
d453 1
a453 1
ps2SkipInit (KdPointerInfo *pi, int ninit, Bool ret_next)
d455 1
a455 1
    Kmouse  *km = pi->driverPrivate;
d484 1
a484 1
ps2Init (KdPointerInfo *pi)
d486 1
a486 1
    Kmouse	    *km = pi->driverPrivate;
d502 1
a502 1
    id = ps2SkipInit (pi, 0, TRUE);
d527 1
a527 1
    (void) ps2SkipInit (pi, ninit, FALSE);
d531 1
a531 1
static Bool busParse (KdPointerInfo *pi, unsigned char *ev, int ne)
d533 1
a533 1
    Kmouse	    *km = pi->driverPrivate;
d546 1
a546 1
    if (!MouseReasonable (pi, flags, dx, dy))
d549 1
a549 1
	KdEnqueuePointerEvent (pi, flags, dx, dy, 0);
d564 1
a564 1
static Bool msParse (KdPointerInfo *pi, unsigned char *ev, int ne)
d566 1
a566 1
    Kmouse	    *km = pi->driverPrivate;
d579 1
a579 1
    if (!MouseReasonable (pi, flags, dx, dy))
d582 1
a582 1
	KdEnqueuePointerEvent (pi, flags, dx, dy, 0);
d603 1
a603 1
static Bool logiComplete (KdPointerInfo *pi, unsigned char *ev, int ne)
d605 1
a605 1
    Kmouse		*km = pi->driverPrivate;
d614 1
a614 1
static int logiValid (KdPointerInfo *pi, unsigned char *ev, int ne)
d616 1
a616 1
    Kmouse		*km = pi->driverPrivate;
d635 1
a635 1
static Bool logiParse (KdPointerInfo *pi, unsigned char *ev, int ne)
d637 1
a637 1
    Kmouse	    *km = pi->driverPrivate;
d663 1
a663 1
    if (!MouseReasonable (pi, flags, dx, dy))
d666 1
a666 1
	KdEnqueuePointerEvent (pi, flags, dx, dy, 0);
d685 1
a685 1
static Bool mscParse (KdPointerInfo *pi, unsigned char *ev, int ne)
d687 1
a687 1
    Kmouse	    *km = pi->driverPrivate;
d702 1
a702 1
    if (!MouseReasonable (pi, flags, dx, dy))
d705 1
a705 1
	KdEnqueuePointerEvent (pi, flags, dx, dy, 0);
d813 2
a814 2
    KdPointerInfo   *pi = closure;
    Kmouse	    *km = pi->driverPrivate;
d838 1
a838 1
	i = (*km->prot->Valid) (pi, event, ne);
d870 1
a870 1
	    if ((*km->prot->Complete) (pi, event, ne))
d872 1
a872 1
		if ((*km->prot->Parse) (pi, event, ne))
d899 1
a899 1
			    if (km->prot->Init && !(*km->prot->Init) (pi))
a925 1
    "/dev/input/mice",
d928 1
d936 2
a937 2
static Status
MouseInit (KdPointerInfo *pi)
d942 27
a968 16

    if (!pi)
        return BadImplementation;
    
    if (!pi->path || strcmp(pi->path, "auto") == 0) {
        for (i = 0; i < NUM_DEFAULT_MOUSE; i++) {
            fd = open (kdefaultMouse[i], 2);
            if (fd >= 0) {
                pi->path = KdSaveString (kdefaultMouse[i]);
                break;
            }
        }
    }
    else {
        fd = open (pi->path, 2);
    }
d970 19
a988 13
    if (fd < 0)
        return BadMatch;

    close(fd);

    km = (Kmouse *) xalloc (sizeof (Kmouse));
    if (km) {
        km->iob.avail = km->iob.used = 0;
        MouseFirstProtocol(km, "exps/2");
        km->i_prot = 0;
        km->tty = isatty (fd);
        km->iob.fd = -1;
        pi->driverPrivate = km;
d990 1
a990 6
    else {
        close (fd);
        return BadAlloc;
    }

    return Success;
d993 2
a994 2
static Status
MouseEnable (KdPointerInfo *pi)
d996 1
a996 1
    Kmouse *km;
d998 2
a999 10
    if (!pi || !pi->driverPrivate || !pi->path)
        return BadImplementation;

    km = pi->driverPrivate;

    km->iob.fd = open(pi->path, 2);
    if (km->iob.fd < 0)
        return BadMatch;

    if (!KdRegisterFd (km->iob.fd, MouseRead, pi))
d1001 6
a1006 2
        close(km->iob.fd);
        return BadAlloc;
a1007 20

    return Success;
}

static void
MouseDisable (KdPointerInfo *pi)
{
    Kmouse *km;
    if (!pi || !pi->driverPrivate)
        return;
    
    km = pi->driverPrivate;
    KdUnregisterFd (pi, km->iob.fd, TRUE);
}

static void
MouseFini (KdPointerInfo *pi)
{
    xfree (pi->driverPrivate);
    pi->driverPrivate = NULL;
d1010 1
a1010 2
KdPointerDriver LinuxMouseDriver = {
    "mouse",
a1011 2
    MouseEnable,
    MouseDisable,
a1012 1
    NULL,
@

