head	1.6;
access;
symbols
	OPENBSD_5_7:1.5.0.6
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.4.0.24
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.22
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.20
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.18
	OPENBSD_5_0:1.4.0.16
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.12
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.14
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.10
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.8
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.6
date	2015.04.18.10.22.11;	author matthieu;	state dead;
branches;
next	1.5;
commitid	OR7BzFIxidTrshaf;

1.5
date	2014.02.15.15.00.28;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.23.14.28.10;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.27.05.17.06;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.25.19.10.43;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.25.15.33.32;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Bury kdriver/wscons code in the Attic.
It has never worked and there is no plan to finish it.
@
text
@/* $OpenBSD: keyboard.c,v 1.5 2014/02/15 15:00:28 matthieu Exp $ */
/*
 * Copyright (c) 2007 Matthieu Herrb <matthieu@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif
#include "kdrive.h"

#include <X11/keysym.h>

#include <errno.h>
#include <sys/ioctl.h>
#include <dev/wscons/wsconsio.h>

#define DBG(x) ErrorF x

extern int WsconsConsoleFd;

static void
wskbdLoad(void)
{
	DBG(("wskbdLoad\n"));

	/* Read kernel Mapping */
}

#define NUM_EVENTS 64

static void
wskbdRead(int fd, void *closure)
{
	struct wscons_event events[NUM_EVENTS];
	int i, n, type;

	DBG(("wskbdRead\n"));
	if ((n = read(fd, events, sizeof(events))) > 0) {
		n /= sizeof(struct wscons_event);
		for (i = 0; i < n; i++) {
			type = events[i].type;
			if (type == WSCONS_EVENT_KEY_UP || 
			    type == WSCONS_EVENT_KEY_DOWN) {
				
				KdEnqueueKeyboardEvent(closure, 
				    events[i].value, 
				    type == WSCONS_EVENT_KEY_DOWN ? 
				    TRUE : FALSE);
			}
		} /* for */
	}
}

static int
wskbdEnable(KdKeyboardInfo *ki)
{
	int option = WSKBD_RAW;
	int fd = WsconsConsoleFd;
	
	DBG(("wskbdEnable\n"));
	if (ki == NULL) 
		return !Success;
	ki->driverPrivate = (void *)(intptr_t)fd;

	/* Switch to X mode */
	if (ioctl(fd, WSKBDIO_SETMODE, &option) == -1) {
		ErrorF("wskbdEnable: WSKBDIO_SETMODE: %d\n", errno);
		return -1;
	}
	KdRegisterFd (fd, wskbdRead, ki);
	return Success;
}

static void
wskbdDisable(KdKeyboardInfo *ki)
{
	int option = WSKBD_TRANSLATED;
	int fd;

	DBG(("wskbdDisable\n"));
	if (ki == NULL)
		return;
	fd = (int)(intptr_t)ki->driverPrivate;
	/* Back to console mode */
	ioctl(fd, WSKBDIO_SETMODE, &option);
}

static int
wskbdInit(KdKeyboardInfo *ki)
{
	DBG(("wskbdInit\n"));
	if (!ki)
		return !Success;

	if (ki->path)
		free(ki->path);
	ki->path = strdup("console");
	if (ki->name)
		free(ki->name);
	ki->name = strdup("Wscons keyboard");
	
	wskbdLoad();
	return Success;
}


static void
wskbdLeds(KdKeyboardInfo *ki, int leds)
{
	DBG(("wskbdLeds %d\n", leds));
	if (!ki)
		return;
	if (ioctl(WsconsConsoleFd, WSKBDIO_SETLEDS, &leds) == -1)
		ErrorF("wskbd WSKBDIO_SETLEDS: %s\n", 
		    strerror(errno));
}
	
KdKeyboardDriver WsconsKeyboardDriver = {
	"keyboard",
	.Init = wskbdInit,
	.Enable = wskbdEnable,
	.Leds = wskbdLeds,
	.Disable = wskbdDisable
};
@


1.5
log
@Fix build of (disabled) wsfb kdrive backend.
@
text
@d1 1
a1 1
/* $OpenBSD: keyboard.c,v 1.4 2007/12/23 14:28:10 matthieu Exp $ */
@


1.4
log
@Adapt OpenBSD/wscons kdrive drivers to changes in xserver 1.4.
Still not working but at least building again.
@
text
@d1 1
a1 1
/* $OpenBSD: keyboard.c,v 1.3 2007/05/27 05:17:06 matthieu Exp $ */
d75 1
a75 1
	ki->driverPrivate = (void *)fd;
d95 1
a95 1
	fd = (int)ki->driverPrivate;
d108 2
a109 2
		xfree(ki->path);
	ki->path = KdSaveString("console");
d111 2
a112 2
		xfree(ki->name);
	ki->name = KdSaveString("Wscons keyboard");
@


1.3
log
@- rename some functions for consistancy
- fill more code
@
text
@d1 1
a1 1
/* $OpenBSD: keyboard.c,v 1.2 2007/05/25 19:10:43 matthieu Exp $ */
d26 1
a31 1
static int WsconsKbdType;
a47 1
	unsigned char b;
d50 1
a50 1
	if ((n = read(WsconsConsoleFd, events, sizeof(events))) > 0) {
d57 2
a58 1
				KdEnqueueKeyboardEvent(events[i].value, 
d67 1
a67 1
wskbdEnable(int fd, void *closure)
d70 1
d73 4
d82 2
a83 1
	return fd;
d87 1
a87 1
wskbdDisable(int fd, void *closure)
d90 1
d93 3
d101 1
a101 1
wskbdInit(void)
d104 12
a115 7
	if (!WsconsKbdType)
		WsconsKbdType = KdAllocInputType();
	KdRegisterFd(WsconsKbdType, WsconsConsoleFd, wskbdRead, 0);
	wskbdEnable(WsconsConsoleFd, 0);
	KdRegisterFdEnableDisable(WsconsConsoleFd,
	    wskbdEnable, wskbdDisable);
	return 1;
a117 7
static void
wskbdFini(void)
{
	DBG(("wskbdFini\n"));
	wskbdDisable(WsconsConsoleFd, 0);
	KdUnregisterFds(WsconsKbdType, FALSE);
}
d120 1
a120 1
wskbdLeds(int leds)
d123 2
a128 15

static void
wskbdBell(int volume, int pitch, int duration)
{
	struct wskbd_bell_data wsb;

	DBG(("wskbdBell volume %d pictch %d duration %d\n",
		volume, pitch, duration));
	wsb.which = WSKBD_BELL_DOALL;
	wsb.pitch = pitch;
	wsb.period = duration;
	wsb.volume = volume;
	if (ioctl(WsconsConsoleFd, WSKBDIO_COMPLEXBELL, &wsb) == -1)
		ErrorF("WsconsKeyboardBell: %s\n", strerror(errno));
}
d130 6
a135 7
KdKeyboardFuncs WsconsKeyboardFuncs = {
	wskbdLoad,
	wskbdInit,
	wskbdLeds,
	wskbdBell,
	wskbdFini,
	3,
@


1.2
log
@Start filling the holes.
@
text
@d1 1
a1 1
/* $OpenBSD: keyboard.c,v 1.1 2007/05/25 15:33:32 matthieu Exp $ */
d28 2
d34 1
a34 1
WsconsKeyboardLoad(void)
d36 2
d41 2
d44 1
a44 1
WsconsKeyboardRead(int fd, void *closure)
d46 2
d50 14
a63 2
	/* read and enqueue events */
	KdEnqueueKeyboardEvent(b & 0x7f, b & 0x80);
d67 1
a67 1
WsconsKeyboardEnable(int fd, void *closure)
d71 1
d74 1
a74 1
		ErrorF("WsconsKeyboardEnable: WSKBDIO_SETMODE: %d\n", errno);
d81 1
a81 1
WsconsKeyboardDisable(int fd, void *closure)
d85 1
d91 1
a91 1
WsconsKeyboardInit(void)
d93 1
d96 2
a97 2
	KdRegisterFd(WsconsKbdType, WsconsConsoleFd, WsconsKeyboardRead, 0);
	WsconsKeyboardEnable(WsconsConsoleFd, 0);
d99 1
a99 1
	    WsconsKeyboardEnable, WsconsKeyboardDisable);
d104 1
a104 1
WsconsKeyboardFini(void)
d106 2
a107 1
	WsconsKeyboardDisable(WsconsConsoleFd, 0);
d112 1
a112 1
WsconsKeyboardLeds(int leds)
d114 4
a117 1
	ioctl(WsconsConsoleFd, WSKBDIO_SETLEDS, &leds);
d121 1
a121 1
WsconsKeyboardBell(int volume, int pitch, int duration)
d125 2
d131 2
a132 1
	ioctl(WsconsConsoleFd, WSKBDIO_COMPLEXBELL, &wsb);
d136 5
a140 5
	WsconsKeyboardLoad,
	WsconsKeyboardInit,
	WsconsKeyboardLeds,
	WsconsKeyboardBell,
	WsconsKeyboardFini,
@


1.1
log
@Add skeleton implentation of Xwscons a kdrive based X server for
wscons's dumb framebuffer mode. This is an empty shell for now.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d25 3
d46 1
a46 1
static void
d49 2
d52 5
d62 2
d65 1
d90 1
d96 7
@

