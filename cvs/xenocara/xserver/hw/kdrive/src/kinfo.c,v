head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.22
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.20
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.18
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.16
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.14
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.12
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.10
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.56;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.56;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.04.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@/*
 * Copyright Â© 1999 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif
#include "kdrive.h"

KdCardInfo *kdCardInfo;

KdCardInfo *
KdCardInfoAdd(KdCardFuncs * funcs, void *closure)
{
    KdCardInfo *ci, **prev;

    ci = calloc(1, sizeof(KdCardInfo));
    if (!ci)
        return 0;
    for (prev = &kdCardInfo; *prev; prev = &(*prev)->next);
    *prev = ci;
    ci->cfuncs = funcs;
    ci->closure = closure;
    ci->screenList = 0;
    ci->selected = 0;
    ci->next = 0;
    return ci;
}

KdCardInfo *
KdCardInfoLast(void)
{
    KdCardInfo *ci;

    if (!kdCardInfo)
        return 0;
    for (ci = kdCardInfo; ci->next; ci = ci->next);
    return ci;
}

void
KdCardInfoDispose(KdCardInfo * ci)
{
    KdCardInfo **prev;

    for (prev = &kdCardInfo; *prev; prev = &(*prev)->next)
        if (*prev == ci) {
            *prev = ci->next;
            free(ci);
            break;
        }
}

KdScreenInfo *
KdScreenInfoAdd(KdCardInfo * ci)
{
    KdScreenInfo *si, **prev;
    int n;

    si = calloc(1, sizeof(KdScreenInfo));
    if (!si)
        return 0;
    for (prev = &ci->screenList, n = 0; *prev; prev = &(*prev)->next, n++);
    *prev = si;
    si->next = 0;
    si->card = ci;
    si->mynum = n;
    return si;
}

void
KdScreenInfoDispose(KdScreenInfo * si)
{
    KdCardInfo *ci = si->card;
    KdScreenInfo **prev;

    for (prev = &ci->screenList; *prev; prev = &(*prev)->next) {
        if (*prev == si) {
            *prev = si->next;
            free(si);
            if (!ci->screenList)
                KdCardInfoDispose(ci);
            break;
        }
    }
}

KdPointerInfo *
KdNewPointer(void)
{
    KdPointerInfo *pi;
    int i;

    pi = (KdPointerInfo *) calloc(1, sizeof(KdPointerInfo));
    if (!pi)
        return NULL;

    pi->name = strdup("Generic Pointer");
    pi->path = NULL;
    pi->inputClass = KD_MOUSE;
    pi->driver = NULL;
    pi->driverPrivate = NULL;
    pi->next = NULL;
    pi->options = NULL;
    pi->nAxes = 3;
    pi->nButtons = KD_MAX_BUTTON;
    for (i = 1; i < KD_MAX_BUTTON; i++)
        pi->map[i] = i;

    return pi;
}

void
KdFreePointer(KdPointerInfo * pi)
{
    free(pi->name);
    free(pi->path);
    input_option_free_list(&pi->options);
    free(pi);
}

void
KdFreeKeyboard(KdKeyboardInfo * ki)
{
    free(ki->name);
    free(ki->path);
    free(ki->xkbRules);
    free(ki->xkbModel);
    free(ki->xkbLayout);
    ki->next = NULL;
    free(ki);
}
@


1.5
log
@Update to xserver 1.11.2
@
text
@d28 1
a28 1
KdCardInfo  *kdCardInfo;
d31 1
a31 2
KdCardInfoAdd (KdCardFuncs  *funcs,
	       void	    *closure)
d33 1
a33 1
    KdCardInfo	*ci, **prev;
d35 1
a35 1
    ci = calloc(1, sizeof (KdCardInfo));
d37 1
a37 1
	return 0;
d49 1
a49 1
KdCardInfoLast (void)
d51 1
a51 1
    KdCardInfo	*ci;
d54 1
a54 1
	return 0;
d60 1
a60 1
KdCardInfoDispose (KdCardInfo *ci)
d62 1
a62 1
    KdCardInfo	**prev;
d65 5
a69 6
	if (*prev == ci)
	{
	    *prev = ci->next;
	    free(ci);
	    break;
	}
d73 1
a73 1
KdScreenInfoAdd (KdCardInfo *ci)
d75 2
a76 2
    KdScreenInfo    *si, **prev;
    int		    n;
d78 1
a78 1
    si = calloc(1, sizeof (KdScreenInfo));
d80 1
a80 1
	return 0;
d90 1
a90 1
KdScreenInfoDispose (KdScreenInfo *si)
d92 2
a93 2
    KdCardInfo	    *ci = si->card;
    KdScreenInfo    **prev;
d96 7
a102 8
	if (*prev == si)
	{
	    *prev = si->next;
	    free(si);
	    if (!ci->screenList)
		KdCardInfoDispose (ci);
	    break;
	}
d107 1
a107 1
KdNewPointer (void)
d112 1
a112 1
    pi = (KdPointerInfo *)calloc(1, sizeof(KdPointerInfo));
d132 1
a132 1
KdFreePointer(KdPointerInfo *pi)
a133 2
    InputOption *option, *prev = NULL;

d136 1
a136 9

    for (option = pi->options; option; option = option->next) {
        free(prev);
        free(option->key);
        free(option->value);
        prev = option;
    }

    free(prev);
d141 1
a141 1
KdFreeKeyboard(KdKeyboardInfo *ki)
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d2 1
a2 1
 * Copyright © 1999 Keith Packard
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d36 1
a36 1
    ci = xcalloc (1, sizeof (KdCardInfo));
d69 1
a69 1
	    xfree (ci);
d80 1
a80 1
    si = xcalloc (1, sizeof (KdScreenInfo));
d101 1
a101 1
	    xfree (si);
d115 1
a115 1
    pi = (KdPointerInfo *)xcalloc(1, sizeof(KdPointerInfo));
d139 2
a140 2
    xfree(pi->name);
    xfree(pi->path);
d143 3
a145 3
        xfree(prev);
        xfree(option->key);
        xfree(option->value);
d149 2
a150 2
    xfree(prev);
    xfree(pi);
d156 5
a160 5
    xfree(ki->name);
    xfree(ki->path);
    xfree(ki->xkbRules);
    xfree(ki->xkbModel);
    xfree(ki->xkbLayout);
d162 1
a162 1
    xfree(ki);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a31 1
	       KdCardAttr   *attr,
a41 1
    ci->attr = *attr;
d119 1
a119 1
    pi->name = KdSaveString("Generic Pointer");
d139 2
a140 4
    if (pi->name)
        xfree(pi->name);
    if (pi->path)
        xfree(pi->path);
d143 3
a145 6
        if (prev)
            xfree(prev);
        if (option->key)
            xfree(option->key);
        if (option->value)
            xfree(option->value);
d149 1
a149 3
    if (prev)
        xfree(prev);
    
d152 1
a152 1
 
d156 5
a160 4
    if (ki->name)
        xfree(ki->name);
    if (ki->path)
        xfree(ki->path);
@


1.1
log
@Initial revision
@
text
@a1 2
 * Id: kinfo.c,v 1.1 1999/11/02 03:54:46 keithp Exp $
 *
a21 1
/* $RCSId: xc/programs/Xserver/hw/kdrive/kinfo.c,v 1.2 2000/02/23 20:29:53 dawes Exp $ */
d37 1
a37 1
    ci = (KdCardInfo *) xalloc (sizeof (KdCardInfo));
a39 1
    bzero (ci, sizeof (KdCardInfo));
d82 1
a82 1
    si = (KdScreenInfo *) xalloc (sizeof (KdScreenInfo));
a84 1
    bzero (si, sizeof (KdScreenInfo));
d99 1
a99 1
    for (prev = &ci->screenList; *prev; prev = &(*prev)->next)
d108 1
d111 5
a115 1
KdMouseInfo *kdMouseInfo;
d117 15
a131 4
KdMouseInfo *
KdMouseInfoAdd (void)
{
    KdMouseInfo	*mi, **prev;
d133 1
a133 7
    mi = (KdMouseInfo *) xalloc (sizeof (KdMouseInfo));
    if (!mi)
	return 0;
    bzero (mi, sizeof (KdMouseInfo));
    for (prev = &kdMouseInfo; *prev; prev = &(*prev)->next);
    *prev = mi;
    return mi;
d137 1
a137 1
KdMouseInfoDispose (KdMouseInfo *mi)
d139 1
a139 1
    KdMouseInfo	**prev;
d141 30
a170 11
    for (prev = &kdMouseInfo; *prev; prev = &(*prev)->next)
	if (*prev == mi)
	{
	    *prev = mi->next;
	    if (mi->name)
		xfree (mi->name);
	    if (mi->prot)
		xfree (mi->prot);
	    xfree (mi);
	    break;
	}
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d24 1
d104 1
a104 1
    for (prev = &ci->screenList; *prev; prev = &(*prev)->next) {
a112 1
    }
d115 4
a118 2
KdPointerInfo *
KdNewPointer (void)
d120 1
a120 2
    KdPointerInfo *pi;
    int i;
d122 7
a128 17
    pi = (KdPointerInfo *)xcalloc(1, sizeof(KdPointerInfo));
    if (!pi)
        return NULL;

    pi->name = KdSaveString("Generic Pointer");
    pi->path = NULL;
    pi->inputClass = KD_MOUSE;
    pi->driver = NULL;
    pi->driverPrivate = NULL;
    pi->next = NULL;
    pi->options = NULL;
    pi->nAxes = 3;
    pi->nButtons = KD_MAX_BUTTON;
    for (i = 1; i < KD_MAX_BUTTON; i++)
        pi->map[i] = i;

    return pi;
d132 1
a132 1
KdFreePointer(KdPointerInfo *pi)
d134 1
a134 1
    InputOption *option, *prev = NULL;
d136 11
a146 30
    if (pi->name)
        xfree(pi->name);
    if (pi->path)
        xfree(pi->path);

    for (option = pi->options; option; option = option->next) {
        if (prev)
            xfree(prev);
        if (option->key)
            xfree(option->key);
        if (option->value)
            xfree(option->value);
        prev = option;
    }

    if (prev)
        xfree(prev);
    
    xfree(pi);
}
 
void
KdFreeKeyboard(KdKeyboardInfo *ki)
{
    if (ki->name)
        xfree(ki->name);
    if (ki->path)
        xfree(ki->path);
    ki->next = NULL;
    xfree(ki);
@

