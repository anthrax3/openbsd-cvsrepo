head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	s0SI41sEunLdyFfd;

1.12
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.48;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.19;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.57;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.57;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.04.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright Â© 1999 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif
#include "kdrive.h"
#include <mivalidate.h>
#include <dixstruct.h>
#include "privates.h"
#ifdef RANDR
#include <randrstr.h>
#endif

#ifdef XV
#include "kxv.h"
#endif

#ifdef DPMSExtension
#include "dpmsproc.h"
#endif

#ifdef HAVE_EXECINFO_H
#include <execinfo.h>
#endif

#include <signal.h>

typedef struct _kdDepths {
    CARD8 depth;
    CARD8 bpp;
} KdDepths;

KdDepths kdDepths[] = {
    {1, 1},
    {4, 4},
    {8, 8},
    {15, 16},
    {16, 16},
    {24, 32},
    {32, 32}
};

#define NUM_KD_DEPTHS (sizeof (kdDepths) / sizeof (kdDepths[0]))

#define KD_DEFAULT_BUTTONS 5

DevPrivateKeyRec kdScreenPrivateKeyRec;
unsigned long kdGeneration;

Bool kdVideoTest;
unsigned long kdVideoTestTime;
Bool kdEmulateMiddleButton;
Bool kdRawPointerCoordinates;
Bool kdDisableZaphod;
Bool kdAllowZap;
Bool kdEnabled;
int kdSubpixelOrder;
int kdVirtualTerminal = -1;
Bool kdSwitchPending;
char *kdSwitchCmd;
DDXPointRec kdOrigin;
Bool kdHasPointer = FALSE;
Bool kdHasKbd = FALSE;

static Bool kdCaughtSignal = FALSE;

/*
 * Carry arguments from InitOutput through driver initialization
 * to KdScreenInit
 */

KdOsFuncs *kdOsFuncs;

void
KdDisableScreen(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);

    if (!pScreenPriv->enabled)
        return;
    if (!pScreenPriv->closed)
        SetRootClip(pScreen, ROOT_CLIP_NONE);
    KdDisableColormap(pScreen);
    if (!pScreenPriv->screen->dumb && pScreenPriv->card->cfuncs->disableAccel)
        (*pScreenPriv->card->cfuncs->disableAccel) (pScreen);
    if (!pScreenPriv->screen->softCursor &&
        pScreenPriv->card->cfuncs->disableCursor)
        (*pScreenPriv->card->cfuncs->disableCursor) (pScreen);
    if (pScreenPriv->card->cfuncs->dpms)
        (*pScreenPriv->card->cfuncs->dpms) (pScreen, KD_DPMS_NORMAL);
    pScreenPriv->enabled = FALSE;
    if (pScreenPriv->card->cfuncs->disable)
        (*pScreenPriv->card->cfuncs->disable) (pScreen);
}

static void
KdDoSwitchCmd(const char *reason)
{
    if (kdSwitchCmd) {
        char *command;
        int ret;

        if (asprintf(&command, "%s %s", kdSwitchCmd, reason) == -1)
            return;

        /* Ignore the return value from system; I'm not sure
         * there's anything more useful to be done when
         * it fails
         */
        ret = system(command);
        (void) ret;
        free(command);
    }
}

void
KdSuspend(void)
{
    KdCardInfo *card;
    KdScreenInfo *screen;

    if (kdEnabled) {
        for (card = kdCardInfo; card; card = card->next) {
            for (screen = card->screenList; screen; screen = screen->next)
                if (screen->mynum == card->selected && screen->pScreen)
                    KdDisableScreen(screen->pScreen);
            if (card->driver && card->cfuncs->restore)
                (*card->cfuncs->restore) (card);
        }
        KdDisableInput();
        KdDoSwitchCmd("suspend");
    }
}

void
KdDisableScreens(void)
{
    KdSuspend();
    if (kdEnabled) {
        if (kdOsFuncs->Disable)
            (*kdOsFuncs->Disable) ();
        kdEnabled = FALSE;
    }
}

Bool
KdEnableScreen(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);

    if (pScreenPriv->enabled)
        return TRUE;
    if (pScreenPriv->card->cfuncs->enable)
        if (!(*pScreenPriv->card->cfuncs->enable) (pScreen))
            return FALSE;
    pScreenPriv->enabled = TRUE;
    pScreenPriv->dpmsState = KD_DPMS_NORMAL;
    pScreenPriv->card->selected = pScreenPriv->screen->mynum;
    if (!pScreenPriv->screen->softCursor &&
        pScreenPriv->card->cfuncs->enableCursor)
        (*pScreenPriv->card->cfuncs->enableCursor) (pScreen);
    if (!pScreenPriv->screen->dumb && pScreenPriv->card->cfuncs->enableAccel)
        (*pScreenPriv->card->cfuncs->enableAccel) (pScreen);
    KdEnableColormap(pScreen);
    SetRootClip(pScreen, ROOT_CLIP_FULL);
    if (pScreenPriv->card->cfuncs->dpms)
        (*pScreenPriv->card->cfuncs->dpms) (pScreen, pScreenPriv->dpmsState);
    return TRUE;
}

void
KdResume(void)
{
    KdCardInfo *card;
    KdScreenInfo *screen;

    if (kdEnabled) {
        KdDoSwitchCmd("resume");
        for (card = kdCardInfo; card; card = card->next) {
            if (card->cfuncs->preserve)
                (*card->cfuncs->preserve) (card);
            for (screen = card->screenList; screen; screen = screen->next)
                if (screen->mynum == card->selected && screen->pScreen)
                    KdEnableScreen(screen->pScreen);
        }
        KdEnableInput();
        KdReleaseAllKeys();
    }
}

void
KdEnableScreens(void)
{
    if (!kdEnabled) {
        kdEnabled = TRUE;
        if (kdOsFuncs->Enable)
            (*kdOsFuncs->Enable) ();
    }
    KdResume();
}

void
KdProcessSwitch(void)
{
    if (kdEnabled)
        KdDisableScreens();
    else
        KdEnableScreens();
}

void
AbortDDX(enum ExitCode error)
{
    KdDisableScreens();
    if (kdOsFuncs) {
        if (kdEnabled && kdOsFuncs->Disable)
            (*kdOsFuncs->Disable) ();
        if (kdOsFuncs->Fini)
            (*kdOsFuncs->Fini) ();
        KdDoSwitchCmd("stop");
    }

    if (kdCaughtSignal)
        OsAbort();
}

void
ddxGiveUp(enum ExitCode error)
{
    AbortDDX(error);
}

Bool kdDumbDriver;
Bool kdSoftCursor;

const char *
KdParseFindNext(const char *cur, const char *delim, char *save, char *last)
{
    while (*cur && !strchr(delim, *cur)) {
        *save++ = *cur++;
    }
    *save = 0;
    *last = *cur;
    if (*cur)
        cur++;
    return cur;
}

Rotation
KdAddRotation(Rotation a, Rotation b)
{
    Rotation rotate = (a & RR_Rotate_All) * (b & RR_Rotate_All);
    Rotation reflect = (a & RR_Reflect_All) ^ (b & RR_Reflect_All);

    if (rotate > RR_Rotate_270)
        rotate /= (RR_Rotate_270 * RR_Rotate_90);
    return reflect | rotate;
}

Rotation
KdSubRotation(Rotation a, Rotation b)
{
    Rotation rotate = (a & RR_Rotate_All) * 16 / (b & RR_Rotate_All);
    Rotation reflect = (a & RR_Reflect_All) ^ (b & RR_Reflect_All);

    if (rotate > RR_Rotate_270)
        rotate /= (RR_Rotate_270 * RR_Rotate_90);
    return reflect | rotate;
}

void
KdParseScreen(KdScreenInfo * screen, const char *arg)
{
    char delim;
    char save[1024];
    int i;
    int pixels, mm;

    screen->dumb = kdDumbDriver;
    screen->softCursor = kdSoftCursor;
    screen->origin = kdOrigin;
    screen->randr = RR_Rotate_0;
    screen->x = 0;
    screen->y = 0;
    screen->width = 0;
    screen->height = 0;
    screen->width_mm = 0;
    screen->height_mm = 0;
    screen->subpixel_order = kdSubpixelOrder;
    screen->rate = 0;
    screen->fb.depth = 0;
    if (!arg)
        return;
    if (strlen(arg) >= sizeof(save))
        return;

    for (i = 0; i < 2; i++) {
        arg = KdParseFindNext(arg, "x/+@@XY", save, &delim);
        if (!save[0])
            return;

        pixels = atoi(save);
        mm = 0;

        if (delim == '/') {
            arg = KdParseFindNext(arg, "x+@@XY", save, &delim);
            if (!save[0])
                return;
            mm = atoi(save);
        }

        if (i == 0) {
            screen->width = pixels;
            screen->width_mm = mm;
        }
        else {
            screen->height = pixels;
            screen->height_mm = mm;
        }
        if (delim != 'x' && delim != '+' && delim != '@@' &&
            delim != 'X' && delim != 'Y' &&
            (delim != '\0' || i == 0))
            return;
    }

    kdOrigin.x += screen->width;
    kdOrigin.y = 0;
    kdDumbDriver = FALSE;
    kdSoftCursor = FALSE;
    kdSubpixelOrder = SubPixelUnknown;

    if (delim == '+') {
        arg = KdParseFindNext(arg, "+@@xXY", save, &delim);
        if (save[0])
            screen->x = atoi(save);
    }

    if (delim == '+') {
        arg = KdParseFindNext(arg, "@@xXY", save, &delim);
        if (save[0])
            screen->y = atoi(save);
    }

    if (delim == '@@') {
        arg = KdParseFindNext(arg, "xXY", save, &delim);
        if (save[0]) {
            int rotate = atoi(save);

            if (rotate < 45)
                screen->randr = RR_Rotate_0;
            else if (rotate < 135)
                screen->randr = RR_Rotate_90;
            else if (rotate < 225)
                screen->randr = RR_Rotate_180;
            else if (rotate < 315)
                screen->randr = RR_Rotate_270;
            else
                screen->randr = RR_Rotate_0;
        }
    }
    if (delim == 'X') {
        arg = KdParseFindNext(arg, "xY", save, &delim);
        screen->randr |= RR_Reflect_X;
    }

    if (delim == 'Y') {
        arg = KdParseFindNext(arg, "xY", save, &delim);
        screen->randr |= RR_Reflect_Y;
    }

    arg = KdParseFindNext(arg, "x/,", save, &delim);
    if (save[0]) {
        screen->fb.depth = atoi(save);
        if (delim == '/') {
            arg = KdParseFindNext(arg, "x,", save, &delim);
            if (save[0])
                screen->fb.bitsPerPixel = atoi(save);
        }
        else
            screen->fb.bitsPerPixel = 0;
    }

    if (delim == 'x') {
        arg = KdParseFindNext(arg, "x", save, &delim);
        if (save[0])
            screen->rate = atoi(save);
    }
}

/*
 * Mouse argument syntax:
 *
 *  device,protocol,options...
 *
 *  Options are any of:
 *	1-5	    n button mouse
 *	2button	    emulate middle button
 *	{NMO}	    Reorder buttons
 */

void
KdParseRgba(char *rgba)
{
    if (!strcmp(rgba, "rgb"))
        kdSubpixelOrder = SubPixelHorizontalRGB;
    else if (!strcmp(rgba, "bgr"))
        kdSubpixelOrder = SubPixelHorizontalBGR;
    else if (!strcmp(rgba, "vrgb"))
        kdSubpixelOrder = SubPixelVerticalRGB;
    else if (!strcmp(rgba, "vbgr"))
        kdSubpixelOrder = SubPixelVerticalBGR;
    else if (!strcmp(rgba, "none"))
        kdSubpixelOrder = SubPixelNone;
    else
        kdSubpixelOrder = SubPixelUnknown;
}

void
KdUseMsg(void)
{
    ErrorF("\nTinyX Device Dependent Usage:\n");
    ErrorF
        ("-screen WIDTH[/WIDTHMM]xHEIGHT[/HEIGHTMM][+[-]XOFFSET][+[-]YOFFSET][@@ROTATION][X][Y][xDEPTH/BPP[xFREQ]]  Specify screen characteristics\n");
    ErrorF
        ("-rgba rgb/bgr/vrgb/vbgr/none   Specify subpixel ordering for LCD panels\n");
    ErrorF
        ("-mouse driver [,n,,options]    Specify the pointer driver and its options (n is the number of buttons)\n");
    ErrorF
        ("-keybd driver [,,options]      Specify the keyboard driver and its options\n");
    ErrorF("-zaphod          Disable cursor screen switching\n");
    ErrorF("-2button         Emulate 3 button mouse\n");
    ErrorF("-3button         Disable 3 button mouse emulation\n");
    ErrorF
        ("-rawcoord        Don't transform pointer coordinates on rotation\n");
    ErrorF("-dumb            Disable hardware acceleration\n");
    ErrorF("-softCursor      Force software cursor\n");
    ErrorF("-videoTest       Start the server, pause momentarily and exit\n");
    ErrorF
        ("-origin X,Y      Locates the next screen in the the virtual screen (Xinerama)\n");
    ErrorF("-switchCmd       Command to execute on vt switch\n");
    ErrorF("-zap             Terminate server on Ctrl+Alt+Backspace\n");
    ErrorF
        ("vtxx             Use virtual terminal xx instead of the next available\n");
}

int
KdProcessArgument(int argc, char **argv, int i)
{
    KdCardInfo *card;
    KdScreenInfo *screen;

    if (!strcmp(argv[i], "-screen")) {
        if ((i + 1) < argc) {
            card = KdCardInfoLast();
            if (!card) {
                InitCard(0);
                card = KdCardInfoLast();
            }
            if (card) {
                screen = KdScreenInfoAdd(card);
                KdParseScreen(screen, argv[i + 1]);
            }
            else
                ErrorF("No matching card found!\n");
        }
        else
            UseMsg();
        return 2;
    }
    if (!strcmp(argv[i], "-zaphod")) {
        kdDisableZaphod = TRUE;
        return 1;
    }
    if (!strcmp(argv[i], "-zap")) {
        kdAllowZap = TRUE;
        return 1;
    }
    if (!strcmp(argv[i], "-3button")) {
        kdEmulateMiddleButton = FALSE;
        return 1;
    }
    if (!strcmp(argv[i], "-2button")) {
        kdEmulateMiddleButton = TRUE;
        return 1;
    }
    if (!strcmp(argv[i], "-rawcoord")) {
        kdRawPointerCoordinates = 1;
        return 1;
    }
    if (!strcmp(argv[i], "-dumb")) {
        kdDumbDriver = TRUE;
        return 1;
    }
    if (!strcmp(argv[i], "-softCursor")) {
        kdSoftCursor = TRUE;
        return 1;
    }
    if (!strcmp(argv[i], "-videoTest")) {
        kdVideoTest = TRUE;
        return 1;
    }
    if (!strcmp(argv[i], "-origin")) {
        if ((i + 1) < argc) {
            char *x = argv[i + 1];
            char *y = strchr(x, ',');

            if (x)
                kdOrigin.x = atoi(x);
            else
                kdOrigin.x = 0;
            if (y)
                kdOrigin.y = atoi(y + 1);
            else
                kdOrigin.y = 0;
        }
        else
            UseMsg();
        return 2;
    }
    if (!strcmp(argv[i], "-rgba")) {
        if ((i + 1) < argc)
            KdParseRgba(argv[i + 1]);
        else
            UseMsg();
        return 2;
    }
    if (!strcmp(argv[i], "-switchCmd")) {
        if ((i + 1) < argc)
            kdSwitchCmd = argv[i + 1];
        else
            UseMsg();
        return 2;
    }
    if (!strncmp(argv[i], "vt", 2) &&
        sscanf(argv[i], "vt%2d", &kdVirtualTerminal) == 1) {
        return 1;
    }
    if (!strcmp(argv[i], "-mouse") || !strcmp(argv[i], "-pointer")) {
        if (i + 1 >= argc)
            UseMsg();
        KdAddConfigPointer(argv[i + 1]);
        kdHasPointer = TRUE;
        return 2;
    }
    if (!strcmp(argv[i], "-keybd")) {
        if (i + 1 >= argc)
            UseMsg();
        KdAddConfigKeyboard(argv[i + 1]);
        kdHasKbd = TRUE;
        return 2;
    }

    return 0;
}

/*
 * These are getting tossed in here until I can think of where
 * they really belong
 */

void
KdOsInit(KdOsFuncs * pOsFuncs)
{
    kdOsFuncs = pOsFuncs;
    if (pOsFuncs) {
        if (serverGeneration == 1) {
            KdDoSwitchCmd("start");
            if (pOsFuncs->Init)
                (*pOsFuncs->Init) ();
        }
    }
}

Bool
KdAllocatePrivates(ScreenPtr pScreen)
{
    KdPrivScreenPtr pScreenPriv;

    if (kdGeneration != serverGeneration)
        kdGeneration = serverGeneration;

    if (!dixRegisterPrivateKey(&kdScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    pScreenPriv = calloc(1, sizeof(*pScreenPriv));
    if (!pScreenPriv)
        return FALSE;
    KdSetScreenPriv(pScreen, pScreenPriv);
    return TRUE;
}

Bool
KdCreateScreenResources(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    KdCardInfo *card = pScreenPriv->card;
    Bool ret;

    pScreen->CreateScreenResources = pScreenPriv->CreateScreenResources;
    if (pScreen->CreateScreenResources)
        ret = (*pScreen->CreateScreenResources) (pScreen);
    else
        ret = -1;
    pScreenPriv->CreateScreenResources = pScreen->CreateScreenResources;
    pScreen->CreateScreenResources = KdCreateScreenResources;
    if (ret && card->cfuncs->createRes)
        ret = (*card->cfuncs->createRes) (pScreen);
    return ret;
}

Bool
KdCloseScreen(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    KdCardInfo *card = pScreenPriv->card;
    Bool ret;

    if (card->cfuncs->closeScreen)
        (*card->cfuncs->closeScreen)(pScreen);

    pScreenPriv->closed = TRUE;
    pScreen->CloseScreen = pScreenPriv->CloseScreen;

    if (pScreen->CloseScreen)
        ret = (*pScreen->CloseScreen) (pScreen);
    else
        ret = TRUE;

    if (pScreenPriv->dpmsState != KD_DPMS_NORMAL)
        (*card->cfuncs->dpms) (pScreen, KD_DPMS_NORMAL);

    if (screen->mynum == card->selected)
        KdDisableScreen(pScreen);

    /*
     * Restore video hardware when last screen is closed
     */
    if (screen == card->screenList) {
        if (kdEnabled && card->cfuncs->restore)
            (*card->cfuncs->restore) (card);
    }

    if (!pScreenPriv->screen->dumb && card->cfuncs->finiAccel)
        (*card->cfuncs->finiAccel) (pScreen);

    if (!pScreenPriv->screen->softCursor && card->cfuncs->finiCursor)
        (*card->cfuncs->finiCursor) (pScreen);

    if (card->cfuncs->scrfini)
        (*card->cfuncs->scrfini) (screen);

    /*
     * Clean up card when last screen is closed, DIX closes them in
     * reverse order, thus we check for when the first in the list is closed
     */
    if (screen == card->screenList) {
        if (card->cfuncs->cardfini)
            (*card->cfuncs->cardfini) (card);
        /*
         * Clean up OS when last card is closed
         */
        if (card == kdCardInfo) {
            if (kdEnabled) {
                kdEnabled = FALSE;
                if (kdOsFuncs->Disable)
                    (*kdOsFuncs->Disable) ();
            }
        }
    }

    pScreenPriv->screen->pScreen = 0;

    free((void *) pScreenPriv);
    return ret;
}

Bool
KdSaveScreen(ScreenPtr pScreen, int on)
{
    KdScreenPriv(pScreen);
    int dpmsState;

    if (!pScreenPriv->card->cfuncs->dpms)
        return FALSE;

    dpmsState = pScreenPriv->dpmsState;
    switch (on) {
    case SCREEN_SAVER_OFF:
        dpmsState = KD_DPMS_NORMAL;
        break;
    case SCREEN_SAVER_ON:
        if (dpmsState == KD_DPMS_NORMAL)
            dpmsState = KD_DPMS_NORMAL + 1;
        break;
    case SCREEN_SAVER_CYCLE:
        if (dpmsState < KD_DPMS_MAX)
            dpmsState++;
        break;
    case SCREEN_SAVER_FORCER:
        break;
    }
    if (dpmsState != pScreenPriv->dpmsState) {
        if (pScreenPriv->enabled)
            (*pScreenPriv->card->cfuncs->dpms) (pScreen, dpmsState);
        pScreenPriv->dpmsState = dpmsState;
    }
    return TRUE;
}

static Bool
KdCreateWindow(WindowPtr pWin)
{
#ifndef PHOENIX
    if (!pWin->parent) {
        KdScreenPriv(pWin->drawable.pScreen);

        if (!pScreenPriv->enabled) {
            RegionEmpty(&pWin->borderClip);
            RegionBreak(&pWin->clipList);
        }
    }
#endif
    return fbCreateWindow(pWin);
}

void
KdSetSubpixelOrder(ScreenPtr pScreen, Rotation randr)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    int subpixel_order = screen->subpixel_order;
    Rotation subpixel_dir;
    int i;

    static struct {
        int subpixel_order;
        Rotation direction;
    } orders[] = {
        {SubPixelHorizontalRGB, RR_Rotate_0},
        {SubPixelHorizontalBGR, RR_Rotate_180},
        {SubPixelVerticalRGB, RR_Rotate_270},
        {SubPixelVerticalBGR, RR_Rotate_90},
    };

    static struct {
        int bit;
        int normal;
        int reflect;
    } reflects[] = {
        {RR_Reflect_X, SubPixelHorizontalRGB, SubPixelHorizontalBGR},
        {RR_Reflect_X, SubPixelHorizontalBGR, SubPixelHorizontalRGB},
        {RR_Reflect_Y, SubPixelVerticalRGB, SubPixelVerticalBGR},
        {RR_Reflect_Y, SubPixelVerticalRGB, SubPixelVerticalRGB},
    };

    /* map subpixel to direction */
    for (i = 0; i < 4; i++)
        if (orders[i].subpixel_order == subpixel_order)
            break;
    if (i < 4) {
        subpixel_dir =
            KdAddRotation(randr & RR_Rotate_All, orders[i].direction);

        /* map back to subpixel order */
        for (i = 0; i < 4; i++)
            if (orders[i].direction & subpixel_dir) {
                subpixel_order = orders[i].subpixel_order;
                break;
            }
        /* reflect */
        for (i = 0; i < 4; i++)
            if ((randr & reflects[i].bit) &&
                reflects[i].normal == subpixel_order) {
                subpixel_order = reflects[i].reflect;
                break;
            }
    }
    PictureSetSubpixelOrder(pScreen, subpixel_order);
}

/* Pass through AddScreen, which doesn't take any closure */
static KdScreenInfo *kdCurrentScreen;

Bool
KdScreenInit(ScreenPtr pScreen, int argc, char **argv)
{
    KdScreenInfo *screen = kdCurrentScreen;
    KdCardInfo *card = screen->card;
    KdPrivScreenPtr pScreenPriv;

    /*
     * note that screen->fb is set up for the nominal orientation
     * of the screen; that means if randr is rotated, the values
     * there should reflect a rotated frame buffer (or shadow).
     */
    Bool rotated = (screen->randr & (RR_Rotate_90 | RR_Rotate_270)) != 0;
    int width, height, *width_mmp, *height_mmp;

    KdAllocatePrivates(pScreen);

    pScreenPriv = KdGetScreenPriv(pScreen);

    if (!rotated) {
        width = screen->width;
        height = screen->height;
        width_mmp = &screen->width_mm;
        height_mmp = &screen->height_mm;
    }
    else {
        width = screen->height;
        height = screen->width;
        width_mmp = &screen->height_mm;
        height_mmp = &screen->width_mm;
    }
    screen->pScreen = pScreen;
    pScreenPriv->screen = screen;
    pScreenPriv->card = card;
    pScreenPriv->bytesPerPixel = screen->fb.bitsPerPixel >> 3;
    pScreenPriv->dpmsState = KD_DPMS_NORMAL;
    pScreen->x = screen->origin.x;
    pScreen->y = screen->origin.y;

    if (!monitorResolution)
        monitorResolution = 75;
    /*
     * This is done in this order so that backing store wraps
     * our GC functions; fbFinishScreenInit initializes MI
     * backing store
     */
    if (!fbSetupScreen(pScreen,
                       screen->fb.frameBuffer,
                       width, height,
                       monitorResolution, monitorResolution,
                       screen->fb.pixelStride, screen->fb.bitsPerPixel)) {
        return FALSE;
    }

    /*
     * Set colormap functions
     */
    pScreen->InstallColormap = KdInstallColormap;
    pScreen->UninstallColormap = KdUninstallColormap;
    pScreen->ListInstalledColormaps = KdListInstalledColormaps;
    pScreen->StoreColors = KdStoreColors;

    pScreen->SaveScreen = KdSaveScreen;
    pScreen->CreateWindow = KdCreateWindow;

    if (!fbFinishScreenInit(pScreen,
                            screen->fb.frameBuffer,
                            width, height,
                            monitorResolution, monitorResolution,
                            screen->fb.pixelStride, screen->fb.bitsPerPixel)) {
        return FALSE;
    }

    /*
     * Fix screen sizes; for some reason mi takes dpi instead of mm.
     * Rounding errors are annoying
     */
    if (*width_mmp)
        pScreen->mmWidth = *width_mmp;
    else
        *width_mmp = pScreen->mmWidth;
    if (*height_mmp)
        pScreen->mmHeight = *height_mmp;
    else
        *height_mmp = pScreen->mmHeight;

    /*
     * Plug in our own block/wakeup handlers.
     * miScreenInit installs NoopDDA in both places
     */
    pScreen->BlockHandler = KdBlockHandler;
    pScreen->WakeupHandler = KdWakeupHandler;

    if (!fbPictureInit(pScreen, 0, 0))
        return FALSE;
    if (card->cfuncs->initScreen)
        if (!(*card->cfuncs->initScreen) (pScreen))
            return FALSE;

    if (!screen->dumb && card->cfuncs->initAccel)
        if (!(*card->cfuncs->initAccel) (pScreen))
            screen->dumb = TRUE;

    if (card->cfuncs->finishInitScreen)
        if (!(*card->cfuncs->finishInitScreen) (pScreen))
            return FALSE;

    /*
     * Wrap CloseScreen, the order now is:
     *  KdCloseScreen
     *  miBSCloseScreen
     *  fbCloseScreen
     */
    pScreenPriv->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = KdCloseScreen;

    pScreenPriv->CreateScreenResources = pScreen->CreateScreenResources;
    pScreen->CreateScreenResources = KdCreateScreenResources;

    if (screen->softCursor ||
        !card->cfuncs->initCursor || !(*card->cfuncs->initCursor) (pScreen)) {
        /* Use MI for cursor display and event queueing. */
        screen->softCursor = TRUE;
        miDCInitialize(pScreen, &kdPointerScreenFuncs);
    }

    if (!fbCreateDefColormap(pScreen)) {
        return FALSE;
    }

    KdSetSubpixelOrder(pScreen, screen->randr);

    /*
     * Enable the hardware
     */
    if (!kdEnabled) {
        kdEnabled = TRUE;
        if (kdOsFuncs->Enable)
            (*kdOsFuncs->Enable) ();
    }

    if (screen->mynum == card->selected) {
        if (card->cfuncs->preserve)
            (*card->cfuncs->preserve) (card);
        if (card->cfuncs->enable)
            if (!(*card->cfuncs->enable) (pScreen))
                return FALSE;
        pScreenPriv->enabled = TRUE;
        if (!screen->softCursor && card->cfuncs->enableCursor)
            (*card->cfuncs->enableCursor) (pScreen);
        KdEnableColormap(pScreen);
        if (!screen->dumb && card->cfuncs->enableAccel)
            (*card->cfuncs->enableAccel) (pScreen);
    }

    return TRUE;
}

void
KdInitScreen(ScreenInfo * pScreenInfo,
             KdScreenInfo * screen, int argc, char **argv)
{
    KdCardInfo *card = screen->card;

    if (!(*card->cfuncs->scrinit) (screen))
        FatalError("Screen initialization failed!\n");

    if (!card->cfuncs->initAccel)
        screen->dumb = TRUE;
    if (!card->cfuncs->initCursor)
        screen->softCursor = TRUE;
}

static Bool
KdSetPixmapFormats(ScreenInfo * pScreenInfo)
{
    CARD8 depthToBpp[33];       /* depth -> bpp map */
    KdCardInfo *card;
    KdScreenInfo *screen;
    int i;
    int bpp;
    PixmapFormatRec *format;

    for (i = 1; i <= 32; i++)
        depthToBpp[i] = 0;

    /*
     * Generate mappings between bitsPerPixel and depth,
     * also ensure that all screens comply with protocol
     * restrictions on equivalent formats for the same
     * depth on different screens
     */
    for (card = kdCardInfo; card; card = card->next) {
        for (screen = card->screenList; screen; screen = screen->next) {
            bpp = screen->fb.bitsPerPixel;
            if (bpp == 24)
                bpp = 32;
            if (!depthToBpp[screen->fb.depth])
                depthToBpp[screen->fb.depth] = bpp;
            else if (depthToBpp[screen->fb.depth] != bpp)
                return FALSE;
        }
    }

    /*
     * Fill in additional formats
     */
    for (i = 0; i < NUM_KD_DEPTHS; i++)
        if (!depthToBpp[kdDepths[i].depth])
            depthToBpp[kdDepths[i].depth] = kdDepths[i].bpp;

    pScreenInfo->imageByteOrder = IMAGE_BYTE_ORDER;
    pScreenInfo->bitmapScanlineUnit = BITMAP_SCANLINE_UNIT;
    pScreenInfo->bitmapScanlinePad = BITMAP_SCANLINE_PAD;
    pScreenInfo->bitmapBitOrder = BITMAP_BIT_ORDER;

    pScreenInfo->numPixmapFormats = 0;

    for (i = 1; i <= 32; i++) {
        if (depthToBpp[i]) {
            format = &pScreenInfo->formats[pScreenInfo->numPixmapFormats++];
            format->depth = i;
            format->bitsPerPixel = depthToBpp[i];
            format->scanlinePad = BITMAP_SCANLINE_PAD;
        }
    }

    return TRUE;
}

static void
KdAddScreen(ScreenInfo * pScreenInfo,
            KdScreenInfo * screen, int argc, char **argv)
{
    int i;

    /*
     * Fill in fb visual type masks for this screen
     */
    for (i = 0; i < pScreenInfo->numPixmapFormats; i++) {
        unsigned long visuals;
        Pixel rm, gm, bm;

        visuals = 0;
        rm = gm = bm = 0;
        if (pScreenInfo->formats[i].depth == screen->fb.depth) {
            visuals = screen->fb.visuals;
            rm = screen->fb.redMask;
            gm = screen->fb.greenMask;
            bm = screen->fb.blueMask;
        }
        fbSetVisualTypesAndMasks(pScreenInfo->formats[i].depth,
                                 visuals, 8, rm, gm, bm);
    }

    kdCurrentScreen = screen;

    AddScreen(KdScreenInit, argc, argv);
}

#if 0                           /* This function is not used currently */

int
KdDepthToFb(ScreenPtr pScreen, int depth)
{
    KdScreenPriv(pScreen);

    for (fb = 0; fb <= KD_MAX_FB && pScreenPriv->screen->fb.frameBuffer; fb++)
        if (pScreenPriv->screen->fb.depth == depth)
            return fb;
}

#endif

static int
KdSignalWrapper(int signum)
{
    kdCaughtSignal = TRUE;
    return 1;                   /* use generic OS layer cleanup & abort */
}

void
KdInitOutput(ScreenInfo * pScreenInfo, int argc, char **argv)
{
    KdCardInfo *card;
    KdScreenInfo *screen;

    if (!kdCardInfo) {
        InitCard(0);
        if (!(card = KdCardInfoLast()))
            FatalError("No matching cards found!\n");
        screen = KdScreenInfoAdd(card);
        KdParseScreen(screen, 0);
    }
    /*
     * Initialize all of the screens for all of the cards
     */
    for (card = kdCardInfo; card; card = card->next) {
        int ret = 1;

        if (card->cfuncs->cardinit)
            ret = (*card->cfuncs->cardinit) (card);
        if (ret) {
            for (screen = card->screenList; screen; screen = screen->next)
                KdInitScreen(pScreenInfo, screen, argc, argv);
        }
    }

    /*
     * Merge the various pixmap formats together, this can fail
     * when two screens share depth but not bitsPerPixel
     */
    if (!KdSetPixmapFormats(pScreenInfo))
        return;

    /*
     * Add all of the screens
     */
    for (card = kdCardInfo; card; card = card->next)
        for (screen = card->screenList; screen; screen = screen->next)
            KdAddScreen(pScreenInfo, screen, argc, argv);

    OsRegisterSigWrapper(KdSignalWrapper);
}

void
OsVendorFatalError(const char *f, va_list args)
{
}

int
DPMSSet(ClientPtr client, int level)
{
    return Success;
}

Bool
DPMSSupported(void)
{
    return FALSE;
}
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d102 1
a102 1
        SetRootClip(pScreen, FALSE);
d185 1
a185 1
    SetRootClip(pScreen, TRUE);
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d303 2
d318 1
a318 1
        arg = KdParseFindNext(arg, "x/@@XY", save, &delim);
d326 1
a326 1
            arg = KdParseFindNext(arg, "x@@XY", save, &delim);
d340 2
a341 1
        if (delim != 'x' && delim != '@@' && delim != 'X' && delim != 'Y' &&
d352 12
d443 1
a443 1
        ("-screen WIDTH[/WIDTHMM]xHEIGHT[/HEIGHTMM][@@ROTATION][X][Y][xDEPTH/BPP[xFREQ]]  Specify screen characteristics\n");
d639 3
d644 1
a910 4

#if 0
    fbInitValidateTree(pScreen);
#endif
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d121 1
d125 7
a131 1
        system(command);
d675 1
a675 1
    free((pointer) pScreenPriv);
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d249 2
a250 2
char *
KdParseFindNext(char *cur, const char *delim, char *save, char *last)
d285 1
a285 1
KdParseScreen(KdScreenInfo * screen, char *arg)
d331 2
a332 1
        if (delim != 'x' && delim != '@@' && delim != 'X' && delim != 'Y')
d947 2
a948 1
    (*card->cfuncs->scrinit) (screen);
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d609 1
a609 1
KdCloseScreen(int index, ScreenPtr pScreen)
d619 1
a619 1
        ret = (*pScreen->CloseScreen) (index, pScreen);
d733 5
a737 5
        {
        SubPixelHorizontalRGB, RR_Rotate_0}, {
        SubPixelHorizontalBGR, RR_Rotate_180}, {
        SubPixelVerticalRGB, RR_Rotate_270}, {
    SubPixelVerticalBGR, RR_Rotate_90},};
d744 5
a748 5
        {
        RR_Reflect_X, SubPixelHorizontalRGB, SubPixelHorizontalBGR}, {
        RR_Reflect_X, SubPixelHorizontalBGR, SubPixelHorizontalRGB}, {
        RR_Reflect_Y, SubPixelVerticalRGB, SubPixelVerticalBGR}, {
    RR_Reflect_Y, SubPixelVerticalRGB, SubPixelVerticalRGB},};
d779 1
a779 1
KdScreenInit(int index, ScreenPtr pScreen, int argc, char **argv)
d1107 1
a1107 1
OsVendorFatalError(void)
@


1.7
log
@Update to xserver 1.11.2
@
text
@d49 2
a50 2
    CARD8   depth;
    CARD8   bpp;
d53 8
a60 8
KdDepths    kdDepths[] = {
    { 1, 1 },
    { 4, 4 },
    { 8, 8 },
    { 15, 16 },
    { 16, 16 },
    { 24, 32 },
    { 32, 32 }
d67 2
a68 2
DevPrivateKeyRec    kdScreenPrivateKeyRec;
unsigned long	    kdGeneration;
d70 14
a83 14
Bool                kdVideoTest;
unsigned long       kdVideoTestTime;
Bool		    kdEmulateMiddleButton;
Bool		    kdRawPointerCoordinates;
Bool		    kdDisableZaphod;
Bool                kdAllowZap;
Bool		    kdEnabled;
int		    kdSubpixelOrder;
int		    kdVirtualTerminal = -1;
Bool		    kdSwitchPending;
char		    *kdSwitchCmd;
DDXPointRec	    kdOrigin;
Bool		    kdHasPointer = FALSE;
Bool		    kdHasKbd = FALSE;
d85 1
a85 1
static Bool         kdCaughtSignal = FALSE;
d92 1
a92 1
KdOsFuncs	*kdOsFuncs;
d95 1
a95 1
KdDisableScreen (ScreenPtr pScreen)
d100 1
a100 1
	return;
d102 2
a103 2
	SetRootClip (pScreen, FALSE);
    KdDisableColormap (pScreen);
d105 4
a108 3
	(*pScreenPriv->card->cfuncs->disableAccel) (pScreen);
    if (!pScreenPriv->screen->softCursor && pScreenPriv->card->cfuncs->disableCursor)
	(*pScreenPriv->card->cfuncs->disableCursor) (pScreen);
d110 1
a110 1
	(*pScreenPriv->card->cfuncs->dpms) (pScreen, KD_DPMS_NORMAL);
d112 1
a112 1
    if(pScreenPriv->card->cfuncs->disable)
d117 1
a117 1
KdDoSwitchCmd (char *reason)
d119 7
a125 13
    if (kdSwitchCmd)
    {
	char    *command = malloc(strlen (kdSwitchCmd) +
				   1 +
				   strlen (reason) +
				   1);
	if (!command)
	    return;
	strcpy (command, kdSwitchCmd);
	strcat (command, " ");
	strcat (command, reason);
	system (command);
	free(command);
d130 1
a130 1
KdSuspend (void)
d132 2
a133 2
    KdCardInfo	    *card;
    KdScreenInfo    *screen;
d135 10
a144 12
    if (kdEnabled)
    {
	for (card = kdCardInfo; card; card = card->next)
	{
	    for (screen = card->screenList; screen; screen = screen->next)
		if (screen->mynum == card->selected && screen->pScreen)
		    KdDisableScreen (screen->pScreen);
	    if (card->driver && card->cfuncs->restore)
		(*card->cfuncs->restore) (card);
	}
	KdDisableInput ();
	KdDoSwitchCmd ("suspend");
d149 1
a149 1
KdDisableScreens (void)
d151 2
a152 3
    KdSuspend ();
    if (kdEnabled)
    {
d155 1
a155 1
	kdEnabled = FALSE;
d160 1
a160 1
KdEnableScreen (ScreenPtr pScreen)
d162 1
a162 1
    KdScreenPriv (pScreen);
d165 4
a168 4
	return TRUE;
    if(pScreenPriv->card->cfuncs->enable)
	if (!(*pScreenPriv->card->cfuncs->enable) (pScreen))
	    return FALSE;
d172 3
a174 2
    if (!pScreenPriv->screen->softCursor && pScreenPriv->card->cfuncs->enableCursor)
	(*pScreenPriv->card->cfuncs->enableCursor) (pScreen);
d176 3
a178 3
	(*pScreenPriv->card->cfuncs->enableAccel) (pScreen);
    KdEnableColormap (pScreen);
    SetRootClip (pScreen, TRUE);
d180 1
a180 1
	(*pScreenPriv->card->cfuncs->dpms) (pScreen, pScreenPriv->dpmsState);
d185 1
a185 1
KdResume (void)
d187 2
a188 2
    KdCardInfo	    *card;
    KdScreenInfo    *screen;
d190 11
a200 13
    if (kdEnabled)
    {
	KdDoSwitchCmd ("resume");
	for (card = kdCardInfo; card; card = card->next)
	{
	    if(card->cfuncs->preserve)
		(*card->cfuncs->preserve) (card);
	    for (screen = card->screenList; screen; screen = screen->next)
		if (screen->mynum == card->selected && screen->pScreen)
		    KdEnableScreen (screen->pScreen);
	}
	KdEnableInput ();
	KdReleaseAllKeys ();
d205 1
a205 1
KdEnableScreens (void)
d207 2
a208 3
    if (!kdEnabled)
    {
	kdEnabled = TRUE;
d212 1
a212 1
    KdResume ();
d216 1
a216 1
KdProcessSwitch (void)
d219 1
a219 1
	KdDisableScreens ();
d221 1
a221 1
	KdEnableScreens ();
d227 4
a230 5
    KdDisableScreens ();
    if (kdOsFuncs)
    {
	if (kdEnabled && kdOsFuncs->Disable)
	    (*kdOsFuncs->Disable) ();
d233 1
a233 1
	KdDoSwitchCmd ("stop");
d241 1
a241 1
ddxGiveUp (enum ExitCode error)
d243 1
a243 1
    AbortDDX (error);
d246 2
a247 2
Bool	kdDumbDriver;
Bool	kdSoftCursor;
d250 1
a250 1
KdParseFindNext (char *cur, char *delim, char *save, char *last)
d252 2
a253 3
    while (*cur && !strchr (delim, *cur))
    {
	*save++ = *cur++;
d258 1
a258 1
	cur++;
d263 1
a263 1
KdAddRotation (Rotation a, Rotation b)
d265 2
a266 2
    Rotation	rotate = (a & RR_Rotate_All) * (b & RR_Rotate_All);
    Rotation	reflect = (a & RR_Reflect_All) ^ (b & RR_Reflect_All);
d269 1
a269 1
	rotate /= (RR_Rotate_270 * RR_Rotate_90);
d274 1
a274 1
KdSubRotation (Rotation a, Rotation b)
d276 2
a277 2
    Rotation	rotate = (a & RR_Rotate_All) * 16 / (b & RR_Rotate_All);
    Rotation	reflect = (a & RR_Reflect_All) ^ (b & RR_Reflect_All);
d280 1
a280 1
	rotate /= (RR_Rotate_270 * RR_Rotate_90);
d285 1
a285 2
KdParseScreen (KdScreenInfo *screen,
	       char	    *arg)
d287 4
a290 4
    char    delim;
    char    save[1024];
    int	    i;
    int	    pixels, mm;
d304 29
a332 33
	return;
    if (strlen (arg) >= sizeof (save))
	return;

    for (i = 0; i < 2; i++)
    {
	arg = KdParseFindNext (arg, "x/@@XY", save, &delim);
	if (!save[0])
	    return;

	pixels = atoi(save);
	mm = 0;

	if (delim == '/')
	{
	    arg = KdParseFindNext (arg, "x@@XY", save, &delim);
	    if (!save[0])
		return;
	    mm = atoi(save);
	}

	if (i == 0)
	{
	    screen->width = pixels;
	    screen->width_mm = mm;
	}
	else
	{
	    screen->height = pixels;
	    screen->height_mm = mm;
	}
	if (delim != 'x' && delim != '@@' && delim != 'X' && delim != 'Y')
	    return;
d341 43
a383 49
    if (delim == '@@')
    {
	arg = KdParseFindNext (arg, "xXY", save, &delim);
	if (save[0])
	{
	    int	    rotate = atoi (save);
	    if (rotate < 45)
		screen->randr = RR_Rotate_0;
	    else if (rotate < 135)
		screen->randr = RR_Rotate_90;
	    else if (rotate < 225)
		screen->randr = RR_Rotate_180;
	    else if (rotate < 315)
		screen->randr = RR_Rotate_270;
	    else
		screen->randr = RR_Rotate_0;
	}
    }
    if (delim == 'X')
    {
	arg = KdParseFindNext (arg, "xY", save, &delim);
	screen->randr |= RR_Reflect_X;
    }

    if (delim == 'Y')
    {
	arg = KdParseFindNext (arg, "xY", save, &delim);
	screen->randr |= RR_Reflect_Y;
    }

    arg = KdParseFindNext (arg, "x/,", save, &delim);
    if (save[0])
    {
	screen->fb.depth = atoi(save);
	if (delim == '/')
	{
	    arg = KdParseFindNext (arg, "x,", save, &delim);
	    if (save[0])
		screen->fb.bitsPerPixel = atoi (save);
	}
	else
	    screen->fb.bitsPerPixel = 0;
    }

    if (delim == 'x')
    {
	arg = KdParseFindNext (arg, "x", save, &delim);
	if (save[0])
	    screen->rate = atoi(save);
d399 1
a399 1
KdParseRgba (char *rgba)
d401 10
a410 10
    if (!strcmp (rgba, "rgb"))
	kdSubpixelOrder = SubPixelHorizontalRGB;
    else if (!strcmp (rgba, "bgr"))
	kdSubpixelOrder = SubPixelHorizontalBGR;
    else if (!strcmp (rgba, "vrgb"))
	kdSubpixelOrder = SubPixelVerticalRGB;
    else if (!strcmp (rgba, "vbgr"))
	kdSubpixelOrder = SubPixelVerticalBGR;
    else if (!strcmp (rgba, "none"))
	kdSubpixelOrder = SubPixelNone;
d412 1
a412 1
	kdSubpixelOrder = SubPixelUnknown;
d416 1
a416 1
KdUseMsg (void)
d419 8
a426 4
    ErrorF("-screen WIDTH[/WIDTHMM]xHEIGHT[/HEIGHTMM][@@ROTATION][X][Y][xDEPTH/BPP[xFREQ]]  Specify screen characteristics\n");
    ErrorF("-rgba rgb/bgr/vrgb/vbgr/none   Specify subpixel ordering for LCD panels\n");
    ErrorF("-mouse driver [,n,,options]    Specify the pointer driver and its options (n is the number of buttons)\n");
    ErrorF("-keybd driver [,,options]      Specify the keyboard driver and its options\n");
d430 2
a431 1
    ErrorF("-rawcoord        Don't transform pointer coordinates on rotation\n");
d435 2
a436 1
    ErrorF("-origin X,Y      Locates the next screen in the the virtual screen (Xinerama)\n");
d439 2
a440 1
    ErrorF("vtxx             Use virtual terminal xx instead of the next available\n");
d444 1
a444 1
KdProcessArgument (int argc, char **argv, int i)
d446 2
a447 2
    KdCardInfo	    *card;
    KdScreenInfo    *screen;
d449 81
a529 99
    if (!strcmp (argv[i], "-screen"))
    {
	if ((i+1) < argc)
	{
	    card = KdCardInfoLast ();
	    if (!card)
	    {
		InitCard (0);
		card = KdCardInfoLast ();
	    }
	    if (card) {
		screen = KdScreenInfoAdd (card);
		KdParseScreen (screen, argv[i+1]);
	    } else
		ErrorF("No matching card found!\n");
	}
	else
	    UseMsg ();
	return 2;
    }
    if (!strcmp (argv[i], "-zaphod"))
    {
	kdDisableZaphod = TRUE;
	return 1;
    }
    if (!strcmp (argv[i], "-zap"))
    {
	kdAllowZap = TRUE;
	return 1;
    }
    if (!strcmp (argv[i], "-3button"))
    {
	kdEmulateMiddleButton = FALSE;
	return 1;
    }
    if (!strcmp (argv[i], "-2button"))
    {
	kdEmulateMiddleButton = TRUE;
	return 1;
    }
    if (!strcmp (argv[i], "-rawcoord"))
    {
	kdRawPointerCoordinates = 1;
	return 1;
    }
    if (!strcmp (argv[i], "-dumb"))
    {
	kdDumbDriver = TRUE;
	return 1;
    }
    if (!strcmp (argv[i], "-softCursor"))
    {
	kdSoftCursor = TRUE;
	return 1;
    }
    if (!strcmp (argv[i], "-videoTest"))
    {
	kdVideoTest = TRUE;
	return 1;
    }
    if (!strcmp (argv[i], "-origin"))
    {
	if ((i+1) < argc)
	{
	    char    *x = argv[i+1];
	    char    *y = strchr (x, ',');
	    if (x)
		kdOrigin.x = atoi (x);
	    else
		kdOrigin.x = 0;
	    if (y)
		kdOrigin.y = atoi(y+1);
	    else
		kdOrigin.y = 0;
	}
	else
	    UseMsg ();
	return 2;
    }
    if (!strcmp (argv[i], "-rgba"))
    {
	if ((i+1) < argc)
	    KdParseRgba (argv[i+1]);
	else
	    UseMsg ();
	return 2;
    }
    if (!strcmp (argv[i], "-switchCmd"))
    {
	if ((i+1) < argc)
	    kdSwitchCmd = argv[i+1];
	else
	    UseMsg ();
	return 2;
    }
    if (!strncmp (argv[i], "vt", 2) &&
	sscanf (argv[i], "vt%2d", &kdVirtualTerminal) == 1)
    {
	return 1;
d531 5
a535 2
    if (!strcmp (argv[i], "-mouse") ||
        !strcmp (argv[i], "-pointer")) {
d539 1
a539 1
	kdHasPointer = TRUE;
d542 1
a542 1
    if (!strcmp (argv[i], "-keybd")) {
d546 1
a546 1
	kdHasKbd = TRUE;
d559 1
a559 1
KdOsInit (KdOsFuncs *pOsFuncs)
d562 3
a564 5
    if (pOsFuncs)
    {
	if (serverGeneration == 1)
	{
	    KdDoSwitchCmd ("start");
d567 1
a567 1
	}
d572 1
a572 1
KdAllocatePrivates (ScreenPtr pScreen)
d574 1
a574 1
    KdPrivScreenPtr	pScreenPriv;
d577 1
a577 1
	kdGeneration = serverGeneration;
d580 1
a580 1
	return FALSE;
d582 1
a582 1
    pScreenPriv = calloc(1, sizeof (*pScreenPriv));
d584 2
a585 2
	return FALSE;
    KdSetScreenPriv (pScreen, pScreenPriv);
d590 1
a590 1
KdCreateScreenResources (ScreenPtr pScreen)
d593 1
a593 1
    KdCardInfo	    *card = pScreenPriv->card;
d597 2
a598 2
    if(pScreen->CreateScreenResources)
	ret = (*pScreen->CreateScreenResources) (pScreen);
d600 1
a600 1
	ret= -1;
d604 1
a604 1
	ret = (*card->cfuncs->createRes) (pScreen);
d609 1
a609 1
KdCloseScreen (int index, ScreenPtr pScreen)
d612 3
a614 3
    KdScreenInfo    *screen = pScreenPriv->screen;
    KdCardInfo	    *card = pScreenPriv->card;
    Bool	    ret;
d618 1
a618 1
    if(pScreen->CloseScreen)
d621 1
a621 1
	ret = TRUE;
d624 1
a624 1
	(*card->cfuncs->dpms) (pScreen, KD_DPMS_NORMAL);
d627 1
a627 1
	KdDisableScreen (pScreen);
d632 3
a634 4
    if (screen == card->screenList)
    {
	if (kdEnabled && card->cfuncs->restore)
	    (*card->cfuncs->restore) (card);
d638 1
a638 1
	(*card->cfuncs->finiAccel) (pScreen);
d641 1
a641 1
	(*card->cfuncs->finiCursor) (pScreen);
d643 1
a643 1
    if(card->cfuncs->scrfini)
d650 13
a662 16
    if (screen == card->screenList)
    {
	if(card->cfuncs->cardfini)
	    (*card->cfuncs->cardfini) (card);
	/*
	 * Clean up OS when last card is closed
	 */
	if (card == kdCardInfo)
	{
	    if (kdEnabled)
	    {
		kdEnabled = FALSE;
		if(kdOsFuncs->Disable)
		    (*kdOsFuncs->Disable) ();
	    }
	}
d672 1
a672 1
KdSaveScreen (ScreenPtr pScreen, int on)
d675 1
a675 1
    int	    dpmsState;
d678 1
a678 1
	return FALSE;
d683 2
a684 2
	dpmsState = KD_DPMS_NORMAL;
	break;
d686 3
a688 3
	if (dpmsState == KD_DPMS_NORMAL)
	    dpmsState = KD_DPMS_NORMAL+1;
	break;
d690 3
a692 3
	if (dpmsState < KD_DPMS_MAX)
	    dpmsState++;
	break;
d694 1
a694 1
	break;
d696 4
a699 5
    if (dpmsState != pScreenPriv->dpmsState)
    {
	if (pScreenPriv->enabled)
	    (*pScreenPriv->card->cfuncs->dpms) (pScreen, dpmsState);
	pScreenPriv->dpmsState = dpmsState;
d705 1
a705 1
KdCreateWindow (WindowPtr pWin)
d708 7
a714 9
    if (!pWin->parent)
    {
	KdScreenPriv(pWin->drawable.pScreen);

	if (!pScreenPriv->enabled)
	{
	    RegionEmpty(&pWin->borderClip);
	    RegionBreak(&pWin->clipList);
	}
d717 1
a717 1
    return fbCreateWindow (pWin);
d721 1
a721 1
KdSetSubpixelOrder (ScreenPtr pScreen, Rotation randr)
d724 4
a727 4
    KdScreenInfo	*screen = pScreenPriv->screen;
    int			subpixel_order = screen->subpixel_order;
    Rotation		subpixel_dir;
    int			i;
d730 2
a731 2
	int	    subpixel_order;
	Rotation    direction;
d733 5
a737 5
	{ SubPixelHorizontalRGB, 	RR_Rotate_0 },
	{ SubPixelHorizontalBGR,	RR_Rotate_180 },
	{ SubPixelVerticalRGB,		RR_Rotate_270 },
	{ SubPixelVerticalBGR,		RR_Rotate_90 },
    };
d740 3
a742 3
	int	bit;
	int	normal;
	int	reflect;
d744 5
a748 5
	{ RR_Reflect_X, SubPixelHorizontalRGB,	SubPixelHorizontalBGR },
	{ RR_Reflect_X, SubPixelHorizontalBGR,	SubPixelHorizontalRGB },
	{ RR_Reflect_Y, SubPixelVerticalRGB,	SubPixelVerticalBGR },
	{ RR_Reflect_Y, SubPixelVerticalRGB,	SubPixelVerticalRGB },
    };
d752 19
a770 21
	if (orders[i].subpixel_order == subpixel_order)
	    break;
    if (i < 4)
    {
	subpixel_dir = KdAddRotation (randr & RR_Rotate_All, orders[i].direction);

	/* map back to subpixel order */
	for (i = 0; i < 4; i++)
	    if (orders[i].direction & subpixel_dir)
	    {
		subpixel_order = orders[i].subpixel_order;
		break;
	    }
	/* reflect */
	for (i = 0; i < 4; i++)
	    if ((randr & reflects[i].bit) &&
		reflects[i].normal == subpixel_order)
	    {
		subpixel_order = reflects[i].reflect;
		break;
	    }
d772 1
a772 1
    PictureSetSubpixelOrder (pScreen, subpixel_order);
d781 4
a784 3
    KdScreenInfo	*screen = kdCurrentScreen;
    KdCardInfo		*card = screen->card;
    KdPrivScreenPtr	pScreenPriv;
d790 2
a791 2
    Bool		rotated = (screen->randr & (RR_Rotate_90|RR_Rotate_270)) != 0;
    int			width, height, *width_mmp, *height_mmp;
d793 1
a793 1
    KdAllocatePrivates (pScreen);
d797 11
a807 13
    if (!rotated)
    {
	width = screen->width;
	height = screen->height;
	width_mmp = &screen->width_mm;
	height_mmp = &screen->height_mm;
    }
    else
    {
	width = screen->height;
	height = screen->width;
	width_mmp = &screen->height_mm;
	height_mmp = &screen->width_mm;
d818 1
a818 1
	monitorResolution = 75;
d824 6
a829 8
    if (!fbSetupScreen (pScreen,
			screen->fb.frameBuffer,
			width, height,
			monitorResolution, monitorResolution,
			screen->fb.pixelStride,
			screen->fb.bitsPerPixel))
    {
	return FALSE;
d835 2
a836 2
    pScreen->InstallColormap	= KdInstallColormap;
    pScreen->UninstallColormap	= KdUninstallColormap;
d838 1
a838 1
    pScreen->StoreColors	= KdStoreColors;
d840 2
a841 2
    pScreen->SaveScreen		= KdSaveScreen;
    pScreen->CreateWindow	= KdCreateWindow;
d843 6
a848 8
    if (!fbFinishScreenInit (pScreen,
			     screen->fb.frameBuffer,
			     width, height,
			     monitorResolution, monitorResolution,
			     screen->fb.pixelStride,
			     screen->fb.bitsPerPixel))
    {
	return FALSE;
d856 1
a856 1
	pScreen->mmWidth = *width_mmp;
d858 1
a858 1
	*width_mmp = pScreen->mmWidth;
d860 1
a860 1
	pScreen->mmHeight = *height_mmp;
d862 1
a862 1
	*height_mmp = pScreen->mmHeight;
d868 2
a869 2
    pScreen->BlockHandler	= KdBlockHandler;
    pScreen->WakeupHandler	= KdWakeupHandler;
d871 2
a872 2
    if (!fbPictureInit (pScreen, 0, 0))
	return FALSE;
d874 2
a875 2
	if (!(*card->cfuncs->initScreen) (pScreen))
	    return FALSE;
d878 2
a879 2
	if (!(*card->cfuncs->initAccel) (pScreen))
	    screen->dumb = TRUE;
d882 2
a883 2
	if (!(*card->cfuncs->finishInitScreen) (pScreen))
	    return FALSE;
d886 1
a886 1
    fbInitValidateTree (pScreen);
d891 3
a893 3
     *	KdCloseScreen
     *	miBSCloseScreen
     *	fbCloseScreen
d902 4
a905 6
	!card->cfuncs->initCursor ||
	!(*card->cfuncs->initCursor) (pScreen))
    {
	/* Use MI for cursor display and event queueing. */
	screen->softCursor = TRUE;
	miDCInitialize(pScreen, &kdPointerScreenFuncs);
d908 2
a909 4

    if (!fbCreateDefColormap (pScreen))
    {
	return FALSE;
d912 1
a912 1
    KdSetSubpixelOrder (pScreen, screen->randr);
d917 4
a920 5
    if (!kdEnabled)
    {
	kdEnabled = TRUE;
	if(kdOsFuncs->Enable)
	    (*kdOsFuncs->Enable) ();
d923 12
a934 13
    if (screen->mynum == card->selected)
    {
	if(card->cfuncs->preserve)
	    (*card->cfuncs->preserve) (card);
	if(card->cfuncs->enable)
	    if (!(*card->cfuncs->enable) (pScreen))
		return FALSE;
	pScreenPriv->enabled = TRUE;
	if (!screen->softCursor && card->cfuncs->enableCursor)
	    (*card->cfuncs->enableCursor) (pScreen);
	KdEnableColormap (pScreen);
	if (!screen->dumb && card->cfuncs->enableAccel)
	    (*card->cfuncs->enableAccel) (pScreen);
d941 2
a942 4
KdInitScreen (ScreenInfo    *pScreenInfo,
	      KdScreenInfo  *screen,
	      int	    argc,
	      char	    **argv)
d944 1
a944 1
    KdCardInfo	*card = screen->card;
d949 1
a949 1
	screen->dumb = TRUE;
d951 1
a951 1
	screen->softCursor = TRUE;
d955 1
a955 1
KdSetPixmapFormats (ScreenInfo	*pScreenInfo)
d957 5
a961 5
    CARD8	    depthToBpp[33];	/* depth -> bpp map */
    KdCardInfo	    *card;
    KdScreenInfo    *screen;
    int		    i;
    int		    bpp;
d965 1
a965 1
	depthToBpp[i] = 0;
d973 10
a982 12
    for (card = kdCardInfo; card; card = card->next)
    {
	for (screen = card->screenList; screen; screen = screen->next)
	{
	    bpp = screen->fb.bitsPerPixel;
	    if (bpp == 24)
		bpp = 32;
	    if (!depthToBpp[screen->fb.depth])
		depthToBpp[screen->fb.depth] = bpp;
	    else if (depthToBpp[screen->fb.depth] != bpp)
		return FALSE;
	}
d989 2
a990 2
	if (!depthToBpp[kdDepths[i].depth])
	    depthToBpp[kdDepths[i].depth] = kdDepths[i].bpp;
d992 1
a992 1
    pScreenInfo->imageByteOrder     = IMAGE_BYTE_ORDER;
d994 2
a995 2
    pScreenInfo->bitmapScanlinePad  = BITMAP_SCANLINE_PAD;
    pScreenInfo->bitmapBitOrder     = BITMAP_BIT_ORDER;
d999 7
a1005 9
    for (i = 1; i <= 32; i++)
    {
	if (depthToBpp[i])
	{
	    format = &pScreenInfo->formats[pScreenInfo->numPixmapFormats++];
	    format->depth = i;
	    format->bitsPerPixel = depthToBpp[i];
	    format->scanlinePad = BITMAP_SCANLINE_PAD;
	}
d1012 2
a1013 4
KdAddScreen (ScreenInfo	    *pScreenInfo,
	     KdScreenInfo   *screen,
	     int	    argc,
	     char	    **argv)
d1015 2
a1016 1
    int	    i;
d1020 14
a1033 18
    for (i = 0; i < pScreenInfo->numPixmapFormats; i++)
    {
	unsigned long	visuals;
	Pixel		rm, gm, bm;

	visuals = 0;
	rm = gm = bm = 0;
	if (pScreenInfo->formats[i].depth == screen->fb.depth)
	{
	    visuals = screen->fb.visuals;
	    rm = screen->fb.redMask;
	    gm = screen->fb.greenMask;
	    bm = screen->fb.blueMask;
	}
	fbSetVisualTypesAndMasks (pScreenInfo->formats[i].depth,
				  visuals,
				  8,
				  rm, gm, bm);
d1038 1
a1038 1
    AddScreen (KdScreenInit, argc, argv);
d1041 1
a1041 1
#if 0 /* This function is not used currently */
d1044 1
a1044 1
KdDepthToFb (ScreenPtr	pScreen, int depth)
d1049 2
a1050 2
	if (pScreenPriv->screen->fb.depth == depth)
	    return fb;
d1056 1
a1056 1
KdSignalWrapper (int signum)
d1059 1
a1059 1
    return 1; /* use generic OS layer cleanup & abort */
d1063 11
a1073 14
KdInitOutput (ScreenInfo    *pScreenInfo,
	      int	    argc,
	      char	    **argv)
{
    KdCardInfo	    *card;
    KdScreenInfo    *screen;

    if (!kdCardInfo)
    {
	InitCard (0);
	if (!(card = KdCardInfoLast ()))
	    FatalError("No matching cards found!\n");
	screen = KdScreenInfoAdd (card);
	KdParseScreen (screen, 0);
d1078 9
a1086 10
    for (card = kdCardInfo; card; card = card->next)
    {
	int ret=1;
	if(card->cfuncs->cardinit)
		ret=(*card->cfuncs->cardinit) (card);
	if (ret)
	{
	    for (screen = card->screenList; screen; screen = screen->next)
		KdInitScreen (pScreenInfo, screen, argc, argv);
	}
d1093 2
a1094 2
    if (!KdSetPixmapFormats (pScreenInfo))
	return;
d1100 2
a1101 2
	for (screen = card->screenList; screen; screen = screen->next)
	    KdAddScreen (pScreenInfo, screen, argc, argv);
d1118 1
a1118 1
DPMSSupported (void)
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a94 89
KdSetRootClip (ScreenPtr pScreen, BOOL enable)
{
    WindowPtr	pWin = pScreen->root;
    WindowPtr	pChild;
    Bool	WasViewable;
    Bool	anyMarked = FALSE;
    WindowPtr   pLayerWin;
    BoxRec	box;

    if (!pWin)
	return;
    WasViewable = (Bool)(pWin->viewable);
    if (WasViewable)
    {
	for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib)
	{
	    (void) (*pScreen->MarkOverlappedWindows)(pChild,
						     pChild,
						     &pLayerWin);
	}
	(*pScreen->MarkWindow) (pWin);
	anyMarked = TRUE;
	if (pWin->valdata)
	{
	    if (HasBorder (pWin))
	    {
		RegionPtr	borderVisible;

		borderVisible = RegionCreate(NullBox, 1);
		RegionSubtract(borderVisible,
				&pWin->borderClip, &pWin->winSize);
		pWin->valdata->before.borderVisible = borderVisible;
	    }
	    pWin->valdata->before.resized = TRUE;
	}
    }

    if (enable)
    {
	box.x1 = 0;
	box.y1 = 0;
	box.x2 = pScreen->width;
	box.y2 = pScreen->height;
	pWin->drawable.width = pScreen->width;
	pWin->drawable.height = pScreen->height;
	RegionInit(&pWin->winSize, &box, 1);
	RegionInit(&pWin->borderSize, &box, 1);
	RegionReset(&pWin->borderClip, &box);
	RegionBreak(&pWin->clipList);
    }
    else
    {
	RegionEmpty(&pWin->borderClip);
	RegionBreak(&pWin->clipList);
    }

    ResizeChildrenWinSize (pWin, 0, 0, 0, 0);

    if (WasViewable)
    {
	if (pWin->firstChild)
	{
	    anyMarked |= (*pScreen->MarkOverlappedWindows)(pWin->firstChild,
							   pWin->firstChild,
							   (WindowPtr *)NULL);
	}
	else
	{
	    (*pScreen->MarkWindow) (pWin);
	    anyMarked = TRUE;
	}


	if (anyMarked)
	    (*pScreen->ValidateTree)(pWin, NullWindow, VTOther);
    }

    if (WasViewable)
    {
	if (anyMarked)
	    (*pScreen->HandleExposures)(pWin);
	if (anyMarked && pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pWin, NullWindow, VTOther);
    }
    if (pWin->realized)
	WindowsRestructured ();
}

void
d102 1
a102 1
	KdSetRootClip (pScreen, FALSE);
d185 1
a185 1
    KdSetRootClip (pScreen, TRUE);
d235 1
a235 1
AbortDDX(void)
d252 1
a252 1
ddxGiveUp (void)
d254 1
a254 1
    AbortDDX ();
a934 6

#if 0
    pScreen->backingStoreSupport = Always;
    miInitializeBackingStore (pScreen);
#endif

@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d67 1
a67 2
static int          kdScreenPrivateKeyIndex;
DevPrivateKey       kdScreenPrivateKey = &kdScreenPrivateKeyIndex;
d97 1
a97 1
    WindowPtr	pWin = WindowTable[pScreen->myNum];
d123 2
a124 2
		borderVisible = REGION_CREATE(pScreen, NullBox, 1);
		REGION_SUBTRACT(pScreen, borderVisible,
d140 4
a143 4
	REGION_INIT (pScreen, &pWin->winSize, &box, 1);
	REGION_INIT (pScreen, &pWin->borderSize, &box, 1);
	REGION_RESET(pScreen, &pWin->borderClip, &box);
	REGION_BREAK (pWin->drawable.pScreen, &pWin->clipList);
d147 2
a148 2
	REGION_EMPTY(pScreen, &pWin->borderClip);
	REGION_BREAK (pWin->drawable.pScreen, &pWin->clipList);
d209 1
a209 1
	char    *command = xalloc (strlen (kdSwitchCmd) +
d219 1
a219 1
	xfree (command);
d701 4
a704 1
    pScreenPriv = xcalloc(1, sizeof (*pScreenPriv));
d793 1
a793 1
    xfree ((pointer) pScreenPriv);
d841 2
a842 2
	    REGION_EMPTY (pWin->drawable.pScreen, &pWin->borderClip);
	    REGION_BREAK (pWin->drawable.pScreen, &pWin->clipList);
d946 2
a947 3
#ifdef PANORAMIX
    dixScreenOrigins[pScreen->myNum] = screen->origin;
#endif
a1006 1
#ifdef RENDER
a1008 1
#endif
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a26 3
#ifdef PSEUDO8
#include "pseudo8/pseudo8.h"
#endif
a101 1
    RegionPtr	pOldClip = 0;
d151 1
a151 1
    
d153 1
a153 1
    
d188 1
a188 1
    
d212 1
a212 1
				   strlen (reason) + 
d338 1
a338 1
        abort();
d342 1
a342 1
ddxGiveUp ()
a391 1
    int	    fb;
d394 1
a394 1
    
d405 1
a405 2
    for (fb = 0; fb < KD_MAX_FB; fb++)
	screen->fb[fb].depth = 0;
d410 1
a410 1
    
d416 1
a416 1
	
d419 1
a419 1
	
d427 1
a427 1
	
d477 3
a479 3
    
    fb = 0;
    while (fb < KD_MAX_FB)
d481 1
a481 4
	arg = KdParseFindNext (arg, "x/,", save, &delim);
	if (!save[0])
	    break;
	screen->fb[fb].depth = atoi(save);
d485 2
a486 3
	    if (!save[0])
		break;
	    screen->fb[fb].bitsPerPixel = atoi (save);
d489 1
a489 4
	    screen->fb[fb].bitsPerPixel = 0;
	if (delim != ',')
	    break;
	fb++;
a510 11
char *
KdSaveString (char *str)
{
    char    *n = (char *) xalloc (strlen (str) + 1);

    if (!n)
	return 0;
    strcpy (n, str);
    return n;
}

d532 1
a532 2
    ErrorF("-card pcmcia     Use PCMCIA card as additional screen\n");
    ErrorF("-screen WIDTH[/WIDTHMM]xHEIGHT[/HEIGHTMM][@@ROTATION][X][Y][xDEPTH/BPP{,DEPTH/BPP}[xFREQ]]  Specify screen characteristics\n");
a546 3
#ifdef PSEUDO8
    p8UseMsg ();
#endif
a554 8
    if (!strcmp (argv[i], "-card"))
    {
	if ((i+1) < argc)
	    InitCard (argv[i+1]);
	else
	    UseMsg ();
	return 2;
    }
a670 3
#ifdef PSEUDO8
    return p8ProcessArgument (argc, argv, i);
#else
a671 1
#endif
d685 1
a685 1
	if (serverGeneration == 1) 
d698 1
a698 1
    
d735 1
a735 1
    
d742 1
a742 1
    
d745 1
a745 1
    
d748 1
a748 1
    
d757 1
a757 1
	
d788 1
a788 1
    
d790 1
a790 1
    
d800 1
a800 1
    
d803 1
a803 1
    
d855 1
a855 1
    
d868 1
a868 1
	int	normal; 
d876 1
a876 1
    
d884 1
a884 1
	
a912 1
    int			fb;
d924 1
a924 1
    
d942 1
a942 2
    for (fb = 0; fb < KD_MAX_FB && screen->fb[fb].depth; fb++)
	pScreenPriv->bytesPerPixel[fb] = screen->fb[fb].bitsPerPixel >> 3;
d955 6
a960 6
    if (!fbSetupScreen (pScreen, 
			screen->fb[0].frameBuffer, 
			width, height, 
			monitorResolution, monitorResolution, 
			screen->fb[0].pixelStride,
			screen->fb[0].bitsPerPixel))
d972 1
a972 1
     
d976 6
a981 2
#if KD_MAX_FB > 1
    if (screen->fb[1].depth)
d983 1
a983 14
	if (!fbOverlayFinishScreenInit (pScreen, 
					screen->fb[0].frameBuffer, 
					screen->fb[1].frameBuffer, 
					width, height, 
					monitorResolution, monitorResolution,
					screen->fb[0].pixelStride,
					screen->fb[1].pixelStride,
					screen->fb[0].bitsPerPixel,
					screen->fb[1].bitsPerPixel,
					screen->fb[0].depth,
					screen->fb[1].depth))
	{
	    return FALSE;
	}
d985 1
a985 14
    else
#endif
    {
	if (!fbFinishScreenInit (pScreen, 
				 screen->fb[0].frameBuffer, 
				 width, height,
				 monitorResolution, monitorResolution,
				 screen->fb[0].pixelStride,
				 screen->fb[0].bitsPerPixel))
	{
	    return FALSE;
	}
    }
    
d998 1
a998 1
    
d1005 1
a1005 1
    
d1013 1
a1013 1
	    
d1017 1
a1017 5
    
#ifdef PSEUDO8
    (void) p8Init (pScreen, PSEUDO8_USE_DEFAULT);
#endif
    
d1021 1
a1021 1
	    
d1025 1
a1025 1
    
d1032 1
a1032 1
    /* 
d1043 1
a1043 1
    
d1045 1
a1045 1
	!card->cfuncs->initCursor || 
d1053 1
a1053 1
    
d1070 1
a1070 1
    
d1085 1
a1085 1
    
d1096 1
a1096 1
    
d1098 1
a1098 1
    
a1112 1
    int		    fb;
d1128 7
a1134 10
	    for (fb = 0; fb < KD_MAX_FB && screen->fb[fb].depth; fb++)
	    {
		bpp = screen->fb[fb].bitsPerPixel;
		if (bpp == 24)
		    bpp = 32;
		if (!depthToBpp[screen->fb[fb].depth])
		    depthToBpp[screen->fb[fb].depth] = bpp;
		else if (depthToBpp[screen->fb[fb].depth] != bpp) 
		    return FALSE;
	    }
d1137 1
a1137 1
    
d1144 1
a1144 1
	
d1149 1
a1149 1
    
d1151 1
a1151 1
    
d1162 1
a1162 1
    
d1180 1
a1180 2
	int		fb;
	
d1183 1
a1183 1
	for (fb = 0; fb < KD_MAX_FB && screen->fb[fb].depth; fb++)
d1185 4
a1188 8
	    if (pScreenInfo->formats[i].depth == screen->fb[fb].depth)
	    {
		visuals = screen->fb[fb].visuals;
		rm = screen->fb[fb].redMask;
		gm = screen->fb[fb].greenMask;
		bm = screen->fb[fb].blueMask;
		break;
	    }
d1197 1
a1197 1
    
a1206 1
    int	    fb;
d1208 2
a1209 2
    for (fb = 0; fb <= KD_MAX_FB && pScreenPriv->screen->fb[fb].frameBuffer; fb++)
	if (pScreenPriv->screen->fb[fb].depth == depth)
d1215 2
a1216 27
#ifdef HAVE_BACKTRACE
/* shamelessly ripped from xf86Events.c */
void
KdBacktrace (int signum)
{
    void *array[32]; /* more than 32 and you have bigger problems */
    size_t size, i;
    char **strings;

    signal(signum, SIG_IGN);

    size = backtrace (array, 32);
    fprintf (stderr, "\nBacktrace (%d deep):\n", size);
    strings = backtrace_symbols (array, size);
    for (i = 0; i < size; i++)
        fprintf (stderr, "%d: %s\n", i, strings[i]);
    free (strings);
    
    kdCaughtSignal = TRUE;    
    if (signum == SIGSEGV)
        FatalError("Segmentation fault caught\n");
    else if (signum > 0)
        FatalError("Signal %d caught\n", signum);
}
#else
void
KdBacktrace (int signum)
d1219 1
a1219 1
    FatalError("Segmentation fault caught\n");
a1220 1
#endif
d1252 1
a1252 1
    
d1259 1
a1259 1
    
d1267 1
a1267 1
    signal(SIGSEGV, KdBacktrace);
a1274 1
#ifdef DPMSExtension
d1278 1
a1278 6
}

int
DPMSGet (int *level)
{
    return -1;
a1285 2
#endif

@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d70 2
a71 1
DevPrivateKey       kdScreenPrivateKey = &kdScreenPrivateKey;
d79 1
a79 1
Bool                kdDontZap;
a96 1
extern WindowPtr *WindowTable;
a105 3
#ifdef DO_SAVE_UNDERS
    Bool	dosave = FALSE;
#endif
a171 6
#ifdef DO_SAVE_UNDERS
	if (DO_SAVE_UNDERS(pWin))
	{
	    dosave = (*pScreen->ChangeSaveUnder)(pLayerWin, pLayerWin);
	}
#endif /* DO_SAVE_UNDERS */
a180 4
#ifdef DO_SAVE_UNDERS
	if (dosave)
	    (*pScreen->PostChangeSaveUnder)(pLayerWin, pLayerWin);
#endif /* DO_SAVE_UNDERS */
a197 1
    KdOffscreenSwapOut (pScreen);
a273 1
    KdOffscreenSwapIn (pScreen);    
d570 1
a570 1
    ErrorF("-nozap           Don't terminate server on Ctrl+Alt+Backspace\n");
d616 1
a616 1
    if (!strcmp (argv[i], "-nozap"))
d618 1
a618 1
	kdDontZap = TRUE;
d742 1
a742 1
    pScreenPriv = (KdPrivScreenPtr) xalloc(sizeof (*pScreenPriv));
a744 1
    memset (pScreenPriv, '\0', sizeof (KdPrivScreenRec));
a782 3
    if (screen->off_screen_base < screen->memory_size)
	KdOffscreenFini (pScreen);
    
a1080 3

    if (screen->off_screen_base < screen->memory_size)
	KdOffscreenInit (pScreen);
d1374 5
a1396 2

void ddxInitGlobals(void) { /* THANK YOU XPRINT */ }
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d32 1
d70 2
a71 2
int                 kdScreenPrivateIndex;
unsigned long       kdGeneration;
d105 1
a105 1
    RegionPtr	pOldClip = 0, bsExposed;
a162 6
	if (pWin->backStorage)
	{
	    pOldClip = REGION_CREATE(pScreen, NullBox, 1);
	    REGION_COPY(pScreen, pOldClip, &pWin->clipList);
	}

a185 22
    if (pWin->backStorage &&
	((pWin->backingStore == Always) || WasViewable))
    {
	if (!WasViewable)
	    pOldClip = &pWin->clipList; /* a convenient empty region */
	bsExposed = (*pScreen->TranslateBackingStore)
			     (pWin, 0, 0, pOldClip,
			      pWin->drawable.x, pWin->drawable.y);
	if (WasViewable)
	    REGION_DESTROY(pScreen, pOldClip);
	if (bsExposed)
	{
	    RegionPtr	valExposed = NullRegion;
    
	    if (pWin->valdata)
		valExposed = &pWin->valdata->after.exposed;
	    (*pScreen->WindowExposures) (pWin, valExposed, bsExposed);
	    if (valExposed)
		REGION_EMPTY(pScreen, valExposed);
	    REGION_DESTROY(pScreen, bsExposed);
	}
    }
a635 5
    if (!strcmp (argv[i], "-nozap"))
    {
	kdDontZap = TRUE;
	return 1;
    }
d755 2
a756 4
    {
	kdScreenPrivateIndex = AllocateScreenPrivateIndex();
	kdGeneration         = serverGeneration;
    }
d1397 2
a1398 2
void
DPMSSet(int level)
@


1.1
log
@Initial revision
@
text
@a1 2
 * $RCSId: xc/programs/Xserver/hw/kdrive/kdrive.c,v 1.29 2002/10/31 18:29:50 keithp Exp $ 
 *
d44 6
d67 2
d84 4
a99 1
#ifndef FB_OLD_SCREEN
a225 1
#endif	/* !FB_OLD_SCREEN */
d282 1
a282 1
	    if (card->driver)
d296 2
a297 1
	(*kdOsFuncs->Disable) ();
d355 2
a356 1
	(*kdOsFuncs->Enable) ();
d376 1
a376 1
	if (kdEnabled)
d378 2
a379 1
	(*kdOsFuncs->Fini) ();
d382 3
d396 1
a396 1
static char *
a576 91
/*
 * Parse mouse information.  Syntax:
 *
 *  <device>,<nbutton>,<protocol>{,<option>}...
 *
 * options: {nmo}   pointer mapping (e.g. {321})
 *	    2button emulate middle button
 *	    3button dont emulate middle button
 */

void
KdParseMouse (char *arg)
{
    char	save[1024];
    char	delim;
    KdMouseInfo	*mi;
    int		i;
    
    mi = KdMouseInfoAdd ();
    if (!mi)
	return;
    mi->name = 0;
    mi->prot = 0;
    mi->emulateMiddleButton = kdEmulateMiddleButton;
    mi->transformCoordinates = !kdRawPointerCoordinates;
    mi->nbutton = 3;
    for (i = 0; i < KD_MAX_BUTTON; i++)
	mi->map[i] = i + 1;
    
    if (!arg)
	return;
    if (strlen (arg) >= sizeof (save))
	return;
    arg = KdParseFindNext (arg, ",", save, &delim);
    if (!save[0])
	return;
    mi->name = KdSaveString (save);
    if (delim != ',')
	return;
    
    arg = KdParseFindNext (arg, ",", save, &delim);
    if (!save[0])
	return;
    
    if ('1' <= save[0] && save[0] <= '0' + KD_MAX_BUTTON && save[1] == '\0')
    {
        mi->nbutton = save[0] - '0';
	if (mi->nbutton > KD_MAX_BUTTON)
	{
	    UseMsg ();
	    return;
	}
    }
    
    if (!delim != ',')
	return;
    
    arg = KdParseFindNext (arg, ",", save, &delim);
    
    if (save[0])
	mi->prot = KdSaveString (save);
    
    while (delim == ',')
    {
	arg = KdParseFindNext (arg, ",", save, &delim);
	if (save[0] == '{')
	{
	    char	*s = save + 1;
	    i = 0;
	    while (*s && *s != '}')
	    {
		if ('1' <= *s && *s <= '0' + mi->nbutton)
		    mi->map[i] = *s - '0';
		else
		    UseMsg ();
		s++;
	    }
	}
	else if (!strcmp (save, "2button"))
	    mi->emulateMiddleButton = TRUE;
	else if (!strcmp (save, "3button"))
	    mi->emulateMiddleButton = FALSE;
	else if (!strcmp (save, "rawcoord"))
	    mi->transformCoordinates = FALSE;
	else if (!strcmp (save, "transform"))
	    mi->transformCoordinates = TRUE;
	else
	    UseMsg ();
    }
}

d601 2
a610 1
    ErrorF("-mouse path[,n]  Filename of mouse device, n is number of buttons\n");
d663 5
a716 8
    if (!strcmp (argv[i], "-mouse"))
    {
	if ((i+1) < argc)
	    KdParseMouse (argv[i+1]);
	else
	    UseMsg ();
	return 2;
    }
d738 16
d775 2
a776 1
	    (*pOsFuncs->Init) ();
a1070 8
#ifdef FB_OLD_SCREEN
    pScreenPriv->BackingStoreFuncs.SaveAreas = fbSaveAreas;
    pScreenPriv->BackingStoreFuncs.RestoreAreas = fbSaveAreas;
    pScreenPriv->BackingStoreFuncs.SetClipmaskRgn = 0;
    pScreenPriv->BackingStoreFuncs.GetImagePixmap = 0;
    pScreenPriv->BackingStoreFuncs.GetSpansPixmap = 0;
#endif

a1151 3
#ifdef FB_OLD_SCREEN
    miInitializeBackingStore (pScreen, &pScreenPriv->BackingStoreFuncs);
#else
a1153 1
#endif
d1349 33
d1389 1
a1389 1
    
d1426 2
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
a45 6
#ifdef HAVE_EXECINFO_H
#include <execinfo.h>
#endif

#include <signal.h>

a62 2
#define KD_DEFAULT_BUTTONS 5

a77 4
Bool		    kdHasPointer = FALSE;
Bool		    kdHasKbd = FALSE;

static Bool         kdCaughtSignal = FALSE;
d90 1
d217 1
d274 1
a274 1
	    if (card->driver && card->cfuncs->restore)
d288 1
a288 2
        if (kdOsFuncs->Disable)
            (*kdOsFuncs->Disable) ();
d346 1
a346 2
        if (kdOsFuncs->Enable)
            (*kdOsFuncs->Enable) ();
d366 1
a366 1
	if (kdEnabled && kdOsFuncs->Disable)
d368 1
a368 2
        if (kdOsFuncs->Fini)
            (*kdOsFuncs->Fini) ();
a370 3

    if (kdCaughtSignal)
        abort();
d382 1
a382 1
char *
d563 91
a677 2
    ErrorF("-mouse driver [,n,,options]    Specify the pointer driver and its options (n is the number of buttons)\n");
    ErrorF("-keybd driver [,,options]      Specify the keyboard driver and its options\n");
d686 1
a738 5
    if (!strcmp (argv[i], "-nozap"))
    {
	kdDontZap = TRUE;
	return 1;
    }
d788 8
a816 16
    if (!strcmp (argv[i], "-mouse") ||
        !strcmp (argv[i], "-pointer")) {
        if (i + 1 >= argc)
            UseMsg();
        KdAddConfigPointer(argv[i + 1]);
	kdHasPointer = TRUE;
        return 2;
    }
    if (!strcmp (argv[i], "-keybd")) {
        if (i + 1 >= argc)
            UseMsg();
        KdAddConfigKeyboard(argv[i + 1]);
	kdHasKbd = TRUE;
        return 2;
    }

d838 1
a838 2
            if (pOsFuncs->Init)
                (*pOsFuncs->Init) ();
d1133 8
d1222 3
d1227 1
a1422 33
#ifdef HAVE_BACKTRACE
/* shamelessly ripped from xf86Events.c */
void
KdBacktrace (int signum)
{
    void *array[32]; /* more than 32 and you have bigger problems */
    size_t size, i;
    char **strings;

    signal(signum, SIG_IGN);

    size = backtrace (array, 32);
    fprintf (stderr, "\nBacktrace (%d deep):\n", size);
    strings = backtrace_symbols (array, size);
    for (i = 0; i < size; i++)
        fprintf (stderr, "%d: %s\n", i, strings[i]);
    free (strings);
    
    kdCaughtSignal = TRUE;    
    if (signum == SIGSEGV)
        FatalError("Segmentation fault caught\n");
    else if (signum > 0)
        FatalError("Signal %d caught\n", signum);
}
#else
void
KdBacktrace (int signum)
{
    kdCaughtSignal = TRUE;
    FatalError("Segmentation fault caught\n");
}
#endif

a1429 6

#ifdef COMPOSITE
    /* kind of a hack: we want Composite enabled, but it's disabled per
     * default. */
    noCompositeExtension = FALSE;
#endif
a1466 2

    signal(SIGSEGV, KdBacktrace);
@

