head	1.12;
access;
symbols
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.55;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.55;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.04.16;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*

   XFree86 Xv DDX written by Mark Vojkovich (markv@@valinux.com)
   Adapted for KDrive by Pontus Lidman <pontus.lidman@@nokia.com>

   Copyright (C) 2000, 2001 - Nokia Home Communications
   Copyright (C) 1998, 1999 - The XFree86 Project Inc.

All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, and/or sell copies of the Software, and to permit persons
to whom the Software is furnished to do so, provided that the above
copyright notice(s) and this permission notice appear in all copies of
the Software and that both the above copyright notice(s) and this
permission notice appear in supporting documentation.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY
SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER
RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale, use
or other dealings in this Software without prior written authorization
of the copyright holder.

*/

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif
#include "kdrive.h"

#include "scrnintstr.h"
#include "regionstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "mivalidate.h"
#include "validate.h"
#include "resource.h"
#include "gcstruct.h"
#include "dixstruct.h"

#include <X11/extensions/Xv.h>
#include <X11/extensions/Xvproto.h>

#include "kxv.h"
#include "fourcc.h"

/* XvAdaptorRec fields */

static int KdXVPutVideo(DrawablePtr, XvPortPtr, GCPtr,
                        INT16, INT16, CARD16, CARD16,
                        INT16, INT16, CARD16, CARD16);
static int KdXVPutStill(DrawablePtr, XvPortPtr, GCPtr,
                        INT16, INT16, CARD16, CARD16,
                        INT16, INT16, CARD16, CARD16);
static int KdXVGetVideo(DrawablePtr, XvPortPtr, GCPtr,
                        INT16, INT16, CARD16, CARD16,
                        INT16, INT16, CARD16, CARD16);
static int KdXVGetStill(DrawablePtr, XvPortPtr, GCPtr,
                        INT16, INT16, CARD16, CARD16,
                        INT16, INT16, CARD16, CARD16);
static int KdXVStopVideo(XvPortPtr, DrawablePtr);
static int KdXVSetPortAttribute(XvPortPtr, Atom, INT32);
static int KdXVGetPortAttribute(XvPortPtr, Atom, INT32 *);
static int KdXVQueryBestSize(XvPortPtr, CARD8,
                             CARD16, CARD16, CARD16, CARD16,
                             unsigned int *, unsigned int *);
static int KdXVPutImage(DrawablePtr, XvPortPtr, GCPtr,
                        INT16, INT16, CARD16, CARD16,
                        INT16, INT16, CARD16, CARD16,
                        XvImagePtr, unsigned char *, Bool, CARD16, CARD16);
static int KdXVQueryImageAttributes(XvPortPtr, XvImagePtr,
                                    CARD16 *, CARD16 *, int *, int *);

/* ScreenRec fields */

static Bool KdXVDestroyWindow(WindowPtr pWin);
static void KdXVWindowExposures(WindowPtr pWin, RegionPtr r1);
static void KdXVClipNotify(WindowPtr pWin, int dx, int dy);
static Bool KdXVCloseScreen(ScreenPtr);

/* misc */
static Bool KdXVInitAdaptors(ScreenPtr, KdVideoAdaptorPtr, int);

static DevPrivateKeyRec KdXVWindowKeyRec;

#define KdXVWindowKey (&KdXVWindowKeyRec)
static DevPrivateKey KdXvScreenKey;
static DevPrivateKeyRec KdXVScreenPrivateKey;
static unsigned long KdXVGeneration = 0;
static unsigned long PortResource = 0;

#define GET_XV_SCREEN(pScreen) ((XvScreenPtr) \
    dixLookupPrivate(&(pScreen)->devPrivates, KdXvScreenKey))

#define GET_KDXV_SCREEN(pScreen) \
    ((KdXVScreenPtr)(dixGetPrivate(&pScreen->devPrivates, &KdXVScreenPrivateKey)))

#define GET_KDXV_WINDOW(pWin) ((KdXVWindowPtr) \
    dixLookupPrivate(&(pWin)->devPrivates, KdXVWindowKey))

KdVideoAdaptorPtr
KdXVAllocateVideoAdaptorRec(KdScreenInfo * screen)
{
    return calloc(1, sizeof(KdVideoAdaptorRec));
}

void
KdXVFreeVideoAdaptorRec(KdVideoAdaptorPtr ptr)
{
    free(ptr);
}

Bool
KdXVScreenInit(ScreenPtr pScreen, KdVideoAdaptorPtr adaptors, int num)
{
    KdXVScreenPtr ScreenPriv;

/*   fprintf(stderr,"KdXVScreenInit initializing %d adaptors\n",num); */

    if (KdXVGeneration != serverGeneration)
        KdXVGeneration = serverGeneration;

    if (noXvExtension)
        return FALSE;

    if (!dixRegisterPrivateKey(&KdXVWindowKeyRec, PRIVATE_WINDOW, 0))
        return FALSE;
    if (!dixRegisterPrivateKey(&KdXVScreenPrivateKey, PRIVATE_SCREEN, 0))
        return FALSE;

    if (Success != XvScreenInit(pScreen))
        return FALSE;

    KdXvScreenKey = XvGetScreenKey();
    PortResource = XvGetRTPort();

    ScreenPriv = malloc(sizeof(KdXVScreenRec));
    dixSetPrivate(&pScreen->devPrivates, &KdXVScreenPrivateKey, ScreenPriv);

    if (!ScreenPriv)
        return FALSE;

    ScreenPriv->DestroyWindow = pScreen->DestroyWindow;
    ScreenPriv->WindowExposures = pScreen->WindowExposures;
    ScreenPriv->ClipNotify = pScreen->ClipNotify;
    ScreenPriv->CloseScreen = pScreen->CloseScreen;

/*   fprintf(stderr,"XV: Wrapping screen funcs\n"); */

    pScreen->DestroyWindow = KdXVDestroyWindow;
    pScreen->WindowExposures = KdXVWindowExposures;
    pScreen->ClipNotify = KdXVClipNotify;
    pScreen->CloseScreen = KdXVCloseScreen;

    if (!KdXVInitAdaptors(pScreen, adaptors, num))
        return FALSE;

    return TRUE;
}

static void
KdXVFreeAdaptor(XvAdaptorPtr pAdaptor)
{
    int i;

    if (pAdaptor->pPorts) {
        XvPortPtr pPort = pAdaptor->pPorts;
        XvPortRecPrivatePtr pPriv;

        for (i = 0; i < pAdaptor->nPorts; i++, pPort++) {
            pPriv = (XvPortRecPrivatePtr) pPort->devPriv.ptr;
            if (pPriv) {
                if (pPriv->clientClip)
                    RegionDestroy(pPriv->clientClip);
                if (pPriv->pCompositeClip && pPriv->FreeCompositeClip)
                    RegionDestroy(pPriv->pCompositeClip);
                free(pPriv);
            }
        }
    }

    XvFreeAdaptor(pAdaptor);
}

static Bool
KdXVInitAdaptors(ScreenPtr pScreen, KdVideoAdaptorPtr infoPtr, int number)
{
    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;

    XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
    KdVideoAdaptorPtr adaptorPtr;
    XvAdaptorPtr pAdaptor, pa;
    XvAdaptorRecPrivatePtr adaptorPriv;
    int na, numAdaptor;
    XvPortRecPrivatePtr portPriv;
    XvPortPtr pPort, pp;
    int numPort;
    KdVideoFormatPtr formatPtr;
    XvFormatPtr pFormat, pf;
    int numFormat, totFormat;
    KdVideoEncodingPtr encodingPtr;
    XvEncodingPtr pEncode, pe;
    int numVisuals;
    VisualPtr pVisual;
    int i;

    pxvs->nAdaptors = 0;
    pxvs->pAdaptors = NULL;

    if (!(pAdaptor = calloc(number, sizeof(XvAdaptorRec))))
        return FALSE;

    for (pa = pAdaptor, na = 0, numAdaptor = 0; na < number; na++, adaptorPtr++) {
        adaptorPtr = &infoPtr[na];

        if (!adaptorPtr->StopVideo || !adaptorPtr->SetPortAttribute ||
            !adaptorPtr->GetPortAttribute || !adaptorPtr->QueryBestSize)
            continue;

        /* client libs expect at least one encoding */
        if (!adaptorPtr->nEncodings || !adaptorPtr->pEncodings)
            continue;

        pa->type = adaptorPtr->type;

        if (!adaptorPtr->PutVideo && !adaptorPtr->GetVideo)
            pa->type &= ~XvVideoMask;

        if (!adaptorPtr->PutStill && !adaptorPtr->GetStill)
            pa->type &= ~XvStillMask;

        if (!adaptorPtr->PutImage || !adaptorPtr->QueryImageAttributes)
            pa->type &= ~XvImageMask;

        if (!adaptorPtr->PutVideo && !adaptorPtr->PutImage &&
            !adaptorPtr->PutStill)
            pa->type &= ~XvInputMask;

        if (!adaptorPtr->GetVideo && !adaptorPtr->GetStill)
            pa->type &= ~XvOutputMask;

        if (!(adaptorPtr->type & (XvPixmapMask | XvWindowMask)))
            continue;
        if (!(adaptorPtr->type & (XvImageMask | XvVideoMask | XvStillMask)))
            continue;

        pa->pScreen = pScreen;
        pa->ddPutVideo = KdXVPutVideo;
        pa->ddPutStill = KdXVPutStill;
        pa->ddGetVideo = KdXVGetVideo;
        pa->ddGetStill = KdXVGetStill;
        pa->ddStopVideo = KdXVStopVideo;
        pa->ddPutImage = KdXVPutImage;
        pa->ddSetPortAttribute = KdXVSetPortAttribute;
        pa->ddGetPortAttribute = KdXVGetPortAttribute;
        pa->ddQueryBestSize = KdXVQueryBestSize;
        pa->ddQueryImageAttributes = KdXVQueryImageAttributes;
        pa->name = strdup(adaptorPtr->name);

        if (adaptorPtr->nEncodings &&
            (pEncode = calloc(adaptorPtr->nEncodings, sizeof(XvEncodingRec)))) {

            for (pe = pEncode, encodingPtr = adaptorPtr->pEncodings, i = 0;
                 i < adaptorPtr->nEncodings; pe++, i++, encodingPtr++) {
                pe->id = encodingPtr->id;
                pe->pScreen = pScreen;
                pe->name = strdup(encodingPtr->name);
                pe->width = encodingPtr->width;
                pe->height = encodingPtr->height;
                pe->rate.numerator = encodingPtr->rate.numerator;
                pe->rate.denominator = encodingPtr->rate.denominator;
            }
            pa->nEncodings = adaptorPtr->nEncodings;
            pa->pEncodings = pEncode;
        }

        if (adaptorPtr->nImages &&
            (pa->pImages = calloc(adaptorPtr->nImages, sizeof(XvImageRec)))) {
            memcpy(pa->pImages, adaptorPtr->pImages,
                   adaptorPtr->nImages * sizeof(XvImageRec));
            pa->nImages = adaptorPtr->nImages;
        }

        if (adaptorPtr->nAttributes &&
            (pa->pAttributes = calloc(adaptorPtr->nAttributes,
                                      sizeof(XvAttributeRec)))) {
            memcpy(pa->pAttributes, adaptorPtr->pAttributes,
                   adaptorPtr->nAttributes * sizeof(XvAttributeRec));

            for (i = 0; i < adaptorPtr->nAttributes; i++) {
                pa->pAttributes[i].name =
                    strdup(adaptorPtr->pAttributes[i].name);
            }

            pa->nAttributes = adaptorPtr->nAttributes;
        }

        totFormat = adaptorPtr->nFormats;

        if (!(pFormat = calloc(totFormat, sizeof(XvFormatRec)))) {
            KdXVFreeAdaptor(pa);
            continue;
        }
        for (pf = pFormat, i = 0, numFormat = 0, formatPtr =
             adaptorPtr->pFormats; i < adaptorPtr->nFormats; i++, formatPtr++) {
            numVisuals = pScreen->numVisuals;
            pVisual = pScreen->visuals;

            while (numVisuals--) {
                if ((pVisual->class == formatPtr->class) &&
                    (pVisual->nplanes == formatPtr->depth)) {

                    if (numFormat >= totFormat) {
                        void *moreSpace;

                        totFormat *= 2;
                        moreSpace = reallocarray(pFormat, totFormat,
                                                 sizeof(XvFormatRec));
                        if (!moreSpace)
                            break;
                        pFormat = moreSpace;
                        pf = pFormat + numFormat;
                    }

                    pf->visual = pVisual->vid;
                    pf->depth = formatPtr->depth;

                    pf++;
                    numFormat++;
                }
                pVisual++;
            }
        }
        pa->nFormats = numFormat;
        pa->pFormats = pFormat;
        if (!numFormat) {
            KdXVFreeAdaptor(pa);
            continue;
        }

        if (!(adaptorPriv = calloc(1, sizeof(XvAdaptorRecPrivate)))) {
            KdXVFreeAdaptor(pa);
            continue;
        }

        adaptorPriv->flags = adaptorPtr->flags;
        adaptorPriv->PutVideo = adaptorPtr->PutVideo;
        adaptorPriv->PutStill = adaptorPtr->PutStill;
        adaptorPriv->GetVideo = adaptorPtr->GetVideo;
        adaptorPriv->GetStill = adaptorPtr->GetStill;
        adaptorPriv->StopVideo = adaptorPtr->StopVideo;
        adaptorPriv->SetPortAttribute = adaptorPtr->SetPortAttribute;
        adaptorPriv->GetPortAttribute = adaptorPtr->GetPortAttribute;
        adaptorPriv->QueryBestSize = adaptorPtr->QueryBestSize;
        adaptorPriv->QueryImageAttributes = adaptorPtr->QueryImageAttributes;
        adaptorPriv->PutImage = adaptorPtr->PutImage;
        adaptorPriv->ReputImage = adaptorPtr->ReputImage;

        pa->devPriv.ptr = (void *) adaptorPriv;

        if (!(pPort = calloc(adaptorPtr->nPorts, sizeof(XvPortRec)))) {
            KdXVFreeAdaptor(pa);
            continue;
        }
        for (pp = pPort, i = 0, numPort = 0; i < adaptorPtr->nPorts; i++) {

            if (!(pp->id = FakeClientID(0)))
                continue;

            if (!(portPriv = calloc(1, sizeof(XvPortRecPrivate))))
                continue;

            if (!AddResource(pp->id, PortResource, pp)) {
                free(portPriv);
                continue;
            }

            pp->pAdaptor = pa;
            pp->pNotify = (XvPortNotifyPtr) NULL;
            pp->pDraw = (DrawablePtr) NULL;
            pp->client = (ClientPtr) NULL;
            pp->grab.client = (ClientPtr) NULL;
            pp->time = currentTime;
            pp->devPriv.ptr = portPriv;

            portPriv->screen = screen;
            portPriv->AdaptorRec = adaptorPriv;
            portPriv->DevPriv.ptr = adaptorPtr->pPortPrivates[i].ptr;

            pp++;
            numPort++;
        }
        pa->nPorts = numPort;
        pa->pPorts = pPort;
        if (!numPort) {
            KdXVFreeAdaptor(pa);
            continue;
        }

        pa->base_id = pPort->id;

        pa++;
        numAdaptor++;
    }

    if (numAdaptor) {
        pxvs->nAdaptors = numAdaptor;
        pxvs->pAdaptors = pAdaptor;
    }
    else {
        free(pAdaptor);
        return FALSE;
    }

    return TRUE;
}

/* Video should be clipped to the intersection of the window cliplist
   and the client cliplist specified in the GC for which the video was
   initialized.  When we need to reclip a window, the GC that started
   the video may not even be around anymore.  That's why we save the
   client clip from the GC when the video is initialized.  We then
   use KdXVUpdateCompositeClip to calculate the new composite clip
   when we need it.  This is different from what DEC did.  They saved
   the GC and used it's clip list when they needed to reclip the window,
   even if the client clip was different from the one the video was
   initialized with.  If the original GC was destroyed, they had to stop
   the video.  I like the new method better (MArk).

   This function only works for windows.  Will need to rewrite when
   (if) we support pixmap rendering.
*/

static void
KdXVUpdateCompositeClip(XvPortRecPrivatePtr portPriv)
{
    RegionPtr pregWin, pCompositeClip;
    WindowPtr pWin;
    Bool freeCompClip = FALSE;

    if (portPriv->pCompositeClip)
        return;

    pWin = (WindowPtr) portPriv->pDraw;

    /* get window clip list */
    if (portPriv->subWindowMode == IncludeInferiors) {
        pregWin = NotClippedByChildren(pWin);
        freeCompClip = TRUE;
    }
    else
        pregWin = &pWin->clipList;

    if (!portPriv->clientClip) {
        portPriv->pCompositeClip = pregWin;
        portPriv->FreeCompositeClip = freeCompClip;
        return;
    }

    pCompositeClip = RegionCreate(NullBox, 1);
    RegionCopy(pCompositeClip, portPriv->clientClip);
    RegionTranslate(pCompositeClip,
                    portPriv->pDraw->x + portPriv->clipOrg.x,
                    portPriv->pDraw->y + portPriv->clipOrg.y);
    RegionIntersect(pCompositeClip, pregWin, pCompositeClip);

    portPriv->pCompositeClip = pCompositeClip;
    portPriv->FreeCompositeClip = TRUE;

    if (freeCompClip) {
        RegionDestroy(pregWin);
    }
}

/* Save the current clientClip and update the CompositeClip whenever
   we have a fresh GC */

static void
KdXVCopyClip(XvPortRecPrivatePtr portPriv, GCPtr pGC)
{
    /* copy the new clip if it exists */
    if (pGC->clientClip) {
        if (!portPriv->clientClip)
            portPriv->clientClip = RegionCreate(NullBox, 1);
        /* Note: this is in window coordinates */
        RegionCopy(portPriv->clientClip, pGC->clientClip);
    }
    else if (portPriv->clientClip) {    /* free the old clientClip */
        RegionDestroy(portPriv->clientClip);
        portPriv->clientClip = NULL;
    }

    /* get rid of the old clip list */
    if (portPriv->pCompositeClip && portPriv->FreeCompositeClip) {
        RegionDestroy(portPriv->pCompositeClip);
    }

    portPriv->clipOrg = pGC->clipOrg;
    portPriv->pCompositeClip = pGC->pCompositeClip;
    portPriv->FreeCompositeClip = FALSE;
    portPriv->subWindowMode = pGC->subWindowMode;
}

static int
KdXVRegetVideo(XvPortRecPrivatePtr portPriv)
{
    RegionRec WinRegion;
    RegionRec ClipRegion;
    BoxRec WinBox;
    int ret = Success;
    Bool clippedAway = FALSE;

    KdXVUpdateCompositeClip(portPriv);

    /* translate the video region to the screen */
    WinBox.x1 = portPriv->pDraw->x + portPriv->drw_x;
    WinBox.y1 = portPriv->pDraw->y + portPriv->drw_y;
    WinBox.x2 = WinBox.x1 + portPriv->drw_w;
    WinBox.y2 = WinBox.y1 + portPriv->drw_h;

    /* clip to the window composite clip */
    RegionInit(&WinRegion, &WinBox, 1);
    RegionInit(&ClipRegion, NullBox, 1);
    RegionIntersect(&ClipRegion, &WinRegion, portPriv->pCompositeClip);

    /* that's all if it's totally obscured */
    if (!RegionNotEmpty(&ClipRegion)) {
        clippedAway = TRUE;
        goto CLIP_VIDEO_BAILOUT;
    }

    ret = (*portPriv->AdaptorRec->GetVideo) (portPriv->screen, portPriv->pDraw,
                                             portPriv->vid_x, portPriv->vid_y,
                                             WinBox.x1, WinBox.y1,
                                             portPriv->vid_w, portPriv->vid_h,
                                             portPriv->drw_w, portPriv->drw_h,
                                             &ClipRegion,
                                             portPriv->DevPriv.ptr);

    if (ret == Success)
        portPriv->isOn = XV_ON;

 CLIP_VIDEO_BAILOUT:

    if ((clippedAway || (ret != Success)) && portPriv->isOn == XV_ON) {
        (*portPriv->AdaptorRec->StopVideo) (portPriv->screen,
                                            portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
    }

    /* This clip was copied and only good for one shot */
    if (!portPriv->FreeCompositeClip)
        portPriv->pCompositeClip = NULL;

    RegionUninit(&WinRegion);
    RegionUninit(&ClipRegion);

    return ret;
}

static int
KdXVReputVideo(XvPortRecPrivatePtr portPriv)
{
    RegionRec WinRegion;
    RegionRec ClipRegion;
    BoxRec WinBox;
    ScreenPtr pScreen = portPriv->pDraw->pScreen;

    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    int ret = Success;
    Bool clippedAway = FALSE;

    KdXVUpdateCompositeClip(portPriv);

    /* translate the video region to the screen */
    WinBox.x1 = portPriv->pDraw->x + portPriv->drw_x;
    WinBox.y1 = portPriv->pDraw->y + portPriv->drw_y;
    WinBox.x2 = WinBox.x1 + portPriv->drw_w;
    WinBox.y2 = WinBox.y1 + portPriv->drw_h;

    /* clip to the window composite clip */
    RegionInit(&WinRegion, &WinBox, 1);
    RegionInit(&ClipRegion, NullBox, 1);
    RegionIntersect(&ClipRegion, &WinRegion, portPriv->pCompositeClip);

    /* clip and translate to the viewport */
    if (portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
        RegionRec VPReg;
        BoxRec VPBox;

        VPBox.x1 = 0;
        VPBox.y1 = 0;
        VPBox.x2 = screen->width;
        VPBox.y2 = screen->height;

        RegionInit(&VPReg, &VPBox, 1);
        RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
        RegionUninit(&VPReg);
    }

    /* that's all if it's totally obscured */
    if (!RegionNotEmpty(&ClipRegion)) {
        clippedAway = TRUE;
        goto CLIP_VIDEO_BAILOUT;
    }

    ret = (*portPriv->AdaptorRec->PutVideo) (portPriv->screen, portPriv->pDraw,
                                             portPriv->vid_x, portPriv->vid_y,
                                             WinBox.x1, WinBox.y1,
                                             portPriv->vid_w, portPriv->vid_h,
                                             portPriv->drw_w, portPriv->drw_h,
                                             &ClipRegion,
                                             portPriv->DevPriv.ptr);

    if (ret == Success)
        portPriv->isOn = XV_ON;

 CLIP_VIDEO_BAILOUT:

    if ((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
        (*portPriv->AdaptorRec->StopVideo) (portPriv->screen,
                                            portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
    }

    /* This clip was copied and only good for one shot */
    if (!portPriv->FreeCompositeClip)
        portPriv->pCompositeClip = NULL;

    RegionUninit(&WinRegion);
    RegionUninit(&ClipRegion);

    return ret;
}

static int
KdXVReputImage(XvPortRecPrivatePtr portPriv)
{
    RegionRec WinRegion;
    RegionRec ClipRegion;
    BoxRec WinBox;
    ScreenPtr pScreen = portPriv->pDraw->pScreen;

    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    int ret = Success;
    Bool clippedAway = FALSE;

    KdXVUpdateCompositeClip(portPriv);

    /* translate the video region to the screen */
    WinBox.x1 = portPriv->pDraw->x + portPriv->drw_x;
    WinBox.y1 = portPriv->pDraw->y + portPriv->drw_y;
    WinBox.x2 = WinBox.x1 + portPriv->drw_w;
    WinBox.y2 = WinBox.y1 + portPriv->drw_h;

    /* clip to the window composite clip */
    RegionInit(&WinRegion, &WinBox, 1);
    RegionInit(&ClipRegion, NullBox, 1);
    RegionIntersect(&ClipRegion, &WinRegion, portPriv->pCompositeClip);

    /* clip and translate to the viewport */
    if (portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
        RegionRec VPReg;
        BoxRec VPBox;

        VPBox.x1 = 0;
        VPBox.y1 = 0;
        VPBox.x2 = screen->width;
        VPBox.y2 = screen->height;

        RegionInit(&VPReg, &VPBox, 1);
        RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
        RegionUninit(&VPReg);
    }

    /* that's all if it's totally obscured */
    if (!RegionNotEmpty(&ClipRegion)) {
        clippedAway = TRUE;
        goto CLIP_VIDEO_BAILOUT;
    }

    ret =
        (*portPriv->AdaptorRec->ReputImage) (portPriv->screen, portPriv->pDraw,
                                             WinBox.x1, WinBox.y1, &ClipRegion,
                                             portPriv->DevPriv.ptr);

    portPriv->isOn = (ret == Success) ? XV_ON : XV_OFF;

 CLIP_VIDEO_BAILOUT:

    if ((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
        (*portPriv->AdaptorRec->StopVideo) (portPriv->screen,
                                            portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
    }

    /* This clip was copied and only good for one shot */
    if (!portPriv->FreeCompositeClip)
        portPriv->pCompositeClip = NULL;

    RegionUninit(&WinRegion);
    RegionUninit(&ClipRegion);

    return ret;
}

static int
KdXVReputAllVideo(WindowPtr pWin, void *data)
{
    KdXVWindowPtr WinPriv;

    if (pWin->drawable.type != DRAWABLE_WINDOW)
        return WT_DONTWALKCHILDREN;

    WinPriv = GET_KDXV_WINDOW(pWin);

    while (WinPriv) {
        if (WinPriv->PortRec->type == XvInputMask)
            KdXVReputVideo(WinPriv->PortRec);
        else
            KdXVRegetVideo(WinPriv->PortRec);
        WinPriv = WinPriv->next;
    }

    return WT_WALKCHILDREN;
}

static int
KdXVEnlistPortInWindow(WindowPtr pWin, XvPortRecPrivatePtr portPriv)
{
    KdXVWindowPtr winPriv, PrivRoot;

    winPriv = PrivRoot = GET_KDXV_WINDOW(pWin);

    /* Enlist our port in the window private */
    while (winPriv) {
        if (winPriv->PortRec == portPriv)       /* we're already listed */
            break;
        winPriv = winPriv->next;
    }

    if (!winPriv) {
        winPriv = malloc(sizeof(KdXVWindowRec));
        if (!winPriv)
            return BadAlloc;
        winPriv->PortRec = portPriv;
        winPriv->next = PrivRoot;
        dixSetPrivate(&pWin->devPrivates, KdXVWindowKey, winPriv);
    }
    return Success;
}

static void
KdXVRemovePortFromWindow(WindowPtr pWin, XvPortRecPrivatePtr portPriv)
{
    KdXVWindowPtr winPriv, prevPriv = NULL;

    winPriv = GET_KDXV_WINDOW(pWin);

    while (winPriv) {
        if (winPriv->PortRec == portPriv) {
            if (prevPriv)
                prevPriv->next = winPriv->next;
            else
                dixSetPrivate(&pWin->devPrivates, KdXVWindowKey, winPriv->next);
            free(winPriv);
            break;
        }
        prevPriv = winPriv;
        winPriv = winPriv->next;
    }
    portPriv->pDraw = NULL;
}

/****  ScreenRec fields ****/

static Bool
KdXVDestroyWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    KdXVScreenPtr ScreenPriv = GET_KDXV_SCREEN(pScreen);
    KdXVWindowPtr tmp, WinPriv = GET_KDXV_WINDOW(pWin);
    int ret;

    while (WinPriv) {
        XvPortRecPrivatePtr pPriv = WinPriv->PortRec;

        if (pPriv->isOn > XV_OFF) {
            (*pPriv->AdaptorRec->StopVideo) (pPriv->screen, pPriv->DevPriv.ptr,
                                             TRUE);
            pPriv->isOn = XV_OFF;
        }

        pPriv->pDraw = NULL;
        tmp = WinPriv;
        WinPriv = WinPriv->next;
        free(tmp);
    }

    dixSetPrivate(&pWin->devPrivates, KdXVWindowKey, NULL);

    pScreen->DestroyWindow = ScreenPriv->DestroyWindow;
    ret = (*pScreen->DestroyWindow) (pWin);
    pScreen->DestroyWindow = KdXVDestroyWindow;

    return ret;
}

static void
KdXVWindowExposures(WindowPtr pWin, RegionPtr reg1)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    KdXVScreenPtr ScreenPriv = GET_KDXV_SCREEN(pScreen);
    KdXVWindowPtr WinPriv = GET_KDXV_WINDOW(pWin);
    KdXVWindowPtr pPrev;
    XvPortRecPrivatePtr pPriv;
    Bool AreasExposed;

    AreasExposed = (WinPriv && reg1 && RegionNotEmpty(reg1));

    pScreen->WindowExposures = ScreenPriv->WindowExposures;
    (*pScreen->WindowExposures) (pWin, reg1);
    pScreen->WindowExposures = KdXVWindowExposures;

    /* filter out XClearWindow/Area */
    if (!pWin->valdata)
        return;

    pPrev = NULL;

    while (WinPriv) {
        pPriv = WinPriv->PortRec;

        /* Reput anyone with a reput function */

        switch (pPriv->type) {
        case XvInputMask:
            KdXVReputVideo(pPriv);
            break;
        case XvOutputMask:
            KdXVRegetVideo(pPriv);
            break;
        default:               /* overlaid still/image */
            if (pPriv->AdaptorRec->ReputImage)
                KdXVReputImage(pPriv);
            else if (AreasExposed) {
                KdXVWindowPtr tmp;

                if (pPriv->isOn == XV_ON) {
                    (*pPriv->AdaptorRec->StopVideo) (pPriv->screen,
                                                     pPriv->DevPriv.ptr, FALSE);
                    pPriv->isOn = XV_PENDING;
                }
                pPriv->pDraw = NULL;

                if (!pPrev)
                    dixSetPrivate(&pWin->devPrivates, KdXVWindowKey,
                                  WinPriv->next);
                else
                    pPrev->next = WinPriv->next;
                tmp = WinPriv;
                WinPriv = WinPriv->next;
                free(tmp);
                continue;
            }
            break;
        }
        pPrev = WinPriv;
        WinPriv = WinPriv->next;
    }
}

static void
KdXVClipNotify(WindowPtr pWin, int dx, int dy)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    KdXVScreenPtr ScreenPriv = GET_KDXV_SCREEN(pScreen);
    KdXVWindowPtr WinPriv = GET_KDXV_WINDOW(pWin);
    KdXVWindowPtr tmp, pPrev = NULL;
    XvPortRecPrivatePtr pPriv;
    Bool visible = (pWin->visibility == VisibilityUnobscured) ||
        (pWin->visibility == VisibilityPartiallyObscured);

    while (WinPriv) {
        pPriv = WinPriv->PortRec;

        if (pPriv->pCompositeClip && pPriv->FreeCompositeClip)
            RegionDestroy(pPriv->pCompositeClip);

        pPriv->pCompositeClip = NULL;

        /* Stop everything except images, but stop them too if the
           window isn't visible.  But we only remove the images. */

        if (pPriv->type || !visible) {
            if (pPriv->isOn == XV_ON) {
                (*pPriv->AdaptorRec->StopVideo) (pPriv->screen,
                                                 pPriv->DevPriv.ptr, FALSE);
                pPriv->isOn = XV_PENDING;
            }

            if (!pPriv->type) { /* overlaid still/image */
                pPriv->pDraw = NULL;

                if (!pPrev)
                    dixSetPrivate(&pWin->devPrivates, KdXVWindowKey,
                                  WinPriv->next);
                else
                    pPrev->next = WinPriv->next;
                tmp = WinPriv;
                WinPriv = WinPriv->next;
                free(tmp);
                continue;
            }
        }

        pPrev = WinPriv;
        WinPriv = WinPriv->next;
    }

    if (ScreenPriv->ClipNotify) {
        pScreen->ClipNotify = ScreenPriv->ClipNotify;
        (*pScreen->ClipNotify) (pWin, dx, dy);
        pScreen->ClipNotify = KdXVClipNotify;
    }
}

/**** Required XvScreenRec fields ****/

static Bool
KdXVCloseScreen(ScreenPtr pScreen)
{
    XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
    KdXVScreenPtr ScreenPriv = GET_KDXV_SCREEN(pScreen);
    XvAdaptorPtr pa;
    int c;

    if (!ScreenPriv)
        return TRUE;

    pScreen->DestroyWindow = ScreenPriv->DestroyWindow;
    pScreen->WindowExposures = ScreenPriv->WindowExposures;
    pScreen->ClipNotify = ScreenPriv->ClipNotify;
    pScreen->CloseScreen = ScreenPriv->CloseScreen;

/*   fprintf(stderr,"XV: Unwrapping screen funcs\n"); */

    for (c = 0, pa = pxvs->pAdaptors; c < pxvs->nAdaptors; c++, pa++) {
        KdXVFreeAdaptor(pa);
    }

    free(pxvs->pAdaptors);
    free(ScreenPriv);

    return pScreen->CloseScreen(pScreen);
}

static Bool
KdXVRunning(ScreenPtr pScreen)
{
    return (KdXVGeneration == serverGeneration && GET_XV_SCREEN(pScreen) != 0);
}

Bool
KdXVEnable(ScreenPtr pScreen)
{
    if (!KdXVRunning(pScreen))
        return TRUE;

    WalkTree(pScreen, KdXVReputAllVideo, 0);

    return TRUE;
}

void
KdXVDisable(ScreenPtr pScreen)
{
    XvScreenPtr pxvs;
    XvAdaptorPtr pAdaptor;
    XvPortPtr pPort;
    XvPortRecPrivatePtr pPriv;
    int i, j;

    if (!KdXVRunning(pScreen))
        return;

    pxvs = GET_XV_SCREEN(pScreen);

    for (i = 0; i < pxvs->nAdaptors; i++) {
        pAdaptor = &pxvs->pAdaptors[i];
        for (j = 0; j < pAdaptor->nPorts; j++) {
            pPort = &pAdaptor->pPorts[j];
            pPriv = (XvPortRecPrivatePtr) pPort->devPriv.ptr;
            if (pPriv->isOn > XV_OFF) {

                (*pPriv->AdaptorRec->StopVideo) (pPriv->screen,
                                                 pPriv->DevPriv.ptr, TRUE);
                pPriv->isOn = XV_OFF;

                if (pPriv->pCompositeClip && pPriv->FreeCompositeClip)
                    RegionDestroy(pPriv->pCompositeClip);

                pPriv->pCompositeClip = NULL;

                if (!pPriv->type && pPriv->pDraw) {     /* still */
                    KdXVRemovePortFromWindow((WindowPtr) pPriv->pDraw, pPriv);
                }
            }
        }
    }
}

/**** XvAdaptorRec fields ****/

static int
KdXVPutVideo(DrawablePtr pDraw,
             XvPortPtr pPort,
             GCPtr pGC,
             INT16 vid_x, INT16 vid_y,
             CARD16 vid_w, CARD16 vid_h,
             INT16 drw_x, INT16 drw_y, CARD16 drw_w, CARD16 drw_h)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);

    KdScreenPriv(portPriv->screen->pScreen);
    int result;

    /* No dumping video to pixmaps... For now anyhow */
    if (pDraw->type != DRAWABLE_WINDOW) {
        pPort->pDraw = (DrawablePtr) NULL;
        return BadAlloc;
    }

    /* If we are changing windows, unregister our port in the old window */
    if (portPriv->pDraw && (portPriv->pDraw != pDraw))
        KdXVRemovePortFromWindow((WindowPtr) (portPriv->pDraw), portPriv);

    /* Register our port with the new window */
    result = KdXVEnlistPortInWindow((WindowPtr) pDraw, portPriv);
    if (result != Success)
        return result;

    portPriv->pDraw = pDraw;
    portPriv->type = XvInputMask;

    /* save a copy of these parameters */
    portPriv->vid_x = vid_x;
    portPriv->vid_y = vid_y;
    portPriv->vid_w = vid_w;
    portPriv->vid_h = vid_h;
    portPriv->drw_x = drw_x;
    portPriv->drw_y = drw_y;
    portPriv->drw_w = drw_w;
    portPriv->drw_h = drw_h;

    /* make sure we have the most recent copy of the clientClip */
    KdXVCopyClip(portPriv, pGC);

    /* To indicate to the DI layer that we were successful */
    pPort->pDraw = pDraw;

    if (!pScreenPriv->enabled)
        return Success;

    return (KdXVReputVideo(portPriv));
}

static int
KdXVPutStill(DrawablePtr pDraw,
             XvPortPtr pPort,
             GCPtr pGC,
             INT16 vid_x, INT16 vid_y,
             CARD16 vid_w, CARD16 vid_h,
             INT16 drw_x, INT16 drw_y, CARD16 drw_w, CARD16 drw_h)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);
    ScreenPtr pScreen = pDraw->pScreen;

    KdScreenPriv(pScreen);
    KdScreenInfo *screen = pScreenPriv->screen;
    RegionRec WinRegion;
    RegionRec ClipRegion;
    BoxRec WinBox;
    int ret = Success;
    Bool clippedAway = FALSE;

    if (pDraw->type != DRAWABLE_WINDOW)
        return BadAlloc;

    if (!pScreenPriv->enabled)
        return Success;

    WinBox.x1 = pDraw->x + drw_x;
    WinBox.y1 = pDraw->y + drw_y;
    WinBox.x2 = WinBox.x1 + drw_w;
    WinBox.y2 = WinBox.y1 + drw_h;

    RegionInit(&WinRegion, &WinBox, 1);
    RegionInit(&ClipRegion, NullBox, 1);
    RegionIntersect(&ClipRegion, &WinRegion, pGC->pCompositeClip);

    if (portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
        RegionRec VPReg;
        BoxRec VPBox;

        VPBox.x1 = 0;
        VPBox.y1 = 0;
        VPBox.x2 = screen->width;
        VPBox.y2 = screen->height;

        RegionInit(&VPReg, &VPBox, 1);
        RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
        RegionUninit(&VPReg);
    }

    if (portPriv->pDraw) {
        KdXVRemovePortFromWindow((WindowPtr) (portPriv->pDraw), portPriv);
    }

    if (!RegionNotEmpty(&ClipRegion)) {
        clippedAway = TRUE;
        goto PUT_STILL_BAILOUT;
    }

    ret = (*portPriv->AdaptorRec->PutStill) (portPriv->screen, pDraw,
                                             vid_x, vid_y, WinBox.x1, WinBox.y1,
                                             vid_w, vid_h, drw_w, drw_h,
                                             &ClipRegion,
                                             portPriv->DevPriv.ptr);

    if ((ret == Success) &&
        (portPriv->AdaptorRec->flags & VIDEO_OVERLAID_STILLS)) {

        KdXVEnlistPortInWindow((WindowPtr) pDraw, portPriv);
        portPriv->isOn = XV_ON;
        portPriv->pDraw = pDraw;
        portPriv->drw_x = drw_x;
        portPriv->drw_y = drw_y;
        portPriv->drw_w = drw_w;
        portPriv->drw_h = drw_h;
        portPriv->type = 0;     /* no mask means it's transient and should
                                   not be reput once it's removed */
        pPort->pDraw = pDraw;   /* make sure we can get stop requests */
    }

 PUT_STILL_BAILOUT:

    if ((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
        (*portPriv->AdaptorRec->StopVideo) (portPriv->screen,
                                            portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
    }

    RegionUninit(&WinRegion);
    RegionUninit(&ClipRegion);

    return ret;
}

static int
KdXVGetVideo(DrawablePtr pDraw,
             XvPortPtr pPort,
             GCPtr pGC,
             INT16 vid_x, INT16 vid_y,
             CARD16 vid_w, CARD16 vid_h,
             INT16 drw_x, INT16 drw_y, CARD16 drw_w, CARD16 drw_h)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);
    int result;

    KdScreenPriv(portPriv->screen->pScreen);

    /* No pixmaps... For now anyhow */
    if (pDraw->type != DRAWABLE_WINDOW) {
        pPort->pDraw = (DrawablePtr) NULL;
        return BadAlloc;
    }

    /* If we are changing windows, unregister our port in the old window */
    if (portPriv->pDraw && (portPriv->pDraw != pDraw))
        KdXVRemovePortFromWindow((WindowPtr) (portPriv->pDraw), portPriv);

    /* Register our port with the new window */
    result = KdXVEnlistPortInWindow((WindowPtr) pDraw, portPriv);
    if (result != Success)
        return result;

    portPriv->pDraw = pDraw;
    portPriv->type = XvOutputMask;

    /* save a copy of these parameters */
    portPriv->vid_x = vid_x;
    portPriv->vid_y = vid_y;
    portPriv->vid_w = vid_w;
    portPriv->vid_h = vid_h;
    portPriv->drw_x = drw_x;
    portPriv->drw_y = drw_y;
    portPriv->drw_w = drw_w;
    portPriv->drw_h = drw_h;

    /* make sure we have the most recent copy of the clientClip */
    KdXVCopyClip(portPriv, pGC);

    /* To indicate to the DI layer that we were successful */
    pPort->pDraw = pDraw;

    if (!pScreenPriv->enabled)
        return Success;

    return (KdXVRegetVideo(portPriv));
}

static int
KdXVGetStill(DrawablePtr pDraw,
             XvPortPtr pPort,
             GCPtr pGC,
             INT16 vid_x, INT16 vid_y,
             CARD16 vid_w, CARD16 vid_h,
             INT16 drw_x, INT16 drw_y, CARD16 drw_w, CARD16 drw_h)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);
    ScreenPtr pScreen = pDraw->pScreen;

    KdScreenPriv(pScreen);
    RegionRec WinRegion;
    RegionRec ClipRegion;
    BoxRec WinBox;
    int ret = Success;
    Bool clippedAway = FALSE;

    if (pDraw->type != DRAWABLE_WINDOW)
        return BadAlloc;

    if (!pScreenPriv->enabled)
        return Success;

    WinBox.x1 = pDraw->x + drw_x;
    WinBox.y1 = pDraw->y + drw_y;
    WinBox.x2 = WinBox.x1 + drw_w;
    WinBox.y2 = WinBox.y1 + drw_h;

    RegionInit(&WinRegion, &WinBox, 1);
    RegionInit(&ClipRegion, NullBox, 1);
    RegionIntersect(&ClipRegion, &WinRegion, pGC->pCompositeClip);

    if (portPriv->pDraw) {
        KdXVRemovePortFromWindow((WindowPtr) (portPriv->pDraw), portPriv);
    }

    if (!RegionNotEmpty(&ClipRegion)) {
        clippedAway = TRUE;
        goto GET_STILL_BAILOUT;
    }

    ret = (*portPriv->AdaptorRec->GetStill) (portPriv->screen, pDraw,
                                             vid_x, vid_y, WinBox.x1, WinBox.y1,
                                             vid_w, vid_h, drw_w, drw_h,
                                             &ClipRegion,
                                             portPriv->DevPriv.ptr);

 GET_STILL_BAILOUT:

    if ((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
        (*portPriv->AdaptorRec->StopVideo) (portPriv->screen,
                                            portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
    }

    RegionUninit(&WinRegion);
    RegionUninit(&ClipRegion);

    return ret;
}

static int
KdXVStopVideo(XvPortPtr pPort, DrawablePtr pDraw)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);

    KdScreenPriv(portPriv->screen->pScreen);

    if (pDraw->type != DRAWABLE_WINDOW)
        return BadAlloc;

    KdXVRemovePortFromWindow((WindowPtr) pDraw, portPriv);

    if (!pScreenPriv->enabled)
        return Success;

    /* Must free resources. */

    if (portPriv->isOn > XV_OFF) {
        (*portPriv->AdaptorRec->StopVideo) (portPriv->screen,
                                            portPriv->DevPriv.ptr, TRUE);
        portPriv->isOn = XV_OFF;
    }

    return Success;
}

static int
KdXVSetPortAttribute(XvPortPtr pPort, Atom attribute, INT32 value)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);

    return ((*portPriv->AdaptorRec->SetPortAttribute) (portPriv->screen,
                                                       attribute, value,
                                                       portPriv->DevPriv.ptr));
}

static int
KdXVGetPortAttribute(XvPortPtr pPort, Atom attribute, INT32 *p_value)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);

    return ((*portPriv->AdaptorRec->GetPortAttribute) (portPriv->screen,
                                                       attribute,
                                                       (int *) p_value,
                                                       portPriv->DevPriv.ptr));
}

static int
KdXVQueryBestSize(XvPortPtr pPort,
                  CARD8 motion,
                  CARD16 vid_w, CARD16 vid_h,
                  CARD16 drw_w, CARD16 drw_h,
                  unsigned int *p_w, unsigned int *p_h)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);

    (*portPriv->AdaptorRec->QueryBestSize) (portPriv->screen,
                                            (Bool) motion, vid_w, vid_h, drw_w,
                                            drw_h, p_w, p_h,
                                            portPriv->DevPriv.ptr);

    return Success;
}

static int
KdXVPutImage(DrawablePtr pDraw,
             XvPortPtr pPort,
             GCPtr pGC,
             INT16 src_x, INT16 src_y,
             CARD16 src_w, CARD16 src_h,
             INT16 drw_x, INT16 drw_y,
             CARD16 drw_w, CARD16 drw_h,
             XvImagePtr format,
             unsigned char *data, Bool sync, CARD16 width, CARD16 height)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);
    ScreenPtr pScreen = pDraw->pScreen;

    KdScreenPriv(pScreen);
    RegionRec WinRegion;
    RegionRec ClipRegion;
    BoxRec WinBox;
    int ret = Success;
    Bool clippedAway = FALSE;

    if (pDraw->type != DRAWABLE_WINDOW)
        return BadAlloc;

    if (!pScreenPriv->enabled)
        return Success;

    WinBox.x1 = pDraw->x + drw_x;
    WinBox.y1 = pDraw->y + drw_y;
    WinBox.x2 = WinBox.x1 + drw_w;
    WinBox.y2 = WinBox.y1 + drw_h;

    RegionInit(&WinRegion, &WinBox, 1);
    RegionInit(&ClipRegion, NullBox, 1);
    RegionIntersect(&ClipRegion, &WinRegion, pGC->pCompositeClip);

    if (portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
        RegionRec VPReg;
        BoxRec VPBox;

        VPBox.x1 = 0;
        VPBox.y1 = 0;
        VPBox.x2 = pScreen->width;
        VPBox.y2 = pScreen->height;

        RegionInit(&VPReg, &VPBox, 1);
        RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
        RegionUninit(&VPReg);
    }

    if (portPriv->pDraw) {
        KdXVRemovePortFromWindow((WindowPtr) (portPriv->pDraw), portPriv);
    }

    if (!RegionNotEmpty(&ClipRegion)) {
        clippedAway = TRUE;
        goto PUT_IMAGE_BAILOUT;
    }

    ret = (*portPriv->AdaptorRec->PutImage) (portPriv->screen, pDraw,
                                             src_x, src_y, WinBox.x1, WinBox.y1,
                                             src_w, src_h, drw_w, drw_h,
                                             format->id, data, width, height,
                                             sync, &ClipRegion,
                                             portPriv->DevPriv.ptr);

    if ((ret == Success) &&
        (portPriv->AdaptorRec->flags & VIDEO_OVERLAID_IMAGES)) {

        KdXVEnlistPortInWindow((WindowPtr) pDraw, portPriv);
        portPriv->isOn = XV_ON;
        portPriv->pDraw = pDraw;
        portPriv->drw_x = drw_x;
        portPriv->drw_y = drw_y;
        portPriv->drw_w = drw_w;
        portPriv->drw_h = drw_h;
        portPriv->type = 0;     /* no mask means it's transient and should
                                   not be reput once it's removed */
        pPort->pDraw = pDraw;   /* make sure we can get stop requests */
    }

 PUT_IMAGE_BAILOUT:

    if ((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
        (*portPriv->AdaptorRec->StopVideo) (portPriv->screen,
                                            portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
    }

    RegionUninit(&WinRegion);
    RegionUninit(&ClipRegion);

    return ret;
}

static int
KdXVQueryImageAttributes(XvPortPtr pPort,
                         XvImagePtr format,
                         CARD16 *width,
                         CARD16 *height, int *pitches, int *offsets)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);

    return (*portPriv->AdaptorRec->QueryImageAttributes) (portPriv->screen,
                                                          format->id, width,
                                                          height, pitches,
                                                          offsets);
}

/****************  Common video manipulation functions *******************/

void
KdXVCopyPackedData(KdScreenInfo * screen, CARD8 *src, CARD8 *dst, int randr,
                   int srcPitch, int dstPitch, int srcW, int srcH, int top,
                   int left, int h, int w)
{
    int srcDown = srcPitch, srcRight = 2, srcNext;
    int p;

    switch (randr & RR_Rotate_All) {
    case RR_Rotate_0:
        srcDown = srcPitch;
        srcRight = 2;
        break;
    case RR_Rotate_90:
        src += (srcH - 1) * 2;
        srcDown = -2;
        srcRight = srcPitch;
        break;
    case RR_Rotate_180:
        src += srcPitch * (srcH - 1) + (srcW - 1) * 2;
        srcDown = -srcPitch;
        srcRight = -2;
        break;
    case RR_Rotate_270:
        src += srcPitch * (srcW - 1);
        srcDown = 2;
        srcRight = -srcPitch;
        break;
    }

    src = src + top * srcDown + left * srcRight;

    w >>= 1;
    /* srcRight >>= 1; */
    srcNext = srcRight >> 1;
    while (h--) {
        CARD16 *s = (CARD16 *) src;
        CARD32 *d = (CARD32 *) dst;

        p = w;
        while (p--) {
            *d++ = s[0] | (s[srcNext] << 16);
            s += srcRight;
        }
        src += srcPitch;
        dst += dstPitch;
    }
}

void
KdXVCopyPlanarData(KdScreenInfo * screen, CARD8 *src, CARD8 *dst, int randr,
                   int srcPitch, int srcPitch2, int dstPitch, int srcW,
                   int srcH, int height, int top, int left, int h, int w,
                   int id)
{
    int i, j;
    CARD8 *src1, *src2, *src3, *dst1;
    int srcDown = srcPitch, srcDown2 = srcPitch2;
    int srcRight = 2, srcRight2 = 1, srcNext = 1;

    /* compute source data pointers */
    src1 = src;
    src2 = src1 + height * srcPitch;
    src3 = src2 + (height >> 1) * srcPitch2;
    switch (randr & RR_Rotate_All) {
    case RR_Rotate_0:
        srcDown = srcPitch;
        srcDown2 = srcPitch2;
        srcRight = 2;
        srcRight2 = 1;
        srcNext = 1;
        break;
    case RR_Rotate_90:
        src1 = src1 + srcH - 1;
        src2 = src2 + (srcH >> 1) - 1;
        src3 = src3 + (srcH >> 1) - 1;
        srcDown = -1;
        srcDown2 = -1;
        srcRight = srcPitch * 2;
        srcRight2 = srcPitch2;
        srcNext = srcPitch;
        break;
    case RR_Rotate_180:
        src1 = src1 + srcPitch * (srcH - 1) + (srcW - 1);
        src2 = src2 + srcPitch2 * ((srcH >> 1) - 1) + ((srcW >> 1) - 1);
        src3 = src3 + srcPitch2 * ((srcH >> 1) - 1) + ((srcW >> 1) - 1);
        srcDown = -srcPitch;
        srcDown2 = -srcPitch2;
        srcRight = -2;
        srcRight2 = -1;
        srcNext = -1;
        break;
    case RR_Rotate_270:
        src1 = src1 + srcPitch * (srcW - 1);
        src2 = src2 + srcPitch2 * ((srcW >> 1) - 1);
        src3 = src3 + srcPitch2 * ((srcW >> 1) - 1);
        srcDown = 1;
        srcDown2 = 1;
        srcRight = -srcPitch * 2;
        srcRight2 = -srcPitch2;
        srcNext = -srcPitch;
        break;
    }

    /* adjust for origin */
    src1 += top * srcDown + left * srcNext;
    src2 += (top >> 1) * srcDown2 + (left >> 1) * srcRight2;
    src3 += (top >> 1) * srcDown2 + (left >> 1) * srcRight2;

    if (id == FOURCC_I420) {
        CARD8 *srct = src2;

        src2 = src3;
        src3 = srct;
    }

    dst1 = dst;

    w >>= 1;
    for (j = 0; j < h; j++) {
        CARD32 *dst32 = (CARD32 *) dst1;
        CARD8 *s1l = src1;
        CARD8 *s1r = src1 + srcNext;
        CARD8 *s2 = src2;
        CARD8 *s3 = src3;

        for (i = 0; i < w; i++) {
            *dst32++ = *s1l | (*s1r << 16) | (*s3 << 8) | (*s2 << 24);
            s1l += srcRight;
            s1r += srcRight;
            s2 += srcRight2;
            s3 += srcRight2;
        }
        src1 += srcDown;
        dst1 += dstPitch;
        if (j & 1) {
            src2 += srcDown2;
            src3 += srcDown2;
        }
    }
}
@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d330 2
a331 2
                        moreSpace = realloc(pFormat,
                                            totFormat * sizeof(XvFormatRec));
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a58 5
/* XvScreenRec fields */

static Bool KdXVCloseScreen(ScreenPtr);
static int KdXVQueryAdaptors(ScreenPtr, XvAdaptorPtr *, int *);

d61 1
a61 3
static int KdXVAllocatePort(unsigned long, XvPortPtr, XvPortPtr *);
static int KdXVFreePort(XvPortPtr);
static int KdXVPutVideo(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
d64 1
a64 1
static int KdXVPutStill(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
d67 1
a67 1
static int KdXVGetVideo(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
d70 1
a70 1
static int KdXVGetStill(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
d73 4
a76 4
static int KdXVStopVideo(ClientPtr, XvPortPtr, DrawablePtr);
static int KdXVSetPortAttribute(ClientPtr, XvPortPtr, Atom, INT32);
static int KdXVGetPortAttribute(ClientPtr, XvPortPtr, Atom, INT32 *);
static int KdXVQueryBestSize(ClientPtr, XvPortPtr, CARD8,
d79 1
a79 1
static int KdXVPutImage(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
d83 1
a83 1
static int KdXVQueryImageAttributes(ClientPtr, XvPortPtr, XvImagePtr,
a87 1
static Bool KdXVCreateWindow(WindowPtr pWin);
d89 1
a89 1
static void KdXVWindowExposures(WindowPtr pWin, RegionPtr r1, RegionPtr r2);
d91 1
d94 1
a94 1
static Bool KdXVInitAdaptors(ScreenPtr, KdVideoAdaptorPtr *, int);
d100 1
d108 1
a108 1
  	((KdXVScreenPtr)(GET_XV_SCREEN(pScreen)->devPriv.ptr))
a112 43
static KdXVInitGenericAdaptorPtr *GenDrivers = NULL;
static int NumGenDrivers = 0;

int
KdXVRegisterGenericAdaptorDriver(KdXVInitGenericAdaptorPtr InitFunc)
{
    KdXVInitGenericAdaptorPtr *newdrivers;

/*   fprintf(stderr,"KdXVRegisterGenericAdaptorDriver\n"); */

    newdrivers = realloc(GenDrivers, sizeof(KdXVInitGenericAdaptorPtr) *
                         (1 + NumGenDrivers));
    if (!newdrivers)
        return 0;
    GenDrivers = newdrivers;

    GenDrivers[NumGenDrivers++] = InitFunc;

    return 1;
}

int
KdXVListGenericAdaptors(KdScreenInfo * screen, KdVideoAdaptorPtr ** adaptors)
{
    int i, j, n, num;
    KdVideoAdaptorPtr *DrivAdap, *new;

    num = 0;
    *adaptors = NULL;
    for (i = 0; i < NumGenDrivers; i++) {
        n = GenDrivers[i] (screen, &DrivAdap);
        if (0 == n)
            continue;
        new = realloc(*adaptors, sizeof(KdVideoAdaptorPtr) * (num + n));
        if (NULL == new)
            continue;
        *adaptors = new;
        for (j = 0; j < n; j++, num++)
            (*adaptors)[num] = DrivAdap[j];
    }
    return num;
}

d126 1
a126 1
KdXVScreenInit(ScreenPtr pScreen, KdVideoAdaptorPtr * adaptors, int num)
a128 1
    XvScreenPtr pxvs;
d140 2
a148 13
    pxvs = GET_XV_SCREEN(pScreen);

    /* Anyone initializing the Xv layer must provide these two.
       The Xv di layer calls them without even checking if they exist! */

    pxvs->ddCloseScreen = KdXVCloseScreen;
    pxvs->ddQueryAdaptors = KdXVQueryAdaptors;

    /* The Xv di layer provides us with a private hook so that we don't
       have to allocate our own screen private.  They also provide
       a CloseScreen hook so that we don't have to wrap it.  I'm not
       sure that I appreciate that.  */

d150 1
a150 1
    pxvs->devPriv.ptr = (void *) ScreenPriv;
a154 1
    ScreenPriv->CreateWindow = pScreen->CreateWindow;
d158 1
a161 1
    pScreen->CreateWindow = KdXVCreateWindow;
d165 1
a177 13
    free(pAdaptor->name);

    if (pAdaptor->pEncodings) {
        XvEncodingPtr pEncode = pAdaptor->pEncodings;

        for (i = 0; i < pAdaptor->nEncodings; i++, pEncode++) {
            free(pEncode->name);
        }
        free(pAdaptor->pEncodings);
    }

    free(pAdaptor->pFormats);

a191 1
        free(pAdaptor->pPorts);
d194 1
a194 13
    if (pAdaptor->nAttributes) {
        XvAttributePtr pAttribute = pAdaptor->pAttributes;

        for (i = 0; i < pAdaptor->nAttributes; i++, pAttribute++) {
            free(pAttribute->name);
        }

        free(pAdaptor->pAttributes);
    }

    free(pAdaptor->pImages);

    free(pAdaptor->devPriv.ptr);
d198 1
a198 1
KdXVInitAdaptors(ScreenPtr pScreen, KdVideoAdaptorPtr * infoPtr, int number)
a210 2
    KdAttributePtr attributePtr;
    XvAttributePtr pAttribute, pat;
a215 2
    KdImagePtr imagePtr;
    XvImagePtr pImage, pi;
d227 1
a227 1
        adaptorPtr = infoPtr[na];
a260 2
        pa->ddAllocatePort = KdXVAllocatePort;
        pa->ddFreePort = KdXVFreePort;
d291 3
a293 6
            (pImage = calloc(adaptorPtr->nImages, sizeof(XvImageRec)))) {

            for (i = 0, pi = pImage, imagePtr = adaptorPtr->pImages;
                 i < adaptorPtr->nImages; i++, pi++, imagePtr++) {
                memcpy(pi, imagePtr, sizeof(*pi));
            }
a294 1
            pa->pImages = pImage;
d298 8
a305 6
            (pAttribute =
             calloc(adaptorPtr->nAttributes, sizeof(XvAttributeRec)))) {
            for (pat = pAttribute, attributePtr = adaptorPtr->pAttributes, i =
                 0; i < adaptorPtr->nAttributes; pat++, i++, attributePtr++) {
                memcpy(pat, attributePtr, sizeof(*pat));
                pat->name = strdup(attributePtr->name);
d307 1
a308 1
            pa->pAttributes = pAttribute;
d495 1
a495 1
    if ((pGC->clientClipType == CT_REGION) && pGC->clientClip) {
a544 4
    if (portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
        RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
    }

a620 16
    /* bailout if we have to clip but the hardware doesn't support it */
    if (portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
        BoxPtr clipBox = RegionRects(&ClipRegion);

        if ((RegionNumRects(&ClipRegion) != 1) ||
            (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
            (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2)) {
            clippedAway = TRUE;
            goto CLIP_VIDEO_BAILOUT;
        }
    }

    if (portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
        RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
    }

a696 16
    /* bailout if we have to clip but the hardware doesn't support it */
    if (portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
        BoxPtr clipBox = RegionRects(&ClipRegion);

        if ((RegionNumRects(&ClipRegion) != 1) ||
            (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
            (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2)) {
            clippedAway = TRUE;
            goto CLIP_VIDEO_BAILOUT;
        }
    }

    if (portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
        RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
    }

a792 17
KdXVCreateWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    KdXVScreenPtr ScreenPriv = GET_KDXV_SCREEN(pScreen);
    int ret;

    pScreen->CreateWindow = ScreenPriv->CreateWindow;
    ret = (*pScreen->CreateWindow) (pWin);
    pScreen->CreateWindow = KdXVCreateWindow;

    if (ret)
        dixSetPrivate(&pWin->devPrivates, KdXVWindowKey, NULL);

    return ret;
}

static Bool
d825 1
a825 1
KdXVWindowExposures(WindowPtr pWin, RegionPtr reg1, RegionPtr reg2)
d837 1
a837 1
    (*pScreen->WindowExposures) (pWin, reg1, reg2);
a955 1
    pScreen->CreateWindow = ScreenPriv->CreateWindow;
d959 1
d970 1
a970 13
    return TRUE;
}

static int
KdXVQueryAdaptors(ScreenPtr pScreen,
                  XvAdaptorPtr * p_pAdaptors, int *p_nAdaptors)
{
    XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);

    *p_nAdaptors = pxvs->nAdaptors;
    *p_pAdaptors = pxvs->pAdaptors;

    return Success;
d1031 1
a1031 15
KdXVAllocatePort(unsigned long port, XvPortPtr pPort, XvPortPtr * ppPort)
{
    *ppPort = pPort;
    return Success;
}

static int
KdXVFreePort(XvPortPtr pPort)
{
    return Success;
}

static int
KdXVPutVideo(ClientPtr client,
             DrawablePtr pDraw,
d1084 1
a1084 2
KdXVPutStill(ClientPtr client,
             DrawablePtr pDraw,
a1139 15
    if (portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
        BoxPtr clipBox = RegionRects(&ClipRegion);

        if ((RegionNumRects(&ClipRegion) != 1) ||
            (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
            (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2)) {
            clippedAway = TRUE;
            goto PUT_STILL_BAILOUT;
        }
    }

    if (portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
        RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
    }

d1176 1
a1176 2
KdXVGetVideo(ClientPtr client,
             DrawablePtr pDraw,
d1229 1
a1229 2
KdXVGetStill(ClientPtr client,
             DrawablePtr pDraw,
a1269 4
    if (portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
        RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
    }

d1291 1
a1291 1
KdXVStopVideo(ClientPtr client, XvPortPtr pPort, DrawablePtr pDraw)
d1317 1
a1317 2
KdXVSetPortAttribute(ClientPtr client,
                     XvPortPtr pPort, Atom attribute, INT32 value)
d1327 1
a1327 2
KdXVGetPortAttribute(ClientPtr client,
                     XvPortPtr pPort, Atom attribute, INT32 *p_value)
d1338 1
a1338 2
KdXVQueryBestSize(ClientPtr client,
                  XvPortPtr pPort,
d1355 1
a1355 2
KdXVPutImage(ClientPtr client,
             DrawablePtr pDraw,
a1412 15
    if (portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
        BoxPtr clipBox = RegionRects(&ClipRegion);

        if ((RegionNumRects(&ClipRegion) != 1) ||
            (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
            (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2)) {
            clippedAway = TRUE;
            goto PUT_IMAGE_BAILOUT;
        }
    }

    if (portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
        RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
    }

d1450 1
a1450 2
KdXVQueryImageAttributes(ClientPtr client,
                         XvPortPtr pPort,
a1604 41
}

void
KXVPaintRegion(DrawablePtr pDraw, RegionPtr pRgn, Pixel fg)
{
    GCPtr pGC;
    ChangeGCVal val[2];
    xRectangle *rects, *r;
    BoxPtr pBox = RegionRects(pRgn);
    int nBox = RegionNumRects(pRgn);

    rects = malloc(nBox * sizeof(xRectangle));
    if (!rects)
        goto bail0;
    r = rects;
    while (nBox--) {
        r->x = pBox->x1 - pDraw->x;
        r->y = pBox->y1 - pDraw->y;
        r->width = pBox->x2 - pBox->x1;
        r->height = pBox->y2 - pBox->y1;
        r++;
        pBox++;
    }

    pGC = GetScratchGC(pDraw->depth, pDraw->pScreen);
    if (!pGC)
        goto bail1;

    val[0].val = fg;
    val[1].val = IncludeInferiors;
    ChangeGC(NullClient, pGC, GCForeground | GCSubwindowMode, val);

    ValidateGC(pDraw, pGC);

    (*pGC->ops->PolyFillRect) (pDraw, pGC, RegionNumRects(pRgn), rects);

    FreeScratchGC(pGC);
 bail1:
    free(rects);
 bail0:
    ;
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d211 1
a211 1
    pxvs->devPriv.ptr = (pointer) ScreenPriv;
d388 1
a388 22
                pi->id = imagePtr->id;
                pi->type = imagePtr->type;
                pi->byte_order = imagePtr->byte_order;
                memcpy(pi->guid, imagePtr->guid, 16);
                pi->bits_per_pixel = imagePtr->bits_per_pixel;
                pi->format = imagePtr->format;
                pi->num_planes = imagePtr->num_planes;
                pi->depth = imagePtr->depth;
                pi->red_mask = imagePtr->red_mask;
                pi->green_mask = imagePtr->green_mask;
                pi->blue_mask = imagePtr->blue_mask;
                pi->y_sample_bits = imagePtr->y_sample_bits;
                pi->u_sample_bits = imagePtr->u_sample_bits;
                pi->v_sample_bits = imagePtr->v_sample_bits;
                pi->horz_y_period = imagePtr->horz_y_period;
                pi->horz_u_period = imagePtr->horz_u_period;
                pi->horz_v_period = imagePtr->horz_v_period;
                pi->vert_y_period = imagePtr->vert_y_period;
                pi->vert_u_period = imagePtr->vert_u_period;
                pi->vert_v_period = imagePtr->vert_v_period;
                memcpy(pi->component_order, imagePtr->component_order, 32);
                pi->scanline_order = imagePtr->scanline_order;
d399 1
a399 3
                pat->flags = attributePtr->flags;
                pat->min_value = attributePtr->min_value;
                pat->max_value = attributePtr->max_value;
d467 1
a467 1
        pa->devPriv.ptr = (pointer) adaptorPriv;
d854 1
a854 1
KdXVReputAllVideo(WindowPtr pWin, pointer data)
d1801 1
a1801 1
        CARD32 *dst = (CARD32 *) dst1;
d1808 1
a1808 1
            *dst++ = *s1l | (*s1r << 16) | (*s3 << 8) | (*s2 << 24);
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a1176 1
    KdXVScreenPtr ScreenPriv;
a1185 1
    ScreenPriv = GET_KDXV_SCREEN(pScreen);
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d61 1
a61 1
static Bool KdXVCloseScreen(int, ScreenPtr);
a109 4
DevPrivateKey (*XvGetScreenKeyProc) (void) = XvGetScreenKey;
unsigned long (*XvGetRTPortProc) (void) = XvGetRTPort;
int (*XvScreenInitProc) (ScreenPtr) = XvScreenInit;

d185 1
a185 1
    if (!XvGetScreenKeyProc || !XvGetRTPortProc || !XvScreenInitProc)
d191 1
a191 1
    if (Success != (*XvScreenInitProc) (pScreen))
d194 2
a195 2
    KdXvScreenKey = (*XvGetScreenKeyProc) ();
    PortResource = (*XvGetRTPortProc) ();
d1117 1
a1117 1
KdXVCloseScreen(int i, ScreenPtr pScreen)
@


1.6
log
@Update to xserver 1.11.2
@
text
@a58 1

d66 1
a66 1
static int KdXVAllocatePort(unsigned long, XvPortPtr, XvPortPtr*);
d68 12
a79 12
static int KdXVPutVideo(ClientPtr, DrawablePtr,XvPortPtr, GCPtr,
   				INT16, INT16, CARD16, CARD16,
				INT16, INT16, CARD16, CARD16);
static int KdXVPutStill(ClientPtr, DrawablePtr,XvPortPtr, GCPtr,
   				INT16, INT16, CARD16, CARD16,
				INT16, INT16, CARD16, CARD16);
static int KdXVGetVideo(ClientPtr, DrawablePtr,XvPortPtr, GCPtr,
   				INT16, INT16, CARD16, CARD16,
				INT16, INT16, CARD16, CARD16);
static int KdXVGetStill(ClientPtr, DrawablePtr,XvPortPtr, GCPtr,
   				INT16, INT16, CARD16, CARD16,
				INT16, INT16, CARD16, CARD16);
d84 2
a85 2
   				CARD16, CARD16,CARD16, CARD16,
				unsigned int*, unsigned int*);
d87 3
a89 4
   				INT16, INT16, CARD16, CARD16,
				INT16, INT16, CARD16, CARD16,
				XvImagePtr, unsigned char*, Bool,
				CARD16, CARD16);
d91 1
a91 2
				CARD16*, CARD16*, int*, int*);

d101 1
a101 1
static Bool KdXVInitAdaptors(ScreenPtr, KdVideoAdaptorPtr*, int);
d104 1
d110 3
a112 3
DevPrivateKey (*XvGetScreenKeyProc)(void) = XvGetScreenKey;
unsigned long (*XvGetRTPortProc)(void) = XvGetRTPort;
int (*XvScreenInitProc)(ScreenPtr) = XvScreenInit;
d127 3
a129 4
KdXVRegisterGenericAdaptorDriver(
    KdXVInitGenericAdaptorPtr InitFunc
){
  KdXVInitGenericAdaptorPtr *newdrivers;
d133 5
a137 5
  newdrivers = realloc(GenDrivers, sizeof(KdXVInitGenericAdaptorPtr) *
			(1 + NumGenDrivers));
  if (!newdrivers)
    return 0;
  GenDrivers = newdrivers;
d139 1
a139 1
  GenDrivers[NumGenDrivers++] = InitFunc;
d141 1
a141 1
  return 1;
d145 4
a148 6
KdXVListGenericAdaptors(
    KdScreenInfo *          screen,
    KdVideoAdaptorPtr **adaptors
){
    int i,j,n,num;
    KdVideoAdaptorPtr *DrivAdap,*new;
d153 9
a161 9
	n = GenDrivers[i](screen,&DrivAdap);
	if (0 == n)
	    continue;
	new = realloc(*adaptors, sizeof(KdVideoAdaptorPtr) * (num+n));
	if (NULL == new)
	    continue;
	*adaptors = new;
	for (j = 0; j < n; j++, num++)
	    (*adaptors)[num] = DrivAdap[j];
a177 1

d179 4
a182 7
KdXVScreenInit(
   ScreenPtr pScreen,
   KdVideoAdaptorPtr *adaptors,
   int num
){
  KdXVScreenPtr ScreenPriv;
  XvScreenPtr pxvs;
d186 2
a187 2
  if (KdXVGeneration != serverGeneration)
      KdXVGeneration = serverGeneration;
d189 2
a190 2
  if(!XvGetScreenKeyProc || !XvGetRTPortProc || !XvScreenInitProc)
	return FALSE;
d192 2
a193 2
  if (!dixRegisterPrivateKey(&KdXVWindowKeyRec, PRIVATE_WINDOW, 0))
      return FALSE;
d195 2
a196 1
  if(Success != (*XvScreenInitProc)(pScreen)) return FALSE;
d198 2
a199 4
  KdXvScreenKey = (*XvGetScreenKeyProc)();
  PortResource = (*XvGetRTPortProc)();

  pxvs = GET_XV_SCREEN(pScreen);
d201 1
d203 2
a204 2
  /* Anyone initializing the Xv layer must provide these two.
     The Xv di layer calls them without even checking if they exist! */
d206 2
a207 2
  pxvs->ddCloseScreen = KdXVCloseScreen;
  pxvs->ddQueryAdaptors = KdXVQueryAdaptors;
d209 15
a223 15
  /* The Xv di layer provides us with a private hook so that we don't
     have to allocate our own screen private.  They also provide
     a CloseScreen hook so that we don't have to wrap it.  I'm not
     sure that I appreciate that.  */

  ScreenPriv = malloc(sizeof(KdXVScreenRec));
  pxvs->devPriv.ptr = (pointer)ScreenPriv;

  if(!ScreenPriv) return FALSE;


  ScreenPriv->CreateWindow = pScreen->CreateWindow;
  ScreenPriv->DestroyWindow = pScreen->DestroyWindow;
  ScreenPriv->WindowExposures = pScreen->WindowExposures;
  ScreenPriv->ClipNotify = pScreen->ClipNotify;
d227 4
a230 4
  pScreen->CreateWindow = KdXVCreateWindow;
  pScreen->DestroyWindow = KdXVDestroyWindow;
  pScreen->WindowExposures = KdXVWindowExposures;
  pScreen->ClipNotify = KdXVClipNotify;
d232 2
a233 2
  if(!KdXVInitAdaptors(pScreen, adaptors, num))
	return FALSE;
d235 1
a235 1
  return TRUE;
d241 1
a241 1
   int i;
d243 1
a243 1
   free(pAdaptor->name);
d245 2
a246 2
   if(pAdaptor->pEncodings) {
      XvEncodingPtr pEncode = pAdaptor->pEncodings;
d248 5
a252 31
      for(i = 0; i < pAdaptor->nEncodings; i++, pEncode++) {
          free(pEncode->name);
      }
      free(pAdaptor->pEncodings);
   }

   free(pAdaptor->pFormats);

   if(pAdaptor->pPorts) {
      XvPortPtr pPort = pAdaptor->pPorts;
      XvPortRecPrivatePtr pPriv;

      for(i = 0; i < pAdaptor->nPorts; i++, pPort++) {
          pPriv = (XvPortRecPrivatePtr)pPort->devPriv.ptr;
	  if(pPriv) {
	     if(pPriv->clientClip)
		RegionDestroy(pPriv->clientClip);
             if(pPriv->pCompositeClip && pPriv->FreeCompositeClip)
		RegionDestroy(pPriv->pCompositeClip);
	     free(pPriv);
	  }
      }
      free(pAdaptor->pPorts);
   }

   if(pAdaptor->nAttributes) {
      XvAttributePtr pAttribute = pAdaptor->pAttributes;

      for(i = 0; i < pAdaptor->nAttributes; i++, pAttribute++) {
          free(pAttribute->name);
      }
d254 1
a254 2
      free(pAdaptor->pAttributes);
   }
d256 26
a281 1
   free(pAdaptor->pImages);
d283 3
a285 1
   free(pAdaptor->devPriv.ptr);
d289 2
a290 5
KdXVInitAdaptors(
   ScreenPtr pScreen,
   KdVideoAdaptorPtr *infoPtr,
   int number
) {
d292 242
a533 1
    KdScreenInfo * screen = pScreenPriv->screen;
d535 1
a535 258
  XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
  KdVideoAdaptorPtr adaptorPtr;
  XvAdaptorPtr pAdaptor, pa;
  XvAdaptorRecPrivatePtr adaptorPriv;
  int na, numAdaptor;
  XvPortRecPrivatePtr portPriv;
  XvPortPtr pPort, pp;
  int numPort;
  KdAttributePtr attributePtr;
  XvAttributePtr pAttribute, pat;
  KdVideoFormatPtr formatPtr;
  XvFormatPtr pFormat, pf;
  int numFormat, totFormat;
  KdVideoEncodingPtr encodingPtr;
  XvEncodingPtr pEncode, pe;
  KdImagePtr imagePtr;
  XvImagePtr pImage, pi;
  int numVisuals;
  VisualPtr pVisual;
  int i;

  pxvs->nAdaptors = 0;
  pxvs->pAdaptors = NULL;

  if(!(pAdaptor = calloc(number, sizeof(XvAdaptorRec))))
      return FALSE;

  for(pa = pAdaptor, na = 0, numAdaptor = 0; na < number; na++, adaptorPtr++) {
      adaptorPtr = infoPtr[na];

      if(!adaptorPtr->StopVideo || !adaptorPtr->SetPortAttribute ||
	 !adaptorPtr->GetPortAttribute || !adaptorPtr->QueryBestSize)
	   continue;

      /* client libs expect at least one encoding */
      if(!adaptorPtr->nEncodings || !adaptorPtr->pEncodings)
	   continue;

      pa->type = adaptorPtr->type;

      if(!adaptorPtr->PutVideo && !adaptorPtr->GetVideo)
	 pa->type &= ~XvVideoMask;

      if(!adaptorPtr->PutStill && !adaptorPtr->GetStill)
	 pa->type &= ~XvStillMask;

      if(!adaptorPtr->PutImage || !adaptorPtr->QueryImageAttributes)
	 pa->type &= ~XvImageMask;

      if(!adaptorPtr->PutVideo && !adaptorPtr->PutImage &&
							  !adaptorPtr->PutStill)
	 pa->type &= ~XvInputMask;

      if(!adaptorPtr->GetVideo && !adaptorPtr->GetStill)
	 pa->type &= ~XvOutputMask;

      if(!(adaptorPtr->type & (XvPixmapMask | XvWindowMask)))
	  continue;
      if(!(adaptorPtr->type & (XvImageMask | XvVideoMask | XvStillMask)))
	  continue;

      pa->pScreen = pScreen;
      pa->ddAllocatePort = KdXVAllocatePort;
      pa->ddFreePort = KdXVFreePort;
      pa->ddPutVideo = KdXVPutVideo;
      pa->ddPutStill = KdXVPutStill;
      pa->ddGetVideo = KdXVGetVideo;
      pa->ddGetStill = KdXVGetStill;
      pa->ddStopVideo = KdXVStopVideo;
      pa->ddPutImage = KdXVPutImage;
      pa->ddSetPortAttribute = KdXVSetPortAttribute;
      pa->ddGetPortAttribute = KdXVGetPortAttribute;
      pa->ddQueryBestSize = KdXVQueryBestSize;
      pa->ddQueryImageAttributes = KdXVQueryImageAttributes;
      pa->name = strdup(adaptorPtr->name);

      if(adaptorPtr->nEncodings &&
	(pEncode = calloc(adaptorPtr->nEncodings, sizeof(XvEncodingRec)))) {

	for(pe = pEncode, encodingPtr = adaptorPtr->pEncodings, i = 0;
	    i < adaptorPtr->nEncodings; pe++, i++, encodingPtr++)
        {
	    pe->id = encodingPtr->id;
	    pe->pScreen = pScreen;
	    pe->name = strdup(encodingPtr->name);
	    pe->width = encodingPtr->width;
	    pe->height = encodingPtr->height;
	    pe->rate.numerator = encodingPtr->rate.numerator;
	    pe->rate.denominator = encodingPtr->rate.denominator;
	}
	pa->nEncodings = adaptorPtr->nEncodings;
	pa->pEncodings = pEncode;
      }

      if(adaptorPtr->nImages &&
         (pImage = calloc(adaptorPtr->nImages, sizeof(XvImageRec)))) {

          for(i = 0, pi = pImage, imagePtr = adaptorPtr->pImages;
	      i < adaptorPtr->nImages; i++, pi++, imagePtr++)
  	  {
	     pi->id = imagePtr->id;
	     pi->type = imagePtr->type;
	     pi->byte_order = imagePtr->byte_order;
	     memcpy(pi->guid, imagePtr->guid, 16);
	     pi->bits_per_pixel = imagePtr->bits_per_pixel;
	     pi->format = imagePtr->format;
	     pi->num_planes = imagePtr->num_planes;
	     pi->depth = imagePtr->depth;
	     pi->red_mask = imagePtr->red_mask;
	     pi->green_mask = imagePtr->green_mask;
	     pi->blue_mask = imagePtr->blue_mask;
	     pi->y_sample_bits = imagePtr->y_sample_bits;
	     pi->u_sample_bits = imagePtr->u_sample_bits;
	     pi->v_sample_bits = imagePtr->v_sample_bits;
	     pi->horz_y_period = imagePtr->horz_y_period;
	     pi->horz_u_period = imagePtr->horz_u_period;
	     pi->horz_v_period = imagePtr->horz_v_period;
	     pi->vert_y_period = imagePtr->vert_y_period;
	     pi->vert_u_period = imagePtr->vert_u_period;
	     pi->vert_v_period = imagePtr->vert_v_period;
	     memcpy(pi->component_order, imagePtr->component_order, 32);
	     pi->scanline_order = imagePtr->scanline_order;
          }
	  pa->nImages = adaptorPtr->nImages;
	  pa->pImages = pImage;
      }

      if(adaptorPtr->nAttributes &&
	(pAttribute = calloc(adaptorPtr->nAttributes, sizeof(XvAttributeRec))))
      {
	for(pat = pAttribute, attributePtr = adaptorPtr->pAttributes, i = 0;
	    i < adaptorPtr->nAttributes; pat++, i++, attributePtr++)
        {
	    pat->flags = attributePtr->flags;
	    pat->min_value = attributePtr->min_value;
	    pat->max_value = attributePtr->max_value;
	    pat->name = strdup(attributePtr->name);
	}
	pa->nAttributes = adaptorPtr->nAttributes;
	pa->pAttributes = pAttribute;
      }


      totFormat = adaptorPtr->nFormats;

      if(!(pFormat = calloc(totFormat, sizeof(XvFormatRec)))) {
          KdXVFreeAdaptor(pa);
          continue;
      }
      for(pf = pFormat, i = 0, numFormat = 0, formatPtr = adaptorPtr->pFormats;
	  i < adaptorPtr->nFormats; i++, formatPtr++)
      {
	  numVisuals = pScreen->numVisuals;
          pVisual = pScreen->visuals;

          while(numVisuals--) {
              if((pVisual->class == formatPtr->class) &&
                 (pVisual->nplanes == formatPtr->depth)) {

		   if(numFormat >= totFormat) {
			void *moreSpace;
			totFormat *= 2;
			moreSpace = realloc(pFormat,
					     totFormat * sizeof(XvFormatRec));
			if(!moreSpace) break;
			pFormat = moreSpace;
			pf = pFormat + numFormat;
		   }

                   pf->visual = pVisual->vid;
		   pf->depth = formatPtr->depth;

		   pf++;
		   numFormat++;
              }
              pVisual++;
          }
      }
      pa->nFormats = numFormat;
      pa->pFormats = pFormat;
      if(!numFormat) {
          KdXVFreeAdaptor(pa);
          continue;
      }

      if(!(adaptorPriv = calloc(1, sizeof(XvAdaptorRecPrivate)))) {
          KdXVFreeAdaptor(pa);
          continue;
      }

      adaptorPriv->flags = adaptorPtr->flags;
      adaptorPriv->PutVideo = adaptorPtr->PutVideo;
      adaptorPriv->PutStill = adaptorPtr->PutStill;
      adaptorPriv->GetVideo = adaptorPtr->GetVideo;
      adaptorPriv->GetStill = adaptorPtr->GetStill;
      adaptorPriv->StopVideo = adaptorPtr->StopVideo;
      adaptorPriv->SetPortAttribute = adaptorPtr->SetPortAttribute;
      adaptorPriv->GetPortAttribute = adaptorPtr->GetPortAttribute;
      adaptorPriv->QueryBestSize = adaptorPtr->QueryBestSize;
      adaptorPriv->QueryImageAttributes = adaptorPtr->QueryImageAttributes;
      adaptorPriv->PutImage = adaptorPtr->PutImage;
      adaptorPriv->ReputImage = adaptorPtr->ReputImage;

      pa->devPriv.ptr = (pointer)adaptorPriv;

      if(!(pPort = calloc(adaptorPtr->nPorts, sizeof(XvPortRec)))) {
          KdXVFreeAdaptor(pa);
          continue;
      }
      for(pp = pPort, i = 0, numPort = 0;
	  i < adaptorPtr->nPorts; i++) {

          if(!(pp->id = FakeClientID(0)))
		continue;

	  if(!(portPriv = calloc(1, sizeof(XvPortRecPrivate))))
		continue;

	  if(!AddResource(pp->id, PortResource, pp)) {
		free(portPriv);
		continue;
	  }

          pp->pAdaptor = pa;
          pp->pNotify = (XvPortNotifyPtr)NULL;
          pp->pDraw = (DrawablePtr)NULL;
          pp->client = (ClientPtr)NULL;
          pp->grab.client = (ClientPtr)NULL;
          pp->time = currentTime;
          pp->devPriv.ptr = portPriv;

	  portPriv->screen = screen;
	  portPriv->AdaptorRec = adaptorPriv;
          portPriv->DevPriv.ptr = adaptorPtr->pPortPrivates[i].ptr;

          pp++;
          numPort++;
      }
      pa->nPorts = numPort;
      pa->pPorts = pPort;
      if(!numPort) {
          KdXVFreeAdaptor(pa);
          continue;
      }

      pa->base_id = pPort->id;

      pa++;
      numAdaptor++;
  }

  if(numAdaptor) {
      pxvs->nAdaptors = numAdaptor;
      pxvs->pAdaptors = pAdaptor;
  } else {
     free(pAdaptor);
     return FALSE;
  }
d537 14
a550 1
  return TRUE;
d572 36
a607 35
   RegionPtr	pregWin, pCompositeClip;
   WindowPtr	pWin;
   Bool 	freeCompClip = FALSE;

   if(portPriv->pCompositeClip)
	return;

   pWin = (WindowPtr)portPriv->pDraw;

   /* get window clip list */
   if(portPriv->subWindowMode == IncludeInferiors) {
	pregWin = NotClippedByChildren(pWin);
	freeCompClip = TRUE;
   } else
	pregWin = &pWin->clipList;

   if(!portPriv->clientClip) {
	portPriv->pCompositeClip = pregWin;
	portPriv->FreeCompositeClip = freeCompClip;
	return;
   }

   pCompositeClip = RegionCreate(NullBox, 1);
   RegionCopy(pCompositeClip, portPriv->clientClip);
   RegionTranslate(pCompositeClip,
			portPriv->pDraw->x + portPriv->clipOrg.x,
			portPriv->pDraw->y + portPriv->clipOrg.y);
   RegionIntersect(pCompositeClip, pregWin, pCompositeClip);

   portPriv->pCompositeClip = pCompositeClip;
   portPriv->FreeCompositeClip = TRUE;

   if(freeCompClip) {
	RegionDestroy(pregWin);
   }
d614 2
a615 4
KdXVCopyClip(
   XvPortRecPrivatePtr portPriv,
   GCPtr pGC
){
d617 9
a625 8
    if((pGC->clientClipType == CT_REGION) && pGC->clientClip) {
	if(!portPriv->clientClip)
	    portPriv->clientClip = RegionCreate(NullBox, 1);
	/* Note: this is in window coordinates */
	RegionCopy(portPriv->clientClip, pGC->clientClip);
    } else if(portPriv->clientClip) { /* free the old clientClip */
	RegionDestroy(portPriv->clientClip);
	portPriv->clientClip = NULL;
d629 2
a630 2
    if(portPriv->pCompositeClip && portPriv->FreeCompositeClip) {
	RegionDestroy(portPriv->pCompositeClip);
d642 28
a669 50
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  int ret = Success;
  Bool clippedAway = FALSE;

  KdXVUpdateCompositeClip(portPriv);

  /* translate the video region to the screen */
  WinBox.x1 = portPriv->pDraw->x + portPriv->drw_x;
  WinBox.y1 = portPriv->pDraw->y + portPriv->drw_y;
  WinBox.x2 = WinBox.x1 + portPriv->drw_w;
  WinBox.y2 = WinBox.y1 + portPriv->drw_h;

  /* clip to the window composite clip */
  RegionInit(&WinRegion, &WinBox, 1);
  RegionInit(&ClipRegion, NullBox, 1);
  RegionIntersect(&ClipRegion, &WinRegion, portPriv->pCompositeClip);

  /* that's all if it's totally obscured */
  if(!RegionNotEmpty(&ClipRegion)) {
	clippedAway = TRUE;
	goto CLIP_VIDEO_BAILOUT;
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->GetVideo)(portPriv->screen, portPriv->pDraw,
			portPriv->vid_x, portPriv->vid_y,
			WinBox.x1, WinBox.y1,
			portPriv->vid_w, portPriv->vid_h,
			portPriv->drw_w, portPriv->drw_h,
			&ClipRegion, portPriv->DevPriv.ptr);

  if(ret == Success)
	portPriv->isOn = XV_ON;

CLIP_VIDEO_BAILOUT:

  if((clippedAway || (ret != Success)) && portPriv->isOn == XV_ON) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->screen, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
  }

  /* This clip was copied and only good for one shot */
  if(!portPriv->FreeCompositeClip)
     portPriv->pCompositeClip = NULL;
d671 22
a692 2
  RegionUninit(&WinRegion);
  RegionUninit(&ClipRegion);
d694 4
a697 1
  return ret;
a699 1

d703 78
a780 79
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  ScreenPtr pScreen = portPriv->pDraw->pScreen;
  KdScreenPriv(pScreen);
  KdScreenInfo *screen=pScreenPriv->screen;
  int ret = Success;
  Bool clippedAway = FALSE;

  KdXVUpdateCompositeClip(portPriv);

  /* translate the video region to the screen */
  WinBox.x1 = portPriv->pDraw->x + portPriv->drw_x;
  WinBox.y1 = portPriv->pDraw->y + portPriv->drw_y;
  WinBox.x2 = WinBox.x1 + portPriv->drw_w;
  WinBox.y2 = WinBox.y1 + portPriv->drw_h;

  /* clip to the window composite clip */
  RegionInit(&WinRegion, &WinBox, 1);
  RegionInit(&ClipRegion, NullBox, 1);
  RegionIntersect(&ClipRegion, &WinRegion, portPriv->pCompositeClip);

  /* clip and translate to the viewport */
  if(portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
     RegionRec VPReg;
     BoxRec VPBox;

     VPBox.x1 = 0;
     VPBox.y1 = 0;
     VPBox.x2 = screen->width;
     VPBox.y2 = screen->height;

     RegionInit(&VPReg, &VPBox, 1);
     RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
     RegionUninit(&VPReg);
  }

  /* that's all if it's totally obscured */
  if(!RegionNotEmpty(&ClipRegion)) {
	clippedAway = TRUE;
	goto CLIP_VIDEO_BAILOUT;
  }

  /* bailout if we have to clip but the hardware doesn't support it */
  if(portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
     BoxPtr clipBox = RegionRects(&ClipRegion);
     if(  (RegionNumRects(&ClipRegion) != 1) ||
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
     {
	    clippedAway = TRUE;
	    goto CLIP_VIDEO_BAILOUT;
     }
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->PutVideo)(portPriv->screen, portPriv->pDraw,
			portPriv->vid_x, portPriv->vid_y,
			WinBox.x1, WinBox.y1,
			portPriv->vid_w, portPriv->vid_h,
			portPriv->drw_w, portPriv->drw_h,
			&ClipRegion, portPriv->DevPriv.ptr);

  if(ret == Success) portPriv->isOn = XV_ON;

CLIP_VIDEO_BAILOUT:

  if((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->screen, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
  }

  /* This clip was copied and only good for one shot */
  if(!portPriv->FreeCompositeClip)
     portPriv->pCompositeClip = NULL;
d782 3
a784 2
  RegionUninit(&WinRegion);
  RegionUninit(&ClipRegion);
d786 4
a789 1
  return ret;
d795 4
a798 76
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  ScreenPtr pScreen = portPriv->pDraw->pScreen;
  KdScreenPriv(pScreen);
  KdScreenInfo *screen=pScreenPriv->screen;
  int ret = Success;
  Bool clippedAway = FALSE;

  KdXVUpdateCompositeClip(portPriv);

  /* translate the video region to the screen */
  WinBox.x1 = portPriv->pDraw->x + portPriv->drw_x;
  WinBox.y1 = portPriv->pDraw->y + portPriv->drw_y;
  WinBox.x2 = WinBox.x1 + portPriv->drw_w;
  WinBox.y2 = WinBox.y1 + portPriv->drw_h;

  /* clip to the window composite clip */
  RegionInit(&WinRegion, &WinBox, 1);
  RegionInit(&ClipRegion, NullBox, 1);
  RegionIntersect(&ClipRegion, &WinRegion, portPriv->pCompositeClip);

  /* clip and translate to the viewport */
  if(portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
     RegionRec VPReg;
     BoxRec VPBox;

     VPBox.x1 = 0;
     VPBox.y1 = 0;
     VPBox.x2 = screen->width;
     VPBox.y2 = screen->height;

     RegionInit(&VPReg, &VPBox, 1);
     RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
     RegionUninit(&VPReg);
  }

  /* that's all if it's totally obscured */
  if(!RegionNotEmpty(&ClipRegion)) {
	clippedAway = TRUE;
	goto CLIP_VIDEO_BAILOUT;
  }

  /* bailout if we have to clip but the hardware doesn't support it */
  if(portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
     BoxPtr clipBox = RegionRects(&ClipRegion);
     if(  (RegionNumRects(&ClipRegion) != 1) ||
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
     {
	    clippedAway = TRUE;
	    goto CLIP_VIDEO_BAILOUT;
     }
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->ReputImage)(portPriv->screen, portPriv->pDraw,
			WinBox.x1, WinBox.y1,
			&ClipRegion, portPriv->DevPriv.ptr);

  portPriv->isOn = (ret == Success) ? XV_ON : XV_OFF;

CLIP_VIDEO_BAILOUT:

  if((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->screen, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
  }

  /* This clip was copied and only good for one shot */
  if(!portPriv->FreeCompositeClip)
     portPriv->pCompositeClip = NULL;
d800 38
a837 2
  RegionUninit(&WinRegion);
  RegionUninit(&ClipRegion);
d839 39
a877 1
  return ret;
a879 1

d886 1
a886 1
	return WT_DONTWALKCHILDREN;
d890 6
a895 6
    while(WinPriv) {
	if(WinPriv->PortRec->type == XvInputMask)
	    KdXVReputVideo(WinPriv->PortRec);
	else
	    KdXVRegetVideo(WinPriv->PortRec);
	WinPriv = WinPriv->next;
d904 1
a904 1
   KdXVWindowPtr winPriv, PrivRoot;
d906 1
a906 1
   winPriv = PrivRoot = GET_KDXV_WINDOW(pWin);
d908 16
a923 15
  /* Enlist our port in the window private */
   while(winPriv) {
	if(winPriv->PortRec == portPriv) /* we're already listed */
	    break;
	winPriv = winPriv->next;
   }

   if(!winPriv) {
	winPriv = malloc(sizeof(KdXVWindowRec));
	if(!winPriv) return BadAlloc;
	winPriv->PortRec = portPriv;
	winPriv->next = PrivRoot;
	dixSetPrivate(&pWin->devPrivates, KdXVWindowKey, winPriv);
   }
   return Success;
a925 1

d929 1
a929 1
     KdXVWindowPtr winPriv, prevPriv = NULL;
d931 1
a931 1
     winPriv = GET_KDXV_WINDOW(pWin);
d933 13
a945 13
     while(winPriv) {
	if(winPriv->PortRec == portPriv) {
	    if(prevPriv)
		prevPriv->next = winPriv->next;
	    else
		dixSetPrivate(&pWin->devPrivates, KdXVWindowKey, winPriv->next);
	    free(winPriv);
	    break;
	}
	prevPriv = winPriv;
	winPriv = winPriv->next;
     }
     portPriv->pDraw = NULL;
a949 1

d953 7
a959 7
  ScreenPtr pScreen = pWin->drawable.pScreen;
  KdXVScreenPtr ScreenPriv = GET_KDXV_SCREEN(pScreen);
  int ret;

  pScreen->CreateWindow = ScreenPriv->CreateWindow;
  ret = (*pScreen->CreateWindow)(pWin);
  pScreen->CreateWindow = KdXVCreateWindow;
d961 2
a962 2
  if (ret)
      dixSetPrivate(&pWin->devPrivates, KdXVWindowKey, NULL);
d964 1
a964 1
  return ret;
a966 1

d970 21
a990 25
  ScreenPtr pScreen = pWin->drawable.pScreen;
  KdXVScreenPtr ScreenPriv = GET_KDXV_SCREEN(pScreen);
  KdXVWindowPtr tmp, WinPriv = GET_KDXV_WINDOW(pWin);
  int ret;

  while(WinPriv) {
     XvPortRecPrivatePtr pPriv = WinPriv->PortRec;

     if(pPriv->isOn > XV_OFF) {
	(*pPriv->AdaptorRec->StopVideo)(
			pPriv->screen, pPriv->DevPriv.ptr, TRUE);
	pPriv->isOn = XV_OFF;
     }

     pPriv->pDraw = NULL;
     tmp = WinPriv;
     WinPriv = WinPriv->next;
     free(tmp);
  }

  dixSetPrivate(&pWin->devPrivates, KdXVWindowKey, NULL);

  pScreen->DestroyWindow = ScreenPriv->DestroyWindow;
  ret = (*pScreen->DestroyWindow)(pWin);
  pScreen->DestroyWindow = KdXVDestroyWindow;
d992 5
a996 1
  return ret;
a998 1

d1002 59
a1060 57
  ScreenPtr pScreen = pWin->drawable.pScreen;
  KdXVScreenPtr ScreenPriv = GET_KDXV_SCREEN(pScreen);
  KdXVWindowPtr WinPriv = GET_KDXV_WINDOW(pWin);
  KdXVWindowPtr pPrev;
  XvPortRecPrivatePtr pPriv;
  Bool AreasExposed;

  AreasExposed = (WinPriv && reg1 && RegionNotEmpty(reg1));

  pScreen->WindowExposures = ScreenPriv->WindowExposures;
  (*pScreen->WindowExposures)(pWin, reg1, reg2);
  pScreen->WindowExposures = KdXVWindowExposures;

  /* filter out XClearWindow/Area */
  if (!pWin->valdata) return;

  pPrev = NULL;

  while(WinPriv) {
     pPriv = WinPriv->PortRec;

     /* Reput anyone with a reput function */

     switch(pPriv->type) {
     case XvInputMask:
	KdXVReputVideo(pPriv);
	break;
     case XvOutputMask:
	KdXVRegetVideo(pPriv);
	break;
     default:  /* overlaid still/image*/
	if (pPriv->AdaptorRec->ReputImage)
	   KdXVReputImage(pPriv);
	else if(AreasExposed) {
	    KdXVWindowPtr tmp;

	    if (pPriv->isOn == XV_ON) {
		(*pPriv->AdaptorRec->StopVideo)(
		    pPriv->screen, pPriv->DevPriv.ptr, FALSE);
		pPriv->isOn = XV_PENDING;
	    }
	    pPriv->pDraw = NULL;

	    if(!pPrev)
		dixSetPrivate(&pWin->devPrivates, KdXVWindowKey, WinPriv->next);
	    else
	       pPrev->next = WinPriv->next;
	    tmp = WinPriv;
	    WinPriv = WinPriv->next;
	    free(tmp);
	    continue;
	}
	break;
     }
     pPrev = WinPriv;
     WinPriv = WinPriv->next;
  }
a1062 1

d1066 40
a1105 50
  ScreenPtr pScreen = pWin->drawable.pScreen;
  KdXVScreenPtr ScreenPriv = GET_KDXV_SCREEN(pScreen);
  KdXVWindowPtr WinPriv = GET_KDXV_WINDOW(pWin);
  KdXVWindowPtr tmp, pPrev = NULL;
  XvPortRecPrivatePtr pPriv;
  Bool visible = (pWin->visibility == VisibilityUnobscured) ||
		 (pWin->visibility == VisibilityPartiallyObscured);

  while(WinPriv) {
     pPriv = WinPriv->PortRec;

     if(pPriv->pCompositeClip && pPriv->FreeCompositeClip)
	RegionDestroy(pPriv->pCompositeClip);

     pPriv->pCompositeClip = NULL;

     /* Stop everything except images, but stop them too if the
	window isn't visible.  But we only remove the images. */

     if(pPriv->type || !visible) {
	if(pPriv->isOn == XV_ON) {
	    (*pPriv->AdaptorRec->StopVideo)(
			pPriv->screen, pPriv->DevPriv.ptr, FALSE);
	    pPriv->isOn = XV_PENDING;
	}

	if(!pPriv->type) {  /* overlaid still/image */
	    pPriv->pDraw = NULL;

	    if(!pPrev)
		dixSetPrivate(&pWin->devPrivates, KdXVWindowKey, WinPriv->next);
	    else
	       pPrev->next = WinPriv->next;
	    tmp = WinPriv;
	    WinPriv = WinPriv->next;
	    free(tmp);
	    continue;
	}
     }

     pPrev = WinPriv;
     WinPriv = WinPriv->next;
  }

  if(ScreenPriv->ClipNotify) {
      pScreen->ClipNotify = ScreenPriv->ClipNotify;
      (*pScreen->ClipNotify)(pWin, dx, dy);
      pScreen->ClipNotify = KdXVClipNotify;
  }
}
d1107 3
d1111 6
d1123 12
a1134 11
  XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
  KdXVScreenPtr ScreenPriv = GET_KDXV_SCREEN(pScreen);
  XvAdaptorPtr pa;
  int c;

  if(!ScreenPriv) return TRUE;

  pScreen->CreateWindow = ScreenPriv->CreateWindow;
  pScreen->DestroyWindow = ScreenPriv->DestroyWindow;
  pScreen->WindowExposures = ScreenPriv->WindowExposures;
  pScreen->ClipNotify = ScreenPriv->ClipNotify;
d1138 3
a1140 3
  for(c = 0, pa = pxvs->pAdaptors; c < pxvs->nAdaptors; c++, pa++) {
       KdXVFreeAdaptor(pa);
  }
d1142 2
a1143 2
  free(pxvs->pAdaptors);
  free(ScreenPriv);
d1145 1
a1145 1
  return TRUE;
a1147 1

d1149 4
a1152 6
KdXVQueryAdaptors(
   ScreenPtr pScreen,
   XvAdaptorPtr *p_pAdaptors,
   int *p_nAdaptors
){
  XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
d1154 2
a1155 2
  *p_nAdaptors = pxvs->nAdaptors;
  *p_pAdaptors = pxvs->pAdaptors;
d1157 1
a1157 1
  return Success;
d1161 1
a1161 1
KdXVRunning (ScreenPtr pScreen)
d1163 1
a1163 2
    return (KdXVGeneration == serverGeneration &&
	    GET_XV_SCREEN(pScreen) != 0);
d1169 2
a1170 2
    if (!KdXVRunning (pScreen))
	return TRUE;
d1187 2
a1188 2
    if (!KdXVRunning (pScreen))
	return;
d1193 21
a1213 21
    for(i = 0; i < pxvs->nAdaptors; i++) {
	pAdaptor = &pxvs->pAdaptors[i];
	for(j = 0; j < pAdaptor->nPorts; j++) {
	    pPort = &pAdaptor->pPorts[j];
	    pPriv = (XvPortRecPrivatePtr)pPort->devPriv.ptr;
	    if(pPriv->isOn > XV_OFF) {

		(*pPriv->AdaptorRec->StopVideo)(
			pPriv->screen, pPriv->DevPriv.ptr, TRUE);
		pPriv->isOn = XV_OFF;

		if(pPriv->pCompositeClip && pPriv->FreeCompositeClip)
		    RegionDestroy(pPriv->pCompositeClip);

		pPriv->pCompositeClip = NULL;

		if(!pPriv->type && pPriv->pDraw) { /* still */
		    KdXVRemovePortFromWindow((WindowPtr)pPriv->pDraw, pPriv);
		}
	    }
	}
d1220 4
a1223 7
KdXVAllocatePort(
   unsigned long port,
   XvPortPtr pPort,
   XvPortPtr *ppPort
){
  *ppPort = pPort;
  return Success;
d1229 1
a1229 1
  return Success;
d1233 43
a1275 39
KdXVPutVideo(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  KdScreenPriv(portPriv->screen->pScreen);
  int result;

  /* No dumping video to pixmaps... For now anyhow */
  if(pDraw->type != DRAWABLE_WINDOW) {
      pPort->pDraw = (DrawablePtr)NULL;
      return BadAlloc;
  }

  /* If we are changing windows, unregister our port in the old window */
  if(portPriv->pDraw && (portPriv->pDraw != pDraw))
     KdXVRemovePortFromWindow((WindowPtr)(portPriv->pDraw), portPriv);

  /* Register our port with the new window */
  result =  KdXVEnlistPortInWindow((WindowPtr)pDraw, portPriv);
  if(result != Success) return result;

  portPriv->pDraw = pDraw;
  portPriv->type = XvInputMask;

  /* save a copy of these parameters */
  portPriv->vid_x = vid_x;  portPriv->vid_y = vid_y;
  portPriv->vid_w = vid_w;  portPriv->vid_h = vid_h;
  portPriv->drw_x = drw_x;  portPriv->drw_y = drw_y;
  portPriv->drw_w = drw_w;  portPriv->drw_h = drw_h;

  /* make sure we have the most recent copy of the clientClip */
  KdXVCopyClip(portPriv, pGC);
d1277 2
a1278 2
  /* To indicate to the DI layer that we were successful */
  pPort->pDraw = pDraw;
d1280 2
a1281 1
  if (!pScreenPriv->enabled) return Success;
d1283 1
a1283 1
  return(KdXVReputVideo(portPriv));
d1287 98
a1384 95
KdXVPutStill(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  ScreenPtr pScreen = pDraw->pScreen;
  KdScreenPriv(pScreen);
  KdScreenInfo *screen=pScreenPriv->screen;
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  int ret = Success;
  Bool clippedAway = FALSE;

  if (pDraw->type != DRAWABLE_WINDOW)
      return BadAlloc;

  if (!pScreenPriv->enabled) return Success;

  WinBox.x1 = pDraw->x + drw_x;
  WinBox.y1 = pDraw->y + drw_y;
  WinBox.x2 = WinBox.x1 + drw_w;
  WinBox.y2 = WinBox.y1 + drw_h;

  RegionInit(&WinRegion, &WinBox, 1);
  RegionInit(&ClipRegion, NullBox, 1);
  RegionIntersect(&ClipRegion, &WinRegion, pGC->pCompositeClip);

  if(portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
     RegionRec VPReg;
     BoxRec VPBox;

     VPBox.x1 = 0;
     VPBox.y1 = 0;
     VPBox.x2 = screen->width;
     VPBox.y2 = screen->height;

     RegionInit(&VPReg, &VPBox, 1);
     RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
     RegionUninit(&VPReg);
  }

  if(portPriv->pDraw) {
     KdXVRemovePortFromWindow((WindowPtr)(portPriv->pDraw), portPriv);
  }

  if(!RegionNotEmpty(&ClipRegion)) {
     clippedAway = TRUE;
     goto PUT_STILL_BAILOUT;
  }

  if(portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
     BoxPtr clipBox = RegionRects(&ClipRegion);
     if(  (RegionNumRects(&ClipRegion) != 1) ||
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
     {
	  clippedAway = TRUE;
          goto PUT_STILL_BAILOUT;
     }
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->PutStill)(portPriv->screen, pDraw,
		vid_x, vid_y, WinBox.x1, WinBox.y1,
		vid_w, vid_h, drw_w, drw_h,
		&ClipRegion, portPriv->DevPriv.ptr);

  if((ret == Success) &&
	(portPriv->AdaptorRec->flags & VIDEO_OVERLAID_STILLS)) {

     KdXVEnlistPortInWindow((WindowPtr)pDraw, portPriv);
     portPriv->isOn = XV_ON;
     portPriv->pDraw = pDraw;
     portPriv->drw_x = drw_x;  portPriv->drw_y = drw_y;
     portPriv->drw_w = drw_w;  portPriv->drw_h = drw_h;
     portPriv->type = 0;  /* no mask means it's transient and should
			     not be reput once it's removed */
     pPort->pDraw = pDraw;  /* make sure we can get stop requests */
  }

PUT_STILL_BAILOUT:

  if((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
        (*portPriv->AdaptorRec->StopVideo)(
                portPriv->screen, portPriv->DevPriv.ptr, FALSE);
d1386 1
a1386 1
  }
d1388 2
a1389 2
  RegionUninit(&WinRegion);
  RegionUninit(&ClipRegion);
d1391 1
a1391 1
  return ret;
d1395 43
a1437 39
KdXVGetVideo(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  int result;
  KdScreenPriv(portPriv->screen->pScreen);

  /* No pixmaps... For now anyhow */
  if(pDraw->type != DRAWABLE_WINDOW) {
      pPort->pDraw = (DrawablePtr)NULL;
      return BadAlloc;
  }

  /* If we are changing windows, unregister our port in the old window */
  if(portPriv->pDraw && (portPriv->pDraw != pDraw))
     KdXVRemovePortFromWindow((WindowPtr)(portPriv->pDraw), portPriv);

  /* Register our port with the new window */
  result =  KdXVEnlistPortInWindow((WindowPtr)pDraw, portPriv);
  if(result != Success) return result;

  portPriv->pDraw = pDraw;
  portPriv->type = XvOutputMask;

  /* save a copy of these parameters */
  portPriv->vid_x = vid_x;  portPriv->vid_y = vid_y;
  portPriv->vid_w = vid_w;  portPriv->vid_h = vid_h;
  portPriv->drw_x = drw_x;  portPriv->drw_y = drw_y;
  portPriv->drw_w = drw_w;  portPriv->drw_h = drw_h;

  /* make sure we have the most recent copy of the clientClip */
  KdXVCopyClip(portPriv, pGC);
d1439 2
a1440 2
  /* To indicate to the DI layer that we were successful */
  pPort->pDraw = pDraw;
d1442 2
a1443 1
  if(!pScreenPriv->enabled) return Success;
d1445 1
a1445 1
  return(KdXVRegetVideo(portPriv));
d1449 57
a1505 56
KdXVGetStill(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  ScreenPtr pScreen = pDraw->pScreen;
  KdScreenPriv(pScreen);
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  int ret = Success;
  Bool clippedAway = FALSE;

  if (pDraw->type != DRAWABLE_WINDOW)
      return BadAlloc;

  if(!pScreenPriv->enabled) return Success;

  WinBox.x1 = pDraw->x + drw_x;
  WinBox.y1 = pDraw->y + drw_y;
  WinBox.x2 = WinBox.x1 + drw_w;
  WinBox.y2 = WinBox.y1 + drw_h;

  RegionInit(&WinRegion, &WinBox, 1);
  RegionInit(&ClipRegion, NullBox, 1);
  RegionIntersect(&ClipRegion, &WinRegion, pGC->pCompositeClip);

  if(portPriv->pDraw) {
     KdXVRemovePortFromWindow((WindowPtr)(portPriv->pDraw), portPriv);
  }

  if(!RegionNotEmpty(&ClipRegion)) {
     clippedAway = TRUE;
     goto GET_STILL_BAILOUT;
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->GetStill)(portPriv->screen, pDraw,
		vid_x, vid_y, WinBox.x1, WinBox.y1,
		vid_w, vid_h, drw_w, drw_h,
		&ClipRegion, portPriv->DevPriv.ptr);

GET_STILL_BAILOUT:

  if((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
        (*portPriv->AdaptorRec->StopVideo)(
                portPriv->screen, portPriv->DevPriv.ptr, FALSE);
d1507 1
a1507 1
  }
d1509 2
a1510 2
  RegionUninit(&WinRegion);
  RegionUninit(&ClipRegion);
d1512 1
a1512 1
  return ret;
d1515 6
d1522 18
d1542 4
a1545 22
KdXVStopVideo(
   ClientPtr client,
   XvPortPtr pPort,
   DrawablePtr pDraw
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  KdScreenPriv(portPriv->screen->pScreen);

  if(pDraw->type != DRAWABLE_WINDOW)
      return BadAlloc;

  KdXVRemovePortFromWindow((WindowPtr)pDraw, portPriv);

  if(!pScreenPriv->enabled) return Success;

  /* Must free resources. */

  if(portPriv->isOn > XV_OFF) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->screen, portPriv->DevPriv.ptr, TRUE);
	portPriv->isOn = XV_OFF;
  }
d1547 3
a1549 1
  return Success;
d1553 4
a1556 7
KdXVSetPortAttribute(
   ClientPtr client,
   XvPortPtr pPort,
   Atom attribute,
   INT32 value
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
d1558 4
a1561 2
  return((*portPriv->AdaptorRec->SetPortAttribute)(portPriv->screen,
		attribute, value, portPriv->DevPriv.ptr));
a1563 1

d1565 13
a1577 7
KdXVGetPortAttribute(
   ClientPtr client,
   XvPortPtr pPort,
   Atom attribute,
   INT32 *p_value
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
d1579 1
a1579 2
  return((*portPriv->AdaptorRec->GetPortAttribute)(portPriv->screen,
		attribute, (int *) p_value, portPriv->DevPriv.ptr));
d1582 50
d1633 3
d1637 4
a1640 14
static int
KdXVQueryBestSize(
   ClientPtr client,
   XvPortPtr pPort,
   CARD8 motion,
   CARD16 vid_w, CARD16 vid_h,
   CARD16 drw_w, CARD16 drw_h,
   unsigned int *p_w, unsigned int *p_h
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);

  (*portPriv->AdaptorRec->QueryBestSize)(portPriv->screen,
		(Bool)motion, vid_w, vid_h, drw_w, drw_h,
		p_w, p_h, portPriv->DevPriv.ptr);
d1642 2
a1643 2
  return Success;
}
d1645 7
d1653 3
a1655 101
static int
KdXVPutImage(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 src_x, INT16 src_y,
   CARD16 src_w, CARD16 src_h,
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h,
   XvImagePtr format,
   unsigned char* data,
   Bool sync,
   CARD16 width, CARD16 height
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  ScreenPtr pScreen = pDraw->pScreen;
  KdScreenPriv(pScreen);
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  int ret = Success;
  Bool clippedAway = FALSE;

  if (pDraw->type != DRAWABLE_WINDOW)
      return BadAlloc;

  if(!pScreenPriv->enabled) return Success;

  WinBox.x1 = pDraw->x + drw_x;
  WinBox.y1 = pDraw->y + drw_y;
  WinBox.x2 = WinBox.x1 + drw_w;
  WinBox.y2 = WinBox.y1 + drw_h;

  RegionInit(&WinRegion, &WinBox, 1);
  RegionInit(&ClipRegion, NullBox, 1);
  RegionIntersect(&ClipRegion, &WinRegion, pGC->pCompositeClip);

  if(portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
     RegionRec VPReg;
     BoxRec VPBox;

     VPBox.x1 = 0;
     VPBox.y1 = 0;
     VPBox.x2 = pScreen->width;
     VPBox.y2 = pScreen->height;

     RegionInit(&VPReg, &VPBox, 1);
     RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
     RegionUninit(&VPReg);
  }

  if(portPriv->pDraw) {
     KdXVRemovePortFromWindow((WindowPtr)(portPriv->pDraw), portPriv);
  }

  if(!RegionNotEmpty(&ClipRegion)) {
     clippedAway = TRUE;
     goto PUT_IMAGE_BAILOUT;
  }

  if(portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
     BoxPtr clipBox = RegionRects(&ClipRegion);
     if(  (RegionNumRects(&ClipRegion) != 1) ||
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
     {
	  clippedAway = TRUE;
          goto PUT_IMAGE_BAILOUT;
     }
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->PutImage)(portPriv->screen, pDraw,
		src_x, src_y, WinBox.x1, WinBox.y1,
		src_w, src_h, drw_w, drw_h, format->id, data, width, height,
		sync, &ClipRegion, portPriv->DevPriv.ptr);

  if((ret == Success) &&
	(portPriv->AdaptorRec->flags & VIDEO_OVERLAID_IMAGES)) {

     KdXVEnlistPortInWindow((WindowPtr)pDraw, portPriv);
     portPriv->isOn = XV_ON;
     portPriv->pDraw = pDraw;
     portPriv->drw_x = drw_x;  portPriv->drw_y = drw_y;
     portPriv->drw_w = drw_w;  portPriv->drw_h = drw_h;
     portPriv->type = 0;  /* no mask means it's transient and should
			     not be reput once it's removed */
     pPort->pDraw = pDraw;  /* make sure we can get stop requests */
  }

PUT_IMAGE_BAILOUT:

  if((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
        (*portPriv->AdaptorRec->StopVideo)(
                portPriv->screen, portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
  }
d1657 21
a1677 2
  RegionUninit(&WinRegion);
  RegionUninit(&ClipRegion);
d1679 1
a1679 2
  return ret;
}
d1681 5
d1687 2
a1688 11
static  int
KdXVQueryImageAttributes(
   ClientPtr client,
   XvPortPtr pPort,
   XvImagePtr format,
   CARD16 *width,
   CARD16 *height,
   int *pitches,
   int *offsets
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
d1690 1
a1690 2
  return (*portPriv->AdaptorRec->QueryImageAttributes)(portPriv->screen,
			format->id, width, height, pitches, offsets);
d1693 14
d1711 3
a1713 3
KdXVCopyPackedData(KdScreenInfo *screen, CARD8 *src, CARD8 *dst, int randr,
    int srcPitch, int dstPitch, int srcW, int srcH, int top, int left,
    int h, int w)
d1720 3
a1722 3
	srcDown = srcPitch;
	srcRight = 2;
	break;
d1724 4
a1727 4
	src += (srcH - 1) * 2;
	srcDown = -2;
	srcRight = srcPitch;
	break;
d1729 4
a1732 4
	src += srcPitch * (srcH - 1) + (srcW - 1) * 2;
	srcDown = -srcPitch;
	srcRight = -2;
	break;
d1734 4
a1737 4
	src += srcPitch * (srcW - 1);
	srcDown = 2;
	srcRight = -srcPitch;
	break;
d1746 10
a1755 9
	CARD16 *s = (CARD16 *)src;
	CARD32 *d = (CARD32 *)dst;
	p = w;
	while (p--) {
	    *d++ = s[0] | (s[srcNext] << 16);
	    s += srcRight;
	}
	src += srcPitch;
	dst += dstPitch;
d1760 4
a1763 3
KdXVCopyPlanarData(KdScreenInfo *screen, CARD8 *src, CARD8 *dst, int randr,
    int srcPitch, int srcPitch2, int dstPitch, int srcW, int srcH, int height,
    int top, int left, int h, int w, int id)
d1776 6
a1781 6
	srcDown = srcPitch;
	srcDown2 = srcPitch2;
	srcRight = 2;
	srcRight2 = 1;
	srcNext = 1;
	break;
d1783 9
a1791 9
	src1 = src1 + srcH - 1;
	src2 = src2 + (srcH >> 1) - 1;
	src3 = src3 + (srcH >> 1) - 1;
	srcDown = -1;
	srcDown2 = -1;
	srcRight = srcPitch * 2;
	srcRight2 = srcPitch2;
	srcNext = srcPitch;
	break;
d1793 9
a1801 9
	src1 = src1 + srcPitch * (srcH - 1) + (srcW - 1);
	src2 = src2 + srcPitch2 * ((srcH >> 1) - 1) + ((srcW >> 1) - 1);
	src3 = src3 + srcPitch2 * ((srcH >> 1) - 1) + ((srcW >> 1) - 1);
	srcDown = -srcPitch;
	srcDown2 = -srcPitch2;
	srcRight = -2;
	srcRight2 = -1;
	srcNext = -1;
	break;
d1803 9
a1811 9
	src1 = src1 + srcPitch * (srcW - 1);
	src2 = src2 + srcPitch2 * ((srcW >> 1) - 1);
	src3 = src3 + srcPitch2 * ((srcW >> 1) - 1);
	srcDown = 1;
	srcDown2 = 1;
	srcRight = -srcPitch * 2;
	srcRight2 = -srcPitch2;
	srcNext = -srcPitch;
	break;
d1820 4
a1823 3
	CARD8 *srct = src2;
	src2 = src3;
	src3 = srct;
d1830 19
a1848 19
	CARD32 *dst = (CARD32 *)dst1;
	CARD8 *s1l = src1;
	CARD8 *s1r = src1 + srcNext;
	CARD8 *s2 = src2;
	CARD8 *s3 = src3;

	for (i = 0; i < w; i++) {
	    *dst++ = *s1l | (*s1r << 16) | (*s3 << 8) | (*s2 << 24);
	    s1l += srcRight;
	    s1r += srcRight;
	    s2 += srcRight2;
	    s3 += srcRight2;
	}
	src1 += srcDown;
	dst1 += dstPitch;
	if (j & 1) {
	    src2 += srcDown2;
	    src3 += srcDown2;
	}
d1853 1
a1853 1
KXVPaintRegion (DrawablePtr pDraw, RegionPtr pRgn, Pixel fg)
d1855 5
a1859 5
    GCPtr	pGC;
    ChangeGCVal	val[2];
    xRectangle	*rects, *r;
    BoxPtr	pBox = RegionRects (pRgn);
    int		nBox = RegionNumRects (pRgn);
d1861 1
a1861 1
    rects = malloc(nBox * sizeof (xRectangle));
d1863 1
a1863 1
	goto bail0;
d1865 7
a1871 8
    while (nBox--)
    {
	r->x = pBox->x1 - pDraw->x;
	r->y = pBox->y1 - pDraw->y;
	r->width = pBox->x2 - pBox->x1;
	r->height = pBox->y2 - pBox->y1;
	r++;
	pBox++;
d1874 1
a1874 1
    pGC = GetScratchGC (pDraw->depth, pDraw->pScreen);
d1876 1
a1876 1
	goto bail1;
d1880 1
a1880 1
    ChangeGC (NullClient, pGC, GCForeground|GCSubwindowMode, val);
d1882 1
a1882 1
    ValidateGC (pDraw, pGC);
d1884 1
a1884 2
    (*pGC->ops->PolyFillRect) (pDraw, pGC,
			       RegionNumRects (pRgn), rects);
d1886 2
a1887 2
    FreeScratchGC (pGC);
bail1:
d1889 1
a1889 1
bail0:
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d380 1
a380 2
      if((pa->name = malloc(strlen(adaptorPtr->name) + 1)))
          strcpy(pa->name, adaptorPtr->name);
d390 1
a390 2
	    if((pe->name = malloc(strlen(encodingPtr->name) + 1)))
                strcpy(pe->name, encodingPtr->name);
d442 1
a442 2
	    if((pat->name = malloc(strlen(attributePtr->name) + 1)))
                strcpy(pat->name, attributePtr->name);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d106 3
a108 4
static int KdXVWindowKeyIndex;
DevPrivateKey KdXVWindowKey = &KdXVWindowKeyIndex;
static int KdXvScreenKeyIndex;
DevPrivateKey KdXvScreenKey = &KdXvScreenKeyIndex;
d136 1
a136 1
  newdrivers = xrealloc(GenDrivers, sizeof(KdXVInitGenericAdaptorPtr) *
d161 1
a161 1
	new = xrealloc(*adaptors, sizeof(KdVideoAdaptorPtr) * (num+n));
d174 1
a174 1
    return xcalloc(1, sizeof(KdVideoAdaptorRec));
d180 1
a180 1
    xfree(ptr);
d201 3
d223 1
a223 1
  ScreenPriv = xalloc(sizeof(KdXVScreenRec));
d252 1
a252 1
   xfree(pAdaptor->name);
d258 1
a258 1
          xfree(pEncode->name);
d260 1
a260 1
      xfree(pAdaptor->pEncodings);
d263 1
a263 1
   xfree(pAdaptor->pFormats);
d273 1
a273 1
		REGION_DESTROY(pAdaptor->pScreen, pPriv->clientClip);
d275 2
a276 2
		REGION_DESTROY(pAdaptor->pScreen, pPriv->pCompositeClip);
	     xfree(pPriv);
d279 1
a279 1
      xfree(pAdaptor->pPorts);
d286 1
a286 1
          xfree(pAttribute->name);
d289 1
a289 1
      xfree(pAdaptor->pAttributes);
d292 1
a292 1
   xfree(pAdaptor->pImages);
d294 1
a294 1
   xfree(pAdaptor->devPriv.ptr);
d330 1
a330 1
  if(!(pAdaptor = xcalloc(number, sizeof(XvAdaptorRec))))
d380 1
a380 1
      if((pa->name = xalloc(strlen(adaptorPtr->name) + 1)))
d384 1
a384 1
	(pEncode = xcalloc(adaptorPtr->nEncodings, sizeof(XvEncodingRec)))) {
d391 1
a391 1
	    if((pe->name = xalloc(strlen(encodingPtr->name) + 1)))
d403 1
a403 1
         (pImage = xcalloc(adaptorPtr->nImages, sizeof(XvImageRec)))) {
d436 1
a436 1
	(pAttribute = xcalloc(adaptorPtr->nAttributes, sizeof(XvAttributeRec))))
d444 1
a444 1
	    if((pat->name = xalloc(strlen(attributePtr->name) + 1)))
d454 1
a454 1
      if(!(pFormat = xcalloc(totFormat, sizeof(XvFormatRec)))) {
d471 1
a471 1
			moreSpace = xrealloc(pFormat,
d494 1
a494 1
      if(!(adaptorPriv = xcalloc(1, sizeof(XvAdaptorRecPrivate)))) {
d514 1
a514 1
      if(!(pPort = xcalloc(adaptorPtr->nPorts, sizeof(XvPortRec)))) {
d524 1
a524 1
	  if(!(portPriv = xcalloc(1, sizeof(XvPortRecPrivate))))
d528 1
a528 1
		xfree(portPriv);
d564 1
a564 1
     xfree(pAdaptor);
d612 3
a614 3
   pCompositeClip = REGION_CREATE(pWin->pScreen, NullBox, 1);
   REGION_COPY(pWin->pScreen, pCompositeClip, portPriv->clientClip);
   REGION_TRANSLATE(pWin->pScreen, pCompositeClip,
d617 1
a617 1
   REGION_INTERSECT(pWin->pScreen, pCompositeClip, pregWin, pCompositeClip);
d623 1
a623 1
   	REGION_DESTROY(pWin->pScreen, pregWin);
d638 1
a638 1
	    portPriv->clientClip = REGION_CREATE(pGC->pScreen, NullBox, 1);
d640 1
a640 1
	REGION_COPY(pGC->pScreen, portPriv->clientClip, pGC->clientClip);
d642 1
a642 1
	REGION_DESTROY(pGC->pScreen, portPriv->clientClip);
d648 1
a648 1
	REGION_DESTROY(pWin->pScreen, portPriv->pCompositeClip);
d675 3
a677 3
  REGION_INIT(portPriv->pDraw->pScreen, &WinRegion, &WinBox, 1);
  REGION_INIT(portPriv->pDraw->pScreen, &ClipRegion, NullBox, 1);
  REGION_INTERSECT(portPriv->pDraw->pScreen, &ClipRegion, &WinRegion, portPriv->pCompositeClip);
d680 1
a680 1
  if(!REGION_NOTEMPTY(portPriv->pDraw->pScreen, &ClipRegion)) {
d686 1
a686 1
     REGION_SUBTRACT(portPriv->pDraw->pScreen, &ClipRegion, &WinRegion, &ClipRegion);
d711 2
a712 2
  REGION_UNINIT(portPriv->pDraw->pScreen, &WinRegion);
  REGION_UNINIT(portPriv->pDraw->pScreen, &ClipRegion);
d739 3
a741 3
  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_INIT(pScreen, &ClipRegion, NullBox, 1);
  REGION_INTERSECT(Screen, &ClipRegion, &WinRegion, portPriv->pCompositeClip);
d753 3
a755 3
     REGION_INIT(pScreen, &VPReg, &VPBox, 1);
     REGION_INTERSECT(Screen, &ClipRegion, &ClipRegion, &VPReg);
     REGION_UNINIT(pScreen, &VPReg);
d759 1
a759 1
  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
d766 2
a767 2
     BoxPtr clipBox = REGION_RECTS(&ClipRegion);
     if(  (REGION_NUM_RECTS(&ClipRegion) != 1) ||
d777 1
a777 1
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
d801 2
a802 2
  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);
d828 3
a830 3
  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_INIT(pScreen, &ClipRegion, NullBox, 1);
  REGION_INTERSECT(Screen, &ClipRegion, &WinRegion, portPriv->pCompositeClip);
d842 3
a844 3
     REGION_INIT(pScreen, &VPReg, &VPBox, 1);
     REGION_INTERSECT(Screen, &ClipRegion, &ClipRegion, &VPReg);
     REGION_UNINIT(pScreen, &VPReg);
d848 1
a848 1
  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
d855 2
a856 2
     BoxPtr clipBox = REGION_RECTS(&ClipRegion);
     if(  (REGION_NUM_RECTS(&ClipRegion) != 1) ||
d866 1
a866 1
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
d887 2
a888 2
  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);
d930 1
a930 1
	winPriv = xalloc(sizeof(KdXVWindowRec));
d953 1
a953 1
	    xfree(winPriv);
d1003 1
a1003 1
     xfree(tmp);
d1026 1
a1026 1
  AreasExposed = (WinPriv && reg1 && REGION_NOTEMPTY(pScreen, reg1));
d1068 1
a1068 1
	    xfree(tmp);
d1094 1
a1094 1
	REGION_DESTROY(pScreen, pPriv->pCompositeClip);
d1117 1
a1117 1
	    xfree(tmp);
d1158 2
a1159 2
  xfree(pxvs->pAdaptors);
  xfree(ScreenPriv);
d1176 1
a1176 1
  return (Success);
d1225 1
a1225 1
		    REGION_DESTROY(pScreen, pPriv->pCompositeClip);
d1335 3
a1337 3
  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_INIT(pScreen, &ClipRegion, NullBox, 1);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);
d1348 3
a1350 3
     REGION_INIT(pScreen, &VPReg, &VPBox, 1);
     REGION_INTERSECT(Screen, &ClipRegion, &ClipRegion, &VPReg);
     REGION_UNINIT(pScreen, &VPReg);
d1357 1
a1357 1
  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
d1363 2
a1364 2
     BoxPtr clipBox = REGION_RECTS(&ClipRegion);
     if(  (REGION_NUM_RECTS(&ClipRegion) != 1) ||
d1374 1
a1374 1
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
d1403 2
a1404 2
  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);
d1488 3
a1490 3
  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_INIT(pScreen, &ClipRegion, NullBox, 1);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);
d1496 1
a1496 1
  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
d1502 1
a1502 1
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
d1518 2
a1519 2
  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);
d1635 3
a1637 3
  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_INIT(pScreen, &ClipRegion, NullBox, 1);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);
d1648 3
a1650 3
     REGION_INIT(pScreen, &VPReg, &VPBox, 1);
     REGION_INTERSECT(Screen, &ClipRegion, &ClipRegion, &VPReg);
     REGION_UNINIT(pScreen, &VPReg);
d1657 1
a1657 1
  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
d1663 2
a1664 2
     BoxPtr clipBox = REGION_RECTS(&ClipRegion);
     if(  (REGION_NUM_RECTS(&ClipRegion) != 1) ||
d1674 1
a1674 1
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
d1703 2
a1704 2
  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);
d1872 1
a1872 1
    CARD32    	val[2];
d1874 2
a1875 2
    BoxPtr	pBox = REGION_RECTS (pRgn);
    int		nBox = REGION_NUM_RECTS (pRgn);
d1877 1
a1877 1
    rects = xalloc (nBox * sizeof (xRectangle));
d1895 3
a1897 3
    val[0] = fg;
    val[1] = IncludeInferiors;
    ChangeGC (pGC, GCForeground|GCSubwindowMode, val);
d1902 1
a1902 1
			       REGION_NUM_RECTS (pRgn), rects);
d1906 1
a1906 1
    xfree (rects);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d1 1
a1 1
/* 
d3 1
a3 1
   XFree86 Xv DDX written by Mark Vojkovich (markv@@valinux.com) 
d70 1
a70 1
   				INT16, INT16, CARD16, CARD16, 
d73 1
a73 1
   				INT16, INT16, CARD16, CARD16, 
d76 1
a76 1
   				INT16, INT16, CARD16, CARD16, 
d79 1
a79 1
   				INT16, INT16, CARD16, CARD16, 
d85 1
a85 1
   				CARD16, CARD16,CARD16, CARD16, 
d88 1
a88 1
   				INT16, INT16, CARD16, CARD16, 
d92 1
a92 1
static int KdXVQueryImageAttributes(ClientPtr, XvPortPtr, XvImagePtr, 
d137 1
a137 1
  newdrivers = xrealloc(GenDrivers, sizeof(KdXVInitGenericAdaptorPtr) * 
d142 1
a142 1
  
d187 1
a187 1
   ScreenPtr pScreen, 
d200 1
a200 1
	return FALSE;  
d250 1
a250 2
   if(pAdaptor->name)
      xfree(pAdaptor->name);
d256 1
a256 1
          if(pEncode->name) xfree(pEncode->name);
d261 1
a261 2
   if(pAdaptor->pFormats) 
      xfree(pAdaptor->pFormats);
d270 1
a270 1
	     if(pPriv->clientClip) 
d272 1
a272 1
             if(pPriv->pCompositeClip && pPriv->FreeCompositeClip) 
d284 1
a284 1
          if(pAttribute->name) xfree(pAttribute->name);
d290 3
a292 5
   if(pAdaptor->nImages)
      xfree(pAdaptor->pImages);
	
   if(pAdaptor->devPriv.ptr)
      xfree(pAdaptor->devPriv.ptr);
d297 1
a297 1
   ScreenPtr pScreen, 
d328 1
a328 1
  if(!(pAdaptor = xcalloc(number, sizeof(XvAdaptorRec)))) 
d342 1
a342 1
      pa->type = adaptorPtr->type; 
d353 1
a353 1
      if(!adaptorPtr->PutVideo && !adaptorPtr->PutImage && 
d359 2
a360 2
	 
      if(!(adaptorPtr->type & (XvPixmapMask | XvWindowMask))) 
d362 1
a362 1
      if(!(adaptorPtr->type & (XvImageMask | XvVideoMask | XvStillMask))) 
d365 1
a365 1
      pa->pScreen = pScreen; 
d384 2
a385 2
	for(pe = pEncode, encodingPtr = adaptorPtr->pEncodings, i = 0; 
	    i < adaptorPtr->nEncodings; pe++, i++, encodingPtr++) 
d397 2
a398 2
	pa->pEncodings = pEncode;  
      } 
d404 1
a404 1
	      i < adaptorPtr->nImages; i++, pi++, imagePtr++) 
d436 2
a437 2
	for(pat = pAttribute, attributePtr = adaptorPtr->pAttributes, i = 0; 
	    i < adaptorPtr->nAttributes; pat++, i++, attributePtr++) 
d446 2
a447 2
	pa->pAttributes = pAttribute;  
      } 
d456 2
a457 2
      for(pf = pFormat, i = 0, numFormat = 0, formatPtr = adaptorPtr->pFormats; 
	  i < adaptorPtr->nFormats; i++, formatPtr++) 
d467 1
a467 1
			void *moreSpace; 
d469 1
a469 1
			moreSpace = xrealloc(pFormat, 
d476 1
a476 1
                   pf->visual = pVisual->vid; 
d483 1
a483 1
          }	
d486 1
a486 1
      pa->pFormats = pFormat;  
d516 1
a516 1
      for(pp = pPort, i = 0, numPort = 0; 
d519 1
a519 1
          if(!(pp->id = FakeClientID(0))) 
d522 1
a522 1
	  if(!(portPriv = xcalloc(1, sizeof(XvPortRecPrivate)))) 
d524 1
a524 1
	  
d541 1
a541 1
	
d553 1
a553 1
      
d579 1
a579 1
   the video.  I like the new method better (MArk). 
d585 1
a585 1
static void  
d622 1
a622 1
   }    
d630 1
a630 1
   XvPortRecPrivatePtr portPriv, 
d671 1
a671 1
  
d675 2
a676 2
  REGION_INTERSECT(portPriv->pDraw->pScreen, &ClipRegion, &WinRegion, portPriv->pCompositeClip); 
  
d688 4
a691 4
			portPriv->vid_x, portPriv->vid_y, 
			WinBox.x1, WinBox.y1, 
			portPriv->vid_w, portPriv->vid_h, 
			portPriv->drw_w, portPriv->drw_h, 
d735 1
a735 1
  
d739 1
a739 1
  REGION_INTERSECT(Screen, &ClipRegion, &WinRegion, portPriv->pCompositeClip); 
d752 1
a752 1
     REGION_INTERSECT(Screen, &ClipRegion, &ClipRegion, &VPReg); 
d755 1
a755 1
  
d766 2
a767 2
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) || 
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2)) 
d779 1
a779 1
			portPriv->vid_x, portPriv->vid_y, 
d781 2
a782 2
			portPriv->vid_w, portPriv->vid_h, 
			portPriv->drw_w, portPriv->drw_h, 
d824 1
a824 1
  
d828 1
a828 1
  REGION_INTERSECT(Screen, &ClipRegion, &WinRegion, portPriv->pCompositeClip); 
d841 1
a841 1
     REGION_INTERSECT(Screen, &ClipRegion, &ClipRegion, &VPReg); 
d844 1
a844 1
  
d855 2
a856 2
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) || 
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2)) 
d896 1
a896 1
    
d899 1
a899 1
    
d916 1
a916 1
   KdXVWindowPtr winPriv, PrivRoot;    
d933 1
a933 1
   }   
d947 1
a947 1
	    if(prevPriv) 
d949 1
a949 1
	    else 
d954 1
a954 1
	prevPriv = winPriv; 
d1032 1
a1032 1
   
d1043 1
a1043 1
	break;	     
d1045 2
a1046 2
	KdXVRegetVideo(pPriv);	
	break;     
d1060 1
a1060 1
	    if(!pPrev) 
d1077 1
a1077 1
static void 
d1096 1
a1096 1
     /* Stop everything except images, but stop them too if the 
d1109 1
a1109 1
	    if(!pPrev) 
d1152 1
a1152 1
  for(c = 0, pa = pxvs->pAdaptors; c < pxvs->nAdaptors; c++, pa++) { 
d1156 1
a1156 3
  if(pxvs->pAdaptors)
    xfree(pxvs->pAdaptors);

a1158 1

d1189 3
a1191 3
    
    WalkTree(pScreen, KdXVReputAllVideo, 0); 
 
d1210 1
a1210 1
    
d1259 2
a1260 2
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
d1273 1
a1273 1
  
d1298 1
a1298 1
  
d1308 2
a1309 2
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
d1314 1
a1314 1
  ScreenPtr pScreen = pDraw->pScreen;  
d1332 1
a1332 1
  
d1335 1
a1335 1
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);   
d1347 1
a1347 1
     REGION_INTERSECT(Screen, &ClipRegion, &ClipRegion, &VPReg); 
d1363 1
a1363 1
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) || 
d1413 2
a1414 2
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
d1427 1
a1427 1
  
d1450 1
a1450 1
  
d1462 2
a1463 2
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
d1485 1
a1485 1
  
d1488 1
a1488 1
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);   
d1522 1
a1522 1
 
d1535 1
a1535 1
  
d1559 2
a1560 2
     
  return((*portPriv->AdaptorRec->SetPortAttribute)(portPriv->screen, 
d1573 2
a1574 2
     
  return((*portPriv->AdaptorRec->GetPortAttribute)(portPriv->screen, 
d1590 2
a1591 2
     
  (*portPriv->AdaptorRec->QueryBestSize)(portPriv->screen, 
d1599 1
a1599 1
static int 
d1601 3
a1603 3
   ClientPtr client, 
   DrawablePtr pDraw, 
   XvPortPtr pPort, 
d1605 2
a1606 2
   INT16 src_x, INT16 src_y, 
   CARD16 src_w, CARD16 src_h, 
d1632 1
a1632 1
  
d1635 1
a1635 1
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);   
d1647 1
a1647 1
     REGION_INTERSECT(Screen, &ClipRegion, &ClipRegion, &VPReg); 
d1663 1
a1663 1
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) || 
d1708 1
a1708 1
static  int 
d1710 1
a1710 1
   ClientPtr client, 
d1712 3
a1714 3
   XvImagePtr format, 
   CARD16 *width, 
   CARD16 *height, 
d1720 1
a1720 1
  return (*portPriv->AdaptorRec->QueryImageAttributes)(portPriv->screen, 
d1874 1
a1874 1
    
d1888 1
a1888 1
    
d1892 1
a1892 1
    
d1896 1
a1896 1
    
d1898 2
a1899 2
    
    (*pGC->ops->PolyFillRect) (pDraw, pGC, 
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d106 4
a109 3

DevPrivateKey KdXVWindowKey = &KdXVWindowKey;
DevPrivateKey KdXvScreenKey = &KdXvScreenKey;
a1730 41

/****************  Offscreen surface stuff *******************/

typedef struct {
   KdOffscreenImagePtr images;
   int num;
} OffscreenImageRec;

static OffscreenImageRec OffscreenImages[MAXSCREENS];
static Bool offscreenInited = FALSE;

Bool 
KdXVRegisterOffscreenImages(
    ScreenPtr pScreen,
    KdOffscreenImagePtr images,
    int num
){
    if(!offscreenInited) {
	bzero(OffscreenImages, sizeof(OffscreenImages[MAXSCREENS]));
	offscreenInited = TRUE;
    }
  
    OffscreenImages[pScreen->myNum].num = num;
    OffscreenImages[pScreen->myNum].images = images;

    return TRUE;
}

KdOffscreenImagePtr
KdXVQueryOffscreenImages(
   ScreenPtr pScreen,
   int *num
){
   if(!offscreenInited) {
	*num = 0;
	return NULL;
   }

   *num = OffscreenImages[pScreen->myNum].num;
   return OffscreenImages[pScreen->myNum].images;
}
@


1.1
log
@Initial revision
@
text
@a37 2
/* $RCSId: xc/programs/Xserver/hw/kdrive/kxv.c,v 1.3 2001/08/09 09:08:54 keithp Exp $ */

d107 2
a108 2
int KdXVWindowIndex = -1;
int KdXvScreenIndex = -1;
d112 1
a112 1
int (*XvGetScreenIndexProc)(void) = XvGetScreenIndex;
d116 2
a117 2
#define GET_XV_SCREEN(pScreen) \
	((XvScreenPtr)((pScreen)->devPrivates[KdXvScreenIndex].ptr))
d122 2
a123 2
#define GET_KDXV_WINDOW(pWin) \
	((KdXVWindowPtr)((pWin)->devPrivates[KdXVWindowIndex].ptr))
d195 2
a196 8
  if(KdXVGeneration != serverGeneration) {
	if((KdXVWindowIndex = AllocateWindowPrivateIndex()) < 0)
	    return FALSE;
	KdXVGeneration = serverGeneration;
  }

  if(!AllocateWindowPrivate(pScreen,KdXVWindowIndex,0))
        return FALSE;
d198 1
a198 1
  if(!XvGetScreenIndexProc || !XvGetRTPortProc || !XvScreenInitProc)
d203 1
a203 1
  KdXvScreenIndex = (*XvGetScreenIndexProc)();
d935 1
a935 1
	pWin->devPrivates[KdXVWindowIndex].ptr = (pointer)winPriv;
d953 1
a953 2
		pWin->devPrivates[KdXVWindowIndex].ptr = 
					(pointer)winPriv->next;
d977 2
a978 1
  if(ret) pWin->devPrivates[KdXVWindowIndex].ptr = NULL;
d1007 1
a1007 1
  pWin->devPrivates[KdXVWindowIndex].ptr = NULL;
d1064 1
a1064 2
	       pWin->devPrivates[KdXVWindowIndex].ptr = 		
						(pointer)(WinPriv->next);
d1113 1
a1113 2
	       pWin->devPrivates[KdXVWindowIndex].ptr = 		
						(pointer)(WinPriv->next);
d1922 1
a1922 1
    rects = ALLOCATE_LOCAL (nBox * sizeof (xRectangle));
d1951 1
a1951 1
    DEALLOCATE_LOCAL (rects);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d38 2
@

