head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.8
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.6
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.57;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.57;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.04.13;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright Â© 1999 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <kdrive-config.h>
#endif
#include "kdrive.h"

/*
 * Put the entire colormap into the DAC
 */

void
KdSetColormap(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    ColormapPtr pCmap = pScreenPriv->pInstalledmap;
    Pixel pixels[KD_MAX_PSEUDO_SIZE];
    xrgb colors[KD_MAX_PSEUDO_SIZE];
    xColorItem defs[KD_MAX_PSEUDO_SIZE];
    int i;

    if (!pScreenPriv->card->cfuncs->putColors)
        return;
    if (pScreenPriv->screen->fb.depth > KD_MAX_PSEUDO_DEPTH)
        return;

    if (!pScreenPriv->enabled)
        return;

    if (!pCmap)
        return;

    /*
     * Make DIX convert pixels into RGB values -- this handles
     * true/direct as well as pseudo/static visuals
     */

    for (i = 0; i < (1 << pScreenPriv->screen->fb.depth); i++)
        pixels[i] = i;

    QueryColors(pCmap, (1 << pScreenPriv->screen->fb.depth), pixels, colors,
                serverClient);

    for (i = 0; i < (1 << pScreenPriv->screen->fb.depth); i++) {
        defs[i].pixel = i;
        defs[i].red = colors[i].red;
        defs[i].green = colors[i].green;
        defs[i].blue = colors[i].blue;
        defs[i].flags = DoRed | DoGreen | DoBlue;
    }

    (*pScreenPriv->card->cfuncs->putColors) (pCmap->pScreen,
                                             (1 << pScreenPriv->screen->fb.
                                              depth), defs);

    /* recolor hardware cursor */
    if (pScreenPriv->card->cfuncs->recolorCursor)
        (*pScreenPriv->card->cfuncs->recolorCursor) (pCmap->pScreen, 0, 0);
}

/*
 * When the hardware is enabled, save the hardware colors and store
 * the current colormap
 */
void
KdEnableColormap(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);
    int i;

    if (!pScreenPriv->card->cfuncs->putColors)
        return;

    if (pScreenPriv->screen->fb.depth <= KD_MAX_PSEUDO_DEPTH) {
        for (i = 0; i < (1 << pScreenPriv->screen->fb.depth); i++)
            pScreenPriv->systemPalette[i].pixel = i;
        (*pScreenPriv->card->cfuncs->getColors) (pScreen,
                                                 (1 << pScreenPriv->screen->fb.
                                                  depth),
                                                 pScreenPriv->systemPalette);
    }
    KdSetColormap(pScreen);
}

void
KdDisableColormap(ScreenPtr pScreen)
{
    KdScreenPriv(pScreen);

    if (!pScreenPriv->card->cfuncs->putColors)
        return;

    if (pScreenPriv->screen->fb.depth <= KD_MAX_PSEUDO_DEPTH) {
        (*pScreenPriv->card->cfuncs->putColors) (pScreen,
                                                 (1 << pScreenPriv->screen->fb.
                                                  depth),
                                                 pScreenPriv->systemPalette);
    }
}

/*
 * KdInstallColormap
 *
 * This function is called when the server receives a request to install a
 * colormap or when the server needs to install one on its own, like when
 * there's no window manager running and the user has moved the pointer over
 * an X client window.  It needs to build an identity Windows palette for the
 * colormap and realize it into the Windows system palette.
 */
void
KdInstallColormap(ColormapPtr pCmap)
{
    KdScreenPriv(pCmap->pScreen);

    if (pCmap == pScreenPriv->pInstalledmap)
        return;

    /* Tell X clients that the installed colormap is going away. */
    if (pScreenPriv->pInstalledmap)
        WalkTree(pScreenPriv->pInstalledmap->pScreen, TellLostMap,
                 (void *) &(pScreenPriv->pInstalledmap->mid));

    /* Take note of the new installed colorscreen-> */
    pScreenPriv->pInstalledmap = pCmap;

    KdSetColormap(pCmap->pScreen);

    /* Tell X clients of the new colormap */
    WalkTree(pCmap->pScreen, TellGainedMap, (void *) &(pCmap->mid));
}

/*
 * KdUninstallColormap
 *
 * This function uninstalls a colormap by either installing
 * the default X colormap or erasing the installed colormap pointer.
 * The default X colormap itself cannot be uninstalled.
 */
void
KdUninstallColormap(ColormapPtr pCmap)
{
    KdScreenPriv(pCmap->pScreen);
    Colormap defMapID;
    ColormapPtr defMap;

    /* ignore if not installed */
    if (pCmap != pScreenPriv->pInstalledmap)
        return;

    /* ignore attempts to uninstall default colormap */
    defMapID = pCmap->pScreen->defColormap;
    if ((Colormap) pCmap->mid == defMapID)
        return;

    /* install default */
    dixLookupResourceByType((void **) &defMap, defMapID, RT_COLORMAP,
                            serverClient, DixInstallAccess);
    if (defMap)
        (*pCmap->pScreen->InstallColormap) (defMap);
    else {
        /* uninstall and clear colormap pointer */
        WalkTree(pCmap->pScreen, TellLostMap, (void *) &(pCmap->mid));
        pScreenPriv->pInstalledmap = 0;
    }
}

int
KdListInstalledColormaps(ScreenPtr pScreen, Colormap * pCmaps)
{
    KdScreenPriv(pScreen);
    int n = 0;

    if (pScreenPriv->pInstalledmap) {
        *pCmaps++ = pScreenPriv->pInstalledmap->mid;
        n++;
    }
    return n;
}

/*
 * KdStoreColors
 *
 * This function is called whenever the server receives a request to store
 * color values into one or more entries in the currently installed X
 * colormap; it can be either the default colormap or a private colorscreen->
 */
void
KdStoreColors(ColormapPtr pCmap, int ndef, xColorItem * pdefs)
{
    KdScreenPriv(pCmap->pScreen);
    VisualPtr pVisual;
    xColorItem expanddefs[KD_MAX_PSEUDO_SIZE];

    if (pCmap != pScreenPriv->pInstalledmap)
        return;

    if (!pScreenPriv->card->cfuncs->putColors)
        return;

    if (pScreenPriv->screen->fb.depth > KD_MAX_PSEUDO_DEPTH)
        return;

    if (!pScreenPriv->enabled)
        return;

    /* Check for DirectColor or TrueColor being simulated on a PseudoColor device. */
    pVisual = pCmap->pVisual;
    if ((pVisual->class | DynamicClass) == DirectColor) {
        /*
         * Expand DirectColor or TrueColor color values into a PseudoColor
         * format.  Defer to the Color Framebuffer (CFB) code to do that.
         */
        ndef = fbExpandDirectColors(pCmap, ndef, pdefs, expanddefs);
        pdefs = expanddefs;
    }

    (*pScreenPriv->card->cfuncs->putColors) (pCmap->pScreen, ndef, pdefs);

    /* recolor hardware cursor */
    if (pScreenPriv->card->cfuncs->recolorCursor)
        (*pScreenPriv->card->cfuncs->recolorCursor) (pCmap->pScreen, ndef,
                                                     pdefs);
}
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d141 1
a141 1
                 (pointer) &(pScreenPriv->pInstalledmap->mid));
d149 1
a149 1
    WalkTree(pCmap->pScreen, TellGainedMap, (pointer) &(pCmap->mid));
d176 1
a176 1
    dixLookupResourceByType((pointer *) &defMap, defMapID, RT_COLORMAP,
d182 1
a182 1
        WalkTree(pCmap->pScreen, TellLostMap, (pointer) &(pCmap->mid));
@


1.4
log
@Update to xserver 1.11.2
@
text
@d33 1
a33 1
KdSetColormap (ScreenPtr pScreen)
d36 5
a40 5
    ColormapPtr	pCmap = pScreenPriv->pInstalledmap;
    Pixel	pixels[KD_MAX_PSEUDO_SIZE];
    xrgb	colors[KD_MAX_PSEUDO_SIZE];
    xColorItem	defs[KD_MAX_PSEUDO_SIZE];
    int		i;
d43 1
a43 1
	return;
d45 1
a45 1
	return;
d48 1
a48 1
	return;
d51 1
a51 1
	return;
d59 1
a59 1
	pixels[i] = i;
d61 2
a62 1
    QueryColors (pCmap, (1 << pScreenPriv->screen->fb.depth), pixels, colors, serverClient);
d64 6
a69 7
    for (i = 0; i < (1 << pScreenPriv->screen->fb.depth); i++)
    {
	defs[i].pixel = i;
	defs[i].red = colors[i].red;
	defs[i].green = colors[i].green;
	defs[i].blue = colors[i].blue;
	defs[i].flags = DoRed|DoGreen|DoBlue;
d73 2
a74 2
					     (1 << pScreenPriv->screen->fb.depth),
					     defs);
d78 1
a78 1
	(*pScreenPriv->card->cfuncs->recolorCursor) (pCmap->pScreen, 0, 0);
d86 1
a86 1
KdEnableColormap (ScreenPtr pScreen)
d89 1
a89 1
    int	    i;
d92 1
a92 1
	return;
d94 7
a100 7
    if (pScreenPriv->screen->fb.depth <= KD_MAX_PSEUDO_DEPTH)
    {
	for (i = 0; i < (1 << pScreenPriv->screen->fb.depth); i++)
	    pScreenPriv->systemPalette[i].pixel = i;
	(*pScreenPriv->card->cfuncs->getColors) (pScreen,
						 (1 << pScreenPriv->screen->fb.depth),
						 pScreenPriv->systemPalette);
d102 1
a102 1
    KdSetColormap (pScreen);
d106 1
a106 1
KdDisableColormap (ScreenPtr pScreen)
d111 1
a111 1
	return;
d113 5
a117 5
    if (pScreenPriv->screen->fb.depth <= KD_MAX_PSEUDO_DEPTH)
    {
	(*pScreenPriv->card->cfuncs->putColors) (pScreen,
						 (1 << pScreenPriv->screen->fb.depth),
						 pScreenPriv->systemPalette);
d131 1
a131 1
KdInstallColormap (ColormapPtr pCmap)
d136 1
a136 1
	return;
d140 2
a141 2
	WalkTree(pScreenPriv->pInstalledmap->pScreen, TellLostMap,
		 (pointer) &(pScreenPriv->pInstalledmap->mid));
d146 1
a146 1
    KdSetColormap (pCmap->pScreen);
d160 1
a160 1
KdUninstallColormap (ColormapPtr pCmap)
d163 1
a163 1
    Colormap	defMapID;
d168 1
a168 1
	return;
d173 1
a173 1
	return;
d176 2
a177 2
    dixLookupResourceByType((pointer *)&defMap, defMapID, RT_COLORMAP,
			    serverClient, DixInstallAccess);
d179 5
a183 7
	(*pCmap->pScreen->InstallColormap)(defMap);
    else
    {
	/* uninstall and clear colormap pointer */
	WalkTree(pCmap->pScreen, TellLostMap,
		 (pointer) &(pCmap->mid));
	pScreenPriv->pInstalledmap = 0;
d188 1
a188 1
KdListInstalledColormaps (ScreenPtr pScreen, Colormap *pCmaps)
d191 1
a191 1
    int		n = 0;
d193 3
a195 4
    if (pScreenPriv->pInstalledmap)
    {
	*pCmaps++ = pScreenPriv->pInstalledmap->mid;
	n++;
d208 1
a208 1
KdStoreColors (ColormapPtr pCmap, int ndef, xColorItem *pdefs)
d211 2
a212 2
    VisualPtr           pVisual;
    xColorItem          expanddefs[KD_MAX_PSEUDO_SIZE];
d215 1
a215 1
	return;
d218 1
a218 1
	return;
d221 1
a221 1
	return;
d224 1
a224 1
	return;
d228 7
a234 8
    if ((pVisual->class | DynamicClass) == DirectColor)
    {
	/*
	 * Expand DirectColor or TrueColor color values into a PseudoColor
	 * format.  Defer to the Color Framebuffer (CFB) code to do that.
	 */
	ndef = fbExpandDirectColors(pCmap, ndef, pdefs, expanddefs);
	pdefs = expanddefs;
d241 2
a242 1
	(*pScreenPriv->card->cfuncs->recolorCursor) (pCmap->pScreen, ndef, pdefs);
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d2 1
a2 1
 * Copyright © 1999 Keith Packard
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d61 1
a61 1
    QueryColors (pCmap, (1 << pScreenPriv->screen->fb.depth), pixels, colors);
@


1.1
log
@Initial revision
@
text
@a1 2
 * Id: kcmap.c,v 1.1 1999/11/02 03:54:46 keithp Exp $
 *
a21 1
/* $RCSId: xc/programs/Xserver/hw/kdrive/kcmap.c,v 1.4 2000/05/24 23:57:56 keithp Exp $ */
d33 1
a33 1
KdSetColormap (ScreenPtr pScreen, int fb)
d36 1
a36 1
    ColormapPtr	pCmap = pScreenPriv->pInstalledmap[fb];
d44 1
a44 1
    if (pScreenPriv->screen->fb[fb].depth > KD_MAX_PSEUDO_DEPTH)
d46 1
a46 1
    
d49 1
a49 1
    
d57 2
a58 2
    
    for (i = 0; i < (1 << pScreenPriv->screen->fb[fb].depth); i++)
d61 3
a63 3
    QueryColors (pCmap, (1 << pScreenPriv->screen->fb[fb].depth), pixels, colors);
    
    for (i = 0; i < (1 << pScreenPriv->screen->fb[fb].depth); i++)
d72 2
a73 2
    (*pScreenPriv->card->cfuncs->putColors) (pCmap->pScreen, fb,
					     (1 << pScreenPriv->screen->fb[fb].depth),
a89 2
    int	    fb;
    Bool    done = FALSE;
d93 2
a94 1
    for (fb = 0; fb < KD_MAX_FB && pScreenPriv->screen->fb[fb].depth; fb++)
d96 5
a100 10
	if (pScreenPriv->screen->fb[fb].depth <= KD_MAX_PSEUDO_DEPTH && !done)
	{
	    for (i = 0; i < (1 << pScreenPriv->screen->fb[fb].depth); i++)
		pScreenPriv->systemPalette[i].pixel = i;
	    (*pScreenPriv->card->cfuncs->getColors) (pScreen, fb,
						   (1 << pScreenPriv->screen->fb[fb].depth),
						   pScreenPriv->systemPalette);
	    done = TRUE;
	}
	KdSetColormap (pScreen, fb);
d102 1
a108 1
    int	    fb;
a111 11
    for (fb = 0; fb < KD_MAX_FB && pScreenPriv->screen->fb[fb].depth; fb++)
    {
	if (pScreenPriv->screen->fb[fb].depth <= KD_MAX_PSEUDO_DEPTH)
	{
	    (*pScreenPriv->card->cfuncs->putColors) (pScreen, fb,
						     (1 << pScreenPriv->screen->fb[fb].depth),
						     pScreenPriv->systemPalette);
	    break;
	}
    }
}
d113 1
a113 13
static int
KdColormapFb (ColormapPtr   pCmap)
{
    ScreenPtr	pScreen = pCmap->pScreen;
    KdScreenPriv (pScreen);
    KdScreenInfo    *screen = pScreenPriv->screen;
    int		d;
    DepthPtr	depth;
    int		v;
    VisualID	vid = pCmap->pVisual->vid;
    int		fb;

    if (screen->fb[1].depth)
d115 3
a117 15
	for (d = 0; d < pScreen->numDepths; d++)
	{
	    depth = &pScreen->allowedDepths[d];
	    for (v = 0; v < depth->numVids; v++)
	    {
		if (depth->vids[v] == vid)
		{
		    for (fb = 0; fb < KD_MAX_FB && screen->fb[fb].depth; fb++)
		    {
			if (depth->depth == screen->fb[fb].depth)
			    return fb;
		    }
		}
	    }
	}
a118 1
    return 0;
a133 1
    int		fb = KdColormapFb (pCmap);
d135 1
a135 1
    if (pCmap == pScreenPriv->pInstalledmap[fb])
d139 3
a141 3
    if (pScreenPriv->pInstalledmap[fb])
	WalkTree(pScreenPriv->pInstalledmap[fb]->pScreen, TellLostMap,
		 (pointer) &(pScreenPriv->pInstalledmap[fb]->mid));
d144 3
a146 1
    pScreenPriv->pInstalledmap[fb] = pCmap;
a147 2
    KdSetColormap (pCmap->pScreen, fb);
    
d155 1
a155 1
 * This function uninstalls a colormap by either installing 
a162 1
    int		fb = KdColormapFb (pCmap);
d167 1
a167 1
    if (pCmap != pScreenPriv->pInstalledmap[fb])
d175 4
a178 3
    /* install default if on same fb */
    defMap = (ColormapPtr) LookupIDByType(defMapID, RT_COLORMAP);
    if (defMap && KdColormapFb (defMap) == fb)
d185 1
a185 1
	pScreenPriv->pInstalledmap[fb] = 0;
a192 1
    int		fb;
d194 2
a195 2
    
    for (fb = 0; fb < KD_MAX_FB && pScreenPriv->screen->fb[fb].depth; fb++)
d197 2
a198 5
	if (pScreenPriv->pInstalledmap[fb])
	{
	    *pCmaps++ = pScreenPriv->pInstalledmap[fb]->mid;
	    n++;
	}
a215 1
    int			fb = KdColormapFb (pCmap);
d217 1
a217 1
    if (pCmap != pScreenPriv->pInstalledmap[fb])
d219 1
a219 1
    
d222 2
a223 2
    
    if (pScreenPriv->screen->fb[fb].depth > KD_MAX_PSEUDO_DEPTH)
d225 1
a225 1
    
d228 1
a228 1
    
d241 2
a242 2
    (*pScreenPriv->card->cfuncs->putColors) (pCmap->pScreen, fb, ndef, pdefs);
    
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d24 1
@

