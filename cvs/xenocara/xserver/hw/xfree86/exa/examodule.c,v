head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.10
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.51;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.40;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.40;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright Â© 2006 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <anholt@@FreeBSD.org>
 *
 */

#ifdef HAVE_CONFIG_H
#include <xorg-config.h>
#endif

#include <string.h>

#include "exa_priv.h"

#include "xf86str.h"
#include "xf86.h"

typedef struct _ExaXorgScreenPrivRec {
    CloseScreenProcPtr SavedCloseScreen;
    xf86EnableDisableFBAccessProc *SavedEnableDisableFBAccess;
    OptionInfoPtr options;
} ExaXorgScreenPrivRec, *ExaXorgScreenPrivPtr;

static DevPrivateKeyRec exaXorgScreenPrivateKeyRec;

#define exaXorgScreenPrivateKey (&exaXorgScreenPrivateKeyRec)

typedef enum {
    EXAOPT_MIGRATION_HEURISTIC,
    EXAOPT_NO_COMPOSITE,
    EXAOPT_NO_UTS,
    EXAOPT_NO_DFS,
    EXAOPT_OPTIMIZE_MIGRATION
} EXAOpts;

static const OptionInfoRec EXAOptions[] = {
    {EXAOPT_MIGRATION_HEURISTIC, "MigrationHeuristic",
     OPTV_ANYSTR, {0}, FALSE},
    {EXAOPT_NO_COMPOSITE, "EXANoComposite",
     OPTV_BOOLEAN, {0}, FALSE},
    {EXAOPT_NO_UTS, "EXANoUploadToScreen",
     OPTV_BOOLEAN, {0}, FALSE},
    {EXAOPT_NO_DFS, "EXANoDownloadFromScreen",
     OPTV_BOOLEAN, {0}, FALSE},
    {EXAOPT_OPTIMIZE_MIGRATION, "EXAOptimizeMigration",
     OPTV_BOOLEAN, {0}, FALSE},
    {-1, NULL,
     OPTV_NONE, {0}, FALSE}
};

static Bool
exaXorgCloseScreen(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    ExaXorgScreenPrivPtr pScreenPriv = (ExaXorgScreenPrivPtr)
        dixLookupPrivate(&pScreen->devPrivates, exaXorgScreenPrivateKey);

    pScreen->CloseScreen = pScreenPriv->SavedCloseScreen;

    pScrn->EnableDisableFBAccess = pScreenPriv->SavedEnableDisableFBAccess;

    free(pScreenPriv->options);
    free(pScreenPriv);

    return pScreen->CloseScreen(pScreen);
}

static void
exaXorgEnableDisableFBAccess(ScrnInfoPtr pScrn, Bool enable)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    ExaXorgScreenPrivPtr pScreenPriv = (ExaXorgScreenPrivPtr)
        dixLookupPrivate(&pScreen->devPrivates, exaXorgScreenPrivateKey);

    if (!enable)
        exaEnableDisableFBAccess(pScreen, enable);

    if (pScreenPriv->SavedEnableDisableFBAccess)
        pScreenPriv->SavedEnableDisableFBAccess(pScrn, enable);

    if (enable)
        exaEnableDisableFBAccess(pScreen, enable);
}

/**
 * This will be called during exaDriverInit, giving us the chance to set options
 * and hook in our EnableDisableFBAccess.
 */
void
exaDDXDriverInit(ScreenPtr pScreen)
{
    ExaScreenPriv(pScreen);
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    ExaXorgScreenPrivPtr pScreenPriv;

    if (!dixRegisterPrivateKey(&exaXorgScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
        return;

    pScreenPriv = calloc(1, sizeof(ExaXorgScreenPrivRec));
    if (pScreenPriv == NULL)
        return;

    pScreenPriv->options = xnfalloc(sizeof(EXAOptions));
    memcpy(pScreenPriv->options, EXAOptions, sizeof(EXAOptions));
    xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pScreenPriv->options);

    if (pExaScr->info->flags & EXA_OFFSCREEN_PIXMAPS) {
        if (!(pExaScr->info->flags & EXA_HANDLES_PIXMAPS) &&
            pExaScr->info->offScreenBase < pExaScr->info->memorySize) {
            const char *heuristicName;

            heuristicName = xf86GetOptValString(pScreenPriv->options,
                                                EXAOPT_MIGRATION_HEURISTIC);
            if (heuristicName != NULL) {
                if (strcmp(heuristicName, "greedy") == 0)
                    pExaScr->migration = ExaMigrationGreedy;
                else if (strcmp(heuristicName, "always") == 0)
                    pExaScr->migration = ExaMigrationAlways;
                else if (strcmp(heuristicName, "smart") == 0)
                    pExaScr->migration = ExaMigrationSmart;
                else {
                    xf86DrvMsg(pScreen->myNum, X_WARNING,
                               "EXA: unknown migration heuristic %s\n",
                               heuristicName);
                }
            }
        }

        pExaScr->optimize_migration =
            xf86ReturnOptValBool(pScreenPriv->options,
                                 EXAOPT_OPTIMIZE_MIGRATION, TRUE);
    }

    if (xf86ReturnOptValBool(pScreenPriv->options, EXAOPT_NO_COMPOSITE, FALSE)) {
        xf86DrvMsg(pScreen->myNum, X_CONFIG,
                   "EXA: Disabling Composite operation "
                   "(RENDER acceleration)\n");
        pExaScr->info->CheckComposite = NULL;
        pExaScr->info->PrepareComposite = NULL;
    }

    if (xf86ReturnOptValBool(pScreenPriv->options, EXAOPT_NO_UTS, FALSE)) {
        xf86DrvMsg(pScreen->myNum, X_CONFIG, "EXA: Disabling UploadToScreen\n");
        pExaScr->info->UploadToScreen = NULL;
    }

    if (xf86ReturnOptValBool(pScreenPriv->options, EXAOPT_NO_DFS, FALSE)) {
        xf86DrvMsg(pScreen->myNum, X_CONFIG,
                   "EXA: Disabling DownloadFromScreen\n");
        pExaScr->info->DownloadFromScreen = NULL;
    }

    dixSetPrivate(&pScreen->devPrivates, exaXorgScreenPrivateKey, pScreenPriv);

    pScreenPriv->SavedEnableDisableFBAccess = pScrn->EnableDisableFBAccess;
    pScrn->EnableDisableFBAccess = exaXorgEnableDisableFBAccess;

    pScreenPriv->SavedCloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = exaXorgCloseScreen;

}

static XF86ModuleVersionInfo exaVersRec = {
    "exa",
    MODULEVENDORSTRING,
    MODINFOSTRING1,
    MODINFOSTRING2,
    XORG_VERSION_CURRENT,
    EXA_VERSION_MAJOR, EXA_VERSION_MINOR, EXA_VERSION_RELEASE,
    ABI_CLASS_VIDEODRV,         /* requires the video driver ABI */
    ABI_VIDEODRV_VERSION,
    MOD_CLASS_NONE,
    {0, 0, 0, 0}
};

_X_EXPORT XF86ModuleData exaModuleData = { &exaVersRec, NULL, NULL };
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d131 1
a131 1
            char *heuristicName;
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d41 1
a41 1
    EnableDisableFBAccessProcPtr SavedEnableDisableFBAccess;
d73 1
a73 1
exaXorgCloseScreen(int i, ScreenPtr pScreen)
d75 1
a75 1
    ScrnInfoPtr pScrn = XF86SCRNINFO(pScreen);
d86 1
a86 1
    return pScreen->CloseScreen(i, pScreen);
d90 1
a90 1
exaXorgEnableDisableFBAccess(int index, Bool enable)
d92 1
a92 1
    ScreenPtr pScreen = screenInfo.screens[index];
d97 1
a97 1
        exaEnableDisableFBAccess(index, enable);
d100 1
a100 1
        pScreenPriv->SavedEnableDisableFBAccess(index, enable);
d103 1
a103 1
        exaEnableDisableFBAccess(index, enable);
d114 1
a114 2
    /* Do NOT use XF86SCRNINFO macro here!! */
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
@


1.6
log
@Update to xserver 1.11.2
@
text
@d40 1
a40 1
    CloseScreenProcPtr 		 SavedCloseScreen;
d42 1
a42 1
    OptionInfoPtr		 options;
d46 1
d58 12
a69 12
    { EXAOPT_MIGRATION_HEURISTIC,	"MigrationHeuristic",
				OPTV_ANYSTR,	{0}, FALSE },
    { EXAOPT_NO_COMPOSITE,		"EXANoComposite",
				OPTV_BOOLEAN,	{0}, FALSE },
    { EXAOPT_NO_UTS,			"EXANoUploadToScreen",
				OPTV_BOOLEAN,	{0}, FALSE },
    { EXAOPT_NO_DFS,			"EXANoDownloadFromScreen",
				OPTV_BOOLEAN,	{0}, FALSE },
    { EXAOPT_OPTIMIZE_MIGRATION,	"EXAOptimizeMigration",
				OPTV_BOOLEAN,	{0}, FALSE },
    { -1,				NULL,
				OPTV_NONE,	{0}, FALSE }
d73 1
a73 1
exaXorgCloseScreen (int i, ScreenPtr pScreen)
d77 1
a77 1
	dixLookupPrivate(&pScreen->devPrivates, exaXorgScreenPrivateKey);
d86 1
a86 1
    return pScreen->CloseScreen (i, pScreen);
d90 1
a90 1
exaXorgEnableDisableFBAccess (int index, Bool enable)
d94 1
a94 1
	dixLookupPrivate(&pScreen->devPrivates, exaXorgScreenPrivateKey);
d97 1
a97 1
	exaEnableDisableFBAccess (index, enable);
d100 1
a100 1
       pScreenPriv->SavedEnableDisableFBAccess (index, enable);
d103 1
a103 1
	exaEnableDisableFBAccess (index, enable);
d119 1
a119 1
	return;
d123 1
a123 1
	return;
d125 1
a125 1
    pScreenPriv->options = xnfalloc (sizeof(EXAOptions));
d127 1
a127 1
    xf86ProcessOptions (pScrn->scrnIndex, pScrn->options, pScreenPriv->options);
d130 24
a153 25
	if (!(pExaScr->info->flags & EXA_HANDLES_PIXMAPS) &&
	    pExaScr->info->offScreenBase < pExaScr->info->memorySize) {
	    char *heuristicName;

	    heuristicName = xf86GetOptValString (pScreenPriv->options,
						 EXAOPT_MIGRATION_HEURISTIC);
	    if (heuristicName != NULL) {
		if (strcmp(heuristicName, "greedy") == 0)
		    pExaScr->migration = ExaMigrationGreedy;
		else if (strcmp(heuristicName, "always") == 0)
		    pExaScr->migration = ExaMigrationAlways;
		else if (strcmp(heuristicName, "smart") == 0)
		    pExaScr->migration = ExaMigrationSmart;
		else {
		    xf86DrvMsg (pScreen->myNum, X_WARNING, 
				"EXA: unknown migration heuristic %s\n",
				heuristicName);
		}
	    }
	}

	pExaScr->optimize_migration =
	    xf86ReturnOptValBool(pScreenPriv->options,
				 EXAOPT_OPTIMIZE_MIGRATION,
				 TRUE);
d156 6
a161 7
    if (xf86ReturnOptValBool(pScreenPriv->options,
                             EXAOPT_NO_COMPOSITE, FALSE)) {
	xf86DrvMsg(pScreen->myNum, X_CONFIG,
		   "EXA: Disabling Composite operation "
		   "(RENDER acceleration)\n");
	pExaScr->info->CheckComposite = NULL;
	pExaScr->info->PrepareComposite = NULL;
d165 2
a166 3
	xf86DrvMsg(pScreen->myNum, X_CONFIG,
		   "EXA: Disabling UploadToScreen\n");
	pExaScr->info->UploadToScreen = NULL;
d170 3
a172 3
	xf86DrvMsg(pScreen->myNum, X_CONFIG,
		   "EXA: Disabling DownloadFromScreen\n");
	pExaScr->info->DownloadFromScreen = NULL;
d179 1
a179 1
    
d182 1
a182 1
    
d185 11
a195 12
static XF86ModuleVersionInfo exaVersRec =
{
	"exa",
	MODULEVENDORSTRING,
	MODINFOSTRING1,
	MODINFOSTRING2,
	XORG_VERSION_CURRENT,
	EXA_VERSION_MAJOR, EXA_VERSION_MINOR, EXA_VERSION_RELEASE,
	ABI_CLASS_VIDEODRV,		/* requires the video driver ABI */
	ABI_VIDEODRV_VERSION,
	MOD_CLASS_NONE,
	{0,0,0,0}
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d2 1
a2 1
 * Copyright © 2006 Intel Corporation
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d45 2
a46 2
static int exaXorgScreenPrivateKeyIndex;
static DevPrivateKey exaXorgScreenPrivateKey = &exaXorgScreenPrivateKeyIndex;
d82 2
a83 2
    xfree (pScreenPriv->options);
    xfree (pScreenPriv);
d117 4
a120 1
    pScreenPriv = xcalloc (1, sizeof(ExaXorgScreenPrivRec));
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d125 4
a128 4
    if ((pExaScr->info->flags & EXA_OFFSCREEN_PIXMAPS) &&
  	pExaScr->info->offScreenBase < pExaScr->info->memorySize)
    {
	char *heuristicName;
d130 14
a143 13
	heuristicName = xf86GetOptValString (pScreenPriv->options,
					     EXAOPT_MIGRATION_HEURISTIC);
	if (heuristicName != NULL) {
	    if (strcmp(heuristicName, "greedy") == 0)
		pExaScr->migration = ExaMigrationGreedy;
	    else if (strcmp(heuristicName, "always") == 0)
		pExaScr->migration = ExaMigrationAlways;
	    else if (strcmp(heuristicName, "smart") == 0)
		pExaScr->migration = ExaMigrationSmart;
	    else {
		xf86DrvMsg (pScreen->myNum, X_WARNING, 
			    "EXA: unknown migration heuristic %s\n",
			    heuristicName);
d150 1
a150 1
				 FALSE);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d45 2
a46 1
static DevPrivateKey exaXorgScreenPrivateKey = &exaXorgScreenPrivateKey;
a180 7
}

/*ARGSUSED*/
static const OptionInfoRec *
EXAAvailableOptions(void *unused)
{
    return (EXAOptions);
@


1.1
log
@Initial revision
@
text
@d45 1
a45 2
static int exaXorgServerGeneration;
static int exaXorgScreenPrivateIndex;
d52 1
d64 2
d74 2
a75 2
    ExaXorgScreenPrivPtr pScreenPriv =
	pScreen->devPrivates[exaXorgScreenPrivateIndex].ptr;
d91 2
a92 2
    ExaXorgScreenPrivPtr pScreenPriv =
	pScreen->devPrivates[exaXorgScreenPrivateIndex].ptr;
a115 5
    if (exaXorgServerGeneration != serverGeneration) {
	exaXorgScreenPrivateIndex = AllocateScreenPrivateIndex();
	exaXorgServerGeneration = serverGeneration;
    }

d144 5
d151 3
a153 2
    if (xf86IsOptionSet(pScreenPriv->options, EXAOPT_NO_COMPOSITE)) {
	xf86DrvMsg(pScreen->myNum, X_INFO,
d160 2
a161 2
    if (xf86IsOptionSet(pScreenPriv->options, EXAOPT_NO_UTS)) {
	xf86DrvMsg(pScreen->myNum, X_INFO,
d166 2
a167 2
    if (xf86IsOptionSet(pScreenPriv->options, EXAOPT_NO_DFS)) {
	xf86DrvMsg(pScreen->myNum, X_INFO,
d172 1
a172 1
    pScreen->devPrivates[exaXorgScreenPrivateIndex].ptr = pScreenPriv;
a181 2
static MODULESETUPPROTO(exaSetup);

d203 1
a203 23
_X_EXPORT XF86ModuleData exaModuleData = { &exaVersRec, exaSetup, NULL };

static ModuleInfoRec EXA = {
    1,
    "EXA",
    NULL,
    0,
    EXAAvailableOptions,
};

/*ARGSUSED*/
static pointer
exaSetup(pointer Module, pointer Options, int *ErrorMajor, int *ErrorMinor)
{
    static Bool Initialised = FALSE;

    if (!Initialised) {
	Initialised = TRUE;
	xf86AddModuleInfo(&EXA, Module);
    }

    return (pointer)TRUE;
}
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
