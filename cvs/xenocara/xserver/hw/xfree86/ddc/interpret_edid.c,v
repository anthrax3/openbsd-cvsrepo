head	1.8;
access;
symbols
	OPENBSD_6_0:1.8.0.8
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.10
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.8
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.31;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.18.46;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.18.46;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.55;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright 1998 by Egbert Eich <Egbert.Eich@@Physik.TU-Darmstadt.DE>
 * Copyright 2007 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * interpret_edid.c: interpret a primary EDID block
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"
#define _PARSE_EDID_
#include "xf86DDC.h"
#include <string.h>

static void get_vendor_section(Uchar *, struct vendor *);
static void get_version_section(Uchar *, struct edid_version *);
static void get_display_section(Uchar *, struct disp_features *,
                                struct edid_version *);
static void get_established_timing_section(Uchar *,
                                           struct established_timings *);
static void get_std_timing_section(Uchar *, struct std_timings *,
                                   struct edid_version *);
static void fetch_detailed_block(Uchar * c, struct edid_version *ver,
                                 struct detailed_monitor_section *det_mon);
static void get_dt_md_section(Uchar *, struct edid_version *,
                              struct detailed_monitor_section *det_mon);
static void copy_string(Uchar *, Uchar *);
static void get_dst_timing_section(Uchar *, struct std_timings *,
                                   struct edid_version *);
static void get_monitor_ranges(Uchar *, struct monitor_ranges *);
static void get_whitepoint_section(Uchar *, struct whitePoints *);
static void get_detailed_timing_section(Uchar *, struct detailed_timings *);
static Bool validate_version(int scrnIndex, struct edid_version *);

static void
find_ranges_section(struct detailed_monitor_section *det, void *ranges)
{
    if (det->type == DS_RANGES && det->section.ranges.max_clock)
        *(struct monitor_ranges **) ranges = &det->section.ranges;
}

static void
find_max_detailed_clock(struct detailed_monitor_section *det, void *ret)
{
    if (det->type == DT) {
        *(int *) ret = max(*((int *) ret), det->section.d_timings.clock);
    }
}

static void
handle_edid_quirks(xf86MonPtr m)
{
    struct monitor_ranges *ranges = NULL;

    /*
     * max_clock is only encoded in EDID in tens of MHz, so occasionally we
     * find a monitor claiming a max of 160 with a mode requiring 162, or
     * similar.  Strictly we should refuse to round up too far, but let's
     * see how well this works.
     */

    /* Try to find Monitor Range and max clock, then re-set range value */
    xf86ForEachDetailedBlock(m, find_ranges_section, &ranges);
    if (ranges && ranges->max_clock) {
        int clock = 0;

        xf86ForEachDetailedBlock(m, find_max_detailed_clock, &clock);
        if (clock && (ranges->max_clock * 1e6 < clock)) {
            xf86Msg(X_WARNING, "EDID timing clock %.2f exceeds claimed max "
                    "%dMHz, fixing\n", clock / 1.0e6, ranges->max_clock);
            ranges->max_clock = (clock + 999999) / 1e6;
        }
    }
}

struct det_hv_parameter {
    int real_hsize;
    int real_vsize;
    float target_aspect;
};

static void
handle_detailed_hvsize(struct detailed_monitor_section *det_mon, void *data)
{
    struct det_hv_parameter *p = (struct det_hv_parameter *) data;
    float timing_aspect;

    if (det_mon->type == DT) {
        struct detailed_timings *timing;

        timing = &det_mon->section.d_timings;

        if (!timing->v_size)
            return;

        timing_aspect = (float) timing->h_size / timing->v_size;
        if (fabs(1 - (timing_aspect / p->target_aspect)) < 0.05) {
            p->real_hsize = max(p->real_hsize, timing->h_size);
            p->real_vsize = max(p->real_vsize, timing->v_size);
        }
    }
}

static void
encode_aspect_ratio(xf86MonPtr m)
{
    /*
     * some monitors encode the aspect ratio instead of the physical size.
     * try to find the largest detailed timing that matches that aspect
     * ratio and use that to fill in the feature section.
     */
    if ((m->features.hsize == 16 && m->features.vsize == 9) ||
        (m->features.hsize == 16 && m->features.vsize == 10) ||
        (m->features.hsize == 4 && m->features.vsize == 3) ||
        (m->features.hsize == 5 && m->features.vsize == 4)) {

        struct det_hv_parameter p;

        p.real_hsize = 0;
        p.real_vsize = 0;
        p.target_aspect = (float) m->features.hsize / m->features.vsize;

        xf86ForEachDetailedBlock(m, handle_detailed_hvsize, &p);

        if (!p.real_hsize || !p.real_vsize) {
            m->features.hsize = m->features.vsize = 0;
        }
        else if ((m->features.hsize * 10 == p.real_hsize) &&
                 (m->features.vsize * 10 == p.real_vsize)) {
            /* exact match is just unlikely, should do a better check though */
            m->features.hsize = m->features.vsize = 0;
        }
        else {
            /* convert mm to cm */
            m->features.hsize = (p.real_hsize + 5) / 10;
            m->features.vsize = (p.real_vsize + 5) / 10;
        }

        xf86Msg(X_INFO, "Quirked EDID physical size to %dx%d cm\n",
                m->features.hsize, m->features.vsize);
    }
}

xf86MonPtr
xf86InterpretEDID(int scrnIndex, Uchar * block)
{
    xf86MonPtr m;

    if (!block)
        return NULL;
    if (!(m = xnfcalloc(sizeof(xf86Monitor), 1)))
        return NULL;
    m->scrnIndex = scrnIndex;
    m->rawData = block;

    get_vendor_section(SECTION(VENDOR_SECTION, block), &m->vendor);
    get_version_section(SECTION(VERSION_SECTION, block), &m->ver);
    if (!validate_version(scrnIndex, &m->ver))
        goto error;
    get_display_section(SECTION(DISPLAY_SECTION, block), &m->features, &m->ver);
    get_established_timing_section(SECTION(ESTABLISHED_TIMING_SECTION, block),
                                   &m->timings1);
    get_std_timing_section(SECTION(STD_TIMING_SECTION, block), m->timings2,
                           &m->ver);
    get_dt_md_section(SECTION(DET_TIMING_SECTION, block), &m->ver, m->det_mon);
    m->no_sections = (int) *(char *) SECTION(NO_EDID, block);

    handle_edid_quirks(m);
    encode_aspect_ratio(m);

    return m;

 error:
    free(m);
    return NULL;
}

static int
get_cea_detail_timing(Uchar * blk, xf86MonPtr mon,
                      struct detailed_monitor_section *det_mon)
{
    int dt_num;
    int dt_offset = ((struct cea_ext_body *) blk)->dt_offset;

    dt_num = 0;

    if (dt_offset < CEA_EXT_MIN_DATA_OFFSET)
        return dt_num;

    for (; dt_offset < (CEA_EXT_MAX_DATA_OFFSET - DET_TIMING_INFO_LEN) &&
         dt_num < CEA_EXT_DET_TIMING_NUM; _NEXT_DT_MD_SECTION(dt_offset)) {

        fetch_detailed_block(blk + dt_offset, &mon->ver, det_mon + dt_num);
        dt_num = dt_num + 1;
    }

    return dt_num;
}

static void
handle_cea_detail_block(Uchar * ext, xf86MonPtr mon,
                        handle_detailed_fn fn, void *data)
{
    int i;
    struct detailed_monitor_section det_mon[CEA_EXT_DET_TIMING_NUM];
    int det_mon_num;

    det_mon_num = get_cea_detail_timing(ext, mon, det_mon);

    for (i = 0; i < det_mon_num; i++)
        fn(det_mon + i, data);
}

void
xf86ForEachDetailedBlock(xf86MonPtr mon, handle_detailed_fn fn, void *data)
{
    int i;
    Uchar *ext;

    if (mon == NULL)
        return;

    for (i = 0; i < DET_TIMINGS; i++)
        fn(mon->det_mon + i, data);

    for (i = 0; i < mon->no_sections; i++) {
        ext = mon->rawData + EDID1_LEN * (i + 1);
        switch (ext[EXT_TAG]) {
        case CEA_EXT:
            handle_cea_detail_block(ext, mon, fn, data);
            break;
        case VTB_EXT:
        case DI_EXT:
        case LS_EXT:
        case MI_EXT:
            break;
        }
    }
}

static struct cea_data_block *
extract_cea_data_block(Uchar * ext, int data_type)
{
    struct cea_ext_body *cea;
    struct cea_data_block *data_collection;
    struct cea_data_block *data_end;

    cea = (struct cea_ext_body *) ext;

    if (cea->dt_offset <= CEA_EXT_MIN_DATA_OFFSET)
        return NULL;

    data_collection = &cea->data_collection;
    data_end = (struct cea_data_block *) (cea->dt_offset + ext);

    for (; data_collection < data_end;) {

        if (data_type == data_collection->tag) {
            return data_collection;
        }
        data_collection = (void *) ((unsigned char *) data_collection +
                                    data_collection->len + 1);
    }

    return NULL;
}

static void
handle_cea_video_block(Uchar * ext, handle_video_fn fn, void *data)
{
    struct cea_video_block *video;
    struct cea_video_block *video_end;
    struct cea_data_block *data_collection;

    data_collection = extract_cea_data_block(ext, CEA_VIDEO_BLK);
    if (data_collection == NULL)
        return;

    video = &data_collection->u.video;
    video_end = (struct cea_video_block *)
        ((Uchar *) video + data_collection->len);

    for (; video < video_end; video = video + 1) {
        fn(video, data);
    }
}

void
xf86ForEachVideoBlock(xf86MonPtr mon, handle_video_fn fn, void *data)
{
    int i;
    Uchar *ext;

    if (mon == NULL)
        return;

    for (i = 0; i < mon->no_sections; i++) {
        ext = mon->rawData + EDID1_LEN * (i + 1);
        switch (ext[EXT_TAG]) {
        case CEA_EXT:
            handle_cea_video_block(ext, fn, data);
            break;
        case VTB_EXT:
        case DI_EXT:
        case LS_EXT:
        case MI_EXT:
            break;
        }
    }
}

static Bool
cea_db_offsets(Uchar *cea, int *start, int *end)
{
    /* Data block offset in CEA extension block */
    *start = CEA_EXT_MIN_DATA_OFFSET;
    *end = cea[2];
    if (*end == 0)
        *end = CEA_EXT_MAX_DATA_OFFSET;
    if (*end < CEA_EXT_MIN_DATA_OFFSET || *end > CEA_EXT_MAX_DATA_OFFSET)
        return FALSE;
    return TRUE;
}

static int
cea_db_len(Uchar *db)
{
    return db[0] & 0x1f;
}

static int
cea_db_tag(Uchar *db)
{
    return db[0] >> 5;
}

typedef void (*handle_cea_db_fn) (Uchar *, void *);

static void
cea_for_each_db(xf86MonPtr mon, handle_cea_db_fn fn, void *data)
{
    int i;

    if (!mon)
        return;

    if (!(mon->flags & EDID_COMPLETE_RAWDATA))
        return;

    if (!mon->no_sections)
        return;

    if (!mon->rawData)
        return;

    for (i = 0; i < mon->no_sections; i++) {
        int start, end, offset;
        Uchar *ext;

        ext = mon->rawData + EDID1_LEN * (i + 1);
        if (ext[EXT_TAG] != CEA_EXT)
            continue;

        if (!cea_db_offsets(ext, &start, &end))
            continue;

        for (offset = start;
             offset < end && offset + cea_db_len(&ext[offset]) < end;
             offset += cea_db_len(&ext[offset]) + 1)
                fn(&ext[offset], data);
    }
}

struct find_hdmi_block_data {
    struct cea_data_block *hdmi;
};

static void find_hdmi_block(Uchar *db, void *data)
{
    struct find_hdmi_block_data *result = data;
    int oui;

    if (cea_db_tag(db) != CEA_VENDOR_BLK)
        return;

    if (cea_db_len(db) < 5)
        return;

    oui = (db[3] << 16) | (db[2] << 8) | db[1];
    if (oui == IEEE_ID_HDMI)
        result->hdmi = (struct cea_data_block *)db;
}

struct cea_data_block *xf86MonitorFindHDMIBlock(xf86MonPtr mon)
{
    struct find_hdmi_block_data result = { NULL };

    cea_for_each_db(mon, find_hdmi_block, &result);

    return result.hdmi;
}

xf86MonPtr
xf86InterpretEEDID(int scrnIndex, Uchar * block)
{
    xf86MonPtr m;

    m = xf86InterpretEDID(scrnIndex, block);
    if (!m)
        return NULL;

    /* extension parse */

    return m;
}

static void
get_vendor_section(Uchar * c, struct vendor *r)
{
    r->name[0] = L1;
    r->name[1] = L2;
    r->name[2] = L3;
    r->name[3] = '\0';

    r->prod_id = PROD_ID;
    r->serial = SERIAL_NO;
    r->week = WEEK;
    r->year = YEAR;
}

static void
get_version_section(Uchar * c, struct edid_version *r)
{
    r->version = VERSION;
    r->revision = REVISION;
}

static void
get_display_section(Uchar * c, struct disp_features *r, struct edid_version *v)
{
    r->input_type = INPUT_TYPE;
    if (!DIGITAL(r->input_type)) {
        r->input_voltage = INPUT_VOLTAGE;
        r->input_setup = SETUP;
        r->input_sync = SYNC;
    }
    else if (v->revision == 2 || v->revision == 3) {
        r->input_dfp = DFP;
    }
    else if (v->revision >= 4) {
        r->input_bpc = BPC;
        r->input_interface = DIGITAL_INTERFACE;
    }
    r->hsize = HSIZE_MAX;
    r->vsize = VSIZE_MAX;
    r->gamma = GAMMA;
    r->dpms = DPMS;
    r->display_type = DISPLAY_TYPE;
    r->msc = MSC;
    r->redx = REDX;
    r->redy = REDY;
    r->greenx = GREENX;
    r->greeny = GREENY;
    r->bluex = BLUEX;
    r->bluey = BLUEY;
    r->whitex = WHITEX;
    r->whitey = WHITEY;
}

static void
get_established_timing_section(Uchar * c, struct established_timings *r)
{
    r->t1 = T1;
    r->t2 = T2;
    r->t_manu = T_MANU;
}

static void
get_cvt_timing_section(Uchar * c, struct cvt_timings *r)
{
    int i;

    for (i = 0; i < 4; i++) {
        if (c[0] && c[1] && c[2]) {
            r[i].height = (c[0] + ((c[1] & 0xF0) << 8) + 1) * 2;
            switch (c[1] & 0xc0) {
            case 0x00:
                r[i].width = r[i].height * 4 / 3;
                break;
            case 0x40:
                r[i].width = r[i].height * 16 / 9;
                break;
            case 0x80:
                r[i].width = r[i].height * 16 / 10;
                break;
            case 0xc0:
                r[i].width = r[i].height * 15 / 9;
                break;
            }
            switch (c[2] & 0x60) {
            case 0x00:
                r[i].rate = 50;
                break;
            case 0x20:
                r[i].rate = 60;
                break;
            case 0x40:
                r[i].rate = 75;
                break;
            case 0x60:
                r[i].rate = 85;
                break;
            }
            r[i].rates = c[2] & 0x1f;
        }
        else {
            return;
        }
        c += 3;
    }
}

static void
get_std_timing_section(Uchar * c, struct std_timings *r, struct edid_version *v)
{
    int i;

    for (i = 0; i < STD_TIMINGS; i++) {
        if (VALID_TIMING) {
            r[i].hsize = HSIZE1;
            VSIZE1(r[i].vsize);
            r[i].refresh = REFRESH_R;
            r[i].id = STD_TIMING_ID;
        }
        else {
            r[i].hsize = r[i].vsize = r[i].refresh = r[i].id = 0;
        }
        NEXT_STD_TIMING;
    }
}

static const unsigned char empty_block[18];

static void
fetch_detailed_block(Uchar * c, struct edid_version *ver,
                     struct detailed_monitor_section *det_mon)
{
    if (ver->version == 1 && ver->revision >= 1 && IS_MONITOR_DESC) {
        switch (MONITOR_DESC_TYPE) {
        case SERIAL_NUMBER:
            det_mon->type = DS_SERIAL;
            copy_string(c, det_mon->section.serial);
            break;
        case ASCII_STR:
            det_mon->type = DS_ASCII_STR;
            copy_string(c, det_mon->section.ascii_data);
            break;
        case MONITOR_RANGES:
            det_mon->type = DS_RANGES;
            get_monitor_ranges(c, &det_mon->section.ranges);
            break;
        case MONITOR_NAME:
            det_mon->type = DS_NAME;
            copy_string(c, det_mon->section.name);
            break;
        case ADD_COLOR_POINT:
            det_mon->type = DS_WHITE_P;
            get_whitepoint_section(c, det_mon->section.wp);
            break;
        case ADD_STD_TIMINGS:
            det_mon->type = DS_STD_TIMINGS;
            get_dst_timing_section(c, det_mon->section.std_t, ver);
            break;
        case COLOR_MANAGEMENT_DATA:
            det_mon->type = DS_CMD;
            break;
        case CVT_3BYTE_DATA:
            det_mon->type = DS_CVT;
            get_cvt_timing_section(c, det_mon->section.cvt);
            break;
        case ADD_EST_TIMINGS:
            det_mon->type = DS_EST_III;
            memcpy(det_mon->section.est_iii, c + 6, 6);
            break;
        case ADD_DUMMY:
            det_mon->type = DS_DUMMY;
            break;
        default:
            det_mon->type = DS_UNKOWN;
            break;
        }
        if (c[3] <= 0x0F && memcmp(c, empty_block, sizeof(empty_block))) {
            det_mon->type = DS_VENDOR + c[3];
        }
    }
    else {
        det_mon->type = DT;
        get_detailed_timing_section(c, &det_mon->section.d_timings);
    }
}

static void
get_dt_md_section(Uchar * c, struct edid_version *ver,
                  struct detailed_monitor_section *det_mon)
{
    int i;

    for (i = 0; i < DET_TIMINGS; i++) {
        fetch_detailed_block(c, ver, det_mon + i);
        NEXT_DT_MD_SECTION;
    }
}

static void
copy_string(Uchar * c, Uchar * s)
{
    int i;

    c = c + 5;
    for (i = 0; (i < 13 && *c != 0x0A); i++)
        *(s++) = *(c++);
    *s = 0;
    while (i-- && (*--s == 0x20))
        *s = 0;
}

static void
get_dst_timing_section(Uchar * c, struct std_timings *t, struct edid_version *v)
{
    int j;

    c = c + 5;
    for (j = 0; j < 5; j++) {
        t[j].hsize = HSIZE1;
        VSIZE1(t[j].vsize);
        t[j].refresh = REFRESH_R;
        t[j].id = STD_TIMING_ID;
        NEXT_STD_TIMING;
    }
}

static void
get_monitor_ranges(Uchar * c, struct monitor_ranges *r)
{
    r->min_v = MIN_V;
    r->max_v = MAX_V;
    r->min_h = MIN_H;
    r->max_h = MAX_H;
    r->max_clock = 0;
    if (MAX_CLOCK != 0xff)      /* is specified? */
        r->max_clock = MAX_CLOCK * 10 + 5;
    if (HAVE_2ND_GTF) {
        r->gtf_2nd_f = F_2ND_GTF;
        r->gtf_2nd_c = C_2ND_GTF;
        r->gtf_2nd_m = M_2ND_GTF;
        r->gtf_2nd_k = K_2ND_GTF;
        r->gtf_2nd_j = J_2ND_GTF;
    }
    else {
        r->gtf_2nd_f = 0;
    }
    if (HAVE_CVT) {
        r->max_clock_khz = MAX_CLOCK_KHZ;
        r->max_clock = r->max_clock_khz / 1000;
        r->maxwidth = MAXWIDTH;
        r->supported_aspect = SUPPORTED_ASPECT;
        r->preferred_aspect = PREFERRED_ASPECT;
        r->supported_blanking = SUPPORTED_BLANKING;
        r->supported_scaling = SUPPORTED_SCALING;
        r->preferred_refresh = PREFERRED_REFRESH;
    }
    else {
        r->max_clock_khz = 0;
    }
}

static void
get_whitepoint_section(Uchar * c, struct whitePoints *wp)
{
    wp[0].white_x = WHITEX1;
    wp[0].white_y = WHITEY1;
    wp[1].white_x = WHITEX2;
    wp[1].white_y = WHITEY2;
    wp[0].index = WHITE_INDEX1;
    wp[1].index = WHITE_INDEX2;
    wp[0].white_gamma = WHITE_GAMMA1;
    wp[1].white_gamma = WHITE_GAMMA2;
}

static void
get_detailed_timing_section(Uchar * c, struct detailed_timings *r)
{
    r->clock = PIXEL_CLOCK;
    r->h_active = H_ACTIVE;
    r->h_blanking = H_BLANK;
    r->v_active = V_ACTIVE;
    r->v_blanking = V_BLANK;
    r->h_sync_off = H_SYNC_OFF;
    r->h_sync_width = H_SYNC_WIDTH;
    r->v_sync_off = V_SYNC_OFF;
    r->v_sync_width = V_SYNC_WIDTH;
    r->h_size = H_SIZE;
    r->v_size = V_SIZE;
    r->h_border = H_BORDER;
    r->v_border = V_BORDER;
    r->interlaced = INTERLACED;
    r->stereo = STEREO;
    r->stereo_1 = STEREO1;
    r->sync = SYNC_T;
    r->misc = MISC;
}

#define MAX_EDID_MINOR 4

static Bool
validate_version(int scrnIndex, struct edid_version *r)
{
    if (r->version != 1) {
        xf86DrvMsg(scrnIndex, X_ERROR, "Unknown EDID version %d\n", r->version);
        return FALSE;
    }

    if (r->revision > MAX_EDID_MINOR)
        xf86DrvMsg(scrnIndex, X_WARNING,
                   "Assuming version 1.%d is compatible with 1.%d\n",
                   r->revision, MAX_EDID_MINOR);

    return TRUE;
}

/*
 * Returns true if HDMI, false if definitely not or unknown.
 */
Bool
xf86MonitorIsHDMI(xf86MonPtr mon)
{
    return xf86MonitorFindHDMIBlock(mon) != NULL;
}
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d335 91
d760 1
a760 45
    int i = 0, version, offset;
    char *edid = NULL;

    if (!mon)
        return FALSE;

    if (!(mon->flags & EDID_COMPLETE_RAWDATA))
        return FALSE;

    if (!mon->no_sections)
        return FALSE;

    edid = (char *) mon->rawData;
    if (!edid)
        return FALSE;

    /* find the CEA extension block */
    for (i = 1; i <= mon->no_sections; i++)
        if (edid[i * 128] == 0x02)
            break;
    if (i == mon->no_sections + 1)
        return FALSE;
    edid += (i * 128);

    version = edid[1];
    offset = edid[2];
    if (version < 3 || offset < 4)
        return FALSE;

    /* walk the cea data blocks */
    for (i = 4; i < offset; i += (edid[i] & 0x1f) + 1) {
        char *x = edid + i;

        /* find a vendor specific block */
        if ((x[0] & 0xe0) >> 5 == 0x03) {
            int oui = (x[3] << 16) + (x[2] << 8) + x[1];

            /* find the HDMI vendor OUI */
            if (oui == 0x000c03)
                return TRUE;
        }
    }

    /* guess it's not HDMI after all */
    return FALSE;
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d38 9
a46 8
static void get_vendor_section(Uchar*, struct vendor *);
static void get_version_section(Uchar*, struct edid_version *);
static void get_display_section(Uchar*, struct disp_features *,
				struct edid_version *);
static void get_established_timing_section(Uchar*, struct established_timings *);
static void get_std_timing_section(Uchar*, struct std_timings *,
				   struct edid_version *);
static void fetch_detailed_block(Uchar *c, struct edid_version *ver,
d49 1
a49 1
			      struct detailed_monitor_section *det_mon);
d52 1
a52 1
				   struct edid_version *);
d55 1
a55 1
static void get_detailed_timing_section(Uchar*, struct 	detailed_timings *);
d61 2
a62 2
   if (det->type == DS_RANGES && det->section.ranges.max_clock)
       *(struct monitor_ranges **)ranges = &det->section.ranges;
d69 1
a69 2
        *(int *)ret = max(*((int *)ret),
                          det->section.d_timings.clock);
d85 1
a85 1
    /* Try to find Monitor Range and max clock, then re-set range value*/
d89 1
d94 1
a94 1
            ranges->max_clock = (clock+999999)/1e6;
d105 2
a106 2
static void handle_detailed_hvsize(struct detailed_monitor_section *det_mon,
                                   void *data)
d108 1
a108 1
    struct det_hv_parameter *p = (struct det_hv_parameter *)data;
d113 1
d119 1
a119 1
        timing_aspect = (float)timing->h_size / timing->v_size;
d127 2
a128 1
static void encode_aspect_ratio(xf86MonPtr m)
d136 3
a138 3
	(m->features.hsize == 16 && m->features.vsize == 10) ||
	(m->features.hsize == 4 && m->features.vsize == 3) ||
	(m->features.hsize == 5 && m->features.vsize == 4)) {
d141 1
d144 1
a144 1
        p.target_aspect = (float)m->features.hsize /m->features.vsize;
d148 13
a160 11
	if (!p.real_hsize || !p.real_vsize) {
	    m->features.hsize = m->features.vsize = 0;
	} else if ((m->features.hsize * 10 == p.real_hsize) &&
		   (m->features.vsize * 10 == p.real_vsize)) {
	    /* exact match is just unlikely, should do a better check though */
	    m->features.hsize = m->features.vsize = 0;
	} else {
	    /* convert mm to cm */
	    m->features.hsize = (p.real_hsize + 5) / 10;
	    m->features.vsize = (p.real_vsize + 5) / 10;
	}
d162 2
a163 2
	xf86Msg(X_INFO, "Quirked EDID physical size to %dx%d cm\n",
		m->features.hsize, m->features.vsize);
d168 1
a168 1
xf86InterpretEDID(int scrnIndex, Uchar *block)
d172 4
a175 2
    if (!block) return NULL;
    if (! (m = xnfcalloc(sizeof(xf86Monitor),1))) return NULL;
d179 11
a189 11
    get_vendor_section(SECTION(VENDOR_SECTION,block),&m->vendor);
    get_version_section(SECTION(VERSION_SECTION,block),&m->ver);
    if (!validate_version(scrnIndex, &m->ver)) goto error;
    get_display_section(SECTION(DISPLAY_SECTION,block),&m->features,
			&m->ver);
    get_established_timing_section(SECTION(ESTABLISHED_TIMING_SECTION,block),
				   &m->timings1);
    get_std_timing_section(SECTION(STD_TIMING_SECTION,block),m->timings2,
			   &m->ver);
    get_dt_md_section(SECTION(DET_TIMING_SECTION,block),&m->ver, m->det_mon);
    m->no_sections = (int)*(char *)SECTION(NO_EDID,block);
d201 3
a203 2
static int get_cea_detail_timing(Uchar *blk, xf86MonPtr mon,
                                 struct detailed_monitor_section *det_mon)
d206 1
a206 1
    int dt_offset = ((struct cea_ext_body *)blk)->dt_offset;
d214 1
a214 2
           dt_num < CEA_EXT_DET_TIMING_NUM;
	   _NEXT_DT_MD_SECTION(dt_offset)) {
d217 1
a217 1
        dt_num = dt_num + 1 ;
d223 3
a225 3
static void handle_cea_detail_block(Uchar *ext, xf86MonPtr mon,
                                    handle_detailed_fn fn,
                                    void *data)
d237 2
a238 3
void xf86ForEachDetailedBlock(xf86MonPtr mon,
                              handle_detailed_fn fn,
                              void *data)
d251 1
a251 1
        switch (ext[EXT_TAG]){
d259 1
a259 1
	    break;
d265 1
a265 1
extract_cea_data_block(Uchar *ext, int data_type)
d271 1
a271 1
    cea = (struct cea_ext_body *)ext;
d277 1
a277 1
    data_end = (struct cea_data_block *)(cea->dt_offset + ext);
d279 1
a279 1
    for ( ;data_collection < data_end;) {
d281 5
a285 5
	if (data_type == data_collection->tag) {
	    return data_collection;
	}
	data_collection = (void *)((unsigned char *)data_collection +
	    data_collection->len + 1);
d291 2
a292 1
static void handle_cea_video_block(Uchar *ext, handle_video_fn fn, void *data)
d304 1
a304 1
	((Uchar *)video + data_collection->len);
d307 1
a307 1
	fn(video, data);
d311 2
a312 3
void xf86ForEachVideoBlock(xf86MonPtr mon,
	                   handle_video_fn fn,
                           void *data)
d318 1
a318 1
	return;
d321 11
a331 11
	ext = mon->rawData + EDID1_LEN * (i + 1);
	switch (ext[EXT_TAG]) {
	case CEA_EXT:
	    handle_cea_video_block(ext, fn, data);
	    break;
	case VTB_EXT:
	case DI_EXT:
	case LS_EXT:
	case MI_EXT:
	    break;
	}
d336 1
a336 1
xf86InterpretEEDID(int scrnIndex, Uchar *block)
d342 1
a342 1
	return NULL;
d350 1
a350 1
get_vendor_section(Uchar *c, struct vendor *r)
d356 1
a356 1
  
d358 3
a360 3
    r->serial  = SERIAL_NO;
    r->week    = WEEK;
    r->year    = YEAR;
d363 2
a364 2
static void 
get_version_section(Uchar *c, struct edid_version *r)
d366 1
a366 1
    r->version  = VERSION;
d370 2
a371 3
static void 
get_display_section(Uchar *c, struct disp_features *r,
		    struct edid_version *v)
d375 10
a384 8
	r->input_voltage = INPUT_VOLTAGE;
	r->input_setup = SETUP;
	r->input_sync = SYNC;
    } else if (v->revision == 2 || v->revision == 3) {
	r->input_dfp = DFP;
    } else if (v->revision >= 4) {
	r->input_bpc = BPC;
	r->input_interface = DIGITAL_INTERFACE;
d389 1
a389 1
    r->dpms =  DPMS;
d402 2
a403 2
static void 
get_established_timing_section(Uchar *c, struct established_timings *r)
d411 1
a411 1
get_cvt_timing_section(Uchar *c, struct cvt_timings *r)
d416 36
a451 19
	if (c[0] && c[1] && c[2]) {
	    r[i].height = (c[0] + ((c[1] & 0xF0) << 8) + 1) * 2;
	    switch (c[1] & 0xc0) {
		case 0x00: r[i].width = r[i].height * 4 / 3; break;
		case 0x40: r[i].width = r[i].height * 16 / 9; break;
		case 0x80: r[i].width = r[i].height * 16 / 10; break;
		case 0xc0: r[i].width = r[i].height * 15 / 9; break;
	    }
	    switch (c[2] & 0x60) {
		case 0x00: r[i].rate = 50; break;
		case 0x20: r[i].rate = 60; break;
		case 0x40: r[i].rate = 75; break;
		case 0x60: r[i].rate = 85; break;
	    }
	    r[i].rates = c[2] & 0x1f;
	} else {
	    return;
	}
	c += 3;
d456 1
a456 2
get_std_timing_section(Uchar *c, struct std_timings *r,
		       struct edid_version *v)
d460 11
a470 10
    for (i=0;i<STD_TIMINGS;i++){
	if (VALID_TIMING) {
	    r[i].hsize = HSIZE1;
	    VSIZE1(r[i].vsize);
	    r[i].refresh = REFRESH_R;
	    r[i].id = STD_TIMING_ID;
	} else {
	    r[i].hsize = r[i].vsize = r[i].refresh = r[i].id = 0;
	}
	NEXT_STD_TIMING;
d477 1
a477 1
fetch_detailed_block(Uchar *c, struct edid_version *ver,
d484 1
a484 1
            copy_string(c,det_mon->section.serial);
d488 1
a488 1
            copy_string(c,det_mon->section.ascii_data);
d492 1
a492 1
            get_monitor_ranges(c,&det_mon->section.ranges);
d496 1
a496 1
            copy_string(c,det_mon->section.name);
d500 1
a500 1
            get_whitepoint_section(c,det_mon->section.wp);
d504 1
a504 1
            get_dst_timing_section(c,det_mon->section.std_t, ver);
d515 1
a515 1
	    memcpy(det_mon->section.est_iii, c + 6, 6);
d524 1
a524 1
	if (c[3] <= 0x0F && memcmp(c, empty_block, sizeof(empty_block))) {
d527 2
a528 1
    } else {
d535 2
a536 2
get_dt_md_section(Uchar *c, struct edid_version *ver,
		  struct detailed_monitor_section *det_mon)
d540 1
a540 1
    for (i=0; i < DET_TIMINGS; i++) {
d547 1
a547 1
copy_string(Uchar *c, Uchar *s)
d549 8
a556 6
  int i;
  c = c + 5;
  for (i = 0; (i < 13 && *c != 0x0A); i++) 
    *(s++) = *(c++);
  *s = 0;
  while (i-- && (*--s == 0x20)) *s = 0;
d560 1
a560 2
get_dst_timing_section(Uchar *c, struct std_timings *t,
		       struct edid_version *v)
d562 2
a563 1
  int j;
d566 5
a570 5
	t[j].hsize = HSIZE1;
	VSIZE1(t[j].vsize);
	t[j].refresh = REFRESH_R;
	t[j].id = STD_TIMING_ID;
	NEXT_STD_TIMING;
d575 1
a575 1
get_monitor_ranges(Uchar *c, struct monitor_ranges *r)
d582 2
a583 2
    if(MAX_CLOCK != 0xff) /* is specified? */
	r->max_clock = MAX_CLOCK * 10 + 5;
d585 8
a592 7
	r->gtf_2nd_f = F_2ND_GTF;
	r->gtf_2nd_c = C_2ND_GTF;
	r->gtf_2nd_m = M_2ND_GTF;
	r->gtf_2nd_k = K_2ND_GTF;
	r->gtf_2nd_j = J_2ND_GTF;
    } else {
	r->gtf_2nd_f = 0;
d595 11
a605 10
	r->max_clock_khz = MAX_CLOCK_KHZ;
	r->max_clock = r->max_clock_khz / 1000;
	r->maxwidth = MAXWIDTH;
	r->supported_aspect = SUPPORTED_ASPECT;
	r->preferred_aspect = PREFERRED_ASPECT;
	r->supported_blanking = SUPPORTED_BLANKING;
	r->supported_scaling = SUPPORTED_SCALING;
	r->preferred_refresh = PREFERRED_REFRESH;
    } else {
	r->max_clock_khz = 0;
d610 1
a610 1
get_whitepoint_section(Uchar *c, struct whitePoints *wp)
d616 4
a619 4
    wp[0].index  = WHITE_INDEX1;
    wp[1].index  = WHITE_INDEX2;
    wp[0].white_gamma  = WHITE_GAMMA1;
    wp[1].white_gamma  = WHITE_GAMMA2;
d623 20
a642 20
get_detailed_timing_section(Uchar *c, struct detailed_timings *r)
{
  r->clock = PIXEL_CLOCK;
  r->h_active = H_ACTIVE;
  r->h_blanking = H_BLANK;
  r->v_active = V_ACTIVE;
  r->v_blanking = V_BLANK;
  r->h_sync_off = H_SYNC_OFF;
  r->h_sync_width = H_SYNC_WIDTH;
  r->v_sync_off = V_SYNC_OFF;
  r->v_sync_width = V_SYNC_WIDTH;
  r->h_size = H_SIZE;
  r->v_size = V_SIZE;
  r->h_border = H_BORDER;
  r->v_border = V_BORDER;
  r->interlaced = INTERLACED;
  r->stereo = STEREO;
  r->stereo_1 = STEREO1;
  r->sync = SYNC_T;
  r->misc = MISC;
d651 2
a652 3
	xf86DrvMsg(scrnIndex, X_ERROR, "Unknown EDID version %d\n",
		   r->version);
	return FALSE;
d656 3
a658 3
	xf86DrvMsg(scrnIndex, X_WARNING,
		   "Assuming version 1.%d is compatible with 1.%d\n",
		   r->revision, MAX_EDID_MINOR);
d673 1
a673 1
       return FALSE;
d676 1
a676 1
       return FALSE;
d679 1
a679 1
       return FALSE;
d681 1
a681 1
    edid = (char *)mon->rawData;
d683 1
a683 1
       return FALSE;
d687 2
a688 2
       if (edid[i * 128] == 0x02)
           break;
d690 1
a690 1
       return FALSE;
d696 1
a696 1
       return FALSE;
d700 1
a700 1
       char *x = edid + i;
d702 8
a709 8
       /* find a vendor specific block */
       if ((x[0] & 0xe0) >> 5 == 0x03) {
           int oui = (x[3] << 16) + (x[2] << 8) + x[1];

           /* find the HDMI vendor OUI */
           if (oui == 0x000c03)
               return TRUE;
       }
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d186 1
a186 1
    return (m);
d189 1
a189 1
    xfree(m);
d555 1
a555 1
	r->max_clock = MAX_CLOCK * 10;
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d6 5
a10 5
 * copy of this software and associated documentation files (the "Software")
 * to deal in the software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * them Software is furnished to do so, subject to the following conditions:
d17 6
a22 5
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTIBILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d45 2
d58 16
d76 1
a76 3
    int i, j;
    struct detailed_timings *preferred_timing;
    struct monitor_ranges *ranges;
d84 38
a121 20
    for (i = 0; i < 4; i++) {
	if (m->det_mon[i].type == DS_RANGES) {
	    ranges = &m->det_mon[i].section.ranges;
	    for (j = 0; j < 4; j++) {
		if (m->det_mon[j].type == DT) {
		    preferred_timing = &m->det_mon[j].section.d_timings;
		    if (!ranges->max_clock) continue; /* zero is legal */
		    if (ranges->max_clock * 1000000 < preferred_timing->clock) {
			xf86Msg(X_WARNING,
			    "EDID preferred timing clock %.2fMHz exceeds "
			    "claimed max %dMHz, fixing\n",
			    preferred_timing->clock / 1.0e6,
			    ranges->max_clock);
			ranges->max_clock =
			    (preferred_timing->clock+999999)/1000000;
			return;
		    }
		}
	    }
	}
d123 1
d125 2
a135 19
	int real_hsize = 0, real_vsize = 0;
	float target_aspect, timing_aspect;
	
	target_aspect = (float)m->features.hsize / (float)m->features.vsize;
	for (i = 0; i < 4; i++) {
	    if (m->det_mon[i].type == DT) {
		struct detailed_timings *timing;
		timing = &m->det_mon[i].section.d_timings;

		if (!timing->v_size)
		    continue;

		timing_aspect = (float)timing->h_size / (float)timing->v_size;
		if (fabs(1 - (timing_aspect / target_aspect)) < 0.05) {
		    real_hsize = max(real_hsize, timing->h_size);
		    real_vsize = max(real_vsize, timing->v_size);
		}
	    }
	}
d137 8
a144 1
	if (!real_hsize || !real_vsize) {
d146 2
a147 2
	} else if ((m->features.hsize * 10 == real_hsize) &&
		   (m->features.vsize * 10 == real_vsize)) {
d152 2
a153 2
	    m->features.hsize = (real_hsize + 5) / 10;
	    m->features.vsize = (real_vsize + 5) / 10;
d155 1
a155 1
	
d184 1
d193 135
d452 58
a509 1
get_dt_md_section(Uchar *c, struct edid_version *ver, 
d512 1
a512 4
  int i;
 
  for (i=0;i<DET_TIMINGS;i++) {  
    if (ver->version == 1 && ver->revision >= 1 && IS_MONITOR_DESC) {
d514 3
a516 49
      switch (MONITOR_DESC_TYPE) {
      case SERIAL_NUMBER:
	det_mon[i].type = DS_SERIAL;
	copy_string(c,det_mon[i].section.serial);
	break;
      case ASCII_STR:
	det_mon[i].type = DS_ASCII_STR;
	copy_string(c,det_mon[i].section.ascii_data);
	break;
      case MONITOR_RANGES:
	det_mon[i].type = DS_RANGES;
	get_monitor_ranges(c,&det_mon[i].section.ranges);
	break;
      case MONITOR_NAME:
	det_mon[i].type = DS_NAME;
	copy_string(c,det_mon[i].section.name);
	break;
      case ADD_COLOR_POINT:
	det_mon[i].type = DS_WHITE_P;
	get_whitepoint_section(c,det_mon[i].section.wp);
	break;
      case ADD_STD_TIMINGS:
	det_mon[i].type = DS_STD_TIMINGS;
	get_dst_timing_section(c,det_mon[i].section.std_t, ver);
	break;
      case COLOR_MANAGEMENT_DATA:
	det_mon[i].type = DS_CMD;
	break;
      case CVT_3BYTE_DATA:
	det_mon[i].type = DS_CVT;
	get_cvt_timing_section(c, det_mon[i].section.cvt);
	break;
      case ADD_EST_TIMINGS:
	det_mon[i].type = DS_EST_III;
	memcpy(det_mon[i].section.est_iii, c + 6, 6);
	break;
      case ADD_DUMMY:
	det_mon[i].type = DS_DUMMY;
        break;
      default:
        det_mon[i].type = DS_UNKOWN;
        break;
      }
      if (c[3] <= 0x0F && memcmp(c, empty_block, sizeof(empty_block))) {
	det_mon[i].type = DS_VENDOR + c[3];
      }
    } else {
      det_mon[i].type = DT;
      get_detailed_timing_section(c,&det_mon[i].section.d_timings);
a517 2
    NEXT_DT_MD_SECTION;
  }
d637 1
a637 1
_X_EXPORT Bool
@


1.3
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d166 14
d287 2
d332 1
d341 1
a341 1
      if (c[3] <= 0x0F) {
d344 1
a344 1
    } else { 
d414 8
a421 8
    wp[1].white_x = WHITEX1;
    wp[1].white_y = WHITEY1;
    wp[2].white_x = WHITEX2;
    wp[2].white_y = WHITEY2;
    wp[1].index  = WHITE_INDEX1;
    wp[2].index  = WHITE_INDEX2;
    wp[1].white_gamma  = WHITE_GAMMA1;
    wp[2].white_gamma  = WHITE_GAMMA2;
d464 53
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d118 7
a124 1
	if (real_hsize && real_vsize) {
a127 2
	} else {
	    m->features.hsize = m->features.vsize = 0;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 3

/* interpret_edid.c: interpret a primary EDID block
 * 
d3 21
d25 1
d88 41
d192 1
a192 1
    } else if (v->version > 1 || v->revision > 2)
d194 4
d223 28
d303 10
d320 3
d373 1
a373 1
    } else
d375 13
d426 1
d431 3
a433 5
    if (r->version != 1)
	return FALSE;
    if (r->revision > 3) {
	xf86DrvMsg(scrnIndex, X_ERROR,"EDID Version 1.%i not yet supported\n",
		   r->revision);
d436 6
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a306 1
#define MAX_EDID_MINOR 3
d313 5
a317 6

    if (r->revision > MAX_EDID_MINOR)
	xf86DrvMsg(scrnIndex, X_WARNING,
		   "Assuming version 1.%d is compatible with 1.%d\n",
		   r->revision, MAX_EDID_MINOR);

@

