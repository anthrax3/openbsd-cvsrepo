head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.21.20.10.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.07.27.19.02.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/* xf86DDC.c
 *
 * Copyright 1998,1999 by Egbert Eich <Egbert.Eich@@Physik.TU-Darmstadt.DE>
 */

/*
 * A note on terminology.  DDC1 is the original dumb serial protocol, and
 * can only do up to 128 bytes of EDID.  DDC2 is I2C-encapsulated and
 * introduces extension blocks.  EDID is the old display identification
 * block, DisplayID is the new one.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86DDC.h"
#include <string.h>

#define RETRIES 4

typedef enum {
    DDCOPT_NODDC1,
    DDCOPT_NODDC2,
    DDCOPT_NODDC
} DDCOpts;

static const OptionInfoRec DDCOptions[] = {
    {DDCOPT_NODDC1, "NoDDC1", OPTV_BOOLEAN, {0}, FALSE},
    {DDCOPT_NODDC2, "NoDDC2", OPTV_BOOLEAN, {0}, FALSE},
    {DDCOPT_NODDC, "NoDDC", OPTV_BOOLEAN, {0}, FALSE},
    {-1, NULL, OPTV_NONE, {0}, FALSE},
};

/* DDC1 */

static int
find_start(unsigned int *ptr)
{
    unsigned int comp[9], test[9];
    int i, j;

    for (i = 0; i < 9; i++) {
        comp[i] = *(ptr++);
        test[i] = 1;
    }
    for (i = 0; i < 127; i++) {
        for (j = 0; j < 9; j++) {
            test[j] = test[j] & !(comp[j] ^ *(ptr++));
        }
    }
    for (i = 0; i < 9; i++)
        if (test[i])
            return i + 1;
    return -1;
}

static unsigned char *
find_header(unsigned char *block)
{
    unsigned char *ptr, *head_ptr, *end;
    unsigned char header[] = { 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00 };

    ptr = block;
    end = block + EDID1_LEN;
    while (ptr < end) {
        int i;

        head_ptr = ptr;
        for (i = 0; i < 8; i++) {
            if (header[i] != *(head_ptr++))
                break;
            if (head_ptr == end)
                head_ptr = block;
        }
        if (i == 8)
            break;
        ptr++;
    }
    if (ptr == end)
        return NULL;
    return ptr;
}

static unsigned char *
resort(unsigned char *s_block)
{
    unsigned char *d_new, *d_ptr, *d_end, *s_ptr, *s_end;
    unsigned char tmp;

    s_ptr = find_header(s_block);
    if (!s_ptr)
        return NULL;
    s_end = s_block + EDID1_LEN;

    d_new = malloc(EDID1_LEN);
    if (!d_new)
        return NULL;
    d_end = d_new + EDID1_LEN;

    for (d_ptr = d_new; d_ptr < d_end; d_ptr++) {
        tmp = *(s_ptr++);
        *d_ptr = tmp;
        if (s_ptr == s_end)
            s_ptr = s_block;
    }
    free(s_block);
    return d_new;
}

static int
DDC_checksum(const unsigned char *block, int len)
{
    int i, result = 0;
    int not_null = 0;

    for (i = 0; i < len; i++) {
        not_null |= block[i];
        result += block[i];
    }

#ifdef DEBUG
    if (result & 0xFF)
        ErrorF("DDC checksum not correct\n");
    if (!not_null)
        ErrorF("DDC read all Null\n");
#endif

    /* catch the trivial case where all bytes are 0 */
    if (!not_null)
        return 1;

    return result & 0xFF;
}

static unsigned char *
GetEDID_DDC1(unsigned int *s_ptr)
{
    unsigned char *d_block, *d_pos;
    unsigned int *s_pos, *s_end;
    int s_start;
    int i, j;

    s_start = find_start(s_ptr);
    if (s_start == -1)
        return NULL;
    s_end = s_ptr + NUM;
    s_pos = s_ptr + s_start;
    d_block = malloc(EDID1_LEN);
    if (!d_block)
        return NULL;
    d_pos = d_block;
    for (i = 0; i < EDID1_LEN; i++) {
        for (j = 0; j < 8; j++) {
            *d_pos <<= 1;
            if (*s_pos) {
                *d_pos |= 0x01;
            }
            s_pos++;
            if (s_pos == s_end)
                s_pos = s_ptr;
        };
        s_pos++;
        if (s_pos == s_end)
            s_pos = s_ptr;
        d_pos++;
    }
    free(s_ptr);
    if (d_block && DDC_checksum(d_block, EDID1_LEN)) {
        free(d_block);
        return NULL;
    }
    return (resort(d_block));
}

/* fetch entire EDID record; DDC bit needs to be masked */
static unsigned int *
FetchEDID_DDC1(register ScrnInfoPtr pScrn,
               register unsigned int (*read_DDC) (ScrnInfoPtr))
{
    int count = NUM;
    unsigned int *ptr, *xp;

    ptr = xp = malloc(sizeof(int) * NUM);

    if (!ptr)
        return NULL;
    do {
        /* wait for next retrace */
        *xp = read_DDC(pScrn);
        xp++;
    } while (--count);
    return ptr;
}

/* test if DDC1  return 0 if not */
static Bool
TestDDC1(ScrnInfoPtr pScrn, unsigned int (*read_DDC) (ScrnInfoPtr))
{
    int old, count;

    old = read_DDC(pScrn);
    count = HEADER * BITS_PER_BYTE;
    do {
        /* wait for next retrace */
        if (old != read_DDC(pScrn))
            break;
    } while (count--);
    return count;
}

/*
 * read EDID record , pass it to callback function to interpret.
 * callback function will store it for further use by calling
 * function; it will also decide if we need to reread it
 */
static unsigned char *
EDIDRead_DDC1(ScrnInfoPtr pScrn, DDC1SetSpeedProc DDCSpeed,
              unsigned int (*read_DDC) (ScrnInfoPtr))
{
    unsigned char *EDID_block = NULL;
    int count = RETRIES;

    if (!read_DDC) {
        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
                   "chipset doesn't support DDC1\n");
        return NULL;
    };

    if (TestDDC1(pScrn, read_DDC) == -1) {
        xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "No DDC signal\n");
        return NULL;
    };

    if (DDCSpeed)
        DDCSpeed(pScrn, DDC_FAST);
    do {
        EDID_block = GetEDID_DDC1(FetchEDID_DDC1(pScrn, read_DDC));
        count--;
    } while (!EDID_block && count);
    if (DDCSpeed)
        DDCSpeed(pScrn, DDC_SLOW);

    return EDID_block;
}

/**
 * Attempts to probe the monitor for EDID information, if NoDDC and NoDDC1 are
 * unset.  EDID information blocks are interpreted and the results returned in
 * an xf86MonPtr.
 *
 * This function does not affect the list of modes used by drivers -- it is up
 * to the driver to decide policy on what to do with EDID information.
 *
 * @@return pointer to a new xf86MonPtr containing the EDID information.
 * @@return NULL if no monitor attached or failure to interpret the EDID.
 */
xf86MonPtr
xf86DoEDID_DDC1(ScrnInfoPtr pScrn, DDC1SetSpeedProc DDC1SetSpeed,
                unsigned int (*DDC1Read) (ScrnInfoPtr))
{
    unsigned char *EDID_block = NULL;
    xf86MonPtr tmp = NULL;

    /* Default DDC and DDC1 to enabled. */
    Bool noddc = FALSE, noddc1 = FALSE;
    OptionInfoPtr options;

    options = xnfalloc(sizeof(DDCOptions));
    (void) memcpy(options, DDCOptions, sizeof(DDCOptions));
    xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, options);

    xf86GetOptValBool(options, DDCOPT_NODDC, &noddc);
    xf86GetOptValBool(options, DDCOPT_NODDC1, &noddc1);
    free(options);

    if (noddc || noddc1)
        return NULL;

    OsBlockSignals();
    EDID_block = EDIDRead_DDC1(pScrn, DDC1SetSpeed, DDC1Read);
    OsReleaseSignals();

    if (EDID_block) {
        tmp = xf86InterpretEDID(pScrn->scrnIndex, EDID_block);
    }
#ifdef DEBUG
    else
        ErrorF("No EDID block returned\n");
    if (!tmp)
        ErrorF("Cannot interpret EDID block\n");
#endif
    return tmp;
}

/* DDC2 */

static I2CDevPtr
DDC2MakeDevice(I2CBusPtr pBus, int address, const char *name)
{
    I2CDevPtr dev = NULL;

    if (!(dev = xf86I2CFindDev(pBus, address))) {
        dev = xf86CreateI2CDevRec();
        dev->DevName = name;
        dev->SlaveAddr = address;
        dev->ByteTimeout = 2200;        /* VESA DDC spec 3 p. 43 (+10 %) */
        dev->StartTimeout = 550;
        dev->BitTimeout = 40;
        dev->AcknTimeout = 40;

        dev->pI2CBus = pBus;
        if (!xf86I2CDevInit(dev)) {
            xf86DrvMsg(pBus->scrnIndex, X_PROBED, "No DDC2 device\n");
            return NULL;
        }
    }

    return dev;
}

static I2CDevPtr
DDC2Init(I2CBusPtr pBus)
{
    I2CDevPtr dev = NULL;

    /*
     * Slow down the bus so that older monitors don't
     * miss things.
     */
    pBus->RiseFallTime = 20;

    dev = DDC2MakeDevice(pBus, 0x00A0, "ddc2");
    if (xf86I2CProbeAddress(pBus, 0x0060))
        DDC2MakeDevice(pBus, 0x0060, "E-EDID segment register");

    return dev;
}

/* Mmmm, smell the hacks */
static void
EEDIDStop(I2CDevPtr d)
{
}

/* block is the EDID block number.  a segment is two blocks. */
static Bool
DDC2Read(I2CDevPtr dev, int block, unsigned char *R_Buffer)
{
    unsigned char W_Buffer[1];
    int i, segment;
    I2CDevPtr seg;
    void (*stop) (I2CDevPtr);

    for (i = 0; i < RETRIES; i++) {
        /* Stop bits reset the segment pointer to 0, so be careful here. */
        segment = block >> 1;
        if (segment) {
            Bool b;

            if (!(seg = xf86I2CFindDev(dev->pI2CBus, 0x0060)))
                return FALSE;

            W_Buffer[0] = segment;

            stop = dev->pI2CBus->I2CStop;
            dev->pI2CBus->I2CStop = EEDIDStop;

            b = xf86I2CWriteRead(seg, W_Buffer, 1, NULL, 0);

            dev->pI2CBus->I2CStop = stop;
            if (!b) {
                dev->pI2CBus->I2CStop(dev);
                continue;
            }
        }

        W_Buffer[0] = (block & 0x01) * EDID1_LEN;

        if (xf86I2CWriteRead(dev, W_Buffer, 1, R_Buffer, EDID1_LEN)) {
            if (!DDC_checksum(R_Buffer, EDID1_LEN))
                return TRUE;
        }
    }

    return FALSE;
}

/**
 * Attempts to probe the monitor for EDID information, if NoDDC and NoDDC2 are
 * unset.  EDID information blocks are interpreted and the results returned in
 * an xf86MonPtr.  Unlike xf86DoEDID_DDC[12](), this function will return
 * the complete EDID data, including all extension blocks, if the 'complete'
 * parameter is TRUE;
 *
 * This function does not affect the list of modes used by drivers -- it is up
 * to the driver to decide policy on what to do with EDID information.
 *
 * @@return pointer to a new xf86MonPtr containing the EDID information.
 * @@return NULL if no monitor attached or failure to interpret the EDID.
 */
xf86MonPtr
xf86DoEEDID(ScrnInfoPtr pScrn, I2CBusPtr pBus, Bool complete)
{
    unsigned char *EDID_block = NULL;
    xf86MonPtr tmp = NULL;
    I2CDevPtr dev = NULL;

    /* Default DDC and DDC2 to enabled. */
    Bool noddc = FALSE, noddc2 = FALSE;
    OptionInfoPtr options;

    options = malloc(sizeof(DDCOptions));
    if (!options)
        return NULL;
    memcpy(options, DDCOptions, sizeof(DDCOptions));
    xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, options);

    xf86GetOptValBool(options, DDCOPT_NODDC, &noddc);
    xf86GetOptValBool(options, DDCOPT_NODDC2, &noddc2);
    free(options);

    if (noddc || noddc2)
        return NULL;

    if (!(dev = DDC2Init(pBus)))
        return NULL;

    EDID_block = calloc(1, EDID1_LEN);
    if (!EDID_block)
        return NULL;

    if (DDC2Read(dev, 0, EDID_block)) {
        int i, n = EDID_block[0x7e];

        if (complete && n) {
            EDID_block = reallocarray(EDID_block, 1 + n, EDID1_LEN);

            for (i = 0; i < n; i++)
                DDC2Read(dev, i + 1, EDID_block + (EDID1_LEN * (1 + i)));
        }

        tmp = xf86InterpretEEDID(pScrn->scrnIndex, EDID_block);
    }

    if (tmp && complete)
        tmp->flags |= MONITOR_EDID_COMPLETE_RAWDATA;

    return tmp;
}

/**
 * Attempts to probe the monitor for EDID information, if NoDDC and NoDDC2 are
 * unset.  EDID information blocks are interpreted and the results returned in
 * an xf86MonPtr.
 *
 * This function does not affect the list of modes used by drivers -- it is up
 * to the driver to decide policy on what to do with EDID information.
 *
 * @@return pointer to a new xf86MonPtr containing the EDID information.
 * @@return NULL if no monitor attached or failure to interpret the EDID.
 */
xf86MonPtr
xf86DoEDID_DDC2(ScrnInfoPtr pScrn, I2CBusPtr pBus)
{
    return xf86DoEEDID(pScrn, pBus, FALSE);
}
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d440 1
a440 1
            EDID_block = realloc(EDID_block, EDID1_LEN * (1 + n));
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1 2
a2 2
/* xf86DDC.c 
 * 
d215 1
a215 1
/* 
d218 1
a218 1
 * function; it will also decide if we need to reread it 
d331 1
a331 1
     * Slow down the bus so that older monitors don't 
a469 58
}

/* XXX write me */
static void *
DDC2ReadDisplayID(void)
{
    return FALSE;
}

/**
 * Attempts to probe the monitor for DisplayID information, if NoDDC and
 * NoDDC2 are unset.  DisplayID blocks are interpreted and the results
 * returned in an xf86MonPtr.
 *
 * This function does not affect the list of modes used by drivers -- it is up
 * to the driver to decide policy on what to do with DisplayID information.
 *
 * @@return pointer to a new xf86MonPtr containing the DisplayID information.
 * @@return NULL if no monitor attached or failure to interpret the DisplayID.
 */
xf86MonPtr
xf86DoDisplayID(ScrnInfoPtr pScrn, I2CBusPtr pBus)
{
    unsigned char *did = NULL;
    xf86MonPtr tmp = NULL;
    I2CDevPtr dev = NULL;

    /* Default DDC and DDC2 to enabled. */
    Bool noddc = FALSE, noddc2 = FALSE;
    OptionInfoPtr options;

    options = malloc(sizeof(DDCOptions));
    if (!options)
        return NULL;
    memcpy(options, DDCOptions, sizeof(DDCOptions));
    xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, options);

    xf86GetOptValBool(options, DDCOPT_NODDC, &noddc);
    xf86GetOptValBool(options, DDCOPT_NODDC2, &noddc2);
    free(options);

    if (noddc || noddc2)
        return NULL;

    if (!(dev = DDC2Init(pBus)))
        return NULL;

    if ((did = DDC2ReadDisplayID())) {
        tmp = calloc(1, sizeof(*tmp));
        if (!tmp)
            return NULL;

        tmp->scrnIndex = pScrn->scrnIndex;
        tmp->flags |= MONITOR_DISPLAYID;
        tmp->rawData = did;
    }

    return tmp;
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d302 1
a302 1
DDC2MakeDevice(I2CBusPtr pBus, int address, char *name)
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d94 3
d98 1
a103 3
    s_ptr = find_header(s_block);
    if (!s_ptr)
        return NULL;
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d261 1
a261 1
xf86DoEDID_DDC1(int scrnIndex, DDC1SetSpeedProc DDC1SetSpeed,
a263 1
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d287 1
a287 1
        tmp = xf86InterpretEDID(scrnIndex, EDID_block);
d325 1
a325 1
DDC2Init(int scrnIndex, I2CBusPtr pBus)
d405 1
a405 1
xf86DoEEDID(int scrnIndex, I2CBusPtr pBus, Bool complete)
a406 1
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d428 1
a428 1
    if (!(dev = DDC2Init(scrnIndex, pBus)))
d445 1
a445 1
        tmp = xf86InterpretEEDID(scrnIndex, EDID_block);
d466 1
a466 1
xf86DoEDID_DDC2(int scrnIndex, I2CBusPtr pBus)
d468 1
a468 1
    return xf86DoEEDID(scrnIndex, pBus, FALSE);
d490 1
a490 1
xf86DoDisplayID(int scrnIndex, I2CBusPtr pBus)
a491 1
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d513 1
a513 1
    if (!(dev = DDC2Init(scrnIndex, pBus)))
d521 1
a521 1
        tmp->scrnIndex = scrnIndex;
@


1.4
log
@Update to xserver 1.11.2
@
text
@d32 4
a35 4
    { DDCOPT_NODDC1,	"NoDDC1",	OPTV_BOOLEAN,	{0},	FALSE },
    { DDCOPT_NODDC2,	"NoDDC2",	OPTV_BOOLEAN,	{0},	FALSE },
    { DDCOPT_NODDC,	"NoDDC",	OPTV_BOOLEAN,	{0},	FALSE },
    { -1,		NULL,		OPTV_NONE,	{0},	FALSE },
d44 14
a57 13
    int i,j;
  
    for (i=0;i<9;i++){
	comp[i] = *(ptr++);
	test[i] = 1;
    }
    for (i=0;i<127;i++){
	for (j=0;j<9;j++){
	    test[j] = test[j] & !(comp[j] ^ *(ptr++));
	}
    }
    for (i=0;i<9;i++)
	if (test[i]) return i+1;
d65 2
a66 2
    unsigned char header[]={0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00};
 
d69 13
a81 9
    while (ptr<end) {
	int i;
	head_ptr = ptr;
	for (i=0;i<8;i++){
	    if (header[i] != *(head_ptr++)) break;
	    if (head_ptr == end) head_ptr = block;
	}
	if (i==8) break;
	ptr++; 
d83 2
a84 1
    if (ptr == end) return NULL;
d96 2
a97 1
    if (!d_new) return NULL;
d101 7
a107 5
    if (!s_ptr) return NULL;
    for (d_ptr=d_new;d_ptr<d_end;d_ptr++){
	tmp = *(s_ptr++);
	*d_ptr = tmp; 
	if (s_ptr == s_end) s_ptr = s_block;
d118 4
a121 4
    
    for (i=0;i<len;i++) {
	not_null |= block[i];
	result += block[i];
d123 1
a123 1
    
d125 4
a128 2
    if (result & 0xFF) ErrorF("DDC checksum not correct\n");
    if (!not_null) ErrorF("DDC read all Null\n");
d132 2
a133 1
    if (!not_null) return 1;
d135 1
a135 1
    return result&0xFF;
d144 2
a145 1
    int i,j;
d147 2
a148 1
    if (s_start==-1) return NULL;
d151 3
a153 2
    d_block=malloc(EDID1_LEN);
    if (!d_block) return NULL;
d155 14
a168 10
    for (i=0;i<EDID1_LEN;i++) {
	for (j=0;j<8;j++) {
	    *d_pos <<= 1;
	    if (*s_pos) {
		*d_pos |= 0x01;
	    }
	    s_pos++; if (s_pos == s_end) s_pos=s_ptr;
	};
	s_pos++; if (s_pos == s_end) s_pos=s_ptr;
	d_pos++;
d171 3
a173 3
    if (d_block && DDC_checksum(d_block,EDID1_LEN)) {
	free(d_block);
	return NULL;
d179 1
a179 1
static unsigned int * 
d181 1
a181 1
	       register unsigned int (*read_DDC)(ScrnInfoPtr))
d186 1
a186 1
    ptr=xp=malloc(sizeof(int)*NUM);
d188 2
a189 1
    if (!ptr)  return NULL;
d191 4
a194 4
	/* wait for next retrace */
	*xp = read_DDC(pScrn);
	xp++;
    } while(--count);
d200 1
a200 1
TestDDC1(ScrnInfoPtr pScrn, unsigned int (*read_DDC)(ScrnInfoPtr))
d207 4
a210 3
	/* wait for next retrace */
	if (old != read_DDC(pScrn)) break;
    } while(count--);
d220 2
a221 2
EDIDRead_DDC1(ScrnInfoPtr pScrn, DDC1SetSpeedProc DDCSpeed, 
              unsigned int (*read_DDC)(ScrnInfoPtr))
d226 4
a229 4
    if (!read_DDC) { 
	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, 
		   "chipset doesn't support DDC1\n");
	return NULL; 
d232 3
a234 3
    if (TestDDC1(pScrn,read_DDC)==-1) { 
	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "No DDC signal\n"); 
	return NULL; 
d237 2
a238 1
    if (DDCSpeed) DDCSpeed(pScrn,DDC_FAST);
d240 2
a241 2
	EDID_block = GetEDID_DDC1(FetchEDID_DDC1(pScrn,read_DDC)); 
	count --;
d243 2
a244 1
    if (DDCSpeed) DDCSpeed(pScrn,DDC_SLOW);
d261 2
a262 2
xf86DoEDID_DDC1(int scrnIndex, DDC1SetSpeedProc DDC1SetSpeed, 
		unsigned int (*DDC1Read)(ScrnInfoPtr))
d267 1
d273 1
a273 1
    (void)memcpy(options, DDCOptions, sizeof(DDCOptions));
d279 1
a279 1
    
d281 2
a282 2
	return NULL;
    
d284 1
a284 1
    EDID_block = EDIDRead_DDC1(pScrn,DDC1SetSpeed,DDC1Read);
d287 2
a288 2
    if (EDID_block){
	tmp = xf86InterpretEDID(scrnIndex,EDID_block);
d291 2
a292 1
	else ErrorF("No EDID block returned\n");
d294 1
a294 1
	ErrorF("Cannot interpret EDID block\n");
d296 1
a296 1
	return tmp;
d307 13
a319 13
	dev = xf86CreateI2CDevRec();
	dev->DevName = name;
	dev->SlaveAddr = address;
	dev->ByteTimeout = 2200; /* VESA DDC spec 3 p. 43 (+10 %) */
	dev->StartTimeout = 550;
	dev->BitTimeout = 40;
	dev->AcknTimeout = 40;

	dev->pI2CBus = pBus;
	if (!xf86I2CDevInit(dev)) {
	    xf86DrvMsg(pBus->scrnIndex, X_PROBED, "No DDC2 device\n");
	    return NULL;
	}
d335 1
a335 1
 
d338 1
a338 1
	DDC2MakeDevice(pBus, 0x0060, "E-EDID segment register");
d356 1
a356 1
    void (*stop)(I2CDevPtr);
d359 28
a386 28
	/* Stop bits reset the segment pointer to 0, so be careful here. */
	segment = block >> 1;
	if (segment) {
	    Bool b;
	    
	    if (!(seg = xf86I2CFindDev(dev->pI2CBus, 0x0060)))
		return FALSE;

	    W_Buffer[0] = segment;

	    stop = dev->pI2CBus->I2CStop;
	    dev->pI2CBus->I2CStop = EEDIDStop;

	    b = xf86I2CWriteRead(seg, W_Buffer, 1, NULL, 0);

	    dev->pI2CBus->I2CStop = stop;
	    if (!b) {
		dev->pI2CBus->I2CStop(dev);
		continue;
	    }
	}

	W_Buffer[0] = (block & 0x01) * EDID1_LEN;

	if (xf86I2CWriteRead(dev, W_Buffer, 1, R_Buffer, EDID1_LEN)) {
	    if (!DDC_checksum(R_Buffer, EDID1_LEN))
		return TRUE;
	}
d388 1
a388 1
 
d412 1
d419 1
a419 1
	return NULL;
d428 1
a428 1
	return NULL;
d431 1
a431 1
	return NULL;
d435 1
a435 1
	return NULL;
d438 1
a438 1
	int i, n = EDID_block[0x7e];
d440 2
a441 2
	if (complete && n) {
	    EDID_block = realloc(EDID_block, EDID1_LEN * (1+n));
d443 3
a445 3
	    for (i = 0; i < n; i++)
		DDC2Read(dev, i+1, EDID_block + (EDID1_LEN * (1+i)));
	}
d447 1
a447 1
	tmp = xf86InterpretEEDID(scrnIndex, EDID_block);
d451 1
a451 1
	tmp->flags |= MONITOR_EDID_COMPLETE_RAWDATA;
d498 1
d505 1
a505 1
	return NULL;
d514 1
a514 1
	return NULL;
d517 1
a517 1
	return NULL;
d520 7
a526 7
	tmp = calloc(1, sizeof(*tmp));
	if (!tmp)
	    return NULL;

	tmp->scrnIndex = scrnIndex;
	tmp->flags |= MONITOR_DISPLAYID;
	tmp->rawData = did;
@


1.3
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d238 2
a239 4
xf86DoEDID_DDC1(
    int scrnIndex, DDC1SetSpeedProc DDC1SetSpeed, 
    unsigned int (*DDC1Read)(ScrnInfoPtr)
)
a243 1
    int sigio;
d259 1
a259 1
    sigio = xf86BlockSIGIO();
d261 1
a261 1
    xf86UnblockSIGIO(sigio);
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a316 4
    if (xf86I2CProbeAddress(pBus, 0x0062))
	DDC2MakeDevice(pBus, 0x0062, "EDID EEPROM interface");
    if (xf86I2CProbeAddress(pBus, 0x006E))
	DDC2MakeDevice(pBus, 0x006E, "DDC control interface");
@


1.1
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d56 2
a57 2
	if (test[i]) return (i+1);
    return (-1);
d78 2
a79 2
    if (ptr == end) return (NULL);
    return (ptr);
d89 1
a89 1
    d_new = xalloc(EDID1_LEN);
d100 2
a101 2
    xfree(s_block);
    return (d_new);
d105 1
a105 1
DDC_checksum(unsigned char *block, int len)
d123 1
a123 1
    return (result&0xFF);
d137 1
a137 1
    d_block=xalloc(EDID1_LEN);
d151 5
a155 2
    xfree(s_ptr);
    if (d_block && DDC_checksum(d_block,EDID1_LEN)) return NULL;
d167 1
a167 1
    ptr=xp=xalloc(sizeof(int)*NUM); 
d175 1
a175 1
    return (ptr);
d190 1
a190 1
    return (count);
d257 1
a257 1
    xfree(options);
d398 1
a398 1
    options = xalloc(sizeof(DDCOptions));
d406 1
a406 1
    xfree(options);
d414 1
a414 1
    EDID_block = xcalloc(1, EDID1_LEN);
d422 1
a422 1
	    EDID_block = xrealloc(EDID_block, EDID1_LEN * (1+n));
d483 1
a483 1
    options = xalloc(sizeof(DDCOptions));
d491 1
a491 1
    xfree(options);
d500 1
a500 1
	tmp = xcalloc(1, sizeof(*tmp));
@

