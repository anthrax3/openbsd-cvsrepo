head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2016.05.29.12.02.38;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	s0SI41sEunLdyFfd;

1.7
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2012.06.10.13.21.27;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.04.02.16.08.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.21.20.10.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.18.17;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.18.17;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/****************************************************************************
*
*						Realmode X86 Emulator Library
*
*            	Copyright (C) 1996-1999 SciTech Software, Inc.
* 				     Copyright (C) David Mosberger-Tang
* 					   Copyright (C) 1999 Egbert Eich
*
*  ========================================================================
*
*  Permission to use, copy, modify, distribute, and sell this software and
*  its documentation for any purpose is hereby granted without fee,
*  provided that the above copyright notice appear in all copies and that
*  both that copyright notice and this permission notice appear in
*  supporting documentation, and that the name of the authors not be used
*  in advertising or publicity pertaining to distribution of the software
*  without specific, written prior permission.  The authors makes no
*  representations about the suitability of this software for any purpose.
*  It is provided "as is" without express or implied warranty.
*
*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
*  PERFORMANCE OF THIS SOFTWARE.
*
*  ========================================================================
*
* Language:		ANSI C
* Environment:	Any
* Developer:    Kendall Bennett
*
* Description:  This file includes subroutines to implement the decoding
*               and emulation of all the x86 processor instructions.
*
* There are approximately 250 subroutines in here, which correspond
* to the 256 byte-"opcodes" found on the 8086.  The table which
* dispatches this is found in the files optab.[ch].
*
* Each opcode proc has a comment preceeding it which gives it's table
* address.  Several opcodes are missing (undefined) in the table.
*
* Each proc includes information for decoding (DECODE_PRINTF and
* DECODE_PRINTF2), debugging (TRACE_REGS, SINGLE_STEP), and misc
* functions (START_OF_INSTR, END_OF_INSTR).
*
* Many of the procedures are *VERY* similar in coding.  This has
* allowed for a very large amount of code to be generated in a fairly
* short amount of time (i.e. cut, paste, and modify).  The result is
* that much of the code below could have been folded into subroutines
* for a large reduction in size of this file.  The downside would be
* that there would be a penalty in execution speed.  The file could
* also have been *MUCH* larger by inlining certain functions which
* were called.  This could have resulted even faster execution.  The
* prime directive I used to decide whether to inline the code or to
* modularize it, was basically: 1) no unnecessary subroutine calls,
* 2) no routines more than about 200 lines in size, and 3) modularize
* any code that I might not get right the first time.  The fetch_*
* subroutines fall into the latter category.  The The decode_* fall
* into the second category.  The coding of the "switch(mod){ .... }"
* in many of the subroutines below falls into the first category.
* Especially, the coding of {add,and,or,sub,...}_{byte,word}
* subroutines are an especially glaring case of the third guideline.
* Since so much of the code is cloned from other modules (compare
* opcode #00 to opcode #01), making the basic operations subroutine
* calls is especially important; otherwise mistakes in coding an
* "add" would represent a nightmare in maintenance.
*
****************************************************************************/

#include "x86emu/x86emui.h"

/*----------------------------- Implementation ----------------------------*/

/****************************************************************************
PARAMETERS:
op1 - Instruction op code

REMARKS:
Handles illegal opcodes.
****************************************************************************/
static void
x86emuOp_illegal_op(u8 op1)
{
    START_OF_INSTR();
    if (M.x86.R_SP != 0) {
        DECODE_PRINTF("ILLEGAL X86 OPCODE\n");
        TRACE_REGS();
        DB(printk("%04x:%04x: %02X ILLEGAL X86 OPCODE!\n",
                  M.x86.R_CS, M.x86.R_IP - 1, op1));
        HALT_SYS();
    }
    else {
        /* If we get here, it means the stack pointer is back to zero
         * so we are just returning from an emulator service call
         * so therte is no need to display an error message. We trap
         * the emulator with an 0xF1 opcode to finish the service
         * call.
         */
        X86EMU_halt_sys();
    }
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x00
****************************************************************************/
static void
x86emuOp_add_byte_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;
    u8 *destreg, *srcreg;
    u8 destval;

    START_OF_INSTR();
    DECODE_PRINTF("ADD\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = add_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 1:
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = add_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 2:
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = add_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = add_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x01
****************************************************************************/
static void
x86emuOp_add_word_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("ADD\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = add_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = add_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = add_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = add_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = add_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = add_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = add_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = add_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x02
****************************************************************************/
static void
x86emuOp_add_byte_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint srcoffset;
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("ADD\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = add_byte(*destreg, srcval);
        break;
    case 1:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = add_byte(*destreg, srcval);
        break;
    case 2:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = add_byte(*destreg, srcval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = add_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x03
****************************************************************************/
static void
x86emuOp_add_word_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("ADD\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = add_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = add_word(*destreg, srcval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = add_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = add_word(*destreg, srcval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = add_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = add_word(*destreg, srcval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = add_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = add_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x04
****************************************************************************/
static void
x86emuOp_add_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("ADD\tAL,");
    srcval = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    M.x86.R_AL = add_byte(M.x86.R_AL, srcval);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x05
****************************************************************************/
static void
x86emuOp_add_word_AX_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("ADD\tEAX,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("ADD\tAX,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EAX = add_long(M.x86.R_EAX, srcval);
    }
    else {
        M.x86.R_AX = add_word(M.x86.R_AX, (u16) srcval);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x06
****************************************************************************/
static void
x86emuOp_push_ES(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("PUSH\tES\n");
    TRACE_AND_STEP();
    push_word(M.x86.R_ES);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x07
****************************************************************************/
static void
x86emuOp_pop_ES(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("POP\tES\n");
    TRACE_AND_STEP();
    M.x86.R_ES = pop_word();
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x08
****************************************************************************/
static void
x86emuOp_or_byte_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint destoffset;
    u8 destval;

    START_OF_INSTR();
    DECODE_PRINTF("OR\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = or_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 1:
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = or_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 2:
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = or_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = or_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x09
****************************************************************************/
static void
x86emuOp_or_word_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("OR\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = or_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = or_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = or_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = or_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = or_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = or_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = or_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = or_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0a
****************************************************************************/
static void
x86emuOp_or_byte_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint srcoffset;
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("OR\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = or_byte(*destreg, srcval);
        break;
    case 1:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = or_byte(*destreg, srcval);
        break;
    case 2:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = or_byte(*destreg, srcval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = or_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0b
****************************************************************************/
static void
x86emuOp_or_word_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("OR\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = or_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = or_word(*destreg, srcval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = or_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = or_word(*destreg, srcval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = or_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = or_word(*destreg, srcval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = or_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = or_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0c
****************************************************************************/
static void
x86emuOp_or_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("OR\tAL,");
    srcval = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    M.x86.R_AL = or_byte(M.x86.R_AL, srcval);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0d
****************************************************************************/
static void
x86emuOp_or_word_AX_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("OR\tEAX,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("OR\tAX,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EAX = or_long(M.x86.R_EAX, srcval);
    }
    else {
        M.x86.R_AX = or_word(M.x86.R_AX, (u16) srcval);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0e
****************************************************************************/
static void
x86emuOp_push_CS(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("PUSH\tCS\n");
    TRACE_AND_STEP();
    push_word(M.x86.R_CS);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f. Escape for two-byte opcode (286 or better)
****************************************************************************/
static void
x86emuOp_two_byte(u8 X86EMU_UNUSED(op1))
{
    u8 op2 = (*sys_rdb) (((u32) M.x86.R_CS << 4) + (M.x86.R_IP++));

    INC_DECODED_INST_LEN(1);
    (*x86emu_optab2[op2]) (op2);
}

/****************************************************************************
REMARKS:
Handles opcode 0x10
****************************************************************************/
static void
x86emuOp_adc_byte_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint destoffset;
    u8 destval;

    START_OF_INSTR();
    DECODE_PRINTF("ADC\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = adc_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 1:
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = adc_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 2:
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = adc_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = adc_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x11
****************************************************************************/
static void
x86emuOp_adc_word_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("ADC\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = adc_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = adc_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = adc_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = adc_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = adc_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = adc_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = adc_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = adc_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x12
****************************************************************************/
static void
x86emuOp_adc_byte_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint srcoffset;
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("ADC\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = adc_byte(*destreg, srcval);
        break;
    case 1:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = adc_byte(*destreg, srcval);
        break;
    case 2:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = adc_byte(*destreg, srcval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = adc_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x13
****************************************************************************/
static void
x86emuOp_adc_word_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("ADC\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = adc_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = adc_word(*destreg, srcval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = adc_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = adc_word(*destreg, srcval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = adc_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = adc_word(*destreg, srcval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = adc_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = adc_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x14
****************************************************************************/
static void
x86emuOp_adc_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("ADC\tAL,");
    srcval = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    M.x86.R_AL = adc_byte(M.x86.R_AL, srcval);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x15
****************************************************************************/
static void
x86emuOp_adc_word_AX_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("ADC\tEAX,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("ADC\tAX,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EAX = adc_long(M.x86.R_EAX, srcval);
    }
    else {
        M.x86.R_AX = adc_word(M.x86.R_AX, (u16) srcval);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x16
****************************************************************************/
static void
x86emuOp_push_SS(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("PUSH\tSS\n");
    TRACE_AND_STEP();
    push_word(M.x86.R_SS);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x17
****************************************************************************/
static void
x86emuOp_pop_SS(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("POP\tSS\n");
    TRACE_AND_STEP();
    M.x86.R_SS = pop_word();
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x18
****************************************************************************/
static void
x86emuOp_sbb_byte_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint destoffset;
    u8 destval;

    START_OF_INSTR();
    DECODE_PRINTF("SBB\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = sbb_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 1:
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = sbb_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 2:
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = sbb_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = sbb_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x19
****************************************************************************/
static void
x86emuOp_sbb_word_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("SBB\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = sbb_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = sbb_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = sbb_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = sbb_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = sbb_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = sbb_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sbb_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sbb_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x1a
****************************************************************************/
static void
x86emuOp_sbb_byte_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint srcoffset;
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("SBB\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = sbb_byte(*destreg, srcval);
        break;
    case 1:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = sbb_byte(*destreg, srcval);
        break;
    case 2:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = sbb_byte(*destreg, srcval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = sbb_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x1b
****************************************************************************/
static void
x86emuOp_sbb_word_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("SBB\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sbb_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sbb_word(*destreg, srcval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sbb_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sbb_word(*destreg, srcval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sbb_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sbb_word(*destreg, srcval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sbb_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sbb_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x1c
****************************************************************************/
static void
x86emuOp_sbb_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("SBB\tAL,");
    srcval = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    M.x86.R_AL = sbb_byte(M.x86.R_AL, srcval);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x1d
****************************************************************************/
static void
x86emuOp_sbb_word_AX_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("SBB\tEAX,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("SBB\tAX,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EAX = sbb_long(M.x86.R_EAX, srcval);
    }
    else {
        M.x86.R_AX = sbb_word(M.x86.R_AX, (u16) srcval);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x1e
****************************************************************************/
static void
x86emuOp_push_DS(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("PUSH\tDS\n");
    TRACE_AND_STEP();
    push_word(M.x86.R_DS);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x1f
****************************************************************************/
static void
x86emuOp_pop_DS(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("POP\tDS\n");
    TRACE_AND_STEP();
    M.x86.R_DS = pop_word();
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x20
****************************************************************************/
static void
x86emuOp_and_byte_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint destoffset;
    u8 destval;

    START_OF_INSTR();
    DECODE_PRINTF("AND\t");
    FETCH_DECODE_MODRM(mod, rh, rl);

    switch (mod) {
    case 0:
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = and_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;

    case 1:
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = and_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;

    case 2:
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = and_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;

    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = and_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x21
****************************************************************************/
static void
x86emuOp_and_word_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("AND\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = and_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = and_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = and_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = and_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = and_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = and_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = and_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = and_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x22
****************************************************************************/
static void
x86emuOp_and_byte_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint srcoffset;
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("AND\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = and_byte(*destreg, srcval);
        break;
    case 1:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = and_byte(*destreg, srcval);
        break;
    case 2:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = and_byte(*destreg, srcval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = and_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x23
****************************************************************************/
static void
x86emuOp_and_word_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("AND\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = and_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = and_word(*destreg, srcval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = and_long(*destreg, srcval);
            break;
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = and_word(*destreg, srcval);
            break;
        }
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = and_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = and_word(*destreg, srcval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = and_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = and_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x24
****************************************************************************/
static void
x86emuOp_and_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("AND\tAL,");
    srcval = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    M.x86.R_AL = and_byte(M.x86.R_AL, srcval);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x25
****************************************************************************/
static void
x86emuOp_and_word_AX_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("AND\tEAX,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("AND\tAX,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EAX = and_long(M.x86.R_EAX, srcval);
    }
    else {
        M.x86.R_AX = and_word(M.x86.R_AX, (u16) srcval);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x26
****************************************************************************/
static void
x86emuOp_segovr_ES(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("ES:\n");
    TRACE_AND_STEP();
    M.x86.mode |= SYSMODE_SEGOVR_ES;
    /*
     * note the lack of DECODE_CLEAR_SEGOVR(r) since, here is one of 4
     * opcode subroutines we do not want to do this.
     */
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x27
****************************************************************************/
static void
x86emuOp_daa(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("DAA\n");
    TRACE_AND_STEP();
    M.x86.R_AL = daa_byte(M.x86.R_AL);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x28
****************************************************************************/
static void
x86emuOp_sub_byte_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint destoffset;
    u8 destval;

    START_OF_INSTR();
    DECODE_PRINTF("SUB\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = sub_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 1:
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = sub_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 2:
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = sub_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = sub_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x29
****************************************************************************/
static void
x86emuOp_sub_word_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("SUB\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = sub_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = sub_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = sub_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = sub_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = sub_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = sub_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sub_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sub_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x2a
****************************************************************************/
static void
x86emuOp_sub_byte_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint srcoffset;
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("SUB\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = sub_byte(*destreg, srcval);
        break;
    case 1:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = sub_byte(*destreg, srcval);
        break;
    case 2:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = sub_byte(*destreg, srcval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = sub_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x2b
****************************************************************************/
static void
x86emuOp_sub_word_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("SUB\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sub_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sub_word(*destreg, srcval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sub_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sub_word(*destreg, srcval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sub_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sub_word(*destreg, srcval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sub_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = sub_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x2c
****************************************************************************/
static void
x86emuOp_sub_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("SUB\tAL,");
    srcval = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    M.x86.R_AL = sub_byte(M.x86.R_AL, srcval);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x2d
****************************************************************************/
static void
x86emuOp_sub_word_AX_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("SUB\tEAX,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("SUB\tAX,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EAX = sub_long(M.x86.R_EAX, srcval);
    }
    else {
        M.x86.R_AX = sub_word(M.x86.R_AX, (u16) srcval);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x2e
****************************************************************************/
static void
x86emuOp_segovr_CS(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("CS:\n");
    TRACE_AND_STEP();
    M.x86.mode |= SYSMODE_SEGOVR_CS;
    /* note no DECODE_CLEAR_SEGOVR here. */
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x2f
****************************************************************************/
static void
x86emuOp_das(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("DAS\n");
    TRACE_AND_STEP();
    M.x86.R_AL = das_byte(M.x86.R_AL);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x30
****************************************************************************/
static void
x86emuOp_xor_byte_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint destoffset;
    u8 destval;

    START_OF_INSTR();
    DECODE_PRINTF("XOR\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = xor_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 1:
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = xor_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 2:
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = xor_byte(destval, *srcreg);
        store_data_byte(destoffset, destval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = xor_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x31
****************************************************************************/
static void
x86emuOp_xor_word_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("XOR\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = xor_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = xor_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = xor_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = xor_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = xor_long(destval, *srcreg);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = xor_word(destval, *srcreg);
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = xor_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = xor_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x32
****************************************************************************/
static void
x86emuOp_xor_byte_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint srcoffset;
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("XOR\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = xor_byte(*destreg, srcval);
        break;
    case 1:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = xor_byte(*destreg, srcval);
        break;
    case 2:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = xor_byte(*destreg, srcval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = xor_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x33
****************************************************************************/
static void
x86emuOp_xor_word_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("XOR\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = xor_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = xor_word(*destreg, srcval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = xor_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = xor_word(*destreg, srcval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = xor_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = xor_word(*destreg, srcval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = xor_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = xor_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x34
****************************************************************************/
static void
x86emuOp_xor_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("XOR\tAL,");
    srcval = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    M.x86.R_AL = xor_byte(M.x86.R_AL, srcval);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x35
****************************************************************************/
static void
x86emuOp_xor_word_AX_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("XOR\tEAX,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("XOR\tAX,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EAX = xor_long(M.x86.R_EAX, srcval);
    }
    else {
        M.x86.R_AX = xor_word(M.x86.R_AX, (u16) srcval);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x36
****************************************************************************/
static void
x86emuOp_segovr_SS(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("SS:\n");
    TRACE_AND_STEP();
    M.x86.mode |= SYSMODE_SEGOVR_SS;
    /* no DECODE_CLEAR_SEGOVR ! */
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x37
****************************************************************************/
static void
x86emuOp_aaa(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("AAA\n");
    TRACE_AND_STEP();
    M.x86.R_AX = aaa_word(M.x86.R_AX);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x38
****************************************************************************/
static void
x86emuOp_cmp_byte_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;
    u8 *destreg, *srcreg;
    u8 destval;

    START_OF_INSTR();
    DECODE_PRINTF("CMP\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        cmp_byte(destval, *srcreg);
        break;
    case 1:
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        cmp_byte(destval, *srcreg);
        break;
    case 2:
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        cmp_byte(destval, *srcreg);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        cmp_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x39
****************************************************************************/
static void
x86emuOp_cmp_word_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("CMP\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_long(destval, *srcreg);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_word(destval, *srcreg);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_long(destval, *srcreg);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_word(destval, *srcreg);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_long(destval, *srcreg);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_word(destval, *srcreg);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x3a
****************************************************************************/
static void
x86emuOp_cmp_byte_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint srcoffset;
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("CMP\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        cmp_byte(*destreg, srcval);
        break;
    case 1:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        cmp_byte(*destreg, srcval);
        break;
    case 2:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        cmp_byte(*destreg, srcval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        cmp_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x3b
****************************************************************************/
static void
x86emuOp_cmp_word_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("CMP\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_word(*destreg, srcval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_word(*destreg, srcval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_long(*destreg, srcval);
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_word(*destreg, srcval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            cmp_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x3c
****************************************************************************/
static void
x86emuOp_cmp_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("CMP\tAL,");
    srcval = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    cmp_byte(M.x86.R_AL, srcval);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x3d
****************************************************************************/
static void
x86emuOp_cmp_word_AX_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("CMP\tEAX,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("CMP\tAX,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        cmp_long(M.x86.R_EAX, srcval);
    }
    else {
        cmp_word(M.x86.R_AX, (u16) srcval);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x3e
****************************************************************************/
static void
x86emuOp_segovr_DS(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("DS:\n");
    TRACE_AND_STEP();
    M.x86.mode |= SYSMODE_SEGOVR_DS;
    /* NO DECODE_CLEAR_SEGOVR! */
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x3f
****************************************************************************/
static void
x86emuOp_aas(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("AAS\n");
    TRACE_AND_STEP();
    M.x86.R_AX = aas_word(M.x86.R_AX);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x40
****************************************************************************/
static void
x86emuOp_inc_AX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("INC\tEAX\n");
    }
    else {
        DECODE_PRINTF("INC\tAX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EAX = inc_long(M.x86.R_EAX);
    }
    else {
        M.x86.R_AX = inc_word(M.x86.R_AX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x41
****************************************************************************/
static void
x86emuOp_inc_CX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("INC\tECX\n");
    }
    else {
        DECODE_PRINTF("INC\tCX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_ECX = inc_long(M.x86.R_ECX);
    }
    else {
        M.x86.R_CX = inc_word(M.x86.R_CX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x42
****************************************************************************/
static void
x86emuOp_inc_DX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("INC\tEDX\n");
    }
    else {
        DECODE_PRINTF("INC\tDX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EDX = inc_long(M.x86.R_EDX);
    }
    else {
        M.x86.R_DX = inc_word(M.x86.R_DX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x43
****************************************************************************/
static void
x86emuOp_inc_BX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("INC\tEBX\n");
    }
    else {
        DECODE_PRINTF("INC\tBX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EBX = inc_long(M.x86.R_EBX);
    }
    else {
        M.x86.R_BX = inc_word(M.x86.R_BX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x44
****************************************************************************/
static void
x86emuOp_inc_SP(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("INC\tESP\n");
    }
    else {
        DECODE_PRINTF("INC\tSP\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_ESP = inc_long(M.x86.R_ESP);
    }
    else {
        M.x86.R_SP = inc_word(M.x86.R_SP);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x45
****************************************************************************/
static void
x86emuOp_inc_BP(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("INC\tEBP\n");
    }
    else {
        DECODE_PRINTF("INC\tBP\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EBP = inc_long(M.x86.R_EBP);
    }
    else {
        M.x86.R_BP = inc_word(M.x86.R_BP);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x46
****************************************************************************/
static void
x86emuOp_inc_SI(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("INC\tESI\n");
    }
    else {
        DECODE_PRINTF("INC\tSI\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_ESI = inc_long(M.x86.R_ESI);
    }
    else {
        M.x86.R_SI = inc_word(M.x86.R_SI);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x47
****************************************************************************/
static void
x86emuOp_inc_DI(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("INC\tEDI\n");
    }
    else {
        DECODE_PRINTF("INC\tDI\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EDI = inc_long(M.x86.R_EDI);
    }
    else {
        M.x86.R_DI = inc_word(M.x86.R_DI);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x48
****************************************************************************/
static void
x86emuOp_dec_AX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("DEC\tEAX\n");
    }
    else {
        DECODE_PRINTF("DEC\tAX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EAX = dec_long(M.x86.R_EAX);
    }
    else {
        M.x86.R_AX = dec_word(M.x86.R_AX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x49
****************************************************************************/
static void
x86emuOp_dec_CX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("DEC\tECX\n");
    }
    else {
        DECODE_PRINTF("DEC\tCX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_ECX = dec_long(M.x86.R_ECX);
    }
    else {
        M.x86.R_CX = dec_word(M.x86.R_CX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x4a
****************************************************************************/
static void
x86emuOp_dec_DX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("DEC\tEDX\n");
    }
    else {
        DECODE_PRINTF("DEC\tDX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EDX = dec_long(M.x86.R_EDX);
    }
    else {
        M.x86.R_DX = dec_word(M.x86.R_DX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x4b
****************************************************************************/
static void
x86emuOp_dec_BX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("DEC\tEBX\n");
    }
    else {
        DECODE_PRINTF("DEC\tBX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EBX = dec_long(M.x86.R_EBX);
    }
    else {
        M.x86.R_BX = dec_word(M.x86.R_BX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x4c
****************************************************************************/
static void
x86emuOp_dec_SP(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("DEC\tESP\n");
    }
    else {
        DECODE_PRINTF("DEC\tSP\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_ESP = dec_long(M.x86.R_ESP);
    }
    else {
        M.x86.R_SP = dec_word(M.x86.R_SP);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x4d
****************************************************************************/
static void
x86emuOp_dec_BP(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("DEC\tEBP\n");
    }
    else {
        DECODE_PRINTF("DEC\tBP\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EBP = dec_long(M.x86.R_EBP);
    }
    else {
        M.x86.R_BP = dec_word(M.x86.R_BP);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x4e
****************************************************************************/
static void
x86emuOp_dec_SI(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("DEC\tESI\n");
    }
    else {
        DECODE_PRINTF("DEC\tSI\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_ESI = dec_long(M.x86.R_ESI);
    }
    else {
        M.x86.R_SI = dec_word(M.x86.R_SI);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x4f
****************************************************************************/
static void
x86emuOp_dec_DI(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("DEC\tEDI\n");
    }
    else {
        DECODE_PRINTF("DEC\tDI\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EDI = dec_long(M.x86.R_EDI);
    }
    else {
        M.x86.R_DI = dec_word(M.x86.R_DI);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x50
****************************************************************************/
static void
x86emuOp_push_AX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("PUSH\tEAX\n");
    }
    else {
        DECODE_PRINTF("PUSH\tAX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        push_long(M.x86.R_EAX);
    }
    else {
        push_word(M.x86.R_AX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x51
****************************************************************************/
static void
x86emuOp_push_CX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("PUSH\tECX\n");
    }
    else {
        DECODE_PRINTF("PUSH\tCX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        push_long(M.x86.R_ECX);
    }
    else {
        push_word(M.x86.R_CX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x52
****************************************************************************/
static void
x86emuOp_push_DX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("PUSH\tEDX\n");
    }
    else {
        DECODE_PRINTF("PUSH\tDX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        push_long(M.x86.R_EDX);
    }
    else {
        push_word(M.x86.R_DX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x53
****************************************************************************/
static void
x86emuOp_push_BX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("PUSH\tEBX\n");
    }
    else {
        DECODE_PRINTF("PUSH\tBX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        push_long(M.x86.R_EBX);
    }
    else {
        push_word(M.x86.R_BX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x54
****************************************************************************/
static void
x86emuOp_push_SP(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("PUSH\tESP\n");
    }
    else {
        DECODE_PRINTF("PUSH\tSP\n");
    }
    TRACE_AND_STEP();
    /* Always push (E)SP, since we are emulating an i386 and above
     * processor. This is necessary as some BIOS'es use this to check
     * what type of processor is in the system.
     */
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        push_long(M.x86.R_ESP);
    }
    else {
        push_word((u16) (M.x86.R_SP));
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x55
****************************************************************************/
static void
x86emuOp_push_BP(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("PUSH\tEBP\n");
    }
    else {
        DECODE_PRINTF("PUSH\tBP\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        push_long(M.x86.R_EBP);
    }
    else {
        push_word(M.x86.R_BP);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x56
****************************************************************************/
static void
x86emuOp_push_SI(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("PUSH\tESI\n");
    }
    else {
        DECODE_PRINTF("PUSH\tSI\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        push_long(M.x86.R_ESI);
    }
    else {
        push_word(M.x86.R_SI);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x57
****************************************************************************/
static void
x86emuOp_push_DI(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("PUSH\tEDI\n");
    }
    else {
        DECODE_PRINTF("PUSH\tDI\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        push_long(M.x86.R_EDI);
    }
    else {
        push_word(M.x86.R_DI);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x58
****************************************************************************/
static void
x86emuOp_pop_AX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("POP\tEAX\n");
    }
    else {
        DECODE_PRINTF("POP\tAX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EAX = pop_long();
    }
    else {
        M.x86.R_AX = pop_word();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x59
****************************************************************************/
static void
x86emuOp_pop_CX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("POP\tECX\n");
    }
    else {
        DECODE_PRINTF("POP\tCX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_ECX = pop_long();
    }
    else {
        M.x86.R_CX = pop_word();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x5a
****************************************************************************/
static void
x86emuOp_pop_DX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("POP\tEDX\n");
    }
    else {
        DECODE_PRINTF("POP\tDX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EDX = pop_long();
    }
    else {
        M.x86.R_DX = pop_word();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x5b
****************************************************************************/
static void
x86emuOp_pop_BX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("POP\tEBX\n");
    }
    else {
        DECODE_PRINTF("POP\tBX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EBX = pop_long();
    }
    else {
        M.x86.R_BX = pop_word();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x5c
****************************************************************************/
static void
x86emuOp_pop_SP(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("POP\tESP\n");
    }
    else {
        DECODE_PRINTF("POP\tSP\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_ESP = pop_long();
    }
    else {
        M.x86.R_SP = pop_word();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x5d
****************************************************************************/
static void
x86emuOp_pop_BP(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("POP\tEBP\n");
    }
    else {
        DECODE_PRINTF("POP\tBP\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EBP = pop_long();
    }
    else {
        M.x86.R_BP = pop_word();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x5e
****************************************************************************/
static void
x86emuOp_pop_SI(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("POP\tESI\n");
    }
    else {
        DECODE_PRINTF("POP\tSI\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_ESI = pop_long();
    }
    else {
        M.x86.R_SI = pop_word();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x5f
****************************************************************************/
static void
x86emuOp_pop_DI(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("POP\tEDI\n");
    }
    else {
        DECODE_PRINTF("POP\tDI\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EDI = pop_long();
    }
    else {
        M.x86.R_DI = pop_word();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x60
****************************************************************************/
static void
x86emuOp_push_all(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("PUSHAD\n");
    }
    else {
        DECODE_PRINTF("PUSHA\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        u32 old_sp = M.x86.R_ESP;

        push_long(M.x86.R_EAX);
        push_long(M.x86.R_ECX);
        push_long(M.x86.R_EDX);
        push_long(M.x86.R_EBX);
        push_long(old_sp);
        push_long(M.x86.R_EBP);
        push_long(M.x86.R_ESI);
        push_long(M.x86.R_EDI);
    }
    else {
        u16 old_sp = M.x86.R_SP;

        push_word(M.x86.R_AX);
        push_word(M.x86.R_CX);
        push_word(M.x86.R_DX);
        push_word(M.x86.R_BX);
        push_word(old_sp);
        push_word(M.x86.R_BP);
        push_word(M.x86.R_SI);
        push_word(M.x86.R_DI);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x61
****************************************************************************/
static void
x86emuOp_pop_all(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("POPAD\n");
    }
    else {
        DECODE_PRINTF("POPA\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EDI = pop_long();
        M.x86.R_ESI = pop_long();
        M.x86.R_EBP = pop_long();
        M.x86.R_ESP += 4;       /* skip ESP */
        M.x86.R_EBX = pop_long();
        M.x86.R_EDX = pop_long();
        M.x86.R_ECX = pop_long();
        M.x86.R_EAX = pop_long();
    }
    else {
        M.x86.R_DI = pop_word();
        M.x86.R_SI = pop_word();
        M.x86.R_BP = pop_word();
        M.x86.R_SP += 2;        /* skip SP */
        M.x86.R_BX = pop_word();
        M.x86.R_DX = pop_word();
        M.x86.R_CX = pop_word();
        M.x86.R_AX = pop_word();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/*opcode 0x62   ILLEGAL OP, calls x86emuOp_illegal_op() */
/*opcode 0x63   ILLEGAL OP, calls x86emuOp_illegal_op() */

/****************************************************************************
REMARKS:
Handles opcode 0x64
****************************************************************************/
static void
x86emuOp_segovr_FS(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("FS:\n");
    TRACE_AND_STEP();
    M.x86.mode |= SYSMODE_SEGOVR_FS;
    /*
     * note the lack of DECODE_CLEAR_SEGOVR(r) since, here is one of 4
     * opcode subroutines we do not want to do this.
     */
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x65
****************************************************************************/
static void
x86emuOp_segovr_GS(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("GS:\n");
    TRACE_AND_STEP();
    M.x86.mode |= SYSMODE_SEGOVR_GS;
    /*
     * note the lack of DECODE_CLEAR_SEGOVR(r) since, here is one of 4
     * opcode subroutines we do not want to do this.
     */
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x66 - prefix for 32-bit register
****************************************************************************/
static void
x86emuOp_prefix_data(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("DATA:\n");
    TRACE_AND_STEP();
    M.x86.mode |= SYSMODE_PREFIX_DATA;
    /* note no DECODE_CLEAR_SEGOVR here. */
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x67 - prefix for 32-bit address
****************************************************************************/
static void
x86emuOp_prefix_addr(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("ADDR:\n");
    TRACE_AND_STEP();
    M.x86.mode |= SYSMODE_PREFIX_ADDR;
    /* note no DECODE_CLEAR_SEGOVR here. */
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x68
****************************************************************************/
static void
x86emuOp_push_word_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 imm;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        imm = fetch_long_imm();
    }
    else {
        imm = fetch_word_imm();
    }
    DECODE_PRINTF2("PUSH\t%x\n", imm);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        push_long(imm);
    }
    else {
        push_word((u16) imm);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x69
****************************************************************************/
static void
x86emuOp_imul_word_IMM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("IMUL\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;
            u32 res_lo, res_hi;
            s32 imm;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_long(srcoffset);
            imm = fetch_long_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            TRACE_AND_STEP();
            imul_long_direct(&res_lo, &res_hi, (s32) srcval, (s32) imm);
            if (res_hi != 0) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u32) res_lo;
        }
        else {
            u16 *destreg;
            u16 srcval;
            u32 res;
            s16 imm;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_word(srcoffset);
            imm = fetch_word_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            TRACE_AND_STEP();
            res = (s16) srcval *(s16) imm;

            if (res > 0xFFFF) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u16) res;
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;
            u32 res_lo, res_hi;
            s32 imm;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_long(srcoffset);
            imm = fetch_long_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            TRACE_AND_STEP();
            imul_long_direct(&res_lo, &res_hi, (s32) srcval, (s32) imm);
            if (res_hi != 0) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u32) res_lo;
        }
        else {
            u16 *destreg;
            u16 srcval;
            u32 res;
            s16 imm;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_word(srcoffset);
            imm = fetch_word_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            TRACE_AND_STEP();
            res = (s16) srcval *(s16) imm;

            if (res > 0xFFFF) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u16) res;
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;
            u32 res_lo, res_hi;
            s32 imm;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_long(srcoffset);
            imm = fetch_long_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            TRACE_AND_STEP();
            imul_long_direct(&res_lo, &res_hi, (s32) srcval, (s32) imm);
            if (res_hi != 0) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u32) res_lo;
        }
        else {
            u16 *destreg;
            u16 srcval;
            u32 res;
            s16 imm;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_word(srcoffset);
            imm = fetch_word_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            TRACE_AND_STEP();
            res = (s16) srcval *(s16) imm;

            if (res > 0xFFFF) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u16) res;
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;
            u32 res_lo, res_hi;
            s32 imm;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rl);
            imm = fetch_long_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            TRACE_AND_STEP();
            imul_long_direct(&res_lo, &res_hi, (s32) * srcreg, (s32) imm);
            if (res_hi != 0) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u32) res_lo;
        }
        else {
            u16 *destreg, *srcreg;
            u32 res;
            s16 imm;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rl);
            imm = fetch_word_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            res = (s16) * srcreg * (s16) imm;
            if (res > 0xFFFF) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u16) res;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x6a
****************************************************************************/
static void
x86emuOp_push_byte_IMM(u8 X86EMU_UNUSED(op1))
{
    s16 imm;

    START_OF_INSTR();
    imm = (s8) fetch_byte_imm();
    DECODE_PRINTF2("PUSH\t%d\n", imm);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        push_long((s32) imm);
    }
    else {
        push_word(imm);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x6b
****************************************************************************/
static void
x86emuOp_imul_byte_IMM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint srcoffset;
    s8 imm;

    START_OF_INSTR();
    DECODE_PRINTF("IMUL\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;
            u32 res_lo, res_hi;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_long(srcoffset);
            imm = fetch_byte_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            TRACE_AND_STEP();
            imul_long_direct(&res_lo, &res_hi, (s32) srcval, (s32) imm);
            if (res_hi != 0) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u32) res_lo;
        }
        else {
            u16 *destreg;
            u16 srcval;
            u32 res;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_word(srcoffset);
            imm = fetch_byte_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            TRACE_AND_STEP();
            res = (s16) srcval *(s16) imm;

            if (res > 0xFFFF) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u16) res;
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;
            u32 res_lo, res_hi;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_long(srcoffset);
            imm = fetch_byte_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            TRACE_AND_STEP();
            imul_long_direct(&res_lo, &res_hi, (s32) srcval, (s32) imm);
            if (res_hi != 0) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u32) res_lo;
        }
        else {
            u16 *destreg;
            u16 srcval;
            u32 res;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_word(srcoffset);
            imm = fetch_byte_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            TRACE_AND_STEP();
            res = (s16) srcval *(s16) imm;

            if (res > 0xFFFF) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u16) res;
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;
            u32 res_lo, res_hi;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_long(srcoffset);
            imm = fetch_byte_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            TRACE_AND_STEP();
            imul_long_direct(&res_lo, &res_hi, (s32) srcval, (s32) imm);
            if (res_hi != 0) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u32) res_lo;
        }
        else {
            u16 *destreg;
            u16 srcval;
            u32 res;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_word(srcoffset);
            imm = fetch_byte_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            TRACE_AND_STEP();
            res = (s16) srcval *(s16) imm;

            if (res > 0xFFFF) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u16) res;
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;
            u32 res_lo, res_hi;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rl);
            imm = fetch_byte_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            TRACE_AND_STEP();
            imul_long_direct(&res_lo, &res_hi, (s32) * srcreg, (s32) imm);
            if (res_hi != 0) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u32) res_lo;
        }
        else {
            u16 *destreg, *srcreg;
            u32 res;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rl);
            imm = fetch_byte_imm();
            DECODE_PRINTF2(",%d\n", (s32) imm);
            res = (s16) * srcreg * (s16) imm;
            if (res > 0xFFFF) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u16) res;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x6c
****************************************************************************/
static void
x86emuOp_ins_byte(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("INSB\n");
    ins(1);
    TRACE_AND_STEP();
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x6d
****************************************************************************/
static void
x86emuOp_ins_word(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("INSD\n");
        ins(4);
    }
    else {
        DECODE_PRINTF("INSW\n");
        ins(2);
    }
    TRACE_AND_STEP();
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x6e
****************************************************************************/
static void
x86emuOp_outs_byte(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("OUTSB\n");
    outs(1);
    TRACE_AND_STEP();
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x6f
****************************************************************************/
static void
x86emuOp_outs_word(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("OUTSD\n");
        outs(4);
    }
    else {
        DECODE_PRINTF("OUTSW\n");
        outs(2);
    }
    TRACE_AND_STEP();
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x70
****************************************************************************/
static void
x86emuOp_jump_near_O(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;

    /* jump to byte offset if overflow flag is set */
    START_OF_INSTR();
    DECODE_PRINTF("JO\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    if (ACCESS_FLAG(F_OF))
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x71
****************************************************************************/
static void
x86emuOp_jump_near_NO(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;

    /* jump to byte offset if overflow is not set */
    START_OF_INSTR();
    DECODE_PRINTF("JNO\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    if (!ACCESS_FLAG(F_OF))
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x72
****************************************************************************/
static void
x86emuOp_jump_near_B(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;

    /* jump to byte offset if carry flag is set. */
    START_OF_INSTR();
    DECODE_PRINTF("JB\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    if (ACCESS_FLAG(F_CF))
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x73
****************************************************************************/
static void
x86emuOp_jump_near_NB(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;

    /* jump to byte offset if carry flag is clear. */
    START_OF_INSTR();
    DECODE_PRINTF("JNB\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    if (!ACCESS_FLAG(F_CF))
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x74
****************************************************************************/
static void
x86emuOp_jump_near_Z(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;

    /* jump to byte offset if zero flag is set. */
    START_OF_INSTR();
    DECODE_PRINTF("JZ\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    if (ACCESS_FLAG(F_ZF))
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x75
****************************************************************************/
static void
x86emuOp_jump_near_NZ(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;

    /* jump to byte offset if zero flag is clear. */
    START_OF_INSTR();
    DECODE_PRINTF("JNZ\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    if (!ACCESS_FLAG(F_ZF))
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x76
****************************************************************************/
static void
x86emuOp_jump_near_BE(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;

    /* jump to byte offset if carry flag is set or if the zero
       flag is set. */
    START_OF_INSTR();
    DECODE_PRINTF("JBE\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    if (ACCESS_FLAG(F_CF) || ACCESS_FLAG(F_ZF))
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x77
****************************************************************************/
static void
x86emuOp_jump_near_NBE(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;

    /* jump to byte offset if carry flag is clear and if the zero
       flag is clear */
    START_OF_INSTR();
    DECODE_PRINTF("JNBE\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    if (!(ACCESS_FLAG(F_CF) || ACCESS_FLAG(F_ZF)))
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x78
****************************************************************************/
static void
x86emuOp_jump_near_S(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;

    /* jump to byte offset if sign flag is set */
    START_OF_INSTR();
    DECODE_PRINTF("JS\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    if (ACCESS_FLAG(F_SF))
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x79
****************************************************************************/
static void
x86emuOp_jump_near_NS(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;

    /* jump to byte offset if sign flag is clear */
    START_OF_INSTR();
    DECODE_PRINTF("JNS\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    if (!ACCESS_FLAG(F_SF))
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x7a
****************************************************************************/
static void
x86emuOp_jump_near_P(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;

    /* jump to byte offset if parity flag is set (even parity) */
    START_OF_INSTR();
    DECODE_PRINTF("JP\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    if (ACCESS_FLAG(F_PF))
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x7b
****************************************************************************/
static void
x86emuOp_jump_near_NP(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;

    /* jump to byte offset if parity flag is clear (odd parity) */
    START_OF_INSTR();
    DECODE_PRINTF("JNP\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    if (!ACCESS_FLAG(F_PF))
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x7c
****************************************************************************/
static void
x86emuOp_jump_near_L(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;
    int sf, of;

    /* jump to byte offset if sign flag not equal to overflow flag. */
    START_OF_INSTR();
    DECODE_PRINTF("JL\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    sf = ACCESS_FLAG(F_SF) != 0;
    of = ACCESS_FLAG(F_OF) != 0;
    if (sf ^ of)
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x7d
****************************************************************************/
static void
x86emuOp_jump_near_NL(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;
    int sf, of;

    /* jump to byte offset if sign flag not equal to overflow flag. */
    START_OF_INSTR();
    DECODE_PRINTF("JNL\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    sf = ACCESS_FLAG(F_SF) != 0;
    of = ACCESS_FLAG(F_OF) != 0;
    /* note: inverse of above, but using == instead of xor. */
    if (sf == of)
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x7e
****************************************************************************/
static void
x86emuOp_jump_near_LE(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;
    int sf, of;

    /* jump to byte offset if sign flag not equal to overflow flag
       or the zero flag is set */
    START_OF_INSTR();
    DECODE_PRINTF("JLE\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    sf = ACCESS_FLAG(F_SF) != 0;
    of = ACCESS_FLAG(F_OF) != 0;
    if ((sf ^ of) || ACCESS_FLAG(F_ZF))
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x7f
****************************************************************************/
static void
x86emuOp_jump_near_NLE(u8 X86EMU_UNUSED(op1))
{
    s8 offset;
    u16 target;
    int sf, of;

    /* jump to byte offset if sign flag equal to overflow flag.
       and the zero flag is clear */
    START_OF_INSTR();
    DECODE_PRINTF("JNLE\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + (s16) offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    sf = ACCESS_FLAG(F_SF) != 0;
    of = ACCESS_FLAG(F_OF) != 0;
    if ((sf == of) && !ACCESS_FLAG(F_ZF))
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

static u8(*opc80_byte_operation[]) (u8 d, u8 s) = {
    add_byte,                   /* 00 */
        or_byte,                /* 01 */
        adc_byte,               /* 02 */
        sbb_byte,               /* 03 */
        and_byte,               /* 04 */
        sub_byte,               /* 05 */
        xor_byte,               /* 06 */
        cmp_byte,               /* 07 */
};

/****************************************************************************
REMARKS:
Handles opcode 0x80
****************************************************************************/
static void
x86emuOp_opc80_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg;
    uint destoffset;
    u8 imm;
    u8 destval;

    /*
     * Weirdo special case instruction format.  Part of the opcode
     * held below in "RH".  Doubly nested case would result, except
     * that the decoded instruction
     */
    START_OF_INSTR();
    FETCH_DECODE_MODRM(mod, rh, rl);
#ifdef DEBUG
    if (DEBUG_DECODE()) {
        /* XXX DECODE_PRINTF may be changed to something more
           general, so that it is important to leave the strings
           in the same format, even though the result is that the
           above test is done twice. */

        switch (rh) {
        case 0:
            DECODE_PRINTF("ADD\t");
            break;
        case 1:
            DECODE_PRINTF("OR\t");
            break;
        case 2:
            DECODE_PRINTF("ADC\t");
            break;
        case 3:
            DECODE_PRINTF("SBB\t");
            break;
        case 4:
            DECODE_PRINTF("AND\t");
            break;
        case 5:
            DECODE_PRINTF("SUB\t");
            break;
        case 6:
            DECODE_PRINTF("XOR\t");
            break;
        case 7:
            DECODE_PRINTF("CMP\t");
            break;
        }
    }
#endif
    /* know operation, decode the mod byte to find the addressing
       mode. */
    switch (mod) {
    case 0:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        imm = fetch_byte_imm();
        DECODE_PRINTF2("%x\n", imm);
        TRACE_AND_STEP();
        destval = (*opc80_byte_operation[rh]) (destval, imm);
        if (rh != 7)
            store_data_byte(destoffset, destval);
        break;
    case 1:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        imm = fetch_byte_imm();
        DECODE_PRINTF2("%x\n", imm);
        TRACE_AND_STEP();
        destval = (*opc80_byte_operation[rh]) (destval, imm);
        if (rh != 7)
            store_data_byte(destoffset, destval);
        break;
    case 2:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        imm = fetch_byte_imm();
        DECODE_PRINTF2("%x\n", imm);
        TRACE_AND_STEP();
        destval = (*opc80_byte_operation[rh]) (destval, imm);
        if (rh != 7)
            store_data_byte(destoffset, destval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF(",");
        imm = fetch_byte_imm();
        DECODE_PRINTF2("%x\n", imm);
        TRACE_AND_STEP();
        destval = (*opc80_byte_operation[rh]) (*destreg, imm);
        if (rh != 7)
            *destreg = destval;
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

static u16(*opc81_word_operation[]) (u16 d, u16 s) = {
    add_word,                   /*00 */
        or_word,                /*01 */
        adc_word,               /*02 */
        sbb_word,               /*03 */
        and_word,               /*04 */
        sub_word,               /*05 */
        xor_word,               /*06 */
        cmp_word,               /*07 */
};

static u32(*opc81_long_operation[]) (u32 d, u32 s) = {
    add_long,                   /*00 */
        or_long,                /*01 */
        adc_long,               /*02 */
        sbb_long,               /*03 */
        and_long,               /*04 */
        sub_long,               /*05 */
        xor_long,               /*06 */
        cmp_long,               /*07 */
};

/****************************************************************************
REMARKS:
Handles opcode 0x81
****************************************************************************/
static void
x86emuOp_opc81_word_RM_IMM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    /*
     * Weirdo special case instruction format.  Part of the opcode
     * held below in "RH".  Doubly nested case would result, except
     * that the decoded instruction
     */
    START_OF_INSTR();
    FETCH_DECODE_MODRM(mod, rh, rl);
#ifdef DEBUG
    if (DEBUG_DECODE()) {
        /* XXX DECODE_PRINTF may be changed to something more
           general, so that it is important to leave the strings
           in the same format, even though the result is that the
           above test is done twice. */

        switch (rh) {
        case 0:
            DECODE_PRINTF("ADD\t");
            break;
        case 1:
            DECODE_PRINTF("OR\t");
            break;
        case 2:
            DECODE_PRINTF("ADC\t");
            break;
        case 3:
            DECODE_PRINTF("SBB\t");
            break;
        case 4:
            DECODE_PRINTF("AND\t");
            break;
        case 5:
            DECODE_PRINTF("SUB\t");
            break;
        case 6:
            DECODE_PRINTF("XOR\t");
            break;
        case 7:
            DECODE_PRINTF("CMP\t");
            break;
        }
    }
#endif
    /*
     * Know operation, decode the mod byte to find the addressing
     * mode.
     */
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval, imm;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            imm = fetch_long_imm();
            DECODE_PRINTF2("%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc81_long_operation[rh]) (destval, imm);
            if (rh != 7)
                store_data_long(destoffset, destval);
        }
        else {
            u16 destval, imm;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            imm = fetch_word_imm();
            DECODE_PRINTF2("%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc81_word_operation[rh]) (destval, imm);
            if (rh != 7)
                store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval, imm;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            imm = fetch_long_imm();
            DECODE_PRINTF2("%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc81_long_operation[rh]) (destval, imm);
            if (rh != 7)
                store_data_long(destoffset, destval);
        }
        else {
            u16 destval, imm;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            imm = fetch_word_imm();
            DECODE_PRINTF2("%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc81_word_operation[rh]) (destval, imm);
            if (rh != 7)
                store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval, imm;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            imm = fetch_long_imm();
            DECODE_PRINTF2("%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc81_long_operation[rh]) (destval, imm);
            if (rh != 7)
                store_data_long(destoffset, destval);
        }
        else {
            u16 destval, imm;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            imm = fetch_word_imm();
            DECODE_PRINTF2("%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc81_word_operation[rh]) (destval, imm);
            if (rh != 7)
                store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 destval, imm;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            imm = fetch_long_imm();
            DECODE_PRINTF2("%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc81_long_operation[rh]) (*destreg, imm);
            if (rh != 7)
                *destreg = destval;
        }
        else {
            u16 *destreg;
            u16 destval, imm;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            imm = fetch_word_imm();
            DECODE_PRINTF2("%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc81_word_operation[rh]) (*destreg, imm);
            if (rh != 7)
                *destreg = destval;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

static u8(*opc82_byte_operation[]) (u8 s, u8 d) = {
    add_byte,                   /*00 */
        or_byte,                /*01 *//*YYY UNUSED ???? */
        adc_byte,               /*02 */
        sbb_byte,               /*03 */
        and_byte,               /*04 *//*YYY UNUSED ???? */
        sub_byte,               /*05 */
        xor_byte,               /*06 *//*YYY UNUSED ???? */
        cmp_byte,               /*07 */
};

/****************************************************************************
REMARKS:
Handles opcode 0x82
****************************************************************************/
static void
x86emuOp_opc82_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg;
    uint destoffset;
    u8 imm;
    u8 destval;

    /*
     * Weirdo special case instruction format.  Part of the opcode
     * held below in "RH".  Doubly nested case would result, except
     * that the decoded instruction Similar to opcode 81, except that
     * the immediate byte is sign extended to a word length.
     */
    START_OF_INSTR();
    FETCH_DECODE_MODRM(mod, rh, rl);
#ifdef DEBUG
    if (DEBUG_DECODE()) {
        /* XXX DECODE_PRINTF may be changed to something more
           general, so that it is important to leave the strings
           in the same format, even though the result is that the
           above test is done twice. */
        switch (rh) {
        case 0:
            DECODE_PRINTF("ADD\t");
            break;
        case 1:
            DECODE_PRINTF("OR\t");
            break;
        case 2:
            DECODE_PRINTF("ADC\t");
            break;
        case 3:
            DECODE_PRINTF("SBB\t");
            break;
        case 4:
            DECODE_PRINTF("AND\t");
            break;
        case 5:
            DECODE_PRINTF("SUB\t");
            break;
        case 6:
            DECODE_PRINTF("XOR\t");
            break;
        case 7:
            DECODE_PRINTF("CMP\t");
            break;
        }
    }
#endif
    /* know operation, decode the mod byte to find the addressing
       mode. */
    switch (mod) {
    case 0:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm00_address(rl);
        destval = fetch_data_byte(destoffset);
        imm = fetch_byte_imm();
        DECODE_PRINTF2(",%x\n", imm);
        TRACE_AND_STEP();
        destval = (*opc82_byte_operation[rh]) (destval, imm);
        if (rh != 7)
            store_data_byte(destoffset, destval);
        break;
    case 1:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm01_address(rl);
        destval = fetch_data_byte(destoffset);
        imm = fetch_byte_imm();
        DECODE_PRINTF2(",%x\n", imm);
        TRACE_AND_STEP();
        destval = (*opc82_byte_operation[rh]) (destval, imm);
        if (rh != 7)
            store_data_byte(destoffset, destval);
        break;
    case 2:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm10_address(rl);
        destval = fetch_data_byte(destoffset);
        imm = fetch_byte_imm();
        DECODE_PRINTF2(",%x\n", imm);
        TRACE_AND_STEP();
        destval = (*opc82_byte_operation[rh]) (destval, imm);
        if (rh != 7)
            store_data_byte(destoffset, destval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        imm = fetch_byte_imm();
        DECODE_PRINTF2(",%x\n", imm);
        TRACE_AND_STEP();
        destval = (*opc82_byte_operation[rh]) (*destreg, imm);
        if (rh != 7)
            *destreg = destval;
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

static u16(*opc83_word_operation[]) (u16 s, u16 d) = {
    add_word,                   /*00 */
        or_word,                /*01 *//*YYY UNUSED ???? */
        adc_word,               /*02 */
        sbb_word,               /*03 */
        and_word,               /*04 *//*YYY UNUSED ???? */
        sub_word,               /*05 */
        xor_word,               /*06 *//*YYY UNUSED ???? */
        cmp_word,               /*07 */
};

static u32(*opc83_long_operation[]) (u32 s, u32 d) = {
    add_long,                   /*00 */
        or_long,                /*01 *//*YYY UNUSED ???? */
        adc_long,               /*02 */
        sbb_long,               /*03 */
        and_long,               /*04 *//*YYY UNUSED ???? */
        sub_long,               /*05 */
        xor_long,               /*06 *//*YYY UNUSED ???? */
        cmp_long,               /*07 */
};

/****************************************************************************
REMARKS:
Handles opcode 0x83
****************************************************************************/
static void
x86emuOp_opc83_word_RM_IMM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    /*
     * Weirdo special case instruction format.  Part of the opcode
     * held below in "RH".  Doubly nested case would result, except
     * that the decoded instruction Similar to opcode 81, except that
     * the immediate byte is sign extended to a word length.
     */
    START_OF_INSTR();
    FETCH_DECODE_MODRM(mod, rh, rl);
#ifdef DEBUG
    if (DEBUG_DECODE()) {
        /* XXX DECODE_PRINTF may be changed to something more
           general, so that it is important to leave the strings
           in the same format, even though the result is that the
           above test is done twice. */
        switch (rh) {
        case 0:
            DECODE_PRINTF("ADD\t");
            break;
        case 1:
            DECODE_PRINTF("OR\t");
            break;
        case 2:
            DECODE_PRINTF("ADC\t");
            break;
        case 3:
            DECODE_PRINTF("SBB\t");
            break;
        case 4:
            DECODE_PRINTF("AND\t");
            break;
        case 5:
            DECODE_PRINTF("SUB\t");
            break;
        case 6:
            DECODE_PRINTF("XOR\t");
            break;
        case 7:
            DECODE_PRINTF("CMP\t");
            break;
        }
    }
#endif
    /* know operation, decode the mod byte to find the addressing
       mode. */
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval, imm;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm00_address(rl);
            destval = fetch_data_long(destoffset);
            imm = (s8) fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc83_long_operation[rh]) (destval, imm);
            if (rh != 7)
                store_data_long(destoffset, destval);
        }
        else {
            u16 destval, imm;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm00_address(rl);
            destval = fetch_data_word(destoffset);
            imm = (s8) fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc83_word_operation[rh]) (destval, imm);
            if (rh != 7)
                store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval, imm;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm01_address(rl);
            destval = fetch_data_long(destoffset);
            imm = (s8) fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc83_long_operation[rh]) (destval, imm);
            if (rh != 7)
                store_data_long(destoffset, destval);
        }
        else {
            u16 destval, imm;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm01_address(rl);
            destval = fetch_data_word(destoffset);
            imm = (s8) fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc83_word_operation[rh]) (destval, imm);
            if (rh != 7)
                store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval, imm;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm10_address(rl);
            destval = fetch_data_long(destoffset);
            imm = (s8) fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc83_long_operation[rh]) (destval, imm);
            if (rh != 7)
                store_data_long(destoffset, destval);
        }
        else {
            u16 destval, imm;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm10_address(rl);
            destval = fetch_data_word(destoffset);
            imm = (s8) fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc83_word_operation[rh]) (destval, imm);
            if (rh != 7)
                store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 destval, imm;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            imm = (s8) fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc83_long_operation[rh]) (*destreg, imm);
            if (rh != 7)
                *destreg = destval;
        }
        else {
            u16 *destreg;
            u16 destval, imm;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            imm = (s8) fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            destval = (*opc83_word_operation[rh]) (*destreg, imm);
            if (rh != 7)
                *destreg = destval;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x84
****************************************************************************/
static void
x86emuOp_test_byte_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint destoffset;
    u8 destval;

    START_OF_INSTR();
    DECODE_PRINTF("TEST\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        test_byte(destval, *srcreg);
        break;
    case 1:
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        test_byte(destval, *srcreg);
        break;
    case 2:
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        test_byte(destval, *srcreg);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        test_byte(*destreg, *srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x85
****************************************************************************/
static void
x86emuOp_test_word_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("TEST\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            test_long(destval, *srcreg);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            test_word(destval, *srcreg);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            test_long(destval, *srcreg);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            test_word(destval, *srcreg);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            test_long(destval, *srcreg);
        }
        else {
            u16 destval;
            u16 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            test_word(destval, *srcreg);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            test_long(*destreg, *srcreg);
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            test_word(*destreg, *srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x86
****************************************************************************/
static void
x86emuOp_xchg_byte_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint destoffset;
    u8 destval;
    u8 tmp;

    START_OF_INSTR();
    DECODE_PRINTF("XCHG\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        tmp = *srcreg;
        *srcreg = destval;
        destval = tmp;
        store_data_byte(destoffset, destval);
        break;
    case 1:
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        tmp = *srcreg;
        *srcreg = destval;
        destval = tmp;
        store_data_byte(destoffset, destval);
        break;
    case 2:
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF(",");
        destval = fetch_data_byte(destoffset);
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        tmp = *srcreg;
        *srcreg = destval;
        destval = tmp;
        store_data_byte(destoffset, destval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        tmp = *srcreg;
        *srcreg = *destreg;
        *destreg = tmp;
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x87
****************************************************************************/
static void
x86emuOp_xchg_word_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("XCHG\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *srcreg;
            u32 destval, tmp;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            tmp = *srcreg;
            *srcreg = destval;
            destval = tmp;
            store_data_long(destoffset, destval);
        }
        else {
            u16 *srcreg;
            u16 destval, tmp;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            tmp = *srcreg;
            *srcreg = destval;
            destval = tmp;
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *srcreg;
            u32 destval, tmp;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            tmp = *srcreg;
            *srcreg = destval;
            destval = tmp;
            store_data_long(destoffset, destval);
        }
        else {
            u16 *srcreg;
            u16 destval, tmp;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            tmp = *srcreg;
            *srcreg = destval;
            destval = tmp;
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *srcreg;
            u32 destval, tmp;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_long(destoffset);
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            tmp = *srcreg;
            *srcreg = destval;
            destval = tmp;
            store_data_long(destoffset, destval);
        }
        else {
            u16 *srcreg;
            u16 destval, tmp;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            destval = fetch_data_word(destoffset);
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            tmp = *srcreg;
            *srcreg = destval;
            destval = tmp;
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;
            u32 tmp;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            tmp = *srcreg;
            *srcreg = *destreg;
            *destreg = tmp;
        }
        else {
            u16 *destreg, *srcreg;
            u16 tmp;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            tmp = *srcreg;
            *srcreg = *destreg;
            *destreg = tmp;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x88
****************************************************************************/
static void
x86emuOp_mov_byte_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        store_data_byte(destoffset, *srcreg);
        break;
    case 1:
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        store_data_byte(destoffset, *srcreg);
        break;
    case 2:
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        store_data_byte(destoffset, *srcreg);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = *srcreg;
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x89
****************************************************************************/
static void
x86emuOp_mov_word_RM_R(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u32 destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            store_data_long(destoffset, *srcreg);
        }
        else {
            u16 *srcreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            store_data_word(destoffset, *srcreg);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            store_data_long(destoffset, *srcreg);
        }
        else {
            u16 *srcreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            store_data_word(destoffset, *srcreg);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            store_data_long(destoffset, *srcreg);
        }
        else {
            u16 *srcreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            store_data_word(destoffset, *srcreg);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = *srcreg;
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = *srcreg;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x8a
****************************************************************************/
static void
x86emuOp_mov_byte_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg, *srcreg;
    uint srcoffset;
    u8 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = srcval;
        break;
    case 1:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = srcval;
        break;
    case 2:
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        srcval = fetch_data_byte(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = srcval;
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rh);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = *srcreg;
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x8b
****************************************************************************/
static void
x86emuOp_mov_word_R_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_long(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_word(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = *srcreg;
        }
        else {
            u16 *destreg, *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = *srcreg;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x8c
****************************************************************************/
static void
x86emuOp_mov_word_RM_SR(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u16 *destreg, *srcreg;
    uint destoffset;
    u16 destval;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF(",");
        srcreg = decode_rm_seg_register(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = *srcreg;
        store_data_word(destoffset, destval);
        break;
    case 1:
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF(",");
        srcreg = decode_rm_seg_register(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = *srcreg;
        store_data_word(destoffset, destval);
        break;
    case 2:
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF(",");
        srcreg = decode_rm_seg_register(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        destval = *srcreg;
        store_data_word(destoffset, destval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_WORD_REGISTER(rl);
        DECODE_PRINTF(",");
        srcreg = decode_rm_seg_register(rh);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = *srcreg;
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x8d
****************************************************************************/
static void
x86emuOp_lea_word_R_M(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("LEA\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_ADDR) {
            u32 *srcreg = DECODE_RM_LONG_REGISTER(rh);

            DECODE_PRINTF(",");
            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *srcreg = (u32) destoffset;
        }
        else {
            u16 *srcreg = DECODE_RM_WORD_REGISTER(rh);

            DECODE_PRINTF(",");
            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *srcreg = (u16) destoffset;
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_ADDR) {
            u32 *srcreg = DECODE_RM_LONG_REGISTER(rh);

            DECODE_PRINTF(",");
            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *srcreg = (u32) destoffset;
        }
        else {
            u16 *srcreg = DECODE_RM_WORD_REGISTER(rh);

            DECODE_PRINTF(",");
            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *srcreg = (u16) destoffset;
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_ADDR) {
            u32 *srcreg = DECODE_RM_LONG_REGISTER(rh);

            DECODE_PRINTF(",");
            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *srcreg = (u32) destoffset;
        }
        else {
            u16 *srcreg = DECODE_RM_WORD_REGISTER(rh);

            DECODE_PRINTF(",");
            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *srcreg = (u16) destoffset;
        }
        break;
    case 3:                    /* register to register */
        /* undefined.  Do nothing. */
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x8e
****************************************************************************/
static void
x86emuOp_mov_word_SR_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u16 *destreg, *srcreg;
    uint srcoffset;
    u16 srcval;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destreg = decode_rm_seg_register(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        srcval = fetch_data_word(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = srcval;
        break;
    case 1:
        destreg = decode_rm_seg_register(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        srcval = fetch_data_word(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = srcval;
        break;
    case 2:
        destreg = decode_rm_seg_register(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        srcval = fetch_data_word(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = srcval;
        break;
    case 3:                    /* register to register */
        destreg = decode_rm_seg_register(rh);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_WORD_REGISTER(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = *srcreg;
        break;
    }
    /*
     * Clean up, and reset all the R_xSP pointers to the correct
     * locations.  This is about 3x too much overhead (doing all the
     * segreg ptrs when only one is needed, but this instruction
     * *cannot* be that common, and this isn't too much work anyway.
     */
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x8f
****************************************************************************/
static void
x86emuOp_pop_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("POP\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    if (rh != 0) {
        DECODE_PRINTF("ILLEGAL DECODE OF OPCODE 8F\n");
        HALT_SYS();
    }
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = pop_long();
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = pop_word();
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = pop_long();
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = pop_word();
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = pop_long();
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            destval = pop_word();
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = pop_long();
        }
        else {
            u16 *destreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = pop_word();
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x90
****************************************************************************/
static void
x86emuOp_nop(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("NOP\n");
    TRACE_AND_STEP();
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x91
****************************************************************************/
static void
x86emuOp_xchg_word_AX_CX(u8 X86EMU_UNUSED(op1))
{
    u32 tmp;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("XCHG\tEAX,ECX\n");
    }
    else {
        DECODE_PRINTF("XCHG\tAX,CX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        tmp = M.x86.R_EAX;
        M.x86.R_EAX = M.x86.R_ECX;
        M.x86.R_ECX = tmp;
    }
    else {
        tmp = M.x86.R_AX;
        M.x86.R_AX = M.x86.R_CX;
        M.x86.R_CX = (u16) tmp;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x92
****************************************************************************/
static void
x86emuOp_xchg_word_AX_DX(u8 X86EMU_UNUSED(op1))
{
    u32 tmp;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("XCHG\tEAX,EDX\n");
    }
    else {
        DECODE_PRINTF("XCHG\tAX,DX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        tmp = M.x86.R_EAX;
        M.x86.R_EAX = M.x86.R_EDX;
        M.x86.R_EDX = tmp;
    }
    else {
        tmp = M.x86.R_AX;
        M.x86.R_AX = M.x86.R_DX;
        M.x86.R_DX = (u16) tmp;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x93
****************************************************************************/
static void
x86emuOp_xchg_word_AX_BX(u8 X86EMU_UNUSED(op1))
{
    u32 tmp;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("XCHG\tEAX,EBX\n");
    }
    else {
        DECODE_PRINTF("XCHG\tAX,BX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        tmp = M.x86.R_EAX;
        M.x86.R_EAX = M.x86.R_EBX;
        M.x86.R_EBX = tmp;
    }
    else {
        tmp = M.x86.R_AX;
        M.x86.R_AX = M.x86.R_BX;
        M.x86.R_BX = (u16) tmp;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x94
****************************************************************************/
static void
x86emuOp_xchg_word_AX_SP(u8 X86EMU_UNUSED(op1))
{
    u32 tmp;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("XCHG\tEAX,ESP\n");
    }
    else {
        DECODE_PRINTF("XCHG\tAX,SP\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        tmp = M.x86.R_EAX;
        M.x86.R_EAX = M.x86.R_ESP;
        M.x86.R_ESP = tmp;
    }
    else {
        tmp = M.x86.R_AX;
        M.x86.R_AX = M.x86.R_SP;
        M.x86.R_SP = (u16) tmp;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x95
****************************************************************************/
static void
x86emuOp_xchg_word_AX_BP(u8 X86EMU_UNUSED(op1))
{
    u32 tmp;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("XCHG\tEAX,EBP\n");
    }
    else {
        DECODE_PRINTF("XCHG\tAX,BP\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        tmp = M.x86.R_EAX;
        M.x86.R_EAX = M.x86.R_EBP;
        M.x86.R_EBP = tmp;
    }
    else {
        tmp = M.x86.R_AX;
        M.x86.R_AX = M.x86.R_BP;
        M.x86.R_BP = (u16) tmp;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x96
****************************************************************************/
static void
x86emuOp_xchg_word_AX_SI(u8 X86EMU_UNUSED(op1))
{
    u32 tmp;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("XCHG\tEAX,ESI\n");
    }
    else {
        DECODE_PRINTF("XCHG\tAX,SI\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        tmp = M.x86.R_EAX;
        M.x86.R_EAX = M.x86.R_ESI;
        M.x86.R_ESI = tmp;
    }
    else {
        tmp = M.x86.R_AX;
        M.x86.R_AX = M.x86.R_SI;
        M.x86.R_SI = (u16) tmp;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x97
****************************************************************************/
static void
x86emuOp_xchg_word_AX_DI(u8 X86EMU_UNUSED(op1))
{
    u32 tmp;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("XCHG\tEAX,EDI\n");
    }
    else {
        DECODE_PRINTF("XCHG\tAX,DI\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        tmp = M.x86.R_EAX;
        M.x86.R_EAX = M.x86.R_EDI;
        M.x86.R_EDI = tmp;
    }
    else {
        tmp = M.x86.R_AX;
        M.x86.R_AX = M.x86.R_DI;
        M.x86.R_DI = (u16) tmp;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x98
****************************************************************************/
static void
x86emuOp_cbw(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("CWDE\n");
    }
    else {
        DECODE_PRINTF("CBW\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        if (M.x86.R_AX & 0x8000) {
            M.x86.R_EAX |= 0xffff0000;
        }
        else {
            M.x86.R_EAX &= 0x0000ffff;
        }
    }
    else {
        if (M.x86.R_AL & 0x80) {
            M.x86.R_AH = 0xff;
        }
        else {
            M.x86.R_AH = 0x0;
        }
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x99
****************************************************************************/
static void
x86emuOp_cwd(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("CDQ\n");
    }
    else {
        DECODE_PRINTF("CWD\n");
    }
    DECODE_PRINTF("CWD\n");
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        if (M.x86.R_EAX & 0x80000000) {
            M.x86.R_EDX = 0xffffffff;
        }
        else {
            M.x86.R_EDX = 0x0;
        }
    }
    else {
        if (M.x86.R_AX & 0x8000) {
            M.x86.R_DX = 0xffff;
        }
        else {
            M.x86.R_DX = 0x0;
        }
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x9a
****************************************************************************/
static void
x86emuOp_call_far_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 farseg, faroff;

    START_OF_INSTR();
    DECODE_PRINTF("CALL\t");
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        faroff = fetch_long_imm();
        farseg = fetch_word_imm();
    }
    else {
        faroff = fetch_word_imm();
        farseg = fetch_word_imm();
    }
    DECODE_PRINTF2("%04x:", farseg);
    DECODE_PRINTF2("%04x\n", faroff);
    CALL_TRACE(M.x86.saved_cs, M.x86.saved_ip, farseg, faroff, "FAR ");

    /* XXX
     *
     * Hooked interrupt vectors calling into our "BIOS" will cause
     * problems unless all intersegment stuff is checked for BIOS
     * access.  Check needed here.  For moment, let it alone.
     */
    TRACE_AND_STEP();
    push_word(M.x86.R_CS);
    M.x86.R_CS = farseg;
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        push_long(M.x86.R_EIP);
    }
    else {
        push_word(M.x86.R_IP);
    }
    M.x86.R_EIP = faroff & 0xffff;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x9b
****************************************************************************/
static void
x86emuOp_wait(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("WAIT");
    TRACE_AND_STEP();
    /* NADA.  */
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x9c
****************************************************************************/
static void
x86emuOp_pushf_word(u8 X86EMU_UNUSED(op1))
{
    u32 flags;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("PUSHFD\n");
    }
    else {
        DECODE_PRINTF("PUSHF\n");
    }
    TRACE_AND_STEP();

    /* clear out *all* bits not representing flags, and turn on real bits */
    flags = (M.x86.R_EFLG & F_MSK) | F_ALWAYS_ON;
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        push_long(flags);
    }
    else {
        push_word((u16) flags);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x9d
****************************************************************************/
static void
x86emuOp_popf_word(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("POPFD\n");
    }
    else {
        DECODE_PRINTF("POPF\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EFLG = pop_long();
    }
    else {
        M.x86.R_FLG = pop_word();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x9e
****************************************************************************/
static void
x86emuOp_sahf(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("SAHF\n");
    TRACE_AND_STEP();
    /* clear the lower bits of the flag register */
    M.x86.R_FLG &= 0xffffff00;
    /* or in the AH register into the flags register */
    M.x86.R_FLG |= M.x86.R_AH;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x9f
****************************************************************************/
static void
x86emuOp_lahf(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("LAHF\n");
    TRACE_AND_STEP();
    M.x86.R_AH = (u8) (M.x86.R_FLG & 0xff);
    /*undocumented TC++ behavior??? Nope.  It's documented, but
       you have too look real hard to notice it. */
    M.x86.R_AH |= 0x2;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xa0
****************************************************************************/
static void
x86emuOp_mov_AL_M_IMM(u8 X86EMU_UNUSED(op1))
{
    u16 offset;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\tAL,");
    offset = fetch_word_imm();
    DECODE_PRINTF2("[%04x]\n", offset);
    TRACE_AND_STEP();
    M.x86.R_AL = fetch_data_byte(offset);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xa1
****************************************************************************/
static void
x86emuOp_mov_AX_M_IMM(u8 X86EMU_UNUSED(op1))
{
    u16 offset;

    START_OF_INSTR();
    offset = fetch_word_imm();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF2("MOV\tEAX,[%04x]\n", offset);
    }
    else {
        DECODE_PRINTF2("MOV\tAX,[%04x]\n", offset);
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EAX = fetch_data_long(offset);
    }
    else {
        M.x86.R_AX = fetch_data_word(offset);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xa2
****************************************************************************/
static void
x86emuOp_mov_M_AL_IMM(u8 X86EMU_UNUSED(op1))
{
    u16 offset;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\t");
    offset = fetch_word_imm();
    DECODE_PRINTF2("[%04x],AL\n", offset);
    TRACE_AND_STEP();
    store_data_byte(offset, M.x86.R_AL);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xa3
****************************************************************************/
static void
x86emuOp_mov_M_AX_IMM(u8 X86EMU_UNUSED(op1))
{
    u16 offset;

    START_OF_INSTR();
    offset = fetch_word_imm();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF2("MOV\t[%04x],EAX\n", offset);
    }
    else {
        DECODE_PRINTF2("MOV\t[%04x],AX\n", offset);
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        store_data_long(offset, M.x86.R_EAX);
    }
    else {
        store_data_word(offset, M.x86.R_AX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xa4
****************************************************************************/
static void
x86emuOp_movs_byte(u8 X86EMU_UNUSED(op1))
{
    u8 val;
    u32 count;
    int inc;

    START_OF_INSTR();
    DECODE_PRINTF("MOVS\tBYTE\n");
    if (ACCESS_FLAG(F_DF))      /* down */
        inc = -1;
    else
        inc = 1;
    TRACE_AND_STEP();
    count = 1;
    if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {
        /* dont care whether REPE or REPNE */
        /* move them until CX is ZERO. */
        count = M.x86.R_CX;
        M.x86.R_CX = 0;
        M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
    }
    while (count--) {
        val = fetch_data_byte(M.x86.R_SI);
        store_data_byte_abs(M.x86.R_ES, M.x86.R_DI, val);
        M.x86.R_SI += inc;
        M.x86.R_DI += inc;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xa5
****************************************************************************/
static void
x86emuOp_movs_word(u8 X86EMU_UNUSED(op1))
{
    u32 val;
    int inc;
    u32 count;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("MOVS\tDWORD\n");
        if (ACCESS_FLAG(F_DF))  /* down */
            inc = -4;
        else
            inc = 4;
    }
    else {
        DECODE_PRINTF("MOVS\tWORD\n");
        if (ACCESS_FLAG(F_DF))  /* down */
            inc = -2;
        else
            inc = 2;
    }
    TRACE_AND_STEP();
    count = 1;
    if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {
        /* dont care whether REPE or REPNE */
        /* move them until CX is ZERO. */
        count = M.x86.R_CX;
        M.x86.R_CX = 0;
        M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
    }
    while (count--) {
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            val = fetch_data_long(M.x86.R_SI);
            store_data_long_abs(M.x86.R_ES, M.x86.R_DI, val);
        }
        else {
            val = fetch_data_word(M.x86.R_SI);
            store_data_word_abs(M.x86.R_ES, M.x86.R_DI, (u16) val);
        }
        M.x86.R_SI += inc;
        M.x86.R_DI += inc;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xa6
****************************************************************************/
static void
x86emuOp_cmps_byte(u8 X86EMU_UNUSED(op1))
{
    s8 val1, val2;
    int inc;

    START_OF_INSTR();
    DECODE_PRINTF("CMPS\tBYTE\n");
    TRACE_AND_STEP();
    if (ACCESS_FLAG(F_DF))      /* down */
        inc = -1;
    else
        inc = 1;

    if (M.x86.mode & SYSMODE_PREFIX_REPE) {
        /* REPE  */
        /* move them until CX is ZERO. */
        while (M.x86.R_CX != 0) {
            val1 = fetch_data_byte(M.x86.R_SI);
            val2 = fetch_data_byte_abs(M.x86.R_ES, M.x86.R_DI);
            cmp_byte(val1, val2);
            M.x86.R_CX -= 1;
            M.x86.R_SI += inc;
            M.x86.R_DI += inc;
            if (ACCESS_FLAG(F_ZF) == 0)
                break;
        }
        M.x86.mode &= ~SYSMODE_PREFIX_REPE;
    }
    else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
        /* REPNE  */
        /* move them until CX is ZERO. */
        while (M.x86.R_CX != 0) {
            val1 = fetch_data_byte(M.x86.R_SI);
            val2 = fetch_data_byte_abs(M.x86.R_ES, M.x86.R_DI);
            cmp_byte(val1, val2);
            M.x86.R_CX -= 1;
            M.x86.R_SI += inc;
            M.x86.R_DI += inc;
            if (ACCESS_FLAG(F_ZF))
                break;          /* zero flag set means equal */
        }
        M.x86.mode &= ~SYSMODE_PREFIX_REPNE;
    }
    else {
        val1 = fetch_data_byte(M.x86.R_SI);
        val2 = fetch_data_byte_abs(M.x86.R_ES, M.x86.R_DI);
        cmp_byte(val1, val2);
        M.x86.R_SI += inc;
        M.x86.R_DI += inc;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xa7
****************************************************************************/
static void
x86emuOp_cmps_word(u8 X86EMU_UNUSED(op1))
{
    u32 val1, val2;
    int inc;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("CMPS\tDWORD\n");
        if (ACCESS_FLAG(F_DF))  /* down */
            inc = -4;
        else
            inc = 4;
    }
    else {
        DECODE_PRINTF("CMPS\tWORD\n");
        if (ACCESS_FLAG(F_DF))  /* down */
            inc = -2;
        else
            inc = 2;
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_REPE) {
        /* REPE  */
        /* move them until CX is ZERO. */
        while (M.x86.R_CX != 0) {
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                val1 = fetch_data_long(M.x86.R_SI);
                val2 = fetch_data_long_abs(M.x86.R_ES, M.x86.R_DI);
                cmp_long(val1, val2);
            }
            else {
                val1 = fetch_data_word(M.x86.R_SI);
                val2 = fetch_data_word_abs(M.x86.R_ES, M.x86.R_DI);
                cmp_word((u16) val1, (u16) val2);
            }
            M.x86.R_CX -= 1;
            M.x86.R_SI += inc;
            M.x86.R_DI += inc;
            if (ACCESS_FLAG(F_ZF) == 0)
                break;
        }
        M.x86.mode &= ~SYSMODE_PREFIX_REPE;
    }
    else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
        /* REPNE  */
        /* move them until CX is ZERO. */
        while (M.x86.R_CX != 0) {
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                val1 = fetch_data_long(M.x86.R_SI);
                val2 = fetch_data_long_abs(M.x86.R_ES, M.x86.R_DI);
                cmp_long(val1, val2);
            }
            else {
                val1 = fetch_data_word(M.x86.R_SI);
                val2 = fetch_data_word_abs(M.x86.R_ES, M.x86.R_DI);
                cmp_word((u16) val1, (u16) val2);
            }
            M.x86.R_CX -= 1;
            M.x86.R_SI += inc;
            M.x86.R_DI += inc;
            if (ACCESS_FLAG(F_ZF))
                break;          /* zero flag set means equal */
        }
        M.x86.mode &= ~SYSMODE_PREFIX_REPNE;
    }
    else {
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            val1 = fetch_data_long(M.x86.R_SI);
            val2 = fetch_data_long_abs(M.x86.R_ES, M.x86.R_DI);
            cmp_long(val1, val2);
        }
        else {
            val1 = fetch_data_word(M.x86.R_SI);
            val2 = fetch_data_word_abs(M.x86.R_ES, M.x86.R_DI);
            cmp_word((u16) val1, (u16) val2);
        }
        M.x86.R_SI += inc;
        M.x86.R_DI += inc;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xa8
****************************************************************************/
static void
x86emuOp_test_AL_IMM(u8 X86EMU_UNUSED(op1))
{
    int imm;

    START_OF_INSTR();
    DECODE_PRINTF("TEST\tAL,");
    imm = fetch_byte_imm();
    DECODE_PRINTF2("%04x\n", imm);
    TRACE_AND_STEP();
    test_byte(M.x86.R_AL, (u8) imm);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xa9
****************************************************************************/
static void
x86emuOp_test_AX_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("TEST\tEAX,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("TEST\tAX,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        test_long(M.x86.R_EAX, srcval);
    }
    else {
        test_word(M.x86.R_AX, (u16) srcval);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xaa
****************************************************************************/
static void
x86emuOp_stos_byte(u8 X86EMU_UNUSED(op1))
{
    int inc;

    START_OF_INSTR();
    DECODE_PRINTF("STOS\tBYTE\n");
    if (ACCESS_FLAG(F_DF))      /* down */
        inc = -1;
    else
        inc = 1;
    TRACE_AND_STEP();
    if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {
        /* dont care whether REPE or REPNE */
        /* move them until CX is ZERO. */
        while (M.x86.R_CX != 0) {
            store_data_byte_abs(M.x86.R_ES, M.x86.R_DI, M.x86.R_AL);
            M.x86.R_CX -= 1;
            M.x86.R_DI += inc;
        }
        M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
    }
    else {
        store_data_byte_abs(M.x86.R_ES, M.x86.R_DI, M.x86.R_AL);
        M.x86.R_DI += inc;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xab
****************************************************************************/
static void
x86emuOp_stos_word(u8 X86EMU_UNUSED(op1))
{
    int inc;
    u32 count;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("STOS\tDWORD\n");
        if (ACCESS_FLAG(F_DF))  /* down */
            inc = -4;
        else
            inc = 4;
    }
    else {
        DECODE_PRINTF("STOS\tWORD\n");
        if (ACCESS_FLAG(F_DF))  /* down */
            inc = -2;
        else
            inc = 2;
    }
    TRACE_AND_STEP();
    count = 1;
    if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {
        /* dont care whether REPE or REPNE */
        /* move them until CX is ZERO. */
        count = M.x86.R_CX;
        M.x86.R_CX = 0;
        M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
    }
    while (count--) {
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            store_data_long_abs(M.x86.R_ES, M.x86.R_DI, M.x86.R_EAX);
        }
        else {
            store_data_word_abs(M.x86.R_ES, M.x86.R_DI, M.x86.R_AX);
        }
        M.x86.R_DI += inc;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xac
****************************************************************************/
static void
x86emuOp_lods_byte(u8 X86EMU_UNUSED(op1))
{
    int inc;

    START_OF_INSTR();
    DECODE_PRINTF("LODS\tBYTE\n");
    TRACE_AND_STEP();
    if (ACCESS_FLAG(F_DF))      /* down */
        inc = -1;
    else
        inc = 1;
    if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {
        /* dont care whether REPE or REPNE */
        /* move them until CX is ZERO. */
        while (M.x86.R_CX != 0) {
            M.x86.R_AL = fetch_data_byte(M.x86.R_SI);
            M.x86.R_CX -= 1;
            M.x86.R_SI += inc;
        }
        M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
    }
    else {
        M.x86.R_AL = fetch_data_byte(M.x86.R_SI);
        M.x86.R_SI += inc;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xad
****************************************************************************/
static void
x86emuOp_lods_word(u8 X86EMU_UNUSED(op1))
{
    int inc;
    u32 count;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("LODS\tDWORD\n");
        if (ACCESS_FLAG(F_DF))  /* down */
            inc = -4;
        else
            inc = 4;
    }
    else {
        DECODE_PRINTF("LODS\tWORD\n");
        if (ACCESS_FLAG(F_DF))  /* down */
            inc = -2;
        else
            inc = 2;
    }
    TRACE_AND_STEP();
    count = 1;
    if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {
        /* dont care whether REPE or REPNE */
        /* move them until CX is ZERO. */
        count = M.x86.R_CX;
        M.x86.R_CX = 0;
        M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
    }
    while (count--) {
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            M.x86.R_EAX = fetch_data_long(M.x86.R_SI);
        }
        else {
            M.x86.R_AX = fetch_data_word(M.x86.R_SI);
        }
        M.x86.R_SI += inc;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xae
****************************************************************************/
static void
x86emuOp_scas_byte(u8 X86EMU_UNUSED(op1))
{
    s8 val2;
    int inc;

    START_OF_INSTR();
    DECODE_PRINTF("SCAS\tBYTE\n");
    TRACE_AND_STEP();
    if (ACCESS_FLAG(F_DF))      /* down */
        inc = -1;
    else
        inc = 1;
    if (M.x86.mode & SYSMODE_PREFIX_REPE) {
        /* REPE  */
        /* move them until CX is ZERO. */
        while (M.x86.R_CX != 0) {
            val2 = fetch_data_byte_abs(M.x86.R_ES, M.x86.R_DI);
            cmp_byte(M.x86.R_AL, val2);
            M.x86.R_CX -= 1;
            M.x86.R_DI += inc;
            if (ACCESS_FLAG(F_ZF) == 0)
                break;
        }
        M.x86.mode &= ~SYSMODE_PREFIX_REPE;
    }
    else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
        /* REPNE  */
        /* move them until CX is ZERO. */
        while (M.x86.R_CX != 0) {
            val2 = fetch_data_byte_abs(M.x86.R_ES, M.x86.R_DI);
            cmp_byte(M.x86.R_AL, val2);
            M.x86.R_CX -= 1;
            M.x86.R_DI += inc;
            if (ACCESS_FLAG(F_ZF))
                break;          /* zero flag set means equal */
        }
        M.x86.mode &= ~SYSMODE_PREFIX_REPNE;
    }
    else {
        val2 = fetch_data_byte_abs(M.x86.R_ES, M.x86.R_DI);
        cmp_byte(M.x86.R_AL, val2);
        M.x86.R_DI += inc;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xaf
****************************************************************************/
static void
x86emuOp_scas_word(u8 X86EMU_UNUSED(op1))
{
    int inc;
    u32 val;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("SCAS\tDWORD\n");
        if (ACCESS_FLAG(F_DF))  /* down */
            inc = -4;
        else
            inc = 4;
    }
    else {
        DECODE_PRINTF("SCAS\tWORD\n");
        if (ACCESS_FLAG(F_DF))  /* down */
            inc = -2;
        else
            inc = 2;
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_REPE) {
        /* REPE  */
        /* move them until CX is ZERO. */
        while (M.x86.R_CX != 0) {
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                val = fetch_data_long_abs(M.x86.R_ES, M.x86.R_DI);
                cmp_long(M.x86.R_EAX, val);
            }
            else {
                val = fetch_data_word_abs(M.x86.R_ES, M.x86.R_DI);
                cmp_word(M.x86.R_AX, (u16) val);
            }
            M.x86.R_CX -= 1;
            M.x86.R_DI += inc;
            if (ACCESS_FLAG(F_ZF) == 0)
                break;
        }
        M.x86.mode &= ~SYSMODE_PREFIX_REPE;
    }
    else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
        /* REPNE  */
        /* move them until CX is ZERO. */
        while (M.x86.R_CX != 0) {
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                val = fetch_data_long_abs(M.x86.R_ES, M.x86.R_DI);
                cmp_long(M.x86.R_EAX, val);
            }
            else {
                val = fetch_data_word_abs(M.x86.R_ES, M.x86.R_DI);
                cmp_word(M.x86.R_AX, (u16) val);
            }
            M.x86.R_CX -= 1;
            M.x86.R_DI += inc;
            if (ACCESS_FLAG(F_ZF))
                break;          /* zero flag set means equal */
        }
        M.x86.mode &= ~SYSMODE_PREFIX_REPNE;
    }
    else {
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            val = fetch_data_long_abs(M.x86.R_ES, M.x86.R_DI);
            cmp_long(M.x86.R_EAX, val);
        }
        else {
            val = fetch_data_word_abs(M.x86.R_ES, M.x86.R_DI);
            cmp_word(M.x86.R_AX, (u16) val);
        }
        M.x86.R_DI += inc;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xb0
****************************************************************************/
static void
x86emuOp_mov_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 imm;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\tAL,");
    imm = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", imm);
    TRACE_AND_STEP();
    M.x86.R_AL = imm;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xb1
****************************************************************************/
static void
x86emuOp_mov_byte_CL_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 imm;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\tCL,");
    imm = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", imm);
    TRACE_AND_STEP();
    M.x86.R_CL = imm;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xb2
****************************************************************************/
static void
x86emuOp_mov_byte_DL_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 imm;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\tDL,");
    imm = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", imm);
    TRACE_AND_STEP();
    M.x86.R_DL = imm;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xb3
****************************************************************************/
static void
x86emuOp_mov_byte_BL_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 imm;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\tBL,");
    imm = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", imm);
    TRACE_AND_STEP();
    M.x86.R_BL = imm;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xb4
****************************************************************************/
static void
x86emuOp_mov_byte_AH_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 imm;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\tAH,");
    imm = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", imm);
    TRACE_AND_STEP();
    M.x86.R_AH = imm;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xb5
****************************************************************************/
static void
x86emuOp_mov_byte_CH_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 imm;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\tCH,");
    imm = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", imm);
    TRACE_AND_STEP();
    M.x86.R_CH = imm;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xb6
****************************************************************************/
static void
x86emuOp_mov_byte_DH_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 imm;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\tDH,");
    imm = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", imm);
    TRACE_AND_STEP();
    M.x86.R_DH = imm;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xb7
****************************************************************************/
static void
x86emuOp_mov_byte_BH_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 imm;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\tBH,");
    imm = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", imm);
    TRACE_AND_STEP();
    M.x86.R_BH = imm;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xb8
****************************************************************************/
static void
x86emuOp_mov_word_AX_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("MOV\tEAX,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("MOV\tAX,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EAX = srcval;
    }
    else {
        M.x86.R_AX = (u16) srcval;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xb9
****************************************************************************/
static void
x86emuOp_mov_word_CX_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("MOV\tECX,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("MOV\tCX,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_ECX = srcval;
    }
    else {
        M.x86.R_CX = (u16) srcval;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xba
****************************************************************************/
static void
x86emuOp_mov_word_DX_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("MOV\tEDX,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("MOV\tDX,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EDX = srcval;
    }
    else {
        M.x86.R_DX = (u16) srcval;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xbb
****************************************************************************/
static void
x86emuOp_mov_word_BX_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("MOV\tEBX,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("MOV\tBX,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EBX = srcval;
    }
    else {
        M.x86.R_BX = (u16) srcval;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xbc
****************************************************************************/
static void
x86emuOp_mov_word_SP_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("MOV\tESP,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("MOV\tSP,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_ESP = srcval;
    }
    else {
        M.x86.R_SP = (u16) srcval;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xbd
****************************************************************************/
static void
x86emuOp_mov_word_BP_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("MOV\tEBP,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("MOV\tBP,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EBP = srcval;
    }
    else {
        M.x86.R_BP = (u16) srcval;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xbe
****************************************************************************/
static void
x86emuOp_mov_word_SI_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("MOV\tESI,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("MOV\tSI,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_ESI = srcval;
    }
    else {
        M.x86.R_SI = (u16) srcval;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xbf
****************************************************************************/
static void
x86emuOp_mov_word_DI_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 srcval;

    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("MOV\tEDI,");
        srcval = fetch_long_imm();
    }
    else {
        DECODE_PRINTF("MOV\tDI,");
        srcval = fetch_word_imm();
    }
    DECODE_PRINTF2("%x\n", srcval);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EDI = srcval;
    }
    else {
        M.x86.R_DI = (u16) srcval;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/* used by opcodes c0, d0, and d2. */
static u8(*opcD0_byte_operation[]) (u8 d, u8 s) = {
    rol_byte, ror_byte, rcl_byte, rcr_byte, shl_byte, shr_byte, shl_byte,       /* sal_byte === shl_byte  by definition */
sar_byte,};

/****************************************************************************
REMARKS:
Handles opcode 0xc0
****************************************************************************/
static void
x86emuOp_opcC0_byte_RM_MEM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg;
    uint destoffset;
    u8 destval;
    u8 amt;

    /*
     * Yet another weirdo special case instruction format.  Part of
     * the opcode held below in "RH".  Doubly nested case would
     * result, except that the decoded instruction
     */
    START_OF_INSTR();
    FETCH_DECODE_MODRM(mod, rh, rl);
#ifdef DEBUG
    if (DEBUG_DECODE()) {
        /* XXX DECODE_PRINTF may be changed to something more
           general, so that it is important to leave the strings
           in the same format, even though the result is that the
           above test is done twice. */

        switch (rh) {
        case 0:
            DECODE_PRINTF("ROL\t");
            break;
        case 1:
            DECODE_PRINTF("ROR\t");
            break;
        case 2:
            DECODE_PRINTF("RCL\t");
            break;
        case 3:
            DECODE_PRINTF("RCR\t");
            break;
        case 4:
            DECODE_PRINTF("SHL\t");
            break;
        case 5:
            DECODE_PRINTF("SHR\t");
            break;
        case 6:
            DECODE_PRINTF("SAL\t");
            break;
        case 7:
            DECODE_PRINTF("SAR\t");
            break;
        }
    }
#endif
    /* know operation, decode the mod byte to find the addressing
       mode. */
    switch (mod) {
    case 0:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm00_address(rl);
        amt = fetch_byte_imm();
        DECODE_PRINTF2(",%x\n", amt);
        destval = fetch_data_byte(destoffset);
        TRACE_AND_STEP();
        destval = (*opcD0_byte_operation[rh]) (destval, amt);
        store_data_byte(destoffset, destval);
        break;
    case 1:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm01_address(rl);
        amt = fetch_byte_imm();
        DECODE_PRINTF2(",%x\n", amt);
        destval = fetch_data_byte(destoffset);
        TRACE_AND_STEP();
        destval = (*opcD0_byte_operation[rh]) (destval, amt);
        store_data_byte(destoffset, destval);
        break;
    case 2:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm10_address(rl);
        amt = fetch_byte_imm();
        DECODE_PRINTF2(",%x\n", amt);
        destval = fetch_data_byte(destoffset);
        TRACE_AND_STEP();
        destval = (*opcD0_byte_operation[rh]) (destval, amt);
        store_data_byte(destoffset, destval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        amt = fetch_byte_imm();
        DECODE_PRINTF2(",%x\n", amt);
        TRACE_AND_STEP();
        destval = (*opcD0_byte_operation[rh]) (*destreg, amt);
        *destreg = destval;
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/* used by opcodes c1, d1, and d3. */
static u16(*opcD1_word_operation[]) (u16 s, u8 d) = {
    rol_word, ror_word, rcl_word, rcr_word, shl_word, shr_word, shl_word,       /* sal_byte === shl_byte  by definition */
sar_word,};

/* used by opcodes c1, d1, and d3. */
static u32(*opcD1_long_operation[]) (u32 s, u8 d) = {
    rol_long, ror_long, rcl_long, rcr_long, shl_long, shr_long, shl_long,       /* sal_byte === shl_byte  by definition */
sar_long,};

/****************************************************************************
REMARKS:
Handles opcode 0xc1
****************************************************************************/
static void
x86emuOp_opcC1_word_RM_MEM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;
    u8 amt;

    /*
     * Yet another weirdo special case instruction format.  Part of
     * the opcode held below in "RH".  Doubly nested case would
     * result, except that the decoded instruction
     */
    START_OF_INSTR();
    FETCH_DECODE_MODRM(mod, rh, rl);
#ifdef DEBUG
    if (DEBUG_DECODE()) {
        /* XXX DECODE_PRINTF may be changed to something more
           general, so that it is important to leave the strings
           in the same format, even though the result is that the
           above test is done twice. */

        switch (rh) {
        case 0:
            DECODE_PRINTF("ROL\t");
            break;
        case 1:
            DECODE_PRINTF("ROR\t");
            break;
        case 2:
            DECODE_PRINTF("RCL\t");
            break;
        case 3:
            DECODE_PRINTF("RCR\t");
            break;
        case 4:
            DECODE_PRINTF("SHL\t");
            break;
        case 5:
            DECODE_PRINTF("SHR\t");
            break;
        case 6:
            DECODE_PRINTF("SAL\t");
            break;
        case 7:
            DECODE_PRINTF("SAR\t");
            break;
        }
    }
#endif
    /* know operation, decode the mod byte to find the addressing
       mode. */
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm00_address(rl);
            amt = fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", amt);
            destval = fetch_data_long(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_long_operation[rh]) (destval, amt);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm00_address(rl);
            amt = fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", amt);
            destval = fetch_data_word(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_word_operation[rh]) (destval, amt);
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm01_address(rl);
            amt = fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", amt);
            destval = fetch_data_long(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_long_operation[rh]) (destval, amt);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm01_address(rl);
            amt = fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", amt);
            destval = fetch_data_word(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_word_operation[rh]) (destval, amt);
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm10_address(rl);
            amt = fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", amt);
            destval = fetch_data_long(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_long_operation[rh]) (destval, amt);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm10_address(rl);
            amt = fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", amt);
            destval = fetch_data_word(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_word_operation[rh]) (destval, amt);
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            amt = fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", amt);
            TRACE_AND_STEP();
            *destreg = (*opcD1_long_operation[rh]) (*destreg, amt);
        }
        else {
            u16 *destreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            amt = fetch_byte_imm();
            DECODE_PRINTF2(",%x\n", amt);
            TRACE_AND_STEP();
            *destreg = (*opcD1_word_operation[rh]) (*destreg, amt);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xc2
****************************************************************************/
static void
x86emuOp_ret_near_IMM(u8 X86EMU_UNUSED(op1))
{
    u16 imm;

    START_OF_INSTR();
    DECODE_PRINTF("RET\t");
    imm = fetch_word_imm();
    DECODE_PRINTF2("%x\n", imm);
    RETURN_TRACE("RET", M.x86.saved_cs, M.x86.saved_ip);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EIP = pop_long();
    } else {
        M.x86.R_IP = pop_word();
    }
    M.x86.R_SP += imm;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xc3
****************************************************************************/
static void
x86emuOp_ret_near(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("RET\n");
    RETURN_TRACE("RET", M.x86.saved_cs, M.x86.saved_ip);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EIP = pop_long();
    } else {
        M.x86.R_IP = pop_word();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xc4
****************************************************************************/
static void
x86emuOp_les_R_IMM(u8 X86EMU_UNUSED(op1))
{
    int mod, rh, rl;
    u16 *dstreg;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("LES\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        dstreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *dstreg = fetch_data_word(srcoffset);
        M.x86.R_ES = fetch_data_word(srcoffset + 2);
        break;
    case 1:
        dstreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *dstreg = fetch_data_word(srcoffset);
        M.x86.R_ES = fetch_data_word(srcoffset + 2);
        break;
    case 2:
        dstreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *dstreg = fetch_data_word(srcoffset);
        M.x86.R_ES = fetch_data_word(srcoffset + 2);
        break;
    case 3:                    /* register to register */
        /* UNDEFINED! */
        TRACE_AND_STEP();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xc5
****************************************************************************/
static void
x86emuOp_lds_R_IMM(u8 X86EMU_UNUSED(op1))
{
    int mod, rh, rl;
    u16 *dstreg;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("LDS\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        dstreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *dstreg = fetch_data_word(srcoffset);
        M.x86.R_DS = fetch_data_word(srcoffset + 2);
        break;
    case 1:
        dstreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *dstreg = fetch_data_word(srcoffset);
        M.x86.R_DS = fetch_data_word(srcoffset + 2);
        break;
    case 2:
        dstreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *dstreg = fetch_data_word(srcoffset);
        M.x86.R_DS = fetch_data_word(srcoffset + 2);
        break;
    case 3:                    /* register to register */
        /* UNDEFINED! */
        TRACE_AND_STEP();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xc6
****************************************************************************/
static void
x86emuOp_mov_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg;
    uint destoffset;
    u8 imm;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    if (rh != 0) {
        DECODE_PRINTF("ILLEGAL DECODE OF OPCODE c6\n");
        HALT_SYS();
    }
    switch (mod) {
    case 0:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm00_address(rl);
        imm = fetch_byte_imm();
        DECODE_PRINTF2(",%2x\n", imm);
        TRACE_AND_STEP();
        store_data_byte(destoffset, imm);
        break;
    case 1:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm01_address(rl);
        imm = fetch_byte_imm();
        DECODE_PRINTF2(",%2x\n", imm);
        TRACE_AND_STEP();
        store_data_byte(destoffset, imm);
        break;
    case 2:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm10_address(rl);
        imm = fetch_byte_imm();
        DECODE_PRINTF2(",%2x\n", imm);
        TRACE_AND_STEP();
        store_data_byte(destoffset, imm);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        imm = fetch_byte_imm();
        DECODE_PRINTF2(",%2x\n", imm);
        TRACE_AND_STEP();
        *destreg = imm;
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xc7
****************************************************************************/
static void
x86emuOp_mov_word_RM_IMM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("MOV\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    if (rh != 0) {
        DECODE_PRINTF("ILLEGAL DECODE OF OPCODE 8F\n");
        HALT_SYS();
    }
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 imm;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm00_address(rl);
            imm = fetch_long_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            store_data_long(destoffset, imm);
        }
        else {
            u16 imm;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm00_address(rl);
            imm = fetch_word_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            store_data_word(destoffset, imm);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 imm;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm01_address(rl);
            imm = fetch_long_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            store_data_long(destoffset, imm);
        }
        else {
            u16 imm;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm01_address(rl);
            imm = fetch_word_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            store_data_word(destoffset, imm);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 imm;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm10_address(rl);
            imm = fetch_long_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            store_data_long(destoffset, imm);
        }
        else {
            u16 imm;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm10_address(rl);
            imm = fetch_word_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            store_data_word(destoffset, imm);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 imm;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            imm = fetch_long_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            *destreg = imm;
        }
        else {
            u16 *destreg;
            u16 imm;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            imm = fetch_word_imm();
            DECODE_PRINTF2(",%x\n", imm);
            TRACE_AND_STEP();
            *destreg = imm;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xc8
****************************************************************************/
static void
x86emuOp_enter(u8 X86EMU_UNUSED(op1))
{
    u16 local, frame_pointer;
    u8 nesting;
    int i;

    START_OF_INSTR();
    local = fetch_word_imm();
    nesting = fetch_byte_imm();
    DECODE_PRINTF2("ENTER %x\n", local);
    DECODE_PRINTF2(",%x\n", nesting);
    TRACE_AND_STEP();
    push_word(M.x86.R_BP);
    frame_pointer = M.x86.R_SP;
    if (nesting > 0) {
        for (i = 1; i < nesting; i++) {
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                M.x86.R_BP -= 4;
                push_long(fetch_data_long_abs(M.x86.R_SS, M.x86.R_BP));
            } else {
                M.x86.R_BP -= 2;
                push_word(fetch_data_word_abs(M.x86.R_SS, M.x86.R_BP));
            }
        }
        push_word(frame_pointer);
    }
    M.x86.R_BP = frame_pointer;
    M.x86.R_SP = (u16) (M.x86.R_SP - local);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xc9
****************************************************************************/
static void
x86emuOp_leave(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("LEAVE\n");
    TRACE_AND_STEP();
    M.x86.R_SP = M.x86.R_BP;
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EBP = pop_long();
    } else {
        M.x86.R_BP = pop_word();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xca
****************************************************************************/
static void
x86emuOp_ret_far_IMM(u8 X86EMU_UNUSED(op1))
{
    u16 imm;

    START_OF_INSTR();
    DECODE_PRINTF("RETF\t");
    imm = fetch_word_imm();
    DECODE_PRINTF2("%x\n", imm);
    RETURN_TRACE("RETF", M.x86.saved_cs, M.x86.saved_ip);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EIP = pop_long();
        M.x86.R_CS = pop_long() & 0xffff;
    } else {
        M.x86.R_IP = pop_word();
        M.x86.R_CS = pop_word();
    }
    M.x86.R_SP += imm;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xcb
****************************************************************************/
static void
x86emuOp_ret_far(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("RETF\n");
    RETURN_TRACE("RETF", M.x86.saved_cs, M.x86.saved_ip);
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EIP = pop_long();
        M.x86.R_CS = pop_long() & 0xffff;
    } else {
        M.x86.R_IP = pop_word();
        M.x86.R_CS = pop_word();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xcc
****************************************************************************/
static void
x86emuOp_int3(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("INT 3\n");
    TRACE_AND_STEP();
    if (_X86EMU_intrTab[3]) {
        (*_X86EMU_intrTab[3]) (3);
    }
    else {
        push_word((u16) M.x86.R_FLG);
        CLEAR_FLAG(F_IF);
        CLEAR_FLAG(F_TF);
        push_word(M.x86.R_CS);
        M.x86.R_CS = mem_access_word(3 * 4 + 2);
        push_word(M.x86.R_IP);
        M.x86.R_IP = mem_access_word(3 * 4);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xcd
****************************************************************************/
static void
x86emuOp_int_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 intnum;

    START_OF_INSTR();
    DECODE_PRINTF("INT\t");
    intnum = fetch_byte_imm();
    DECODE_PRINTF2("%x\n", intnum);
    TRACE_AND_STEP();
    if (_X86EMU_intrTab[intnum]) {
        (*_X86EMU_intrTab[intnum]) (intnum);
    }
    else {
        push_word((u16) M.x86.R_FLG);
        CLEAR_FLAG(F_IF);
        CLEAR_FLAG(F_TF);
        push_word(M.x86.R_CS);
        M.x86.R_CS = mem_access_word(intnum * 4 + 2);
        push_word(M.x86.R_IP);
        M.x86.R_IP = mem_access_word(intnum * 4);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xce
****************************************************************************/
static void
x86emuOp_into(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("INTO\n");
    TRACE_AND_STEP();
    if (ACCESS_FLAG(F_OF)) {
        if (_X86EMU_intrTab[4]) {
            (*_X86EMU_intrTab[4]) (4);
        }
        else {
            push_word((u16) M.x86.R_FLG);
            CLEAR_FLAG(F_IF);
            CLEAR_FLAG(F_TF);
            push_word(M.x86.R_CS);
            M.x86.R_CS = mem_access_word(4 * 4 + 2);
            push_word(M.x86.R_IP);
            M.x86.R_IP = mem_access_word(4 * 4);
        }
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xcf
****************************************************************************/
static void
x86emuOp_iret(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("IRET\n");

    TRACE_AND_STEP();

    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EIP = pop_long();
        M.x86.R_CS = pop_long() & 0xffff;
        M.x86.R_EFLG = (pop_long() & 0x257FD5) | (M.x86.R_EFLG & 0x1A0000);
    } else {
        M.x86.R_IP = pop_word();
        M.x86.R_CS = pop_word();
        M.x86.R_FLG = pop_word();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xd0
****************************************************************************/
static void
x86emuOp_opcD0_byte_RM_1(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg;
    uint destoffset;
    u8 destval;

    /*
     * Yet another weirdo special case instruction format.  Part of
     * the opcode held below in "RH".  Doubly nested case would
     * result, except that the decoded instruction
     */
    START_OF_INSTR();
    FETCH_DECODE_MODRM(mod, rh, rl);
#ifdef DEBUG
    if (DEBUG_DECODE()) {
        /* XXX DECODE_PRINTF may be changed to something more
           general, so that it is important to leave the strings
           in the same format, even though the result is that the
           above test is done twice. */
        switch (rh) {
        case 0:
            DECODE_PRINTF("ROL\t");
            break;
        case 1:
            DECODE_PRINTF("ROR\t");
            break;
        case 2:
            DECODE_PRINTF("RCL\t");
            break;
        case 3:
            DECODE_PRINTF("RCR\t");
            break;
        case 4:
            DECODE_PRINTF("SHL\t");
            break;
        case 5:
            DECODE_PRINTF("SHR\t");
            break;
        case 6:
            DECODE_PRINTF("SAL\t");
            break;
        case 7:
            DECODE_PRINTF("SAR\t");
            break;
        }
    }
#endif
    /* know operation, decode the mod byte to find the addressing
       mode. */
    switch (mod) {
    case 0:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF(",1\n");
        destval = fetch_data_byte(destoffset);
        TRACE_AND_STEP();
        destval = (*opcD0_byte_operation[rh]) (destval, 1);
        store_data_byte(destoffset, destval);
        break;
    case 1:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF(",1\n");
        destval = fetch_data_byte(destoffset);
        TRACE_AND_STEP();
        destval = (*opcD0_byte_operation[rh]) (destval, 1);
        store_data_byte(destoffset, destval);
        break;
    case 2:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF(",1\n");
        destval = fetch_data_byte(destoffset);
        TRACE_AND_STEP();
        destval = (*opcD0_byte_operation[rh]) (destval, 1);
        store_data_byte(destoffset, destval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF(",1\n");
        TRACE_AND_STEP();
        destval = (*opcD0_byte_operation[rh]) (*destreg, 1);
        *destreg = destval;
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xd1
****************************************************************************/
static void
x86emuOp_opcD1_word_RM_1(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    /*
     * Yet another weirdo special case instruction format.  Part of
     * the opcode held below in "RH".  Doubly nested case would
     * result, except that the decoded instruction
     */
    START_OF_INSTR();
    FETCH_DECODE_MODRM(mod, rh, rl);
#ifdef DEBUG
    if (DEBUG_DECODE()) {
        /* XXX DECODE_PRINTF may be changed to something more
           general, so that it is important to leave the strings
           in the same format, even though the result is that the
           above test is done twice. */
        switch (rh) {
        case 0:
            DECODE_PRINTF("ROL\t");
            break;
        case 1:
            DECODE_PRINTF("ROR\t");
            break;
        case 2:
            DECODE_PRINTF("RCL\t");
            break;
        case 3:
            DECODE_PRINTF("RCR\t");
            break;
        case 4:
            DECODE_PRINTF("SHL\t");
            break;
        case 5:
            DECODE_PRINTF("SHR\t");
            break;
        case 6:
            DECODE_PRINTF("SAL\t");
            break;
        case 7:
            DECODE_PRINTF("SAR\t");
            break;
        }
    }
#endif
    /* know operation, decode the mod byte to find the addressing
       mode. */
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",1\n");
            destval = fetch_data_long(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_long_operation[rh]) (destval, 1);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",1\n");
            destval = fetch_data_word(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_word_operation[rh]) (destval, 1);
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",1\n");
            destval = fetch_data_long(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_long_operation[rh]) (destval, 1);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",1\n");
            destval = fetch_data_word(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_word_operation[rh]) (destval, 1);
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",1\n");
            destval = fetch_data_long(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_long_operation[rh]) (destval, 1);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;

            DECODE_PRINTF("BYTE PTR ");
            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",1\n");
            destval = fetch_data_word(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_word_operation[rh]) (destval, 1);
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *destreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",1\n");
            TRACE_AND_STEP();
            destval = (*opcD1_long_operation[rh]) (*destreg, 1);
            *destreg = destval;
        }
        else {
            u16 destval;
            u16 *destreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",1\n");
            TRACE_AND_STEP();
            destval = (*opcD1_word_operation[rh]) (*destreg, 1);
            *destreg = destval;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xd2
****************************************************************************/
static void
x86emuOp_opcD2_byte_RM_CL(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg;
    uint destoffset;
    u8 destval;
    u8 amt;

    /*
     * Yet another weirdo special case instruction format.  Part of
     * the opcode held below in "RH".  Doubly nested case would
     * result, except that the decoded instruction
     */
    START_OF_INSTR();
    FETCH_DECODE_MODRM(mod, rh, rl);
#ifdef DEBUG
    if (DEBUG_DECODE()) {
        /* XXX DECODE_PRINTF may be changed to something more
           general, so that it is important to leave the strings
           in the same format, even though the result is that the
           above test is done twice. */
        switch (rh) {
        case 0:
            DECODE_PRINTF("ROL\t");
            break;
        case 1:
            DECODE_PRINTF("ROR\t");
            break;
        case 2:
            DECODE_PRINTF("RCL\t");
            break;
        case 3:
            DECODE_PRINTF("RCR\t");
            break;
        case 4:
            DECODE_PRINTF("SHL\t");
            break;
        case 5:
            DECODE_PRINTF("SHR\t");
            break;
        case 6:
            DECODE_PRINTF("SAL\t");
            break;
        case 7:
            DECODE_PRINTF("SAR\t");
            break;
        }
    }
#endif
    /* know operation, decode the mod byte to find the addressing
       mode. */
    amt = M.x86.R_CL;
    switch (mod) {
    case 0:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF(",CL\n");
        destval = fetch_data_byte(destoffset);
        TRACE_AND_STEP();
        destval = (*opcD0_byte_operation[rh]) (destval, amt);
        store_data_byte(destoffset, destval);
        break;
    case 1:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF(",CL\n");
        destval = fetch_data_byte(destoffset);
        TRACE_AND_STEP();
        destval = (*opcD0_byte_operation[rh]) (destval, amt);
        store_data_byte(destoffset, destval);
        break;
    case 2:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF(",CL\n");
        destval = fetch_data_byte(destoffset);
        TRACE_AND_STEP();
        destval = (*opcD0_byte_operation[rh]) (destval, amt);
        store_data_byte(destoffset, destval);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF(",CL\n");
        TRACE_AND_STEP();
        destval = (*opcD0_byte_operation[rh]) (*destreg, amt);
        *destreg = destval;
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xd3
****************************************************************************/
static void
x86emuOp_opcD3_word_RM_CL(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;
    u8 amt;

    /*
     * Yet another weirdo special case instruction format.  Part of
     * the opcode held below in "RH".  Doubly nested case would
     * result, except that the decoded instruction
     */
    START_OF_INSTR();
    FETCH_DECODE_MODRM(mod, rh, rl);
#ifdef DEBUG
    if (DEBUG_DECODE()) {
        /* XXX DECODE_PRINTF may be changed to something more
           general, so that it is important to leave the strings
           in the same format, even though the result is that the
           above test is done twice. */
        switch (rh) {
        case 0:
            DECODE_PRINTF("ROL\t");
            break;
        case 1:
            DECODE_PRINTF("ROR\t");
            break;
        case 2:
            DECODE_PRINTF("RCL\t");
            break;
        case 3:
            DECODE_PRINTF("RCR\t");
            break;
        case 4:
            DECODE_PRINTF("SHL\t");
            break;
        case 5:
            DECODE_PRINTF("SHR\t");
            break;
        case 6:
            DECODE_PRINTF("SAL\t");
            break;
        case 7:
            DECODE_PRINTF("SAR\t");
            break;
        }
    }
#endif
    /* know operation, decode the mod byte to find the addressing
       mode. */
    amt = M.x86.R_CL;
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",CL\n");
            destval = fetch_data_long(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_long_operation[rh]) (destval, amt);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",CL\n");
            destval = fetch_data_word(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_word_operation[rh]) (destval, amt);
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",CL\n");
            destval = fetch_data_long(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_long_operation[rh]) (destval, amt);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",CL\n");
            destval = fetch_data_word(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_word_operation[rh]) (destval, amt);
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;

            DECODE_PRINTF("DWORD PTR ");
            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",CL\n");
            destval = fetch_data_long(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_long_operation[rh]) (destval, amt);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;

            DECODE_PRINTF("WORD PTR ");
            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",CL\n");
            destval = fetch_data_word(destoffset);
            TRACE_AND_STEP();
            destval = (*opcD1_word_operation[rh]) (destval, amt);
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            *destreg = (*opcD1_long_operation[rh]) (*destreg, amt);
        }
        else {
            u16 *destreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            *destreg = (*opcD1_word_operation[rh]) (*destreg, amt);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xd4
****************************************************************************/
static void
x86emuOp_aam(u8 X86EMU_UNUSED(op1))
{
    u8 a;

    START_OF_INSTR();
    DECODE_PRINTF("AAM\n");
    a = fetch_byte_imm();       /* this is a stupid encoding. */
    if (a != 10) {
        /* fix: add base decoding
           aam_word(u8 val, int base a) */
        DECODE_PRINTF("ERROR DECODING AAM\n");
        TRACE_REGS();
        HALT_SYS();
    }
    TRACE_AND_STEP();
    /* note the type change here --- returning AL and AH in AX. */
    M.x86.R_AX = aam_word(M.x86.R_AL);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xd5
****************************************************************************/
static void
x86emuOp_aad(u8 X86EMU_UNUSED(op1))
{
    u8 a;

    START_OF_INSTR();
    DECODE_PRINTF("AAD\n");
    a = fetch_byte_imm();
    if (a != 10) {
        /* fix: add base decoding
           aad_word(u16 val, int base a) */
        DECODE_PRINTF("ERROR DECODING AAM\n");
        TRACE_REGS();
        HALT_SYS();
    }
    TRACE_AND_STEP();
    M.x86.R_AX = aad_word(M.x86.R_AX);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/* opcode 0xd6 ILLEGAL OPCODE */

/****************************************************************************
REMARKS:
Handles opcode 0xd7
****************************************************************************/
static void
x86emuOp_xlat(u8 X86EMU_UNUSED(op1))
{
    u16 addr;

    START_OF_INSTR();
    DECODE_PRINTF("XLAT\n");
    TRACE_AND_STEP();
    addr = (u16) (M.x86.R_BX + (u8) M.x86.R_AL);
    M.x86.R_AL = fetch_data_byte(addr);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/* instuctions  D8 .. DF are in i87_ops.c */

/****************************************************************************
REMARKS:
Handles opcode 0xe0
****************************************************************************/
static void
x86emuOp_loopne(u8 X86EMU_UNUSED(op1))
{
    s16 ip;

    START_OF_INSTR();
    DECODE_PRINTF("LOOPNE\t");
    ip = (s8) fetch_byte_imm();
    ip += (s16) M.x86.R_IP;
    DECODE_PRINTF2("%04x\n", ip);
    TRACE_AND_STEP();
    M.x86.R_CX -= 1;
    if (M.x86.R_CX != 0 && !ACCESS_FLAG(F_ZF))  /* CX != 0 and !ZF */
        M.x86.R_IP = ip;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xe1
****************************************************************************/
static void
x86emuOp_loope(u8 X86EMU_UNUSED(op1))
{
    s16 ip;

    START_OF_INSTR();
    DECODE_PRINTF("LOOPE\t");
    ip = (s8) fetch_byte_imm();
    ip += (s16) M.x86.R_IP;
    DECODE_PRINTF2("%04x\n", ip);
    TRACE_AND_STEP();
    M.x86.R_CX -= 1;
    if (M.x86.R_CX != 0 && ACCESS_FLAG(F_ZF))   /* CX != 0 and ZF */
        M.x86.R_IP = ip;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xe2
****************************************************************************/
static void
x86emuOp_loop(u8 X86EMU_UNUSED(op1))
{
    s16 ip;

    START_OF_INSTR();
    DECODE_PRINTF("LOOP\t");
    ip = (s8) fetch_byte_imm();
    ip += (s16) M.x86.R_IP;
    DECODE_PRINTF2("%04x\n", ip);
    TRACE_AND_STEP();
    M.x86.R_CX -= 1;
    if (M.x86.R_CX != 0)
        M.x86.R_IP = ip;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xe3
****************************************************************************/
static void
x86emuOp_jcxz(u8 X86EMU_UNUSED(op1))
{
    u16 target;
    s8 offset;

    /* jump to byte offset if overflow flag is set */
    START_OF_INSTR();
    DECODE_PRINTF("JCXZ\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    if (M.x86.R_CX == 0)
        M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xe4
****************************************************************************/
static void
x86emuOp_in_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 port;

    START_OF_INSTR();
    DECODE_PRINTF("IN\t");
    port = (u8) fetch_byte_imm();
    DECODE_PRINTF2("%x,AL\n", port);
    TRACE_AND_STEP();
    M.x86.R_AL = (*sys_inb) (port);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xe5
****************************************************************************/
static void
x86emuOp_in_word_AX_IMM(u8 X86EMU_UNUSED(op1))
{
    u8 port;

    START_OF_INSTR();
    DECODE_PRINTF("IN\t");
    port = (u8) fetch_byte_imm();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF2("EAX,%x\n", port);
    }
    else {
        DECODE_PRINTF2("AX,%x\n", port);
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EAX = (*sys_inl) (port);
    }
    else {
        M.x86.R_AX = (*sys_inw) (port);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xe6
****************************************************************************/
static void
x86emuOp_out_byte_IMM_AL(u8 X86EMU_UNUSED(op1))
{
    u8 port;

    START_OF_INSTR();
    DECODE_PRINTF("OUT\t");
    port = (u8) fetch_byte_imm();
    DECODE_PRINTF2("%x,AL\n", port);
    TRACE_AND_STEP();
    (*sys_outb) (port, M.x86.R_AL);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xe7
****************************************************************************/
static void
x86emuOp_out_word_IMM_AX(u8 X86EMU_UNUSED(op1))
{
    u8 port;

    START_OF_INSTR();
    DECODE_PRINTF("OUT\t");
    port = (u8) fetch_byte_imm();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF2("%x,EAX\n", port);
    }
    else {
        DECODE_PRINTF2("%x,AX\n", port);
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        (*sys_outl) (port, M.x86.R_EAX);
    }
    else {
        (*sys_outw) (port, M.x86.R_AX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xe8
****************************************************************************/
static void
x86emuOp_call_near_IMM(u8 X86EMU_UNUSED(op1))
{
    s16 ip16 = 0;
    s32 ip32 = 0;

    START_OF_INSTR();
    DECODE_PRINTF("CALL\t");
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        ip32 = (s32) fetch_long_imm();
        ip32 += (s16) M.x86.R_IP;       /* CHECK SIGN */
        DECODE_PRINTF2("%04x\n", (u16) ip32);
        CALL_TRACE(M.x86.saved_cs, M.x86.saved_ip, M.x86.R_CS, ip32, "");
    }
    else {
        ip16 = (s16) fetch_word_imm();
        ip16 += (s16) M.x86.R_IP;       /* CHECK SIGN */
        DECODE_PRINTF2("%04x\n", (u16) ip16);
        CALL_TRACE(M.x86.saved_cs, M.x86.saved_ip, M.x86.R_CS, ip16, "");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        push_long(M.x86.R_EIP);
        M.x86.R_EIP = ip32 & 0xffff;
    }
    else {
        push_word(M.x86.R_IP);
        M.x86.R_EIP = ip16;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xe9
****************************************************************************/
static void
x86emuOp_jump_near_IMM(u8 X86EMU_UNUSED(op1))
{
    u32 ip;

    START_OF_INSTR();
    DECODE_PRINTF("JMP\t");
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        ip = (u32) fetch_long_imm();
        ip += (u32) M.x86.R_EIP;
        DECODE_PRINTF2("%08x\n", (u32) ip);
        TRACE_AND_STEP();
        M.x86.R_EIP = (u32) ip;
    }
    else {
        ip = (s16) fetch_word_imm();
        ip += (s16) M.x86.R_IP;
        DECODE_PRINTF2("%04x\n", (u16) ip);
        TRACE_AND_STEP();
        M.x86.R_IP = (u16) ip;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xea
****************************************************************************/
static void
x86emuOp_jump_far_IMM(u8 X86EMU_UNUSED(op1))
{
    u16 cs;
    u32 ip;

    START_OF_INSTR();
    DECODE_PRINTF("JMP\tFAR ");
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        ip = fetch_long_imm();
    }
    else {
        ip = fetch_word_imm();
    }
    cs = fetch_word_imm();
    DECODE_PRINTF2("%04x:", cs);
    DECODE_PRINTF2("%04x\n", ip);
    TRACE_AND_STEP();
    M.x86.R_EIP = ip & 0xffff;
    M.x86.R_CS = cs;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xeb
****************************************************************************/
static void
x86emuOp_jump_byte_IMM(u8 X86EMU_UNUSED(op1))
{
    u16 target;
    s8 offset;

    START_OF_INSTR();
    DECODE_PRINTF("JMP\t");
    offset = (s8) fetch_byte_imm();
    target = (u16) (M.x86.R_IP + offset);
    DECODE_PRINTF2("%x\n", target);
    TRACE_AND_STEP();
    M.x86.R_IP = target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xec
****************************************************************************/
static void
x86emuOp_in_byte_AL_DX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("IN\tAL,DX\n");
    TRACE_AND_STEP();
    M.x86.R_AL = (*sys_inb) (M.x86.R_DX);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xed
****************************************************************************/
static void
x86emuOp_in_word_AX_DX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("IN\tEAX,DX\n");
    }
    else {
        DECODE_PRINTF("IN\tAX,DX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        M.x86.R_EAX = (*sys_inl) (M.x86.R_DX);
    }
    else {
        M.x86.R_AX = (*sys_inw) (M.x86.R_DX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xee
****************************************************************************/
static void
x86emuOp_out_byte_DX_AL(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("OUT\tDX,AL\n");
    TRACE_AND_STEP();
    (*sys_outb) (M.x86.R_DX, M.x86.R_AL);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xef
****************************************************************************/
static void
x86emuOp_out_word_DX_AX(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        DECODE_PRINTF("OUT\tDX,EAX\n");
    }
    else {
        DECODE_PRINTF("OUT\tDX,AX\n");
    }
    TRACE_AND_STEP();
    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
        (*sys_outl) (M.x86.R_DX, M.x86.R_EAX);
    }
    else {
        (*sys_outw) (M.x86.R_DX, M.x86.R_AX);
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xf0
****************************************************************************/
static void
x86emuOp_lock(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("LOCK:\n");
    TRACE_AND_STEP();
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/*opcode 0xf1 ILLEGAL OPERATION */

/****************************************************************************
REMARKS:
Handles opcode 0xf2
****************************************************************************/
static void
x86emuOp_repne(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("REPNE\n");
    TRACE_AND_STEP();
    M.x86.mode |= SYSMODE_PREFIX_REPNE;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xf3
****************************************************************************/
static void
x86emuOp_repe(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("REPE\n");
    TRACE_AND_STEP();
    M.x86.mode |= SYSMODE_PREFIX_REPE;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xf4
****************************************************************************/
static void
x86emuOp_halt(u8 X86EMU_UNUSED(op1))
{
    START_OF_INSTR();
    DECODE_PRINTF("HALT\n");
    TRACE_AND_STEP();
    HALT_SYS();
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xf5
****************************************************************************/
static void
x86emuOp_cmc(u8 X86EMU_UNUSED(op1))
{
    /* complement the carry flag. */
    START_OF_INSTR();
    DECODE_PRINTF("CMC\n");
    TRACE_AND_STEP();
    TOGGLE_FLAG(F_CF);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xf6
****************************************************************************/
static void
x86emuOp_opcF6_byte_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    u8 *destreg;
    uint destoffset;
    u8 destval, srcval;

    /* long, drawn out code follows.  Double switch for a total
       of 32 cases.  */
    START_OF_INSTR();
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:                    /* mod=00 */
        switch (rh) {
        case 0:                /* test byte imm */
            DECODE_PRINTF("TEST\tBYTE PTR ");
            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            srcval = fetch_byte_imm();
            DECODE_PRINTF2("%02x\n", srcval);
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            test_byte(destval, srcval);
            break;
        case 1:
            DECODE_PRINTF("ILLEGAL OP MOD=00 RH=01 OP=F6\n");
            HALT_SYS();
            break;
        case 2:
            DECODE_PRINTF("NOT\tBYTE PTR ");
            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            destval = not_byte(destval);
            store_data_byte(destoffset, destval);
            break;
        case 3:
            DECODE_PRINTF("NEG\tBYTE PTR ");
            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            destval = neg_byte(destval);
            store_data_byte(destoffset, destval);
            break;
        case 4:
            DECODE_PRINTF("MUL\tBYTE PTR ");
            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            mul_byte(destval);
            break;
        case 5:
            DECODE_PRINTF("IMUL\tBYTE PTR ");
            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            imul_byte(destval);
            break;
        case 6:
            DECODE_PRINTF("DIV\tBYTE PTR ");
            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            div_byte(destval);
            break;
        case 7:
            DECODE_PRINTF("IDIV\tBYTE PTR ");
            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            idiv_byte(destval);
            break;
        }
        break;                  /* end mod==00 */
    case 1:                    /* mod=01 */
        switch (rh) {
        case 0:                /* test byte imm */
            DECODE_PRINTF("TEST\tBYTE PTR ");
            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            srcval = fetch_byte_imm();
            DECODE_PRINTF2("%02x\n", srcval);
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            test_byte(destval, srcval);
            break;
        case 1:
            DECODE_PRINTF("ILLEGAL OP MOD=01 RH=01 OP=F6\n");
            HALT_SYS();
            break;
        case 2:
            DECODE_PRINTF("NOT\tBYTE PTR ");
            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            destval = not_byte(destval);
            store_data_byte(destoffset, destval);
            break;
        case 3:
            DECODE_PRINTF("NEG\tBYTE PTR ");
            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            destval = neg_byte(destval);
            store_data_byte(destoffset, destval);
            break;
        case 4:
            DECODE_PRINTF("MUL\tBYTE PTR ");
            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            mul_byte(destval);
            break;
        case 5:
            DECODE_PRINTF("IMUL\tBYTE PTR ");
            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            imul_byte(destval);
            break;
        case 6:
            DECODE_PRINTF("DIV\tBYTE PTR ");
            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            div_byte(destval);
            break;
        case 7:
            DECODE_PRINTF("IDIV\tBYTE PTR ");
            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            idiv_byte(destval);
            break;
        }
        break;                  /* end mod==01 */
    case 2:                    /* mod=10 */
        switch (rh) {
        case 0:                /* test byte imm */
            DECODE_PRINTF("TEST\tBYTE PTR ");
            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            srcval = fetch_byte_imm();
            DECODE_PRINTF2("%02x\n", srcval);
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            test_byte(destval, srcval);
            break;
        case 1:
            DECODE_PRINTF("ILLEGAL OP MOD=10 RH=01 OP=F6\n");
            HALT_SYS();
            break;
        case 2:
            DECODE_PRINTF("NOT\tBYTE PTR ");
            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            destval = not_byte(destval);
            store_data_byte(destoffset, destval);
            break;
        case 3:
            DECODE_PRINTF("NEG\tBYTE PTR ");
            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            destval = neg_byte(destval);
            store_data_byte(destoffset, destval);
            break;
        case 4:
            DECODE_PRINTF("MUL\tBYTE PTR ");
            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            mul_byte(destval);
            break;
        case 5:
            DECODE_PRINTF("IMUL\tBYTE PTR ");
            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            imul_byte(destval);
            break;
        case 6:
            DECODE_PRINTF("DIV\tBYTE PTR ");
            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            div_byte(destval);
            break;
        case 7:
            DECODE_PRINTF("IDIV\tBYTE PTR ");
            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF("\n");
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            idiv_byte(destval);
            break;
        }
        break;                  /* end mod==10 */
    case 3:                    /* mod=11 */
        switch (rh) {
        case 0:                /* test byte imm */
            DECODE_PRINTF("TEST\t");
            destreg = DECODE_RM_BYTE_REGISTER(rl);
            DECODE_PRINTF(",");
            srcval = fetch_byte_imm();
            DECODE_PRINTF2("%02x\n", srcval);
            TRACE_AND_STEP();
            test_byte(*destreg, srcval);
            break;
        case 1:
            DECODE_PRINTF("ILLEGAL OP MOD=00 RH=01 OP=F6\n");
            HALT_SYS();
            break;
        case 2:
            DECODE_PRINTF("NOT\t");
            destreg = DECODE_RM_BYTE_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = not_byte(*destreg);
            break;
        case 3:
            DECODE_PRINTF("NEG\t");
            destreg = DECODE_RM_BYTE_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = neg_byte(*destreg);
            break;
        case 4:
            DECODE_PRINTF("MUL\t");
            destreg = DECODE_RM_BYTE_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            mul_byte(*destreg); /*!!!  */
            break;
        case 5:
            DECODE_PRINTF("IMUL\t");
            destreg = DECODE_RM_BYTE_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            imul_byte(*destreg);
            break;
        case 6:
            DECODE_PRINTF("DIV\t");
            destreg = DECODE_RM_BYTE_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            div_byte(*destreg);
            break;
        case 7:
            DECODE_PRINTF("IDIV\t");
            destreg = DECODE_RM_BYTE_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            idiv_byte(*destreg);
            break;
        }
        break;                  /* end mod==11 */
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xf7
****************************************************************************/
static void
x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rl, rh;
    uint destoffset;

    /* long, drawn out code follows.  Double switch for a total
       of 32 cases.  */
    START_OF_INSTR();
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:                    /* mod=00 */
        switch (rh) {
        case 0:                /* test word imm */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval, srcval;

                DECODE_PRINTF("TEST\tDWORD PTR ");
                destoffset = decode_rm00_address(rl);
                DECODE_PRINTF(",");
                srcval = fetch_long_imm();
                DECODE_PRINTF2("%x\n", srcval);
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                test_long(destval, srcval);
            }
            else {
                u16 destval, srcval;

                DECODE_PRINTF("TEST\tWORD PTR ");
                destoffset = decode_rm00_address(rl);
                DECODE_PRINTF(",");
                srcval = fetch_word_imm();
                DECODE_PRINTF2("%x\n", srcval);
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                test_word(destval, srcval);
            }
            break;
        case 1:
            DECODE_PRINTF("ILLEGAL OP MOD=00 RH=01 OP=F7\n");
            HALT_SYS();
            break;
        case 2:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("NOT\tDWORD PTR ");
                destoffset = decode_rm00_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                destval = not_long(destval);
                store_data_long(destoffset, destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("NOT\tWORD PTR ");
                destoffset = decode_rm00_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                destval = not_word(destval);
                store_data_word(destoffset, destval);
            }
            break;
        case 3:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("NEG\tDWORD PTR ");
                destoffset = decode_rm00_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                destval = neg_long(destval);
                store_data_long(destoffset, destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("NEG\tWORD PTR ");
                destoffset = decode_rm00_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                destval = neg_word(destval);
                store_data_word(destoffset, destval);
            }
            break;
        case 4:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("MUL\tDWORD PTR ");
                destoffset = decode_rm00_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                mul_long(destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("MUL\tWORD PTR ");
                destoffset = decode_rm00_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                mul_word(destval);
            }
            break;
        case 5:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("IMUL\tDWORD PTR ");
                destoffset = decode_rm00_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                imul_long(destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("IMUL\tWORD PTR ");
                destoffset = decode_rm00_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                imul_word(destval);
            }
            break;
        case 6:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("DIV\tDWORD PTR ");
                destoffset = decode_rm00_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                div_long(destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("DIV\tWORD PTR ");
                destoffset = decode_rm00_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                div_word(destval);
            }
            break;
        case 7:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("IDIV\tDWORD PTR ");
                destoffset = decode_rm00_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                idiv_long(destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("IDIV\tWORD PTR ");
                destoffset = decode_rm00_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                idiv_word(destval);
            }
            break;
        }
        break;                  /* end mod==00 */
    case 1:                    /* mod=01 */
        switch (rh) {
        case 0:                /* test word imm */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval, srcval;

                DECODE_PRINTF("TEST\tDWORD PTR ");
                destoffset = decode_rm01_address(rl);
                DECODE_PRINTF(",");
                srcval = fetch_long_imm();
                DECODE_PRINTF2("%x\n", srcval);
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                test_long(destval, srcval);
            }
            else {
                u16 destval, srcval;

                DECODE_PRINTF("TEST\tWORD PTR ");
                destoffset = decode_rm01_address(rl);
                DECODE_PRINTF(",");
                srcval = fetch_word_imm();
                DECODE_PRINTF2("%x\n", srcval);
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                test_word(destval, srcval);
            }
            break;
        case 1:
            DECODE_PRINTF("ILLEGAL OP MOD=01 RH=01 OP=F6\n");
            HALT_SYS();
            break;
        case 2:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("NOT\tDWORD PTR ");
                destoffset = decode_rm01_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                destval = not_long(destval);
                store_data_long(destoffset, destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("NOT\tWORD PTR ");
                destoffset = decode_rm01_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                destval = not_word(destval);
                store_data_word(destoffset, destval);
            }
            break;
        case 3:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("NEG\tDWORD PTR ");
                destoffset = decode_rm01_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                destval = neg_long(destval);
                store_data_long(destoffset, destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("NEG\tWORD PTR ");
                destoffset = decode_rm01_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                destval = neg_word(destval);
                store_data_word(destoffset, destval);
            }
            break;
        case 4:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("MUL\tDWORD PTR ");
                destoffset = decode_rm01_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                mul_long(destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("MUL\tWORD PTR ");
                destoffset = decode_rm01_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                mul_word(destval);
            }
            break;
        case 5:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("IMUL\tDWORD PTR ");
                destoffset = decode_rm01_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                imul_long(destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("IMUL\tWORD PTR ");
                destoffset = decode_rm01_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                imul_word(destval);
            }
            break;
        case 6:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("DIV\tDWORD PTR ");
                destoffset = decode_rm01_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                div_long(destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("DIV\tWORD PTR ");
                destoffset = decode_rm01_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                div_word(destval);
            }
            break;
        case 7:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("IDIV\tDWORD PTR ");
                destoffset = decode_rm01_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                idiv_long(destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("IDIV\tWORD PTR ");
                destoffset = decode_rm01_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                idiv_word(destval);
            }
            break;
        }
        break;                  /* end mod==01 */
    case 2:                    /* mod=10 */
        switch (rh) {
        case 0:                /* test word imm */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval, srcval;

                DECODE_PRINTF("TEST\tDWORD PTR ");
                destoffset = decode_rm10_address(rl);
                DECODE_PRINTF(",");
                srcval = fetch_long_imm();
                DECODE_PRINTF2("%x\n", srcval);
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                test_long(destval, srcval);
            }
            else {
                u16 destval, srcval;

                DECODE_PRINTF("TEST\tWORD PTR ");
                destoffset = decode_rm10_address(rl);
                DECODE_PRINTF(",");
                srcval = fetch_word_imm();
                DECODE_PRINTF2("%x\n", srcval);
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                test_word(destval, srcval);
            }
            break;
        case 1:
            DECODE_PRINTF("ILLEGAL OP MOD=10 RH=01 OP=F6\n");
            HALT_SYS();
            break;
        case 2:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("NOT\tDWORD PTR ");
                destoffset = decode_rm10_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                destval = not_long(destval);
                store_data_long(destoffset, destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("NOT\tWORD PTR ");
                destoffset = decode_rm10_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                destval = not_word(destval);
                store_data_word(destoffset, destval);
            }
            break;
        case 3:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("NEG\tDWORD PTR ");
                destoffset = decode_rm10_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                destval = neg_long(destval);
                store_data_long(destoffset, destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("NEG\tWORD PTR ");
                destoffset = decode_rm10_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                destval = neg_word(destval);
                store_data_word(destoffset, destval);
            }
            break;
        case 4:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("MUL\tDWORD PTR ");
                destoffset = decode_rm10_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                mul_long(destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("MUL\tWORD PTR ");
                destoffset = decode_rm10_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                mul_word(destval);
            }
            break;
        case 5:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("IMUL\tDWORD PTR ");
                destoffset = decode_rm10_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                imul_long(destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("IMUL\tWORD PTR ");
                destoffset = decode_rm10_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                imul_word(destval);
            }
            break;
        case 6:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("DIV\tDWORD PTR ");
                destoffset = decode_rm10_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                div_long(destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("DIV\tWORD PTR ");
                destoffset = decode_rm10_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                div_word(destval);
            }
            break;
        case 7:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval;

                DECODE_PRINTF("IDIV\tDWORD PTR ");
                destoffset = decode_rm10_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                idiv_long(destval);
            }
            else {
                u16 destval;

                DECODE_PRINTF("IDIV\tWORD PTR ");
                destoffset = decode_rm10_address(rl);
                DECODE_PRINTF("\n");
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                idiv_word(destval);
            }
            break;
        }
        break;                  /* end mod==10 */
    case 3:                    /* mod=11 */
        switch (rh) {
        case 0:                /* test word imm */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 *destreg;
                u32 srcval;

                DECODE_PRINTF("TEST\t");
                destreg = DECODE_RM_LONG_REGISTER(rl);
                DECODE_PRINTF(",");
                srcval = fetch_long_imm();
                DECODE_PRINTF2("%x\n", srcval);
                TRACE_AND_STEP();
                test_long(*destreg, srcval);
            }
            else {
                u16 *destreg;
                u16 srcval;

                DECODE_PRINTF("TEST\t");
                destreg = DECODE_RM_WORD_REGISTER(rl);
                DECODE_PRINTF(",");
                srcval = fetch_word_imm();
                DECODE_PRINTF2("%x\n", srcval);
                TRACE_AND_STEP();
                test_word(*destreg, srcval);
            }
            break;
        case 1:
            DECODE_PRINTF("ILLEGAL OP MOD=00 RH=01 OP=F6\n");
            HALT_SYS();
            break;
        case 2:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 *destreg;

                DECODE_PRINTF("NOT\t");
                destreg = DECODE_RM_LONG_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                *destreg = not_long(*destreg);
            }
            else {
                u16 *destreg;

                DECODE_PRINTF("NOT\t");
                destreg = DECODE_RM_WORD_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                *destreg = not_word(*destreg);
            }
            break;
        case 3:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 *destreg;

                DECODE_PRINTF("NEG\t");
                destreg = DECODE_RM_LONG_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                *destreg = neg_long(*destreg);
            }
            else {
                u16 *destreg;

                DECODE_PRINTF("NEG\t");
                destreg = DECODE_RM_WORD_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                *destreg = neg_word(*destreg);
            }
            break;
        case 4:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 *destreg;

                DECODE_PRINTF("MUL\t");
                destreg = DECODE_RM_LONG_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                mul_long(*destreg);     /*!!!  */
            }
            else {
                u16 *destreg;

                DECODE_PRINTF("MUL\t");
                destreg = DECODE_RM_WORD_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                mul_word(*destreg);     /*!!!  */
            }
            break;
        case 5:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 *destreg;

                DECODE_PRINTF("IMUL\t");
                destreg = DECODE_RM_LONG_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                imul_long(*destreg);
            }
            else {
                u16 *destreg;

                DECODE_PRINTF("IMUL\t");
                destreg = DECODE_RM_WORD_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                imul_word(*destreg);
            }
            break;
        case 6:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 *destreg;

                DECODE_PRINTF("DIV\t");
                destreg = DECODE_RM_LONG_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                div_long(*destreg);
            }
            else {
                u16 *destreg;

                DECODE_PRINTF("DIV\t");
                destreg = DECODE_RM_WORD_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                div_word(*destreg);
            }
            break;
        case 7:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 *destreg;

                DECODE_PRINTF("IDIV\t");
                destreg = DECODE_RM_LONG_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                idiv_long(*destreg);
            }
            else {
                u16 *destreg;

                DECODE_PRINTF("IDIV\t");
                destreg = DECODE_RM_WORD_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                idiv_word(*destreg);
            }
            break;
        }
        break;                  /* end mod==11 */
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xf8
****************************************************************************/
static void
x86emuOp_clc(u8 X86EMU_UNUSED(op1))
{
    /* clear the carry flag. */
    START_OF_INSTR();
    DECODE_PRINTF("CLC\n");
    TRACE_AND_STEP();
    CLEAR_FLAG(F_CF);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xf9
****************************************************************************/
static void
x86emuOp_stc(u8 X86EMU_UNUSED(op1))
{
    /* set the carry flag. */
    START_OF_INSTR();
    DECODE_PRINTF("STC\n");
    TRACE_AND_STEP();
    SET_FLAG(F_CF);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xfa
****************************************************************************/
static void
x86emuOp_cli(u8 X86EMU_UNUSED(op1))
{
    /* clear interrupts. */
    START_OF_INSTR();
    DECODE_PRINTF("CLI\n");
    TRACE_AND_STEP();
    CLEAR_FLAG(F_IF);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xfb
****************************************************************************/
static void
x86emuOp_sti(u8 X86EMU_UNUSED(op1))
{
    /* enable  interrupts. */
    START_OF_INSTR();
    DECODE_PRINTF("STI\n");
    TRACE_AND_STEP();
    SET_FLAG(F_IF);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xfc
****************************************************************************/
static void
x86emuOp_cld(u8 X86EMU_UNUSED(op1))
{
    /* clear interrupts. */
    START_OF_INSTR();
    DECODE_PRINTF("CLD\n");
    TRACE_AND_STEP();
    CLEAR_FLAG(F_DF);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xfd
****************************************************************************/
static void
x86emuOp_std(u8 X86EMU_UNUSED(op1))
{
    /* clear interrupts. */
    START_OF_INSTR();
    DECODE_PRINTF("STD\n");
    TRACE_AND_STEP();
    SET_FLAG(F_DF);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xfe
****************************************************************************/
static void
x86emuOp_opcFE_byte_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rh, rl;
    u8 destval;
    uint destoffset;
    u8 *destreg;

    /* Yet another special case instruction. */
    START_OF_INSTR();
    FETCH_DECODE_MODRM(mod, rh, rl);
#ifdef DEBUG
    if (DEBUG_DECODE()) {
        /* XXX DECODE_PRINTF may be changed to something more
           general, so that it is important to leave the strings
           in the same format, even though the result is that the
           above test is done twice. */

        switch (rh) {
        case 0:
            DECODE_PRINTF("INC\t");
            break;
        case 1:
            DECODE_PRINTF("DEC\t");
            break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
            DECODE_PRINTF2("ILLEGAL OP MAJOR OP 0xFE MINOR OP %x \n", mod);
            HALT_SYS();
            break;
        }
    }
#endif
    switch (mod) {
    case 0:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF("\n");
        switch (rh) {
        case 0:                /* inc word ptr ... */
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            destval = inc_byte(destval);
            store_data_byte(destoffset, destval);
            break;
        case 1:                /* dec word ptr ... */
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            destval = dec_byte(destval);
            store_data_byte(destoffset, destval);
            break;
        }
        break;
    case 1:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF("\n");
        switch (rh) {
        case 0:
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            destval = inc_byte(destval);
            store_data_byte(destoffset, destval);
            break;
        case 1:
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            destval = dec_byte(destval);
            store_data_byte(destoffset, destval);
            break;
        }
        break;
    case 2:
        DECODE_PRINTF("BYTE PTR ");
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF("\n");
        switch (rh) {
        case 0:
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            destval = inc_byte(destval);
            store_data_byte(destoffset, destval);
            break;
        case 1:
            destval = fetch_data_byte(destoffset);
            TRACE_AND_STEP();
            destval = dec_byte(destval);
            store_data_byte(destoffset, destval);
            break;
        }
        break;
    case 3:
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        DECODE_PRINTF("\n");
        switch (rh) {
        case 0:
            TRACE_AND_STEP();
            *destreg = inc_byte(*destreg);
            break;
        case 1:
            TRACE_AND_STEP();
            *destreg = dec_byte(*destreg);
            break;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0xff
****************************************************************************/
static void
x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
{
    int mod, rh, rl;
    uint destoffset = 0;
    u16 *destreg;
    u16 destval, destval2;

    /* Yet another special case instruction. */
    START_OF_INSTR();
    FETCH_DECODE_MODRM(mod, rh, rl);
#ifdef DEBUG
    if (DEBUG_DECODE()) {
        /* XXX DECODE_PRINTF may be changed to something more
           general, so that it is important to leave the strings
           in the same format, even though the result is that the
           above test is done twice. */

        switch (rh) {
        case 0:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                DECODE_PRINTF("INC\tDWORD PTR ");
            }
            else {
                DECODE_PRINTF("INC\tWORD PTR ");
            }
            break;
        case 1:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                DECODE_PRINTF("DEC\tDWORD PTR ");
            }
            else {
                DECODE_PRINTF("DEC\tWORD PTR ");
            }
            break;
        case 2:
            DECODE_PRINTF("CALL\t");
            break;
        case 3:
            DECODE_PRINTF("CALL\tFAR ");
            break;
        case 4:
            DECODE_PRINTF("JMP\t");
            break;
        case 5:
            DECODE_PRINTF("JMP\tFAR ");
            break;
        case 6:
            DECODE_PRINTF("PUSH\t");
            break;
        case 7:
            DECODE_PRINTF("ILLEGAL DECODING OF OPCODE FF\t");
            HALT_SYS();
            break;
        }
    }
#endif
    switch (mod) {
    case 0:
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF("\n");
        switch (rh) {
        case 0:                /* inc word ptr ... */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval32;

                destval32 = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                destval32 = inc_long(destval32);
                store_data_long(destoffset, destval32);
            }
            else {
                u16 destval16;

                destval16 = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                destval16 = inc_word(destval16);
                store_data_word(destoffset, destval16);
            }
            break;
        case 1:                /* dec word ptr ... */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval32;

                destval32 = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                destval32 = dec_long(destval32);
                store_data_long(destoffset, destval32);
            }
            else {
                u16 destval16;

                destval16 = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                destval16 = dec_word(destval16);
                store_data_word(destoffset, destval16);
            }
            break;
        case 2:                /* call word ptr ... */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                push_long(M.x86.R_EIP);
                M.x86.R_EIP = destval;
            } else {
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                push_word(M.x86.R_IP);
                M.x86.R_IP = destval;
            }
            break;
        case 3:                /* call far ptr ... */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                destval = fetch_data_long(destoffset);
                destval2 = fetch_data_word(destoffset + 4);
                TRACE_AND_STEP();
                push_long(M.x86.R_CS);
                M.x86.R_CS = destval2;
                push_long(M.x86.R_EIP);
                M.x86.R_EIP = destval;
            } else {
                destval = fetch_data_word(destoffset);
                destval2 = fetch_data_word(destoffset + 2);
                TRACE_AND_STEP();
                push_word(M.x86.R_CS);
                M.x86.R_CS = destval2;
                push_word(M.x86.R_IP);
                M.x86.R_IP = destval;
            }
            break;
        case 4:                /* jmp word ptr ... */
            destval = fetch_data_word(destoffset);
            TRACE_AND_STEP();
            M.x86.R_IP = destval;
            break;
        case 5:                /* jmp far ptr ... */
            destval = fetch_data_word(destoffset);
            destval2 = fetch_data_word(destoffset + 2);
            TRACE_AND_STEP();
            M.x86.R_IP = destval;
            M.x86.R_CS = destval2;
            break;
        case 6:                /*  push word ptr ... */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval32;

                destval32 = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                push_long(destval32);
            }
            else {
                u16 destval16;

                destval16 = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                push_word(destval16);
            }
            break;
        }
        break;
    case 1:
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF("\n");
        switch (rh) {
        case 0:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval32;

                destval32 = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                destval32 = inc_long(destval32);
                store_data_long(destoffset, destval32);
            }
            else {
                u16 destval16;

                destval16 = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                destval16 = inc_word(destval16);
                store_data_word(destoffset, destval16);
            }
            break;
        case 1:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval32;

                destval32 = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                destval32 = dec_long(destval32);
                store_data_long(destoffset, destval32);
            }
            else {
                u16 destval16;

                destval16 = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                destval16 = dec_word(destval16);
                store_data_word(destoffset, destval16);
            }
            break;
        case 2:                /* call word ptr ... */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                push_long(M.x86.R_EIP);
                M.x86.R_EIP = destval;
            } else {
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                push_word(M.x86.R_IP);
                M.x86.R_IP = destval;
            }
            break;
        case 3:                /* call far ptr ... */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                destval = fetch_data_long(destoffset);
                destval2 = fetch_data_word(destoffset + 4);
                TRACE_AND_STEP();
                push_long(M.x86.R_CS);
                M.x86.R_CS = destval2;
                push_long(M.x86.R_EIP);
                M.x86.R_EIP = destval;
            } else {
                destval = fetch_data_word(destoffset);
                destval2 = fetch_data_word(destoffset + 2);
                TRACE_AND_STEP();
                push_word(M.x86.R_CS);
                M.x86.R_CS = destval2;
                push_word(M.x86.R_IP);
                M.x86.R_IP = destval;
            }
            break;
        case 4:                /* jmp word ptr ... */
            destval = fetch_data_word(destoffset);
            TRACE_AND_STEP();
            M.x86.R_IP = destval;
            break;
        case 5:                /* jmp far ptr ... */
            destval = fetch_data_word(destoffset);
            destval2 = fetch_data_word(destoffset + 2);
            TRACE_AND_STEP();
            M.x86.R_IP = destval;
            M.x86.R_CS = destval2;
            break;
        case 6:                /*  push word ptr ... */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval32;

                destval32 = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                push_long(destval32);
            }
            else {
                u16 destval16;

                destval16 = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                push_word(destval16);
            }
            break;
        }
        break;
    case 2:
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF("\n");
        switch (rh) {
        case 0:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval32;

                destval32 = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                destval32 = inc_long(destval32);
                store_data_long(destoffset, destval32);
            }
            else {
                u16 destval16;

                destval16 = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                destval16 = inc_word(destval16);
                store_data_word(destoffset, destval16);
            }
            break;
        case 1:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval32;

                destval32 = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                destval32 = dec_long(destval32);
                store_data_long(destoffset, destval32);
            }
            else {
                u16 destval16;

                destval16 = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                destval16 = dec_word(destval16);
                store_data_word(destoffset, destval16);
            }
            break;
        case 2:                /* call word ptr ... */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                destval = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                push_long(M.x86.R_EIP);
                M.x86.R_EIP = destval;
            } else {
                destval = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                push_word(M.x86.R_IP);
                M.x86.R_IP = destval;
            }
            break;
        case 3:                /* call far ptr ... */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                destval = fetch_data_long(destoffset);
                destval2 = fetch_data_word(destoffset + 4);
                TRACE_AND_STEP();
                push_long(M.x86.R_CS);
                M.x86.R_CS = destval2;
                push_long(M.x86.R_EIP);
                M.x86.R_EIP = destval;
            } else {
                destval = fetch_data_word(destoffset);
                destval2 = fetch_data_word(destoffset + 2);
                TRACE_AND_STEP();
                push_word(M.x86.R_CS);
                M.x86.R_CS = destval2;
                push_word(M.x86.R_IP);
                M.x86.R_IP = destval;
            }
            break;
        case 4:                /* jmp word ptr ... */
            destval = fetch_data_word(destoffset);
            TRACE_AND_STEP();
            M.x86.R_IP = destval;
            break;
        case 5:                /* jmp far ptr ... */
            destval = fetch_data_word(destoffset);
            destval2 = fetch_data_word(destoffset + 2);
            TRACE_AND_STEP();
            M.x86.R_IP = destval;
            M.x86.R_CS = destval2;
            break;
        case 6:                /*  push word ptr ... */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 destval32;

                destval32 = fetch_data_long(destoffset);
                TRACE_AND_STEP();
                push_long(destval32);
            }
            else {
                u16 destval16;

                destval16 = fetch_data_word(destoffset);
                TRACE_AND_STEP();
                push_word(destval16);
            }
            break;
        }
        break;
    case 3:
        switch (rh) {
        case 0:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 *destreg32;

                destreg32 = DECODE_RM_LONG_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                *destreg32 = inc_long(*destreg32);
            }
            else {
                u16 *destreg16;

                destreg16 = DECODE_RM_WORD_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                *destreg16 = inc_word(*destreg16);
            }
            break;
        case 1:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 *destreg32;

                destreg32 = DECODE_RM_LONG_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                *destreg32 = dec_long(*destreg32);
            }
            else {
                u16 *destreg16;

                destreg16 = DECODE_RM_WORD_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                *destreg16 = dec_word(*destreg16);
            }
            break;
        case 2:                /* call word ptr ... */
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                destreg = (u16 *)DECODE_RM_LONG_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                push_long(M.x86.R_EIP);
                M.x86.R_EIP = *destreg;
            } else {
                destreg = DECODE_RM_WORD_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                push_word(M.x86.R_IP);
                M.x86.R_IP = *destreg;
            }
            break;
        case 3:                /* jmp far ptr ... */
            DECODE_PRINTF("OPERATION UNDEFINED 0XFF \n");
            TRACE_AND_STEP();
            HALT_SYS();
            break;

        case 4:                /* jmp  ... */
            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            M.x86.R_IP = (u16) (*destreg);
            break;
        case 5:                /* jmp far ptr ... */
            DECODE_PRINTF("OPERATION UNDEFINED 0XFF \n");
            TRACE_AND_STEP();
            HALT_SYS();
            break;
        case 6:
            if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                u32 *destreg32;

                destreg32 = DECODE_RM_LONG_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                push_long(*destreg32);
            }
            else {
                u16 *destreg16;

                destreg16 = DECODE_RM_WORD_REGISTER(rl);
                DECODE_PRINTF("\n");
                TRACE_AND_STEP();
                push_word(*destreg16);
            }
            break;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/***************************************************************************
 * Single byte operation code table:
 **************************************************************************/
void (*x86emu_optab[256]) (u8) = {
/*  0x00 */ x86emuOp_add_byte_RM_R,
/*  0x01 */ x86emuOp_add_word_RM_R,
/*  0x02 */ x86emuOp_add_byte_R_RM,
/*  0x03 */ x86emuOp_add_word_R_RM,
/*  0x04 */ x86emuOp_add_byte_AL_IMM,
/*  0x05 */ x86emuOp_add_word_AX_IMM,
/*  0x06 */ x86emuOp_push_ES,
/*  0x07 */ x86emuOp_pop_ES,
/*  0x08 */ x86emuOp_or_byte_RM_R,
/*  0x09 */ x86emuOp_or_word_RM_R,
/*  0x0a */ x86emuOp_or_byte_R_RM,
/*  0x0b */ x86emuOp_or_word_R_RM,
/*  0x0c */ x86emuOp_or_byte_AL_IMM,
/*  0x0d */ x86emuOp_or_word_AX_IMM,
/*  0x0e */ x86emuOp_push_CS,
/*  0x0f */ x86emuOp_two_byte,
/*  0x10 */ x86emuOp_adc_byte_RM_R,
/*  0x11 */ x86emuOp_adc_word_RM_R,
/*  0x12 */ x86emuOp_adc_byte_R_RM,
/*  0x13 */ x86emuOp_adc_word_R_RM,
/*  0x14 */ x86emuOp_adc_byte_AL_IMM,
/*  0x15 */ x86emuOp_adc_word_AX_IMM,
/*  0x16 */ x86emuOp_push_SS,
/*  0x17 */ x86emuOp_pop_SS,
/*  0x18 */ x86emuOp_sbb_byte_RM_R,
/*  0x19 */ x86emuOp_sbb_word_RM_R,
/*  0x1a */ x86emuOp_sbb_byte_R_RM,
/*  0x1b */ x86emuOp_sbb_word_R_RM,
/*  0x1c */ x86emuOp_sbb_byte_AL_IMM,
/*  0x1d */ x86emuOp_sbb_word_AX_IMM,
/*  0x1e */ x86emuOp_push_DS,
/*  0x1f */ x86emuOp_pop_DS,
/*  0x20 */ x86emuOp_and_byte_RM_R,
/*  0x21 */ x86emuOp_and_word_RM_R,
/*  0x22 */ x86emuOp_and_byte_R_RM,
/*  0x23 */ x86emuOp_and_word_R_RM,
/*  0x24 */ x86emuOp_and_byte_AL_IMM,
/*  0x25 */ x86emuOp_and_word_AX_IMM,
/*  0x26 */ x86emuOp_segovr_ES,
/*  0x27 */ x86emuOp_daa,
/*  0x28 */ x86emuOp_sub_byte_RM_R,
/*  0x29 */ x86emuOp_sub_word_RM_R,
/*  0x2a */ x86emuOp_sub_byte_R_RM,
/*  0x2b */ x86emuOp_sub_word_R_RM,
/*  0x2c */ x86emuOp_sub_byte_AL_IMM,
/*  0x2d */ x86emuOp_sub_word_AX_IMM,
/*  0x2e */ x86emuOp_segovr_CS,
/*  0x2f */ x86emuOp_das,
/*  0x30 */ x86emuOp_xor_byte_RM_R,
/*  0x31 */ x86emuOp_xor_word_RM_R,
/*  0x32 */ x86emuOp_xor_byte_R_RM,
/*  0x33 */ x86emuOp_xor_word_R_RM,
/*  0x34 */ x86emuOp_xor_byte_AL_IMM,
/*  0x35 */ x86emuOp_xor_word_AX_IMM,
/*  0x36 */ x86emuOp_segovr_SS,
/*  0x37 */ x86emuOp_aaa,
/*  0x38 */ x86emuOp_cmp_byte_RM_R,
/*  0x39 */ x86emuOp_cmp_word_RM_R,
/*  0x3a */ x86emuOp_cmp_byte_R_RM,
/*  0x3b */ x86emuOp_cmp_word_R_RM,
/*  0x3c */ x86emuOp_cmp_byte_AL_IMM,
/*  0x3d */ x86emuOp_cmp_word_AX_IMM,
/*  0x3e */ x86emuOp_segovr_DS,
/*  0x3f */ x86emuOp_aas,
/*  0x40 */ x86emuOp_inc_AX,
/*  0x41 */ x86emuOp_inc_CX,
/*  0x42 */ x86emuOp_inc_DX,
/*  0x43 */ x86emuOp_inc_BX,
/*  0x44 */ x86emuOp_inc_SP,
/*  0x45 */ x86emuOp_inc_BP,
/*  0x46 */ x86emuOp_inc_SI,
/*  0x47 */ x86emuOp_inc_DI,
/*  0x48 */ x86emuOp_dec_AX,
/*  0x49 */ x86emuOp_dec_CX,
/*  0x4a */ x86emuOp_dec_DX,
/*  0x4b */ x86emuOp_dec_BX,
/*  0x4c */ x86emuOp_dec_SP,
/*  0x4d */ x86emuOp_dec_BP,
/*  0x4e */ x86emuOp_dec_SI,
/*  0x4f */ x86emuOp_dec_DI,
/*  0x50 */ x86emuOp_push_AX,
/*  0x51 */ x86emuOp_push_CX,
/*  0x52 */ x86emuOp_push_DX,
/*  0x53 */ x86emuOp_push_BX,
/*  0x54 */ x86emuOp_push_SP,
/*  0x55 */ x86emuOp_push_BP,
/*  0x56 */ x86emuOp_push_SI,
/*  0x57 */ x86emuOp_push_DI,
/*  0x58 */ x86emuOp_pop_AX,
/*  0x59 */ x86emuOp_pop_CX,
/*  0x5a */ x86emuOp_pop_DX,
/*  0x5b */ x86emuOp_pop_BX,
/*  0x5c */ x86emuOp_pop_SP,
/*  0x5d */ x86emuOp_pop_BP,
/*  0x5e */ x86emuOp_pop_SI,
/*  0x5f */ x86emuOp_pop_DI,
/*  0x60 */ x86emuOp_push_all,
/*  0x61 */ x86emuOp_pop_all,
                                                /*  0x62 */ x86emuOp_illegal_op,
                                                /* bound */
                                                /*  0x63 */ x86emuOp_illegal_op,
                                                /* arpl */
/*  0x64 */ x86emuOp_segovr_FS,
/*  0x65 */ x86emuOp_segovr_GS,
/*  0x66 */ x86emuOp_prefix_data,
/*  0x67 */ x86emuOp_prefix_addr,
/*  0x68 */ x86emuOp_push_word_IMM,
/*  0x69 */ x86emuOp_imul_word_IMM,
/*  0x6a */ x86emuOp_push_byte_IMM,
/*  0x6b */ x86emuOp_imul_byte_IMM,
/*  0x6c */ x86emuOp_ins_byte,
/*  0x6d */ x86emuOp_ins_word,
/*  0x6e */ x86emuOp_outs_byte,
/*  0x6f */ x86emuOp_outs_word,
/*  0x70 */ x86emuOp_jump_near_O,
/*  0x71 */ x86emuOp_jump_near_NO,
/*  0x72 */ x86emuOp_jump_near_B,
/*  0x73 */ x86emuOp_jump_near_NB,
/*  0x74 */ x86emuOp_jump_near_Z,
/*  0x75 */ x86emuOp_jump_near_NZ,
/*  0x76 */ x86emuOp_jump_near_BE,
/*  0x77 */ x86emuOp_jump_near_NBE,
/*  0x78 */ x86emuOp_jump_near_S,
/*  0x79 */ x86emuOp_jump_near_NS,
/*  0x7a */ x86emuOp_jump_near_P,
/*  0x7b */ x86emuOp_jump_near_NP,
/*  0x7c */ x86emuOp_jump_near_L,
/*  0x7d */ x86emuOp_jump_near_NL,
/*  0x7e */ x86emuOp_jump_near_LE,
/*  0x7f */ x86emuOp_jump_near_NLE,
/*  0x80 */ x86emuOp_opc80_byte_RM_IMM,
/*  0x81 */ x86emuOp_opc81_word_RM_IMM,
/*  0x82 */ x86emuOp_opc82_byte_RM_IMM,
/*  0x83 */ x86emuOp_opc83_word_RM_IMM,
/*  0x84 */ x86emuOp_test_byte_RM_R,
/*  0x85 */ x86emuOp_test_word_RM_R,
/*  0x86 */ x86emuOp_xchg_byte_RM_R,
/*  0x87 */ x86emuOp_xchg_word_RM_R,
/*  0x88 */ x86emuOp_mov_byte_RM_R,
/*  0x89 */ x86emuOp_mov_word_RM_R,
/*  0x8a */ x86emuOp_mov_byte_R_RM,
/*  0x8b */ x86emuOp_mov_word_R_RM,
/*  0x8c */ x86emuOp_mov_word_RM_SR,
/*  0x8d */ x86emuOp_lea_word_R_M,
/*  0x8e */ x86emuOp_mov_word_SR_RM,
/*  0x8f */ x86emuOp_pop_RM,
/*  0x90 */ x86emuOp_nop,
/*  0x91 */ x86emuOp_xchg_word_AX_CX,
/*  0x92 */ x86emuOp_xchg_word_AX_DX,
/*  0x93 */ x86emuOp_xchg_word_AX_BX,
/*  0x94 */ x86emuOp_xchg_word_AX_SP,
/*  0x95 */ x86emuOp_xchg_word_AX_BP,
/*  0x96 */ x86emuOp_xchg_word_AX_SI,
/*  0x97 */ x86emuOp_xchg_word_AX_DI,
/*  0x98 */ x86emuOp_cbw,
/*  0x99 */ x86emuOp_cwd,
/*  0x9a */ x86emuOp_call_far_IMM,
/*  0x9b */ x86emuOp_wait,
/*  0x9c */ x86emuOp_pushf_word,
/*  0x9d */ x86emuOp_popf_word,
/*  0x9e */ x86emuOp_sahf,
/*  0x9f */ x86emuOp_lahf,
/*  0xa0 */ x86emuOp_mov_AL_M_IMM,
/*  0xa1 */ x86emuOp_mov_AX_M_IMM,
/*  0xa2 */ x86emuOp_mov_M_AL_IMM,
/*  0xa3 */ x86emuOp_mov_M_AX_IMM,
/*  0xa4 */ x86emuOp_movs_byte,
/*  0xa5 */ x86emuOp_movs_word,
/*  0xa6 */ x86emuOp_cmps_byte,
/*  0xa7 */ x86emuOp_cmps_word,
/*  0xa8 */ x86emuOp_test_AL_IMM,
/*  0xa9 */ x86emuOp_test_AX_IMM,
/*  0xaa */ x86emuOp_stos_byte,
/*  0xab */ x86emuOp_stos_word,
/*  0xac */ x86emuOp_lods_byte,
/*  0xad */ x86emuOp_lods_word,
/*  0xac */ x86emuOp_scas_byte,
/*  0xad */ x86emuOp_scas_word,
/*  0xb0 */ x86emuOp_mov_byte_AL_IMM,
/*  0xb1 */ x86emuOp_mov_byte_CL_IMM,
/*  0xb2 */ x86emuOp_mov_byte_DL_IMM,
/*  0xb3 */ x86emuOp_mov_byte_BL_IMM,
/*  0xb4 */ x86emuOp_mov_byte_AH_IMM,
/*  0xb5 */ x86emuOp_mov_byte_CH_IMM,
/*  0xb6 */ x86emuOp_mov_byte_DH_IMM,
/*  0xb7 */ x86emuOp_mov_byte_BH_IMM,
/*  0xb8 */ x86emuOp_mov_word_AX_IMM,
/*  0xb9 */ x86emuOp_mov_word_CX_IMM,
/*  0xba */ x86emuOp_mov_word_DX_IMM,
/*  0xbb */ x86emuOp_mov_word_BX_IMM,
/*  0xbc */ x86emuOp_mov_word_SP_IMM,
/*  0xbd */ x86emuOp_mov_word_BP_IMM,
/*  0xbe */ x86emuOp_mov_word_SI_IMM,
/*  0xbf */ x86emuOp_mov_word_DI_IMM,
/*  0xc0 */ x86emuOp_opcC0_byte_RM_MEM,
/*  0xc1 */ x86emuOp_opcC1_word_RM_MEM,
/*  0xc2 */ x86emuOp_ret_near_IMM,
/*  0xc3 */ x86emuOp_ret_near,
/*  0xc4 */ x86emuOp_les_R_IMM,
/*  0xc5 */ x86emuOp_lds_R_IMM,
/*  0xc6 */ x86emuOp_mov_byte_RM_IMM,
/*  0xc7 */ x86emuOp_mov_word_RM_IMM,
/*  0xc8 */ x86emuOp_enter,
/*  0xc9 */ x86emuOp_leave,
/*  0xca */ x86emuOp_ret_far_IMM,
/*  0xcb */ x86emuOp_ret_far,
/*  0xcc */ x86emuOp_int3,
/*  0xcd */ x86emuOp_int_IMM,
/*  0xce */ x86emuOp_into,
/*  0xcf */ x86emuOp_iret,
/*  0xd0 */ x86emuOp_opcD0_byte_RM_1,
/*  0xd1 */ x86emuOp_opcD1_word_RM_1,
/*  0xd2 */ x86emuOp_opcD2_byte_RM_CL,
/*  0xd3 */ x86emuOp_opcD3_word_RM_CL,
/*  0xd4 */ x86emuOp_aam,
/*  0xd5 */ x86emuOp_aad,
                                                /*  0xd6 */ x86emuOp_illegal_op,
                                                /* Undocumented SETALC instruction */
/*  0xd7 */ x86emuOp_xlat,
/*  0xd8 */ x86emuOp_esc_coprocess_d8,
/*  0xd9 */ x86emuOp_esc_coprocess_d9,
/*  0xda */ x86emuOp_esc_coprocess_da,
/*  0xdb */ x86emuOp_esc_coprocess_db,
/*  0xdc */ x86emuOp_esc_coprocess_dc,
/*  0xdd */ x86emuOp_esc_coprocess_dd,
/*  0xde */ x86emuOp_esc_coprocess_de,
/*  0xdf */ x86emuOp_esc_coprocess_df,
/*  0xe0 */ x86emuOp_loopne,
/*  0xe1 */ x86emuOp_loope,
/*  0xe2 */ x86emuOp_loop,
/*  0xe3 */ x86emuOp_jcxz,
/*  0xe4 */ x86emuOp_in_byte_AL_IMM,
/*  0xe5 */ x86emuOp_in_word_AX_IMM,
/*  0xe6 */ x86emuOp_out_byte_IMM_AL,
/*  0xe7 */ x86emuOp_out_word_IMM_AX,
/*  0xe8 */ x86emuOp_call_near_IMM,
/*  0xe9 */ x86emuOp_jump_near_IMM,
/*  0xea */ x86emuOp_jump_far_IMM,
/*  0xeb */ x86emuOp_jump_byte_IMM,
/*  0xec */ x86emuOp_in_byte_AL_DX,
/*  0xed */ x86emuOp_in_word_AX_DX,
/*  0xee */ x86emuOp_out_byte_DX_AL,
/*  0xef */ x86emuOp_out_word_DX_AX,
/*  0xf0 */ x86emuOp_lock,
/*  0xf1 */ x86emuOp_illegal_op,
/*  0xf2 */ x86emuOp_repne,
/*  0xf3 */ x86emuOp_repe,
/*  0xf4 */ x86emuOp_halt,
/*  0xf5 */ x86emuOp_cmc,
/*  0xf6 */ x86emuOp_opcF6_byte_RM,
/*  0xf7 */ x86emuOp_opcF7_word_RM,
/*  0xf8 */ x86emuOp_clc,
/*  0xf9 */ x86emuOp_stc,
/*  0xfa */ x86emuOp_cli,
/*  0xfb */ x86emuOp_sti,
/*  0xfc */ x86emuOp_cld,
/*  0xfd */ x86emuOp_std,
/*  0xfe */ x86emuOp_opcFE_byte_RM,
/*  0xff */ x86emuOp_opcFF_word_RM,
};
@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d8952 5
a8956 1
    M.x86.R_IP = pop_word();
d8973 5
a8977 1
    M.x86.R_IP = pop_word();
d9270 7
a9276 2
            M.x86.R_BP -= 2;
            push_word(fetch_data_word_abs(M.x86.R_SS, M.x86.R_BP));
d9297 5
a9301 1
    M.x86.R_BP = pop_word();
d9321 7
a9327 2
    M.x86.R_IP = pop_word();
    M.x86.R_CS = pop_word();
d9344 7
a9350 2
    M.x86.R_IP = pop_word();
    M.x86.R_CS = pop_word();
d9451 9
a9459 3
    M.x86.R_IP = pop_word();
    M.x86.R_CS = pop_word();
    M.x86.R_FLG = pop_word();
d11776 11
a11786 4
            destval = fetch_data_word(destoffset);
            TRACE_AND_STEP();
            push_word(M.x86.R_IP);
            M.x86.R_IP = destval;
d11789 17
a11805 7
            destval = fetch_data_word(destoffset);
            destval2 = fetch_data_word(destoffset + 2);
            TRACE_AND_STEP();
            push_word(M.x86.R_CS);
            M.x86.R_CS = destval2;
            push_word(M.x86.R_IP);
            M.x86.R_IP = destval;
d11878 11
a11888 4
            destval = fetch_data_word(destoffset);
            TRACE_AND_STEP();
            push_word(M.x86.R_IP);
            M.x86.R_IP = destval;
d11891 17
a11907 7
            destval = fetch_data_word(destoffset);
            destval2 = fetch_data_word(destoffset + 2);
            TRACE_AND_STEP();
            push_word(M.x86.R_CS);
            M.x86.R_CS = destval2;
            push_word(M.x86.R_IP);
            M.x86.R_IP = destval;
d11980 11
a11990 4
            destval = fetch_data_word(destoffset);
            TRACE_AND_STEP();
            push_word(M.x86.R_IP);
            M.x86.R_IP = destval;
d11993 17
a12009 7
            destval = fetch_data_word(destoffset);
            destval2 = fetch_data_word(destoffset + 2);
            TRACE_AND_STEP();
            push_word(M.x86.R_CS);
            M.x86.R_CS = destval2;
            push_word(M.x86.R_IP);
            M.x86.R_IP = destval;
d12080 13
a12092 5
            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            push_word(M.x86.R_IP);
            M.x86.R_IP = *destreg;
@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d5533 1
a5533 1
           in the same format, even though the result is that the 
d5661 1
a5661 1
           in the same format, even though the result is that the 
d5693 1
a5693 1
     * Know operation, decode the mod byte to find the addressing 
d5856 1
a5856 1
           in the same format, even though the result is that the 
d5980 1
a5980 1
           in the same format, even though the result is that the 
d7475 1
a7475 1
     * 
d8691 1
a8691 1
           in the same format, even though the result is that the 
d8800 1
a8800 1
           in the same format, even though the result is that the 
d9703 1
a9703 1
           in the same format, even though the result is that the 
d9798 1
a9798 1
           in the same format, even though the result is that the 
d11541 1
a11541 1
           in the same format, even though the result is that the 
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d10192 2
a10193 2
    s16 ip16;
    s32 ip32;
d11708 1
a11708 1
                u32 destval;
d11710 1
a11710 1
                destval = fetch_data_long(destoffset);
d11712 2
a11713 2
                destval = inc_long(destval);
                store_data_long(destoffset, destval);
d11716 1
a11716 1
                u16 destval;
d11718 1
a11718 1
                destval = fetch_data_word(destoffset);
d11720 2
a11721 2
                destval = inc_word(destval);
                store_data_word(destoffset, destval);
d11726 1
a11726 1
                u32 destval;
d11728 1
a11728 1
                destval = fetch_data_long(destoffset);
d11730 2
a11731 2
                destval = dec_long(destval);
                store_data_long(destoffset, destval);
d11734 1
a11734 1
                u16 destval;
d11736 1
a11736 1
                destval = fetch_data_word(destoffset);
d11738 2
a11739 2
                destval = dec_word(destval);
                store_data_word(destoffset, destval);
d11771 1
a11771 1
                u32 destval;
d11773 1
a11773 1
                destval = fetch_data_long(destoffset);
d11775 1
a11775 1
                push_long(destval);
d11778 1
a11778 1
                u16 destval;
d11780 1
a11780 1
                destval = fetch_data_word(destoffset);
d11782 1
a11782 1
                push_word(destval);
d11793 1
a11793 1
                u32 destval;
d11795 1
a11795 1
                destval = fetch_data_long(destoffset);
d11797 2
a11798 2
                destval = inc_long(destval);
                store_data_long(destoffset, destval);
d11801 1
a11801 1
                u16 destval;
d11803 1
a11803 1
                destval = fetch_data_word(destoffset);
d11805 2
a11806 2
                destval = inc_word(destval);
                store_data_word(destoffset, destval);
d11811 1
a11811 1
                u32 destval;
d11813 1
a11813 1
                destval = fetch_data_long(destoffset);
d11815 2
a11816 2
                destval = dec_long(destval);
                store_data_long(destoffset, destval);
d11819 1
a11819 1
                u16 destval;
d11821 1
a11821 1
                destval = fetch_data_word(destoffset);
d11823 2
a11824 2
                destval = dec_word(destval);
                store_data_word(destoffset, destval);
d11856 1
a11856 1
                u32 destval;
d11858 1
a11858 1
                destval = fetch_data_long(destoffset);
d11860 1
a11860 1
                push_long(destval);
d11863 1
a11863 1
                u16 destval;
d11865 1
a11865 1
                destval = fetch_data_word(destoffset);
d11867 1
a11867 1
                push_word(destval);
d11878 1
a11878 1
                u32 destval;
d11880 1
a11880 1
                destval = fetch_data_long(destoffset);
d11882 2
a11883 2
                destval = inc_long(destval);
                store_data_long(destoffset, destval);
d11886 1
a11886 1
                u16 destval;
d11888 1
a11888 1
                destval = fetch_data_word(destoffset);
d11890 2
a11891 2
                destval = inc_word(destval);
                store_data_word(destoffset, destval);
d11896 1
a11896 1
                u32 destval;
d11898 1
a11898 1
                destval = fetch_data_long(destoffset);
d11900 2
a11901 2
                destval = dec_long(destval);
                store_data_long(destoffset, destval);
d11904 1
a11904 1
                u16 destval;
d11906 1
a11906 1
                destval = fetch_data_word(destoffset);
d11908 2
a11909 2
                destval = dec_word(destval);
                store_data_word(destoffset, destval);
d11941 1
a11941 1
                u32 destval;
d11943 1
a11943 1
                destval = fetch_data_long(destoffset);
d11945 1
a11945 1
                push_long(destval);
d11948 1
a11948 1
                u16 destval;
d11950 1
a11950 1
                destval = fetch_data_word(destoffset);
d11952 1
a11952 1
                push_word(destval);
d11961 1
a11961 1
                u32 *destreg;
d11963 1
a11963 1
                destreg = DECODE_RM_LONG_REGISTER(rl);
d11966 1
a11966 1
                *destreg = inc_long(*destreg);
d11969 1
a11969 1
                u16 *destreg;
d11971 1
a11971 1
                destreg = DECODE_RM_WORD_REGISTER(rl);
d11974 1
a11974 1
                *destreg = inc_word(*destreg);
d11979 1
a11979 1
                u32 *destreg;
d11981 1
a11981 1
                destreg = DECODE_RM_LONG_REGISTER(rl);
d11984 1
a11984 1
                *destreg = dec_long(*destreg);
d11987 1
a11987 1
                u16 *destreg;
d11989 1
a11989 1
                destreg = DECODE_RM_WORD_REGISTER(rl);
d11992 1
a11992 1
                *destreg = dec_word(*destreg);
d12021 1
a12021 1
                u32 *destreg;
d12023 1
a12023 1
                destreg = DECODE_RM_LONG_REGISTER(rl);
d12026 1
a12026 1
                push_long(*destreg);
d12029 1
a12029 1
                u16 *destreg;
d12031 1
a12031 1
                destreg = DECODE_RM_WORD_REGISTER(rl);
d12034 1
a12034 1
                push_word(*destreg);
@


1.4
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d84 2
a85 2
static void x86emuOp_illegal_op(
    u8 op1)
d89 6
a94 6
    DECODE_PRINTF("ILLEGAL X86 OPCODE\n");
    TRACE_REGS();
    DB( printk("%04x:%04x: %02X ILLEGAL X86 OPCODE!\n",
        M.x86.R_CS, M.x86.R_IP-1,op1));
    HALT_SYS();
        }
d103 1
a103 1
        }
d111 2
a112 1
static void x86emuOp_add_byte_RM_R(u8 X86EMU_UNUSED(op1))
d153 1
a153 1
    case 3:                     /* register to register */
d170 2
a171 1
static void x86emuOp_add_word_RM_R(u8 X86EMU_UNUSED(op1))
d193 2
a194 1
        } else {
d221 2
a222 1
        } else {
d249 2
a250 1
        } else {
d264 1
a264 1
    case 3:                     /* register to register */
d266 1
a266 1
            u32 *destreg,*srcreg;
d274 3
a276 2
        } else {
            u16 *destreg,*srcreg;
d295 2
a296 1
static void x86emuOp_add_byte_R_RM(u8 X86EMU_UNUSED(op1))
d334 1
a334 1
    case 3:                     /* register to register */
d351 2
a352 1
static void x86emuOp_add_word_R_RM(u8 X86EMU_UNUSED(op1))
d373 2
a374 1
        } else {
d399 2
a400 1
        } else {
d425 2
a426 1
        } else {
d439 1
a439 1
    case 3:                     /* register to register */
d441 1
a441 1
            u32 *destreg,*srcreg;
d449 3
a451 2
        } else {
            u16 *destreg,*srcreg;
d470 2
a471 1
static void x86emuOp_add_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
d489 2
a490 1
static void x86emuOp_add_word_AX_IMM(u8 X86EMU_UNUSED(op1))
d498 2
a499 1
    } else {
d507 3
a509 2
    } else {
        M.x86.R_AX = add_word(M.x86.R_AX, (u16)srcval);
d519 2
a520 1
static void x86emuOp_push_ES(u8 X86EMU_UNUSED(op1))
d534 2
a535 1
static void x86emuOp_pop_ES(u8 X86EMU_UNUSED(op1))
d549 2
a550 1
static void x86emuOp_or_byte_RM_R(u8 X86EMU_UNUSED(op1))
d591 1
a591 1
    case 3:                     /* register to register */
d608 2
a609 1
static void x86emuOp_or_word_RM_R(u8 X86EMU_UNUSED(op1))
d631 2
a632 1
        } else {
d659 2
a660 1
        } else {
d687 2
a688 1
        } else {
d702 1
a702 1
    case 3:                     /* register to register */
d704 1
a704 1
            u32 *destreg,*srcreg;
d712 3
a714 2
        } else {
            u16 *destreg,*srcreg;
d733 2
a734 1
static void x86emuOp_or_byte_R_RM(u8 X86EMU_UNUSED(op1))
d772 1
a772 1
    case 3:                     /* register to register */
d789 2
a790 1
static void x86emuOp_or_word_R_RM(u8 X86EMU_UNUSED(op1))
d811 2
a812 1
        } else {
d837 2
a838 1
        } else {
d863 2
a864 1
        } else {
d877 1
a877 1
    case 3:                     /* register to register */
d879 1
a879 1
            u32 *destreg,*srcreg;
d887 3
a889 2
        } else {
            u16 *destreg,*srcreg;
d908 2
a909 1
static void x86emuOp_or_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
d927 2
a928 1
static void x86emuOp_or_word_AX_IMM(u8 X86EMU_UNUSED(op1))
d936 2
a937 1
    } else {
d945 3
a947 2
    } else {
        M.x86.R_AX = or_word(M.x86.R_AX, (u16)srcval);
d957 2
a958 1
static void x86emuOp_push_CS(u8 X86EMU_UNUSED(op1))
d972 2
a973 1
static void x86emuOp_two_byte(u8 X86EMU_UNUSED(op1))
d975 2
a976 1
    u8 op2 = (*sys_rdb)(((u32)M.x86.R_CS << 4) + (M.x86.R_IP++));
d978 1
a978 1
    (*x86emu_optab2[op2])(op2);
d985 2
a986 1
static void x86emuOp_adc_byte_RM_R(u8 X86EMU_UNUSED(op1))
d1027 1
a1027 1
    case 3:                     /* register to register */
d1044 2
a1045 1
static void x86emuOp_adc_word_RM_R(u8 X86EMU_UNUSED(op1))
d1067 2
a1068 1
        } else {
d1095 2
a1096 1
        } else {
d1123 2
a1124 1
        } else {
d1138 1
a1138 1
    case 3:                     /* register to register */
d1140 1
a1140 1
            u32 *destreg,*srcreg;
d1148 3
a1150 2
        } else {
            u16 *destreg,*srcreg;
d1169 2
a1170 1
static void x86emuOp_adc_byte_R_RM(u8 X86EMU_UNUSED(op1))
d1208 1
a1208 1
    case 3:                     /* register to register */
d1225 2
a1226 1
static void x86emuOp_adc_word_R_RM(u8 X86EMU_UNUSED(op1))
d1247 2
a1248 1
        } else {
d1273 2
a1274 1
        } else {
d1299 2
a1300 1
        } else {
d1313 1
a1313 1
    case 3:                     /* register to register */
d1315 1
a1315 1
            u32 *destreg,*srcreg;
d1323 3
a1325 2
        } else {
            u16 *destreg,*srcreg;
d1344 2
a1345 1
static void x86emuOp_adc_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
d1363 2
a1364 1
static void x86emuOp_adc_word_AX_IMM(u8 X86EMU_UNUSED(op1))
d1372 2
a1373 1
    } else {
d1381 3
a1383 2
    } else {
        M.x86.R_AX = adc_word(M.x86.R_AX, (u16)srcval);
d1393 2
a1394 1
static void x86emuOp_push_SS(u8 X86EMU_UNUSED(op1))
d1408 2
a1409 1
static void x86emuOp_pop_SS(u8 X86EMU_UNUSED(op1))
d1423 2
a1424 1
static void x86emuOp_sbb_byte_RM_R(u8 X86EMU_UNUSED(op1))
d1465 1
a1465 1
    case 3:                     /* register to register */
d1482 2
a1483 1
static void x86emuOp_sbb_word_RM_R(u8 X86EMU_UNUSED(op1))
d1505 2
a1506 1
        } else {
d1533 2
a1534 1
        } else {
d1561 2
a1562 1
        } else {
d1576 1
a1576 1
    case 3:                     /* register to register */
d1578 1
a1578 1
            u32 *destreg,*srcreg;
d1586 3
a1588 2
        } else {
            u16 *destreg,*srcreg;
d1607 2
a1608 1
static void x86emuOp_sbb_byte_R_RM(u8 X86EMU_UNUSED(op1))
d1646 1
a1646 1
    case 3:                     /* register to register */
d1663 2
a1664 1
static void x86emuOp_sbb_word_R_RM(u8 X86EMU_UNUSED(op1))
d1685 2
a1686 1
        } else {
d1711 2
a1712 1
        } else {
d1737 2
a1738 1
        } else {
d1751 1
a1751 1
    case 3:                     /* register to register */
d1753 1
a1753 1
            u32 *destreg,*srcreg;
d1761 3
a1763 2
        } else {
            u16 *destreg,*srcreg;
d1782 2
a1783 1
static void x86emuOp_sbb_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
d1801 2
a1802 1
static void x86emuOp_sbb_word_AX_IMM(u8 X86EMU_UNUSED(op1))
d1810 2
a1811 1
    } else {
d1819 3
a1821 2
    } else {
        M.x86.R_AX = sbb_word(M.x86.R_AX, (u16)srcval);
d1831 2
a1832 1
static void x86emuOp_push_DS(u8 X86EMU_UNUSED(op1))
d1846 2
a1847 1
static void x86emuOp_pop_DS(u8 X86EMU_UNUSED(op1))
d1861 2
a1862 1
static void x86emuOp_and_byte_RM_R(u8 X86EMU_UNUSED(op1))
d1907 1
a1907 1
    case 3:                     /* register to register */
d1924 2
a1925 1
static void x86emuOp_and_word_RM_R(u8 X86EMU_UNUSED(op1))
d1947 2
a1948 1
        } else {
d1975 2
a1976 1
        } else {
d2003 2
a2004 1
        } else {
d2018 1
a2018 1
    case 3:                     /* register to register */
d2020 1
a2020 1
            u32 *destreg,*srcreg;
d2028 3
a2030 2
        } else {
            u16 *destreg,*srcreg;
d2049 2
a2050 1
static void x86emuOp_and_byte_R_RM(u8 X86EMU_UNUSED(op1))
d2088 1
a2088 1
    case 3:                     /* register to register */
d2105 2
a2106 1
static void x86emuOp_and_word_R_RM(u8 X86EMU_UNUSED(op1))
d2127 2
a2128 1
        } else {
d2154 2
a2155 1
        } else {
d2180 2
a2181 1
        } else {
d2194 1
a2194 1
    case 3:                     /* register to register */
d2196 1
a2196 1
            u32 *destreg,*srcreg;
d2204 3
a2206 2
        } else {
            u16 *destreg,*srcreg;
d2225 2
a2226 1
static void x86emuOp_and_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
d2244 2
a2245 1
static void x86emuOp_and_word_AX_IMM(u8 X86EMU_UNUSED(op1))
d2253 2
a2254 1
    } else {
d2262 3
a2264 2
    } else {
        M.x86.R_AX = and_word(M.x86.R_AX, (u16)srcval);
d2274 2
a2275 1
static void x86emuOp_segovr_ES(u8 X86EMU_UNUSED(op1))
d2292 2
a2293 1
static void x86emuOp_daa(u8 X86EMU_UNUSED(op1))
d2307 2
a2308 1
static void x86emuOp_sub_byte_RM_R(u8 X86EMU_UNUSED(op1))
d2349 1
a2349 1
    case 3:                     /* register to register */
d2366 2
a2367 1
static void x86emuOp_sub_word_RM_R(u8 X86EMU_UNUSED(op1))
d2389 2
a2390 1
        } else {
d2417 2
a2418 1
        } else {
d2445 2
a2446 1
        } else {
d2460 1
a2460 1
    case 3:                     /* register to register */
d2462 1
a2462 1
            u32 *destreg,*srcreg;
d2470 3
a2472 2
        } else {
            u16 *destreg,*srcreg;
d2491 2
a2492 1
static void x86emuOp_sub_byte_R_RM(u8 X86EMU_UNUSED(op1))
d2530 1
a2530 1
    case 3:                     /* register to register */
d2547 2
a2548 1
static void x86emuOp_sub_word_R_RM(u8 X86EMU_UNUSED(op1))
d2569 2
a2570 1
        } else {
d2595 2
a2596 1
        } else {
d2621 2
a2622 1
        } else {
d2635 1
a2635 1
    case 3:                     /* register to register */
d2637 1
a2637 1
            u32 *destreg,*srcreg;
d2645 3
a2647 2
        } else {
            u16 *destreg,*srcreg;
d2666 2
a2667 1
static void x86emuOp_sub_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
d2685 2
a2686 1
static void x86emuOp_sub_word_AX_IMM(u8 X86EMU_UNUSED(op1))
d2694 2
a2695 1
    } else {
d2703 3
a2705 2
    } else {
        M.x86.R_AX = sub_word(M.x86.R_AX, (u16)srcval);
d2715 2
a2716 1
static void x86emuOp_segovr_CS(u8 X86EMU_UNUSED(op1))
d2730 2
a2731 1
static void x86emuOp_das(u8 X86EMU_UNUSED(op1))
d2745 2
a2746 1
static void x86emuOp_xor_byte_RM_R(u8 X86EMU_UNUSED(op1))
d2787 1
a2787 1
    case 3:                     /* register to register */
d2804 2
a2805 1
static void x86emuOp_xor_word_RM_R(u8 X86EMU_UNUSED(op1))
d2827 2
a2828 1
        } else {
d2855 2
a2856 1
        } else {
d2883 2
a2884 1
        } else {
d2898 1
a2898 1
    case 3:                     /* register to register */
d2900 1
a2900 1
            u32 *destreg,*srcreg;
d2908 3
a2910 2
        } else {
            u16 *destreg,*srcreg;
d2929 2
a2930 1
static void x86emuOp_xor_byte_R_RM(u8 X86EMU_UNUSED(op1))
d2968 1
a2968 1
    case 3:                     /* register to register */
d2985 2
a2986 1
static void x86emuOp_xor_word_R_RM(u8 X86EMU_UNUSED(op1))
d3007 2
a3008 1
        } else {
d3033 2
a3034 1
        } else {
d3059 2
a3060 1
        } else {
d3073 1
a3073 1
    case 3:                     /* register to register */
d3075 1
a3075 1
            u32 *destreg,*srcreg;
d3083 3
a3085 2
        } else {
            u16 *destreg,*srcreg;
d3104 2
a3105 1
static void x86emuOp_xor_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
d3123 2
a3124 1
static void x86emuOp_xor_word_AX_IMM(u8 X86EMU_UNUSED(op1))
d3132 2
a3133 1
    } else {
d3141 3
a3143 2
    } else {
        M.x86.R_AX = xor_word(M.x86.R_AX, (u16)srcval);
d3153 2
a3154 1
static void x86emuOp_segovr_SS(u8 X86EMU_UNUSED(op1))
d3168 2
a3169 1
static void x86emuOp_aaa(u8 X86EMU_UNUSED(op1))
d3183 2
a3184 1
static void x86emuOp_cmp_byte_RM_R(u8 X86EMU_UNUSED(op1))
d3222 1
a3222 1
    case 3:                     /* register to register */
d3239 2
a3240 1
static void x86emuOp_cmp_word_RM_R(u8 X86EMU_UNUSED(op1))
d3261 2
a3262 1
        } else {
d3287 2
a3288 1
        } else {
d3313 2
a3314 1
        } else {
d3327 1
a3327 1
    case 3:                     /* register to register */
d3329 1
a3329 1
            u32 *destreg,*srcreg;
d3337 3
a3339 2
        } else {
            u16 *destreg,*srcreg;
d3358 2
a3359 1
static void x86emuOp_cmp_byte_R_RM(u8 X86EMU_UNUSED(op1))
d3397 1
a3397 1
    case 3:                     /* register to register */
d3414 2
a3415 1
static void x86emuOp_cmp_word_R_RM(u8 X86EMU_UNUSED(op1))
d3436 2
a3437 1
        } else {
d3462 2
a3463 1
        } else {
d3488 2
a3489 1
        } else {
d3502 1
a3502 1
    case 3:                     /* register to register */
d3504 1
a3504 1
            u32 *destreg,*srcreg;
d3512 3
a3514 2
        } else {
            u16 *destreg,*srcreg;
d3533 2
a3534 1
static void x86emuOp_cmp_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
d3552 2
a3553 1
static void x86emuOp_cmp_word_AX_IMM(u8 X86EMU_UNUSED(op1))
d3561 2
a3562 1
    } else {
d3570 3
a3572 2
    } else {
        cmp_word(M.x86.R_AX, (u16)srcval);
d3582 2
a3583 1
static void x86emuOp_segovr_DS(u8 X86EMU_UNUSED(op1))
d3597 2
a3598 1
static void x86emuOp_aas(u8 X86EMU_UNUSED(op1))
d3612 2
a3613 1
static void x86emuOp_inc_AX(u8 X86EMU_UNUSED(op1))
d3618 2
a3619 1
    } else {
d3625 2
a3626 1
    } else {
d3637 2
a3638 1
static void x86emuOp_inc_CX(u8 X86EMU_UNUSED(op1))
d3643 2
a3644 1
    } else {
d3650 2
a3651 1
    } else {
d3662 2
a3663 1
static void x86emuOp_inc_DX(u8 X86EMU_UNUSED(op1))
d3668 2
a3669 1
    } else {
d3675 2
a3676 1
    } else {
d3687 2
a3688 1
static void x86emuOp_inc_BX(u8 X86EMU_UNUSED(op1))
d3693 2
a3694 1
    } else {
d3700 2
a3701 1
    } else {
d3712 2
a3713 1
static void x86emuOp_inc_SP(u8 X86EMU_UNUSED(op1))
d3718 2
a3719 1
    } else {
d3725 2
a3726 1
    } else {
d3737 2
a3738 1
static void x86emuOp_inc_BP(u8 X86EMU_UNUSED(op1))
d3743 2
a3744 1
    } else {
d3750 2
a3751 1
    } else {
d3762 2
a3763 1
static void x86emuOp_inc_SI(u8 X86EMU_UNUSED(op1))
d3768 2
a3769 1
    } else {
d3775 2
a3776 1
    } else {
d3787 2
a3788 1
static void x86emuOp_inc_DI(u8 X86EMU_UNUSED(op1))
d3793 2
a3794 1
    } else {
d3800 2
a3801 1
    } else {
d3812 2
a3813 1
static void x86emuOp_dec_AX(u8 X86EMU_UNUSED(op1))
d3818 2
a3819 1
    } else {
d3825 2
a3826 1
    } else {
d3837 2
a3838 1
static void x86emuOp_dec_CX(u8 X86EMU_UNUSED(op1))
d3843 2
a3844 1
    } else {
d3850 2
a3851 1
    } else {
d3862 2
a3863 1
static void x86emuOp_dec_DX(u8 X86EMU_UNUSED(op1))
d3868 2
a3869 1
    } else {
d3875 2
a3876 1
    } else {
d3887 2
a3888 1
static void x86emuOp_dec_BX(u8 X86EMU_UNUSED(op1))
d3893 2
a3894 1
    } else {
d3900 2
a3901 1
    } else {
d3912 2
a3913 1
static void x86emuOp_dec_SP(u8 X86EMU_UNUSED(op1))
d3918 2
a3919 1
    } else {
d3925 2
a3926 1
    } else {
d3937 2
a3938 1
static void x86emuOp_dec_BP(u8 X86EMU_UNUSED(op1))
d3943 2
a3944 1
    } else {
d3950 2
a3951 1
    } else {
d3962 2
a3963 1
static void x86emuOp_dec_SI(u8 X86EMU_UNUSED(op1))
d3968 2
a3969 1
    } else {
d3975 2
a3976 1
    } else {
d3987 2
a3988 1
static void x86emuOp_dec_DI(u8 X86EMU_UNUSED(op1))
d3993 2
a3994 1
    } else {
d4000 2
a4001 1
    } else {
d4012 2
a4013 1
static void x86emuOp_push_AX(u8 X86EMU_UNUSED(op1))
d4018 2
a4019 1
    } else {
d4025 2
a4026 1
    } else {
d4037 2
a4038 1
static void x86emuOp_push_CX(u8 X86EMU_UNUSED(op1))
d4043 2
a4044 1
    } else {
d4050 2
a4051 1
    } else {
d4062 2
a4063 1
static void x86emuOp_push_DX(u8 X86EMU_UNUSED(op1))
d4068 2
a4069 1
    } else {
d4075 2
a4076 1
    } else {
d4087 2
a4088 1
static void x86emuOp_push_BX(u8 X86EMU_UNUSED(op1))
d4093 2
a4094 1
    } else {
d4100 2
a4101 1
    } else {
d4112 2
a4113 1
static void x86emuOp_push_SP(u8 X86EMU_UNUSED(op1))
d4118 2
a4119 1
    } else {
d4123 9
a4131 8
	/* Always push (E)SP, since we are emulating an i386 and above
	 * processor. This is necessary as some BIOS'es use this to check
	 * what type of processor is in the system.
	 */
	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
		push_long(M.x86.R_ESP);
	} else {
		push_word((u16)(M.x86.R_SP));
d4141 2
a4142 1
static void x86emuOp_push_BP(u8 X86EMU_UNUSED(op1))
d4147 2
a4148 1
    } else {
d4154 2
a4155 1
    } else {
d4166 2
a4167 1
static void x86emuOp_push_SI(u8 X86EMU_UNUSED(op1))
d4172 2
a4173 1
    } else {
d4179 2
a4180 1
    } else {
d4191 2
a4192 1
static void x86emuOp_push_DI(u8 X86EMU_UNUSED(op1))
d4197 2
a4198 1
    } else {
d4204 2
a4205 1
    } else {
d4216 2
a4217 1
static void x86emuOp_pop_AX(u8 X86EMU_UNUSED(op1))
d4222 2
a4223 1
    } else {
d4229 2
a4230 1
    } else {
d4241 2
a4242 1
static void x86emuOp_pop_CX(u8 X86EMU_UNUSED(op1))
d4247 2
a4248 1
    } else {
d4254 2
a4255 1
    } else {
d4266 2
a4267 1
static void x86emuOp_pop_DX(u8 X86EMU_UNUSED(op1))
d4272 2
a4273 1
    } else {
d4279 2
a4280 1
    } else {
d4291 2
a4292 1
static void x86emuOp_pop_BX(u8 X86EMU_UNUSED(op1))
d4297 2
a4298 1
    } else {
d4304 2
a4305 1
    } else {
d4316 2
a4317 1
static void x86emuOp_pop_SP(u8 X86EMU_UNUSED(op1))
d4322 2
a4323 1
    } else {
d4329 2
a4330 1
    } else {
d4341 2
a4342 1
static void x86emuOp_pop_BP(u8 X86EMU_UNUSED(op1))
d4347 2
a4348 1
    } else {
d4354 2
a4355 1
    } else {
d4366 2
a4367 1
static void x86emuOp_pop_SI(u8 X86EMU_UNUSED(op1))
d4372 2
a4373 1
    } else {
d4379 2
a4380 1
    } else {
d4391 2
a4392 1
static void x86emuOp_pop_DI(u8 X86EMU_UNUSED(op1))
d4397 2
a4398 1
    } else {
d4404 2
a4405 1
    } else {
d4416 2
a4417 1
static void x86emuOp_push_all(u8 X86EMU_UNUSED(op1))
d4422 2
a4423 1
    } else {
d4438 2
a4439 1
    } else {
d4459 2
a4460 1
static void x86emuOp_pop_all(u8 X86EMU_UNUSED(op1))
d4465 2
a4466 1
    } else {
d4474 1
a4474 1
        M.x86.R_ESP += 4;              /* skip ESP */
d4479 2
a4480 1
    } else {
d4484 1
a4484 1
        M.x86.R_SP += 2;               /* skip SP */
d4501 2
a4502 1
static void x86emuOp_segovr_FS(u8 X86EMU_UNUSED(op1))
d4519 2
a4520 1
static void x86emuOp_segovr_GS(u8 X86EMU_UNUSED(op1))
d4537 2
a4538 1
static void x86emuOp_prefix_data(u8 X86EMU_UNUSED(op1))
d4552 2
a4553 1
static void x86emuOp_prefix_addr(u8 X86EMU_UNUSED(op1))
d4567 2
a4568 1
static void x86emuOp_push_word_IMM(u8 X86EMU_UNUSED(op1))
d4575 2
a4576 1
    } else {
d4583 3
a4585 2
    } else {
        push_word((u16)imm);
d4595 2
a4596 1
static void x86emuOp_imul_word_IMM(u8 X86EMU_UNUSED(op1))
d4609 1
a4609 1
            u32 res_lo,res_hi;
d4617 1
a4617 1
            DECODE_PRINTF2(",%d\n", (s32)imm);
d4619 1
a4619 1
            imul_long_direct(&res_lo,&res_hi,(s32)srcval,(s32)imm);
d4623 2
a4624 1
            } else {
d4628 3
a4630 2
            *destreg = (u32)res_lo;
        } else {
d4641 1
a4641 1
            DECODE_PRINTF2(",%d\n", (s32)imm);
d4643 2
a4644 1
            res = (s16)srcval * (s16)imm;
d4648 2
a4649 1
            } else {
d4653 1
a4653 1
            *destreg = (u16)res;
d4660 1
a4660 1
            u32 res_lo,res_hi;
d4668 1
a4668 1
            DECODE_PRINTF2(",%d\n", (s32)imm);
d4670 1
a4670 1
            imul_long_direct(&res_lo,&res_hi,(s32)srcval,(s32)imm);
d4674 2
a4675 1
            } else {
d4679 3
a4681 2
            *destreg = (u32)res_lo;
        } else {
d4692 1
a4692 1
            DECODE_PRINTF2(",%d\n", (s32)imm);
d4694 2
a4695 1
            res = (s16)srcval * (s16)imm;
d4699 2
a4700 1
            } else {
d4704 1
a4704 1
            *destreg = (u16)res;
d4711 1
a4711 1
            u32 res_lo,res_hi;
d4719 1
a4719 1
            DECODE_PRINTF2(",%d\n", (s32)imm);
d4721 1
a4721 1
            imul_long_direct(&res_lo,&res_hi,(s32)srcval,(s32)imm);
d4725 2
a4726 1
            } else {
d4730 3
a4732 2
            *destreg = (u32)res_lo;
        } else {
d4743 1
a4743 1
            DECODE_PRINTF2(",%d\n", (s32)imm);
d4745 2
a4746 1
            res = (s16)srcval * (s16)imm;
d4750 2
a4751 1
            } else {
d4755 1
a4755 1
            *destreg = (u16)res;
d4758 1
a4758 1
    case 3:                     /* register to register */
d4760 2
a4761 2
            u32 *destreg,*srcreg;
            u32 res_lo,res_hi;
d4768 1
a4768 1
            DECODE_PRINTF2(",%d\n", (s32)imm);
d4770 1
a4770 1
            imul_long_direct(&res_lo,&res_hi,(s32)*srcreg,(s32)imm);
d4774 2
a4775 1
            } else {
d4779 4
a4782 3
            *destreg = (u32)res_lo;
        } else {
            u16 *destreg,*srcreg;
d4790 2
a4791 2
            DECODE_PRINTF2(",%d\n", (s32)imm);
            res = (s16)*srcreg * (s16)imm;
d4795 2
a4796 1
            } else {
d4800 1
a4800 1
            *destreg = (u16)res;
d4812 2
a4813 1
static void x86emuOp_push_byte_IMM(u8 X86EMU_UNUSED(op1))
d4818 1
a4818 1
    imm = (s8)fetch_byte_imm();
d4822 4
a4825 3
	push_long((s32)imm);
    } else {
	push_word(imm);
d4835 2
a4836 1
static void x86emuOp_imul_byte_IMM(u8 X86EMU_UNUSED(op1))
d4840 1
a4840 1
    s8  imm;
d4850 1
a4850 1
            u32 res_lo,res_hi;
d4857 1
a4857 1
            DECODE_PRINTF2(",%d\n", (s32)imm);
d4859 1
a4859 1
            imul_long_direct(&res_lo,&res_hi,(s32)srcval,(s32)imm);
d4863 2
a4864 1
            } else {
d4868 3
a4870 2
            *destreg = (u32)res_lo;
        } else {
d4880 1
a4880 1
            DECODE_PRINTF2(",%d\n", (s32)imm);
d4882 2
a4883 1
            res = (s16)srcval * (s16)imm;
d4887 2
a4888 1
            } else {
d4892 1
a4892 1
            *destreg = (u16)res;
d4899 1
a4899 1
            u32 res_lo,res_hi;
d4906 1
a4906 1
            DECODE_PRINTF2(",%d\n", (s32)imm);
d4908 1
a4908 1
            imul_long_direct(&res_lo,&res_hi,(s32)srcval,(s32)imm);
d4912 2
a4913 1
            } else {
d4917 3
a4919 2
            *destreg = (u32)res_lo;
        } else {
d4929 1
a4929 1
            DECODE_PRINTF2(",%d\n", (s32)imm);
d4931 2
a4932 1
            res = (s16)srcval * (s16)imm;
d4936 2
a4937 1
            } else {
d4941 1
a4941 1
            *destreg = (u16)res;
d4948 1
a4948 1
            u32 res_lo,res_hi;
d4955 1
a4955 1
            DECODE_PRINTF2(",%d\n", (s32)imm);
d4957 1
a4957 1
            imul_long_direct(&res_lo,&res_hi,(s32)srcval,(s32)imm);
d4961 2
a4962 1
            } else {
d4966 3
a4968 2
            *destreg = (u32)res_lo;
        } else {
d4978 1
a4978 1
            DECODE_PRINTF2(",%d\n", (s32)imm);
d4980 2
a4981 1
            res = (s16)srcval * (s16)imm;
d4985 2
a4986 1
            } else {
d4990 1
a4990 1
            *destreg = (u16)res;
d4993 1
a4993 1
    case 3:                     /* register to register */
d4995 2
a4996 2
            u32 *destreg,*srcreg;
            u32 res_lo,res_hi;
d5002 1
a5002 1
            DECODE_PRINTF2(",%d\n", (s32)imm);
d5004 1
a5004 1
            imul_long_direct(&res_lo,&res_hi,(s32)*srcreg,(s32)imm);
d5008 2
a5009 1
            } else {
d5013 4
a5016 3
            *destreg = (u32)res_lo;
        } else {
            u16 *destreg,*srcreg;
d5023 2
a5024 2
            DECODE_PRINTF2(",%d\n", (s32)imm);
            res = (s16)*srcreg * (s16)imm;
d5028 2
a5029 1
            } else {
d5033 1
a5033 1
            *destreg = (u16)res;
d5045 2
a5046 1
static void x86emuOp_ins_byte(u8 X86EMU_UNUSED(op1))
d5060 2
a5061 1
static void x86emuOp_ins_word(u8 X86EMU_UNUSED(op1))
d5067 2
a5068 1
    } else {
d5081 2
a5082 1
static void x86emuOp_outs_byte(u8 X86EMU_UNUSED(op1))
d5096 2
a5097 1
static void x86emuOp_outs_word(u8 X86EMU_UNUSED(op1))
d5103 2
a5104 1
    } else {
d5117 2
a5118 1
static void x86emuOp_jump_near_O(u8 X86EMU_UNUSED(op1))
d5126 2
a5127 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5140 2
a5141 1
static void x86emuOp_jump_near_NO(u8 X86EMU_UNUSED(op1))
d5149 2
a5150 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5163 2
a5164 1
static void x86emuOp_jump_near_B(u8 X86EMU_UNUSED(op1))
d5172 2
a5173 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5186 2
a5187 1
static void x86emuOp_jump_near_NB(u8 X86EMU_UNUSED(op1))
d5195 2
a5196 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5209 2
a5210 1
static void x86emuOp_jump_near_Z(u8 X86EMU_UNUSED(op1))
d5218 2
a5219 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5232 2
a5233 1
static void x86emuOp_jump_near_NZ(u8 X86EMU_UNUSED(op1))
d5241 2
a5242 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5255 2
a5256 1
static void x86emuOp_jump_near_BE(u8 X86EMU_UNUSED(op1))
d5265 2
a5266 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5279 2
a5280 1
static void x86emuOp_jump_near_NBE(u8 X86EMU_UNUSED(op1))
d5289 2
a5290 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5303 2
a5304 1
static void x86emuOp_jump_near_S(u8 X86EMU_UNUSED(op1))
d5312 2
a5313 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5326 2
a5327 1
static void x86emuOp_jump_near_NS(u8 X86EMU_UNUSED(op1))
d5335 2
a5336 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5349 2
a5350 1
static void x86emuOp_jump_near_P(u8 X86EMU_UNUSED(op1))
d5358 2
a5359 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5372 2
a5373 1
static void x86emuOp_jump_near_NP(u8 X86EMU_UNUSED(op1))
d5381 2
a5382 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5395 2
a5396 1
static void x86emuOp_jump_near_L(u8 X86EMU_UNUSED(op1))
d5405 2
a5406 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5421 2
a5422 1
static void x86emuOp_jump_near_NL(u8 X86EMU_UNUSED(op1))
d5431 2
a5432 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5448 2
a5449 1
static void x86emuOp_jump_near_LE(u8 X86EMU_UNUSED(op1))
d5459 2
a5460 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5475 2
a5476 1
static void x86emuOp_jump_near_NLE(u8 X86EMU_UNUSED(op1))
d5486 2
a5487 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + (s16)offset);
d5498 9
a5506 10
static u8 (*opc80_byte_operation[])(u8 d, u8 s) =
{
    add_byte,           /* 00 */
    or_byte,            /* 01 */
    adc_byte,           /* 02 */
    sbb_byte,           /* 03 */
    and_byte,           /* 04 */
    sub_byte,           /* 05 */
    xor_byte,           /* 06 */
    cmp_byte,           /* 07 */
d5513 2
a5514 1
static void x86emuOp_opc80_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
d5603 1
a5603 1
    case 3:                     /* register to register */
d5618 9
a5626 10
static u16 (*opc81_word_operation[])(u16 d, u16 s) =
{
    add_word,           /*00 */
    or_word,            /*01 */
    adc_word,           /*02 */
    sbb_word,           /*03 */
    and_word,           /*04 */
    sub_word,           /*05 */
    xor_word,           /*06 */
    cmp_word,           /*07 */
d5629 9
a5637 10
static u32 (*opc81_long_operation[])(u32 d, u32 s) =
{
    add_long,           /*00 */
    or_long,            /*01 */
    adc_long,           /*02 */
    sbb_long,           /*03 */
    and_long,           /*04 */
    sub_long,           /*05 */
    xor_long,           /*06 */
    cmp_long,           /*07 */
d5644 2
a5645 1
static void x86emuOp_opc81_word_RM_IMM(u8 X86EMU_UNUSED(op1))
d5699 1
a5699 1
            u32 destval,imm;
d5711 3
a5713 2
        } else {
            u16 destval,imm;
d5729 1
a5729 1
            u32 destval,imm;
d5741 3
a5743 2
        } else {
            u16 destval,imm;
d5759 1
a5759 1
            u32 destval,imm;
d5771 3
a5773 2
        } else {
            u16 destval,imm;
d5787 1
a5787 1
    case 3:                     /* register to register */
d5790 1
a5790 1
            u32 destval,imm;
d5800 2
a5801 1
        } else {
d5803 1
a5803 1
            u16 destval,imm;
d5820 9
a5828 10
static u8 (*opc82_byte_operation[])(u8 s, u8 d) =
{
    add_byte,           /*00 */
    or_byte,            /*01 *//*YYY UNUSED ???? */
    adc_byte,           /*02 */
    sbb_byte,           /*03 */
    and_byte,           /*04 *//*YYY UNUSED ???? */
    sub_byte,           /*05 */
    xor_byte,           /*06 *//*YYY UNUSED ???? */
    cmp_byte,           /*07 */
d5835 2
a5836 1
static void x86emuOp_opc82_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
d5922 1
a5922 1
    case 3:                     /* register to register */
d5936 9
a5944 10
static u16 (*opc83_word_operation[])(u16 s, u16 d) =
{
    add_word,           /*00 */
    or_word,            /*01 *//*YYY UNUSED ???? */
    adc_word,           /*02 */
    sbb_word,           /*03 */
    and_word,           /*04 *//*YYY UNUSED ???? */
    sub_word,           /*05 */
    xor_word,           /*06 *//*YYY UNUSED ???? */
    cmp_word,           /*07 */
d5947 9
a5955 10
static u32 (*opc83_long_operation[])(u32 s, u32 d) =
{
    add_long,           /*00 */
    or_long,            /*01 *//*YYY UNUSED ???? */
    adc_long,           /*02 */
    sbb_long,           /*03 */
    and_long,           /*04 *//*YYY UNUSED ???? */
    sub_long,           /*05 */
    xor_long,           /*06 *//*YYY UNUSED ???? */
    cmp_long,           /*07 */
d5962 2
a5963 1
static void x86emuOp_opc83_word_RM_IMM(u8 X86EMU_UNUSED(op1))
d5982 1
a5982 1
       switch (rh) {
d6015 1
a6015 1
            u32 destval,imm;
d6026 3
a6028 2
        } else {
            u16 destval,imm;
d6043 1
a6043 1
            u32 destval,imm;
d6054 3
a6056 2
        } else {
            u16 destval,imm;
d6071 1
a6071 1
            u32 destval,imm;
d6082 3
a6084 2
        } else {
            u16 destval,imm;
d6097 1
a6097 1
    case 3:                     /* register to register */
d6100 1
a6100 1
            u32 destval,imm;
d6109 2
a6110 1
        } else {
d6112 1
a6112 1
            u16 destval,imm;
d6132 2
a6133 1
static void x86emuOp_test_byte_RM_R(u8 X86EMU_UNUSED(op1))
d6171 1
a6171 1
    case 3:                     /* register to register */
d6188 2
a6189 1
static void x86emuOp_test_word_RM_R(u8 X86EMU_UNUSED(op1))
d6210 2
a6211 1
        } else {
d6236 2
a6237 1
        } else {
d6262 2
a6263 1
        } else {
d6276 1
a6276 1
    case 3:                     /* register to register */
d6278 1
a6278 1
            u32 *destreg,*srcreg;
d6286 3
a6288 2
        } else {
            u16 *destreg,*srcreg;
d6307 2
a6308 1
static void x86emuOp_xchg_byte_RM_R(u8 X86EMU_UNUSED(op1))
d6356 1
a6356 1
    case 3:                     /* register to register */
d6375 2
a6376 1
static void x86emuOp_xchg_word_RM_R(u8 X86EMU_UNUSED(op1))
d6388 1
a6388 1
            u32 destval,tmp;
d6400 2
a6401 1
        } else {
d6403 1
a6403 1
            u16 destval,tmp;
d6420 1
a6420 1
            u32 destval,tmp;
d6432 2
a6433 1
        } else {
d6435 1
a6435 1
            u16 destval,tmp;
d6452 1
a6452 1
            u32 destval,tmp;
d6464 2
a6465 1
        } else {
d6467 1
a6467 1
            u16 destval,tmp;
d6481 1
a6481 1
    case 3:                     /* register to register */
d6483 1
a6483 1
            u32 *destreg,*srcreg;
d6494 3
a6496 2
        } else {
            u16 *destreg,*srcreg;
d6518 2
a6519 1
static void x86emuOp_mov_byte_RM_R(u8 X86EMU_UNUSED(op1))
d6553 1
a6553 1
    case 3:                     /* register to register */
d6570 2
a6571 1
static void x86emuOp_mov_word_RM_R(u8 X86EMU_UNUSED(op1))
d6590 2
a6591 1
        } else {
d6612 2
a6613 1
        } else {
d6634 2
a6635 1
        } else {
d6646 1
a6646 1
    case 3:                     /* register to register */
d6648 1
a6648 1
            u32 *destreg,*srcreg;
d6656 3
a6658 2
        } else {
            u16 *destreg,*srcreg;
d6677 2
a6678 1
static void x86emuOp_mov_byte_R_RM(u8 X86EMU_UNUSED(op1))
d6716 1
a6716 1
    case 3:                     /* register to register */
d6733 2
a6734 1
static void x86emuOp_mov_word_R_RM(u8 X86EMU_UNUSED(op1))
d6755 2
a6756 1
        } else {
d6781 2
a6782 1
        } else {
d6807 2
a6808 1
        } else {
d6821 1
a6821 1
    case 3:                     /* register to register */
d6831 2
a6832 1
        } else {
d6852 2
a6853 1
static void x86emuOp_mov_word_RM_SR(u8 X86EMU_UNUSED(op1))
d6891 1
a6891 1
    case 3:                     /* register to register */
d6908 2
a6909 1
static void x86emuOp_lea_word_R_M(u8 X86EMU_UNUSED(op1))
d6921 1
d6926 3
a6928 2
            *srcreg = (u32)destoffset;
        } else {
d6930 1
d6935 1
a6935 1
            *srcreg = (u16)destoffset;
d6941 1
d6946 3
a6948 2
            *srcreg = (u32)destoffset;
        } else {
d6950 1
d6955 1
a6955 1
            *srcreg = (u16)destoffset;
d6961 1
d6966 3
a6968 2
            *srcreg = (u32)destoffset;
        } else {
d6970 1
d6975 1
a6975 1
            *srcreg = (u16)destoffset;
d6978 1
a6978 1
    case 3:                     /* register to register */
d6990 2
a6991 1
static void x86emuOp_mov_word_SR_RM(u8 X86EMU_UNUSED(op1))
d7029 1
a7029 1
    case 3:                     /* register to register */
d7052 2
a7053 1
static void x86emuOp_pop_RM(u8 X86EMU_UNUSED(op1))
d7075 2
a7076 1
        } else {
d7095 2
a7096 1
        } else {
d7115 2
a7116 1
        } else {
d7126 1
a7126 1
    case 3:                     /* register to register */
d7134 2
a7135 1
        } else {
d7153 2
a7154 1
static void x86emuOp_nop(u8 X86EMU_UNUSED(op1))
d7167 2
a7168 1
static void x86emuOp_xchg_word_AX_CX(u8 X86EMU_UNUSED(op1))
d7175 2
a7176 1
    } else {
d7184 2
a7185 1
    } else {
d7188 1
a7188 1
        M.x86.R_CX = (u16)tmp;
d7198 2
a7199 1
static void x86emuOp_xchg_word_AX_DX(u8 X86EMU_UNUSED(op1))
d7206 2
a7207 1
    } else {
d7215 2
a7216 1
    } else {
d7219 1
a7219 1
        M.x86.R_DX = (u16)tmp;
d7229 2
a7230 1
static void x86emuOp_xchg_word_AX_BX(u8 X86EMU_UNUSED(op1))
d7237 2
a7238 1
    } else {
d7246 2
a7247 1
    } else {
d7250 1
a7250 1
        M.x86.R_BX = (u16)tmp;
d7260 2
a7261 1
static void x86emuOp_xchg_word_AX_SP(u8 X86EMU_UNUSED(op1))
d7268 2
a7269 1
    } else {
d7277 2
a7278 1
    } else {
d7281 1
a7281 1
        M.x86.R_SP = (u16)tmp;
d7291 2
a7292 1
static void x86emuOp_xchg_word_AX_BP(u8 X86EMU_UNUSED(op1))
d7299 2
a7300 1
    } else {
d7308 2
a7309 1
    } else {
d7312 1
a7312 1
        M.x86.R_BP = (u16)tmp;
d7322 2
a7323 1
static void x86emuOp_xchg_word_AX_SI(u8 X86EMU_UNUSED(op1))
d7330 2
a7331 1
    } else {
d7339 2
a7340 1
    } else {
d7343 1
a7343 1
        M.x86.R_SI = (u16)tmp;
d7353 2
a7354 1
static void x86emuOp_xchg_word_AX_DI(u8 X86EMU_UNUSED(op1))
d7361 2
a7362 1
    } else {
d7370 2
a7371 1
    } else {
d7374 1
a7374 1
        M.x86.R_DI = (u16)tmp;
d7384 2
a7385 1
static void x86emuOp_cbw(u8 X86EMU_UNUSED(op1))
d7390 2
a7391 1
    } else {
d7398 2
a7399 1
        } else {
d7402 2
a7403 1
    } else {
d7406 2
a7407 1
        } else {
d7419 2
a7420 1
static void x86emuOp_cwd(u8 X86EMU_UNUSED(op1))
d7425 2
a7426 1
    } else {
d7434 2
a7435 1
        } else {
d7438 2
a7439 1
    } else {
d7442 2
a7443 1
        } else {
d7455 2
a7456 1
static void x86emuOp_call_far_IMM(u8 X86EMU_UNUSED(op1))
d7463 6
a7468 5
	faroff = fetch_long_imm();
	farseg = fetch_word_imm();
    } else {
	faroff = fetch_word_imm();
	farseg = fetch_word_imm();
d7484 4
a7487 3
	push_long(M.x86.R_EIP);
    } else {
	push_word(M.x86.R_IP);
d7498 2
a7499 1
static void x86emuOp_wait(u8 X86EMU_UNUSED(op1))
d7513 2
a7514 1
static void x86emuOp_pushf_word(u8 X86EMU_UNUSED(op1))
d7521 2
a7522 1
    } else {
d7531 3
a7533 2
    } else {
        push_word((u16)flags);
d7543 2
a7544 1
static void x86emuOp_popf_word(u8 X86EMU_UNUSED(op1))
d7549 2
a7550 1
    } else {
d7556 2
a7557 1
    } else {
d7568 2
a7569 1
static void x86emuOp_sahf(u8 X86EMU_UNUSED(op1))
d7586 2
a7587 1
static void x86emuOp_lahf(u8 X86EMU_UNUSED(op1))
d7592 1
a7592 1
	M.x86.R_AH = (u8)(M.x86.R_FLG & 0xff);
d7604 2
a7605 1
static void x86emuOp_mov_AL_M_IMM(u8 X86EMU_UNUSED(op1))
d7623 2
a7624 1
static void x86emuOp_mov_AX_M_IMM(u8 X86EMU_UNUSED(op1))
d7632 2
a7633 1
    } else {
d7639 2
a7640 1
    } else {
d7651 2
a7652 1
static void x86emuOp_mov_M_AL_IMM(u8 X86EMU_UNUSED(op1))
d7670 2
a7671 1
static void x86emuOp_mov_M_AX_IMM(u8 X86EMU_UNUSED(op1))
d7679 2
a7680 1
    } else {
d7686 2
a7687 1
    } else {
d7698 2
a7699 1
static void x86emuOp_movs_byte(u8 X86EMU_UNUSED(op1))
d7701 1
a7701 1
    u8  val;
d7707 1
a7707 1
    if (ACCESS_FLAG(F_DF))   /* down */
d7734 2
a7735 1
static void x86emuOp_movs_word(u8 X86EMU_UNUSED(op1))
d7744 1
a7744 1
        if (ACCESS_FLAG(F_DF))      /* down */
d7748 2
a7749 1
    } else {
d7751 1
a7751 1
        if (ACCESS_FLAG(F_DF))      /* down */
d7769 2
a7770 1
        } else {
d7772 1
a7772 1
            store_data_word_abs(M.x86.R_ES, M.x86.R_DI, (u16)val);
d7785 2
a7786 1
static void x86emuOp_cmps_byte(u8 X86EMU_UNUSED(op1))
d7794 1
a7794 1
    if (ACCESS_FLAG(F_DF))   /* down */
d7805 1
a7805 1
                     cmp_byte(val1, val2);
d7813 2
a7814 1
    } else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
d7828 2
a7829 1
    } else {
d7844 2
a7845 1
static void x86emuOp_cmps_word(u8 X86EMU_UNUSED(op1))
d7847 1
a7847 1
    u32 val1,val2;
d7853 1
a7853 1
        if (ACCESS_FLAG(F_DF))   /* down */
d7857 2
a7858 1
    } else {
d7860 1
a7860 1
        if (ACCESS_FLAG(F_DF))   /* down */
d7874 2
a7875 1
            } else {
d7878 1
a7878 1
                cmp_word((u16)val1, (u16)val2);
d7887 2
a7888 1
    } else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
d7896 2
a7897 1
            } else {
d7900 1
a7900 1
                cmp_word((u16)val1, (u16)val2);
d7909 2
a7910 1
    } else {
d7915 2
a7916 1
        } else {
d7919 1
a7919 1
            cmp_word((u16)val1, (u16)val2);
d7932 2
a7933 1
static void x86emuOp_test_AL_IMM(u8 X86EMU_UNUSED(op1))
d7942 1
a7942 1
	test_byte(M.x86.R_AL, (u8)imm);
d7951 2
a7952 1
static void x86emuOp_test_AX_IMM(u8 X86EMU_UNUSED(op1))
d7960 2
a7961 1
    } else {
d7969 3
a7971 2
    } else {
        test_word(M.x86.R_AX, (u16)srcval);
d7981 2
a7982 1
static void x86emuOp_stos_byte(u8 X86EMU_UNUSED(op1))
d7988 1
a7988 1
    if (ACCESS_FLAG(F_DF))   /* down */
d8002 2
a8003 1
    } else {
d8015 2
a8016 1
static void x86emuOp_stos_word(u8 X86EMU_UNUSED(op1))
d8024 1
a8024 1
        if (ACCESS_FLAG(F_DF))   /* down */
d8028 2
a8029 1
    } else {
d8031 1
a8031 1
        if (ACCESS_FLAG(F_DF))   /* down */
d8048 2
a8049 1
        } else {
d8062 2
a8063 1
static void x86emuOp_lods_byte(u8 X86EMU_UNUSED(op1))
d8070 1
a8070 1
    if (ACCESS_FLAG(F_DF))   /* down */
d8083 2
a8084 1
    } else {
d8096 2
a8097 1
static void x86emuOp_lods_word(u8 X86EMU_UNUSED(op1))
d8105 1
a8105 1
        if (ACCESS_FLAG(F_DF))   /* down */
d8109 2
a8110 1
    } else {
d8112 1
a8112 1
        if (ACCESS_FLAG(F_DF))   /* down */
d8129 2
a8130 1
        } else {
d8143 2
a8144 1
static void x86emuOp_scas_byte(u8 X86EMU_UNUSED(op1))
d8152 1
a8152 1
    if (ACCESS_FLAG(F_DF))   /* down */
d8168 2
a8169 1
    } else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
d8181 2
a8182 1
    } else {
d8195 2
a8196 1
static void x86emuOp_scas_word(u8 X86EMU_UNUSED(op1))
d8204 1
a8204 1
        if (ACCESS_FLAG(F_DF))   /* down */
d8208 2
a8209 1
    } else {
d8211 1
a8211 1
        if (ACCESS_FLAG(F_DF))   /* down */
d8224 2
a8225 1
            } else {
d8227 1
a8227 1
                cmp_word(M.x86.R_AX, (u16)val);
d8235 2
a8236 1
    } else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
d8243 2
a8244 1
            } else {
d8246 1
a8246 1
                cmp_word(M.x86.R_AX, (u16)val);
d8254 2
a8255 1
    } else {
d8259 2
a8260 1
        } else {
d8262 1
a8262 1
            cmp_word(M.x86.R_AX, (u16)val);
d8274 2
a8275 1
static void x86emuOp_mov_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
d8293 2
a8294 1
static void x86emuOp_mov_byte_CL_IMM(u8 X86EMU_UNUSED(op1))
d8312 2
a8313 1
static void x86emuOp_mov_byte_DL_IMM(u8 X86EMU_UNUSED(op1))
d8331 2
a8332 1
static void x86emuOp_mov_byte_BL_IMM(u8 X86EMU_UNUSED(op1))
d8350 2
a8351 1
static void x86emuOp_mov_byte_AH_IMM(u8 X86EMU_UNUSED(op1))
d8369 2
a8370 1
static void x86emuOp_mov_byte_CH_IMM(u8 X86EMU_UNUSED(op1))
d8388 2
a8389 1
static void x86emuOp_mov_byte_DH_IMM(u8 X86EMU_UNUSED(op1))
d8407 2
a8408 1
static void x86emuOp_mov_byte_BH_IMM(u8 X86EMU_UNUSED(op1))
d8426 2
a8427 1
static void x86emuOp_mov_word_AX_IMM(u8 X86EMU_UNUSED(op1))
d8435 2
a8436 1
    } else {
d8444 3
a8446 2
    } else {
        M.x86.R_AX = (u16)srcval;
d8456 2
a8457 1
static void x86emuOp_mov_word_CX_IMM(u8 X86EMU_UNUSED(op1))
d8465 2
a8466 1
    } else {
d8474 3
a8476 2
    } else {
        M.x86.R_CX = (u16)srcval;
d8486 2
a8487 1
static void x86emuOp_mov_word_DX_IMM(u8 X86EMU_UNUSED(op1))
d8495 2
a8496 1
    } else {
d8504 3
a8506 2
    } else {
        M.x86.R_DX = (u16)srcval;
d8516 2
a8517 1
static void x86emuOp_mov_word_BX_IMM(u8 X86EMU_UNUSED(op1))
d8525 2
a8526 1
    } else {
d8534 3
a8536 2
    } else {
        M.x86.R_BX = (u16)srcval;
d8546 2
a8547 1
static void x86emuOp_mov_word_SP_IMM(u8 X86EMU_UNUSED(op1))
d8555 2
a8556 1
    } else {
d8564 3
a8566 2
    } else {
        M.x86.R_SP = (u16)srcval;
d8576 2
a8577 1
static void x86emuOp_mov_word_BP_IMM(u8 X86EMU_UNUSED(op1))
d8585 2
a8586 1
    } else {
d8594 3
a8596 2
    } else {
        M.x86.R_BP = (u16)srcval;
d8606 2
a8607 1
static void x86emuOp_mov_word_SI_IMM(u8 X86EMU_UNUSED(op1))
d8615 2
a8616 1
    } else {
d8624 3
a8626 2
    } else {
        M.x86.R_SI = (u16)srcval;
d8636 2
a8637 1
static void x86emuOp_mov_word_DI_IMM(u8 X86EMU_UNUSED(op1))
d8645 2
a8646 1
    } else {
d8654 3
a8656 2
    } else {
        M.x86.R_DI = (u16)srcval;
d8663 3
a8665 11
static u8(*opcD0_byte_operation[])(u8 d, u8 s) =
{
    rol_byte,
    ror_byte,
    rcl_byte,
    rcr_byte,
    shl_byte,
    shr_byte,
    shl_byte,           /* sal_byte === shl_byte  by definition */
    sar_byte,
};
d8671 2
a8672 1
static void x86emuOp_opcC0_byte_RM_MEM(u8 X86EMU_UNUSED(op1))
d8755 1
a8755 1
    case 3:                     /* register to register */
d8769 3
a8771 11
static u16(*opcD1_word_operation[])(u16 s, u8 d) =
{
    rol_word,
    ror_word,
    rcl_word,
    rcr_word,
    shl_word,
    shr_word,
    shl_word,           /* sal_byte === shl_byte  by definition */
    sar_word,
};
d8774 3
a8776 11
static u32 (*opcD1_long_operation[])(u32 s, u8 d) =
{
    rol_long,
    ror_long,
    rcl_long,
    rcr_long,
    shl_long,
    shr_long,
    shl_long,           /* sal_byte === shl_byte  by definition */
    sar_long,
};
d8782 2
a8783 1
static void x86emuOp_opcC1_word_RM_MEM(u8 X86EMU_UNUSED(op1))
d8846 2
a8847 1
        } else {
d8872 2
a8873 1
        } else {
d8898 2
a8899 1
        } else {
d8912 1
a8912 1
    case 3:                     /* register to register */
d8921 2
a8922 1
        } else {
d8941 2
a8942 1
static void x86emuOp_ret_near_IMM(u8 X86EMU_UNUSED(op1))
d8950 2
a8951 2
	RETURN_TRACE("RET",M.x86.saved_cs,M.x86.saved_ip);
	TRACE_AND_STEP();
d8962 2
a8963 1
static void x86emuOp_ret_near(u8 X86EMU_UNUSED(op1))
d8967 2
a8968 2
	RETURN_TRACE("RET",M.x86.saved_cs,M.x86.saved_ip);
	TRACE_AND_STEP();
d8978 2
a8979 1
static void x86emuOp_les_R_IMM(u8 X86EMU_UNUSED(op1))
d9016 1
a9016 1
    case 3:                     /* register to register */
d9028 2
a9029 1
static void x86emuOp_lds_R_IMM(u8 X86EMU_UNUSED(op1))
d9066 1
a9066 1
    case 3:                     /* register to register */
d9078 2
a9079 1
static void x86emuOp_mov_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
d9118 1
a9118 1
    case 3:                     /* register to register */
d9134 2
a9135 1
static void x86emuOp_mov_word_RM_IMM(u8 X86EMU_UNUSED(op1))
d9158 2
a9159 1
        } else {
d9180 2
a9181 1
        } else {
d9202 2
a9203 1
        } else {
d9214 1
a9214 1
    case 3:                     /* register to register */
d9216 2
a9217 2
			u32 *destreg;
			u32 imm;
d9224 4
a9227 3
        } else {
			u16 *destreg;
			u16 imm;
d9245 2
a9246 1
static void x86emuOp_enter(u8 X86EMU_UNUSED(op1))
d9248 2
a9249 2
    u16 local,frame_pointer;
    u8  nesting;
d9264 1
a9264 1
            }
d9266 1
a9266 1
        }
d9268 1
a9268 1
    M.x86.R_SP = (u16)(M.x86.R_SP - local);
d9277 2
a9278 1
static void x86emuOp_leave(u8 X86EMU_UNUSED(op1))
d9293 2
a9294 1
static void x86emuOp_ret_far_IMM(u8 X86EMU_UNUSED(op1))
d9302 2
a9303 2
	RETURN_TRACE("RETF",M.x86.saved_cs,M.x86.saved_ip);
	TRACE_AND_STEP();
d9315 2
a9316 1
static void x86emuOp_ret_far(u8 X86EMU_UNUSED(op1))
d9320 2
a9321 2
	RETURN_TRACE("RETF",M.x86.saved_cs,M.x86.saved_ip);
	TRACE_AND_STEP();
d9332 2
a9333 1
static void x86emuOp_int3(u8 X86EMU_UNUSED(op1))
d9339 4
a9342 3
	(*_X86EMU_intrTab[3])(3);
    } else {
        push_word((u16)M.x86.R_FLG);
d9358 2
a9359 1
static void x86emuOp_int_IMM(u8 X86EMU_UNUSED(op1))
d9369 4
a9372 3
	(*_X86EMU_intrTab[intnum])(intnum);
    } else {
        push_word((u16)M.x86.R_FLG);
d9388 2
a9389 1
static void x86emuOp_into(u8 X86EMU_UNUSED(op1))
d9395 5
a9399 4
	if (_X86EMU_intrTab[4]) {
	    (*_X86EMU_intrTab[4])(4);
        } else {
            push_word((u16)M.x86.R_FLG);
d9416 2
a9417 1
static void x86emuOp_iret(u8 X86EMU_UNUSED(op1))
d9435 2
a9436 1
static void x86emuOp_opcD0_byte_RM_1(u8 X86EMU_UNUSED(op1))
d9514 1
a9514 1
    case 3:                     /* register to register */
d9530 2
a9531 1
static void x86emuOp_opcD1_word_RM_1(u8 X86EMU_UNUSED(op1))
d9591 2
a9592 1
        } else {
d9615 2
a9616 1
        } else {
d9639 2
a9640 1
        } else {
d9652 1
a9652 1
    case 3:                     /* register to register */
d9654 2
a9655 2
			u32 destval;
			u32 *destreg;
d9662 4
a9665 3
        } else {
			u16 destval;
			u16 *destreg;
d9683 2
a9684 1
static void x86emuOp_opcD2_byte_RM_CL(u8 X86EMU_UNUSED(op1))
d9764 1
a9764 1
    case 3:                     /* register to register */
d9780 2
a9781 1
static void x86emuOp_opcD3_word_RM_CL(u8 X86EMU_UNUSED(op1))
d9843 2
a9844 1
        } else {
d9867 2
a9868 1
        } else {
d9891 2
a9892 1
        } else {
d9904 1
a9904 1
    case 3:                     /* register to register */
d9912 2
a9913 1
        } else {
d9931 2
a9932 1
static void x86emuOp_aam(u8 X86EMU_UNUSED(op1))
d9938 1
a9938 1
    a = fetch_byte_imm();      /* this is a stupid encoding. */
d9940 2
a9941 2
	/* fix: add base decoding
	   aam_word(u8 val, int base a) */
d9957 2
a9958 1
static void x86emuOp_aad(u8 X86EMU_UNUSED(op1))
d9966 2
a9967 2
	/* fix: add base decoding
	   aad_word(u16 val, int base a) */
d9984 2
a9985 1
static void x86emuOp_xlat(u8 X86EMU_UNUSED(op1))
d9992 1
a9992 1
	addr = (u16)(M.x86.R_BX + (u8)M.x86.R_AL);
d10004 2
a10005 1
static void x86emuOp_loopne(u8 X86EMU_UNUSED(op1))
d10016 1
a10016 1
    if (M.x86.R_CX != 0 && !ACCESS_FLAG(F_ZF))      /* CX != 0 and !ZF */
d10026 2
a10027 1
static void x86emuOp_loope(u8 X86EMU_UNUSED(op1))
d10038 1
a10038 1
    if (M.x86.R_CX != 0 && ACCESS_FLAG(F_ZF))       /* CX != 0 and ZF */
d10048 2
a10049 1
static void x86emuOp_loop(u8 X86EMU_UNUSED(op1))
d10070 2
a10071 1
static void x86emuOp_jcxz(u8 X86EMU_UNUSED(op1))
d10074 1
a10074 1
    s8  offset;
d10079 2
a10080 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + offset);
d10093 2
a10094 1
static void x86emuOp_in_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
d10100 1
a10100 1
	port = (u8) fetch_byte_imm();
d10103 1
a10103 1
    M.x86.R_AL = (*sys_inb)(port);
d10112 2
a10113 1
static void x86emuOp_in_word_AX_IMM(u8 X86EMU_UNUSED(op1))
d10119 1
a10119 1
	port = (u8) fetch_byte_imm();
d10122 2
a10123 1
    } else {
d10128 4
a10131 3
        M.x86.R_EAX = (*sys_inl)(port);
    } else {
        M.x86.R_AX = (*sys_inw)(port);
d10141 2
a10142 1
static void x86emuOp_out_byte_IMM_AL(u8 X86EMU_UNUSED(op1))
d10148 1
a10148 1
	port = (u8) fetch_byte_imm();
d10151 1
a10151 1
    (*sys_outb)(port, M.x86.R_AL);
d10160 2
a10161 1
static void x86emuOp_out_word_IMM_AX(u8 X86EMU_UNUSED(op1))
d10167 1
a10167 1
	port = (u8) fetch_byte_imm();
d10170 2
a10171 1
    } else {
d10176 4
a10179 3
        (*sys_outl)(port, M.x86.R_EAX);
    } else {
        (*sys_outw)(port, M.x86.R_AX);
d10189 2
a10190 1
static void x86emuOp_call_near_IMM(u8 X86EMU_UNUSED(op1))
d10198 10
a10207 9
	ip32 = (s32) fetch_long_imm();
	ip32 += (s16) M.x86.R_IP;    /* CHECK SIGN */
	DECODE_PRINTF2("%04x\n", (u16)ip32);
	CALL_TRACE(M.x86.saved_cs, M.x86.saved_ip, M.x86.R_CS, ip32, "");
    } else {
	ip16 = (s16) fetch_word_imm();
	ip16 += (s16) M.x86.R_IP;    /* CHECK SIGN */
	DECODE_PRINTF2("%04x\n", (u16)ip16);
	CALL_TRACE(M.x86.saved_cs, M.x86.saved_ip, M.x86.R_CS, ip16, "");
d10211 6
a10216 5
	push_long(M.x86.R_EIP);
	M.x86.R_EIP = ip32 & 0xffff;
    } else {
	push_word(M.x86.R_IP);
	M.x86.R_EIP = ip16;
d10226 2
a10227 1
static void x86emuOp_jump_near_IMM(u8 X86EMU_UNUSED(op1))
d10234 12
a10245 11
	ip = (u32)fetch_long_imm();
	ip += (u32)M.x86.R_EIP;
	DECODE_PRINTF2("%08x\n", (u32)ip);
	TRACE_AND_STEP();
	M.x86.R_EIP = (u32)ip;
    } else {
	ip = (s16)fetch_word_imm();
	ip += (s16)M.x86.R_IP;
	DECODE_PRINTF2("%04x\n", (u16)ip);
	TRACE_AND_STEP();
	M.x86.R_IP = (u16)ip;
d10255 2
a10256 1
static void x86emuOp_jump_far_IMM(u8 X86EMU_UNUSED(op1))
d10264 4
a10267 3
	ip = fetch_long_imm();
    } else {
	ip = fetch_word_imm();
d10283 2
a10284 1
static void x86emuOp_jump_byte_IMM(u8 X86EMU_UNUSED(op1))
d10291 2
a10292 2
    offset = (s8)fetch_byte_imm();
    target = (u16)(M.x86.R_IP + offset);
d10304 2
a10305 1
static void x86emuOp_in_byte_AL_DX(u8 X86EMU_UNUSED(op1))
d10310 1
a10310 1
    M.x86.R_AL = (*sys_inb)(M.x86.R_DX);
d10319 2
a10320 1
static void x86emuOp_in_word_AX_DX(u8 X86EMU_UNUSED(op1))
d10325 2
a10326 1
    } else {
d10331 4
a10334 3
        M.x86.R_EAX = (*sys_inl)(M.x86.R_DX);
    } else {
        M.x86.R_AX = (*sys_inw)(M.x86.R_DX);
d10344 2
a10345 1
static void x86emuOp_out_byte_DX_AL(u8 X86EMU_UNUSED(op1))
d10350 1
a10350 1
    (*sys_outb)(M.x86.R_DX, M.x86.R_AL);
d10359 2
a10360 1
static void x86emuOp_out_word_DX_AX(u8 X86EMU_UNUSED(op1))
d10365 2
a10366 1
    } else {
d10371 4
a10374 3
        (*sys_outl)(M.x86.R_DX, M.x86.R_EAX);
    } else {
        (*sys_outw)(M.x86.R_DX, M.x86.R_AX);
d10384 2
a10385 1
static void x86emuOp_lock(u8 X86EMU_UNUSED(op1))
d10400 2
a10401 1
static void x86emuOp_repne(u8 X86EMU_UNUSED(op1))
d10415 2
a10416 1
static void x86emuOp_repe(u8 X86EMU_UNUSED(op1))
d10430 2
a10431 1
static void x86emuOp_halt(u8 X86EMU_UNUSED(op1))
d10445 2
a10446 1
static void x86emuOp_cmc(u8 X86EMU_UNUSED(op1))
d10461 2
a10462 1
static void x86emuOp_opcF6_byte_RM(u8 X86EMU_UNUSED(op1))
d10474 1
a10474 1
    case 0:                     /* mod=00 */
d10476 1
a10476 1
        case 0:         /* test byte imm */
d10542 1
a10542 1
    case 1:                     /* mod=01 */
d10544 1
a10544 1
        case 0:         /* test byte imm */
d10610 1
a10610 1
    case 2:                     /* mod=10 */
d10612 1
a10612 1
        case 0:         /* test byte imm */
d10678 1
a10678 1
    case 3:                     /* mod=11 */
d10680 1
a10680 1
        case 0:         /* test byte imm */
d10712 1
a10712 1
            mul_byte(*destreg);      /*!!!  */
d10746 2
a10747 1
static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
d10757 1
a10757 1
    case 0:                     /* mod=00 */
d10759 1
a10759 1
        case 0:         /* test word imm */
d10761 1
a10761 1
                u32 destval,srcval;
d10771 3
a10773 2
            } else {
                u16 destval,srcval;
d10800 2
a10801 1
            } else {
d10824 2
a10825 1
            } else {
d10847 2
a10848 1
            } else {
d10869 2
a10870 1
            } else {
d10891 2
a10892 1
            } else {
d10913 2
a10914 1
            } else {
d10927 1
a10927 1
    case 1:                     /* mod=01 */
d10929 1
a10929 1
        case 0:         /* test word imm */
d10931 1
a10931 1
                u32 destval,srcval;
d10941 3
a10943 2
            } else {
                u16 destval,srcval;
d10970 2
a10971 1
            } else {
d10994 2
a10995 1
            } else {
d11017 2
a11018 1
            } else {
d11039 2
a11040 1
            } else {
d11061 2
a11062 1
            } else {
d11083 2
a11084 1
            } else {
d11097 1
a11097 1
    case 2:                     /* mod=10 */
d11099 1
a11099 1
        case 0:         /* test word imm */
d11101 1
a11101 1
                u32 destval,srcval;
d11111 3
a11113 2
            } else {
                u16 destval,srcval;
d11140 2
a11141 1
            } else {
d11164 2
a11165 1
            } else {
d11187 2
a11188 1
            } else {
d11209 2
a11210 1
            } else {
d11231 2
a11232 1
            } else {
d11253 2
a11254 1
            } else {
d11267 1
a11267 1
    case 3:                     /* mod=11 */
d11269 1
a11269 1
        case 0:         /* test word imm */
d11281 2
a11282 1
            } else {
d11308 2
a11309 1
            } else {
d11328 2
a11329 1
            } else {
d11347 3
a11349 2
                mul_long(*destreg);      /*!!!  */
            } else {
d11356 1
a11356 1
                mul_word(*destreg);      /*!!!  */
d11368 2
a11369 1
            } else {
d11388 2
a11389 1
            } else {
d11408 2
a11409 1
            } else {
d11430 2
a11431 1
static void x86emuOp_clc(u8 X86EMU_UNUSED(op1))
d11446 2
a11447 1
static void x86emuOp_stc(u8 X86EMU_UNUSED(op1))
d11462 2
a11463 1
static void x86emuOp_cli(u8 X86EMU_UNUSED(op1))
d11478 2
a11479 1
static void x86emuOp_sti(u8 X86EMU_UNUSED(op1))
d11494 2
a11495 1
static void x86emuOp_cld(u8 X86EMU_UNUSED(op1))
d11510 2
a11511 1
static void x86emuOp_std(u8 X86EMU_UNUSED(op1))
d11526 2
a11527 1
static void x86emuOp_opcFE_byte_RM(u8 X86EMU_UNUSED(op1))
d11569 1
a11569 1
        case 0:         /* inc word ptr ... */
d11575 1
a11575 1
        case 1:         /* dec word ptr ... */
d11644 2
a11645 1
static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
d11649 2
a11650 2
	u16 *destreg;
	u16 destval,destval2;
d11666 2
a11667 1
            } else {
d11674 2
a11675 1
            } else {
d11706 1
a11706 1
        case 0:         /* inc word ptr ... */
d11714 2
a11715 1
            } else {
d11724 1
a11724 1
        case 1:         /* dec word ptr ... */
d11732 2
a11733 1
            } else {
d11742 1
a11742 1
        case 2:         /* call word ptr ... */
d11748 1
a11748 1
        case 3:         /* call far ptr ... */
d11757 1
a11757 1
        case 4:         /* jmp word ptr ... */
d11762 1
a11762 1
        case 5:         /* jmp far ptr ... */
d11769 1
a11769 1
        case 6:         /*  push word ptr ... */
d11776 2
a11777 1
            } else {
d11799 2
a11800 1
            } else {
d11817 2
a11818 1
            } else {
d11827 1
a11827 1
        case 2:         /* call word ptr ... */
d11833 1
a11833 1
        case 3:         /* call far ptr ... */
d11842 1
a11842 1
        case 4:         /* jmp word ptr ... */
d11847 1
a11847 1
        case 5:         /* jmp far ptr ... */
d11854 1
a11854 1
        case 6:         /*  push word ptr ... */
d11861 2
a11862 1
            } else {
d11884 2
a11885 1
            } else {
d11902 2
a11903 1
            } else {
d11912 1
a11912 1
        case 2:         /* call word ptr ... */
d11918 1
a11918 1
        case 3:         /* call far ptr ... */
d11927 1
a11927 1
        case 4:         /* jmp word ptr ... */
d11932 1
a11932 1
        case 5:         /* jmp far ptr ... */
d11939 1
a11939 1
        case 6:         /*  push word ptr ... */
d11946 2
a11947 1
            } else {
d11967 2
a11968 1
            } else {
d11985 2
a11986 1
            } else {
d11995 1
a11995 1
        case 2:         /* call word ptr ... */
d12002 1
a12002 1
        case 3:         /* jmp far ptr ... */
d12008 1
a12008 1
        case 4:         /* jmp  ... */
d12014 1
a12014 1
        case 5:         /* jmp far ptr ... */
d12027 2
a12028 1
            } else {
d12047 1
a12047 2
void (*x86emu_optab[256])(u8) =
{
a12055 1

a12063 1

a12071 1

a12079 1

a12087 1

a12095 1

a12103 1

a12111 1

a12119 1

a12127 1

a12135 1

a12143 1

d12146 4
a12149 2
/*  0x62 */ x86emuOp_illegal_op,   /* bound */
/*  0x63 */ x86emuOp_illegal_op,   /* arpl */
a12153 1

a12161 1

a12169 1

a12177 1

a12185 1

a12193 1

a12201 1

a12209 1

a12225 2


a12233 1

a12241 1

a12257 1

d12264 2
a12265 1
/*  0xd6 */ x86emuOp_illegal_op,   /* Undocumented SETALC instruction */
a12274 1

a12282 1

a12290 1

a12298 1

@


1.3
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d7068 1
a7068 1
    u16 farseg, faroff;
d7071 5
a7075 1
	DECODE_PRINTF("CALL\t");
d7078 4
a7081 3
	DECODE_PRINTF2("%04x:", farseg);
	DECODE_PRINTF2("%04x\n", faroff);
	CALL_TRACE(M.x86.saved_cs, M.x86.saved_ip, farseg, faroff, "FAR ");
d7092 6
a7097 2
    push_word(M.x86.R_IP);
    M.x86.R_IP = faroff;
d9682 2
a9683 1
    s16 ip;
d9686 12
a9697 5
	DECODE_PRINTF("CALL\t");
	ip = (s16) fetch_word_imm();
	ip += (s16) M.x86.R_IP;    /* CHECK SIGN */
	DECODE_PRINTF2("%04x\n", (u16)ip);
	CALL_TRACE(M.x86.saved_cs, M.x86.saved_ip, M.x86.R_CS, ip, "");
d9699 7
a9705 2
    push_word(M.x86.R_IP);
    M.x86.R_IP = ip;
d9743 2
a9744 1
    u16 cs, ip;
d9748 5
a9752 1
    ip = fetch_word_imm();
d9757 1
a9757 1
    M.x86.R_IP = ip;
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d9694 1
a9694 1
    int ip;
d9698 13
a9710 5
    ip = (s16)fetch_word_imm();
    ip += (s16)M.x86.R_IP;
    DECODE_PRINTF2("%04x\n", (u16)ip);
    TRACE_AND_STEP();
    M.x86.R_IP = (u16)ip;
@


1.1
log
@Initial revision
@
text
@a6569 1
    u16 *srcreg;
a6571 6
/*
 * TODO: Need to handle address size prefix!
 *
 * lea  eax,[eax+ebx*2] ??
 */
    
d6577 15
a6591 6
        srcreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        destoffset = decode_rm00_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *srcreg = (u16)destoffset;
d6594 15
a6608 6
        srcreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        destoffset = decode_rm01_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *srcreg = (u16)destoffset;
d6611 15
a6625 6
        srcreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        destoffset = decode_rm10_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *srcreg = (u16)destoffset;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
