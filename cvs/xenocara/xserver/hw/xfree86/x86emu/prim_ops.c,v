head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.6
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.5.0.14
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.12
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.10
	OPENBSD_5_0:1.4.0.8
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.4
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.6
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	Te1daavkBLskZ8gc;

1.5
date	2012.06.10.13.21.27;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.28;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.25;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.10.22.31.30;	author mbalmer;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.18.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.18.20;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.58.06;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/****************************************************************************
*
*						Realmode X86 Emulator Library
*
*            	Copyright (C) 1996-1999 SciTech Software, Inc.
* 				     Copyright (C) David Mosberger-Tang
* 					   Copyright (C) 1999 Egbert Eich
*
*  ========================================================================
*
*  Permission to use, copy, modify, distribute, and sell this software and
*  its documentation for any purpose is hereby granted without fee,
*  provided that the above copyright notice appear in all copies and that
*  both that copyright notice and this permission notice appear in
*  supporting documentation, and that the name of the authors not be used
*  in advertising or publicity pertaining to distribution of the software
*  without specific, written prior permission.  The authors makes no
*  representations about the suitability of this software for any purpose.
*  It is provided "as is" without express or implied warranty.
*
*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
*  PERFORMANCE OF THIS SOFTWARE.
*
*  ========================================================================
*
* Language:		ANSI C
* Environment:	Any
* Developer:    Kendall Bennett
*
* Description:  This file contains the code to implement the primitive
*				machine operations used by the emulation code in ops.c
*
* Carry Chain Calculation
*
* This represents a somewhat expensive calculation which is
* apparently required to emulate the setting of the OF and AF flag.
* The latter is not so important, but the former is.  The overflow
* flag is the XOR of the top two bits of the carry chain for an
* addition (similar for subtraction).  Since we do not want to
* simulate the addition in a bitwise manner, we try to calculate the
* carry chain given the two operands and the result.
*
* So, given the following table, which represents the addition of two
* bits, we can derive a formula for the carry chain.
*
* a   b   cin   r     cout
* 0   0   0     0     0
* 0   0   1     1     0
* 0   1   0     1     0
* 0   1   1     0     1
* 1   0   0     1     0
* 1   0   1     0     1
* 1   1   0     0     1
* 1   1   1     1     1
*
* Construction of table for cout:
*
* ab
* r  \  00   01   11  10
* |------------------
* 0  |   0    1    1   1
* 1  |   0    0    1   0
*
* By inspection, one gets:  cc = ab +  r'(a + b)
*
* That represents alot of operations, but NO CHOICE....
*
* Borrow Chain Calculation.
*
* The following table represents the subtraction of two bits, from
* which we can derive a formula for the borrow chain.
*
* a   b   bin   r     bout
* 0   0   0     0     0
* 0   0   1     1     1
* 0   1   0     1     1
* 0   1   1     0     1
* 1   0   0     1     0
* 1   0   1     0     0
* 1   1   0     0     0
* 1   1   1     1     1
*
* Construction of table for cout:
*
* ab
* r  \  00   01   11  10
* |------------------
* 0  |   0    1    0   0
* 1  |   1    1    1   0
*
* By inspection, one gets:  bc = a'b +  r(a' + b)
*
****************************************************************************/

#include <stdlib.h>

#define	PRIM_OPS_NO_REDEFINE_ASM
#include "x86emu/x86emui.h"

#if defined(__GNUC__)
#if defined (__i386__) || defined(__i386) || defined(__AMD64__) || defined(__amd64__)
#include "x86emu/prim_x86_gcc.h"
#endif
#endif

/*------------------------- Global Variables ------------------------------*/

static u32 x86emu_parity_tab[8] = {
    0x96696996,
    0x69969669,
    0x69969669,
    0x96696996,
    0x69969669,
    0x96696996,
    0x96696996,
    0x69969669,
};

#define PARITY(x)   (((x86emu_parity_tab[(x) / 32] >> ((x) % 32)) & 1) == 0)
#define XOR2(x) 	(((x) ^ ((x)>>1)) & 0x1)

/*----------------------------- Implementation ----------------------------*/

/****************************************************************************
REMARKS:
Implements the AAA instruction and side effects.
****************************************************************************/
u16
aaa_word(u16 d)
{
    u16 res;

    if ((d & 0xf) > 0x9 || ACCESS_FLAG(F_AF)) {
        d += 0x6;
        d += 0x100;
        SET_FLAG(F_AF);
        SET_FLAG(F_CF);
    }
    else {
        CLEAR_FLAG(F_CF);
        CLEAR_FLAG(F_AF);
    }
    res = (u16) (d & 0xFF0F);
    CLEAR_FLAG(F_SF);
    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the AAA instruction and side effects.
****************************************************************************/
u16
aas_word(u16 d)
{
    u16 res;

    if ((d & 0xf) > 0x9 || ACCESS_FLAG(F_AF)) {
        d -= 0x6;
        d -= 0x100;
        SET_FLAG(F_AF);
        SET_FLAG(F_CF);
    }
    else {
        CLEAR_FLAG(F_CF);
        CLEAR_FLAG(F_AF);
    }
    res = (u16) (d & 0xFF0F);
    CLEAR_FLAG(F_SF);
    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the AAD instruction and side effects.
****************************************************************************/
u16
aad_word(u16 d)
{
    u16 l;
    u8 hb, lb;

    hb = (u8) ((d >> 8) & 0xff);
    lb = (u8) ((d & 0xff));
    l = (u16) ((lb + 10 * hb) & 0xFF);

    CLEAR_FLAG(F_CF);
    CLEAR_FLAG(F_AF);
    CLEAR_FLAG(F_OF);
    CONDITIONAL_SET_FLAG(l & 0x80, F_SF);
    CONDITIONAL_SET_FLAG(l == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(l & 0xff), F_PF);
    return l;
}

/****************************************************************************
REMARKS:
Implements the AAM instruction and side effects.
****************************************************************************/
u16
aam_word(u8 d)
{
    u16 h, l;

    h = (u16) (d / 10);
    l = (u16) (d % 10);
    l |= (u16) (h << 8);

    CLEAR_FLAG(F_CF);
    CLEAR_FLAG(F_AF);
    CLEAR_FLAG(F_OF);
    CONDITIONAL_SET_FLAG(l & 0x80, F_SF);
    CONDITIONAL_SET_FLAG(l == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(l & 0xff), F_PF);
    return l;
}

/****************************************************************************
REMARKS:
Implements the ADC instruction and side effects.
****************************************************************************/
u8
adc_byte(u8 d, u8 s)
{
    register u32 res;           /* all operands in native machine order */
    register u32 cc;

    if (ACCESS_FLAG(F_CF))
        res = 1 + d + s;
    else
        res = d + s;

    CONDITIONAL_SET_FLAG(res & 0x100, F_CF);
    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the carry chain  SEE NOTE AT TOP. */
    cc = (s & d) | ((~res) & (s | d));
    CONDITIONAL_SET_FLAG(XOR2(cc >> 6), F_OF);
    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
    return (u8) res;
}

/****************************************************************************
REMARKS:
Implements the ADC instruction and side effects.
****************************************************************************/
u16
adc_word(u16 d, u16 s)
{
    register u32 res;           /* all operands in native machine order */
    register u32 cc;

    if (ACCESS_FLAG(F_CF))
        res = 1 + d + s;
    else
        res = d + s;

    CONDITIONAL_SET_FLAG(res & 0x10000, F_CF);
    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the carry chain  SEE NOTE AT TOP. */
    cc = (s & d) | ((~res) & (s | d));
    CONDITIONAL_SET_FLAG(XOR2(cc >> 14), F_OF);
    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
    return (u16) res;
}

/****************************************************************************
REMARKS:
Implements the ADC instruction and side effects.
****************************************************************************/
u32
adc_long(u32 d, u32 s)
{
    register u32 lo;            /* all operands in native machine order */
    register u32 hi;
    register u32 res;
    register u32 cc;

    if (ACCESS_FLAG(F_CF)) {
        lo = 1 + (d & 0xFFFF) + (s & 0xFFFF);
        res = 1 + d + s;
    }
    else {
        lo = (d & 0xFFFF) + (s & 0xFFFF);
        res = d + s;
    }
    hi = (lo >> 16) + (d >> 16) + (s >> 16);

    CONDITIONAL_SET_FLAG(hi & 0x10000, F_CF);
    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the carry chain  SEE NOTE AT TOP. */
    cc = (s & d) | ((~res) & (s | d));
    CONDITIONAL_SET_FLAG(XOR2(cc >> 30), F_OF);
    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the ADD instruction and side effects.
****************************************************************************/
u8
add_byte(u8 d, u8 s)
{
    register u32 res;           /* all operands in native machine order */
    register u32 cc;

    res = d + s;
    CONDITIONAL_SET_FLAG(res & 0x100, F_CF);
    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the carry chain  SEE NOTE AT TOP. */
    cc = (s & d) | ((~res) & (s | d));
    CONDITIONAL_SET_FLAG(XOR2(cc >> 6), F_OF);
    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
    return (u8) res;
}

/****************************************************************************
REMARKS:
Implements the ADD instruction and side effects.
****************************************************************************/
u16
add_word(u16 d, u16 s)
{
    register u32 res;           /* all operands in native machine order */
    register u32 cc;

    res = d + s;
    CONDITIONAL_SET_FLAG(res & 0x10000, F_CF);
    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the carry chain  SEE NOTE AT TOP. */
    cc = (s & d) | ((~res) & (s | d));
    CONDITIONAL_SET_FLAG(XOR2(cc >> 14), F_OF);
    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
    return (u16) res;
}

/****************************************************************************
REMARKS:
Implements the ADD instruction and side effects.
****************************************************************************/
u32
add_long(u32 d, u32 s)
{
    register u32 lo;            /* all operands in native machine order */
    register u32 hi;
    register u32 res;
    register u32 cc;

    lo = (d & 0xFFFF) + (s & 0xFFFF);
    res = d + s;
    hi = (lo >> 16) + (d >> 16) + (s >> 16);

    CONDITIONAL_SET_FLAG(hi & 0x10000, F_CF);
    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the carry chain  SEE NOTE AT TOP. */
    cc = (s & d) | ((~res) & (s | d));
    CONDITIONAL_SET_FLAG(XOR2(cc >> 30), F_OF);
    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);

    return res;
}

/****************************************************************************
REMARKS:
Implements the AND instruction and side effects.
****************************************************************************/
u8
and_byte(u8 d, u8 s)
{
    register u8 res;            /* all operands in native machine order */

    res = d & s;

    /* set the flags  */
    CLEAR_FLAG(F_OF);
    CLEAR_FLAG(F_CF);
    CLEAR_FLAG(F_AF);
    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the AND instruction and side effects.
****************************************************************************/
u16
and_word(u16 d, u16 s)
{
    register u16 res;           /* all operands in native machine order */

    res = d & s;

    /* set the flags  */
    CLEAR_FLAG(F_OF);
    CLEAR_FLAG(F_CF);
    CLEAR_FLAG(F_AF);
    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the AND instruction and side effects.
****************************************************************************/
u32
and_long(u32 d, u32 s)
{
    register u32 res;           /* all operands in native machine order */

    res = d & s;

    /* set the flags  */
    CLEAR_FLAG(F_OF);
    CLEAR_FLAG(F_CF);
    CLEAR_FLAG(F_AF);
    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the CMP instruction and side effects.
****************************************************************************/
u8
cmp_byte(u8 d, u8 s)
{
    register u32 res;           /* all operands in native machine order */
    register u32 bc;

    res = d - s;
    CLEAR_FLAG(F_CF);
    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the borrow chain.  See note at top */
    bc = (res & (~d | s)) | (~d & s);
    CONDITIONAL_SET_FLAG(bc & 0x80, F_CF);
    CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
    return d;
}

/****************************************************************************
REMARKS:
Implements the CMP instruction and side effects.
****************************************************************************/
u16
cmp_word(u16 d, u16 s)
{
    register u32 res;           /* all operands in native machine order */
    register u32 bc;

    res = d - s;
    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the borrow chain.  See note at top */
    bc = (res & (~d | s)) | (~d & s);
    CONDITIONAL_SET_FLAG(bc & 0x8000, F_CF);
    CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
    return d;
}

/****************************************************************************
REMARKS:
Implements the CMP instruction and side effects.
****************************************************************************/
u32
cmp_long(u32 d, u32 s)
{
    register u32 res;           /* all operands in native machine order */
    register u32 bc;

    res = d - s;
    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the borrow chain.  See note at top */
    bc = (res & (~d | s)) | (~d & s);
    CONDITIONAL_SET_FLAG(bc & 0x80000000, F_CF);
    CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
    return d;
}

/****************************************************************************
REMARKS:
Implements the DAA instruction and side effects.
****************************************************************************/
u8
daa_byte(u8 d)
{
    u32 res = d;

    if ((d & 0xf) > 9 || ACCESS_FLAG(F_AF)) {
        res += 6;
        SET_FLAG(F_AF);
    }
    if (res > 0x9F || ACCESS_FLAG(F_CF)) {
        res += 0x60;
        SET_FLAG(F_CF);
    }
    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
    CONDITIONAL_SET_FLAG((res & 0xFF) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    return (u8) res;
}

/****************************************************************************
REMARKS:
Implements the DAS instruction and side effects.
****************************************************************************/
u8
das_byte(u8 d)
{
    if ((d & 0xf) > 9 || ACCESS_FLAG(F_AF)) {
        d -= 6;
        SET_FLAG(F_AF);
    }
    if (d > 0x9F || ACCESS_FLAG(F_CF)) {
        d -= 0x60;
        SET_FLAG(F_CF);
    }
    CONDITIONAL_SET_FLAG(d & 0x80, F_SF);
    CONDITIONAL_SET_FLAG(d == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(d & 0xff), F_PF);
    return d;
}

/****************************************************************************
REMARKS:
Implements the DEC instruction and side effects.
****************************************************************************/
u8
dec_byte(u8 d)
{
    register u32 res;           /* all operands in native machine order */
    register u32 bc;

    res = d - 1;
    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the borrow chain.  See note at top */
    /* based on sub_byte, uses s==1.  */
    bc = (res & (~d | 1)) | (~d & 1);
    /* carry flag unchanged */
    CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
    return (u8) res;
}

/****************************************************************************
REMARKS:
Implements the DEC instruction and side effects.
****************************************************************************/
u16
dec_word(u16 d)
{
    register u32 res;           /* all operands in native machine order */
    register u32 bc;

    res = d - 1;
    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the borrow chain.  See note at top */
    /* based on the sub_byte routine, with s==1 */
    bc = (res & (~d | 1)) | (~d & 1);
    /* carry flag unchanged */
    CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
    return (u16) res;
}

/****************************************************************************
REMARKS:
Implements the DEC instruction and side effects.
****************************************************************************/
u32
dec_long(u32 d)
{
    register u32 res;           /* all operands in native machine order */
    register u32 bc;

    res = d - 1;

    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the borrow chain.  See note at top */
    bc = (res & (~d | 1)) | (~d & 1);
    /* carry flag unchanged */
    CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the INC instruction and side effects.
****************************************************************************/
u8
inc_byte(u8 d)
{
    register u32 res;           /* all operands in native machine order */
    register u32 cc;

    res = d + 1;
    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the carry chain  SEE NOTE AT TOP. */
    cc = ((1 & d) | (~res)) & (1 | d);
    CONDITIONAL_SET_FLAG(XOR2(cc >> 6), F_OF);
    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
    return (u8) res;
}

/****************************************************************************
REMARKS:
Implements the INC instruction and side effects.
****************************************************************************/
u16
inc_word(u16 d)
{
    register u32 res;           /* all operands in native machine order */
    register u32 cc;

    res = d + 1;
    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the carry chain  SEE NOTE AT TOP. */
    cc = (1 & d) | ((~res) & (1 | d));
    CONDITIONAL_SET_FLAG(XOR2(cc >> 14), F_OF);
    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
    return (u16) res;
}

/****************************************************************************
REMARKS:
Implements the INC instruction and side effects.
****************************************************************************/
u32
inc_long(u32 d)
{
    register u32 res;           /* all operands in native machine order */
    register u32 cc;

    res = d + 1;
    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the carry chain  SEE NOTE AT TOP. */
    cc = (1 & d) | ((~res) & (1 | d));
    CONDITIONAL_SET_FLAG(XOR2(cc >> 30), F_OF);
    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the OR instruction and side effects.
****************************************************************************/
u8
or_byte(u8 d, u8 s)
{
    register u8 res;            /* all operands in native machine order */

    res = d | s;
    CLEAR_FLAG(F_OF);
    CLEAR_FLAG(F_CF);
    CLEAR_FLAG(F_AF);
    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the OR instruction and side effects.
****************************************************************************/
u16
or_word(u16 d, u16 s)
{
    register u16 res;           /* all operands in native machine order */

    res = d | s;
    /* set the carry flag to be bit 8 */
    CLEAR_FLAG(F_OF);
    CLEAR_FLAG(F_CF);
    CLEAR_FLAG(F_AF);
    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the OR instruction and side effects.
****************************************************************************/
u32
or_long(u32 d, u32 s)
{
    register u32 res;           /* all operands in native machine order */

    res = d | s;

    /* set the carry flag to be bit 8 */
    CLEAR_FLAG(F_OF);
    CLEAR_FLAG(F_CF);
    CLEAR_FLAG(F_AF);
    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the OR instruction and side effects.
****************************************************************************/
u8
neg_byte(u8 s)
{
    register u8 res;
    register u8 bc;

    CONDITIONAL_SET_FLAG(s != 0, F_CF);
    res = (u8) - s;
    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
    CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
    /* calculate the borrow chain --- modified such that d=0.
       substitutiing d=0 into     bc= res&(~d|s)|(~d&s);
       (the one used for sub) and simplifying, since ~d=0xff...,
       ~d|s == 0xffff..., and res&0xfff... == res.  Similarly
       ~d&s == s.  So the simplified result is: */
    bc = res | s;
    CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the OR instruction and side effects.
****************************************************************************/
u16
neg_word(u16 s)
{
    register u16 res;
    register u16 bc;

    CONDITIONAL_SET_FLAG(s != 0, F_CF);
    res = (u16) - s;
    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the borrow chain --- modified such that d=0.
       substitutiing d=0 into     bc= res&(~d|s)|(~d&s);
       (the one used for sub) and simplifying, since ~d=0xff...,
       ~d|s == 0xffff..., and res&0xfff... == res.  Similarly
       ~d&s == s.  So the simplified result is: */
    bc = res | s;
    CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the OR instruction and side effects.
****************************************************************************/
u32
neg_long(u32 s)
{
    register u32 res;
    register u32 bc;

    CONDITIONAL_SET_FLAG(s != 0, F_CF);
    res = (u32) - s;
    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the borrow chain --- modified such that d=0.
       substitutiing d=0 into     bc= res&(~d|s)|(~d&s);
       (the one used for sub) and simplifying, since ~d=0xff...,
       ~d|s == 0xffff..., and res&0xfff... == res.  Similarly
       ~d&s == s.  So the simplified result is: */
    bc = res | s;
    CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the NOT instruction and side effects.
****************************************************************************/
u8
not_byte(u8 s)
{
    return ~s;
}

/****************************************************************************
REMARKS:
Implements the NOT instruction and side effects.
****************************************************************************/
u16
not_word(u16 s)
{
    return ~s;
}

/****************************************************************************
REMARKS:
Implements the NOT instruction and side effects.
****************************************************************************/
u32
not_long(u32 s)
{
    return ~s;
}

/****************************************************************************
REMARKS:
Implements the RCL instruction and side effects.
****************************************************************************/
u8
rcl_byte(u8 d, u8 s)
{
    register unsigned int res, cnt, mask, cf;

    /* s is the rotate distance.  It varies from 0 - 8. */
    /* have

       CF  B_7 B_6 B_5 B_4 B_3 B_2 B_1 B_0

       want to rotate through the carry by "s" bits.  We could
       loop, but that's inefficient.  So the width is 9,
       and we split into three parts:

       The new carry flag   (was B_n)
       the stuff in B_n-1 .. B_0
       the stuff in B_7 .. B_n+1

       The new rotate is done mod 9, and given this,
       for a rotation of n bits (mod 9) the new carry flag is
       then located n bits from the MSB.  The low part is
       then shifted up cnt bits, and the high part is or'd
       in.  Using CAPS for new values, and lowercase for the
       original values, this can be expressed as:

       IF n > 0
       1) CF <-  b_(8-n)
       2) B_(7) .. B_(n)  <-  b_(8-(n+1)) .. b_0
       3) B_(n-1) <- cf
       4) B_(n-2) .. B_0 <-  b_7 .. b_(8-(n-1))
     */
    res = d;
    if ((cnt = s % 9) != 0) {
        /* extract the new CARRY FLAG. */
        /* CF <-  b_(8-n)             */
        cf = (d >> (8 - cnt)) & 0x1;

        /* get the low stuff which rotated
           into the range B_7 .. B_cnt */
        /* B_(7) .. B_(n)  <-  b_(8-(n+1)) .. b_0  */
        /* note that the right hand side done by the mask */
        res = (d << cnt) & 0xff;

        /* now the high stuff which rotated around
           into the positions B_cnt-2 .. B_0 */
        /* B_(n-2) .. B_0 <-  b_7 .. b_(8-(n-1)) */
        /* shift it downward, 7-(n-2) = 9-n positions.
           and mask off the result before or'ing in.
         */
        mask = (1 << (cnt - 1)) - 1;
        res |= (d >> (9 - cnt)) & mask;

        /* if the carry flag was set, or it in.  */
        if (ACCESS_FLAG(F_CF)) {        /* carry flag is set */
            /*  B_(n-1) <- cf */
            res |= 1 << (cnt - 1);
        }
        /* set the new carry flag, based on the variable "cf" */
        CONDITIONAL_SET_FLAG(cf, F_CF);
        /* OVERFLOW is set *IFF* cnt==1, then it is the
           xor of CF and the most significant bit.  Blecck. */
        /* parenthesized this expression since it appears to
           be causing OF to be misset */
        CONDITIONAL_SET_FLAG(cnt == 1 && XOR2(cf + ((res >> 6) & 0x2)), F_OF);

    }
    return (u8) res;
}

/****************************************************************************
REMARKS:
Implements the RCL instruction and side effects.
****************************************************************************/
u16
rcl_word(u16 d, u8 s)
{
    register unsigned int res, cnt, mask, cf;

    res = d;
    if ((cnt = s % 17) != 0) {
        cf = (d >> (16 - cnt)) & 0x1;
        res = (d << cnt) & 0xffff;
        mask = (1 << (cnt - 1)) - 1;
        res |= (d >> (17 - cnt)) & mask;
        if (ACCESS_FLAG(F_CF)) {
            res |= 1 << (cnt - 1);
        }
        CONDITIONAL_SET_FLAG(cf, F_CF);
        CONDITIONAL_SET_FLAG(cnt == 1 && XOR2(cf + ((res >> 14) & 0x2)), F_OF);
    }
    return (u16) res;
}

/****************************************************************************
REMARKS:
Implements the RCL instruction and side effects.
****************************************************************************/
u32
rcl_long(u32 d, u8 s)
{
    register u32 res, cnt, mask, cf;

    res = d;
    if ((cnt = s % 33) != 0) {
        cf = (d >> (32 - cnt)) & 0x1;
        res = (d << cnt) & 0xffffffff;
        mask = (1 << (cnt - 1)) - 1;
        res |= (d >> (33 - cnt)) & mask;
        if (ACCESS_FLAG(F_CF)) {        /* carry flag is set */
            res |= 1 << (cnt - 1);
        }
        CONDITIONAL_SET_FLAG(cf, F_CF);
        CONDITIONAL_SET_FLAG(cnt == 1 && XOR2(cf + ((res >> 30) & 0x2)), F_OF);
    }
    return res;
}

/****************************************************************************
REMARKS:
Implements the RCR instruction and side effects.
****************************************************************************/
u8
rcr_byte(u8 d, u8 s)
{
    u32 res, cnt;
    u32 mask, cf, ocf = 0;

    /* rotate right through carry */
    /*
       s is the rotate distance.  It varies from 0 - 8.
       d is the byte object rotated.

       have

       CF  B_7 B_6 B_5 B_4 B_3 B_2 B_1 B_0

       The new rotate is done mod 9, and given this,
       for a rotation of n bits (mod 9) the new carry flag is
       then located n bits from the LSB.  The low part is
       then shifted up cnt bits, and the high part is or'd
       in.  Using CAPS for new values, and lowercase for the
       original values, this can be expressed as:

       IF n > 0
       1) CF <-  b_(n-1)
       2) B_(8-(n+1)) .. B_(0)  <-  b_(7) .. b_(n)
       3) B_(8-n) <- cf
       4) B_(7) .. B_(8-(n-1)) <-  b_(n-2) .. b_(0)
     */
    res = d;
    if ((cnt = s % 9) != 0) {
        /* extract the new CARRY FLAG. */
        /* CF <-  b_(n-1)              */
        if (cnt == 1) {
            cf = d & 0x1;
            /* note hackery here.  Access_flag(..) evaluates to either
               0 if flag not set
               non-zero if flag is set.
               doing access_flag(..) != 0 casts that into either
               0..1 in any representation of the flags register
               (i.e. packed bit array or unpacked.)
             */
            ocf = ACCESS_FLAG(F_CF) != 0;
        }
        else
            cf = (d >> (cnt - 1)) & 0x1;

        /* B_(8-(n+1)) .. B_(0)  <-  b_(7) .. b_n  */
        /* note that the right hand side done by the mask
           This is effectively done by shifting the
           object to the right.  The result must be masked,
           in case the object came in and was treated
           as a negative number.  Needed??? */

        mask = (1 << (8 - cnt)) - 1;
        res = (d >> cnt) & mask;

        /* now the high stuff which rotated around
           into the positions B_cnt-2 .. B_0 */
        /* B_(7) .. B_(8-(n-1)) <-  b_(n-2) .. b_(0) */
        /* shift it downward, 7-(n-2) = 9-n positions.
           and mask off the result before or'ing in.
         */
        res |= (d << (9 - cnt));

        /* if the carry flag was set, or it in.  */
        if (ACCESS_FLAG(F_CF)) {        /* carry flag is set */
            /*  B_(8-n) <- cf */
            res |= 1 << (8 - cnt);
        }
        /* set the new carry flag, based on the variable "cf" */
        CONDITIONAL_SET_FLAG(cf, F_CF);
        /* OVERFLOW is set *IFF* cnt==1, then it is the
           xor of CF and the most significant bit.  Blecck. */
        /* parenthesized... */
        if (cnt == 1) {
            CONDITIONAL_SET_FLAG(XOR2(ocf + ((d >> 6) & 0x2)), F_OF);
        }
    }
    return (u8) res;
}

/****************************************************************************
REMARKS:
Implements the RCR instruction and side effects.
****************************************************************************/
u16
rcr_word(u16 d, u8 s)
{
    u32 res, cnt;
    u32 mask, cf, ocf = 0;

    /* rotate right through carry */
    res = d;
    if ((cnt = s % 17) != 0) {
        if (cnt == 1) {
            cf = d & 0x1;
            ocf = ACCESS_FLAG(F_CF) != 0;
        }
        else
            cf = (d >> (cnt - 1)) & 0x1;
        mask = (1 << (16 - cnt)) - 1;
        res = (d >> cnt) & mask;
        res |= (d << (17 - cnt));
        if (ACCESS_FLAG(F_CF)) {
            res |= 1 << (16 - cnt);
        }
        CONDITIONAL_SET_FLAG(cf, F_CF);
        if (cnt == 1) {
            CONDITIONAL_SET_FLAG(XOR2(ocf + ((d >> 14) & 0x2)), F_OF);
        }
    }
    return (u16) res;
}

/****************************************************************************
REMARKS:
Implements the RCR instruction and side effects.
****************************************************************************/
u32
rcr_long(u32 d, u8 s)
{
    u32 res, cnt;
    u32 mask, cf, ocf = 0;

    /* rotate right through carry */
    res = d;
    if ((cnt = s % 33) != 0) {
        if (cnt == 1) {
            cf = d & 0x1;
            ocf = ACCESS_FLAG(F_CF) != 0;
        }
        else
            cf = (d >> (cnt - 1)) & 0x1;
        mask = (1 << (32 - cnt)) - 1;
        res = (d >> cnt) & mask;
        if (cnt != 1)
            res |= (d << (33 - cnt));
        if (ACCESS_FLAG(F_CF)) {        /* carry flag is set */
            res |= 1 << (32 - cnt);
        }
        CONDITIONAL_SET_FLAG(cf, F_CF);
        if (cnt == 1) {
            CONDITIONAL_SET_FLAG(XOR2(ocf + ((d >> 30) & 0x2)), F_OF);
        }
    }
    return res;
}

/****************************************************************************
REMARKS:
Implements the ROL instruction and side effects.
****************************************************************************/
u8
rol_byte(u8 d, u8 s)
{
    register unsigned int res, cnt, mask;

    /* rotate left */
    /*
       s is the rotate distance.  It varies from 0 - 8.
       d is the byte object rotated.

       have

       CF  B_7 ... B_0

       The new rotate is done mod 8.
       Much simpler than the "rcl" or "rcr" operations.

       IF n > 0
       1) B_(7) .. B_(n)  <-  b_(8-(n+1)) .. b_(0)
       2) B_(n-1) .. B_(0) <-  b_(7) .. b_(8-n)
     */
    res = d;
    if ((cnt = s % 8) != 0) {
        /* B_(7) .. B_(n)  <-  b_(8-(n+1)) .. b_(0) */
        res = (d << cnt);

        /* B_(n-1) .. B_(0) <-  b_(7) .. b_(8-n) */
        mask = (1 << cnt) - 1;
        res |= (d >> (8 - cnt)) & mask;

        /* set the new carry flag, Note that it is the low order
           bit of the result!!!                               */
        CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
        /* OVERFLOW is set *IFF* s==1, then it is the
           xor of CF and the most significant bit.  Blecck. */
        CONDITIONAL_SET_FLAG(s == 1 &&
                             XOR2((res & 0x1) + ((res >> 6) & 0x2)), F_OF);
    }
    if (s != 0) {
        /* set the new carry flag, Note that it is the low order
           bit of the result!!!                               */
        CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
    }
    return (u8) res;
}

/****************************************************************************
REMARKS:
Implements the ROL instruction and side effects.
****************************************************************************/
u16
rol_word(u16 d, u8 s)
{
    register unsigned int res, cnt, mask;

    res = d;
    if ((cnt = s % 16) != 0) {
        res = (d << cnt);
        mask = (1 << cnt) - 1;
        res |= (d >> (16 - cnt)) & mask;
        CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
        CONDITIONAL_SET_FLAG(s == 1 &&
                             XOR2((res & 0x1) + ((res >> 14) & 0x2)), F_OF);
    }
    if (s != 0) {
        /* set the new carry flag, Note that it is the low order
           bit of the result!!!                               */
        CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
    }
    return (u16) res;
}

/****************************************************************************
REMARKS:
Implements the ROL instruction and side effects.
****************************************************************************/
u32
rol_long(u32 d, u8 s)
{
    register u32 res, cnt, mask;

    res = d;
    if ((cnt = s % 32) != 0) {
        res = (d << cnt);
        mask = (1 << cnt) - 1;
        res |= (d >> (32 - cnt)) & mask;
        CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
        CONDITIONAL_SET_FLAG(s == 1 &&
                             XOR2((res & 0x1) + ((res >> 30) & 0x2)), F_OF);
    }
    if (s != 0) {
        /* set the new carry flag, Note that it is the low order
           bit of the result!!!                               */
        CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
    }
    return res;
}

/****************************************************************************
REMARKS:
Implements the ROR instruction and side effects.
****************************************************************************/
u8
ror_byte(u8 d, u8 s)
{
    register unsigned int res, cnt, mask;

    /* rotate right */
    /*
       s is the rotate distance.  It varies from 0 - 8.
       d is the byte object rotated.

       have

       B_7 ... B_0

       The rotate is done mod 8.

       IF n > 0
       1) B_(8-(n+1)) .. B_(0)  <-  b_(7) .. b_(n)
       2) B_(7) .. B_(8-n) <-  b_(n-1) .. b_(0)
     */
    res = d;
    if ((cnt = s % 8) != 0) {   /* not a typo, do nada if cnt==0 */
        /* B_(7) .. B_(8-n) <-  b_(n-1) .. b_(0) */
        res = (d << (8 - cnt));

        /* B_(8-(n+1)) .. B_(0)  <-  b_(7) .. b_(n) */
        mask = (1 << (8 - cnt)) - 1;
        res |= (d >> (cnt)) & mask;

        /* set the new carry flag, Note that it is the low order
           bit of the result!!!                               */
        CONDITIONAL_SET_FLAG(res & 0x80, F_CF);
        /* OVERFLOW is set *IFF* s==1, then it is the
           xor of the two most significant bits.  Blecck. */
        CONDITIONAL_SET_FLAG(s == 1 && XOR2(res >> 6), F_OF);
    }
    else if (s != 0) {
        /* set the new carry flag, Note that it is the low order
           bit of the result!!!                               */
        CONDITIONAL_SET_FLAG(res & 0x80, F_CF);
    }
    return (u8) res;
}

/****************************************************************************
REMARKS:
Implements the ROR instruction and side effects.
****************************************************************************/
u16
ror_word(u16 d, u8 s)
{
    register unsigned int res, cnt, mask;

    res = d;
    if ((cnt = s % 16) != 0) {
        res = (d << (16 - cnt));
        mask = (1 << (16 - cnt)) - 1;
        res |= (d >> (cnt)) & mask;
        CONDITIONAL_SET_FLAG(res & 0x8000, F_CF);
        CONDITIONAL_SET_FLAG(s == 1 && XOR2(res >> 14), F_OF);
    }
    else if (s != 0) {
        /* set the new carry flag, Note that it is the low order
           bit of the result!!!                               */
        CONDITIONAL_SET_FLAG(res & 0x8000, F_CF);
    }
    return (u16) res;
}

/****************************************************************************
REMARKS:
Implements the ROR instruction and side effects.
****************************************************************************/
u32
ror_long(u32 d, u8 s)
{
    register u32 res, cnt, mask;

    res = d;
    if ((cnt = s % 32) != 0) {
        res = (d << (32 - cnt));
        mask = (1 << (32 - cnt)) - 1;
        res |= (d >> (cnt)) & mask;
        CONDITIONAL_SET_FLAG(res & 0x80000000, F_CF);
        CONDITIONAL_SET_FLAG(s == 1 && XOR2(res >> 30), F_OF);
    }
    else if (s != 0) {
        /* set the new carry flag, Note that it is the low order
           bit of the result!!!                               */
        CONDITIONAL_SET_FLAG(res & 0x80000000, F_CF);
    }
    return res;
}

/****************************************************************************
REMARKS:
Implements the SHL instruction and side effects.
****************************************************************************/
u8
shl_byte(u8 d, u8 s)
{
    unsigned int cnt, res, cf;

    if (s < 8) {
        cnt = s % 8;

        /* last bit shifted out goes into carry flag */
        if (cnt > 0) {
            res = d << cnt;
            cf = d & (1 << (8 - cnt));
            CONDITIONAL_SET_FLAG(cf, F_CF);
            CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
            CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
        }
        else {
            res = (u8) d;
        }

        if (cnt == 1) {
            /* Needs simplification. */
            CONDITIONAL_SET_FLAG((((res & 0x80) == 0x80) ^
                                  (ACCESS_FLAG(F_CF) != 0)),
                                 /* was (M.x86.R_FLG&F_CF)==F_CF)), */
                                 F_OF);
        }
        else {
            CLEAR_FLAG(F_OF);
        }
    }
    else {
        res = 0;
        CONDITIONAL_SET_FLAG((d << (s - 1)) & 0x80, F_CF);
        CLEAR_FLAG(F_OF);
        CLEAR_FLAG(F_SF);
        SET_FLAG(F_PF);
        SET_FLAG(F_ZF);
    }
    return (u8) res;
}

/****************************************************************************
REMARKS:
Implements the SHL instruction and side effects.
****************************************************************************/
u16
shl_word(u16 d, u8 s)
{
    unsigned int cnt, res, cf;

    if (s < 16) {
        cnt = s % 16;
        if (cnt > 0) {
            res = d << cnt;
            cf = d & (1 << (16 - cnt));
            CONDITIONAL_SET_FLAG(cf, F_CF);
            CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
            CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
        }
        else {
            res = (u16) d;
        }

        if (cnt == 1) {
            CONDITIONAL_SET_FLAG((((res & 0x8000) == 0x8000) ^
                                  (ACCESS_FLAG(F_CF) != 0)), F_OF);
        }
        else {
            CLEAR_FLAG(F_OF);
        }
    }
    else {
        res = 0;
        CONDITIONAL_SET_FLAG((d << (s - 1)) & 0x8000, F_CF);
        CLEAR_FLAG(F_OF);
        CLEAR_FLAG(F_SF);
        SET_FLAG(F_PF);
        SET_FLAG(F_ZF);
    }
    return (u16) res;
}

/****************************************************************************
REMARKS:
Implements the SHL instruction and side effects.
****************************************************************************/
u32
shl_long(u32 d, u8 s)
{
    unsigned int cnt, res, cf;

    if (s < 32) {
        cnt = s % 32;
        if (cnt > 0) {
            res = d << cnt;
            cf = d & (1 << (32 - cnt));
            CONDITIONAL_SET_FLAG(cf, F_CF);
            CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
            CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
        }
        else {
            res = d;
        }
        if (cnt == 1) {
            CONDITIONAL_SET_FLAG((((res & 0x80000000) == 0x80000000) ^
                                  (ACCESS_FLAG(F_CF) != 0)), F_OF);
        }
        else {
            CLEAR_FLAG(F_OF);
        }
    }
    else {
        res = 0;
        CONDITIONAL_SET_FLAG((d << (s - 1)) & 0x80000000, F_CF);
        CLEAR_FLAG(F_OF);
        CLEAR_FLAG(F_SF);
        SET_FLAG(F_PF);
        SET_FLAG(F_ZF);
    }
    return res;
}

/****************************************************************************
REMARKS:
Implements the SHR instruction and side effects.
****************************************************************************/
u8
shr_byte(u8 d, u8 s)
{
    unsigned int cnt, res, cf;

    if (s < 8) {
        cnt = s % 8;
        if (cnt > 0) {
            cf = d & (1 << (cnt - 1));
            res = d >> cnt;
            CONDITIONAL_SET_FLAG(cf, F_CF);
            CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
            CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
        }
        else {
            res = (u8) d;
        }

        if (cnt == 1) {
            CONDITIONAL_SET_FLAG(XOR2(res >> 6), F_OF);
        }
        else {
            CLEAR_FLAG(F_OF);
        }
    }
    else {
        res = 0;
        CONDITIONAL_SET_FLAG((d >> (s - 1)) & 0x1, F_CF);
        CLEAR_FLAG(F_OF);
        CLEAR_FLAG(F_SF);
        SET_FLAG(F_PF);
        SET_FLAG(F_ZF);
    }
    return (u8) res;
}

/****************************************************************************
REMARKS:
Implements the SHR instruction and side effects.
****************************************************************************/
u16
shr_word(u16 d, u8 s)
{
    unsigned int cnt, res, cf;

    if (s < 16) {
        cnt = s % 16;
        if (cnt > 0) {
            cf = d & (1 << (cnt - 1));
            res = d >> cnt;
            CONDITIONAL_SET_FLAG(cf, F_CF);
            CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
            CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
        }
        else {
            res = d;
        }

        if (cnt == 1) {
            CONDITIONAL_SET_FLAG(XOR2(res >> 14), F_OF);
        }
        else {
            CLEAR_FLAG(F_OF);
        }
    }
    else {
        res = 0;
        CLEAR_FLAG(F_CF);
        CLEAR_FLAG(F_OF);
        SET_FLAG(F_ZF);
        CLEAR_FLAG(F_SF);
        CLEAR_FLAG(F_PF);
    }
    return (u16) res;
}

/****************************************************************************
REMARKS:
Implements the SHR instruction and side effects.
****************************************************************************/
u32
shr_long(u32 d, u8 s)
{
    unsigned int cnt, res, cf;

    if (s < 32) {
        cnt = s % 32;
        if (cnt > 0) {
            cf = d & (1 << (cnt - 1));
            res = d >> cnt;
            CONDITIONAL_SET_FLAG(cf, F_CF);
            CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
            CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
        }
        else {
            res = d;
        }
        if (cnt == 1) {
            CONDITIONAL_SET_FLAG(XOR2(res >> 30), F_OF);
        }
        else {
            CLEAR_FLAG(F_OF);
        }
    }
    else {
        res = 0;
        CLEAR_FLAG(F_CF);
        CLEAR_FLAG(F_OF);
        SET_FLAG(F_ZF);
        CLEAR_FLAG(F_SF);
        CLEAR_FLAG(F_PF);
    }
    return res;
}

/****************************************************************************
REMARKS:
Implements the SAR instruction and side effects.
****************************************************************************/
u8
sar_byte(u8 d, u8 s)
{
    unsigned int cnt, res, cf, mask, sf;

    res = d;
    sf = d & 0x80;
    cnt = s % 8;
    if (cnt > 0 && cnt < 8) {
        mask = (1 << (8 - cnt)) - 1;
        cf = d & (1 << (cnt - 1));
        res = (d >> cnt) & mask;
        CONDITIONAL_SET_FLAG(cf, F_CF);
        if (sf) {
            res |= ~mask;
        }
        CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
        CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
        CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
    }
    else if (cnt >= 8) {
        if (sf) {
            res = 0xff;
            SET_FLAG(F_CF);
            CLEAR_FLAG(F_ZF);
            SET_FLAG(F_SF);
            SET_FLAG(F_PF);
        }
        else {
            res = 0;
            CLEAR_FLAG(F_CF);
            SET_FLAG(F_ZF);
            CLEAR_FLAG(F_SF);
            CLEAR_FLAG(F_PF);
        }
    }
    return (u8) res;
}

/****************************************************************************
REMARKS:
Implements the SAR instruction and side effects.
****************************************************************************/
u16
sar_word(u16 d, u8 s)
{
    unsigned int cnt, res, cf, mask, sf;

    sf = d & 0x8000;
    cnt = s % 16;
    res = d;
    if (cnt > 0 && cnt < 16) {
        mask = (1 << (16 - cnt)) - 1;
        cf = d & (1 << (cnt - 1));
        res = (d >> cnt) & mask;
        CONDITIONAL_SET_FLAG(cf, F_CF);
        if (sf) {
            res |= ~mask;
        }
        CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
        CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
        CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    }
    else if (cnt >= 16) {
        if (sf) {
            res = 0xffff;
            SET_FLAG(F_CF);
            CLEAR_FLAG(F_ZF);
            SET_FLAG(F_SF);
            SET_FLAG(F_PF);
        }
        else {
            res = 0;
            CLEAR_FLAG(F_CF);
            SET_FLAG(F_ZF);
            CLEAR_FLAG(F_SF);
            CLEAR_FLAG(F_PF);
        }
    }
    return (u16) res;
}

/****************************************************************************
REMARKS:
Implements the SAR instruction and side effects.
****************************************************************************/
u32
sar_long(u32 d, u8 s)
{
    u32 cnt, res, cf, mask, sf;

    sf = d & 0x80000000;
    cnt = s % 32;
    res = d;
    if (cnt > 0 && cnt < 32) {
        mask = (1 << (32 - cnt)) - 1;
        cf = d & (1 << (cnt - 1));
        res = (d >> cnt) & mask;
        CONDITIONAL_SET_FLAG(cf, F_CF);
        if (sf) {
            res |= ~mask;
        }
        CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
        CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
        CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    }
    else if (cnt >= 32) {
        if (sf) {
            res = 0xffffffff;
            SET_FLAG(F_CF);
            CLEAR_FLAG(F_ZF);
            SET_FLAG(F_SF);
            SET_FLAG(F_PF);
        }
        else {
            res = 0;
            CLEAR_FLAG(F_CF);
            SET_FLAG(F_ZF);
            CLEAR_FLAG(F_SF);
            CLEAR_FLAG(F_PF);
        }
    }
    return res;
}

/****************************************************************************
REMARKS:
Implements the SHLD instruction and side effects.
****************************************************************************/
u16
shld_word(u16 d, u16 fill, u8 s)
{
    unsigned int cnt, res, cf;

    if (s < 16) {
        cnt = s % 16;
        if (cnt > 0) {
            res = (d << cnt) | (fill >> (16 - cnt));
            cf = d & (1 << (16 - cnt));
            CONDITIONAL_SET_FLAG(cf, F_CF);
            CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
            CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
        }
        else {
            res = d;
        }
        if (cnt == 1) {
            CONDITIONAL_SET_FLAG((((res & 0x8000) == 0x8000) ^
                                  (ACCESS_FLAG(F_CF) != 0)), F_OF);
        }
        else {
            CLEAR_FLAG(F_OF);
        }
    }
    else {
        res = 0;
        CONDITIONAL_SET_FLAG((d << (s - 1)) & 0x8000, F_CF);
        CLEAR_FLAG(F_OF);
        CLEAR_FLAG(F_SF);
        SET_FLAG(F_PF);
        SET_FLAG(F_ZF);
    }
    return (u16) res;
}

/****************************************************************************
REMARKS:
Implements the SHLD instruction and side effects.
****************************************************************************/
u32
shld_long(u32 d, u32 fill, u8 s)
{
    unsigned int cnt, res, cf;

    if (s < 32) {
        cnt = s % 32;
        if (cnt > 0) {
            res = (d << cnt) | (fill >> (32 - cnt));
            cf = d & (1 << (32 - cnt));
            CONDITIONAL_SET_FLAG(cf, F_CF);
            CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
            CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
        }
        else {
            res = d;
        }
        if (cnt == 1) {
            CONDITIONAL_SET_FLAG((((res & 0x80000000) == 0x80000000) ^
                                  (ACCESS_FLAG(F_CF) != 0)), F_OF);
        }
        else {
            CLEAR_FLAG(F_OF);
        }
    }
    else {
        res = 0;
        CONDITIONAL_SET_FLAG((d << (s - 1)) & 0x80000000, F_CF);
        CLEAR_FLAG(F_OF);
        CLEAR_FLAG(F_SF);
        SET_FLAG(F_PF);
        SET_FLAG(F_ZF);
    }
    return res;
}

/****************************************************************************
REMARKS:
Implements the SHRD instruction and side effects.
****************************************************************************/
u16
shrd_word(u16 d, u16 fill, u8 s)
{
    unsigned int cnt, res, cf;

    if (s < 16) {
        cnt = s % 16;
        if (cnt > 0) {
            cf = d & (1 << (cnt - 1));
            res = (d >> cnt) | (fill << (16 - cnt));
            CONDITIONAL_SET_FLAG(cf, F_CF);
            CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
            CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
        }
        else {
            res = d;
        }

        if (cnt == 1) {
            CONDITIONAL_SET_FLAG(XOR2(res >> 14), F_OF);
        }
        else {
            CLEAR_FLAG(F_OF);
        }
    }
    else {
        res = 0;
        CLEAR_FLAG(F_CF);
        CLEAR_FLAG(F_OF);
        SET_FLAG(F_ZF);
        CLEAR_FLAG(F_SF);
        CLEAR_FLAG(F_PF);
    }
    return (u16) res;
}

/****************************************************************************
REMARKS:
Implements the SHRD instruction and side effects.
****************************************************************************/
u32
shrd_long(u32 d, u32 fill, u8 s)
{
    unsigned int cnt, res, cf;

    if (s < 32) {
        cnt = s % 32;
        if (cnt > 0) {
            cf = d & (1 << (cnt - 1));
            res = (d >> cnt) | (fill << (32 - cnt));
            CONDITIONAL_SET_FLAG(cf, F_CF);
            CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
            CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
        }
        else {
            res = d;
        }
        if (cnt == 1) {
            CONDITIONAL_SET_FLAG(XOR2(res >> 30), F_OF);
        }
        else {
            CLEAR_FLAG(F_OF);
        }
    }
    else {
        res = 0;
        CLEAR_FLAG(F_CF);
        CLEAR_FLAG(F_OF);
        SET_FLAG(F_ZF);
        CLEAR_FLAG(F_SF);
        CLEAR_FLAG(F_PF);
    }
    return res;
}

/****************************************************************************
REMARKS:
Implements the SBB instruction and side effects.
****************************************************************************/
u8
sbb_byte(u8 d, u8 s)
{
    register u32 res;           /* all operands in native machine order */
    register u32 bc;

    if (ACCESS_FLAG(F_CF))
        res = d - s - 1;
    else
        res = d - s;
    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the borrow chain.  See note at top */
    bc = (res & (~d | s)) | (~d & s);
    CONDITIONAL_SET_FLAG(bc & 0x80, F_CF);
    CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
    return (u8) res;
}

/****************************************************************************
REMARKS:
Implements the SBB instruction and side effects.
****************************************************************************/
u16
sbb_word(u16 d, u16 s)
{
    register u32 res;           /* all operands in native machine order */
    register u32 bc;

    if (ACCESS_FLAG(F_CF))
        res = d - s - 1;
    else
        res = d - s;
    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the borrow chain.  See note at top */
    bc = (res & (~d | s)) | (~d & s);
    CONDITIONAL_SET_FLAG(bc & 0x8000, F_CF);
    CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
    return (u16) res;
}

/****************************************************************************
REMARKS:
Implements the SBB instruction and side effects.
****************************************************************************/
u32
sbb_long(u32 d, u32 s)
{
    register u32 res;           /* all operands in native machine order */
    register u32 bc;

    if (ACCESS_FLAG(F_CF))
        res = d - s - 1;
    else
        res = d - s;
    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the borrow chain.  See note at top */
    bc = (res & (~d | s)) | (~d & s);
    CONDITIONAL_SET_FLAG(bc & 0x80000000, F_CF);
    CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the SUB instruction and side effects.
****************************************************************************/
u8
sub_byte(u8 d, u8 s)
{
    register u32 res;           /* all operands in native machine order */
    register u32 bc;

    res = d - s;
    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the borrow chain.  See note at top */
    bc = (res & (~d | s)) | (~d & s);
    CONDITIONAL_SET_FLAG(bc & 0x80, F_CF);
    CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
    return (u8) res;
}

/****************************************************************************
REMARKS:
Implements the SUB instruction and side effects.
****************************************************************************/
u16
sub_word(u16 d, u16 s)
{
    register u32 res;           /* all operands in native machine order */
    register u32 bc;

    res = d - s;
    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the borrow chain.  See note at top */
    bc = (res & (~d | s)) | (~d & s);
    CONDITIONAL_SET_FLAG(bc & 0x8000, F_CF);
    CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
    return (u16) res;
}

/****************************************************************************
REMARKS:
Implements the SUB instruction and side effects.
****************************************************************************/
u32
sub_long(u32 d, u32 s)
{
    register u32 res;           /* all operands in native machine order */
    register u32 bc;

    res = d - s;
    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

    /* calculate the borrow chain.  See note at top */
    bc = (res & (~d | s)) | (~d & s);
    CONDITIONAL_SET_FLAG(bc & 0x80000000, F_CF);
    CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the TEST instruction and side effects.
****************************************************************************/
void
test_byte(u8 d, u8 s)
{
    register u32 res;           /* all operands in native machine order */

    res = d & s;

    CLEAR_FLAG(F_OF);
    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    /* AF == dont care */
    CLEAR_FLAG(F_CF);
}

/****************************************************************************
REMARKS:
Implements the TEST instruction and side effects.
****************************************************************************/
void
test_word(u16 d, u16 s)
{
    register u32 res;           /* all operands in native machine order */

    res = d & s;

    CLEAR_FLAG(F_OF);
    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    /* AF == dont care */
    CLEAR_FLAG(F_CF);
}

/****************************************************************************
REMARKS:
Implements the TEST instruction and side effects.
****************************************************************************/
void
test_long(u32 d, u32 s)
{
    register u32 res;           /* all operands in native machine order */

    res = d & s;

    CLEAR_FLAG(F_OF);
    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    /* AF == dont care */
    CLEAR_FLAG(F_CF);
}

/****************************************************************************
REMARKS:
Implements the XOR instruction and side effects.
****************************************************************************/
u8
xor_byte(u8 d, u8 s)
{
    register u8 res;            /* all operands in native machine order */

    res = d ^ s;
    CLEAR_FLAG(F_OF);
    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
    CLEAR_FLAG(F_CF);
    CLEAR_FLAG(F_AF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the XOR instruction and side effects.
****************************************************************************/
u16
xor_word(u16 d, u16 s)
{
    register u16 res;           /* all operands in native machine order */

    res = d ^ s;
    CLEAR_FLAG(F_OF);
    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    CLEAR_FLAG(F_CF);
    CLEAR_FLAG(F_AF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the XOR instruction and side effects.
****************************************************************************/
u32
xor_long(u32 d, u32 s)
{
    register u32 res;           /* all operands in native machine order */

    res = d ^ s;
    CLEAR_FLAG(F_OF);
    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    CLEAR_FLAG(F_CF);
    CLEAR_FLAG(F_AF);
    return res;
}

/****************************************************************************
REMARKS:
Implements the IMUL instruction and side effects.
****************************************************************************/
void
imul_byte(u8 s)
{
    s16 res = (s16) ((s8) M.x86.R_AL * (s8) s);

    M.x86.R_AX = res;
    if (((M.x86.R_AL & 0x80) == 0 && M.x86.R_AH == 0x00) ||
        ((M.x86.R_AL & 0x80) != 0 && M.x86.R_AH == 0xFF)) {
        CLEAR_FLAG(F_CF);
        CLEAR_FLAG(F_OF);
    }
    else {
        SET_FLAG(F_CF);
        SET_FLAG(F_OF);
    }
}

/****************************************************************************
REMARKS:
Implements the IMUL instruction and side effects.
****************************************************************************/
void
imul_word(u16 s)
{
    s32 res = (s16) M.x86.R_AX * (s16) s;

    M.x86.R_AX = (u16) res;
    M.x86.R_DX = (u16) (res >> 16);
    if (((M.x86.R_AX & 0x8000) == 0 && M.x86.R_DX == 0x00) ||
        ((M.x86.R_AX & 0x8000) != 0 && M.x86.R_DX == 0xFF)) {
        CLEAR_FLAG(F_CF);
        CLEAR_FLAG(F_OF);
    }
    else {
        SET_FLAG(F_CF);
        SET_FLAG(F_OF);
    }
}

/****************************************************************************
REMARKS:
Implements the IMUL instruction and side effects.
****************************************************************************/
void
imul_long_direct(u32 * res_lo, u32 * res_hi, u32 d, u32 s)
{
#ifdef	__HAS_LONG_LONG__
    s64 res = (s64) (s32) d * (s32) s;

    *res_lo = (u32) res;
    *res_hi = (u32) (res >> 32);
#else
    u32 d_lo, d_hi, d_sign;
    u32 s_lo, s_hi, s_sign;
    u32 rlo_lo, rlo_hi, rhi_lo;

    if ((d_sign = d & 0x80000000) != 0)
        d = -d;
    d_lo = d & 0xFFFF;
    d_hi = d >> 16;
    if ((s_sign = s & 0x80000000) != 0)
        s = -s;
    s_lo = s & 0xFFFF;
    s_hi = s >> 16;
    rlo_lo = d_lo * s_lo;
    rlo_hi = (d_hi * s_lo + d_lo * s_hi) + (rlo_lo >> 16);
    rhi_lo = d_hi * s_hi + (rlo_hi >> 16);
    *res_lo = (rlo_hi << 16) | (rlo_lo & 0xFFFF);
    *res_hi = rhi_lo;
    if (d_sign != s_sign) {
        d = ~*res_lo;
        s = (((d & 0xFFFF) + 1) >> 16) + (d >> 16);
        *res_lo = ~*res_lo + 1;
        *res_hi = ~*res_hi + (s >> 16);
    }
#endif
}

/****************************************************************************
REMARKS:
Implements the IMUL instruction and side effects.
****************************************************************************/
void
imul_long(u32 s)
{
    imul_long_direct(&M.x86.R_EAX, &M.x86.R_EDX, M.x86.R_EAX, s);
    if (((M.x86.R_EAX & 0x80000000) == 0 && M.x86.R_EDX == 0x00) ||
        ((M.x86.R_EAX & 0x80000000) != 0 && M.x86.R_EDX == 0xFF)) {
        CLEAR_FLAG(F_CF);
        CLEAR_FLAG(F_OF);
    }
    else {
        SET_FLAG(F_CF);
        SET_FLAG(F_OF);
    }
}

/****************************************************************************
REMARKS:
Implements the MUL instruction and side effects.
****************************************************************************/
void
mul_byte(u8 s)
{
    u16 res = (u16) (M.x86.R_AL * s);

    M.x86.R_AX = res;
    if (M.x86.R_AH == 0) {
        CLEAR_FLAG(F_CF);
        CLEAR_FLAG(F_OF);
    }
    else {
        SET_FLAG(F_CF);
        SET_FLAG(F_OF);
    }
}

/****************************************************************************
REMARKS:
Implements the MUL instruction and side effects.
****************************************************************************/
void
mul_word(u16 s)
{
    u32 res = M.x86.R_AX * s;

    M.x86.R_AX = (u16) res;
    M.x86.R_DX = (u16) (res >> 16);
    if (M.x86.R_DX == 0) {
        CLEAR_FLAG(F_CF);
        CLEAR_FLAG(F_OF);
    }
    else {
        SET_FLAG(F_CF);
        SET_FLAG(F_OF);
    }
}

/****************************************************************************
REMARKS:
Implements the MUL instruction and side effects.
****************************************************************************/
void
mul_long(u32 s)
{
#ifdef	__HAS_LONG_LONG__
    u64 res = (u64) M.x86.R_EAX * s;

    M.x86.R_EAX = (u32) res;
    M.x86.R_EDX = (u32) (res >> 32);
#else
    u32 a, a_lo, a_hi;
    u32 s_lo, s_hi;
    u32 rlo_lo, rlo_hi, rhi_lo;

    a = M.x86.R_EAX;
    a_lo = a & 0xFFFF;
    a_hi = a >> 16;
    s_lo = s & 0xFFFF;
    s_hi = s >> 16;
    rlo_lo = a_lo * s_lo;
    rlo_hi = (a_hi * s_lo + a_lo * s_hi) + (rlo_lo >> 16);
    rhi_lo = a_hi * s_hi + (rlo_hi >> 16);
    M.x86.R_EAX = (rlo_hi << 16) | (rlo_lo & 0xFFFF);
    M.x86.R_EDX = rhi_lo;
#endif

    if (M.x86.R_EDX == 0) {
        CLEAR_FLAG(F_CF);
        CLEAR_FLAG(F_OF);
    }
    else {
        SET_FLAG(F_CF);
        SET_FLAG(F_OF);
    }
}

/****************************************************************************
REMARKS:
Implements the IDIV instruction and side effects.
****************************************************************************/
void
idiv_byte(u8 s)
{
    s32 dvd, div, mod;

    dvd = (s16) M.x86.R_AX;
    if (s == 0) {
        x86emu_intr_raise(0);
        return;
    }
    div = dvd / (s8) s;
    mod = dvd % (s8) s;
    if (abs(div) > 0x7f) {
        x86emu_intr_raise(0);
        return;
    }
    M.x86.R_AL = (s8) div;
    M.x86.R_AH = (s8) mod;
}

/****************************************************************************
REMARKS:
Implements the IDIV instruction and side effects.
****************************************************************************/
void
idiv_word(u16 s)
{
    s32 dvd, div, mod;

    dvd = (((s32) M.x86.R_DX) << 16) | M.x86.R_AX;
    if (s == 0) {
        x86emu_intr_raise(0);
        return;
    }
    div = dvd / (s16) s;
    mod = dvd % (s16) s;
    if (abs(div) > 0x7fff) {
        x86emu_intr_raise(0);
        return;
    }
    CLEAR_FLAG(F_CF);
    CLEAR_FLAG(F_SF);
    CONDITIONAL_SET_FLAG(div == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);

    M.x86.R_AX = (u16) div;
    M.x86.R_DX = (u16) mod;
}

/****************************************************************************
REMARKS:
Implements the IDIV instruction and side effects.
****************************************************************************/
void
idiv_long(u32 s)
{
#ifdef	__HAS_LONG_LONG__
    s64 dvd, div, mod;

    dvd = (((s64) M.x86.R_EDX) << 32) | M.x86.R_EAX;
    if (s == 0) {
        x86emu_intr_raise(0);
        return;
    }
    div = dvd / (s32) s;
    mod = dvd % (s32) s;
    if (abs(div) > 0x7fffffff) {
        x86emu_intr_raise(0);
        return;
    }
#else
    s32 div = 0, mod;
    s32 h_dvd = M.x86.R_EDX;
    u32 l_dvd = M.x86.R_EAX;
    u32 abs_s = s & 0x7FFFFFFF;
    u32 abs_h_dvd = h_dvd & 0x7FFFFFFF;
    u32 h_s = abs_s >> 1;
    u32 l_s = abs_s << 31;
    int counter = 31;
    int carry;

    if (s == 0) {
        x86emu_intr_raise(0);
        return;
    }
    do {
        div <<= 1;
        carry = (l_dvd >= l_s) ? 0 : 1;

        if (abs_h_dvd < (h_s + carry)) {
            h_s >>= 1;
            l_s = abs_s << (--counter);
            continue;
        }
        else {
            abs_h_dvd -= (h_s + carry);
            l_dvd = carry ? ((0xFFFFFFFF - l_s) + l_dvd + 1)
                : (l_dvd - l_s);
            h_s >>= 1;
            l_s = abs_s << (--counter);
            div |= 1;
            continue;
        }

    } while (counter > -1);
    /* overflow */
    if (abs_h_dvd || (l_dvd > abs_s)) {
        x86emu_intr_raise(0);
        return;
    }
    /* sign */
    div |= ((h_dvd & 0x10000000) ^ (s & 0x10000000));
    mod = l_dvd;

#endif
    CLEAR_FLAG(F_CF);
    CLEAR_FLAG(F_AF);
    CLEAR_FLAG(F_SF);
    SET_FLAG(F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);

    M.x86.R_EAX = (u32) div;
    M.x86.R_EDX = (u32) mod;
}

/****************************************************************************
REMARKS:
Implements the DIV instruction and side effects.
****************************************************************************/
void
div_byte(u8 s)
{
    u32 dvd, div, mod;

    dvd = M.x86.R_AX;
    if (s == 0) {
        x86emu_intr_raise(0);
        return;
    }
    div = dvd / (u8) s;
    mod = dvd % (u8) s;
    if (abs(div) > 0xff) {
        x86emu_intr_raise(0);
        return;
    }
    M.x86.R_AL = (u8) div;
    M.x86.R_AH = (u8) mod;
}

/****************************************************************************
REMARKS:
Implements the DIV instruction and side effects.
****************************************************************************/
void
div_word(u16 s)
{
    u32 dvd, div, mod;

    dvd = (((u32) M.x86.R_DX) << 16) | M.x86.R_AX;
    if (s == 0) {
        x86emu_intr_raise(0);
        return;
    }
    div = dvd / (u16) s;
    mod = dvd % (u16) s;
    if (abs(div) > 0xffff) {
        x86emu_intr_raise(0);
        return;
    }
    CLEAR_FLAG(F_CF);
    CLEAR_FLAG(F_SF);
    CONDITIONAL_SET_FLAG(div == 0, F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);

    M.x86.R_AX = (u16) div;
    M.x86.R_DX = (u16) mod;
}

/****************************************************************************
REMARKS:
Implements the DIV instruction and side effects.
****************************************************************************/
void
div_long(u32 s)
{
#ifdef	__HAS_LONG_LONG__
    u64 dvd, div, mod;

    dvd = (((u64) M.x86.R_EDX) << 32) | M.x86.R_EAX;
    if (s == 0) {
        x86emu_intr_raise(0);
        return;
    }
    div = dvd / (u32) s;
    mod = dvd % (u32) s;
    if (abs(div) > 0xffffffff) {
        x86emu_intr_raise(0);
        return;
    }
#else
    s32 div = 0, mod;
    s32 h_dvd = M.x86.R_EDX;
    u32 l_dvd = M.x86.R_EAX;

    u32 h_s = s;
    u32 l_s = 0;
    int counter = 32;
    int carry;

    if (s == 0) {
        x86emu_intr_raise(0);
        return;
    }
    do {
        div <<= 1;
        carry = (l_dvd >= l_s) ? 0 : 1;

        if (h_dvd < (h_s + carry)) {
            h_s >>= 1;
            l_s = s << (--counter);
            continue;
        }
        else {
            h_dvd -= (h_s + carry);
            l_dvd = carry ? ((0xFFFFFFFF - l_s) + l_dvd + 1)
                : (l_dvd - l_s);
            h_s >>= 1;
            l_s = s << (--counter);
            div |= 1;
            continue;
        }

    } while (counter > -1);
    /* overflow */
    if (h_dvd || (l_dvd > s)) {
        x86emu_intr_raise(0);
        return;
    }
    mod = l_dvd;
#endif
    CLEAR_FLAG(F_CF);
    CLEAR_FLAG(F_AF);
    CLEAR_FLAG(F_SF);
    SET_FLAG(F_ZF);
    CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);

    M.x86.R_EAX = (u32) div;
    M.x86.R_EDX = (u32) mod;
}

/****************************************************************************
REMARKS:
Implements the IN string instruction and side effects.
****************************************************************************/
void
ins(int size)
{
    int inc = size;

    if (ACCESS_FLAG(F_DF)) {
        inc = -size;
    }
    if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {
        /* dont care whether REPE or REPNE */
        /* in until CX is ZERO. */
        u32 count = ((M.x86.mode & SYSMODE_PREFIX_DATA) ?
                     M.x86.R_ECX : M.x86.R_CX);
        switch (size) {
        case 1:
            while (count--) {
                store_data_byte_abs(M.x86.R_ES, M.x86.R_DI,
                                    (*sys_inb) (M.x86.R_DX));
                M.x86.R_DI += inc;
            }
            break;

        case 2:
            while (count--) {
                store_data_word_abs(M.x86.R_ES, M.x86.R_DI,
                                    (*sys_inw) (M.x86.R_DX));
                M.x86.R_DI += inc;
            }
            break;
        case 4:
            while (count--) {
                store_data_long_abs(M.x86.R_ES, M.x86.R_DI,
                                    (*sys_inl) (M.x86.R_DX));
                M.x86.R_DI += inc;
                break;
            }
        }
        M.x86.R_CX = 0;
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            M.x86.R_ECX = 0;
        }
        M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
    }
    else {
        switch (size) {
        case 1:
            store_data_byte_abs(M.x86.R_ES, M.x86.R_DI,
                                (*sys_inb) (M.x86.R_DX));
            break;
        case 2:
            store_data_word_abs(M.x86.R_ES, M.x86.R_DI,
                                (*sys_inw) (M.x86.R_DX));
            break;
        case 4:
            store_data_long_abs(M.x86.R_ES, M.x86.R_DI,
                                (*sys_inl) (M.x86.R_DX));
            break;
        }
        M.x86.R_DI += inc;
    }
}

/****************************************************************************
REMARKS:
Implements the OUT string instruction and side effects.
****************************************************************************/
void
outs(int size)
{
    int inc = size;

    if (ACCESS_FLAG(F_DF)) {
        inc = -size;
    }
    if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {
        /* dont care whether REPE or REPNE */
        /* out until CX is ZERO. */
        u32 count = ((M.x86.mode & SYSMODE_PREFIX_DATA) ?
                     M.x86.R_ECX : M.x86.R_CX);
        switch (size) {
        case 1:
            while (count--) {
                (*sys_outb) (M.x86.R_DX,
                             fetch_data_byte_abs(M.x86.R_ES, M.x86.R_SI));
                M.x86.R_SI += inc;
            }
            break;

        case 2:
            while (count--) {
                (*sys_outw) (M.x86.R_DX,
                             fetch_data_word_abs(M.x86.R_ES, M.x86.R_SI));
                M.x86.R_SI += inc;
            }
            break;
        case 4:
            while (count--) {
                (*sys_outl) (M.x86.R_DX,
                             fetch_data_long_abs(M.x86.R_ES, M.x86.R_SI));
                M.x86.R_SI += inc;
                break;
            }
        }
        M.x86.R_CX = 0;
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            M.x86.R_ECX = 0;
        }
        M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
    }
    else {
        switch (size) {
        case 1:
            (*sys_outb) (M.x86.R_DX,
                         fetch_data_byte_abs(M.x86.R_ES, M.x86.R_SI));
            break;
        case 2:
            (*sys_outw) (M.x86.R_DX,
                         fetch_data_word_abs(M.x86.R_ES, M.x86.R_SI));
            break;
        case 4:
            (*sys_outl) (M.x86.R_DX,
                         fetch_data_long_abs(M.x86.R_ES, M.x86.R_SI));
            break;
        }
        M.x86.R_SI += inc;
    }
}

/****************************************************************************
PARAMETERS:
addr	- Address to fetch word from

REMARKS:
Fetches a word from emulator memory using an absolute address.
****************************************************************************/
u16
mem_access_word(int addr)
{
    DB(if (CHECK_MEM_ACCESS())
       x86emu_check_mem_access(addr);)
        return (*sys_rdw) (addr);
}

/****************************************************************************
REMARKS:
Pushes a word onto the stack.

NOTE: Do not inline this, as (*sys_wrX) is already inline!
****************************************************************************/
void
push_word(u16 w)
{
    DB(if (CHECK_SP_ACCESS())
       x86emu_check_sp_access();)
        M.x86.R_SP -= 2;
    (*sys_wrw) (((u32) M.x86.R_SS << 4) + M.x86.R_SP, w);
}

/****************************************************************************
REMARKS:
Pushes a long onto the stack.

NOTE: Do not inline this, as (*sys_wrX) is already inline!
****************************************************************************/
void
push_long(u32 w)
{
    DB(if (CHECK_SP_ACCESS())
       x86emu_check_sp_access();)
        M.x86.R_SP -= 4;
    (*sys_wrl) (((u32) M.x86.R_SS << 4) + M.x86.R_SP, w);
}

/****************************************************************************
REMARKS:
Pops a word from the stack.

NOTE: Do not inline this, as (*sys_rdX) is already inline!
****************************************************************************/
u16
pop_word(void)
{
    register u16 res;

    DB(if (CHECK_SP_ACCESS())
       x86emu_check_sp_access();)
        res = (*sys_rdw) (((u32) M.x86.R_SS << 4) + M.x86.R_SP);
    M.x86.R_SP += 2;
    return res;
}

/****************************************************************************
REMARKS:
Pops a long from the stack.

NOTE: Do not inline this, as (*sys_rdX) is already inline!
****************************************************************************/
u32
pop_long(void)
{
    register u32 res;

    DB(if (CHECK_SP_ACCESS())
       x86emu_check_sp_access();)
        res = (*sys_rdl) (((u32) M.x86.R_SS << 4) + M.x86.R_SP);
    M.x86.R_SP += 4;
    return res;
}

/****************************************************************************
REMARKS:
CPUID takes EAX/ECX as inputs, writes EAX/EBX/ECX/EDX as output
****************************************************************************/
void
cpuid(void)
{
    u32 feature = M.x86.R_EAX;

#ifdef X86EMU_HAS_HW_CPUID
    /* If the platform allows it, we will base our values on the real
     * results from the CPUID instruction.  We limit support to the
     * first two features, and the results of those are sanitized.
     */
    if (feature <= 1)
        hw_cpuid(&M.x86.R_EAX, &M.x86.R_EBX, &M.x86.R_ECX, &M.x86.R_EDX);
#endif

    switch (feature) {
    case 0:
        /* Regardless if we have real data from the hardware, the emulator
         * will only support upto feature 1, which we set in register EAX.
         * Registers EBX:EDX:ECX contain a string identifying the CPU.
         */
        M.x86.R_EAX = 1;
#ifndef X86EMU_HAS_HW_CPUID
        /* EBX:EDX:ECX = "GenuineIntel" */
        M.x86.R_EBX = 0x756e6547;
        M.x86.R_EDX = 0x49656e69;
        M.x86.R_ECX = 0x6c65746e;
#endif
        break;
    case 1:
#ifndef X86EMU_HAS_HW_CPUID
        /* If we don't have x86 compatible hardware, we return values from an
         * Intel 486dx4; which was one of the first processors to have CPUID.
         */
        M.x86.R_EAX = 0x00000480;
        M.x86.R_EBX = 0x00000000;
        M.x86.R_ECX = 0x00000000;
        M.x86.R_EDX = 0x00000002;       /* VME */
#else
        /* In the case that we have hardware CPUID instruction, we make sure
         * that the features reported are limited to TSC and VME.
         */
        M.x86.R_EDX &= 0x00000012;
#endif
        break;
    default:
        /* Finally, we don't support any additional features.  Most CPUs
         * return all zeros when queried for invalid or unsupported feature
         * numbers.
         */
        M.x86.R_EAX = 0;
        M.x86.R_EBX = 0;
        M.x86.R_ECX = 0;
        M.x86.R_EDX = 0;
        break;
    }
}
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d886 1
a886 1
       CF  B_7 B_6 B_5 B_4 B_3 B_2 B_1 B_0 
d888 1
a888 1
       want to rotate through the carry by "s" bits.  We could 
d898 1
a898 1
       then located n bits from the MSB.  The low part is 
d900 1
a900 1
       in.  Using CAPS for new values, and lowercase for the 
d903 1
a903 1
       IF n > 0 
d915 1
a915 1
        /* get the low stuff which rotated 
d921 1
a921 1
        /* now the high stuff which rotated around 
d924 2
a925 2
        /* shift it downward, 7-(n-2) = 9-n positions. 
           and mask off the result before or'ing in. 
d937 1
a937 1
        /* OVERFLOW is set *IFF* cnt==1, then it is the 
d1006 1
a1006 1
    /* 
d1008 1
a1008 1
       d is the byte object rotated.  
d1010 1
a1010 1
       have 
d1012 1
a1012 1
       CF  B_7 B_6 B_5 B_4 B_3 B_2 B_1 B_0 
d1016 1
a1016 1
       then located n bits from the LSB.  The low part is 
d1018 1
a1018 1
       in.  Using CAPS for new values, and lowercase for the 
d1021 1
a1021 1
       IF n > 0 
d1036 1
a1036 1
               doing access_flag(..) != 0 casts that into either 
d1047 1
a1047 1
           This is effectively done by shifting the 
d1049 1
a1049 1
           in case the object came in and was treated 
d1055 1
a1055 1
        /* now the high stuff which rotated around 
d1058 2
a1059 2
        /* shift it downward, 7-(n-2) = 9-n positions. 
           and mask off the result before or'ing in. 
d1070 1
a1070 1
        /* OVERFLOW is set *IFF* cnt==1, then it is the 
d1157 1
a1157 1
    /* 
d1159 1
a1159 1
       d is the byte object rotated.  
d1161 1
a1161 1
       have 
d1163 1
a1163 1
       CF  B_7 ... B_0 
d1168 1
a1168 1
       IF n > 0 
d1259 1
a1259 1
    /* 
d1261 1
a1261 1
       d is the byte object rotated.  
d1263 1
a1263 1
       have 
d1265 1
a1265 1
       B_7 ... B_0 
d1269 1
a1269 1
       IF n > 0 
d1282 1
a1282 1
        /* set the new carry flag, Note that it is the low order 
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d106 3
a108 3
# if defined (__i386__) || defined(__i386) || defined(__AMD64__) || defined(__amd64__)
#  include "x86emu/prim_x86_gcc.h"
# endif
d113 9
a121 10
static u32 x86emu_parity_tab[8] =
{
	0x96696996,
	0x69969669,
	0x69969669,
	0x96696996,
	0x69969669,
	0x96696996,
	0x96696996,
	0x69969669,
d133 2
a134 1
u16 aaa_word(u16 d)
d136 17
a152 15
	u16	res;
	if ((d & 0xf) > 0x9 || ACCESS_FLAG(F_AF)) {
		d += 0x6;
		d += 0x100;
		SET_FLAG(F_AF);
		SET_FLAG(F_CF);
	} else {
		CLEAR_FLAG(F_CF);
		CLEAR_FLAG(F_AF);
	}
	res = (u16)(d & 0xFF0F);
	CLEAR_FLAG(F_SF);
	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
	return res;
d159 2
a160 1
u16 aas_word(u16 d)
d162 17
a178 15
	u16	res;
	if ((d & 0xf) > 0x9 || ACCESS_FLAG(F_AF)) {
		d -= 0x6;
		d -= 0x100;
		SET_FLAG(F_AF);
		SET_FLAG(F_CF);
	} else {
		CLEAR_FLAG(F_CF);
		CLEAR_FLAG(F_AF);
	}
	res = (u16)(d & 0xFF0F);
	CLEAR_FLAG(F_SF);
	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
	return res;
d185 2
a186 1
u16 aad_word(u16 d)
d188 2
a189 2
	u16 l;
	u8 hb, lb;
d191 11
a201 11
	hb = (u8)((d >> 8) & 0xff);
	lb = (u8)((d & 0xff));
	l = (u16)((lb + 10 * hb) & 0xFF);

	CLEAR_FLAG(F_CF);
	CLEAR_FLAG(F_AF);
	CLEAR_FLAG(F_OF);
	CONDITIONAL_SET_FLAG(l & 0x80, F_SF);
	CONDITIONAL_SET_FLAG(l == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(l & 0xff), F_PF);
	return l;
d208 2
a209 1
u16 aam_word(u8 d)
d213 10
a222 10
	h = (u16)(d / 10);
	l = (u16)(d % 10);
	l |= (u16)(h << 8);

	CLEAR_FLAG(F_CF);
	CLEAR_FLAG(F_AF);
	CLEAR_FLAG(F_OF);
	CONDITIONAL_SET_FLAG(l & 0x80, F_SF);
	CONDITIONAL_SET_FLAG(l == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(l & 0xff), F_PF);
d230 2
a231 1
u8 adc_byte(u8 d, u8 s)
d233 12
a244 2
	register u32 res;   /* all operands in native machine order */
	register u32 cc;
d246 5
a250 15
	if (ACCESS_FLAG(F_CF))
		res = 1 + d + s;
	else
		res = d + s;

	CONDITIONAL_SET_FLAG(res & 0x100, F_CF);
	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the carry chain  SEE NOTE AT TOP. */
	cc = (s & d) | ((~res) & (s | d));
	CONDITIONAL_SET_FLAG(XOR2(cc >> 6), F_OF);
	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
	return (u8)res;
d257 2
a258 1
u16 adc_word(u16 d, u16 s)
d260 7
a266 2
	register u32 res;   /* all operands in native machine order */
	register u32 cc;
d268 10
a277 15
	if (ACCESS_FLAG(F_CF))
		res = 1 + d + s;
	else
		res = d + s;

	CONDITIONAL_SET_FLAG(res & 0x10000, F_CF);
	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the carry chain  SEE NOTE AT TOP. */
	cc = (s & d) | ((~res) & (s | d));
	CONDITIONAL_SET_FLAG(XOR2(cc >> 14), F_OF);
	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
	return (u16)res;
d284 2
a285 1
u32 adc_long(u32 d, u32 s)
d287 25
a311 25
	register u32 lo;	/* all operands in native machine order */
	register u32 hi;
	register u32 res;
	register u32 cc;

	if (ACCESS_FLAG(F_CF)) {
		lo = 1 + (d & 0xFFFF) + (s & 0xFFFF);
		res = 1 + d + s;
		}
	else {
		lo = (d & 0xFFFF) + (s & 0xFFFF);
		res = d + s;
		}
	hi = (lo >> 16) + (d >> 16) + (s >> 16);

	CONDITIONAL_SET_FLAG(hi & 0x10000, F_CF);
	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the carry chain  SEE NOTE AT TOP. */
	cc = (s & d) | ((~res) & (s | d));
	CONDITIONAL_SET_FLAG(XOR2(cc >> 30), F_OF);
	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
	return res;
d318 2
a319 1
u8 add_byte(u8 d, u8 s)
d321 2
a322 2
	register u32 res;   /* all operands in native machine order */
	register u32 cc;
d324 11
a334 11
	res = d + s;
	CONDITIONAL_SET_FLAG(res & 0x100, F_CF);
	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the carry chain  SEE NOTE AT TOP. */
	cc = (s & d) | ((~res) & (s | d));
	CONDITIONAL_SET_FLAG(XOR2(cc >> 6), F_OF);
	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
	return (u8)res;
d341 2
a342 1
u16 add_word(u16 d, u16 s)
d344 2
a345 2
	register u32 res;   /* all operands in native machine order */
	register u32 cc;
d347 11
a357 11
	res = d + s;
	CONDITIONAL_SET_FLAG(res & 0x10000, F_CF);
	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the carry chain  SEE NOTE AT TOP. */
	cc = (s & d) | ((~res) & (s | d));
	CONDITIONAL_SET_FLAG(XOR2(cc >> 14), F_OF);
	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
	return (u16)res;
d364 2
a365 1
u32 add_long(u32 d, u32 s)
d367 13
a379 13
	register u32 lo;	/* all operands in native machine order */
	register u32 hi;
	register u32 res;
	register u32 cc;

	lo = (d & 0xFFFF) + (s & 0xFFFF);
	res = d + s;
	hi = (lo >> 16) + (d >> 16) + (s >> 16);

	CONDITIONAL_SET_FLAG(hi & 0x10000, F_CF);
	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
d383 2
a384 2
	CONDITIONAL_SET_FLAG(XOR2(cc >> 30), F_OF);
	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
d393 2
a394 1
u8 and_byte(u8 d, u8 s)
d396 1
a396 1
	register u8 res;    /* all operands in native machine order */
d398 1
a398 1
	res = d & s;
d400 8
a407 8
	/* set the flags  */
	CLEAR_FLAG(F_OF);
	CLEAR_FLAG(F_CF);
	CLEAR_FLAG(F_AF);
	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
	return res;
d414 2
a415 1
u16 and_word(u16 d, u16 s)
d417 1
a417 1
    register u16 res;   /* all operands in native machine order */
d422 6
a427 6
	CLEAR_FLAG(F_OF);
	CLEAR_FLAG(F_CF);
	CLEAR_FLAG(F_AF);
	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
d435 2
a436 1
u32 and_long(u32 d, u32 s)
d438 1
a438 1
	register u32 res;   /* all operands in native machine order */
d440 1
a440 1
	res = d & s;
d442 8
a449 8
	/* set the flags  */
	CLEAR_FLAG(F_OF);
	CLEAR_FLAG(F_CF);
	CLEAR_FLAG(F_AF);
	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
	return res;
d456 2
a457 1
u8 cmp_byte(u8 d, u8 s)
d459 2
a460 2
	register u32 res;   /* all operands in native machine order */
	register u32 bc;
d462 12
a473 12
	res = d - s;
	CLEAR_FLAG(F_CF);
	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the borrow chain.  See note at top */
	bc = (res & (~d | s)) | (~d & s);
	CONDITIONAL_SET_FLAG(bc & 0x80, F_CF);
	CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
	return d;
d480 2
a481 1
u16 cmp_word(u16 d, u16 s)
d483 2
a484 2
	register u32 res;   /* all operands in native machine order */
	register u32 bc;
d486 4
a489 4
	res = d - s;
	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
d491 1
a491 1
	/* calculate the borrow chain.  See note at top */
d493 4
a496 4
	CONDITIONAL_SET_FLAG(bc & 0x8000, F_CF);
	CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
	return d;
d503 2
a504 1
u32 cmp_long(u32 d, u32 s)
d506 7
a512 2
	register u32 res;   /* all operands in native machine order */
	register u32 bc;
d514 6
a519 11
	res = d - s;
	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the borrow chain.  See note at top */
	bc = (res & (~d | s)) | (~d & s);
	CONDITIONAL_SET_FLAG(bc & 0x80000000, F_CF);
	CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
	return d;
d526 2
a527 1
u8 daa_byte(u8 d)
d529 14
a542 13
	u32 res = d;
	if ((d & 0xf) > 9 || ACCESS_FLAG(F_AF)) {
		res += 6;
		SET_FLAG(F_AF);
	}
	if (res > 0x9F || ACCESS_FLAG(F_CF)) {
		res += 0x60;
		SET_FLAG(F_CF);
	}
	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
	CONDITIONAL_SET_FLAG((res & 0xFF) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
	return (u8)res;
d549 2
a550 1
u8 das_byte(u8 d)
d552 12
a563 12
	if ((d & 0xf) > 9 || ACCESS_FLAG(F_AF)) {
		d -= 6;
		SET_FLAG(F_AF);
	}
	if (d > 0x9F || ACCESS_FLAG(F_CF)) {
		d -= 0x60;
		SET_FLAG(F_CF);
	}
	CONDITIONAL_SET_FLAG(d & 0x80, F_SF);
	CONDITIONAL_SET_FLAG(d == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(d & 0xff), F_PF);
	return d;
d570 2
a571 1
u8 dec_byte(u8 d)
d573 1
a573 1
    register u32 res;   /* all operands in native machine order */
d577 11
a587 11
	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the borrow chain.  See note at top */
	/* based on sub_byte, uses s==1.  */
	bc = (res & (~d | 1)) | (~d & 1);
	/* carry flag unchanged */
	CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
	return (u8)res;
d594 2
a595 1
u16 dec_word(u16 d)
d597 1
a597 1
    register u32 res;   /* all operands in native machine order */
d601 3
a603 3
	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
d609 3
a611 3
	CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
	return (u16)res;
d618 2
a619 1
u32 dec_long(u32 d)
d621 1
a621 1
    register u32 res;   /* all operands in native machine order */
d626 3
a628 3
	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
d631 5
a635 5
	bc = (res & (~d | 1)) | (~d & 1);
	/* carry flag unchanged */
	CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
	return res;
d642 2
a643 1
u8 inc_byte(u8 d)
d645 2
a646 2
	register u32 res;   /* all operands in native machine order */
	register u32 cc;
d648 10
a657 10
	res = d + 1;
	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the carry chain  SEE NOTE AT TOP. */
	cc = ((1 & d) | (~res)) & (1 | d);
	CONDITIONAL_SET_FLAG(XOR2(cc >> 6), F_OF);
	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
	return (u8)res;
d664 2
a665 1
u16 inc_word(u16 d)
d667 7
a673 2
	register u32 res;   /* all operands in native machine order */
	register u32 cc;
d675 5
a679 10
	res = d + 1;
	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the carry chain  SEE NOTE AT TOP. */
	cc = (1 & d) | ((~res) & (1 | d));
	CONDITIONAL_SET_FLAG(XOR2(cc >> 14), F_OF);
	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
	return (u16)res;
d686 2
a687 1
u32 inc_long(u32 d)
d689 7
a695 2
	register u32 res;   /* all operands in native machine order */
	register u32 cc;
d697 5
a701 10
	res = d + 1;
	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the carry chain  SEE NOTE AT TOP. */
	cc = (1 & d) | ((~res) & (1 | d));
	CONDITIONAL_SET_FLAG(XOR2(cc >> 30), F_OF);
	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
	return res;
d708 2
a709 1
u8 or_byte(u8 d, u8 s)
d711 1
a711 1
	register u8 res;    /* all operands in native machine order */
d713 8
a720 8
	res = d | s;
	CLEAR_FLAG(F_OF);
	CLEAR_FLAG(F_CF);
	CLEAR_FLAG(F_AF);
	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
	return res;
d727 2
a728 1
u16 or_word(u16 d, u16 s)
d730 1
a730 1
	register u16 res;   /* all operands in native machine order */
d732 9
a740 9
	res = d | s;
	/* set the carry flag to be bit 8 */
	CLEAR_FLAG(F_OF);
	CLEAR_FLAG(F_CF);
	CLEAR_FLAG(F_AF);
	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
	return res;
d747 2
a748 1
u32 or_long(u32 d, u32 s)
d750 1
a750 1
	register u32 res;   /* all operands in native machine order */
d752 1
a752 1
	res = d | s;
d754 8
a761 8
	/* set the carry flag to be bit 8 */
	CLEAR_FLAG(F_OF);
	CLEAR_FLAG(F_CF);
	CLEAR_FLAG(F_AF);
	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
	return res;
d768 2
a769 1
u8 neg_byte(u8 s)
d774 14
a787 14
	CONDITIONAL_SET_FLAG(s != 0, F_CF);
	res = (u8)-s;
	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
	CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
	/* calculate the borrow chain --- modified such that d=0.
	   substitutiing d=0 into     bc= res&(~d|s)|(~d&s);
	   (the one used for sub) and simplifying, since ~d=0xff...,
	   ~d|s == 0xffff..., and res&0xfff... == res.  Similarly
	   ~d&s == s.  So the simplified result is: */
	bc = res | s;
	CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
	return res;
d794 2
a795 1
u16 neg_word(u16 s)
d797 2
a798 2
	register u16 res;
	register u16 bc;
d800 15
a814 15
	CONDITIONAL_SET_FLAG(s != 0, F_CF);
	res = (u16)-s;
	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the borrow chain --- modified such that d=0.
	   substitutiing d=0 into     bc= res&(~d|s)|(~d&s);
	   (the one used for sub) and simplifying, since ~d=0xff...,
	   ~d|s == 0xffff..., and res&0xfff... == res.  Similarly
	   ~d&s == s.  So the simplified result is: */
	bc = res | s;
	CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
	return res;
d821 2
a822 1
u32 neg_long(u32 s)
d824 2
a825 2
	register u32 res;
	register u32 bc;
d827 15
a841 15
	CONDITIONAL_SET_FLAG(s != 0, F_CF);
	res = (u32)-s;
	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the borrow chain --- modified such that d=0.
	   substitutiing d=0 into     bc= res&(~d|s)|(~d&s);
	   (the one used for sub) and simplifying, since ~d=0xff...,
	   ~d|s == 0xffff..., and res&0xfff... == res.  Similarly
	   ~d&s == s.  So the simplified result is: */
	bc = res | s;
	CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
	return res;
d848 2
a849 1
u8 not_byte(u8 s)
d851 1
a851 1
	return ~s;
d858 2
a859 1
u16 not_word(u16 s)
d861 1
a861 1
	return ~s;
d868 2
a869 1
u32 not_long(u32 s)
d871 1
a871 1
	return ~s;
d878 2
a879 1
u8 rcl_byte(u8 d, u8 s)
d884 1
a884 1
	/* have
d908 3
a910 3
	 */
	res = d;
	if ((cnt = s % 9) != 0) {
d919 1
a919 1
		res = (d << cnt) & 0xff;
d931 1
a931 1
		if (ACCESS_FLAG(F_CF)) {     /* carry flag is set */
d936 1
a936 1
		CONDITIONAL_SET_FLAG(cf, F_CF);
d941 1
a941 2
        CONDITIONAL_SET_FLAG(cnt == 1 && XOR2(cf + ((res >> 6) & 0x2)),
							 F_OF);
d944 1
a944 1
	return (u8)res;
d951 2
a952 1
u16 rcl_word(u16 d, u8 s)
d954 1
a954 1
	register unsigned int res, cnt, mask, cf;
d956 13
a968 14
	res = d;
	if ((cnt = s % 17) != 0) {
		cf = (d >> (16 - cnt)) & 0x1;
		res = (d << cnt) & 0xffff;
		mask = (1 << (cnt - 1)) - 1;
		res |= (d >> (17 - cnt)) & mask;
		if (ACCESS_FLAG(F_CF)) {
			res |= 1 << (cnt - 1);
		}
		CONDITIONAL_SET_FLAG(cf, F_CF);
		CONDITIONAL_SET_FLAG(cnt == 1 && XOR2(cf + ((res >> 14) & 0x2)),
							 F_OF);
	}
	return (u16)res;
d975 2
a976 1
u32 rcl_long(u32 d, u8 s)
d978 1
a978 1
	register u32 res, cnt, mask, cf;
d980 13
a992 14
	res = d;
	if ((cnt = s % 33) != 0) {
		cf = (d >> (32 - cnt)) & 0x1;
		res = (d << cnt) & 0xffffffff;
		mask = (1 << (cnt - 1)) - 1;
		res |= (d >> (33 - cnt)) & mask;
		if (ACCESS_FLAG(F_CF)) {     /* carry flag is set */
			res |= 1 << (cnt - 1);
		}
		CONDITIONAL_SET_FLAG(cf, F_CF);
		CONDITIONAL_SET_FLAG(cnt == 1 && XOR2(cf + ((res >> 30) & 0x2)),
							 F_OF);
	}
	return res;
d999 2
a1000 1
u8 rcr_byte(u8 d, u8 s)
d1002 2
a1003 2
	u32	res, cnt;
	u32	mask, cf, ocf = 0;
d1005 1
a1005 1
	/* rotate right through carry */
d1026 3
a1028 3
	 */
	res = d;
	if ((cnt = s % 9) != 0) {
d1037 1
a1037 1
			   0..1 in any representation of the flags register
d1040 3
a1042 2
			ocf = ACCESS_FLAG(F_CF) != 0;
        } else
d1064 1
a1064 1
		if (ACCESS_FLAG(F_CF)) {     /* carry flag is set */
d1069 1
a1069 1
		CONDITIONAL_SET_FLAG(cf, F_CF);
d1073 5
a1077 6
		if (cnt == 1) {
			CONDITIONAL_SET_FLAG(XOR2(ocf + ((d >> 6) & 0x2)),
								 F_OF);
		}
	}
	return (u8)res;
d1084 2
a1085 1
u16 rcr_word(u16 d, u8 s)
d1087 2
a1088 2
	u32 res, cnt;
	u32	mask, cf, ocf = 0;
d1090 21
a1110 21
	/* rotate right through carry */
	res = d;
	if ((cnt = s % 17) != 0) {
		if (cnt == 1) {
			cf = d & 0x1;
			ocf = ACCESS_FLAG(F_CF) != 0;
		} else
			cf = (d >> (cnt - 1)) & 0x1;
		mask = (1 << (16 - cnt)) - 1;
		res = (d >> cnt) & mask;
		res |= (d << (17 - cnt));
		if (ACCESS_FLAG(F_CF)) {
			res |= 1 << (16 - cnt);
		}
		CONDITIONAL_SET_FLAG(cf, F_CF);
		if (cnt == 1) {
			CONDITIONAL_SET_FLAG(XOR2(ocf + ((d >> 14) & 0x2)),
								 F_OF);
		}
	}
	return (u16)res;
d1117 2
a1118 1
u32 rcr_long(u32 d, u8 s)
d1120 2
a1121 2
	u32 res, cnt;
	u32 mask, cf, ocf = 0;
d1123 22
a1144 22
	/* rotate right through carry */
	res = d;
	if ((cnt = s % 33) != 0) {
		if (cnt == 1) {
			cf = d & 0x1;
			ocf = ACCESS_FLAG(F_CF) != 0;
		} else
			cf = (d >> (cnt - 1)) & 0x1;
		mask = (1 << (32 - cnt)) - 1;
		res = (d >> cnt) & mask;
		if (cnt != 1)
			res |= (d << (33 - cnt));
		if (ACCESS_FLAG(F_CF)) {     /* carry flag is set */
			res |= 1 << (32 - cnt);
		}
		CONDITIONAL_SET_FLAG(cf, F_CF);
		if (cnt == 1) {
			CONDITIONAL_SET_FLAG(XOR2(ocf + ((d >> 30) & 0x2)),
								 F_OF);
		}
	}
	return res;
d1151 2
a1152 1
u8 rol_byte(u8 d, u8 s)
d1171 1
a1171 1
	 */
d1173 22
a1194 22
	if ((cnt = s % 8) != 0) {
		/* B_(7) .. B_(n)  <-  b_(8-(n+1)) .. b_(0) */
		res = (d << cnt);

		/* B_(n-1) .. B_(0) <-  b_(7) .. b_(8-n) */
		mask = (1 << cnt) - 1;
		res |= (d >> (8 - cnt)) & mask;

		/* set the new carry flag, Note that it is the low order
		   bit of the result!!!                               */
		CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
		/* OVERFLOW is set *IFF* s==1, then it is the
		   xor of CF and the most significant bit.  Blecck. */
		CONDITIONAL_SET_FLAG(s == 1 &&
							 XOR2((res & 0x1) + ((res >> 6) & 0x2)),
							 F_OF);
	} if (s != 0) {
		/* set the new carry flag, Note that it is the low order
		   bit of the result!!!                               */
		CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
	}
	return (u8)res;
d1201 2
a1202 1
u16 rol_word(u16 d, u8 s)
d1206 15
a1220 15
	res = d;
	if ((cnt = s % 16) != 0) {
		res = (d << cnt);
		mask = (1 << cnt) - 1;
		res |= (d >> (16 - cnt)) & mask;
		CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
		CONDITIONAL_SET_FLAG(s == 1 &&
							 XOR2((res & 0x1) + ((res >> 14) & 0x2)),
							 F_OF);
	} if (s != 0) {
		/* set the new carry flag, Note that it is the low order
		   bit of the result!!!                               */
		CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
	}
	return (u16)res;
d1227 2
a1228 1
u32 rol_long(u32 d, u8 s)
d1232 15
a1246 15
	res = d;
	if ((cnt = s % 32) != 0) {
		res = (d << cnt);
		mask = (1 << cnt) - 1;
		res |= (d >> (32 - cnt)) & mask;
		CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
		CONDITIONAL_SET_FLAG(s == 1 &&
							 XOR2((res & 0x1) + ((res >> 30) & 0x2)),
							 F_OF);
	} if (s != 0) {
		/* set the new carry flag, Note that it is the low order
		   bit of the result!!!                               */
		CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
	}
	return res;
d1253 2
a1254 1
u8 ror_byte(u8 d, u8 s)
d1272 3
a1274 3
	 */
	res = d;
	if ((cnt = s % 8) != 0) {           /* not a typo, do nada if cnt==0 */
d1284 2
a1285 2
		CONDITIONAL_SET_FLAG(res & 0x80, F_CF);
		/* OVERFLOW is set *IFF* s==1, then it is the
d1287 8
a1294 7
		CONDITIONAL_SET_FLAG(s == 1 && XOR2(res >> 6), F_OF);
	} else if (s != 0) {
		/* set the new carry flag, Note that it is the low order
		   bit of the result!!!                               */
		CONDITIONAL_SET_FLAG(res & 0x80, F_CF);
	}
	return (u8)res;
d1301 2
a1302 1
u16 ror_word(u16 d, u8 s)
d1306 14
a1319 13
	res = d;
	if ((cnt = s % 16) != 0) {
		res = (d << (16 - cnt));
		mask = (1 << (16 - cnt)) - 1;
		res |= (d >> (cnt)) & mask;
		CONDITIONAL_SET_FLAG(res & 0x8000, F_CF);
		CONDITIONAL_SET_FLAG(s == 1 && XOR2(res >> 14), F_OF);
	} else if (s != 0) {
		/* set the new carry flag, Note that it is the low order
		   bit of the result!!!                               */
		CONDITIONAL_SET_FLAG(res & 0x8000, F_CF);
	}
	return (u16)res;
d1326 2
a1327 1
u32 ror_long(u32 d, u8 s)
d1329 1
a1329 1
	register u32 res, cnt, mask;
d1331 14
a1344 13
	res = d;
	if ((cnt = s % 32) != 0) {
		res = (d << (32 - cnt));
		mask = (1 << (32 - cnt)) - 1;
		res |= (d >> (cnt)) & mask;
		CONDITIONAL_SET_FLAG(res & 0x80000000, F_CF);
		CONDITIONAL_SET_FLAG(s == 1 && XOR2(res >> 30), F_OF);
	} else if (s != 0) {
		/* set the new carry flag, Note that it is the low order
		   bit of the result!!!                               */
		CONDITIONAL_SET_FLAG(res & 0x80000000, F_CF);
	}
	return res;
d1351 2
a1352 1
u8 shl_byte(u8 d, u8 s)
d1354 4
a1357 1
	unsigned int cnt, res, cf;
d1359 12
a1370 2
	if (s < 8) {
		cnt = s % 8;
d1372 18
a1389 29
		/* last bit shifted out goes into carry flag */
		if (cnt > 0) {
			res = d << cnt;
			cf = d & (1 << (8 - cnt));
			CONDITIONAL_SET_FLAG(cf, F_CF);
			CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
			CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
		} else {
			res = (u8) d;
		}

		if (cnt == 1) {
			/* Needs simplification. */
			CONDITIONAL_SET_FLAG(
									(((res & 0x80) == 0x80) ^
									 (ACCESS_FLAG(F_CF) != 0)),
			/* was (M.x86.R_FLG&F_CF)==F_CF)), */
									F_OF);
		} else {
			CLEAR_FLAG(F_OF);
		}
	} else {
		res = 0;
		CONDITIONAL_SET_FLAG((d << (s-1)) & 0x80, F_CF);
		CLEAR_FLAG(F_OF);
		CLEAR_FLAG(F_SF);
		SET_FLAG(F_PF);
		SET_FLAG(F_ZF);
d1391 1
a1391 1
	return (u8)res;
d1398 2
a1399 1
u16 shl_word(u16 d, u8 s)
d1403 31
a1433 30
	if (s < 16) {
		cnt = s % 16;
		if (cnt > 0) {
			res = d << cnt;
			cf = d & (1 << (16 - cnt));
			CONDITIONAL_SET_FLAG(cf, F_CF);
			CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
			CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
		} else {
			res = (u16) d;
		}

		if (cnt == 1) {
			CONDITIONAL_SET_FLAG(
									(((res & 0x8000) == 0x8000) ^
									 (ACCESS_FLAG(F_CF) != 0)),
									F_OF);
        } else {
			CLEAR_FLAG(F_OF);
        }
    } else {
		res = 0;
		CONDITIONAL_SET_FLAG((d << (s-1)) & 0x8000, F_CF);
		CLEAR_FLAG(F_OF);
		CLEAR_FLAG(F_SF);
		SET_FLAG(F_PF);
		SET_FLAG(F_ZF);
	}
	return (u16)res;
d1440 2
a1441 1
u32 shl_long(u32 d, u8 s)
d1443 1
a1443 1
	unsigned int cnt, res, cf;
d1445 30
a1474 27
	if (s < 32) {
		cnt = s % 32;
		if (cnt > 0) {
			res = d << cnt;
			cf = d & (1 << (32 - cnt));
			CONDITIONAL_SET_FLAG(cf, F_CF);
			CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
			CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
		} else {
			res = d;
		}
		if (cnt == 1) {
			CONDITIONAL_SET_FLAG((((res & 0x80000000) == 0x80000000) ^
								  (ACCESS_FLAG(F_CF) != 0)), F_OF);
		} else {
			CLEAR_FLAG(F_OF);
		}
	} else {
		res = 0;
		CONDITIONAL_SET_FLAG((d << (s-1)) & 0x80000000, F_CF);
		CLEAR_FLAG(F_OF);
		CLEAR_FLAG(F_SF);
		SET_FLAG(F_PF);
		SET_FLAG(F_ZF);
	}
	return res;
d1481 2
a1482 1
u8 shr_byte(u8 d, u8 s)
d1484 15
a1498 1
	unsigned int cnt, res, cf;
d1500 16
a1515 27
	if (s < 8) {
		cnt = s % 8;
		if (cnt > 0) {
			cf = d & (1 << (cnt - 1));
			res = d >> cnt;
			CONDITIONAL_SET_FLAG(cf, F_CF);
			CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
			CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
		} else {
			res = (u8) d;
		}

		if (cnt == 1) {
			CONDITIONAL_SET_FLAG(XOR2(res >> 6), F_OF);
		} else {
			CLEAR_FLAG(F_OF);
		}
	} else {
		res = 0;
		CONDITIONAL_SET_FLAG((d >> (s-1)) & 0x1, F_CF);
		CLEAR_FLAG(F_OF);
		CLEAR_FLAG(F_SF);
		SET_FLAG(F_PF);
		SET_FLAG(F_ZF);
	}
	return (u8)res;
d1522 2
a1523 1
u16 shr_word(u16 d, u8 s)
d1525 1
a1525 1
	unsigned int cnt, res, cf;
d1527 28
a1554 25
	if (s < 16) {
		cnt = s % 16;
		if (cnt > 0) {
			cf = d & (1 << (cnt - 1));
			res = d >> cnt;
			CONDITIONAL_SET_FLAG(cf, F_CF);
			CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
			CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
		} else {
			res = d;
		}

		if (cnt == 1) {
			CONDITIONAL_SET_FLAG(XOR2(res >> 14), F_OF);
        } else {
			CLEAR_FLAG(F_OF);
        }
	} else {
		res = 0;
		CLEAR_FLAG(F_CF);
		CLEAR_FLAG(F_OF);
		SET_FLAG(F_ZF);
		CLEAR_FLAG(F_SF);
		CLEAR_FLAG(F_PF);
d1556 1
a1556 1
	return (u16)res;
d1563 2
a1564 1
u32 shr_long(u32 d, u8 s)
d1566 1
a1566 1
	unsigned int cnt, res, cf;
d1568 11
a1578 10
	if (s < 32) {
		cnt = s % 32;
		if (cnt > 0) {
			cf = d & (1 << (cnt - 1));
			res = d >> cnt;
			CONDITIONAL_SET_FLAG(cf, F_CF);
			CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
			CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
        } else {
d1582 4
a1585 3
			CONDITIONAL_SET_FLAG(XOR2(res >> 30), F_OF);
        } else {
			CLEAR_FLAG(F_OF);
d1587 2
a1588 1
    } else {
d1590 5
a1594 5
		CLEAR_FLAG(F_CF);
		CLEAR_FLAG(F_OF);
		SET_FLAG(F_ZF);
		CLEAR_FLAG(F_SF);
		CLEAR_FLAG(F_PF);
d1603 2
a1604 1
u8 sar_byte(u8 d, u8 s)
d1606 1
a1606 1
	unsigned int cnt, res, cf, mask, sf;
d1608 2
a1609 2
	res = d;
	sf = d & 0x80;
d1611 13
a1623 12
	if (cnt > 0 && cnt < 8) {
		mask = (1 << (8 - cnt)) - 1;
		cf = d & (1 << (cnt - 1));
		res = (d >> cnt) & mask;
		CONDITIONAL_SET_FLAG(cf, F_CF);
		if (sf) {
			res |= ~mask;
		}
		CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
		CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
		CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
    } else if (cnt >= 8) {
d1626 14
a1639 13
			SET_FLAG(F_CF);
			CLEAR_FLAG(F_ZF);
			SET_FLAG(F_SF);
			SET_FLAG(F_PF);
		} else {
			res = 0;
			CLEAR_FLAG(F_CF);
			SET_FLAG(F_ZF);
			CLEAR_FLAG(F_SF);
			CLEAR_FLAG(F_PF);
		}
	}
	return (u8)res;
d1646 2
a1647 1
u16 sar_word(u16 d, u8 s)
d1653 2
a1654 2
	res = d;
	if (cnt > 0 && cnt < 16) {
d1658 1
a1658 1
		CONDITIONAL_SET_FLAG(cf, F_CF);
d1662 5
a1666 4
		CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
		CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
		CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    } else if (cnt >= 16) {
d1669 6
a1674 5
			SET_FLAG(F_CF);
			CLEAR_FLAG(F_ZF);
			SET_FLAG(F_SF);
			SET_FLAG(F_PF);
        } else {
d1676 4
a1679 4
			CLEAR_FLAG(F_CF);
			SET_FLAG(F_ZF);
			CLEAR_FLAG(F_SF);
			CLEAR_FLAG(F_PF);
d1682 1
a1682 1
	return (u16)res;
d1689 2
a1690 1
u32 sar_long(u32 d, u8 s)
d1696 2
a1697 2
	res = d;
	if (cnt > 0 && cnt < 32) {
d1699 1
a1699 1
		cf = d & (1 << (cnt - 1));
d1701 1
a1701 1
		CONDITIONAL_SET_FLAG(cf, F_CF);
d1705 5
a1709 4
		CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
		CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
		CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
    } else if (cnt >= 32) {
d1712 14
a1725 13
			SET_FLAG(F_CF);
			CLEAR_FLAG(F_ZF);
			SET_FLAG(F_SF);
			SET_FLAG(F_PF);
		} else {
			res = 0;
			CLEAR_FLAG(F_CF);
			SET_FLAG(F_ZF);
			CLEAR_FLAG(F_SF);
			CLEAR_FLAG(F_PF);
		}
	}
	return res;
d1732 2
a1733 1
u16 shld_word (u16 d, u16 fill, u8 s)
d1735 1
a1735 1
	unsigned int cnt, res, cf;
d1737 30
a1766 27
	if (s < 16) {
		cnt = s % 16;
		if (cnt > 0) {
			res = (d << cnt) | (fill >> (16-cnt));
			cf = d & (1 << (16 - cnt));
			CONDITIONAL_SET_FLAG(cf, F_CF);
			CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
			CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
		} else {
			res = d;
		}
		if (cnt == 1) {
			CONDITIONAL_SET_FLAG((((res & 0x8000) == 0x8000) ^
								  (ACCESS_FLAG(F_CF) != 0)), F_OF);
		} else {
			CLEAR_FLAG(F_OF);
		}
	} else {
		res = 0;
		CONDITIONAL_SET_FLAG((d << (s-1)) & 0x8000, F_CF);
		CLEAR_FLAG(F_OF);
		CLEAR_FLAG(F_SF);
		SET_FLAG(F_PF);
		SET_FLAG(F_ZF);
	}
	return (u16)res;
d1773 2
a1774 1
u32 shld_long (u32 d, u32 fill, u8 s)
d1776 1
a1776 1
	unsigned int cnt, res, cf;
d1778 30
a1807 27
	if (s < 32) {
		cnt = s % 32;
		if (cnt > 0) {
			res = (d << cnt) | (fill >> (32-cnt));
			cf = d & (1 << (32 - cnt));
			CONDITIONAL_SET_FLAG(cf, F_CF);
			CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
			CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
		} else {
			res = d;
		}
		if (cnt == 1) {
			CONDITIONAL_SET_FLAG((((res & 0x80000000) == 0x80000000) ^
								  (ACCESS_FLAG(F_CF) != 0)), F_OF);
		} else {
			CLEAR_FLAG(F_OF);
		}
	} else {
		res = 0;
		CONDITIONAL_SET_FLAG((d << (s-1)) & 0x80000000, F_CF);
		CLEAR_FLAG(F_OF);
		CLEAR_FLAG(F_SF);
		SET_FLAG(F_PF);
		SET_FLAG(F_ZF);
	}
	return res;
d1814 2
a1815 1
u16 shrd_word (u16 d, u16 fill, u8 s)
d1817 1
a1817 1
	unsigned int cnt, res, cf;
d1819 20
a1838 25
	if (s < 16) {
		cnt = s % 16;
		if (cnt > 0) {
			cf = d & (1 << (cnt - 1));
			res = (d >> cnt) | (fill << (16 - cnt));
			CONDITIONAL_SET_FLAG(cf, F_CF);
			CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
			CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
		} else {
			res = d;
		}

		if (cnt == 1) {
			CONDITIONAL_SET_FLAG(XOR2(res >> 14), F_OF);
        } else {
			CLEAR_FLAG(F_OF);
        }
	} else {
		res = 0;
		CLEAR_FLAG(F_CF);
		CLEAR_FLAG(F_OF);
		SET_FLAG(F_ZF);
		CLEAR_FLAG(F_SF);
		CLEAR_FLAG(F_PF);
d1840 9
a1848 1
	return (u16)res;
d1855 2
a1856 1
u32 shrd_long (u32 d, u32 fill, u8 s)
d1858 1
a1858 1
	unsigned int cnt, res, cf;
d1860 19
a1878 24
	if (s < 32) {
		cnt = s % 32;
		if (cnt > 0) {
			cf = d & (1 << (cnt - 1));
			res = (d >> cnt) | (fill << (32 - cnt));
			CONDITIONAL_SET_FLAG(cf, F_CF);
			CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
			CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
		} else {
			res = d;
		}
		if (cnt == 1) {
			CONDITIONAL_SET_FLAG(XOR2(res >> 30), F_OF);
        } else {
			CLEAR_FLAG(F_OF);
        }
	} else {
		res = 0;
		CLEAR_FLAG(F_CF);
		CLEAR_FLAG(F_OF);
		SET_FLAG(F_ZF);
		CLEAR_FLAG(F_SF);
		CLEAR_FLAG(F_PF);
d1880 9
a1888 1
	return res;
d1895 2
a1896 1
u8 sbb_byte(u8 d, u8 s)
d1898 1
a1898 1
    register u32 res;   /* all operands in native machine order */
d1901 14
a1914 14
	if (ACCESS_FLAG(F_CF))
		res = d - s - 1;
	else
		res = d - s;
	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the borrow chain.  See note at top */
	bc = (res & (~d | s)) | (~d & s);
	CONDITIONAL_SET_FLAG(bc & 0x80, F_CF);
	CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
	return (u8)res;
d1921 2
a1922 1
u16 sbb_word(u16 d, u16 s)
d1924 1
a1924 1
    register u32 res;   /* all operands in native machine order */
d1927 1
a1927 1
	if (ACCESS_FLAG(F_CF))
d1931 10
a1940 10
	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the borrow chain.  See note at top */
	bc = (res & (~d | s)) | (~d & s);
	CONDITIONAL_SET_FLAG(bc & 0x8000, F_CF);
	CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
	return (u16)res;
d1947 2
a1948 1
u32 sbb_long(u32 d, u32 s)
d1950 2
a1951 2
	register u32 res;   /* all operands in native machine order */
	register u32 bc;
d1953 1
a1953 1
	if (ACCESS_FLAG(F_CF))
d1957 10
a1966 10
	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the borrow chain.  See note at top */
	bc = (res & (~d | s)) | (~d & s);
	CONDITIONAL_SET_FLAG(bc & 0x80000000, F_CF);
	CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
	return res;
d1973 2
a1974 1
u8 sub_byte(u8 d, u8 s)
d1976 7
a1982 2
	register u32 res;   /* all operands in native machine order */
	register u32 bc;
d1984 6
a1989 11
	res = d - s;
	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the borrow chain.  See note at top */
	bc = (res & (~d | s)) | (~d & s);
	CONDITIONAL_SET_FLAG(bc & 0x80, F_CF);
	CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
	return (u8)res;
d1996 2
a1997 1
u16 sub_word(u16 d, u16 s)
d1999 1
a1999 1
    register u32 res;   /* all operands in native machine order */
d2003 10
a2012 10
	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the borrow chain.  See note at top */
	bc = (res & (~d | s)) | (~d & s);
	CONDITIONAL_SET_FLAG(bc & 0x8000, F_CF);
	CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
	return (u16)res;
d2019 2
a2020 1
u32 sub_long(u32 d, u32 s)
d2022 2
a2023 2
	register u32 res;   /* all operands in native machine order */
	register u32 bc;
d2025 11
a2035 11
	res = d - s;
	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);

	/* calculate the borrow chain.  See note at top */
	bc = (res & (~d | s)) | (~d & s);
	CONDITIONAL_SET_FLAG(bc & 0x80000000, F_CF);
	CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
	return res;
d2042 2
a2043 1
void test_byte(u8 d, u8 s)
d2045 1
a2045 1
    register u32 res;   /* all operands in native machine order */
d2049 4
a2052 4
	CLEAR_FLAG(F_OF);
	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
d2054 1
a2054 1
	CLEAR_FLAG(F_CF);
d2061 2
a2062 1
void test_word(u16 d, u16 s)
d2064 1
a2064 1
	register u32 res;   /* all operands in native machine order */
d2066 1
a2066 1
	res = d & s;
d2068 6
a2073 6
	CLEAR_FLAG(F_OF);
	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
	/* AF == dont care */
	CLEAR_FLAG(F_CF);
d2080 2
a2081 1
void test_long(u32 d, u32 s)
d2083 1
a2083 1
	register u32 res;   /* all operands in native machine order */
d2085 1
a2085 1
	res = d & s;
d2087 6
a2092 6
	CLEAR_FLAG(F_OF);
	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
	/* AF == dont care */
	CLEAR_FLAG(F_CF);
d2099 2
a2100 1
u8 xor_byte(u8 d, u8 s)
d2102 1
a2102 1
	register u8 res;    /* all operands in native machine order */
d2104 8
a2111 8
	res = d ^ s;
	CLEAR_FLAG(F_OF);
	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
	CLEAR_FLAG(F_CF);
	CLEAR_FLAG(F_AF);
	return res;
d2118 2
a2119 1
u16 xor_word(u16 d, u16 s)
d2121 1
a2121 1
	register u16 res;   /* all operands in native machine order */
d2123 8
a2130 8
	res = d ^ s;
	CLEAR_FLAG(F_OF);
	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
	CLEAR_FLAG(F_CF);
	CLEAR_FLAG(F_AF);
	return res;
d2137 2
a2138 1
u32 xor_long(u32 d, u32 s)
d2140 1
a2140 1
	register u32 res;   /* all operands in native machine order */
d2142 8
a2149 8
	res = d ^ s;
	CLEAR_FLAG(F_OF);
	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
	CLEAR_FLAG(F_CF);
	CLEAR_FLAG(F_AF);
	return res;
d2156 2
a2157 1
void imul_byte(u8 s)
d2159 1
a2159 1
	s16 res = (s16)((s8)M.x86.R_AL * (s8)s);
d2161 10
a2170 9
	M.x86.R_AX = res;
	if (((M.x86.R_AL & 0x80) == 0 && M.x86.R_AH == 0x00) ||
		((M.x86.R_AL & 0x80) != 0 && M.x86.R_AH == 0xFF)) {
		CLEAR_FLAG(F_CF);
		CLEAR_FLAG(F_OF);
	} else {
		SET_FLAG(F_CF);
		SET_FLAG(F_OF);
	}
d2177 2
a2178 1
void imul_word(u16 s)
d2180 1
a2180 1
	s32 res = (s16)M.x86.R_AX * (s16)s;
d2182 11
a2192 10
	M.x86.R_AX = (u16)res;
	M.x86.R_DX = (u16)(res >> 16);
	if (((M.x86.R_AX & 0x8000) == 0 && M.x86.R_DX == 0x00) ||
		((M.x86.R_AX & 0x8000) != 0 && M.x86.R_DX == 0xFF)) {
		CLEAR_FLAG(F_CF);
		CLEAR_FLAG(F_OF);
	} else {
		SET_FLAG(F_CF);
		SET_FLAG(F_OF);
	}
d2199 2
a2200 1
void imul_long_direct(u32 *res_lo, u32* res_hi,u32 d, u32 s)
d2203 1
a2203 1
	s64 res = (s64)(s32)d * (s32)s;
d2205 2
a2206 2
	*res_lo = (u32)res;
	*res_hi = (u32)(res >> 32);
d2208 23
a2230 23
	u32	d_lo,d_hi,d_sign;
	u32	s_lo,s_hi,s_sign;
	u32	rlo_lo,rlo_hi,rhi_lo;

	if ((d_sign = d & 0x80000000) != 0)
		d = -d;
	d_lo = d & 0xFFFF;
	d_hi = d >> 16;
	if ((s_sign = s & 0x80000000) != 0)
		s = -s;
	s_lo = s & 0xFFFF;
	s_hi = s >> 16;
	rlo_lo = d_lo * s_lo;
	rlo_hi = (d_hi * s_lo + d_lo * s_hi) + (rlo_lo >> 16);
	rhi_lo = d_hi * s_hi + (rlo_hi >> 16);
	*res_lo = (rlo_hi << 16) | (rlo_lo & 0xFFFF);
	*res_hi = rhi_lo;
	if (d_sign != s_sign) {
		d = ~*res_lo;
		s = (((d & 0xFFFF) + 1) >> 16) + (d >> 16);
		*res_lo = ~*res_lo+1;
		*res_hi = ~*res_hi+(s >> 16);
		}
d2238 2
a2239 1
void imul_long(u32 s)
d2241 10
a2250 9
	imul_long_direct(&M.x86.R_EAX,&M.x86.R_EDX,M.x86.R_EAX,s);
	if (((M.x86.R_EAX & 0x80000000) == 0 && M.x86.R_EDX == 0x00) ||
		((M.x86.R_EAX & 0x80000000) != 0 && M.x86.R_EDX == 0xFF)) {
		CLEAR_FLAG(F_CF);
		CLEAR_FLAG(F_OF);
	} else {
		SET_FLAG(F_CF);
		SET_FLAG(F_OF);
	}
d2257 2
a2258 1
void mul_byte(u8 s)
d2260 1
a2260 1
	u16 res = (u16)(M.x86.R_AL * s);
d2262 9
a2270 8
	M.x86.R_AX = res;
	if (M.x86.R_AH == 0) {
		CLEAR_FLAG(F_CF);
		CLEAR_FLAG(F_OF);
	} else {
		SET_FLAG(F_CF);
		SET_FLAG(F_OF);
	}
d2277 2
a2278 1
void mul_word(u16 s)
d2280 1
a2280 1
	u32 res = M.x86.R_AX * s;
d2282 9
a2290 8
	M.x86.R_AX = (u16)res;
	M.x86.R_DX = (u16)(res >> 16);
	if (M.x86.R_DX == 0) {
		CLEAR_FLAG(F_CF);
		CLEAR_FLAG(F_OF);
    } else {
		SET_FLAG(F_CF);
		SET_FLAG(F_OF);
d2298 2
a2299 1
void mul_long(u32 s)
d2302 1
a2302 1
	u64 res = (u64)M.x86.R_EAX * s;
d2304 2
a2305 2
	M.x86.R_EAX = (u32)res;
	M.x86.R_EDX = (u32)(res >> 32);
d2307 14
a2320 14
	u32	a,a_lo,a_hi;
	u32	s_lo,s_hi;
	u32	rlo_lo,rlo_hi,rhi_lo;

	a = M.x86.R_EAX;
	a_lo = a & 0xFFFF;
	a_hi = a >> 16;
	s_lo = s & 0xFFFF;
	s_hi = s >> 16;
	rlo_lo = a_lo * s_lo;
	rlo_hi = (a_hi * s_lo + a_lo * s_hi) + (rlo_lo >> 16);
	rhi_lo = a_hi * s_hi + (rlo_hi >> 16);
	M.x86.R_EAX = (rlo_hi << 16) | (rlo_lo & 0xFFFF);
	M.x86.R_EDX = rhi_lo;
d2323 7
a2329 6
	if (M.x86.R_EDX == 0) {
		CLEAR_FLAG(F_CF);
		CLEAR_FLAG(F_OF);
	} else {
		SET_FLAG(F_CF);
		SET_FLAG(F_OF);
d2337 2
a2338 1
void idiv_byte(u8 s)
d2342 3
a2344 3
	dvd = (s16)M.x86.R_AX;
	if (s == 0) {
		x86emu_intr_raise(0);
d2346 9
a2354 9
	}
	div = dvd / (s8)s;
	mod = dvd % (s8)s;
	if (abs(div) > 0x7f) {
		x86emu_intr_raise(0);
		return;
	}
	M.x86.R_AL = (s8) div;
	M.x86.R_AH = (s8) mod;
d2361 2
a2362 1
void idiv_word(u16 s)
d2364 1
a2364 1
	s32 dvd, div, mod;
d2366 15
a2380 15
	dvd = (((s32)M.x86.R_DX) << 16) | M.x86.R_AX;
	if (s == 0) {
		x86emu_intr_raise(0);
		return;
	}
	div = dvd / (s16)s;
	mod = dvd % (s16)s;
	if (abs(div) > 0x7fff) {
		x86emu_intr_raise(0);
		return;
	}
	CLEAR_FLAG(F_CF);
	CLEAR_FLAG(F_SF);
	CONDITIONAL_SET_FLAG(div == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);
d2382 2
a2383 2
	M.x86.R_AX = (u16)div;
	M.x86.R_DX = (u16)mod;
d2390 2
a2391 1
void idiv_long(u32 s)
d2394 1
a2394 1
	s64 dvd, div, mod;
d2396 11
a2406 11
	dvd = (((s64)M.x86.R_EDX) << 32) | M.x86.R_EAX;
	if (s == 0) {
		x86emu_intr_raise(0);
		return;
	}
	div = dvd / (s32)s;
	mod = dvd % (s32)s;
	if (abs(div) > 0x7fffffff) {
		x86emu_intr_raise(0);
		return;
	}
d2408 42
a2449 41
	s32 div = 0, mod;
	s32 h_dvd = M.x86.R_EDX;
	u32 l_dvd = M.x86.R_EAX;
	u32 abs_s = s & 0x7FFFFFFF;
	u32 abs_h_dvd = h_dvd & 0x7FFFFFFF;
	u32 h_s = abs_s >> 1;
	u32 l_s = abs_s << 31;
	int counter = 31;
	int carry;

	if (s == 0) {
		x86emu_intr_raise(0);
		return;
	}
	do {
		div <<= 1;
		carry = (l_dvd >= l_s) ? 0 : 1;
		
		if (abs_h_dvd < (h_s + carry)) {
			h_s >>= 1;
			l_s = abs_s << (--counter);
			continue;
		} else {
			abs_h_dvd -= (h_s + carry);
			l_dvd = carry ? ((0xFFFFFFFF - l_s) + l_dvd + 1)
				: (l_dvd - l_s);
			h_s >>= 1;
			l_s = abs_s << (--counter);
			div |= 1;
			continue;
		}
		
	} while (counter > -1);
	/* overflow */
	if (abs_h_dvd || (l_dvd > abs_s)) {
		x86emu_intr_raise(0);
		return;
	}
	/* sign */
	div |= ((h_dvd & 0x10000000) ^ (s & 0x10000000));
	mod = l_dvd;
d2452 5
a2456 5
	CLEAR_FLAG(F_CF);
	CLEAR_FLAG(F_AF);
	CLEAR_FLAG(F_SF);
	SET_FLAG(F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);
d2458 2
a2459 2
	M.x86.R_EAX = (u32)div;
	M.x86.R_EDX = (u32)mod;
d2466 2
a2467 1
void div_byte(u8 s)
d2469 1
a2469 1
	u32 dvd, div, mod;
d2471 1
a2471 1
	dvd = M.x86.R_AX;
d2473 1
a2473 1
		x86emu_intr_raise(0);
d2476 4
a2479 4
	div = dvd / (u8)s;
	mod = dvd % (u8)s;
	if (abs(div) > 0xff) {
		x86emu_intr_raise(0);
d2481 3
a2483 3
	}
	M.x86.R_AL = (u8)div;
	M.x86.R_AH = (u8)mod;
d2490 2
a2491 1
void div_word(u16 s)
d2493 1
a2493 1
	u32 dvd, div, mod;
d2495 9
a2503 3
	dvd = (((u32)M.x86.R_DX) << 16) | M.x86.R_AX;
	if (s == 0) {
		x86emu_intr_raise(0);
d2506 4
a2509 10
	div = dvd / (u16)s;
	mod = dvd % (u16)s;
	if (abs(div) > 0xffff) {
		x86emu_intr_raise(0);
		return;
	}
	CLEAR_FLAG(F_CF);
	CLEAR_FLAG(F_SF);
	CONDITIONAL_SET_FLAG(div == 0, F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);
d2511 2
a2512 2
	M.x86.R_AX = (u16)div;
	M.x86.R_DX = (u16)mod;
d2519 2
a2520 1
void div_long(u32 s)
d2523 1
a2523 1
	u64 dvd, div, mod;
d2525 11
a2535 11
	dvd = (((u64)M.x86.R_EDX) << 32) | M.x86.R_EAX;
	if (s == 0) {
		x86emu_intr_raise(0);
		return;
	}
	div = dvd / (u32)s;
	mod = dvd % (u32)s;
	if (abs(div) > 0xffffffff) {
		x86emu_intr_raise(0);
		return;
	}
d2537 39
a2575 38
	s32 div = 0, mod;
	s32 h_dvd = M.x86.R_EDX;
	u32 l_dvd = M.x86.R_EAX;

	u32 h_s = s;
	u32 l_s = 0;
	int counter = 32;
	int carry;
		
	if (s == 0) {
		x86emu_intr_raise(0);
		return;
	}
	do {
		div <<= 1;
		carry = (l_dvd >= l_s) ? 0 : 1;
		
		if (h_dvd < (h_s + carry)) {
			h_s >>= 1;
			l_s = s << (--counter);
			continue;
		} else {
			h_dvd -= (h_s + carry);
			l_dvd = carry ? ((0xFFFFFFFF - l_s) + l_dvd + 1)
				: (l_dvd - l_s);
			h_s >>= 1;
			l_s = s << (--counter);
			div |= 1;
			continue;
		}
		
	} while (counter > -1);
	/* overflow */
	if (h_dvd || (l_dvd > s)) {
		x86emu_intr_raise(0);
		return;
	}
	mod = l_dvd;
d2577 5
a2581 5
	CLEAR_FLAG(F_CF);
	CLEAR_FLAG(F_AF);
	CLEAR_FLAG(F_SF);
	SET_FLAG(F_ZF);
	CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);
d2583 2
a2584 2
	M.x86.R_EAX = (u32)div;
	M.x86.R_EDX = (u32)mod;
d2591 2
a2592 1
void ins(int size)
d2594 1
a2594 1
	int inc = size;
d2596 4
a2599 4
	if (ACCESS_FLAG(F_DF)) {
		inc = -size;
	}
	if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {
d2602 2
a2603 2
		u32 count = ((M.x86.mode & SYSMODE_PREFIX_DATA) ?
					 M.x86.R_ECX : M.x86.R_CX);
d2605 1
a2605 1
          case 1:
d2607 3
a2609 3
				store_data_byte_abs(M.x86.R_ES, M.x86.R_DI,
									(*sys_inb)(M.x86.R_DX));
				M.x86.R_DI += inc;
d2613 1
a2613 1
          case 2:
d2615 3
a2617 3
				store_data_word_abs(M.x86.R_ES, M.x86.R_DI,
									(*sys_inw)(M.x86.R_DX));
				M.x86.R_DI += inc;
d2620 1
a2620 1
          case 4:
d2622 3
a2624 3
				store_data_long_abs(M.x86.R_ES, M.x86.R_DI,
									(*sys_inl)(M.x86.R_DX));
				M.x86.R_DI += inc;
d2628 3
a2630 3
		M.x86.R_CX = 0;
		if (M.x86.mode & SYSMODE_PREFIX_DATA) {
			M.x86.R_ECX = 0;
d2632 3
a2634 2
		M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
    } else {
d2636 3
a2638 3
          case 1:
			store_data_byte_abs(M.x86.R_ES, M.x86.R_DI,
								(*sys_inb)(M.x86.R_DX));
d2640 3
a2642 3
          case 2:
			store_data_word_abs(M.x86.R_ES, M.x86.R_DI,
								(*sys_inw)(M.x86.R_DX));
d2644 3
a2646 3
          case 4:
			store_data_long_abs(M.x86.R_ES, M.x86.R_DI,
								(*sys_inl)(M.x86.R_DX));
d2649 1
a2649 1
		M.x86.R_DI += inc;
d2657 2
a2658 1
void outs(int size)
d2662 1
a2662 1
	if (ACCESS_FLAG(F_DF)) {
d2665 1
a2665 1
	if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {
d2668 2
a2669 2
		u32 count = ((M.x86.mode & SYSMODE_PREFIX_DATA) ?
					 M.x86.R_ECX : M.x86.R_CX);
d2671 1
a2671 1
          case 1:
d2673 3
a2675 3
				(*sys_outb)(M.x86.R_DX,
						 fetch_data_byte_abs(M.x86.R_ES, M.x86.R_SI));
				M.x86.R_SI += inc;
d2679 1
a2679 1
          case 2:
d2681 3
a2683 3
				(*sys_outw)(M.x86.R_DX,
						 fetch_data_word_abs(M.x86.R_ES, M.x86.R_SI));
				M.x86.R_SI += inc;
d2686 1
a2686 1
          case 4:
d2688 3
a2690 3
				(*sys_outl)(M.x86.R_DX,
						 fetch_data_long_abs(M.x86.R_ES, M.x86.R_SI));
				M.x86.R_SI += inc;
d2694 3
a2696 3
		M.x86.R_CX = 0;
		if (M.x86.mode & SYSMODE_PREFIX_DATA) {
			M.x86.R_ECX = 0;
d2698 3
a2700 2
		M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
    } else {
d2702 3
a2704 3
          case 1:
			(*sys_outb)(M.x86.R_DX,
					 fetch_data_byte_abs(M.x86.R_ES, M.x86.R_SI));
d2706 3
a2708 3
          case 2:
			(*sys_outw)(M.x86.R_DX,
					 fetch_data_word_abs(M.x86.R_ES, M.x86.R_SI));
d2710 3
a2712 3
          case 4:
			(*sys_outl)(M.x86.R_DX,
					 fetch_data_long_abs(M.x86.R_ES, M.x86.R_SI));
d2715 1
a2715 1
		M.x86.R_SI += inc;
d2726 2
a2727 1
u16 mem_access_word(int addr)
d2729 3
a2731 3
DB(	if (CHECK_MEM_ACCESS())
	  x86emu_check_mem_access(addr);)
	return (*sys_rdw)(addr);
d2740 2
a2741 1
void push_word(u16 w)
d2743 4
a2746 4
DB(	if (CHECK_SP_ACCESS())
	  x86emu_check_sp_access();)
	M.x86.R_SP -= 2;
	(*sys_wrw)(((u32)M.x86.R_SS << 4)  + M.x86.R_SP, w);
d2755 2
a2756 1
void push_long(u32 w)
d2758 4
a2761 4
DB(	if (CHECK_SP_ACCESS())
	  x86emu_check_sp_access();)
	M.x86.R_SP -= 4;
	(*sys_wrl)(((u32)M.x86.R_SS << 4)  + M.x86.R_SP, w);
d2770 2
a2771 1
u16 pop_word(void)
d2773 1
a2773 1
	register u16 res;
d2775 5
a2779 5
DB(	if (CHECK_SP_ACCESS())
	  x86emu_check_sp_access();)
	res = (*sys_rdw)(((u32)M.x86.R_SS << 4)  + M.x86.R_SP);
	M.x86.R_SP += 2;
	return res;
d2788 2
a2789 1
u32 pop_long(void)
d2793 4
a2796 4
DB(	if (CHECK_SP_ACCESS())
	  x86emu_check_sp_access();)
	res = (*sys_rdl)(((u32)M.x86.R_SS << 4)  + M.x86.R_SP);
	M.x86.R_SP += 4;
d2804 2
a2805 1
void cpuid (void)
d2815 1
a2815 1
	hw_cpuid(&M.x86.R_EAX, &M.x86.R_EBX, &M.x86.R_ECX, &M.x86.R_EDX);
d2821 3
a2823 3
	 * will only support upto feature 1, which we set in register EAX.
	 * Registers EBX:EDX:ECX contain a string identifying the CPU.
	 */
d2835 2
a2836 2
	 * Intel 486dx4; which was one of the first processors to have CPUID.
	 */
d2840 1
a2840 1
        M.x86.R_EDX = 0x00000002;	/* VME */
d2843 2
a2844 2
	 * that the features reported are limited to TSC and VME.
	 */
d2850 3
a2852 3
	 * return all zeros when queried for invalid or unsupported feature
	 * numbers.
	 */
a2859 1

@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d106 1
a106 1
# if defined (__i386__) || defined(__i386) || defined(__AMD64__) || defined(__x86_64__) || defined(__amd64__) || defined(__x86_64__)
@


1.2
log
@Pull in a patch from X.Org-current to let X11 run on AMD Geode LX
CPUs in basic VESA mode:

X86EMU: handle CPUID instruction

Starting X on an AMD Geode LX system such as an Alix board with VGA
connector, the Xorg driver attempts to issue INT 10/0 to go to mode
3 (VGA).  The emulator, running the BIOS code, would then spit out:

	c000:0282: A2 ILLEGAL EXTENDED X86 OPCODE!

The opcode was 0F A2, or CPUID; it was not implemented in the
emulator. With this patch it handles the CPUID instruction in one of
two ways:

1) if ran on __i386__ or __x86_64__ then it calls the CPUID instruction
   directly.

2) if ran elsewhere it returns a canned 486dx4 set of values for function 1.

Tested with & ok matthieu
@
text
@d106 1
a106 1
# if defined (__i386__) || defined(__i386) || defined(__AMD64__) || defined(__x86_64__) || defined(__amd64__)
@


1.1
log
@Initial revision
@
text
@d105 6
d2091 1
a2091 1
	s64 res = (s32)d * (s32)s;
d2183 1
a2183 1
	u64 res = (u32)M.x86.R_EAX * (u32)s;
d2661 60
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2085 1
a2085 1
	s64 res = (s64)(s32)d * (s32)s;
d2177 1
a2177 1
	u64 res = (u64)M.x86.R_EAX * s;
@

