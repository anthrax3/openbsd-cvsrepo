head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.4
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.2.0.14
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.12
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.10
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.8
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.18
	OPENBSD_5_0:1.1.1.2.0.16
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.12
	OPENBSD_4_9_BASE:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.14
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.3;
commitid	7pAEtF6Y5EgemkuY;

1.3
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.2;
commitid	Te1daavkBLskZ8gc;

1.2
date	2012.06.10.13.21.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.18.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.18.20;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.58;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@/****************************************************************************
*
*						Realmode X86 Emulator Library
*
*            	Copyright (C) 1996-1999 SciTech Software, Inc.
* 				     Copyright (C) David Mosberger-Tang
* 					   Copyright (C) 1999 Egbert Eich
*
*  ========================================================================
*
*  Permission to use, copy, modify, distribute, and sell this software and
*  its documentation for any purpose is hereby granted without fee,
*  provided that the above copyright notice appear in all copies and that
*  both that copyright notice and this permission notice appear in
*  supporting documentation, and that the name of the authors not be used
*  in advertising or publicity pertaining to distribution of the software
*  without specific, written prior permission.  The authors makes no
*  representations about the suitability of this software for any purpose.
*  It is provided "as is" without express or implied warranty.
*
*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
*  PERFORMANCE OF THIS SOFTWARE.
*
*  ========================================================================
*
* Language:		ANSI C
* Environment:	Any
* Developer:    Kendall Bennett
*
* Description:  This file contains the code to handle debugging of the
*				emulator.
*
****************************************************************************/

#include "x86emu/x86emui.h"
#include <stdio.h>
#include <string.h>
#ifndef NO_SYS_HEADERS
#include <stdarg.h>
#include <stdlib.h>
#endif

/*----------------------------- Implementation ----------------------------*/

#ifdef DEBUG

static void print_encoded_bytes(u16 s, u16 o);
static void print_decoded_instruction(void);
static int parse_line(char *s, int *ps, int *n);

/* should look something like debug's output. */
void
X86EMU_trace_regs(void)
{
    if (DEBUG_TRACE()) {
        x86emu_dump_regs();
    }
    if (DEBUG_DECODE() && !DEBUG_DECODE_NOPRINT()) {
        printk("%04x:%04x ", M.x86.saved_cs, M.x86.saved_ip);
        print_encoded_bytes(M.x86.saved_cs, M.x86.saved_ip);
        print_decoded_instruction();
    }
}

void
X86EMU_trace_xregs(void)
{
    if (DEBUG_TRACE()) {
        x86emu_dump_xregs();
    }
}

void
x86emu_just_disassemble(void)
{
    /*
     * This routine called if the flag DEBUG_DISASSEMBLE is set kind
     * of a hack!
     */
    printk("%04x:%04x ", M.x86.saved_cs, M.x86.saved_ip);
    print_encoded_bytes(M.x86.saved_cs, M.x86.saved_ip);
    print_decoded_instruction();
}

static void
disassemble_forward(u16 seg, u16 off, int n)
{
    X86EMU_sysEnv tregs;
    int i;
    u8 op1;

    /*
     * hack, hack, hack.  What we do is use the exact machinery set up
     * for execution, except that now there is an additional state
     * flag associated with the "execution", and we are using a copy
     * of the register struct.  All the major opcodes, once fully
     * decoded, have the following two steps: TRACE_REGS(r,m);
     * SINGLE_STEP(r,m); which disappear if DEBUG is not defined to
     * the preprocessor.  The TRACE_REGS macro expands to:
     *
     * if (debug&DEBUG_DISASSEMBLE)
     *     {just_disassemble(); goto EndOfInstruction;}
     *     if (debug&DEBUG_TRACE) trace_regs(r,m);
     *
     * ......  and at the last line of the routine.
     *
     * EndOfInstruction: end_instr();
     *
     * Up to the point where TRACE_REG is expanded, NO modifications
     * are done to any register EXCEPT the IP register, for fetch and
     * decoding purposes.
     *
     * This was done for an entirely different reason, but makes a
     * nice way to get the system to help debug codes.
     */
    tregs = M;
    tregs.x86.R_IP = off;
    tregs.x86.R_CS = seg;

    /* reset the decoding buffers */
    tregs.x86.enc_str_pos = 0;
    tregs.x86.enc_pos = 0;

    /* turn on the "disassemble only, no execute" flag */
    tregs.x86.debug |= DEBUG_DISASSEMBLE_F;

    /* DUMP NEXT n instructions to screen in straight_line fashion */
    /*
     * This looks like the regular instruction fetch stream, except
     * that when this occurs, each fetched opcode, upon seeing the
     * DEBUG_DISASSEMBLE flag set, exits immediately after decoding
     * the instruction.  XXX --- CHECK THAT MEM IS NOT AFFECTED!!!
     * Note the use of a copy of the register structure...
     */
    for (i = 0; i < n; i++) {
        op1 = (*sys_rdb) (((u32) M.x86.R_CS << 4) + (M.x86.R_IP++));
        (x86emu_optab[op1]) (op1);
    }
    /* end major hack mode. */
}

void
x86emu_check_ip_access(void)
{
    /* NULL as of now */
}

void
x86emu_check_sp_access(void)
{
}

void
x86emu_check_mem_access(u32 dummy)
{
    /*  check bounds, etc */
}

void
x86emu_check_data_access(uint dummy1, uint dummy2)
{
    /*  check bounds, etc */
}

void
x86emu_inc_decoded_inst_len(int x)
{
    M.x86.enc_pos += x;
}

void
x86emu_decode_printf(const char *x)
{
    sprintf(M.x86.decoded_buf + M.x86.enc_str_pos, "%s", x);
    M.x86.enc_str_pos += strlen(x);
}

void
x86emu_decode_printf2(const char *x, int y)
{
    char temp[100];

    snprintf(temp, sizeof(temp), x, y);
    sprintf(M.x86.decoded_buf + M.x86.enc_str_pos, "%s", temp);
    M.x86.enc_str_pos += strlen(temp);
}

void
x86emu_end_instr(void)
{
    M.x86.enc_str_pos = 0;
    M.x86.enc_pos = 0;
}

static void
print_encoded_bytes(u16 s, u16 o)
{
    int i;
    char buf1[64];

    for (i = 0; i < M.x86.enc_pos; i++) {
        sprintf(buf1 + 2 * i, "%02x", fetch_data_byte_abs(s, o + i));
    }
    printk("%-20s", buf1);
}

static void
print_decoded_instruction(void)
{
    printk("%s", M.x86.decoded_buf);
}

void
x86emu_print_int_vect(u16 iv)
{
    u16 seg, off;

    if (iv > 256)
        return;
    seg = fetch_data_word_abs(0, iv * 4);
    off = fetch_data_word_abs(0, iv * 4 + 2);
    printk("%04x:%04x ", seg, off);
}

void
X86EMU_dump_memory(u16 seg, u16 off, u32 amt)
{
    u32 start = off & 0xfffffff0;
    u32 end = (off + 16) & 0xfffffff0;
    u32 i;

    while (end <= off + amt) {
        printk("%04x:%04x ", seg, start);
        for (i = start; i < off; i++)
            printk("   ");
        for (; i < end; i++)
            printk("%02x ", fetch_data_byte_abs(seg, i));
        printk("\n");
        start = end;
        end = start + 16;
    }
}

void
x86emu_single_step(void)
{
    char s[1024];
    int ps[10];
    int ntok;
    int cmd;
    int done;
    int segment;
    int offset;
    static int breakpoint;
    static int noDecode = 1;

    if (DEBUG_BREAK()) {
        if (M.x86.saved_ip != breakpoint) {
            return;
        }
        else {
            M.x86.debug &= ~DEBUG_DECODE_NOPRINT_F;
            M.x86.debug |= DEBUG_TRACE_F;
            M.x86.debug &= ~DEBUG_BREAK_F;
            print_decoded_instruction();
            X86EMU_trace_regs();
        }
    }
    done = 0;
    offset = M.x86.saved_ip;
    while (!done) {
        printk("-");
        (void)fgets(s, 1023, stdin);
        cmd = parse_line(s, ps, &ntok);
        switch (cmd) {
        case 'u':
            disassemble_forward(M.x86.saved_cs, (u16) offset, 10);
            break;
        case 'd':
            if (ntok == 2) {
                segment = M.x86.saved_cs;
                offset = ps[1];
                X86EMU_dump_memory(segment, (u16) offset, 16);
                offset += 16;
            }
            else if (ntok == 3) {
                segment = ps[1];
                offset = ps[2];
                X86EMU_dump_memory(segment, (u16) offset, 16);
                offset += 16;
            }
            else {
                segment = M.x86.saved_cs;
                X86EMU_dump_memory(segment, (u16) offset, 16);
                offset += 16;
            }
            break;
        case 'c':
            M.x86.debug ^= DEBUG_TRACECALL_F;
            break;
        case 's':
            M.x86.debug ^= DEBUG_SVC_F | DEBUG_SYS_F | DEBUG_SYSINT_F;
            break;
        case 'r':
            X86EMU_trace_regs();
            break;
        case 'x':
            X86EMU_trace_xregs();
            break;
        case 'g':
            if (ntok == 2) {
                breakpoint = ps[1];
                if (noDecode) {
                    M.x86.debug |= DEBUG_DECODE_NOPRINT_F;
                }
                else {
                    M.x86.debug &= ~DEBUG_DECODE_NOPRINT_F;
                }
                M.x86.debug &= ~DEBUG_TRACE_F;
                M.x86.debug |= DEBUG_BREAK_F;
                done = 1;
            }
            break;
        case 'q':
            M.x86.debug |= DEBUG_EXIT;
            return;
        case 'P':
            noDecode = (noDecode) ? 0 : 1;
            printk("Toggled decoding to %s\n", (noDecode) ? "FALSE" : "TRUE");
            break;
        case 't':
        case 0:
            done = 1;
            break;
        }
    }
}

int
X86EMU_trace_on(void)
{
    return M.x86.debug |= DEBUG_STEP_F | DEBUG_DECODE_F | DEBUG_TRACE_F;
}

int
X86EMU_trace_off(void)
{
    return M.x86.debug &= ~(DEBUG_STEP_F | DEBUG_DECODE_F | DEBUG_TRACE_F);
}

static int
parse_line(char *s, int *ps, int *n)
{
    int cmd;

    *n = 0;
    while (*s == ' ' || *s == '\t')
        s++;
    ps[*n] = *s;
    switch (*s) {
    case '\n':
        *n += 1;
        return 0;
    default:
        cmd = *s;
        *n += 1;
    }

    while (1) {
        while (*s != ' ' && *s != '\t' && *s != '\n')
            s++;

        if (*s == '\n')
            return cmd;

        while (*s == ' ' || *s == '\t')
            s++;

        sscanf(s, "%x", &ps[*n]);
        *n += 1;
    }
}

#endif                          /* DEBUG */

void
x86emu_dump_regs(void)
{
    printk("\tAX=%04x  ", M.x86.R_AX);
    printk("BX=%04x  ", M.x86.R_BX);
    printk("CX=%04x  ", M.x86.R_CX);
    printk("DX=%04x  ", M.x86.R_DX);
    printk("SP=%04x  ", M.x86.R_SP);
    printk("BP=%04x  ", M.x86.R_BP);
    printk("SI=%04x  ", M.x86.R_SI);
    printk("DI=%04x\n", M.x86.R_DI);
    printk("\tDS=%04x  ", M.x86.R_DS);
    printk("ES=%04x  ", M.x86.R_ES);
    printk("SS=%04x  ", M.x86.R_SS);
    printk("CS=%04x  ", M.x86.R_CS);
    printk("IP=%04x   ", M.x86.R_IP);
    if (ACCESS_FLAG(F_OF))
        printk("OV ");          /* CHECKED... */
    else
        printk("NV ");
    if (ACCESS_FLAG(F_DF))
        printk("DN ");
    else
        printk("UP ");
    if (ACCESS_FLAG(F_IF))
        printk("EI ");
    else
        printk("DI ");
    if (ACCESS_FLAG(F_SF))
        printk("NG ");
    else
        printk("PL ");
    if (ACCESS_FLAG(F_ZF))
        printk("ZR ");
    else
        printk("NZ ");
    if (ACCESS_FLAG(F_AF))
        printk("AC ");
    else
        printk("NA ");
    if (ACCESS_FLAG(F_PF))
        printk("PE ");
    else
        printk("PO ");
    if (ACCESS_FLAG(F_CF))
        printk("CY ");
    else
        printk("NC ");
    printk("\n");
}

void
x86emu_dump_xregs(void)
{
    printk("\tEAX=%08x  ", M.x86.R_EAX);
    printk("EBX=%08x  ", M.x86.R_EBX);
    printk("ECX=%08x  ", M.x86.R_ECX);
    printk("EDX=%08x  \n", M.x86.R_EDX);
    printk("\tESP=%08x  ", M.x86.R_ESP);
    printk("EBP=%08x  ", M.x86.R_EBP);
    printk("ESI=%08x  ", M.x86.R_ESI);
    printk("EDI=%08x\n", M.x86.R_EDI);
    printk("\tDS=%04x  ", M.x86.R_DS);
    printk("ES=%04x  ", M.x86.R_ES);
    printk("SS=%04x  ", M.x86.R_SS);
    printk("CS=%04x  ", M.x86.R_CS);
    printk("EIP=%08x\n\t", M.x86.R_EIP);
    if (ACCESS_FLAG(F_OF))
        printk("OV ");          /* CHECKED... */
    else
        printk("NV ");
    if (ACCESS_FLAG(F_DF))
        printk("DN ");
    else
        printk("UP ");
    if (ACCESS_FLAG(F_IF))
        printk("EI ");
    else
        printk("DI ");
    if (ACCESS_FLAG(F_SF))
        printk("NG ");
    else
        printk("PL ");
    if (ACCESS_FLAG(F_ZF))
        printk("ZR ");
    else
        printk("NZ ");
    if (ACCESS_FLAG(F_AF))
        printk("AC ");
    else
        printk("NA ");
    if (ACCESS_FLAG(F_PF))
        printk("PE ");
    else
        printk("PO ");
    if (ACCESS_FLAG(F_CF))
        printk("CY ");
    else
        printk("NC ");
    printk("\n");
}
@


1.3
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a235 1
    u32 current;
a236 1
    current = start;
a261 2
    char *p;

d278 1
a278 1
        p = fgets(s, 1023, stdin);
@


1.2
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d106 1
a106 1
     * if (debug&DEBUG_DISASSEMBLE) 
d110 1
a110 1
     * ......  and at the last line of the routine. 
@


1.1
log
@Initial revision
@
text
@d41 2
d52 4
a55 4
static void     print_encoded_bytes (u16 s, u16 o);
static void     print_decoded_instruction (void);
static int      parse_line (char *s, int *ps, int *n);
  
d57 2
a58 1
void X86EMU_trace_regs (void)
d60 2
a61 2
	if (DEBUG_TRACE()) {
		x86emu_dump_regs();
d63 4
a66 4
	if (DEBUG_DECODE() && ! DEBUG_DECODE_NOPRINT()) {
		printk("%04x:%04x ",M.x86.saved_cs, M.x86.saved_ip);
		print_encoded_bytes( M.x86.saved_cs, M.x86.saved_ip);
		print_decoded_instruction();
d70 2
a71 1
void X86EMU_trace_xregs (void)
d73 2
a74 2
	if (DEBUG_TRACE()) {
		x86emu_dump_xregs();
d78 2
a79 1
void x86emu_just_disassemble (void)
d85 3
a87 3
	printk("%04x:%04x ",M.x86.saved_cs, M.x86.saved_ip);
	print_encoded_bytes( M.x86.saved_cs, M.x86.saved_ip);
	print_decoded_instruction();
d90 2
a91 1
static void disassemble_forward (u16 seg, u16 off, int n)
d93 4
a96 3
	X86EMU_sysEnv tregs;
	int i;
	u8 op1;
d121 1
a121 1
	tregs = M;
d124 1
a124 1
    
d128 1
a128 1
    
d131 1
a131 1
 
d140 3
a142 3
    for (i=0; i<n; i++) {
		op1 = (*sys_rdb)(((u32)M.x86.R_CS<<4) + (M.x86.R_IP++));
		(x86emu_optab[op1])(op1);
d147 2
a148 1
void x86emu_check_ip_access (void)
d153 2
a154 1
void x86emu_check_sp_access (void)
d158 2
a159 1
void x86emu_check_mem_access (u32 dummy)
d161 1
a161 1
	/*  check bounds, etc */
d164 2
a165 1
void x86emu_check_data_access (uint dummy1, uint dummy2)
d167 1
a167 1
	/*  check bounds, etc */
d170 2
a171 1
void x86emu_inc_decoded_inst_len (int x)
d173 1
a173 1
	M.x86.enc_pos += x;
d176 2
a177 1
void x86emu_decode_printf (char *x)
d179 2
a180 2
	sprintf(M.x86.decoded_buf+M.x86.enc_str_pos,"%s",x);
	M.x86.enc_str_pos += strlen(x);
d183 2
a184 1
void x86emu_decode_printf2 (char *x, int y)
d186 5
a190 4
	char temp[100];
	sprintf(temp,x,y);
	sprintf(M.x86.decoded_buf+M.x86.enc_str_pos,"%s",temp);
	M.x86.enc_str_pos += strlen(temp);
d193 2
a194 1
void x86emu_end_instr (void)
d196 2
a197 2
	M.x86.enc_str_pos = 0;
	M.x86.enc_pos = 0;
d200 2
a201 1
static void print_encoded_bytes (u16 s, u16 o)
d205 3
a207 2
	for (i=0; i< M.x86.enc_pos; i++) {
		sprintf(buf1+2*i,"%02x", fetch_data_byte_abs(s,o+i));
d209 1
a209 1
	printk("%-20s",buf1);
d212 2
a213 1
static void print_decoded_instruction (void)
d215 1
a215 1
	printk("%s", M.x86.decoded_buf);
d218 2
a219 1
void x86emu_print_int_vect (u16 iv)
d221 1
a221 1
	u16 seg,off;
d223 5
a227 4
	if (iv > 256) return;
	seg   = fetch_data_word_abs(0,iv*4);
	off   = fetch_data_word_abs(0,iv*4+2);
	printk("%04x:%04x ", seg, off);
d230 2
a231 1
void X86EMU_dump_memory (u16 seg, u16 off, u32 amt)
d233 4
a236 4
	u32 start = off & 0xfffffff0;
	u32 end  = (off+16) & 0xfffffff0;
	u32 i;
	u32 current;
d238 11
a248 11
	current = start;
	while (end <= off + amt) {
		printk("%04x:%04x ", seg, start);
		for (i=start; i< off; i++)
		  printk("   ");
		for (       ; i< end; i++)
		  printk("%02x ", fetch_data_byte_abs(seg,i));
		printk("\n");
		start = end;
		end = start + 16;
	}
d251 2
a252 1
void x86emu_single_step (void)
d259 1
a259 1
		int segment;
d263 1
a263 1
    
d266 14
a279 13
		if (DEBUG_BREAK()) {
				if (M.x86.saved_ip != breakpoint) {
						return;
				} else {
 	          M.x86.debug &= ~DEBUG_DECODE_NOPRINT_F;
						M.x86.debug |= DEBUG_TRACE_F;
						M.x86.debug &= ~DEBUG_BREAK_F;
						print_decoded_instruction ();
						X86EMU_trace_regs();
				}
		}
    done=0;
	offset = M.x86.saved_ip;
d284 3
a286 3
        switch(cmd) {
          case 'u':
			disassemble_forward(M.x86.saved_cs,(u16)offset,10);
d288 18
a305 16
          case 'd':  
							if (ntok == 2) {
									segment = M.x86.saved_cs;
									offset = ps[1];
									X86EMU_dump_memory(segment,(u16)offset,16);
									offset += 16;
							} else if (ntok == 3) {
									segment = ps[1];
									offset = ps[2];
									X86EMU_dump_memory(segment,(u16)offset,16);
									offset += 16;
							} else {
									segment = M.x86.saved_cs;
									X86EMU_dump_memory(segment,(u16)offset,16);
									offset += 16;
							}
d307 2
a308 2
          case 'c':
			M.x86.debug ^= DEBUG_TRACECALL_F;
d310 2
a311 2
          case 's':
			M.x86.debug ^= DEBUG_SVC_F | DEBUG_SYS_F | DEBUG_SYSINT_F;
d313 2
a314 2
          case 'r':
			X86EMU_trace_regs();
d316 2
a317 2
          case 'x':
			X86EMU_trace_xregs();
d319 1
a319 1
          case 'g':
d322 9
a330 8
		if (noDecode) {
		                M.x86.debug |= DEBUG_DECODE_NOPRINT_F;
		} else {
		                M.x86.debug &= ~DEBUG_DECODE_NOPRINT_F;
		}
		M.x86.debug &= ~DEBUG_TRACE_F;
		M.x86.debug |= DEBUG_BREAK_F;
		done = 1;
d333 9
a341 9
          case 'q':
          M.x86.debug |= DEBUG_EXIT;
          return;
	  case 'P':
	      noDecode = (noDecode)?0:1;
	      printk("Toggled decoding to %s\n",(noDecode)?"FALSE":"TRUE");
	      break;
          case 't':
	  case 0:
d344 1
a344 1
        }   
d348 2
a349 1
int X86EMU_trace_on(void)
d351 1
a351 1
	return M.x86.debug |= DEBUG_STEP_F | DEBUG_DECODE_F | DEBUG_TRACE_F;
d354 2
a355 1
int X86EMU_trace_off(void)
d357 1
a357 1
	return M.x86.debug &= ~(DEBUG_STEP_F | DEBUG_DECODE_F | DEBUG_TRACE_F);
d360 2
a361 1
static int parse_line (char *s, int *ps, int *n)
d366 2
a367 1
    while(*s == ' ' || *s == '\t') s++;
d370 1
a370 1
      case '\n':
d373 1
a373 1
      default:
d378 117
a494 81
	while (1) {
		while (*s != ' ' && *s != '\t' && *s != '\n')  s++;
		
		if (*s == '\n')
			return cmd;
		
		while(*s == ' ' || *s == '\t') s++;
		
		sscanf(s,"%x",&ps[*n]);
		*n += 1;
	}
}

#endif /* DEBUG */

void x86emu_dump_regs (void)
{
	printk("\tAX=%04x  ", M.x86.R_AX );
	printk("BX=%04x  ", M.x86.R_BX );
	printk("CX=%04x  ", M.x86.R_CX );
	printk("DX=%04x  ", M.x86.R_DX );
	printk("SP=%04x  ", M.x86.R_SP );
	printk("BP=%04x  ", M.x86.R_BP );
	printk("SI=%04x  ", M.x86.R_SI );
	printk("DI=%04x\n", M.x86.R_DI );
	printk("\tDS=%04x  ", M.x86.R_DS );
	printk("ES=%04x  ", M.x86.R_ES );
	printk("SS=%04x  ", M.x86.R_SS );
	printk("CS=%04x  ", M.x86.R_CS );
	printk("IP=%04x   ", M.x86.R_IP );
	if (ACCESS_FLAG(F_OF))    printk("OV ");     /* CHECKED... */
	else                        printk("NV ");
	if (ACCESS_FLAG(F_DF))    printk("DN ");
	else                        printk("UP ");
	if (ACCESS_FLAG(F_IF))    printk("EI ");
	else                        printk("DI ");
	if (ACCESS_FLAG(F_SF))    printk("NG ");
	else                        printk("PL ");
	if (ACCESS_FLAG(F_ZF))    printk("ZR ");
	else                        printk("NZ ");
	if (ACCESS_FLAG(F_AF))    printk("AC ");
	else                        printk("NA ");
	if (ACCESS_FLAG(F_PF))    printk("PE ");
	else                        printk("PO ");
	if (ACCESS_FLAG(F_CF))    printk("CY ");
	else                        printk("NC ");
	printk("\n");
}

void x86emu_dump_xregs (void)
{
	printk("\tEAX=%08x  ", M.x86.R_EAX );
	printk("EBX=%08x  ", M.x86.R_EBX );
	printk("ECX=%08x  ", M.x86.R_ECX );
	printk("EDX=%08x  \n", M.x86.R_EDX );
	printk("\tESP=%08x  ", M.x86.R_ESP );
	printk("EBP=%08x  ", M.x86.R_EBP );
	printk("ESI=%08x  ", M.x86.R_ESI );
	printk("EDI=%08x\n", M.x86.R_EDI );
	printk("\tDS=%04x  ", M.x86.R_DS );
	printk("ES=%04x  ", M.x86.R_ES );
	printk("SS=%04x  ", M.x86.R_SS );
	printk("CS=%04x  ", M.x86.R_CS );
	printk("EIP=%08x\n\t", M.x86.R_EIP );
	if (ACCESS_FLAG(F_OF))    printk("OV ");     /* CHECKED... */
	else                        printk("NV ");
	if (ACCESS_FLAG(F_DF))    printk("DN ");
	else                        printk("UP ");
	if (ACCESS_FLAG(F_IF))    printk("EI ");
	else                        printk("DI ");
	if (ACCESS_FLAG(F_SF))    printk("NG ");
	else                        printk("PL ");
	if (ACCESS_FLAG(F_ZF))    printk("ZR ");
	else                        printk("NZ ");
	if (ACCESS_FLAG(F_AF))    printk("AC ");
	else                        printk("NA ");
	if (ACCESS_FLAG(F_PF))    printk("PE ");
	else                        printk("PO ");
	if (ACCESS_FLAG(F_CF))    printk("CY ");
	else                        printk("NC ");
	printk("\n");
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a40 2
#include <stdio.h>
#include <string.h>
@

