head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.22
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.20
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.18
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.16
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.14
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.12
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.10
	OPENBSD_5_0:1.4.0.8
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.4
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.6
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.06.10.13.21.27;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.28;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.25;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.10.22.31.30;	author mbalmer;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.18.18;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.18.18;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.10.00;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.58.00;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@/****************************************************************************
*
*						Realmode X86 Emulator Library
*
*            	Copyright (C) 1996-1999 SciTech Software, Inc.
* 				     Copyright (C) David Mosberger-Tang
* 					   Copyright (C) 1999 Egbert Eich
*
*  ========================================================================
*
*  Permission to use, copy, modify, distribute, and sell this software and
*  its documentation for any purpose is hereby granted without fee,
*  provided that the above copyright notice appear in all copies and that
*  both that copyright notice and this permission notice appear in
*  supporting documentation, and that the name of the authors not be used
*  in advertising or publicity pertaining to distribution of the software
*  without specific, written prior permission.  The authors makes no
*  representations about the suitability of this software for any purpose.
*  It is provided "as is" without express or implied warranty.
*
*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
*  PERFORMANCE OF THIS SOFTWARE.
*
*  ========================================================================
*
* Language:		ANSI C
* Environment:	Any
* Developer:    Kendall Bennett
*
* Description:  This file includes subroutines to implement the decoding
*               and emulation of all the x86 extended two-byte processor
*               instructions.
*
****************************************************************************/

#include "x86emu/x86emui.h"

#undef bswap_32
#define bswap_32(x) (((x & 0xff000000) >> 24) | \
		     ((x & 0x00ff0000) >> 8) | \
		     ((x & 0x0000ff00) << 8) | \
		     ((x & 0x000000ff) << 24))

/*----------------------------- Implementation ----------------------------*/

/****************************************************************************
PARAMETERS:
op1 - Instruction op code

REMARKS:
Handles illegal opcodes.
****************************************************************************/
static void
x86emuOp2_illegal_op(u8 op2)
{
    START_OF_INSTR();
    DECODE_PRINTF("ILLEGAL EXTENDED X86 OPCODE\n");
    TRACE_REGS();
    printk("%04x:%04x: %02X ILLEGAL EXTENDED X86 OPCODE!\n",
           M.x86.R_CS, M.x86.R_IP - 2, op2);
    HALT_SYS();
    END_OF_INSTR();
}

#define xorl(a,b)   ((a) && !(b)) || (!(a) && (b))

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0x31
****************************************************************************/
static void
x86emuOp2_rdtsc(u8 X86EMU_UNUSED(op2))
{
#ifdef __HAS_LONG_LONG__
    static u64 counter = 0;
#else
    static u32 counter = 0;
#endif

    counter += 0x10000;

    /* read timestamp counter */
    /*
     * Note that instead of actually trying to accurately measure this, we just
     * increase the counter by a fixed amount every time we hit one of these
     * instructions.  Feel free to come up with a better method.
     */
    START_OF_INSTR();
    DECODE_PRINTF("RDTSC\n");
    TRACE_AND_STEP();
#ifdef __HAS_LONG_LONG__
    M.x86.R_EAX = counter & 0xffffffff;
    M.x86.R_EDX = counter >> 32;
#else
    M.x86.R_EAX = counter;
    M.x86.R_EDX = 0;
#endif
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0x80-0x8F
****************************************************************************/
static void
x86emuOp2_long_jump(u8 op2)
{
    s32 target;
    const char *name = NULL;
    int cond = 0;

    /* conditional jump to word offset. */
    START_OF_INSTR();
    switch (op2) {
    case 0x80:
        name = "JO\t";
        cond = ACCESS_FLAG(F_OF);
        break;
    case 0x81:
        name = "JNO\t";
        cond = !ACCESS_FLAG(F_OF);
        break;
    case 0x82:
        name = "JB\t";
        cond = ACCESS_FLAG(F_CF);
        break;
    case 0x83:
        name = "JNB\t";
        cond = !ACCESS_FLAG(F_CF);
        break;
    case 0x84:
        name = "JZ\t";
        cond = ACCESS_FLAG(F_ZF);
        break;
    case 0x85:
        name = "JNZ\t";
        cond = !ACCESS_FLAG(F_ZF);
        break;
    case 0x86:
        name = "JBE\t";
        cond = ACCESS_FLAG(F_CF) || ACCESS_FLAG(F_ZF);
        break;
    case 0x87:
        name = "JNBE\t";
        cond = !(ACCESS_FLAG(F_CF) || ACCESS_FLAG(F_ZF));
        break;
    case 0x88:
        name = "JS\t";
        cond = ACCESS_FLAG(F_SF);
        break;
    case 0x89:
        name = "JNS\t";
        cond = !ACCESS_FLAG(F_SF);
        break;
    case 0x8a:
        name = "JP\t";
        cond = ACCESS_FLAG(F_PF);
        break;
    case 0x8b:
        name = "JNP\t";
        cond = !ACCESS_FLAG(F_PF);
        break;
    case 0x8c:
        name = "JL\t";
        cond = xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF));
        break;
    case 0x8d:
        name = "JNL\t";
        cond = !(xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF)));
        break;
    case 0x8e:
        name = "JLE\t";
        cond = (xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF)) ||
                ACCESS_FLAG(F_ZF));
        break;
    case 0x8f:
        name = "JNLE\t";
        cond = !(xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF)) ||
                 ACCESS_FLAG(F_ZF));
        break;
    }
    DECODE_PRINTF(name);
    (void) name;
    target = (s16) fetch_word_imm();
    target += (s16) M.x86.R_IP;
    DECODE_PRINTF2("%04x\n", target);
    TRACE_AND_STEP();
    if (cond)
        M.x86.R_IP = (u16) target;
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0x90-0x9F
****************************************************************************/
static void
x86emuOp2_set_byte(u8 op2)
{
    int mod, rl, rh;
    uint destoffset;
    u8 *destreg;
    const char *name = NULL;
    int cond = 0;

    START_OF_INSTR();
    switch (op2) {
    case 0x90:
        name = "SETO\t";
        cond = ACCESS_FLAG(F_OF);
        break;
    case 0x91:
        name = "SETNO\t";
        cond = !ACCESS_FLAG(F_OF);
        break;
    case 0x92:
        name = "SETB\t";
        cond = ACCESS_FLAG(F_CF);
        break;
    case 0x93:
        name = "SETNB\t";
        cond = !ACCESS_FLAG(F_CF);
        break;
    case 0x94:
        name = "SETZ\t";
        cond = ACCESS_FLAG(F_ZF);
        break;
    case 0x95:
        name = "SETNZ\t";
        cond = !ACCESS_FLAG(F_ZF);
        break;
    case 0x96:
        name = "SETBE\t";
        cond = ACCESS_FLAG(F_CF) || ACCESS_FLAG(F_ZF);
        break;
    case 0x97:
        name = "SETNBE\t";
        cond = !(ACCESS_FLAG(F_CF) || ACCESS_FLAG(F_ZF));
        break;
    case 0x98:
        name = "SETS\t";
        cond = ACCESS_FLAG(F_SF);
        break;
    case 0x99:
        name = "SETNS\t";
        cond = !ACCESS_FLAG(F_SF);
        break;
    case 0x9a:
        name = "SETP\t";
        cond = ACCESS_FLAG(F_PF);
        break;
    case 0x9b:
        name = "SETNP\t";
        cond = !ACCESS_FLAG(F_PF);
        break;
    case 0x9c:
        name = "SETL\t";
        cond = xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF));
        break;
    case 0x9d:
        name = "SETNL\t";
        cond = xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF));
        break;
    case 0x9e:
        name = "SETLE\t";
        cond = (xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF)) ||
                ACCESS_FLAG(F_ZF));
        break;
    case 0x9f:
        name = "SETNLE\t";
        cond = !(xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF)) ||
                 ACCESS_FLAG(F_ZF));
        break;
    }
    DECODE_PRINTF(name);
    (void) name;
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destoffset = decode_rm00_address(rl);
        TRACE_AND_STEP();
        store_data_byte(destoffset, cond ? 0x01 : 0x00);
        break;
    case 1:
        destoffset = decode_rm01_address(rl);
        TRACE_AND_STEP();
        store_data_byte(destoffset, cond ? 0x01 : 0x00);
        break;
    case 2:
        destoffset = decode_rm10_address(rl);
        TRACE_AND_STEP();
        store_data_byte(destoffset, cond ? 0x01 : 0x00);
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_BYTE_REGISTER(rl);
        TRACE_AND_STEP();
        *destreg = cond ? 0x01 : 0x00;
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xa0
****************************************************************************/
static void
x86emuOp2_push_FS(u8 X86EMU_UNUSED(op2))
{
    START_OF_INSTR();
    DECODE_PRINTF("PUSH\tFS\n");
    TRACE_AND_STEP();
    push_word(M.x86.R_FS);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xa1
****************************************************************************/
static void
x86emuOp2_pop_FS(u8 X86EMU_UNUSED(op2))
{
    START_OF_INSTR();
    DECODE_PRINTF("POP\tFS\n");
    TRACE_AND_STEP();
    M.x86.R_FS = pop_word();
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS: CPUID takes EAX/ECX as inputs, writes EAX/EBX/ECX/EDX as output
Handles opcode 0x0f,0xa2
****************************************************************************/
static void
x86emuOp2_cpuid(u8 X86EMU_UNUSED(op2))
{
    START_OF_INSTR();
    DECODE_PRINTF("CPUID\n");
    TRACE_AND_STEP();
    cpuid();
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xa3
****************************************************************************/
static void
x86emuOp2_bt_R(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint srcoffset;
    int bit, disp;

    START_OF_INSTR();
    DECODE_PRINTF("BT\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval;
            u32 *shiftreg;

            srcoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            disp = (s16) * shiftreg >> 5;
            srcval = fetch_data_long(srcoffset + disp);
            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit), F_CF);
        }
        else {
            u16 srcval;
            u16 *shiftreg;

            srcoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            disp = (s16) * shiftreg >> 4;
            srcval = fetch_data_word(srcoffset + disp);
            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit), F_CF);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval;
            u32 *shiftreg;

            srcoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            disp = (s16) * shiftreg >> 5;
            srcval = fetch_data_long(srcoffset + disp);
            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit), F_CF);
        }
        else {
            u16 srcval;
            u16 *shiftreg;

            srcoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            disp = (s16) * shiftreg >> 4;
            srcval = fetch_data_word(srcoffset + disp);
            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit), F_CF);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval;
            u32 *shiftreg;

            srcoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            disp = (s16) * shiftreg >> 5;
            srcval = fetch_data_long(srcoffset + disp);
            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit), F_CF);
        }
        else {
            u16 srcval;
            u16 *shiftreg;

            srcoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            disp = (s16) * shiftreg >> 4;
            srcval = fetch_data_word(srcoffset + disp);
            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit), F_CF);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *srcreg, *shiftreg;

            srcreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            CONDITIONAL_SET_FLAG(*srcreg & (0x1 << bit), F_CF);
        }
        else {
            u16 *srcreg, *shiftreg;

            srcreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            CONDITIONAL_SET_FLAG(*srcreg & (0x1 << bit), F_CF);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xa4
****************************************************************************/
static void
x86emuOp2_shld_IMM(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint destoffset;
    u8 shift;

    START_OF_INSTR();
    DECODE_PRINTF("SHLD\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *shiftreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            destval = fetch_data_long(destoffset);
            destval = shld_long(destval, *shiftreg, shift);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *shiftreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            destval = fetch_data_word(destoffset);
            destval = shld_word(destval, *shiftreg, shift);
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *shiftreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            destval = fetch_data_long(destoffset);
            destval = shld_long(destval, *shiftreg, shift);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *shiftreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            destval = fetch_data_word(destoffset);
            destval = shld_word(destval, *shiftreg, shift);
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *shiftreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            destval = fetch_data_long(destoffset);
            destval = shld_long(destval, *shiftreg, shift);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *shiftreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            destval = fetch_data_word(destoffset);
            destval = shld_word(destval, *shiftreg, shift);
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *shiftreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            *destreg = shld_long(*destreg, *shiftreg, shift);
        }
        else {
            u16 *destreg, *shiftreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            *destreg = shld_word(*destreg, *shiftreg, shift);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xa5
****************************************************************************/
static void
x86emuOp2_shld_CL(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("SHLD\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *shiftreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            destval = fetch_data_long(destoffset);
            destval = shld_long(destval, *shiftreg, M.x86.R_CL);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *shiftreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            destval = fetch_data_word(destoffset);
            destval = shld_word(destval, *shiftreg, M.x86.R_CL);
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *shiftreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            destval = fetch_data_long(destoffset);
            destval = shld_long(destval, *shiftreg, M.x86.R_CL);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *shiftreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            destval = fetch_data_word(destoffset);
            destval = shld_word(destval, *shiftreg, M.x86.R_CL);
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *shiftreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            destval = fetch_data_long(destoffset);
            destval = shld_long(destval, *shiftreg, M.x86.R_CL);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *shiftreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            destval = fetch_data_word(destoffset);
            destval = shld_word(destval, *shiftreg, M.x86.R_CL);
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *shiftreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            *destreg = shld_long(*destreg, *shiftreg, M.x86.R_CL);
        }
        else {
            u16 *destreg, *shiftreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            *destreg = shld_word(*destreg, *shiftreg, M.x86.R_CL);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xa8
****************************************************************************/
static void
x86emuOp2_push_GS(u8 X86EMU_UNUSED(op2))
{
    START_OF_INSTR();
    DECODE_PRINTF("PUSH\tGS\n");
    TRACE_AND_STEP();
    push_word(M.x86.R_GS);
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xa9
****************************************************************************/
static void
x86emuOp2_pop_GS(u8 X86EMU_UNUSED(op2))
{
    START_OF_INSTR();
    DECODE_PRINTF("POP\tGS\n");
    TRACE_AND_STEP();
    M.x86.R_GS = pop_word();
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xab
****************************************************************************/
static void
x86emuOp2_bts_R(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint srcoffset;
    int bit, disp;

    START_OF_INSTR();
    DECODE_PRINTF("BTS\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, mask;
            u32 *shiftreg;

            srcoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            disp = (s16) * shiftreg >> 5;
            srcval = fetch_data_long(srcoffset + disp);
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_long(srcoffset + disp, srcval | mask);
        }
        else {
            u16 srcval, mask;
            u16 *shiftreg;

            srcoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            disp = (s16) * shiftreg >> 4;
            srcval = fetch_data_word(srcoffset + disp);
            mask = (u16) (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_word(srcoffset + disp, srcval | mask);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, mask;
            u32 *shiftreg;

            srcoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            disp = (s16) * shiftreg >> 5;
            srcval = fetch_data_long(srcoffset + disp);
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_long(srcoffset + disp, srcval | mask);
        }
        else {
            u16 srcval, mask;
            u16 *shiftreg;

            srcoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            disp = (s16) * shiftreg >> 4;
            srcval = fetch_data_word(srcoffset + disp);
            mask = (u16) (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_word(srcoffset + disp, srcval | mask);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, mask;
            u32 *shiftreg;

            srcoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            disp = (s16) * shiftreg >> 5;
            srcval = fetch_data_long(srcoffset + disp);
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_long(srcoffset + disp, srcval | mask);
        }
        else {
            u16 srcval, mask;
            u16 *shiftreg;

            srcoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            disp = (s16) * shiftreg >> 4;
            srcval = fetch_data_word(srcoffset + disp);
            mask = (u16) (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_word(srcoffset + disp, srcval | mask);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *srcreg, *shiftreg;
            u32 mask;

            srcreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
            *srcreg |= mask;
        }
        else {
            u16 *srcreg, *shiftreg;
            u16 mask;

            srcreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            mask = (u16) (0x1 << bit);
            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
            *srcreg |= mask;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xac
****************************************************************************/
static void
x86emuOp2_shrd_IMM(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint destoffset;
    u8 shift;

    START_OF_INSTR();
    DECODE_PRINTF("SHLD\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *shiftreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            destval = fetch_data_long(destoffset);
            destval = shrd_long(destval, *shiftreg, shift);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *shiftreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            destval = fetch_data_word(destoffset);
            destval = shrd_word(destval, *shiftreg, shift);
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *shiftreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            destval = fetch_data_long(destoffset);
            destval = shrd_long(destval, *shiftreg, shift);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *shiftreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            destval = fetch_data_word(destoffset);
            destval = shrd_word(destval, *shiftreg, shift);
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *shiftreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            destval = fetch_data_long(destoffset);
            destval = shrd_long(destval, *shiftreg, shift);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *shiftreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            destval = fetch_data_word(destoffset);
            destval = shrd_word(destval, *shiftreg, shift);
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *shiftreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            *destreg = shrd_long(*destreg, *shiftreg, shift);
        }
        else {
            u16 *destreg, *shiftreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            DECODE_PRINTF2("%d\n", shift);
            TRACE_AND_STEP();
            *destreg = shrd_word(*destreg, *shiftreg, shift);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xad
****************************************************************************/
static void
x86emuOp2_shrd_CL(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint destoffset;

    START_OF_INSTR();
    DECODE_PRINTF("SHLD\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *shiftreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            destval = fetch_data_long(destoffset);
            destval = shrd_long(destval, *shiftreg, M.x86.R_CL);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *shiftreg;

            destoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            destval = fetch_data_word(destoffset);
            destval = shrd_word(destval, *shiftreg, M.x86.R_CL);
            store_data_word(destoffset, destval);
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *shiftreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            destval = fetch_data_long(destoffset);
            destval = shrd_long(destval, *shiftreg, M.x86.R_CL);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *shiftreg;

            destoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            destval = fetch_data_word(destoffset);
            destval = shrd_word(destval, *shiftreg, M.x86.R_CL);
            store_data_word(destoffset, destval);
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 destval;
            u32 *shiftreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            destval = fetch_data_long(destoffset);
            destval = shrd_long(destval, *shiftreg, M.x86.R_CL);
            store_data_long(destoffset, destval);
        }
        else {
            u16 destval;
            u16 *shiftreg;

            destoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            destval = fetch_data_word(destoffset);
            destval = shrd_word(destval, *shiftreg, M.x86.R_CL);
            store_data_word(destoffset, destval);
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *shiftreg;

            destreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            *destreg = shrd_long(*destreg, *shiftreg, M.x86.R_CL);
        }
        else {
            u16 *destreg, *shiftreg;

            destreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",CL\n");
            TRACE_AND_STEP();
            *destreg = shrd_word(*destreg, *shiftreg, M.x86.R_CL);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xaf
****************************************************************************/
static void
x86emuOp2_imul_R_RM(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("IMUL\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;
            u32 res_lo, res_hi;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_long(srcoffset);
            TRACE_AND_STEP();
            imul_long_direct(&res_lo, &res_hi, (s32) * destreg, (s32) srcval);
            if (res_hi != 0) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u32) res_lo;
        }
        else {
            u16 *destreg;
            u16 srcval;
            u32 res;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_word(srcoffset);
            TRACE_AND_STEP();
            res = (s16) * destreg * (s16) srcval;
            if (res > 0xFFFF) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u16) res;
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;
            u32 res_lo, res_hi;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_long(srcoffset);
            TRACE_AND_STEP();
            imul_long_direct(&res_lo, &res_hi, (s32) * destreg, (s32) srcval);
            if (res_hi != 0) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u32) res_lo;
        }
        else {
            u16 *destreg;
            u16 srcval;
            u32 res;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_word(srcoffset);
            TRACE_AND_STEP();
            res = (s16) * destreg * (s16) srcval;
            if (res > 0xFFFF) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u16) res;
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;
            u32 res_lo, res_hi;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_long(srcoffset);
            TRACE_AND_STEP();
            imul_long_direct(&res_lo, &res_hi, (s32) * destreg, (s32) srcval);
            if (res_hi != 0) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u32) res_lo;
        }
        else {
            u16 *destreg;
            u16 srcval;
            u32 res;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_word(srcoffset);
            TRACE_AND_STEP();
            res = (s16) * destreg * (s16) srcval;
            if (res > 0xFFFF) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u16) res;
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg, *srcreg;
            u32 res_lo, res_hi;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_LONG_REGISTER(rl);
            TRACE_AND_STEP();
            imul_long_direct(&res_lo, &res_hi, (s32) * destreg, (s32) * srcreg);
            if (res_hi != 0) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u32) res_lo;
        }
        else {
            u16 *destreg, *srcreg;
            u32 res;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_WORD_REGISTER(rl);
            res = (s16) * destreg * (s16) * srcreg;
            if (res > 0xFFFF) {
                SET_FLAG(F_CF);
                SET_FLAG(F_OF);
            }
            else {
                CLEAR_FLAG(F_CF);
                CLEAR_FLAG(F_OF);
            }
            *destreg = (u16) res;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xb2
****************************************************************************/
static void
x86emuOp2_lss_R_IMM(u8 X86EMU_UNUSED(op2))
{
    int mod, rh, rl;
    u16 *dstreg;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("LSS\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        dstreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *dstreg = fetch_data_word(srcoffset);
        M.x86.R_SS = fetch_data_word(srcoffset + 2);
        break;
    case 1:
        dstreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *dstreg = fetch_data_word(srcoffset);
        M.x86.R_SS = fetch_data_word(srcoffset + 2);
        break;
    case 2:
        dstreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *dstreg = fetch_data_word(srcoffset);
        M.x86.R_SS = fetch_data_word(srcoffset + 2);
        break;
    case 3:                    /* register to register */
        /* UNDEFINED! */
        TRACE_AND_STEP();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xb3
****************************************************************************/
static void
x86emuOp2_btr_R(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint srcoffset;
    int bit, disp;

    START_OF_INSTR();
    DECODE_PRINTF("BTR\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, mask;
            u32 *shiftreg;

            srcoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            disp = (s16) * shiftreg >> 5;
            srcval = fetch_data_long(srcoffset + disp);
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_long(srcoffset + disp, srcval & ~mask);
        }
        else {
            u16 srcval, mask;
            u16 *shiftreg;

            srcoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            disp = (s16) * shiftreg >> 4;
            srcval = fetch_data_word(srcoffset + disp);
            mask = (u16) (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_word(srcoffset + disp, (u16) (srcval & ~mask));
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, mask;
            u32 *shiftreg;

            srcoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            disp = (s16) * shiftreg >> 5;
            srcval = fetch_data_long(srcoffset + disp);
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_long(srcoffset + disp, srcval & ~mask);
        }
        else {
            u16 srcval, mask;
            u16 *shiftreg;

            srcoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            disp = (s16) * shiftreg >> 4;
            srcval = fetch_data_word(srcoffset + disp);
            mask = (u16) (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_word(srcoffset + disp, (u16) (srcval & ~mask));
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, mask;
            u32 *shiftreg;

            srcoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            disp = (s16) * shiftreg >> 5;
            srcval = fetch_data_long(srcoffset + disp);
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_long(srcoffset + disp, srcval & ~mask);
        }
        else {
            u16 srcval, mask;
            u16 *shiftreg;

            srcoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            disp = (s16) * shiftreg >> 4;
            srcval = fetch_data_word(srcoffset + disp);
            mask = (u16) (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_word(srcoffset + disp, (u16) (srcval & ~mask));
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *srcreg, *shiftreg;
            u32 mask;

            srcreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
            *srcreg &= ~mask;
        }
        else {
            u16 *srcreg, *shiftreg;
            u16 mask;

            srcreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            mask = (u16) (0x1 << bit);
            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
            *srcreg &= ~mask;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xb4
****************************************************************************/
static void
x86emuOp2_lfs_R_IMM(u8 X86EMU_UNUSED(op2))
{
    int mod, rh, rl;
    u16 *dstreg;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("LFS\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        dstreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *dstreg = fetch_data_word(srcoffset);
        M.x86.R_FS = fetch_data_word(srcoffset + 2);
        break;
    case 1:
        dstreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *dstreg = fetch_data_word(srcoffset);
        M.x86.R_FS = fetch_data_word(srcoffset + 2);
        break;
    case 2:
        dstreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *dstreg = fetch_data_word(srcoffset);
        M.x86.R_FS = fetch_data_word(srcoffset + 2);
        break;
    case 3:                    /* register to register */
        /* UNDEFINED! */
        TRACE_AND_STEP();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xb5
****************************************************************************/
static void
x86emuOp2_lgs_R_IMM(u8 X86EMU_UNUSED(op2))
{
    int mod, rh, rl;
    u16 *dstreg;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("LGS\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        dstreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *dstreg = fetch_data_word(srcoffset);
        M.x86.R_GS = fetch_data_word(srcoffset + 2);
        break;
    case 1:
        dstreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *dstreg = fetch_data_word(srcoffset);
        M.x86.R_GS = fetch_data_word(srcoffset + 2);
        break;
    case 2:
        dstreg = DECODE_RM_WORD_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *dstreg = fetch_data_word(srcoffset);
        M.x86.R_GS = fetch_data_word(srcoffset + 2);
        break;
    case 3:                    /* register to register */
        /* UNDEFINED! */
        TRACE_AND_STEP();
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xb6
****************************************************************************/
static void
x86emuOp2_movzx_byte_R_RM(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("MOVZX\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_byte(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = fetch_data_byte(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_byte(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = fetch_data_byte(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_byte(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = fetch_data_byte(srcoffset);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u8 *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_BYTE_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = *srcreg;
        }
        else {
            u16 *destreg;
            u8 *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_BYTE_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = *srcreg;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xb7
****************************************************************************/
static void
x86emuOp2_movzx_word_R_RM(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint srcoffset;
    u32 *destreg;
    u32 srcval;
    u16 *srcreg;

    START_OF_INSTR();
    DECODE_PRINTF("MOVZX\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destreg = DECODE_RM_LONG_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        srcval = fetch_data_word(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = srcval;
        break;
    case 1:
        destreg = DECODE_RM_LONG_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        srcval = fetch_data_word(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = srcval;
        break;
    case 2:
        destreg = DECODE_RM_LONG_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        srcval = fetch_data_word(srcoffset);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = srcval;
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_LONG_REGISTER(rh);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_WORD_REGISTER(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = *srcreg;
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xba
****************************************************************************/
static void
x86emuOp2_btX_I(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint srcoffset;
    int bit;

    START_OF_INSTR();
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (rh) {
    case 4:
        DECODE_PRINTF("BT\t");
        break;
    case 5:
        DECODE_PRINTF("BTS\t");
        break;
    case 6:
        DECODE_PRINTF("BTR\t");
        break;
    case 7:
        DECODE_PRINTF("BTC\t");
        break;
    default:
        DECODE_PRINTF("ILLEGAL EXTENDED X86 OPCODE\n");
        TRACE_REGS();
        printk("%04x:%04x: %02X%02X ILLEGAL EXTENDED X86 OPCODE EXTENSION!\n",
               M.x86.R_CS, M.x86.R_IP - 3, op2, (mod << 6) | (rh << 3) | rl);
        HALT_SYS();
    }
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, mask;
            u8 shift;

            srcoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            TRACE_AND_STEP();
            bit = shift & 0x1F;
            srcval = fetch_data_long(srcoffset);
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            switch (rh) {
            case 5:
                store_data_long(srcoffset, srcval | mask);
                break;
            case 6:
                store_data_long(srcoffset, srcval & ~mask);
                break;
            case 7:
                store_data_long(srcoffset, srcval ^ mask);
                break;
            default:
                break;
            }
        }
        else {
            u16 srcval, mask;
            u8 shift;

            srcoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            TRACE_AND_STEP();
            bit = shift & 0xF;
            srcval = fetch_data_word(srcoffset);
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            switch (rh) {
            case 5:
                store_data_word(srcoffset, srcval | mask);
                break;
            case 6:
                store_data_word(srcoffset, srcval & ~mask);
                break;
            case 7:
                store_data_word(srcoffset, srcval ^ mask);
                break;
            default:
                break;
            }
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, mask;
            u8 shift;

            srcoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            TRACE_AND_STEP();
            bit = shift & 0x1F;
            srcval = fetch_data_long(srcoffset);
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            switch (rh) {
            case 5:
                store_data_long(srcoffset, srcval | mask);
                break;
            case 6:
                store_data_long(srcoffset, srcval & ~mask);
                break;
            case 7:
                store_data_long(srcoffset, srcval ^ mask);
                break;
            default:
                break;
            }
        }
        else {
            u16 srcval, mask;
            u8 shift;

            srcoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            TRACE_AND_STEP();
            bit = shift & 0xF;
            srcval = fetch_data_word(srcoffset);
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            switch (rh) {
            case 5:
                store_data_word(srcoffset, srcval | mask);
                break;
            case 6:
                store_data_word(srcoffset, srcval & ~mask);
                break;
            case 7:
                store_data_word(srcoffset, srcval ^ mask);
                break;
            default:
                break;
            }
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, mask;
            u8 shift;

            srcoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            TRACE_AND_STEP();
            bit = shift & 0x1F;
            srcval = fetch_data_long(srcoffset);
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            switch (rh) {
            case 5:
                store_data_long(srcoffset, srcval | mask);
                break;
            case 6:
                store_data_long(srcoffset, srcval & ~mask);
                break;
            case 7:
                store_data_long(srcoffset, srcval ^ mask);
                break;
            default:
                break;
            }
        }
        else {
            u16 srcval, mask;
            u8 shift;

            srcoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            TRACE_AND_STEP();
            bit = shift & 0xF;
            srcval = fetch_data_word(srcoffset);
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            switch (rh) {
            case 5:
                store_data_word(srcoffset, srcval | mask);
                break;
            case 6:
                store_data_word(srcoffset, srcval & ~mask);
                break;
            case 7:
                store_data_word(srcoffset, srcval ^ mask);
                break;
            default:
                break;
            }
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *srcreg;
            u32 mask;
            u8 shift;

            srcreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            TRACE_AND_STEP();
            bit = shift & 0x1F;
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
            switch (rh) {
            case 5:
                *srcreg |= mask;
                break;
            case 6:
                *srcreg &= ~mask;
                break;
            case 7:
                *srcreg ^= mask;
                break;
            default:
                break;
            }
        }
        else {
            u16 *srcreg;
            u16 mask;
            u8 shift;

            srcreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            shift = fetch_byte_imm();
            TRACE_AND_STEP();
            bit = shift & 0xF;
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
            switch (rh) {
            case 5:
                *srcreg |= mask;
                break;
            case 6:
                *srcreg &= ~mask;
                break;
            case 7:
                *srcreg ^= mask;
                break;
            default:
                break;
            }
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xbb
****************************************************************************/
static void
x86emuOp2_btc_R(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint srcoffset;
    int bit, disp;

    START_OF_INSTR();
    DECODE_PRINTF("BTC\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, mask;
            u32 *shiftreg;

            srcoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            disp = (s16) * shiftreg >> 5;
            srcval = fetch_data_long(srcoffset + disp);
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_long(srcoffset + disp, srcval ^ mask);
        }
        else {
            u16 srcval, mask;
            u16 *shiftreg;

            srcoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            disp = (s16) * shiftreg >> 4;
            srcval = fetch_data_word(srcoffset + disp);
            mask = (u16) (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_word(srcoffset + disp, (u16) (srcval ^ mask));
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, mask;
            u32 *shiftreg;

            srcoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            disp = (s16) * shiftreg >> 5;
            srcval = fetch_data_long(srcoffset + disp);
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_long(srcoffset + disp, srcval ^ mask);
        }
        else {
            u16 srcval, mask;
            u16 *shiftreg;

            srcoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            disp = (s16) * shiftreg >> 4;
            srcval = fetch_data_word(srcoffset + disp);
            mask = (u16) (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_word(srcoffset + disp, (u16) (srcval ^ mask));
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, mask;
            u32 *shiftreg;

            srcoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            disp = (s16) * shiftreg >> 5;
            srcval = fetch_data_long(srcoffset + disp);
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_long(srcoffset + disp, srcval ^ mask);
        }
        else {
            u16 srcval, mask;
            u16 *shiftreg;

            srcoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            disp = (s16) * shiftreg >> 4;
            srcval = fetch_data_word(srcoffset + disp);
            mask = (u16) (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
            store_data_word(srcoffset + disp, (u16) (srcval ^ mask));
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *srcreg, *shiftreg;
            u32 mask;

            srcreg = DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0x1F;
            mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
            *srcreg ^= mask;
        }
        else {
            u16 *srcreg, *shiftreg;
            u16 mask;

            srcreg = DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            shiftreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            bit = *shiftreg & 0xF;
            mask = (u16) (0x1 << bit);
            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
            *srcreg ^= mask;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xbc
****************************************************************************/
static void
x86emuOp2_bsf(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("BSF\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, *dstreg;

            srcoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            srcval = fetch_data_long(srcoffset);
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 0; *dstreg < 32; (*dstreg)++)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        else {
            u16 srcval, *dstreg;

            srcoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            srcval = fetch_data_word(srcoffset);
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 0; *dstreg < 16; (*dstreg)++)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, *dstreg;

            srcoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            srcval = fetch_data_long(srcoffset);
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 0; *dstreg < 32; (*dstreg)++)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        else {
            u16 srcval, *dstreg;

            srcoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            srcval = fetch_data_word(srcoffset);
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 0; *dstreg < 16; (*dstreg)++)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, *dstreg;

            srcoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            srcval = fetch_data_long(srcoffset);
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 0; *dstreg < 32; (*dstreg)++)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        else {
            u16 srcval, *dstreg;

            srcoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            srcval = fetch_data_word(srcoffset);
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 0; *dstreg < 16; (*dstreg)++)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, *dstreg;

            srcval = *DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 0; *dstreg < 32; (*dstreg)++)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        else {
            u16 srcval, *dstreg;

            srcval = *DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 0; *dstreg < 16; (*dstreg)++)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xbd
****************************************************************************/
static void
x86emuOp2_bsr(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("BSR\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, *dstreg;

            srcoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            srcval = fetch_data_long(srcoffset);
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 31; *dstreg > 0; (*dstreg)--)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        else {
            u16 srcval, *dstreg;

            srcoffset = decode_rm00_address(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            srcval = fetch_data_word(srcoffset);
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 15; *dstreg > 0; (*dstreg)--)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, *dstreg;

            srcoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            srcval = fetch_data_long(srcoffset);
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 31; *dstreg > 0; (*dstreg)--)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        else {
            u16 srcval, *dstreg;

            srcoffset = decode_rm01_address(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            srcval = fetch_data_word(srcoffset);
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 15; *dstreg > 0; (*dstreg)--)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, *dstreg;

            srcoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            srcval = fetch_data_long(srcoffset);
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 31; *dstreg > 0; (*dstreg)--)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        else {
            u16 srcval, *dstreg;

            srcoffset = decode_rm10_address(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            srcval = fetch_data_word(srcoffset);
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 15; *dstreg > 0; (*dstreg)--)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 srcval, *dstreg;

            srcval = *DECODE_RM_LONG_REGISTER(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_LONG_REGISTER(rh);
            TRACE_AND_STEP();
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 31; *dstreg > 0; (*dstreg)--)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        else {
            u16 srcval, *dstreg;

            srcval = *DECODE_RM_WORD_REGISTER(rl);
            DECODE_PRINTF(",");
            dstreg = DECODE_RM_WORD_REGISTER(rh);
            TRACE_AND_STEP();
            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
            for (*dstreg = 15; *dstreg > 0; (*dstreg)--)
                if ((srcval >> *dstreg) & 1)
                    break;
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xbe
****************************************************************************/
static void
x86emuOp2_movsx_byte_R_RM(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint srcoffset;

    START_OF_INSTR();
    DECODE_PRINTF("MOVSX\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = (s32) ((s8) fetch_data_byte(srcoffset));
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm00_address(rl);
            srcval = (s16) ((s8) fetch_data_byte(srcoffset));
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        break;
    case 1:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = (s32) ((s8) fetch_data_byte(srcoffset));
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm01_address(rl);
            srcval = (s16) ((s8) fetch_data_byte(srcoffset));
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        break;
    case 2:
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u32 srcval;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = (s32) ((s8) fetch_data_byte(srcoffset));
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        else {
            u16 *destreg;
            u16 srcval;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcoffset = decode_rm10_address(rl);
            srcval = (s16) ((s8) fetch_data_byte(srcoffset));
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = srcval;
        }
        break;
    case 3:                    /* register to register */
        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
            u32 *destreg;
            u8 *srcreg;

            destreg = DECODE_RM_LONG_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_BYTE_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = (s32) ((s8) * srcreg);
        }
        else {
            u16 *destreg;
            u8 *srcreg;

            destreg = DECODE_RM_WORD_REGISTER(rh);
            DECODE_PRINTF(",");
            srcreg = DECODE_RM_BYTE_REGISTER(rl);
            DECODE_PRINTF("\n");
            TRACE_AND_STEP();
            *destreg = (s16) ((s8) * srcreg);
        }
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
Handles opcode 0x0f,0xbf
****************************************************************************/
static void
x86emuOp2_movsx_word_R_RM(u8 X86EMU_UNUSED(op2))
{
    int mod, rl, rh;
    uint srcoffset;
    u32 *destreg;
    u32 srcval;
    u16 *srcreg;

    START_OF_INSTR();
    DECODE_PRINTF("MOVSX\t");
    FETCH_DECODE_MODRM(mod, rh, rl);
    switch (mod) {
    case 0:
        destreg = DECODE_RM_LONG_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm00_address(rl);
        srcval = (s32) ((s16) fetch_data_word(srcoffset));
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = srcval;
        break;
    case 1:
        destreg = DECODE_RM_LONG_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm01_address(rl);
        srcval = (s32) ((s16) fetch_data_word(srcoffset));
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = srcval;
        break;
    case 2:
        destreg = DECODE_RM_LONG_REGISTER(rh);
        DECODE_PRINTF(",");
        srcoffset = decode_rm10_address(rl);
        srcval = (s32) ((s16) fetch_data_word(srcoffset));
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = srcval;
        break;
    case 3:                    /* register to register */
        destreg = DECODE_RM_LONG_REGISTER(rh);
        DECODE_PRINTF(",");
        srcreg = DECODE_RM_WORD_REGISTER(rl);
        DECODE_PRINTF("\n");
        TRACE_AND_STEP();
        *destreg = (s32) ((s16) * srcreg);
        break;
    }
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/* Handles opcodes 0xc8-0xcf */
static void
x86emuOp2_bswap(u8 X86EMU_UNUSED(op2))
{
    START_OF_INSTR();
    DECODE_PRINTF("BSWAP\n");
    TRACE_AND_STEP();

    switch (op2) {
    case 0xc8:
        M.x86.R_EAX = bswap_32(M.x86.R_EAX);
        break;
    case 0xc9:
        M.x86.R_ECX = bswap_32(M.x86.R_ECX);
        break;
    case 0xca:
        M.x86.R_EDX = bswap_32(M.x86.R_EDX);
        break;
    case 0xcb:
        M.x86.R_EBX = bswap_32(M.x86.R_EBX);
        break;
    case 0xcc:
        M.x86.R_ESP = bswap_32(M.x86.R_ESP);
        break;
    case 0xcd:
        M.x86.R_EBP = bswap_32(M.x86.R_EBP);
        break;
    case 0xce:
        M.x86.R_ESI = bswap_32(M.x86.R_ESI);
        break;
    case 0xcf:
        M.x86.R_EDI = bswap_32(M.x86.R_EDI);
        break;
    default:
        /* can't happen */
        break;
    }

    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/***************************************************************************
 * Double byte operation code table:
 **************************************************************************/
void (*x86emu_optab2[256]) (u8) = {
                                        /*  0x00 */ x86emuOp2_illegal_op,
                                        /* Group F (ring 0 PM)      */
                                                /*  0x01 */ x86emuOp2_illegal_op,
                                                /* Group G (ring 0 PM)      */
                                                /*  0x02 */ x86emuOp2_illegal_op,
                                                /* lar (ring 0 PM)          */
                                                /*  0x03 */ x86emuOp2_illegal_op,
                                                /* lsl (ring 0 PM)          */
/*  0x04 */ x86emuOp2_illegal_op,
                                                /*  0x05 */ x86emuOp2_illegal_op,
                                                /* loadall (undocumented)   */
                                                /*  0x06 */ x86emuOp2_illegal_op,
                                                /* clts (ring 0 PM)         */
                                                /*  0x07 */ x86emuOp2_illegal_op,
                                                /* loadall (undocumented)   */
                                                /*  0x08 */ x86emuOp2_illegal_op,
                                                /* invd (ring 0 PM)         */
                                                /*  0x09 */ x86emuOp2_illegal_op,
                                                /* wbinvd (ring 0 PM)       */
/*  0x0a */ x86emuOp2_illegal_op,
/*  0x0b */ x86emuOp2_illegal_op,
/*  0x0c */ x86emuOp2_illegal_op,
/*  0x0d */ x86emuOp2_illegal_op,
/*  0x0e */ x86emuOp2_illegal_op,
/*  0x0f */ x86emuOp2_illegal_op,
/*  0x10 */ x86emuOp2_illegal_op,
/*  0x11 */ x86emuOp2_illegal_op,
/*  0x12 */ x86emuOp2_illegal_op,
/*  0x13 */ x86emuOp2_illegal_op,
/*  0x14 */ x86emuOp2_illegal_op,
/*  0x15 */ x86emuOp2_illegal_op,
/*  0x16 */ x86emuOp2_illegal_op,
/*  0x17 */ x86emuOp2_illegal_op,
/*  0x18 */ x86emuOp2_illegal_op,
/*  0x19 */ x86emuOp2_illegal_op,
/*  0x1a */ x86emuOp2_illegal_op,
/*  0x1b */ x86emuOp2_illegal_op,
/*  0x1c */ x86emuOp2_illegal_op,
/*  0x1d */ x86emuOp2_illegal_op,
/*  0x1e */ x86emuOp2_illegal_op,
/*  0x1f */ x86emuOp2_illegal_op,
                                                /*  0x20 */ x86emuOp2_illegal_op,
                                                /* mov reg32,creg (ring 0 PM) */
                                                /*  0x21 */ x86emuOp2_illegal_op,
                                                /* mov reg32,dreg (ring 0 PM) */
                                                /*  0x22 */ x86emuOp2_illegal_op,
                                                /* mov creg,reg32 (ring 0 PM) */
                                                /*  0x23 */ x86emuOp2_illegal_op,
                                                /* mov dreg,reg32 (ring 0 PM) */
                                                /*  0x24 */ x86emuOp2_illegal_op,
                                                /* mov reg32,treg (ring 0 PM) */
/*  0x25 */ x86emuOp2_illegal_op,
                                                /*  0x26 */ x86emuOp2_illegal_op,
                                                /* mov treg,reg32 (ring 0 PM) */
/*  0x27 */ x86emuOp2_illegal_op,
/*  0x28 */ x86emuOp2_illegal_op,
/*  0x29 */ x86emuOp2_illegal_op,
/*  0x2a */ x86emuOp2_illegal_op,
/*  0x2b */ x86emuOp2_illegal_op,
/*  0x2c */ x86emuOp2_illegal_op,
/*  0x2d */ x86emuOp2_illegal_op,
/*  0x2e */ x86emuOp2_illegal_op,
/*  0x2f */ x86emuOp2_illegal_op,
/*  0x30 */ x86emuOp2_illegal_op,
/*  0x31 */ x86emuOp2_rdtsc,
/*  0x32 */ x86emuOp2_illegal_op,
/*  0x33 */ x86emuOp2_illegal_op,
/*  0x34 */ x86emuOp2_illegal_op,
/*  0x35 */ x86emuOp2_illegal_op,
/*  0x36 */ x86emuOp2_illegal_op,
/*  0x37 */ x86emuOp2_illegal_op,
/*  0x38 */ x86emuOp2_illegal_op,
/*  0x39 */ x86emuOp2_illegal_op,
/*  0x3a */ x86emuOp2_illegal_op,
/*  0x3b */ x86emuOp2_illegal_op,
/*  0x3c */ x86emuOp2_illegal_op,
/*  0x3d */ x86emuOp2_illegal_op,
/*  0x3e */ x86emuOp2_illegal_op,
/*  0x3f */ x86emuOp2_illegal_op,
/*  0x40 */ x86emuOp2_illegal_op,
/*  0x41 */ x86emuOp2_illegal_op,
/*  0x42 */ x86emuOp2_illegal_op,
/*  0x43 */ x86emuOp2_illegal_op,
/*  0x44 */ x86emuOp2_illegal_op,
/*  0x45 */ x86emuOp2_illegal_op,
/*  0x46 */ x86emuOp2_illegal_op,
/*  0x47 */ x86emuOp2_illegal_op,
/*  0x48 */ x86emuOp2_illegal_op,
/*  0x49 */ x86emuOp2_illegal_op,
/*  0x4a */ x86emuOp2_illegal_op,
/*  0x4b */ x86emuOp2_illegal_op,
/*  0x4c */ x86emuOp2_illegal_op,
/*  0x4d */ x86emuOp2_illegal_op,
/*  0x4e */ x86emuOp2_illegal_op,
/*  0x4f */ x86emuOp2_illegal_op,
/*  0x50 */ x86emuOp2_illegal_op,
/*  0x51 */ x86emuOp2_illegal_op,
/*  0x52 */ x86emuOp2_illegal_op,
/*  0x53 */ x86emuOp2_illegal_op,
/*  0x54 */ x86emuOp2_illegal_op,
/*  0x55 */ x86emuOp2_illegal_op,
/*  0x56 */ x86emuOp2_illegal_op,
/*  0x57 */ x86emuOp2_illegal_op,
/*  0x58 */ x86emuOp2_illegal_op,
/*  0x59 */ x86emuOp2_illegal_op,
/*  0x5a */ x86emuOp2_illegal_op,
/*  0x5b */ x86emuOp2_illegal_op,
/*  0x5c */ x86emuOp2_illegal_op,
/*  0x5d */ x86emuOp2_illegal_op,
/*  0x5e */ x86emuOp2_illegal_op,
/*  0x5f */ x86emuOp2_illegal_op,
/*  0x60 */ x86emuOp2_illegal_op,
/*  0x61 */ x86emuOp2_illegal_op,
/*  0x62 */ x86emuOp2_illegal_op,
/*  0x63 */ x86emuOp2_illegal_op,
/*  0x64 */ x86emuOp2_illegal_op,
/*  0x65 */ x86emuOp2_illegal_op,
/*  0x66 */ x86emuOp2_illegal_op,
/*  0x67 */ x86emuOp2_illegal_op,
/*  0x68 */ x86emuOp2_illegal_op,
/*  0x69 */ x86emuOp2_illegal_op,
/*  0x6a */ x86emuOp2_illegal_op,
/*  0x6b */ x86emuOp2_illegal_op,
/*  0x6c */ x86emuOp2_illegal_op,
/*  0x6d */ x86emuOp2_illegal_op,
/*  0x6e */ x86emuOp2_illegal_op,
/*  0x6f */ x86emuOp2_illegal_op,
/*  0x70 */ x86emuOp2_illegal_op,
/*  0x71 */ x86emuOp2_illegal_op,
/*  0x72 */ x86emuOp2_illegal_op,
/*  0x73 */ x86emuOp2_illegal_op,
/*  0x74 */ x86emuOp2_illegal_op,
/*  0x75 */ x86emuOp2_illegal_op,
/*  0x76 */ x86emuOp2_illegal_op,
/*  0x77 */ x86emuOp2_illegal_op,
/*  0x78 */ x86emuOp2_illegal_op,
/*  0x79 */ x86emuOp2_illegal_op,
/*  0x7a */ x86emuOp2_illegal_op,
/*  0x7b */ x86emuOp2_illegal_op,
/*  0x7c */ x86emuOp2_illegal_op,
/*  0x7d */ x86emuOp2_illegal_op,
/*  0x7e */ x86emuOp2_illegal_op,
/*  0x7f */ x86emuOp2_illegal_op,
/*  0x80 */ x86emuOp2_long_jump,
/*  0x81 */ x86emuOp2_long_jump,
/*  0x82 */ x86emuOp2_long_jump,
/*  0x83 */ x86emuOp2_long_jump,
/*  0x84 */ x86emuOp2_long_jump,
/*  0x85 */ x86emuOp2_long_jump,
/*  0x86 */ x86emuOp2_long_jump,
/*  0x87 */ x86emuOp2_long_jump,
/*  0x88 */ x86emuOp2_long_jump,
/*  0x89 */ x86emuOp2_long_jump,
/*  0x8a */ x86emuOp2_long_jump,
/*  0x8b */ x86emuOp2_long_jump,
/*  0x8c */ x86emuOp2_long_jump,
/*  0x8d */ x86emuOp2_long_jump,
/*  0x8e */ x86emuOp2_long_jump,
/*  0x8f */ x86emuOp2_long_jump,
/*  0x90 */ x86emuOp2_set_byte,
/*  0x91 */ x86emuOp2_set_byte,
/*  0x92 */ x86emuOp2_set_byte,
/*  0x93 */ x86emuOp2_set_byte,
/*  0x94 */ x86emuOp2_set_byte,
/*  0x95 */ x86emuOp2_set_byte,
/*  0x96 */ x86emuOp2_set_byte,
/*  0x97 */ x86emuOp2_set_byte,
/*  0x98 */ x86emuOp2_set_byte,
/*  0x99 */ x86emuOp2_set_byte,
/*  0x9a */ x86emuOp2_set_byte,
/*  0x9b */ x86emuOp2_set_byte,
/*  0x9c */ x86emuOp2_set_byte,
/*  0x9d */ x86emuOp2_set_byte,
/*  0x9e */ x86emuOp2_set_byte,
/*  0x9f */ x86emuOp2_set_byte,
/*  0xa0 */ x86emuOp2_push_FS,
/*  0xa1 */ x86emuOp2_pop_FS,
/*  0xa2 */ x86emuOp2_cpuid,
/*  0xa3 */ x86emuOp2_bt_R,
/*  0xa4 */ x86emuOp2_shld_IMM,
/*  0xa5 */ x86emuOp2_shld_CL,
/*  0xa6 */ x86emuOp2_illegal_op,
/*  0xa7 */ x86emuOp2_illegal_op,
/*  0xa8 */ x86emuOp2_push_GS,
/*  0xa9 */ x86emuOp2_pop_GS,
/*  0xaa */ x86emuOp2_illegal_op,
/*  0xab */ x86emuOp2_bts_R,
/*  0xac */ x86emuOp2_shrd_IMM,
/*  0xad */ x86emuOp2_shrd_CL,
/*  0xae */ x86emuOp2_illegal_op,
/*  0xaf */ x86emuOp2_imul_R_RM,
                                                /*  0xb0 */ x86emuOp2_illegal_op,
                                                /* TODO: cmpxchg */
                                                /*  0xb1 */ x86emuOp2_illegal_op,
                                                /* TODO: cmpxchg */
/*  0xb2 */ x86emuOp2_lss_R_IMM,
/*  0xb3 */ x86emuOp2_btr_R,
/*  0xb4 */ x86emuOp2_lfs_R_IMM,
/*  0xb5 */ x86emuOp2_lgs_R_IMM,
/*  0xb6 */ x86emuOp2_movzx_byte_R_RM,
/*  0xb7 */ x86emuOp2_movzx_word_R_RM,
/*  0xb8 */ x86emuOp2_illegal_op,
/*  0xb9 */ x86emuOp2_illegal_op,
/*  0xba */ x86emuOp2_btX_I,
/*  0xbb */ x86emuOp2_btc_R,
/*  0xbc */ x86emuOp2_bsf,
/*  0xbd */ x86emuOp2_bsr,
/*  0xbe */ x86emuOp2_movsx_byte_R_RM,
/*  0xbf */ x86emuOp2_movsx_word_R_RM,
                                                /*  0xc0 */ x86emuOp2_illegal_op,
                                                /* TODO: xadd */
                                                /*  0xc1 */ x86emuOp2_illegal_op,
                                                /* TODO: xadd */
/*  0xc2 */ x86emuOp2_illegal_op,
/*  0xc3 */ x86emuOp2_illegal_op,
/*  0xc4 */ x86emuOp2_illegal_op,
/*  0xc5 */ x86emuOp2_illegal_op,
/*  0xc6 */ x86emuOp2_illegal_op,
/*  0xc7 */ x86emuOp2_illegal_op,
/*  0xc8 */ x86emuOp2_bswap,
/*  0xc9 */ x86emuOp2_bswap,
/*  0xca */ x86emuOp2_bswap,
/*  0xcb */ x86emuOp2_bswap,
/*  0xcc */ x86emuOp2_bswap,
/*  0xcd */ x86emuOp2_bswap,
/*  0xce */ x86emuOp2_bswap,
/*  0xcf */ x86emuOp2_bswap,
/*  0xd0 */ x86emuOp2_illegal_op,
/*  0xd1 */ x86emuOp2_illegal_op,
/*  0xd2 */ x86emuOp2_illegal_op,
/*  0xd3 */ x86emuOp2_illegal_op,
/*  0xd4 */ x86emuOp2_illegal_op,
/*  0xd5 */ x86emuOp2_illegal_op,
/*  0xd6 */ x86emuOp2_illegal_op,
/*  0xd7 */ x86emuOp2_illegal_op,
/*  0xd8 */ x86emuOp2_illegal_op,
/*  0xd9 */ x86emuOp2_illegal_op,
/*  0xda */ x86emuOp2_illegal_op,
/*  0xdb */ x86emuOp2_illegal_op,
/*  0xdc */ x86emuOp2_illegal_op,
/*  0xdd */ x86emuOp2_illegal_op,
/*  0xde */ x86emuOp2_illegal_op,
/*  0xdf */ x86emuOp2_illegal_op,
/*  0xe0 */ x86emuOp2_illegal_op,
/*  0xe1 */ x86emuOp2_illegal_op,
/*  0xe2 */ x86emuOp2_illegal_op,
/*  0xe3 */ x86emuOp2_illegal_op,
/*  0xe4 */ x86emuOp2_illegal_op,
/*  0xe5 */ x86emuOp2_illegal_op,
/*  0xe6 */ x86emuOp2_illegal_op,
/*  0xe7 */ x86emuOp2_illegal_op,
/*  0xe8 */ x86emuOp2_illegal_op,
/*  0xe9 */ x86emuOp2_illegal_op,
/*  0xea */ x86emuOp2_illegal_op,
/*  0xeb */ x86emuOp2_illegal_op,
/*  0xec */ x86emuOp2_illegal_op,
/*  0xed */ x86emuOp2_illegal_op,
/*  0xee */ x86emuOp2_illegal_op,
/*  0xef */ x86emuOp2_illegal_op,
/*  0xf0 */ x86emuOp2_illegal_op,
/*  0xf1 */ x86emuOp2_illegal_op,
/*  0xf2 */ x86emuOp2_illegal_op,
/*  0xf3 */ x86emuOp2_illegal_op,
/*  0xf4 */ x86emuOp2_illegal_op,
/*  0xf5 */ x86emuOp2_illegal_op,
/*  0xf6 */ x86emuOp2_illegal_op,
/*  0xf7 */ x86emuOp2_illegal_op,
/*  0xf8 */ x86emuOp2_illegal_op,
/*  0xf9 */ x86emuOp2_illegal_op,
/*  0xfa */ x86emuOp2_illegal_op,
/*  0xfb */ x86emuOp2_illegal_op,
/*  0xfc */ x86emuOp2_illegal_op,
/*  0xfd */ x86emuOp2_illegal_op,
/*  0xfe */ x86emuOp2_illegal_op,
/*  0xff */ x86emuOp2_illegal_op,
};
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d58 2
a59 2
static void x86emuOp2_illegal_op(
	u8 op2)
d61 5
a65 5
	START_OF_INSTR();
	DECODE_PRINTF("ILLEGAL EXTENDED X86 OPCODE\n");
	TRACE_REGS();
	printk("%04x:%04x: %02X ILLEGAL EXTENDED X86 OPCODE!\n",
		M.x86.R_CS, M.x86.R_IP-2,op2);
d76 2
a77 1
static void x86emuOp2_rdtsc(u8 X86EMU_UNUSED(op2))
d111 2
a112 1
static void x86emuOp2_long_jump(u8 op2)
d115 1
a115 1
    char *name = NULL;
d121 1
a121 1
      case 0x80:
d123 1
a123 1
        cond =  ACCESS_FLAG(F_OF);
d125 1
a125 1
      case 0x81:
d129 1
a129 1
      case 0x82:
d133 1
a133 1
      case 0x83:
d137 1
a137 1
      case 0x84:
d141 1
a141 1
      case 0x85:
d145 1
a145 1
      case 0x86:
d149 1
a149 1
      case 0x87:
d153 1
a153 1
      case 0x88:
d157 1
a157 1
      case 0x89:
d161 1
a161 1
      case 0x8a:
d165 1
a165 1
      case 0x8b:
d169 1
a169 1
      case 0x8c:
d173 1
a173 1
      case 0x8d:
d177 1
a177 1
      case 0x8e:
d182 1
a182 1
      case 0x8f:
d189 1
a189 1
    (void)name;
d195 1
a195 1
        M.x86.R_IP = (u16)target;
d204 2
a205 1
static void x86emuOp2_set_byte(u8 op2)
d209 2
a210 2
    u8  *destreg;
    char *name = NULL;
d215 1
a215 1
      case 0x90:
d217 1
a217 1
        cond =  ACCESS_FLAG(F_OF);
d219 1
a219 1
      case 0x91:
d223 1
a223 1
      case 0x92:
d227 1
a227 1
      case 0x93:
d231 1
a231 1
      case 0x94:
d235 1
a235 1
      case 0x95:
d239 1
a239 1
      case 0x96:
d243 1
a243 1
      case 0x97:
d247 1
a247 1
      case 0x98:
d251 1
a251 1
      case 0x99:
d255 1
a255 1
      case 0x9a:
d259 1
a259 1
      case 0x9b:
d263 1
a263 1
      case 0x9c:
d267 1
a267 1
      case 0x9d:
d271 1
a271 1
      case 0x9e:
d276 1
a276 1
      case 0x9f:
d283 1
a283 1
    (void)name;
d301 1
a301 1
    case 3:                     /* register to register */
d315 2
a316 1
static void x86emuOp2_push_FS(u8 X86EMU_UNUSED(op2))
d330 2
a331 1
static void x86emuOp2_pop_FS(u8 X86EMU_UNUSED(op2))
d345 2
a346 1
static void x86emuOp2_cpuid(u8 X86EMU_UNUSED(op2))
d360 2
a361 1
static void x86emuOp2_bt_R(u8 X86EMU_UNUSED(op2))
d365 1
a365 1
    int bit,disp;
d381 5
a385 4
            disp = (s16)*shiftreg >> 5;
            srcval = fetch_data_long(srcoffset+disp);
            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit),F_CF);
        } else {
d394 3
a396 3
            disp = (s16)*shiftreg >> 4;
            srcval = fetch_data_word(srcoffset+disp);
            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit),F_CF);
d409 5
a413 4
            disp = (s16)*shiftreg >> 5;
            srcval = fetch_data_long(srcoffset+disp);
            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit),F_CF);
        } else {
d422 3
a424 3
            disp = (s16)*shiftreg >> 4;
            srcval = fetch_data_word(srcoffset+disp);
            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit),F_CF);
d437 5
a441 4
            disp = (s16)*shiftreg >> 5;
            srcval = fetch_data_long(srcoffset+disp);
            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit),F_CF);
        } else {
d450 3
a452 3
            disp = (s16)*shiftreg >> 4;
            srcval = fetch_data_word(srcoffset+disp);
            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit),F_CF);
d455 1
a455 1
    case 3:                     /* register to register */
d457 1
a457 1
            u32 *srcreg,*shiftreg;
d464 4
a467 3
            CONDITIONAL_SET_FLAG(*srcreg & (0x1 << bit),F_CF);
        } else {
            u16 *srcreg,*shiftreg;
d474 1
a474 1
            CONDITIONAL_SET_FLAG(*srcreg & (0x1 << bit),F_CF);
d486 2
a487 1
static void x86emuOp2_shld_IMM(u8 X86EMU_UNUSED(op2))
d491 1
a491 1
	u8 shift;
d510 1
a510 1
            destval = shld_long(destval,*shiftreg,shift);
d512 2
a513 1
        } else {
d525 1
a525 1
            destval = shld_word(destval,*shiftreg,shift);
d542 1
a542 1
            destval = shld_long(destval,*shiftreg,shift);
d544 2
a545 1
        } else {
d557 1
a557 1
            destval = shld_word(destval,*shiftreg,shift);
d574 1
a574 1
            destval = shld_long(destval,*shiftreg,shift);
d576 2
a577 1
        } else {
d589 1
a589 1
            destval = shld_word(destval,*shiftreg,shift);
d593 1
a593 1
    case 3:                     /* register to register */
d595 1
a595 1
            u32 *destreg,*shiftreg;
d604 4
a607 3
            *destreg = shld_long(*destreg,*shiftreg,shift);
        } else {
            u16 *destreg,*shiftreg;
d616 1
a616 1
            *destreg = shld_word(*destreg,*shiftreg,shift);
d628 2
a629 1
static void x86emuOp2_shld_CL(u8 X86EMU_UNUSED(op2))
d649 1
a649 1
            destval = shld_long(destval,*shiftreg,M.x86.R_CL);
d651 2
a652 1
        } else {
d662 1
a662 1
            destval = shld_word(destval,*shiftreg,M.x86.R_CL);
d677 1
a677 1
            destval = shld_long(destval,*shiftreg,M.x86.R_CL);
d679 2
a680 1
        } else {
d690 1
a690 1
            destval = shld_word(destval,*shiftreg,M.x86.R_CL);
d705 1
a705 1
            destval = shld_long(destval,*shiftreg,M.x86.R_CL);
d707 2
a708 1
        } else {
d718 1
a718 1
            destval = shld_word(destval,*shiftreg,M.x86.R_CL);
d722 1
a722 1
    case 3:                     /* register to register */
d724 1
a724 1
            u32 *destreg,*shiftreg;
d731 4
a734 3
            *destreg = shld_long(*destreg,*shiftreg,M.x86.R_CL);
        } else {
            u16 *destreg,*shiftreg;
d741 1
a741 1
            *destreg = shld_word(*destreg,*shiftreg,M.x86.R_CL);
d753 2
a754 1
static void x86emuOp2_push_GS(u8 X86EMU_UNUSED(op2))
d768 2
a769 1
static void x86emuOp2_pop_GS(u8 X86EMU_UNUSED(op2))
d783 2
a784 1
static void x86emuOp2_bts_R(u8 X86EMU_UNUSED(op2))
d788 1
a788 1
    int bit,disp;
d796 1
a796 1
            u32 srcval,mask;
d804 2
a805 2
            disp = (s16)*shiftreg >> 5;
            srcval = fetch_data_long(srcoffset+disp);
d807 5
a811 4
            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
            store_data_long(srcoffset+disp, srcval | mask);
        } else {
            u16 srcval,mask;
d819 5
a823 5
            disp = (s16)*shiftreg >> 4;
            srcval = fetch_data_word(srcoffset+disp);
			mask = (u16)(0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
            store_data_word(srcoffset+disp, srcval | mask);
d828 1
a828 1
            u32 srcval,mask;
d836 2
a837 2
            disp = (s16)*shiftreg >> 5;
            srcval = fetch_data_long(srcoffset+disp);
d839 5
a843 4
            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
            store_data_long(srcoffset+disp, srcval | mask);
        } else {
            u16 srcval,mask;
d851 5
a855 5
            disp = (s16)*shiftreg >> 4;
            srcval = fetch_data_word(srcoffset+disp);
			mask = (u16)(0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
            store_data_word(srcoffset+disp, srcval | mask);
d860 1
a860 1
            u32 srcval,mask;
d868 2
a869 2
            disp = (s16)*shiftreg >> 5;
            srcval = fetch_data_long(srcoffset+disp);
d871 44
a914 42
            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
            store_data_long(srcoffset+disp, srcval | mask);
        } else {
            u16 srcval,mask;
            u16 *shiftreg;

			srcoffset = decode_rm10_address(rl);
			DECODE_PRINTF(",");
			shiftreg = DECODE_RM_WORD_REGISTER(rh);
			TRACE_AND_STEP();
			bit = *shiftreg & 0xF;
			disp = (s16)*shiftreg >> 4;
			srcval = fetch_data_word(srcoffset+disp);
			mask = (u16)(0x1 << bit);
			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
			store_data_word(srcoffset+disp, srcval | mask);
		}
		break;
	case 3:                     /* register to register */
		if (M.x86.mode & SYSMODE_PREFIX_DATA) {
			u32 *srcreg,*shiftreg;
			u32 mask;

			srcreg = DECODE_RM_LONG_REGISTER(rl);
			DECODE_PRINTF(",");
			shiftreg = DECODE_RM_LONG_REGISTER(rh);
			TRACE_AND_STEP();
			bit = *shiftreg & 0x1F;
			mask = (0x1 << bit);
			CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
			*srcreg |= mask;
		} else {
			u16 *srcreg,*shiftreg;
			u16 mask;

			srcreg = DECODE_RM_WORD_REGISTER(rl);
			DECODE_PRINTF(",");
			shiftreg = DECODE_RM_WORD_REGISTER(rh);
			TRACE_AND_STEP();
			bit = *shiftreg & 0xF;
			mask = (u16)(0x1 << bit);
            CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
d927 2
a928 1
static void x86emuOp2_shrd_IMM(u8 X86EMU_UNUSED(op2))
d932 1
a932 1
	u8 shift;
d951 1
a951 1
            destval = shrd_long(destval,*shiftreg,shift);
d953 2
a954 1
        } else {
d966 1
a966 1
            destval = shrd_word(destval,*shiftreg,shift);
d983 1
a983 1
            destval = shrd_long(destval,*shiftreg,shift);
d985 2
a986 1
        } else {
d998 1
a998 1
            destval = shrd_word(destval,*shiftreg,shift);
d1015 1
a1015 1
            destval = shrd_long(destval,*shiftreg,shift);
d1017 2
a1018 1
        } else {
d1030 1
a1030 1
            destval = shrd_word(destval,*shiftreg,shift);
d1034 1
a1034 1
    case 3:                     /* register to register */
d1036 1
a1036 1
            u32 *destreg,*shiftreg;
d1045 4
a1048 3
            *destreg = shrd_long(*destreg,*shiftreg,shift);
        } else {
            u16 *destreg,*shiftreg;
d1057 1
a1057 1
            *destreg = shrd_word(*destreg,*shiftreg,shift);
d1069 2
a1070 1
static void x86emuOp2_shrd_CL(u8 X86EMU_UNUSED(op2))
d1090 1
a1090 1
            destval = shrd_long(destval,*shiftreg,M.x86.R_CL);
d1092 2
a1093 1
        } else {
d1103 1
a1103 1
            destval = shrd_word(destval,*shiftreg,M.x86.R_CL);
d1118 1
a1118 1
            destval = shrd_long(destval,*shiftreg,M.x86.R_CL);
d1120 2
a1121 1
        } else {
d1131 1
a1131 1
            destval = shrd_word(destval,*shiftreg,M.x86.R_CL);
d1146 1
a1146 1
            destval = shrd_long(destval,*shiftreg,M.x86.R_CL);
d1148 2
a1149 1
        } else {
d1159 1
a1159 1
            destval = shrd_word(destval,*shiftreg,M.x86.R_CL);
d1163 1
a1163 1
    case 3:                     /* register to register */
d1165 1
a1165 1
            u32 *destreg,*shiftreg;
d1172 4
a1175 3
            *destreg = shrd_long(*destreg,*shiftreg,M.x86.R_CL);
        } else {
            u16 *destreg,*shiftreg;
d1182 1
a1182 1
            *destreg = shrd_word(*destreg,*shiftreg,M.x86.R_CL);
d1194 2
a1195 1
static void x86emuOp2_imul_R_RM(u8 X86EMU_UNUSED(op2))
d1208 1
a1208 1
            u32 res_lo,res_hi;
d1215 1
a1215 1
            imul_long_direct(&res_lo,&res_hi,(s32)*destreg,(s32)srcval);
d1219 2
a1220 1
            } else {
d1224 3
a1226 2
            *destreg = (u32)res_lo;
        } else {
d1236 1
a1236 1
            res = (s16)*destreg * (s16)srcval;
d1240 2
a1241 1
            } else {
d1245 1
a1245 1
            *destreg = (u16)res;
d1252 1
a1252 1
            u32 res_lo,res_hi;
d1259 1
a1259 1
            imul_long_direct(&res_lo,&res_hi,(s32)*destreg,(s32)srcval);
d1263 2
a1264 1
            } else {
d1268 3
a1270 2
            *destreg = (u32)res_lo;
        } else {
d1280 1
a1280 1
            res = (s16)*destreg * (s16)srcval;
d1284 2
a1285 1
            } else {
d1289 1
a1289 1
            *destreg = (u16)res;
d1296 1
a1296 1
            u32 res_lo,res_hi;
d1303 1
a1303 1
            imul_long_direct(&res_lo,&res_hi,(s32)*destreg,(s32)srcval);
d1307 2
a1308 1
            } else {
d1312 3
a1314 2
            *destreg = (u32)res_lo;
        } else {
d1324 1
a1324 1
            res = (s16)*destreg * (s16)srcval;
d1328 2
a1329 1
            } else {
d1333 1
a1333 1
            *destreg = (u16)res;
d1336 1
a1336 1
    case 3:                     /* register to register */
d1338 2
a1339 2
            u32 *destreg,*srcreg;
            u32 res_lo,res_hi;
d1345 1
a1345 1
            imul_long_direct(&res_lo,&res_hi,(s32)*destreg,(s32)*srcreg);
d1349 2
a1350 1
            } else {
d1354 4
a1357 3
            *destreg = (u32)res_lo;
        } else {
            u16 *destreg,*srcreg;
d1363 1
a1363 1
            res = (s16)*destreg * (s16)*srcreg;
d1367 2
a1368 1
            } else {
d1372 1
a1372 1
            *destreg = (u16)res;
d1384 2
a1385 1
static void x86emuOp2_lss_R_IMM(u8 X86EMU_UNUSED(op2))
d1387 1
a1387 1
	int mod, rh, rl;
d1422 1
a1422 1
    case 3:                     /* register to register */
d1434 2
a1435 1
static void x86emuOp2_btr_R(u8 X86EMU_UNUSED(op2))
d1437 135
a1571 131
	int mod, rl, rh;
	uint srcoffset;
	int bit,disp;

	START_OF_INSTR();
	DECODE_PRINTF("BTR\t");
	FETCH_DECODE_MODRM(mod, rh, rl);
	switch (mod) {
	case 0:
		if (M.x86.mode & SYSMODE_PREFIX_DATA) {
			u32 srcval,mask;
			u32 *shiftreg;

			srcoffset = decode_rm00_address(rl);
			DECODE_PRINTF(",");
			shiftreg = DECODE_RM_LONG_REGISTER(rh);
			TRACE_AND_STEP();
			bit = *shiftreg & 0x1F;
			disp = (s16)*shiftreg >> 5;
			srcval = fetch_data_long(srcoffset+disp);
			mask = (0x1 << bit);
			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
			store_data_long(srcoffset+disp, srcval & ~mask);
		} else {
			u16 srcval,mask;
			u16 *shiftreg;

			srcoffset = decode_rm00_address(rl);
			DECODE_PRINTF(",");
			shiftreg = DECODE_RM_WORD_REGISTER(rh);
			TRACE_AND_STEP();
			bit = *shiftreg & 0xF;
			disp = (s16)*shiftreg >> 4;
			srcval = fetch_data_word(srcoffset+disp);
			mask = (u16)(0x1 << bit);
			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
			store_data_word(srcoffset+disp, (u16)(srcval & ~mask));
		}
		break;
	case 1:
		if (M.x86.mode & SYSMODE_PREFIX_DATA) {
			u32 srcval,mask;
			u32 *shiftreg;

			srcoffset = decode_rm01_address(rl);
			DECODE_PRINTF(",");
			shiftreg = DECODE_RM_LONG_REGISTER(rh);
			TRACE_AND_STEP();
			bit = *shiftreg & 0x1F;
			disp = (s16)*shiftreg >> 5;
			srcval = fetch_data_long(srcoffset+disp);
			mask = (0x1 << bit);
			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
			store_data_long(srcoffset+disp, srcval & ~mask);
		} else {
			u16 srcval,mask;
			u16 *shiftreg;

			srcoffset = decode_rm01_address(rl);
			DECODE_PRINTF(",");
			shiftreg = DECODE_RM_WORD_REGISTER(rh);
			TRACE_AND_STEP();
			bit = *shiftreg & 0xF;
			disp = (s16)*shiftreg >> 4;
			srcval = fetch_data_word(srcoffset+disp);
			mask = (u16)(0x1 << bit);
			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
			store_data_word(srcoffset+disp, (u16)(srcval & ~mask));
		}
		break;
	case 2:
		if (M.x86.mode & SYSMODE_PREFIX_DATA) {
			u32 srcval,mask;
			u32 *shiftreg;

			srcoffset = decode_rm10_address(rl);
			DECODE_PRINTF(",");
			shiftreg = DECODE_RM_LONG_REGISTER(rh);
			TRACE_AND_STEP();
			bit = *shiftreg & 0x1F;
			disp = (s16)*shiftreg >> 5;
			srcval = fetch_data_long(srcoffset+disp);
			mask = (0x1 << bit);
			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
			store_data_long(srcoffset+disp, srcval & ~mask);
		} else {
			u16 srcval,mask;
			u16 *shiftreg;

			srcoffset = decode_rm10_address(rl);
			DECODE_PRINTF(",");
			shiftreg = DECODE_RM_WORD_REGISTER(rh);
			TRACE_AND_STEP();
			bit = *shiftreg & 0xF;
			disp = (s16)*shiftreg >> 4;
			srcval = fetch_data_word(srcoffset+disp);
			mask = (u16)(0x1 << bit);
			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
			store_data_word(srcoffset+disp, (u16)(srcval & ~mask));
		}
		break;
	case 3:                     /* register to register */
		if (M.x86.mode & SYSMODE_PREFIX_DATA) {
			u32 *srcreg,*shiftreg;
			u32 mask;

			srcreg = DECODE_RM_LONG_REGISTER(rl);
			DECODE_PRINTF(",");
			shiftreg = DECODE_RM_LONG_REGISTER(rh);
			TRACE_AND_STEP();
			bit = *shiftreg & 0x1F;
			mask = (0x1 << bit);
			CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
			*srcreg &= ~mask;
		} else {
			u16 *srcreg,*shiftreg;
			u16 mask;

			srcreg = DECODE_RM_WORD_REGISTER(rl);
			DECODE_PRINTF(",");
			shiftreg = DECODE_RM_WORD_REGISTER(rh);
			TRACE_AND_STEP();
			bit = *shiftreg & 0xF;
			mask = (u16)(0x1 << bit);
			CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
			*srcreg &= ~mask;
		}
		break;
	}
	DECODE_CLEAR_SEGOVR();
	END_OF_INSTR();
d1578 2
a1579 1
static void x86emuOp2_lfs_R_IMM(u8 X86EMU_UNUSED(op2))
d1581 1
a1581 1
	int mod, rh, rl;
d1616 1
a1616 1
    case 3:                     /* register to register */
d1628 2
a1629 1
static void x86emuOp2_lgs_R_IMM(u8 X86EMU_UNUSED(op2))
d1631 1
a1631 1
	int mod, rh, rl;
d1666 1
a1666 1
    case 3:                     /* register to register */
d1678 2
a1679 1
static void x86emuOp2_movzx_byte_R_RM(u8 X86EMU_UNUSED(op2))
d1700 2
a1701 1
        } else {
d1726 2
a1727 1
        } else {
d1752 2
a1753 1
        } else {
d1766 1
a1766 1
    case 3:                     /* register to register */
d1769 1
a1769 1
            u8  *srcreg;
d1777 2
a1778 1
        } else {
d1780 1
a1780 1
            u8  *srcreg;
d1799 2
a1800 1
static void x86emuOp2_movzx_word_R_RM(u8 X86EMU_UNUSED(op2))
d1839 1
a1839 1
    case 3:                     /* register to register */
d1856 2
a1857 1
static void x86emuOp2_btX_I(u8 X86EMU_UNUSED(op2))
d1867 2
a1868 2
	DECODE_PRINTF("BT\t");
	break;
d1870 2
a1871 2
	DECODE_PRINTF("BTS\t");
	break;
d1873 2
a1874 2
	DECODE_PRINTF("BTR\t");
	break;
d1876 2
a1877 2
	DECODE_PRINTF("BTC\t");
	break;
d1879 5
a1883 5
	DECODE_PRINTF("ILLEGAL EXTENDED X86 OPCODE\n");
	TRACE_REGS();
	printk("%04x:%04x: %02X%02X ILLEGAL EXTENDED X86 OPCODE EXTENSION!\n",
		M.x86.R_CS, M.x86.R_IP-3,op2, (mod<<6)|(rh<<3)|rl);
	HALT_SYS();
d1897 17
a1913 16
	    mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
	    switch (rh) {
	    case 5:
		store_data_long(srcoffset, srcval | mask);
		break;
	    case 6:
		store_data_long(srcoffset, srcval & ~mask);
		break;
	    case 7:
		store_data_long(srcoffset, srcval ^ mask);
		break;
	    default:
		break;
	    }
        } else {
d1923 15
a1937 15
	    mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
	    switch (rh) {
	    case 5:
		store_data_word(srcoffset, srcval | mask);
		break;
	    case 6:
		store_data_word(srcoffset, srcval & ~mask);
		break;
	    case 7:
		store_data_word(srcoffset, srcval ^ mask);
		break;
	    default:
		break;
	    }
d1951 17
a1967 16
	    mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
	    switch (rh) {
	    case 5:
		store_data_long(srcoffset, srcval | mask);
		break;
	    case 6:
		store_data_long(srcoffset, srcval & ~mask);
		break;
	    case 7:
		store_data_long(srcoffset, srcval ^ mask);
		break;
	    default:
		break;
	    }
        } else {
d1977 15
a1991 15
	    mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
	    switch (rh) {
	    case 5:
		store_data_word(srcoffset, srcval | mask);
		break;
	    case 6:
		store_data_word(srcoffset, srcval & ~mask);
		break;
	    case 7:
		store_data_word(srcoffset, srcval ^ mask);
		break;
	    default:
		break;
	    }
d2005 17
a2021 16
	    mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
	    switch (rh) {
	    case 5:
		store_data_long(srcoffset, srcval | mask);
		break;
	    case 6:
		store_data_long(srcoffset, srcval & ~mask);
		break;
	    case 7:
		store_data_long(srcoffset, srcval ^ mask);
		break;
	    default:
		break;
	    }
        } else {
d2031 15
a2045 15
	    mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
	    switch (rh) {
	    case 5:
		store_data_word(srcoffset, srcval | mask);
		break;
	    case 6:
		store_data_word(srcoffset, srcval & ~mask);
		break;
	    case 7:
		store_data_word(srcoffset, srcval ^ mask);
		break;
	    default:
		break;
	    }
d2048 1
a2048 1
    case 3:                     /* register to register */
d2051 2
a2052 2
	    u32 mask;
	    u8 shift;
d2059 17
a2075 16
	    mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
	    switch (rh) {
	    case 5:
		*srcreg |= mask;
		break;
	    case 6:
		*srcreg &= ~mask;
		break;
	    case 7:
		*srcreg ^= mask;
		break;
	    default:
		break;
	    }
        } else {
d2077 2
a2078 2
	    u16 mask;
	    u8 shift;
d2085 15
a2099 15
	    mask = (0x1 << bit);
            CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
	    switch (rh) {
	    case 5:
		*srcreg |= mask;
		break;
	    case 6:
		*srcreg &= ~mask;
		break;
	    case 7:
		*srcreg ^= mask;
		break;
	    default:
		break;
	    }
d2111 2
a2112 1
static void x86emuOp2_btc_R(u8 X86EMU_UNUSED(op2))
d2116 1
a2116 1
    int bit,disp;
d2124 1
a2124 1
            u32 srcval,mask;
d2132 2
a2133 2
            disp = (s16)*shiftreg >> 5;
            srcval = fetch_data_long(srcoffset+disp);
d2135 5
a2139 4
            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
            store_data_long(srcoffset+disp, srcval ^ mask);
        } else {
            u16 srcval,mask;
d2147 5
a2151 5
            disp = (s16)*shiftreg >> 4;
            srcval = fetch_data_word(srcoffset+disp);
			mask = (u16)(0x1 << bit);
            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
			store_data_word(srcoffset+disp, (u16)(srcval ^ mask));
d2156 1
a2156 1
            u32 srcval,mask;
d2164 2
a2165 2
            disp = (s16)*shiftreg >> 5;
            srcval = fetch_data_long(srcoffset+disp);
d2167 5
a2171 4
            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
            store_data_long(srcoffset+disp, srcval ^ mask);
        } else {
            u16 srcval,mask;
d2179 5
a2183 5
            disp = (s16)*shiftreg >> 4;
            srcval = fetch_data_word(srcoffset+disp);
			mask = (u16)(0x1 << bit);
			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
			store_data_word(srcoffset+disp, (u16)(srcval ^ mask));
d2188 1
a2188 1
            u32 srcval,mask;
d2196 2
a2197 2
            disp = (s16)*shiftreg >> 5;
            srcval = fetch_data_long(srcoffset+disp);
d2199 5
a2203 4
            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
            store_data_long(srcoffset+disp, srcval ^ mask);
        } else {
            u16 srcval,mask;
d2211 5
a2215 5
            disp = (s16)*shiftreg >> 4;
            srcval = fetch_data_word(srcoffset+disp);
			mask = (u16)(0x1 << bit);
			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
			store_data_word(srcoffset+disp, (u16)(srcval ^ mask));
d2218 1
a2218 1
    case 3:                     /* register to register */
d2220 1
a2220 1
			u32 *srcreg,*shiftreg;
d2229 14
a2242 13
			CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
			*srcreg ^= mask;
		} else {
			u16 *srcreg,*shiftreg;
			u16 mask;

			srcreg = DECODE_RM_WORD_REGISTER(rl);
			DECODE_PRINTF(",");
			shiftreg = DECODE_RM_WORD_REGISTER(rh);
			TRACE_AND_STEP();
			bit = *shiftreg & 0xF;
			mask = (u16)(0x1 << bit);
            CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
d2255 2
a2256 1
static void x86emuOp2_bsf(u8 X86EMU_UNUSED(op2))
d2264 1
a2264 1
    switch(mod) {
d2266 2
a2267 2
	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
	    u32 srcval, *dstreg;
d2269 24
a2292 21
	    srcoffset = decode_rm00_address(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_LONG_REGISTER(rh);
	    TRACE_AND_STEP();
	    srcval = fetch_data_long(srcoffset);
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 0; *dstreg < 32; (*dstreg)++)
		if ((srcval >> *dstreg) & 1) break;
	} else {
	    u16 srcval, *dstreg;

	    srcoffset = decode_rm00_address(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_WORD_REGISTER(rh);
	    TRACE_AND_STEP();
	    srcval = fetch_data_word(srcoffset);
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 0; *dstreg < 16; (*dstreg)++)
		if ((srcval >> *dstreg) & 1) break;
	}
	break;
d2294 2
a2295 2
	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
	    u32 srcval, *dstreg;
d2297 24
a2320 21
	    srcoffset = decode_rm01_address(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_LONG_REGISTER(rh);
	    TRACE_AND_STEP();
	    srcval = fetch_data_long(srcoffset);
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 0; *dstreg < 32; (*dstreg)++)
		if ((srcval >> *dstreg) & 1) break;
	} else {
	    u16 srcval, *dstreg;

	    srcoffset = decode_rm01_address(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_WORD_REGISTER(rh);
	    TRACE_AND_STEP();
	    srcval = fetch_data_word(srcoffset);
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 0; *dstreg < 16; (*dstreg)++)
		if ((srcval >> *dstreg) & 1) break;
	}
	break;
d2322 42
a2363 2
	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
	    u32 srcval, *dstreg;
d2365 10
a2374 44
	    srcoffset = decode_rm10_address(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_LONG_REGISTER(rh);
	    TRACE_AND_STEP();
	    srcval = fetch_data_long(srcoffset);
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 0; *dstreg < 32; (*dstreg)++)
		if ((srcval >> *dstreg) & 1) break;
	} else {
	    u16 srcval, *dstreg;

	    srcoffset = decode_rm10_address(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_WORD_REGISTER(rh);
	    TRACE_AND_STEP();
	    srcval = fetch_data_word(srcoffset);
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 0; *dstreg < 16; (*dstreg)++)
		if ((srcval >> *dstreg) & 1) break;
	}
	break;
    case 3:				/* register to register */
	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
	    u32 srcval, *dstreg;

	    srcval = *DECODE_RM_LONG_REGISTER(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_LONG_REGISTER(rh);
	    TRACE_AND_STEP();
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 0; *dstreg < 32; (*dstreg)++)
		if ((srcval >> *dstreg) & 1) break;
	} else {
	    u16 srcval, *dstreg;

	    srcval = *DECODE_RM_WORD_REGISTER(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_WORD_REGISTER(rh);
	    TRACE_AND_STEP();
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 0; *dstreg < 16; (*dstreg)++)
		if ((srcval >> *dstreg) & 1) break;
	}
	break;
d2384 2
a2385 1
static void x86emuOp2_bsr(u8 X86EMU_UNUSED(op2))
d2393 1
a2393 1
    switch(mod) {
d2395 2
a2396 2
	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
	    u32 srcval, *dstreg;
d2398 24
a2421 21
	    srcoffset = decode_rm00_address(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_LONG_REGISTER(rh);
	    TRACE_AND_STEP();
	    srcval = fetch_data_long(srcoffset);
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 31; *dstreg > 0; (*dstreg)--)
		if ((srcval >> *dstreg) & 1) break;
	} else {
	    u16 srcval, *dstreg;

	    srcoffset = decode_rm00_address(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_WORD_REGISTER(rh);
	    TRACE_AND_STEP();
	    srcval = fetch_data_word(srcoffset);
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 15; *dstreg > 0; (*dstreg)--)
		if ((srcval >> *dstreg) & 1) break;
	}
	break;
d2423 15
a2437 2
	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
	    u32 srcval, *dstreg;
d2439 11
a2449 21
	    srcoffset = decode_rm01_address(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_LONG_REGISTER(rh);
	    TRACE_AND_STEP();
	    srcval = fetch_data_long(srcoffset);
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 31; *dstreg > 0; (*dstreg)--)
		if ((srcval >> *dstreg) & 1) break;
	} else {
	    u16 srcval, *dstreg;

	    srcoffset = decode_rm01_address(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_WORD_REGISTER(rh);
	    TRACE_AND_STEP();
	    srcval = fetch_data_word(srcoffset);
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 15; *dstreg > 0; (*dstreg)--)
		if ((srcval >> *dstreg) & 1) break;
	}
	break;
d2451 30
a2480 2
	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
	    u32 srcval, *dstreg;
d2482 22
a2503 44
	    srcoffset = decode_rm10_address(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_LONG_REGISTER(rh);
	    TRACE_AND_STEP();
	    srcval = fetch_data_long(srcoffset);
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 31; *dstreg > 0; (*dstreg)--)
		if ((srcval >> *dstreg) & 1) break;
	} else {
	    u16 srcval, *dstreg;

	    srcoffset = decode_rm10_address(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_WORD_REGISTER(rh);
	    TRACE_AND_STEP();
	    srcval = fetch_data_word(srcoffset);
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 15; *dstreg > 0; (*dstreg)--)
		if ((srcval >> *dstreg) & 1) break;
	}
	break;
    case 3:				/* register to register */
	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
	    u32 srcval, *dstreg;

	    srcval = *DECODE_RM_LONG_REGISTER(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_LONG_REGISTER(rh);
	    TRACE_AND_STEP();
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 31; *dstreg > 0; (*dstreg)--)
		if ((srcval >> *dstreg) & 1) break;
	} else {
	    u16 srcval, *dstreg;

	    srcval = *DECODE_RM_WORD_REGISTER(rl);
	    DECODE_PRINTF(",");
	    dstreg = DECODE_RM_WORD_REGISTER(rh);
	    TRACE_AND_STEP();
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
	    for(*dstreg = 15; *dstreg > 0; (*dstreg)--)
		if ((srcval >> *dstreg) & 1) break;
	}
	break;
d2513 2
a2514 1
static void x86emuOp2_movsx_byte_R_RM(u8 X86EMU_UNUSED(op2))
d2531 1
a2531 1
            srcval = (s32)((s8)fetch_data_byte(srcoffset));
d2535 2
a2536 1
        } else {
d2543 1
a2543 1
            srcval = (s16)((s8)fetch_data_byte(srcoffset));
d2557 1
a2557 1
            srcval = (s32)((s8)fetch_data_byte(srcoffset));
d2561 2
a2562 1
        } else {
d2569 1
a2569 1
            srcval = (s16)((s8)fetch_data_byte(srcoffset));
d2583 1
a2583 1
            srcval = (s32)((s8)fetch_data_byte(srcoffset));
d2587 2
a2588 1
        } else {
d2595 1
a2595 1
            srcval = (s16)((s8)fetch_data_byte(srcoffset));
d2601 1
a2601 1
    case 3:                     /* register to register */
d2604 1
a2604 1
            u8  *srcreg;
d2611 3
a2613 2
            *destreg = (s32)((s8)*srcreg);
        } else {
d2615 1
a2615 1
            u8  *srcreg;
d2622 1
a2622 1
            *destreg = (s16)((s8)*srcreg);
d2634 2
a2635 1
static void x86emuOp2_movsx_word_R_RM(u8 X86EMU_UNUSED(op2))
d2651 1
a2651 1
        srcval = (s32)((s16)fetch_data_word(srcoffset));
d2660 1
a2660 1
        srcval = (s32)((s16)fetch_data_word(srcoffset));
d2669 1
a2669 1
        srcval = (s32)((s16)fetch_data_word(srcoffset));
d2674 1
a2674 1
    case 3:                     /* register to register */
d2680 1
a2680 1
        *destreg = (s32)((s16)*srcreg);
d2688 2
a2689 1
static void x86emuOp2_bswap(u8 X86EMU_UNUSED(op2))
d2696 27
a2722 27
	case 0xc8:
	    M.x86.R_EAX = bswap_32(M.x86.R_EAX);
	    break;
	case 0xc9:
	    M.x86.R_ECX = bswap_32(M.x86.R_ECX);
	    break;
	case 0xca:
	    M.x86.R_EDX = bswap_32(M.x86.R_EDX);
	    break;
	case 0xcb:
	    M.x86.R_EBX = bswap_32(M.x86.R_EBX);
	    break;
	case 0xcc:
	    M.x86.R_ESP = bswap_32(M.x86.R_ESP);
	    break;
	case 0xcd:
	    M.x86.R_EBP = bswap_32(M.x86.R_EBP);
	    break;
	case 0xce:
	    M.x86.R_ESI = bswap_32(M.x86.R_ESI);
	    break;
	case 0xcf:
	    M.x86.R_EDI = bswap_32(M.x86.R_EDI);
	    break;
	default:
	    /* can't happen */
	    break;
d2732 9
a2740 6
void (*x86emu_optab2[256])(u8) =
{
/*  0x00 */ x86emuOp2_illegal_op,  /* Group F (ring 0 PM)      */
/*  0x01 */ x86emuOp2_illegal_op,  /* Group G (ring 0 PM)      */
/*  0x02 */ x86emuOp2_illegal_op,  /* lar (ring 0 PM)          */
/*  0x03 */ x86emuOp2_illegal_op,  /* lsl (ring 0 PM)          */
d2742 10
a2751 5
/*  0x05 */ x86emuOp2_illegal_op,  /* loadall (undocumented)   */
/*  0x06 */ x86emuOp2_illegal_op,  /* clts (ring 0 PM)         */
/*  0x07 */ x86emuOp2_illegal_op,  /* loadall (undocumented)   */
/*  0x08 */ x86emuOp2_illegal_op,  /* invd (ring 0 PM)         */
/*  0x09 */ x86emuOp2_illegal_op,  /* wbinvd (ring 0 PM)       */
a2757 1

d2774 10
a2783 6

/*  0x20 */ x86emuOp2_illegal_op,  /* mov reg32,creg (ring 0 PM) */
/*  0x21 */ x86emuOp2_illegal_op,  /* mov reg32,dreg (ring 0 PM) */
/*  0x22 */ x86emuOp2_illegal_op,  /* mov creg,reg32 (ring 0 PM) */
/*  0x23 */ x86emuOp2_illegal_op,  /* mov dreg,reg32 (ring 0 PM) */
/*  0x24 */ x86emuOp2_illegal_op,  /* mov reg32,treg (ring 0 PM) */
d2785 2
a2786 1
/*  0x26 */ x86emuOp2_illegal_op,  /* mov treg,reg32 (ring 0 PM) */
a2795 1

a2811 1

a2827 1

a2843 1

a2859 1

a2875 1

a2891 1

a2907 1

d2924 4
a2927 3

/*  0xb0 */ x86emuOp2_illegal_op,  /* TODO: cmpxchg */
/*  0xb1 */ x86emuOp2_illegal_op,  /* TODO: cmpxchg */
d2942 4
a2945 3

/*  0xc0 */ x86emuOp2_illegal_op,  /* TODO: xadd */
/*  0xc1 */ x86emuOp2_illegal_op,  /* TODO: xadd */
a2959 1

a2975 1

a2991 1

@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d113 1
a113 1
    char *name = 0;
d207 1
a207 1
    char *name = 0;
@


1.2
log
@Pull in a patch from X.Org-current to let X11 run on AMD Geode LX
CPUs in basic VESA mode:

X86EMU: handle CPUID instruction

Starting X on an AMD Geode LX system such as an Alix board with VGA
connector, the Xorg driver attempts to issue INT 10/0 to go to mode
3 (VGA).  The emulator, running the BIOS code, would then spit out:

	c000:0282: A2 ILLEGAL EXTENDED X86 OPCODE!

The opcode was 0F A2, or CPUID; it was not implemented in the
emulator. With this patch it handles the CPUID instruction in one of
two ways:

1) if ran on __i386__ or __x86_64__ then it calls the CPUID instruction
   directly.

2) if ran elsewhere it returns a canned 486dx4 set of values for function 1.

Tested with & ok matthieu
@
text
@d43 6
d2580 41
d2838 8
a2845 8
/*  0xc8 */ x86emuOp2_illegal_op,  /* TODO: bswap */
/*  0xc9 */ x86emuOp2_illegal_op,  /* TODO: bswap */
/*  0xca */ x86emuOp2_illegal_op,  /* TODO: bswap */
/*  0xcb */ x86emuOp2_illegal_op,  /* TODO: bswap */
/*  0xcc */ x86emuOp2_illegal_op,  /* TODO: bswap */
/*  0xcd */ x86emuOp2_illegal_op,  /* TODO: bswap */
/*  0xce */ x86emuOp2_illegal_op,  /* TODO: bswap */
/*  0xcf */ x86emuOp2_illegal_op,  /* TODO: bswap */
@


1.1
log
@Initial revision
@
text
@d68 34
d331 14
d2180 1
a2180 1
    DECODE_PRINTF("BSF\n");
d2260 1
a2260 1
	    u32 *srcreg, *dstreg;
d2262 1
a2262 1
	    srcreg = DECODE_RM_LONG_REGISTER(rl);
d2266 1
a2266 1
	    CONDITIONAL_SET_FLAG(*srcreg == 0, F_ZF);
d2268 1
a2268 1
		if ((*srcreg >> *dstreg) & 1) break;
d2270 1
a2270 1
	    u16 *srcreg, *dstreg;
d2272 1
a2272 1
	    srcreg = DECODE_RM_WORD_REGISTER(rl);
d2276 1
a2276 1
	    CONDITIONAL_SET_FLAG(*srcreg == 0, F_ZF);
d2278 1
a2278 1
		if ((*srcreg >> *dstreg) & 1) break;
d2296 1
a2296 1
    DECODE_PRINTF("BSF\n");
d2376 1
a2376 1
	    u32 *srcreg, *dstreg;
d2378 1
a2378 1
	    srcreg = DECODE_RM_LONG_REGISTER(rl);
d2382 1
a2382 1
	    CONDITIONAL_SET_FLAG(*srcreg == 0, F_ZF);
d2384 1
a2384 1
		if ((*srcreg >> *dstreg) & 1) break;
d2386 1
a2386 1
	    u16 *srcreg, *dstreg;
d2388 1
a2388 1
	    srcreg = DECODE_RM_WORD_REGISTER(rl);
d2392 1
a2392 1
	    CONDITIONAL_SET_FLAG(*srcreg == 0, F_ZF);
d2394 1
a2394 1
		if ((*srcreg >> *dstreg) & 1) break;
d2631 1
a2631 1
/*  0x31 */ x86emuOp2_illegal_op,
d2751 1
a2751 1
/*  0xa2 */ x86emuOp2_illegal_op,
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@Import xserver version 1.2.0 (X.Org 7.2 final).
@
text
@d2132 1
a2132 1
    DECODE_PRINTF("BSF\t");
d2212 1
a2212 1
	    u32 srcval, *dstreg;
d2214 1
a2214 1
	    srcval = *DECODE_RM_LONG_REGISTER(rl);
d2218 1
a2218 1
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
d2220 1
a2220 1
		if ((srcval >> *dstreg) & 1) break;
d2222 1
a2222 1
	    u16 srcval, *dstreg;
d2224 1
a2224 1
	    srcval = *DECODE_RM_WORD_REGISTER(rl);
d2228 1
a2228 1
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
d2230 1
a2230 1
		if ((srcval >> *dstreg) & 1) break;
d2248 1
a2248 1
    DECODE_PRINTF("BSR\t");
d2328 1
a2328 1
	    u32 srcval, *dstreg;
d2330 1
a2330 1
	    srcval = *DECODE_RM_LONG_REGISTER(rl);
d2334 1
a2334 1
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
d2336 1
a2336 1
		if ((srcval >> *dstreg) & 1) break;
d2338 1
a2338 1
	    u16 srcval, *dstreg;
d2340 1
a2340 1
	    srcval = *DECODE_RM_WORD_REGISTER(rl);
d2344 1
a2344 1
	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
d2346 1
a2346 1
		if ((srcval >> *dstreg) & 1) break;
@


1.1.1.3
log
@xserver 1.4
@
text
@a67 34
Handles opcode 0x0f,0x31
****************************************************************************/
static void x86emuOp2_rdtsc(u8 X86EMU_UNUSED(op2))
{
#ifdef __HAS_LONG_LONG__
    static u64 counter = 0;
#else
    static u32 counter = 0;
#endif

    counter += 0x10000;

    /* read timestamp counter */
    /*
     * Note that instead of actually trying to accurately measure this, we just
     * increase the counter by a fixed amount every time we hit one of these
     * instructions.  Feel free to come up with a better method.
     */
    START_OF_INSTR();
    DECODE_PRINTF("RDTSC\n");
    TRACE_AND_STEP();
#ifdef __HAS_LONG_LONG__
    M.x86.R_EAX = counter & 0xffffffff;
    M.x86.R_EDX = counter >> 32;
#else
    M.x86.R_EAX = counter;
    M.x86.R_EDX = 0;
#endif
    DECODE_CLEAR_SEGOVR();
    END_OF_INSTR();
}

/****************************************************************************
REMARKS:
d2583 1
a2583 1
/*  0x31 */ x86emuOp2_rdtsc,
@


