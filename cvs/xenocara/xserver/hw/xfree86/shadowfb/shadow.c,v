head	1.12;
access;
symbols
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.6
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	cVXoV5PxI8YrEaVA;

1.11
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.06.10.13.21.27;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.06.19.44.27;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.20.23.13.15;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.05.07.04.32;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.25;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.18.09;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.18.09;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
   Copyright (C) 1999.  The XFree86 Project Inc.
   Copyright 2014 Red Hat, Inc.

   Written by Mark Vojkovich (mvojkovi@@ucsd.edu)
   Pre-fb-write callbacks and RENDER support - Nolan Leake (nolan@@vmware.com)
*/

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "pixmapstr.h"
#include "input.h"
#include <X11/fonts/font.h>
#include "mi.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "gcstruct.h"
#include "dixfontstr.h"
#include <X11/fonts/fontstruct.h>
#include "xf86.h"
#include "xf86str.h"
#include "shadowfb.h"

#include "picturestr.h"

static Bool ShadowCloseScreen(ScreenPtr pScreen);
static Bool ShadowCreateRootWindow(WindowPtr pWin);

typedef struct {
    ScrnInfoPtr pScrn;
    RefreshAreaFuncPtr preRefresh;
    RefreshAreaFuncPtr postRefresh;
    CloseScreenProcPtr CloseScreen;
    CreateWindowProcPtr CreateWindow;
} ShadowScreenRec, *ShadowScreenPtr;

static DevPrivateKeyRec ShadowScreenKeyRec;

static ShadowScreenPtr
shadowfbGetScreenPrivate(ScreenPtr pScreen)
{
    return dixLookupPrivate(&(pScreen)->devPrivates, &ShadowScreenKeyRec);
}

Bool
ShadowFBInit2(ScreenPtr pScreen,
              RefreshAreaFuncPtr preRefreshArea,
              RefreshAreaFuncPtr postRefreshArea)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    ShadowScreenPtr pPriv;

    if (!preRefreshArea && !postRefreshArea)
        return FALSE;

    if (!dixRegisterPrivateKey(&ShadowScreenKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    if (!(pPriv = (ShadowScreenPtr) malloc(sizeof(ShadowScreenRec))))
        return FALSE;

    dixSetPrivate(&pScreen->devPrivates, &ShadowScreenKeyRec, pPriv);

    pPriv->pScrn = pScrn;
    pPriv->preRefresh = preRefreshArea;
    pPriv->postRefresh = postRefreshArea;

    pPriv->CloseScreen = pScreen->CloseScreen;
    pPriv->CreateWindow = pScreen->CreateWindow;

    pScreen->CloseScreen = ShadowCloseScreen;
    pScreen->CreateWindow = ShadowCreateRootWindow;

    return TRUE;
}

Bool
ShadowFBInit(ScreenPtr pScreen, RefreshAreaFuncPtr refreshArea)
{
    return ShadowFBInit2(pScreen, NULL, refreshArea);
}

/*
 * Note that we don't do DamageEmpty, or indeed look at the region inside the
 * DamagePtr at all.  This is an optimization, believe it or not.  The
 * incoming RegionPtr is the new damage, and if we were to empty the region
 * miext/damage would just have to waste time reallocating and re-unioning
 * it every time, whereas if we leave it around the union gets fast-pathed
 * away.
 */

static void
shadowfbReportPre(DamagePtr damage, RegionPtr reg, void *closure)
{
    ShadowScreenPtr pPriv = closure;

    if (!pPriv->pScrn->vtSema)
        return;

    pPriv->preRefresh(pPriv->pScrn, RegionNumRects(reg), RegionRects(reg));
}

static void
shadowfbReportPost(DamagePtr damage, RegionPtr reg, void *closure)
{
    ShadowScreenPtr pPriv = closure;

    if (!pPriv->pScrn->vtSema)
        return;

    pPriv->postRefresh(pPriv->pScrn, RegionNumRects(reg), RegionRects(reg));
}

static Bool
ShadowCreateRootWindow(WindowPtr pWin)
{
    Bool ret;
    ScreenPtr pScreen = pWin->drawable.pScreen;
    ShadowScreenPtr pPriv = shadowfbGetScreenPrivate(pScreen);

    /* paranoia */
    if (pWin != pScreen->root)
        ErrorF("ShadowCreateRootWindow called unexpectedly\n");

    /* call down, but don't hook ourselves back in; we know the first time
     * we're called it's for the root window.
     */
    pScreen->CreateWindow = pPriv->CreateWindow;
    ret = pScreen->CreateWindow(pWin);

    /* this might look like it leaks, but the damage code reaps listeners
     * when their drawable disappears.
     */
    if (ret) {
        DamagePtr damage;

        if (pPriv->preRefresh) {
            damage = DamageCreate(shadowfbReportPre, NULL,
                                  DamageReportRawRegion,
                                  TRUE, pScreen, pPriv);
            DamageRegister(&pWin->drawable, damage);
        }

        if (pPriv->postRefresh) {
            damage = DamageCreate(shadowfbReportPost, NULL,
                                  DamageReportRawRegion,
                                  TRUE, pScreen, pPriv);
            DamageSetReportAfterOp(damage, TRUE);
            DamageRegister(&pWin->drawable, damage);
        }
    }

    return ret;
}

static Bool
ShadowCloseScreen(ScreenPtr pScreen)
{
    ShadowScreenPtr pPriv = shadowfbGetScreenPrivate(pScreen);

    pScreen->CloseScreen = pPriv->CloseScreen;

    free(pPriv);

    return (*pScreen->CloseScreen) (pScreen);
}
@


1.11
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d3 1
a5 1

d32 1
a32 17
static void ShadowCopyWindow(WindowPtr pWin,
                             DDXPointRec ptOldOrg, RegionPtr prgn);
static Bool ShadowCreateGC(GCPtr pGC);

static Bool ShadowEnterVT(ScrnInfoPtr pScrn);
static void ShadowLeaveVT(ScrnInfoPtr pScrn);

static void ShadowComposite(CARD8 op,
                            PicturePtr pSrc,
                            PicturePtr pMask,
                            PicturePtr pDst,
                            INT16 xSrc,
                            INT16 ySrc,
                            INT16 xMask,
                            INT16 yMask,
                            INT16 xDst,
                            INT16 yDst, CARD16 width, CARD16 height);
d39 1
a39 7
    CopyWindowProcPtr CopyWindow;
    CreateGCProcPtr CreateGC;
    ModifyPixmapHeaderProcPtr ModifyPixmapHeader;
    CompositeProcPtr Composite;
    Bool (*EnterVT) (ScrnInfoPtr);
    void (*LeaveVT) (ScrnInfoPtr);
    Bool vtSema;
a41 5
typedef struct {
    GCOps *ops;
    GCFuncs *funcs;
} ShadowGCRec, *ShadowGCPtr;

d44 5
a48 62
#define ShadowScreenKey (&ShadowScreenKeyRec)

static DevPrivateKeyRec ShadowGCKeyRec;

#define ShadowGCKey (&ShadowGCKeyRec)

#define GET_SCREEN_PRIVATE(pScreen) \
    (ShadowScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, ShadowScreenKey)
#define GET_GC_PRIVATE(pGC) \
    (ShadowGCPtr)dixLookupPrivate(&(pGC)->devPrivates, ShadowGCKey)

#define SHADOW_GC_FUNC_PROLOGUE(pGC)\
    ShadowGCPtr pGCPriv = GET_GC_PRIVATE(pGC);\
    (pGC)->funcs = pGCPriv->funcs;\
    if(pGCPriv->ops)\
        (pGC)->ops = pGCPriv->ops

#define SHADOW_GC_FUNC_EPILOGUE(pGC)\
    pGCPriv->funcs = (pGC)->funcs;\
    (pGC)->funcs = &ShadowGCFuncs;\
    if(pGCPriv->ops) {\
        pGCPriv->ops = (pGC)->ops;\
        (pGC)->ops = &ShadowGCOps;\
    }

#define SHADOW_GC_OP_PROLOGUE(pGC)\
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pGC->pScreen); \
    ShadowGCPtr pGCPriv = GET_GC_PRIVATE(pGC);\
    GCFuncs *oldFuncs = pGC->funcs;\
    pGC->funcs = pGCPriv->funcs;\
    pGC->ops = pGCPriv->ops

#define SHADOW_GC_OP_EPILOGUE(pGC)\
    pGCPriv->ops = pGC->ops;\
    pGC->funcs = oldFuncs;\
    pGC->ops   = &ShadowGCOps

#define IS_VISIBLE(pWin) (pPriv->vtSema && \
    (((WindowPtr)pWin)->visibility != VisibilityFullyObscured))

#define TRIM_BOX(box, pGC) { \
    BoxPtr extents = &pGC->pCompositeClip->extents;\
    if(box.x1 < extents->x1) box.x1 = extents->x1; \
    if(box.x2 > extents->x2) box.x2 = extents->x2; \
    if(box.y1 < extents->y1) box.y1 = extents->y1; \
    if(box.y2 > extents->y2) box.y2 = extents->y2; \
    }

#define TRANSLATE_BOX(box, pDraw) { \
    box.x1 += pDraw->x; \
    box.x2 += pDraw->x; \
    box.y1 += pDraw->y; \
    box.y2 += pDraw->y; \
    }

#define TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC) { \
    TRANSLATE_BOX(box, pDraw); \
    TRIM_BOX(box, pGC); \
    }

#define BOX_NOT_EMPTY(box) \
    (((box.x2 - box.x1) > 0) && ((box.y2 - box.y1) > 0))
a56 1
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);
a63 4
    if (!dixRegisterPrivateKey
        (&ShadowGCKeyRec, PRIVATE_GC, sizeof(ShadowGCRec)))
        return FALSE;

d67 1
a67 1
    dixSetPrivate(&pScreen->devPrivates, ShadowScreenKey, pPriv);
a71 1
    pPriv->vtSema = TRUE;
d74 1
a74 6
    pPriv->CopyWindow = pScreen->CopyWindow;
    pPriv->CreateGC = pScreen->CreateGC;
    pPriv->ModifyPixmapHeader = pScreen->ModifyPixmapHeader;

    pPriv->EnterVT = pScrn->EnterVT;
    pPriv->LeaveVT = pScrn->LeaveVT;
d77 1
a77 10
    pScreen->CopyWindow = ShadowCopyWindow;
    pScreen->CreateGC = ShadowCreateGC;

    pScrn->EnterVT = ShadowEnterVT;
    pScrn->LeaveVT = ShadowLeaveVT;

    if (ps) {
        pPriv->Composite = ps->Composite;
        ps->Composite = ShadowComposite;
    }
d88 8
a95 19
/**********************************************************/

static Bool
ShadowEnterVT(ScrnInfoPtr pScrn)
{
    Bool ret;
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScrn->pScreen);

    pScrn->EnterVT = pPriv->EnterVT;
    ret = (*pPriv->EnterVT) (pScrn);
    pPriv->EnterVT = pScrn->EnterVT;
    pScrn->EnterVT = ShadowEnterVT;
    if (ret) {
        pPriv->vtSema = TRUE;
        return TRUE;
    }

    return FALSE;
}
d98 1
a98 1
ShadowLeaveVT(ScrnInfoPtr pScrn)
d100 1
a100 35
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScrn->pScreen);

    pPriv->vtSema = FALSE;

    pScrn->LeaveVT = pPriv->LeaveVT;
    (*pPriv->LeaveVT) (pScrn);
    pPriv->LeaveVT = pScrn->LeaveVT;
    pScrn->LeaveVT = ShadowLeaveVT;
}

/**********************************************************/

static Bool
ShadowCloseScreen(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScreen);
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);

    pScreen->CloseScreen = pPriv->CloseScreen;
    pScreen->CopyWindow = pPriv->CopyWindow;
    pScreen->CreateGC = pPriv->CreateGC;
    pScreen->ModifyPixmapHeader = pPriv->ModifyPixmapHeader;

    pScrn->EnterVT = pPriv->EnterVT;
    pScrn->LeaveVT = pPriv->LeaveVT;

    if (ps) {
        ps->Composite = pPriv->Composite;
    }

    free((pointer) pPriv);

    return (*pScreen->CloseScreen) (pScreen);
}
d102 2
a103 24
static void
ShadowCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgn)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScreen);
    int num = 0;
    RegionRec rgnDst;

    if (pPriv->vtSema) {
        RegionNull(&rgnDst);
        RegionCopy(&rgnDst, prgn);

        RegionTranslate(&rgnDst,
                        pWin->drawable.x - ptOldOrg.x,
                        pWin->drawable.y - ptOldOrg.y);
        RegionIntersect(&rgnDst, &pWin->borderClip, &rgnDst);
        if ((num = RegionNumRects(&rgnDst))) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, num, RegionRects(&rgnDst));
        }
        else {
            RegionUninit(&rgnDst);
        }
    }
d105 1
a105 9
    pScreen->CopyWindow = pPriv->CopyWindow;
    (*pScreen->CopyWindow) (pWin, ptOldOrg, prgn);
    pScreen->CopyWindow = ShadowCopyWindow;

    if (num) {
        if (pPriv->postRefresh)
            (*pPriv->postRefresh) (pPriv->pScrn, num, RegionRects(&rgnDst));
        RegionUninit(&rgnDst);
    }
d109 1
a109 9
ShadowComposite(CARD8 op,
                PicturePtr pSrc,
                PicturePtr pMask,
                PicturePtr pDst,
                INT16 xSrc,
                INT16 ySrc,
                INT16 xMask,
                INT16 yMask,
                INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
d111 1
a111 30
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScreen);
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    BoxRec box;
    BoxPtr extents;
    Bool boxNotEmpty = FALSE;

    if (pPriv->vtSema && pDst->pDrawable->type == DRAWABLE_WINDOW) {

        box.x1 = pDst->pDrawable->x + xDst;
        box.y1 = pDst->pDrawable->y + yDst;
        box.x2 = box.x1 + width;
        box.y2 = box.y1 + height;

        extents = &pDst->pCompositeClip->extents;
        if (box.x1 < extents->x1)
            box.x1 = extents->x1;
        if (box.x2 > extents->x2)
            box.x2 = extents->x2;
        if (box.y1 < extents->y1)
            box.y1 = extents->y1;
        if (box.y2 > extents->y2)
            box.y2 = extents->y2;

        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
    }
d113 2
a114 4
    ps->Composite = pPriv->Composite;
    (*ps->Composite) (op, pSrc, pMask, pDst, xSrc, ySrc,
                      xMask, yMask, xDst, yDst, width, height);
    ps->Composite = ShadowComposite;
d116 1
a116 3
    if (pPriv->postRefresh && boxNotEmpty) {
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);
    }
a118 17
/**********************************************************/

static void ShadowValidateGC(GCPtr, unsigned long, DrawablePtr);
static void ShadowChangeGC(GCPtr, unsigned long);
static void ShadowCopyGC(GCPtr, unsigned long, GCPtr);
static void ShadowDestroyGC(GCPtr);
static void ShadowChangeClip(GCPtr, int, pointer, int);
static void ShadowDestroyClip(GCPtr);
static void ShadowCopyClip(GCPtr, GCPtr);

GCFuncs ShadowGCFuncs = {
    ShadowValidateGC, ShadowChangeGC, ShadowCopyGC, ShadowDestroyGC,
    ShadowChangeClip, ShadowDestroyClip, ShadowCopyClip
};

extern GCOps ShadowGCOps;

d120 1
a120 1
ShadowCreateGC(GCPtr pGC)
a121 3
    ScreenPtr pScreen = pGC->pScreen;
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScreen);
    ShadowGCPtr pGCPriv = GET_GC_PRIVATE(pGC);
d123 2
d126 15
a140 163
    pScreen->CreateGC = pPriv->CreateGC;
    if ((ret = (*pScreen->CreateGC) (pGC))) {
        pGCPriv->ops = NULL;
        pGCPriv->funcs = pGC->funcs;
        pGC->funcs = &ShadowGCFuncs;
    }
    pScreen->CreateGC = ShadowCreateGC;

    return ret;
}

static void
ShadowValidateGC(GCPtr pGC, unsigned long changes, DrawablePtr pDraw)
{
    SHADOW_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->ValidateGC) (pGC, changes, pDraw);
    if (pDraw->type == DRAWABLE_WINDOW)
        pGCPriv->ops = pGC->ops;        /* just so it's not NULL */
    else
        pGCPriv->ops = NULL;
    SHADOW_GC_FUNC_EPILOGUE(pGC);
}

static void
ShadowDestroyGC(GCPtr pGC)
{
    SHADOW_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->DestroyGC) (pGC);
    SHADOW_GC_FUNC_EPILOGUE(pGC);
}

static void
ShadowChangeGC(GCPtr pGC, unsigned long mask)
{
    SHADOW_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->ChangeGC) (pGC, mask);
    SHADOW_GC_FUNC_EPILOGUE(pGC);
}

static void
ShadowCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst)
{
    SHADOW_GC_FUNC_PROLOGUE(pGCDst);
    (*pGCDst->funcs->CopyGC) (pGCSrc, mask, pGCDst);
    SHADOW_GC_FUNC_EPILOGUE(pGCDst);
}

static void
ShadowChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects)
{
    SHADOW_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->ChangeClip) (pGC, type, pvalue, nrects);
    SHADOW_GC_FUNC_EPILOGUE(pGC);
}

static void
ShadowCopyClip(GCPtr pgcDst, GCPtr pgcSrc)
{
    SHADOW_GC_FUNC_PROLOGUE(pgcDst);
    (*pgcDst->funcs->CopyClip) (pgcDst, pgcSrc);
    SHADOW_GC_FUNC_EPILOGUE(pgcDst);
}

static void
ShadowDestroyClip(GCPtr pGC)
{
    SHADOW_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->DestroyClip) (pGC);
    SHADOW_GC_FUNC_EPILOGUE(pGC);
}

/**********************************************************/

static void
ShadowFillSpans(DrawablePtr pDraw,
                GC * pGC,
                int nInit, DDXPointPtr pptInit, int *pwidthInit, int fSorted)
{
    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw) && nInit) {
        DDXPointPtr ppt = pptInit;
        int *pwidth = pwidthInit;
        int i = nInit;
        BoxRec box;
        Bool boxNotEmpty = FALSE;

        box.x1 = ppt->x;
        box.x2 = box.x1 + *pwidth;
        box.y2 = box.y1 = ppt->y;

        while (--i) {
            ppt++;
            pwidth++;
            if (box.x1 > ppt->x)
                box.x1 = ppt->x;
            if (box.x2 < (ppt->x + *pwidth))
                box.x2 = ppt->x + *pwidth;
            if (box.y1 > ppt->y)
                box.y1 = ppt->y;
            else if (box.y2 < ppt->y)
                box.y2 = ppt->y;
        }

        box.y2++;

        if (!pGC->miTranslate) {
            TRANSLATE_BOX(box, pDraw);
        }
        TRIM_BOX(box, pGC);

        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }

        (*pGC->ops->FillSpans) (pDraw, pGC, nInit, pptInit, pwidthInit,
                                fSorted);

        if (boxNotEmpty && pPriv->postRefresh)
            (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);
    }
    else
        (*pGC->ops->FillSpans) (pDraw, pGC, nInit, pptInit, pwidthInit,
                                fSorted);

    SHADOW_GC_OP_EPILOGUE(pGC);
}

static void
ShadowSetSpans(DrawablePtr pDraw,
               GCPtr pGC,
               char *pcharsrc,
               DDXPointPtr pptInit, int *pwidthInit, int nspans, int fSorted)
{
    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw) && nspans) {
        DDXPointPtr ppt = pptInit;
        int *pwidth = pwidthInit;
        int i = nspans;
        BoxRec box;
        Bool boxNotEmpty = FALSE;

        box.x1 = ppt->x;
        box.x2 = box.x1 + *pwidth;
        box.y2 = box.y1 = ppt->y;

        while (--i) {
            ppt++;
            pwidth++;
            if (box.x1 > ppt->x)
                box.x1 = ppt->x;
            if (box.x2 < (ppt->x + *pwidth))
                box.x2 = ppt->x + *pwidth;
            if (box.y1 > ppt->y)
                box.y1 = ppt->y;
            else if (box.y2 < ppt->y)
                box.y2 = ppt->y;
        }

        box.y2++;
d142 5
a146 2
        if (!pGC->miTranslate) {
            TRANSLATE_BOX(box, pDraw);
a147 82
        TRIM_BOX(box, pGC);

        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }

        (*pGC->ops->SetSpans) (pDraw, pGC, pcharsrc, pptInit,
                               pwidthInit, nspans, fSorted);

        if (boxNotEmpty && pPriv->postRefresh)
            (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);
    }
    else
        (*pGC->ops->SetSpans) (pDraw, pGC, pcharsrc, pptInit,
                               pwidthInit, nspans, fSorted);

    SHADOW_GC_OP_EPILOGUE(pGC);
}

static void
ShadowPutImage(DrawablePtr pDraw,
               GCPtr pGC,
               int depth,
               int x, int y, int w, int h,
               int leftPad, int format, char *pImage)
{
    BoxRec box;
    Bool boxNotEmpty = FALSE;

    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw)) {
        box.x1 = x + pDraw->x;
        box.x2 = box.x1 + w;
        box.y1 = y + pDraw->y;
        box.y2 = box.y1 + h;

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
    }

    (*pGC->ops->PutImage) (pDraw, pGC, depth, x, y, w, h,
                           leftPad, format, pImage);

    if (boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);

}

static RegionPtr
ShadowCopyArea(DrawablePtr pSrc,
               DrawablePtr pDst,
               GC * pGC,
               int srcx, int srcy, int width, int height, int dstx, int dsty)
{
    RegionPtr ret;
    BoxRec box;
    Bool boxNotEmpty = FALSE;

    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDst)) {
        box.x1 = dstx + pDst->x;
        box.x2 = box.x1 + width;
        box.y1 = dsty + pDst->y;
        box.y2 = box.y1 + height;

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
    }
d149 6
a154 36
    ret = (*pGC->ops->CopyArea) (pSrc, pDst,
                                 pGC, srcx, srcy, width, height, dstx, dsty);

    if (boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);

    return ret;
}

static RegionPtr
ShadowCopyPlane(DrawablePtr pSrc,
                DrawablePtr pDst,
                GCPtr pGC,
                int srcx, int srcy,
                int width, int height,
                int dstx, int dsty, unsigned long bitPlane)
{
    RegionPtr ret;
    BoxRec box;
    Bool boxNotEmpty = FALSE;

    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDst)) {
        box.x1 = dstx + pDst->x;
        box.x2 = box.x1 + width;
        box.y1 = dsty + pDst->y;
        box.y2 = box.y1 + height;

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
a157 9
    ret = (*pGC->ops->CopyPlane) (pSrc, pDst,
                                  pGC, srcx, srcy, width, height, dstx, dsty,
                                  bitPlane);

    if (boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);

d161 2
a162 3
static void
ShadowPolyPoint(DrawablePtr pDraw,
                GCPtr pGC, int mode, int nptInit, xPoint * pptInit)
d164 1
a164 2
    BoxRec box;
    Bool boxNotEmpty = FALSE;
d166 1
a166 22
    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw) && nptInit) {
        xPoint *ppt = pptInit;
        int npt = nptInit;

        box.x2 = box.x1 = pptInit->x;
        box.y2 = box.y1 = pptInit->y;

        /* this could be slow if the points were spread out */

        while (--npt) {
            ppt++;
            if (box.x1 > ppt->x)
                box.x1 = ppt->x;
            else if (box.x2 < ppt->x)
                box.x2 = ppt->x;
            if (box.y1 > ppt->y)
                box.y1 = ppt->y;
            else if (box.y2 < ppt->y)
                box.y2 = ppt->y;
        }
d168 1
a168 2
        box.x2++;
        box.y2++;
d170 1
a170 14
        TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
    }

    (*pGC->ops->PolyPoint) (pDraw, pGC, mode, nptInit, pptInit);

    if (boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
a171 927

static void
ShadowPolylines(DrawablePtr pDraw,
                GCPtr pGC, int mode, int nptInit, DDXPointPtr pptInit)
{
    BoxRec box;
    Bool boxNotEmpty = FALSE;

    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw) && nptInit) {
        DDXPointPtr ppt = pptInit;
        int npt = nptInit;
        int extra = pGC->lineWidth >> 1;

        box.x2 = box.x1 = pptInit->x;
        box.y2 = box.y1 = pptInit->y;

        if (npt > 1) {
            if (pGC->joinStyle == JoinMiter)
                extra = 6 * pGC->lineWidth;
            else if (pGC->capStyle == CapProjecting)
                extra = pGC->lineWidth;
        }

        if (mode == CoordModePrevious) {
            int x = box.x1;
            int y = box.y1;

            while (--npt) {
                ppt++;
                x += ppt->x;
                y += ppt->y;
                if (box.x1 > x)
                    box.x1 = x;
                else if (box.x2 < x)
                    box.x2 = x;
                if (box.y1 > y)
                    box.y1 = y;
                else if (box.y2 < y)
                    box.y2 = y;
            }
        }
        else {
            while (--npt) {
                ppt++;
                if (box.x1 > ppt->x)
                    box.x1 = ppt->x;
                else if (box.x2 < ppt->x)
                    box.x2 = ppt->x;
                if (box.y1 > ppt->y)
                    box.y1 = ppt->y;
                else if (box.y2 < ppt->y)
                    box.y2 = ppt->y;
            }
        }

        box.x2++;
        box.y2++;

        if (extra) {
            box.x1 -= extra;
            box.x2 += extra;
            box.y1 -= extra;
            box.y2 += extra;
        }

        TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
    }

    (*pGC->ops->Polylines) (pDraw, pGC, mode, nptInit, pptInit);

    if (boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
}

static void
ShadowPolySegment(DrawablePtr pDraw,
                  GCPtr pGC, int nsegInit, xSegment * pSegInit)
{
    BoxRec box;
    Bool boxNotEmpty = FALSE;

    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw) && nsegInit) {
        int extra = pGC->lineWidth;
        xSegment *pSeg = pSegInit;
        int nseg = nsegInit;

        if (pGC->capStyle != CapProjecting)
            extra >>= 1;

        if (pSeg->x2 > pSeg->x1) {
            box.x1 = pSeg->x1;
            box.x2 = pSeg->x2;
        }
        else {
            box.x2 = pSeg->x1;
            box.x1 = pSeg->x2;
        }

        if (pSeg->y2 > pSeg->y1) {
            box.y1 = pSeg->y1;
            box.y2 = pSeg->y2;
        }
        else {
            box.y2 = pSeg->y1;
            box.y1 = pSeg->y2;
        }

        while (--nseg) {
            pSeg++;
            if (pSeg->x2 > pSeg->x1) {
                if (pSeg->x1 < box.x1)
                    box.x1 = pSeg->x1;
                if (pSeg->x2 > box.x2)
                    box.x2 = pSeg->x2;
            }
            else {
                if (pSeg->x2 < box.x1)
                    box.x1 = pSeg->x2;
                if (pSeg->x1 > box.x2)
                    box.x2 = pSeg->x1;
            }
            if (pSeg->y2 > pSeg->y1) {
                if (pSeg->y1 < box.y1)
                    box.y1 = pSeg->y1;
                if (pSeg->y2 > box.y2)
                    box.y2 = pSeg->y2;
            }
            else {
                if (pSeg->y2 < box.y1)
                    box.y1 = pSeg->y2;
                if (pSeg->y1 > box.y2)
                    box.y2 = pSeg->y1;
            }
        }

        box.x2++;
        box.y2++;

        if (extra) {
            box.x1 -= extra;
            box.x2 += extra;
            box.y1 -= extra;
            box.y2 += extra;
        }

        TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
    }

    (*pGC->ops->PolySegment) (pDraw, pGC, nsegInit, pSegInit);

    if (boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
}

static void
ShadowPolyRectangle(DrawablePtr pDraw,
                    GCPtr pGC, int nRectsInit, xRectangle *pRectsInit)
{
    BoxRec box;
    BoxPtr pBoxInit = NULL;
    Bool boxNotEmpty = FALSE;
    int num = 0;

    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw) && nRectsInit) {
        xRectangle *pRects = pRectsInit;
        int nRects = nRectsInit;

        if (nRects >= 32) {
            int extra = pGC->lineWidth >> 1;

            box.x1 = pRects->x;
            box.x2 = box.x1 + pRects->width;
            box.y1 = pRects->y;
            box.y2 = box.y1 + pRects->height;

            while (--nRects) {
                pRects++;
                if (box.x1 > pRects->x)
                    box.x1 = pRects->x;
                if (box.x2 < (pRects->x + pRects->width))
                    box.x2 = pRects->x + pRects->width;
                if (box.y1 > pRects->y)
                    box.y1 = pRects->y;
                if (box.y2 < (pRects->y + pRects->height))
                    box.y2 = pRects->y + pRects->height;
            }

            if (extra) {
                box.x1 -= extra;
                box.x2 += extra;
                box.y1 -= extra;
                box.y2 += extra;
            }

            box.x2++;
            box.y2++;

            TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
            if (BOX_NOT_EMPTY(box)) {
                if (pPriv->preRefresh)
                    (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
                boxNotEmpty = TRUE;
            }
        }
        else {
            BoxPtr pbox;
            int offset1, offset2, offset3;

            offset2 = pGC->lineWidth;
            if (!offset2)
                offset2 = 1;
            offset1 = offset2 >> 1;
            offset3 = offset2 - offset1;

            pBoxInit = (BoxPtr) malloc(nRects * 4 * sizeof(BoxRec));
            pbox = pBoxInit;

            while (nRects--) {
                pbox->x1 = pRects->x - offset1;
                pbox->y1 = pRects->y - offset1;
                pbox->x2 = pbox->x1 + pRects->width + offset2;
                pbox->y2 = pbox->y1 + offset2;
                TRIM_AND_TRANSLATE_BOX((*pbox), pDraw, pGC);
                if (BOX_NOT_EMPTY((*pbox))) {
                    num++;
                    pbox++;
                }

                pbox->x1 = pRects->x - offset1;
                pbox->y1 = pRects->y + offset3;
                pbox->x2 = pbox->x1 + offset2;
                pbox->y2 = pbox->y1 + pRects->height - offset2;
                TRIM_AND_TRANSLATE_BOX((*pbox), pDraw, pGC);
                if (BOX_NOT_EMPTY((*pbox))) {
                    num++;
                    pbox++;
                }

                pbox->x1 = pRects->x + pRects->width - offset1;
                pbox->y1 = pRects->y + offset3;
                pbox->x2 = pbox->x1 + offset2;
                pbox->y2 = pbox->y1 + pRects->height - offset2;
                TRIM_AND_TRANSLATE_BOX((*pbox), pDraw, pGC);
                if (BOX_NOT_EMPTY((*pbox))) {
                    num++;
                    pbox++;
                }

                pbox->x1 = pRects->x - offset1;
                pbox->y1 = pRects->y + pRects->height - offset1;
                pbox->x2 = pbox->x1 + pRects->width + offset2;
                pbox->y2 = pbox->y1 + offset2;
                TRIM_AND_TRANSLATE_BOX((*pbox), pDraw, pGC);
                if (BOX_NOT_EMPTY((*pbox))) {
                    num++;
                    pbox++;
                }

                pRects++;
            }

            if (num) {
                if (pPriv->preRefresh)
                    (*pPriv->preRefresh) (pPriv->pScrn, num, pBoxInit);
            }
            else {
                free(pBoxInit);
            }
        }
    }

    (*pGC->ops->PolyRectangle) (pDraw, pGC, nRectsInit, pRectsInit);

    if (boxNotEmpty && pPriv->postRefresh) {
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);
    }
    else if (num) {
        if (pPriv->postRefresh)
            (*pPriv->postRefresh) (pPriv->pScrn, num, pBoxInit);
        free(pBoxInit);
    }

    SHADOW_GC_OP_EPILOGUE(pGC);

}

static void
ShadowPolyArc(DrawablePtr pDraw, GCPtr pGC, int narcsInit, xArc * parcsInit)
{
    BoxRec box;
    Bool boxNotEmpty = FALSE;

    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw) && narcsInit) {
        int narcs = narcsInit;
        xArc *parcs = parcsInit;
        int extra = pGC->lineWidth >> 1;

        box.x1 = parcs->x;
        box.x2 = box.x1 + parcs->width;
        box.y1 = parcs->y;
        box.y2 = box.y1 + parcs->height;

        /* should I break these up instead ? */

        while (--narcs) {
            parcs++;
            if (box.x1 > parcs->x)
                box.x1 = parcs->x;
            if (box.x2 < (parcs->x + parcs->width))
                box.x2 = parcs->x + parcs->width;
            if (box.y1 > parcs->y)
                box.y1 = parcs->y;
            if (box.y2 < (parcs->y + parcs->height))
                box.y2 = parcs->y + parcs->height;
        }

        if (extra) {
            box.x1 -= extra;
            box.x2 += extra;
            box.y1 -= extra;
            box.y2 += extra;
        }

        box.x2++;
        box.y2++;

        TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
    }

    (*pGC->ops->PolyArc) (pDraw, pGC, narcsInit, parcsInit);

    if (boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);

}

static void
ShadowFillPolygon(DrawablePtr pDraw,
                  GCPtr pGC,
                  int shape, int mode, int count, DDXPointPtr pptInit)
{
    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw) && (count > 2)) {
        DDXPointPtr ppt = pptInit;
        int i = count;
        BoxRec box;
        Bool boxNotEmpty = FALSE;

        box.x2 = box.x1 = ppt->x;
        box.y2 = box.y1 = ppt->y;

        if (mode != CoordModeOrigin) {
            int x = box.x1;
            int y = box.y1;

            while (--i) {
                ppt++;
                x += ppt->x;
                y += ppt->y;
                if (box.x1 > x)
                    box.x1 = x;
                else if (box.x2 < x)
                    box.x2 = x;
                if (box.y1 > y)
                    box.y1 = y;
                else if (box.y2 < y)
                    box.y2 = y;
            }
        }
        else {
            while (--i) {
                ppt++;
                if (box.x1 > ppt->x)
                    box.x1 = ppt->x;
                else if (box.x2 < ppt->x)
                    box.x2 = ppt->x;
                if (box.y1 > ppt->y)
                    box.y1 = ppt->y;
                else if (box.y2 < ppt->y)
                    box.y2 = ppt->y;
            }
        }

        box.x2++;
        box.y2++;

        TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }

        (*pGC->ops->FillPolygon) (pDraw, pGC, shape, mode, count, pptInit);

        if (boxNotEmpty && pPriv->postRefresh)
            (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);
    }
    else
        (*pGC->ops->FillPolygon) (pDraw, pGC, shape, mode, count, pptInit);

    SHADOW_GC_OP_EPILOGUE(pGC);
}

static void
ShadowPolyFillRect(DrawablePtr pDraw,
                   GCPtr pGC, int nRectsInit, xRectangle *pRectsInit)
{
    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw) && nRectsInit) {
        BoxRec box;
        Bool boxNotEmpty = FALSE;
        xRectangle *pRects = pRectsInit;
        int nRects = nRectsInit;

        box.x1 = pRects->x;
        box.x2 = box.x1 + pRects->width;
        box.y1 = pRects->y;
        box.y2 = box.y1 + pRects->height;

        while (--nRects) {
            pRects++;
            if (box.x1 > pRects->x)
                box.x1 = pRects->x;
            if (box.x2 < (pRects->x + pRects->width))
                box.x2 = pRects->x + pRects->width;
            if (box.y1 > pRects->y)
                box.y1 = pRects->y;
            if (box.y2 < (pRects->y + pRects->height))
                box.y2 = pRects->y + pRects->height;
        }

        /* cfb messes with the pRectsInit so we have to do our
           calculations first */

        TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }

        (*pGC->ops->PolyFillRect) (pDraw, pGC, nRectsInit, pRectsInit);

        if (boxNotEmpty && pPriv->postRefresh)
            (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);
    }
    else
        (*pGC->ops->PolyFillRect) (pDraw, pGC, nRectsInit, pRectsInit);

    SHADOW_GC_OP_EPILOGUE(pGC);
}

static void
ShadowPolyFillArc(DrawablePtr pDraw, GCPtr pGC, int narcsInit, xArc * parcsInit)
{
    BoxRec box;
    Bool boxNotEmpty = FALSE;

    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw) && narcsInit) {
        xArc *parcs = parcsInit;
        int narcs = narcsInit;

        box.x1 = parcs->x;
        box.x2 = box.x1 + parcs->width;
        box.y1 = parcs->y;
        box.y2 = box.y1 + parcs->height;

        /* should I break these up instead ? */

        while (--narcs) {
            parcs++;
            if (box.x1 > parcs->x)
                box.x1 = parcs->x;
            if (box.x2 < (parcs->x + parcs->width))
                box.x2 = parcs->x + parcs->width;
            if (box.y1 > parcs->y)
                box.y1 = parcs->y;
            if (box.y2 < (parcs->y + parcs->height))
                box.y2 = parcs->y + parcs->height;
        }

        TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
    }

    (*pGC->ops->PolyFillArc) (pDraw, pGC, narcsInit, parcsInit);

    if (boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
}

static void
ShadowTextExtent(FontPtr pFont, int count, char *chars,
                 FontEncoding fontEncoding, BoxPtr box)
{
    unsigned long n, i;
    int w;
    CharInfoPtr charinfo[255];  /* encoding only has 1 byte for count */

    GetGlyphs(pFont, (unsigned long) count, (unsigned char *) chars,
              fontEncoding, &n, charinfo);
    w = 0;
    for (i = 0; i < n; i++) {
        w += charinfo[i]->metrics.characterWidth;
    }
    if (i) {
        w += charinfo[i - 1]->metrics.rightSideBearing;
    }

    box->x1 = 0;
    if (n) {
        if (charinfo[0]->metrics.leftSideBearing < 0) {
            box->x1 = charinfo[0]->metrics.leftSideBearing;
        }
    }
    box->x2 = w;
    box->y1 = -FONTMAXBOUNDS(pFont, ascent);
    box->y2 = FONTMAXBOUNDS(pFont, descent);
}

static void
ShadowFontToBox(BoxPtr BB, DrawablePtr pDrawable, GCPtr pGC, int x, int y,
                int count, char *chars, int wide)
{
    FontPtr pFont;

    pFont = pGC->font;
    if (pFont->info.constantWidth) {
        int ascent, descent, left, right = 0;

        ascent = max(pFont->info.fontAscent, pFont->info.maxbounds.ascent);
        descent = max(pFont->info.fontDescent, pFont->info.maxbounds.descent);
        left = pFont->info.maxbounds.leftSideBearing;
        if (count > 0) {
            right = (count - 1) * pFont->info.maxbounds.characterWidth;
        }
        right += pFont->info.maxbounds.rightSideBearing;
        BB->x1 =
            max(pDrawable->x + x - left,
                RegionExtents(&((WindowPtr) pDrawable)->winSize)->x1);
        BB->y1 =
            max(pDrawable->y + y - ascent,
                RegionExtents(&((WindowPtr) pDrawable)->winSize)->y1);
        BB->x2 =
            min(pDrawable->x + x + right,
                RegionExtents(&((WindowPtr) pDrawable)->winSize)->x2);
        BB->y2 =
            min(pDrawable->y + y + descent,
                RegionExtents(&((WindowPtr) pDrawable)->winSize)->y2);
    }
    else {
        ShadowTextExtent(pFont, count, chars, wide ? (FONTLASTROW(pFont) == 0)
                         ? Linear16Bit : TwoD16Bit : Linear8Bit, BB);
        BB->x1 =
            max(pDrawable->x + x + BB->x1,
                RegionExtents(&((WindowPtr) pDrawable)->winSize)->x1);
        BB->y1 =
            max(pDrawable->y + y + BB->y1,
                RegionExtents(&((WindowPtr) pDrawable)->winSize)->y1);
        BB->x2 =
            min(pDrawable->x + x + BB->x2,
                RegionExtents(&((WindowPtr) pDrawable)->winSize)->x2);
        BB->y2 =
            min(pDrawable->y + y + BB->y2,
                RegionExtents(&((WindowPtr) pDrawable)->winSize)->y2);
    }
}

static int
ShadowPolyText8(DrawablePtr pDraw,
                GCPtr pGC, int x, int y, int count, char *chars)
{
    int width;
    BoxRec box;
    Bool boxNotEmpty = FALSE;

    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw)) {
        ShadowFontToBox(&box, pDraw, pGC, x, y, count, chars, 0);

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
    }

    width = (*pGC->ops->PolyText8) (pDraw, pGC, x, y, count, chars);

    if (boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);

    return width;
}

static int
ShadowPolyText16(DrawablePtr pDraw,
                 GCPtr pGC, int x, int y, int count, unsigned short *chars)
{
    int width;
    BoxRec box;
    Bool boxNotEmpty = FALSE;

    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw)) {
        ShadowFontToBox(&box, pDraw, pGC, x, y, count, (char *) chars, 1);

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
    }

    width = (*pGC->ops->PolyText16) (pDraw, pGC, x, y, count, chars);

    if (boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);

    return width;
}

static void
ShadowImageText8(DrawablePtr pDraw,
                 GCPtr pGC, int x, int y, int count, char *chars)
{
    BoxRec box;
    Bool boxNotEmpty = FALSE;

    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw) && count) {
        int top, bot, Min, Max;

        top = max(FONTMAXBOUNDS(pGC->font, ascent), FONTASCENT(pGC->font));
        bot = max(FONTMAXBOUNDS(pGC->font, descent), FONTDESCENT(pGC->font));

        Min = count * FONTMINBOUNDS(pGC->font, characterWidth);
        if (Min > 0)
            Min = 0;
        Max = count * FONTMAXBOUNDS(pGC->font, characterWidth);
        if (Max < 0)
            Max = 0;

        /* ugh */
        box.x1 = pDraw->x + x + Min + FONTMINBOUNDS(pGC->font, leftSideBearing);
        box.x2 = pDraw->x + x + Max +
            FONTMAXBOUNDS(pGC->font, rightSideBearing);

        box.y1 = pDraw->y + y - top;
        box.y2 = pDraw->y + y + bot;

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
    }

    (*pGC->ops->ImageText8) (pDraw, pGC, x, y, count, chars);

    if (boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
}

static void
ShadowImageText16(DrawablePtr pDraw,
                  GCPtr pGC, int x, int y, int count, unsigned short *chars)
{
    BoxRec box;
    Bool boxNotEmpty = FALSE;

    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw) && count) {
        int top, bot, Min, Max;

        top = max(FONTMAXBOUNDS(pGC->font, ascent), FONTASCENT(pGC->font));
        bot = max(FONTMAXBOUNDS(pGC->font, descent), FONTDESCENT(pGC->font));

        Min = count * FONTMINBOUNDS(pGC->font, characterWidth);
        if (Min > 0)
            Min = 0;
        Max = count * FONTMAXBOUNDS(pGC->font, characterWidth);
        if (Max < 0)
            Max = 0;

        /* ugh */
        box.x1 = pDraw->x + x + Min + FONTMINBOUNDS(pGC->font, leftSideBearing);
        box.x2 = pDraw->x + x + Max +
            FONTMAXBOUNDS(pGC->font, rightSideBearing);

        box.y1 = pDraw->y + y - top;
        box.y2 = pDraw->y + y + bot;

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
    }

    (*pGC->ops->ImageText16) (pDraw, pGC, x, y, count, chars);

    if (boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
}

static void
ShadowImageGlyphBlt(DrawablePtr pDraw,
                    GCPtr pGC,
                    int x, int y,
                    unsigned int nglyphInit,
                    CharInfoPtr * ppciInit, pointer pglyphBase)
{
    BoxRec box;
    Bool boxNotEmpty = FALSE;

    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw) && nglyphInit) {
        CharInfoPtr *ppci = ppciInit;
        unsigned int nglyph = nglyphInit;
        int top, bot, width = 0;

        top = max(FONTMAXBOUNDS(pGC->font, ascent), FONTASCENT(pGC->font));
        bot = max(FONTMAXBOUNDS(pGC->font, descent), FONTDESCENT(pGC->font));

        box.x1 = ppci[0]->metrics.leftSideBearing;
        if (box.x1 > 0)
            box.x1 = 0;
        box.x2 = ppci[nglyph - 1]->metrics.rightSideBearing -
            ppci[nglyph - 1]->metrics.characterWidth;
        if (box.x2 < 0)
            box.x2 = 0;

        box.x2 += pDraw->x + x;
        box.x1 += pDraw->x + x;

        while (nglyph--) {
            width += (*ppci)->metrics.characterWidth;
            ppci++;
        }

        if (width > 0)
            box.x2 += width;
        else
            box.x1 += width;

        box.y1 = pDraw->y + y - top;
        box.y2 = pDraw->y + y + bot;

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
    }

    (*pGC->ops->ImageGlyphBlt) (pDraw, pGC, x, y, nglyphInit,
                                ppciInit, pglyphBase);

    if (boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
}

static void
ShadowPolyGlyphBlt(DrawablePtr pDraw,
                   GCPtr pGC,
                   int x, int y,
                   unsigned int nglyphInit,
                   CharInfoPtr * ppciInit, pointer pglyphBase)
{
    BoxRec box;
    Bool boxNotEmpty = FALSE;

    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw) && nglyphInit) {
        CharInfoPtr *ppci = ppciInit;
        unsigned int nglyph = nglyphInit;

        /* ugh */
        box.x1 = pDraw->x + x + ppci[0]->metrics.leftSideBearing;
        box.x2 = pDraw->x + x + ppci[nglyph - 1]->metrics.rightSideBearing;

        if (nglyph > 1) {
            int width = 0;

            while (--nglyph) {
                width += (*ppci)->metrics.characterWidth;
                ppci++;
            }

            if (width > 0)
                box.x2 += width;
            else
                box.x1 += width;
        }

        box.y1 = pDraw->y + y - FONTMAXBOUNDS(pGC->font, ascent);
        box.y2 = pDraw->y + y + FONTMAXBOUNDS(pGC->font, descent);

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
    }

    (*pGC->ops->PolyGlyphBlt) (pDraw, pGC, x, y, nglyphInit,
                               ppciInit, pglyphBase);

    if (boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
}

static void
ShadowPushPixels(GCPtr pGC,
                 PixmapPtr pBitMap,
                 DrawablePtr pDraw, int dx, int dy, int xOrg, int yOrg)
{
    BoxRec box;
    Bool boxNotEmpty = FALSE;

    SHADOW_GC_OP_PROLOGUE(pGC);

    if (IS_VISIBLE(pDraw)) {
        box.x1 = xOrg;
        box.y1 = yOrg;

        if (!pGC->miTranslate) {
            box.x1 += pDraw->x;
            box.y1 += pDraw->y;
        }

        box.x2 = box.x1 + dx;
        box.y2 = box.y1 + dy;

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box)) {
            if (pPriv->preRefresh)
                (*pPriv->preRefresh) (pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
    }

    (*pGC->ops->PushPixels) (pGC, pBitMap, pDraw, dx, dy, xOrg, yOrg);

    if (boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh) (pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
}

GCOps ShadowGCOps = {
    ShadowFillSpans, ShadowSetSpans,
    ShadowPutImage, ShadowCopyArea,
    ShadowCopyPlane, ShadowPolyPoint,
    ShadowPolylines, ShadowPolySegment,
    ShadowPolyRectangle, ShadowPolyArc,
    ShadowFillPolygon, ShadowPolyFillRect,
    ShadowPolyFillArc, ShadowPolyText8,
    ShadowPolyText16, ShadowImageText8,
    ShadowImageText16, ShadowImageGlyphBlt,
    ShadowPolyGlyphBlt, ShadowPushPixels,
};
@


1.10
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d31 1
a31 1
static Bool ShadowCloseScreen(int i, ScreenPtr pScreen);
d36 2
a37 2
static Bool ShadowEnterVT(int index, int flags);
static void ShadowLeaveVT(int index, int flags);
d59 2
a60 2
    Bool (*EnterVT) (int, int);
    void (*LeaveVT) (int, int);
d139 1
a139 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d195 1
a195 1
ShadowEnterVT(int index, int flags)
a196 1
    ScrnInfoPtr pScrn = xf86Screens[index];
d201 1
a201 1
    ret = (*pPriv->EnterVT) (index, flags);
d213 1
a213 1
ShadowLeaveVT(int index, int flags)
d215 1
a215 2
    ScrnInfoPtr pScrn = xf86Screens[index];
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(xf86Screens[index]->pScreen);
d220 1
a220 1
    (*pPriv->LeaveVT) (index, flags);
d228 1
a228 1
ShadowCloseScreen(int i, ScreenPtr pScreen)
d230 1
a230 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d248 1
a248 1
    return (*pScreen->CloseScreen) (i, pScreen);
@


1.9
log
@Update to xserver 1.11.2
@
text
@a8 1

d29 1
a29 1
# include "picturestr.h"
d31 3
a33 6
static Bool ShadowCloseScreen (int i, ScreenPtr pScreen);
static void ShadowCopyWindow(
    WindowPtr pWin,
    DDXPointRec ptOldOrg,
    RegionPtr prgn 
);
d39 10
a48 15
static void ShadowComposite(
    CARD8 op,
    PicturePtr pSrc,
    PicturePtr pMask,
    PicturePtr pDst,
    INT16 xSrc,
    INT16 ySrc,
    INT16 xMask,
    INT16 yMask,
    INT16 xDst,
    INT16 yDst,
    CARD16 width,
    CARD16 height
);

d51 11
a61 11
  ScrnInfoPtr 				pScrn;
  RefreshAreaFuncPtr			preRefresh;
  RefreshAreaFuncPtr                    postRefresh;
  CloseScreenProcPtr			CloseScreen;
  CopyWindowProcPtr			CopyWindow;
  CreateGCProcPtr			CreateGC;
  ModifyPixmapHeaderProcPtr		ModifyPixmapHeader;
  CompositeProcPtr Composite;
  Bool				(*EnterVT)(int, int);
  void				(*LeaveVT)(int, int);
  Bool				vtSema;
d65 2
a66 2
   GCOps   *ops;
   GCFuncs *funcs;
d70 1
d74 1
a102 1
    
a133 2


d135 4
a138 5
ShadowFBInit2 (
    ScreenPtr		pScreen,
    RefreshAreaFuncPtr  preRefreshArea,
    RefreshAreaFuncPtr  postRefreshArea
){
d143 3
a145 2
    if(!preRefreshArea && !postRefreshArea) return FALSE;
    
d147 1
a147 1
	return FALSE;
d149 3
a151 2
    if(!dixRegisterPrivateKey(&ShadowGCKeyRec, PRIVATE_GC, sizeof(ShadowGCRec)))
	return FALSE;
d153 2
a154 2
    if(!(pPriv = (ShadowScreenPtr)malloc(sizeof(ShadowScreenRec))))
	return FALSE;
d178 3
a180 3
    if(ps) {
      pPriv->Composite = ps->Composite;
      ps->Composite = ShadowComposite;
d187 2
a188 4
ShadowFBInit (
    ScreenPtr		pScreen,
    RefreshAreaFuncPtr  refreshArea
){
d202 1
a202 1
    ret = (*pPriv->EnterVT)(index, flags);
d205 2
a206 2
    if(ret) {
	pPriv->vtSema = TRUE;
d222 1
a222 1
    (*pPriv->LeaveVT)(index, flags);
a228 1

d230 1
a230 1
ShadowCloseScreen (int i, ScreenPtr pScreen)
d244 1
a244 1
    if(ps) {
d248 1
a248 1
    free((pointer)pPriv);
d253 3
a255 6
static void 
ShadowCopyWindow(
   WindowPtr pWin,
   DDXPointRec ptOldOrg,
   RegionPtr prgn 
){
d263 2
a264 2
	RegionCopy(&rgnDst, prgn);
        
d266 2
a267 2
                         pWin->drawable.x - ptOldOrg.x,
                         pWin->drawable.y - ptOldOrg.y);
d270 4
a273 3
            if(pPriv->preRefresh)
                (*pPriv->preRefresh)(pPriv->pScrn, num, RegionRects(&rgnDst));
        } else {
d277 1
a277 1
    
d281 1
a281 1
    
d284 1
a284 1
            (*pPriv->postRefresh)(pPriv->pScrn, num, RegionRects(&rgnDst));
d290 10
a299 14
ShadowComposite(
    CARD8 op,
    PicturePtr pSrc,
    PicturePtr pMask,
    PicturePtr pDst,
    INT16 xSrc,
    INT16 ySrc,
    INT16 xMask,
    INT16 yMask,
    INT16 xDst,
    INT16 yDst,
    CARD16 width,
    CARD16 height
){
d307 1
a307 2
    if (pPriv->vtSema
	&& pDst->pDrawable->type == DRAWABLE_WINDOW) {
d309 20
a328 16
	box.x1 = pDst->pDrawable->x + xDst;
	box.y1 = pDst->pDrawable->y + yDst;
	box.x2 = box.x1 + width;
	box.y2 = box.y1 + height;

	extents = &pDst->pCompositeClip->extents;
	if(box.x1 < extents->x1) box.x1 = extents->x1;
	if(box.x2 > extents->x2) box.x2 = extents->x2;
	if(box.y1 < extents->y1) box.y1 = extents->y1;
	if(box.y2 > extents->y2) box.y2 = extents->y2;
	
	if (BOX_NOT_EMPTY(box)) {
	    if (pPriv->preRefresh)
		(*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
	    boxNotEmpty = TRUE;
	}
d330 1
a330 1
    
d332 2
a333 2
    (*ps->Composite)(op, pSrc, pMask, pDst, xSrc, ySrc,
		     xMask, yMask, xDst, yDst, width, height);
d337 1
a337 1
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
a355 1

d365 1
a365 1
   
d367 4
a370 4
    if((ret = (*pScreen->CreateGC) (pGC))) {
	pGCPriv->ops = NULL;
	pGCPriv->funcs = pGC->funcs;
	pGC->funcs = &ShadowGCFuncs;
a376 1

d378 9
a386 12
ShadowValidateGC(
   GCPtr         pGC,
   unsigned long changes,
   DrawablePtr   pDraw 
){
    SHADOW_GC_FUNC_PROLOGUE (pGC);
    (*pGC->funcs->ValidateGC)(pGC, changes, pDraw);
    if(pDraw->type == DRAWABLE_WINDOW)
	pGCPriv->ops = pGC->ops;  /* just so it's not NULL */
    else 
	pGCPriv->ops = NULL;
    SHADOW_GC_FUNC_EPILOGUE (pGC);
a388 1

d392 3
a394 3
    SHADOW_GC_FUNC_PROLOGUE (pGC);
    (*pGC->funcs->DestroyGC)(pGC);
    SHADOW_GC_FUNC_EPILOGUE (pGC);
d398 3
a400 5
ShadowChangeGC (
    GCPtr	    pGC,
    unsigned long   mask
){
    SHADOW_GC_FUNC_PROLOGUE (pGC);
d402 1
a402 1
    SHADOW_GC_FUNC_EPILOGUE (pGC);
d406 3
a408 6
ShadowCopyGC (
    GCPtr	    pGCSrc, 
    unsigned long   mask,
    GCPtr	    pGCDst
){
    SHADOW_GC_FUNC_PROLOGUE (pGCDst);
d410 1
a410 1
    SHADOW_GC_FUNC_EPILOGUE (pGCDst);
d414 3
a416 7
ShadowChangeClip (
    GCPtr   pGC,
    int		type,
    pointer	pvalue,
    int		nrects 
){
    SHADOW_GC_FUNC_PROLOGUE (pGC);
d418 1
a418 1
    SHADOW_GC_FUNC_EPILOGUE (pGC);
d424 3
a426 3
    SHADOW_GC_FUNC_PROLOGUE (pgcDst);
    (* pgcDst->funcs->CopyClip)(pgcDst, pgcSrc);
    SHADOW_GC_FUNC_EPILOGUE (pgcDst);
d432 3
a434 3
    SHADOW_GC_FUNC_PROLOGUE (pGC);
    (* pGC->funcs->DestroyClip)(pGC);
    SHADOW_GC_FUNC_EPILOGUE (pGC);
d437 1
d439 6
d446 6
d453 16
a468 1
/**********************************************************/
d470 1
d472 4
a475 17
static void
ShadowFillSpans(
    DrawablePtr pDraw,
    GC		*pGC,
    int		nInit,	
    DDXPointPtr pptInit,	
    int 	*pwidthInit,		
    int 	fSorted 
){
    SHADOW_GC_OP_PROLOGUE(pGC);    

    if(IS_VISIBLE(pDraw) && nInit) {
	DDXPointPtr ppt = pptInit;
	int *pwidth = pwidthInit;
	int i = nInit;
	BoxRec box;
        Bool boxNotEmpty = FALSE;
d477 3
a479 24
	box.x1 = ppt->x;
	box.x2 = box.x1 + *pwidth;
	box.y2 = box.y1 = ppt->y;

	while(--i) {
	   ppt++;
	   pwidth++;
	   if(box.x1 > ppt->x) box.x1 = ppt->x;
	   if(box.x2 < (ppt->x + *pwidth)) 
		box.x2 = ppt->x + *pwidth;
	   if(box.y1 > ppt->y) box.y1 = ppt->y;
	   else if(box.y2 < ppt->y) box.y2 = ppt->y;
	}

	box.y2++;

        if(!pGC->miTranslate) {
           TRANSLATE_BOX(box, pDraw);
        }
        TRIM_BOX(box, pGC); 

	if(BOX_NOT_EMPTY(box)) {
            if(pPriv->preRefresh)
                (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
d483 2
a484 1
	(*pGC->ops->FillSpans)(pDraw, pGC, nInit, pptInit, pwidthInit, fSorted);
d486 6
a491 4
        if(boxNotEmpty && pPriv->postRefresh)
	   (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    } else
	(*pGC->ops->FillSpans)(pDraw, pGC, nInit, pptInit, pwidthInit, fSorted);
d497 5
a501 9
ShadowSetSpans(
    DrawablePtr		pDraw,
    GCPtr		pGC,
    char		*pcharsrc,
    DDXPointPtr 	pptInit,
    int			*pwidthInit,
    int			nspans,
    int			fSorted 
){
d504 5
a508 5
    if(IS_VISIBLE(pDraw) && nspans) {
	DDXPointPtr ppt = pptInit;
	int *pwidth = pwidthInit;
	int i = nspans;
	BoxRec box;
d511 16
a526 13
	box.x1 = ppt->x;
	box.x2 = box.x1 + *pwidth;
	box.y2 = box.y1 = ppt->y;

	while(--i) {
	   ppt++;
	   pwidth++;
	   if(box.x1 > ppt->x) box.x1 = ppt->x;
	   if(box.x2 < (ppt->x + *pwidth)) 
		box.x2 = ppt->x + *pwidth;
	   if(box.y1 > ppt->y) box.y1 = ppt->y;
	   else if(box.y2 < ppt->y) box.y2 = ppt->y;
	}
d528 1
a528 1
	box.y2++;
d530 2
a531 2
        if(!pGC->miTranslate) {
           TRANSLATE_BOX(box, pDraw);
d535 4
a538 4
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
d541 9
a549 8
	(*pGC->ops->SetSpans)(pDraw, pGC, pcharsrc, pptInit, 
				pwidthInit, nspans, fSorted);

	if(boxNotEmpty && pPriv->postRefresh)
	   (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    } else
	(*pGC->ops->SetSpans)(pDraw, pGC, pcharsrc, pptInit, 
				pwidthInit, nspans, fSorted);
d555 6
a560 9
ShadowPutImage(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		depth, 
    int x, int y, int w, int h,
    int		leftPad,
    int		format,
    char 	*pImage 
){
d563 1
a563 1
    
d566 11
a576 11
    if(IS_VISIBLE(pDraw)) {
	box.x1 = x + pDraw->x;
	box.x2 = box.x1 + w;
	box.y1 = y + pDraw->y;
	box.y2 = box.y1 + h;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
d580 6
a585 6
    (*pGC->ops->PutImage)(pDraw, pGC, depth, x, y, w, h, 
		leftPad, format, pImage);
                
    if(boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
d591 5
a595 8
ShadowCopyArea(
    DrawablePtr pSrc,
    DrawablePtr pDst,
    GC *pGC,
    int srcx, int srcy,
    int width, int height,
    int dstx, int dsty 
){
d599 1
a599 1
    
d602 20
a621 20
    if(IS_VISIBLE(pDst)) {
	box.x1 = dstx + pDst->x;
	box.x2 = box.x1 + width;
	box.y1 = dsty + pDst->y;
	box.y2 = box.y1 + height;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
    }
    
    ret = (*pGC->ops->CopyArea)(pSrc, pDst,
            pGC, srcx, srcy, width, height, dstx, dsty);

    if(boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
d628 7
a634 9
ShadowCopyPlane(
    DrawablePtr	pSrc,
    DrawablePtr	pDst,
    GCPtr pGC,
    int	srcx, int srcy,
    int	width, int height,
    int	dstx, int dsty,
    unsigned long bitPlane 
){
d638 1
a638 1
    
d641 21
a661 20
    if(IS_VISIBLE(pDst)) {
	box.x1 = dstx + pDst->x;
	box.x2 = box.x1 + width;
	box.y1 = dsty + pDst->y;
	box.y2 = box.y1 + height;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
    }
    
    ret = (*pGC->ops->CopyPlane)(pSrc, pDst,
	       pGC, srcx, srcy, width, height, dstx, dsty, bitPlane);
    
    if(boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
d668 3
a670 7
ShadowPolyPoint(
    DrawablePtr pDraw,
    GCPtr pGC,
    int mode,
    int nptInit,
    xPoint *pptInit 
){
d673 1
a673 1
    
d676 1
a676 1
    if(IS_VISIBLE(pDraw) && nptInit) {
d680 2
a681 2
	box.x2 = box.x1 = pptInit->x;
	box.y2 = box.y1 = pptInit->y;
d683 1
a683 1
	/* this could be slow if the points were spread out */
d685 27
a711 23
	while(--npt) {
	   ppt++;
	   if(box.x1 > ppt->x) box.x1 = ppt->x;
	   else if(box.x2 < ppt->x) box.x2 = ppt->x;
	   if(box.y1 > ppt->y) box.y1 = ppt->y;
	   else if(box.y2 < ppt->y) box.y2 = ppt->y;
	}

	box.x2++;
	box.y2++;

	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
    }
    
    (*pGC->ops->PolyPoint)(pDraw, pGC, mode, nptInit, pptInit);
    
    if(boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
d717 3
a719 7
ShadowPolylines(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		mode,		
    int		nptInit,		
    DDXPointPtr pptInit 
){
d722 1
a722 1
    
d725 1
a725 1
    if(IS_VISIBLE(pDraw) && nptInit) {
d728 46
a773 1
	int extra = pGC->lineWidth >> 1;
d775 6
a780 2
	box.x2 = box.x1 = pptInit->x;
	box.y2 = box.y1 = pptInit->y;
d782 5
a786 44
	if(npt > 1) {
	   if(pGC->joinStyle == JoinMiter)
		extra = 6 * pGC->lineWidth;
	   else if(pGC->capStyle == CapProjecting)
		extra = pGC->lineWidth;
        }

	if(mode == CoordModePrevious) {
	   int x = box.x1;
	   int y = box.y1;
	   while(--npt) {
		ppt++;
		x += ppt->x;
		y += ppt->y;
		if(box.x1 > x) box.x1 = x;
		else if(box.x2 < x) box.x2 = x;
		if(box.y1 > y) box.y1 = y;
		else if(box.y2 < y) box.y2 = y;
	    }
	} else {
	   while(--npt) {
		ppt++;
		if(box.x1 > ppt->x) box.x1 = ppt->x;
		else if(box.x2 < ppt->x) box.x2 = ppt->x;
		if(box.y1 > ppt->y) box.y1 = ppt->y;
		else if(box.y2 < ppt->y) box.y2 = ppt->y;
	    }
	}

	box.x2++;
	box.y2++;

	if(extra) {
	   box.x1 -= extra;
	   box.x2 += extra;
	   box.y1 -= extra;
	   box.y2 += extra;
        }

	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
a788 2
    
    (*pGC->ops->Polylines)(pDraw, pGC, mode, nptInit, pptInit);
d790 4
a793 2
    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
d798 4
a801 7
static void 
ShadowPolySegment(
    DrawablePtr	pDraw,
    GCPtr	pGC,
    int		nsegInit,
    xSegment	*pSegInit 
){
d804 1
a804 1
   
d807 2
a808 2
    if(IS_VISIBLE(pDraw) && nsegInit) {
	int extra = pGC->lineWidth;
d812 2
a813 2
        if(pGC->capStyle != CapProjecting)	
	   extra >>= 1;
d815 61
a875 49
	if(pSeg->x2 > pSeg->x1) {
	    box.x1 = pSeg->x1;
	    box.x2 = pSeg->x2;
	} else {
	    box.x2 = pSeg->x1;
	    box.x1 = pSeg->x2;
	}

	if(pSeg->y2 > pSeg->y1) {
	    box.y1 = pSeg->y1;
	    box.y2 = pSeg->y2;
	} else {
	    box.y2 = pSeg->y1;
	    box.y1 = pSeg->y2;
	}

	while(--nseg) {
	    pSeg++;
	    if(pSeg->x2 > pSeg->x1) {
		if(pSeg->x1 < box.x1) box.x1 = pSeg->x1;
		if(pSeg->x2 > box.x2) box.x2 = pSeg->x2;
	    } else {
		if(pSeg->x2 < box.x1) box.x1 = pSeg->x2;
		if(pSeg->x1 > box.x2) box.x2 = pSeg->x1;
	    }
	    if(pSeg->y2 > pSeg->y1) {
		if(pSeg->y1 < box.y1) box.y1 = pSeg->y1;
		if(pSeg->y2 > box.y2) box.y2 = pSeg->y2;
	    } else {
		if(pSeg->y2 < box.y1) box.y1 = pSeg->y2;
		if(pSeg->y1 > box.y2) box.y2 = pSeg->y1;
	    }
	}

	box.x2++;
	box.y2++;

	if(extra) {
	   box.x1 -= extra;
	   box.x2 += extra;
	   box.y1 -= extra;
	   box.y2 += extra;
        }

	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
a877 2
    
    (*pGC->ops->PolySegment)(pDraw, pGC, nsegInit, pSegInit);
d879 4
a882 2
    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
d888 3
a890 6
ShadowPolyRectangle(
    DrawablePtr  pDraw,
    GCPtr        pGC,
    int	         nRectsInit,
    xRectangle  *pRectsInit 
){
d895 1
a895 1
    
d898 1
a898 1
    if(IS_VISIBLE(pDraw) && nRectsInit) {
d902 19
a920 2
	if(nRects >= 32) {
	    int extra = pGC->lineWidth >> 1;
d922 14
a935 29
	    box.x1 = pRects->x;
	    box.x2 = box.x1 + pRects->width;
	    box.y1 = pRects->y;
	    box.y2 = box.y1 + pRects->height;

	    while(--nRects) {
		pRects++;
		if(box.x1 > pRects->x) box.x1 = pRects->x;
		if(box.x2 < (pRects->x + pRects->width))
			box.x2 = pRects->x + pRects->width;
		if(box.y1 > pRects->y) box.y1 = pRects->y;
		if(box.y2 < (pRects->y + pRects->height))
			box.y2 = pRects->y + pRects->height;
	    }

	    if(extra) {
		box.x1 -= extra;
		box.x2 += extra;
		box.y1 -= extra;
		box.y2 += extra;
	    }

	    box.x2++;
	    box.y2++;

	    TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	    if(BOX_NOT_EMPTY(box)) {
                if(pPriv->preRefresh)
                   (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
d938 63
a1000 60
	} else {
	    BoxPtr pbox;
	    int offset1, offset2, offset3;

	    offset2 = pGC->lineWidth;
	    if(!offset2) offset2 = 1;
	    offset1 = offset2 >> 1;
	    offset3 = offset2 - offset1;

	    pBoxInit = (BoxPtr)malloc(nRects * 4 * sizeof(BoxRec));
	    pbox = pBoxInit;

	    while(nRects--) {
		pbox->x1 = pRects->x - offset1;
		pbox->y1 = pRects->y - offset1;
		pbox->x2 = pbox->x1 + pRects->width + offset2;
		pbox->y2 = pbox->y1 + offset2;		
		TRIM_AND_TRANSLATE_BOX((*pbox), pDraw, pGC);
		if(BOX_NOT_EMPTY((*pbox))) {
		   num++;
		   pbox++;
		}

		pbox->x1 = pRects->x - offset1;
		pbox->y1 = pRects->y + offset3;
		pbox->x2 = pbox->x1 + offset2;
		pbox->y2 = pbox->y1 + pRects->height - offset2;		
		TRIM_AND_TRANSLATE_BOX((*pbox), pDraw, pGC);
		if(BOX_NOT_EMPTY((*pbox))) {
		   num++;
		   pbox++;
		}

		pbox->x1 = pRects->x + pRects->width - offset1;
		pbox->y1 = pRects->y + offset3;
		pbox->x2 = pbox->x1 + offset2;
		pbox->y2 = pbox->y1 + pRects->height - offset2;		
		TRIM_AND_TRANSLATE_BOX((*pbox), pDraw, pGC);
		if(BOX_NOT_EMPTY((*pbox))) {
		   num++;
		   pbox++;
		}

		pbox->x1 = pRects->x - offset1;
		pbox->y1 = pRects->y + pRects->height - offset1;
		pbox->x2 = pbox->x1 + pRects->width + offset2;
		pbox->y2 = pbox->y1 + offset2;		
		TRIM_AND_TRANSLATE_BOX((*pbox), pDraw, pGC);
		if(BOX_NOT_EMPTY((*pbox))) {
		   num++;
		   pbox++;
		}

		pRects++;
	    }
	    
	    if(num) {
                if(pPriv->preRefresh)
                    (*pPriv->preRefresh)(pPriv->pScrn, num, pBoxInit);
            } else {
d1002 2
a1003 2
            }                
	}
d1006 1
a1006 1
    (*pGC->ops->PolyRectangle)(pDraw, pGC, nRectsInit, pRectsInit);
d1008 7
a1014 6
    if(boxNotEmpty && pPriv->postRefresh) {
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    } else if(num) {
       if(pPriv->postRefresh)
          (*pPriv->postRefresh)(pPriv->pScrn, num, pBoxInit);
       free(pBoxInit);
d1016 1
a1016 1
    
d1022 2
a1023 6
ShadowPolyArc(
    DrawablePtr	pDraw,
    GCPtr	pGC,
    int		narcsInit,
    xArc	*parcsInit 
){
d1026 1
a1026 1
   
d1029 1
a1029 1
    if(IS_VISIBLE(pDraw) && narcsInit) {
d1034 42
a1075 40
	box.x1 = parcs->x;
	box.x2 = box.x1 + parcs->width;
	box.y1 = parcs->y;
	box.y2 = box.y1 + parcs->height;

	/* should I break these up instead ? */

	while(--narcs) {
	   parcs++;
	   if(box.x1 > parcs->x) box.x1 = parcs->x;
	   if(box.x2 < (parcs->x + parcs->width))
		box.x2 = parcs->x + parcs->width;
	   if(box.y1 > parcs->y) box.y1 = parcs->y;
	   if(box.y2 < (parcs->y + parcs->height))
		box.y2 = parcs->y + parcs->height;
        }

	if(extra) {
	   box.x1 -= extra;
	   box.x2 += extra;
	   box.y1 -= extra;
	   box.y2 += extra;
        }

	box.x2++;
	box.y2++;

	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
    }
    
    (*pGC->ops->PolyArc)(pDraw, pGC, narcsInit, parcsInit);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
d1081 4
a1084 8
ShadowFillPolygon(
    DrawablePtr	pDraw,
    GCPtr	pGC,
    int		shape,
    int		mode,
    int		count,
    DDXPointPtr	pptInit 
){
d1087 4
a1090 4
    if(IS_VISIBLE(pDraw) && (count > 2)) {
	DDXPointPtr ppt = pptInit;
	int i = count;
	BoxRec box;
d1093 2
a1094 2
	box.x2 = box.x1 = ppt->x;
	box.y2 = box.y1 = ppt->y;
d1096 49
a1144 38
	if(mode != CoordModeOrigin) {
	   int x = box.x1;
	   int y = box.y1;
	   while(--i) {
		ppt++;
		x += ppt->x;
		y += ppt->y;
		if(box.x1 > x) box.x1 = x;
		else if(box.x2 < x) box.x2 = x;
		if(box.y1 > y) box.y1 = y;
		else if(box.y2 < y) box.y2 = y;
	    }
	} else {
	   while(--i) {
		ppt++;
		if(box.x1 > ppt->x) box.x1 = ppt->x;
		else if(box.x2 < ppt->x) box.x2 = ppt->x;
		if(box.y1 > ppt->y) box.y1 = ppt->y;
		else if(box.y2 < ppt->y) box.y2 = ppt->y;
	    }
	}

	box.x2++;
	box.y2++;

	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }

	(*pGC->ops->FillPolygon)(pDraw, pGC, shape, mode, count, pptInit);

        if(boxNotEmpty && pPriv->postRefresh)
           (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);        
    } else
	(*pGC->ops->FillPolygon)(pDraw, pGC, shape, mode, count, pptInit);
d1149 4
a1152 8

static void 
ShadowPolyFillRect(
    DrawablePtr	pDraw,
    GCPtr	pGC,
    int		nRectsInit, 
    xRectangle	*pRectsInit 
){
d1155 2
a1156 2
    if(IS_VISIBLE(pDraw) && nRectsInit) {
	BoxRec box;
d1158 2
a1159 2
	xRectangle *pRects = pRectsInit;
	int nRects = nRectsInit;
d1161 24
a1184 22
	box.x1 = pRects->x;
	box.x2 = box.x1 + pRects->width;
	box.y1 = pRects->y;
	box.y2 = box.y1 + pRects->height;

	while(--nRects) {
	    pRects++;
	    if(box.x1 > pRects->x) box.x1 = pRects->x;
	    if(box.x2 < (pRects->x + pRects->width))
		box.x2 = pRects->x + pRects->width;
	    if(box.y1 > pRects->y) box.y1 = pRects->y;
	    if(box.y2 < (pRects->y + pRects->height))
		box.y2 = pRects->y + pRects->height;
	}

	/* cfb messes with the pRectsInit so we have to do our
	   calculations first */

	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box)) {
            if(pPriv->preRefresh)
                (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
d1188 1
a1188 1
	(*pGC->ops->PolyFillRect)(pDraw, pGC, nRectsInit, pRectsInit);
d1190 5
a1194 4
        if(boxNotEmpty && pPriv->postRefresh)
            (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    } else
	(*pGC->ops->PolyFillRect)(pDraw, pGC, nRectsInit, pRectsInit);
a1198 1

d1200 2
a1201 6
ShadowPolyFillArc(
    DrawablePtr	pDraw,
    GCPtr	pGC,
    int		narcsInit,
    xArc	*parcsInit 
){
d1204 1
a1204 1
   
d1207 1
a1207 1
    if(IS_VISIBLE(pDraw) && narcsInit) {
d1211 24
a1234 15
	box.x1 = parcs->x;
	box.x2 = box.x1 + parcs->width;
	box.y1 = parcs->y;
	box.y2 = box.y1 + parcs->height;

	/* should I break these up instead ? */

	while(--narcs) {
	   parcs++;
	   if(box.x1 > parcs->x) box.x1 = parcs->x;
	   if(box.x2 < (parcs->x + parcs->width))
		box.x2 = parcs->x + parcs->width;
	   if(box.y1 > parcs->y) box.y1 = parcs->y;
	   if(box.y2 < (parcs->y + parcs->height))
		box.y2 = parcs->y + parcs->height;
d1236 1
d1238 1
a1238 7
	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
    }
d1240 2
a1241 1
    (*pGC->ops->PolyFillArc)(pDraw, pGC, narcsInit, parcsInit);
a1242 3
    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);       
    
d1247 1
a1247 1
ShadowTextExtent(FontPtr pFont, int count, char* chars,
d1252 1
a1252 1
    CharInfoPtr charinfo[255];	/* encoding only has 1 byte for count */
d1254 2
a1255 2
    GetGlyphs(pFont, (unsigned long)count, (unsigned char *)chars,
	      fontEncoding, &n, charinfo);
d1257 1
a1257 1
    for (i=0; i < n; i++) {
d1261 1
a1261 1
    	w += charinfo[i - 1]->metrics.rightSideBearing;
d1263 1
a1263 1
    
d1266 1
a1266 1
	if (charinfo[0]->metrics.leftSideBearing < 0) {
d1271 2
a1272 2
    box->y1 = -FONTMAXBOUNDS(pFont,ascent);
    box->y2 = FONTMAXBOUNDS(pFont,descent);
a1274 2


d1285 22
a1306 21
	ascent = max(pFont->info.fontAscent, pFont->info.maxbounds.ascent);
	descent = max(pFont->info.fontDescent, pFont->info.maxbounds.descent);
	left = pFont->info.maxbounds.leftSideBearing;
	if (count > 0) {
	    right = (count - 1) * pFont->info.maxbounds.characterWidth;
	}
	right += pFont->info.maxbounds.rightSideBearing;
	BB->x1 =
	    max(pDrawable->x + x - left,
		RegionExtents(&((WindowPtr) pDrawable)->winSize)->x1);
	BB->y1 =
	    max(pDrawable->y + y - ascent,
		RegionExtents(&((WindowPtr) pDrawable)->winSize)->y1);
	BB->x2 =
	    min(pDrawable->x + x + right,
		RegionExtents(&((WindowPtr) pDrawable)->winSize)->x2);
	BB->y2 =
	    min(pDrawable->y + y + descent,
		RegionExtents(&((WindowPtr) pDrawable)->winSize)->y2);
    } else {
    	ShadowTextExtent(pFont, count, chars, wide ? (FONTLASTROW(pFont) == 0)
d1308 12
a1319 12
	BB->x1 =
	    max(pDrawable->x + x + BB->x1,
		RegionExtents(&((WindowPtr) pDrawable)->winSize)->x1);
	BB->y1 =
	    max(pDrawable->y + y + BB->y1,
		RegionExtents(&((WindowPtr) pDrawable)->winSize)->y1);
	BB->x2 =
	    min(pDrawable->x + x + BB->x2,
		RegionExtents(&((WindowPtr) pDrawable)->winSize)->x2);
	BB->y2 =
	    min(pDrawable->y + y + BB->y2,
		RegionExtents(&((WindowPtr) pDrawable)->winSize)->y2);
d1324 3
a1326 8
ShadowPolyText8(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x, 
    int 	y,
    int 	count,
    char	*chars 
){
d1330 1
a1330 1
    
d1333 1
a1333 1
    if(IS_VISIBLE(pDraw)) {
d1335 1
a1335 1
       
d1337 4
a1340 4
        if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
d1343 6
a1348 6
    
    width = (*pGC->ops->PolyText8)(pDraw, pGC, x, y, count, chars);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
d1355 3
a1357 8
ShadowPolyText16(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x,
    int		y,
    int 	count,
    unsigned short *chars 
){
d1364 3
a1366 3
    if(IS_VISIBLE(pDraw)) {
        ShadowFontToBox(&box, pDraw, pGC, x, y, count, (char*)chars, 1);
       
d1368 4
a1371 4
        if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
d1375 1
a1375 1
    width = (*pGC->ops->PolyText16)(pDraw, pGC, x, y, count, chars);
d1377 2
a1378 2
    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
d1386 3
a1388 8
ShadowImageText8(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x, 
    int		y,
    int 	count,
    char	*chars 
){
d1391 1
d1394 5
a1398 2
    if(IS_VISIBLE(pDraw) && count) {
	int top, bot, Min, Max;
d1400 11
a1410 2
	top = max(FONTMAXBOUNDS(pGC->font, ascent), FONTASCENT(pGC->font));
	bot = max(FONTMAXBOUNDS(pGC->font, descent), FONTDESCENT(pGC->font));
d1412 7
a1418 18
	Min = count * FONTMINBOUNDS(pGC->font, characterWidth);
	if(Min > 0) Min = 0;
	Max = count * FONTMAXBOUNDS(pGC->font, characterWidth);	
	if(Max < 0) Max = 0;

	/* ugh */
	box.x1 = pDraw->x + x + Min +
		FONTMINBOUNDS(pGC->font, leftSideBearing);
	box.x2 = pDraw->x + x + Max + 
		FONTMAXBOUNDS(pGC->font, rightSideBearing);

	box.y1 = pDraw->y + y - top;
	box.y2 = pDraw->y + y + bot;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box)) {
            if(pPriv->preRefresh) 
               (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
a1421 2
    
    (*pGC->ops->ImageText8)(pDraw, pGC, x, y, count, chars);
d1423 5
a1427 3
    if(boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
d1430 1
d1432 3
a1434 8
ShadowImageText16(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x,
    int		y,
    int 	count,
    unsigned short *chars 
){
d1437 1
d1440 30
a1469 2
    if(IS_VISIBLE(pDraw) && count) {
	int top, bot, Min, Max;
d1471 2
a1472 2
	top = max(FONTMAXBOUNDS(pGC->font, ascent), FONTASCENT(pGC->font));
	bot = max(FONTMAXBOUNDS(pGC->font, descent), FONTDESCENT(pGC->font));
a1473 27
	Min = count * FONTMINBOUNDS(pGC->font, characterWidth);
	if(Min > 0) Min = 0;
	Max = count * FONTMAXBOUNDS(pGC->font, characterWidth);	
	if(Max < 0) Max = 0;

	/* ugh */
	box.x1 = pDraw->x + x + Min +
		FONTMINBOUNDS(pGC->font, leftSideBearing);
	box.x2 = pDraw->x + x + Max + 
		FONTMAXBOUNDS(pGC->font, rightSideBearing);

	box.y1 = pDraw->y + y - top;
	box.y2 = pDraw->y + y + bot;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
    }
    
    (*pGC->ops->ImageText16)(pDraw, pGC, x, y, count, chars);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);   
    
a1476 1

d1478 6
a1483 8
ShadowImageGlyphBlt(
    DrawablePtr pDraw,
    GCPtr pGC,
    int x, int y,
    unsigned int nglyphInit,
    CharInfoPtr *ppciInit,
    pointer pglyphBase 
){
d1486 1
d1489 1
a1489 1
    if(IS_VISIBLE(pDraw) && nglyphInit) {
d1492 4
a1495 1
	int top, bot, width = 0;
d1497 20
a1516 2
	top = max(FONTMAXBOUNDS(pGC->font, ascent), FONTASCENT(pGC->font));
	bot = max(FONTMAXBOUNDS(pGC->font, descent), FONTDESCENT(pGC->font));
d1518 8
a1525 27
	box.x1 = ppci[0]->metrics.leftSideBearing;
	if(box.x1 > 0) box.x1 = 0;
	box.x2 = ppci[nglyph - 1]->metrics.rightSideBearing - 
		ppci[nglyph - 1]->metrics.characterWidth;
	if(box.x2 < 0) box.x2 = 0;

	box.x2 += pDraw->x + x;
	box.x1 += pDraw->x + x;
	   
	while(nglyph--) {
	    width += (*ppci)->metrics.characterWidth;
	    ppci++;
	}

	if(width > 0) 
	   box.x2 += width;
	else 
	   box.x1 += width;

	box.y1 = pDraw->y + y - top;
	box.y2 = pDraw->y + y + bot;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
d1529 2
a1530 2
    (*pGC->ops->ImageGlyphBlt)(pDraw, pGC, x, y, nglyphInit, 
					ppciInit, pglyphBase);
d1532 2
a1533 2
    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
d1539 6
a1544 8
ShadowPolyGlyphBlt(
    DrawablePtr pDraw,
    GCPtr pGC,
    int x, int y,
    unsigned int nglyphInit,
    CharInfoPtr *ppciInit,
    pointer pglyphBase 
){
d1550 1
a1550 1
    if(IS_VISIBLE(pDraw) && nglyphInit) {
d1554 17
a1570 29
	/* ugh */
	box.x1 = pDraw->x + x + ppci[0]->metrics.leftSideBearing;
	box.x2 = pDraw->x + x + ppci[nglyph - 1]->metrics.rightSideBearing;

	if(nglyph > 1) {
	    int width = 0;

	    while(--nglyph) { 
		width += (*ppci)->metrics.characterWidth;
		ppci++;
	    }
	
	    if(width > 0) box.x2 += width;
	    else box.x1 += width;
	}

	box.y1 = pDraw->y + y - FONTMAXBOUNDS(pGC->font, ascent);
	box.y2 = pDraw->y + y + FONTMAXBOUNDS(pGC->font, descent);

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
    }
    
    (*pGC->ops->PolyGlyphBlt)(pDraw, pGC, x, y, nglyphInit, 
				ppciInit, pglyphBase);
d1572 16
a1587 2
    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
d1593 4
a1596 6
ShadowPushPixels(
    GCPtr	pGC,
    PixmapPtr	pBitMap,
    DrawablePtr pDraw,
    int	dx, int dy, int xOrg, int yOrg 
){
d1599 1
a1599 1
    
d1602 3
a1604 3
    if(IS_VISIBLE(pDraw)) {
	box.x1 = xOrg;
	box.y1 = yOrg;
d1606 3
a1608 3
        if(!pGC->miTranslate) {
           box.x1 += pDraw->x;          
           box.y1 += pDraw->y;          
d1611 2
a1612 2
	box.x2 = box.x1 + dx;
	box.y2 = box.y1 + dy;
d1614 5
a1618 5
	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
d1622 1
a1622 1
    (*pGC->ops->PushPixels)(pGC, pBitMap, pDraw, dx, dy, xOrg, yOrg);
d1624 2
a1625 2
    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
a1629 1

d1631 9
a1639 9
    ShadowFillSpans, ShadowSetSpans, 
    ShadowPutImage, ShadowCopyArea, 
    ShadowCopyPlane, ShadowPolyPoint, 
    ShadowPolylines, ShadowPolySegment, 
    ShadowPolyRectangle, ShadowPolyArc, 
    ShadowFillPolygon, ShadowPolyFillRect, 
    ShadowPolyFillArc, ShadowPolyText8, 
    ShadowPolyText16, ShadowImageText8, 
    ShadowImageText16, ShadowImageGlyphBlt, 
a1641 1

@


1.8
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a38 9
static Bool ShadowModifyPixmapHeader(
    PixmapPtr pPixmap,
    int width,
    int height,
    int depth,
    int bitsPerPixel,
    int devKind,
    pointer pPixData
);
a182 1
    pScreen->ModifyPixmapHeader = ShadowModifyPixmapHeader;
a302 43
static Bool
ShadowModifyPixmapHeader(
    PixmapPtr pPixmap,
    int width,
    int height,
    int depth,
    int bitsPerPixel,
    int devKind,
    pointer pPixData
)
{
    ScreenPtr pScreen;
    ScrnInfoPtr pScrn;
    ShadowScreenPtr pPriv;
    Bool retval;
    PixmapPtr pScreenPix;

    if (!pPixmap)
	return FALSE;

    pScreen = pPixmap->drawable.pScreen;
    pScrn = xf86Screens[pScreen->myNum];

    pScreenPix = (*pScreen->GetScreenPixmap)(pScreen);
    
    if (pPixmap == pScreenPix && !pScrn->vtSema)
	pScreenPix->devPrivate = pScrn->pixmapPrivate;
    
    pPriv = GET_SCREEN_PRIVATE(pScreen);

    pScreen->ModifyPixmapHeader = pPriv->ModifyPixmapHeader;
    retval = (*pScreen->ModifyPixmapHeader)(pPixmap,
	width, height, depth, bitsPerPixel, devKind, pPixData);
    pScreen->ModifyPixmapHeader = ShadowModifyPixmapHeader;

    if (pPixmap == pScreenPix && !pScrn->vtSema)
    {
	pScrn->pixmapPrivate = pScreenPix->devPrivate;
	pScreenPix->devPrivate.ptr = 0;
    }
    return retval;
}

a1679 1
    {NULL}		/* devPrivate */
@


1.7
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a29 1
#ifdef RENDER
a30 1
#endif
a51 1
#ifdef RENDER
a65 1
#endif /* RENDER */
a75 1
#ifdef RENDER
a76 1
#endif /* RENDER */
d87 2
d90 2
a91 4
static int ShadowScreenKeyIndex;
static DevPrivateKey ShadowScreenKey = &ShadowScreenKeyIndex;
static int ShadowGCKeyIndex;
static DevPrivateKey ShadowGCKey = &ShadowGCKeyIndex;
a160 1
#ifdef RENDER
a161 1
#endif /* RENDER */
d165 1
a165 1
    if(!dixRequestPrivate(ShadowGCKey, sizeof(ShadowGCRec)))
d168 4
a171 1
    if(!(pPriv = (ShadowScreenPtr)xalloc(sizeof(ShadowScreenRec))))
a196 1
#ifdef RENDER
a200 1
#endif /* RENDER */
d219 1
d222 5
a226 1
    if((*pPriv->EnterVT)(index, flags)) {
d237 1
d242 1
d244 2
a255 1
#ifdef RENDER
a256 1
#endif /* RENDER */
a265 1
#ifdef RENDER
a268 1
#endif /* RENDER */
d270 1
a270 1
    xfree((pointer)pPriv);
d287 2
a288 2
        REGION_NULL(pWin->drawable.pScreen, &rgnDst);
	REGION_COPY(pWin->drawable.pScreen, &rgnDst, prgn);
d290 1
a290 1
        REGION_TRANSLATE(pWin->drawable.pScreen, &rgnDst,
d293 2
a294 2
        REGION_INTERSECT(pScreen, &rgnDst, &pWin->borderClip, &rgnDst);
        if ((num = REGION_NUM_RECTS(&rgnDst))) {
d296 1
a296 1
                (*pPriv->preRefresh)(pPriv->pScrn, num, REGION_RECTS(&rgnDst));
d298 1
a298 1
            REGION_UNINIT(pWin->drawable.pScreen, &rgnDst);
d308 2
a309 2
            (*pPriv->postRefresh)(pPriv->pScrn, num, REGION_RECTS(&rgnDst));
        REGION_UNINIT(pWin->drawable.pScreen, &rgnDst);
a355 1
#ifdef RENDER
a407 1
#endif /* RENDER */
d1025 1
a1025 1
	    pBoxInit = (BoxPtr)xalloc(nRects * 4 * sizeof(BoxRec));
d1076 1
a1076 1
                xfree(pBoxInit);
d1088 1
a1088 1
       xfree(pBoxInit);
d1368 2
a1369 2
	    max(pDrawable->x + x - left, (REGION_EXTENTS(pGC->pScreen,
		&((WindowPtr) pDrawable)->winSize))->x1);
d1372 1
a1372 2
	    (REGION_EXTENTS(pGC->pScreen,
             &((WindowPtr) pDrawable)->winSize))->y1);
d1375 1
a1375 2
	    (REGION_EXTENTS(pGC->pScreen,
             &((WindowPtr) pDrawable)->winSize))->x2);
d1378 1
a1378 2
	    (REGION_EXTENTS(pGC->pScreen,
             &((WindowPtr) pDrawable)->winSize))->y2);
d1383 2
a1384 2
	    max(pDrawable->x + x + BB->x1, (REGION_EXTENTS(pGC->pScreen,
		&((WindowPtr) pDrawable)->winSize))->x1);
d1387 1
a1387 2
	    (REGION_EXTENTS(pGC->pScreen,
             &((WindowPtr) pDrawable)->winSize))->y1);
d1390 1
a1390 2
	    (REGION_EXTENTS(pGC->pScreen,
	     &((WindowPtr) pDrawable)->winSize))->x2);
d1393 1
a1393 2
	    (REGION_EXTENTS(pGC->pScreen, 
	     &((WindowPtr) pDrawable)->winSize))->y2);
@


1.6
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a33 3
#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))

d102 1
a102 1
    (ShadowGCPtr)dixLookupPrivate(&(pGC)->devPrivates, ShadowGCKey);
a118 1
    GCFuncs *oldFuncs = pGC->funcs;\
d121 1
a434 1
    Bool ret;
d437 1
d1364 2
a1365 2
	ascent = MAX(pFont->info.fontAscent, pFont->info.maxbounds.ascent);
	descent = MAX(pFont->info.fontDescent, pFont->info.maxbounds.descent);
d1372 1
a1372 1
	    MAX(pDrawable->x + x - left, (REGION_EXTENTS(pGC->pScreen,
d1375 1
a1375 1
	    MAX(pDrawable->y + y - ascent,
d1379 1
a1379 1
	    MIN(pDrawable->x + x + right,
d1383 1
a1383 1
	    MIN(pDrawable->y + y + descent,
d1390 1
a1390 1
	    MAX(pDrawable->x + x + BB->x1, (REGION_EXTENTS(pGC->pScreen,
d1393 1
a1393 1
	    MAX(pDrawable->y + y + BB->y1,
d1397 1
a1397 1
	    MIN(pDrawable->x + x + BB->x2,
d1401 1
a1401 1
	    MIN(pDrawable->y + y + BB->y2,
@


1.5
log
@more gcc2 breakage found by sparc
@
text
@d97 4
a100 2
static DevPrivateKey ShadowScreenKey = &ShadowScreenKey;
static DevPrivateKey ShadowGCKey = &ShadowGCKey;
a121 2
    ShadowScreenPtr pPriv;\
    ShadowGCPtr pGCPriv;\
d123 2
a124 2
    pGCPriv = GET_GC_PRIVATE(pGC);\
    pPriv = GET_SCREEN_PRIVATE(pGC->pScreen);\
a437 2
    ShadowScreenPtr pPriv;
    ShadowGCPtr pGCPriv;
d439 2
a440 2
    pPriv = GET_SCREEN_PRIVATE(pScreen);
    pGCPriv = GET_GC_PRIVATE(pGC);
@


1.4
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d120 2
a121 2
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pGC->pScreen); \
    ShadowGCPtr pGCPriv = GET_GC_PRIVATE(pGC);\
d123 2
d438 2
a439 2
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScreen);
    ShadowGCPtr pGCPriv = GET_GC_PRIVATE(pGC);
d441 2
@


1.3
log
@more gcc2 fixes courtesy sparc
@
text
@a119 1
    GCFuncs *oldFuncs = pGC->funcs;\
d122 1
a434 1
    Bool ret;
d438 1
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d120 1
a122 1
    GCFuncs *oldFuncs = pGC->funcs;\
d435 1
a438 1
    Bool ret;
@


1.1
log
@Initial revision
@
text
@a37 12
static void ShadowRestoreAreas (    
    PixmapPtr pPixmap,
    RegionPtr prgn,
    int       xorg,
    int       yorg,
    WindowPtr pWin 
);
static void ShadowPaintWindow (
    WindowPtr pWin,
    RegionPtr prgn,
    int what 
);
a79 2
  PaintWindowBackgroundProcPtr		PaintWindowBackground;
  PaintWindowBorderProcPtr		PaintWindowBorder;
a81 1
  BackingStoreRestoreAreasProcPtr	RestoreAreas;  
d97 2
a98 3
static int ShadowScreenIndex = -1;
static int ShadowGCIndex = -1;
static unsigned long ShadowGeneration = 0;
d101 1
a101 1
	(ShadowScreenPtr)((pScreen)->devPrivates[ShadowScreenIndex].ptr)
d103 1
a103 1
	(ShadowGCPtr)((pGC)->devPrivates[ShadowGCIndex].ptr)
d174 1
a174 8
    if (ShadowGeneration != serverGeneration) {
	if(((ShadowScreenIndex = AllocateScreenPrivateIndex ()) < 0) ||
	   ((ShadowGCIndex = AllocateGCPrivateIndex()) < 0))
	    return FALSE;
	ShadowGeneration = serverGeneration;
    }

    if(!AllocateGCPrivate(pScreen, ShadowGCIndex, sizeof(ShadowGCRec)))
d180 1
a180 1
    pScreen->devPrivates[ShadowScreenIndex].ptr = (pointer)pPriv;  
a187 2
    pPriv->PaintWindowBackground = pScreen->PaintWindowBackground;
    pPriv->PaintWindowBorder = pScreen->PaintWindowBorder;
a189 1
    pPriv->RestoreAreas = pScreen->BackingStoreFuncs.RestoreAreas;
a195 2
    pScreen->PaintWindowBackground = ShadowPaintWindow;
    pScreen->PaintWindowBorder = ShadowPaintWindow;
a197 1
    pScreen->BackingStoreFuncs.RestoreAreas = ShadowRestoreAreas;
a259 2
    pScreen->PaintWindowBackground = pPriv->PaintWindowBackground;
    pScreen->PaintWindowBorder = pPriv->PaintWindowBorder;
a261 1
    pScreen->BackingStoreFuncs.RestoreAreas = pPriv->RestoreAreas;
a277 56

static void
ShadowRestoreAreas (    
    PixmapPtr pPixmap,
    RegionPtr prgn,
    int       xorg,
    int       yorg,
    WindowPtr pWin 
){
    ScreenPtr pScreen = pWin->drawable.pScreen;
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScreen);
    int num = 0;

    if(pPriv->vtSema && (num = REGION_NUM_RECTS(prgn)))
        if(pPriv->preRefresh)
            (*pPriv->preRefresh)(pPriv->pScrn, num, REGION_RECTS(prgn));

    pScreen->BackingStoreFuncs.RestoreAreas = pPriv->RestoreAreas;
    (*pScreen->BackingStoreFuncs.RestoreAreas) (
                pPixmap, prgn, xorg, yorg, pWin);
    pScreen->BackingStoreFuncs.RestoreAreas = ShadowRestoreAreas;

    if(num && pPriv->postRefresh)
	(*pPriv->postRefresh)(pPriv->pScrn, num, REGION_RECTS(prgn));
}


static void
ShadowPaintWindow(
  WindowPtr pWin,
  RegionPtr prgn,
  int what 
){
    ScreenPtr pScreen = pWin->drawable.pScreen;
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScreen);
    int num = 0;

    if(pPriv->vtSema && (num = REGION_NUM_RECTS(prgn)))
        if(pPriv->preRefresh)
            (*pPriv->preRefresh)(pPriv->pScrn, num, REGION_RECTS(prgn));

    if(what == PW_BACKGROUND) {
	pScreen->PaintWindowBackground = pPriv->PaintWindowBackground;
	(*pScreen->PaintWindowBackground) (pWin, prgn, what);
	pScreen->PaintWindowBackground = ShadowPaintWindow;
    } else {
	pScreen->PaintWindowBorder = pPriv->PaintWindowBorder;
	(*pScreen->PaintWindowBorder) (pWin, prgn, what);
	pScreen->PaintWindowBorder = ShadowPaintWindow;
    }

    if(num && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, num, REGION_RECTS(prgn));    
}


d1030 1
a1030 1
	    pBoxInit = (BoxPtr)ALLOCATE_LOCAL(nRects * 4 * sizeof(BoxRec));
d1081 1
a1081 1
                DEALLOCATE_LOCAL(pBoxInit);
d1093 1
a1093 1
       DEALLOCATE_LOCAL(pBoxInit);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
