head	1.15;
access;
symbols
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.2
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2016.05.29.12.02.38;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	s0SI41sEunLdyFfd;

1.14
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	Te1daavkBLskZ8gc;

1.13
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	cVXoV5PxI8YrEaVA;

1.12
date	2014.05.02.19.27.49;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.21.20.10.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.13.19.54.46;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.15.26.22;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.01.23.31.01;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.01.22;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.01.22;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright © 2006 Keith Packard
 * Copyright © 2011 Aaron Plattner
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#else
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#endif

#include <stddef.h>
#include <string.h>
#include <stdio.h>

#include "xf86.h"
#include "xf86DDC.h"
#include "windowstr.h"
#include "xf86Crtc.h"
#include "xf86Modes.h"
#include "xf86RandR12.h"
#include "X11/extensions/render.h"
#include "X11/extensions/dpmsconst.h"
#include "X11/Xatom.h"

static void
xf86RotateCrtcRedisplay(xf86CrtcPtr crtc, RegionPtr region)
{
    ScrnInfoPtr scrn = crtc->scrn;
    ScreenPtr screen = scrn->pScreen;
    WindowPtr root = screen->root;
    PixmapPtr dst_pixmap = crtc->rotatedPixmap;
    PictFormatPtr format = PictureWindowFormat(screen->root);
    int error;
    PicturePtr src, dst;
    int n = RegionNumRects(region);
    BoxPtr b = RegionRects(region);
    XID include_inferiors = IncludeInferiors;

    if (crtc->driverIsPerformingTransform)
        return;

    src = CreatePicture(None,
                        &root->drawable,
                        format,
                        CPSubwindowMode,
                        &include_inferiors, serverClient, &error);
    if (!src)
        return;

    dst = CreatePicture(None,
                        &dst_pixmap->drawable,
                        format, 0L, NULL, serverClient, &error);
    if (!dst)
        return;

    error = SetPictureTransform(src, &crtc->crtc_to_framebuffer);
    if (error)
        return;
    if (crtc->transform_in_use && crtc->filter)
        SetPicturePictFilter(src, crtc->filter, crtc->params, crtc->nparams);

    if (crtc->shadowClear) {
        CompositePicture(PictOpSrc,
                         src, NULL, dst,
                         0, 0, 0, 0, 0, 0,
                         crtc->mode.HDisplay, crtc->mode.VDisplay);
        crtc->shadowClear = FALSE;
    }
    else {
        while (n--) {
            BoxRec dst_box;

            dst_box = *b;
            dst_box.x1 -= crtc->filter_width >> 1;
            dst_box.x2 += crtc->filter_width >> 1;
            dst_box.y1 -= crtc->filter_height >> 1;
            dst_box.y2 += crtc->filter_height >> 1;
            pixman_f_transform_bounds(&crtc->f_framebuffer_to_crtc, &dst_box);
            CompositePicture(PictOpSrc,
                             src, NULL, dst,
                             dst_box.x1, dst_box.y1, 0, 0, dst_box.x1,
                             dst_box.y1, dst_box.x2 - dst_box.x1,
                             dst_box.y2 - dst_box.y1);
            b++;
        }
    }
    FreePicture(src, None);
    FreePicture(dst, None);
}

static void
xf86CrtcDamageShadow(xf86CrtcPtr crtc)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    BoxRec damage_box;
    RegionRec damage_region;
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);

    damage_box.x1 = 0;
    damage_box.x2 = crtc->mode.HDisplay;
    damage_box.y1 = 0;
    damage_box.y2 = crtc->mode.VDisplay;
    if (!pixman_transform_bounds(&crtc->crtc_to_framebuffer, &damage_box)) {
        damage_box.x1 = 0;
        damage_box.y1 = 0;
        damage_box.x2 = pScreen->width;
        damage_box.y2 = pScreen->height;
    }
    if (damage_box.x1 < 0)
        damage_box.x1 = 0;
    if (damage_box.y1 < 0)
        damage_box.y1 = 0;
    if (damage_box.x2 > pScreen->width)
        damage_box.x2 = pScreen->width;
    if (damage_box.y2 > pScreen->height)
        damage_box.y2 = pScreen->height;
    RegionInit(&damage_region, &damage_box, 1);
    DamageDamageRegion(&(*pScreen->GetScreenPixmap) (pScreen)->drawable,
                       &damage_region);
    RegionUninit(&damage_region);
    crtc->shadowClear = TRUE;
}

static void
xf86RotatePrepare(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int c;

    for (c = 0; c < xf86_config->num_crtc; c++) {
        xf86CrtcPtr crtc = xf86_config->crtc[c];

        if (crtc->rotatedData && !crtc->rotatedPixmap) {
            crtc->rotatedPixmap = crtc->funcs->shadow_create(crtc,
                                                             crtc->rotatedData,
                                                             crtc->mode.
                                                             HDisplay,
                                                             crtc->mode.
                                                             VDisplay);
            if (!xf86_config->rotation_damage_registered) {
                /* Hook damage to screen pixmap */
                DamageRegister(&pScreen->root->drawable,
                               xf86_config->rotation_damage);
                xf86_config->rotation_damage_registered = TRUE;
                EnableLimitedSchedulingLatency();
            }

            xf86CrtcDamageShadow(crtc);
        }
    }
}

static Bool
xf86RotateRedisplay(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    DamagePtr damage = xf86_config->rotation_damage;
    RegionPtr region;

    if (!damage)
        return FALSE;
    xf86RotatePrepare(pScreen);
    region = DamageRegion(damage);
    if (RegionNotEmpty(region)) {
        int c;
        SourceValidateProcPtr SourceValidate;

        /*
         * SourceValidate is used by the software cursor code
         * to pull the cursor off of the screen when reading
         * bits from the frame buffer. Bypassing this function
         * leaves the software cursor in place
         */
        SourceValidate = pScreen->SourceValidate;
        pScreen->SourceValidate = NULL;

        for (c = 0; c < xf86_config->num_crtc; c++) {
            xf86CrtcPtr crtc = xf86_config->crtc[c];

            if (crtc->transform_in_use && crtc->enabled) {
                RegionRec crtc_damage;

                /* compute portion of damage that overlaps crtc */
                RegionInit(&crtc_damage, &crtc->bounds, 1);
                RegionIntersect(&crtc_damage, &crtc_damage, region);

                /* update damaged region */
                if (RegionNotEmpty(&crtc_damage))
                    xf86RotateCrtcRedisplay(crtc, &crtc_damage);

                RegionUninit(&crtc_damage);
            }
        }
        pScreen->SourceValidate = SourceValidate;
        DamageEmpty(damage);
    }
    return TRUE;
}

static void
xf86RotateBlockHandler(ScreenPtr pScreen,
                       void *pTimeout, void *pReadmask)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);

    /* Unwrap before redisplay in case the software
     * cursor layer wants to add its block handler to the
     * chain
     */
    pScreen->BlockHandler = xf86_config->BlockHandler;

    xf86RotateRedisplay(pScreen);

    (*pScreen->BlockHandler) (pScreen, pTimeout, pReadmask);

    /* Re-wrap if we still need this hook */
    if (xf86_config->rotation_damage != NULL) {
        xf86_config->BlockHandler = pScreen->BlockHandler;
        pScreen->BlockHandler = xf86RotateBlockHandler;
    } else
        xf86_config->BlockHandler = NULL;
}

void
xf86RotateDestroy(xf86CrtcPtr crtc)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int c;

    /* Free memory from rotation */
    if (crtc->rotatedPixmap || crtc->rotatedData) {
        crtc->funcs->shadow_destroy(crtc, crtc->rotatedPixmap,
                                    crtc->rotatedData);
        crtc->rotatedPixmap = NULL;
        crtc->rotatedData = NULL;
    }

    for (c = 0; c < xf86_config->num_crtc; c++)
        if (xf86_config->crtc[c]->rotatedData)
            return;

    /*
     * Clean up damage structures when no crtcs are rotated
     */
    if (xf86_config->rotation_damage) {
        /* Free damage structure */
        if (xf86_config->rotation_damage_registered) {
            xf86_config->rotation_damage_registered = FALSE;
            DisableLimitedSchedulingLatency();
        }
        DamageDestroy(xf86_config->rotation_damage);
        xf86_config->rotation_damage = NULL;
    }
}

void
xf86RotateFreeShadow(ScrnInfoPtr pScrn)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
    int c;

    for (c = 0; c < config->num_crtc; c++) {
        xf86CrtcPtr crtc = config->crtc[c];

        if (crtc->rotatedPixmap || crtc->rotatedData) {
            crtc->funcs->shadow_destroy(crtc, crtc->rotatedPixmap,
                                        crtc->rotatedData);
            crtc->rotatedPixmap = NULL;
            crtc->rotatedData = NULL;
        }
    }
}

void
xf86RotateCloseScreen(ScreenPtr screen)
{
    ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int c;

    /* This has already been destroyed when the root window was destroyed */
    xf86_config->rotation_damage = NULL;
    for (c = 0; c < xf86_config->num_crtc; c++)
        xf86RotateDestroy(xf86_config->crtc[c]);
}

static Bool
xf86CrtcFitsScreen(xf86CrtcPtr crtc, struct pict_f_transform *crtc_to_fb)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    BoxRec b;

    /* When called before PreInit, the driver is
     * presumably doing load detect
     */
    if (pScrn->is_gpu) {
	ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
	if (pScreen->current_master)
	    pScrn = xf86ScreenToScrn(pScreen->current_master);
    }

    if (pScrn->virtualX == 0 || pScrn->virtualY == 0)
        return TRUE;

    b.x1 = 0;
    b.y1 = 0;
    b.x2 = crtc->mode.HDisplay;
    b.y2 = crtc->mode.VDisplay;
    if (crtc_to_fb)
        pixman_f_transform_bounds(crtc_to_fb, &b);
    else {
        b.x1 += crtc->x;
        b.y1 += crtc->y;
        b.x2 += crtc->x;
        b.y2 += crtc->y;
    }

    return (0 <= b.x1 && b.x2 <= pScrn->virtualX &&
            0 <= b.y1 && b.y2 <= pScrn->virtualY);
}

Bool
xf86CrtcRotate(xf86CrtcPtr crtc)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    PictTransform crtc_to_fb;
    struct pict_f_transform f_crtc_to_fb, f_fb_to_crtc;
    xFixed *new_params = NULL;
    int new_nparams = 0;
    PictFilterPtr new_filter = NULL;
    int new_width = 0;
    int new_height = 0;
    RRTransformPtr transform = NULL;
    Bool damage = FALSE;

    if (pScreen->isGPU)
        return TRUE;
    if (crtc->transformPresent)
        transform = &crtc->transform;

    if (!RRTransformCompute(crtc->x, crtc->y,
                            crtc->mode.HDisplay, crtc->mode.VDisplay,
                            crtc->rotation,
                            transform,
                            &crtc_to_fb,
                            &f_crtc_to_fb,
                            &f_fb_to_crtc) &&
        xf86CrtcFitsScreen(crtc, &f_crtc_to_fb)) {
        /*
         * If the untranslated transformation is the identity,
         * disable the shadow buffer
         */
        xf86RotateDestroy(crtc);
        crtc->transform_in_use = FALSE;
        free(new_params);
        new_params = NULL;
        new_nparams = 0;
        new_filter = NULL;
        new_width = 0;
        new_height = 0;
    }
    else {
        if (crtc->driverIsPerformingTransform) {
            xf86RotateDestroy(crtc);
        }
        else {
            /*
             * these are the size of the shadow pixmap, which
             * matches the mode, not the pre-rotated copy in the
             * frame buffer
             */
            int width = crtc->mode.HDisplay;
            int height = crtc->mode.VDisplay;
            void *shadowData = crtc->rotatedData;
            PixmapPtr shadow = crtc->rotatedPixmap;
            int old_width = shadow ? shadow->drawable.width : 0;
            int old_height = shadow ? shadow->drawable.height : 0;

            /* Allocate memory for rotation */
            if (old_width != width || old_height != height) {
                if (shadow || shadowData) {
                    crtc->funcs->shadow_destroy(crtc, shadow, shadowData);
                    crtc->rotatedPixmap = NULL;
                    crtc->rotatedData = NULL;
                }
                shadowData = crtc->funcs->shadow_allocate(crtc, width, height);
                if (!shadowData)
                    goto bail1;
                crtc->rotatedData = shadowData;
                /* shadow will be damaged in xf86RotatePrepare */
            }
            else {
                /* mark shadowed area as damaged so it will be repainted */
                damage = TRUE;
            }

            if (!xf86_config->rotation_damage) {
                /* Create damage structure */
                xf86_config->rotation_damage = DamageCreate(NULL, NULL,
                                                            DamageReportNone,
                                                            TRUE, pScreen,
                                                            pScreen);
                if (!xf86_config->rotation_damage)
                    goto bail2;

                /* Wrap block handler */
                if (!xf86_config->BlockHandler) {
                    xf86_config->BlockHandler = pScreen->BlockHandler;
                    pScreen->BlockHandler = xf86RotateBlockHandler;
                }
            }

            if (0) {
 bail2:
                if (shadow || shadowData) {
                    crtc->funcs->shadow_destroy(crtc, shadow, shadowData);
                    crtc->rotatedPixmap = NULL;
                    crtc->rotatedData = NULL;
                }
 bail1:
                if (old_width && old_height)
                    crtc->rotatedPixmap =
                        crtc->funcs->shadow_create(crtc, NULL, old_width,
                                                   old_height);
                return FALSE;
            }
        }
#ifdef RANDR_12_INTERFACE
        if (transform) {
            if (transform->nparams) {
                new_params = malloc(transform->nparams * sizeof(xFixed));
                if (new_params) {
                    memcpy(new_params, transform->params,
                           transform->nparams * sizeof(xFixed));
                    new_nparams = transform->nparams;
                    new_filter = transform->filter;
                }
            }
            else
                new_filter = transform->filter;
            if (new_filter) {
                new_width = new_filter->width;
                new_height = new_filter->height;
            }
        }
#endif
        crtc->transform_in_use = TRUE;
    }
    crtc->crtc_to_framebuffer = crtc_to_fb;
    crtc->f_crtc_to_framebuffer = f_crtc_to_fb;
    crtc->f_framebuffer_to_crtc = f_fb_to_crtc;
    free(crtc->params);
    crtc->params = new_params;
    crtc->nparams = new_nparams;
    crtc->filter = new_filter;
    crtc->filter_width = new_width;
    crtc->filter_height = new_height;
    crtc->bounds.x1 = 0;
    crtc->bounds.x2 = crtc->mode.HDisplay;
    crtc->bounds.y1 = 0;
    crtc->bounds.y2 = crtc->mode.VDisplay;
    pixman_f_transform_bounds(&f_crtc_to_fb, &crtc->bounds);

    if (damage)
        xf86CrtcDamageShadow(crtc);

    /* All done */
    return TRUE;
}
@


1.14
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a45 6
/* borrowed from composite extension, move to Render and publish? */

#define F(x)	IntToxFixed(x)

#define toF(x)	((float) (x) / 65536.0f)

d363 2
@


1.13
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a37 1
#include "fb.h"
d236 6
d243 1
a243 1
    pScreen->BlockHandler = xf86_config->BlockHandler;
d245 7
a251 3
    /* cannot avoid re-wrapping until all wrapping is audited */
    xf86_config->BlockHandler = pScreen->BlockHandler;
    pScreen->BlockHandler = xf86RotateBlockHandler;
d312 2
@


1.12
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d232 1
a232 1
                       pointer pTimeout, pointer pReadmask)
a235 1
    Bool rotation_active;
d237 1
a237 1
    rotation_active = xf86RotateRedisplay(pScreen);
a248 1
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
a267 3
        DrawablePtr screenDrawable = NULL;
        if (pScreen && pScreen->root)
            screenDrawable = &pScreen->root->drawable;
@


1.11
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a274 3
            if (screenDrawable)
                DamageUnregister(screenDrawable,
                        xf86_config->rotation_damage);
d278 1
a278 2
        if (screenDrawable)
            DamageDestroy(xf86_config->rotation_damage);
@


1.10
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a48 22
static VisualPtr
compGetWindowVisual(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    VisualID vid = wVisual(pWin);
    int i;

    for (i = 0; i < pScreen->numVisuals; i++)
        if (pScreen->visuals[i].vid == vid)
            return &pScreen->visuals[i];
    return 0;
}

static PictFormatPtr
compWindowFormat(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    return PictureMatchVisual(pScreen, pWin->drawable.depth,
                              compGetWindowVisual(pWin));
}

d60 1
a60 1
    PictFormatPtr format = compWindowFormat(screen->root);
d125 1
a125 1
    ScreenPtr pScreen = pScrn->pScreen;
d155 1
a155 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d185 1
a185 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d231 1
a231 1
xf86RotateBlockHandler(int screenNum, pointer blockData,
d234 1
a234 2
    ScreenPtr pScreen = screenInfo.screens[screenNum];
    ScrnInfoPtr pScrn = xf86Screens[screenNum];
d240 1
a240 1
    (*pScreen->BlockHandler) (screenNum, blockData, pTimeout, pReadmask);
d250 1
a250 1
    ScreenPtr pScreen = pScrn->pScreen;
d308 1
a308 1
    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d325 6
d356 1
a356 3

    /* if this is called during ScreenInit() we don't have pScrn->pScreen yet */
    ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
@


1.9
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d3 1
d50 1
a50 1
compGetWindowVisual (WindowPtr pWin)
d52 3
a54 3
    ScreenPtr	    pScreen = pWin->drawable.pScreen;
    VisualID	    vid = wVisual (pWin);
    int		    i;
d57 2
a58 2
	if (pScreen->visuals[i].vid == vid)
	    return &pScreen->visuals[i];
d63 1
a63 1
compWindowFormat (WindowPtr pWin)
d65 4
a68 4
    ScreenPtr	pScreen = pWin->drawable.pScreen;
    
    return PictureMatchVisual (pScreen, pWin->drawable.depth,
			       compGetWindowVisual (pWin));
d76 1
a76 1
xf86RotateCrtcRedisplay (xf86CrtcPtr crtc, RegionPtr region)
d78 19
a96 18
    ScrnInfoPtr		scrn = crtc->scrn;
    ScreenPtr		screen = scrn->pScreen;
    WindowPtr		root = screen->root;
    PixmapPtr		dst_pixmap = crtc->rotatedPixmap;
    PictFormatPtr	format = compWindowFormat (screen->root);
    int			error;
    PicturePtr		src, dst;
    int			n = RegionNumRects(region);
    BoxPtr		b = RegionRects(region);
    XID			include_inferiors = IncludeInferiors;
    
    src = CreatePicture (None,
			 &root->drawable,
			 format,
			 CPSubwindowMode,
			 &include_inferiors,
			 serverClient,
			 &error);
d98 1
a98 1
	return;
d100 3
a102 7
    dst = CreatePicture (None,
			 &dst_pixmap->drawable,
			 format,
			 0L,
			 NULL,
			 serverClient,
			 &error);
d104 1
a104 1
	return;
d106 1
a106 1
    error = SetPictureTransform (src, &crtc->crtc_to_framebuffer);
d108 1
a108 1
	return;
d110 1
a110 2
	SetPicturePictFilter (src, crtc->filter,
			      crtc->params, crtc->nparams);
d112 6
a117 27
    if (crtc->shadowClear)
    {
	CompositePicture (PictOpSrc,
			  src, NULL, dst,
			  0, 0, 0, 0, 0, 0,
			  crtc->mode.HDisplay, crtc->mode.VDisplay);
	crtc->shadowClear = FALSE;
    }
    else
    {
	while (n--)
	{
	    BoxRec	dst_box;

	    dst_box = *b;
	    dst_box.x1 -= crtc->filter_width >> 1;
	    dst_box.x2 += crtc->filter_width >> 1;
	    dst_box.y1 -= crtc->filter_height >> 1;
	    dst_box.y2 += crtc->filter_height >> 1;
	    pixman_f_transform_bounds (&crtc->f_framebuffer_to_crtc, &dst_box);
	    CompositePicture (PictOpSrc,
			      src, NULL, dst,
			      dst_box.x1, dst_box.y1, 0, 0, dst_box.x1, dst_box.y1,
			      dst_box.x2 - dst_box.x1,
			      dst_box.y2 - dst_box.y1);
	    b++;
	}
d119 20
a138 2
    FreePicture (src, None);
    FreePicture (dst, None);
d142 1
a142 1
xf86CrtcDamageShadow (xf86CrtcPtr crtc)
d144 4
a147 4
    ScrnInfoPtr	pScrn = crtc->scrn;
    BoxRec	damage_box;
    RegionRec   damage_region;
    ScreenPtr	pScreen = pScrn->pScreen;
d153 14
a166 11
    if (!pixman_transform_bounds (&crtc->crtc_to_framebuffer, &damage_box))
    {
	damage_box.x1 = 0;
	damage_box.y1 = 0;
	damage_box.x2 = pScreen->width;
	damage_box.y2 = pScreen->height;
    }
    if (damage_box.x1 < 0) damage_box.x1 = 0;
    if (damage_box.y1 < 0) damage_box.y1 = 0;
    if (damage_box.x2 > pScreen->width) damage_box.x2 = pScreen->width;
    if (damage_box.y2 > pScreen->height) damage_box.y2 = pScreen->height;
d168 2
a169 2
    DamageDamageRegion (&(*pScreen->GetScreenPixmap)(pScreen)->drawable,
			&damage_region);
d175 1
a175 1
xf86RotatePrepare (ScreenPtr pScreen)
d177 6
a182 3
    ScrnInfoPtr		pScrn = xf86Screens[pScreen->myNum];
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int			c;
d184 17
a200 21
    for (c = 0; c < xf86_config->num_crtc; c++)
    {
	xf86CrtcPtr crtc = xf86_config->crtc[c];
	
	if (crtc->rotatedData && !crtc->rotatedPixmap)
	{
	    crtc->rotatedPixmap = crtc->funcs->shadow_create (crtc,
							     crtc->rotatedData,
							     crtc->mode.HDisplay,
							     crtc->mode.VDisplay);
	    if (!xf86_config->rotation_damage_registered)
	    {
		/* Hook damage to screen pixmap */
		DamageRegister (&(*pScreen->GetScreenPixmap)(pScreen)->drawable,
				xf86_config->rotation_damage);
		xf86_config->rotation_damage_registered = TRUE;
		EnableLimitedSchedulingLatency();
	    }
	    
	    xf86CrtcDamageShadow (crtc);
	}
d207 4
a210 4
    ScrnInfoPtr		pScrn = xf86Screens[pScreen->myNum];
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    DamagePtr		damage = xf86_config->rotation_damage;
    RegionPtr		region;
d213 2
a214 2
	return FALSE;
    xf86RotatePrepare (pScreen);
d216 32
a247 35
    if (RegionNotEmpty(region))
    {
	int			c;
	SourceValidateProcPtr	SourceValidate;

	/*
	 * SourceValidate is used by the software cursor code
	 * to pull the cursor off of the screen when reading
	 * bits from the frame buffer. Bypassing this function
	 * leaves the software cursor in place
	 */
	SourceValidate = pScreen->SourceValidate;
	pScreen->SourceValidate = NULL;

	for (c = 0; c < xf86_config->num_crtc; c++)
	{
	    xf86CrtcPtr	    crtc = xf86_config->crtc[c];

	    if (crtc->transform_in_use && crtc->enabled)
	    {
		RegionRec   crtc_damage;

		/* compute portion of damage that overlaps crtc */
		RegionInit(&crtc_damage, &crtc->bounds, 1);
		RegionIntersect(&crtc_damage, &crtc_damage, region);
		
		/* update damaged region */
		if (RegionNotEmpty(&crtc_damage))
    		    xf86RotateCrtcRedisplay (crtc, &crtc_damage);
		
		RegionUninit(&crtc_damage);
	    }
	}
	pScreen->SourceValidate = SourceValidate;
	DamageEmpty(damage);
d254 1
a254 1
		       pointer pTimeout, pointer pReadmask)
d256 4
a259 4
    ScreenPtr		pScreen = screenInfo.screens[screenNum];
    ScrnInfoPtr		pScrn = xf86Screens[screenNum];
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    Bool		rotation_active;
d270 1
a270 1
xf86RotateDestroy (xf86CrtcPtr crtc)
d272 5
a276 5
    ScrnInfoPtr		pScrn = crtc->scrn;
    ScreenPtr		pScreen = pScrn->pScreen;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int			c;
    
d278 5
a282 5
    if (crtc->rotatedPixmap || crtc->rotatedData)
    {
	crtc->funcs->shadow_destroy (crtc, crtc->rotatedPixmap, crtc->rotatedData);
	crtc->rotatedPixmap = NULL;
	crtc->rotatedData = NULL;
d286 2
a287 2
	if (xf86_config->crtc[c]->transform_in_use)
	    return;
d292 15
a306 12
    if (xf86_config->rotation_damage)
    {
	/* Free damage structure */
	if (xf86_config->rotation_damage_registered)
	{
	    DamageUnregister (&(*pScreen->GetScreenPixmap)(pScreen)->drawable,
			      xf86_config->rotation_damage);
	    xf86_config->rotation_damage_registered = FALSE;
	    DisableLimitedSchedulingLatency();
	}
	DamageDestroy (xf86_config->rotation_damage);
	xf86_config->rotation_damage = NULL;
d316 2
a317 2
   for (c = 0; c < config->num_crtc; c++) {
       xf86CrtcPtr crtc = config->crtc[c];
d319 7
a325 7
       if (crtc->rotatedPixmap || crtc->rotatedData) {
	   crtc->funcs->shadow_destroy(crtc, crtc->rotatedPixmap,
				crtc->rotatedData);
	   crtc->rotatedPixmap = NULL;
	   crtc->rotatedData = NULL;
       }
   }
d329 1
a329 1
xf86RotateCloseScreen (ScreenPtr screen)
d331 3
a333 3
    ScrnInfoPtr		scrn = xf86Screens[screen->myNum];
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int			c;
d336 1
a336 1
	xf86RotateDestroy (xf86_config->crtc[c]);
d340 1
a340 1
xf86CrtcFitsScreen (xf86CrtcPtr crtc, struct pict_f_transform *crtc_to_fb)
d342 2
a343 2
    ScrnInfoPtr		pScrn = crtc->scrn;
    BoxRec		b;
d349 1
a349 1
	return TRUE;
d356 1
a356 1
	pixman_f_transform_bounds (crtc_to_fb, &b);
d358 4
a361 4
	b.x1 += crtc->x;
	b.y1 += crtc->y;
	b.x2 += crtc->x;
	b.y2 += crtc->y;
d365 1
a365 1
	    0 <= b.y1 && b.y2 <= pScrn->virtualY);
d369 1
a369 1
xf86CrtcRotate (xf86CrtcPtr crtc)
d371 3
a373 2
    ScrnInfoPtr		pScrn = crtc->scrn;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
d375 2
a376 2
    ScreenPtr		pScreen = screenInfo.screens[pScrn->scrnIndex];
    PictTransform	crtc_to_fb;
d378 7
a384 7
    xFixed		*new_params = NULL;
    int			new_nparams = 0;
    PictFilterPtr	new_filter = NULL;
    int			new_width = 0;
    int			new_height = 0;
    RRTransformPtr	transform = NULL;
    Bool		damage = FALSE;
d387 1
a387 1
	transform = &crtc->transform;
d389 87
a475 73
    if (!RRTransformCompute (crtc->x, crtc->y,
			     crtc->mode.HDisplay, crtc->mode.VDisplay,
			     crtc->rotation,
			     transform,

			     &crtc_to_fb,
			     &f_crtc_to_fb,
			     &f_fb_to_crtc) &&
	xf86CrtcFitsScreen (crtc, &f_crtc_to_fb))
    {
	/*
	 * If the untranslated transformation is the identity,
	 * disable the shadow buffer
	 */
	xf86RotateDestroy (crtc);
	crtc->transform_in_use = FALSE;
	free(new_params);
	new_params = NULL;
	new_nparams = 0;
	new_filter = NULL;
	new_width = 0;
	new_height = 0;
    }
    else
    {
	/*
	 * these are the size of the shadow pixmap, which
	 * matches the mode, not the pre-rotated copy in the
	 * frame buffer
	 */
	int	    width = crtc->mode.HDisplay;
	int	    height = crtc->mode.VDisplay;
	void	    *shadowData = crtc->rotatedData;
	PixmapPtr   shadow = crtc->rotatedPixmap;
	int	    old_width = shadow ? shadow->drawable.width : 0;
	int	    old_height = shadow ? shadow->drawable.height : 0;

	/* Allocate memory for rotation */
	if (old_width != width || old_height != height)
	{
	    if (shadow || shadowData)
	    {
		crtc->funcs->shadow_destroy (crtc, shadow, shadowData);
		crtc->rotatedPixmap = NULL;
		crtc->rotatedData = NULL;
	    }
	    shadowData = crtc->funcs->shadow_allocate (crtc, width, height);
	    if (!shadowData)
		goto bail1;
	    crtc->rotatedData = shadowData;
	    /* shadow will be damaged in xf86RotatePrepare */
	}
	else
	{
	    /* mark shadowed area as damaged so it will be repainted */
	    damage = TRUE;
	}

	if (!xf86_config->rotation_damage)
	{
	    /* Create damage structure */
	    xf86_config->rotation_damage = DamageCreate (NULL, NULL,
						DamageReportNone,
						TRUE, pScreen, pScreen);
	    if (!xf86_config->rotation_damage)
		goto bail2;
	    
	    /* Wrap block handler */
	    if (!xf86_config->BlockHandler) {
		xf86_config->BlockHandler = pScreen->BlockHandler;
		pScreen->BlockHandler = xf86RotateBlockHandler;
	    }
	}
d477 17
a493 18
	if (transform)
	{
	    if (transform->nparams) {
		new_params = malloc(transform->nparams * sizeof (xFixed));
		if (new_params) {
		    memcpy (new_params, transform->params,
			    transform->nparams * sizeof (xFixed));
		    new_nparams = transform->nparams;
		    new_filter = transform->filter;
		}
	    } else
		new_filter = transform->filter;
	    if (new_filter)
	    {
		new_width = new_filter->width;
		new_height = new_filter->height;
	    }
	}
d495 1
a495 19

	if (0)
	{
    bail2:
	    if (shadow || shadowData)
	    {
		crtc->funcs->shadow_destroy (crtc, shadow, shadowData);
		crtc->rotatedPixmap = NULL;
		crtc->rotatedData = NULL;
	    }
    bail1:
	    if (old_width && old_height)
		crtc->rotatedPixmap = crtc->funcs->shadow_create (crtc,
								  NULL,
								  old_width,
								  old_height);
	    return FALSE;
	}
	crtc->transform_in_use = TRUE;
d510 1
a510 1
    pixman_f_transform_bounds (&f_crtc_to_fb, &crtc->bounds);
d513 1
a513 1
        xf86CrtcDamageShadow (crtc);
@


1.8
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d171 1
a171 1
    DamageRegionAppend (&(*pScreen->GetScreenPixmap)(pScreen)->drawable,
@


1.7
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d79 1
a79 1
    WindowPtr		root = WindowTable[screen->myNum];
d81 1
a81 1
    PictFormatPtr	format = compWindowFormat (WindowTable[screen->myNum]);
d84 2
a85 2
    int			n = REGION_NUM_RECTS(region);
    BoxPtr		b = REGION_RECTS(region);
d170 1
a170 1
    REGION_INIT (pScreen, &damage_region, &damage_box, 1);
d173 1
a173 1
    REGION_UNINIT (pScreen, &damage_region);
d220 1
a220 1
    if (REGION_NOTEMPTY(pScreen, region)) 
d243 2
a244 2
		REGION_INIT(pScreen, &crtc_damage, &crtc->bounds, 1);
		REGION_INTERSECT (pScreen, &crtc_damage, &crtc_damage, region);
d247 1
a247 1
		if (REGION_NOTEMPTY(pScreen, &crtc_damage))
d250 1
a250 1
		REGION_UNINIT (pScreen, &crtc_damage);
d408 1
a408 2
	if (new_params)
	    xfree (new_params);
d469 1
a469 1
		new_params = xalloc (transform->nparams * sizeof (xFixed));
d508 1
a508 2
    if (crtc->params)
	xfree (crtc->params);
@


1.6
log
@Add a configure test for newer proto headers and use it to enable
building xserver 1.6 with those headers. ok oga@@.
@
text
@d43 1
a43 6
#ifdef HAVE_X11_EXTENSIONS_DPMSCONST_H
#include <X11/extensions/dpmsconst.h>
#else
#define DPMS_SERVER
#include "X11/extensions/dpms.h"
#endif
d271 3
a273 7
    if (rotation_active) {
	/* Re-wrap if rotation is still happening */
	xf86_config->BlockHandler = pScreen->BlockHandler;
	pScreen->BlockHandler = xf86RotateBlockHandler;
    } else {
	xf86_config->BlockHandler = NULL;
    }
d314 1
a314 1
_X_EXPORT void
d332 1
a332 1
_X_EXPORT void
d372 1
a372 1
_X_EXPORT Bool
@


1.5
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d43 3
d48 1
@


1.4
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a72 167
static void
PictureTransformIdentity (PictTransformPtr matrix)
{
    int	i;
    memset (matrix, '\0', sizeof (PictTransform));
    for (i = 0; i < 3; i++)
	matrix->matrix[i][i] = F(1);
}

static Bool
PictureTransformMultiply (PictTransformPtr dst, PictTransformPtr l, PictTransformPtr r)
{
    PictTransform   d;
    int		    dx, dy;
    int		    o;

    for (dy = 0; dy < 3; dy++)
	for (dx = 0; dx < 3; dx++)
	{
	    xFixed_48_16    v;
	    xFixed_32_32    partial;
	    v = 0;
	    for (o = 0; o < 3; o++)
	    {
		partial = (xFixed_32_32) l->matrix[dy][o] * (xFixed_32_32) r->matrix[o][dx];
		v += partial >> 16;
	    }
	    if (v > MAX_FIXED_48_16 || v < MIN_FIXED_48_16)
		return FALSE;
	    d.matrix[dy][dx] = (xFixed) v;
	}
    *dst = d;
    return TRUE;
}

static void
PictureTransformInitScale (PictTransformPtr t, xFixed sx, xFixed sy)
{
    memset (t, '\0', sizeof (PictTransform));
    t->matrix[0][0] = sx;
    t->matrix[1][1] = sy;
    t->matrix[2][2] = F (1);
}

static xFixed
fixed_inverse (xFixed x)
{
    return (xFixed) ((((xFixed_48_16) F(1)) * F(1)) / x);
}

static Bool
PictureTransformScale (PictTransformPtr forward,
		       PictTransformPtr reverse,
		       xFixed sx, xFixed sy)
{
    PictTransform   t;
    
    PictureTransformInitScale (&t, sx, sy);
    if (!PictureTransformMultiply (forward, &t, forward))
	return FALSE;
    PictureTransformInitScale (&t, fixed_inverse (sx), fixed_inverse (sy));
    if (!PictureTransformMultiply (reverse, reverse, &t))
	return FALSE;
    return TRUE;
}

static void
PictureTransformInitRotate (PictTransformPtr t, xFixed c, xFixed s)
{
    memset (t, '\0', sizeof (PictTransform));
    t->matrix[0][0] = c;
    t->matrix[0][1] = -s;
    t->matrix[1][0] = s;
    t->matrix[1][1] = c;
    t->matrix[2][2] = F (1);
}

static Bool
PictureTransformRotate (PictTransformPtr forward,
			PictTransformPtr reverse,
			xFixed c, xFixed s)
{
    PictTransform   t;
    PictureTransformInitRotate (&t, c, s);
    if (!PictureTransformMultiply (forward, &t, forward))
	return FALSE;
    
    PictureTransformInitRotate (&t, c, -s);
    if (!PictureTransformMultiply (reverse, reverse, &t))
	return FALSE;
    return TRUE;
}

static void
PictureTransformInitTranslate (PictTransformPtr t, xFixed tx, xFixed ty)
{
    memset (t, '\0', sizeof (PictTransform));
    t->matrix[0][0] = F (1);
    t->matrix[0][2] = tx;
    t->matrix[1][1] = F (1);
    t->matrix[1][2] = ty;
    t->matrix[2][2] = F (1);
}

static Bool
PictureTransformTranslate (PictTransformPtr forward,
			   PictTransformPtr reverse,
			   xFixed tx, xFixed ty)
{
    PictTransform   t;
    PictureTransformInitTranslate (&t, tx, ty);
    if (!PictureTransformMultiply (forward, &t, forward))
	return FALSE;
    
    PictureTransformInitTranslate (&t, -tx, -ty);
    if (!PictureTransformMultiply (reverse, reverse, &t))
	return FALSE;
    return TRUE;
}

static void
PictureTransformBounds (BoxPtr b, PictTransformPtr matrix)
{
    PictVector	v[4];
    int		i;
    int		x1, y1, x2, y2;

    v[0].vector[0] = F (b->x1);    v[0].vector[1] = F (b->y1);	v[0].vector[2] = F(1);
    v[1].vector[0] = F (b->x2);    v[1].vector[1] = F (b->y1);	v[1].vector[2] = F(1);
    v[2].vector[0] = F (b->x2);    v[2].vector[1] = F (b->y2);	v[2].vector[2] = F(1);
    v[3].vector[0] = F (b->x1);    v[3].vector[1] = F (b->y2);	v[3].vector[2] = F(1);
    for (i = 0; i < 4; i++)
    {
	PictureTransformPoint (matrix, &v[i]);
	x1 = xFixedToInt (v[i].vector[0]);
	y1 = xFixedToInt (v[i].vector[1]);
	x2 = xFixedToInt (xFixedCeil (v[i].vector[0]));
	y2 = xFixedToInt (xFixedCeil (v[i].vector[1]));
	if (i == 0)
	{
	    b->x1 = x1; b->y1 = y1;
	    b->x2 = x2; b->y2 = y2;
	}
	else
	{
	    if (x1 < b->x1) b->x1 = x1;
	    if (y1 < b->y1) b->y1 = y1;
	    if (x2 > b->x2) b->x2 = x2;
	    if (y2 > b->y2) b->y2 = y2;
	}
    }
}

static Bool
PictureTransformIsIdentity(PictTransform *t)
{
    return ((t->matrix[0][0] == t->matrix[1][1]) &&
            (t->matrix[0][0] == t->matrix[2][2]) &&
            (t->matrix[0][0] != 0) &&
            (t->matrix[0][1] == 0) &&
            (t->matrix[0][2] == 0) &&
            (t->matrix[1][0] == 0) &&
            (t->matrix[1][2] == 0) &&
            (t->matrix[2][0] == 0) &&
            (t->matrix[2][1] == 0));
}

a75 29
PictureTransformErrorF (PictTransform *t)
{
    ErrorF ("{ { %f %f %f } { %f %f %f } { %f %f %f } }",
	    toF(t->matrix[0][0]), toF(t->matrix[0][1]), toF(t->matrix[0][2]), 
	    toF(t->matrix[1][0]), toF(t->matrix[1][1]), toF(t->matrix[1][2]), 
	    toF(t->matrix[2][0]), toF(t->matrix[2][1]), toF(t->matrix[2][2]));
}

static Bool
PictureTransformIsInverse (char *where, PictTransform *a, PictTransform *b)
{
    PictTransform   t;

    PictureTransformMultiply (&t, a, b);
    if (!PictureTransformIsIdentity (&t))
    {
	ErrorF ("%s: ", where);
	PictureTransformErrorF (a);
	ErrorF (" * ");
	PictureTransformErrorF (b);
	ErrorF (" = ");
	PictureTransformErrorF (a);
	ErrorF ("\n");
	return FALSE;
    }
    return TRUE;
}

static void
d112 3
d116 1
a116 1
    while (n--)
a117 4
	BoxRec	dst_box;

	dst_box = *b;
	PictureTransformBounds (&dst_box, &crtc->framebuffer_to_crtc);
d120 23
a142 4
			  dst_box.x1, dst_box.y1, 0, 0, dst_box.x1, dst_box.y1,
			  dst_box.x2 - dst_box.x1,
			  dst_box.y2 - dst_box.y1);
	b++;
d156 15
a170 4
    damage_box.x1 = crtc->x;
    damage_box.x2 = crtc->x + xf86ModeWidth (&crtc->mode, crtc->rotation);
    damage_box.y1 = crtc->y;
    damage_box.y2 = crtc->y + xf86ModeHeight (&crtc->mode, crtc->rotation);
d172 1
a172 1
    DamageDamageRegion (&(*pScreen->GetScreenPixmap)(pScreen)->drawable,
d175 1
d201 1
d239 1
a239 1
	    if (crtc->rotation != RR_Rotate_0 && crtc->enabled)
d267 1
d269 1
d272 1
a272 2
    if (xf86RotateRedisplay(pScreen))
    {
d276 2
d281 1
a281 1
static void
d298 1
a298 2
	if (xf86_config->crtc[c]->rotatedPixmap ||
	    xf86_config->crtc[c]->rotatedData)
d312 1
d320 18
d348 29
d378 1
a378 1
xf86CrtcRotate (xf86CrtcPtr crtc, DisplayModePtr mode, Rotation rotation)
d384 22
a405 74
    PictTransform	crtc_to_fb, fb_to_crtc;
    
    PictureTransformIdentity (&crtc_to_fb);
    PictureTransformIdentity (&fb_to_crtc);
    PictureTransformIsInverse ("identity", &crtc_to_fb, &fb_to_crtc);
    if (rotation != RR_Rotate_0)
    {
	xFixed	rot_cos, rot_sin, rot_dx, rot_dy;
	xFixed	scale_x, scale_y, scale_dx, scale_dy;
	int	mode_w = crtc->mode.HDisplay;
	int	mode_h = crtc->mode.VDisplay;
	
	/* rotation */
	switch (rotation & 0xf) {
	default:
	case RR_Rotate_0:
	    rot_cos = F ( 1);	    rot_sin = F ( 0);
	    rot_dx  = F ( 0);	    rot_dy  = F ( 0);
	    break;
	case RR_Rotate_90:
	    rot_cos = F ( 0);	    rot_sin = F ( 1);
	    rot_dx =  F ( mode_h);  rot_dy  = F (0);
	    break;
	case RR_Rotate_180:
	    rot_cos = F (-1);	    rot_sin = F ( 0);
	    rot_dx  = F (mode_w);   rot_dy  = F ( mode_h);
	    break;
	case RR_Rotate_270:
	    rot_cos = F ( 0);	    rot_sin = F (-1);
	    rot_dx  = F ( 0);	    rot_dy  = F ( mode_w);
	    break;
	}
	
	PictureTransformRotate (&crtc_to_fb, &fb_to_crtc, rot_cos, rot_sin);
	PictureTransformIsInverse ("rotate", &crtc_to_fb, &fb_to_crtc);

	PictureTransformTranslate (&crtc_to_fb, &fb_to_crtc, rot_dx, rot_dy);
	PictureTransformIsInverse ("rotate translate", &crtc_to_fb, &fb_to_crtc);

	/* reflection */
	scale_x = F (1);
	scale_dx = 0;
	scale_y = F (1);
	scale_dy = 0;
	if (rotation & RR_Reflect_X)
	{
	    scale_x = F(-1);
	    if (rotation & (RR_Rotate_0|RR_Rotate_180))
		scale_dx = F(mode_w);
	    else
		scale_dx = F(mode_h);
	}
	if (rotation & RR_Reflect_Y)
	{
	    scale_y = F(-1);
	    if (rotation & (RR_Rotate_0|RR_Rotate_180))
		scale_dy = F(mode_h);
	    else
		scale_dy = F(mode_w);
	}
	
	PictureTransformScale (&crtc_to_fb, &fb_to_crtc, scale_x, scale_y);
	PictureTransformIsInverse ("scale", &crtc_to_fb, &fb_to_crtc);

	PictureTransformTranslate (&crtc_to_fb, &fb_to_crtc, scale_dx, scale_dy);
	PictureTransformIsInverse ("scale translate", &crtc_to_fb, &fb_to_crtc);

    }
    
    /*
     * If the untranslated transformation is the identity,
     * disable the shadow buffer
     */
    if (PictureTransformIsIdentity (&crtc_to_fb))
d407 5
d413 7
a419 5
	PictureTransformInitTranslate (&crtc->crtc_to_framebuffer, 
				       F (-crtc->x), F (-crtc->y));
	PictureTransformInitTranslate (&crtc->framebuffer_to_crtc,
				       F ( crtc->x), F ( crtc->y));
	xf86RotateDestroy (crtc);
d423 1
a423 8
	int width, height, old_width, old_height;
	void *shadowData;
	PixmapPtr shadow;

	PictureTransformTranslate (&crtc_to_fb, &fb_to_crtc, F(crtc->x), F(crtc->y));
	PictureTransformIsInverse ("offset", &crtc_to_fb, &fb_to_crtc);

	/* 
d428 7
a434 7
	width = mode->HDisplay;
	height = mode->VDisplay;
	shadowData = crtc->rotatedData;
	shadow = crtc->rotatedPixmap;
	old_width = shadow ? shadow->drawable.width : 0;
	old_height = shadow ? shadow->drawable.height : 0;
	
d453 1
a453 1
	    xf86CrtcDamageShadow (crtc);
d455 1
a455 1
	
d466 23
a488 2
	    xf86_config->BlockHandler = pScreen->BlockHandler;
	    pScreen->BlockHandler = xf86RotateBlockHandler;
d490 2
a509 7
	crtc->crtc_to_framebuffer = crtc_to_fb;
	crtc->framebuffer_to_crtc = fb_to_crtc;
	crtc->bounds.x1 = 0;
	crtc->bounds.x2 = crtc->mode.HDisplay;
	crtc->bounds.y1 = 0;
	crtc->bounds.y2 = crtc->mode.VDisplay;
	PictureTransformBounds (&crtc->bounds, &crtc_to_fb);
d511 19
a529 1
    
@


1.3
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d497 2
a498 1
    ScreenPtr		pScreen = pScrn->pScreen;
d586 1
d589 1
a589 1
	
@


1.2
log
@more gcc2 fixes; ok mathieu@@
@
text
@d585 1
a585 1
	PictureTransformTranslate (&crtc_to_fb, &fb_to_crtc, crtc->x, crtc->y);
@


1.1
log
@Initial revision
@
text
@d582 3
d593 6
a598 6
	int	    width = mode->HDisplay;
	int	    height = mode->VDisplay;
	void	    *shadowData = crtc->rotatedData;
	PixmapPtr   shadow = crtc->rotatedPixmap;
	int	    old_width = shadow ? shadow->drawable.width : 0;
	int	    old_height = shadow ? shadow->drawable.height : 0;
@


1.1.1.1
log
@xserver 1.4
@
text
@@
