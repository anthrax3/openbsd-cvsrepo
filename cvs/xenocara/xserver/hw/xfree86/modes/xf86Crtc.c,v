head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.2
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.2
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.2
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2016.08.09.18.59.53;	author matthieu;	state Exp;
branches;
next	1.18;
commitid	6HLO5qdN5N4nPDjW;

1.18
date	2016.05.29.12.02.38;	author matthieu;	state Exp;
branches;
next	1.17;
commitid	s0SI41sEunLdyFfd;

1.17
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	Te1daavkBLskZ8gc;

1.16
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	cVXoV5PxI8YrEaVA;

1.15
date	2014.05.02.19.27.49;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2013.09.28.15.36.35;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2013.08.24.19.44.41;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.02.16.08.39;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.13.19.54.46;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.31.14.09.44;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.01.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.01.20;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/*
 * Copyright © 2006 Keith Packard
 * Copyright © 2008 Red Hat, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#else
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#endif

#include <stddef.h>
#include <string.h>
#include <stdio.h>

#include "xf86.h"
#include "xf86DDC.h"
#include "xf86Crtc.h"
#include "xf86Modes.h"
#include "xf86Priv.h"
#include "xf86RandR12.h"
#include "X11/extensions/render.h"
#include "X11/extensions/dpmsconst.h"
#include "X11/Xatom.h"
#include "picturestr.h"

#ifdef XV
#include "xf86xv.h"
#endif

#define NO_OUTPUT_DEFAULT_WIDTH 1024
#define NO_OUTPUT_DEFAULT_HEIGHT 768
/*
 * Initialize xf86CrtcConfig structure
 */

int xf86CrtcConfigPrivateIndex = -1;

void
xf86CrtcConfigInit(ScrnInfoPtr scrn, const xf86CrtcConfigFuncsRec * funcs)
{
    xf86CrtcConfigPtr config;

    if (xf86CrtcConfigPrivateIndex == -1)
        xf86CrtcConfigPrivateIndex = xf86AllocateScrnInfoPrivateIndex();
    config = xnfcalloc(1, sizeof(xf86CrtcConfigRec));

    config->funcs = funcs;
    config->compat_output = -1;

    scrn->privates[xf86CrtcConfigPrivateIndex].ptr = config;
}

void
xf86CrtcSetSizeRange(ScrnInfoPtr scrn,
                     int minWidth, int minHeight, int maxWidth, int maxHeight)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);

    config->minWidth = minWidth;
    config->minHeight = minHeight;
    config->maxWidth = maxWidth;
    config->maxHeight = maxHeight;
}

/*
 * Crtc functions
 */
xf86CrtcPtr
xf86CrtcCreate(ScrnInfoPtr scrn, const xf86CrtcFuncsRec * funcs)
{
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CrtcPtr crtc, *crtcs;

    crtc = calloc(sizeof(xf86CrtcRec), 1);
    if (!crtc)
        return NULL;
    crtc->version = XF86_CRTC_VERSION;
    crtc->scrn = scrn;
    crtc->funcs = funcs;
#ifdef RANDR_12_INTERFACE
    crtc->randr_crtc = NULL;
#endif
    crtc->rotation = RR_Rotate_0;
    crtc->desiredRotation = RR_Rotate_0;
    pixman_transform_init_identity(&crtc->crtc_to_framebuffer);
    pixman_f_transform_init_identity(&crtc->f_crtc_to_framebuffer);
    pixman_f_transform_init_identity(&crtc->f_framebuffer_to_crtc);
    crtc->filter = NULL;
    crtc->params = NULL;
    crtc->nparams = 0;
    crtc->filter_width = 0;
    crtc->filter_height = 0;
    crtc->transform_in_use = FALSE;
    crtc->transformPresent = FALSE;
    crtc->desiredTransformPresent = FALSE;
    memset(&crtc->bounds, '\0', sizeof(crtc->bounds));

    /* Preallocate gamma at a sensible size. */
    crtc->gamma_size = 256;
    crtc->gamma_red = xallocarray(crtc->gamma_size, 3 * sizeof(CARD16));
    if (!crtc->gamma_red) {
        free(crtc);
        return NULL;
    }
    crtc->gamma_green = crtc->gamma_red + crtc->gamma_size;
    crtc->gamma_blue = crtc->gamma_green + crtc->gamma_size;

    if (xf86_config->crtc)
        crtcs = reallocarray(xf86_config->crtc,
                             xf86_config->num_crtc + 1, sizeof(xf86CrtcPtr));
    else
        crtcs = xallocarray(xf86_config->num_crtc + 1, sizeof(xf86CrtcPtr));
    if (!crtcs) {
        free(crtc->gamma_red);
        free(crtc);
        return NULL;
    }
    xf86_config->crtc = crtcs;
    xf86_config->crtc[xf86_config->num_crtc++] = crtc;
    return crtc;
}

void
xf86CrtcDestroy(xf86CrtcPtr crtc)
{
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
    int c;

    (*crtc->funcs->destroy) (crtc);
    for (c = 0; c < xf86_config->num_crtc; c++)
        if (xf86_config->crtc[c] == crtc) {
            memmove(&xf86_config->crtc[c],
                    &xf86_config->crtc[c + 1],
                    ((xf86_config->num_crtc - (c + 1)) * sizeof(void *)));
            xf86_config->num_crtc--;
            break;
        }
    free(crtc->params);
    free(crtc->gamma_red);
    free(crtc);
}

/**
 * Return whether any outputs are connected to the specified pipe
 */

Bool
xf86CrtcInUse(xf86CrtcPtr crtc)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int o;

    for (o = 0; o < xf86_config->num_output; o++)
        if (xf86_config->output[o]->crtc == crtc)
            return TRUE;
    return FALSE;
}

void
xf86CrtcSetScreenSubpixelOrder(ScreenPtr pScreen)
{
    int subpixel_order = SubPixelUnknown;
    Bool has_none = FALSE;
    ScrnInfoPtr scrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int icrtc, o;

    for (icrtc = 0; icrtc < xf86_config->num_crtc; icrtc++) {
        xf86CrtcPtr crtc = xf86_config->crtc[icrtc];

        for (o = 0; o < xf86_config->num_output; o++) {
            xf86OutputPtr output = xf86_config->output[o];

            if (output->crtc == crtc) {
                switch (output->subpixel_order) {
                case SubPixelNone:
                    has_none = TRUE;
                    break;
                case SubPixelUnknown:
                    break;
                default:
                    subpixel_order = output->subpixel_order;
                    break;
                }
            }
            if (subpixel_order != SubPixelUnknown)
                break;
        }
        if (subpixel_order != SubPixelUnknown) {
            static const int circle[4] = {
                SubPixelHorizontalRGB,
                SubPixelVerticalRGB,
                SubPixelHorizontalBGR,
                SubPixelVerticalBGR,
            };
            int rotate;
            int sc;

            for (rotate = 0; rotate < 4; rotate++)
                if (crtc->rotation & (1 << rotate))
                    break;
            for (sc = 0; sc < 4; sc++)
                if (circle[sc] == subpixel_order)
                    break;
            sc = (sc + rotate) & 0x3;
            if ((crtc->rotation & RR_Reflect_X) && !(sc & 1))
                sc ^= 2;
            if ((crtc->rotation & RR_Reflect_Y) && (sc & 1))
                sc ^= 2;
            subpixel_order = circle[sc];
            break;
        }
    }
    if (subpixel_order == SubPixelUnknown && has_none)
        subpixel_order = SubPixelNone;
    PictureSetSubpixelOrder(pScreen, subpixel_order);
}

/**
 * Sets the given video mode on the given crtc
 */
Bool
xf86CrtcSetModeTransform(xf86CrtcPtr crtc, DisplayModePtr mode,
                         Rotation rotation, RRTransformPtr transform, int x,
                         int y)
{
    ScrnInfoPtr scrn = crtc->scrn;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int i;
    Bool ret = FALSE;
    Bool didLock = FALSE;
    DisplayModePtr adjusted_mode;
    DisplayModeRec saved_mode;
    int saved_x, saved_y;
    Rotation saved_rotation;
    RRTransformRec saved_transform;
    Bool saved_transform_present;

    crtc->enabled = xf86CrtcInUse(crtc);

    /* We only hit this if someone explicitly sends a "disabled" modeset. */
    if (!crtc->enabled) {
        /* Check everything for stuff that should be off. */
        xf86DisableUnusedFunctions(scrn);
        return TRUE;
    }

    adjusted_mode = xf86DuplicateMode(mode);

    saved_mode = crtc->mode;
    saved_x = crtc->x;
    saved_y = crtc->y;
    saved_rotation = crtc->rotation;
    if (crtc->transformPresent) {
        RRTransformInit(&saved_transform);
        RRTransformCopy(&saved_transform, &crtc->transform);
    }
    saved_transform_present = crtc->transformPresent;

    /* Update crtc values up front so the driver can rely on them for mode
     * setting.
     */
    crtc->mode = *mode;
    crtc->x = x;
    crtc->y = y;
    crtc->rotation = rotation;
    if (transform) {
        RRTransformCopy(&crtc->transform, transform);
        crtc->transformPresent = TRUE;
    }
    else
        crtc->transformPresent = FALSE;

    if (crtc->funcs->set_mode_major) {
        ret = crtc->funcs->set_mode_major(crtc, mode, rotation, x, y);
        goto done;
    }

    didLock = crtc->funcs->lock(crtc);
    /* Pass our mode to the outputs and the CRTC to give them a chance to
     * adjust it according to limitations or output properties, and also
     * a chance to reject the mode entirely.
     */
    for (i = 0; i < xf86_config->num_output; i++) {
        xf86OutputPtr output = xf86_config->output[i];

        if (output->crtc != crtc)
            continue;

        if (!output->funcs->mode_fixup(output, mode, adjusted_mode)) {
            goto done;
        }
    }

    if (!crtc->funcs->mode_fixup(crtc, mode, adjusted_mode)) {
        goto done;
    }

    if (!xf86CrtcRotate(crtc))
        goto done;

    /* Prepare the outputs and CRTCs before setting the mode. */
    for (i = 0; i < xf86_config->num_output; i++) {
        xf86OutputPtr output = xf86_config->output[i];

        if (output->crtc != crtc)
            continue;

        /* Disable the output as the first thing we do. */
        output->funcs->prepare(output);
    }

    crtc->funcs->prepare(crtc);

    /* Set up the DPLL and any output state that needs to adjust or depend
     * on the DPLL.
     */
    crtc->funcs->mode_set(crtc, mode, adjusted_mode, crtc->x, crtc->y);
    for (i = 0; i < xf86_config->num_output; i++) {
        xf86OutputPtr output = xf86_config->output[i];

        if (output->crtc == crtc)
            output->funcs->mode_set(output, mode, adjusted_mode);
    }

    /* Only upload when needed, to avoid unneeded delays. */
    if (!crtc->active && crtc->funcs->gamma_set)
        crtc->funcs->gamma_set(crtc, crtc->gamma_red, crtc->gamma_green,
                               crtc->gamma_blue, crtc->gamma_size);

    /* Now, enable the clocks, plane, pipe, and outputs that we set up. */
    crtc->funcs->commit(crtc);
    for (i = 0; i < xf86_config->num_output; i++) {
        xf86OutputPtr output = xf86_config->output[i];

        if (output->crtc == crtc)
            output->funcs->commit(output);
    }

    ret = TRUE;

 done:
    if (ret) {
        crtc->active = TRUE;
        if (scrn->pScreen)
            xf86CrtcSetScreenSubpixelOrder(scrn->pScreen);
        if (scrn->ModeSet)
            scrn->ModeSet(scrn);

        /* Make sure the HW cursor is hidden if it's supposed to be, in case
         * it was hidden while the CRTC was disabled
         */
        if (!xf86_config->cursor_on)
            xf86_hide_cursors(scrn);
    }
    else {
        crtc->x = saved_x;
        crtc->y = saved_y;
        crtc->rotation = saved_rotation;
        crtc->mode = saved_mode;
        if (saved_transform_present)
            RRTransformCopy(&crtc->transform, &saved_transform);
        crtc->transformPresent = saved_transform_present;
    }

    free((void *) adjusted_mode->name);
    free(adjusted_mode);

    if (didLock)
        crtc->funcs->unlock(crtc);

    return ret;
}

/**
 * Sets the given video mode on the given crtc, but without providing
 * a transform
 */
Bool
xf86CrtcSetMode(xf86CrtcPtr crtc, DisplayModePtr mode, Rotation rotation,
                int x, int y)
{
    return xf86CrtcSetModeTransform(crtc, mode, rotation, NULL, x, y);
}

/**
 * Pans the screen, does not change the mode
 */
void
xf86CrtcSetOrigin(xf86CrtcPtr crtc, int x, int y)
{
    ScrnInfoPtr scrn = crtc->scrn;

    crtc->x = x;
    crtc->y = y;
    if (crtc->funcs->set_origin) {
        if (!xf86CrtcRotate(crtc))
            return;
        crtc->funcs->set_origin(crtc, x, y);
        if (scrn->ModeSet)
            scrn->ModeSet(scrn);
    }
    else
        xf86CrtcSetMode(crtc, &crtc->mode, crtc->rotation, x, y);
}

/*
 * Output functions
 */

extern XF86ConfigPtr xf86configptr;

typedef enum {
    OPTION_PREFERRED_MODE,
    OPTION_ZOOM_MODES,
    OPTION_POSITION,
    OPTION_BELOW,
    OPTION_RIGHT_OF,
    OPTION_ABOVE,
    OPTION_LEFT_OF,
    OPTION_ENABLE,
    OPTION_DISABLE,
    OPTION_MIN_CLOCK,
    OPTION_MAX_CLOCK,
    OPTION_IGNORE,
    OPTION_ROTATE,
    OPTION_PANNING,
    OPTION_PRIMARY,
    OPTION_DEFAULT_MODES,
} OutputOpts;

static OptionInfoRec xf86OutputOptions[] = {
    {OPTION_PREFERRED_MODE, "PreferredMode", OPTV_STRING, {0}, FALSE},
    {OPTION_ZOOM_MODES, "ZoomModes", OPTV_STRING, {0}, FALSE },
    {OPTION_POSITION, "Position", OPTV_STRING, {0}, FALSE},
    {OPTION_BELOW, "Below", OPTV_STRING, {0}, FALSE},
    {OPTION_RIGHT_OF, "RightOf", OPTV_STRING, {0}, FALSE},
    {OPTION_ABOVE, "Above", OPTV_STRING, {0}, FALSE},
    {OPTION_LEFT_OF, "LeftOf", OPTV_STRING, {0}, FALSE},
    {OPTION_ENABLE, "Enable", OPTV_BOOLEAN, {0}, FALSE},
    {OPTION_DISABLE, "Disable", OPTV_BOOLEAN, {0}, FALSE},
    {OPTION_MIN_CLOCK, "MinClock", OPTV_FREQ, {0}, FALSE},
    {OPTION_MAX_CLOCK, "MaxClock", OPTV_FREQ, {0}, FALSE},
    {OPTION_IGNORE, "Ignore", OPTV_BOOLEAN, {0}, FALSE},
    {OPTION_ROTATE, "Rotate", OPTV_STRING, {0}, FALSE},
    {OPTION_PANNING, "Panning", OPTV_STRING, {0}, FALSE},
    {OPTION_PRIMARY, "Primary", OPTV_BOOLEAN, {0}, FALSE},
    {OPTION_DEFAULT_MODES, "DefaultModes", OPTV_BOOLEAN, {0}, FALSE},
    {-1, NULL, OPTV_NONE, {0}, FALSE},
};

enum {
    OPTION_MODEDEBUG,
};

static OptionInfoRec xf86DeviceOptions[] = {
    {OPTION_MODEDEBUG, "ModeDebug", OPTV_BOOLEAN, {0}, FALSE},
    {-1, NULL, OPTV_NONE, {0}, FALSE},
};

static void
xf86OutputSetMonitor(xf86OutputPtr output)
{
    char *option_name;
    const char *monitor;

    if (!output->name)
        return;

    free(output->options);

    output->options = xnfalloc(sizeof(xf86OutputOptions));
    memcpy(output->options, xf86OutputOptions, sizeof(xf86OutputOptions));

    XNFasprintf(&option_name, "monitor-%s", output->name);
    monitor = xf86findOptionValue(output->scrn->options, option_name);
    if (!monitor)
        monitor = output->name;
    else
        xf86MarkOptionUsedByName(output->scrn->options, option_name);
    free(option_name);
    output->conf_monitor = xf86findMonitor(monitor,
                                           xf86configptr->conf_monitor_lst);
    /*
     * Find the monitor section of the screen and use that
     */
    if (!output->conf_monitor && output->use_screen_monitor)
        output->conf_monitor = xf86findMonitor(output->scrn->monitor->id,
                                               xf86configptr->conf_monitor_lst);
    if (output->conf_monitor) {
        xf86DrvMsg(output->scrn->scrnIndex, X_INFO,
                   "Output %s using monitor section %s\n",
                   output->name, output->conf_monitor->mon_identifier);
        xf86ProcessOptions(output->scrn->scrnIndex,
                           output->conf_monitor->mon_option_lst,
                           output->options);
    }
    else
        xf86DrvMsg(output->scrn->scrnIndex, X_INFO,
                   "Output %s has no monitor section\n", output->name);
}

static Bool
xf86OutputEnabled(xf86OutputPtr output, Bool strict)
{
    Bool enable, disable;

    /* check to see if this output was enabled in the config file */
    if (xf86GetOptValBool(output->options, OPTION_ENABLE, &enable) && enable) {
        xf86DrvMsg(output->scrn->scrnIndex, X_INFO,
                   "Output %s enabled by config file\n", output->name);
        return TRUE;
    }
    /* or if this output was disabled in the config file */
    if (xf86GetOptValBool(output->options, OPTION_DISABLE, &disable) && disable) {
        xf86DrvMsg(output->scrn->scrnIndex, X_INFO,
                   "Output %s disabled by config file\n", output->name);
        return FALSE;
    }

    /* If not, try to only light up the ones we know are connected */
    if (strict) {
        enable = output->status == XF86OutputStatusConnected;
    }
    /* But if that fails, try to light up even outputs we're unsure of */
    else {
        enable = output->status != XF86OutputStatusDisconnected;
    }

    xf86DrvMsg(output->scrn->scrnIndex, X_INFO,
               "Output %s %sconnected\n", output->name, enable ? "" : "dis");
    return enable;
}

static Bool
xf86OutputIgnored(xf86OutputPtr output)
{
    return xf86ReturnOptValBool(output->options, OPTION_IGNORE, FALSE);
}

static const char *direction[4] = {
    "normal",
    "left",
    "inverted",
    "right"
};

static Rotation
xf86OutputInitialRotation(xf86OutputPtr output)
{
    const char *rotate_name = xf86GetOptValString(output->options,
                                                  OPTION_ROTATE);
    int i;

    if (!rotate_name) {
        if (output->initial_rotation)
            return output->initial_rotation;
        return RR_Rotate_0;
    }

    for (i = 0; i < 4; i++)
        if (xf86nameCompare(direction[i], rotate_name) == 0)
            return 1 << i;
    return RR_Rotate_0;
}

xf86OutputPtr
xf86OutputCreate(ScrnInfoPtr scrn,
                 const xf86OutputFuncsRec * funcs, const char *name)
{
    xf86OutputPtr output, *outputs;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int len;
    Bool primary;

    if (name)
        len = strlen(name) + 1;
    else
        len = 0;

    output = calloc(sizeof(xf86OutputRec) + len, 1);
    if (!output)
        return NULL;
    output->scrn = scrn;
    output->funcs = funcs;
    if (name) {
        output->name = (char *) (output + 1);
        strcpy(output->name, name);
    }
    output->subpixel_order = SubPixelUnknown;
    /*
     * Use the old per-screen monitor section for the first output
     */
    output->use_screen_monitor = (xf86_config->num_output == 0);
#ifdef RANDR_12_INTERFACE
    output->randr_output = NULL;
#endif
    if (name) {
        xf86OutputSetMonitor(output);
        if (xf86OutputIgnored(output)) {
            free(output);
            return FALSE;
        }
    }

    if (xf86_config->output)
        outputs = reallocarray(xf86_config->output,
                               xf86_config->num_output + 1,
                               sizeof(xf86OutputPtr));
    else
        outputs = xallocarray(xf86_config->num_output + 1,
                              sizeof(xf86OutputPtr));
    if (!outputs) {
        free(output);
        return NULL;
    }

    xf86_config->output = outputs;

    if (xf86GetOptValBool(output->options, OPTION_PRIMARY, &primary) && primary) {
        memmove(xf86_config->output + 1, xf86_config->output,
                xf86_config->num_output * sizeof(xf86OutputPtr));
        xf86_config->output[0] = output;
    }
    else {
        xf86_config->output[xf86_config->num_output] = output;
    }

    xf86_config->num_output++;

    return output;
}

Bool
xf86OutputRename(xf86OutputPtr output, const char *name)
{
    char *newname = strdup(name);

    if (!newname)
        return FALSE;           /* so sorry... */

    if (output->name && output->name != (char *) (output + 1))
        free(output->name);
    output->name = newname;
    xf86OutputSetMonitor(output);
    if (xf86OutputIgnored(output))
        return FALSE;
    return TRUE;
}

void
xf86OutputUseScreenMonitor(xf86OutputPtr output, Bool use_screen_monitor)
{
    if (use_screen_monitor != output->use_screen_monitor) {
        output->use_screen_monitor = use_screen_monitor;
        xf86OutputSetMonitor(output);
    }
}

void
xf86OutputDestroy(xf86OutputPtr output)
{
    ScrnInfoPtr scrn = output->scrn;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int o;

    (*output->funcs->destroy) (output);
    while (output->probed_modes)
        xf86DeleteMode(&output->probed_modes, output->probed_modes);
    for (o = 0; o < xf86_config->num_output; o++)
        if (xf86_config->output[o] == output) {
            memmove(&xf86_config->output[o],
                    &xf86_config->output[o + 1],
                    ((xf86_config->num_output - (o + 1)) * sizeof(void *)));
            xf86_config->num_output--;
            break;
        }
    if (output->name && output->name != (char *) (output + 1))
        free(output->name);
    free(output);
}

/*
 * Called during CreateScreenResources to hook up RandR
 */
static Bool
xf86CrtcCreateScreenResources(ScreenPtr screen)
{
    ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);

    screen->CreateScreenResources = config->CreateScreenResources;

    if (!(*screen->CreateScreenResources) (screen))
        return FALSE;

    if (!xf86RandR12CreateScreenResources(screen))
        return FALSE;

    return TRUE;
}

/*
 * Clean up config on server reset
 */
static Bool
xf86CrtcCloseScreen(ScreenPtr screen)
{
    ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
    int o, c;

    screen->CloseScreen = config->CloseScreen;

    xf86RotateCloseScreen(screen);

    xf86RandR12CloseScreen(screen);

    screen->CloseScreen(screen);

    for (o = 0; o < config->num_output; o++) {
        xf86OutputPtr output = config->output[o];

        output->randr_output = NULL;
    }
    for (c = 0; c < config->num_crtc; c++) {
        xf86CrtcPtr crtc = config->crtc[c];

        crtc->randr_crtc = NULL;
    }
    /* detach any providers */
    if (config->randr_provider) {
        RRProviderDestroy(config->randr_provider);
        config->randr_provider = NULL;
    }
    return TRUE;
}

/*
 * Called at ScreenInit time to set up
 */
#ifdef RANDR_13_INTERFACE
int
#else
Bool
#endif
xf86CrtcScreenInit(ScreenPtr screen)
{
    ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
    int c;

    /* Rotation */
    xf86DrvMsg(scrn->scrnIndex, X_INFO,
               "RandR 1.2 enabled, ignore the following RandR disabled message.\n");
    xf86DisableRandR();         /* Disable old RandR extension support */
    xf86RandR12Init(screen);

    /* support all rotations if every crtc has the shadow alloc funcs */
    for (c = 0; c < config->num_crtc; c++) {
        xf86CrtcPtr crtc = config->crtc[c];

        if (!crtc->funcs->shadow_allocate || !crtc->funcs->shadow_create)
            break;
    }
    if (c == config->num_crtc) {
        xf86RandR12SetRotations(screen, RR_Rotate_0 | RR_Rotate_90 |
                                RR_Rotate_180 | RR_Rotate_270 |
                                RR_Reflect_X | RR_Reflect_Y);
        xf86RandR12SetTransformSupport(screen, TRUE);
    }
    else {
        xf86RandR12SetRotations(screen, RR_Rotate_0);
        xf86RandR12SetTransformSupport(screen, FALSE);
    }

    /* Wrap CreateScreenResources so we can initialize the RandR code */
    config->CreateScreenResources = screen->CreateScreenResources;
    screen->CreateScreenResources = xf86CrtcCreateScreenResources;

    config->CloseScreen = screen->CloseScreen;
    screen->CloseScreen = xf86CrtcCloseScreen;

    /* This might still be marked wrapped from a previous generation */
    config->BlockHandler = NULL;

#ifdef XFreeXDGA
    _xf86_di_dga_init_internal(screen);
#endif
#ifdef RANDR_13_INTERFACE
    return RANDR_INTERFACE_VERSION;
#else
    return TRUE;
#endif
}

static DisplayModePtr
xf86DefaultMode(xf86OutputPtr output, int width, int height)
{
    DisplayModePtr target_mode = NULL;
    DisplayModePtr mode;
    int target_diff = 0;
    int target_preferred = 0;
    int mm_height;

    mm_height = output->mm_height;
    if (!mm_height)
        mm_height = (768 * 25.4) / DEFAULT_DPI;
    /*
     * Pick a mode closest to DEFAULT_DPI
     */
    for (mode = output->probed_modes; mode; mode = mode->next) {
        int dpi;
        int preferred = (((mode->type & M_T_PREFERRED) != 0) +
                         ((mode->type & M_T_USERPREF) != 0));
        int diff;

        if (xf86ModeWidth(mode, output->initial_rotation) > width ||
            xf86ModeHeight(mode, output->initial_rotation) > height)
            continue;

        /* yes, use VDisplay here, not xf86ModeHeight */
        dpi = (mode->VDisplay * 254) / (mm_height * 10);
        diff = dpi - DEFAULT_DPI;
        diff = diff < 0 ? -diff : diff;
        if (target_mode == NULL || (preferred > target_preferred) ||
            (preferred == target_preferred && diff < target_diff)) {
            target_mode = mode;
            target_diff = diff;
            target_preferred = preferred;
        }
    }
    return target_mode;
}

static DisplayModePtr
xf86ClosestMode(xf86OutputPtr output,
                DisplayModePtr match, Rotation match_rotation,
                int width, int height)
{
    DisplayModePtr target_mode = NULL;
    DisplayModePtr mode;
    int target_diff = 0;

    /*
     * Pick a mode closest to the specified mode
     */
    for (mode = output->probed_modes; mode; mode = mode->next) {
        int dx, dy;
        int diff;

        if (xf86ModeWidth(mode, output->initial_rotation) > width ||
            xf86ModeHeight(mode, output->initial_rotation) > height)
            continue;

        /* exact matches are preferred */
        if (output->initial_rotation == match_rotation &&
            xf86ModesEqual(mode, match))
            return mode;

        dx = xf86ModeWidth(match, match_rotation) - xf86ModeWidth(mode,
                                                                  output->
                                                                  initial_rotation);
        dy = xf86ModeHeight(match, match_rotation) - xf86ModeHeight(mode,
                                                                    output->
                                                                    initial_rotation);
        diff = dx * dx + dy * dy;
        if (target_mode == NULL || diff < target_diff) {
            target_mode = mode;
            target_diff = diff;
        }
    }
    return target_mode;
}

static DisplayModePtr
xf86OutputHasPreferredMode(xf86OutputPtr output, int width, int height)
{
    DisplayModePtr mode;

    for (mode = output->probed_modes; mode; mode = mode->next) {
        if (xf86ModeWidth(mode, output->initial_rotation) > width ||
            xf86ModeHeight(mode, output->initial_rotation) > height)
            continue;

        if (mode->type & M_T_PREFERRED)
            return mode;
    }
    return NULL;
}

static DisplayModePtr
xf86OutputHasUserPreferredMode(xf86OutputPtr output)
{
    DisplayModePtr mode, first = output->probed_modes;

    for (mode = first; mode && mode->next != first; mode = mode->next)
        if (mode->type & M_T_USERPREF)
            return mode;

    return NULL;
}

static int
xf86PickCrtcs(ScrnInfoPtr scrn,
              xf86CrtcPtr * best_crtcs,
              DisplayModePtr * modes, int n, int width, int height)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
    int c, o;
    xf86OutputPtr output;
    xf86CrtcPtr crtc;
    xf86CrtcPtr *crtcs;
    int best_score;
    int score;
    int my_score;

    if (n == config->num_output)
        return 0;
    output = config->output[n];

    /*
     * Compute score with this output disabled
     */
    best_crtcs[n] = NULL;
    best_score = xf86PickCrtcs(scrn, best_crtcs, modes, n + 1, width, height);
    if (modes[n] == NULL)
        return best_score;

    crtcs = xallocarray(config->num_output, sizeof(xf86CrtcPtr));
    if (!crtcs)
        return best_score;

    my_score = 1;
    /* Score outputs that are known to be connected higher */
    if (output->status == XF86OutputStatusConnected)
        my_score++;
    /* Score outputs with preferred modes higher */
    if (xf86OutputHasPreferredMode(output, width, height))
        my_score++;
    /*
     * Select a crtc for this output and
     * then attempt to configure the remaining
     * outputs
     */
    for (c = 0; c < config->num_crtc; c++) {
        if ((output->possible_crtcs & (1 << c)) == 0)
            continue;

        crtc = config->crtc[c];
        /*
         * Check to see if some other output is
         * using this crtc
         */
        for (o = 0; o < n; o++)
            if (best_crtcs[o] == crtc)
                break;
        if (o < n) {
            /*
             * If the two outputs desire the same mode,
             * see if they can be cloned
             */
            if (xf86ModesEqual(modes[o], modes[n]) &&
                config->output[o]->initial_rotation ==
                config->output[n]->initial_rotation &&
                config->output[o]->initial_x == config->output[n]->initial_x &&
                config->output[o]->initial_y == config->output[n]->initial_y) {
                if ((output->possible_clones & (1 << o)) == 0)
                    continue;   /* nope, try next CRTC */
            }
            else
                continue;       /* different modes, can't clone */
        }
        crtcs[n] = crtc;
        memcpy(crtcs, best_crtcs, n * sizeof(xf86CrtcPtr));
        score =
            my_score + xf86PickCrtcs(scrn, crtcs, modes, n + 1, width, height);
        if (score > best_score) {
            best_score = score;
            memcpy(best_crtcs, crtcs, config->num_output * sizeof(xf86CrtcPtr));
        }
    }
    free(crtcs);
    return best_score;
}

/*
 * Compute the virtual size necessary to place all of the available
 * crtcs in the specified configuration.
 *
 * canGrow indicates that the driver can make the screen larger than its initial
 * configuration.  If FALSE, this function will enlarge the screen to include
 * the largest available mode.
 */

static void
xf86DefaultScreenLimits(ScrnInfoPtr scrn, int *widthp, int *heightp,
                        Bool canGrow)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
    int width = 0, height = 0;
    int o;
    int c;
    int s;

    for (c = 0; c < config->num_crtc; c++) {
        int crtc_width = 0, crtc_height = 0;
        xf86CrtcPtr crtc = config->crtc[c];

        if (crtc->enabled) {
            crtc_width =
                crtc->desiredX + xf86ModeWidth(&crtc->desiredMode,
                                               crtc->desiredRotation);
            crtc_height =
                crtc->desiredY + xf86ModeHeight(&crtc->desiredMode,
                                                crtc->desiredRotation);
        }
        if (!canGrow) {
            for (o = 0; o < config->num_output; o++) {
                xf86OutputPtr output = config->output[o];

                for (s = 0; s < config->num_crtc; s++)
                    if (output->possible_crtcs & (1 << s)) {
                        DisplayModePtr mode;

                        for (mode = output->probed_modes; mode;
                             mode = mode->next) {
                            if (mode->HDisplay > crtc_width)
                                crtc_width = mode->HDisplay;
                            if (mode->VDisplay > crtc_width)
                                crtc_width = mode->VDisplay;
                            if (mode->VDisplay > crtc_height)
                                crtc_height = mode->VDisplay;
                            if (mode->HDisplay > crtc_height)
                                crtc_height = mode->HDisplay;
                        }
                    }
            }
        }
        if (crtc_width > width)
            width = crtc_width;
        if (crtc_height > height)
            height = crtc_height;
    }
    if (config->maxWidth && width > config->maxWidth)
        width = config->maxWidth;
    if (config->maxHeight && height > config->maxHeight)
        height = config->maxHeight;
    if (config->minWidth && width < config->minWidth)
        width = config->minWidth;
    if (config->minHeight && height < config->minHeight)
        height = config->minHeight;
    *widthp = width;
    *heightp = height;
}

#define POSITION_UNSET	-100000

/*
 * check if the user configured any outputs at all
 * with either a position or a relative setting or a mode.
 */
static Bool
xf86UserConfiguredOutputs(ScrnInfoPtr scrn, DisplayModePtr * modes)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
    int o;
    Bool user_conf = FALSE;

    for (o = 0; o < config->num_output; o++) {
        xf86OutputPtr output = config->output[o];
        const char *position;
        const char *relative_name;
        OutputOpts relation;
        int r;

        static const OutputOpts relations[] = {
            OPTION_BELOW, OPTION_RIGHT_OF, OPTION_ABOVE, OPTION_LEFT_OF
        };

        position = xf86GetOptValString(output->options, OPTION_POSITION);
        if (position)
            user_conf = TRUE;

        relation = 0;
        relative_name = NULL;
        for (r = 0; r < 4; r++) {
            relation = relations[r];
            relative_name = xf86GetOptValString(output->options, relation);
            if (relative_name)
                break;
        }
        if (relative_name)
            user_conf = TRUE;

        modes[o] = xf86OutputHasUserPreferredMode(output);
        if (modes[o])
            user_conf = TRUE;
    }

    return user_conf;
}

static Bool
xf86InitialOutputPositions(ScrnInfoPtr scrn, DisplayModePtr * modes)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
    int o;
    int min_x, min_y;

    /* check for initial right-of heuristic */
    for (o = 0; o < config->num_output; o++)
    {
        xf86OutputPtr output = config->output[o];

        if (output->initial_x || output->initial_y)
            return TRUE;
    }

    for (o = 0; o < config->num_output; o++) {
        xf86OutputPtr output = config->output[o];

        output->initial_x = output->initial_y = POSITION_UNSET;
    }

    /*
     * Loop until all outputs are set
     */
    for (;;) {
        Bool any_set = FALSE;
        Bool keep_going = FALSE;

        for (o = 0; o < config->num_output; o++) {
            static const OutputOpts relations[] = {
                OPTION_BELOW, OPTION_RIGHT_OF, OPTION_ABOVE, OPTION_LEFT_OF
            };
            xf86OutputPtr output = config->output[o];
            xf86OutputPtr relative;
            const char *relative_name;
            const char *position;
            OutputOpts relation;
            int r;

            if (output->initial_x != POSITION_UNSET)
                continue;
            position = xf86GetOptValString(output->options, OPTION_POSITION);
            /*
             * Absolute position wins
             */
            if (position) {
                int x, y;

                if (sscanf(position, "%d %d", &x, &y) == 2) {
                    output->initial_x = x;
                    output->initial_y = y;
                }
                else {
                    xf86DrvMsg(scrn->scrnIndex, X_ERROR,
                               "Output %s position not of form \"x y\"\n",
                               output->name);
                    output->initial_x = output->initial_y = 0;
                }
                any_set = TRUE;
                continue;
            }
            /*
             * Next comes relative positions
             */
            relation = 0;
            relative_name = NULL;
            for (r = 0; r < 4; r++) {
                relation = relations[r];
                relative_name = xf86GetOptValString(output->options, relation);
                if (relative_name)
                    break;
            }
            if (relative_name) {
                int or;

                relative = NULL;
                for (or = 0; or < config->num_output; or++) {
                    xf86OutputPtr out_rel = config->output[or];
                    XF86ConfMonitorPtr rel_mon = out_rel->conf_monitor;

                    if (rel_mon) {
                        if (xf86nameCompare(rel_mon->mon_identifier,
                                            relative_name) == 0) {
                            relative = config->output[or];
                            break;
                        }
                    }
                    if (strcmp(out_rel->name, relative_name) == 0) {
                        relative = config->output[or];
                        break;
                    }
                }
                if (!relative) {
                    xf86DrvMsg(scrn->scrnIndex, X_ERROR,
                               "Cannot position output %s relative to unknown output %s\n",
                               output->name, relative_name);
                    output->initial_x = 0;
                    output->initial_y = 0;
                    any_set = TRUE;
                    continue;
                }
                if (!modes[or]) {
                    xf86DrvMsg(scrn->scrnIndex, X_ERROR,
                               "Cannot position output %s relative to output %s without modes\n",
                               output->name, relative_name);
                    output->initial_x = 0;
                    output->initial_y = 0;
                    any_set = TRUE;
                    continue;
                }
                if (relative->initial_x == POSITION_UNSET) {
                    keep_going = TRUE;
                    continue;
                }
                output->initial_x = relative->initial_x;
                output->initial_y = relative->initial_y;
                switch (relation) {
                case OPTION_BELOW:
                    output->initial_y +=
                        xf86ModeHeight(modes[or], relative->initial_rotation);
                    break;
                case OPTION_RIGHT_OF:
                    output->initial_x +=
                        xf86ModeWidth(modes[or], relative->initial_rotation);
                    break;
                case OPTION_ABOVE:
                    if (modes[o])
                        output->initial_y -=
                            xf86ModeHeight(modes[o], output->initial_rotation);
                    break;
                case OPTION_LEFT_OF:
                    if (modes[o])
                        output->initial_x -=
                            xf86ModeWidth(modes[o], output->initial_rotation);
                    break;
                default:
                    break;
                }
                any_set = TRUE;
                continue;
            }

            /* Nothing set, just stick them at 0,0 */
            output->initial_x = 0;
            output->initial_y = 0;
            any_set = TRUE;
        }
        if (!keep_going)
            break;
        if (!any_set) {
            for (o = 0; o < config->num_output; o++) {
                xf86OutputPtr output = config->output[o];

                if (output->initial_x == POSITION_UNSET) {
                    xf86DrvMsg(scrn->scrnIndex, X_ERROR,
                               "Output position loop. Moving %s to 0,0\n",
                               output->name);
                    output->initial_x = output->initial_y = 0;
                    break;
                }
            }
        }
    }

    /*
     * normalize positions
     */
    min_x = 1000000;
    min_y = 1000000;
    for (o = 0; o < config->num_output; o++) {
        xf86OutputPtr output = config->output[o];

        if (output->initial_x < min_x)
            min_x = output->initial_x;
        if (output->initial_y < min_y)
            min_y = output->initial_y;
    }

    for (o = 0; o < config->num_output; o++) {
        xf86OutputPtr output = config->output[o];

        output->initial_x -= min_x;
        output->initial_y -= min_y;
    }
    return TRUE;
}

static void
xf86InitialPanning(ScrnInfoPtr scrn)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
    int o;

    for (o = 0; o < config->num_output; o++) {
        xf86OutputPtr output = config->output[o];
        const char *panning = xf86GetOptValString(output->options, OPTION_PANNING);
        int width, height, left, top;
        int track_width, track_height, track_left, track_top;
        int brdr[4];

        memset(&output->initialTotalArea, 0, sizeof(BoxRec));
        memset(&output->initialTrackingArea, 0, sizeof(BoxRec));
        memset(output->initialBorder, 0, 4 * sizeof(INT16));

        if (!panning)
            continue;

        switch (sscanf(panning, "%dx%d+%d+%d/%dx%d+%d+%d/%d/%d/%d/%d",
                       &width, &height, &left, &top,
                       &track_width, &track_height, &track_left, &track_top,
                       &brdr[0], &brdr[1], &brdr[2], &brdr[3])) {
        case 12:
            output->initialBorder[0] = brdr[0];
            output->initialBorder[1] = brdr[1];
            output->initialBorder[2] = brdr[2];
            output->initialBorder[3] = brdr[3];
            /* fall through */
        case 8:
            output->initialTrackingArea.x1 = track_left;
            output->initialTrackingArea.y1 = track_top;
            output->initialTrackingArea.x2 = track_left + track_width;
            output->initialTrackingArea.y2 = track_top + track_height;
            /* fall through */
        case 4:
            output->initialTotalArea.x1 = left;
            output->initialTotalArea.y1 = top;
            /* fall through */
        case 2:
            output->initialTotalArea.x2 = output->initialTotalArea.x1 + width;
            output->initialTotalArea.y2 = output->initialTotalArea.y1 + height;
            break;
        default:
            xf86DrvMsg(scrn->scrnIndex, X_ERROR,
                       "Broken panning specification '%s' for output %s in config file\n",
                       panning, output->name);
        }
    }
}

/** Return - 0 + if a should be earlier, same or later than b in list
 */
static int
xf86ModeCompare(DisplayModePtr a, DisplayModePtr b)
{
    int diff;

    diff = ((b->type & M_T_PREFERRED) != 0) - ((a->type & M_T_PREFERRED) != 0);
    if (diff)
        return diff;
    diff = b->HDisplay * b->VDisplay - a->HDisplay * a->VDisplay;
    if (diff)
        return diff;
    diff = b->Clock - a->Clock;
    return diff;
}

/**
 * Insertion sort input in-place and return the resulting head
 */
static DisplayModePtr
xf86SortModes(DisplayModePtr input)
{
    DisplayModePtr output = NULL, i, o, n, *op, prev;

    /* sort by preferred status and pixel area */
    while (input) {
        i = input;
        input = input->next;
        for (op = &output; (o = *op); op = &o->next)
            if (xf86ModeCompare(o, i) > 0)
                break;
        i->next = *op;
        *op = i;
    }
    /* prune identical modes */
    for (o = output; o && (n = o->next); o = n) {
        if (!strcmp(o->name, n->name) && xf86ModesEqual(o, n)) {
            o->next = n->next;
            free((void *) n->name);
            free(n);
            n = o;
        }
    }
    /* hook up backward links */
    prev = NULL;
    for (o = output; o; o = o->next) {
        o->prev = prev;
        prev = o;
    }
    return output;
}

static const char *
preferredMode(ScrnInfoPtr pScrn, xf86OutputPtr output)
{
    const char *preferred_mode = NULL;

    /* Check for a configured preference for a particular mode */
    preferred_mode = xf86GetOptValString(output->options,
                                         OPTION_PREFERRED_MODE);
    if (preferred_mode)
        return preferred_mode;

    if (pScrn->display->modes && *pScrn->display->modes)
        preferred_mode = *pScrn->display->modes;

    return preferred_mode;
}

/** identify a token
 * args
 *   *src     a string with zero or more tokens, e.g. "tok0 tok1",
 *   **token  stores a pointer to the first token character,
 *   *len     stores the token length.
 * return
 *   a pointer into src[] at the token terminating character, or
 *   NULL if no token is found.
 */
static const char *
gettoken(const char *src, const char **token, int *len)
{
    const char *delim = " \t";
    int skip;

    if (!src)
        return NULL;

    skip = strspn(src, delim);
    *token = &src[skip];

    *len = strcspn(*token, delim);
    /* Support for backslash escaped delimiters could be implemented
     * here.
     */

    /* (*token)[0] != '\0'  <==>  *len > 0 */
    if (*len > 0)
        return &(*token)[*len];
    else
        return NULL;
}

/** Check for a user configured zoom mode list, Option "ZoomModes":
 *
 * Section "Monitor"
 *   Identifier "a21inch"
 *   Option "ZoomModes" "1600x1200 1280x1024 1280x1024 640x480"
 * EndSection
 *
 * Each user mode name is searched for independently so the list
 * specification order is free.  An output mode is matched at most
 * once, a mode with an already set M_T_USERDEF type bit is skipped.
 * Thus a repeat mode name specification matches the next output mode
 * with the same name.
 *
 * Ctrl+Alt+Keypad-{Plus,Minus} zooms {in,out} by selecting the
 * {next,previous} M_T_USERDEF mode in the screen modes list, itself
 * sorted toward lower dot area or lower dot clock frequency, see
 *   modes/xf86Crtc.c: xf86SortModes() xf86SetScrnInfoModes(), and
 *   common/xf86Cursor.c: xf86ZoomViewport().
 */
static int
processZoomModes(xf86OutputPtr output)
{
    const char *zoom_modes;
    int count = 0;

    zoom_modes = xf86GetOptValString(output->options, OPTION_ZOOM_MODES);

    if (zoom_modes) {
        const char *token, *next;
        int len;

        next = gettoken(zoom_modes, &token, &len);
        while (next) {
            DisplayModePtr mode;

            for (mode = output->probed_modes; mode; mode = mode->next)
                if (!strncmp(token, mode->name, len)  /* prefix match */
                    && mode->name[len] == '\0'        /* equal length */
                    && !(mode->type & M_T_USERDEF)) { /* no rematch */
                    mode->type |= M_T_USERDEF;
                    break;
                }

            count++;
            next = gettoken(next, &token, &len);
        }
    }

    return count;
}

static void
GuessRangeFromModes(MonPtr mon, DisplayModePtr mode)
{
    if (!mon || !mode)
        return;

    mon->nHsync = 1;
    mon->hsync[0].lo = 1024.0;
    mon->hsync[0].hi = 0.0;

    mon->nVrefresh = 1;
    mon->vrefresh[0].lo = 1024.0;
    mon->vrefresh[0].hi = 0.0;

    while (mode) {
        if (!mode->HSync)
            mode->HSync = ((float) mode->Clock) / ((float) mode->HTotal);

        if (!mode->VRefresh)
            mode->VRefresh = (1000.0 * ((float) mode->Clock)) /
                ((float) (mode->HTotal * mode->VTotal));

        if (mode->HSync < mon->hsync[0].lo)
            mon->hsync[0].lo = mode->HSync;

        if (mode->HSync > mon->hsync[0].hi)
            mon->hsync[0].hi = mode->HSync;

        if (mode->VRefresh < mon->vrefresh[0].lo)
            mon->vrefresh[0].lo = mode->VRefresh;

        if (mode->VRefresh > mon->vrefresh[0].hi)
            mon->vrefresh[0].hi = mode->VRefresh;

        mode = mode->next;
    }

    /* stretch out the bottom to fit 640x480@@60 */
    if (mon->hsync[0].lo > 31.0)
        mon->hsync[0].lo = 31.0;
    if (mon->vrefresh[0].lo > 58.0)
        mon->vrefresh[0].lo = 58.0;
}

enum det_monrec_source {
    sync_config, sync_edid, sync_default
};

struct det_monrec_parameter {
    MonRec *mon_rec;
    int *max_clock;
    Bool set_hsync;
    Bool set_vrefresh;
    enum det_monrec_source *sync_source;
};

static void
handle_detailed_monrec(struct detailed_monitor_section *det_mon, void *data)
{
    struct det_monrec_parameter *p;

    p = (struct det_monrec_parameter *) data;

    if (det_mon->type == DS_RANGES) {
        struct monitor_ranges *ranges = &det_mon->section.ranges;

        if (p->set_hsync && ranges->max_h) {
            p->mon_rec->hsync[p->mon_rec->nHsync].lo = ranges->min_h;
            p->mon_rec->hsync[p->mon_rec->nHsync].hi = ranges->max_h;
            p->mon_rec->nHsync++;
            if (*p->sync_source == sync_default)
                *p->sync_source = sync_edid;
        }
        if (p->set_vrefresh && ranges->max_v) {
            p->mon_rec->vrefresh[p->mon_rec->nVrefresh].lo = ranges->min_v;
            p->mon_rec->vrefresh[p->mon_rec->nVrefresh].hi = ranges->max_v;
            p->mon_rec->nVrefresh++;
            if (*p->sync_source == sync_default)
                *p->sync_source = sync_edid;
        }
        if (ranges->max_clock * 1000 > *p->max_clock)
            *p->max_clock = ranges->max_clock * 1000;
    }
}

void
xf86ProbeOutputModes(ScrnInfoPtr scrn, int maxX, int maxY)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
    int o;

    /* When canGrow was TRUE in the initial configuration we have to
     * compare against the maximum values so that we don't drop modes.
     * When canGrow was FALSE, the maximum values would have been clamped
     * anyway.
     */
    if (maxX == 0 || maxY == 0) {
        maxX = config->maxWidth;
        maxY = config->maxHeight;
    }

    /* Probe the list of modes for each output. */
    for (o = 0; o < config->num_output; o++) {
        xf86OutputPtr output = config->output[o];
        DisplayModePtr mode;
        DisplayModePtr config_modes = NULL, output_modes, default_modes = NULL;
        const char *preferred_mode;
        xf86MonPtr edid_monitor;
        XF86ConfMonitorPtr conf_monitor;
        MonRec mon_rec;
        int min_clock = 0;
        int max_clock = 0;
        double clock;
        Bool add_default_modes;
        Bool debug_modes = config->debug_modes || xf86Initialising;
        enum det_monrec_source sync_source = sync_default;

        while (output->probed_modes != NULL)
            xf86DeleteMode(&output->probed_modes, output->probed_modes);

        /*
         * Check connection status
         */
        output->status = (*output->funcs->detect) (output);

        if (output->status == XF86OutputStatusDisconnected &&
            !xf86ReturnOptValBool(output->options, OPTION_ENABLE, FALSE)) {
            xf86OutputSetEDID(output, NULL);
            continue;
        }

        memset(&mon_rec, '\0', sizeof(mon_rec));

        conf_monitor = output->conf_monitor;

        if (conf_monitor) {
            int i;

            for (i = 0; i < conf_monitor->mon_n_hsync; i++) {
                mon_rec.hsync[mon_rec.nHsync].lo =
                    conf_monitor->mon_hsync[i].lo;
                mon_rec.hsync[mon_rec.nHsync].hi =
                    conf_monitor->mon_hsync[i].hi;
                mon_rec.nHsync++;
                sync_source = sync_config;
            }
            for (i = 0; i < conf_monitor->mon_n_vrefresh; i++) {
                mon_rec.vrefresh[mon_rec.nVrefresh].lo =
                    conf_monitor->mon_vrefresh[i].lo;
                mon_rec.vrefresh[mon_rec.nVrefresh].hi =
                    conf_monitor->mon_vrefresh[i].hi;
                mon_rec.nVrefresh++;
                sync_source = sync_config;
            }
            config_modes = xf86GetMonitorModes(scrn, conf_monitor);
        }

        output_modes = (*output->funcs->get_modes) (output);

        /*
         * If the user has a preference, respect it.
         * Otherwise, don't second-guess the driver.
         */
        if (!xf86GetOptValBool(output->options, OPTION_DEFAULT_MODES,
                               &add_default_modes))
            add_default_modes = (output_modes == NULL);

        edid_monitor = output->MonInfo;

        if (edid_monitor) {
            struct det_monrec_parameter p;
            struct disp_features *features = &edid_monitor->features;
            struct cea_data_block *hdmi_db;

            /* if display is not continuous-frequency, don't add default modes */
            if (!GTF_SUPPORTED(features->msc))
                add_default_modes = FALSE;

            p.mon_rec = &mon_rec;
            p.max_clock = &max_clock;
            p.set_hsync = mon_rec.nHsync == 0;
            p.set_vrefresh = mon_rec.nVrefresh == 0;
            p.sync_source = &sync_source;

            xf86ForEachDetailedBlock(edid_monitor, handle_detailed_monrec, &p);

            /* Look at the CEA HDMI vendor block for the max TMDS freq */
            hdmi_db = xf86MonitorFindHDMIBlock(edid_monitor);
            if (hdmi_db && hdmi_db->len >= 7) {
                int tmds_freq = hdmi_db->u.vendor.hdmi.max_tmds_clock * 5000;
                xf86DrvMsg(scrn->scrnIndex, X_PROBED,
                           "HDMI max TMDS frequency %dKHz\n", tmds_freq);
                if (tmds_freq > max_clock)
                    max_clock = tmds_freq;
            }
        }

        if (xf86GetOptValFreq(output->options, OPTION_MIN_CLOCK,
                              OPTUNITS_KHZ, &clock))
            min_clock = (int) clock;
        if (xf86GetOptValFreq(output->options, OPTION_MAX_CLOCK,
                              OPTUNITS_KHZ, &clock))
            max_clock = (int) clock;

        /* If we still don't have a sync range, guess wildly */
        if (!mon_rec.nHsync || !mon_rec.nVrefresh)
            GuessRangeFromModes(&mon_rec, output_modes);

        /*
         * These limits will end up setting a 1024x768@@60Hz mode by default,
         * which seems like a fairly good mode to use when nothing else is
         * specified
         */
        if (mon_rec.nHsync == 0) {
            mon_rec.hsync[0].lo = 31.0;
            mon_rec.hsync[0].hi = 55.0;
            mon_rec.nHsync = 1;
        }
        if (mon_rec.nVrefresh == 0) {
            mon_rec.vrefresh[0].lo = 58.0;
            mon_rec.vrefresh[0].hi = 62.0;
            mon_rec.nVrefresh = 1;
        }

        if (add_default_modes)
            default_modes = xf86GetDefaultModes();

        /*
         * If this is not an RB monitor, remove RB modes from the default
         * pool.  RB modes from the config or the monitor itself are fine.
         */
        if (!mon_rec.reducedblanking)
            xf86ValidateModesReducedBlanking(scrn, default_modes);

        if (sync_source == sync_config) {
            /*
             * Check output and config modes against sync range from config file
             */
            xf86ValidateModesSync(scrn, output_modes, &mon_rec);
            xf86ValidateModesSync(scrn, config_modes, &mon_rec);
        }
        /*
         * Check default modes against sync range
         */
        xf86ValidateModesSync(scrn, default_modes, &mon_rec);
        /*
         * Check default modes against monitor max clock
         */
        if (max_clock) {
            xf86ValidateModesClocks(scrn, default_modes,
                                    &min_clock, &max_clock, 1);
            xf86ValidateModesClocks(scrn, output_modes,
                                    &min_clock, &max_clock, 1);
        }

        output->probed_modes = NULL;
        output->probed_modes = xf86ModesAdd(output->probed_modes, config_modes);
        output->probed_modes = xf86ModesAdd(output->probed_modes, output_modes);
        output->probed_modes =
            xf86ModesAdd(output->probed_modes, default_modes);

        /*
         * Check all modes against max size, interlace, and doublescan
         */
        if (maxX && maxY)
            xf86ValidateModesSize(scrn, output->probed_modes, maxX, maxY, 0);

        {
            int flags = (output->interlaceAllowed ? V_INTERLACE : 0) |
                (output->doubleScanAllowed ? V_DBLSCAN : 0);
            xf86ValidateModesFlags(scrn, output->probed_modes, flags);
        }

        /*
         * Check all modes against output
         */
        for (mode = output->probed_modes; mode != NULL; mode = mode->next)
            if (mode->status == MODE_OK)
                mode->status = (*output->funcs->mode_valid) (output, mode);

        xf86PruneInvalidModes(scrn, &output->probed_modes, debug_modes);

        output->probed_modes = xf86SortModes(output->probed_modes);

        /* Check for a configured preference for a particular mode */
        preferred_mode = preferredMode(scrn, output);

        if (preferred_mode) {
            for (mode = output->probed_modes; mode; mode = mode->next) {
                if (!strcmp(preferred_mode, mode->name)) {
                    if (mode != output->probed_modes) {
                        if (mode->prev)
                            mode->prev->next = mode->next;
                        if (mode->next)
                            mode->next->prev = mode->prev;
                        mode->next = output->probed_modes;
                        output->probed_modes->prev = mode;
                        mode->prev = NULL;
                        output->probed_modes = mode;
                    }
                    mode->type |= (M_T_PREFERRED | M_T_USERPREF);
                    break;
                }
            }
        }

        /* Ctrl+Alt+Keypad-{Plus,Minus} zoom mode: M_T_USERDEF mode type */
        processZoomModes(output);

        output->initial_rotation = xf86OutputInitialRotation(output);

        if (debug_modes) {
            if (output->probed_modes != NULL) {
                xf86DrvMsg(scrn->scrnIndex, X_INFO,
                           "Printing probed modes for output %s\n",
                           output->name);
            }
            else {
                xf86DrvMsg(scrn->scrnIndex, X_INFO,
                           "No remaining probed modes for output %s\n",
                           output->name);
            }
        }
        for (mode = output->probed_modes; mode != NULL; mode = mode->next) {
            /* The code to choose the best mode per pipe later on will require
             * VRefresh to be set.
             */
            mode->VRefresh = xf86ModeVRefresh(mode);
            xf86SetModeCrtc(mode, INTERLACE_HALVE_V);

            if (debug_modes)
                xf86PrintModeline(scrn->scrnIndex, mode);
        }
    }
}

/**
 * Copy one of the output mode lists to the ScrnInfo record
 */

static DisplayModePtr
biggestMode(DisplayModePtr a, DisplayModePtr b)
{
    int A, B;

    if (!a)
        return b;
    if (!b)
        return a;

    A = a->HDisplay * a->VDisplay;
    B = b->HDisplay * b->VDisplay;

    if (A > B)
        return a;

    return b;
}

static xf86OutputPtr
SetCompatOutput(xf86CrtcConfigPtr config)
{
    xf86OutputPtr output = NULL, test = NULL;
    DisplayModePtr maxmode = NULL, testmode, mode;
    int o, compat = -1, count, mincount = 0;

    if (config->num_output == 0)
        return NULL;

    /* Look for one that's definitely connected */
    for (o = 0; o < config->num_output; o++) {
        test = config->output[o];
        if (!test->crtc)
            continue;
        if (test->status != XF86OutputStatusConnected)
            continue;
        if (!test->probed_modes)
            continue;

        testmode = mode = test->probed_modes;
        for (count = 0; mode; mode = mode->next, count++)
            testmode = biggestMode(testmode, mode);

        if (!output) {
            output = test;
            compat = o;
            maxmode = testmode;
            mincount = count;
        }
        else if (maxmode == biggestMode(maxmode, testmode)) {
            output = test;
            compat = o;
            maxmode = testmode;
            mincount = count;
        }
        else if ((maxmode->HDisplay == testmode->HDisplay) &&
                 (maxmode->VDisplay == testmode->VDisplay) &&
                 count <= mincount) {
            output = test;
            compat = o;
            maxmode = testmode;
            mincount = count;
        }
    }

    /* If we didn't find one, take anything we can get */
    if (!output) {
        for (o = 0; o < config->num_output; o++) {
            test = config->output[o];
            if (!test->crtc)
                continue;
            if (!test->probed_modes)
                continue;

            if (!output) {
                output = test;
                compat = o;
            }
            else if (test->probed_modes->HDisplay <
                     output->probed_modes->HDisplay) {
                output = test;
                compat = o;
            }
        }
    }

    if (compat >= 0) {
        config->compat_output = compat;
    }
    else if (config->compat_output >= 0 && config->compat_output < config->num_output) {
        /* Don't change the compat output when no valid outputs found */
        output = config->output[config->compat_output];
    }

    /* All outputs are disconnected, select one to fake */
    if (!output && config->num_output) {
        config->compat_output = 0;
        output = config->output[config->compat_output];
    }

    return output;
}

void
xf86SetScrnInfoModes(ScrnInfoPtr scrn)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86OutputPtr output;
    xf86CrtcPtr crtc;
    DisplayModePtr last, mode = NULL;

    output = SetCompatOutput(config);

    if (!output)
        return;                 /* punt */

    crtc = output->crtc;

    /* Clear any existing modes from scrn->modes */
    while (scrn->modes != NULL)
        xf86DeleteMode(&scrn->modes, scrn->modes);

    /* Set scrn->modes to the mode list for the 'compat' output */
    scrn->modes = xf86DuplicateModes(scrn, output->probed_modes);

    if (crtc) {
        for (mode = scrn->modes; mode; mode = mode->next)
            if (xf86ModesEqual(mode, &crtc->desiredMode))
                break;
    }

    if (!scrn->modes) {
        scrn->modes = xf86ModesAdd(scrn->modes,
                                   xf86CVTMode(scrn->display->virtualX,
                                               scrn->display->virtualY,
                                               60, 0, 0));
    }

    /* For some reason, scrn->modes is circular, unlike the other mode
     * lists.  How great is that?
     */
    for (last = scrn->modes; last && last->next; last = last->next);
    last->next = scrn->modes;
    scrn->modes->prev = last;
    if (mode) {
        while (scrn->modes != mode)
            scrn->modes = scrn->modes->next;
    }

    scrn->currentMode = scrn->modes;
#ifdef XFreeXDGA
    if (scrn->pScreen)
        _xf86_di_dga_reinit_internal(scrn->pScreen);
#endif
}

static Bool
xf86CollectEnabledOutputs(ScrnInfoPtr scrn, xf86CrtcConfigPtr config,
                          Bool *enabled)
{
    Bool any_enabled = FALSE;
    int o;

    /*
     * Don't bother enabling outputs on GPU screens: a client needs to attach
     * it to a source provider before setting a mode that scans out a shared
     * pixmap.
     */
    if (scrn->is_gpu)
        return FALSE;

    for (o = 0; o < config->num_output; o++)
        any_enabled |= enabled[o] = xf86OutputEnabled(config->output[o], TRUE);

    if (!any_enabled) {
        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
                   "No outputs definitely connected, trying again...\n");

        for (o = 0; o < config->num_output; o++)
            any_enabled |= enabled[o] =
                xf86OutputEnabled(config->output[o], FALSE);
    }

    return any_enabled;
}

static Bool
nextEnabledOutput(xf86CrtcConfigPtr config, Bool *enabled, int *index)
{
    int o = *index;

    for (o++; o < config->num_output; o++) {
        if (enabled[o]) {
            *index = o;
            return TRUE;
        }
    }

    return FALSE;
}

static Bool
aspectMatch(float a, float b)
{
    return fabs(1 - (a / b)) < 0.05;
}

static DisplayModePtr
nextAspectMode(xf86OutputPtr o, DisplayModePtr last, float aspect)
{
    DisplayModePtr m = NULL;

    if (!o)
        return NULL;

    if (!last)
        m = o->probed_modes;
    else
        m = last->next;

    for (; m; m = m->next)
        if (aspectMatch(aspect, (float) m->HDisplay / (float) m->VDisplay))
            return m;

    return NULL;
}

static DisplayModePtr
bestModeForAspect(xf86CrtcConfigPtr config, Bool *enabled, float aspect)
{
    int o = -1, p;
    DisplayModePtr mode = NULL, test = NULL, match = NULL;

    if (!nextEnabledOutput(config, enabled, &o))
        return NULL;
    while ((mode = nextAspectMode(config->output[o], mode, aspect))) {
        test = mode;
        for (p = o; nextEnabledOutput(config, enabled, &p);) {
            test = xf86OutputFindClosestMode(config->output[p], mode);
            if (!test)
                break;
            if (test->HDisplay != mode->HDisplay ||
                test->VDisplay != mode->VDisplay) {
                test = NULL;
                break;
            }
        }

        /* if we didn't match it on all outputs, try the next one */
        if (!test)
            continue;

        /* if it's bigger than the last one, save it */
        if (!match || (test->HDisplay > match->HDisplay))
            match = test;
    }

    /* return the biggest one found */
    return match;
}

static int
numEnabledOutputs(xf86CrtcConfigPtr config, Bool *enabled)
{
    int i = 0, p;

    for (i = 0, p = -1; nextEnabledOutput(config, enabled, &p); i++) ;

    return i;
}

static Bool
xf86TargetRightOf(ScrnInfoPtr scrn, xf86CrtcConfigPtr config,
                  DisplayModePtr *modes, Bool *enabled,
                  int width, int height)
{
    int o;
    int w = 0;
    Bool has_tile = FALSE;
    uint32_t configured_outputs;

    if (scrn->preferClone)
        return FALSE;

    if (numEnabledOutputs(config, enabled) < 2)
        return FALSE;

    for (o = -1; nextEnabledOutput(config, enabled, &o); ) {
        DisplayModePtr mode =
            xf86OutputHasPreferredMode(config->output[o], width, height);

        if (!mode)
            return FALSE;

        w += mode->HDisplay;
    }

    if (w > width)
        return FALSE;

    w = 0;
    configured_outputs = 0;

    for (o = -1; nextEnabledOutput(config, enabled, &o); ) {
        DisplayModePtr mode =
            xf86OutputHasPreferredMode(config->output[o], width, height);

        if (configured_outputs & (1 << o))
            continue;

        if (config->output[o]->tile_info.group_id) {
            has_tile = TRUE;
            continue;
        }

        config->output[o]->initial_x = w;
        w += mode->HDisplay;

        configured_outputs |= (1 << o);
        modes[o] = mode;
    }

    if (has_tile) {
        for (o = -1; nextEnabledOutput(config, enabled, &o); ) {
            int ht, vt, ot;
            int add_x, cur_x = w;
            struct xf86CrtcTileInfo *tile_info = &config->output[o]->tile_info, *this_tile;
            if (configured_outputs & (1 << o))
                continue;
            if (!tile_info->group_id)
                continue;

            if (tile_info->tile_h_loc != 0 && tile_info->tile_v_loc != 0)
                continue;

            for (ht = 0; ht < tile_info->num_h_tile; ht++) {
                int cur_y = 0;
                add_x = 0;
                for (vt = 0; vt < tile_info->num_v_tile; vt++) {

                    for (ot = -1; nextEnabledOutput(config, enabled, &ot); ) {

                        DisplayModePtr mode =
                            xf86OutputHasPreferredMode(config->output[ot], width, height);
                        if (!config->output[ot]->tile_info.group_id)
                            continue;

                        this_tile = &config->output[ot]->tile_info;
                        if (this_tile->group_id != tile_info->group_id)
                            continue;

                        if (this_tile->tile_h_loc != ht ||
                            this_tile->tile_v_loc != vt)
                            continue;

                        config->output[ot]->initial_x = cur_x;
                        config->output[ot]->initial_y = cur_y;

                        if (vt == 0)
                            add_x = this_tile->tile_h_size;
                        cur_y += this_tile->tile_v_size;
                        configured_outputs |= (1 << ot);
                        modes[ot] = mode;
                    }
                }
                cur_x += add_x;
            }
            w = cur_x;
        }
    }
    return TRUE;
}

static Bool
xf86TargetPreferred(ScrnInfoPtr scrn, xf86CrtcConfigPtr config,
                    DisplayModePtr * modes, Bool *enabled,
                    int width, int height)
{
    int o, p;
    int max_pref_width = 0, max_pref_height = 0;
    DisplayModePtr *preferred, *preferred_match;
    Bool ret = FALSE;

    preferred = xnfcalloc(config->num_output, sizeof(DisplayModePtr));
    preferred_match = xnfcalloc(config->num_output, sizeof(DisplayModePtr));

    /* Check if the preferred mode is available on all outputs */
    for (p = -1; nextEnabledOutput(config, enabled, &p);) {
        Rotation r = config->output[p]->initial_rotation;
        DisplayModePtr mode;

        if ((preferred[p] = xf86OutputHasPreferredMode(config->output[p],
                                                       width, height))) {
            int pref_width = xf86ModeWidth(preferred[p], r);
            int pref_height = xf86ModeHeight(preferred[p], r);
            Bool all_match = TRUE;

            for (o = -1; nextEnabledOutput(config, enabled, &o);) {
                Bool match = FALSE;
                xf86OutputPtr output = config->output[o];

                if (o == p)
                    continue;

                /*
                 * First see if the preferred mode matches on the next
                 * output as well.  This catches the common case of identical
                 * monitors and makes sure they all have the same timings
                 * and refresh.  If that fails, we fall back to trying to
                 * match just width & height.
                 */
                mode = xf86OutputHasPreferredMode(output, pref_width,
                                                  pref_height);
                if (mode && xf86ModesEqual(mode, preferred[p])) {
                    preferred[o] = mode;
                    match = TRUE;
                }
                else {
                    for (mode = output->probed_modes; mode; mode = mode->next) {
                        Rotation ir = output->initial_rotation;

                        if (xf86ModeWidth(mode, ir) == pref_width &&
                            xf86ModeHeight(mode, ir) == pref_height) {
                            preferred[o] = mode;
                            match = TRUE;
                        }
                    }
                }

                all_match &= match;
            }

            if (all_match &&
                (pref_width * pref_height > max_pref_width * max_pref_height)) {
                for (o = -1; nextEnabledOutput(config, enabled, &o);)
                    preferred_match[o] = preferred[o];
                max_pref_width = pref_width;
                max_pref_height = pref_height;
                ret = TRUE;
            }
        }
    }

    /*
     * If there's no preferred mode, but only one monitor, pick the
     * biggest mode for its aspect ratio or 4:3, assuming one exists.
     */
    if (!ret)
        do {
            float aspect = 0.0;
            DisplayModePtr a = NULL, b = NULL;

            if (numEnabledOutputs(config, enabled) != 1)
                break;

            p = -1;
            nextEnabledOutput(config, enabled, &p);
            if (config->output[p]->mm_height)
                aspect = (float) config->output[p]->mm_width /
                    (float) config->output[p]->mm_height;

            a = bestModeForAspect(config, enabled, 4.0/3.0);
            if (aspect)
                b = bestModeForAspect(config, enabled, aspect);

            preferred_match[p] = biggestMode(a, b);

            if (preferred_match[p])
                ret = TRUE;

        } while (0);

    if (ret) {
        /* oh good, there is a match.  stash the selected modes and return. */
        memcpy(modes, preferred_match,
               config->num_output * sizeof(DisplayModePtr));
    }

    free(preferred);
    free(preferred_match);
    return ret;
}

static Bool
xf86TargetAspect(ScrnInfoPtr scrn, xf86CrtcConfigPtr config,
                 DisplayModePtr * modes, Bool *enabled, int width, int height)
{
    int o;
    float aspect = 0.0, *aspects;
    xf86OutputPtr output;
    Bool ret = FALSE;
    DisplayModePtr guess = NULL, aspect_guess = NULL, base_guess = NULL;

    aspects = xnfcalloc(config->num_output, sizeof(float));

    /* collect the aspect ratios */
    for (o = -1; nextEnabledOutput(config, enabled, &o);) {
        output = config->output[o];
        if (output->mm_height)
            aspects[o] = (float) output->mm_width / (float) output->mm_height;
        else
            aspects[o] = 4.0 / 3.0;
    }

    /* check that they're all the same */
    for (o = -1; nextEnabledOutput(config, enabled, &o);) {
        output = config->output[o];
        if (!aspect) {
            aspect = aspects[o];
        }
        else if (!aspectMatch(aspect, aspects[o])) {
            goto no_aspect_match;
        }
    }

    /* if they're all 4:3, just skip ahead and save effort */
    if (!aspectMatch(aspect, 4.0 / 3.0))
        aspect_guess = bestModeForAspect(config, enabled, aspect);

 no_aspect_match:
    base_guess = bestModeForAspect(config, enabled, 4.0 / 3.0);

    guess = biggestMode(base_guess, aspect_guess);

    if (!guess)
        goto out;

    /* found a mode that works everywhere, now apply it */
    for (o = -1; nextEnabledOutput(config, enabled, &o);) {
        modes[o] = xf86OutputFindClosestMode(config->output[o], guess);
    }
    ret = TRUE;

 out:
    free(aspects);
    return ret;
}

static Bool
xf86TargetFallback(ScrnInfoPtr scrn, xf86CrtcConfigPtr config,
                   DisplayModePtr * modes, Bool *enabled, int width, int height)
{
    DisplayModePtr target_mode = NULL;
    Rotation target_rotation = RR_Rotate_0;
    DisplayModePtr default_mode;
    int default_preferred, target_preferred = 0, o;

    /* User preferred > preferred > other modes */
    for (o = -1; nextEnabledOutput(config, enabled, &o);) {
        default_mode = xf86DefaultMode(config->output[o], width, height);
        if (!default_mode)
            continue;

        default_preferred = (((default_mode->type & M_T_PREFERRED) != 0) +
                             ((default_mode->type & M_T_USERPREF) != 0));

        if (default_preferred > target_preferred || !target_mode) {
            target_mode = default_mode;
            target_preferred = default_preferred;
            target_rotation = config->output[o]->initial_rotation;
            config->compat_output = o;
        }
    }

    if (target_mode)
        modes[config->compat_output] = target_mode;

    /* Fill in other output modes */
    for (o = -1; nextEnabledOutput(config, enabled, &o);) {
        if (!modes[o])
            modes[o] = xf86ClosestMode(config->output[o], target_mode,
                                       target_rotation, width, height);
    }

    return target_mode != NULL;
}

static Bool
xf86TargetUserpref(ScrnInfoPtr scrn, xf86CrtcConfigPtr config,
                   DisplayModePtr * modes, Bool *enabled, int width, int height)
{
    int o;

    if (xf86UserConfiguredOutputs(scrn, modes))
        return xf86TargetFallback(scrn, config, modes, enabled, width, height);

    for (o = -1; nextEnabledOutput(config, enabled, &o);)
        if (xf86OutputHasUserPreferredMode(config->output[o]))
            return
                xf86TargetFallback(scrn, config, modes, enabled, width, height);

    return FALSE;
}

static Bool
xf86CrtcSetInitialGamma(xf86CrtcPtr crtc, float gamma_red, float gamma_green,
                        float gamma_blue)
{
    int i, size = 256;
    CARD16 *red, *green, *blue;

    red = xallocarray(size, 3 * sizeof(CARD16));
    green = red + size;
    blue = green + size;

    /* Only cause warning if user wanted gamma to be set. */
    if (!crtc->funcs->gamma_set &&
        (gamma_red != 1.0 || gamma_green != 1.0 || gamma_blue != 1.0)) {
        free(red);
        return FALSE;
    }
    else if (!crtc->funcs->gamma_set) {
        free(red);
        return TRUE;
    }

    /* At this early stage none of the randr-interface stuff is up.
     * So take the default gamma size for lack of something better.
     */
    for (i = 0; i < size; i++) {
        if (gamma_red == 1.0)
            red[i] = i << 8;
        else
            red[i] = (CARD16) (pow((double) i / (double) (size - 1),
                                   1. / (double) gamma_red) * (double) (size -
                                                                        1) *
                               256);

        if (gamma_green == 1.0)
            green[i] = i << 8;
        else
            green[i] = (CARD16) (pow((double) i / (double) (size - 1),
                                     1. / (double) gamma_green) *
                                 (double) (size - 1) * 256);

        if (gamma_blue == 1.0)
            blue[i] = i << 8;
        else
            blue[i] = (CARD16) (pow((double) i / (double) (size - 1),
                                    1. / (double) gamma_blue) * (double) (size -
                                                                          1) *
                                256);
    }

    /* Default size is 256, so anything else is failure. */
    if (size != crtc->gamma_size) {
        free(red);
        return FALSE;
    }

    crtc->gamma_size = size;
    memcpy(crtc->gamma_red, red, crtc->gamma_size * sizeof(CARD16));
    memcpy(crtc->gamma_green, green, crtc->gamma_size * sizeof(CARD16));
    memcpy(crtc->gamma_blue, blue, crtc->gamma_size * sizeof(CARD16));

    /* Do not set gamma now, delay until the crtc is activated. */

    free(red);

    return TRUE;
}

static Bool
xf86OutputSetInitialGamma(xf86OutputPtr output)
{
    XF86ConfMonitorPtr mon = output->conf_monitor;
    float gamma_red = 1.0, gamma_green = 1.0, gamma_blue = 1.0;

    if (!mon)
        return TRUE;

    if (!output->crtc)
        return FALSE;

    /* Get configured values, where they exist. */
    if (mon->mon_gamma_red >= GAMMA_MIN && mon->mon_gamma_red <= GAMMA_MAX)
        gamma_red = mon->mon_gamma_red;

    if (mon->mon_gamma_green >= GAMMA_MIN && mon->mon_gamma_green <= GAMMA_MAX)
        gamma_green = mon->mon_gamma_green;

    if (mon->mon_gamma_blue >= GAMMA_MIN && mon->mon_gamma_blue <= GAMMA_MAX)
        gamma_blue = mon->mon_gamma_blue;

    /* This avoids setting gamma 1.0 in case another cloned output on this crtc has a specific gamma. */
    if (gamma_red != 1.0 || gamma_green != 1.0 || gamma_blue != 1.0) {
        xf86DrvMsg(output->scrn->scrnIndex, X_INFO,
                   "Output %s wants gamma correction (%.1f, %.1f, %.1f)\n",
                   output->name, gamma_red, gamma_green, gamma_blue);
        return xf86CrtcSetInitialGamma(output->crtc, gamma_red, gamma_green,
                                       gamma_blue);
    }
    else
        return TRUE;
}

/**
 * Construct default screen configuration
 *
 * Given auto-detected (and, eventually, configured) values,
 * construct a usable configuration for the system
 *
 * canGrow indicates that the driver can resize the screen to larger than its
 * initially configured size via the config->funcs->resize hook.  If TRUE, this
 * function will set virtualX and virtualY to match the initial configuration
 * and leave config->max{Width,Height} alone.  If FALSE, it will bloat
 * virtual[XY] to include the largest modes and set config->max{Width,Height}
 * accordingly.
 */

Bool
xf86InitialConfiguration(ScrnInfoPtr scrn, Bool canGrow)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
    int o, c;
    xf86CrtcPtr *crtcs;
    DisplayModePtr *modes;
    Bool *enabled;
    int width, height;
    int i = scrn->scrnIndex;
    Bool have_outputs = TRUE;
    Bool ret;
    Bool success = FALSE;

    /* Set up the device options */
    config->options = xnfalloc(sizeof(xf86DeviceOptions));
    memcpy(config->options, xf86DeviceOptions, sizeof(xf86DeviceOptions));
    xf86ProcessOptions(scrn->scrnIndex, scrn->options, config->options);
    config->debug_modes = xf86ReturnOptValBool(config->options,
                                               OPTION_MODEDEBUG, FALSE);

    if (scrn->display->virtualX && !scrn->is_gpu)
        width = scrn->display->virtualX;
    else
        width = config->maxWidth;
    if (scrn->display->virtualY && !scrn->is_gpu)
        height = scrn->display->virtualY;
    else
        height = config->maxHeight;

    xf86ProbeOutputModes(scrn, width, height);

    crtcs = xnfcalloc(config->num_output, sizeof(xf86CrtcPtr));
    modes = xnfcalloc(config->num_output, sizeof(DisplayModePtr));
    enabled = xnfcalloc(config->num_output, sizeof(Bool));

    ret = xf86CollectEnabledOutputs(scrn, config, enabled);
    if (ret == FALSE && canGrow) {
        if (!scrn->is_gpu)
            xf86DrvMsg(i, X_WARNING,
		       "Unable to find connected outputs - setting %dx%d "
                       "initial framebuffer\n",
                       NO_OUTPUT_DEFAULT_WIDTH, NO_OUTPUT_DEFAULT_HEIGHT);
        have_outputs = FALSE;
    }
    else {
        if (xf86TargetUserpref(scrn, config, modes, enabled, width, height))
            xf86DrvMsg(i, X_INFO, "Using user preference for initial modes\n");
        else if (xf86TargetRightOf(scrn, config, modes, enabled, width, height))
            xf86DrvMsg(i, X_INFO, "Using spanning desktop for initial modes\n");
        else if (xf86TargetPreferred
                 (scrn, config, modes, enabled, width, height))
            xf86DrvMsg(i, X_INFO, "Using exact sizes for initial modes\n");
        else if (xf86TargetAspect(scrn, config, modes, enabled, width, height))
            xf86DrvMsg(i, X_INFO,
                       "Using fuzzy aspect match for initial modes\n");
        else if (xf86TargetFallback
                 (scrn, config, modes, enabled, width, height))
            xf86DrvMsg(i, X_INFO, "Using sloppy heuristic for initial modes\n");
        else
            xf86DrvMsg(i, X_WARNING, "Unable to find initial modes\n");
    }

    for (o = -1; nextEnabledOutput(config, enabled, &o);) {
        if (!modes[o])
            xf86DrvMsg(scrn->scrnIndex, X_ERROR,
                       "Output %s enabled but has no modes\n",
                       config->output[o]->name);
        else
            xf86DrvMsg (scrn->scrnIndex, X_INFO,
                        "Output %s using initial mode %s +%d+%d\n",
                        config->output[o]->name, modes[o]->name,
                        config->output[o]->initial_x,
                        config->output[o]->initial_y);
    }

    /*
     * Set the position of each output
     */
    if (!xf86InitialOutputPositions(scrn, modes))
        goto bailout;

    /*
     * Set initial panning of each output
     */
    xf86InitialPanning(scrn);

    /*
     * Assign CRTCs to fit output configuration
     */
    if (have_outputs && !xf86PickCrtcs(scrn, crtcs, modes, 0, width, height))
        goto bailout;

    /* XXX override xf86 common frame computation code */

    if (!scrn->is_gpu) {
        scrn->display->frameX0 = 0;
        scrn->display->frameY0 = 0;
    }

    for (c = 0; c < config->num_crtc; c++) {
        xf86CrtcPtr crtc = config->crtc[c];

        crtc->enabled = FALSE;
        memset(&crtc->desiredMode, '\0', sizeof(crtc->desiredMode));
        /* Set default gamma for all crtc's. */
        /* This is done to avoid problems later on with cloned outputs. */
        xf86CrtcSetInitialGamma(crtc, 1.0, 1.0, 1.0);
    }

    if (xf86_crtc_supports_gamma(scrn))
        xf86DrvMsg(scrn->scrnIndex, X_INFO,
                   "Using default gamma of (1.0, 1.0, 1.0) unless otherwise stated.\n");

    /*
     * Set initial configuration
     */
    for (o = 0; o < config->num_output; o++) {
        xf86OutputPtr output = config->output[o];
        DisplayModePtr mode = modes[o];
        xf86CrtcPtr crtc = crtcs[o];

        if (mode && crtc) {
            xf86SaveModeContents(&crtc->desiredMode, mode);
            crtc->desiredRotation = output->initial_rotation;
            crtc->desiredX = output->initial_x;
            crtc->desiredY = output->initial_y;
            crtc->desiredTransformPresent = FALSE;
            crtc->enabled = TRUE;
            memcpy(&crtc->panningTotalArea, &output->initialTotalArea,
                   sizeof(BoxRec));
            memcpy(&crtc->panningTrackingArea, &output->initialTrackingArea,
                   sizeof(BoxRec));
            memcpy(crtc->panningBorder, output->initialBorder,
                   4 * sizeof(INT16));
            output->crtc = crtc;
            if (!xf86OutputSetInitialGamma(output))
                xf86DrvMsg(scrn->scrnIndex, X_WARNING,
                           "Initial gamma correction for output %s: failed.\n",
                           output->name);
        }
        else {
            output->crtc = NULL;
        }
    }

    if (scrn->display->virtualX == 0 || scrn->is_gpu) {
        /*
         * Expand virtual size to cover the current config and potential mode
         * switches, if the driver can't enlarge the screen later.
         */
        xf86DefaultScreenLimits(scrn, &width, &height, canGrow);

        if (have_outputs == FALSE) {
            if (width < NO_OUTPUT_DEFAULT_WIDTH &&
                height < NO_OUTPUT_DEFAULT_HEIGHT) {
                width = NO_OUTPUT_DEFAULT_WIDTH;
                height = NO_OUTPUT_DEFAULT_HEIGHT;
            }
        }

	if (!scrn->is_gpu) {
            scrn->display->virtualX = width;
            scrn->display->virtualY = height;
	}
    }

    if (width > scrn->virtualX)
        scrn->virtualX = width;
    if (height > scrn->virtualY)
        scrn->virtualY = height;

    /*
     * Make sure the configuration isn't too small.
     */
    if (width < config->minWidth || height < config->minHeight)
        goto bailout;

    /*
     * Limit the crtc config to virtual[XY] if the driver can't grow the
     * desktop.
     */
    if (!canGrow) {
        xf86CrtcSetSizeRange(scrn, config->minWidth, config->minHeight,
                             width, height);
    }

    xf86SetScrnInfoModes(scrn);

    success = TRUE;
 bailout:
    free(crtcs);
    free(modes);
    free(enabled);
    return success;
}

/*
 * Check the CRTC we're going to map each output to vs. it's current
 * CRTC.  If they don't match, we have to disable the output and the CRTC
 * since the driver will have to re-route things.
 */
static void
xf86PrepareOutputs(ScrnInfoPtr scrn)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
    int o;

    for (o = 0; o < config->num_output; o++) {
        xf86OutputPtr output = config->output[o];

#if RANDR_GET_CRTC_INTERFACE
        /* Disable outputs that are unused or will be re-routed */
        if (!output->funcs->get_crtc ||
            output->crtc != (*output->funcs->get_crtc) (output) ||
            output->crtc == NULL)
#endif
            (*output->funcs->dpms) (output, DPMSModeOff);
    }
}

static void
xf86PrepareCrtcs(ScrnInfoPtr scrn)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
    int c;

    for (c = 0; c < config->num_crtc; c++) {
#if RANDR_GET_CRTC_INTERFACE
        xf86CrtcPtr crtc = config->crtc[c];
        xf86OutputPtr output = NULL;
        uint32_t desired_outputs = 0, current_outputs = 0;
        int o;

        for (o = 0; o < config->num_output; o++) {
            output = config->output[o];
            if (output->crtc == crtc)
                desired_outputs |= (1 << o);
            /* If we can't tell where it's mapped, force it off */
            if (!output->funcs->get_crtc) {
                desired_outputs = 0;
                break;
            }
            if ((*output->funcs->get_crtc) (output) == crtc)
                current_outputs |= (1 << o);
        }

        /*
         * If mappings are different or the CRTC is unused,
         * we need to disable it
         */
        if (desired_outputs != current_outputs || !desired_outputs)
            (*crtc->funcs->dpms) (crtc, DPMSModeOff);
#else
        (*crtc->funcs->dpms) (crtc, DPMSModeOff);
#endif
    }
}

/*
 * Using the desired mode information in each crtc, set
 * modes (used in EnterVT functions, or at server startup)
 */

Bool
xf86SetDesiredModes(ScrnInfoPtr scrn)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CrtcPtr crtc = config->crtc[0];
    int enabled = 0, failed = 0;
    int c;

    /* A driver with this hook will take care of this */
    if (!crtc->funcs->set_mode_major) {
        xf86PrepareOutputs(scrn);
        xf86PrepareCrtcs(scrn);
    }

    for (c = 0; c < config->num_crtc; c++) {
        xf86OutputPtr output = NULL;
        int o;
        RRTransformPtr transform;

        crtc = config->crtc[c];

        /* Skip disabled CRTCs */
        if (!crtc->enabled)
            continue;

        if (xf86CompatOutput(scrn) && xf86CompatCrtc(scrn) == crtc)
            output = xf86CompatOutput(scrn);
        else {
            for (o = 0; o < config->num_output; o++)
                if (config->output[o]->crtc == crtc) {
                    output = config->output[o];
                    break;
                }
        }
        /* paranoia */
        if (!output)
            continue;

        /* Mark that we'll need to re-set the mode for sure */
        memset(&crtc->mode, 0, sizeof(crtc->mode));
        if (!crtc->desiredMode.CrtcHDisplay) {
            DisplayModePtr mode =
                xf86OutputFindClosestMode(output, scrn->currentMode);

            if (!mode)
                return FALSE;
            xf86SaveModeContents(&crtc->desiredMode, mode);
            crtc->desiredRotation = RR_Rotate_0;
            crtc->desiredTransformPresent = FALSE;
            crtc->desiredX = 0;
            crtc->desiredY = 0;
        }

        if (crtc->desiredTransformPresent)
            transform = &crtc->desiredTransform;
        else
            transform = NULL;
        if (xf86CrtcSetModeTransform
            (crtc, &crtc->desiredMode, crtc->desiredRotation, transform,
             crtc->desiredX, crtc->desiredY)) {
            ++enabled;
        } else {
            for (o = 0; o < config->num_output; o++)
                if (config->output[o]->crtc == crtc)
                    config->output[o]->crtc = NULL;
            crtc->enabled = FALSE;
            ++failed;
	}
    }

    xf86DisableUnusedFunctions(scrn);
    return enabled != 0 || failed == 0;
}

/**
 * In the current world order, there are lists of modes per output, which may
 * or may not include the mode that was asked to be set by XFree86's mode
 * selection.  Find the closest one, in the following preference order:
 *
 * - Equality
 * - Closer in size to the requested mode, but no larger
 * - Closer in refresh rate to the requested mode.
 */

DisplayModePtr
xf86OutputFindClosestMode(xf86OutputPtr output, DisplayModePtr desired)
{
    DisplayModePtr best = NULL, scan = NULL;

    for (scan = output->probed_modes; scan != NULL; scan = scan->next) {
        /* If there's an exact match, we're done. */
        if (xf86ModesEqual(scan, desired)) {
            best = desired;
            break;
        }

        /* Reject if it's larger than the desired mode. */
        if (scan->HDisplay > desired->HDisplay ||
            scan->VDisplay > desired->VDisplay) {
            continue;
        }

        /*
         * If we haven't picked a best mode yet, use the first
         * one in the size range
         */
        if (best == NULL) {
            best = scan;
            continue;
        }

        /* Find if it's closer to the right size than the current best
         * option.
         */
        if ((scan->HDisplay > best->HDisplay &&
             scan->VDisplay >= best->VDisplay) ||
            (scan->HDisplay >= best->HDisplay &&
             scan->VDisplay > best->VDisplay)) {
            best = scan;
            continue;
        }

        /* Find if it's still closer to the right refresh than the current
         * best resolution.
         */
        if (scan->HDisplay == best->HDisplay &&
            scan->VDisplay == best->VDisplay &&
            (fabs(scan->VRefresh - desired->VRefresh) <
             fabs(best->VRefresh - desired->VRefresh))) {
            best = scan;
        }
    }
    return best;
}

/**
 * When setting a mode through XFree86-VidModeExtension or XFree86-DGA,
 * take the specified mode and apply it to the crtc connected to the compat
 * output. Then, find similar modes for the other outputs, as with the
 * InitialConfiguration code above. The goal is to clone the desired
 * mode across all outputs that are currently active.
 */

Bool
xf86SetSingleMode(ScrnInfoPtr pScrn, DisplayModePtr desired, Rotation rotation)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
    Bool ok = TRUE;
    xf86OutputPtr compat_output;
    DisplayModePtr compat_mode = NULL;
    int c;

    /*
     * Let the compat output drive the final mode selection
     */
    compat_output = xf86CompatOutput(pScrn);
    if (compat_output)
        compat_mode = xf86OutputFindClosestMode(compat_output, desired);
    if (compat_mode)
        desired = compat_mode;

    for (c = 0; c < config->num_crtc; c++) {
        xf86CrtcPtr crtc = config->crtc[c];
        DisplayModePtr crtc_mode = NULL;
        int o;

        if (!crtc->enabled)
            continue;

        for (o = 0; o < config->num_output; o++) {
            xf86OutputPtr output = config->output[o];
            DisplayModePtr output_mode;

            /* skip outputs not on this crtc */
            if (output->crtc != crtc)
                continue;

            if (crtc_mode) {
                output_mode = xf86OutputFindClosestMode(output, crtc_mode);
                if (output_mode != crtc_mode)
                    output->crtc = NULL;
            }
            else
                crtc_mode = xf86OutputFindClosestMode(output, desired);
        }
        if (!crtc_mode) {
            crtc->enabled = FALSE;
            continue;
        }
        if (!xf86CrtcSetModeTransform(crtc, crtc_mode, rotation, NULL, 0, 0))
            ok = FALSE;
        else {
            xf86SaveModeContents(&crtc->desiredMode, crtc_mode);
            crtc->desiredRotation = rotation;
            crtc->desiredTransformPresent = FALSE;
            crtc->desiredX = 0;
            crtc->desiredY = 0;
        }
    }
    xf86DisableUnusedFunctions(pScrn);
#ifdef RANDR_12_INTERFACE
    xf86RandR12TellChanged(pScrn->pScreen);
#endif
    return ok;
}

/**
 * Set the DPMS power mode of all outputs and CRTCs.
 *
 * If the new mode is off, it will turn off outputs and then CRTCs.
 * Otherwise, it will affect CRTCs before outputs.
 */
void
xf86DPMSSet(ScrnInfoPtr scrn, int mode, int flags)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
    int i;

    if (!scrn->vtSema)
        return;

    if (mode == DPMSModeOff) {
        for (i = 0; i < config->num_output; i++) {
            xf86OutputPtr output = config->output[i];

            if (output->crtc != NULL)
                (*output->funcs->dpms) (output, mode);
        }
    }

    for (i = 0; i < config->num_crtc; i++) {
        xf86CrtcPtr crtc = config->crtc[i];

        if (crtc->enabled)
            (*crtc->funcs->dpms) (crtc, mode);
    }

    if (mode != DPMSModeOff) {
        for (i = 0; i < config->num_output; i++) {
            xf86OutputPtr output = config->output[i];

            if (output->crtc != NULL)
                (*output->funcs->dpms) (output, mode);
        }
    }
}

/**
 * Implement the screensaver by just calling down into the driver DPMS hooks.
 *
 * Even for monitors with no DPMS support, by the definition of our DPMS hooks,
 * the outputs will still get disabled (blanked).
 */
Bool
xf86SaveScreen(ScreenPtr pScreen, int mode)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);

    if (xf86IsUnblank(mode))
        xf86DPMSSet(pScrn, DPMSModeOn, 0);
    else
        xf86DPMSSet(pScrn, DPMSModeOff, 0);

    return TRUE;
}

/**
 * Disable all inactive crtcs and outputs
 */
void
xf86DisableUnusedFunctions(ScrnInfoPtr pScrn)
{
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int o, c;

    for (o = 0; o < xf86_config->num_output; o++) {
        xf86OutputPtr output = xf86_config->output[o];

        if (!output->crtc)
            (*output->funcs->dpms) (output, DPMSModeOff);
    }

    for (c = 0; c < xf86_config->num_crtc; c++) {
        xf86CrtcPtr crtc = xf86_config->crtc[c];

        if (!crtc->enabled) {
            crtc->funcs->dpms(crtc, DPMSModeOff);
            memset(&crtc->mode, 0, sizeof(crtc->mode));
            xf86RotateDestroy(crtc);
            crtc->active = FALSE;
        }
    }
    if (pScrn->pScreen)
        xf86_crtc_notify(pScrn->pScreen);
    if (pScrn->ModeSet)
        pScrn->ModeSet(pScrn);
    if (pScrn->pScreen) {
        if (pScrn->pScreen->isGPU)
            xf86CursorResetCursor(pScrn->pScreen->current_master);
        else
            xf86CursorResetCursor(pScrn->pScreen);
    }
}

#ifdef RANDR_12_INTERFACE

#define EDID_ATOM_NAME		"EDID"

/**
 * Set the RandR EDID property
 */
static void
xf86OutputSetEDIDProperty(xf86OutputPtr output, void *data, int data_len)
{
    Atom edid_atom = MakeAtom(EDID_ATOM_NAME, sizeof(EDID_ATOM_NAME) - 1, TRUE);

    /* This may get called before the RandR resources have been created */
    if (output->randr_output == NULL)
        return;

    if (data_len != 0) {
        RRChangeOutputProperty(output->randr_output, edid_atom, XA_INTEGER, 8,
                               PropModeReplace, data_len, data, FALSE, TRUE);
    }
    else {
        RRDeleteOutputProperty(output->randr_output, edid_atom);
    }
}

#define TILE_ATOM_NAME		"TILE"
/* changing this in the future could be tricky as people may hardcode 8 */
#define TILE_PROP_NUM_ITEMS		8
static void
xf86OutputSetTileProperty(xf86OutputPtr output)
{
    Atom tile_atom = MakeAtom(TILE_ATOM_NAME, sizeof(TILE_ATOM_NAME) - 1, TRUE);

    /* This may get called before the RandR resources have been created */
    if (output->randr_output == NULL)
        return;

    if (output->tile_info.group_id != 0) {
        RRChangeOutputProperty(output->randr_output, tile_atom, XA_INTEGER, 32,
                               PropModeReplace, TILE_PROP_NUM_ITEMS, (uint32_t *)&output->tile_info, FALSE, TRUE);
    }
    else {
        RRDeleteOutputProperty(output->randr_output, tile_atom);
    }
}

#endif

/* Pull out a phyiscal size from a detailed timing if available. */
struct det_phySize_parameter {
    xf86OutputPtr output;
    ddc_quirk_t quirks;
    Bool ret;
};

static void
handle_detailed_physical_size(struct detailed_monitor_section
                              *det_mon, void *data)
{
    struct det_phySize_parameter *p;

    p = (struct det_phySize_parameter *) data;

    if (p->ret == TRUE)
        return;

    xf86DetTimingApplyQuirks(det_mon, p->quirks,
                             p->output->MonInfo->features.hsize,
                             p->output->MonInfo->features.vsize);
    if (det_mon->type == DT &&
        det_mon->section.d_timings.h_size != 0 &&
        det_mon->section.d_timings.v_size != 0) {
        /* some sanity checking for aspect ratio:
           assume any h / v (or v / h) > 2.4 to be bogus.
           This would even include cinemascope */
        if (((det_mon->section.d_timings.h_size * 5) <
             (det_mon->section.d_timings.v_size * 12)) &&
            ((det_mon->section.d_timings.v_size * 5) <
             (det_mon->section.d_timings.h_size * 12))) {
            p->output->mm_width = det_mon->section.d_timings.h_size;
            p->output->mm_height = det_mon->section.d_timings.v_size;
            p->ret = TRUE;
        } else
            xf86DrvMsg(p->output->scrn->scrnIndex, X_WARNING,
                       "Output %s: Strange aspect ratio (%i/%i), "
                       "consider adding a quirk\n", p->output->name,
                       det_mon->section.d_timings.h_size,
                       det_mon->section.d_timings.v_size);
    }
}

Bool
xf86OutputParseKMSTile(const char *tile_data, int tile_length,
                       struct xf86CrtcTileInfo *tile_info)
{
    int ret;

    ret = sscanf(tile_data, "%d:%d:%d:%d:%d:%d:%d:%d",
                 &tile_info->group_id,
                 &tile_info->flags,
                 &tile_info->num_h_tile,
                 &tile_info->num_v_tile,
                 &tile_info->tile_h_loc,
                 &tile_info->tile_v_loc,
                 &tile_info->tile_h_size,
                 &tile_info->tile_v_size);
    if (ret != 8)
        return FALSE;
    return TRUE;
}

void
xf86OutputSetTile(xf86OutputPtr output, struct xf86CrtcTileInfo *tile_info)
{
    if (tile_info)
        output->tile_info = *tile_info;
    else
        memset(&output->tile_info, 0, sizeof(output->tile_info));
#ifdef RANDR_12_INTERFACE
    xf86OutputSetTileProperty(output);
#endif
}

/**
 * Set the EDID information for the specified output
 */
void
xf86OutputSetEDID(xf86OutputPtr output, xf86MonPtr edid_mon)
{
    ScrnInfoPtr scrn = output->scrn;
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
    Bool debug_modes = config->debug_modes || xf86Initialising;

#ifdef RANDR_12_INTERFACE
    int size;
#endif

    free(output->MonInfo);

    output->MonInfo = edid_mon;
    output->mm_width = 0;
    output->mm_height = 0;

    if (debug_modes) {
        xf86DrvMsg(scrn->scrnIndex, X_INFO, "EDID for output %s\n",
                   output->name);
        xf86PrintEDID(edid_mon);
    }

    /* Set the DDC properties for the 'compat' output */
    /* GPU screens don't have a root window */
    if (output == xf86CompatOutput(scrn) && !scrn->is_gpu)
        xf86SetDDCproperties(scrn, edid_mon);

#ifdef RANDR_12_INTERFACE
    /* Set the RandR output properties */
    size = 0;
    if (edid_mon) {
        if (edid_mon->ver.version == 1) {
            size = 128;
            if (edid_mon->flags & EDID_COMPLETE_RAWDATA)
                size += edid_mon->no_sections * 128;
        }
        else if (edid_mon->ver.version == 2)
            size = 256;
    }
    xf86OutputSetEDIDProperty(output, edid_mon ? edid_mon->rawData : NULL,
                              size);
#endif

    if (edid_mon) {

        struct det_phySize_parameter p;

        p.output = output;
        p.quirks = xf86DDCDetectQuirks(scrn->scrnIndex, edid_mon, FALSE);
        p.ret = FALSE;
        xf86ForEachDetailedBlock(edid_mon, handle_detailed_physical_size, &p);

        /* if no mm size is available from a detailed timing, check the max size field */
        if ((!output->mm_width || !output->mm_height) &&
            (edid_mon->features.hsize && edid_mon->features.vsize)) {
            output->mm_width = edid_mon->features.hsize * 10;
            output->mm_height = edid_mon->features.vsize * 10;
        }
    }
}

/**
 * Return the list of modes supported by the EDID information
 * stored in 'output'
 */
DisplayModePtr
xf86OutputGetEDIDModes(xf86OutputPtr output)
{
    ScrnInfoPtr scrn = output->scrn;
    xf86MonPtr edid_mon = output->MonInfo;

    if (!edid_mon)
        return NULL;
    return xf86DDCGetModes(scrn->scrnIndex, edid_mon);
}

/* maybe we should care about DDC1?  meh. */
xf86MonPtr
xf86OutputGetEDID(xf86OutputPtr output, I2CBusPtr pDDCBus)
{
    ScrnInfoPtr scrn = output->scrn;
    xf86MonPtr mon;

    mon = xf86DoEEDID(scrn, pDDCBus, TRUE);
    if (mon)
        xf86DDCApplyQuirks(scrn->scrnIndex, mon);

    return mon;
}

static const char *_xf86ConnectorNames[] = {
    "None", "VGA", "DVI-I", "DVI-D",
    "DVI-A", "Composite", "S-Video",
    "Component", "LFP", "Proprietary",
    "HDMI", "DisplayPort",
};

const char *
xf86ConnectorGetName(xf86ConnectorType connector)
{
    return _xf86ConnectorNames[connector];
}

static void
x86_crtc_box_intersect(BoxPtr dest, BoxPtr a, BoxPtr b)
{
    dest->x1 = a->x1 > b->x1 ? a->x1 : b->x1;
    dest->x2 = a->x2 < b->x2 ? a->x2 : b->x2;
    dest->y1 = a->y1 > b->y1 ? a->y1 : b->y1;
    dest->y2 = a->y2 < b->y2 ? a->y2 : b->y2;

    if (dest->x1 >= dest->x2 || dest->y1 >= dest->y2)
        dest->x1 = dest->x2 = dest->y1 = dest->y2 = 0;
}

static void
x86_crtc_box(xf86CrtcPtr crtc, BoxPtr crtc_box)
{
    if (crtc->enabled) {
        crtc_box->x1 = crtc->x;
        crtc_box->x2 = crtc->x + xf86ModeWidth(&crtc->mode, crtc->rotation);
        crtc_box->y1 = crtc->y;
        crtc_box->y2 = crtc->y + xf86ModeHeight(&crtc->mode, crtc->rotation);
    }
    else
        crtc_box->x1 = crtc_box->x2 = crtc_box->y1 = crtc_box->y2 = 0;
}

static int
xf86_crtc_box_area(BoxPtr box)
{
    return (int) (box->x2 - box->x1) * (int) (box->y2 - box->y1);
}

#ifdef XV
/*
 * Return the crtc covering 'box'. If two crtcs cover a portion of
 * 'box', then prefer 'desired'. If 'desired' is NULL, then prefer the crtc
 * with greater coverage
 */

static xf86CrtcPtr
xf86_covering_crtc(ScrnInfoPtr pScrn,
                   BoxPtr box, xf86CrtcPtr desired, BoxPtr crtc_box_ret)
{
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    xf86CrtcPtr crtc, best_crtc;
    int coverage, best_coverage;
    int c;
    BoxRec crtc_box, cover_box;

    best_crtc = NULL;
    best_coverage = 0;
    crtc_box_ret->x1 = 0;
    crtc_box_ret->x2 = 0;
    crtc_box_ret->y1 = 0;
    crtc_box_ret->y2 = 0;
    for (c = 0; c < xf86_config->num_crtc; c++) {
        crtc = xf86_config->crtc[c];
        x86_crtc_box(crtc, &crtc_box);
        x86_crtc_box_intersect(&cover_box, &crtc_box, box);
        coverage = xf86_crtc_box_area(&cover_box);
        if (coverage && crtc == desired) {
            *crtc_box_ret = crtc_box;
            return crtc;
        }
        else if (coverage > best_coverage) {
            *crtc_box_ret = crtc_box;
            best_crtc = crtc;
            best_coverage = coverage;
        }
    }
    return best_crtc;
}

/*
 * For overlay video, compute the relevant CRTC and
 * clip video to that.
 *
 * returning FALSE means there was a memory failure of some kind,
 * not that the video shouldn't be displayed
 */

Bool
xf86_crtc_clip_video_helper(ScrnInfoPtr pScrn,
                            xf86CrtcPtr * crtc_ret,
                            xf86CrtcPtr desired_crtc,
                            BoxPtr dst,
                            INT32 *xa,
                            INT32 *xb,
                            INT32 *ya,
                            INT32 *yb, RegionPtr reg, INT32 width, INT32 height)
{
    Bool ret;
    RegionRec crtc_region_local;
    RegionPtr crtc_region = reg;

    if (crtc_ret) {
        BoxRec crtc_box;
        xf86CrtcPtr crtc = xf86_covering_crtc(pScrn, dst,
                                              desired_crtc,
                                              &crtc_box);

        if (crtc) {
            RegionInit(&crtc_region_local, &crtc_box, 1);
            crtc_region = &crtc_region_local;
            RegionIntersect(crtc_region, crtc_region, reg);
        }
        *crtc_ret = crtc;
    }

    ret = xf86XVClipVideoHelper(dst, xa, xb, ya, yb,
                                crtc_region, width, height);

    if (crtc_region != reg)
        RegionUninit(&crtc_region_local);

    return ret;
}
#endif

xf86_crtc_notify_proc_ptr
xf86_wrap_crtc_notify(ScreenPtr screen, xf86_crtc_notify_proc_ptr new)
{
    if (xf86CrtcConfigPrivateIndex != -1) {
        ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
        xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
        xf86_crtc_notify_proc_ptr old;

        old = config->xf86_crtc_notify;
        config->xf86_crtc_notify = new;
        return old;
    }
    return NULL;
}

void
xf86_unwrap_crtc_notify(ScreenPtr screen, xf86_crtc_notify_proc_ptr old)
{
    if (xf86CrtcConfigPrivateIndex != -1) {
        ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
        xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);

        config->xf86_crtc_notify = old;
    }
}

void
xf86_crtc_notify(ScreenPtr screen)
{
    ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);

    if (config->xf86_crtc_notify)
        config->xf86_crtc_notify(screen);
}

Bool
xf86_crtc_supports_gamma(ScrnInfoPtr pScrn)
{
    if (xf86CrtcConfigPrivateIndex != -1) {
        xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
        xf86CrtcPtr crtc;

        /* for multiple drivers loaded we need this */
        if (!xf86_config)
            return FALSE;
        if (xf86_config->num_crtc == 0)
            return FALSE;
        crtc = xf86_config->crtc[0];

        return crtc->funcs->gamma_set != NULL;
    }

    return FALSE;
}

void
xf86ProviderSetup(ScrnInfoPtr scrn,
                  const xf86ProviderFuncsRec *funcs, const char *name)
{
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);

    assert(!xf86_config->name);
    assert(name);

    xf86_config->name = strdup(name);
    xf86_config->provider_funcs = funcs;
#ifdef RANDR_12_INTERFACE
    xf86_config->randr_provider = NULL;
#endif
}

void
xf86DetachAllCrtc(ScrnInfoPtr scrn)
{
        xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
        int i;

        for (i = 0; i < xf86_config->num_crtc; i++) {
            xf86CrtcPtr crtc = xf86_config->crtc[i];

            if (crtc->randr_crtc)
                RRCrtcDetachScanoutPixmap(crtc->randr_crtc);

            /* dpms off */
            (*crtc->funcs->dpms) (crtc, DPMSModeOff);
            /* force a reset the next time its used */
            crtc->randr_crtc->mode = NULL;
            crtc->mode.HDisplay = 0;
            crtc->x = crtc->y = 0;
        }
}
@


1.18
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@d3288 2
a3289 1
    if (output == xf86CompatOutput(scrn))
@


1.17
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d121 1
a121 1
    crtc->gamma_red = malloc(3 * crtc->gamma_size * sizeof(CARD16));
d130 2
a131 2
        crtcs = realloc(xf86_config->crtc,
                        (xf86_config->num_crtc + 1) * sizeof(xf86CrtcPtr));
d133 1
a133 1
        crtcs = malloc((xf86_config->num_crtc + 1) * sizeof(xf86CrtcPtr));
d371 6
d629 3
a631 3
        outputs = realloc(xf86_config->output,
                          (xf86_config->num_output +
                           1) * sizeof(xf86OutputPtr));
d633 2
a634 1
        outputs = malloc((xf86_config->num_output + 1) * sizeof(xf86OutputPtr));
d952 1
a952 1
    crtcs = malloc(config->num_output * sizeof(xf86CrtcPtr));
d1133 9
d2121 112
a2308 1
            int i = 0;
d2312 1
a2312 4
            /* count the number of enabled outputs */
            for (i = 0, p = -1; nextEnabledOutput(config, enabled, &p); i++);

            if (i != 1)
d2461 1
a2461 1
    red = malloc(3 * size * sizeof(CARD16));
d2618 2
d2639 5
a2643 3
            xf86DrvMsg(scrn->scrnIndex, X_INFO,
                       "Output %s using initial mode %s\n",
                       config->output[o]->name, modes[o]->name);
d3130 6
d3163 21
d3227 32
@


1.16
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1075 1
a1075 1
 * check if the user configured any outputs at all 
d1739 1
a1739 1
            /* 
@


1.15
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d188 1
a188 1
    int c, o;
d190 2
a191 2
    for (c = 0; c < xf86_config->num_crtc; c++) {
        xf86CrtcPtr crtc = xf86_config->crtc[c];
d219 1
a219 1
            int c;
d224 2
a225 2
            for (c = 0; c < 4; c++)
                if (circle[c] == subpixel_order)
d227 6
a232 6
            c = (c + rotate) & 0x3;
            if ((crtc->rotation & RR_Reflect_X) && !(c & 1))
                c ^= 2;
            if ((crtc->rotation & RR_Reflect_Y) && (c & 1))
                c ^= 2;
            subpixel_order = circle[c];
d382 1
a382 1
    free(adjusted_mode->name);
d567 2
a568 2
    char *rotate_name = xf86GetOptValString(output->options,
                                            OPTION_ROTATE);
a928 1
    xf86CrtcPtr best_crtc;
a940 1
    best_crtc = NULL;
a993 1
            best_crtc = crtc;
d1087 2
a1088 2
        char *position;
        char *relative_name;
d1145 2
a1146 2
            char *relative_name;
            char *position;
d1306 1
a1306 1
        char *panning = xf86GetOptValString(output->options, OPTION_PANNING);
d1389 1
a1389 1
            free(n->name);
d1403 1
a1403 1
static char *
d1406 1
a1406 1
    char *preferred_mode = NULL;
d1610 1
a1610 1
        char *preferred_mode;
d1676 1
d1689 10
a1843 4
/* XXX where does this function belong? Here? */
void
 xf86RandR12GetOriginalVirtualSize(ScrnInfoPtr scrn, int *x, int *y);

d2151 1
a2151 1
                        Rotation r = output->initial_rotation;
d2153 2
a2154 2
                        if (xf86ModeWidth(mode, r) == pref_width &&
                            xf86ModeHeight(mode, r) == pref_height) {
@


1.14
log
@Update to xserver 1.14.3
@
text
@d431 1
d450 1
d1423 84
d1802 3
d1866 3
d3051 16
a3066 4

        p->output->mm_width = det_mon->section.d_timings.h_size;
        p->output->mm_height = det_mon->section.d_timings.v_size;
        p->ret = TRUE;
@


1.13
log
@Uodate to xserver 1.14.2. Tested by krw@@, shadchin@@, todd@@
@
text
@d1911 8
d2371 1
a2371 1
    if (scrn->display->virtualX)
d2375 1
a2375 1
    if (scrn->display->virtualY)
d2388 5
a2392 3
        xf86DrvMsg(i, X_WARNING,
                   "Unable to find connected outputs - setting %dx%d initial framebuffer\n",
                   NO_OUTPUT_DEFAULT_WIDTH, NO_OUTPUT_DEFAULT_HEIGHT);
d2441 4
a2444 2
    scrn->display->frameX0 = 0;
    scrn->display->frameY0 = 0;
d2492 1
a2492 1
    if (scrn->display->virtualX == 0) {
d2507 4
a2510 2
        scrn->display->virtualX = width;
        scrn->display->virtualY = height;
@


1.12
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d2601 1
a2602 1
    int enabled = 0;
d2662 1
d2667 1
a2667 1
    return enabled != 0;
@


1.11
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d47 1
d49 1
d69 1
d186 1
a186 1
    ScrnInfoPtr scrn = xf86Screens[pScreen->myNum];
d702 1
a702 1
    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d720 1
a720 1
xf86CrtcCloseScreen(int index, ScreenPtr screen)
d722 1
a722 1
    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d730 4
d744 6
a749 3
    xf86RandR12CloseScreen(screen);

    return screen->CloseScreen(index, screen);
d762 1
a762 1
    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d1837 1
a1837 1
    else {
d1842 6
d2073 1
a2073 1
     * biggest mode for its aspect ratio, assuming one exists.
d2079 1
d2093 1
d2095 3
a2097 1
                preferred_match[p] = bestModeForAspect(config, enabled, aspect);
d2457 1
a2457 1
            crtc->desiredMode = *mode;
d2602 1
d2642 1
a2642 1
            crtc->desiredMode = *mode;
d2653 1
a2653 1
        if (!xf86CrtcSetModeTransform
d2655 8
a2662 2
             crtc->desiredX, crtc->desiredY))
            return FALSE;
d2666 1
a2666 1
    return TRUE;
d2787 1
a2787 1
            crtc->desiredMode = *crtc_mode;
d2851 1
a2851 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d3037 1
a3037 1
    mon = xf86DoEEDID(scrn->scrnIndex, pDDCBus, TRUE);
d3179 1
a3179 1
        ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d3194 1
a3194 1
        ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d3204 1
a3204 1
    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d3229 37
@


1.10
log
@Bugfix Update to xserver 1.11.3
@
text
@d58 1
a58 2
xf86CrtcConfigInit (ScrnInfoPtr scrn,
		    const xf86CrtcConfigFuncsRec *funcs)
d60 2
a61 2
    xf86CrtcConfigPtr	config;
    
d63 2
a64 2
	xf86CrtcConfigPrivateIndex = xf86AllocateScrnInfoPrivateIndex();
    config = xnfcalloc (1, sizeof (xf86CrtcConfigRec));
d70 1
a70 1
 
d72 2
a73 3
xf86CrtcSetSizeRange (ScrnInfoPtr scrn,
		      int minWidth, int minHeight,
		      int maxWidth, int maxHeight)
d75 1
a75 1
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
d87 1
a87 2
xf86CrtcCreate (ScrnInfoPtr		scrn,
		const xf86CrtcFuncsRec	*funcs)
d89 2
a90 2
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CrtcPtr		crtc, *crtcs;
d92 1
a92 1
    crtc = calloc(sizeof (xf86CrtcRec), 1);
d94 1
a94 1
	return NULL;
d103 3
a105 3
    pixman_transform_init_identity (&crtc->crtc_to_framebuffer);
    pixman_f_transform_init_identity (&crtc->f_crtc_to_framebuffer);
    pixman_f_transform_init_identity (&crtc->f_framebuffer_to_crtc);
d114 1
a114 1
    memset (&crtc->bounds, '\0', sizeof (crtc->bounds));
d118 1
a118 1
    crtc->gamma_red = malloc(3 * crtc->gamma_size * sizeof (CARD16));
d120 2
a121 2
	free(crtc);
	return NULL;
d127 2
a128 2
	crtcs = realloc(xf86_config->crtc,
			  (xf86_config->num_crtc + 1) * sizeof (xf86CrtcPtr));
d130 5
a134 6
	crtcs = malloc((xf86_config->num_crtc + 1) * sizeof (xf86CrtcPtr));
    if (!crtcs)
    {
	free(crtc->gamma_red);
	free(crtc);
	return NULL;
d142 1
a142 1
xf86CrtcDestroy (xf86CrtcPtr crtc)
d144 3
a146 3
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
    int			c;
    
d149 7
a155 8
	if (xf86_config->crtc[c] == crtc)
	{
	    memmove (&xf86_config->crtc[c],
		     &xf86_config->crtc[c+1],
		     ((xf86_config->num_crtc - (c + 1)) * sizeof(void*)));
	    xf86_config->num_crtc--;
	    break;
	}
a160 1

d166 1
a166 1
xf86CrtcInUse (xf86CrtcPtr crtc)
d168 4
a171 4
    ScrnInfoPtr		pScrn = crtc->scrn;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int			o;
    
d173 2
a174 2
	if (xf86_config->output[o]->crtc == crtc)
	    return TRUE;
d179 1
a179 1
xf86CrtcSetScreenSubpixelOrder (ScreenPtr pScreen)
d181 5
a185 5
    int			subpixel_order = SubPixelUnknown;
    Bool		has_none = FALSE;
    ScrnInfoPtr		scrn = xf86Screens[pScreen->myNum];
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int			c, o;
d187 45
a231 48
    for (c = 0; c < xf86_config->num_crtc; c++)
    {
	xf86CrtcPtr crtc = xf86_config->crtc[c];
	
	for (o = 0; o < xf86_config->num_output; o++)
	{
	    xf86OutputPtr   output = xf86_config->output[o];

	    if (output->crtc == crtc)
	    {
		switch (output->subpixel_order) {
		case SubPixelNone:
		    has_none = TRUE;
		    break;
		case SubPixelUnknown:
		    break;
		default:
		    subpixel_order = output->subpixel_order;
		    break;
		}
	    }
	    if (subpixel_order != SubPixelUnknown)
		break;
	}
	if (subpixel_order != SubPixelUnknown)
	{
	    static const int circle[4] = {
		SubPixelHorizontalRGB,
		SubPixelVerticalRGB,
		SubPixelHorizontalBGR,
		SubPixelVerticalBGR,
	    };
	    int	rotate;
	    int c;
	    for (rotate = 0; rotate < 4; rotate++)
		if (crtc->rotation & (1 << rotate))
		    break;
	    for (c = 0; c < 4; c++)
		if (circle[c] == subpixel_order)
		    break;
	    c = (c + rotate) & 0x3;
	    if ((crtc->rotation & RR_Reflect_X) && !(c & 1))
		c ^= 2;
	    if ((crtc->rotation & RR_Reflect_Y) && (c & 1))
		c ^= 2;
	    subpixel_order = circle[c];
	    break;
	}
d234 2
a235 2
	subpixel_order = SubPixelNone;
    PictureSetSubpixelOrder (pScreen, subpixel_order);
d242 3
a244 2
xf86CrtcSetModeTransform (xf86CrtcPtr crtc, DisplayModePtr mode, Rotation rotation,
			  RRTransformPtr transform, int x, int y)
d246 11
a256 11
    ScrnInfoPtr		scrn = crtc->scrn;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int			i;
    Bool		ret = FALSE;
    Bool		didLock = FALSE;
    DisplayModePtr	adjusted_mode;
    DisplayModeRec	saved_mode;
    int			saved_x, saved_y;
    Rotation		saved_rotation;
    RRTransformRec	saved_transform;
    Bool		saved_transform_present;
d258 1
a258 1
    crtc->enabled = xf86CrtcInUse (crtc);
d261 4
a264 5
    if (!crtc->enabled)
    {
	/* Check everything for stuff that should be off. */
	xf86DisableUnusedFunctions(scrn);
	return TRUE;
a268 1

d274 2
a275 2
	RRTransformInit (&saved_transform);
	RRTransformCopy (&saved_transform, &crtc->transform);
d287 5
a291 4
	RRTransformCopy (&crtc->transform, transform);
	crtc->transformPresent = TRUE;
    } else
	crtc->transformPresent = FALSE;
d294 2
a295 2
	ret = crtc->funcs->set_mode_major(crtc, mode, rotation, x, y);
	goto done;
d298 1
a298 1
    didLock = crtc->funcs->lock (crtc);
d304 1
a304 1
	xf86OutputPtr output = xf86_config->output[i];
d306 2
a307 2
	if (output->crtc != crtc)
	    continue;
d309 3
a311 3
	if (!output->funcs->mode_fixup(output, mode, adjusted_mode)) {
	    goto done;
	}
d315 1
a315 1
	goto done;
d318 2
a319 2
    if (!xf86CrtcRotate (crtc))
	goto done;
d323 1
a323 1
	xf86OutputPtr output = xf86_config->output[i];
d325 2
a326 2
	if (output->crtc != crtc)
	    continue;
d328 2
a329 2
	/* Disable the output as the first thing we do. */
	output->funcs->prepare(output);
d338 5
a342 5
    for (i = 0; i < xf86_config->num_output; i++) 
    {
	xf86OutputPtr output = xf86_config->output[i];
	if (output->crtc == crtc)
	    output->funcs->mode_set(output, mode, adjusted_mode);
d347 2
a348 2
	crtc->funcs->gamma_set(crtc, crtc->gamma_red, crtc->gamma_green,
                                            crtc->gamma_blue, crtc->gamma_size);
d352 5
a356 5
    for (i = 0; i < xf86_config->num_output; i++) 
    {
	xf86OutputPtr output = xf86_config->output[i];
	if (output->crtc == crtc)
	    output->funcs->commit(output);
d361 1
a361 1
done:
d363 14
a376 13
	crtc->active = TRUE;
	if (scrn->pScreen)
	    xf86CrtcSetScreenSubpixelOrder (scrn->pScreen);
	if (scrn->ModeSet)
	    scrn->ModeSet(scrn);
    } else {
	crtc->x = saved_x;
	crtc->y = saved_y;
	crtc->rotation = saved_rotation;
	crtc->mode = saved_mode;
	if (saved_transform_present)
	    RRTransformCopy (&crtc->transform, &saved_transform);
	crtc->transformPresent = saved_transform_present;
d383 1
a383 1
	crtc->funcs->unlock (crtc);
d393 2
a394 2
xf86CrtcSetMode (xf86CrtcPtr crtc, DisplayModePtr mode, Rotation rotation,
		 int x, int y)
d396 1
a396 1
    return xf86CrtcSetModeTransform (crtc, mode, rotation, NULL, x, y);
d403 1
a403 1
xf86CrtcSetOrigin (xf86CrtcPtr crtc, int x, int y)
d410 5
a414 5
	if (!xf86CrtcRotate (crtc))
	    return;
	crtc->funcs->set_origin (crtc, x, y);
	if (scrn->ModeSet)
	    scrn->ModeSet(scrn);
d417 1
a417 1
	xf86CrtcSetMode (crtc, &crtc->mode, crtc->rotation, x, y);
d445 16
a460 16
    {OPTION_PREFERRED_MODE, "PreferredMode",	OPTV_STRING,  {0}, FALSE },
    {OPTION_POSITION,	    "Position",		OPTV_STRING,  {0}, FALSE },
    {OPTION_BELOW,	    "Below",		OPTV_STRING,  {0}, FALSE },
    {OPTION_RIGHT_OF,	    "RightOf",		OPTV_STRING,  {0}, FALSE },
    {OPTION_ABOVE,	    "Above",		OPTV_STRING,  {0}, FALSE },
    {OPTION_LEFT_OF,	    "LeftOf",		OPTV_STRING,  {0}, FALSE },
    {OPTION_ENABLE,	    "Enable",		OPTV_BOOLEAN, {0}, FALSE },
    {OPTION_DISABLE,	    "Disable",		OPTV_BOOLEAN, {0}, FALSE },
    {OPTION_MIN_CLOCK,	    "MinClock",		OPTV_FREQ,    {0}, FALSE },
    {OPTION_MAX_CLOCK,	    "MaxClock",		OPTV_FREQ,    {0}, FALSE },
    {OPTION_IGNORE,	    "Ignore",		OPTV_BOOLEAN, {0}, FALSE },
    {OPTION_ROTATE,	    "Rotate",		OPTV_STRING,  {0}, FALSE },
    {OPTION_PANNING,	    "Panning",		OPTV_STRING,  {0}, FALSE },
    {OPTION_PRIMARY,	    "Primary",		OPTV_BOOLEAN, {0}, FALSE },
    {OPTION_DEFAULT_MODES,  "DefaultModes",	OPTV_BOOLEAN, {0}, FALSE },
    {-1,		    NULL,		OPTV_NONE,    {0}, FALSE },
d468 2
a469 2
    {OPTION_MODEDEBUG,	    "ModeDebug",	OPTV_BOOLEAN,  {0}, FALSE },
    {-1,		    NULL,		OPTV_NONE,    {0}, FALSE },
d473 1
a473 1
xf86OutputSetMonitor (xf86OutputPtr output)
d475 2
a476 2
    char    *option_name;
    char    *monitor;
d479 1
a479 1
	return;
d483 2
a484 2
    output->options = xnfalloc (sizeof (xf86OutputOptions));
    memcpy (output->options, xf86OutputOptions, sizeof (xf86OutputOptions));
d487 1
a487 1
    monitor = xf86findOptionValue (output->scrn->options, option_name);
d489 1
a489 1
	monitor = output->name;
d491 1
a491 1
	xf86MarkOptionUsedByName (output->scrn->options, option_name);
d493 2
a494 2
    output->conf_monitor = xf86findMonitor (monitor,
					    xf86configptr->conf_monitor_lst);
d499 9
a507 10
	output->conf_monitor = xf86findMonitor (output->scrn->monitor->id,
						xf86configptr->conf_monitor_lst);
    if (output->conf_monitor)
    {
	xf86DrvMsg (output->scrn->scrnIndex, X_INFO,
		    "Output %s using monitor section %s\n",
		    output->name, output->conf_monitor->mon_identifier);
	xf86ProcessOptions (output->scrn->scrnIndex,
			    output->conf_monitor->mon_option_lst,
			    output->options);
d510 2
a511 3
	xf86DrvMsg (output->scrn->scrnIndex, X_INFO,
		    "Output %s has no monitor section\n",
		    output->name);
d515 1
a515 1
xf86OutputEnabled (xf86OutputPtr output, Bool strict)
d517 1
a517 1
    Bool    enable, disable;
d520 4
a523 5
    if (xf86GetOptValBool (output->options, OPTION_ENABLE, &enable) && enable)
    {
	xf86DrvMsg (output->scrn->scrnIndex, X_INFO,
		    "Output %s enabled by config file\n", output->name);
	return TRUE;
d526 4
a529 5
    if (xf86GetOptValBool (output->options, OPTION_DISABLE, &disable) && disable)
    {
	xf86DrvMsg (output->scrn->scrnIndex, X_INFO,
		    "Output %s disabled by config file\n", output->name);
	return FALSE;
d534 1
a534 1
	enable = output->status == XF86OutputStatusConnected;
d538 1
a538 1
	enable = output->status != XF86OutputStatusDisconnected;
d541 2
a542 2
    xf86DrvMsg (output->scrn->scrnIndex, X_INFO,
    	    "Output %s %sconnected\n", output->name, enable ? "" : "dis");
d547 1
a547 1
xf86OutputIgnored (xf86OutputPtr    output)
d549 1
a549 1
    return xf86ReturnOptValBool (output->options, OPTION_IGNORE, FALSE);
d552 4
a555 4
static char *direction[4] = {
    "normal", 
    "left", 
    "inverted", 
d560 1
a560 1
xf86OutputInitialRotation (xf86OutputPtr output)
d562 3
a564 3
    char    *rotate_name = xf86GetOptValString (output->options, 
						OPTION_ROTATE);
    int	    i;
d567 3
a569 3
	if (output->initial_rotation)
	    return output->initial_rotation;
	return RR_Rotate_0;
d571 1
a571 1
    
d573 2
a574 2
	if (xf86nameCompare (direction[i], rotate_name) == 0)
	    return 1 << i;
d579 7
a585 8
xf86OutputCreate (ScrnInfoPtr		    scrn,
		  const xf86OutputFuncsRec  *funcs,
		  const char		    *name)
{
    xf86OutputPtr	output, *outputs;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int			len;
    Bool		primary;
d588 1
a588 1
	len = strlen (name) + 1;
d590 1
a590 1
	len = 0;
d592 1
a592 1
    output = calloc(sizeof (xf86OutputRec) + len, 1);
d594 1
a594 1
	return NULL;
d597 3
a599 4
    if (name)
    {
	output->name = (char *) (output + 1);
	strcpy (output->name, name);
d609 6
a614 8
    if (name)
    {
	xf86OutputSetMonitor (output);
	if (xf86OutputIgnored (output))
	{
	    free(output);
	    return FALSE;
	}
d616 1
a616 2
    
    
d618 3
a620 2
	outputs = realloc(xf86_config->output,
			  (xf86_config->num_output + 1) * sizeof (xf86OutputPtr));
d622 4
a625 5
	outputs = malloc((xf86_config->num_output + 1) * sizeof (xf86OutputPtr));
    if (!outputs)
    {
	free(output);
	return NULL;
d630 4
a633 5
    if (xf86GetOptValBool (output->options, OPTION_PRIMARY, &primary) && primary)
    {
	memmove(xf86_config->output + 1, xf86_config->output,
		xf86_config->num_output * sizeof (xf86OutputPtr));
	xf86_config->output[0] = output;
d635 2
a636 3
    else
    {
	xf86_config->output[xf86_config->num_output] = output;
d645 1
a645 1
xf86OutputRename (xf86OutputPtr output, const char *name)
d647 2
a648 2
    char    *newname = strdup(name);
    
d650 2
a651 2
	return FALSE;	/* so sorry... */
    
d653 1
a653 1
	free(output->name);
d655 3
a657 3
    xf86OutputSetMonitor (output);
    if (xf86OutputIgnored (output))
	return FALSE;
d662 1
a662 1
xf86OutputUseScreenMonitor (xf86OutputPtr output, Bool use_screen_monitor)
d664 3
a666 4
    if (use_screen_monitor != output->use_screen_monitor)
    {
	output->use_screen_monitor = use_screen_monitor;
	xf86OutputSetMonitor (output);
d671 1
a671 1
xf86OutputDestroy (xf86OutputPtr output)
d673 4
a676 4
    ScrnInfoPtr		scrn = output->scrn;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int			o;
    
d679 1
a679 1
	xf86DeleteMode (&output->probed_modes, output->probed_modes);
d681 7
a687 8
	if (xf86_config->output[o] == output)
	{
	    memmove (&xf86_config->output[o],
		     &xf86_config->output[o+1],
		     ((xf86_config->num_output - (o + 1)) * sizeof(void*)));
	    xf86_config->num_output--;
	    break;
	}
d689 1
a689 1
	free(output->name);
d697 1
a697 1
xf86CrtcCreateScreenResources (ScreenPtr screen)
d699 2
a700 2
    ScrnInfoPtr		scrn = xf86Screens[screen->myNum];
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
a702 3
    
    if (!(*screen->CreateScreenResources)(screen))
	return FALSE;
d704 5
a708 2
    if (!xf86RandR12CreateScreenResources (screen))
	return FALSE;
d717 1
a717 1
xf86CrtcCloseScreen (int index, ScreenPtr screen)
d719 4
a722 4
    ScrnInfoPtr		scrn = xf86Screens[screen->myNum];
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
    int			o, c;
    
d725 1
a725 1
    xf86RotateCloseScreen (screen);
d727 2
a728 3
    for (o = 0; o < config->num_output; o++)
    {
	xf86OutputPtr	output = config->output[o];
d730 1
a730 1
	output->randr_output = NULL;
d732 2
a733 3
    for (c = 0; c < config->num_crtc; c++)
    {
	xf86CrtcPtr	crtc = config->crtc[c];
d735 1
a735 1
	crtc->randr_crtc = NULL;
d737 1
a737 1
    xf86RandR12CloseScreen (screen);
d739 1
a739 1
    return screen->CloseScreen (index, screen);
d750 1
a750 1
xf86CrtcScreenInit (ScreenPtr screen)
d752 3
a754 3
    ScrnInfoPtr		scrn = xf86Screens[screen->myNum];
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
    int			c;
d757 4
a760 3
    xf86DrvMsg(scrn->scrnIndex, X_INFO, "RandR 1.2 enabled, ignore the following RandR disabled message.\n");
    xf86DisableRandR(); /* Disable old RandR extension support */
    xf86RandR12Init (screen);
d763 5
a767 12
    for (c = 0; c < config->num_crtc; c++)
    {
	xf86CrtcPtr crtc = config->crtc[c];
	if (!crtc->funcs->shadow_allocate || !crtc->funcs->shadow_create)
	    break;
    }
    if (c == config->num_crtc)
    {
	xf86RandR12SetRotations (screen, RR_Rotate_0 | RR_Rotate_90 |
				 RR_Rotate_180 | RR_Rotate_270 |
				 RR_Reflect_X | RR_Reflect_Y);
	xf86RandR12SetTransformSupport (screen, TRUE);
d769 9
a777 4
    else
    {
	xf86RandR12SetRotations (screen, RR_Rotate_0);
	xf86RandR12SetTransformSupport (screen, FALSE);
d779 1
a779 1
    
d786 4
a789 1
    
d801 1
a801 1
xf86DefaultMode (xf86OutputPtr output, int width, int height)
d803 6
a808 6
    DisplayModePtr  target_mode = NULL;
    DisplayModePtr  mode;
    int		    target_diff = 0;
    int		    target_preferred = 0;
    int		    mm_height;
    
d811 1
a811 1
	mm_height = (768 * 25.4) / DEFAULT_DPI;
d815 20
a834 22
    for (mode = output->probed_modes; mode; mode = mode->next)
    {
	int	    dpi;
	int	    preferred = (((mode->type & M_T_PREFERRED) != 0) +
				 ((mode->type & M_T_USERPREF) != 0));
	int	    diff;

	if (xf86ModeWidth (mode, output->initial_rotation) > width ||
	    xf86ModeHeight (mode, output->initial_rotation) > height)
	    continue;
	
	/* yes, use VDisplay here, not xf86ModeHeight */
	dpi = (mode->VDisplay * 254) / (mm_height * 10);
	diff = dpi - DEFAULT_DPI;
	diff = diff < 0 ? -diff : diff;
	if (target_mode == NULL || (preferred > target_preferred) ||
	    (preferred == target_preferred && diff < target_diff))
	{
	    target_mode = mode;
	    target_diff = diff;
	    target_preferred = preferred;
	}
d840 8
a847 8
xf86ClosestMode (xf86OutputPtr output, 
		 DisplayModePtr match, Rotation match_rotation,
		 int width, int height)
{
    DisplayModePtr  target_mode = NULL;
    DisplayModePtr  mode;
    int		    target_diff = 0;
    
d851 24
a874 22
    for (mode = output->probed_modes; mode; mode = mode->next)
    {
	int	    dx, dy;
	int	    diff;

	if (xf86ModeWidth (mode, output->initial_rotation) > width ||
	    xf86ModeHeight (mode, output->initial_rotation) > height)
	    continue;
	
	/* exact matches are preferred */
	if (output->initial_rotation == match_rotation &&
	    xf86ModesEqual (mode, match))
	    return mode;
	
	dx = xf86ModeWidth (match, match_rotation) - xf86ModeWidth (mode, output->initial_rotation);
	dy = xf86ModeHeight (match, match_rotation) - xf86ModeHeight (mode, output->initial_rotation);
	diff = dx * dx + dy * dy;
	if (target_mode == NULL || diff < target_diff)
	{
	    target_mode = mode;
	    target_diff = diff;
	}
d880 1
a880 1
xf86OutputHasPreferredMode (xf86OutputPtr output, int width, int height)
d882 1
a882 1
    DisplayModePtr  mode;
d884 4
a887 5
    for (mode = output->probed_modes; mode; mode = mode->next)
    {
	if (xf86ModeWidth (mode, output->initial_rotation) > width ||
	    xf86ModeHeight (mode, output->initial_rotation) > height)
	    continue;
d889 2
a890 2
	if (mode->type & M_T_PREFERRED)
	    return mode;
d896 1
a896 1
xf86OutputHasUserPreferredMode (xf86OutputPtr output)
d901 2
a902 2
	if (mode->type & M_T_USERPREF)
	    return mode;
d908 14
a921 17
xf86PickCrtcs (ScrnInfoPtr	scrn,
	       xf86CrtcPtr	*best_crtcs,
	       DisplayModePtr	*modes,
	       int		n,
	       int		width,
	       int		height)
{
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
    int		    c, o;
    xf86OutputPtr   output;
    xf86CrtcPtr	    crtc;
    xf86CrtcPtr	    *crtcs;
    xf86CrtcPtr	    best_crtc;
    int		    best_score;
    int		    score;
    int		    my_score;
    
d923 1
a923 1
	return 0;
d925 1
a925 1
    
d931 1
a931 1
    best_score = xf86PickCrtcs (scrn, best_crtcs, modes, n+1, width, height);
d933 3
a935 3
	return best_score;
    
    crtcs = malloc(config->num_output * sizeof (xf86CrtcPtr));
d937 1
a937 1
	return best_score;
d942 1
a942 1
	my_score++;
d944 2
a945 2
    if (xf86OutputHasPreferredMode (output, width, height))
	my_score++;
d951 37
a987 39
    for (c = 0; c < config->num_crtc; c++)
    {
	if ((output->possible_crtcs & (1 << c)) == 0)
	    continue;
	
	crtc = config->crtc[c];
	/*
	 * Check to see if some other output is
	 * using this crtc
	 */
	for (o = 0; o < n; o++)
	    if (best_crtcs[o] == crtc)
		break;
	if (o < n)
	{
	    /*
	     * If the two outputs desire the same mode,
	     * see if they can be cloned
	     */
	    if (xf86ModesEqual (modes[o], modes[n]) &&
		config->output[o]->initial_rotation == config->output[n]->initial_rotation &&
		config->output[o]->initial_x == config->output[n]->initial_x &&
		config->output[o]->initial_y == config->output[n]->initial_y)
	    {
		if ((output->possible_clones & (1 << o)) == 0)
		    continue;		/* nope, try next CRTC */
	    }
	    else
		continue;		/* different modes, can't clone */
	}
	crtcs[n] = crtc;
	memcpy (crtcs, best_crtcs, n * sizeof (xf86CrtcPtr));
	score = my_score + xf86PickCrtcs (scrn, crtcs, modes, n+1, width, height);
	if (score > best_score)
	{
	    best_crtc = crtc;
	    best_score = score;
	    memcpy (best_crtcs, crtcs, config->num_output * sizeof (xf86CrtcPtr));
	}
a992 1

d1003 2
a1004 2
xf86DefaultScreenLimits (ScrnInfoPtr scrn, int *widthp, int *heightp,
			 Bool canGrow)
d1006 53
a1058 48
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
    int	    width = 0, height = 0;
    int	    o;
    int	    c;
    int	    s;

    for (c = 0; c < config->num_crtc; c++)
    {
	int	    crtc_width = 0, crtc_height = 0;
	xf86CrtcPtr crtc = config->crtc[c];

	if (crtc->enabled)
	{
	    crtc_width = crtc->desiredX + xf86ModeWidth (&crtc->desiredMode, crtc->desiredRotation);
	    crtc_height = crtc->desiredY + xf86ModeHeight (&crtc->desiredMode, crtc->desiredRotation);
	}
	if (!canGrow) {
	    for (o = 0; o < config->num_output; o++)
	    {
		xf86OutputPtr   output = config->output[o];

		for (s = 0; s < config->num_crtc; s++)
		    if (output->possible_crtcs & (1 << s))
		    {
			DisplayModePtr  mode;
			for (mode = output->probed_modes; mode; mode = mode->next)
			{
			    if (mode->HDisplay > crtc_width)
				crtc_width = mode->HDisplay;
			    if (mode->VDisplay > crtc_width)
				crtc_width = mode->VDisplay;
			    if (mode->VDisplay > crtc_height)
				crtc_height = mode->VDisplay;
			    if (mode->HDisplay > crtc_height)
				crtc_height = mode->HDisplay;
			}
		    }
	    }
	}
	if (crtc_width > width)
	    width = crtc_width;
	if (crtc_height > height)
	    height = crtc_height;
    }
    if (config->maxWidth && width > config->maxWidth) width = config->maxWidth;
    if (config->maxHeight && height > config->maxHeight) height = config->maxHeight;
    if (config->minWidth && width < config->minWidth) width = config->minWidth;
    if (config->minHeight && height < config->minHeight) height = config->minHeight;
d1070 1
a1070 1
xf86UserConfiguredOutputs(ScrnInfoPtr scrn, DisplayModePtr *modes)
d1072 1
a1072 1
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
d1076 29
a1104 32
    for (o = 0; o < config->num_output; o++)
    {
	xf86OutputPtr output = config->output[o];
	char	    *position;
	char	    *relative_name;
	OutputOpts	    relation;
	int r;
	static const OutputOpts	relations[] = {
	    OPTION_BELOW, OPTION_RIGHT_OF, OPTION_ABOVE, OPTION_LEFT_OF
	};

	position = xf86GetOptValString (output->options,
					OPTION_POSITION);
	if (position)
	    user_conf = TRUE;

	relation = 0;
	relative_name = NULL;
	for (r = 0; r < 4; r++)
	{
	    relation = relations[r];
	    relative_name = xf86GetOptValString (output->options,
						     relation);
	    if (relative_name)
		break;
	}
	if (relative_name)
	    user_conf = TRUE;

	modes[o] = xf86OutputHasUserPreferredMode(output);
	if (modes[o])
	    user_conf = TRUE;
d1111 1
a1111 1
xf86InitialOutputPositions (ScrnInfoPtr scrn, DisplayModePtr *modes)
d1113 6
a1118 7
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
    int			o;
    int			min_x, min_y;
    
    for (o = 0; o < config->num_output; o++)
    {
	xf86OutputPtr	output = config->output[o];
d1120 1
a1120 1
	output->initial_x = output->initial_y = POSITION_UNSET;
d1122 1
a1122 1
    
d1126 138
a1263 150
    for (;;)
    {
	Bool	any_set = FALSE;
	Bool	keep_going = FALSE;

	for (o = 0; o < config->num_output; o++)	
	{
	    static const OutputOpts	relations[] = {
		OPTION_BELOW, OPTION_RIGHT_OF, OPTION_ABOVE, OPTION_LEFT_OF
	    };
	    xf86OutputPtr   output = config->output[o];
	    xf86OutputPtr   relative;
	    char	    *relative_name;
	    char	    *position;
	    OutputOpts	    relation;
	    int		    r;

	    if (output->initial_x != POSITION_UNSET)
		continue;
	    position = xf86GetOptValString (output->options,
					    OPTION_POSITION);
	    /*
	     * Absolute position wins
	     */
	    if (position)
	    {
		int		    x, y;
		if (sscanf (position, "%d %d", &x, &y) == 2)
		{
		    output->initial_x = x;
		    output->initial_y = y;
		}
		else
		{
		    xf86DrvMsg (scrn->scrnIndex, X_ERROR,
				"Output %s position not of form \"x y\"\n",
				output->name);
		    output->initial_x = output->initial_y = 0;
		}
		any_set = TRUE;
		continue;
	    }
	    /*
	     * Next comes relative positions
	     */
	    relation = 0;
	    relative_name = NULL;
	    for (r = 0; r < 4; r++)
	    {
		relation = relations[r];
		relative_name = xf86GetOptValString (output->options,
						     relation);
		if (relative_name)
		    break;
	    }
	    if (relative_name)
	    {
		int or;
		relative = NULL;
		for (or = 0; or < config->num_output; or++)
		{
		    xf86OutputPtr	out_rel = config->output[or];
		    XF86ConfMonitorPtr	rel_mon = out_rel->conf_monitor;

		    if (rel_mon)
		    {
			if (xf86nameCompare (rel_mon->mon_identifier,
					      relative_name) == 0)
			{
			    relative = config->output[or];
			    break;
			}
		    }
		    if (strcmp (out_rel->name, relative_name) == 0)
		    {
			relative = config->output[or];
			break;
		    }
		}
		if (!relative)
		{
		    xf86DrvMsg (scrn->scrnIndex, X_ERROR,
				"Cannot position output %s relative to unknown output %s\n",
				output->name, relative_name);
		    output->initial_x = 0;
		    output->initial_y = 0;
		    any_set = TRUE;
		    continue;
		}
		if (!modes[or])
		{
		    xf86DrvMsg (scrn->scrnIndex, X_ERROR,
				"Cannot position output %s relative to output %s without modes\n",
				output->name, relative_name);
		    output->initial_x = 0;
		    output->initial_y = 0;
		    any_set = TRUE;
		    continue;
		}
		if (relative->initial_x == POSITION_UNSET)
		{
		    keep_going = TRUE;
		    continue;
		}
		output->initial_x = relative->initial_x;
		output->initial_y = relative->initial_y;
		switch (relation) {
		case OPTION_BELOW:
		    output->initial_y += xf86ModeHeight (modes[or], relative->initial_rotation);
		    break;
		case OPTION_RIGHT_OF:
		    output->initial_x += xf86ModeWidth (modes[or], relative->initial_rotation);
		    break;
		case OPTION_ABOVE:
		    if (modes[o])
			output->initial_y -= xf86ModeHeight (modes[o], output->initial_rotation);
		    break;
		case OPTION_LEFT_OF:
		    if (modes[o])
			output->initial_x -= xf86ModeWidth (modes[o], output->initial_rotation);
		    break;
		default:
		    break;
		}
		any_set = TRUE;
		continue;
	    }
	    
	    /* Nothing set, just stick them at 0,0 */
	    output->initial_x = 0;
	    output->initial_y = 0;
	    any_set = TRUE;
	}
	if (!keep_going)
	    break;
	if (!any_set) 
	{
	    for (o = 0; o < config->num_output; o++)
	    {
		xf86OutputPtr   output = config->output[o];
		if (output->initial_x == POSITION_UNSET)
		{
		    xf86DrvMsg (scrn->scrnIndex, X_ERROR,
				"Output position loop. Moving %s to 0,0\n",
				output->name);
		    output->initial_x = output->initial_y = 0;
		    break;
		}
	    }
	}
d1271 2
a1272 3
    for (o = 0; o < config->num_output; o++)
    {
	xf86OutputPtr	output = config->output[o];
d1274 4
a1277 4
	if (output->initial_x < min_x)
	    min_x = output->initial_x;
	if (output->initial_y < min_y)
	    min_y = output->initial_y;
a1278 4
    
    for (o = 0; o < config->num_output; o++)
    {
	xf86OutputPtr	output = config->output[o];
d1280 5
a1284 2
	output->initial_x -= min_x;
	output->initial_y -= min_y;
d1290 1
a1290 1
xf86InitialPanning (ScrnInfoPtr scrn)
d1292 46
a1337 47
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
    int			o;
    
    for (o = 0; o < config->num_output; o++)
    {
	xf86OutputPtr	output = config->output[o];
	char	       *panning = xf86GetOptValString (output->options, OPTION_PANNING);
	int		width, height, left, top;
	int		track_width, track_height, track_left, track_top;
	int		brdr[4];

	memset (&output->initialTotalArea,    0, sizeof(BoxRec));
	memset (&output->initialTrackingArea, 0, sizeof(BoxRec));
	memset (output->initialBorder,        0, 4*sizeof(INT16));

	if (! panning)
	    continue;

	switch (sscanf (panning, "%dx%d+%d+%d/%dx%d+%d+%d/%d/%d/%d/%d",
			&width, &height, &left, &top,
			&track_width, &track_height, &track_left, &track_top,
			&brdr[0], &brdr[1], &brdr[2], &brdr[3])) {
	case 12:
	    output->initialBorder[0] = brdr[0];
	    output->initialBorder[1] = brdr[1];
	    output->initialBorder[2] = brdr[2];
	    output->initialBorder[3] = brdr[3];
	    /* fall through */
	case 8:
	    output->initialTrackingArea.x1 = track_left;
	    output->initialTrackingArea.y1 = track_top;
	    output->initialTrackingArea.x2 = track_left + track_width;
	    output->initialTrackingArea.y2 = track_top  + track_height;
	    /* fall through */
	case 4:
	    output->initialTotalArea.x1 = left;
	    output->initialTotalArea.y1 = top;
	    /* fall through */
	case 2:
	    output->initialTotalArea.x2 = output->initialTotalArea.x1 + width;
	    output->initialTotalArea.y2 = output->initialTotalArea.y1 + height;
	    break;
	default:
	    xf86DrvMsg (scrn->scrnIndex, X_ERROR,
			"Broken panning specification '%s' for output %s in config file\n",
			panning, output->name);
	}
d1344 1
a1344 1
xf86ModeCompare (DisplayModePtr a, DisplayModePtr b)
d1346 1
a1346 1
    int	diff;
d1350 1
a1350 1
	return diff;
d1353 1
a1353 1
	return diff;
d1362 1
a1362 1
xf86SortModes (DisplayModePtr input)
d1364 1
a1364 1
    DisplayModePtr  output = NULL, i, o, n, *op, prev;
d1367 8
a1374 9
    while (input)
    {
	i = input;
	input = input->next;
	for (op = &output; (o = *op); op = &o->next)
	    if (xf86ModeCompare (o, i) > 0)
		break;
	i->next = *op;
	*op = i;
d1377 7
a1383 9
    for (o = output; o && (n = o->next); o = n)
    {
	if (!strcmp (o->name, n->name) && xf86ModesEqual (o, n))
	{
	    o->next = n->next;
	    free(n->name);
	    free(n);
	    n = o;
	}
d1387 3
a1389 4
    for (o = output; o; o = o->next)
    {
	o->prev = prev;
	prev = o;
d1400 2
a1401 2
    preferred_mode = xf86GetOptValString (output->options,
					  OPTION_PREFERRED_MODE);
d1403 1
a1403 1
	return preferred_mode;
d1406 1
a1406 1
	preferred_mode = *pScrn->display->modes;
d1415 1
a1415 1
       return;
d1426 2
a1427 2
	if (!mode->HSync)
	    mode->HSync = ((float) mode->Clock ) / ((float) mode->HTotal);
d1429 3
a1431 3
	if (!mode->VRefresh)
	    mode->VRefresh = (1000.0 * ((float) mode->Clock)) / 
		((float) (mode->HTotal * mode->VTotal));
d1433 2
a1434 2
	if (mode->HSync < mon->hsync[0].lo)
	    mon->hsync[0].lo = mode->HSync;
d1436 2
a1437 2
	if (mode->HSync > mon->hsync[0].hi)
	    mon->hsync[0].hi = mode->HSync;
d1439 2
a1440 2
	if (mode->VRefresh < mon->vrefresh[0].lo)
	    mon->vrefresh[0].lo = mode->VRefresh;
d1442 2
a1443 2
	if (mode->VRefresh > mon->vrefresh[0].hi)
	    mon->vrefresh[0].hi = mode->VRefresh;
d1445 1
a1445 1
	mode = mode->next;
d1450 1
a1450 1
       mon->hsync[0].lo = 31.0;
d1452 1
a1452 1
       mon->vrefresh[0].lo = 58.0;
d1467 2
a1468 2
static void handle_detailed_monrec(struct detailed_monitor_section *det_mon,
                                   void *data)
d1471 2
a1472 1
    p = (struct det_monrec_parameter *)data;
d1476 1
d1497 1
a1497 1
xf86ProbeOutputModes (ScrnInfoPtr scrn, int maxX, int maxY)
d1499 2
a1500 2
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
    int			o;
d1508 2
a1509 2
	maxX = config->maxWidth;
	maxY = config->maxHeight;
d1513 154
a1666 70
    for (o = 0; o < config->num_output; o++) 
    {
	xf86OutputPtr	    output = config->output[o];
	DisplayModePtr	    mode;
	DisplayModePtr	    config_modes = NULL, output_modes, default_modes = NULL;
	char		    *preferred_mode;
	xf86MonPtr	    edid_monitor;
	XF86ConfMonitorPtr  conf_monitor;
	MonRec		    mon_rec;
	int		    min_clock = 0;
	int		    max_clock = 0;
	double		    clock;
	Bool		    add_default_modes;
	Bool		    debug_modes = config->debug_modes ||
					  xf86Initialising;
	enum det_monrec_source sync_source = sync_default;
	
	while (output->probed_modes != NULL)
	    xf86DeleteMode(&output->probed_modes, output->probed_modes);

	/*
	 * Check connection status
	 */
	output->status = (*output->funcs->detect)(output);

	if (output->status == XF86OutputStatusDisconnected &&
		!xf86ReturnOptValBool(output->options, OPTION_ENABLE, FALSE))
	{
	    xf86OutputSetEDID (output, NULL);
	    continue;
	}

	memset (&mon_rec, '\0', sizeof (mon_rec));
	
	conf_monitor = output->conf_monitor;
	
	if (conf_monitor)
	{
	    int	i;
	    
	    for (i = 0; i < conf_monitor->mon_n_hsync; i++)
	    {
		mon_rec.hsync[mon_rec.nHsync].lo = conf_monitor->mon_hsync[i].lo;
		mon_rec.hsync[mon_rec.nHsync].hi = conf_monitor->mon_hsync[i].hi;
		mon_rec.nHsync++;
		sync_source = sync_config;
	    }
	    for (i = 0; i < conf_monitor->mon_n_vrefresh; i++)
	    {
		mon_rec.vrefresh[mon_rec.nVrefresh].lo = conf_monitor->mon_vrefresh[i].lo;
		mon_rec.vrefresh[mon_rec.nVrefresh].hi = conf_monitor->mon_vrefresh[i].hi;
		mon_rec.nVrefresh++;
		sync_source = sync_config;
	    }
	    config_modes = xf86GetMonitorModes (scrn, conf_monitor);
	}
	
	output_modes = (*output->funcs->get_modes) (output);

	/*
	 * If the user has a preference, respect it.
	 * Otherwise, don't second-guess the driver.
	 */
	if (!xf86GetOptValBool(output->options, OPTION_DEFAULT_MODES,
			       &add_default_modes))
	    add_default_modes = (output_modes == NULL);
	
	edid_monitor = output->MonInfo;
	
        if (edid_monitor)
d1668 58
a1725 2
            struct det_monrec_parameter p;
            struct disp_features    *features = &edid_monitor->features;
d1727 3
a1729 155
	    /* if display is not continuous-frequency, don't add default modes */
	    if (!GTF_SUPPORTED(features->msc))
		add_default_modes = FALSE;

	    p.mon_rec = &mon_rec;
	    p.max_clock = &max_clock;
	    p.set_hsync = mon_rec.nHsync == 0;
	    p.set_vrefresh = mon_rec.nVrefresh == 0;
	    p.sync_source = &sync_source;

	    xf86ForEachDetailedBlock(edid_monitor,
			             handle_detailed_monrec,
			             &p);
	}

	if (xf86GetOptValFreq (output->options, OPTION_MIN_CLOCK,
			       OPTUNITS_KHZ, &clock))
	    min_clock = (int) clock;
	if (xf86GetOptValFreq (output->options, OPTION_MAX_CLOCK,
			       OPTUNITS_KHZ, &clock))
	    max_clock = (int) clock;

	/* If we still don't have a sync range, guess wildly */
	if (!mon_rec.nHsync || !mon_rec.nVrefresh)
	    GuessRangeFromModes(&mon_rec, output_modes);

	/*
	 * These limits will end up setting a 1024x768@@60Hz mode by default,
	 * which seems like a fairly good mode to use when nothing else is
	 * specified
	 */
	if (mon_rec.nHsync == 0)
	{
	    mon_rec.hsync[0].lo = 31.0;
	    mon_rec.hsync[0].hi = 55.0;
	    mon_rec.nHsync = 1;
	}
	if (mon_rec.nVrefresh == 0)
	{
	    mon_rec.vrefresh[0].lo = 58.0;
	    mon_rec.vrefresh[0].hi = 62.0;
	    mon_rec.nVrefresh = 1;
	}

	if (add_default_modes)
	    default_modes = xf86GetDefaultModes ();

	/*
	 * If this is not an RB monitor, remove RB modes from the default
	 * pool.  RB modes from the config or the monitor itself are fine.
	 */
	if (!mon_rec.reducedblanking)
	    xf86ValidateModesReducedBlanking (scrn, default_modes);

	if (sync_source == sync_config)
	{
	    /* 
	     * Check output and config modes against sync range from config file
	     */
	    xf86ValidateModesSync (scrn, output_modes, &mon_rec);
	    xf86ValidateModesSync (scrn, config_modes, &mon_rec);
	}
	/*
	 * Check default modes against sync range
	 */
        xf86ValidateModesSync (scrn, default_modes, &mon_rec);
	/*
	 * Check default modes against monitor max clock
	 */
	if (max_clock) {
	    xf86ValidateModesClocks(scrn, default_modes,
				    &min_clock, &max_clock, 1);
	    xf86ValidateModesClocks(scrn, output_modes,
				    &min_clock, &max_clock, 1);
	}
	
	output->probed_modes = NULL;
	output->probed_modes = xf86ModesAdd (output->probed_modes, config_modes);
	output->probed_modes = xf86ModesAdd (output->probed_modes, output_modes);
	output->probed_modes = xf86ModesAdd (output->probed_modes, default_modes);
	
	/*
	 * Check all modes against max size, interlace, and doublescan
	 */
	if (maxX && maxY)
	    xf86ValidateModesSize (scrn, output->probed_modes,
				       maxX, maxY, 0);

	{
	    int flags = (output->interlaceAllowed ? V_INTERLACE : 0) |
			(output->doubleScanAllowed ? V_DBLSCAN : 0);
	    xf86ValidateModesFlags (scrn, output->probed_modes, flags);
	}
	 
	/*
	 * Check all modes against output
	 */
	for (mode = output->probed_modes; mode != NULL; mode = mode->next) 
	    if (mode->status == MODE_OK)
		mode->status = (*output->funcs->mode_valid)(output, mode);
	
	xf86PruneInvalidModes(scrn, &output->probed_modes, debug_modes);
	
	output->probed_modes = xf86SortModes (output->probed_modes);
	
	/* Check for a configured preference for a particular mode */
	preferred_mode = preferredMode(scrn, output);

	if (preferred_mode)
	{
	    for (mode = output->probed_modes; mode; mode = mode->next)
	    {
		if (!strcmp (preferred_mode, mode->name))
		{
		    if (mode != output->probed_modes)
		    {
			if (mode->prev)
			    mode->prev->next = mode->next;
			if (mode->next)
			    mode->next->prev = mode->prev;
			mode->next = output->probed_modes;
			output->probed_modes->prev = mode;
			mode->prev = NULL;
			output->probed_modes = mode;
		    }
		    mode->type |= (M_T_PREFERRED|M_T_USERPREF);
		    break;
		}
	    }
	}
	
	output->initial_rotation = xf86OutputInitialRotation (output);

	if (debug_modes) {
	    if (output->probed_modes != NULL) {
		xf86DrvMsg(scrn->scrnIndex, X_INFO,
			   "Printing probed modes for output %s\n",
			   output->name);
	    } else {
		xf86DrvMsg(scrn->scrnIndex, X_INFO,
			   "No remaining probed modes for output %s\n",
			   output->name);
	    }
	}
	for (mode = output->probed_modes; mode != NULL; mode = mode->next)
	{
	    /* The code to choose the best mode per pipe later on will require
	     * VRefresh to be set.
	     */
	    mode->VRefresh = xf86ModeVRefresh(mode);
	    xf86SetModeCrtc(mode, INTERLACE_HALVE_V);

	    if (debug_modes)
		xf86PrintModeline(scrn->scrnIndex, mode);
	}
a1732 1

d1739 1
a1739 1
xf86RandR12GetOriginalVirtualSize(ScrnInfoPtr scrn, int *x, int *y);
d1747 1
a1747 1
	return b;
d1749 1
a1749 1
	return a;
d1755 1
a1755 1
	return a;
d1768 33
a1800 32
    for (o = 0; o < config->num_output; o++)
    {
	test = config->output[o];
	if (!test->crtc)
	    continue;
	if (test->status != XF86OutputStatusConnected)
	    continue;
	if (!test->probed_modes)
	    continue;

	testmode = mode = test->probed_modes;
	for (count = 0; mode; mode = mode->next, count++)
	    testmode = biggestMode(testmode, mode);

	if (!output) {
	    output = test;
	    compat = o;
	    maxmode = testmode;
	    mincount = count;
	} else if (maxmode == biggestMode(maxmode, testmode)) {
	    output = test;
	    compat = o;
	    maxmode = testmode;
	    mincount = count;
	} else if ((maxmode->HDisplay == testmode->HDisplay) && 
		(maxmode->VDisplay == testmode->VDisplay) &&
		count <= mincount) {
	    output = test;
	    compat = o;
	    maxmode = testmode;
	    mincount = count;
	}
d1804 18
a1821 18
    if (!output)
    {
	for (o = 0; o < config->num_output; o++)
	{
	    test = config->output[o];
	    if (!test->crtc)
		continue;
	    if (!test->probed_modes)
		continue;

	    if (!output) {
		output = test;
		compat = o;
	    } else if (test->probed_modes->HDisplay < output->probed_modes->HDisplay) {
		output = test;
		compat = o;
	    }
	}
d1825 5
a1829 4
	config->compat_output = compat;
    } else {
	/* Don't change the compat output when no valid outputs found */
	output = config->output[config->compat_output];
d1836 1
a1836 1
xf86SetScrnInfoModes (ScrnInfoPtr scrn)
d1838 4
a1841 4
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86OutputPtr	output;
    xf86CrtcPtr		crtc;
    DisplayModePtr	last, mode = NULL;
d1846 1
a1846 1
	return; /* punt */
d1852 1
a1852 1
	xf86DeleteMode(&scrn->modes, scrn->modes);
d1858 3
a1860 3
	for (mode = scrn->modes; mode; mode = mode->next)
	    if (xf86ModesEqual (mode, &crtc->desiredMode))
		break;
d1864 4
a1867 4
	scrn->modes = xf86ModesAdd(scrn->modes,
				   xf86CVTMode(scrn->display->virtualX,
					       scrn->display->virtualY,
					       60, 0, 0));
d1873 1
a1873 2
    for (last = scrn->modes; last && last->next; last = last->next)
	;
d1877 2
a1878 2
	while (scrn->modes != mode)
	    scrn->modes = scrn->modes->next;
d1884 1
a1884 1
	    _xf86_di_dga_reinit_internal(scrn->pScreen);
d1890 1
a1890 1
			  Bool *enabled)
d1896 2
a1897 2
	any_enabled |= enabled[o] = xf86OutputEnabled(config->output[o], TRUE);
    
d1899 2
a1900 2
	xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		   "No outputs definitely connected, trying again...\n");
d1902 3
a1904 2
	for (o = 0; o < config->num_output; o++)
	    any_enabled |= enabled[o] = xf86OutputEnabled(config->output[o], FALSE);
d1916 4
a1919 4
	if (enabled[o]) {
	    *index = o;
	    return TRUE;
	}
d1921 1
a1921 1
    
d1937 1
a1937 1
	return NULL;
d1940 1
a1940 1
	m = o->probed_modes;
d1942 1
a1942 1
	m = last->next;
d1945 2
a1946 2
	if (aspectMatch(aspect, (float)m->HDisplay / (float)m->VDisplay))
	    return m;
d1958 1
a1958 1
	return NULL;
d1960 19
a1978 19
	test = mode;
	for (p = o; nextEnabledOutput(config, enabled, &p); ) {
	    test = xf86OutputFindClosestMode(config->output[p], mode);
	    if (!test)
		break;
	    if (test->HDisplay != mode->HDisplay ||
		    test->VDisplay != mode->VDisplay) {
		test = NULL;
		break;
	    }
	}

	/* if we didn't match it on all outputs, try the next one */
	if (!test)
	    continue;

	/* if it's bigger than the last one, save it */
	if (!match || (test->HDisplay > match->HDisplay))
	    match = test;
d1987 2
a1988 2
		    DisplayModePtr *modes, Bool *enabled,
		    int width, int height)
d1999 54
a2052 51
    for (p = -1; nextEnabledOutput(config, enabled, &p); ) {
	Rotation r = config->output[p]->initial_rotation;
	DisplayModePtr mode;
	if ((preferred[p] = xf86OutputHasPreferredMode(config->output[p],
			width, height))) {
	    int pref_width = xf86ModeWidth(preferred[p], r);
	    int pref_height = xf86ModeHeight(preferred[p], r);
	    Bool all_match = TRUE;

	    for (o = -1; nextEnabledOutput(config, enabled, &o); ) {
		Bool match = FALSE;
		xf86OutputPtr output = config->output[o];
		if (o == p)
		    continue;

		/*
		 * First see if the preferred mode matches on the next
		 * output as well.  This catches the common case of identical
		 * monitors and makes sure they all have the same timings
		 * and refresh.  If that fails, we fall back to trying to
		 * match just width & height.
		 */
		mode = xf86OutputHasPreferredMode(output, pref_width,
						  pref_height);
		if (mode && xf86ModesEqual(mode, preferred[p])) {
			preferred[o] = mode;
			match = TRUE;
		} else {
			for (mode = output->probed_modes; mode;
			     mode = mode->next) {
				Rotation r = output->initial_rotation;
				if (xf86ModeWidth(mode, r) == pref_width &&
				    xf86ModeHeight(mode, r) == pref_height) {
					preferred[o] = mode;
					match = TRUE;
				}
			}
		}

		all_match &= match;
	    }

	    if (all_match &&
		    (pref_width*pref_height > max_pref_width*max_pref_height)) {
		for (o = -1; nextEnabledOutput(config, enabled, &o); )
		    preferred_match[o] = preferred[o];
		max_pref_width = pref_width;
		max_pref_height = pref_height;
		ret = TRUE;
	    }
	}
d2059 16
a2074 3
    if (!ret) do {
	int i = 0;
	float aspect = 0.0;
d2076 2
a2077 2
	/* count the number of enabled outputs */
	for (i = 0, p = -1; nextEnabledOutput(config, enabled, &p); i++) ;
d2079 2
a2080 2
	if (i != 1)
	    break;
d2082 1
a2082 13
	p = -1;
	nextEnabledOutput(config, enabled, &p);
	if (config->output[p]->mm_height)
	    aspect = (float)config->output[p]->mm_width /
		     (float)config->output[p]->mm_height;

	if (aspect)
	    preferred_match[p] = bestModeForAspect(config, enabled, aspect);

	if (preferred_match[p])
	    ret = TRUE;

    } while (0);
d2085 3
a2087 3
	/* oh good, there is a match.  stash the selected modes and return. */
	memcpy(modes, preferred_match,
		config->num_output * sizeof(DisplayModePtr));
d2097 1
a2097 2
		 DisplayModePtr *modes, Bool *enabled,
		 int width, int height)
d2108 6
a2113 6
    for (o = -1; nextEnabledOutput(config, enabled, &o); ) {
	output = config->output[o];
	if (output->mm_height)
	    aspects[o] = (float)output->mm_width / (float)output->mm_height;
	else
	    aspects[o] = 4.0 / 3.0;
d2117 8
a2124 7
    for (o = -1; nextEnabledOutput(config, enabled, &o); ) {
	output = config->output[o];
	if (!aspect) {
	    aspect = aspects[o];
	} else if (!aspectMatch(aspect, aspects[o])) {
	    goto no_aspect_match;
	}
d2128 2
a2129 2
    if (!aspectMatch(aspect, 4.0/3.0))
	aspect_guess = bestModeForAspect(config, enabled, aspect);
d2131 2
a2132 2
no_aspect_match:
    base_guess = bestModeForAspect(config, enabled, 4.0/3.0);
d2137 1
a2137 1
	goto out;
d2140 2
a2141 2
    for (o = -1; nextEnabledOutput(config, enabled, &o); ) {
	modes[o] = xf86OutputFindClosestMode(config->output[o], guess);
d2145 1
a2145 1
out:
d2152 1
a2152 2
		   DisplayModePtr *modes, Bool *enabled,
		   int width, int height)
d2160 14
a2173 14
    for (o = -1; nextEnabledOutput(config, enabled, &o); ) {
	default_mode = xf86DefaultMode (config->output[o], width, height);
	if (!default_mode)
	    continue;

	default_preferred = (((default_mode->type & M_T_PREFERRED) != 0) +
		((default_mode->type & M_T_USERPREF) != 0));

	if (default_preferred > target_preferred || !target_mode) {
	    target_mode = default_mode;
	    target_preferred = default_preferred;
	    target_rotation = config->output[o]->initial_rotation;
	    config->compat_output = o;
	}
d2177 1
a2177 1
	modes[config->compat_output] = target_mode;
d2180 4
a2183 4
    for (o = -1; nextEnabledOutput(config, enabled, &o); ) {
	if (!modes[o])
	    modes[o] = xf86ClosestMode(config->output[o], target_mode,
				       target_rotation, width, height);
d2191 1
a2191 2
		   DisplayModePtr *modes, Bool *enabled,
		   int width, int height)
d2196 6
a2201 6
	return xf86TargetFallback(scrn, config, modes, enabled, width, height);
    
    for (o = -1; nextEnabledOutput(config, enabled, &o); )
	if (xf86OutputHasUserPreferredMode(config->output[o]))
	    return 
		xf86TargetFallback(scrn, config, modes, enabled, width, height);
d2208 1
a2208 1
        float gamma_blue)
d2217 3
a2219 2
     /* Only cause warning if user wanted gamma to be set. */
    if (!crtc->funcs->gamma_set && (gamma_red != 1.0 || gamma_green != 1.0 || gamma_blue != 1.0)) {
d2222 2
a2223 1
    } else if (!crtc->funcs->gamma_set) {
d2226 1
a2226 1
      }
d2235 4
a2238 2
            red[i] = (CARD16)(pow((double)i/(double)(size - 1),
			1. / (double)gamma_red) * (double)(size - 1) * 256);
d2243 3
a2245 2
            green[i] = (CARD16)(pow((double)i/(double)(size - 1),
			1. / (double)gamma_green) * (double)(size - 1) * 256);
d2250 4
a2253 2
            blue[i] = (CARD16)(pow((double)i/(double)(size - 1),
			1. / (double)gamma_blue) * (double)(size - 1) * 256);
d2260 1
a2260 1
      }
d2263 3
a2265 3
    memcpy (crtc->gamma_red, red, crtc->gamma_size * sizeof (CARD16));
    memcpy (crtc->gamma_green, green, crtc->gamma_size * sizeof (CARD16));
    memcpy (crtc->gamma_blue, blue, crtc->gamma_size * sizeof (CARD16));
d2279 1
a2279 1
    
d2287 8
a2294 11
    if (mon->mon_gamma_red >= GAMMA_MIN &&
        mon->mon_gamma_red <= GAMMA_MAX)
            gamma_red = mon->mon_gamma_red;

    if (mon->mon_gamma_green >= GAMMA_MIN &&
        mon->mon_gamma_green <= GAMMA_MAX)
            gamma_green = mon->mon_gamma_green;

    if (mon->mon_gamma_blue >= GAMMA_MIN &&
        mon->mon_gamma_blue <= GAMMA_MAX)
            gamma_blue = mon->mon_gamma_blue;
d2298 8
a2305 4
	xf86DrvMsg(output->scrn->scrnIndex, X_INFO, "Output %s wants gamma correction (%.1f, %.1f, %.1f)\n", output->name, gamma_red, gamma_green, gamma_blue);
	return xf86CrtcSetInitialGamma(output->crtc, gamma_red, gamma_green, gamma_blue);
    }else
	return TRUE;
d2323 1
a2323 1
xf86InitialConfiguration (ScrnInfoPtr scrn, Bool canGrow)
d2325 7
a2331 7
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
    int			o, c;
    xf86CrtcPtr		*crtcs;
    DisplayModePtr	*modes;
    Bool		*enabled;
    int			width, height;
    int			i = scrn->scrnIndex;
d2337 5
a2341 7
    config->options = xnfalloc (sizeof (xf86DeviceOptions));
    memcpy (config->options, xf86DeviceOptions, sizeof (xf86DeviceOptions));
    xf86ProcessOptions (scrn->scrnIndex,
			scrn->options,
			config->options);
    config->debug_modes = xf86ReturnOptValBool (config->options,
						OPTION_MODEDEBUG, FALSE);
d2344 1
a2344 1
	width = scrn->display->virtualX;
d2346 1
a2346 1
	width = config->maxWidth;
d2348 1
a2348 1
	height = scrn->display->virtualY;
d2350 3
a2352 1
	height = config->maxHeight;
d2354 3
a2356 1
    xf86ProbeOutputModes (scrn, width, height);
a2357 4
    crtcs = xnfcalloc (config->num_output, sizeof (xf86CrtcPtr));
    modes = xnfcalloc (config->num_output, sizeof (DisplayModePtr));
    enabled = xnfcalloc (config->num_output, sizeof (Bool));
    
d2360 30
a2389 25
	xf86DrvMsg(i, X_WARNING, "Unable to find connected outputs - setting %dx%d initial framebuffer\n",
		   NO_OUTPUT_DEFAULT_WIDTH, NO_OUTPUT_DEFAULT_HEIGHT);
	have_outputs = FALSE;
    } else {
	if (xf86TargetUserpref(scrn, config, modes, enabled, width, height))
	    xf86DrvMsg(i, X_INFO, "Using user preference for initial modes\n");
	else if (xf86TargetPreferred(scrn, config, modes, enabled, width, height))
	    xf86DrvMsg(i, X_INFO, "Using exact sizes for initial modes\n");
	else if (xf86TargetAspect(scrn, config, modes, enabled, width, height))
	    xf86DrvMsg(i, X_INFO, "Using fuzzy aspect match for initial modes\n");
	else if (xf86TargetFallback(scrn, config, modes, enabled, width, height))
	    xf86DrvMsg(i, X_INFO, "Using sloppy heuristic for initial modes\n");
	else
	    xf86DrvMsg(i, X_WARNING, "Unable to find initial modes\n");
    }

    for (o = -1; nextEnabledOutput(config, enabled, &o); ) {
	if (!modes[o])
	    xf86DrvMsg (scrn->scrnIndex, X_ERROR,
			"Output %s enabled but has no modes\n",
			config->output[o]->name);
	else
	    xf86DrvMsg (scrn->scrnIndex, X_INFO,
			"Output %s using initial mode %s\n",
			config->output[o]->name, modes[o]->name);
d2395 2
a2396 2
    if (!xf86InitialOutputPositions (scrn, modes))
	goto bailout;
d2401 2
a2402 2
    xf86InitialPanning (scrn);
	
d2406 3
a2408 3
    if (have_outputs && !xf86PickCrtcs (scrn, crtcs, modes, 0, width, height))
	goto bailout;
    
d2410 1
a2410 1
    
d2413 9
a2421 10
    
    for (c = 0; c < config->num_crtc; c++)
    {
	xf86CrtcPtr	crtc = config->crtc[c];

	crtc->enabled = FALSE;
	memset (&crtc->desiredMode, '\0', sizeof (crtc->desiredMode));
	/* Set default gamma for all crtc's. */
	/* This is done to avoid problems later on with cloned outputs. */
	xf86CrtcSetInitialGamma(crtc, 1.0, 1.0, 1.0);
d2425 2
a2426 1
	xf86DrvMsg(scrn->scrnIndex, X_INFO, "Using default gamma of (1.0, 1.0, 1.0) unless otherwise stated.\n");
d2431 43
a2473 39
    for (o = 0; o < config->num_output; o++)
    {
	xf86OutputPtr	output = config->output[o];
	DisplayModePtr	mode = modes[o];
        xf86CrtcPtr	crtc = crtcs[o];

	if (mode && crtc)
	{
	    crtc->desiredMode = *mode;
	    crtc->desiredRotation = output->initial_rotation;
	    crtc->desiredX = output->initial_x;
	    crtc->desiredY = output->initial_y;
	    crtc->desiredTransformPresent = FALSE;
	    crtc->enabled = TRUE;
	    memcpy (&crtc->panningTotalArea,    &output->initialTotalArea,    sizeof(BoxRec));
	    memcpy (&crtc->panningTrackingArea, &output->initialTrackingArea, sizeof(BoxRec));
	    memcpy (crtc->panningBorder,        output->initialBorder,        4*sizeof(INT16));
	    output->crtc = crtc;
	    if (!xf86OutputSetInitialGamma(output))
		xf86DrvMsg (scrn->scrnIndex, X_WARNING, "Initial gamma correction for output %s: failed.\n", output->name);
	} else {
	    output->crtc = NULL;
	}
    }

    if (scrn->display->virtualX == 0)
    {
	/*
	 * Expand virtual size to cover the current config and potential mode
	 * switches, if the driver can't enlarge the screen later.
	 */
	xf86DefaultScreenLimits (scrn, &width, &height, canGrow);
    
	if (have_outputs == FALSE) {
	    if (width < NO_OUTPUT_DEFAULT_WIDTH && height < NO_OUTPUT_DEFAULT_HEIGHT) {
		width = NO_OUTPUT_DEFAULT_WIDTH;
		height = NO_OUTPUT_DEFAULT_HEIGHT;
	    }
	}
d2475 2
a2476 2
	scrn->display->virtualX = width;
	scrn->display->virtualY = height;
d2480 1
a2480 1
	scrn->virtualX = width;
d2482 1
a2482 1
	scrn->virtualY = height;
d2488 1
a2488 1
	goto bailout;
d2494 3
a2496 4
    if (!canGrow)
    {
	xf86CrtcSetSizeRange (scrn, config->minWidth, config->minHeight,
			      width, height);
d2499 1
a2499 1
    xf86SetScrnInfoModes (scrn);
d2515 1
a2515 1
xf86PrepareOutputs (ScrnInfoPtr scrn)
d2517 2
a2518 2
    xf86CrtcConfigPtr   config = XF86_CRTC_CONFIG_PTR(scrn);
    int			o;
d2521 2
a2522 1
	xf86OutputPtr output = config->output[o];
d2524 4
a2527 4
	/* Disable outputs that are unused or will be re-routed */
	if (!output->funcs->get_crtc ||
	    output->crtc != (*output->funcs->get_crtc)(output) ||
	    output->crtc == NULL)
d2529 1
a2529 1
	    (*output->funcs->dpms)(output, DPMSModeOff);
d2534 1
a2534 1
xf86PrepareCrtcs (ScrnInfoPtr scrn)
d2536 2
a2537 2
    xf86CrtcConfigPtr   config = XF86_CRTC_CONFIG_PTR(scrn);
    int			c;
d2541 24
a2564 25
	xf86CrtcPtr	crtc = config->crtc[c];
	xf86OutputPtr	output = NULL;
	uint32_t	desired_outputs = 0, current_outputs = 0;
	int		o;

	for (o = 0; o < config->num_output; o++) {
	    output = config->output[o];
	    if (output->crtc == crtc)
		desired_outputs |= (1<<o);
	    /* If we can't tell where it's mapped, force it off */
	    if (!output->funcs->get_crtc) {
		desired_outputs = 0;
		break;
	    }
	    if ((*output->funcs->get_crtc)(output) == crtc)
		current_outputs |= (1<<o);
	}

	/*
	 * If mappings are different or the CRTC is unused,
	 * we need to disable it
	 */
	if (desired_outputs != current_outputs ||
	    !desired_outputs)
	    (*crtc->funcs->dpms)(crtc, DPMSModeOff);
d2566 1
a2566 1
	(*crtc->funcs->dpms)(crtc, DPMSModeOff);
d2577 1
a2577 1
xf86SetDesiredModes (ScrnInfoPtr scrn)
d2579 3
a2581 3
    xf86CrtcConfigPtr   config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CrtcPtr         crtc = config->crtc[0];
    int			c;
d2585 2
a2586 2
	xf86PrepareOutputs(scrn);
	xf86PrepareCrtcs(scrn);
d2589 47
a2635 49
    for (c = 0; c < config->num_crtc; c++)
    {
	xf86OutputPtr	output = NULL;
	int		o;
	RRTransformPtr	transform;

	crtc = config->crtc[c];

	/* Skip disabled CRTCs */
	if (!crtc->enabled)
	    continue;

	if (xf86CompatOutput(scrn) && xf86CompatCrtc(scrn) == crtc)
	    output = xf86CompatOutput(scrn);
	else
	{
	    for (o = 0; o < config->num_output; o++)
		if (config->output[o]->crtc == crtc)
		{
		    output = config->output[o];
		    break;
		}
	}
	/* paranoia */
	if (!output)
	    continue;

	/* Mark that we'll need to re-set the mode for sure */
	memset(&crtc->mode, 0, sizeof(crtc->mode));
	if (!crtc->desiredMode.CrtcHDisplay)
	{
	    DisplayModePtr  mode = xf86OutputFindClosestMode (output, scrn->currentMode);

	    if (!mode)
		return FALSE;
	    crtc->desiredMode = *mode;
	    crtc->desiredRotation = RR_Rotate_0;
	    crtc->desiredTransformPresent = FALSE;
	    crtc->desiredX = 0;
	    crtc->desiredY = 0;
	}

	if (crtc->desiredTransformPresent)
	    transform = &crtc->desiredTransform;
	else
	    transform = NULL;
	if (!xf86CrtcSetModeTransform (crtc, &crtc->desiredMode, crtc->desiredRotation,
				       transform, crtc->desiredX, crtc->desiredY))
	    return FALSE;
d2653 1
a2653 1
xf86OutputFindClosestMode (xf86OutputPtr output, DisplayModePtr desired)
d2655 23
a2677 1
    DisplayModePtr	best = NULL, scan = NULL;
d2679 20
a2698 46
    for (scan = output->probed_modes; scan != NULL; scan = scan->next) 
    {
	/* If there's an exact match, we're done. */
	if (xf86ModesEqual(scan, desired)) {
	    best = desired;
	    break;
	}

	/* Reject if it's larger than the desired mode. */
	if (scan->HDisplay > desired->HDisplay || 
	    scan->VDisplay > desired->VDisplay)
	{
	    continue;
	}

	/*
	 * If we haven't picked a best mode yet, use the first
	 * one in the size range
	 */
	if (best == NULL) 
	{
	    best = scan;
	    continue;
	}

	/* Find if it's closer to the right size than the current best
	 * option.
	 */
	if ((scan->HDisplay > best->HDisplay &&
	     scan->VDisplay >= best->VDisplay) ||
	    (scan->HDisplay >= best->HDisplay &&
	     scan->VDisplay > best->VDisplay))
	{
	    best = scan;
	    continue;
	}

	/* Find if it's still closer to the right refresh than the current
	 * best resolution.
	 */
	if (scan->HDisplay == best->HDisplay &&
	    scan->VDisplay == best->VDisplay &&
	    (fabs(scan->VRefresh - desired->VRefresh) <
	     fabs(best->VRefresh - desired->VRefresh))) {
	    best = scan;
	}
d2712 1
a2712 1
xf86SetSingleMode (ScrnInfoPtr pScrn, DisplayModePtr desired, Rotation rotation)
d2714 5
a2718 5
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(pScrn);
    Bool		ok = TRUE;
    xf86OutputPtr	compat_output;
    DisplayModePtr	compat_mode = NULL;
    int			c;
d2725 1
a2725 1
	compat_mode = xf86OutputFindClosestMode (compat_output, desired);
d2727 39
a2765 44
	desired = compat_mode;
    
    for (c = 0; c < config->num_crtc; c++)
    {
	xf86CrtcPtr	crtc = config->crtc[c];
	DisplayModePtr	crtc_mode = NULL;
	int		o;

	if (!crtc->enabled)
	    continue;
	
	for (o = 0; o < config->num_output; o++)
	{
	    xf86OutputPtr   output = config->output[o];
	    DisplayModePtr  output_mode;

	    /* skip outputs not on this crtc */
	    if (output->crtc != crtc)
		continue;
	    
	    if (crtc_mode)
	    {
		output_mode = xf86OutputFindClosestMode (output, crtc_mode);
		if (output_mode != crtc_mode)
		    output->crtc = NULL;
	    }
	    else
		crtc_mode = xf86OutputFindClosestMode (output, desired);
	}
	if (!crtc_mode)
	{
	    crtc->enabled = FALSE;
	    continue;
	}
	if (!xf86CrtcSetModeTransform (crtc, crtc_mode, rotation, NULL, 0, 0))
	    ok = FALSE;
	else
	{
	    crtc->desiredMode = *crtc_mode;
	    crtc->desiredRotation = rotation;
	    crtc->desiredTransformPresent = FALSE;
	    crtc->desiredX = 0;
	    crtc->desiredY = 0;
	}
d2769 1
a2769 1
    xf86RandR12TellChanged (pScrn->pScreen);
a2773 1

d2783 2
a2784 2
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
    int			i;
d2787 1
a2787 1
	return;
d2790 6
a2795 5
	for (i = 0; i < config->num_output; i++) {
	    xf86OutputPtr output = config->output[i];
	    if (output->crtc != NULL)
		(*output->funcs->dpms) (output, mode);
	}
d2799 4
a2802 3
	xf86CrtcPtr crtc = config->crtc[i];
	if (crtc->enabled)
	    (*crtc->funcs->dpms) (crtc, mode);
d2806 6
a2811 5
	for (i = 0; i < config->num_output; i++) {
	    xf86OutputPtr output = config->output[i];
	    if (output->crtc != NULL)
		(*output->funcs->dpms) (output, mode);
	}
d2827 1
a2827 1
	xf86DPMSSet(pScrn, DPMSModeOn, 0);
d2829 1
a2829 1
	xf86DPMSSet(pScrn, DPMSModeOff, 0);
d2840 2
a2841 2
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int			o, c;
d2843 16
a2858 18
    for (o = 0; o < xf86_config->num_output; o++) 
    {
	xf86OutputPtr  output = xf86_config->output[o];
	if (!output->crtc) 
	    (*output->funcs->dpms)(output, DPMSModeOff);
    }

    for (c = 0; c < xf86_config->num_crtc; c++) 
    {
	xf86CrtcPtr crtc = xf86_config->crtc[c];

	if (!crtc->enabled) 
	{
	    crtc->funcs->dpms(crtc, DPMSModeOff);
	    memset(&crtc->mode, 0, sizeof(crtc->mode));
	    xf86RotateDestroy(crtc);
	    crtc->active = FALSE;
	}
d2861 1
a2861 1
	xf86_crtc_notify(pScrn->pScreen);
d2863 1
a2863 1
	pScrn->ModeSet(pScrn);
d2874 1
a2874 1
xf86OutputSetEDIDProperty (xf86OutputPtr output, void *data, int data_len)
d2880 1
a2880 1
	return;
d2883 5
a2887 4
	RRChangeOutputProperty(output->randr_output, edid_atom, XA_INTEGER, 8,
			       PropModeReplace, data_len, data, FALSE, TRUE);
    } else {
	RRDeleteOutputProperty(output->randr_output, edid_atom);
d2900 3
a2902 2
static void  handle_detailed_physical_size(struct detailed_monitor_section
		                          *det_mon, void *data)
a2904 1
    p = (struct det_phySize_parameter *)data;
d2906 4
a2909 2
    if (p->ret == TRUE )
        return ;
d2928 1
a2928 1
xf86OutputSetEDID (xf86OutputPtr output, xf86MonPtr edid_mon)
d2930 4
a2933 3
    ScrnInfoPtr		scrn = output->scrn;
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
    Bool		debug_modes = config->debug_modes || xf86Initialising;
d2935 1
a2935 1
    int			size;
d2937 1
a2937 1
    
d2939 1
a2939 1
    
d2945 3
a2947 3
	xf86DrvMsg(scrn->scrnIndex, X_INFO, "EDID for output %s\n",
		   output->name);
	xf86PrintEDID(edid_mon);
d2957 8
a2964 8
    if (edid_mon)
    {
	if (edid_mon->ver.version == 1) {
	    size = 128;
	    if (edid_mon->flags & EDID_COMPLETE_RAWDATA)
		size += edid_mon->no_sections * 128;
	} else if (edid_mon->ver.version == 2)
	    size = 256;
d2966 2
a2967 1
    xf86OutputSetEDIDProperty (output, edid_mon ? edid_mon->rawData : NULL, size);
d2973 1
d2975 1
a2975 1
        p.quirks = xf86DDCDetectQuirks(scrn->scrnIndex,edid_mon, FALSE);
d2977 1
a2977 2
        xf86ForEachDetailedBlock(edid_mon,
                                 handle_detailed_physical_size, &p);
d2979 6
a2984 7
	/* if no mm size is available from a detailed timing, check the max size field */
	if ((!output->mm_width || !output->mm_height) &&
	    (edid_mon->features.hsize && edid_mon->features.vsize))
	{
	    output->mm_width = edid_mon->features.hsize * 10;
	    output->mm_height = edid_mon->features.vsize * 10;
	}
d2993 1
a2993 1
xf86OutputGetEDIDModes (xf86OutputPtr output)
d2995 2
a2996 2
    ScrnInfoPtr	scrn = output->scrn;
    xf86MonPtr	edid_mon = output->MonInfo;
d2999 1
a2999 1
	return NULL;
d3005 1
a3005 1
xf86OutputGetEDID (xf86OutputPtr output, I2CBusPtr pDDCBus)
d3007 1
a3007 1
    ScrnInfoPtr	scrn = output->scrn;
d3017 8
a3024 7
static char *_xf86ConnectorNames[] = {
					"None", "VGA", "DVI-I", "DVI-D",
					"DVI-A", "Composite", "S-Video",
					"Component", "LFP", "Proprietary",
					"HDMI", "DisplayPort",
				     };
char *
d3039 1
a3039 1
	dest->x1 = dest->x2 = dest->y1 = dest->y2 = 0;
d3046 7
a3052 6
	crtc_box->x1 = crtc->x;
	crtc_box->x2 = crtc->x + xf86ModeWidth(&crtc->mode, crtc->rotation);
	crtc_box->y1 = crtc->y;
	crtc_box->y2 = crtc->y + xf86ModeHeight(&crtc->mode, crtc->rotation);
    } else
	crtc_box->x1 = crtc_box->x2 = crtc_box->y1 = crtc_box->y2 = 0;
d3061 1
d3070 7
a3076 9
		   BoxPtr      box,
		   xf86CrtcPtr desired,
		   BoxPtr      crtc_box_ret)
{
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    xf86CrtcPtr		crtc, best_crtc;
    int			coverage, best_coverage;
    int			c;
    BoxRec		crtc_box, cover_box;
d3085 13
a3097 12
	crtc = xf86_config->crtc[c];
	x86_crtc_box(crtc, &crtc_box);
	x86_crtc_box_intersect(&cover_box, &crtc_box, box);
	coverage = xf86_crtc_box_area(&cover_box);
	if (coverage && crtc == desired) {
	    *crtc_box_ret = crtc_box;
	    return crtc;
	} else if (coverage > best_coverage) {
	    *crtc_box_ret = crtc_box;
	    best_crtc = crtc;
	    best_coverage = coverage;
	}
d3112 12
a3123 15
			    xf86CrtcPtr *crtc_ret,
			    xf86CrtcPtr desired_crtc,
			    BoxPtr      dst,
			    INT32	*xa,
			    INT32	*xb,
			    INT32	*ya,
			    INT32	*yb,
			    RegionPtr   reg,
			    INT32	width,
			    INT32	height)
{
    Bool	ret;
    RegionRec	crtc_region_local;
    RegionPtr	crtc_region = reg;
    
d3125 11
a3135 11
	BoxRec		crtc_box;
	xf86CrtcPtr	crtc = xf86_covering_crtc(pScrn, dst,
						  desired_crtc,
						  &crtc_box);

	if (crtc) {
	    RegionInit(&crtc_region_local, &crtc_box, 1);
	    crtc_region = &crtc_region_local;
	    RegionIntersect(crtc_region, crtc_region, reg);
	}
	*crtc_ret = crtc;
d3138 2
a3139 2
    ret = xf86XVClipVideoHelper(dst, xa, xb, ya, yb, 
				crtc_region, width, height);
d3142 1
a3142 1
	RegionUninit(&crtc_region_local);
d3146 1
d3149 1
a3149 1
xf86_wrap_crtc_notify (ScreenPtr screen, xf86_crtc_notify_proc_ptr new)
d3151 8
a3158 9
    if (xf86CrtcConfigPrivateIndex != -1)
    {
	ScrnInfoPtr		scrn = xf86Screens[screen->myNum];
	xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
	xf86_crtc_notify_proc_ptr	old;
	
	old = config->xf86_crtc_notify;
	config->xf86_crtc_notify = new;
	return old;
d3166 5
a3170 6
    if (xf86CrtcConfigPrivateIndex != -1)
    {
	ScrnInfoPtr		scrn = xf86Screens[screen->myNum];
	xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
    
	config->xf86_crtc_notify = old;
d3177 3
a3179 3
    ScrnInfoPtr		scrn = xf86Screens[screen->myNum];
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
    
d3181 1
a3181 1
	config->xf86_crtc_notify(screen);
d3188 2
a3189 2
	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
	xf86CrtcPtr crtc;
d3191 6
a3196 6
	/* for multiple drivers loaded we need this */
	if (!xf86_config)
		return FALSE;
	if (xf86_config->num_crtc == 0)
	    return FALSE;
	crtc = xf86_config->crtc[0];
d3198 1
a3198 1
	return crtc->funcs->gamma_set != NULL;
@


1.9
log
@Update to xserver 1.11.2
@
text
@d1918 17
a1934 12
    if (scrn->modes != NULL) {
	/* For some reason, scrn->modes is circular, unlike the other mode
	 * lists.  How great is that?
	 */
	for (last = scrn->modes; last && last->next; last = last->next)
	    ;
	last->next = scrn->modes;
	scrn->modes->prev = last;
	if (mode) {
	    while (scrn->modes != mode)
		scrn->modes = scrn->modes->next;
	}
d1936 1
d2538 1
a2538 10
    if (have_outputs) {
	/* Mirror output modes to scrn mode list */
	xf86SetScrnInfoModes (scrn);
    } else {
	/* Clear any existing modes from scrn->modes */
	while (scrn->modes != NULL)
	    xf86DeleteMode(&scrn->modes, scrn->modes);
	scrn->modes = xf86ModesAdd(scrn->modes,
				   xf86CVTMode(width, height, 60, 0, 0));
    }
@


1.8
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d136 1
d375 2
d413 2
d421 2
a483 1
    static const char monitor_prefix[] = "monitor-";
d493 2
a494 5
    
    option_name = xnfalloc (strlen (monitor_prefix) +
			    strlen (output->name) + 1);
    strcpy (option_name, monitor_prefix);
    strcat (option_name, output->name);
d666 1
a666 2
    int	    len = strlen(name) + 1;
    char    *newname = malloc(len);
a670 1
    strcpy (newname, name);
a1515 1
    enum { sync_config, sync_edid, sync_default };
d2063 10
a2072 4
		for (mode = output->probed_modes; mode; mode = mode->next) {
		    Rotation r = output->initial_rotation;
		    if (xf86ModeWidth(mode, r) == pref_width &&
			    xf86ModeHeight(mode, r) == pref_height) {
d2075 10
a2084 1
		    }
d2915 2
d2987 1
a2987 2
    if (output->MonInfo != NULL)
	free(output->MonInfo);
@


1.7
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d1569 1
a1569 1
	Bool		    add_default_modes = xf86ReturnOptValBool(output->options, OPTION_DEFAULT_MODES, TRUE);
d1615 8
d2358 1
d2417 1
a2417 5
    {
	free(crtcs);
	free(modes);
	return FALSE;
    }
d2428 1
a2428 5
    {
	free(crtcs);
	free(modes);
	return FALSE;
    }
d2505 1
a2505 1
	return FALSE;
d2528 2
a2529 1
    
d2532 2
a2533 1
    return TRUE;
d2974 2
@


1.6
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a44 1
#ifdef RENDER
a45 1
#endif
d49 2
d95 1
a95 1
    crtc = xcalloc (sizeof (xf86CrtcRec), 1);
d123 1
a123 1
	xfree (crtc);
d130 1
a130 1
	crtcs = xrealloc (xf86_config->crtc,
d133 1
a133 1
	crtcs = xalloc ((xf86_config->num_crtc + 1) * sizeof (xf86CrtcPtr));
d136 1
a136 1
	xfree (crtc);
d160 1
a160 2
    if (crtc->params)
	xfree (crtc->params);
d162 1
a162 1
    xfree (crtc);
a185 1
#ifdef RENDER
a243 1
#endif
d384 2
a385 3
    if (adjusted_mode->name)
	    xfree(adjusted_mode->name);
    xfree(adjusted_mode);
d442 1
d460 1
d483 1
a483 2
    if (output->options)
	xfree (output->options);
d497 1
a497 1
    xfree (option_name);
d575 3
a577 1
    if (!rotate_name)
d579 1
d583 1
a583 1
	    return (1 << i);
d602 1
a602 1
    output = xcalloc (sizeof (xf86OutputRec) + len, 1);
d625 1
a625 1
	    xfree (output);
d632 1
a632 1
	outputs = xrealloc (xf86_config->output,
d635 1
a635 1
	outputs = xalloc ((xf86_config->num_output + 1) * sizeof (xf86OutputPtr));
d638 1
a638 1
	xfree (output);
d664 1
a664 1
    char    *newname = xalloc (len);
d671 1
a671 1
	xfree (output->name);
d709 2
a710 2
	xfree (output->name);
    xfree (output);
d759 2
d959 1
a959 1
    crtcs = xalloc (config->num_output * sizeof (xf86CrtcPtr));
d1015 1
a1015 1
    xfree (crtcs);
d1046 2
a1047 2
	    crtc_width = crtc->x + xf86ModeWidth (&crtc->desiredMode, crtc->desiredRotation);
	    crtc_height = crtc->y + xf86ModeHeight (&crtc->desiredMode, crtc->desiredRotation);
d1424 2
a1425 2
	    xfree (n->name);
	    xfree (n);
d1569 1
a1569 1
	Bool                add_default_modes = TRUE;
d1930 1
a1930 1
static void
d1945 1
a1945 1
	    enabled[o] = xf86OutputEnabled(config->output[o], FALSE);
d1947 2
d2112 2
a2113 2
    xfree(preferred);
    xfree(preferred_match);
d2168 1
a2168 1
    xfree(aspects);
d2209 1
a2209 1
    return (target_mode != NULL);
d2348 2
d2375 17
a2391 12
    xf86CollectEnabledOutputs(scrn, config, enabled);

    if (xf86TargetUserpref(scrn, config, modes, enabled, width, height))
	xf86DrvMsg(i, X_INFO, "Using user preference for initial modes\n");
    else if (xf86TargetPreferred(scrn, config, modes, enabled, width, height))
	xf86DrvMsg(i, X_INFO, "Using exact sizes for initial modes\n");
    else if (xf86TargetAspect(scrn, config, modes, enabled, width, height))
	xf86DrvMsg(i, X_INFO, "Using fuzzy aspect match for initial modes\n");
    else if (xf86TargetFallback(scrn, config, modes, enabled, width, height))
	xf86DrvMsg(i, X_INFO, "Using sloppy heuristic for initial modes\n");
    else
	xf86DrvMsg(i, X_WARNING, "Unable to find initial modes\n");
d2409 2
a2410 2
	xfree (crtcs);
	xfree (modes);
d2422 1
a2422 1
    if (!xf86PickCrtcs (scrn, crtcs, modes, 0, width, height))
d2424 2
a2425 2
	xfree (crtcs);
	xfree (modes);
d2484 7
d2516 11
a2526 2
    /* Mirror output modes to scrn mode list */
    xf86SetScrnInfoModes (scrn);
d2528 2
a2529 2
    xfree (crtcs);
    xfree (modes);
d2968 1
a2968 1
	xfree(output->MonInfo);
d3160 1
a3160 1
	    REGION_INIT (pScreen, &crtc_region_local, &crtc_box, 1);
d3162 1
a3162 1
	    REGION_INTERSECT (pScreen, crtc_region, crtc_region, reg);
d3171 1
a3171 1
	REGION_UNINIT (pScreen, &crtc_region_local);
d3228 1
a3228 1
	return (crtc->funcs->gamma_set != NULL);
@


1.5
log
@Add a configure test for newer proto headers and use it to enable
building xserver 1.6 with those headers. ok oga@@.
@
text
@d43 1
a43 6
#ifdef HAVE_X11_EXTENSIONS_DPMSCONST_H
#include <X11/extensions/dpmsproto.h>
#else
#define DPMS_SERVER
#include "X11/extensions/dpms.h"
#endif
d57 1
a57 1
_X_EXPORT void
d72 1
a72 1
_X_EXPORT void
d88 1
a88 1
_X_EXPORT xf86CrtcPtr
d119 10
d144 1
a144 1
_X_EXPORT void
d162 1
d171 1
a171 1
_X_EXPORT Bool
d184 1
a184 1
_X_EXPORT void
d252 1
a252 1
_X_EXPORT Bool
a256 2
    /* During ScreenInit() scrn->pScreen is still NULL */
    ScreenPtr		pScreen = screenInfo.screens[scrn->scrnIndex];
d270 1
d273 2
a274 1
	/* XXX disable crtc? */
d356 5
a369 1
    /* XXX free adjustedmode */
a370 2
    if (scrn->pScreen)
	xf86CrtcSetScreenSubpixelOrder (scrn->pScreen);
d373 5
a377 1
    if (!ret) {
d387 4
d401 1
a401 1
_X_EXPORT Bool
d411 1
a411 1
_X_EXPORT void
d445 1
d462 1
d471 1
a471 1
    {OPTION_MODEDEBUG,	    "ModeDebug",	OPTV_STRING,  {0}, FALSE },
d587 1
a587 1
_X_EXPORT xf86OutputPtr
d595 1
d641 1
a641 1
    
d643 14
a656 2
    xf86_config->output[xf86_config->num_output++] = output;
    
d660 1
a660 1
_X_EXPORT Bool
d679 1
a679 1
_X_EXPORT void
d689 1
a689 1
_X_EXPORT void
a764 1
_X_EXPORT
a1379 28
/*
 * XXX walk the monitor mode list and prune out duplicates that
 * are inserted by xf86DDCMonitorSet. In an ideal world, that
 * function would do this work by itself.
 */

static void
xf86PruneDuplicateMonitorModes (MonPtr Monitor)
{
    DisplayModePtr  master, clone, next;

    for (master = Monitor->Modes; 
	 master && master != Monitor->Last; 
	 master = master->next)
    {
	for (clone = master->next; clone && clone != Monitor->Modes; clone = next)
	{
	    next = clone->next;
	    if (xf86ModesEqual (master, clone))
	    {
		if (Monitor->Last == clone)
		    Monitor->Last = clone->prev;
		xf86DeleteMode (&Monitor->Modes, clone);
	    }
	}
    }
}

d1498 41
a1538 1
_X_EXPORT void
a1553 3
    /* Elide duplicate modes before defaulting code uses them */
    xf86PruneDuplicateMonitorModes (scrn->monitor);
    
d1568 3
a1570 1
	enum { sync_config, sync_edid, sync_default } sync_source = sync_default;
d1580 2
a1581 1
	if (output->status == XF86OutputStatusDisconnected)
d1616 4
a1619 6
	if (edid_monitor)
	{
	    int			    i;
	    Bool		    set_hsync = mon_rec.nHsync == 0;
	    Bool		    set_vrefresh = mon_rec.nVrefresh == 0;
	    struct disp_features    *features = &edid_monitor->features;
d1625 9
a1633 25
	    for (i = 0; i < sizeof (edid_monitor->det_mon) / sizeof (edid_monitor->det_mon[0]); i++)
	    {
		if (edid_monitor->det_mon[i].type == DS_RANGES)
		{
		    struct monitor_ranges   *ranges = &edid_monitor->det_mon[i].section.ranges;
		    if (set_hsync && ranges->max_h)
		    {
			mon_rec.hsync[mon_rec.nHsync].lo = ranges->min_h;
			mon_rec.hsync[mon_rec.nHsync].hi = ranges->max_h;
			mon_rec.nHsync++;
			if (sync_source == sync_default)
			    sync_source = sync_edid;
		    }
		    if (set_vrefresh && ranges->max_v)
		    {
			mon_rec.vrefresh[mon_rec.nVrefresh].lo = ranges->min_v;
			mon_rec.vrefresh[mon_rec.nVrefresh].hi = ranges->max_v;
			mon_rec.nVrefresh++;
			if (sync_source == sync_default)
			    sync_source = sync_edid;
		    }
		    if (ranges->max_clock * 1000 > max_clock)
			max_clock = ranges->max_clock * 1000;
		}
	    }
d1666 1
a1666 2
	    default_modes = xf86GetDefaultModes (output->interlaceAllowed,
						 output->doubleScanAllowed);
d1703 1
a1703 1
	 * Check all modes against max size
d1708 6
d1722 1
a1722 2
	xf86PruneInvalidModes(scrn, &output->probed_modes,
			      config->debug_modes);
d1754 1
a1754 1
	if (config->debug_modes) {
d1773 1
a1773 1
	    if (config->debug_modes)
d1785 1
a1785 1
_X_EXPORT void
d1880 1
a1880 1
_X_EXPORT void
d1929 2
a1930 1
xf86EnableOutputs(ScrnInfoPtr scrn, xf86CrtcConfigPtr config, Bool *enabled)
d2226 93
d2334 1
a2334 1
_X_EXPORT Bool
d2369 1
a2369 1
    xf86EnableOutputs(scrn, config, enabled);
d2429 3
d2433 4
a2436 1
    
a2453 2
	    crtc->x = output->initial_x;
	    crtc->y = output->initial_y;
d2458 2
d2464 1
a2464 1
    
d2573 1
a2573 1
_X_EXPORT Bool
d2598 2
a2599 2
	if (config->output[config->compat_output]->crtc == crtc)
	    output = config->output[config->compat_output];
d2651 1
a2651 1
_X_EXPORT DisplayModePtr
d2714 1
a2714 1
_X_EXPORT Bool
d2719 2
a2720 2
    xf86OutputPtr	compat_output = config->output[config->compat_output];
    DisplayModePtr	compat_mode;
d2726 3
a2728 1
    compat_mode = xf86OutputFindClosestMode (compat_output, desired);
d2789 1
a2789 1
_X_EXPORT void
d2827 1
a2827 1
_X_EXPORT Bool
d2843 1
a2843 1
_X_EXPORT void
d2865 1
d2874 1
a2874 1
#define EDID_ATOM_NAME		"EDID_DATA"
d2898 29
d2930 1
a2930 1
_X_EXPORT void
d2935 1
a2935 1
    int			i;
d2945 1
a2945 1
    if (config->debug_modes) {
d2952 1
a2952 1
    if (output == config->output[config->compat_output])
d2970 9
a2978 14
    if (edid_mon)
    {
	/* Pull out a phyiscal size from a detailed timing if available. */
	for (i = 0; i < 4; i++) {
	    if (edid_mon->det_mon[i].type == DT &&
		edid_mon->det_mon[i].section.d_timings.h_size != 0 &&
		edid_mon->det_mon[i].section.d_timings.v_size != 0)
	    {
		output->mm_width = edid_mon->det_mon[i].section.d_timings.h_size;
		output->mm_height = edid_mon->det_mon[i].section.d_timings.v_size;
		break;
	    }
	}
    
d2993 1
a2993 1
_X_EXPORT DisplayModePtr
d3005 1
a3005 1
_X_EXPORT xf86MonPtr
d3024 1
a3024 1
_X_EXPORT char *
d3109 1
a3109 1
_X_EXPORT Bool
d3185 20
@


1.4
log
@Update to server 1.6.5.
@
text
@d43 3
d48 1
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d774 3
d1890 4
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d99 1
d107 13
d151 2
d243 2
a244 2
xf86CrtcSetMode (xf86CrtcPtr crtc, DisplayModePtr mode, Rotation rotation,
		 int x, int y)
d247 2
d257 2
a259 3
    if (crtc->funcs->set_mode_major)
	return crtc->funcs->set_mode_major(crtc, mode, rotation, x, y);
	
d261 1
a261 1
    
a269 1
    didLock = crtc->funcs->lock (crtc);
d275 6
d288 5
d294 3
a296 22
    /* Shift offsets that move us out of virtual size */
    if (x + mode->HDisplay > xf86_config->maxWidth ||
	y + mode->VDisplay > xf86_config->maxHeight)
    {
	if (x + mode->HDisplay > xf86_config->maxWidth)
	    crtc->x = xf86_config->maxWidth - mode->HDisplay;
	if (y + mode->VDisplay > xf86_config->maxHeight)
	    crtc->y = xf86_config->maxHeight - mode->VDisplay;
	if (crtc->x < 0 || crtc->y < 0)
	{
	    xf86DrvMsg (scrn->scrnIndex, X_ERROR,
			"Mode %dx%d does not fit virtual size %dx%d - "
			"internal error\n", mode->HDisplay, mode->VDisplay,
			xf86_config->maxWidth, xf86_config->maxHeight);
	    goto done;
	}
	xf86DrvMsg (scrn->scrnIndex, X_ERROR,
		    "Mode %dx%d+%d+%d does not fit virtual size %dx%d - "
		    "offset updated to +%d+%d\n",
		    mode->HDisplay, mode->VDisplay, x, y,
		    xf86_config->maxWidth, xf86_config->maxHeight,
		    crtc->x, crtc->y);
d299 1
a299 2
    /* XXX short-circuit changes to base location only */
    
d319 1
a319 1
    if (!xf86CrtcRotate (crtc, mode, rotation)) {
a320 1
    }
a351 1
	{
a352 5
#ifdef RANDR_12_INTERFACE
	    if (output->randr_output)
		RRPostPendingProperties (output->randr_output);
#endif
	}
d366 3
d377 28
d424 1
d440 1
d730 6
a735 1
_X_EXPORT Bool
d755 1
d759 2
d762 1
d764 2
d774 3
d778 1
d956 1
a956 1
		config->output[0]->initial_rotation == config->output[n]->initial_rotation &&
d1227 2
a1228 1
		    output->initial_y -= xf86ModeHeight (modes[o], relative->initial_rotation);
d1231 2
a1232 1
		    output->initial_x -= xf86ModeWidth (modes[o], relative->initial_rotation);
d1290 53
d1513 1
a1513 1
	DisplayModePtr	    config_modes = NULL, output_modes, default_modes;
d1521 1
d1572 5
d1633 4
a1636 2
	default_modes = xf86GetDefaultModes (output->interlaceAllowed,
					     output->doubleScanAllowed);
d1923 60
d2034 28
a2073 60
aspectMatch(float a, float b)
{
    return fabs(1 - (a / b)) < 0.05;
}

static DisplayModePtr
nextAspectMode(xf86OutputPtr o, DisplayModePtr last, float aspect)
{
    DisplayModePtr m = NULL;

    if (!o)
	return NULL;

    if (!last)
	m = o->probed_modes;
    else
	m = last->next;

    for (; m; m = m->next)
	if (aspectMatch(aspect, (float)m->HDisplay / (float)m->VDisplay))
	    return m;

    return NULL;
}

static DisplayModePtr
bestModeForAspect(xf86CrtcConfigPtr config, Bool *enabled, float aspect)
{
    int o = -1, p;
    DisplayModePtr mode = NULL, test = NULL, match = NULL;

    if (!nextEnabledOutput(config, enabled, &o))
	return NULL;
    while ((mode = nextAspectMode(config->output[o], mode, aspect))) {
	test = mode;
	for (p = o; nextEnabledOutput(config, enabled, &p); ) {
	    test = xf86OutputFindClosestMode(config->output[p], mode);
	    if (!test)
		break;
	    if (test->HDisplay != mode->HDisplay ||
		    test->VDisplay != mode->VDisplay) {
		test = NULL;
		break;
	    }
	}

	/* if we didn't match it on all outputs, try the next one */
	if (!test)
	    continue;

	/* if it's bigger than the last one, save it */
	if (!match || (test->HDisplay > match->HDisplay))
	    match = test;
    }

    /* return the biggest one found */
    return match;
}

static Bool
d2269 5
d2313 1
d2317 3
d2368 62
d2438 2
a2439 1
    int			c, o;
d2441 4
a2444 8
    /*
     * Turn off everything so mode setting is done
     * with hardware in a consistent state
     */
    for (o = 0; o < config->num_output; o++) 
    {
	xf86OutputPtr  output = config->output[o];
	(*output->funcs->dpms)(output, DPMSModeOff);
a2446 8
    for (c = 0; c < config->num_crtc; c++) 
    {
	xf86CrtcPtr crtc = config->crtc[c];

	crtc->funcs->dpms(crtc, DPMSModeOff);
	memset(&crtc->mode, 0, sizeof(crtc->mode));
    }
    
a2448 1
	xf86CrtcPtr	crtc = config->crtc[c];
d2451 3
d2484 1
d2489 6
a2494 2
	if (!xf86CrtcSetMode (crtc, &crtc->desiredMode, crtc->desiredRotation,
			      crtc->desiredX, crtc->desiredY))
d2623 1
a2623 1
	if (!xf86CrtcSetMode (crtc, crtc_mode, rotation, 0, 0))
d2629 1
d2635 1
a2635 1
#if RANDR_12_INTERFACE
d2723 1
d2726 2
d2789 1
a2789 1
	if (edid_mon->ver.version == 1)
d2791 3
a2793 1
	else if (edid_mon->ver.version == 2)
d2838 1
d2845 1
a2845 1
    mon = xf86DoEDID_DDC2 (scrn->scrnIndex, pDDCBus);
d2847 1
a2847 1
        xf86DDCApplyQuirks (scrn->scrnIndex, mon);
d2981 38
@


1.1
log
@Initial revision
@
text
@d3 1
d40 1
d240 3
d267 24
d332 1
a332 1
    crtc->funcs->mode_set(crtc, mode, adjusted_mode, x, y);
d470 1
a470 1
xf86OutputEnabled (xf86OutputPtr output)
d488 10
a497 2
    /* otherwise, enable if it is not disconnected */
    enable = output->status != XF86OutputStatusDisconnected;
d744 1
a744 1
	mm_height = 203;	/* 768 pixels at 96dpi */
d746 1
a746 1
     * Pick a mode closest to 96dpi 
d751 2
a752 1
	int	    preferred = (mode->type & M_T_PREFERRED) != 0;
d761 1
a761 1
	diff = dpi - 96;
d812 1
a812 1
static Bool
d824 1
a824 1
	    return TRUE;
d826 13
a838 1
    return FALSE;
d1000 48
d1154 10
d1179 1
a1179 1
		    output->initial_y -= xf86ModeHeight (modes[or], relative->initial_rotation);
d1182 1
a1182 1
		    output->initial_x -= xf86ModeWidth (modes[or], relative->initial_rotation);
d1325 61
d1490 2
a1491 2
		    if (ranges->max_clock > max_clock)
			max_clock = ranges->max_clock;
d1503 4
d1526 8
a1533 1
	
d1549 1
a1549 1
	if (max_clock)
d1552 3
d1581 1
a1581 2
	preferred_mode = xf86GetOptValString (output->options,
					      OPTION_PREFERRED_MODE);
d1600 2
a1601 1
		    mode->type |= M_T_PREFERRED;
a1602 2
		else
		    mode->type &= ~M_T_PREFERRED;
d1642 92
d1740 1
a1740 1
    DisplayModePtr	last, mode;
d1742 4
a1745 4
    output = config->output[config->compat_output];
    if (!output->crtc)
    {
	int o;
a1746 12
	output = NULL;
	for (o = 0; o < config->num_output; o++)
	    if (config->output[o]->crtc)
	    {
		config->compat_output = o;
		output = config->output[o];
		break;
	    }
	/* no outputs are active, punt and leave things as they are */
	if (!output)
	    return;
    }
d1756 5
a1760 3
    for (mode = scrn->modes; mode; mode = mode->next)
	if (xf86ModesEqual (mode, &crtc->desiredMode))
	    break;
d1778 270
a2066 2
    DisplayModePtr	target_mode = NULL;
    Rotation		target_rotation = RR_Rotate_0;
d2070 2
a2071 2
    int			width;
    int			height;
d2097 12
a2108 14
    for (o = 0; o < config->num_output; o++)
    {
	xf86OutputPtr output = config->output[o];
	
	modes[o] = NULL;
	enabled[o] = xf86OutputEnabled (output);
    }
    
    /*
     * Let outputs with preferred modes drive screen size
     */
    for (o = 0; o < config->num_output; o++)
    {
	xf86OutputPtr output = config->output[o];
d2110 9
a2118 49
	if (enabled[o] &&
	    xf86OutputHasPreferredMode (output, width, height))
	{
	    target_mode = xf86DefaultMode (output, width, height);
	    target_rotation = output->initial_rotation;
	    if (target_mode)
	    {
		modes[o] = target_mode;
		config->compat_output = o;
		break;
	    }
	}
    }
    if (!target_mode)
    {
	for (o = 0; o < config->num_output; o++)
	{
	    xf86OutputPtr output = config->output[o];
	    if (enabled[o])
	    {
		target_mode = xf86DefaultMode (output, width, height);
		target_rotation = output->initial_rotation;
		if (target_mode)
		{
		    modes[o] = target_mode;
		    config->compat_output = o;
		    break;
		}
	    }
	}
    }
    for (o = 0; o < config->num_output; o++)
    {
	xf86OutputPtr output = config->output[o];
	
	if (enabled[o])
	{
	    if (!modes[o])
		modes[o] = xf86ClosestMode (output, target_mode,
					    target_rotation, width, height);
	    if (!modes[o])
		xf86DrvMsg (scrn->scrnIndex, X_ERROR,
			    "Output %s enabled but has no modes\n",
			    output->name);
	    else
		xf86DrvMsg (scrn->scrnIndex, X_INFO,
			    "Output %s using initial mode %s\n",
			    output->name, modes[o]->name);
	}
d2173 2
d2254 4
d2269 1
a2269 3
	/*
	 * Skip disabled crtcs
	 */
d2630 1
d2632 5
a2636 1
    return xf86DoEDID_DDC2 (scrn->scrnIndex, pDDCBus);
d2639 6
a2644 3
static char *_xf86ConnectorNames[] = { "None", "VGA", "DVI-I", "DVI-D",
				      "DVI-A", "Composite", "S-Video",
				      "Component", "LFP", "Proprietary" };
d2724 4
a2727 1
 * clip video to that
@


1.1.1.1
log
@xserver 1.4
@
text
@@
