head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.12
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.10
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.8
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.6
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.04.02.16.08.39;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.01.21;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.01.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#else
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#endif

#include "xf86Modes.h"
#include "xf86Priv.h"

extern XF86ConfigPtr xf86configptr;

/**
 * Calculates the horizontal sync rate of a mode.
 */
double
xf86ModeHSync(const DisplayModeRec * mode)
{
    double hsync = 0.0;

    if (mode->HSync > 0.0)
        hsync = mode->HSync;
    else if (mode->HTotal > 0)
        hsync = (float) mode->Clock / (float) mode->HTotal;

    return hsync;
}

/**
 * Calculates the vertical refresh rate of a mode.
 */
double
xf86ModeVRefresh(const DisplayModeRec * mode)
{
    double refresh = 0.0;

    if (mode->VRefresh > 0.0)
        refresh = mode->VRefresh;
    else if (mode->HTotal > 0 && mode->VTotal > 0) {
        refresh = mode->Clock * 1000.0 / mode->HTotal / mode->VTotal;
        if (mode->Flags & V_INTERLACE)
            refresh *= 2.0;
        if (mode->Flags & V_DBLSCAN)
            refresh /= 2.0;
        if (mode->VScan > 1)
            refresh /= (float) (mode->VScan);
    }
    return refresh;
}

int
xf86ModeWidth(const DisplayModeRec * mode, Rotation rotation)
{
    switch (rotation & 0xf) {
    case RR_Rotate_0:
    case RR_Rotate_180:
        return mode->HDisplay;
    case RR_Rotate_90:
    case RR_Rotate_270:
        return mode->VDisplay;
    default:
        return 0;
    }
}

int
xf86ModeHeight(const DisplayModeRec * mode, Rotation rotation)
{
    switch (rotation & 0xf) {
    case RR_Rotate_0:
    case RR_Rotate_180:
        return mode->VDisplay;
    case RR_Rotate_90:
    case RR_Rotate_270:
        return mode->HDisplay;
    default:
        return 0;
    }
}

/** Calculates the memory bandwidth (in MiB/sec) of a mode. */
unsigned int
xf86ModeBandwidth(DisplayModePtr mode, int depth)
{
    float a_active, a_total, active_percent, pixels_per_second;
    int bytes_per_pixel = bits_to_bytes(depth);

    if (!mode->HTotal || !mode->VTotal || !mode->Clock)
        return 0;

    a_active = mode->HDisplay * mode->VDisplay;
    a_total = mode->HTotal * mode->VTotal;
    active_percent = a_active / a_total;
    pixels_per_second = active_percent * mode->Clock * 1000.0;

    return (unsigned int) (pixels_per_second * bytes_per_pixel / (1024 * 1024));
}

/** Sets a default mode name of <width>x<height> on a mode. */
void
xf86SetModeDefaultName(DisplayModePtr mode)
{
    Bool interlaced = ! !(mode->Flags & V_INTERLACE);
    char *tmp;

    free((void *) mode->name);

    XNFasprintf(&tmp, "%dx%d%s", mode->HDisplay, mode->VDisplay,
                interlaced ? "i" : "");
    mode->name = tmp;
}

/*
 * xf86SetModeCrtc
 *
 * Initialises the Crtc parameters for a mode.  The initialisation includes
 * adjustments for interlaced and double scan modes.
 */
void
xf86SetModeCrtc(DisplayModePtr p, int adjustFlags)
{
    if ((p == NULL) || ((p->type & M_T_CRTC_C) == M_T_BUILTIN))
        return;

    p->CrtcHDisplay = p->HDisplay;
    p->CrtcHSyncStart = p->HSyncStart;
    p->CrtcHSyncEnd = p->HSyncEnd;
    p->CrtcHTotal = p->HTotal;
    p->CrtcHSkew = p->HSkew;
    p->CrtcVDisplay = p->VDisplay;
    p->CrtcVSyncStart = p->VSyncStart;
    p->CrtcVSyncEnd = p->VSyncEnd;
    p->CrtcVTotal = p->VTotal;
    if (p->Flags & V_INTERLACE) {
        if (adjustFlags & INTERLACE_HALVE_V) {
            p->CrtcVDisplay /= 2;
            p->CrtcVSyncStart /= 2;
            p->CrtcVSyncEnd /= 2;
            p->CrtcVTotal /= 2;
        }
        /* Force interlaced modes to have an odd VTotal */
        /* maybe we should only do this when INTERLACE_HALVE_V is set? */
        p->CrtcVTotal |= 1;
    }

    if (p->Flags & V_DBLSCAN) {
        p->CrtcVDisplay *= 2;
        p->CrtcVSyncStart *= 2;
        p->CrtcVSyncEnd *= 2;
        p->CrtcVTotal *= 2;
    }
    if (p->VScan > 1) {
        p->CrtcVDisplay *= p->VScan;
        p->CrtcVSyncStart *= p->VScan;
        p->CrtcVSyncEnd *= p->VScan;
        p->CrtcVTotal *= p->VScan;
    }
    p->CrtcVBlankStart = min(p->CrtcVSyncStart, p->CrtcVDisplay);
    p->CrtcVBlankEnd = max(p->CrtcVSyncEnd, p->CrtcVTotal);
    p->CrtcHBlankStart = min(p->CrtcHSyncStart, p->CrtcHDisplay);
    p->CrtcHBlankEnd = max(p->CrtcHSyncEnd, p->CrtcHTotal);

    p->CrtcHAdjusted = FALSE;
    p->CrtcVAdjusted = FALSE;
}

/**
 * Fills in a copy of mode, removing all stale pointer references.
 * xf86ModesEqual will return true when comparing with original mode.
 */
void
xf86SaveModeContents(DisplayModePtr intern, const DisplayModeRec *mode)
{
    *intern = *mode;
    intern->prev = intern->next = NULL;
    intern->name = NULL;
    intern->PrivSize = 0;
    intern->PrivFlags = 0;
    intern->Private = NULL;
}

/**
 * Allocates and returns a copy of pMode, including pointers within pMode.
 */
DisplayModePtr
xf86DuplicateMode(const DisplayModeRec * pMode)
{
    DisplayModePtr pNew;

    pNew = xnfalloc(sizeof(DisplayModeRec));
    *pNew = *pMode;
    pNew->next = NULL;
    pNew->prev = NULL;

    if (pMode->name == NULL)
        xf86SetModeDefaultName(pNew);
    else
        pNew->name = xnfstrdup(pMode->name);

    return pNew;
}

/**
 * Duplicates every mode in the given list and returns a pointer to the first
 * mode.
 *
 * \param modeList doubly-linked mode list
 */
DisplayModePtr
xf86DuplicateModes(ScrnInfoPtr pScrn, DisplayModePtr modeList)
{
    DisplayModePtr first = NULL, last = NULL;
    DisplayModePtr mode;

    for (mode = modeList; mode != NULL; mode = mode->next) {
        DisplayModePtr new;

        new = xf86DuplicateMode(mode);

        /* Insert pNew into modeList */
        if (last) {
            last->next = new;
            new->prev = last;
        }
        else {
            first = new;
            new->prev = NULL;
        }
        new->next = NULL;
        last = new;
    }

    return first;
}

/**
 * Returns true if the given modes should program to the same timings.
 *
 * This doesn't use Crtc values, as it might be used on ModeRecs without the
 * Crtc values set.  So, it's assumed that the other numbers are enough.
 */
Bool
xf86ModesEqual(const DisplayModeRec * pMode1, const DisplayModeRec * pMode2)
{
    if (pMode1->Clock == pMode2->Clock &&
        pMode1->HDisplay == pMode2->HDisplay &&
        pMode1->HSyncStart == pMode2->HSyncStart &&
        pMode1->HSyncEnd == pMode2->HSyncEnd &&
        pMode1->HTotal == pMode2->HTotal &&
        pMode1->HSkew == pMode2->HSkew &&
        pMode1->VDisplay == pMode2->VDisplay &&
        pMode1->VSyncStart == pMode2->VSyncStart &&
        pMode1->VSyncEnd == pMode2->VSyncEnd &&
        pMode1->VTotal == pMode2->VTotal &&
        pMode1->VScan == pMode2->VScan && pMode1->Flags == pMode2->Flags) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

static void
add(char **p, const char *new)
{
    *p = xnfrealloc(*p, strlen(*p) + strlen(new) + 2);
    strcat(*p, " ");
    strcat(*p, new);
}

/**
 * Print out a modeline.
 *
 * The mode type bits are informational except for the capitalized U
 * and P bits which give sort order priority.  Letter map:
 *
 * USERPREF, U, user preferred is set from the xorg.conf Monitor
 * Option "PreferredMode" or from the Screen Display Modes statement.
 * This unique modeline is moved to the head of the list after sorting.
 *
 * DRIVER, e, is set by the video driver, EDID or flat panel native.
 *
 * USERDEF, z, a configured zoom mode Ctrl+Alt+Keypad-{Plus,Minus}.
 *
 * DEFAULT, d, a compiled-in default.
 *
 * PREFERRED, P, driver preferred is set by the video device driver,
 * e.g. the EDID detailed timing modeline.  This is a true sort
 * priority and multiple P modes form a sorted sublist at the list
 * head.
 *
 * BUILTIN, b, a hardware fixed CRTC mode.
 *
 * See modes/xf86Crtc.c: xf86ProbeOutputModes().
 */
void
xf86PrintModeline(int scrnIndex, DisplayModePtr mode)
{
    char tmp[256];
    char *flags = xnfcalloc(1, 1);

#define TBITS 6
    const char tchar[TBITS + 1] = "UezdPb";

    int tbit[TBITS] = {
        M_T_USERPREF, M_T_DRIVER, M_T_USERDEF,
        M_T_DEFAULT, M_T_PREFERRED, M_T_BUILTIN
    };
    char type[TBITS + 2];       /* +1 for leading space */

#undef TBITS
    int tlen = 0;

    if (mode->type) {
        int i;

        type[tlen++] = ' ';
        for (i = 0; tchar[i]; i++)
            if (mode->type & tbit[i])
                type[tlen++] = tchar[i];
    }
    type[tlen] = '\0';

    if (mode->HSkew) {
        snprintf(tmp, 256, "hskew %i", mode->HSkew);
        add(&flags, tmp);
    }
    if (mode->VScan) {
        snprintf(tmp, 256, "vscan %i", mode->VScan);
        add(&flags, tmp);
    }
    if (mode->Flags & V_INTERLACE)
        add(&flags, "interlace");
    if (mode->Flags & V_CSYNC)
        add(&flags, "composite");
    if (mode->Flags & V_DBLSCAN)
        add(&flags, "doublescan");
    if (mode->Flags & V_BCAST)
        add(&flags, "bcast");
    if (mode->Flags & V_PHSYNC)
        add(&flags, "+hsync");
    if (mode->Flags & V_NHSYNC)
        add(&flags, "-hsync");
    if (mode->Flags & V_PVSYNC)
        add(&flags, "+vsync");
    if (mode->Flags & V_NVSYNC)
        add(&flags, "-vsync");
    if (mode->Flags & V_PCSYNC)
        add(&flags, "+csync");
    if (mode->Flags & V_NCSYNC)
        add(&flags, "-csync");
#if 0
    if (mode->Flags & V_CLKDIV2)
        add(&flags, "vclk/2");
#endif
    xf86DrvMsg(scrnIndex, X_INFO,
               "Modeline \"%s\"x%.01f  %6.2f  %i %i %i %i  %i %i %i %i%s"
               " (%.01f kHz%s)\n",
               mode->name, mode->VRefresh, mode->Clock / 1000.,
               mode->HDisplay, mode->HSyncStart, mode->HSyncEnd, mode->HTotal,
               mode->VDisplay, mode->VSyncStart, mode->VSyncEnd, mode->VTotal,
               flags, xf86ModeHSync(mode), type);
    free(flags);
}

/**
 * Marks as bad any modes with unsupported flags.
 *
 * \param modeList doubly-linked list of modes.
 * \param flags flags supported by the driver.
 *
 * \bug only V_INTERLACE and V_DBLSCAN are supported.  Is that enough?
 */
void
xf86ValidateModesFlags(ScrnInfoPtr pScrn, DisplayModePtr modeList, int flags)
{
    DisplayModePtr mode;

    if (flags == (V_INTERLACE | V_DBLSCAN))
        return;

    for (mode = modeList; mode != NULL; mode = mode->next) {
        if (mode->Flags & V_INTERLACE && !(flags & V_INTERLACE))
            mode->status = MODE_NO_INTERLACE;
        if (mode->Flags & V_DBLSCAN && !(flags & V_DBLSCAN))
            mode->status = MODE_NO_DBLESCAN;
    }
}

/**
 * Marks as bad any modes extending beyond the given max X, Y, or pitch.
 *
 * \param modeList doubly-linked list of modes.
 */
void
xf86ValidateModesSize(ScrnInfoPtr pScrn, DisplayModePtr modeList,
                      int maxX, int maxY, int maxPitch)
{
    DisplayModePtr mode;

    if (maxPitch <= 0)
        maxPitch = MAXINT;
    if (maxX <= 0)
        maxX = MAXINT;
    if (maxY <= 0)
        maxY = MAXINT;

    for (mode = modeList; mode != NULL; mode = mode->next) {
        if ((xf86ModeWidth(mode, RR_Rotate_0) > maxPitch ||
             xf86ModeWidth(mode, RR_Rotate_0) > maxX ||
             xf86ModeHeight(mode, RR_Rotate_0) > maxY) &&
            (xf86ModeWidth(mode, RR_Rotate_90) > maxPitch ||
             xf86ModeWidth(mode, RR_Rotate_90) > maxX ||
             xf86ModeHeight(mode, RR_Rotate_90) > maxY)) {
            if (xf86ModeWidth(mode, RR_Rotate_0) > maxPitch ||
                xf86ModeWidth(mode, RR_Rotate_90) > maxPitch)
                mode->status = MODE_BAD_WIDTH;

            if (xf86ModeWidth(mode, RR_Rotate_0) > maxX ||
                xf86ModeWidth(mode, RR_Rotate_90) > maxX)
                mode->status = MODE_VIRTUAL_X;

            if (xf86ModeHeight(mode, RR_Rotate_0) > maxY ||
                xf86ModeHeight(mode, RR_Rotate_90) > maxY)
                mode->status = MODE_VIRTUAL_Y;
        }

        if (mode->next == modeList)
            break;
    }
}

/**
 * Marks as bad any modes that aren't supported by the given monitor's
 * hsync and vrefresh ranges.
 *
 * \param modeList doubly-linked list of modes.
 */
void
xf86ValidateModesSync(ScrnInfoPtr pScrn, DisplayModePtr modeList, MonPtr mon)
{
    DisplayModePtr mode;

    for (mode = modeList; mode != NULL; mode = mode->next) {
        Bool bad;
        int i;

        bad = TRUE;
        for (i = 0; i < mon->nHsync; i++) {
            if (xf86ModeHSync(mode) >= mon->hsync[i].lo * (1 - SYNC_TOLERANCE)
                && xf86ModeHSync(mode) <=
                mon->hsync[i].hi * (1 + SYNC_TOLERANCE)) {
                bad = FALSE;
            }
        }
        if (bad)
            mode->status = MODE_HSYNC;

        bad = TRUE;
        for (i = 0; i < mon->nVrefresh; i++) {
            if (xf86ModeVRefresh(mode) >=
                mon->vrefresh[i].lo * (1 - SYNC_TOLERANCE) &&
                xf86ModeVRefresh(mode) <=
                mon->vrefresh[i].hi * (1 + SYNC_TOLERANCE)) {
                bad = FALSE;
            }
        }
        if (bad)
            mode->status = MODE_VSYNC;

        if (mode->next == modeList)
            break;
    }
}

/**
 * Marks as bad any modes extending beyond outside of the given clock ranges.
 *
 * \param modeList doubly-linked list of modes.
 * \param min pointer to minimums of clock ranges
 * \param max pointer to maximums of clock ranges
 * \param n_ranges number of ranges.
 */
void
xf86ValidateModesClocks(ScrnInfoPtr pScrn, DisplayModePtr modeList,
                        int *min, int *max, int n_ranges)
{
    DisplayModePtr mode;
    int i;

    for (mode = modeList; mode != NULL; mode = mode->next) {
        Bool good = FALSE;

        for (i = 0; i < n_ranges; i++) {
            if (mode->Clock >= min[i] * (1 - SYNC_TOLERANCE) &&
                mode->Clock <= max[i] * (1 + SYNC_TOLERANCE)) {
                good = TRUE;
                break;
            }
        }
        if (!good)
            mode->status = MODE_CLOCK_RANGE;
    }
}

/**
 * If the user has specified a set of mode names to use, mark as bad any modes
 * not listed.
 *
 * The user mode names specified are prefixes to names of modes, so "1024x768"
 * will match modes named "1024x768", "1024x768x75", "1024x768-good", but
 * "1024x768x75" would only match "1024x768x75" from that list.
 *
 * MODE_BAD is used as the rejection flag, for lack of a better flag.
 *
 * \param modeList doubly-linked list of modes.
 */
void
xf86ValidateModesUserConfig(ScrnInfoPtr pScrn, DisplayModePtr modeList)
{
    DisplayModePtr mode;

    if (pScrn->display->modes[0] == NULL)
        return;

    for (mode = modeList; mode != NULL; mode = mode->next) {
        int i;
        Bool good = FALSE;

        for (i = 0; pScrn->display->modes[i] != NULL; i++) {
            if (strncmp(pScrn->display->modes[i], mode->name,
                        strlen(pScrn->display->modes[i])) == 0) {
                good = TRUE;
                break;
            }
        }
        if (!good)
            mode->status = MODE_BAD;
    }
}

/**
 * Marks as bad any modes exceeding the given bandwidth.
 *
 * \param modeList doubly-linked list of modes.
 * \param bandwidth bandwidth in MHz.
 * \param depth color depth.
 */
void
xf86ValidateModesBandwidth(ScrnInfoPtr pScrn, DisplayModePtr modeList,
                           unsigned int bandwidth, int depth)
{
    DisplayModePtr mode;

    for (mode = modeList; mode != NULL; mode = mode->next) {
        if (xf86ModeBandwidth(mode, depth) > bandwidth)
            mode->status = MODE_BANDWIDTH;
    }
}

Bool
xf86ModeIsReduced(const DisplayModeRec * mode)
{
    if ((((mode->HDisplay * 5 / 4) & ~0x07) > mode->HTotal) &&
        ((mode->HTotal - mode->HDisplay) == 160) &&
        ((mode->HSyncEnd - mode->HDisplay) == 80) &&
        ((mode->HSyncEnd - mode->HSyncStart) == 32) &&
        ((mode->VSyncStart - mode->VDisplay) == 3))
        return TRUE;
    return FALSE;
}

/**
 * Marks as bad any reduced-blanking modes.
 *
 * \param modeList doubly-linked list of modes.
 */
void
xf86ValidateModesReducedBlanking(ScrnInfoPtr pScrn, DisplayModePtr modeList)
{
    for (; modeList != NULL; modeList = modeList->next)
        if (xf86ModeIsReduced(modeList))
            modeList->status = MODE_NO_REDUCED;
}

/**
 * Frees any modes from the list with a status other than MODE_OK.
 *
 * \param modeList pointer to a doubly-linked or circular list of modes.
 * \param verbose determines whether the reason for mode invalidation is
 *	  printed.
 */
void
xf86PruneInvalidModes(ScrnInfoPtr pScrn, DisplayModePtr * modeList,
                      Bool verbose)
{
    DisplayModePtr mode;

    for (mode = *modeList; mode != NULL;) {
        DisplayModePtr next = mode->next, first = *modeList;

        if (mode->status != MODE_OK) {
            if (verbose) {
                const char *type = "";

                if (mode->type & M_T_BUILTIN)
                    type = "built-in ";
                else if (mode->type & M_T_DEFAULT)
                    type = "default ";
                xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                           "Not using %smode \"%s\" (%s)\n", type, mode->name,
                           xf86ModeStatusToString(mode->status));
            }
            xf86DeleteMode(modeList, mode);
        }

        if (next == first)
            break;
        mode = next;
    }
}

/**
 * Adds the new mode into the mode list, and returns the new list
 *
 * \param modes doubly-linked mode list.
 */
DisplayModePtr
xf86ModesAdd(DisplayModePtr modes, DisplayModePtr new)
{
    if (modes == NULL)
        return new;

    if (new) {
        DisplayModePtr mode = modes;

        while (mode->next)
            mode = mode->next;

        mode->next = new;
        new->prev = mode;
    }

    return modes;
}

/**
 * Build a mode list from a list of config file modes
 */
static DisplayModePtr
xf86GetConfigModes(XF86ConfModeLinePtr conf_mode)
{
    DisplayModePtr head = NULL, prev = NULL, mode;

    for (; conf_mode; conf_mode = (XF86ConfModeLinePtr) conf_mode->list.next) {
        mode = calloc(1, sizeof(DisplayModeRec));
        if (!mode)
            continue;
        mode->name = xstrdup(conf_mode->ml_identifier);
        if (!mode->name) {
            free(mode);
            continue;
        }
        mode->type = 0;
        mode->Clock = conf_mode->ml_clock;
        mode->HDisplay = conf_mode->ml_hdisplay;
        mode->HSyncStart = conf_mode->ml_hsyncstart;
        mode->HSyncEnd = conf_mode->ml_hsyncend;
        mode->HTotal = conf_mode->ml_htotal;
        mode->VDisplay = conf_mode->ml_vdisplay;
        mode->VSyncStart = conf_mode->ml_vsyncstart;
        mode->VSyncEnd = conf_mode->ml_vsyncend;
        mode->VTotal = conf_mode->ml_vtotal;
        mode->Flags = conf_mode->ml_flags;
        mode->HSkew = conf_mode->ml_hskew;
        mode->VScan = conf_mode->ml_vscan;

        mode->prev = prev;
        mode->next = NULL;
        if (prev)
            prev->next = mode;
        else
            head = mode;
        prev = mode;
    }
    return head;
}

/**
 * Build a mode list from a monitor configuration
 */
DisplayModePtr
xf86GetMonitorModes(ScrnInfoPtr pScrn, XF86ConfMonitorPtr conf_monitor)
{
    DisplayModePtr modes = NULL;
    XF86ConfModesLinkPtr modes_link;

    if (!conf_monitor)
        return NULL;

    /*
     * first we collect the mode lines from the UseModes directive
     */
    for (modes_link = conf_monitor->mon_modes_sect_lst;
         modes_link; modes_link = modes_link->list.next) {
        /* If this modes link hasn't been resolved, go look it up now */
        if (!modes_link->ml_modes)
            modes_link->ml_modes = xf86findModes(modes_link->ml_modes_str,
                                                 xf86configptr->conf_modes_lst);
        if (modes_link->ml_modes)
            modes = xf86ModesAdd(modes,
                                 xf86GetConfigModes(modes_link->ml_modes->
                                                    mon_modeline_lst));
    }

    return xf86ModesAdd(modes,
                        xf86GetConfigModes(conf_monitor->mon_modeline_lst));
}

/**
 * Build a mode list containing all of the default modes
 */
DisplayModePtr
xf86GetDefaultModes(void)
{
    DisplayModePtr head = NULL, mode;
    int i;

    for (i = 0; i < xf86NumDefaultModes; i++) {
        const DisplayModeRec *defMode = &xf86DefaultModes[i];

        mode = xf86DuplicateMode(defMode);
        head = xf86ModesAdd(head, mode);
    }
    return head;
}

/*
 * Walk a mode list and prune out duplicates.  Will preserve the preferred
 * mode of an otherwise-duplicate pair.
 *
 * Probably best to call this on lists that are all of a single class
 * (driver, default, user, etc.), otherwise, which mode gets deleted is
 * not especially well defined.
 *
 * Returns the new list.
 */

DisplayModePtr
xf86PruneDuplicateModes(DisplayModePtr modes)
{
    DisplayModePtr m, n, o;

 top:
    for (m = modes; m; m = m->next) {
        for (n = m->next; n; n = o) {
            o = n->next;
            if (xf86ModesEqual(m, n)) {
                if (n->type & M_T_PREFERRED) {
                    xf86DeleteMode(&modes, m);
                    goto top;
                }
                else
                    xf86DeleteMode(&modes, n);
            }
        }
    }

    return modes;
}
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d132 1
d134 1
a134 1
    free(mode->name);
d136 1
a136 1
    XNFasprintf(&mode->name, "%dx%d%s", mode->HDisplay, mode->VDisplay,
d138 1
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d194 15
@


1.7
log
@Update to xserver 1.11.2
@
text
@d45 1
a45 1
xf86ModeHSync(const DisplayModeRec *mode)
d48 1
a48 1
    
d50 1
a50 1
	    hsync = mode->HSync;
d52 1
a52 1
	    hsync = (float)mode->Clock / (float)mode->HTotal;
d61 1
a61 1
xf86ModeVRefresh(const DisplayModeRec *mode)
d66 1
a66 1
	refresh = mode->VRefresh;
d68 7
a74 7
	refresh = mode->Clock * 1000.0 / mode->HTotal / mode->VTotal;
	if (mode->Flags & V_INTERLACE)
	    refresh *= 2.0;
	if (mode->Flags & V_DBLSCAN)
	    refresh /= 2.0;
	if (mode->VScan > 1)
	    refresh /= (float)(mode->VScan);
d80 1
a80 1
xf86ModeWidth (const DisplayModeRec *mode, Rotation rotation)
d85 1
a85 1
	return mode->HDisplay;
d88 1
a88 1
	return mode->VDisplay;
d90 1
a90 1
	return 0;
d95 1
a95 1
xf86ModeHeight (const DisplayModeRec *mode, Rotation rotation)
d100 1
a100 1
	return mode->VDisplay;
d103 1
a103 1
	return mode->HDisplay;
d105 1
a105 1
	return 0;
d117 1
a117 1
	return 0;
d124 1
a124 1
    return (unsigned int)(pixels_per_second * bytes_per_pixel / (1024 * 1024));
d131 1
a131 1
    Bool interlaced = !!(mode->Flags & V_INTERLACE);
d136 1
a136 1
		interlaced ? "i" : "");
d149 1
a149 1
	return;
d151 9
a159 9
    p->CrtcHDisplay             = p->HDisplay;
    p->CrtcHSyncStart           = p->HSyncStart;
    p->CrtcHSyncEnd             = p->HSyncEnd;
    p->CrtcHTotal               = p->HTotal;
    p->CrtcHSkew                = p->HSkew;
    p->CrtcVDisplay             = p->VDisplay;
    p->CrtcVSyncStart           = p->VSyncStart;
    p->CrtcVSyncEnd             = p->VSyncEnd;
    p->CrtcVTotal               = p->VTotal;
d161 9
a169 9
	if (adjustFlags & INTERLACE_HALVE_V) {
	    p->CrtcVDisplay         /= 2;
	    p->CrtcVSyncStart       /= 2;
	    p->CrtcVSyncEnd         /= 2;
	    p->CrtcVTotal           /= 2;
	}
	/* Force interlaced modes to have an odd VTotal */
	/* maybe we should only do this when INTERLACE_HALVE_V is set? */
	p->CrtcVTotal |= 1;
d173 4
a176 4
        p->CrtcVDisplay         *= 2;
        p->CrtcVSyncStart       *= 2;
        p->CrtcVSyncEnd         *= 2;
        p->CrtcVTotal           *= 2;
d179 4
a182 4
        p->CrtcVDisplay         *= p->VScan;
        p->CrtcVSyncStart       *= p->VScan;
        p->CrtcVSyncEnd         *= p->VScan;
        p->CrtcVTotal           *= p->VScan;
d197 1
a197 1
xf86DuplicateMode(const DisplayModeRec *pMode)
d207 1
a207 1
	xf86SetModeDefaultName(pNew);
d209 1
a209 1
	pNew->name = xnfstrdup(pMode->name);
d227 1
a227 1
	DisplayModePtr new;
d229 1
a229 1
	new = xf86DuplicateMode(mode);
d231 11
a241 10
	/* Insert pNew into modeList */
	if (last) {
	    last->next = new;
	    new->prev = last;
	} else {
	    first = new;
	    new->prev = NULL;
	}
	new->next = NULL;
	last = new;
d254 1
a254 1
xf86ModesEqual(const DisplayModeRec *pMode1, const DisplayModeRec *pMode2)
d256 16
a271 17
     if (pMode1->Clock == pMode2->Clock &&
	 pMode1->HDisplay == pMode2->HDisplay &&
	 pMode1->HSyncStart == pMode2->HSyncStart &&
	 pMode1->HSyncEnd == pMode2->HSyncEnd &&
	 pMode1->HTotal == pMode2->HTotal &&
	 pMode1->HSkew == pMode2->HSkew &&
	 pMode1->VDisplay == pMode2->VDisplay &&
	 pMode1->VSyncStart == pMode2->VSyncStart &&
	 pMode1->VSyncEnd == pMode2->VSyncEnd &&
	 pMode1->VTotal == pMode2->VTotal &&
	 pMode1->VScan == pMode2->VScan &&
	 pMode1->Flags == pMode2->Flags)
     {
	return TRUE;
     } else {
	return FALSE;
     }
d275 1
a275 1
add(char **p, char *new)
d284 22
d308 1
a308 1
xf86PrintModeline(int scrnIndex,DisplayModePtr mode)
d313 50
a362 18
    if (mode->HSkew) { 
	snprintf(tmp, 256, "hskew %i", mode->HSkew); 
	add(&flags, tmp);
    }
    if (mode->VScan) { 
	snprintf(tmp, 256, "vscan %i", mode->VScan); 
	add(&flags, tmp);
    }
    if (mode->Flags & V_INTERLACE) add(&flags, "interlace");
    if (mode->Flags & V_CSYNC) add(&flags, "composite");
    if (mode->Flags & V_DBLSCAN) add(&flags, "doublescan");
    if (mode->Flags & V_BCAST) add(&flags, "bcast");
    if (mode->Flags & V_PHSYNC) add(&flags, "+hsync");
    if (mode->Flags & V_NHSYNC) add(&flags, "-hsync");
    if (mode->Flags & V_PVSYNC) add(&flags, "+vsync");
    if (mode->Flags & V_NVSYNC) add(&flags, "-vsync");
    if (mode->Flags & V_PCSYNC) add(&flags, "+csync");
    if (mode->Flags & V_NCSYNC) add(&flags, "-csync");
d364 2
a365 1
    if (mode->Flags & V_CLKDIV2) add(&flags, "vclk/2");
d368 6
a373 6
		   "Modeline \"%s\"x%.01f  %6.2f  %i %i %i %i  %i %i %i %i%s "
		   "(%.01f kHz)\n",
		   mode->name, mode->VRefresh, mode->Clock/1000., mode->HDisplay,
		   mode->HSyncStart, mode->HSyncEnd, mode->HTotal,
		   mode->VDisplay, mode->VSyncStart, mode->VSyncEnd,
		   mode->VTotal, flags, xf86ModeHSync(mode));
d386 1
a386 2
xf86ValidateModesFlags(ScrnInfoPtr pScrn, DisplayModePtr modeList,
			    int flags)
d391 1
a391 1
	return;
d394 4
a397 4
	if (mode->Flags & V_INTERLACE && !(flags & V_INTERLACE))
	    mode->status = MODE_NO_INTERLACE;
	if (mode->Flags & V_DBLSCAN && !(flags & V_DBLSCAN))
	    mode->status = MODE_NO_DBLESCAN;
d408 1
a408 1
			  int maxX, int maxY, int maxPitch)
d413 1
a413 1
	    maxPitch = MAXINT;
d415 1
a415 1
	    maxX = MAXINT;
d417 1
a417 1
	    maxY = MAXINT;
d420 18
a437 18
	if ((xf86ModeWidth(mode, RR_Rotate_0) > maxPitch ||
	     xf86ModeWidth(mode, RR_Rotate_0) > maxX ||
	     xf86ModeHeight(mode, RR_Rotate_0) > maxY) &&
	    (xf86ModeWidth(mode, RR_Rotate_90) > maxPitch ||
	     xf86ModeWidth(mode, RR_Rotate_90) > maxX ||
	     xf86ModeHeight(mode, RR_Rotate_90) > maxY)) {
	    if (xf86ModeWidth(mode, RR_Rotate_0) > maxPitch ||
		xf86ModeWidth(mode, RR_Rotate_90) > maxPitch)
		mode->status = MODE_BAD_WIDTH;

	    if (xf86ModeWidth(mode, RR_Rotate_0) > maxX ||
		xf86ModeWidth(mode, RR_Rotate_90) > maxX)
		mode->status = MODE_VIRTUAL_X;

	    if (xf86ModeHeight(mode, RR_Rotate_0) > maxY ||
		xf86ModeHeight(mode, RR_Rotate_90) > maxY)
		mode->status = MODE_VIRTUAL_Y;
	}
d439 2
a440 2
	if (mode->next == modeList)
	    break;
d451 1
a451 2
xf86ValidateModesSync(ScrnInfoPtr pScrn, DisplayModePtr modeList,
			  MonPtr mon)
d456 2
a457 2
	Bool bad;
	int i;
d459 22
a480 21
	bad = TRUE;
	for (i = 0; i < mon->nHsync; i++) {
	    if (xf86ModeHSync(mode) >= mon->hsync[i].lo * (1-SYNC_TOLERANCE) &&
		xf86ModeHSync(mode) <= mon->hsync[i].hi * (1+SYNC_TOLERANCE))
	    {
		bad = FALSE;
	    }
	}
	if (bad)
	    mode->status = MODE_HSYNC;

	bad = TRUE;
	for (i = 0; i < mon->nVrefresh; i++) {
	    if (xf86ModeVRefresh(mode) >= mon->vrefresh[i].lo * (1-SYNC_TOLERANCE) &&
		xf86ModeVRefresh(mode) <= mon->vrefresh[i].hi * (1+SYNC_TOLERANCE))
	    {
		bad = FALSE;
	    }
	}
	if (bad)
	    mode->status = MODE_VSYNC;
d482 2
a483 2
	if (mode->next == modeList)
	    break;
d497 1
a497 1
			    int *min, int *max, int n_ranges)
d503 11
a513 10
	Bool good = FALSE;
	for (i = 0; i < n_ranges; i++) {
	    if (mode->Clock >= min[i] * (1-SYNC_TOLERANCE) &&
		mode->Clock <= max[i] * (1+SYNC_TOLERANCE)) {
		good = TRUE;
		break;
	    }
	}
	if (!good)
	    mode->status = MODE_CLOCK_RANGE;
d535 1
a535 1
	return;
d538 2
a539 2
	int i;
	Bool good = FALSE;
d541 9
a549 9
	for (i = 0; pScrn->display->modes[i] != NULL; i++) {
	    if (strncmp(pScrn->display->modes[i], mode->name,
			strlen(pScrn->display->modes[i])) == 0) {
		good = TRUE;
		break;
	    }
	}
	if (!good)
	    mode->status = MODE_BAD;
a552 1

d562 1
a562 1
			   unsigned int bandwidth, int depth)
d567 2
a568 2
	if (xf86ModeBandwidth(mode, depth) > bandwidth)
	    mode->status = MODE_BANDWIDTH;
d573 1
a573 1
xf86ModeIsReduced(const DisplayModeRec *mode)
d577 4
a580 4
	((mode->HSyncEnd - mode->HDisplay) == 80) &&
	((mode->HSyncEnd - mode->HSyncStart) == 32) &&
	((mode->VSyncStart - mode->VDisplay) == 3))
	return TRUE;
d593 2
a594 2
	if (xf86ModeIsReduced(modeList))
	    modeList->status = MODE_NO_REDUCED;
d605 2
a606 2
xf86PruneInvalidModes(ScrnInfoPtr pScrn, DisplayModePtr *modeList,
			  Bool verbose)
d611 1
a611 1
	DisplayModePtr next = mode->next, first = *modeList;
d613 18
a630 17
	if (mode->status != MODE_OK) {
	    if (verbose) {
		char *type = "";
		if (mode->type & M_T_BUILTIN)
		    type = "built-in ";
		else if (mode->type & M_T_DEFAULT)
		    type = "default ";
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "Not using %smode \"%s\" (%s)\n", type, mode->name,
			   xf86ModeStatusToString(mode->status));
	    }
	    xf86DeleteMode(modeList, mode);
	}

	if (next == first)
	    break;
	mode = next;
d643 1
a643 1
	return new;
d646 1
a646 1
	DisplayModePtr mode = modes;
d648 2
a649 2
	while (mode->next)
	    mode = mode->next;
d651 2
a652 2
	mode->next = new;
	new->prev = mode;
d662 1
a662 1
xf86GetConfigModes (XF86ConfModeLinePtr conf_mode)
d664 3
a666 4
    DisplayModePtr  head = NULL, prev = NULL, mode;
    
    for (; conf_mode; conf_mode = (XF86ConfModeLinePtr) conf_mode->list.next)
    {
d668 10
a677 11
	if (!mode)
	    continue;
        mode->name       = xstrdup(conf_mode->ml_identifier);
	if (!mode->name)
	{
	    free(mode);
	    continue;
	}
	mode->type       = 0;
        mode->Clock      = conf_mode->ml_clock;
        mode->HDisplay   = conf_mode->ml_hdisplay;
d679 3
a681 3
        mode->HSyncEnd   = conf_mode->ml_hsyncend;
        mode->HTotal     = conf_mode->ml_htotal;
        mode->VDisplay   = conf_mode->ml_vdisplay;
d683 5
a687 5
        mode->VSyncEnd   = conf_mode->ml_vsyncend;
        mode->VTotal     = conf_mode->ml_vtotal;
        mode->Flags      = conf_mode->ml_flags;
        mode->HSkew      = conf_mode->ml_hskew;
        mode->VScan      = conf_mode->ml_vscan;
d690 6
a695 6
	mode->next = NULL;
	if (prev)
	    prev->next = mode;
	else
	    head = mode;
	prev = mode;
d704 1
a704 1
xf86GetMonitorModes (ScrnInfoPtr pScrn, XF86ConfMonitorPtr conf_monitor)
d706 3
a708 3
    DisplayModePtr	    modes = NULL;
    XF86ConfModesLinkPtr    modes_link;
    
d710 1
a710 1
	return NULL;
d715 10
a724 11
    for (modes_link = conf_monitor->mon_modes_sect_lst; 
	 modes_link; 
	 modes_link = modes_link->list.next)
    {
	/* If this modes link hasn't been resolved, go look it up now */
	if (!modes_link->ml_modes)
	    modes_link->ml_modes = xf86findModes (modes_link->ml_modes_str, 
						  xf86configptr->conf_modes_lst);
	if (modes_link->ml_modes)
	    modes = xf86ModesAdd (modes,
				  xf86GetConfigModes (modes_link->ml_modes->mon_modeline_lst));
d727 2
a728 2
    return xf86ModesAdd (modes,
			 xf86GetConfigModes (conf_monitor->mon_modeline_lst));
d735 1
a735 1
xf86GetDefaultModes (void)
d737 5
a741 2
    DisplayModePtr  head = NULL, mode;
    int		    i;
d743 2
a744 6
    for (i = 0; i < xf86NumDefaultModes; i++)
    {
	const DisplayModeRec	*defMode = &xf86DefaultModes[i];
	
	mode = xf86DuplicateMode(defMode);
	head = xf86ModesAdd(head, mode);
d765 1
a765 1
top:
d767 11
a777 11
	for (n = m->next; n; n = o) {
	    o = n->next;
	    if (xf86ModesEqual(m, n)) {
		if (n->type & M_T_PREFERRED) {
		    xf86DeleteMode(&modes, m);
		    goto top;
		}
		else
		    xf86DeleteMode(&modes, n);
	    }
	}
@


1.6
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@a40 8
/*
 * This is the version number where we epoched.  These files get copied
 * into drivers that want to use this setup infrastructure on pre-1.3
 * servers, so when that happens they need to define these symbols
 * themselves.  However, _in_ the server, we basically always define them now.
 */
#if XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(7,2,99,2,0)

d135 2
a136 2
    mode->name = XNFprintf("%dx%d%s", mode->HDisplay, mode->VDisplay,
			   interlaced ? "i" : "");
a320 1
#endif /* XORG_VERSION_CURRENT <= 7.2.99.2 */
a513 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a514 4
#else
	    /* MODE_BANDWIDTH didn't exist in xserver 1.2 */
	    mode->status = MODE_BAD;
#endif
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d367 7
d375 9
a383 2
	if (maxPitch > 0 && mode->HDisplay > maxPitch)
	    mode->status = MODE_BAD_WIDTH;
d385 3
a387 2
	if (maxX > 0 && mode->HDisplay > maxX)
	    mode->status = MODE_VIRTUAL_X;
d389 4
a392 2
	if (maxY > 0 && mode->VDisplay > maxY)
	    mode->status = MODE_VIRTUAL_Y;
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d141 1
a141 1
    xfree(mode->name);
d327 1
a327 1
    xfree(flags);
d610 1
a610 1
        mode = xcalloc(1, sizeof(DisplayModeRec));
d616 1
a616 1
	    xfree (mode);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a50 2
 *
 * Exact copy of xf86Mode.c's.
d52 1
a52 1
_X_EXPORT double
a66 2
 *
 * Exact copy of xf86Mode.c's.
d68 1
a68 1
_X_EXPORT double
d87 1
a87 1
_X_EXPORT int
d102 1
a102 1
_X_EXPORT int
d118 1
a118 1
_X_EXPORT unsigned int
d122 1
a122 1
    int bytes_per_pixel = (depth + 7) / 8;
d136 1
a136 1
_X_EXPORT void
d139 1
a139 2
    if (mode->name != NULL)
	xfree(mode->name);
d141 4
a144 1
    mode->name = XNFprintf("%dx%d", mode->HDisplay, mode->VDisplay);
a151 2
 *
 * Exact copy of xf86Mode.c's.
d153 1
a153 1
_X_EXPORT void
d204 1
a204 1
_X_EXPORT DisplayModePtr
d228 1
a228 1
_X_EXPORT DisplayModePtr
a258 2
 *
 * This isn't in xf86Modes.c, but it might deserve to be there.
d260 1
a260 1
_X_EXPORT Bool
a281 1
/* exact copy of xf86Mode.c */
a291 2
 *
 * Convenient VRefresh printing was added, though, compared to xf86Mode.c
d293 1
a293 1
_X_EXPORT void
d339 1
a339 1
_X_EXPORT void
d345 3
d361 1
a361 1
_X_EXPORT void
d388 1
a388 1
_X_EXPORT void
d433 1
a433 1
_X_EXPORT void
d466 1
a466 1
_X_EXPORT void
d498 1
a498 1
_X_EXPORT void
d532 1
a532 1
_X_EXPORT void
d535 3
a537 11
    DisplayModePtr mode;

    for (mode = modeList; mode != NULL; mode = mode->next) {
	/* gratuitous duplication from pre-randr validation code */
	if ((((mode->HDisplay * 5 / 4) & ~0x07) > mode->HTotal) &&
	    ((mode->HTotal - mode->HDisplay) == 160) &&
	    ((mode->HSyncEnd - mode->HDisplay) == 80) &&
	    ((mode->HSyncEnd - mode->HSyncStart) == 32) &&
	    ((mode->VSyncStart - mode->VDisplay) == 3))
	    mode->status = MODE_NO_REDUCED;
    }
d547 1
a547 1
_X_EXPORT void
d581 1
a581 1
_X_EXPORT DisplayModePtr
d647 1
a647 1
_X_EXPORT DisplayModePtr
d679 2
a680 2
_X_EXPORT DisplayModePtr
xf86GetDefaultModes (Bool interlaceAllowed, Bool doubleScanAllowed)
a688 5
	if (!interlaceAllowed && (defMode->Flags & V_INTERLACE))
	    continue;
	if (!doubleScanAllowed && (defMode->Flags & V_DBLSCAN))
	    continue;

a689 1

d693 34
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d55 1
a55 1
xf86ModeHSync(DisplayModePtr mode)
d73 1
a73 1
xf86ModeVRefresh(DisplayModePtr mode)
d92 1
a92 1
xf86ModeWidth (DisplayModePtr mode, Rotation rotation)
d107 1
a107 1
xf86ModeHeight (DisplayModePtr mode, Rotation rotation)
d209 1
a209 1
xf86DuplicateMode(DisplayModePtr pMode)
d267 1
a267 1
xf86ModesEqual(DisplayModePtr pMode1, DisplayModePtr pMode2)
d512 1
d514 4
d521 12
a540 1
    Bool mode_is_reduced = FALSE;
d696 1
a696 1
    DisplayModePtr  head = NULL, prev = NULL, mode;
d701 1
a701 1
	DisplayModePtr	defMode = &xf86DefaultModes[i];
@


1.1
log
@Initial revision
@
text
@d41 5
a45 3
/**
 * @@file this file contains symbols from xf86Mode.c and friends that are static
 * there but we still want to use.  We need to come up with better API here.
d47 1
a48 1
#if XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(7,2,99,2,0)
d121 18
d217 4
a220 3
    if (pNew->name == NULL) {
	xf86SetModeDefaultName(pMode);
    } else {
a221 1
    }
d343 1
a343 1
 * \param modeList doubly-linked or circular list of modes.
a346 2
 *
 * This is not in xf86Modes.c, but would be part of the proposed new API.
d365 1
a365 3
 * \param modeList doubly-linked or circular list of modes.
 *
 * This is not in xf86Modes.c, but would be part of the proposed new API.
d392 1
a392 3
 * \param modeList doubly-linked or circular list of modes.
 *
 * This is not in xf86Modes.c, but would be part of the proposed new API.
d406 2
a407 2
	    if (xf86ModeHSync(mode) >= mon->hsync[i].lo &&
		xf86ModeHSync(mode) <= mon->hsync[i].hi)
d417 2
a418 2
	    if (xf86ModeVRefresh(mode) >= mon->vrefresh[i].lo &&
		xf86ModeVRefresh(mode) <= mon->vrefresh[i].hi)
d434 1
a434 1
 * \param modeList doubly-linked or circular list of modes.
a437 2
 *
 * This is not in xf86Modes.c, but would be part of the proposed new API.
d449 2
a450 1
	    if (mode->Clock >= min[i] && mode->Clock <= max[i]) {
d470 1
a470 3
 * \param modeList doubly-linked or circular list of modes.
 *
 * This is not in xf86Modes.c, but would be part of the proposed new API.
d498 41
a543 2
 *
 * This is not in xf86Modes.c, but would be part of the proposed new API.
d683 1
a683 1
    for (i = 0; xf86DefaultModes[i].name != NULL; i++)
d692 3
a694 17
	mode = xalloc(sizeof(DisplayModeRec));
	if (!mode)
	    continue;
        memcpy(mode,&xf86DefaultModes[i],sizeof(DisplayModeRec));
        mode->name = xstrdup(xf86DefaultModes[i].name);
        if (!mode->name)
	{
	    xfree (mode);
	    continue;
	}
        mode->prev = prev;
	mode->next = NULL;
	if (prev)
	    prev->next = mode;
	else
	    head = mode;
	prev = mode;
@


1.1.1.1
log
@xserver 1.4
@
text
@@
