head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.6
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.12
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.10
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.8
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.1.0.8
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.6
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.05.29.12.02.38;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	s0SI41sEunLdyFfd;

1.6
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.31.14.09.44;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.01.21;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.01.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright Â© 2006 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#else
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#endif

#include "xf86.h"
#include "xf86DDC.h"
#include "xf86_OSproc.h"
#include "dgaproc.h"
#include "xf86Crtc.h"
#include "xf86Modes.h"
#include "gcstruct.h"
#include "scrnintstr.h"
#include "windowstr.h"

static Bool
xf86_dga_get_modes(ScreenPtr pScreen)
{
    ScrnInfoPtr scrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    DGAModePtr modes, mode;
    DisplayModePtr display_mode;
    int bpp = scrn->bitsPerPixel >> 3;
    int num;

    num = 0;
    display_mode = scrn->modes;
    while (display_mode) {
        num++;
        display_mode = display_mode->next;
        if (display_mode == scrn->modes)
            break;
    }

    if (!num)
        return FALSE;

    modes = xallocarray(num, sizeof(DGAModeRec));
    if (!modes)
        return FALSE;

    num = 0;
    display_mode = scrn->modes;
    while (display_mode) {
        mode = modes + num++;

        mode->mode = display_mode;
        mode->flags = DGA_CONCURRENT_ACCESS;
        if (display_mode->Flags & V_DBLSCAN)
            mode->flags |= DGA_DOUBLESCAN;
        if (display_mode->Flags & V_INTERLACE)
            mode->flags |= DGA_INTERLACED;
        mode->byteOrder = scrn->imageByteOrder;
        mode->depth = scrn->depth;
        mode->bitsPerPixel = scrn->bitsPerPixel;
        mode->red_mask = scrn->mask.red;
        mode->green_mask = scrn->mask.green;
        mode->blue_mask = scrn->mask.blue;
        mode->visualClass = (bpp == 1) ? PseudoColor : TrueColor;
        mode->viewportWidth = display_mode->HDisplay;
        mode->viewportHeight = display_mode->VDisplay;
        mode->xViewportStep = (bpp == 3) ? 2 : 1;
        mode->yViewportStep = 1;
        mode->viewportFlags = DGA_FLIP_RETRACE;
        mode->offset = 0;
        mode->address = 0;
        mode->imageWidth = mode->viewportWidth;
        mode->imageHeight = mode->viewportHeight;
        mode->bytesPerScanline = (mode->imageWidth * scrn->bitsPerPixel) >> 3;
        mode->pixmapWidth = mode->imageWidth;
        mode->pixmapHeight = mode->imageHeight;
        mode->maxViewportX = 0;
        mode->maxViewportY = 0;

        display_mode = display_mode->next;
        if (display_mode == scrn->modes)
            break;
    }
    free(xf86_config->dga_modes);
    xf86_config->dga_nmode = num;
    xf86_config->dga_modes = modes;
    return TRUE;
}

static Bool
xf86_dga_set_mode(ScrnInfoPtr scrn, DGAModePtr display_mode)
{
    ScreenPtr pScreen = scrn->pScreen;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);

    if (!display_mode) {
        if (xf86_config->dga_save_mode) {
            xf86SwitchMode(pScreen, xf86_config->dga_save_mode);
            xf86_config->dga_save_mode = NULL;
        }
    }
    else {
        if (!xf86_config->dga_save_mode) {
            xf86_config->dga_save_mode = scrn->currentMode;
            xf86SwitchMode(pScreen, display_mode->mode);
        }
    }
    return TRUE;
}

static int
xf86_dga_get_viewport(ScrnInfoPtr scrn)
{
    return 0;
}

static void
xf86_dga_set_viewport(ScrnInfoPtr scrn, int x, int y, int flags)
{
    scrn->AdjustFrame(scrn, x, y);
}

static Bool
xf86_dga_open_framebuffer(ScrnInfoPtr scrn,
                          char **name,
                          unsigned char **mem, int *size, int *offset,
                          int *flags)
{
    return FALSE;
}

static void
xf86_dga_close_framebuffer(ScrnInfoPtr scrn)
{
}

static DGAFunctionRec xf86_dga_funcs = {
    xf86_dga_open_framebuffer,
    xf86_dga_close_framebuffer,
    xf86_dga_set_mode,
    xf86_dga_set_viewport,
    xf86_dga_get_viewport,
    NULL,
    NULL,
    NULL,
    NULL
};

Bool
xf86DiDGAReInit(ScreenPtr pScreen)
{
    return TRUE;
}

Bool
_xf86_di_dga_reinit_internal(ScreenPtr pScreen)
{
    ScrnInfoPtr scrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);

    if (!DGAScreenAvailable(pScreen))
        return TRUE;

    if (!xf86_dga_get_modes(pScreen))
        return FALSE;

    return DGAReInitModes(pScreen, xf86_config->dga_modes,
                          xf86_config->dga_nmode);
}

Bool
xf86DiDGAInit(ScreenPtr pScreen, unsigned long dga_address)
{
    return TRUE;
}

Bool
_xf86_di_dga_init_internal(ScreenPtr pScreen)
{
    ScrnInfoPtr scrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);

    xf86_config->dga_flags = 0;
    xf86_config->dga_address = 0;
    xf86_config->dga_width = 0;
    xf86_config->dga_height = 0;
    xf86_config->dga_stride = 0;

    if (!xf86_dga_get_modes(pScreen))
        return FALSE;

    return DGAInit(pScreen, &xf86_dga_funcs, xf86_config->dga_modes,
                   xf86_config->dga_nmode);
}
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d63 1
a63 1
    modes = malloc(num * sizeof(DGAModeRec));
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d44 1
a44 1
    ScrnInfoPtr scrn = xf86Screens[pScreen->myNum];
d140 1
a140 1
    scrn->AdjustFrame(scrn->pScreen->myNum, x, y, flags);
d178 1
a178 1
    ScrnInfoPtr scrn = xf86Screens[pScreen->myNum];
d181 1
a181 1
    if (!DGAAvailable(pScreen->myNum))
d200 1
a200 1
    ScrnInfoPtr scrn = xf86Screens[pScreen->myNum];
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d42 1
a42 1
xf86_dga_get_modes (ScreenPtr pScreen)
d44 6
a49 6
    ScrnInfoPtr		scrn = xf86Screens[pScreen->myNum];
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    DGAModePtr		modes, mode;
    DisplayModePtr	display_mode;
    int			bpp = scrn->bitsPerPixel >> 3;
    int			num;
d53 5
a57 6
    while (display_mode) 
    {
	num++;
	display_mode = display_mode->next;
	if (display_mode == scrn->modes)
	    break;
d59 1
a59 1
    
d61 2
a62 2
	return FALSE;
    
d65 2
a66 2
	return FALSE;
    
d69 34
a102 35
    while (display_mode) 
    {
	mode = modes + num++;

	mode->mode = display_mode;
	mode->flags = DGA_CONCURRENT_ACCESS;
	if (display_mode->Flags & V_DBLSCAN)
	    mode->flags |= DGA_DOUBLESCAN;
	if (display_mode->Flags & V_INTERLACE)
	    mode->flags |= DGA_INTERLACED;
	mode->byteOrder = scrn->imageByteOrder;
	mode->depth = scrn->depth;
	mode->bitsPerPixel = scrn->bitsPerPixel;
	mode->red_mask = scrn->mask.red;
	mode->green_mask = scrn->mask.green;
	mode->blue_mask = scrn->mask.blue;
	mode->visualClass = (bpp == 1) ? PseudoColor : TrueColor;
	mode->viewportWidth = display_mode->HDisplay;
	mode->viewportHeight = display_mode->VDisplay;
	mode->xViewportStep = (bpp == 3) ? 2 : 1;
	mode->yViewportStep = 1;
	mode->viewportFlags = DGA_FLIP_RETRACE;
	mode->offset = 0;
	mode->address = 0;
	mode->imageWidth = mode->viewportWidth;
	mode->imageHeight = mode->viewportHeight;
	mode->bytesPerScanline = (mode->imageWidth * scrn->bitsPerPixel) >> 3;
	mode->pixmapWidth = mode->imageWidth;
	mode->pixmapHeight = mode->imageHeight;
	mode->maxViewportX = 0;
	mode->maxViewportY = 0;

	display_mode = display_mode->next;
	if (display_mode == scrn->modes)
	    break;
d113 2
a114 2
    ScreenPtr		pScreen = scrn->pScreen;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
d116 5
a120 7
    if (!display_mode) 
    {
	if (xf86_config->dga_save_mode)
	{
	    xf86SwitchMode(pScreen, xf86_config->dga_save_mode);
	    xf86_config->dga_save_mode = NULL;
	}
d122 5
a126 7
    else
    {
	if (!xf86_config->dga_save_mode)
	{
	    xf86_config->dga_save_mode = scrn->currentMode;
	    xf86SwitchMode(pScreen, display_mode->mode);
	}
d140 1
a140 1
   scrn->AdjustFrame(scrn->pScreen->myNum, x, y, flags);
d145 3
a147 2
			  char **name,
			  unsigned char **mem, int *size, int *offset, int *flags)
d158 9
a166 9
   xf86_dga_open_framebuffer,
   xf86_dga_close_framebuffer,
   xf86_dga_set_mode,
   xf86_dga_set_viewport,
   xf86_dga_get_viewport,
   NULL,
   NULL,
   NULL,
   NULL
d170 1
a170 1
xf86DiDGAReInit (ScreenPtr pScreen)
d176 1
a176 1
_xf86_di_dga_reinit_internal (ScreenPtr pScreen)
d178 3
a180 3
    ScrnInfoPtr		scrn = xf86Screens[pScreen->myNum];
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    
d182 4
a185 1
	return TRUE;
d187 2
a188 4
    if (!xf86_dga_get_modes (pScreen))
	return FALSE;
    
    return DGAReInitModes (pScreen, xf86_config->dga_modes, xf86_config->dga_nmode);
d192 1
a192 1
xf86DiDGAInit (ScreenPtr pScreen, unsigned long dga_address)
d198 1
a198 1
_xf86_di_dga_init_internal (ScreenPtr pScreen)
d200 2
a201 2
    ScrnInfoPtr		scrn = xf86Screens[pScreen->myNum];
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
d208 6
a213 5
    
    if (!xf86_dga_get_modes (pScreen))
	return FALSE;
    
    return DGAInit(pScreen, &xf86_dga_funcs, xf86_config->dga_modes, xf86_config->dga_nmode);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d64 1
a64 1
    modes = xalloc(num * sizeof(DGAModeRec));
d106 1
a106 2
    if (xf86_config->dga_modes)
	xfree (xf86_config->dga_modes);
@


1.2
log
@Update to server 1.6.5.
@
text
@d175 1
a175 1
_X_EXPORT Bool
d196 1
a196 1
_X_EXPORT Bool
@


1.1
log
@Initial revision
@
text
@d75 1
a75 2
	mode->flags = DGA_CONCURRENT_ACCESS | DGA_PIXMAP_AVAILABLE;
        mode->flags |= DGA_FILL_RECT | DGA_BLIT_RECT;
d93 4
a96 4
	mode->address = (unsigned char *) xf86_config->dga_address;
	mode->bytesPerScanline = xf86_config->dga_stride;
	mode->imageWidth = xf86_config->dga_width;
	mode->imageHeight = xf86_config->dga_height;
d99 2
a100 2
	mode->maxViewportX = mode->imageWidth -	mode->viewportWidth;
	mode->maxViewportY = mode->imageHeight - mode->viewportHeight;
a150 75
xf86_dga_get_drawable_and_gc (ScrnInfoPtr scrn, DrawablePtr *ppDrawable, GCPtr *ppGC)
{
    ScreenPtr		pScreen = scrn->pScreen;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    PixmapPtr		pPixmap;
    GCPtr		pGC;
    
    pPixmap = GetScratchPixmapHeader (pScreen, xf86_config->dga_width, xf86_config->dga_height,
				      scrn->depth, scrn->bitsPerPixel, xf86_config->dga_stride, 
				      (char *) scrn->memPhysBase + scrn->fbOffset);
    if (!pPixmap)
	return FALSE;
    pGC  = GetScratchGC (scrn->depth, pScreen);
    if (!pGC)
    {
	FreeScratchPixmapHeader (pPixmap);
	return FALSE;
    }
    *ppDrawable = &pPixmap->drawable;
    *ppGC = pGC;
    return TRUE;
}

static void
xf86_dga_release_drawable_and_gc (ScrnInfoPtr scrn, DrawablePtr pDrawable, GCPtr pGC)
{
    FreeScratchGC (pGC);
    FreeScratchPixmapHeader ((PixmapPtr) pDrawable);
}

static void
xf86_dga_fill_rect(ScrnInfoPtr scrn, int x, int y, int w, int h, unsigned long color)
{
    GCPtr		pGC;
    DrawablePtr		pDrawable;
    XID			vals[1];
    xRectangle		r;

    if (!xf86_dga_get_drawable_and_gc (scrn, &pDrawable, &pGC))
	return;
    vals[0] = color;
    ChangeGC (pGC, GCForeground, vals);
    ValidateGC (pDrawable, pGC);
    r.x = x;
    r.y = y;
    r.width = w;
    r.height = h;
    pGC->ops->PolyFillRect (pDrawable, pGC, 1, &r);
    xf86_dga_release_drawable_and_gc (scrn, pDrawable, pGC);
}

static void
xf86_dga_sync(ScrnInfoPtr scrn)
{
    ScreenPtr	pScreen = scrn->pScreen;
    WindowPtr	pRoot = WindowTable [pScreen->myNum];
    char	buffer[4];

    pScreen->GetImage (&pRoot->drawable, 0, 0, 1, 1, ZPixmap, ~0L, buffer);
}

static void
xf86_dga_blit_rect(ScrnInfoPtr scrn, int srcx, int srcy, int w, int h, int dstx, int dsty)
{
    DrawablePtr	pDrawable;
    GCPtr	pGC;

    if (!xf86_dga_get_drawable_and_gc (scrn, &pDrawable, &pGC))
	return;
    ValidateGC (pDrawable, pGC);
    pGC->ops->CopyArea (pDrawable, pDrawable, pGC, srcx, srcy, w, h, dstx, dsty);
    xf86_dga_release_drawable_and_gc (scrn, pDrawable, pGC);
}

static Bool
d155 1
a155 8
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    
    *size = xf86_config->dga_stride * xf86_config->dga_height;
    *mem = (unsigned char *) (xf86_config->dga_address);
    *offset = 0;
    *flags = DGA_NEED_ROOT;

    return TRUE;
d169 3
a171 3
   xf86_dga_sync,
   xf86_dga_fill_rect,
   xf86_dga_blit_rect,
d178 6
d187 3
d199 6
d209 4
a212 4
    xf86_config->dga_address = dga_address;
    xf86_config->dga_width = scrn->virtualX;
    xf86_config->dga_height = scrn->virtualY;
    xf86_config->dga_stride = scrn->displayWidth * scrn->bitsPerPixel >> 3;
@


1.1.1.1
log
@xserver 1.4
@
text
@@
