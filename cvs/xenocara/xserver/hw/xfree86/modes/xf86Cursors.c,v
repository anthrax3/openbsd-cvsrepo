head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.6
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.2
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.05.29.12.02.38;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	s0SI41sEunLdyFfd;

1.13
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	cVXoV5PxI8YrEaVA;

1.12
date	2013.09.28.15.36.35;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.12.21.20.10.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.13.19.54.46;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.01.21;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.01.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright © 2007 Keith Packard
 * Copyright © 2010-2011 Aaron Plattner
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#else
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#endif

#include <stddef.h>
#include <string.h>
#include <stdio.h>

#include <X11/Xarch.h>
#include "xf86.h"
#include "xf86DDC.h"
#include "xf86Crtc.h"
#include "xf86Modes.h"
#include "xf86RandR12.h"
#include "xf86CursorPriv.h"
#include "X11/extensions/render.h"
#include "X11/extensions/dpmsconst.h"
#include "X11/Xatom.h"
#include "picturestr.h"
#include "cursorstr.h"
#include "inputstr.h"

/*
 * Returns the rotation being performed by the server.  If the driver indicates
 * that it's handling the screen transform, then this returns RR_Rotate_0.
 */
static Rotation
xf86_crtc_cursor_rotation(xf86CrtcPtr crtc)
{
    if (crtc->driverIsPerformingTransform)
        return RR_Rotate_0;
    return crtc->rotation;
}

/*
 * Given a screen coordinate, rotate back to a cursor source coordinate
 */
static void
xf86_crtc_rotate_coord(Rotation rotation,
                       int width,
                       int height, int x_dst, int y_dst, int *x_src, int *y_src)
{
    int t;

    switch (rotation & 0xf) {
    case RR_Rotate_0:
        break;
    case RR_Rotate_90:
        t = x_dst;
        x_dst = height - y_dst - 1;
        y_dst = t;
        break;
    case RR_Rotate_180:
        x_dst = width - x_dst - 1;
        y_dst = height - y_dst - 1;
        break;
    case RR_Rotate_270:
        t = x_dst;
        x_dst = y_dst;
        y_dst = width - t - 1;
        break;
    }
    if (rotation & RR_Reflect_X)
        x_dst = width - x_dst - 1;
    if (rotation & RR_Reflect_Y)
        y_dst = height - y_dst - 1;
    *x_src = x_dst;
    *y_src = y_dst;
}

/*
 * Given a cursor source  coordinate, rotate to a screen coordinate
 */
static void
xf86_crtc_rotate_coord_back(Rotation rotation,
                            int width,
                            int height,
                            int x_dst, int y_dst, int *x_src, int *y_src)
{
    int t;

    if (rotation & RR_Reflect_X)
        x_dst = width - x_dst - 1;
    if (rotation & RR_Reflect_Y)
        y_dst = height - y_dst - 1;

    switch (rotation & 0xf) {
    case RR_Rotate_0:
        break;
    case RR_Rotate_90:
        t = x_dst;
        x_dst = y_dst;
        y_dst = width - t - 1;
        break;
    case RR_Rotate_180:
        x_dst = width - x_dst - 1;
        y_dst = height - y_dst - 1;
        break;
    case RR_Rotate_270:
        t = x_dst;
        x_dst = height - y_dst - 1;
        y_dst = t;
        break;
    }
    *x_src = x_dst;
    *y_src = y_dst;
}

struct cursor_bit {
    CARD8 *byte;
    char bitpos;
};

/*
 * Convert an x coordinate to a position within the cursor bitmap
 */
static struct cursor_bit
cursor_bitpos(CARD8 *image, xf86CursorInfoPtr cursor_info, int x, int y,
              Bool mask)
{
    const int flags = cursor_info->Flags;
    const Bool interleaved =
        ! !(flags & (HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_1 |
                     HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_8 |
                     HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_16 |
                     HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_32 |
                     HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_64));
    const int width = cursor_info->MaxWidth;
    const int height = cursor_info->MaxHeight;
    const int stride = interleaved ? width / 4 : width / 8;

    struct cursor_bit ret;

    image += y * stride;

    if (flags & HARDWARE_CURSOR_SWAP_SOURCE_AND_MASK)
        mask = !mask;
    if (flags & HARDWARE_CURSOR_NIBBLE_SWAPPED)
        x = (x & ~3) | (3 - (x & 3));
    if (((flags & HARDWARE_CURSOR_BIT_ORDER_MSBFIRST) == 0) ==
        (X_BYTE_ORDER == X_BIG_ENDIAN))
        x = (x & ~7) | (7 - (x & 7));
    if (flags & HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_1)
        x = (x << 1) + mask;
    else if (flags & HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_8)
        x = ((x & ~7) << 1) | (mask << 3) | (x & 7);
    else if (flags & HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_16)
        x = ((x & ~15) << 1) | (mask << 4) | (x & 15);
    else if (flags & HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_32)
        x = ((x & ~31) << 1) | (mask << 5) | (x & 31);
    else if (flags & HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_64)
        x = ((x & ~63) << 1) | (mask << 6) | (x & 63);
    else if (mask)
        image += stride * height;

    ret.byte = image + (x / 8);
    ret.bitpos = x & 7;

    return ret;
}

/*
 * Fetch one bit from a cursor bitmap
 */
static CARD8
get_bit(CARD8 *image, xf86CursorInfoPtr cursor_info, int x, int y, Bool mask)
{
    struct cursor_bit bit = cursor_bitpos(image, cursor_info, x, y, mask);

    return (*bit.byte >> bit.bitpos) & 1;
}

/*
 * Set one bit in a cursor bitmap
 */
static void
set_bit(CARD8 *image, xf86CursorInfoPtr cursor_info, int x, int y, Bool mask)
{
    struct cursor_bit bit = cursor_bitpos(image, cursor_info, x, y, mask);

    *bit.byte |= 1 << bit.bitpos;
}

/*
 * Wrappers to deal with API compatibility with drivers that don't expose
 * load_cursor_*_check
 */
static inline Bool
xf86_driver_has_load_cursor_image(xf86CrtcPtr crtc)
{
    return crtc->funcs->load_cursor_image_check || crtc->funcs->load_cursor_image;
}

static inline Bool
xf86_driver_has_load_cursor_argb(xf86CrtcPtr crtc)
{
    return crtc->funcs->load_cursor_argb_check || crtc->funcs->load_cursor_argb;
}

static inline Bool
xf86_driver_load_cursor_image(xf86CrtcPtr crtc, CARD8 *cursor_image)
{
    if (crtc->funcs->load_cursor_image_check)
        return crtc->funcs->load_cursor_image_check(crtc, cursor_image);
    crtc->funcs->load_cursor_image(crtc, cursor_image);
    return TRUE;
}

static inline Bool
xf86_driver_load_cursor_argb(xf86CrtcPtr crtc, CARD32 *cursor_argb)
{
    if (crtc->funcs->load_cursor_argb_check)
        return crtc->funcs->load_cursor_argb_check(crtc, cursor_argb);
    crtc->funcs->load_cursor_argb(crtc, cursor_argb);
    return TRUE;
}

/*
 * Load a two color cursor into a driver that supports only ARGB cursors
 */
static Bool
xf86_crtc_convert_cursor_to_argb(xf86CrtcPtr crtc, unsigned char *src)
{
    ScrnInfoPtr scrn = crtc->scrn;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CursorInfoPtr cursor_info = xf86_config->cursor_info;
    CARD32 *cursor_image = (CARD32 *) xf86_config->cursor_image;
    int x, y;
    int xin, yin;
    int flags = cursor_info->Flags;
    CARD32 bits;
    const Rotation rotation = xf86_crtc_cursor_rotation(crtc);

    crtc->cursor_argb = FALSE;

    for (y = 0; y < cursor_info->MaxHeight; y++)
        for (x = 0; x < cursor_info->MaxWidth; x++) {
            xf86_crtc_rotate_coord(rotation,
                                   cursor_info->MaxWidth,
                                   cursor_info->MaxHeight, x, y, &xin, &yin);
            if (get_bit(src, cursor_info, xin, yin, TRUE) ==
                ((flags & HARDWARE_CURSOR_INVERT_MASK) == 0)) {
                if (get_bit(src, cursor_info, xin, yin, FALSE))
                    bits = xf86_config->cursor_fg;
                else
                    bits = xf86_config->cursor_bg;
            }
            else
                bits = 0;
            cursor_image[y * cursor_info->MaxWidth + x] = bits;
        }
    return xf86_driver_load_cursor_argb(crtc, cursor_image);
}

/*
 * Set the colors for a two-color cursor (ignore for ARGB cursors)
 */
static void
xf86_set_cursor_colors(ScrnInfoPtr scrn, int bg, int fg)
{
    ScreenPtr screen = scrn->pScreen;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    CursorPtr cursor = xf86_config->cursor;
    int c;
    CARD8 *bits = cursor ?
        dixLookupScreenPrivate(&cursor->devPrivates, CursorScreenKey, screen)
        : NULL;

    /* Save ARGB versions of these colors */
    xf86_config->cursor_fg = (CARD32) fg | 0xff000000;
    xf86_config->cursor_bg = (CARD32) bg | 0xff000000;

    for (c = 0; c < xf86_config->num_crtc; c++) {
        xf86CrtcPtr crtc = xf86_config->crtc[c];

        if (crtc->enabled && !crtc->cursor_argb) {
            if (xf86_driver_has_load_cursor_image(crtc))
                crtc->funcs->set_cursor_colors(crtc, bg, fg);
            else if (bits)
                xf86_crtc_convert_cursor_to_argb(crtc, bits);
        }
    }
}

static void
xf86_crtc_hide_cursor(xf86CrtcPtr crtc)
{
    if (crtc->cursor_shown) {
        crtc->funcs->hide_cursor(crtc);
        crtc->cursor_shown = FALSE;
    }
}

void
xf86_hide_cursors(ScrnInfoPtr scrn)
{
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int c;

    xf86_config->cursor_on = FALSE;
    for (c = 0; c < xf86_config->num_crtc; c++) {
        xf86CrtcPtr crtc = xf86_config->crtc[c];

        if (crtc->enabled)
            xf86_crtc_hide_cursor(crtc);
    }
}

static void
xf86_crtc_show_cursor(xf86CrtcPtr crtc)
{
    if (!crtc->cursor_shown && crtc->cursor_in_range) {
        crtc->funcs->show_cursor(crtc);
        crtc->cursor_shown = TRUE;
    }
}

void
xf86_show_cursors(ScrnInfoPtr scrn)
{
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int c;

    xf86_config->cursor_on = TRUE;
    for (c = 0; c < xf86_config->num_crtc; c++) {
        xf86CrtcPtr crtc = xf86_config->crtc[c];

        if (crtc->enabled)
            xf86_crtc_show_cursor(crtc);
    }
}

void
xf86CrtcTransformCursorPos(xf86CrtcPtr crtc, int *x, int *y)
{
    ScrnInfoPtr scrn = crtc->scrn;
    ScreenPtr screen = scrn->pScreen;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CursorInfoPtr cursor_info = xf86_config->cursor_info;
    xf86CursorScreenPtr ScreenPriv =
        (xf86CursorScreenPtr) dixLookupPrivate(&screen->devPrivates,
                                               xf86CursorScreenKey);
    struct pict_f_vector v;
    int dx, dy;

    v.v[0] = (*x + ScreenPriv->HotX) + 0.5;
    v.v[1] = (*y + ScreenPriv->HotY) + 0.5;
    v.v[2] = 1;
    pixman_f_transform_point(&crtc->f_framebuffer_to_crtc, &v);
    /* cursor will have 0.5 added to it already so floor is sufficent */
    *x = floor(v.v[0]);
    *y = floor(v.v[1]);
    /*
     * Transform position of cursor upper left corner
     */
    xf86_crtc_rotate_coord_back(crtc->rotation, cursor_info->MaxWidth,
                                cursor_info->MaxHeight, ScreenPriv->HotX,
                                ScreenPriv->HotY, &dx, &dy);
    *x -= dx;
    *y -= dy;
}

static void
xf86_crtc_set_cursor_position(xf86CrtcPtr crtc, int x, int y)
{
    ScrnInfoPtr scrn = crtc->scrn;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CursorInfoPtr cursor_info = xf86_config->cursor_info;
    DisplayModePtr mode = &crtc->mode;
    Bool in_range;

    /*
     * Transform position of cursor on screen
     */
    if (crtc->transform_in_use && !crtc->driverIsPerformingTransform)
        xf86CrtcTransformCursorPos(crtc, &x, &y);
    else {
        x -= crtc->x;
        y -= crtc->y;
    }

    /*
     * Disable the cursor when it is outside the viewport
     */
    in_range = TRUE;
    if (x >= mode->HDisplay || y >= mode->VDisplay ||
        x <= -cursor_info->MaxWidth || y <= -cursor_info->MaxHeight) {
        in_range = FALSE;
        x = 0;
        y = 0;
    }

    crtc->cursor_in_range = in_range;

    if (in_range) {
        crtc->funcs->set_cursor_position(crtc, x, y);
        xf86_crtc_show_cursor(crtc);
    }
    else
        xf86_crtc_hide_cursor(crtc);
}

static void
xf86_set_cursor_position(ScrnInfoPtr scrn, int x, int y)
{
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int c;

    /* undo what xf86HWCurs did to the coordinates */
    x += scrn->frameX0;
    y += scrn->frameY0;
    for (c = 0; c < xf86_config->num_crtc; c++) {
        xf86CrtcPtr crtc = xf86_config->crtc[c];

        if (crtc->enabled)
            xf86_crtc_set_cursor_position(crtc, x, y);
    }
}

/*
 * Load a two-color cursor into a crtc, performing rotation as needed
 */
static Bool
xf86_crtc_load_cursor_image(xf86CrtcPtr crtc, CARD8 *src)
{
    ScrnInfoPtr scrn = crtc->scrn;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CursorInfoPtr cursor_info = xf86_config->cursor_info;
    CARD8 *cursor_image;
    const Rotation rotation = xf86_crtc_cursor_rotation(crtc);

    crtc->cursor_argb = FALSE;

    if (rotation == RR_Rotate_0)
        cursor_image = src;
    else {
        int x, y;
        int xin, yin;
        int stride = cursor_info->MaxWidth >> 2;

        cursor_image = xf86_config->cursor_image;
        memset(cursor_image, 0, cursor_info->MaxHeight * stride);

        for (y = 0; y < cursor_info->MaxHeight; y++)
            for (x = 0; x < cursor_info->MaxWidth; x++) {
                xf86_crtc_rotate_coord(rotation,
                                       cursor_info->MaxWidth,
                                       cursor_info->MaxHeight,
                                       x, y, &xin, &yin);
                if (get_bit(src, cursor_info, xin, yin, FALSE))
                    set_bit(cursor_image, cursor_info, x, y, FALSE);
                if (get_bit(src, cursor_info, xin, yin, TRUE))
                    set_bit(cursor_image, cursor_info, x, y, TRUE);
            }
    }
    return xf86_driver_load_cursor_image(crtc, cursor_image);
}

/*
 * Load a cursor image into all active CRTCs
 */
static Bool
xf86_load_cursor_image(ScrnInfoPtr scrn, unsigned char *src)
{
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int c;

    for (c = 0; c < xf86_config->num_crtc; c++) {
        xf86CrtcPtr crtc = xf86_config->crtc[c];

        if (crtc->enabled) {
            if (xf86_driver_has_load_cursor_image(crtc)) {
                if (!xf86_crtc_load_cursor_image(crtc, src))
                    return FALSE;
            } else if (xf86_driver_has_load_cursor_argb(crtc)) {
                if (!xf86_crtc_convert_cursor_to_argb(crtc, src))
                    return FALSE;
            } else
                return FALSE;
        }
    }
    return TRUE;
}

static Bool
xf86_use_hw_cursor(ScreenPtr screen, CursorPtr cursor)
{
    ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CursorInfoPtr cursor_info = xf86_config->cursor_info;
    int c;

    cursor = RefCursor(cursor);
    if (xf86_config->cursor)
        FreeCursor(xf86_config->cursor, None);
    xf86_config->cursor = cursor;

    if (cursor->bits->width > cursor_info->MaxWidth ||
        cursor->bits->height > cursor_info->MaxHeight)
        return FALSE;

    for (c = 0; c < xf86_config->num_crtc; c++) {
        xf86CrtcPtr crtc = xf86_config->crtc[c];

        if (!crtc->enabled)
            continue;

        if (crtc->transformPresent)
            return FALSE;
    }

    return TRUE;
}

static Bool
xf86_use_hw_cursor_argb(ScreenPtr screen, CursorPtr cursor)
{
    ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CursorInfoPtr cursor_info = xf86_config->cursor_info;

    if (!xf86_use_hw_cursor(screen, cursor))
        return FALSE;

    /* Make sure ARGB support is available */
    if ((cursor_info->Flags & HARDWARE_CURSOR_ARGB) == 0)
        return FALSE;

    return TRUE;
}

static Bool
xf86_crtc_load_cursor_argb(xf86CrtcPtr crtc, CursorPtr cursor)
{
    ScrnInfoPtr scrn = crtc->scrn;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CursorInfoPtr cursor_info = xf86_config->cursor_info;
    CARD32 *cursor_image = (CARD32 *) xf86_config->cursor_image;
    CARD32 *cursor_source = (CARD32 *) cursor->bits->argb;
    int x, y;
    int xin, yin;
    CARD32 bits;
    int source_width = cursor->bits->width;
    int source_height = cursor->bits->height;
    int image_width = cursor_info->MaxWidth;
    int image_height = cursor_info->MaxHeight;
    const Rotation rotation = xf86_crtc_cursor_rotation(crtc);

    for (y = 0; y < image_height; y++)
        for (x = 0; x < image_width; x++) {
            xf86_crtc_rotate_coord(rotation, image_width, image_height, x, y,
                                   &xin, &yin);
            if (xin < source_width && yin < source_height)
                bits = cursor_source[yin * source_width + xin];
            else
                bits = 0;
            cursor_image[y * image_width + x] = bits;
        }

    return xf86_driver_load_cursor_argb(crtc, cursor_image);
}

static Bool
xf86_load_cursor_argb(ScrnInfoPtr scrn, CursorPtr cursor)
{
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int c;

    for (c = 0; c < xf86_config->num_crtc; c++) {
        xf86CrtcPtr crtc = xf86_config->crtc[c];

        if (crtc->enabled)
            if (!xf86_crtc_load_cursor_argb(crtc, cursor))
                return FALSE;
    }
    return TRUE;
}

Bool
xf86_cursors_init(ScreenPtr screen, int max_width, int max_height, int flags)
{
    ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CursorInfoPtr cursor_info;

    cursor_info = xf86CreateCursorInfoRec();
    if (!cursor_info)
        return FALSE;

    xf86_config->cursor_image = malloc(max_width * max_height * 4);

    if (!xf86_config->cursor_image) {
        xf86DestroyCursorInfoRec(cursor_info);
        return FALSE;
    }

    xf86_config->cursor_info = cursor_info;

    cursor_info->MaxWidth = max_width;
    cursor_info->MaxHeight = max_height;
    cursor_info->Flags = flags;

    cursor_info->SetCursorColors = xf86_set_cursor_colors;
    cursor_info->SetCursorPosition = xf86_set_cursor_position;
    cursor_info->LoadCursorImageCheck = xf86_load_cursor_image;
    cursor_info->HideCursor = xf86_hide_cursors;
    cursor_info->ShowCursor = xf86_show_cursors;
    cursor_info->UseHWCursor = xf86_use_hw_cursor;
    if (flags & HARDWARE_CURSOR_ARGB) {
        cursor_info->UseHWCursorARGB = xf86_use_hw_cursor_argb;
        cursor_info->LoadCursorARGBCheck = xf86_load_cursor_argb;
    }

    xf86_config->cursor = NULL;
    xf86_hide_cursors(scrn);

    return xf86InitCursor(screen, cursor_info);
}

/**
 * Called when anything on the screen is reconfigured.
 *
 * Reloads cursor images as needed, then adjusts cursor positions
 * @@note We assume that all hardware cursors to be loaded have already been
 *       found to be usable by the hardware.
 */

void
xf86_reload_cursors(ScreenPtr screen)
{
    ScrnInfoPtr scrn;
    xf86CrtcConfigPtr xf86_config;
    xf86CursorInfoPtr cursor_info;
    CursorPtr cursor;
    int x, y;
    xf86CursorScreenPtr cursor_screen_priv;

    /* initial mode setting will not have set a screen yet.
       May be called before the devices are initialised.
     */
    if (!screen || !inputInfo.pointer)
        return;
    cursor_screen_priv = dixLookupPrivate(&screen->devPrivates,
                                          xf86CursorScreenKey);
    /* return if HW cursor is inactive, to avoid displaying two cursors */
    if (!cursor_screen_priv || !cursor_screen_priv->isUp)
        return;

    scrn = xf86ScreenToScrn(screen);
    xf86_config = XF86_CRTC_CONFIG_PTR(scrn);

    /* make sure the cursor code has been initialized */
    cursor_info = xf86_config->cursor_info;
    if (!cursor_info)
        return;

    cursor = xf86_config->cursor;
    GetSpritePosition(inputInfo.pointer, &x, &y);
    if (!(cursor_info->Flags & HARDWARE_CURSOR_UPDATE_UNHIDDEN))
        (*cursor_info->HideCursor) (scrn);

    if (cursor) {
        void *src =
            dixLookupScreenPrivate(&cursor->devPrivates, CursorScreenKey,
                                   screen);
        if (cursor->bits->argb && xf86DriverHasLoadCursorARGB(cursor_info))
            xf86DriverLoadCursorARGB(cursor_info, cursor);
        else if (src)
            xf86DriverLoadCursorImage(cursor_info, src);

        x += scrn->frameX0 + cursor_screen_priv->HotX;
        y += scrn->frameY0 + cursor_screen_priv->HotY;
        (*cursor_info->SetCursorPosition) (scrn, x, y);
    }
}

/**
 * Clean up CRTC-based cursor code
 */
void
xf86_cursors_fini(ScreenPtr screen)
{
    ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);

    if (xf86_config->cursor_info) {
        xf86DestroyCursorInfoRec(xf86_config->cursor_info);
        xf86_config->cursor_info = NULL;
    }
    free(xf86_config->cursor_image);
    xf86_config->cursor_image = NULL;
    if (xf86_config->cursor) {
        FreeCursor(xf86_config->cursor, None);
        xf86_config->cursor = NULL;
    }
}
@


1.13
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a260 1
#ifdef ARGB_CURSOR
a261 1
#endif
a458 1
#ifdef ARGB_CURSOR
a459 1
#endif
d518 1
d529 10
d549 2
a550 4
    cursor = RefCursor(cursor);
    if (xf86_config->cursor)
        FreeCursor(xf86_config->cursor, None);
    xf86_config->cursor = cursor;
a555 4
    if (cursor->bits->width > cursor_info->MaxWidth ||
        cursor->bits->height > cursor_info->MaxHeight)
        return FALSE;

a635 1
#ifdef ARGB_CURSOR
a639 1
#endif
a692 1
#ifdef ARGB_CURSOR
a695 1
#endif
@


1.12
log
@Update to xserver 1.14.3
@
text
@d212 34
d248 1
a248 1
static void
d281 1
a281 1
    crtc->funcs->load_cursor_argb(crtc, cursor_image);
d306 1
a306 1
            if (crtc->funcs->load_cursor_image)
d452 1
a452 1
static void
d487 1
a487 1
    crtc->funcs->load_cursor_image(crtc, cursor_image);
d493 1
a493 1
static void
d503 8
a510 4
            if (crtc->funcs->load_cursor_image)
                xf86_crtc_load_cursor_image(crtc, src);
            else if (crtc->funcs->load_cursor_argb)
                xf86_crtc_convert_cursor_to_argb(crtc, src);
d513 1
d558 1
a558 1
static void
d586 1
a586 1
    crtc->funcs->load_cursor_argb(crtc, cursor_image);
d589 1
a589 1
static void
d599 2
a600 1
            xf86_crtc_load_cursor_argb(crtc, cursor);
d602 1
d631 1
a631 1
    cursor_info->LoadCursorImage = xf86_load_cursor_image;
d638 1
a638 1
        cursor_info->LoadCursorARGB = xf86_load_cursor_argb;
d652 2
d695 2
a696 2
        if (cursor->bits->argb && cursor_info->LoadCursorARGB)
            (*cursor_info->LoadCursorARGB) (scrn, cursor);
d699 1
a699 1
            (*cursor_info->LoadCursorImage) (scrn, src);
@


1.11
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d484 1
a484 1
    ++cursor->refcnt;
d503 1
a503 1
    ++cursor->refcnt;
@


1.10
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d480 1
a480 1
    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d499 1
a499 1
    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d567 1
a567 1
    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d634 1
a634 1
    scrn = xf86Screens[screen->myNum];
d670 1
a670 1
    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
@


1.9
log
@Update to xserver 1.11.2
@
text
@d3 1
a3 1
 * Copyright © 2010 Aaron Plattner
d36 1
d51 12
d66 3
a68 7
xf86_crtc_rotate_coord (Rotation    rotation,
			int	    width,
			int	    height,
			int	    x_dst,
			int	    y_dst,
			int	    *x_src,
			int	    *y_src)
d71 1
a71 1
    
d74 1
a74 1
	break;
d76 4
a79 4
	t = x_dst;
	x_dst = height - y_dst - 1;
	y_dst = t;
	break;
d81 3
a83 3
	x_dst = width - x_dst - 1;
	y_dst = height - y_dst - 1;
	break;
d85 4
a88 4
	t = x_dst;
	x_dst = y_dst;
	y_dst = width - t - 1;
	break;
d91 1
a91 1
	x_dst = width - x_dst - 1;
d93 1
a93 1
	y_dst = height - y_dst - 1;
d102 4
a105 7
xf86_crtc_rotate_coord_back (Rotation    rotation,
			     int	    width,
			     int	    height,
			     int	    x_dst,
			     int	    y_dst,
			     int	    *x_src,
			     int	    *y_src)
d108 1
a108 1
    
d110 1
a110 1
	x_dst = width - x_dst - 1;
d112 1
a112 1
	y_dst = height - y_dst - 1;
d116 1
a116 1
	break;
d118 4
a121 4
	t = x_dst;
	x_dst = y_dst;
	y_dst = width - t - 1;
	break;
d123 3
a125 3
	x_dst = width - x_dst - 1;
	y_dst = height - y_dst - 1;
	break;
d127 4
a130 4
	t = x_dst;
	x_dst = height - y_dst - 1;
	y_dst = t;
	break;
d145 2
a146 2
cursor_bitpos (CARD8 *image, xf86CursorInfoPtr cursor_info, int x, int y,
	       Bool mask)
d150 5
a154 5
	!!(flags & (HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_1 |
		    HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_8 |
		    HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_16 |
		    HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_32 |
		    HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_64));
d164 1
a164 1
	mask = !mask;
d166 1
a166 1
	x = (x & ~3) | (3 - (x & 3));
d168 2
a169 2
	(X_BYTE_ORDER == X_BIG_ENDIAN))
	x = (x & ~7) | (7 - (x & 7));
d171 1
a171 1
	x = (x << 1) + mask;
d173 1
a173 1
	x = ((x & ~7) << 1) | (mask << 3) | (x & 7);
d175 1
a175 1
	x = ((x & ~15) << 1) | (mask << 4) | (x & 15);
d177 1
a177 1
	x = ((x & ~31) << 1) | (mask << 5) | (x & 31);
d179 1
a179 1
	x = ((x & ~63) << 1) | (mask << 6) | (x & 63);
d181 1
a181 1
	image += stride * height;
d193 1
a193 1
get_bit (CARD8 *image, xf86CursorInfoPtr cursor_info, int x, int y, Bool mask)
d196 1
d204 1
a204 1
set_bit (CARD8 *image, xf86CursorInfoPtr cursor_info, int x, int y, Bool mask)
d207 1
d210 1
a210 1
    
d215 1
a215 1
xf86_crtc_convert_cursor_to_argb (xf86CrtcPtr crtc, unsigned char *src)
d217 9
a225 8
    ScrnInfoPtr		scrn = crtc->scrn;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CursorInfoPtr	cursor_info = xf86_config->cursor_info;
    CARD32		*cursor_image = (CARD32 *) xf86_config->cursor_image;
    int			x, y;
    int			xin, yin;
    int			flags = cursor_info->Flags;
    CARD32		bits;
d232 16
a247 19
	for (x = 0; x < cursor_info->MaxWidth; x++) 
	{
	    xf86_crtc_rotate_coord (crtc->rotation,
				    cursor_info->MaxWidth,
				    cursor_info->MaxHeight,
				    x, y, &xin, &yin);
	    if (get_bit (src, cursor_info, xin, yin, TRUE) ==
		((flags & HARDWARE_CURSOR_INVERT_MASK) == 0))
	    {
		if (get_bit (src, cursor_info, xin, yin, FALSE))
		    bits = xf86_config->cursor_fg;
		else
		    bits = xf86_config->cursor_bg;
	    }
	    else
		bits = 0;
	    cursor_image[y * cursor_info->MaxWidth + x] = bits;
	}
    crtc->funcs->load_cursor_argb (crtc, cursor_image);
d254 1
a254 1
xf86_set_cursor_colors (ScrnInfoPtr scrn, int bg, int fg)
d256 7
a262 7
    ScreenPtr		screen = scrn->pScreen;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    CursorPtr		cursor = xf86_config->cursor;
    int			c;
    CARD8		*bits = cursor ?
        dixLookupPrivate(&cursor->devPrivates, CursorScreenKey(screen))
      : NULL;
a266 4
    
    for (c = 0; c < xf86_config->num_crtc; c++)
    {
	xf86CrtcPtr crtc = xf86_config->crtc[c];
d268 9
a276 7
	if (crtc->enabled && !crtc->cursor_argb)
	{
	    if (crtc->funcs->load_cursor_image)
		crtc->funcs->set_cursor_colors (crtc, bg, fg);
	    else if (bits)
		xf86_crtc_convert_cursor_to_argb (crtc, bits);
	}
d281 1
a281 1
xf86_crtc_hide_cursor (xf86CrtcPtr crtc)
d283 3
a285 4
    if (crtc->cursor_shown)
    {
	crtc->funcs->hide_cursor (crtc);
	crtc->cursor_shown = FALSE;
d290 1
a290 1
xf86_hide_cursors (ScrnInfoPtr scrn)
d292 2
a293 2
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int			c;
d296 2
a297 3
    for (c = 0; c < xf86_config->num_crtc; c++)
    {
	xf86CrtcPtr crtc = xf86_config->crtc[c];
d299 2
a300 2
	if (crtc->enabled)
	    xf86_crtc_hide_cursor (crtc);
d303 1
a303 1
    
d305 1
a305 1
xf86_crtc_show_cursor (xf86CrtcPtr crtc)
d307 3
a309 4
    if (!crtc->cursor_shown && crtc->cursor_in_range)
    {
	crtc->funcs->show_cursor (crtc);
	crtc->cursor_shown = TRUE;
d314 1
a314 1
xf86_show_cursors (ScrnInfoPtr scrn)
d316 2
a317 2
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int			c;
d320 2
a321 3
    for (c = 0; c < xf86_config->num_crtc; c++)
    {
	xf86CrtcPtr crtc = xf86_config->crtc[c];
d323 2
a324 2
	if (crtc->enabled)
	    xf86_crtc_show_cursor (crtc);
d327 31
a357 1
    
d359 1
a359 1
xf86_crtc_set_cursor_position (xf86CrtcPtr crtc, int x, int y)
d361 5
a365 6
    ScrnInfoPtr		scrn = crtc->scrn;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CursorInfoPtr	cursor_info = xf86_config->cursor_info;
    DisplayModePtr	mode = &crtc->mode;
    Bool		in_range;
    int			dx, dy;
d370 5
a374 29
    if (crtc->transform_in_use)
    {
	ScreenPtr	screen = scrn->pScreen;
	xf86CursorScreenPtr ScreenPriv =
	    (xf86CursorScreenPtr)dixLookupPrivate(&screen->devPrivates,
						  xf86CursorScreenKey);
	struct pict_f_vector   v;

	v.v[0] = (x + ScreenPriv->HotX) + 0.5;
	v.v[1] = (y + ScreenPriv->HotY) + 0.5;
	v.v[2] = 1;
	pixman_f_transform_point (&crtc->f_framebuffer_to_crtc, &v);
	/* cursor will have 0.5 added to it already so floor is sufficent */
	x = floor (v.v[0]);
	y = floor (v.v[1]);
	/*
	 * Transform position of cursor upper left corner
	 */
	xf86_crtc_rotate_coord_back (crtc->rotation,
				     cursor_info->MaxWidth,
				     cursor_info->MaxHeight,
				     ScreenPriv->HotX, ScreenPriv->HotY, &dx, &dy);
	x -= dx;
	y -= dy;
   }
    else
    {
	x -= crtc->x;
	y -= crtc->y;
d382 4
a385 5
	x <= -cursor_info->MaxWidth || y <= -cursor_info->MaxHeight) 
    {
	in_range = FALSE;
	x = 0;
	y = 0;
d389 4
a392 5
    
    if (in_range)
    {
	crtc->funcs->set_cursor_position (crtc, x, y);
	xf86_crtc_show_cursor (crtc);
d395 1
a395 1
	xf86_crtc_hide_cursor (crtc);
d399 1
a399 1
xf86_set_cursor_position (ScrnInfoPtr scrn, int x, int y)
d401 2
a402 2
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int			c;
d407 2
a408 3
    for (c = 0; c < xf86_config->num_crtc; c++)
    {
	xf86CrtcPtr crtc = xf86_config->crtc[c];
d410 2
a411 2
	if (crtc->enabled)
	    xf86_crtc_set_cursor_position (crtc, x, y);
d414 1
a414 1
    
d419 1
a419 1
xf86_crtc_load_cursor_image (xf86CrtcPtr crtc, CARD8 *src)
d421 5
a425 4
    ScrnInfoPtr		scrn = crtc->scrn;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CursorInfoPtr	cursor_info = xf86_config->cursor_info;
    CARD8		*cursor_image;
d431 3
a433 4
    if (crtc->rotation == RR_Rotate_0)
	cursor_image = src;
    else
    {
d435 6
a440 6
    	int xin, yin;
	int stride = cursor_info->MaxWidth >> 2;
	
	cursor_image = xf86_config->cursor_image;
	memset(cursor_image, 0, cursor_info->MaxHeight * stride);
	
d442 10
a451 11
	    for (x = 0; x < cursor_info->MaxWidth; x++) 
	    {
		xf86_crtc_rotate_coord (crtc->rotation,
					cursor_info->MaxWidth,
					cursor_info->MaxHeight,
					x, y, &xin, &yin);
		if (get_bit(src, cursor_info, xin, yin, FALSE))
		    set_bit(cursor_image, cursor_info, x, y, FALSE);
		if (get_bit(src, cursor_info, xin, yin, TRUE))
		    set_bit(cursor_image, cursor_info, x, y, TRUE);
	    }
d453 1
a453 1
    crtc->funcs->load_cursor_image (crtc, cursor_image);
d455 1
a455 1
    
d460 1
a460 1
xf86_load_cursor_image (ScrnInfoPtr scrn, unsigned char *src)
d462 5
a466 2
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int			c;
d468 6
a473 11
    for (c = 0; c < xf86_config->num_crtc; c++)
    {
	xf86CrtcPtr crtc = xf86_config->crtc[c];

	if (crtc->enabled)
	{
	    if (crtc->funcs->load_cursor_image)
		xf86_crtc_load_cursor_image (crtc, src);
	    else if (crtc->funcs->load_cursor_argb)
		xf86_crtc_convert_cursor_to_argb (crtc, src);
	}
d478 1
a478 1
xf86_use_hw_cursor (ScreenPtr screen, CursorPtr cursor)
d480 3
a482 3
    ScrnInfoPtr		scrn = xf86Screens[screen->myNum];
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CursorInfoPtr	cursor_info = xf86_config->cursor_info;
d486 1
a486 1
	FreeCursor (xf86_config->cursor, None);
d490 2
a491 2
	cursor->bits->height> cursor_info->MaxHeight)
	return FALSE;
d497 1
a497 1
xf86_use_hw_cursor_argb (ScreenPtr screen, CursorPtr cursor)
d499 4
a502 4
    ScrnInfoPtr		scrn = xf86Screens[screen->myNum];
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CursorInfoPtr	cursor_info = xf86_config->cursor_info;
    
d505 1
a505 1
	FreeCursor (xf86_config->cursor, None);
d507 1
a507 1
    
d510 2
a511 2
	return FALSE;
    
d513 2
a514 2
	cursor->bits->height> cursor_info->MaxHeight)
	return FALSE;
d520 1
a520 1
xf86_crtc_load_cursor_argb (xf86CrtcPtr crtc, CursorPtr cursor)
d522 14
a535 13
    ScrnInfoPtr		scrn = crtc->scrn;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CursorInfoPtr	cursor_info = xf86_config->cursor_info;
    CARD32		*cursor_image = (CARD32 *) xf86_config->cursor_image;
    CARD32		*cursor_source = (CARD32 *) cursor->bits->argb;
    int			x, y;
    int			xin, yin;
    CARD32		bits;
    int			source_width = cursor->bits->width;
    int			source_height = cursor->bits->height;
    int			image_width = cursor_info->MaxWidth;
    int			image_height = cursor_info->MaxHeight;
    
d537 11
a547 12
	for (x = 0; x < image_width; x++)
	{
	    xf86_crtc_rotate_coord (crtc->rotation, image_width, image_height,
				    x, y, &xin, &yin);
	    if (xin < source_width && yin < source_height)
		bits = cursor_source[yin * source_width + xin];
	    else
		bits = 0;
	    cursor_image[y * image_width + x] = bits;
	}
    
    crtc->funcs->load_cursor_argb (crtc, cursor_image);
d551 4
a554 8
xf86_load_cursor_argb (ScrnInfoPtr scrn, CursorPtr cursor)
{
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int			c;

    for (c = 0; c < xf86_config->num_crtc; c++)
    {
	xf86CrtcPtr crtc = xf86_config->crtc[c];
d556 5
a560 2
	if (crtc->enabled)
	    xf86_crtc_load_cursor_argb (crtc, cursor);
d565 1
a565 1
xf86_cursors_init (ScreenPtr screen, int max_width, int max_height, int flags)
d567 3
a569 3
    ScrnInfoPtr		scrn = xf86Screens[screen->myNum];
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    xf86CursorInfoPtr	cursor_info;
d573 1
a573 1
	return FALSE;
d577 3
a579 4
    if (!xf86_config->cursor_image)
    {
	xf86DestroyCursorInfoRec (cursor_info);
	return FALSE;
d581 1
a581 1
	
d595 3
a597 4
    if (flags & HARDWARE_CURSOR_ARGB)
    {
	cursor_info->UseHWCursorARGB = xf86_use_hw_cursor_argb;
	cursor_info->LoadCursorARGB = xf86_load_cursor_argb;
d600 1
a600 1
    
d602 3
a604 3
    xf86_hide_cursors (scrn);
    
    return xf86InitCursor (screen, cursor_info);
d614 1
a614 1
xf86_reload_cursors (ScreenPtr screen)
d616 5
a620 5
    ScrnInfoPtr		scrn;
    xf86CrtcConfigPtr   xf86_config;
    xf86CursorInfoPtr   cursor_info;
    CursorPtr		cursor;
    int			x, y;
d622 1
a622 1
    
d627 1
a627 1
	return;
d629 1
a629 1
					  xf86CursorScreenKey);
d632 1
a632 1
	return;
d640 1
a640 1
	return;
d643 1
a643 1
    GetSpritePosition (inputInfo.pointer, &x, &y);
d645 1
a645 1
	(*cursor_info->HideCursor)(scrn);
d647 4
a650 3
    if (cursor)
    {
	void *src = dixLookupPrivate(&cursor->devPrivates, CursorScreenKey(screen));
d652 3
a654 3
	if (cursor->bits->argb && cursor_info->LoadCursorARGB)
	    (*cursor_info->LoadCursorARGB) (scrn, cursor);
	else if (src)
d656 1
a656 1
	    (*cursor_info->LoadCursorImage)(scrn, src);
d658 3
a660 3
	x += scrn->frameX0 + cursor_screen_priv->HotX;
	y += scrn->frameY0 + cursor_screen_priv->HotY;
	(*cursor_info->SetCursorPosition)(scrn, x, y);
d668 1
a668 1
xf86_cursors_fini (ScreenPtr screen)
d670 6
a675 7
    ScrnInfoPtr		scrn = xf86Screens[screen->myNum];
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    
    if (xf86_config->cursor_info)
    {
	xf86DestroyCursorInfoRec (xf86_config->cursor_info);
	xf86_config->cursor_info = NULL;
d679 3
a681 4
    if (xf86_config->cursor)
    {
	FreeCursor (xf86_config->cursor, None);
	xf86_config->cursor = NULL;
@


1.8
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@a254 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a255 3
#else
        cursor->devPriv[screen->myNum]
#endif
a652 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a653 3
#else
	void *src = cursor->devPriv[screen->myNum];
#endif
@


1.7
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d3 1
d130 5
d138 19
a156 3
static int
cursor_bitpos (int flags, int x, Bool mask)
{
d174 7
a180 1
    return x;
d187 1
a187 1
get_bit (CARD8 *image, int stride, int flags, int x, int y, Bool mask)
d189 2
a190 3
    x = cursor_bitpos (flags, x, mask);
    image += y * stride;
    return (image[(x >> 3)] >> (x & 7)) & 1;
d197 1
a197 1
set_bit (CARD8 *image, int stride, int flags, int x, int y, Bool mask)
d199 2
a200 3
    x = cursor_bitpos (flags, x, mask);
    image += y * stride;
    image[(x >> 3)] |= 1 << (x & 7);
a214 1
    int			stride = cursor_info->MaxWidth >> 2;
d229 1
a229 1
	    if (get_bit (src, stride, flags, xin, yin, TRUE) ==
d232 1
a232 1
		if (get_bit (src, stride, flags, xin, yin, FALSE))
a438 1
	int flags = cursor_info->Flags;
d450 4
a453 4
		if (get_bit(src, stride, flags, xin, yin, FALSE))
		    set_bit(cursor_image, stride, flags, x, y, FALSE);
		if (get_bit(src, stride, flags, xin, yin, TRUE))
		    set_bit(cursor_image, stride, flags, x, y, TRUE);
@


1.6
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a43 1
#ifdef RENDER
a44 1
#endif
d328 3
a330 1
	v.v[0] = x + ScreenPriv->HotX; v.v[1] = y + ScreenPriv->HotY; v.v[2] = 1;
d332 3
a334 2
	x = floor (v.v[0] + 0.5);
	y = floor (v.v[1] + 0.5);
d557 1
a557 1
    xf86_config->cursor_image = xalloc (max_width * max_height * 4);
d665 2
a666 5
    if (xf86_config->cursor_image)
    {
	xfree (xf86_config->cursor_image);
	xf86_config->cursor_image = NULL;
    }
@


1.5
log
@Add a configure test for newer proto headers and use it to enable
building xserver 1.6 with those headers. ok oga@@.
@
text
@d42 1
a42 6
#ifdef HAVE_X11_EXTENSIONS_DPMSCONST_H
#include <X11/extensions/dpmsconst.h>
#else
#define DPMS_SERVER
#include "X11/extensions/dpms.h"
#endif
d267 1
a267 1
_X_EXPORT void
d293 1
a293 1
_X_EXPORT void
d464 1
d468 1
a468 2
    ++cursor->refcnt;
    
d483 1
a486 1
    ++cursor->refcnt;
d545 1
a545 1
_X_EXPORT Bool
d596 1
a596 1
_X_EXPORT void
d614 1
a614 1
    if (!cursor_screen_priv->isUp)
d653 1
a653 1
_X_EXPORT void
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d42 3
d47 1
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d40 1
d49 1
d232 7
a238 2
    CARD8		*bits = cursor ? dixLookupPrivate(&cursor->devPrivates,
							  screen) : NULL;
d325 20
a344 5
	PictVector	v;
	v.vector[0] = IntToxFixed (x); v.vector[1] = IntToxFixed (y); v.vector[2] = IntToxFixed(1);
	PictureTransformPoint (&crtc->framebuffer_to_crtc, &v);
	x = xFixedToInt (v.vector[0]); y = xFixedToInt (v.vector[1]);
    }
a349 9
    /*
     * Transform position of cursor upper left corner
     */
    xf86_crtc_rotate_coord_back (crtc->rotation,
				 cursor_info->MaxWidth,
				 cursor_info->MaxHeight,
				 0, 0, &dx, &dy);
    x -= dx;
    y -= dy;
d605 1
d607 9
a615 2
    /* initial mode setting will not have set a screen yet */
    if (!screen)
d617 1
d625 1
a625 1
    
d627 1
a627 1
    GetSpritePosition (&x, &y);
d634 1
a634 1
	void *src = dixLookupPrivate(&cursor->devPrivates, screen);
d643 1
a643 1
	    (*cursor_info->LoadCursorImage)(cursor_info->pScrn, src);
d645 3
a647 2
	(*cursor_info->SetCursorPosition)(cursor_info->pScrn, x, y);
	(*cursor_info->ShowCursor)(cursor_info->pScrn);
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d230 2
a231 1
    CARD8		*bits = cursor ? cursor->devPriv[screen->myNum] : NULL;
d404 1
a404 1
	memset(cursor_image, 0, cursor_info->MaxWidth * stride);
d611 5
d619 1
a619 1
	else
d621 1
a621 2
	    (*cursor_info->LoadCursorImage)(cursor_info->pScrn,
					    cursor->devPriv[screen->myNum]);
@


1.1
log
@Initial revision
@
text
@d140 2
a141 1
    if (flags & HARDWARE_CURSOR_BIT_ORDER_MSBFIRST)
@


1.1.1.1
log
@xserver 1.4
@
text
@@
