head	1.18;
access;
symbols
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.2
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.2
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.05.29.12.02.38;	author matthieu;	state Exp;
branches;
next	1.17;
commitid	s0SI41sEunLdyFfd;

1.17
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	7pAEtF6Y5EgemkuY;

1.16
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	Te1daavkBLskZ8gc;

1.15
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	cVXoV5PxI8YrEaVA;

1.14
date	2014.05.02.19.27.49;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2013.12.28.14.40.02;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.21.21.26.08;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.10.20.45.49;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.21.20.10.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.31.14.09.44;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.01.22;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.01.22;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.12.13.21.12.53;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright Â© 2002 Keith Packard, member of The XFree86 Project, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#else
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#endif

#include "xf86.h"
#include "os.h"
#include "globals.h"
#include "xf86Modes.h"
#include "xf86Priv.h"
#include "xf86DDC.h"
#include "mipointer.h"
#include "windowstr.h"
#include "inputstr.h"
#include <randrstr.h>
#include <X11/extensions/render.h>

#include "xf86Crtc.h"
#include "xf86RandR12.h"

typedef struct _xf86RandR12Info {
    int virtualX;
    int virtualY;
    int mmWidth;
    int mmHeight;
    int maxX;
    int maxY;
    int pointerX;
    int pointerY;
    Rotation rotation;          /* current mode */
    Rotation supported_rotations;       /* driver supported */

    /* Used to wrap EnterVT so we can re-probe the outputs when a laptop unsuspends
     * (actually, any time that we switch back into our VT).
     *
     * See https://bugs.freedesktop.org/show_bug.cgi?id=21554
     */
    xf86EnterVTProc *orig_EnterVT;

    Bool                         panning;
    ConstrainCursorHarderProcPtr orig_ConstrainCursorHarder;
} XF86RandRInfoRec, *XF86RandRInfoPtr;

#ifdef RANDR_12_INTERFACE
static Bool xf86RandR12Init12(ScreenPtr pScreen);
static Bool xf86RandR12CreateScreenResources12(ScreenPtr pScreen);
#endif

static int xf86RandR12Generation;

static DevPrivateKeyRec xf86RandR12KeyRec;
static DevPrivateKey xf86RandR12Key;

#define XF86RANDRINFO(p) ((XF86RandRInfoPtr) \
    dixLookupPrivate(&(p)->devPrivates, xf86RandR12Key))

static int
xf86RandR12ModeRefresh(DisplayModePtr mode)
{
    if (mode->VRefresh)
        return (int) (mode->VRefresh + 0.5);
    else
        return (int) (mode->Clock * 1000.0 / mode->HTotal / mode->VTotal + 0.5);
}

/* Adapt panning area; return TRUE if panning area was valid without adaption */
static int
xf86RandR13VerifyPanningArea(xf86CrtcPtr crtc, int screenWidth,
                             int screenHeight)
{
    int ret = TRUE;

    if (crtc->version < 2)
        return FALSE;

    if (crtc->panningTotalArea.x2 <= crtc->panningTotalArea.x1) {
        /* Panning in X is disabled */
        if (crtc->panningTotalArea.x1 || crtc->panningTotalArea.x2)
            /* Illegal configuration -> fail/disable */
            ret = FALSE;
        crtc->panningTotalArea.x1 = crtc->panningTotalArea.x2 = 0;
        crtc->panningTrackingArea.x1 = crtc->panningTrackingArea.x2 = 0;
        crtc->panningBorder[0] = crtc->panningBorder[2] = 0;
    }
    else {
        /* Panning in X is enabled */
        if (crtc->panningTotalArea.x1 < 0) {
            /* Panning region outside screen -> move inside */
            crtc->panningTotalArea.x2 -= crtc->panningTotalArea.x1;
            crtc->panningTotalArea.x1 = 0;
            ret = FALSE;
        }
        if (crtc->panningTotalArea.x2 <
            crtc->panningTotalArea.x1 + crtc->mode.HDisplay) {
            /* Panning region smaller than displayed area -> crop to displayed area */
            crtc->panningTotalArea.x2 =
                crtc->panningTotalArea.x1 + crtc->mode.HDisplay;
            ret = FALSE;
        }
        if (crtc->panningTotalArea.x2 > screenWidth) {
            /* Panning region larger than screen -> move inside, then crop to screen */
            crtc->panningTotalArea.x1 -=
                crtc->panningTotalArea.x2 - screenWidth;
            crtc->panningTotalArea.x2 = screenWidth;
            ret = FALSE;
            if (crtc->panningTotalArea.x1 < 0)
                crtc->panningTotalArea.x1 = 0;
        }
        if (crtc->panningBorder[0] + crtc->panningBorder[2] >
            crtc->mode.HDisplay) {
            /* Borders too large -> set to 0 */
            crtc->panningBorder[0] = crtc->panningBorder[2] = 0;
            ret = FALSE;
        }
    }

    if (crtc->panningTotalArea.y2 <= crtc->panningTotalArea.y1) {
        /* Panning in Y is disabled */
        if (crtc->panningTotalArea.y1 || crtc->panningTotalArea.y2)
            /* Illegal configuration -> fail/disable */
            ret = FALSE;
        crtc->panningTotalArea.y1 = crtc->panningTotalArea.y2 = 0;
        crtc->panningTrackingArea.y1 = crtc->panningTrackingArea.y2 = 0;
        crtc->panningBorder[1] = crtc->panningBorder[3] = 0;
    }
    else {
        /* Panning in Y is enabled */
        if (crtc->panningTotalArea.y1 < 0) {
            /* Panning region outside screen -> move inside */
            crtc->panningTotalArea.y2 -= crtc->panningTotalArea.y1;
            crtc->panningTotalArea.y1 = 0;
            ret = FALSE;
        }
        if (crtc->panningTotalArea.y2 <
            crtc->panningTotalArea.y1 + crtc->mode.VDisplay) {
            /* Panning region smaller than displayed area -> crop to displayed area */
            crtc->panningTotalArea.y2 =
                crtc->panningTotalArea.y1 + crtc->mode.VDisplay;
            ret = FALSE;
        }
        if (crtc->panningTotalArea.y2 > screenHeight) {
            /* Panning region larger than screen -> move inside, then crop to screen */
            crtc->panningTotalArea.y1 -=
                crtc->panningTotalArea.y2 - screenHeight;
            crtc->panningTotalArea.y2 = screenHeight;
            ret = FALSE;
            if (crtc->panningTotalArea.y1 < 0)
                crtc->panningTotalArea.y1 = 0;
        }
        if (crtc->panningBorder[1] + crtc->panningBorder[3] >
            crtc->mode.VDisplay) {
            /* Borders too large -> set to 0 */
            crtc->panningBorder[1] = crtc->panningBorder[3] = 0;
            ret = FALSE;
        }
    }

    return ret;
}

/*
 * The heart of the panning operation:
 *
 * Given a frame buffer position (fb_x, fb_y),
 * and a crtc position (crtc_x, crtc_y),
 * and a transform matrix which maps frame buffer to crtc,
 * compute a panning position (pan_x, pan_y) that
 * makes the resulting transform line those two up
 */

static void
xf86ComputeCrtcPan(Bool transform_in_use,
                   struct pixman_f_transform *m,
                   double screen_x, double screen_y,
                   double crtc_x, double crtc_y,
                   int old_pan_x, int old_pan_y, int *new_pan_x, int *new_pan_y)
{
    if (transform_in_use) {
        /*
         * Given the current transform, M, the current position
         * on the Screen, S, and the desired position on the CRTC,
         * C, compute a translation, T, such that:
         *
         * M T S = C
         *
         * where T is of the form
         *
         * | 1 0 dx |
         * | 0 1 dy |
         * | 0 0 1  |
         *
         * M T S =
         *   | M00 Sx + M01 Sy + M00 dx + M01 dy + M02 |   | Cx F |
         *   | M10 Sx + M11 Sy + M10 dx + M11 dy + M12 | = | Cy F |
         *   | M20 Sx + M21 Sy + M20 dx + M21 dy + M22 |   |  F   |
         *
         * R = M S
         *
         *   Cx F = M00 dx + M01 dy + R0
         *   Cy F = M10 dx + M11 dy + R1
         *      F = M20 dx + M21 dy + R2
         *
         * Zero out dx, then dy
         *
         * F (Cx M10 - Cy M00) =
         *          (M10 M01 - M00 M11) dy + M10 R0 - M00 R1
         * F (M10 - Cy M20) =
         *          (M10 M21 - M20 M11) dy + M10 R2 - M20 R1
         *
         * F (Cx M11 - Cy M01) =
         *          (M11 M00 - M01 M10) dx + M11 R0 - M01 R1
         * F (M11 - Cy M21) =
         *          (M11 M20 - M21 M10) dx + M11 R2 - M21 R1
         *
         * Make some temporaries
         *
         * T = | Cx M10 - Cy M00 |
         *     | Cx M11 - Cy M01 |
         *
         * U = | M10 M01 - M00 M11 |
         *     | M11 M00 - M01 M10 |
         *
         * Q = | M10 R0 - M00 R1 |
         *     | M11 R0 - M01 R1 |
         *
         * P = | M10 - Cy M20 |
         *     | M11 - Cy M21 |
         *
         * W = | M10 M21 - M20 M11 |
         *     | M11 M20 - M21 M10 |
         *
         * V = | M10 R2 - M20 R1 |
         *         | M11 R2 - M21 R1 |
         *
         * Rewrite:
         *
         * F T0 = U0 dy + Q0
         * F P0 = W0 dy + V0
         * F T1 = U1 dx + Q1
         * F P1 = W1 dx + V1
         *
         * Solve for F (two ways)
         *
         * F (W0 T0 - U0 P0)  = W0 Q0 - U0 V0
         *
         *     W0 Q0 - U0 V0
         * F = -------------
         *     W0 T0 - U0 P0
         *
         * F (W1 T1 - U1 P1) = W1 Q1 - U1 V1
         *
         *     W1 Q1 - U1 V1
         * F = -------------
         *     W1 T1 - U1 P1
         *
         * We'll use which ever solution works (denominator != 0)
         *
         * Finally, solve for dx and dy:
         *
         * dx = (F T1 - Q1) / U1
         * dx = (F P1 - V1) / W1
         *
         * dy = (F T0 - Q0) / U0
         * dy = (F P0 - V0) / W0
         */
        double r[3];
        double q[2], u[2], t[2], v[2], w[2], p[2];
        double f;
        struct pict_f_vector d;
        int i;

        /* Get the un-normalized crtc coordinates again */
        for (i = 0; i < 3; i++)
            r[i] = m->m[i][0] * screen_x + m->m[i][1] * screen_y + m->m[i][2];

        /* Combine values into temporaries */
        for (i = 0; i < 2; i++) {
            q[i] = m->m[1][i] * r[0] - m->m[0][i] * r[1];
            u[i] = m->m[1][i] * m->m[0][1 - i] - m->m[0][i] * m->m[1][1 - i];
            t[i] = m->m[1][i] * crtc_x - m->m[0][i] * crtc_y;

            v[i] = m->m[1][i] * r[2] - m->m[2][i] * r[1];
            w[i] = m->m[1][i] * m->m[2][1 - i] - m->m[2][i] * m->m[1][1 - i];
            p[i] = m->m[1][i] - m->m[2][i] * crtc_y;
        }

        /* Find a way to compute f */
        f = 0;
        for (i = 0; i < 2; i++) {
            double a = w[i] * q[i] - u[i] * v[i];
            double b = w[i] * t[i] - u[i] * p[i];

            if (b != 0) {
                f = a / b;
                break;
            }
        }

        /* Solve for the resulting transform vector */
        for (i = 0; i < 2; i++) {
            if (u[i])
                d.v[1 - i] = (t[i] * f - q[i]) / u[i];
            else if (w[1])
                d.v[1 - i] = (p[i] * f - v[i]) / w[i];
            else
                d.v[1 - i] = 0;
        }
        *new_pan_x = old_pan_x - floor(d.v[0] + 0.5);
        *new_pan_y = old_pan_y - floor(d.v[1] + 0.5);
    }
    else {
        *new_pan_x = screen_x - crtc_x;
        *new_pan_y = screen_y - crtc_y;
    }
}

static void
xf86RandR13Pan(xf86CrtcPtr crtc, int x, int y)
{
    int newX, newY;
    int width, height;
    Bool panned = FALSE;

    if (crtc->version < 2)
        return;

    if (!crtc->enabled ||
        (crtc->panningTotalArea.x2 <= crtc->panningTotalArea.x1 &&
         crtc->panningTotalArea.y2 <= crtc->panningTotalArea.y1))
        return;

    newX = crtc->x;
    newY = crtc->y;
    width = crtc->mode.HDisplay;
    height = crtc->mode.VDisplay;

    if ((crtc->panningTrackingArea.x2 <= crtc->panningTrackingArea.x1 ||
         (x >= crtc->panningTrackingArea.x1 &&
          x < crtc->panningTrackingArea.x2)) &&
        (crtc->panningTrackingArea.y2 <= crtc->panningTrackingArea.y1 ||
         (y >= crtc->panningTrackingArea.y1 &&
          y < crtc->panningTrackingArea.y2))) {
        struct pict_f_vector c;

        /*
         * Pre-clip the mouse position to the panning area so that we don't
         * push the crtc outside. This doesn't deal with changes to the
         * panning values, only mouse position changes.
         */
        if (crtc->panningTotalArea.x2 > crtc->panningTotalArea.x1) {
            if (x < crtc->panningTotalArea.x1)
                x = crtc->panningTotalArea.x1;
            if (x >= crtc->panningTotalArea.x2)
                x = crtc->panningTotalArea.x2 - 1;
        }
        if (crtc->panningTotalArea.y2 > crtc->panningTotalArea.y1) {
            if (y < crtc->panningTotalArea.y1)
                y = crtc->panningTotalArea.y1;
            if (y >= crtc->panningTotalArea.y2)
                y = crtc->panningTotalArea.y2 - 1;
        }

        c.v[0] = x;
        c.v[1] = y;
        c.v[2] = 1.0;
        if (crtc->transform_in_use) {
            pixman_f_transform_point(&crtc->f_framebuffer_to_crtc, &c);
        }
        else {
            c.v[0] -= crtc->x;
            c.v[1] -= crtc->y;
        }

        if (crtc->panningTotalArea.x2 > crtc->panningTotalArea.x1) {
            if (c.v[0] < crtc->panningBorder[0]) {
                c.v[0] = crtc->panningBorder[0];
                panned = TRUE;
            }
            if (c.v[0] >= width - crtc->panningBorder[2]) {
                c.v[0] = width - crtc->panningBorder[2] - 1;
                panned = TRUE;
            }
        }
        if (crtc->panningTotalArea.y2 > crtc->panningTotalArea.y1) {
            if (c.v[1] < crtc->panningBorder[1]) {
                c.v[1] = crtc->panningBorder[1];
                panned = TRUE;
            }
            if (c.v[1] >= height - crtc->panningBorder[3]) {
                c.v[1] = height - crtc->panningBorder[3] - 1;
                panned = TRUE;
            }
        }
        if (panned)
            xf86ComputeCrtcPan(crtc->transform_in_use,
                               &crtc->f_framebuffer_to_crtc,
                               x, y, c.v[0], c.v[1], newX, newY, &newX, &newY);
    }

    /*
     * Ensure that the crtc is within the panning region.
     *
     * XXX This computation only works when we do not have a transform
     * in use.
     */
    if (!crtc->transform_in_use) {
        /* Validate against [xy]1 after [xy]2, to be sure that results are > 0 for [xy]1 > 0 */
        if (crtc->panningTotalArea.x2 > crtc->panningTotalArea.x1) {
            if (newX > crtc->panningTotalArea.x2 - width)
                newX = crtc->panningTotalArea.x2 - width;
            if (newX < crtc->panningTotalArea.x1)
                newX = crtc->panningTotalArea.x1;
        }
        if (crtc->panningTotalArea.y2 > crtc->panningTotalArea.y1) {
            if (newY > crtc->panningTotalArea.y2 - height)
                newY = crtc->panningTotalArea.y2 - height;
            if (newY < crtc->panningTotalArea.y1)
                newY = crtc->panningTotalArea.y1;
        }
    }
    if (newX != crtc->x || newY != crtc->y)
        xf86CrtcSetOrigin(crtc, newX, newY);
}

static Bool
xf86RandR12GetInfo(ScreenPtr pScreen, Rotation * rotations)
{
    RRScreenSizePtr pSize;
    ScrnInfoPtr scrp = xf86ScreenToScrn(pScreen);
    XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);
    DisplayModePtr mode;
    int maxX = 0, maxY = 0;

    *rotations = randrp->supported_rotations;

    if (randrp->virtualX == -1 || randrp->virtualY == -1) {
        randrp->virtualX = scrp->virtualX;
        randrp->virtualY = scrp->virtualY;
    }

    /* Re-probe the outputs for new monitors or modes */
    if (scrp->vtSema) {
        xf86ProbeOutputModes(scrp, 0, 0);
        xf86SetScrnInfoModes(scrp);
    }

    for (mode = scrp->modes;; mode = mode->next) {
        int refresh = xf86RandR12ModeRefresh(mode);

        if (randrp->maxX == 0 || randrp->maxY == 0) {
            if (maxX < mode->HDisplay)
                maxX = mode->HDisplay;
            if (maxY < mode->VDisplay)
                maxY = mode->VDisplay;
        }
        pSize = RRRegisterSize(pScreen,
                               mode->HDisplay, mode->VDisplay,
                               randrp->mmWidth, randrp->mmHeight);
        if (!pSize)
            return FALSE;
        RRRegisterRate(pScreen, pSize, refresh);

        if (xf86ModesEqual(mode, scrp->currentMode)) {
            RRSetCurrentConfig(pScreen, randrp->rotation, refresh, pSize);
        }
        if (mode->next == scrp->modes)
            break;
    }

    if (randrp->maxX == 0 || randrp->maxY == 0) {
        randrp->maxX = maxX;
        randrp->maxY = maxY;
    }

    return TRUE;
}

static Bool
xf86RandR12SetMode(ScreenPtr pScreen,
                   DisplayModePtr mode,
                   Bool useVirtual, int mmWidth, int mmHeight)
{
    ScrnInfoPtr scrp = xf86ScreenToScrn(pScreen);
    XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);
    int oldWidth = pScreen->width;
    int oldHeight = pScreen->height;
    int oldmmWidth = pScreen->mmWidth;
    int oldmmHeight = pScreen->mmHeight;
    WindowPtr pRoot = pScreen->root;
    DisplayModePtr currentMode = NULL;
    Bool ret = TRUE;

    if (pRoot)
        (*scrp->EnableDisableFBAccess) (scrp, FALSE);
    if (useVirtual) {
        scrp->virtualX = randrp->virtualX;
        scrp->virtualY = randrp->virtualY;
    }
    else {
        scrp->virtualX = mode->HDisplay;
        scrp->virtualY = mode->VDisplay;
    }

    if (randrp->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
        /* If the screen is rotated 90 or 270 degrees, swap the sizes. */
        pScreen->width = scrp->virtualY;
        pScreen->height = scrp->virtualX;
        pScreen->mmWidth = mmHeight;
        pScreen->mmHeight = mmWidth;
    }
    else {
        pScreen->width = scrp->virtualX;
        pScreen->height = scrp->virtualY;
        pScreen->mmWidth = mmWidth;
        pScreen->mmHeight = mmHeight;
    }
    if (scrp->currentMode == mode) {
        /* Save current mode */
        currentMode = scrp->currentMode;
        /* Reset, just so we ensure the drivers SwitchMode is called */
        scrp->currentMode = NULL;
    }
    /*
     * We know that if the driver failed to SwitchMode to the rotated
     * version, then it should revert back to it's prior mode.
     */
    if (!xf86SwitchMode(pScreen, mode)) {
        ret = FALSE;
        scrp->virtualX = pScreen->width = oldWidth;
        scrp->virtualY = pScreen->height = oldHeight;
        pScreen->mmWidth = oldmmWidth;
        pScreen->mmHeight = oldmmHeight;
        scrp->currentMode = currentMode;
    }

    /*
     * Make sure the layout is correct
     */
    xf86ReconfigureLayout();

    /*
     * Make sure the whole screen is visible
     */
    xf86SetViewport(pScreen, pScreen->width, pScreen->height);
    xf86SetViewport(pScreen, 0, 0);
    if (pRoot)
        (*scrp->EnableDisableFBAccess) (scrp, TRUE);
    return ret;
}

Bool
xf86RandR12SetConfig(ScreenPtr pScreen,
                     Rotation rotation, int rate, RRScreenSizePtr pSize)
{
    ScrnInfoPtr scrp = xf86ScreenToScrn(pScreen);
    XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);
    DisplayModePtr mode;
    int pos[MAXDEVICES][2];
    Bool useVirtual = FALSE;
    int maxX = 0, maxY = 0;
    Rotation oldRotation = randrp->rotation;
    DeviceIntPtr dev;
    Bool view_adjusted = FALSE;

    randrp->rotation = rotation;

    if (randrp->virtualX == -1 || randrp->virtualY == -1) {
        randrp->virtualX = scrp->virtualX;
        randrp->virtualY = scrp->virtualY;
    }

    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if (!IsMaster(dev) && !IsFloating(dev))
            continue;

        miPointerGetPosition(dev, &pos[dev->id][0], &pos[dev->id][1]);
    }

    for (mode = scrp->modes;; mode = mode->next) {
        if (randrp->maxX == 0 || randrp->maxY == 0) {
            if (maxX < mode->HDisplay)
                maxX = mode->HDisplay;
            if (maxY < mode->VDisplay)
                maxY = mode->VDisplay;
        }
        if (mode->HDisplay == pSize->width &&
            mode->VDisplay == pSize->height &&
            (rate == 0 || xf86RandR12ModeRefresh(mode) == rate))
            break;
        if (mode->next == scrp->modes) {
            if (pSize->width == randrp->virtualX &&
                pSize->height == randrp->virtualY) {
                mode = scrp->modes;
                useVirtual = TRUE;
                break;
            }
            if (randrp->maxX == 0 || randrp->maxY == 0) {
                randrp->maxX = maxX;
                randrp->maxY = maxY;
            }
            return FALSE;
        }
    }

    if (randrp->maxX == 0 || randrp->maxY == 0) {
        randrp->maxX = maxX;
        randrp->maxY = maxY;
    }

    if (!xf86RandR12SetMode(pScreen, mode, useVirtual, pSize->mmWidth,
                            pSize->mmHeight)) {
        randrp->rotation = oldRotation;
        return FALSE;
    }

    /*
     * Move the cursor back where it belongs; SwitchMode repositions it
     * FIXME: duplicated code, see modes/xf86RandR12.c
     */
    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if (!IsMaster(dev) && !IsFloating(dev))
            continue;

        if (pScreen == miPointerGetScreen(dev)) {
            int px = pos[dev->id][0];
            int py = pos[dev->id][1];

            px = (px >= pScreen->width ? (pScreen->width - 1) : px);
            py = (py >= pScreen->height ? (pScreen->height - 1) : py);

            /* Setting the viewpoint makes only sense on one device */
            if (!view_adjusted && IsMaster(dev)) {
                xf86SetViewport(pScreen, px, py);
                view_adjusted = TRUE;
            }

            (*pScreen->SetCursorPosition) (dev, pScreen, px, py, FALSE);
        }
    }

    return TRUE;
}

#define PANNING_ENABLED(crtc)                                           \
    ((crtc)->panningTotalArea.x2 > (crtc)->panningTotalArea.x1 ||       \
     (crtc)->panningTotalArea.y2 > (crtc)->panningTotalArea.y1)

static Bool
xf86RandR12ScreenSetSize(ScreenPtr pScreen,
                         CARD16 width,
                         CARD16 height, CARD32 mmWidth, CARD32 mmHeight)
{
    XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
    WindowPtr pRoot = pScreen->root;
    PixmapPtr pScrnPix;
    Bool ret = FALSE;
    int c;

    if (randrp->virtualX == -1 || randrp->virtualY == -1) {
        randrp->virtualX = pScrn->virtualX;
        randrp->virtualY = pScrn->virtualY;
    }
    if (pRoot && pScrn->vtSema)
        (*pScrn->EnableDisableFBAccess) (pScrn, FALSE);

    /* Let the driver update virtualX and virtualY */
    if (!(*config->funcs->resize) (pScrn, width, height))
        goto finish;

    ret = TRUE;
    /* Update panning information */
    for (c = 0; c < config->num_crtc; c++) {
        xf86CrtcPtr crtc = config->crtc[c];

	if (PANNING_ENABLED (crtc)) {
            if (crtc->panningTotalArea.x2 > crtc->panningTrackingArea.x1)
                crtc->panningTotalArea.x2 += width - pScreen->width;
            if (crtc->panningTotalArea.y2 > crtc->panningTrackingArea.y1)
                crtc->panningTotalArea.y2 += height - pScreen->height;
            if (crtc->panningTrackingArea.x2 > crtc->panningTrackingArea.x1)
                crtc->panningTrackingArea.x2 += width - pScreen->width;
            if (crtc->panningTrackingArea.y2 > crtc->panningTrackingArea.y1)
                crtc->panningTrackingArea.y2 += height - pScreen->height;
            xf86RandR13VerifyPanningArea(crtc, width, height);
            xf86RandR13Pan(crtc, randrp->pointerX, randrp->pointerY);
        }
    }

    pScrnPix = (*pScreen->GetScreenPixmap) (pScreen);
    pScreen->width = pScrnPix->drawable.width = width;
    pScreen->height = pScrnPix->drawable.height = height;
    randrp->mmWidth = pScreen->mmWidth = mmWidth;
    randrp->mmHeight = pScreen->mmHeight = mmHeight;

    xf86SetViewport(pScreen, pScreen->width - 1, pScreen->height - 1);
    xf86SetViewport(pScreen, 0, 0);

 finish:
    update_desktop_dimensions();

    if (pRoot && pScrn->vtSema)
        (*pScrn->EnableDisableFBAccess) (pScrn, TRUE);
#if RANDR_12_INTERFACE
    if (pScreen->root && ret)
        RRScreenSizeNotify(pScreen);
#endif
    return ret;
}

Rotation
xf86RandR12GetRotation(ScreenPtr pScreen)
{
    XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);

    return randrp->rotation;
}

Bool
xf86RandR12CreateScreenResources(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr config;
    XF86RandRInfoPtr randrp;
    int c;
    int width, height;
    int mmWidth, mmHeight;

#ifdef PANORAMIX
    /* XXX disable RandR when using Xinerama */
    if (!noPanoramiXExtension)
        return TRUE;
#endif

    config = XF86_CRTC_CONFIG_PTR(pScrn);
    randrp = XF86RANDRINFO(pScreen);
    /*
     * Compute size of screen
     */
    width = 0;
    height = 0;
    for (c = 0; c < config->num_crtc; c++) {
        xf86CrtcPtr crtc = config->crtc[c];
        int crtc_width = crtc->x + xf86ModeWidth(&crtc->mode, crtc->rotation);
        int crtc_height = crtc->y + xf86ModeHeight(&crtc->mode, crtc->rotation);

        if (crtc->enabled) {
            if (crtc_width > width)
                width = crtc_width;
            if (crtc_height > height)
                height = crtc_height;
            if (crtc->panningTotalArea.x2 > width)
                width = crtc->panningTotalArea.x2;
            if (crtc->panningTotalArea.y2 > height)
                height = crtc->panningTotalArea.y2;
        }
    }

    if (width && height) {
        /*
         * Compute physical size of screen
         */
        if (monitorResolution) {
            mmWidth = width * 25.4 / monitorResolution;
            mmHeight = height * 25.4 / monitorResolution;
        }
        else {
            xf86OutputPtr output = xf86CompatOutput(pScrn);

            if (output &&
                output->conf_monitor &&
                (output->conf_monitor->mon_width > 0 &&
                 output->conf_monitor->mon_height > 0)) {
                /*
                 * Prefer user configured DisplaySize
                 */
                mmWidth = output->conf_monitor->mon_width;
                mmHeight = output->conf_monitor->mon_height;
            }
            else {
                /*
                 * Otherwise, just set the screen to DEFAULT_DPI
                 */
                mmWidth = width * 25.4 / DEFAULT_DPI;
                mmHeight = height * 25.4 / DEFAULT_DPI;
            }
        }
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                   "Setting screen physical size to %d x %d\n",
                   mmWidth, mmHeight);
        /*
         * This is the initial setting of the screen size.
         * We have to pre-set it here, otherwise panning would be adapted
         * to the new screen size.
         */
        pScreen->width = width;
        pScreen->height = height;
        xf86RandR12ScreenSetSize(pScreen, width, height, mmWidth, mmHeight);
        xf86ReconfigureLayout();
    }

    if (randrp->virtualX == -1 || randrp->virtualY == -1) {
        randrp->virtualX = pScrn->virtualX;
        randrp->virtualY = pScrn->virtualY;
    }
    xf86CrtcSetScreenSubpixelOrder(pScreen);
#if RANDR_12_INTERFACE
    if (xf86RandR12CreateScreenResources12(pScreen))
        return TRUE;
#endif
    return TRUE;
}

Bool
xf86RandR12Init(ScreenPtr pScreen)
{
    rrScrPrivPtr rp;
    XF86RandRInfoPtr randrp;

#ifdef PANORAMIX
    /* XXX disable RandR when using Xinerama */
    if (!noPanoramiXExtension) {
        if (xf86NumScreens == 1)
            noPanoramiXExtension = TRUE;
        else
            return TRUE;
    }
#endif

    if (xf86RandR12Generation != serverGeneration)
        xf86RandR12Generation = serverGeneration;

    xf86RandR12Key = &xf86RandR12KeyRec;
    if (!dixRegisterPrivateKey(&xf86RandR12KeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    randrp = malloc(sizeof(XF86RandRInfoRec));
    if (!randrp)
        return FALSE;

    if (!RRScreenInit(pScreen)) {
        free(randrp);
        return FALSE;
    }
    rp = rrGetScrPriv(pScreen);
    rp->rrGetInfo = xf86RandR12GetInfo;
    rp->rrSetConfig = xf86RandR12SetConfig;

    randrp->virtualX = -1;
    randrp->virtualY = -1;
    randrp->mmWidth = pScreen->mmWidth;
    randrp->mmHeight = pScreen->mmHeight;

    randrp->rotation = RR_Rotate_0;     /* initial rotated mode */

    randrp->supported_rotations = RR_Rotate_0;

    randrp->maxX = randrp->maxY = 0;

    dixSetPrivate(&pScreen->devPrivates, xf86RandR12Key, randrp);

#if RANDR_12_INTERFACE
    if (!xf86RandR12Init12(pScreen))
        return FALSE;
#endif
    return TRUE;
}

void
xf86RandR12CloseScreen(ScreenPtr pScreen)
{
    XF86RandRInfoPtr randrp;

    if (xf86RandR12Key == NULL)
        return;

    randrp = XF86RANDRINFO(pScreen);
#if RANDR_12_INTERFACE
    xf86ScreenToScrn(pScreen)->EnterVT = randrp->orig_EnterVT;
    pScreen->ConstrainCursorHarder = randrp->orig_ConstrainCursorHarder;
#endif

    free(randrp);
}

void
xf86RandR12SetRotations(ScreenPtr pScreen, Rotation rotations)
{
    XF86RandRInfoPtr randrp;

#if RANDR_12_INTERFACE
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    int c;
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
#endif

    if (xf86RandR12Key == NULL)
        return;

    randrp = XF86RANDRINFO(pScreen);
#if RANDR_12_INTERFACE
    for (c = 0; c < config->num_crtc; c++) {
        xf86CrtcPtr crtc = config->crtc[c];

        RRCrtcSetRotations(crtc->randr_crtc, rotations);
    }
#endif
    randrp->supported_rotations = rotations;
}

void
xf86RandR12SetTransformSupport(ScreenPtr pScreen, Bool transforms)
{
#if RANDR_13_INTERFACE
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    int c;
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
#endif

    if (xf86RandR12Key == NULL)
        return;

#if RANDR_13_INTERFACE
    for (c = 0; c < config->num_crtc; c++) {
        xf86CrtcPtr crtc = config->crtc[c];

        RRCrtcSetTransformSupport(crtc->randr_crtc, transforms);
    }
#endif
}

void
xf86RandR12GetOriginalVirtualSize(ScrnInfoPtr pScrn, int *x, int *y)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);

    if (xf86RandR12Generation != serverGeneration ||
        XF86RANDRINFO(pScreen)->virtualX == -1) {
        *x = pScrn->virtualX;
        *y = pScrn->virtualY;
    }
    else {
        XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);

        *x = randrp->virtualX;
        *y = randrp->virtualY;
    }
}

#if RANDR_12_INTERFACE

#define FLAG_BITS (RR_HSyncPositive | \
		   RR_HSyncNegative | \
		   RR_VSyncPositive | \
		   RR_VSyncNegative | \
		   RR_Interlace | \
		   RR_DoubleScan | \
		   RR_CSync | \
		   RR_CSyncPositive | \
		   RR_CSyncNegative | \
		   RR_HSkewPresent | \
		   RR_BCast | \
		   RR_PixelMultiplex | \
		   RR_DoubleClock | \
		   RR_ClockDivideBy2)

static Bool
xf86RandRModeMatches(RRModePtr randr_mode, DisplayModePtr mode)
{
#if 0
    if (match_name) {
        /* check for same name */
        int len = strlen(mode->name);

        if (randr_mode->mode.nameLength != len)
            return FALSE;
        if (memcmp(randr_mode->name, mode->name, len) != 0)
            return FALSE;
    }
#endif

    /* check for same timings */
    if (randr_mode->mode.dotClock / 1000 != mode->Clock)
        return FALSE;
    if (randr_mode->mode.width != mode->HDisplay)
        return FALSE;
    if (randr_mode->mode.hSyncStart != mode->HSyncStart)
        return FALSE;
    if (randr_mode->mode.hSyncEnd != mode->HSyncEnd)
        return FALSE;
    if (randr_mode->mode.hTotal != mode->HTotal)
        return FALSE;
    if (randr_mode->mode.hSkew != mode->HSkew)
        return FALSE;
    if (randr_mode->mode.height != mode->VDisplay)
        return FALSE;
    if (randr_mode->mode.vSyncStart != mode->VSyncStart)
        return FALSE;
    if (randr_mode->mode.vSyncEnd != mode->VSyncEnd)
        return FALSE;
    if (randr_mode->mode.vTotal != mode->VTotal)
        return FALSE;

    /* check for same flags (using only the XF86 valid flag bits) */
    if ((randr_mode->mode.modeFlags & FLAG_BITS) != (mode->Flags & FLAG_BITS))
        return FALSE;

    /* everything matches */
    return TRUE;
}

static Bool
xf86RandR12CrtcNotify(RRCrtcPtr randr_crtc)
{
    ScreenPtr pScreen = randr_crtc->pScreen;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
    RRModePtr randr_mode = NULL;
    int x;
    int y;
    Rotation rotation;
    int numOutputs;
    RROutputPtr *randr_outputs;
    RROutputPtr randr_output;
    xf86CrtcPtr crtc = randr_crtc->devPrivate;
    xf86OutputPtr output;
    int i, j;
    DisplayModePtr mode = &crtc->mode;
    Bool ret;

    randr_outputs = xallocarray(config->num_output, sizeof(RROutputPtr));
    if (!randr_outputs)
        return FALSE;
    x = crtc->x;
    y = crtc->y;
    rotation = crtc->rotation;
    numOutputs = 0;
    randr_mode = NULL;
    for (i = 0; i < config->num_output; i++) {
        output = config->output[i];
        if (output->crtc == crtc) {
            randr_output = output->randr_output;
            randr_outputs[numOutputs++] = randr_output;
            /*
             * We make copies of modes, so pointer equality
             * isn't sufficient
             */
            for (j = 0; j < randr_output->numModes + randr_output->numUserModes;
                 j++) {
                RRModePtr m =
                    (j <
                     randr_output->numModes ? randr_output->
                     modes[j] : randr_output->userModes[j -
                                                        randr_output->
                                                        numModes]);

                if (xf86RandRModeMatches(m, mode)) {
                    randr_mode = m;
                    break;
                }
            }
        }
    }
    ret = RRCrtcNotify(randr_crtc, randr_mode, x, y,
                       rotation,
                       crtc->transformPresent ? &crtc->transform : NULL,
                       numOutputs, randr_outputs);
    free(randr_outputs);
    return ret;
}

/*
 * Convert a RandR mode to a DisplayMode
 */
static void
xf86RandRModeConvert(ScrnInfoPtr scrn,
                     RRModePtr randr_mode, DisplayModePtr mode)
{
    memset(mode, 0, sizeof(DisplayModeRec));
    mode->status = MODE_OK;

    mode->Clock = randr_mode->mode.dotClock / 1000;

    mode->HDisplay = randr_mode->mode.width;
    mode->HSyncStart = randr_mode->mode.hSyncStart;
    mode->HSyncEnd = randr_mode->mode.hSyncEnd;
    mode->HTotal = randr_mode->mode.hTotal;
    mode->HSkew = randr_mode->mode.hSkew;

    mode->VDisplay = randr_mode->mode.height;
    mode->VSyncStart = randr_mode->mode.vSyncStart;
    mode->VSyncEnd = randr_mode->mode.vSyncEnd;
    mode->VTotal = randr_mode->mode.vTotal;
    mode->VScan = 0;

    mode->Flags = randr_mode->mode.modeFlags & FLAG_BITS;

    xf86SetModeCrtc(mode, scrn->adjustFlags);
}

static Bool
xf86RandR12CrtcSet(ScreenPtr pScreen,
                   RRCrtcPtr randr_crtc,
                   RRModePtr randr_mode,
                   int x,
                   int y,
                   Rotation rotation,
                   int num_randr_outputs, RROutputPtr * randr_outputs)
{
    XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
    xf86CrtcPtr crtc = randr_crtc->devPrivate;
    RRTransformPtr transform;
    Bool changed = FALSE;
    int o, ro;
    xf86CrtcPtr *save_crtcs;
    Bool save_enabled = crtc->enabled;

    if (!crtc->scrn->vtSema)
        return FALSE;

    save_crtcs = xallocarray(config->num_output, sizeof(xf86CrtcPtr));
    if ((randr_mode != NULL) != crtc->enabled)
        changed = TRUE;
    else if (randr_mode && !xf86RandRModeMatches(randr_mode, &crtc->mode))
        changed = TRUE;

    if (rotation != crtc->rotation)
        changed = TRUE;

    if (crtc->current_scanout != randr_crtc->scanout_pixmap)
        changed = TRUE;

    transform = RRCrtcGetTransform(randr_crtc);
    if ((transform != NULL) != crtc->transformPresent)
        changed = TRUE;
    else if (transform &&
             memcmp(&transform->transform, &crtc->transform.transform,
                    sizeof(transform->transform)) != 0)
        changed = TRUE;

    if (x != crtc->x || y != crtc->y)
        changed = TRUE;
    for (o = 0; o < config->num_output; o++) {
        xf86OutputPtr output = config->output[o];
        xf86CrtcPtr new_crtc;

        save_crtcs[o] = output->crtc;

        if (output->crtc == crtc)
            new_crtc = NULL;
        else
            new_crtc = output->crtc;
        for (ro = 0; ro < num_randr_outputs; ro++)
            if (output->randr_output == randr_outputs[ro]) {
                new_crtc = crtc;
                break;
            }
        if (new_crtc != output->crtc) {
            changed = TRUE;
            output->crtc = new_crtc;
        }
    }
    for (ro = 0; ro < num_randr_outputs; ro++)
        if (randr_outputs[ro]->pendingProperties)
            changed = TRUE;

    /* XXX need device-independent mode setting code through an API */
    if (changed) {
        crtc->enabled = randr_mode != NULL;

        if (randr_mode) {
            DisplayModeRec mode;

            xf86RandRModeConvert(pScrn, randr_mode, &mode);
            if (!xf86CrtcSetModeTransform
                (crtc, &mode, rotation, transform, x, y)) {
                crtc->enabled = save_enabled;
                for (o = 0; o < config->num_output; o++) {
                    xf86OutputPtr output = config->output[o];

                    output->crtc = save_crtcs[o];
                }
                free(save_crtcs);
                return FALSE;
            }
            xf86RandR13VerifyPanningArea(crtc, pScreen->width, pScreen->height);
            xf86RandR13Pan(crtc, randrp->pointerX, randrp->pointerY);
            randrp->panning = PANNING_ENABLED (crtc);
            /*
             * Save the last successful setting for EnterVT
             */
            xf86SaveModeContents(&crtc->desiredMode, &mode);
            crtc->desiredRotation = rotation;
            crtc->current_scanout = randr_crtc->scanout_pixmap;
            if (transform) {
                crtc->desiredTransform = *transform;
                crtc->desiredTransformPresent = TRUE;
            }
            else
                crtc->desiredTransformPresent = FALSE;

            crtc->desiredX = x;
            crtc->desiredY = y;
        }
        xf86DisableUnusedFunctions(pScrn);
    }
    free(save_crtcs);
    return xf86RandR12CrtcNotify(randr_crtc);
}

static Bool
xf86RandR12CrtcSetGamma(ScreenPtr pScreen, RRCrtcPtr randr_crtc)
{
    xf86CrtcPtr crtc = randr_crtc->devPrivate;

    if (crtc->funcs->gamma_set == NULL)
        return FALSE;

    if (!crtc->scrn->vtSema)
        return TRUE;

    /* Realloc local gamma if needed. */
    if (randr_crtc->gammaSize != crtc->gamma_size) {
        CARD16 *tmp_ptr;

        tmp_ptr = reallocarray(crtc->gamma_red,
                               randr_crtc->gammaSize, 3 * sizeof(CARD16));
        if (!tmp_ptr)
            return FALSE;
        crtc->gamma_red = tmp_ptr;
        crtc->gamma_green = crtc->gamma_red + randr_crtc->gammaSize;
        crtc->gamma_blue = crtc->gamma_green + randr_crtc->gammaSize;
    }

    crtc->gamma_size = randr_crtc->gammaSize;
    memcpy(crtc->gamma_red, randr_crtc->gammaRed,
           crtc->gamma_size * sizeof(CARD16));
    memcpy(crtc->gamma_green, randr_crtc->gammaGreen,
           crtc->gamma_size * sizeof(CARD16));
    memcpy(crtc->gamma_blue, randr_crtc->gammaBlue,
           crtc->gamma_size * sizeof(CARD16));

    /* Only set it when the crtc is actually running.
     * Otherwise it will be set when it's activated.
     */
    if (crtc->active)
        crtc->funcs->gamma_set(crtc, crtc->gamma_red, crtc->gamma_green,
                               crtc->gamma_blue, crtc->gamma_size);

    return TRUE;
}

static Bool
xf86RandR12CrtcGetGamma(ScreenPtr pScreen, RRCrtcPtr randr_crtc)
{
    xf86CrtcPtr crtc = randr_crtc->devPrivate;

    if (!crtc->gamma_size)
        return FALSE;

    if (!crtc->gamma_red || !crtc->gamma_green || !crtc->gamma_blue)
        return FALSE;

    /* Realloc randr gamma if needed. */
    if (randr_crtc->gammaSize != crtc->gamma_size) {
        CARD16 *tmp_ptr;

        tmp_ptr = reallocarray(randr_crtc->gammaRed,
                               crtc->gamma_size, 3 * sizeof(CARD16));
        if (!tmp_ptr)
            return FALSE;
        randr_crtc->gammaRed = tmp_ptr;
        randr_crtc->gammaGreen = randr_crtc->gammaRed + crtc->gamma_size;
        randr_crtc->gammaBlue = randr_crtc->gammaGreen + crtc->gamma_size;
    }
    randr_crtc->gammaSize = crtc->gamma_size;
    memcpy(randr_crtc->gammaRed, crtc->gamma_red,
           crtc->gamma_size * sizeof(CARD16));
    memcpy(randr_crtc->gammaGreen, crtc->gamma_green,
           crtc->gamma_size * sizeof(CARD16));
    memcpy(randr_crtc->gammaBlue, crtc->gamma_blue,
           crtc->gamma_size * sizeof(CARD16));

    return TRUE;
}

static Bool
xf86RandR12OutputSetProperty(ScreenPtr pScreen,
                             RROutputPtr randr_output,
                             Atom property, RRPropertyValuePtr value)
{
    xf86OutputPtr output = randr_output->devPrivate;

    /* If we don't have any property handler, then we don't care what the
     * user is setting properties to.
     */
    if (output->funcs->set_property == NULL)
        return TRUE;

    /*
     * This function gets called even when vtSema is FALSE, as
     * drivers will need to remember the correct value to apply
     * when the VT switch occurs
     */
    return output->funcs->set_property(output, property, value);
}

static Bool
xf86RandR13OutputGetProperty(ScreenPtr pScreen,
                             RROutputPtr randr_output, Atom property)
{
    xf86OutputPtr output = randr_output->devPrivate;

    if (output->funcs->get_property == NULL)
        return TRUE;

    /* Should be safe even w/o vtSema */
    return output->funcs->get_property(output, property);
}

static Bool
xf86RandR12OutputValidateMode(ScreenPtr pScreen,
                              RROutputPtr randr_output, RRModePtr randr_mode)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86OutputPtr output = randr_output->devPrivate;
    DisplayModeRec mode;

    xf86RandRModeConvert(pScrn, randr_mode, &mode);
    /*
     * This function may be called when vtSema is FALSE, so
     * the underlying function must either avoid touching the hardware
     * or return FALSE when vtSema is FALSE
     */
    if (output->funcs->mode_valid(output, &mode) != MODE_OK)
        return FALSE;
    return TRUE;
}

static void
xf86RandR12ModeDestroy(ScreenPtr pScreen, RRModePtr randr_mode)
{
}

/**
 * Given a list of xf86 modes and a RandR Output object, construct
 * RandR modes and assign them to the output
 */
static Bool
xf86RROutputSetModes(RROutputPtr randr_output, DisplayModePtr modes)
{
    DisplayModePtr mode;
    RRModePtr *rrmodes = NULL;
    int nmode = 0;
    int npreferred = 0;
    Bool ret = TRUE;
    int pref;

    for (mode = modes; mode; mode = mode->next)
        nmode++;

    if (nmode) {
        rrmodes = xallocarray(nmode, sizeof(RRModePtr));

        if (!rrmodes)
            return FALSE;
        nmode = 0;

        for (pref = 1; pref >= 0; pref--) {
            for (mode = modes; mode; mode = mode->next) {
                if ((pref != 0) == ((mode->type & M_T_PREFERRED) != 0)) {
                    xRRModeInfo modeInfo;
                    RRModePtr rrmode;

                    modeInfo.nameLength = strlen(mode->name);
                    modeInfo.width = mode->HDisplay;
                    modeInfo.dotClock = mode->Clock * 1000;
                    modeInfo.hSyncStart = mode->HSyncStart;
                    modeInfo.hSyncEnd = mode->HSyncEnd;
                    modeInfo.hTotal = mode->HTotal;
                    modeInfo.hSkew = mode->HSkew;

                    modeInfo.height = mode->VDisplay;
                    modeInfo.vSyncStart = mode->VSyncStart;
                    modeInfo.vSyncEnd = mode->VSyncEnd;
                    modeInfo.vTotal = mode->VTotal;
                    modeInfo.modeFlags = mode->Flags;

                    rrmode = RRModeGet(&modeInfo, mode->name);
                    if (rrmode) {
                        rrmodes[nmode++] = rrmode;
                        npreferred += pref;
                    }
                }
            }
        }
    }

    ret = RROutputSetModes(randr_output, rrmodes, nmode, npreferred);
    free(rrmodes);
    return ret;
}

/*
 * Mirror the current mode configuration to RandR
 */
static Bool
xf86RandR12SetInfo12(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
    RROutputPtr *clones;
    RRCrtcPtr *crtcs;
    int ncrtc;
    int o, c, l;
    int nclone;

    clones = xallocarray(config->num_output, sizeof(RROutputPtr));
    crtcs = xallocarray(config->num_crtc, sizeof(RRCrtcPtr));
    for (o = 0; o < config->num_output; o++) {
        xf86OutputPtr output = config->output[o];

        ncrtc = 0;
        for (c = 0; c < config->num_crtc; c++)
            if (output->possible_crtcs & (1 << c))
                crtcs[ncrtc++] = config->crtc[c]->randr_crtc;

        if (!RROutputSetCrtcs(output->randr_output, crtcs, ncrtc)) {
            free(crtcs);
            free(clones);
            return FALSE;
        }

        RROutputSetPhysicalSize(output->randr_output,
                                output->mm_width, output->mm_height);
        xf86RROutputSetModes(output->randr_output, output->probed_modes);

        switch (output->status) {
        case XF86OutputStatusConnected:
            RROutputSetConnection(output->randr_output, RR_Connected);
            break;
        case XF86OutputStatusDisconnected:
            RROutputSetConnection(output->randr_output, RR_Disconnected);
            break;
        case XF86OutputStatusUnknown:
            RROutputSetConnection(output->randr_output, RR_UnknownConnection);
            break;
        }

        RROutputSetSubpixelOrder(output->randr_output, output->subpixel_order);

        /*
         * Valid clones
         */
        nclone = 0;
        for (l = 0; l < config->num_output; l++) {
            xf86OutputPtr clone = config->output[l];

            if (l != o && (output->possible_clones & (1 << l)))
                clones[nclone++] = clone->randr_output;
        }
        if (!RROutputSetClones(output->randr_output, clones, nclone)) {
            free(crtcs);
            free(clones);
            return FALSE;
        }
    }
    free(crtcs);
    free(clones);
    return TRUE;
}

/*
 * Query the hardware for the current state, then mirror
 * that to RandR
 */
static Bool
xf86RandR12GetInfo12(ScreenPtr pScreen, Rotation * rotations)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);

    if (!pScrn->vtSema)
        return TRUE;
    xf86ProbeOutputModes(pScrn, 0, 0);
    xf86SetScrnInfoModes(pScrn);
    return xf86RandR12SetInfo12(pScreen);
}

static Bool
xf86RandR12CreateObjects12(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
    int c;
    int o;

    if (!RRInit())
        return FALSE;

    /*
     * Configure crtcs
     */
    for (c = 0; c < config->num_crtc; c++) {
        xf86CrtcPtr crtc = config->crtc[c];

        crtc->randr_crtc = RRCrtcCreate(pScreen, crtc);
        RRCrtcGammaSetSize(crtc->randr_crtc, 256);
    }
    /*
     * Configure outputs
     */
    for (o = 0; o < config->num_output; o++) {
        xf86OutputPtr output = config->output[o];

        output->randr_output = RROutputCreate(pScreen, output->name,
                                              strlen(output->name), output);

        if (output->funcs->create_resources != NULL)
            output->funcs->create_resources(output);
        RRPostPendingProperties(output->randr_output);
    }

    if (config->name) {
        config->randr_provider = RRProviderCreate(pScreen, config->name,
                                                  strlen(config->name));

        RRProviderSetCapabilities(config->randr_provider, pScrn->capabilities);
    }

    return TRUE;
}

static void
xf86RandR12CreateMonitors(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
    int o, ot;
    int ht, vt;
    int ret;
    char buf[25];

    for (o = 0; o < config->num_output; o++) {
        xf86OutputPtr output = config->output[o];
        struct xf86CrtcTileInfo *tile_info = &output->tile_info, *this_tile;
        RRMonitorPtr monitor;
        int output_num, num_outputs;
        if (!tile_info->group_id)
            continue;

        if (tile_info->tile_h_loc ||
            tile_info->tile_v_loc)
            continue;

        num_outputs = tile_info->num_h_tile * tile_info->num_v_tile;

        monitor = RRMonitorAlloc(num_outputs);
        if (!monitor)
            return;
        monitor->pScreen = pScreen;
        snprintf(buf, 25, "Auto-Monitor-%d", tile_info->group_id);
        monitor->name = MakeAtom(buf, strlen(buf), TRUE);
        monitor->primary = 0;
        monitor->automatic = TRUE;
        memset(&monitor->geometry.box, 0, sizeof(monitor->geometry.box));

        output_num = 0;
        for (ht = 0; ht < tile_info->num_h_tile; ht++) {
            for (vt = 0; vt < tile_info->num_v_tile; vt++) {

                for (ot = 0; ot < config->num_output; ot++) {
                    this_tile = &config->output[ot]->tile_info;

                    if (this_tile->group_id != tile_info->group_id)
                        continue;

                    if (this_tile->tile_h_loc != ht ||
                        this_tile->tile_v_loc != vt)
                        continue;

                    monitor->outputs[output_num] = config->output[ot]->randr_output->id;
                    output_num++;

                }

            }
        }

        ret = RRMonitorAdd(serverClient, pScreen, monitor);
        if (ret) {
            RRMonitorFree(monitor);
            return;
        }
    }
}

static Bool
xf86RandR12CreateScreenResources12(ScreenPtr pScreen)
{
    int c;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);

    if (xf86RandR12Key == NULL)
        return TRUE;

    for (c = 0; c < config->num_crtc; c++)
        xf86RandR12CrtcNotify(config->crtc[c]->randr_crtc);

    RRScreenSetSizeRange(pScreen, config->minWidth, config->minHeight,
                         config->maxWidth, config->maxHeight);

    xf86RandR12CreateMonitors(pScreen);
    return TRUE;
}

/*
 * Something happened within the screen configuration due
 * to DGA, VidMode or hot key. Tell RandR
 */

void
xf86RandR12TellChanged(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
    int c;

    if (xf86RandR12Key == NULL)
        return;

    xf86RandR12SetInfo12(pScreen);
    for (c = 0; c < config->num_crtc; c++)
        xf86RandR12CrtcNotify(config->crtc[c]->randr_crtc);

    RRTellChanged(pScreen);
}

static void
xf86RandR12PointerMoved(ScrnInfoPtr pScrn, int x, int y)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
    XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);
    int c;

    randrp->pointerX = x;
    randrp->pointerY = y;
    for (c = 0; c < config->num_crtc; c++)
        xf86RandR13Pan(config->crtc[c], x, y);
}

static Bool
xf86RandR13GetPanning(ScreenPtr pScreen,
                      RRCrtcPtr randr_crtc,
                      BoxPtr totalArea, BoxPtr trackingArea, INT16 *border)
{
    xf86CrtcPtr crtc = randr_crtc->devPrivate;

    if (crtc->version < 2)
        return FALSE;
    if (totalArea)
        memcpy(totalArea, &crtc->panningTotalArea, sizeof(BoxRec));
    if (trackingArea)
        memcpy(trackingArea, &crtc->panningTrackingArea, sizeof(BoxRec));
    if (border)
        memcpy(border, crtc->panningBorder, 4 * sizeof(INT16));

    return TRUE;
}

static Bool
xf86RandR13SetPanning(ScreenPtr pScreen,
                      RRCrtcPtr randr_crtc,
                      BoxPtr totalArea, BoxPtr trackingArea, INT16 *border)
{
    XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);
    xf86CrtcPtr crtc = randr_crtc->devPrivate;
    BoxRec oldTotalArea;
    BoxRec oldTrackingArea;
    INT16 oldBorder[4];
    Bool oldPanning = randrp->panning;

    if (crtc->version < 2)
        return FALSE;

    memcpy(&oldTotalArea, &crtc->panningTotalArea, sizeof(BoxRec));
    memcpy(&oldTrackingArea, &crtc->panningTrackingArea, sizeof(BoxRec));
    memcpy(oldBorder, crtc->panningBorder, 4 * sizeof(INT16));

    if (totalArea)
        memcpy(&crtc->panningTotalArea, totalArea, sizeof(BoxRec));
    if (trackingArea)
        memcpy(&crtc->panningTrackingArea, trackingArea, sizeof(BoxRec));
    if (border)
        memcpy(crtc->panningBorder, border, 4 * sizeof(INT16));

    if (xf86RandR13VerifyPanningArea(crtc, pScreen->width, pScreen->height)) {
        xf86RandR13Pan(crtc, randrp->pointerX, randrp->pointerY);
        randrp->panning = PANNING_ENABLED (crtc);
        return TRUE;
    }
    else {
        /* Restore old settings */
        memcpy(&crtc->panningTotalArea, &oldTotalArea, sizeof(BoxRec));
        memcpy(&crtc->panningTrackingArea, &oldTrackingArea, sizeof(BoxRec));
        memcpy(crtc->panningBorder, oldBorder, 4 * sizeof(INT16));
        randrp->panning = oldPanning;
        return FALSE;
    }
}

/*
 * Compatibility with XF86VidMode's gamma changer.  This necessarily clobbers
 * any per-crtc setup.  You asked for it...
 */

static void
gamma_to_ramp(float gamma, CARD16 *ramp, int size)
{
    int i;

    for (i = 0; i < size; i++) {
        if (gamma == 1.0)
            ramp[i] = i | i << 8;
        else
            ramp[i] =
                (CARD16) (pow((double) i / (double) (size - 1), 1. / gamma)
                          * (double) (size - 1) * 257);
    }
}

static int
xf86RandR12ChangeGamma(ScrnInfoPtr pScrn, Gamma gamma)
{
    CARD16 *points, *red, *green, *blue;
    RRCrtcPtr crtc = xf86CompatRRCrtc(pScrn);
    int size;

    if (!crtc)
        return Success;

    size = max(0, crtc->gammaSize);
    if (!size)
        return Success;

    points = calloc(size, 3 * sizeof(CARD16));
    if (!points)
        return BadAlloc;

    red = points;
    green = points + size;
    blue = points + 2 * size;

    gamma_to_ramp(gamma.red, red, size);
    gamma_to_ramp(gamma.green, green, size);
    gamma_to_ramp(gamma.blue, blue, size);
    RRCrtcGammaSet(crtc, red, green, blue);

    free(points);

    pScrn->gamma = gamma;

    return Success;
}

static Bool
xf86RandR12EnterVT(ScrnInfoPtr pScrn)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);
    rrScrPrivPtr rp = rrGetScrPriv(pScreen);
    Bool ret;
    int i;

    if (randrp->orig_EnterVT) {
        pScrn->EnterVT = randrp->orig_EnterVT;
        ret = pScrn->EnterVT(pScrn);
        randrp->orig_EnterVT = pScrn->EnterVT;
        pScrn->EnterVT = xf86RandR12EnterVT;
        if (!ret)
            return FALSE;
    }

    /* reload gamma */
    for (i = 0; i < rp->numCrtcs; i++)
        xf86RandR12CrtcSetGamma(pScreen, rp->crtcs[i]);

    return RRGetInfo(pScreen, TRUE);    /* force a re-probe of outputs and notify clients about changes */
}

static void
xf86DetachOutputGPU(ScreenPtr pScreen)
{
    rrScrPrivPtr rp = rrGetScrPriv(pScreen);
    int i;

    /* make sure there are no attached shared scanout pixmaps first */
    for (i = 0; i < rp->numCrtcs; i++)
        RRCrtcDetachScanoutPixmap(rp->crtcs[i]);

    DetachOutputGPU(pScreen);
}

static Bool
xf86RandR14ProviderSetOutputSource(ScreenPtr pScreen,
                                   RRProviderPtr provider,
                                   RRProviderPtr source_provider)
{
    if (!source_provider) {
        if (provider->output_source) {
            ScreenPtr cmScreen = pScreen->current_master;

            xf86DetachOutputGPU(pScreen);
            AttachUnboundGPU(cmScreen, pScreen);
        }
        provider->output_source = NULL;
        return TRUE;
    }

    if (provider->output_source == source_provider)
        return TRUE;

    SetRootClip(source_provider->pScreen, ROOT_CLIP_NONE);

    DetachUnboundGPU(pScreen);
    AttachOutputGPU(source_provider->pScreen, pScreen);

    provider->output_source = source_provider;
    SetRootClip(source_provider->pScreen, ROOT_CLIP_FULL);
    return TRUE;
}

static Bool
xf86RandR14ProviderSetOffloadSink(ScreenPtr pScreen,
                                  RRProviderPtr provider,
                                  RRProviderPtr sink_provider)
{
    if (!sink_provider) {
        if (provider->offload_sink) {
            ScreenPtr cmScreen = pScreen->current_master;
            xf86DetachOutputGPU(pScreen);
            AttachUnboundGPU(cmScreen, pScreen);
        }

        provider->offload_sink = NULL;
        return TRUE;
    }

    if (provider->offload_sink == sink_provider)
        return TRUE;

    DetachUnboundGPU(pScreen);
    AttachOffloadGPU(sink_provider->pScreen, pScreen);

    provider->offload_sink = sink_provider;
    return TRUE;
}

static Bool
xf86RandR14ProviderSetProperty(ScreenPtr pScreen,
                             RRProviderPtr randr_provider,
                             Atom property, RRPropertyValuePtr value)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);

    /* If we don't have any property handler, then we don't care what the
     * user is setting properties to.
     */
    if (config->provider_funcs->set_property == NULL)
        return TRUE;

    /*
     * This function gets called even when vtSema is FALSE, as
     * drivers will need to remember the correct value to apply
     * when the VT switch occurs
     */
    return config->provider_funcs->set_property(pScrn, property, value);
}

static Bool
xf86RandR14ProviderGetProperty(ScreenPtr pScreen,
                               RRProviderPtr randr_provider, Atom property)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);

    if (config->provider_funcs->get_property == NULL)
        return TRUE;

    /* Should be safe even w/o vtSema */
    return config->provider_funcs->get_property(pScrn, property);
}

static Bool
xf86CrtcSetScanoutPixmap(RRCrtcPtr randr_crtc, PixmapPtr pixmap)
{
    xf86CrtcPtr crtc = randr_crtc->devPrivate;
    if (!crtc->funcs->set_scanout_pixmap)
        return FALSE;
    return crtc->funcs->set_scanout_pixmap(crtc, pixmap);
}

static void
xf86RandR13ConstrainCursorHarder(DeviceIntPtr dev, ScreenPtr screen, int mode, int *x, int *y)
{
    XF86RandRInfoPtr randrp = XF86RANDRINFO(screen);

    if (randrp->panning)
        return;

    if (randrp->orig_ConstrainCursorHarder) {
        screen->ConstrainCursorHarder = randrp->orig_ConstrainCursorHarder;
        screen->ConstrainCursorHarder(dev, screen, mode, x, y);
        screen->ConstrainCursorHarder = xf86RandR13ConstrainCursorHarder;
    }
}

static void
xf86RandR14ProviderDestroy(ScreenPtr screen, RRProviderPtr provider)
{
    ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);

    if (config->randr_provider == provider) {
        if (config->randr_provider->offload_sink) {
            DetachOffloadGPU(screen);
            config->randr_provider->offload_sink = NULL;
            RRSetChanged(screen);
        }
        else if (config->randr_provider->output_source) {
            xf86DetachOutputGPU(screen);
            config->randr_provider->output_source = NULL;
            RRSetChanged(screen);
        }
        else if (screen->current_master)
            DetachUnboundGPU(screen);
    }
    config->randr_provider = NULL;
}

static Bool
xf86RandR12Init12(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    rrScrPrivPtr rp = rrGetScrPriv(pScreen);
    XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);
    int i;

    rp->rrGetInfo = xf86RandR12GetInfo12;
    rp->rrScreenSetSize = xf86RandR12ScreenSetSize;
    rp->rrCrtcSet = xf86RandR12CrtcSet;
    rp->rrCrtcSetGamma = xf86RandR12CrtcSetGamma;
    rp->rrCrtcGetGamma = xf86RandR12CrtcGetGamma;
    rp->rrOutputSetProperty = xf86RandR12OutputSetProperty;
    rp->rrOutputValidateMode = xf86RandR12OutputValidateMode;
#if RANDR_13_INTERFACE
    rp->rrOutputGetProperty = xf86RandR13OutputGetProperty;
    rp->rrGetPanning = xf86RandR13GetPanning;
    rp->rrSetPanning = xf86RandR13SetPanning;
#endif
    rp->rrModeDestroy = xf86RandR12ModeDestroy;
    rp->rrSetConfig = NULL;

    rp->rrProviderSetOutputSource = xf86RandR14ProviderSetOutputSource;
    rp->rrProviderSetOffloadSink = xf86RandR14ProviderSetOffloadSink;

    rp->rrProviderSetProperty = xf86RandR14ProviderSetProperty;
    rp->rrProviderGetProperty = xf86RandR14ProviderGetProperty;
    rp->rrCrtcSetScanoutPixmap = xf86CrtcSetScanoutPixmap;
    rp->rrProviderDestroy = xf86RandR14ProviderDestroy;

    pScrn->PointerMoved = xf86RandR12PointerMoved;
    pScrn->ChangeGamma = xf86RandR12ChangeGamma;

    randrp->orig_EnterVT = pScrn->EnterVT;
    pScrn->EnterVT = xf86RandR12EnterVT;

    randrp->panning = FALSE;
    randrp->orig_ConstrainCursorHarder = pScreen->ConstrainCursorHarder;
    pScreen->ConstrainCursorHarder = xf86RandR13ConstrainCursorHarder;

    if (!xf86RandR12CreateObjects12(pScreen))
        return FALSE;

    /*
     * Configure output modes
     */
    if (!xf86RandR12SetInfo12(pScreen))
        return FALSE;
    for (i = 0; i < rp->numCrtcs; i++) {
        xf86RandR12CrtcGetGamma(pScreen, rp->crtcs[i]);
    }
    return TRUE;
}

#endif

Bool
xf86RandR12PreInit(ScrnInfoPtr pScrn)
{
    return TRUE;
}
@


1.17
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d1057 1
a1057 1
    randr_outputs = malloc(config->num_output * sizeof(RROutputPtr));
d1149 1
a1149 1
    save_crtcs = malloc(config->num_output * sizeof(xf86CrtcPtr));
d1254 2
a1255 3
        tmp_ptr =
            realloc(crtc->gamma_red,
                    3 * randr_crtc->gammaSize * sizeof(CARD16));
d1296 2
a1297 3
        tmp_ptr =
            realloc(randr_crtc->gammaRed,
                    3 * crtc->gamma_size * sizeof(CARD16));
d1391 1
a1391 1
        rrmodes = malloc(nmode * sizeof(RRModePtr));
d1446 2
a1447 2
    clones = malloc(config->num_output * sizeof(RROutputPtr));
    crtcs = malloc(config->num_crtc * sizeof(RRCrtcPtr));
d1561 64
d1640 2
d1852 1
a1852 1
    SetRootClip(source_provider->pScreen, FALSE);
d1858 1
a1858 1
    SetRootClip(source_provider->pScreen, TRUE);
@


1.16
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d686 3
a688 5
    if (xf86RandR12Key) {
        if (randrp->virtualX == -1 || randrp->virtualY == -1) {
            randrp->virtualX = pScrn->virtualX;
            randrp->virtualY = pScrn->virtualY;
        }
d731 1
a731 1
    if (xf86RandR12Key && pScreen->root && ret)
a826 3

    if (xf86RandR12Key == NULL)
        return TRUE;
@


1.15
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1076 1
a1076 1
             * We make copies of modes, so pointer equality 
d1894 1
a1894 1
    
@


1.14
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a456 1
    int refresh0 = 60;
a480 2
        if (mode == scrp->modes)
            refresh0 = refresh;
a683 1
    Bool panning = FALSE;
a714 1
	    panning = TRUE;
a944 2
    XF86RandRInfoPtr randrp;

a953 1
    randrp = XF86RANDRINFO(pScreen);
a1205 1
            RRTransformPtr transform = RRCrtcGetTransform(randr_crtc);
d1260 2
a1261 1
            realloc(crtc->gamma_red, 3 * crtc->gamma_size * sizeof(CARD16));
d1265 2
a1266 2
        crtc->gamma_green = crtc->gamma_red + crtc->gamma_size;
        crtc->gamma_blue = crtc->gamma_green + crtc->gamma_size;
a1450 1
    RRCrtcPtr randr_crtc;
a1461 5

        if (output->crtc)
            randr_crtc = output->crtc->randr_crtc;
        else
            randr_crtc = NULL;
@


1.13
log
@Update to xserver 1.14.5
@
text
@d34 1
@


1.12
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d1774 13
d1796 1
a1796 1
            DetachOutputGPU(pScreen);
d1824 1
a1824 1
            DetachOutputGPU(pScreen);
d1912 1
d1915 1
a1915 1
            DetachOutputGPU(screen);
d1917 1
@


1.11
log
@backport (whitespace changes only) a fix for panning that also effected scale
to permit:
   xrandr --output LVDS1 --mode 1280x800 --panning 1380x1024 --scale 1.8x1.8
to behave properly.
based on upstream commit 1bf81af4a6be1113bcc3b940ab264d5c9e0f0c5d that is in
the 1.14 xserver that is not ready for OpenBSD yet
ok matthieu@@
@
text
@d453 1
a453 1
    ScrnInfoPtr scrp = XF86SCRNINFO(pScreen);
d510 1
a510 1
    ScrnInfoPtr scrp = XF86SCRNINFO(pScreen);
d521 1
a521 1
        (*scrp->EnableDisableFBAccess) (pScreen->myNum, FALSE);
d574 1
a574 1
        (*scrp->EnableDisableFBAccess) (pScreen->myNum, TRUE);
d582 1
a582 1
    ScrnInfoPtr scrp = XF86SCRNINFO(pScreen);
d681 1
a681 1
    ScrnInfoPtr pScrn = XF86SCRNINFO(pScreen);
d696 1
a696 1
        (*pScrn->EnableDisableFBAccess) (pScreen->myNum, FALSE);
d735 1
a735 1
        (*pScrn->EnableDisableFBAccess) (pScreen->myNum, TRUE);
d754 1
a754 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d914 1
a914 1
    xf86Screens[pScreen->myNum]->EnterVT = randrp->orig_EnterVT;
d927 1
a927 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d952 1
a952 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d973 1
a973 1
    ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
d1054 1
a1054 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1149 1
a1149 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1170 3
d1233 1
a1233 1
            crtc->desiredMode = mode;
d1235 1
d1367 1
a1367 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1452 1
a1452 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1528 1
a1528 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1540 1
a1540 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1570 8
d1585 1
a1585 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1607 1
a1607 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1622 1
a1622 1
xf86RandR12PointerMoved(int scrnIndex, int x, int y)
d1624 1
a1624 2
    ScreenPtr pScreen = screenInfo.screens[scrnIndex];
    ScrnInfoPtr pScrn = XF86SCRNINFO(pScreen);
d1707 1
a1707 1
            ramp[i] = i << 8;
d1711 1
a1711 1
                          * (double) (size - 1) * 256);
d1716 1
a1716 1
xf86RandR12ChangeGamma(int scrnIndex, Gamma gamma)
a1718 1
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d1750 1
a1750 1
xf86RandR12EnterVT(int screen_index, int flags)
d1752 1
a1752 2
    ScreenPtr pScreen = screenInfo.screens[screen_index];
    ScrnInfoPtr pScrn = xf86Screens[screen_index];
d1760 1
a1760 1
        ret = pScrn->EnterVT(screen_index, flags);
d1774 100
d1889 21
d1913 1
a1913 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1932 9
@


1.10
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d63 3
d671 4
d686 1
d707 1
a707 2
        if (crtc->panningTotalArea.x2 > crtc->panningTotalArea.x1 ||
            crtc->panningTotalArea.y2 > crtc->panningTotalArea.y1) {
d718 1
d915 1
d1226 1
d1653 1
d1671 1
d1679 1
d1765 15
d1807 4
@


1.9
log
@Update to xserver 1.11.2
@
text
@d46 10
a55 10
    int				    virtualX;
    int				    virtualY;
    int				    mmWidth;
    int				    mmHeight;
    int				    maxX;
    int				    maxY;
    int				    pointerX;
    int				    pointerY;
    Rotation			    rotation; /* current mode */
    Rotation                        supported_rotations; /* driver supported */
d66 2
a67 2
static Bool xf86RandR12Init12 (ScreenPtr pScreen);
static Bool xf86RandR12CreateScreenResources12 (ScreenPtr pScreen);
d74 1
a77 1

d79 1
a79 1
xf86RandR12ModeRefresh (DisplayModePtr mode)
d82 1
a82 1
	return (int) (mode->VRefresh + 0.5);
d84 1
a84 1
	return (int) (mode->Clock * 1000.0 / mode->HTotal / mode->VTotal + 0.5);
d89 2
a90 1
xf86RandR13VerifyPanningArea (xf86CrtcPtr crtc, int screenWidth, int screenHeight)
d95 1
a95 1
	return FALSE;
d98 38
a135 33
	/* Panning in X is disabled */
	if (crtc->panningTotalArea.x1 || crtc->panningTotalArea.x2)
	    /* Illegal configuration -> fail/disable */
	    ret = FALSE;
	crtc->panningTotalArea.x1    = crtc->panningTotalArea.x2    = 0;
	crtc->panningTrackingArea.x1 = crtc->panningTrackingArea.x2 = 0;
	crtc->panningBorder[0]       = crtc->panningBorder[2]       = 0;
    } else {
	/* Panning in X is enabled */
	if (crtc->panningTotalArea.x1 < 0) {
	    /* Panning region outside screen -> move inside */
	    crtc->panningTotalArea.x2 -= crtc->panningTotalArea.x1;
	    crtc->panningTotalArea.x1 = 0;
	    ret = FALSE;
	}
	if (crtc->panningTotalArea.x2 < crtc->panningTotalArea.x1 + crtc->mode.HDisplay) {
	    /* Panning region smaller than displayed area -> crop to displayed area */
	    crtc->panningTotalArea.x2 = crtc->panningTotalArea.x1 + crtc->mode.HDisplay;
	    ret = FALSE;
	}
	if (crtc->panningTotalArea.x2 > screenWidth) {
	    /* Panning region larger than screen -> move inside, then crop to screen */
	    crtc->panningTotalArea.x1 -= crtc->panningTotalArea.x2 - screenWidth;
	    crtc->panningTotalArea.x2 = screenWidth;
	    ret = FALSE;
	    if (crtc->panningTotalArea.x1 < 0)
		crtc->panningTotalArea.x1 = 0;
	}
	if (crtc->panningBorder[0] + crtc->panningBorder[2] > crtc->mode.HDisplay) {
	    /* Borders too large -> set to 0 */
	    crtc->panningBorder[0] = crtc->panningBorder[2] = 0;
	    ret = FALSE;
	}
d139 38
a176 33
	/* Panning in Y is disabled */
	if (crtc->panningTotalArea.y1 || crtc->panningTotalArea.y2)
	    /* Illegal configuration -> fail/disable */
	    ret = FALSE;
	crtc->panningTotalArea.y1    = crtc->panningTotalArea.y2    = 0;
	crtc->panningTrackingArea.y1 = crtc->panningTrackingArea.y2 = 0;
	crtc->panningBorder[1]       = crtc->panningBorder[3]       = 0;
    } else {
	/* Panning in Y is enabled */
	if (crtc->panningTotalArea.y1 < 0) {
	    /* Panning region outside screen -> move inside */
	    crtc->panningTotalArea.y2 -= crtc->panningTotalArea.y1;
	    crtc->panningTotalArea.y1 = 0;
	    ret = FALSE;
	}
	if (crtc->panningTotalArea.y2 < crtc->panningTotalArea.y1 + crtc->mode.VDisplay) {
	    /* Panning region smaller than displayed area -> crop to displayed area */
	    crtc->panningTotalArea.y2 = crtc->panningTotalArea.y1 + crtc->mode.VDisplay;
	    ret = FALSE;
	}
	if (crtc->panningTotalArea.y2 > screenHeight) {
	    /* Panning region larger than screen -> move inside, then crop to screen */
	    crtc->panningTotalArea.y1 -= crtc->panningTotalArea.y2 - screenHeight;
	    crtc->panningTotalArea.y2 = screenHeight;
	    ret = FALSE;
	    if (crtc->panningTotalArea.y1 < 0)
		crtc->panningTotalArea.y1 = 0;
	}
	if (crtc->panningBorder[1] + crtc->panningBorder[3] > crtc->mode.VDisplay) {
	    /* Borders too large -> set to 0 */
	    crtc->panningBorder[1] = crtc->panningBorder[3] = 0;
	    ret = FALSE;
	}
d193 5
a197 6
xf86ComputeCrtcPan (Bool transform_in_use,
		    struct pixman_f_transform *m,
		    double screen_x, double screen_y,
		    double crtc_x, double crtc_y,
		    int old_pan_x, int old_pan_y,
		    int *new_pan_x, int *new_pan_y)
d200 135
a334 133
	/*
	 * Given the current transform, M, the current position
	 * on the Screen, S, and the desired position on the CRTC,
	 * C, compute a translation, T, such that:
	 *
	 * M T S = C
	 *
	 * where T is of the form
	 *
	 * | 1 0 dx |
	 * | 0 1 dy |
	 * | 0 0 1  |
	 *
	 * M T S =
	 *   | M00 Sx + M01 Sy + M00 dx + M01 dy + M02 |   | Cx F |
	 *   | M10 Sx + M11 Sy + M10 dx + M11 dy + M12 | = | Cy F |
	 *   | M20 Sx + M21 Sy + M20 dx + M21 dy + M22 |   |  F   |
	 *
	 * R = M S
	 *
	 *   Cx F = M00 dx + M01 dy + R0
	 *   Cy F = M10 dx + M11 dy + R1
	 *      F = M20 dx + M21 dy + R2
	 *
	 * Zero out dx, then dy
	 *
	 * F (Cx M10 - Cy M00) =
	 *	    (M10 M01 - M00 M11) dy + M10 R0 - M00 R1
	 * F (M10 - Cy M20) =
	 *	    (M10 M21 - M20 M11) dy + M10 R2 - M20 R1
	 *
	 * F (Cx M11 - Cy M01) =
	 *	    (M11 M00 - M01 M10) dx + M11 R0 - M01 R1
	 * F (M11 - Cy M21) =
	 *	    (M11 M20 - M21 M10) dx + M11 R2 - M21 R1
	 *
	 * Make some temporaries
	 *
	 * T = | Cx M10 - Cy M00 |
	 *     | Cx M11 - Cy M01 |
	 *
	 * U = | M10 M01 - M00 M11 |
	 *     | M11 M00 - M01 M10 |
	 *
	 * Q = | M10 R0 - M00 R1 |
	 *     | M11 R0 - M01 R1 |
	 *
	 * P = | M10 - Cy M20 |
	 *     | M11 - Cy M21 |
	 *
	 * W = | M10 M21 - M20 M11 |
	 *     | M11 M20 - M21 M10 |
	 *
	 * V = | M10 R2 - M20 R1 |
	 *	   | M11 R2 - M21 R1 |
	 *
	 * Rewrite:
	 *
	 * F T0 = U0 dy + Q0
	 * F P0 = W0 dy + V0
	 * F T1 = U1 dx + Q1
	 * F P1 = W1 dx + V1
	 *
	 * Solve for F (two ways)
	 *
	 * F (W0 T0 - U0 P0)  = W0 Q0 - U0 V0
	 *
	 *     W0 Q0 - U0 V0
	 * F = -------------
	 *     W0 T0 - U0 P0
	 *
	 * F (W1 T1 - U1 P1) = W1 Q1 - U1 V1
	 *
	 *     W1 Q1 - U1 V1
	 * F = -------------
	 *     W1 T1 - U1 P1
	 *
	 * We'll use which ever solution works (denominator != 0)
	 *
	 * Finally, solve for dx and dy:
	 *
	 * dx = (F T1 - Q1) / U1
	 * dx = (F P1 - V1) / W1
	 *
	 * dy = (F T0 - Q0) / U0
	 * dy = (F P0 - V0) / W0
	 */
	double			    r[3];
	double			    q[2], u[2], t[2], v[2], w[2], p[2];
	double			    f;
	struct pict_f_vector	    d;
	int			    i;

	/* Get the un-normalized crtc coordinates again */
	for (i = 0; i < 3; i++)
	    r[i] = m->m[i][0] * screen_x + m->m[i][1] * screen_y + m->m[i][2];

	/* Combine values into temporaries */
	for (i = 0; i < 2; i++) {
	    q[i] = m->m[1][i] * r[0] - m->m[0][i] * r[1];
	    u[i] = m->m[1][i] * m->m[0][1-i] - m->m[0][i] * m->m[1][1-i];
	    t[i] = m->m[1][i] * crtc_x - m->m[0][i] * crtc_y;

	    v[i] = m->m[1][i] * r[2] - m->m[2][i] * r[1];
	    w[i] = m->m[1][i] * m->m[2][1-i] - m->m[2][i] * m->m[1][1-i];
	    p[i] = m->m[1][i] - m->m[2][i] * crtc_y;
	}

	/* Find a way to compute f */
	f = 0;
	for (i = 0; i < 2; i++) {
	    double a = w[i] * q[i] - u[i] * v[i];
	    double b = w[i] * t[i] - u[i] * p[i];
	    if (b != 0) {
		f = a/b;
		break;
	    }
	}

	/* Solve for the resulting transform vector */
	for (i = 0; i < 2; i++) {
	    if (u[i])
		d.v[1-i] = (t[i] * f - q[i]) / u[i];
	    else if (w[1])
		d.v[1-i] = (p[i] * f - v[i]) / w[i];
	    else
		d.v[1-i] = 0;
	}
	*new_pan_x = old_pan_x - floor (d.v[0] + 0.5);
	*new_pan_y = old_pan_y - floor (d.v[1] + 0.5);
    } else {
	*new_pan_x = screen_x - crtc_x;
	*new_pan_y = screen_y - crtc_y;
d339 1
a339 1
xf86RandR13Pan (xf86CrtcPtr crtc, int x, int y)
d346 1
a346 1
	return;
d348 8
a355 8
    if (! crtc->enabled						||
	(crtc->panningTotalArea.x2 <= crtc->panningTotalArea.x1	&&
	 crtc->panningTotalArea.y2 <= crtc->panningTotalArea.y1))
	return;

    newX   = crtc->x;
    newY   = crtc->y;
    width  = crtc->mode.HDisplay;
d359 60
a418 61
	 (x >= crtc->panningTrackingArea.x1 && x < crtc->panningTrackingArea.x2)) &&
	(crtc->panningTrackingArea.y2 <= crtc->panningTrackingArea.y1 ||
	 (y >= crtc->panningTrackingArea.y1 && y < crtc->panningTrackingArea.y2)))
    {
	struct pict_f_vector    c;

	/*
	 * Pre-clip the mouse position to the panning area so that we don't
	 * push the crtc outside. This doesn't deal with changes to the
	 * panning values, only mouse position changes.
	 */
	if (crtc->panningTotalArea.x2 > crtc->panningTotalArea.x1)
	{
	    if (x < crtc->panningTotalArea.x1)
		x = crtc->panningTotalArea.x1;
	    if (x >= crtc->panningTotalArea.x2)
		x = crtc->panningTotalArea.x2 - 1;
	}
	if (crtc->panningTotalArea.y2 > crtc->panningTotalArea.y1)
	{
	    if (y < crtc->panningTotalArea.y1)
		y = crtc->panningTotalArea.y1;
	    if (y >= crtc->panningTotalArea.y2)
		y = crtc->panningTotalArea.y2 - 1;
	}

	c.v[0] = x;
	c.v[1] = y;
	c.v[2] = 1.0;
	if (crtc->transform_in_use) {
	    pixman_f_transform_point(&crtc->f_framebuffer_to_crtc, &c);
	} else {
	    c.v[0] -= crtc->x;
	    c.v[1] -= crtc->y;
	}

	if (crtc->panningTotalArea.x2 > crtc->panningTotalArea.x1) {
	    if (c.v[0] < crtc->panningBorder[0]) {
		c.v[0] = crtc->panningBorder[0];
		panned = TRUE;
	    }
	    if (c.v[0] >= width - crtc->panningBorder[2]) {
		c.v[0] = width - crtc->panningBorder[2] - 1;
		panned = TRUE;
	    }
	}
	if (crtc->panningTotalArea.y2 > crtc->panningTotalArea.y1) {
	    if (c.v[1] < crtc->panningBorder[1]) {
		c.v[1] = crtc->panningBorder[1];
		panned = TRUE;
	    }
	    if (c.v[1] >= height - crtc->panningBorder[3]) {
		c.v[1] = height - crtc->panningBorder[3] - 1;
		panned = TRUE;
	    }
	}
	if (panned)
	    xf86ComputeCrtcPan (crtc->transform_in_use,
				&crtc->f_framebuffer_to_crtc,
				x, y, c.v[0], c.v[1],
				newX, newY, &newX, &newY);
d427 14
a440 15
    if (!crtc->transform_in_use)
    {
	/* Validate against [xy]1 after [xy]2, to be sure that results are > 0 for [xy]1 > 0 */
	if (crtc->panningTotalArea.x2 > crtc->panningTotalArea.x1) {
	    if (newX > crtc->panningTotalArea.x2 - width)
		newX =  crtc->panningTotalArea.x2 - width;
	    if (newX <  crtc->panningTotalArea.x1)
		newX =  crtc->panningTotalArea.x1;
	}
	if (crtc->panningTotalArea.y2 > crtc->panningTotalArea.y1) {
	    if (newY > crtc->panningTotalArea.y2 - height)
		newY =  crtc->panningTotalArea.y2 - height;
	    if (newY <  crtc->panningTotalArea.y1)
		newY =  crtc->panningTotalArea.y1;
	}
d443 1
a443 1
	xf86CrtcSetOrigin (crtc, newX, newY);
d447 1
a447 1
xf86RandR12GetInfo (ScreenPtr pScreen, Rotation *rotations)
d449 6
a454 6
    RRScreenSizePtr	    pSize;
    ScrnInfoPtr		    scrp = XF86SCRNINFO(pScreen);
    XF86RandRInfoPtr	    randrp = XF86RANDRINFO(pScreen);
    DisplayModePtr	    mode;
    int			    refresh0 = 60;
    int			    maxX = 0, maxY = 0;
d458 3
a460 4
    if (randrp->virtualX == -1 || randrp->virtualY == -1)
    {
	randrp->virtualX = scrp->virtualX;
	randrp->virtualY = scrp->virtualY;
d464 33
a496 37
    if (scrp->vtSema)
    {
	xf86ProbeOutputModes (scrp, 0, 0);
	xf86SetScrnInfoModes (scrp);
    }

    for (mode = scrp->modes; ; mode = mode->next)
    {
	int refresh = xf86RandR12ModeRefresh (mode);
	if (randrp->maxX == 0 || randrp->maxY == 0)
	{
		if (maxX < mode->HDisplay)
			maxX = mode->HDisplay;
		if (maxY < mode->VDisplay)
			maxY = mode->VDisplay;
	}
	if (mode == scrp->modes)
	    refresh0 = refresh;
	pSize = RRRegisterSize (pScreen,
				mode->HDisplay, mode->VDisplay,
				randrp->mmWidth, randrp->mmHeight);
	if (!pSize)
	    return FALSE;
	RRRegisterRate (pScreen, pSize, refresh);

	if (xf86ModesEqual(mode, scrp->currentMode))
	{
	    RRSetCurrentConfig (pScreen, randrp->rotation, refresh, pSize);
	}
	if (mode->next == scrp->modes)
	    break;
    }

    if (randrp->maxX == 0 || randrp->maxY == 0)
    {
	randrp->maxX = maxX;
	randrp->maxY = maxY;
d503 13
a515 15
xf86RandR12SetMode (ScreenPtr	    pScreen,
		  DisplayModePtr    mode,
		  Bool		    useVirtual,
		  int		    mmWidth,
		  int		    mmHeight)
{
    ScrnInfoPtr		scrp = XF86SCRNINFO(pScreen);
    XF86RandRInfoPtr	randrp = XF86RANDRINFO(pScreen);
    int			oldWidth = pScreen->width;
    int			oldHeight = pScreen->height;
    int			oldmmWidth = pScreen->mmWidth;
    int			oldmmHeight = pScreen->mmHeight;
    WindowPtr		pRoot = pScreen->root;
    DisplayModePtr      currentMode = NULL;
    Bool 		ret = TRUE;
d518 22
a539 26
	(*scrp->EnableDisableFBAccess) (pScreen->myNum, FALSE);
    if (useVirtual)
    {
	scrp->virtualX = randrp->virtualX;
	scrp->virtualY = randrp->virtualY;
    }
    else
    {
	scrp->virtualX = mode->HDisplay;
	scrp->virtualY = mode->VDisplay;
    }

    if(randrp->rotation & (RR_Rotate_90 | RR_Rotate_270))
    {
	/* If the screen is rotated 90 or 270 degrees, swap the sizes. */
	pScreen->width = scrp->virtualY;
	pScreen->height = scrp->virtualX;
	pScreen->mmWidth = mmHeight;
	pScreen->mmHeight = mmWidth;
    }
    else
    {
	pScreen->width = scrp->virtualX;
	pScreen->height = scrp->virtualY;
	pScreen->mmWidth = mmWidth;
	pScreen->mmHeight = mmHeight;
d551 1
a551 2
    if (!xf86SwitchMode (pScreen, mode))
    {
d553 4
a556 4
	scrp->virtualX = pScreen->width = oldWidth;
	scrp->virtualY = pScreen->height = oldHeight;
	pScreen->mmWidth = oldmmWidth;
	pScreen->mmHeight = oldmmHeight;
d568 2
a569 2
    xf86SetViewport (pScreen, pScreen->width, pScreen->height);
    xf86SetViewport (pScreen, 0, 0);
d571 1
a571 1
	(*scrp->EnableDisableFBAccess) (pScreen->myNum, TRUE);
d576 12
a587 14
xf86RandR12SetConfig (ScreenPtr		pScreen,
		    Rotation		rotation,
		    int			rate,
		    RRScreenSizePtr	pSize)
{
    ScrnInfoPtr		scrp = XF86SCRNINFO(pScreen);
    XF86RandRInfoPtr	randrp = XF86RANDRINFO(pScreen);
    DisplayModePtr	mode;
    int			pos[MAXDEVICES][2];
    Bool		useVirtual = FALSE;
    int			maxX = 0, maxY = 0;
    Rotation		oldRotation = randrp->rotation;
    DeviceIntPtr	dev;
    Bool		view_adjusted = FALSE;
d591 41
a631 49
    if (randrp->virtualX == -1 || randrp->virtualY == -1)
    {
	randrp->virtualX = scrp->virtualX;
	randrp->virtualY = scrp->virtualY;
    }

    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
	if (!IsMaster(dev) && !IsFloating(dev))
		continue;

	miPointerGetPosition(dev, &pos[dev->id][0], &pos[dev->id][1]);
    }

    for (mode = scrp->modes; ; mode = mode->next)
    {
	if (randrp->maxX == 0 || randrp->maxY == 0)
	{
		if (maxX < mode->HDisplay)
			maxX = mode->HDisplay;
		if (maxY < mode->VDisplay)
			maxY = mode->VDisplay;
	}
	if (mode->HDisplay == pSize->width &&
	    mode->VDisplay == pSize->height &&
	    (rate == 0 || xf86RandR12ModeRefresh (mode) == rate))
	    break;
	if (mode->next == scrp->modes)
	{
	    if (pSize->width == randrp->virtualX &&
		pSize->height == randrp->virtualY)
	    {
		mode = scrp->modes;
		useVirtual = TRUE;
		break;
	    }
    	    if (randrp->maxX == 0 || randrp->maxY == 0)
    	    {
		randrp->maxX = maxX;
		randrp->maxY = maxY;
    	    }
	    return FALSE;
	}
    }

    if (randrp->maxX == 0 || randrp->maxY == 0)
    {
	randrp->maxX = maxX;
	randrp->maxY = maxY;
d634 2
a635 2
    if (!xf86RandR12SetMode (pScreen, mode, useVirtual, pSize->mmWidth,
			   pSize->mmHeight)) {
d637 1
a637 1
	return FALSE;
d644 16
a659 17
    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
	if (!IsMaster(dev) && !IsFloating(dev))
		continue;

	if (pScreen == miPointerGetScreen(dev)) {
	    int px = pos[dev->id][0];
	    int py = pos[dev->id][1];

	    px = (px >= pScreen->width ? (pScreen->width - 1) : px);
	    py = (py >= pScreen->height ? (pScreen->height - 1) : py);

	    /* Setting the viewpoint makes only sense on one device */
	    if (!view_adjusted && IsMaster(dev)) {
		xf86SetViewport(pScreen, px, py);
		view_adjusted = TRUE;
	    }
d661 2
a662 2
	    (*pScreen->SetCursorPosition) (dev, pScreen, px, py, FALSE);
	}
d669 11
a679 13
xf86RandR12ScreenSetSize (ScreenPtr	pScreen,
			CARD16		width,
			CARD16		height,
			CARD32		mmWidth,
			CARD32		mmHeight)
{
    XF86RandRInfoPtr	randrp = XF86RANDRINFO(pScreen);
    ScrnInfoPtr		pScrn = XF86SCRNINFO(pScreen);
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(pScrn);
    WindowPtr		pRoot = pScreen->root;
    PixmapPtr		pScrnPix;
    Bool		ret = FALSE;
    int                 c;
d682 3
a684 4
        if (randrp->virtualX == -1 || randrp->virtualY == -1)
        {
	    randrp->virtualX = pScrn->virtualX;
	    randrp->virtualY = pScrn->virtualY;
d688 1
a688 1
	(*pScrn->EnableDisableFBAccess) (pScreen->myNum, FALSE);
d691 2
a692 2
    if (!(*config->funcs->resize)(pScrn, width, height))
	goto finish;
d697 15
a711 14
	xf86CrtcPtr crtc = config->crtc[c];
	if (crtc->panningTotalArea.x2 > crtc->panningTotalArea.x1 ||
	    crtc->panningTotalArea.y2 > crtc->panningTotalArea.y1) {
	    if (crtc->panningTotalArea.x2 > crtc->panningTrackingArea.x1)
		crtc->panningTotalArea.x2 += width  - pScreen->width;
	    if (crtc->panningTotalArea.y2 > crtc->panningTrackingArea.y1)
		crtc->panningTotalArea.y2 += height - pScreen->height;
	    if (crtc->panningTrackingArea.x2 > crtc->panningTrackingArea.x1)
		crtc->panningTrackingArea.x2 += width  - pScreen->width;
	    if (crtc->panningTrackingArea.y2 > crtc->panningTrackingArea.y1)
		crtc->panningTrackingArea.y2 += height - pScreen->height;
	    xf86RandR13VerifyPanningArea (crtc, width, height);
	    xf86RandR13Pan (crtc, randrp->pointerX, randrp->pointerY);
	}
d714 1
a714 1
    pScrnPix = (*pScreen->GetScreenPixmap)(pScreen);
d720 5
a724 2
    xf86SetViewport (pScreen, pScreen->width-1, pScreen->height-1);
    xf86SetViewport (pScreen, 0, 0);
a725 1
finish:
d727 1
a727 1
	(*pScrn->EnableDisableFBAccess) (pScreen->myNum, TRUE);
d730 1
a730 1
	RRScreenSizeNotify (pScreen);
d738 1
a738 1
    XF86RandRInfoPtr	    randrp = XF86RANDRINFO(pScreen);
d744 1
a744 1
xf86RandR12CreateScreenResources (ScreenPtr pScreen)
d746 7
a752 6
    ScrnInfoPtr		pScrn = xf86Screens[pScreen->myNum];
    xf86CrtcConfigPtr   config;
    XF86RandRInfoPtr	randrp;
    int			c;
    int			width, height;
    int			mmWidth, mmHeight;
d756 1
a756 1
	return TRUE;
d764 60
a823 69
    width = 0; height = 0;
    for (c = 0; c < config->num_crtc; c++)
    {
	xf86CrtcPtr crtc = config->crtc[c];
	int	    crtc_width = crtc->x + xf86ModeWidth (&crtc->mode, crtc->rotation);
	int	    crtc_height = crtc->y + xf86ModeHeight (&crtc->mode, crtc->rotation);
	
	if (crtc->enabled) {
	    if (crtc_width > width)
		width = crtc_width;
	    if (crtc_height > height)
		height = crtc_height;
	    if (crtc->panningTotalArea.x2 > width)
		width = crtc->panningTotalArea.x2;
	    if (crtc->panningTotalArea.y2 > height)
		height = crtc->panningTotalArea.y2;
	}
    }
    
    if (width && height)
    {
	/*
	 * Compute physical size of screen
	 */
	if (monitorResolution) 
	{
	    mmWidth = width * 25.4 / monitorResolution;
	    mmHeight = height * 25.4 / monitorResolution;
	}
	else
	{
	    xf86OutputPtr   output = xf86CompatOutput(pScrn);

	    if (output &&
		output->conf_monitor &&
		(output->conf_monitor->mon_width  > 0 &&
		 output->conf_monitor->mon_height > 0))
	    {
		/*
		 * Prefer user configured DisplaySize
		 */
		mmWidth = output->conf_monitor->mon_width;
		mmHeight = output->conf_monitor->mon_height;
	    }
	    else
	    {
		/*
		 * Otherwise, just set the screen to DEFAULT_DPI
		 */
		mmWidth = width * 25.4 / DEFAULT_DPI;
		mmHeight = height * 25.4 / DEFAULT_DPI;
	    }
	}
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Setting screen physical size to %d x %d\n",
		   mmWidth, mmHeight);
	/*
	 * This is the initial setting of the screen size.
	 * We have to pre-set it here, otherwise panning would be adapted
	 * to the new screen size.
	 */
	pScreen->width  = width;
	pScreen->height = height;
	xf86RandR12ScreenSetSize (pScreen,
				  width,
				  height,
				  mmWidth,
				  mmHeight);
	xf86ReconfigureLayout();
d827 1
a827 1
	return TRUE;
d829 3
a831 4
    if (randrp->virtualX == -1 || randrp->virtualY == -1)
    {
	randrp->virtualX = pScrn->virtualX;
	randrp->virtualY = pScrn->virtualY;
d833 1
a833 1
    xf86CrtcSetScreenSubpixelOrder (pScreen);
d835 2
a836 2
    if (xf86RandR12CreateScreenResources12 (pScreen))
	return TRUE;
a840 1

d842 1
a842 1
xf86RandR12Init (ScreenPtr pScreen)
d844 2
a845 2
    rrScrPrivPtr	rp;
    XF86RandRInfoPtr	randrp;
d849 1
a849 2
    if (!noPanoramiXExtension)
    {
d858 1
a858 1
	xf86RandR12Generation = serverGeneration;
d862 1
a862 1
	return FALSE;
d864 1
a864 1
    randrp = malloc(sizeof (XF86RandRInfoRec));
d866 1
a866 1
	return FALSE;
d868 3
a870 4
    if (!RRScreenInit(pScreen))
    {
	free(randrp);
	return FALSE;
d881 1
a881 1
    randrp->rotation = RR_Rotate_0; /* initial rotated mode */
d890 2
a891 2
    if (!xf86RandR12Init12 (pScreen))
	return FALSE;
d897 1
a897 1
xf86RandR12CloseScreen (ScreenPtr pScreen)
d899 1
a899 1
    XF86RandRInfoPtr	randrp;
d902 1
a902 1
	return;
d913 1
a913 1
xf86RandR12SetRotations (ScreenPtr pScreen, Rotation rotations)
d915 2
a916 1
    XF86RandRInfoPtr	randrp;
d918 3
a920 3
    ScrnInfoPtr		pScrn = xf86Screens[pScreen->myNum];
    int			c;
    xf86CrtcConfigPtr   config = XF86_CRTC_CONFIG_PTR(pScrn);
d924 1
a924 1
	return;
d929 1
a929 1
	xf86CrtcPtr    crtc = config->crtc[c];
d931 1
a931 1
	RRCrtcSetRotations (crtc->randr_crtc, rotations);
d938 1
a938 1
xf86RandR12SetTransformSupport (ScreenPtr pScreen, Bool transforms)
d940 2
a941 1
    XF86RandRInfoPtr	randrp;
d943 3
a945 3
    ScrnInfoPtr		pScrn = xf86Screens[pScreen->myNum];
    int			c;
    xf86CrtcConfigPtr   config = XF86_CRTC_CONFIG_PTR(pScrn);
d949 1
a949 1
	return;
d954 1
a954 1
	xf86CrtcPtr    crtc = config->crtc[c];
d956 1
a956 1
	RRCrtcSetTransformSupport (crtc->randr_crtc, transforms);
d967 6
a972 6
	XF86RANDRINFO(pScreen)->virtualX == -1)
    {
	*x = pScrn->virtualX;
	*y = pScrn->virtualY;
    } else {
	XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);
d974 2
a975 2
	*x = randrp->virtualX;
	*y = randrp->virtualY;
d997 1
a997 2
xf86RandRModeMatches (RRModePtr		randr_mode,
		      DisplayModePtr	mode)
d1000 8
a1007 6
    if (match_name)
    {
	/* check for same name */
	int	len = strlen (mode->name);
	if (randr_mode->mode.nameLength != len)			return FALSE;
	if (memcmp (randr_mode->name, mode->name, len) != 0)	return FALSE;
d1010 1
a1010 1
    
d1012 21
a1032 11
    if (randr_mode->mode.dotClock / 1000 != mode->Clock)    return FALSE;
    if (randr_mode->mode.width        != mode->HDisplay)    return FALSE;
    if (randr_mode->mode.hSyncStart   != mode->HSyncStart)  return FALSE;
    if (randr_mode->mode.hSyncEnd     != mode->HSyncEnd)    return FALSE;
    if (randr_mode->mode.hTotal       != mode->HTotal)	    return FALSE;
    if (randr_mode->mode.hSkew        != mode->HSkew)	    return FALSE;
    if (randr_mode->mode.height       != mode->VDisplay)    return FALSE;
    if (randr_mode->mode.vSyncStart   != mode->VSyncStart)  return FALSE;
    if (randr_mode->mode.vSyncEnd     != mode->VSyncEnd)    return FALSE;
    if (randr_mode->mode.vTotal       != mode->VTotal)	    return FALSE;
    
d1035 2
a1036 2
	return FALSE;
    
d1042 1
a1042 1
xf86RandR12CrtcNotify (RRCrtcPtr	randr_crtc)
d1044 15
a1058 15
    ScreenPtr		pScreen = randr_crtc->pScreen;
    ScrnInfoPtr		pScrn = xf86Screens[pScreen->myNum];
    xf86CrtcConfigPtr   config = XF86_CRTC_CONFIG_PTR(pScrn);
    RRModePtr		randr_mode = NULL;
    int			x;
    int			y;
    Rotation		rotation;
    int			numOutputs;
    RROutputPtr		*randr_outputs;
    RROutputPtr		randr_output;
    xf86CrtcPtr		crtc = randr_crtc->devPrivate;
    xf86OutputPtr	output;
    int			i, j;
    DisplayModePtr	mode = &crtc->mode;
    Bool		ret;
d1060 1
a1060 1
    randr_outputs = malloc(config->num_output * sizeof (RROutputPtr));
d1062 1
a1062 1
	return FALSE;
d1068 29
a1096 29
    for (i = 0; i < config->num_output; i++)
    {
	output = config->output[i];
	if (output->crtc == crtc)
	{
	    randr_output = output->randr_output;
	    randr_outputs[numOutputs++] = randr_output;
	    /*
	     * We make copies of modes, so pointer equality 
	     * isn't sufficient
	     */
	    for (j = 0; j < randr_output->numModes + randr_output->numUserModes; j++)
	    {
		RRModePtr   m = (j < randr_output->numModes ?
				 randr_output->modes[j] :
				 randr_output->userModes[j-randr_output->numModes]);
					 
		if (xf86RandRModeMatches (m, mode))
		{
		    randr_mode = m;
		    break;
		}
	    }
	}
    }
    ret = RRCrtcNotify (randr_crtc, randr_mode, x, y,
			rotation, 
			crtc->transformPresent ? &crtc->transform : NULL,
			numOutputs, randr_outputs);
d1105 2
a1106 3
xf86RandRModeConvert (ScrnInfoPtr	scrn,
		      RRModePtr		randr_mode,
		      DisplayModePtr	mode)
d1112 1
a1112 1
    
d1118 1
a1118 1
    
d1127 1
a1127 1
    xf86SetModeCrtc (mode, scrn->adjustFlags);
d1131 17
a1147 18
xf86RandR12CrtcSet (ScreenPtr	    pScreen,
		    RRCrtcPtr	    randr_crtc,
		    RRModePtr	    randr_mode,
		    int		    x,
		    int		    y,
		    Rotation	    rotation,
		    int		    num_randr_outputs,
		    RROutputPtr	    *randr_outputs)
{
    XF86RandRInfoPtr	randrp = XF86RANDRINFO(pScreen);
    ScrnInfoPtr		pScrn = xf86Screens[pScreen->myNum];
    xf86CrtcConfigPtr   config = XF86_CRTC_CONFIG_PTR(pScrn);
    xf86CrtcPtr		crtc = randr_crtc->devPrivate;
    RRTransformPtr	transform;
    Bool		changed = FALSE;
    int			o, ro;
    xf86CrtcPtr		*save_crtcs;
    Bool		save_enabled = crtc->enabled;
d1150 1
a1150 1
	return FALSE;
d1152 1
a1152 1
    save_crtcs = malloc(config->num_output * sizeof (xf86CrtcPtr));
d1154 4
a1157 4
	changed = TRUE;
    else if (randr_mode && !xf86RandRModeMatches (randr_mode, &crtc->mode))
	changed = TRUE;
    
d1159 1
a1159 1
	changed = TRUE;
d1161 1
a1161 1
    transform = RRCrtcGetTransform (randr_crtc);
d1163 5
a1167 4
	changed = TRUE;
    else if (transform && memcmp (&transform->transform, &crtc->transform.transform,
				  sizeof (transform->transform)) != 0)
	changed = TRUE;
d1170 20
a1189 23
	changed = TRUE;
    for (o = 0; o < config->num_output; o++) 
    {
	xf86OutputPtr  output = config->output[o];
	xf86CrtcPtr    new_crtc;

	save_crtcs[o] = output->crtc;
	
	if (output->crtc == crtc)
	    new_crtc = NULL;
	else
	    new_crtc = output->crtc;
	for (ro = 0; ro < num_randr_outputs; ro++) 
	    if (output->randr_output == randr_outputs[ro])
	    {
		new_crtc = crtc;
		break;
	    }
	if (new_crtc != output->crtc)
	{
	    changed = TRUE;
	    output->crtc = new_crtc;
	}
d1191 1
a1191 1
    for (ro = 0; ro < num_randr_outputs; ro++) 
d1193 1
a1193 1
	    changed = TRUE;
d1196 37
a1232 38
    if (changed)
    {
	crtc->enabled = randr_mode != NULL;

	if (randr_mode)
	{
	    DisplayModeRec  mode;
	    RRTransformPtr  transform = RRCrtcGetTransform (randr_crtc);

	    xf86RandRModeConvert (pScrn, randr_mode, &mode);
	    if (!xf86CrtcSetModeTransform (crtc, &mode, rotation, transform, x, y))
	    {
		crtc->enabled = save_enabled;
		for (o = 0; o < config->num_output; o++)
		{
		    xf86OutputPtr	output = config->output[o];
		    output->crtc = save_crtcs[o];
		}
		free(save_crtcs);
		return FALSE;
	    }
	    xf86RandR13VerifyPanningArea (crtc, pScreen->width, pScreen->height);
	    xf86RandR13Pan (crtc, randrp->pointerX, randrp->pointerY);
	    /*
	     * Save the last successful setting for EnterVT
	     */
	    crtc->desiredMode = mode;
	    crtc->desiredRotation = rotation;
	    if (transform) {
		crtc->desiredTransform = *transform;
		crtc->desiredTransformPresent = TRUE;
	    } else
		crtc->desiredTransformPresent = FALSE;

	    crtc->desiredX = x;
	    crtc->desiredY = y;
	}
	xf86DisableUnusedFunctions (pScrn);
d1235 1
a1235 1
    return xf86RandR12CrtcNotify (randr_crtc);
d1239 1
a1239 2
xf86RandR12CrtcSetGamma (ScreenPtr    pScreen,
			 RRCrtcPtr    randr_crtc)
d1241 1
a1241 1
    xf86CrtcPtr		crtc = randr_crtc->devPrivate;
d1244 1
a1244 1
	return FALSE;
d1247 1
a1247 1
	return TRUE;
d1252 3
a1254 1
        tmp_ptr = realloc(crtc->gamma_red, 3 * crtc->gamma_size * sizeof (CARD16));
d1263 6
a1268 3
    memcpy (crtc->gamma_red, randr_crtc->gammaRed, crtc->gamma_size * sizeof (CARD16));
    memcpy (crtc->gamma_green, randr_crtc->gammaGreen, crtc->gamma_size * sizeof (CARD16));
    memcpy (crtc->gamma_blue, randr_crtc->gammaBlue, crtc->gamma_size * sizeof (CARD16));
d1274 2
a1275 2
	crtc->funcs->gamma_set(crtc, crtc->gamma_red, crtc->gamma_green,
						crtc->gamma_blue, crtc->gamma_size);
d1281 1
a1281 2
xf86RandR12CrtcGetGamma (ScreenPtr    pScreen,
			 RRCrtcPtr    randr_crtc)
d1294 4
a1297 1
        tmp_ptr = realloc(randr_crtc->gammaRed, 3 * crtc->gamma_size * sizeof (CARD16));
d1305 6
a1310 3
    memcpy (randr_crtc->gammaRed, crtc->gamma_red, crtc->gamma_size * sizeof (CARD16));
    memcpy (randr_crtc->gammaGreen, crtc->gamma_green, crtc->gamma_size * sizeof (CARD16));
    memcpy (randr_crtc->gammaBlue, crtc->gamma_blue, crtc->gamma_size * sizeof (CARD16));
d1316 3
a1318 4
xf86RandR12OutputSetProperty (ScreenPtr pScreen,
			      RROutputPtr randr_output,
			      Atom property,
			      RRPropertyValuePtr value)
d1326 1
a1326 1
	return TRUE;
d1337 2
a1338 3
xf86RandR13OutputGetProperty (ScreenPtr pScreen,
			      RROutputPtr randr_output,
			      Atom property)
d1343 1
a1343 1
	return TRUE;
d1350 6
a1355 7
xf86RandR12OutputValidateMode (ScreenPtr    pScreen,
			       RROutputPtr  randr_output,
			       RRModePtr    randr_mode)
{
    ScrnInfoPtr	    pScrn = xf86Screens[pScreen->myNum];
    xf86OutputPtr   output = randr_output->devPrivate;
    DisplayModeRec  mode;
d1357 1
a1357 1
    xf86RandRModeConvert (pScrn, randr_mode, &mode);
d1363 2
a1364 2
    if (output->funcs->mode_valid (output, &mode) != MODE_OK)
	return FALSE;
d1369 1
a1369 1
xf86RandR12ModeDestroy (ScreenPtr pScreen, RRModePtr randr_mode)
d1378 1
a1378 1
xf86RROutputSetModes (RROutputPtr randr_output, DisplayModePtr modes)
d1380 6
a1385 6
    DisplayModePtr  mode;
    RRModePtr	    *rrmodes = NULL;
    int		    nmode = 0;
    int		    npreferred = 0;
    Bool	    ret = TRUE;
    int		    pref;
d1388 1
a1388 1
	nmode++;
d1391 34
a1424 34
	rrmodes = malloc(nmode * sizeof (RRModePtr));
	
	if (!rrmodes)
	    return FALSE;
	nmode = 0;

	for (pref = 1; pref >= 0; pref--) {
	    for (mode = modes; mode; mode = mode->next) {
		if ((pref != 0) == ((mode->type & M_T_PREFERRED) != 0)) {
		    xRRModeInfo		modeInfo;
		    RRModePtr		rrmode;
		    
		    modeInfo.nameLength = strlen (mode->name);
		    modeInfo.width = mode->HDisplay;
		    modeInfo.dotClock = mode->Clock * 1000;
		    modeInfo.hSyncStart = mode->HSyncStart;
		    modeInfo.hSyncEnd = mode->HSyncEnd;
		    modeInfo.hTotal = mode->HTotal;
		    modeInfo.hSkew = mode->HSkew;

		    modeInfo.height = mode->VDisplay;
		    modeInfo.vSyncStart = mode->VSyncStart;
		    modeInfo.vSyncEnd = mode->VSyncEnd;
		    modeInfo.vTotal = mode->VTotal;
		    modeInfo.modeFlags = mode->Flags;

		    rrmode = RRModeGet (&modeInfo, mode->name);
		    if (rrmode) {
			rrmodes[nmode++] = rrmode;
			npreferred += pref;
		    }
		}
	    }
	}
d1426 2
a1427 2
    
    ret = RROutputSetModes (randr_output, rrmodes, nmode, npreferred);
d1436 1
a1436 1
xf86RandR12SetInfo12 (ScreenPtr pScreen)
d1438 63
a1500 68
    ScrnInfoPtr		pScrn = xf86Screens[pScreen->myNum];
    xf86CrtcConfigPtr   config = XF86_CRTC_CONFIG_PTR(pScrn);
    RROutputPtr		*clones;
    RRCrtcPtr		*crtcs;
    int			ncrtc;
    int			o, c, l;
    RRCrtcPtr		randr_crtc;
    int			nclone;
    
    clones = malloc(config->num_output * sizeof (RROutputPtr));
    crtcs = malloc(config->num_crtc * sizeof (RRCrtcPtr));
    for (o = 0; o < config->num_output; o++)
    {
	xf86OutputPtr	output = config->output[o];
	
	ncrtc = 0;
	for (c = 0; c < config->num_crtc; c++)
	    if (output->possible_crtcs & (1 << c))
		crtcs[ncrtc++] = config->crtc[c]->randr_crtc;

	if (output->crtc)
	    randr_crtc = output->crtc->randr_crtc;
	else
	    randr_crtc = NULL;

	if (!RROutputSetCrtcs (output->randr_output, crtcs, ncrtc))
	{
	    free(crtcs);
	    free(clones);
	    return FALSE;
	}

	RROutputSetPhysicalSize(output->randr_output, 
				output->mm_width,
				output->mm_height);
	xf86RROutputSetModes (output->randr_output, output->probed_modes);

	switch (output->status) {
	case XF86OutputStatusConnected:
	    RROutputSetConnection (output->randr_output, RR_Connected);
	    break;
	case XF86OutputStatusDisconnected:
	    RROutputSetConnection (output->randr_output, RR_Disconnected);
	    break;
	case XF86OutputStatusUnknown:
	    RROutputSetConnection (output->randr_output, RR_UnknownConnection);
	    break;
	}

	RROutputSetSubpixelOrder (output->randr_output, output->subpixel_order);

	/*
	 * Valid clones
	 */
	nclone = 0;
	for (l = 0; l < config->num_output; l++)
	{
	    xf86OutputPtr	    clone = config->output[l];
	    
	    if (l != o && (output->possible_clones & (1 << l)))
		clones[nclone++] = clone->randr_output;
	}
	if (!RROutputSetClones (output->randr_output, clones, nclone))
	{
	    free(crtcs);
	    free(clones);
	    return FALSE;
	}
a1506 2


d1512 1
a1512 1
xf86RandR12GetInfo12 (ScreenPtr pScreen, Rotation *rotations)
d1514 1
a1514 1
    ScrnInfoPtr		pScrn = xf86Screens[pScreen->myNum];
d1517 4
a1520 4
	return TRUE;
    xf86ProbeOutputModes (pScrn, 0, 0);
    xf86SetScrnInfoModes (pScrn);
    return xf86RandR12SetInfo12 (pScreen);
d1524 1
a1524 1
xf86RandR12CreateObjects12 (ScreenPtr pScreen)
d1526 7
a1532 7
    ScrnInfoPtr		pScrn = xf86Screens[pScreen->myNum];
    xf86CrtcConfigPtr   config = XF86_CRTC_CONFIG_PTR(pScrn);
    int			c;
    int			o;
    
    if (!RRInit ())
	return FALSE;
d1537 5
a1541 6
    for (c = 0; c < config->num_crtc; c++)
    {
	xf86CrtcPtr    crtc = config->crtc[c];
	
	crtc->randr_crtc = RRCrtcCreate (pScreen, crtc);
	RRCrtcGammaSetSize (crtc->randr_crtc, 256);
d1546 9
a1554 11
    for (o = 0; o < config->num_output; o++)
    {
	xf86OutputPtr	output = config->output[o];

	output->randr_output = RROutputCreate (pScreen, output->name, 
					       strlen (output->name),
					       output);

	if (output->funcs->create_resources != NULL)
	    output->funcs->create_resources(output);
	RRPostPendingProperties (output->randr_output);
d1560 1
a1560 1
xf86RandR12CreateScreenResources12 (ScreenPtr pScreen)
d1562 3
a1564 3
    int			c;
    ScrnInfoPtr		pScrn = xf86Screens[pScreen->myNum];
    xf86CrtcConfigPtr   config = XF86_CRTC_CONFIG_PTR(pScrn);
d1567 1
a1567 1
	return TRUE;
d1570 4
a1573 4
        xf86RandR12CrtcNotify (config->crtc[c]->randr_crtc);
    
    RRScreenSetSizeRange (pScreen, config->minWidth, config->minHeight,
			  config->maxWidth, config->maxHeight);
d1583 1
a1583 1
xf86RandR12TellChanged (ScreenPtr pScreen)
d1585 3
a1587 3
    ScrnInfoPtr		pScrn = xf86Screens[pScreen->myNum];
    xf86CrtcConfigPtr   config = XF86_CRTC_CONFIG_PTR(pScrn);
    int			c;
d1590 1
a1590 1
	return;
d1592 1
a1592 1
    xf86RandR12SetInfo12 (pScreen);
d1594 1
a1594 1
	xf86RandR12CrtcNotify (config->crtc[c]->randr_crtc);
d1596 1
a1596 1
    RRTellChanged (pScreen);
d1600 1
a1600 1
xf86RandR12PointerMoved (int scrnIndex, int x, int y)
d1602 4
a1605 4
    ScreenPtr		pScreen = screenInfo.screens[scrnIndex];
    ScrnInfoPtr		pScrn   = XF86SCRNINFO(pScreen);
    xf86CrtcConfigPtr	config  = XF86_CRTC_CONFIG_PTR(pScrn);
    XF86RandRInfoPtr	randrp  = XF86RANDRINFO(pScreen);
d1611 1
a1611 1
	xf86RandR13Pan (config->crtc[c], x, y);
d1615 3
a1617 5
xf86RandR13GetPanning (ScreenPtr           pScreen,
		       RRCrtcPtr           randr_crtc,
		       BoxPtr              totalArea,
		       BoxPtr              trackingArea,
		       INT16               *border)
d1619 1
a1619 1
    xf86CrtcPtr		crtc = randr_crtc->devPrivate;
d1622 1
a1622 1
	return FALSE;
d1624 1
a1624 1
	memcpy (totalArea,    &crtc->panningTotalArea,    sizeof(BoxRec));
d1626 1
a1626 1
	memcpy (trackingArea, &crtc->panningTrackingArea, sizeof(BoxRec));
d1628 1
a1628 1
	memcpy (border,        crtc->panningBorder,       4*sizeof(INT16));
d1634 9
a1642 12
xf86RandR13SetPanning (ScreenPtr           pScreen,
		       RRCrtcPtr           randr_crtc,
		       BoxPtr              totalArea,
		       BoxPtr              trackingArea,
		       INT16               *border)
{
    XF86RandRInfoPtr	randrp  = XF86RANDRINFO(pScreen);
    xf86CrtcPtr		crtc = randr_crtc->devPrivate;
    BoxRec		oldTotalArea;
    BoxRec		oldTrackingArea;
    INT16		oldBorder[4];

d1645 1
a1645 1
	return FALSE;
d1647 3
a1649 3
    memcpy (&oldTotalArea,    &crtc->panningTotalArea,    sizeof(BoxRec));
    memcpy (&oldTrackingArea, &crtc->panningTrackingArea, sizeof(BoxRec));
    memcpy (oldBorder,         crtc->panningBorder,       4*sizeof(INT16));
d1652 1
a1652 1
	memcpy (&crtc->panningTotalArea, totalArea, sizeof(BoxRec));
d1654 1
a1654 1
	memcpy (&crtc->panningTrackingArea, trackingArea, sizeof(BoxRec));
d1656 1
a1656 1
	memcpy (crtc->panningBorder, border, 4*sizeof(INT16));
d1658 10
a1667 9
    if (xf86RandR13VerifyPanningArea (crtc, pScreen->width, pScreen->height)) {
	xf86RandR13Pan (crtc, randrp->pointerX, randrp->pointerY);
	return TRUE;
    } else {
	/* Restore old settings */
	memcpy (&crtc->panningTotalArea,    &oldTotalArea,    sizeof(BoxRec));
	memcpy (&crtc->panningTrackingArea, &oldTrackingArea, sizeof(BoxRec));
	memcpy (crtc->panningBorder,         oldBorder,       4*sizeof(INT16));
	return FALSE;
d1682 6
a1687 5
	if (gamma == 1.0)
	    ramp[i] = i << 8;
	else
	    ramp[i] = (CARD16)(pow((double)i / (double)(size - 1), 1. / gamma)
			       * (double)(size - 1) * 256);
d1700 1
a1700 1
	return Success;
d1704 1
a1704 1
	return Success;
d1708 1
a1708 1
	return BadAlloc;
d1727 1
a1727 1
xf86RandR12EnterVT (int screen_index, int flags)
d1729 6
a1734 6
    ScreenPtr        pScreen = screenInfo.screens[screen_index];
    ScrnInfoPtr	     pScrn = xf86Screens[screen_index];
    XF86RandRInfoPtr randrp  = XF86RANDRINFO(pScreen);
    rrScrPrivPtr     rp = rrGetScrPriv(pScreen);
    Bool	     ret;
    int              i;
d1737 6
a1742 6
	pScrn->EnterVT = randrp->orig_EnterVT;
	ret = pScrn->EnterVT (screen_index, flags);
	randrp->orig_EnterVT = pScrn->EnterVT;
	pScrn->EnterVT = xf86RandR12EnterVT;
	if (!ret)
	    return FALSE;
d1747 1
a1747 1
	xf86RandR12CrtcSetGamma(pScreen, rp->crtcs[i]);
d1749 1
a1749 1
    return RRGetInfo (pScreen, TRUE); /* force a re-probe of outputs and notify clients about changes */
d1753 1
a1753 1
xf86RandR12Init12 (ScreenPtr pScreen)
d1755 3
a1757 3
    ScrnInfoPtr		pScrn = xf86Screens[pScreen->myNum];
    rrScrPrivPtr	rp = rrGetScrPriv(pScreen);
    XF86RandRInfoPtr	randrp  = XF86RANDRINFO(pScreen);
d1780 2
a1781 2
    if (!xf86RandR12CreateObjects12 (pScreen))
	return FALSE;
d1786 2
a1787 2
    if (!xf86RandR12SetInfo12 (pScreen))
	return FALSE;
d1789 1
a1789 1
	xf86RandR12CrtcGetGamma(pScreen, rp->crtcs[i]);
d1797 1
a1797 1
xf86RandR12PreInit (ScrnInfoPtr pScrn)
@


1.8
log
@Call xf86Reconfigure() after readjusting the physical dimensions of the screen
based on EDID information.  Fixes issues with the mouse getting stuck on dual
card setups.  Still trying to push this one upstream.

ok matthieu@@
@
text
@a33 1
#include "xf86.h"
a70 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a76 8
#else /* XORG_VERSION_CURRENT < 7.0 */

static int xf86RandR12Index;
#define XF86RANDRINFO(p) \
    ((XF86RandRInfoPtr)(p)->devPrivates[xf86RandR12Index].ptr)

#endif /* XORG_VERSION_CURRENT < 7.0 */

a512 1
    PixmapPtr 		pspix = NULL;
a560 8
    /*
     * Get the new Screen pixmap ptr as SwitchMode might have called
     * ModifyPixmapHeader and xf86EnableDisableFBAccess will put it back...
     * Unfortunately.
     */
    pspix = (*pScreen->GetScreenPixmap) (pScreen);
    if (pspix->devPrivate.ptr)
       scrp->pixmapPrivate = pspix->devPrivate;
d586 1
a586 1
    int			px, py;
d590 2
d601 8
a608 1
    miPointerGetPosition (inputInfo.pointer, &px, &py);
d654 1
d656 1
a656 1
    if (pScreen == miPointerGetScreen(inputInfo.pointer))
d658 2
a659 2
        px = (px >= pScreen->width ? (pScreen->width - 1) : px);
        py = (py >= pScreen->height ? (pScreen->height - 1) : py);
d661 12
a672 1
	xf86SetViewport(pScreen, px, py);
d674 2
a675 1
	(*pScreen->SetCursorPosition) (inputInfo.pointer, pScreen, px, py, FALSE);
a695 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a696 1
#endif
a701 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a702 1
#endif
a846 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a848 1
#endif
a883 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a886 3
#else
    xf86RandR12Index = AllocateScreenPrivateIndex();
#endif
a911 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a912 3
#else
    pScreen->devPrivates[xf86RandR12Index].ptr = randrp;
#endif
a925 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a927 1
#endif
a946 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a948 1
#endif
a970 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a972 1
#endif
a1586 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a1588 1
#endif
a1609 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a1611 4
#else
    if (!XF86RANDRINFO(pScreen))
	return;
#endif
d1758 1
a1758 1
    int i;
@


1.7
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d845 1
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d1779 1
d1781 1
d1792 4
d1805 1
d1835 3
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a32 1
#include "mibank.h"
d74 1
a74 1
static int xf86RandR12KeyIndex;
d520 1
a520 1
    WindowPtr		pRoot = WindowTable[pScreen->myNum];
d688 2
a689 2
    WindowPtr		pRoot = WindowTable[pScreen->myNum];
    PixmapPtr		pScrnPix = (*pScreen->GetScreenPixmap)(pScreen);
d730 1
d743 1
a743 1
    if (xf86RandR12Key && WindowTable[pScreen->myNum] && ret)
d887 3
a889 1
    xf86RandR12Key = &xf86RandR12KeyIndex;
d894 1
a894 1
    randrp = xalloc (sizeof (XF86RandRInfoRec));
d900 1
a900 1
	xfree (randrp);
d932 18
d1088 1
a1088 1
    randr_outputs = xalloc(config->num_output * sizeof (RROutputPtr));
d1125 1
a1125 1
    xfree(randr_outputs);
d1182 1
a1182 1
    save_crtcs = xalloc(config->num_output * sizeof (xf86CrtcPtr));
d1246 1
a1246 1
		xfree(save_crtcs);
d1267 1
a1267 1
    xfree(save_crtcs);
d1418 1
a1418 1
	rrmodes = xalloc (nmode * sizeof (RRModePtr));
d1455 1
a1455 1
    xfree (rrmodes);
d1474 2
a1475 2
    clones = xalloc(config->num_output * sizeof (RROutputPtr));
    crtcs = xalloc (config->num_crtc * sizeof (RRCrtcPtr));
d1492 2
a1493 2
	    xfree (crtcs);
	    xfree (clones);
d1529 2
a1530 2
	    xfree (crtcs);
	    xfree (clones);
d1534 2
a1535 2
    xfree (crtcs);
    xfree (clones);
d1753 1
a1753 1
    points = xcalloc(size, 3 * sizeof(CARD16));
d1766 1
a1766 1
    xfree(points);
d1777 1
d1779 1
d1782 5
a1786 1
	if (!randrp->orig_EnterVT (screen_index, flags))
@


1.4
log
@Update to server 1.6.5.
@
text
@d58 7
d597 1
a597 1
_X_EXPORT Bool
d749 1
a749 1
_X_EXPORT Rotation
d757 1
a757 1
_X_EXPORT Bool
d808 1
a808 2
	    xf86OutputPtr   output = config->output[config->compat_output];
	    xf86CrtcPtr	    crtc = output->crtc;
d810 2
a811 1
	    if (output->conf_monitor &&
a820 11
	    else if (crtc && crtc->mode.HDisplay &&
		     output->mm_width && output->mm_height)
	    {
		/*
		 * If the output has a mode and a declared size, use that
		 * to scale the screen size
		 */
		DisplayModePtr	mode = &crtc->mode;
		mmWidth = output->mm_width * width / mode->HDisplay;
		mmHeight = output->mm_height * height / mode->VDisplay;
	    }
d866 1
a866 1
_X_EXPORT Bool
d875 6
a880 1
	return TRUE;
d929 1
a929 1
_X_EXPORT void
d955 1
a955 1
_X_EXPORT void
d980 1
a980 1
_X_EXPORT void
d1263 52
a1314 2
    crtc->funcs->gamma_set(crtc, randr_crtc->gammaRed, randr_crtc->gammaGreen,
			   randr_crtc->gammaBlue, randr_crtc->gammaSize);
d1601 1
a1601 1
_X_EXPORT void
d1699 68
d1772 1
d1778 1
d1789 5
d1807 1
a1807 1
_X_EXPORT Bool
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d2 1
a2 1
 * Copyright © 2002 Keith Packard, member of The XFree86 Project, Inc.
a462 1
	xf86DiDGAReInit (pScreen);
a1482 1
    xf86DiDGAReInit (pScreen);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d40 1
d54 2
d66 3
a69 1

d73 9
d91 349
d613 1
a613 1
    miPointerPosition (&px, &py);
d660 1
a660 1
    if (pScreen == miPointerCurrentScreen ())
d667 1
a667 1
	(*pScreen->SetCursorPosition) (pScreen, px, py, FALSE);
d686 1
d688 1
d690 1
d696 1
d698 1
d707 17
d755 2
a756 2
    xf86CrtcConfigPtr   config = XF86_CRTC_CONFIG_PTR(pScrn);
    XF86RandRInfoPtr	randrp = XF86RANDRINFO(pScreen);
d766 2
d778 10
a787 4
	if (crtc->enabled && crtc_width > width)
	    width = crtc_width;
	if (crtc->enabled && crtc_height > height)
	    height = crtc_height;
d838 7
d852 1
d855 1
d886 5
a890 1
    xf86RandR12Key = &xf86RandR12Key;
d916 1
d918 3
d939 1
d942 1
d956 25
d1102 3
a1104 1
			rotation, numOutputs, randr_outputs);
d1140 8
a1147 8
xf86RandR12CrtcSet (ScreenPtr	pScreen,
		  RRCrtcPtr	randr_crtc,
		  RRModePtr	randr_mode,
		  int		x,
		  int		y,
		  Rotation	rotation,
		  int		num_randr_outputs,
		  RROutputPtr	*randr_outputs)
d1149 1
d1153 1
d1171 7
d1215 1
d1218 1
a1218 1
	    if (!xf86CrtcSetMode (crtc, &mode, rotation, x, y))
d1229 2
d1236 6
d1292 14
d1534 1
d1537 1
d1559 1
d1562 4
d1577 71
d1662 5
@


1.1
log
@Initial revision
@
text
@d62 2
a63 2
static int	    xf86RandR12Index;
static int	    xf86RandR12Generation;
d65 2
a66 2
#define XF86RANDRINFO(p) \
	((XF86RandRInfoPtr)(p)->devPrivates[xf86RandR12Index].ptr)
d122 1
a122 3
	if (xf86ModesEqual(mode, scrp->currentMode) &&
	    mode->HDisplay == scrp->virtualX &&
	    mode->VDisplay == scrp->virtualY)
a135 17
    if (scrp->currentMode->HDisplay != randrp->virtualX ||
	scrp->currentMode->VDisplay != randrp->virtualY)
    {
	pSize = RRRegisterSize (pScreen,
				randrp->virtualX, randrp->virtualY,
				randrp->mmWidth,
				randrp->mmHeight);
	if (!pSize)
	    return FALSE;
	RRRegisterRate (pScreen, pSize, refresh0);
	if (scrp->virtualX == randrp->virtualX &&
	    scrp->virtualY == randrp->virtualY)
	{
	    RRSetCurrentConfig (pScreen, randrp->rotation, refresh0, pSize);
	}
    }

d324 6
a329 4
    if (randrp->virtualX == -1 || randrp->virtualY == -1)
    {
	randrp->virtualX = pScrn->virtualX;
	randrp->virtualY = pScrn->virtualY;
d331 1
a331 1
    if (pRoot)
d342 2
a343 2
    pScreen->mmWidth = mmWidth;
    pScreen->mmHeight = mmHeight;
d349 1
a349 1
    if (pRoot)
d352 1
a352 1
    if (WindowTable[pScreen->myNum] && ret)
d412 12
a423 2
	    if (crtc && crtc->mode.HDisplay &&
		output->mm_width && output->mm_height)
d436 1
a436 1
		 * Otherwise, just set the screen to 96dpi
d438 2
a439 2
		mmWidth = width * 25.4 / 96;
		mmHeight = height * 25.4 / 96;
d452 3
d480 1
a481 2
    {
	xf86RandR12Index = AllocateScreenPrivateIndex();
d483 2
a484 1
    }
d510 1
a510 1
    pScreen->devPrivates[xf86RandR12Index].ptr = randrp;
d522 1
a522 1
    XF86RandRInfoPtr	randrp = XF86RANDRINFO(pScreen);
d527 1
d529 5
d631 1
a631 1
    randr_outputs = ALLOCATE_LOCAL(config->num_output * sizeof (RROutputPtr));
d666 1
a666 1
    DEALLOCATE_LOCAL(randr_outputs);
d678 1
a678 3
    mode->prev = NULL;
    mode->next = NULL;
    mode->name = NULL;
a679 1
    mode->type = 0;
d718 4
a721 1
    save_crtcs = ALLOCATE_LOCAL(config->num_output * sizeof (xf86CrtcPtr));
d777 1
a777 1
		DEALLOCATE_LOCAL(save_crtcs);
d790 1
a790 1
    DEALLOCATE_LOCAL(save_crtcs);
d933 2
a934 2
    clones = ALLOCATE_LOCAL(config->num_output * sizeof (RROutputPtr));
    crtcs = ALLOCATE_LOCAL (config->num_crtc * sizeof (RRCrtcPtr));
d951 2
a952 2
	    DEALLOCATE_LOCAL (crtcs);
	    DEALLOCATE_LOCAL (clones);
d988 2
a989 2
	    DEALLOCATE_LOCAL (crtcs);
	    DEALLOCATE_LOCAL (clones);
d993 2
a994 2
    DEALLOCATE_LOCAL (crtcs);
    DEALLOCATE_LOCAL (clones);
d1063 3
d1067 1
a1067 2
	xf86RandR12CrtcNotify (config->crtc[c]->randr_crtc);
    
a1083 1
    XF86RandRInfoPtr	randrp = XF86RANDRINFO(pScreen);
d1086 1
a1086 1
    if (!randrp)
d1088 1
@


1.1.1.1
log
@xserver 1.4
@
text
@@


1.1.1.2
log
@xserver 1.4.0.90
@
text
@d348 1
a348 1
    if (pRoot && pScrn->vtSema)
d366 1
a366 1
    if (pRoot && pScrn->vtSema)
d429 2
a430 12
	    if (output->conf_monitor &&
		(output->conf_monitor->mon_width  > 0 &&
		 output->conf_monitor->mon_height > 0))
	    {
		/*
		 * Prefer user configured DisplaySize
		 */
		mmWidth = output->conf_monitor->mon_width;
		mmHeight = output->conf_monitor->mon_height;
	    }
	    else if (crtc && crtc->mode.HDisplay &&
		     output->mm_width && output->mm_height)
@

