head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.8
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.38;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2014.05.02.19.27.49;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.31.14.09.44;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.01.19;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.01.19;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright © 2006 Keith Packard
 * Copyright © 2011 Aaron Plattner
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */
#ifndef _XF86CRTC_H_
#define _XF86CRTC_H_

#include <edid.h>
#include "randrstr.h"
#include "xf86Modes.h"
#include "xf86Cursor.h"
#include "xf86i2c.h"
#include "damage.h"
#include "picturestr.h"

/* Compat definitions for older X Servers. */
#ifndef M_T_PREFERRED
#define M_T_PREFERRED	0x08
#endif
#ifndef M_T_DRIVER
#define M_T_DRIVER	0x40
#endif
#ifndef M_T_USERPREF
#define M_T_USERPREF	0x80
#endif
#ifndef HARDWARE_CURSOR_ARGB
#define HARDWARE_CURSOR_ARGB				0x00004000
#endif

typedef struct _xf86Crtc xf86CrtcRec, *xf86CrtcPtr;
typedef struct _xf86Output xf86OutputRec, *xf86OutputPtr;

/* define a standard for connector types */
typedef enum _xf86ConnectorType {
    XF86ConnectorNone,
    XF86ConnectorVGA,
    XF86ConnectorDVI_I,
    XF86ConnectorDVI_D,
    XF86ConnectorDVI_A,
    XF86ConnectorComposite,
    XF86ConnectorSvideo,
    XF86ConnectorComponent,
    XF86ConnectorLFP,
    XF86ConnectorProprietary,
    XF86ConnectorHDMI,
    XF86ConnectorDisplayPort,
} xf86ConnectorType;

typedef enum _xf86OutputStatus {
    XF86OutputStatusConnected,
    XF86OutputStatusDisconnected,
    XF86OutputStatusUnknown
} xf86OutputStatus;

struct xf86CrtcTileInfo {
    uint32_t group_id;
    uint32_t flags;
    uint32_t num_h_tile;
    uint32_t num_v_tile;
    uint32_t tile_h_loc;
    uint32_t tile_v_loc;
    uint32_t tile_h_size;
    uint32_t tile_v_size;
};

typedef struct _xf86CrtcFuncs {
   /**
    * Turns the crtc on/off, or sets intermediate power levels if available.
    *
    * Unsupported intermediate modes drop to the lower power setting.  If the
    * mode is DPMSModeOff, the crtc must be disabled sufficiently for it to
    * be safe to call mode_set.
    */
    void
     (*dpms) (xf86CrtcPtr crtc, int mode);

   /**
    * Saves the crtc's state for restoration on VT switch.
    */
    void
     (*save) (xf86CrtcPtr crtc);

   /**
    * Restore's the crtc's state at VT switch.
    */
    void
     (*restore) (xf86CrtcPtr crtc);

    /**
     * Lock CRTC prior to mode setting, mostly for DRI.
     * Returns whether unlock is needed
     */
    Bool
     (*lock) (xf86CrtcPtr crtc);

    /**
     * Unlock CRTC after mode setting, mostly for DRI
     */
    void
     (*unlock) (xf86CrtcPtr crtc);

    /**
     * Callback to adjust the mode to be set in the CRTC.
     *
     * This allows a CRTC to adjust the clock or even the entire set of
     * timings, which is used for panels with fixed timings or for
     * buses with clock limitations.
     */
    Bool
     (*mode_fixup) (xf86CrtcPtr crtc,
                    DisplayModePtr mode, DisplayModePtr adjusted_mode);

    /**
     * Prepare CRTC for an upcoming mode set.
     */
    void
     (*prepare) (xf86CrtcPtr crtc);

    /**
     * Callback for setting up a video mode after fixups have been made.
     */
    void
     (*mode_set) (xf86CrtcPtr crtc,
                  DisplayModePtr mode,
                  DisplayModePtr adjusted_mode, int x, int y);

    /**
     * Commit mode changes to a CRTC
     */
    void
     (*commit) (xf86CrtcPtr crtc);

    /* Set the color ramps for the CRTC to the given values. */
    void
     (*gamma_set) (xf86CrtcPtr crtc, CARD16 *red, CARD16 *green, CARD16 *blue,
                   int size);

    /**
     * Allocate the shadow area, delay the pixmap creation until needed
     */
    void *(*shadow_allocate) (xf86CrtcPtr crtc, int width, int height);

    /**
     * Create shadow pixmap for rotation support
     */
    PixmapPtr
     (*shadow_create) (xf86CrtcPtr crtc, void *data, int width, int height);

    /**
     * Destroy shadow pixmap
     */
    void
     (*shadow_destroy) (xf86CrtcPtr crtc, PixmapPtr pPixmap, void *data);

    /**
     * Set cursor colors
     */
    void
     (*set_cursor_colors) (xf86CrtcPtr crtc, int bg, int fg);

    /**
     * Set cursor position
     */
    void
     (*set_cursor_position) (xf86CrtcPtr crtc, int x, int y);

    /**
     * Show cursor
     */
    void
     (*show_cursor) (xf86CrtcPtr crtc);

    /**
     * Hide cursor
     */
    void
     (*hide_cursor) (xf86CrtcPtr crtc);

    /**
     * Load monochrome image
     */
    void
     (*load_cursor_image) (xf86CrtcPtr crtc, CARD8 *image);
    Bool
     (*load_cursor_image_check) (xf86CrtcPtr crtc, CARD8 *image);

    /**
     * Load ARGB image
     */
    void
     (*load_cursor_argb) (xf86CrtcPtr crtc, CARD32 *image);
    Bool
     (*load_cursor_argb_check) (xf86CrtcPtr crtc, CARD32 *image);

    /**
     * Clean up driver-specific bits of the crtc
     */
    void
     (*destroy) (xf86CrtcPtr crtc);

    /**
     * Less fine-grained mode setting entry point for kernel modesetting
     */
    Bool
     (*set_mode_major) (xf86CrtcPtr crtc, DisplayModePtr mode,
                        Rotation rotation, int x, int y);

    /**
     * Callback for panning. Doesn't change the mode.
     * Added in ABI version 2
     */
    void
     (*set_origin) (xf86CrtcPtr crtc, int x, int y);

    /**
     */
    Bool
    (*set_scanout_pixmap)(xf86CrtcPtr crtc, PixmapPtr pixmap);

} xf86CrtcFuncsRec, *xf86CrtcFuncsPtr;

#define XF86_CRTC_VERSION 6

struct _xf86Crtc {
    /**
     * ABI versioning
     */
    int version;

    /**
     * Associated ScrnInfo
     */
    ScrnInfoPtr scrn;

    /**
     * Desired state of this CRTC
     *
     * Set when this CRTC should be driving one or more outputs
     */
    Bool enabled;

    /**
     * Active mode
     *
     * This reflects the mode as set in the CRTC currently
     * It will be cleared when the VT is not active or
     * during server startup
     */
    DisplayModeRec mode;
    Rotation rotation;
    PixmapPtr rotatedPixmap;
    void *rotatedData;

    /**
     * Position on screen
     *
     * Locates this CRTC within the frame buffer
     */
    int x, y;

    /**
     * Desired mode
     *
     * This is set to the requested mode, independent of
     * whether the VT is active. In particular, it receives
     * the startup configured mode and saves the active mode
     * on VT switch.
     */
    DisplayModeRec desiredMode;
    Rotation desiredRotation;
    int desiredX, desiredY;

    /** crtc-specific functions */
    const xf86CrtcFuncsRec *funcs;

    /**
     * Driver private
     *
     * Holds driver-private information
     */
    void *driver_private;

#ifdef RANDR_12_INTERFACE
    /**
     * RandR crtc
     *
     * When RandR 1.2 is available, this
     * points at the associated crtc object
     */
    RRCrtcPtr randr_crtc;
#else
    void *randr_crtc;
#endif

    /**
     * Current cursor is ARGB
     */
    Bool cursor_argb;
    /**
     * Track whether cursor is within CRTC range
     */
    Bool cursor_in_range;
    /**
     * Track state of cursor associated with this CRTC
     */
    Bool cursor_shown;

    /**
     * Current transformation matrix
     */
    PictTransform crtc_to_framebuffer;
    /* framebuffer_to_crtc was removed in ABI 2 */
    struct pict_f_transform f_crtc_to_framebuffer;      /* ABI 2 */
    struct pict_f_transform f_framebuffer_to_crtc;      /* ABI 2 */
    PictFilterPtr filter;       /* ABI 2 */
    xFixed *params;             /* ABI 2 */
    int nparams;                /* ABI 2 */
    int filter_width;           /* ABI 2 */
    int filter_height;          /* ABI 2 */
    Bool transform_in_use;
    RRTransformRec transform;   /* ABI 2 */
    Bool transformPresent;      /* ABI 2 */
    RRTransformRec desiredTransform;    /* ABI 2 */
    Bool desiredTransformPresent;       /* ABI 2 */
    /**
     * Bounding box in screen space
     */
    BoxRec bounds;
    /**
     * Panning:
     * TotalArea: total panning area, larger than CRTC's size
     * TrackingArea: Area of the pointer for which the CRTC is panned
     * border: Borders of the displayed CRTC area which induces panning if the pointer reaches them
     * Added in ABI version 2
     */
    BoxRec panningTotalArea;
    BoxRec panningTrackingArea;
    INT16 panningBorder[4];

    /**
     * Current gamma, especially useful after initial config.
     * Added in ABI version 3
     */
    CARD16 *gamma_red;
    CARD16 *gamma_green;
    CARD16 *gamma_blue;
    int gamma_size;

    /**
     * Actual state of this CRTC
     *
     * Set to TRUE after modesetting, set to FALSE if no outputs are connected
     * Added in ABI version 3
     */
    Bool active;
    /**
     * Clear the shadow
     */
    Bool shadowClear;

    /**
     * Indicates that the driver is handling the transform, so the shadow
     * surface should be disabled.  The driver writes this field before calling
     * xf86CrtcRotate to indicate that it is handling the transform (including
     * rotation and reflection).
     *
     * Setting this flag also causes the server to stop adjusting the cursor
     * image and position.
     *
     * Added in ABI version 4
     */
    Bool driverIsPerformingTransform;

    /* Added in ABI version 5
     */
    PixmapPtr current_scanout;
};

typedef struct _xf86OutputFuncs {
    /**
     * Called to allow the output a chance to create properties after the
     * RandR objects have been created.
     */
    void
     (*create_resources) (xf86OutputPtr output);

    /**
     * Turns the output on/off, or sets intermediate power levels if available.
     *
     * Unsupported intermediate modes drop to the lower power setting.  If the
     * mode is DPMSModeOff, the output must be disabled, as the DPLL may be
     * disabled afterwards.
     */
    void
     (*dpms) (xf86OutputPtr output, int mode);

    /**
     * Saves the output's state for restoration on VT switch.
     */
    void
     (*save) (xf86OutputPtr output);

    /**
     * Restore's the output's state at VT switch.
     */
    void
     (*restore) (xf86OutputPtr output);

    /**
     * Callback for testing a video mode for a given output.
     *
     * This function should only check for cases where a mode can't be supported
     * on the output specifically, and not represent generic CRTC limitations.
     *
     * \return MODE_OK if the mode is valid, or another MODE_* otherwise.
     */
    int
     (*mode_valid) (xf86OutputPtr output, DisplayModePtr pMode);

    /**
     * Callback to adjust the mode to be set in the CRTC.
     *
     * This allows an output to adjust the clock or even the entire set of
     * timings, which is used for panels with fixed timings or for
     * buses with clock limitations.
     */
    Bool
     (*mode_fixup) (xf86OutputPtr output,
                    DisplayModePtr mode, DisplayModePtr adjusted_mode);

    /**
     * Callback for preparing mode changes on an output
     */
    void
     (*prepare) (xf86OutputPtr output);

    /**
     * Callback for committing mode changes on an output
     */
    void
     (*commit) (xf86OutputPtr output);

    /**
     * Callback for setting up a video mode after fixups have been made.
     *
     * This is only called while the output is disabled.  The dpms callback
     * must be all that's necessary for the output, to turn the output on
     * after this function is called.
     */
    void
     (*mode_set) (xf86OutputPtr output,
                  DisplayModePtr mode, DisplayModePtr adjusted_mode);

    /**
     * Probe for a connected output, and return detect_status.
     */
     xf86OutputStatus(*detect) (xf86OutputPtr output);

    /**
     * Query the device for the modes it provides.
     *
     * This function may also update MonInfo, mm_width, and mm_height.
     *
     * \return singly-linked list of modes or NULL if no modes found.
     */
     DisplayModePtr(*get_modes) (xf86OutputPtr output);

#ifdef RANDR_12_INTERFACE
    /**
     * Callback when an output's property has changed.
     */
    Bool
     (*set_property) (xf86OutputPtr output,
                      Atom property, RRPropertyValuePtr value);
#endif
#ifdef RANDR_13_INTERFACE
    /**
     * Callback to get an updated property value
     */
    Bool
     (*get_property) (xf86OutputPtr output, Atom property);
#endif
#ifdef RANDR_GET_CRTC_INTERFACE
    /**
     * Callback to get current CRTC for a given output
     */
     xf86CrtcPtr(*get_crtc) (xf86OutputPtr output);
#endif
    /**
     * Clean up driver-specific bits of the output
     */
    void
     (*destroy) (xf86OutputPtr output);
} xf86OutputFuncsRec, *xf86OutputFuncsPtr;

#define XF86_OUTPUT_VERSION 3

struct _xf86Output {
    /**
     * ABI versioning
     */
    int version;

    /**
     * Associated ScrnInfo
     */
    ScrnInfoPtr scrn;

    /**
     * Currently connected crtc (if any)
     *
     * If this output is not in use, this field will be NULL.
     */
    xf86CrtcPtr crtc;

    /**
     * Possible CRTCs for this output as a mask of crtc indices
     */
    CARD32 possible_crtcs;

    /**
     * Possible outputs to share the same CRTC as a mask of output indices
     */
    CARD32 possible_clones;

    /**
     * Whether this output can support interlaced modes
     */
    Bool interlaceAllowed;

    /**
     * Whether this output can support double scan modes
     */
    Bool doubleScanAllowed;

    /**
     * List of available modes on this output.
     *
     * This should be the list from get_modes(), plus perhaps additional
     * compatible modes added later.
     */
    DisplayModePtr probed_modes;

    /**
     * Options parsed from the related monitor section
     */
    OptionInfoPtr options;

    /**
     * Configured monitor section
     */
    XF86ConfMonitorPtr conf_monitor;

    /**
     * Desired initial position
     */
    int initial_x, initial_y;

    /**
     * Desired initial rotation
     */
    Rotation initial_rotation;

    /**
     * Current connection status
     *
     * This indicates whether a monitor is known to be connected
     * to this output or not, or whether there is no way to tell
     */
    xf86OutputStatus status;

    /** EDID monitor information */
    xf86MonPtr MonInfo;

    /** subpixel order */
    int subpixel_order;

    /** Physical size of the currently attached output device. */
    int mm_width, mm_height;

    /** Output name */
    char *name;

    /** output-specific functions */
    const xf86OutputFuncsRec *funcs;

    /** driver private information */
    void *driver_private;

    /** Whether to use the old per-screen Monitor config section */
    Bool use_screen_monitor;

#ifdef RANDR_12_INTERFACE
    /**
     * RandR 1.2 output structure.
     *
     * When RandR 1.2 is available, this points at the associated
     * RandR output structure and is created when this output is created
     */
    RROutputPtr randr_output;
#else
    void *randr_output;
#endif
    /**
     * Desired initial panning
     * Added in ABI version 2
     */
    BoxRec initialTotalArea;
    BoxRec initialTrackingArea;
    INT16 initialBorder[4];

    struct xf86CrtcTileInfo tile_info;
};

typedef struct _xf86ProviderFuncs {
    /**
     * Called to allow the provider a chance to create properties after the
     * RandR objects have been created.
     */
    void
    (*create_resources) (ScrnInfoPtr scrn);

    /**
     * Callback when an provider's property has changed.
     */
    Bool
    (*set_property) (ScrnInfoPtr scrn,
                     Atom property, RRPropertyValuePtr value);

    /**
     * Callback to get an updated property value
     */
    Bool
    (*get_property) (ScrnInfoPtr provider, Atom property);

} xf86ProviderFuncsRec, *xf86ProviderFuncsPtr;

typedef struct _xf86CrtcConfigFuncs {
    /**
     * Requests that the driver resize the screen.
     *
     * The driver is responsible for updating scrn->virtualX and scrn->virtualY.
     * If the requested size cannot be set, the driver should leave those values
     * alone and return FALSE.
     *
     * A naive driver that cannot reallocate the screen may simply change
     * virtual[XY].  A more advanced driver will want to also change the
     * devPrivate.ptr and devKind of the screen pixmap, update any offscreen
     * pixmaps it may have moved, and change pScrn->displayWidth.
     */
    Bool
     (*resize) (ScrnInfoPtr scrn, int width, int height);
} xf86CrtcConfigFuncsRec, *xf86CrtcConfigFuncsPtr;

typedef void (*xf86_crtc_notify_proc_ptr) (ScreenPtr pScreen);

typedef struct _xf86CrtcConfig {
    int num_output;
    xf86OutputPtr *output;
    /**
     * compat_output is used whenever we deal
     * with legacy code that only understands a single
     * output. pScrn->modes will be loaded from this output,
     * adjust frame will whack this output, etc.
     */
    int compat_output;

    int num_crtc;
    xf86CrtcPtr *crtc;

    int minWidth, minHeight;
    int maxWidth, maxHeight;

    /* For crtc-based rotation */
    DamagePtr rotation_damage;
    Bool rotation_damage_registered;

    /* DGA */
    unsigned int dga_flags;
    unsigned long dga_address;
    DGAModePtr dga_modes;
    int dga_nmode;
    int dga_width, dga_height, dga_stride;
    DisplayModePtr dga_save_mode;

    const xf86CrtcConfigFuncsRec *funcs;

    CreateScreenResourcesProcPtr CreateScreenResources;

    CloseScreenProcPtr CloseScreen;

    /* Cursor information */
    xf86CursorInfoPtr cursor_info;
    CursorPtr cursor;
    CARD8 *cursor_image;
    Bool cursor_on;
    CARD32 cursor_fg, cursor_bg;

    /**
     * Options parsed from the related device section
     */
    OptionInfoPtr options;

    Bool debug_modes;

    /* wrap screen BlockHandler for rotation */
    ScreenBlockHandlerProcPtr BlockHandler;

    /* callback when crtc configuration changes */
    xf86_crtc_notify_proc_ptr xf86_crtc_notify;

    char *name;
    const xf86ProviderFuncsRec *provider_funcs;
#ifdef RANDR_12_INTERFACE
    RRProviderPtr randr_provider;
#else
    void *randr_provider;
#endif
} xf86CrtcConfigRec, *xf86CrtcConfigPtr;

extern _X_EXPORT int xf86CrtcConfigPrivateIndex;

#define XF86_CRTC_CONFIG_PTR(p)	((xf86CrtcConfigPtr) ((p)->privates[xf86CrtcConfigPrivateIndex].ptr))

static _X_INLINE xf86OutputPtr
xf86CompatOutput(ScrnInfoPtr pScrn)
{
    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);

    if (config->compat_output < 0)
        return NULL;
    return config->output[config->compat_output];
}

static _X_INLINE xf86CrtcPtr
xf86CompatCrtc(ScrnInfoPtr pScrn)
{
    xf86OutputPtr compat_output = xf86CompatOutput(pScrn);

    if (!compat_output)
        return NULL;
    return compat_output->crtc;
}

static _X_INLINE RRCrtcPtr
xf86CompatRRCrtc(ScrnInfoPtr pScrn)
{
    xf86CrtcPtr compat_crtc = xf86CompatCrtc(pScrn);

    if (!compat_crtc)
        return NULL;
    return compat_crtc->randr_crtc;
}

/*
 * Initialize xf86CrtcConfig structure
 */

extern _X_EXPORT void
 xf86CrtcConfigInit(ScrnInfoPtr scrn, const xf86CrtcConfigFuncsRec * funcs);

extern _X_EXPORT void

xf86CrtcSetSizeRange(ScrnInfoPtr scrn,
                     int minWidth, int minHeight, int maxWidth, int maxHeight);

/*
 * Crtc functions
 */
extern _X_EXPORT xf86CrtcPtr
xf86CrtcCreate(ScrnInfoPtr scrn, const xf86CrtcFuncsRec * funcs);

extern _X_EXPORT void
 xf86CrtcDestroy(xf86CrtcPtr crtc);

/**
 * Sets the given video mode on the given crtc
 */

extern _X_EXPORT Bool

xf86CrtcSetModeTransform(xf86CrtcPtr crtc, DisplayModePtr mode,
                         Rotation rotation, RRTransformPtr transform, int x,
                         int y);

extern _X_EXPORT Bool

xf86CrtcSetMode(xf86CrtcPtr crtc, DisplayModePtr mode, Rotation rotation,
                int x, int y);

extern _X_EXPORT void
 xf86CrtcSetOrigin(xf86CrtcPtr crtc, int x, int y);

/*
 * Assign crtc rotation during mode set
 */
extern _X_EXPORT Bool
 xf86CrtcRotate(xf86CrtcPtr crtc);

/*
 * Clean up any rotation data, used when a crtc is turned off
 * as well as when rotation is disabled.
 */
extern _X_EXPORT void
 xf86RotateDestroy(xf86CrtcPtr crtc);

/*
 * free shadow memory allocated for all crtcs
 */
extern _X_EXPORT void
 xf86RotateFreeShadow(ScrnInfoPtr pScrn);

/*
 * Clean up rotation during CloseScreen
 */
extern _X_EXPORT void
 xf86RotateCloseScreen(ScreenPtr pScreen);

/**
 * Return whether any output is assigned to the crtc
 */
extern _X_EXPORT Bool
 xf86CrtcInUse(xf86CrtcPtr crtc);

/*
 * Output functions
 */
extern _X_EXPORT xf86OutputPtr
xf86OutputCreate(ScrnInfoPtr scrn,
                 const xf86OutputFuncsRec * funcs, const char *name);

extern _X_EXPORT void
 xf86OutputUseScreenMonitor(xf86OutputPtr output, Bool use_screen_monitor);

extern _X_EXPORT Bool
 xf86OutputRename(xf86OutputPtr output, const char *name);

extern _X_EXPORT void
 xf86OutputDestroy(xf86OutputPtr output);

extern _X_EXPORT void
 xf86ProbeOutputModes(ScrnInfoPtr pScrn, int maxX, int maxY);

extern _X_EXPORT void
 xf86SetScrnInfoModes(ScrnInfoPtr pScrn);

#ifdef RANDR_13_INTERFACE
#define ScreenInitRetType	int
#else
#define ScreenInitRetType	Bool
#endif

extern _X_EXPORT ScreenInitRetType xf86CrtcScreenInit(ScreenPtr pScreen);

extern _X_EXPORT Bool
 xf86InitialConfiguration(ScrnInfoPtr pScrn, Bool canGrow);

extern _X_EXPORT void
 xf86DPMSSet(ScrnInfoPtr pScrn, int PowerManagementMode, int flags);

extern _X_EXPORT Bool
 xf86SaveScreen(ScreenPtr pScreen, int mode);

extern _X_EXPORT void
 xf86DisableUnusedFunctions(ScrnInfoPtr pScrn);

extern _X_EXPORT DisplayModePtr
xf86OutputFindClosestMode(xf86OutputPtr output, DisplayModePtr desired);

extern _X_EXPORT Bool

xf86SetSingleMode(ScrnInfoPtr pScrn, DisplayModePtr desired, Rotation rotation);

/**
 * Set the EDID information for the specified output
 */
extern _X_EXPORT void
 xf86OutputSetEDID(xf86OutputPtr output, xf86MonPtr edid_mon);

/**
 * Set the TILE information for the specified output
 */
extern _X_EXPORT void
xf86OutputSetTile(xf86OutputPtr output, struct xf86CrtcTileInfo *tile_info);

extern _X_EXPORT Bool
xf86OutputParseKMSTile(const char *tile_data, int tile_length, struct xf86CrtcTileInfo *tile_info);

/**
 * Return the list of modes supported by the EDID information
 * stored in 'output'
 */
extern _X_EXPORT DisplayModePtr xf86OutputGetEDIDModes(xf86OutputPtr output);

extern _X_EXPORT xf86MonPtr
xf86OutputGetEDID(xf86OutputPtr output, I2CBusPtr pDDCBus);

/**
 * Initialize dga for this screen
 */

#ifdef XFreeXDGA
extern _X_EXPORT Bool
 xf86DiDGAInit(ScreenPtr pScreen, unsigned long dga_address);

/* this is the real function, used only internally */
_X_INTERNAL Bool
 _xf86_di_dga_init_internal(ScreenPtr pScreen);

/**
 * Re-initialize dga for this screen (as when the set of modes changes)
 */

extern _X_EXPORT Bool
 xf86DiDGAReInit(ScreenPtr pScreen);
#endif

/* This is the real function, used only internally */
_X_INTERNAL Bool
 _xf86_di_dga_reinit_internal(ScreenPtr pScreen);

/*
 * Set the subpixel order reported for the screen using
 * the information from the outputs
 */

extern _X_EXPORT void
 xf86CrtcSetScreenSubpixelOrder(ScreenPtr pScreen);

/*
 * Get a standard string name for a connector type
 */
extern _X_EXPORT const char *xf86ConnectorGetName(xf86ConnectorType connector);

/*
 * Using the desired mode information in each crtc, set
 * modes (used in EnterVT functions, or at server startup)
 */

extern _X_EXPORT Bool
 xf86SetDesiredModes(ScrnInfoPtr pScrn);

/**
 * Initialize the CRTC-based cursor code. CRTC function vectors must
 * contain relevant cursor setting functions.
 *
 * Driver should call this from ScreenInit function
 */
extern _X_EXPORT Bool
 xf86_cursors_init(ScreenPtr screen, int max_width, int max_height, int flags);

/**
 * Called when anything on the screen is reconfigured.
 *
 * Reloads cursor images as needed, then adjusts cursor positions.
 *
 * Driver should call this from crtc commit function.
 */
extern _X_EXPORT void
 xf86_reload_cursors(ScreenPtr screen);

/**
 * Called from EnterVT to turn the cursors back on
 */
extern _X_EXPORT void
 xf86_show_cursors(ScrnInfoPtr scrn);

/**
 * Called by the driver to turn cursors off
 */
extern _X_EXPORT void
 xf86_hide_cursors(ScrnInfoPtr scrn);

/**
 * Clean up CRTC-based cursor code. Driver must call this at CloseScreen time.
 */
extern _X_EXPORT void
 xf86_cursors_fini(ScreenPtr screen);

/**
 * Transform the cursor's coordinates based on the crtc transform.  Normally
 * this is done by the server, but if crtc->driverIsPerformingTransform is TRUE,
 * then the server does not transform the cursor position automatically.
 */
extern _X_EXPORT void
 xf86CrtcTransformCursorPos(xf86CrtcPtr crtc, int *x, int *y);

#ifdef XV
/*
 * For overlay video, compute the relevant CRTC and
 * clip video to that.
 * wraps xf86XVClipVideoHelper()
 */

extern _X_EXPORT Bool

xf86_crtc_clip_video_helper(ScrnInfoPtr pScrn,
                            xf86CrtcPtr * crtc_ret,
                            xf86CrtcPtr desired_crtc,
                            BoxPtr dst,
                            INT32 *xa,
                            INT32 *xb,
                            INT32 *ya,
                            INT32 *yb,
                            RegionPtr reg, INT32 width, INT32 height);
#endif

extern _X_EXPORT xf86_crtc_notify_proc_ptr
xf86_wrap_crtc_notify(ScreenPtr pScreen, xf86_crtc_notify_proc_ptr new);

extern _X_EXPORT void
 xf86_unwrap_crtc_notify(ScreenPtr pScreen, xf86_crtc_notify_proc_ptr old);

extern _X_EXPORT void
 xf86_crtc_notify(ScreenPtr pScreen);

/**
 * Gamma
 */

extern _X_EXPORT Bool
 xf86_crtc_supports_gamma(ScrnInfoPtr pScrn);

extern _X_EXPORT void
xf86ProviderSetup(ScrnInfoPtr scrn,
                  const xf86ProviderFuncsRec * funcs, const char *name);

extern _X_EXPORT void
xf86DetachAllCrtc(ScrnInfoPtr scrn);

#endif                          /* _XF86CRTC_H_ */
@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d73 11
d240 1
a240 1
#define XF86_CRTC_VERSION 5
d514 1
a514 1
#define XF86_OUTPUT_VERSION 2
d629 2
d897 9
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d245 1
a245 1
     * Set when this CRTC should be driving one or more outputs 
d307 1
a307 1
     * Track whether cursor is within CRTC range 
d611 1
a611 1
    /** 
d735 2
d927 1
a927 1
 * Get a standard string name for a connector type 
d952 1
a952 1
 * 
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d191 2
d199 2
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a27 3
#if XF86_MODES_RENAME
#include "xf86Rename.h"
#endif
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d221 5
d228 1
a228 1
#define XF86_CRTC_VERSION 4
d379 4
d619 23
d716 7
d1016 7
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d3 1
d56 12
a67 12
   XF86ConnectorNone,
   XF86ConnectorVGA,
   XF86ConnectorDVI_I,
   XF86ConnectorDVI_D,
   XF86ConnectorDVI_A,
   XF86ConnectorComposite,
   XF86ConnectorSvideo,
   XF86ConnectorComponent,
   XF86ConnectorLFP,
   XF86ConnectorProprietary,
   XF86ConnectorHDMI,
   XF86ConnectorDisplayPort,
d71 3
a73 3
   XF86OutputStatusConnected,
   XF86OutputStatusDisconnected,
   XF86OutputStatusUnknown
d84 2
a85 3
   void
    (*dpms)(xf86CrtcPtr		crtc,
	    int		    	mode);
d90 2
a91 2
   void
    (*save)(xf86CrtcPtr		crtc);
d96 2
a97 2
   void
    (*restore)(xf86CrtcPtr	crtc);
d104 2
a105 2
    (*lock) (xf86CrtcPtr crtc);
    
d110 2
a111 2
    (*unlock) (xf86CrtcPtr crtc);
    
d120 2
a121 3
    (*mode_fixup)(xf86CrtcPtr crtc,
		  DisplayModePtr mode,
		  DisplayModePtr adjusted_mode);
d127 1
a127 1
    (*prepare)(xf86CrtcPtr crtc);
d133 3
a135 4
    (*mode_set)(xf86CrtcPtr crtc,
		DisplayModePtr mode,
		DisplayModePtr adjusted_mode,
		int x, int y);
d141 1
a141 1
    (*commit)(xf86CrtcPtr crtc);
d145 2
a146 2
    (*gamma_set)(xf86CrtcPtr crtc, CARD16 *red, CARD16 *green, CARD16 *blue,
		 int size);
d151 2
a152 3
    void *
    (*shadow_allocate) (xf86CrtcPtr crtc, int width, int height);
    
d157 2
a158 2
    (*shadow_create) (xf86CrtcPtr crtc, void *data, int width, int height);
    
d163 1
a163 1
    (*shadow_destroy) (xf86CrtcPtr crtc, PixmapPtr pPixmap, void *data);
d169 1
a169 1
    (*set_cursor_colors) (xf86CrtcPtr crtc, int bg, int fg);
d175 1
a175 1
    (*set_cursor_position) (xf86CrtcPtr crtc, int x, int y);
d181 1
a181 1
    (*show_cursor) (xf86CrtcPtr crtc);
d187 1
a187 1
    (*hide_cursor) (xf86CrtcPtr crtc);
d193 1
a193 1
    (*load_cursor_image) (xf86CrtcPtr crtc, CARD8 *image);
d198 1
a198 1
     void
d200 1
a200 1
     
d205 1
a205 1
    (*destroy) (xf86CrtcPtr	crtc);
d211 2
a212 2
    (*set_mode_major)(xf86CrtcPtr crtc, DisplayModePtr mode,
		      Rotation rotation, int x, int y);
d219 1
a219 1
    (*set_origin)(xf86CrtcPtr crtc, int x, int y);
d223 1
a223 1
#define XF86_CRTC_VERSION 3
d234 2
a235 2
    ScrnInfoPtr	    scrn;
    
d241 2
a242 2
    Bool	    enabled;
    
d250 5
a254 5
    DisplayModeRec  mode;
    Rotation	    rotation;
    PixmapPtr	    rotatedPixmap;
    void	    *rotatedData;
    
d260 2
a261 2
    int		    x, y;
    
d270 4
a273 4
    DisplayModeRec  desiredMode;
    Rotation	    desiredRotation;
    int		    desiredX, desiredY;
    
d282 1
a282 1
    void	    *driver_private;
d291 1
a291 1
    RRCrtcPtr	    randr_crtc;
d293 1
a293 1
    void	    *randr_crtc;
d299 1
a299 1
    Bool	    cursor_argb;
d303 1
a303 1
    Bool	    cursor_in_range;
d307 1
a307 1
    Bool	    cursor_shown;
d312 1
a312 1
    PictTransform   crtc_to_framebuffer;
d314 12
a325 12
    struct pict_f_transform f_crtc_to_framebuffer; /* ABI 2 */
    struct pict_f_transform f_framebuffer_to_crtc; /* ABI 2 */
    PictFilterPtr   filter; /* ABI 2 */
    xFixed	    *params; /* ABI 2 */
    int		    nparams; /* ABI 2 */
    int		    filter_width; /* ABI 2 */
    int		    filter_height; /* ABI 2 */
    Bool	    transform_in_use;
    RRTransformRec  transform; /* ABI 2 */
    Bool	    transformPresent; /* ABI 2 */
    RRTransformRec  desiredTransform; /* ABI 2 */
    Bool	    desiredTransformPresent; /* ABI 2 */
d329 1
a329 1
    BoxRec	    bounds;
d337 3
a339 3
    BoxRec          panningTotalArea;
    BoxRec          panningTrackingArea;
    INT16           panningBorder[4];
d356 1
a356 1
    Bool	    active;
d360 14
a373 1
    Bool	    shadowClear;
d382 1
a382 1
    (*create_resources)(xf86OutputPtr output);
d392 1
a392 2
    (*dpms)(xf86OutputPtr	output,
	    int			mode);
d398 1
a398 1
    (*save)(xf86OutputPtr	output);
d404 1
a404 1
    (*restore)(xf86OutputPtr	output);
d415 1
a415 2
    (*mode_valid)(xf86OutputPtr	    output,
		  DisplayModePtr    pMode);
d425 2
a426 3
    (*mode_fixup)(xf86OutputPtr output,
		  DisplayModePtr mode,
		  DisplayModePtr adjusted_mode);
d432 1
a432 1
    (*prepare)(xf86OutputPtr output);
d438 1
a438 1
    (*commit)(xf86OutputPtr output);
d448 2
a449 3
    (*mode_set)(xf86OutputPtr  output,
		DisplayModePtr mode,
		DisplayModePtr adjusted_mode);
d454 1
a454 2
    xf86OutputStatus
    (*detect)(xf86OutputPtr	    output);
d463 1
a463 2
    DisplayModePtr
    (*get_modes)(xf86OutputPtr	    output);
d470 2
a471 3
    (*set_property)(xf86OutputPtr output,
		    Atom property,
		    RRPropertyValuePtr value);
d478 1
a478 2
    (*get_property)(xf86OutputPtr output,
		    Atom property);
d484 1
a484 2
    xf86CrtcPtr
    (*get_crtc)(xf86OutputPtr output);
d490 1
a490 1
    (*destroy) (xf86OutputPtr	    output);
a492 1

d504 1
a504 1
    ScrnInfoPtr		scrn;
d511 1
a511 1
    xf86CrtcPtr		crtc;
d516 1
a516 1
    CARD32		possible_crtcs;
d521 2
a522 2
    CARD32		possible_clones;
    
d526 1
a526 1
    Bool		interlaceAllowed;
d531 1
a531 1
    Bool		doubleScanAllowed;
d539 1
a539 1
    DisplayModePtr	probed_modes;
d544 2
a545 2
    OptionInfoPtr	options;
    
d549 2
a550 2
    XF86ConfMonitorPtr  conf_monitor;
    
d554 1
a554 1
    int			initial_x, initial_y;
d559 1
a559 1
    Rotation		initial_rotation;
d567 1
a567 1
    xf86OutputStatus	status;
d570 1
a570 1
    xf86MonPtr		MonInfo;
d573 1
a573 1
    int			subpixel_order;
d576 1
a576 1
    int			mm_width, mm_height;
d579 1
a579 1
    char		*name;
d585 2
a586 2
    void		*driver_private;
    
d588 1
a588 1
    Bool		use_screen_monitor;
d597 1
a597 1
    RROutputPtr		randr_output;
d599 1
a599 1
    void		*randr_output;
d605 3
a607 3
    BoxRec          initialTotalArea;
    BoxRec          initialTrackingArea;
    INT16           initialBorder[4];
d624 1
a624 3
    (*resize)(ScrnInfoPtr	scrn,
	      int		width,
	      int		height);
d630 2
a631 2
    int			num_output;
    xf86OutputPtr	*output;
d638 4
a641 1
    int			compat_output;
d643 2
a644 2
    int			num_crtc;
    xf86CrtcPtr		*crtc;
a645 3
    int			minWidth, minHeight;
    int			maxWidth, maxHeight;
    
d647 2
a648 2
    DamagePtr		rotation_damage;
    Bool		rotation_damage_registered;
d651 6
a656 6
    unsigned int	dga_flags;
    unsigned long	dga_address;
    DGAModePtr		dga_modes;
    int			dga_nmode;
    int			dga_width, dga_height, dga_stride;
    DisplayModePtr	dga_save_mode;
d660 1
a660 1
    CreateScreenResourcesProcPtr    CreateScreenResources;
d662 1
a662 1
    CloseScreenProcPtr		    CloseScreen;
d665 5
a669 5
    xf86CursorInfoPtr	cursor_info;
    CursorPtr		cursor;
    CARD8		*cursor_image;
    Bool		cursor_on;
    CARD32		cursor_fg, cursor_bg;
d674 1
a674 1
    OptionInfoPtr	options;
d676 1
a676 1
    Bool		debug_modes;
d679 1
a679 1
    ScreenBlockHandlerProcPtr	BlockHandler;
d682 1
a682 1
    xf86_crtc_notify_proc_ptr  xf86_crtc_notify;
d694 1
d702 1
d704 1
a704 1
	return NULL;
d711 2
a712 1
    xf86CrtcPtr	compat_crtc = xf86CompatCrtc(pScrn);
d714 1
a714 1
	return NULL;
a717 1

d723 1
a723 2
xf86CrtcConfigInit (ScrnInfoPtr				scrn,
		    const xf86CrtcConfigFuncsRec	*funcs);
d726 3
a728 3
xf86CrtcSetSizeRange (ScrnInfoPtr scrn,
		      int minWidth, int minHeight,
		      int maxWidth, int maxHeight);
d734 1
a734 2
xf86CrtcCreate (ScrnInfoPtr		scrn,
		const xf86CrtcFuncsRec	*funcs);
d737 1
a737 2
xf86CrtcDestroy (xf86CrtcPtr		crtc);

d744 4
a747 2
xf86CrtcSetModeTransform (xf86CrtcPtr crtc, DisplayModePtr mode, Rotation rotation,
			  RRTransformPtr transform, int x, int y);
d750 3
a752 2
xf86CrtcSetMode (xf86CrtcPtr crtc, DisplayModePtr mode, Rotation rotation,
		 int x, int y);
d755 1
a755 1
xf86CrtcSetOrigin (xf86CrtcPtr crtc, int x, int y);
d761 1
a761 1
xf86CrtcRotate (xf86CrtcPtr crtc);
d768 1
a768 1
xf86RotateDestroy (xf86CrtcPtr crtc);
d774 1
a774 1
xf86RotateFreeShadow(ScrnInfoPtr pScrn);
d780 1
a780 1
xf86RotateCloseScreen (ScreenPtr pScreen);
d786 1
a786 1
xf86CrtcInUse (xf86CrtcPtr crtc);
d792 2
a793 3
xf86OutputCreate (ScrnInfoPtr		    scrn,
		  const xf86OutputFuncsRec  *funcs,
		  const char		    *name);
d796 1
a796 1
xf86OutputUseScreenMonitor (xf86OutputPtr output, Bool use_screen_monitor);
d799 1
a799 1
xf86OutputRename (xf86OutputPtr output, const char *name);
d802 1
a802 1
xf86OutputDestroy (xf86OutputPtr	output);
d805 1
a805 1
xf86ProbeOutputModes (ScrnInfoPtr pScrn, int maxX, int maxY);
d808 1
a808 1
xf86SetScrnInfoModes (ScrnInfoPtr pScrn);
d811 1
a811 1
# define ScreenInitRetType	int
d813 1
a813 1
# define ScreenInitRetType	Bool
d816 1
a816 2
extern _X_EXPORT ScreenInitRetType
xf86CrtcScreenInit (ScreenPtr pScreen);
d819 1
a819 1
xf86InitialConfiguration (ScrnInfoPtr pScrn, Bool canGrow);
d822 2
a823 2
xf86DPMSSet(ScrnInfoPtr pScrn, int PowerManagementMode, int flags);
    
d825 1
a825 1
xf86SaveScreen(ScreenPtr pScreen, int mode);
d828 1
a828 1
xf86DisableUnusedFunctions(ScrnInfoPtr pScrn);
d831 2
a832 2
xf86OutputFindClosestMode (xf86OutputPtr output, DisplayModePtr desired);
    
d834 2
a835 1
xf86SetSingleMode (ScrnInfoPtr pScrn, DisplayModePtr desired, Rotation rotation);
d841 1
a841 1
xf86OutputSetEDID (xf86OutputPtr output, xf86MonPtr edid_mon);
d847 1
a847 2
extern _X_EXPORT DisplayModePtr
xf86OutputGetEDIDModes (xf86OutputPtr output);
d850 1
a850 1
xf86OutputGetEDID (xf86OutputPtr output, I2CBusPtr pDDCBus);
d858 1
a858 1
xf86DiDGAInit (ScreenPtr pScreen, unsigned long dga_address);
d862 1
a862 1
_xf86_di_dga_init_internal (ScreenPtr pScreen);
d869 1
a869 1
xf86DiDGAReInit (ScreenPtr pScreen);
d874 1
a874 1
_xf86_di_dga_reinit_internal (ScreenPtr pScreen);
d882 1
a882 1
xf86CrtcSetScreenSubpixelOrder (ScreenPtr pScreen);
d887 1
a887 2
extern _X_EXPORT char *
xf86ConnectorGetName(xf86ConnectorType connector);
d895 1
a895 1
xf86SetDesiredModes (ScrnInfoPtr pScrn);
d904 1
a904 1
xf86_cursors_init (ScreenPtr screen, int max_width, int max_height, int flags);
d914 1
a914 1
xf86_reload_cursors (ScreenPtr screen);
d920 1
a920 1
xf86_show_cursors (ScrnInfoPtr scrn);
d926 1
a926 1
xf86_hide_cursors (ScrnInfoPtr scrn);
d932 1
a932 1
xf86_cursors_fini (ScreenPtr screen);
d934 9
d950 1
d952 10
a961 11
			    xf86CrtcPtr *crtc_ret,
			    xf86CrtcPtr desired_crtc,
			    BoxPtr      dst,
			    INT32	*xa,
			    INT32	*xb,
			    INT32	*ya,
			    INT32	*yb,
			    RegionPtr   reg,
			    INT32	width,
			    INT32	height);
    
d963 1
a963 1
xf86_wrap_crtc_notify (ScreenPtr pScreen, xf86_crtc_notify_proc_ptr new);
d966 1
a966 1
xf86_unwrap_crtc_notify(ScreenPtr pScreen, xf86_crtc_notify_proc_ptr old);
d969 1
a969 1
xf86_crtc_notify(ScreenPtr pScreen);
d976 1
a976 1
xf86_crtc_supports_gamma(ScrnInfoPtr pScrn);
d978 1
a978 1
#endif /* _XF86CRTC_H_ */
@


1.4
log
@Update to server 1.6.5.
@
text
@d219 1
d226 1
a226 1
#define XF86_CRTC_VERSION 2
d240 1
a240 1
     * Active state of this CRTC
d242 1
a242 1
     * Set when this CRTC is driving one or more outputs 
d316 8
a323 7
    struct pict_f_transform f_crtc_to_framebuffer;
    struct pict_f_transform f_framebuffer_to_crtc;
    PictFilterPtr   filter;
    xFixed	    *params;
    int		    nparams;
    int		    filter_width;
    int		    filter_height;
d325 4
a328 4
    RRTransformRec  transform;
    Bool	    transformPresent;
    RRTransformRec  desiredTransform;
    Bool	    desiredTransformPresent;
d338 1
d343 17
d601 4
a604 1
    /** Desired initial panning */
d688 1
a688 1
extern int xf86CrtcConfigPrivateIndex;
d692 26
d722 1
a722 1
void
d726 1
a726 1
void
d734 1
a734 1
xf86CrtcPtr
d738 1
a738 1
void
d746 1
a746 1
Bool
d750 1
a750 1
Bool
d754 1
a754 1
void
d760 1
a760 1
Bool
d767 1
a767 1
void
d773 1
a773 1
void
d779 1
a779 1
void
d785 1
a785 1
Bool
d791 1
a791 1
xf86OutputPtr
d796 1
a796 1
void
d799 1
a799 1
Bool
d802 1
a802 1
void
d805 1
a805 1
void
d808 1
a808 1
void
d812 1
a812 1
int
d814 1
a814 1
Bool
d816 2
d820 1
a820 1
Bool
d823 1
a823 1
void
d826 1
a826 1
Bool
d829 1
a829 1
void
d832 1
a832 1
DisplayModePtr
d835 1
a835 1
Bool
d841 1
a841 1
void
d848 1
a848 1
DisplayModePtr
d851 1
a851 1
xf86MonPtr
d858 2
a859 1
Bool
d870 1
a870 1
Bool
d872 1
d883 1
a883 1
void
d889 1
a889 1
char *
d897 1
a897 1
Bool
d906 1
a906 1
Bool
d916 1
a916 1
void
d922 1
a922 1
void
d928 1
a928 1
void
d934 1
a934 1
void
d943 1
a943 1
Bool
d956 1
a956 1
xf86_crtc_notify_proc_ptr
d959 1
a959 1
void
d962 1
a962 1
void
d966 1
a966 1
 * Panning
d968 3
a970 11
Bool
xf86_crtc_get_panning(ScrnInfoPtr pScrn,
		      BoxPtr      totalArea,
		      BoxPtr      TrackingArea,
		      INT16      *border);

Bool
xf86_crtc_set_panning(ScrnInfoPtr pScrn,
		      BoxPtr      totalArea,
		      BoxPtr      TrackingArea,
		      INT16      *border);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d810 4
d820 4
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d216 7
d225 2
d229 5
d315 7
a321 1
    PictTransform   framebuffer_to_crtc;
d323 4
d331 13
d450 15
d472 3
d477 5
d581 4
d606 2
d660 3
d696 5
d705 3
d712 14
a725 1
xf86CrtcRotate (xf86CrtcPtr crtc, DisplayModePtr mode, Rotation rotation);
d762 3
d766 1
d895 24
@


1.1
log
@Initial revision
@
text
@d32 1
d43 3
d65 2
d72 1
a72 1
   XF86OutputStatusUnknown,
d209 7
@


1.1.1.1
log
@xserver 1.4
@
text
@@
