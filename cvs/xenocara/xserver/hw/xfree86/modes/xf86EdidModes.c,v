head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.6
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	7pAEtF6Y5EgemkuY;

1.14
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	cVXoV5PxI8YrEaVA;

1.13
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2012.08.05.18.11.38;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.02.16.08.39;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.21.20.10.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.01.21;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.01.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@/*
 * Copyright 2006 Luc Verhaegen.
 * Copyright 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sub license,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * @@file This file covers code to convert a xf86MonPtr containing EDID-probed
 * information into a list of modes, including applying monitor-specific
 * quirks to fix broken EDID data.
 */
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#else
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#endif

#define _PARSE_EDID_
#include "xf86.h"
#include "xf86DDC.h"
#include <X11/Xatom.h>
#include "property.h"
#include "propertyst.h"
#include "xf86Crtc.h"
#include <string.h>
#include <math.h>

static void
handle_detailed_rblank(struct detailed_monitor_section *det_mon, void *data)
{
    if (det_mon->type == DS_RANGES)
        if (det_mon->section.ranges.supported_blanking & CVT_REDUCED)
            *(Bool *) data = TRUE;
}

static Bool
xf86MonitorSupportsReducedBlanking(xf86MonPtr DDC)
{
    /* EDID 1.4 explicitly defines RB support */
    if (DDC->ver.revision >= 4) {
        Bool ret = FALSE;

        xf86ForEachDetailedBlock(DDC, handle_detailed_rblank, &ret);
        return ret;
    }

    /* For anything older, assume digital means RB support. Boo. */
    if (DDC->features.input_type)
        return TRUE;

    return FALSE;
}

static Bool
quirk_prefer_large_60(int scrnIndex, xf86MonPtr DDC)
{
    /* Belinea 10 15 55 */
    if (memcmp(DDC->vendor.name, "MAX", 4) == 0 &&
        ((DDC->vendor.prod_id == 1516) || (DDC->vendor.prod_id == 0x77e)))
        return TRUE;

    /* Acer AL1706 */
    if (memcmp(DDC->vendor.name, "ACR", 4) == 0 && DDC->vendor.prod_id == 44358)
        return TRUE;

    /* Bug #10814: Samsung SyncMaster 225BW */
    if (memcmp(DDC->vendor.name, "SAM", 4) == 0 && DDC->vendor.prod_id == 596)
        return TRUE;

    /* Bug #10545: Samsung SyncMaster 226BW */
    if (memcmp(DDC->vendor.name, "SAM", 4) == 0 && DDC->vendor.prod_id == 638)
        return TRUE;

    /* Acer F51 */
    if (memcmp(DDC->vendor.name, "API", 4) == 0 &&
        DDC->vendor.prod_id == 0x7602)
        return TRUE;

    return FALSE;
}

static Bool
quirk_prefer_large_75(int scrnIndex, xf86MonPtr DDC)
{
    /* Bug #11603: Funai Electronics PM36B */
    if (memcmp(DDC->vendor.name, "FCM", 4) == 0 && DDC->vendor.prod_id == 13600)
        return TRUE;

    return FALSE;
}

static Bool
quirk_detailed_h_in_cm(int scrnIndex, xf86MonPtr DDC)
{
    /* Bug #11603: Funai Electronics PM36B */
    if (memcmp(DDC->vendor.name, "FCM", 4) == 0 && DDC->vendor.prod_id == 13600)
        return TRUE;

    return FALSE;
}

static Bool
quirk_detailed_v_in_cm(int scrnIndex, xf86MonPtr DDC)
{
    /* Bug #11603: Funai Electronics PM36B */
    if (memcmp(DDC->vendor.name, "FCM", 4) == 0 && DDC->vendor.prod_id == 13600)
        return TRUE;

    /* Bug #21000: LGPhilipsLCD LP154W01-TLAJ */
    if (memcmp(DDC->vendor.name, "LPL", 4) == 0 && DDC->vendor.prod_id == 47360)
        return TRUE;

    /* Bug #10304: LGPhilipsLCD LP154W01-A5 */
    if (memcmp(DDC->vendor.name, "LPL", 4) == 0 && DDC->vendor.prod_id == 0)
        return TRUE;

    /* Bug #24482: LGPhilipsLCD LP154W01-TLA1 */
    if (memcmp(DDC->vendor.name, "LPL", 4) == 0 &&
        DDC->vendor.prod_id == 0x2a00)
        return TRUE;

    /* Bug #28414: HP Compaq NC8430 LP154W01-TLA8 */
    if (memcmp(DDC->vendor.name, "LPL", 4) == 0 && DDC->vendor.prod_id == 5750)
        return TRUE;

    /* Bug #21750: Samsung Syncmaster 2333HD */
    if (memcmp(DDC->vendor.name, "SAM", 4) == 0 && DDC->vendor.prod_id == 1157)
        return TRUE;

    return FALSE;
}

static Bool
quirk_detailed_use_maximum_size(int scrnIndex, xf86MonPtr DDC)
{
    /* Bug #21324: Iiyama Vision Master 450 */
    if (memcmp(DDC->vendor.name, "IVM", 4) == 0 && DDC->vendor.prod_id == 6400)
        return TRUE;

    /* Bug #41141: Acer Aspire One */
    if (memcmp(DDC->vendor.name, "LGD", 4) == 0 &&
        DDC->vendor.prod_id == 0x7f01)
        return TRUE;

    /* Sony Vaio Pro 13 */
    if (memcmp(DDC->vendor.name, "MEI", 4) == 0 &&
        DDC->vendor.prod_id == 0x96a2)
        return TRUE;

    return FALSE;
}

static Bool
quirk_135_clock_too_high(int scrnIndex, xf86MonPtr DDC)
{
    /* Envision Peripherals, Inc. EN-7100e.  See bug #9550. */
    if (memcmp(DDC->vendor.name, "EPI", 4) == 0 && DDC->vendor.prod_id == 59264)
        return TRUE;

    return FALSE;
}

static Bool
quirk_first_detailed_preferred(int scrnIndex, xf86MonPtr DDC)
{
    /* Philips 107p5 CRT. Reported on xorg@@ with pastebin. */
    if (memcmp(DDC->vendor.name, "PHL", 4) == 0 && DDC->vendor.prod_id == 57364)
        return TRUE;

    /* Proview AY765C 17" LCD. See bug #15160 */
    if (memcmp(DDC->vendor.name, "PTS", 4) == 0 && DDC->vendor.prod_id == 765)
        return TRUE;

    /* ACR of some sort RH #284231 */
    if (memcmp(DDC->vendor.name, "ACR", 4) == 0 && DDC->vendor.prod_id == 2423)
        return TRUE;

    /* Peacock Ergovision 19.  See rh#492359 */
    if (memcmp(DDC->vendor.name, "PEA", 4) == 0 && DDC->vendor.prod_id == 9003)
        return TRUE;

    return FALSE;
}

static Bool
quirk_detailed_sync_pp(int scrnIndex, xf86MonPtr DDC)
{
    /* Bug #12439: Samsung SyncMaster 205BW */
    if (memcmp(DDC->vendor.name, "SAM", 4) == 0 && DDC->vendor.prod_id == 541)
        return TRUE;
    return FALSE;
}

/* This should probably be made more generic */
static Bool
quirk_dvi_single_link(int scrnIndex, xf86MonPtr DDC)
{
    /* Red Hat bug #453106: Apple 23" Cinema Display */
    if (memcmp(DDC->vendor.name, "APL", 4) == 0 &&
        DDC->vendor.prod_id == 0x921c)
        return TRUE;
    return FALSE;
}

typedef struct {
    Bool (*detect) (int scrnIndex, xf86MonPtr DDC);
    ddc_quirk_t quirk;
    const char *description;
} ddc_quirk_map_t;

static const ddc_quirk_map_t ddc_quirks[] = {
    {
     quirk_prefer_large_60, DDC_QUIRK_PREFER_LARGE_60,
     "Detailed timing is not preferred, use largest mode at 60Hz"},
    {
     quirk_135_clock_too_high, DDC_QUIRK_135_CLOCK_TOO_HIGH,
     "Recommended 135MHz pixel clock is too high"},
    {
     quirk_prefer_large_75, DDC_QUIRK_PREFER_LARGE_75,
     "Detailed timing is not preferred, use largest mode at 75Hz"},
    {
     quirk_detailed_h_in_cm, DDC_QUIRK_DETAILED_H_IN_CM,
     "Detailed timings give horizontal size in cm."},
    {
     quirk_detailed_v_in_cm, DDC_QUIRK_DETAILED_V_IN_CM,
     "Detailed timings give vertical size in cm."},
    {
     quirk_detailed_use_maximum_size, DDC_QUIRK_DETAILED_USE_MAXIMUM_SIZE,
     "Use maximum size instead of detailed timing sizes."},
    {
     quirk_first_detailed_preferred, DDC_QUIRK_FIRST_DETAILED_PREFERRED,
     "First detailed timing was not marked as preferred."},
    {
     quirk_detailed_sync_pp, DDC_QUIRK_DETAILED_SYNC_PP,
     "Use +hsync +vsync for detailed timing."},
    {
     quirk_dvi_single_link, DDC_QUIRK_DVI_SINGLE_LINK,
     "Forcing maximum pixel clock to single DVI link."},
    {
     NULL, DDC_QUIRK_NONE,
     "No known quirks"},
};

/*
 * These more or less come from the DMT spec.  The 720x400 modes are
 * inferred from historical 80x25 practice.  The 640x480@@67 and 832x624@@75
 * modes are old-school Mac modes.  The EDID spec says the 1152x864@@75 mode
 * should be 1152x870, again for the Mac, but instead we use the x864 DMT
 * mode.
 *
 * The DMT modes have been fact-checked; the rest are mild guesses.
 */
#define MODEPREFIX NULL, NULL, NULL, 0, M_T_DRIVER
#define MODESUFFIX 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,FALSE,FALSE,0,NULL,0,0.0,0.0

static const DisplayModeRec DDCEstablishedModes[17] = {
    {MODEPREFIX, 40000, 800, 840, 968, 1056, 0, 600, 601, 605, 628, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 800x600@@60Hz */
    {MODEPREFIX, 36000, 800, 824, 896, 1024, 0, 600, 601, 603, 625, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 800x600@@56Hz */
    {MODEPREFIX, 31500, 640, 656, 720, 840, 0, 480, 481, 484, 500, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* 640x480@@75Hz */
    {MODEPREFIX, 31500, 640, 664, 704, 832, 0, 480, 489, 492, 520, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* 640x480@@72Hz */
    {MODEPREFIX, 30240, 640, 704, 768, 864, 0, 480, 483, 486, 525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* 640x480@@67Hz */
    {MODEPREFIX, 25175, 640, 656, 752, 800, 0, 480, 490, 492, 525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* 640x480@@60Hz */
    {MODEPREFIX, 35500, 720, 738, 846, 900, 0, 400, 421, 423, 449, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* 720x400@@88Hz */
    {MODEPREFIX, 28320, 720, 738, 846, 900, 0, 400, 412, 414, 449, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX}, /* 720x400@@70Hz */
    {MODEPREFIX, 135000, 1280, 1296, 1440, 1688, 0, 1024, 1025, 1028, 1066, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 1280x1024@@75Hz */
    {MODEPREFIX, 78750, 1024, 1040, 1136, 1312, 0, 768, 769, 772, 800, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},     /* 1024x768@@75Hz */
    {MODEPREFIX, 75000, 1024, 1048, 1184, 1328, 0, 768, 771, 777, 806, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* 1024x768@@70Hz */
    {MODEPREFIX, 65000, 1024, 1048, 1184, 1344, 0, 768, 771, 777, 806, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* 1024x768@@60Hz */
    {MODEPREFIX, 44900, 1024, 1032, 1208, 1264, 0, 768, 768, 772, 817, 0, V_PHSYNC | V_PVSYNC | V_INTERLACE, MODESUFFIX},       /* 1024x768@@43Hz */
    {MODEPREFIX, 57284, 832, 864, 928, 1152, 0, 624, 625, 628, 667, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},        /* 832x624@@75Hz */
    {MODEPREFIX, 49500, 800, 816, 896, 1056, 0, 600, 601, 604, 625, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 800x600@@75Hz */
    {MODEPREFIX, 50000, 800, 856, 976, 1040, 0, 600, 637, 643, 666, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 800x600@@72Hz */
    {MODEPREFIX, 108000, 1152, 1216, 1344, 1600, 0, 864, 865, 868, 900, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},    /* 1152x864@@75Hz */
};

static DisplayModePtr
DDCModesFromEstablished(int scrnIndex, struct established_timings *timing,
                        ddc_quirk_t quirks)
{
    DisplayModePtr Modes = NULL, Mode = NULL;
    CARD32 bits = (timing->t1) | (timing->t2 << 8) |
        ((timing->t_manu & 0x80) << 9);
    int i;

    for (i = 0; i < 17; i++) {
        if (bits & (0x01 << i)) {
            Mode = xf86DuplicateMode(&DDCEstablishedModes[i]);
            Modes = xf86ModesAdd(Modes, Mode);
        }
    }

    return Modes;
}

/* Autogenerated from the DMT spec */
const DisplayModeRec DMTModes[] = {
    {MODEPREFIX, 31500, 640, 672, 736, 832, 0, 350, 382, 385, 445, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX}, /* 640x350@@85Hz */
    {MODEPREFIX, 31500, 640, 672, 736, 832, 0, 400, 401, 404, 445, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX}, /* 640x400@@85Hz */
    {MODEPREFIX, 35500, 720, 756, 828, 936, 0, 400, 401, 404, 446, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX}, /* 720x400@@85Hz */
    {MODEPREFIX, 25175, 640, 656, 752, 800, 0, 480, 490, 492, 525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* 640x480@@60Hz */
    {MODEPREFIX, 31500, 640, 664, 704, 832, 0, 480, 489, 492, 520, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* 640x480@@72Hz */
    {MODEPREFIX, 31500, 640, 656, 720, 840, 0, 480, 481, 484, 500, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* 640x480@@75Hz */
    {MODEPREFIX, 36000, 640, 696, 752, 832, 0, 480, 481, 484, 509, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* 640x480@@85Hz */
    {MODEPREFIX, 36000, 800, 824, 896, 1024, 0, 600, 601, 603, 625, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 800x600@@56Hz */
    {MODEPREFIX, 40000, 800, 840, 968, 1056, 0, 600, 601, 605, 628, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 800x600@@60Hz */
    {MODEPREFIX, 50000, 800, 856, 976, 1040, 0, 600, 637, 643, 666, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 800x600@@72Hz */
    {MODEPREFIX, 49500, 800, 816, 896, 1056, 0, 600, 601, 604, 625, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 800x600@@75Hz */
    {MODEPREFIX, 56250, 800, 832, 896, 1048, 0, 600, 601, 604, 631, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 800x600@@85Hz */
    {MODEPREFIX, 73250, 800, 848, 880, 960, 0, 600, 603, 607, 636, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX}, /* 800x600@@120Hz RB */
    {MODEPREFIX, 33750, 848, 864, 976, 1088, 0, 480, 486, 494, 517, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 848x480@@60Hz */
    {MODEPREFIX, 44900, 1024, 1032, 1208, 1264, 0, 768, 768, 772, 817, 0, V_PHSYNC | V_PVSYNC | V_INTERLACE, MODESUFFIX},       /* 1024x768@@43Hz (interlaced) */
    {MODEPREFIX, 65000, 1024, 1048, 1184, 1344, 0, 768, 771, 777, 806, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* 1024x768@@60Hz */
    {MODEPREFIX, 75000, 1024, 1048, 1184, 1328, 0, 768, 771, 777, 806, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* 1024x768@@70Hz */
    {MODEPREFIX, 78750, 1024, 1040, 1136, 1312, 0, 768, 769, 772, 800, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},     /* 1024x768@@75Hz */
    {MODEPREFIX, 94500, 1024, 1072, 1168, 1376, 0, 768, 769, 772, 808, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},     /* 1024x768@@85Hz */
    {MODEPREFIX, 115500, 1024, 1072, 1104, 1184, 0, 768, 771, 775, 813, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},    /* 1024x768@@120Hz RB */
    {MODEPREFIX, 108000, 1152, 1216, 1344, 1600, 0, 864, 865, 868, 900, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},    /* 1152x864@@75Hz */
    {MODEPREFIX, 68250, 1280, 1328, 1360, 1440, 0, 768, 771, 778, 790, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},     /* 1280x768@@60Hz RB */
    {MODEPREFIX, 79500, 1280, 1344, 1472, 1664, 0, 768, 771, 778, 798, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},     /* 1280x768@@60Hz */
    {MODEPREFIX, 102250, 1280, 1360, 1488, 1696, 0, 768, 771, 778, 805, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},    /* 1280x768@@75Hz */
    {MODEPREFIX, 117500, 1280, 1360, 1496, 1712, 0, 768, 771, 778, 809, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},    /* 1280x768@@85Hz */
    {MODEPREFIX, 140250, 1280, 1328, 1360, 1440, 0, 768, 771, 778, 813, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},    /* 1280x768@@120Hz RB */
    {MODEPREFIX, 71000, 1280, 1328, 1360, 1440, 0, 800, 803, 809, 823, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},     /* 1280x800@@60Hz RB */
    {MODEPREFIX, 83500, 1280, 1352, 1480, 1680, 0, 800, 803, 809, 831, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},     /* 1280x800@@60Hz */
    {MODEPREFIX, 106500, 1280, 1360, 1488, 1696, 0, 800, 803, 809, 838, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},    /* 1280x800@@75Hz */
    {MODEPREFIX, 122500, 1280, 1360, 1496, 1712, 0, 800, 803, 809, 843, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},    /* 1280x800@@85Hz */
    {MODEPREFIX, 146250, 1280, 1328, 1360, 1440, 0, 800, 803, 809, 847, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},    /* 1280x800@@120Hz RB */
    {MODEPREFIX, 108000, 1280, 1376, 1488, 1800, 0, 960, 961, 964, 1000, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},   /* 1280x960@@60Hz */
    {MODEPREFIX, 148500, 1280, 1344, 1504, 1728, 0, 960, 961, 964, 1011, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},   /* 1280x960@@85Hz */
    {MODEPREFIX, 175500, 1280, 1328, 1360, 1440, 0, 960, 963, 967, 1017, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},   /* 1280x960@@120Hz RB */
    {MODEPREFIX, 108000, 1280, 1328, 1440, 1688, 0, 1024, 1025, 1028, 1066, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 1280x1024@@60Hz */
    {MODEPREFIX, 135000, 1280, 1296, 1440, 1688, 0, 1024, 1025, 1028, 1066, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 1280x1024@@75Hz */
    {MODEPREFIX, 157500, 1280, 1344, 1504, 1728, 0, 1024, 1025, 1028, 1072, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 1280x1024@@85Hz */
    {MODEPREFIX, 187250, 1280, 1328, 1360, 1440, 0, 1024, 1027, 1034, 1084, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},        /* 1280x1024@@120Hz RB */
    {MODEPREFIX, 85500, 1360, 1424, 1536, 1792, 0, 768, 771, 777, 795, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},     /* 1360x768@@60Hz */
    {MODEPREFIX, 148250, 1360, 1408, 1440, 1520, 0, 768, 771, 776, 813, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},    /* 1360x768@@120Hz RB */
    {MODEPREFIX, 101000, 1400, 1448, 1480, 1560, 0, 1050, 1053, 1057, 1080, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},        /* 1400x1050@@60Hz RB */
    {MODEPREFIX, 121750, 1400, 1488, 1632, 1864, 0, 1050, 1053, 1057, 1089, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 1400x1050@@60Hz */
    {MODEPREFIX, 156000, 1400, 1504, 1648, 1896, 0, 1050, 1053, 1057, 1099, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 1400x1050@@75Hz */
    {MODEPREFIX, 179500, 1400, 1504, 1656, 1912, 0, 1050, 1053, 1057, 1105, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 1400x1050@@85Hz */
    {MODEPREFIX, 208000, 1400, 1448, 1480, 1560, 0, 1050, 1053, 1057, 1112, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},        /* 1400x1050@@120Hz RB */
    {MODEPREFIX, 88750, 1440, 1488, 1520, 1600, 0, 900, 903, 909, 926, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},     /* 1440x900@@60Hz RB */
    {MODEPREFIX, 106500, 1440, 1520, 1672, 1904, 0, 900, 903, 909, 934, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},    /* 1440x900@@60Hz */
    {MODEPREFIX, 136750, 1440, 1536, 1688, 1936, 0, 900, 903, 909, 942, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},    /* 1440x900@@75Hz */
    {MODEPREFIX, 157000, 1440, 1544, 1696, 1952, 0, 900, 903, 909, 948, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},    /* 1440x900@@85Hz */
    {MODEPREFIX, 182750, 1440, 1488, 1520, 1600, 0, 900, 903, 909, 953, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},    /* 1440x900@@120Hz RB */
    {MODEPREFIX, 162000, 1600, 1664, 1856, 2160, 0, 1200, 1201, 1204, 1250, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 1600x1200@@60Hz */
    {MODEPREFIX, 175500, 1600, 1664, 1856, 2160, 0, 1200, 1201, 1204, 1250, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 1600x1200@@65Hz */
    {MODEPREFIX, 189000, 1600, 1664, 1856, 2160, 0, 1200, 1201, 1204, 1250, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 1600x1200@@70Hz */
    {MODEPREFIX, 202500, 1600, 1664, 1856, 2160, 0, 1200, 1201, 1204, 1250, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 1600x1200@@75Hz */
    {MODEPREFIX, 229500, 1600, 1664, 1856, 2160, 0, 1200, 1201, 1204, 1250, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* 1600x1200@@85Hz */
    {MODEPREFIX, 268250, 1600, 1648, 1680, 1760, 0, 1200, 1203, 1207, 1271, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},        /* 1600x1200@@120Hz RB */
    {MODEPREFIX, 119000, 1680, 1728, 1760, 1840, 0, 1050, 1053, 1059, 1080, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},        /* 1680x1050@@60Hz RB */
    {MODEPREFIX, 146250, 1680, 1784, 1960, 2240, 0, 1050, 1053, 1059, 1089, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 1680x1050@@60Hz */
    {MODEPREFIX, 187000, 1680, 1800, 1976, 2272, 0, 1050, 1053, 1059, 1099, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 1680x1050@@75Hz */
    {MODEPREFIX, 214750, 1680, 1808, 1984, 2288, 0, 1050, 1053, 1059, 1105, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 1680x1050@@85Hz */
    {MODEPREFIX, 245500, 1680, 1728, 1760, 1840, 0, 1050, 1053, 1059, 1112, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},        /* 1680x1050@@120Hz RB */
    {MODEPREFIX, 204750, 1792, 1920, 2120, 2448, 0, 1344, 1345, 1348, 1394, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 1792x1344@@60Hz */
    {MODEPREFIX, 261000, 1792, 1888, 2104, 2456, 0, 1344, 1345, 1348, 1417, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 1792x1344@@75Hz */
    {MODEPREFIX, 333250, 1792, 1840, 1872, 1952, 0, 1344, 1347, 1351, 1423, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},        /* 1792x1344@@120Hz RB */
    {MODEPREFIX, 218250, 1856, 1952, 2176, 2528, 0, 1392, 1393, 1396, 1439, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 1856x1392@@60Hz */
    {MODEPREFIX, 288000, 1856, 1984, 2208, 2560, 0, 1392, 1393, 1396, 1500, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 1856x1392@@75Hz */
    {MODEPREFIX, 356500, 1856, 1904, 1936, 2016, 0, 1392, 1395, 1399, 1474, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},        /* 1856x1392@@120Hz RB */
    {MODEPREFIX, 154000, 1920, 1968, 2000, 2080, 0, 1200, 1203, 1209, 1235, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},        /* 1920x1200@@60Hz RB */
    {MODEPREFIX, 193250, 1920, 2056, 2256, 2592, 0, 1200, 1203, 1209, 1245, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 1920x1200@@60Hz */
    {MODEPREFIX, 245250, 1920, 2056, 2264, 2608, 0, 1200, 1203, 1209, 1255, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 1920x1200@@75Hz */
    {MODEPREFIX, 281250, 1920, 2064, 2272, 2624, 0, 1200, 1203, 1209, 1262, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 1920x1200@@85Hz */
    {MODEPREFIX, 317000, 1920, 1968, 2000, 2080, 0, 1200, 1203, 1209, 1271, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},        /* 1920x1200@@120Hz RB */
    {MODEPREFIX, 234000, 1920, 2048, 2256, 2600, 0, 1440, 1441, 1444, 1500, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 1920x1440@@60Hz */
    {MODEPREFIX, 297000, 1920, 2064, 2288, 2640, 0, 1440, 1441, 1444, 1500, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 1920x1440@@75Hz */
    {MODEPREFIX, 380500, 1920, 1968, 2000, 2080, 0, 1440, 1443, 1447, 1525, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},        /* 1920x1440@@120Hz RB */
    {MODEPREFIX, 268500, 2560, 2608, 2640, 2720, 0, 1600, 1603, 1609, 1646, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},        /* 2560x1600@@60Hz RB */
    {MODEPREFIX, 348500, 2560, 2752, 3032, 3504, 0, 1600, 1603, 1609, 1658, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 2560x1600@@60Hz */
    {MODEPREFIX, 443250, 2560, 2768, 3048, 3536, 0, 1600, 1603, 1609, 1672, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 2560x1600@@75Hz */
    {MODEPREFIX, 505250, 2560, 2768, 3048, 3536, 0, 1600, 1603, 1609, 1682, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX},        /* 2560x1600@@85Hz */
    {MODEPREFIX, 552750, 2560, 2608, 2640, 2720, 0, 1600, 1603, 1609, 1694, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX},        /* 2560x1600@@120Hz RB */
};

#define LEVEL_DMT 0
#define LEVEL_GTF 1
#define LEVEL_CVT 2

static int
MonitorStandardTimingLevel(xf86MonPtr DDC)
{
    if (DDC->ver.revision >= 2) {
        if (DDC->ver.revision >= 4 && CVT_SUPPORTED(DDC->features.msc)) {
            return LEVEL_CVT;
        }
        return LEVEL_GTF;
    }
    return LEVEL_DMT;
}

static int
ModeRefresh(const DisplayModeRec * mode)
{
    return (int) (xf86ModeVRefresh(mode) + 0.5);
}

/*
 * If rb is not set, then we'll not consider reduced-blanking modes as
 * part of the DMT pool.  For the 'standard' EDID mode descriptor there's
 * no way to specify whether the mode should be RB or not.
 */
DisplayModePtr
FindDMTMode(int hsize, int vsize, int refresh, Bool rb)
{
    int i;
    const DisplayModeRec *ret;

    for (i = 0; i < sizeof(DMTModes) / sizeof(DisplayModeRec); i++) {
        ret = &DMTModes[i];

        if (!rb && xf86ModeIsReduced(ret))
            continue;

        if (ret->HDisplay == hsize &&
            ret->VDisplay == vsize && refresh == ModeRefresh(ret))
            return xf86DuplicateMode(ret);
    }

    return NULL;
}

/*
 * Appendix B of the EDID 1.4 spec defines the right thing to do here.
 * If the timing given here matches a mode defined in the VESA DMT standard,
 * we _must_ use that.  If the device supports CVT modes, then we should
 * generate a CVT timing.  If both of the above fail, use GTF.
 *
 * There are some wrinkles here.  EDID 1.1 and 1.0 sinks can't really
 * "support" GTF, since it wasn't a standard yet; so if they ask for a
 * timing in this section that isn't defined in DMT, returning a GTF mode
 * may not actually be valid.  EDID 1.3 sinks often report support for
 * some CVT modes, but they are not required to support CVT timings for
 * modes in the standard timing descriptor, so we should _not_ treat them
 * as CVT-compliant (unless specified in an extension block I suppose).
 *
 * EDID 1.4 requires that all sink devices support both GTF and CVT timings
 * for modes in this section, but does say that CVT is preferred.
 */
static DisplayModePtr
DDCModesFromStandardTiming(struct std_timings *timing, ddc_quirk_t quirks,
                           int timing_level, Bool rb)
{
    DisplayModePtr Modes = NULL, Mode = NULL;
    int i, hsize, vsize, refresh;

    for (i = 0; i < STD_TIMINGS; i++) {
        hsize = timing[i].hsize;
        vsize = timing[i].vsize;
        refresh = timing[i].refresh;

        /* HDTV hack, because you can't say 1366 */
        if (refresh == 60 &&
            ((hsize == 1360 && vsize == 765) ||
             (hsize == 1368 && vsize == 769))) {
            Mode = xf86CVTMode(1366, 768, 60, FALSE, FALSE);
            Mode->HDisplay = 1366;
            Mode->HSyncStart--;
            Mode->HSyncEnd--;
        }
        else if (hsize && vsize && refresh) {
            Mode = FindDMTMode(hsize, vsize, refresh, rb);

            if (!Mode) {
                if (timing_level == LEVEL_CVT)
                    /* pass rb here too? */
                    Mode = xf86CVTMode(hsize, vsize, refresh, FALSE, FALSE);
                else if (timing_level == LEVEL_GTF)
                    Mode = xf86GTFMode(hsize, vsize, refresh, FALSE, FALSE);
            }

        }

        if (Mode) {
            Mode->type = M_T_DRIVER;
            Modes = xf86ModesAdd(Modes, Mode);
        }
        Mode = NULL;
    }

    return Modes;
}

static void
DDCModeDoInterlaceQuirks(DisplayModePtr mode)
{
    /*
     * EDID is delightfully ambiguous about how interlaced modes are to be
     * encoded.  X's internal representation is of frame height, but some
     * HDTV detailed timings are encoded as field height.
     *
     * The format list here is from CEA, in frame size.  Technically we
     * should be checking refresh rate too.  Whatever.
     */
    static const struct {
        int w, h;
    } cea_interlaced[] = {
        {1920, 1080},
        {720, 480},
        {1440, 480},
        {2880, 480},
        {720, 576},
        {1440, 576},
        {2880, 576},
    };
    static const int n_modes =
        sizeof(cea_interlaced) / sizeof(cea_interlaced[0]);
    int i;

    for (i = 0; i < n_modes; i++) {
        if ((mode->HDisplay == cea_interlaced[i].w) &&
            (mode->VDisplay == cea_interlaced[i].h / 2)) {
            mode->VDisplay *= 2;
            mode->VSyncStart *= 2;
            mode->VSyncEnd *= 2;
            mode->VTotal *= 2;
            mode->VTotal |= 1;
        }
    }

    mode->Flags |= V_INTERLACE;
}

/*
 *
 */
static DisplayModePtr
DDCModeFromDetailedTiming(int scrnIndex, struct detailed_timings *timing,
                          Bool preferred, ddc_quirk_t quirks)
{
    DisplayModePtr Mode;

    /*
     * Refuse to create modes that are insufficiently large.  64 is a random
     * number, maybe the spec says something about what the minimum is.  In
     * particular I see this frequently with _old_ EDID, 1.0 or so, so maybe
     * our parser is just being too aggresive there.
     */
    if (timing->h_active < 64 || timing->v_active < 64) {
        xf86DrvMsg(scrnIndex, X_INFO,
                   "%s: Ignoring tiny %dx%d mode\n", __func__,
                   timing->h_active, timing->v_active);
        return NULL;
    }

    /* We don't do stereo */
    if (timing->stereo) {
        xf86DrvMsg(scrnIndex, X_INFO,
                   "%s: Ignoring: We don't handle stereo.\n", __func__);
        return NULL;
    }

    /* We only do seperate sync currently */
    if (timing->sync != 0x03) {
        xf86DrvMsg(scrnIndex, X_INFO,
                   "%s: %dx%d Warning: We only handle separate"
                   " sync.\n", __func__, timing->h_active, timing->v_active);
    }

    Mode = xnfcalloc(1, sizeof(DisplayModeRec));

    Mode->type = M_T_DRIVER;
    if (preferred)
        Mode->type |= M_T_PREFERRED;

    if ((quirks & DDC_QUIRK_135_CLOCK_TOO_HIGH) && timing->clock == 135000000)
        Mode->Clock = 108880;
    else
        Mode->Clock = timing->clock / 1000.0;

    Mode->HDisplay = timing->h_active;
    Mode->HSyncStart = timing->h_active + timing->h_sync_off;
    Mode->HSyncEnd = Mode->HSyncStart + timing->h_sync_width;
    Mode->HTotal = timing->h_active + timing->h_blanking;

    Mode->VDisplay = timing->v_active;
    Mode->VSyncStart = timing->v_active + timing->v_sync_off;
    Mode->VSyncEnd = Mode->VSyncStart + timing->v_sync_width;
    Mode->VTotal = timing->v_active + timing->v_blanking;

    /* perform basic check on the detail timing */
    if (Mode->HSyncEnd > Mode->HTotal || Mode->VSyncEnd > Mode->VTotal) {
        free(Mode);
        return NULL;
    }

    /* We ignore h/v_size and h/v_border for now. */

    if (timing->interlaced)
        DDCModeDoInterlaceQuirks(Mode);

    if (quirks & DDC_QUIRK_DETAILED_SYNC_PP)
        Mode->Flags |= V_PVSYNC | V_PHSYNC;
    else {
        if (timing->misc & 0x02)
            Mode->Flags |= V_PVSYNC;
        else
            Mode->Flags |= V_NVSYNC;

        if (timing->misc & 0x01)
            Mode->Flags |= V_PHSYNC;
        else
            Mode->Flags |= V_NHSYNC;
    }

    xf86SetModeDefaultName(Mode);

    return Mode;
}

static DisplayModePtr
DDCModesFromCVT(int scrnIndex, struct cvt_timings *t)
{
    DisplayModePtr modes = NULL;
    int i;

    for (i = 0; i < 4; i++) {
        if (t[i].height) {
            if (t[i].rates & 0x10)
                modes = xf86ModesAdd(modes,
                                     xf86CVTMode(t[i].width, t[i].height, 50, 0,
                                                 0));
            if (t[i].rates & 0x08)
                modes = xf86ModesAdd(modes,
                                     xf86CVTMode(t[i].width, t[i].height, 60, 0,
                                                 0));
            if (t[i].rates & 0x04)
                modes = xf86ModesAdd(modes,
                                     xf86CVTMode(t[i].width, t[i].height, 75, 0,
                                                 0));
            if (t[i].rates & 0x02)
                modes = xf86ModesAdd(modes,
                                     xf86CVTMode(t[i].width, t[i].height, 85, 0,
                                                 0));
            if (t[i].rates & 0x01)
                modes = xf86ModesAdd(modes,
                                     xf86CVTMode(t[i].width, t[i].height, 60, 1,
                                                 0));
        }
        else
            break;
    }

    return modes;
}

static const struct {
    short w;
    short h;
    short r;
    short rb;
} EstIIIModes[] = {
        /* byte 6 */
    {640, 350, 85, 0},
    {640, 400, 85, 0},
    {720, 400, 85, 0},
    {640, 480, 85, 0},
    {848, 480, 60, 0},
    {800, 600, 85, 0},
    {1024, 768, 85, 0},
    {1152, 864, 75, 0},
        /* byte 7 */
    {1280, 768, 60, 1},
    {1280, 768, 60, 0},
    {1280, 768, 75, 0},
    {1280, 768, 85, 0},
    {1280, 960, 60, 0},
    {1280, 960, 85, 0},
    {1280, 1024, 60, 0},
    {1280, 1024, 85, 0},
        /* byte 8 */
    {1360, 768, 60, 0},
    {1440, 900, 60, 1},
    {1440, 900, 60, 0},
    {1440, 900, 75, 0},
    {1440, 900, 85, 0},
    {1400, 1050, 60, 1},
    {1400, 1050, 60, 0},
    {1400, 1050, 75, 0},
        /* byte 9 */
    {1400, 1050, 85, 0},
    {1680, 1050, 60, 1},
    {1680, 1050, 60, 0},
    {1680, 1050, 75, 0},
    {1680, 1050, 85, 0},
    {1600, 1200, 60, 0},
    {1600, 1200, 65, 0},
    {1600, 1200, 70, 0},
        /* byte 10 */
    {1600, 1200, 75, 0},
    {1600, 1200, 85, 0},
    {1792, 1344, 60, 0},
    {1792, 1344, 75, 0},
    {1856, 1392, 60, 0},
    {1856, 1392, 75, 0},
    {1920, 1200, 60, 1},
    {1920, 1200, 60, 0},
        /* byte 11 */
    {1920, 1200, 75, 0},
    {1920, 1200, 85, 0},
    {1920, 1440, 60, 0},
    {1920, 1440, 75, 0},
        /* fill up last byte */
    {0,0,0,0},
    {0,0,0,0},
    {0,0,0,0},
    {0,0,0,0},
};

static DisplayModePtr
DDCModesFromEstIII(unsigned char *est)
{
    DisplayModePtr modes = NULL;
    int i, j, m;

    for (i = 0; i < 6; i++) {
        for (j = 7; j >= 0; j--) {
            if (est[i] & (1 << j)) {
                m = (i * 8) + (7 - j);
                if (EstIIIModes[m].w)
                    modes = xf86ModesAdd(modes,
                                     FindDMTMode(EstIIIModes[m].w,
                                                 EstIIIModes[m].h,
                                                 EstIIIModes[m].r,
                                                 EstIIIModes[m].rb));
            }
        }
    }

    return modes;
}

/*
 * This is only valid when the sink claims to be continuous-frequency
 * but does not supply a detailed range descriptor.  Such sinks are
 * arguably broken.  Currently the mode validation code isn't aware of
 * this; the non-RANDR code even punts the decision of optional sync
 * range checking to the driver.  Loss.
 */
static void
DDCGuessRangesFromModes(int scrnIndex, MonPtr Monitor, DisplayModePtr Modes)
{
    DisplayModePtr Mode = Modes;

    if (!Monitor || !Modes)
        return;

    /* set up the ranges for scanning through the modes */
    Monitor->nHsync = 1;
    Monitor->hsync[0].lo = 1024.0;
    Monitor->hsync[0].hi = 0.0;

    Monitor->nVrefresh = 1;
    Monitor->vrefresh[0].lo = 1024.0;
    Monitor->vrefresh[0].hi = 0.0;

    while (Mode) {
        if (!Mode->HSync)
            Mode->HSync = ((float) Mode->Clock) / ((float) Mode->HTotal);

        if (!Mode->VRefresh)
            Mode->VRefresh = (1000.0 * ((float) Mode->Clock)) /
                ((float) (Mode->HTotal * Mode->VTotal));

        if (Mode->HSync < Monitor->hsync[0].lo)
            Monitor->hsync[0].lo = Mode->HSync;

        if (Mode->HSync > Monitor->hsync[0].hi)
            Monitor->hsync[0].hi = Mode->HSync;

        if (Mode->VRefresh < Monitor->vrefresh[0].lo)
            Monitor->vrefresh[0].lo = Mode->VRefresh;

        if (Mode->VRefresh > Monitor->vrefresh[0].hi)
            Monitor->vrefresh[0].hi = Mode->VRefresh;

        Mode = Mode->next;
    }
}

ddc_quirk_t
xf86DDCDetectQuirks(int scrnIndex, xf86MonPtr DDC, Bool verbose)
{
    ddc_quirk_t quirks;
    int i;

    quirks = DDC_QUIRK_NONE;
    for (i = 0; ddc_quirks[i].detect; i++) {
        if (ddc_quirks[i].detect(scrnIndex, DDC)) {
            if (verbose) {
                xf86DrvMsg(scrnIndex, X_INFO, "    EDID quirk: %s\n",
                           ddc_quirks[i].description);
            }
            quirks |= ddc_quirks[i].quirk;
        }
    }

    return quirks;
}

void
xf86DetTimingApplyQuirks(struct detailed_monitor_section *det_mon,
                         ddc_quirk_t quirks, int hsize, int vsize)
{
    if (det_mon->type != DT)
        return;

    if (quirks & DDC_QUIRK_DETAILED_H_IN_CM)
        det_mon->section.d_timings.h_size *= 10;

    if (quirks & DDC_QUIRK_DETAILED_V_IN_CM)
        det_mon->section.d_timings.v_size *= 10;

    if (quirks & DDC_QUIRK_DETAILED_USE_MAXIMUM_SIZE) {
        det_mon->section.d_timings.h_size = 10 * hsize;
        det_mon->section.d_timings.v_size = 10 * vsize;
    }
}

/**
 * Applies monitor-specific quirks to the decoded EDID information.
 *
 * Note that some quirks applying to the mode list are still implemented in
 * xf86DDCGetModes.
 */
void
xf86DDCApplyQuirks(int scrnIndex, xf86MonPtr DDC)
{
    ddc_quirk_t quirks = xf86DDCDetectQuirks(scrnIndex, DDC, FALSE);
    int i;

    for (i = 0; i < DET_TIMINGS; i++) {
        xf86DetTimingApplyQuirks(DDC->det_mon + i, quirks,
                                 DDC->features.hsize, DDC->features.vsize);
    }
}

/**
 * Walks the modes list, finding the mode with the largest area which is
 * closest to the target refresh rate, and marks it as the only preferred mode.
*/
static void
xf86DDCSetPreferredRefresh(int scrnIndex, DisplayModePtr modes,
                           float target_refresh)
{
    DisplayModePtr mode, best = modes;

    for (mode = modes; mode; mode = mode->next) {
        mode->type &= ~M_T_PREFERRED;

        if (mode == best)
            continue;

        if (mode->HDisplay * mode->VDisplay > best->HDisplay * best->VDisplay) {
            best = mode;
            continue;
        }
        if (mode->HDisplay * mode->VDisplay == best->HDisplay * best->VDisplay) {
            double mode_refresh = xf86ModeVRefresh(mode);
            double best_refresh = xf86ModeVRefresh(best);
            double mode_dist = fabs(mode_refresh - target_refresh);
            double best_dist = fabs(best_refresh - target_refresh);

            if (mode_dist < best_dist) {
                best = mode;
                continue;
            }
        }
    }
    if (best)
        best->type |= M_T_PREFERRED;
}

#define CEA_VIDEO_MODES_NUM  64
static const DisplayModeRec CEAVideoModes[CEA_VIDEO_MODES_NUM] = {
    {MODEPREFIX, 25175, 640, 656, 752, 800, 0, 480, 490, 492, 525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* VIC 1:640x480@@60Hz */
    {MODEPREFIX, 27000, 720, 736, 798, 858, 0, 480, 489, 495, 525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* VIC 2:720x480@@60Hz */
    {MODEPREFIX, 27000, 720, 736, 798, 858, 0, 480, 489, 495, 525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* VIC 3:720x480@@60Hz */
    {MODEPREFIX, 74250, 1280, 1390, 1430, 1650, 0, 720, 725, 730, 750, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},     /* VIC 4: 1280x720@@60Hz */
    {MODEPREFIX, 74250, 1920, 2008, 2052, 2200, 0, 1080, 1084, 1094, 1125, 0, V_PHSYNC | V_PVSYNC | V_INTERLACE, MODESUFFIX},   /* VIC 5:1920x1080i@@60Hz */
    {MODEPREFIX, 27000, 1440, 1478, 1602, 1716, 0, 480, 488, 494, 525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX},       /* VIC 6:1440x480i@@60Hz */
    {MODEPREFIX, 27000, 1440, 1478, 1602, 1716, 0, 480, 488, 494, 525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX},       /* VIC 7:1440x480i@@60Hz */
    {MODEPREFIX, 27000, 1440, 1478, 1602, 1716, 0, 240, 244, 247, 262, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* VIC 8:1440x240@@60Hz */
    {MODEPREFIX, 27000, 1440, 1478, 1602, 1716, 0, 240, 244, 247, 262, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* VIC 9:1440x240@@60Hz */
    {MODEPREFIX, 54000, 2880, 2956, 3204, 3432, 0, 480, 488, 494, 525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX},       /* VIC 10:2880x480i@@60Hz */
    {MODEPREFIX, 54000, 2880, 2956, 3204, 3432, 0, 480, 488, 494, 525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX},       /* VIC 11:2880x480i@@60Hz */
    {MODEPREFIX, 54000, 2880, 2956, 3204, 3432, 0, 240, 244, 247, 262, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* VIC 12:2880x240@@60Hz */
    {MODEPREFIX, 54000, 2880, 2956, 3204, 3432, 0, 240, 244, 247, 262, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* VIC 13:2880x240@@60Hz */
    {MODEPREFIX, 54000, 1440, 1472, 1596, 1716, 0, 480, 489, 495, 525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* VIC 14:1440x480@@60Hz */
    {MODEPREFIX, 54000, 1440, 1472, 1596, 1716, 0, 480, 489, 495, 525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* VIC 15:1440x480@@60Hz */
    {MODEPREFIX, 148500, 1920, 2008, 2052, 2200, 0, 1080, 1084, 1089, 1125, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* VIC 16:1920x1080@@60Hz */
    {MODEPREFIX, 27000, 720, 732, 796, 864, 0, 576, 581, 586, 625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* VIC 17:720x576@@50Hz */
    {MODEPREFIX, 27000, 720, 732, 796, 864, 0, 576, 581, 586, 625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* VIC 18:720x576@@50Hz */
    {MODEPREFIX, 74250, 1280, 1720, 1760, 1980, 0, 720, 725, 730, 750, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},     /* VIC 19: 1280x720@@50Hz */
    {MODEPREFIX, 74250, 1920, 2448, 2492, 2640, 0, 1080, 1084, 1094, 1125, 0, V_PHSYNC | V_PVSYNC | V_INTERLACE, MODESUFFIX},   /* VIC 20:1920x1080i@@50Hz */
    {MODEPREFIX, 27000, 1440, 1464, 1590, 1728, 0, 576, 580, 586, 625, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX},       /* VIC 21:1440x576i@@50Hz */
    {MODEPREFIX, 27000, 1440, 1464, 1590, 1728, 0, 576, 580, 586, 625, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX},       /* VIC 22:1440x576i@@50Hz */
    {MODEPREFIX, 27000, 1440, 1464, 1590, 1728, 0, 288, 290, 293, 312, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* VIC 23:1440x288@@50Hz */
    {MODEPREFIX, 27000, 1440, 1464, 1590, 1728, 0, 288, 290, 293, 312, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* VIC 24:1440x288@@50Hz */
    {MODEPREFIX, 54000, 2880, 2928, 3180, 3456, 0, 576, 580, 586, 625, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX},       /* VIC 25:2880x576i@@50Hz */
    {MODEPREFIX, 54000, 2880, 2928, 3180, 3456, 0, 576, 580, 586, 625, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX},       /* VIC 26:2880x576i@@50Hz */
    {MODEPREFIX, 54000, 2880, 2928, 3180, 3456, 0, 288, 290, 293, 312, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* VIC 27:2880x288@@50Hz */
    {MODEPREFIX, 54000, 2880, 2928, 3180, 3456, 0, 288, 290, 293, 312, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* VIC 28:2880x288@@50Hz */
    {MODEPREFIX, 54000, 1440, 1464, 1592, 1728, 0, 576, 581, 586, 625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* VIC 29:1440x576@@50Hz */
    {MODEPREFIX, 54000, 1440, 1464, 1592, 1728, 0, 576, 581, 586, 625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* VIC 30:1440x576@@50Hz */
    {MODEPREFIX, 148500, 1920, 2448, 2492, 2640, 0, 1080, 1084, 1089, 1125, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* VIC 31:1920x1080@@50Hz */
    {MODEPREFIX, 74250, 1920, 2558, 2602, 2750, 0, 1080, 1084, 1089, 1125, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX}, /* VIC 32:1920x1080@@24Hz */
    {MODEPREFIX, 74250, 1920, 2448, 2492, 2640, 0, 1080, 1084, 1089, 1125, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX}, /* VIC 33:1920x1080@@25Hz */
    {MODEPREFIX, 74250, 1920, 2008, 2052, 2200, 0, 1080, 1084, 1089, 1125, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX}, /* VIC 34:1920x1080@@30Hz */
    {MODEPREFIX, 108000, 2880, 2944, 3192, 3432, 0, 480, 489, 495, 525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},    /* VIC 35:2880x480@@60Hz */
    {MODEPREFIX, 108000, 2880, 2944, 3192, 3432, 0, 480, 489, 495, 525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},    /* VIC 36:2880x480@@60Hz */
    {MODEPREFIX, 108000, 2880, 2928, 3184, 3456, 0, 576, 581, 586, 625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},    /* VIC 37:2880x576@@50Hz */
    {MODEPREFIX, 108000, 2880, 2928, 3184, 3456, 0, 576, 581, 586, 625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},    /* VIC 38:2880x576@@50Hz */
    {MODEPREFIX, 72000, 1920, 1952, 2120, 2304, 0, 1080, 1126, 1136, 1250, 0, V_PHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX},   /* VIC 39:1920x1080i@@50Hz */
    {MODEPREFIX, 148500, 1920, 2448, 2492, 2640, 0, 1080, 1084, 1094, 1125, 0, V_PHSYNC | V_PVSYNC | V_INTERLACE, MODESUFFIX},  /* VIC 40:1920x1080i@@100Hz */
    {MODEPREFIX, 148500, 1280, 1720, 1760, 1980, 0, 720, 725, 730, 750, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},    /* VIC 41:1280x720@@100Hz */
    {MODEPREFIX, 54000, 720, 732, 796, 864, 0, 576, 581, 586, 625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* VIC 42:720x576@@100Hz */
    {MODEPREFIX, 54000, 720, 732, 796, 864, 0, 576, 581, 586, 625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* VIC 43:720x576@@100Hz */
    {MODEPREFIX, 54000, 1440, 1464, 1590, 1728, 0, 576, 580, 586, 625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* VIC 44:1440x576i@@100Hz */
    {MODEPREFIX, 54000, 1440, 1464, 1590, 1728, 0, 576, 580, 586, 625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},     /* VIC 45:1440x576i@@100Hz */
    {MODEPREFIX, 148500, 1920, 2008, 2052, 2200, 0, 1080, 1084, 1094, 1125, 0, V_PHSYNC | V_PVSYNC | V_INTERLACE, MODESUFFIX},  /* VIC 46:1920x1080i@@120Hz */
    {MODEPREFIX, 148500, 1280, 1390, 1430, 1650, 0, 720, 725, 730, 750, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},    /* VIC 47:1280x720@@120Hz */
    {MODEPREFIX, 54000, 720, 736, 798, 858, 0, 480, 489, 495, 525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* VIC 48:720x480@@120Hz */
    {MODEPREFIX, 54000, 720, 736, 798, 858, 0, 480, 489, 495, 525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX}, /* VIC 49:720x480@@120Hz */
    {MODEPREFIX, 54000, 1440, 1478, 1602, 1716, 0, 480, 488, 494, 525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX},       /* VIC 50:1440x480i@@120Hz */
    {MODEPREFIX, 54000, 1440, 1478, 1602, 1716, 0, 480, 488, 494, 525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX},       /* VIC 51:1440x480i@@120Hz */
    {MODEPREFIX, 108000, 720, 732, 796, 864, 0, 576, 581, 586, 625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},        /* VIC 52:720x576@@200Hz */
    {MODEPREFIX, 108000, 720, 732, 796, 864, 0, 576, 581, 586, 625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},        /* VIC 53:720x576@@200Hz */
    {MODEPREFIX, 108000, 1440, 1464, 1590, 1728, 0, 576, 580, 586, 625, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX},      /* VIC 54:1440x576i@@200Hz */
    {MODEPREFIX, 108000, 1440, 1464, 1590, 1728, 0, 576, 580, 586, 625, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX},      /* VIC 55:1440x576i@@200Hz */
    {MODEPREFIX, 108000, 720, 736, 798, 858, 0, 480, 489, 495, 525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},        /* VIC 56:720x480@@240Hz */
    {MODEPREFIX, 108000, 720, 736, 798, 858, 0, 480, 489, 495, 525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX},        /* VIC 57:720x480@@240Hz */
    {MODEPREFIX, 108000, 1440, 1478, 1602, 1716, 0, 480, 488, 494, 525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX},      /* VIC 58:1440x480i@@240 */
    {MODEPREFIX, 108000, 1440, 1478, 1602, 1716, 0, 480, 488, 494, 525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX},      /* VIC 59:1440x480i@@240 */
    {MODEPREFIX, 59400, 1280, 3040, 3080, 3300, 0, 720, 725, 730, 750, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},     /* VIC 60: 1280x720@@24Hz */
    {MODEPREFIX, 74250, 1280, 3700, 3740, 3960, 0, 720, 725, 730, 750, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},     /* VIC 61: 1280x720@@25Hz */
    {MODEPREFIX, 74250, 1280, 3040, 3080, 3300, 0, 720, 725, 730, 750, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},     /* VIC 62: 1280x720@@30Hz */
    {MODEPREFIX, 297000, 1920, 2008, 2052, 2200, 0, 1080, 1084, 1089, 1125, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* VIC 63: 1920x1080@@120Hz */
    {MODEPREFIX, 297000, 1920, 2448, 2492, 2640, 0, 1080, 1084, 1094, 1125, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX},        /* VIC 64:1920x1080@@100Hz */
};

/* chose mode line by cea short video descriptor*/
static void
handle_cea_svd(struct cea_video_block *video, void *data)
{
    DisplayModePtr Mode;
    DisplayModePtr *Modes = (DisplayModePtr *) data;
    int vid;

    vid = video->video_code & 0x7f;
    if (vid < CEA_VIDEO_MODES_NUM) {
        Mode = xf86DuplicateMode(CEAVideoModes + vid);
        *Modes = xf86ModesAdd(*Modes, Mode);
    }
}

static DisplayModePtr
DDCModesFromCEAExtension(int scrnIndex, xf86MonPtr mon_ptr)
{
    DisplayModePtr Modes = NULL;

    xf86ForEachVideoBlock(mon_ptr, handle_cea_svd, &Modes);

    return Modes;
}

struct det_modes_parameter {
    xf86MonPtr DDC;
    ddc_quirk_t quirks;
    DisplayModePtr Modes;
    Bool rb;
    Bool preferred;
    int timing_level;
};

static void
handle_detailed_modes(struct detailed_monitor_section *det_mon, void *data)
{
    DisplayModePtr Mode;
    struct det_modes_parameter *p = (struct det_modes_parameter *) data;

    xf86DetTimingApplyQuirks(det_mon, p->quirks,
                             p->DDC->features.hsize, p->DDC->features.vsize);

    switch (det_mon->type) {
    case DT:
        Mode = DDCModeFromDetailedTiming(p->DDC->scrnIndex,
                                         &det_mon->section.d_timings,
                                         p->preferred, p->quirks);
        p->preferred = FALSE;
        p->Modes = xf86ModesAdd(p->Modes, Mode);
        break;
    case DS_STD_TIMINGS:
        Mode = DDCModesFromStandardTiming(det_mon->section.std_t,
                                          p->quirks, p->timing_level, p->rb);
        p->Modes = xf86ModesAdd(p->Modes, Mode);
        break;
    case DS_CVT:
        Mode = DDCModesFromCVT(p->DDC->scrnIndex, det_mon->section.cvt);
        p->Modes = xf86ModesAdd(p->Modes, Mode);
        break;
    case DS_EST_III:
        Mode = DDCModesFromEstIII(det_mon->section.est_iii);
        p->Modes = xf86ModesAdd(p->Modes, Mode);
        break;
    default:
        break;
    }
}

DisplayModePtr
xf86DDCGetModes(int scrnIndex, xf86MonPtr DDC)
{
    DisplayModePtr Modes = NULL, Mode;
    ddc_quirk_t quirks;
    Bool preferred, rb;
    int timing_level;
    struct det_modes_parameter p;

    xf86DrvMsg(scrnIndex, X_INFO, "EDID vendor \"%s\", prod id %d\n",
               DDC->vendor.name, DDC->vendor.prod_id);

    quirks = xf86DDCDetectQuirks(scrnIndex, DDC, TRUE);

    preferred = PREFERRED_TIMING_MODE(DDC->features.msc);
    if (DDC->ver.revision >= 4)
        preferred = TRUE;
    if (quirks & DDC_QUIRK_FIRST_DETAILED_PREFERRED)
        preferred = TRUE;
    if (quirks & (DDC_QUIRK_PREFER_LARGE_60 | DDC_QUIRK_PREFER_LARGE_75))
        preferred = FALSE;

    rb = xf86MonitorSupportsReducedBlanking(DDC);

    timing_level = MonitorStandardTimingLevel(DDC);

    p.quirks = quirks;
    p.DDC = DDC;
    p.Modes = Modes;
    p.rb = rb;
    p.preferred = preferred;
    p.timing_level = timing_level;
    xf86ForEachDetailedBlock(DDC, handle_detailed_modes, &p);
    Modes = p.Modes;

    /* Add established timings */
    Mode = DDCModesFromEstablished(scrnIndex, &DDC->timings1, quirks);
    Modes = xf86ModesAdd(Modes, Mode);

    /* Add standard timings */
    Mode = DDCModesFromStandardTiming(DDC->timings2, quirks, timing_level, rb);
    Modes = xf86ModesAdd(Modes, Mode);

    /* Add cea-extension mode timings */
    Mode = DDCModesFromCEAExtension(scrnIndex, DDC);
    Modes = xf86ModesAdd(Modes, Mode);

    if (quirks & DDC_QUIRK_PREFER_LARGE_60)
        xf86DDCSetPreferredRefresh(scrnIndex, Modes, 60);

    if (quirks & DDC_QUIRK_PREFER_LARGE_75)
        xf86DDCSetPreferredRefresh(scrnIndex, Modes, 75);

    Modes = xf86PruneDuplicateModes(Modes);

    return Modes;
}

struct det_mon_parameter {
    MonPtr Monitor;
    ddc_quirk_t quirks;
    Bool have_hsync;
    Bool have_vrefresh;
    Bool have_maxpixclock;
};

static void
handle_detailed_monset(struct detailed_monitor_section *det_mon, void *data)
{
    int clock;
    struct det_mon_parameter *p = (struct det_mon_parameter *) data;
    int scrnIndex = ((xf86MonPtr) (p->Monitor->DDC))->scrnIndex;

    switch (det_mon->type) {
    case DS_RANGES:
        if (!p->have_hsync) {
            if (!p->Monitor->nHsync)
                xf86DrvMsg(scrnIndex, X_INFO,
                           "Using EDID range info for horizontal sync\n");
            p->Monitor->hsync[p->Monitor->nHsync].lo =
                det_mon->section.ranges.min_h;
            p->Monitor->hsync[p->Monitor->nHsync].hi =
                det_mon->section.ranges.max_h;
            p->Monitor->nHsync++;
        }
        else {
            xf86DrvMsg(scrnIndex, X_INFO,
                       "Using hsync ranges from config file\n");
        }

        if (!p->have_vrefresh) {
            if (!p->Monitor->nVrefresh)
                xf86DrvMsg(scrnIndex, X_INFO,
                           "Using EDID range info for vertical refresh\n");
            p->Monitor->vrefresh[p->Monitor->nVrefresh].lo =
                det_mon->section.ranges.min_v;
            p->Monitor->vrefresh[p->Monitor->nVrefresh].hi =
                det_mon->section.ranges.max_v;
            p->Monitor->nVrefresh++;
        }
        else {
            xf86DrvMsg(scrnIndex, X_INFO,
                       "Using vrefresh ranges from config file\n");
        }

        clock = det_mon->section.ranges.max_clock * 1000;
        if (p->quirks & DDC_QUIRK_DVI_SINGLE_LINK)
            clock = min(clock, 165000);
        if (!p->have_maxpixclock && clock > p->Monitor->maxPixClock)
            p->Monitor->maxPixClock = clock;

        break;
    default:
        break;
    }
}

/*
 * Fill out MonPtr with xf86MonPtr information.
 */
void
xf86EdidMonitorSet(int scrnIndex, MonPtr Monitor, xf86MonPtr DDC)
{
    DisplayModePtr Modes = NULL, Mode;
    struct det_mon_parameter p;

    if (!Monitor || !DDC)
        return;

    Monitor->DDC = DDC;

    if (Monitor->widthmm <= 0 || Monitor->heightmm <= 0) {
        Monitor->widthmm = 10 * DDC->features.hsize;
        Monitor->heightmm = 10 * DDC->features.vsize;
    }

    Monitor->reducedblanking = xf86MonitorSupportsReducedBlanking(DDC);

    Modes = xf86DDCGetModes(scrnIndex, DDC);

    /* Go through the detailed monitor sections */
    p.Monitor = Monitor;
    p.quirks = xf86DDCDetectQuirks(scrnIndex, Monitor->DDC, FALSE);
    p.have_hsync = (Monitor->nHsync != 0);
    p.have_vrefresh = (Monitor->nVrefresh != 0);
    p.have_maxpixclock = (Monitor->maxPixClock != 0);
    xf86ForEachDetailedBlock(DDC, handle_detailed_monset, &p);

    if (Modes) {
        /* Print Modes */
        xf86DrvMsg(scrnIndex, X_INFO, "Printing DDC gathered Modelines:\n");

        Mode = Modes;
        while (Mode) {
            xf86PrintModeline(scrnIndex, Mode);
            Mode = Mode->next;
        }

        /* Do we still need ranges to be filled in? */
        if (!Monitor->nHsync || !Monitor->nVrefresh)
            DDCGuessRangesFromModes(scrnIndex, Monitor, Modes);

        /* look for last Mode */
        Mode = Modes;

        while (Mode->next)
            Mode = Mode->next;

        /* add to MonPtr */
        if (Monitor->Modes) {
            Monitor->Last->next = Modes;
            Modes->prev = Monitor->Last;
            Monitor->Last = Mode;
        }
        else {
            Monitor->Modes = Modes;
            Monitor->Last = Mode;
        }
    }
}
@


1.14
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d716 1
a716 1
    {1792, 1344, 85, 0},
@


1.13
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d165 5
d981 1
a981 1
DDCModesFromCEAExtension(int scrnIndex, xf86MonPtr MonPtr)
d985 1
a985 1
    xf86ForEachVideoBlock(MonPtr, handle_cea_svd, &Modes);
@


1.12
log
@Update to xserver 1.12.3.
@
text
@d516 8
a523 8
        {
        1920, 1080}, {
        720, 480}, {
        1440, 480}, {
        2880, 480}, {
        720, 576}, {
        1440, 576}, {
    2880, 576},};
d671 9
a679 10
    /* byte 6 */
    {
    640, 350, 85, 0}, {
    640, 400, 85, 0}, {
    720, 400, 85, 0}, {
    640, 480, 85, 0}, {
    848, 480, 60, 0}, {
    800, 600, 85, 0}, {
    1024, 768, 85, 0}, {
    1152, 864, 75, 0},
d681 8
a688 9
    {
    1280, 768, 60, 1}, {
    1280, 768, 60, 0}, {
    1280, 768, 75, 0}, {
    1280, 768, 85, 0}, {
    1280, 960, 60, 0}, {
    1280, 960, 85, 0}, {
    1280, 1024, 60, 0}, {
    1280, 1024, 85, 0},
d690 8
a697 9
    {
    1360, 768, 60, 0}, {
    1440, 900, 60, 1}, {
    1440, 900, 60, 0}, {
    1440, 900, 75, 0}, {
    1440, 900, 85, 0}, {
    1400, 1050, 60, 1}, {
    1400, 1050, 60, 0}, {
    1400, 1050, 75, 0},
d699 8
a706 9
    {
    1400, 1050, 85, 0}, {
    1680, 1050, 60, 1}, {
    1680, 1050, 60, 0}, {
    1680, 1050, 75, 0}, {
    1680, 1050, 85, 0}, {
    1600, 1200, 60, 0}, {
    1600, 1200, 65, 0}, {
    1600, 1200, 70, 0},
d708 8
a715 9
    {
    1600, 1200, 75, 0}, {
    1600, 1200, 85, 0}, {
    1792, 1344, 60, 0}, {
    1792, 1344, 85, 0}, {
    1856, 1392, 60, 0}, {
    1856, 1392, 75, 0}, {
    1920, 1200, 60, 1}, {
    1920, 1200, 60, 0},
d717 4
a720 5
    {
    1920, 1200, 75, 0}, {
    1920, 1200, 85, 0}, {
    1920, 1440, 60, 0}, {
    1920, 1440, 75, 0},
d722 5
a726 5
    {
    0,0,0,0}, {
    0,0,0,0}, {
    0,0,0,0}, {
    0,0,0,0}, };
@


1.11
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d726 7
a732 1
1920, 1440, 75, 0},};
d741 1
a741 1
        for (j = 7; j > 0; j--) {
d744 2
a745 1
                modes = xf86ModesAdd(modes,
@


1.10
log
@Bugfix Update to xserver 1.11.3
@
text
@d48 2
a49 2
static void handle_detailed_rblank(struct detailed_monitor_section *det_mon,
                                   void *data)
d53 1
a53 1
            *(Bool*)data = TRUE;
d74 2
a75 1
static Bool quirk_prefer_large_60 (int scrnIndex, xf86MonPtr DDC)
d78 4
a81 5
    if (memcmp (DDC->vendor.name, "MAX", 4) == 0 &&
	((DDC->vendor.prod_id == 1516) ||
	(DDC->vendor.prod_id == 0x77e)))
	return TRUE;
    
d83 2
a84 3
    if (memcmp (DDC->vendor.name, "ACR", 4) == 0 &&
	DDC->vendor.prod_id == 44358)
	return TRUE;
d87 2
a88 3
    if (memcmp (DDC->vendor.name, "SAM", 4) == 0 &&
	DDC->vendor.prod_id == 596)
	return TRUE;
d91 2
a92 3
    if (memcmp (DDC->vendor.name, "SAM", 4) == 0 &&
	DDC->vendor.prod_id == 638)
	return TRUE;
d95 3
a97 4
    if (memcmp (DDC->vendor.name, "API", 4) == 0 &&
	DDC->vendor.prod_id == 0x7602)
	return TRUE;

d102 2
a103 1
static Bool quirk_prefer_large_75 (int scrnIndex, xf86MonPtr DDC)
d106 2
a107 3
    if (memcmp (DDC->vendor.name, "FCM", 4) == 0 &&
	DDC->vendor.prod_id == 13600)
	return TRUE;
d112 2
a113 1
static Bool quirk_detailed_h_in_cm (int scrnIndex, xf86MonPtr DDC)
d116 2
a117 3
    if (memcmp (DDC->vendor.name, "FCM", 4) == 0 &&
	DDC->vendor.prod_id == 13600)
	return TRUE;
d122 2
a123 1
static Bool quirk_detailed_v_in_cm (int scrnIndex, xf86MonPtr DDC)
d126 2
a127 3
    if (memcmp (DDC->vendor.name, "FCM", 4) == 0 &&
	DDC->vendor.prod_id == 13600)
	return TRUE;
d130 2
a131 3
    if (memcmp (DDC->vendor.name, "LPL", 4) == 0 &&
	DDC->vendor.prod_id == 47360)
	return TRUE;
d134 2
a135 3
    if (memcmp(DDC->vendor.name, "LPL", 4) == 0 &&
	DDC->vendor.prod_id == 0)
	return TRUE;
d139 2
a140 2
	DDC->vendor.prod_id == 0x2a00)
	return TRUE;
d143 2
a144 3
    if (memcmp (DDC->vendor.name, "LPL", 4) == 0 &&
	DDC->vendor.prod_id == 5750)
	return TRUE;
d147 2
a148 3
    if (memcmp (DDC->vendor.name, "SAM", 4) == 0 &&
	DDC->vendor.prod_id == 1157)
	return TRUE;
d153 2
a154 1
static Bool quirk_detailed_use_maximum_size (int scrnIndex, xf86MonPtr DDC)
d157 2
a158 3
    if (memcmp (DDC->vendor.name, "IVM", 4) == 0 &&
	DDC->vendor.prod_id == 6400)
	return TRUE;
d161 3
a163 3
    if (memcmp (DDC->vendor.name, "LGD", 4) == 0 &&
	DDC->vendor.prod_id == 0x7f01)
	return TRUE;
d168 2
a169 1
static Bool quirk_135_clock_too_high (int scrnIndex, xf86MonPtr DDC)
d172 3
a174 4
    if (memcmp (DDC->vendor.name, "EPI", 4) == 0 &&
	DDC->vendor.prod_id == 59264)
	return TRUE;
    
d178 2
a179 1
static Bool quirk_first_detailed_preferred (int scrnIndex, xf86MonPtr DDC)
d182 6
a187 8
    if (memcmp (DDC->vendor.name, "PHL", 4) == 0 &&
	DDC->vendor.prod_id == 57364)
	return TRUE;

    /* Proview AY765C 17" LCD. See bug #15160*/
    if (memcmp (DDC->vendor.name, "PTS", 4) == 0 &&
	DDC->vendor.prod_id == 765)
	return TRUE;
d190 2
a191 3
    if (memcmp (DDC->vendor.name, "ACR", 4) == 0 &&
	DDC->vendor.prod_id == 2423)
	return TRUE;
d194 2
a195 3
    if (memcmp (DDC->vendor.name, "PEA", 4) == 0 &&
	DDC->vendor.prod_id == 9003)
	return TRUE;
d200 2
a201 1
static Bool quirk_detailed_sync_pp(int scrnIndex, xf86MonPtr DDC)
d204 2
a205 3
    if (memcmp (DDC->vendor.name, "SAM", 4) == 0 &&
	DDC->vendor.prod_id == 541)
	return TRUE;
d210 2
a211 1
static Bool quirk_dvi_single_link(int scrnIndex, xf86MonPtr DDC)
d214 3
a216 3
    if (memcmp (DDC->vendor.name, "APL", 4) == 0 &&
	DDC->vendor.prod_id == 0x921c)
	return TRUE;
d221 3
a223 3
    Bool	(*detect) (int scrnIndex, xf86MonPtr DDC);
    ddc_quirk_t	quirk;
    char	*description;
d228 5
a232 3
	quirk_prefer_large_60,   DDC_QUIRK_PREFER_LARGE_60,
	"Detailed timing is not preferred, use largest mode at 60Hz"
    },
d234 2
a235 3
	quirk_135_clock_too_high,   DDC_QUIRK_135_CLOCK_TOO_HIGH,
	"Recommended 135MHz pixel clock is too high"
    },
d237 2
a238 3
	quirk_prefer_large_75,   DDC_QUIRK_PREFER_LARGE_75,
	"Detailed timing is not preferred, use largest mode at 75Hz"
    },
d240 2
a241 3
	quirk_detailed_h_in_cm,   DDC_QUIRK_DETAILED_H_IN_CM,
	"Detailed timings give horizontal size in cm."
    },
d243 2
a244 3
	quirk_detailed_v_in_cm,   DDC_QUIRK_DETAILED_V_IN_CM,
	"Detailed timings give vertical size in cm."
    },
d246 2
a247 3
	quirk_detailed_use_maximum_size,   DDC_QUIRK_DETAILED_USE_MAXIMUM_SIZE,
	"Use maximum size instead of detailed timing sizes."
    },
d249 2
a250 3
	quirk_first_detailed_preferred, DDC_QUIRK_FIRST_DETAILED_PREFERRED,
	"First detailed timing was not marked as preferred."
    },
d252 2
a253 3
	quirk_detailed_sync_pp, DDC_QUIRK_DETAILED_SYNC_PP,
	"Use +hsync +vsync for detailed timing."
    },
d255 2
a256 7
	quirk_dvi_single_link, DDC_QUIRK_DVI_SINGLE_LINK,
	"Forcing maximum pixel clock to single DVI link."
    },
    { 
	NULL,		DDC_QUIRK_NONE,
	"No known quirks"
    },
d272 17
a288 17
    { MODEPREFIX,    40000,  800,  840,  968, 1056, 0,  600,  601,  605,  628, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 800x600@@60Hz */
    { MODEPREFIX,    36000,  800,  824,  896, 1024, 0,  600,  601,  603,  625, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 800x600@@56Hz */
    { MODEPREFIX,    31500,  640,  656,  720,  840, 0,  480,  481,  484,  500, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 640x480@@75Hz */
    { MODEPREFIX,    31500,  640,  664,  704,  832, 0,  480,  489,  492,  520, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 640x480@@72Hz */
    { MODEPREFIX,    30240,  640,  704,  768,  864, 0,  480,  483,  486,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 640x480@@67Hz */
    { MODEPREFIX,    25175,  640,  656,  752,  800, 0,  480,  490,  492,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 640x480@@60Hz */
    { MODEPREFIX,    35500,  720,  738,  846,  900, 0,  400,  421,  423,  449, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 720x400@@88Hz */
    { MODEPREFIX,    28320,  720,  738,  846,  900, 0,  400,  412,  414,  449, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 720x400@@70Hz */
    { MODEPREFIX,   135000, 1280, 1296, 1440, 1688, 0, 1024, 1025, 1028, 1066, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1280x1024@@75Hz */
    { MODEPREFIX,    78750, 1024, 1040, 1136, 1312, 0,  768,  769,  772,  800, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1024x768@@75Hz */
    { MODEPREFIX,    75000, 1024, 1048, 1184, 1328, 0,  768,  771,  777,  806, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 1024x768@@70Hz */
    { MODEPREFIX,    65000, 1024, 1048, 1184, 1344, 0,  768,  771,  777,  806, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 1024x768@@60Hz */
    { MODEPREFIX,    44900, 1024, 1032, 1208, 1264, 0,  768,  768,  772,  817, 0, V_PHSYNC | V_PVSYNC | V_INTERLACE, MODESUFFIX }, /* 1024x768@@43Hz */
    { MODEPREFIX,    57284,  832,  864,  928, 1152, 0,  624,  625,  628,  667, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 832x624@@75Hz */
    { MODEPREFIX,    49500,  800,  816,  896, 1056, 0,  600,  601,  604,  625, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 800x600@@75Hz */
    { MODEPREFIX,    50000,  800,  856,  976, 1040, 0,  600,  637,  643,  666, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 800x600@@72Hz */
    { MODEPREFIX,   108000, 1152, 1216, 1344, 1600, 0,  864,  865,  868,  900, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1152x864@@75Hz */
d293 1
a293 1
			ddc_quirk_t quirks)
d312 80
a391 80
    { MODEPREFIX,    31500,  640,  672,  736,  832, 0,  350,  382,  385,  445, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 640x350@@85Hz */
    { MODEPREFIX,    31500,  640,  672,  736,  832, 0,  400,  401,  404,  445, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 640x400@@85Hz */
    { MODEPREFIX,    35500,  720,  756,  828,  936, 0,  400,  401,  404,  446, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 720x400@@85Hz */
    { MODEPREFIX,    25175,  640,  656,  752,  800, 0,  480,  490,  492,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 640x480@@60Hz */
    { MODEPREFIX,    31500,  640,  664,  704,  832, 0,  480,  489,  492,  520, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 640x480@@72Hz */
    { MODEPREFIX,    31500,  640,  656,  720,  840, 0,  480,  481,  484,  500, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 640x480@@75Hz */
    { MODEPREFIX,    36000,  640,  696,  752,  832, 0,  480,  481,  484,  509, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 640x480@@85Hz */
    { MODEPREFIX,    36000,  800,  824,  896, 1024, 0,  600,  601,  603,  625, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 800x600@@56Hz */
    { MODEPREFIX,    40000,  800,  840,  968, 1056, 0,  600,  601,  605,  628, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 800x600@@60Hz */
    { MODEPREFIX,    50000,  800,  856,  976, 1040, 0,  600,  637,  643,  666, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 800x600@@72Hz */
    { MODEPREFIX,    49500,  800,  816,  896, 1056, 0,  600,  601,  604,  625, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 800x600@@75Hz */
    { MODEPREFIX,    56250,  800,  832,  896, 1048, 0,  600,  601,  604,  631, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 800x600@@85Hz */
    { MODEPREFIX,    73250,  800,  848,  880,  960, 0,  600,  603,  607,  636, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 800x600@@120Hz RB */
    { MODEPREFIX,    33750,  848,  864,  976, 1088, 0,  480,  486,  494,  517, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 848x480@@60Hz */
    { MODEPREFIX,    44900, 1024, 1032, 1208, 1264, 0,  768,  768,  772,  817, 0, V_PHSYNC | V_PVSYNC | V_INTERLACE, MODESUFFIX }, /* 1024x768@@43Hz (interlaced) */
    { MODEPREFIX,    65000, 1024, 1048, 1184, 1344, 0,  768,  771,  777,  806, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 1024x768@@60Hz */
    { MODEPREFIX,    75000, 1024, 1048, 1184, 1328, 0,  768,  771,  777,  806, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 1024x768@@70Hz */
    { MODEPREFIX,    78750, 1024, 1040, 1136, 1312, 0,  768,  769,  772,  800, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1024x768@@75Hz */
    { MODEPREFIX,    94500, 1024, 1072, 1168, 1376, 0,  768,  769,  772,  808, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1024x768@@85Hz */
    { MODEPREFIX,   115500, 1024, 1072, 1104, 1184, 0,  768,  771,  775,  813, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1024x768@@120Hz RB */
    { MODEPREFIX,   108000, 1152, 1216, 1344, 1600, 0,  864,  865,  868,  900, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1152x864@@75Hz */
    { MODEPREFIX,    68250, 1280, 1328, 1360, 1440, 0,  768,  771,  778,  790, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1280x768@@60Hz RB */
    { MODEPREFIX,    79500, 1280, 1344, 1472, 1664, 0,  768,  771,  778,  798, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1280x768@@60Hz */
    { MODEPREFIX,   102250, 1280, 1360, 1488, 1696, 0,  768,  771,  778,  805, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1280x768@@75Hz */
    { MODEPREFIX,   117500, 1280, 1360, 1496, 1712, 0,  768,  771,  778,  809, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1280x768@@85Hz */
    { MODEPREFIX,   140250, 1280, 1328, 1360, 1440, 0,  768,  771,  778,  813, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1280x768@@120Hz RB */
    { MODEPREFIX,    71000, 1280, 1328, 1360, 1440, 0,  800,  803,  809,  823, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1280x800@@60Hz RB */
    { MODEPREFIX,    83500, 1280, 1352, 1480, 1680, 0,  800,  803,  809,  831, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1280x800@@60Hz */
    { MODEPREFIX,   106500, 1280, 1360, 1488, 1696, 0,  800,  803,  809,  838, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1280x800@@75Hz */
    { MODEPREFIX,   122500, 1280, 1360, 1496, 1712, 0,  800,  803,  809,  843, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1280x800@@85Hz */
    { MODEPREFIX,   146250, 1280, 1328, 1360, 1440, 0,  800,  803,  809,  847, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1280x800@@120Hz RB */
    { MODEPREFIX,   108000, 1280, 1376, 1488, 1800, 0,  960,  961,  964, 1000, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1280x960@@60Hz */
    { MODEPREFIX,   148500, 1280, 1344, 1504, 1728, 0,  960,  961,  964, 1011, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1280x960@@85Hz */
    { MODEPREFIX,   175500, 1280, 1328, 1360, 1440, 0,  960,  963,  967, 1017, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1280x960@@120Hz RB */
    { MODEPREFIX,   108000, 1280, 1328, 1440, 1688, 0, 1024, 1025, 1028, 1066, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1280x1024@@60Hz */
    { MODEPREFIX,   135000, 1280, 1296, 1440, 1688, 0, 1024, 1025, 1028, 1066, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1280x1024@@75Hz */
    { MODEPREFIX,   157500, 1280, 1344, 1504, 1728, 0, 1024, 1025, 1028, 1072, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1280x1024@@85Hz */
    { MODEPREFIX,   187250, 1280, 1328, 1360, 1440, 0, 1024, 1027, 1034, 1084, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1280x1024@@120Hz RB */
    { MODEPREFIX,    85500, 1360, 1424, 1536, 1792, 0,  768,  771,  777,  795, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1360x768@@60Hz */
    { MODEPREFIX,   148250, 1360, 1408, 1440, 1520, 0,  768,  771,  776,  813, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1360x768@@120Hz RB */
    { MODEPREFIX,   101000, 1400, 1448, 1480, 1560, 0, 1050, 1053, 1057, 1080, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1400x1050@@60Hz RB */
    { MODEPREFIX,   121750, 1400, 1488, 1632, 1864, 0, 1050, 1053, 1057, 1089, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1400x1050@@60Hz */
    { MODEPREFIX,   156000, 1400, 1504, 1648, 1896, 0, 1050, 1053, 1057, 1099, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1400x1050@@75Hz */
    { MODEPREFIX,   179500, 1400, 1504, 1656, 1912, 0, 1050, 1053, 1057, 1105, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1400x1050@@85Hz */
    { MODEPREFIX,   208000, 1400, 1448, 1480, 1560, 0, 1050, 1053, 1057, 1112, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1400x1050@@120Hz RB */
    { MODEPREFIX,    88750, 1440, 1488, 1520, 1600, 0,  900,  903,  909,  926, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1440x900@@60Hz RB */
    { MODEPREFIX,   106500, 1440, 1520, 1672, 1904, 0,  900,  903,  909,  934, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1440x900@@60Hz */
    { MODEPREFIX,   136750, 1440, 1536, 1688, 1936, 0,  900,  903,  909,  942, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1440x900@@75Hz */
    { MODEPREFIX,   157000, 1440, 1544, 1696, 1952, 0,  900,  903,  909,  948, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1440x900@@85Hz */
    { MODEPREFIX,   182750, 1440, 1488, 1520, 1600, 0,  900,  903,  909,  953, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1440x900@@120Hz RB */
    { MODEPREFIX,   162000, 1600, 1664, 1856, 2160, 0, 1200, 1201, 1204, 1250, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1600x1200@@60Hz */
    { MODEPREFIX,   175500, 1600, 1664, 1856, 2160, 0, 1200, 1201, 1204, 1250, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1600x1200@@65Hz */
    { MODEPREFIX,   189000, 1600, 1664, 1856, 2160, 0, 1200, 1201, 1204, 1250, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1600x1200@@70Hz */
    { MODEPREFIX,   202500, 1600, 1664, 1856, 2160, 0, 1200, 1201, 1204, 1250, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1600x1200@@75Hz */
    { MODEPREFIX,   229500, 1600, 1664, 1856, 2160, 0, 1200, 1201, 1204, 1250, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1600x1200@@85Hz */
    { MODEPREFIX,   268250, 1600, 1648, 1680, 1760, 0, 1200, 1203, 1207, 1271, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1600x1200@@120Hz RB */
    { MODEPREFIX,   119000, 1680, 1728, 1760, 1840, 0, 1050, 1053, 1059, 1080, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1680x1050@@60Hz RB */
    { MODEPREFIX,   146250, 1680, 1784, 1960, 2240, 0, 1050, 1053, 1059, 1089, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1680x1050@@60Hz */
    { MODEPREFIX,   187000, 1680, 1800, 1976, 2272, 0, 1050, 1053, 1059, 1099, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1680x1050@@75Hz */
    { MODEPREFIX,   214750, 1680, 1808, 1984, 2288, 0, 1050, 1053, 1059, 1105, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1680x1050@@85Hz */
    { MODEPREFIX,   245500, 1680, 1728, 1760, 1840, 0, 1050, 1053, 1059, 1112, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1680x1050@@120Hz RB */
    { MODEPREFIX,   204750, 1792, 1920, 2120, 2448, 0, 1344, 1345, 1348, 1394, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1792x1344@@60Hz */
    { MODEPREFIX,   261000, 1792, 1888, 2104, 2456, 0, 1344, 1345, 1348, 1417, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1792x1344@@75Hz */
    { MODEPREFIX,   333250, 1792, 1840, 1872, 1952, 0, 1344, 1347, 1351, 1423, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1792x1344@@120Hz RB */
    { MODEPREFIX,   218250, 1856, 1952, 2176, 2528, 0, 1392, 1393, 1396, 1439, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1856x1392@@60Hz */
    { MODEPREFIX,   288000, 1856, 1984, 2208, 2560, 0, 1392, 1393, 1396, 1500, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1856x1392@@75Hz */
    { MODEPREFIX,   356500, 1856, 1904, 1936, 2016, 0, 1392, 1395, 1399, 1474, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1856x1392@@120Hz RB */
    { MODEPREFIX,   154000, 1920, 1968, 2000, 2080, 0, 1200, 1203, 1209, 1235, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1920x1200@@60Hz RB */
    { MODEPREFIX,   193250, 1920, 2056, 2256, 2592, 0, 1200, 1203, 1209, 1245, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1920x1200@@60Hz */
    { MODEPREFIX,   245250, 1920, 2056, 2264, 2608, 0, 1200, 1203, 1209, 1255, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1920x1200@@75Hz */
    { MODEPREFIX,   281250, 1920, 2064, 2272, 2624, 0, 1200, 1203, 1209, 1262, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1920x1200@@85Hz */
    { MODEPREFIX,   317000, 1920, 1968, 2000, 2080, 0, 1200, 1203, 1209, 1271, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1920x1200@@120Hz RB */
    { MODEPREFIX,   234000, 1920, 2048, 2256, 2600, 0, 1440, 1441, 1444, 1500, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1920x1440@@60Hz */
    { MODEPREFIX,   297000, 1920, 2064, 2288, 2640, 0, 1440, 1441, 1444, 1500, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 1920x1440@@75Hz */
    { MODEPREFIX,   380500, 1920, 1968, 2000, 2080, 0, 1440, 1443, 1447, 1525, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 1920x1440@@120Hz RB */
    { MODEPREFIX,   268500, 2560, 2608, 2640, 2720, 0, 1600, 1603, 1609, 1646, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 2560x1600@@60Hz RB */
    { MODEPREFIX,   348500, 2560, 2752, 3032, 3504, 0, 1600, 1603, 1609, 1658, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 2560x1600@@60Hz */
    { MODEPREFIX,   443250, 2560, 2768, 3048, 3536, 0, 1600, 1603, 1609, 1672, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 2560x1600@@75Hz */
    { MODEPREFIX,   505250, 2560, 2768, 3048, 3536, 0, 1600, 1603, 1609, 1682, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 2560x1600@@85Hz */
    { MODEPREFIX,   552750, 2560, 2608, 2640, 2720, 0, 1600, 1603, 1609, 1694, 0, V_PHSYNC | V_NVSYNC, MODESUFFIX }, /* 2560x1600@@120Hz RB */
d402 4
a405 4
	if (DDC->ver.revision >= 4 && CVT_SUPPORTED(DDC->features.msc)) {
	    return LEVEL_CVT;
	}
	return LEVEL_GTF;
d411 1
a411 1
ModeRefresh(const DisplayModeRec *mode)
d413 1
a413 1
    return (int)(xf86ModeVRefresh(mode) + 0.5);
d428 1
a428 1
	ret = &DMTModes[i];
d430 2
a431 2
	if (!rb && xf86ModeIsReduced(ret))
	    continue;
d433 3
a435 4
	if (ret->HDisplay == hsize &&
	    ret->VDisplay == vsize &&
	    refresh == ModeRefresh(ret))
	    return xf86DuplicateMode(ret);
d460 1
a460 1
			   int timing_level, Bool rb)
d466 31
a496 30
	hsize = timing[i].hsize;
	vsize = timing[i].vsize;
	refresh = timing[i].refresh;

	/* HDTV hack, because you can't say 1366 */
	if (refresh == 60 &&
	    ((hsize == 1360 && vsize == 765) ||
	     (hsize == 1368 && vsize == 769))) {
	    Mode = xf86CVTMode(1366, 768, 60, FALSE, FALSE);
	    Mode->HDisplay = 1366;
	    Mode->HSyncStart--;
	    Mode->HSyncEnd--;
	} else if (hsize && vsize && refresh) {
	    Mode = FindDMTMode(hsize, vsize, refresh, rb);

	    if (!Mode) {
		if (timing_level == LEVEL_CVT)
		    /* pass rb here too? */
		    Mode = xf86CVTMode(hsize, vsize, refresh, FALSE, FALSE);
		else if (timing_level == LEVEL_GTF)
		    Mode = xf86GTFMode(hsize, vsize, refresh, FALSE, FALSE);
	    }

	}

	if (Mode) {
	    Mode->type = M_T_DRIVER;
	    Modes = xf86ModesAdd(Modes, Mode);
	}
	Mode = NULL;
d514 1
a514 1
	int w, h;
d516 10
a525 9
	{ 1920, 1080 },
	{  720,  480 },
	{ 1440,  480 },
	{ 2880,  480 },
	{  720,  576 },
	{ 1440,  576 },
	{ 2880,  576 },
    };
    static const int n_modes = sizeof(cea_interlaced)/sizeof(cea_interlaced[0]);
d529 8
a536 8
	if ((mode->HDisplay == cea_interlaced[i].w) &&
	    (mode->VDisplay == cea_interlaced[i].h / 2)) {
	    mode->VDisplay *= 2;
	    mode->VSyncStart *= 2;
	    mode->VSyncEnd *= 2;
	    mode->VTotal *= 2;
	    mode->VTotal |= 1;
	}
d547 1
a547 1
			  Bool preferred, ddc_quirk_t quirks)
d558 4
a561 4
	xf86DrvMsg(scrnIndex, X_INFO,
		   "%s: Ignoring tiny %dx%d mode\n", __func__,
		   timing->h_active, timing->v_active);
	return NULL;
d567 1
a567 1
		   "%s: Ignoring: We don't handle stereo.\n", __func__);
d573 3
a575 3
         xf86DrvMsg(scrnIndex, X_INFO,
		    "%s: %dx%d Warning: We only handle separate"
                    " sync.\n", __func__, timing->h_active, timing->v_active);
d582 1
a582 1
	Mode->type |= M_T_PREFERRED;
d584 1
a584 2
    if( ( quirks & DDC_QUIRK_135_CLOCK_TOO_HIGH ) &&
	timing->clock == 135000000 )
d601 2
a602 2
	free(Mode);
	return NULL;
d608 1
a608 1
	DDCModeDoInterlaceQuirks(Mode);
d611 1
a611 1
	Mode->Flags |= V_PVSYNC | V_PHSYNC;
d613 9
a621 9
	if (timing->misc & 0x02)
	    Mode->Flags |= V_PVSYNC;
	else
	    Mode->Flags |= V_NVSYNC;

	if (timing->misc & 0x01)
	    Mode->Flags |= V_PHSYNC;
	else
	    Mode->Flags |= V_NHSYNC;
d636 24
a659 17
	if (t[i].height) {
	    if (t[i].rates & 0x10)
		modes = xf86ModesAdd(modes,
			xf86CVTMode(t[i].width, t[i].height, 50, 0, 0));
	    if (t[i].rates & 0x08)
		modes = xf86ModesAdd(modes,
			xf86CVTMode(t[i].width, t[i].height, 60, 0, 0));
	    if (t[i].rates & 0x04)
		modes = xf86ModesAdd(modes,
			xf86CVTMode(t[i].width, t[i].height, 75, 0, 0));
	    if (t[i].rates & 0x02)
		modes = xf86ModesAdd(modes,
			xf86CVTMode(t[i].width, t[i].height, 85, 0, 0));
	    if (t[i].rates & 0x01)
		modes = xf86ModesAdd(modes,
			xf86CVTMode(t[i].width, t[i].height, 60, 1, 0));
	} else break;
d672 55
a726 50
    { 640, 350, 85, 0 },
    { 640, 400, 85, 0 },
    { 720, 400, 85, 0 },
    { 640, 480, 85, 0 },
    { 848, 480, 60, 0 },
    { 800, 600, 85, 0 },
    { 1024, 768, 85, 0 },
    { 1152, 864, 75, 0 },
    /* byte 7 */
    { 1280, 768, 60, 1 },
    { 1280, 768, 60, 0 },
    { 1280, 768, 75, 0 },
    { 1280, 768, 85, 0 },
    { 1280, 960, 60, 0 },
    { 1280, 960, 85, 0 },
    { 1280, 1024, 60, 0 },
    { 1280, 1024, 85, 0 },
    /* byte 8 */
    { 1360, 768, 60, 0 },
    { 1440, 900, 60, 1 },
    { 1440, 900, 60, 0 },
    { 1440, 900, 75, 0 },
    { 1440, 900, 85, 0 },
    { 1400, 1050, 60, 1 },
    { 1400, 1050, 60, 0 },
    { 1400, 1050, 75, 0 },
    /* byte 9 */
    { 1400, 1050, 85, 0 },
    { 1680, 1050, 60, 1 },
    { 1680, 1050, 60, 0 },
    { 1680, 1050, 75, 0 },
    { 1680, 1050, 85, 0 },
    { 1600, 1200, 60, 0 },
    { 1600, 1200, 65, 0 },
    { 1600, 1200, 70, 0 },
    /* byte 10 */
    { 1600, 1200, 75, 0 },
    { 1600, 1200, 85, 0 },
    { 1792, 1344, 60, 0 },
    { 1792, 1344, 85, 0 },
    { 1856, 1392, 60, 0 },
    { 1856, 1392, 75, 0 },
    { 1920, 1200, 60, 1 },
    { 1920, 1200, 60, 0 },
    /* byte 11 */
    { 1920, 1200, 75, 0 },
    { 1920, 1200, 85, 0 },
    { 1920, 1440, 60, 0 },
    { 1920, 1440, 75, 0 },
};
d735 10
a744 10
	for (j = 7; j > 0; j--) {
	    if (est[i] & (1 << j)) {
		m = (i * 8) + (7 - j);
		modes = xf86ModesAdd(modes,
				     FindDMTMode(EstIIIModes[m].w,
						 EstIIIModes[m].h,
						 EstIIIModes[m].r,
						 EstIIIModes[m].rb));
	    }
	}
d776 1
a776 1
            Mode->HSync = ((float) Mode->Clock ) / ((float) Mode->HTotal);
d779 1
a779 1
            Mode->VRefresh = (1000.0 * ((float) Mode->Clock)) / 
d801 1
a801 1
    ddc_quirk_t	quirks;
d806 7
a812 7
	if (ddc_quirks[i].detect (scrnIndex, DDC)) {
	    if (verbose) {
		xf86DrvMsg (scrnIndex, X_INFO, "    EDID quirk: %s\n",
			    ddc_quirks[i].description);
	    }
	    quirks |= ddc_quirks[i].quirk;
	}
d818 3
a820 3
void xf86DetTimingApplyQuirks(struct detailed_monitor_section *det_mon,
                              ddc_quirk_t quirks,
                              int hsize, int vsize)
d846 1
a846 1
    ddc_quirk_t quirks = xf86DDCDetectQuirks (scrnIndex, DDC, FALSE);
d851 1
a851 2
                                 DDC->features.hsize,
                                 DDC->features.vsize);
d861 1
a861 1
			   float target_refresh)
d863 7
a869 1
	DisplayModePtr	mode, best = modes;
d871 18
a888 29
	for (mode = modes; mode; mode = mode->next)
	{
	    mode->type &= ~M_T_PREFERRED;

	    if (mode == best) continue;

	    if (mode->HDisplay * mode->VDisplay >
		best->HDisplay * best->VDisplay)
	    {
		best = mode;
		continue;
	    }
	    if (mode->HDisplay * mode->VDisplay ==
		best->HDisplay * best->VDisplay)
	    {
		double	mode_refresh = xf86ModeVRefresh (mode);
		double	best_refresh = xf86ModeVRefresh (best);
		double	mode_dist = fabs(mode_refresh - target_refresh);
		double	best_dist = fabs(best_refresh - target_refresh);

		if (mode_dist < best_dist)
		{
		    best = mode;
		    continue;
		}
	    }
	}
	if (best)
	    best->type |= M_T_PREFERRED;
d893 64
a956 64
    { MODEPREFIX,    25175,  640,  656,  752,  800, 0,  480,  490,  492,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 1:640x480@@60Hz */
    { MODEPREFIX,    27000,  720,  736,  798,  858, 0,  480,  489,  495,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 2:720x480@@60Hz */
    { MODEPREFIX,    27000,  720,  736,  798,  858, 0,  480,  489,  495,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 3:720x480@@60Hz */
    { MODEPREFIX,    74250, 1280, 1390, 1430, 1650, 0,  720,  725,  730,  750, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* VIC 4: 1280x720@@60Hz */
    { MODEPREFIX,    74250, 1920, 2008, 2052, 2200, 0, 1080, 1084, 1094, 1125, 0, V_PHSYNC | V_PVSYNC | V_INTERLACE, MODESUFFIX }, /* VIC 5:1920x1080i@@60Hz */
    { MODEPREFIX,    27000, 1440, 1478, 1602, 1716, 0,  480,  488,  494,  525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX }, /* VIC 6:1440x480i@@60Hz */
    { MODEPREFIX,    27000, 1440, 1478, 1602, 1716, 0,  480,  488,  494,  525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX }, /* VIC 7:1440x480i@@60Hz */
    { MODEPREFIX,    27000, 1440, 1478, 1602, 1716, 0,  240,  244,  247,  262, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 8:1440x240@@60Hz */
    { MODEPREFIX,    27000, 1440, 1478, 1602, 1716, 0,  240,  244,  247,  262, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 9:1440x240@@60Hz */
    { MODEPREFIX,    54000, 2880, 2956, 3204, 3432, 0,  480,  488,  494,  525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX }, /* VIC 10:2880x480i@@60Hz */
    { MODEPREFIX,    54000, 2880, 2956, 3204, 3432, 0,  480,  488,  494,  525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX }, /* VIC 11:2880x480i@@60Hz */
    { MODEPREFIX,    54000, 2880, 2956, 3204, 3432, 0,  240,  244,  247,  262, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 12:2880x240@@60Hz */
    { MODEPREFIX,    54000, 2880, 2956, 3204, 3432, 0,  240,  244,  247,  262, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 13:2880x240@@60Hz */
    { MODEPREFIX,    54000, 1440, 1472, 1596, 1716, 0,  480,  489,  495,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 14:1440x480@@60Hz */
    { MODEPREFIX,    54000, 1440, 1472, 1596, 1716, 0,  480,  489,  495,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 15:1440x480@@60Hz */
    { MODEPREFIX,   148500, 1920, 2008, 2052, 2200, 0, 1080, 1084, 1089, 1125, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* VIC 16:1920x1080@@60Hz */
    { MODEPREFIX,    27000,  720,  732,  796,  864, 0,  576,  581,  586,  625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 17:720x576@@50Hz */
    { MODEPREFIX,    27000,  720,  732,  796,  864, 0,  576,  581,  586,  625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 18:720x576@@50Hz */
    { MODEPREFIX,    74250, 1280, 1720, 1760, 1980, 0,  720,  725,  730,  750, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* VIC 19: 1280x720@@50Hz */
    { MODEPREFIX,    74250, 1920, 2448, 2492, 2640, 0, 1080, 1084, 1094, 1125, 0, V_PHSYNC | V_PVSYNC | V_INTERLACE, MODESUFFIX }, /* VIC 20:1920x1080i@@50Hz */
    { MODEPREFIX,    27000, 1440, 1464, 1590, 1728, 0,  576,  580,  586,  625, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX }, /* VIC 21:1440x576i@@50Hz */
    { MODEPREFIX,    27000, 1440, 1464, 1590, 1728, 0,  576,  580,  586,  625, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX }, /* VIC 22:1440x576i@@50Hz */
    { MODEPREFIX,    27000, 1440, 1464, 1590, 1728, 0,  288,  290,  293,  312, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 23:1440x288@@50Hz */
    { MODEPREFIX,    27000, 1440, 1464, 1590, 1728, 0,  288,  290,  293,  312, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 24:1440x288@@50Hz */
    { MODEPREFIX,    54000, 2880, 2928, 3180, 3456, 0,  576,  580,  586,  625, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX }, /* VIC 25:2880x576i@@50Hz */
    { MODEPREFIX,    54000, 2880, 2928, 3180, 3456, 0,  576,  580,  586,  625, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX }, /* VIC 26:2880x576i@@50Hz */
    { MODEPREFIX,    54000, 2880, 2928, 3180, 3456, 0,  288,  290,  293,  312, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 27:2880x288@@50Hz */
    { MODEPREFIX,    54000, 2880, 2928, 3180, 3456, 0,  288,  290,  293,  312, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 28:2880x288@@50Hz */
    { MODEPREFIX,    54000, 1440, 1464, 1592, 1728, 0,  576,  581,  586,  625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 29:1440x576@@50Hz */
    { MODEPREFIX,    54000, 1440, 1464, 1592, 1728, 0,  576,  581,  586,  625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 30:1440x576@@50Hz */
    { MODEPREFIX,   148500, 1920, 2448, 2492, 2640, 0, 1080, 1084, 1089, 1125, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* VIC 31:1920x1080@@50Hz */
    { MODEPREFIX,    74250, 1920, 2558, 2602, 2750, 0, 1080, 1084, 1089, 1125, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* VIC 32:1920x1080@@24Hz */
    { MODEPREFIX,    74250, 1920, 2448, 2492, 2640, 0, 1080, 1084, 1089, 1125, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* VIC 33:1920x1080@@25Hz */
    { MODEPREFIX,    74250, 1920, 2008, 2052, 2200, 0, 1080, 1084, 1089, 1125, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* VIC 34:1920x1080@@30Hz */
    { MODEPREFIX,   108000, 2880, 2944, 3192, 3432, 0,  480,  489,  495,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 35:2880x480@@60Hz */
    { MODEPREFIX,   108000, 2880, 2944, 3192, 3432, 0,  480,  489,  495,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 36:2880x480@@60Hz */
    { MODEPREFIX,   108000, 2880, 2928, 3184, 3456, 0,  576,  581,  586,  625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 37:2880x576@@50Hz */
    { MODEPREFIX,   108000, 2880, 2928, 3184, 3456, 0,  576,  581,  586,  625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 38:2880x576@@50Hz */
    { MODEPREFIX,    72000, 1920, 1952, 2120, 2304, 0, 1080, 1126, 1136, 1250, 0, V_PHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX }, /* VIC 39:1920x1080i@@50Hz */
    { MODEPREFIX,   148500, 1920, 2448, 2492, 2640, 0, 1080, 1084, 1094, 1125, 0, V_PHSYNC | V_PVSYNC | V_INTERLACE, MODESUFFIX }, /* VIC 40:1920x1080i@@100Hz */
    { MODEPREFIX,   148500, 1280, 1720, 1760, 1980, 0,  720,  725,  730,  750, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* VIC 41:1280x720@@100Hz */
    { MODEPREFIX,    54000,  720,  732,  796,  864, 0,  576,  581,  586,  625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 42:720x576@@100Hz */
    { MODEPREFIX,    54000,  720,  732,  796,  864, 0,  576,  581,  586,  625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 43:720x576@@100Hz */
    { MODEPREFIX,    54000, 1440, 1464, 1590, 1728, 0,  576,  580,  586,  625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 44:1440x576i@@100Hz */
    { MODEPREFIX,    54000, 1440, 1464, 1590, 1728, 0,  576,  580,  586,  625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 45:1440x576i@@100Hz */
    { MODEPREFIX,   148500, 1920, 2008, 2052, 2200, 0, 1080, 1084, 1094, 1125, 0, V_PHSYNC | V_PVSYNC | V_INTERLACE, MODESUFFIX }, /* VIC 46:1920x1080i@@120Hz */
    { MODEPREFIX,   148500, 1280, 1390, 1430, 1650, 0,  720,  725,  730,  750, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* VIC 47:1280x720@@120Hz */
    { MODEPREFIX,    54000,  720,  736,  798,  858, 0,  480,  489,  495,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 48:720x480@@120Hz */
    { MODEPREFIX,    54000,  720,  736,  798,  858, 0,  480,  489,  495,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 49:720x480@@120Hz */
    { MODEPREFIX,    54000, 1440, 1478, 1602, 1716, 0,  480,  488,  494,  525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX },/* VIC 50:1440x480i@@120Hz */
    { MODEPREFIX,    54000, 1440, 1478, 1602, 1716, 0,  480,  488,  494,  525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX },/* VIC 51:1440x480i@@120Hz */
    { MODEPREFIX,   108000,  720,  732,  796,  864, 0,  576,  581,  586,  625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 52:720x576@@200Hz */
    { MODEPREFIX,   108000,  720,  732,  796,  864, 0,  576,  581,  586,  625, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 53:720x576@@200Hz */
    { MODEPREFIX,   108000, 1440, 1464, 1590, 1728, 0,  576,  580,  586,  625, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX },/* VIC 54:1440x576i@@200Hz */
    { MODEPREFIX,   108000, 1440, 1464, 1590, 1728, 0,  576,  580,  586,  625, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX },/* VIC 55:1440x576i@@200Hz */
    { MODEPREFIX,   108000,  720,  736,  798,  858, 0,  480,  489,  495,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 56:720x480@@240Hz */
    { MODEPREFIX,   108000,  720,  736,  798,  858, 0,  480,  489,  495,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* VIC 57:720x480@@240Hz */
    { MODEPREFIX,   108000, 1440, 1478, 1602, 1716, 0,  480,  488,  494,  525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX },/* VIC 58:1440x480i@@240 */
    { MODEPREFIX,   108000, 1440, 1478, 1602, 1716, 0,  480,  488,  494,  525, 0, V_NHSYNC | V_NVSYNC | V_INTERLACE, MODESUFFIX },/* VIC 59:1440x480i@@240 */
    { MODEPREFIX,    59400, 1280, 3040, 3080, 3300, 0,  720,  725,  730,  750, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* VIC 60: 1280x720@@24Hz */
    { MODEPREFIX,    74250, 1280, 3700, 3740, 3960, 0,  720,  725,  730,  750, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* VIC 61: 1280x720@@25Hz */
    { MODEPREFIX,    74250, 1280, 3040, 3080, 3300, 0,  720,  725,  730,  750, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* VIC 62: 1280x720@@30Hz */
    { MODEPREFIX,   297000, 1920, 2008, 2052, 2200, 0, 1080, 1084, 1089, 1125, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* VIC 63: 1920x1080@@120Hz */
    { MODEPREFIX,   297000, 1920, 2448, 2492, 2640, 0, 1080, 1084, 1094, 1125, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* VIC 64:1920x1080@@100Hz */
d960 2
a961 1
static void handle_cea_svd(struct cea_video_block *video, void *data)
d967 1
a967 1
    vid = video ->video_code & 0x7f;
d969 2
a970 2
	Mode = xf86DuplicateMode(CEAVideoModes + vid);
	*Modes = xf86ModesAdd(*Modes, Mode);
d979 1
a979 3
    xf86ForEachVideoBlock(MonPtr,
                          handle_cea_svd,
                          &Modes);
d987 1
a987 1
    DisplayModePtr  Modes;
d993 2
a994 2
static void handle_detailed_modes(struct detailed_monitor_section *det_mon,
	                          void *data)
d996 2
a997 2
    DisplayModePtr  Mode;
    struct det_modes_parameter *p = (struct det_modes_parameter *)data;
d999 2
a1000 3
    xf86DetTimingApplyQuirks(det_mon,p->quirks,
                             p->DDC->features.hsize,
                             p->DDC->features.vsize);
d1006 1
a1006 2
                                         p->preferred,
                                         p->quirks);
d1012 1
a1012 1
                                          p->quirks, p->timing_level,p->rb);
d1020 3
a1022 3
	Mode = DDCModesFromEstIII(det_mon->section.est_iii);
	p->Modes = xf86ModesAdd(p->Modes, Mode);
	break;
d1031 4
a1034 4
    DisplayModePtr  Modes = NULL, Mode;
    ddc_quirk_t	    quirks;
    Bool	    preferred, rb;
    int		    timing_level;
d1037 2
a1038 2
    xf86DrvMsg (scrnIndex, X_INFO, "EDID vendor \"%s\", prod id %d\n",
		DDC->vendor.name, DDC->vendor.prod_id);
d1044 1
a1044 1
	preferred = TRUE;
d1046 1
a1046 1
	preferred = TRUE;
d1048 1
a1048 1
	preferred = FALSE;
d1072 1
a1072 1
    Mode = DDCModesFromCEAExtension(scrnIndex,DDC);
d1076 1
a1076 1
	xf86DDCSetPreferredRefresh(scrnIndex, Modes, 60);
d1079 1
a1079 1
	xf86DDCSetPreferredRefresh(scrnIndex, Modes, 75);
d1094 2
a1095 2
static void handle_detailed_monset(struct detailed_monitor_section *det_mon,
                                   void *data)
d1098 2
a1099 2
    struct det_mon_parameter *p = (struct det_mon_parameter *)data;
    int scrnIndex = ((xf86MonPtr)(p->Monitor->DDC))->scrnIndex;
d1106 8
a1113 7
                    "Using EDID range info for horizontal sync\n");
                p->Monitor->hsync[p->Monitor->nHsync].lo =
                    det_mon->section.ranges.min_h;
                p->Monitor->hsync[p->Monitor->nHsync].hi =
                    det_mon->section.ranges.max_h;
                p->Monitor->nHsync++;
        } else {
d1115 1
a1115 1
                "Using hsync ranges from config file\n");
d1121 1
a1121 1
                    "Using EDID range info for vertical refresh\n");
d1127 2
a1128 1
        } else {
d1130 1
a1130 1
                "Using vrefresh ranges from config file\n");
d1160 2
a1161 2
	Monitor->widthmm = 10 * DDC->features.hsize;
	Monitor->heightmm = 10 * DDC->features.vsize;
d1201 2
a1202 1
        } else {
@


1.9
log
@Update to xserver 1.11.2
@
text
@d168 5
@


1.8
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@a643 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a671 1
#endif
a1026 1
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
a1030 1
#endif
@


1.7
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d148 5
d964 1
a964 1
    { MODEPREFIX,    74250, 3700, 3740, 1430, 3960, 0,  720,  725,  730,  750, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* VIC 61: 1280x720@@25Hz */
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d487 2
a488 2
	    Mode->VSyncStart--;
	    Mode->VSyncEnd--;
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d611 1
a611 1
	xfree(Mode);
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d48 8
d61 4
a64 9
	int i;
	for (i = 0; i < DET_TIMINGS; i++) {
	    struct detailed_monitor_section *det_mon = &DDC->det_mon[i];
	    if (det_mon->type == DS_RANGES)
		if (det_mon->section.ranges.supported_blanking & CVT_REDUCED)
		    return TRUE;
	}
	
	return FALSE;
a73 28
/*
 * Quirks to work around broken EDID data from various monitors.
 */

typedef enum {
    DDC_QUIRK_NONE = 0,
    /* First detailed mode is bogus, prefer largest mode at 60hz */
    DDC_QUIRK_PREFER_LARGE_60 = 1 << 0,
    /* 135MHz clock is too high, drop a bit */
    DDC_QUIRK_135_CLOCK_TOO_HIGH = 1 << 1,
    /* Prefer the largest mode at 75 Hz */
    DDC_QUIRK_PREFER_LARGE_75 = 1 << 2,
    /* Convert detailed timing's horizontal from units of cm to mm */
    DDC_QUIRK_DETAILED_H_IN_CM = 1 << 3,
    /* Convert detailed timing's vertical from units of cm to mm */
    DDC_QUIRK_DETAILED_V_IN_CM = 1 << 4,
    /* Detailed timing descriptors have bogus size values, so just take the
     * maximum size and use that.
     */
    DDC_QUIRK_DETAILED_USE_MAXIMUM_SIZE = 1 << 5,
    /* Monitor forgot to set the first detailed is preferred bit. */
    DDC_QUIRK_FIRST_DETAILED_PREFERRED = 1 << 6,
    /* use +hsync +vsync for detailed mode */
    DDC_QUIRK_DETAILED_SYNC_PP = 1 << 7,
    /* Force single-link DVI bandwidth limit */
    DDC_QUIRK_DVI_SINGLE_LINK = 1 << 8,
} ddc_quirk_t;

d138 15
a157 5
    /* Bug #10304: LGPhilipsLCD LP154W01-A5 */
    if (memcmp (DDC->vendor.name, "LPL", 4) == 0 &&
	(DDC->vendor.prod_id == 0 || DDC->vendor.prod_id == 0x2a00))
	return TRUE;

d249 1
a249 1
	"Detailed timings give sizes in cm."
d321 1
a321 1
static const DisplayModeRec DMTModes[] = {
d431 1
a431 1
static DisplayModePtr
d474 1
a474 1
    int i;
d477 14
a490 3
        if (timing[i].hsize && timing[i].vsize && timing[i].refresh) {
	    Mode = FindDMTMode(timing[i].hsize, timing[i].vsize,
			       timing[i].refresh, rb);
d495 1
a495 2
		    Mode = xf86CVTMode(timing[i].hsize, timing[i].vsize,
				       timing[i].refresh, FALSE, FALSE);
d497 1
a497 2
		    Mode = xf86GTFMode(timing[i].hsize, timing[i].vsize,
				       timing[i].refresh, FALSE, FALSE);
d500 1
a500 2
	    if (!Mode)
		continue;
d502 1
d504 3
a506 2
            Modes = xf86ModesAdd(Modes, Mode);
        }
d512 39
a614 2
    xf86SetModeDefaultName(Mode);

d618 1
a618 1
        Mode->Flags |= V_INTERLACE;
d634 2
d798 1
a798 1
static ddc_quirk_t
d818 19
d850 3
a852 15
	struct detailed_monitor_section *det_mon = &DDC->det_mon[i];

	if (det_mon->type != DT)
	    continue;

	if (quirks & DDC_QUIRK_DETAILED_H_IN_CM)
	    det_mon->section.d_timings.h_size *= 10;

	if (quirks & DDC_QUIRK_DETAILED_V_IN_CM)
	    det_mon->section.d_timings.v_size *= 10;

	if (quirks & DDC_QUIRK_DETAILED_USE_MAXIMUM_SIZE) {
	    det_mon->section.d_timings.h_size = 10 * DDC->features.hsize;
	    det_mon->section.d_timings.v_size = 10 * DDC->features.vsize;
	}
d897 143
a1039 1
_X_EXPORT DisplayModePtr
a1041 1
    int		    i;
d1046 1
d1065 8
a1072 29
    for (i = 0; i < DET_TIMINGS; i++) {
	struct detailed_monitor_section *det_mon = &DDC->det_mon[i];

	Mode = NULL;
        switch (det_mon->type) {
        case DT:
            Mode = DDCModeFromDetailedTiming(scrnIndex,
                                             &det_mon->section.d_timings,
					     preferred,
					     quirks);
	    preferred = FALSE;
            break;
        case DS_STD_TIMINGS:
            Mode = DDCModesFromStandardTiming(det_mon->section.std_t,
					      quirks, timing_level, rb);
            break;
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(7,0,0,0,0)
	case DS_CVT:
	    Mode = DDCModesFromCVT(scrnIndex, det_mon->section.cvt);
	    break;
#endif
	case DS_EST_III:
	    Mode = DDCModesFromEstIII(det_mon->section.est_iii);
	    break;
        default:
            break;
        }
	Modes = xf86ModesAdd(Modes, Mode);
    }
d1082 4
d1092 2
d1097 57
d1157 2
a1158 2
_X_EXPORT void
xf86DDCMonitorSet(int scrnIndex, MonPtr Monitor, xf86MonPtr DDC)
d1161 1
a1161 3
    int i, clock;
    Bool have_hsync = FALSE, have_vrefresh = FALSE, have_maxpixclock = FALSE;
    ddc_quirk_t quirks;
d1168 1
a1168 3
    quirks = xf86DDCDetectQuirks(scrnIndex, DDC, FALSE);

    if (Monitor->widthmm <= 0 && Monitor->heightmm <= 0) {
a1176 5
    /* Skip EDID ranges if they were specified in the config file */
    have_hsync = (Monitor->nHsync != 0);
    have_vrefresh = (Monitor->nVrefresh != 0);
    have_maxpixclock = (Monitor->maxPixClock != 0);

d1178 6
a1183 42
    for (i = 0; i < DET_TIMINGS; i++) {
        switch (DDC->det_mon[i].type) {
        case DS_RANGES:
	    if (!have_hsync) {
		if (!Monitor->nHsync)
		    xf86DrvMsg(scrnIndex, X_INFO,
			    "Using EDID range info for horizontal sync\n");
		Monitor->hsync[Monitor->nHsync].lo =
		    DDC->det_mon[i].section.ranges.min_h;
		Monitor->hsync[Monitor->nHsync].hi =
		    DDC->det_mon[i].section.ranges.max_h;
		Monitor->nHsync++;
	    } else {
		xf86DrvMsg(scrnIndex, X_INFO,
			"Using hsync ranges from config file\n");
	    }

	    if (!have_vrefresh) {
		if (!Monitor->nVrefresh)
		    xf86DrvMsg(scrnIndex, X_INFO,
			    "Using EDID range info for vertical refresh\n");
		Monitor->vrefresh[Monitor->nVrefresh].lo =
		    DDC->det_mon[i].section.ranges.min_v;
		Monitor->vrefresh[Monitor->nVrefresh].hi =
		    DDC->det_mon[i].section.ranges.max_v;
		Monitor->nVrefresh++;
	    } else {
		xf86DrvMsg(scrnIndex, X_INFO,
			"Using vrefresh ranges from config file\n");
	    }

	    clock = DDC->det_mon[i].section.ranges.max_clock * 1000;
	    if (quirks & DDC_QUIRK_DVI_SINGLE_LINK)
		clock = min(clock, 165000);
	    if (!have_maxpixclock && clock > Monitor->maxPixClock)
		Monitor->maxPixClock = clock;

            break;
        default:
            break;
        }
    }
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d3 1
d38 1
a43 1
#include "xf86DDC.h"
d48 23
d95 2
d158 5
d173 5
d208 5
d225 10
d274 4
d285 7
a291 2
 * TODO:
 *  - for those with access to the VESA DMT standard; review please.
d300 1
a300 1
    { MODEPREFIX,    31500,  640,  664,  704,  832, 0,  480,  489,  491,  520, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 640x480@@72Hz */
d302 1
a302 1
    { MODEPREFIX,    25200,  640,  656,  752,  800, 0,  480,  490,  492,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 640x480@@60Hz */
d306 1
a306 1
    { MODEPREFIX,    78800, 1024, 1040, 1136, 1312, 0,  768,  769,  772,  800, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1024x768@@75Hz */
d309 1
a309 1
    { MODEPREFIX,    44900, 1024, 1032, 1208, 1264, 0,  768,  768,  776,  817, 0, V_PHSYNC | V_PVSYNC | V_INTERLACE, MODESUFFIX }, /* 1024x768@@43Hz */
d335 84
d435 6
d442 30
a471 5
 * This is not really correct.  Appendix B of the EDID 1.4 spec defines
 * the right thing to do here.  If the timing given here matches a mode
 * defined in the VESA DMT standard, we _must_ use that.  If the device
 * supports CVT modes, then we should generate a CVT timing.  If both
 * of the above fail, use GTF.
d486 1
a486 1
			   int timing_level)
d493 15
a507 7
	    /* XXX check for DMT first, else... */
	    if (timing_level == LEVEL_CVT)
		Mode = xf86CVTMode(timing[i].hsize, timing[i].vsize,
				   timing[i].refresh, FALSE, FALSE);
	    else
		Mode = xf86GTFMode(timing[i].hsize, timing[i].vsize,
				   timing[i].refresh, FALSE, FALSE);
d549 1
a549 1
		    "%s: %dx%d Warning: We only handle seperate"
d605 1
d634 59
d694 21
d862 1
a862 1
    Bool	    preferred;
d878 2
d885 1
a892 1
            Modes = xf86ModesAdd(Modes, Mode);
d896 1
a896 2
					      quirks, timing_level);
            Modes = xf86ModesAdd(Modes, Mode);
d898 1
d901 4
a904 1
	    Modes = xf86ModesAdd(Modes, Mode);
d909 1
d917 1
a917 1
    Mode = DDCModesFromStandardTiming(DDC->timings2, quirks, timing_level);
d938 1
d945 2
d952 1
a952 6
    /*
     * If this is a digital display, then we can use reduced blanking.
     * XXX This is a 1.3 heuristic.  1.4 explicitly defines rb support.
     */
    if (DDC->features.input_type)
        Monitor->reducedblanking = TRUE;
d994 2
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d57 14
d77 2
a78 1
	DDC->vendor.prod_id == 1516)
d96 46
d155 29
d199 24
d233 2
a234 2
#define MODEPREFIX(name) NULL, NULL, name, 0,M_T_DRIVER
#define MODESUFFIX   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,FALSE,FALSE,0,NULL,0,0.0,0.0
d236 18
a253 18
static DisplayModeRec DDCEstablishedModes[17] = {
    { MODEPREFIX("800x600"),    40000,  800,  840,  968, 1056, 0,  600,  601,  605,  628, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 800x600@@60Hz */
    { MODEPREFIX("800x600"),    36000,  800,  824,  896, 1024, 0,  600,  601,  603,  625, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 800x600@@56Hz */
    { MODEPREFIX("640x480"),    31500,  640,  656,  720,  840, 0,  480,  481,  484,  500, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 640x480@@75Hz */
    { MODEPREFIX("640x480"),    31500,  640,  664,  704,  832, 0,  480,  489,  491,  520, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 640x480@@72Hz */
    { MODEPREFIX("640x480"),    30240,  640,  704,  768,  864, 0,  480,  483,  486,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 640x480@@67Hz */
    { MODEPREFIX("640x480"),    25200,  640,  656,  752,  800, 0,  480,  490,  492,  525, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 640x480@@60Hz */
    { MODEPREFIX("720x400"),    35500,  720,  738,  846,  900, 0,  400,  421,  423,  449, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 720x400@@88Hz */
    { MODEPREFIX("720x400"),    28320,  720,  738,  846,  900, 0,  400,  412,  414,  449, 0, V_NHSYNC | V_PVSYNC, MODESUFFIX }, /* 720x400@@70Hz */
    { MODEPREFIX("1280x1024"), 135000, 1280, 1296, 1440, 1688, 0, 1024, 1025, 1028, 1066, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1280x1024@@75Hz */
    { MODEPREFIX("1024x768"),   78800, 1024, 1040, 1136, 1312, 0,  768,  769,  772,  800, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1024x768@@75Hz */
    { MODEPREFIX("1024x768"),   75000, 1024, 1048, 1184, 1328, 0,  768,  771,  777,  806, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 1024x768@@70Hz */
    { MODEPREFIX("1024x768"),   65000, 1024, 1048, 1184, 1344, 0,  768,  771,  777,  806, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 1024x768@@60Hz */
    { MODEPREFIX("1024x768"),   44900, 1024, 1032, 1208, 1264, 0,  768,  768,  776,  817, 0, V_PHSYNC | V_PVSYNC | V_INTERLACE, MODESUFFIX }, /* 1024x768@@43Hz */
    { MODEPREFIX("832x624"),    57284,  832,  864,  928, 1152, 0,  624,  625,  628,  667, 0, V_NHSYNC | V_NVSYNC, MODESUFFIX }, /* 832x624@@75Hz */
    { MODEPREFIX("800x600"),    49500,  800,  816,  896, 1056, 0,  600,  601,  604,  625, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 800x600@@75Hz */
    { MODEPREFIX("800x600"),    50000,  800,  856,  976, 1040, 0,  600,  637,  643,  666, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 800x600@@72Hz */
    { MODEPREFIX("1152x864"),  108000, 1152, 1216, 1344, 1600, 0,  864,  865,  868,  900, 0, V_PHSYNC | V_PVSYNC, MODESUFFIX }, /* 1152x864@@75Hz */
d275 16
d292 5
d298 10
d310 2
a311 2
DDCModesFromStandardTiming(int scrnIndex, struct std_timings *timing,
			   ddc_quirk_t quirks)
d318 8
a325 2
            Mode =  xf86CVTMode(timing[i].hsize, timing[i].vsize,
                                timing[i].refresh, FALSE, FALSE);
d339 1
a339 1
			  int preferred, ddc_quirk_t quirks)
d370 1
a370 2
    Mode = xnfalloc(sizeof(DisplayModeRec));
    memset(Mode, 0, sizeof(DisplayModeRec));
d405 22
a426 4
    if (timing->misc & 0x02)
	Mode->Flags |= V_PVSYNC;
    else
	Mode->Flags |= V_NVSYNC;
d428 19
a446 4
    if (timing->misc & 0x01)
	Mode->Flags |= V_PHSYNC;
    else
	Mode->Flags |= V_NHSYNC;
d448 1
a448 1
    return Mode;
d451 1
d453 5
a457 1
 *
d500 92
d595 1
a595 1
    int preferred, i;
d598 2
d603 3
a605 9
    quirks = DDC_QUIRK_NONE;
    for (i = 0; ddc_quirks[i].detect; i++)
	if (ddc_quirks[i].detect (scrnIndex, DDC))
	{
	    xf86DrvMsg (scrnIndex, X_INFO, "    EDID quirk: %s\n",
			ddc_quirks[i].description);
	    quirks |= ddc_quirks[i].quirk;
	}
    
d607 8
a614 2
    if (quirks & DDC_QUIRK_PREFER_LARGE_60)
	preferred = 0;
d625 1
a625 1
	    preferred = 0;
d629 2
a630 3
            Mode = DDCModesFromStandardTiming(scrnIndex,
					      det_mon->section.std_t,
					      quirks);
d633 4
d647 1
a647 1
    Mode = DDCModesFromStandardTiming(scrnIndex, DDC->timings2, quirks);
d651 5
a655 26
    {
	DisplayModePtr	best = Modes;
	for (Mode = Modes; Mode; Mode = Mode->next)
	{
	    if (Mode == best) continue;
	    if (Mode->HDisplay * Mode->VDisplay > best->HDisplay * best->VDisplay)
	    {
		best = Mode;
		continue;
	    }
	    if (Mode->HDisplay * Mode->VDisplay == best->HDisplay * best->VDisplay)
	    {
		double	mode_refresh = xf86ModeVRefresh (Mode);
		double	best_refresh = xf86ModeVRefresh (best);
		double	mode_dist = fabs(mode_refresh - 60.0);
		double	best_dist = fabs(best_refresh - 60.0);
		if (mode_dist < best_dist)
		{
		    best = Mode;
		    continue;
		}
	    }
	}
	if (best)
	    best->type |= M_T_PREFERRED;
    }
d674 4
a677 2
    Monitor->widthmm = 10 * DDC->features.hsize;
    Monitor->heightmm = 10 * DDC->features.vsize;
d679 4
a682 1
    /* If this is a digital display, then we can use reduced blanking */
a684 1
    /* Allow the user to also enable this through config */
@


1.1
log
@Initial revision
@
text
@d242 6
@


1.1.1.1
log
@xserver 1.4
@
text
@@
