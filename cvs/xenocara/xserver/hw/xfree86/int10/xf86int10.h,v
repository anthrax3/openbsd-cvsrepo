head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.12
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.10
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.8
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.6
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2013.06.07.17.28.51;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.20.58;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.20.58;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.58.09;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@
/*
 *                   XFree86 int10 module
 *   execute BIOS int 10h calls in x86 real mode environment
 *                 Copyright 1999 Egbert Eich
 */

#ifndef _XF86INT10_H
#define _XF86INT10_H

#include <X11/Xmd.h>
#include <X11/Xdefs.h>
#include "xf86Pci.h"

#define SEG_ADDR(x) (((x) >> 4) & 0x00F000)
#define SEG_OFF(x) ((x) & 0x0FFFF)

#define SET_BIOS_SCRATCH     0x1
#define RESTORE_BIOS_SCRATCH 0x2

/* int10 info structure */
typedef struct {
    int entityIndex;
    uint16_t BIOSseg;
    uint16_t inb40time;
    ScrnInfoPtr pScrn;
    void *cpuRegs;
    char *BIOSScratch;
    int Flags;
    void *private;
    struct _int10Mem *mem;
    int num;
    int ax;
    int bx;
    int cx;
    int dx;
    int si;
    int di;
    int es;
    int bp;
    int flags;
    int stackseg;
    struct pci_device *dev;
    struct pci_io_handle *io;
} xf86Int10InfoRec, *xf86Int10InfoPtr;

typedef struct _int10Mem {
    uint8_t (*rb) (xf86Int10InfoPtr, int);
    uint16_t (*rw) (xf86Int10InfoPtr, int);
    uint32_t (*rl) (xf86Int10InfoPtr, int);
    void (*wb) (xf86Int10InfoPtr, int, uint8_t);
    void (*ww) (xf86Int10InfoPtr, int, uint16_t);
    void (*wl) (xf86Int10InfoPtr, int, uint32_t);
} int10MemRec, *int10MemPtr;

typedef struct {
    uint8_t save_msr;
    uint8_t save_pos102;
    uint8_t save_vse;
    uint8_t save_46e8;
} legacyVGARec, *legacyVGAPtr;

/* OS dependent functions */
extern _X_EXPORT xf86Int10InfoPtr xf86InitInt10(int entityIndex);
extern _X_EXPORT xf86Int10InfoPtr xf86ExtendedInitInt10(int entityIndex,
                                                        int Flags);
extern _X_EXPORT void xf86FreeInt10(xf86Int10InfoPtr pInt);
extern _X_EXPORT void *xf86Int10AllocPages(xf86Int10InfoPtr pInt, int num,
                                           int *off);
extern _X_EXPORT void xf86Int10FreePages(xf86Int10InfoPtr pInt, void *pbase,
                                         int num);
extern _X_EXPORT void *xf86int10Addr(xf86Int10InfoPtr pInt, uint32_t addr);

/* x86 executor related functions */
extern _X_EXPORT void xf86ExecX86int10(xf86Int10InfoPtr pInt);

#ifdef _INT10_PRIVATE

#define I_S_DEFAULT_INT_VECT 0xFF065
#define SYS_SIZE 0x100000
#define SYS_BIOS 0xF0000
#if 1
#define BIOS_SIZE 0x10000
#else                           /* a bug in DGUX requires this - let's try it */
#define BIOS_SIZE (0x10000 - 1)
#endif
#define LOW_PAGE_SIZE 0x600
#define V_RAM 0xA0000
#define VRAM_SIZE 0x20000
#define V_BIOS_SIZE 0x10000
#define V_BIOS 0xC0000
#define BIOS_SCRATCH_OFF 0x449
#define BIOS_SCRATCH_END 0x466
#define BIOS_SCRATCH_LEN (BIOS_SCRATCH_END - BIOS_SCRATCH_OFF + 1)
#define HIGH_MEM V_BIOS
#define HIGH_MEM_SIZE (SYS_BIOS - HIGH_MEM)
#define SEG_ADR(type, seg, reg)  type((seg << 4) + (X86_##reg))
#define SEG_EADR(type, seg, reg) type((seg << 4) + (X86_E##reg))

#define X86_TF_MASK		0x00000100
#define X86_IF_MASK		0x00000200
#define X86_IOPL_MASK		0x00003000
#define X86_NT_MASK		0x00004000
#define X86_VM_MASK		0x00020000
#define X86_AC_MASK		0x00040000
#define X86_VIF_MASK		0x00080000      /* virtual interrupt flag */
#define X86_VIP_MASK		0x00100000      /* virtual interrupt pending */
#define X86_ID_MASK		0x00200000

#define MEM_RB(name, addr)      (*name->mem->rb)(name, addr)
#define MEM_RW(name, addr)      (*name->mem->rw)(name, addr)
#define MEM_RL(name, addr)      (*name->mem->rl)(name, addr)
#define MEM_WB(name, addr, val) (*name->mem->wb)(name, addr, val)
#define MEM_WW(name, addr, val) (*name->mem->ww)(name, addr, val)
#define MEM_WL(name, addr, val) (*name->mem->wl)(name, addr, val)

/* OS dependent functions */
extern _X_EXPORT Bool MapCurrentInt10(xf86Int10InfoPtr pInt);

/* x86 executor related functions */
extern _X_EXPORT Bool xf86Int10ExecSetup(xf86Int10InfoPtr pInt);

/* int.c */
extern _X_EXPORT xf86Int10InfoPtr Int10Current;
int int_handler(xf86Int10InfoPtr pInt);

/* helper_exec.c */
int setup_int(xf86Int10InfoPtr pInt);
void finish_int(xf86Int10InfoPtr, int sig);
uint32_t getIntVect(xf86Int10InfoPtr pInt, int num);
void pushw(xf86Int10InfoPtr pInt, uint16_t val);
int run_bios_int(int num, xf86Int10InfoPtr pInt);
void dump_code(xf86Int10InfoPtr pInt);
void dump_registers(xf86Int10InfoPtr pInt);
void stack_trace(xf86Int10InfoPtr pInt);
uint8_t bios_checksum(const uint8_t *start, int size);
void LockLegacyVGA(xf86Int10InfoPtr pInt, legacyVGAPtr vga);
void UnlockLegacyVGA(xf86Int10InfoPtr pInt, legacyVGAPtr vga);

#if defined (_PC)
extern _X_EXPORT void xf86Int10SaveRestoreBIOSVars(xf86Int10InfoPtr pInt,
                                                   Bool save);
#endif
int port_rep_inb(xf86Int10InfoPtr pInt,
                 uint16_t port, uint32_t base, int d_f, uint32_t count);
int port_rep_inw(xf86Int10InfoPtr pInt,
                 uint16_t port, uint32_t base, int d_f, uint32_t count);
int port_rep_inl(xf86Int10InfoPtr pInt,
                 uint16_t port, uint32_t base, int d_f, uint32_t count);
int port_rep_outb(xf86Int10InfoPtr pInt,
                  uint16_t port, uint32_t base, int d_f, uint32_t count);
int port_rep_outw(xf86Int10InfoPtr pInt,
                  uint16_t port, uint32_t base, int d_f, uint32_t count);
int port_rep_outl(xf86Int10InfoPtr pInt,
                  uint16_t port, uint32_t base, int d_f, uint32_t count);

uint8_t x_inb(uint16_t port);
uint16_t x_inw(uint16_t port);
void x_outb(uint16_t port, uint8_t val);
void x_outw(uint16_t port, uint16_t val);
uint32_t x_inl(uint16_t port);
void x_outl(uint16_t port, uint32_t val);

uint8_t Mem_rb(uint32_t addr);
uint16_t Mem_rw(uint32_t addr);
uint32_t Mem_rl(uint32_t addr);
void Mem_wb(uint32_t addr, uint8_t val);
void Mem_ww(uint32_t addr, uint16_t val);
void Mem_wl(uint32_t addr, uint32_t val);

/* helper_mem.c */
void setup_int_vect(xf86Int10InfoPtr pInt);
int setup_system_bios(void *base_addr);
void reset_int_vect(xf86Int10InfoPtr pInt);
void set_return_trap(xf86Int10InfoPtr pInt);
extern _X_EXPORT void *xf86HandleInt10Options(ScrnInfoPtr pScrn,
                                              int entityIndex);
Bool int10skip(const void *options);
Bool int10_check_bios(int scrnIndex, int codeSeg,
                      const unsigned char *vbiosMem);
Bool initPrimary(const void *options);
extern _X_EXPORT BusType xf86int10GetBiosLocationType(const xf86Int10InfoPtr
                                                      pInt);
extern _X_EXPORT Bool xf86int10GetBiosSegment(xf86Int10InfoPtr pInt,
                                              void *base);
#ifdef DEBUG
void dprint(unsigned long start, unsigned long size);
#endif

#endif                          /* _INT10_PRIVATE */
#endif                          /* _XF86INT10_H */
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d24 2
a25 2
    CARD16 BIOSseg;
    CARD16 inb40time;
d27 1
a27 1
    pointer cpuRegs;
d30 1
a30 1
    pointer private;
d48 6
a53 6
    CARD8 (*rb) (xf86Int10InfoPtr, int);
    CARD16 (*rw) (xf86Int10InfoPtr, int);
    CARD32 (*rl) (xf86Int10InfoPtr, int);
    void (*wb) (xf86Int10InfoPtr, int, CARD8);
    void (*ww) (xf86Int10InfoPtr, int, CARD16);
    void (*wl) (xf86Int10InfoPtr, int, CARD32);
d57 4
a60 4
    CARD8 save_msr;
    CARD8 save_pos102;
    CARD8 save_vse;
    CARD8 save_46e8;
d72 1
a72 1
extern _X_EXPORT pointer xf86int10Addr(xf86Int10InfoPtr pInt, CARD32 addr);
d130 2
a131 2
CARD32 getIntVect(xf86Int10InfoPtr pInt, int num);
void pushw(xf86Int10InfoPtr pInt, CARD16 val);
d136 1
a136 1
CARD8 bios_checksum(const CARD8 *start, int size);
d145 1
a145 1
                 CARD16 port, CARD32 base, int d_f, CARD32 count);
d147 1
a147 1
                 CARD16 port, CARD32 base, int d_f, CARD32 count);
d149 1
a149 1
                 CARD16 port, CARD32 base, int d_f, CARD32 count);
d151 1
a151 1
                  CARD16 port, CARD32 base, int d_f, CARD32 count);
d153 1
a153 1
                  CARD16 port, CARD32 base, int d_f, CARD32 count);
d155 1
a155 1
                  CARD16 port, CARD32 base, int d_f, CARD32 count);
d157 13
a169 13
CARD8 x_inb(CARD16 port);
CARD16 x_inw(CARD16 port);
void x_outb(CARD16 port, CARD8 val);
void x_outw(CARD16 port, CARD16 val);
CARD32 x_inl(CARD16 port);
void x_outl(CARD16 port, CARD32 val);

CARD8 Mem_rb(CARD32 addr);
CARD16 Mem_rw(CARD32 addr);
CARD32 Mem_rl(CARD32 addr);
void Mem_wb(CARD32 addr, CARD8 val);
void Mem_ww(CARD32 addr, CARD16 val);
void Mem_wl(CARD32 addr, CARD32 val);
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a23 2
    int scrnIndex;
    pointer cpuRegs;
d26 2
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d26 3
a28 3
    CARD16  BIOSseg;
    CARD16  inb40time;
    char * BIOSScratch;
d31 1
a31 1
    struct _int10Mem* mem;
d44 1
a44 1
    IOADDRESS ioBase;
d48 6
a53 6
    CARD8(*rb)(xf86Int10InfoPtr, int);
    CARD16(*rw)(xf86Int10InfoPtr, int);
    CARD32(*rl)(xf86Int10InfoPtr, int);
    void(*wb)(xf86Int10InfoPtr, int, CARD8);
    void(*ww)(xf86Int10InfoPtr, int, CARD16);
    void(*wl)(xf86Int10InfoPtr, int, CARD32);
d62 1
a62 1
    
d66 1
a66 1
							int Flags);
d69 1
a69 1
					   int *off);
d71 1
a71 1
					 int num);
d84 1
a84 1
#else /* a bug in DGUX requires this - let's try it */
d106 2
a107 2
#define X86_VIF_MASK		0x00080000	/* virtual interrupt flag */
#define X86_VIP_MASK		0x00100000	/* virtual interrupt pending */
d119 1
d139 1
d141 2
a142 1
extern _X_EXPORT void xf86Int10SaveRestoreBIOSVars(xf86Int10InfoPtr pInt, Bool save);
d145 1
a145 1
		 CARD16 port, CARD32 base, int d_f, CARD32 count);
d147 1
a147 1
		 CARD16 port, CARD32 base, int d_f, CARD32 count);
d149 1
a149 1
		 CARD16 port, CARD32 base, int d_f, CARD32 count);
d151 1
a151 1
		  CARD16 port, CARD32 base, int d_f, CARD32 count);
d153 1
a153 1
		  CARD16 port, CARD32 base, int d_f, CARD32 count);
d155 1
a155 1
		  CARD16 port, CARD32 base, int d_f, CARD32 count);
d176 3
a178 2
extern _X_EXPORT void * xf86HandleInt10Options(ScrnInfoPtr pScrn, int entityIndex);
Bool int10skip(const void* options);
d180 6
a185 4
    const unsigned char* vbiosMem);
Bool initPrimary(const void* options);
extern _X_EXPORT BusType xf86int10GetBiosLocationType(const xf86Int10InfoPtr pInt);
extern _X_EXPORT Bool xf86int10GetBiosSegment(xf86Int10InfoPtr pInt, void *base);
d190 2
a191 2
#endif /* _INT10_PRIVATE */
#endif /* _XF86INT10_H */
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d64 9
a72 6
xf86Int10InfoPtr xf86InitInt10(int entityIndex);
xf86Int10InfoPtr xf86ExtendedInitInt10(int entityIndex, int Flags);
void xf86FreeInt10(xf86Int10InfoPtr pInt);
void *xf86Int10AllocPages(xf86Int10InfoPtr pInt, int num, int *off);
void xf86Int10FreePages(xf86Int10InfoPtr pInt, void *pbase, int num);
pointer xf86int10Addr(xf86Int10InfoPtr pInt, CARD32 addr);
d75 1
a75 1
void xf86ExecX86int10(xf86Int10InfoPtr pInt);
d118 1
a118 1
Bool MapCurrentInt10(xf86Int10InfoPtr pInt);
d120 1
a120 1
Bool xf86Int10ExecSetup(xf86Int10InfoPtr pInt);
d123 1
a123 1
extern xf86Int10InfoPtr Int10Current;
a134 1
xf86Int10InfoPtr getInt10Rec(int entityIndex);
d139 1
a139 1
void xf86Int10SaveRestoreBIOSVars(xf86Int10InfoPtr pInt, Bool save);
d173 1
a173 1
void * xf86HandleInt10Options(ScrnInfoPtr pScrn, int entityIndex);
d178 2
a179 2
BusType xf86int10GetBiosLocationType(const xf86Int10InfoPtr pInt);
Bool xf86int10GetBiosSegment(xf86Int10InfoPtr pInt, void *base);
@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
    PCITAG Tag;
a61 12

typedef struct {
    BusType bus;
    union {
	struct {
	    int bus;
	    int dev;
	    int func;
	} pci;
	int legacy;
    } location;
} xf86int10BiosLocation, *xf86int10BiosLocationPtr;
d176 2
a177 6
void xf86int10ParseBiosLocation(const void* options, 
				xf86int10BiosLocationPtr bios);
BusType xf86int10GetBiosLocationType(const xf86Int10InfoPtr pInt,
    const xf86int10BiosLocationPtr bios);
Bool xf86int10GetBiosSegment(xf86Int10InfoPtr pInt,
    const xf86int10BiosLocationPtr bios, void * base);
a180 3

/* pci.c */
int mapPciRom(int pciEntity, unsigned char *address);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d62 12
d188 6
a193 2
BusType xf86int10GetBiosLocationType(const xf86Int10InfoPtr pInt);
Bool xf86int10GetBiosSegment(xf86Int10InfoPtr pInt, void *base);
@

