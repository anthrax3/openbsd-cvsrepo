head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2013.06.07.17.28.51;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.20.57;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.20.57;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.10.35;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.58.10;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *                   XFree86 int10 module
 *   execute BIOS int 10h calls in x86 real mode environment
 *                 Copyright 1999 Egbert Eich
 */
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <string.h>
#include <unistd.h>

#include "xf86.h"
#include "xf86_OSproc.h"
#include "compiler.h"
#define _INT10_PRIVATE
#include "xf86int10.h"
#include "int10Defines.h"
#include "Pci.h"

#define ALLOC_ENTRIES(x) ((V_RAM / x) - 1)

#include <string.h>             /* needed for memmove */

static __inline__ uint32_t
ldl_u(uint32_t * p)
{
    uint32_t ret;

    memmove(&ret, p, sizeof(*p));
    return ret;
}

static __inline__ uint16_t
ldw_u(uint16_t * p)
{
    uint16_t ret;

    memmove(&ret, p, sizeof(*p));
    return ret;
}

static __inline__ void
stl_u(uint32_t val, uint32_t * p)
{
    uint32_t tmp = val;

    memmove(p, &tmp, sizeof(*p));
}

static __inline__ void
stw_u(uint16_t val, uint16_t * p)
{
    uint16_t tmp = val;

    memmove(p, &tmp, sizeof(*p));
}

static uint8_t read_b(xf86Int10InfoPtr pInt, int addr);
static uint16_t read_w(xf86Int10InfoPtr pInt, int addr);
static uint32_t read_l(xf86Int10InfoPtr pInt, int addr);
static void write_b(xf86Int10InfoPtr pInt, int addr, uint8_t val);
static void write_w(xf86Int10InfoPtr pInt, int addr, uint16_t val);
static void write_l(xf86Int10InfoPtr pInt, int addr, uint32_t val);

/*
 * the emulator cannot pass a pointer to the current xf86Int10InfoRec
 * to the memory access functions therefore store it here.
 */

typedef struct {
    int shift;
    int entries;
    void *base;
    void *vRam;
    int highMemory;
    void *sysMem;
    char *alloc;
} genericInt10Priv;

#define INTPriv(x) ((genericInt10Priv*)x->private)

int10MemRec genericMem = {
    read_b,
    read_w,
    read_l,
    write_b,
    write_w,
    write_l
};

static void MapVRam(xf86Int10InfoPtr pInt);
static void UnmapVRam(xf86Int10InfoPtr pInt);

#ifdef _PC
#define GET_HIGH_BASE(x) (((V_BIOS + (x) + getpagesize() - 1)/getpagesize()) \
                              * getpagesize())
#endif

static void *sysMem = NULL;

static Bool
readIntVec(struct pci_device *dev, unsigned char *buf, int len)
{
    void *map;

    if (pci_device_map_legacy(dev, 0, len, 0, &map))
        return FALSE;

    memcpy(buf, map, len);
    pci_device_unmap_legacy(dev, map, len);

    return TRUE;
}

xf86Int10InfoPtr
xf86ExtendedInitInt10(int entityIndex, int Flags)
{
    xf86Int10InfoPtr pInt;
    void *base = 0;
    void *vbiosMem = 0;
    void *options = NULL;
    legacyVGARec vga;
    ScrnInfoPtr pScrn;

    pScrn = xf86FindScreenForEntity(entityIndex);

    options = xf86HandleInt10Options(pScrn, entityIndex);

    if (int10skip(options)) {
        free(options);
        return NULL;
    }

    pInt = (xf86Int10InfoPtr) xnfcalloc(1, sizeof(xf86Int10InfoRec));
    pInt->entityIndex = entityIndex;
    if (!xf86Int10ExecSetup(pInt))
        goto error0;
    pInt->mem = &genericMem;
    pInt->private = (void *) xnfcalloc(1, sizeof(genericInt10Priv));
    INTPriv(pInt)->alloc = (void *) xnfcalloc(1, ALLOC_ENTRIES(getpagesize()));
    pInt->pScrn = pScrn;
    base = INTPriv(pInt)->base = xnfalloc(SYS_BIOS);

    /* FIXME: Shouldn't this be a failure case?  Leaving dev as NULL seems like
     * FIXME: an error
     */
    pInt->dev = xf86GetPciInfoForEntity(entityIndex);

    /*
     * we need to map video RAM MMIO as some chipsets map mmio
     * registers into this range.
     */
    MapVRam(pInt);
#ifdef _PC
    if (!sysMem)
        pci_device_map_legacy(pInt->dev, V_BIOS, BIOS_SIZE + SYS_BIOS - V_BIOS,
                              PCI_DEV_MAP_FLAG_WRITABLE, &sysMem);
    INTPriv(pInt)->sysMem = sysMem;

    if (!readIntVec(pInt->dev, base, LOW_PAGE_SIZE)) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Cannot read int vect\n");
        goto error1;
    }

    /*
     * Retrieve everything between V_BIOS and SYS_BIOS as some system BIOSes
     * have executable code there.
     */
    memset((char *) base + V_BIOS, 0, SYS_BIOS - V_BIOS);
    INTPriv(pInt)->highMemory = V_BIOS;

    if (xf86IsEntityPrimary(entityIndex) && !(initPrimary(options))) {
        if (!xf86int10GetBiosSegment(pInt, (unsigned char *) sysMem - V_BIOS))
            goto error1;

        set_return_trap(pInt);

        pInt->Flags = Flags & (SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
        if (!(pInt->Flags & SET_BIOS_SCRATCH))
            pInt->Flags &= ~RESTORE_BIOS_SCRATCH;
        xf86Int10SaveRestoreBIOSVars(pInt, TRUE);

    }
    else {
        const BusType location_type = xf86int10GetBiosLocationType(pInt);
        int bios_location = V_BIOS;

        reset_int_vect(pInt);
        set_return_trap(pInt);

        switch (location_type) {
        case BUS_PCI:{
            int err;
            struct pci_device *rom_device =
                xf86GetPciInfoForEntity(pInt->entityIndex);

            vbiosMem = (unsigned char *) base + bios_location;
            err = pci_device_read_rom(rom_device, vbiosMem);
            if (err) {
                xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Cannot read V_BIOS (3) %s\n",
                           strerror(err));
                goto error1;
            }
            INTPriv(pInt)->highMemory = GET_HIGH_BASE(rom_device->rom_size);
            break;
        }
        default:
            goto error1;
        }
        pInt->BIOSseg = V_BIOS >> 4;
        pInt->num = 0xe6;
        LockLegacyVGA(pInt, &vga);
        xf86ExecX86int10(pInt);
        UnlockLegacyVGA(pInt, &vga);
    }
#else
    if (!sysMem) {
        sysMem = xnfalloc(BIOS_SIZE);
        setup_system_bios(sysMem);
    }
    INTPriv(pInt)->sysMem = sysMem;
    setup_int_vect(pInt);
    set_return_trap(pInt);

    /* Retrieve the entire legacy video BIOS segment.  This can be upto
     * 128KiB.
     */
    vbiosMem = (char *) base + V_BIOS;
    memset(vbiosMem, 0, 2 * V_BIOS_SIZE);
    if (pci_device_read_rom(pInt->dev, vbiosMem) != 0
        || pInt->dev->rom_size < V_BIOS_SIZE) {
        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                   "Unable to retrieve all of segment 0x0C0000.\n");
    }

    /*
     * If this adapter is the primary, use its post-init BIOS (if we can find
     * it).
     */
    {
        int bios_location = V_BIOS;
        Bool done = FALSE;

        vbiosMem = (unsigned char *) base + bios_location;

        if (xf86IsEntityPrimary(entityIndex)) {
            if (int10_check_bios(pScrn->scrnIndex, bios_location >> 4, vbiosMem))
                done = TRUE;
            else
                xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                           "No legacy BIOS found -- trying PCI\n");
        }
        if (!done) {
            int err;
            struct pci_device *rom_device =
                xf86GetPciInfoForEntity(pInt->entityIndex);

            err = pci_device_read_rom(rom_device, vbiosMem);
            if (err) {
                xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Cannot read V_BIOS (5) %s\n",
                           strerror(err));
                goto error1;
            }
        }
    }

    pInt->BIOSseg = V_BIOS >> 4;
    pInt->num = 0xe6;
    LockLegacyVGA(pInt, &vga);
    xf86ExecX86int10(pInt);
    UnlockLegacyVGA(pInt, &vga);
#endif
    free(options);
    return pInt;

 error1:
    free(base);
    UnmapVRam(pInt);
    free(INTPriv(pInt)->alloc);
    free(pInt->private);
 error0:
    free(pInt);
    free(options);

    return NULL;
}

static void
MapVRam(xf86Int10InfoPtr pInt)
{
    int pagesize = getpagesize();
    int size = ((VRAM_SIZE + pagesize - 1) / pagesize) * pagesize;

    pci_device_map_legacy(pInt->dev, V_RAM, size, PCI_DEV_MAP_FLAG_WRITABLE,
                          &(INTPriv(pInt)->vRam));
    pInt->io = pci_legacy_open_io(pInt->dev, 0, 64 * 1024);
}

static void
UnmapVRam(xf86Int10InfoPtr pInt)
{
    int pagesize = getpagesize();
    int size = ((VRAM_SIZE + pagesize - 1) / pagesize) * pagesize;

    pci_device_unmap_legacy(pInt->dev, INTPriv(pInt)->vRam, size);
    pci_device_close_io(pInt->dev, pInt->io);
    pInt->io = NULL;
}

Bool
MapCurrentInt10(xf86Int10InfoPtr pInt)
{
    /* nothing to do here */
    return TRUE;
}

void
xf86FreeInt10(xf86Int10InfoPtr pInt)
{
    if (!pInt)
        return;
#if defined (_PC)
    xf86Int10SaveRestoreBIOSVars(pInt, FALSE);
#endif
    if (Int10Current == pInt)
        Int10Current = NULL;
    free(INTPriv(pInt)->base);
    UnmapVRam(pInt);
    free(INTPriv(pInt)->alloc);
    free(pInt->private);
    free(pInt);
}

void *
xf86Int10AllocPages(xf86Int10InfoPtr pInt, int num, int *off)
{
    int pagesize = getpagesize();
    int num_pages = ALLOC_ENTRIES(pagesize);
    int i, j;

    for (i = 0; i < (num_pages - num); i++) {
        if (INTPriv(pInt)->alloc[i] == 0) {
            for (j = i; j < (num + i); j++)
                if (INTPriv(pInt)->alloc[j] != 0)
                    break;
            if (j == (num + i))
                break;
            i += num;
        }
    }
    if (i == (num_pages - num))
        return NULL;

    for (j = i; j < (i + num); j++)
        INTPriv(pInt)->alloc[j] = 1;

    *off = (i + 1) * pagesize;

    return (char *) INTPriv(pInt)->base + *off;
}

void
xf86Int10FreePages(xf86Int10InfoPtr pInt, void *pbase, int num)
{
    int pagesize = getpagesize();
    int first =
        (((char *) pbase - (char *) INTPriv(pInt)->base) / pagesize) - 1;
    int i;

    for (i = first; i < (first + num); i++)
        INTPriv(pInt)->alloc[i] = 0;
}

#define OFF(addr) ((addr) & 0xffff)
#if defined _PC
#define HIGH_OFFSET (INTPriv(pInt)->highMemory)
#define HIGH_BASE   V_BIOS
#else
#define HIGH_OFFSET SYS_BIOS
#define HIGH_BASE   SYS_BIOS
#endif
#define SYS(addr) ((addr) >= HIGH_OFFSET)
#define V_ADDR(addr) \
	  (SYS(addr) ? ((char*)INTPriv(pInt)->sysMem) + (addr - HIGH_BASE) \
	   : (((char*)(INTPriv(pInt)->base) + addr)))
#define VRAM_ADDR(addr) (addr - V_RAM)
#define VRAM_BASE (INTPriv(pInt)->vRam)

#define VRAM(addr) ((addr >= V_RAM) && (addr < (V_RAM + VRAM_SIZE)))
#define V_ADDR_RB(addr) \
	(VRAM(addr)) ? MMIO_IN8((uint8_t*)VRAM_BASE,VRAM_ADDR(addr)) \
	   : *(uint8_t*) V_ADDR(addr)
#define V_ADDR_RW(addr) \
	(VRAM(addr)) ? MMIO_IN16((uint16_t*)VRAM_BASE,VRAM_ADDR(addr)) \
	   : ldw_u((void *)V_ADDR(addr))
#define V_ADDR_RL(addr) \
	(VRAM(addr)) ? MMIO_IN32((uint32_t*)VRAM_BASE,VRAM_ADDR(addr)) \
	   : ldl_u((void *)V_ADDR(addr))

#define V_ADDR_WB(addr,val) \
	if(VRAM(addr)) \
	    MMIO_OUT8((uint8_t*)VRAM_BASE,VRAM_ADDR(addr),val); \
	else \
	    *(uint8_t*) V_ADDR(addr) = val;
#define V_ADDR_WW(addr,val) \
	if(VRAM(addr)) \
	    MMIO_OUT16((uint16_t*)VRAM_BASE,VRAM_ADDR(addr),val); \
	else \
	    stw_u((val),(void *)(V_ADDR(addr)));

#define V_ADDR_WL(addr,val) \
	if (VRAM(addr)) \
	    MMIO_OUT32((uint32_t*)VRAM_BASE,VRAM_ADDR(addr),val); \
	else \
	    stl_u(val,(void *)(V_ADDR(addr)));

static uint8_t
read_b(xf86Int10InfoPtr pInt, int addr)
{
    return V_ADDR_RB(addr);
}

static uint16_t
read_w(xf86Int10InfoPtr pInt, int addr)
{
#if X_BYTE_ORDER == X_LITTLE_ENDIAN
    if (OFF(addr + 1) > 0)
        return V_ADDR_RW(addr);
#endif
    return V_ADDR_RB(addr) | (V_ADDR_RB(addr + 1) << 8);
}

static uint32_t
read_l(xf86Int10InfoPtr pInt, int addr)
{
#if X_BYTE_ORDER == X_LITTLE_ENDIAN
    if (OFF(addr + 3) > 2)
        return V_ADDR_RL(addr);
#endif
    return V_ADDR_RB(addr) |
        (V_ADDR_RB(addr + 1) << 8) |
        (V_ADDR_RB(addr + 2) << 16) | (V_ADDR_RB(addr + 3) << 24);
}

static void
write_b(xf86Int10InfoPtr pInt, int addr, uint8_t val)
{
    V_ADDR_WB(addr, val);
}

static void
write_w(xf86Int10InfoPtr pInt, int addr, CARD16 val)
{
#if X_BYTE_ORDER == X_LITTLE_ENDIAN
    if (OFF(addr + 1) > 0) {
        V_ADDR_WW(addr, val);
    }
#endif
    V_ADDR_WB(addr, val);
    V_ADDR_WB(addr + 1, val >> 8);
}

static void
write_l(xf86Int10InfoPtr pInt, int addr, uint32_t val)
{
#if X_BYTE_ORDER == X_LITTLE_ENDIAN
    if (OFF(addr + 3) > 2) {
        V_ADDR_WL(addr, val);
    }
#endif
    V_ADDR_WB(addr, val);
    V_ADDR_WB(addr + 1, val >> 8);
    V_ADDR_WB(addr + 2, val >> 16);
    V_ADDR_WB(addr + 3, val >> 24);
}

void *
xf86int10Addr(xf86Int10InfoPtr pInt, uint32_t addr)
{
    return V_ADDR(addr);
}
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d23 36
d102 14
d161 1
a161 1
    if (xf86ReadBIOS(0, 0, base, LOW_PAGE_SIZE) < 0) {
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d23 6
a28 6
static CARD8 read_b(xf86Int10InfoPtr pInt, int addr);
static CARD16 read_w(xf86Int10InfoPtr pInt, int addr);
static CARD32 read_l(xf86Int10InfoPtr pInt, int addr);
static void write_b(xf86Int10InfoPtr pInt, int addr, CARD8 val);
static void write_w(xf86Int10InfoPtr pInt, int addr, CARD16 val);
static void write_l(xf86Int10InfoPtr pInt, int addr, CARD32 val);
d90 2
a91 2
    pInt->private = (pointer) xnfcalloc(1, sizeof(genericInt10Priv));
    INTPriv(pInt)->alloc = (pointer) xnfcalloc(1, ALLOC_ENTRIES(getpagesize()));
d342 2
a343 2
	(VRAM(addr)) ? MMIO_IN8((CARD8*)VRAM_BASE,VRAM_ADDR(addr)) \
	   : *(CARD8*) V_ADDR(addr)
d345 2
a346 2
	(VRAM(addr)) ? MMIO_IN16((CARD16*)VRAM_BASE,VRAM_ADDR(addr)) \
	   : ldw_u((pointer)V_ADDR(addr))
d348 2
a349 2
	(VRAM(addr)) ? MMIO_IN32((CARD32*)VRAM_BASE,VRAM_ADDR(addr)) \
	   : ldl_u((pointer)V_ADDR(addr))
d353 1
a353 1
	    MMIO_OUT8((CARD8*)VRAM_BASE,VRAM_ADDR(addr),val); \
d355 1
a355 1
	    *(CARD8*) V_ADDR(addr) = val;
d358 1
a358 1
	    MMIO_OUT16((CARD16*)VRAM_BASE,VRAM_ADDR(addr),val); \
d360 1
a360 1
	    stw_u((val),(pointer)(V_ADDR(addr)));
d364 1
a364 1
	    MMIO_OUT32((CARD32*)VRAM_BASE,VRAM_ADDR(addr),val); \
d366 1
a366 1
	    stl_u(val,(pointer)(V_ADDR(addr)));
d368 1
a368 1
static CARD8
d374 1
a374 1
static CARD16
d384 1
a384 1
static CARD32
d397 1
a397 1
write_b(xf86Int10InfoPtr pInt, int addr, CARD8 val)
d415 1
a415 1
write_l(xf86Int10InfoPtr pInt, int addr, CARD32 val)
d428 2
a429 2
pointer
xf86int10Addr(xf86Int10InfoPtr pInt, CARD32 addr)
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a72 1
    int screen;
d74 1
d76 1
a76 1
    screen = (xf86FindScreenForEntity(entityIndex))->scrnIndex;
d78 1
a78 1
    options = xf86HandleInt10Options(xf86Screens[screen], entityIndex);
d92 1
a92 1
    pInt->scrnIndex = screen;
d112 1
a112 1
        xf86DrvMsg(screen, X_ERROR, "Cannot read int vect\n");
d151 1
a151 1
                xf86DrvMsg(screen, X_ERROR, "Cannot read V_BIOS (3) %s\n",
d181 3
a183 2
    if (pci_device_read_rom(pInt->dev, vbiosMem) < V_BIOS_SIZE) {
        xf86DrvMsg(screen, X_WARNING,
d198 1
a198 1
            if (int10_check_bios(screen, bios_location >> 4, vbiosMem))
d201 1
a201 1
                xf86DrvMsg(screen, X_INFO,
d211 1
a211 1
                xf86DrvMsg(screen, X_ERROR, "Cannot read V_BIOS (5) %s\n",
a252 1
    int screen = pInt->scrnIndex;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d23 6
a28 6
static CARD8 read_b(xf86Int10InfoPtr pInt,int addr);
static CARD16 read_w(xf86Int10InfoPtr pInt,int addr);
static CARD32 read_l(xf86Int10InfoPtr pInt,int addr);
static void write_b(xf86Int10InfoPtr pInt,int addr, CARD8 val);
static void write_w(xf86Int10InfoPtr pInt,int addr, CARD16 val);
static void write_l(xf86Int10InfoPtr pInt,int addr, CARD32 val);
d38 2
a39 2
    void* base;
    void* vRam;
d41 2
a42 2
    void* sysMem;
    char* alloc;
d58 1
a65 56
/**
 * Read legacy VGA video BIOS associated with specified domain.
 * 
 * Attempts to read up to 128KiB of legacy VGA video BIOS.
 * 
 * \return
 * The number of bytes read on success or -1 on failure.
 *
 * \bug
 * PCI ROMs can contain multiple BIOS images (e.g., OpenFirmware, x86 VGA,
 * etc.).  How do we know that \c pci_device_read_rom will return the
 * legacy VGA BIOS image?
 */
#ifndef _PC
static int
read_legacy_video_BIOS(struct pci_device *dev, unsigned char *Buf)
{
    const ADDRESS Base = 0xC0000;
    const int Len = 0x10000 * 2;
    const int pagemask = getpagesize() - 1;
    const ADDRESS offset = Base & ~pagemask;
    const unsigned long size = ((Base + Len + pagemask) & ~pagemask) - offset;
    unsigned char *ptr, *src;
    int len;


    /* Try to use the civilized PCI interface first.
     */
    if (pci_device_read_rom(dev, Buf) == 0) {
	return dev->rom_size;
    }

    ptr = xf86MapDomainMemory(-1, VIDMEM_READONLY, dev, offset, size);

    if (!ptr)
	return -1;

    /* Using memcpy() here can hang the system */
    src = ptr + (Base - offset);
    for (len = 0; len < (Len / 2); len++) {
	Buf[len] = src[len];
    }

    if ((Buf[0] == 0x55) && (Buf[1] == 0xAA) && (Buf[2] > 0x80)) {
	for ( /* empty */ ; len < Len; len++) {
	    Buf[len] = src[len];
	}
    }

    xf86UnMapVidMem(-1, ptr, size);

    return Len;
}
#endif /* _PC */


d70 3
a72 3
    void* base = 0;
    void* vbiosMem = 0;
    void* options = NULL;
a74 4
 
#if 0
    CARD32 cs;
#endif
d78 2
a79 2
    options = xf86HandleInt10Options(xf86Screens[screen],entityIndex);
    
d81 2
a82 2
	free(options);
	return NULL;
d84 2
a85 2
    
    pInt = (xf86Int10InfoPtr)xnfcalloc(1, sizeof(xf86Int10InfoRec));
d88 1
a88 1
	goto error0;
d90 2
a91 2
    pInt->private = (pointer)xnfcalloc(1, sizeof(genericInt10Priv));
    INTPriv(pInt)->alloc = (pointer)xnfcalloc(1, ALLOC_ENTRIES(getpagesize()));
d107 2
a108 2
	sysMem = xf86MapVidMem(screen, VIDMEM_MMIO, V_BIOS,
			       BIOS_SIZE + SYS_BIOS - V_BIOS);
d112 2
a113 2
	xf86DrvMsg(screen, X_ERROR, "Cannot read int vect\n");
	goto error1;
d118 1
a118 2
     * have executable code there.  Note that xf86ReadBIOS() can only read in
     * 64kB at a time.
d120 1
a120 8
    memset((char *)base + V_BIOS, 0, SYS_BIOS - V_BIOS);
#if 0
    for (cs = V_BIOS;  cs < SYS_BIOS;  cs += V_BIOS_SIZE)
	if (xf86ReadBIOS(cs, 0, (unsigned char *)base + cs, V_BIOS_SIZE) <
		V_BIOS_SIZE)
	    xf86DrvMsg(screen, X_WARNING,
		       "Unable to retrieve all of segment 0x%06X.\n", cs);
#endif
d122 1
a122 1
    
d124 2
a125 2
	if (!xf86int10GetBiosSegment(pInt, (unsigned char *)sysMem - V_BIOS))
	    goto error1;
d127 1
a127 1
	set_return_trap(pInt);
d129 9
a137 8
	pInt->Flags = Flags & (SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
	if (! (pInt->Flags & SET_BIOS_SCRATCH))
	    pInt->Flags &= ~RESTORE_BIOS_SCRATCH;
	xf86Int10SaveRestoreBIOSVars(pInt, TRUE);
	
    } else {
	const BusType location_type = xf86int10GetBiosLocationType(pInt);
	int bios_location = V_BIOS;
d140 1
a140 1
	set_return_trap(pInt);
d142 24
a165 24
	switch (location_type) {
	case BUS_PCI: {
	    int err;
	    struct pci_device *rom_device =
		xf86GetPciInfoForEntity(pInt->entityIndex);

	    vbiosMem = (unsigned char *)base + bios_location;
	    err = pci_device_read_rom(rom_device, vbiosMem);
	    if (err) {
		xf86DrvMsg(screen,X_ERROR,"Cannot read V_BIOS (3) %s\n",
			   strerror(err));
		goto error1;
	    }
	    INTPriv(pInt)->highMemory = GET_HIGH_BASE(rom_device->rom_size);
	    break;
	}
	default:
	    goto error1;
	}
	pInt->BIOSseg = V_BIOS >> 4;
	pInt->num = 0xe6;
	LockLegacyVGA(pInt, &vga);
	xf86ExecX86int10(pInt);
	UnlockLegacyVGA(pInt, &vga);
d169 2
a170 2
	sysMem = xnfalloc(BIOS_SIZE);
	setup_system_bios(sysMem);
d179 1
a179 1
    vbiosMem = (char *)base + V_BIOS;
d181 3
a183 3
    if (read_legacy_video_BIOS(pInt->dev, vbiosMem) < V_BIOS_SIZE) {
	xf86DrvMsg(screen, X_WARNING,
		   "Unable to retrieve all of segment 0x0C0000.\n");
d191 24
a214 23
	int bios_location = V_BIOS;
	Bool done = FALSE;
	vbiosMem = (unsigned char *)base + bios_location;
	
	if (xf86IsEntityPrimary(entityIndex)) {
	    if (int10_check_bios(screen, bios_location >> 4, vbiosMem)) 
		done = TRUE;
	    else 
		xf86DrvMsg(screen,X_INFO,
			"No legacy BIOS found -- trying PCI\n");
	} 
	if (!done) {
	    int err;
	    struct pci_device *rom_device =
		xf86GetPciInfoForEntity(pInt->entityIndex);

	    err = pci_device_read_rom(rom_device, vbiosMem);
	    if (err) {
		xf86DrvMsg(screen,X_ERROR,"Cannot read V_BIOS (5) %s\n",
			   strerror(err));
		goto error1;
	    }
	} 
d234 1
a234 1
    
d244 3
a246 4
    INTPriv(pInt)->vRam = xf86MapDomainMemory(pInt->scrnIndex, VIDMEM_MMIO,
					      pInt->dev, V_RAM, size);

    pInt->ioBase = xf86Screens[pInt->scrnIndex]->domainIOBase;
d254 1
a254 1
    int size = ((VRAM_SIZE + pagesize - 1)/pagesize) * pagesize;
d256 3
a258 1
    xf86UnMapVidMem(screen, INTPriv(pInt)->vRam, size);
d272 1
a272 1
      return;
d277 1
a277 1
	Int10Current = NULL;
d290 1
a290 1
    int i,j;
d293 8
a300 8
	if (INTPriv(pInt)->alloc[i] == 0) {
	    for (j = i; j < (num + i); j++)
		if (INTPriv(pInt)->alloc[j] != 0)
		    break;
	    if (j == (num + i))
		break;
	    i += num;
	}
d303 1
a303 1
	return NULL;
d306 1
a306 1
	INTPriv(pInt)->alloc[j] = 1;
d310 1
a310 1
    return (char *)INTPriv(pInt)->base + *off;
d317 2
a318 1
    int first = (((char *)pbase - (char *)INTPriv(pInt)->base) / pagesize) - 1;
d322 1
a322 1
	INTPriv(pInt)->alloc[i] = 0;
d327 2
a328 2
# define HIGH_OFFSET (INTPriv(pInt)->highMemory)
# define HIGH_BASE   V_BIOS
d330 2
a331 2
# define HIGH_OFFSET SYS_BIOS
# define HIGH_BASE   SYS_BIOS
d333 1
a333 1
# define SYS(addr) ((addr) >= HIGH_OFFSET)
d379 1
a379 1
	return V_ADDR_RW(addr);
d389 1
a389 1
	return V_ADDR_RL(addr);
d392 2
a393 3
	   (V_ADDR_RB(addr + 1) << 8) |
	   (V_ADDR_RB(addr + 2) << 16) |
	   (V_ADDR_RB(addr + 3) << 24);
d399 1
a399 1
    V_ADDR_WB(addr,val);
d406 3
a408 2
    if (OFF(addr + 1) > 0)
      { V_ADDR_WW(addr, val); }
d418 3
a420 2
    if (OFF(addr + 3) > 2)
      { V_ADDR_WL(addr, val); }
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d140 1
a140 1
	xfree(options);
d288 1
a288 1
    xfree(options);
d292 1
a292 1
    xfree(base);
d294 2
a295 2
    xfree(INTPriv(pInt)->alloc);
    xfree(pInt->private);
d297 2
a298 2
    xfree(pInt);
    xfree(options);
d342 1
a342 1
    xfree(INTPriv(pInt)->base);
d344 3
a346 3
    xfree(INTPriv(pInt)->alloc);
    xfree(pInt->private);
    xfree(pInt);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d78 1
d118 1
d131 1
a131 2
#ifdef _PC
    int size;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d179 1
a179 1
    (void)memset((char *)base + V_BIOS, 0, SYS_BIOS - V_BIOS);
a222 13
	case BUS_ISA:
	    vbiosMem = (unsigned char *)sysMem + bios_location;
#if 0
	    (void)memset(vbiosMem, 0, V_BIOS_SIZE);
	    if (xf86ReadBIOS(bios_location, 0, vbiosMem, V_BIOS_SIZE)
		< V_BIOS_SIZE)
		xf86DrvMsg(screen, X_WARNING,
		    "Unable to retrieve all of segment 0x%x.\n",bios_location);
#endif
	    if (!int10_check_bios(screen, bios_location >> 4, vbiosMem)) {
	        xf86DrvMsg(screen,X_ERROR,"Cannot read V_BIOS (4)\n");
		goto error1;
	    }
d245 1
a245 1
    (void)memset(vbiosMem, 0, 2 * V_BIOS_SIZE);
@


1.1
log
@Initial revision
@
text
@d19 1
d59 2
a60 2
#define GET_HIGH_BASE(x) (((V_BIOS + size + getpagesize() - 1)/getpagesize()) \
                             * getpagesize())
d65 54
a125 1
    pciVideoPtr pvp;
d128 1
a128 2
    xf86int10BiosLocation bios;
    
d153 4
a156 2
    pvp = xf86GetPciInfoForEntity(entityIndex);
    if (pvp) pInt->Tag = ((pciConfigPtr)(pvp->thisCard))->tag;
d189 2
a190 6
    xf86int10ParseBiosLocation(options,&bios);
    
    if (xf86IsEntityPrimary(entityIndex) 
	&& !(initPrimary(options))) {
	if (! xf86int10GetBiosSegment(pInt, &bios, 
				      (unsigned char *)sysMem - V_BIOS)) {
a191 1
	}
d201 1
a201 2
	const BusType location_type = xf86int10GetBiosLocationType(pInt,
								   &bios);
d209 3
a211 5
	    const int pci_entity = (bios.bus == BUS_PCI)
	      ? xf86GetPciEntity(bios.location.pci.bus,
				 bios.location.pci.dev,
				 bios.location.pci.func)
	      : pInt->entityIndex;
d214 4
a217 2
	    if (!(size = mapPciRom(pci_entity,(unsigned char *)(vbiosMem)))) {
		xf86DrvMsg(screen,X_ERROR,"Cannot read V_BIOS (3)\n");
d220 1
a220 1
	    INTPriv(pInt)->highMemory = GET_HIGH_BASE(size);
a223 3
	    if (bios.bus == BUS_ISA) {
		bios_location = bios.location.legacy;
	    }
d254 2
a255 4
    /*
     * Retrieve two segments:  one at V_BIOS, the other 64kB beyond the first.
     * This'll catch any BIOS that might have been initialised before server
     * entry.
d259 1
a259 2
    if (xf86ReadDomainMemory(pInt->Tag, V_BIOS, V_BIOS_SIZE, vbiosMem) <
	V_BIOS_SIZE)
d261 2
a262 8
	    "Unable to retrieve all of segment 0x0C0000.\n");
    else if ((((unsigned char *)vbiosMem)[0] == 0x55) &&
	     (((unsigned char *)vbiosMem)[1] == 0xAA) &&
	     (((unsigned char *)vbiosMem)[2] > 0x80))
    if (xf86ReadDomainMemory(pInt->Tag, V_BIOS + V_BIOS_SIZE, V_BIOS_SIZE,
	    (unsigned char *)vbiosMem + V_BIOS_SIZE) < V_BIOS_SIZE)
	xf86DrvMsg(screen, X_WARNING,
	    "Unable to retrieve all of segment 0x0D0000.\n");
a267 2
    xf86int10ParseBiosLocation(options,&bios);
    
d273 6
a278 15
	if ((bios.bus == BUS_ISA)
	    || (bios.bus != BUS_PCI && xf86IsEntityPrimary(entityIndex))) {
		if (bios.bus == BUS_ISA && bios.location.legacy) {
		    xf86DrvMsg(screen, X_CONFIG,"Looking for legacy V_BIOS "
			       "at 0x%x for %sprimary device\n",
			       bios.location.legacy,
			       xf86IsEntityPrimary(entityIndex) ? "" : "non-");
		    bios_location = bios.location.legacy;
		    vbiosMem = (unsigned char *)base + bios_location;
		}
		if (int10_check_bios(screen, bios_location >> 4, vbiosMem)) 
		    done = TRUE;
		else 
		    xf86DrvMsg(screen,X_INFO,
			       "No legacy BIOS found -- trying PCI\n");
d281 9
a289 15
	    int pci_entity;
	    
	    if (bios.bus == BUS_PCI) {
		xf86DrvMsg(screen,X_CONFIG,"Looking for BIOS at PCI:%i%i%i\n",
			   bios.location.pci.bus,bios.location.pci.dev,
			   bios.location.pci.func);		
		pci_entity = xf86GetPciEntity(bios.location.pci.bus,
					      bios.location.pci.dev,
					      bios.location.pci.func);
	    } else 
		pci_entity = pInt->entityIndex;

	    if (!mapPciRom(pci_entity, vbiosMem)) {
		    xf86DrvMsg(screen, X_ERROR, "Cannot read V_BIOS (5)\n");
		    goto error1;
a291 1

d322 1
a322 1
					      pInt->Tag, V_RAM, size);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@Import xserver version 1.2.0 (X.Org 7.2 final).
@
text
@d101 1
a101 1
    if (pvp) pInt->Tag = pciTag(pvp->bus, pvp->device, pvp->func);
@


1.1.1.3
log
@xserver 1.4
@
text
@d74 2
a75 1
 
d134 6
a139 2
    if (xf86IsEntityPrimary(entityIndex) && !(initPrimary(options))) {
	if (!xf86int10GetBiosSegment(pInt, (unsigned char *)sysMem - V_BIOS))
d141 1
d151 2
a152 1
	const BusType location_type = xf86int10GetBiosLocationType(pInt);
d160 5
a164 1
	    const int pci_entity = pInt->entityIndex;
d175 3
d231 2
d238 15
a252 6
	if (xf86IsEntityPrimary(entityIndex)) {
	    if (int10_check_bios(screen, bios_location >> 4, vbiosMem)) 
		done = TRUE;
	    else 
		xf86DrvMsg(screen,X_INFO,
			"No legacy BIOS found -- trying PCI\n");
d255 13
a267 1
	    if (!mapPciRom(pInt->entityIndex, vbiosMem)) {
d272 1
@


