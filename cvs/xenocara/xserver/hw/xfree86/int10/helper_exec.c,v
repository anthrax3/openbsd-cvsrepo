head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.51;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.20.58;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.20.58;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.58.09;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 *                   XFree86 int10 module
 *   execute BIOS int 10h calls in x86 real mode environment
 *                 Copyright 1999 Egbert Eich
 *
 *   Part of this code was inspired  by the VBIOS POSTing code in DOSEMU
 *   developed by the "DOSEMU-Development-Team"
 */

/*
 * To debug port accesses define PRINT_PORT to 1.
 * Note! You also have to comment out ioperm()
 * in xf86EnableIO(). Otherwise we won't trap
 * on PIO.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#define PRINT_PORT 0

#include <unistd.h>

#include <X11/Xos.h>
#include "xf86.h"
#include "xf86_OSproc.h"
#include "compiler.h"
#define _INT10_PRIVATE
#include "int10Defines.h"
#include "xf86int10.h"
#include "Pci.h"
#ifdef _X86EMU
#include "x86emu/x86emui.h"
#else
#define DEBUG_IO_TRACE() 0
#endif
#include <pciaccess.h>

static int pciCfg1in(uint16_t addr, uint32_t *val);
static int pciCfg1out(uint16_t addr, uint32_t val);
static int pciCfg1inw(uint16_t addr, uint16_t *val);
static int pciCfg1outw(uint16_t addr, uint16_t val);
static int pciCfg1inb(uint16_t addr, uint8_t *val);
static int pciCfg1outb(uint16_t addr, uint8_t val);

#if defined (_PC)
static void SetResetBIOSVars(xf86Int10InfoPtr pInt, Bool set);
#endif

#define REG pInt

int
setup_int(xf86Int10InfoPtr pInt)
{
    if (pInt != Int10Current) {
        if (!MapCurrentInt10(pInt))
            return -1;
        Int10Current = pInt;
    }
    X86_EAX = (uint32_t) pInt->ax;
    X86_EBX = (uint32_t) pInt->bx;
    X86_ECX = (uint32_t) pInt->cx;
    X86_EDX = (uint32_t) pInt->dx;
    X86_ESI = (uint32_t) pInt->si;
    X86_EDI = (uint32_t) pInt->di;
    X86_EBP = (uint32_t) pInt->bp;
    X86_ESP = 0x1000;
    X86_SS = pInt->stackseg >> 4;
    X86_EIP = 0x0600;
    X86_CS = 0x0;               /* address of 'hlt' */
    X86_DS = 0x40;              /* standard pc ds */
    X86_ES = pInt->es;
    X86_FS = 0;
    X86_GS = 0;
    X86_EFLAGS = X86_IF_MASK | X86_IOPL_MASK;
#if defined (_PC)
    if (pInt->Flags & SET_BIOS_SCRATCH)
        SetResetBIOSVars(pInt, TRUE);
#endif
    OsBlockSignals();
    return 0;
}

void
finish_int(xf86Int10InfoPtr pInt, int sig)
{
    OsReleaseSignals();
    pInt->ax = (uint32_t) X86_EAX;
    pInt->bx = (uint32_t) X86_EBX;
    pInt->cx = (uint32_t) X86_ECX;
    pInt->dx = (uint32_t) X86_EDX;
    pInt->si = (uint32_t) X86_ESI;
    pInt->di = (uint32_t) X86_EDI;
    pInt->es = (uint16_t) X86_ES;
    pInt->bp = (uint32_t) X86_EBP;
    pInt->flags = (uint32_t) X86_FLAGS;
#if defined (_PC)
    if (pInt->Flags & RESTORE_BIOS_SCRATCH)
        SetResetBIOSVars(pInt, FALSE);
#endif
}

/* general software interrupt handler */
uint32_t
getIntVect(xf86Int10InfoPtr pInt, int num)
{
    return MEM_RW(pInt, num << 2) + (MEM_RW(pInt, (num << 2) + 2) << 4);
}

void
pushw(xf86Int10InfoPtr pInt, uint16_t val)
{
    X86_ESP -= 2;
    MEM_WW(pInt, ((uint32_t) X86_SS << 4) + X86_SP, val);
}

int
run_bios_int(int num, xf86Int10InfoPtr pInt)
{
    uint32_t eflags;

#ifndef _PC
    /* check if bios vector is initialized */
    if (MEM_RW(pInt, (num << 2) + 2) == (SYS_BIOS >> 4)) {      /* SYS_BIOS_SEG ? */

        if (num == 21 && X86_AH == 0x4e) {
            xf86DrvMsg(pInt->pScrn->scrnIndex, X_NOTICE,
                       "Failing Find-Matching-File on non-PC"
                       " (int 21, func 4e)\n");
            X86_AX = 2;
            SET_FLAG(F_CF);
            return 1;
        }
        else {
            xf86DrvMsgVerb(pInt->pScrn->scrnIndex, X_NOT_IMPLEMENTED, 2,
                           "Ignoring int 0x%02x call\n", num);
            if (xf86GetVerbosity() > 3) {
                dump_registers(pInt);
                stack_trace(pInt);
            }
            return 1;
        }
    }
#endif
#ifdef PRINT_INT
    ErrorF("calling card BIOS at: ");
#endif
    eflags = X86_EFLAGS;
#if 0
    eflags = eflags | IF_MASK;
    X86_EFLAGS = X86_EFLAGS & ~(VIF_MASK | TF_MASK | IF_MASK | NT_MASK);
#endif
    pushw(pInt, eflags);
    pushw(pInt, X86_CS);
    pushw(pInt, X86_IP);
    X86_CS = MEM_RW(pInt, (num << 2) + 2);
    X86_IP = MEM_RW(pInt, num << 2);
#ifdef PRINT_INT
    ErrorF("0x%x:%lx\n", X86_CS, X86_EIP);
#endif
    return 1;
}

/* Debugging stuff */
void
dump_code(xf86Int10InfoPtr pInt)
{
    int i;
    uint32_t lina = SEG_ADR((uint32_t), X86_CS, IP);

    xf86DrvMsgVerb(pInt->pScrn->scrnIndex, X_INFO, 3, "code at 0x%8.8" PRIx32 ":\n",
                   (unsigned) lina);
    for (i = 0; i < 0x10; i++)
        xf86ErrorFVerb(3, " %2.2x", MEM_RB(pInt, lina + i));
    xf86ErrorFVerb(3, "\n");
    for (; i < 0x20; i++)
        xf86ErrorFVerb(3, " %2.2x", MEM_RB(pInt, lina + i));
    xf86ErrorFVerb(3, "\n");
}

void
dump_registers(xf86Int10InfoPtr pInt)
{
    xf86DrvMsgVerb(pInt->pScrn->scrnIndex, X_INFO, 3,
                   "EAX=0x%8.8lx, EBX=0x%8.8lx, ECX=0x%8.8lx, EDX=0x%8.8lx\n",
                   (unsigned long) X86_EAX, (unsigned long) X86_EBX,
                   (unsigned long) X86_ECX, (unsigned long) X86_EDX);
    xf86DrvMsgVerb(pInt->pScrn->scrnIndex, X_INFO, 3,
                   "ESP=0x%8.8lx, EBP=0x%8.8lx, ESI=0x%8.8lx, EDI=0x%8.8lx\n",
                   (unsigned long) X86_ESP, (unsigned long) X86_EBP,
                   (unsigned long) X86_ESI, (unsigned long) X86_EDI);
    xf86DrvMsgVerb(pInt->pScrn->scrnIndex, X_INFO, 3,
                   "CS=0x%4.4x, SS=0x%4.4x,"
                   " DS=0x%4.4x, ES=0x%4.4x, FS=0x%4.4x, GS=0x%4.4x\n",
                   X86_CS, X86_SS, X86_DS, X86_ES, X86_FS, X86_GS);
    xf86DrvMsgVerb(pInt->pScrn->scrnIndex, X_INFO, 3,
                   "EIP=0x%8.8lx, EFLAGS=0x%8.8lx\n",
                   (unsigned long) X86_EIP, (unsigned long) X86_EFLAGS);
}

void
stack_trace(xf86Int10InfoPtr pInt)
{
    int i = 0;
    unsigned long stack = SEG_ADR((uint32_t), X86_SS, SP);
    unsigned long tail = (uint32_t) ((X86_SS << 4) + 0x1000);

    if (stack >= tail)
        return;

    xf86MsgVerb(X_INFO, 3, "stack at 0x%8.8lx:\n", stack);
    for (; stack < tail; stack++) {
        xf86ErrorFVerb(3, " %2.2x", MEM_RB(pInt, stack));
        i = (i + 1) % 0x10;
        if (!i)
            xf86ErrorFVerb(3, "\n");
    }
    if (i)
        xf86ErrorFVerb(3, "\n");
}

int
port_rep_inb(xf86Int10InfoPtr pInt,
             uint16_t port, uint32_t base, int d_f, uint32_t count)
{
    register int inc = d_f ? -1 : 1;
    uint32_t dst = base;

    if (PRINT_PORT && DEBUG_IO_TRACE())
        ErrorF(" rep_insb(%#x) %" PRIu32 " bytes at %8.8" PRIx32 " %s\n",
               port, (unsigned) count, (unsigned) base, d_f ? "up" : "down");
    while (count--) {
        MEM_WB(pInt, dst, x_inb(port));
        dst += inc;
    }
    return dst - base;
}

int
port_rep_inw(xf86Int10InfoPtr pInt,
             uint16_t port, uint32_t base, int d_f, uint32_t count)
{
    register int inc = d_f ? -2 : 2;
    uint32_t dst = base;

    if (PRINT_PORT && DEBUG_IO_TRACE())
        ErrorF(" rep_insw(%#x) %" PRIu32 " bytes at %8.8" PRIx32 " %s\n",
               port, (unsigned) count, (unsigned) base, d_f ? "up" : "down");
    while (count--) {
        MEM_WW(pInt, dst, x_inw(port));
        dst += inc;
    }
    return dst - base;
}

int
port_rep_inl(xf86Int10InfoPtr pInt,
             uint16_t port, uint32_t base, int d_f, uint32_t count)
{
    register int inc = d_f ? -4 : 4;
    uint32_t dst = base;

    if (PRINT_PORT && DEBUG_IO_TRACE())
        ErrorF(" rep_insl(%#x) %" PRIu32 " bytes at %8.8" PRIx32 " %s\n",
               port, (unsigned) count, (unsigned) base, d_f ? "up" : "down");
    while (count--) {
        MEM_WL(pInt, dst, x_inl(port));
        dst += inc;
    }
    return dst - base;
}

int
port_rep_outb(xf86Int10InfoPtr pInt,
              uint16_t port, uint32_t base, int d_f, uint32_t count)
{
    register int inc = d_f ? -1 : 1;
    uint32_t dst = base;

    if (PRINT_PORT && DEBUG_IO_TRACE())
        ErrorF(" rep_outb(%#x) %" PRIu32 " bytes at %8.8" PRIx32 " %s\n",
               port, (unsigned) count, (unsigned) base, d_f ? "up" : "down");
    while (count--) {
        x_outb(port, MEM_RB(pInt, dst));
        dst += inc;
    }
    return dst - base;
}

int
port_rep_outw(xf86Int10InfoPtr pInt,
              uint16_t port, uint32_t base, int d_f, uint32_t count)
{
    register int inc = d_f ? -2 : 2;
    uint32_t dst = base;

    if (PRINT_PORT && DEBUG_IO_TRACE())
        ErrorF(" rep_outw(%#x) %" PRIu32 " bytes at %8.8" PRIx32 " %s\n",
               port, (unsigned) count, (unsigned) base, d_f ? "up" : "down");
    while (count--) {
        x_outw(port, MEM_RW(pInt, dst));
        dst += inc;
    }
    return dst - base;
}

int
port_rep_outl(xf86Int10InfoPtr pInt,
              uint16_t port, uint32_t base, int d_f, uint32_t count)
{
    register int inc = d_f ? -4 : 4;
    uint32_t dst = base;

    if (PRINT_PORT && DEBUG_IO_TRACE())
        ErrorF(" rep_outl(%#x) %" PRIu32 " bytes at %8.8" PRIx32 " %s\n",
               port, (unsigned) count, (unsigned) base, d_f ? "up" : "down");
    while (count--) {
        x_outl(port, MEM_RL(pInt, dst));
        dst += inc;
    }
    return dst - base;
}

uint8_t
x_inb(uint16_t port)
{
    uint8_t val;

    if (port == 0x40) {
        Int10Current->inb40time++;
        val = (uint8_t) (Int10Current->inb40time >>
                       ((Int10Current->inb40time & 1) << 3));
        if (PRINT_PORT && DEBUG_IO_TRACE())
            ErrorF(" inb(%#x) = %2.2x\n", port, val);
#ifdef __NOT_YET__
    }
    else if (port < 0x0100) {   /* Don't interfere with mainboard */
        val = 0;
        xf86DrvMsgVerb(Int10Current->pScrn->scrnIndex, X_NOT_IMPLEMENTED, 2,
                       "inb 0x%4.4x\n", port);
        if (xf86GetVerbosity() > 3) {
            dump_registers(Int10Current);
            stack_trace(Int10Current);
        }
#endif                          /* __NOT_YET__ */
    }
    else if (!pciCfg1inb(port, &val)) {
        val = pci_io_read8(Int10Current->io, port);
        if (PRINT_PORT && DEBUG_IO_TRACE())
            ErrorF(" inb(%#x) = %2.2x\n", port, val);
    }
    return val;
}

uint16_t
x_inw(uint16_t port)
{
    uint16_t val;

    if (port == 0x5c) {
        struct timeval tv;

        /*
         * Emulate a PC's timer.  Typical resolution is 3.26 usec.
         * Approximate this by dividing by 3.
         */
        X_GETTIMEOFDAY(&tv);
        val = (uint16_t) (tv.tv_usec / 3);
    }
    else if (!pciCfg1inw(port, &val)) {
        val = pci_io_read16(Int10Current->io, port);
        if (PRINT_PORT && DEBUG_IO_TRACE())
            ErrorF(" inw(%#x) = %4.4x\n", port, val);
    }
    return val;
}

void
x_outb(uint16_t port, uint8_t val)
{
    if ((port == 0x43) && (val == 0)) {
        struct timeval tv;

        /*
         * Emulate a PC's timer 0.  Such timers typically have a resolution of
         * some .838 usec per tick, but this can only provide 1 usec per tick.
         * (Not that this matters much, given inherent emulation delays.)  Use
         * the bottom bit as a byte select.  See inb(0x40) above.
         */
        X_GETTIMEOFDAY(&tv);
        Int10Current->inb40time = (uint16_t) (tv.tv_usec | 1);
        if (PRINT_PORT && DEBUG_IO_TRACE())
            ErrorF(" outb(%#x, %2.2x)\n", port, val);
#ifdef __NOT_YET__
    }
    else if (port < 0x0100) {   /* Don't interfere with mainboard */
        xf86DrvMsgVerb(Int10Current->pScrn->scrnIndex, X_NOT_IMPLEMENTED, 2,
                       "outb 0x%4.4x,0x%2.2x\n", port, val);
        if (xf86GetVerbosity() > 3) {
            dump_registers(Int10Current);
            stack_trace(Int10Current);
        }
#endif                          /* __NOT_YET__ */
    }
    else if (!pciCfg1outb(port, val)) {
        if (PRINT_PORT && DEBUG_IO_TRACE())
            ErrorF(" outb(%#x, %2.2x)\n", port, val);
        pci_io_write8(Int10Current->io, port, val);
    }
}

void
x_outw(uint16_t port, uint16_t val)
{

    if (!pciCfg1outw(port, val)) {
        if (PRINT_PORT && DEBUG_IO_TRACE())
            ErrorF(" outw(%#x, %4.4x)\n", port, val);
        pci_io_write16(Int10Current->io, port, val);
    }
}

uint32_t
x_inl(uint16_t port)
{
    uint32_t val;

    if (!pciCfg1in(port, &val)) {
        val = pci_io_read32(Int10Current->io, port);
        if (PRINT_PORT && DEBUG_IO_TRACE())
            ErrorF(" inl(%#x) = %8.8" PRIx32 "\n", port, (unsigned) val);
    }
    return val;
}

void
x_outl(uint16_t port, uint32_t val)
{
    if (!pciCfg1out(port, val)) {
        if (PRINT_PORT && DEBUG_IO_TRACE())
            ErrorF(" outl(%#x, %8.8" PRIx32 ")\n", port, (unsigned) val);
        pci_io_write32(Int10Current->io, port, val);
    }
}

uint8_t
Mem_rb(uint32_t addr)
{
    return (*Int10Current->mem->rb) (Int10Current, addr);
}

uint16_t
Mem_rw(uint32_t addr)
{
    return (*Int10Current->mem->rw) (Int10Current, addr);
}

uint32_t
Mem_rl(uint32_t addr)
{
    return (*Int10Current->mem->rl) (Int10Current, addr);
}

void
Mem_wb(uint32_t addr, uint8_t val)
{
    (*Int10Current->mem->wb) (Int10Current, addr, val);
}

void
Mem_ww(uint32_t addr, uint16_t val)
{
    (*Int10Current->mem->ww) (Int10Current, addr, val);
}

void
Mem_wl(uint32_t addr, uint32_t val)
{
    (*Int10Current->mem->wl) (Int10Current, addr, val);
}

static uint32_t PciCfg1Addr = 0;

#define PCI_DOM_FROM_TAG(tag)  (((tag) >> 24) & (PCI_DOM_MASK))
#define PCI_BUS_FROM_TAG(tag)  (((tag) >> 16) & (PCI_DOMBUS_MASK))
#define PCI_DEV_FROM_TAG(tag)  (((tag) & 0x0000f800u) >> 11)
#define PCI_FUNC_FROM_TAG(tag) (((tag) & 0x00000700u) >> 8)

#define PCI_OFFSET(x) ((x) & 0x000000ff)
#define PCI_TAG(x)    ((x) & 0x7fffff00)

static struct pci_device *
pci_device_for_cfg_address(uint32_t addr)
{
    struct pci_device *dev = NULL;
    uint32_t tag = PCI_TAG(addr);

    struct pci_slot_match slot_match = {
        .domain = PCI_DOM_FROM_TAG(tag),
        .bus = PCI_BUS_NO_DOMAIN(PCI_BUS_FROM_TAG(tag)),
        .dev = PCI_DEV_FROM_TAG(tag),
        .func = PCI_FUNC_FROM_TAG(tag),
        .match_data = 0
    };

    struct pci_device_iterator *iter =
        pci_slot_match_iterator_create(&slot_match);

    if (iter)
        dev = pci_device_next(iter);

    pci_iterator_destroy(iter);

    return dev;
}

static int
pciCfg1in(uint16_t addr, uint32_t *val)
{
    if (addr == 0xCF8) {
        *val = PciCfg1Addr;
        return 1;
    }
    if (addr == 0xCFC) {
        pci_device_cfg_read_u32(pci_device_for_cfg_address(PciCfg1Addr),
                                (uint32_t *) val, PCI_OFFSET(PciCfg1Addr));
        if (PRINT_PORT && DEBUG_IO_TRACE())
            ErrorF(" cfg_inl(%#" PRIx32 ") = %8.8" PRIx32 "\n", (unsigned) PciCfg1Addr,
                   (unsigned) *val);
        return 1;
    }
    return 0;
}

static int
pciCfg1out(uint16_t addr, uint32_t val)
{
    if (addr == 0xCF8) {
        PciCfg1Addr = val;
        return 1;
    }
    if (addr == 0xCFC) {
        if (PRINT_PORT && DEBUG_IO_TRACE())
            ErrorF(" cfg_outl(%#" PRIx32 ", %8.8" PRIx32 ")\n", (unsigned) PciCfg1Addr,
                   (unsigned) val);
        pci_device_cfg_write_u32(pci_device_for_cfg_address(PciCfg1Addr), val,
                                 PCI_OFFSET(PciCfg1Addr));
        return 1;
    }
    return 0;
}

static int
pciCfg1inw(uint16_t addr, uint16_t *val)
{
    int shift;

    if ((addr >= 0xCF8) && (addr <= 0xCFB)) {
        shift = (addr - 0xCF8) * 8;
        *val = (PciCfg1Addr >> shift) & 0xffff;
        return 1;
    }
    if ((addr >= 0xCFC) && (addr <= 0xCFF)) {
        const unsigned offset = addr - 0xCFC;

        pci_device_cfg_read_u16(pci_device_for_cfg_address(PciCfg1Addr),
                                val, PCI_OFFSET(PciCfg1Addr) + offset);
        if (PRINT_PORT && DEBUG_IO_TRACE())
            ErrorF(" cfg_inw(%#" PRIx32 ") = %4.4x\n", (unsigned) (PciCfg1Addr + offset),
                   (unsigned) *val);
        return 1;
    }
    return 0;
}

static int
pciCfg1outw(uint16_t addr, uint16_t val)
{
    int shift;

    if ((addr >= 0xCF8) && (addr <= 0xCFB)) {
        shift = (addr - 0xCF8) * 8;
        PciCfg1Addr &= ~(0xffff << shift);
        PciCfg1Addr |= ((uint32_t) val) << shift;
        return 1;
    }
    if ((addr >= 0xCFC) && (addr <= 0xCFF)) {
        const unsigned offset = addr - 0xCFC;

        if (PRINT_PORT && DEBUG_IO_TRACE())
            ErrorF(" cfg_outw(%#" PRIx32 ", %4.4x)\n", (unsigned) (PciCfg1Addr + offset),
                   (unsigned) val);
        pci_device_cfg_write_u16(pci_device_for_cfg_address(PciCfg1Addr), val,
                                 PCI_OFFSET(PciCfg1Addr) + offset);
        return 1;
    }
    return 0;
}

static int
pciCfg1inb(uint16_t addr, uint8_t *val)
{
    int shift;

    if ((addr >= 0xCF8) && (addr <= 0xCFB)) {
        shift = (addr - 0xCF8) * 8;
        *val = (PciCfg1Addr >> shift) & 0xff;
        return 1;
    }
    if ((addr >= 0xCFC) && (addr <= 0xCFF)) {
        const unsigned offset = addr - 0xCFC;

        pci_device_cfg_read_u8(pci_device_for_cfg_address(PciCfg1Addr),
                               val, PCI_OFFSET(PciCfg1Addr) + offset);
        if (PRINT_PORT && DEBUG_IO_TRACE())
            ErrorF(" cfg_inb(%#" PRIx32 ") = %2.2x\n", (unsigned) (PciCfg1Addr + offset),
                   (unsigned) *val);
        return 1;
    }
    return 0;
}

static int
pciCfg1outb(uint16_t addr, uint8_t val)
{
    int shift;

    if ((addr >= 0xCF8) && (addr <= 0xCFB)) {
        shift = (addr - 0xCF8) * 8;
        PciCfg1Addr &= ~(0xff << shift);
        PciCfg1Addr |= ((uint32_t) val) << shift;
        return 1;
    }
    if ((addr >= 0xCFC) && (addr <= 0xCFF)) {
        const unsigned offset = addr - 0xCFC;

        if (PRINT_PORT && DEBUG_IO_TRACE())
            ErrorF(" cfg_outb(%#" PRIx32 ", %2.2x)\n", (unsigned) (PciCfg1Addr + offset),
                   (unsigned) val);
        pci_device_cfg_write_u8(pci_device_for_cfg_address(PciCfg1Addr), val,
                                PCI_OFFSET(PciCfg1Addr) + offset);
        return 1;
    }
    return 0;
}

uint8_t
bios_checksum(const uint8_t *start, int size)
{
    uint8_t sum = 0;

    while (size-- > 0)
        sum += *start++;
    return sum;
}

/*
 * Lock/Unlock legacy VGA. Some Bioses try to be very clever and make
 * an attempt to detect a legacy ISA card. If they find one they might
 * act very strange: for example they might configure the card as a
 * monochrome card. This might cause some drivers to choke.
 * To avoid this we attempt legacy VGA by writing to all know VGA
 * disable registers before we call the BIOS initialization and
 * restore the original values afterwards. In beween we hold our
 * breath. To get to a (possibly exising) ISA card need to disable
 * our current PCI card.
 */
/*
 * This is just for booting: we just want to catch pure
 * legacy vga therefore we don't worry about mmio etc.
 * This stuff should really go into vgaHW.c. However then
 * the driver would have to load the vga-module prior to
 * doing int10.
 */
void
LockLegacyVGA(xf86Int10InfoPtr pInt, legacyVGAPtr vga)
{
    vga->save_msr = pci_io_read8(pInt->io, 0x03CC);
    vga->save_vse = pci_io_read8(pInt->io, 0x03C3);
#ifndef __ia64__
    vga->save_46e8 = pci_io_read8(pInt->io, 0x46E8);
#endif
    vga->save_pos102 = pci_io_read8(pInt->io, 0x0102);
    pci_io_write8(pInt->io, 0x03C2, ~(uint8_t) 0x03 & vga->save_msr);
    pci_io_write8(pInt->io, 0x03C3, ~(uint8_t) 0x01 & vga->save_vse);
#ifndef __ia64__
    pci_io_write8(pInt->io, 0x46E8, ~(uint8_t) 0x08 & vga->save_46e8);
#endif
    pci_io_write8(pInt->io, 0x0102, ~(uint8_t) 0x01 & vga->save_pos102);
}

void
UnlockLegacyVGA(xf86Int10InfoPtr pInt, legacyVGAPtr vga)
{
    pci_io_write8(pInt->io, 0x0102, vga->save_pos102);
#ifndef __ia64__
    pci_io_write8(pInt->io, 0x46E8, vga->save_46e8);
#endif
    pci_io_write8(pInt->io, 0x03C3, vga->save_vse);
    pci_io_write8(pInt->io, 0x03C2, vga->save_msr);
}

#if defined (_PC)
static void
SetResetBIOSVars(xf86Int10InfoPtr pInt, Bool set)
{
    int pagesize = getpagesize();
    unsigned char *base;
    int i;

    if (pci_device_map_legacy
        (pInt->dev, 0, pagesize, PCI_DEV_MAP_FLAG_WRITABLE, (void **) &base))
        return;                 /* eek */

    if (set) {
        for (i = BIOS_SCRATCH_OFF; i < BIOS_SCRATCH_END; i++)
            MEM_WW(pInt, i, *(base + i));
    }
    else {
        for (i = BIOS_SCRATCH_OFF; i < BIOS_SCRATCH_END; i++)
            *(base + i) = MEM_RW(pInt, i);
    }

    pci_device_unmap_legacy(pInt->dev, base, pagesize);
}

void
xf86Int10SaveRestoreBIOSVars(xf86Int10InfoPtr pInt, Bool save)
{
    int pagesize = getpagesize();
    unsigned char *base;
    int i;

    if (!xf86IsEntityPrimary(pInt->entityIndex)
        || (!save && !pInt->BIOSScratch))
        return;

    if (pci_device_map_legacy
        (pInt->dev, 0, pagesize, PCI_DEV_MAP_FLAG_WRITABLE, (void **) &base))
        return;                 /* eek */

    base += BIOS_SCRATCH_OFF;
    if (save) {
        if ((pInt->BIOSScratch = xnfalloc(BIOS_SCRATCH_LEN)))
            for (i = 0; i < BIOS_SCRATCH_LEN; i++)
                *(((char *) pInt->BIOSScratch + i)) = *(base + i);
    }
    else {
        if (pInt->BIOSScratch) {
            for (i = 0; i < BIOS_SCRATCH_LEN; i++)
                *(base + i) = *(pInt->BIOSScratch + i);
            free(pInt->BIOSScratch);
            pInt->BIOSScratch = NULL;
        }
    }

    pci_device_unmap_legacy(pInt->dev, base - BIOS_SCRATCH_OFF, pagesize);
}
#endif

xf86Int10InfoPtr
xf86InitInt10(int entityIndex)
{
    return xf86ExtendedInitInt10(entityIndex, 0);
}
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d40 6
a45 6
static int pciCfg1in(CARD16 addr, CARD32 *val);
static int pciCfg1out(CARD16 addr, CARD32 val);
static int pciCfg1inw(CARD16 addr, CARD16 *val);
static int pciCfg1outw(CARD16 addr, CARD16 val);
static int pciCfg1inb(CARD16 addr, CARD8 *val);
static int pciCfg1outb(CARD16 addr, CARD8 val);
d61 7
a67 7
    X86_EAX = (CARD32) pInt->ax;
    X86_EBX = (CARD32) pInt->bx;
    X86_ECX = (CARD32) pInt->cx;
    X86_EDX = (CARD32) pInt->dx;
    X86_ESI = (CARD32) pInt->si;
    X86_EDI = (CARD32) pInt->di;
    X86_EBP = (CARD32) pInt->bp;
d89 9
a97 9
    pInt->ax = (CARD32) X86_EAX;
    pInt->bx = (CARD32) X86_EBX;
    pInt->cx = (CARD32) X86_ECX;
    pInt->dx = (CARD32) X86_EDX;
    pInt->si = (CARD32) X86_ESI;
    pInt->di = (CARD32) X86_EDI;
    pInt->es = (CARD16) X86_ES;
    pInt->bp = (CARD32) X86_EBP;
    pInt->flags = (CARD32) X86_FLAGS;
d105 1
a105 1
CARD32
d112 1
a112 1
pushw(xf86Int10InfoPtr pInt, CARD16 val)
d115 1
a115 1
    MEM_WW(pInt, ((CARD32) X86_SS << 4) + X86_SP, val);
d121 1
a121 1
    CARD32 eflags;
d170 1
a170 1
    CARD32 lina = SEG_ADR((CARD32), X86_CS, IP);
d173 1
a173 1
                   lina);
d206 2
a207 2
    unsigned long stack = SEG_ADR((CARD32), X86_SS, SP);
    unsigned long tail = (CARD32) ((X86_SS << 4) + 0x1000);
d225 1
a225 1
             CARD16 port, CARD32 base, int d_f, CARD32 count)
d228 1
a228 1
    CARD32 dst = base;
d232 1
a232 1
               port, count, base, d_f ? "up" : "down");
d242 1
a242 1
             CARD16 port, CARD32 base, int d_f, CARD32 count)
d245 1
a245 1
    CARD32 dst = base;
d249 1
a249 1
               port, count, base, d_f ? "up" : "down");
d259 1
a259 1
             CARD16 port, CARD32 base, int d_f, CARD32 count)
d262 1
a262 1
    CARD32 dst = base;
d266 1
a266 1
               port, count, base, d_f ? "up" : "down");
d276 1
a276 1
              CARD16 port, CARD32 base, int d_f, CARD32 count)
d279 1
a279 1
    CARD32 dst = base;
d283 1
a283 1
               port, count, base, d_f ? "up" : "down");
d293 1
a293 1
              CARD16 port, CARD32 base, int d_f, CARD32 count)
d296 1
a296 1
    CARD32 dst = base;
d300 1
a300 1
               port, count, base, d_f ? "up" : "down");
d310 1
a310 1
              CARD16 port, CARD32 base, int d_f, CARD32 count)
d313 1
a313 1
    CARD32 dst = base;
d317 1
a317 1
               port, count, base, d_f ? "up" : "down");
d325 2
a326 2
CARD8
x_inb(CARD16 port)
d328 1
a328 1
    CARD8 val;
d332 1
a332 1
        val = (CARD8) (Int10Current->inb40time >>
d356 2
a357 2
CARD16
x_inw(CARD16 port)
d359 1
a359 1
    CARD16 val;
d369 1
a369 1
        val = (CARD16) (tv.tv_usec / 3);
d380 1
a380 1
x_outb(CARD16 port, CARD8 val)
d392 1
a392 1
        Int10Current->inb40time = (CARD16) (tv.tv_usec | 1);
d414 1
a414 1
x_outw(CARD16 port, CARD16 val)
d424 2
a425 2
CARD32
x_inl(CARD16 port)
d427 1
a427 1
    CARD32 val;
d432 1
a432 1
            ErrorF(" inl(%#x) = %8.8" PRIx32 "\n", port, val);
d438 1
a438 1
x_outl(CARD16 port, CARD32 val)
d442 1
a442 1
            ErrorF(" outl(%#x, %8.8" PRIx32 ")\n", port, val);
d447 2
a448 2
CARD8
Mem_rb(CARD32 addr)
d453 2
a454 2
CARD16
Mem_rw(CARD32 addr)
d459 2
a460 2
CARD32
Mem_rl(CARD32 addr)
d466 1
a466 1
Mem_wb(CARD32 addr, CARD8 val)
d472 1
a472 1
Mem_ww(CARD32 addr, CARD16 val)
d478 1
a478 1
Mem_wl(CARD32 addr, CARD32 val)
d483 1
a483 1
static CARD32 PciCfg1Addr = 0;
d494 1
a494 1
pci_device_for_cfg_address(CARD32 addr)
d497 1
a497 1
    CARD32 tag = PCI_TAG(addr);
d519 1
a519 1
pciCfg1in(CARD16 addr, CARD32 *val)
d529 2
a530 2
            ErrorF(" cfg_inl(%#" PRIx32 ") = %8.8" PRIx32 "\n", PciCfg1Addr,
                   *val);
d537 1
a537 1
pciCfg1out(CARD16 addr, CARD32 val)
d545 2
a546 2
            ErrorF(" cfg_outl(%#" PRIx32 ", %8.8" PRIx32 ")\n", PciCfg1Addr,
                   val);
d555 1
a555 1
pciCfg1inw(CARD16 addr, CARD16 *val)
d570 2
a571 2
            ErrorF(" cfg_inw(%#" PRIx32 ") = %4.4x\n", PciCfg1Addr + offset,
                   *val);
d578 1
a578 1
pciCfg1outw(CARD16 addr, CARD16 val)
d585 1
a585 1
        PciCfg1Addr |= ((CARD32) val) << shift;
d592 2
a593 2
            ErrorF(" cfg_outw(%#" PRIx32 ", %4.4x)\n", PciCfg1Addr + offset,
                   val);
d602 1
a602 1
pciCfg1inb(CARD16 addr, CARD8 *val)
d617 2
a618 2
            ErrorF(" cfg_inb(%#" PRIx32 ") = %2.2x\n", PciCfg1Addr + offset,
                   *val);
d625 1
a625 1
pciCfg1outb(CARD16 addr, CARD8 val)
d632 1
a632 1
        PciCfg1Addr |= ((CARD32) val) << shift;
d639 2
a640 2
            ErrorF(" cfg_outb(%#" PRIx32 ", %2.2x)\n", PciCfg1Addr + offset,
                   val);
d648 2
a649 2
CARD8
bios_checksum(const CARD8 *start, int size)
d651 1
a651 1
    CARD8 sum = 0;
d685 2
a686 2
    pci_io_write8(pInt->io, 0x03C2, ~(CARD8) 0x03 & vga->save_msr);
    pci_io_write8(pInt->io, 0x03C3, ~(CARD8) 0x01 & vga->save_vse);
d688 1
a688 1
    pci_io_write8(pInt->io, 0x46E8, ~(CARD8) 0x08 & vga->save_46e8);
d690 1
a690 1
    pci_io_write8(pInt->io, 0x0102, ~(CARD8) 0x01 & vga->save_pos102);
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d128 1
a128 1
            xf86DrvMsg(pInt->scrnIndex, X_NOTICE,
d136 1
a136 1
            xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 2,
d172 1
a172 1
    xf86DrvMsgVerb(pInt->scrnIndex, X_INFO, 3, "code at 0x%8.8" PRIx32 ":\n",
d185 1
a185 1
    xf86DrvMsgVerb(pInt->scrnIndex, X_INFO, 3,
d189 1
a189 1
    xf86DrvMsgVerb(pInt->scrnIndex, X_INFO, 3,
d193 1
a193 1
    xf86DrvMsgVerb(pInt->scrnIndex, X_INFO, 3,
d197 1
a197 1
    xf86DrvMsgVerb(pInt->scrnIndex, X_INFO, 3,
d340 1
a340 1
        xf86DrvMsgVerb(Int10Current->scrnIndex, X_NOT_IMPLEMENTED, 2,
d398 1
a398 1
        xf86DrvMsgVerb(Int10Current->scrnIndex, X_NOT_IMPLEMENTED, 2,
@


1.6
log
@Update to xserver 1.11.2
@
text
@d46 1
d57 3
a59 3
	if (!MapCurrentInt10(pInt))
	    return -1;
	Int10Current = pInt;
d68 5
a72 3
    X86_ESP = 0x1000; X86_SS = pInt->stackseg >> 4;
    X86_EIP = 0x0600; X86_CS = 0x0;	/* address of 'hlt' */
    X86_DS = 0x40;			/* standard pc ds */
d79 1
a79 1
	SetResetBIOSVars(pInt, TRUE);
d100 1
a100 1
	SetResetBIOSVars(pInt, FALSE);
d106 1
a106 1
getIntVect(xf86Int10InfoPtr pInt,int num)
d122 1
d125 1
a125 1
    if (MEM_RW(pInt, (num << 2) + 2) == (SYS_BIOS >> 4)) { /* SYS_BIOS_SEG ?*/
d127 17
a143 16
	if (num == 21 && X86_AH == 0x4e) {
 	    xf86DrvMsg(pInt->scrnIndex, X_NOTICE,
		       "Failing Find-Matching-File on non-PC"
			" (int 21, func 4e)\n");
 	    X86_AX = 2;
 	    SET_FLAG(F_CF);
 	    return 1;
 	} else {
	    xf86DrvMsgVerb(pInt->scrnIndex, X_NOT_IMPLEMENTED, 2,
			   "Ignoring int 0x%02x call\n", num);
	    if (xf86GetVerbosity() > 3) {
		dump_registers(pInt);
		stack_trace(pInt);
	    }
	    return 1;
	}
d152 1
a152 1
    X86_EFLAGS = X86_EFLAGS  & ~(VIF_MASK | TF_MASK | IF_MASK | NT_MASK);
d158 1
a158 1
    X86_IP = MEM_RW(pInt,  num << 2);
d170 1
a170 1
    unsigned long lina = SEG_ADR((CARD32), X86_CS, IP);
d172 4
a175 3
    xf86DrvMsgVerb(pInt->scrnIndex, X_INFO, 3, "code at 0x%8.8lx:\n", lina);
    for (i=0; i<0x10; i++)
	xf86ErrorFVerb(3, " %2.2x", MEM_RB(pInt, lina + i));
d177 2
a178 2
    for (; i<0x20; i++)
	xf86ErrorFVerb(3, " %2.2x", MEM_RB(pInt, lina + i));
d186 3
a188 3
	"EAX=0x%8.8lx, EBX=0x%8.8lx, ECX=0x%8.8lx, EDX=0x%8.8lx\n",
	(unsigned long)X86_EAX, (unsigned long)X86_EBX,
	(unsigned long)X86_ECX, (unsigned long)X86_EDX);
d190 3
a192 3
	"ESP=0x%8.8lx, EBP=0x%8.8lx, ESI=0x%8.8lx, EDI=0x%8.8lx\n",
	(unsigned long)X86_ESP, (unsigned long)X86_EBP,
	(unsigned long)X86_ESI, (unsigned long)X86_EDI);
d194 3
a196 3
	"CS=0x%4.4x, SS=0x%4.4x,"
	" DS=0x%4.4x, ES=0x%4.4x, FS=0x%4.4x, GS=0x%4.4x\n",
	X86_CS, X86_SS, X86_DS, X86_ES, X86_FS, X86_GS);
d198 2
a199 2
	"EIP=0x%8.8lx, EFLAGS=0x%8.8lx\n",
	(unsigned long)X86_EIP, (unsigned long)X86_EFLAGS);
d207 1
a207 1
    unsigned long tail  = (CARD32)((X86_SS << 4) + 0x1000);
d209 2
a210 1
    if (stack >= tail) return;
d214 4
a217 4
	xf86ErrorFVerb(3, " %2.2x", MEM_RB(pInt, stack));
	i = (i + 1) % 0x10;
	if (!i)
	    xf86ErrorFVerb(3, "\n");
d220 1
a220 1
	xf86ErrorFVerb(3, "\n");
d225 1
a225 1
	     CARD16 port, CARD32 base, int d_f, CARD32 count)
d229 1
d231 2
a232 2
	ErrorF(" rep_insb(%#x) %ld bytes at %8.8lx %s\n",
		port, count, base, d_f ? "up" : "down");
d234 2
a235 2
	MEM_WB(pInt, dst, x_inb(port));
	dst += inc;
d242 1
a242 1
	     CARD16 port, CARD32 base, int d_f, CARD32 count)
d246 1
d248 2
a249 2
	ErrorF(" rep_insw(%#x) %ld bytes at %8.8lx %s\n",
	     port, count, base, d_f ? "up" : "down");
d251 2
a252 2
	MEM_WW(pInt, dst, x_inw(port));
	dst += inc;
d259 1
a259 1
	     CARD16 port, CARD32 base, int d_f, CARD32 count)
d263 1
d265 2
a266 2
	ErrorF(" rep_insl(%#x) %ld bytes at %8.8lx %s\n",
	     port, count, base, d_f ? "up" : "down");
d268 2
a269 2
	MEM_WL(pInt, dst, x_inl(port));
	dst += inc;
d276 1
a276 1
	      CARD16 port, CARD32 base, int d_f, CARD32 count)
d280 1
d282 2
a283 2
	ErrorF(" rep_outb(%#x) %ld bytes at %8.8lx %s\n",
	     port, count, base, d_f ? "up" : "down");
d285 2
a286 2
	x_outb(port, MEM_RB(pInt, dst));
	dst += inc;
d293 1
a293 1
	      CARD16 port, CARD32 base, int d_f, CARD32 count)
d297 1
d299 2
a300 2
	ErrorF(" rep_outw(%#x) %ld bytes at %8.8lx %s\n",
	     port, count, base, d_f ? "up" : "down");
d302 2
a303 2
	x_outw(port, MEM_RW(pInt, dst));
	dst += inc;
d310 1
a310 1
	      CARD16 port, CARD32 base, int d_f, CARD32 count)
d314 1
d316 2
a317 2
	ErrorF(" rep_outl(%#x) %ld bytes at %8.8lx %s\n",
	     port, count, base, d_f ? "up" : "down");
d319 2
a320 2
	x_outl(port, MEM_RL(pInt, dst));
	dst += inc;
d331 5
a335 5
	Int10Current->inb40time++;
	val = (CARD8)(Int10Current->inb40time >>
		      ((Int10Current->inb40time & 1) << 3));
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" inb(%#x) = %2.2x\n", port, val);
d337 15
a351 13
    } else if (port < 0x0100) {		/* Don't interfere with mainboard */
	val = 0;
	xf86DrvMsgVerb(Int10Current->scrnIndex, X_NOT_IMPLEMENTED, 2,
	    "inb 0x%4.4x\n", port);
	if (xf86GetVerbosity() > 3) {
	    dump_registers(Int10Current);
	    stack_trace(Int10Current);
	}
#endif /* __NOT_YET__ */
    } else if (!pciCfg1inb(port, &val)) {
	val = inb(Int10Current->ioBase + port);
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" inb(%#x) = %2.2x\n", port, val);
d362 1
a362 1
	struct timeval tv;
d364 11
a374 10
	/*
	 * Emulate a PC98's timer.  Typical resolution is 3.26 usec.
	 * Approximate this by dividing by 3.
	 */
	X_GETTIMEOFDAY(&tv);
	val = (CARD16)(tv.tv_usec / 3);
    } else if (!pciCfg1inw(port, &val)) {
	val = inw(Int10Current->ioBase + port);
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" inw(%#x) = %4.4x\n", port, val);
d383 12
a394 11
	struct timeval tv;
	/*
	 * Emulate a PC's timer 0.  Such timers typically have a resolution of
	 * some .838 usec per tick, but this can only provide 1 usec per tick.
	 * (Not that this matters much, given inherent emulation delays.)  Use
	 * the bottom bit as a byte select.  See inb(0x40) above.
	 */
	X_GETTIMEOFDAY(&tv);
	Int10Current->inb40time = (CARD16)(tv.tv_usec | 1);
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" outb(%#x, %2.2x)\n", port, val);
d396 14
a409 12
    } else if (port < 0x0100) {		/* Don't interfere with mainboard */
	xf86DrvMsgVerb(Int10Current->scrnIndex, X_NOT_IMPLEMENTED, 2,
	    "outb 0x%4.4x,0x%2.2x\n", port, val);
	if (xf86GetVerbosity() > 3) {
	    dump_registers(Int10Current);
	    stack_trace(Int10Current);
	}
#endif /* __NOT_YET__ */
    } else if (!pciCfg1outb(port, val)) {
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" outb(%#x, %2.2x)\n", port, val);
	outb(Int10Current->ioBase + port, val);
d418 3
a420 3
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" outw(%#x, %4.4x)\n", port, val);
	outw(Int10Current->ioBase + port, val);
d430 3
a432 3
	val = inl(Int10Current->ioBase + port);
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" inl(%#x) = %8.8lx\n", port, val);
d441 3
a443 3
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" outl(%#x, %8.8lx)\n", port, val);
	outl(Int10Current->ioBase + port, val);
d450 1
a450 1
    return (*Int10Current->mem->rb)(Int10Current, addr);
d456 1
a456 1
    return (*Int10Current->mem->rw)(Int10Current, addr);
d462 1
a462 1
    return (*Int10Current->mem->rl)(Int10Current, addr);
d468 1
a468 1
    (*Int10Current->mem->wb)(Int10Current, addr, val);
d474 1
a474 1
    (*Int10Current->mem->ww)(Int10Current, addr, val);
d480 1
a480 1
    (*Int10Current->mem->wl)(Int10Current, addr, val);
d493 2
a494 2
static struct pci_device*
pci_device_for_cfg_address (CARD32 addr)
d496 13
a508 12
	struct pci_device *dev = NULL;
	PCITAG tag = PCI_TAG(addr);
	struct pci_slot_match slot_match = {
		.domain = PCI_DOM_FROM_TAG(tag),
		.bus = PCI_BUS_NO_DOMAIN(PCI_BUS_FROM_TAG(tag)),
		.dev = PCI_DEV_FROM_TAG(tag),
		.func = PCI_FUNC_FROM_TAG(tag),
		.match_data = 0
	};

	struct pci_device_iterator *iter =
	    pci_slot_match_iterator_create (&slot_match);
d510 2
a511 2
	if (iter)
		dev = pci_device_next(iter);
d513 1
a513 1
	pci_iterator_destroy(iter);
d515 1
a515 1
	return dev;
d522 2
a523 2
	*val = PciCfg1Addr;
	return 1;
d526 6
a531 5
	pci_device_cfg_read_u32(pci_device_for_cfg_address(PciCfg1Addr),
			(uint32_t *)val, PCI_OFFSET(PciCfg1Addr));
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" cfg_inl(%#lx) = %8.8lx\n", PciCfg1Addr, *val);
	return 1;
d540 2
a541 2
	PciCfg1Addr = val;
	return 1;
d544 6
a549 5
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" cfg_outl(%#lx, %8.8lx)\n", PciCfg1Addr, val);
	pci_device_cfg_write_u32(pci_device_for_cfg_address(PciCfg1Addr),
			val, PCI_OFFSET(PciCfg1Addr));
	return 1;
d560 3
a562 3
	shift = (addr - 0xCF8) * 8;
	*val = (PciCfg1Addr >> shift) & 0xffff;
	return 1;
d565 1
a565 1
	const unsigned offset = addr - 0xCFC;
d567 6
a572 5
	pci_device_cfg_read_u16(pci_device_for_cfg_address(PciCfg1Addr),
			val, PCI_OFFSET(PciCfg1Addr) + offset);
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" cfg_inw(%#lx) = %4.4x\n", PciCfg1Addr + offset, *val);
	return 1;
d583 4
a586 4
	shift = (addr - 0xCF8) * 8;
	PciCfg1Addr &= ~(0xffff << shift);
	PciCfg1Addr |= ((CARD32) val) << shift;
	return 1;
d589 1
a589 1
	const unsigned offset = addr - 0xCFC;
d591 6
a596 5
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" cfg_outw(%#lx, %4.4x)\n", PciCfg1Addr + offset, val);
	pci_device_cfg_write_u16(pci_device_for_cfg_address(PciCfg1Addr),
			val, PCI_OFFSET(PciCfg1Addr) + offset);
	return 1;
d607 3
a609 3
	shift = (addr - 0xCF8) * 8;
	*val = (PciCfg1Addr >> shift) & 0xff;
	return 1;
d612 1
a612 1
	const unsigned offset = addr - 0xCFC;
d614 6
a619 5
	pci_device_cfg_read_u8(pci_device_for_cfg_address(PciCfg1Addr),
			val, PCI_OFFSET(PciCfg1Addr) + offset);
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" cfg_inb(%#lx) = %2.2x\n", PciCfg1Addr + offset, *val);
	return 1;
d630 4
a633 4
	shift = (addr - 0xCF8) * 8;
	PciCfg1Addr &= ~(0xff << shift);
	PciCfg1Addr |= ((CARD32) val) << shift;
	return 1;
d636 1
a636 1
	const unsigned offset = addr - 0xCFC;
d638 6
a643 5
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" cfg_outb(%#lx, %2.2x)\n", PciCfg1Addr + offset, val);
	pci_device_cfg_write_u8(pci_device_for_cfg_address(PciCfg1Addr),
			val, PCI_OFFSET(PciCfg1Addr) + offset);
	return 1;
d654 1
a654 1
	sum += *start++;
d679 2
a680 2
    vga->save_msr    = inb(pInt->ioBase + 0x03CC);
    vga->save_vse    = inb(pInt->ioBase + 0x03C3);
d682 1
a682 1
    vga->save_46e8   = inb(pInt->ioBase + 0x46E8);
d684 3
a686 3
    vga->save_pos102 = inb(pInt->ioBase + 0x0102);
    outb(pInt->ioBase + 0x03C2, ~(CARD8)0x03 & vga->save_msr);
    outb(pInt->ioBase + 0x03C3, ~(CARD8)0x01 & vga->save_vse);
d688 1
a688 1
    outb(pInt->ioBase + 0x46E8, ~(CARD8)0x08 & vga->save_46e8);
d690 1
a690 1
    outb(pInt->ioBase + 0x0102, ~(CARD8)0x01 & vga->save_pos102);
d696 1
a696 1
    outb(pInt->ioBase + 0x0102, vga->save_pos102);
d698 1
a698 1
    outb(pInt->ioBase + 0x46E8, vga->save_46e8);
d700 2
a701 2
    outb(pInt->ioBase + 0x03C3, vga->save_vse);
    outb(pInt->ioBase + 0x03C2, vga->save_msr);
d709 1
a709 2
    unsigned char* base = xf86MapVidMem(pInt->scrnIndex,
					VIDMEM_MMIO, 0, pagesize);
d712 4
d717 6
a722 5
	for (i = BIOS_SCRATCH_OFF; i < BIOS_SCRATCH_END; i++)
	    MEM_WW(pInt, i, *(base + i));
    } else {
	for (i = BIOS_SCRATCH_OFF; i < BIOS_SCRATCH_END; i++)
	    *(base + i) = MEM_RW(pInt, i);
d724 2
a725 2
    
    xf86UnMapVidMem(pInt->scrnIndex,base,pagesize);
d732 1
a732 1
    unsigned char* base;
d736 7
a742 4
	|| (!save && !pInt->BIOSScratch))
	return;
    
    base = xf86MapVidMem(pInt->scrnIndex, VIDMEM_MMIO, 0, pagesize);
d745 11
a755 11
	if ((pInt->BIOSScratch
	     = xnfalloc(BIOS_SCRATCH_LEN)))
	    for (i = 0; i < BIOS_SCRATCH_LEN; i++)
		*(((char*)pInt->BIOSScratch + i)) = *(base + i);	
    } else {
	if (pInt->BIOSScratch) {
	    for (i = 0; i < BIOS_SCRATCH_LEN; i++)
		*(base + i) = *(pInt->BIOSScratch + i); 
	    free(pInt->BIOSScratch);
	    pInt->BIOSScratch = NULL;
	}
d757 2
a758 2
    
    xf86UnMapVidMem(pInt->scrnIndex,base - BIOS_SCRATCH_OFF ,pagesize);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d78 2
a79 1
    return xf86BlockSIGIO();
d85 1
a85 1
    xf86UnblockSIGIO(sig);
d466 5
d507 1
a507 1
			val, PCI_OFFSET(PciCfg1Addr));
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d714 1
a714 1
	    xfree(pInt->BIOSScratch);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d222 1
a222 1
	ErrorF(" rep_insb(%#x) %d bytes at %8.8x %s\n",
d238 1
a238 1
	ErrorF(" rep_insw(%#x) %d bytes at %8.8x %s\n",
d254 1
a254 1
	ErrorF(" rep_insl(%#x) %d bytes at %8.8x %s\n",
d270 1
a270 1
	ErrorF(" rep_outb(%#x) %d bytes at %8.8x %s\n",
d286 1
a286 1
	ErrorF(" rep_outw(%#x) %d bytes at %8.8x %s\n",
d302 1
a302 1
	ErrorF(" rep_outl(%#x) %d bytes at %8.8x %s\n",
d412 1
a412 1
	    ErrorF(" inl(%#x) = %8.8x\n", port, val);
d422 1
a422 1
	    ErrorF(" outl(%#x, %8.8x)\n", port, val);
d503 1
a503 1
	    ErrorF(" cfg_inl(%#x) = %8.8x\n", PciCfg1Addr, *val);
d518 1
a518 1
	    ErrorF(" cfg_outl(%#x, %8.8x)\n", PciCfg1Addr, val);
d542 1
a542 1
	    ErrorF(" cfg_inw(%#x) = %4.4x\n", PciCfg1Addr + offset, *val);
d563 1
a563 1
	    ErrorF(" cfg_outw(%#x, %4.4x)\n", PciCfg1Addr + offset, val);
d587 1
a587 1
	    ErrorF(" cfg_inb(%#x) = %2.2x\n", PciCfg1Addr + offset, *val);
d608 1
a608 1
	    ErrorF(" cfg_outb(%#x, %2.2x)\n", PciCfg1Addr + offset, val);
a646 1
    xf86SetCurrentAccess(FALSE, xf86Screens[pInt->scrnIndex]);
a658 1
    xf86SetCurrentAccess(TRUE, xf86Screens[pInt->scrnIndex]);
a663 1
    xf86SetCurrentAccess(FALSE, xf86Screens[pInt->scrnIndex]);
a669 1
    xf86SetCurrentAccess(TRUE, xf86Screens[pInt->scrnIndex]);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d35 2
@


1.1
log
@Initial revision
@
text
@d6 2
a7 2
 *   Part of this is based on code taken from DOSEMU
 *   (C) Copyright 1992, ..., 1999 the "DOSEMU-Development-Team"
d11 1
a11 1
 * To debug port accesses define PRINT_PORT.
d21 2
d32 5
d219 3
a221 4
#ifdef PRINT_PORT
    ErrorF(" rep_insb(%#x) %d bytes at %p %s\n",
	     port, count, base, d_f ? "up" : "down");
#endif
d235 2
a236 2
#ifdef PRINT_PORT
    ErrorF(" rep_insw(%#x) %d bytes at %p %s\n",
a237 1
#endif
d251 2
a252 2
#ifdef PRINT_PORT
    ErrorF(" rep_insl(%#x) %d bytes at %p %s\n",
a253 1
#endif
d267 2
a268 2
#ifdef PRINT_PORT
    ErrorF(" rep_outb(%#x) %d bytes at %p %s\n",
a269 1
#endif
d283 2
a284 2
#ifdef PRINT_PORT
    ErrorF(" rep_outw(%#x) %d bytes at %p %s\n",
a285 1
#endif
d299 2
a300 2
#ifdef PRINT_PORT
    ErrorF(" rep_outl(%#x) %d bytes at %p %s\n",
a301 1
#endif
d318 2
a319 3
#ifdef PRINT_PORT
	ErrorF(" inb(%#x) = %2.2x\n", port, val);
#endif
d330 4
a333 6
    } else {
	if (!pciCfg1inb(port, &val))
	    val = inb(Int10Current->ioBase + port);
#ifdef PRINT_PORT
	ErrorF(" inb(%#x) = %2.2x\n", port, val);
#endif
d352 4
a355 3
    } else {
	if (!pciCfg1inw(port, &val))
	    val = inw(Int10Current->ioBase + port);
a356 3
#ifdef PRINT_PORT
    ErrorF(" inw(%#x) = %4.4x\n", port, val);
#endif
d373 2
a374 3
#ifdef PRINT_PORT
	ErrorF(" outb(%#x, %2.2x)\n", port, val);
#endif
d384 4
a387 6
    } else {
#ifdef PRINT_PORT
	ErrorF(" outb(%#x, %2.2x)\n", port, val);
#endif
	if (!pciCfg1outb(port, val))
	    outb(Int10Current->ioBase + port, val);
a393 3
#ifdef PRINT_PORT
    ErrorF(" outw(%#x, %4.4x)\n", port, val);
#endif
d395 3
a397 1
    if (!pciCfg1outw(port, val))
d399 1
d407 1
a407 1
    if (!pciCfg1in(port, &val))
d409 3
a411 4

#ifdef PRINT_PORT
    ErrorF(" inl(%#x) = %8.8x\n", port, val);
#endif
d418 3
a420 5
#ifdef PRINT_PORT
    ErrorF(" outl(%#x, %8.8x)\n", port, val);
#endif

    if (!pciCfg1out(port, val))
d422 1
d463 26
a488 1
#define OFFSET(Cfg1Addr) (Cfg1Addr & 0xff)
d498 4
a501 1
	*val = pciReadLong(Int10Current->Tag, OFFSET(PciCfg1Addr));
d515 4
a518 1
	pciWriteLong(Int10Current->Tag, OFFSET(PciCfg1Addr), val);
d527 1
a527 1
    int offset, shift;
d535 6
a540 2
	offset = addr - 0xCFC;
	*val = pciReadWord(Int10Current->Tag, OFFSET(PciCfg1Addr) + offset);
d549 1
a549 1
    int offset, shift;
d558 6
a563 2
	offset = addr - 0xCFC;
	pciWriteWord(Int10Current->Tag, OFFSET(PciCfg1Addr) + offset, val);
d572 1
a572 1
    int offset, shift;
d580 6
a585 2
	offset = addr - 0xCFC;
	*val = pciReadByte(Int10Current->Tag, OFFSET(PciCfg1Addr) + offset);
d594 1
a594 1
    int offset, shift;
d603 6
a608 2
	offset = addr - 0xCFC;
	pciWriteByte(Int10Current->Tag, OFFSET(PciCfg1Addr) + offset, val);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d6 2
a7 2
 *   Part of this code was inspired  by the VBIOS POSTing code in DOSEMU
 *   developed by the "DOSEMU-Development-Team"
d11 1
a11 1
 * To debug port accesses define PRINT_PORT to 1.
a20 2
#define PRINT_PORT 0

a29 3
#ifdef _X86EMU
#include "x86emu/x86emui.h"
#endif
a42 2
static int pci_config_cycle = 0;

d212 4
a215 3
    if (PRINT_PORT && DEBUG_IO_TRACE())
	ErrorF(" rep_insb(%#x) %d bytes at %8.8x %s\n",
		port, count, base, d_f ? "up" : "down");
d229 2
a230 2
    if (PRINT_PORT && DEBUG_IO_TRACE())
	ErrorF(" rep_insw(%#x) %d bytes at %8.8x %s\n",
d232 1
d246 2
a247 2
    if (PRINT_PORT && DEBUG_IO_TRACE())
	ErrorF(" rep_insl(%#x) %d bytes at %8.8x %s\n",
d249 1
d263 2
a264 2
    if (PRINT_PORT && DEBUG_IO_TRACE())
	ErrorF(" rep_outb(%#x) %d bytes at %8.8x %s\n",
d266 1
d280 2
a281 2
    if (PRINT_PORT && DEBUG_IO_TRACE())
	ErrorF(" rep_outw(%#x) %d bytes at %8.8x %s\n",
d283 1
d297 2
a298 2
    if (PRINT_PORT && DEBUG_IO_TRACE())
	ErrorF(" rep_outl(%#x) %d bytes at %8.8x %s\n",
d300 1
d317 3
a319 2
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" inb(%#x) = %2.2x\n", port, val);
d330 6
a335 4
    } else if (!pciCfg1inb(port, &val)) {
	val = inb(Int10Current->ioBase + port);
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" inb(%#x) = %2.2x\n", port, val);
d354 3
a356 4
    } else if (!pciCfg1inw(port, &val)) {
	val = inw(Int10Current->ioBase + port);
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" inw(%#x) = %4.4x\n", port, val);
d358 3
d377 3
a379 2
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" outb(%#x, %2.2x)\n", port, val);
d389 6
a394 4
    } else if (!pciCfg1outb(port, val)) {
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" outb(%#x, %2.2x)\n", port, val);
	outb(Int10Current->ioBase + port, val);
d401 3
d405 1
a405 3
    if (!pciCfg1outw(port, val)) {
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" outw(%#x, %4.4x)\n", port, val);
a406 1
    }
d414 1
a414 1
    if (!pciCfg1in(port, &val)) {
d416 4
a419 3
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" inl(%#x) = %8.8x\n", port, val);
    }
d426 5
a430 3
    if (!pciCfg1out(port, val)) {
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" outl(%#x, %8.8x)\n", port, val);
a431 1
    }
a482 2
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" cfg_inl(%#x) = %8.8x\n", PciCfg1Addr, *val);
a495 2
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" cfg_outl(%#x, %8.8x)\n", PciCfg1Addr, val);
a514 2
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" cfg_inw(%#x) = %4.4x\n", PciCfg1Addr + offset, *val);
a532 2
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" cfg_outw(%#x, %4.4x)\n", PciCfg1Addr + offset, val);
a551 2
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" cfg_inb(%#x) = %2.2x\n", PciCfg1Addr + offset, *val);
a569 2
	if (PRINT_PORT && DEBUG_IO_TRACE())
	    ErrorF(" cfg_outb(%#x, %2.2x)\n", PciCfg1Addr + offset, val);
@

