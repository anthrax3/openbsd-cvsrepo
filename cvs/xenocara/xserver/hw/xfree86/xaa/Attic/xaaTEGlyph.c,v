head	1.6;
access;
symbols
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.06.07.17.28.53;	author matthieu;	state dead;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.45;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.45;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "xaa.h"
#include "xaalocal.h"
#include "xaacexp.h"
#include "xf86.h"

/* scanline function for TRIPLE_BITS_24BPP */
static CARD32 *DrawTextScanline3(CARD32 *base, CARD32 *mem, int width);

/* Loop unrolled functions for common font widths */
static CARD32 *DrawTETextScanlineGeneric(CARD32 *base, unsigned int **glyphp,
                                         int line, int width, int glyphwidth);
static CARD32 *DrawTETextScanlineWidth7(CARD32 *base, unsigned int **glyphp,
                                        int line, int width, int glyphwidth);
static CARD32 *DrawTETextScanlineWidth10(CARD32 *base, unsigned int **glyphp,
                                         int line, int width, int glyphwidth);
static CARD32 *DrawTETextScanlineWidth12(CARD32 *base, unsigned int **glyphp,
                                         int line, int width, int glyphwidth);
static CARD32 *DrawTETextScanlineWidth14(CARD32 *base, unsigned int **glyphp,
                                         int line, int width, int glyphwidth);
static CARD32 *DrawTETextScanlineWidth16(CARD32 *base, unsigned int **glyphp,
                                         int line, int width, int glyphwidth);
static CARD32 *DrawTETextScanlineWidth18(CARD32 *base, unsigned int **glyphp,
                                         int line, int width, int glyphwidth);
static CARD32 *DrawTETextScanlineWidth24(CARD32 *base, unsigned int **glyphp,
                                         int line, int width, int glyphwidth);

#ifdef USEASSEMBLER
#ifdef FIXEDBASE
#ifdef MSBFIRST
CARD32 *DrawTETextScanlineWidth6PMSBFirstFixedBase(CARD32 *base,
                                                   unsigned int **glyphp,
                                                   int line, int width,
                                                   int glyphwidth);
CARD32 *DrawTETextScanlineWidth8PMSBFirstFixedBase(CARD32 *base,
                                                   unsigned int **glyphp,
                                                   int line, int width,
                                                   int glyphwidth);
CARD32 *DrawTETextScanlineWidth9PMSBFirstFixedBase(CARD32 *base,
                                                   unsigned int **glyphp,
                                                   int line, int width,
                                                   int glyphwidth);
#else
CARD32 *DrawTETextScanlineWidth6PLSBFirstFixedBase(CARD32 *base,
                                                   unsigned int **glyphp,
                                                   int line, int width,
                                                   int glyphwidth);
CARD32 *DrawTETextScanlineWidth8PLSBFirstFixedBase(CARD32 *base,
                                                   unsigned int **glyphp,
                                                   int line, int width,
                                                   int glyphwidth);
CARD32 *DrawTETextScanlineWidth9PLSBFirstFixedBase(CARD32 *base,
                                                   unsigned int **glyphp,
                                                   int line, int width,
                                                   int glyphwidth);
#endif
#else
#ifdef MSBFIRST
CARD32 *DrawTETextScanlineWidth6PMSBFirst(CARD32 *base, unsigned int **glyphp,
                                          int line, int width, int glyphwidth);
CARD32 *DrawTETextScanlineWidth8PMSBFirst(CARD32 *base, unsigned int **glyphp,
                                          int line, int width, int glyphwidth);
CARD32 *DrawTETextScanlineWidth9PMSBFirst(CARD32 *base, unsigned int **glyphp,
                                          int line, int width, int glyphwidth);
#else
CARD32 *DrawTETextScanlineWidth6PLSBFirst(CARD32 *base, unsigned int **glyphp,
                                          int line, int width, int glyphwidth);
CARD32 *DrawTETextScanlineWidth8PLSBFirst(CARD32 *base, unsigned int **glyphp,
                                          int line, int width, int glyphwidth);
CARD32 *DrawTETextScanlineWidth9PLSBFirst(CARD32 *base, unsigned int **glyphp,
                                          int line, int width, int glyphwidth);
#endif
#endif
#else
static CARD32 *DrawTETextScanlineWidth6(CARD32 *base, unsigned int **glyphp,
                                        int line, int width, int glyphwidth);
static CARD32 *DrawTETextScanlineWidth8(CARD32 *base, unsigned int **glyphp,
                                        int line, int width, int glyphwidth);
static CARD32 *DrawTETextScanlineWidth9(CARD32 *base, unsigned int **glyphp,
                                        int line, int width, int glyphwidth);
#endif

#define glyph_scanline_func EXPNAME(XAAGlyphScanlineFunc)
#define glyph_get_scanline_func EXPNAME(XAAGetGlyphScanlineFunc)

GlyphScanlineFuncPtr glyph_scanline_func[32] = {
    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
    DrawTETextScanlineGeneric,
#ifdef USEASSEMBLER
#ifdef FIXEDBASE
#ifdef MSBFIRST
    DrawTETextScanlineWidth6PMSBFirstFixedBase,
    DrawTETextScanlineWidth7,
    DrawTETextScanlineWidth8PMSBFirstFixedBase,
    DrawTETextScanlineWidth9PMSBFirstFixedBase,
#else
    DrawTETextScanlineWidth6PLSBFirstFixedBase,
    DrawTETextScanlineWidth7,
    DrawTETextScanlineWidth8PLSBFirstFixedBase,
    DrawTETextScanlineWidth9PLSBFirstFixedBase,
#endif
#else
#ifdef MSBFIRST
    DrawTETextScanlineWidth6PMSBFirst,
    DrawTETextScanlineWidth7,
    DrawTETextScanlineWidth8PMSBFirst,
    DrawTETextScanlineWidth9PMSBFirst,
#else
    DrawTETextScanlineWidth6PLSBFirst,
    DrawTETextScanlineWidth7,
    DrawTETextScanlineWidth8PLSBFirst,
    DrawTETextScanlineWidth9PLSBFirst,
#endif
#endif
#else
    DrawTETextScanlineWidth6, DrawTETextScanlineWidth7,
    DrawTETextScanlineWidth8, DrawTETextScanlineWidth9,
#endif
    DrawTETextScanlineWidth10,
    DrawTETextScanlineGeneric, DrawTETextScanlineWidth12,
    DrawTETextScanlineGeneric, DrawTETextScanlineWidth14,
    DrawTETextScanlineGeneric, DrawTETextScanlineWidth16,
    DrawTETextScanlineGeneric, DrawTETextScanlineWidth18,
    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
    DrawTETextScanlineGeneric, DrawTETextScanlineWidth24,
    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric
};

GlyphScanlineFuncPtr *
glyph_get_scanline_func(void)
{
    return glyph_scanline_func;
}

/********************************************************************

   Here we have TEGlyphRenders for a bunch of different color
   expansion types.  The driver may provide its own renderer, but
   this is the default one which renders using lower-level primitives
   exported by the chipset driver.

********************************************************************/

/* This gets built for MSBFIRST or LSBFIRST with FIXEDBASE or not.
	A total of 4 versions */

void

EXPNAME(XAATEGlyphRenderer) (ScrnInfoPtr pScrn,
                             int x, int y, int w, int h, int skipleft,
                             int startline, unsigned int **glyphs,
                             int glyphWidth, int fg, int bg, int rop,
                             unsigned planemask) {
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    CARD32 *base;
    GlyphScanlineFuncPtr GlyphFunc = glyph_scanline_func[glyphWidth - 1];
    int dwords = 0;

    if ((bg != -1) && (infoRec->TEGlyphRendererFlags & TRANSPARENCY_ONLY)) {
        (*infoRec->SetupForSolidFill) (pScrn, bg, rop, planemask);
        (*infoRec->SubsequentSolidFillRect) (pScrn, x, y, w, h);
        bg = -1;
    }

    (*infoRec->SetupForCPUToScreenColorExpandFill) (pScrn, fg, bg, rop,
                                                    planemask);

    if (skipleft &&
        (!(infoRec->TEGlyphRendererFlags & LEFT_EDGE_CLIPPING) ||
         (!(infoRec->TEGlyphRendererFlags & LEFT_EDGE_CLIPPING_NEGATIVE_X) &&
          (skipleft > x)))) {
        /* draw the first character only */

        int count = h, line = startline;
        int width = glyphWidth - skipleft;

        if (width > w)
            width = w;

        (*infoRec->SubsequentCPUToScreenColorExpandFill) (pScrn, x, y, width, h,
                                                          0);

        base = (CARD32 *) infoRec->ColorExpandBase;

        while (count--) {
            register CARD32 tmp = SHIFT_R(glyphs[0][line++], skipleft);

            WRITE_BITS(tmp);
        }

        w -= width;
        if ((infoRec->TEGlyphRendererFlags & CPU_TRANSFER_PAD_QWORD) &&
            ((((width + 31) >> 5) * h) & 1)) {
            base = (CARD32 *) infoRec->ColorExpandBase;
            base[0] = 0x00000000;
        }
        if (!w)
            goto THE_END;
        glyphs++;
        x += width;
        skipleft = 0;           /* nicely aligned again */
    }

    w += skipleft;
    x -= skipleft;
    dwords = ((w + 31) >> 5) * h;

    (*infoRec->SubsequentCPUToScreenColorExpandFill) (pScrn, x, y, w, h,
                                                      skipleft);

    base = (CARD32 *) infoRec->ColorExpandBase;

#ifndef FIXEDBASE
    if ((((w + 31) >> 5) * h) <= infoRec->ColorExpandRange)
        while (h--) {
            base = (*GlyphFunc) (base, glyphs, startline++, w, glyphWidth);
        }
    else
#endif
        while (h--) {
            (*GlyphFunc) (base, glyphs, startline++, w, glyphWidth);
        }

    if ((infoRec->TEGlyphRendererFlags & CPU_TRANSFER_PAD_QWORD) &&
        (dwords & 1)) {
        base = (CARD32 *) infoRec->ColorExpandBase;
        base[0] = 0x00000000;
    }

 THE_END:

    if (infoRec->TEGlyphRendererFlags & SYNC_AFTER_COLOR_EXPAND)
        (*infoRec->Sync) (pScrn);
    else
        SET_SYNC_FLAG(infoRec);
}

/********************************************************************
 
   This is the GlyphRenderer for TRIPLE_BITS_24BPP. It renders to a buffer
   with the non FIXEDBASE LSB_FIRST code before tripling, and possibly
   reversing the bits and sending them to the screen

********************************************************************/

void

EXPNAME(XAATEGlyphRenderer3) (ScrnInfoPtr pScrn,
                              int x, int y, int w, int h, int skipleft,
                              int startline, unsigned int **glyphs,
                              int glyphWidth, int fg, int bg, int rop,
                              unsigned planemask) {
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    CARD32 *base, *mem;
    GlyphScanlineFuncPtr GlyphFunc =
        XAAGlyphScanlineFuncLSBFirst[glyphWidth - 1];
    int dwords = 0;

    if ((bg != -1) &&
        ((infoRec->TEGlyphRendererFlags & TRANSPARENCY_ONLY) ||
         ((infoRec->TEGlyphRendererFlags & RGB_EQUAL) &&
          (!CHECK_RGB_EQUAL(bg))))) {
        (*infoRec->SetupForSolidFill) (pScrn, bg, rop, planemask);
        (*infoRec->SubsequentSolidFillRect) (pScrn, x, y, w, h);
        bg = -1;
    }

    (*infoRec->SetupForCPUToScreenColorExpandFill) (pScrn, fg, bg, rop,
                                                    planemask);

    if (skipleft) {
        /* draw the first character only */

        int count = h, line = startline;
        int width = glyphWidth - skipleft;
        CARD32 bits;

        if (width > w)
            width = w;
        (*infoRec->SubsequentCPUToScreenColorExpandFill) (pScrn, x, y, width, h,
                                                          0);

        base = (CARD32 *) infoRec->ColorExpandBase;

        while (count--) {
            bits = SHIFT_R(glyphs[0][line++], skipleft);
            if (width >= 22) {
                WRITE_BITS3(bits);
            }
            else if (width >= 11) {
                WRITE_BITS2(bits);
            }
            else {
                WRITE_BITS1(bits);
            }
        }

        w -= width;
        if ((infoRec->TEGlyphRendererFlags & CPU_TRANSFER_PAD_QWORD) &&
            ((((3 * width + 31) >> 5) * h) & 1)) {
            base = (CARD32 *) infoRec->ColorExpandBase;
            base[0] = 0x00000000;
        }
        if (!w)
            goto THE_END;
        glyphs++;
        x += width;
        skipleft = 0;           /* nicely aligned again */
    }

    dwords = ((3 * w + 31) >> 5) * h;
    mem = (CARD32 *) malloc(((w + 31) >> 3) * sizeof(char));
    if (!mem)
        return;

    (*infoRec->SubsequentCPUToScreenColorExpandFill) (pScrn, x, y, w, h, 0);

    base = (CARD32 *) infoRec->ColorExpandBase;

#ifndef FIXEDBASE
    if ((((3 * w + 31) >> 5) * h) <= infoRec->ColorExpandRange)
        while (h--) {
            (*GlyphFunc) (mem, glyphs, startline++, w, glyphWidth);
            base = DrawTextScanline3(base, mem, w);
        }
    else
#endif
        while (h--) {
            (*GlyphFunc) (mem, glyphs, startline++, w, glyphWidth);
            DrawTextScanline3(base, mem, w);
        }

    free(mem);

    if ((infoRec->TEGlyphRendererFlags & CPU_TRANSFER_PAD_QWORD) &&
        (dwords & 1)) {
        base = (CARD32 *) infoRec->ColorExpandBase;
        base[0] = 0x00000000;
    }

 THE_END:

    if (infoRec->TEGlyphRendererFlags & SYNC_AFTER_COLOR_EXPAND)
        (*infoRec->Sync) (pScrn);
    else
        SET_SYNC_FLAG(infoRec);
}

#ifndef FIXEDBASE
/*  Scanline version of above gets built for LSBFIRST and MSBFIRST */

void

EXPNAME(XAATEGlyphRendererScanline) (ScrnInfoPtr pScrn,
                                     int x, int y, int w, int h, int skipleft,
                                     int startline, unsigned int **glyphs,
                                     int glyphWidth, int fg, int bg, int rop,
                                     unsigned planemask) {
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int bufferNo;
    CARD32 *base;
    GlyphScanlineFuncPtr GlyphFunc = glyph_scanline_func[glyphWidth - 1];

    if ((bg != -1) && (infoRec->TEGlyphRendererFlags & TRANSPARENCY_ONLY)) {
        (*infoRec->SetupForSolidFill) (pScrn, bg, rop, planemask);
        (*infoRec->SubsequentSolidFillRect) (pScrn, x, y, w, h);
        bg = -1;
    }

    (*infoRec->SetupForScanlineCPUToScreenColorExpandFill) (pScrn, fg, bg, rop,
                                                            planemask);

    if (skipleft &&
        (!(infoRec->TEGlyphRendererFlags & LEFT_EDGE_CLIPPING) ||
         (!(infoRec->TEGlyphRendererFlags & LEFT_EDGE_CLIPPING_NEGATIVE_X) &&
          (skipleft > x)))) {
        /* draw the first character only */

        int count = h, line = startline;
        int width = glyphWidth - skipleft;

        if (width > w)
            width = w;

        (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill) (pScrn, x, y,
                                                                  width, h, 0);

        bufferNo = 0;

        while (count--) {
            register CARD32 tmp = SHIFT_R(glyphs[0][line++], skipleft);

            base = (CARD32 *) infoRec->ScanlineColorExpandBuffers[bufferNo];
            WRITE_BITS(tmp);
            (*infoRec->SubsequentColorExpandScanline) (pScrn, bufferNo++);
            if (bufferNo >= infoRec->NumScanlineColorExpandBuffers)
                bufferNo = 0;
        }

        w -= width;
        if (!w)
            goto THE_END;
        glyphs++;
        x += width;
        skipleft = 0;           /* nicely aligned again */
    }

    w += skipleft;
    x -= skipleft;

    (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill) (pScrn, x, y, w, h,
                                                              skipleft);

    bufferNo = 0;

    while (h--) {
        base = (CARD32 *) infoRec->ScanlineColorExpandBuffers[bufferNo];
        (*GlyphFunc) (base, glyphs, startline++, w, glyphWidth);
        (*infoRec->SubsequentColorExpandScanline) (pScrn, bufferNo++);
        if (bufferNo >= infoRec->NumScanlineColorExpandBuffers)
            bufferNo = 0;
    }

 THE_END:

    SET_SYNC_FLAG(infoRec);
}

void

EXPNAME(XAATEGlyphRendererScanline3) (ScrnInfoPtr pScrn,
                                      int x, int y, int w, int h, int skipleft,
                                      int startline, unsigned int **glyphs,
                                      int glyphWidth, int fg, int bg, int rop,
                                      unsigned planemask) {
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int bufferNo;
    CARD32 *base, *mem;
    GlyphScanlineFuncPtr GlyphFunc =
        XAAGlyphScanlineFuncLSBFirst[glyphWidth - 1];

    if ((bg != -1) &&
        ((infoRec->TEGlyphRendererFlags & TRANSPARENCY_ONLY) ||
         ((infoRec->TEGlyphRendererFlags & RGB_EQUAL) &&
          (!CHECK_RGB_EQUAL(bg))))) {
        (*infoRec->SetupForSolidFill) (pScrn, bg, rop, planemask);
        (*infoRec->SubsequentSolidFillRect) (pScrn, x, y, w, h);
        bg = -1;
    }

    (*infoRec->SetupForScanlineCPUToScreenColorExpandFill) (pScrn, fg, bg, rop,
                                                            planemask);

    if (skipleft) {
        /* draw the first character only */

        int count = h, line = startline;
        int width = glyphWidth - skipleft;
        CARD32 bits;

        if (width > w)
            width = w;

        (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill) (pScrn, x, y,
                                                                  width, h, 0);

        bufferNo = 0;

        while (count--) {
            base = (CARD32 *) infoRec->ScanlineColorExpandBuffers[bufferNo];
            bits = SHIFT_R(glyphs[0][line++], skipleft);
            if (width >= 22) {
                WRITE_BITS3(bits);
            }
            else if (width >= 11) {
                WRITE_BITS2(bits);
            }
            else {
                WRITE_BITS1(bits);
            }
            (*infoRec->SubsequentColorExpandScanline) (pScrn, bufferNo++);
            if (bufferNo >= infoRec->NumScanlineColorExpandBuffers)
                bufferNo = 0;
        }

        w -= width;
        if (!w)
            goto THE_END;
        glyphs++;
        x += width;
        skipleft = 0;           /* nicely aligned again */
    }

    w += skipleft;
    x -= skipleft;
    mem = (CARD32 *) malloc(((w + 31) >> 3) * sizeof(char));
    if (!mem)
        return;

    (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill) (pScrn, x, y, w, h,
                                                              skipleft);

    bufferNo = 0;

    while (h--) {
        base = (CARD32 *) infoRec->ScanlineColorExpandBuffers[bufferNo];
        (*GlyphFunc) (mem, glyphs, startline++, w, glyphWidth);
        DrawTextScanline3(base, mem, w);
        (*infoRec->SubsequentColorExpandScanline) (pScrn, bufferNo++);
        if (bufferNo >= infoRec->NumScanlineColorExpandBuffers)
            bufferNo = 0;
    }

    free(mem);

 THE_END:

    SET_SYNC_FLAG(infoRec);
}

#endif

/********************************************************************

   TRIPLE_BITS_24BPP scanline rendering code.

********************************************************************/

static CARD32 *
DrawTextScanline3(CARD32 *base, CARD32 *mem, int width)
{

    while (width > 32) {
        WRITE_BITS3(*mem);
        mem++;
        width -= 32;
    }
    if (width) {
        if (width >= 22) {
            WRITE_BITS3(*mem);
        }
        else if (width >= 11) {
            WRITE_BITS2(*mem);
        }
        else {
            WRITE_BITS1(*mem);
        }
    }

    return base;
}

/********************************************************************

   Generic TE scanline rendering code.

********************************************************************/

static CARD32 *
DrawTETextScanlineGeneric(CARD32 *base,
                          unsigned int **glyphp,
                          int line, int width, int glyphwidth)
{
    CARD32 bits = (*glyphp)[line];
    int shift = glyphwidth;

    while (width > 32) {
        while (shift < 32) {
            glyphp++;
            bits |= SHIFT_L((*glyphp)[line], shift);
            shift += glyphwidth;
        }
        WRITE_BITS(bits);
        shift &= 31;
        if (shift)
            bits = SHIFT_R((*glyphp)[line], (glyphwidth - shift));
        else
            bits = 0;
        width -= 32;
    }

    if (width) {
        width -= shift;
        while (width > 0) {
            glyphp++;
            bits |= SHIFT_L((*glyphp)[line], shift);
            shift += glyphwidth;
            width -= glyphwidth;
        }
        WRITE_BITS(bits);
    }

    return base;
}

/********************************************************************

   Loop unrolled TE font scanline rendering code

********************************************************************/

#ifndef USEASSEMBLER
static CARD32 *
DrawTETextScanlineWidth6(CARD32 *base,
                         unsigned int **glyphp,
                         int line, int width, int glyphwidth)
{
    while (1) {
        unsigned int bits;

        bits = glyphp[0][line];
        bits |= SHIFT_L(glyphp[1][line], 6);
        bits |= SHIFT_L(glyphp[2][line], 12);
        bits |= SHIFT_L(glyphp[3][line], 18);
        bits |= SHIFT_L(glyphp[4][line], 24);
        bits |= SHIFT_L(glyphp[5][line], 30);
        WRITE_IN_BITORDER(base, 0, bits);
        CHECKRETURN(1);
        bits = SHIFT_R(glyphp[5][line], 2);
        bits |= SHIFT_L(glyphp[6][line], 4);
        bits |= SHIFT_L(glyphp[7][line], 10);
        bits |= SHIFT_L(glyphp[8][line], 16);
        bits |= SHIFT_L(glyphp[9][line], 22);
        bits |= SHIFT_L(glyphp[10][line], 28);
        WRITE_IN_BITORDER(base, 1, bits);
        CHECKRETURN(2);
        bits = SHIFT_R(glyphp[10][line], 4);
        bits |= SHIFT_L(glyphp[11][line], 2);
        bits |= SHIFT_L(glyphp[12][line], 8);
        bits |= SHIFT_L(glyphp[13][line], 14);
        bits |= SHIFT_L(glyphp[14][line], 20);
        bits |= SHIFT_L(glyphp[15][line], 26);
        WRITE_IN_BITORDER(base, 2, bits);
        CHECKRETURN(3);
#ifndef FIXEDBASE
        base += 3;
#endif
        width -= 96;
        glyphp += 16;
    }
    return base;
}
#endif

static CARD32 *
DrawTETextScanlineWidth7(CARD32 *base,
                         unsigned int **glyphp,
                         int line, int width, int glyphwidth)
{
    while (1) {
        unsigned int bits;

        bits = glyphp[0][line];
        bits |= SHIFT_L(glyphp[1][line], 7);
        bits |= SHIFT_L(glyphp[2][line], 14);
        bits |= SHIFT_L(glyphp[3][line], 21);
        bits |= SHIFT_L(glyphp[4][line], 28);
        WRITE_IN_BITORDER(base, 0, bits);
        CHECKRETURN(1);
        bits = SHIFT_R(glyphp[4][line], 4);
        bits |= SHIFT_L(glyphp[5][line], 3);
        bits |= SHIFT_L(glyphp[6][line], 10);
        bits |= SHIFT_L(glyphp[7][line], 17);
        bits |= SHIFT_L(glyphp[8][line], 24);
        bits |= SHIFT_L(glyphp[9][line], 31);
        WRITE_IN_BITORDER(base, 1, bits);
        CHECKRETURN(2);
        bits = SHIFT_R(glyphp[9][line], 1);
        bits |= SHIFT_L(glyphp[10][line], 6);
        bits |= SHIFT_L(glyphp[11][line], 13);
        bits |= SHIFT_L(glyphp[12][line], 20);
        bits |= SHIFT_L(glyphp[13][line], 27);
        WRITE_IN_BITORDER(base, 2, bits);
        CHECKRETURN(3);
        bits = SHIFT_R(glyphp[13][line], 5);
        bits |= SHIFT_L(glyphp[14][line], 2);
        bits |= SHIFT_L(glyphp[15][line], 9);
        bits |= SHIFT_L(glyphp[16][line], 16);
        bits |= SHIFT_L(glyphp[17][line], 23);
        bits |= SHIFT_L(glyphp[18][line], 30);
        WRITE_IN_BITORDER(base, 3, bits);
        CHECKRETURN(4);
        bits = SHIFT_R(glyphp[18][line], 2);
        bits |= SHIFT_L(glyphp[19][line], 5);
        bits |= SHIFT_L(glyphp[20][line], 12);
        bits |= SHIFT_L(glyphp[21][line], 19);
        bits |= SHIFT_L(glyphp[22][line], 26);
        WRITE_IN_BITORDER(base, 4, bits);
        CHECKRETURN(5);
        bits = SHIFT_R(glyphp[22][line], 6);
        bits |= SHIFT_L(glyphp[23][line], 1);
        bits |= SHIFT_L(glyphp[24][line], 8);
        bits |= SHIFT_L(glyphp[25][line], 15);
        bits |= SHIFT_L(glyphp[26][line], 22);
        bits |= SHIFT_L(glyphp[27][line], 29);
        WRITE_IN_BITORDER(base, 5, bits);
        CHECKRETURN(6);
        bits = SHIFT_R(glyphp[27][line], 3);
        bits |= SHIFT_L(glyphp[28][line], 4);
        bits |= SHIFT_L(glyphp[29][line], 11);
        bits |= SHIFT_L(glyphp[30][line], 18);
        bits |= SHIFT_L(glyphp[31][line], 25);
        WRITE_IN_BITORDER(base, 6, bits);
        CHECKRETURN(7);
#ifndef FIXEDBASE
        base += 7;
#endif
        width -= 224;
        glyphp += 32;
    }
    return base;
}

#ifndef USEASSEMBLER
static CARD32 *
DrawTETextScanlineWidth8(CARD32 *base,
                         unsigned int **glyphp,
                         int line, int width, int glyphwidth)
{
    while (1) {
        unsigned int bits;

        bits = glyphp[0][line];
        bits |= SHIFT_L(glyphp[1][line], 8);
        bits |= SHIFT_L(glyphp[2][line], 16);
        bits |= SHIFT_L(glyphp[3][line], 24);
        WRITE_IN_BITORDER(base, 0, bits);
        CHECKRETURN(1);
        bits = glyphp[4][line];
        bits |= SHIFT_L(glyphp[5][line], 8);
        bits |= SHIFT_L(glyphp[6][line], 16);
        bits |= SHIFT_L(glyphp[7][line], 24);
        WRITE_IN_BITORDER(base, 1, bits);
        CHECKRETURN(2);
#ifndef FIXEDBASE
        base += 2;
#endif
        width -= 64;
        glyphp += 8;
    }
    return base;
}
#endif

#ifndef USEASSEMBLER
static CARD32 *
DrawTETextScanlineWidth9(CARD32 *base,
                         unsigned int **glyphp,
                         int line, int width, int glyphwidth)
{
    while (1) {
        unsigned int bits;

        bits = glyphp[0][line];
        bits |= SHIFT_L(glyphp[1][line], 9);
        bits |= SHIFT_L(glyphp[2][line], 18);
        bits |= SHIFT_L(glyphp[3][line], 27);
        WRITE_IN_BITORDER(base, 0, bits);
        CHECKRETURN(1);
        bits = SHIFT_R(glyphp[3][line], 5);
        bits |= SHIFT_L(glyphp[4][line], 4);
        bits |= SHIFT_L(glyphp[5][line], 13);
        bits |= SHIFT_L(glyphp[6][line], 22);
        bits |= SHIFT_L(glyphp[7][line], 31);
        WRITE_IN_BITORDER(base, 1, bits);
        CHECKRETURN(2);
        bits = SHIFT_R(glyphp[7][line], 1);
        bits |= SHIFT_L(glyphp[8][line], 8);
        bits |= SHIFT_L(glyphp[9][line], 17);
        bits |= SHIFT_L(glyphp[10][line], 26);
        WRITE_IN_BITORDER(base, 2, bits);
        CHECKRETURN(3);
        bits = SHIFT_R(glyphp[10][line], 6);
        bits |= SHIFT_L(glyphp[11][line], 3);
        bits |= SHIFT_L(glyphp[12][line], 12);
        bits |= SHIFT_L(glyphp[13][line], 21);
        bits |= SHIFT_L(glyphp[14][line], 30);
        WRITE_IN_BITORDER(base, 3, bits);
        CHECKRETURN(4);
        bits = SHIFT_R(glyphp[14][line], 2);
        bits |= SHIFT_L(glyphp[15][line], 7);
        bits |= SHIFT_L(glyphp[16][line], 16);
        bits |= SHIFT_L(glyphp[17][line], 25);
        WRITE_IN_BITORDER(base, 4, bits);
        CHECKRETURN(5);
        bits = SHIFT_R(glyphp[17][line], 7);
        bits |= SHIFT_L(glyphp[18][line], 2);
        bits |= SHIFT_L(glyphp[19][line], 11);
        bits |= SHIFT_L(glyphp[20][line], 20);
        bits |= SHIFT_L(glyphp[21][line], 29);
        WRITE_IN_BITORDER(base, 5, bits);
        CHECKRETURN(6);
        bits = SHIFT_R(glyphp[21][line], 3);
        bits |= SHIFT_L(glyphp[22][line], 6);
        bits |= SHIFT_L(glyphp[23][line], 15);
        bits |= SHIFT_L(glyphp[24][line], 24);
        WRITE_IN_BITORDER(base, 6, bits);
        CHECKRETURN(7);
        bits = SHIFT_R(glyphp[24][line], 8);
        bits |= SHIFT_L(glyphp[25][line], 1);
        bits |= SHIFT_L(glyphp[26][line], 10);
        bits |= SHIFT_L(glyphp[27][line], 19);
        bits |= SHIFT_L(glyphp[28][line], 28);
        WRITE_IN_BITORDER(base, 7, bits);
        CHECKRETURN(8);
        bits = SHIFT_R(glyphp[28][line], 4);
        bits |= SHIFT_L(glyphp[29][line], 5);
        bits |= SHIFT_L(glyphp[30][line], 14);
        bits |= SHIFT_L(glyphp[31][line], 23);
        WRITE_IN_BITORDER(base, 8, bits);
        CHECKRETURN(9);
#ifndef FIXEDBASE
        base += 9;
#endif
        width -= 288;
        glyphp += 32;
    }
    return base;
}
#endif

static CARD32 *
DrawTETextScanlineWidth10(CARD32 *base,
                          unsigned int **glyphp,
                          int line, int width, int glyphwidth)
{
    while (1) {
        unsigned int bits;

        bits = glyphp[0][line];
        bits |= SHIFT_L(glyphp[1][line], 10);
        bits |= SHIFT_L(glyphp[2][line], 20);
        bits |= SHIFT_L(glyphp[3][line], 30);
        WRITE_IN_BITORDER(base, 0, bits);
        CHECKRETURN(1);
        bits = SHIFT_R(glyphp[3][line], 2);
        bits |= SHIFT_L(glyphp[4][line], 8);
        bits |= SHIFT_L(glyphp[5][line], 18);
        bits |= SHIFT_L(glyphp[6][line], 28);
        WRITE_IN_BITORDER(base, 1, bits);
        CHECKRETURN(2);
        bits = SHIFT_R(glyphp[6][line], 4);
        bits |= SHIFT_L(glyphp[7][line], 6);
        bits |= SHIFT_L(glyphp[8][line], 16);
        bits |= SHIFT_L(glyphp[9][line], 26);
        WRITE_IN_BITORDER(base, 2, bits);
        CHECKRETURN(3);
        bits = SHIFT_R(glyphp[9][line], 6);
        bits |= SHIFT_L(glyphp[10][line], 4);
        bits |= SHIFT_L(glyphp[11][line], 14);
        bits |= SHIFT_L(glyphp[12][line], 24);
        WRITE_IN_BITORDER(base, 3, bits);
        CHECKRETURN(4);
        bits = SHIFT_R(glyphp[12][line], 8);
        bits |= SHIFT_L(glyphp[13][line], 2);
        bits |= SHIFT_L(glyphp[14][line], 12);
        bits |= SHIFT_L(glyphp[15][line], 22);
        WRITE_IN_BITORDER(base, 4, bits);
        CHECKRETURN(5);
#ifndef FIXEDBASE
        base += 5;
#endif
        width -= 160;
        glyphp += 16;
    }
    return base;
}

static CARD32 *
DrawTETextScanlineWidth12(CARD32 *base,
                          unsigned int **glyphp,
                          int line, int width, int glyphwidth)
{
    while (1) {
        unsigned int bits;

        bits = glyphp[0][line];
        bits |= SHIFT_L(glyphp[1][line], 12);
        bits |= SHIFT_L(glyphp[2][line], 24);
        WRITE_IN_BITORDER(base, 0, bits);
        CHECKRETURN(1);
        bits = SHIFT_R(glyphp[2][line], 8);
        bits |= SHIFT_L(glyphp[3][line], 4);
        bits |= SHIFT_L(glyphp[4][line], 16);
        bits |= SHIFT_L(glyphp[5][line], 28);
        WRITE_IN_BITORDER(base, 1, bits);
        CHECKRETURN(2);
        bits = SHIFT_R(glyphp[5][line], 4);
        bits |= SHIFT_L(glyphp[6][line], 8);
        bits |= SHIFT_L(glyphp[7][line], 20);
        WRITE_IN_BITORDER(base, 2, bits);
        CHECKRETURN(3);
#ifndef FIXEDBASE
        base += 3;
#endif
        width -= 96;
        glyphp += 8;
    }
    return base;
}

static CARD32 *
DrawTETextScanlineWidth14(CARD32 *base,
                          unsigned int **glyphp,
                          int line, int width, int glyphwidth)
{
    while (1) {
        unsigned int bits;

        bits = glyphp[0][line];
        bits |= SHIFT_L(glyphp[1][line], 14);
        bits |= SHIFT_L(glyphp[2][line], 28);
        WRITE_IN_BITORDER(base, 0, bits);
        CHECKRETURN(1);
        bits = SHIFT_R(glyphp[2][line], 4);
        bits |= SHIFT_L(glyphp[3][line], 10);
        bits |= SHIFT_L(glyphp[4][line], 24);
        WRITE_IN_BITORDER(base, 1, bits);
        CHECKRETURN(2);
        bits = SHIFT_R(glyphp[4][line], 8);
        bits |= SHIFT_L(glyphp[5][line], 6);
        bits |= SHIFT_L(glyphp[6][line], 20);
        WRITE_IN_BITORDER(base, 2, bits);
        CHECKRETURN(3);
        bits = SHIFT_R(glyphp[6][line], 12);
        bits |= SHIFT_L(glyphp[7][line], 2);
        bits |= SHIFT_L(glyphp[8][line], 16);
        bits |= SHIFT_L(glyphp[9][line], 30);
        WRITE_IN_BITORDER(base, 3, bits);
        CHECKRETURN(4);
        bits = SHIFT_R(glyphp[9][line], 2);
        bits |= SHIFT_L(glyphp[10][line], 12);
        bits |= SHIFT_L(glyphp[11][line], 26);
        WRITE_IN_BITORDER(base, 4, bits);
        CHECKRETURN(5);
        bits = SHIFT_R(glyphp[11][line], 6);
        bits |= SHIFT_L(glyphp[12][line], 8);
        bits |= SHIFT_L(glyphp[13][line], 22);
        WRITE_IN_BITORDER(base, 5, bits);
        CHECKRETURN(6);
        bits = SHIFT_R(glyphp[13][line], 10);
        bits |= SHIFT_L(glyphp[14][line], 4);
        bits |= SHIFT_L(glyphp[15][line], 18);
        WRITE_IN_BITORDER(base, 6, bits);
        CHECKRETURN(7);
#ifndef FIXEDBASE
        base += 7;
#endif
        width -= 224;
        glyphp += 16;
    }
    return base;
}

static CARD32 *
DrawTETextScanlineWidth16(CARD32 *base,
                          unsigned int **glyphp,
                          int line, int width, int glyphwidth)
{
    while (1) {
        unsigned int bits;

        bits = glyphp[0][line];
        bits |= SHIFT_L(glyphp[1][line], 16);
        WRITE_IN_BITORDER(base, 0, bits);
        CHECKRETURN(1);
        bits = glyphp[2][line];
        bits |= SHIFT_L(glyphp[3][line], 16);
        WRITE_IN_BITORDER(base, 1, bits);
        CHECKRETURN(2);
        bits = glyphp[4][line];
        bits |= SHIFT_L(glyphp[5][line], 16);
        WRITE_IN_BITORDER(base, 2, bits);
        CHECKRETURN(3);
        bits = glyphp[6][line];
        bits |= SHIFT_L(glyphp[7][line], 16);
        WRITE_IN_BITORDER(base, 3, bits);
        CHECKRETURN(4);
#ifndef FIXEDBASE
        base += 4;
#endif
        width -= 128;
        glyphp += 8;
    }
    return base;
}

static CARD32 *
DrawTETextScanlineWidth18(CARD32 *base,
                          unsigned int **glyphp,
                          int line, int width, int glyphwidth)
{
    while (1) {
        unsigned int bits;

        bits = glyphp[0][line];
        bits |= SHIFT_L(glyphp[1][line], 18);
        WRITE_IN_BITORDER(base, 0, bits);
        CHECKRETURN(1);
        bits = SHIFT_R(glyphp[1][line], 14);
        bits |= SHIFT_L(glyphp[2][line], 4);
        bits |= SHIFT_L(glyphp[3][line], 22);
        WRITE_IN_BITORDER(base, 1, bits);
        CHECKRETURN(2);
        bits = SHIFT_R(glyphp[3][line], 10);
        bits |= SHIFT_L(glyphp[4][line], 8);
        bits |= SHIFT_L(glyphp[5][line], 26);
        WRITE_IN_BITORDER(base, 2, bits);
        CHECKRETURN(3);
        bits = SHIFT_R(glyphp[5][line], 6);
        bits |= SHIFT_L(glyphp[6][line], 12);
        bits |= SHIFT_L(glyphp[7][line], 30);
        WRITE_IN_BITORDER(base, 3, bits);
        CHECKRETURN(4);
        bits = SHIFT_R(glyphp[7][line], 2);
        bits |= SHIFT_L(glyphp[8][line], 16);
        WRITE_IN_BITORDER(base, 4, bits);
        CHECKRETURN(5);
        bits = SHIFT_R(glyphp[8][line], 16);
        bits |= SHIFT_L(glyphp[9][line], 2);
        bits |= SHIFT_L(glyphp[10][line], 20);
        WRITE_IN_BITORDER(base, 5, bits);
        CHECKRETURN(6);
        bits = SHIFT_R(glyphp[10][line], 12);
        bits |= SHIFT_L(glyphp[11][line], 6);
        bits |= SHIFT_L(glyphp[12][line], 24);
        WRITE_IN_BITORDER(base, 6, bits);
        CHECKRETURN(7);
        bits = SHIFT_R(glyphp[12][line], 8);
        bits |= SHIFT_L(glyphp[13][line], 10);
        bits |= SHIFT_L(glyphp[14][line], 28);
        WRITE_IN_BITORDER(base, 7, bits);
        CHECKRETURN(8);
        bits = SHIFT_R(glyphp[14][line], 4);
        bits |= SHIFT_L(glyphp[15][line], 14);
        WRITE_IN_BITORDER(base, 8, bits);
        CHECKRETURN(9);
#ifndef FIXEDBASE
        base += 9;
#endif
        width -= 288;
        glyphp += 16;
    }
    return base;
}

static CARD32 *
DrawTETextScanlineWidth24(CARD32 *base,
                          unsigned int **glyphp,
                          int line, int width, int glyphwidth)
{
    while (1) {
        unsigned int bits;

        bits = glyphp[0][line];
        bits |= SHIFT_L(glyphp[1][line], 24);
        WRITE_IN_BITORDER(base, 0, bits);
        CHECKRETURN(1);
        bits = SHIFT_R(glyphp[1][line], 8);
        bits |= SHIFT_L(glyphp[2][line], 16);
        WRITE_IN_BITORDER(base, 1, bits);
        CHECKRETURN(2);
        bits = SHIFT_R(glyphp[2][line], 16);
        bits |= SHIFT_L(glyphp[3][line], 8);
        WRITE_IN_BITORDER(base, 2, bits);
        CHECKRETURN(3);
#ifndef FIXEDBASE
        base += 3;
#endif
        width -= 96;
        glyphp += 4;
    }
    return base;
}
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a1 1

d16 1
a16 1
					int line, int width, int glyphwidth);
d18 1
a18 1
					int line, int width, int glyphwidth);
d20 1
a20 1
					int line, int width, int glyphwidth);
d22 1
a22 1
					int line, int width, int glyphwidth);
d24 1
a24 1
					int line, int width, int glyphwidth);
d26 1
a26 1
					int line, int width, int glyphwidth);
d28 1
a28 1
					int line, int width, int glyphwidth);
d30 1
a30 2
					int line, int width, int glyphwidth);

d33 2
a34 2
# ifdef FIXEDBASE
#  ifdef MSBFIRST
d36 3
a38 1
		unsigned int **glyphp, int line, int width, int glyphwidth);
d40 3
a42 1
		unsigned int **glyphp, int line, int width, int glyphwidth);
d44 4
a47 2
		unsigned int **glyphp, int line, int width, int glyphwidth);
#  else
d49 3
a51 1
		unsigned int **glyphp, int line, int width, int glyphwidth);
d53 3
a55 1
		unsigned int **glyphp, int line, int width, int glyphwidth);
d57 6
a62 4
		unsigned int **glyphp, int line, int width, int glyphwidth);
#  endif
# else
#  ifdef MSBFIRST
d64 1
a64 1
					int line, int width, int glyphwidth);
d66 1
a66 1
					int line, int width, int glyphwidth);
d68 2
a69 2
					int line, int width, int glyphwidth);
#  else
d71 1
a71 1
					int line, int width, int glyphwidth);
d73 1
a73 1
					int line, int width, int glyphwidth);
d75 3
a77 3
					int line, int width, int glyphwidth);
#  endif
# endif
d80 1
a80 1
					int line, int width, int glyphwidth);
d82 1
a82 1
					int line, int width, int glyphwidth);
d84 1
a84 1
					int line, int width, int glyphwidth);
a89 1

d91 3
a93 3
   DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,  
   DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
   DrawTETextScanlineGeneric, 
d95 6
a100 25
# ifdef FIXEDBASE
#  ifdef MSBFIRST
   DrawTETextScanlineWidth6PMSBFirstFixedBase, 
   DrawTETextScanlineWidth7, 
   DrawTETextScanlineWidth8PMSBFirstFixedBase, 
   DrawTETextScanlineWidth9PMSBFirstFixedBase, 
#  else
   DrawTETextScanlineWidth6PLSBFirstFixedBase, 
   DrawTETextScanlineWidth7, 
   DrawTETextScanlineWidth8PLSBFirstFixedBase, 
   DrawTETextScanlineWidth9PLSBFirstFixedBase, 
#  endif
# else
#  ifdef MSBFIRST
   DrawTETextScanlineWidth6PMSBFirst, 
   DrawTETextScanlineWidth7, 
   DrawTETextScanlineWidth8PMSBFirst, 
   DrawTETextScanlineWidth9PMSBFirst, 
#  else
   DrawTETextScanlineWidth6PLSBFirst, 
   DrawTETextScanlineWidth7, 
   DrawTETextScanlineWidth8PLSBFirst, 
   DrawTETextScanlineWidth9PLSBFirst, 
#  endif
# endif
d102 4
a105 2
   DrawTETextScanlineWidth6, DrawTETextScanlineWidth7, 
   DrawTETextScanlineWidth8, DrawTETextScanlineWidth9, 
d107 29
a135 12
   DrawTETextScanlineWidth10, 
   DrawTETextScanlineGeneric, DrawTETextScanlineWidth12,
   DrawTETextScanlineGeneric, DrawTETextScanlineWidth14, 
   DrawTETextScanlineGeneric, DrawTETextScanlineWidth16,
   DrawTETextScanlineGeneric, DrawTETextScanlineWidth18, 
   DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
   DrawTETextScanlineGeneric, DrawTETextScanlineGeneric, 
   DrawTETextScanlineGeneric, DrawTETextScanlineWidth24,
   DrawTETextScanlineGeneric, DrawTETextScanlineGeneric, 
   DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
   DrawTETextScanlineGeneric, DrawTETextScanlineGeneric, 
   DrawTETextScanlineGeneric, DrawTETextScanlineGeneric
d138 4
a141 2
GlyphScanlineFuncPtr *glyph_get_scanline_func(void) {
   return glyph_scanline_func;
a143 1

d157 6
a162 7
EXPNAME(XAATEGlyphRenderer)(
    ScrnInfoPtr pScrn,
    int x, int y, int w, int h, int skipleft, int startline, 
    unsigned int **glyphs, int glyphWidth,
    int fg, int bg, int rop, unsigned planemask
)
{
d164 1
a164 1
    CARD32* base;
d168 44
a211 41
    if((bg != -1) && (infoRec->TEGlyphRendererFlags & TRANSPARENCY_ONLY)) {
    	(*infoRec->SetupForSolidFill)(pScrn, bg, rop, planemask);
        (*infoRec->SubsequentSolidFillRect)(pScrn, x, y, w, h);
	bg = -1;
    }

    (*infoRec->SetupForCPUToScreenColorExpandFill)(
				pScrn, fg, bg, rop, planemask);

    if(skipleft && 
	 (!(infoRec->TEGlyphRendererFlags & LEFT_EDGE_CLIPPING) || 
	 (!(infoRec->TEGlyphRendererFlags & LEFT_EDGE_CLIPPING_NEGATIVE_X) && 
		(skipleft > x)))) {
	    /* draw the first character only */

	    int count = h, line = startline;
            int width = glyphWidth - skipleft;

	    if(width > w) width = w;

            (*infoRec->SubsequentCPUToScreenColorExpandFill)(
						pScrn, x, y, width, h, 0);

	    base = (CARD32*)infoRec->ColorExpandBase;

	    while(count--) {
		register CARD32 tmp = SHIFT_R(glyphs[0][line++],skipleft);
		WRITE_BITS(tmp);
	    }
    
	    w -= width;
	    if((infoRec->TEGlyphRendererFlags & CPU_TRANSFER_PAD_QWORD) &&
			((((width + 31) >> 5) * h) & 1)) {
		base = (CARD32*)infoRec->ColorExpandBase;
		base[0] = 0x00000000;
	    }
	    if(!w) goto THE_END;
	    glyphs++;
            x += width;
	    skipleft = 0;	/* nicely aligned again */
    } 
d217 2
a218 2
    (*infoRec->SubsequentCPUToScreenColorExpandFill)(
				pScrn, x, y, w, h, skipleft);
d220 1
a220 1
    base = (CARD32*)infoRec->ColorExpandBase;
d223 4
a226 4
    if((((w + 31) >> 5) * h) <= infoRec->ColorExpandRange)
	while(h--) {
	    base = (*GlyphFunc)(base, glyphs, startline++, w, glyphWidth);
	}
d229 3
a231 3
	while(h--) {
	    (*GlyphFunc)(base, glyphs, startline++, w, glyphWidth);
	}
d233 4
a236 4
    if((infoRec->TEGlyphRendererFlags & CPU_TRANSFER_PAD_QWORD) &&
			(dwords & 1)) {
	base = (CARD32*)infoRec->ColorExpandBase;
	base[0] = 0x00000000;
d239 1
a239 1
THE_END:
d241 4
a244 3
    if(infoRec->TEGlyphRendererFlags & SYNC_AFTER_COLOR_EXPAND) 
	(*infoRec->Sync)(pScrn);
    else SET_SYNC_FLAG(infoRec);
d256 6
a261 7
EXPNAME(XAATEGlyphRenderer3)(
    ScrnInfoPtr pScrn,
    int x, int y, int w, int h, int skipleft, int startline, 
    unsigned int **glyphs, int glyphWidth,
    int fg, int bg, int rop, unsigned planemask
)
{
d264 2
a265 1
    GlyphScanlineFuncPtr GlyphFunc = XAAGlyphScanlineFuncLSBFirst[glyphWidth - 1];
d268 51
a318 47
    if((bg != -1) && 
	((infoRec->TEGlyphRendererFlags & TRANSPARENCY_ONLY) ||
	((infoRec->TEGlyphRendererFlags & RGB_EQUAL) && 
	(!CHECK_RGB_EQUAL(bg))))) {
    	(*infoRec->SetupForSolidFill)(pScrn, bg, rop, planemask);
        (*infoRec->SubsequentSolidFillRect)(pScrn, x, y, w, h);
	bg = -1;
    }

    (*infoRec->SetupForCPUToScreenColorExpandFill)(
					pScrn, fg, bg, rop, planemask);

    if(skipleft) {
	    /* draw the first character only */

	    int count = h, line = startline;
            int width = glyphWidth - skipleft;
	    CARD32 bits;

	    if(width > w) width = w;
            (*infoRec->SubsequentCPUToScreenColorExpandFill)(
					pScrn, x, y, width, h, 0);

	    base = (CARD32*)infoRec->ColorExpandBase;

	    while(count--) {	
		bits = SHIFT_R(glyphs[0][line++],skipleft);
	        if (width >= 22) {
		    WRITE_BITS3(bits);
	        } else if (width >= 11) {
		    WRITE_BITS2(bits);
		} else {
		    WRITE_BITS1(bits);
		}
	    }

	    w -= width;
	    if((infoRec->TEGlyphRendererFlags & CPU_TRANSFER_PAD_QWORD) &&
			((((3 * width + 31) >> 5) * h) & 1)) {
		base = (CARD32*)infoRec->ColorExpandBase;
		base[0] = 0x00000000;
	    }
	    if(!w) goto THE_END;
	    glyphs++;
            x += width;
	    skipleft = 0;	/* nicely aligned again */
    } 
d321 3
a323 2
    mem = (CARD32*)malloc(((w + 31) >> 3) * sizeof(char));
    if (!mem) return;
d325 1
a325 1
    (*infoRec->SubsequentCPUToScreenColorExpandFill)(pScrn, x, y, w, h, 0);
d327 1
a327 1
    base = (CARD32*)infoRec->ColorExpandBase;
d329 6
a334 6
# ifndef FIXEDBASE
    if((((3 * w + 31) >> 5) * h) <= infoRec->ColorExpandRange)
	while(h--) {
	    (*GlyphFunc)(mem, glyphs, startline++, w, glyphWidth);
	    base = DrawTextScanline3(base, mem, w);
	}
d336 5
a340 5
# endif
	while(h--) {
	    (*GlyphFunc)(mem, glyphs, startline++, w, glyphWidth);
	    DrawTextScanline3(base, mem, w);
	}
d344 4
a347 4
    if((infoRec->TEGlyphRendererFlags & CPU_TRANSFER_PAD_QWORD) &&
			(dwords & 1)) {
	base = (CARD32*)infoRec->ColorExpandBase;
	base[0] = 0x00000000;
d350 1
a350 1
THE_END:
d352 4
a355 3
    if(infoRec->TEGlyphRendererFlags & SYNC_AFTER_COLOR_EXPAND) 
	(*infoRec->Sync)(pScrn);
    else SET_SYNC_FLAG(infoRec);
a357 1

d362 6
a367 7
EXPNAME(XAATEGlyphRendererScanline)(
    ScrnInfoPtr pScrn,
    int x, int y, int w, int h, int skipleft, int startline, 
    unsigned int **glyphs, int glyphWidth,
    int fg, int bg, int rop, unsigned planemask
)
{
d370 1
a370 1
    CARD32* base;
d373 43
a415 40
    if((bg != -1) && (infoRec->TEGlyphRendererFlags & TRANSPARENCY_ONLY)) {
    	(*infoRec->SetupForSolidFill)(pScrn, bg, rop, planemask);
        (*infoRec->SubsequentSolidFillRect)(pScrn, x, y, w, h);
	bg = -1;
    }

    (*infoRec->SetupForScanlineCPUToScreenColorExpandFill)(
				pScrn, fg, bg, rop, planemask);

    if(skipleft && 
	(!(infoRec->TEGlyphRendererFlags & LEFT_EDGE_CLIPPING) || 
	(!(infoRec->TEGlyphRendererFlags & LEFT_EDGE_CLIPPING_NEGATIVE_X) &&
	(skipleft > x)))) {
	/* draw the first character only */

	int count = h, line = startline;
	int width = glyphWidth - skipleft;

	if(width > w) width = w;

        (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill)(
					pScrn, x, y, width, h, 0);

	bufferNo = 0;

	while(count--) {	
	    register CARD32 tmp = SHIFT_R(glyphs[0][line++],skipleft);
	    base = (CARD32*)infoRec->ScanlineColorExpandBuffers[bufferNo];
	    WRITE_BITS(tmp);
	    (*infoRec->SubsequentColorExpandScanline)(pScrn, bufferNo++);
	    if(bufferNo >= infoRec->NumScanlineColorExpandBuffers)
	    	bufferNo = 0;
	}

	w -= width;
	if(!w) goto THE_END;
	glyphs++;
	x += width;
	skipleft = 0;	/* nicely aligned again */
    } 
d420 2
a421 2
    (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill)(	
				pScrn, x, y, w, h, skipleft);
d425 6
a430 6
    while(h--) {
	base = (CARD32*)infoRec->ScanlineColorExpandBuffers[bufferNo];
	(*GlyphFunc)(base, glyphs, startline++, w, glyphWidth);
	(*infoRec->SubsequentColorExpandScanline)(pScrn, bufferNo++);
	if(bufferNo >= infoRec->NumScanlineColorExpandBuffers)
	    bufferNo = 0;
d433 1
a433 1
THE_END:
d439 6
a444 7
EXPNAME(XAATEGlyphRendererScanline3)(
    ScrnInfoPtr pScrn,
    int x, int y, int w, int h, int skipleft, int startline, 
    unsigned int **glyphs, int glyphWidth,
    int fg, int bg, int rop, unsigned planemask
)
{
d448 2
a449 1
    GlyphScanlineFuncPtr GlyphFunc = XAAGlyphScanlineFuncLSBFirst[glyphWidth - 1];
d451 51
a501 47
    if((bg != -1) && 
	((infoRec->TEGlyphRendererFlags & TRANSPARENCY_ONLY) ||
	((infoRec->TEGlyphRendererFlags & RGB_EQUAL) && 
	(!CHECK_RGB_EQUAL(bg))))) {
    	(*infoRec->SetupForSolidFill)(pScrn, bg, rop, planemask);
        (*infoRec->SubsequentSolidFillRect)(pScrn, x, y, w, h);
	bg = -1;
    }

    (*infoRec->SetupForScanlineCPUToScreenColorExpandFill)(
					pScrn, fg, bg, rop, planemask);

    if(skipleft) {
	/* draw the first character only */

	int count = h, line = startline;
	int width = glyphWidth - skipleft;
	CARD32 bits;
	
	if(width > w) width = w;

        (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill)(
					pScrn, x, y, width, h, 0);

	bufferNo = 0;

	while(count--) {	
	    base = (CARD32*)infoRec->ScanlineColorExpandBuffers[bufferNo];
	    bits = SHIFT_R(glyphs[0][line++],skipleft);
	    if (width >= 22) {
		WRITE_BITS3(bits);
	    } else if (width >= 11) {
		WRITE_BITS2(bits);
	    } else {
		WRITE_BITS1(bits);
	    }
	    (*infoRec->SubsequentColorExpandScanline)(pScrn, bufferNo++);
	    if(bufferNo >= infoRec->NumScanlineColorExpandBuffers)
	    	bufferNo = 0;
	}

	w -= width;
	if(!w) goto THE_END;
	glyphs++;
	x += width;
	skipleft = 0;	/* nicely aligned again */
    } 
d505 3
a507 2
    mem = (CARD32*)malloc(((w + 31) >> 3) * sizeof(char));
    if (!mem) return;
d509 2
a510 2
   (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill)(	
				pScrn, x, y, w, h, skipleft);
d514 7
a520 7
    while(h--) {
	base = (CARD32*)infoRec->ScanlineColorExpandBuffers[bufferNo];
	(*GlyphFunc)(mem, glyphs, startline++, w, glyphWidth);
	DrawTextScanline3(base, mem, w);
	(*infoRec->SubsequentColorExpandScanline)(pScrn, bufferNo++);
	if(bufferNo >= infoRec->NumScanlineColorExpandBuffers)
	    bufferNo = 0;
d524 2
a525 2
    
THE_END:
a531 2


d538 2
a539 7


static CARD32*
DrawTextScanline3(
    CARD32 *base,
    CARD32 *mem,
    int width )
d542 15
a556 13
    while(width > 32) {
	WRITE_BITS3(*mem);
	mem++;
	width -= 32;
    }
    if(width) {
	if (width >= 22) {
	    WRITE_BITS3(*mem);
	} else if (width >= 11) {
	    WRITE_BITS2(*mem);
	} else {
	    WRITE_BITS1(*mem);
	}
a561 1

d568 4
a571 7


static CARD32*
DrawTETextScanlineGeneric(
    CARD32 *base,
    unsigned int **glyphp,
    int line, int width, int glyphwidth )
d574 1
a574 1
    int shift = glyphwidth; 
d576 24
a599 23
    while(width > 32) {
	while(shift < 32) {
	   glyphp++;
           bits |= SHIFT_L((*glyphp)[line], shift);
	   shift += glyphwidth;
	}
	WRITE_BITS(bits);
	shift &= 31;
	if(shift) 
            bits = SHIFT_R((*glyphp)[line],(glyphwidth - shift));
	else bits = 0;
	width -= 32;
    }

    if(width) {
	width -= shift;
	while(width > 0) {
	   glyphp++;
           bits |= SHIFT_L((*glyphp)[line],shift);
	   shift += glyphwidth;
	   width -= glyphwidth;
	}
	WRITE_BITS(bits);
a604 1

a610 1

d612 4
a615 5
static CARD32* 
DrawTETextScanlineWidth6(
    CARD32 *base,
    unsigned int **glyphp,
    int line, int width, int glyphwidth )
d618 8
a625 7
	unsigned int bits;
        bits =  glyphp[0][line];
        bits |= SHIFT_L(glyphp[1][line],6);
        bits |= SHIFT_L(glyphp[2][line],12);
        bits |= SHIFT_L(glyphp[3][line],18);
        bits |= SHIFT_L(glyphp[4][line],24);
        bits |= SHIFT_L(glyphp[5][line],30);
d627 7
a633 7
	CHECKRETURN(1);
        bits =  SHIFT_R(glyphp[5][line],2);
        bits |= SHIFT_L(glyphp[6][line],4);
        bits |= SHIFT_L(glyphp[7][line],10);
        bits |= SHIFT_L(glyphp[8][line],16);
        bits |= SHIFT_L(glyphp[9][line],22);
        bits |= SHIFT_L(glyphp[10][line],28);
d635 7
a641 7
	CHECKRETURN(2);
        bits =  SHIFT_R(glyphp[10][line],4);
        bits |= SHIFT_L(glyphp[11][line],2);
        bits |= SHIFT_L(glyphp[12][line],8);
        bits |= SHIFT_L(glyphp[13][line],14);
        bits |= SHIFT_L(glyphp[14][line],20);
        bits |= SHIFT_L(glyphp[15][line],26);
d643 1
a643 1
	CHECKRETURN(3);
d647 1
a647 1
	width -= 96;
d654 4
a657 5
static CARD32*
DrawTETextScanlineWidth7(
    CARD32 *base,
    unsigned int **glyphp,
    int line, int width, int glyphwidth )
d661 1
d663 4
a666 4
        bits |= SHIFT_L(glyphp[1][line],7);
        bits |= SHIFT_L(glyphp[2][line],14);
        bits |= SHIFT_L(glyphp[3][line],21);
        bits |= SHIFT_L(glyphp[4][line],28);
d668 7
a674 7
	CHECKRETURN(1);	
        bits = SHIFT_R(glyphp[4][line],4);
        bits |= SHIFT_L(glyphp[5][line],3);
        bits |= SHIFT_L(glyphp[6][line],10);
        bits |= SHIFT_L(glyphp[7][line],17);
        bits |= SHIFT_L(glyphp[8][line],24);
        bits |= SHIFT_L(glyphp[9][line],31);
d676 6
a681 6
	CHECKRETURN(2);	
        bits =  SHIFT_R(glyphp[9][line],1);
        bits |= SHIFT_L(glyphp[10][line],6);
        bits |= SHIFT_L(glyphp[11][line],13);
        bits |= SHIFT_L(glyphp[12][line],20);
        bits |= SHIFT_L(glyphp[13][line],27);
d683 7
a689 7
	CHECKRETURN(3);	
        bits = SHIFT_R(glyphp[13][line],5);
        bits |= SHIFT_L(glyphp[14][line],2);
        bits |= SHIFT_L(glyphp[15][line],9);
        bits |= SHIFT_L(glyphp[16][line],16);
        bits |= SHIFT_L(glyphp[17][line],23);
        bits |= SHIFT_L(glyphp[18][line],30);
d691 6
a696 6
	CHECKRETURN(4);	
        bits = SHIFT_R(glyphp[18][line],2);
        bits |= SHIFT_L(glyphp[19][line],5);
        bits |= SHIFT_L(glyphp[20][line],12);
        bits |= SHIFT_L(glyphp[21][line],19);
        bits |= SHIFT_L(glyphp[22][line],26);
d698 7
a704 7
	CHECKRETURN(5);	
        bits = SHIFT_R(glyphp[22][line],6);
        bits |= SHIFT_L(glyphp[23][line],1);
        bits |= SHIFT_L(glyphp[24][line],8);
        bits |= SHIFT_L(glyphp[25][line],15);
        bits |= SHIFT_L(glyphp[26][line],22);
        bits |= SHIFT_L(glyphp[27][line],29);
d706 6
a711 6
	CHECKRETURN(6);	
        bits = SHIFT_R(glyphp[27][line],3);
        bits |= SHIFT_L(glyphp[28][line],4);
        bits |= SHIFT_L(glyphp[29][line],11);
        bits |= SHIFT_L(glyphp[30][line],18);
        bits |= SHIFT_L(glyphp[31][line],25);
d713 1
a713 1
	CHECKRETURN(7);	
a722 1

d724 4
a727 5
static CARD32* 
DrawTETextScanlineWidth8(
    CARD32 *base,
    unsigned int **glyphp,
    int line, int width, int glyphwidth )
d731 1
d733 3
a735 3
        bits |= SHIFT_L(glyphp[1][line],8);
        bits |= SHIFT_L(glyphp[2][line],16);
        bits |= SHIFT_L(glyphp[3][line],24);
d737 1
a737 1
	CHECKRETURN(1);
d739 3
a741 3
        bits |= SHIFT_L(glyphp[5][line],8);
        bits |= SHIFT_L(glyphp[6][line],16);
        bits |= SHIFT_L(glyphp[7][line],24);
d743 1
a743 1
	CHECKRETURN(2);
d747 1
a747 1
	width -= 64;
d755 4
a758 5
static CARD32* 
DrawTETextScanlineWidth9(
    CARD32 *base,
    unsigned int **glyphp,
    int line, int width, int glyphwidth )
d762 1
d764 3
a766 3
        bits |= SHIFT_L(glyphp[1][line],9);
        bits |= SHIFT_L(glyphp[2][line],18);
        bits |= SHIFT_L(glyphp[3][line],27);
d768 6
a773 6
	CHECKRETURN(1);	
        bits = SHIFT_R(glyphp[3][line],5);
        bits |= SHIFT_L(glyphp[4][line],4);
        bits |= SHIFT_L(glyphp[5][line],13);
        bits |= SHIFT_L(glyphp[6][line],22);
        bits |= SHIFT_L(glyphp[7][line],31);
d775 5
a779 5
	CHECKRETURN(2);	
        bits = SHIFT_R(glyphp[7][line],1);
        bits |= SHIFT_L(glyphp[8][line],8);
        bits |= SHIFT_L(glyphp[9][line],17);
        bits |= SHIFT_L(glyphp[10][line],26);
d781 6
a786 6
	CHECKRETURN(3);	
        bits = SHIFT_R(glyphp[10][line],6);
        bits |= SHIFT_L(glyphp[11][line],3);
        bits |= SHIFT_L(glyphp[12][line],12);
        bits |= SHIFT_L(glyphp[13][line],21);
        bits |= SHIFT_L(glyphp[14][line],30);
d788 5
a792 5
	CHECKRETURN(4);	
        bits = SHIFT_R(glyphp[14][line],2);
        bits |= SHIFT_L(glyphp[15][line],7);
        bits |= SHIFT_L(glyphp[16][line],16);
        bits |= SHIFT_L(glyphp[17][line],25);
d794 6
a799 6
	CHECKRETURN(5);	
        bits = SHIFT_R(glyphp[17][line],7);
        bits |= SHIFT_L(glyphp[18][line],2);
        bits |= SHIFT_L(glyphp[19][line],11);
        bits |= SHIFT_L(glyphp[20][line],20);
        bits |= SHIFT_L(glyphp[21][line],29);
d801 5
a805 5
	CHECKRETURN(6);	
        bits = SHIFT_R(glyphp[21][line],3);
        bits |= SHIFT_L(glyphp[22][line],6);
        bits |= SHIFT_L(glyphp[23][line],15);
        bits |= SHIFT_L(glyphp[24][line],24);
d807 6
a812 6
	CHECKRETURN(7);	
        bits = SHIFT_R(glyphp[24][line],8);
        bits |= SHIFT_L(glyphp[25][line],1);
        bits |= SHIFT_L(glyphp[26][line],10);
        bits |= SHIFT_L(glyphp[27][line],19);
        bits |= SHIFT_L(glyphp[28][line],28);
d814 5
a818 5
	CHECKRETURN(8);	
        bits = SHIFT_R(glyphp[28][line],4);
        bits |= SHIFT_L(glyphp[29][line],5);
        bits |= SHIFT_L(glyphp[30][line],14);
        bits |= SHIFT_L(glyphp[31][line],23);
d820 1
a820 1
	CHECKRETURN(9);	
d831 4
a834 5
static CARD32* 
DrawTETextScanlineWidth10(
    CARD32 *base,
    unsigned int **glyphp,
    int line, int width, int glyphwidth )
d838 1
d840 3
a842 3
        bits |= SHIFT_L(glyphp[1][line],10);
        bits |= SHIFT_L(glyphp[2][line],20);
        bits |= SHIFT_L(glyphp[3][line],30);
d844 5
a848 5
	CHECKRETURN(1);	
        bits = SHIFT_R(glyphp[3][line],2);
        bits |= SHIFT_L(glyphp[4][line],8);
        bits |= SHIFT_L(glyphp[5][line],18);
        bits |= SHIFT_L(glyphp[6][line],28);
d850 5
a854 5
	CHECKRETURN(2);	
        bits = SHIFT_R(glyphp[6][line],4);
        bits |= SHIFT_L(glyphp[7][line],6);
        bits |= SHIFT_L(glyphp[8][line],16);
        bits |= SHIFT_L(glyphp[9][line],26);
d856 5
a860 5
	CHECKRETURN(3);	
        bits =  SHIFT_R(glyphp[9][line],6);
        bits |= SHIFT_L(glyphp[10][line],4);
        bits |= SHIFT_L(glyphp[11][line],14);
        bits |= SHIFT_L(glyphp[12][line],24);
d862 5
a866 5
	CHECKRETURN(4);	
        bits = SHIFT_R(glyphp[12][line],8);
        bits |= SHIFT_L(glyphp[13][line],2);
        bits |= SHIFT_L(glyphp[14][line],12);
        bits |= SHIFT_L(glyphp[15][line],22);
d868 1
a868 1
	CHECKRETURN(5);	
d878 4
a881 5
static CARD32* 
DrawTETextScanlineWidth12(
    CARD32 *base,
    unsigned int **glyphp,
    int line, int width, int glyphwidth )
d885 1
d887 2
a888 2
        bits |= SHIFT_L(glyphp[1][line],12);
        bits |= SHIFT_L(glyphp[2][line],24);
d890 5
a894 5
	CHECKRETURN(1);	
        bits = SHIFT_R(glyphp[2][line],8);
        bits |= SHIFT_L(glyphp[3][line],4);
        bits |= SHIFT_L(glyphp[4][line],16);
        bits |= SHIFT_L(glyphp[5][line],28);
d896 4
a899 4
	CHECKRETURN(2);	
        bits = SHIFT_R(glyphp[5][line],4);
        bits |= SHIFT_L(glyphp[6][line],8);
        bits |= SHIFT_L(glyphp[7][line],20);
d901 1
a901 1
	CHECKRETURN(3);	
d911 4
a914 7


static CARD32* 
DrawTETextScanlineWidth14(
    CARD32 *base,
    unsigned int **glyphp,
    int line, int width, int glyphwidth )
d918 1
d920 2
a921 2
        bits |= SHIFT_L(glyphp[1][line],14);
        bits |= SHIFT_L(glyphp[2][line],28);
d923 4
a926 4
	CHECKRETURN(1);	
        bits = SHIFT_R(glyphp[2][line],4);
        bits |= SHIFT_L(glyphp[3][line],10);
        bits |= SHIFT_L(glyphp[4][line],24);
d928 4
a931 4
	CHECKRETURN(2);	
        bits = SHIFT_R(glyphp[4][line],8);
        bits |= SHIFT_L(glyphp[5][line],6);
        bits |= SHIFT_L(glyphp[6][line],20);
d933 5
a937 5
	CHECKRETURN(3);	
        bits = SHIFT_R(glyphp[6][line],12);
        bits |= SHIFT_L(glyphp[7][line],2);
        bits |= SHIFT_L(glyphp[8][line],16);
        bits |= SHIFT_L(glyphp[9][line],30);
d939 4
a942 4
	CHECKRETURN(4);	
        bits = SHIFT_R(glyphp[9][line],2);
        bits |= SHIFT_L(glyphp[10][line],12);
        bits |= SHIFT_L(glyphp[11][line],26);
d944 4
a947 4
	CHECKRETURN(5);	
        bits = SHIFT_R(glyphp[11][line],6);
        bits |= SHIFT_L(glyphp[12][line],8);
        bits |= SHIFT_L(glyphp[13][line],22);
d949 4
a952 4
	CHECKRETURN(6);	
        bits = SHIFT_R(glyphp[13][line],10);
        bits |= SHIFT_L(glyphp[14][line],4);
        bits |= SHIFT_L(glyphp[15][line],18);
d954 1
a954 1
	CHECKRETURN(7);	
d964 4
a967 6

static CARD32* 
DrawTETextScanlineWidth16(
    CARD32 *base,
    unsigned int **glyphp,
    int line, int width, int glyphwidth )
d971 1
d973 1
a973 1
        bits |= SHIFT_L(glyphp[1][line],16);
d975 1
a975 1
	CHECKRETURN(1);	
d977 1
a977 1
        bits |= SHIFT_L(glyphp[3][line],16);
d979 1
a979 1
	CHECKRETURN(2);	
d981 1
a981 1
        bits |= SHIFT_L(glyphp[5][line],16);
d983 1
a983 1
	CHECKRETURN(3);	
d985 1
a985 1
        bits |= SHIFT_L(glyphp[7][line],16);
d987 1
a987 1
	CHECKRETURN(4);	
d991 1
a991 1
        width -= 128;	    
d997 4
a1000 7


static CARD32* 
DrawTETextScanlineWidth18(
    CARD32 *base,
    unsigned int **glyphp,
    int line, int width, int glyphwidth )
d1004 1
d1006 1
a1006 1
        bits |= SHIFT_L(glyphp[1][line],18);
d1008 4
a1011 4
	CHECKRETURN(1);	
        bits = SHIFT_R(glyphp[1][line],14);
        bits |= SHIFT_L(glyphp[2][line],4);
        bits |= SHIFT_L(glyphp[3][line],22);
d1013 4
a1016 4
	CHECKRETURN(2);	
        bits = SHIFT_R(glyphp[3][line],10);
        bits |= SHIFT_L(glyphp[4][line],8);
        bits |= SHIFT_L(glyphp[5][line],26);
d1018 4
a1021 4
	CHECKRETURN(3);	
        bits = SHIFT_R(glyphp[5][line],6);
        bits |= SHIFT_L(glyphp[6][line],12);
        bits |= SHIFT_L(glyphp[7][line],30);
d1023 3
a1025 3
	CHECKRETURN(4);	
        bits = SHIFT_R(glyphp[7][line],2);
        bits |= SHIFT_L(glyphp[8][line],16);
d1027 4
a1030 4
	CHECKRETURN(5);	
        bits = SHIFT_R(glyphp[8][line],16);
        bits |= SHIFT_L(glyphp[9][line],2);
        bits |= SHIFT_L(glyphp[10][line],20);
d1032 4
a1035 4
	CHECKRETURN(6);	
        bits = SHIFT_R(glyphp[10][line],12);
        bits |= SHIFT_L(glyphp[11][line],6);
        bits |= SHIFT_L(glyphp[12][line],24);
d1037 4
a1040 4
	CHECKRETURN(7);	
        bits = SHIFT_R(glyphp[12][line],8);
        bits |= SHIFT_L(glyphp[13][line],10);
        bits |= SHIFT_L(glyphp[14][line],28);
d1042 3
a1044 3
	CHECKRETURN(8);	
        bits = SHIFT_R(glyphp[14][line],4);
        bits |= SHIFT_L(glyphp[15][line],14);
d1046 1
a1046 1
	CHECKRETURN(9);	
d1056 4
a1059 6

static CARD32* 
DrawTETextScanlineWidth24(
    CARD32 *base,
    unsigned int **glyphp,
    int line, int width, int glyphwidth )
d1063 1
d1065 1
a1065 1
        bits |= SHIFT_L(glyphp[1][line],24);
d1067 3
a1069 3
	CHECKRETURN(1);	
        bits = SHIFT_R(glyphp[1][line],8);
        bits |= SHIFT_L(glyphp[2][line],16);
d1071 3
a1073 3
	CHECKRETURN(2);	
        bits = SHIFT_R(glyphp[2][line],16);
        bits |= SHIFT_L(glyphp[3][line],8);
d1075 1
a1075 1
	CHECKRETURN(3);	
a1083 2


@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d304 1
a304 1
    mem = (CARD32*)xalloc(((w + 31) >> 3) * sizeof(char));
d324 1
a324 1
    xfree(mem);
d481 1
a481 1
    mem = (CARD32*)xalloc(((w + 31) >> 3) * sizeof(char));
d498 1
a498 1
    xfree(mem);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d146 1
a146 1
void 
d242 1
a242 1
void 
d343 1
a343 1
void 
d418 1
a418 1
void 
@


1.1
log
@Initial revision
@
text
@d304 1
a304 1
    mem = (CARD32*)ALLOCATE_LOCAL(((w + 31) >> 3) * sizeof(char));
d324 1
a324 1
    DEALLOCATE_LOCAL(mem);
d481 1
a481 1
    mem = (CARD32*)ALLOCATE_LOCAL(((w + 31) >> 3) * sizeof(char));
d498 1
a498 1
    DEALLOCATE_LOCAL(mem);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
