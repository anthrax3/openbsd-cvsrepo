head	1.4;
access;
symbols
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.1.1.0.16
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2013.06.07.17.28.53;	author matthieu;	state dead;
branches;
next	1.3;

1.3
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.48;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.48;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"

#include <X11/X.h>
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "xf86str.h"
#include "xaa.h"
#include "xaalocal.h"

/*
   Much of this file based on code by 
	Harm Hanemaayer (H.Hanemaayer@@inter.nl.net).
*/

void
XAAPolyRectangleThinSolid(DrawablePtr pDrawable,
                          GCPtr pGC, int nRectsInit, xRectangle *pRectsInit)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    int nClipRects;             /* number of clip rectangles */
    BoxPtr pClipRects;          /* points to the list of clip rects */
    int xOrigin;                /* Drawables x origin */
    int yOrigin;                /* Drawables x origin */
    xRectangle *pRect;          /* list of rects */
    int nRects;                 /* running count of number of rects */
    int origX1, origY1;         /* original rectangle's U/L corner */
    int origX2, origY2;         /* original rectangle's L/R corner */
    int clippedX1;              /* clipped rectangle's left x */
    int clippedY1;              /* clipped rectangle's top y */
    int clippedX2;              /* clipped rectangle's right x */
    int clippedY2;              /* clipped rectangle's bottom y */
    int clipXMin;               /* upper left corner of clip rect */
    int clipYMin;               /* upper left corner of clip rect */
    int clipXMax;               /* lower right corner of clip rect */
    int clipYMax;               /* lower right corner of clip rect */
    int width, height;          /* width and height of rect */

    nClipRects = RegionNumRects(pGC->pCompositeClip);
    pClipRects = RegionRects(pGC->pCompositeClip);

    if (!nClipRects)
        return;

    xOrigin = pDrawable->x;
    yOrigin = pDrawable->y;

    (*infoRec->SetupForSolidLine) (infoRec->pScrn,
                                   pGC->fgPixel, pGC->alu, pGC->planemask);

    for (; nClipRects > 0; nClipRects--, pClipRects++) {
        clipYMin = pClipRects->y1;
        clipYMax = pClipRects->y2 - 1;
        clipXMin = pClipRects->x1;
        clipXMax = pClipRects->x2 - 1;

        for (pRect = pRectsInit, nRects = nRectsInit;
             nRects > 0; nRects--, pRect++) {
            /* translate rectangle data over to the drawable */
            origX1 = pRect->x + xOrigin;
            origY1 = pRect->y + yOrigin;
            origX2 = origX1 + pRect->width;
            origY2 = origY1 + pRect->height;

            /* reject entire rectangle if completely outside clip rect */
            if ((origX1 > clipXMax) || (origX2 < clipXMin) ||
                (origY1 > clipYMax) || (origY2 < clipYMin))
                continue;

            /* clip the rectangle */
            clippedX1 = max(origX1, clipXMin);
            clippedX2 = min(origX2, clipXMax);
            clippedY1 = max(origY1, clipYMin);
            clippedY2 = min(origY2, clipYMax);

            width = clippedX2 - clippedX1 + 1;

            if (origY1 >= clipYMin) {
                (*infoRec->SubsequentSolidHorVertLine) (infoRec->pScrn,
                                                        clippedX1, clippedY1,
                                                        width, DEGREES_0);

                /* don't overwrite corner */
                clippedY1++;
            }

            if ((origY2 <= clipYMax) && (origY1 != origY2)) {
                (*infoRec->SubsequentSolidHorVertLine) (infoRec->pScrn,
                                                        clippedX1, clippedY2,
                                                        width, DEGREES_0);

                /* don't overwrite corner */
                clippedY2--;
            }

            if (clippedY2 < clippedY1)
                continue;

            height = clippedY2 - clippedY1 + 1;

            /* draw vertical edges using lines if not clipped out */
            if (origX1 >= clipXMin)
                (*infoRec->SubsequentSolidHorVertLine) (infoRec->pScrn,
                                                        clippedX1, clippedY1,
                                                        height, DEGREES_270);

            if ((origX2 <= clipXMax) && (origX2 != origX1))
                (*infoRec->SubsequentSolidHorVertLine) (infoRec->pScrn,
                                                        clippedX2, clippedY1,
                                                        height, DEGREES_270);
        }
    }

    SET_SYNC_FLAG(infoRec);
}
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a21 1

d23 2
a24 5
XAAPolyRectangleThinSolid(
    DrawablePtr  pDrawable,
    GCPtr        pGC,    
    int	         nRectsInit,
    xRectangle  *pRectsInit )
d27 4
a30 4
    int         nClipRects;     /* number of clip rectangles */
    BoxPtr      pClipRects;     /* points to the list of clip rects */
    int         xOrigin;        /* Drawables x origin */
    int         yOrigin;        /* Drawables x origin */
d32 12
a43 12
    int         nRects;         /* running count of number of rects */
    int         origX1, origY1; /* original rectangle's U/L corner */
    int         origX2, origY2; /* original rectangle's L/R corner */
    int         clippedX1;      /* clipped rectangle's left x */
    int         clippedY1;      /* clipped rectangle's top y */
    int         clippedX2;      /* clipped rectangle's right x */
    int         clippedY2;      /* clipped rectangle's bottom y */
    int         clipXMin;       /* upper left corner of clip rect */
    int         clipYMin;       /* upper left corner of clip rect */
    int         clipXMax;       /* lower right corner of clip rect */
    int         clipYMax;       /* lower right corner of clip rect */
    int         width, height;  /* width and height of rect */
d48 2
a49 1
    if(!nClipRects) return;
d54 2
d57 1
a57 7
    (*infoRec->SetupForSolidLine)(infoRec->pScrn, 
			pGC->fgPixel, pGC->alu, pGC->planemask);


    for ( ; nClipRects > 0; 
	  nClipRects--, pClipRects++ )
    {
d63 49
a111 47
	for (pRect = pRectsInit, nRects = nRectsInit; 
	     nRects > 0; 
	     nRects--, pRect++ )
        {
	    /* translate rectangle data over to the drawable */
            origX1 = pRect->x + xOrigin; 
	    origY1 = pRect->y + yOrigin;
            origX2 = origX1 + pRect->width; 
	    origY2 = origY1 + pRect->height; 

	    /* reject entire rectangle if completely outside clip rect */
	    if ((origX1 > clipXMax) || (origX2 < clipXMin) ||
		(origY1 > clipYMax) || (origY2 < clipYMin))
	        continue;

	    /* clip the rectangle */
	    clippedX1 = max (origX1, clipXMin);
	    clippedX2 = min (origX2, clipXMax);
	    clippedY1 = max (origY1, clipYMin);
	    clippedY2 = min (origY2, clipYMax);

	    width = clippedX2 - clippedX1 + 1;

	    if (origY1 >= clipYMin) {
		(*infoRec->SubsequentSolidHorVertLine)(infoRec->pScrn,
			clippedX1, clippedY1, width, DEGREES_0);

		/* don't overwrite corner */
		clippedY1++;
	    }

	    if ((origY2 <= clipYMax) && (origY1 != origY2)) {
		(*infoRec->SubsequentSolidHorVertLine)(infoRec->pScrn,
			clippedX1, clippedY2, width, DEGREES_0);

		/* don't overwrite corner */
		clippedY2--; 
	    }

	    if (clippedY2 < clippedY1) continue;

	    height = clippedY2 - clippedY1 + 1;

	    /* draw vertical edges using lines if not clipped out */
            if (origX1 >= clipXMin) 
		(*infoRec->SubsequentSolidHorVertLine)(infoRec->pScrn,
			clippedX1, clippedY1, height, DEGREES_270);
d114 4
a117 3
		(*infoRec->SubsequentSolidHorVertLine)(infoRec->pScrn,
			clippedX2, clippedY1, height, DEGREES_270);
	}
d121 1
a121 12
} 











@


1.1
log
@Initial revision
@
text
@d49 2
a50 2
    nClipRects = REGION_NUM_RECTS(pGC->pCompositeClip);
    pClipRects = REGION_RECTS(pGC->pCompositeClip);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
