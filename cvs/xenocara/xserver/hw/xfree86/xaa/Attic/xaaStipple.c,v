head	1.4;
access;
symbols
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.8
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2013.06.07.17.28.53;	author matthieu;	state dead;
branches;
next	1.3;

1.3
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.41;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.41;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "xaa.h"
#include "xaalocal.h"
#include "xaacexp.h"
#include "xf86.h"

static CARD32 *StipplePowerOfTwo(CARD32 *, CARD32 *, int, int, int);
static CARD32 *StipplePowerOfTwo_Inverted(CARD32 *, CARD32 *, int, int, int);
static CARD32 *StippleUpTo32(CARD32 *, CARD32 *, int, int, int);
static CARD32 *StippleUpTo32_Inverted(CARD32 *, CARD32 *, int, int, int);
static CARD32 *StippleOver32(CARD32 *, CARD32 *, int, int, int);
static CARD32 *StippleOver32_Inverted(CARD32 *, CARD32 *, int, int, int);

#ifdef TRIPLE_BITS
#define stipple_scanline_func EXPNAME(XAAStippleScanlineFunc3)
#define stipple_get_scanline_func EXPNAME(XAAGetStippleScanlineFunc3)
#else
#define stipple_scanline_func EXPNAME(XAAStippleScanlineFunc)
#define stipple_get_scanline_func EXPNAME(XAAGetStippleScanlineFunc)
#endif

StippleScanlineProcPtr stipple_scanline_func[6] = {
    StipplePowerOfTwo,
    StippleUpTo32,
    StippleOver32,
    StipplePowerOfTwo_Inverted,
    StippleUpTo32_Inverted,
    StippleOver32_Inverted
};

StippleScanlineProcPtr *
stipple_get_scanline_func(void)
{
    return stipple_scanline_func;
}

#ifdef FIXEDBASE
#define DEST(i)	*dest
#define RETURN(i)	return(dest)
#else
#define DEST(i)	dest[i]
#define RETURN(i)	return(dest + i)
#endif

/* TRIPLE_BITS pattern expansion */
#ifdef TRIPLE_BITS
#define EXPAND_PAT \
	CARD32 pat1 = byte_expand3[pat & 0xFF], \
	       pat2 = byte_expand3[(pat & 0xFF00) >> 8], \
	       pat3 = byte_expand3[(pat & 0xFF0000) >> 16], \
	       pat4 = byte_expand3[(pat & 0xFF000000) >> 24], \
	       patA = pat1 | (pat2 << 24), \
	       patB = (pat2 >> 8) | (pat3 << 16), \
	       patC = (pat3 >> 16) | (pat4 << 8)
#ifdef FIXED_BASE
#define WRITE_PAT1 { \
	*dest = patA; }
#define WRITE_PAT2 { \
	*dest = patA; \
	*dest = patB; }
#define WRITE_PAT3 { \
	*dest = patA; \
	*dest = patB; \
	*dest = patC; }
#else
#define WRITE_PAT1 { \
	*(dest++) = patA; }
#define WRITE_PAT2 { \
	*(dest) = patA; \
	*(dest + 1) = patB; \
	dest += 2; }
#define WRITE_PAT3 { \
	*(dest) = patA; \
	*(dest + 1) = patB; \
	*(dest + 2) = patC; \
	dest += 3; }
#endif
#endif

#if !defined(FIXEDBASE) && !defined(MSBFIRST) && !defined(TRIPLE_BITS)

unsigned int XAAShiftMasks[32] = {
    /* gcc is rather pedantic about SHIFT_R(0xFFFFFFFF,32) */
    0x00000000, SHIFT_R(0xFFFFFFFF, 31),
    SHIFT_R(0xFFFFFFFF, 30), SHIFT_R(0xFFFFFFFF, 29),
    SHIFT_R(0xFFFFFFFF, 28), SHIFT_R(0xFFFFFFFF, 27),
    SHIFT_R(0xFFFFFFFF, 26), SHIFT_R(0xFFFFFFFF, 25),
    SHIFT_R(0xFFFFFFFF, 24), SHIFT_R(0xFFFFFFFF, 23),
    SHIFT_R(0xFFFFFFFF, 22), SHIFT_R(0xFFFFFFFF, 21),
    SHIFT_R(0xFFFFFFFF, 20), SHIFT_R(0xFFFFFFFF, 19),
    SHIFT_R(0xFFFFFFFF, 18), SHIFT_R(0xFFFFFFFF, 17),
    SHIFT_R(0xFFFFFFFF, 16), SHIFT_R(0xFFFFFFFF, 15),
    SHIFT_R(0xFFFFFFFF, 14), SHIFT_R(0xFFFFFFFF, 13),
    SHIFT_R(0xFFFFFFFF, 12), SHIFT_R(0xFFFFFFFF, 11),
    SHIFT_R(0xFFFFFFFF, 10), SHIFT_R(0xFFFFFFFF, 9),
    SHIFT_R(0xFFFFFFFF, 8), SHIFT_R(0xFFFFFFFF, 7),
    SHIFT_R(0xFFFFFFFF, 6), SHIFT_R(0xFFFFFFFF, 5),
    SHIFT_R(0xFFFFFFFF, 4), SHIFT_R(0xFFFFFFFF, 3),
    SHIFT_R(0xFFFFFFFF, 2), SHIFT_R(0xFFFFFFFF, 1)
};

#endif

void
#ifdef TRIPLE_BITS
 EXPNAME(XAAFillColorExpandRects3) (
#else
 EXPNAME(XAAFillColorExpandRects) (
#endif
                                      ScrnInfoPtr pScrn,
                                      int fg, int bg, int rop,
                                      unsigned int planemask,
                                      int nBox,
                                      BoxPtr pBox,
                                      int xorg, int yorg, PixmapPtr pPix) {
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    CARD32 *base;
    Bool TwoPass = FALSE, FirstPass = TRUE;
    StippleScanlineProcPtr StippleFunc, FirstFunc, SecondFunc;
    int stipplewidth = pPix->drawable.width;
    int stippleheight = pPix->drawable.height;
    int srcwidth = pPix->devKind;
    int dwords, srcy, srcx, funcNo = 2, h;
    unsigned char *src = (unsigned char *) pPix->devPrivate.ptr;
    unsigned char *srcp;
    int flag;

    if (stipplewidth <= 32) {
        if (stipplewidth & (stipplewidth - 1))
            funcNo = 1;
        else
            funcNo = 0;
    }
    StippleFunc = stipple_scanline_func[funcNo];
    SecondFunc = stipple_scanline_func[funcNo];
    FirstFunc = stipple_scanline_func[funcNo + 3];

#ifdef TRIPLE_BITS
    if ((bg == -1) ||
        (!(infoRec->CPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY) &&
         (!(infoRec->CPUToScreenColorExpandFillFlags & RGB_EQUAL) ||
          (CHECK_RGB_EQUAL(bg))))) {
#else
    if ((bg == -1) ||
        !(infoRec->CPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)) {
#endif
        /* one pass */
    }
    else if ((rop == GXcopy) && infoRec->FillSolidRects) {
        /* one pass but we fill background rects first */
        (*infoRec->FillSolidRects) (pScrn, bg, rop, planemask, nBox, pBox);
        bg = -1;
    }
    else {
        /* gotta do two passes */
        TwoPass = TRUE;
    }

    if (!TwoPass)
        (*infoRec->SetupForCPUToScreenColorExpandFill) (pScrn, fg, bg, rop,
                                                        planemask);

    while (nBox--) {
#ifdef TRIPLE_BITS
        dwords = (3 * (pBox->x2 - pBox->x1) + 31) >> 5;
#else
        dwords = (pBox->x2 - pBox->x1 + 31) >> 5;
#endif

 SECOND_PASS:
        if (TwoPass) {
            (*infoRec->SetupForCPUToScreenColorExpandFill) (pScrn,
                                                            (FirstPass) ? bg :
                                                            fg, -1, rop,
                                                            planemask);
            StippleFunc = (FirstPass) ? FirstFunc : SecondFunc;
        }

        h = pBox->y2 - pBox->y1;
        flag = (infoRec->CPUToScreenColorExpandFillFlags
                & CPU_TRANSFER_PAD_QWORD) && ((dwords * h) & 0x01);

        (*infoRec->SubsequentCPUToScreenColorExpandFill) (pScrn, pBox->x1,
                                                          pBox->y1,
                                                          pBox->x2 - pBox->x1,
                                                          h, 0);

        base = (CARD32 *) infoRec->ColorExpandBase;

        srcy = (pBox->y1 - yorg) % stippleheight;
        if (srcy < 0)
            srcy += stippleheight;
        srcx = (pBox->x1 - xorg) % stipplewidth;
        if (srcx < 0)
            srcx += stipplewidth;

        srcp = (srcwidth * srcy) + src;

#ifndef FIXEDBASE
        if ((dwords * h) <= infoRec->ColorExpandRange) {
            while (h--) {
                base =
                    (*StippleFunc) (base, (CARD32 *) srcp, srcx, stipplewidth,
                                    dwords);
                srcy++;
                srcp += srcwidth;
                if (srcy >= stippleheight) {
                    srcy = 0;
                    srcp = src;
                }
            }
        }
        else
#endif
            while (h--) {
                (*StippleFunc) (base, (CARD32 *) srcp, srcx, stipplewidth,
                                dwords);
                srcy++;
                srcp += srcwidth;
                if (srcy >= stippleheight) {
                    srcy = 0;
                    srcp = src;
                }
            }

        if (flag) {
            base = (CARD32 *) infoRec->ColorExpandBase;
            base[0] = 0x00000000;
        }

        if (TwoPass) {
            if (FirstPass) {
                FirstPass = FALSE;
                goto SECOND_PASS;
            }
            else
                FirstPass = TRUE;
        }

        pBox++;
    }

    if (infoRec->CPUToScreenColorExpandFillFlags & SYNC_AFTER_COLOR_EXPAND)
        (*infoRec->Sync) (pScrn);
    else
        SET_SYNC_FLAG(infoRec);
}

void
#ifdef TRIPLE_BITS
 EXPNAME(XAAFillColorExpandSpans3) (
#else
 EXPNAME(XAAFillColorExpandSpans) (
#endif
                                      ScrnInfoPtr pScrn,
                                      int fg, int bg, int rop,
                                      unsigned int planemask,
                                      int n,
                                      DDXPointPtr ppt,
                                      int *pwidth,
                                      int fSorted,
                                      int xorg, int yorg, PixmapPtr pPix) {
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    CARD32 *base;
    Bool TwoPass = FALSE, FirstPass = TRUE;
    StippleScanlineProcPtr StippleFunc, FirstFunc, SecondFunc;
    int stipplewidth = pPix->drawable.width;
    int stippleheight = pPix->drawable.height;
    int dwords, srcy, srcx, funcNo = 2;
    unsigned char *srcp;

    if (stipplewidth <= 32) {
        if (stipplewidth & (stipplewidth - 1))
            funcNo = 1;
        else
            funcNo = 0;
    }
    StippleFunc = stipple_scanline_func[funcNo];
    SecondFunc = stipple_scanline_func[funcNo];
    FirstFunc = stipple_scanline_func[funcNo + 3];

#ifdef TRIPLE_BITS
    if ((bg == -1) ||
        (!(infoRec->CPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY) &&
         (!(infoRec->CPUToScreenColorExpandFillFlags & RGB_EQUAL) ||
          (CHECK_RGB_EQUAL(bg))))) {
#else
    if ((bg == -1) ||
        !(infoRec->CPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)) {
#endif
        /* one pass */
    }
    else if ((rop == GXcopy) && infoRec->FillSolidSpans) {
        /* one pass but we fill background rects first */
        (*infoRec->FillSolidSpans) (pScrn, bg, rop, planemask, n, ppt, pwidth,
                                    fSorted);
        bg = -1;
    }
    else {
        /* gotta do two passes */
        TwoPass = TRUE;
    }

    if (!TwoPass)
        (*infoRec->SetupForCPUToScreenColorExpandFill) (pScrn, fg, bg, rop,
                                                        planemask);

    while (n--) {
#ifdef TRIPLE_BITS
        dwords = (3 * *pwidth + 31) >> 5;
#else
        dwords = (*pwidth + 31) >> 5;
#endif

        srcy = (ppt->y - yorg) % stippleheight;
        if (srcy < 0)
            srcy += stippleheight;
        srcx = (ppt->x - xorg) % stipplewidth;
        if (srcx < 0)
            srcx += stipplewidth;

        srcp = (pPix->devKind * srcy) + (unsigned char *) pPix->devPrivate.ptr;

 SECOND_PASS:
        if (TwoPass) {
            (*infoRec->SetupForCPUToScreenColorExpandFill) (pScrn,
                                                            (FirstPass) ? bg :
                                                            fg, -1, rop,
                                                            planemask);
            StippleFunc = (FirstPass) ? FirstFunc : SecondFunc;
        }

        (*infoRec->SubsequentCPUToScreenColorExpandFill) (pScrn, ppt->x, ppt->y,
                                                          *pwidth, 1, 0);

        base = (CARD32 *) infoRec->ColorExpandBase;

        (*StippleFunc) (base, (CARD32 *) srcp, srcx, stipplewidth, dwords);

        if ((infoRec->CPUToScreenColorExpandFillFlags & CPU_TRANSFER_PAD_QWORD)
            && (dwords & 0x01)) {
            base = (CARD32 *) infoRec->ColorExpandBase;
            base[0] = 0x00000000;
        }

        if (TwoPass) {
            if (FirstPass) {
                FirstPass = FALSE;
                goto SECOND_PASS;
            }
            else
                FirstPass = TRUE;
        }

        ppt++;
        pwidth++;
    }

    if (infoRec->CPUToScreenColorExpandFillFlags & SYNC_AFTER_COLOR_EXPAND)
        (*infoRec->Sync) (pScrn);
    else
        SET_SYNC_FLAG(infoRec);
}

#ifndef FIXEDBASE

void
#ifdef TRIPLE_BITS
 EXPNAME(XAAFillScanlineColorExpandRects3) (
#else
 EXPNAME(XAAFillScanlineColorExpandRects) (
#endif
                                              ScrnInfoPtr pScrn,
                                              int fg, int bg, int rop,
                                              unsigned int planemask,
                                              int nBox,
                                              BoxPtr pBox,
                                              int xorg, int yorg,
                                              PixmapPtr pPix) {
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    CARD32 *base;
    Bool TwoPass = FALSE, FirstPass = TRUE;
    StippleScanlineProcPtr StippleFunc, FirstFunc, SecondFunc;
    int stipplewidth = pPix->drawable.width;
    int stippleheight = pPix->drawable.height;
    int srcwidth = pPix->devKind;
    int dwords, srcy, srcx, funcNo = 2, bufferNo, h;
    unsigned char *src = pPix->devPrivate.ptr;
    unsigned char *srcp;

    if (stipplewidth <= 32) {
        if (stipplewidth & (stipplewidth - 1))
            funcNo = 1;
        else
            funcNo = 0;
    }
    StippleFunc = stipple_scanline_func[funcNo];
    SecondFunc = stipple_scanline_func[funcNo];
    FirstFunc = stipple_scanline_func[funcNo + 3];

#ifdef TRIPLE_BITS
    if ((bg == -1) ||
        (!(infoRec->ScanlineCPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)
         && (!(infoRec->ScanlineCPUToScreenColorExpandFillFlags & RGB_EQUAL) ||
             (CHECK_RGB_EQUAL(bg))))) {
#else
    if ((bg == -1) ||
        !(infoRec->
          ScanlineCPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)) {
#endif
        /* one pass */
    }
    else if ((rop == GXcopy) && infoRec->FillSolidRects) {
        /* one pass but we fill background rects first */
        (*infoRec->FillSolidRects) (pScrn, bg, rop, planemask, nBox, pBox);
        bg = -1;
    }
    else {
        /* gotta do two passes */
        TwoPass = TRUE;
    }

    if (!TwoPass)
        (*infoRec->SetupForScanlineCPUToScreenColorExpandFill) (pScrn, fg, bg,
                                                                rop, planemask);

    while (nBox--) {
#ifdef TRIPLE_BITS
        dwords = (3 * (pBox->x2 - pBox->x1) + 31) >> 5;
#else
        dwords = (pBox->x2 - pBox->x1 + 31) >> 5;
#endif

 SECOND_PASS:
        if (TwoPass) {
            (*infoRec->SetupForScanlineCPUToScreenColorExpandFill) (pScrn,
                                                                    (FirstPass)
                                                                    ? bg : fg,
                                                                    -1, rop,
                                                                    planemask);
            StippleFunc = (FirstPass) ? FirstFunc : SecondFunc;
        }

        h = pBox->y2 - pBox->y1;

        (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill) (pScrn,
                                                                  pBox->x1,
                                                                  pBox->y1,
                                                                  pBox->x2 -
                                                                  pBox->x1, h,
                                                                  0);

        bufferNo = 0;

        srcy = (pBox->y1 - yorg) % stippleheight;
        if (srcy < 0)
            srcy += stippleheight;
        srcx = (pBox->x1 - xorg) % stipplewidth;
        if (srcx < 0)
            srcx += stipplewidth;

        srcp = (srcwidth * srcy) + src;

        while (h--) {
            base = (CARD32 *) infoRec->ScanlineColorExpandBuffers[bufferNo];
            (*StippleFunc) (base, (CARD32 *) srcp, srcx, stipplewidth, dwords);
            (*infoRec->SubsequentColorExpandScanline) (pScrn, bufferNo++);
            if (bufferNo >= infoRec->NumScanlineColorExpandBuffers)
                bufferNo = 0;
            srcy++;
            srcp += srcwidth;
            if (srcy >= stippleheight) {
                srcy = 0;
                srcp = src;
            }
        }

        if (TwoPass) {
            if (FirstPass) {
                FirstPass = FALSE;
                goto SECOND_PASS;
            }
            else
                FirstPass = TRUE;
        }

        pBox++;
    }

    SET_SYNC_FLAG(infoRec);
}

void
#ifdef TRIPLE_BITS
 EXPNAME(XAAFillScanlineColorExpandSpans3) (
#else
 EXPNAME(XAAFillScanlineColorExpandSpans) (
#endif
                                              ScrnInfoPtr pScrn,
                                              int fg, int bg, int rop,
                                              unsigned int planemask,
                                              int n,
                                              DDXPointPtr ppt,
                                              int *pwidth,
                                              int fSorted,
                                              int xorg, int yorg,
                                              PixmapPtr pPix) {
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    CARD32 *base;
    Bool TwoPass = FALSE, FirstPass = TRUE;
    StippleScanlineProcPtr StippleFunc, FirstFunc, SecondFunc;
    int stipplewidth = pPix->drawable.width;
    int stippleheight = pPix->drawable.height;
    int dwords, srcy, srcx, funcNo = 2;
    unsigned char *srcp;

    if (stipplewidth <= 32) {
        if (stipplewidth & (stipplewidth - 1))
            funcNo = 1;
        else
            funcNo = 0;
    }
    StippleFunc = stipple_scanline_func[funcNo];
    SecondFunc = stipple_scanline_func[funcNo];
    FirstFunc = stipple_scanline_func[funcNo + 3];

#ifdef TRIPLE_BITS
    if ((bg == -1) ||
        (!(infoRec->ScanlineCPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)
         && (!(infoRec->ScanlineCPUToScreenColorExpandFillFlags & RGB_EQUAL) ||
             (CHECK_RGB_EQUAL(bg))))) {
#else
    if ((bg == -1) ||
        !(infoRec->
          ScanlineCPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)) {
#endif
        /* one pass */
    }
    else if ((rop == GXcopy) && infoRec->FillSolidSpans) {
        /* one pass but we fill background rects first */
        (*infoRec->FillSolidSpans) (pScrn, bg, rop, planemask, n, ppt, pwidth,
                                    fSorted);
        bg = -1;
    }
    else {
        /* gotta do two passes */
        TwoPass = TRUE;
    }

    if (!TwoPass)
        (*infoRec->SetupForScanlineCPUToScreenColorExpandFill) (pScrn, fg, bg,
                                                                rop, planemask);

    while (n--) {
#ifdef TRIPLE_BITS
        dwords = (3 * *pwidth + 31) >> 5;
#else
        dwords = (*pwidth + 31) >> 5;
#endif

        srcy = (ppt->y - yorg) % stippleheight;
        if (srcy < 0)
            srcy += stippleheight;
        srcx = (ppt->x - xorg) % stipplewidth;
        if (srcx < 0)
            srcx += stipplewidth;

        srcp = (pPix->devKind * srcy) + (unsigned char *) pPix->devPrivate.ptr;

 SECOND_PASS:
        if (TwoPass) {
            (*infoRec->SetupForScanlineCPUToScreenColorExpandFill) (pScrn,
                                                                    (FirstPass)
                                                                    ? bg : fg,
                                                                    -1, rop,
                                                                    planemask);
            StippleFunc = (FirstPass) ? FirstFunc : SecondFunc;
        }

        (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill) (pScrn, ppt->x,
                                                                  ppt->y,
                                                                  *pwidth, 1,
                                                                  0);

        base = (CARD32 *) infoRec->ScanlineColorExpandBuffers[0];

        (*StippleFunc) (base, (CARD32 *) srcp, srcx, stipplewidth, dwords);
        (*infoRec->SubsequentColorExpandScanline) (pScrn, 0);

        if (TwoPass) {
            if (FirstPass) {
                FirstPass = FALSE;
                goto SECOND_PASS;
            }
            else
                FirstPass = TRUE;
        }

        ppt++;
        pwidth++;
    }

    SET_SYNC_FLAG(infoRec);
}

#endif

static CARD32 *
StipplePowerOfTwo(CARD32 *dest, CARD32 *src, int shift, int width, int dwords)
{
    CARD32 pat = *src;

    if (width < 32) {
        pat &= XAAShiftMasks[width];
        while (width < 32) {
            pat |= SHIFT_L(pat, width);
            width <<= 1;
        }
    }

    if (shift)
        pat = SHIFT_R(pat, shift) | SHIFT_L(pat, 32 - shift);

#ifdef MSBFIRST
    pat = SWAP_BITS_IN_BYTES(pat);
#endif

#ifdef TRIPLE_BITS
    {
        EXPAND_PAT;

        while (dwords >= 3) {
            WRITE_PAT3;
            dwords -= 3;
        }
        if (dwords == 2) {
            WRITE_PAT2;
        }
        else if (dwords == 1) {
            WRITE_PAT1;
        }

        return dest;
    }
#else                           /* TRIPLE_BITS */
    while (dwords >= 4) {
        DEST(0) = pat;
        DEST(1) = pat;
        DEST(2) = pat;
        DEST(3) = pat;
        dwords -= 4;
#ifndef FIXEDBASE
        dest += 4;
#endif
    }

    if (!dwords)
        return dest;
    DEST(0) = pat;
    if (dwords == 1)
        RETURN(1);
    DEST(1) = pat;
    if (dwords == 2)
        RETURN(2);
    DEST(2) = pat;
    RETURN(3);
#endif                          /* TRIPLE_BITS */
}

static CARD32 *
StipplePowerOfTwo_Inverted(CARD32 *dest, CARD32 *src,
                           int shift, int width, int dwords)
{
    CARD32 pat = *src;

    if (width < 32) {
        pat &= XAAShiftMasks[width];
        while (width < 32) {
            pat |= SHIFT_L(pat, width);
            width <<= 1;
        }
    }

    if (shift)
        pat = SHIFT_R(pat, shift) | SHIFT_L(pat, 32 - shift);

#ifdef MSBFIRST
    pat = SWAP_BITS_IN_BYTES(pat);
#endif

    pat = ~pat;

#ifdef TRIPLE_BITS
    {
        EXPAND_PAT;

        while (dwords >= 3) {
            WRITE_PAT3;
            dwords -= 3;
        }
        if (dwords == 2) {
            WRITE_PAT2;
        }
        else if (dwords == 1) {
            WRITE_PAT1;
        }

        return dest;
    }
#else                           /* TRIPLE_BITS */
    while (dwords >= 4) {
        DEST(0) = pat;
        DEST(1) = pat;
        DEST(2) = pat;
        DEST(3) = pat;
        dwords -= 4;
#ifndef FIXEDBASE
        dest += 4;
#endif
    }

    if (!dwords)
        return dest;
    DEST(0) = pat;
    if (dwords == 1)
        RETURN(1);
    DEST(1) = pat;
    if (dwords == 2)
        RETURN(2);
    DEST(2) = pat;
    RETURN(3);
#endif                          /* TRIPLE_BITS */
}

static CARD32 *
StippleUpTo32(CARD32 *base, CARD32 *src, int shift, int width, int dwords)
{
    CARD32 pat = *src & XAAShiftMasks[width];

    while (width <= 15) {
        pat |= SHIFT_L(pat, width);
        width <<= 1;
    }
    pat |= SHIFT_L(pat, width);

    while (dwords--) {
        CARD32 bits = SHIFT_R(pat, shift) | SHIFT_L(pat, width - shift);

#ifdef TRIPLE_BITS
        if (dwords >= 2) {
            WRITE_BITS3(bits);
            dwords -= 2;
        }
        else if (dwords > 0) {
            WRITE_BITS2(bits);
            dwords--;
        }
        else {
            WRITE_BITS1(bits);
        }
#else
        WRITE_BITS(bits);
#endif

        shift += 32;
        shift %= width;
    }
    return base;
}

static CARD32 *
StippleUpTo32_Inverted(CARD32 *base, CARD32 *src,
                       int shift, int width, int dwords)
{
    CARD32 pat = *src & XAAShiftMasks[width];

    while (width <= 15) {
        pat |= SHIFT_L(pat, width);
        width <<= 1;
    }
    pat |= SHIFT_L(pat, width);

    while (dwords--) {
        CARD32 bits = ~(SHIFT_R(pat, shift) | SHIFT_L(pat, width - shift));

#ifdef TRIPLE_BITS
        if (dwords >= 2) {
            WRITE_BITS3(bits);
            dwords -= 2;
        }
        else if (dwords > 0) {
            WRITE_BITS2(bits);
            dwords--;
        }
        else {
            WRITE_BITS1(bits);
        }
#else
        WRITE_BITS(bits);
#endif

        shift += 32;
        shift %= width;
    }
    return base;
}

static CARD32 *
StippleOver32(CARD32 *base, CARD32 *src, int offset, int width, int dwords)
{
    CARD32 *srcp;
    CARD32 bits;
    int bitsleft, shift, usable;

    while (dwords--) {
        bitsleft = width - offset;
        srcp = src + (offset >> 5);
        shift = offset & 31;
        usable = 32 - shift;

        if (bitsleft < 32) {
            if (bitsleft <= usable) {
                bits = SHIFT_L(*src, bitsleft) |
                    (SHIFT_R(*srcp, shift) & XAAShiftMasks[bitsleft]);
            }
            else {
                bits = SHIFT_L(*src, bitsleft) |
                    (SHIFT_L(srcp[1], usable) & XAAShiftMasks[bitsleft]) |
                    (SHIFT_R(*srcp, shift) & XAAShiftMasks[usable]);
            }
        }
        else if (shift)
            bits = SHIFT_R(*srcp, shift) | SHIFT_L(srcp[1], usable);
        else
            bits = *srcp;

#ifdef TRIPLE_BITS
        if (dwords >= 2) {
            WRITE_BITS3(bits);
            dwords -= 2;
        }
        else if (dwords > 0) {
            WRITE_BITS2(bits);
            dwords--;
        }
        else {
            WRITE_BITS1(bits);
        }
#else
        WRITE_BITS(bits);
#endif

        offset += 32;
        offset %= width;
    }
    return base;
}

static CARD32 *
StippleOver32_Inverted(CARD32 *base, CARD32 *src,
                       int offset, int width, int dwords)
{
    CARD32 *srcp;
    CARD32 bits;
    int bitsleft, shift, usable;

    while (dwords--) {
        bitsleft = width - offset;
        srcp = src + (offset >> 5);
        shift = offset & 31;
        usable = 32 - shift;

        if (bitsleft < 32) {
            if (bitsleft <= usable) {
                bits = SHIFT_L(*src, bitsleft) |
                    (SHIFT_R(*srcp, shift) & XAAShiftMasks[bitsleft]);
            }
            else {
                bits = SHIFT_L(*src, bitsleft) |
                    (SHIFT_L(srcp[1], usable) & XAAShiftMasks[bitsleft]) |
                    (SHIFT_R(*srcp, shift) & XAAShiftMasks[usable]);
            }
        }
        else if (shift)
            bits = SHIFT_R(*srcp, shift) | SHIFT_L(srcp[1], usable);
        else
            bits = *srcp;

        bits = ~bits;

#ifdef TRIPLE_BITS
        if (dwords >= 2) {
            WRITE_BITS3(bits);
            dwords -= 2;
        }
        else if (dwords > 0) {
            WRITE_BITS2(bits);
            dwords--;
        }
        else {
            WRITE_BITS1(bits);
        }
#else
        WRITE_BITS(bits);
#endif

        offset += 32;
        offset %= width;
    }
    return base;
}
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d11 6
a16 6
static CARD32* StipplePowerOfTwo(CARD32*, CARD32*, int, int, int);
static CARD32* StipplePowerOfTwo_Inverted(CARD32*, CARD32*, int, int, int);
static CARD32* StippleUpTo32(CARD32*, CARD32*, int, int, int);
static CARD32* StippleUpTo32_Inverted(CARD32*, CARD32*, int, int, int);
static CARD32* StippleOver32(CARD32*, CARD32*, int, int, int);
static CARD32* StippleOver32_Inverted(CARD32*, CARD32*, int, int, int);
d27 6
a32 6
   StipplePowerOfTwo,
   StippleUpTo32,
   StippleOver32,
   StipplePowerOfTwo_Inverted,
   StippleUpTo32_Inverted,
   StippleOver32_Inverted
d35 4
a38 2
StippleScanlineProcPtr *stipple_get_scanline_func(void) {
   return stipple_scanline_func;
d42 2
a43 2
# define DEST(i)	*dest
# define RETURN(i)	return(dest)
d45 2
a46 2
# define DEST(i)	dest[i]
# define RETURN(i)	return(dest + i)
a48 1

a83 1

d87 17
a103 17
  /* gcc is rather pedantic about SHIFT_R(0xFFFFFFFF,32) */
          0x00000000    , SHIFT_R(0xFFFFFFFF,31),
  SHIFT_R(0xFFFFFFFF,30), SHIFT_R(0xFFFFFFFF,29),
  SHIFT_R(0xFFFFFFFF,28), SHIFT_R(0xFFFFFFFF,27),
  SHIFT_R(0xFFFFFFFF,26), SHIFT_R(0xFFFFFFFF,25),
  SHIFT_R(0xFFFFFFFF,24), SHIFT_R(0xFFFFFFFF,23),
  SHIFT_R(0xFFFFFFFF,22), SHIFT_R(0xFFFFFFFF,21),
  SHIFT_R(0xFFFFFFFF,20), SHIFT_R(0xFFFFFFFF,19),
  SHIFT_R(0xFFFFFFFF,18), SHIFT_R(0xFFFFFFFF,17),
  SHIFT_R(0xFFFFFFFF,16), SHIFT_R(0xFFFFFFFF,15),
  SHIFT_R(0xFFFFFFFF,14), SHIFT_R(0xFFFFFFFF,13),
  SHIFT_R(0xFFFFFFFF,12), SHIFT_R(0xFFFFFFFF,11),
  SHIFT_R(0xFFFFFFFF,10), SHIFT_R(0xFFFFFFFF,9),
  SHIFT_R(0xFFFFFFFF,8),  SHIFT_R(0xFFFFFFFF,7),
  SHIFT_R(0xFFFFFFFF,6),  SHIFT_R(0xFFFFFFFF,5),
  SHIFT_R(0xFFFFFFFF,4),  SHIFT_R(0xFFFFFFFF,3),
  SHIFT_R(0xFFFFFFFF,2),  SHIFT_R(0xFFFFFFFF,1)
d110 1
a110 1
EXPNAME(XAAFillColorExpandRects3)(
d112 1
a112 1
EXPNAME(XAAFillColorExpandRects)(
d114 6
a119 8
   ScrnInfoPtr pScrn,
   int fg, int bg, int rop,
   unsigned int planemask,
   int nBox,
   BoxPtr pBox,
   int xorg, int yorg,
   PixmapPtr pPix
){
d128 1
a128 1
    unsigned char *src = (unsigned char*)pPix->devPrivate.ptr;
d132 6
a137 6
    if(stipplewidth <= 32) {
	if(stipplewidth & (stipplewidth - 1))	
	  funcNo = 1;
	else	
	  funcNo = 0;
    } 
d143 4
a146 4
    if((bg == -1) || 
	(!(infoRec->CPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY) &&
	(!(infoRec->CPUToScreenColorExpandFillFlags & RGB_EQUAL) ||
	(CHECK_RGB_EQUAL(bg))))) {
d148 2
a149 2
    if((bg == -1) || 
	!(infoRec->CPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)) {
d151 10
a160 8
	/* one pass */
    } else if((rop == GXcopy) && infoRec->FillSolidRects) {
	/* one pass but we fill background rects first */
	(*infoRec->FillSolidRects)(pScrn, bg, rop, planemask, nBox, pBox);
	bg = -1;
    } else {
	/* gotta do two passes */
	TwoPass = TRUE;
d163 3
a165 3
    if(!TwoPass)
	(*infoRec->SetupForCPUToScreenColorExpandFill)(
					pScrn, fg, bg, rop, planemask);
d167 1
a167 1
    while(nBox--) {
d169 1
a169 1
	dwords = (3 * (pBox->x2 - pBox->x1) + 31) >> 5;
d171 1
a171 1
	dwords = (pBox->x2 - pBox->x1 + 31) >> 5;
d174 8
a181 6
SECOND_PASS:
	if(TwoPass) {
	    (*infoRec->SetupForCPUToScreenColorExpandFill)(pScrn, 
			(FirstPass) ? bg : fg, -1, rop, planemask);
	    StippleFunc = (FirstPass) ? FirstFunc : SecondFunc;
	}
d183 17
a199 3
	h = pBox->y2 - pBox->y1;
	flag = (infoRec->CPUToScreenColorExpandFillFlags 
		& CPU_TRANSFER_PAD_QWORD) && ((dwords * h) & 0x01);
d201 1
a201 3
        (*infoRec->SubsequentCPUToScreenColorExpandFill)(
			pScrn, pBox->x1, pBox->y1,
 			pBox->x2 - pBox->x1, h, 0);
d203 26
a228 1
	base = (CARD32*)infoRec->ColorExpandBase;
d230 4
a233 4
	srcy = (pBox->y1 - yorg) % stippleheight;
	if(srcy < 0) srcy += stippleheight;
	srcx = (pBox->x1 - xorg) % stipplewidth;
	if(srcx < 0) srcx += stipplewidth;
d235 8
a242 45
	srcp = (srcwidth * srcy) + src;
	
#ifndef FIXEDBASE
	if((dwords * h) <= infoRec->ColorExpandRange) {
	   while(h--) {
		base = (*StippleFunc)(
			base, (CARD32*)srcp, srcx, stipplewidth, dwords);
		srcy++;
		srcp += srcwidth;
		if (srcy >= stippleheight) {
		   srcy = 0;
		   srcp = src;
		}
	   }
	} else
#endif
	   while(h--) {
		(*StippleFunc)(base, (CARD32*)srcp, srcx, stipplewidth, dwords);
		srcy++;
		srcp += srcwidth;
		if (srcy >= stippleheight) {
		   srcy = 0;
		   srcp = src;
		}
	   }
    
	  if (flag) {
	      base = (CARD32*)infoRec->ColorExpandBase;
	      base[0] = 0x00000000;
	  }

	if(TwoPass) {
	   if(FirstPass) {
		FirstPass = FALSE;
		goto SECOND_PASS;
	   } else FirstPass = TRUE;
	}

	pBox++;
     }

    if(infoRec->CPUToScreenColorExpandFillFlags & SYNC_AFTER_COLOR_EXPAND) 
	(*infoRec->Sync)(pScrn);
    else SET_SYNC_FLAG(infoRec);
}
d244 2
d247 5
d255 1
a255 1
EXPNAME(XAAFillColorExpandSpans3)(
d257 1
a257 1
EXPNAME(XAAFillColorExpandSpans)(
d259 8
a266 10
   ScrnInfoPtr pScrn,
   int fg, int bg, int rop,
   unsigned int planemask,
   int n,
   DDXPointPtr ppt,
   int *pwidth,
   int fSorted,
   int xorg, int yorg,
   PixmapPtr pPix
){
d276 6
a281 6
    if(stipplewidth <= 32) {
	if(stipplewidth & (stipplewidth - 1))	
	  funcNo = 1;
	else	
	  funcNo = 0;
    } 
d287 80
a366 70
    if((bg == -1) || 
	(!(infoRec->CPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY) &&
	(!(infoRec->CPUToScreenColorExpandFillFlags & RGB_EQUAL) ||
	(CHECK_RGB_EQUAL(bg))))) {
#else
    if((bg == -1) || 
	!(infoRec->CPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)) {
#endif
	/* one pass */
    } else if((rop == GXcopy) && infoRec->FillSolidSpans) {
	/* one pass but we fill background rects first */
	(*infoRec->FillSolidSpans)(
		pScrn, bg, rop, planemask, n, ppt, pwidth, fSorted);
	bg = -1;
    } else {
	/* gotta do two passes */
	TwoPass = TRUE;
    }

    if(!TwoPass)
	(*infoRec->SetupForCPUToScreenColorExpandFill)(
				pScrn, fg, bg, rop, planemask);

    while(n--) {
#ifdef TRIPLE_BITS
	dwords = (3 * *pwidth + 31) >> 5;
#else
	dwords = (*pwidth + 31) >> 5;
#endif

	srcy = (ppt->y - yorg) % stippleheight;
	if(srcy < 0) srcy += stippleheight;
	srcx = (ppt->x - xorg) % stipplewidth;
	if(srcx < 0) srcx += stipplewidth;

	srcp = (pPix->devKind * srcy) + (unsigned char*)pPix->devPrivate.ptr;

SECOND_PASS:
	if(TwoPass) {
	    (*infoRec->SetupForCPUToScreenColorExpandFill)(pScrn, 
			(FirstPass) ? bg : fg, -1, rop, planemask);
	    StippleFunc = (FirstPass) ? FirstFunc : SecondFunc;
	}

        (*infoRec->SubsequentCPUToScreenColorExpandFill)(pScrn, ppt->x, ppt->y,
 			*pwidth, 1, 0);

	base = (CARD32*)infoRec->ColorExpandBase;

	(*StippleFunc)(base, (CARD32*)srcp, srcx, stipplewidth, dwords);
    
	if((infoRec->CPUToScreenColorExpandFillFlags & CPU_TRANSFER_PAD_QWORD) 
			&& (dwords & 0x01)) {
	    base = (CARD32*)infoRec->ColorExpandBase;
	    base[0] = 0x00000000;
    	}

	if(TwoPass) {
	   if(FirstPass) {
		FirstPass = FALSE;
		goto SECOND_PASS;
	   } else FirstPass = TRUE;
	}

	ppt++; pwidth++;
     }

    if(infoRec->CPUToScreenColorExpandFillFlags & SYNC_AFTER_COLOR_EXPAND) 
	(*infoRec->Sync)(pScrn);
    else SET_SYNC_FLAG(infoRec);
a368 1

d373 1
a373 1
EXPNAME(XAAFillScanlineColorExpandRects3)(
d375 1
a375 1
EXPNAME(XAAFillScanlineColorExpandRects)(
d377 7
a383 8
   ScrnInfoPtr pScrn,
   int fg, int bg, int rop,
   unsigned int planemask,
   int nBox,
   BoxPtr pBox,
   int xorg, int yorg,
   PixmapPtr pPix
){
d395 6
a400 6
    if(stipplewidth <= 32) {
	if(stipplewidth & (stipplewidth - 1))	
	  funcNo = 1;
	else	
	  funcNo = 0;
    } 
d406 41
a446 70
    if((bg == -1) || 
      (!(infoRec->ScanlineCPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY) &&
      (!(infoRec->ScanlineCPUToScreenColorExpandFillFlags & RGB_EQUAL) ||
      (CHECK_RGB_EQUAL(bg))))) {
#else
    if((bg == -1) || 
      !(infoRec->ScanlineCPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)) {
#endif
	/* one pass */
    } else if((rop == GXcopy) && infoRec->FillSolidRects) {
	/* one pass but we fill background rects first */
	(*infoRec->FillSolidRects)(pScrn, bg, rop, planemask, nBox, pBox);
	bg = -1;
    } else {
	/* gotta do two passes */
	TwoPass = TRUE;
    }

    if(!TwoPass)
	(*infoRec->SetupForScanlineCPUToScreenColorExpandFill)(
				pScrn, fg, bg, rop, planemask);

    while(nBox--) {
#ifdef TRIPLE_BITS
	dwords = (3 * (pBox->x2 - pBox->x1) + 31) >> 5;
#else
	dwords = (pBox->x2 - pBox->x1 + 31) >> 5;
#endif

SECOND_PASS:
	if(TwoPass) {
	    (*infoRec->SetupForScanlineCPUToScreenColorExpandFill)(pScrn, 
			(FirstPass) ? bg : fg, -1, rop, planemask);
	    StippleFunc = (FirstPass) ? FirstFunc : SecondFunc;
	}

	h = pBox->y2 - pBox->y1;

        (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill)(
		pScrn, pBox->x1, pBox->y1, pBox->x2 - pBox->x1, h, 0);

	bufferNo = 0;

	srcy = (pBox->y1 - yorg) % stippleheight;
	if(srcy < 0) srcy += stippleheight;
	srcx = (pBox->x1 - xorg) % stipplewidth;
	if(srcx < 0) srcx += stipplewidth;

	srcp = (srcwidth * srcy) + src;

	while(h--) {
   	    base = (CARD32*)infoRec->ScanlineColorExpandBuffers[bufferNo];
	    (*StippleFunc)(base, (CARD32*)srcp, srcx, stipplewidth, dwords);
	    (*infoRec->SubsequentColorExpandScanline)(pScrn, bufferNo++);
	    if(bufferNo >= infoRec->NumScanlineColorExpandBuffers)
		bufferNo = 0;
	    srcy++;
	    srcp += srcwidth;
	    if (srcy >= stippleheight) {
		srcy = 0;
		srcp = src;
	    }
	}
    
	if(TwoPass) {
	   if(FirstPass) {
		FirstPass = FALSE;
		goto SECOND_PASS;
	   } else FirstPass = TRUE;
	}
d448 45
a492 2
	pBox++;
     }
d494 1
a494 1
     SET_SYNC_FLAG(infoRec);
d499 1
a499 1
EXPNAME(XAAFillScanlineColorExpandSpans3)(
d501 1
a501 1
EXPNAME(XAAFillScanlineColorExpandSpans)(
d503 9
a511 10
   ScrnInfoPtr pScrn,
   int fg, int bg, int rop,
   unsigned int planemask,
   int n,
   DDXPointPtr ppt,
   int *pwidth,
   int fSorted,
   int xorg, int yorg,
   PixmapPtr pPix
){
d521 6
a526 6
    if(stipplewidth <= 32) {
	if(stipplewidth & (stipplewidth - 1))	
	  funcNo = 1;
	else	
	  funcNo = 0;
    } 
d532 4
a535 4
    if((bg == -1) || 
      (!(infoRec->ScanlineCPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY) &&
      (!(infoRec->ScanlineCPUToScreenColorExpandFillFlags & RGB_EQUAL) ||
      (CHECK_RGB_EQUAL(bg))))) {
d537 3
a539 2
    if((bg == -1) || 
      !(infoRec->ScanlineCPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)) {
d541 11
a551 9
	/* one pass */
    } else if((rop == GXcopy) && infoRec->FillSolidSpans) {
	/* one pass but we fill background rects first */
	(*infoRec->FillSolidSpans)(
		pScrn, bg, rop, planemask, n, ppt, pwidth, fSorted);
	bg = -1;
    } else {
	/* gotta do two passes */
	TwoPass = TRUE;
d554 3
a556 4
    if(!TwoPass)
	(*infoRec->SetupForScanlineCPUToScreenColorExpandFill)(
				pScrn, fg, bg, rop, planemask);

d558 1
a558 1
    while(n--) {
d560 1
a560 1
	dwords = (3 * *pwidth + 31) >> 5;
d562 1
a562 1
	dwords = (*pwidth + 31) >> 5;
d565 6
a570 4
	srcy = (ppt->y - yorg) % stippleheight;
	if(srcy < 0) srcy += stippleheight;
	srcx = (ppt->x - xorg) % stipplewidth;
	if(srcx < 0) srcx += stipplewidth;
d572 1
a572 1
	srcp = (pPix->devKind * srcy) + (unsigned char*)pPix->devPrivate.ptr;
d574 9
a582 6
SECOND_PASS:
	if(TwoPass) {
	    (*infoRec->SetupForScanlineCPUToScreenColorExpandFill)(pScrn, 
			(FirstPass) ? bg : fg, -1, rop, planemask);
	    StippleFunc = (FirstPass) ? FirstFunc : SecondFunc;
	}
d584 18
a601 2
        (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill)(
				pScrn, ppt->x, ppt->y, *pwidth, 1, 0);
d603 3
a605 1
	base = (CARD32*)infoRec->ScanlineColorExpandBuffers[0];
d607 1
a607 14
	(*StippleFunc)(base, (CARD32*)srcp, srcx, stipplewidth, dwords);
	(*infoRec->SubsequentColorExpandScanline)(pScrn, 0);
    
	if(TwoPass) {
	   if(FirstPass) {
		FirstPass = FALSE;
		goto SECOND_PASS;
	   } else FirstPass = TRUE;
	}

	ppt++; pwidth++;
     }

     SET_SYNC_FLAG(infoRec);
d613 2
a614 4
StipplePowerOfTwo(
   CARD32* dest, CARD32* src, 
   int shift, int width, int dwords
){
d616 11
a626 10
    if(width < 32) {
	pat &= XAAShiftMasks[width];
	while(width < 32) {
	    pat |= SHIFT_L(pat,width);
	    width <<= 1;
	}
    }
   
    if(shift)
	pat = SHIFT_R(pat,shift) | SHIFT_L(pat,32 - shift);
d629 1
a629 1
    pat = SWAP_BITS_IN_BYTES(pat);    
d634 1
a634 1
	EXPAND_PAT;
d636 20
a655 19
	while(dwords >= 3) {
	    WRITE_PAT3;
	    dwords -= 3;
	}
	if (dwords == 2) {
	    WRITE_PAT2;
	} else if (dwords == 1) {
	    WRITE_PAT1;
	}

	return dest;
    }
#else /* TRIPLE_BITS */
   while(dwords >= 4) {
	DEST(0) = pat;
	DEST(1) = pat;
	DEST(2) = pat;
	DEST(3) = pat;
	dwords -= 4;
d657 1
a657 1
	dest += 4;
d659 13
a671 10
   }
   
   if(!dwords) return dest;
   DEST(0) = pat;
   if(dwords == 1) RETURN(1);
   DEST(1) = pat;
   if(dwords == 2) RETURN(2);
   DEST(2) = pat;
   RETURN(3);
#endif /* TRIPLE_BITS */
d675 3
a677 4
StipplePowerOfTwo_Inverted(
   CARD32* dest, CARD32* src, 
   int shift, int width, int dwords
){
d679 11
a689 10
    if(width < 32) {
	pat &= XAAShiftMasks[width];
	while(width < 32) {
	    pat |= SHIFT_L(pat,width);
	    width <<= 1;
	}
    }
   
    if(shift)
	pat = SHIFT_R(pat,shift) | SHIFT_L(pat,32 - shift);
d692 1
a692 1
    pat = SWAP_BITS_IN_BYTES(pat);    
d695 1
a695 1
   pat = ~pat;
d699 1
a699 1
	EXPAND_PAT;
d701 20
a720 19
	while(dwords >= 3) {
	    WRITE_PAT3;
	    dwords -= 3;
	}
	if (dwords == 2) {
	    WRITE_PAT2;
	} else if (dwords == 1) {
	    WRITE_PAT1;
	}

	return dest;
    }
#else /* TRIPLE_BITS */
   while(dwords >= 4) {
	DEST(0) = pat;
	DEST(1) = pat;
	DEST(2) = pat;
	DEST(3) = pat;
	dwords -= 4;
d722 1
a722 1
	dest += 4;
d724 13
a736 10
   }
   
   if(!dwords) return dest;
   DEST(0) = pat;
   if(dwords == 1) RETURN(1);
   DEST(1) = pat;
   if(dwords == 2) RETURN(2);
   DEST(2) = pat;
   RETURN(3);
#endif /* TRIPLE_BITS */
a738 1

d740 2
a741 4
StippleUpTo32(
   CARD32* base, CARD32* src, 
   int shift, int width, int dwords
){
d744 21
a764 18
    while(width <= 15) {
	pat |= SHIFT_L(pat,width);
	width <<= 1;
    }
    pat |= SHIFT_L(pat,width);

    while(dwords--) {
	CARD32 bits = SHIFT_R(pat,shift) | SHIFT_L(pat,width-shift);
#ifdef TRIPLE_BITS
	if(dwords >= 2) {
	    WRITE_BITS3(bits);
	    dwords -= 2;
	} else if(dwords > 0) {
	    WRITE_BITS2(bits);
	    dwords--;
	} else {
	    WRITE_BITS1(bits);
	}
d766 1
a766 1
	WRITE_BITS(bits);
d769 2
a770 2
	shift += 32;
	shift %= width;
a774 1

d776 3
a778 4
StippleUpTo32_Inverted(
   CARD32* base, CARD32* src, 
   int shift, int width, int dwords
){
d781 21
a801 18
    while(width <= 15) {
	pat |= SHIFT_L(pat,width);
	width <<= 1;
    }
    pat |= SHIFT_L(pat,width);

    while(dwords--) {
	CARD32 bits = ~(SHIFT_R(pat,shift) | SHIFT_L(pat,width-shift));
#ifdef TRIPLE_BITS
	if(dwords >= 2) {
	    WRITE_BITS3(bits);
	    dwords -= 2;
	} else if(dwords > 0) {
	    WRITE_BITS2(bits);
	    dwords--;
	} else {
	    WRITE_BITS1(bits);
	}
d803 1
a803 1
	WRITE_BITS(bits);
d806 2
a807 2
	shift += 32;
	shift %= width;
a811 1

d813 5
a817 7
StippleOver32(
   CARD32* base, CARD32* src, 
   int offset, int width, int dwords
){
   CARD32* srcp;
   CARD32 bits;
   int bitsleft, shift, usable;   
d819 1
a819 1
   while(dwords--) {
d825 9
a833 8
        if(bitsleft < 32) {
            if(bitsleft <= usable) {
                 bits = SHIFT_L(*src,bitsleft) | 
                       (SHIFT_R(*srcp,shift) & XAAShiftMasks[bitsleft]);
            } else {
                 bits = SHIFT_L(*src,bitsleft) |
                       (SHIFT_L(srcp[1],usable) & XAAShiftMasks[bitsleft]) |
                       (SHIFT_R(*srcp,shift) & XAAShiftMasks[usable]);
d836 2
a837 2
        else if(shift)
            bits = SHIFT_R(*srcp,shift) | SHIFT_L(srcp[1],usable);
d842 19
a860 17
	if(dwords >= 2) {
	    WRITE_BITS3(bits);
	    dwords -= 2;
	} else if(dwords > 0) {
	    WRITE_BITS2(bits);
	    dwords--;
	} else {
	    WRITE_BITS1(bits);
	}
#else
	WRITE_BITS(bits);
#endif

	offset += 32;
	offset %= width;
   }
   return base;
a862 1

d864 6
a869 7
StippleOver32_Inverted(
   CARD32* base, CARD32* src, 
   int offset, int width, int dwords
){
   CARD32* srcp;
   CARD32 bits;
   int bitsleft, shift, usable;
d871 1
a871 1
   while(dwords--) {
d877 9
a885 8
        if(bitsleft < 32) {
            if(bitsleft <= usable) {
                 bits = SHIFT_L(*src,bitsleft) |
                       (SHIFT_R(*srcp,shift) & XAAShiftMasks[bitsleft]);
            } else {
                 bits = SHIFT_L(*src,bitsleft) |
                       (SHIFT_L(srcp[1],usable) & XAAShiftMasks[bitsleft]) |
                       (SHIFT_R(*srcp,shift) & XAAShiftMasks[usable]);
d888 2
a889 2
        else if(shift)
            bits = SHIFT_R(*srcp,shift) | SHIFT_L(srcp[1],usable);
d893 1
a893 1
	bits = ~bits;
d896 19
a914 17
	if(dwords >= 2) {
	    WRITE_BITS3(bits);
	    dwords -= 2;
	} else if(dwords > 0) {
	    WRITE_BITS2(bits);
	    dwords--;
	} else {
	    WRITE_BITS1(bits);
	}
#else
	WRITE_BITS(bits);
#endif

	offset += 32;
	offset %= width;
   }
   return base;
@


1.1
log
@Initial revision
@
text
@d108 1
a108 1
void 
d244 1
a244 1
void 
d355 1
a355 1
void 
d468 1
a468 1
void 
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
