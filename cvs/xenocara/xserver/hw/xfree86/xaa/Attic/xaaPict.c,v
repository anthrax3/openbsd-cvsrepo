head	1.6;
access;
symbols
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.06.07.17.28.53;	author matthieu;	state dead;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.43;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@/*
 *
 * Copyright Â© 2000 Keith Packard, member of The XFree86 Project, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <string.h>

#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"

#include <X11/X.h>
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "xf86str.h"
#include "mi.h"
#include "picturestr.h"
#include "glyphstr.h"
#include "picture.h"
#include "mipict.h"
#include "xaa.h"
#include "xaalocal.h"
#include "xaawrap.h"
#include "xaacexp.h"
#include "xf86fbman.h"
#include "servermd.h"

Bool
XAAGetPixelFromRGBA(CARD32 *pixel,
                    CARD16 red,
                    CARD16 green, CARD16 blue, CARD16 alpha, CARD32 format)
{
    int rbits, bbits, gbits, abits;
    int rshift, bshift, gshift, ashift;

    *pixel = 0;

    if (!PICT_FORMAT_COLOR(format))
        return FALSE;

    rbits = PICT_FORMAT_R(format);
    gbits = PICT_FORMAT_G(format);
    bbits = PICT_FORMAT_B(format);
    abits = PICT_FORMAT_A(format);

    if (PICT_FORMAT_TYPE(format) == PICT_TYPE_ARGB) {
        bshift = 0;
        gshift = bbits;
        rshift = gshift + gbits;
        ashift = rshift + rbits;
    }
    else if (PICT_FORMAT_TYPE(format) == PICT_TYPE_ABGR) {
        rshift = 0;
        gshift = rbits;
        bshift = gshift + gbits;
        ashift = bshift + bbits;
    }
    else if (PICT_FORMAT_TYPE(format) == PICT_TYPE_BGRA) {
        bshift = PICT_FORMAT_BPP(format) - bbits;
        gshift = bshift - gbits;
        rshift = gshift - rbits;
        ashift = 0;
    }
    else
        return FALSE;

    *pixel |= (blue >> (16 - bbits)) << bshift;
    *pixel |= (red >> (16 - rbits)) << rshift;
    *pixel |= (green >> (16 - gbits)) << gshift;
    *pixel |= (alpha >> (16 - abits)) << ashift;

    return TRUE;
}

Bool
XAAGetRGBAFromPixel(CARD32 pixel,
                    CARD16 *red,
                    CARD16 *green, CARD16 *blue, CARD16 *alpha, CARD32 format)
{
    int rbits, bbits, gbits, abits;
    int rshift, bshift, gshift, ashift;

    if (!PICT_FORMAT_COLOR(format))
        return FALSE;

    rbits = PICT_FORMAT_R(format);
    gbits = PICT_FORMAT_G(format);
    bbits = PICT_FORMAT_B(format);
    abits = PICT_FORMAT_A(format);

    if (PICT_FORMAT_TYPE(format) == PICT_TYPE_ARGB) {
        bshift = 0;
        gshift = bbits;
        rshift = gshift + gbits;
        ashift = rshift + rbits;
    }
    else if (PICT_FORMAT_TYPE(format) == PICT_TYPE_ABGR) {
        rshift = 0;
        gshift = rbits;
        bshift = gshift + gbits;
        ashift = bshift + bbits;
    }
    else if (PICT_FORMAT_TYPE(format) == PICT_TYPE_BGRA) {
        bshift = PICT_FORMAT_BPP(format) - bbits;
        gshift = bshift - gbits;
        rshift = gshift - rbits;
        ashift = 0;
    }
    else
        return FALSE;

    *red = ((pixel >> rshift) & ((1 << rbits) - 1)) << (16 - rbits);
    while (rbits < 16) {
        *red |= *red >> rbits;
        rbits <<= 1;
    }

    *green = ((pixel >> gshift) & ((1 << gbits) - 1)) << (16 - gbits);
    while (gbits < 16) {
        *green |= *green >> gbits;
        gbits <<= 1;
    }

    *blue = ((pixel >> bshift) & ((1 << bbits) - 1)) << (16 - bbits);
    while (bbits < 16) {
        *blue |= *blue >> bbits;
        bbits <<= 1;
    }

    if (abits) {
        *alpha = ((pixel >> ashift) & ((1 << abits) - 1)) << (16 - abits);
        while (abits < 16) {
            *alpha |= *alpha >> abits;
            abits <<= 1;
        }
    }
    else
        *alpha = 0xffff;

    return TRUE;
}

/* 8:8:8 + PICT_a8 -> 8:8:8:8 texture */

void
XAA_888_plus_PICT_a8_to_8888(CARD32 color, CARD8 *alphaPtr,     /* in bytes */
                             int alphaPitch, CARD32 *dstPtr, int dstPitch,      /* in dwords */
                             int width, int height)
{
    int x;

    color &= 0x00ffffff;

    while (height--) {
        for (x = 0; x < width; x++)
            dstPtr[x] = color | (alphaPtr[x] << 24);
        dstPtr += dstPitch;
        alphaPtr += alphaPitch;
    }
}

#define DRAWABLE_IS_ON_CARD(pDraw) \
    (pDraw->type == DRAWABLE_WINDOW || \
     (pDraw->type == DRAWABLE_PIXMAP && IS_OFFSCREEN_PIXMAP(pDraw)))

Bool
XAADoComposite(CARD8 op,
               PicturePtr pSrc,
               PicturePtr pMask,
               PicturePtr pDst,
               INT16 xSrc,
               INT16 ySrc,
               INT16 xMask,
               INT16 yMask, INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
    RegionRec region;
    CARD32 *formats, *dstformats;
    int flags = 0;
    BoxPtr pbox;
    int nbox, w, h;

    if (!RegionNumRects(pDst->pCompositeClip))
        return TRUE;

    if (!infoRec->pScrn->vtSema || !DRAWABLE_IS_ON_CARD(pDst->pDrawable))
        return FALSE;

    if (DRAWABLE_IS_ON_CARD(pSrc->pDrawable))
        return FALSE;

    if (pSrc->transform || (pMask && pMask->transform))
        return FALSE;

    if (pDst->alphaMap || pSrc->alphaMap || (pMask && pMask->alphaMap))
        return FALSE;

    if ((pSrc->repeat && pSrc->repeatType != RepeatNormal) ||
        (pMask && pMask->repeat && pMask->repeatType != RepeatNormal)) {
        return FALSE;
    }

    xDst += pDst->pDrawable->x;
    yDst += pDst->pDrawable->y;
    xSrc += pSrc->pDrawable->x;
    ySrc += pSrc->pDrawable->y;

    if (pMask) {
        if (pMask->componentAlpha)
            return FALSE;

        /* for now we only do it if there is a 1x1 (solid) source */

        if ((pSrc->pDrawable->width == 1) && (pSrc->pDrawable->height == 1)) {
            CARD16 red, green, blue, alpha;
            CARD32 pixel =
                *((CARD32 *) (((PixmapPtr) (pSrc->pDrawable))->devPrivate.ptr));

            if (!XAAGetRGBAFromPixel
                (pixel, &red, &green, &blue, &alpha, pSrc->format))
                return FALSE;

            xMask += pMask->pDrawable->x;
            yMask += pMask->pDrawable->y;

            /* pull out color expandable operations here */
            if ((pMask->format == PICT_a1) && (alpha == 0xffff) &&
                (op == PictOpOver) && infoRec->WriteBitmap && !pMask->repeat &&
                !(infoRec->WriteBitmapFlags & NO_TRANSPARENCY) &&
                (!(infoRec->WriteBitmapFlags & RGB_EQUAL) ||
                 ((red == green) && (green == blue)))) {
                PixmapPtr pPix = (PixmapPtr) (pMask->pDrawable);
                int skipleft;

                if (!miComputeCompositeRegion(&region, pSrc, pMask, pDst,
                                              xSrc, ySrc, xMask, yMask, xDst,
                                              yDst, width, height))
                    return TRUE;

                nbox = RegionNumRects(&region);
                pbox = RegionRects(&region);

                if (!nbox)
                    return TRUE;

                XAAGetPixelFromRGBA(&pixel, red, green, blue, 0, pDst->format);

                xMask -= xDst;
                yMask -= yDst;

                while (nbox--) {
                    skipleft = pbox->x1 + xMask;

                    (*infoRec->WriteBitmap) (infoRec->pScrn,
                                             pbox->x1, pbox->y1,
                                             pbox->x2 - pbox->x1,
                                             pbox->y2 - pbox->y1,
                                             (unsigned char *) (pPix->
                                                                devPrivate.
                                                                ptr) +
                                             (pPix->devKind *
                                              (pbox->y1 + yMask)) +
                                             ((skipleft >> 3) & ~3),
                                             pPix->devKind, skipleft & 31,
                                             pixel, -1, GXcopy, ~0);
                    pbox++;
                }

                /* WriteBitmap sets the Sync flag */
                RegionUninit(&region);
                return TRUE;
            }

            formats = infoRec->CPUToScreenAlphaTextureFormats;
            dstformats = infoRec->CPUToScreenAlphaTextureDstFormats;
            if (!formats || !dstformats)
                return FALSE;

            w = pMask->pDrawable->width;
            h = pMask->pDrawable->height;

            if (pMask->repeat) {
                if ((infoRec->CPUToScreenAlphaTextureFlags & XAA_RENDER_NO_TILE)
                    ||
                    ((infoRec->
                      CPUToScreenAlphaTextureFlags &
                      XAA_RENDER_POWER_OF_2_TILE_ONLY) && ((h & (h - 1)) ||
                                                           (w & (w - 1))))) {
                    return FALSE;
                }
                flags |= XAA_RENDER_REPEAT;
            }

            if ((alpha != 0xffff) &&
                (infoRec->
                 CPUToScreenAlphaTextureFlags & XAA_RENDER_NO_SRC_ALPHA))
                return FALSE;

            while (*formats != pMask->format) {
                if (!(*formats))
                    return FALSE;
                formats++;
            }
            while (*dstformats != pDst->format) {
                if (!(*dstformats))
                    return FALSE;
                dstformats++;
            }

            if (!miComputeCompositeRegion(&region, pSrc, pMask, pDst,
                                          xSrc, ySrc, xMask, yMask, xDst, yDst,
                                          width, height))
                return TRUE;

            nbox = RegionNumRects(&region);
            pbox = RegionRects(&region);

            if (!nbox) {
                RegionUninit(&region);
                return TRUE;
            }

            if (!(infoRec->SetupForCPUToScreenAlphaTexture2) (infoRec->pScrn,
                                                              op, red, green,
                                                              blue, alpha,
                                                              pMask->format,
                                                              pDst->format,
                                                              ((PixmapPtr)
                                                               (pMask->
                                                                pDrawable))->
                                                              devPrivate.ptr,
                                                              ((PixmapPtr)
                                                               (pMask->
                                                                pDrawable))->
                                                              devKind, w, h,
                                                              flags)) {
                RegionUninit(&region);
                return FALSE;
            }

            xMask -= xDst;
            yMask -= yDst;

            while (nbox--) {
                (*infoRec->SubsequentCPUToScreenAlphaTexture) (infoRec->pScrn,
                                                               pbox->x1,
                                                               pbox->y1,
                                                               pbox->x1 + xMask,
                                                               pbox->y1 + yMask,
                                                               pbox->x2 -
                                                               pbox->x1,
                                                               pbox->y2 -
                                                               pbox->y1);
                pbox++;
            }

            SET_SYNC_FLAG(infoRec);
            RegionUninit(&region);
            return TRUE;
        }
    }
    else {
        formats = infoRec->CPUToScreenTextureFormats;
        dstformats = infoRec->CPUToScreenTextureDstFormats;
        if (!formats || !dstformats)
            return FALSE;

        w = pSrc->pDrawable->width;
        h = pSrc->pDrawable->height;

        if (pSrc->repeat) {
            if ((infoRec->CPUToScreenTextureFlags & XAA_RENDER_NO_TILE) ||
                ((infoRec->CPUToScreenTextureFlags &
                  XAA_RENDER_POWER_OF_2_TILE_ONLY) &&
                 ((h & (h - 1)) || (w & (w - 1))))) {
                return FALSE;
            }
            flags |= XAA_RENDER_REPEAT;
        }

        while (*formats != pSrc->format) {
            if (!(*formats))
                return FALSE;
            formats++;
        }
        while (*dstformats != pDst->format) {
            if (!(*dstformats))
                return FALSE;
            dstformats++;
        }

        if (!miComputeCompositeRegion(&region, pSrc, pMask, pDst,
                                      xSrc, ySrc, xMask, yMask, xDst, yDst,
                                      width, height))
            return TRUE;

        nbox = RegionNumRects(&region);
        pbox = RegionRects(&region);

        if (!nbox) {
            RegionUninit(&region);
            return TRUE;
        }

        if (!(infoRec->SetupForCPUToScreenTexture2) (infoRec->pScrn,
                                                     op, pSrc->format,
                                                     pDst->format,
                                                     ((PixmapPtr)
                                                      (pSrc->pDrawable))->
                                                     devPrivate.ptr,
                                                     ((PixmapPtr)
                                                      (pSrc->pDrawable))->
                                                     devKind, w, h, flags)) {
            RegionUninit(&region);
            return FALSE;
        }

        xSrc -= xDst;
        ySrc -= yDst;

        while (nbox--) {
            (*infoRec->SubsequentCPUToScreenTexture) (infoRec->pScrn,
                                                      pbox->x1, pbox->y1,
                                                      pbox->x1 + xSrc,
                                                      pbox->y1 + ySrc,
                                                      pbox->x2 - pbox->x1,
                                                      pbox->y2 - pbox->y1);
            pbox++;
        }

        SET_SYNC_FLAG(infoRec);
        RegionUninit(&region);
        return TRUE;
    }

    return FALSE;
}

static void
XAACompositeSrcCopy(PicturePtr pSrc,
                    PicturePtr pDst,
                    INT16 xSrc,
                    INT16 ySrc,
                    INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
    int i, nbox;
    int xoff, yoff;
    BoxPtr pbox;
    DDXPointPtr pptSrc;
    RegionRec region;

    xDst += pDst->pDrawable->x;
    yDst += pDst->pDrawable->y;
    xSrc += pSrc->pDrawable->x;
    ySrc += pSrc->pDrawable->y;

    if (!miComputeCompositeRegion(&region, pSrc, NULL, pDst,
                                  xSrc, ySrc, 0, 0, xDst, yDst, width, height))
        return;

    nbox = RegionNumRects(&region);
    pbox = RegionRects(&region);

    if (!nbox) {
        RegionUninit(&region);
        return;
    }
    pptSrc = malloc(sizeof(DDXPointRec) * nbox);
    if (!pptSrc) {
        RegionUninit(&region);
        return;
    }
    xoff = xSrc - xDst;
    yoff = ySrc - yDst;
    for (i = 0; i < nbox; i++) {
        pptSrc[i].x = pbox[i].x1 + xoff;
        pptSrc[i].y = pbox[i].y1 + yoff;
    }

    infoRec->ScratchGC.planemask = ~0L;
    infoRec->ScratchGC.alu = GXcopy;

    XAADoBitBlt(pSrc->pDrawable, pDst->pDrawable, &infoRec->ScratchGC, &region,
                pptSrc);

    free(pptSrc);
    RegionUninit(&region);
    return;
}

void
XAAComposite(CARD8 op,
             PicturePtr pSrc,
             PicturePtr pMask,
             PicturePtr pDst,
             INT16 xSrc,
             INT16 ySrc,
             INT16 xMask,
             INT16 yMask, INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);

    XAA_RENDER_PROLOGUE(pScreen, Composite);

    if (!pMask && infoRec->pScrn->vtSema &&
        infoRec->ScreenToScreenBitBlt &&
        pSrc->pDrawable &&
        DRAWABLE_IS_ON_CARD(pSrc->pDrawable) &&
        DRAWABLE_IS_ON_CARD(pDst->pDrawable) &&
        !pSrc->transform &&
        (!pSrc->repeat || (xSrc >= 0 && ySrc >= 0 &&
                           xSrc + width <= pSrc->pDrawable->width &&
                           ySrc + height <= pSrc->pDrawable->height)) &&
        ((op == PictOpSrc &&
          ((pSrc->format == pDst->format) ||
           (pSrc->format == PICT_a8r8g8b8 && pDst->format == PICT_x8r8g8b8) ||
           (pSrc->format == PICT_a8b8g8r8 && pDst->format == PICT_x8b8g8r8))) ||
         (op == PictOpOver && !pSrc->alphaMap && !pDst->alphaMap &&
          pSrc->format == pDst->format &&
          (pSrc->format == PICT_x8r8g8b8 || pSrc->format == PICT_x8b8g8r8)))) {
        XAACompositeSrcCopy(pSrc, pDst, xSrc, ySrc, xDst, yDst, width, height);
    }
    else if (!pSrc->pDrawable || (pMask && !pMask->pDrawable) ||
             !infoRec->Composite ||
             !(*infoRec->Composite) (op, pSrc, pMask, pDst,
                                     xSrc, ySrc, xMask, yMask, xDst, yDst,
                                     width, height)) {
        if (infoRec->pScrn->vtSema &&
            ((pSrc->pDrawable &&
              (pSrc->pDrawable->type == DRAWABLE_WINDOW ||
               IS_OFFSCREEN_PIXMAP(pSrc->pDrawable))) ||
             pDst->pDrawable->type == DRAWABLE_WINDOW ||
             IS_OFFSCREEN_PIXMAP(pDst->pDrawable))) {
            SYNC_CHECK(pDst->pDrawable);
        }
        (*GetPictureScreen(pScreen)->Composite) (op,
                                                 pSrc,
                                                 pMask,
                                                 pDst,
                                                 xSrc,
                                                 ySrc,
                                                 xMask,
                                                 yMask,
                                                 xDst, yDst, width, height);
    }

    if (pDst->pDrawable->type == DRAWABLE_PIXMAP)
        (XAA_GET_PIXMAP_PRIVATE((PixmapPtr) (pDst->pDrawable)))->flags |= DIRTY;

    XAA_RENDER_EPILOGUE(pScreen, Composite, XAAComposite);
}

Bool
XAADoGlyphs(CARD8 op,
            PicturePtr pSrc,
            PicturePtr pDst,
            PictFormatPtr maskFormat,
            INT16 xSrc,
            INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);

    if (!RegionNumRects(pDst->pCompositeClip))
        return TRUE;

    if (!infoRec->pScrn->vtSema ||
        ((pDst->pDrawable->type != DRAWABLE_WINDOW) &&
         !IS_OFFSCREEN_PIXMAP(pDst->pDrawable)))
        return FALSE;

    if ((pSrc->pDrawable->type != DRAWABLE_PIXMAP) ||
        IS_OFFSCREEN_PIXMAP(pSrc->pDrawable))
        return FALSE;

    /*
     * If it looks like we have a chance of being able to draw these
     * glyphs with an accelerated Composite, do that now to avoid
     * unneeded and costly syncs.
     */
    if (maskFormat) {
        if (!infoRec->CPUToScreenAlphaTextureFormats)
            return FALSE;
    }
    else {
        if (!infoRec->CPUToScreenTextureFormats)
            return FALSE;
    }

    miGlyphs(op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, list, glyphs);

    return TRUE;
}

void
XAAGlyphs(CARD8 op,
          PicturePtr pSrc,
          PicturePtr pDst,
          PictFormatPtr maskFormat,
          INT16 xSrc,
          INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);

    XAA_RENDER_PROLOGUE(pScreen, Glyphs);

    if (!pSrc->pDrawable || !infoRec->Glyphs ||
        !(*infoRec->Glyphs) (op, pSrc, pDst, maskFormat,
                             xSrc, ySrc, nlist, list, glyphs)) {
        if (infoRec->pScrn->vtSema &&
            ((pSrc->pDrawable &&
              (pSrc->pDrawable->type == DRAWABLE_WINDOW ||
               IS_OFFSCREEN_PIXMAP(pSrc->pDrawable))) ||
             pDst->pDrawable->type == DRAWABLE_WINDOW ||
             IS_OFFSCREEN_PIXMAP(pDst->pDrawable))) {
            SYNC_CHECK(pDst->pDrawable);
        }
        (*GetPictureScreen(pScreen)->Glyphs) (op, pSrc, pDst, maskFormat,
                                              xSrc, ySrc, nlist, list, glyphs);
    }

    if (pDst->pDrawable->type == DRAWABLE_PIXMAP)
        (XAA_GET_PIXMAP_PRIVATE((PixmapPtr) (pDst->pDrawable)))->flags |= DIRTY;

    XAA_RENDER_EPILOGUE(pScreen, Glyphs, XAAGlyphs);
}
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d52 4
a55 8
XAAGetPixelFromRGBA (
    CARD32 *pixel,
    CARD16 red,
    CARD16 green,
    CARD16 blue,
    CARD16 alpha,
    CARD32 format
){
d61 3
a63 3
    if(!PICT_FORMAT_COLOR(format))
    	return FALSE;
	
d68 2
a69 2
    
    if(PICT_FORMAT_TYPE(format) == PICT_TYPE_ARGB) {
d72 4
a75 3
	rshift = gshift + gbits;
	ashift = rshift + rbits;
    } else if(PICT_FORMAT_TYPE(format) == PICT_TYPE_ABGR) {
d77 17
a93 15
	gshift = rbits;
	bshift = gshift + gbits;
	ashift = bshift + bbits;
    } else if(PICT_FORMAT_TYPE(format) == PICT_TYPE_BGRA) {
	bshift = PICT_FORMAT_BPP(format) - bbits;
	gshift = bshift - gbits;
	rshift = gshift - rbits;
	ashift = 0;
    } else
	return FALSE;
    
    *pixel |=  ( blue >> (16 - bbits)) << bshift;
    *pixel |=  (  red >> (16 - rbits)) << rshift;
    *pixel |=  (green >> (16 - gbits)) << gshift;
    *pixel |=  (alpha >> (16 - abits)) << ashift;
a97 1

d99 4
a102 8
XAAGetRGBAFromPixel(
    CARD32 pixel,
    CARD16 *red,
    CARD16 *green,
    CARD16 *blue,
    CARD16 *alpha,
    CARD32 format
){
d105 4
a108 4
    
    if(!PICT_FORMAT_COLOR(format))
    	return FALSE;
	
d113 2
a114 2
    
    if(PICT_FORMAT_TYPE(format) == PICT_TYPE_ARGB) {
d117 4
a120 3
	rshift = gshift + gbits;
	ashift = rshift + rbits;
    } else if(PICT_FORMAT_TYPE(format) == PICT_TYPE_ABGR) {
d122 41
a162 37
	gshift = rbits;
	bshift = gshift + gbits;
	ashift = bshift + bbits;
    } else if(PICT_FORMAT_TYPE(format) == PICT_TYPE_BGRA) {
	bshift = PICT_FORMAT_BPP(format) - bbits;
	gshift = bshift - gbits;
	rshift = gshift - rbits;
	ashift = 0;
    } else
	return FALSE;
 
    *red = ((pixel >> rshift ) & ((1 << rbits) - 1)) << (16 - rbits);
    while(rbits < 16) {
       *red |= *red >> rbits;
       rbits <<= 1;
    }
    
    *green = ((pixel >> gshift ) & ((1 << gbits) - 1)) << (16 - gbits);
    while(gbits < 16) {
       *green |= *green >> gbits;
       gbits <<= 1;
    }
        
    *blue = ((pixel >> bshift ) & ((1 << bbits) - 1)) << (16 - bbits);
    while(bbits < 16) {
       *blue |= *blue >> bbits;
       bbits <<= 1;
    }  
    
    if(abits) {
       *alpha = ((pixel >> ashift ) & ((1 << abits) - 1)) << (16 - abits);
       while(abits < 16) {
          *alpha |= *alpha >> abits;
          abits <<= 1;
       }     
    } else *alpha = 0xffff;
      
d169 4
a172 9
XAA_888_plus_PICT_a8_to_8888 (
    CARD32 color,
    CARD8  *alphaPtr,   /* in bytes */
    int    alphaPitch,
    CARD32  *dstPtr,
    int    dstPitch,	/* in dwords */
    int    width,
    int    height
){
d177 6
a182 6
    while(height--) {
	for(x = 0; x < width; x++)
	   dstPtr[x] = color | (alphaPtr[x] << 24);
	dstPtr += dstPitch;
	alphaPtr += alphaPitch;
    } 
d190 9
a198 14
XAADoComposite (
    CARD8      op,
    PicturePtr pSrc,
    PicturePtr pMask,
    PicturePtr pDst,
    INT16      xSrc,
    INT16      ySrc,
    INT16      xMask,
    INT16      yMask,
    INT16      xDst,
    INT16      yDst,
    CARD16     width,
    CARD16     height
){
d207 1
a207 1
    if(!RegionNumRects(pDst->pCompositeClip))
d210 2
a211 2
    if(!infoRec->pScrn->vtSema || !DRAWABLE_IS_ON_CARD(pDst->pDrawable))
	return FALSE;
d213 2
a214 2
    if(DRAWABLE_IS_ON_CARD(pSrc->pDrawable))
	return FALSE;
d217 1
a217 1
	return FALSE;
d220 1
a220 1
	return FALSE;
d223 2
a224 3
	(pMask && pMask->repeat && pMask->repeatType != RepeatNormal))
    {
	return FALSE;
d232 62
a293 103
    if(pMask) {
	if(pMask->componentAlpha)
	    return FALSE;
 
	/* for now we only do it if there is a 1x1 (solid) source */

	if((pSrc->pDrawable->width == 1) && (pSrc->pDrawable->height == 1)) {
	   CARD16 red, green, blue, alpha;
           CARD32 pixel =
                *((CARD32*)(((PixmapPtr)(pSrc->pDrawable))->devPrivate.ptr));

	   if(!XAAGetRGBAFromPixel(pixel,&red,&green,&blue,&alpha,pSrc->format))
		return FALSE;

	   xMask += pMask->pDrawable->x;
	   yMask += pMask->pDrawable->y;	
		
	   /* pull out color expandable operations here */
	   if((pMask->format == PICT_a1) && (alpha == 0xffff) &&
	       (op == PictOpOver) && infoRec->WriteBitmap && !pMask->repeat &&
	       !(infoRec->WriteBitmapFlags & NO_TRANSPARENCY) &&
	       (!(infoRec->WriteBitmapFlags & RGB_EQUAL) || 
	         ((red == green) && (green == blue))))
	   {
	        PixmapPtr pPix = (PixmapPtr)(pMask->pDrawable);
		int skipleft;
		        
	  	if (!miComputeCompositeRegion (&region, pSrc, pMask, pDst,
                                   xSrc, ySrc, xMask, yMask, xDst, yDst,
                                   width, height))
		      return TRUE;
		      
		nbox = RegionNumRects(&region);
		pbox = RegionRects(&region);
		
	        if(!nbox)
		    return TRUE;	
		    
	        XAAGetPixelFromRGBA(&pixel, red, green, blue, 0, pDst->format);
		    
	   	xMask -= xDst;
	   	yMask -= yDst;

	   	while(nbox--) {
		    skipleft = pbox->x1 + xMask;
		    
	            (*infoRec->WriteBitmap)(infoRec->pScrn,
			        pbox->x1, pbox->y1, 
			        pbox->x2 - pbox->x1, pbox->y2 - pbox->y1,
			        (unsigned char*)(pPix->devPrivate.ptr) + 
				  (pPix->devKind * (pbox->y1 + yMask)) + 
			          ((skipleft >> 3) & ~3), pPix->devKind, 
				skipleft & 31, pixel, -1, GXcopy, ~0);
	            pbox++;
	   	}
				  
		/* WriteBitmap sets the Sync flag */		  
	        RegionUninit(&region);
		return TRUE;
	  }

	  formats = infoRec->CPUToScreenAlphaTextureFormats;
	  dstformats = infoRec->CPUToScreenAlphaTextureDstFormats;
	  if(!formats || !dstformats)
		return FALSE;

	  w = pMask->pDrawable->width;
	  h = pMask->pDrawable->height;

	  if(pMask->repeat) {
	      if((infoRec->CPUToScreenAlphaTextureFlags & XAA_RENDER_NO_TILE) ||
		   ((infoRec->CPUToScreenAlphaTextureFlags & 
                                   XAA_RENDER_POWER_OF_2_TILE_ONLY) && 
				((h & (h - 1)) || (w & (w - 1)))))
	      {
		 return FALSE;
	      }
	      flags |= XAA_RENDER_REPEAT;
	  } 

	  if((alpha != 0xffff) &&
              (infoRec->CPUToScreenAlphaTextureFlags & XAA_RENDER_NO_SRC_ALPHA))
		return FALSE;

	  while(*formats != pMask->format) {
		if(!(*formats)) return FALSE;
		formats++;
          }
	  while(*dstformats != pDst->format) {
		if(!(*dstformats))
		    return FALSE;
		dstformats++;
          }

	  if (!miComputeCompositeRegion (&region, pSrc, pMask, pDst,
                                   xSrc, ySrc, xMask, yMask, xDst, yDst,
                                   width, height))
		return TRUE;

	  nbox = RegionNumRects(&region);
	  pbox = RegionRects(&region);
	     
	  if(!nbox) {
d295 43
a337 2
		return TRUE;
	  }
d339 4
a342 7
	  if(!(infoRec->SetupForCPUToScreenAlphaTexture2)(infoRec->pScrn,
			op, red, green, blue, alpha, pMask->format,
			pDst->format,
			((PixmapPtr)(pMask->pDrawable))->devPrivate.ptr,
			((PixmapPtr)(pMask->pDrawable))->devKind, 
			w, h, flags))
	  {
d344 2
a345 2
		return FALSE;
	  }
d347 44
a390 20
	   xMask -= xDst;
	   yMask -= yDst;
	
	   while(nbox--) {
	      (*infoRec->SubsequentCPUToScreenAlphaTexture)(infoRec->pScrn,
			pbox->x1, pbox->y1, 
			pbox->x1 + xMask, pbox->y1 + yMask,
			pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
	      pbox++;
	   }

	   SET_SYNC_FLAG(infoRec);
	   RegionUninit(&region);
	   return TRUE;
	}
    } else {
	formats = infoRec->CPUToScreenTextureFormats;
	dstformats = infoRec->CPUToScreenTextureDstFormats;
	if(!formats || !dstformats)
	    return FALSE;
d395 19
a413 9
        if(pSrc->repeat) {
              if((infoRec->CPUToScreenTextureFlags & XAA_RENDER_NO_TILE) ||
                   ((infoRec->CPUToScreenTextureFlags &
                                   XAA_RENDER_POWER_OF_2_TILE_ONLY) &&
                                ((h & (h - 1)) || (w & (w - 1)))))
              {
                 return FALSE;
              }
              flags |= XAA_RENDER_REPEAT;
d416 11
a426 21
	while(*formats != pSrc->format) {
	    if(!(*formats)) return FALSE;
	    formats++;
	}
	while(*dstformats != pDst->format) {
	    if(!(*dstformats))
		return FALSE;
	    dstformats++;
	}

	if (!miComputeCompositeRegion (&region, pSrc, pMask, pDst,
                                   xSrc, ySrc, xMask, yMask, xDst, yDst,
                                   width, height))
		return TRUE;

	nbox = RegionNumRects(&region);
	pbox = RegionRects(&region);
	     
        if(!nbox) {
             RegionUninit(&region);
             return TRUE;
d429 11
a439 8
	if(!(infoRec->SetupForCPUToScreenTexture2)(infoRec->pScrn,
			op, pSrc->format, pDst->format, 
			((PixmapPtr)(pSrc->pDrawable))->devPrivate.ptr,
			((PixmapPtr)(pSrc->pDrawable))->devKind, 
			w, h, flags))
        {
              RegionUninit(&region);
              return FALSE;
d442 12
d455 3
a457 14
	xSrc -= xDst;
	ySrc -= yDst;
	
	while(nbox--) {
	    (*infoRec->SubsequentCPUToScreenTexture)(infoRec->pScrn,
			pbox->x1, pbox->y1, 
			pbox->x1 + xSrc, pbox->y1 + ySrc,
			pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
	    pbox++;
	 }

	SET_SYNC_FLAG(infoRec);
	RegionUninit(&region);
	return TRUE;
a459 1

d464 5
a468 8
XAACompositeSrcCopy (PicturePtr pSrc,
		     PicturePtr pDst,
		     INT16      xSrc,
		     INT16      ySrc,
		     INT16      xDst,
		     INT16      yDst,
		     CARD16     width,
		     CARD16     height)
d470 1
a470 1
    ScreenPtr	pScreen = pDst->pDrawable->pScreen;
d483 3
a485 4
    if (!miComputeCompositeRegion (&region, pSrc, NULL, pDst,
				   xSrc, ySrc, 0, 0, xDst, yDst,
				   width, height))
	return;
d490 3
a492 3
    if(!nbox) {
	RegionUninit(&region);
	return;
d496 2
a497 2
	RegionUninit(&region);
	return;
d502 2
a503 2
	pptSrc[i].x = pbox[i].x1 + xoff;
	pptSrc[i].y = pbox[i].y1 + yoff; 
d510 1
a510 1
		pptSrc);
d518 8
a525 12
XAAComposite (CARD8      op,
	      PicturePtr pSrc,
	      PicturePtr pMask,
	      PicturePtr pDst,
	      INT16      xSrc,
	      INT16      ySrc,
	      INT16      xMask,
	      INT16      yMask,
	      INT16      xDst,
	      INT16      yDst,
	      CARD16     width,
	      CARD16     height)
d527 1
a527 1
    ScreenPtr	pScreen = pDst->pDrawable->pScreen;
d529 1
d532 21
a552 21
    if(!pMask && infoRec->pScrn->vtSema &&
       infoRec->ScreenToScreenBitBlt &&
       pSrc->pDrawable &&
       DRAWABLE_IS_ON_CARD(pSrc->pDrawable) &&
       DRAWABLE_IS_ON_CARD(pDst->pDrawable) &&
       !pSrc->transform &&
       (!pSrc->repeat || (xSrc >= 0 && ySrc >= 0 &&
			  xSrc+width<=pSrc->pDrawable->width &&
			  ySrc+height<=pSrc->pDrawable->height)) &&
       ((op == PictOpSrc &&
	 ((pSrc->format==pDst->format) ||
	  (pSrc->format==PICT_a8r8g8b8 && pDst->format==PICT_x8r8g8b8) ||
	  (pSrc->format==PICT_a8b8g8r8 && pDst->format==PICT_x8b8g8r8))) ||
	(op == PictOpOver && !pSrc->alphaMap && !pDst->alphaMap &&
	 pSrc->format==pDst->format &&
	 (pSrc->format==PICT_x8r8g8b8 || pSrc->format==PICT_x8b8g8r8))))
    {
	XAACompositeSrcCopy(pSrc, pDst, xSrc, ySrc, xDst, yDst, width, height);
    } else if(!pSrc->pDrawable || (pMask && !pMask->pDrawable) ||
              !infoRec->Composite ||
              !(*infoRec->Composite)(op, pSrc, pMask, pDst,
d554 7
a560 6
                                     width, height))
    {
        if(infoRec->pScrn->vtSema &&
           ((pSrc->pDrawable &&
             (pSrc->pDrawable->type == DRAWABLE_WINDOW || IS_OFFSCREEN_PIXMAP(pSrc->pDrawable))) ||
            pDst->pDrawable->type == DRAWABLE_WINDOW || IS_OFFSCREEN_PIXMAP(pDst->pDrawable))) {
d564 8
a571 11
		       pSrc,
		       pMask,
		       pDst,
		       xSrc,
		       ySrc,
		       xMask,
		       yMask,
		       xDst,
		       yDst,
		       width,
		       height);    
d574 2
a575 2
    if(pDst->pDrawable->type == DRAWABLE_PIXMAP)
	(XAA_GET_PIXMAP_PRIVATE((PixmapPtr)(pDst->pDrawable)))->flags |= DIRTY;
d581 6
a586 9
XAADoGlyphs (CARD8         op,
	   PicturePtr    pSrc,
	   PicturePtr    pDst,
	   PictFormatPtr maskFormat,
	   INT16         xSrc,
	   INT16         ySrc,
	   int           nlist,
	   GlyphListPtr  list,
	   GlyphPtr      *glyphs)
d588 1
a588 1
    ScreenPtr	pScreen = pDst->pDrawable->pScreen;
d591 2
a592 2
    if(!RegionNumRects(pDst->pCompositeClip))
	return TRUE;
d594 4
a597 4
    if(!infoRec->pScrn->vtSema || 
      ((pDst->pDrawable->type != DRAWABLE_WINDOW) &&
	!IS_OFFSCREEN_PIXMAP(pDst->pDrawable)))
	return FALSE;
d599 1
a599 1
    if((pSrc->pDrawable->type != DRAWABLE_PIXMAP) ||
d608 2
a609 2
    if(maskFormat) {
        if(!infoRec->CPUToScreenAlphaTextureFormats)
d611 3
a613 2
    } else {
        if(!infoRec->CPUToScreenTextureFormats)
d620 2
a621 3
}	   
	 
	
d623 6
a628 9
XAAGlyphs (CARD8         op,
	   PicturePtr    pSrc,
	   PicturePtr    pDst,
	   PictFormatPtr maskFormat,
	   INT16         xSrc,
	   INT16         ySrc,
	   int           nlist,
	   GlyphListPtr  list,
	   GlyphPtr      *glyphs)
d630 1
a630 1
    ScreenPtr	pScreen = pDst->pDrawable->pScreen;
d632 1
d635 9
a643 8
    if(!pSrc->pDrawable || !infoRec->Glyphs ||
       !(*infoRec->Glyphs)(op, pSrc, pDst, maskFormat,
                           xSrc, ySrc, nlist, list, glyphs))
    {
        if(infoRec->pScrn->vtSema &&
           ((pSrc->pDrawable &&
             (pSrc->pDrawable->type == DRAWABLE_WINDOW || IS_OFFSCREEN_PIXMAP(pSrc->pDrawable))) ||
            pDst->pDrawable->type == DRAWABLE_WINDOW || IS_OFFSCREEN_PIXMAP(pDst->pDrawable))) {
d646 2
a647 2
       (*GetPictureScreen(pScreen)->Glyphs) (op, pSrc, pDst, maskFormat,
					  xSrc, ySrc, nlist, list, glyphs);
d650 2
a651 2
    if(pDst->pDrawable->type == DRAWABLE_PIXMAP)
	(XAA_GET_PIXMAP_PRIVATE((PixmapPtr)(pDst->pDrawable)))->flags |= DIRTY;
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d218 1
a218 1
    if(!REGION_NUM_RECTS(pDst->pCompositeClip))
d276 2
a277 2
	  	nbox = REGION_NUM_RECTS(&region);
	  	pbox = REGION_RECTS(&region);   
d301 1
a301 1
	        REGION_UNINIT(pScreen, &region);
d343 2
a344 2
	  nbox = REGION_NUM_RECTS(&region);
	  pbox = REGION_RECTS(&region);   
d347 1
a347 1
                REGION_UNINIT(pScreen, &region);
d358 1
a358 1
                REGION_UNINIT(pScreen, &region);
d374 1
a374 1
	   REGION_UNINIT(pScreen, &region);
d412 2
a413 2
	nbox = REGION_NUM_RECTS(&region);
	pbox = REGION_RECTS(&region);   
d416 1
a416 1
             REGION_UNINIT(pScreen, &region);
d426 1
a426 1
              REGION_UNINIT(pScreen, &region);
d443 1
a443 1
	REGION_UNINIT(pScreen, &region);
d479 2
a480 2
    nbox = REGION_NUM_RECTS(&region);
    pbox = REGION_RECTS(&region);   
d483 1
a483 1
	REGION_UNINIT(pScreen, &region);
d486 1
a486 1
    pptSrc = xalloc(sizeof(DDXPointRec) * nbox);
d488 1
a488 1
	REGION_UNINIT(pScreen, &region);
d504 2
a505 2
    xfree(pptSrc);
    REGION_UNINIT(pScreen, &region);
d591 1
a591 1
    if(!REGION_NUM_RECTS(pDst->pCompositeClip))
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d78 1
a78 1
    } else {  /* PICT_TYPE_ABGR */
d83 7
a89 1
    }
d125 1
a125 1
    } else {  /* PICT_TYPE_ABGR */
d130 7
a136 1
    }
@


1.1
log
@Initial revision
@
text
@d474 1
a474 1
    pptSrc = ALLOCATE_LOCAL(sizeof(DDXPointRec) * nbox);
d492 1
a492 1
    DEALLOCATE_LOCAL(pptSrc);
a589 144

    if(maskFormat && (maskFormat->depth == 1) && 
       (pSrc->pDrawable->width == 1) && (pSrc->pDrawable->height == 1) &&
       (op == PictOpOver) && infoRec->WriteBitmap &&
       !(infoRec->WriteBitmapFlags & NO_TRANSPARENCY))
    {
	CARD16 red, green, blue, alpha;
	CARD32 pixel =
                *((CARD32*)(((PixmapPtr)(pSrc->pDrawable))->devPrivate.ptr));
	CARD32 *bits, *pntr, *pnt;
	int x, y, i, n, left, top, right, bottom, width, height, pitch;
	int L, T, R, B, X, Y, h, w, dwords, row, column, nbox;
	int leftEdge, rightEdge, topLine, botLine;
	BoxPtr pbox;
	GlyphPtr glyph;
	
	if(!XAAGetRGBAFromPixel(pixel,&red,&green,&blue,&alpha,pSrc->format))
		return FALSE;

	if(alpha != 0xffff) return FALSE;

	XAAGetPixelFromRGBA(&pixel, red, green, blue, 0, pDst->format);

	if((infoRec->WriteBitmapFlags & RGB_EQUAL) && !((red == green) && (green == blue)))
	   return FALSE;

	x = pDst->pDrawable->x;
	y = pDst->pDrawable->y;

	while(nlist--) {
	    x += list->xOff;
	    y += list->yOff;
	    left = right = X = x;
	    top = bottom = Y = y;
	    for(i = 0; i < list->len; i++) {
		glyph = glyphs[i];

		L = X - glyph->info.x;
		if(L < left) left = L;
		R = L + glyph->info.width;
		if(R > right) right = R;

		T = Y - glyph->info.y;
		if(T < top) top = T;
		B = T + glyph->info.height;
		if(B > bottom) bottom = B;

		X += glyph->info.xOff;
		Y += glyph->info.yOff;
	    }

	    width = right - left;
	    height = bottom - top;

	    if(width && height) {
		pitch = (((width + 31) & ~31) >> 5) + 1;
		pntr = (CARD32*)xalloc(sizeof(CARD32) * pitch * height);
		if(!pntr) 
		    return TRUE;
		bzero(pntr, sizeof(CARD32) * pitch * height);
		n = list->len;

		X = x; Y = y;
		while(n--) {
		    glyph = *glyphs++;
		    h = glyph->info.height;
		    w = glyph->info.width;
		    if(h && w) {
			row = y - top - glyph->info.y;
			column = x - left - glyph->info.x;
			pnt = pntr + (row * pitch) + (column >> 5);
			column &= 31;
			dwords = ((w + 31) >> 5) - 1;
			bits = (CARD32*)(glyph + 1);
			if(dwords) {
			  while(h--) {
			    for(i = 0; i <= dwords; i++) {
				if(column) {
				    pnt[i] |= SHIFT_L(*bits, column);
				    pnt[i + 1] |= SHIFT_R(*bits, 32 - column);
				} else
				    pnt[i] |= *bits;

				if(i != dwords) bits++;
			    }
			    bits++;
			    pnt += pitch;
			  } 
			} else {
			  if(column) {
			     while(h--) {
				pnt[0] |= SHIFT_L(*bits, column);
				pnt[0 + 1] |= SHIFT_R(*bits, 32 - column);
				bits++;
				pnt += pitch;
			     }
			  } else {
			     while(h--) {
				*pnt |= *bits++;
				pnt += pitch;
			     }			  
			  }	  
			}
		    }
		    x += glyph->info.xOff;
		    y += glyph->info.yOff;
		}
		
		nbox = REGION_NUM_RECTS(pDst->pCompositeClip);
		pbox = REGION_RECTS(pDst->pCompositeClip);
		
		while(nbox && (top >= pbox->y2)) {
		    pbox++; nbox--;
		}
		
		while(nbox && (bottom > pbox->y1)) {		
		    leftEdge = max(left, pbox->x1);
		    rightEdge = min(right, pbox->x2);
		    
		    if(rightEdge > leftEdge) {
		    	column = leftEdge - left;
			topLine = max(top, pbox->y1);
			botLine = min(bottom, pbox->y2);
			h = botLine - topLine;
			
			if(h > 0) {
			  (*infoRec->WriteBitmap)(infoRec->pScrn, 
			  	leftEdge, topLine, rightEdge - leftEdge, h,
				(unsigned char*)(pntr + 
				  ((topLine - top) * pitch) + (column >> 5)),
				pitch << 2, column & 31, pixel, -1, GXcopy, ~0);
			}
		    }	
		    nbox--; pbox++;
	   	}
		xfree(pntr);
	    } else {
		x = X; y = Y;
	    }
	    list++;
	}

	return TRUE;
    }
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
