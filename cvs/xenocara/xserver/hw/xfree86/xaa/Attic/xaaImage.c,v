head	1.5;
access;
symbols
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.06.07.17.28.53;	author matthieu;	state dead;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.48;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.48;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"
#include "servermd.h"

#include <X11/X.h>
#include "scrnintstr.h"
#include "mi.h"
#include "pixmapstr.h"
#include "xf86str.h"
#include "xaa.h"
#include "xaalocal.h"

void
XAAMoveDWORDS_FixedBase(register CARD32 *dest,
                        register CARD32 *src, register int dwords)
{
    while (dwords & ~0x03) {
        *dest = *src;
        *dest = *(src + 1);
        *dest = *(src + 2);
        *dest = *(src + 3);
        dwords -= 4;
        src += 4;
    }

    if (!dwords)
        return;
    *dest = *src;
    if (dwords == 1)
        return;
    *dest = *(src + 1);
    if (dwords == 2)
        return;
    *dest = *(src + 2);
}

void
XAAMoveDWORDS(register CARD32 *dest, register CARD32 *src, register int dwords)
{
    while (dwords & ~0x03) {
        *dest = *src;
        *(dest + 1) = *(src + 1);
        *(dest + 2) = *(src + 2);
        *(dest + 3) = *(src + 3);
        src += 4;
        dest += 4;
        dwords -= 4;
    }
    if (!dwords)
        return;
    *dest = *src;
    if (dwords == 1)
        return;
    *(dest + 1) = *(src + 1);
    if (dwords == 2)
        return;
    *(dest + 2) = *(src + 2);
}

void
XAAMoveDWORDS_FixedSrc(register CARD32 *dest,
                       register CARD32 *src, register int dwords)
{
    while (dwords & ~0x03) {
        *dest = *src;
        *(dest + 1) = *src;
        *(dest + 2) = *src;
        *(dest + 3) = *src;
        dest += 4;
        dwords -= 4;
    }
    if (!dwords)
        return;
    *dest = *src;
    if (dwords == 1)
        return;
    *(dest + 1) = *src;
    if (dwords == 2)
        return;
    *(dest + 2) = *src;
}

static void
XAAWritePixmap32To24(ScrnInfoPtr pScrn, int x, int y, int w, int h, unsigned char *srcInit, int srcwidth,       /* bytes */
                     int rop, unsigned int planemask, int trans)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int count, dwords = bytes_to_int32(w * 3);
    CARD32 *src, *dst;
    Bool PlusOne = FALSE;

    if ((infoRec->ImageWriteFlags & CPU_TRANSFER_PAD_QWORD) &&
        ((dwords * h) & 0x01)) {
        PlusOne = TRUE;
    }

    (*infoRec->SetupForImageWrite) (pScrn, rop, planemask, trans, 24, 24);
    (*infoRec->SubsequentImageWriteRect) (pScrn, x, y, w, h, 0);

    if (dwords > infoRec->ImageWriteRange) {
        dst = (CARD32 *) infoRec->ImageWriteBase;
        while (h--) {
            src = (CARD32 *) srcInit;
            count = w;

            while (count >= 4) {
                *dst = (src[0] & 0x00ffffff) | (src[1] << 24);
                *dst = ((src[1] >> 8) & 0x0000ffff) | (src[2] << 16);
                *dst = ((src[2] >> 16) & 0x000000ff) | (src[3] << 8);
                src += 4;
                count -= 4;
            }
            switch (count) {
            case 0:
                break;
            case 1:
                *dst = src[0];
                break;
            case 2:
                *dst = (src[0] & 0x00ffffff) | (src[1] << 24);
                *dst = src[1] >> 8;
                break;
            default:
                *dst = (src[0] & 0x00ffffff) | (src[1] << 24);
                *dst = ((src[1] >> 8) & 0x0000ffff) | (src[2] << 16);
                *dst = src[2] >> 16;
                break;
            }
            srcInit += srcwidth;
        }
    }
    else {
        while (h--) {
            dst = (CARD32 *) infoRec->ImageWriteBase;
            src = (CARD32 *) srcInit;
            count = w;

            while (count >= 4) {
                dst[0] = (src[0] & 0x00ffffff) | (src[1] << 24);
                dst[1] = ((src[1] >> 8) & 0x0000ffff) | (src[2] << 16);
                dst[2] = ((src[2] >> 16) & 0x000000ff) | (src[3] << 8);
                dst += 3;
                src += 4;
                count -= 4;
            }
            switch (count) {
            case 0:
                break;
            case 1:
                dst[0] = src[0];
                break;
            case 2:
                dst[0] = (src[0] & 0x00ffffff) | (src[1] << 24);
                dst[1] = src[1] >> 8;
                break;
            default:
                dst[0] = (src[0] & 0x00ffffff) | (src[1] << 24);
                dst[1] = ((src[1] >> 8) & 0x0000ffff) | (src[2] << 16);
                dst[2] = src[2] >> 16;
                break;
            }
            srcInit += srcwidth;
        }
    }

    if (PlusOne) {
        CARD32 *base = (CARD32 *) infoRec->ImageWriteBase;

        *base = 0x00000000;
    }

    if (infoRec->ImageWriteFlags & SYNC_AFTER_IMAGE_WRITE)
        (*infoRec->Sync) (pScrn);
    else
        SET_SYNC_FLAG(infoRec);

}

void
XAAWritePixmap(ScrnInfoPtr pScrn, int x, int y, int w, int h, unsigned char *src, int srcwidth, /* bytes */
               int rop, unsigned int planemask, int trans, int bpp, int depth)
{
    XAAInfoRecPtr infoRec;
    int dwords, skipleft, Bpp;
    Bool beCareful, PlusOne;

    if ((bpp == 32) && (pScrn->bitsPerPixel == 24)) {
        XAAWritePixmap32To24(pScrn, x, y, w, h, src, srcwidth,
                             rop, planemask, trans);
        return;
    }

    infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    beCareful = PlusOne = FALSE;
    Bpp = bpp >> 3;

    if ((skipleft = (long) src & 0x03L)) {
        if (!(infoRec->ImageWriteFlags & LEFT_EDGE_CLIPPING)) {
            skipleft = 0;
            beCareful = TRUE;
            goto BAD_ALIGNMENT;
        }

        if (Bpp == 3)
            skipleft = 4 - skipleft;
        else
            skipleft /= Bpp;

        if ((x < skipleft) && !(infoRec->ImageWriteFlags &
                                LEFT_EDGE_CLIPPING_NEGATIVE_X)) {
            skipleft = 0;
            beCareful = TRUE;
            goto BAD_ALIGNMENT;
        }

        x -= skipleft;
        w += skipleft;

        if (Bpp == 3)
            src -= 3 * skipleft;
        else                    /* is this Alpha friendly ? */
            src = (unsigned char *) ((long) src & ~0x03L);
    }

 BAD_ALIGNMENT:

    dwords = bytes_to_int32(w * Bpp);

    if ((infoRec->ImageWriteFlags & CPU_TRANSFER_PAD_QWORD) &&
        ((dwords * h) & 0x01)) {
        PlusOne = TRUE;
    }

    (*infoRec->SetupForImageWrite) (pScrn, rop, planemask, trans, bpp, depth);
    (*infoRec->SubsequentImageWriteRect) (pScrn, x, y, w, h, skipleft);

    if (beCareful) {
        /* in cases with bad alignment we have to be careful not
           to read beyond the end of the source */
        if (((x * Bpp) + (dwords << 2)) > srcwidth)
            h--;
        else
            beCareful = FALSE;
    }

    if (dwords > infoRec->ImageWriteRange) {
        while (h--) {
            XAAMoveDWORDS_FixedBase((CARD32 *) infoRec->ImageWriteBase,
                                    (CARD32 *) src, dwords);
            src += srcwidth;
        }
        if (beCareful) {
            int shift = ((long) src & 0x03L) << 3;

            if (--dwords)
                XAAMoveDWORDS_FixedBase((CARD32 *) infoRec->ImageWriteBase,
                                        (CARD32 *) src, dwords);
            src = (unsigned char *) ((long) (src + (dwords << 2)) & ~0x03L);
            *((CARD32 *) infoRec->ImageWriteBase) = *((CARD32 *) src) >> shift;
        }
    }
    else {
        if (srcwidth == (dwords << 2)) {
            int decrement = infoRec->ImageWriteRange / dwords;

            while (h > decrement) {
                XAAMoveDWORDS((CARD32 *) infoRec->ImageWriteBase,
                              (CARD32 *) src, dwords * decrement);
                src += (srcwidth * decrement);
                h -= decrement;
            }
            if (h) {
                XAAMoveDWORDS((CARD32 *) infoRec->ImageWriteBase,
                              (CARD32 *) src, dwords * h);
                if (beCareful)
                    src += (srcwidth * h);
            }
        }
        else {
            while (h--) {
                XAAMoveDWORDS((CARD32 *) infoRec->ImageWriteBase,
                              (CARD32 *) src, dwords);
                src += srcwidth;
            }
        }

        if (beCareful) {
            int shift = ((long) src & 0x03L) << 3;

            if (--dwords)
                XAAMoveDWORDS((CARD32 *) infoRec->ImageWriteBase,
                              (CARD32 *) src, dwords);
            src = (unsigned char *) ((long) (src + (dwords << 2)) & ~0x03L);

            ((CARD32 *) infoRec->ImageWriteBase)[dwords] =
                *((CARD32 *) src) >> shift;
        }
    }

    if (PlusOne) {
        CARD32 *base = (CARD32 *) infoRec->ImageWriteBase;

        *base = 0x00000000;
    }

    if (infoRec->ImageWriteFlags & SYNC_AFTER_IMAGE_WRITE)
        (*infoRec->Sync) (pScrn);
    else
        SET_SYNC_FLAG(infoRec);
}

void
XAAWritePixmapScanline(ScrnInfoPtr pScrn, int x, int y, int w, int h, unsigned char *src, int srcwidth, /* bytes */
                       int rop,
                       unsigned int planemask, int trans, int bpp, int depth)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int dwords, skipleft, bufferNo = 0, Bpp = bpp >> 3;
    Bool beCareful = FALSE;
    CARD32 *base;

    if ((skipleft = (long) src & 0x03L)) {
        if (!(infoRec->ScanlineImageWriteFlags & LEFT_EDGE_CLIPPING)) {
            skipleft = 0;
            beCareful = TRUE;
            goto BAD_ALIGNMENT;
        }

        if (Bpp == 3)
            skipleft = 4 - skipleft;
        else
            skipleft /= Bpp;

        if ((x < skipleft) && !(infoRec->ScanlineImageWriteFlags &
                                LEFT_EDGE_CLIPPING_NEGATIVE_X)) {
            skipleft = 0;
            beCareful = TRUE;
            goto BAD_ALIGNMENT;
        }

        x -= skipleft;
        w += skipleft;

        if (Bpp == 3)
            src -= 3 * skipleft;
        else
            src = (unsigned char *) ((long) src & ~0x03L);
    }

 BAD_ALIGNMENT:

    dwords = bytes_to_int32(w * Bpp);

    (*infoRec->SetupForScanlineImageWrite) (pScrn, rop, planemask, trans, bpp,
                                            depth);
    (*infoRec->SubsequentScanlineImageWriteRect) (pScrn, x, y, w, h, skipleft);

    if (beCareful) {
        /* in cases with bad alignment we have to be careful not
           to read beyond the end of the source */
        if (((x * Bpp) + (dwords << 2)) > srcwidth)
            h--;
        else
            beCareful = FALSE;
    }

    while (h--) {
        base = (CARD32 *) infoRec->ScanlineImageWriteBuffers[bufferNo];
        XAAMoveDWORDS(base, (CARD32 *) src, dwords);
        (*infoRec->SubsequentImageWriteScanline) (pScrn, bufferNo++);
        src += srcwidth;
        if (bufferNo >= infoRec->NumScanlineImageWriteBuffers)
            bufferNo = 0;
    }

    if (beCareful) {
        int shift = ((long) src & 0x03L) << 3;

        base = (CARD32 *) infoRec->ScanlineImageWriteBuffers[bufferNo];
        if (--dwords)
            XAAMoveDWORDS(base, (CARD32 *) src, dwords);
        src = (unsigned char *) ((long) (src + (dwords << 2)) & ~0x03L);

        base[dwords] = *((CARD32 *) src) >> shift;
        (*infoRec->SubsequentImageWriteScanline) (pScrn, bufferNo);
    }

    SET_SYNC_FLAG(infoRec);
}

void
XAAPutImage(DrawablePtr pDraw,
            GCPtr pGC,
            int depth,
            int x, int y, int w, int h, int leftPad, int format, char *pImage)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    int bpp = BitsPerPixel(depth);
    Bool depthBug = FALSE;

    if (!w || !h)
        return;

    if (!RegionNumRects(pGC->pCompositeClip))
        return;

    depthBug = XAA_DEPTH_BUG(pGC);

    if (((format == ZPixmap) && infoRec->WritePixmap &&
         ((pDraw->bitsPerPixel == bpp) ||
          ((pDraw->bitsPerPixel == 24) && (bpp == 32) &&
           (infoRec->WritePixmapFlags & CONVERT_32BPP_TO_24BPP))) &&
         CHECK_ROP(pGC, infoRec->WritePixmapFlags) &&
         CHECK_ROPSRC(pGC, infoRec->WritePixmapFlags) &&
         CHECK_PLANEMASK(pGC, infoRec->WritePixmapFlags) &&
         CHECK_NO_GXCOPY(pGC, infoRec->WritePixmapFlags)) ||
        ((format == XYBitmap) && !depthBug && infoRec->WriteBitmap &&
         CHECK_ROP(pGC, infoRec->WriteBitmapFlags) &&
         CHECK_ROPSRC(pGC, infoRec->WriteBitmapFlags) &&
         CHECK_PLANEMASK(pGC, infoRec->WriteBitmapFlags) &&
         CHECK_COLORS(pGC, infoRec->WriteBitmapFlags) &&
         !(infoRec->WriteBitmapFlags & TRANSPARENCY_ONLY)) ||
        ((format == XYPixmap) && !depthBug && infoRec->WriteBitmap &&
         CHECK_ROP(pGC, infoRec->WriteBitmapFlags) &&
         CHECK_ROPSRC(pGC, infoRec->WriteBitmapFlags) &&
         !(infoRec->WriteBitmapFlags & NO_PLANEMASK) &&
         !(infoRec->WriteBitmapFlags & TRANSPARENCY_ONLY))) {

        int MaxBoxes = RegionNumRects(pGC->pCompositeClip);
        BoxPtr pbox, pClipBoxes;
        int nboxes, srcx, srcy, srcwidth;
        xRectangle TheRect;

        TheRect.x = pDraw->x + x;
        TheRect.y = pDraw->y + y;
        TheRect.width = w;
        TheRect.height = h;

        if (MaxBoxes > (infoRec->PreAllocSize / sizeof(BoxRec))) {
            pClipBoxes = malloc(MaxBoxes * sizeof(BoxRec));
            if (!pClipBoxes)
                return;
        }
        else
            pClipBoxes = (BoxPtr) infoRec->PreAllocMem;

        nboxes = XAAGetRectClipBoxes(pGC, pClipBoxes, 1, &TheRect);
        pbox = pClipBoxes;

        if (format == XYBitmap) {
            srcwidth = BitmapBytePad(leftPad + w);
            while (nboxes--) {
                srcx = pbox->x1 - TheRect.x + leftPad;
                srcy = pbox->y1 - TheRect.y;
                (*infoRec->WriteBitmap) (infoRec->pScrn, pbox->x1, pbox->y1,
                                         pbox->x2 - pbox->x1,
                                         pbox->y2 - pbox->y1,
                                         (unsigned char *) pImage +
                                         (srcwidth * srcy) + ((srcx >> 5) << 2),
                                         srcwidth, srcx & 31, pGC->fgPixel,
                                         pGC->bgPixel, pGC->alu,
                                         pGC->planemask);
                pbox++;
            }
        }
        else if (format == ZPixmap) {
            int Bpp = bpp >> 3;

            srcwidth = PixmapBytePad(leftPad + w, depth);
            while (nboxes--) {
                srcx = pbox->x1 - TheRect.x + leftPad;
                srcy = pbox->y1 - TheRect.y;
                (*infoRec->WritePixmap) (infoRec->pScrn, pbox->x1, pbox->y1,
                                         pbox->x2 - pbox->x1,
                                         pbox->y2 - pbox->y1,
                                         (unsigned char *) pImage +
                                         (srcwidth * srcy) + (srcx * Bpp),
                                         srcwidth, pGC->alu, pGC->planemask, -1,
                                         Bpp << 3, depth);
                pbox++;
            }
        }
        else {                  /* XYPixmap */
            int depth = pGC->depth;
            int numBox, increment;
            unsigned long i, mask;
            BoxPtr pntBox;

            srcwidth = BitmapBytePad(w + leftPad);
            increment = h * srcwidth;
            i = 1 << (depth - 1);
            mask = ~0;

            if ((infoRec->pScrn->overlayFlags & OVERLAY_8_32_PLANAR) &&
                (pGC->depth == 8)) {
                i = 0x80000000;
                mask = 0xff000000;
            }

            for (; i & mask; i >>= 1, pImage += increment) {
                if (i & pGC->planemask) {
                    pntBox = pbox;
                    numBox = nboxes;
                    while (numBox--) {
                        srcx = pntBox->x1 - TheRect.x + leftPad;
                        srcy = pntBox->y1 - TheRect.y;
                        (*infoRec->WriteBitmap) (infoRec->pScrn,
                                                 pntBox->x1, pntBox->y1,
                                                 pntBox->x2 - pntBox->x1,
                                                 pntBox->y2 - pntBox->y1,
                                                 (unsigned char *) pImage +
                                                 (srcwidth * srcy) +
                                                 ((srcx >> 5) << 2), srcwidth,
                                                 srcx & 31, ~0, 0, pGC->alu, i);
                        pntBox++;
                    }
                }
            }

        }

        if (pClipBoxes != (BoxPtr) infoRec->PreAllocMem)
            free(pClipBoxes);
    }
    else
        XAAFallbackOps.PutImage(pDraw, pGC, depth, x, y, w, h, leftPad,
                                format, pImage);
}
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d19 3
a21 4
void XAAMoveDWORDS_FixedBase(
   register CARD32* dest,
   register CARD32* src,
   register int dwords )
d23 18
a40 15
     while(dwords & ~0x03) {
	 *dest = *src;
	 *dest = *(src + 1);
	 *dest = *(src + 2);
	 *dest = *(src + 3);	
	 dwords -= 4;
	 src += 4;
     }

     if(!dwords) return;
     *dest = *src;
     if(dwords == 1) return;
     *dest = *(src + 1);
     if(dwords == 2) return;
     *dest = *(src + 2);
d43 2
a44 4
void XAAMoveDWORDS(
   register CARD32* dest,
   register CARD32* src,
   register int dwords )
d46 18
a63 15
     while(dwords & ~0x03) {
	*dest = *src;
	*(dest + 1) = *(src + 1);
	*(dest + 2) = *(src + 2);
	*(dest + 3) = *(src + 3);
	src += 4;
	dest += 4;
	dwords -= 4;
     }	
     if(!dwords) return;
     *dest = *src;
     if(dwords == 1) return;
     *(dest + 1) = *(src + 1);
     if(dwords == 2) return;
     *(dest + 2) = *(src + 2);
d66 3
a68 4
void XAAMoveDWORDS_FixedSrc(
   register CARD32* dest,
   register CARD32* src,
   register int dwords )
d70 17
a86 14
     while(dwords & ~0x03) {
	*dest = *src;
	*(dest + 1) = *src;
	*(dest + 2) = *src;
	*(dest + 3) = *src;
	dest += 4;
	dwords -= 4;
     }	
     if(!dwords) return;
     *dest = *src;
     if(dwords == 1) return;
     *(dest + 1) = *src;
     if(dwords == 2) return;
     *(dest + 2) = *src;
d90 3
a92 9
XAAWritePixmap32To24(
   ScrnInfoPtr pScrn,
   int x, int y, int w, int h,
   unsigned char *srcInit,	
   int srcwidth,	/* bytes */
   int rop,
   unsigned int planemask,
   int trans
){
d98 84
a181 73
    if((infoRec->ImageWriteFlags & CPU_TRANSFER_PAD_QWORD) && 
					((dwords * h) & 0x01)) {
	PlusOne = TRUE;
    }

    (*infoRec->SetupForImageWrite)(pScrn, rop, planemask, trans, 24, 24);
    (*infoRec->SubsequentImageWriteRect)(pScrn, x, y, w, h, 0);
  
    if(dwords > infoRec->ImageWriteRange) {
	dst = (CARD32*)infoRec->ImageWriteBase;
	while(h--) {
	    src = (CARD32*)srcInit;
  	    count = w;

	    while(count >= 4) {
		*dst = (src[0] & 0x00ffffff) | (src[1] << 24);
		*dst = ((src[1] >> 8) & 0x0000ffff) | (src[2] << 16);
		*dst = ((src[2] >> 16) & 0x000000ff) | (src[3] << 8);
		src += 4;
		count -= 4;
	    }
	    switch(count) {
	    case 0:	break;
	    case 1:	*dst = src[0];
			break;
	    case 2:	*dst = (src[0] & 0x00ffffff) | (src[1] << 24);
			*dst = src[1] >> 8;
			break;
	    default:	*dst = (src[0] & 0x00ffffff) | (src[1] << 24);
			*dst = ((src[1] >> 8) & 0x0000ffff) | (src[2] << 16);
			*dst = src[2] >> 16;
			break;
	    }
	    srcInit += srcwidth;
	}
    } else {
	while(h--) {
	    dst = (CARD32*)infoRec->ImageWriteBase;
	    src = (CARD32*)srcInit;
  	    count = w;

	    while(count >= 4) {
		dst[0] = (src[0] & 0x00ffffff) | (src[1] << 24);
		dst[1] = ((src[1] >> 8) & 0x0000ffff) | (src[2] << 16);
		dst[2] = ((src[2] >> 16) & 0x000000ff) | (src[3] << 8);
		dst += 3;
		src += 4;
		count -= 4;
	    }
	    switch(count) {
	    case 0:	break;
	    case 1:	dst[0] = src[0];
			break;
	    case 2:	dst[0] = (src[0] & 0x00ffffff) | (src[1] << 24);
			dst[1] = src[1] >> 8;
			break;
	    default:	dst[0] = (src[0] & 0x00ffffff) | (src[1] << 24);
			dst[1] = ((src[1] >> 8) & 0x0000ffff) | (src[2] << 16);
			dst[2] = src[2] >> 16;
			break;
	    }
	    srcInit += srcwidth;
	}
    }

    if(PlusOne) {
	CARD32* base = (CARD32*)infoRec->ImageWriteBase;
	*base = 0x00000000;
    }

    if(infoRec->ImageWriteFlags & SYNC_AFTER_IMAGE_WRITE)
	(*infoRec->Sync)(pScrn);
    else SET_SYNC_FLAG(infoRec);
d186 3
a188 10
XAAWritePixmap (
   ScrnInfoPtr pScrn,
   int x, int y, int w, int h,
   unsigned char *src,	
   int srcwidth,	/* bytes */
   int rop,
   unsigned int planemask,
   int trans,
   int bpp, int depth
){
d190 1
a190 1
    int dwords, skipleft, Bpp; 
d193 4
a196 4
    if((bpp == 32) && (pScrn->bitsPerPixel == 24)) {
	XAAWritePixmap32To24(pScrn, x, y, w, h, src, srcwidth, 
						rop, planemask, trans);	
	return;
d203 26
a228 26
    if((skipleft = (long)src & 0x03L)) {
	if(!(infoRec->ImageWriteFlags & LEFT_EDGE_CLIPPING)) {
	   skipleft = 0;
	   beCareful = TRUE;
	   goto BAD_ALIGNMENT;
	}

	if(Bpp == 3)
	   skipleft = 4 - skipleft;
	else
	   skipleft /= Bpp;

	if((x < skipleft) && !(infoRec->ImageWriteFlags &
				 LEFT_EDGE_CLIPPING_NEGATIVE_X)) {
	   skipleft = 0;
	   beCareful = TRUE;
	   goto BAD_ALIGNMENT;
	}

	x -= skipleft;	     
	w += skipleft;
	
	if(Bpp == 3)
	   src -= 3 * skipleft;  
	else   /* is this Alpha friendly ? */
	   src = (unsigned char*)((long)src & ~0x03L);     
d231 1
a231 1
BAD_ALIGNMENT:
d235 81
a315 73
    if((infoRec->ImageWriteFlags & CPU_TRANSFER_PAD_QWORD) && 
						((dwords * h) & 0x01)) {
	PlusOne = TRUE;
    } 
		
	
    (*infoRec->SetupForImageWrite)(pScrn, rop, planemask, trans, bpp, depth);
    (*infoRec->SubsequentImageWriteRect)(pScrn, x, y, w, h, skipleft);

    if(beCareful) {
	/* in cases with bad alignment we have to be careful not
	   to read beyond the end of the source */
	if(((x * Bpp) + (dwords << 2)) > srcwidth) h--;
	else beCareful = FALSE;
    }

    if(dwords > infoRec->ImageWriteRange) {
	while(h--) {
	    XAAMoveDWORDS_FixedBase((CARD32*)infoRec->ImageWriteBase,
		(CARD32*)src, dwords);
	    src += srcwidth;
	}
	if(beCareful) {
	   int shift = ((long)src & 0x03L) << 3;
	   if(--dwords)
		XAAMoveDWORDS_FixedBase((CARD32*)infoRec->ImageWriteBase,
			(CARD32*)src, dwords);
	   src = (unsigned char*)((long)(src + (dwords << 2)) & ~0x03L);
	   *((CARD32*)infoRec->ImageWriteBase) = *((CARD32*)src) >> shift;
	}
    } else {
	if(srcwidth == (dwords << 2)) {
	   int decrement = infoRec->ImageWriteRange/dwords;

	   while(h > decrement) {
		XAAMoveDWORDS((CARD32*)infoRec->ImageWriteBase,
	 		(CARD32*)src, dwords * decrement);
		src += (srcwidth * decrement);
		h -= decrement;
	   }
	   if(h) {
		XAAMoveDWORDS((CARD32*)infoRec->ImageWriteBase,
	 		(CARD32*)src, dwords * h);
		if(beCareful) src += (srcwidth * h);
	   }
	} else {
	    while(h--) {
		XAAMoveDWORDS((CARD32*)infoRec->ImageWriteBase,
	 		(CARD32*)src, dwords);
		src += srcwidth;
	    }
	}

	if(beCareful) {
	    int shift = ((long)src & 0x03L) << 3;
	    if(--dwords)
		XAAMoveDWORDS((CARD32*)infoRec->ImageWriteBase,
					(CARD32*)src, dwords);
	    src = (unsigned char*)((long)(src + (dwords << 2)) & ~0x03L);
     
	    ((CARD32*)infoRec->ImageWriteBase)[dwords] = 
			*((CARD32*)src) >> shift;
	}
    }

    if(PlusOne) {
	CARD32* base = (CARD32*)infoRec->ImageWriteBase;
	*base = 0x00000000;
    }

    if(infoRec->ImageWriteFlags & SYNC_AFTER_IMAGE_WRITE)
	(*infoRec->Sync)(pScrn);
    else SET_SYNC_FLAG(infoRec);
a317 1

d319 4
a322 10
XAAWritePixmapScanline (
   ScrnInfoPtr pScrn,
   int x, int y, int w, int h,
   unsigned char *src,	
   int srcwidth,	/* bytes */
   int rop,
   unsigned int planemask,
   int trans,
   int bpp, int depth
){
d324 1
a324 1
    int dwords, skipleft, bufferNo = 0, Bpp = bpp >> 3; 
d326 1
a326 1
    CARD32* base;
d328 26
a353 26
    if((skipleft = (long)src & 0x03L)) {
	if(!(infoRec->ScanlineImageWriteFlags & LEFT_EDGE_CLIPPING)) {
	   skipleft = 0;
	   beCareful = TRUE;
	   goto BAD_ALIGNMENT;
	}

	if(Bpp == 3)
	   skipleft = 4 - skipleft;
	else
	   skipleft /= Bpp;

	if((x < skipleft) && !(infoRec->ScanlineImageWriteFlags &
				 LEFT_EDGE_CLIPPING_NEGATIVE_X)) {
	   skipleft = 0;
	   beCareful = TRUE;
	   goto BAD_ALIGNMENT;
	}

	x -= skipleft;	     
	w += skipleft;
	
	if(Bpp == 3)
	   src -= 3 * skipleft;  
	else
	   src = (unsigned char*)((long)src & ~0x03L);     
d356 1
a356 1
BAD_ALIGNMENT:
d360 32
a391 29
    (*infoRec->SetupForScanlineImageWrite)(
				pScrn, rop, planemask, trans, bpp, depth);
    (*infoRec->SubsequentScanlineImageWriteRect)(pScrn, x, y, w, h, skipleft);

    if(beCareful) {
	/* in cases with bad alignment we have to be careful not
	   to read beyond the end of the source */
	if(((x * Bpp) + (dwords << 2)) > srcwidth) h--;
	else beCareful = FALSE;
    }

    while(h--) {
	base = (CARD32*)infoRec->ScanlineImageWriteBuffers[bufferNo];
	XAAMoveDWORDS(base, (CARD32*)src, dwords);
	(*infoRec->SubsequentImageWriteScanline)(pScrn, bufferNo++);
	src += srcwidth;
	if(bufferNo >= infoRec->NumScanlineImageWriteBuffers)
	    bufferNo = 0;
    }

    if(beCareful) {
	int shift = ((long)src & 0x03L) << 3;
	base = (CARD32*)infoRec->ScanlineImageWriteBuffers[bufferNo];
	if(--dwords)
	    XAAMoveDWORDS(base,(CARD32*)src, dwords);
	src = (unsigned char*)((long)(src + (dwords << 2)) & ~0x03L);
     
	base[dwords] = *((CARD32*)src) >> shift;
	(*infoRec->SubsequentImageWriteScanline)(pScrn, bufferNo);
a396 1

d398 5
a402 12
XAAPutImage(
    DrawablePtr pDraw,
    GCPtr       pGC,
    int         depth, 
    int 	x, 
    int		y, 
    int		w, 
    int		h,
    int         leftPad,
    int         format,
    char        *pImage
){
a405 1
    if(!w || !h) return;
d407 5
a411 2
    if(!RegionNumRects(pGC->pCompositeClip))
	return;
d415 119
a533 107
    if(((format == ZPixmap) && infoRec->WritePixmap &&
	     ((pDraw->bitsPerPixel == bpp) ||
		((pDraw->bitsPerPixel == 24) &&  (bpp == 32) &&
		(infoRec->WritePixmapFlags & CONVERT_32BPP_TO_24BPP))) &&
	     CHECK_ROP(pGC,infoRec->WritePixmapFlags) &&
	     CHECK_ROPSRC(pGC,infoRec->WritePixmapFlags) &&
	     CHECK_PLANEMASK(pGC,infoRec->WritePixmapFlags) &&
	     CHECK_NO_GXCOPY(pGC,infoRec->WritePixmapFlags)) ||
       ((format == XYBitmap) && !depthBug && infoRec->WriteBitmap &&
	     CHECK_ROP(pGC,infoRec->WriteBitmapFlags) &&
	     CHECK_ROPSRC(pGC,infoRec->WriteBitmapFlags) &&
	     CHECK_PLANEMASK(pGC,infoRec->WriteBitmapFlags) &&
	     CHECK_COLORS(pGC,infoRec->WriteBitmapFlags) &&
	     !(infoRec->WriteBitmapFlags & TRANSPARENCY_ONLY)) ||
       ((format == XYPixmap) && !depthBug && infoRec->WriteBitmap &&
	     CHECK_ROP(pGC,infoRec->WriteBitmapFlags) &&
	     CHECK_ROPSRC(pGC,infoRec->WriteBitmapFlags) &&
	     !(infoRec->WriteBitmapFlags & NO_PLANEMASK) &&
	     !(infoRec->WriteBitmapFlags & TRANSPARENCY_ONLY))){

	int MaxBoxes = RegionNumRects(pGC->pCompositeClip);
	BoxPtr pbox, pClipBoxes;
	int nboxes, srcx, srcy, srcwidth;
	xRectangle TheRect;

	TheRect.x = pDraw->x + x;
	TheRect.y = pDraw->y + y;
	TheRect.width = w;
	TheRect.height = h; 

	if(MaxBoxes > (infoRec->PreAllocSize/sizeof(BoxRec))) {
	    pClipBoxes = malloc(MaxBoxes * sizeof(BoxRec));
	    if(!pClipBoxes) return;	
	} else pClipBoxes = (BoxPtr)infoRec->PreAllocMem;

	nboxes = XAAGetRectClipBoxes(pGC, pClipBoxes, 1, &TheRect);
	pbox = pClipBoxes;

	if(format == XYBitmap) {
	    srcwidth = BitmapBytePad(leftPad + w);
	    while(nboxes--) {
		srcx = pbox->x1 - TheRect.x + leftPad;
		srcy = pbox->y1 - TheRect.y;
		(*infoRec->WriteBitmap)(infoRec->pScrn, pbox->x1, pbox->y1, 
			pbox->x2 - pbox->x1, pbox->y2 - pbox->y1, 
			(unsigned char*)pImage + 
				(srcwidth * srcy) + ((srcx >> 5) << 2), 
			srcwidth, srcx & 31, pGC->fgPixel, pGC->bgPixel,
	 		pGC->alu, pGC->planemask);
		pbox++;
	    }
        } else if(format == ZPixmap) {
	    int Bpp = bpp >> 3;
	    srcwidth = PixmapBytePad(leftPad + w, depth);
	    while(nboxes--) {
		srcx = pbox->x1 - TheRect.x + leftPad;
		srcy = pbox->y1 - TheRect.y;
		(*infoRec->WritePixmap)(infoRec->pScrn, pbox->x1, pbox->y1, 
			pbox->x2 - pbox->x1, pbox->y2 - pbox->y1, 
			(unsigned char*)pImage + 
				(srcwidth * srcy) + (srcx * Bpp), 
			srcwidth, pGC->alu, pGC->planemask, -1, 
			Bpp << 3, depth);
		pbox++;
	    }
	} else { /* XYPixmap */
	    int depth = pGC->depth;
	    int numBox, increment;
	    unsigned long i, mask;
	    BoxPtr pntBox;
	    
	    srcwidth = BitmapBytePad(w + leftPad);
	    increment = h * srcwidth;
 	    i = 1 << (depth - 1);
	    mask = ~0;

	    if((infoRec->pScrn->overlayFlags & OVERLAY_8_32_PLANAR) &&
							 (pGC->depth == 8)){
		i = 0x80000000;  mask = 0xff000000;
	    }

	    for(; i & mask; i >>= 1, pImage += increment) {
		if(i & pGC->planemask) {
		    pntBox = pbox;
		    numBox = nboxes;
		    while(numBox--) {
			srcx = pntBox->x1 - TheRect.x + leftPad;
			srcy = pntBox->y1 - TheRect.y;
			(*infoRec->WriteBitmap)(infoRec->pScrn, 
				pntBox->x1, pntBox->y1, 
				pntBox->x2 - pntBox->x1, 
				pntBox->y2 - pntBox->y1, 
				(unsigned char*)pImage + 
				(srcwidth * srcy) + ((srcx >> 5) << 2), 
				srcwidth, srcx & 31, ~0, 0, pGC->alu, i);
			pntBox++;
	    	    }
		}
	    }

	}

	if(pClipBoxes != (BoxPtr)infoRec->PreAllocMem)
	    free(pClipBoxes);
    } else 
	XAAFallbackOps.PutImage(pDraw, pGC, depth, x, y, w, h, leftPad, 
				format, pImage);
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d409 1
a409 1
    if(!REGION_NUM_RECTS(pGC->pCompositeClip))
d434 1
a434 1
	int MaxBoxes = REGION_NUM_RECTS(pGC->pCompositeClip);
d445 1
a445 1
	    pClipBoxes = xalloc(MaxBoxes * sizeof(BoxRec));
d517 1
a517 1
	    xfree(pClipBoxes);
@


1.1
log
@Initial revision
@
text
@d95 1
a95 1
    int count, dwords = ((w * 3) + 3) >> 2;
d175 1
a175 1
void 
d230 1
a230 1
    dwords = ((w * Bpp) + 3) >> 2;
d308 1
a308 1
void 
d354 1
a354 1
    dwords = ((w * Bpp) + 3) >> 2;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
