head	1.6;
access;
symbols
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.06.07.17.28.53;	author matthieu;	state dead;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.27;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.28;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.47;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@
/********************************************************************

   In this file we have GC level replacements for PolyText8/16,
   ImageText8/16, ImageGlyphBlt and PolyGlyphBlt for NonTE (proportional) 
   fonts. The idea is that everything in this file is device independent.
   The mentioned GCOps are merely wrappers for the 
   PolyGlyphBltNonTEColorExpansion and ImageGlyphBltNonTEColorExpansion
   functions which calculate the boxes containing arbitrarily clipped 
   text and passes them to the NonTEGlyphRenderer which will usually 
   be a lower level XAA function which renders these clipped glyphs using
   the basic color expansion functions exported by the chipset driver.
   The NonTEGlyphRenderer itself may optionally be driver supplied to
   facilitate work-arounds/optimizations at a higher level than usual.

   Written by Mark Vojkovich (mvojkovi@@ucsd.edu)

********************************************************************/

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <string.h>

#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"

#include <X11/X.h>
#include <X11/fonts/font.h>
#include "scrnintstr.h"
#include "dixfontstr.h"
#include "xf86str.h"
#include "xaa.h"
#include "xaacexp.h"
#include "xaalocal.h"
#include "gcstruct.h"
#include "pixmapstr.h"

static void ImageGlyphBltNonTEColorExpansion(ScrnInfoPtr pScrn,
                                             int xInit, int yInit, FontPtr font,
                                             int fg, int bg, unsigned planemask,
                                             RegionPtr cclip, int nglyph,
                                             unsigned char *gBase,
                                             CharInfoPtr * ppci);
static int PolyGlyphBltNonTEColorExpansion(ScrnInfoPtr pScrn, int xInit,
                                           int yInit, FontPtr font, int fg,
                                           int rop, unsigned planemask,
                                           RegionPtr cclip, int nglyph,
                                           unsigned char *gBase,
                                           CharInfoPtr * ppci);

/********************************************************************

   GC level replacements for PolyText8/16 and ImageText8/16
   for NonTE fonts when using color expansion.

********************************************************************/

int
XAAPolyText8NonTEColorExpansion(DrawablePtr pDraw,
                                GCPtr pGC, int x, int y, int count, char *chars)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    unsigned long n;
    int width = 0;

    (*pGC->font->get_glyphs) (pGC->font, (unsigned long) count,
                              (unsigned char *) chars, Linear8Bit, &n,
                              infoRec->CharInfo);

    if (n) {
        width = PolyGlyphBltNonTEColorExpansion(infoRec->pScrn,
                                                x + pDraw->x, y + pDraw->y,
                                                pGC->font, pGC->fgPixel,
                                                pGC->alu, pGC->planemask,
                                                pGC->pCompositeClip, n,
                                                FONTGLYPHS(pGC->font),
                                                infoRec->CharInfo);
    }

    return x + width;
}

int
XAAPolyText16NonTEColorExpansion(DrawablePtr pDraw,
                                 GCPtr pGC,
                                 int x, int y, int count, unsigned short *chars)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    unsigned long n;
    int width = 0;

    (*pGC->font->get_glyphs) (pGC->font, (unsigned long) count,
                              (unsigned char *) chars,
                              (FONTLASTROW(pGC->font) ==
                               0) ? Linear16Bit : TwoD16Bit, &n,
                              infoRec->CharInfo);

    if (n) {
        width = PolyGlyphBltNonTEColorExpansion(infoRec->pScrn,
                                                x + pDraw->x, y + pDraw->y,
                                                pGC->font, pGC->fgPixel,
                                                pGC->alu, pGC->planemask,
                                                pGC->pCompositeClip, n,
                                                FONTGLYPHS(pGC->font),
                                                infoRec->CharInfo);
    }

    return x + width;
}

void
XAAImageText8NonTEColorExpansion(DrawablePtr pDraw,
                                 GCPtr pGC,
                                 int x, int y, int count, char *chars)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    unsigned long n;

    if (!RegionNumRects(pGC->pCompositeClip))
        return;

    (*pGC->font->get_glyphs) (pGC->font, (unsigned long) count,
                              (unsigned char *) chars, Linear8Bit, &n,
                              infoRec->CharInfo);

    if (n)
        ImageGlyphBltNonTEColorExpansion(infoRec->pScrn, x + pDraw->x,
                                         y + pDraw->y, pGC->font, pGC->fgPixel,
                                         pGC->bgPixel, pGC->planemask,
                                         pGC->pCompositeClip, n,
                                         FONTGLYPHS(pGC->font),
                                         infoRec->CharInfo);
}

void
XAAImageText16NonTEColorExpansion(DrawablePtr pDraw,
                                  GCPtr pGC,
                                  int x,
                                  int y, int count, unsigned short *chars)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    unsigned long n;

    if (!RegionNumRects(pGC->pCompositeClip))
        return;

    (*pGC->font->get_glyphs) (pGC->font, (unsigned long) count,
                              (unsigned char *) chars,
                              (FONTLASTROW(pGC->font) ==
                               0) ? Linear16Bit : TwoD16Bit, &n,
                              infoRec->CharInfo);

    if (n)
        ImageGlyphBltNonTEColorExpansion(infoRec->pScrn, x + pDraw->x,
                                         y + pDraw->y, pGC->font, pGC->fgPixel,
                                         pGC->bgPixel, pGC->planemask,
                                         pGC->pCompositeClip, n,
                                         FONTGLYPHS(pGC->font),
                                         infoRec->CharInfo);
}

/********************************************************************

   GC level replacements for ImageGlyphBlt and PolyGlyphBlt for
   NonTE fonts when using color expansion.

********************************************************************/

void
XAAImageGlyphBltNonTEColorExpansion(DrawablePtr pDraw, GCPtr pGC, int xInit, int yInit, unsigned int nglyph, CharInfoPtr * ppci,        /* array of character info */
                                    pointer pglyphBase  /* start of array of glyphs */
    )
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);

    if (!RegionNumRects(pGC->pCompositeClip))
        return;

    ImageGlyphBltNonTEColorExpansion(infoRec->pScrn, xInit + pDraw->x,
                                     yInit + pDraw->y, pGC->font, pGC->fgPixel,
                                     pGC->bgPixel, pGC->planemask,
                                     pGC->pCompositeClip, nglyph,
                                     (unsigned char *) pglyphBase, ppci);
}

void
XAAPolyGlyphBltNonTEColorExpansion(DrawablePtr pDraw, GCPtr pGC, int xInit, int yInit, unsigned int nglyph, CharInfoPtr * ppci, /* array of character info */
                                   pointer pglyphBase   /* start of array of glyphs */
    )
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);

    if (!RegionNumRects(pGC->pCompositeClip))
        return;

    PolyGlyphBltNonTEColorExpansion(infoRec->pScrn, xInit + pDraw->x,
                                    yInit + pDraw->y, pGC->font, pGC->fgPixel,
                                    pGC->alu, pGC->planemask,
                                    pGC->pCompositeClip, nglyph,
                                    (unsigned char *) pglyphBase, ppci);
}

/********************************************************************

   ImageGlyphBltNonTEColorExpansion -
   PolyGlyphBltNonTEColorExpansion -

   These guys compute the clipped pieces of text and send it to
   the lower-level function which will handle acceleration of 
   arbitrarily clipped text.
  
********************************************************************/

static int
CollectCharacterInfo(NonTEGlyphPtr glyphs,
                     unsigned int nglyph, CharInfoPtr * ppci, FontPtr pfont)
{
    int i, w = 0;

    for (i = 0; i < nglyph; i++, ppci++, glyphs++) {
        glyphs->bits = (unsigned char *) ((*ppci)->bits);
        glyphs->start = w + (*ppci)->metrics.leftSideBearing;
        glyphs->end = w + (*ppci)->metrics.rightSideBearing;
        glyphs->yoff = (*ppci)->metrics.ascent;
        glyphs->height = glyphs->yoff + (*ppci)->metrics.descent;
        glyphs->srcwidth = PADGLYPHWIDTHBYTES(glyphs->end - glyphs->start);
        w += (*ppci)->metrics.characterWidth;
    }
    return w;
}

static void
PolyGlyphBltAsSingleBitmap(ScrnInfoPtr pScrn,
                           int nglyph,
                           FontPtr font,
                           int xInit,
                           int yInit,
                           int nbox,
                           BoxPtr pbox, int fg, int rop, unsigned planemask)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    CARD32 *block, *pntr, *bits;
    int pitch, topLine, botLine, top, bot, height;
    int Left, Right, Top, Bottom;
    int LeftEdge, RightEdge;
    int bitPitch, shift, size, i, skippix;
    NonTEGlyphPtr glyphs = infoRec->GlyphInfo;
    Bool extra;

    Left = xInit + infoRec->GlyphInfo[0].start;
    Right = xInit + infoRec->GlyphInfo[nglyph - 1].end;
    Top = yInit - FONTMAXBOUNDS(font, ascent);
    Bottom = yInit + FONTMAXBOUNDS(font, descent);

    /* get into the first band that may contain part of our string */
    while (nbox && (Top >= pbox->y2)) {
        pbox++;
        nbox--;
    }

    if (!nbox)
        return;

    pitch = (Right - Left + 31) >> 5;
    size = (pitch << 2) * (Bottom - Top);
    block = calloc(1, size);

    topLine = 10000;
    botLine = -10000;

    while (nglyph--) {
        top = -glyphs->yoff;
        bot = top + glyphs->height;
        if (top < topLine)
            topLine = top;
        if (bot > botLine)
            botLine = bot;
        skippix = glyphs->start - infoRec->GlyphInfo[0].start;
        bits = (CARD32 *) glyphs->bits;
        bitPitch = glyphs->srcwidth >> 2;
        pntr = block + ((FONTMAXBOUNDS(font, ascent) + top) * pitch) +
            (skippix >> 5);
        shift = skippix & 31;
        extra = ((shift + glyphs->end - glyphs->start) > 32);

        for (i = top; i < bot; i++) {
            *pntr |= SHIFT_L(*bits, shift);
            if (extra)
                *(pntr + 1) |= SHIFT_R(*bits, 32 - shift);
            pntr += pitch;
            bits += bitPitch;
        }

        glyphs++;
    }

    pntr = block + ((FONTMAXBOUNDS(font, ascent) + topLine) * pitch);

    Top = yInit + topLine;
    Bottom = yInit + botLine;

    while (nbox && (Top >= pbox->y2)) {
        pbox++;
        nbox--;
    }

    while (nbox && (Bottom > pbox->y1)) {
        LeftEdge = max(Left, pbox->x1);
        RightEdge = min(Right, pbox->x2);

        if (RightEdge > LeftEdge) {
            skippix = LeftEdge - Left;
            topLine = max(Top, pbox->y1);
            botLine = min(Bottom, pbox->y2);
            height = botLine - topLine;

            if (height > 0)
                (*infoRec->WriteBitmap) (pScrn, LeftEdge, topLine,
                                         RightEdge - LeftEdge, height,
                                         (unsigned char *) (pntr +
                                                            ((topLine -
                                                              Top) * pitch) +
                                                            (skippix >> 5)),
                                         pitch << 2, skippix & 31, fg, -1, rop,
                                         planemask);
        }

        nbox--;
        pbox++;
    }

    free(block);
}

static void
ImageGlyphBltNonTEColorExpansion(ScrnInfoPtr pScrn,
                                 int xInit, int yInit,
                                 FontPtr font,
                                 int fg, int bg,
                                 unsigned planemask,
                                 RegionPtr cclip,
                                 int nglyph,
                                 unsigned char *gBase, CharInfoPtr * ppci)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int skippix, skipglyph, width, n, i;
    int Left, Right, Top, Bottom;
    int LeftEdge, RightEdge, ytop, ybot;
    int nbox = RegionNumRects(cclip);
    BoxPtr pbox = RegionRects(cclip);
    Bool AlreadySetup = FALSE;

    width = CollectCharacterInfo(infoRec->GlyphInfo, nglyph, ppci, font);

    /* find our backing rectangle dimensions */
    Left = xInit;
    Right = Left + width;
    Top = yInit - FONTASCENT(font);
    Bottom = yInit + FONTDESCENT(font);

    /* get into the first band that may contain part of our box */
    while (nbox && (Top >= pbox->y2)) {
        pbox++;
        nbox--;
    }

    while (nbox && (Bottom >= pbox->y1)) {
        /* handle backing rect first */
        LeftEdge = max(Left, pbox->x1);
        RightEdge = min(Right, pbox->x2);
        if (RightEdge > LeftEdge) {
            ytop = max(Top, pbox->y1);
            ybot = min(Bottom, pbox->y2);

            if (ybot > ytop) {
                if (!AlreadySetup) {
                    (*infoRec->SetupForSolidFill) (pScrn, bg, GXcopy,
                                                   planemask);
                    AlreadySetup = TRUE;
                }
                (*infoRec->SubsequentSolidFillRect) (pScrn,
                                                     LeftEdge, ytop,
                                                     RightEdge - LeftEdge,
                                                     ybot - ytop);
            }
        }
        nbox--;
        pbox++;
    }

    nbox = RegionNumRects(cclip);
    pbox = RegionRects(cclip);

    if (infoRec->WriteBitmap && (nglyph > 1) &&
        ((FONTMAXBOUNDS(font, rightSideBearing) -
          FONTMINBOUNDS(font, leftSideBearing)) <= 32)) {
        PolyGlyphBltAsSingleBitmap(pScrn, nglyph, font,
                                   xInit, yInit, nbox, pbox,
                                   fg, GXcopy, planemask);

        return;
    }

    /* compute an approximate but covering bounding box */
    Left = xInit + infoRec->GlyphInfo[0].start;
    Right = xInit + infoRec->GlyphInfo[nglyph - 1].end;
    Top = yInit - FONTMAXBOUNDS(font, ascent);
    Bottom = yInit + FONTMAXBOUNDS(font, descent);

    /* get into the first band that may contain part of our box */
    while (nbox && (Top >= pbox->y2)) {
        pbox++;
        nbox--;
    }

    /* stop when the lower edge of the box is beyond our string */
    while (nbox && (Bottom >= pbox->y1)) {
        LeftEdge = max(Left, pbox->x1);
        RightEdge = min(Right, pbox->x2);

        if (RightEdge > LeftEdge) {     /* we're possibly drawing something */
            ytop = max(Top, pbox->y1);
            ybot = min(Bottom, pbox->y2);
            if (ybot > ytop) {
                skippix = LeftEdge - xInit;
                skipglyph = 0;
                while (skippix >= infoRec->GlyphInfo[skipglyph].end)
                    skipglyph++;

                skippix = RightEdge - xInit;
                n = 0;
                i = skipglyph;
                while ((i < nglyph) && (skippix > infoRec->GlyphInfo[i].start)) {
                    i++;
                    n++;
                }

                if (n)
                    (*infoRec->NonTEGlyphRenderer) (pScrn,
                                                    xInit, yInit, n,
                                                    infoRec->GlyphInfo +
                                                    skipglyph, pbox, fg, GXcopy,
                                                    planemask);
            }
        }

        nbox--;
        pbox++;
    }
}

static int
PolyGlyphBltNonTEColorExpansion(ScrnInfoPtr pScrn,
                                int xInit, int yInit,
                                FontPtr font,
                                int fg, int rop,
                                unsigned planemask,
                                RegionPtr cclip,
                                int nglyph,
                                unsigned char *gBase, CharInfoPtr * ppci)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int skippix, skipglyph, width, n, i;
    int Left, Right, Top, Bottom;
    int LeftEdge, RightEdge;
    int nbox = RegionNumRects(cclip);
    BoxPtr pbox = RegionRects(cclip);

    width = CollectCharacterInfo(infoRec->GlyphInfo, nglyph, ppci, font);

    if (!nbox)
        return width;

    if ((infoRec->WriteBitmap) && (rop == GXcopy) && (nglyph > 1) &&
        ((FONTMAXBOUNDS(font, rightSideBearing) -
          FONTMINBOUNDS(font, leftSideBearing)) <= 32)) {

        PolyGlyphBltAsSingleBitmap(pScrn, nglyph, font,
                                   xInit, yInit, nbox, pbox,
                                   fg, rop, planemask);

        return width;
    }

    /* compute an approximate but covering bounding box */
    Left = xInit + infoRec->GlyphInfo[0].start;
    Right = xInit + infoRec->GlyphInfo[nglyph - 1].end;
    Top = yInit - FONTMAXBOUNDS(font, ascent);
    Bottom = yInit + FONTMAXBOUNDS(font, descent);

    /* get into the first band that may contain part of our string */
    while (nbox && (Top >= pbox->y2)) {
        pbox++;
        nbox--;
    }

    /* stop when the lower edge of the box is beyond our string */
    while (nbox && (Bottom >= pbox->y1)) {
        LeftEdge = max(Left, pbox->x1);
        RightEdge = min(Right, pbox->x2);

        if (RightEdge > LeftEdge) {     /* we're possibly drawing something */

            skippix = LeftEdge - xInit;
            skipglyph = 0;
            while (skippix >= infoRec->GlyphInfo[skipglyph].end)
                skipglyph++;

            skippix = RightEdge - xInit;
            n = 0;
            i = skipglyph;
            while ((i < nglyph) && (skippix > infoRec->GlyphInfo[i].start)) {
                i++;
                n++;
            }

            if (n)
                (*infoRec->NonTEGlyphRenderer) (pScrn,
                                                xInit, yInit, n,
                                                infoRec->GlyphInfo + skipglyph,
                                                pbox, fg, rop, planemask);
        }

        nbox--;
        pbox++;
    }
    return width;
}

/* It is possible that the none of the glyphs passed to the 
   NonTEGlyphRenderer will be drawn.  This function being called
   indicates that part of the text string's bounding box is visible
   but not necessarily that any of the characters are visible */

void
XAANonTEGlyphRenderer(ScrnInfoPtr pScrn,
                      int x, int y, int n,
                      NonTEGlyphPtr glyphs,
                      BoxPtr pbox, int fg, int rop, unsigned int planemask)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int x1, x2, y1, y2, i, w, h, skipleft, skiptop;
    unsigned char *src;

    for (i = 0; i < n; i++, glyphs++) {
        x1 = x + glyphs->start;
        x2 = x + glyphs->end;
        y1 = y - glyphs->yoff;
        y2 = y1 + glyphs->height;

        if (y1 < pbox->y1) {
            skiptop = pbox->y1 - y1;
            y1 = pbox->y1;
        }
        else
            skiptop = 0;
        if (y2 > pbox->y2)
            y2 = pbox->y2;
        h = y2 - y1;
        if (h <= 0)
            continue;

        if (x1 < pbox->x1) {
            skipleft = pbox->x1 - x1;
            x1 = pbox->x1;
        }
        else
            skipleft = 0;
        if (x2 > pbox->x2)
            x2 = pbox->x2;

        w = x2 - x1;

        if (w > 0) {
            src = glyphs->bits + (skiptop * glyphs->srcwidth);

            if (skipleft) {
                src += (skipleft >> 5) << 2;
                skipleft &= 31;
            }

            (*infoRec->WriteBitmap) (pScrn, x1, y1, w, h, src,
                                     glyphs->srcwidth, skipleft, fg, -1, rop,
                                     planemask);
        }
    }

}
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a40 1

d42 11
a52 9
				int xInit, int yInit, FontPtr font,
				int fg, int bg, unsigned planemask,
				RegionPtr cclip, int nglyph,
				unsigned char* gBase, CharInfoPtr *ppci);
static int PolyGlyphBltNonTEColorExpansion(ScrnInfoPtr pScrn,
				int xInit, int yInit, FontPtr font,
				int fg, int rop, unsigned planemask,
				RegionPtr cclip, int nglyph,
				unsigned char* gBase, CharInfoPtr *ppci);
a60 1

d62 2
a63 7
XAAPolyText8NonTEColorExpansion(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x, 
    int 	y,
    int 	count,
    char	*chars )
d69 12
a80 9
    (*pGC->font->get_glyphs)(pGC->font, (unsigned long)count, 
		(unsigned char *)chars, Linear8Bit, &n, infoRec->CharInfo);

    if(n) {
	width = PolyGlyphBltNonTEColorExpansion( infoRec->pScrn, 
		x + pDraw->x, y + pDraw->y, pGC->font, 
		pGC->fgPixel, pGC->alu, pGC->planemask, 
		pGC->pCompositeClip, n, FONTGLYPHS(pGC->font),
 		infoRec->CharInfo);
a85 1

d87 3
a89 7
XAAPolyText16NonTEColorExpansion(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x, 
    int		y,
    int		count,
    unsigned short *chars )
d95 14
a108 11
    (*pGC->font->get_glyphs)(
		pGC->font, (unsigned long)count, (unsigned char *)chars,
		(FONTLASTROW(pGC->font) == 0) ? Linear16Bit : TwoD16Bit,
		&n, infoRec->CharInfo);

    if(n) {
	width = PolyGlyphBltNonTEColorExpansion( infoRec->pScrn, 
		x + pDraw->x, y + pDraw->y, pGC->font, 
		pGC->fgPixel, pGC->alu, pGC->planemask, 
		pGC->pCompositeClip, n, FONTGLYPHS(pGC->font),
		infoRec->CharInfo);
a113 1

d115 4
a118 8
XAAImageText8NonTEColorExpansion(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x, 
    int		y,
    int		count,
    char	*chars 
){
d122 2
a123 5
    if(!RegionNumRects(pGC->pCompositeClip))
	return;

    (*pGC->font->get_glyphs)(pGC->font, (unsigned long)count, 
		(unsigned char *)chars, Linear8Bit, &n, infoRec->CharInfo);
d125 11
a135 4
    if(n) ImageGlyphBltNonTEColorExpansion(
	infoRec->pScrn, x + pDraw->x, y + pDraw->y,
	pGC->font, pGC->fgPixel, pGC->bgPixel, pGC->planemask, 
	pGC->pCompositeClip, n, FONTGLYPHS(pGC->font), infoRec->CharInfo);
a137 1

d139 5
a143 8
XAAImageText16NonTEColorExpansion(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x, 
    int		y,
    int		count,
    unsigned short *chars 
){
d147 2
a148 2
    if(!RegionNumRects(pGC->pCompositeClip))
	return;
d150 13
a162 9
    (*pGC->font->get_glyphs)(
		pGC->font, (unsigned long)count, (unsigned char *)chars,
		(FONTLASTROW(pGC->font) == 0) ? Linear16Bit : TwoD16Bit,
		&n, infoRec->CharInfo);

    if(n) ImageGlyphBltNonTEColorExpansion(
	infoRec->pScrn, x + pDraw->x, y + pDraw->y,
	pGC->font, pGC->fgPixel, pGC->bgPixel, pGC->planemask, 
	pGC->pCompositeClip, n, FONTGLYPHS(pGC->font), infoRec->CharInfo);
a164 2


a171 1

d173 4
a176 8
XAAImageGlyphBltNonTEColorExpansion(
    DrawablePtr pDraw,
    GCPtr pGC,
    int xInit, int yInit,
    unsigned int nglyph,
    CharInfoPtr *ppci,      /* array of character info */
    pointer pglyphBase	       /* start of array of glyphs */
){
d179 2
a180 2
    if(!RegionNumRects(pGC->pCompositeClip))
	return;
d182 5
a186 4
    ImageGlyphBltNonTEColorExpansion(
	infoRec->pScrn, xInit + pDraw->x, yInit + pDraw->y,
	pGC->font, pGC->fgPixel, pGC->bgPixel, pGC->planemask, 
	pGC->pCompositeClip, nglyph, (unsigned char*)pglyphBase, ppci);
d190 4
a193 8
XAAPolyGlyphBltNonTEColorExpansion(
    DrawablePtr pDraw,
    GCPtr pGC,
    int xInit, int yInit,
    unsigned int nglyph,
    CharInfoPtr *ppci,      /* array of character info */
    pointer pglyphBase	       /* start of array of glyphs */
){
d196 2
a197 2
    if(!RegionNumRects(pGC->pCompositeClip))
	return;
d199 5
a203 4
    PolyGlyphBltNonTEColorExpansion(
	infoRec->pScrn, xInit + pDraw->x, yInit + pDraw->y,
	pGC->font, pGC->fgPixel, pGC->alu, pGC->planemask, 
	pGC->pCompositeClip, nglyph, (unsigned char*)pglyphBase, ppci);
a205 3



d217 5
d223 10
a232 20

static int
CollectCharacterInfo(
    NonTEGlyphPtr glyphs,
    unsigned int nglyph,
    CharInfoPtr *ppci,
    FontPtr pfont
){
   int i, w = 0;
   
   for(i = 0; i < nglyph; i++, ppci++, glyphs++) {
	glyphs->bits = (unsigned char*)((*ppci)->bits);
	glyphs->start = w + (*ppci)->metrics.leftSideBearing;
	glyphs->end = w + (*ppci)->metrics.rightSideBearing;
	glyphs->yoff = (*ppci)->metrics.ascent;
	glyphs->height = glyphs->yoff + (*ppci)->metrics.descent;
	glyphs->srcwidth = PADGLYPHWIDTHBYTES(glyphs->end - glyphs->start);
	w += (*ppci)->metrics.characterWidth;
   }
   return w;
a234 1

d236 8
a243 12
PolyGlyphBltAsSingleBitmap (
   ScrnInfoPtr pScrn,
   int nglyph,
   FontPtr font,
   int xInit,
   int yInit,
   int nbox,
   BoxPtr pbox,
   int fg,
   int rop,
   unsigned planemask
){
d252 1
a252 1
	
d255 2
a256 2
    Top = yInit - FONTMAXBOUNDS(font,ascent);
    Bottom = yInit + FONTMAXBOUNDS(font,descent);
d259 3
a261 2
    while(nbox && (Top >= pbox->y2)) {
	pbox++; nbox--;
d264 2
a265 1
    if(!nbox) return;
d271 2
a272 1
    topLine = 10000; botLine = -10000;
d274 22
a295 20
    while(nglyph--) {
	top = -glyphs->yoff;
	bot = top + glyphs->height;
	if(top < topLine) topLine = top;
	if(bot > botLine) botLine = bot;
	skippix = glyphs->start - infoRec->GlyphInfo[0].start;
	bits = (CARD32*)glyphs->bits;
	bitPitch = glyphs->srcwidth >> 2;
	pntr = block + ((FONTMAXBOUNDS(font,ascent) + top) * pitch) +
				(skippix >> 5);
	shift = skippix & 31;
	extra = ((shift + glyphs->end - glyphs->start) > 32);

	for(i = top; i < bot; i++) {
	    *pntr |= SHIFT_L(*bits, shift);
	    if(extra)
		*(pntr + 1) |= SHIFT_R(*bits,32 - shift);
	    pntr += pitch;
	    bits += bitPitch;
	}
d297 1
a297 1
	glyphs++;
d300 1
a300 1
    pntr = block + ((FONTMAXBOUNDS(font,ascent) + topLine) * pitch);
d305 25
a329 21
    while(nbox && (Top >= pbox->y2)) {
	pbox++; nbox--;
    }

    while(nbox && (Bottom > pbox->y1)) {
	LeftEdge = max(Left, pbox->x1);
	RightEdge = min(Right, pbox->x2);

	if(RightEdge > LeftEdge) {
	    skippix = LeftEdge - Left;
	    topLine = max(Top, pbox->y1);
	    botLine = min(Bottom, pbox->y2);	
	    height = botLine - topLine;

	    if(height > 0) 
	       (*infoRec->WriteBitmap)(pScrn, LeftEdge, topLine, 
			RightEdge - LeftEdge, height,
			(unsigned char*)(pntr + ((topLine - Top) * pitch) +
				(skippix >> 5)),
			pitch << 2, skippix & 31, fg, -1, rop, planemask);
	}
d331 2
a332 1
	nbox--; pbox++;
d339 9
a347 11
ImageGlyphBltNonTEColorExpansion(
   ScrnInfoPtr pScrn,
   int xInit, int yInit,
   FontPtr font,
   int fg, int bg,
   unsigned planemask,
   RegionPtr cclip,
   int nglyph,
   unsigned char* gBase,
   CharInfoPtr *ppci 
){
d365 27
a391 2
    while(nbox && (Top >= pbox->y2)) {
	pbox++; nbox--;
a393 20
    while(nbox && (Bottom >= pbox->y1)) {
	/* handle backing rect first */
	LeftEdge = max(Left, pbox->x1);
	RightEdge = min(Right, pbox->x2);
	if(RightEdge > LeftEdge) {	    
	    ytop = max(Top, pbox->y1);
	    ybot = min(Bottom, pbox->y2);

	    if(ybot > ytop) {
		if(!AlreadySetup) {
		   (*infoRec->SetupForSolidFill)(pScrn, bg, GXcopy, planemask);
		   AlreadySetup = TRUE;
		}
		(*infoRec->SubsequentSolidFillRect)(pScrn, 
			LeftEdge, ytop, RightEdge - LeftEdge, ybot - ytop);
	    }
	}
	nbox--; pbox++;
    }
 
d397 6
a402 7
    if(infoRec->WriteBitmap && (nglyph > 1) && 
			((FONTMAXBOUNDS(font, rightSideBearing) - 
          		FONTMINBOUNDS(font, leftSideBearing)) <= 32)) 
   {
	PolyGlyphBltAsSingleBitmap(pScrn, nglyph, font, 
				xInit, yInit, nbox, pbox,
				fg, GXcopy, planemask);
d404 1
a404 1
	return;
d410 2
a411 2
    Top = yInit - FONTMAXBOUNDS(font,ascent);
    Bottom = yInit + FONTMAXBOUNDS(font,descent);
d414 3
a416 2
    while(nbox && (Top >= pbox->y2)) {
	pbox++; nbox--;
d420 29
a448 24
    while(nbox && (Bottom >= pbox->y1)) {
	LeftEdge = max(Left, pbox->x1);
	RightEdge = min(Right, pbox->x2);

	if(RightEdge > LeftEdge) { /* we're possibly drawing something */
	    ytop = max(Top, pbox->y1);
	    ybot = min(Bottom, pbox->y2);
	    if(ybot > ytop) {
		skippix = LeftEdge - xInit;
		skipglyph = 0;
		while(skippix >= infoRec->GlyphInfo[skipglyph].end)
		   skipglyph++;

		skippix = RightEdge - xInit;
		n = 0; i = skipglyph;
		while((i < nglyph) && (skippix > infoRec->GlyphInfo[i].start)) {
		    i++; n++;
		}

		if(n) (*infoRec->NonTEGlyphRenderer)(pScrn,
			xInit, yInit, n, infoRec->GlyphInfo + skipglyph, 
			pbox, fg, GXcopy, planemask); 
	    }
	}
d450 2
a451 1
	nbox--; pbox++;
a454 1

d456 9
a464 11
PolyGlyphBltNonTEColorExpansion(
   ScrnInfoPtr pScrn,
   int xInit, int yInit,
   FontPtr font,
   int fg, int rop,
   unsigned planemask,
   RegionPtr cclip,
   int nglyph,
   unsigned char* gBase,
   CharInfoPtr *ppci 
){
d474 2
a475 2
    if(!nbox)
	return width;
d477 2
a478 2
    if((infoRec->WriteBitmap) && (rop == GXcopy) && (nglyph > 1) &&
	((FONTMAXBOUNDS(font, rightSideBearing) - 
d481 3
a483 3
	 PolyGlyphBltAsSingleBitmap(pScrn, nglyph, font, 
				xInit, yInit, nbox, pbox,
				fg, rop, planemask);
d485 1
a485 1
	return width;
d491 2
a492 2
    Top = yInit - FONTMAXBOUNDS(font,ascent);
    Bottom = yInit + FONTMAXBOUNDS(font,descent);
d495 3
a497 2
    while(nbox && (Top >= pbox->y2)) {
	pbox++; nbox--;
d501 25
a525 21
    while(nbox && (Bottom >= pbox->y1)) {
	LeftEdge = max(Left, pbox->x1);
	RightEdge = min(Right, pbox->x2);

	if(RightEdge > LeftEdge) { /* we're possibly drawing something */

	    skippix = LeftEdge - xInit;
	    skipglyph = 0;
	    while(skippix >= infoRec->GlyphInfo[skipglyph].end)
		skipglyph++;

	    skippix = RightEdge - xInit;
	    n = 0; i = skipglyph;
	    while((i < nglyph) && (skippix > infoRec->GlyphInfo[i].start)) {
		i++; n++;
	    }

	    if(n) (*infoRec->NonTEGlyphRenderer)(pScrn,
			xInit, yInit, n, infoRec->GlyphInfo + skipglyph, 
			pbox, fg, rop, planemask); 
	}
d527 2
a528 1
	nbox--; pbox++;
a532 1

d538 6
a543 8
void XAANonTEGlyphRenderer(
   ScrnInfoPtr pScrn,
   int x, int y, int n,
   NonTEGlyphPtr glyphs,
   BoxPtr pbox,
   int fg, int rop,
   unsigned int planemask
){
d548 42
a589 34
    for(i = 0; i < n; i++, glyphs++) {
	x1 = x + glyphs->start;
	x2 = x + glyphs->end;
	y1 = y - glyphs->yoff;
	y2 = y1 + glyphs->height;

	if(y1 < pbox->y1) {
	    skiptop = pbox->y1 - y1;
	    y1 = pbox->y1;
	} else skiptop = 0;
	if(y2 > pbox->y2) y2 = pbox->y2;
	h = y2 - y1;
	if(h <= 0) continue;

	if(x1 < pbox->x1) {
	    skipleft = pbox->x1 - x1;
	    x1 = pbox->x1;
	} else skipleft = 0;
	if(x2 > pbox->x2) x2 = pbox->x2;

	w = x2 - x1;

	if(w > 0) {
	    src = glyphs->bits + (skiptop * glyphs->srcwidth);

	    if(skipleft) {
		src += (skipleft >> 5) << 2;
		skipleft &= 31;
	    }

	    (*infoRec->WriteBitmap)(pScrn, x1, y1, w, h, src,
			glyphs->srcwidth, skipleft, fg, -1, rop, planemask);
	}
    }  
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d85 1
a85 1
    return (x + width);
d115 1
a115 1
    return (x + width);
d131 1
a131 1
    if(!REGION_NUM_RECTS(pGC->pCompositeClip))
d156 1
a156 1
    if(!REGION_NUM_RECTS(pGC->pCompositeClip))
d191 1
a191 1
    if(!REGION_NUM_RECTS(pGC->pCompositeClip))
d211 1
a211 1
    if(!REGION_NUM_RECTS(pGC->pCompositeClip))
d294 1
a294 1
    block = xcalloc(1, size);
d352 1
a352 1
    xfree(block);
d371 2
a372 2
    int nbox = REGION_NUM_RECTS(cclip);
    BoxPtr pbox = REGION_RECTS(cclip);
d408 2
a409 2
    nbox = REGION_NUM_RECTS(cclip);
    pbox = REGION_RECTS(cclip);
d480 2
a481 2
    int nbox = REGION_NUM_RECTS(cclip);
    BoxPtr pbox = REGION_RECTS(cclip);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d294 1
a294 2
    block = (CARD32*)xalloc(size);
    bzero(block, size);
@


1.1
log
@Initial revision
@
text
@d294 1
a294 1
    block = (CARD32*)ALLOCATE_LOCAL(size);
d353 1
a353 1
    DEALLOCATE_LOCAL(block);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
