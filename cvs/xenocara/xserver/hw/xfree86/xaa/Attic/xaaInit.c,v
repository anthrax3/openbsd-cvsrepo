head	1.7;
access;
symbols
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.06.07.17.28.53;	author matthieu;	state dead;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.27;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.28;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.49;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.49;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.58.23;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"

#include <X11/X.h>
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "xf86str.h"
#include "mi.h"
#include "miline.h"
#include "xaa.h"
#include "xaalocal.h"
#include "xaawrap.h"
#include "xf86fbman.h"
#include "servermd.h"
#ifdef COMPOSITE
#include "cw.h"
#endif

#define MAX_PREALLOC_MEM	65536   /* MUST be >= 1024 */

#define MIN_OFFPIX_SIZE		(320*200)

static Bool XAACloseScreen(int i, ScreenPtr pScreen);
static void XAAGetImage(DrawablePtr pDrawable, int sx, int sy, int w, int h,
                        unsigned int format, unsigned long planemask,
                        char *pdstLine);
static void XAAGetSpans(DrawablePtr pDrawable, int wMax, DDXPointPtr ppt,
                        int *pwidth, int nspans, char *pdstStart);
static PixmapPtr XAACreatePixmap(ScreenPtr pScreen, int w, int h, int depth,
                                 unsigned usage_hint);
static Bool XAADestroyPixmap(PixmapPtr pPixmap);
static Bool XAAEnterVT(int index, int flags);
static void XAALeaveVT(int index, int flags);
static int XAASetDGAMode(int index, int num, DGADevicePtr devRet);
static void XAAEnableDisableFBAccess(int index, Bool enable);
static Bool XAAChangeWindowAttributes(WindowPtr pWin, unsigned long mask);

static DevPrivateKeyRec XAAScreenKeyRec;

#define XAAScreenKey (&XAAScreenKeyRec)
static DevPrivateKeyRec XAAGCKeyRec;

#define XAAGCKey (&XAAGCKeyRec)
static DevPrivateKeyRec XAAPixmapKeyRec;

#define XAAPixmapKey (&XAAPixmapKeyRec)

DevPrivateKey
XAAGetScreenKey(void)
{
    return XAAScreenKey;
}

DevPrivateKey
XAAGetGCKey(void)
{
    return XAAGCKey;
}

DevPrivateKey
XAAGetPixmapKey(void)
{
    return XAAPixmapKey;
}

/* temp kludge */
static Bool SwitchedOut = FALSE;

XAAInfoRecPtr
XAACreateInfoRec(void)
{
    XAAInfoRecPtr infoRec;

    infoRec = calloc(1, sizeof(XAAInfoRec));
    if (infoRec)
        infoRec->CachePixelGranularity = -1;

    return infoRec;
}

void
XAADestroyInfoRec(XAAInfoRecPtr infoRec)
{
    if (!infoRec)
        return;

    if (infoRec->ClosePixmapCache)
        (*infoRec->ClosePixmapCache) (infoRec->pScrn->pScreen);

    free(infoRec->PreAllocMem);

    free(infoRec->PixmapCachePrivate);

    free(infoRec);
}

Bool
XAAInit(ScreenPtr pScreen, XAAInfoRecPtr infoRec)
{
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    XAAScreenPtr pScreenPriv;
    int i;
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);

    /* Return successfully if no acceleration wanted */
    if (!infoRec)
        return TRUE;

    if (!dixRegisterPrivateKey(&XAAGCKeyRec, PRIVATE_GC, sizeof(XAAGCRec)))
        return FALSE;

    if (!dixRegisterPrivateKey
        (&XAAPixmapKeyRec, PRIVATE_PIXMAP, sizeof(XAAPixmapRec)))
        return FALSE;

    if (!dixRegisterPrivateKey(&XAAScreenKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    if (!(pScreenPriv = malloc(sizeof(XAAScreenRec))))
        return FALSE;

    dixSetPrivate(&pScreen->devPrivates, XAAScreenKey, pScreenPriv);

    if (!xf86FBManagerRunning(pScreen))
        infoRec->Flags &= ~(PIXMAP_CACHE | OFFSCREEN_PIXMAPS);
    if (!(infoRec->Flags & LINEAR_FRAMEBUFFER))
        infoRec->Flags &= ~OFFSCREEN_PIXMAPS;

    if (!infoRec->FullPlanemask) {      /* for backwards compatibility */
        infoRec->FullPlanemask = (1 << pScrn->depth) - 1;
        infoRec->FullPlanemasks[pScrn->depth - 1] = infoRec->FullPlanemask;
    }

    for (i = 0; i < 32; i++) {
        if (!infoRec->FullPlanemasks[i])        /* keep any set by caller */
            infoRec->FullPlanemasks[i] = (1 << (i + 1)) - 1;
    }

    if (!XAAInitAccel(pScreen, infoRec))
        return FALSE;
    pScreenPriv->AccelInfoRec = infoRec;
    infoRec->ScratchGC.pScreen = pScreen;

    if (!infoRec->GetImage)
        infoRec->GetImage = XAAGetImage;
    if (!infoRec->GetSpans)
        infoRec->GetSpans = XAAGetSpans;
    if (!infoRec->CopyWindow)
        infoRec->CopyWindow = XAACopyWindow;

    pScreenPriv->CreateGC = pScreen->CreateGC;
    pScreen->CreateGC = XAACreateGC;
    pScreenPriv->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = XAACloseScreen;
    pScreenPriv->GetImage = pScreen->GetImage;
    pScreen->GetImage = infoRec->GetImage;
    pScreenPriv->GetSpans = pScreen->GetSpans;
    pScreen->GetSpans = infoRec->GetSpans;
    pScreenPriv->CopyWindow = pScreen->CopyWindow;
    pScreen->CopyWindow = infoRec->CopyWindow;
    pScreenPriv->CreatePixmap = pScreen->CreatePixmap;
    pScreen->CreatePixmap = XAACreatePixmap;
    pScreenPriv->DestroyPixmap = pScreen->DestroyPixmap;
    pScreen->DestroyPixmap = XAADestroyPixmap;
    pScreenPriv->ChangeWindowAttributes = pScreen->ChangeWindowAttributes;
    pScreen->ChangeWindowAttributes = XAAChangeWindowAttributes;

    pScreenPriv->EnterVT = pScrn->EnterVT;
    pScrn->EnterVT = XAAEnterVT;
    pScreenPriv->LeaveVT = pScrn->LeaveVT;
    pScrn->LeaveVT = XAALeaveVT;
    pScreenPriv->SetDGAMode = pScrn->SetDGAMode;
    pScrn->SetDGAMode = XAASetDGAMode;
    pScreenPriv->EnableDisableFBAccess = pScrn->EnableDisableFBAccess;
    pScrn->EnableDisableFBAccess = XAAEnableDisableFBAccess;

    pScreenPriv->WindowExposures = pScreen->WindowExposures;
    if (ps) {
        pScreenPriv->Composite = ps->Composite;
        ps->Composite = XAAComposite;
        pScreenPriv->Glyphs = ps->Glyphs;
        ps->Glyphs = XAAGlyphs;
    }
    if (pScrn->overlayFlags & OVERLAY_8_32_PLANAR)
        XAASetupOverlay8_32Planar(pScreen);

    infoRec->PreAllocMem = malloc(MAX_PREALLOC_MEM);
    if (infoRec->PreAllocMem)
        infoRec->PreAllocSize = MAX_PREALLOC_MEM;

    if (infoRec->Flags & PIXMAP_CACHE)
        xf86RegisterFreeBoxCallback(pScreen, infoRec->InitPixmapCache,
                                    (pointer) infoRec);

    if (infoRec->Flags & MICROSOFT_ZERO_LINE_BIAS)
        miSetZeroLineBias(pScreen, OCTANT1 | OCTANT2 | OCTANT3 | OCTANT4);

#ifdef COMPOSITE
    /* Initialize the composite wrapper.  This needs to happen after the
     * wrapping above (so it comes before us), but before all other extensions,
     * so it doesn't confuse them. (particularly damage).
     */
    miInitializeCompositeWrapper(pScreen);
#endif

    return TRUE;
}

static Bool
XAACloseScreen(int i, ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    XAAScreenPtr pScreenPriv =
        (XAAScreenPtr) dixLookupPrivate(&pScreen->devPrivates, XAAScreenKey);

    pScrn->EnterVT = pScreenPriv->EnterVT;
    pScrn->LeaveVT = pScreenPriv->LeaveVT;
    pScrn->EnableDisableFBAccess = pScreenPriv->EnableDisableFBAccess;

    pScreen->CreateGC = pScreenPriv->CreateGC;
    pScreen->CloseScreen = pScreenPriv->CloseScreen;
    pScreen->GetImage = pScreenPriv->GetImage;
    pScreen->GetSpans = pScreenPriv->GetSpans;
    pScreen->CopyWindow = pScreenPriv->CopyWindow;
    pScreen->WindowExposures = pScreenPriv->WindowExposures;
    pScreen->CreatePixmap = pScreenPriv->CreatePixmap;
    pScreen->DestroyPixmap = pScreenPriv->DestroyPixmap;
    pScreen->ChangeWindowAttributes = pScreenPriv->ChangeWindowAttributes;

    /* We leave it up to the client to free the XAAInfoRec */

    free((pointer) pScreenPriv);

    return (*pScreen->CloseScreen) (i, pScreen);
}

static void
XAAGetImage(DrawablePtr pDraw,
            int sx, int sy, int w, int h,
            unsigned int format, unsigned long planemask, char *pdstLine)
{
    ScreenPtr pScreen = pDraw->pScreen;
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
    ScrnInfoPtr pScrn = infoRec->pScrn;

    if (pScrn->vtSema &&
        ((pDraw->type == DRAWABLE_WINDOW) || IS_OFFSCREEN_PIXMAP(pDraw))) {
        if (infoRec->ReadPixmap && (format == ZPixmap) &&
            ((planemask & infoRec->FullPlanemasks[pDraw->depth - 1]) ==
             infoRec->FullPlanemasks[pDraw->depth - 1]) &&
            (pDraw->bitsPerPixel == BitsPerPixel(pDraw->depth))) {
            (*infoRec->ReadPixmap) (pScrn,
                                    sx + pDraw->x, sy + pDraw->y, w, h,
                                    (unsigned char *) pdstLine,
                                    PixmapBytePad(w, pDraw->depth),
                                    pDraw->bitsPerPixel, pDraw->depth);
            return;
        }
        SYNC_CHECK(pDraw);
    }

    XAA_SCREEN_PROLOGUE(pScreen, GetImage);
    (*pScreen->GetImage) (pDraw, sx, sy, w, h, format, planemask, pdstLine);
    XAA_SCREEN_EPILOGUE(pScreen, GetImage, XAAGetImage);
}

static void
XAAGetSpans(DrawablePtr pDraw,
            int wMax, DDXPointPtr ppt, int *pwidth, int nspans, char *pdstStart)
{
    ScreenPtr pScreen = pDraw->pScreen;

    XAA_SCREEN_PROLOGUE(pScreen, GetSpans);
    if (xf86Screens[pScreen->myNum]->vtSema &&
        ((pDraw->type == DRAWABLE_WINDOW) || IS_OFFSCREEN_PIXMAP(pDraw))) {
        SYNC_CHECK(pDraw);
    }
    (*pScreen->GetSpans) (pDraw, wMax, ppt, pwidth, nspans, pdstStart);
    XAA_SCREEN_EPILOGUE(pScreen, GetSpans, XAAGetSpans);
}

static int
XAAPixmapBPP(ScreenPtr pScreen, int depth)
{
    PixmapPtr pPix;
    int bpp;
    DestroyPixmapProcPtr destroyPixmap;

    XAA_SCREEN_PROLOGUE(pScreen, CreatePixmap);
    pPix = (*pScreen->CreatePixmap) (pScreen, 1, 1, depth,
                                     CREATE_PIXMAP_USAGE_SCRATCH);
    XAA_SCREEN_EPILOGUE(pScreen, CreatePixmap, XAACreatePixmap);
    if (!pPix)
        return 0;
    bpp = pPix->drawable.bitsPerPixel;
    destroyPixmap = pScreen->DestroyPixmap;
    XAA_SCREEN_PROLOGUE(pScreen, DestroyPixmap);
    (*pScreen->DestroyPixmap) (pPix);
    XAA_SCREEN_EPILOGUE(pScreen, DestroyPixmap, destroyPixmap);
    return bpp;
}

static void
XAAInitializeOffscreenDepths(ScreenPtr pScreen)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    int d, dep;

    infoRec->offscreenDepthsInitialized = TRUE;
    infoRec->offscreenDepths = 0;
    if (infoRec->Flags & OFFSCREEN_PIXMAPS) {
        for (d = 0; d < pScreen->numDepths; d++) {
            dep = pScreen->allowedDepths[d].depth;
            if (XAAPixmapBPP(pScreen, dep) == pScrn->bitsPerPixel)
                infoRec->offscreenDepths |= (1 << (dep - 1));
        }
    }
}

static PixmapPtr
XAACreatePixmap(ScreenPtr pScreen, int w, int h, int depth, unsigned usage_hint)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    XAAPixmapPtr pPriv;
    PixmapPtr pPix = NULL;
    int size = w * h;

    if (w > 32767 || h > 32767)
        return NullPixmap;

    if (!infoRec->offscreenDepthsInitialized)
        XAAInitializeOffscreenDepths(pScreen);

    if (pScrn->vtSema &&
        (usage_hint != CREATE_PIXMAP_USAGE_GLYPH_PICTURE) &&
        (infoRec->offscreenDepths & (1 << (depth - 1))) &&
        (size >= MIN_OFFPIX_SIZE) && !SwitchedOut &&
        (!infoRec->maxOffPixWidth || (w <= infoRec->maxOffPixWidth)) &&
        (!infoRec->maxOffPixHeight || (h <= infoRec->maxOffPixHeight))) {
        PixmapLinkPtr pLink;
        PixmapPtr pScreenPix;
        FBAreaPtr area;
        int gran = 0;

        switch (pScrn->bitsPerPixel) {
        case 24:
        case 8:
            gran = 4;
            break;
        case 16:
            gran = 2;
            break;
        case 32:
            gran = 1;
            break;
        default:
            break;
        }

        if (BITMAP_SCANLINE_PAD == 64)
            gran *= 2;

        if (!(area = xf86AllocateOffscreenArea(pScreen, w, h, gran, 0,
                                               XAARemoveAreaCallback, NULL))) {
            goto BAILOUT;
        }

        if (!(pLink = malloc(sizeof(PixmapLink)))) {
            xf86FreeOffscreenArea(area);
            goto BAILOUT;
        }

        XAA_SCREEN_PROLOGUE(pScreen, CreatePixmap);
        pPix = (*pScreen->CreatePixmap) (pScreen, 0, 0, depth, usage_hint);
        XAA_SCREEN_EPILOGUE(pScreen, CreatePixmap, XAACreatePixmap);

        if (!pPix) {
            free(pLink);
            xf86FreeOffscreenArea(area);
            goto BAILOUT;
        }

        pScreenPix = (*pScreen->GetScreenPixmap) (pScreen);

        pPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
        pPix->drawable.x = area->box.x1;
        pPix->drawable.y = area->box.y1;
        pPix->drawable.width = w;
        pPix->drawable.height = h;
        pPix->drawable.bitsPerPixel = pScrn->bitsPerPixel;
        pPix->devKind = pScreenPix->devKind;
        pPix->devPrivate.ptr = pScreenPix->devPrivate.ptr;
        area->devPrivate.ptr = pPix;

        pPriv->flags = OFFSCREEN;
        pPriv->offscreenArea = area;
        pPriv->freeData = FALSE;

        pLink->next = infoRec->OffscreenPixmaps;
        pLink->pPix = pPix;
        infoRec->OffscreenPixmaps = pLink;
        return pPix;
    }
 BAILOUT:
    XAA_SCREEN_PROLOGUE(pScreen, CreatePixmap);
    pPix = (*pScreen->CreatePixmap) (pScreen, w, h, depth, usage_hint);
    XAA_SCREEN_EPILOGUE(pScreen, CreatePixmap, XAACreatePixmap);

    if (pPix) {
        pPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
        pPriv->flags = 0;
        pPriv->offscreenArea = NULL;
        pPriv->freeData = FALSE;
        if (!w || !h)           /* either scratch or shared memory */
            pPriv->flags |= SHARED_PIXMAP;
    }

    return pPix;
}

static Bool
XAADestroyPixmap(PixmapPtr pPix)
{
    ScreenPtr pScreen = pPix->drawable.pScreen;
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
    Bool ret;

    if (pPix->refcnt == 1) {
        if (pPriv->flags & OFFSCREEN) {
            if (pPriv->flags & DGA_PIXMAP)
                free(pPriv->offscreenArea);
            else {
                FBAreaPtr area = pPriv->offscreenArea;
                PixmapLinkPtr pLink = infoRec->OffscreenPixmaps;
                PixmapLinkPtr prev = NULL;

                while (pLink->pPix != pPix) {
                    prev = pLink;
                    pLink = pLink->next;
                }

                if (prev)
                    prev->next = pLink->next;
                else
                    infoRec->OffscreenPixmaps = pLink->next;

                if (!area)
                    area = pLink->area;

                xf86FreeOffscreenArea(area);
                pPriv->offscreenArea = NULL;
                free(pLink);
            }
        }

        if (pPriv->freeData) {  /* pixmaps that were once in video ram */
            free(pPix->devPrivate.ptr);
            pPix->devPrivate.ptr = NULL;
        }
    }

    XAA_SCREEN_PROLOGUE(pScreen, DestroyPixmap);
    ret = (*pScreen->DestroyPixmap) (pPix);
    XAA_SCREEN_EPILOGUE(pScreen, DestroyPixmap, XAADestroyPixmap);

    return ret;
}

static Bool
XAAChangeWindowAttributes(WindowPtr pWin, unsigned long mask)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    Bool ret;

    XAA_SCREEN_PROLOGUE(pScreen, ChangeWindowAttributes);
    ret = (*pScreen->ChangeWindowAttributes) (pWin, mask);
    XAA_SCREEN_EPILOGUE(pScreen, ChangeWindowAttributes,
                        XAAChangeWindowAttributes);

    /* we have to assume that shared memory pixmaps are dirty
       because we can't wrap operations on them */

    if ((mask & CWBackPixmap) && (pWin->backgroundState == BackgroundPixmap) &&
        PIXMAP_IS_SHARED(pWin->background.pixmap)) {
        XAAPixmapPtr pPixPriv = XAA_GET_PIXMAP_PRIVATE(pWin->background.pixmap);

        pPixPriv->flags |= DIRTY;
    }
    if ((mask & CWBorderPixmap) && !(pWin->borderIsPixel) &&
        PIXMAP_IS_SHARED(pWin->border.pixmap)) {
        XAAPixmapPtr pPixPriv = XAA_GET_PIXMAP_PRIVATE(pWin->border.pixmap);

        pPixPriv->flags |= DIRTY;
    }

    return ret;
}

/*  These two aren't really needed for anything */

static Bool
XAAEnterVT(int index, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[index];
    Bool ret;
    ScreenPtr pScreen = screenInfo.screens[index];
    XAAScreenPtr pScreenPriv =
        (XAAScreenPtr) dixLookupPrivate(&pScreen->devPrivates, XAAScreenKey);

    pScrn->EnterVT = pScreenPriv->EnterVT;
    ret = ((*pScreenPriv->EnterVT) (index, flags));
    pScreenPriv->EnterVT = pScrn->EnterVT;
    pScrn->EnterVT = XAAEnterVT;
    return ret;
}

static void
XAALeaveVT(int index, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[index];
    ScreenPtr pScreen = screenInfo.screens[index];
    XAAScreenPtr pScreenPriv =
        (XAAScreenPtr) dixLookupPrivate(&pScreen->devPrivates, XAAScreenKey);
    XAAInfoRecPtr infoRec = pScreenPriv->AccelInfoRec;

    if (infoRec->NeedToSync) {
        (*infoRec->Sync) (infoRec->pScrn);
        infoRec->NeedToSync = FALSE;
    }

    pScrn->LeaveVT = pScreenPriv->LeaveVT;
    (*pScreenPriv->LeaveVT) (index, flags);
    pScreenPriv->LeaveVT = pScrn->LeaveVT;
    pScrn->LeaveVT = XAALeaveVT;
}

typedef struct {
    Bool UsingPixmapCache;
    Bool CanDoColor8x8;
    Bool CanDoMono8x8;
} SavedCacheState, *SavedCacheStatePtr;

static int
XAASetDGAMode(int index, int num, DGADevicePtr devRet)
{
    ScreenPtr pScreen = screenInfo.screens[index];
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
    XAAScreenPtr pScreenPriv =
        (XAAScreenPtr) dixLookupPrivate(&pScreen->devPrivates, XAAScreenKey);
    int ret;

    if (!num && infoRec->dgaSaves) {    /* restore old pixmap cache state */
        SavedCacheStatePtr state = (SavedCacheStatePtr) infoRec->dgaSaves;

        infoRec->UsingPixmapCache = state->UsingPixmapCache;
        infoRec->CanDoColor8x8 = state->CanDoColor8x8;
        infoRec->CanDoMono8x8 = state->CanDoMono8x8;
        free(infoRec->dgaSaves);
        infoRec->dgaSaves = NULL;
    }

    ret = (*pScreenPriv->SetDGAMode) (index, num, devRet);
    if (ret != Success)
        return ret;

    if (num && devRet->pPix) {  /* accelerate this pixmap */
        XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE(devRet->pPix);
        FBAreaPtr area;

        if ((area = malloc(sizeof(FBArea)))) {
            area->pScreen = pScreen;
            area->box.x1 = 0;
            area->box.x2 = 0;
            area->box.y1 = devRet->mode->pixmapWidth;
            area->box.y2 = devRet->mode->pixmapHeight;
            area->granularity = 0;
            area->MoveAreaCallback = 0;
            area->RemoveAreaCallback = 0;
            area->devPrivate.ptr = 0;

            pixPriv->flags |= OFFSCREEN | DGA_PIXMAP;
            pixPriv->offscreenArea = area;

            if (!infoRec->dgaSaves) {   /* save pixmap cache state */
                SavedCacheStatePtr state = malloc(sizeof(SavedCacheState));

                state->UsingPixmapCache = infoRec->UsingPixmapCache;
                state->CanDoColor8x8 = infoRec->CanDoColor8x8;
                state->CanDoMono8x8 = infoRec->CanDoMono8x8;
                infoRec->dgaSaves = (char *) state;

                infoRec->UsingPixmapCache = FALSE;
                if (infoRec->PixmapCacheFlags & CACHE_MONO_8x8)
                    infoRec->CanDoMono8x8 = FALSE;
                if (infoRec->PixmapCacheFlags & CACHE_COLOR_8x8)
                    infoRec->CanDoColor8x8 = FALSE;
            }
        }
    }

    return ret;
}

static void
XAAEnableDisableFBAccess(int index, Bool enable)
{
    ScreenPtr pScreen = screenInfo.screens[index];
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
    XAAScreenPtr pScreenPriv =
        (XAAScreenPtr) dixLookupPrivate(&pScreen->devPrivates, XAAScreenKey);

    if (!enable) {
        if ((infoRec->Flags & OFFSCREEN_PIXMAPS) && (infoRec->OffscreenPixmaps))
            XAAMoveOutOffscreenPixmaps(pScreen);
        if (infoRec->Flags & PIXMAP_CACHE)
            XAAInvalidatePixmapCache(pScreen);
        SwitchedOut = TRUE;
    }

    (*pScreenPriv->EnableDisableFBAccess) (index, enable);

    if (enable) {
        if ((infoRec->Flags & OFFSCREEN_PIXMAPS) && (infoRec->OffscreenPixmaps))
            XAAMoveInOffscreenPixmaps(pScreen);
        SwitchedOut = FALSE;
    }
}
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d26 1
a26 1
#define MAX_PREALLOC_MEM	65536	/* MUST be >= 1024 */
d32 2
a33 2
			unsigned int format, unsigned long planemask,
			char *pdstLine);
d35 1
a35 1
			int *pwidth, int nspans, char *pdstStart);
d37 1
a37 1
				 unsigned usage_hint);
d39 5
a43 5
static Bool XAAEnterVT (int index, int flags);
static void XAALeaveVT (int index, int flags);
static int  XAASetDGAMode(int index, int num, DGADevicePtr devRet);
static void XAAEnableDisableFBAccess (int index, Bool enable);
static Bool XAAChangeWindowAttributes (WindowPtr pWin, unsigned long mask);
d46 1
d49 1
d52 1
d55 3
a57 1
DevPrivateKey XAAGetScreenKey(void) {
d61 3
a63 1
DevPrivateKey XAAGetGCKey(void) {
d67 3
a69 1
DevPrivateKey XAAGetPixmapKey(void) {
d82 2
a83 2
    if(infoRec)
	infoRec->CachePixelGranularity = -1;
d91 5
a95 1
    if(!infoRec) return;
a96 3
    if(infoRec->ClosePixmapCache)
	(*infoRec->ClosePixmapCache)(infoRec->pScrn->pScreen);
   
a103 1

d110 1
a110 1
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);
d114 2
a115 2
	return TRUE;
    
d117 1
a117 1
	return FALSE;
d119 3
a121 2
    if (!dixRegisterPrivateKey(&XAAPixmapKeyRec, PRIVATE_PIXMAP, sizeof(XAAPixmapRec)))
	return FALSE;
d124 1
a124 1
	return FALSE;
d127 1
a127 1
	return FALSE;
d131 8
a138 13
    if(!xf86FBManagerRunning(pScreen))
	infoRec->Flags &= ~(PIXMAP_CACHE | OFFSCREEN_PIXMAPS);
    if(!(infoRec->Flags & LINEAR_FRAMEBUFFER))
	infoRec->Flags &= ~OFFSCREEN_PIXMAPS;
   
    if(!infoRec->FullPlanemask) { /* for backwards compatibility */
	infoRec->FullPlanemask =  (1 << pScrn->depth) - 1;
	infoRec->FullPlanemasks[pScrn->depth - 1] = infoRec->FullPlanemask;
    }

    for(i = 0; i < 32; i++) {
	if(!infoRec->FullPlanemasks[i]) /* keep any set by caller */
	    infoRec->FullPlanemasks[i] = (1 << (i+1)) - 1;	
d141 7
a147 1
    if(!XAAInitAccel(pScreen, infoRec)) return FALSE;
d151 6
a156 7
    
    if(!infoRec->GetImage)
	infoRec->GetImage = XAAGetImage;
    if(!infoRec->GetSpans)
	infoRec->GetSpans = XAAGetSpans;
    if(!infoRec->CopyWindow)
	infoRec->CopyWindow = XAACopyWindow;
d176 1
a176 1
    pScrn->EnterVT = XAAEnterVT; 
d185 5
a189 6
    if (ps)
    {
	pScreenPriv->Composite = ps->Composite;
	ps->Composite = XAAComposite;
	pScreenPriv->Glyphs = ps->Glyphs;
	ps->Glyphs = XAAGlyphs;
d191 1
a191 1
    if(pScrn->overlayFlags & OVERLAY_8_32_PLANAR)
d195 2
a196 2
    if(infoRec->PreAllocMem)
    	infoRec->PreAllocSize = MAX_PREALLOC_MEM;
d198 3
a200 3
    if(infoRec->Flags & PIXMAP_CACHE) 
	xf86RegisterFreeBoxCallback(pScreen, infoRec->InitPixmapCache,
						(pointer)infoRec);
d202 2
a203 2
    if(infoRec->Flags & MICROSOFT_ZERO_LINE_BIAS)
	miSetZeroLineBias(pScreen, OCTANT1 | OCTANT2 | OCTANT3 | OCTANT4);
a215 2


d217 1
a217 1
XAACloseScreen (int i, ScreenPtr pScreen)
d220 2
a221 2
    XAAScreenPtr pScreenPriv = 
	(XAAScreenPtr)dixLookupPrivate(&pScreen->devPrivates, XAAScreenKey);
d223 2
a224 2
    pScrn->EnterVT = pScreenPriv->EnterVT; 
    pScrn->LeaveVT = pScreenPriv->LeaveVT; 
d226 1
a226 1
   
d245 3
a247 7
XAAGetImage (
    DrawablePtr pDraw,
    int	sx, int sy, int w, int h,
    unsigned int    format,
    unsigned long   planemask,
    char	    *pdstLine 
)
d253 14
a266 16
    if(pScrn->vtSema && 
	((pDraw->type == DRAWABLE_WINDOW) || IS_OFFSCREEN_PIXMAP(pDraw))) 
    {
	if(infoRec->ReadPixmap && (format == ZPixmap) && 
	   ((planemask & infoRec->FullPlanemasks[pDraw->depth - 1]) == 
                           infoRec->FullPlanemasks[pDraw->depth - 1]) &&
	   (pDraw->bitsPerPixel == BitsPerPixel(pDraw->depth)))
	{
	    (*infoRec->ReadPixmap)(pScrn, 
		   sx + pDraw->x, sy + pDraw->y, w, h,
		   (unsigned char *)pdstLine,
		   PixmapBytePad(w, pDraw->depth), 
		   pDraw->bitsPerPixel, pDraw->depth);
	    return;
	}
	SYNC_CHECK(pDraw);
d269 1
a269 1
    XAA_SCREEN_PROLOGUE (pScreen, GetImage);
d271 1
a271 1
    XAA_SCREEN_EPILOGUE (pScreen, GetImage, XAAGetImage);
d275 2
a276 8
XAAGetSpans (
    DrawablePtr pDraw,
    int		wMax,
    DDXPointPtr	ppt,
    int		*pwidth,
    int		nspans,
    char	*pdstStart
)
d279 5
a283 4
    XAA_SCREEN_PROLOGUE (pScreen, GetSpans);
    if(xf86Screens[pScreen->myNum]->vtSema && 
	((pDraw->type == DRAWABLE_WINDOW) || IS_OFFSCREEN_PIXMAP(pDraw))) {
	SYNC_CHECK(pDraw);
d286 1
a286 1
    XAA_SCREEN_EPILOGUE (pScreen, GetSpans, XAAGetSpans);
a288 1

d290 1
a290 1
XAAPixmapBPP (ScreenPtr pScreen, int depth)
d292 5
a296 5
    PixmapPtr	pPix;
    int		bpp;
    DestroyPixmapProcPtr    destroyPixmap;
    
    XAA_SCREEN_PROLOGUE (pScreen, CreatePixmap);
d298 2
a299 2
				     CREATE_PIXMAP_USAGE_SCRATCH);
    XAA_SCREEN_EPILOGUE (pScreen, CreatePixmap, XAACreatePixmap);
d301 1
a301 1
	return 0;
d304 1
a304 1
    XAA_SCREEN_PROLOGUE (pScreen, DestroyPixmap);
d306 1
a306 1
    XAA_SCREEN_EPILOGUE (pScreen, DestroyPixmap, destroyPixmap);
d311 1
a311 1
XAAInitializeOffscreenDepths (ScreenPtr pScreen)
d313 4
a316 4
    XAAInfoRecPtr   infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
    ScrnInfoPtr	    pScrn = xf86Screens[pScreen->myNum];
    int		    d, dep;
    
d320 5
a324 5
	for (d = 0; d < pScreen->numDepths; d++) {
	    dep = pScreen->allowedDepths[d].depth;
	    if (XAAPixmapBPP (pScreen, dep) == pScrn->bitsPerPixel)
		infoRec->offscreenDepths |= (1 << (dep - 1));
	}
d328 1
a328 1
static PixmapPtr 
d338 2
a339 2
	return NullPixmap;
    
d341 1
a341 1
	XAAInitializeOffscreenDepths (pScreen);
d343 6
a348 7
    if(pScrn->vtSema &&
	(usage_hint != CREATE_PIXMAP_USAGE_GLYPH_PICTURE) &&
	(infoRec->offscreenDepths & (1 << (depth - 1))) &&
	(size >= MIN_OFFPIX_SIZE) && !SwitchedOut &&
	(!infoRec->maxOffPixWidth || (w <= infoRec->maxOffPixWidth)) &&
	(!infoRec->maxOffPixHeight || (h <= infoRec->maxOffPixHeight)) )
    {
d350 1
a350 1
	PixmapPtr pScreenPix;
d354 13
a366 6
	switch(pScrn->bitsPerPixel) {
        case 24: 
        case 8:  gran = 4;  break;
        case 16: gran = 2;  break;
        case 32: gran = 1;  break;
        default: break;
d369 2
a370 2
        if(BITMAP_SCANLINE_PAD == 64)
           gran *= 2;
d372 4
a375 4
        if(!(area = xf86AllocateOffscreenArea(pScreen, w, h, gran, 0,
                                XAARemoveAreaCallback, NULL))) {
	    goto BAILOUT;
	}
d377 1
a377 1
        if(!(pLink = malloc(sizeof(PixmapLink)))) {
d379 2
a380 2
	    goto BAILOUT;
	}
d382 3
a384 3
	XAA_SCREEN_PROLOGUE (pScreen, CreatePixmap);
	pPix = (*pScreen->CreatePixmap) (pScreen, 0, 0, depth, usage_hint);
	XAA_SCREEN_EPILOGUE (pScreen, CreatePixmap, XAACreatePixmap);
d386 2
a387 2
	if (!pPix) {
	    free(pLink);
d389 23
a411 23
	    goto BAILOUT;
	}
	
	pScreenPix = (*pScreen->GetScreenPixmap)(pScreen);

	pPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
	pPix->drawable.x = area->box.x1;
	pPix->drawable.y = area->box.y1;
	pPix->drawable.width = w;
	pPix->drawable.height = h;
	pPix->drawable.bitsPerPixel = pScrn->bitsPerPixel;
	pPix->devKind = pScreenPix->devKind;
	pPix->devPrivate.ptr = pScreenPix->devPrivate.ptr;
	area->devPrivate.ptr = pPix;

	pPriv->flags = OFFSCREEN;
	pPriv->offscreenArea = area;
 	pPriv->freeData = FALSE;
	    
	pLink->next = infoRec->OffscreenPixmaps;
	pLink->pPix = pPix;
	infoRec->OffscreenPixmaps = pLink;
	return pPix;
d413 2
a414 2
BAILOUT:
    XAA_SCREEN_PROLOGUE (pScreen, CreatePixmap);
d416 1
a416 1
    XAA_SCREEN_EPILOGUE (pScreen, CreatePixmap, XAACreatePixmap);
d418 7
a424 7
    if(pPix) {
       pPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
       pPriv->flags = 0;
       pPriv->offscreenArea = NULL;
       pPriv->freeData = FALSE;
       if(!w || !h) /* either scratch or shared memory */
	    pPriv->flags |= SHARED_PIXMAP;
d430 1
a430 1
static Bool 
d438 4
a441 4
    if(pPix->refcnt == 1) {
        if(pPriv->flags & OFFSCREEN) {
	    if(pPriv->flags & DGA_PIXMAP)
	        free(pPriv->offscreenArea);
d443 21
a463 18
	        FBAreaPtr area = pPriv->offscreenArea;
		PixmapLinkPtr pLink = infoRec->OffscreenPixmaps;
	        PixmapLinkPtr prev = NULL;

		while(pLink->pPix != pPix) {
		    prev = pLink;
		    pLink = pLink->next;
		}

	        if(prev) prev->next = pLink->next;
		else infoRec->OffscreenPixmaps = pLink->next;

	        if(!area) area = pLink->area;

	        xf86FreeOffscreenArea(area);
	        pPriv->offscreenArea = NULL;
	        free(pLink);
	    } 
d466 4
a469 4
        if(pPriv->freeData) { /* pixmaps that were once in video ram */
	    free(pPix->devPrivate.ptr);
	    pPix->devPrivate.ptr = NULL;
	}
d471 2
a472 2
    
    XAA_SCREEN_PROLOGUE (pScreen, DestroyPixmap);
d474 2
a475 2
    XAA_SCREEN_EPILOGUE (pScreen, DestroyPixmap, XAADestroyPixmap);
 
d480 1
a480 1
XAAChangeWindowAttributes (WindowPtr pWin, unsigned long mask)
d482 2
a483 2
   ScreenPtr pScreen = pWin->drawable.pScreen;
   Bool ret;
d485 4
a488 3
   XAA_SCREEN_PROLOGUE (pScreen, ChangeWindowAttributes);
   ret = (*pScreen->ChangeWindowAttributes) (pWin, mask);
   XAA_SCREEN_EPILOGUE (pScreen, ChangeWindowAttributes, XAAChangeWindowAttributes);
d490 2
a491 2
   /* we have to assume that shared memory pixmaps are dirty
      because we can't wrap operations on them */
d493 2
a494 3
   if((mask & CWBackPixmap) && (pWin->backgroundState == BackgroundPixmap) &&
      PIXMAP_IS_SHARED(pWin->background.pixmap))
   {
d496 5
a500 5
	pPixPriv->flags |= DIRTY;
   }
   if((mask & CWBorderPixmap) && !(pWin->borderIsPixel) &&
      PIXMAP_IS_SHARED(pWin->border.pixmap))
   {
d502 1
d504 1
a504 1
   }
d506 1
a506 1
   return ret;
a508 2


d511 1
a511 1
static Bool 
d517 2
a518 2
    XAAScreenPtr pScreenPriv = 
	(XAAScreenPtr)dixLookupPrivate(&pScreen->devPrivates, XAAScreenKey);
d521 1
a521 1
    ret = ((*pScreenPriv->EnterVT)(index, flags));
d527 1
a527 1
static void 
d532 2
a533 2
    XAAScreenPtr pScreenPriv = 
	(XAAScreenPtr)dixLookupPrivate(&pScreen->devPrivates, XAAScreenKey);
d536 2
a537 2
    if(infoRec->NeedToSync) {
        (*infoRec->Sync)(infoRec->pScrn);
d542 1
a542 1
    (*pScreenPriv->LeaveVT)(index, flags);
d548 3
a550 3
   Bool UsingPixmapCache;
   Bool CanDoColor8x8;
   Bool CanDoMono8x8;
d553 1
a553 1
static int  
d558 2
a559 2
    XAAScreenPtr pScreenPriv = 
	(XAAScreenPtr)dixLookupPrivate(&pScreen->devPrivates, XAAScreenKey);
d562 47
a608 46
    if (!num && infoRec->dgaSaves) { /* restore old pixmap cache state */
	SavedCacheStatePtr state = (SavedCacheStatePtr)infoRec->dgaSaves;
	
	infoRec->UsingPixmapCache = state->UsingPixmapCache;	
	infoRec->CanDoColor8x8 = state->CanDoColor8x8;	
	infoRec->CanDoMono8x8 = state->CanDoMono8x8;
	free(infoRec->dgaSaves);
	infoRec->dgaSaves = NULL;
    }

    ret = (*pScreenPriv->SetDGAMode)(index, num, devRet);
    if(ret != Success) return ret;

    if(num && devRet->pPix) {  /* accelerate this pixmap */
	XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE(devRet->pPix);
	FBAreaPtr area;

	if((area = malloc(sizeof(FBArea)))) {
	    area->pScreen = pScreen;
	    area->box.x1 = 0;
	    area->box.x2 = 0;
	    area->box.y1 = devRet->mode->pixmapWidth;
	    area->box.y2 = devRet->mode->pixmapHeight;
	    area->granularity = 0;
	    area->MoveAreaCallback = 0;
	    area->RemoveAreaCallback = 0;
	    area->devPrivate.ptr = 0;	

	    pixPriv->flags |= OFFSCREEN | DGA_PIXMAP;
	    pixPriv->offscreenArea = area;

	    if(!infoRec->dgaSaves) { /* save pixmap cache state */
		SavedCacheStatePtr state = malloc(sizeof(SavedCacheState));
	
		state->UsingPixmapCache = infoRec->UsingPixmapCache;	
		state->CanDoColor8x8 = infoRec->CanDoColor8x8;	
		state->CanDoMono8x8 = infoRec->CanDoMono8x8;	
		infoRec->dgaSaves = (char*)state;

		infoRec->UsingPixmapCache = FALSE;
		if(infoRec->PixmapCacheFlags & CACHE_MONO_8x8)
		    infoRec->CanDoMono8x8 = FALSE;
		if(infoRec->PixmapCacheFlags & CACHE_COLOR_8x8)
		    infoRec->CanDoColor8x8 = FALSE;
	    }
	}
a613 2


d615 1
a615 1
XAAEnableDisableFBAccess (int index, Bool enable)
d619 2
a620 2
    XAAScreenPtr pScreenPriv = 
	(XAAScreenPtr)dixLookupPrivate(&pScreen->devPrivates, XAAScreenKey);
d622 14
a635 14
    if(!enable) {
	if((infoRec->Flags & OFFSCREEN_PIXMAPS) && (infoRec->OffscreenPixmaps))
	    XAAMoveOutOffscreenPixmaps(pScreen);
	if(infoRec->Flags & PIXMAP_CACHE)
	    XAAInvalidatePixmapCache(pScreen);
	SwitchedOut = TRUE;
    }

    (*pScreenPriv->EnableDisableFBAccess)(index, enable);

    if(enable) {
	if((infoRec->Flags & OFFSCREEN_PIXMAPS) && (infoRec->OffscreenPixmaps))
	    XAAMoveInOffscreenPixmaps(pScreen);
	SwitchedOut = FALSE;
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d45 6
a50 6
static int XAAScreenKeyIndex;
static DevPrivateKey XAAScreenKey = &XAAScreenKeyIndex;
static int XAAGCKeyIndex;
static DevPrivateKey XAAGCKey = &XAAGCKeyIndex;
static int XAAPixmapKeyIndex;
static DevPrivateKey XAAPixmapKey = &XAAPixmapKeyIndex;
d72 1
a72 1
    infoRec = xcalloc(1, sizeof(XAAInfoRec));
d87 1
a87 2
    if(infoRec->PreAllocMem)
	xfree(infoRec->PreAllocMem);
d89 1
a89 2
    if(infoRec->PixmapCachePrivate)
	xfree(infoRec->PixmapCachePrivate);
d91 1
a91 1
    xfree(infoRec);
a100 1
#ifdef RENDER
a101 1
#endif
d107 1
a107 1
    if (!dixRequestPrivate(XAAGCKey, sizeof(XAAGCRec)))
d110 1
a110 1
    if (!dixRequestPrivate(XAAPixmapKey, sizeof(XAAPixmapRec)))
d113 4
a116 1
    if (!(pScreenPriv = xalloc(sizeof(XAAScreenRec))))
a174 1
#ifdef RENDER
a181 1
#endif    
d185 1
a185 1
    infoRec->PreAllocMem = xalloc(MAX_PREALLOC_MEM);
d232 1
a232 1
    xfree ((pointer) pScreenPriv);
d376 1
a376 1
        if(!(pLink = xalloc(sizeof(PixmapLink)))) {
d386 1
a386 1
	    xfree (pLink);
d440 1
a440 1
	        xfree(pPriv->offscreenArea);
d458 1
a458 1
	        xfree(pLink);
d463 1
a463 1
	    xfree(pPix->devPrivate.ptr);
d511 2
d517 5
a521 1
    return((*pScreenPriv->EnterVT)(index, flags));
d527 1
d538 1
d540 2
d565 1
a565 1
	xfree(infoRec->dgaSaves);
d576 1
a576 1
	if((area = xalloc(sizeof(FBArea)))) {
d591 1
a591 1
		SavedCacheStatePtr state = xalloc(sizeof(SavedCacheState));
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d68 1
a68 1
XAACreateInfoRec()
d79 1
a79 1
void 
d97 1
a97 1
Bool 
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d22 3
d45 6
a50 3
static DevPrivateKey XAAScreenKey = &XAAScreenKey;
static DevPrivateKey XAAGCKey = &XAAGCKey;
static DevPrivateKey XAAPixmapKey = &XAAPixmapKey;
@


1.1
log
@Initial revision
@
text
@d33 2
a34 1
static PixmapPtr XAACreatePixmap(ScreenPtr pScreen, int w, int h, int depth);
a35 4
static void XAARestoreAreas (PixmapPtr pPixmap, RegionPtr prgnRestore, 
			int xorg, int yorg, WindowPtr pWin);
static void XAASaveAreas (PixmapPtr pPixmap, RegionPtr prgnSave, 
			int xorg, int yorg, WindowPtr pWin);
d42 3
a44 8
/*
 * XXX These three should be static, but that breaks ABI compat with XF4.4
 * and Xorg 6.7.0 modules.  DO NOT use them in new code, you should never
 * be setting them, and you've got Get functions below.
 */
int XAAScreenIndex = -1;
int XAAGCIndex = -1;
int XAAPixmapIndex = -1;
d46 2
a47 4
static unsigned long XAAGeneration = 0;

int XAAGetScreenIndex(void) {
    return XAAScreenIndex;
d50 2
a51 2
int XAAGetGCIndex(void) {
    return XAAGCIndex;
d54 2
a55 2
int XAAGetPixmapIndex(void) {
    return XAAPixmapIndex;
d105 1
a105 10
    if (XAAGeneration != serverGeneration) {
	if (	((XAAScreenIndex = AllocateScreenPrivateIndex()) < 0) ||
		((XAAGCIndex = AllocateGCPrivateIndex()) < 0) ||
		((XAAPixmapIndex = AllocatePixmapPrivateIndex()) < 0))
		return FALSE;

	XAAGeneration = serverGeneration;
    }

    if (!AllocateGCPrivate(pScreen, XAAGCIndex, sizeof(XAAGCRec)))
d108 1
a108 1
    if (!AllocatePixmapPrivate(pScreen, XAAPixmapIndex, sizeof(XAAPixmapRec)))
d114 1
a114 1
    pScreen->devPrivates[XAAScreenIndex].ptr = (pointer)pScreenPriv;
a139 4
    if(!infoRec->PaintWindowBackground)
	infoRec->PaintWindowBackground = XAAPaintWindow;
    if(!infoRec->PaintWindowBorder)
	infoRec->PaintWindowBorder = XAAPaintWindow;
a141 4
    if(!infoRec->SaveAreas)
	infoRec->SaveAreas = XAASaveAreas;
    if(!infoRec->RestoreAreas)
	infoRec->RestoreAreas = XAARestoreAreas;
a150 4
    pScreenPriv->PaintWindowBackground = pScreen->PaintWindowBackground;
    pScreen->PaintWindowBackground = infoRec->PaintWindowBackground;
    pScreenPriv->PaintWindowBorder = pScreen->PaintWindowBorder;
    pScreen->PaintWindowBorder = infoRec->PaintWindowBorder;
a156 6
    pScreenPriv->BackingStoreFuncs.RestoreAreas = 
			pScreen->BackingStoreFuncs.RestoreAreas;
    pScreen->BackingStoreFuncs.RestoreAreas = infoRec->RestoreAreas;
    pScreenPriv->BackingStoreFuncs.SaveAreas = 
			pScreen->BackingStoreFuncs.SaveAreas;
    pScreen->BackingStoreFuncs.SaveAreas = infoRec->SaveAreas;
d193 8
d211 1
a211 1
	(XAAScreenPtr) pScreen->devPrivates[XAAScreenIndex].ptr;
a220 2
    pScreen->PaintWindowBackground = pScreenPriv->PaintWindowBackground;
    pScreen->PaintWindowBorder = pScreenPriv->PaintWindowBorder;
a224 4
    pScreen->BackingStoreFuncs.RestoreAreas = 
			pScreenPriv->BackingStoreFuncs.RestoreAreas;
    pScreen->BackingStoreFuncs.SaveAreas = 
			pScreenPriv->BackingStoreFuncs.SaveAreas;
a290 131
static void
XAASaveAreas (
    PixmapPtr pPixmap,
    RegionPtr prgnSave,
    int       xorg,
    int       yorg,
    WindowPtr pWin
){
    ScreenPtr pScreen = pPixmap->drawable.pScreen;
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);

    if(IS_OFFSCREEN_PIXMAP(pPixmap)) {
	BoxPtr pbox = REGION_RECTS(prgnSave);
	int nboxes = REGION_NUM_RECTS(prgnSave);

	(*infoRec->SetupForScreenToScreenCopy)(pScrn, 1, 1, GXcopy, ~0, -1);
	while(nboxes--) {
	    (*infoRec->SubsequentScreenToScreenCopy)(pScrn, 
		pbox->x1 + xorg, pbox->y1 + yorg, 
		pPixmap->drawable.x + pbox->x1, 
		pPixmap->drawable.y + pbox->y1,
		pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
	    pbox++;
	}
	SET_SYNC_FLAG(infoRec);
	return;
    }

    if(xf86Screens[pScreen->myNum]->vtSema && infoRec->ReadPixmap &&
	(pWin->drawable.bitsPerPixel == pPixmap->drawable.bitsPerPixel)) {
	BoxPtr pbox = REGION_RECTS(prgnSave);
	int nboxes = REGION_NUM_RECTS(prgnSave);
	int Bpp =  pPixmap->drawable.bitsPerPixel >> 3;
	unsigned char *dstp = (unsigned char*)pPixmap->devPrivate.ptr;

	while(nboxes--) {
	    (*infoRec->ReadPixmap)(infoRec->pScrn,
		pbox->x1 + xorg, pbox->y1 + yorg, 
		pbox->x2 - pbox->x1, pbox->y2 - pbox->y1, 
		dstp + (pPixmap->devKind * pbox->y1) + (pbox->x1 * Bpp),
		pPixmap->devKind,
		pPixmap->drawable.bitsPerPixel, pPixmap->drawable.depth);
	    pbox++;
	}
	return;
    }

    XAA_SCREEN_PROLOGUE (pScreen, BackingStoreFuncs.SaveAreas);
    if(pScrn->vtSema) {
	SYNC_CHECK(&pWin->drawable);
    }
    (*pScreen->BackingStoreFuncs.SaveAreas) (
		pPixmap, prgnSave, xorg, yorg, pWin);

    XAA_SCREEN_EPILOGUE (pScreen, BackingStoreFuncs.SaveAreas,
			 XAASaveAreas);
}

static void
XAARestoreAreas (    
    PixmapPtr pPixmap,
    RegionPtr prgnRestore,
    int       xorg,
    int       yorg,
    WindowPtr pWin 
){
    ScreenPtr pScreen = pPixmap->drawable.pScreen;
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);

    if(IS_OFFSCREEN_PIXMAP(pPixmap)) {
	BoxPtr pbox = REGION_RECTS(prgnRestore);
	int nboxes = REGION_NUM_RECTS(prgnRestore);
	int pm = ~0;

	if((pScrn->overlayFlags & OVERLAY_8_32_PLANAR) && 
					(pWin->drawable.depth == 24))
	   pm = 0x00ffffff;

	(*infoRec->SetupForScreenToScreenCopy)(pScrn, 1, 1, GXcopy, pm, -1);
	while(nboxes--) {
	    (*infoRec->SubsequentScreenToScreenCopy)(pScrn, 
		pPixmap->drawable.x + pbox->x1 - xorg, 
		pPixmap->drawable.y + pbox->y1 - yorg,
		pbox->x1, pbox->y1, pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
	    pbox++;
	}
	SET_SYNC_FLAG(infoRec);
	return;
    }

    if(pScrn->vtSema && infoRec->WritePixmap &&
	!(infoRec->WritePixmapFlags & NO_GXCOPY) &&
	((pWin->drawable.bitsPerPixel == pPixmap->drawable.bitsPerPixel) ||
		((pWin->drawable.bitsPerPixel == 24) &&  
		 (pPixmap->drawable.bitsPerPixel == 32) &&
		 (infoRec->WritePixmapFlags & CONVERT_32BPP_TO_24BPP)))) {
	BoxPtr pbox = REGION_RECTS(prgnRestore);
	int nboxes = REGION_NUM_RECTS(prgnRestore);
	int Bpp =  pPixmap->drawable.bitsPerPixel >> 3;
	unsigned char *srcp = (unsigned char*)pPixmap->devPrivate.ptr;
	int pm = ~0;

	if((pScrn->overlayFlags & OVERLAY_8_32_PLANAR) && 
					(pWin->drawable.depth == 24))
	   pm = 0x00ffffff;
 
	while(nboxes--) {
	    (*infoRec->WritePixmap)(pScrn, pbox->x1, pbox->y1, 
		pbox->x2 - pbox->x1, pbox->y2 - pbox->y1, 
		srcp + (pPixmap->devKind * (pbox->y1 - yorg)) + 
				((pbox->x1 - xorg) * Bpp), 
		pPixmap->devKind, GXcopy, pm, -1, 
		pPixmap->drawable.bitsPerPixel, pPixmap->drawable.depth);
	    pbox++;
	}
	return;
    }

    XAA_SCREEN_PROLOGUE (pScreen, BackingStoreFuncs.RestoreAreas);
    if(pScrn->vtSema) {
	SYNC_CHECK(&pWin->drawable);
    }
    (*pScreen->BackingStoreFuncs.RestoreAreas) (
		pPixmap, prgnRestore, xorg, yorg, pWin);

    XAA_SCREEN_EPILOGUE (pScreen, BackingStoreFuncs.RestoreAreas,
				 XAARestoreAreas);
}

d299 2
a300 1
    pPix = (*pScreen->CreatePixmap) (pScreen, 1, 1, depth);
d331 1
a331 1
XAACreatePixmap(ScreenPtr pScreen, int w, int h, int depth)
d345 3
a347 1
    if(pScrn->vtSema && (infoRec->offscreenDepths & (1 << (depth - 1))) &&
d379 1
a379 1
	pPix = (*pScreen->CreatePixmap) (pScreen, 0, 0, depth);
d411 1
a411 1
    pPix = (*pScreen->CreatePixmap) (pScreen, w, h, depth);
d510 1
a510 1
	(XAAScreenPtr) pScreen->devPrivates[XAAScreenIndex].ptr;
d520 1
a520 1
	(XAAScreenPtr) pScreen->devPrivates[XAAScreenIndex].ptr;
d543 1
a543 1
	(XAAScreenPtr) pScreen->devPrivates[XAAScreenIndex].ptr;
d605 1
a605 1
	(XAAScreenPtr) pScreen->devPrivates[XAAScreenIndex].ptr;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d45 8
a52 3
static int XAAScreenIndex = -1;
static int XAAGCIndex = -1;
static int XAAPixmapIndex = -1;
a228 8

#ifdef COMPOSITE
    /* Initialize the composite wrapper.  This needs to happen after the
     * wrapping above (so it comes before us), but before all other extensions,
     * so it doesn't confuse them. (particularly damage).
     */
    miInitializeCompositeWrapper(pScreen);
#endif
@

