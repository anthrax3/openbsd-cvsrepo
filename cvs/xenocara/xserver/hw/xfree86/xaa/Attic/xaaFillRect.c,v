head	1.5;
access;
symbols
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.06.07.17.28.53;	author matthieu;	state dead;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.48;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.48;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"

#include <X11/X.h>
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "xf86str.h"
#include "xaa.h"
#include "xaalocal.h"

static void XAARenderSolidRects(GCPtr, int, BoxPtr, int, int);
static void XAARenderColor8x8Rects(GCPtr, int, BoxPtr, int, int);
static void XAARenderMono8x8Rects(GCPtr, int, BoxPtr, int, int);
static void XAARenderColorExpandRects(GCPtr, int, BoxPtr, int, int);
static void XAARenderCacheExpandRects(GCPtr, int, BoxPtr, int, int);
static void XAARenderCacheBltRects(GCPtr, int, BoxPtr, int, int);
static void XAARenderImageWriteRects(GCPtr, int, BoxPtr, int, int);
static void XAARenderPixmapCopyRects(GCPtr, int, BoxPtr, int, int);

void
XAAPolyFillRect(DrawablePtr pDraw, GCPtr pGC, int nrectFill,    /* number of rectangles to fill */
                xRectangle *prectInit   /* Pointer to first rectangle to fill */
    )
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    int xorg = pDraw->x;
    int yorg = pDraw->y;
    int type = 0;
    ClipAndRenderRectsFunc function;

    if ((nrectFill <= 0) || !pGC->planemask)
        return;

    if (!RegionNumRects(pGC->pCompositeClip))
        return;

    switch (pGC->fillStyle) {
    case FillSolid:
        type = DO_SOLID;
        break;
    case FillStippled:
        type = (*infoRec->StippledFillChooser) (pGC);
        break;
    case FillOpaqueStippled:
        if ((pGC->fgPixel == pGC->bgPixel) && infoRec->FillSolidRects &&
            CHECK_PLANEMASK(pGC, infoRec->FillSolidRectsFlags) &&
            CHECK_ROP(pGC, infoRec->FillSolidRectsFlags) &&
            CHECK_ROPSRC(pGC, infoRec->FillSolidRectsFlags) &&
            CHECK_FG(pGC, infoRec->FillSolidRectsFlags))
            type = DO_SOLID;
        else
            type = (*infoRec->OpaqueStippledFillChooser) (pGC);
        break;
    case FillTiled:
        type = (*infoRec->TiledFillChooser) (pGC);
        break;
    }

    switch (type) {
    case DO_SOLID:
        function = XAARenderSolidRects;
        break;
    case DO_COLOR_8x8:
        function = XAARenderColor8x8Rects;
        break;
    case DO_MONO_8x8:
        function = XAARenderMono8x8Rects;
        break;
    case DO_CACHE_BLT:
        function = XAARenderCacheBltRects;
        break;
    case DO_COLOR_EXPAND:
        function = XAARenderColorExpandRects;
        break;
    case DO_CACHE_EXPAND:
        function = XAARenderCacheExpandRects;
        break;
    case DO_IMAGE_WRITE:
        function = XAARenderImageWriteRects;
        break;
    case DO_PIXMAP_COPY:
        function = XAARenderPixmapCopyRects;
        break;
    default:
        (*XAAFallbackOps.PolyFillRect) (pDraw, pGC, nrectFill, prectInit);
        return;
    }

    if (xorg | yorg) {
        int n = nrectFill;
        xRectangle *prect = prectInit;

        while (n--) {
            prect->x += xorg;
            prect->y += yorg;
            prect++;
        }
    }

    XAAClipAndRenderRects(pGC, function, nrectFill, prectInit, xorg, yorg);
}

        /*********************\
	|     Solid Rects     |
	\*********************/

static void
XAARenderSolidRects(GCPtr pGC,
                    int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);

    (*infoRec->FillSolidRects) (infoRec->pScrn,
                                pGC->fgPixel, pGC->alu, pGC->planemask, nboxes,
                                pClipBoxes);
}

        /************************\
	|     Mono 8x8 Rects     |
	\************************/

static void
XAARenderMono8x8Rects(GCPtr pGC,
                      int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    XAAPixmapPtr pPriv;
    int fg, bg;

    switch (pGC->fillStyle) {
    case FillStippled:
        pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
        fg = pGC->fgPixel;
        bg = -1;
        break;
    case FillOpaqueStippled:
        pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
        fg = pGC->fgPixel;
        bg = pGC->bgPixel;
        break;
    case FillTiled:
        pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
        fg = pPriv->fg;
        bg = pPriv->bg;
        break;
    default:                   /* Muffle compiler */
        pPriv = NULL;           /* Kaboom */
        fg = -1;
        bg = -1;
        break;
    }

    (*infoRec->FillMono8x8PatternRects) (infoRec->pScrn,
                                         fg, bg, pGC->alu, pGC->planemask,
                                         nboxes, pClipBoxes, pPriv->pattern0,
                                         pPriv->pattern1,
                                         (xorg + pGC->patOrg.x),
                                         (yorg + pGC->patOrg.y));
}

        /*************************\
	|     Color 8x8 Rects     |
	\*************************/

static void
XAARenderColor8x8Rects(GCPtr pGC,
                       int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    XAACacheInfoPtr pCache;
    PixmapPtr pPix;
    int fg, bg;

    switch (pGC->fillStyle) {
    case FillStippled:
        pPix = pGC->stipple;
        fg = pGC->fgPixel;
        bg = -1;
        break;
    case FillOpaqueStippled:
        pPix = pGC->stipple;
        fg = pGC->fgPixel;
        bg = pGC->bgPixel;
        break;
    case FillTiled:
        pPix = pGC->tile.pixmap;
        fg = -1;
        bg = -1;
        break;
    default:                   /* Muffle compiler */
        pPix = NULL;
        fg = -1;
        bg = -1;
        break;
    }

    pCache = (*infoRec->CacheColor8x8Pattern) (infoRec->pScrn, pPix, fg, bg);
    (*infoRec->FillColor8x8PatternRects) (infoRec->pScrn,
                                          pGC->alu, pGC->planemask, nboxes,
                                          pClipBoxes, (xorg + pGC->patOrg.x),
                                          (yorg + pGC->patOrg.y), pCache);
}

        /****************************\
	|     Color Expand Rects     |
	\****************************/

static void
XAARenderColorExpandRects(GCPtr pGC,
                          int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    int fg, bg;

    switch (pGC->fillStyle) {
    case FillStippled:
        fg = pGC->fgPixel;
        bg = -1;
        break;
    case FillOpaqueStippled:
        fg = pGC->fgPixel;
        bg = pGC->bgPixel;
        break;
    default:                   /* Muffle compiler */
        fg = -1;
        bg = -1;
        break;
    }

    (*infoRec->FillColorExpandRects) (infoRec->pScrn, fg, bg,
                                      pGC->alu, pGC->planemask, nboxes,
                                      pClipBoxes, (xorg + pGC->patOrg.x),
                                      (yorg + pGC->patOrg.y), pGC->stipple);
}

        /*************************\
	|     Cache Blt Rects     |
	\*************************/

static void
XAARenderCacheBltRects(GCPtr pGC,
                       int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    XAACacheInfoPtr pCache;

    switch (pGC->fillStyle) {
    case FillStippled:
        pCache = (*infoRec->CacheStipple) (infoRec->pScrn, pGC->stipple,
                                           pGC->fgPixel, -1);
        break;
    case FillOpaqueStippled:
        pCache = (*infoRec->CacheStipple) (infoRec->pScrn, pGC->stipple,
                                           pGC->fgPixel, pGC->bgPixel);
        break;
    case FillTiled:
        pCache = (*infoRec->CacheTile) (infoRec->pScrn, pGC->tile.pixmap);
        break;
    default:                   /* Muffle compiler */
        pCache = NULL;
        break;
    }

    (*infoRec->FillCacheBltRects) (infoRec->pScrn, pGC->alu,
                                   pGC->planemask, nboxes, pClipBoxes,
                                   (xorg + pGC->patOrg.x),
                                   (yorg + pGC->patOrg.y), pCache);
}

        /****************************\
	|     Cache Expand Rects     |
	\****************************/

static void
XAARenderCacheExpandRects(GCPtr pGC,
                          int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    int fg, bg;

    switch (pGC->fillStyle) {
    case FillStippled:
        fg = pGC->fgPixel;
        bg = -1;
        break;
    case FillOpaqueStippled:
        fg = pGC->fgPixel;
        bg = pGC->bgPixel;
        break;
    default:                   /* Muffle compiler */
        fg = -1;
        bg = -1;
        break;
    }

    (*infoRec->FillCacheExpandRects) (infoRec->pScrn, fg, bg,
                                      pGC->alu, pGC->planemask, nboxes,
                                      pClipBoxes, (xorg + pGC->patOrg.x),
                                      (yorg + pGC->patOrg.y), pGC->stipple);
}

        /***************************\
	|     Image Write Rects     |
	\***************************/

static void
XAARenderImageWriteRects(GCPtr pGC,
                         int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);

    (*infoRec->FillImageWriteRects) (infoRec->pScrn, pGC->alu,
                                     pGC->planemask, nboxes, pClipBoxes,
                                     (xorg + pGC->patOrg.x),
                                     (yorg + pGC->patOrg.y), pGC->tile.pixmap);
}

        /***************************\
	|     Pixmap Copy Rects     |
	\***************************/

static void
XAARenderPixmapCopyRects(GCPtr pGC,
                         int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    XAACacheInfoPtr pCache = &(infoRec->ScratchCacheInfoRec);
    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);

    pCache->x = pPriv->offscreenArea->box.x1;
    pCache->y = pPriv->offscreenArea->box.y1;
    pCache->w = pCache->orig_w = pPriv->offscreenArea->box.x2 - pCache->x;
    pCache->h = pCache->orig_h = pPriv->offscreenArea->box.y2 - pCache->y;
    pCache->trans_color = -1;

    (*infoRec->FillCacheBltRects) (infoRec->pScrn, pGC->alu,
                                   pGC->planemask, nboxes, pClipBoxes,
                                   (xorg + pGC->patOrg.x),
                                   (yorg + pGC->patOrg.y), pCache);
}

        /************\
	|   Solid    |
	\************/

void
XAAFillSolidRects(ScrnInfoPtr pScrn, int fg, int rop, unsigned int planemask, int nBox, /* number of rectangles to fill */
                  BoxPtr pBox   /* Pointer to first rectangle to fill */
    )
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);

    (*infoRec->SetupForSolidFill) (pScrn, fg, rop, planemask);
    while (nBox--) {
        (*infoRec->SubsequentSolidFillRect) (pScrn, pBox->x1, pBox->y1,
                                             pBox->x2 - pBox->x1,
                                             pBox->y2 - pBox->y1);
        pBox++;
    }
    SET_SYNC_FLAG(infoRec);
}

        /*********************\
	|  8x8 Mono Patterns  |
	\*********************/

void
XAAFillMono8x8PatternRectsScreenOrigin(ScrnInfoPtr pScrn,
                                       int fg, int bg, int rop,
                                       unsigned int planemask,
                                       int nBox,
                                       BoxPtr pBox,
                                       int pattern0, int pattern1,
                                       int xorigin, int yorigin)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int patx = pattern0, paty = pattern1;
    int xorg = (-xorigin) & 0x07;
    int yorg = (-yorigin) & 0x07;

    if (infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_PROGRAMMED_BITS) {
        if (!(infoRec->Mono8x8PatternFillFlags &
              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
            XAARotateMonoPattern(&patx, &paty, xorg, yorg,
                                 (infoRec->Mono8x8PatternFillFlags &
                                  BIT_ORDER_IN_BYTE_MSBFIRST));
            xorg = patx;
            yorg = paty;
        }
    }
    else {
        XAACacheInfoPtr pCache =
            (*infoRec->CacheMono8x8Pattern) (pScrn, pattern0, pattern1);
        patx = pCache->x;
        paty = pCache->y;
        if (!(infoRec->Mono8x8PatternFillFlags &
              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
            int slot = (yorg << 3) + xorg;

            patx += pCache->offsets[slot].x;
            paty += pCache->offsets[slot].y;
            xorg = patx;
            yorg = paty;
        }
    }

    (*infoRec->SetupForMono8x8PatternFill) (pScrn, patx, paty,
                                            fg, bg, rop, planemask);

    while (nBox--) {
        (*infoRec->SubsequentMono8x8PatternFillRect) (pScrn,
                                                      xorg, yorg, pBox->x1,
                                                      pBox->y1,
                                                      pBox->x2 - pBox->x1,
                                                      pBox->y2 - pBox->y1);
        pBox++;
    }
    SET_SYNC_FLAG(infoRec);
}

void
XAAFillMono8x8PatternRects(ScrnInfoPtr pScrn,
                           int fg, int bg, int rop,
                           unsigned int planemask,
                           int nBox,
                           BoxPtr pBox,
                           int pattern0, int pattern1, int xorigin, int yorigin)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int patx = pattern0, paty = pattern1;
    int xorg, yorg;
    XAACacheInfoPtr pCache = NULL;

    if (!(infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_PROGRAMMED_BITS)) {
        pCache = (*infoRec->CacheMono8x8Pattern) (pScrn, pattern0, pattern1);
        patx = pCache->x;
        paty = pCache->y;
    }

    (*infoRec->SetupForMono8x8PatternFill) (pScrn, patx, paty,
                                            fg, bg, rop, planemask);

    while (nBox--) {
        xorg = (pBox->x1 - xorigin) & 0x07;
        yorg = (pBox->y1 - yorigin) & 0x07;

        if (!(infoRec->Mono8x8PatternFillFlags &
              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
            if (infoRec->Mono8x8PatternFillFlags &
                HARDWARE_PATTERN_PROGRAMMED_BITS) {
                patx = pattern0;
                paty = pattern1;
                XAARotateMonoPattern(&patx, &paty, xorg, yorg,
                                     (infoRec->Mono8x8PatternFillFlags &
                                      BIT_ORDER_IN_BYTE_MSBFIRST));
                xorg = patx;
                yorg = paty;
            }
            else {
                int slot = (yorg << 3) + xorg;

                xorg = patx + pCache->offsets[slot].x;
                yorg = paty + pCache->offsets[slot].y;
            }
        }

        (*infoRec->SubsequentMono8x8PatternFillRect) (pScrn,
                                                      xorg, yorg, pBox->x1,
                                                      pBox->y1,
                                                      pBox->x2 - pBox->x1,
                                                      pBox->y2 - pBox->y1);
        pBox++;
    }

    SET_SYNC_FLAG(infoRec);
}

        /**********************\
	|  8x8 Color Patterns  |
	\**********************/

void
XAAFillColor8x8PatternRectsScreenOrigin(ScrnInfoPtr pScrn,
                                        int rop,
                                        unsigned int planemask,
                                        int nBox,
                                        BoxPtr pBox,
                                        int xorigin, int yorigin,
                                        XAACacheInfoPtr pCache)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int patx = pCache->x, paty = pCache->y;
    int xorg = (-xorigin) & 0x07;
    int yorg = (-yorigin) & 0x07;

    if (!(infoRec->Color8x8PatternFillFlags &
          HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
        int slot = (yorg << 3) + xorg;

        paty += pCache->offsets[slot].y;
        patx += pCache->offsets[slot].x;
        xorg = patx;
        yorg = paty;
    }

    (*infoRec->SetupForColor8x8PatternFill) (pScrn, patx, paty,
                                             rop, planemask,
                                             pCache->trans_color);

    while (nBox--) {
        (*infoRec->SubsequentColor8x8PatternFillRect) (pScrn,
                                                       xorg, yorg, pBox->x1,
                                                       pBox->y1,
                                                       pBox->x2 - pBox->x1,
                                                       pBox->y2 - pBox->y1);
        pBox++;
    }
    SET_SYNC_FLAG(infoRec);
}

void
XAAFillColor8x8PatternRects(ScrnInfoPtr pScrn,
                            int rop,
                            unsigned int planemask,
                            int nBox,
                            BoxPtr pBox,
                            int xorigin, int yorigin, XAACacheInfoPtr pCache)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int xorg, yorg;

    (*infoRec->SetupForColor8x8PatternFill) (pScrn, pCache->x, pCache->y,
                                             rop, planemask,
                                             pCache->trans_color);

    while (nBox--) {
        xorg = (pBox->x1 - xorigin) & 0x07;
        yorg = (pBox->y1 - yorigin) & 0x07;

        if (!(infoRec->Color8x8PatternFillFlags &
              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
            int slot = (yorg << 3) + xorg;

            yorg = pCache->y + pCache->offsets[slot].y;
            xorg = pCache->x + pCache->offsets[slot].x;
        }

        (*infoRec->SubsequentColor8x8PatternFillRect) (pScrn,
                                                       xorg, yorg, pBox->x1,
                                                       pBox->y1,
                                                       pBox->x2 - pBox->x1,
                                                       pBox->y2 - pBox->y1);
        pBox++;
    }

    SET_SYNC_FLAG(infoRec);
}

        /***************\
	|  Cache Blits  |
	\***************/

void
XAAFillCacheBltRects(ScrnInfoPtr pScrn,
                     int rop,
                     unsigned int planemask,
                     int nBox,
                     BoxPtr pBox, int xorg, int yorg, XAACacheInfoPtr pCache)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int x, y, phaseY, phaseX, skipleft, height, width, w, blit_w, blit_h;

    (*infoRec->SetupForScreenToScreenCopy) (pScrn, 1, 1, rop, planemask,
                                            pCache->trans_color);

    while (nBox--) {
        y = pBox->y1;
        phaseY = (y - yorg) % pCache->orig_h;
        if (phaseY < 0)
            phaseY += pCache->orig_h;
        phaseX = (pBox->x1 - xorg) % pCache->orig_w;
        if (phaseX < 0)
            phaseX += pCache->orig_w;
        height = pBox->y2 - y;
        width = pBox->x2 - pBox->x1;

#if 0
        if (rop == GXcopy) {
            while (1) {
                w = width;
                skipleft = phaseX;
                x = pBox->x1;
                blit_h = pCache->h - phaseY;
                if (blit_h > height)
                    blit_h = height;

                while (1) {
                    blit_w = pCache->w - skipleft;
                    if (blit_w > w)
                        blit_w = w;
                    (*infoRec->SubsequentScreenToScreenCopy) (pScrn,
                                                              pCache->x +
                                                              skipleft,
                                                              pCache->y +
                                                              phaseY, x, y,
                                                              blit_w, blit_h);
                    w -= blit_w;
                    if (!w)
                        break;
                    x += blit_w;
                    skipleft = (skipleft + blit_w) % pCache->orig_w;
                    if (blit_w >= pCache->orig_w)
                        break;
                }

                /* Expand horizontally */
                if (w) {
                    skipleft -= phaseX;
                    if (skipleft < 0)
                        skipleft += pCache->orig_w;
                    blit_w = x - pBox->x1 - skipleft;
                    while (w) {
                        if (blit_w > w)
                            blit_w = w;
                        (*infoRec->SubsequentScreenToScreenCopy) (pScrn,
                                                                  pBox->x1 +
                                                                  skipleft, y,
                                                                  x, y, blit_w,
                                                                  blit_h);
                        w -= blit_w;
                        x += blit_w;
                        blit_w <<= 1;
                    }
                }

                height -= blit_h;
                if (!height)
                    break;
                y += blit_h;
                phaseY = (phaseY + blit_h) % pCache->orig_h;
                if (blit_h >= pCache->orig_h)
                    break;
            }

            /* Expand vertically */
            if (height) {
                blit_w = pBox->x2 - pBox->x1;
                phaseY -= (pBox->y1 - yorg) % pCache->orig_h;
                if (phaseY < 0)
                    phaseY += pCache->orig_h;
                blit_h = y - pBox->y1 - phaseY;
                while (height) {
                    if (blit_h > height)
                        blit_h = height;
                    (*infoRec->SubsequentScreenToScreenCopy) (pScrn, pBox->x1,
                                                              pBox->y1 + phaseY,
                                                              pBox->x1, y,
                                                              blit_w, blit_h);
                    height -= blit_h;
                    y += blit_h;
                    blit_h <<= 1;
                }
            }
        }
        else
#endif
        {
            while (1) {
                w = width;
                skipleft = phaseX;
                x = pBox->x1;
                blit_h = pCache->h - phaseY;
                if (blit_h > height)
                    blit_h = height;

                while (1) {
                    blit_w = pCache->w - skipleft;
                    if (blit_w > w)
                        blit_w = w;
                    (*infoRec->SubsequentScreenToScreenCopy) (pScrn,
                                                              pCache->x +
                                                              skipleft,
                                                              pCache->y +
                                                              phaseY, x, y,
                                                              blit_w, blit_h);
                    w -= blit_w;
                    if (!w)
                        break;
                    x += blit_w;
                    skipleft = (skipleft + blit_w) % pCache->orig_w;
                }
                height -= blit_h;
                if (!height)
                    break;
                y += blit_h;
                phaseY = (phaseY + blit_h) % pCache->orig_h;
            }
        }
        pBox++;
    }

    SET_SYNC_FLAG(infoRec);
}

        /*******************\
	|  Cache Expansion  |
	\*******************/

void
XAAFillCacheExpandRects(ScrnInfoPtr pScrn,
                        int fg, int bg, int rop,
                        unsigned int planemask,
                        int nBox,
                        BoxPtr pBox, int xorg, int yorg, PixmapPtr pPix)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int x, y, phaseY, phaseX, skipleft, height, width, w, blit_w, blit_h;
    int cacheWidth;
    XAACacheInfoPtr pCache;

    pCache = (*infoRec->CacheMonoStipple) (pScrn, pPix);

    cacheWidth = (pCache->w * pScrn->bitsPerPixel) /
        infoRec->CacheColorExpandDensity;

    (*infoRec->SetupForScreenToScreenColorExpandFill) (pScrn, fg, bg, rop,
                                                       planemask);

    while (nBox--) {
        y = pBox->y1;
        phaseY = (y - yorg) % pCache->orig_h;
        if (phaseY < 0)
            phaseY += pCache->orig_h;
        phaseX = (pBox->x1 - xorg) % pCache->orig_w;
        if (phaseX < 0)
            phaseX += pCache->orig_w;
        height = pBox->y2 - y;
        width = pBox->x2 - pBox->x1;

        while (1) {
            w = width;
            skipleft = phaseX;
            x = pBox->x1;
            blit_h = pCache->h - phaseY;
            if (blit_h > height)
                blit_h = height;

            while (1) {
                blit_w = cacheWidth - skipleft;
                if (blit_w > w)
                    blit_w = w;
                (*infoRec->SubsequentScreenToScreenColorExpandFill) (pScrn, x,
                                                                     y, blit_w,
                                                                     blit_h,
                                                                     pCache->x,
                                                                     pCache->y +
                                                                     phaseY,
                                                                     skipleft);
                w -= blit_w;
                if (!w)
                    break;
                x += blit_w;
                skipleft = (skipleft + blit_w) % pCache->orig_w;
            }
            height -= blit_h;
            if (!height)
                break;
            y += blit_h;
            phaseY = (phaseY + blit_h) % pCache->orig_h;
        }
        pBox++;
    }

    SET_SYNC_FLAG(infoRec);
}

        /******************\
	|   Image Writes   |
	\******************/

/*  This requires all LEFT_EDGE clipping.  You get too many problems
    with reading past the edge of the pattern otherwise */

static void
WriteColumn(ScrnInfoPtr pScrn,
            unsigned char *pSrc,
            int x, int y, int w, int h,
            int xoff, int yoff, int pHeight, int srcwidth, int Bpp)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    unsigned char *src;
    Bool PlusOne = FALSE;
    int skipleft, dwords;

    pSrc += (Bpp * xoff);

    if ((skipleft = (long) pSrc & 0x03L)) {
        if (Bpp == 3)
            skipleft = 4 - skipleft;
        else
            skipleft /= Bpp;

        x -= skipleft;
        w += skipleft;

        if (Bpp == 3)
            pSrc -= 3 * skipleft;
        else                    /* is this Alpha friendly ? */
            pSrc = (unsigned char *) ((long) pSrc & ~0x03L);
    }

    src = pSrc + (yoff * srcwidth);

    dwords = bytes_to_int32(w * Bpp);

    if ((infoRec->ImageWriteFlags & CPU_TRANSFER_PAD_QWORD) &&
        ((dwords * h) & 0x01)) {
        PlusOne = TRUE;
    }

    (*infoRec->SubsequentImageWriteRect) (pScrn, x, y, w, h, skipleft);

    if (dwords > infoRec->ImageWriteRange) {
        while (h--) {
            XAAMoveDWORDS_FixedBase((CARD32 *) infoRec->ImageWriteBase,
                                    (CARD32 *) src, dwords);
            src += srcwidth;
            yoff++;
            if (yoff >= pHeight) {
                yoff = 0;
                src = pSrc;
            }
        }
    }
    else {
        if (srcwidth == (dwords << 2)) {
            int maxLines = infoRec->ImageWriteRange / dwords;
            int step;

            while (h) {
                step = pHeight - yoff;
                if (step > maxLines)
                    step = maxLines;
                if (step > h)
                    step = h;

                XAAMoveDWORDS((CARD32 *) infoRec->ImageWriteBase,
                              (CARD32 *) src, dwords * step);

                src += (srcwidth * step);
                yoff += step;
                if (yoff >= pHeight) {
                    yoff = 0;
                    src = pSrc;
                }
                h -= step;
            }
        }
        else {
            while (h--) {
                XAAMoveDWORDS((CARD32 *) infoRec->ImageWriteBase,
                              (CARD32 *) src, dwords);
                src += srcwidth;
                yoff++;
                if (yoff >= pHeight) {
                    yoff = 0;
                    src = pSrc;
                }
            }
        }
    }

    if (PlusOne) {
        CARD32 *base = (CARD32 *) infoRec->ImageWriteBase;

        *base = 0x00000000;
    }
}

void
XAAFillImageWriteRects(ScrnInfoPtr pScrn,
                       int rop,
                       unsigned int planemask,
                       int nBox,
                       BoxPtr pBox, int xorg, int yorg, PixmapPtr pPix)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int x, phaseY, phaseX, height, width, blit_w;
    int pHeight = pPix->drawable.height;
    int pWidth = pPix->drawable.width;
    int Bpp = pPix->drawable.bitsPerPixel >> 3;
    int srcwidth = pPix->devKind;

    (*infoRec->SetupForImageWrite) (pScrn, rop, planemask, -1,
                                    pPix->drawable.bitsPerPixel,
                                    pPix->drawable.depth);

    while (nBox--) {
        x = pBox->x1;
        phaseY = (pBox->y1 - yorg) % pHeight;
        if (phaseY < 0)
            phaseY += pHeight;
        phaseX = (x - xorg) % pWidth;
        if (phaseX < 0)
            phaseX += pWidth;
        height = pBox->y2 - pBox->y1;
        width = pBox->x2 - x;

        while (1) {
            blit_w = pWidth - phaseX;
            if (blit_w > width)
                blit_w = width;

            WriteColumn(pScrn, pPix->devPrivate.ptr, x, pBox->y1,
                        blit_w, height, phaseX, phaseY, pHeight, srcwidth, Bpp);

            width -= blit_w;
            if (!width)
                break;
            x += blit_w;
            phaseX = (phaseX + blit_w) % pWidth;
        }
        pBox++;
    }

    if (infoRec->ImageWriteFlags & SYNC_AFTER_IMAGE_WRITE)
        (*infoRec->Sync) (pScrn);
    else
        SET_SYNC_FLAG(infoRec);
}

        /*************\
	|  Utilities  |
	\*************/

void
XAAClipAndRenderRects(GCPtr pGC,
                      ClipAndRenderRectsFunc BoxFunc,
                      int nrectFill, xRectangle *prect, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    int Right, Bottom, MaxBoxes;
    BoxPtr pextent, pboxClipped, pboxClippedBase;

    MaxBoxes = infoRec->PreAllocSize / sizeof(BoxRec);
    pboxClippedBase = (BoxPtr) infoRec->PreAllocMem;
    pboxClipped = pboxClippedBase;

    if (RegionNumRects(pGC->pCompositeClip) == 1) {
        pextent = RegionRects(pGC->pCompositeClip);
        while (nrectFill--) {
            pboxClipped->x1 = max(pextent->x1, prect->x);
            pboxClipped->y1 = max(pextent->y1, prect->y);

            Right = (int) prect->x + (int) prect->width;
            pboxClipped->x2 = min(pextent->x2, Right);

            Bottom = (int) prect->y + (int) prect->height;
            pboxClipped->y2 = min(pextent->y2, Bottom);

            prect++;
            if ((pboxClipped->x1 < pboxClipped->x2) &&
                (pboxClipped->y1 < pboxClipped->y2)) {
                pboxClipped++;
                if (pboxClipped >= (pboxClippedBase + MaxBoxes)) {
                    (*BoxFunc) (pGC, MaxBoxes, pboxClippedBase, xorg, yorg);
                    pboxClipped = pboxClippedBase;
                }
            }
        }
    }
    else {
        pextent = RegionExtents(pGC->pCompositeClip);
        while (nrectFill--) {
            int n;
            BoxRec box, *pbox;

            box.x1 = max(pextent->x1, prect->x);
            box.y1 = max(pextent->y1, prect->y);

            Right = (int) prect->x + (int) prect->width;
            box.x2 = min(pextent->x2, Right);

            Bottom = (int) prect->y + (int) prect->height;
            box.y2 = min(pextent->y2, Bottom);

            prect++;

            if ((box.x1 >= box.x2) || (box.y1 >= box.y2))
                continue;

            n = RegionNumRects(pGC->pCompositeClip);
            pbox = RegionRects(pGC->pCompositeClip);

            /* clip the rectangle to each box in the clip region
               this is logically equivalent to calling Intersect()
             */
            while (n--) {
                pboxClipped->x1 = max(box.x1, pbox->x1);
                pboxClipped->y1 = max(box.y1, pbox->y1);
                pboxClipped->x2 = min(box.x2, pbox->x2);
                pboxClipped->y2 = min(box.y2, pbox->y2);
                pbox++;

                /* see if clipping left anything */
                if (pboxClipped->x1 < pboxClipped->x2 &&
                    pboxClipped->y1 < pboxClipped->y2) {
                    pboxClipped++;
                    if (pboxClipped >= (pboxClippedBase + MaxBoxes)) {
                        (*BoxFunc) (pGC, MaxBoxes, pboxClippedBase, xorg, yorg);
                        pboxClipped = pboxClippedBase;
                    }
                }
            }
        }
    }

    if (pboxClipped != pboxClippedBase)
        (*BoxFunc) (pGC, pboxClipped - pboxClippedBase, pboxClippedBase,
                    xorg, yorg);
}

int
XAAGetRectClipBoxes(GCPtr pGC,
                    BoxPtr pboxClippedBase,
                    int nrectFill, xRectangle *prectInit)
{
    int Right, Bottom;
    BoxPtr pextent, pboxClipped = pboxClippedBase;
    xRectangle *prect = prectInit;
    RegionPtr prgnClip = pGC->pCompositeClip;

    if (RegionNumRects(prgnClip) == 1) {
        pextent = RegionRects(prgnClip);
        while (nrectFill--) {
            pboxClipped->x1 = max(pextent->x1, prect->x);
            pboxClipped->y1 = max(pextent->y1, prect->y);

            Right = (int) prect->x + (int) prect->width;
            pboxClipped->x2 = min(pextent->x2, Right);

            Bottom = (int) prect->y + (int) prect->height;
            pboxClipped->y2 = min(pextent->y2, Bottom);

            prect++;
            if ((pboxClipped->x1 < pboxClipped->x2) &&
                (pboxClipped->y1 < pboxClipped->y2)) {
                pboxClipped++;
            }
        }
    }
    else {
        pextent = RegionExtents(prgnClip);
        while (nrectFill--) {
            int n;
            BoxRec box, *pbox;

            box.x1 = max(pextent->x1, prect->x);
            box.y1 = max(pextent->y1, prect->y);

            Right = (int) prect->x + (int) prect->width;
            box.x2 = min(pextent->x2, Right);

            Bottom = (int) prect->y + (int) prect->height;
            box.y2 = min(pextent->y2, Bottom);

            prect++;

            if ((box.x1 >= box.x2) || (box.y1 >= box.y2))
                continue;

            n = RegionNumRects(prgnClip);
            pbox = RegionRects(prgnClip);

            /* clip the rectangle to each box in the clip region
               this is logically equivalent to calling Intersect()
             */
            while (n--) {
                pboxClipped->x1 = max(box.x1, pbox->x1);
                pboxClipped->y1 = max(box.y1, pbox->y1);
                pboxClipped->x2 = min(box.x2, pbox->x2);
                pboxClipped->y2 = min(box.y2, pbox->y2);
                pbox++;

                /* see if clipping left anything */
                if (pboxClipped->x1 < pboxClipped->x2 &&
                    pboxClipped->y1 < pboxClipped->y2) {
                    pboxClipped++;
                }
            }
        }
    }

    return pboxClipped - pboxClippedBase;
}
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a16 1

d27 4
a30 6
XAAPolyFillRect(
    DrawablePtr pDraw,
    GCPtr pGC,
    int		nrectFill, 	/* number of rectangles to fill */
    xRectangle	*prectInit   	/* Pointer to first rectangle to fill */
){
d32 3
a34 3
    int		xorg = pDraw->x;
    int		yorg = pDraw->y;
    int		type = 0;
d37 1
a37 1
    if((nrectFill <= 0) || !pGC->planemask)
d40 2
a41 2
    if(!RegionNumRects(pGC->pCompositeClip))
	return;
d43 1
a43 1
    switch(pGC->fillStyle) {
d45 2
a46 2
	type = DO_SOLID;
	break;
d48 2
a49 2
	type = (*infoRec->StippledFillChooser)(pGC);
	break;
d51 9
a59 9
	if((pGC->fgPixel == pGC->bgPixel) && infoRec->FillSolidRects &&
                CHECK_PLANEMASK(pGC,infoRec->FillSolidRectsFlags) &&
                CHECK_ROP(pGC,infoRec->FillSolidRectsFlags) &&
                CHECK_ROPSRC(pGC,infoRec->FillSolidRectsFlags) &&
                CHECK_FG(pGC,infoRec->FillSolidRectsFlags))
	    type = DO_SOLID;
	else
	    type = (*infoRec->OpaqueStippledFillChooser)(pGC);
	break;
d61 2
a62 2
	type = (*infoRec->TiledFillChooser)(pGC);
	break;
d65 1
a65 1
    switch(type) {
d67 2
a68 2
	function = XAARenderSolidRects;	
	break;	
d70 2
a71 2
	function = XAARenderColor8x8Rects;	
	break;	
d73 2
a74 2
	function = XAARenderMono8x8Rects;	
	break;	
d76 2
a77 2
	function = XAARenderCacheBltRects;	
	break;	
d79 2
a80 2
	function = XAARenderColorExpandRects;	
	break;	
d82 2
a83 2
	function = XAARenderCacheExpandRects;	
	break;	
d85 2
a86 2
	function = XAARenderImageWriteRects;	
	break;	
d88 2
a89 2
	function = XAARenderPixmapCopyRects;	
	break;	
d91 2
a92 2
	(*XAAFallbackOps.PolyFillRect)(pDraw, pGC, nrectFill, prectInit);
	return;
d95 9
a103 9
    if(xorg | yorg) {
	int n = nrectFill;
	xRectangle *prect = prectInit;

	while(n--) {
	    prect->x += xorg;
	    prect->y += yorg;
	    prect++;
	}
a105 1
    
d109 1
a109 3


	/*********************\
d114 4
a117 7
XAARenderSolidRects(
   GCPtr pGC,
   int nboxes,
   BoxPtr pClipBoxes,
   int xorg, int yorg
){
   XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
d119 3
a121 2
   (*infoRec->FillSolidRects) (infoRec->pScrn, 
               pGC->fgPixel, pGC->alu, pGC->planemask, nboxes, pClipBoxes);
d124 1
a124 2

	/************************\
d129 36
a164 33
XAARenderMono8x8Rects(
   GCPtr pGC,
   int nboxes,
   BoxPtr pClipBoxes,
   int xorg, int yorg
){
   XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
   XAAPixmapPtr pPriv;
   int fg, bg;

   switch(pGC->fillStyle) {
   case FillStippled:
      pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
      fg = pGC->fgPixel;  bg = -1;
      break;
   case FillOpaqueStippled:
      pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
      fg = pGC->fgPixel;  bg = pGC->bgPixel;
      break;
   case FillTiled:
      pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
      fg = pPriv->fg;  bg = pPriv->bg;
      break;
   default:	/* Muffle compiler */
      pPriv = NULL;	/* Kaboom */
      fg = -1;  bg = -1;
      break;
   }

   (*infoRec->FillMono8x8PatternRects) (infoRec->pScrn, 
                fg, bg, pGC->alu, pGC->planemask, 
                nboxes, pClipBoxes, pPriv->pattern0, pPriv->pattern1, 
                (xorg + pGC->patOrg.x), (yorg + pGC->patOrg.y));
d167 1
a167 1
	/*************************\
d172 36
a207 34
XAARenderColor8x8Rects(
   GCPtr pGC,
   int nboxes,
   BoxPtr pClipBoxes,
   int xorg, int yorg
){
   XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
   XAACacheInfoPtr pCache;
   PixmapPtr pPix;
   int fg, bg;

   switch(pGC->fillStyle) {
   case FillStippled:
      pPix = pGC->stipple;
      fg = pGC->fgPixel;  bg = -1;
      break;
   case FillOpaqueStippled:
      pPix = pGC->stipple;
      fg = pGC->fgPixel;  bg = pGC->bgPixel;
      break;
   case FillTiled:
      pPix = pGC->tile.pixmap;
      fg = -1;  bg = -1;
      break;
   default:	/* Muffle compiler */
      pPix = NULL;
      fg = -1;  bg = -1;
      break;
   }

   pCache = (*infoRec->CacheColor8x8Pattern)(infoRec->pScrn, pPix, fg, bg);
   (*infoRec->FillColor8x8PatternRects) (infoRec->pScrn,
                pGC->alu, pGC->planemask, nboxes, pClipBoxes, 
                (xorg + pGC->patOrg.x), (yorg + pGC->patOrg.y), pCache);
d210 1
a210 2

	/****************************\
d215 25
a239 25
XAARenderColorExpandRects(
   GCPtr pGC,
   int nboxes,
   BoxPtr pClipBoxes,
   int xorg, int yorg
){
   XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
   int fg, bg;

   switch(pGC->fillStyle) {
   case FillStippled:
      fg = pGC->fgPixel;  bg = -1;
      break;
   case FillOpaqueStippled:
      fg = pGC->fgPixel;  bg = pGC->bgPixel;
      break;
   default:	/* Muffle compiler */
      fg = -1;  bg = -1;
      break;
   }

   (*infoRec->FillColorExpandRects) (infoRec->pScrn, fg, bg, 
                pGC->alu, pGC->planemask, nboxes, pClipBoxes, 
                (xorg + pGC->patOrg.x), (yorg + pGC->patOrg.y),
		pGC->stipple);
d242 1
a242 2

	/*************************\
d247 27
a273 29
XAARenderCacheBltRects(
   GCPtr pGC,
   int nboxes,
   BoxPtr pClipBoxes,
   int xorg, int yorg
){
   XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
   XAACacheInfoPtr pCache;

   switch(pGC->fillStyle) {
   case FillStippled:
      pCache = (*infoRec->CacheStipple)(infoRec->pScrn, pGC->stipple, 
					pGC->fgPixel, -1);
      break;
   case FillOpaqueStippled:
      pCache = (*infoRec->CacheStipple)(infoRec->pScrn, pGC->stipple, 
					pGC->fgPixel, pGC->bgPixel);
      break;
   case FillTiled:
      pCache = (*infoRec->CacheTile)(infoRec->pScrn, pGC->tile.pixmap);
      break;
   default:	/* Muffle compiler */
      pCache = NULL;
      break;
   }

   (*infoRec->FillCacheBltRects) (infoRec->pScrn, pGC->alu, 
                pGC->planemask, nboxes, pClipBoxes, 
                (xorg + pGC->patOrg.x), (yorg + pGC->patOrg.y), pCache);
d276 1
a276 2

	/****************************\
d281 5
a285 26
XAARenderCacheExpandRects(
   GCPtr pGC,
   int nboxes,
   BoxPtr pClipBoxes,
   int xorg, int yorg
){
   XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
   int fg, bg;

   switch(pGC->fillStyle) {
   case FillStippled:
      fg = pGC->fgPixel;  bg = -1;
      break;
   case FillOpaqueStippled:
      fg = pGC->fgPixel;  bg = pGC->bgPixel;
      break;
   default:	/* Muffle compiler */
      fg = -1;  bg = -1;
      break;
   }

   (*infoRec->FillCacheExpandRects) (infoRec->pScrn, fg, bg,
                pGC->alu, pGC->planemask, nboxes, pClipBoxes, 
                (xorg + pGC->patOrg.x), (yorg + pGC->patOrg.y), 
                pGC->stipple);
}
d287 14
d302 5
d308 1
a308 1
	/***************************\
d313 9
a321 12
XAARenderImageWriteRects(
   GCPtr pGC,
   int nboxes,
   BoxPtr pClipBoxes,
   int xorg, int yorg
){
   XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);

   (*infoRec->FillImageWriteRects) (infoRec->pScrn, pGC->alu, 
                pGC->planemask, nboxes, pClipBoxes, 
                (xorg + pGC->patOrg.x), (yorg + pGC->patOrg.y),
                pGC->tile.pixmap);
d324 1
a324 3


	/***************************\
d329 17
a345 22
XAARenderPixmapCopyRects(
   GCPtr pGC,
   int nboxes,
   BoxPtr pClipBoxes,
   int xorg, int yorg
){
   XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
   XAACacheInfoPtr pCache = &(infoRec->ScratchCacheInfoRec);
   XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);

   pCache->x = pPriv->offscreenArea->box.x1;
   pCache->y = pPriv->offscreenArea->box.y1;
   pCache->w = pCache->orig_w = 
		pPriv->offscreenArea->box.x2 - pCache->x;
   pCache->h = pCache->orig_h = 
		pPriv->offscreenArea->box.y2 - pCache->y;
   pCache->trans_color = -1;

   (*infoRec->FillCacheBltRects) (infoRec->pScrn, pGC->alu, 
                pGC->planemask, nboxes, pClipBoxes, 
                (xorg + pGC->patOrg.x), (yorg + pGC->patOrg.y), 
                pCache);
d348 1
a348 3


	/************\
d353 4
a356 7
XAAFillSolidRects(
    ScrnInfoPtr pScrn,
    int	fg, int rop,
    unsigned int planemask,
    int		nBox, 		/* number of rectangles to fill */
    BoxPtr	pBox  		/* Pointer to first rectangle to fill */
){
d359 8
a366 7
    (*infoRec->SetupForSolidFill)(pScrn, fg, rop, planemask);
     while(nBox--) {
        (*infoRec->SubsequentSolidFillRect)(pScrn, pBox->x1, pBox->y1,
 			pBox->x2 - pBox->x1, pBox->y2 - pBox->y1);
	pBox++;
     }
     SET_SYNC_FLAG(infoRec);
d369 1
a369 4



	/*********************\
a372 1

d374 7
a380 9
XAAFillMono8x8PatternRectsScreenOrigin(
    ScrnInfoPtr pScrn,
    int	fg, int bg, int rop,
    unsigned int planemask,
    int	nBox,
    BoxPtr pBox,
    int pattern0, int pattern1,
    int xorigin, int yorigin
)
d387 28
d416 9
a424 31
    if(infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_PROGRAMMED_BITS) {
   	if(!(infoRec->Mono8x8PatternFillFlags & 		
				HARDWARE_PATTERN_PROGRAMMED_ORIGIN)){
	    XAARotateMonoPattern(&patx, &paty, xorg, yorg,
				(infoRec->Mono8x8PatternFillFlags &
				 BIT_ORDER_IN_BYTE_MSBFIRST));
	    xorg = patx; yorg = paty;
        }
    } else {
	XAACacheInfoPtr pCache =
		(*infoRec->CacheMono8x8Pattern)(pScrn, pattern0, pattern1);
	patx = pCache->x;  paty = pCache->y;
   	if(!(infoRec->Mono8x8PatternFillFlags & 
				HARDWARE_PATTERN_PROGRAMMED_ORIGIN)){
	    int slot = (yorg << 3) + xorg;
	    patx += pCache->offsets[slot].x;
	    paty += pCache->offsets[slot].y;
	    xorg = patx;  yorg = paty;
	}	
    }

    (*infoRec->SetupForMono8x8PatternFill)(pScrn, patx, paty,
					fg, bg, rop, planemask);

     while(nBox--) {
        (*infoRec->SubsequentMono8x8PatternFillRect)(pScrn, 
			xorg, yorg, pBox->x1, pBox->y1,
 			pBox->x2 - pBox->x1, pBox->y2 - pBox->y1);
	pBox++;
     }
     SET_SYNC_FLAG(infoRec);
d428 6
a433 9
XAAFillMono8x8PatternRects(
    ScrnInfoPtr pScrn,
    int	fg, int bg, int rop,
    unsigned int planemask,
    int	nBox,
    BoxPtr pBox,
    int pattern0, int pattern1,
    int xorigin, int yorigin
)
d440 4
a443 4

    if(!(infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_PROGRAMMED_BITS)){
	pCache = (*infoRec->CacheMono8x8Pattern)(pScrn, pattern0, pattern1);
	patx = pCache->x;  paty = pCache->y;
d446 2
d449 22
a470 22
    (*infoRec->SetupForMono8x8PatternFill)(pScrn, patx, paty,
					fg, bg, rop, planemask);


     while(nBox--) {
	xorg = (pBox->x1 - xorigin) & 0x07;
	yorg = (pBox->y1 - yorigin) & 0x07;

   	if(!(infoRec->Mono8x8PatternFillFlags & 		
				HARDWARE_PATTERN_PROGRAMMED_ORIGIN)){
	    if(infoRec->Mono8x8PatternFillFlags & 
				HARDWARE_PATTERN_PROGRAMMED_BITS) {
		patx = pattern0; paty = pattern1;
		XAARotateMonoPattern(&patx, &paty, xorg, yorg,
				(infoRec->Mono8x8PatternFillFlags & 		
				BIT_ORDER_IN_BYTE_MSBFIRST));
		xorg = patx; yorg = paty;
	    } else {
		int slot = (yorg << 3) + xorg;
	    	xorg = patx + pCache->offsets[slot].x;
	    	yorg = paty + pCache->offsets[slot].y;
	    }
d473 7
a479 5
        (*infoRec->SubsequentMono8x8PatternFillRect)(pScrn, 
			xorg, yorg, pBox->x1, pBox->y1,
 			pBox->x2 - pBox->x1, pBox->y2 - pBox->y1);
	pBox++;
     }
d481 1
a481 1
     SET_SYNC_FLAG(infoRec);
d484 1
a484 2

	/**********************\
a487 1

d489 8
a496 9
XAAFillColor8x8PatternRectsScreenOrigin(
   ScrnInfoPtr pScrn,
   int rop,
   unsigned int planemask,
   int nBox,
   BoxPtr pBox,
   int xorigin, int yorigin,
   XAACacheInfoPtr pCache
){
d502 21
a522 16
    if(!(infoRec->Color8x8PatternFillFlags & 
					HARDWARE_PATTERN_PROGRAMMED_ORIGIN)){
	int slot = (yorg << 3) + xorg;
	paty += pCache->offsets[slot].y;
	patx += pCache->offsets[slot].x;
	xorg = patx;  yorg = paty;
    }	

    (*infoRec->SetupForColor8x8PatternFill)(pScrn, patx, paty,
			 rop, planemask, pCache->trans_color);

    while(nBox--) {
        (*infoRec->SubsequentColor8x8PatternFillRect)(pScrn, 
			xorg, yorg, pBox->x1, pBox->y1,
 			pBox->x2 - pBox->x1, pBox->y2 - pBox->y1);
	pBox++;
d528 7
a534 9
XAAFillColor8x8PatternRects(
   ScrnInfoPtr pScrn,
   int rop,
   unsigned int planemask,
   int nBox,
   BoxPtr pBox,
   int xorigin, int yorigin,
   XAACacheInfoPtr pCache
){
d538 11
a548 2
    (*infoRec->SetupForColor8x8PatternFill)(pScrn, pCache->x, pCache->y,
			 rop, planemask, pCache->trans_color);
d550 2
a551 9
     while(nBox--) {
	xorg = (pBox->x1 - xorigin) & 0x07;
	yorg = (pBox->y1 - yorigin) & 0x07;

   	if(!(infoRec->Color8x8PatternFillFlags & 		
				HARDWARE_PATTERN_PROGRAMMED_ORIGIN)){
	    int slot = (yorg << 3) + xorg;
	    yorg = pCache->y + pCache->offsets[slot].y;
	    xorg = pCache->x + pCache->offsets[slot].x;
d554 7
a560 5
        (*infoRec->SubsequentColor8x8PatternFillRect)(pScrn, 
			xorg, yorg, pBox->x1, pBox->y1,
 			pBox->x2 - pBox->x1, pBox->y2 - pBox->y1);
	pBox++;
     }
d562 1
a562 1
     SET_SYNC_FLAG(infoRec);
d565 1
a565 2

	/***************\
d570 6
a575 9
XAAFillCacheBltRects(
   ScrnInfoPtr pScrn,
   int rop,
   unsigned int planemask,
   int nBox,
   BoxPtr pBox,
   int xorg, int yorg,
   XAACacheInfoPtr pCache
){
d579 13
a591 2
    (*infoRec->SetupForScreenToScreenCopy)(pScrn, 1, 1, rop, planemask,
		pCache->trans_color);
a592 9
    while(nBox--) {
	y = pBox->y1;
	phaseY = (y - yorg) % pCache->orig_h;
	if(phaseY < 0) phaseY += pCache->orig_h;
	phaseX = (pBox->x1 - xorg) % pCache->orig_w;
	if(phaseX < 0) phaseX += pCache->orig_w;
	height = pBox->y2 - y;
	width = pBox->x2 - pBox->x1;
	
d594 78
a671 57
	if (rop == GXcopy) {
	    while(1) {
		w = width; skipleft = phaseX; x = pBox->x1;
		blit_h = pCache->h - phaseY;
		if(blit_h > height) blit_h = height;
	
		while(1) {
		    blit_w = pCache->w - skipleft;
		    if(blit_w > w) blit_w = w;
		    (*infoRec->SubsequentScreenToScreenCopy)(pScrn,
			pCache->x + skipleft, pCache->y + phaseY,
			x, y, blit_w, blit_h);
		    w -= blit_w;
		    if(!w) break;
		    x += blit_w;
		    skipleft = (skipleft + blit_w) % pCache->orig_w;
		    if(blit_w >= pCache->orig_w) break;
		}

		/* Expand horizontally */
		if (w) {
		    skipleft -= phaseX;
		    if (skipleft < 0) skipleft += pCache->orig_w;
		    blit_w = x - pBox->x1 - skipleft;
		    while(w) {
			if (blit_w > w) blit_w = w;
			(*infoRec->SubsequentScreenToScreenCopy)(pScrn,
			    pBox->x1 + skipleft, y, x, y, blit_w, blit_h);
			w -= blit_w;
			x += blit_w;
			blit_w <<= 1;
		    }
		}

		height -= blit_h;
		if(!height) break;
		y += blit_h;
		phaseY = (phaseY + blit_h) % pCache->orig_h;
		if(blit_h >= pCache->orig_h) break;
	    }

	    /* Expand vertically */
	    if (height) {
		blit_w = pBox->x2 - pBox->x1;
		phaseY -= (pBox->y1 - yorg) % pCache->orig_h;
		if (phaseY < 0) phaseY += pCache->orig_h;
		blit_h = y - pBox->y1  - phaseY;
		while(height) {
		    if (blit_h > height) blit_h = height;
		    (*infoRec->SubsequentScreenToScreenCopy)(pScrn, pBox->x1,
			pBox->y1 + phaseY, pBox->x1, y, blit_w, blit_h);
		    height -= blit_h;
		    y += blit_h;
		    blit_h <<= 1;
		}
	    }
	} else 
d673 33
a705 24
	{
	    while(1) {
		w = width; skipleft = phaseX; x = pBox->x1;
		blit_h = pCache->h - phaseY;
		if(blit_h > height) blit_h = height;
	
		while(1) {
		    blit_w = pCache->w - skipleft;
		    if(blit_w > w) blit_w = w;
		    (*infoRec->SubsequentScreenToScreenCopy)(pScrn,
			pCache->x + skipleft, pCache->y + phaseY,
			x, y, blit_w, blit_h);
		    w -= blit_w;
		    if(!w) break;
		    x += blit_w;
		    skipleft = (skipleft + blit_w) % pCache->orig_w;
		}
		height -= blit_h;
		if(!height) break;
		y += blit_h;
		phaseY = (phaseY + blit_h) % pCache->orig_h;
	    }
	}
	pBox++;
d707 1
a707 1
    
d711 1
a711 4



	/*******************\
a714 2


d716 6
a721 9
XAAFillCacheExpandRects(
   ScrnInfoPtr pScrn,
   int fg, int bg, int rop,
   unsigned int planemask,
   int nBox,
   BoxPtr pBox,
   int xorg, int yorg,
   PixmapPtr pPix
){
d727 1
a727 1
    pCache = (*infoRec->CacheMonoStipple)(pScrn, pPix);
d729 2
a730 2
    cacheWidth = (pCache->w * pScrn->bitsPerPixel) / 
	infoRec->CacheColorExpandDensity;
d732 2
a733 2
    (*infoRec->SetupForScreenToScreenColorExpandFill)(pScrn, fg, bg, rop, 
							planemask);
d735 43
a777 31
    while(nBox--) {
	y = pBox->y1;
	phaseY = (y - yorg) % pCache->orig_h;
	if(phaseY < 0) phaseY += pCache->orig_h;
	phaseX = (pBox->x1 - xorg) % pCache->orig_w;
	if(phaseX < 0) phaseX += pCache->orig_w;
	height = pBox->y2 - y;
	width = pBox->x2 - pBox->x1;
	
	while(1) {
	    w = width; skipleft = phaseX; x = pBox->x1;
	    blit_h = pCache->h - phaseY;
	    if(blit_h > height) blit_h = height;
	
	    while(1) {
		blit_w = cacheWidth - skipleft;
		if(blit_w > w) blit_w = w;
		(*infoRec->SubsequentScreenToScreenColorExpandFill)(
			pScrn, x, y, blit_w, blit_h,
			pCache->x, pCache->y + phaseY, skipleft);
		w -= blit_w;
		if(!w) break;
		x += blit_w;
		skipleft = (skipleft + blit_w) % pCache->orig_w;
	    }
	    height -= blit_h;
	    if(!height) break;
	    y += blit_h;
	    phaseY = (phaseY + blit_h) % pCache->orig_h;
	}
	pBox++;
d779 1
a779 1
    
d783 1
a783 2

	/******************\
a786 2


d791 5
a795 9
WriteColumn(
    ScrnInfoPtr pScrn,
    unsigned char *pSrc,
    int x, int y, int w, int h,
    int xoff, int yoff,
    int pHeight,
    int srcwidth,
    int Bpp
) {
d802 4
a805 4
   
    if((skipleft = (long)pSrc & 0x03L)) {
        if(Bpp == 3)
           skipleft = 4 - skipleft;
d807 1
a807 1
           skipleft /= Bpp;
d809 1
a809 1
        x -= skipleft;       
d811 5
a815 5
        
        if(Bpp == 3)
           pSrc -= 3 * skipleft;  
        else   /* is this Alpha friendly ? */
           pSrc = (unsigned char*)((long)pSrc & ~0x03L);     
d822 2
a823 2
    if((infoRec->ImageWriteFlags & CPU_TRANSFER_PAD_QWORD) && 
                                                ((dwords * h) & 0x01)) {
d825 1
a825 1
    } 
d827 1
a827 1
    (*infoRec->SubsequentImageWriteRect)(pScrn, x, y, w, h, skipleft);
d829 4
a832 4
    if(dwords > infoRec->ImageWriteRange) {
        while(h--) {
            XAAMoveDWORDS_FixedBase((CARD32*)infoRec->ImageWriteBase,
                (CARD32*)src, dwords);
d834 5
a838 5
	    yoff++;
	    if(yoff >= pHeight) {
		yoff = 0;
		src = pSrc;
	    }
d840 12
a851 9
    } else {
        if(srcwidth == (dwords << 2)) {
           int maxLines = infoRec->ImageWriteRange/dwords;
	   int step;

	   while(h) {
		step = pHeight - yoff;
		if(step > maxLines) step = maxLines;
		if(step > h) step = h;
d853 2
a854 2
                XAAMoveDWORDS((CARD32*)infoRec->ImageWriteBase,
                        (CARD32*)src, dwords * step);
d857 12
a868 11
		yoff += step;
		if(yoff >= pHeight) {
		    yoff = 0;
		    src = pSrc;
		}
                h -= step;		
	   }
        } else {
            while(h--) {
                XAAMoveDWORDS((CARD32*)infoRec->ImageWriteBase,
                        (CARD32*)src, dwords);
d870 5
a874 5
		yoff++;
		if(yoff >= pHeight) {
		    yoff = 0;
		    src = pSrc;
		}
d879 3
a881 2
    if(PlusOne) {
        CARD32* base = (CARD32*)infoRec->ImageWriteBase;
d887 6
a892 9
XAAFillImageWriteRects(
    ScrnInfoPtr pScrn,
    int rop,
    unsigned int planemask,
    int nBox,
    BoxPtr pBox,
    int xorg, int yorg,
    PixmapPtr pPix
){
d900 31
a930 2
    (*infoRec->SetupForImageWrite)(pScrn, rop, planemask, -1,
		pPix->drawable.bitsPerPixel, pPix->drawable.depth);
d932 4
a935 27
    while(nBox--) {
	x = pBox->x1;
	phaseY = (pBox->y1 - yorg) % pHeight;
	if(phaseY < 0) phaseY += pHeight;
	phaseX = (x - xorg) % pWidth;
	if(phaseX < 0) phaseX += pWidth;
	height = pBox->y2 - pBox->y1;
	width = pBox->x2 - x;
	
	while(1) {
	    blit_w = pWidth - phaseX;
	    if(blit_w > width) blit_w = width;

	    WriteColumn(pScrn, pPix->devPrivate.ptr, x, pBox->y1, 
		blit_w, height, phaseX, phaseY, pHeight, srcwidth, Bpp);

	    width -= blit_w;
	    if(!width) break;
	    x += blit_w;
	    phaseX = (phaseX + blit_w) % pWidth;
	}
	pBox++;
    }

    if(infoRec->ImageWriteFlags & SYNC_AFTER_IMAGE_WRITE)
        (*infoRec->Sync)(pScrn);
    else SET_SYNC_FLAG(infoRec);
d938 1
a938 2

	/*************\
a941 1

d943 4
a946 7
XAAClipAndRenderRects(
   GCPtr pGC, 
   ClipAndRenderRectsFunc BoxFunc, 
   int nrectFill, 
   xRectangle *prect, 
   int xorg, int yorg
){
d948 2
a949 2
    int 	Right, Bottom, MaxBoxes;
    BoxPtr 	pextent, pboxClipped, pboxClippedBase;
d951 2
a952 2
    MaxBoxes = infoRec->PreAllocSize/sizeof(BoxRec);  
    pboxClippedBase = (BoxPtr)infoRec->PreAllocMem;
d956 71
a1026 70
	pextent = RegionRects(pGC->pCompositeClip);
    	while (nrectFill--) {
	    pboxClipped->x1 = max(pextent->x1, prect->x);
	    pboxClipped->y1 = max(pextent->y1, prect->y);

	    Right = (int)prect->x + (int)prect->width;
	    pboxClipped->x2 = min(pextent->x2, Right);
    
	    Bottom = (int)prect->y + (int)prect->height;
	    pboxClipped->y2 = min(pextent->y2, Bottom);

	    prect++;
	    if ((pboxClipped->x1 < pboxClipped->x2) &&
		(pboxClipped->y1 < pboxClipped->y2)) {
		pboxClipped++;
		if(pboxClipped >= (pboxClippedBase + MaxBoxes)) {
		    (*BoxFunc)(pGC, MaxBoxes, pboxClippedBase, xorg, yorg); 
		    pboxClipped = pboxClippedBase;
		}
	    }
    	}
    } else {
	pextent = RegionExtents(pGC->pCompositeClip);
    	while (nrectFill--) {
	    int n;
	    BoxRec box, *pbox;
   
	    box.x1 = max(pextent->x1, prect->x);
   	    box.y1 = max(pextent->y1, prect->y);
     
	    Right = (int)prect->x + (int)prect->width;
	    box.x2 = min(pextent->x2, Right);
  
	    Bottom = (int)prect->y + (int)prect->height;
	    box.y2 = min(pextent->y2, Bottom);
    
	    prect++;
    
	    if ((box.x1 >= box.x2) || (box.y1 >= box.y2))
	    	continue;
    
	    n = RegionNumRects (pGC->pCompositeClip);
	    pbox = RegionRects(pGC->pCompositeClip);
    
	    /* clip the rectangle to each box in the clip region
	       this is logically equivalent to calling Intersect()
	    */
	    while(n--) {
		pboxClipped->x1 = max(box.x1, pbox->x1);
		pboxClipped->y1 = max(box.y1, pbox->y1);
		pboxClipped->x2 = min(box.x2, pbox->x2);
		pboxClipped->y2 = min(box.y2, pbox->y2);
		pbox++;

		/* see if clipping left anything */
		if(pboxClipped->x1 < pboxClipped->x2 && 
		   pboxClipped->y1 < pboxClipped->y2) {
		    pboxClipped++;
		    if(pboxClipped >= (pboxClippedBase + MaxBoxes)) {
			(*BoxFunc)(pGC, MaxBoxes, pboxClippedBase, xorg, yorg); 
			pboxClipped = pboxClippedBase;
		    }
		}
	    }
    	}
    }

    if(pboxClipped != pboxClippedBase)
	(*BoxFunc)(pGC, pboxClipped - pboxClippedBase, pboxClippedBase, 
					xorg, yorg); 
a1028 1

d1030 8
a1037 10
XAAGetRectClipBoxes(
    GCPtr pGC,
    BoxPtr pboxClippedBase,
    int nrectFill,
    xRectangle *prectInit
){
    int 	Right, Bottom;
    BoxPtr 	pextent, pboxClipped = pboxClippedBase;
    xRectangle	*prect = prectInit;
    RegionPtr   prgnClip = pGC->pCompositeClip;
d1040 58
a1097 57
	pextent = RegionRects(prgnClip);
    	while (nrectFill--) {
	    pboxClipped->x1 = max(pextent->x1, prect->x);
	    pboxClipped->y1 = max(pextent->y1, prect->y);

	    Right = (int)prect->x + (int)prect->width;
	    pboxClipped->x2 = min(pextent->x2, Right);
    
	    Bottom = (int)prect->y + (int)prect->height;
	    pboxClipped->y2 = min(pextent->y2, Bottom);

	    prect++;
	    if ((pboxClipped->x1 < pboxClipped->x2) &&
		(pboxClipped->y1 < pboxClipped->y2)) {
		pboxClipped++;
	    }
    	}
    } else {
	pextent = RegionExtents(prgnClip);
    	while (nrectFill--) {
	    int n;
	    BoxRec box, *pbox;
   
	    box.x1 = max(pextent->x1, prect->x);
   	    box.y1 = max(pextent->y1, prect->y);
     
	    Right = (int)prect->x + (int)prect->width;
	    box.x2 = min(pextent->x2, Right);
  
	    Bottom = (int)prect->y + (int)prect->height;
	    box.y2 = min(pextent->y2, Bottom);
    
	    prect++;
    
	    if ((box.x1 >= box.x2) || (box.y1 >= box.y2))
	    	continue;
    
	    n = RegionNumRects (prgnClip);
	    pbox = RegionRects(prgnClip);
    
	    /* clip the rectangle to each box in the clip region
	       this is logically equivalent to calling Intersect()
	    */
	    while(n--) {
		pboxClipped->x1 = max(box.x1, pbox->x1);
		pboxClipped->y1 = max(box.y1, pbox->y1);
		pboxClipped->x2 = min(box.x2, pbox->x2);
		pboxClipped->y2 = min(box.y2, pbox->y2);
		pbox++;

		/* see if clipping left anything */
		if(pboxClipped->x1 < pboxClipped->x2 && 
		   pboxClipped->y1 < pboxClipped->y2) {
		    pboxClipped++;
		}
	    }
    	}
a1101 1

@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d43 1
a43 1
    if(!REGION_NUM_RECTS(pGC->pCompositeClip))
d947 2
a948 2
    if (REGION_NUM_RECTS(pGC->pCompositeClip) == 1) {
	pextent = REGION_RECTS(pGC->pCompositeClip);
d970 1
a970 1
	pextent = REGION_EXTENTS(pGC->pScreen, pGC->pCompositeClip);
d989 2
a990 2
	    n = REGION_NUM_RECTS (pGC->pCompositeClip);
	    pbox = REGION_RECTS(pGC->pCompositeClip);
d1033 2
a1034 2
    if (REGION_NUM_RECTS(prgnClip) == 1) {
	pextent = REGION_RECTS(prgnClip);
d1052 1
a1052 1
	pextent = REGION_EXTENTS(pGC->pScreen, prgnClip);
d1071 2
a1072 2
	    n = REGION_NUM_RECTS (prgnClip);
	    pbox = REGION_RECTS(prgnClip);
d1093 1
a1093 1
    return(pboxClipped - pboxClippedBase);  
@


1.1
log
@Initial revision
@
text
@d590 1
a590 1
void 
d712 1
a712 1
void 
d815 1
a815 1
    dwords = ((w * Bpp) + 3) >> 2;
d876 1
a876 1
void 
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
