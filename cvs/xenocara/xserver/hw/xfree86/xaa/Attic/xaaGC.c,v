head	1.8;
access;
symbols
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.10
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.6
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2013.06.07.17.28.53;	author matthieu;	state dead;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.27;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.50;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.50;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.58.24;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <string.h>

#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"

#include <X11/X.h>
#include "scrnintstr.h"
#include "xf86str.h"
#include "xaa.h"
#include "xaalocal.h"
#include "migc.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "xaawrap.h"

static void XAAValidateGC(GCPtr pGC, unsigned long changes, DrawablePtr pDraw);
static void XAAChangeGC(GCPtr pGC, unsigned long mask);
static void XAACopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst);
static void XAADestroyGC(GCPtr pGC);
static void XAAChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects);
static void XAADestroyClip(GCPtr pGC);
static void XAACopyClip(GCPtr pgcDst, GCPtr pgcSrc);

GCFuncs XAAGCFuncs = {
    XAAValidateGC, XAAChangeGC, XAACopyGC, XAADestroyGC,
    XAAChangeClip, XAADestroyClip, XAACopyClip
};

extern GCOps XAAPixmapOps;

Bool
XAACreateGC(GCPtr pGC)
{
    ScreenPtr pScreen = pGC->pScreen;
    XAAGCPtr pGCPriv = (XAAGCPtr) dixLookupPrivate(&pGC->devPrivates,
                                                   XAAGetGCKey());
    Bool ret;

    XAA_SCREEN_PROLOGUE(pScreen, CreateGC);

    if ((ret = (*pScreen->CreateGC) (pGC))) {
        pGCPriv->wrapOps = NULL;
        pGCPriv->wrapFuncs = pGC->funcs;
        pGCPriv->XAAOps = &XAAFallbackOps;
        pGC->funcs = &XAAGCFuncs;
    }

    XAA_SCREEN_EPILOGUE(pScreen, CreateGC, XAACreateGC);

    return ret;
}

static void
XAAValidateGC(GCPtr pGC, unsigned long changes, DrawablePtr pDraw)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);

    XAA_GC_FUNC_PROLOGUE(pGC);

    (*pGC->funcs->ValidateGC) (pGC, changes, pDraw);

    if ((changes & GCPlaneMask) &&
        ((pGC->planemask & infoRec->FullPlanemasks[pGC->depth - 1]) ==
         infoRec->FullPlanemasks[pGC->depth - 1])) {
        pGC->planemask = ~0;
    }

    if (pGC->depth != 32) {
        /* 0xffffffff is reserved for transparency */
        if (pGC->bgPixel == 0xffffffff)
            pGC->bgPixel = 0x7fffffff;
        if (pGC->fgPixel == 0xffffffff)
            pGC->fgPixel = 0x7fffffff;
    }

    if ((pDraw->type == DRAWABLE_PIXMAP) && !IS_OFFSCREEN_PIXMAP(pDraw)) {
        pGCPriv->flags = OPS_ARE_PIXMAP;
        pGCPriv->changes |= changes;

        /* make sure we're not using videomemory pixmaps to render
           onto system memory drawables */

        if ((pGC->fillStyle == FillTiled) &&
            IS_OFFSCREEN_PIXMAP(pGC->tile.pixmap) &&
            !OFFSCREEN_PIXMAP_LOCKED(pGC->tile.pixmap)) {

            XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
            FBAreaPtr area = pPriv->offscreenArea;

            XAARemoveAreaCallback(area);        /* clobbers pPriv->offscreenArea */
            xf86FreeOffscreenArea(area);
        }
    }
    else if (!infoRec->pScrn->vtSema && (pDraw->type == DRAWABLE_WINDOW)) {
        pGCPriv->flags = 0;
        pGCPriv->changes |= changes;
    }
    else {
        if (!(pGCPriv->flags & OPS_ARE_ACCEL)) {
            changes |= pGCPriv->changes;
            pGCPriv->changes = 0;
        }
        pGCPriv->flags = OPS_ARE_ACCEL;

#if 1
        /* Ugh.  If we can't use the blitter on offscreen pixmaps used
           as tiles, then we need to move them out as cfb can't handle
           tiles with non-zero origins */

        if ((pGC->fillStyle == FillTiled) &&
            IS_OFFSCREEN_PIXMAP(pGC->tile.pixmap) &&
            (DO_PIXMAP_COPY != (*infoRec->TiledFillChooser) (pGC))) {

            XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
            FBAreaPtr area = pPriv->offscreenArea;

            XAARemoveAreaCallback(area);        /* clobbers pPriv->offscreenArea */
            xf86FreeOffscreenArea(area);
        }
#endif
    }

    XAA_GC_FUNC_EPILOGUE(pGC);

    if (!(pGCPriv->flags & OPS_ARE_ACCEL))
        return;

    if ((changes & GCTile) && !pGC->tileIsPixel && pGC->tile.pixmap) {
        XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);

        if (pixPriv->flags & DIRTY) {
            pixPriv->flags &= ~(DIRTY | REDUCIBILITY_MASK);
            pGC->tile.pixmap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
        }
    }
    if ((changes & GCStipple) && pGC->stipple) {
        XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);

        if (pixPriv->flags & DIRTY) {
            pixPriv->flags &= ~(DIRTY | REDUCIBILITY_MASK);
            pGC->stipple->drawable.serialNumber = NEXT_SERIAL_NUMBER;
        }
    }

    /* If our Ops are still the default ones we need to allocate new ones */
    if (pGC->ops == &XAAFallbackOps) {
        if (!(pGCPriv->XAAOps = malloc(sizeof(GCOps)))) {
            pGCPriv->XAAOps = &XAAFallbackOps;
            return;
        }
        /* make a modifiable copy of the default ops */
        memcpy(pGCPriv->XAAOps, &XAAFallbackOps, sizeof(GCOps));
        pGC->ops = pGCPriv->XAAOps;
        changes = ~0;
    }

    if (!changes)
        return;

    if ((changes & GCDashList) && infoRec->ComputeDash)
        infoRec->ComputeDash(pGC);

    if (changes & infoRec->FillSpansMask)
        (*infoRec->ValidateFillSpans) (pGC, changes, pDraw);

    if (changes & infoRec->SetSpansMask)
        (*infoRec->ValidateSetSpans) (pGC, changes, pDraw);

    if (changes & infoRec->PutImageMask)
        (*infoRec->ValidatePutImage) (pGC, changes, pDraw);

    if (changes & infoRec->CopyAreaMask)
        (*infoRec->ValidateCopyArea) (pGC, changes, pDraw);

    if (changes & infoRec->CopyPlaneMask)
        (*infoRec->ValidateCopyPlane) (pGC, changes, pDraw);

    if (changes & infoRec->PolyPointMask)
        (*infoRec->ValidatePolyPoint) (pGC, changes, pDraw);

    if (changes & infoRec->PolylinesMask)
        (*infoRec->ValidatePolylines) (pGC, changes, pDraw);

    if (changes & infoRec->PolySegmentMask)
        (*infoRec->ValidatePolySegment) (pGC, changes, pDraw);

    if (changes & infoRec->PolyRectangleMask)
        (*infoRec->ValidatePolyRectangle) (pGC, changes, pDraw);

    if (changes & infoRec->PolyArcMask)
        (*infoRec->ValidatePolyArc) (pGC, changes, pDraw);

    if (changes & infoRec->FillPolygonMask)
        (*infoRec->ValidateFillPolygon) (pGC, changes, pDraw);

    if (changes & infoRec->PolyFillRectMask)
        (*infoRec->ValidatePolyFillRect) (pGC, changes, pDraw);

    if (changes & infoRec->PolyFillArcMask)
        (*infoRec->ValidatePolyFillArc) (pGC, changes, pDraw);

    if (changes & infoRec->PolyGlyphBltMask)
        (*infoRec->ValidatePolyGlyphBlt) (pGC, changes, pDraw);

    if (changes & infoRec->ImageGlyphBltMask)
        (*infoRec->ValidateImageGlyphBlt) (pGC, changes, pDraw);

    if (changes & infoRec->PolyText8Mask)
        (*infoRec->ValidatePolyText8) (pGC, changes, pDraw);

    if (changes & infoRec->PolyText16Mask)
        (*infoRec->ValidatePolyText16) (pGC, changes, pDraw);

    if (changes & infoRec->ImageText8Mask)
        (*infoRec->ValidateImageText8) (pGC, changes, pDraw);

    if (changes & infoRec->ImageText16Mask)
        (*infoRec->ValidateImageText16) (pGC, changes, pDraw);

    if (changes & infoRec->PushPixelsMask)
        (*infoRec->ValidatePushPixels) (pGC, changes, pDraw);
}

static void
XAADestroyGC(GCPtr pGC)
{
    XAA_GC_FUNC_PROLOGUE(pGC);

    if (pGCPriv->XAAOps != &XAAFallbackOps)
        free(pGCPriv->XAAOps);

    free(pGCPriv->DashPattern);
    pGCPriv->flags = 0;

    (*pGC->funcs->DestroyGC) (pGC);
    XAA_GC_FUNC_EPILOGUE(pGC);
}

static void
XAAChangeGC(GCPtr pGC, unsigned long mask)
{
    XAA_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->ChangeGC) (pGC, mask);
    XAA_GC_FUNC_EPILOGUE(pGC);

    /* we have to assume that shared memory pixmaps are dirty 
       because we can't wrap all operations on them */

    if ((mask & GCTile) && !pGC->tileIsPixel &&
        PIXMAP_IS_SHARED(pGC->tile.pixmap)) {
        XAAPixmapPtr pPixPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);

        pPixPriv->flags |= DIRTY;
    }

    if ((mask & GCStipple) && PIXMAP_IS_SHARED(pGC->stipple)) {
        XAAPixmapPtr pPixPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);

        pPixPriv->flags |= DIRTY;
    }
}

static void
XAACopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst)
{
    XAA_GC_FUNC_PROLOGUE(pGCDst);
    (*pGCDst->funcs->CopyGC) (pGCSrc, mask, pGCDst);
    XAA_GC_FUNC_EPILOGUE(pGCDst);
}

static void
XAAChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects)
{
    XAA_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->ChangeClip) (pGC, type, pvalue, nrects);
    XAA_GC_FUNC_EPILOGUE(pGC);
}

static void
XAACopyClip(GCPtr pgcDst, GCPtr pgcSrc)
{
    XAA_GC_FUNC_PROLOGUE(pgcDst);
    (*pgcDst->funcs->CopyClip) (pgcDst, pgcSrc);
    XAA_GC_FUNC_EPILOGUE(pgcDst);
}

static void
XAADestroyClip(GCPtr pGC)
{
    XAA_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->DestroyClip) (pGC);
    XAA_GC_FUNC_EPILOGUE(pGC);
}

/**** Pixmap Wrappers ****/

static void
XAAFillSpansPixmap(DrawablePtr pDraw,
                   GC * pGC,
                   int nInit, DDXPointPtr pptInit, int *pwidthInit, int fSorted)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->FillSpans) (pDraw, pGC, nInit, pptInit, pwidthInit, fSorted);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

static void
XAASetSpansPixmap(DrawablePtr pDraw,
                  GCPtr pGC,
                  char *pcharsrc,
                  register DDXPointPtr ppt,
                  int *pwidth, int nspans, int fSorted)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->SetSpans) (pDraw, pGC, pcharsrc, ppt, pwidth, nspans, fSorted);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

static void
XAAPutImagePixmap(DrawablePtr pDraw,
                  GCPtr pGC,
                  int depth,
                  int x, int y, int w, int h,
                  int leftPad, int format, char *pImage)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->PutImage) (pDraw, pGC, depth, x, y, w, h,
                           leftPad, format, pImage);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

static RegionPtr
XAACopyAreaPixmap(DrawablePtr pSrc,
                  DrawablePtr pDst,
                  GC * pGC,
                  int srcx, int srcy, int width, int height, int dstx, int dsty)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    RegionPtr ret;

    if (infoRec->pScrn->vtSema &&
        ((pSrc->type == DRAWABLE_WINDOW) || IS_OFFSCREEN_PIXMAP(pSrc))) {
        if (infoRec->ReadPixmap && (pGC->alu == GXcopy) &&
            (pSrc->bitsPerPixel == pDst->bitsPerPixel) &&
            ((pGC->planemask & infoRec->FullPlanemasks[pSrc->depth - 1])
             == infoRec->FullPlanemasks[pSrc->depth - 1])) {
            XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE((PixmapPtr) (pDst));

            pixPriv->flags |= DIRTY;

            return (XAABitBlt(pSrc, pDst, pGC,
                              srcx, srcy, width, height, dstx, dsty,
                              XAADoImageRead, 0L));
        }
        else if (infoRec->NeedToSync) {
            (*infoRec->Sync) (infoRec->pScrn);
            infoRec->NeedToSync = FALSE;
        }
    }

    {
        XAA_PIXMAP_OP_PROLOGUE(pGC, pDst);
        ret = (*pGC->ops->CopyArea) (pSrc, pDst,
                                     pGC, srcx, srcy, width, height, dstx,
                                     dsty);
        XAA_PIXMAP_OP_EPILOGUE(pGC);
    }
    return ret;
}

static RegionPtr
XAACopyPlanePixmap(DrawablePtr pSrc,
                   DrawablePtr pDst,
                   GCPtr pGC,
                   int srcx, int srcy,
                   int width, int height,
                   int dstx, int dsty, unsigned long bitPlane)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    RegionPtr ret;

    XAA_PIXMAP_OP_PROLOGUE(pGC, pDst);

    if (infoRec->pScrn->vtSema &&
        ((pSrc->type == DRAWABLE_WINDOW) || IS_OFFSCREEN_PIXMAP(pSrc))) {
        if (infoRec->NeedToSync) {
            (*infoRec->Sync) (infoRec->pScrn);
            infoRec->NeedToSync = FALSE;
        }
    }

    ret = (*pGC->ops->CopyPlane) (pSrc, pDst,
                                  pGC, srcx, srcy, width, height, dstx, dsty,
                                  bitPlane);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
    return ret;
}

static void
XAAPolyPointPixmap(DrawablePtr pDraw,
                   GCPtr pGC, int mode, int npt, xPoint * pptInit)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->PolyPoint) (pDraw, pGC, mode, npt, pptInit);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

static void
XAAPolylinesPixmap(DrawablePtr pDraw,
                   GCPtr pGC, int mode, int npt, DDXPointPtr pptInit)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->Polylines) (pDraw, pGC, mode, npt, pptInit);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

static void
XAAPolySegmentPixmap(DrawablePtr pDraw, GCPtr pGC, int nseg, xSegment * pSeg)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->PolySegment) (pDraw, pGC, nseg, pSeg);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

static void
XAAPolyRectanglePixmap(DrawablePtr pDraw,
                       GCPtr pGC, int nRectsInit, xRectangle *pRectsInit)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->PolyRectangle) (pDraw, pGC, nRectsInit, pRectsInit);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

static void
XAAPolyArcPixmap(DrawablePtr pDraw, GCPtr pGC, int narcs, xArc * parcs)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->PolyArc) (pDraw, pGC, narcs, parcs);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

static void
XAAFillPolygonPixmap(DrawablePtr pDraw,
                     GCPtr pGC,
                     int shape, int mode, int count, DDXPointPtr ptsIn)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->FillPolygon) (pDraw, pGC, shape, mode, count, ptsIn);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

static void
XAAPolyFillRectPixmap(DrawablePtr pDraw,
                      GCPtr pGC, int nrectFill, xRectangle *prectInit)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->PolyFillRect) (pDraw, pGC, nrectFill, prectInit);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

static void
XAAPolyFillArcPixmap(DrawablePtr pDraw, GCPtr pGC, int narcs, xArc * parcs)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->PolyFillArc) (pDraw, pGC, narcs, parcs);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

static int
XAAPolyText8Pixmap(DrawablePtr pDraw,
                   GCPtr pGC, int x, int y, int count, char *chars)
{
    int ret;

    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    ret = (*pGC->ops->PolyText8) (pDraw, pGC, x, y, count, chars);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
    return ret;
}

static int
XAAPolyText16Pixmap(DrawablePtr pDraw,
                    GCPtr pGC, int x, int y, int count, unsigned short *chars)
{
    int ret;

    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    ret = (*pGC->ops->PolyText16) (pDraw, pGC, x, y, count, chars);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
    return ret;
}

static void
XAAImageText8Pixmap(DrawablePtr pDraw,
                    GCPtr pGC, int x, int y, int count, char *chars)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->ImageText8) (pDraw, pGC, x, y, count, chars);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

static void
XAAImageText16Pixmap(DrawablePtr pDraw,
                     GCPtr pGC, int x, int y, int count, unsigned short *chars)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->ImageText16) (pDraw, pGC, x, y, count, chars);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

static void
XAAImageGlyphBltPixmap(DrawablePtr pDraw,
                       GCPtr pGC,
                       int xInit, int yInit,
                       unsigned int nglyph,
                       CharInfoPtr * ppci, pointer pglyphBase)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->ImageGlyphBlt) (pDraw, pGC, xInit, yInit, nglyph,
                                ppci, pglyphBase);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

static void
XAAPolyGlyphBltPixmap(DrawablePtr pDraw,
                      GCPtr pGC,
                      int xInit, int yInit,
                      unsigned int nglyph,
                      CharInfoPtr * ppci, pointer pglyphBase)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->PolyGlyphBlt) (pDraw, pGC, xInit, yInit, nglyph,
                               ppci, pglyphBase);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

static void
XAAPushPixelsPixmap(GCPtr pGC,
                    PixmapPtr pBitMap,
                    DrawablePtr pDraw, int dx, int dy, int xOrg, int yOrg)
{
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->PushPixels) (pGC, pBitMap, pDraw, dx, dy, xOrg, yOrg);
    XAA_PIXMAP_OP_EPILOGUE(pGC);
}

GCOps XAAPixmapOps = {
    XAAFillSpansPixmap, XAASetSpansPixmap,
    XAAPutImagePixmap, XAACopyAreaPixmap,
    XAACopyPlanePixmap, XAAPolyPointPixmap,
    XAAPolylinesPixmap, XAAPolySegmentPixmap,
    XAAPolyRectanglePixmap, XAAPolyArcPixmap,
    XAAFillPolygonPixmap, XAAPolyFillRectPixmap,
    XAAPolyFillArcPixmap, XAAPolyText8Pixmap,
    XAAPolyText16Pixmap, XAAImageText8Pixmap,
    XAAImageText16Pixmap, XAAImageGlyphBltPixmap,
    XAAPolyGlyphBltPixmap, XAAPushPixelsPixmap,
};
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@@


1.6
log
@Bugfix Update to xserver 1.11.3
@
text
@d40 12
a51 12
    ScreenPtr    pScreen = pGC->pScreen;
    XAAGCPtr     pGCPriv = (XAAGCPtr)dixLookupPrivate(&pGC->devPrivates,
						      XAAGetGCKey());
    Bool         ret;

    XAA_SCREEN_PROLOGUE(pScreen,CreateGC);

    if((ret = (*pScreen->CreateGC)(pGC))) {	
	pGCPriv->wrapOps = NULL;
	pGCPriv->wrapFuncs = pGC->funcs;
	pGCPriv->XAAOps = &XAAFallbackOps;
	pGC->funcs = &XAAGCFuncs;
d53 2
a54 2
 
    XAA_SCREEN_EPILOGUE(pScreen,CreateGC,XAACreateGC);
a58 1

d60 2
a61 5
XAAValidateGC(
   GCPtr         pGC,
   unsigned long changes,
   DrawablePtr   pDraw 
){
d63 1
d66 1
a66 1
    (*pGC->funcs->ValidateGC)(pGC, changes, pDraw);
d68 4
a71 5
    if((changes & GCPlaneMask) &&
       ((pGC->planemask & infoRec->FullPlanemasks[pGC->depth - 1]) == 
	 infoRec->FullPlanemasks[pGC->depth - 1]))
    {	
	pGC->planemask = ~0;
d74 6
a79 6
    if(pGC->depth != 32) {
	/* 0xffffffff is reserved for transparency */
	if(pGC->bgPixel == 0xffffffff)
	    pGC->bgPixel = 0x7fffffff;
	if(pGC->fgPixel == 0xffffffff)
	    pGC->fgPixel = 0x7fffffff;
d82 2
a83 2
    if((pDraw->type == DRAWABLE_PIXMAP) && !IS_OFFSCREEN_PIXMAP(pDraw)){
	pGCPriv->flags = OPS_ARE_PIXMAP;
d86 2
a87 2
	/* make sure we're not using videomemory pixmaps to render
	   onto system memory drawables */
d89 13
a101 13
	if((pGC->fillStyle == FillTiled) && 
	    IS_OFFSCREEN_PIXMAP(pGC->tile.pixmap) &&
	    !OFFSCREEN_PIXMAP_LOCKED(pGC->tile.pixmap)) {

	    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
	    FBAreaPtr area = pPriv->offscreenArea;

	    XAARemoveAreaCallback(area); /* clobbers pPriv->offscreenArea */
	    xf86FreeOffscreenArea(area);
	}
    } 
    else if(!infoRec->pScrn->vtSema && (pDraw->type == DRAWABLE_WINDOW)) {
	pGCPriv->flags = 0;
d105 5
a109 5
	if(!(pGCPriv->flags & OPS_ARE_ACCEL)) {	
	    changes |= pGCPriv->changes;
	    pGCPriv->changes = 0;
	}
	pGCPriv->flags = OPS_ARE_ACCEL;
d112 14
a125 14
	/* Ugh.  If we can't use the blitter on offscreen pixmaps used
	   as tiles, then we need to move them out as cfb can't handle
	   tiles with non-zero origins */

	if((pGC->fillStyle == FillTiled) && 
	    IS_OFFSCREEN_PIXMAP(pGC->tile.pixmap) &&
	    (DO_PIXMAP_COPY != (*infoRec->TiledFillChooser)(pGC))) {

	    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
	    FBAreaPtr area = pPriv->offscreenArea;

	    XAARemoveAreaCallback(area); /* clobbers pPriv->offscreenArea */
	    xf86FreeOffscreenArea(area);
	}
d131 5
a135 1
    if(!(pGCPriv->flags & OPS_ARE_ACCEL)) return;
d137 12
a148 15
    if((changes & GCTile) && !pGC->tileIsPixel && pGC->tile.pixmap){
	XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
		
	if(pixPriv->flags & DIRTY) {
	    pixPriv->flags &= ~(DIRTY | REDUCIBILITY_MASK);
	    pGC->tile.pixmap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
	}
    }
    if((changes & GCStipple) && pGC->stipple){
	XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
		
	if(pixPriv->flags & DIRTY) {
	    pixPriv->flags &= ~(DIRTY | REDUCIBILITY_MASK);
	    pGC->stipple->drawable.serialNumber = NEXT_SERIAL_NUMBER;
	}
d152 9
a160 9
    if(pGC->ops == &XAAFallbackOps) {
	if(!(pGCPriv->XAAOps = malloc(sizeof(GCOps)))) {
	    pGCPriv->XAAOps = &XAAFallbackOps;
	    return;
	}
	/* make a modifiable copy of the default ops */
	memcpy(pGCPriv->XAAOps, &XAAFallbackOps, sizeof(GCOps));
	pGC->ops = pGCPriv->XAAOps;
	changes = ~0;
d163 2
a164 1
    if(!changes) return;
d166 2
a167 2
    if((changes & GCDashList) && infoRec->ComputeDash)
	infoRec->ComputeDash(pGC);
d169 2
a170 2
    if(changes & infoRec->FillSpansMask)
	(*infoRec->ValidateFillSpans)(pGC, changes, pDraw); 	
d172 2
a173 2
    if(changes & infoRec->SetSpansMask)
	(*infoRec->ValidateSetSpans)(pGC, changes, pDraw); 	
d175 2
a176 2
    if(changes & infoRec->PutImageMask)
	(*infoRec->ValidatePutImage)(pGC, changes, pDraw); 	
d178 2
a179 2
    if(changes & infoRec->CopyAreaMask)
	(*infoRec->ValidateCopyArea)(pGC, changes, pDraw); 	
d181 2
a182 2
    if(changes & infoRec->CopyPlaneMask)
	(*infoRec->ValidateCopyPlane)(pGC, changes, pDraw); 	
d184 2
a185 2
    if(changes & infoRec->PolyPointMask)
	(*infoRec->ValidatePolyPoint)(pGC, changes, pDraw); 	
d187 2
a188 2
    if(changes & infoRec->PolylinesMask)
	(*infoRec->ValidatePolylines)(pGC, changes, pDraw); 	
d190 2
a191 2
    if(changes & infoRec->PolySegmentMask)
	(*infoRec->ValidatePolySegment)(pGC, changes, pDraw); 	
d193 2
a194 2
    if(changes & infoRec->PolyRectangleMask)
	(*infoRec->ValidatePolyRectangle)(pGC, changes, pDraw); 	
d196 2
a197 2
    if(changes & infoRec->PolyArcMask)
	(*infoRec->ValidatePolyArc)(pGC, changes, pDraw); 	
d199 2
a200 2
    if(changes & infoRec->FillPolygonMask)
	(*infoRec->ValidateFillPolygon)(pGC, changes, pDraw); 	
d202 2
a203 5
    if(changes & infoRec->PolyFillRectMask)
	(*infoRec->ValidatePolyFillRect)(pGC, changes, pDraw); 	
 
    if(changes & infoRec->PolyFillArcMask)
	(*infoRec->ValidatePolyFillArc)(pGC, changes, pDraw); 	
d205 2
a206 2
    if(changes & infoRec->PolyGlyphBltMask)
	(*infoRec->ValidatePolyGlyphBlt)(pGC, changes, pDraw);
d208 2
a209 2
    if(changes & infoRec->ImageGlyphBltMask)
	(*infoRec->ValidateImageGlyphBlt)(pGC, changes, pDraw);
d211 2
a212 5
    if(changes & infoRec->PolyText8Mask)
	(*infoRec->ValidatePolyText8)(pGC, changes, pDraw);
    
    if(changes & infoRec->PolyText16Mask)
	(*infoRec->ValidatePolyText16)(pGC, changes, pDraw);
d214 14
a227 8
    if(changes & infoRec->ImageText8Mask)
	(*infoRec->ValidateImageText8)(pGC, changes, pDraw);
    
    if(changes & infoRec->ImageText16Mask)
	(*infoRec->ValidateImageText16)(pGC, changes, pDraw);
 
    if(changes & infoRec->PushPixelsMask) 
	(*infoRec->ValidatePushPixels)(pGC, changes, pDraw); 	
a229 1

d233 4
a236 4
    XAA_GC_FUNC_PROLOGUE (pGC);
     
    if(pGCPriv->XAAOps != &XAAFallbackOps)
	free(pGCPriv->XAAOps);
d241 2
a242 2
    (*pGC->funcs->DestroyGC)(pGC);
    XAA_GC_FUNC_EPILOGUE (pGC);
d246 1
a246 4
XAAChangeGC (
    GCPtr	    pGC,
    unsigned long   mask
)
d248 1
a248 1
    XAA_GC_FUNC_PROLOGUE (pGC);
d250 1
a250 1
    XAA_GC_FUNC_EPILOGUE (pGC);
d252 2
a253 2
   /* we have to assume that shared memory pixmaps are dirty 
      because we can't wrap all operations on them */
d255 5
a259 5
    if((mask & GCTile) && !pGC->tileIsPixel &&
	PIXMAP_IS_SHARED(pGC->tile.pixmap))
    {
	XAAPixmapPtr pPixPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
	pPixPriv->flags |= DIRTY;
d262 4
a265 3
    if((mask & GCStipple) && PIXMAP_IS_SHARED(pGC->stipple)){
	XAAPixmapPtr pPixPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
	pPixPriv->flags |= DIRTY;
d270 1
a270 4
XAACopyGC (
    GCPtr	    pGCSrc, 
    unsigned long   mask,
    GCPtr	    pGCDst)
d272 1
a272 1
    XAA_GC_FUNC_PROLOGUE (pGCDst);
d274 1
a274 1
    XAA_GC_FUNC_EPILOGUE (pGCDst);
d276 1
d278 1
a278 5
XAAChangeClip (
    GCPtr   pGC,
    int		type,
    pointer	pvalue,
    int		nrects )
d280 1
a280 1
    XAA_GC_FUNC_PROLOGUE (pGC);
d282 1
a282 1
    XAA_GC_FUNC_EPILOGUE (pGC);
d288 3
a290 3
    XAA_GC_FUNC_PROLOGUE (pgcDst);
    (* pgcDst->funcs->CopyClip)(pgcDst, pgcSrc);
    XAA_GC_FUNC_EPILOGUE (pgcDst);
d296 3
a298 3
    XAA_GC_FUNC_PROLOGUE (pGC);
    (* pGC->funcs->DestroyClip)(pGC);
    XAA_GC_FUNC_EPILOGUE (pGC);
d300 1
a300 1
 
a302 2


d304 6
a309 10
XAAFillSpansPixmap(
    DrawablePtr pDraw,
    GC		*pGC,
    int		nInit,	
    DDXPointPtr pptInit,	
    int *pwidthInit,		
    int fSorted 
){
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);    
    (*pGC->ops->FillSpans)(pDraw, pGC, nInit, pptInit, pwidthInit, fSorted);
d314 8
a321 11
XAASetSpansPixmap(
    DrawablePtr		pDraw,
    GCPtr		pGC,
    char		*pcharsrc,
    register DDXPointPtr ppt,
    int			*pwidth,
    int			nspans,
    int			fSorted 
){
    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
    (*pGC->ops->SetSpans)(pDraw, pGC, pcharsrc, ppt, pwidth, nspans, fSorted);
d326 6
a331 9
XAAPutImagePixmap(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		depth, 
    int x, int y, int w, int h,
    int		leftPad,
    int		format,
    char 	*pImage 
){
d333 2
a334 2
    (*pGC->ops->PutImage)(pDraw, pGC, depth, x, y, w, h, 
		leftPad, format, pImage);
d339 5
a343 8
XAACopyAreaPixmap(
    DrawablePtr pSrc,
    DrawablePtr pDst,
    GC *pGC,
    int srcx, int srcy,
    int width, int height,
    int dstx, int dsty 
){
d347 19
a365 20
    if(infoRec->pScrn->vtSema && 
	((pSrc->type == DRAWABLE_WINDOW) || IS_OFFSCREEN_PIXMAP(pSrc))) 
    {
	if(infoRec->ReadPixmap && (pGC->alu == GXcopy) &&
           (pSrc->bitsPerPixel == pDst->bitsPerPixel) &&
          ((pGC->planemask & infoRec->FullPlanemasks[pSrc->depth - 1])
              == infoRec->FullPlanemasks[pSrc->depth - 1]))
        {
            XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE((PixmapPtr)(pDst));
	    pixPriv->flags |= DIRTY; 

            return (XAABitBlt( pSrc, pDst, pGC,
                srcx, srcy, width, height, dstx, dsty,
                XAADoImageRead, 0L));
        } else
	if(infoRec->NeedToSync) {
	   (*infoRec->Sync)(infoRec->pScrn);
	    infoRec->NeedToSync = FALSE;
	}
    }    
d368 5
a372 4
	XAA_PIXMAP_OP_PROLOGUE(pGC, pDst);
	ret = (*pGC->ops->CopyArea)(pSrc, pDst,
            pGC, srcx, srcy, width, height, dstx, dsty);
	XAA_PIXMAP_OP_EPILOGUE(pGC);
d378 7
a384 9
XAACopyPlanePixmap(
    DrawablePtr	pSrc,
    DrawablePtr	pDst,
    GCPtr pGC,
    int	srcx, int srcy,
    int	width, int height,
    int	dstx, int dsty,
    unsigned long bitPlane 
){
d390 7
a396 7
    if(infoRec->pScrn->vtSema && 
	((pSrc->type == DRAWABLE_WINDOW) || IS_OFFSCREEN_PIXMAP(pSrc))){
	if(infoRec->NeedToSync) {
	   (*infoRec->Sync)(infoRec->pScrn);
	    infoRec->NeedToSync = FALSE;
	}
    }    
d398 3
a400 2
    ret = (*pGC->ops->CopyPlane)(pSrc, pDst,
	       pGC, srcx, srcy, width, height, dstx, dsty, bitPlane);
d406 3
a408 7
XAAPolyPointPixmap(
    DrawablePtr pDraw,
    GCPtr pGC,
    int mode,
    int npt,
    xPoint *pptInit 
){
d410 1
a410 1
    (*pGC->ops->PolyPoint)(pDraw, pGC, mode, npt, pptInit);
a413 1

d415 3
a417 7
XAAPolylinesPixmap(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		mode,		
    int		npt,		
    DDXPointPtr pptInit 
){
d419 1
a419 1
    (*pGC->ops->Polylines)(pDraw, pGC, mode, npt, pptInit);
d423 3
a425 7
static void 
XAAPolySegmentPixmap(
    DrawablePtr	pDraw,
    GCPtr	pGC,
    int		nseg,
    xSegment	*pSeg 
){
d427 1
a427 1
    (*pGC->ops->PolySegment)(pDraw, pGC, nseg, pSeg);
d432 3
a434 6
XAAPolyRectanglePixmap(
    DrawablePtr  pDraw,
    GCPtr        pGC,
    int	         nRectsInit,
    xRectangle  *pRectsInit 
){
d436 1
a436 1
    (*pGC->ops->PolyRectangle)(pDraw, pGC, nRectsInit, pRectsInit);
d441 2
a442 6
XAAPolyArcPixmap(
    DrawablePtr	pDraw,
    GCPtr	pGC,
    int		narcs,
    xArc	*parcs 
){
d444 1
a444 1
    (*pGC->ops->PolyArc)(pDraw, pGC, narcs, parcs);
d449 4
a452 8
XAAFillPolygonPixmap(
    DrawablePtr	pDraw,
    GCPtr	pGC,
    int		shape,
    int		mode,
    int		count,
    DDXPointPtr	ptsIn 
){
d454 1
a454 1
    (*pGC->ops->FillPolygon)(pDraw, pGC, shape, mode, count, ptsIn);
d458 4
a461 8

static void 
XAAPolyFillRectPixmap(
    DrawablePtr	pDraw,
    GCPtr	pGC,
    int		nrectFill, 
    xRectangle	*prectInit 
){
d463 1
a463 1
    (*pGC->ops->PolyFillRect)(pDraw, pGC, nrectFill, prectInit);
a466 1

d468 2
a469 6
XAAPolyFillArcPixmap(
    DrawablePtr	pDraw,
    GCPtr	pGC,
    int		narcs,
    xArc	*parcs 
){
d471 1
a471 1
    (*pGC->ops->PolyFillArc)(pDraw, pGC, narcs, parcs);
d476 3
a478 8
XAAPolyText8Pixmap(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x, 
    int 	y,
    int 	count,
    char	*chars 
){
d482 1
a482 1
    ret = (*pGC->ops->PolyText8)(pDraw, pGC, x, y, count, chars);
d488 3
a490 8
XAAPolyText16Pixmap(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x,
    int		y,
    int 	count,
    unsigned short *chars 
){
d494 1
a494 1
    ret = (*pGC->ops->PolyText16)(pDraw, pGC, x, y, count, chars);
d500 3
a502 8
XAAImageText8Pixmap(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x, 
    int		y,
    int 	count,
    char	*chars 
){
d504 1
a504 1
    (*pGC->ops->ImageText8)(pDraw, pGC, x, y, count, chars);
d507 1
d509 3
a511 8
XAAImageText16Pixmap(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x,
    int		y,
    int 	count,
    unsigned short *chars 
){
d513 1
a513 1
    (*pGC->ops->ImageText16)(pDraw, pGC, x, y, count, chars);
a516 1

d518 6
a523 8
XAAImageGlyphBltPixmap(
    DrawablePtr pDraw,
    GCPtr pGC,
    int xInit, int yInit,
    unsigned int nglyph,
    CharInfoPtr *ppci,
    pointer pglyphBase 
){
d525 2
a526 2
    (*pGC->ops->ImageGlyphBlt)(pDraw, pGC, xInit, yInit, nglyph, 
					ppci, pglyphBase);
d531 6
a536 8
XAAPolyGlyphBltPixmap(
    DrawablePtr pDraw,
    GCPtr pGC,
    int xInit, int yInit,
    unsigned int nglyph,
    CharInfoPtr *ppci,
    pointer pglyphBase 
){
d538 2
a539 2
    (*pGC->ops->PolyGlyphBlt)(pDraw, pGC, xInit, yInit, nglyph, 
				ppci, pglyphBase);
d544 4
a547 6
XAAPushPixelsPixmap(
    GCPtr	pGC,
    PixmapPtr	pBitMap,
    DrawablePtr pDraw,
    int	dx, int dy, int xOrg, int yOrg 
){
d549 1
a549 1
    (*pGC->ops->PushPixels)(pGC, pBitMap, pDraw, dx, dy, xOrg, yOrg);
d554 9
a562 9
    XAAFillSpansPixmap, XAASetSpansPixmap, 
    XAAPutImagePixmap, XAACopyAreaPixmap, 
    XAACopyPlanePixmap, XAAPolyPointPixmap, 
    XAAPolylinesPixmap, XAAPolySegmentPixmap, 
    XAAPolyRectanglePixmap, XAAPolyArcPixmap, 
    XAAFillPolygonPixmap, XAAPolyFillRectPixmap, 
    XAAPolyFillArcPixmap, XAAPolyText8Pixmap, 
    XAAPolyText16Pixmap, XAAImageText8Pixmap, 
    XAAImageText16Pixmap, XAAImageGlyphBltPixmap, 
@


1.5
log
@Update to xserver 1.11.2
@
text
@d242 1
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a50 5
	pGCPriv->flags = 0;
	pGCPriv->DashLength = 0;
	pGCPriv->DashPattern = NULL;
	pGCPriv->changes = 0;
	/* initialize any other private fields here */
a648 1
    {NULL}		/* devPrivate */
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d161 1
a161 1
	if(!(pGCPriv->XAAOps = xalloc(sizeof(GCOps)))) {	
d244 1
a244 1
	xfree(pGCPriv->XAAOps);
d246 1
a246 2
    if(pGCPriv->DashPattern)
	xfree(pGCPriv->DashPattern);    
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d41 2
a42 1
    XAAGCPtr     pGCPriv = (XAAGCPtr)(pGC->devPrivates[XAAGetGCIndex()].ptr);
@


1.1
log
@Initial revision
@
text
@d41 1
a41 1
    XAAGCPtr     pGCPriv = (XAAGCPtr)(pGC->devPrivates[XAAGCIndex].ptr);
d83 5
a87 4
	if(pGC->bgPixel == -1) /* -1 is reserved for transparency */
	    pGC->bgPixel = 0x7fffffff; 
	if(pGC->fgPixel == -1) /* -1 is reserved for transparency */
	    pGC->fgPixel = 0x7fffffff; 
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d41 1
a41 1
    XAAGCPtr     pGCPriv = (XAAGCPtr)(pGC->devPrivates[XAAGetGCIndex()].ptr);
@

