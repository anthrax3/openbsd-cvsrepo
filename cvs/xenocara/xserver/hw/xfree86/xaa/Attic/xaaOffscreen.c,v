head	1.4;
access;
symbols
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.1.1.0.16
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2013.06.07.17.28.53;	author matthieu;	state dead;
branches;
next	1.3;

1.3
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.50;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.50;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@
/*
   Copyright (c) 1999 -  The XFree86 Project Inc.

   Written by Mark Vojkovich

*/

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"

#include <X11/X.h>
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "xf86str.h"
#include "mi.h"
#include "miline.h"
#include "xaa.h"
#include "xaalocal.h"
#include "xaawrap.h"
#include "xf86fbman.h"
#include "servermd.h"

void
XAAMoveOutOffscreenPixmaps(ScreenPtr pScreen)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
    PixmapLinkPtr pLink = infoRec->OffscreenPixmaps;
    XAAPixmapPtr pPriv;

    while (pLink) {
        pPriv = XAA_GET_PIXMAP_PRIVATE(pLink->pPix);
        pLink->area = pPriv->offscreenArea;
        XAAMoveOutOffscreenPixmap(pLink->pPix);
        pLink = pLink->next;
    }
}

void
XAAMoveInOffscreenPixmaps(ScreenPtr pScreen)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
    PixmapLinkPtr pLink = infoRec->OffscreenPixmaps;
    PixmapPtr pPix, pScreenPix, tmpPix;
    pointer data;
    XAAPixmapPtr pPriv;
    GCPtr pGC;
    FBAreaPtr area;

    pScreenPix = (*pScreen->GetScreenPixmap) (pScreen);

    while (pLink) {
        pPix = pLink->pPix;
        pPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
        area = pLink->area;

        data = pPix->devPrivate.ptr;
        tmpPix = GetScratchPixmapHeader(pScreen,
                                        pPix->drawable.width,
                                        pPix->drawable.height,
                                        pPix->drawable.depth,
                                        pPix->drawable.bitsPerPixel,
                                        pPix->devKind, data);

        pPriv->freeData = FALSE;

        pPix->drawable.x = area->box.x1;
        pPix->drawable.y = area->box.y1;
        pPix->devKind = pScreenPix->devKind;
        pPix->devPrivate.ptr = pScreenPix->devPrivate.ptr;
        pPix->drawable.bitsPerPixel = infoRec->pScrn->bitsPerPixel;
        pPix->drawable.serialNumber = NEXT_SERIAL_NUMBER;

        if (!tmpPix) {
            pPriv->offscreenArea = area;
            free(data);
            pLink = pLink->next;
            continue;
        }

        pGC = GetScratchGC(pPix->drawable.depth, pScreen);
        ValidateGC((DrawablePtr) pPix, pGC);

        (*pGC->ops->CopyArea) ((DrawablePtr) tmpPix, (DrawablePtr) pPix, pGC,
                               0, 0, pPix->drawable.width,
                               pPix->drawable.height, 0, 0);

        free(data);
        tmpPix->devPrivate.ptr = NULL;

        FreeScratchGC(pGC);
        FreeScratchPixmapHeader(tmpPix);

        pPriv->offscreenArea = area;
        pLink->area = NULL;
        pLink = pLink->next;
    }
}

void
XAARemoveAreaCallback(FBAreaPtr area)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(area->pScreen);
    PixmapPtr pPix = (PixmapPtr) area->devPrivate.ptr;
    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pPix);

    XAAMoveOutOffscreenPixmap(pPix);

    pPriv->flags &= ~OFFSCREEN;

    DELIST_OFFSCREEN_PIXMAP(pPix);
}

void
XAAMoveOutOffscreenPixmap(PixmapPtr pPix)
{
    ScreenPtr pScreen = pPix->drawable.pScreen;
    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
    int width, height, devKind, bitsPerPixel;
    PixmapPtr tmpPix;
    unsigned char *data;
    GCPtr pGC;

    width = pPix->drawable.width;
    height = pPix->drawable.height;
    bitsPerPixel = pPix->drawable.bitsPerPixel;

    devKind = BitmapBytePad(width * bitsPerPixel);
    if (!(data = malloc(devKind * height)))
        FatalError("Out of memory\n");

    tmpPix = GetScratchPixmapHeader(pScreen, width, height,
                                    pPix->drawable.depth, bitsPerPixel, devKind,
                                    data);
    if (!tmpPix) {
        free(data);
        FatalError("Out of memory\n");
    }

    pGC = GetScratchGC(pPix->drawable.depth, pScreen);
    ValidateGC((DrawablePtr) tmpPix, pGC);

    (*pGC->ops->CopyArea) ((DrawablePtr) pPix, (DrawablePtr) tmpPix,
                           pGC, 0, 0, width, height, 0, 0);

    FreeScratchGC(pGC);
    FreeScratchPixmapHeader(tmpPix);

    pPix->drawable.x = 0;
    pPix->drawable.y = 0;
    pPix->devKind = devKind;
    pPix->devPrivate.ptr = data;
    pPix->drawable.serialNumber = NEXT_SERIAL_NUMBER;

    pPriv->offscreenArea = NULL;
    pPriv->freeData = TRUE;
}
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d7 1
a7 1
*/ 
d36 7
a42 7
    
    while(pLink) {
	pPriv = XAA_GET_PIXMAP_PRIVATE(pLink->pPix);
	pLink->area = pPriv->offscreenArea;
	XAAMoveOutOffscreenPixmap(pLink->pPix);	
	pLink = pLink->next;
    }    
a44 2


d56 1
a56 1
    pScreenPix = (*pScreen->GetScreenPixmap)(pScreen);
d58 46
a103 43
    while(pLink) {
	pPix = pLink->pPix;
    	pPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
	area = pLink->area;

	data = pPix->devPrivate.ptr;
	tmpPix = GetScratchPixmapHeader(pScreen, 
		pPix->drawable.width, pPix->drawable.height, 
		pPix->drawable.depth, pPix->drawable.bitsPerPixel, 
		pPix->devKind, data);

	pPriv->freeData = FALSE;

	pPix->drawable.x = area->box.x1;
	pPix->drawable.y = area->box.y1;
	pPix->devKind = pScreenPix->devKind;
	pPix->devPrivate.ptr = pScreenPix->devPrivate.ptr;
	pPix->drawable.bitsPerPixel = infoRec->pScrn->bitsPerPixel;
	pPix->drawable.serialNumber = NEXT_SERIAL_NUMBER;

	if(!tmpPix) {
	    pPriv->offscreenArea = area;
	    free(data);
	    pLink = pLink->next;
	    continue;
	}
	
	pGC = GetScratchGC(pPix->drawable.depth, pScreen);
	ValidateGC((DrawablePtr)pPix, pGC);

	(*pGC->ops->CopyArea)((DrawablePtr)tmpPix, (DrawablePtr)pPix, pGC, 
		0, 0, pPix->drawable.width, pPix->drawable.height, 0, 0);	

	free(data);
	tmpPix->devPrivate.ptr = NULL;

	FreeScratchGC(pGC);
	FreeScratchPixmapHeader(tmpPix);

	pPriv->offscreenArea = area;
	pLink->area = NULL;
	pLink = pLink->next;
    }    
a105 1

d110 1
a110 1
    PixmapPtr pPix = (PixmapPtr)area->devPrivate.ptr;
d115 1
a115 1
    pPriv->flags &= ~OFFSCREEN;	
d121 1
a121 1
XAAMoveOutOffscreenPixmap(PixmapPtr pPix) 
d135 2
a136 2
    if(!(data = malloc(devKind * height)))
	FatalError("Out of memory\n");
d138 6
a143 5
    tmpPix = GetScratchPixmapHeader(pScreen, width, height, 
		pPix->drawable.depth, bitsPerPixel, devKind, data);
    if(!tmpPix) {
	free(data);
	FatalError("Out of memory\n");
d147 1
a147 1
    ValidateGC((DrawablePtr)tmpPix, pGC);
d149 2
a150 2
    (*pGC->ops->CopyArea)((DrawablePtr)pPix, (DrawablePtr)tmpPix,
		pGC, 0, 0, width, height, 0, 0);	
@


1.1
log
@Initial revision
@
text
@d82 1
a82 1
	    xfree(data);
d93 1
a93 1
	xfree(data);
d135 1
a135 1
    if(!(data = xalloc(devKind * height)))
d141 1
a141 1
	xfree(data);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
