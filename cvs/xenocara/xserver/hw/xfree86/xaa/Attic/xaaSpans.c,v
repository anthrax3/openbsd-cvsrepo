head	1.5;
access;
symbols
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.06.07.17.28.53;	author matthieu;	state dead;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.28;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.45;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.45;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"

#include <X11/X.h>
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "xf86str.h"
#include "mi.h"
#include "mispans.h"
#include "xaa.h"
#include "xaalocal.h"

static void XAARenderSolidSpans(GCPtr, int, DDXPointPtr, int *, int, int, int);
static void XAARenderColor8x8Spans(GCPtr, int, DDXPointPtr, int *, int, int,
                                   int);
static void XAARenderMono8x8Spans(GCPtr, int, DDXPointPtr, int *, int, int,
                                  int);
static void XAARenderCacheBltSpans(GCPtr, int, DDXPointPtr, int *, int, int,
                                   int);
static void XAARenderColorExpandSpans(GCPtr, int, DDXPointPtr, int *, int, int,
                                      int);
static void XAARenderCacheExpandSpans(GCPtr, int, DDXPointPtr, int *, int, int,
                                      int);
static void XAARenderPixmapCopySpans(GCPtr, int, DDXPointPtr, int *, int, int,
                                     int);

void
XAAFillSpans(DrawablePtr pDraw, GC * pGC, int nInit,    /* number of spans to fill */
             DDXPointPtr pptInit,       /* pointer to list of start points */
             int *pwidthInit,   /* pointer to list of n widths */
             int fSorted)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    int type = 0;
    ClipAndRenderSpansFunc function;
    Bool fastClip = FALSE;

    if ((nInit <= 0) || !pGC->planemask)
        return;

    if (!RegionNumRects(pGC->pCompositeClip))
        return;

    switch (pGC->fillStyle) {
    case FillSolid:
        type = DO_SOLID;
        break;
    case FillStippled:
        type = (*infoRec->StippledFillChooser) (pGC);
        break;
    case FillOpaqueStippled:
        if ((pGC->fgPixel == pGC->bgPixel) && infoRec->FillSpansSolid &&
            CHECK_PLANEMASK(pGC, infoRec->FillSpansSolidFlags) &&
            CHECK_ROP(pGC, infoRec->FillSpansSolidFlags) &&
            CHECK_ROPSRC(pGC, infoRec->FillSpansSolidFlags) &&
            CHECK_FG(pGC, infoRec->FillSpansSolidFlags))
            type = DO_SOLID;
        else
            type = (*infoRec->OpaqueStippledFillChooser) (pGC);
        break;
    case FillTiled:
        type = (*infoRec->TiledFillChooser) (pGC);
        break;
    }

    switch (type) {
    case DO_SOLID:
        function = XAARenderSolidSpans;
        if (infoRec->ClippingFlags & HARDWARE_CLIP_SOLID_FILL)
            fastClip = TRUE;
        break;
    case DO_COLOR_8x8:
        function = XAARenderColor8x8Spans;
        if (infoRec->ClippingFlags & HARDWARE_CLIP_COLOR_8x8_FILL)
            fastClip = TRUE;
        break;
    case DO_MONO_8x8:
        function = XAARenderMono8x8Spans;
        if (infoRec->ClippingFlags & HARDWARE_CLIP_MONO_8x8_FILL)
            fastClip = TRUE;
        break;
    case DO_CACHE_BLT:
        function = XAARenderCacheBltSpans;
        if (infoRec->ClippingFlags & HARDWARE_CLIP_SCREEN_TO_SCREEN_COPY)
            fastClip = TRUE;
        break;
    case DO_COLOR_EXPAND:
        function = XAARenderColorExpandSpans;
        break;
    case DO_CACHE_EXPAND:
        function = XAARenderCacheExpandSpans;
        if (infoRec->ClippingFlags &
            HARDWARE_CLIP_SCREEN_TO_SCREEN_COLOR_EXPAND)
            fastClip = TRUE;
        break;
    case DO_PIXMAP_COPY:
        function = XAARenderPixmapCopySpans;
        if (infoRec->ClippingFlags & HARDWARE_CLIP_SCREEN_TO_SCREEN_COPY)
            fastClip = TRUE;
        break;
    case DO_IMAGE_WRITE:
    default:
        (*XAAFallbackOps.FillSpans) (pDraw, pGC, nInit, pptInit,
                                     pwidthInit, fSorted);
        return;
    }

    if ((nInit < 10) || (RegionNumRects(pGC->pCompositeClip) != 1))
        fastClip = FALSE;

    if (fastClip) {
        infoRec->ClipBox = &pGC->pCompositeClip->extents;
        (*function) (pGC, nInit, pptInit, pwidthInit, fSorted,
                     pDraw->x, pDraw->y);
        infoRec->ClipBox = NULL;
    }
    else
        XAAClipAndRenderSpans(pGC, pptInit, pwidthInit, nInit, fSorted,
                              function, pDraw->x, pDraw->y);
}

        /*********************\
	|     Solid Spans     |
	\*********************/

static void
XAARenderSolidSpans(GCPtr pGC,
                    int n,
                    DDXPointPtr ppt,
                    int *pwidth, int fSorted, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);

    (*infoRec->FillSolidSpans) (infoRec->pScrn, pGC->fgPixel,
                                pGC->alu, pGC->planemask, n, ppt, pwidth,
                                fSorted);
}

        /************************\
	|     Mono 8x8 Spans     |
	\************************/

static void
XAARenderMono8x8Spans(GCPtr pGC,
                      int n,
                      DDXPointPtr ppt,
                      int *pwidth, int fSorted, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    XAAPixmapPtr pPriv;
    int fg, bg;

    switch (pGC->fillStyle) {
    case FillStippled:
        pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
        fg = pGC->fgPixel;
        bg = -1;
        break;
    case FillOpaqueStippled:
        pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
        fg = pGC->fgPixel;
        bg = pGC->bgPixel;
        break;
    case FillTiled:
        pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
        fg = pPriv->fg;
        bg = pPriv->bg;
        break;
    default:                   /* Muffle compiler */
        pPriv = NULL;           /* Kaboom */
        fg = -1;
        bg = -1;
        break;
    }

    (*infoRec->FillMono8x8PatternSpans) (infoRec->pScrn,
                                         fg, bg, pGC->alu, pGC->planemask,
                                         n, ppt, pwidth, fSorted,
                                         pPriv->pattern0, pPriv->pattern1,
                                         (xorg + pGC->patOrg.x),
                                         (yorg + pGC->patOrg.y));
}

        /*************************\
	|     Color 8x8 Spans     |
	\*************************/

static void
XAARenderColor8x8Spans(GCPtr pGC,
                       int n,
                       DDXPointPtr ppt,
                       int *pwidth, int fSorted, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    XAACacheInfoPtr pCache;
    PixmapPtr pPix;
    int fg, bg;

    switch (pGC->fillStyle) {
    case FillStippled:
        pPix = pGC->stipple;
        fg = pGC->fgPixel;
        bg = -1;
        break;
    case FillOpaqueStippled:
        pPix = pGC->stipple;
        fg = pGC->fgPixel;
        bg = pGC->bgPixel;
        break;
    case FillTiled:
        pPix = pGC->tile.pixmap;
        fg = -1;
        bg = -1;
        break;
    default:                   /* Muffle compiler */
        pPix = NULL;
        fg = -1;
        bg = -1;
        break;
    }

    pCache = (*infoRec->CacheColor8x8Pattern) (infoRec->pScrn, pPix, fg, bg);

    (*infoRec->FillColor8x8PatternSpans) (infoRec->pScrn,
                                          pGC->alu, pGC->planemask, n, ppt,
                                          pwidth, fSorted, pCache,
                                          (yorg + pGC->patOrg.x),
                                          (xorg + pGC->patOrg.y));
}

        /****************************\
	|     Color Expand Spans     |
	\****************************/

static void
XAARenderColorExpandSpans(GCPtr pGC,
                          int n,
                          DDXPointPtr ppt,
                          int *pwidth, int fSorted, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    int fg, bg;

    switch (pGC->fillStyle) {
    case FillStippled:
        fg = pGC->fgPixel;
        bg = -1;
        break;
    case FillOpaqueStippled:
        fg = pGC->fgPixel;
        bg = pGC->bgPixel;
        break;
    default:                   /* Muffle compiler */
        fg = -1;
        bg = -1;
        break;
    }

    (*infoRec->FillColorExpandSpans) (infoRec->pScrn, fg, bg,
                                      pGC->alu, pGC->planemask, n, ppt, pwidth,
                                      fSorted, (xorg + pGC->patOrg.x),
                                      (yorg + pGC->patOrg.y), pGC->stipple);

}

        /*************************\
	|     Cache Blt Spans     |
	\*************************/

static void
XAARenderCacheBltSpans(GCPtr pGC,
                       int n,
                       DDXPointPtr ppt,
                       int *pwidth, int fSorted, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    XAACacheInfoPtr pCache;

    switch (pGC->fillStyle) {
    case FillStippled:
        pCache = (*infoRec->CacheStipple) (infoRec->pScrn, pGC->stipple,
                                           pGC->fgPixel, -1);
        break;
    case FillOpaqueStippled:
        pCache = (*infoRec->CacheStipple) (infoRec->pScrn, pGC->stipple,
                                           pGC->fgPixel, pGC->bgPixel);
        break;
    case FillTiled:
        pCache = (*infoRec->CacheTile) (infoRec->pScrn, pGC->tile.pixmap);
        break;
    default:                   /* Muffle compiler */
        pCache = NULL;
        break;
    }

    (*infoRec->FillCacheBltSpans) (infoRec->pScrn,
                                   pGC->alu, pGC->planemask, n, ppt, pwidth,
                                   fSorted, pCache, (xorg + pGC->patOrg.x),
                                   (yorg + pGC->patOrg.y));

}

        /****************************\
	|     Cache Expand Spans     |
	\****************************/

static void
XAARenderCacheExpandSpans(GCPtr pGC,
                          int n,
                          DDXPointPtr ppt,
                          int *pwidth, int fSorted, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    int fg, bg;

    switch (pGC->fillStyle) {
    case FillStippled:
        fg = pGC->fgPixel;
        bg = -1;
        break;
    case FillOpaqueStippled:
        fg = pGC->fgPixel;
        bg = pGC->bgPixel;
        break;
    default:                   /* Muffle compiler */
        fg = -1;
        bg = -1;
        break;
    }

    (*infoRec->FillCacheExpandSpans) (infoRec->pScrn, fg, bg,
                                      pGC->alu, pGC->planemask, n, ppt, pwidth,
                                      fSorted, (xorg + pGC->patOrg.x),
                                      (yorg + pGC->patOrg.y), pGC->stipple);
}

        /***************************\
	|     Pixmap Copy Spans     |
	\***************************/

static void
XAARenderPixmapCopySpans(GCPtr pGC,
                         int n,
                         DDXPointPtr ppt,
                         int *pwidth, int fSorted, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    XAACacheInfoPtr pCache = &(infoRec->ScratchCacheInfoRec);
    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);

    pCache->x = pPriv->offscreenArea->box.x1;
    pCache->y = pPriv->offscreenArea->box.y1;
    pCache->w = pCache->orig_w = pPriv->offscreenArea->box.x2 - pCache->x;
    pCache->h = pCache->orig_h = pPriv->offscreenArea->box.y2 - pCache->y;
    pCache->trans_color = -1;

    (*infoRec->FillCacheBltSpans) (infoRec->pScrn,
                                   pGC->alu, pGC->planemask, n, ppt, pwidth,
                                   fSorted, pCache, (xorg + pGC->patOrg.x),
                                   (yorg + pGC->patOrg.y));
}

        /****************\
	|     Solid      |
	\****************/

void
XAAFillSolidSpans(ScrnInfoPtr pScrn,
                  int fg, int rop,
                  unsigned int planemask,
                  int n, DDXPointPtr ppt, int *pwidth, int fSorted)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);

    (*infoRec->SetupForSolidFill) (pScrn, fg, rop, planemask);

    if (infoRec->ClipBox)
        (*infoRec->SetClippingRectangle) (infoRec->pScrn,
                                          infoRec->ClipBox->x1,
                                          infoRec->ClipBox->y1,
                                          infoRec->ClipBox->x2 - 1,
                                          infoRec->ClipBox->y2 - 1);

    while (n--) {
        if (*pwidth > 0)
            (*infoRec->SubsequentSolidFillRect) (pScrn, ppt->x, ppt->y,
                                                 *pwidth, 1);
        ppt++;
        pwidth++;
    }

    if (infoRec->ClipBox)
        (*infoRec->DisableClipping) (infoRec->pScrn);

    SET_SYNC_FLAG(infoRec);
}

        /***************\
	|   Mono 8x8    |
	\***************/

void
XAAFillMono8x8PatternSpansScreenOrigin(ScrnInfoPtr pScrn,
                                       int fg, int bg, int rop,
                                       unsigned int planemask,
                                       int n,
                                       DDXPointPtr ppt,
                                       int *pwidth, int fSorted,
                                       int pattern0, int pattern1,
                                       int xorigin, int yorigin)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int patx = pattern0, paty = pattern1;
    int xorg = (-xorigin) & 0x07;
    int yorg = (-yorigin) & 0x07;

    if (infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_PROGRAMMED_BITS) {
        if (!(infoRec->Mono8x8PatternFillFlags &
              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
            XAARotateMonoPattern(&patx, &paty, xorg, yorg,
                                 (infoRec->Mono8x8PatternFillFlags &
                                  BIT_ORDER_IN_BYTE_MSBFIRST));
            xorg = patx;
            yorg = paty;
        }
    }
    else {
        XAACacheInfoPtr pCache =
            (*infoRec->CacheMono8x8Pattern) (pScrn, pattern0, pattern1);
        patx = pCache->x;
        paty = pCache->y;
        if (!(infoRec->Mono8x8PatternFillFlags &
              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
            int slot = (yorg << 3) + xorg;

            patx += pCache->offsets[slot].x;
            paty += pCache->offsets[slot].y;
            xorg = patx;
            yorg = paty;
        }
    }

    (*infoRec->SetupForMono8x8PatternFill) (pScrn, patx, paty,
                                            fg, bg, rop, planemask);

    if (infoRec->ClipBox)
        (*infoRec->SetClippingRectangle) (infoRec->pScrn,
                                          infoRec->ClipBox->x1,
                                          infoRec->ClipBox->y1,
                                          infoRec->ClipBox->x2 - 1,
                                          infoRec->ClipBox->y2 - 1);

    while (n--) {
        (*infoRec->SubsequentMono8x8PatternFillRect) (pScrn,
                                                      xorg, yorg, ppt->x,
                                                      ppt->y, *pwidth, 1);
        ppt++;
        pwidth++;
    }

    if (infoRec->ClipBox)
        (*infoRec->DisableClipping) (infoRec->pScrn);

    SET_SYNC_FLAG(infoRec);
}

void
XAAFillMono8x8PatternSpans(ScrnInfoPtr pScrn,
                           int fg, int bg, int rop,
                           unsigned int planemask,
                           int n,
                           DDXPointPtr ppt,
                           int *pwidth, int fSorted,
                           int pattern0, int pattern1, int xorigin, int yorigin)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int patx = pattern0, paty = pattern1;
    int xorg, yorg, slot;
    XAACacheInfoPtr pCache = NULL;

    if (!(infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_PROGRAMMED_BITS)) {
        pCache = (*infoRec->CacheMono8x8Pattern) (pScrn, pattern0, pattern1);
        patx = pCache->x;
        paty = pCache->y;
    }

    (*infoRec->SetupForMono8x8PatternFill) (pScrn, patx, paty,
                                            fg, bg, rop, planemask);

    if (infoRec->ClipBox)
        (*infoRec->SetClippingRectangle) (infoRec->pScrn,
                                          infoRec->ClipBox->x1,
                                          infoRec->ClipBox->y1,
                                          infoRec->ClipBox->x2 - 1,
                                          infoRec->ClipBox->y2 - 1);

    while (n--) {
        xorg = (ppt->x - xorigin) & 0x07;
        yorg = (ppt->y - yorigin) & 0x07;

        if (!(infoRec->Mono8x8PatternFillFlags &
              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
            if (infoRec->Mono8x8PatternFillFlags &
                HARDWARE_PATTERN_PROGRAMMED_BITS) {
                patx = pattern0;
                paty = pattern1;
                XAARotateMonoPattern(&patx, &paty, xorg, yorg,
                                     (infoRec->Mono8x8PatternFillFlags &
                                      BIT_ORDER_IN_BYTE_MSBFIRST));
                xorg = patx;
                yorg = paty;
            }
            else {
                slot = (yorg << 3) + xorg;
                xorg = patx + pCache->offsets[slot].x;
                yorg = paty + pCache->offsets[slot].y;
            }
        }

        (*infoRec->SubsequentMono8x8PatternFillRect) (pScrn,
                                                      xorg, yorg, ppt->x,
                                                      ppt->y, *pwidth, 1);
        ppt++;
        pwidth++;
    }

    if (infoRec->ClipBox)
        (*infoRec->DisableClipping) (infoRec->pScrn);

    SET_SYNC_FLAG(infoRec);
}

        /****************\
	|   Color 8x8    |
	\****************/

void
XAAFillColor8x8PatternSpansScreenOrigin(ScrnInfoPtr pScrn,
                                        int rop,
                                        unsigned int planemask,
                                        int n,
                                        DDXPointPtr ppt,
                                        int *pwidth, int fSorted,
                                        XAACacheInfoPtr pCache,
                                        int xorigin, int yorigin)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int patx = pCache->x, paty = pCache->y;
    int xorg = (-xorigin) & 0x07;
    int yorg = (-yorigin) & 0x07;

    if (!(infoRec->Color8x8PatternFillFlags &
          HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
        int slot = (yorg << 3) + xorg;

        paty += pCache->offsets[slot].y;
        patx += pCache->offsets[slot].x;
        xorg = patx;
        yorg = paty;
    }

    (*infoRec->SetupForColor8x8PatternFill) (pScrn, patx, paty,
                                             rop, planemask,
                                             pCache->trans_color);

    if (infoRec->ClipBox)
        (*infoRec->SetClippingRectangle) (infoRec->pScrn,
                                          infoRec->ClipBox->x1,
                                          infoRec->ClipBox->y1,
                                          infoRec->ClipBox->x2 - 1,
                                          infoRec->ClipBox->y2 - 1);

    while (n--) {
        (*infoRec->SubsequentColor8x8PatternFillRect) (pScrn,
                                                       xorg, yorg, ppt->x,
                                                       ppt->y, *pwidth, 1);
        ppt++;
        pwidth++;
    }

    if (infoRec->ClipBox)
        (*infoRec->DisableClipping) (infoRec->pScrn);

    SET_SYNC_FLAG(infoRec);
}

void
XAAFillColor8x8PatternSpans(ScrnInfoPtr pScrn,
                            int rop,
                            unsigned int planemask,
                            int n,
                            DDXPointPtr ppt,
                            int *pwidth, int fSorted,
                            XAACacheInfoPtr pCache, int xorigin, int yorigin)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int xorg, yorg, slot;

    (*infoRec->SetupForColor8x8PatternFill) (pScrn, pCache->x, pCache->y,
                                             rop, planemask,
                                             pCache->trans_color);

    if (infoRec->ClipBox)
        (*infoRec->SetClippingRectangle) (infoRec->pScrn,
                                          infoRec->ClipBox->x1,
                                          infoRec->ClipBox->y1,
                                          infoRec->ClipBox->x2 - 1,
                                          infoRec->ClipBox->y2 - 1);

    while (n--) {
        xorg = (ppt->x - xorigin) & 0x07;
        yorg = (ppt->y - yorigin) & 0x07;

        if (!(infoRec->Color8x8PatternFillFlags &
              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
            slot = (yorg << 3) + xorg;
            yorg = pCache->y + pCache->offsets[slot].y;
            xorg = pCache->x + pCache->offsets[slot].x;
        }

        (*infoRec->SubsequentColor8x8PatternFillRect) (pScrn,
                                                       xorg, yorg, ppt->x,
                                                       ppt->y, *pwidth, 1);
        ppt++;
        pwidth++;
    }

    if (infoRec->ClipBox)
        (*infoRec->DisableClipping) (infoRec->pScrn);

    SET_SYNC_FLAG(infoRec);
}

        /*****************\
	|   Cache Blit    |
	\*****************/

void
XAAFillCacheBltSpans(ScrnInfoPtr pScrn,
                     int rop,
                     unsigned int planemask,
                     int n,
                     DDXPointPtr ppt,
                     int *pwidth,
                     int fSorted, XAACacheInfoPtr pCache, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int x, w, phaseX, phaseY, blit_w;

    (*infoRec->SetupForScreenToScreenCopy) (pScrn, 1, 1, rop, planemask,
                                            pCache->trans_color);

    if (infoRec->ClipBox)
        (*infoRec->SetClippingRectangle) (infoRec->pScrn,
                                          infoRec->ClipBox->x1,
                                          infoRec->ClipBox->y1,
                                          infoRec->ClipBox->x2 - 1,
                                          infoRec->ClipBox->y2 - 1);

    while (n--) {
        x = ppt->x;
        w = *pwidth;
        phaseX = (x - xorg) % pCache->orig_w;
        if (phaseX < 0)
            phaseX += pCache->orig_w;
        phaseY = (ppt->y - yorg) % pCache->orig_h;
        if (phaseY < 0)
            phaseY += pCache->orig_h;

        while (1) {
            blit_w = pCache->w - phaseX;
            if (blit_w > w)
                blit_w = w;

            (*infoRec->SubsequentScreenToScreenCopy) (pScrn,
                                                      pCache->x + phaseX,
                                                      pCache->y + phaseY, x,
                                                      ppt->y, blit_w, 1);

            w -= blit_w;
            if (!w)
                break;
            x += blit_w;
            phaseX = (phaseX + blit_w) % pCache->orig_w;
        }
        ppt++;
        pwidth++;
    }

    if (infoRec->ClipBox)
        (*infoRec->DisableClipping) (infoRec->pScrn);

    SET_SYNC_FLAG(infoRec);
}

        /****************\
	|  Cache Expand  |
	\****************/

void
XAAFillCacheExpandSpans(ScrnInfoPtr pScrn,
                        int fg, int bg, int rop,
                        unsigned int planemask,
                        int n,
                        DDXPointPtr ppt,
                        int *pwidth,
                        int fSorted, int xorg, int yorg, PixmapPtr pPix)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
    int x, w, phaseX, phaseY, blit_w, cacheWidth;
    XAACacheInfoPtr pCache;

    pCache = (*infoRec->CacheMonoStipple) (pScrn, pPix);

    cacheWidth = (pCache->w * pScrn->bitsPerPixel) /
        infoRec->CacheColorExpandDensity;

    (*infoRec->SetupForScreenToScreenColorExpandFill) (pScrn, fg, bg, rop,
                                                       planemask);

    if (infoRec->ClipBox)
        (*infoRec->SetClippingRectangle) (infoRec->pScrn,
                                          infoRec->ClipBox->x1,
                                          infoRec->ClipBox->y1,
                                          infoRec->ClipBox->x2 - 1,
                                          infoRec->ClipBox->y2 - 1);

    while (n--) {
        x = ppt->x;
        w = *pwidth;
        phaseX = (x - xorg) % pCache->orig_w;
        if (phaseX < 0)
            phaseX += pCache->orig_w;
        phaseY = (ppt->y - yorg) % pCache->orig_h;
        if (phaseY < 0)
            phaseY += pCache->orig_h;

        while (1) {
            blit_w = cacheWidth - phaseX;
            if (blit_w > w)
                blit_w = w;

            (*infoRec->SubsequentScreenToScreenColorExpandFill) (pScrn, x,
                                                                 ppt->y, blit_w,
                                                                 1, pCache->x,
                                                                 pCache->y +
                                                                 phaseY,
                                                                 phaseX);

            w -= blit_w;
            if (!w)
                break;
            x += blit_w;
            phaseX = (phaseX + blit_w) % pCache->orig_w;
        }
        ppt++;
        pwidth++;
    }

    if (infoRec->ClipBox)
        (*infoRec->DisableClipping) (infoRec->pScrn);

    SET_SYNC_FLAG(infoRec);
}

void
XAAClipAndRenderSpans(GCPtr pGC,
                      DDXPointPtr ppt,
                      int *pwidth,
                      int nspans,
                      int fSorted,
                      ClipAndRenderSpansFunc func, int xorg, int yorg)
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    DDXPointPtr pptNew, pptBase;
    int *pwidthBase, *pwidthNew;
    int Right, numRects, MaxBoxes;

    MaxBoxes = infoRec->PreAllocSize / (sizeof(DDXPointRec) + sizeof(int));
    pptBase = (DDXPointRec *) infoRec->PreAllocMem;
    pwidthBase = (int *) (&pptBase[MaxBoxes]);

    pptNew = pptBase;
    pwidthNew = pwidthBase;

    numRects = RegionNumRects(pGC->pCompositeClip);

    if (numRects == 1) {
        BoxPtr pextent = RegionRects(pGC->pCompositeClip);

        while (nspans--) {
            if ((pextent->y1 <= ppt->y) && (ppt->y < pextent->y2)) {
                pptNew->x = max(pextent->x1, ppt->x);
                Right = ppt->x + *pwidth;
                *pwidthNew = min(pextent->x2, Right) - pptNew->x;

                if (*pwidthNew > 0) {
                    pptNew->y = ppt->y;
                    pptNew++;
                    pwidthNew++;

                    if (pptNew >= (pptBase + MaxBoxes)) {
                        (*func) (pGC, MaxBoxes, pptBase, pwidthBase, fSorted,
                                 xorg, yorg);
                        pptNew = pptBase;
                        pwidthNew = pwidthBase;
                    }
                }
            }
            ppt++;
            pwidth++;
        }
    }
    else if (numRects) {
        BoxPtr pbox;
        int nbox;

        while (nspans--) {
            nbox = numRects;
            pbox = RegionRects(pGC->pCompositeClip);

            /* find the first band */
            while (nbox && (pbox->y2 <= ppt->y)) {
                pbox++;
                nbox--;
            }

            if (nbox && (pbox->y1 <= ppt->y)) {
                int orig_y = pbox->y1;

                Right = ppt->x + *pwidth;
                while (nbox && (orig_y == pbox->y1)) {
                    if (pbox->x2 <= ppt->x) {
                        nbox--;
                        pbox++;
                        continue;
                    }

                    if (pbox->x1 >= Right) {
                        nbox = 0;
                        break;
                    }

                    pptNew->x = max(pbox->x1, ppt->x);
                    *pwidthNew = min(pbox->x2, Right) - pptNew->x;
                    if (*pwidthNew > 0) {
                        pptNew->y = ppt->y;
                        pptNew++;
                        pwidthNew++;

                        if (pptNew >= (pptBase + MaxBoxes)) {
                            (*func) (pGC, MaxBoxes, pptBase, pwidthBase,
                                     fSorted, xorg, yorg);
                            pptNew = pptBase;
                            pwidthNew = pwidthBase;
                        }
                    }
                    pbox++;
                    nbox--;
                }
            }
            ppt++;
            pwidth++;
        }
    }

    if (pptNew != pptBase)
        (*func) (pGC, pptNew - pptBase, pptBase, pwidthBase, fSorted,
                 xorg, yorg);
}
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d19 13
a31 15

static void XAARenderSolidSpans(
	GCPtr, int, DDXPointPtr, int*, int, int, int);
static void XAARenderColor8x8Spans(
	GCPtr, int, DDXPointPtr, int*, int, int, int);
static void XAARenderMono8x8Spans(
	GCPtr, int, DDXPointPtr, int*, int, int, int);
static void XAARenderCacheBltSpans(
	GCPtr, int, DDXPointPtr, int*, int, int, int);
static void XAARenderColorExpandSpans(
	GCPtr, int, DDXPointPtr, int*, int, int, int);
static void XAARenderCacheExpandSpans(
	GCPtr, int, DDXPointPtr, int*, int, int, int);
static void XAARenderPixmapCopySpans(
	GCPtr, int, DDXPointPtr, int*, int, int, int);
d34 5
a38 8
XAAFillSpans(
    DrawablePtr pDraw,
    GC		*pGC,
    int		nInit,		/* number of spans to fill */
    DDXPointPtr pptInit,	/* pointer to list of start points */
    int *pwidthInit,		/* pointer to list of n widths */
    int fSorted 
){
d44 1
a44 1
    if((nInit <= 0) || !pGC->planemask)
d47 2
a48 2
    if(!RegionNumRects(pGC->pCompositeClip))
	return;
d50 1
a50 1
    switch(pGC->fillStyle) {
d52 2
a53 2
	type = DO_SOLID;
	break;
d55 2
a56 2
	type = (*infoRec->StippledFillChooser)(pGC);
	break;
d58 9
a66 9
	if((pGC->fgPixel == pGC->bgPixel) && infoRec->FillSpansSolid &&
                CHECK_PLANEMASK(pGC,infoRec->FillSpansSolidFlags) &&
                CHECK_ROP(pGC,infoRec->FillSpansSolidFlags) &&
                CHECK_ROPSRC(pGC,infoRec->FillSpansSolidFlags) &&
                CHECK_FG(pGC,infoRec->FillSpansSolidFlags))
	    type = DO_SOLID;
	else
	    type = (*infoRec->OpaqueStippledFillChooser)(pGC);
	break;
d68 2
a69 2
	type = (*infoRec->TiledFillChooser)(pGC);
	break;
d72 1
a72 1
    switch(type) {
d74 4
a77 4
	function = XAARenderSolidSpans;	
	if(infoRec->ClippingFlags & HARDWARE_CLIP_SOLID_FILL) 
		fastClip = TRUE; 
	break;	
d79 4
a82 4
	function = XAARenderColor8x8Spans;	
	if(infoRec->ClippingFlags & HARDWARE_CLIP_COLOR_8x8_FILL) 
		fastClip = TRUE; 
	break;	
d84 4
a87 4
	function = XAARenderMono8x8Spans;	
	if(infoRec->ClippingFlags & HARDWARE_CLIP_MONO_8x8_FILL) 
		fastClip = TRUE; 
	break;	
d89 4
a92 4
	function = XAARenderCacheBltSpans;	
	if(infoRec->ClippingFlags & HARDWARE_CLIP_SCREEN_TO_SCREEN_COPY)
		fastClip = TRUE; 
	break;	
d94 2
a95 2
	function = XAARenderColorExpandSpans;	
	break;	
d97 5
a101 5
	function = XAARenderCacheExpandSpans;	
	if(infoRec->ClippingFlags & 
			HARDWARE_CLIP_SCREEN_TO_SCREEN_COLOR_EXPAND) 
		fastClip = TRUE; 
	break;	
d103 4
a106 4
	function = XAARenderPixmapCopySpans;	
	if(infoRec->ClippingFlags & HARDWARE_CLIP_SCREEN_TO_SCREEN_COPY)
		fastClip = TRUE; 
	break;	
d109 3
a111 3
	(*XAAFallbackOps.FillSpans)(pDraw, pGC, nInit, pptInit,
				pwidthInit, fSorted);
	return;
d114 2
d117 9
a125 11
    if((nInit < 10) || (RegionNumRects(pGC->pCompositeClip) != 1))
	fastClip = FALSE;

    if(fastClip) {
	infoRec->ClipBox = &pGC->pCompositeClip->extents;
	(*function)(pGC, nInit, pptInit, pwidthInit, fSorted, 
					pDraw->x, pDraw->y);
	infoRec->ClipBox = NULL;
    } else
	XAAClipAndRenderSpans(pGC, pptInit, pwidthInit, nInit, fSorted,
					function, pDraw->x, pDraw->y);
d128 1
a128 2

	/*********************\
a131 1

d133 5
a137 8
XAARenderSolidSpans(
    GCPtr pGC,
    int	n,
    DDXPointPtr ppt,
    int *pwidth,
    int fSorted,
    int xorg, int yorg 
){
d140 3
a142 2
    (*infoRec->FillSolidSpans) (infoRec->pScrn, pGC->fgPixel, 
		pGC->alu, pGC->planemask, n, ppt, pwidth, fSorted);    
d145 1
a145 2

	/************************\
d149 9
d159 29
a187 36
static void
XAARenderMono8x8Spans(
    GCPtr pGC,
    int	n,
    DDXPointPtr ppt,
    int *pwidth,
    int fSorted,
    int xorg, int yorg 
){
   XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
   XAAPixmapPtr pPriv;
   int fg, bg;

   switch(pGC->fillStyle) {
   case FillStippled:
      pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
      fg = pGC->fgPixel;  bg = -1;
      break;
   case FillOpaqueStippled:
      pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
      fg = pGC->fgPixel;  bg = pGC->bgPixel;
      break;
   case FillTiled:
      pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
      fg = pPriv->fg;  bg = pPriv->bg;
      break;
   default:	/* Muffle compiler */
      pPriv = NULL;	/* Kaboom */
      fg = -1;  bg = -1;
      break;
   }

   (*infoRec->FillMono8x8PatternSpans) (infoRec->pScrn, 
                fg, bg, pGC->alu, pGC->planemask, 
                n, ppt, pwidth, fSorted, pPriv->pattern0, pPriv->pattern1, 
                (xorg + pGC->patOrg.x), (yorg + pGC->patOrg.y));	  
d190 1
a190 2

	/*************************\
d194 10
d205 30
a234 38
static void
XAARenderColor8x8Spans(
    GCPtr pGC,
    int	n,
    DDXPointPtr ppt,
    int *pwidth,
    int fSorted,
    int xorg, int yorg 
){
   XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
   XAACacheInfoPtr pCache;
   PixmapPtr pPix;
   int fg, bg;

   switch(pGC->fillStyle) {
   case FillStippled:
      pPix = pGC->stipple;
      fg = pGC->fgPixel;  bg = -1;
      break;
   case FillOpaqueStippled:
      pPix = pGC->stipple;
      fg = pGC->fgPixel;  bg = pGC->bgPixel;
      break;
   case FillTiled:
      pPix = pGC->tile.pixmap;
      fg = -1;  bg = -1;
      break;
   default:	/* Muffle compiler */
      pPix = NULL;
      fg = -1;  bg = -1;
      break;
   }

   pCache = (*infoRec->CacheColor8x8Pattern)(infoRec->pScrn, pPix, fg, bg);

   (*infoRec->FillColor8x8PatternSpans) (infoRec->pScrn, 
                pGC->alu, pGC->planemask, n, ppt, pwidth, fSorted, pCache,
                (yorg + pGC->patOrg.x), (xorg + pGC->patOrg.y));
d237 1
a237 2

	/****************************\
d241 23
d265 4
a268 28
static void
XAARenderColorExpandSpans(
    GCPtr pGC,
    int	n,
    DDXPointPtr ppt,
    int *pwidth,
    int fSorted,
    int xorg, int yorg 
){
   XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
   int fg, bg;

   switch(pGC->fillStyle) {
   case FillStippled:
      fg = pGC->fgPixel;  bg = -1;
      break;
   case FillOpaqueStippled:
      fg = pGC->fgPixel;  bg = pGC->bgPixel;
      break;
   default:	/* Muffle compiler */
      fg = -1;  bg = -1;
      break;
   }

   (*infoRec->FillColorExpandSpans) (infoRec->pScrn, fg, bg,
                pGC->alu, pGC->planemask, n, ppt, pwidth, fSorted,
                (xorg + pGC->patOrg.x), (yorg + pGC->patOrg.y),
                pGC->stipple); 
d272 1
a272 2

	/*************************\
d276 8
d285 21
a305 32
static void
XAARenderCacheBltSpans(
    GCPtr pGC,
    int	n,
    DDXPointPtr ppt,
    int *pwidth,
    int fSorted,
    int xorg, int yorg 
){
   XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
   XAACacheInfoPtr pCache;

   switch(pGC->fillStyle) {
   case FillStippled:
      pCache = (*infoRec->CacheStipple)(infoRec->pScrn, pGC->stipple, 
					pGC->fgPixel, -1);
      break;
   case FillOpaqueStippled:
      pCache = (*infoRec->CacheStipple)(infoRec->pScrn, pGC->stipple, 
					pGC->fgPixel, pGC->bgPixel);
      break;
   case FillTiled:
      pCache = (*infoRec->CacheTile)(infoRec->pScrn, pGC->tile.pixmap);
      break;
   default:	/* Muffle compiler */
      pCache = NULL;
      break;
   }

   (*infoRec->FillCacheBltSpans) (infoRec->pScrn, 
                pGC->alu, pGC->planemask, n, ppt, pwidth, fSorted, pCache, 
                (xorg + pGC->patOrg.x), (yorg + pGC->patOrg.y));
d309 1
a309 2

	/****************************\
d313 8
d322 19
a340 28
static void
XAARenderCacheExpandSpans(
    GCPtr pGC,
    int	n,
    DDXPointPtr ppt,
    int *pwidth,
    int fSorted,
    int xorg, int yorg 
){
   XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
   int fg, bg;

   switch(pGC->fillStyle) {
   case FillStippled:
      fg = pGC->fgPixel;  bg = -1;
      break;
   case FillOpaqueStippled:
      fg = pGC->fgPixel;  bg = pGC->bgPixel;
      break;
   default:	/* Muffle compiler */
      fg = -1;  bg = -1;
      break;
   }

   (*infoRec->FillCacheExpandSpans) (infoRec->pScrn, fg, bg,
                pGC->alu, pGC->planemask, n, ppt, pwidth, fSorted,
                (xorg + pGC->patOrg.x), (yorg + pGC->patOrg.y),
                pGC->stipple); 
d343 1
a343 2

	/***************************\
a346 1

d348 8
a355 11
XAARenderPixmapCopySpans(
    GCPtr pGC,
    int	n,
    DDXPointPtr ppt,
    int *pwidth,
    int fSorted,
    int xorg, int yorg 
){
   XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
   XAACacheInfoPtr pCache = &(infoRec->ScratchCacheInfoRec);
   XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
d357 10
a366 11
   pCache->x = pPriv->offscreenArea->box.x1;
   pCache->y = pPriv->offscreenArea->box.y1;
   pCache->w = pCache->orig_w = 
		pPriv->offscreenArea->box.x2 - pCache->x;
   pCache->h = pCache->orig_h = 
		pPriv->offscreenArea->box.y2 - pCache->y;
   pCache->trans_color = -1;

   (*infoRec->FillCacheBltSpans) (infoRec->pScrn, 
                pGC->alu, pGC->planemask, n, ppt, pwidth, fSorted, pCache, 
                (xorg + pGC->patOrg.x), (yorg + pGC->patOrg.y));
d369 1
a369 5




	/****************\
a372 1

d374 5
a378 8
XAAFillSolidSpans(
   ScrnInfoPtr pScrn,
   int fg, int rop,
   unsigned int planemask,
   int n,
   DDXPointPtr ppt,
   int *pwidth, int fSorted 
){
d381 1
a381 1
    (*infoRec->SetupForSolidFill)(pScrn, fg, rop, planemask);
d383 13
a395 10
    if(infoRec->ClipBox)
	(*infoRec->SetClippingRectangle)(infoRec->pScrn,
		infoRec->ClipBox->x1, infoRec->ClipBox->y1, 
		infoRec->ClipBox->x2 - 1, infoRec->ClipBox->y2 - 1);

    while(n--) {
	if (*pwidth > 0)
            (*infoRec->SubsequentSolidFillRect)(pScrn, ppt->x, ppt->y, 
								*pwidth, 1);
	ppt++; pwidth++;
d398 2
a399 2
    if(infoRec->ClipBox)
	(*infoRec->DisableClipping)(infoRec->pScrn);
d404 1
a404 1
	/***************\
a407 1

d409 9
a417 10
XAAFillMono8x8PatternSpansScreenOrigin(
   ScrnInfoPtr pScrn,
   int fg, int bg, int rop,
   unsigned int planemask,
   int n,
   DDXPointPtr ppt,
   int *pwidth, int fSorted,
   int pattern0, int pattern1,
   int xorigin, int yorigin 
){
d423 28
d452 14
a465 34
    if(infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_PROGRAMMED_BITS) {
   	if(!(infoRec->Mono8x8PatternFillFlags & 		
				HARDWARE_PATTERN_PROGRAMMED_ORIGIN)){
	    XAARotateMonoPattern(&patx, &paty, xorg, yorg,
				(infoRec->Mono8x8PatternFillFlags & 		
				BIT_ORDER_IN_BYTE_MSBFIRST));
	    xorg = patx; yorg = paty;
        }
    } else {
	XAACacheInfoPtr pCache =
		(*infoRec->CacheMono8x8Pattern)(pScrn, pattern0, pattern1);
	patx = pCache->x;  paty = pCache->y;
   	if(!(infoRec->Mono8x8PatternFillFlags & 
				HARDWARE_PATTERN_PROGRAMMED_ORIGIN)){
	    int slot = (yorg << 3) + xorg;
	    patx += pCache->offsets[slot].x;
	    paty += pCache->offsets[slot].y;
	    xorg = patx;  yorg = paty;
	}	
    }

    (*infoRec->SetupForMono8x8PatternFill)(pScrn, patx, paty,
	fg, bg, rop, planemask);

    if(infoRec->ClipBox)
	(*infoRec->SetClippingRectangle)(infoRec->pScrn,
		infoRec->ClipBox->x1, infoRec->ClipBox->y1, 
		infoRec->ClipBox->x2 - 1, infoRec->ClipBox->y2 - 1);

     while(n--) {
        (*infoRec->SubsequentMono8x8PatternFillRect)(pScrn, 
			xorg, yorg, ppt->x, ppt->y, *pwidth, 1);
	ppt++; pwidth++;
     }
d467 2
a468 2
     if(infoRec->ClipBox)
	(*infoRec->DisableClipping)(infoRec->pScrn);
d470 1
a470 1
     SET_SYNC_FLAG(infoRec);
a472 1

d474 8
a481 10
XAAFillMono8x8PatternSpans(
   ScrnInfoPtr pScrn,
   int fg, int bg, int rop,
   unsigned int planemask,
   int n,
   DDXPointPtr ppt,
   int *pwidth, int fSorted,
   int pattern0, int pattern1,
   int xorigin, int yorigin 
){
d487 8
d496 28
a523 31
    if(!(infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_PROGRAMMED_BITS)){
	pCache = (*infoRec->CacheMono8x8Pattern)(pScrn, pattern0, pattern1);
	patx = pCache->x;  paty = pCache->y;
    }

    (*infoRec->SetupForMono8x8PatternFill)(pScrn, patx, paty,
					fg, bg, rop, planemask);

    if(infoRec->ClipBox)
	(*infoRec->SetClippingRectangle)(infoRec->pScrn,
		infoRec->ClipBox->x1, infoRec->ClipBox->y1, 
		infoRec->ClipBox->x2 - 1, infoRec->ClipBox->y2 - 1);

     while(n--) {
	xorg = (ppt->x - xorigin) & 0x07;
	yorg = (ppt->y - yorigin) & 0x07;

   	if(!(infoRec->Mono8x8PatternFillFlags & 		
				HARDWARE_PATTERN_PROGRAMMED_ORIGIN)){
	    if(infoRec->Mono8x8PatternFillFlags & 
				HARDWARE_PATTERN_PROGRAMMED_BITS) {
		patx = pattern0; paty = pattern1;
		XAARotateMonoPattern(&patx, &paty, xorg, yorg,
				(infoRec->Mono8x8PatternFillFlags & 		
				BIT_ORDER_IN_BYTE_MSBFIRST));
		xorg = patx; yorg = paty;
	    } else {
		slot = (yorg << 3) + xorg;
	    	xorg = patx + pCache->offsets[slot].x;
	    	yorg = paty + pCache->offsets[slot].y;
	    }
d526 6
a531 4
        (*infoRec->SubsequentMono8x8PatternFillRect)(pScrn, 
			xorg, yorg, ppt->x, ppt->y, *pwidth, 1);
	ppt++; pwidth++;
     }
d533 2
a534 2
     if(infoRec->ClipBox)
	(*infoRec->DisableClipping)(infoRec->pScrn);
d536 1
a536 1
     SET_SYNC_FLAG(infoRec);
d539 1
a539 3


	/****************\
a542 1

d544 9
a552 10
XAAFillColor8x8PatternSpansScreenOrigin(
   ScrnInfoPtr pScrn,
   int rop,
   unsigned int planemask,
   int n,
   DDXPointPtr ppt,
   int *pwidth, int fSorted,
   XAACacheInfoPtr pCache,
   int xorigin, int yorigin 
){
d558 28
d587 2
a588 24
    if(!(infoRec->Color8x8PatternFillFlags & 
					HARDWARE_PATTERN_PROGRAMMED_ORIGIN)){
	int slot = (yorg << 3) + xorg;
	paty += pCache->offsets[slot].y;
	patx += pCache->offsets[slot].x;
	xorg = patx;  yorg = paty;
    }	

    (*infoRec->SetupForColor8x8PatternFill)(pScrn, patx, paty,
			 rop, planemask, pCache->trans_color);

    if(infoRec->ClipBox)
	(*infoRec->SetClippingRectangle)(infoRec->pScrn,
		infoRec->ClipBox->x1, infoRec->ClipBox->y1, 
		infoRec->ClipBox->x2 - 1, infoRec->ClipBox->y2 - 1);

     while(n--) {
        (*infoRec->SubsequentColor8x8PatternFillRect)(pScrn, 
			xorg, yorg, ppt->x, ppt->y, *pwidth, 1);
	ppt++; pwidth++;
     }
 
    if(infoRec->ClipBox)
	(*infoRec->DisableClipping)(infoRec->pScrn);
d590 1
a590 1
     SET_SYNC_FLAG(infoRec);
a592 1

d594 8
a601 10
XAAFillColor8x8PatternSpans(
   ScrnInfoPtr pScrn,
   int rop,
   unsigned int planemask,
   int n,
   DDXPointPtr ppt,
   int *pwidth, int fSorted,
   XAACacheInfoPtr pCache,
   int xorigin, int yorigin 
){
d605 20
a624 17
    (*infoRec->SetupForColor8x8PatternFill)(pScrn, pCache->x, pCache->y,
			 rop, planemask, pCache->trans_color);

    if(infoRec->ClipBox)
	(*infoRec->SetClippingRectangle)(infoRec->pScrn,
		infoRec->ClipBox->x1, infoRec->ClipBox->y1, 
		infoRec->ClipBox->x2 - 1, infoRec->ClipBox->y2 - 1);

     while(n--) {
	xorg = (ppt->x - xorigin) & 0x07;
	yorg = (ppt->y - yorigin) & 0x07;

   	if(!(infoRec->Color8x8PatternFillFlags & 		
				HARDWARE_PATTERN_PROGRAMMED_ORIGIN)){
	    slot = (yorg << 3) + xorg;
	    yorg = pCache->y + pCache->offsets[slot].y;
	    xorg = pCache->x + pCache->offsets[slot].x;
d627 6
a632 4
        (*infoRec->SubsequentColor8x8PatternFillRect)(pScrn, 
			xorg, yorg, ppt->x, ppt->y, *pwidth, 1);
	ppt++; pwidth++;
     }
d634 2
a635 2
     if(infoRec->ClipBox)
	(*infoRec->DisableClipping)(infoRec->pScrn);
d637 1
a637 1
     SET_SYNC_FLAG(infoRec);
d640 1
a640 1
	/*****************\
a643 1

d645 8
a652 11
XAAFillCacheBltSpans(
   ScrnInfoPtr pScrn,
   int rop,
   unsigned int planemask,
   int n,
   DDXPointPtr ppt,
   int *pwidth,
   int fSorted,
   XAACacheInfoPtr pCache,
   int xorg, int yorg
){
d654 1
a654 1
    int x, w, phaseX, phaseY, blit_w;  
d656 2
a657 2
    (*infoRec->SetupForScreenToScreenCopy)(pScrn, 1, 1, rop, planemask,
		pCache->trans_color);
d659 36
a694 4
    if(infoRec->ClipBox)
	(*infoRec->SetClippingRectangle)(infoRec->pScrn,
		infoRec->ClipBox->x1, infoRec->ClipBox->y1, 
		infoRec->ClipBox->x2 - 1, infoRec->ClipBox->y2 - 1);
d696 2
a697 7
     while(n--) {
	x = ppt->x;
	w = *pwidth; 
	phaseX = (x - xorg) % pCache->orig_w;
	if(phaseX < 0) phaseX += pCache->orig_w;
	phaseY = (ppt->y - yorg) % pCache->orig_h;
	if(phaseY < 0) phaseY += pCache->orig_h;
d699 1
a699 20
	while(1) {
	    blit_w = pCache->w - phaseX;
	    if(blit_w > w) blit_w = w;

            (*infoRec->SubsequentScreenToScreenCopy)(pScrn, 
		pCache->x + phaseX, pCache->y + phaseY,
		x, ppt->y, blit_w, 1);

	    w -= blit_w;
	    if(!w) break;
	    x += blit_w;
	    phaseX = (phaseX + blit_w) % pCache->orig_w;
	}
	ppt++; pwidth++;
     }

     if(infoRec->ClipBox)
	(*infoRec->DisableClipping)(infoRec->pScrn);

     SET_SYNC_FLAG(infoRec);
d702 1
a702 2

	/****************\
a705 1

d707 8
a714 11
XAAFillCacheExpandSpans(
   ScrnInfoPtr pScrn,
   int fg, int bg, int rop,
   unsigned int planemask,
   int n,
   DDXPointPtr ppt,
   int *pwidth,
   int fSorted,
   int xorg, int yorg,
   PixmapPtr pPix
){
d716 1
a716 1
    int x, w, phaseX, phaseY, blit_w, cacheWidth;  
d719 1
a719 1
    pCache = (*infoRec->CacheMonoStipple)(pScrn, pPix);
d721 2
a722 2
    cacheWidth = (pCache->w * pScrn->bitsPerPixel) / 
	infoRec->CacheColorExpandDensity;
d724 2
a725 2
    (*infoRec->SetupForScreenToScreenColorExpandFill)(pScrn, fg, bg, rop, 
							planemask);
d727 38
a764 28
    if(infoRec->ClipBox)
	(*infoRec->SetClippingRectangle)(infoRec->pScrn,
		infoRec->ClipBox->x1, infoRec->ClipBox->y1, 
		infoRec->ClipBox->x2 - 1, infoRec->ClipBox->y2 - 1);

     while(n--) {
	x = ppt->x;
	w = *pwidth; 
	phaseX = (x - xorg) % pCache->orig_w;
	if(phaseX < 0) phaseX += pCache->orig_w;
	phaseY = (ppt->y - yorg) % pCache->orig_h;
	if(phaseY < 0) phaseY += pCache->orig_h;

	while(1) {
	    blit_w = cacheWidth - phaseX;
	    if(blit_w > w) blit_w = w;

	    (*infoRec->SubsequentScreenToScreenColorExpandFill)(
			pScrn, x, ppt->y, blit_w, 1,
			pCache->x, pCache->y + phaseY, phaseX);

	    w -= blit_w;
	    if(!w) break;
	    x += blit_w;
	    phaseX = (phaseX + blit_w) % pCache->orig_w;
	}
	ppt++; pwidth++;
     }
d766 2
a767 2
     if(infoRec->ClipBox)
	(*infoRec->DisableClipping)(infoRec->pScrn);
d769 1
a769 1
     SET_SYNC_FLAG(infoRec);
a771 2


d773 7
a779 10
XAAClipAndRenderSpans(
    GCPtr pGC, 
    DDXPointPtr	ppt,
    int		*pwidth,
    int		nspans,
    int		fSorted,
    ClipAndRenderSpansFunc func,
    int 	xorg,
    int		yorg
){
d782 2
a783 2
    int	*pwidthBase, *pwidthNew;
    int	Right, numRects, MaxBoxes;
d785 3
a787 3
    MaxBoxes = infoRec->PreAllocSize/(sizeof(DDXPointRec) + sizeof(int));
    pptBase = (DDXPointRec*)infoRec->PreAllocMem;
    pwidthBase = (int*)(&pptBase[MaxBoxes]);
d794 1
a794 1
    if(numRects == 1) {
d796 80
a875 78
	    
	while(nspans--) {
	    if ((pextent->y1 <= ppt->y) && (ppt->y < pextent->y2)) {
		pptNew->x = max(pextent->x1, ppt->x);
		Right = ppt->x + *pwidth; 
		*pwidthNew = min(pextent->x2, Right) - pptNew->x;

		if (*pwidthNew > 0) {
		    pptNew->y = ppt->y;
		    pptNew++;
		    pwidthNew++;

		    if(pptNew >= (pptBase + MaxBoxes)) {
			(*func)(pGC, MaxBoxes, pptBase, pwidthBase, fSorted, 	
								xorg, yorg);
			pptNew = pptBase;
			pwidthNew = pwidthBase;
		    }
		}
	    }
	    ppt++;
	    pwidth++;
	}
    } else if (numRects) {
	BoxPtr	pbox;
	int nbox;

	while(nspans--) {
	    nbox = numRects;
	    pbox = RegionRects(pGC->pCompositeClip);

	    /* find the first band */
	    while(nbox && (pbox->y2 <= ppt->y)) {
		pbox++;
		nbox--;
	    }

	    if(nbox && (pbox->y1 <= ppt->y)) {
		int orig_y = pbox->y1;
		Right = ppt->x + *pwidth;
		while(nbox && (orig_y == pbox->y1)) {
		    if(pbox->x2 <= ppt->x) {
			nbox--;
			pbox++;
			continue;
		    }

		    if(pbox->x1 >= Right) {
			nbox = 0;
			break;
		    }

		    pptNew->x = max(pbox->x1, ppt->x);
		    *pwidthNew = min(pbox->x2, Right) - pptNew->x;
		    if(*pwidthNew > 0) {
			pptNew->y = ppt->y;
			pptNew++;
			pwidthNew++;

			if(pptNew >= (pptBase + MaxBoxes)) {
			    (*func)(pGC, MaxBoxes, pptBase, pwidthBase, 
							fSorted, xorg, yorg);
			    pptNew = pptBase;
			    pwidthNew = pwidthBase;
			}
		    }
		    pbox++;
		    nbox--;
		}
	    }
	    ppt++;
	    pwidth++;
	}
    }

    if(pptNew != pptBase)
	(*func)(pGC, pptNew - pptBase, pptBase, pwidthBase, fSorted, 
						xorg, yorg);
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d52 1
a52 1
    if(!REGION_NUM_RECTS(pGC->pCompositeClip))
d120 1
a120 1
    if((nInit < 10) || (REGION_NUM_RECTS(pGC->pCompositeClip) != 1))
d800 1
a800 1
    numRects = REGION_NUM_RECTS(pGC->pCompositeClip);
d803 1
a803 1
        BoxPtr pextent = REGION_RECTS(pGC->pCompositeClip);
d833 1
a833 1
	    pbox = REGION_RECTS(pGC->pCompositeClip);
@


1.1
log
@Initial revision
@
text
@d399 1
a399 1
void 
d435 1
a435 1
void 
d494 1
a494 1
void 
d562 1
a562 1
void 
d608 1
a608 1
void 
d657 1
a657 1
void 
d716 1
a716 1
void 
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
