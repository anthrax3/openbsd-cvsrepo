head	1.5;
access;
symbols
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.10
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.06.07.17.28.53;	author matthieu;	state dead;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.41;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.41;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.58.29;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <stdlib.h>

#include <X11/X.h>
#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"

#include "scrnintstr.h"
#include "pixmapstr.h"
#include "miline.h"
#include "xf86str.h"
#include "xaa.h"
#include "xaalocal.h"

void
#ifdef POLYSEGMENT
 XAAPolySegmentDashed(DrawablePtr pDrawable,
                      GCPtr pGC, int nseg, xSegment * pSeg
#else
XAAPolyLinesDashed(DrawablePtr pDrawable, GCPtr pGC, int mode,  /* Origin or Previous */
                   int npt,     /* number of points */
                   DDXPointPtr pptInit
#endif
    )
{
    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
    XAAGCPtr pGCPriv = (XAAGCPtr) dixLookupPrivate(&pGC->devPrivates,
                                                   XAAGetGCKey());
    BoxPtr pboxInit = RegionRects(pGC->pCompositeClip);
    int nboxInit = RegionNumRects(pGC->pCompositeClip);
    unsigned int bias = miGetZeroLineBias(pDrawable->pScreen);
    int xorg = pDrawable->x;
    int yorg = pDrawable->y;
    int nbox;
    BoxPtr pbox;

#ifndef POLYSEGMENT
    DDXPointPtr ppt;
#endif
    unsigned int oc1, oc2;
    int dmin, dmaj, e, octant;
    int x1, x2, y1, y2, tmp, len, offset;
    int PatternLength, PatternOffset;

    if (!nboxInit)
        return;

    if (infoRec->DashedLineFlags & LINE_LIMIT_COORDS) {
        int minValX = infoRec->DashedLineLimits.x1;
        int maxValX = infoRec->DashedLineLimits.x2;
        int minValY = infoRec->DashedLineLimits.y1;
        int maxValY = infoRec->DashedLineLimits.y2;

#ifdef POLYSEGMENT
        int n = nseg;
        xSegment *s = pSeg;

        while (n--)
#else
        int n = npt;
        int xorgtmp = xorg;
        int yorgtmp = yorg;

        ppt = pptInit;
        x2 = ppt->x + xorgtmp;
        y2 = ppt->y + yorgtmp;
        while (--n)
#endif
        {
#ifdef POLYSEGMENT
            x1 = s->x1 + xorg;
            y1 = s->y1 + yorg;
            x2 = s->x2 + xorg;
            y2 = s->y2 + yorg;
            s++;
#else
            x1 = x2;
            y1 = y2;
            ++ppt;
            if (mode == CoordModePrevious) {
                xorgtmp = x1;
                yorgtmp = y1;
            }
            x2 = ppt->x + xorgtmp;
            y2 = ppt->y + yorgtmp;
#endif
            if (x1 > maxValX || x1 < minValX ||
                x2 > maxValX || x2 < minValX ||
                y1 > maxValY || y1 < minValY || y2 > maxValY || y2 < minValY) {
#ifdef POLYSEGMENT
                XAAFallbackOps.PolySegment(pDrawable, pGC, nseg, pSeg);
#else
                XAAFallbackOps.Polylines(pDrawable, pGC, mode, npt, pptInit);
#endif
                return;
            }
        }
    }

    PatternLength = pGCPriv->DashLength;
    PatternOffset = pGC->dashOffset % PatternLength;

    (*infoRec->SetupForDashedLine) (infoRec->pScrn, pGC->fgPixel,
                                    (pGC->lineStyle ==
                                     LineDoubleDash) ? pGC->bgPixel : -1,
                                    pGC->alu, pGC->planemask, PatternLength,
                                    pGCPriv->DashPattern);

#ifdef POLYSEGMENT
    while (nseg--)
#else
    ppt = pptInit;
    x2 = ppt->x + xorg;
    y2 = ppt->y + yorg;
    while (--npt)
#endif
    {
        nbox = nboxInit;
        pbox = pboxInit;

#ifdef POLYSEGMENT
        x1 = pSeg->x1 + xorg;
        y1 = pSeg->y1 + yorg;
        x2 = pSeg->x2 + xorg;
        y2 = pSeg->y2 + yorg;
        pSeg++;
#else
        x1 = x2;
        y1 = y2;
        ++ppt;
        if (mode == CoordModePrevious) {
            xorg = x1;
            yorg = y1;
        }
        x2 = ppt->x + xorg;
        y2 = ppt->y + yorg;
#endif

        if (infoRec->SubsequentDashedBresenhamLine) {
            if ((dmaj = x2 - x1) < 0) {
                dmaj = -dmaj;
                octant = XDECREASING;
            }
            else
                octant = 0;

            if ((dmin = y2 - y1) < 0) {
                dmin = -dmin;
                octant |= YDECREASING;
            }

            if (dmin >= dmaj) {
                tmp = dmin;
                dmin = dmaj;
                dmaj = tmp;
                octant |= YMAJOR;
            }

            e = -dmaj - ((bias >> octant) & 1);
            len = dmaj;
            dmin <<= 1;
            dmaj <<= 1;
        }
        else {                  /* Muffle compiler */
            dmin = dmaj = e = octant = len = 0;
        }

        while (nbox--) {
            oc1 = oc2 = 0;
            OUTCODES(oc1, x1, y1, pbox);
            OUTCODES(oc2, x2, y2, pbox);
            if (!(oc1 | oc2)) { /* uncliped */
                if (infoRec->SubsequentDashedTwoPointLine) {
                    (*infoRec->SubsequentDashedTwoPointLine) (infoRec->pScrn,
                                                              x1, y1, x2, y2,
#ifdef POLYSEGMENT
                                                              (pGC->capStyle !=
                                                               CapNotLast) ? 0 :
#endif
                                                              OMIT_LAST,
                                                              PatternOffset);
                }
                else {
                    (*infoRec->SubsequentDashedBresenhamLine) (infoRec->pScrn,
                                                               x1, y1, dmaj,
                                                               dmin, e,
#ifdef POLYSEGMENT
                                                               (pGC->capStyle !=
                                                                CapNotLast)
                                                               ? (len + 1) :
#endif
                                                               len, octant,
                                                               PatternOffset);
                }
                break;
            }
            else if (oc1 & oc2) {       /* completely clipped */
                pbox++;
            }
            else if (infoRec->ClippingFlags & HARDWARE_CLIP_DASHED_LINE) {
                (*infoRec->SetClippingRectangle) (infoRec->pScrn,
                                                  pbox->x1, pbox->y1,
                                                  pbox->x2 - 1, pbox->y2 - 1);

                if (infoRec->SubsequentDashedBresenhamLine) {
                    (*infoRec->SubsequentDashedBresenhamLine) (infoRec->pScrn,
                                                               x1, y1, dmaj,
                                                               dmin, e,
#ifdef POLYSEGMENT
                                                               (pGC->capStyle !=
                                                                CapNotLast)
                                                               ? (len + 1) :
#endif
                                                               len, octant,
                                                               PatternOffset);
                }
                else {
                    (*infoRec->SubsequentDashedTwoPointLine) (infoRec->pScrn,
                                                              x1, y1, x2, y2,
#ifdef POLYSEGMENT
                                                              (pGC->capStyle !=
                                                               CapNotLast) ? 0 :
#endif
                                                              OMIT_LAST,
                                                              PatternOffset);
                }
                (*infoRec->DisableClipping) (infoRec->pScrn);
                pbox++;
            }
            else {
                int new_x1 = x1, new_y1 = y1, new_x2 = x2, new_y2 = y2;
                int clip1 = 0, clip2 = 0;
                int err, adx, ady;

                if (octant & YMAJOR) {
                    ady = dmaj >> 1;
                    adx = dmin >> 1;
                }
                else {
                    ady = dmin >> 1;
                    adx = dmaj >> 1;
                }

                if (miZeroClipLine(pbox->x1, pbox->y1,
                                   pbox->x2 - 1, pbox->y2 - 1,
                                   &new_x1, &new_y1, &new_x2, &new_y2,
                                   adx, ady, &clip1, &clip2,
                                   octant, bias, oc1, oc2) == -1) {
                    pbox++;
                    continue;
                }

                if (octant & YMAJOR)
                    len = abs(new_y2 - new_y1);
                else
                    len = abs(new_x2 - new_x1);
#ifdef POLYSEGMENT
                if (clip2 != 0 || pGC->capStyle != CapNotLast)
                    len++;
#else
                len += (clip2 != 0);
#endif
                if (len) {
                    int abserr, clipdx, clipdy;

                    /* unwind bresenham error term to first point */
                    if (clip1) {
                        clipdx = abs(new_x1 - x1);
                        clipdy = abs(new_y1 - y1);

                        if (octant & YMAJOR)
                            err = e + clipdy * dmin - clipdx * dmaj;
                        else
                            err = e + clipdx * dmin - clipdy * dmaj;
                    }
                    else
                        err = e;

#define range infoRec->DashedBresenhamLineErrorTermBits
                    abserr = abs(err);
                    while ((abserr & range) || (dmaj & range) || (dmin & range)) {
                        dmin >>= 1;
                        dmaj >>= 1;
                        abserr >>= 1;
                        err /= 2;
                    }

                    if (octant & YMAJOR)
                        offset = abs(new_y1 - y1);
                    else
                        offset = abs(new_x1 - x1);

                    offset += PatternOffset;
                    offset %= PatternLength;

                    (*infoRec->SubsequentDashedBresenhamLine) (infoRec->pScrn,
                                                               new_x1, new_y1,
                                                               dmaj, dmin, err,
                                                               len, octant,
                                                               offset);
                }
                pbox++;
            }
        }                       /* while (nbox--) */
#ifndef POLYSEGMENT
        len = abs(y2 - y1);
        tmp = abs(x2 - x1);
        PatternOffset += (len > tmp) ? len : tmp;
        PatternOffset %= PatternLength;
#endif
    }                           /* while (nline--) */

#ifndef POLYSEGMENT
    /* paint the last point if the end style isn't CapNotLast.
       (Assume that a projecting, butt, or round cap that is one
       pixel wide is the same as the single pixel of the endpoint.)
     */

    if ((pGC->capStyle != CapNotLast) &&
        ((ppt->x + xorg != pptInit->x + pDrawable->x) ||
         (ppt->y + yorg != pptInit->y + pDrawable->y) ||
         (ppt == pptInit + 1))) {
        nbox = nboxInit;
        pbox = pboxInit;
        while (nbox--) {
            if ((x2 >= pbox->x1) && (y2 >= pbox->y1) &&
                (x2 < pbox->x2) && (y2 < pbox->y2)) {
                if (infoRec->SubsequentDashedTwoPointLine) {
                    (*infoRec->SubsequentDashedTwoPointLine) (infoRec->pScrn,
                                                              x2, y2, x2, y2, 0,
                                                              PatternOffset);
                }
                else {
                    (*infoRec->SubsequentDashedBresenhamLine) (infoRec->pScrn,
                                                               x2, y2, 2, 0, -1,
                                                               1, 0,
                                                               PatternOffset);
                }
                break;
            }
            else
                pbox++;
        }
    }
#endif

    SET_SYNC_FLAG(infoRec);
}
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a19 1

d22 2
a23 5
XAAPolySegmentDashed(
    DrawablePtr	pDrawable,
    GCPtr	pGC,
    int		nseg,
    xSegment	*pSeg
d25 3
a27 6
XAAPolyLinesDashed(
    DrawablePtr pDrawable,
    GCPtr	pGC,
    int		mode,		/* Origin or Previous */
    int		npt,		/* number of points */
    DDXPointPtr pptInit
d29 2
a30 1
){
d32 2
a33 2
    XAAGCPtr   pGCPriv = (XAAGCPtr)dixLookupPrivate(&pGC->devPrivates,
						    XAAGetGCKey());
d41 1
d50 2
a51 2
    if(!nboxInit)
	return;
d54 5
a58 4
	int minValX = infoRec->DashedLineLimits.x1;
	int maxValX = infoRec->DashedLineLimits.x2;
	int minValY = infoRec->DashedLineLimits.y1;
	int maxValY = infoRec->DashedLineLimits.y2;
d60 2
a61 2
	int n = nseg;
	xSegment *s = pSeg;
d63 1
a63 1
	while (n--)
d65 16
a80 16
	int n = npt;
	int xorgtmp = xorg;
	int yorgtmp = yorg;

	ppt = pptInit;
	x2 = ppt->x + xorgtmp;
	y2 = ppt->y + yorgtmp;
	while (--n)
#endif
	{
#ifdef POLYSEGMENT
	    x1 = s->x1 + xorg;
	    y1 = s->y1 + yorg;
	    x2 = s->x2 + xorg;
	    y2 = s->y2 + yorg;
	    s++;
d82 13
a94 14
	    x1 = x2;
	    y1 = y2;
	    ++ppt;
	    if (mode == CoordModePrevious) {
		xorgtmp = x1;
		yorgtmp = y1;
	    }
	    x2 = ppt->x + xorgtmp;
	    y2 = ppt->y + yorgtmp;
#endif
	    if (x1 > maxValX || x1 < minValX ||
		x2 > maxValX || x2 < minValX ||
		y1 > maxValY || y1 < minValY ||
		y2 > maxValY || y2 < minValY) {
d96 1
a96 1
		XAAFallbackOps.PolySegment(pDrawable, pGC, nseg, pSeg);
d98 1
a98 1
		XAAFallbackOps.Polylines(pDrawable, pGC, mode, npt, pptInit);
d100 3
a102 3
		return;
	    }
	}
d105 1
a105 1
    PatternLength = pGCPriv->DashLength; 
d108 5
a112 4
    (*infoRec->SetupForDashedLine)(infoRec->pScrn, pGC->fgPixel,
		(pGC->lineStyle == LineDoubleDash) ? pGC->bgPixel : -1,
		pGC->alu, pGC->planemask, PatternLength, pGCPriv->DashPattern);

d120 1
a120 1
    while(--npt)
d123 2
a124 2
	nbox = nboxInit;
	pbox = pboxInit;
d127 5
a131 5
	x1 = pSeg->x1 + xorg;	
	y1 = pSeg->y1 + yorg;
	x2 = pSeg->x2 + xorg;	
	y2 = pSeg->y2 + yorg;
	pSeg++;
d133 129
a261 108
	x1 = x2; 
	y1 = y2;
	++ppt;
	if (mode == CoordModePrevious) {
	    xorg = x1; 
	    yorg = y1;
	}
	x2 = ppt->x + xorg; 
	y2 = ppt->y + yorg;
#endif


	if (infoRec->SubsequentDashedBresenhamLine) {
	    if((dmaj = x2 - x1) < 0) {
		dmaj = -dmaj;
		octant = XDECREASING;
	    } else octant = 0;		   

	    if((dmin = y2 - y1) < 0) {
		dmin = -dmin;
		octant |= YDECREASING;
	    }	
	
	    if(dmin >= dmaj){
		tmp = dmin; dmin = dmaj; dmaj = tmp;
		octant |= YMAJOR;
	    }

	    e = -dmaj - ((bias >> octant) & 1);
	    len = dmaj;
	    dmin <<= 1;
	    dmaj <<= 1;
	} else {	/* Muffle compiler */
	    dmin = dmaj = e = octant = len = 0;
	}

	while(nbox--) {
	    oc1 = oc2 = 0;
	    OUTCODES(oc1, x1, y1, pbox);
	    OUTCODES(oc2, x2, y2, pbox);
	    if (!(oc1 | oc2)) {   /* uncliped */
		if(infoRec->SubsequentDashedTwoPointLine) {
		   (*infoRec->SubsequentDashedTwoPointLine)(
				infoRec->pScrn, x1, y1, x2, y2, 
#ifdef POLYSEGMENT
			    	(pGC->capStyle != CapNotLast) ? 0 :
#endif
				OMIT_LAST, PatternOffset);
		} else {
		    (*infoRec->SubsequentDashedBresenhamLine)(
				infoRec->pScrn, x1, y1, dmaj, dmin, e, 
#ifdef POLYSEGMENT
			    	(pGC->capStyle != CapNotLast) ? (len+1) :
#endif
			    	len, octant, PatternOffset);
		}
		break;
	    } else if (oc1 & oc2) { /* completely clipped */
		pbox++;
	    } else if (infoRec->ClippingFlags & HARDWARE_CLIP_DASHED_LINE) {
		(*infoRec->SetClippingRectangle)(infoRec->pScrn,
			pbox->x1, pbox->y1, pbox->x2 - 1, pbox->y2 - 1);

		if(infoRec->SubsequentDashedBresenhamLine) {
		    (*infoRec->SubsequentDashedBresenhamLine)(
				infoRec->pScrn, x1, y1, dmaj, dmin, e, 
#ifdef POLYSEGMENT
			    	(pGC->capStyle != CapNotLast) ? (len+1) :
#endif
			    	len, octant, PatternOffset);
		} else {
			(*infoRec->SubsequentDashedTwoPointLine)(
				infoRec->pScrn, x1, y1, x2, y2, 
#ifdef POLYSEGMENT
			    	(pGC->capStyle != CapNotLast) ? 0 :
#endif
				OMIT_LAST, PatternOffset
			);
		}
		(*infoRec->DisableClipping)(infoRec->pScrn);
		pbox++;
	    } else {
		int new_x1 = x1, new_y1 = y1, new_x2 = x2, new_y2 = y2;
		int clip1 = 0, clip2 = 0;
		int err, adx, ady;
		    
		if(octant & YMAJOR) {
		    ady = dmaj >> 1;
		    adx = dmin >> 1;
		} else {
		    ady = dmin >> 1;
		    adx = dmaj >> 1;
		}

		if (miZeroClipLine(pbox->x1, pbox->y1, 
				       pbox->x2 - 1, pbox->y2 - 1,
				       &new_x1, &new_y1, &new_x2, &new_y2,
				       adx, ady, &clip1, &clip2,
				       octant, bias, oc1, oc2) == -1)
		{
		    pbox++;
		    continue;
		}

		if (octant & YMAJOR)
		    len = abs(new_y2 - new_y1);
		else
		    len = abs(new_x2 - new_x1);
d263 2
a264 2
		if (clip2 != 0 || pGC->capStyle != CapNotLast)
		    len++;
d266 1
a266 1
		len += (clip2 != 0);
d268 15
a282 13
		if (len) {
		    int abserr, clipdx, clipdy;
			/* unwind bresenham error term to first point */
		    if (clip1) {
			clipdx = abs(new_x1 - x1);
			clipdy = abs(new_y1 - y1);

			if (octant & YMAJOR)
			    err = e + clipdy*dmin - clipdx*dmaj;
			else
			    err = e + clipdx*dmin - clipdy*dmaj;
		    } else
			err = e;
d285 25
a309 25
		    abserr = abs(err);			    
		    while((abserr & range) || 
			  (dmaj & range) ||
			  (dmin & range)) {
			dmin >>= 1;
			dmaj >>= 1;
			abserr >>= 1;
			err /= 2;
		    }

		    if(octant & YMAJOR)
			offset = abs(new_y1 - y1);
		    else 
			offset = abs(new_x1 - x1);

		    offset += PatternOffset;
		    offset %= PatternLength;

		    (*infoRec->SubsequentDashedBresenhamLine)(
				infoRec->pScrn, new_x1, new_y1,
				dmaj, dmin, err, len, octant, offset);
		}
		pbox++;
	    }
	} /* while (nbox--) */
d311 4
a314 4
	len = abs(y2 - y1);
	tmp = abs(x2 - x1);
	PatternOffset += (len > tmp) ? len : tmp;
	PatternOffset %= PatternLength;
d316 1
a316 1
    } /* while (nline--) */
d321 2
a322 2
        pixel wide is the same as the single pixel of the endpoint.)
    */
d325 24
a348 23
	((ppt->x + xorg != pptInit->x + pDrawable->x) ||
	 (ppt->y + yorg != pptInit->y + pDrawable->y) ||
	 (ppt == pptInit + 1)))
    {
	nbox = nboxInit;
	pbox = pboxInit;
	while (nbox--) {
	    if ((x2 >= pbox->x1) && (y2 >= pbox->y1) &&
		(x2 <  pbox->x2) && (y2 <  pbox->y2))
	    {
		if(infoRec->SubsequentDashedTwoPointLine) {
			(*infoRec->SubsequentDashedTwoPointLine)(
				infoRec->pScrn, x2, y2, x2, y2, 0,
				PatternOffset);
		} else {
			(*infoRec->SubsequentDashedBresenhamLine)(
				infoRec->pScrn, x2, y2, 2, 0, -1, 
				1, 0, PatternOffset);
		}
		break;
	    } else
		pbox++;
	}
a353 1

@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d40 2
a41 2
    BoxPtr pboxInit = REGION_RECTS(pGC->pCompositeClip);
    int nboxInit = REGION_NUM_RECTS(pGC->pCompositeClip);
@


1.1
log
@Initial revision
@
text
@d38 2
a39 1
    XAAGCPtr   pGCPriv = (XAAGCPtr) (pGC)->devPrivates[XAAGCIndex].ptr;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d38 1
a38 1
    XAAGCPtr   pGCPriv = (XAAGCPtr) (pGC)->devPrivates[XAAGetGCIndex()].ptr;
@

