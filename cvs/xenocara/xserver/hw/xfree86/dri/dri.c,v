head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.6
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.6
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.2
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	s0SI41sEunLdyFfd;

1.12
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2013.06.07.17.28.51;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.08.31.21.22.35;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.32;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.18.11;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.18.11;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.12.16.20.16.10;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.18.01.18;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/**************************************************************************

Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
Copyright 2000 VA Linux Systems, Inc.
All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sub license, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Jens Owen <jens@@tungstengraphics.com>
 *   Rickard E. (Rik) Faith <faith@@valinux.com>
 *
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "xf86.h"
#include <sys/time.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/ioctl.h>
#include <errno.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include "xf86drm.h"
#include "misc.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "extinit.h"
#include "colormapst.h"
#include "cursorstr.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "servermd.h"
#define _XF86DRI_SERVER_
#include <X11/dri/xf86driproto.h>
#include "swaprep.h"
#include "xf86str.h"
#include "dri.h"
#include "sarea.h"
#include "dristruct.h"
#include "mi.h"
#include "mipointer.h"
#include "xf86_OSproc.h"
#include "inputstr.h"
#include "xf86VGAarbiter.h"
#include "xf86Extensions.h"

static int DRIEntPrivIndex = -1;
static DevPrivateKeyRec DRIScreenPrivKeyRec;

#define DRIScreenPrivKey (&DRIScreenPrivKeyRec)
static DevPrivateKeyRec DRIWindowPrivKeyRec;

#define DRIWindowPrivKey (&DRIWindowPrivKeyRec)
static unsigned long DRIGeneration = 0;
static unsigned int DRIDrawableValidationStamp = 0;

static RESTYPE DRIDrawablePrivResType;
static RESTYPE DRIContextPrivResType;
static void DRIDestroyDummyContext(ScreenPtr pScreen, Bool hasCtxPriv);

drmServerInfo DRIDRMServerInfo;

                                /* Wrapper just like xf86DrvMsg, but
                                   without the verbosity level checking.
                                   This will make it easy to turn off some
                                   messages later, based on verbosity
                                   level. */

/*
 * Since we're already referencing things from the XFree86 common layer in
 * this file, we'd might as well just call xf86VDrvMsgVerb, and have
 * consistent message formatting.  The verbosity of these messages can be
 * easily changed here.
 */
#define DRI_MSG_VERBOSITY 1

static void
DRIDrvMsg(int scrnIndex, MessageType type, const char *format, ...)
    _X_ATTRIBUTE_PRINTF(3,4);

static void
DRIDrvMsg(int scrnIndex, MessageType type, const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    xf86VDrvMsgVerb(scrnIndex, type, DRI_MSG_VERBOSITY, format, ap);
    va_end(ap);
}

static void
DRIOpenDRMCleanup(DRIEntPrivPtr pDRIEntPriv)
{
    if (pDRIEntPriv->pLSAREA != NULL) {
        drmUnmap(pDRIEntPriv->pLSAREA, pDRIEntPriv->sAreaSize);
        pDRIEntPriv->pLSAREA = NULL;
    }
    if (pDRIEntPriv->hLSAREA != 0) {
        drmRmMap(pDRIEntPriv->drmFD, pDRIEntPriv->hLSAREA);
    }
    if (pDRIEntPriv->drmFD >= 0) {
        drmClose(pDRIEntPriv->drmFD);
        pDRIEntPriv->drmFD = 0;
    }
}

int
DRIMasterFD(ScrnInfoPtr pScrn)
{
    return DRI_ENT_PRIV(pScrn)->drmFD;
}

void *
DRIMasterSareaPointer(ScrnInfoPtr pScrn)
{
    return DRI_ENT_PRIV(pScrn)->pLSAREA;
}

drm_handle_t
DRIMasterSareaHandle(ScrnInfoPtr pScrn)
{
    return DRI_ENT_PRIV(pScrn)->hLSAREA;
}

Bool
DRIOpenDRMMaster(ScrnInfoPtr pScrn,
                 unsigned long sAreaSize,
                 const char *busID, const char *drmDriverName)
{
    drmSetVersion saveSv, sv;
    Bool drmWasAvailable;
    DRIEntPrivPtr pDRIEntPriv;
    DRIEntPrivRec tmp;
    drmVersionPtr drmlibv;
    int drmlibmajor, drmlibminor;
    const char *openBusID;
    int count;
    int err;

    if (DRIEntPrivIndex == -1)
        DRIEntPrivIndex = xf86AllocateEntityPrivateIndex();

    pDRIEntPriv = DRI_ENT_PRIV(pScrn);

    if (pDRIEntPriv && pDRIEntPriv->drmFD != -1)
        return TRUE;

    drmWasAvailable = drmAvailable();

    memset(&tmp, 0, sizeof(tmp));

    /* Check the DRM lib version.
     */

    drmlibmajor = 1;
    drmlibminor = 0;
    drmlibv = drmGetLibVersion(-1);
    if (drmlibv != NULL) {
        drmlibmajor = drmlibv->version_major;
        drmlibminor = drmlibv->version_minor;
        drmFreeVersion(drmlibv);
    }

    /* Check if the libdrm can handle falling back to loading based on name
     * if a busid string is passed.
     */
    openBusID = (drmlibmajor == 1 && drmlibminor >= 2) ? busID : NULL;

    tmp.drmFD = -1;
    sv.drm_di_major = 1;
    sv.drm_di_minor = 1;
    sv.drm_dd_major = -1;

    saveSv = sv;
    count = 10;
    while (count--) {
        tmp.drmFD = drmOpen(drmDriverName, openBusID);

        if (tmp.drmFD < 0) {
            DRIDrvMsg(-1, X_ERROR, "[drm] drmOpen failed.\n");
            goto out_err;
        }

        err = drmSetInterfaceVersion(tmp.drmFD, &sv);

        if (err != -EPERM)
            break;

        sv = saveSv;
        drmClose(tmp.drmFD);
        tmp.drmFD = -1;
        usleep(100000);
    }

    if (tmp.drmFD <= 0) {
        DRIDrvMsg(-1, X_ERROR, "[drm] DRM was busy with another master.\n");
        goto out_err;
    }

    if (!drmWasAvailable) {
        DRIDrvMsg(-1, X_INFO,
                  "[drm] loaded kernel module for \"%s\" driver.\n",
                  drmDriverName);
    }

    if (err != 0) {
        sv.drm_di_major = 1;
        sv.drm_di_minor = 0;
    }

    DRIDrvMsg(-1, X_INFO, "[drm] DRM interface version %d.%d\n",
              sv.drm_di_major, sv.drm_di_minor);

    if (sv.drm_di_major == 1 && sv.drm_di_minor >= 1)
        err = 0;
    else
        err = drmSetBusid(tmp.drmFD, busID);

    if (err) {
        DRIDrvMsg(-1, X_ERROR, "[drm] Could not set DRM device bus ID.\n");
        goto out_err;
    }

    /*
     * Create a lock-containing sarea.
     */

    if (drmAddMap(tmp.drmFD, 0, sAreaSize, DRM_SHM,
                  DRM_CONTAINS_LOCK, &tmp.hLSAREA) < 0) {
        DRIDrvMsg(-1, X_INFO, "[drm] Could not create SAREA for DRM lock.\n");
        tmp.hLSAREA = 0;
        goto out_err;
    }

    if (drmMap(tmp.drmFD, tmp.hLSAREA, sAreaSize,
               (drmAddressPtr) (&tmp.pLSAREA)) < 0) {
        DRIDrvMsg(-1, X_INFO, "[drm] Mapping SAREA for DRM lock failed.\n");
        tmp.pLSAREA = NULL;
        goto out_err;
    }

    memset(tmp.pLSAREA, 0, sAreaSize);

    /*
     * Reserved contexts are handled by the first opened screen.
     */

    tmp.resOwner = NULL;

    if (!pDRIEntPriv)
        pDRIEntPriv = xnfcalloc(sizeof(*pDRIEntPriv), 1);

    if (!pDRIEntPriv) {
        DRIDrvMsg(-1, X_INFO, "[drm] Failed to allocate memory for "
                  "DRM device.\n");
        goto out_err;
    }
    *pDRIEntPriv = tmp;
    xf86GetEntityPrivate((pScrn)->entityList[0], DRIEntPrivIndex)->ptr =
        pDRIEntPriv;

    DRIDrvMsg(-1, X_INFO, "[drm] DRM open master succeeded.\n");
    return TRUE;

 out_err:

    DRIOpenDRMCleanup(&tmp);
    return FALSE;
}

static void
 DRIClipNotifyAllDrawables(ScreenPtr pScreen);

static void
dri_crtc_notify(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    DRIClipNotifyAllDrawables(pScreen);
    xf86_unwrap_crtc_notify(pScreen, pDRIPriv->xf86_crtc_notify);
    xf86_crtc_notify(pScreen);
    pDRIPriv->xf86_crtc_notify =
        xf86_wrap_crtc_notify(pScreen, dri_crtc_notify);
}

Bool
DRIScreenInit(ScreenPtr pScreen, DRIInfoPtr pDRIInfo, int *pDRMFD)
{
    DRIScreenPrivPtr pDRIPriv;
    drm_context_t *reserved;
    int reserved_count;
    int i;
    DRIEntPrivPtr pDRIEntPriv;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    DRIContextFlags flags = 0;
    DRIContextPrivPtr pDRIContextPriv;
    static Bool drm_server_inited;

    /* If the DRI extension is disabled, do not initialize the DRI */
    if (noXFree86DRIExtension) {
        DRIDrvMsg(pScreen->myNum, X_WARNING,
                  "Direct rendering has been disabled.\n");
        return FALSE;
    }

    if (!xf86VGAarbiterAllowDRI(pScreen)) {
        DRIDrvMsg(pScreen->myNum, X_WARNING,
                  "Direct rendering is not supported when VGA arb is necessary for the device\n");
        return FALSE;
    }

#ifdef PANORAMIX
    /*
     * If Xinerama is on, don't allow DRI to initialise.  It won't be usable
     * anyway.
     */
    if (!noPanoramiXExtension) {
        DRIDrvMsg(pScreen->myNum, X_WARNING,
                  "Direct rendering is not supported when Xinerama is enabled\n");
        return FALSE;
    }
#endif
    if (drm_server_inited == FALSE) {
        drmSetServerInfo(&DRIDRMServerInfo);
        drm_server_inited = TRUE;
    }

    if (!DRIOpenDRMMaster(pScrn, pDRIInfo->SAREASize,
                          pDRIInfo->busIdString, pDRIInfo->drmDriverName))
        return FALSE;

    pDRIEntPriv = DRI_ENT_PRIV(pScrn);

    if (DRIGeneration != serverGeneration)
        DRIGeneration = serverGeneration;

    if (!dixRegisterPrivateKey(&DRIScreenPrivKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;
    if (!dixRegisterPrivateKey(&DRIWindowPrivKeyRec, PRIVATE_WINDOW, 0))
        return FALSE;

    pDRIPriv = (DRIScreenPrivPtr) calloc(1, sizeof(DRIScreenPrivRec));
    if (!pDRIPriv) {
        dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, NULL);
        return FALSE;
    }

    dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, pDRIPriv);
    pDRIPriv->drmFD = pDRIEntPriv->drmFD;
    pDRIPriv->directRenderingSupport = TRUE;
    pDRIPriv->pDriverInfo = pDRIInfo;
    pDRIPriv->nrWindows = 0;
    pDRIPriv->nrWindowsVisible = 0;
    pDRIPriv->fullscreen = NULL;

    pDRIPriv->createDummyCtx = pDRIInfo->createDummyCtx;
    pDRIPriv->createDummyCtxPriv = pDRIInfo->createDummyCtxPriv;

    pDRIPriv->grabbedDRILock = FALSE;
    *pDRMFD = pDRIPriv->drmFD;

    if (pDRIEntPriv->sAreaGrabbed || pDRIInfo->allocSarea) {

        if (drmAddMap(pDRIPriv->drmFD,
                      0,
                      pDRIPriv->pDriverInfo->SAREASize,
                      DRM_SHM, 0, &pDRIPriv->hSAREA) < 0) {
            pDRIPriv->directRenderingSupport = FALSE;
            dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, NULL);
            drmClose(pDRIPriv->drmFD);
            DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] drmAddMap failed\n");
            return FALSE;
        }
        DRIDrvMsg(pScreen->myNum, X_INFO,
                  "[drm] added %d byte SAREA at %p\n",
                  (int) pDRIPriv->pDriverInfo->SAREASize, (void *) (uintptr_t) pDRIPriv->hSAREA);

        /* Backwards compat. */
        if (drmMap(pDRIPriv->drmFD,
                   pDRIPriv->hSAREA,
                   pDRIPriv->pDriverInfo->SAREASize,
                   (drmAddressPtr) (&pDRIPriv->pSAREA)) < 0) {
            pDRIPriv->directRenderingSupport = FALSE;
            dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, NULL);
            drmClose(pDRIPriv->drmFD);
            DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] drmMap failed\n");
            return FALSE;
        }
        DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] mapped SAREA %p to %p\n",
                  (void *) (uintptr_t) pDRIPriv->hSAREA, pDRIPriv->pSAREA);
        memset(pDRIPriv->pSAREA, 0, pDRIPriv->pDriverInfo->SAREASize);
    }
    else {
        DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] Using the DRM lock "
                  "SAREA also for drawables.\n");
        pDRIPriv->hSAREA = pDRIEntPriv->hLSAREA;
        pDRIPriv->pSAREA = (XF86DRISAREAPtr) pDRIEntPriv->pLSAREA;
        pDRIEntPriv->sAreaGrabbed = TRUE;
    }

    pDRIPriv->hLSAREA = pDRIEntPriv->hLSAREA;
    pDRIPriv->pLSAREA = pDRIEntPriv->pLSAREA;

    if (!pDRIPriv->pDriverInfo->dontMapFrameBuffer) {
        if (drmAddMap(pDRIPriv->drmFD,
                      (uintptr_t) pDRIPriv->pDriverInfo->
                      frameBufferPhysicalAddress,
                      pDRIPriv->pDriverInfo->frameBufferSize, DRM_FRAME_BUFFER,
                      0, &pDRIPriv->pDriverInfo->hFrameBuffer) < 0) {
            pDRIPriv->directRenderingSupport = FALSE;
            dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, NULL);
            drmUnmap(pDRIPriv->pSAREA, pDRIPriv->pDriverInfo->SAREASize);
            drmClose(pDRIPriv->drmFD);
            DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] drmAddMap failed\n");
            return FALSE;
        }
        DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] framebuffer handle = %p\n",
                  (void *) (uintptr_t) pDRIPriv->pDriverInfo->hFrameBuffer);
    }
    else {
        DRIDrvMsg(pScreen->myNum, X_INFO,
                  "[drm] framebuffer mapped by ddx driver\n");
    }

    if (pDRIEntPriv->resOwner == NULL) {
        pDRIEntPriv->resOwner = pScreen;

        /* Add tags for reserved contexts */
        if ((reserved = drmGetReservedContextList(pDRIPriv->drmFD,
                                                  &reserved_count))) {
            int r;
            void *tag;

            for (r = 0; r < reserved_count; r++) {
                tag = DRICreateContextPrivFromHandle(pScreen,
                                                     reserved[r],
                                                     DRI_CONTEXT_RESERVED);
                drmAddContextTag(pDRIPriv->drmFD, reserved[r], tag);
            }
            drmFreeReservedContextList(reserved);
            DRIDrvMsg(pScreen->myNum, X_INFO,
                      "[drm] added %d reserved context%s for kernel\n",
                      reserved_count, reserved_count > 1 ? "s" : "");
        }
    }

    /* validate max drawable table entry set by driver */
    if ((pDRIPriv->pDriverInfo->maxDrawableTableEntry <= 0) ||
        (pDRIPriv->pDriverInfo->maxDrawableTableEntry > SAREA_MAX_DRAWABLES)) {
        DRIDrvMsg(pScreen->myNum, X_ERROR,
                  "Invalid max drawable table size set by driver: %d\n",
                  pDRIPriv->pDriverInfo->maxDrawableTableEntry);
    }

    /* Initialize drawable tables (screen private and SAREA) */
    for (i = 0; i < pDRIPriv->pDriverInfo->maxDrawableTableEntry; i++) {
        pDRIPriv->DRIDrawables[i] = NULL;
        pDRIPriv->pSAREA->drawableTable[i].stamp = 0;
        pDRIPriv->pSAREA->drawableTable[i].flags = 0;
    }

    pDRIPriv->pLockRefCount = &pDRIEntPriv->lockRefCount;
    pDRIPriv->pLockingContext = &pDRIEntPriv->lockingContext;

    if (!pDRIEntPriv->keepFDOpen)
        pDRIEntPriv->keepFDOpen = pDRIInfo->keepFDOpen;

    pDRIEntPriv->refCount++;

    /* Set up flags for DRICreateContextPriv */
    switch (pDRIInfo->driverSwapMethod) {
    case DRI_KERNEL_SWAP:
        flags = DRI_CONTEXT_2DONLY;
        break;
    case DRI_HIDE_X_CONTEXT:
        flags = DRI_CONTEXT_PRESERVED;
        break;
    }

    if (!(pDRIContextPriv = DRICreateContextPriv(pScreen,
                                                 &pDRIPriv->myContext,
                                                 flags))) {
        DRIDrvMsg(pScreen->myNum, X_ERROR, "failed to create server context\n");
        return FALSE;
    }
    pDRIPriv->myContextPriv = pDRIContextPriv;

    DRIDrvMsg(pScreen->myNum, X_INFO,
              "X context handle = %p\n", (void *) (uintptr_t) pDRIPriv->myContext);

    /* Now that we have created the X server's context, we can grab the
     * hardware lock for the X server.
     */
    DRILock(pScreen, 0);
    pDRIPriv->grabbedDRILock = TRUE;

    /* pointers so that we can prevent memory leaks later */
    pDRIPriv->hiddenContextStore = NULL;
    pDRIPriv->partial3DContextStore = NULL;

    switch (pDRIInfo->driverSwapMethod) {
    case DRI_HIDE_X_CONTEXT:
        /* Server will handle 3D swaps, and hide 2D swaps from kernel.
         * Register server context as a preserved context.
         */

        /* allocate memory for hidden context store */
        pDRIPriv->hiddenContextStore
            = (void *) calloc(1, pDRIInfo->contextSize);
        if (!pDRIPriv->hiddenContextStore) {
            DRIDrvMsg(pScreen->myNum, X_ERROR,
                      "failed to allocate hidden context\n");
            DRIDestroyContextPriv(pDRIContextPriv);
            return FALSE;
        }

        /* allocate memory for partial 3D context store */
        pDRIPriv->partial3DContextStore
            = (void *) calloc(1, pDRIInfo->contextSize);
        if (!pDRIPriv->partial3DContextStore) {
            DRIDrvMsg(pScreen->myNum, X_ERROR,
                      "[DRI] failed to allocate partial 3D context\n");
            free(pDRIPriv->hiddenContextStore);
            DRIDestroyContextPriv(pDRIContextPriv);
            return FALSE;
        }

        /* save initial context store */
        if (pDRIInfo->SwapContext) {
            (*pDRIInfo->SwapContext) (pScreen,
                                      DRI_NO_SYNC,
                                      DRI_2D_CONTEXT,
                                      pDRIPriv->hiddenContextStore,
                                      DRI_NO_CONTEXT, NULL);
        }
        /* fall through */

    case DRI_SERVER_SWAP:
    default:
        break;
    }

    return TRUE;
}

Bool
DRIFinishScreenInit(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIInfoPtr pDRIInfo = pDRIPriv->pDriverInfo;

    /* Wrap DRI support */
    if (pDRIInfo->wrap.WindowExposures) {
        pDRIPriv->wrap.WindowExposures = pScreen->WindowExposures;
        pScreen->WindowExposures = pDRIInfo->wrap.WindowExposures;
    }

    pDRIPriv->DestroyWindow = pScreen->DestroyWindow;
    pScreen->DestroyWindow = DRIDestroyWindow;

    pDRIPriv->xf86_crtc_notify = xf86_wrap_crtc_notify(pScreen,
                                                       dri_crtc_notify);

    if (pDRIInfo->wrap.CopyWindow) {
        pDRIPriv->wrap.CopyWindow = pScreen->CopyWindow;
        pScreen->CopyWindow = pDRIInfo->wrap.CopyWindow;
    }
    if (pDRIInfo->wrap.ClipNotify) {
        pDRIPriv->wrap.ClipNotify = pScreen->ClipNotify;
        pScreen->ClipNotify = pDRIInfo->wrap.ClipNotify;
    }
    if (pDRIInfo->wrap.AdjustFrame) {
        ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);

        pDRIPriv->wrap.AdjustFrame = pScrn->AdjustFrame;
        pScrn->AdjustFrame = pDRIInfo->wrap.AdjustFrame;
    }
    pDRIPriv->wrapped = TRUE;

    DRIDrvMsg(pScreen->myNum, X_INFO, "[DRI] installation complete\n");

    return TRUE;
}

void
DRICloseScreen(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIInfoPtr pDRIInfo;
    drm_context_t *reserved;
    int reserved_count;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    DRIEntPrivPtr pDRIEntPriv = DRI_ENT_PRIV(pScrn);
    Bool closeMaster;

    if (pDRIPriv) {

        pDRIInfo = pDRIPriv->pDriverInfo;

        if (pDRIPriv->wrapped) {
            /* Unwrap DRI Functions */
            if (pDRIInfo->wrap.WindowExposures) {
                pScreen->WindowExposures = pDRIPriv->wrap.WindowExposures;
                pDRIPriv->wrap.WindowExposures = NULL;
            }
            if (pDRIPriv->DestroyWindow) {
                pScreen->DestroyWindow = pDRIPriv->DestroyWindow;
                pDRIPriv->DestroyWindow = NULL;
            }

            xf86_unwrap_crtc_notify(pScreen, pDRIPriv->xf86_crtc_notify);

            if (pDRIInfo->wrap.CopyWindow) {
                pScreen->CopyWindow = pDRIPriv->wrap.CopyWindow;
                pDRIPriv->wrap.CopyWindow = NULL;
            }
            if (pDRIInfo->wrap.ClipNotify) {
                pScreen->ClipNotify = pDRIPriv->wrap.ClipNotify;
                pDRIPriv->wrap.ClipNotify = NULL;
            }
            if (pDRIInfo->wrap.AdjustFrame) {
                ScrnInfoPtr scrn = xf86ScreenToScrn(pScreen);

                scrn->AdjustFrame = pDRIPriv->wrap.AdjustFrame;
                pDRIPriv->wrap.AdjustFrame = NULL;
            }

            pDRIPriv->wrapped = FALSE;
        }

        if (pDRIPriv->dummyCtxPriv && pDRIPriv->createDummyCtx) {
            DRIDestroyDummyContext(pScreen, pDRIPriv->createDummyCtxPriv);
        }

        if (!DRIDestroyContextPriv(pDRIPriv->myContextPriv)) {
            DRIDrvMsg(pScreen->myNum, X_ERROR,
                      "failed to destroy server context\n");
        }

        /* Remove tags for reserved contexts */
        if (pDRIEntPriv->resOwner == pScreen) {
            pDRIEntPriv->resOwner = NULL;

            if ((reserved = drmGetReservedContextList(pDRIPriv->drmFD,
                                                      &reserved_count))) {
                int i;

                for (i = 0; i < reserved_count; i++) {
                    DRIDestroyContextPriv(drmGetContextTag(pDRIPriv->drmFD,
                                                           reserved[i]));
                }
                drmFreeReservedContextList(reserved);
                DRIDrvMsg(pScreen->myNum, X_INFO,
                          "[drm] removed %d reserved context%s for kernel\n",
                          reserved_count, reserved_count > 1 ? "s" : "");
            }
        }

        /* Make sure signals get unblocked etc. */
        drmUnlock(pDRIPriv->drmFD, pDRIPriv->myContext);
        pDRIPriv->pLockRefCount = NULL;
        closeMaster = (--pDRIEntPriv->refCount == 0) &&
            !pDRIEntPriv->keepFDOpen;
        if (closeMaster || pDRIPriv->hSAREA != pDRIEntPriv->hLSAREA) {
            DRIDrvMsg(pScreen->myNum, X_INFO,
                      "[drm] unmapping %d bytes of SAREA %p at %p\n",
                      (int) pDRIInfo->SAREASize, (void *) (uintptr_t) pDRIPriv->hSAREA, pDRIPriv->pSAREA);
            if (drmUnmap(pDRIPriv->pSAREA, pDRIInfo->SAREASize)) {
                DRIDrvMsg(pScreen->myNum, X_ERROR,
                          "[drm] unable to unmap %d bytes"
                          " of SAREA %p at %p\n",
                          (int) pDRIInfo->SAREASize,
                          (void *) (uintptr_t) pDRIPriv->hSAREA, pDRIPriv->pSAREA);
            }
        }
        else {
            pDRIEntPriv->sAreaGrabbed = FALSE;
        }

        if (closeMaster || (pDRIEntPriv->drmFD != pDRIPriv->drmFD)) {
            drmClose(pDRIPriv->drmFD);
            if (pDRIEntPriv->drmFD == pDRIPriv->drmFD) {
                DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] Closed DRM master.\n");
                pDRIEntPriv->drmFD = -1;
            }
        }

        free(pDRIPriv);
        dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, NULL);
    }
}

#define DRM_MSG_VERBOSITY 3

static int
dri_drm_debug_print(const char *format, va_list ap)
    _X_ATTRIBUTE_PRINTF(1,0);

static int
dri_drm_debug_print(const char *format, va_list ap)
{
    xf86VDrvMsgVerb(-1, X_NONE, DRM_MSG_VERBOSITY, format, ap);
    return 0;
}

static void
dri_drm_get_perms(gid_t * group, mode_t * mode)
{
    *group = xf86ConfigDRI.group;
    *mode = xf86ConfigDRI.mode;
}

drmServerInfo DRIDRMServerInfo = {
    dri_drm_debug_print,
    xf86LoadKernelModule,
    dri_drm_get_perms,
};

Bool
DRIExtensionInit(void)
{
    if (DRIGeneration != serverGeneration) {
        return FALSE;
    }

    DRIDrawablePrivResType = CreateNewResourceType(DRIDrawablePrivDelete,
                                                   "DRIDrawable");
    DRIContextPrivResType = CreateNewResourceType(DRIContextPrivDelete,
                                                  "DRIContext");

    if (!DRIDrawablePrivResType || !DRIContextPrivResType)
        return FALSE;

    RegisterBlockAndWakeupHandlers(DRIBlockHandler, DRIWakeupHandler, NULL);

    return TRUE;
}

void
DRIReset(void)
{
    /*
     * This stub routine is called when the X Server recycles, resources
     * allocated by DRIExtensionInit need to be managed here.
     *
     * Currently this routine is a stub because all the interesting resources
     * are managed via the screen init process.
     */
}

Bool
DRIQueryDirectRenderingCapable(ScreenPtr pScreen, Bool *isCapable)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (pDRIPriv)
        *isCapable = pDRIPriv->directRenderingSupport;
    else
        *isCapable = FALSE;

    return TRUE;
}

Bool
DRIOpenConnection(ScreenPtr pScreen, drm_handle_t * hSAREA, char **busIdString)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    *hSAREA = pDRIPriv->hSAREA;
    *busIdString = pDRIPriv->pDriverInfo->busIdString;

    return TRUE;
}

Bool
DRIAuthConnection(ScreenPtr pScreen, drm_magic_t magic)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (drmAuthMagic(pDRIPriv->drmFD, magic))
        return FALSE;
    return TRUE;
}

Bool
DRICloseConnection(ScreenPtr pScreen)
{
    return TRUE;
}

Bool
DRIGetClientDriverName(ScreenPtr pScreen,
                       int *ddxDriverMajorVersion,
                       int *ddxDriverMinorVersion,
                       int *ddxDriverPatchVersion, char **clientDriverName)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    *ddxDriverMajorVersion = pDRIPriv->pDriverInfo->ddxDriverMajorVersion;
    *ddxDriverMinorVersion = pDRIPriv->pDriverInfo->ddxDriverMinorVersion;
    *ddxDriverPatchVersion = pDRIPriv->pDriverInfo->ddxDriverPatchVersion;
    *clientDriverName = pDRIPriv->pDriverInfo->clientDriverName;

    return TRUE;
}

/* DRICreateContextPriv and DRICreateContextPrivFromHandle are helper
   functions that layer on drmCreateContext and drmAddContextTag.

   DRICreateContextPriv always creates a kernel drm_context_t and then calls
   DRICreateContextPrivFromHandle to create a DRIContextPriv structure for
   DRI tracking.  For the SIGIO handler, the drm_context_t is associated with
   DRIContextPrivPtr.  Any special flags are stored in the DRIContextPriv
   area and are passed to the kernel (if necessary).

   DRICreateContextPriv returns a pointer to newly allocated
   DRIContextPriv, and returns the kernel drm_context_t in pHWContext. */

DRIContextPrivPtr
DRICreateContextPriv(ScreenPtr pScreen,
                     drm_context_t * pHWContext, DRIContextFlags flags)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (drmCreateContext(pDRIPriv->drmFD, pHWContext)) {
        return NULL;
    }

    return DRICreateContextPrivFromHandle(pScreen, *pHWContext, flags);
}

DRIContextPrivPtr
DRICreateContextPrivFromHandle(ScreenPtr pScreen,
                               drm_context_t hHWContext, DRIContextFlags flags)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIContextPrivPtr pDRIContextPriv;
    int contextPrivSize;

    contextPrivSize = sizeof(DRIContextPrivRec) +
        pDRIPriv->pDriverInfo->contextSize;
    if (!(pDRIContextPriv = calloc(1, contextPrivSize))) {
        return NULL;
    }
    pDRIContextPriv->pContextStore = (void *) (pDRIContextPriv + 1);

    drmAddContextTag(pDRIPriv->drmFD, hHWContext, pDRIContextPriv);

    pDRIContextPriv->hwContext = hHWContext;
    pDRIContextPriv->pScreen = pScreen;
    pDRIContextPriv->flags = flags;
    pDRIContextPriv->valid3D = FALSE;

    if (flags & DRI_CONTEXT_2DONLY) {
        if (drmSetContextFlags(pDRIPriv->drmFD, hHWContext, DRM_CONTEXT_2DONLY)) {
            DRIDrvMsg(pScreen->myNum, X_ERROR,
                      "[drm] failed to set 2D context flag\n");
            DRIDestroyContextPriv(pDRIContextPriv);
            return NULL;
        }
    }
    if (flags & DRI_CONTEXT_PRESERVED) {
        if (drmSetContextFlags(pDRIPriv->drmFD,
                               hHWContext, DRM_CONTEXT_PRESERVED)) {
            DRIDrvMsg(pScreen->myNum, X_ERROR,
                      "[drm] failed to set preserved flag\n");
            DRIDestroyContextPriv(pDRIContextPriv);
            return NULL;
        }
    }
    return pDRIContextPriv;
}

Bool
DRIDestroyContextPriv(DRIContextPrivPtr pDRIContextPriv)
{
    DRIScreenPrivPtr pDRIPriv;

    if (!pDRIContextPriv)
        return TRUE;

    pDRIPriv = DRI_SCREEN_PRIV(pDRIContextPriv->pScreen);

    if (!(pDRIContextPriv->flags & DRI_CONTEXT_RESERVED)) {
        /* Don't delete reserved contexts from
           kernel area -- the kernel manages its
           reserved contexts itself. */
        if (drmDestroyContext(pDRIPriv->drmFD, pDRIContextPriv->hwContext))
            return FALSE;
    }

    /* Remove the tag last to prevent a race
       condition where the context has pending
       buffers.  The context can't be re-used
       while in this thread, but buffers can be
       dispatched asynchronously. */
    drmDelContextTag(pDRIPriv->drmFD, pDRIContextPriv->hwContext);
    free(pDRIContextPriv);
    return TRUE;
}

static Bool
DRICreateDummyContext(ScreenPtr pScreen, Bool needCtxPriv)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIContextPrivPtr pDRIContextPriv;
    void *contextStore;

    if (!(pDRIContextPriv =
          DRICreateContextPriv(pScreen, &pDRIPriv->pSAREA->dummy_context, 0))) {
        return FALSE;
    }

    contextStore = DRIGetContextStore(pDRIContextPriv);
    if (pDRIPriv->pDriverInfo->CreateContext && needCtxPriv) {
        if (!pDRIPriv->pDriverInfo->CreateContext(pScreen, NULL,
                                                  pDRIPriv->pSAREA->
                                                  dummy_context, NULL,
                                                  (DRIContextType) (long)
                                                  contextStore)) {
            DRIDestroyContextPriv(pDRIContextPriv);
            return FALSE;
        }
    }

    pDRIPriv->dummyCtxPriv = pDRIContextPriv;
    return TRUE;
}

static void
DRIDestroyDummyContext(ScreenPtr pScreen, Bool hasCtxPriv)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIContextPrivPtr pDRIContextPriv = pDRIPriv->dummyCtxPriv;
    void *contextStore;

    if (!pDRIContextPriv)
        return;
    if (pDRIPriv->pDriverInfo->DestroyContext && hasCtxPriv) {
        contextStore = DRIGetContextStore(pDRIContextPriv);
        pDRIPriv->pDriverInfo->DestroyContext(pDRIContextPriv->pScreen,
                                              pDRIContextPriv->hwContext,
                                              (DRIContextType) (long)
                                              contextStore);
    }

    DRIDestroyContextPriv(pDRIPriv->dummyCtxPriv);
    pDRIPriv->dummyCtxPriv = NULL;
}

Bool
DRICreateContext(ScreenPtr pScreen, VisualPtr visual,
                 XID context, drm_context_t * pHWContext)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIContextPrivPtr pDRIContextPriv;
    void *contextStore;

    if (pDRIPriv->createDummyCtx && !pDRIPriv->dummyCtxPriv) {
        if (!DRICreateDummyContext(pScreen, pDRIPriv->createDummyCtxPriv)) {
            DRIDrvMsg(pScreen->myNum, X_INFO,
                      "[drm] Could not create dummy context\n");
            return FALSE;
        }
    }

    if (!(pDRIContextPriv = DRICreateContextPriv(pScreen, pHWContext, 0))) {
        return FALSE;
    }

    contextStore = DRIGetContextStore(pDRIContextPriv);
    if (pDRIPriv->pDriverInfo->CreateContext) {
        if (!((*pDRIPriv->pDriverInfo->CreateContext) (pScreen, NULL,
                                                       *pHWContext, NULL,
                                                       (DRIContextType) (long)
                                                       contextStore))) {
            DRIDestroyContextPriv(pDRIContextPriv);
            return FALSE;
        }
    }

    /* track this in case the client dies before cleanup */
    if (!AddResource(context, DRIContextPrivResType, (void *) pDRIContextPriv))
        return FALSE;

    return TRUE;
}

Bool
DRIDestroyContext(ScreenPtr pScreen, XID context)
{
    FreeResourceByType(context, DRIContextPrivResType, FALSE);

    return TRUE;
}

/* DRIContextPrivDelete is called by the resource manager. */
Bool
DRIContextPrivDelete(void *pResource, XID id)
{
    DRIContextPrivPtr pDRIContextPriv = (DRIContextPrivPtr) pResource;
    DRIScreenPrivPtr pDRIPriv;
    void *contextStore;

    pDRIPriv = DRI_SCREEN_PRIV(pDRIContextPriv->pScreen);
    if (pDRIPriv->pDriverInfo->DestroyContext) {
        contextStore = DRIGetContextStore(pDRIContextPriv);
        pDRIPriv->pDriverInfo->DestroyContext(pDRIContextPriv->pScreen,
                                              pDRIContextPriv->hwContext,
                                              (DRIContextType) (long)
                                              contextStore);
    }
    return DRIDestroyContextPriv(pDRIContextPriv);
}

/* This walks the drawable timestamp array and invalidates all of them
 * in the case of transition from private to shared backbuffers.  It's
 * not necessary for correctness, because DRIClipNotify gets called in
 * time to prevent any conflict, but the transition from
 * shared->private is sometimes missed if we don't do this.
 */
static void
DRIClipNotifyAllDrawables(ScreenPtr pScreen)
{
    int i;
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    for (i = 0; i < pDRIPriv->pDriverInfo->maxDrawableTableEntry; i++) {
        pDRIPriv->pSAREA->drawableTable[i].stamp = DRIDrawableValidationStamp++;
    }
}

static void
DRITransitionToSharedBuffers(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIInfoPtr pDRIInfo = pDRIPriv->pDriverInfo;

    DRIClipNotifyAllDrawables(pScreen);

    if (pDRIInfo->TransitionSingleToMulti3D)
        pDRIInfo->TransitionSingleToMulti3D(pScreen);
}

static void
DRITransitionToPrivateBuffers(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIInfoPtr pDRIInfo = pDRIPriv->pDriverInfo;

    DRIClipNotifyAllDrawables(pScreen);

    if (pDRIInfo->TransitionMultiToSingle3D)
        pDRIInfo->TransitionMultiToSingle3D(pScreen);
}

static void
DRITransitionTo3d(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIInfoPtr pDRIInfo = pDRIPriv->pDriverInfo;

    DRIClipNotifyAllDrawables(pScreen);

    if (pDRIInfo->TransitionTo3d)
        pDRIInfo->TransitionTo3d(pScreen);
}

static void
DRITransitionTo2d(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIInfoPtr pDRIInfo = pDRIPriv->pDriverInfo;

    DRIClipNotifyAllDrawables(pScreen);

    if (pDRIInfo->TransitionTo2d)
        pDRIInfo->TransitionTo2d(pScreen);
}

static int
DRIDCNTreeTraversal(WindowPtr pWin, void *data)
{
    DRIDrawablePrivPtr pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);

    if (pDRIDrawablePriv) {
        ScreenPtr pScreen = pWin->drawable.pScreen;
        DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

        if (RegionNumRects(&pWin->clipList) > 0) {
            WindowPtr *pDRIWindows = (WindowPtr *) data;
            int i = 0;

            while (pDRIWindows[i])
                i++;

            pDRIWindows[i] = pWin;

            pDRIPriv->nrWalked++;
        }

        if (pDRIPriv->nrWindows == pDRIPriv->nrWalked)
            return WT_STOPWALKING;
    }

    return WT_WALKCHILDREN;
}

static void
DRIDriverClipNotify(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (pDRIPriv->pDriverInfo->ClipNotify) {
        WindowPtr *pDRIWindows = calloc(sizeof(WindowPtr), pDRIPriv->nrWindows);
        DRIInfoPtr pDRIInfo = pDRIPriv->pDriverInfo;

        if (pDRIPriv->nrWindows > 0) {
            pDRIPriv->nrWalked = 0;
            TraverseTree(pScreen->root, DRIDCNTreeTraversal,
                         (void *) pDRIWindows);
        }

        pDRIInfo->ClipNotify(pScreen, pDRIWindows, pDRIPriv->nrWindows);

        free(pDRIWindows);
    }
}

static void
DRIIncreaseNumberVisible(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    switch (++pDRIPriv->nrWindowsVisible) {
    case 1:
        DRITransitionTo3d(pScreen);
        break;
    case 2:
        DRITransitionToSharedBuffers(pScreen);
        break;
    default:
        break;
    }

    DRIDriverClipNotify(pScreen);
}

static void
DRIDecreaseNumberVisible(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    switch (--pDRIPriv->nrWindowsVisible) {
    case 0:
        DRITransitionTo2d(pScreen);
        break;
    case 1:
        DRITransitionToPrivateBuffers(pScreen);
        break;
    default:
        break;
    }

    DRIDriverClipNotify(pScreen);
}

Bool
DRICreateDrawable(ScreenPtr pScreen, ClientPtr client, DrawablePtr pDrawable,
                  drm_drawable_t * hHWDrawable)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIDrawablePrivPtr pDRIDrawablePriv;
    WindowPtr pWin;

    if (pDrawable->type == DRAWABLE_WINDOW) {
        pWin = (WindowPtr) pDrawable;
        if ((pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin))) {
            pDRIDrawablePriv->refCount++;

            if (!pDRIDrawablePriv->hwDrawable) {
                drmCreateDrawable(pDRIPriv->drmFD,
                                  &pDRIDrawablePriv->hwDrawable);
            }
        }
        else {
            /* allocate a DRI Window Private record */
            if (!(pDRIDrawablePriv = malloc(sizeof(DRIDrawablePrivRec)))) {
                return FALSE;
            }

            /* Only create a drm_drawable_t once */
            if (drmCreateDrawable(pDRIPriv->drmFD,
                                  &pDRIDrawablePriv->hwDrawable)) {
                free(pDRIDrawablePriv);
                return FALSE;
            }

            /* add it to the list of DRI drawables for this screen */
            pDRIDrawablePriv->pScreen = pScreen;
            pDRIDrawablePriv->refCount = 1;
            pDRIDrawablePriv->drawableIndex = -1;
            pDRIDrawablePriv->nrects = RegionNumRects(&pWin->clipList);

            /* save private off of preallocated index */
            dixSetPrivate(&pWin->devPrivates, DRIWindowPrivKey,
                          pDRIDrawablePriv);
            pDRIPriv->nrWindows++;

            if (pDRIDrawablePriv->nrects)
                DRIIncreaseNumberVisible(pScreen);
        }

        /* track this in case the client dies */
        if (!AddResource(FakeClientID(client->index), DRIDrawablePrivResType,
                         (void *) (intptr_t) pDrawable->id))
            return FALSE;

        if (pDRIDrawablePriv->hwDrawable) {
            drmUpdateDrawableInfo(pDRIPriv->drmFD,
                                  pDRIDrawablePriv->hwDrawable,
                                  DRM_DRAWABLE_CLIPRECTS,
                                  RegionNumRects(&pWin->clipList),
                                  RegionRects(&pWin->clipList));
            *hHWDrawable = pDRIDrawablePriv->hwDrawable;
        }
    }
    else if (pDrawable->type != DRAWABLE_PIXMAP) {      /* PBuffer */
        /* NOT_DONE */
        return FALSE;
    }

    return TRUE;
}

static void
DRIDrawablePrivDestroy(WindowPtr pWin)
{
    DRIDrawablePrivPtr pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
    ScreenPtr pScreen;
    DRIScreenPrivPtr pDRIPriv;

    if (!pDRIDrawablePriv)
        return;

    pScreen = pWin->drawable.pScreen;
    pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (pDRIDrawablePriv->drawableIndex != -1) {
        /* bump stamp to force outstanding 3D requests to resync */
        pDRIPriv->pSAREA->drawableTable[pDRIDrawablePriv->drawableIndex].stamp
            = DRIDrawableValidationStamp++;

        /* release drawable table entry */
        pDRIPriv->DRIDrawables[pDRIDrawablePriv->drawableIndex] = NULL;
    }

    pDRIPriv->nrWindows--;

    if (pDRIDrawablePriv->nrects)
        DRIDecreaseNumberVisible(pScreen);

    drmDestroyDrawable(pDRIPriv->drmFD, pDRIDrawablePriv->hwDrawable);

    free(pDRIDrawablePriv);
    dixSetPrivate(&pWin->devPrivates, DRIWindowPrivKey, NULL);
}

static Bool
DRIDestroyDrawableCB(void *value, XID id, void *data)
{
    if (value == data) {
        /* This calls back DRIDrawablePrivDelete which frees private area */
        FreeResourceByType(id, DRIDrawablePrivResType, FALSE);

        return TRUE;
    }

    return FALSE;
}

Bool
DRIDestroyDrawable(ScreenPtr pScreen, ClientPtr client, DrawablePtr pDrawable)
{
    if (pDrawable->type == DRAWABLE_WINDOW) {
        LookupClientResourceComplex(client, DRIDrawablePrivResType,
                                    DRIDestroyDrawableCB,
                                    (void *) (intptr_t) pDrawable->id);
    }
    else {                      /* pixmap (or for GLX 1.3, a PBuffer) */
        /* NOT_DONE */
        return FALSE;
    }

    return TRUE;
}

Bool
DRIDrawablePrivDelete(void *pResource, XID id)
{
    WindowPtr pWin;
    int rc;

    /* For DRIDrawablePrivResType, the XID is the client's fake ID. The
     * important XID is the value in pResource. */
    id = (XID) (intptr_t) pResource;
    rc = dixLookupWindow(&pWin, id, serverClient, DixGetAttrAccess);

    if (rc == Success) {
        DRIDrawablePrivPtr pDRIDrwPriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);

        if (!pDRIDrwPriv)
            return FALSE;

        if (--pDRIDrwPriv->refCount == 0)
            DRIDrawablePrivDestroy(pWin);

        return TRUE;
    }
    else {                      /* pixmap (or for GLX 1.3, a PBuffer) */
        /* NOT_DONE */
        return FALSE;
    }
}

Bool
DRIGetDrawableInfo(ScreenPtr pScreen,
                   DrawablePtr pDrawable,
                   unsigned int *index,
                   unsigned int *stamp,
                   int *X,
                   int *Y,
                   int *W,
                   int *H,
                   int *numClipRects,
                   drm_clip_rect_t ** pClipRects,
                   int *backX,
                   int *backY,
                   int *numBackClipRects, drm_clip_rect_t ** pBackClipRects)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIDrawablePrivPtr pDRIDrawablePriv, pOldDrawPriv;
    WindowPtr pWin, pOldWin;
    int i;

#if 0
    printf("maxDrawableTableEntry = %d\n",
           pDRIPriv->pDriverInfo->maxDrawableTableEntry);
#endif

    if (pDrawable->type == DRAWABLE_WINDOW) {
        pWin = (WindowPtr) pDrawable;
        if ((pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin))) {

            /* Manage drawable table */
            if (pDRIDrawablePriv->drawableIndex == -1) {        /* load SAREA table */

                /* Search table for empty entry */
                i = 0;
                while (i < pDRIPriv->pDriverInfo->maxDrawableTableEntry) {
                    if (!(pDRIPriv->DRIDrawables[i])) {
                        pDRIPriv->DRIDrawables[i] = pDrawable;
                        pDRIDrawablePriv->drawableIndex = i;
                        pDRIPriv->pSAREA->drawableTable[i].stamp =
                            DRIDrawableValidationStamp++;
                        break;
                    }
                    i++;
                }

                /* Search table for oldest entry */
                if (i == pDRIPriv->pDriverInfo->maxDrawableTableEntry) {
                    unsigned int oldestStamp = ~0;
                    int oldestIndex = 0;

                    i = pDRIPriv->pDriverInfo->maxDrawableTableEntry;
                    while (i--) {
                        if (pDRIPriv->pSAREA->drawableTable[i].stamp <
                            oldestStamp) {
                            oldestIndex = i;
                            oldestStamp =
                                pDRIPriv->pSAREA->drawableTable[i].stamp;
                        }
                    }
                    pDRIDrawablePriv->drawableIndex = oldestIndex;

                    /* release oldest drawable table entry */
                    pOldWin = (WindowPtr) pDRIPriv->DRIDrawables[oldestIndex];
                    pOldDrawPriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pOldWin);
                    pOldDrawPriv->drawableIndex = -1;

                    /* claim drawable table entry */
                    pDRIPriv->DRIDrawables[oldestIndex] = pDrawable;

                    /* validate SAREA entry */
                    pDRIPriv->pSAREA->drawableTable[oldestIndex].stamp =
                        DRIDrawableValidationStamp++;

                    /* check for stamp wrap around */
                    if (oldestStamp > DRIDrawableValidationStamp) {

                        /* walk SAREA table and invalidate all drawables */
                        for (i = 0;
                             i < pDRIPriv->pDriverInfo->maxDrawableTableEntry;
                             i++) {
                            pDRIPriv->pSAREA->drawableTable[i].stamp =
                                DRIDrawableValidationStamp++;
                        }
                    }
                }

                /* If the driver wants to be notified when the index is
                 * set for a drawable, let it know now.
                 */
                if (pDRIPriv->pDriverInfo->SetDrawableIndex)
                    pDRIPriv->pDriverInfo->SetDrawableIndex(pWin,
                                                            pDRIDrawablePriv->
                                                            drawableIndex);

                /* reinit drawable ID if window is visible */
                if ((pWin->viewable) &&
                    (pDRIPriv->pDriverInfo->bufferRequests != DRI_NO_WINDOWS)) {
                    (*pDRIPriv->pDriverInfo->InitBuffers) (pWin,
                                                           &pWin->clipList,
                                                           pDRIDrawablePriv->
                                                           drawableIndex);
                }
            }

            *index = pDRIDrawablePriv->drawableIndex;
            *stamp = pDRIPriv->pSAREA->drawableTable[*index].stamp;
            *X = (int) (pWin->drawable.x);
            *Y = (int) (pWin->drawable.y);
            *W = (int) (pWin->drawable.width);
            *H = (int) (pWin->drawable.height);
            *numClipRects = RegionNumRects(&pWin->clipList);
            *pClipRects = (drm_clip_rect_t *) RegionRects(&pWin->clipList);

            if (!*numClipRects && pDRIPriv->fullscreen) {
                /* use fake full-screen clip rect */
                pDRIPriv->fullscreen_rect.x1 = *X;
                pDRIPriv->fullscreen_rect.y1 = *Y;
                pDRIPriv->fullscreen_rect.x2 = *X + *W;
                pDRIPriv->fullscreen_rect.y2 = *Y + *H;

                *numClipRects = 1;
                *pClipRects = &pDRIPriv->fullscreen_rect;
            }

            *backX = *X;
            *backY = *Y;

            if (pDRIPriv->nrWindowsVisible == 1 && *numClipRects) {
                /* Use a single cliprect. */

                int x0 = *X;
                int y0 = *Y;
                int x1 = x0 + *W;
                int y1 = y0 + *H;

                if (x0 < 0)
                    x0 = 0;
                if (y0 < 0)
                    y0 = 0;
                if (x1 > pScreen->width)
                    x1 = pScreen->width;
                if (y1 > pScreen->height)
                    y1 = pScreen->height;

                if (y0 >= y1 || x0 >= x1) {
                    *numBackClipRects = 0;
                    *pBackClipRects = NULL;
                }
                else {
                    pDRIPriv->private_buffer_rect.x1 = x0;
                    pDRIPriv->private_buffer_rect.y1 = y0;
                    pDRIPriv->private_buffer_rect.x2 = x1;
                    pDRIPriv->private_buffer_rect.y2 = y1;

                    *numBackClipRects = 1;
                    *pBackClipRects = &(pDRIPriv->private_buffer_rect);
                }
            }
            else {
                /* Use the frontbuffer cliprects for back buffers.  */
                *numBackClipRects = 0;
                *pBackClipRects = 0;
            }
        }
        else {
            /* Not a DRIDrawable */
            return FALSE;
        }
    }
    else {                      /* pixmap (or for GLX 1.3, a PBuffer) */
        /* NOT_DONE */
        return FALSE;
    }

    return TRUE;
}

Bool
DRIGetDeviceInfo(ScreenPtr pScreen,
                 drm_handle_t * hFrameBuffer,
                 int *fbOrigin,
                 int *fbSize,
                 int *fbStride, int *devPrivateSize, void **pDevPrivate)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    *hFrameBuffer = pDRIPriv->pDriverInfo->hFrameBuffer;
    *fbOrigin = 0;
    *fbSize = pDRIPriv->pDriverInfo->frameBufferSize;
    *fbStride = pDRIPriv->pDriverInfo->frameBufferStride;
    *devPrivateSize = pDRIPriv->pDriverInfo->devPrivateSize;
    *pDevPrivate = pDRIPriv->pDriverInfo->devPrivate;

    return TRUE;
}

DRIInfoPtr
DRICreateInfoRec(void)
{
    DRIInfoPtr inforec = (DRIInfoPtr) calloc(1, sizeof(DRIInfoRec));

    if (!inforec)
        return NULL;

    /* Initialize defaults */
    inforec->busIdString = NULL;

    /* Wrapped function defaults */
    inforec->wrap.WakeupHandler = DRIDoWakeupHandler;
    inforec->wrap.BlockHandler = DRIDoBlockHandler;
    inforec->wrap.WindowExposures = DRIWindowExposures;
    inforec->wrap.CopyWindow = DRICopyWindow;
    inforec->wrap.ClipNotify = DRIClipNotify;
    inforec->wrap.AdjustFrame = DRIAdjustFrame;

    inforec->TransitionTo2d = 0;
    inforec->TransitionTo3d = 0;
    inforec->SetDrawableIndex = 0;

    return inforec;
}

void
DRIDestroyInfoRec(DRIInfoPtr DRIInfo)
{
    free(DRIInfo->busIdString);
    free((char *) DRIInfo);
}

void
DRIWakeupHandler(void *wakeupData, int result, void *pReadmask)
{
    int i;

    for (i = 0; i < screenInfo.numScreens; i++) {
        ScreenPtr pScreen = screenInfo.screens[i];
        DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

        if (pDRIPriv && pDRIPriv->pDriverInfo->wrap.WakeupHandler)
            (*pDRIPriv->pDriverInfo->wrap.WakeupHandler) (pScreen,
                                                          result, pReadmask);
    }
}

void
DRIBlockHandler(void *blockData, OSTimePtr pTimeout, void *pReadmask)
{
    int i;

    for (i = 0; i < screenInfo.numScreens; i++) {
        ScreenPtr pScreen = screenInfo.screens[i];
        DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

        if (pDRIPriv && pDRIPriv->pDriverInfo->wrap.BlockHandler)
            (*pDRIPriv->pDriverInfo->wrap.BlockHandler) (pScreen,
                                                         pTimeout, pReadmask);
    }
}

void
DRIDoWakeupHandler(ScreenPtr pScreen,
                   unsigned long result, void *pReadmask)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    DRILock(pScreen, 0);
    if (pDRIPriv->pDriverInfo->driverSwapMethod == DRI_HIDE_X_CONTEXT) {
        /* hide X context by swapping 2D component here */
        (*pDRIPriv->pDriverInfo->SwapContext) (pScreen,
                                               DRI_3D_SYNC,
                                               DRI_2D_CONTEXT,
                                               pDRIPriv->partial3DContextStore,
                                               DRI_2D_CONTEXT,
                                               pDRIPriv->hiddenContextStore);
    }
}

void
DRIDoBlockHandler(ScreenPtr pScreen,
                  void *pTimeout, void *pReadmask)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (pDRIPriv->pDriverInfo->driverSwapMethod == DRI_HIDE_X_CONTEXT) {
        /* hide X context by swapping 2D component here */
        (*pDRIPriv->pDriverInfo->SwapContext) (pScreen,
                                               DRI_2D_SYNC,
                                               DRI_NO_CONTEXT,
                                               NULL,
                                               DRI_2D_CONTEXT,
                                               pDRIPriv->partial3DContextStore);
    }

    if (pDRIPriv->windowsTouched)
        DRM_SPINUNLOCK(&pDRIPriv->pSAREA->drawable_lock, 1);
    pDRIPriv->windowsTouched = FALSE;

    DRIUnlock(pScreen);
}

void
DRISwapContext(int drmFD, void *oldctx, void *newctx)
{
    DRIContextPrivPtr oldContext = (DRIContextPrivPtr) oldctx;
    DRIContextPrivPtr newContext = (DRIContextPrivPtr) newctx;
    ScreenPtr pScreen = newContext->pScreen;
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    void *oldContextStore = NULL;
    DRIContextType oldContextType;
    void *newContextStore = NULL;
    DRIContextType newContextType;
    DRISyncType syncType;

#ifdef DEBUG
    static int count = 0;

    if (!newContext) {
        DRIDrvMsg(pScreen->myNum, X_ERROR,
                  "[DRI] Context Switch Error: oldContext=%p, newContext=%p\n",
                  oldContext, newContext);
        return;
    }

    /* usefull for debugging, just print out after n context switches */
    if (!count || !(count % 1)) {
        DRIDrvMsg(pScreen->myNum, X_INFO,
                  "[DRI] Context switch %5d from %p/0x%08x (%d)\n",
                  count,
                  oldContext,
                  oldContext ? oldContext->flags : 0,
                  oldContext ? oldContext->hwContext : -1);
        DRIDrvMsg(pScreen->myNum, X_INFO,
                  "[DRI] Context switch %5d to   %p/0x%08x (%d)\n",
                  count,
                  newContext,
                  newContext ? newContext->flags : 0,
                  newContext ? newContext->hwContext : -1);
    }
    ++count;
#endif

    if (!pDRIPriv->pDriverInfo->SwapContext) {
        DRIDrvMsg(pScreen->myNum, X_ERROR,
                  "[DRI] DDX driver missing context swap call back\n");
        return;
    }

    if (pDRIPriv->pDriverInfo->driverSwapMethod == DRI_HIDE_X_CONTEXT) {

        /* only 3D contexts are swapped in this case */
        if (oldContext) {
            oldContextStore = DRIGetContextStore(oldContext);
            oldContext->valid3D = TRUE;
            oldContextType = DRI_3D_CONTEXT;
        }
        else {
            oldContextType = DRI_NO_CONTEXT;
        }
        newContextStore = DRIGetContextStore(newContext);
        if ((newContext->valid3D) &&
            (newContext->hwContext != pDRIPriv->myContext)) {
            newContextType = DRI_3D_CONTEXT;
        }
        else {
            newContextType = DRI_2D_CONTEXT;
        }
        syncType = DRI_3D_SYNC;
    }
    else {                      /* default: driverSwapMethod == DRI_SERVER_SWAP */

        /* optimize 2D context swaps */

        if (newContext->flags & DRI_CONTEXT_2DONLY) {
            /* go from 3D context to 2D context and only save 2D
             * subset of 3D state
             */
            oldContextStore = DRIGetContextStore(oldContext);
            oldContextType = DRI_2D_CONTEXT;
            newContextStore = DRIGetContextStore(newContext);
            newContextType = DRI_2D_CONTEXT;
            syncType = DRI_3D_SYNC;
            pDRIPriv->lastPartial3DContext = oldContext;
        }
        else if (oldContext->flags & DRI_CONTEXT_2DONLY) {
            if (pDRIPriv->lastPartial3DContext == newContext) {
                /* go from 2D context back to previous 3D context and
                 * only restore 2D subset of previous 3D state
                 */
                oldContextStore = DRIGetContextStore(oldContext);
                oldContextType = DRI_2D_CONTEXT;
                newContextStore = DRIGetContextStore(newContext);
                newContextType = DRI_2D_CONTEXT;
                syncType = DRI_2D_SYNC;
            }
            else {
                /* go from 2D context to a different 3D context */

                /* call DDX driver to do partial restore */
                oldContextStore = DRIGetContextStore(oldContext);
                newContextStore =
                    DRIGetContextStore(pDRIPriv->lastPartial3DContext);
                (*pDRIPriv->pDriverInfo->SwapContext) (pScreen,
                                                       DRI_2D_SYNC,
                                                       DRI_2D_CONTEXT,
                                                       oldContextStore,
                                                       DRI_2D_CONTEXT,
                                                       newContextStore);

                /* now setup for a complete 3D swap */
                oldContextStore = newContextStore;
                oldContext->valid3D = TRUE;
                oldContextType = DRI_3D_CONTEXT;
                newContextStore = DRIGetContextStore(newContext);
                if ((newContext->valid3D) &&
                    (newContext->hwContext != pDRIPriv->myContext)) {
                    newContextType = DRI_3D_CONTEXT;
                }
                else {
                    newContextType = DRI_2D_CONTEXT;
                }
                syncType = DRI_NO_SYNC;
            }
        }
        else {
            /* now setup for a complete 3D swap */
            oldContextStore = newContextStore;
            oldContext->valid3D = TRUE;
            oldContextType = DRI_3D_CONTEXT;
            newContextStore = DRIGetContextStore(newContext);
            if ((newContext->valid3D) &&
                (newContext->hwContext != pDRIPriv->myContext)) {
                newContextType = DRI_3D_CONTEXT;
            }
            else {
                newContextType = DRI_2D_CONTEXT;
            }
            syncType = DRI_3D_SYNC;
        }
    }

    /* call DDX driver to perform the swap */
    (*pDRIPriv->pDriverInfo->SwapContext) (pScreen,
                                           syncType,
                                           oldContextType,
                                           oldContextStore,
                                           newContextType, newContextStore);
}

void *
DRIGetContextStore(DRIContextPrivPtr context)
{
    return ((void *) context->pContextStore);
}

void
DRIWindowExposures(WindowPtr pWin, RegionPtr prgn)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIDrawablePrivPtr pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);

    if (pDRIDrawablePriv) {
        (*pDRIPriv->pDriverInfo->InitBuffers) (pWin, prgn,
                                               pDRIDrawablePriv->drawableIndex);
    }

    /* call lower wrapped functions */
    if (pDRIPriv && pDRIPriv->wrap.WindowExposures) {

        /* unwrap */
        pScreen->WindowExposures = pDRIPriv->wrap.WindowExposures;

        /* call lower layers */
        (*pScreen->WindowExposures) (pWin, prgn);

        /* rewrap */
        pDRIPriv->wrap.WindowExposures = pScreen->WindowExposures;
        pScreen->WindowExposures = DRIWindowExposures;
    }
}

static int
DRITreeTraversal(WindowPtr pWin, void *data)
{
    DRIDrawablePrivPtr pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);

    if (pDRIDrawablePriv) {
        ScreenPtr pScreen = pWin->drawable.pScreen;
        DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

        if (RegionNumRects(&(pWin->clipList)) > 0) {
            RegionPtr reg = (RegionPtr) data;

            RegionUnion(reg, reg, &(pWin->clipList));
            pDRIPriv->nrWalked++;
        }

        if (pDRIPriv->nrWindows == pDRIPriv->nrWalked)
            return WT_STOPWALKING;
    }
    return WT_WALKCHILDREN;
}

Bool
DRIDestroyWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    Bool retval = TRUE;

    DRIDrawablePrivDestroy(pWin);

    /* call lower wrapped functions */
    if (pDRIPriv->DestroyWindow) {
        /* unwrap */
        pScreen->DestroyWindow = pDRIPriv->DestroyWindow;

        /* call lower layers */
        retval = (*pScreen->DestroyWindow) (pWin);

        /* rewrap */
        pDRIPriv->DestroyWindow = pScreen->DestroyWindow;
        pScreen->DestroyWindow = DRIDestroyWindow;
    }

    return retval;
}

void
DRICopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (!pDRIPriv)
        return;

    if (pDRIPriv->nrWindowsVisible > 0) {
        RegionRec reg;

        RegionNull(&reg);
        pDRIPriv->nrWalked = 0;
        TraverseTree(pWin, DRITreeTraversal, (void *) (&reg));

        if (RegionNotEmpty(&reg)) {
            RegionTranslate(&reg, ptOldOrg.x - pWin->drawable.x,
                            ptOldOrg.y - pWin->drawable.y);
            RegionIntersect(&reg, &reg, prgnSrc);

            /* The MoveBuffers interface is not ideal */
            (*pDRIPriv->pDriverInfo->MoveBuffers) (pWin, ptOldOrg, &reg,
                                                   pDRIPriv->pDriverInfo->
                                                   ddxDrawableTableEntry);
        }

        RegionUninit(&reg);
    }

    /* call lower wrapped functions */
    if (pDRIPriv->wrap.CopyWindow) {
        /* unwrap */
        pScreen->CopyWindow = pDRIPriv->wrap.CopyWindow;

        /* call lower layers */
        (*pScreen->CopyWindow) (pWin, ptOldOrg, prgnSrc);

        /* rewrap */
        pDRIPriv->wrap.CopyWindow = pScreen->CopyWindow;
        pScreen->CopyWindow = DRICopyWindow;
    }
}

static void
DRIGetSecs(long *secs, long *usecs)
{
    struct timeval tv;

    gettimeofday(&tv, NULL);

    *secs = tv.tv_sec;
    *usecs = tv.tv_usec;
}

static unsigned long
DRIComputeMilliSeconds(unsigned long s_secs, unsigned long s_usecs,
                       unsigned long f_secs, unsigned long f_usecs)
{
    if (f_usecs < s_usecs) {
        --f_secs;
        f_usecs += 1000000;
    }
    return (f_secs - s_secs) * 1000 + (f_usecs - s_usecs) / 1000;
}

static void
DRISpinLockTimeout(drmLock * lock, int val, unsigned long timeout /* in mS */ )
{
    int count = 10000;

#if !defined(__alpha__) && !defined(__powerpc__)
    char ret;
#else
    int ret;
#endif
    long s_secs, s_usecs;
    long f_secs, f_usecs;
    long msecs;
    long prev = 0;

    DRIGetSecs(&s_secs, &s_usecs);

    do {
        DRM_SPINLOCK_COUNT(lock, val, count, ret);
        if (!ret)
            return;             /* Got lock */
        DRIGetSecs(&f_secs, &f_usecs);
        msecs = DRIComputeMilliSeconds(s_secs, s_usecs, f_secs, f_usecs);
        if (msecs - prev < 250)
            count *= 2;         /* Not more than 0.5S */
    } while (msecs < timeout);

    /* Didn't get lock, so take it.  The worst
       that can happen is that there is some
       garbage written to the wrong part of the
       framebuffer that a refresh will repair.
       That's undesirable, but better than
       locking the server.  This should be a
       very rare event. */
    DRM_SPINLOCK_TAKE(lock, val);
}

static void
DRILockTree(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (!pDRIPriv)
        return;

    /* Restore the last known 3D context if the X context is hidden */
    if (pDRIPriv->pDriverInfo->driverSwapMethod == DRI_HIDE_X_CONTEXT) {
        (*pDRIPriv->pDriverInfo->SwapContext) (pScreen,
                                               DRI_2D_SYNC,
                                               DRI_NO_CONTEXT,
                                               NULL,
                                               DRI_2D_CONTEXT,
                                               pDRIPriv->partial3DContextStore);
    }

    /* Call kernel to release lock */
    DRIUnlock(pScreen);

    /* Grab drawable spin lock: a time out between 10 and 30 seconds is
       appropriate, since this should never time out except in the case of
       client death while the lock is being held.  The timeout must be
       greater than any reasonable rendering time. */
    DRISpinLockTimeout(&pDRIPriv->pSAREA->drawable_lock, 1, 10000);     /*10 secs */

    /* Call kernel flush outstanding buffers and relock */
    DRILock(pScreen, DRM_LOCK_QUIESCENT | DRM_LOCK_FLUSH_ALL);

    /* Switch back to our 2D context if the X context is hidden */
    if (pDRIPriv->pDriverInfo->driverSwapMethod == DRI_HIDE_X_CONTEXT) {
        /* hide X context by swapping 2D component here */
        (*pDRIPriv->pDriverInfo->SwapContext) (pScreen,
                                               DRI_3D_SYNC,
                                               DRI_2D_CONTEXT,
                                               pDRIPriv->partial3DContextStore,
                                               DRI_2D_CONTEXT,
                                               pDRIPriv->hiddenContextStore);
    }
}

void
DRIClipNotify(WindowPtr pWin, int dx, int dy)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIDrawablePrivPtr pDRIDrawablePriv;

    if (!pDRIPriv)
        return;

    if ((pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin))) {
        int nrects = RegionNumRects(&pWin->clipList);

        if (!pDRIPriv->windowsTouched) {
            DRILockTree(pScreen);
            pDRIPriv->windowsTouched = TRUE;
        }

        if (nrects && !pDRIDrawablePriv->nrects)
            DRIIncreaseNumberVisible(pScreen);
        else if (!nrects && pDRIDrawablePriv->nrects)
            DRIDecreaseNumberVisible(pScreen);
        else
            DRIDriverClipNotify(pScreen);

        pDRIDrawablePriv->nrects = nrects;

        pDRIPriv->pSAREA->drawableTable[pDRIDrawablePriv->drawableIndex].stamp
            = DRIDrawableValidationStamp++;

        drmUpdateDrawableInfo(pDRIPriv->drmFD, pDRIDrawablePriv->hwDrawable,
                              DRM_DRAWABLE_CLIPRECTS,
                              nrects, RegionRects(&pWin->clipList));
    }

    /* call lower wrapped functions */
    if (pDRIPriv->wrap.ClipNotify) {

        /* unwrap */
        pScreen->ClipNotify = pDRIPriv->wrap.ClipNotify;

        /* call lower layers */
        (*pScreen->ClipNotify) (pWin, dx, dy);

        /* rewrap */
        pDRIPriv->wrap.ClipNotify = pScreen->ClipNotify;
        pScreen->ClipNotify = DRIClipNotify;
    }
}

CARD32
DRIGetDrawableIndex(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIDrawablePrivPtr pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
    CARD32 index;

    if (pDRIDrawablePriv) {
        index = pDRIDrawablePriv->drawableIndex;
    }
    else {
        index = pDRIPriv->pDriverInfo->ddxDrawableTableEntry;
    }

    return index;
}

unsigned int
DRIGetDrawableStamp(ScreenPtr pScreen, CARD32 drawable_index)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    return pDRIPriv->pSAREA->drawableTable[drawable_index].stamp;
}

void
DRIPrintDrawableLock(ScreenPtr pScreen, char *msg)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    ErrorF("%s: %d\n", msg, pDRIPriv->pSAREA->drawable_lock.lock);
}

void
DRILock(ScreenPtr pScreen, int flags)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (!pDRIPriv || !pDRIPriv->pLockRefCount)
        return;

    if (!*pDRIPriv->pLockRefCount) {
        DRM_LOCK(pDRIPriv->drmFD, pDRIPriv->pLSAREA, pDRIPriv->myContext,
                 flags);
        *pDRIPriv->pLockingContext = pDRIPriv->myContext;
    }
    else if (*pDRIPriv->pLockingContext != pDRIPriv->myContext) {
        DRIDrvMsg(pScreen->myNum, X_ERROR,
                  "[DRI] Locking deadlock.\n"
                  "\tAlready locked with context %p,\n"
                  "\ttrying to lock with context %p.\n",
                  pDRIPriv->pLockingContext, (void *) (uintptr_t) pDRIPriv->myContext);
    }
    (*pDRIPriv->pLockRefCount)++;
}

void
DRIUnlock(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (!pDRIPriv || !pDRIPriv->pLockRefCount)
        return;

    if (*pDRIPriv->pLockRefCount > 0) {
        if (pDRIPriv->myContext != *pDRIPriv->pLockingContext) {
            DRIDrvMsg(pScreen->myNum, X_ERROR,
                      "[DRI] Unlocking inconsistency:\n"
                      "\tContext %p trying to unlock lock held by context %p\n",
                      pDRIPriv->pLockingContext, (void *) (uintptr_t) pDRIPriv->myContext);
        }
        (*pDRIPriv->pLockRefCount)--;
    }
    else {
        DRIDrvMsg(pScreen->myNum, X_ERROR,
                  "DRIUnlock called when not locked.\n");
        return;
    }
    if (!*pDRIPriv->pLockRefCount)
        DRM_UNLOCK(pDRIPriv->drmFD, pDRIPriv->pLSAREA, pDRIPriv->myContext);
}

void *
DRIGetSAREAPrivate(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (!pDRIPriv)
        return 0;

    return (void *) (((char *) pDRIPriv->pSAREA) + sizeof(XF86DRISAREARec));
}

drm_context_t
DRIGetContext(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (!pDRIPriv)
        return 0;

    return pDRIPriv->myContext;
}

void
DRIGetTexOffsetFuncs(ScreenPtr pScreen,
                     DRITexOffsetStartProcPtr * texOffsetStartFunc,
                     DRITexOffsetFinishProcPtr * texOffsetFinishFunc)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (!pDRIPriv)
        return;

    *texOffsetStartFunc = pDRIPriv->pDriverInfo->texOffsetStart;
    *texOffsetFinishFunc = pDRIPriv->pDriverInfo->texOffsetFinish;
}

/* This lets get at the unwrapped functions so that they can correctly
 * call the lowerlevel functions, and choose whether they will be
 * called at every level of recursion (eg in validatetree).
 */
DRIWrappedFuncsRec *
DRIGetWrappedFuncs(ScreenPtr pScreen)
{
    return &(DRI_SCREEN_PRIV(pScreen)->wrap);
}

/* note that this returns the library version, not the protocol version */
void
DRIQueryVersion(int *majorVersion, int *minorVersion, int *patchVersion)
{
    *majorVersion = DRIINFO_MAJOR_VERSION;
    *minorVersion = DRIINFO_MINOR_VERSION;
    *patchVersion = DRIINFO_PATCH_VERSION;
}

static void
_DRIAdjustFrame(ScrnInfoPtr pScrn, DRIScreenPrivPtr pDRIPriv, int x, int y)
{
    pDRIPriv->pSAREA->frame.x = x;
    pDRIPriv->pSAREA->frame.y = y;
    pDRIPriv->pSAREA->frame.width = pScrn->frameX1 - x + 1;
    pDRIPriv->pSAREA->frame.height = pScrn->frameY1 - y + 1;
}

void
DRIAdjustFrame(ScrnInfoPtr pScrn, int x, int y)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    int px, py;

    if (!pDRIPriv || !pDRIPriv->pSAREA) {
        DRIDrvMsg(pScrn->scrnIndex, X_ERROR, "[DRI] No SAREA (%p %p)\n",
                  pDRIPriv, pDRIPriv ? pDRIPriv->pSAREA : NULL);
        return;
    }

    if (pDRIPriv->fullscreen) {
        /* Fix up frame */
        pScrn->frameX0 = pDRIPriv->pSAREA->frame.x;
        pScrn->frameY0 = pDRIPriv->pSAREA->frame.y;
        pScrn->frameX1 = pScrn->frameX0 + pDRIPriv->pSAREA->frame.width - 1;
        pScrn->frameY1 = pScrn->frameY0 + pDRIPriv->pSAREA->frame.height - 1;

        /* Fix up cursor */
        miPointerGetPosition(inputInfo.pointer, &px, &py);

        if (px < pScrn->frameX0)
            px = pScrn->frameX0;
        if (px > pScrn->frameX1)
            px = pScrn->frameX1;
        if (py < pScrn->frameY0)
            py = pScrn->frameY0;
        if (py > pScrn->frameY1)
            py = pScrn->frameY1;
        pScreen->SetCursorPosition(inputInfo.pointer, pScreen, px, py, TRUE);

        return;
    }

    if (pDRIPriv->wrap.AdjustFrame) {
        /* unwrap */
        pScrn->AdjustFrame = pDRIPriv->wrap.AdjustFrame;
        /* call lower layers */
        (*pScrn->AdjustFrame) (pScrn, x, y);
        /* rewrap */
        pDRIPriv->wrap.AdjustFrame = pScrn->AdjustFrame;
        pScrn->AdjustFrame = DRIAdjustFrame;
    }

    _DRIAdjustFrame(pScrn, pDRIPriv, x, y);
}

/*
 * DRIMoveBuffersHelper swaps the regions rects in place leaving you
 * a region with the rects in the order that you need to blit them,
 * but it is possibly (likely) an invalid region afterwards.  If you
 * need to use the region again for anything you have to call
 * REGION_VALIDATE on it, or better yet, save a copy first.
 */

void
DRIMoveBuffersHelper(ScreenPtr pScreen,
                     int dx, int dy, int *xdir, int *ydir, RegionPtr reg)
{
    BoxPtr extents, pbox, firstBox, lastBox;
    BoxRec tmpBox;
    int y, nbox;

    extents = RegionExtents(reg);
    nbox = RegionNumRects(reg);
    pbox = RegionRects(reg);

    if ((dy > 0) && (dy < (extents->y2 - extents->y1))) {
        *ydir = -1;
        if (nbox > 1) {
            firstBox = pbox;
            lastBox = pbox + nbox - 1;
            while ((unsigned long) firstBox < (unsigned long) lastBox) {
                tmpBox = *firstBox;
                *firstBox = *lastBox;
                *lastBox = tmpBox;
                firstBox++;
                lastBox--;
            }
        }
    }
    else
        *ydir = 1;

    if ((dx > 0) && (dx < (extents->x2 - extents->x1))) {
        *xdir = -1;
        if (nbox > 1) {
            firstBox = lastBox = pbox;
            y = pbox->y1;
            while (--nbox) {
                pbox++;
                if (pbox->y1 == y)
                    lastBox++;
                else {
                    while ((unsigned long) firstBox < (unsigned long) lastBox) {
                        tmpBox = *firstBox;
                        *firstBox = *lastBox;
                        *lastBox = tmpBox;
                        firstBox++;
                        lastBox--;
                    }

                    firstBox = lastBox = pbox;
                    y = pbox->y1;
                }
            }
            while ((unsigned long) firstBox < (unsigned long) lastBox) {
                tmpBox = *firstBox;
                *firstBox = *lastBox;
                *lastBox = tmpBox;
                firstBox++;
                lastBox--;
            }
        }
    }
    else
        *xdir = 1;

}

char *
DRICreatePCIBusID(const struct pci_device *dev)
{
    char *busID;

    if (asprintf(&busID, "pci:%04x:%02x:%02x.%d",
                 dev->domain, dev->bus, dev->dev, dev->func) == -1)
        return NULL;

    return busID;
}
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d1010 2
a1011 1
    AddResource(context, DRIContextPrivResType, (void *) pDRIContextPriv);
d1242 3
a1244 2
        AddResource(FakeClientID(client->index), DRIDrawablePrivResType,
                    (void *) (intptr_t) pDrawable->id);
d1671 1
a1671 1
                  "[DRI] Context Switch Error: oldContext=%x, newContext=%x\n",
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a579 8
    if (pDRIInfo->wrap.ValidateTree) {
        pDRIPriv->wrap.ValidateTree = pScreen->ValidateTree;
        pScreen->ValidateTree = pDRIInfo->wrap.ValidateTree;
    }
    if (pDRIInfo->wrap.PostValidateTree) {
        pDRIPriv->wrap.PostValidateTree = pScreen->PostValidateTree;
        pScreen->PostValidateTree = pDRIInfo->wrap.PostValidateTree;
    }
a628 8
            if (pDRIInfo->wrap.ValidateTree) {
                pScreen->ValidateTree = pDRIPriv->wrap.ValidateTree;
                pDRIPriv->wrap.ValidateTree = NULL;
            }
            if (pDRIInfo->wrap.PostValidateTree) {
                pScreen->PostValidateTree = pDRIPriv->wrap.PostValidateTree;
                pDRIPriv->wrap.PostValidateTree = NULL;
            }
a1562 2
    inforec->wrap.ValidateTree = DRIValidateTree;
    inforec->wrap.PostValidateTree = DRIPostValidateTree;
d1806 1
a1806 1
DRIWindowExposures(WindowPtr pWin, RegionPtr prgn, RegionPtr bsreg)
d1824 1
a1824 1
        (*pScreen->WindowExposures) (pWin, prgn, bsreg);
a2023 55
int
DRIValidateTree(WindowPtr pParent, WindowPtr pChild, VTKind kind)
{
    ScreenPtr pScreen = pParent->drawable.pScreen;
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    int returnValue = 1;        /* always return 1, not checked by dix/window.c */

    if (!pDRIPriv)
        return returnValue;

    /* call lower wrapped functions */
    if (pDRIPriv->wrap.ValidateTree) {
        /* unwrap */
        pScreen->ValidateTree = pDRIPriv->wrap.ValidateTree;

        /* call lower layers */
        returnValue = (*pScreen->ValidateTree) (pParent, pChild, kind);

        /* rewrap */
        pDRIPriv->wrap.ValidateTree = pScreen->ValidateTree;
        pScreen->ValidateTree = DRIValidateTree;
    }

    return returnValue;
}

void
DRIPostValidateTree(WindowPtr pParent, WindowPtr pChild, VTKind kind)
{
    ScreenPtr pScreen;
    DRIScreenPrivPtr pDRIPriv;

    if (pParent) {
        pScreen = pParent->drawable.pScreen;
    }
    else {
        pScreen = pChild->drawable.pScreen;
    }
    if (!(pDRIPriv = DRI_SCREEN_PRIV(pScreen)))
        return;

    if (pDRIPriv->wrap.PostValidateTree) {
        /* unwrap */
        pScreen->PostValidateTree = pDRIPriv->wrap.PostValidateTree;

        /* call lower layers */
        (*pScreen->PostValidateTree) (pParent, pChild, kind);

        /* rewrap */
        pDRIPriv->wrap.PostValidateTree = pScreen->PostValidateTree;
        pScreen->PostValidateTree = DRIPostValidateTree;
    }
}

d2270 1
a2270 1
/* 
d2274 1
a2274 1
 * need to use the region again for anything you have to call 
@


1.10
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d103 5
a179 2
     * drmGetLibVersion was not supported in version 1.0, so check for
     * symbol first to avoid possible crash or hang.
d184 5
a188 7
    if (xf86LoaderCheckSymbol("drmGetLibVersion")) {
        drmlibv = drmGetLibVersion(-1);
        if (drmlibv != NULL) {
            drmlibmajor = drmlibv->version_major;
            drmlibminor = drmlibv->version_minor;
            drmFreeVersion(drmlibv);
        }
d403 1
a403 1
                  pDRIPriv->pDriverInfo->SAREASize, pDRIPriv->hSAREA);
d417 1
a417 1
                  pDRIPriv->hSAREA, pDRIPriv->pSAREA);
d445 1
a445 1
                  pDRIPriv->pDriverInfo->hFrameBuffer);
d458 1
a458 1
            int i;
d461 1
a461 1
            for (i = 0; i < reserved_count; i++) {
d463 1
a463 1
                                                     reserved[i],
d465 1
a465 1
                drmAddContextTag(pDRIPriv->drmFD, reserved[i], tag);
d516 1
a516 1
              "X context handle = %p\n", pDRIPriv->myContext);
d665 1
a665 1
                ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
d667 1
a667 1
                pScrn->AdjustFrame = pDRIPriv->wrap.AdjustFrame;
d710 1
a710 1
                      pDRIInfo->SAREASize, pDRIPriv->hSAREA, pDRIPriv->pSAREA);
d715 2
a716 2
                          pDRIInfo->SAREASize,
                          pDRIPriv->hSAREA, pDRIPriv->pSAREA);
d740 4
d1026 1
a1026 1
    AddResource(context, DRIContextPrivResType, (pointer) pDRIContextPriv);
d1041 1
a1041 1
DRIContextPrivDelete(pointer pResource, XID id)
d1124 1
a1124 1
DRIDCNTreeTraversal(WindowPtr pWin, pointer data)
d1163 1
a1163 1
                         (pointer) pDRIWindows);
d1258 1
a1258 1
                    (pointer) (intptr_t) pDrawable->id);
d1311 1
a1311 1
DRIDestroyDrawableCB(pointer value, XID id, pointer data)
d1329 1
a1329 1
                                    (pointer) (intptr_t) pDrawable->id);
d1340 1
a1340 1
DRIDrawablePrivDelete(pointer pResource, XID id)
d1599 1
a1599 1
DRIWakeupHandler(pointer wakeupData, int result, pointer pReadmask)
d1614 1
a1614 1
DRIBlockHandler(pointer blockData, OSTimePtr pTimeout, pointer pReadmask)
d1630 1
a1630 1
                   unsigned long result, pointer pReadmask)
d1648 1
a1648 1
                  pointer pTimeout, pointer pReadmask)
d1851 1
a1851 1
DRITreeTraversal(WindowPtr pWin, pointer data)
d1911 1
a1911 1
        TraverseTree(pWin, DRITreeTraversal, (pointer) (&reg));
d2197 3
a2199 3
                  "\tAlready locked with context %d,\n"
                  "\ttrying to lock with context %d.\n",
                  pDRIPriv->pLockingContext, pDRIPriv->myContext);
d2216 2
a2217 2
                      "\tContext %d trying to unlock lock held by context %d\n",
                      pDRIPriv->pLockingContext, pDRIPriv->myContext);
@


1.9
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d54 1
d72 1
d320 1
a320 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d323 1
d349 4
d607 1
a607 1
        ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d626 1
a626 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d664 1
a664 1
                ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1603 1
a1603 1
            (*pDRIPriv->pDriverInfo->wrap.WakeupHandler) (i, wakeupData,
d1618 1
a1618 1
            (*pDRIPriv->pDriverInfo->wrap.BlockHandler) (i, blockData,
d1624 1
a1624 1
DRIDoWakeupHandler(int screenNum, pointer wakeupData,
a1626 1
    ScreenPtr pScreen = screenInfo.screens[screenNum];
d1642 1
a1642 1
DRIDoBlockHandler(int screenNum, pointer blockData,
a1644 1
    ScreenPtr pScreen = screenInfo.screens[screenNum];
d2290 1
a2290 1
DRIAdjustFrame(int scrnIndex, int x, int y, int flags)
d2292 1
a2292 1
    ScreenPtr pScreen = screenInfo.screens[scrnIndex];
a2293 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d2297 1
a2297 1
        DRIDrvMsg(scrnIndex, X_ERROR, "[DRI] No SAREA (%p %p)\n",
d2329 1
a2329 1
        (*pScrn->AdjustFrame) (scrnIndex, x, y, flags);
@


1.8
log
@Update to xserver 1.11.2
@
text
@d74 1
d77 1
d84 1
a84 1
static void    DRIDestroyDummyContext(ScreenPtr pScreen, Bool hasCtxPriv);
d88 5
a92 5
				/* Wrapper just like xf86DrvMsg, but
				   without the verbosity level checking.
				   This will make it easy to turn off some
				   messages later, based on verbosity
				   level. */
d104 1
a104 1
    va_list     ap;
a110 1

d115 2
a116 2
	drmUnmap(pDRIEntPriv->pLSAREA, pDRIEntPriv->sAreaSize);
	pDRIEntPriv->pLSAREA = NULL;
d119 1
a119 1
	drmRmMap(pDRIEntPriv->drmFD, pDRIEntPriv->hLSAREA);
d122 2
a123 2
	drmClose(pDRIEntPriv->drmFD);
	pDRIEntPriv->drmFD = 0;
a144 1

d147 2
a148 3
		 unsigned long sAreaSize,
		 const char *busID,
		 const char *drmDriverName)
d161 1
a161 1
	DRIEntPrivIndex = xf86AllocateEntityPrivateIndex();
d166 1
a166 1
	return TRUE;
d180 6
a185 6
	drmlibv = drmGetLibVersion(-1);
	if (drmlibv != NULL) {
	    drmlibmajor = drmlibv->version_major;
	    drmlibminor = drmlibv->version_minor;
	    drmFreeVersion(drmlibv);
	}
d201 1
a201 1
	tmp.drmFD = drmOpen(drmDriverName, openBusID);
d203 14
a216 14
	if (tmp.drmFD < 0) {
	    DRIDrvMsg(-1, X_ERROR, "[drm] drmOpen failed.\n");
	    goto out_err;
	}

	err = drmSetInterfaceVersion(tmp.drmFD, &sv);

	if (err != -EPERM)
	    break;

	sv = saveSv;
	drmClose(tmp.drmFD);
	tmp.drmFD = -1;
	usleep(100000);
d220 2
a221 2
	DRIDrvMsg(-1, X_ERROR, "[drm] DRM was busy with another master.\n");
	goto out_err;
d225 3
a227 3
	DRIDrvMsg(-1, X_INFO,
		  "[drm] loaded kernel module for \"%s\" driver.\n",
		  drmDriverName);
d231 2
a232 2
	sv.drm_di_major = 1;
	sv.drm_di_minor = 0;
d236 1
a236 1
	      sv.drm_di_major, sv.drm_di_minor);
d239 1
a239 1
	err = 0;
d241 1
a241 1
	err = drmSetBusid(tmp.drmFD, busID);
d244 2
a245 2
	DRIDrvMsg(-1, X_ERROR, "[drm] Could not set DRM device bus ID.\n");
	goto out_err;
d252 2
a253 2
    if (drmAddMap( tmp.drmFD, 0, sAreaSize, DRM_SHM,
		   DRM_CONTAINS_LOCK, &tmp.hLSAREA) < 0) {
d255 2
a256 2
	tmp.hLSAREA = 0;
	goto out_err;
d259 2
a260 2
    if (drmMap( tmp.drmFD, tmp.hLSAREA, sAreaSize,
		(drmAddressPtr)(&tmp.pLSAREA)) < 0) {
d262 2
a263 2
	tmp.pLSAREA = NULL;
	goto out_err;
d275 1
a275 1
	pDRIEntPriv = xnfcalloc(sizeof(*pDRIEntPriv), 1);
d279 2
a280 2
		  "DRM device.\n");
	goto out_err;
d283 2
a284 2
    xf86GetEntityPrivate((pScrn)->entityList[0],DRIEntPrivIndex)->ptr =
	pDRIEntPriv;
d289 1
a289 1
  out_err:
d296 1
a296 1
DRIClipNotifyAllDrawables(ScreenPtr pScreen);
d301 2
a302 1
    DRIScreenPrivPtr  pDRIPriv = DRI_SCREEN_PRIV(pScreen);
d306 2
a307 1
    pDRIPriv->xf86_crtc_notify = xf86_wrap_crtc_notify(pScreen, dri_crtc_notify);
d313 8
a320 8
    DRIScreenPrivPtr    pDRIPriv;
    drm_context_t *       reserved;
    int                 reserved_count;
    int                 i;
    DRIEntPrivPtr       pDRIEntPriv;
    ScrnInfoPtr         pScrn = xf86Screens[pScreen->myNum];
    DRIContextFlags	flags    = 0;
    DRIContextPrivPtr	pDRIContextPriv;
d324 3
a326 3
	DRIDrvMsg(pScreen->myNum, X_WARNING,
		  "Direct rendering has been disabled.\n");
	return FALSE;
d332 1
a332 1
	return FALSE;
d340 5
a344 5
	if (!noPanoramiXExtension) {
	    DRIDrvMsg(pScreen->myNum, X_WARNING,
		"Direct rendering is not supported when Xinerama is enabled\n");
	    return FALSE;
	}
d348 2
a349 3
			  pDRIInfo->busIdString,
			  pDRIInfo->drmDriverName))
	return FALSE;
d354 1
a354 1
	DRIGeneration = serverGeneration;
d357 1
a357 1
	return FALSE;
d359 1
a359 1
	return FALSE;
d363 1
a363 1
	dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, NULL);
d375 1
a375 1
    pDRIPriv->createDummyCtx     = pDRIInfo->createDummyCtx;
d383 35
a417 40
	if (drmAddMap( pDRIPriv->drmFD,
		       0,
		       pDRIPriv->pDriverInfo->SAREASize,
		       DRM_SHM,
		       0,
		       &pDRIPriv->hSAREA) < 0)
	{
	    pDRIPriv->directRenderingSupport = FALSE;
	    dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, NULL);
	    drmClose(pDRIPriv->drmFD);
	    DRIDrvMsg(pScreen->myNum, X_INFO,
		      "[drm] drmAddMap failed\n");
	    return FALSE;
	}
	DRIDrvMsg(pScreen->myNum, X_INFO,
		  "[drm] added %d byte SAREA at %p\n",
		  pDRIPriv->pDriverInfo->SAREASize, pDRIPriv->hSAREA);

	/* Backwards compat. */
	if (drmMap( pDRIPriv->drmFD,
		    pDRIPriv->hSAREA,
		    pDRIPriv->pDriverInfo->SAREASize,
		    (drmAddressPtr)(&pDRIPriv->pSAREA)) < 0)
	{
	    pDRIPriv->directRenderingSupport = FALSE;
	    dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, NULL);
	    drmClose(pDRIPriv->drmFD);
	    DRIDrvMsg(pScreen->myNum, X_INFO,
		      "[drm] drmMap failed\n");
	    return FALSE;
	}
	DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] mapped SAREA %p to %p\n",
		  pDRIPriv->hSAREA, pDRIPriv->pSAREA);
	memset(pDRIPriv->pSAREA, 0, pDRIPriv->pDriverInfo->SAREASize);
    } else {
	DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] Using the DRM lock "
		  "SAREA also for drawables.\n");
	pDRIPriv->hSAREA = pDRIEntPriv->hLSAREA;
	pDRIPriv->pSAREA = (XF86DRISAREAPtr) pDRIEntPriv->pLSAREA;
	pDRIEntPriv->sAreaGrabbed = TRUE;
d423 19
a441 22
    if (!pDRIPriv->pDriverInfo->dontMapFrameBuffer)
    {
	if (drmAddMap( pDRIPriv->drmFD,
		       (uintptr_t)pDRIPriv->pDriverInfo->frameBufferPhysicalAddress,
		       pDRIPriv->pDriverInfo->frameBufferSize,
		       DRM_FRAME_BUFFER,
		       0,
		       &pDRIPriv->pDriverInfo->hFrameBuffer) < 0)
	    {
		pDRIPriv->directRenderingSupport = FALSE;
		dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, NULL);
		drmUnmap(pDRIPriv->pSAREA, pDRIPriv->pDriverInfo->SAREASize);
		drmClose(pDRIPriv->drmFD);
		DRIDrvMsg(pScreen->myNum, X_INFO,
			  "[drm] drmAddMap failed\n");
		return FALSE;
	    }
	DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] framebuffer handle = %p\n",
		  pDRIPriv->pDriverInfo->hFrameBuffer);
    } else {
	DRIDrvMsg(pScreen->myNum, X_INFO,
		  "[drm] framebuffer mapped by ddx driver\n");
d445 1
a445 1
	pDRIEntPriv->resOwner = pScreen;
d447 17
a463 17
	/* Add tags for reserved contexts */
	if ((reserved = drmGetReservedContextList(pDRIPriv->drmFD,
						  &reserved_count))) {
	    int  i;
	    void *tag;

	    for (i = 0; i < reserved_count; i++) {
		tag = DRICreateContextPrivFromHandle(pScreen,
						     reserved[i],
						     DRI_CONTEXT_RESERVED);
		drmAddContextTag(pDRIPriv->drmFD, reserved[i], tag);
	    }
	    drmFreeReservedContextList(reserved);
	    DRIDrvMsg(pScreen->myNum, X_INFO,
		      "[drm] added %d reserved context%s for kernel\n",
		      reserved_count, reserved_count > 1 ? "s" : "");
	}
d469 3
a471 3
	    DRIDrvMsg(pScreen->myNum, X_ERROR,
		      "Invalid max drawable table size set by driver: %d\n",
		      pDRIPriv->pDriverInfo->maxDrawableTableEntry);
d475 4
a478 4
    for( i=0; i < pDRIPriv->pDriverInfo->maxDrawableTableEntry; i++) {
	pDRIPriv->DRIDrawables[i] = NULL;
	pDRIPriv->pSAREA->drawableTable[i].stamp = 0;
	pDRIPriv->pSAREA->drawableTable[i].flags = 0;
d485 1
a485 1
	pDRIEntPriv->keepFDOpen = pDRIInfo->keepFDOpen;
d492 2
a493 2
	flags = DRI_CONTEXT_2DONLY;
	break;
d495 2
a496 2
	flags = DRI_CONTEXT_PRESERVED;
	break;
d500 4
a503 5
						 &pDRIPriv->myContext,
						 flags))) {
	DRIDrvMsg(pScreen->myNum, X_ERROR,
		  "failed to create server context\n");
	return FALSE;
d508 1
a508 1
	      "X context handle = %p\n", pDRIPriv->myContext);
d517 1
a517 1
    pDRIPriv->hiddenContextStore    = NULL;
d520 1
a520 1
    switch(pDRIInfo->driverSwapMethod) {
d522 34
a555 36
	/* Server will handle 3D swaps, and hide 2D swaps from kernel.
	 * Register server context as a preserved context.
	 */

	/* allocate memory for hidden context store */
	pDRIPriv->hiddenContextStore
	    = (void *)calloc(1, pDRIInfo->contextSize);
	if (!pDRIPriv->hiddenContextStore) {
	    DRIDrvMsg(pScreen->myNum, X_ERROR,
		      "failed to allocate hidden context\n");
	    DRIDestroyContextPriv(pDRIContextPriv);
	    return FALSE;
	}

	/* allocate memory for partial 3D context store */
	pDRIPriv->partial3DContextStore
	    = (void *)calloc(1, pDRIInfo->contextSize);
	if (!pDRIPriv->partial3DContextStore) {
	    DRIDrvMsg(pScreen->myNum, X_ERROR,
		      "[DRI] failed to allocate partial 3D context\n");
	    free(pDRIPriv->hiddenContextStore);
	    DRIDestroyContextPriv(pDRIContextPriv);
	    return FALSE;
	}

	/* save initial context store */
	if (pDRIInfo->SwapContext) {
	    (*pDRIInfo->SwapContext)(
		pScreen,
		DRI_NO_SYNC,
		DRI_2D_CONTEXT,
		pDRIPriv->hiddenContextStore,
		DRI_NO_CONTEXT,
		NULL);
	}
	/* fall through */
d559 1
a559 1
	break;
d568 2
a569 2
    DRIScreenPrivPtr  pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIInfoPtr        pDRIInfo = pDRIPriv->pDriverInfo;
d573 2
a574 2
	pDRIPriv->wrap.ValidateTree     = pScreen->ValidateTree;
	pScreen->ValidateTree           = pDRIInfo->wrap.ValidateTree;
d577 2
a578 2
	pDRIPriv->wrap.PostValidateTree = pScreen->PostValidateTree;
	pScreen->PostValidateTree       = pDRIInfo->wrap.PostValidateTree;
d581 2
a582 2
	pDRIPriv->wrap.WindowExposures  = pScreen->WindowExposures;
	pScreen->WindowExposures        = pDRIInfo->wrap.WindowExposures;
d585 2
a586 2
    pDRIPriv->DestroyWindow             = pScreen->DestroyWindow;
    pScreen->DestroyWindow              = DRIDestroyWindow;
d589 2
a590 2
						       dri_crtc_notify);
						       
d592 2
a593 2
	pDRIPriv->wrap.CopyWindow       = pScreen->CopyWindow;
	pScreen->CopyWindow             = pDRIInfo->wrap.CopyWindow;
d596 2
a597 2
	pDRIPriv->wrap.ClipNotify       = pScreen->ClipNotify;
	pScreen->ClipNotify             = pDRIInfo->wrap.ClipNotify;
d600 4
a603 3
	ScrnInfoPtr pScrn               = xf86Screens[pScreen->myNum];
	pDRIPriv->wrap.AdjustFrame      = pScrn->AdjustFrame;
	pScrn->AdjustFrame              = pDRIInfo->wrap.AdjustFrame;
d616 5
a620 5
    DRIInfoPtr       pDRIInfo;
    drm_context_t *    reserved;
    int              reserved_count;
    ScrnInfoPtr      pScrn = xf86Screens[pScreen->myNum];
    DRIEntPrivPtr    pDRIEntPriv = DRI_ENT_PRIV(pScrn);
d627 38
a664 37
	if (pDRIPriv->wrapped) {
	    /* Unwrap DRI Functions */
	    if (pDRIInfo->wrap.ValidateTree) {
		pScreen->ValidateTree           = pDRIPriv->wrap.ValidateTree;
		pDRIPriv->wrap.ValidateTree     = NULL;
	    }
	    if (pDRIInfo->wrap.PostValidateTree) {
		pScreen->PostValidateTree       = pDRIPriv->wrap.PostValidateTree;
		pDRIPriv->wrap.PostValidateTree = NULL;
	    }
	    if (pDRIInfo->wrap.WindowExposures) {
		pScreen->WindowExposures        = pDRIPriv->wrap.WindowExposures;
		pDRIPriv->wrap.WindowExposures  = NULL;
	    }
	    if (pDRIPriv->DestroyWindow) {
		pScreen->DestroyWindow          = pDRIPriv->DestroyWindow;
		pDRIPriv->DestroyWindow         = NULL;
	    }

	    xf86_unwrap_crtc_notify(pScreen, pDRIPriv->xf86_crtc_notify);

	    if (pDRIInfo->wrap.CopyWindow) {
		pScreen->CopyWindow             = pDRIPriv->wrap.CopyWindow;
		pDRIPriv->wrap.CopyWindow       = NULL;
	    }
	    if (pDRIInfo->wrap.ClipNotify) {
		pScreen->ClipNotify             = pDRIPriv->wrap.ClipNotify;
		pDRIPriv->wrap.ClipNotify       = NULL;
	    }
	    if (pDRIInfo->wrap.AdjustFrame) {
		ScrnInfoPtr pScrn               = xf86Screens[pScreen->myNum];
		pScrn->AdjustFrame              = pDRIPriv->wrap.AdjustFrame;
		pDRIPriv->wrap.AdjustFrame      = NULL;
	    }
	    
	    pDRIPriv->wrapped = FALSE;
	}
d667 7
a673 2
	    DRIDestroyDummyContext(pScreen, pDRIPriv->createDummyCtxPriv);
	}
d675 47
a721 55
	if (!DRIDestroyContextPriv(pDRIPriv->myContextPriv)) {
	    DRIDrvMsg(pScreen->myNum, X_ERROR,
		      "failed to destroy server context\n");
	}

				/* Remove tags for reserved contexts */
	if (pDRIEntPriv->resOwner == pScreen) {
	    pDRIEntPriv->resOwner = NULL;

	    if ((reserved = drmGetReservedContextList(pDRIPriv->drmFD,
						  &reserved_count))) {
		int  i;

		for (i = 0; i < reserved_count; i++) {
		    DRIDestroyContextPriv(drmGetContextTag(pDRIPriv->drmFD,
							   reserved[i]));
		}
		drmFreeReservedContextList(reserved);
		DRIDrvMsg(pScreen->myNum, X_INFO,
			  "[drm] removed %d reserved context%s for kernel\n",
			  reserved_count, reserved_count > 1 ? "s" : "");
	    }
	}

	/* Make sure signals get unblocked etc. */
	drmUnlock(pDRIPriv->drmFD, pDRIPriv->myContext);
	pDRIPriv->pLockRefCount = NULL;
	closeMaster = (--pDRIEntPriv->refCount == 0) &&
	    !pDRIEntPriv->keepFDOpen;
	if (closeMaster || pDRIPriv->hSAREA != pDRIEntPriv->hLSAREA) {
	    DRIDrvMsg(pScreen->myNum, X_INFO,
		      "[drm] unmapping %d bytes of SAREA %p at %p\n",
		      pDRIInfo->SAREASize,
		      pDRIPriv->hSAREA,
		      pDRIPriv->pSAREA);
	    if (drmUnmap(pDRIPriv->pSAREA, pDRIInfo->SAREASize)) {
		DRIDrvMsg(pScreen->myNum, X_ERROR,
			  "[drm] unable to unmap %d bytes"
			  " of SAREA %p at %p\n",
			  pDRIInfo->SAREASize,
			  pDRIPriv->hSAREA,
			  pDRIPriv->pSAREA);
	    }
	} else {
	    pDRIEntPriv->sAreaGrabbed = FALSE;
	}

	if (closeMaster || (pDRIEntPriv->drmFD != pDRIPriv->drmFD)) {
	    drmClose(pDRIPriv->drmFD);
	    if (pDRIEntPriv->drmFD == pDRIPriv->drmFD) {
		DRIDrvMsg(pScreen->myNum, X_INFO,
			  "[drm] Closed DRM master.\n");
		pDRIEntPriv->drmFD = -1;
	    }
	}
d723 2
a724 2
	free(pDRIPriv);
	dixSetPrivate(&pScreen->devPrivates, DRIScreenPrivKey, NULL);
d730 2
a731 1
static int dri_drm_debug_print(const char *format, va_list ap)
d733 2
a734 2
  xf86VDrvMsgVerb(-1, X_NONE, DRM_MSG_VERBOSITY, format, ap);
  return 0;
d737 2
a738 1
static void dri_drm_get_perms(gid_t *group, mode_t *mode)
d740 2
a741 2
  *group = xf86ConfigDRI.group;
  *mode = xf86ConfigDRI.mode;
d744 4
a747 4
drmServerInfo DRIDRMServerInfo =  {
  dri_drm_debug_print,
  xf86LoadKernelModule,
  dri_drm_get_perms,
d754 1
a754 1
	return FALSE;
d758 1
a758 1
						   "DRIDrawable");
d760 1
a760 1
						  "DRIContext");
d763 1
a763 1
	return FALSE;
d783 1
a783 1
DRIQueryDirectRenderingCapable(ScreenPtr pScreen, Bool* isCapable)
d788 1
a788 1
	*isCapable = pDRIPriv->directRenderingSupport;
d790 1
a790 1
	*isCapable = FALSE;
d800 2
a801 2
    *hSAREA           = pDRIPriv->hSAREA;
    *busIdString      = pDRIPriv->pDriverInfo->busIdString;
d811 2
a812 1
    if (drmAuthMagic(pDRIPriv->drmFD, magic)) return FALSE;
d826 1
a826 2
                       int *ddxDriverPatchVersion,
                       char **clientDriverName)
d833 1
a833 1
    *clientDriverName      = pDRIPriv->pDriverInfo->clientDriverName;
d852 1
a852 2
		     drm_context_t * pHWContext,
		     DRIContextFlags flags)
d854 1
a854 1
    DRIScreenPrivPtr  pDRIPriv = DRI_SCREEN_PRIV(pScreen);
d857 1
a857 1
	return NULL;
d865 1
a865 2
			       drm_context_t hHWContext,
			       DRIContextFlags flags)
d867 1
a867 1
    DRIScreenPrivPtr  pDRIPriv = DRI_SCREEN_PRIV(pScreen);
d869 1
a869 1
    int 	      contextPrivSize;
d872 1
a872 1
			    pDRIPriv->pDriverInfo->contextSize;
d874 1
a874 1
	return NULL;
d876 1
a876 1
    pDRIContextPriv->pContextStore = (void *)(pDRIContextPriv + 1);
d881 3
a883 3
    pDRIContextPriv->pScreen   = pScreen;
    pDRIContextPriv->flags     = flags;
    pDRIContextPriv->valid3D   = FALSE;
d886 6
a891 8
	if (drmSetContextFlags(pDRIPriv->drmFD,
			       hHWContext,
			       DRM_CONTEXT_2DONLY)) {
	    DRIDrvMsg(pScreen->myNum, X_ERROR,
		      "[drm] failed to set 2D context flag\n");
	    DRIDestroyContextPriv(pDRIContextPriv);
	    return NULL;
	}
d894 7
a900 8
	if (drmSetContextFlags(pDRIPriv->drmFD,
			       hHWContext,
			       DRM_CONTEXT_PRESERVED)) {
	    DRIDrvMsg(pScreen->myNum, X_ERROR,
		      "[drm] failed to set preserved flag\n");
	    DRIDestroyContextPriv(pDRIContextPriv);
	    return NULL;
	}
d910 2
a911 1
    if (!pDRIContextPriv) return TRUE;
d916 5
a920 5
				/* Don't delete reserved contexts from
                                   kernel area -- the kernel manages its
                                   reserved contexts itself. */
	if (drmDestroyContext(pDRIPriv->drmFD, pDRIContextPriv->hwContext))
	    return FALSE;
d923 5
a927 5
				/* Remove the tag last to prevent a race
                                   condition where the context has pending
                                   buffers.  The context can't be re-used
                                   while in this thread, but buffers can be
                                   dispatched asynchronously. */
d941 2
a942 3
	  DRICreateContextPriv(pScreen,
			       &pDRIPriv->pSAREA->dummy_context, 0))) {
	return FALSE;
d947 8
a954 7
	if (!pDRIPriv->pDriverInfo->CreateContext(pScreen, NULL,
						  pDRIPriv->pSAREA->dummy_context,
						  NULL,
						  (DRIContextType)(long)contextStore)) {
	    DRIDestroyContextPriv(pDRIContextPriv);
	    return FALSE;
	}
d968 2
a969 1
    if (!pDRIContextPriv) return;
d971 5
a975 4
	contextStore = DRIGetContextStore(pDRIContextPriv);
	pDRIPriv->pDriverInfo->DestroyContext(pDRIContextPriv->pScreen,
					      pDRIContextPriv->hwContext,
					      (DRIContextType)(long)contextStore);
d992 4
a995 4
	    DRIDrvMsg(pScreen->myNum, X_INFO,
		      "[drm] Could not create dummy context\n");
	    return FALSE;
	}
d999 1
a999 1
	return FALSE;
d1004 7
a1010 6
	if (!((*pDRIPriv->pDriverInfo->CreateContext)(pScreen, NULL,
		*pHWContext, NULL,
		(DRIContextType)(long)contextStore))) {
	    DRIDestroyContextPriv(pDRIContextPriv);
	    return FALSE;
	}
d1014 1
a1014 1
    AddResource(context, DRIContextPrivResType, (pointer)pDRIContextPriv);
d1031 1
a1031 1
    DRIContextPrivPtr pDRIContextPriv = (DRIContextPrivPtr)pResource;
d1037 5
a1041 4
      contextStore = DRIGetContextStore(pDRIContextPriv);
      pDRIPriv->pDriverInfo->DestroyContext(pDRIContextPriv->pScreen,
					    pDRIContextPriv->hwContext,
					    (DRIContextType)(long)contextStore);
a1045 1

d1055 2
a1056 2
   int i;
   DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
d1058 3
a1060 3
   for( i=0; i < pDRIPriv->pDriverInfo->maxDrawableTableEntry; i++) {
      pDRIPriv->pSAREA->drawableTable[i].stamp = DRIDrawableValidationStamp++;
   }
a1062 1

d1069 1
a1069 1
    DRIClipNotifyAllDrawables( pScreen );
d1072 1
a1072 1
	pDRIInfo->TransitionSingleToMulti3D( pScreen );
a1074 1

d1081 1
a1081 1
    DRIClipNotifyAllDrawables( pScreen );
d1084 1
a1084 1
	pDRIInfo->TransitionMultiToSingle3D( pScreen );
a1086 1

d1093 1
a1093 1
    DRIClipNotifyAllDrawables( pScreen );
d1096 1
a1096 1
	pDRIInfo->TransitionTo3d( pScreen );
d1105 1
a1105 1
    DRIClipNotifyAllDrawables( pScreen );
d1108 1
a1108 1
	pDRIInfo->TransitionTo2d( pScreen );
a1110 1

d1117 2
a1118 2
	ScreenPtr pScreen = pWin->drawable.pScreen;
	DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
d1120 3
a1122 3
	if (RegionNumRects(&pWin->clipList) > 0) {
	    WindowPtr *pDRIWindows = (WindowPtr*)data;
	    int i = 0;
d1124 2
a1125 2
	    while (pDRIWindows[i])
		i++;
d1127 1
a1127 1
	    pDRIWindows[i] = pWin;
d1129 2
a1130 2
	    pDRIPriv->nrWalked++;
	}
d1132 2
a1133 2
	if (pDRIPriv->nrWindows == pDRIPriv->nrWalked)
	    return WT_STOPWALKING;
d1145 2
a1146 2
	WindowPtr *pDRIWindows = calloc(sizeof(WindowPtr), pDRIPriv->nrWindows);
	DRIInfoPtr pDRIInfo = pDRIPriv->pDriverInfo;
d1148 5
a1152 5
	if (pDRIPriv->nrWindows > 0) {
	    pDRIPriv->nrWalked = 0;
	    TraverseTree(pScreen->root, DRIDCNTreeTraversal,
			 (pointer)pDRIWindows);
	}
d1154 1
a1154 1
	pDRIInfo->ClipNotify(pScreen, pDRIWindows, pDRIPriv->nrWindows);
d1156 1
a1156 1
	free(pDRIWindows);
d1167 2
a1168 2
	DRITransitionTo3d( pScreen );
	break;
d1170 2
a1171 2
	DRITransitionToSharedBuffers( pScreen );
	break;
d1173 1
a1173 1
	break;
d1186 2
a1187 2
	DRITransitionTo2d( pScreen );
	break;
d1189 2
a1190 2
	DRITransitionToPrivateBuffers( pScreen );
	break;
d1192 1
a1192 1
	break;
d1200 1
a1200 1
		  drm_drawable_t * hHWDrawable)
d1202 3
a1204 3
    DRIScreenPrivPtr	pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIDrawablePrivPtr	pDRIDrawablePriv;
    WindowPtr		pWin;
d1207 53
a1259 52
	pWin = (WindowPtr)pDrawable;
	if ((pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin))) {
	    pDRIDrawablePriv->refCount++;

	    if (!pDRIDrawablePriv->hwDrawable) {
		drmCreateDrawable(pDRIPriv->drmFD, &pDRIDrawablePriv->hwDrawable);
	    }
	}
	else {
	    /* allocate a DRI Window Private record */
	    if (!(pDRIDrawablePriv = malloc(sizeof(DRIDrawablePrivRec)))) {
		return FALSE;
	    }

	    /* Only create a drm_drawable_t once */
	    if (drmCreateDrawable(pDRIPriv->drmFD,
				  &pDRIDrawablePriv->hwDrawable)) {
		free(pDRIDrawablePriv);
		return FALSE;
	    }

	    /* add it to the list of DRI drawables for this screen */
	    pDRIDrawablePriv->pScreen = pScreen;
	    pDRIDrawablePriv->refCount = 1;
	    pDRIDrawablePriv->drawableIndex = -1;
	    pDRIDrawablePriv->nrects = RegionNumRects(&pWin->clipList);

	    /* save private off of preallocated index */
	    dixSetPrivate(&pWin->devPrivates, DRIWindowPrivKey,
			  pDRIDrawablePriv);
	    pDRIPriv->nrWindows++;

	    if (pDRIDrawablePriv->nrects)
		DRIIncreaseNumberVisible(pScreen);
	}

	/* track this in case the client dies */
	AddResource(FakeClientID(client->index), DRIDrawablePrivResType,
		    (pointer)(intptr_t)pDrawable->id);

	if (pDRIDrawablePriv->hwDrawable) {
	    drmUpdateDrawableInfo(pDRIPriv->drmFD,
				  pDRIDrawablePriv->hwDrawable,
				  DRM_DRAWABLE_CLIPRECTS,
				  RegionNumRects(&pWin->clipList),
				  RegionRects(&pWin->clipList));
	    *hHWDrawable = pDRIDrawablePriv->hwDrawable;
	}
    }
    else if (pDrawable->type != DRAWABLE_PIXMAP) { /* PBuffer */
	/* NOT_DONE */
	return FALSE;
d1273 1
a1273 1
	return;
d1279 3
a1281 3
	/* bump stamp to force outstanding 3D requests to resync */
	pDRIPriv->pSAREA->drawableTable[pDRIDrawablePriv->drawableIndex].stamp
	    = DRIDrawableValidationStamp++;
d1283 2
a1284 2
	/* release drawable table entry */
	pDRIPriv->DRIDrawables[pDRIDrawablePriv->drawableIndex] = NULL;
d1290 1
a1290 1
	DRIDecreaseNumberVisible(pScreen);
d1302 2
a1303 2
	/* This calls back DRIDrawablePrivDelete which frees private area */
	FreeResourceByType(id, DRIDrawablePrivResType, FALSE);
d1305 1
a1305 1
	return TRUE;
d1315 7
a1321 7
	LookupClientResourceComplex(client, DRIDrawablePrivResType,
				    DRIDestroyDrawableCB,
				    (pointer)(intptr_t)pDrawable->id);
    }
    else { /* pixmap (or for GLX 1.3, a PBuffer) */
	/* NOT_DONE */
	return FALSE;
d1335 1
a1335 1
    id = (XID)(intptr_t)pResource;
d1339 1
a1339 1
	DRIDrawablePrivPtr pDRIDrwPriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
d1341 2
a1342 2
	if (!pDRIDrwPriv)
	    return FALSE;
d1344 2
a1345 2
	if (--pDRIDrwPriv->refCount == 0)
	    DRIDrawablePrivDestroy(pWin);
d1347 1
a1347 1
	return TRUE;
d1349 3
a1351 3
    else { /* pixmap (or for GLX 1.3, a PBuffer) */
	/* NOT_DONE */
	return FALSE;
d1358 7
a1364 7
                   unsigned int* index,
                   unsigned int* stamp,
                   int* X,
                   int* Y,
                   int* W,
                   int* H,
                   int* numClipRects,
d1366 8
a1373 9
                   int* backX,
                   int* backY,
                   int* numBackClipRects,
                   drm_clip_rect_t ** pBackClipRects)
{
    DRIScreenPrivPtr    pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIDrawablePrivPtr	pDRIDrawablePriv, pOldDrawPriv;
    WindowPtr		pWin, pOldWin;
    int			i;
d1376 2
a1377 1
    printf("maxDrawableTableEntry = %d\n", pDRIPriv->pDriverInfo->maxDrawableTableEntry);
d1381 2
a1382 2
	pWin = (WindowPtr)pDrawable;
	if ((pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin))) {
d1384 2
a1385 2
	    /* Manage drawable table */
	    if (pDRIDrawablePriv->drawableIndex == -1) { /* load SAREA table */
d1387 12
a1398 12
		/* Search table for empty entry */
		i = 0;
		while (i < pDRIPriv->pDriverInfo->maxDrawableTableEntry) {
		    if (!(pDRIPriv->DRIDrawables[i])) {
			pDRIPriv->DRIDrawables[i] = pDrawable;
			pDRIDrawablePriv->drawableIndex = i;
			pDRIPriv->pSAREA->drawableTable[i].stamp =
					    DRIDrawableValidationStamp++;
			break;
		    }
		    i++;
		}
d1400 2
a1401 2
		/* Search table for oldest entry */
		if (i == pDRIPriv->pDriverInfo->maxDrawableTableEntry) {
a1403 22
		    i = pDRIPriv->pDriverInfo->maxDrawableTableEntry;
		    while (i--) {
			if (pDRIPriv->pSAREA->drawableTable[i].stamp <
								oldestStamp) {
			    oldestIndex = i;
			    oldestStamp =
				pDRIPriv->pSAREA->drawableTable[i].stamp;
			}
		    }
		    pDRIDrawablePriv->drawableIndex = oldestIndex;

		    /* release oldest drawable table entry */
		    pOldWin = (WindowPtr)pDRIPriv->DRIDrawables[oldestIndex];
		    pOldDrawPriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pOldWin);
		    pOldDrawPriv->drawableIndex = -1;

		    /* claim drawable table entry */
		    pDRIPriv->DRIDrawables[oldestIndex] = pDrawable;

		    /* validate SAREA entry */
		    pDRIPriv->pSAREA->drawableTable[oldestIndex].stamp =
					DRIDrawableValidationStamp++;
d1405 22
a1426 2
		    /* check for stamp wrap around */
		    if (oldestStamp > DRIDrawableValidationStamp) {
d1428 5
a1432 2
			/* walk SAREA table and invalidate all drawables */
			for( i=0;
d1435 92
a1526 84
				pDRIPriv->pSAREA->drawableTable[i].stamp =
					DRIDrawableValidationStamp++;
			}
		    }
		}

		/* If the driver wants to be notified when the index is
		 * set for a drawable, let it know now.
		 */
		if (pDRIPriv->pDriverInfo->SetDrawableIndex)
			pDRIPriv->pDriverInfo->SetDrawableIndex(pWin,
				pDRIDrawablePriv->drawableIndex);

		/* reinit drawable ID if window is visible */
		if ((pWin->viewable) &&
		    (pDRIPriv->pDriverInfo->bufferRequests != DRI_NO_WINDOWS))
		{
		    (*pDRIPriv->pDriverInfo->InitBuffers)(pWin,
			    &pWin->clipList, pDRIDrawablePriv->drawableIndex);
		}
	    }

	    *index = pDRIDrawablePriv->drawableIndex;
	    *stamp = pDRIPriv->pSAREA->drawableTable[*index].stamp;
	    *X = (int)(pWin->drawable.x);
	    *Y = (int)(pWin->drawable.y);
	    *W = (int)(pWin->drawable.width);
	    *H = (int)(pWin->drawable.height);
	    *numClipRects = RegionNumRects(&pWin->clipList);
	    *pClipRects = (drm_clip_rect_t *)RegionRects(&pWin->clipList);

	    if (!*numClipRects && pDRIPriv->fullscreen) {
				/* use fake full-screen clip rect */
		pDRIPriv->fullscreen_rect.x1 = *X;
		pDRIPriv->fullscreen_rect.y1 = *Y;
		pDRIPriv->fullscreen_rect.x2 = *X + *W;
		pDRIPriv->fullscreen_rect.y2 = *Y + *H;

		*numClipRects = 1;
		*pClipRects   = &pDRIPriv->fullscreen_rect;
	    }

	    *backX = *X;
	    *backY = *Y;

	    if (pDRIPriv->nrWindowsVisible == 1 && *numClipRects) {
	       /* Use a single cliprect. */

	       int x0 = *X;
	       int y0 = *Y;
	       int x1 = x0 + *W;
	       int y1 = y0 + *H;

	       if (x0 < 0) x0 = 0;
	       if (y0 < 0) y0 = 0;
	       if (x1 > pScreen->width) x1 = pScreen->width;
	       if (y1 > pScreen->height) y1 = pScreen->height;

	       if (y0 >= y1 || x0 >= x1) {
		    *numBackClipRects = 0;
		    *pBackClipRects = NULL;
	       } else {
		    pDRIPriv->private_buffer_rect.x1 = x0;
		    pDRIPriv->private_buffer_rect.y1 = y0;
		    pDRIPriv->private_buffer_rect.x2 = x1;
		    pDRIPriv->private_buffer_rect.y2 = y1;

		    *numBackClipRects = 1;
		    *pBackClipRects = &(pDRIPriv->private_buffer_rect);
	       }
	    } else {
	       /* Use the frontbuffer cliprects for back buffers.  */
	       *numBackClipRects = 0;
	       *pBackClipRects = 0;
	    }
	}
	else {
	    /* Not a DRIDrawable */
	    return FALSE;
	}
    }
    else { /* pixmap (or for GLX 1.3, a PBuffer) */
	/* NOT_DONE */
	return FALSE;
d1535 3
a1537 5
                 int* fbOrigin,
                 int* fbSize,
                 int* fbStride,
                 int* devPrivateSize,
                 void** pDevPrivate)
d1554 4
a1557 2
    DRIInfoPtr inforec = (DRIInfoPtr)calloc(1, sizeof(DRIInfoRec));
    if (!inforec) return NULL;
d1563 8
a1570 8
    inforec->wrap.WakeupHandler         = DRIDoWakeupHandler;
    inforec->wrap.BlockHandler          = DRIDoBlockHandler;
    inforec->wrap.WindowExposures       = DRIWindowExposures;
    inforec->wrap.CopyWindow            = DRICopyWindow;
    inforec->wrap.ValidateTree          = DRIValidateTree;
    inforec->wrap.PostValidateTree      = DRIPostValidateTree;
    inforec->wrap.ClipNotify            = DRIClipNotify;
    inforec->wrap.AdjustFrame           = DRIAdjustFrame;
d1583 1
a1583 1
    free((char*)DRIInfo);
a1585 1

d1592 2
a1593 2
	ScreenPtr        pScreen  = screenInfo.screens[i];
	DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
d1595 3
a1597 4
	if (pDRIPriv &&
	    pDRIPriv->pDriverInfo->wrap.WakeupHandler)
	    (*pDRIPriv->pDriverInfo->wrap.WakeupHandler)(i, wakeupData,
							 result, pReadmask);
d1607 2
a1608 2
	ScreenPtr        pScreen  = screenInfo.screens[i];
	DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
d1610 3
a1612 4
	if (pDRIPriv &&
	    pDRIPriv->pDriverInfo->wrap.BlockHandler)
	    (*pDRIPriv->pDriverInfo->wrap.BlockHandler)(i, blockData,
							pTimeout, pReadmask);
d1625 7
a1631 7
	/* hide X context by swapping 2D component here */
	(*pDRIPriv->pDriverInfo->SwapContext)(pScreen,
					      DRI_3D_SYNC,
					      DRI_2D_CONTEXT,
					      pDRIPriv->partial3DContextStore,
					      DRI_2D_CONTEXT,
					      pDRIPriv->hiddenContextStore);
d1643 7
a1649 7
	/* hide X context by swapping 2D component here */
	(*pDRIPriv->pDriverInfo->SwapContext)(pScreen,
					      DRI_2D_SYNC,
					      DRI_NO_CONTEXT,
					      NULL,
					      DRI_2D_CONTEXT,
					      pDRIPriv->partial3DContextStore);
d1662 10
a1671 9
    DRIContextPrivPtr oldContext      = (DRIContextPrivPtr)oldctx;
    DRIContextPrivPtr newContext      = (DRIContextPrivPtr)newctx;
    ScreenPtr         pScreen         = newContext->pScreen;
    DRIScreenPrivPtr  pDRIPriv        = DRI_SCREEN_PRIV(pScreen);
    void*             oldContextStore = NULL;
    DRIContextType    oldContextType;
    void*             newContextStore = NULL;
    DRIContextType    newContextType;
    DRISyncType       syncType;
d1673 1
a1673 1
    static int        count = 0;
d1676 4
a1679 4
	DRIDrvMsg(pScreen->myNum, X_ERROR,
		  "[DRI] Context Switch Error: oldContext=%x, newContext=%x\n",
		  oldContext, newContext);
	return;
d1684 12
a1695 12
	DRIDrvMsg(pScreen->myNum, X_INFO,
		  "[DRI] Context switch %5d from %p/0x%08x (%d)\n",
		  count,
		  oldContext,
		  oldContext ? oldContext->flags : 0,
		  oldContext ? oldContext->hwContext : -1);
	DRIDrvMsg(pScreen->myNum, X_INFO,
		  "[DRI] Context switch %5d to   %p/0x%08x (%d)\n",
		  count,
		  newContext,
		  newContext ? newContext->flags : 0,
		  newContext ? newContext->hwContext : -1);
d1701 3
a1703 3
	DRIDrvMsg(pScreen->myNum, X_ERROR,
		  "[DRI] DDX driver missing context swap call back\n");
	return;
d1709 17
a1725 16
	if (oldContext) {
	    oldContextStore     = DRIGetContextStore(oldContext);
	    oldContext->valid3D = TRUE;
	    oldContextType      = DRI_3D_CONTEXT;
	} else {
	    oldContextType      = DRI_NO_CONTEXT;
	}
	newContextStore = DRIGetContextStore(newContext);
	if ((newContext->valid3D) &&
	  (newContext->hwContext != pDRIPriv->myContext)) {
	    newContextType = DRI_3D_CONTEXT;
	}
	else {
	    newContextType = DRI_2D_CONTEXT;
	}
	syncType = DRI_3D_SYNC;
d1727 1
a1727 1
    else /* default: driverSwapMethod == DRI_SERVER_SWAP */ {
d1731 2
a1732 2
	if (newContext->flags & DRI_CONTEXT_2DONLY) {
	    /* go from 3D context to 2D context and only save 2D
d1735 62
a1796 62
	    oldContextStore = DRIGetContextStore(oldContext);
	    oldContextType = DRI_2D_CONTEXT;
	    newContextStore = DRIGetContextStore(newContext);
	    newContextType = DRI_2D_CONTEXT;
	    syncType = DRI_3D_SYNC;
	    pDRIPriv->lastPartial3DContext = oldContext;
	}
	else if (oldContext->flags & DRI_CONTEXT_2DONLY) {
	    if (pDRIPriv->lastPartial3DContext == newContext) {
		/* go from 2D context back to previous 3D context and
		 * only restore 2D subset of previous 3D state
		 */
		oldContextStore = DRIGetContextStore(oldContext);
		oldContextType = DRI_2D_CONTEXT;
		newContextStore = DRIGetContextStore(newContext);
		newContextType = DRI_2D_CONTEXT;
		syncType = DRI_2D_SYNC;
	    }
	    else {
		/* go from 2D context to a different 3D context */

		/* call DDX driver to do partial restore */
		oldContextStore = DRIGetContextStore(oldContext);
		newContextStore =
			DRIGetContextStore(pDRIPriv->lastPartial3DContext);
		(*pDRIPriv->pDriverInfo->SwapContext)(pScreen,
						      DRI_2D_SYNC,
						      DRI_2D_CONTEXT,
						      oldContextStore,
						      DRI_2D_CONTEXT,
						      newContextStore);

		/* now setup for a complete 3D swap */
		oldContextStore = newContextStore;
		oldContext->valid3D = TRUE;
		oldContextType = DRI_3D_CONTEXT;
		newContextStore = DRIGetContextStore(newContext);
		if ((newContext->valid3D) &&
		  (newContext->hwContext != pDRIPriv->myContext)) {
		    newContextType = DRI_3D_CONTEXT;
		}
		else {
		    newContextType = DRI_2D_CONTEXT;
		}
		syncType = DRI_NO_SYNC;
	    }
	}
	else {
	    /* now setup for a complete 3D swap */
	    oldContextStore = newContextStore;
	    oldContext->valid3D = TRUE;
	    oldContextType = DRI_3D_CONTEXT;
	    newContextStore = DRIGetContextStore(newContext);
	    if ((newContext->valid3D) &&
	      (newContext->hwContext != pDRIPriv->myContext)) {
		newContextType = DRI_3D_CONTEXT;
	    }
	    else {
		newContextType = DRI_2D_CONTEXT;
	    }
	    syncType = DRI_3D_SYNC;
	}
d1800 5
a1804 6
    (*pDRIPriv->pDriverInfo->SwapContext)(pScreen,
					  syncType,
					  oldContextType,
					  oldContextStore,
					  newContextType,
					  newContextStore);
d1807 1
a1807 1
void*
d1810 1
a1810 1
    return((void *)context->pContextStore);
d1820 2
a1821 2
    if(pDRIDrawablePriv) {
         (*pDRIPriv->pDriverInfo->InitBuffers)(pWin, prgn,
d1828 2
a1829 2
	/* unwrap */
	pScreen->WindowExposures = pDRIPriv->wrap.WindowExposures;
d1831 2
a1832 2
	/* call lower layers */
	(*pScreen->WindowExposures)(pWin, prgn, bsreg);
d1834 3
a1836 3
	/* rewrap */
	pDRIPriv->wrap.WindowExposures = pScreen->WindowExposures;
	pScreen->WindowExposures = DRIWindowExposures;
a1839 1

d1845 1
a1845 1
    if(pDRIDrawablePriv) {
d1849 2
a1850 2
	if(RegionNumRects(&(pWin->clipList)) > 0) {
	   RegionPtr reg = (RegionPtr)data;
d1852 3
a1854 3
	   RegionUnion(reg, reg, &(pWin->clipList));
	   pDRIPriv->nrWalked++;
	}
d1856 2
a1857 2
	if(pDRIPriv->nrWindows == pDRIPriv->nrWalked)
	   return WT_STOPWALKING;
d1872 10
a1881 10
    if(pDRIPriv->DestroyWindow) {
	/* unwrap */
	pScreen->DestroyWindow = pDRIPriv->DestroyWindow;

	/* call lower layers */
	retval = (*pScreen->DestroyWindow)(pWin);

	/* rewrap */
	pDRIPriv->DestroyWindow = pScreen->DestroyWindow;
	pScreen->DestroyWindow = DRIDestroyWindow;
d1893 2
a1894 1
    if(!pDRIPriv) return;
d1896 2
a1897 2
    if(pDRIPriv->nrWindowsVisible > 0) {
       RegionRec reg;
d1899 14
a1912 13
       RegionNull(&reg);
       pDRIPriv->nrWalked = 0;
       TraverseTree(pWin, DRITreeTraversal, (pointer)(&reg));

       if(RegionNotEmpty(&reg)) {
           RegionTranslate(&reg, ptOldOrg.x - pWin->drawable.x,
                                        ptOldOrg.y - pWin->drawable.y);
           RegionIntersect(&reg, &reg, prgnSrc);

           /* The MoveBuffers interface is not ideal */
           (*pDRIPriv->pDriverInfo->MoveBuffers)(pWin, ptOldOrg, &reg,
				pDRIPriv->pDriverInfo->ddxDrawableTableEntry);
       }
d1914 1
a1914 1
       RegionUninit(&reg);
d1918 10
a1927 10
    if(pDRIPriv->wrap.CopyWindow) {
	/* unwrap */
	pScreen->CopyWindow = pDRIPriv->wrap.CopyWindow;

	/* call lower layers */
	(*pScreen->CopyWindow)(pWin, ptOldOrg, prgnSrc);

	/* rewrap */
	pDRIPriv->wrap.CopyWindow = pScreen->CopyWindow;
	pScreen->CopyWindow = DRICopyWindow;
d1938 1
a1938 1
    *secs  = tv.tv_sec;
d1944 1
a1944 1
		       unsigned long f_secs, unsigned long f_usecs)
d1947 2
a1948 2
	--f_secs;
	f_usecs += 1000000;
d1954 1
a1954 1
DRISpinLockTimeout(drmLock *lock, int val, unsigned long timeout /* in mS */)
d1956 2
a1957 1
    int  count = 10000;
d1966 1
a1966 1
    long prev  = 0;
d1971 7
a1977 5
	DRM_SPINLOCK_COUNT(lock, val, count, ret);
	if (!ret) return;	/* Got lock */
	DRIGetSecs(&f_secs, &f_usecs);
	msecs = DRIComputeMilliSeconds(s_secs, s_usecs, f_secs, f_usecs);
	if (msecs - prev < 250) count *= 2; /* Not more than 0.5S */
d1980 7
a1986 7
				/* Didn't get lock, so take it.  The worst
                                   that can happen is that there is some
                                   garbage written to the wrong part of the
                                   framebuffer that a refresh will repair.
                                   That's undesirable, but better than
                                   locking the server.  This should be a
                                   very rare event. */
d1995 2
a1996 1
    if(!pDRIPriv) return;
d2000 6
a2005 6
	(*pDRIPriv->pDriverInfo->SwapContext)(pScreen,
					      DRI_2D_SYNC,
					      DRI_NO_CONTEXT,
					      NULL,
					      DRI_2D_CONTEXT,
					      pDRIPriv->partial3DContextStore);
d2015 1
a2015 1
    DRISpinLockTimeout(&pDRIPriv->pSAREA->drawable_lock, 1, 10000); /*10 secs*/
d2018 1
a2018 1
    DRILock(pScreen, DRM_LOCK_QUIESCENT|DRM_LOCK_FLUSH_ALL);
d2022 7
a2028 7
	/* hide X context by swapping 2D component here */
	(*pDRIPriv->pDriverInfo->SwapContext)(pScreen,
					      DRI_3D_SYNC,
					      DRI_2D_CONTEXT,
					      pDRIPriv->partial3DContextStore,
					      DRI_2D_CONTEXT,
					      pDRIPriv->hiddenContextStore);
d2038 1
a2038 1
    int returnValue = 1; /* always return 1, not checked by dix/window.c */
d2040 2
a2041 1
    if(!pDRIPriv) return returnValue;
d2044 10
a2053 10
    if(pDRIPriv->wrap.ValidateTree) {
	/* unwrap */
	pScreen->ValidateTree = pDRIPriv->wrap.ValidateTree;

	/* call lower layers */
	returnValue = (*pScreen->ValidateTree)(pParent, pChild, kind);

	/* rewrap */
	pDRIPriv->wrap.ValidateTree = pScreen->ValidateTree;
	pScreen->ValidateTree = DRIValidateTree;
d2066 4
a2069 3
	pScreen = pParent->drawable.pScreen;
    } else {
	pScreen = pChild->drawable.pScreen;
d2071 2
a2072 1
    if(!(pDRIPriv = DRI_SCREEN_PRIV(pScreen))) return;
d2075 2
a2076 2
	/* unwrap */
	pScreen->PostValidateTree = pDRIPriv->wrap.PostValidateTree;
d2078 2
a2079 2
	/* call lower layers */
	(*pScreen->PostValidateTree)(pParent, pChild, kind);
d2081 3
a2083 3
	/* rewrap */
	pDRIPriv->wrap.PostValidateTree = pScreen->PostValidateTree;
	pScreen->PostValidateTree = DRIPostValidateTree;
d2092 1
a2092 1
    DRIDrawablePrivPtr	pDRIDrawablePriv;
d2094 2
a2095 1
    if(!pDRIPriv) return;
d2100 1
a2100 1
        if(!pDRIPriv->windowsTouched) {
d2105 15
a2119 15
	if (nrects && !pDRIDrawablePriv->nrects)
	    DRIIncreaseNumberVisible(pScreen);
	else if (!nrects && pDRIDrawablePriv->nrects)
	    DRIDecreaseNumberVisible(pScreen);
	else
	    DRIDriverClipNotify(pScreen);

	pDRIDrawablePriv->nrects = nrects;

	pDRIPriv->pSAREA->drawableTable[pDRIDrawablePriv->drawableIndex].stamp
	    = DRIDrawableValidationStamp++;

	drmUpdateDrawableInfo(pDRIPriv->drmFD, pDRIDrawablePriv->hwDrawable,
			      DRM_DRAWABLE_CLIPRECTS,
			      nrects, RegionRects(&pWin->clipList));
d2123 1
a2123 1
    if(pDRIPriv->wrap.ClipNotify) {
d2125 1
a2125 1
	/* unwrap */
d2128 2
a2129 2
	/* call lower layers */
        (*pScreen->ClipNotify)(pWin, dx, dy);
d2131 1
a2131 1
	/* rewrap */
d2146 1
a2146 1
	index = pDRIDrawablePriv->drawableIndex;
d2149 1
a2149 1
	index = pDRIPriv->pDriverInfo->ddxDrawableTableEntry;
d2159 1
a2162 1

d2168 1
a2168 1
    ErrorF("%s: %d\n", msg,  pDRIPriv->pSAREA->drawable_lock.lock);
d2176 2
a2177 1
    if(!pDRIPriv || !pDRIPriv->pLockRefCount) return;
d2180 10
a2189 9
        DRM_LOCK(pDRIPriv->drmFD, pDRIPriv->pLSAREA, pDRIPriv->myContext, flags);
	*pDRIPriv->pLockingContext = pDRIPriv->myContext;
    } else if (*pDRIPriv->pLockingContext != pDRIPriv->myContext) {
	DRIDrvMsg(pScreen->myNum, X_ERROR,
		  "[DRI] Locking deadlock.\n"
		  "\tAlready locked with context %d,\n"
		  "\ttrying to lock with context %d.\n",
		  pDRIPriv->pLockingContext,
		  pDRIPriv->myContext);
d2199 2
a2200 1
    if(!pDRIPriv || !pDRIPriv->pLockRefCount) return;
d2203 9
a2211 9
	if (pDRIPriv->myContext != *pDRIPriv->pLockingContext) {
	    DRIDrvMsg(pScreen->myNum, X_ERROR,
		      "[DRI] Unlocking inconsistency:\n"
		      "\tContext %d trying to unlock lock held by context %d\n",
		      pDRIPriv->pLockingContext,
		      pDRIPriv->myContext);
	}
	(*pDRIPriv->pLockRefCount)--;
    } else {
d2213 1
a2213 1
		  "DRIUnlock called when not locked.\n");
d2216 1
a2216 1
    if (! *pDRIPriv->pLockRefCount)
a2223 1
    if (!pDRIPriv) return 0;
d2225 4
a2228 1
    return (void *)(((char*)pDRIPriv->pSAREA)+sizeof(XF86DRISAREARec));
d2235 3
a2237 1
    if (!pDRIPriv) return 0;
d2244 2
a2245 2
		     DRITexOffsetStartProcPtr *texOffsetStartFunc,
		     DRITexOffsetFinishProcPtr *texOffsetFinishFunc)
d2249 2
a2250 1
    if (!pDRIPriv) return;
d2252 1
a2252 1
    *texOffsetStartFunc  = pDRIPriv->pDriverInfo->texOffsetStart;
d2268 1
a2268 3
DRIQueryVersion(int *majorVersion,
                int *minorVersion,
                int *patchVersion)
d2278 3
a2280 3
    pDRIPriv->pSAREA->frame.x      = x;
    pDRIPriv->pSAREA->frame.y      = y;
    pDRIPriv->pSAREA->frame.width  = pScrn->frameX1 - x + 1;
d2287 1
a2287 1
    ScreenPtr        pScreen  = screenInfo.screens[scrnIndex];
d2289 2
a2290 2
    ScrnInfoPtr      pScrn    = xf86Screens[pScreen->myNum];
    int              px, py;
d2293 3
a2295 3
	DRIDrvMsg(scrnIndex, X_ERROR, "[DRI] No SAREA (%p %p)\n",
		  pDRIPriv, pDRIPriv ? pDRIPriv->pSAREA : NULL);
	return;
d2299 20
a2318 14
				/* Fix up frame */
	pScrn->frameX0 = pDRIPriv->pSAREA->frame.x;
	pScrn->frameY0 = pDRIPriv->pSAREA->frame.y;
	pScrn->frameX1 = pScrn->frameX0 + pDRIPriv->pSAREA->frame.width - 1;
	pScrn->frameY1 = pScrn->frameY0 + pDRIPriv->pSAREA->frame.height - 1;

				/* Fix up cursor */
    miPointerGetPosition(inputInfo.pointer, &px, &py);
	if (px < pScrn->frameX0) px = pScrn->frameX0;
	if (px > pScrn->frameX1) px = pScrn->frameX1;
	if (py < pScrn->frameY0) py = pScrn->frameY0;
	if (py > pScrn->frameY1) py = pScrn->frameY1;
	pScreen->SetCursorPosition(inputInfo.pointer, pScreen, px, py, TRUE);
	return;
d2322 7
a2328 7
	/* unwrap */
	pScrn->AdjustFrame = pDRIPriv->wrap.AdjustFrame;
	/* call lower layers */
	(*pScrn->AdjustFrame)(scrnIndex, x, y, flags);
	/* rewrap */
	pDRIPriv->wrap.AdjustFrame = pScrn->AdjustFrame;
	pScrn->AdjustFrame         = DRIAdjustFrame;
d2343 23
a2365 59
DRIMoveBuffersHelper(
   ScreenPtr pScreen, 
   int dx,
   int dy,
   int *xdir, 
   int *ydir, 
   RegionPtr reg
)
{
   BoxPtr extents, pbox, firstBox, lastBox;
   BoxRec tmpBox;
   int y, nbox;

   extents = RegionExtents(reg);
   nbox = RegionNumRects(reg);
   pbox = RegionRects(reg);

   if((dy > 0) && (dy < (extents->y2 - extents->y1))) {
     *ydir = -1;
     if(nbox > 1) {
        firstBox = pbox;
        lastBox = pbox + nbox - 1;
        while((unsigned long)firstBox < (unsigned long)lastBox) {
           tmpBox = *firstBox;
           *firstBox = *lastBox;
           *lastBox = tmpBox;
           firstBox++;
           lastBox--;
        }
     }
   } else *ydir = 1;

   if((dx > 0) && (dx < (extents->x2 - extents->x1))) {
     *xdir = -1;
     if(nbox > 1) {
        firstBox = lastBox = pbox;
        y = pbox->y1;
        while(--nbox) {
           pbox++;
           if(pbox->y1 == y) lastBox++;
           else {
              while((unsigned long)firstBox < (unsigned long)lastBox) {
                 tmpBox = *firstBox;
                 *firstBox = *lastBox;
                 *lastBox = tmpBox;
                 firstBox++;
                 lastBox--;
              }

              firstBox = lastBox = pbox;
              y = pbox->y1;
           }
         }
         while((unsigned long)firstBox < (unsigned long)lastBox) {
           tmpBox = *firstBox;
           *firstBox = *lastBox;
           *lastBox = tmpBox;
           firstBox++;
           lastBox--;
d2367 37
a2403 2
     }
   } else *xdir = 1;
d2408 1
a2408 1
DRICreatePCIBusID(const struct pci_device * dev)
d2413 2
a2414 2
		 dev->domain, dev->bus, dev->dev, dev->func) == -1)
	return NULL;
@


1.7
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a65 2
#include "xf86.h"
#include "xf86drm.h"
a71 2
#define PCI_BUS_NO_DOMAIN(bus) ((bus) & 0xffu)

d431 1
a431 1
		       (drm_handle_t)pDRIPriv->pDriverInfo->frameBufferPhysicalAddress,
a1473 4
#if 0
	    *W = (int)(pWin->winSize.extents.x2 - pWin->winSize.extents.x1);
	    *H = (int)(pWin->winSize.extents.y2 - pWin->winSize.extents.y1);
#endif
d2399 2
a2400 2
    busID = malloc(20);
    if (busID == NULL)
a2401 3

    snprintf(busID, 20, "pci:%04x:%02x:%02x.%d", dev->domain, dev->bus,
	dev->dev, dev->func);
@


1.6
log
@Don't even attempt to establish a SIGIO handler for DRI1.

This hasn't been used for a very, very, very long time, (since before
OpenBSD had dri support, for example) and it causes segfaults on dri
drivers when sigio is disabled. Now we don't need to do context swaps on sigio
nor are we trying to do interrupts in userland (thank fuck for that) this
function can die the death that I intended it to die about two years ago, may it
burn.

The kernel support the the sigio ioctl will be removed in a couple of
weeks to give people time to update (right now it accepts it, then
ignores it).

ok kettenis@@, matthieu@@.
@
text
@d77 4
a80 4
static int DRIScreenPrivKeyIndex;
static DevPrivateKey DRIScreenPrivKey = &DRIScreenPrivKeyIndex;
static int DRIWindowPrivKeyIndex;
static DevPrivateKey DRIWindowPrivKey = &DRIWindowPrivKeyIndex;
d360 6
a365 1
    pDRIPriv = (DRIScreenPrivPtr) xcalloc(1, sizeof(DRIScreenPrivRec));
d541 1
a541 1
	    = (void *)xcalloc(1, pDRIInfo->contextSize);
d551 1
a551 1
	    = (void *)xcalloc(1, pDRIInfo->contextSize);
d555 1
a555 1
	    xfree(pDRIPriv->hiddenContextStore);
d739 1
a739 1
	xfree(pDRIPriv);
d767 1
a767 1
    if (!DRIScreenPrivKey || DRIGeneration != serverGeneration) {
d857 2
a858 1
   DRI tracking. Any special flags are stored in the DRIContextPriv
d889 1
a889 1
    if (!(pDRIContextPriv = xcalloc(1, contextPrivSize))) {
d947 1
a947 1
    xfree(pDRIContextPriv);
d1139 1
a1139 1
	if (REGION_NUM_RECTS(&pWin->clipList) > 0) {
d1164 1
a1164 1
	WindowPtr *pDRIWindows = xcalloc(sizeof(WindowPtr), pDRIPriv->nrWindows);
d1169 1
a1169 1
	    TraverseTree(WindowTable[pScreen->myNum], DRIDCNTreeTraversal,
d1175 1
a1175 1
	xfree(pDRIWindows);
d1236 1
a1236 1
	    if (!(pDRIDrawablePriv = xalloc(sizeof(DRIDrawablePrivRec)))) {
d1243 1
a1243 1
		xfree(pDRIDrawablePriv);
d1251 1
a1251 1
	    pDRIDrawablePriv->nrects = REGION_NUM_RECTS(&pWin->clipList);
d1270 2
a1271 2
				  REGION_NUM_RECTS(&pWin->clipList),
				  REGION_RECTS(&pWin->clipList));
d1312 1
a1312 1
    xfree(pDRIDrawablePriv);
d1484 2
a1485 2
	    *numClipRects = REGION_NUM_RECTS(&pWin->clipList);
	    *pClipRects = (drm_clip_rect_t *)REGION_RECTS(&pWin->clipList);
d1569 1
a1569 1
    DRIInfoPtr inforec = (DRIInfoPtr)xcalloc(1, sizeof(DRIInfoRec));
d1595 2
a1596 2
    if (DRIInfo->busIdString) xfree(DRIInfo->busIdString);
    xfree((char*)DRIInfo);
d1865 1
a1865 1
	if(REGION_NUM_RECTS(&(pWin->clipList)) > 0) {
d1868 1
a1868 1
	   REGION_UNION(pScreen, reg, reg, &(pWin->clipList));
d1914 1
a1914 1
       REGION_NULL(pScreen, &reg);
d1918 2
a1919 2
       if(REGION_NOTEMPTY(pScreen, &reg)) {
           REGION_TRANSLATE(pScreen, &reg, ptOldOrg.x - pWin->drawable.x,  
d1921 1
a1921 1
           REGION_INTERSECT(pScreen, &reg, &reg, prgnSrc);
d1928 1
a1928 1
       REGION_UNINIT(pScreen, &reg);
d2104 1
a2104 1
        int nrects = REGION_NUM_RECTS(&pWin->clipList);
d2125 1
a2125 1
			      nrects, REGION_RECTS(&pWin->clipList));
d2350 3
a2352 3
   extents = REGION_EXTENTS(pScreen, reg);
   nbox = REGION_NUM_RECTS(reg);
   pbox = REGION_RECTS(reg);
d2407 1
a2407 1
    busID = xalloc(20);
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a377 1
    pDRIPriv->drmSIGIOHandlerInstalled = FALSE;
a567 18
        /* For swap methods of DRI_SERVER_SWAP and DRI_HIDE_X_CONTEXT
         * setup signal handler for receiving swap requests from kernel
	 */
	if (!(pDRIPriv->drmSIGIOHandlerInstalled =
	      drmInstallSIGIOHandler(pDRIPriv->drmFD, DRISwapContext))) {
	    DRIDrvMsg(pScreen->myNum, X_ERROR,
		      "[drm] failed to setup DRM signal handler\n");
	    if (pDRIPriv->hiddenContextStore)
		xfree(pDRIPriv->hiddenContextStore);
	    if (pDRIPriv->partial3DContextStore)
		xfree(pDRIPriv->partial3DContextStore);
	    DRIDestroyContextPriv(pDRIContextPriv);
	    return FALSE;
	} else {
	    DRIDrvMsg(pScreen->myNum, X_INFO,
		      "[drm] installed DRM signal handler\n");
	}

a673 7
	if (pDRIPriv->drmSIGIOHandlerInstalled) {
	    if (!drmRemoveSIGIOHandler(pDRIPriv->drmFD)) {
		DRIDrvMsg(pScreen->myNum, X_ERROR,
			  "[drm] failed to remove DRM signal handler\n");
	    }
	}

d852 1
a852 2
   DRI tracking.  For the SIGIO handler, the drm_context_t is associated with
   DRIContextPrivPtr.  Any special flags are stored in the DRIContextPriv
a2408 68
}

static void drmSIGIOHandler(int interrupt, void *closure)
{
    unsigned long key;
    void          *value;
    ssize_t       count;
    drm_ctx_t     ctx;
    typedef void  (*_drmCallback)(int, void *, void *);
    char          buf[256];
    drm_context_t    old;
    drm_context_t    new;
    void          *oldctx;
    void          *newctx;
    char          *pt;
    drmHashEntry  *entry;
    void *hash_table;

    hash_table = drmGetHashTable();

    if (!hash_table) return;
    if (drmHashFirst(hash_table, &key, &value)) {
	entry = value;
	do {
#if 0
	    fprintf(stderr, "Trying %d\n", entry->fd);
#endif
	    if ((count = read(entry->fd, buf, sizeof(buf) - 1)) > 0) {
		buf[count] = '\0';
#if 0
		fprintf(stderr, "Got %s\n", buf);
#endif

		for (pt = buf; *pt != ' '; ++pt); /* Find first space */
		++pt;
		old    = strtol(pt, &pt, 0);
		new    = strtol(pt, NULL, 0);
		oldctx = drmGetContextTag(entry->fd, old);
		newctx = drmGetContextTag(entry->fd, new);
#if 0
		fprintf(stderr, "%d %d %p %p\n", old, new, oldctx, newctx);
#endif
		((_drmCallback)entry->f)(entry->fd, oldctx, newctx);
		ctx.handle = new;
		ioctl(entry->fd, DRM_IOCTL_NEW_CTX, &ctx);
	    }
	} while (drmHashNext(hash_table, &key, &value));
    }
}


int drmInstallSIGIOHandler(int fd, void (*f)(int, void *, void *))
{
    drmHashEntry     *entry;

    entry     = drmGetEntry(fd);
    entry->f  = f;

    return xf86InstallSIGIOHandler(fd, drmSIGIOHandler, 0);
}

int drmRemoveSIGIOHandler(int fd)
{
    drmHashEntry     *entry = drmGetEntry(fd);

    entry->f = NULL;

    return xf86RemoveSIGIOHandler(fd);
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a47 2
#define NEED_REPLIES
#define NEED_EVENTS
d60 1
a60 1
#include "xf86dristr.h"
d72 1
a75 4
#if !defined(PANORAMIX)
extern Bool noPanoramiXExtension;
#endif

a319 1
    Bool                xineramaInCore = FALSE;
d332 7
a342 4
    if (xf86LoaderCheckSymbol("noPanoramiXExtension"))
	xineramaInCore = TRUE;

    if (xineramaInCore) {
d348 1
a348 1
    }
d792 7
a798 2
    DRIDrawablePrivResType = CreateNewResourceType(DRIDrawablePrivDelete);
    DRIContextPrivResType = CreateNewResourceType(DRIContextPrivDelete);
d1285 1
a1285 1
		    (pointer)pDrawable->id);
d1356 1
a1356 1
				    (pointer)pDrawable->id);
d1370 1
d1372 4
a1375 2
    id = (XID)pResource;
    pWin = LookupIDByType(id, RT_WINDOW);
d1377 1
a1377 1
    if (pWin) {
d1843 1
a1843 1
void* 
@


1.3
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d73 1
d82 4
a85 2
static DevPrivateKey DRIScreenPrivKey = &DRIScreenPrivKey;
static DevPrivateKey DRIWindowPrivKey = &DRIWindowPrivKey;
d305 12
a359 1
    DRIScreenPrivKey = &DRIScreenPrivKey;
d620 3
d676 3
d692 1
d1294 1
a1294 1
    else { /* pixmap (or for GLX 1.3, a PBuffer) */
d2322 1
a2322 1
	miPointerPosition(&px, &py);
d2327 1
a2327 1
	pScreen->SetCursorPosition(pScreen, px, py, TRUE);
d2458 1
a2458 1
	    if ((count = read(entry->fd, buf, sizeof(buf))) > 0) {
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a351 1
        DRIScreenPrivKey = NULL;
a743 1
	DRIScreenPrivKey = NULL;
@


1.1
log
@Initial revision
@
text
@d45 2
d52 1
a69 1
#include "glxserver.h"
d72 3
d80 3
a82 2
static int DRIScreenPrivIndex = -1;
static int DRIWindowPrivIndex = -1;
d90 2
d115 188
d309 1
a309 1
    int                 i, fd, drmWasAvailable;
d311 4
a314 10
    int                 err = 0;
    char                *openbusid;
    drmVersionPtr       drmlibv;
    int                 drmlibmajor, drmlibminor, drmdimajor, drmdiminor;

    if (DRIGeneration != serverGeneration) {
	if ((DRIScreenPrivIndex = AllocateScreenPrivateIndex()) < 0)
	    return FALSE;
	DRIGeneration = serverGeneration;
    }
d338 4
a341 1
    drmWasAvailable = drmAvailable();
d343 1
a343 14
    /* Check the DRM lib version.
     * drmGetLibVersion was not supported in version 1.0, so check for
     * symbol first to avoid possible crash or hang.
     */
    drmlibmajor = 1;
    drmlibminor = 0;
    if (xf86LoaderCheckSymbol("drmGetLibVersion")) {
	drmlibv = drmGetLibVersion(-1);
	if (drmlibv != NULL) {
	    drmlibmajor = drmlibv->version_major;
	    drmlibminor = drmlibv->version_minor;
	    drmFreeVersion(drmlibv);
	}
    }
d345 3
a347 24
    /* Check if the libdrm can handle falling back to loading based on name
     * if a busid string is passed.
     */
    if (drmlibmajor == 1 && drmlibminor >= 2)
	openbusid = pDRIInfo->busIdString;
    else
	openbusid = NULL;

    /* Note that drmOpen will try to load the kernel module, if needed. */
    fd = drmOpen(pDRIInfo->drmDriverName, openbusid);
    if (fd < 0) {
        /* failed to open DRM */
        pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
        DRIDrvMsg(pScreen->myNum, X_INFO,
                  "[drm] drmOpen failed\n");
        return FALSE;
    }

    if (!drmWasAvailable) {
       /* drmOpen loaded the kernel module, print a message to say so */
       DRIDrvMsg(pScreen->myNum, X_INFO,
                 "[drm] loaded kernel module for \"%s\" driver\n",
                 pDRIInfo->drmDriverName);
    }
d351 2
a352 1
        pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
d356 2
a357 2
    pScreen->devPrivates[DRIScreenPrivIndex].ptr = (pointer) pDRIPriv;
    pDRIPriv->drmFD = fd;
d361 1
d369 1
d371 1
a371 2
    if (drmlibmajor == 1 && drmlibminor >= 2) {
	drmSetVersion sv;
d373 30
a402 12
	/* Get the interface version, asking for 1.1. */
	sv.drm_di_major = 1;
	sv.drm_di_minor = 1;
	sv.drm_dd_major = -1;
	err = drmSetInterfaceVersion(pDRIPriv->drmFD, &sv);
	if (err == 0) {
	    drmdimajor = sv.drm_di_major;
	    drmdiminor = sv.drm_di_minor;
	} else {
	    /* failure, so set it to 1.0.0. */
	    drmdimajor = 1;
	    drmdiminor = 0;
d404 9
a413 7
    else {
	/* We can't check the DI DRM interface version, so set it to 1.0.0. */
	drmdimajor = 1;
	drmdiminor = 0;
    }
    DRIDrvMsg(pScreen->myNum, X_INFO,
              "[drm] DRM interface version %d.%d\n", drmdimajor, drmdiminor);
d415 2
a416 7
    /* If the interface minor number is 1.1, then we've opened a DRM device
     * that already had the busid set through drmOpen.
     */
    if (drmdimajor == 1 && drmdiminor >= 1)
	err = 0;
    else
	err = drmSetBusid(pDRIPriv->drmFD, pDRIPriv->pDriverInfo->busIdString);
d418 22
a439 8
    if (err < 0) {
	pDRIPriv->directRenderingSupport = FALSE;
	pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
	drmClose(pDRIPriv->drmFD);
        DRIDrvMsg(pScreen->myNum, X_INFO,
                  "[drm] drmSetBusid failed (%d, %s), %s\n",
                  pDRIPriv->drmFD, pDRIPriv->pDriverInfo->busIdString, strerror(-err));
	return FALSE;
d442 2
a443 23
    *pDRMFD = pDRIPriv->drmFD;
    DRIDrvMsg(pScreen->myNum, X_INFO,
	      "[drm] created \"%s\" driver at busid \"%s\"\n",
	      pDRIPriv->pDriverInfo->drmDriverName,
	      pDRIPriv->pDriverInfo->busIdString);

    if (drmAddMap( pDRIPriv->drmFD,
		   0,
		   pDRIPriv->pDriverInfo->SAREASize,
		   DRM_SHM,
		   DRM_CONTAINS_LOCK,
		   &pDRIPriv->hSAREA) < 0)
    {
	pDRIPriv->directRenderingSupport = FALSE;
	pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
	drmClose(pDRIPriv->drmFD);
        DRIDrvMsg(pScreen->myNum, X_INFO,
                  "[drm] drmAddMap failed\n");
	return FALSE;
    }
    DRIDrvMsg(pScreen->myNum, X_INFO,
	      "[drm] added %d byte SAREA at %p\n",
	      pDRIPriv->pDriverInfo->SAREASize, pDRIPriv->hSAREA);
d445 5
a449 33
    if (drmMap( pDRIPriv->drmFD,
		pDRIPriv->hSAREA,
		pDRIPriv->pDriverInfo->SAREASize,
		(drmAddressPtr)(&pDRIPriv->pSAREA)) < 0)
    {
	pDRIPriv->directRenderingSupport = FALSE;
	pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
	drmClose(pDRIPriv->drmFD);
        DRIDrvMsg(pScreen->myNum, X_INFO,
                  "[drm] drmMap failed\n");
	return FALSE;
    }
    memset(pDRIPriv->pSAREA, 0, pDRIPriv->pDriverInfo->SAREASize);
    DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] mapped SAREA %p to %p\n",
	      pDRIPriv->hSAREA, pDRIPriv->pSAREA);

    if (drmAddMap( pDRIPriv->drmFD,
		   (drm_handle_t)pDRIPriv->pDriverInfo->frameBufferPhysicalAddress,
		   pDRIPriv->pDriverInfo->frameBufferSize,
		   DRM_FRAME_BUFFER,
		   0,
		   &pDRIPriv->hFrameBuffer) < 0)
    {
	pDRIPriv->directRenderingSupport = FALSE;
	pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
	drmUnmap(pDRIPriv->pSAREA, pDRIPriv->pDriverInfo->SAREASize);
	drmClose(pDRIPriv->drmFD);
        DRIDrvMsg(pScreen->myNum, X_INFO,
                  "[drm] drmAddMap failed\n");
	return FALSE;
    }
    DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] framebuffer handle = %p\n",
	      pDRIPriv->hFrameBuffer);
d451 10
a460 11
				/* Add tags for reserved contexts */
    if ((reserved = drmGetReservedContextList(pDRIPriv->drmFD,
					      &reserved_count))) {
	int  i;
	void *tag;

	for (i = 0; i < reserved_count; i++) {
	    tag = DRICreateContextPrivFromHandle(pScreen,
						 reserved[i],
						 DRI_CONTEXT_RESERVED);
	    drmAddContextTag(pDRIPriv->drmFD, reserved[i], tag);
a461 4
	drmFreeReservedContextList(reserved);
	DRIDrvMsg(pScreen->myNum, X_INFO,
		  "[drm] added %d reserved context%s for kernel\n",
		  reserved_count, reserved_count > 1 ? "s" : "");
d479 5
a483 2
    return TRUE;
}
d485 1
a485 7
Bool
DRIFinishScreenInit(ScreenPtr pScreen)
{
    DRIScreenPrivPtr  pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIInfoPtr        pDRIInfo = pDRIPriv->pDriverInfo;
    DRIContextFlags   flags    = 0;
    DRIContextPrivPtr pDRIContextPriv;
d487 1
a487 1
				/* Set up flags for DRICreateContextPriv */
d489 6
a494 2
    case DRI_KERNEL_SWAP:    flags = DRI_CONTEXT_2DONLY;    break;
    case DRI_HIDE_X_CONTEXT: flags = DRI_CONTEXT_PRESERVED; break;
d581 9
d603 4
d634 3
d638 1
a638 1
    if (pDRIPriv && pDRIPriv->directRenderingSupport) {
d656 4
d693 4
a696 1
	if ((reserved = drmGetReservedContextList(pDRIPriv->drmFD,
d698 1
a698 1
	    int  i;
d700 8
a707 3
	    for (i = 0; i < reserved_count; i++) {
		DRIDestroyContextPriv(drmGetContextTag(pDRIPriv->drmFD,
						       reserved[i]));
a708 4
	    drmFreeReservedContextList(reserved);
	    DRIDrvMsg(pScreen->myNum, X_INFO,
		      "[drm] removed %d reserved context%s for kernel\n",
		      reserved_count, reserved_count > 1 ? "s" : "");
d713 6
a718 10
	pDRIPriv->lockRefCount = 0;
	DRIDrvMsg(pScreen->myNum, X_INFO,
		  "[drm] unmapping %d bytes of SAREA %p at %p\n",
		  pDRIInfo->SAREASize,
		  pDRIPriv->hSAREA,
		  pDRIPriv->pSAREA);
	if (drmUnmap(pDRIPriv->pSAREA, pDRIInfo->SAREASize)) {
	    DRIDrvMsg(pScreen->myNum, X_ERROR,
		      "[drm] unable to unmap %d bytes"
		      " of SAREA %p at %p\n",
d722 10
d734 8
a741 1
	drmClose(pDRIPriv->drmFD);
d744 2
a745 1
	pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
d749 20
d772 1
a772 4
    int		    	i;
    ScreenPtr		pScreen;

    if (DRIScreenPrivIndex < 0 || DRIGeneration != serverGeneration) {
a775 7
    /* Allocate a window private index with a zero sized private area for
     * each window, then should a window become a DRI window, we'll hang
     * a DRIWindowPrivateRec off of this private index.
     */
    if ((DRIWindowPrivIndex = AllocateWindowPrivateIndex()) < 0)
	return FALSE;

a778 7
    for (i = 0; i < screenInfo.numScreens; i++)
    {
	pScreen = screenInfo.screens[i];
	if (!AllocateWindowPrivate(pScreen, DRIWindowPrivIndex, 0))
	    return FALSE;
    }

a954 3
    __GLXscreen *pGLXScreen = __glXgetActiveScreen(pScreen->myNum);
    __GLcontextModes *modes = pGLXScreen->modes;
    void **pVisualConfigPriv = pGLXScreen->pVisualPriv;
a956 13
    VisualPtr visual;
    int visNum;

    visual = pScreen->visuals;

    /* Find the X visual that corresponds the the first GLX visual */
    for (visNum = 0;
	 visNum < pScreen->numVisuals;
	 visNum++, visual++) {
	if (modes->visualID == visual->vid)
	    break;
    }
    if (visNum == pScreen->numVisuals) return FALSE;
d966 1
a966 1
	if (!pDRIPriv->pDriverInfo->CreateContext(pScreen, visual,
d968 1
a968 1
						  *pVisualConfigPriv,
a1002 3
    __GLXscreen *pGLXScreen = __glXgetActiveScreen(pScreen->myNum);
    __GLcontextModes *modes = pGLXScreen->modes;
    void **pVisualConfigPriv = pGLXScreen->pVisualPriv;
a1013 12
    /* Find the GLX visual associated with the one requested */
    for (modes = pGLXScreen->modes; modes != NULL; modes = modes->next) {
	if (modes->visualID == visual->vid)
	    break;
	pVisualConfigPriv++;
    }

    if (modes == NULL) {
	/* No matching GLX visual found */
	return FALSE;
    }

d1020 2
a1021 2
	if (!((*pDRIPriv->pDriverInfo->CreateContext)(pScreen, visual,
		*pHWContext, *pVisualConfigPriv,
d1130 87
d1218 2
a1219 2
DRICreateDrawable(ScreenPtr pScreen, Drawable id,
                  DrawablePtr pDrawable, drm_drawable_t * hHWDrawable)
d1229 4
d1241 2
a1242 1
	    if (drmCreateDrawable(pDRIPriv->drmFD, hHWDrawable)) {
a1247 1
	    pDRIDrawablePriv->hwDrawable = *hHWDrawable;
d1251 1
d1254 19
a1272 16
	    pWin->devPrivates[DRIWindowPrivIndex].ptr =
						(pointer)pDRIDrawablePriv;

	    switch (++pDRIPriv->nrWindows) {
	    case 1:
	       DRITransitionTo3d( pScreen );
	       break;
	    case 2:
	       DRITransitionToSharedBuffers( pScreen );
	       break;
	    default:
	       break;
	    }

	    /* track this in case this window is destroyed */
	    AddResource(id, DRIDrawablePrivResType, (pointer)pWin);
d1283 35
a1317 2
Bool
DRIDestroyDrawable(ScreenPtr pScreen, Drawable id, DrawablePtr pDrawable)
d1319 6
a1324 2
    DRIDrawablePrivPtr	pDRIDrawablePriv;
    WindowPtr		pWin;
d1326 2
d1329 3
d1333 3
a1335 7
	pWin = (WindowPtr)pDrawable;
	pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
	pDRIDrawablePriv->refCount--;
	if (pDRIDrawablePriv->refCount <= 0) {
	    /* This calls back DRIDrawablePrivDelete which frees private area */
	    FreeResourceByType(id, DRIDrawablePrivResType, FALSE);
	}
d1348 1
a1348 4
    DrawablePtr		pDrawable = (DrawablePtr)pResource;
    DRIScreenPrivPtr	pDRIPriv = DRI_SCREEN_PRIV(pDrawable->pScreen);
    DRIDrawablePrivPtr	pDRIDrawablePriv;
    WindowPtr		pWin;
d1350 2
a1351 3
    if (pDrawable->type == DRAWABLE_WINDOW) {
	pWin = (WindowPtr)pDrawable;
	pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
d1353 2
a1354 4
	if (pDRIDrawablePriv->drawableIndex != -1) {
	    /* bump stamp to force outstanding 3D requests to resync */
	    pDRIPriv->pSAREA->drawableTable[pDRIDrawablePriv->drawableIndex].stamp
		= DRIDrawableValidationStamp++;
d1356 2
a1357 3
	    /* release drawable table entry */
	    pDRIPriv->DRIDrawables[pDRIDrawablePriv->drawableIndex] = NULL;
	}
d1359 2
a1360 6
	if (drmDestroyDrawable(pDRIPriv->drmFD,
			       pDRIDrawablePriv->hwDrawable)) {
	    return FALSE;
	}
	xfree(pDRIDrawablePriv);
	pWin->devPrivates[DRIWindowPrivIndex].ptr = NULL;
d1362 1
a1362 10
	switch (--pDRIPriv->nrWindows) {
	case 0:
	   DRITransitionTo2d( pDrawable->pScreen );
	   break;
	case 1:
	   DRITransitionToPrivateBuffers( pDrawable->pScreen );
	   break;
	default:
	   break;
	}
a1367 2

    return TRUE;
d1498 1
a1498 1
	    if (pDRIPriv->nrWindows == 1 && *numClipRects) {
d1511 12
a1522 7
	       pDRIPriv->private_buffer_rect.x1 = x0;
	       pDRIPriv->private_buffer_rect.y1 = y0;
	       pDRIPriv->private_buffer_rect.x2 = x1;
	       pDRIPriv->private_buffer_rect.y2 = y1;

	       *numBackClipRects = 1;
	       *pBackClipRects = &(pDRIPriv->private_buffer_rect);
d1553 1
a1553 1
    *hFrameBuffer = pDRIPriv->hFrameBuffer;
a1860 1
        RegionPtr reg = (RegionPtr)data;
d1862 6
a1867 1
        REGION_UNION(pScreen, reg, reg, &(pWin->clipList));
d1869 1
a1869 1
        if(pDRIPriv->nrWindows == 1)
d1875 25
d1908 1
a1908 1
    if(pDRIPriv->nrWindows > 0) {
d1912 1
d2101 1
d2108 9
d2119 4
a2177 1
    if(!pDRIPriv) return;
d2179 14
a2192 3
    if (!pDRIPriv->lockRefCount)
        DRM_LOCK(pDRIPriv->drmFD, pDRIPriv->pSAREA, pDRIPriv->myContext, flags);
    pDRIPriv->lockRefCount++;
a2198 1
    if(!pDRIPriv) return;
d2200 14
a2213 5
    if (pDRIPriv->lockRefCount > 0) {
        pDRIPriv->lockRefCount--;
    }
    else {
        ErrorF("DRIUnlock called when not locked\n");
d2216 2
a2217 2
    if (!pDRIPriv->lockRefCount)
        DRM_UNLOCK(pDRIPriv->drmFD, pDRIPriv->pSAREA, pDRIPriv->myContext);
d2238 13
d2400 1
a2400 1
DRICreatePCIBusID(pciVideoPtr PciInfo)
a2402 2
    int domain;
    PCITAG tag;
d2408 3
a2410 4
    tag = pciTag(PciInfo->bus, PciInfo->device, PciInfo->func);
    domain = xf86GetPciDomain(tag);
    snprintf(busID, 20, "pci:%04x:%02x:%02x.%d", domain, PciInfo->bus,
	PciInfo->device, PciInfo->func);
d2412 68
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.1.99.903 from X.Org 7.2RC3
@
text
@a44 1
#include <sys/ioctl.h>
a49 1
#include "xf86drm.h"
a69 1
#include "xf86_OSproc.h"
a83 2
drmServerInfo DRIDRMServerInfo;

a106 1

a573 20
#define DRM_MSG_VERBOSITY 3

static int dri_drm_debug_print(const char *format, va_list ap)
{
  xf86VDrvMsgVerb(-1, X_NONE, DRM_MSG_VERBOSITY, format, ap);
  return 0;
}

static void dri_drm_get_perms(gid_t *group, mode_t *mode)
{
  *group = xf86ConfigDRI.group;
  *mode = xf86ConfigDRI.mode;
}

drmServerInfo DRIDRMServerInfo =  {
  dri_drm_debug_print,
  xf86LoadKernelModule,
  dri_drm_get_perms,
};

a2076 68
}

static void drmSIGIOHandler(int interrupt, void *closure)
{
    unsigned long key;
    void          *value;
    ssize_t       count;
    drm_ctx_t     ctx;
    typedef void  (*_drmCallback)(int, void *, void *);
    char          buf[256];
    drm_context_t    old;
    drm_context_t    new;
    void          *oldctx;
    void          *newctx;
    char          *pt;
    drmHashEntry  *entry;
    void *hash_table;

    hash_table = drmGetHashTable();

    if (!hash_table) return;
    if (drmHashFirst(hash_table, &key, &value)) {
	entry = value;
	do {
#if 0
	    fprintf(stderr, "Trying %d\n", entry->fd);
#endif
	    if ((count = read(entry->fd, buf, sizeof(buf))) > 0) {
		buf[count] = '\0';
#if 0
		fprintf(stderr, "Got %s\n", buf);
#endif

		for (pt = buf; *pt != ' '; ++pt); /* Find first space */
		++pt;
		old    = strtol(pt, &pt, 0);
		new    = strtol(pt, NULL, 0);
		oldctx = drmGetContextTag(entry->fd, old);
		newctx = drmGetContextTag(entry->fd, new);
#if 0
		fprintf(stderr, "%d %d %p %p\n", old, new, oldctx, newctx);
#endif
		((_drmCallback)entry->f)(entry->fd, oldctx, newctx);
		ctx.handle = new;
		ioctl(entry->fd, DRM_IOCTL_NEW_CTX, &ctx);
	    }
	} while (drmHashNext(hash_table, &key, &value));
    }
}


int drmInstallSIGIOHandler(int fd, void (*f)(int, void *, void *))
{
    drmHashEntry     *entry;

    entry     = drmGetEntry(fd);
    entry->f  = f;

    return xf86InstallSIGIOHandler(fd, drmSIGIOHandler, 0);
}

int drmRemoveSIGIOHandler(int fd)
{
    drmHashEntry     *entry = drmGetEntry(fd);

    entry->f = NULL;

    return xf86RemoveSIGIOHandler(fd);
@


1.1.1.3
log
@xserver 1.4
@
text
@a45 1
#include <errno.h>
a73 2
#define PCI_BUS_NO_DOMAIN(bus) ((bus) & 0xffu)

a77 1
static int DRIEntPrivIndex = -1;
a112 187
static void
DRIOpenDRMCleanup(DRIEntPrivPtr pDRIEntPriv)
{
    if (pDRIEntPriv->pLSAREA != NULL) {
	drmUnmap(pDRIEntPriv->pLSAREA, pDRIEntPriv->sAreaSize);
	pDRIEntPriv->pLSAREA = NULL;
    }
    if (pDRIEntPriv->hLSAREA != 0) {
	drmRmMap(pDRIEntPriv->drmFD, pDRIEntPriv->hLSAREA);
    }
    if (pDRIEntPriv->drmFD >= 0) {
	drmClose(pDRIEntPriv->drmFD);
	pDRIEntPriv->drmFD = 0;
    }
}

int
DRIMasterFD(ScrnInfoPtr pScrn)
{
    return DRI_ENT_PRIV(pScrn)->drmFD;
}

void *
DRIMasterSareaPointer(ScrnInfoPtr pScrn)
{
    return DRI_ENT_PRIV(pScrn)->pLSAREA;
}

drm_handle_t
DRIMasterSareaHandle(ScrnInfoPtr pScrn)
{
    return DRI_ENT_PRIV(pScrn)->hLSAREA;
}


Bool
DRIOpenDRMMaster(ScrnInfoPtr pScrn,
		 unsigned long sAreaSize,
		 const char *busID,
		 const char *drmDriverName)
{
    drmSetVersion saveSv, sv;
    Bool drmWasAvailable;
    DRIEntPrivPtr pDRIEntPriv;
    DRIEntPrivRec tmp;
    drmVersionPtr drmlibv;
    int drmlibmajor, drmlibminor;
    const char *openBusID;
    int count;
    int err;

    if (DRIEntPrivIndex == -1)
	DRIEntPrivIndex = xf86AllocateEntityPrivateIndex();

    pDRIEntPriv = DRI_ENT_PRIV(pScrn);

    if (pDRIEntPriv && pDRIEntPriv->drmFD != -1)
	return TRUE;

    drmWasAvailable = drmAvailable();

    memset(&tmp, 0, sizeof(tmp));

    /* Check the DRM lib version.
     * drmGetLibVersion was not supported in version 1.0, so check for
     * symbol first to avoid possible crash or hang.
     */

    drmlibmajor = 1;
    drmlibminor = 0;
    if (xf86LoaderCheckSymbol("drmGetLibVersion")) {
	drmlibv = drmGetLibVersion(-1);
	if (drmlibv != NULL) {
	    drmlibmajor = drmlibv->version_major;
	    drmlibminor = drmlibv->version_minor;
	    drmFreeVersion(drmlibv);
	}
    }

    /* Check if the libdrm can handle falling back to loading based on name
     * if a busid string is passed.
     */
    openBusID = (drmlibmajor == 1 && drmlibminor >= 2) ? busID : NULL;

    tmp.drmFD = -1;
    sv.drm_di_major = 1;
    sv.drm_di_minor = 1;
    sv.drm_dd_major = -1;

    saveSv = sv;
    count = 10;
    while (count--) {
	tmp.drmFD = drmOpen(drmDriverName, openBusID);

	if (tmp.drmFD < 0) {
	    DRIDrvMsg(-1, X_ERROR, "[drm] drmOpen failed.\n");
	    goto out_err;
	}

	err = drmSetInterfaceVersion(tmp.drmFD, &sv);

	if (err != -EPERM)
	    break;

	sv = saveSv;
	drmClose(tmp.drmFD);
	tmp.drmFD = -1;
	usleep(100000);
    }

    if (tmp.drmFD <= 0) {
	DRIDrvMsg(-1, X_ERROR, "[drm] DRM was busy with another master.\n");
	goto out_err;
    }

    if (!drmWasAvailable) {
	DRIDrvMsg(-1, X_INFO,
		  "[drm] loaded kernel module for \"%s\" driver.\n",
		  drmDriverName);
    }

    if (err != 0) {
	sv.drm_di_major = 1;
	sv.drm_di_minor = 0;
    }

    DRIDrvMsg(-1, X_INFO, "[drm] DRM interface version %d.%d\n",
	      sv.drm_di_major, sv.drm_di_minor);

    if (sv.drm_di_major == 1 && sv.drm_di_minor >= 1)
	err = 0;
    else
	err = drmSetBusid(tmp.drmFD, busID);

    if (err) {
	DRIDrvMsg(-1, X_ERROR, "[drm] Could not set DRM device bus ID.\n");
	goto out_err;
    }

    /*
     * Create a lock-containing sarea.
     */

    if (drmAddMap( tmp.drmFD, 0, sAreaSize, DRM_SHM,
		   DRM_CONTAINS_LOCK, &tmp.hLSAREA) < 0) {
        DRIDrvMsg(-1, X_INFO, "[drm] Could not create SAREA for DRM lock.\n");
	tmp.hLSAREA = 0;
	goto out_err;
    }

    if (drmMap( tmp.drmFD, tmp.hLSAREA, sAreaSize,
		(drmAddressPtr)(&tmp.pLSAREA)) < 0) {
        DRIDrvMsg(-1, X_INFO, "[drm] Mapping SAREA for DRM lock failed.\n");
	tmp.pLSAREA = NULL;
	goto out_err;
    }

    memset(tmp.pLSAREA, 0, sAreaSize);

    /*
     * Reserved contexts are handled by the first opened screen.
     */

    tmp.resOwner = NULL;

    if (!pDRIEntPriv)
	pDRIEntPriv = xnfcalloc(sizeof(*pDRIEntPriv), 1);

    if (!pDRIEntPriv) {
        DRIDrvMsg(-1, X_INFO, "[drm] Failed to allocate memory for "
		  "DRM device.\n");
	goto out_err;
    }
    *pDRIEntPriv = tmp;
    xf86GetEntityPrivate((pScrn)->entityList[0],DRIEntPrivIndex)->ptr =
	pDRIEntPriv;

    DRIDrvMsg(-1, X_INFO, "[drm] DRM open master succeeded.\n");
    return TRUE;

  out_err:

    DRIOpenDRMCleanup(&tmp);
    return FALSE;
}


d119 1
a119 1
    int                 i;
d121 10
a130 4
    DRIEntPrivPtr       pDRIEntPriv;
    ScrnInfoPtr         pScrn = xf86Screens[pScreen->myNum];
    DRIContextFlags	flags    = 0;
    DRIContextPrivPtr	pDRIContextPriv;
d154 24
a177 4
    if (!DRIOpenDRMMaster(pScrn, pDRIInfo->SAREASize,
			  pDRIInfo->busIdString,
			  pDRIInfo->drmDriverName))
	return FALSE;
d179 9
a187 1
    pDRIEntPriv = DRI_ENT_PRIV(pScrn);
d189 5
a193 4
    if (DRIGeneration != serverGeneration) {
	if ((DRIScreenPrivIndex = AllocateScreenPrivateIndex()) < 0)
	    return FALSE;
	DRIGeneration = serverGeneration;
a198 1
        DRIScreenPrivIndex = -1;
d203 1
a203 1
    pDRIPriv->drmFD = pDRIEntPriv->drmFD;
a206 1
    pDRIPriv->nrWindowsVisible = 0;
a213 1
    *pDRMFD = pDRIPriv->drmFD;
d215 2
a216 1
    if (pDRIEntPriv->sAreaGrabbed || pDRIInfo->allocSarea) {
d218 12
a229 13
	if (drmAddMap( pDRIPriv->drmFD,
		       0,
		       pDRIPriv->pDriverInfo->SAREASize,
		       DRM_SHM,
		       0,
		       &pDRIPriv->hSAREA) < 0)
	{
	    pDRIPriv->directRenderingSupport = FALSE;
	    pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
	    drmClose(pDRIPriv->drmFD);
	    DRIDrvMsg(pScreen->myNum, X_INFO,
		      "[drm] drmAddMap failed\n");
	    return FALSE;
d231 16
a246 3
	DRIDrvMsg(pScreen->myNum, X_INFO,
		  "[drm] added %d byte SAREA at %p\n",
		  pDRIPriv->pDriverInfo->SAREASize, pDRIPriv->hSAREA);
d248 8
a255 22
	/* Backwards compat. */
	if (drmMap( pDRIPriv->drmFD,
		    pDRIPriv->hSAREA,
		    pDRIPriv->pDriverInfo->SAREASize,
		    (drmAddressPtr)(&pDRIPriv->pSAREA)) < 0)
	{
	    pDRIPriv->directRenderingSupport = FALSE;
	    pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
	    drmClose(pDRIPriv->drmFD);
	    DRIDrvMsg(pScreen->myNum, X_INFO,
		      "[drm] drmMap failed\n");
	    return FALSE;
	}
	DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] mapped SAREA %p to %p\n",
		  pDRIPriv->hSAREA, pDRIPriv->pSAREA);
	memset(pDRIPriv->pSAREA, 0, pDRIPriv->pDriverInfo->SAREASize);
    } else {
	DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] Using the DRM lock "
		  "SAREA also for drawables.\n");
	pDRIPriv->hSAREA = pDRIEntPriv->hLSAREA;
	pDRIPriv->pSAREA = (XF86DRISAREAPtr) pDRIEntPriv->pLSAREA;
	pDRIEntPriv->sAreaGrabbed = TRUE;
d258 23
a280 2
    pDRIPriv->hLSAREA = pDRIEntPriv->hLSAREA;
    pDRIPriv->pLSAREA = pDRIEntPriv->pLSAREA;
d282 22
a303 1
    if (!pDRIPriv->pDriverInfo->dontMapFrameBuffer)
d305 7
a311 20
	if (drmAddMap( pDRIPriv->drmFD,
		       (drm_handle_t)pDRIPriv->pDriverInfo->frameBufferPhysicalAddress,
		       pDRIPriv->pDriverInfo->frameBufferSize,
		       DRM_FRAME_BUFFER,
		       0,
		       &pDRIPriv->pDriverInfo->hFrameBuffer) < 0)
	    {
		pDRIPriv->directRenderingSupport = FALSE;
		pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
		drmUnmap(pDRIPriv->pSAREA, pDRIPriv->pDriverInfo->SAREASize);
		drmClose(pDRIPriv->drmFD);
		DRIDrvMsg(pScreen->myNum, X_INFO,
			  "[drm] drmAddMap failed\n");
		return FALSE;
	    }
	DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] framebuffer handle = %p\n",
		  pDRIPriv->pDriverInfo->hFrameBuffer);
    } else {
	DRIDrvMsg(pScreen->myNum, X_INFO,
		  "[drm] framebuffer mapped by ddx driver\n");
d313 2
d316 11
a326 19
    if (pDRIEntPriv->resOwner == NULL) {
	pDRIEntPriv->resOwner = pScreen;

	/* Add tags for reserved contexts */
	if ((reserved = drmGetReservedContextList(pDRIPriv->drmFD,
						  &reserved_count))) {
	    int  i;
	    void *tag;

	    for (i = 0; i < reserved_count; i++) {
		tag = DRICreateContextPrivFromHandle(pScreen,
						     reserved[i],
						     DRI_CONTEXT_RESERVED);
		drmAddContextTag(pDRIPriv->drmFD, reserved[i], tag);
	    }
	    drmFreeReservedContextList(reserved);
	    DRIDrvMsg(pScreen->myNum, X_INFO,
		      "[drm] added %d reserved context%s for kernel\n",
		      reserved_count, reserved_count > 1 ? "s" : "");
d328 4
d349 2
a350 2
    pDRIPriv->pLockRefCount = &pDRIEntPriv->lockRefCount;
    pDRIPriv->pLockingContext = &pDRIEntPriv->lockingContext;
d352 7
a358 2
    if (!pDRIEntPriv->keepFDOpen)
	pDRIEntPriv->keepFDOpen = pDRIInfo->keepFDOpen;
d360 1
a360 3
    pDRIEntPriv->refCount++;

    /* Set up flags for DRICreateContextPriv */
d362 2
a363 6
    case DRI_KERNEL_SWAP:
	flags = DRI_CONTEXT_2DONLY;
	break;
    case DRI_HIDE_X_CONTEXT:
	flags = DRI_CONTEXT_PRESERVED;
	break;
a449 9
    return TRUE;
}

Bool
DRIFinishScreenInit(ScreenPtr pScreen)
{
    DRIScreenPrivPtr  pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    DRIInfoPtr        pDRIInfo = pDRIPriv->pDriverInfo;

a462 4

    pDRIPriv->DestroyWindow             = pScreen->DestroyWindow;
    pScreen->DestroyWindow              = DRIDestroyWindow;

a489 3
    ScrnInfoPtr      pScrn = xf86Screens[pScreen->myNum];
    DRIEntPrivPtr    pDRIEntPriv = DRI_ENT_PRIV(pScrn);
    Bool closeMaster;
d491 1
a491 1
    if (pDRIPriv) {
a508 4
	    if (pDRIPriv->DestroyWindow) {
		pScreen->DestroyWindow          = pDRIPriv->DestroyWindow;
		pDRIPriv->DestroyWindow         = NULL;
	    }
d542 1
a542 4
	if (pDRIEntPriv->resOwner == pScreen) {
	    pDRIEntPriv->resOwner = NULL;

	    if ((reserved = drmGetReservedContextList(pDRIPriv->drmFD,
d544 1
a544 1
		int  i;
d546 3
a548 8
		for (i = 0; i < reserved_count; i++) {
		    DRIDestroyContextPriv(drmGetContextTag(pDRIPriv->drmFD,
							   reserved[i]));
		}
		drmFreeReservedContextList(reserved);
		DRIDrvMsg(pScreen->myNum, X_INFO,
			  "[drm] removed %d reserved context%s for kernel\n",
			  reserved_count, reserved_count > 1 ? "s" : "");
d550 4
d558 10
a567 6
	pDRIPriv->pLockRefCount = NULL;
	closeMaster = (--pDRIEntPriv->refCount == 0) &&
	    !pDRIEntPriv->keepFDOpen;
	if (closeMaster || pDRIPriv->hSAREA != pDRIEntPriv->hLSAREA) {
	    DRIDrvMsg(pScreen->myNum, X_INFO,
		      "[drm] unmapping %d bytes of SAREA %p at %p\n",
a570 10
	    if (drmUnmap(pDRIPriv->pSAREA, pDRIInfo->SAREASize)) {
		DRIDrvMsg(pScreen->myNum, X_ERROR,
			  "[drm] unable to unmap %d bytes"
			  " of SAREA %p at %p\n",
			  pDRIInfo->SAREASize,
			  pDRIPriv->hSAREA,
			  pDRIPriv->pSAREA);
	    }
	} else {
	    pDRIEntPriv->sAreaGrabbed = FALSE;
d573 1
a573 8
	if (closeMaster || (pDRIEntPriv->drmFD != pDRIPriv->drmFD)) {
	    drmClose(pDRIPriv->drmFD);
	    if (pDRIEntPriv->drmFD == pDRIPriv->drmFD) {
		DRIDrvMsg(pScreen->myNum, X_INFO,
			  "[drm] Closed DRM master.\n");
		pDRIEntPriv->drmFD = -1;
	    }
	}
a576 1
	DRIScreenPrivIndex = -1;
a1008 87
static int
DRIDCNTreeTraversal(WindowPtr pWin, pointer data)
{
    DRIDrawablePrivPtr pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);

    if (pDRIDrawablePriv) {
	ScreenPtr pScreen = pWin->drawable.pScreen;
	DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

	if (REGION_NUM_RECTS(&pWin->clipList) > 0) {
	    WindowPtr *pDRIWindows = (WindowPtr*)data;
	    int i = 0;

	    while (pDRIWindows[i])
		i++;

	    pDRIWindows[i] = pWin;

	    pDRIPriv->nrWalked++;
	}

	if (pDRIPriv->nrWindows == pDRIPriv->nrWalked)
	    return WT_STOPWALKING;
    }

    return WT_WALKCHILDREN;
}

static void
DRIDriverClipNotify(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (pDRIPriv->pDriverInfo->ClipNotify) {
	WindowPtr *pDRIWindows = xcalloc(sizeof(WindowPtr), pDRIPriv->nrWindows);
	DRIInfoPtr pDRIInfo = pDRIPriv->pDriverInfo;

	if (pDRIPriv->nrWindows > 0) {
	    pDRIPriv->nrWalked = 0;
	    TraverseTree(WindowTable[pScreen->myNum], DRIDCNTreeTraversal,
			 (pointer)pDRIWindows);
	}

	pDRIInfo->ClipNotify(pScreen, pDRIWindows, pDRIPriv->nrWindows);

	xfree(pDRIWindows);
    }
}

static void
DRIIncreaseNumberVisible(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    switch (++pDRIPriv->nrWindowsVisible) {
    case 1:
	DRITransitionTo3d( pScreen );
	break;
    case 2:
	DRITransitionToSharedBuffers( pScreen );
	break;
    default:
	break;
    }

    DRIDriverClipNotify(pScreen);
}

static void
DRIDecreaseNumberVisible(ScreenPtr pScreen)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    switch (--pDRIPriv->nrWindowsVisible) {
    case 0:
	DRITransitionTo2d( pScreen );
	break;
    case 1:
	DRITransitionToPrivateBuffers( pScreen );
	break;
    default:
	break;
    }

    DRIDriverClipNotify(pScreen);
}

d1010 2
a1011 2
DRICreateDrawable(ScreenPtr pScreen, ClientPtr client, DrawablePtr pDrawable,
		  drm_drawable_t * hHWDrawable)
a1020 4

	    if (!pDRIDrawablePriv->hwDrawable) {
		drmCreateDrawable(pDRIPriv->drmFD, &pDRIDrawablePriv->hwDrawable);
	    }
d1029 1
a1029 2
	    if (drmCreateDrawable(pDRIPriv->drmFD,
				  &pDRIDrawablePriv->hwDrawable)) {
d1035 1
a1038 1
	    pDRIDrawablePriv->nrects = REGION_NUM_RECTS(&pWin->clipList);
d1044 10
a1053 1
	    pDRIPriv->nrWindows++;
d1055 2
a1056 15
	    if (pDRIDrawablePriv->nrects)
		DRIIncreaseNumberVisible(pScreen);
	}

	/* track this in case the client dies */
	AddResource(FakeClientID(client->index), DRIDrawablePrivResType,
		    (pointer)pDrawable->id);

	if (pDRIDrawablePriv->hwDrawable) {
	    drmUpdateDrawableInfo(pDRIPriv->drmFD,
				  pDRIDrawablePriv->hwDrawable,
				  DRM_DRAWABLE_CLIPRECTS,
				  REGION_NUM_RECTS(&pWin->clipList),
				  REGION_RECTS(&pWin->clipList));
	    *hHWDrawable = pDRIDrawablePriv->hwDrawable;
d1067 2
a1068 2
static void
DRIDrawablePrivDestroy(WindowPtr pWin)
d1070 2
a1071 18
    DRIDrawablePrivPtr pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
    ScreenPtr pScreen;
    DRIScreenPrivPtr pDRIPriv;

    if (!pDRIDrawablePriv)
	return;

    pScreen = pWin->drawable.pScreen;
    pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (pDRIDrawablePriv->drawableIndex != -1) {
	/* bump stamp to force outstanding 3D requests to resync */
	pDRIPriv->pSAREA->drawableTable[pDRIDrawablePriv->drawableIndex].stamp
	    = DRIDrawableValidationStamp++;

	/* release drawable table entry */
	pDRIPriv->DRIDrawables[pDRIDrawablePriv->drawableIndex] = NULL;
    }
a1072 1
    pDRIPriv->nrWindows--;
a1073 25
    if (pDRIDrawablePriv->nrects)
	DRIDecreaseNumberVisible(pScreen);

    drmDestroyDrawable(pDRIPriv->drmFD, pDRIDrawablePriv->hwDrawable);

    xfree(pDRIDrawablePriv);
    pWin->devPrivates[DRIWindowPrivIndex].ptr = NULL;
}

static Bool
DRIDestroyDrawableCB(pointer value, XID id, pointer data)
{
    if (value == data) {
	/* This calls back DRIDrawablePrivDelete which frees private area */
	FreeResourceByType(id, DRIDrawablePrivResType, FALSE);

	return TRUE;
    }

    return FALSE;
}

Bool
DRIDestroyDrawable(ScreenPtr pScreen, ClientPtr client, DrawablePtr pDrawable)
{
d1075 7
a1081 3
	LookupClientResourceComplex(client, DRIDrawablePrivResType,
				    DRIDestroyDrawableCB,
				    (pointer)pDrawable->id);
d1094 4
a1097 1
    WindowPtr pWin;
d1099 3
a1101 2
    id = (XID)pResource;
    pWin = LookupIDByType(id, RT_WINDOW);
d1103 4
a1106 2
    if (pWin) {
	DRIDrawablePrivPtr pDRIDrwPriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
d1108 6
a1113 1
	if (!pDRIDrwPriv)
d1115 3
d1119 10
a1128 4
	if (--pDRIDrwPriv->refCount == 0)
	    DRIDrawablePrivDestroy(pWin);

	return TRUE;
d1134 2
d1266 1
a1266 1
	    if (pDRIPriv->nrWindowsVisible == 1 && *numClipRects) {
d1279 7
a1285 12
	       if (y0 >= y1 || x0 >= x1) {
		    *numBackClipRects = 0;
		    *pBackClipRects = NULL;
	       } else {
		    pDRIPriv->private_buffer_rect.x1 = x0;
		    pDRIPriv->private_buffer_rect.y1 = y0;
		    pDRIPriv->private_buffer_rect.x2 = x1;
		    pDRIPriv->private_buffer_rect.y2 = y1;

		    *numBackClipRects = 1;
		    *pBackClipRects = &(pDRIPriv->private_buffer_rect);
	       }
d1316 1
a1316 1
    *hFrameBuffer = pDRIPriv->pDriverInfo->hFrameBuffer;
d1624 1
d1626 1
a1626 2
	if(REGION_NUM_RECTS(&(pWin->clipList)) > 0) {
	   RegionPtr reg = (RegionPtr)data;
d1628 1
a1628 5
	   REGION_UNION(pScreen, reg, reg, &(pWin->clipList));
	   pDRIPriv->nrWalked++;
	}

	if(pDRIPriv->nrWindows == pDRIPriv->nrWalked)
a1633 25
Bool
DRIDestroyWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
    Bool retval = TRUE;

    DRIDrawablePrivDestroy(pWin);

    /* call lower wrapped functions */
    if(pDRIPriv->DestroyWindow) {
	/* unwrap */
	pScreen->DestroyWindow = pDRIPriv->DestroyWindow;

	/* call lower layers */
	retval = (*pScreen->DestroyWindow)(pWin);

	/* rewrap */
	pDRIPriv->DestroyWindow = pScreen->DestroyWindow;
	pScreen->DestroyWindow = DRIDestroyWindow;
    }

    return retval;
}

d1642 1
a1642 1
    if(pDRIPriv->nrWindowsVisible > 0) {
a1645 1
       pDRIPriv->nrWalked = 0;
a1833 1
        int nrects = REGION_NUM_RECTS(&pWin->clipList);
a1839 9
	if (nrects && !pDRIDrawablePriv->nrects)
	    DRIIncreaseNumberVisible(pScreen);
	else if (!nrects && pDRIDrawablePriv->nrects)
	    DRIDecreaseNumberVisible(pScreen);
	else
	    DRIDriverClipNotify(pScreen);

	pDRIDrawablePriv->nrects = nrects;

a1841 4

	drmUpdateDrawableInfo(pDRIPriv->drmFD, pDRIDrawablePriv->hwDrawable,
			      DRM_DRAWABLE_CLIPRECTS,
			      nrects, REGION_RECTS(&pWin->clipList));
d1897 1
d1899 3
a1901 14
    if(!pDRIPriv || !pDRIPriv->pLockRefCount) return;

    if (!*pDRIPriv->pLockRefCount) {
        DRM_LOCK(pDRIPriv->drmFD, pDRIPriv->pLSAREA, pDRIPriv->myContext, flags);
	*pDRIPriv->pLockingContext = pDRIPriv->myContext;
    } else if (*pDRIPriv->pLockingContext != pDRIPriv->myContext) {
	DRIDrvMsg(pScreen->myNum, X_ERROR,
		  "[DRI] Locking deadlock.\n"
		  "\tAlready locked with context %d,\n"
		  "\ttrying to lock with context %d.\n",
		  pDRIPriv->pLockingContext,
		  pDRIPriv->myContext);
    }
    (*pDRIPriv->pLockRefCount)++;
d1908 1
d1910 5
a1914 14
    if(!pDRIPriv || !pDRIPriv->pLockRefCount) return;

    if (*pDRIPriv->pLockRefCount > 0) {
	if (pDRIPriv->myContext != *pDRIPriv->pLockingContext) {
	    DRIDrvMsg(pScreen->myNum, X_ERROR,
		      "[DRI] Unlocking inconsistency:\n"
		      "\tContext %d trying to unlock lock held by context %d\n",
		      pDRIPriv->pLockingContext,
		      pDRIPriv->myContext);
	}
	(*pDRIPriv->pLockRefCount)--;
    } else {
        DRIDrvMsg(pScreen->myNum, X_ERROR,
		  "DRIUnlock called when not locked.\n");
d1917 2
a1918 2
    if (! *pDRIPriv->pLockRefCount)
        DRM_UNLOCK(pDRIPriv->drmFD, pDRIPriv->pLSAREA, pDRIPriv->myContext);
a1938 13
void
DRIGetTexOffsetFuncs(ScreenPtr pScreen,
		     DRITexOffsetStartProcPtr *texOffsetStartFunc,
		     DRITexOffsetFinishProcPtr *texOffsetFinishFunc)
{
    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);

    if (!pDRIPriv) return;

    *texOffsetStartFunc  = pDRIPriv->pDriverInfo->texOffsetStart;
    *texOffsetFinishFunc = pDRIPriv->pDriverInfo->texOffsetFinish;
}

d2100 2
a2101 2
    snprintf(busID, 20, "pci:%04x:%02x:%02x.%d", domain,
	PCI_BUS_NO_DOMAIN(PciInfo->bus), PciInfo->device, PciInfo->func);
@


