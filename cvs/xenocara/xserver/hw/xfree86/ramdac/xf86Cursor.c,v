head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.29.12.02.38;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	s0SI41sEunLdyFfd;

1.12
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2014.05.02.19.27.49;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.09.28.15.36.35;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.27;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.35;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.35;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.58.17;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "xf86.h"
#include "xf86CursorPriv.h"
#include "colormapst.h"
#include "cursorstr.h"

/* FIXME: This was added with the ABI change of the miPointerSpriteFuncs for
 * MPX.
 * inputInfo is needed to pass the core pointer as the default argument into
 * the cursor functions.
 *
 * Externing inputInfo is not the nice way to do it but it works.
 */
#include "inputstr.h"

DevPrivateKeyRec xf86CursorScreenKeyRec;

/* sprite functions */

static Bool xf86CursorRealizeCursor(DeviceIntPtr, ScreenPtr, CursorPtr);
static Bool xf86CursorUnrealizeCursor(DeviceIntPtr, ScreenPtr, CursorPtr);
static void xf86CursorSetCursor(DeviceIntPtr, ScreenPtr, CursorPtr, int, int);
static void xf86CursorMoveCursor(DeviceIntPtr, ScreenPtr, int, int);
static Bool xf86DeviceCursorInitialize(DeviceIntPtr, ScreenPtr);
static void xf86DeviceCursorCleanup(DeviceIntPtr, ScreenPtr);

static miPointerSpriteFuncRec xf86CursorSpriteFuncs = {
    xf86CursorRealizeCursor,
    xf86CursorUnrealizeCursor,
    xf86CursorSetCursor,
    xf86CursorMoveCursor,
    xf86DeviceCursorInitialize,
    xf86DeviceCursorCleanup
};

/* Screen functions */

static void xf86CursorInstallColormap(ColormapPtr);
static void xf86CursorRecolorCursor(DeviceIntPtr pDev, ScreenPtr, CursorPtr,
                                    Bool);
static Bool xf86CursorCloseScreen(ScreenPtr);
static void xf86CursorQueryBestSize(int, unsigned short *, unsigned short *,
                                    ScreenPtr);

/* ScrnInfoRec functions */

static void xf86CursorEnableDisableFBAccess(ScrnInfoPtr, Bool);
static Bool xf86CursorSwitchMode(ScrnInfoPtr, DisplayModePtr);

Bool
xf86InitCursor(ScreenPtr pScreen, xf86CursorInfoPtr infoPtr)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CursorScreenPtr ScreenPriv;
    miPointerScreenPtr PointPriv;

    if (!xf86InitHardwareCursor(pScreen, infoPtr))
        return FALSE;

    if (!dixRegisterPrivateKey(&xf86CursorScreenKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    ScreenPriv = calloc(1, sizeof(xf86CursorScreenRec));
    if (!ScreenPriv)
        return FALSE;

    dixSetPrivate(&pScreen->devPrivates, xf86CursorScreenKey, ScreenPriv);

    ScreenPriv->SWCursor = TRUE;
    ScreenPriv->isUp = FALSE;
    ScreenPriv->CurrentCursor = NULL;
    ScreenPriv->CursorInfoPtr = infoPtr;
    ScreenPriv->PalettedCursor = FALSE;
    ScreenPriv->pInstalledMap = NULL;

    ScreenPriv->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = xf86CursorCloseScreen;
    ScreenPriv->QueryBestSize = pScreen->QueryBestSize;
    pScreen->QueryBestSize = xf86CursorQueryBestSize;
    ScreenPriv->RecolorCursor = pScreen->RecolorCursor;
    pScreen->RecolorCursor = xf86CursorRecolorCursor;

    if ((infoPtr->pScrn->bitsPerPixel == 8) &&
        !(infoPtr->Flags & HARDWARE_CURSOR_TRUECOLOR_AT_8BPP)) {
        ScreenPriv->InstallColormap = pScreen->InstallColormap;
        pScreen->InstallColormap = xf86CursorInstallColormap;
        ScreenPriv->PalettedCursor = TRUE;
    }

    PointPriv = dixLookupPrivate(&pScreen->devPrivates, miPointerScreenKey);

    ScreenPriv->showTransparent = PointPriv->showTransparent;
    if (infoPtr->Flags & HARDWARE_CURSOR_SHOW_TRANSPARENT)
        PointPriv->showTransparent = TRUE;
    else
        PointPriv->showTransparent = FALSE;
    ScreenPriv->spriteFuncs = PointPriv->spriteFuncs;
    PointPriv->spriteFuncs = &xf86CursorSpriteFuncs;

    ScreenPriv->EnableDisableFBAccess = pScrn->EnableDisableFBAccess;
    ScreenPriv->SwitchMode = pScrn->SwitchMode;

    ScreenPriv->ForceHWCursorCount = 0;
    ScreenPriv->HWCursorForced = FALSE;

    pScrn->EnableDisableFBAccess = xf86CursorEnableDisableFBAccess;
    if (pScrn->SwitchMode)
        pScrn->SwitchMode = xf86CursorSwitchMode;

    return TRUE;
}

/***** Screen functions *****/

static Bool
xf86CursorCloseScreen(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    miPointerScreenPtr PointPriv =
        (miPointerScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                              miPointerScreenKey);
    xf86CursorScreenPtr ScreenPriv =
        (xf86CursorScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               xf86CursorScreenKey);

    if (ScreenPriv->isUp && pScrn->vtSema)
        xf86SetCursor(pScreen, NullCursor, ScreenPriv->x, ScreenPriv->y);

    if (ScreenPriv->CurrentCursor)
        FreeCursor(ScreenPriv->CurrentCursor, None);

    pScreen->CloseScreen = ScreenPriv->CloseScreen;
    pScreen->QueryBestSize = ScreenPriv->QueryBestSize;
    pScreen->RecolorCursor = ScreenPriv->RecolorCursor;
    if (ScreenPriv->InstallColormap)
        pScreen->InstallColormap = ScreenPriv->InstallColormap;

    PointPriv->spriteFuncs = ScreenPriv->spriteFuncs;
    PointPriv->showTransparent = ScreenPriv->showTransparent;

    pScrn->EnableDisableFBAccess = ScreenPriv->EnableDisableFBAccess;
    pScrn->SwitchMode = ScreenPriv->SwitchMode;

    free(ScreenPriv->transparentData);
    free(ScreenPriv);

    return (*pScreen->CloseScreen) (pScreen);
}

static void
xf86CursorQueryBestSize(int class,
                        unsigned short *width,
                        unsigned short *height, ScreenPtr pScreen)
{
    xf86CursorScreenPtr ScreenPriv =
        (xf86CursorScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               xf86CursorScreenKey);

    if (class == CursorShape) {
        if (*width > ScreenPriv->CursorInfoPtr->MaxWidth)
            *width = ScreenPriv->CursorInfoPtr->MaxWidth;
        if (*height > ScreenPriv->CursorInfoPtr->MaxHeight)
            *height = ScreenPriv->CursorInfoPtr->MaxHeight;
    }
    else
        (*ScreenPriv->QueryBestSize) (class, width, height, pScreen);
}

static void
xf86CursorInstallColormap(ColormapPtr pMap)
{
    xf86CursorScreenPtr ScreenPriv =
        (xf86CursorScreenPtr) dixLookupPrivate(&pMap->pScreen->devPrivates,
                                               xf86CursorScreenKey);

    ScreenPriv->pInstalledMap = pMap;

    (*ScreenPriv->InstallColormap) (pMap);
}

static void
xf86CursorRecolorCursor(DeviceIntPtr pDev,
                        ScreenPtr pScreen, CursorPtr pCurs, Bool displayed)
{
    xf86CursorScreenPtr ScreenPriv =
        (xf86CursorScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               xf86CursorScreenKey);

    if (!displayed)
        return;

    if (ScreenPriv->SWCursor)
        (*ScreenPriv->RecolorCursor) (pDev, pScreen, pCurs, displayed);
    else
        xf86RecolorCursor(pScreen, pCurs, displayed);
}

/***** ScrnInfoRec functions *********/

static void
xf86CursorEnableDisableFBAccess(ScrnInfoPtr pScrn, Bool enable)
{
    DeviceIntPtr pDev = inputInfo.pointer;

    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    xf86CursorScreenPtr ScreenPriv =
        (xf86CursorScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               xf86CursorScreenKey);

    if (!enable && ScreenPriv->CurrentCursor != NullCursor) {
        CursorPtr currentCursor = ScreenPriv->CurrentCursor;

        xf86CursorSetCursor(pDev, pScreen, NullCursor, ScreenPriv->x,
                            ScreenPriv->y);
        ScreenPriv->isUp = FALSE;
        ScreenPriv->SWCursor = TRUE;
        ScreenPriv->SavedCursor = currentCursor;
    }

    if (ScreenPriv->EnableDisableFBAccess)
        (*ScreenPriv->EnableDisableFBAccess) (pScrn, enable);

    if (enable && ScreenPriv->SavedCursor) {
        /*
         * Re-set current cursor so drivers can react to FB access having been
         * temporarily disabled.
         */
        xf86CursorSetCursor(pDev, pScreen, ScreenPriv->SavedCursor,
                            ScreenPriv->x, ScreenPriv->y);
        ScreenPriv->SavedCursor = NULL;
    }
}

static Bool
xf86CursorSwitchMode(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    Bool ret;
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    xf86CursorScreenPtr ScreenPriv =
        (xf86CursorScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               xf86CursorScreenKey);

    if (ScreenPriv->isUp) {
        xf86SetCursor(pScreen, NullCursor, ScreenPriv->x, ScreenPriv->y);
        ScreenPriv->isUp = FALSE;
    }

    ret = (*ScreenPriv->SwitchMode) (pScrn, mode);

    /*
     * Cannot restore cursor here because the new frame[XY][01] haven't been
     * calculated yet.  However, because the hardware cursor was removed above,
     * ensure the cursor is repainted by miPointerWarpCursor().
     */
    ScreenPriv->CursorToRestore = ScreenPriv->CurrentCursor;
    miPointerSetWaitForUpdate(pScreen, FALSE);  /* Force cursor repaint */

    return ret;
}

/****** miPointerSpriteFunctions *******/

static Bool
xf86CursorRealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCurs)
{
    xf86CursorScreenPtr ScreenPriv =
        (xf86CursorScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               xf86CursorScreenKey);

    if (CursorRefCount(pCurs) <= 1)
        dixSetScreenPrivate(&pCurs->devPrivates, CursorScreenKey, pScreen,
                            NULL);

    return (*ScreenPriv->spriteFuncs->RealizeCursor) (pDev, pScreen, pCurs);
}

static Bool
xf86CursorUnrealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCurs)
{
    xf86CursorScreenPtr ScreenPriv =
        (xf86CursorScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               xf86CursorScreenKey);

    if (CursorRefCount(pCurs) <= 1) {
        free(dixLookupScreenPrivate
             (&pCurs->devPrivates, CursorScreenKey, pScreen));
        dixSetScreenPrivate(&pCurs->devPrivates, CursorScreenKey, pScreen,
                            NULL);
    }

    return (*ScreenPriv->spriteFuncs->UnrealizeCursor) (pDev, pScreen, pCurs);
}

static void
xf86CursorSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCurs,
                    int x, int y)
{
    xf86CursorScreenPtr ScreenPriv =
        (xf86CursorScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               xf86CursorScreenKey);
    xf86CursorInfoPtr infoPtr = ScreenPriv->CursorInfoPtr;

    if (pCurs == NullCursor) {  /* means we're supposed to remove the cursor */
        if (ScreenPriv->SWCursor ||
            !(GetMaster(pDev, MASTER_POINTER) == inputInfo.pointer))
            (*ScreenPriv->spriteFuncs->SetCursor) (pDev, pScreen, NullCursor, x,
                                                   y);
        else if (ScreenPriv->isUp) {
            xf86SetCursor(pScreen, NullCursor, x, y);
            ScreenPriv->isUp = FALSE;
        }
        if (ScreenPriv->CurrentCursor)
            FreeCursor(ScreenPriv->CurrentCursor, None);
        ScreenPriv->CurrentCursor = NullCursor;
        return;
    }

    /* only update for VCP, otherwise we get cursor jumps when removing a
       sprite. The second cursor is never HW rendered anyway. */
    if (GetMaster(pDev, MASTER_POINTER) == inputInfo.pointer) {
        CursorPtr cursor = RefCursor(pCurs);
        if (ScreenPriv->CurrentCursor)
            FreeCursor(ScreenPriv->CurrentCursor, None);
        ScreenPriv->CurrentCursor = cursor;
        ScreenPriv->x = x;
        ScreenPriv->y = y;
        ScreenPriv->CursorToRestore = NULL;
        ScreenPriv->HotX = cursor->bits->xhot;
        ScreenPriv->HotY = cursor->bits->yhot;

        if (!infoPtr->pScrn->vtSema) {
            ScreenPriv->SavedCursor = cursor;
            return;
        }

        if (infoPtr->pScrn->vtSema && xorg_list_is_empty(&pScreen->pixmap_dirty_list) &&
            (ScreenPriv->ForceHWCursorCount ||
             ((
               cursor->bits->argb &&
               infoPtr->UseHWCursorARGB &&
               (*infoPtr->UseHWCursorARGB)(pScreen, cursor)) ||
              (cursor->bits->argb == 0 &&
               (cursor->bits->height <= infoPtr->MaxHeight) &&
               (cursor->bits->width <= infoPtr->MaxWidth) &&
               (!infoPtr->UseHWCursor || (*infoPtr->UseHWCursor) (pScreen, cursor)))))) {

            if (ScreenPriv->SWCursor)   /* remove the SW cursor */
                (*ScreenPriv->spriteFuncs->SetCursor) (pDev, pScreen,
                                                       NullCursor, x, y);

            if (xf86SetCursor(pScreen, cursor, x, y)) {
                ScreenPriv->SWCursor = FALSE;
                ScreenPriv->isUp = TRUE;

                miPointerSetWaitForUpdate(pScreen, !infoPtr->pScrn->silkenMouse);
                return;
            }
        }

        miPointerSetWaitForUpdate(pScreen, TRUE);

        if (ScreenPriv->isUp) {
            /* Remove the HW cursor, or make it transparent */
            if (infoPtr->Flags & HARDWARE_CURSOR_SHOW_TRANSPARENT) {
                xf86SetTransparentCursor(pScreen);
            }
            else {
                xf86SetCursor(pScreen, NullCursor, x, y);
                ScreenPriv->isUp = FALSE;
            }
        }

        if (!ScreenPriv->SWCursor)
            ScreenPriv->SWCursor = TRUE;

    }

    if (pCurs->bits->emptyMask && !ScreenPriv->showTransparent)
        pCurs = NullCursor;

    (*ScreenPriv->spriteFuncs->SetCursor) (pDev, pScreen, pCurs, x, y);
}

/* Re-set the current cursor. This will switch between hardware and software
 * cursor depending on whether hardware cursor is currently supported
 * according to the driver.
 */
void
xf86CursorResetCursor(ScreenPtr pScreen)
{
    xf86CursorScreenPtr ScreenPriv;

    if (!inputInfo.pointer)
        return;

    if (!dixPrivateKeyRegistered(xf86CursorScreenKey))
        return;

    ScreenPriv = (xf86CursorScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                        xf86CursorScreenKey);
    if (!ScreenPriv)
        return;

    xf86CursorSetCursor(inputInfo.pointer, pScreen, ScreenPriv->CurrentCursor,
                        ScreenPriv->x, ScreenPriv->y);
}

static void
xf86CursorMoveCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
{
    xf86CursorScreenPtr ScreenPriv =
        (xf86CursorScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               xf86CursorScreenKey);

    /* only update coordinate state for first sprite, otherwise we get jumps
       when removing a sprite. The second sprite is never HW rendered anyway */
    if (GetMaster(pDev, MASTER_POINTER) == inputInfo.pointer) {
        ScreenPriv->x = x;
        ScreenPriv->y = y;

        if (ScreenPriv->CursorToRestore)
            xf86CursorSetCursor(pDev, pScreen, ScreenPriv->CursorToRestore, x,
                                y);
        else if (ScreenPriv->SWCursor)
            (*ScreenPriv->spriteFuncs->MoveCursor) (pDev, pScreen, x, y);
        else if (ScreenPriv->isUp)
            xf86MoveCursor(pScreen, x, y);
    }
    else
        (*ScreenPriv->spriteFuncs->MoveCursor) (pDev, pScreen, x, y);
}

void
xf86ForceHWCursor(ScreenPtr pScreen, Bool on)
{
    DeviceIntPtr pDev = inputInfo.pointer;
    xf86CursorScreenPtr ScreenPriv =
        (xf86CursorScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               xf86CursorScreenKey);

    if (on) {
        if (ScreenPriv->ForceHWCursorCount++ == 0) {
            if (ScreenPriv->SWCursor && ScreenPriv->CurrentCursor) {
                ScreenPriv->HWCursorForced = TRUE;
                xf86CursorSetCursor(pDev, pScreen, ScreenPriv->CurrentCursor,
                                    ScreenPriv->x, ScreenPriv->y);
            }
            else
                ScreenPriv->HWCursorForced = FALSE;
        }
    }
    else {
        if (--ScreenPriv->ForceHWCursorCount == 0) {
            if (ScreenPriv->HWCursorForced && ScreenPriv->CurrentCursor)
                xf86CursorSetCursor(pDev, pScreen, ScreenPriv->CurrentCursor,
                                    ScreenPriv->x, ScreenPriv->y);
        }
    }
}

xf86CursorInfoPtr
xf86CreateCursorInfoRec(void)
{
    return calloc(1, sizeof(xf86CursorInfoRec));
}

void
xf86DestroyCursorInfoRec(xf86CursorInfoPtr infoPtr)
{
    free(infoPtr);
}

/**
 * New cursor has been created. Do your initalizations here.
 */
static Bool
xf86DeviceCursorInitialize(DeviceIntPtr pDev, ScreenPtr pScreen)
{
    int ret;
    xf86CursorScreenPtr ScreenPriv =
        (xf86CursorScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               xf86CursorScreenKey);

    /* Init SW cursor */
    ret = (*ScreenPriv->spriteFuncs->DeviceCursorInitialize) (pDev, pScreen);

    return ret;
}

/**
 * Cursor has been removed. Clean up after yourself.
 */
static void
xf86DeviceCursorCleanup(DeviceIntPtr pDev, ScreenPtr pScreen)
{
    xf86CursorScreenPtr ScreenPriv =
        (xf86CursorScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               xf86CursorScreenKey);

    /* Clean up SW cursor */
    (*ScreenPriv->spriteFuncs->DeviceCursorCleanup) (pDev, pScreen);
}
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a342 1
#ifdef ARGB_CURSOR
a346 1
#endif
d386 24
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d335 1
a335 1
        if (!infoPtr->pScrn->vtSema)
d337 2
d352 1
a352 1
            
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d355 3
a357 3
            xf86SetCursor(pScreen, cursor, x, y);
            ScreenPriv->SWCursor = FALSE;
            ScreenPriv->isUp = TRUE;
d359 3
a361 2
            miPointerSetWaitForUpdate(pScreen, !infoPtr->pScrn->silkenMouse);
            return;
@


1.9
log
@Update to xserver 1.14.3
@
text
@a18 1
extern InputInfo inputInfo;
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d275 1
a275 1
    if (pCurs->refcnt <= 1)
d289 1
a289 1
    if (pCurs->refcnt <= 1) {
d326 1
a326 1
        pCurs->refcnt++;
d329 1
a329 1
        ScreenPriv->CurrentCursor = pCurs;
d333 2
a334 2
        ScreenPriv->HotX = pCurs->bits->xhot;
        ScreenPriv->HotY = pCurs->bits->yhot;
d337 1
a337 1
            ScreenPriv->SavedCursor = pCurs;
d343 1
a343 1
               pCurs->bits->argb &&
d345 2
a346 2
               (*infoPtr->UseHWCursorARGB)(pScreen, pCurs)) ||
              (pCurs->bits->argb == 0 &&
d348 3
a350 3
               (pCurs->bits->height <= infoPtr->MaxHeight) &&
               (pCurs->bits->width <= infoPtr->MaxWidth) &&
               (!infoPtr->UseHWCursor || (*infoPtr->UseHWCursor) (pScreen, pCurs)))))) {
d356 1
a356 1
            xf86SetCursor(pScreen, pCurs, x, y);
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d46 1
a46 1
static Bool xf86CursorCloseScreen(int, ScreenPtr);
d52 2
a53 2
static void xf86CursorEnableDisableFBAccess(int, Bool);
static Bool xf86CursorSwitchMode(int, DisplayModePtr, int);
d58 1
a58 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d121 1
a121 1
xf86CursorCloseScreen(int i, ScreenPtr pScreen)
d123 1
a123 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d152 1
a152 1
    return (*pScreen->CloseScreen) (i, pScreen);
d206 1
a206 1
xf86CursorEnableDisableFBAccess(int index, Bool enable)
d210 1
a210 1
    ScreenPtr pScreen = screenInfo.screens[index];
d226 1
a226 1
        (*ScreenPriv->EnableDisableFBAccess) (index, enable);
d240 1
a240 1
xf86CursorSwitchMode(int index, DisplayModePtr mode, int flags)
d243 1
a243 1
    ScreenPtr pScreen = screenInfo.screens[index];
d253 1
a253 1
    ret = (*ScreenPriv->SwitchMode) (index, mode, flags);
d339 3
a341 1
        if (infoPtr->pScrn->vtSema && (ScreenPriv->ForceHWCursorCount || ((
d343 4
a346 17
                                                                              pCurs->
                                                                              bits->
                                                                              argb
                                                                              &&
                                                                              infoPtr->
                                                                              UseHWCursorARGB
                                                                              &&
                                                                              (*infoPtr->
                                                                               UseHWCursorARGB)
                                                                              (pScreen,
                                                                               pCurs))
                                                                          ||
                                                                          (pCurs->
                                                                           bits->
                                                                           argb
                                                                           == 0
                                                                           &&
d348 4
a351 2
                                                                           (pCurs->bits->height <= infoPtr->MaxHeight) && (pCurs->bits->width <= infoPtr->MaxWidth) && (!infoPtr->UseHWCursor || (*infoPtr->UseHWCursor) (pScreen, pCurs)))))) {

@


1.6
log
@Update to xserver 1.11.2
@
text
@d33 6
a38 6
   xf86CursorRealizeCursor,
   xf86CursorUnrealizeCursor,
   xf86CursorSetCursor,
   xf86CursorMoveCursor,
   xf86DeviceCursorInitialize,
   xf86DeviceCursorCleanup
d44 2
a45 1
static void xf86CursorRecolorCursor(DeviceIntPtr pDev, ScreenPtr, CursorPtr, Bool);
d47 2
a48 2
static void xf86CursorQueryBestSize(int, unsigned short*, unsigned short*,
				    ScreenPtr);
d53 1
a53 1
static Bool xf86CursorSwitchMode(int, DisplayModePtr,int);
d56 1
a56 4
xf86InitCursor(
   ScreenPtr pScreen,
   xf86CursorInfoPtr infoPtr
)
d63 1
a63 1
	return FALSE;
d66 1
a66 1
	return FALSE;
d70 1
a70 1
	return FALSE;
d89 4
a92 4
	!(infoPtr->Flags & HARDWARE_CURSOR_TRUECOLOR_AT_8BPP)) {
	ScreenPriv->InstallColormap = pScreen->InstallColormap;
	pScreen->InstallColormap = xf86CursorInstallColormap;
	ScreenPriv->PalettedCursor = TRUE;
d99 1
a99 1
	PointPriv->showTransparent = TRUE;
d101 1
a101 1
	PointPriv->showTransparent = FALSE;
d107 1
a107 1
    
d113 1
a113 1
	pScrn->SwitchMode = xf86CursorSwitchMode;
d124 6
a129 4
    miPointerScreenPtr PointPriv = (miPointerScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, miPointerScreenKey);
    xf86CursorScreenPtr ScreenPriv = (xf86CursorScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, xf86CursorScreenKey);
d132 1
a132 1
	xf86SetCursor(pScreen, NullCursor, ScreenPriv->x, ScreenPriv->y);
d135 1
a135 1
	FreeCursor(ScreenPriv->CurrentCursor, None);
d141 1
a141 1
	pScreen->InstallColormap = ScreenPriv->InstallColormap;
d152 1
a152 1
    return (*pScreen->CloseScreen)(i, pScreen);
d156 7
a162 8
xf86CursorQueryBestSize(
   int class,
   unsigned short *width,
   unsigned short *height,
   ScreenPtr pScreen)
{
    xf86CursorScreenPtr ScreenPriv = (xf86CursorScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, xf86CursorScreenKey);
d165 7
a171 6
	if(*width > ScreenPriv->CursorInfoPtr->MaxWidth)
	   *width = ScreenPriv->CursorInfoPtr->MaxWidth;
	if(*height > ScreenPriv->CursorInfoPtr->MaxHeight)
	   *height = ScreenPriv->CursorInfoPtr->MaxHeight;
    } else
	(*ScreenPriv->QueryBestSize)(class, width, height, pScreen);
d177 3
a179 2
    xf86CursorScreenPtr ScreenPriv = (xf86CursorScreenPtr)dixLookupPrivate(
	&pMap->pScreen->devPrivates, xf86CursorScreenKey);
d183 1
a183 1
    (*ScreenPriv->InstallColormap)(pMap);
d187 2
a188 5
xf86CursorRecolorCursor(
    DeviceIntPtr pDev,
    ScreenPtr pScreen,
    CursorPtr pCurs,
    Bool displayed)
d190 3
a192 2
    xf86CursorScreenPtr ScreenPriv = (xf86CursorScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, xf86CursorScreenKey);
d195 1
a195 1
	return;
d198 1
a198 1
	(*ScreenPriv->RecolorCursor)(pDev, pScreen, pCurs, displayed);
d200 1
a200 1
	xf86RecolorCursor(pScreen, pCurs, displayed);
d206 1
a206 3
xf86CursorEnableDisableFBAccess(
    int index,
    Bool enable)
d211 3
a213 2
    xf86CursorScreenPtr ScreenPriv = (xf86CursorScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, xf86CursorScreenKey);
d217 1
d219 1
a219 1
                ScreenPriv->y); 
d221 2
a222 2
	ScreenPriv->SWCursor = TRUE;
	ScreenPriv->SavedCursor = currentCursor;
d226 1
a226 1
	(*ScreenPriv->EnableDisableFBAccess)(index, enable);
d228 8
a235 9
    if (enable && ScreenPriv->SavedCursor)
    {
	/*
	 * Re-set current cursor so drivers can react to FB access having been
	 * temporarily disabled.
	 */
	xf86CursorSetCursor(pDev, pScreen, ScreenPriv->SavedCursor,
			    ScreenPriv->x, ScreenPriv->y);
	ScreenPriv->SavedCursor = NULL;
d244 3
a246 2
    xf86CursorScreenPtr ScreenPriv = (xf86CursorScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, xf86CursorScreenKey);
d249 2
a250 2
	xf86SetCursor(pScreen, NullCursor, ScreenPriv->x, ScreenPriv->y);
	ScreenPriv->isUp = FALSE;
d253 1
a253 1
    ret = (*ScreenPriv->SwitchMode)(index, mode, flags);
d261 1
a261 1
    miPointerSetWaitForUpdate(pScreen, FALSE);	/* Force cursor repaint */
d271 3
a273 2
    xf86CursorScreenPtr ScreenPriv = (xf86CursorScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, xf86CursorScreenKey);
d276 2
a277 1
	dixSetPrivate(&pCurs->devPrivates, CursorScreenKey(pScreen), NULL);
d279 1
a279 1
    return (*ScreenPriv->spriteFuncs->RealizeCursor)(pDev, pScreen, pCurs);
d283 1
a283 2
xf86CursorUnrealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, 
                          CursorPtr pCurs)
d285 3
a287 2
    xf86CursorScreenPtr ScreenPriv = (xf86CursorScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, xf86CursorScreenKey);
d290 4
a293 2
	free(dixLookupPrivate(&pCurs->devPrivates, CursorScreenKey(pScreen)));
	dixSetPrivate(&pCurs->devPrivates, CursorScreenKey(pScreen), NULL);
d296 1
a296 1
    return (*ScreenPriv->spriteFuncs->UnrealizeCursor)(pDev, pScreen, pCurs);
d300 1
a300 1
xf86CursorSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCurs, 
d303 3
a305 2
    xf86CursorScreenPtr ScreenPriv = (xf86CursorScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, xf86CursorScreenKey);
d308 1
a308 1
    if (pCurs == NullCursor) {	/* means we're supposed to remove the cursor */
d311 2
a312 1
                (*ScreenPriv->spriteFuncs->SetCursor)(pDev, pScreen, NullCursor, x, y);
d317 2
a318 2
	if (ScreenPriv->CurrentCursor)
	    FreeCursor(ScreenPriv->CurrentCursor, None);
d325 10
a334 11
    if (GetMaster(pDev, MASTER_POINTER) == inputInfo.pointer)
    {
	pCurs->refcnt++;
	if (ScreenPriv->CurrentCursor)
	    FreeCursor(ScreenPriv->CurrentCursor, None);
	ScreenPriv->CurrentCursor = pCurs;
	ScreenPriv->x = x;
	ScreenPriv->y = y;
	ScreenPriv->CursorToRestore = NULL;
	ScreenPriv->HotX = pCurs->bits->xhot;
	ScreenPriv->HotY = pCurs->bits->yhot;
d339 1
a339 1
	if (infoPtr->pScrn->vtSema && (ScreenPriv->ForceHWCursorCount || ((
d341 17
a357 3
			    pCurs->bits->argb && infoPtr->UseHWCursorARGB &&
			    (*infoPtr->UseHWCursorARGB) (pScreen, pCurs) ) || (
			    pCurs->bits->argb == 0 &&
d359 13
a371 15
			    (pCurs->bits->height <= infoPtr->MaxHeight) &&
			    (pCurs->bits->width <= infoPtr->MaxWidth) &&
                            (!infoPtr->UseHWCursor || (*infoPtr->UseHWCursor)(pScreen, pCurs))))))
	{

	    if (ScreenPriv->SWCursor)	/* remove the SW cursor */
		(*ScreenPriv->spriteFuncs->SetCursor)(pDev, pScreen, NullCursor, x, y);

	    xf86SetCursor(pScreen, pCurs, x, y);
	    ScreenPriv->SWCursor = FALSE;
	    ScreenPriv->isUp = TRUE;

	    miPointerSetWaitForUpdate(pScreen, !infoPtr->pScrn->silkenMouse);
	    return;
	}
d379 2
a380 1
            } else {
d392 1
a392 1
	pCurs = NullCursor;
d394 1
a394 1
    (*ScreenPriv->spriteFuncs->SetCursor)(pDev, pScreen, pCurs, x, y);
d400 3
a402 2
    xf86CursorScreenPtr ScreenPriv = (xf86CursorScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, xf86CursorScreenKey);
d406 3
a408 4
    if (GetMaster(pDev, MASTER_POINTER) == inputInfo.pointer)
    {
	ScreenPriv->x = x;
	ScreenPriv->y = y;
d411 2
a412 1
            xf86CursorSetCursor(pDev, pScreen, ScreenPriv->CursorToRestore, x, y);
d414 1
a414 1
            (*ScreenPriv->spriteFuncs->MoveCursor)(pDev, pScreen, x, y);
d417 3
a419 2
    } else
        (*ScreenPriv->spriteFuncs->MoveCursor)(pDev, pScreen, x, y);
d423 1
a423 1
xf86ForceHWCursor (ScreenPtr pScreen, Bool on)
d426 14
a439 16
    xf86CursorScreenPtr ScreenPriv = (xf86CursorScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, xf86CursorScreenKey);

    if (on)
    {
	if (ScreenPriv->ForceHWCursorCount++ == 0)
	{
	    if (ScreenPriv->SWCursor && ScreenPriv->CurrentCursor)
	    {
		ScreenPriv->HWCursorForced = TRUE;
		xf86CursorSetCursor (pDev, pScreen, ScreenPriv->CurrentCursor,
				     ScreenPriv->x, ScreenPriv->y);
	    }
	    else
		ScreenPriv->HWCursorForced = FALSE;
	}
d441 6
a446 8
    else
    {
	if (--ScreenPriv->ForceHWCursorCount == 0)
	{
	    if (ScreenPriv->HWCursorForced && ScreenPriv->CurrentCursor)
		xf86CursorSetCursor (pDev, pScreen, ScreenPriv->CurrentCursor,
				     ScreenPriv->x, ScreenPriv->y);
	}
d469 3
a471 2
    xf86CursorScreenPtr ScreenPriv = (xf86CursorScreenPtr)dixLookupPrivate(
            &pScreen->devPrivates, xf86CursorScreenKey);
d474 1
a474 1
    ret = (*ScreenPriv->spriteFuncs->DeviceCursorInitialize)(pDev, pScreen);
d485 3
a487 2
    xf86CursorScreenPtr ScreenPriv = (xf86CursorScreenPtr)dixLookupPrivate(
            &pScreen->devPrivates, xf86CursorScreenKey);
d489 2
a490 2
   /* Clean up SW cursor */
    (*ScreenPriv->spriteFuncs->DeviceCursorCleanup)(pDev, pScreen);
a491 1

@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d320 1
a320 2
    if (pDev == inputInfo.pointer ||
        (!IsMaster(pDev) && pDev->u.master == inputInfo.pointer))
d388 1
a388 2
    if (pDev == inputInfo.pointer ||
	(!IsMaster(pDev) && pDev->u.master == inputInfo.pointer))
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d21 1
a21 2
static int xf86CursorScreenKeyIndex;
DevPrivateKey xf86CursorScreenKey = &xf86CursorScreenKeyIndex;
d67 4
a70 1
    ScreenPriv = xcalloc(1, sizeof(xf86CursorScreenRec));
d149 2
a150 2
    xfree(ScreenPriv->transparentData);
    xfree(ScreenPriv);
a247 2
    miPointerScreenPtr PointPriv = (miPointerScreenPtr)dixLookupPrivate(
	&pScreen->devPrivates, miPointerScreenKey);
d262 1
a262 1
    PointPriv->waitForUpdate = FALSE;	/* Force cursor repaint */
d289 1
a289 1
	xfree(dixLookupPrivate(&pCurs->devPrivates, CursorScreenKey(pScreen)));
a302 3
    miPointerScreenPtr PointPriv = (miPointerScreenPtr)dixLookupPrivate(
    &pScreen->devPrivates, miPointerScreenKey);

d353 2
a354 1
	    PointPriv->waitForUpdate = !infoPtr->pScrn->silkenMouse;
d358 1
a358 1
        PointPriv->waitForUpdate = TRUE;
d440 1
a440 1
    return xcalloc(1, sizeof(xf86CursorInfoRec));
d446 1
a446 1
    xfree(infoPtr);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d132 3
d309 1
a309 1
            !(pDev == inputInfo.pointer || !pDev->isMaster && pDev->u.master == inputInfo.pointer))
d315 3
d324 1
a324 1
        (!pDev->isMaster && pDev->u.master == inputInfo.pointer))
d326 3
d392 1
a392 1
	(!pDev->isMaster && pDev->u.master == inputInfo.pointer))
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d11 12
a22 1
DevPrivateKey xf86CursorScreenKey = &xf86CursorScreenKey;
d26 6
a31 4
static Bool xf86CursorRealizeCursor(ScreenPtr, CursorPtr);
static Bool xf86CursorUnrealizeCursor(ScreenPtr, CursorPtr);
static void xf86CursorSetCursor(ScreenPtr, CursorPtr, int, int);
static void xf86CursorMoveCursor(ScreenPtr, int, int);
d37 3
a39 1
   xf86CursorMoveCursor
d45 1
a45 1
static void xf86CursorRecolorCursor(ScreenPtr, CursorPtr, Bool);
d182 1
d194 1
a194 1
	(*ScreenPriv->RecolorCursor)(pScreen, pCurs, displayed);
d206 2
d213 4
a216 3
	CursorPtr   currentCursor = ScreenPriv->CurrentCursor;
	xf86CursorSetCursor(pScreen, NullCursor, ScreenPriv->x, ScreenPriv->y);
	ScreenPriv->isUp = FALSE;
d230 1
a230 1
	xf86CursorSetCursor(pScreen, ScreenPriv->SavedCursor,
d267 1
a267 1
xf86CursorRealizeCursor(ScreenPtr pScreen, CursorPtr pCurs)
d273 1
a273 1
	dixSetPrivate(&pCurs->devPrivates, pScreen, NULL);
d275 1
a275 1
    return (*ScreenPriv->spriteFuncs->RealizeCursor)(pScreen, pCurs);
d279 2
a280 1
xf86CursorUnrealizeCursor(ScreenPtr pScreen, CursorPtr pCurs)
d286 2
a287 2
	xfree(dixLookupPrivate(&pCurs->devPrivates, pScreen));
	dixSetPrivate(&pCurs->devPrivates, pScreen, NULL);
d290 1
a290 1
    return (*ScreenPriv->spriteFuncs->UnrealizeCursor)(pScreen, pCurs);
d294 2
a295 1
xf86CursorSetCursor(ScreenPtr pScreen, CursorPtr pCurs, int x, int y)
d300 2
a301 1
    miPointerScreenPtr PointPriv;
a302 7
    ScreenPriv->CurrentCursor = pCurs;
    ScreenPriv->x = x;
    ScreenPriv->y = y;
    ScreenPriv->CursorToRestore = NULL;

    if (!infoPtr->pScrn->vtSema)
	 ScreenPriv->SavedCursor = pCurs;
d305 8
a312 7
	if (ScreenPriv->SWCursor)
	    (*ScreenPriv->spriteFuncs->SetCursor)(pScreen, NullCursor, x, y);
	else if (ScreenPriv->isUp) {
	    xf86SetCursor(pScreen, NullCursor, x, y);
	    ScreenPriv->isUp = FALSE;
	}
	return;
d315 14
a328 2
    ScreenPriv->HotX = pCurs->bits->xhot;
    ScreenPriv->HotY = pCurs->bits->yhot;
d330 1
a330 3
    PointPriv = (miPointerScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						     miPointerScreenKey);
    if (infoPtr->pScrn->vtSema && (ScreenPriv->ForceHWCursorCount || ((
d332 3
a334 3
	pCurs->bits->argb && infoPtr->UseHWCursorARGB &&
	 (*infoPtr->UseHWCursorARGB) (pScreen, pCurs) ) || (
	pCurs->bits->argb == 0 &&
d336 14
a349 4
	(pCurs->bits->height <= infoPtr->MaxHeight) &&
	(pCurs->bits->width <= infoPtr->MaxWidth) &&
	(!infoPtr->UseHWCursor || (*infoPtr->UseHWCursor)(pScreen, pCurs))))))
    {
d351 1
a351 2
	if (ScreenPriv->SWCursor)	/* remove the SW cursor */
	      (*ScreenPriv->spriteFuncs->SetCursor)(pScreen, NullCursor, x, y);
d353 9
a361 6
	xf86SetCursor(pScreen, pCurs, x, y);
	ScreenPriv->SWCursor = FALSE;
	ScreenPriv->isUp = TRUE;
	PointPriv->waitForUpdate = !infoPtr->pScrn->silkenMouse;
	return;
    }
d363 2
a364 1
    PointPriv->waitForUpdate = TRUE;
a365 8
    if (ScreenPriv->isUp) {
	/* Remove the HW cursor, or make it transparent */
	if (infoPtr->Flags & HARDWARE_CURSOR_SHOW_TRANSPARENT) {
	    xf86SetTransparentCursor(pScreen);
	} else {
	    xf86SetCursor(pScreen, NullCursor, x, y);
	    ScreenPriv->isUp = FALSE;
	}
a367 2
    ScreenPriv->SWCursor = TRUE;

d370 2
a371 1
    (*ScreenPriv->spriteFuncs->SetCursor)(pScreen, pCurs, x, y);
d375 1
a375 1
xf86CursorMoveCursor(ScreenPtr pScreen, int x, int y)
d380 7
a386 2
    ScreenPriv->x = x;
    ScreenPriv->y = y;
d388 8
a395 7
    if (ScreenPriv->CursorToRestore)
	xf86CursorSetCursor(pScreen, ScreenPriv->CursorToRestore,
			    ScreenPriv->x, ScreenPriv->y);
    else if (ScreenPriv->SWCursor)
	(*ScreenPriv->spriteFuncs->MoveCursor)(pScreen, x, y);
    else if (ScreenPriv->isUp)
	xf86MoveCursor(pScreen, x, y);
d401 1
d412 1
a412 1
		xf86CursorSetCursor (pScreen, ScreenPriv->CurrentCursor,
d424 1
a424 1
		xf86CursorSetCursor (pScreen, ScreenPriv->CurrentCursor,
d441 30
@


1.1
log
@Initial revision
@
text
@d11 1
a11 2
int xf86CursorScreenIndex = -1;
static unsigned long xf86CursorGeneration = 0;
a49 6
    if (xf86CursorGeneration != serverGeneration) {
	if ((xf86CursorScreenIndex = AllocateScreenPrivateIndex()) < 0)
	    return FALSE;
	xf86CursorGeneration = serverGeneration;
    }

d57 1
a57 1
    pScreen->devPrivates[xf86CursorScreenIndex].ptr = ScreenPriv;
d80 1
a80 1
    PointPriv = pScreen->devPrivates[miPointerScreenIndex].ptr;
d109 4
a112 4
    miPointerScreenPtr PointPriv =
	pScreen->devPrivates[miPointerScreenIndex].ptr;
    xf86CursorScreenPtr ScreenPriv =
	pScreen->devPrivates[xf86CursorScreenIndex].ptr;
d142 2
a143 2
    xf86CursorScreenPtr ScreenPriv =
	pScreen->devPrivates[xf86CursorScreenIndex].ptr;
d157 2
a158 2
    xf86CursorScreenPtr ScreenPriv =
	pMap->pScreen->devPrivates[xf86CursorScreenIndex].ptr;
d171 2
a172 2
    xf86CursorScreenPtr ScreenPriv =
	pScreen->devPrivates[xf86CursorScreenIndex].ptr;
d191 2
a192 2
    xf86CursorScreenPtr ScreenPriv =
	pScreen->devPrivates[xf86CursorScreenIndex].ptr;
d195 1
a195 1
	ScreenPriv->SavedCursor = ScreenPriv->CurrentCursor;
d199 1
d222 4
a225 4
    xf86CursorScreenPtr ScreenPriv =
	pScreen->devPrivates[xf86CursorScreenIndex].ptr;
    miPointerScreenPtr PointPriv =
	pScreen->devPrivates[miPointerScreenIndex].ptr;
d250 2
a251 2
    xf86CursorScreenPtr ScreenPriv =
	pScreen->devPrivates[xf86CursorScreenIndex].ptr;
d254 1
a254 1
	pCurs->devPriv[pScreen->myNum] = NULL;
d262 2
a263 2
    xf86CursorScreenPtr ScreenPriv =
	pScreen->devPrivates[xf86CursorScreenIndex].ptr;
d266 2
a267 2
	xfree(pCurs->devPriv[pScreen->myNum]);
	pCurs->devPriv[pScreen->myNum] = NULL;
d276 2
a277 2
    xf86CursorScreenPtr ScreenPriv =
	pScreen->devPrivates[xf86CursorScreenIndex].ptr;
d302 2
a303 2
    PointPriv = pScreen->devPrivates[miPointerScreenIndex].ptr;

d347 2
a348 2
    xf86CursorScreenPtr ScreenPriv =
	pScreen->devPrivates[xf86CursorScreenIndex].ptr;
d365 2
a366 2
    xf86CursorScreenPtr ScreenPriv =
	pScreen->devPrivates[xf86CursorScreenIndex].ptr;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d202 1
a202 1
	CursorPtr   currentCursor = ScreenPriv->CurrentCursor;
a205 1
	ScreenPriv->SavedCursor = currentCursor;
@

