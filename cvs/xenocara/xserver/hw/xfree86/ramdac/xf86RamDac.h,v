head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.8
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.6
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.4
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.3.0.14
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.12
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.10
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.8
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.8
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.3;
commitid	Te1daavkBLskZ8gc;

1.3
date	2012.06.10.13.21.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@
#ifndef _XF86RAMDAC_H
#define _XF86RAMDAC_H 1

#include "colormapst.h"
#include "xf86Cursor.h"

/* Define unique vendor codes for RAMDAC's */
#define VENDOR_IBM	0x0000
#define VENDOR_BT	0x0001
#define VENDOR_TI	0x0002

typedef struct _RamDacRegRec {
/* This is probably the nastiest assumption, we allocate 1024 slots for
 * ramdac registers, should be enough. I've checked IBM and TVP series
 * and they seem o.k
 * Then we allocate 768 entries for the DAC too. IBM640 needs 1024 -FIXME
 */
    unsigned short DacRegs[0x400];      /* register set */
    unsigned char DAC[0x300];   /* colour map */
    Bool Overlay;
} RamDacRegRec, *RamDacRegRecPtr;

typedef struct _RamDacHWRegRec {
    RamDacRegRec SavedReg;
    RamDacRegRec ModeReg;
} RamDacHWRec, *RamDacHWRecPtr;

typedef struct _RamDacRec {
    CARD32 RamDacType;

    void (*LoadPalette) (ScrnInfoPtr pScrn,
                         int numColors,
                         int *indices, LOCO * colors, VisualPtr pVisual);

    unsigned char (*ReadDAC) (ScrnInfoPtr pScrn, CARD32);

    void (*WriteDAC) (ScrnInfoPtr pScrn, CARD32, unsigned char, unsigned char);

    void (*WriteAddress) (ScrnInfoPtr pScrn, CARD32);

    void (*WriteData) (ScrnInfoPtr pScrn, unsigned char);

    void (*ReadAddress) (ScrnInfoPtr pScrn, CARD32);

    unsigned char (*ReadData) (ScrnInfoPtr pScrn);
} RamDacRec, *RamDacRecPtr;

typedef struct _RamDacHelperRec {
    CARD32 RamDacType;

    void (*Restore) (ScrnInfoPtr pScrn,
                     RamDacRecPtr ramdacPtr, RamDacRegRecPtr ramdacReg);

    void (*Save) (ScrnInfoPtr pScrn,
                  RamDacRecPtr ramdacPtr, RamDacRegRecPtr ramdacReg);

    void (*SetBpp) (ScrnInfoPtr pScrn, RamDacRegRecPtr ramdacReg);

    void (*HWCursorInit) (xf86CursorInfoPtr infoPtr);
} RamDacHelperRec, *RamDacHelperRecPtr;

#define RAMDACHWPTR(p) ((RamDacHWRecPtr)((p)->privates[RamDacGetHWIndex()].ptr))

typedef struct _RamdacScreenRec {
    RamDacRecPtr RamDacRec;
} RamDacScreenRec, *RamDacScreenRecPtr;

#define RAMDACSCRPTR(p) ((RamDacScreenRecPtr)((p)->privates[RamDacGetScreenIndex()].ptr))->RamDacRec

extern _X_EXPORT int RamDacHWPrivateIndex;
extern _X_EXPORT int RamDacScreenPrivateIndex;

typedef struct {
    int token;
} RamDacSupportedInfoRec, *RamDacSupportedInfoRecPtr;

extern _X_EXPORT RamDacRecPtr RamDacCreateInfoRec(void);
extern _X_EXPORT RamDacHelperRecPtr RamDacHelperCreateInfoRec(void);
extern _X_EXPORT void RamDacDestroyInfoRec(RamDacRecPtr RamDacRec);
extern _X_EXPORT void RamDacHelperDestroyInfoRec(RamDacHelperRecPtr RamDacRec);
extern _X_EXPORT Bool RamDacInit(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec);
extern _X_EXPORT Bool RamDacHandleColormaps(ScreenPtr pScreen, int maxColors,
                                            int sigRGBbits, unsigned int flags);
extern _X_EXPORT void RamDacFreeRec(ScrnInfoPtr pScrn);
extern _X_EXPORT int RamDacGetHWIndex(void);

#endif                          /* _XF86RAMDAC_H */
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d15 2
a16 2
 * ramdac registers, should be enough. I've checked IBM and TVP series 
 * and they seem o.k 
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d19 2
a20 2
    unsigned short DacRegs[0x400];	/* register set */
    unsigned char DAC[0x300];		/* colour map */
d25 2
a26 2
    RamDacRegRec	SavedReg;
    RamDacRegRec	ModeReg;
d32 15
a46 38
    void (*LoadPalette)(
	ScrnInfoPtr pScrn, 
	int numColors, 
	int *indices, 
	LOCO *colors,
	VisualPtr pVisual
    );

    unsigned char (*ReadDAC)(
	ScrnInfoPtr pScrn,
	CARD32
    );

    void (*WriteDAC)(
	ScrnInfoPtr pScrn,
	CARD32,
	unsigned char,
	unsigned char
    );

    void (*WriteAddress)(
	ScrnInfoPtr pScrn,
	CARD32
    );

    void (*WriteData)(
	ScrnInfoPtr pScrn,
	unsigned char
    );

    void (*ReadAddress)(
	ScrnInfoPtr pScrn,
	CARD32
    );

    unsigned char (*ReadData)(
	ScrnInfoPtr pScrn
    );
d52 9
a60 20
    void (*Restore)(
	ScrnInfoPtr pScrn,
	RamDacRecPtr ramdacPtr,
	RamDacRegRecPtr ramdacReg
    );

    void (*Save)(
	ScrnInfoPtr pScrn,
	RamDacRecPtr ramdacPtr,
	RamDacRegRecPtr ramdacReg
    );

    void (*SetBpp)(
	ScrnInfoPtr pScrn,
	RamDacRegRecPtr ramdacReg
    );

    void (*HWCursorInit)(
	xf86CursorInfoPtr infoPtr
    );
d66 1
a66 1
    RamDacRecPtr	RamDacRec;
d68 1
d75 1
a75 1
    int		token;
d83 2
a84 2
extern _X_EXPORT Bool RamDacHandleColormaps(ScreenPtr pScreen, int maxColors, int sigRGBbits,
			   unsigned int flags);
d86 1
a86 1
extern _X_EXPORT int  RamDacGetHWIndex(void);
d88 1
a88 1
#endif /* _XF86RAMDAC_H */
@


1.1
log
@Initial revision
@
text
@d104 2
a105 2
extern int RamDacHWPrivateIndex;
extern int RamDacScreenPrivateIndex;
d111 6
a116 8
RamDacRecPtr RamDacCreateInfoRec(void);
RamDacHelperRecPtr RamDacHelperCreateInfoRec(void);
void RamDacDestroyInfoRec(RamDacRecPtr RamDacRec);
void RamDacHelperDestroyInfoRec(RamDacHelperRecPtr RamDacRec);
Bool RamDacInit(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec);
void RamDacSetGamma(ScrnInfoPtr pScrn, Bool Real8BitDac);
void RamDacRestoreDACValues(ScrnInfoPtr pScrn);
Bool RamDacHandleColormaps(ScreenPtr pScreen, int maxColors, int sigRGBbits,
d118 2
a119 2
void RamDacFreeRec(ScrnInfoPtr pScrn);
int  RamDacGetHWIndex(void);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
