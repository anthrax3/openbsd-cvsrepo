head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.4
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.10
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.8
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	s0SI41sEunLdyFfd;

1.7
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2013.06.07.17.28.51;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.38;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.38;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright (C) 1998 Itai Nahshon, Michael Schimek
 *
 * The original code was derived from and inspired by
 * the I2C driver from the Linux kernel.
 *      (c) 1998 Gerd Knorr <kraxel@@cs.tu-berlin.de>
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <sys/time.h>
#include <string.h>

#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"

#include <X11/X.h>
#include <X11/Xos.h>
#include <X11/Xproto.h>
#include "scrnintstr.h"
#include "regionstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "validate.h"
#include "resource.h"
#include "gcstruct.h"
#include "dixstruct.h"

#include "xf86i2c.h"

#define I2C_TIMEOUT(x)	/*(x)*/ /* Report timeouts */
#define I2C_TRACE(x)    /*(x)*/ /* Report progress */

/* This is the default I2CUDelay function if not supplied by the driver.
 * High level I2C interfaces implementing the bus protocol in hardware
 * should supply this function too.
 *
 * Delay execution at least usec microseconds.
 * All values 0 to 1e6 inclusive must be expected.
 */

static void
I2CUDelay(I2CBusPtr b, int usec)
{
    struct timeval begin, cur;
    long d_secs, d_usecs;
    long diff;

    if (usec > 0) {
        X_GETTIMEOFDAY(&begin);
        do {
            /* It would be nice to use {xf86}usleep,
             * but usleep (1) takes >10000 usec !
             */
            X_GETTIMEOFDAY(&cur);
            d_secs = (cur.tv_sec - begin.tv_sec);
            d_usecs = (cur.tv_usec - begin.tv_usec);
            diff = d_secs * 1000000 + d_usecs;
        } while (diff >= 0 && diff < (usec + 1));
    }
}

/* Most drivers will register just with GetBits/PutBits functions.
 * The following functions implement a software I2C protocol
 * by using the promitive functions given by the driver.
 * ================================================================
 *
 * It is assumed that there is just one master on the I2C bus, therefore
 * there is no explicit test for conflits.
 */

#define RISEFALLTIME 2          /* usec, actually 300 to 1000 ns according to the i2c specs */

/* Some devices will hold SCL low to slow down the bus or until
 * ready for transmission.
 *
 * This condition will be noticed when the master tries to raise
 * the SCL line. You can set the timeout to zero if the slave device
 * does not support this clock synchronization.
 */

static Bool
I2CRaiseSCL(I2CBusPtr b, int sda, int timeout)
{
    int i, scl;

    b->I2CPutBits(b, 1, sda);
    b->I2CUDelay(b, b->RiseFallTime);

    for (i = timeout; i > 0; i -= b->RiseFallTime) {
        b->I2CGetBits(b, &scl, &sda);
        if (scl)
            break;
        b->I2CUDelay(b, b->RiseFallTime);
    }

    if (i <= 0) {
        I2C_TIMEOUT(ErrorF
                    ("[I2CRaiseSCL(<%s>, %d, %d) timeout]", b->BusName, sda,
                     timeout));
        return FALSE;
    }

    return TRUE;
}

/* Send a start signal on the I2C bus. The start signal notifies
 * devices that a new transaction is initiated by the bus master.
 *
 * The start signal is always followed by a slave address.
 * Slave addresses are 8+ bits. The first 7 bits identify the
 * device and the last bit signals if this is a read (1) or
 * write (0) operation.
 *
 * There may be more than one start signal on one transaction.
 * This happens for example on some devices that allow reading
 * of registers. First send a start bit followed by the device
 * address (with the last bit 0) and the register number. Then send
 * a new start bit with the device address (with the last bit 1)
 * and then read the value from the device.
 *
 * Note this is function does not implement a multiple master
 * arbitration procedure.
 */

static Bool
I2CStart(I2CBusPtr b, int timeout)
{
    if (!I2CRaiseSCL(b, 1, timeout))
        return FALSE;

    b->I2CPutBits(b, 1, 0);
    b->I2CUDelay(b, b->HoldTime);
    b->I2CPutBits(b, 0, 0);
    b->I2CUDelay(b, b->HoldTime);

    I2C_TRACE(ErrorF("\ni2c: <"));

    return TRUE;
}

/* This is the default I2CStop function if not supplied by the driver.
 *
 * Signal devices on the I2C bus that a transaction on the
 * bus has finished. There may be more than one start signal
 * on a transaction but only one stop signal.
 */

static void
I2CStop(I2CDevPtr d)
{
    I2CBusPtr b = d->pI2CBus;

    b->I2CPutBits(b, 0, 0);
    b->I2CUDelay(b, b->RiseFallTime);

    b->I2CPutBits(b, 1, 0);
    b->I2CUDelay(b, b->HoldTime);
    b->I2CPutBits(b, 1, 1);
    b->I2CUDelay(b, b->HoldTime);

    I2C_TRACE(ErrorF(">\n"));
}

/* Write/Read a single bit to/from a device.
 * Return FALSE if a timeout occurs.
 */

static Bool
I2CWriteBit(I2CBusPtr b, int sda, int timeout)
{
    Bool r;

    b->I2CPutBits(b, 0, sda);
    b->I2CUDelay(b, b->RiseFallTime);

    r = I2CRaiseSCL(b, sda, timeout);
    b->I2CUDelay(b, b->HoldTime);

    b->I2CPutBits(b, 0, sda);
    b->I2CUDelay(b, b->HoldTime);

    return r;
}

static Bool
I2CReadBit(I2CBusPtr b, int *psda, int timeout)
{
    Bool r;
    int scl;

    r = I2CRaiseSCL(b, 1, timeout);
    b->I2CUDelay(b, b->HoldTime);

    b->I2CGetBits(b, &scl, psda);

    b->I2CPutBits(b, 0, 1);
    b->I2CUDelay(b, b->HoldTime);

    return r;
}

/* This is the default I2CPutByte function if not supplied by the driver.
 *
 * A single byte is sent to the device.
 * The function returns FALSE if a timeout occurs, you should send
 * a stop condition afterwards to reset the bus.
 *
 * A timeout occurs,
 * if the slave pulls SCL to slow down the bus more than ByteTimeout usecs,
 * or slows down the bus for more than BitTimeout usecs for each bit,
 * or does not send an ACK bit (0) to acknowledge the transmission within
 * AcknTimeout usecs, but a NACK (1) bit.
 *
 * AcknTimeout must be at least b->HoldTime, the other timeouts can be
 * zero according to the comment on I2CRaiseSCL.
 */

static Bool
I2CPutByte(I2CDevPtr d, I2CByte data)
{
    Bool r;
    int i, scl, sda;
    I2CBusPtr b = d->pI2CBus;

    if (!I2CWriteBit(b, (data >> 7) & 1, d->ByteTimeout))
        return FALSE;

    for (i = 6; i >= 0; i--)
        if (!I2CWriteBit(b, (data >> i) & 1, d->BitTimeout))
            return FALSE;

    b->I2CPutBits(b, 0, 1);
    b->I2CUDelay(b, b->RiseFallTime);

    r = I2CRaiseSCL(b, 1, b->HoldTime);

    if (r) {
        for (i = d->AcknTimeout; i > 0; i -= b->HoldTime) {
            b->I2CUDelay(b, b->HoldTime);
            b->I2CGetBits(b, &scl, &sda);
            if (sda == 0)
                break;
        }

        if (i <= 0) {
            I2C_TIMEOUT(ErrorF("[I2CPutByte(<%s>, 0x%02x, %d, %d, %d) timeout]",
                               b->BusName, data, d->BitTimeout,
                               d->ByteTimeout, d->AcknTimeout));
            r = FALSE;
        }

        I2C_TRACE(ErrorF("W%02x%c ", (int) data, sda ? '-' : '+'));
    }

    b->I2CPutBits(b, 0, 1);
    b->I2CUDelay(b, b->HoldTime);

    return r;
}

/* This is the default I2CGetByte function if not supplied by the driver.
 *
 * A single byte is read from the device.
 * The function returns FALSE if a timeout occurs, you should send
 * a stop condition afterwards to reset the bus.
 *
 * A timeout occurs,
 * if the slave pulls SCL to slow down the bus more than ByteTimeout usecs,
 * or slows down the bus for more than b->BitTimeout usecs for each bit.
 *
 * ByteTimeout must be at least b->HoldTime, the other timeouts can be
 * zero according to the comment on I2CRaiseSCL.
 *
 * For the <last> byte in a sequence the acknowledge bit NACK (1),
 * otherwise ACK (0) will be sent.
 */

static Bool
I2CGetByte(I2CDevPtr d, I2CByte * data, Bool last)
{
    int i, sda;
    I2CBusPtr b = d->pI2CBus;

    b->I2CPutBits(b, 0, 1);
    b->I2CUDelay(b, b->RiseFallTime);

    if (!I2CReadBit(b, &sda, d->ByteTimeout))
        return FALSE;

    *data = (sda > 0) << 7;

    for (i = 6; i >= 0; i--)
        if (!I2CReadBit(b, &sda, d->BitTimeout))
            return FALSE;
        else
            *data |= (sda > 0) << i;

    if (!I2CWriteBit(b, last ? 1 : 0, d->BitTimeout))
        return FALSE;

    I2C_TRACE(ErrorF("R%02x%c ", (int) *data, last ? '+' : '-'));

    return TRUE;
}

/* This is the default I2CAddress function if not supplied by the driver.
 *
 * It creates the start condition, followed by the d->SlaveAddr.
 * Higher level functions must call this routine rather than
 * I2CStart/PutByte because a hardware I2C master may not be able
 * to send a slave address without a start condition.
 *
 * The same timeouts apply as with I2CPutByte and additional a
 * StartTimeout, similar to the ByteTimeout but for the start
 * condition.
 *
 * In case of a timeout, the bus is left in a clean idle condition.
 * I. e. you *must not* send a Stop. If this function succeeds, you *must*.
 *
 * The slave address format is 16 bit, with the legacy _8_bit_ slave address
 * in the least significant byte. This is, the slave address must include the
 * R/_W flag as least significant bit.
 *
 * The most significant byte of the address will be sent _after_ the LSB,
 * but only if the LSB indicates:
 * a) an 11 bit address, this is LSB = 1111 0xxx.
 * b) a 'general call address', this is LSB = 0000 000x - see the I2C specs
 *    for more.
 */

static Bool
I2CAddress(I2CDevPtr d, I2CSlaveAddr addr)
{
    if (I2CStart(d->pI2CBus, d->StartTimeout)) {
        if (I2CPutByte(d, addr & 0xFF)) {
            if ((addr & 0xF8) != 0xF0 && (addr & 0xFE) != 0x00)
                return TRUE;

            if (I2CPutByte(d, (addr >> 8) & 0xFF))
                return TRUE;
        }

        I2CStop(d);
    }

    return FALSE;
}

/* These are the hardware independent I2C helper functions.
 * ========================================================
 */

/* Function for probing. Just send the slave address
 * and return true if the device responds. The slave address
 * must have the lsb set to reflect a read (1) or write (0) access.
 * Don't expect a read- or write-only device will respond otherwise.
 */

Bool
xf86I2CProbeAddress(I2CBusPtr b, I2CSlaveAddr addr)
{
    int r;
    I2CDevRec d;

    d.DevName = "Probing";
    d.BitTimeout = b->BitTimeout;
    d.ByteTimeout = b->ByteTimeout;
    d.AcknTimeout = b->AcknTimeout;
    d.StartTimeout = b->StartTimeout;
    d.SlaveAddr = addr;
    d.pI2CBus = b;
    d.NextDev = NULL;

    r = b->I2CAddress(&d, addr);

    if (r)
        b->I2CStop(&d);

    return r;
}

/* All functions below are related to devices and take the
 * slave address and timeout values from an I2CDevRec. They
 * return FALSE in case of an error (presumably a timeout).
 */

/* General purpose read and write function.
 *
 * 1st, if nWrite > 0
 *   Send a start condition
 *   Send the slave address (1 or 2 bytes) with write flag
 *   Write n bytes from WriteBuffer
 * 2nd, if nRead > 0
 *   Send a start condition [again]
 *   Send the slave address (1 or 2 bytes) with read flag
 *   Read n bytes to ReadBuffer
 * 3rd, if a Start condition has been successfully sent,
 *   Send a Stop condition.
 *
 * The functions exits immediately when an error occures,
 * not proceeding any data left. However, step 3 will
 * be executed anyway to leave the bus in clean idle state.
 */

static Bool
I2CWriteRead(I2CDevPtr d,
             I2CByte * WriteBuffer, int nWrite, I2CByte * ReadBuffer, int nRead)
{
    Bool r = TRUE;
    I2CBusPtr b = d->pI2CBus;
    int s = 0;

    if (r && nWrite > 0) {
        r = b->I2CAddress(d, d->SlaveAddr & ~1);
        if (r) {
            for (; nWrite > 0; WriteBuffer++, nWrite--)
                if (!(r = b->I2CPutByte(d, *WriteBuffer)))
                    break;
            s++;
        }
    }

    if (r && nRead > 0) {
        r = b->I2CAddress(d, d->SlaveAddr | 1);
        if (r) {
            for (; nRead > 0; ReadBuffer++, nRead--)
                if (!(r = b->I2CGetByte(d, ReadBuffer, nRead == 1)))
                    break;
            s++;
        }
    }

    if (s)
        b->I2CStop(d);

    return r;
}

/* wrapper - for compatibility and convinience */

Bool
xf86I2CWriteRead(I2CDevPtr d,
                 I2CByte * WriteBuffer, int nWrite,
                 I2CByte * ReadBuffer, int nRead)
{
    I2CBusPtr b = d->pI2CBus;

    return b->I2CWriteRead(d, WriteBuffer, nWrite, ReadBuffer, nRead);
}

/* Read a byte, the only readable register of a device.
 */

Bool
xf86I2CReadStatus(I2CDevPtr d, I2CByte * pbyte)
{
    return xf86I2CWriteRead(d, NULL, 0, pbyte, 1);
}

/* Read a byte from one of the registers determined by its sub-address.
 */

Bool
xf86I2CReadByte(I2CDevPtr d, I2CByte subaddr, I2CByte * pbyte)
{
    return xf86I2CWriteRead(d, &subaddr, 1, pbyte, 1);
}

/* Read bytes from subsequent registers determined by the
 * sub-address of the first register.
 */

Bool
xf86I2CReadBytes(I2CDevPtr d, I2CByte subaddr, I2CByte * pbyte, int n)
{
    return xf86I2CWriteRead(d, &subaddr, 1, pbyte, n);
}

/* Read a word (high byte, then low byte) from one of the registers
 * determined by its sub-address.
 */

Bool
xf86I2CReadWord(I2CDevPtr d, I2CByte subaddr, unsigned short *pword)
{
    I2CByte rb[2];

    if (!xf86I2CWriteRead(d, &subaddr, 1, rb, 2))
        return FALSE;

    *pword = (rb[0] << 8) | rb[1];

    return TRUE;
}

/* Write a byte to one of the registers determined by its sub-address.
 */

Bool
xf86I2CWriteByte(I2CDevPtr d, I2CByte subaddr, I2CByte byte)
{
    I2CByte wb[2];

    wb[0] = subaddr;
    wb[1] = byte;

    return xf86I2CWriteRead(d, wb, 2, NULL, 0);
}

/* Write bytes to subsequent registers determined by the
 * sub-address of the first register.
 */

Bool
xf86I2CWriteBytes(I2CDevPtr d, I2CByte subaddr,
                  I2CByte * WriteBuffer, int nWrite)
{
    I2CBusPtr b = d->pI2CBus;
    Bool r = TRUE;

    if (nWrite > 0) {
        r = b->I2CAddress(d, d->SlaveAddr & ~1);
        if (r) {
            if ((r = b->I2CPutByte(d, subaddr)))
                for (; nWrite > 0; WriteBuffer++, nWrite--)
                    if (!(r = b->I2CPutByte(d, *WriteBuffer)))
                        break;

            b->I2CStop(d);
        }
    }

    return r;
}

/* Write a word (high byte, then low byte) to one of the registers
 * determined by its sub-address.
 */

Bool
xf86I2CWriteWord(I2CDevPtr d, I2CByte subaddr, unsigned short word)
{
    I2CByte wb[3];

    wb[0] = subaddr;
    wb[1] = word >> 8;
    wb[2] = word & 0xFF;

    return xf86I2CWriteRead(d, wb, 3, NULL, 0);
}

/* Write a vector of bytes to not adjacent registers. This vector is,
 * 1st byte sub-address, 2nd byte value, 3rd byte sub-address asf.
 * This function is intended to initialize devices. Note this function
 * exits immediately when an error occurs, some registers may
 * remain uninitialized.
 */

Bool
xf86I2CWriteVec(I2CDevPtr d, I2CByte * vec, int nValues)
{
    I2CBusPtr b = d->pI2CBus;
    Bool r = TRUE;
    int s = 0;

    if (nValues > 0) {
        for (; nValues > 0; nValues--, vec += 2) {
            if (!(r = b->I2CAddress(d, d->SlaveAddr & ~1)))
                break;

            s++;

            if (!(r = b->I2CPutByte(d, vec[0])))
                break;

            if (!(r = b->I2CPutByte(d, vec[1])))
                break;
        }

        if (s > 0)
            b->I2CStop(d);
    }

    return r;
}

/* Administrative functions.
 * =========================
 */

/* Allocates an I2CDevRec for you and initializes with propper defaults
 * you may modify before calling xf86I2CDevInit. Your I2CDevRec must
 * contain at least a SlaveAddr, and a pI2CBus pointer to the bus this
 * device shall be linked to.
 *
 * See function I2CAddress for the slave address format. Always set
 * the least significant bit, indicating a read or write access, to zero.
 */

I2CDevPtr
xf86CreateI2CDevRec(void)
{
    return calloc(1, sizeof(I2CDevRec));
}

/* Unlink an I2C device. If you got the I2CDevRec from xf86CreateI2CDevRec
 * you should set <unalloc> to free it.
 */

void
xf86DestroyI2CDevRec(I2CDevPtr d, Bool unalloc)
{
    if (d) {
        I2CDevPtr *p;

        /* Remove this from the list of active I2C devices. */

        for (p = &d->pI2CBus->FirstDev; *p != NULL; p = &(*p)->NextDev)
            if (*p == d) {
                *p = (*p)->NextDev;
                break;
            }

        xf86DrvMsg(d->pI2CBus->scrnIndex, X_INFO,
                   "I2C device \"%s:%s\" removed.\n",
                   d->pI2CBus->BusName, d->DevName);

        if (unalloc)
            free(d);
    }
}

/* I2C transmissions are related to an I2CDevRec you must link to a
 * previously registered bus (see xf86I2CBusInit) before attempting
 * to read and write data. You may call xf86I2CProbeAddress first to
 * see if the device in question is present on this bus.
 *
 * xf86I2CDevInit will not allocate an I2CBusRec for you, instead you
 * may enter a pointer to a statically allocated I2CDevRec or the (modified)
 * result of xf86CreateI2CDevRec.
 *
 * If you don't specify timeouts for the device (n <= 0), it will inherit
 * the bus-wide defaults. The function returns TRUE on success.
 */

Bool
xf86I2CDevInit(I2CDevPtr d)
{
    I2CBusPtr b;

    if (d == NULL ||
        (b = d->pI2CBus) == NULL ||
        (d->SlaveAddr & 1) || xf86I2CFindDev(b, d->SlaveAddr) != NULL)
        return FALSE;

    if (d->BitTimeout <= 0)
        d->BitTimeout = b->BitTimeout;
    if (d->ByteTimeout <= 0)
        d->ByteTimeout = b->ByteTimeout;
    if (d->AcknTimeout <= 0)
        d->AcknTimeout = b->AcknTimeout;
    if (d->StartTimeout <= 0)
        d->StartTimeout = b->StartTimeout;

    d->NextDev = b->FirstDev;
    b->FirstDev = d;

    xf86DrvMsg(b->scrnIndex, X_INFO,
               "I2C device \"%s:%s\" registered at address 0x%02X.\n",
               b->BusName, d->DevName, d->SlaveAddr);

    return TRUE;
}

I2CDevPtr
xf86I2CFindDev(I2CBusPtr b, I2CSlaveAddr addr)
{
    I2CDevPtr d;

    if (b) {
        for (d = b->FirstDev; d != NULL; d = d->NextDev)
            if (d->SlaveAddr == addr)
                return d;
    }

    return NULL;
}

static I2CBusPtr I2CBusList;

/* Allocates an I2CBusRec for you and initializes with propper defaults
 * you may modify before calling xf86I2CBusInit. Your I2CBusRec must
 * contain at least a BusName, a scrnIndex (or -1), and a complete set
 * of either high or low level I2C function pointers. You may pass
 * bus-wide timeouts, otherwise inplausible values will be replaced
 * with safe defaults.
 */

I2CBusPtr
xf86CreateI2CBusRec(void)
{
    I2CBusPtr b;

    b = (I2CBusPtr) calloc(1, sizeof(I2CBusRec));

    if (b != NULL) {
        b->scrnIndex = -1;
        b->pScrn = NULL;
        b->HoldTime = 5;        /* 100 kHz bus */
        b->BitTimeout = 5;
        b->ByteTimeout = 5;
        b->AcknTimeout = 5;
        b->StartTimeout = 5;
        b->RiseFallTime = RISEFALLTIME;
    }

    return b;
}

/* Unregister an I2C bus. If you got the I2CBusRec from xf86CreateI2CBusRec
 * you should set <unalloc> to free it. If you set <devs_too>, the function
 * xf86DestroyI2CDevRec will be called for all devices linked to the bus
 * first, passing down the <unalloc> option.
 */

void
xf86DestroyI2CBusRec(I2CBusPtr b, Bool unalloc, Bool devs_too)
{
    if (b) {
        I2CBusPtr *p;

        /* Remove this from the list of active I2C buses */

        for (p = &I2CBusList; *p != NULL; p = &(*p)->NextBus)
            if (*p == b) {
                *p = (*p)->NextBus;
                break;
            }

        if (b->FirstDev != NULL) {
            if (devs_too) {
                I2CDevPtr d;

                while ((d = b->FirstDev) != NULL) {
                    b->FirstDev = d->NextDev;
                    xf86DestroyI2CDevRec(d, unalloc);
                }
            }
            else {
                if (unalloc) {
                    xf86Msg(X_ERROR,
                            "i2c bug: Attempt to remove I2C bus \"%s\", "
                            "but device list is not empty.\n", b->BusName);
                    return;
                }
            }
        }

        xf86DrvMsg(b->scrnIndex, X_INFO, "I2C bus \"%s\" removed.\n",
                   b->BusName);

        if (unalloc)
            free(b);
    }
}

/* I2C masters have to register themselves using this function.
 * It will not allocate an I2CBusRec for you, instead you may enter
 * a pointer to a statically allocated I2CBusRec or the (modified)
 * result of xf86CreateI2CBusRec. Returns TRUE on success.
 *
 * At this point there won't be any traffic on the I2C bus.
 */

Bool
xf86I2CBusInit(I2CBusPtr b)
{
    /* I2C buses must be identified by a unique scrnIndex
     * and name. If scrnIndex is unspecified (a negative value),
     * then the name must be unique throughout the server.
     */

    if (b->BusName == NULL || xf86I2CFindBus(b->scrnIndex, b->BusName) != NULL)
        return FALSE;

    /* If the high level functions are not
     * supplied, use the generic functions.
     * In this case we need the low-level
     * function.
     */
    if (b->I2CWriteRead == NULL) {
        b->I2CWriteRead = I2CWriteRead;

        if (b->I2CPutBits == NULL || b->I2CGetBits == NULL) {
            if (b->I2CPutByte == NULL ||
                b->I2CGetByte == NULL ||
                b->I2CAddress == NULL ||
                b->I2CStart == NULL || b->I2CStop == NULL)
                return FALSE;
        }
        else {
            b->I2CPutByte = I2CPutByte;
            b->I2CGetByte = I2CGetByte;
            b->I2CAddress = I2CAddress;
            b->I2CStop = I2CStop;
            b->I2CStart = I2CStart;
        }
    }

    if (b->I2CUDelay == NULL)
        b->I2CUDelay = I2CUDelay;

    if (b->HoldTime < 2)
        b->HoldTime = 5;
    if (b->BitTimeout <= 0)
        b->BitTimeout = b->HoldTime;
    if (b->ByteTimeout <= 0)
        b->ByteTimeout = b->HoldTime;
    if (b->AcknTimeout <= 0)
        b->AcknTimeout = b->HoldTime;
    if (b->StartTimeout <= 0)
        b->StartTimeout = b->HoldTime;

    /* Put new bus on list. */

    b->NextBus = I2CBusList;
    I2CBusList = b;

    xf86DrvMsg(b->scrnIndex, X_INFO, "I2C bus \"%s\" initialized.\n",
               b->BusName);

    return TRUE;
}

I2CBusPtr
xf86I2CFindBus(int scrnIndex, char *name)
{
    I2CBusPtr p;

    if (name != NULL)
        for (p = I2CBusList; p != NULL; p = p->NextBus)
            if (scrnIndex < 0 || p->scrnIndex == scrnIndex)
                if (!strcmp(p->BusName, name))
                    return p;

    return NULL;
}

/*
 * Return an array of I2CBusPtr's related to a screen.  The caller is
 * responsible for freeing the array.
 */
int
xf86I2CGetScreenBuses(int scrnIndex, I2CBusPtr ** pppI2CBus)
{
    I2CBusPtr pI2CBus;
    int n = 0;

    if (pppI2CBus)
        *pppI2CBus = NULL;

    for (pI2CBus = I2CBusList; pI2CBus; pI2CBus = pI2CBus->NextBus) {
        if ((pI2CBus->scrnIndex >= 0) && (pI2CBus->scrnIndex != scrnIndex))
            continue;

        n++;

        if (!pppI2CBus)
            continue;

        *pppI2CBus = xnfreallocarray(*pppI2CBus, n, sizeof(I2CBusPtr));
        (*pppI2CBus)[n - 1] = pI2CBus;
    }

    return n;
}
@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d875 1
a875 1
        *pppI2CBus = xnfrealloc(*pppI2CBus, n * sizeof(I2CBusPtr));
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d4 1
a4 1
 * The original code was derived from and inspired by 
d55 1
a55 1
            /* It would be nice to use {xf86}usleep, 
d77 1
a77 1
/* Some devices will hold SCL low to slow down the bus or until 
d209 1
a209 1
 * The function returns FALSE if a timeout occurs, you should send 
d270 1
a270 1
 * 
d278 1
a278 1
 * For the <last> byte in a sequence the acknowledge bit NACK (1), 
d314 1
a314 1
 * I2CStart/PutByte because a hardware I2C master may not be able 
d318 1
a318 1
 * StartTimeout, similar to the ByteTimeout but for the start 
d328 1
a328 1
 * The most significant byte of the address will be sent _after_ the LSB, 
d357 1
a357 1
/* Function for probing. Just send the slave address 
d406 1
a406 1
 * be executed anyway to leave the bus in clean idle state. 
d473 1
a473 1
/* Read bytes from subsequent registers determined by the 
d483 1
a483 1
/* Read a word (high byte, then low byte) from one of the registers 
d514 1
a514 1
/* Write bytes to subsequent registers determined by the 
d540 1
a540 1
/* Write a word (high byte, then low byte) to one of the registers 
d556 1
a556 1
/* Write a vector of bytes to not adjacent registers. This vector is, 
d640 1
a640 1
 * see if the device in question is present on this bus. 
d782 3
a784 3
    /* I2C buses must be identified by a unique scrnIndex 
     * and name. If scrnIndex is unspecified (a negative value), 
     * then the name must be unique throughout the server. 
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d712 1
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a8 1

d34 2
a35 2
#define I2C_TIMEOUT(x)	/*(x)*/  /* Report timeouts */
#define I2C_TRACE(x)    /*(x)*/  /* Report progress */
d48 16
a63 16
  struct timeval begin, cur;
  long d_secs, d_usecs;
  long diff;

  if (usec > 0) {
    X_GETTIMEOFDAY(&begin);
    do {
      /* It would be nice to use {xf86}usleep, 
       * but usleep (1) takes >10000 usec !
       */
      X_GETTIMEOFDAY(&cur);
      d_secs  = (cur.tv_sec - begin.tv_sec);
      d_usecs = (cur.tv_usec - begin.tv_usec);
      diff = d_secs*1000000 + d_usecs;
    } while (diff>=0 && diff< (usec + 1));
  }
d75 1
a75 1
#define RISEFALLTIME 2 /* usec, actually 300 to 1000 ns according to the i2c specs */
d94 4
a97 3
	b->I2CGetBits(b, &scl, &sda);
	if (scl) break;
	b->I2CUDelay(b, b->RiseFallTime);
d101 4
a104 2
	I2C_TIMEOUT(ErrorF("[I2CRaiseSCL(<%s>, %d, %d) timeout]", b->BusName, sda, timeout));    
	return FALSE;
d133 1
a133 1
	return FALSE;
d230 1
a230 1
	return FALSE;
d233 2
a234 2
	if (!I2CWriteBit(b, (data >> i) & 1, d->BitTimeout))
	    return FALSE;
d242 13
a254 12
    	for (i = d->AcknTimeout; i > 0; i -= b->HoldTime) {
	    b->I2CUDelay(b, b->HoldTime);
	    b->I2CGetBits(b, &scl, &sda);
	    if (sda == 0) break;
	}

	if (i <= 0) {
	    I2C_TIMEOUT(ErrorF("[I2CPutByte(<%s>, 0x%02x, %d, %d, %d) timeout]", 
				       b->BusName, data, d->BitTimeout, 
				       d->ByteTimeout, d->AcknTimeout));
	    r = FALSE;
	}
d256 1
a256 1
	I2C_TRACE(ErrorF("W%02x%c ", (int) data, sda ? '-' : '+'));
d283 1
a283 1
I2CGetByte(I2CDevPtr d, I2CByte *data, Bool last)
d292 1
a292 1
	return FALSE;
d297 4
a300 4
	if (!I2CReadBit(b, &sda, d->BitTimeout))
	    return FALSE;
	else
	    *data |= (sda > 0) << i;
d303 1
a303 1
	return FALSE;
d339 3
a341 8
	if (I2CPutByte(d, addr & 0xFF)) {
	    if ((addr & 0xF8) != 0xF0 &&
		(addr & 0xFE) != 0x00)
		return TRUE;

	    if (I2CPutByte(d, (addr >> 8) & 0xFF))
		return TRUE;
	}
d343 5
a347 1
	I2CStop(d);
d380 2
a381 1
    if (r) b->I2CStop(&d);
d411 1
a411 2
		 I2CByte *WriteBuffer, int nWrite,
		 I2CByte *ReadBuffer,  int nRead) 
d418 7
a424 7
	r = b->I2CAddress(d, d->SlaveAddr & ~1);
	if (r) {
	    for (; nWrite > 0; WriteBuffer++, nWrite--)
		if (!(r = b->I2CPutByte(d, *WriteBuffer))) 
		    break;
	    s++;
	}
d428 7
a434 7
	r = b->I2CAddress(d, d->SlaveAddr | 1);
	if (r) {
	    for (; nRead > 0; ReadBuffer++, nRead--)
		if (!(r = b->I2CGetByte(d, ReadBuffer, nRead == 1))) 
		    break;
	    s++;
	}
d437 2
a438 1
    if (s) b->I2CStop(d);
d447 2
a448 2
		 I2CByte *WriteBuffer, int nWrite,
		 I2CByte *ReadBuffer,  int nRead) 
d451 2
a452 1
    return b->I2CWriteRead(d,WriteBuffer,nWrite,ReadBuffer,nRead);
d459 1
a459 1
xf86I2CReadStatus(I2CDevPtr d, I2CByte *pbyte)
d468 1
a468 1
xf86I2CReadByte(I2CDevPtr d, I2CByte subaddr, I2CByte *pbyte)
d478 1
a478 1
xf86I2CReadBytes(I2CDevPtr d, I2CByte subaddr, I2CByte *pbyte, int n)
d492 2
a493 1
    if (!xf86I2CWriteRead(d, &subaddr, 1, rb, 2)) return FALSE;
d519 2
a520 2
xf86I2CWriteBytes(I2CDevPtr d, I2CByte subaddr, 
		  I2CByte *WriteBuffer, int nWrite)
d526 6
a531 6
	r = b->I2CAddress(d, d->SlaveAddr & ~1);
	if (r){
	    if ((r = b->I2CPutByte(d, subaddr)))
		for (; nWrite > 0; WriteBuffer++, nWrite--)
		    if (!(r = b->I2CPutByte(d, *WriteBuffer))) 
			break;
d533 2
a534 2
	    b->I2CStop(d);
	}
d564 1
a564 1
xf86I2CWriteVec(I2CDevPtr d, I2CByte *vec, int nValues)
d571 3
a573 3
	for (; nValues > 0; nValues--, vec += 2) {
	    if (!(r = b->I2CAddress(d, d->SlaveAddr & ~1)))
	    	break;
d575 1
a575 1
	    s++;
d577 2
a578 2
	    if (!(r = b->I2CPutByte(d, vec[0])))
		break;
d580 3
a582 3
	    if (!(r = b->I2CPutByte(d, vec[1]))) 
		break;
	}
d584 2
a585 1
	if (s > 0) b->I2CStop(d);	
d605 1
a605 1
xf86CreateI2CDevRec(void) 
d615 1
a615 1
xf86DestroyI2CDevRec(I2CDevPtr d, Bool unalloc) 
d618 1
a618 3
	I2CDevPtr *p;

	/* Remove this from the list of active I2C devices. */
d620 1
a620 5
	for (p = &d->pI2CBus->FirstDev; *p != NULL; p = &(*p)->NextDev) 
	    if (*p == d) {
		*p = (*p)->NextDev;
		break;
	    }
d622 9
a630 3
	xf86DrvMsg(d->pI2CBus->scrnIndex, X_INFO,
		   "I2C device \"%s:%s\" removed.\n",
		   d->pI2CBus->BusName, d->DevName);
d632 2
a633 1
	if (unalloc) free(d);
d651 1
a651 1
xf86I2CDevInit(I2CDevPtr d) 
d656 12
a667 9
	(b = d->pI2CBus) == NULL ||
        (d->SlaveAddr & 1) ||
        xf86I2CFindDev(b, d->SlaveAddr) != NULL)
	return FALSE;

    if (d->BitTimeout <= 0) d->BitTimeout = b->BitTimeout;
    if (d->ByteTimeout <= 0) d->ByteTimeout = b->ByteTimeout;
    if (d->AcknTimeout <= 0) d->AcknTimeout = b->AcknTimeout;
    if (d->StartTimeout <= 0) d->StartTimeout = b->StartTimeout;
d673 2
a674 2
	       "I2C device \"%s:%s\" registered at address 0x%02X.\n",
	       b->BusName, d->DevName, d->SlaveAddr);
d680 1
a680 1
xf86I2CFindDev(I2CBusPtr b, I2CSlaveAddr addr) 
d684 4
a687 4
    if (b) { 
         for (d = b->FirstDev; d != NULL; d = d->NextDev) 
	    if (d->SlaveAddr == addr)
		return d;
d704 1
a704 1
xf86CreateI2CBusRec(void) 
d711 7
a717 7
	b->scrnIndex = -1;
	b->HoldTime = 5; /* 100 kHz bus */
	b->BitTimeout = 5;
	b->ByteTimeout = 5;
	b->AcknTimeout = 5;
	b->StartTimeout = 5;
	b->RiseFallTime = RISEFALLTIME;
d730 1
a730 1
xf86DestroyI2CBusRec(I2CBusPtr b, Bool unalloc, Bool devs_too) 
d733 1
a733 1
	I2CBusPtr *p;
d735 1
a735 1
	/* Remove this from the list of active I2C buses */
d737 24
a760 23
	for (p = &I2CBusList; *p != NULL; p = &(*p)->NextBus) 
	    if (*p == b) {
		*p = (*p)->NextBus;
		break;
	    }

	if (b->FirstDev != NULL) {
	    if (devs_too) {
		I2CDevPtr d;

		while ((d = b->FirstDev) != NULL) {
		    b->FirstDev = d->NextDev;
		    xf86DestroyI2CDevRec(d, unalloc);
		}
	    } else {
		if (unalloc) {
		    xf86Msg(X_ERROR, "i2c bug: Attempt to remove I2C bus \"%s\", "
			    "but device list is not empty.\n",
			    b->BusName);
		    return;
		}
	    }
	}
d762 2
a763 2
	xf86DrvMsg(b->scrnIndex, X_INFO, "I2C bus \"%s\" removed.\n",
		   b->BusName);
d765 2
a766 1
	if (unalloc) free(b);
d779 1
a779 1
xf86I2CBusInit(I2CBusPtr b) 
d786 2
a787 3
    if (b->BusName == NULL ||
	xf86I2CFindBus(b->scrnIndex, b->BusName) != NULL)
	return FALSE;
d794 16
a809 19
    if (b->I2CWriteRead == NULL) 
    {
        b->I2CWriteRead=I2CWriteRead;

        if (b->I2CPutBits == NULL ||
	    b->I2CGetBits == NULL) 
        {
	    if (b->I2CPutByte == NULL ||
	        b->I2CGetByte == NULL ||
	        b->I2CAddress == NULL ||
	        b->I2CStart   == NULL ||
	        b->I2CStop    == NULL)
	        return FALSE;
        } else { 
	    b->I2CPutByte = I2CPutByte;
	    b->I2CGetByte = I2CGetByte;
	    b->I2CAddress = I2CAddress;
	    b->I2CStop    = I2CStop;
	    b->I2CStart   = I2CStart;
d811 1
a811 1
     }
d814 1
a814 1
	b->I2CUDelay = I2CUDelay;
d816 10
a825 5
    if (b->HoldTime < 2) b->HoldTime = 5;
    if (b->BitTimeout <= 0) b->BitTimeout = b->HoldTime;
    if (b->ByteTimeout <= 0) b->ByteTimeout = b->HoldTime;
    if (b->AcknTimeout <= 0) b->AcknTimeout = b->HoldTime;
    if (b->StartTimeout <= 0) b->StartTimeout = b->HoldTime;
d833 1
a833 1
	       b->BusName);
d839 1
a839 1
xf86I2CFindBus(int scrnIndex, char *name) 
d844 5
a848 5
	for (p = I2CBusList; p != NULL; p = p->NextBus)
	    if (scrnIndex < 0 || p->scrnIndex == scrnIndex)
		if (!strcmp(p->BusName, name))
		    return p;
    
d857 1
a857 1
xf86I2CGetScreenBuses(int scrnIndex, I2CBusPtr **pppI2CBus)
d863 1
a863 1
	*pppI2CBus = NULL;
d865 3
a867 3
    for (pI2CBus = I2CBusList;  pI2CBus;  pI2CBus = pI2CBus->NextBus) {
	if ((pI2CBus->scrnIndex >= 0) && (pI2CBus->scrnIndex != scrnIndex))
	    continue;
d869 1
a869 1
	n++;
d871 2
a872 2
	if (!pppI2CBus)
	    continue;
d875 1
a875 1
	(*pppI2CBus)[n - 1] = pI2CBus;
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d601 1
a601 1
    return xcalloc(1, sizeof(I2CDevRec));
d626 1
a626 1
	if (unalloc) xfree(d);
d698 1
a698 1
    b = (I2CBusPtr) xcalloc(1, sizeof(I2CBusRec));
d754 1
a754 1
	if (unalloc) xfree(b);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a37 6
/* Set which OSs have bad gettimeofday resolution. */
#if defined(SVR4) && !defined(sun)
#define BAD_GETTIMEOFDAY_RESOLUTION
#endif


a45 17
#ifdef BAD_GETTIMEOFDAY_RESOLUTION
/*
 * This is temporary until a better, portable
 * way is found. Adjust bogo_usec to match CPU speed.
 */
static int bogo_usec = 500;

static void
I2CUDelay(I2CBusPtr b, int usec)
{
    volatile long i;

    if (usec > 0)
	for (i = usec * bogo_usec; i > 0; i--)
	    /* (perhaps hw delay action) */;
}
#else
a65 1
#endif
@


1.1
log
@Initial revision
@
text
@d886 1
a886 1
	*pppI2CBus[n - 1] = pI2CBus;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
