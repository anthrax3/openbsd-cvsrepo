head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.3.0.10
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.8
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.1.1.0.16
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.09.16.19.10.22;	author matthieu;	state dead;
branches;
next	1.4;
commitid	Te1daavkBLskZ8gc;

1.4
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.3;
commitid	cVXoV5PxI8YrEaVA;

1.3
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.39;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.39;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <string.h>
#include <unistd.h>

#include "xf86.h"
#include "xf86i2c.h"
#include "msp3430.h"
#include "i2c_def.h"

#define CONTROL         0x00
#define WR_DEM          0x10
#define RD_DEM          0x11
#define WR_DSP          0x12
#define RD_DSP          0x13

void InitMSP34xxG(MSP3430Ptr m);
void InitMSP34x5D(MSP3430Ptr m);
void CheckModeMSP34x5D(MSP3430Ptr m);
static const char *MSP_getProductName(CARD16 product_id);
void mpause(int milliseconds);

#define __MSPDEBUG__	0

#if __MSPDEBUG__ > 3

void MSPBeep(MSP3430Ptr m, CARD8 freq);

#define __MSPBEEP MSPBeep(m,0x14);

#else

#define __MSPBEEP
#endif

static void
SetMSP3430Control(MSP3430Ptr m, CARD8 RegAddress, CARD8 RegValueHigh,
                  CARD8 RegValueLow)
{
    I2CByte data[3];

    data[0] = RegAddress;
    data[1] = RegValueHigh;
    data[2] = RegValueLow;

    I2C_WriteRead(&(m->d), data, 3, NULL, 0);
}

static void
SetMSP3430Data(MSP3430Ptr m, CARD8 RegAddress, CARD8 RegSubAddressHigh,
               CARD8 RegSubAddressLow, CARD8 RegValueHigh, CARD8 RegValueLow)
{
    I2CByte data[5];

#ifdef MSP_DEBUG
    if (!m->registers_present[RegSubAddressLow]) {
        xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_ERROR,
                   "Attempt to access non-existent register in MSP34xxX: 0x%02x 0x%02x 0x%02x <- 0x%02x 0x%02x\n",
                   RegAddress, RegSubAddressHigh, RegSubAddressLow,
                   RegValueHigh, RegValueLow);
    }
#endif

    data[0] = RegAddress;
    data[1] = RegSubAddressHigh;
    data[2] = RegSubAddressLow;
    data[3] = RegValueHigh;
    data[4] = RegValueLow;

    I2C_WriteRead(&(m->d), data, 5, NULL, 0);
}

static void
GetMSP3430Data(MSP3430Ptr m, CARD8 RegAddress, CARD8 RegSubAddressHigh,
               CARD8 RegSubAddressLow, CARD8 *RegValueHigh, CARD8 *RegValueLow)
{
    I2CByte send[3];
    I2CByte receive[2];

    send[0] = RegAddress;
    send[1] = RegSubAddressHigh;
    send[2] = RegSubAddressLow;

    I2C_WriteRead(&(m->d), send, 3, receive, 2);

    *RegValueHigh = receive[0];
    *RegValueLow = receive[1];
}

#if __MSPDEBUG__ > 2
static void
MSP3430DumpStatus(MSP3430Ptr m)
{
    CARD8 status_hi, status_lo;
    CARD8 subaddr, data[2];

    GetMSP3430Data(m, RD_DEM, 0x02, 0x00, &status_hi, &status_lo);
    xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO,
               "MSP34xx: SAP(8)=%d mono/NICAM(7)=%d stereo=%d %s O_1=%d O_0=%d 2nd car=%d 1st car=%d\n",
               status_hi & 1, (status_lo >> 7) & 1, (status_lo >> 6) & 1,
               (status_lo >> 5) ? ((status_hi >> 1) & 1 ? "bad NICAM reception"
                                   : "NICAM") : ((status_hi >> 1) & 1 ? "bogus"
                                                 : "ANALOG FM/AM"),
               (status_lo >> 4) & 1, (status_lo >> 3) & 1,
               !((status_lo >> 2) & 1), !((status_lo >> 1) & 1));

    GetMSP3430Data(m, RD_DEM, 0x00, 0x7E, &status_hi, &status_lo);
    xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO,
               "MSP34xx: standard result=0x%02x%02x\n", status_hi, status_lo);
    subaddr = 0x0;
    I2C_WriteRead(&(m->d), &subaddr, 1, data, 2);
    xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO, "MSP34xx: control=0x%02x%02x\n",
               data[1], data[0]);
}
#endif

/* wrapper */
void
InitMSP3430(MSP3430Ptr m)
{
#if __MSPDEBUG__ > 1
    xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO,
               "InitMSP3430(m->connector=%d, m->standard=%d, m->chip_family=%d)\n",
               m->connector, m->standard, m->chip_family);
#endif
    switch (m->chip_family) {
    case MSPFAMILY_34x0G:
        InitMSP34xxG(m);
        break;
    case MSPFAMILY_34x5G:
        InitMSP34xxG(m);
        break;
    case MSPFAMILY_34x5D:
        InitMSP34x5D(m);
        break;
    }
}

/*-----------------------------------------------------------------
| common functions for all MSP34xx chips 
|----------------------------------------------------------------*/

MSP3430Ptr
DetectMSP3430(I2CBusPtr b, I2CSlaveAddr addr)
{
    MSP3430Ptr m;
    I2CByte a;
    CARD8 hardware_version, major_revision, product_code, rom_version;
    Bool supported;

    m = calloc(1, sizeof(MSP3430Rec));
    if (m == NULL)
        return NULL;
    m->d.DevName = strdup("MSP34xx");
    m->d.SlaveAddr = addr;
    m->d.pI2CBus = b;
    m->d.NextDev = NULL;
    m->d.StartTimeout = b->StartTimeout;
    m->d.BitTimeout = b->BitTimeout;
    m->d.AcknTimeout = b->AcknTimeout;
    m->d.ByteTimeout = b->ByteTimeout;

    if (!I2C_WriteRead(&(m->d), NULL, 0, &a, 1)) {
        free((void *) m->d.DevName);
        free(m);
        return NULL;
    }

    m->standard = MSP3430_NTSC;
    m->connector = MSP3430_CONNECTOR_1;
    m->mode = MSPMODE_STEREO_A; /*stereo or chanel A if avail. */
    m->c_format = MSPFORMAT_UNKNOWN;
    m->c_standard = MSPSTANDARD_UNKNOWN;
    m->c_matrix = m->c_fmmatrix = m->c_source = 0;
    m->volume = 0;
    m->recheck = FALSE;

    GetMSP3430Data(m, RD_DSP, 0x00, 0x1E, &hardware_version, &major_revision);
    GetMSP3430Data(m, RD_DSP, 0x00, 0x1F, &product_code, &rom_version);
    m->hardware_version = hardware_version;
    m->major_revision = major_revision;
    m->product_code = product_code;
    m->rom_version = rom_version;

    m->chip_id = ((major_revision << 8) | product_code);

    supported = FALSE;
    switch (major_revision) {
    case 4:                    /* 34xxD */
        switch (product_code) {
        case 0x05:             /* 3405D */
        case 0x0A:             /* 3410D */
        case 0x0F:             /* 3415D */
            m->chip_family = MSPFAMILY_34x5D;
            m->recheck = TRUE;
            supported = TRUE;
            break;
        default:
            m->chip_family = MSPFAMILY_34x0D;
        }
        break;
    case 7:                    /* 34xxG */
        switch (product_code) {
        case 0x00:
        case 0x0A:
        case 0x1E:
        case 0x28:
        case 0x32:
            m->chip_family = MSPFAMILY_34x0G;
            supported = TRUE;
            break;
        case 0x0f:
        case 0x19:
        case 0x2d:
        case 0x37:
        case 0x41:
            m->chip_family = MSPFAMILY_34x5G;
            supported = TRUE;
#ifdef MSP_DEBUG
            memset(m->registers_present, 0, 256);
#define A(num) m->registers_present[(num)]=1;
#define B(num1, num2) memset(&(m->registers_present[num1]), 1, num2-num1);
            A(0x20)
                A(0x30)
                A(0x40)
                A(0x00)
                B(0x01, 0x08)
                B(0x0B, 0x0E)
                A(0x10)
                B(0x12, 0x14)
                A(0x16)
                A(0x29)
#undef B
#undef A
#endif
                break;
        default:
            m->chip_family = MSPFAMILY_UNKNOWN;
        }
        break;
    default:
        m->chip_family = MSPFAMILY_UNKNOWN;
    }

    xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO,
               "Found %s%s, rom version 0x%02x, chip_id=0x%04x\n",
               MSP_getProductName(m->chip_id),
               supported ? "" : " (unsupported)", rom_version, m->chip_id);

    if (!supported) {
        free((void *) m->d.DevName);
        free(m);
        return NULL;
    }
    if (!I2CDevInit(&(m->d))) {
        free((void *) m->d.DevName);
        free(m);
        return NULL;
    }

    return m;
}

void
ResetMSP3430(MSP3430Ptr m)
{
    /* Reset the MSP3430 */
    SetMSP3430Control(m, 0x00, 0x80, 0x00);
    /* Set it back to normal operation */
    SetMSP3430Control(m, 0x00, 0x00, 0x00);

    m->c_format = MSPFORMAT_UNKNOWN;
    m->c_standard = MSPSTANDARD_UNKNOWN;
    m->c_matrix = m->c_fmmatrix = m->c_source = 0;
    m->volume = 0;
}

void
MSP3430SetVolume(MSP3430Ptr m, CARD8 value)
{
    CARD8 result;

#if 0
    CARD8 old_volume;

    GetMSP3430Data(m, RD_DSP, 0x00, 0x00, &old_volume, &result);
    xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO, "MSP3430 result 0x%02x\n",
               result);
#endif
    /* save an extra Get call */
    result = 0;

    SetMSP3430Data(m, WR_DSP, 0x00, 0x00, value, result);

    SetMSP3430Data(m, WR_DSP, 0x00, 0x07, value, 0);
    m->volume = value;

#if __MSPDEBUG__ > 2
    MSP3430DumpStatus(m);
    __MSPBEEP GetMSP3430Data(m, RD_DSP, 0x00, 0x00, &old_volume, &result);
    xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO, "MSP3430 volume 0x%02x\n",
               value);
#endif
}

void
MSP3430SetSAP(MSP3430Ptr m, int mode)
{
    xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO,
               "Put actual code to change SAP here\n");

    SetMSP3430Data(m, WR_DSP, 0x00, 0x08, mode & 0xff, 0x20);
}

#if 0
void
MSP3430SetSource(MSP3430Ptr m, CARD8 value)
{
    /* Write to DSP, register 0x0008, (loudspeaker channel source/matrix) */
    /* This sets the source to the TV tuner, for stereo operation */
    SetMSP3430Data(m, WR_DSP, 0x00, 0x08, value, 0x20);
}
#endif

static const char *
MSP_getProductName(CARD16 product_id)
{
    switch (product_id) {
    case 0x0400:
        return "MSP3400D";
    case 0x040a:
        return "MSP3410D";
    case 0x0405:
        return "MSP3405D";
    case 0x040f:
        return "MSP3415D";
    case 0x0700:
        return "MSP3400G";
    case 0x070a:
        return "MSP3410G";
    case 0x071e:
        return "MSP3430G";
    case 0x0728:
        return "MSP3440G";
    case 0x0732:
        return "MSP3450G";
    case 0x070f:
        return "MSP3415G";
    case 0x0719:
        return "MSP3425G";
    case 0x072d:
        return "MSP3445G";
    case 0x0737:
        return "MSP3455G";
    case 0x0741:
        return "MSP3465G";
    }
    return "MSP - unknown type";
}

#if __MSPDEBUG__ > 2
/*puts beep in MSP output
    freq = 0x01 - 16Hz ... 0x40 - 1kHz ... 0xff - 4kHz  
*/
void
MSPBeep(MSP3430Ptr m, CARD8 freq)
{
    SetMSP3430Data(m, WR_DSP, 0x00, freq, 0x7f, 0x40);
    mpause(100);
    SetMSP3430Data(m, WR_DSP, 0x00, 0x14, 0x00, 0x00);
}
#endif

void
mpause(int milliseconds)
{
    int i, m;

    m = milliseconds / 20;
    for (i = 0; i < m; i++)
        usleep(20000);
}

/*-----------------------------------------------------------------
| specific functions for all MSP34xxG chips 
|----------------------------------------------------------------*/

void
InitMSP34xxG(MSP3430Ptr m)
{

#if __MSPDEBUG__ > 1
    xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO,
               "InitMSP34xxG(m->connector=%d, m->standard=%d, m->chip_family=%d)\n",
               m->connector, m->standard, m->chip_family);
#endif
    /* Reset MSP3430 */
    SetMSP3430Control(m, 0x00, 0x80, 0x00);
    /* Set it back to normal operation */
    SetMSP3430Control(m, 0x00, 0x00, 0x00);

    /*set MODUS register */
    /* bits: 0 - automatic sound detection */
    /*       1 - enable STATUS change */
    /*       12 - detect 6.5 Mhz carrier as D/K1, D/K2 or D/K NICAM  (does not seem to work ) */
    /*       13 - detect 4.5 Mhz carrier as BTSC */
    if ((m->standard & 0xff) == MSP3430_PAL) {
        SetMSP3430Data(m, WR_DEM, 0x00, 0x30, 0x30, 0x03 | 0x08);       /* make O_ pins tristate */
        /* PAL standard */
        SetMSP3430Data(m, WR_DEM, 0x00, 0x20, 0x00, 0x01);      /* possibly wrong */
    }
    else {
        SetMSP3430Data(m, WR_DEM, 0x00, 0x30, 0x20, 0x03 | 0x08);
        /* standard selection is M-BTSC-Stereo */
        SetMSP3430Data(m, WR_DEM, 0x00, 0x20, 0x00, 0x20);
    }

    switch (m->connector) {
    case MSP3430_CONNECTOR_1:
        SetMSP3430Data(m, WR_DSP, 0x00, 0x08, 0x03, 0x20);
        break;
    case MSP3430_CONNECTOR_2:
        /* this has not been checked yet.. could be bogus */
        /* SCART Input Prescale: 0 dB gain */
        SetMSP3430Data(m, WR_DSP, 0x00, 0x0d, 0x19, 0x00);
        SetMSP3430Data(m, WR_DSP, 0x00, 0x08, 0x02, 0x20);
        break;
    case MSP3430_CONNECTOR_3:
    default:
        /* SCART Input Prescale: 0 dB gain */
        SetMSP3430Data(m, WR_DSP, 0x00, 0x0d, 0x19, 0x00);

        SetMSP3430Data(m, WR_DSP, 0x00, 0x08, 0x02, 0x20);
        break;
    }

    switch (m->standard) {
    case MSP3430_PAL:
        SetMSP3430Data(m, WR_DSP, 0x00, 0x0e, 0x24, 0x03);
        SetMSP3430Data(m, WR_DSP, 0x00, 0x10, 0x00, 0x5a);
        SetMSP3430Data(m, WR_DEM, 0x00, 0x20, 0x00, 0x03);
        /* Set volume to FAST_MUTE. */
        SetMSP3430Data(m, WR_DSP, 0x00, 0x00, 0xFF, 0x00);
        break;
    case MSP3430_PAL_DK1:
        SetMSP3430Data(m, WR_DSP, 0x00, 0x0e, 0x24, 0x03);
        SetMSP3430Data(m, WR_DSP, 0x00, 0x10, 0x00, 0x5a);
        SetMSP3430Data(m, WR_DEM, 0x00, 0x20, 0x00, 0x04);
        /* Set volume to FAST_MUTE. */
        SetMSP3430Data(m, WR_DSP, 0x00, 0x00, 0xFF, 0x00);
        break;
    case MSP3430_SECAM:        /* is this right ? */
    case MSP3430_NTSC:
        /* Write to DSP, register 0x000E, (prescale FM/FM matrix) */
        SetMSP3430Data(m, WR_DSP, 0x00, 0x0e, 0x24, 0x03);

        /* Set volume to FAST_MUTE. */
        SetMSP3430Data(m, WR_DSP, 0x00, 0x00, 0xFF, 0x00);
        break;
    }

}

/*-----------------------------------------------------------------
| specific functions for all MSP34x5D chips 
|----------------------------------------------------------------*/

void
InitMSP34x5D(MSP3430Ptr m)
{
    int count;
    CARD8 high, low;
    CARD16 result, standard;
    CARD16 peak;

    if (m->c_format == MSPFORMAT_UNKNOWN)
        ResetMSP3430(m);
    else {
        /*mute volume */
        SetMSP3430Data(m, WR_DSP, 0x00, 0x00, 0x00, 0x00);
    }

    switch (m->connector) {
    case MSP3430_CONNECTOR_2:
    case MSP3430_CONNECTOR_3:
        if (m->c_format != MSPFORMAT_SCART) {
            /* SCART Input Prescale: 0 dB gain */
            SetMSP3430Data(m, WR_DSP, 0x00, 0x0d, 0x19, 0x00);
            /* this has not been checked yet.. could be bogus */
            m->c_format = MSPFORMAT_SCART;      /*stereo */
        }
        break;
    case MSP3430_CONNECTOR_1:
    default:

        switch (m->standard & 0x00ff) {
        case MSP3430_PAL:
            switch (m->standard) {
            case MSP3430_PAL_DK1:
                standard = MSPSTANDARD_FM_DK1;
                break;
/*			case MSP3430_PAL_DK2:
			    standard=MSPSTANDARD_FM_DK2;
			    break;
			case MSP3430_PAL_BG:
			may be FM stereo (Germany) or FM NICAM (Scandinavia,spain)
			    standard=MSPSTANDARD_AUTO;
			    break;
*/
            default:
                standard = MSPSTANDARD_AUTO;
            }
            break;
        case MSP3430_SECAM:
            standard = MSPSTANDARD_AUTO;
        case MSP3430_NTSC:
            /* Only MSP34x5 supported format - Korean NTSC-M */
            standard = MSPSTANDARD_FM_M;
        default:
            standard = MSPSTANDARD_AUTO;
        }

        /*no NICAM support in MSP3410D - force to autodetect */
        if ((m->chip_id == 0x405) && (standard >= MSPSTANDARD_NICAM_BG))
            standard = MSPSTANDARD_AUTO;

        if (m->c_standard != standard) {

            SetMSP3430Data(m, WR_DEM, 0x00, 0x20, standard >> 8,
                           standard & 0xFF);
            if (standard == MSPSTANDARD_AUTO) {
                count = 50;     /* time shouldn't exceed 1s, just in case */
                do {
                    usleep(20000);
                    GetMSP3430Data(m, RD_DEM, 0x00, 0x7e, &high, &low);
                    result = (high << 8) | low;
                    --count;
                } while (result > 0x07ff && count > 0);

                if ((result > MSPSTANDARD_AUTO))
                    standard = result;
                else
                    standard = MSPSTANDARD_UNKNOWN;
#if __MSPDEBUG__ > 1
                xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO,
                           "Detected audio standard: %d\n", result);
#endif
                /* result = MSPSTANDARD_NICAM_L can be one of:
                   SECAM_L - MSPSTANDARD_NICAM_L
                   D/K1 - MSPSTANDARD_FM_DK1
                   D/K2 - MSPSTANDARD_FM_DK2
                   D/K-NICAM - MSPSTANDARD_NICAM_DK */
                if (standard == MSPSTANDARD_NICAM_L) {
                    if ((m->standard & 0x00ff) == MSP3430_PAL) {
                        /* force PAL D/K  */
                        standard = MSPSTANDARD_FM_DK1;
                        SetMSP3430Data(m, WR_DEM, 0x00, 0x20, standard >> 8,
                                       standard & 0xFF);
#if __MSPDEBUG__ > 1
                        xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO,
                                   "Detected 6.5MHz carrier - forced to D/K1 !!!\n");
#endif
                    }
                }
            }
            m->c_standard = standard;
        }                       /*end - standard changed */
        else {
            if (standard < MSPSTANDARD_NICAM_BG) {
                /* get old value of ident. mode register */
                GetMSP3430Data(m, RD_DSP, 0x00, 0x15, &high, &low);
                /* reset Ident-Filter */
                SetMSP3430Data(m, WR_DSP, 0x00, 0x14, 0x00, 0x3F);
                /* put back old value to ident. mode register */
                SetMSP3430Data(m, WR_DSP, 0x00, 0x14, 0x00, low);
            }
        }

        if (standard <= MSPSTANDARD_AUTO) {
            m->c_format = MSPFORMAT_1xFM;
        }
        else if (standard < MSPSTANDARD_NICAM_BG) {
            /* set FM prescale */
            SetMSP3430Data(m, WR_DSP, 0x00, 0x0e, 0x30, 0);
            /* set FM deemphasis */
            SetMSP3430Data(m, WR_DSP, 0x00, 0x0f,
                           ((standard == MSPSTANDARD_FM_M) ? 0 : 1), 0);

            /* check if FM2 carrier is present */
            /*turn off FM DC Notch */
            SetMSP3430Data(m, WR_DSP, 0x00, 0x17, 0x00, 0x3f);
            /*matrix source for Quasi-Peak Detector - stereo: ch2->L ch1->R */
            SetMSP3430Data(m, WR_DSP, 0x00, 0x0c, 0x00, 0x20);

            mpause(250);
            GetMSP3430Data(m, RD_DSP, 0x00, 0x1A, &high, &low);
            peak = (high << 8) | low;
#if __MSPDEBUG__ > 1
            xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO,
                       "Second carrier Quasi-Peak detection: %d\n", peak);
#endif
            /*turn on FM DC Notch */
            SetMSP3430Data(m, WR_DSP, 0x00, 0x17, 0x00, 0x00);

            if (peak < 5) {
                /* if second carrier not detected - only mono from first carrier */
                m->c_format = MSPFORMAT_1xFM;
            }
            else {
                m->c_format = MSPFORMAT_2xFM;
                /*start of FM identification process - FM_WAIT
                   wait at least 0.5s - used 1s - gives beter resolution */
                mpause(1000);
            }
        }
        else {
            if (standard == MSPSTANDARD_NICAM_L) {
                m->c_format = MSPFORMAT_NICAM_AM;
                /* set AM prescale */
                SetMSP3430Data(m, WR_DSP, 0x00, 0x0e, 0x7C, 0);
            }
            else {
                m->c_format = MSPFORMAT_NICAM_FM;
                /* set FM prescale */
                SetMSP3430Data(m, WR_DSP, 0x00, 0x0e, 0x30, 0);
            }
            /* set FM deemphasis */
            SetMSP3430Data(m, WR_DSP, 0x00, 0x0f, 0x00, 0);
            /* set NICAM prescale to 0dB */
            SetMSP3430Data(m, WR_DSP, 0x00, 0x10, 0x20, 0);
        }

        break;
    }                           /*end - case conector */

    CheckModeMSP34x5D(m);

    /* Set volume to FAST_MUTE. */
    /*SetMSP3430Data(m, WR_DSP, 0x00, 0x00, 0xFF, 0x00); */
    /*set volume */
    MSP3430SetVolume(m, m->volume);

__MSPBEEP}                      /* EnableMSP34x5D ()... */

void
CheckModeMSP34x5D(MSP3430Ptr m)
{
    const char stereo_on = 25;
    const char stereo_off = 20;
    const char dual_on = -stereo_on;
    const char dual_off = -stereo_off;
    char detect;
    CARD8 matrix, fmmatrix, source, high, low;

    fmmatrix = 0;               /*no matrix */
    source = 0;
    /*FM*/ switch (m->c_format) {
    case MSPFORMAT_NICAM_FM:
    case MSPFORMAT_NICAM_AM:
    case MSPFORMAT_SCART:
        source = ((m->c_format == MSPFORMAT_SCART) ? 2 : 1);
        switch (m->mode) {
        case MSPMODE_MONO:
            matrix = 0x30;
            /*MONO*/ break;
        case MSPMODE_A:
            matrix = 0x00;
            /*A*/ break;
        case MSPMODE_B:
            matrix = 0x10;
            /*B*/ break;
        default:
            matrix = 0x20;
            /*STEREO*/ break;
        }
        break;
    default:
    case MSPFORMAT_1xFM:
        matrix = 0x00;
        /*A*/ break;
    case MSPFORMAT_2xFM:
        switch (m->mode) {
        case MSPMODE_MONO:
            matrix = 0x30;
            /*MONO*/ break;
        case MSPMODE_STEREO:
            matrix = 0x20;
            /*STEREO*/ fmmatrix = ((m->c_standard == MSPSTANDARD_FM_M) ? 2 : 1);
            break;
        case MSPMODE_AB:
            matrix = 0x20;
            /*STEREO*/ break;
        case MSPMODE_A:
            matrix = 0x00;
            /*A*/ break;
        case MSPMODE_B:
            matrix = 0x10;
            /*B*/ break;
        default:
            /*FM_IDENT_CHECK */
            GetMSP3430Data(m, RD_DSP, 0x00, 0x18, &high, &low);
            detect = (char) high;
#if __MSPDEBUG__ > 1
            xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO,
                       "Stereo Detection Register: %d\n", detect);
#endif
            if (detect >=
                ((m->c_mode == MSPMODE_STEREO) ? stereo_off : stereo_on)) {
                m->c_mode = MSPMODE_STEREO;
                matrix = 0x20;
                /*STEREO*/
                    fmmatrix = ((m->c_standard == MSPSTANDARD_FM_M) ? 2 : 1);
            }
            else if (detect <= ((m->c_mode == MSPMODE_AB) ? dual_off : dual_on)) {
                m->c_mode = MSPMODE_AB;
                switch (m->mode) {
                case MSPMODE_STEREO_AB:
                    matrix = 0x20;
                    break;
                case MSPMODE_STEREO_B:
                    matrix = 0x10;
                    break;
                default:
                case MSPMODE_A:
                    matrix = 0x00;
                    break;
                }
            }
            else {
                m->c_mode = MSPMODE_MONO;
                matrix = 0x30;
            /*MONO*/}
            break;
        }                       /* end - case mode */
        break;
    }

    if (m->c_fmmatrix != fmmatrix) {
        GetMSP3430Data(m, RD_DSP, 0x00, 0x0e, &high, &low);
        SetMSP3430Data(m, WR_DSP, 0x00, 0x0e, high, fmmatrix);
        m->c_fmmatrix = fmmatrix;
    }

    if ((m->c_matrix != matrix) || (m->c_source != source)) {
        /*set chanel source and matrix for loudspeaker */
        SetMSP3430Data(m, WR_DSP, 0x00, 0x08, source, matrix);

        m->c_matrix = matrix;
        m->c_source = source;
    }

    if (((m->c_format) & 0xF0) == MSPFORMAT_NICAM)
        SetMSP3430Data(m, WR_DEM, 0x00, 0x21, 0, 1);

#if __MSPDEBUG__ > 0
    char *msg;

    switch (matrix) {
    case 0x30:
        /*MONO*/ msg = "MONO";
        break;
    case 0x00:
        /*LEFT*/ msg = "MONO/CHANNEL_1";
        break;
    case 0x10:
        /*RIGHT*/ msg = "MONO/CHANNEL_2";
        break;
    case 0x20:
        /*LEFT*/ msg = "STEREO";
        break;
    default:
        msg = "unknown";
        break;
    }
    xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO, "Audio mode set to: %s\n", msg);
#endif
}
@


1.4
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d166 1
a166 1
        free(m->d.DevName);
d253 1
a253 1
        free(m->d.DevName);
d258 1
a258 1
        free(m->d.DevName);
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a18 1

d22 1
a22 1
char *MSP_getProductName (CARD16 product_id);
d30 1
d35 1
a35 1
#define __MSPBEEP 
d38 3
a40 1
static void SetMSP3430Control(MSP3430Ptr m, CARD8 RegAddress, CARD8 RegValueHigh, CARD8 RegValueLow)
d42 7
a48 7
   I2CByte data[3];
   
   data[0]=RegAddress;
   data[1]=RegValueHigh;
   data[2]=RegValueLow;
   
   I2C_WriteRead(&(m->d),data,3,NULL,0);
d51 3
a53 2
static void SetMSP3430Data(MSP3430Ptr m, CARD8 RegAddress, CARD8 RegSubAddressHigh, CARD8 RegSubAddressLow, 
     CARD8 RegValueHigh, CARD8 RegValueLow)
d55 2
a56 1
   I2CByte data[5];
d58 32
a89 29
   if(!m->registers_present[RegSubAddressLow]){
   	xf86DrvMsg(m->d.pI2CBus->scrnIndex,X_ERROR, "Attempt to access non-existent register in MSP34xxX: 0x%02x 0x%02x 0x%02x <- 0x%02x 0x%02x\n",
		RegAddress, RegSubAddressHigh, RegSubAddressLow, RegValueHigh, RegValueLow);
   	}
#endif
   
   data[0] = RegAddress;
   data[1] = RegSubAddressHigh;
   data[2] = RegSubAddressLow;
   data[3] = RegValueHigh;
   data[4] = RegValueLow;
   
   I2C_WriteRead(&(m->d),data,5,NULL,0);
}

static void GetMSP3430Data(MSP3430Ptr m, CARD8 RegAddress, CARD8 RegSubAddressHigh, CARD8 RegSubAddressLow,
            CARD8 *RegValueHigh, CARD8 *RegValueLow)
{
   I2CByte  send[3];
   I2CByte  receive[2];
   
   send[0] = RegAddress;
   send[1] = RegSubAddressHigh;
   send[2] = RegSubAddressLow;
   
   I2C_WriteRead(&(m->d), send, 3, receive, 2);
   
   *RegValueHigh = receive[0];
   *RegValueLow = receive[1];
d93 2
a94 1
static void MSP3430DumpStatus(MSP3430Ptr m)
d96 2
a97 2
CARD8 status_hi, status_lo;
CARD8 subaddr, data[2];
d99 17
a115 14
GetMSP3430Data(m, RD_DEM, 0x02, 0x00, &status_hi, &status_lo);
xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO, "MSP34xx: SAP(8)=%d mono/NICAM(7)=%d stereo=%d %s O_1=%d O_0=%d 2nd car=%d 1st car=%d\n",
		status_hi & 1, (status_lo>>7) & 1, (status_lo>>6)&1, 
		(status_lo>>5)? ( (status_hi>>1)&1? "bad NICAM reception" : "NICAM" ) : 
		                ((status_hi>>1)&1 ? "bogus" : "ANALOG FM/AM") , 
		(status_lo>>4)&1, (status_lo>>3)&1,!( (status_lo>>2)&1), !((status_lo>>1)&1));

GetMSP3430Data(m, RD_DEM, 0x00, 0x7E, &status_hi, &status_lo);
xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO, "MSP34xx: standard result=0x%02x%02x\n",
		status_hi, status_lo);
subaddr=0x0;
I2C_WriteRead(&(m->d), &subaddr, 1, data, 2);
xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO, "MSP34xx: control=0x%02x%02x\n",
		data[1], data[0]);
d120 2
a121 1
void InitMSP3430(MSP3430Ptr m)
d123 16
a138 15
  #if __MSPDEBUG__ > 1
  xf86DrvMsg(m->d.pI2CBus->scrnIndex,X_INFO,"InitMSP3430(m->connector=%d, m->standard=%d, m->chip_family=%d)\n",
  		m->connector, m->standard, m->chip_family);
  #endif
	switch (m->chip_family) {
		case MSPFAMILY_34x0G:
			InitMSP34xxG(m);
			break;
		case MSPFAMILY_34x5G:
			InitMSP34xxG(m);
			break;
		case MSPFAMILY_34x5D:
			InitMSP34x5D(m);
			break;
	}
d145 2
a146 1
MSP3430Ptr DetectMSP3430(I2CBusPtr b, I2CSlaveAddr addr)
d148 22
a169 114
   MSP3430Ptr m;
   I2CByte a;
   CARD8 hardware_version, major_revision, product_code, rom_version;
   Bool supported;
   
   m = calloc(1,sizeof(MSP3430Rec));
   if(m == NULL)return NULL;
   m->d.DevName = strdup("MSP34xx");
   m->d.SlaveAddr = addr;
   m->d.pI2CBus = b;
   m->d.NextDev = NULL;
   m->d.StartTimeout = b->StartTimeout;
   m->d.BitTimeout = b->BitTimeout;
   m->d.AcknTimeout = b->AcknTimeout;
   m->d.ByteTimeout = b->ByteTimeout;
   
   if(!I2C_WriteRead(&(m->d), NULL, 0, &a, 1))
   {
       free(m->d.DevName);
       free(m);
	return NULL;
    }


	m->standard=MSP3430_NTSC;
	m->connector=MSP3430_CONNECTOR_1;
	m->mode=MSPMODE_STEREO_A;	/*stereo or chanel A if avail. */
    	m->c_format=MSPFORMAT_UNKNOWN;
    	m->c_standard=MSPSTANDARD_UNKNOWN;
    	m->c_matrix=m->c_fmmatrix=m->c_source=0;
	m->volume=0;
	m->recheck=FALSE;

   GetMSP3430Data(m, RD_DSP, 0x00, 0x1E, &hardware_version, &major_revision);
   GetMSP3430Data(m, RD_DSP, 0x00, 0x1F, &product_code, &rom_version);
   m->hardware_version=hardware_version;
   m->major_revision=major_revision;
   m->product_code=product_code;
   m->rom_version=rom_version;

   m->chip_id=((major_revision << 8) | product_code);
   
   supported=FALSE;
   switch (major_revision) {
   case 4:	/* 34xxD */
      switch (product_code) {
	  case 0x05: /* 3405D */
	  case 0x0A: /* 3410D */
	  case 0x0F: /* 3415D */
	  	m->chip_family=MSPFAMILY_34x5D;
		m->recheck=TRUE;
		supported=TRUE;
		break;
      default:
	  	m->chip_family=MSPFAMILY_34x0D;
      }
	  break;
   case 7:	/* 34xxG */
   	switch(product_code){
		case 0x00:
		case 0x0A:
		case 0x1E:
		case 0x28:
		case 0x32:
		  	m->chip_family=MSPFAMILY_34x0G;
			supported=TRUE;
			break;
		case 0x0f:
		case 0x19:
		case 0x2d:
		case 0x37:
		case 0x41:
		  	m->chip_family=MSPFAMILY_34x5G;
			supported=TRUE;
			#ifdef MSP_DEBUG
			memset(m->registers_present, 0, 256);
			#define A(num) m->registers_present[(num)]=1;
			#define B(num1, num2) memset(&(m->registers_present[num1]), 1, num2-num1);
			A(0x20)
			A(0x30)
			A(0x40)
			A(0x00)
			B(0x01, 0x08)
			B(0x0B, 0x0E)
			A(0x10)
			B(0x12,0x14)
			A(0x16)
			A(0x29)
			#undef B
			#undef A
			#endif
			break;
		default:
		  	m->chip_family=MSPFAMILY_UNKNOWN;
		}
		break;
   default:
	  	m->chip_family=MSPFAMILY_UNKNOWN;
   }
   
	xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO, "Found %s%s, rom version 0x%02x, chip_id=0x%04x\n",
		MSP_getProductName(m->chip_id), supported?"":" (unsupported)", rom_version, m->chip_id);

	if (!supported) {
            free(m->d.DevName);
            free(m);
            return NULL;
	}
   if(!I2CDevInit(&(m->d)))
   {
       free(m->d.DevName);
       free(m);
       return NULL;
   }
d171 93
a263 1
   return m;  
d266 2
a267 1
void ResetMSP3430(MSP3430Ptr m)
d274 5
a278 5
    m->c_format=MSPFORMAT_UNKNOWN;
    m->c_standard=MSPSTANDARD_UNKNOWN;
    m->c_matrix=m->c_fmmatrix=m->c_source=0;
	m->volume=0;
}   
d280 2
a281 1
void MSP3430SetVolume (MSP3430Ptr m, CARD8 value)
d284 1
d287 4
a290 2
    GetMSP3430Data(m, RD_DSP, 0x00, 0x00, &old_volume, &result);   
    xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO, "MSP3430 result 0x%02x\n", result);
d293 1
a293 1
    result=0;
d298 1
a298 1
    m->volume=value;
d301 4
a304 4
    MSP3430DumpStatus(m); 
    __MSPBEEP
    GetMSP3430Data(m, RD_DSP, 0x00, 0x00, &old_volume, &result);
    xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO, "MSP3430 volume 0x%02x\n",value);
d308 2
a309 2

void MSP3430SetSAP (MSP3430Ptr m, int mode)
d311 2
a312 1
	xf86DrvMsg(m->d.pI2CBus->scrnIndex, X_INFO, "Put actual code to change SAP here\n");
d314 1
a314 1
      SetMSP3430Data(m, WR_DSP, 0x00, 0x08, mode & 0xff, 0x20); 
a316 1

d318 2
a319 1
void MSP3430SetSource(MSP3430Ptr m, CARD8 value)
d327 2
a328 2

char *MSP_getProductName (CARD16 product_id)
d330 31
a360 17
	switch (product_id) {
		case 0x0400: return "MSP3400D";
		case 0x040a: return "MSP3410D";
		case 0x0405: return "MSP3405D";
		case 0x040f: return "MSP3415D";
		case 0x0700: return "MSP3400G";
		case 0x070a: return "MSP3410G";
		case 0x071e: return "MSP3430G";
		case 0x0728: return "MSP3440G";
		case 0x0732: return "MSP3450G";
		case 0x070f: return "MSP3415G";
		case 0x0719: return "MSP3425G";
		case 0x072d: return "MSP3445G";
		case 0x0737: return "MSP3455G";
		case 0x0741: return "MSP3465G";
	}
	return "MSP - unknown type";
d367 4
a370 2
void MSPBeep(MSP3430Ptr m, CARD8 freq) {
    SetMSP3430Data (m, WR_DSP, 0x00, freq, 0x7f, 0x40);
d372 1
a372 1
    SetMSP3430Data (m, WR_DSP, 0x00, 0x14, 0x00, 0x00);
d376 8
a383 4
void mpause(int milliseconds) {
    int i,m;
    m=milliseconds/20;
    for (i=0;i<m;i++) usleep(20000);
d390 2
a391 1
void InitMSP34xxG(MSP3430Ptr m)
d394 69
a462 68
  #if __MSPDEBUG__ > 1
  xf86DrvMsg(m->d.pI2CBus->scrnIndex,X_INFO,"InitMSP34xxG(m->connector=%d, m->standard=%d, m->chip_family=%d)\n",
  		m->connector, m->standard, m->chip_family);
  #endif
   /* Reset MSP3430 */
   SetMSP3430Control(m, 0x00, 0x80, 0x00);
   /* Set it back to normal operation */
   SetMSP3430Control(m, 0x00, 0x00, 0x00);
   
   /*set MODUS register */
   /* bits: 0 - automatic sound detection */
   /*       1 - enable STATUS change */
   /*       12 - detect 6.5 Mhz carrier as D/K1, D/K2 or D/K NICAM  (does not seem to work ) */
   /*       13 - detect 4.5 Mhz carrier as BTSC */ 
   if ( (m->standard & 0xff) == MSP3430_PAL )
   {
      SetMSP3430Data(m, WR_DEM, 0x00, 0x30, 0x30, 0x03|0x08);    /* make O_ pins tristate */
      /* PAL standard */
      SetMSP3430Data(m, WR_DEM, 0x00, 0x20, 0x00, 0x01); /* possibly wrong */
   } else {
      SetMSP3430Data(m, WR_DEM, 0x00, 0x30, 0x20, 0x03|0x08);
      /* standard selection is M-BTSC-Stereo */
      SetMSP3430Data(m, WR_DEM, 0x00, 0x20, 0x00, 0x20); 
   }
   
   switch(m->connector){
         case MSP3430_CONNECTOR_1:
	        SetMSP3430Data(m, WR_DSP, 0x00, 0x08, 0x03, 0x20);
	        break;
	 case MSP3430_CONNECTOR_2:
		/* this has not been checked yet.. could be bogus */
    		/* SCART Input Prescale: 0 dB gain */
		SetMSP3430Data(m, WR_DSP, 0x00, 0x0d, 0x19, 0x00);
    		SetMSP3430Data(m, WR_DSP, 0x00, 0x08, 0x02, 0x20);   	
		break;
	case MSP3430_CONNECTOR_3:
	default:
    		/* SCART Input Prescale: 0 dB gain */
		SetMSP3430Data(m, WR_DSP, 0x00, 0x0d, 0x19, 0x00);
		
    		SetMSP3430Data(m, WR_DSP, 0x00, 0x08, 0x02, 0x20);
    		break;
	}
	      
    switch(m->standard){
        case MSP3430_PAL:
     		SetMSP3430Data(m, WR_DSP, 0x00, 0x0e, 0x24, 0x03);
     		SetMSP3430Data(m, WR_DSP, 0x00, 0x10, 0x00, 0x5a);
                SetMSP3430Data(m, WR_DEM, 0x00, 0x20, 0x00, 0x03);
                /* Set volume to FAST_MUTE. */
     	        SetMSP3430Data(m, WR_DSP, 0x00, 0x00, 0xFF, 0x00);
	        break;
        case MSP3430_PAL_DK1:
     		SetMSP3430Data(m, WR_DSP, 0x00, 0x0e, 0x24, 0x03);
     		SetMSP3430Data(m, WR_DSP, 0x00, 0x10, 0x00, 0x5a);
		SetMSP3430Data(m, WR_DEM, 0x00, 0x20, 0x00, 0x04);
                /* Set volume to FAST_MUTE. */
     	        SetMSP3430Data(m, WR_DSP, 0x00, 0x00, 0xFF, 0x00);
		break;
	case MSP3430_SECAM: /* is this right ? */
        case MSP3430_NTSC:         
                /* Write to DSP, register 0x000E, (prescale FM/FM matrix) */
                SetMSP3430Data(m, WR_DSP, 0x00, 0x0e, 0x24, 0x03);

                /* Set volume to FAST_MUTE. */
                SetMSP3430Data(m, WR_DSP, 0x00, 0x00, 0xFF, 0x00);
		break;
	}
d470 2
a471 1
void InitMSP34x5D(MSP3430Ptr m)
d473 11
a483 11
int count;
CARD8 high,low;
CARD16 result,standard;
CARD16 peak;


if (m->c_format==MSPFORMAT_UNKNOWN) ResetMSP3430(m);
else {
    /*mute volume*/
    SetMSP3430Data (m, WR_DSP, 0x00, 0x00, 0x00, 0x00);
}
d485 12
d498 6
a503 20

    switch(m->connector){
	case MSP3430_CONNECTOR_2:
	case MSP3430_CONNECTOR_3:
	    if (m->c_format!=MSPFORMAT_SCART) {
    		/* SCART Input Prescale: 0 dB gain */
			SetMSP3430Data (m, WR_DSP, 0x00, 0x0d, 0x19, 0x00);
			/* this has not been checked yet.. could be bogus */
			m->c_format=MSPFORMAT_SCART;	/*stereo*/
		}
	    break;
	case MSP3430_CONNECTOR_1:
	default:
	
	    switch ( m->standard & 0x00ff ) {
		case MSP3430_PAL:
			switch( m->standard ) {
			case MSP3430_PAL_DK1:
			    standard=MSPSTANDARD_FM_DK1;
			    break;
d512 34
a545 32
			default:
			    standard=MSPSTANDARD_AUTO;
			}
		    break;
		case MSP3430_SECAM:
		    standard=MSPSTANDARD_AUTO;
		case MSP3430_NTSC:
			    /* Only MSP34x5 supported format - Korean NTSC-M*/
			 standard=MSPSTANDARD_FM_M;
		default:
		    standard=MSPSTANDARD_AUTO;
		}
		
	    /*no NICAM support in MSP3410D - force to autodetect*/
	    if ((m->chip_id==0x405) && (standard>=MSPSTANDARD_NICAM_BG))
    		standard=MSPSTANDARD_AUTO;
		    
	    if (m->c_standard != standard) {

   	        SetMSP3430Data (m, WR_DEM, 0x00, 0x20, standard>>8, standard & 0xFF);
	        if (standard==MSPSTANDARD_AUTO) {
			    count = 50; /* time shouldn't exceed 1s, just in case */
			    do {
     		        usleep(20000);
     		        GetMSP3430Data (m, RD_DEM, 0x00, 0x7e, &high, &low);
			        result = ( high << 8 ) | low;
     		        --count;
	    	    } while( result > 0x07ff && count > 0 );
		    
		    	if ((result > MSPSTANDARD_AUTO))
					standard=result;
		    	else standard=MSPSTANDARD_UNKNOWN;
d547 14
a560 12
				xf86DrvMsg(m->d.pI2CBus->scrnIndex,X_INFO,"Detected audio standard: %d\n",result);
#endif		    	
		    	/* result = MSPSTANDARD_NICAM_L can be one of:
		    	SECAM_L - MSPSTANDARD_NICAM_L
		    	D/K1 - MSPSTANDARD_FM_DK1
		    	D/K2 - MSPSTANDARD_FM_DK2
		    	D/K-NICAM - MSPSTANDARD_NICAM_DK*/
		    	if( standard == MSPSTANDARD_NICAM_L ) {
		        	if ((m->standard & 0x00ff)==MSP3430_PAL) {
			    		/* force PAL D/K  */
			    		standard=MSPSTANDARD_FM_DK1;
		            	SetMSP3430Data (m, WR_DEM, 0x00, 0x20, standard>>8, standard & 0xFF);
d562 2
a563 1
			        	xf86DrvMsg(m->d.pI2CBus->scrnIndex,X_INFO, "Detected 6.5MHz carrier - forced to D/K1 !!!\n" );
d565 35
a599 34
					}
		    	}
			}
			m->c_standard=standard;
	    } /*end - standard changed*/
	    else {
			if (standard<MSPSTANDARD_NICAM_BG) {
    		    /* get old value of ident. mode register*/
		    	GetMSP3430Data (m, RD_DSP, 0x00, 0x15, &high, &low);
    		    /* reset Ident-Filter */
    		    SetMSP3430Data (m, WR_DSP, 0x00, 0x14, 0x00, 0x3F);
		    	/* put back old value to ident. mode register*/
    		    SetMSP3430Data (m, WR_DSP, 0x00, 0x14, 0x00, low);
			}
	    }

	    if (standard<=MSPSTANDARD_AUTO) {
    	   	m->c_format=MSPFORMAT_1xFM;
	    }
	    else if (standard<MSPSTANDARD_NICAM_BG) {
			/* set FM prescale */
			SetMSP3430Data (m, WR_DSP, 0x00, 0x0e, 0x30, 0);
			/* set FM deemphasis*/
			SetMSP3430Data (m, WR_DSP, 0x00, 0x0f, ((standard==MSPSTANDARD_FM_M)?0:1), 0);
		    	
			/* check if FM2 carrier is present */
			/*turn off FM DC Notch*/
			SetMSP3430Data (m, WR_DSP, 0x00, 0x17, 0x00, 0x3f);
			/*matrix source for Quasi-Peak Detector - stereo: ch2->L ch1->R*/
			SetMSP3430Data (m, WR_DSP, 0x00, 0x0c, 0x00, 0x20);
			
			mpause(250);
   		    GetMSP3430Data (m, RD_DSP, 0x00, 0x1A, &high, &low);
			peak = (high << 8) | low;
d601 5
a605 44
			xf86DrvMsg(m->d.pI2CBus->scrnIndex,X_INFO,"Second carrier Quasi-Peak detection: %d\n",peak);
#endif	    	
			/*turn on FM DC Notch*/
			SetMSP3430Data (m, WR_DSP, 0x00, 0x17, 0x00, 0x00);
	    	
			if (peak<5) {
	    	    /* if second carrier not detected - only mono from first carrier*/
	    	    m->c_format=MSPFORMAT_1xFM;
			}
			else {
	    	    m->c_format=MSPFORMAT_2xFM;
    	   	    /*start of FM identification process - FM_WAIT
	    	    wait at least 0.5s - used 1s - gives beter resolution*/
    	   	    mpause(1000);
			}
	    }
	    else {
			if (standard==MSPSTANDARD_NICAM_L) {
	    	    m->c_format=MSPFORMAT_NICAM_AM;
		    	/* set AM prescale */
		    	SetMSP3430Data (m, WR_DSP, 0x00, 0x0e, 0x7C, 0);
			}
			else {
	    	    m->c_format=MSPFORMAT_NICAM_FM;
		    	/* set FM prescale */
			    SetMSP3430Data (m, WR_DSP, 0x00, 0x0e, 0x30, 0);
			}
			/* set FM deemphasis*/
			SetMSP3430Data (m, WR_DSP, 0x00, 0x0f, 0x00, 0);
			/* set NICAM prescale to 0dB */
			SetMSP3430Data (m, WR_DSP, 0x00, 0x10, 0x20, 0);
	    }
	    
	    break;
	} /*end - case conector*/

    CheckModeMSP34x5D(m);
    
    /* Set volume to FAST_MUTE. */
    /*SetMSP3430Data(m, WR_DSP, 0x00, 0x00, 0xFF, 0x00);*/
    /*set volume*/
	MSP3430SetVolume(m,m->volume);
    
    __MSPBEEP
d607 27
d635 2
a636 1
} /* EnableMSP34x5D ()... */
d638 1
d640 14
a653 7


void CheckModeMSP34x5D(MSP3430Ptr m) {
    const char stereo_on=25;
    const char stereo_off=20;
    const char dual_on=-stereo_on;
    const char dual_off=-stereo_off;
d657 48
a704 48
    fmmatrix=0;		/*no matrix*/
    source=0;		/*FM*/
    switch (m->c_format) {
	case MSPFORMAT_NICAM_FM:
	case MSPFORMAT_NICAM_AM:
	case MSPFORMAT_SCART:
	    source=( (m->c_format == MSPFORMAT_SCART)?2:1 );
	    switch (m->mode) {
		case MSPMODE_MONO:
		    matrix=0x30;	/*MONO*/
		    break;
		case MSPMODE_A:
		    matrix=0x00;	/*A*/
		    break;
		case MSPMODE_B:
		    matrix=0x10;	/*B*/
		    break;
		default:
		    matrix=0x20;	/*STEREO*/
		    break;
		}
	    break;
	default:
	case MSPFORMAT_1xFM:
	    matrix=0x00;	/*A*/
	    break;
	case MSPFORMAT_2xFM:
	    switch (m->mode) {
		case MSPMODE_MONO:
		    matrix=0x30;	/*MONO*/
		    break;
		case MSPMODE_STEREO:
		    matrix=0x20;	/*STEREO*/
		    fmmatrix=((m->c_standard==MSPSTANDARD_FM_M)?2:1);
		    break;
		case MSPMODE_AB:
		    matrix=0x20;	/*STEREO*/
		    break;
		case MSPMODE_A:
		    matrix=0x00;	/*A*/
		    break;
		case MSPMODE_B:
		    matrix=0x10;	/*B*/
		    break;
		default:
    		/*FM_IDENT_CHECK*/
    		GetMSP3430Data (m, RD_DSP, 0x00, 0x18, &high, &low);
    		detect=(char)high;
d706 2
a707 1
    		xf86DrvMsg(m->d.pI2CBus->scrnIndex,X_INFO,"Stereo Detection Register: %d\n",detect);
d709 29
a737 21
    		if (detect>=((m->c_mode==MSPMODE_STEREO)?stereo_off:stereo_on)) {
				m->c_mode=MSPMODE_STEREO;
				matrix=0x20;	/*STEREO*/
				fmmatrix=((m->c_standard==MSPSTANDARD_FM_M)?2:1);
		    }
			else if (detect<=((m->c_mode==MSPMODE_AB)?dual_off:dual_on)) {
				m->c_mode=MSPMODE_AB;
    			switch (m->mode) {
			    case MSPMODE_STEREO_AB: matrix=0x20; break;
			    case MSPMODE_STEREO_B: matrix=0x10; break;
			    default:
				case MSPMODE_A: matrix=0x00; break;
				}
			}
    		else {
				m->c_mode=MSPMODE_MONO;
				matrix=0x30;	/*MONO*/
			}
		    break;
	    } /* end - case mode*/
	    break;
d741 3
a743 3
        GetMSP3430Data (m, RD_DSP, 0x00, 0x0e, &high, &low);
		SetMSP3430Data (m, WR_DSP, 0x00, 0x0e, high, fmmatrix);
		m->c_fmmatrix = fmmatrix;
d747 5
a751 5
        /*set chanel source and matrix for loudspeaker*/
		SetMSP3430Data (m, WR_DSP, 0x00, 0x08, source, matrix);
    	
		m->c_matrix = matrix;
		m->c_source = source;
d754 2
a755 2
	if ( ((m->c_format) & 0xF0) == MSPFORMAT_NICAM)
			SetMSP3430Data (m, WR_DEM, 0x00, 0x21, 0, 1);
d758 20
a777 19
		    char *msg;
		    switch (matrix) {
			case 0x30: /*MONO*/
			    msg="MONO";
			    break;
			case 0x00: /*LEFT*/
			    msg="MONO/CHANNEL_1";
			    break;
			case 0x10: /*RIGHT*/
			    msg="MONO/CHANNEL_2";
			    break;
			case 0x20: /*LEFT*/
			    msg="STEREO";
			    break;
			default:
			    msg="unknown";
			    break;
		    }
    		    xf86DrvMsg(m->d.pI2CBus->scrnIndex,X_INFO,"Audio mode set to: %s\n",msg);
a779 1

@


1.1
log
@Initial revision
@
text
@d139 1
a139 1
   m = xcalloc(1,sizeof(MSP3430Rec));
d152 2
a153 2
   	xfree(m->d.DevName);
   	xfree(m);
d238 4
a241 4
       		xfree(m->d.DevName);
	   	xfree(m);
		return NULL;
	}	
d244 2
a245 2
       xfree(m->d.DevName);
       xfree(m);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
