head	1.14;
access;
symbols
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	s0SI41sEunLdyFfd;

1.13
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	Te1daavkBLskZ8gc;

1.12
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	cVXoV5PxI8YrEaVA;

1.11
date	2014.05.02.19.27.49;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.07.17.28.51;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.31.14.09.44;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.27;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.58.11;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/* all driver need this */
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <string.h>

#include "xf86.h"
#include "xf86Modes.h"
#include "xf86_OSproc.h"

/* pci stuff */
#include "xf86Pci.h"

#include "xf86cmap.h"

#include "fbdevhw.h"
#include "fbpriv.h"
#include "globals.h"
#include <X11/extensions/dpmsconst.h>

#define PAGE_MASK               (~(getpagesize() - 1))

static XF86ModuleVersionInfo fbdevHWVersRec = {
    "fbdevhw",
    MODULEVENDORSTRING,
    MODINFOSTRING1,
    MODINFOSTRING2,
    XORG_VERSION_CURRENT,
    0, 0, 2,
    ABI_CLASS_VIDEODRV,
    ABI_VIDEODRV_VERSION,
    MOD_CLASS_NONE,
    {0, 0, 0, 0}
};

_X_EXPORT XF86ModuleData fbdevhwModuleData = {
    &fbdevHWVersRec,
    NULL,
    NULL
};

#include <fcntl.h>
#include <errno.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

/* -------------------------------------------------------------------- */
/* our private data, and two functions to allocate/free this            */

#define FBDEVHWPTRLVAL(p) (p)->privates[fbdevHWPrivateIndex].ptr
#define FBDEVHWPTR(p) ((fbdevHWPtr)(FBDEVHWPTRLVAL(p)))

static int fbdevHWPrivateIndex = -1;

typedef struct {
    /* framebuffer device: filename (/dev/fb*), handle, more */
    char *device;
    int fd;
    void *fbmem;
    unsigned int fbmem_len;
    unsigned int fboff;
    char *mmio;
    unsigned int mmio_len;

    /* current hardware state */
    struct fb_fix_screeninfo fix;
    struct fb_var_screeninfo var;

    /* saved video mode */
    struct fb_var_screeninfo saved_var;

    /* buildin video mode */
    DisplayModeRec buildin;

    /* disable non-fatal unsupported ioctls */
    CARD32 unsupported_ioctls;
} fbdevHWRec, *fbdevHWPtr;

enum {
    FBIOBLANK_UNSUPPORTED = 0,
};

Bool
fbdevHWGetRec(ScrnInfoPtr pScrn)
{
    if (fbdevHWPrivateIndex < 0)
        fbdevHWPrivateIndex = xf86AllocateScrnInfoPrivateIndex();

    if (FBDEVHWPTR(pScrn) != NULL)
        return TRUE;

    FBDEVHWPTRLVAL(pScrn) = xnfcalloc(sizeof(fbdevHWRec), 1);
    return TRUE;
}

void
fbdevHWFreeRec(ScrnInfoPtr pScrn)
{
    if (fbdevHWPrivateIndex < 0)
        return;
    free(FBDEVHWPTR(pScrn));
    FBDEVHWPTRLVAL(pScrn) = NULL;
}

int
fbdevHWGetFD(ScrnInfoPtr pScrn)
{
    fbdevHWPtr fPtr;

    fbdevHWGetRec(pScrn);
    fPtr = FBDEVHWPTR(pScrn);

    return fPtr->fd;
}

/* -------------------------------------------------------------------- */
/* some helpers for printing debug informations                         */

#if DEBUG
static void
print_fbdev_mode(const char *txt, struct fb_var_screeninfo *var)
{
    ErrorF("fbdev %s mode:\t%d   %d %d %d %d   %d %d %d %d   %d %d:%d:%d\n",
           txt, var->pixclock,
           var->xres, var->right_margin, var->hsync_len, var->left_margin,
           var->yres, var->lower_margin, var->vsync_len, var->upper_margin,
           var->bits_per_pixel,
           var->red.length, var->green.length, var->blue.length);
}

static void
print_xfree_mode(const char *txt, DisplayModePtr mode)
{
    ErrorF("xfree %s mode:\t%d   %d %d %d %d   %d %d %d %d\n",
           txt, mode->Clock,
           mode->HDisplay, mode->HSyncStart, mode->HSyncEnd, mode->HTotal,
           mode->VDisplay, mode->VSyncStart, mode->VSyncEnd, mode->VTotal);
}
#endif

/* -------------------------------------------------------------------- */
/* Convert timings between the XFree and the Frame Buffer Device        */

static void
xfree2fbdev_fblayout(ScrnInfoPtr pScrn, struct fb_var_screeninfo *var)
{
    var->xres_virtual = pScrn->displayWidth ? pScrn->displayWidth :
        pScrn->virtualX;
    var->yres_virtual = pScrn->virtualY;
    var->bits_per_pixel = pScrn->bitsPerPixel;
    if (pScrn->defaultVisual == TrueColor ||
        pScrn->defaultVisual == DirectColor) {
        var->red.length = pScrn->weight.red;
        var->green.length = pScrn->weight.green;
        var->blue.length = pScrn->weight.blue;
    }
    else {
        var->red.length = 8;
        var->green.length = 8;
        var->blue.length = 8;
    }
}

static void
xfree2fbdev_timing(DisplayModePtr mode, struct fb_var_screeninfo *var)
{
    var->xres = mode->HDisplay;
    var->yres = mode->VDisplay;
    if (var->xres_virtual < var->xres)
        var->xres_virtual = var->xres;
    if (var->yres_virtual < var->yres)
        var->yres_virtual = var->yres;
    var->xoffset = var->yoffset = 0;
    var->pixclock = mode->Clock ? 1000000000 / mode->Clock : 0;
    var->right_margin = mode->HSyncStart - mode->HDisplay;
    var->hsync_len = mode->HSyncEnd - mode->HSyncStart;
    var->left_margin = mode->HTotal - mode->HSyncEnd;
    var->lower_margin = mode->VSyncStart - mode->VDisplay;
    var->vsync_len = mode->VSyncEnd - mode->VSyncStart;
    var->upper_margin = mode->VTotal - mode->VSyncEnd;
    var->sync = 0;
    if (mode->Flags & V_PHSYNC)
        var->sync |= FB_SYNC_HOR_HIGH_ACT;
    if (mode->Flags & V_PVSYNC)
        var->sync |= FB_SYNC_VERT_HIGH_ACT;
    if (mode->Flags & V_PCSYNC)
        var->sync |= FB_SYNC_COMP_HIGH_ACT;
    if (mode->Flags & V_BCAST)
        var->sync |= FB_SYNC_BROADCAST;
    if (mode->Flags & V_INTERLACE)
        var->vmode = FB_VMODE_INTERLACED;
    else if (mode->Flags & V_DBLSCAN)
        var->vmode = FB_VMODE_DOUBLE;
    else
        var->vmode = FB_VMODE_NONINTERLACED;
}

static Bool
fbdev_modes_equal(struct fb_var_screeninfo *set, struct fb_var_screeninfo *req)
{
    return (set->xres_virtual >= req->xres_virtual &&
            set->yres_virtual >= req->yres_virtual &&
            set->bits_per_pixel == req->bits_per_pixel &&
            set->red.length == req->red.length &&
            set->green.length == req->green.length &&
            set->blue.length == req->blue.length &&
            set->xres == req->xres && set->yres == req->yres &&
            set->right_margin == req->right_margin &&
            set->hsync_len == req->hsync_len &&
            set->left_margin == req->left_margin &&
            set->lower_margin == req->lower_margin &&
            set->vsync_len == req->vsync_len &&
            set->upper_margin == req->upper_margin &&
            set->sync == req->sync && set->vmode == req->vmode);
}

static void
fbdev2xfree_timing(struct fb_var_screeninfo *var, DisplayModePtr mode)
{
    mode->Clock = var->pixclock ? 1000000000 / var->pixclock : 0;
    mode->HDisplay = var->xres;
    mode->HSyncStart = mode->HDisplay + var->right_margin;
    mode->HSyncEnd = mode->HSyncStart + var->hsync_len;
    mode->HTotal = mode->HSyncEnd + var->left_margin;
    mode->VDisplay = var->yres;
    mode->VSyncStart = mode->VDisplay + var->lower_margin;
    mode->VSyncEnd = mode->VSyncStart + var->vsync_len;
    mode->VTotal = mode->VSyncEnd + var->upper_margin;
    mode->Flags = 0;
    mode->Flags |= var->sync & FB_SYNC_HOR_HIGH_ACT ? V_PHSYNC : V_NHSYNC;
    mode->Flags |= var->sync & FB_SYNC_VERT_HIGH_ACT ? V_PVSYNC : V_NVSYNC;
    mode->Flags |= var->sync & FB_SYNC_COMP_HIGH_ACT ? V_PCSYNC : V_NCSYNC;
    if (var->sync & FB_SYNC_BROADCAST)
        mode->Flags |= V_BCAST;
    if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED)
        mode->Flags |= V_INTERLACE;
    else if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE)
        mode->Flags |= V_DBLSCAN;
    mode->SynthClock = mode->Clock;
    mode->CrtcHDisplay = mode->HDisplay;
    mode->CrtcHSyncStart = mode->HSyncStart;
    mode->CrtcHSyncEnd = mode->HSyncEnd;
    mode->CrtcHTotal = mode->HTotal;
    mode->CrtcVDisplay = mode->VDisplay;
    mode->CrtcVSyncStart = mode->VSyncStart;
    mode->CrtcVSyncEnd = mode->VSyncEnd;
    mode->CrtcVTotal = mode->VTotal;
    mode->CrtcHAdjusted = FALSE;
    mode->CrtcVAdjusted = FALSE;
}

/* -------------------------------------------------------------------- */
/* open correct framebuffer device                                      */

/**
 * Try to find the framebuffer device for a given PCI device
 */
static int
fbdev_open_pci(struct pci_device *pPci, char **namep)
{
    struct fb_fix_screeninfo fix;
    char filename[256];
    int fd, i;

    for (i = 0; i < 8; i++) {
        snprintf(filename, sizeof(filename),
                 "/sys/bus/pci/devices/%04x:%02x:%02x.%d/graphics/fb%d",
                 pPci->domain, pPci->bus, pPci->dev, pPci->func, i);

        fd = open(filename, O_RDONLY, 0);
        if (fd < 0) {
            snprintf(filename, sizeof(filename),
                     "/sys/bus/pci/devices/%04x:%02x:%02x.%d/graphics:fb%d",
                     pPci->domain, pPci->bus, pPci->dev, pPci->func, i);
            fd = open(filename, O_RDONLY, 0);
        }
        if (fd >= 0) {
            close(fd);
            snprintf(filename, sizeof(filename), "/dev/fb%d", i);

            fd = open(filename, O_RDWR, 0);
            if (fd != -1) {
                if (ioctl(fd, FBIOGET_FSCREENINFO, (void *) &fix) != -1) {
                    if (namep) {
                        *namep = xnfalloc(16);
                        strncpy(*namep, fix.id, 16);
                    }

                    return fd;
                }
                close(fd);
            }
        }
    }

    if (namep)
        *namep = NULL;

    xf86DrvMsg(-1, X_ERROR, "Unable to find a valid framebuffer device\n");
    return -1;
}

static int
fbdev_open(int scrnIndex, const char *dev, char **namep)
{
    struct fb_fix_screeninfo fix;
    int fd;

    /* try argument (from XF86Config) first */
    if (dev) {
        fd = open(dev, O_RDWR, 0);
    }
    else {
        /* second: environment variable */
        dev = getenv("FRAMEBUFFER");
        if ((NULL == dev) || ((fd = open(dev, O_RDWR, 0)) == -1)) {
            /* last try: default device */
            dev = "/dev/fb0";
            fd = open(dev, O_RDWR, 0);
        }
    }

    if (fd == -1) {
        xf86DrvMsg(scrnIndex, X_ERROR, "open %s: %s\n", dev, strerror(errno));
        return -1;
    }

    if (namep) {
        if (-1 == ioctl(fd, FBIOGET_FSCREENINFO, (void *) (&fix))) {
            *namep = NULL;
            xf86DrvMsg(scrnIndex, X_ERROR,
                       "FBIOGET_FSCREENINFO: %s\n", strerror(errno));
            return -1;
        }
        else {
            *namep = xnfalloc(16);
            strncpy(*namep, fix.id, 16);
        }
    }
    return fd;
}

/* -------------------------------------------------------------------- */

Bool
fbdevHWProbe(struct pci_device *pPci, char *device, char **namep)
{
    int fd;

    if (pPci)
        fd = fbdev_open_pci(pPci, namep);
    else
        fd = fbdev_open(-1, device, namep);

    if (-1 == fd)
        return FALSE;
    close(fd);
    return TRUE;
}

Bool
fbdevHWInit(ScrnInfoPtr pScrn, struct pci_device *pPci, char *device)
{
    fbdevHWPtr fPtr;

    fbdevHWGetRec(pScrn);
    fPtr = FBDEVHWPTR(pScrn);

    /* open device */
    if (pPci)
        fPtr->fd = fbdev_open_pci(pPci, NULL);
    else
        fPtr->fd = fbdev_open(pScrn->scrnIndex, device, NULL);
    if (-1 == fPtr->fd) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                   "Failed to open framebuffer device, consult warnings"
                   " and/or errors above for possible reasons\n"
                   "\t(you may have to look at the server log to see"
                   " warnings)\n");
        return FALSE;
    }

    /* get current fb device settings */
    if (-1 == ioctl(fPtr->fd, FBIOGET_FSCREENINFO, (void *) (&fPtr->fix))) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                   "ioctl FBIOGET_FSCREENINFO: %s\n", strerror(errno));
        return FALSE;
    }
    if (-1 == ioctl(fPtr->fd, FBIOGET_VSCREENINFO, (void *) (&fPtr->var))) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                   "ioctl FBIOGET_VSCREENINFO: %s\n", strerror(errno));
        return FALSE;
    }

    /* we can use the current settings as "buildin mode" */
    fbdev2xfree_timing(&fPtr->var, &fPtr->buildin);
    fPtr->buildin.name = "current";
    fPtr->buildin.next = &fPtr->buildin;
    fPtr->buildin.prev = &fPtr->buildin;
    fPtr->buildin.type |= M_T_BUILTIN;

    return TRUE;
}

char *
fbdevHWGetName(ScrnInfoPtr pScrn)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    return fPtr->fix.id;
}

int
fbdevHWGetDepth(ScrnInfoPtr pScrn, int *fbbpp)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    if (fbbpp)
        *fbbpp = fPtr->var.bits_per_pixel;

    if (fPtr->fix.visual == FB_VISUAL_TRUECOLOR ||
        fPtr->fix.visual == FB_VISUAL_DIRECTCOLOR)
        return fPtr->var.red.length + fPtr->var.green.length +
            fPtr->var.blue.length;
    else
        return fPtr->var.bits_per_pixel;
}

int
fbdevHWGetLineLength(ScrnInfoPtr pScrn)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    if (fPtr->fix.line_length)
        return fPtr->fix.line_length;
    else
        return fPtr->var.xres_virtual * fPtr->var.bits_per_pixel / 8;
}

int
fbdevHWGetType(ScrnInfoPtr pScrn)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    return fPtr->fix.type;
}

int
fbdevHWGetVidmem(ScrnInfoPtr pScrn)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    return fPtr->fix.smem_len;
}

static Bool
fbdevHWSetMode(ScrnInfoPtr pScrn, DisplayModePtr mode, Bool check)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
    struct fb_var_screeninfo req_var = fPtr->var, set_var;

    xfree2fbdev_fblayout(pScrn, &req_var);
    xfree2fbdev_timing(mode, &req_var);

#if DEBUG
    print_xfree_mode("init", mode);
    print_fbdev_mode("init", &req_var);
#endif

    set_var = req_var;

    if (check)
        set_var.activate = FB_ACTIVATE_TEST;

    if (0 != ioctl(fPtr->fd, FBIOPUT_VSCREENINFO, (void *) (&set_var))) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                   "FBIOPUT_VSCREENINFO: %s\n", strerror(errno));
        return FALSE;
    }

    if (!fbdev_modes_equal(&set_var, &req_var)) {
        if (!check)
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                       "FBIOPUT_VSCREENINFO succeeded but modified " "mode\n");
#if DEBUG
        print_fbdev_mode("returned", &set_var);
#endif
        return FALSE;
    }

    if (!check)
        fPtr->var = set_var;

    return TRUE;
}

void
fbdevHWSetVideoModes(ScrnInfoPtr pScrn)
{
    const char **modename;
    DisplayModePtr mode, this, last = pScrn->modes;

    if (NULL == pScrn->display->modes)
        return;

    pScrn->virtualX = pScrn->display->virtualX;
    pScrn->virtualY = pScrn->display->virtualY;

    for (modename = pScrn->display->modes; *modename != NULL; modename++) {
        for (mode = pScrn->monitor->Modes; mode != NULL; mode = mode->next) {
            if (0 == strcmp(mode->name, *modename)) {
                if (fbdevHWSetMode(pScrn, mode, TRUE))
                    break;

                xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                           "\tmode \"%s\" test failed\n", *modename);
            }
        }

        if (NULL == mode) {
            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                       "\tmode \"%s\" not found\n", *modename);
            continue;
        }

        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "\tmode \"%s\" ok\n", *modename);

        if (pScrn->virtualX < mode->HDisplay)
            pScrn->virtualX = mode->HDisplay;
        if (pScrn->virtualY < mode->VDisplay)
            pScrn->virtualY = mode->VDisplay;

        if (NULL == pScrn->modes) {
            this = pScrn->modes = xf86DuplicateMode(mode);
            this->next = this;
            this->prev = this;
        }
        else {
            this = xf86DuplicateMode(mode);
            this->next = pScrn->modes;
            this->prev = last;
            last->next = this;
            pScrn->modes->prev = this;
        }
        last = this;
    }
}

DisplayModePtr
fbdevHWGetBuildinMode(ScrnInfoPtr pScrn)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    return &fPtr->buildin;
}

void
fbdevHWUseBuildinMode(ScrnInfoPtr pScrn)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    pScrn->modes = &fPtr->buildin;
    pScrn->virtualX = pScrn->display->virtualX;
    pScrn->virtualY = pScrn->display->virtualY;
    if (pScrn->virtualX < fPtr->buildin.HDisplay)
        pScrn->virtualX = fPtr->buildin.HDisplay;
    if (pScrn->virtualY < fPtr->buildin.VDisplay)
        pScrn->virtualY = fPtr->buildin.VDisplay;
}

/* -------------------------------------------------------------------- */

static void
calculateFbmem_len(fbdevHWPtr fPtr)
{
    fPtr->fboff = (unsigned long) fPtr->fix.smem_start & ~PAGE_MASK;
    fPtr->fbmem_len = (fPtr->fboff + fPtr->fix.smem_len + ~PAGE_MASK) &
        PAGE_MASK;
}

void *
fbdevHWMapVidmem(ScrnInfoPtr pScrn)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    if (NULL == fPtr->fbmem) {
        calculateFbmem_len(fPtr);
        fPtr->fbmem = mmap(NULL, fPtr->fbmem_len, PROT_READ | PROT_WRITE,
                           MAP_SHARED, fPtr->fd, 0);
        if (-1 == (long) fPtr->fbmem) {
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                       "mmap fbmem: %s\n", strerror(errno));
            fPtr->fbmem = NULL;
        }
        else {
            /* Perhaps we'd better add fboff to fbmem and return 0 in
               fbdevHWLinearOffset()? Of course we then need to mask
               fPtr->fbmem with PAGE_MASK in fbdevHWUnmapVidmem() as
               well. [geert] */
        }
    }
    pScrn->memPhysBase =
        (unsigned long) fPtr->fix.smem_start & (unsigned long) (PAGE_MASK);
    pScrn->fbOffset =
        (unsigned long) fPtr->fix.smem_start & (unsigned long) (~PAGE_MASK);
    return fPtr->fbmem;
}

int
fbdevHWLinearOffset(ScrnInfoPtr pScrn)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    return fPtr->fboff;
}

Bool
fbdevHWUnmapVidmem(ScrnInfoPtr pScrn)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    if (NULL != fPtr->fbmem) {
        if (-1 == munmap(fPtr->fbmem, fPtr->fbmem_len))
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                       "munmap fbmem: %s\n", strerror(errno));
        fPtr->fbmem = NULL;
    }
    return TRUE;
}

void *
fbdevHWMapMMIO(ScrnInfoPtr pScrn)
{
    unsigned int mmio_off;

    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    if (NULL == fPtr->mmio) {
        /* tell the kernel not to use accels to speed up console scrolling */
        fPtr->var.accel_flags = 0;
        if (0 != ioctl(fPtr->fd, FBIOPUT_VSCREENINFO, (void *) (&fPtr->var))) {
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                       "FBIOPUT_VSCREENINFO: %s\n", strerror(errno));
            return FALSE;
        }
        mmio_off = (unsigned long) fPtr->fix.mmio_start & ~PAGE_MASK;
        fPtr->mmio_len = (mmio_off + fPtr->fix.mmio_len + ~PAGE_MASK) &
            PAGE_MASK;
        if (NULL == fPtr->fbmem)
            calculateFbmem_len(fPtr);
        fPtr->mmio = mmap(NULL, fPtr->mmio_len, PROT_READ | PROT_WRITE,
                          MAP_SHARED, fPtr->fd, fPtr->fbmem_len);
        if (-1 == (long) fPtr->mmio) {
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                       "mmap mmio: %s\n", strerror(errno));
            fPtr->mmio = NULL;
        }
        else
            fPtr->mmio += mmio_off;
    }
    return fPtr->mmio;
}

Bool
fbdevHWUnmapMMIO(ScrnInfoPtr pScrn)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    if (NULL != fPtr->mmio) {
        if (-1 ==
            munmap((void *) ((unsigned long) fPtr->mmio & PAGE_MASK),
                   fPtr->mmio_len))
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "munmap mmio: %s\n",
                       strerror(errno));
        fPtr->mmio = NULL;
        /* FIXME: restore var.accel_flags [geert] */
    }
    return TRUE;
}

/* -------------------------------------------------------------------- */

Bool
fbdevHWModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    pScrn->vtSema = TRUE;

    /* set */
    if (!fbdevHWSetMode(pScrn, mode, FALSE))
        return FALSE;

    /* read back */
    if (0 != ioctl(fPtr->fd, FBIOGET_FSCREENINFO, (void *) (&fPtr->fix))) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                   "FBIOGET_FSCREENINFO: %s\n", strerror(errno));
        return FALSE;
    }
    if (0 != ioctl(fPtr->fd, FBIOGET_VSCREENINFO, (void *) (&fPtr->var))) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                   "FBIOGET_VSCREENINFO: %s\n", strerror(errno));
        return FALSE;
    }

    if (pScrn->defaultVisual == TrueColor ||
        pScrn->defaultVisual == DirectColor) {
        /* XXX: This is a hack, but it should be a NOP for all the setups that
         * worked before and actually seems to fix some others...
         */
        pScrn->offset.red = fPtr->var.red.offset;
        pScrn->offset.green = fPtr->var.green.offset;
        pScrn->offset.blue = fPtr->var.blue.offset;
        pScrn->mask.red =
            ((1 << fPtr->var.red.length) - 1) << fPtr->var.red.offset;
        pScrn->mask.green =
            ((1 << fPtr->var.green.length) - 1) << fPtr->var.green.offset;
        pScrn->mask.blue =
            ((1 << fPtr->var.blue.length) - 1) << fPtr->var.blue.offset;
    }

    return TRUE;
}

/* -------------------------------------------------------------------- */
/* video mode save/restore                                              */
void
fbdevHWSave(ScrnInfoPtr pScrn)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    if (0 != ioctl(fPtr->fd, FBIOGET_VSCREENINFO, (void *) (&fPtr->saved_var)))
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                   "FBIOGET_VSCREENINFO: %s\n", strerror(errno));
}

void
fbdevHWRestore(ScrnInfoPtr pScrn)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    if (0 != ioctl(fPtr->fd, FBIOPUT_VSCREENINFO, (void *) (&fPtr->saved_var)))
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                   "FBIOPUT_VSCREENINFO: %s\n", strerror(errno));
}

/* -------------------------------------------------------------------- */
/* callback for xf86HandleColormaps                                     */

void
fbdevHWLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
                   LOCO * colors, VisualPtr pVisual)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
    struct fb_cmap cmap;
    unsigned short red, green, blue;
    int i;

    cmap.len = 1;
    cmap.red = &red;
    cmap.green = &green;
    cmap.blue = &blue;
    cmap.transp = NULL;
    for (i = 0; i < numColors; i++) {
        cmap.start = indices[i];
        red = (colors[indices[i]].red << 8) | colors[indices[i]].red;
        green = (colors[indices[i]].green << 8) | colors[indices[i]].green;
        blue = (colors[indices[i]].blue << 8) | colors[indices[i]].blue;
        if (-1 == ioctl(fPtr->fd, FBIOPUTCMAP, (void *) &cmap))
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                       "FBIOPUTCMAP: %s\n", strerror(errno));
    }
}

/* -------------------------------------------------------------------- */
/* these can be hooked directly into ScrnInfoRec                        */

ModeStatus
fbdevHWValidMode(ScrnInfoPtr pScrn, DisplayModePtr mode, Bool verbose, int flags)
{
    if (!fbdevHWSetMode(pScrn, mode, TRUE))
        return MODE_BAD;

    return MODE_OK;
}

Bool
fbdevHWSwitchMode(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    if (!fbdevHWSetMode(pScrn, mode, FALSE))
        return FALSE;

    return TRUE;
}

void
fbdevHWAdjustFrame(ScrnInfoPtr pScrn, int x, int y)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);

    if (x < 0 || x + fPtr->var.xres > fPtr->var.xres_virtual ||
        y < 0 || y + fPtr->var.yres > fPtr->var.yres_virtual)
        return;

    fPtr->var.xoffset = x;
    fPtr->var.yoffset = y;
    if (-1 == ioctl(fPtr->fd, FBIOPAN_DISPLAY, (void *) &fPtr->var))
        xf86DrvMsgVerb(pScrn->scrnIndex, X_WARNING, 5,
                       "FBIOPAN_DISPLAY: %s\n", strerror(errno));
}

Bool
fbdevHWEnterVT(ScrnInfoPtr pScrn)
{
    if (!fbdevHWModeInit(pScrn, pScrn->currentMode))
        return FALSE;
    fbdevHWAdjustFrame(pScrn, pScrn->frameX0, pScrn->frameY0);
    return TRUE;
}

void
fbdevHWLeaveVT(ScrnInfoPtr pScrn)
{
    fbdevHWRestore(pScrn);
}

void
fbdevHWDPMSSet(ScrnInfoPtr pScrn, int mode, int flags)
{
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
    unsigned long fbmode;

    if (!pScrn->vtSema)
        return;

    if (fPtr->unsupported_ioctls & (1 << FBIOBLANK_UNSUPPORTED))
        return;

    switch (mode) {
    case DPMSModeOn:
        fbmode = 0;
        break;
    case DPMSModeStandby:
        fbmode = 2;
        break;
    case DPMSModeSuspend:
        fbmode = 3;
        break;
    case DPMSModeOff:
        fbmode = 4;
        break;
    default:
        return;
    }

RETRY:
    if (-1 == ioctl(fPtr->fd, FBIOBLANK, (void *) fbmode)) {
        switch (errno) {
        case EAGAIN:
            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                       "FBIOBLANK: %s\n", strerror(errno));
	    break;
        case EINTR:
        case ERESTART:
            goto RETRY;
        default:
            fPtr->unsupported_ioctls |= (1 << FBIOBLANK_UNSUPPORTED);
            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                       "FBIOBLANK: %s (Screen blanking not supported "
                       "by kernel - disabling)\n", strerror(errno));
        }
    }
}

Bool
fbdevHWSaveScreen(ScreenPtr pScreen, int mode)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
    unsigned long unblank;

    if (!pScrn->vtSema)
        return TRUE;

    if (fPtr->unsupported_ioctls & (1 << FBIOBLANK_UNSUPPORTED))
        return FALSE;

    unblank = xf86IsUnblank(mode);

RETRY:
    if (-1 == ioctl(fPtr->fd, FBIOBLANK, (void *) (1 - unblank))) {
        switch (errno) {
        case EAGAIN:
            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                       "FBIOBLANK: %s\n", strerror(errno));
            break;
        case EINTR:
        case ERESTART:
            goto RETRY;
        default:
            fPtr->unsupported_ioctls |= (1 << FBIOBLANK_UNSUPPORTED);
            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                       "FBIOBLANK: %s (Screen blanking not supported "
                       "by kernel - disabling)\n", strerror(errno));
        }
        return FALSE;
    }

    return TRUE;
}

xf86SwitchModeProc *
fbdevHWSwitchModeWeak(void)
{
    return fbdevHWSwitchMode;
}

xf86AdjustFrameProc *
fbdevHWAdjustFrameWeak(void)
{
    return fbdevHWAdjustFrame;
}

xf86EnterVTProc *
fbdevHWEnterVTWeak(void)
{
    return fbdevHWEnterVT;
}

xf86LeaveVTProc *
fbdevHWLeaveVTWeak(void)
{
    return fbdevHWLeaveVT;
}

xf86ValidModeProc *
fbdevHWValidModeWeak(void)
{
    return fbdevHWValidMode;
}

xf86DPMSSetProc *
fbdevHWDPMSSetWeak(void)
{
    return fbdevHWDPMSSet;
}

xf86LoadPaletteProc *
fbdevHWLoadPaletteWeak(void)
{
    return fbdevHWLoadPalette;
}

SaveScreenProcPtr
fbdevHWSaveScreenWeak(void)
{
    return fbdevHWSaveScreen;
}
@


1.13
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d79 2
d83 4
d125 1
a125 1
print_fbdev_mode(char *txt, struct fb_var_screeninfo *var)
d136 1
a136 1
print_xfree_mode(char *txt, DisplayModePtr mode)
d840 3
d860 17
a876 3
    if (-1 == ioctl(fPtr->fd, FBIOBLANK, (void *) fbmode))
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                   "FBIOBLANK: %s\n", strerror(errno));
d889 3
d894 1
d896 14
a909 2
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                   "FBIOBLANK: %s\n", strerror(errno));
@


1.12
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d254 1
a254 1
 * Try to find the framebuffer device for a given PCI device 
@


1.11
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a83 2
    fbdevHWPtr fPtr;

d90 1
a90 1
    fPtr = FBDEVHWPTRLVAL(pScrn) = xnfcalloc(sizeof(fbdevHWRec), 1);
d302 1
a302 1
fbdev_open(int scrnIndex, char *dev, char **namep)
d498 1
a498 1
    char **modename;
@


1.10
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d9 1
@


1.9
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d778 1
a778 1
fbdevHWValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
a779 2
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];

d787 1
a787 1
fbdevHWSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
a788 2
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];

d796 1
a796 1
fbdevHWAdjustFrame(int scrnIndex, int x, int y, int flags)
a797 1
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d807 1
a807 1
        xf86DrvMsgVerb(scrnIndex, X_WARNING, 5,
d812 1
a812 1
fbdevHWEnterVT(int scrnIndex, int flags)
a813 2
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];

d816 1
a816 1
    fbdevHWAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
d821 1
a821 1
fbdevHWLeaveVT(int scrnIndex, int flags)
a822 2
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];

d860 1
a860 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
@


1.8
log
@Bugfix Update to xserver 1.11.3
@
text
@a11 1
#include "xf86PciInfo.h"
d23 11
a33 12
static XF86ModuleVersionInfo fbdevHWVersRec =
{
	"fbdevhw",
	MODULEVENDORSTRING,
	MODINFOSTRING1,
	MODINFOSTRING2,
	XORG_VERSION_CURRENT,
	0, 0, 2,
	ABI_CLASS_VIDEODRV,
	ABI_VIDEODRV_VERSION,
	MOD_CLASS_NONE,
	{0,0,0,0}
d59 12
a70 12
	/* framebuffer device: filename (/dev/fb*), handle, more */
	char*				device;
	int				fd;
	void*				fbmem;
	unsigned int			fbmem_len;
	unsigned int			fboff;
	char*				mmio;
	unsigned int			mmio_len;

	/* current hardware state */
	struct fb_fix_screeninfo	fix;
	struct fb_var_screeninfo	var;
d72 2
a73 2
	/* saved video mode */
	struct fb_var_screeninfo	saved_var;
d75 2
a76 2
	/* buildin video mode */
	DisplayModeRec			buildin;
d83 10
a92 10
	fbdevHWPtr fPtr;
	
	if (fbdevHWPrivateIndex < 0)
		fbdevHWPrivateIndex = xf86AllocateScrnInfoPrivateIndex();

	if (FBDEVHWPTR(pScrn) != NULL)
		return TRUE;
	
	fPtr = FBDEVHWPTRLVAL(pScrn) = xnfcalloc(sizeof(fbdevHWRec), 1);
	return TRUE;
d98 4
a101 6
	if (fbdevHWPrivateIndex < 0)
		return;
	if (FBDEVHWPTR(pScrn) == NULL)
		return;
	free(FBDEVHWPTR(pScrn));
	FBDEVHWPTRLVAL(pScrn) = NULL;
d122 6
a127 6
	ErrorF( "fbdev %s mode:\t%d   %d %d %d %d   %d %d %d %d   %d %d:%d:%d\n",
		txt,var->pixclock,
		var->xres, var->right_margin, var->hsync_len, var->left_margin,
		var->yres, var->lower_margin, var->vsync_len, var->upper_margin,
		var->bits_per_pixel,
		var->red.length, var->green.length, var->blue.length);
d133 4
a136 4
	ErrorF( "xfree %s mode:\t%d   %d %d %d %d   %d %d %d %d\n",
		txt,mode->Clock,
		mode->HDisplay, mode->HSyncStart, mode->HSyncEnd, mode->HTotal,
		mode->VDisplay, mode->VSyncStart, mode->VSyncEnd, mode->VTotal);
d146 15
a160 14
	var->xres_virtual   = pScrn->displayWidth ? pScrn->displayWidth :
			      pScrn->virtualX;
	var->yres_virtual   = pScrn->virtualY;
	var->bits_per_pixel = pScrn->bitsPerPixel;
	if (pScrn->defaultVisual == TrueColor ||
	    pScrn->defaultVisual == DirectColor) {
	    var->red.length     = pScrn->weight.red;
	    var->green.length   = pScrn->weight.green;
	    var->blue.length    = pScrn->weight.blue;
	} else {
	    var->red.length     = 8;
	    var->green.length   = 8;
	    var->blue.length    = 8;
	}
d166 29
a194 29
	var->xres = mode->HDisplay;
	var->yres = mode->VDisplay;
	if (var->xres_virtual < var->xres)
		var->xres_virtual = var->xres;
	if (var->yres_virtual < var->yres)
		var->yres_virtual = var->yres;
	var->xoffset = var->yoffset = 0;
	var->pixclock = mode->Clock ? 1000000000/mode->Clock : 0;
	var->right_margin = mode->HSyncStart-mode->HDisplay;
	var->hsync_len = mode->HSyncEnd-mode->HSyncStart;
	var->left_margin = mode->HTotal-mode->HSyncEnd;
	var->lower_margin = mode->VSyncStart-mode->VDisplay;
	var->vsync_len = mode->VSyncEnd-mode->VSyncStart;
	var->upper_margin = mode->VTotal-mode->VSyncEnd;
	var->sync = 0;
	if (mode->Flags & V_PHSYNC)
		var->sync |= FB_SYNC_HOR_HIGH_ACT;
	if (mode->Flags & V_PVSYNC)
		var->sync |= FB_SYNC_VERT_HIGH_ACT;
	if (mode->Flags & V_PCSYNC)
		var->sync |= FB_SYNC_COMP_HIGH_ACT;
	if (mode->Flags & V_BCAST)
		var->sync |= FB_SYNC_BROADCAST;
	if (mode->Flags & V_INTERLACE)
		var->vmode = FB_VMODE_INTERLACED;
	else if (mode->Flags & V_DBLSCAN)
		var->vmode = FB_VMODE_DOUBLE;
	else
		var->vmode = FB_VMODE_NONINTERLACED;
d200 14
a213 14
	return (set->xres_virtual >= req->xres_virtual &&
		set->yres_virtual >= req->yres_virtual &&
		set->bits_per_pixel == req->bits_per_pixel &&
		set->red.length == req->red.length &&
		set->green.length == req->green.length &&
		set->blue.length == req->blue.length &&
		set->xres == req->xres && set->yres == req->yres &&
		set->right_margin == req->right_margin &&
		set->hsync_len == req->hsync_len &&
		set->left_margin == req->left_margin &&
		set->lower_margin == req->lower_margin &&
		set->vsync_len == req->vsync_len &&
		set->upper_margin == req->upper_margin &&
		set->sync == req->sync && set->vmode == req->vmode);
d219 30
a248 30
	mode->Clock = var->pixclock ? 1000000000/var->pixclock : 0;
	mode->HDisplay = var->xres;
	mode->HSyncStart = mode->HDisplay+var->right_margin;
	mode->HSyncEnd = mode->HSyncStart+var->hsync_len;
	mode->HTotal = mode->HSyncEnd+var->left_margin;
	mode->VDisplay = var->yres;
	mode->VSyncStart = mode->VDisplay+var->lower_margin;
	mode->VSyncEnd = mode->VSyncStart+var->vsync_len;
	mode->VTotal = mode->VSyncEnd+var->upper_margin;
	mode->Flags = 0;
	mode->Flags |= var->sync & FB_SYNC_HOR_HIGH_ACT ? V_PHSYNC : V_NHSYNC;
	mode->Flags |= var->sync & FB_SYNC_VERT_HIGH_ACT ? V_PVSYNC : V_NVSYNC;
	mode->Flags |= var->sync & FB_SYNC_COMP_HIGH_ACT ? V_PCSYNC : V_NCSYNC;
	if (var->sync & FB_SYNC_BROADCAST)
		mode->Flags |= V_BCAST;
	if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED)
		mode->Flags |= V_INTERLACE;
	else if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE)
		mode->Flags |= V_DBLSCAN;
	mode->SynthClock = mode->Clock;
	mode->CrtcHDisplay = mode->HDisplay;
	mode->CrtcHSyncStart = mode->HSyncStart;
	mode->CrtcHSyncEnd = mode->HSyncEnd;
	mode->CrtcHTotal = mode->HTotal;
	mode->CrtcVDisplay = mode->VDisplay;
	mode->CrtcVSyncStart = mode->VSyncStart;
	mode->CrtcVSyncEnd = mode->VSyncEnd;
	mode->CrtcVTotal = mode->VTotal;
	mode->CrtcHAdjusted = FALSE;
	mode->CrtcVAdjusted = FALSE;
a250 1

d258 1
a258 1
fbdev_open_pci(struct pci_device * pPci, char **namep)
d260 3
a262 3
    struct	fb_fix_screeninfo fix;
    char	filename[256];
    int	fd, i;
d265 3
a267 3
	sprintf(filename, 
		"/sys/bus/pci/devices/%04x:%02x:%02x.%d/graphics/fb%d",
		pPci->domain, pPci->bus, pPci->dev, pPci->func, i);
d269 1
a269 1
	fd = open(filename, O_RDONLY, 0);
d271 3
a273 3
            sprintf(filename,
                    "/sys/bus/pci/devices/%04x:%02x:%02x.%d/graphics:fb%d",
                    pPci->domain, pPci->bus, pPci->dev, pPci->func, i);
d276 17
a292 17
	if (fd >= 0) {
	    close(fd);
	    sprintf(filename, "/dev/fb%d", i);

	    fd = open(filename, O_RDWR, 0);
	    if (fd != -1) {
		if (ioctl(fd, FBIOGET_FSCREENINFO, (void*) & fix) != -1) {
		    if (namep) {
			*namep = xnfalloc(16);
			strncpy(*namep,fix.id,16);
		    }

		    return fd;
		}
		close(fd);
	    }
	}
d296 1
a296 1
      *namep = NULL;
d303 1
a303 1
fbdev_open(int scrnIndex, char *dev, char** namep)
d305 21
a325 2
	struct	fb_fix_screeninfo fix;
	int    fd;
d327 13
a339 31
	/* try argument (from XF86Config) first */
	if (dev) {
	    fd = open(dev,O_RDWR,0);
	} else {
	    /* second: environment variable */
	    dev = getenv("FRAMEBUFFER");
	    if ((NULL == dev) || ((fd = open(dev,O_RDWR,0)) == -1)) {
		/* last try: default device */
		dev = "/dev/fb0";
		fd = open(dev,O_RDWR,0);
	    }
	}

	if (fd == -1) {
	    xf86DrvMsg(scrnIndex, X_ERROR,
		       "open %s: %s\n", dev, strerror(errno));
	    return -1;
	}

	if (namep) {
	    if (-1 == ioctl(fd,FBIOGET_FSCREENINFO,(void*)(&fix))) {
		*namep = NULL;
		xf86DrvMsg(scrnIndex, X_ERROR,
			   "FBIOGET_FSCREENINFO: %s\n", strerror(errno));
		return -1;
	    } else {
		*namep = xnfalloc(16);
		strncpy(*namep,fix.id,16);
	    }
	}
	return fd;
d345 1
a345 1
fbdevHWProbe(struct pci_device * pPci, char *device,char **namep)
d347 1
a347 1
	int fd;
d349 9
a357 9
	if (pPci)
		fd = fbdev_open_pci(pPci,namep);
	else
		fd = fbdev_open(-1,device,namep);

	if (-1 == fd)
		return FALSE;
	close(fd);
	return TRUE;
d361 1
a361 1
fbdevHWInit(ScrnInfoPtr pScrn, struct pci_device * pPci, char *device)
d363 30
a392 1
	fbdevHWPtr fPtr;
d394 6
a399 2
	fbdevHWGetRec(pScrn);
	fPtr = FBDEVHWPTR(pScrn);
d401 1
a401 36
	/* open device */
	if (pPci)
		fPtr->fd = fbdev_open_pci(pPci,NULL);
	else
		fPtr->fd = fbdev_open(pScrn->scrnIndex,device,NULL);
	if (-1 == fPtr->fd) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Failed to open framebuffer device, consult warnings"
			   " and/or errors above for possible reasons\n"
			   "\t(you may have to look at the server log to see"
			   " warnings)\n");
		return FALSE;
	}

	/* get current fb device settings */
	if (-1 == ioctl(fPtr->fd,FBIOGET_FSCREENINFO,(void*)(&fPtr->fix))) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "ioctl FBIOGET_FSCREENINFO: %s\n",
			   strerror(errno));
		return FALSE;
	}
	if (-1 == ioctl(fPtr->fd,FBIOGET_VSCREENINFO,(void*)(&fPtr->var))) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "ioctl FBIOGET_VSCREENINFO: %s\n",
			   strerror(errno));
		return FALSE;
	}

	/* we can use the current settings as "buildin mode" */
	fbdev2xfree_timing(&fPtr->var, &fPtr->buildin);
	fPtr->buildin.name  = "current";
	fPtr->buildin.next  = &fPtr->buildin;
	fPtr->buildin.prev  = &fPtr->buildin;
	fPtr->buildin.type |= M_T_BUILTIN;
	
	return TRUE;
d404 1
a404 1
char*
d407 3
a409 2
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
	return fPtr->fix.id;
d415 1
a415 1
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
d417 2
a418 2
	if (fbbpp)
	    *fbbpp = fPtr->var.bits_per_pixel;
d420 6
a425 6
	if (fPtr->fix.visual == FB_VISUAL_TRUECOLOR ||
	    fPtr->fix.visual == FB_VISUAL_DIRECTCOLOR)
		return fPtr->var.red.length+fPtr->var.green.length+
			fPtr->var.blue.length;
	else
		return fPtr->var.bits_per_pixel;
d431 1
a431 1
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
d433 4
a436 4
	if (fPtr->fix.line_length)
		return fPtr->fix.line_length;
	else
		return fPtr->var.xres_virtual*fPtr->var.bits_per_pixel/8;
d442 3
a444 2
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
	return fPtr->fix.type;
d450 3
a452 2
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
	return fPtr->fix.smem_len;
d458 2
a459 2
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
	struct fb_var_screeninfo req_var = fPtr->var, set_var;
d461 2
a462 2
	xfree2fbdev_fblayout(pScrn, &req_var);
	xfree2fbdev_timing(mode, &req_var);
d465 2
a466 2
	print_xfree_mode("init", mode);
	print_fbdev_mode("init", &req_var);
d469 1
a469 1
	set_var = req_var;
d471 2
a472 2
	if (check)
		set_var.activate = FB_ACTIVATE_TEST;
d474 10
a483 11
	if (0 != ioctl(fPtr->fd, FBIOPUT_VSCREENINFO, (void*)(&set_var))) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "FBIOPUT_VSCREENINFO: %s\n", strerror(errno));
		return FALSE;
	}

	if (!fbdev_modes_equal(&set_var, &req_var)) {
		if (!check)
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				   "FBIOPUT_VSCREENINFO succeeded but modified "
				   "mode\n");
d485 1
a485 1
		print_fbdev_mode("returned", &set_var);
d487 2
a488 2
		return FALSE;
	}
d490 2
a491 2
	if (!check)
		fPtr->var = set_var;
d493 1
a493 1
	return TRUE;
d499 8
a506 2
	char **modename;
	DisplayModePtr mode,this,last = pScrn->modes;
d508 16
a523 2
	if (NULL == pScrn->display->modes)
		return;
d525 1
a525 2
	pScrn->virtualX = pScrn->display->virtualX;
	pScrn->virtualY = pScrn->display->virtualY;
d527 19
a545 38
	for (modename = pScrn->display->modes; *modename != NULL; modename++) {
		for (mode = pScrn->monitor->Modes; mode != NULL; mode = mode->next) {
			if (0 == strcmp(mode->name,*modename)) {
				if (fbdevHWSetMode(pScrn, mode, TRUE))
					break;

				xf86DrvMsg(pScrn->scrnIndex, X_INFO,
					   "\tmode \"%s\" test failed\n", *modename);
			}
		}

		if (NULL == mode) {
			xf86DrvMsg(pScrn->scrnIndex, X_INFO,
				   "\tmode \"%s\" not found\n", *modename);
			continue;
		}

		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "\tmode \"%s\" ok\n", *modename);

		if (pScrn->virtualX < mode->HDisplay)
			pScrn->virtualX = mode->HDisplay;
		if (pScrn->virtualY < mode->VDisplay)
			pScrn->virtualY = mode->VDisplay;

		if (NULL == pScrn->modes) {
			this = pScrn->modes = xf86DuplicateMode(mode);
			this->next = this;
			this->prev = this;
		} else {
			this = xf86DuplicateMode(mode);
			this->next = pScrn->modes;
			this->prev = last;
			last->next = this;
			pScrn->modes->prev = this;
		}
		last = this;
	}
d551 3
a553 2
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
	return &fPtr->buildin;
d559 1
a559 1
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
d561 7
a567 7
	pScrn->modes    = &fPtr->buildin;
	pScrn->virtualX = pScrn->display->virtualX;
	pScrn->virtualY = pScrn->display->virtualY;
	if (pScrn->virtualX < fPtr->buildin.HDisplay)
		pScrn->virtualX = fPtr->buildin.HDisplay;
	if (pScrn->virtualY < fPtr->buildin.VDisplay)
		pScrn->virtualY = fPtr->buildin.VDisplay;
d575 3
a577 3
	fPtr->fboff = (unsigned long) fPtr->fix.smem_start & ~PAGE_MASK;
	fPtr->fbmem_len = (fPtr->fboff+fPtr->fix.smem_len+~PAGE_MASK) &
			  PAGE_MASK;
d580 1
a580 2

void*
d583 1
a583 1
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
d585 21
a605 18
	if (NULL == fPtr->fbmem) {
		calculateFbmem_len(fPtr);
		fPtr->fbmem = mmap(NULL, fPtr->fbmem_len, PROT_READ | PROT_WRITE,
				   MAP_SHARED, fPtr->fd, 0);
		if (-1 == (long)fPtr->fbmem) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				   "mmap fbmem: %s\n", strerror(errno));
			fPtr->fbmem = NULL;
		} else {
		    /* Perhaps we'd better add fboff to fbmem and return 0 in
		       fbdevHWLinearOffset()? Of course we then need to mask
		       fPtr->fbmem with PAGE_MASK in fbdevHWUnmapVidmem() as
		       well. [geert] */
		}
	}
	pScrn->memPhysBase = (unsigned long)fPtr->fix.smem_start & (unsigned long)(PAGE_MASK);
	pScrn->fbOffset = (unsigned long)fPtr->fix.smem_start & (unsigned long)(~PAGE_MASK);
	return fPtr->fbmem;
d611 1
a611 1
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
d613 1
a613 1
	return fPtr->fboff;
d619 1
a619 1
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
d621 7
a627 7
	if (NULL != fPtr->fbmem) {
		if (-1 == munmap(fPtr->fbmem, fPtr->fbmem_len))
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				   "munmap fbmem: %s\n", strerror(errno));
		fPtr->fbmem = NULL;
	}
	return TRUE;
d630 1
a630 1
void*
d633 1
a633 1
	unsigned int mmio_off;
d635 1
a635 1
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
d637 24
a660 23
	if (NULL == fPtr->mmio) {
		/* tell the kernel not to use accels to speed up console scrolling */
		fPtr->var.accel_flags = 0;
		if (0 != ioctl(fPtr->fd,FBIOPUT_VSCREENINFO,(void*)(&fPtr->var))) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				   "FBIOPUT_VSCREENINFO: %s\n", strerror(errno));
			return FALSE;
		}
		mmio_off = (unsigned long) fPtr->fix.mmio_start & ~PAGE_MASK;
		fPtr->mmio_len = (mmio_off+fPtr->fix.mmio_len+~PAGE_MASK) &
				  PAGE_MASK;
		if (NULL == fPtr->fbmem)
			calculateFbmem_len(fPtr);
		fPtr->mmio = mmap(NULL, fPtr->mmio_len, PROT_READ | PROT_WRITE,
				  MAP_SHARED, fPtr->fd, fPtr->fbmem_len);
		if (-1 == (long)fPtr->mmio) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				   "mmap mmio: %s\n", strerror(errno));
			fPtr->mmio = NULL;
		} else
			fPtr->mmio += mmio_off;
	}
	return fPtr->mmio;
d666 1
a666 1
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
d668 10
a677 8
	if (NULL != fPtr->mmio) {
		if (-1 == munmap((void *)((unsigned long)fPtr->mmio & PAGE_MASK), fPtr->mmio_len))
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				   "munmap mmio: %s\n", strerror(errno));
		fPtr->mmio = NULL;
		/* FIXME: restore var.accel_flags [geert] */
	}
	return TRUE;
d684 36
a719 33
{	
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
	
	pScrn->vtSema = TRUE;

	/* set */
	if (!fbdevHWSetMode(pScrn, mode, FALSE))
		return FALSE;

	/* read back */
	if (0 != ioctl(fPtr->fd,FBIOGET_FSCREENINFO,(void*)(&fPtr->fix))) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "FBIOGET_FSCREENINFO: %s\n", strerror(errno));
		return FALSE;
	}
	if (0 != ioctl(fPtr->fd,FBIOGET_VSCREENINFO,(void*)(&fPtr->var))) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "FBIOGET_VSCREENINFO: %s\n", strerror(errno));
		return FALSE;
	}

	if (pScrn->defaultVisual == TrueColor ||
	    pScrn->defaultVisual == DirectColor) {
	    /* XXX: This is a hack, but it should be a NOP for all the setups that
	     * worked before and actually seems to fix some others...
	     */
	    pScrn->offset.red   = fPtr->var.red.offset;
	    pScrn->offset.green = fPtr->var.green.offset;
	    pScrn->offset.blue  = fPtr->var.blue.offset;
	    pScrn->mask.red     = ((1 << fPtr->var.red.length) - 1) << fPtr->var.red.offset;
	    pScrn->mask.green   = ((1 << fPtr->var.green.length) - 1) << fPtr->var.green.offset;
	    pScrn->mask.blue    = ((1 << fPtr->var.blue.length) - 1) << fPtr->var.blue.offset;
	}
d721 1
a721 1
	return TRUE;
d729 1
a729 1
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
d731 3
a733 3
	if (0 != ioctl(fPtr->fd,FBIOGET_VSCREENINFO,(void*)(&fPtr->saved_var)))
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "FBIOGET_VSCREENINFO: %s\n", strerror(errno));
d739 1
a739 1
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
d741 3
a743 3
	if (0 != ioctl(fPtr->fd,FBIOPUT_VSCREENINFO,(void*)(&fPtr->saved_var)))
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "FBIOPUT_VSCREENINFO: %s\n", strerror(errno));
d751 1
a751 1
		 LOCO *colors, VisualPtr pVisual)
d753 19
a771 22
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
	struct fb_cmap cmap;
	unsigned short red,green,blue;
	int i;

	cmap.len   = 1;
	cmap.red   = &red;
	cmap.green = &green;
	cmap.blue  = &blue;
	cmap.transp = NULL;
	for (i = 0; i < numColors; i++) {
		cmap.start = indices[i];
		red   = (colors[indices[i]].red   << 8) |
			colors[indices[i]].red;
		green = (colors[indices[i]].green << 8) |
			colors[indices[i]].green;
		blue  = (colors[indices[i]].blue  << 8) |
			colors[indices[i]].blue;
		if (-1 == ioctl(fPtr->fd,FBIOPUTCMAP,(void*)&cmap))
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				   "FBIOPUTCMAP: %s\n", strerror(errno));
	}
d780 1
a780 1
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d782 2
a783 2
	if (!fbdevHWSetMode(pScrn, mode, TRUE))
		return MODE_BAD;
d785 1
a785 1
	return MODE_OK;
d791 1
a791 2
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];

d793 2
a794 2
	if (!fbdevHWSetMode(pScrn, mode, FALSE))
		return FALSE;
d796 1
a796 1
	return TRUE;
d802 2
a803 2
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
d805 9
a813 9
	if ( x < 0 || x + fPtr->var.xres > fPtr->var.xres_virtual || 
	     y < 0 || y + fPtr->var.yres > fPtr->var.yres_virtual )
		return;

	fPtr->var.xoffset = x;
	fPtr->var.yoffset = y;
	if (-1 == ioctl(fPtr->fd,FBIOPAN_DISPLAY,(void*)&fPtr->var))
		xf86DrvMsgVerb(scrnIndex, X_WARNING, 5, 
			   "FBIOPAN_DISPLAY: %s\n", strerror(errno));
d819 6
a824 6
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
	
	if (!fbdevHWModeInit(pScrn, pScrn->currentMode))
		return FALSE;
	fbdevHWAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
	return TRUE;
d830 1
a830 1
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d832 1
a832 1
	fbdevHWRestore(pScrn);
d838 5
a842 2
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
	unsigned long fbmode;
d844 16
a859 2
	if (!pScrn->vtSema)
		return;
d861 3
a863 20
	switch (mode) {
		case DPMSModeOn:
			fbmode = 0;
			break;
		case DPMSModeStandby:
			fbmode = 2;
			break;
		case DPMSModeSuspend:
			fbmode = 3;
			break;
		case DPMSModeOff:
			fbmode = 4;
			break;
		default:
			return;
	}

	if (-1 == ioctl(fPtr->fd, FBIOBLANK, (void *)fbmode))
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "FBIOBLANK: %s\n", strerror(errno));
d869 14
a882 14
	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
	unsigned long unblank;

	if (!pScrn->vtSema)
		return TRUE;

	unblank = xf86IsUnblank(mode);

	if (-1 == ioctl(fPtr->fd, FBIOBLANK, (void *)(1-unblank))) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "FBIOBLANK: %s\n", strerror(errno));
		return FALSE;
	}
d884 1
a884 1
	return TRUE;
d888 4
a891 1
fbdevHWSwitchModeWeak(void) { return fbdevHWSwitchMode; }
d894 4
a897 1
fbdevHWAdjustFrameWeak(void) { return fbdevHWAdjustFrame; }
d900 4
a903 1
fbdevHWEnterVTWeak(void) { return fbdevHWEnterVT; }
d906 4
a909 1
fbdevHWLeaveVTWeak(void) { return fbdevHWLeaveVT; }
d912 4
a915 1
fbdevHWValidModeWeak(void) { return fbdevHWValidMode; }
d918 4
a921 1
fbdevHWDPMSSetWeak(void) { return fbdevHWDPMSSet; }
d924 4
a927 1
fbdevHWLoadPaletteWeak(void) { return fbdevHWLoadPalette; }
d930 4
a933 1
fbdevHWSaveScreenWeak(void) { return fbdevHWSaveScreen; }
@


1.7
log
@Update to xserver 1.11.2
@
text
@d512 10
a521 3
		for (mode = pScrn->monitor->Modes; mode != NULL; mode = mode->next)
			if (0 == strcmp(mode->name,*modename))
				break;
a527 5
		if (!fbdevHWSetMode(pScrn, mode, TRUE)) {
			xf86DrvMsg(pScrn->scrnIndex, X_INFO,
				   "\tmode \"%s\" test failed\n", *modename);
			continue;
		}
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a18 3

#define PAGE_MASK               (~(getpagesize() - 1))

a21 2
#define DEBUG 0

a23 10
#if DEBUG
# define TRACE_ENTER(str)	ErrorF("fbdevHW: " str " %d\n",pScrn->scrnIndex)
#else
# define TRACE_ENTER(str)
#endif

/* -------------------------------------------------------------------- */

static MODULESETUPPROTO(fbdevhwSetup);

d40 1
a40 1
    fbdevhwSetup,
a43 6
static pointer
fbdevhwSetup(pointer module, pointer opts, int *errmaj, int *errmin)
{
    return (pointer)1;
}

a50 1
#include <string.h>
a76 6
	/* FIXME: unused??? [geert] */
	struct fb_cmap			saved_cmap;
	unsigned short			*saved_red;
	unsigned short			*saved_green;
	unsigned short			*saved_blue;

d266 1
a266 8
    int	fd,i,j;


    /* There are two ways to that we can determine which fb device is
     * associated with this PCI device.  The more modern way is to look in
     * the sysfs directory for the PCI device for a file named
     * "graphics/fb*"
     */
a298 44

    /* The other way is to examine the resources associated with each fb
     * device and see if there is a match with the PCI device.  This technique
     * has some problems on certain mixed 64-bit / 32-bit architectures.
     * There is a flaw in the fb_fix_screeninfo structure in that it only
     * returns the low 32-bits of the address of the resources associated with
     * a device.  However, on a mixed architecture the base addresses of PCI
     * devices, even for 32-bit applications, may be higher than 0x0f0000000.
     */

    for (i = 0; i < 8; i++) {
	sprintf(filename,"/dev/fb%d",i);
	if (-1 == (fd = open(filename,O_RDWR,0))) {
	    xf86DrvMsg(-1, X_WARNING,
		       "open %s: %s\n", filename, strerror(errno));
	    continue;
	}
	if (-1 == ioctl(fd,FBIOGET_FSCREENINFO,(void*)&fix)) {
	    close(fd);
	    continue;
	}
	for (j = 0; j < 6; j++) {
	    const pciaddr_t res_start = pPci->regions[j].base_addr;
	    const pciaddr_t res_end = res_start + pPci->regions[j].size;

	    if ((0 != fix.smem_len &&
		 (pciaddr_t) fix.smem_start >= res_start &&
		 (pciaddr_t) fix.smem_start < res_end) ||
		(0 != fix.mmio_len &&
		 (pciaddr_t) fix.mmio_start >= res_start &&
		 (pciaddr_t) fix.mmio_start < res_end))
	      break;
	}
	if (j == 6) {
	    close(fd);
	    continue;
	}
	if (namep) {
	    *namep = xnfalloc(16);
	    strncpy(*namep,fix.id,16);
	}
	return fd;
    }

d302 1
a302 2
    xf86DrvMsg(-1, X_ERROR,
	       "Unable to find a valid framebuffer device\n");
a367 2
	TRACE_ENTER("Init");

a461 2
	
	TRACE_ENTER("SetMode");
a504 1
	TRACE_ENTER("VerifyModes");
a560 1
	TRACE_ENTER("UseBuildinMode");
a585 1
	TRACE_ENTER("MapVidmem");
a610 1
	TRACE_ENTER("LinearOffset");
a618 1
	TRACE_ENTER("UnmapVidmem");
a634 1
	TRACE_ENTER("MapMMIO");
a664 1
	TRACE_ENTER("UnmapMMIO");
a717 2

/* TODO: colormap */
a722 1
	TRACE_ENTER("Save");
a732 1
	TRACE_ENTER("Restore");
a749 1
	TRACE_ENTER("LoadPalette");
a776 2
	TRACE_ENTER("ValidMode");

a787 1
	TRACE_ENTER("SwitchMode");
a800 1
	TRACE_ENTER("AdjustFrame");
a816 1
	TRACE_ENTER("EnterVT");
a827 1
	TRACE_ENTER("LeaveVT");
a836 1
	TRACE_ENTER("DPMSSet");
a868 1
	TRACE_ENTER("HWSaveScreen");
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d132 1
a132 1
	xfree(FBDEVHWPTR(pScrn));
@


1.4
log
@Update to server 1.6.5.
@
text
@d20 1
a20 6
#if 0
/* kernel header doesn't work with -ansi */
# include "asm/page.h"	/* #define for PAGE_* */
#else
# define PAGE_MASK               (~(getpagesize() - 1))
#endif
d23 1
a23 2
#define DPMS_SERVER
#include <X11/extensions/dpms.h>
d62 1
a62 14
	const char *osname;

	/* Check that we're being loaded on a Linux system */
	LoaderGetOS(&osname, NULL, NULL, NULL);
	if (!osname || strcmp(osname, "linux") != 0) {
		if (errmaj)
			*errmaj = LDR_BADOS;
		if (errmin)
			*errmin = 0;
		return NULL;
	} else {
		/* OK */
		return (pointer)1;
	}
d136 11
a217 1
#if 1 /* Badly needed for PAL/NTSC on Amiga (amifb)!! [geert] */
a219 1
#endif
a262 1
#if 1 /* Badly needed for PAL/NTSC on Amiga (amifb)!! [geert] */
a264 1
#endif
d329 1
a331 2

	close(fd);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d321 7
a327 1
	if (fd != -1) {
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a247 1
		set->pixclock == req->pixclock &&
@


1.1
log
@Initial revision
@
text
@d186 2
a187 1
	var->xres_virtual   = pScrn->virtualX;
d190 10
a199 3
	var->red.length     = pScrn->weight.red;
	var->green.length   = pScrn->weight.green;
	var->blue.length    = pScrn->weight.blue;
d238 20
d261 1
a261 1
	mode->Clock = var->pixclock ? 1000000000/var->pixclock : 28000000;
d299 3
a301 1
/* try to find the framebuffer device for a given PCI device */
d303 1
a303 1
fbdev_open_pci(pciVideoPtr pPci, char **namep)
d305 30
a334 11
	struct	fb_fix_screeninfo fix;
	char	filename[16];
	int	fd,i,j;
	memType res_start, res_end;

	for (i = 0; i < 8; i++) {
		sprintf(filename,"/dev/fb%d",i);
		if (-1 == (fd = open(filename,O_RDWR,0))) {
			xf86DrvMsg(-1, X_WARNING,
				   "open %s: %s\n", filename, strerror(errno));
			continue;
d336 46
a381 24
		if (-1 == ioctl(fd,FBIOGET_FSCREENINFO,(void*)&fix)) {
			close(fd);
			continue;
		}
		for (j = 0; j < 6; j++) {
			res_start = pPci->memBase[j];
			res_end = res_start+pPci->size[j];
			if ((0 != fix.smem_len &&
			     (memType) fix.smem_start >= res_start &&
			     (memType) fix.smem_start < res_end) ||
			    (0 != fix.mmio_len &&
			     (memType) fix.mmio_start >= res_start &&
			     (memType) fix.mmio_start < res_end))
				break;
		}
		if (j == 6) {
			close(fd);
			continue;
		}
		if (namep) {
		    *namep = xnfalloc(16);
		    strncpy(*namep,fix.id,16);
		}
		return fd;
d383 5
a387 5
	if (namep)
	    *namep = NULL;
	xf86DrvMsg(-1, X_ERROR,
		   "Unable to find a valid framebuffer device\n");
	return -1;
d389 3
d436 1
a436 1
fbdevHWProbe(pciVideoPtr pPci, char *device,char **namep)
d452 1
a452 1
fbdevHWInit(ScrnInfoPtr pScrn, pciVideoPtr pPci, char *device)
d547 44
a593 4
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
	int virtX = pScrn->display->virtualX;
	int virtY = pScrn->display->virtualY;
	struct fb_var_screeninfo var;
d601 3
d613 2
a614 13
		memset(&var,0,sizeof(var));
		xfree2fbdev_timing(mode,&var);
		var.xres_virtual = virtX;
		var.yres_virtual = virtY;
		var.bits_per_pixel = pScrn->bitsPerPixel;
		var.red.length = pScrn->weight.red;
		var.green.length = pScrn->weight.green;
		var.blue.length = pScrn->weight.blue;

		var.activate = FB_ACTIVATE_TEST;
		if (var.xres_virtual < var.xres) var.xres_virtual = var.xres;
		if (var.yres_virtual < var.yres) var.yres_virtual = var.yres;
		if (-1 == ioctl(fPtr->fd,FBIOPUT_VSCREENINFO,(void*)(&var))) {
d621 6
a626 2
		if (virtX < var.xres) virtX = var.xres;
		if (virtY < var.yres) virtY = var.yres;
d628 1
a628 3
			pScrn->modes = xnfalloc(sizeof(DisplayModeRec));
			this = pScrn->modes;
			memcpy(this,mode,sizeof(DisplayModeRec));
d632 1
a632 2
			this = xnfalloc(sizeof(DisplayModeRec));
			memcpy(this,mode,sizeof(DisplayModeRec));
a639 2
	pScrn->virtualX     = virtX;
	pScrn->virtualY     = virtY;
a780 7
	TRACE_ENTER("ModeInit");
	xfree2fbdev_fblayout(pScrn, &fPtr->var);
	xfree2fbdev_timing(mode,  &fPtr->var);
#if DEBUG
	print_xfree_mode("init",mode);
	print_fbdev_mode("init",&fPtr->var);
#endif
d784 1
a784 3
	if (0 != ioctl(fPtr->fd,FBIOPUT_VSCREENINFO,(void*)(&fPtr->var))) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "FBIOPUT_VSCREENINFO: %s\n", strerror(errno));
d786 1
a786 1
	}
d798 14
a879 2
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
	struct fb_var_screeninfo var;
d882 2
a883 6
	memcpy(&var,&fPtr->var,sizeof(var));
	xfree2fbdev_timing(mode, &var);
	var.activate = FB_ACTIVATE_TEST;
	if (0 != ioctl(fPtr->fd,FBIOPUT_VSCREENINFO,(void*)(&fPtr->var))) {
		xf86DrvMsg(scrnIndex, X_ERROR,
			   "FBIOPUT_VSCREENINFO: %s\n", strerror(errno));
d885 1
a885 1
	}
a892 1
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
d895 2
a896 4
	xfree2fbdev_timing(mode, &fPtr->var);
	if (0 != ioctl(fPtr->fd,FBIOPUT_VSCREENINFO,(void*)(&fPtr->var))) {
		xf86DrvMsg(scrnIndex, X_ERROR,
			   "FBIOPUT_VSCREENINFO: %s\n", strerror(errno));
d898 1
a898 1
	}
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d186 1
a186 2
	var->xres_virtual   = pScrn->displayWidth ? pScrn->displayWidth :
			      pScrn->virtualX;
d189 3
a191 10
	if (pScrn->defaultVisual == TrueColor ||
	    pScrn->defaultVisual == DirectColor) {
	    var->red.length     = pScrn->weight.red;
	    var->green.length   = pScrn->weight.green;
	    var->blue.length    = pScrn->weight.blue;
	} else {
	    var->red.length     = 8;
	    var->green.length   = 8;
	    var->blue.length    = 8;
	}
a229 20
static Bool
fbdev_modes_equal(struct fb_var_screeninfo *set, struct fb_var_screeninfo *req)
{
	return (set->xres_virtual >= req->xres_virtual &&
		set->yres_virtual >= req->yres_virtual &&
		set->bits_per_pixel == req->bits_per_pixel &&
		set->red.length == req->red.length &&
		set->green.length == req->green.length &&
		set->blue.length == req->blue.length &&
		set->xres == req->xres && set->yres == req->yres &&
		set->pixclock == req->pixclock &&
		set->right_margin == req->right_margin &&
		set->hsync_len == req->hsync_len &&
		set->left_margin == req->left_margin &&
		set->lower_margin == req->lower_margin &&
		set->vsync_len == req->vsync_len &&
		set->upper_margin == req->upper_margin &&
		set->sync == req->sync && set->vmode == req->vmode);
}

a472 44
static Bool
fbdevHWSetMode(ScrnInfoPtr pScrn, DisplayModePtr mode, Bool check)
{
	fbdevHWPtr fPtr = FBDEVHWPTR(pScrn);
	struct fb_var_screeninfo req_var = fPtr->var, set_var;
	
	TRACE_ENTER("SetMode");

	xfree2fbdev_fblayout(pScrn, &req_var);
	xfree2fbdev_timing(mode, &req_var);

#if DEBUG
	print_xfree_mode("init", mode);
	print_fbdev_mode("init", &req_var);
#endif

	set_var = req_var;

	if (check)
		set_var.activate = FB_ACTIVATE_TEST;

	if (0 != ioctl(fPtr->fd, FBIOPUT_VSCREENINFO, (void*)(&set_var))) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "FBIOPUT_VSCREENINFO: %s\n", strerror(errno));
		return FALSE;
	}

	if (!fbdev_modes_equal(&set_var, &req_var)) {
		if (!check)
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				   "FBIOPUT_VSCREENINFO succeeded but modified "
				   "mode\n");
#if DEBUG
		print_fbdev_mode("returned", &set_var);
#endif
		return FALSE;
	}

	if (!check)
		fPtr->var = set_var;

	return TRUE;
}

d476 4
a486 3
	pScrn->virtualX = pScrn->display->virtualX;
	pScrn->virtualY = pScrn->display->virtualY;

d496 13
a508 2

		if (!fbdevHWSetMode(pScrn, mode, TRUE)) {
d515 2
a516 6

		if (pScrn->virtualX < mode->HDisplay)
			pScrn->virtualX = mode->HDisplay;
		if (pScrn->virtualY < mode->VDisplay)
			pScrn->virtualY = mode->VDisplay;

d533 2
d676 7
d686 3
a688 1
	if (!fbdevHWSetMode(pScrn, mode, FALSE))
d690 1
a690 1

a701 14

	if (pScrn->defaultVisual == TrueColor ||
	    pScrn->defaultVisual == DirectColor) {
	    /* XXX: This is a hack, but it should be a NOP for all the setups that
	     * worked before and actually seems to fix some others...
	     */
	    pScrn->offset.red   = fPtr->var.red.offset;
	    pScrn->offset.green = fPtr->var.green.offset;
	    pScrn->offset.blue  = fPtr->var.blue.offset;
	    pScrn->mask.red     = ((1 << fPtr->var.red.length) - 1) << fPtr->var.red.offset;
	    pScrn->mask.green   = ((1 << fPtr->var.green.length) - 1) << fPtr->var.green.offset;
	    pScrn->mask.blue    = ((1 << fPtr->var.blue.length) - 1) << fPtr->var.blue.offset;
	}

d770 2
d774 6
a779 2

	if (!fbdevHWSetMode(pScrn, mode, TRUE))
d781 1
a781 1

d789 1
d792 4
a795 2

	if (!fbdevHWSetMode(pScrn, mode, FALSE))
d797 1
a797 1

@

