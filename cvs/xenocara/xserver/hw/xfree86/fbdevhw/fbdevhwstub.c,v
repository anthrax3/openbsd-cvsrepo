head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.14
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.12
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.10
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.8
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.14
	OPENBSD_5_0:1.2.0.12
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.8
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.10
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2013.06.07.17.28.51;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.28;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "xf86.h"
#include "xf86cmap.h"
#include "fbdevhw.h"

/* Stubs for the static server on platforms that don't support fbdev */

Bool
fbdevHWGetRec(ScrnInfoPtr pScrn)
{
    return FALSE;
}

void
fbdevHWFreeRec(ScrnInfoPtr pScrn)
{
}

Bool
fbdevHWProbe(struct pci_device *pPci, char *device, char **namep)
{
    return FALSE;
}

Bool
fbdevHWInit(ScrnInfoPtr pScrn, struct pci_device *pPci, char *device)
{
    xf86Msg(X_ERROR, "fbdevhw is not available on this platform\n");
    return FALSE;
}

char *
fbdevHWGetName(ScrnInfoPtr pScrn)
{
    return NULL;
}

int
fbdevHWGetDepth(ScrnInfoPtr pScrn, int *fbbpp)
{
    return -1;
}

int
fbdevHWGetLineLength(ScrnInfoPtr pScrn)
{
    return -1;                  /* Should cause something spectacular... */
}

int
fbdevHWGetType(ScrnInfoPtr pScrn)
{
    return -1;
}

int
fbdevHWGetVidmem(ScrnInfoPtr pScrn)
{
    return -1;
}

void
fbdevHWSetVideoModes(ScrnInfoPtr pScrn)
{
}

DisplayModePtr
fbdevHWGetBuildinMode(ScrnInfoPtr pScrn)
{
    return NULL;
}

void
fbdevHWUseBuildinMode(ScrnInfoPtr pScrn)
{
}

void *
fbdevHWMapVidmem(ScrnInfoPtr pScrn)
{
    return NULL;
}

int
fbdevHWLinearOffset(ScrnInfoPtr pScrn)
{
    return 0;
}

Bool
fbdevHWUnmapVidmem(ScrnInfoPtr pScrn)
{
    return FALSE;
}

void *
fbdevHWMapMMIO(ScrnInfoPtr pScrn)
{
    return NULL;
}

Bool
fbdevHWUnmapMMIO(ScrnInfoPtr pScrn)
{
    return FALSE;
}

Bool
fbdevHWModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    return FALSE;
}

void
fbdevHWSave(ScrnInfoPtr pScrn)
{
}

void
fbdevHWRestore(ScrnInfoPtr pScrn)
{
}

void
fbdevHWLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
                   LOCO * colors, VisualPtr pVisual)
{
}

ModeStatus
fbdevHWValidMode(ScrnInfoPtr pScrn, DisplayModePtr mode, Bool verbose, int flags)
{
    return MODE_ERROR;
}

Bool
fbdevHWSwitchMode(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    return FALSE;
}

void
fbdevHWAdjustFrame(ScrnInfoPtr pScrn, int x, int y)
{
}

Bool
fbdevHWEnterVT(ScrnInfoPtr pScrn)
{
    return FALSE;
}

void
fbdevHWLeaveVT(ScrnInfoPtr pScrn)
{
}

void
fbdevHWDPMSSet(ScrnInfoPtr pScrn, int mode, int flags)
{
}

Bool
fbdevHWSaveScreen(ScreenPtr pScreen, int mode)
{
    return FALSE;
}

xf86SwitchModeProc *
fbdevHWSwitchModeWeak(void)
{
    return fbdevHWSwitchMode;
}

xf86AdjustFrameProc *
fbdevHWAdjustFrameWeak(void)
{
    return fbdevHWAdjustFrame;
}

xf86EnterVTProc *
fbdevHWEnterVTWeak(void)
{
    return fbdevHWEnterVT;
}

xf86LeaveVTProc *
fbdevHWLeaveVTWeak(void)
{
    return fbdevHWLeaveVT;
}

xf86ValidModeProc *
fbdevHWValidModeWeak(void)
{
    return fbdevHWValidMode;
}

xf86DPMSSetProc *
fbdevHWDPMSSetWeak(void)
{
    return fbdevHWDPMSSet;
}

xf86LoadPaletteProc *
fbdevHWLoadPaletteWeak(void)
{
    return fbdevHWLoadPalette;
}

SaveScreenProcPtr
fbdevHWSaveScreenWeak(void)
{
    return fbdevHWSaveScreen;
}
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d134 1
a134 1
fbdevHWValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
d140 1
a140 1
fbdevHWSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
d146 1
a146 1
fbdevHWAdjustFrame(int scrnIndex, int x, int y, int flags)
d151 1
a151 1
fbdevHWEnterVT(int scrnIndex, int flags)
d157 1
a157 1
fbdevHWLeaveVT(int scrnIndex, int flags)
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a10 1

d14 1
a14 1
	return FALSE;
a21 1

d25 1
a25 1
	return FALSE;
d31 2
a32 2
	xf86Msg(X_ERROR, "fbdevhw is not available on this platform\n");
	return FALSE;
d35 1
a35 1
char*
d38 1
a38 1
	return NULL;
d44 1
a44 1
	return -1;
d50 1
a50 1
	return -1;	/* Should cause something spectacular... */
d56 1
a56 1
	return -1;
d62 1
a62 1
	return -1;
d73 1
a73 1
	return NULL;
d81 1
a81 1
void*
d84 1
a84 1
	return NULL;
d90 1
a90 1
	return 0;
d96 1
a96 1
	return FALSE;
d99 1
a99 1
void*
d102 1
a102 1
	return NULL;
d108 1
a108 1
	return FALSE;
d113 2
a114 2
{	
	return FALSE;
d129 1
a129 1
		 LOCO *colors, VisualPtr pVisual)
d136 1
a136 1
	return MODE_ERROR;
d142 1
a142 1
	return FALSE;
d153 1
a153 1
	return FALSE;
d169 1
a169 1
	return FALSE;
d173 4
a176 1
fbdevHWSwitchModeWeak(void) { return fbdevHWSwitchMode; }
d179 4
a182 1
fbdevHWAdjustFrameWeak(void) { return fbdevHWAdjustFrame; }
d185 4
a188 1
fbdevHWEnterVTWeak(void) { return fbdevHWEnterVT; }
d191 4
a194 1
fbdevHWLeaveVTWeak(void) { return fbdevHWLeaveVT; }
d197 4
a200 1
fbdevHWValidModeWeak(void) { return fbdevHWValidMode; }
d203 4
a206 1
fbdevHWDPMSSetWeak(void) { return fbdevHWDPMSSet; }
d209 4
a212 1
fbdevHWLoadPaletteWeak(void) { return fbdevHWLoadPalette; }
d215 4
a218 1
fbdevHWSaveScreenWeak(void) { return fbdevHWSaveScreen; }
@


1.1
log
@Initial revision
@
text
@a0 1

d25 1
a25 1
fbdevHWProbe(pciVideoPtr pPci, char *device, char **namep)
d31 1
a31 1
fbdevHWInit(ScrnInfoPtr pScrn, pciVideoPtr pPci, char *device)
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
