head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.38;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.20.54;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.20.54;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.58.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *
 * Copyright (c) 1997  Metro Link Incorporated
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of the Metro Link shall not be
 * used in advertising or otherwise to promote the sale, use or other dealings
 * in this Software without prior written authorization from Metro Link.
 *
 */
/*
 * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "xf86Parser.h"
#include "xf86tokens.h"
#include "Configint.h"


static xf86ConfigSymTabRec DisplayTab[] = {
    {ENDSUBSECTION, "endsubsection"},
    {MODES, "modes"},
    {VIEWPORT, "viewport"},
    {VIRTUAL, "virtual"},
    {VISUAL, "visual"},
    {BLACK_TOK, "black"},
    {WHITE_TOK, "white"},
    {DEPTH, "depth"},
    {BPP, "fbbpp"},
    {WEIGHT, "weight"},
    {OPTION, "option"},
    {-1, ""},
};

static void
xf86freeModeList(XF86ModePtr ptr)
{
    XF86ModePtr prev;

    while (ptr) {
        TestFree(ptr->mode_name);
        prev = ptr;
        ptr = ptr->list.next;
        free(prev);
    }
}

static void
xf86freeDisplayList(XF86ConfDisplayPtr ptr)
{
    XF86ConfDisplayPtr prev;

    while (ptr) {
        xf86freeModeList(ptr->disp_mode_lst);
        xf86optionListFree(ptr->disp_option_lst);
        prev = ptr;
        ptr = ptr->list.next;
        free(prev);
    }
}

#define CLEANUP xf86freeDisplayList

static XF86ConfDisplayPtr
xf86parseDisplaySubSection(void)
{
    int token;

    parsePrologue(XF86ConfDisplayPtr, XF86ConfDisplayRec)

        ptr->disp_black.red = ptr->disp_black.green = ptr->disp_black.blue = -1;
    ptr->disp_white.red = ptr->disp_white.green = ptr->disp_white.blue = -1;
    ptr->disp_frameX0 = ptr->disp_frameY0 = -1;
    while ((token = xf86getToken(DisplayTab)) != ENDSUBSECTION) {
        switch (token) {
        case COMMENT:
            ptr->disp_comment = xf86addComment(ptr->disp_comment, xf86_lex_val.str);
            break;
        case VIEWPORT:
            if (xf86getSubToken(&(ptr->disp_comment)) != NUMBER)
                Error(VIEWPORT_MSG);
            ptr->disp_frameX0 = xf86_lex_val.num;
            if (xf86getSubToken(&(ptr->disp_comment)) != NUMBER)
                Error(VIEWPORT_MSG);
            ptr->disp_frameY0 = xf86_lex_val.num;
            break;
        case VIRTUAL:
            if (xf86getSubToken(&(ptr->disp_comment)) != NUMBER)
                Error(VIRTUAL_MSG);
            ptr->disp_virtualX = xf86_lex_val.num;
            if (xf86getSubToken(&(ptr->disp_comment)) != NUMBER)
                Error(VIRTUAL_MSG);
            ptr->disp_virtualY = xf86_lex_val.num;
            break;
        case DEPTH:
            if (xf86getSubToken(&(ptr->disp_comment)) != NUMBER)
                Error(NUMBER_MSG, "Display");
            ptr->disp_depth = xf86_lex_val.num;
            break;
        case BPP:
            if (xf86getSubToken(&(ptr->disp_comment)) != NUMBER)
                Error(NUMBER_MSG, "Display");
            ptr->disp_bpp = xf86_lex_val.num;
            break;
        case VISUAL:
            if (xf86getSubToken(&(ptr->disp_comment)) != STRING)
                Error(QUOTE_MSG, "Display");
            ptr->disp_visual = xf86_lex_val.str;
            break;
        case WEIGHT:
            if (xf86getSubToken(&(ptr->disp_comment)) != NUMBER)
                Error(WEIGHT_MSG);
            ptr->disp_weight.red = xf86_lex_val.num;
            if (xf86getSubToken(&(ptr->disp_comment)) != NUMBER)
                Error(WEIGHT_MSG);
            ptr->disp_weight.green = xf86_lex_val.num;
            if (xf86getSubToken(&(ptr->disp_comment)) != NUMBER)
                Error(WEIGHT_MSG);
            ptr->disp_weight.blue = xf86_lex_val.num;
            break;
        case BLACK_TOK:
            if (xf86getSubToken(&(ptr->disp_comment)) != NUMBER)
                Error(BLACK_MSG);
            ptr->disp_black.red = xf86_lex_val.num;
            if (xf86getSubToken(&(ptr->disp_comment)) != NUMBER)
                Error(BLACK_MSG);
            ptr->disp_black.green = xf86_lex_val.num;
            if (xf86getSubToken(&(ptr->disp_comment)) != NUMBER)
                Error(BLACK_MSG);
            ptr->disp_black.blue = xf86_lex_val.num;
            break;
        case WHITE_TOK:
            if (xf86getSubToken(&(ptr->disp_comment)) != NUMBER)
                Error(WHITE_MSG);
            ptr->disp_white.red = xf86_lex_val.num;
            if (xf86getSubToken(&(ptr->disp_comment)) != NUMBER)
                Error(WHITE_MSG);
            ptr->disp_white.green = xf86_lex_val.num;
            if (xf86getSubToken(&(ptr->disp_comment)) != NUMBER)
                Error(WHITE_MSG);
            ptr->disp_white.blue = xf86_lex_val.num;
            break;
        case MODES:
        {
            XF86ModePtr mptr;

            while ((token =
                    xf86getSubTokenWithTab(&(ptr->disp_comment),
                                           DisplayTab)) == STRING) {
                mptr = calloc(1, sizeof(XF86ModeRec));
                mptr->mode_name = xf86_lex_val.str;
                mptr->list.next = NULL;
                ptr->disp_mode_lst = (XF86ModePtr)
                    xf86addListItem((glp) ptr->disp_mode_lst, (glp) mptr);
            }
            xf86unGetToken(token);
        }
            break;
        case OPTION:
            ptr->disp_option_lst = xf86parseOption(ptr->disp_option_lst);
            break;

        case EOF_TOKEN:
            Error(UNEXPECTED_EOF_MSG);
            break;
        default:
            Error(INVALID_KEYWORD_MSG, xf86tokenString());
            break;
        }
    }

#ifdef DEBUG
    printf("Display subsection parsed\n");
#endif

    return ptr;
}

#undef CLEANUP

static xf86ConfigSymTabRec ScreenTab[] = {
    {ENDSECTION, "endsection"},
    {IDENTIFIER, "identifier"},
    {MATCHSEAT, "matchseat"},
    {OBSDRIVER, "driver"},
    {MDEVICE, "device"},
    {MONITOR, "monitor"},
    {VIDEOADAPTOR, "videoadaptor"},
    {SCREENNO, "screenno"},
    {SUBSECTION, "subsection"},
    {DEFAULTDEPTH, "defaultcolordepth"},
    {DEFAULTDEPTH, "defaultdepth"},
    {DEFAULTBPP, "defaultbpp"},
    {DEFAULTFBBPP, "defaultfbbpp"},
    {VIRTUAL, "virtual"},
    {OPTION, "option"},
    {GDEVICE, "gpudevice"},
    {-1, ""},
};

#define CLEANUP xf86freeScreenList
XF86ConfScreenPtr
xf86parseScreenSection(void)
{
    int has_ident = FALSE;
    int has_driver = FALSE;
    int token;

    parsePrologue(XF86ConfScreenPtr, XF86ConfScreenRec)

        while ((token = xf86getToken(ScreenTab)) != ENDSECTION) {
        switch (token) {
        case COMMENT:
            ptr->scrn_comment = xf86addComment(ptr->scrn_comment, xf86_lex_val.str);
            break;
        case IDENTIFIER:
            if (xf86getSubToken(&(ptr->scrn_comment)) != STRING)
                Error(QUOTE_MSG, "Identifier");
            ptr->scrn_identifier = xf86_lex_val.str;
            if (has_ident || has_driver)
                Error(ONLY_ONE_MSG, "Identifier or Driver");
            has_ident = TRUE;
            break;
        case MATCHSEAT:
            if (xf86getSubToken(&(ptr->scrn_comment)) != STRING)
                Error(QUOTE_MSG, "MatchSeat");
            ptr->match_seat = xf86_lex_val.str;
            break;
        case OBSDRIVER:
            if (xf86getSubToken(&(ptr->scrn_comment)) != STRING)
                Error(QUOTE_MSG, "Driver");
            ptr->scrn_obso_driver = xf86_lex_val.str;
            if (has_ident || has_driver)
                Error(ONLY_ONE_MSG, "Identifier or Driver");
            has_driver = TRUE;
            break;
        case DEFAULTDEPTH:
            if (xf86getSubToken(&(ptr->scrn_comment)) != NUMBER)
                Error(NUMBER_MSG, "DefaultDepth");
            ptr->scrn_defaultdepth = xf86_lex_val.num;
            break;
        case DEFAULTBPP:
            if (xf86getSubToken(&(ptr->scrn_comment)) != NUMBER)
                Error(NUMBER_MSG, "DefaultBPP");
            ptr->scrn_defaultbpp = xf86_lex_val.num;
            break;
        case DEFAULTFBBPP:
            if (xf86getSubToken(&(ptr->scrn_comment)) != NUMBER)
                Error(NUMBER_MSG, "DefaultFbBPP");
            ptr->scrn_defaultfbbpp = xf86_lex_val.num;
            break;
        case MDEVICE:
            if (xf86getSubToken(&(ptr->scrn_comment)) != STRING)
                Error(QUOTE_MSG, "Device");
            ptr->scrn_device_str = xf86_lex_val.str;
            break;
        case GDEVICE:
            if (xf86getSubToken(&(ptr->scrn_comment)) != STRING)
                Error(QUOTE_MSG, "GPUDevice");
            if (ptr->num_gpu_devices == CONF_MAXGPUDEVICES)
                Error(GPU_DEVICE_TOO_MANY, CONF_MAXGPUDEVICES);
            ptr->scrn_gpu_device_str[ptr->num_gpu_devices++] = xf86_lex_val.str;
            break;
        case MONITOR:
            if (xf86getSubToken(&(ptr->scrn_comment)) != STRING)
                Error(QUOTE_MSG, "Monitor");
            ptr->scrn_monitor_str = xf86_lex_val.str;
            break;
        case VIDEOADAPTOR:
        {
            XF86ConfAdaptorLinkPtr aptr;

            if (xf86getSubToken(&(ptr->scrn_comment)) != STRING)
                Error(QUOTE_MSG, "VideoAdaptor");

            /* Don't allow duplicates */
            for (aptr = ptr->scrn_adaptor_lst; aptr;
                 aptr = (XF86ConfAdaptorLinkPtr) aptr->list.next)
                if (xf86nameCompare(xf86_lex_val.str, aptr->al_adaptor_str) == 0)
                    break;

            if (aptr == NULL) {
                aptr = calloc(1, sizeof(XF86ConfAdaptorLinkRec));
                aptr->list.next = NULL;
                aptr->al_adaptor_str = xf86_lex_val.str;
                ptr->scrn_adaptor_lst = (XF86ConfAdaptorLinkPtr)
                    xf86addListItem((glp) ptr->scrn_adaptor_lst, (glp) aptr);
            }
        }
            break;
        case VIRTUAL:
            if (xf86getSubToken(&(ptr->scrn_comment)) != NUMBER)
                Error(VIRTUAL_MSG);
            ptr->scrn_virtualX = xf86_lex_val.num;
            if (xf86getSubToken(&(ptr->scrn_comment)) != NUMBER)
                Error(VIRTUAL_MSG);
            ptr->scrn_virtualY = xf86_lex_val.num;
            break;
        case OPTION:
            ptr->scrn_option_lst = xf86parseOption(ptr->scrn_option_lst);
            break;
        case SUBSECTION:
            if (xf86getSubToken(&(ptr->scrn_comment)) != STRING)
                Error(QUOTE_MSG, "SubSection");
            {
                free(xf86_lex_val.str);
                HANDLE_LIST(scrn_display_lst, xf86parseDisplaySubSection,
                            XF86ConfDisplayPtr);
            }
            break;
        case EOF_TOKEN:
            Error(UNEXPECTED_EOF_MSG);
            break;
        default:
            Error(INVALID_KEYWORD_MSG, xf86tokenString());
            break;
        }
    }

    if (!has_ident && !has_driver)
        Error(NO_IDENT_MSG);

#ifdef DEBUG
    printf("Screen section parsed\n");
#endif

    return ptr;
}

void
xf86printScreenSection(FILE * cf, XF86ConfScreenPtr ptr)
{
    XF86ConfAdaptorLinkPtr aptr;
    XF86ConfDisplayPtr dptr;
    XF86ModePtr mptr;
    int i;
    while (ptr) {
        fprintf(cf, "Section \"Screen\"\n");
        if (ptr->scrn_comment)
            fprintf(cf, "%s", ptr->scrn_comment);
        if (ptr->scrn_identifier)
            fprintf(cf, "\tIdentifier \"%s\"\n", ptr->scrn_identifier);
        if (ptr->scrn_obso_driver)
            fprintf(cf, "\tDriver     \"%s\"\n", ptr->scrn_obso_driver);
        if (ptr->scrn_device_str)
            fprintf(cf, "\tDevice     \"%s\"\n", ptr->scrn_device_str);
        for (i = 0; i < ptr->num_gpu_devices; i++)
            if (ptr->scrn_gpu_device_str[i])
                fprintf(cf, "\tGPUDevice     \"%s\"\n", ptr->scrn_gpu_device_str[i]);
        if (ptr->scrn_monitor_str)
            fprintf(cf, "\tMonitor    \"%s\"\n", ptr->scrn_monitor_str);
        if (ptr->scrn_defaultdepth)
            fprintf(cf, "\tDefaultDepth     %d\n", ptr->scrn_defaultdepth);
        if (ptr->scrn_defaultbpp)
            fprintf(cf, "\tDefaultBPP     %d\n", ptr->scrn_defaultbpp);
        if (ptr->scrn_defaultfbbpp)
            fprintf(cf, "\tDefaultFbBPP     %d\n", ptr->scrn_defaultfbbpp);
        xf86printOptionList(cf, ptr->scrn_option_lst, 1);
        for (aptr = ptr->scrn_adaptor_lst; aptr; aptr = aptr->list.next) {
            fprintf(cf, "\tVideoAdaptor \"%s\"\n", aptr->al_adaptor_str);
        }
        if (ptr->scrn_virtualX && ptr->scrn_virtualY)
            fprintf(cf, "\tVirtual     %d %d\n",
                    ptr->scrn_virtualX, ptr->scrn_virtualY);
        for (dptr = ptr->scrn_display_lst; dptr; dptr = dptr->list.next) {
            fprintf(cf, "\tSubSection \"Display\"\n");
            if (dptr->disp_comment)
                fprintf(cf, "%s", dptr->disp_comment);
            if (dptr->disp_frameX0 >= 0 || dptr->disp_frameY0 >= 0) {
                fprintf(cf, "\t\tViewport   %d %d\n",
                        dptr->disp_frameX0, dptr->disp_frameY0);
            }
            if (dptr->disp_virtualX != 0 || dptr->disp_virtualY != 0) {
                fprintf(cf, "\t\tVirtual   %d %d\n",
                        dptr->disp_virtualX, dptr->disp_virtualY);
            }
            if (dptr->disp_depth) {
                fprintf(cf, "\t\tDepth     %d\n", dptr->disp_depth);
            }
            if (dptr->disp_bpp) {
                fprintf(cf, "\t\tFbBPP     %d\n", dptr->disp_bpp);
            }
            if (dptr->disp_visual) {
                fprintf(cf, "\t\tVisual    \"%s\"\n", dptr->disp_visual);
            }
            if (dptr->disp_weight.red != 0) {
                fprintf(cf, "\t\tWeight    %d %d %d\n",
                        dptr->disp_weight.red, dptr->disp_weight.green,
                        dptr->disp_weight.blue);
            }
            if (dptr->disp_black.red != -1) {
                fprintf(cf, "\t\tBlack     0x%04x 0x%04x 0x%04x\n",
                        dptr->disp_black.red, dptr->disp_black.green,
                        dptr->disp_black.blue);
            }
            if (dptr->disp_white.red != -1) {
                fprintf(cf, "\t\tWhite     0x%04x 0x%04x 0x%04x\n",
                        dptr->disp_white.red, dptr->disp_white.green,
                        dptr->disp_white.blue);
            }
            if (dptr->disp_mode_lst) {
                fprintf(cf, "\t\tModes   ");
            }
            for (mptr = dptr->disp_mode_lst; mptr; mptr = mptr->list.next) {
                fprintf(cf, " \"%s\"", mptr->mode_name);
            }
            if (dptr->disp_mode_lst) {
                fprintf(cf, "\n");
            }
            xf86printOptionList(cf, dptr->disp_option_lst, 2);
            fprintf(cf, "\tEndSubSection\n");
        }
        fprintf(cf, "EndSection\n\n");
        ptr = ptr->list.next;
    }

}

static void
xf86freeAdaptorLinkList(XF86ConfAdaptorLinkPtr ptr)
{
    XF86ConfAdaptorLinkPtr prev;

    while (ptr) {
        TestFree(ptr->al_adaptor_str);
        prev = ptr;
        ptr = ptr->list.next;
        free(prev);
    }
}

void
xf86freeScreenList(XF86ConfScreenPtr ptr)
{
    XF86ConfScreenPtr prev;
    int i;
    while (ptr) {
        TestFree(ptr->scrn_identifier);
        TestFree(ptr->scrn_monitor_str);
        TestFree(ptr->scrn_device_str);
        for (i = 0; i < ptr->num_gpu_devices; i++)
            TestFree(ptr->scrn_gpu_device_str[i]);
        TestFree(ptr->scrn_comment);
        xf86optionListFree(ptr->scrn_option_lst);
        xf86freeAdaptorLinkList(ptr->scrn_adaptor_lst);
        xf86freeDisplayList(ptr->scrn_display_lst);
        prev = ptr;
        ptr = ptr->list.next;
        free(prev);
    }
}

int
xf86validateScreen(XF86ConfigPtr p)
{
    XF86ConfScreenPtr screen = p->conf_screen_lst;
    XF86ConfMonitorPtr monitor;
    XF86ConfAdaptorLinkPtr adaptor;
    int i;

    while (screen) {
        if (screen->scrn_obso_driver && !screen->scrn_identifier)
            screen->scrn_identifier = screen->scrn_obso_driver;

        monitor =
            xf86findMonitor(screen->scrn_monitor_str, p->conf_monitor_lst);
        if (screen->scrn_monitor_str) {
            if (monitor) {
                screen->scrn_monitor = monitor;
                if (!xf86validateMonitor(p, screen))
                    return FALSE;
            }
        }

        screen->scrn_device =
            xf86findDevice(screen->scrn_device_str, p->conf_device_lst);

        for (i = 0; i < screen->num_gpu_devices; i++) {
            screen->scrn_gpu_devices[i] =
                xf86findDevice(screen->scrn_gpu_device_str[i], p->conf_device_lst);
        }
        adaptor = screen->scrn_adaptor_lst;
        while (adaptor) {
            adaptor->al_adaptor =
                xf86findVideoAdaptor(adaptor->al_adaptor_str,
                                     p->conf_videoadaptor_lst);
            if (!adaptor->al_adaptor) {
                xf86validationError(UNDEFINED_ADAPTOR_MSG,
                                    adaptor->al_adaptor_str,
                                    screen->scrn_identifier);
                return FALSE;
            }
            else if (adaptor->al_adaptor->va_fwdref) {
                xf86validationError(ADAPTOR_REF_TWICE_MSG,
                                    adaptor->al_adaptor_str,
                                    adaptor->al_adaptor->va_fwdref);
                return FALSE;
            }

            adaptor->al_adaptor->va_fwdref = strdup(screen->scrn_identifier);
            adaptor = adaptor->list.next;
        }

        screen = screen->list.next;
    }

    return TRUE;
}

XF86ConfScreenPtr
xf86findScreen(const char *ident, XF86ConfScreenPtr p)
{
    while (p) {
        if (xf86nameCompare(ident, p->scrn_identifier) == 0)
            return p;

        p = p->list.next;
    }
    return NULL;
}
@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d79 27
d241 1
d301 7
d380 1
a380 1

d391 3
d463 1
a463 20
void
xf86freeScreenList(XF86ConfScreenPtr ptr)
{
    XF86ConfScreenPtr prev;

    while (ptr) {
        TestFree(ptr->scrn_identifier);
        TestFree(ptr->scrn_monitor_str);
        TestFree(ptr->scrn_device_str);
        TestFree(ptr->scrn_comment);
        xf86optionListFree(ptr->scrn_option_lst);
        xf86freeAdaptorLinkList(ptr->scrn_adaptor_lst);
        xf86freeDisplayList(ptr->scrn_display_lst);
        prev = ptr;
        ptr = ptr->list.next;
        free(prev);
    }
}

void
d477 1
a477 1
xf86freeDisplayList(XF86ConfDisplayPtr ptr)
d479 2
a480 2
    XF86ConfDisplayPtr prev;

d482 9
a490 15
        xf86freeModeList(ptr->disp_mode_lst);
        xf86optionListFree(ptr->disp_option_lst);
        prev = ptr;
        ptr = ptr->list.next;
        free(prev);
    }
}

void
xf86freeModeList(XF86ModePtr ptr)
{
    XF86ModePtr prev;

    while (ptr) {
        TestFree(ptr->mode_name);
d503 1
d522 4
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1 2
a2 2
/* 
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * copy of this software and associated documentation files (the "Software"), 
d11 1
a11 1
 * 
d14 1
a14 1
 * 
d22 1
a22 1
 * 
d26 1
a26 1
 * 
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a62 1
extern LexRec val;
d94 1
a94 1
            ptr->disp_comment = xf86addComment(ptr->disp_comment, val.str);
d99 1
a99 1
            ptr->disp_frameX0 = val.num;
d102 1
a102 1
            ptr->disp_frameY0 = val.num;
d107 1
a107 1
            ptr->disp_virtualX = val.num;
d110 1
a110 1
            ptr->disp_virtualY = val.num;
d115 1
a115 1
            ptr->disp_depth = val.num;
d120 1
a120 1
            ptr->disp_bpp = val.num;
d125 1
a125 1
            ptr->disp_visual = val.str;
d130 1
a130 1
            ptr->disp_weight.red = val.num;
d133 1
a133 1
            ptr->disp_weight.green = val.num;
d136 1
a136 1
            ptr->disp_weight.blue = val.num;
d141 1
a141 1
            ptr->disp_black.red = val.num;
d144 1
a144 1
            ptr->disp_black.green = val.num;
d147 1
a147 1
            ptr->disp_black.blue = val.num;
d152 1
a152 1
            ptr->disp_white.red = val.num;
d155 1
a155 1
            ptr->disp_white.green = val.num;
d158 1
a158 1
            ptr->disp_white.blue = val.num;
d168 1
a168 1
                mptr->mode_name = val.str;
d201 1
d230 1
a230 1
            ptr->scrn_comment = xf86addComment(ptr->scrn_comment, val.str);
d235 1
a235 1
            ptr->scrn_identifier = val.str;
d240 5
d248 1
a248 1
            ptr->scrn_obso_driver = val.str;
d256 1
a256 1
            ptr->scrn_defaultdepth = val.num;
d261 1
a261 1
            ptr->scrn_defaultbpp = val.num;
d266 1
a266 1
            ptr->scrn_defaultfbbpp = val.num;
d271 1
a271 1
            ptr->scrn_device_str = val.str;
d276 1
a276 1
            ptr->scrn_monitor_str = val.str;
d288 1
a288 1
                if (xf86nameCompare(val.str, aptr->al_adaptor_str) == 0)
d294 1
a294 1
                aptr->al_adaptor_str = val.str;
d303 1
a303 1
            ptr->scrn_virtualX = val.num;
d306 1
a306 1
            ptr->scrn_virtualY = val.num;
d315 1
a315 1
                free(val.str);
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a54 2
/* View/edit this file with tab stops set to 4 */

@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a54 1

d67 13
a79 14
static xf86ConfigSymTabRec DisplayTab[] =
{
	{ENDSUBSECTION, "endsubsection"},
	{MODES, "modes"},
	{VIEWPORT, "viewport"},
	{VIRTUAL, "virtual"},
	{VISUAL, "visual"},
	{BLACK_TOK, "black"},
	{WHITE_TOK, "white"},
	{DEPTH, "depth"},
	{BPP, "fbbpp"},
	{WEIGHT, "weight"},
	{OPTION, "option"},
	{-1, ""},
d85 1
a85 1
xf86parseDisplaySubSection (void)
d87 3
a89 2
	int token;
	parsePrologue (XF86ConfDisplayPtr, XF86ConfDisplayRec)
d91 100
a190 101
	ptr->disp_black.red = ptr->disp_black.green = ptr->disp_black.blue = -1;
	ptr->disp_white.red = ptr->disp_white.green = ptr->disp_white.blue = -1;
	ptr->disp_frameX0 = ptr->disp_frameY0 = -1;
	while ((token = xf86getToken (DisplayTab)) != ENDSUBSECTION)
	{
		switch (token)
		{
		case COMMENT:
			ptr->disp_comment = xf86addComment(ptr->disp_comment, val.str);
			break;
		case VIEWPORT:
			if (xf86getSubToken (&(ptr->disp_comment)) != NUMBER)
				Error (VIEWPORT_MSG, NULL);
			ptr->disp_frameX0 = val.num;
			if (xf86getSubToken (&(ptr->disp_comment)) != NUMBER)
				Error (VIEWPORT_MSG, NULL);
			ptr->disp_frameY0 = val.num;
			break;
		case VIRTUAL:
			if (xf86getSubToken (&(ptr->disp_comment)) != NUMBER)
				Error (VIRTUAL_MSG, NULL);
			ptr->disp_virtualX = val.num;
			if (xf86getSubToken (&(ptr->disp_comment)) != NUMBER)
				Error (VIRTUAL_MSG, NULL);
			ptr->disp_virtualY = val.num;
			break;
		case DEPTH:
			if (xf86getSubToken (&(ptr->disp_comment)) != NUMBER)
				Error (NUMBER_MSG, "Display");
			ptr->disp_depth = val.num;
			break;
		case BPP:
			if (xf86getSubToken (&(ptr->disp_comment)) != NUMBER)
				Error (NUMBER_MSG, "Display");
			ptr->disp_bpp = val.num;
			break;
		case VISUAL:
			if (xf86getSubToken (&(ptr->disp_comment)) != STRING)
				Error (QUOTE_MSG, "Display");
			ptr->disp_visual = val.str;
			break;
		case WEIGHT:
			if (xf86getSubToken (&(ptr->disp_comment)) != NUMBER)
				Error (WEIGHT_MSG, NULL);
			ptr->disp_weight.red = val.num;
			if (xf86getSubToken (&(ptr->disp_comment)) != NUMBER)
				Error (WEIGHT_MSG, NULL);
			ptr->disp_weight.green = val.num;
			if (xf86getSubToken (&(ptr->disp_comment)) != NUMBER)
				Error (WEIGHT_MSG, NULL);
			ptr->disp_weight.blue = val.num;
			break;
		case BLACK_TOK:
			if (xf86getSubToken (&(ptr->disp_comment)) != NUMBER)
				Error (BLACK_MSG, NULL);
			ptr->disp_black.red = val.num;
			if (xf86getSubToken (&(ptr->disp_comment)) != NUMBER)
				Error (BLACK_MSG, NULL);
			ptr->disp_black.green = val.num;
			if (xf86getSubToken (&(ptr->disp_comment)) != NUMBER)
				Error (BLACK_MSG, NULL);
			ptr->disp_black.blue = val.num;
			break;
		case WHITE_TOK:
			if (xf86getSubToken (&(ptr->disp_comment)) != NUMBER)
				Error (WHITE_MSG, NULL);
			ptr->disp_white.red = val.num;
			if (xf86getSubToken (&(ptr->disp_comment)) != NUMBER)
				Error (WHITE_MSG, NULL);
			ptr->disp_white.green = val.num;
			if (xf86getSubToken (&(ptr->disp_comment)) != NUMBER)
				Error (WHITE_MSG, NULL);
			ptr->disp_white.blue = val.num;
			break;
		case MODES:
			{
				XF86ModePtr mptr;

				while ((token = xf86getSubTokenWithTab (&(ptr->disp_comment), DisplayTab)) == STRING)
				{
					mptr = calloc (1, sizeof (XF86ModeRec));
					mptr->mode_name = val.str;
					mptr->list.next = NULL;
					ptr->disp_mode_lst = (XF86ModePtr)
						xf86addListItem ((glp) ptr->disp_mode_lst, (glp) mptr);
				}
				xf86unGetToken (token);
			}
			break;
		case OPTION:
			ptr->disp_option_lst = xf86parseOption(ptr->disp_option_lst);
			break;
			
		case EOF_TOKEN:
			Error (UNEXPECTED_EOF_MSG, NULL);
			break;
		default:
			Error (INVALID_KEYWORD_MSG, xf86tokenString ());
			break;
		}
	}
d193 1
a193 1
	printf ("Display subsection parsed\n");
d196 1
a196 1
	return ptr;
d201 16
a216 17
static xf86ConfigSymTabRec ScreenTab[] =
{
	{ENDSECTION, "endsection"},
	{IDENTIFIER, "identifier"},
	{OBSDRIVER, "driver"},
	{MDEVICE, "device"},
	{MONITOR, "monitor"},
	{VIDEOADAPTOR, "videoadaptor"},
	{SCREENNO, "screenno"},
	{SUBSECTION, "subsection"},
	{DEFAULTDEPTH, "defaultcolordepth"},
	{DEFAULTDEPTH, "defaultdepth"},
	{DEFAULTBPP, "defaultbpp"},
	{DEFAULTFBBPP, "defaultfbbpp"},
	{VIRTUAL, "virtual"},
	{OPTION, "option"},
	{-1, ""},
d221 1
a221 1
xf86parseScreenSection (void)
d223 102
a324 105
	int has_ident = FALSE;
	int has_driver= FALSE;
	int token;

	parsePrologue (XF86ConfScreenPtr, XF86ConfScreenRec)

		while ((token = xf86getToken (ScreenTab)) != ENDSECTION)
	{
		switch (token)
		{
		case COMMENT:
			ptr->scrn_comment = xf86addComment(ptr->scrn_comment, val.str);
			break;
		case IDENTIFIER:
			if (xf86getSubToken (&(ptr->scrn_comment)) != STRING)
				Error (QUOTE_MSG, "Identifier");
			ptr->scrn_identifier = val.str;
			if (has_ident || has_driver)
				Error (ONLY_ONE_MSG,"Identifier or Driver");
			has_ident = TRUE;
			break;
		case OBSDRIVER:
			if (xf86getSubToken (&(ptr->scrn_comment)) != STRING)
				Error (QUOTE_MSG, "Driver");
			ptr->scrn_obso_driver = val.str;
			if (has_ident || has_driver)
				Error (ONLY_ONE_MSG,"Identifier or Driver");
			has_driver = TRUE;
			break;
		case DEFAULTDEPTH:
			if (xf86getSubToken (&(ptr->scrn_comment)) != NUMBER)
				Error (NUMBER_MSG, "DefaultDepth");
			ptr->scrn_defaultdepth = val.num;
			break;
		case DEFAULTBPP:
			if (xf86getSubToken (&(ptr->scrn_comment)) != NUMBER)
				Error (NUMBER_MSG, "DefaultBPP");
			ptr->scrn_defaultbpp = val.num;
			break;
		case DEFAULTFBBPP:
			if (xf86getSubToken (&(ptr->scrn_comment)) != NUMBER)
				Error (NUMBER_MSG, "DefaultFbBPP");
			ptr->scrn_defaultfbbpp = val.num;
			break;
		case MDEVICE:
			if (xf86getSubToken (&(ptr->scrn_comment)) != STRING)
				Error (QUOTE_MSG, "Device");
			ptr->scrn_device_str = val.str;
			break;
		case MONITOR:
			if (xf86getSubToken (&(ptr->scrn_comment)) != STRING)
				Error (QUOTE_MSG, "Monitor");
			ptr->scrn_monitor_str = val.str;
			break;
		case VIDEOADAPTOR:
			{
				XF86ConfAdaptorLinkPtr aptr;

				if (xf86getSubToken (&(ptr->scrn_comment)) != STRING)
					Error (QUOTE_MSG, "VideoAdaptor");

				/* Don't allow duplicates */
				for (aptr = ptr->scrn_adaptor_lst; aptr; 
					aptr = (XF86ConfAdaptorLinkPtr) aptr->list.next)
					if (xf86nameCompare (val.str, aptr->al_adaptor_str) == 0)
						break;

				if (aptr == NULL)
				{
					aptr = calloc (1, sizeof (XF86ConfAdaptorLinkRec));
					aptr->list.next = NULL;
					aptr->al_adaptor_str = val.str;
					ptr->scrn_adaptor_lst = (XF86ConfAdaptorLinkPtr)
						xf86addListItem ((glp) ptr->scrn_adaptor_lst, (glp) aptr);
				}
			}
			break;
		case VIRTUAL:
			if (xf86getSubToken (&(ptr->scrn_comment)) != NUMBER)
				Error (VIRTUAL_MSG, NULL);
			ptr->scrn_virtualX = val.num;
			if (xf86getSubToken (&(ptr->scrn_comment)) != NUMBER)
				Error (VIRTUAL_MSG, NULL);
			ptr->scrn_virtualY = val.num;
			break;
		case OPTION:
			ptr->scrn_option_lst = xf86parseOption(ptr->scrn_option_lst);
			break;
		case SUBSECTION:
			if (xf86getSubToken (&(ptr->scrn_comment)) != STRING)
				Error (QUOTE_MSG, "SubSection");
			{
				free(val.str);
				HANDLE_LIST (scrn_display_lst, xf86parseDisplaySubSection,
							 XF86ConfDisplayPtr);
			}
			break;
		case EOF_TOKEN:
			Error (UNEXPECTED_EOF_MSG, NULL);
			break;
		default:
			Error (INVALID_KEYWORD_MSG, xf86tokenString ());
			break;
		}
	}
d326 2
a327 2
	if (!has_ident && !has_driver)
		Error (NO_IDENT_MSG, NULL);
d330 1
a330 1
	printf ("Screen section parsed\n");
d333 1
a333 1
	return ptr;
d337 1
a337 1
xf86printScreenSection (FILE * cf, XF86ConfScreenPtr ptr)
d339 80
a418 95
	XF86ConfAdaptorLinkPtr aptr;
	XF86ConfDisplayPtr dptr;
	XF86ModePtr mptr;

	while (ptr)
	{
		fprintf (cf, "Section \"Screen\"\n");
		if (ptr->scrn_comment)
			fprintf (cf, "%s", ptr->scrn_comment);
		if (ptr->scrn_identifier)
			fprintf (cf, "\tIdentifier \"%s\"\n", ptr->scrn_identifier);
		if (ptr->scrn_obso_driver)
			fprintf (cf, "\tDriver     \"%s\"\n", ptr->scrn_obso_driver);
		if (ptr->scrn_device_str)
			fprintf (cf, "\tDevice     \"%s\"\n", ptr->scrn_device_str);
		if (ptr->scrn_monitor_str)
			fprintf (cf, "\tMonitor    \"%s\"\n", ptr->scrn_monitor_str);
		if (ptr->scrn_defaultdepth)
			fprintf (cf, "\tDefaultDepth     %d\n",
					 ptr->scrn_defaultdepth);
		if (ptr->scrn_defaultbpp)
			fprintf (cf, "\tDefaultBPP     %d\n",
					 ptr->scrn_defaultbpp);
		if (ptr->scrn_defaultfbbpp)
			fprintf (cf, "\tDefaultFbBPP     %d\n",
					 ptr->scrn_defaultfbbpp);
		xf86printOptionList(cf, ptr->scrn_option_lst, 1);
		for (aptr = ptr->scrn_adaptor_lst; aptr; aptr = aptr->list.next)
		{
			fprintf (cf, "\tVideoAdaptor \"%s\"\n", aptr->al_adaptor_str);
		}
		if (ptr->scrn_virtualX && ptr->scrn_virtualY)
			fprintf (cf, "\tVirtual     %d %d\n",
				 ptr->scrn_virtualX,
				 ptr->scrn_virtualY);
		for (dptr = ptr->scrn_display_lst; dptr; dptr = dptr->list.next)
		{
			fprintf (cf, "\tSubSection \"Display\"\n");
			if (dptr->disp_comment)
				fprintf (cf, "%s", dptr->disp_comment);
			if (dptr->disp_frameX0 >= 0 || dptr->disp_frameY0 >= 0)
			{
				fprintf (cf, "\t\tViewport   %d %d\n",
						 dptr->disp_frameX0, dptr->disp_frameY0);
			}
			if (dptr->disp_virtualX != 0 || dptr->disp_virtualY != 0)
			{
				fprintf (cf, "\t\tVirtual   %d %d\n",
						 dptr->disp_virtualX, dptr->disp_virtualY);
			}
			if (dptr->disp_depth)
			{
				fprintf (cf, "\t\tDepth     %d\n", dptr->disp_depth);
			}
			if (dptr->disp_bpp)
			{
				fprintf (cf, "\t\tFbBPP     %d\n", dptr->disp_bpp);
			}
			if (dptr->disp_visual)
			{
				fprintf (cf, "\t\tVisual    \"%s\"\n", dptr->disp_visual);
			}
			if (dptr->disp_weight.red != 0)
			{
				fprintf (cf, "\t\tWeight    %d %d %d\n",
					 dptr->disp_weight.red, dptr->disp_weight.green, dptr->disp_weight.blue);
			}
			if (dptr->disp_black.red != -1)
			{
				fprintf (cf, "\t\tBlack     0x%04x 0x%04x 0x%04x\n",
					  dptr->disp_black.red, dptr->disp_black.green, dptr->disp_black.blue);
			}
			if (dptr->disp_white.red != -1)
			{
				fprintf (cf, "\t\tWhite     0x%04x 0x%04x 0x%04x\n",
					  dptr->disp_white.red, dptr->disp_white.green, dptr->disp_white.blue);
			}
			if (dptr->disp_mode_lst)
			{
				fprintf (cf, "\t\tModes   ");
			}
			for (mptr = dptr->disp_mode_lst; mptr; mptr = mptr->list.next)
			{
				fprintf (cf, " \"%s\"", mptr->mode_name);
			}
			if (dptr->disp_mode_lst)
			{
				fprintf (cf, "\n");
			}
			xf86printOptionList(cf, dptr->disp_option_lst, 2);
			fprintf (cf, "\tEndSubSection\n");
		}
		fprintf (cf, "EndSection\n\n");
		ptr = ptr->list.next;
	}
d423 1
a423 1
xf86freeScreenList (XF86ConfScreenPtr ptr)
d425 1
a425 1
	XF86ConfScreenPtr prev;
d427 12
a438 13
	while (ptr)
	{
		TestFree (ptr->scrn_identifier);
		TestFree (ptr->scrn_monitor_str);
		TestFree (ptr->scrn_device_str);
		TestFree (ptr->scrn_comment);
		xf86optionListFree (ptr->scrn_option_lst);
		xf86freeAdaptorLinkList (ptr->scrn_adaptor_lst);
		xf86freeDisplayList (ptr->scrn_display_lst);
		prev = ptr;
		ptr = ptr->list.next;
		free (prev);
	}
d442 1
a442 1
xf86freeAdaptorLinkList (XF86ConfAdaptorLinkPtr ptr)
d444 1
a444 1
	XF86ConfAdaptorLinkPtr prev;
d446 6
a451 7
	while (ptr)
	{
		TestFree (ptr->al_adaptor_str);
		prev = ptr;
		ptr = ptr->list.next;
		free (prev);
	}
d455 1
a455 1
xf86freeDisplayList (XF86ConfDisplayPtr ptr)
d457 1
a457 1
	XF86ConfDisplayPtr prev;
d459 7
a465 8
	while (ptr)
	{
		xf86freeModeList (ptr->disp_mode_lst);
		xf86optionListFree (ptr->disp_option_lst);
		prev = ptr;
		ptr = ptr->list.next;
		free (prev);
	}
d469 1
a469 1
xf86freeModeList (XF86ModePtr ptr)
d471 1
a471 1
	XF86ModePtr prev;
d473 6
a478 7
	while (ptr)
	{
		TestFree (ptr->mode_name);
		prev = ptr;
		ptr = ptr->list.next;
		free (prev);
	}
d482 1
a482 1
xf86validateScreen (XF86ConfigPtr p)
d484 42
a525 41
	XF86ConfScreenPtr screen = p->conf_screen_lst;
	XF86ConfMonitorPtr monitor;
	XF86ConfAdaptorLinkPtr adaptor;

	while (screen)
	{
		if (screen->scrn_obso_driver && !screen->scrn_identifier)
			screen->scrn_identifier = screen->scrn_obso_driver;

		monitor = xf86findMonitor (screen->scrn_monitor_str, p->conf_monitor_lst);
		if (screen->scrn_monitor_str)
		{
			if (monitor)
			{
				screen->scrn_monitor = monitor;
				if (!xf86validateMonitor(p, screen))
					return FALSE;
			}
		}

		screen->scrn_device= xf86findDevice (screen->scrn_device_str, p->conf_device_lst);

		adaptor = screen->scrn_adaptor_lst;
		while (adaptor)
		{
			adaptor->al_adaptor = xf86findVideoAdaptor (adaptor->al_adaptor_str, p->conf_videoadaptor_lst);
			if (!adaptor->al_adaptor)
			{
				xf86validationError (UNDEFINED_ADAPTOR_MSG, adaptor->al_adaptor_str, screen->scrn_identifier);
				return FALSE;
			}
			else if (adaptor->al_adaptor->va_fwdref)
			{
				xf86validationError (ADAPTOR_REF_TWICE_MSG, adaptor->al_adaptor_str,
						     adaptor->al_adaptor->va_fwdref);
				return FALSE;
			}

			adaptor->al_adaptor->va_fwdref = strdup(screen->scrn_identifier);
			adaptor = adaptor->list.next;
		}
d527 2
a528 2
		screen = screen->list.next;
	}
d530 1
a530 1
	return TRUE;
d534 1
a534 1
xf86findScreen (const char *ident, XF86ConfScreenPtr p)
d536 7
a542 8
	while (p)
	{
		if (xf86nameCompare (ident, p->scrn_identifier) == 0)
			return p;

		p = p->list.next;
	}
	return NULL;
a543 1

@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d525 1
a525 1
					return (FALSE);
d538 1
a538 1
				return (FALSE);
d544 1
a544 1
				return (FALSE);
d554 1
a554 1
	return (TRUE);
d563 1
a563 1
			return (p);
d567 1
a567 1
	return (NULL);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d172 1
a172 1
					mptr = xf86confcalloc (1, sizeof (XF86ModeRec));
d295 1
a295 1
					aptr = xf86confcalloc (1, sizeof (XF86ConfAdaptorLinkRec));
d318 1
a318 1
				xf86conffree(val.str);
d459 1
a459 1
		xf86conffree (prev);
d473 1
a473 1
		xf86conffree (prev);
d488 1
a488 1
		xf86conffree (prev);
d502 1
a502 1
		xf86conffree (prev);
d547 1
a547 1
			adaptor->al_adaptor->va_fwdref = xf86configStrdup(screen->scrn_identifier);
@


1.1
log
@Initial revision
@
text
@d86 1
a86 1
XF86ConfDisplayPtr
d217 1
d303 8
d376 4
a510 1
	XF86ConfDevicePtr device;
a512 6
	if (!screen)
	{
		xf86validationError ("At least one Screen section is required.");
		return (FALSE);
	}

d521 1
a521 7
			if (!monitor)
			{
				xf86validationError (UNDEFINED_MONITOR_MSG,
						 	screen->scrn_monitor_str, screen->scrn_identifier);
				return (FALSE);
			}
			else
d529 1
a529 9
		device = xf86findDevice (screen->scrn_device_str, p->conf_device_lst);
		if (!device)
		{
			xf86validationError (UNDEFINED_DEVICE_MSG,
						  screen->scrn_device_str, screen->scrn_identifier);
			return (FALSE);
		}
		else
			screen->scrn_device = device;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d86 1
a86 1
static XF86ConfDisplayPtr
@

