head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.20.56;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.20.56;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.58.13;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *
 * Copyright (c) 1997  Metro Link Incorporated
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of the Metro Link shall not be
 * used in advertising or otherwise to promote the sale, use or other dealings
 * in this Software without prior written authorization from Metro Link.
 *
 */
/*
 * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "xf86Parser.h"
#include "xf86tokens.h"
#include "Configint.h"


static xf86ConfigSymTabRec MonitorTab[] = {
    {ENDSECTION, "endsection"},
    {IDENTIFIER, "identifier"},
    {VENDOR, "vendorname"},
    {MODEL, "modelname"},
    {USEMODES, "usemodes"},
    {MODELINE, "modeline"},
    {DISPLAYSIZE, "displaysize"},
    {HORIZSYNC, "horizsync"},
    {VERTREFRESH, "vertrefresh"},
    {MODE, "mode"},
    {GAMMA, "gamma"},
    {OPTION, "option"},
    {-1, ""},
};

static xf86ConfigSymTabRec ModesTab[] = {
    {ENDSECTION, "endsection"},
    {IDENTIFIER, "identifier"},
    {MODELINE, "modeline"},
    {MODE, "mode"},
    {-1, ""},
};

static xf86ConfigSymTabRec TimingTab[] = {
    {TT_INTERLACE, "interlace"},
    {TT_PHSYNC, "+hsync"},
    {TT_NHSYNC, "-hsync"},
    {TT_PVSYNC, "+vsync"},
    {TT_NVSYNC, "-vsync"},
    {TT_CSYNC, "composite"},
    {TT_PCSYNC, "+csync"},
    {TT_NCSYNC, "-csync"},
    {TT_DBLSCAN, "doublescan"},
    {TT_HSKEW, "hskew"},
    {TT_BCAST, "bcast"},
    {TT_VSCAN, "vscan"},
    {-1, ""},
};

static xf86ConfigSymTabRec ModeTab[] = {
    {DOTCLOCK, "dotclock"},
    {HTIMINGS, "htimings"},
    {VTIMINGS, "vtimings"},
    {FLAGS, "flags"},
    {HSKEW, "hskew"},
    {BCAST, "bcast"},
    {VSCAN, "vscan"},
    {ENDMODE, "endmode"},
    {-1, ""},
};

#define CLEANUP xf86freeModeLineList

static void
xf86freeModeLineList(XF86ConfModeLinePtr ptr)
{
    XF86ConfModeLinePtr prev;

    while (ptr) {
        TestFree(ptr->ml_identifier);
        TestFree(ptr->ml_comment);
        prev = ptr;
        ptr = ptr->list.next;
        free(prev);
    }
}

static XF86ConfModeLinePtr
xf86parseModeLine(void)
{
    int token;

    parsePrologue(XF86ConfModeLinePtr, XF86ConfModeLineRec)

        /* Identifier */
        if (xf86getSubToken(&(ptr->ml_comment)) != STRING)
        Error("ModeLine identifier expected");
    ptr->ml_identifier = xf86_lex_val.str;

    /* DotClock */
    if (xf86getSubToken(&(ptr->ml_comment)) != NUMBER)
        Error("ModeLine dotclock expected");
    ptr->ml_clock = (int) (xf86_lex_val.realnum * 1000.0 + 0.5);

    /* HDisplay */
    if (xf86getSubToken(&(ptr->ml_comment)) != NUMBER)
        Error("ModeLine Hdisplay expected");
    ptr->ml_hdisplay = xf86_lex_val.num;

    /* HSyncStart */
    if (xf86getSubToken(&(ptr->ml_comment)) != NUMBER)
        Error("ModeLine HSyncStart expected");
    ptr->ml_hsyncstart = xf86_lex_val.num;

    /* HSyncEnd */
    if (xf86getSubToken(&(ptr->ml_comment)) != NUMBER)
        Error("ModeLine HSyncEnd expected");
    ptr->ml_hsyncend = xf86_lex_val.num;

    /* HTotal */
    if (xf86getSubToken(&(ptr->ml_comment)) != NUMBER)
        Error("ModeLine HTotal expected");
    ptr->ml_htotal = xf86_lex_val.num;

    /* VDisplay */
    if (xf86getSubToken(&(ptr->ml_comment)) != NUMBER)
        Error("ModeLine Vdisplay expected");
    ptr->ml_vdisplay = xf86_lex_val.num;

    /* VSyncStart */
    if (xf86getSubToken(&(ptr->ml_comment)) != NUMBER)
        Error("ModeLine VSyncStart expected");
    ptr->ml_vsyncstart = xf86_lex_val.num;

    /* VSyncEnd */
    if (xf86getSubToken(&(ptr->ml_comment)) != NUMBER)
        Error("ModeLine VSyncEnd expected");
    ptr->ml_vsyncend = xf86_lex_val.num;

    /* VTotal */
    if (xf86getSubToken(&(ptr->ml_comment)) != NUMBER)
        Error("ModeLine VTotal expected");
    ptr->ml_vtotal = xf86_lex_val.num;

    token = xf86getSubTokenWithTab(&(ptr->ml_comment), TimingTab);
    while ((token == TT_INTERLACE) || (token == TT_PHSYNC) ||
           (token == TT_NHSYNC) || (token == TT_PVSYNC) ||
           (token == TT_NVSYNC) || (token == TT_CSYNC) ||
           (token == TT_PCSYNC) || (token == TT_NCSYNC) ||
           (token == TT_DBLSCAN) || (token == TT_HSKEW) ||
           (token == TT_VSCAN) || (token == TT_BCAST)) {
        switch (token) {

        case TT_INTERLACE:
            ptr->ml_flags |= XF86CONF_INTERLACE;
            break;
        case TT_PHSYNC:
            ptr->ml_flags |= XF86CONF_PHSYNC;
            break;
        case TT_NHSYNC:
            ptr->ml_flags |= XF86CONF_NHSYNC;
            break;
        case TT_PVSYNC:
            ptr->ml_flags |= XF86CONF_PVSYNC;
            break;
        case TT_NVSYNC:
            ptr->ml_flags |= XF86CONF_NVSYNC;
            break;
        case TT_CSYNC:
            ptr->ml_flags |= XF86CONF_CSYNC;
            break;
        case TT_PCSYNC:
            ptr->ml_flags |= XF86CONF_PCSYNC;
            break;
        case TT_NCSYNC:
            ptr->ml_flags |= XF86CONF_NCSYNC;
            break;
        case TT_DBLSCAN:
            ptr->ml_flags |= XF86CONF_DBLSCAN;
            break;
        case TT_HSKEW:
            if (xf86getSubToken(&(ptr->ml_comment)) != NUMBER)
                Error(NUMBER_MSG, "Hskew");
            ptr->ml_hskew = xf86_lex_val.num;
            ptr->ml_flags |= XF86CONF_HSKEW;
            break;
        case TT_BCAST:
            ptr->ml_flags |= XF86CONF_BCAST;
            break;
        case TT_VSCAN:
            if (xf86getSubToken(&(ptr->ml_comment)) != NUMBER)
                Error(NUMBER_MSG, "Vscan");
            ptr->ml_vscan = xf86_lex_val.num;
            ptr->ml_flags |= XF86CONF_VSCAN;
            break;
        case EOF_TOKEN:
            Error(UNEXPECTED_EOF_MSG);
            break;
        default:
            Error(INVALID_KEYWORD_MSG, xf86tokenString());
            break;
        }
        token = xf86getSubTokenWithTab(&(ptr->ml_comment), TimingTab);
    }
    xf86unGetToken(token);

#ifdef DEBUG
    printf("ModeLine parsed\n");
#endif
    return ptr;
}

static XF86ConfModeLinePtr
xf86parseVerboseMode(void)
{
    int token, token2;
    int had_dotclock = 0, had_htimings = 0, had_vtimings = 0;

    parsePrologue(XF86ConfModeLinePtr, XF86ConfModeLineRec)

        if (xf86getSubToken(&(ptr->ml_comment)) != STRING)
        Error("Mode name expected");
    ptr->ml_identifier = xf86_lex_val.str;
    while ((token = xf86getToken(ModeTab)) != ENDMODE) {
        switch (token) {
        case COMMENT:
            ptr->ml_comment = xf86addComment(ptr->ml_comment, xf86_lex_val.str);
            break;
        case DOTCLOCK:
            if ((token = xf86getSubToken(&(ptr->ml_comment))) != NUMBER)
                Error(NUMBER_MSG, "DotClock");
            ptr->ml_clock = (int) (xf86_lex_val.realnum * 1000.0 + 0.5);
            had_dotclock = 1;
            break;
        case HTIMINGS:
            if (xf86getSubToken(&(ptr->ml_comment)) == NUMBER)
                ptr->ml_hdisplay = xf86_lex_val.num;
            else
                Error("Horizontal display expected");

            if (xf86getSubToken(&(ptr->ml_comment)) == NUMBER)
                ptr->ml_hsyncstart = xf86_lex_val.num;
            else
                Error("Horizontal sync start expected");

            if (xf86getSubToken(&(ptr->ml_comment)) == NUMBER)
                ptr->ml_hsyncend = xf86_lex_val.num;
            else
                Error("Horizontal sync end expected");

            if (xf86getSubToken(&(ptr->ml_comment)) == NUMBER)
                ptr->ml_htotal = xf86_lex_val.num;
            else
                Error("Horizontal total expected");
            had_htimings = 1;
            break;
        case VTIMINGS:
            if (xf86getSubToken(&(ptr->ml_comment)) == NUMBER)
                ptr->ml_vdisplay = xf86_lex_val.num;
            else
                Error("Vertical display expected");

            if (xf86getSubToken(&(ptr->ml_comment)) == NUMBER)
                ptr->ml_vsyncstart = xf86_lex_val.num;
            else
                Error("Vertical sync start expected");

            if (xf86getSubToken(&(ptr->ml_comment)) == NUMBER)
                ptr->ml_vsyncend = xf86_lex_val.num;
            else
                Error("Vertical sync end expected");

            if (xf86getSubToken(&(ptr->ml_comment)) == NUMBER)
                ptr->ml_vtotal = xf86_lex_val.num;
            else
                Error("Vertical total expected");
            had_vtimings = 1;
            break;
        case FLAGS:
            token = xf86getSubToken(&(ptr->ml_comment));
            if (token != STRING)
                Error(QUOTE_MSG, "Flags");
            while (token == STRING) {
                token2 = xf86getStringToken(TimingTab);
                switch (token2) {
                case TT_INTERLACE:
                    ptr->ml_flags |= XF86CONF_INTERLACE;
                    break;
                case TT_PHSYNC:
                    ptr->ml_flags |= XF86CONF_PHSYNC;
                    break;
                case TT_NHSYNC:
                    ptr->ml_flags |= XF86CONF_NHSYNC;
                    break;
                case TT_PVSYNC:
                    ptr->ml_flags |= XF86CONF_PVSYNC;
                    break;
                case TT_NVSYNC:
                    ptr->ml_flags |= XF86CONF_NVSYNC;
                    break;
                case TT_CSYNC:
                    ptr->ml_flags |= XF86CONF_CSYNC;
                    break;
                case TT_PCSYNC:
                    ptr->ml_flags |= XF86CONF_PCSYNC;
                    break;
                case TT_NCSYNC:
                    ptr->ml_flags |= XF86CONF_NCSYNC;
                    break;
                case TT_DBLSCAN:
                    ptr->ml_flags |= XF86CONF_DBLSCAN;
                    break;
                case EOF_TOKEN:
                    Error(UNEXPECTED_EOF_MSG);
                    break;
                default:
                    Error("Unknown flag string");
                    break;
                }
                token = xf86getSubToken(&(ptr->ml_comment));
            }
            xf86unGetToken(token);
            break;
        case HSKEW:
            if (xf86getSubToken(&(ptr->ml_comment)) != NUMBER)
                Error("Horizontal skew expected");
            ptr->ml_flags |= XF86CONF_HSKEW;
            ptr->ml_hskew = xf86_lex_val.num;
            break;
        case VSCAN:
            if (xf86getSubToken(&(ptr->ml_comment)) != NUMBER)
                Error("Vertical scan count expected");
            ptr->ml_flags |= XF86CONF_VSCAN;
            ptr->ml_vscan = xf86_lex_val.num;
            break;
        case EOF_TOKEN:
            Error(UNEXPECTED_EOF_MSG);
            break;
        default:
            Error("Unexepcted token in verbose \"Mode\" entry\n");
        }
    }
    if (!had_dotclock)
        Error("the dotclock is missing");
    if (!had_htimings)
        Error("the horizontal timings are missing");
    if (!had_vtimings)
        Error("the vertical timings are missing");

#ifdef DEBUG
    printf("Verbose Mode parsed\n");
#endif
    return ptr;
}

#undef CLEANUP

#define CLEANUP xf86freeMonitorList

XF86ConfMonitorPtr
xf86parseMonitorSection(void)
{
    int has_ident = FALSE;
    int token;

    parsePrologue(XF86ConfMonitorPtr, XF86ConfMonitorRec)

        while ((token = xf86getToken(MonitorTab)) != ENDSECTION) {
        switch (token) {
        case COMMENT:
            ptr->mon_comment = xf86addComment(ptr->mon_comment, xf86_lex_val.str);
            break;
        case IDENTIFIER:
            if (xf86getSubToken(&(ptr->mon_comment)) != STRING)
                Error(QUOTE_MSG, "Identifier");
            if (has_ident == TRUE)
                Error(MULTIPLE_MSG, "Identifier");
            ptr->mon_identifier = xf86_lex_val.str;
            has_ident = TRUE;
            break;
        case VENDOR:
            if (xf86getSubToken(&(ptr->mon_comment)) != STRING)
                Error(QUOTE_MSG, "Vendor");
            ptr->mon_vendor = xf86_lex_val.str;
            break;
        case MODEL:
            if (xf86getSubToken(&(ptr->mon_comment)) != STRING)
                Error(QUOTE_MSG, "ModelName");
            ptr->mon_modelname = xf86_lex_val.str;
            break;
        case MODE:
            HANDLE_LIST(mon_modeline_lst, xf86parseVerboseMode,
                        XF86ConfModeLinePtr);
            break;
        case MODELINE:
            HANDLE_LIST(mon_modeline_lst, xf86parseModeLine,
                        XF86ConfModeLinePtr);
            break;
        case DISPLAYSIZE:
            if (xf86getSubToken(&(ptr->mon_comment)) != NUMBER)
                Error(DISPLAYSIZE_MSG);
            ptr->mon_width = xf86_lex_val.realnum;
            if (xf86getSubToken(&(ptr->mon_comment)) != NUMBER)
                Error(DISPLAYSIZE_MSG);
            ptr->mon_height = xf86_lex_val.realnum;
            break;

        case HORIZSYNC:
            if (xf86getSubToken(&(ptr->mon_comment)) != NUMBER)
                Error(HORIZSYNC_MSG);
            do {
                if (ptr->mon_n_hsync >= CONF_MAX_HSYNC)
                    Error("Sorry. Too many horizontal sync intervals.");
                ptr->mon_hsync[ptr->mon_n_hsync].lo = xf86_lex_val.realnum;
                switch (token = xf86getSubToken(&(ptr->mon_comment))) {
                case COMMA:
                    ptr->mon_hsync[ptr->mon_n_hsync].hi =
                        ptr->mon_hsync[ptr->mon_n_hsync].lo;
                    break;
                case DASH:
                    if (xf86getSubToken(&(ptr->mon_comment)) != NUMBER ||
                        (float) xf86_lex_val.realnum <
                        ptr->mon_hsync[ptr->mon_n_hsync].lo)
                        Error(HORIZSYNC_MSG);
                    ptr->mon_hsync[ptr->mon_n_hsync].hi = xf86_lex_val.realnum;
                    if ((token = xf86getSubToken(&(ptr->mon_comment))) == COMMA)
                        break;
                    ptr->mon_n_hsync++;
                    goto HorizDone;
                default:
                    /* We cannot currently know if a '\n' was found,
                     * or this is a real error
                     */
                    ptr->mon_hsync[ptr->mon_n_hsync].hi =
                        ptr->mon_hsync[ptr->mon_n_hsync].lo;
                    ptr->mon_n_hsync++;
                    goto HorizDone;
                }
                ptr->mon_n_hsync++;
            } while ((token = xf86getSubToken(&(ptr->mon_comment))) == NUMBER);
 HorizDone:
            xf86unGetToken(token);
            break;

        case VERTREFRESH:
            if (xf86getSubToken(&(ptr->mon_comment)) != NUMBER)
                Error(VERTREFRESH_MSG);
            do {
                ptr->mon_vrefresh[ptr->mon_n_vrefresh].lo = xf86_lex_val.realnum;
                switch (token = xf86getSubToken(&(ptr->mon_comment))) {
                case COMMA:
                    ptr->mon_vrefresh[ptr->mon_n_vrefresh].hi =
                        ptr->mon_vrefresh[ptr->mon_n_vrefresh].lo;
                    break;
                case DASH:
                    if (xf86getSubToken(&(ptr->mon_comment)) != NUMBER ||
                        (float) xf86_lex_val.realnum <
                        ptr->mon_vrefresh[ptr->mon_n_vrefresh].lo)
                        Error(VERTREFRESH_MSG);
                    ptr->mon_vrefresh[ptr->mon_n_vrefresh].hi = xf86_lex_val.realnum;
                    if ((token = xf86getSubToken(&(ptr->mon_comment))) == COMMA)
                        break;
                    ptr->mon_n_vrefresh++;
                    goto VertDone;
                default:
                    /* We cannot currently know if a '\n' was found,
                     * or this is a real error
                     */
                    ptr->mon_vrefresh[ptr->mon_n_vrefresh].hi =
                        ptr->mon_vrefresh[ptr->mon_n_vrefresh].lo;
                    ptr->mon_n_vrefresh++;
                    goto VertDone;
                }
                if (ptr->mon_n_vrefresh >= CONF_MAX_VREFRESH)
                    Error("Sorry. Too many vertical refresh intervals.");
                ptr->mon_n_vrefresh++;
            } while ((token = xf86getSubToken(&(ptr->mon_comment))) == NUMBER);
 VertDone:
            xf86unGetToken(token);
            break;

        case GAMMA:
            if (xf86getSubToken(&(ptr->mon_comment)) != NUMBER) {
                Error(INVALID_GAMMA_MSG);
            }
            else {
                ptr->mon_gamma_red = ptr->mon_gamma_green =
                    ptr->mon_gamma_blue = xf86_lex_val.realnum;
                if (xf86getSubToken(&(ptr->mon_comment)) == NUMBER) {
                    ptr->mon_gamma_green = xf86_lex_val.realnum;
                    if (xf86getSubToken(&(ptr->mon_comment)) == NUMBER) {
                        ptr->mon_gamma_blue = xf86_lex_val.realnum;
                    }
                    else {
                        Error(INVALID_GAMMA_MSG);
                    }
                }
                else
                    xf86unGetToken(token);
            }
            break;
        case OPTION:
            ptr->mon_option_lst = xf86parseOption(ptr->mon_option_lst);
            break;
        case USEMODES:
        {
            XF86ConfModesLinkPtr mptr;

            if ((token = xf86getSubToken(&(ptr->mon_comment))) != STRING)
                Error(QUOTE_MSG, "UseModes");

            /* add to the end of the list of modes sections
               referenced here */
            mptr = calloc(1, sizeof(XF86ConfModesLinkRec));
            mptr->list.next = NULL;
            mptr->ml_modes_str = xf86_lex_val.str;
            mptr->ml_modes = NULL;
            ptr->mon_modes_sect_lst = (XF86ConfModesLinkPtr)
                xf86addListItem((GenericListPtr) ptr->mon_modes_sect_lst,
                                (GenericListPtr) mptr);
        }
            break;
        case EOF_TOKEN:
            Error(UNEXPECTED_EOF_MSG);
            break;
        default:
            xf86parseError(INVALID_KEYWORD_MSG, xf86tokenString());
            CLEANUP(ptr);
            return NULL;
            break;
        }
    }

    if (!has_ident)
        Error(NO_IDENT_MSG);

#ifdef DEBUG
    printf("Monitor section parsed\n");
#endif
    return ptr;
}

#undef CLEANUP
#define CLEANUP xf86freeModesList

XF86ConfModesPtr
xf86parseModesSection(void)
{
    int has_ident = FALSE;
    int token;

    parsePrologue(XF86ConfModesPtr, XF86ConfModesRec)

        while ((token = xf86getToken(ModesTab)) != ENDSECTION) {
        switch (token) {
        case COMMENT:
            ptr->modes_comment = xf86addComment(ptr->modes_comment, xf86_lex_val.str);
            break;
        case IDENTIFIER:
            if (xf86getSubToken(&(ptr->modes_comment)) != STRING)
                Error(QUOTE_MSG, "Identifier");
            if (has_ident == TRUE)
                Error(MULTIPLE_MSG, "Identifier");
            ptr->modes_identifier = xf86_lex_val.str;
            has_ident = TRUE;
            break;
        case MODE:
            HANDLE_LIST(mon_modeline_lst, xf86parseVerboseMode,
                        XF86ConfModeLinePtr);
            break;
        case MODELINE:
            HANDLE_LIST(mon_modeline_lst, xf86parseModeLine,
                        XF86ConfModeLinePtr);
            break;
        default:
            xf86parseError(INVALID_KEYWORD_MSG, xf86tokenString());
            CLEANUP(ptr);
            return NULL;
            break;
        }
    }

    if (!has_ident)
        Error(NO_IDENT_MSG);

#ifdef DEBUG
    printf("Modes section parsed\n");
#endif
    return ptr;
}

#undef CLEANUP

void
xf86printMonitorSection(FILE * cf, XF86ConfMonitorPtr ptr)
{
    int i;
    XF86ConfModeLinePtr mlptr;
    XF86ConfModesLinkPtr mptr;

    while (ptr) {
        mptr = ptr->mon_modes_sect_lst;
        fprintf(cf, "Section \"Monitor\"\n");
        if (ptr->mon_comment)
            fprintf(cf, "%s", ptr->mon_comment);
        if (ptr->mon_identifier)
            fprintf(cf, "\tIdentifier   \"%s\"\n", ptr->mon_identifier);
        if (ptr->mon_vendor)
            fprintf(cf, "\tVendorName   \"%s\"\n", ptr->mon_vendor);
        if (ptr->mon_modelname)
            fprintf(cf, "\tModelName    \"%s\"\n", ptr->mon_modelname);
        while (mptr) {
            fprintf(cf, "\tUseModes     \"%s\"\n", mptr->ml_modes_str);
            mptr = mptr->list.next;
        }
        if (ptr->mon_width)
            fprintf(cf, "\tDisplaySize  %d\t%d\n",
                    ptr->mon_width, ptr->mon_height);
        for (i = 0; i < ptr->mon_n_hsync; i++) {
            fprintf(cf, "\tHorizSync    %2.1f - %2.1f\n",
                    ptr->mon_hsync[i].lo, ptr->mon_hsync[i].hi);
        }
        for (i = 0; i < ptr->mon_n_vrefresh; i++) {
            fprintf(cf, "\tVertRefresh  %2.1f - %2.1f\n",
                    ptr->mon_vrefresh[i].lo, ptr->mon_vrefresh[i].hi);
        }
        if (ptr->mon_gamma_red) {
            if (ptr->mon_gamma_red == ptr->mon_gamma_green
                && ptr->mon_gamma_red == ptr->mon_gamma_blue) {
                fprintf(cf, "\tGamma        %.4g\n", ptr->mon_gamma_red);
            }
            else {
                fprintf(cf, "\tGamma        %.4g %.4g %.4g\n",
                        ptr->mon_gamma_red,
                        ptr->mon_gamma_green, ptr->mon_gamma_blue);
            }
        }
        for (mlptr = ptr->mon_modeline_lst; mlptr; mlptr = mlptr->list.next) {
            fprintf(cf, "\tModeLine     \"%s\" %2.1f ",
                    mlptr->ml_identifier, mlptr->ml_clock / 1000.0);
            fprintf(cf, "%d %d %d %d %d %d %d %d",
                    mlptr->ml_hdisplay, mlptr->ml_hsyncstart,
                    mlptr->ml_hsyncend, mlptr->ml_htotal,
                    mlptr->ml_vdisplay, mlptr->ml_vsyncstart,
                    mlptr->ml_vsyncend, mlptr->ml_vtotal);
            if (mlptr->ml_flags & XF86CONF_PHSYNC)
                fprintf(cf, " +hsync");
            if (mlptr->ml_flags & XF86CONF_NHSYNC)
                fprintf(cf, " -hsync");
            if (mlptr->ml_flags & XF86CONF_PVSYNC)
                fprintf(cf, " +vsync");
            if (mlptr->ml_flags & XF86CONF_NVSYNC)
                fprintf(cf, " -vsync");
            if (mlptr->ml_flags & XF86CONF_INTERLACE)
                fprintf(cf, " interlace");
            if (mlptr->ml_flags & XF86CONF_CSYNC)
                fprintf(cf, " composite");
            if (mlptr->ml_flags & XF86CONF_PCSYNC)
                fprintf(cf, " +csync");
            if (mlptr->ml_flags & XF86CONF_NCSYNC)
                fprintf(cf, " -csync");
            if (mlptr->ml_flags & XF86CONF_DBLSCAN)
                fprintf(cf, " doublescan");
            if (mlptr->ml_flags & XF86CONF_HSKEW)
                fprintf(cf, " hskew %d", mlptr->ml_hskew);
            if (mlptr->ml_flags & XF86CONF_BCAST)
                fprintf(cf, " bcast");
            fprintf(cf, "\n");
        }
        xf86printOptionList(cf, ptr->mon_option_lst, 1);
        fprintf(cf, "EndSection\n\n");
        ptr = ptr->list.next;
    }
}

void
xf86printModesSection(FILE * cf, XF86ConfModesPtr ptr)
{
    XF86ConfModeLinePtr mlptr;

    while (ptr) {
        fprintf(cf, "Section \"Modes\"\n");
        if (ptr->modes_comment)
            fprintf(cf, "%s", ptr->modes_comment);
        if (ptr->modes_identifier)
            fprintf(cf, "\tIdentifier     \"%s\"\n", ptr->modes_identifier);
        for (mlptr = ptr->mon_modeline_lst; mlptr; mlptr = mlptr->list.next) {
            fprintf(cf, "\tModeLine     \"%s\" %2.1f ",
                    mlptr->ml_identifier, mlptr->ml_clock / 1000.0);
            fprintf(cf, "%d %d %d %d %d %d %d %d",
                    mlptr->ml_hdisplay, mlptr->ml_hsyncstart,
                    mlptr->ml_hsyncend, mlptr->ml_htotal,
                    mlptr->ml_vdisplay, mlptr->ml_vsyncstart,
                    mlptr->ml_vsyncend, mlptr->ml_vtotal);
            if (mlptr->ml_flags & XF86CONF_PHSYNC)
                fprintf(cf, " +hsync");
            if (mlptr->ml_flags & XF86CONF_NHSYNC)
                fprintf(cf, " -hsync");
            if (mlptr->ml_flags & XF86CONF_PVSYNC)
                fprintf(cf, " +vsync");
            if (mlptr->ml_flags & XF86CONF_NVSYNC)
                fprintf(cf, " -vsync");
            if (mlptr->ml_flags & XF86CONF_INTERLACE)
                fprintf(cf, " interlace");
            if (mlptr->ml_flags & XF86CONF_CSYNC)
                fprintf(cf, " composite");
            if (mlptr->ml_flags & XF86CONF_PCSYNC)
                fprintf(cf, " +csync");
            if (mlptr->ml_flags & XF86CONF_NCSYNC)
                fprintf(cf, " -csync");
            if (mlptr->ml_flags & XF86CONF_DBLSCAN)
                fprintf(cf, " doublescan");
            if (mlptr->ml_flags & XF86CONF_HSKEW)
                fprintf(cf, " hskew %d", mlptr->ml_hskew);
            if (mlptr->ml_flags & XF86CONF_VSCAN)
                fprintf(cf, " vscan %d", mlptr->ml_vscan);
            if (mlptr->ml_flags & XF86CONF_BCAST)
                fprintf(cf, " bcast");
            if (mlptr->ml_comment)
                fprintf(cf, "%s", mlptr->ml_comment);
            else
                fprintf(cf, "\n");
        }
        fprintf(cf, "EndSection\n\n");
        ptr = ptr->list.next;
    }
}

void
xf86freeMonitorList(XF86ConfMonitorPtr ptr)
{
    XF86ConfMonitorPtr prev;

    while (ptr) {
        TestFree(ptr->mon_identifier);
        TestFree(ptr->mon_vendor);
        TestFree(ptr->mon_modelname);
        TestFree(ptr->mon_comment);
        xf86optionListFree(ptr->mon_option_lst);
        xf86freeModeLineList(ptr->mon_modeline_lst);
        prev = ptr;
        ptr = ptr->list.next;
        free(prev);
    }
}

void
xf86freeModesList(XF86ConfModesPtr ptr)
{
    XF86ConfModesPtr prev;

    while (ptr) {
        TestFree(ptr->modes_identifier);
        TestFree(ptr->modes_comment);
        xf86freeModeLineList(ptr->mon_modeline_lst);
        prev = ptr;
        ptr = ptr->list.next;
        free(prev);
    }
}

XF86ConfMonitorPtr
xf86findMonitor(const char *ident, XF86ConfMonitorPtr p)
{
    while (p) {
        if (xf86nameCompare(ident, p->mon_identifier) == 0)
            return p;

        p = p->list.next;
    }
    return NULL;
}

XF86ConfModesPtr
xf86findModes(const char *ident, XF86ConfModesPtr p)
{
    while (p) {
        if (xf86nameCompare(ident, p->modes_identifier) == 0)
            return p;

        p = p->list.next;
    }
    return NULL;
}

XF86ConfModeLinePtr
xf86findModeLine(const char *ident, XF86ConfModeLinePtr p)
{
    while (p) {
        if (xf86nameCompare(ident, p->ml_identifier) == 0)
            return p;

        p = p->list.next;
    }
    return NULL;
}

int
xf86validateMonitor(XF86ConfigPtr p, XF86ConfScreenPtr screen)
{
    XF86ConfMonitorPtr monitor = screen->scrn_monitor;
    XF86ConfModesLinkPtr modeslnk = monitor->mon_modes_sect_lst;
    XF86ConfModesPtr modes;

    while (modeslnk) {
        modes = xf86findModes(modeslnk->ml_modes_str, p->conf_modes_lst);
        if (!modes) {
            xf86validationError(UNDEFINED_MODES_MSG,
                                modeslnk->ml_modes_str,
                                screen->scrn_identifier);
            return FALSE;
        }
        modeslnk->ml_modes = modes;
        modeslnk = modeslnk->list.next;
    }
    return TRUE;
}
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1 2
a2 2
/* 
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * copy of this software and associated documentation files (the "Software"), 
d11 1
a11 1
 * 
d14 1
a14 1
 * 
d22 1
a22 1
 * 
d26 1
a26 1
 * 
d556 1
a556 1
            /* add to the end of the list of modes sections 
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a62 1
extern LexRec val;
d142 1
a142 1
    ptr->ml_identifier = val.str;
d147 1
a147 1
    ptr->ml_clock = (int) (val.realnum * 1000.0 + 0.5);
d152 1
a152 1
    ptr->ml_hdisplay = val.num;
d157 1
a157 1
    ptr->ml_hsyncstart = val.num;
d162 1
a162 1
    ptr->ml_hsyncend = val.num;
d167 1
a167 1
    ptr->ml_htotal = val.num;
d172 1
a172 1
    ptr->ml_vdisplay = val.num;
d177 1
a177 1
    ptr->ml_vsyncstart = val.num;
d182 1
a182 1
    ptr->ml_vsyncend = val.num;
d187 1
a187 1
    ptr->ml_vtotal = val.num;
d228 1
a228 1
            ptr->ml_hskew = val.num;
d237 1
a237 1
            ptr->ml_vscan = val.num;
d267 1
a267 1
    ptr->ml_identifier = val.str;
d271 1
a271 1
            ptr->ml_comment = xf86addComment(ptr->ml_comment, val.str);
d276 1
a276 1
            ptr->ml_clock = (int) (val.realnum * 1000.0 + 0.5);
d281 1
a281 1
                ptr->ml_hdisplay = val.num;
d286 1
a286 1
                ptr->ml_hsyncstart = val.num;
d291 1
a291 1
                ptr->ml_hsyncend = val.num;
d296 1
a296 1
                ptr->ml_htotal = val.num;
d303 1
a303 1
                ptr->ml_vdisplay = val.num;
d308 1
a308 1
                ptr->ml_vsyncstart = val.num;
d313 1
a313 1
                ptr->ml_vsyncend = val.num;
d318 1
a318 1
                ptr->ml_vtotal = val.num;
d372 1
a372 1
            ptr->ml_hskew = val.num;
d378 1
a378 1
            ptr->ml_vscan = val.num;
d415 1
a415 1
            ptr->mon_comment = xf86addComment(ptr->mon_comment, val.str);
d422 1
a422 1
            ptr->mon_identifier = val.str;
d428 1
a428 1
            ptr->mon_vendor = val.str;
d433 1
a433 1
            ptr->mon_modelname = val.str;
d446 1
a446 1
            ptr->mon_width = val.realnum;
d449 1
a449 1
            ptr->mon_height = val.realnum;
d458 1
a458 1
                ptr->mon_hsync[ptr->mon_n_hsync].lo = val.realnum;
d466 1
a466 1
                        (float) val.realnum <
d469 1
a469 1
                    ptr->mon_hsync[ptr->mon_n_hsync].hi = val.realnum;
d493 1
a493 1
                ptr->mon_vrefresh[ptr->mon_n_vrefresh].lo = val.realnum;
d501 1
a501 1
                        (float) val.realnum <
d504 1
a504 1
                    ptr->mon_vrefresh[ptr->mon_n_vrefresh].hi = val.realnum;
d532 1
a532 1
                    ptr->mon_gamma_blue = val.realnum;
d534 1
a534 1
                    ptr->mon_gamma_green = val.realnum;
d536 1
a536 1
                        ptr->mon_gamma_blue = val.realnum;
d560 1
a560 1
            mptr->ml_modes_str = val.str;
d601 1
a601 1
            ptr->modes_comment = xf86addComment(ptr->modes_comment, val.str);
d608 1
a608 1
            ptr->modes_identifier = val.str;
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a54 2
/* View/edit this file with tab stops set to 4 */

@


1.5
log
@Update to xserver 1.11.2
@
text
@a54 1

d67 14
a80 15
static xf86ConfigSymTabRec MonitorTab[] =
{
	{ENDSECTION, "endsection"},
	{IDENTIFIER, "identifier"},
	{VENDOR, "vendorname"},
	{MODEL, "modelname"},
	{USEMODES, "usemodes"},
	{MODELINE, "modeline"},
	{DISPLAYSIZE, "displaysize"},
	{HORIZSYNC, "horizsync"},
	{VERTREFRESH, "vertrefresh"},
	{MODE, "mode"},
	{GAMMA, "gamma"},
	{OPTION, "option"},
	{-1, ""},
d83 6
a88 7
static xf86ConfigSymTabRec ModesTab[] =
{
	{ENDSECTION, "endsection"},
	{IDENTIFIER, "identifier"},
	{MODELINE, "modeline"},
	{MODE, "mode"},
	{-1, ""},
d91 14
a104 15
static xf86ConfigSymTabRec TimingTab[] =
{
	{TT_INTERLACE, "interlace"},
	{TT_PHSYNC, "+hsync"},
	{TT_NHSYNC, "-hsync"},
	{TT_PVSYNC, "+vsync"},
	{TT_NVSYNC, "-vsync"},
	{TT_CSYNC, "composite"},
	{TT_PCSYNC, "+csync"},
	{TT_NCSYNC, "-csync"},
	{TT_DBLSCAN, "doublescan"},
	{TT_HSKEW, "hskew"},
	{TT_BCAST, "bcast"},
	{TT_VSCAN, "vscan"},
	{-1, ""},
d107 10
a116 11
static xf86ConfigSymTabRec ModeTab[] =
{
	{DOTCLOCK, "dotclock"},
	{HTIMINGS, "htimings"},
	{VTIMINGS, "vtimings"},
	{FLAGS, "flags"},
	{HSKEW, "hskew"},
	{BCAST, "bcast"},
	{VSCAN, "vscan"},
	{ENDMODE, "endmode"},
	{-1, ""},
d122 1
a122 1
xf86freeModeLineList (XF86ConfModeLinePtr ptr)
d124 9
a132 9
	XF86ConfModeLinePtr prev;
	while (ptr)
	{
		TestFree (ptr->ml_identifier);
		TestFree (ptr->ml_comment);
		prev = ptr;
		ptr = ptr->list.next;
		free (prev);
	}
d136 1
a136 1
xf86parseModeLine (void)
d138 3
a140 2
	int token;
	parsePrologue (XF86ConfModeLinePtr, XF86ConfModeLineRec)
d142 111
a252 113
	/* Identifier */
	if (xf86getSubToken (&(ptr->ml_comment)) != STRING)
		Error ("ModeLine identifier expected", NULL);
	ptr->ml_identifier = val.str;

	/* DotClock */
	if (xf86getSubToken (&(ptr->ml_comment)) != NUMBER)
		Error ("ModeLine dotclock expected", NULL);
	ptr->ml_clock = (int) (val.realnum * 1000.0 + 0.5);

	/* HDisplay */
	if (xf86getSubToken (&(ptr->ml_comment)) != NUMBER)
		Error ("ModeLine Hdisplay expected", NULL);
	ptr->ml_hdisplay = val.num;

	/* HSyncStart */
	if (xf86getSubToken (&(ptr->ml_comment)) != NUMBER)
		Error ("ModeLine HSyncStart expected", NULL);
	ptr->ml_hsyncstart = val.num;

	/* HSyncEnd */
	if (xf86getSubToken (&(ptr->ml_comment)) != NUMBER)
		Error ("ModeLine HSyncEnd expected", NULL);
	ptr->ml_hsyncend = val.num;

	/* HTotal */
	if (xf86getSubToken (&(ptr->ml_comment)) != NUMBER)
		Error ("ModeLine HTotal expected", NULL);
	ptr->ml_htotal = val.num;

	/* VDisplay */
	if (xf86getSubToken (&(ptr->ml_comment)) != NUMBER)
		Error ("ModeLine Vdisplay expected", NULL);
	ptr->ml_vdisplay = val.num;

	/* VSyncStart */
	if (xf86getSubToken (&(ptr->ml_comment)) != NUMBER)
		Error ("ModeLine VSyncStart expected", NULL);
	ptr->ml_vsyncstart = val.num;

	/* VSyncEnd */
	if (xf86getSubToken (&(ptr->ml_comment)) != NUMBER)
		Error ("ModeLine VSyncEnd expected", NULL);
	ptr->ml_vsyncend = val.num;

	/* VTotal */
	if (xf86getSubToken (&(ptr->ml_comment)) != NUMBER)
		Error ("ModeLine VTotal expected", NULL);
	ptr->ml_vtotal = val.num;

	token = xf86getSubTokenWithTab (&(ptr->ml_comment), TimingTab);
	while ((token == TT_INTERLACE) || (token == TT_PHSYNC) ||
		   (token == TT_NHSYNC) || (token == TT_PVSYNC) ||
		   (token == TT_NVSYNC) || (token == TT_CSYNC) ||
		   (token == TT_PCSYNC) || (token == TT_NCSYNC) ||
		   (token == TT_DBLSCAN) || (token == TT_HSKEW) ||
		   (token == TT_VSCAN) || (token == TT_BCAST))
	{
		switch (token)
		{

		case TT_INTERLACE:
			ptr->ml_flags |= XF86CONF_INTERLACE;
			break;
		case TT_PHSYNC:
			ptr->ml_flags |= XF86CONF_PHSYNC;
			break;
		case TT_NHSYNC:
			ptr->ml_flags |= XF86CONF_NHSYNC;
			break;
		case TT_PVSYNC:
			ptr->ml_flags |= XF86CONF_PVSYNC;
			break;
		case TT_NVSYNC:
			ptr->ml_flags |= XF86CONF_NVSYNC;
			break;
		case TT_CSYNC:
			ptr->ml_flags |= XF86CONF_CSYNC;
			break;
		case TT_PCSYNC:
			ptr->ml_flags |= XF86CONF_PCSYNC;
			break;
		case TT_NCSYNC:
			ptr->ml_flags |= XF86CONF_NCSYNC;
			break;
		case TT_DBLSCAN:
			ptr->ml_flags |= XF86CONF_DBLSCAN;
			break;
		case TT_HSKEW:
			if (xf86getSubToken (&(ptr->ml_comment)) != NUMBER)
				Error (NUMBER_MSG, "Hskew");
			ptr->ml_hskew = val.num;
			ptr->ml_flags |= XF86CONF_HSKEW;
			break;
		case TT_BCAST:
			ptr->ml_flags |= XF86CONF_BCAST;
			break;
		case TT_VSCAN:
			if (xf86getSubToken (&(ptr->ml_comment)) != NUMBER)
				Error (NUMBER_MSG, "Vscan");
			ptr->ml_vscan = val.num;
			ptr->ml_flags |= XF86CONF_VSCAN;
			break;
		case EOF_TOKEN:
			Error (UNEXPECTED_EOF_MSG, NULL);
			break;
		default:
			Error (INVALID_KEYWORD_MSG, xf86tokenString ());
			break;
		}
		token = xf86getSubTokenWithTab (&(ptr->ml_comment), TimingTab);
	}
	xf86unGetToken (token);
d255 1
a255 1
	printf ("ModeLine parsed\n");
d257 1
a257 1
	return ptr;
d261 1
a261 1
xf86parseVerboseMode (void)
d263 133
a395 136
	int token, token2;
	int had_dotclock = 0, had_htimings = 0, had_vtimings = 0;
	parsePrologue (XF86ConfModeLinePtr, XF86ConfModeLineRec)

		if (xf86getSubToken (&(ptr->ml_comment)) != STRING)
		Error ("Mode name expected", NULL);
	ptr->ml_identifier = val.str;
	while ((token = xf86getToken (ModeTab)) != ENDMODE)
	{
		switch (token)
		{
		case COMMENT:
			ptr->ml_comment = xf86addComment(ptr->ml_comment, val.str);
			break;
		case DOTCLOCK:
			if ((token = xf86getSubToken (&(ptr->ml_comment))) != NUMBER)
				Error (NUMBER_MSG, "DotClock");
			ptr->ml_clock = (int) (val.realnum * 1000.0 + 0.5);
			had_dotclock = 1;
			break;
		case HTIMINGS:
			if (xf86getSubToken (&(ptr->ml_comment)) == NUMBER)
				ptr->ml_hdisplay = val.num;
			else
				Error ("Horizontal display expected", NULL);

			if (xf86getSubToken (&(ptr->ml_comment)) == NUMBER)
				ptr->ml_hsyncstart = val.num;
			else
				Error ("Horizontal sync start expected", NULL);

			if (xf86getSubToken (&(ptr->ml_comment)) == NUMBER)
				ptr->ml_hsyncend = val.num;
			else
				Error ("Horizontal sync end expected", NULL);

			if (xf86getSubToken (&(ptr->ml_comment)) == NUMBER)
				ptr->ml_htotal = val.num;
			else
				Error ("Horizontal total expected", NULL);
			had_htimings = 1;
			break;
		case VTIMINGS:
			if (xf86getSubToken (&(ptr->ml_comment)) == NUMBER)
				ptr->ml_vdisplay = val.num;
			else
				Error ("Vertical display expected", NULL);

			if (xf86getSubToken (&(ptr->ml_comment)) == NUMBER)
				ptr->ml_vsyncstart = val.num;
			else
				Error ("Vertical sync start expected", NULL);

			if (xf86getSubToken (&(ptr->ml_comment)) == NUMBER)
				ptr->ml_vsyncend = val.num;
			else
				Error ("Vertical sync end expected", NULL);

			if (xf86getSubToken (&(ptr->ml_comment)) == NUMBER)
				ptr->ml_vtotal = val.num;
			else
				Error ("Vertical total expected", NULL);
			had_vtimings = 1;
			break;
		case FLAGS:
			token = xf86getSubToken (&(ptr->ml_comment));
			if (token != STRING)
				Error (QUOTE_MSG, "Flags");
			while (token == STRING)
			{
				token2 = xf86getStringToken (TimingTab);
				switch (token2)
				{
				case TT_INTERLACE:
					ptr->ml_flags |= XF86CONF_INTERLACE;
					break;
				case TT_PHSYNC:
					ptr->ml_flags |= XF86CONF_PHSYNC;
					break;
				case TT_NHSYNC:
					ptr->ml_flags |= XF86CONF_NHSYNC;
					break;
				case TT_PVSYNC:
					ptr->ml_flags |= XF86CONF_PVSYNC;
					break;
				case TT_NVSYNC:
					ptr->ml_flags |= XF86CONF_NVSYNC;
					break;
				case TT_CSYNC:
					ptr->ml_flags |= XF86CONF_CSYNC;
					break;
				case TT_PCSYNC:
					ptr->ml_flags |= XF86CONF_PCSYNC;
					break;
				case TT_NCSYNC:
					ptr->ml_flags |= XF86CONF_NCSYNC;
					break;
				case TT_DBLSCAN:
					ptr->ml_flags |= XF86CONF_DBLSCAN;
					break;
				case EOF_TOKEN:
					Error (UNEXPECTED_EOF_MSG, NULL);
					break;
				default:
					Error ("Unknown flag string", NULL);
					break;
				}
				token = xf86getSubToken (&(ptr->ml_comment));
			}
			xf86unGetToken (token);
			break;
		case HSKEW:
			if (xf86getSubToken (&(ptr->ml_comment)) != NUMBER)
				Error ("Horizontal skew expected", NULL);
			ptr->ml_flags |= XF86CONF_HSKEW;
			ptr->ml_hskew = val.num;
			break;
		case VSCAN:
			if (xf86getSubToken (&(ptr->ml_comment)) != NUMBER)
				Error ("Vertical scan count expected", NULL);
			ptr->ml_flags |= XF86CONF_VSCAN;
			ptr->ml_vscan = val.num;
			break;
		case EOF_TOKEN:
			Error (UNEXPECTED_EOF_MSG, NULL);
			break;
		default:
			Error ("Unexepcted token in verbose \"Mode\" entry\n", NULL);
		}
	}
	if (!had_dotclock)
		Error ("the dotclock is missing", NULL);
	if (!had_htimings)
		Error ("the horizontal timings are missing", NULL);
	if (!had_vtimings)
		Error ("the vertical timings are missing", NULL);
d398 1
a398 1
	printf ("Verbose Mode parsed\n");
d400 1
a400 1
	return ptr;
d408 1
a408 1
xf86parseMonitorSection (void)
d410 4
a413 176
	int has_ident = FALSE;
	int token;
	parsePrologue (XF86ConfMonitorPtr, XF86ConfMonitorRec)

		while ((token = xf86getToken (MonitorTab)) != ENDSECTION)
	{
		switch (token)
		{
		case COMMENT:
			ptr->mon_comment = xf86addComment(ptr->mon_comment, val.str);
			break;
		case IDENTIFIER:
			if (xf86getSubToken (&(ptr->mon_comment)) != STRING)
				Error (QUOTE_MSG, "Identifier");
			if (has_ident == TRUE)
				Error (MULTIPLE_MSG, "Identifier");
			ptr->mon_identifier = val.str;
			has_ident = TRUE;
			break;
		case VENDOR:
			if (xf86getSubToken (&(ptr->mon_comment)) != STRING)
				Error (QUOTE_MSG, "Vendor");
			ptr->mon_vendor = val.str;
			break;
		case MODEL:
			if (xf86getSubToken (&(ptr->mon_comment)) != STRING)
				Error (QUOTE_MSG, "ModelName");
			ptr->mon_modelname = val.str;
			break;
		case MODE:
			HANDLE_LIST (mon_modeline_lst, xf86parseVerboseMode,
						 XF86ConfModeLinePtr);
			break;
		case MODELINE:
			HANDLE_LIST (mon_modeline_lst, xf86parseModeLine,
						 XF86ConfModeLinePtr);
			break;
		case DISPLAYSIZE:
			if (xf86getSubToken (&(ptr->mon_comment)) != NUMBER)
				Error (DISPLAYSIZE_MSG, NULL);
			ptr->mon_width = val.realnum;
			if (xf86getSubToken (&(ptr->mon_comment)) != NUMBER)
				Error (DISPLAYSIZE_MSG, NULL);
			ptr->mon_height = val.realnum;
			break;

		case HORIZSYNC:
			if (xf86getSubToken (&(ptr->mon_comment)) != NUMBER)
				Error (HORIZSYNC_MSG, NULL);
			do {
				if (ptr->mon_n_hsync >= CONF_MAX_HSYNC)
					Error ("Sorry. Too many horizontal sync intervals.", NULL);
				ptr->mon_hsync[ptr->mon_n_hsync].lo = val.realnum;
				switch (token = xf86getSubToken (&(ptr->mon_comment)))
				{
					case COMMA:
						ptr->mon_hsync[ptr->mon_n_hsync].hi =
						ptr->mon_hsync[ptr->mon_n_hsync].lo;
						break;
					case DASH:
						if (xf86getSubToken (&(ptr->mon_comment)) != NUMBER ||
						    (float)val.realnum < ptr->mon_hsync[ptr->mon_n_hsync].lo)
							Error (HORIZSYNC_MSG, NULL);
						ptr->mon_hsync[ptr->mon_n_hsync].hi = val.realnum;
						if ((token = xf86getSubToken (&(ptr->mon_comment))) == COMMA)
							break;
						ptr->mon_n_hsync++;
						goto HorizDone;
					default:
						/* We cannot currently know if a '\n' was found,
						 * or this is a real error
						 */
						ptr->mon_hsync[ptr->mon_n_hsync].hi =
						ptr->mon_hsync[ptr->mon_n_hsync].lo;
						ptr->mon_n_hsync++;
						goto HorizDone;
				}
				ptr->mon_n_hsync++;
			} while ((token = xf86getSubToken (&(ptr->mon_comment))) == NUMBER);
HorizDone:
			xf86unGetToken (token);
			break;

		case VERTREFRESH:
			if (xf86getSubToken (&(ptr->mon_comment)) != NUMBER)
				Error (VERTREFRESH_MSG, NULL);
			do {
				ptr->mon_vrefresh[ptr->mon_n_vrefresh].lo = val.realnum;
				switch (token = xf86getSubToken (&(ptr->mon_comment)))
				{
					case COMMA:
						ptr->mon_vrefresh[ptr->mon_n_vrefresh].hi =
						ptr->mon_vrefresh[ptr->mon_n_vrefresh].lo;
						break;
					case DASH:
						if (xf86getSubToken (&(ptr->mon_comment)) != NUMBER ||
						    (float)val.realnum < ptr->mon_vrefresh[ptr->mon_n_vrefresh].lo)
							Error (VERTREFRESH_MSG, NULL);
						ptr->mon_vrefresh[ptr->mon_n_vrefresh].hi = val.realnum;
						if ((token = xf86getSubToken (&(ptr->mon_comment))) == COMMA)
							break;
						ptr->mon_n_vrefresh++;
						goto VertDone;
					default:
						/* We cannot currently know if a '\n' was found,
						 * or this is a real error
						 */
						ptr->mon_vrefresh[ptr->mon_n_vrefresh].hi =
						ptr->mon_vrefresh[ptr->mon_n_vrefresh].lo;
						ptr->mon_n_vrefresh++;
						goto VertDone;
				}
				if (ptr->mon_n_vrefresh >= CONF_MAX_VREFRESH)
					Error ("Sorry. Too many vertical refresh intervals.", NULL);
				ptr->mon_n_vrefresh++;
			} while ((token = xf86getSubToken (&(ptr->mon_comment))) == NUMBER);
VertDone:
			xf86unGetToken (token);
			break;

		case GAMMA:
			if( xf86getSubToken (&(ptr->mon_comment)) != NUMBER )
			{
				Error (INVALID_GAMMA_MSG, NULL);
			}
			else
			{
				ptr->mon_gamma_red = ptr->mon_gamma_green =
					ptr->mon_gamma_blue = val.realnum;
				if( xf86getSubToken (&(ptr->mon_comment)) == NUMBER )
				{
					ptr->mon_gamma_green = val.realnum;
					if( xf86getSubToken (&(ptr->mon_comment)) == NUMBER )
					{
						ptr->mon_gamma_blue = val.realnum;
					}
					else
					{
						Error (INVALID_GAMMA_MSG, NULL);
					}
				}
				else
					xf86unGetToken (token);
			}
			break;
		case OPTION:
			ptr->mon_option_lst = xf86parseOption(ptr->mon_option_lst);
			break;
		case USEMODES:
		        {
				XF86ConfModesLinkPtr mptr;

				if ((token = xf86getSubToken (&(ptr->mon_comment))) != STRING)
					Error (QUOTE_MSG, "UseModes");

				/* add to the end of the list of modes sections 
				   referenced here */
				mptr = calloc (1, sizeof (XF86ConfModesLinkRec));
				mptr->list.next = NULL;
				mptr->ml_modes_str = val.str;
				mptr->ml_modes = NULL;
				ptr->mon_modes_sect_lst = (XF86ConfModesLinkPtr)
					xf86addListItem((GenericListPtr)ptr->mon_modes_sect_lst,
						    (GenericListPtr)mptr);
			}
			break;
		case EOF_TOKEN:
			Error (UNEXPECTED_EOF_MSG, NULL);
			break;
		default:
			xf86parseError (INVALID_KEYWORD_MSG, xf86tokenString ());
			CLEANUP (ptr);
			return NULL;
			break;
		}
	}
d415 168
a582 2
	if (!has_ident)
		Error (NO_IDENT_MSG, NULL);
d585 1
a585 1
	printf ("Monitor section parsed\n");
d587 1
a587 1
	return ptr;
d594 1
a594 1
xf86parseModesSection (void)
d596 33
a628 34
	int has_ident = FALSE;
	int token;
	parsePrologue (XF86ConfModesPtr, XF86ConfModesRec)

	while ((token = xf86getToken (ModesTab)) != ENDSECTION)
	{
		switch (token)
		{
		case COMMENT:
			ptr->modes_comment = xf86addComment(ptr->modes_comment, val.str);
			break;
		case IDENTIFIER:
			if (xf86getSubToken (&(ptr->modes_comment)) != STRING)
				Error (QUOTE_MSG, "Identifier");
			if (has_ident == TRUE)
				Error (MULTIPLE_MSG, "Identifier");
			ptr->modes_identifier = val.str;
			has_ident = TRUE;
			break;
		case MODE:
			HANDLE_LIST (mon_modeline_lst, xf86parseVerboseMode,
						 XF86ConfModeLinePtr);
			break;
		case MODELINE:
			HANDLE_LIST (mon_modeline_lst, xf86parseModeLine,
						 XF86ConfModeLinePtr);
			break;
		default:
			xf86parseError (INVALID_KEYWORD_MSG, xf86tokenString ());
			CLEANUP (ptr);
			return NULL;
			break;
		}
	}
d630 2
a631 2
	if (!has_ident)
		Error (NO_IDENT_MSG, NULL);
d634 1
a634 1
	printf ("Modes section parsed\n");
d636 1
a636 1
	return ptr;
d642 1
a642 1
xf86printMonitorSection (FILE * cf, XF86ConfMonitorPtr ptr)
d644 77
a720 86
	int i;
	XF86ConfModeLinePtr mlptr;
	XF86ConfModesLinkPtr mptr;

	while (ptr)
	{
		mptr = ptr->mon_modes_sect_lst;
		fprintf (cf, "Section \"Monitor\"\n");
		if (ptr->mon_comment)
			fprintf (cf, "%s", ptr->mon_comment);
		if (ptr->mon_identifier)
			fprintf (cf, "\tIdentifier   \"%s\"\n", ptr->mon_identifier);
		if (ptr->mon_vendor)
			fprintf (cf, "\tVendorName   \"%s\"\n", ptr->mon_vendor);
		if (ptr->mon_modelname)
			fprintf (cf, "\tModelName    \"%s\"\n", ptr->mon_modelname);
		while (mptr) {
			fprintf (cf, "\tUseModes     \"%s\"\n", mptr->ml_modes_str);
			mptr = mptr->list.next;
		}
		if (ptr->mon_width)
			fprintf (cf, "\tDisplaySize  %d\t%d\n",
					 ptr->mon_width,
					 ptr->mon_height);
		for (i = 0; i < ptr->mon_n_hsync; i++)
		{
			fprintf (cf, "\tHorizSync    %2.1f - %2.1f\n",
					 ptr->mon_hsync[i].lo,
					 ptr->mon_hsync[i].hi);
		}
		for (i = 0; i < ptr->mon_n_vrefresh; i++)
		{
			fprintf (cf, "\tVertRefresh  %2.1f - %2.1f\n",
					 ptr->mon_vrefresh[i].lo,
					 ptr->mon_vrefresh[i].hi);
		}
		if (ptr->mon_gamma_red) {
			if (ptr->mon_gamma_red == ptr->mon_gamma_green
				&& ptr->mon_gamma_red == ptr->mon_gamma_blue)
			{
				fprintf (cf, "\tGamma        %.4g\n",
					ptr->mon_gamma_red);
			} else {
				fprintf (cf, "\tGamma        %.4g %.4g %.4g\n",
					ptr->mon_gamma_red,
					ptr->mon_gamma_green,
					ptr->mon_gamma_blue);
			}
		}
		for (mlptr = ptr->mon_modeline_lst; mlptr; mlptr = mlptr->list.next)
		{
			fprintf (cf, "\tModeLine     \"%s\" %2.1f ",
					 mlptr->ml_identifier, mlptr->ml_clock / 1000.0);
			fprintf (cf, "%d %d %d %d %d %d %d %d",
					 mlptr->ml_hdisplay, mlptr->ml_hsyncstart,
					 mlptr->ml_hsyncend, mlptr->ml_htotal,
					 mlptr->ml_vdisplay, mlptr->ml_vsyncstart,
					 mlptr->ml_vsyncend, mlptr->ml_vtotal);
			if (mlptr->ml_flags & XF86CONF_PHSYNC)
				fprintf (cf, " +hsync");
			if (mlptr->ml_flags & XF86CONF_NHSYNC)
				fprintf (cf, " -hsync");
			if (mlptr->ml_flags & XF86CONF_PVSYNC)
				fprintf (cf, " +vsync");
			if (mlptr->ml_flags & XF86CONF_NVSYNC)
				fprintf (cf, " -vsync");
			if (mlptr->ml_flags & XF86CONF_INTERLACE)
				fprintf (cf, " interlace");
			if (mlptr->ml_flags & XF86CONF_CSYNC)
				fprintf (cf, " composite");
			if (mlptr->ml_flags & XF86CONF_PCSYNC)
				fprintf (cf, " +csync");
			if (mlptr->ml_flags & XF86CONF_NCSYNC)
				fprintf (cf, " -csync");
			if (mlptr->ml_flags & XF86CONF_DBLSCAN)
				fprintf (cf, " doublescan");
			if (mlptr->ml_flags & XF86CONF_HSKEW)
				fprintf (cf, " hskew %d", mlptr->ml_hskew);
			if (mlptr->ml_flags & XF86CONF_BCAST)
				fprintf (cf, " bcast");
			fprintf (cf, "\n");
		}
		xf86printOptionList(cf, ptr->mon_option_lst, 1);
		fprintf (cf, "EndSection\n\n");
		ptr = ptr->list.next;
	}
d724 1
a724 1
xf86printModesSection (FILE * cf, XF86ConfModesPtr ptr)
d726 1
a726 1
	XF86ConfModeLinePtr mlptr;
d728 46
a773 48
	while (ptr)
	{
		fprintf (cf, "Section \"Modes\"\n");
		if (ptr->modes_comment)
			fprintf (cf, "%s", ptr->modes_comment);
		if (ptr->modes_identifier)
			fprintf (cf, "\tIdentifier     \"%s\"\n", ptr->modes_identifier);
		for (mlptr = ptr->mon_modeline_lst; mlptr; mlptr = mlptr->list.next)
		{
			fprintf (cf, "\tModeLine     \"%s\" %2.1f ",
					 mlptr->ml_identifier, mlptr->ml_clock / 1000.0);
			fprintf (cf, "%d %d %d %d %d %d %d %d",
					 mlptr->ml_hdisplay, mlptr->ml_hsyncstart,
					 mlptr->ml_hsyncend, mlptr->ml_htotal,
					 mlptr->ml_vdisplay, mlptr->ml_vsyncstart,
					 mlptr->ml_vsyncend, mlptr->ml_vtotal);
			if (mlptr->ml_flags & XF86CONF_PHSYNC)
				fprintf (cf, " +hsync");
			if (mlptr->ml_flags & XF86CONF_NHSYNC)
				fprintf (cf, " -hsync");
			if (mlptr->ml_flags & XF86CONF_PVSYNC)
				fprintf (cf, " +vsync");
			if (mlptr->ml_flags & XF86CONF_NVSYNC)
				fprintf (cf, " -vsync");
			if (mlptr->ml_flags & XF86CONF_INTERLACE)
				fprintf (cf, " interlace");
			if (mlptr->ml_flags & XF86CONF_CSYNC)
				fprintf (cf, " composite");
			if (mlptr->ml_flags & XF86CONF_PCSYNC)
				fprintf (cf, " +csync");
			if (mlptr->ml_flags & XF86CONF_NCSYNC)
				fprintf (cf, " -csync");
			if (mlptr->ml_flags & XF86CONF_DBLSCAN)
				fprintf (cf, " doublescan");
			if (mlptr->ml_flags & XF86CONF_HSKEW)
				fprintf (cf, " hskew %d", mlptr->ml_hskew);
			if (mlptr->ml_flags & XF86CONF_VSCAN)
				fprintf (cf, " vscan %d", mlptr->ml_vscan);
			if (mlptr->ml_flags & XF86CONF_BCAST)
				fprintf (cf, " bcast");
			if (mlptr->ml_comment)
				fprintf (cf, "%s", mlptr->ml_comment);
			else
				fprintf (cf, "\n");
		}
		fprintf (cf, "EndSection\n\n");
		ptr = ptr->list.next;
	}
d777 1
a777 1
xf86freeMonitorList (XF86ConfMonitorPtr ptr)
d779 1
a779 1
	XF86ConfMonitorPtr prev;
d781 11
a791 12
	while (ptr)
	{
		TestFree (ptr->mon_identifier);
		TestFree (ptr->mon_vendor);
		TestFree (ptr->mon_modelname);
		TestFree (ptr->mon_comment);
		xf86optionListFree (ptr->mon_option_lst);
		xf86freeModeLineList (ptr->mon_modeline_lst);
		prev = ptr;
		ptr = ptr->list.next;
		free (prev);
	}
d795 1
a795 1
xf86freeModesList (XF86ConfModesPtr ptr)
d797 1
a797 1
	XF86ConfModesPtr prev;
d799 8
a806 9
	while (ptr)
	{
		TestFree (ptr->modes_identifier);
		TestFree (ptr->modes_comment);
		xf86freeModeLineList (ptr->mon_modeline_lst);
		prev = ptr;
		ptr = ptr->list.next;
		free (prev);
	}
d810 1
a810 1
xf86findMonitor (const char *ident, XF86ConfMonitorPtr p)
d812 7
a818 8
	while (p)
	{
		if (xf86nameCompare (ident, p->mon_identifier) == 0)
			return p;

		p = p->list.next;
	}
	return NULL;
d822 1
a822 1
xf86findModes (const char *ident, XF86ConfModesPtr p)
d824 7
a830 8
	while (p)
	{
		if (xf86nameCompare (ident, p->modes_identifier) == 0)
			return p;

		p = p->list.next;
	}
	return NULL;
d834 1
a834 1
xf86findModeLine (const char *ident, XF86ConfModeLinePtr p)
d836 7
a842 8
	while (p)
	{
		if (xf86nameCompare (ident, p->ml_identifier) == 0)
			return p;

		p = p->list.next;
	}
	return NULL;
d846 1
a846 1
xf86validateMonitor (XF86ConfigPtr p, XF86ConfScreenPtr screen)
d848 16
a863 17
	XF86ConfMonitorPtr monitor = screen->scrn_monitor;
	XF86ConfModesLinkPtr modeslnk = monitor->mon_modes_sect_lst;
	XF86ConfModesPtr modes;
	while(modeslnk)
	{
		modes = xf86findModes (modeslnk->ml_modes_str, p->conf_modes_lst);
		if (!modes)
		{
			xf86validationError (UNDEFINED_MODES_MSG, 
					     modeslnk->ml_modes_str, 
					     screen->scrn_identifier);
			return FALSE;
		}
		modeslnk->ml_modes = modes;
		modeslnk = modeslnk->list.next;
	}
	return TRUE;
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a107 1
	{TT_CUSTOM, "CUSTOM"},
a248 3
		case TT_CUSTOM:
			ptr->ml_flags |= XF86CONF_CUSTOM;
			break;
a367 3
					break;
				case TT_CUSTOM:
					ptr->ml_flags |= XF86CONF_CUSTOM;
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d267 1
a267 1
	return (ptr);
d416 1
a416 1
	return (ptr);
d851 1
a851 1
			return (p);
d855 1
a855 1
	return (NULL);
d864 1
a864 1
			return (p);
d868 1
a868 1
	return (NULL);
d877 1
a877 1
			return (p);
d881 1
a881 1
	return (NULL);
d898 1
a898 1
			return (FALSE);
d903 1
a903 1
	return (TRUE);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d137 1
a137 1
		xf86conffree (prev);
d583 1
a583 1
				mptr = xf86confcalloc (1, sizeof (XF86ConfModesLinkRec));
d825 1
a825 1
		xf86conffree (prev);
d841 1
a841 1
		xf86conffree (prev);
@


1.1
log
@Initial revision
@
text
@d127 15
a141 1
XF86ConfModeLinePtr
d270 1
a270 1
XF86ConfModeLinePtr
a690 2
		if ( ptr->mon_n_hsync || ptr->mon_n_vrefresh )
		    fprintf(cf," ### Comment all HorizSync and VertRefresh values to use DDC:\n");
a838 14
		prev = ptr;
		ptr = ptr->list.next;
		xf86conffree (prev);
	}
}

void
xf86freeModeLineList (XF86ConfModeLinePtr ptr)
{
	XF86ConfModeLinePtr prev;
	while (ptr)
	{
		TestFree (ptr->ml_identifier);
		TestFree (ptr->ml_comment);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d127 1
a127 15
static void
xf86freeModeLineList (XF86ConfModeLinePtr ptr)
{
	XF86ConfModeLinePtr prev;
	while (ptr)
	{
		TestFree (ptr->ml_identifier);
		TestFree (ptr->ml_comment);
		prev = ptr;
		ptr = ptr->list.next;
		xf86conffree (prev);
	}
}

static XF86ConfModeLinePtr
d256 1
a256 1
static XF86ConfModeLinePtr
d827 14
@

