head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.8
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.6
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.20.55;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.20.55;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.58.13;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *
 * Copyright (c) 1997  Metro Link Incorporated
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of the Metro Link shall not be
 * used in advertising or otherwise to promote the sale, use or other dealings
 * in this Software without prior written authorization from Metro Link.
 *
 */
/*
 * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "xf86Parser.h"
#include "xf86tokens.h"
#include "Configint.h"
#include <string.h>
#include "optionstr.h"

/* Needed for auto server layout */
extern int xf86CheckBoolOption(void *optlist, const char *name, int deflt);


static xf86ConfigSymTabRec LayoutTab[] = {
    {ENDSECTION, "endsection"},
    {SCREEN, "screen"},
    {IDENTIFIER, "identifier"},
    {MATCHSEAT, "matchseat"},
    {INACTIVE, "inactive"},
    {INPUTDEVICE, "inputdevice"},
    {OPTION, "option"},
    {-1, ""},
};

static xf86ConfigSymTabRec AdjTab[] = {
    {RIGHTOF, "rightof"},
    {LEFTOF, "leftof"},
    {ABOVE, "above"},
    {BELOW, "below"},
    {RELATIVE, "relative"},
    {ABSOLUTE, "absolute"},
    {-1, ""},
};

#define CLEANUP xf86freeLayoutList

XF86ConfLayoutPtr
xf86parseLayoutSection(void)
{
    int has_ident = FALSE;
    int token;

    parsePrologue(XF86ConfLayoutPtr, XF86ConfLayoutRec)

        while ((token = xf86getToken(LayoutTab)) != ENDSECTION) {
        switch (token) {
        case COMMENT:
            ptr->lay_comment = xf86addComment(ptr->lay_comment, xf86_lex_val.str);
            break;
        case IDENTIFIER:
            if (xf86getSubToken(&(ptr->lay_comment)) != STRING)
                Error(QUOTE_MSG, "Identifier");
            if (has_ident == TRUE)
                Error(MULTIPLE_MSG, "Identifier");
            ptr->lay_identifier = xf86_lex_val.str;
            has_ident = TRUE;
            break;
        case MATCHSEAT:
            if (xf86getSubToken(&(ptr->lay_comment)) != STRING)
                Error(QUOTE_MSG, "MatchSeat");
            ptr->match_seat = xf86_lex_val.str;
            break;
        case INACTIVE:
        {
            XF86ConfInactivePtr iptr;

            iptr = calloc(1, sizeof(XF86ConfInactiveRec));
            iptr->list.next = NULL;
            if (xf86getSubToken(&(ptr->lay_comment)) != STRING) {
                free(iptr);
                Error(INACTIVE_MSG);
            }
            iptr->inactive_device_str = xf86_lex_val.str;
            ptr->lay_inactive_lst = (XF86ConfInactivePtr)
                xf86addListItem((glp) ptr->lay_inactive_lst, (glp) iptr);
        }
            break;
        case SCREEN:
        {
            XF86ConfAdjacencyPtr aptr;
            int absKeyword = 0;

            aptr = calloc(1, sizeof(XF86ConfAdjacencyRec));
            aptr->list.next = NULL;
            aptr->adj_scrnum = -1;
            aptr->adj_where = CONF_ADJ_OBSOLETE;
            aptr->adj_x = 0;
            aptr->adj_y = 0;
            aptr->adj_refscreen = NULL;
            if ((token = xf86getSubToken(&(ptr->lay_comment))) == NUMBER)
                aptr->adj_scrnum = xf86_lex_val.num;
            else
                xf86unGetToken(token);
            token = xf86getSubToken(&(ptr->lay_comment));
            if (token != STRING) {
                free(aptr);
                Error(SCREEN_MSG);
            }
            aptr->adj_screen_str = xf86_lex_val.str;

            token = xf86getSubTokenWithTab(&(ptr->lay_comment), AdjTab);
            switch (token) {
            case RIGHTOF:
                aptr->adj_where = CONF_ADJ_RIGHTOF;
                break;
            case LEFTOF:
                aptr->adj_where = CONF_ADJ_LEFTOF;
                break;
            case ABOVE:
                aptr->adj_where = CONF_ADJ_ABOVE;
                break;
            case BELOW:
                aptr->adj_where = CONF_ADJ_BELOW;
                break;
            case RELATIVE:
                aptr->adj_where = CONF_ADJ_RELATIVE;
                break;
            case ABSOLUTE:
                aptr->adj_where = CONF_ADJ_ABSOLUTE;
                absKeyword = 1;
                break;
            case EOF_TOKEN:
                free(aptr);
                Error(UNEXPECTED_EOF_MSG);
                break;
            default:
                xf86unGetToken(token);
                token = xf86getSubToken(&(ptr->lay_comment));
                if (token == STRING)
                    aptr->adj_where = CONF_ADJ_OBSOLETE;
                else
                    aptr->adj_where = CONF_ADJ_ABSOLUTE;
            }
            switch (aptr->adj_where) {
            case CONF_ADJ_ABSOLUTE:
                if (absKeyword)
                    token = xf86getSubToken(&(ptr->lay_comment));
                if (token == NUMBER) {
                    aptr->adj_x = xf86_lex_val.num;
                    token = xf86getSubToken(&(ptr->lay_comment));
                    if (token != NUMBER) {
                        free(aptr);
                        Error(INVALID_SCR_MSG);
                    }
                    aptr->adj_y = xf86_lex_val.num;
                }
                else {
                    if (absKeyword) {
                        free(aptr);
                        Error(INVALID_SCR_MSG);
                    }
                    else
                        xf86unGetToken(token);
                }
                break;
            case CONF_ADJ_RIGHTOF:
            case CONF_ADJ_LEFTOF:
            case CONF_ADJ_ABOVE:
            case CONF_ADJ_BELOW:
            case CONF_ADJ_RELATIVE:
                token = xf86getSubToken(&(ptr->lay_comment));
                if (token != STRING) {
                    free(aptr);
                    Error(INVALID_SCR_MSG);
                }
                aptr->adj_refscreen = xf86_lex_val.str;
                if (aptr->adj_where == CONF_ADJ_RELATIVE) {
                    token = xf86getSubToken(&(ptr->lay_comment));
                    if (token != NUMBER) {
                        free(aptr);
                        Error(INVALID_SCR_MSG);
                    }
                    aptr->adj_x = xf86_lex_val.num;
                    token = xf86getSubToken(&(ptr->lay_comment));
                    if (token != NUMBER) {
                        free(aptr);
                        Error(INVALID_SCR_MSG);
                    }
                    aptr->adj_y = xf86_lex_val.num;
                }
                break;
            case CONF_ADJ_OBSOLETE:
                /* top */
                aptr->adj_top_str = xf86_lex_val.str;

                /* bottom */
                if (xf86getSubToken(&(ptr->lay_comment)) != STRING) {
                    free(aptr);
                    Error(SCREEN_MSG);
                }
                aptr->adj_bottom_str = xf86_lex_val.str;

                /* left */
                if (xf86getSubToken(&(ptr->lay_comment)) != STRING) {
                    free(aptr);
                    Error(SCREEN_MSG);
                }
                aptr->adj_left_str = xf86_lex_val.str;

                /* right */
                if (xf86getSubToken(&(ptr->lay_comment)) != STRING) {
                    free(aptr);
                    Error(SCREEN_MSG);
                }
                aptr->adj_right_str = xf86_lex_val.str;

            }
            ptr->lay_adjacency_lst = (XF86ConfAdjacencyPtr)
                xf86addListItem((glp) ptr->lay_adjacency_lst, (glp) aptr);
        }
            break;
        case INPUTDEVICE:
        {
            XF86ConfInputrefPtr iptr;

            iptr = calloc(1, sizeof(XF86ConfInputrefRec));
            iptr->list.next = NULL;
            iptr->iref_option_lst = NULL;
            if (xf86getSubToken(&(ptr->lay_comment)) != STRING) {
                free(iptr);
                Error(INPUTDEV_MSG);
            }
            iptr->iref_inputdev_str = xf86_lex_val.str;
            while ((token = xf86getSubToken(&(ptr->lay_comment))) == STRING) {
                iptr->iref_option_lst =
                    xf86addNewOption(iptr->iref_option_lst, xf86_lex_val.str, NULL);
            }
            xf86unGetToken(token);
            ptr->lay_input_lst = (XF86ConfInputrefPtr)
                xf86addListItem((glp) ptr->lay_input_lst, (glp) iptr);
        }
            break;
        case OPTION:
            ptr->lay_option_lst = xf86parseOption(ptr->lay_option_lst);
            break;
        case EOF_TOKEN:
            Error(UNEXPECTED_EOF_MSG);
            break;
        default:
            Error(INVALID_KEYWORD_MSG, xf86tokenString());
            break;
        }
    }

    if (!has_ident)
        Error(NO_IDENT_MSG);

#ifdef DEBUG
    printf("Layout section parsed\n");
#endif

    return ptr;
}

#undef CLEANUP

void
xf86printLayoutSection(FILE * cf, XF86ConfLayoutPtr ptr)
{
    XF86ConfAdjacencyPtr aptr;
    XF86ConfInactivePtr iptr;
    XF86ConfInputrefPtr inptr;
    XF86OptionPtr optr;

    while (ptr) {
        fprintf(cf, "Section \"ServerLayout\"\n");
        if (ptr->lay_comment)
            fprintf(cf, "%s", ptr->lay_comment);
        if (ptr->lay_identifier)
            fprintf(cf, "\tIdentifier     \"%s\"\n", ptr->lay_identifier);

        for (aptr = ptr->lay_adjacency_lst; aptr; aptr = aptr->list.next) {
            fprintf(cf, "\tScreen     ");
            if (aptr->adj_scrnum >= 0)
                fprintf(cf, "%2d", aptr->adj_scrnum);
            else
                fprintf(cf, "  ");
            fprintf(cf, "  \"%s\"", aptr->adj_screen_str);
            switch (aptr->adj_where) {
            case CONF_ADJ_OBSOLETE:
                fprintf(cf, " \"%s\"", aptr->adj_top_str);
                fprintf(cf, " \"%s\"", aptr->adj_bottom_str);
                fprintf(cf, " \"%s\"", aptr->adj_right_str);
                fprintf(cf, " \"%s\"\n", aptr->adj_left_str);
                break;
            case CONF_ADJ_ABSOLUTE:
                if (aptr->adj_x != -1)
                    fprintf(cf, " %d %d\n", aptr->adj_x, aptr->adj_y);
                else
                    fprintf(cf, "\n");
                break;
            case CONF_ADJ_RIGHTOF:
                fprintf(cf, " RightOf \"%s\"\n", aptr->adj_refscreen);
                break;
            case CONF_ADJ_LEFTOF:
                fprintf(cf, " LeftOf \"%s\"\n", aptr->adj_refscreen);
                break;
            case CONF_ADJ_ABOVE:
                fprintf(cf, " Above \"%s\"\n", aptr->adj_refscreen);
                break;
            case CONF_ADJ_BELOW:
                fprintf(cf, " Below \"%s\"\n", aptr->adj_refscreen);
                break;
            case CONF_ADJ_RELATIVE:
                fprintf(cf, " Relative \"%s\" %d %d\n", aptr->adj_refscreen,
                        aptr->adj_x, aptr->adj_y);
                break;
            }
        }
        for (iptr = ptr->lay_inactive_lst; iptr; iptr = iptr->list.next)
            fprintf(cf, "\tInactive       \"%s\"\n", iptr->inactive_device_str);
        for (inptr = ptr->lay_input_lst; inptr; inptr = inptr->list.next) {
            fprintf(cf, "\tInputDevice    \"%s\"", inptr->iref_inputdev_str);
            for (optr = inptr->iref_option_lst; optr; optr = optr->list.next) {
                fprintf(cf, " \"%s\"", optr->opt_name);
            }
            fprintf(cf, "\n");
        }
        xf86printOptionList(cf, ptr->lay_option_lst, 1);
        fprintf(cf, "EndSection\n\n");
        ptr = ptr->list.next;
    }
}

static void
xf86freeAdjacencyList(XF86ConfAdjacencyPtr ptr)
{
    XF86ConfAdjacencyPtr prev;

    while (ptr) {
        TestFree(ptr->adj_screen_str);
        TestFree(ptr->adj_top_str);
        TestFree(ptr->adj_bottom_str);
        TestFree(ptr->adj_left_str);
        TestFree(ptr->adj_right_str);

        prev = ptr;
        ptr = ptr->list.next;
        free(prev);
    }

}

static void
xf86freeInputrefList(XF86ConfInputrefPtr ptr)
{
    XF86ConfInputrefPtr prev;

    while (ptr) {
        TestFree(ptr->iref_inputdev_str);
        xf86optionListFree(ptr->iref_option_lst);
        prev = ptr;
        ptr = ptr->list.next;
        free(prev);
    }

}

void
xf86freeLayoutList(XF86ConfLayoutPtr ptr)
{
    XF86ConfLayoutPtr prev;

    while (ptr) {
        TestFree(ptr->lay_identifier);
        TestFree(ptr->lay_comment);
        xf86freeAdjacencyList(ptr->lay_adjacency_lst);
        xf86freeInputrefList(ptr->lay_input_lst);
        prev = ptr;
        ptr = ptr->list.next;
        free(prev);
    }
}

int
xf86layoutAddInputDevices(XF86ConfigPtr config, XF86ConfLayoutPtr layout)
{
    int count = 0;
    XF86ConfInputPtr input = config->conf_input_lst;
    XF86ConfInputrefPtr inptr;

    /* add all AutoServerLayout devices to the server layout */
    while (input) {
        if (xf86CheckBoolOption
            (input->inp_option_lst, "AutoServerLayout", FALSE)) {
            XF86ConfInputrefPtr iref = layout->lay_input_lst;

            /* avoid duplicates if referenced but lists AutoServerLayout too */
            while (iref) {
                if (strcmp(iref->iref_inputdev_str, input->inp_identifier) == 0)
                    break;
                iref = iref->list.next;
            }

            if (!iref) {
                XF86ConfInputrefPtr iptr;

                iptr = calloc(1, sizeof(XF86ConfInputrefRec));
                iptr->iref_inputdev_str = input->inp_identifier;
                layout->lay_input_lst = (XF86ConfInputrefPtr)
                    xf86addListItem((glp) layout->lay_input_lst, (glp) iptr);
                count++;
            }
        }
        input = input->list.next;
    }

    inptr = layout->lay_input_lst;
    while (inptr) {
        input = xf86findInput(inptr->iref_inputdev_str, config->conf_input_lst);
        if (!input) {
            xf86validationError(UNDEFINED_INPUT_MSG,
                                inptr->iref_inputdev_str,
                                layout->lay_identifier);
            return -1;
        }
        else
            inptr->iref_inputdev = input;
        inptr = inptr->list.next;
    }

    return count;
}

int
xf86validateLayout(XF86ConfigPtr p)
{
    XF86ConfLayoutPtr layout = p->conf_layout_lst;
    XF86ConfAdjacencyPtr adj;
    XF86ConfInactivePtr iptr;
    XF86ConfScreenPtr screen;
    XF86ConfDevicePtr device;

    while (layout) {
        adj = layout->lay_adjacency_lst;
        while (adj) {
            /* the first one can't be "" but all others can */
            screen = xf86findScreen(adj->adj_screen_str, p->conf_screen_lst);
            if (!screen) {
                xf86validationError(UNDEFINED_SCREEN_MSG,
                                    adj->adj_screen_str,
                                    layout->lay_identifier);
                return FALSE;
            }
            else
                adj->adj_screen = screen;

            adj = adj->list.next;
        }
        iptr = layout->lay_inactive_lst;
        while (iptr) {
            device = xf86findDevice(iptr->inactive_device_str,
                                    p->conf_device_lst);
            if (!device) {
                xf86validationError(UNDEFINED_DEVICE_LAY_MSG,
                                    iptr->inactive_device_str,
                                    layout->lay_identifier);
                return FALSE;
            }
            else
                iptr->inactive_device = device;
            iptr = iptr->list.next;
        }

        if (xf86layoutAddInputDevices(p, layout) == -1)
            return FALSE;

        layout = layout->list.next;
    }
    return TRUE;
}

XF86ConfLayoutPtr
xf86findLayout(const char *name, XF86ConfLayoutPtr list)
{
    while (list) {
        if (xf86nameCompare(list->lay_identifier, name) == 0)
            return list;
        list = list->list.next;
    }
    return NULL;
}
@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1 2
a2 2
/* 
 * 
d4 1
a4 1
 * 
d6 1
a6 1
 * copy of this software and associated documentation files (the "Software"), 
d11 1
a11 1
 * 
d14 1
a14 1
 * 
d22 1
a22 1
 * 
d26 1
a26 1
 * 
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a67 1
extern LexRec val;
d73 1
d103 1
a103 1
            ptr->lay_comment = xf86addComment(ptr->lay_comment, val.str);
d110 1
a110 1
            ptr->lay_identifier = val.str;
d113 5
d128 1
a128 1
            iptr->inactive_device_str = val.str;
d146 1
a146 1
                aptr->adj_scrnum = val.num;
d154 1
a154 1
            aptr->adj_screen_str = val.str;
d194 1
a194 1
                    aptr->adj_x = val.num;
d200 1
a200 1
                    aptr->adj_y = val.num;
d221 1
a221 1
                aptr->adj_refscreen = val.str;
d228 1
a228 1
                    aptr->adj_x = val.num;
d234 1
a234 1
                    aptr->adj_y = val.num;
d239 1
a239 1
                aptr->adj_top_str = val.str;
d246 1
a246 1
                aptr->adj_bottom_str = val.str;
d253 1
a253 1
                aptr->adj_left_str = val.str;
d260 1
a260 1
                aptr->adj_right_str = val.str;
d278 1
a278 1
            iptr->iref_inputdev_str = val.str;
d281 1
a281 1
                    xf86addNewOption(iptr->iref_option_lst, val.str, NULL);
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a54 2
/* View/edit this file with tab stops set to 4 */

@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a54 1

d65 1
a65 1

d68 1
a68 1
extern int xf86CheckBoolOption(void* optlist, const char *name, int deflt);
d72 8
a79 9
static xf86ConfigSymTabRec LayoutTab[] =
{
	{ENDSECTION, "endsection"},
	{SCREEN, "screen"},
	{IDENTIFIER, "identifier"},
	{INACTIVE, "inactive"},
	{INPUTDEVICE, "inputdevice"},
	{OPTION, "option"},
	{-1, ""},
d82 8
a89 9
static xf86ConfigSymTabRec AdjTab[] =
{
	{RIGHTOF, "rightof"},
	{LEFTOF, "leftof"},
	{ABOVE, "above"},
	{BELOW, "below"},
	{RELATIVE, "relative"},
	{ABSOLUTE, "absolute"},
	{-1, ""},
d95 1
a95 1
xf86parseLayoutSection (void)
d97 2
a98 203
	int has_ident = FALSE;
	int token;
	parsePrologue (XF86ConfLayoutPtr, XF86ConfLayoutRec)

	while ((token = xf86getToken (LayoutTab)) != ENDSECTION)
	{
		switch (token)
		{
		case COMMENT:
			ptr->lay_comment = xf86addComment(ptr->lay_comment, val.str);
			break;
		case IDENTIFIER:
			if (xf86getSubToken (&(ptr->lay_comment)) != STRING)
				Error (QUOTE_MSG, "Identifier");
			if (has_ident == TRUE)
				Error (MULTIPLE_MSG, "Identifier");
			ptr->lay_identifier = val.str;
			has_ident = TRUE;
			break;
		case INACTIVE:
			{
				XF86ConfInactivePtr iptr;

				iptr = calloc (1, sizeof (XF86ConfInactiveRec));
				iptr->list.next = NULL;
				if (xf86getSubToken (&(ptr->lay_comment)) != STRING) {
					free (iptr);
					Error (INACTIVE_MSG, NULL);
				}
				iptr->inactive_device_str = val.str;
				ptr->lay_inactive_lst = (XF86ConfInactivePtr)
					xf86addListItem ((glp) ptr->lay_inactive_lst, (glp) iptr);
			}
			break;
		case SCREEN:
			{
				XF86ConfAdjacencyPtr aptr;
				int absKeyword = 0;

				aptr = calloc (1, sizeof (XF86ConfAdjacencyRec));
				aptr->list.next = NULL;
				aptr->adj_scrnum = -1;
				aptr->adj_where = CONF_ADJ_OBSOLETE;
				aptr->adj_x = 0;
				aptr->adj_y = 0;
				aptr->adj_refscreen = NULL;
				if ((token = xf86getSubToken (&(ptr->lay_comment))) == NUMBER)
					aptr->adj_scrnum = val.num;
				else
					xf86unGetToken (token);
				token = xf86getSubToken(&(ptr->lay_comment));
				if (token != STRING) {
					free(aptr);
					Error (SCREEN_MSG, NULL);
				}
				aptr->adj_screen_str = val.str;

				token = xf86getSubTokenWithTab(&(ptr->lay_comment), AdjTab);
				switch (token)
				{
				case RIGHTOF:
					aptr->adj_where = CONF_ADJ_RIGHTOF;
					break;
				case LEFTOF:
					aptr->adj_where = CONF_ADJ_LEFTOF;
					break;
				case ABOVE:
					aptr->adj_where = CONF_ADJ_ABOVE;
					break;
				case BELOW:
					aptr->adj_where = CONF_ADJ_BELOW;
					break;
				case RELATIVE:
					aptr->adj_where = CONF_ADJ_RELATIVE;
					break;
				case ABSOLUTE:
					aptr->adj_where = CONF_ADJ_ABSOLUTE;
					absKeyword = 1;
					break;
				case EOF_TOKEN:
					free(aptr);
					Error (UNEXPECTED_EOF_MSG, NULL);
					break;
				default:
					xf86unGetToken (token);
					token = xf86getSubToken(&(ptr->lay_comment));
					if (token == STRING)
						aptr->adj_where = CONF_ADJ_OBSOLETE;
					else
						aptr->adj_where = CONF_ADJ_ABSOLUTE;
				}
				switch (aptr->adj_where)
				{
				case CONF_ADJ_ABSOLUTE:
					if (absKeyword) 
						token = xf86getSubToken(&(ptr->lay_comment));
					if (token == NUMBER)
					{
						aptr->adj_x = val.num;
						token = xf86getSubToken(&(ptr->lay_comment));
						if (token != NUMBER) {
							free(aptr);
							Error(INVALID_SCR_MSG, NULL);
						}
						aptr->adj_y = val.num;
					} else {
						if (absKeyword) {
							free(aptr);
							Error(INVALID_SCR_MSG, NULL);
						} else
							xf86unGetToken (token);
					}
					break;
				case CONF_ADJ_RIGHTOF:
				case CONF_ADJ_LEFTOF:
				case CONF_ADJ_ABOVE:
				case CONF_ADJ_BELOW:
				case CONF_ADJ_RELATIVE:
					token = xf86getSubToken(&(ptr->lay_comment));
					if (token != STRING) {
						free(aptr);
						Error(INVALID_SCR_MSG, NULL);
					}
					aptr->adj_refscreen = val.str;
					if (aptr->adj_where == CONF_ADJ_RELATIVE)
					{
						token = xf86getSubToken(&(ptr->lay_comment));
						if (token != NUMBER) {
							free(aptr);
							Error(INVALID_SCR_MSG, NULL);
						}
						aptr->adj_x = val.num;
						token = xf86getSubToken(&(ptr->lay_comment));
						if (token != NUMBER) {
							free(aptr);
							Error(INVALID_SCR_MSG, NULL);
						}
						aptr->adj_y = val.num;
					}
					break;
				case CONF_ADJ_OBSOLETE:
					/* top */
					aptr->adj_top_str = val.str;

					/* bottom */
					if (xf86getSubToken (&(ptr->lay_comment)) != STRING) {
						free(aptr);
						Error (SCREEN_MSG, NULL);
					}
					aptr->adj_bottom_str = val.str;

					/* left */
					if (xf86getSubToken (&(ptr->lay_comment)) != STRING) {
						free(aptr);
						Error (SCREEN_MSG, NULL);
					}
					aptr->adj_left_str = val.str;

					/* right */
					if (xf86getSubToken (&(ptr->lay_comment)) != STRING) {
						free(aptr);
						Error (SCREEN_MSG, NULL);
					}
					aptr->adj_right_str = val.str;

				}
				ptr->lay_adjacency_lst = (XF86ConfAdjacencyPtr)
					xf86addListItem ((glp) ptr->lay_adjacency_lst, (glp) aptr);
			}
			break;
		case INPUTDEVICE:
			{
				XF86ConfInputrefPtr iptr;

				iptr = calloc (1, sizeof (XF86ConfInputrefRec));
				iptr->list.next = NULL;
				iptr->iref_option_lst = NULL;
				if (xf86getSubToken (&(ptr->lay_comment)) != STRING) {
					free(iptr);
					Error (INPUTDEV_MSG, NULL);
				}
				iptr->iref_inputdev_str = val.str;
				while ((token = xf86getSubToken (&(ptr->lay_comment))) == STRING)
				{
					iptr->iref_option_lst =
						xf86addNewOption (iptr->iref_option_lst, val.str, NULL);
				}
				xf86unGetToken (token);
				ptr->lay_input_lst = (XF86ConfInputrefPtr)
					xf86addListItem ((glp) ptr->lay_input_lst, (glp) iptr);
			}
			break;
		case OPTION:
			ptr->lay_option_lst = xf86parseOption(ptr->lay_option_lst);
			break;
		case EOF_TOKEN:
			Error (UNEXPECTED_EOF_MSG, NULL);
			break;
		default:
			Error (INVALID_KEYWORD_MSG, xf86tokenString ());
			break;
		}
	}
d100 199
a298 2
	if (!has_ident)
		Error (NO_IDENT_MSG, NULL);
d301 1
a301 1
	printf ("Layout section parsed\n");
d304 1
a304 1
	return ptr;
d310 1
a310 1
xf86printLayoutSection (FILE * cf, XF86ConfLayoutPtr ptr)
d312 63
a374 68
	XF86ConfAdjacencyPtr aptr;
	XF86ConfInactivePtr iptr;
	XF86ConfInputrefPtr inptr;
	XF86OptionPtr optr;

	while (ptr)
	{
		fprintf (cf, "Section \"ServerLayout\"\n");
		if (ptr->lay_comment)
			fprintf (cf, "%s", ptr->lay_comment);
		if (ptr->lay_identifier)
			fprintf (cf, "\tIdentifier     \"%s\"\n", ptr->lay_identifier);

		for (aptr = ptr->lay_adjacency_lst; aptr; aptr = aptr->list.next)
		{
			fprintf (cf, "\tScreen     ");
			if (aptr->adj_scrnum >= 0)
				fprintf (cf, "%2d", aptr->adj_scrnum);
			else
				fprintf (cf, "  ");
			fprintf (cf, "  \"%s\"", aptr->adj_screen_str);
			switch(aptr->adj_where)
			{
			case CONF_ADJ_OBSOLETE:
				fprintf (cf, " \"%s\"", aptr->adj_top_str);
				fprintf (cf, " \"%s\"", aptr->adj_bottom_str);
				fprintf (cf, " \"%s\"", aptr->adj_right_str);
				fprintf (cf, " \"%s\"\n", aptr->adj_left_str);
				break;
			case CONF_ADJ_ABSOLUTE:
				if (aptr->adj_x != -1)
					fprintf (cf, " %d %d\n", aptr->adj_x, aptr->adj_y);
				else
					fprintf (cf, "\n");
				break;
			case CONF_ADJ_RIGHTOF:
				fprintf (cf, " RightOf \"%s\"\n", aptr->adj_refscreen);
				break;
			case CONF_ADJ_LEFTOF:
				fprintf (cf, " LeftOf \"%s\"\n", aptr->adj_refscreen);
				break;
			case CONF_ADJ_ABOVE:
				fprintf (cf, " Above \"%s\"\n", aptr->adj_refscreen);
				break;
			case CONF_ADJ_BELOW:
				fprintf (cf, " Below \"%s\"\n", aptr->adj_refscreen);
				break;
			case CONF_ADJ_RELATIVE:
				fprintf (cf, " Relative \"%s\" %d %d\n", aptr->adj_refscreen,
						 aptr->adj_x, aptr->adj_y);
				break;
			}
		}
		for (iptr = ptr->lay_inactive_lst; iptr; iptr = iptr->list.next)
			fprintf (cf, "\tInactive       \"%s\"\n", iptr->inactive_device_str);
		for (inptr = ptr->lay_input_lst; inptr; inptr = inptr->list.next)
		{
			fprintf (cf, "\tInputDevice    \"%s\"", inptr->iref_inputdev_str);
			for (optr = inptr->iref_option_lst; optr; optr = optr->list.next)
			{
				fprintf(cf, " \"%s\"", optr->opt_name);
			}
			fprintf(cf, "\n");
		}
		xf86printOptionList(cf, ptr->lay_option_lst, 1);
		fprintf (cf, "EndSection\n\n");
		ptr = ptr->list.next;
	}
d378 1
a378 1
xf86freeAdjacencyList (XF86ConfAdjacencyPtr ptr)
d380 1
a380 1
	XF86ConfAdjacencyPtr prev;
d382 11
a392 12
	while (ptr)
	{
		TestFree (ptr->adj_screen_str);
		TestFree (ptr->adj_top_str);
		TestFree (ptr->adj_bottom_str);
		TestFree (ptr->adj_left_str);
		TestFree (ptr->adj_right_str);

		prev = ptr;
		ptr = ptr->list.next;
		free (prev);
	}
d397 1
a397 1
xf86freeInputrefList (XF86ConfInputrefPtr ptr)
d399 1
a399 1
	XF86ConfInputrefPtr prev;
d401 7
a407 8
	while (ptr)
	{
		TestFree (ptr->iref_inputdev_str);
		xf86optionListFree (ptr->iref_option_lst);
		prev = ptr;
		ptr = ptr->list.next;
		free (prev);
	}
d412 1
a412 1
xf86freeLayoutList (XF86ConfLayoutPtr ptr)
d414 1
a414 1
	XF86ConfLayoutPtr prev;
d416 9
a424 10
	while (ptr)
	{
		TestFree (ptr->lay_identifier);
		TestFree (ptr->lay_comment);
		xf86freeAdjacencyList (ptr->lay_adjacency_lst);
		xf86freeInputrefList (ptr->lay_input_lst);
		prev = ptr;
		ptr = ptr->list.next;
		free (prev);
	}
d435 23
a457 25
    while (input)
    {
	if (xf86CheckBoolOption(input->inp_option_lst, "AutoServerLayout", FALSE))
	{
	    XF86ConfInputrefPtr iref = layout->lay_input_lst;

	    /* avoid duplicates if referenced but lists AutoServerLayout too */
	    while (iref)
	    {
		if (strcmp(iref->iref_inputdev_str, input->inp_identifier) == 0)
		    break;
		iref = iref->list.next;
	    }

	    if (!iref)
	    {
		XF86ConfInputrefPtr iptr;
		iptr = calloc(1, sizeof(XF86ConfInputrefRec));
		iptr->iref_inputdev_str = input->inp_identifier;
		layout->lay_input_lst = (XF86ConfInputrefPtr)
		    xf86addListItem((glp)layout->lay_input_lst, (glp)iptr);
		count++;
	    }
	}
	input = input->list.next;
d461 11
a471 13
    while (inptr)
    {
	input = xf86findInput (inptr->iref_inputdev_str,
		config->conf_input_lst);
	if (!input)
	{
	    xf86validationError (UNDEFINED_INPUT_MSG,
		    inptr->iref_inputdev_str, layout->lay_identifier);
	    return -1;
	}
	else
	    inptr->iref_inputdev = input;
	inptr = inptr->list.next;
d478 1
a478 1
xf86validateLayout (XF86ConfigPtr p)
d480 43
a522 46
	XF86ConfLayoutPtr layout = p->conf_layout_lst;
	XF86ConfAdjacencyPtr adj;
	XF86ConfInactivePtr iptr;
	XF86ConfScreenPtr screen;
	XF86ConfDevicePtr device;

	while (layout)
	{
		adj = layout->lay_adjacency_lst;
		while (adj)
		{
			/* the first one can't be "" but all others can */
			screen = xf86findScreen (adj->adj_screen_str, p->conf_screen_lst);
			if (!screen)
			{
				xf86validationError (UNDEFINED_SCREEN_MSG,
							   adj->adj_screen_str, layout->lay_identifier);
				return FALSE;
			}
			else
				adj->adj_screen = screen;

			adj = adj->list.next;
		}
		iptr = layout->lay_inactive_lst;
		while (iptr)
		{
			device = xf86findDevice (iptr->inactive_device_str,
									p->conf_device_lst);
			if (!device)
			{
				xf86validationError (UNDEFINED_DEVICE_LAY_MSG,
						iptr->inactive_device_str, layout->lay_identifier);
				return FALSE;
			}
			else
				iptr->inactive_device = device;
			iptr = iptr->list.next;
		}

		if (xf86layoutAddInputDevices(p, layout) == -1)
		    return FALSE;

		layout = layout->list.next;
	}
	return TRUE;
d526 1
a526 1
xf86findLayout (const char *name, XF86ConfLayoutPtr list)
d528 6
a533 7
	while (list)
	{
		if (xf86nameCompare (list->lay_identifier, name) == 0)
			return list;
		list = list->list.next;
	}
	return NULL;
a534 1

@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d516 1
a516 1
				return (FALSE);
d532 1
a532 1
				return (FALSE);
d544 1
a544 1
	return (TRUE);
d553 1
a553 1
			return (list);
d556 1
a556 1
	return (NULL);
@


1.1
log
@Initial revision
@
text
@d67 4
d123 1
a123 1
				iptr = xf86confcalloc (1, sizeof (XF86ConfInactiveRec));
d126 1
a126 1
					xf86conffree (iptr);
d139 1
a139 1
				aptr = xf86confcalloc (1, sizeof (XF86ConfAdjacencyRec));
d152 1
a152 1
					xf86conffree(aptr);
d180 1
a180 1
					xf86conffree(aptr);
d201 1
a201 1
							xf86conffree(aptr);
d207 1
a207 1
							xf86conffree(aptr);
d220 1
a220 1
						xf86conffree(aptr);
d228 1
a228 1
							xf86conffree(aptr);
d234 1
a234 1
							xf86conffree(aptr);
d246 1
a246 1
						xf86conffree(aptr);
d253 1
a253 1
						xf86conffree(aptr);
d260 1
a260 1
						xf86conffree(aptr);
d274 1
a274 1
				iptr = xf86confcalloc (1, sizeof (XF86ConfInputrefRec));
d278 1
a278 1
					xf86conffree(iptr);
d389 1
a389 18
void
xf86freeLayoutList (XF86ConfLayoutPtr ptr)
{
	XF86ConfLayoutPtr prev;

	while (ptr)
	{
		TestFree (ptr->lay_identifier);
		TestFree (ptr->lay_comment);
		xf86freeAdjacencyList (ptr->lay_adjacency_lst);
		xf86freeInputrefList (ptr->lay_input_lst);
		prev = ptr;
		ptr = ptr->list.next;
		xf86conffree (prev);
	}
}

void
d404 1
a404 1
		xf86conffree (prev);
d409 1
a409 1
void
d420 1
a420 1
		xf86conffree (prev);
d425 69
a493 12
#define CheckScreen(str, ptr)\
if (str[0] != '\0') \
{ \
screen = xf86findScreen (str, p->conf_screen_lst); \
if (!screen) \
{ \
	xf86validationError (UNDEFINED_SCREEN_MSG, \
				   str, layout->lay_identifier); \
	return (FALSE); \
} \
else \
	ptr = screen; \
a501 1
	XF86ConfInputrefPtr inptr;
a503 1
	XF86ConfInputPtr input;
a520 7
#if 0
			CheckScreen (adj->adj_top_str, adj->adj_top);
			CheckScreen (adj->adj_bottom_str, adj->adj_bottom);
			CheckScreen (adj->adj_left_str, adj->adj_left);
			CheckScreen (adj->adj_right_str, adj->adj_right);
#endif

d538 4
a541 15
		inptr = layout->lay_input_lst;
		while (inptr)
		{
			input = xf86findInput (inptr->iref_inputdev_str,
									p->conf_input_lst);
			if (!input)
			{
				xf86validationError (UNDEFINED_INPUT_MSG,
						inptr->iref_inputdev_str, layout->lay_identifier);
				return (FALSE);
			}
			else
				inptr->iref_inputdev = input;
			inptr = inptr->list.next;
		}
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d385 18
a402 1
static void
d422 1
a422 1
static void
a435 17
}

void
xf86freeLayoutList (XF86ConfLayoutPtr ptr)
{
	XF86ConfLayoutPtr prev;

	while (ptr)
	{
		TestFree (ptr->lay_identifier);
		TestFree (ptr->lay_comment);
		xf86freeAdjacencyList (ptr->lay_adjacency_lst);
		xf86freeInputrefList (ptr->lay_input_lst);
		prev = ptr;
		ptr = ptr->list.next;
		xf86conffree (prev);
	}
@

