head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.27;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.20.55;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.20.55;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.58.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright (c) 1997  Metro Link Incorporated
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of the Metro Link shall not be
 * used in advertising or otherwise to promote the sale, use or other dealings
 * in this Software without prior written authorization from Metro Link.
 *
 */
/*
 * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <dirent.h>
#include <unistd.h>
#include <stdarg.h>
#include <X11/Xdefs.h>
#include <X11/Xfuncproto.h>

#if defined(_POSIX_SOURCE)
#include <limits.h>
#else
#define _POSIX_SOURCE
#include <limits.h>
#undef _POSIX_SOURCE
#endif                          /* _POSIX_SOURCE */

#if !defined(MAXHOSTNAMELEN)
#define MAXHOSTNAMELEN 32
#endif                          /* !MAXHOSTNAMELEN */

/* For PATH_MAX */
#include "misc.h"

#include "Configint.h"
#include "xf86tokens.h"

#define CONFIG_BUF_LEN     1024
#define CONFIG_MAX_FILES   64

static int StringToToken(const char *, xf86ConfigSymTabRec *);

static struct {
    FILE *file;
    char *path;
} configFiles[CONFIG_MAX_FILES];
static const char **builtinConfig = NULL;
static int builtinIndex = 0;
static int configPos = 0;       /* current readers position */
static int configLineNo = 0;    /* linenumber */
static char *configBuf, *configRBuf;    /* buffer for lines */
static char *configSection = NULL;      /* name of current section being parsed */
static int numFiles = 0;        /* number of config files */
static int curFileIndex = 0;    /* index of current config file */
static int pushToken = LOCK_TOKEN;
static int eol_seen = 0;        /* private state to handle comments */
LexRec xf86_lex_val;

/*
 * xf86getNextLine --
 *
 *  read from the configFiles FILE stream until we encounter a new
 *  line; this is effectively just a big wrapper for fgets(3).
 *
 *  xf86getToken() assumes that we will read up to the next
 *  newline; we need to grow configBuf and configRBuf as needed to
 *  support that.
 */

static char *
xf86getNextLine(void)
{
    static int configBufLen = CONFIG_BUF_LEN;
    char *tmpConfigBuf, *tmpConfigRBuf;
    int c, i, pos = 0, eolFound = 0;
    char *ret = NULL;

    /*
     * reallocate the string if it was grown last time (i.e., is no
     * longer CONFIG_BUF_LEN); we malloc the new strings first, so
     * that if either of the mallocs fail, we can fall back on the
     * existing buffer allocations
     */

    if (configBufLen != CONFIG_BUF_LEN) {

        tmpConfigBuf = malloc(CONFIG_BUF_LEN);
        tmpConfigRBuf = malloc(CONFIG_BUF_LEN);

        if (!tmpConfigBuf || !tmpConfigRBuf) {

            /*
             * at least one of the mallocs failed; keep the old buffers
             * and free any partial allocations
             */

            free(tmpConfigBuf);
            free(tmpConfigRBuf);

        }
        else {

            /*
             * malloc succeeded; free the old buffers and use the new
             * buffers
             */

            configBufLen = CONFIG_BUF_LEN;

            free(configBuf);
            free(configRBuf);

            configBuf = tmpConfigBuf;
            configRBuf = tmpConfigRBuf;
        }
    }

    /* read in another block of chars */

    do {
        ret = fgets(configBuf + pos, configBufLen - pos - 1,
                    configFiles[curFileIndex].file);

        if (!ret) {
            /*
             * if the file doesn't end in a newline, add one
             * and trigger another read
             */
            if (pos != 0) {
                strcpy(&configBuf[pos], "\n");
                ret = configBuf;
            }
            else
                break;
        }

        /* search for EOL in the new block of chars */

        for (i = pos; i < (configBufLen - 1); i++) {
            c = configBuf[i];

            if (c == '\0')
                break;

            if ((c == '\n') || (c == '\r')) {
                eolFound = 1;
                break;
            }
        }

        /*
         * if we didn't find EOL, then grow the string and
         * read in more
         */

        if (!eolFound) {

            tmpConfigBuf = realloc(configBuf, configBufLen + CONFIG_BUF_LEN);
            tmpConfigRBuf = realloc(configRBuf, configBufLen + CONFIG_BUF_LEN);

            if (!tmpConfigBuf || !tmpConfigRBuf) {

                /*
                 * at least one of the reallocations failed; use the
                 * new allocation that succeeded, but we have to
                 * fallback to the previous configBufLen size and use
                 * the string we have, even though we don't have an
                 * EOL
                 */

                if (tmpConfigBuf)
                    configBuf = tmpConfigBuf;
                if (tmpConfigRBuf)
                    configRBuf = tmpConfigRBuf;

                break;

            }
            else {

                /* reallocation succeeded */

                configBuf = tmpConfigBuf;
                configRBuf = tmpConfigRBuf;
                pos = i;
                configBufLen += CONFIG_BUF_LEN;
            }
        }

    } while (!eolFound);

    return ret;
}

/*
 * xf86getToken --
 *      Read next Token from the config file. Handle the global variable
 *      pushToken.
 */
int
xf86getToken(xf86ConfigSymTabRec * tab)
{
    int c, i;

    /*
     * First check whether pushToken has a different value than LOCK_TOKEN.
     * In this case rBuf[] contains a valid STRING/TOKEN/NUMBER. But in the
     * oth * case the next token must be read from the input.
     */
    if (pushToken == EOF_TOKEN)
        return EOF_TOKEN;
    else if (pushToken == LOCK_TOKEN) {
        /*
         * eol_seen is only set for the first token after a newline.
         */
        eol_seen = 0;

        c = configBuf[configPos];

        /*
         * Get start of next Token. EOF is handled,
         * whitespaces are skipped.
         */

 again:
        if (!c) {
            char *ret;

            if (numFiles > 0)
                ret = xf86getNextLine();
            else {
                if (builtinConfig[builtinIndex] == NULL)
                    ret = NULL;
                else {
                    strlcpy(configBuf,
                            builtinConfig[builtinIndex], CONFIG_BUF_LEN);
                    ret = configBuf;
                    builtinIndex++;
                }
            }
            if (ret == NULL) {
                /*
                 * if necessary, move to the next file and
                 * read the first line
                 */
                if (curFileIndex + 1 < numFiles) {
                    curFileIndex++;
                    configLineNo = 0;
                    goto again;
                }
                else
                    return pushToken = EOF_TOKEN;
            }
            configLineNo++;
            configPos = 0;
            eol_seen = 1;
        }

        i = 0;
        for (;;) {
            c = configBuf[configPos++];
            configRBuf[i++] = c;
            switch (c) {
            case ' ':
            case '\t':
            case '\r':
                continue;
            case '\n':
                i = 0;
                continue;
            }
            break;
        }
        if (c == '\0')
            goto again;

        if (c == '#') {
            do {
                configRBuf[i++] = (c = configBuf[configPos++]);
            }
            while ((c != '\n') && (c != '\r') && (c != '\0'));
            configRBuf[i] = '\0';
            /* XXX no private copy.
             * Use xf86addComment when setting a comment.
             */
            xf86_lex_val.str = configRBuf;
            return COMMENT;
        }

        /* GJA -- handle '-' and ','  * Be careful: "-hsync" is a keyword. */
        else if ((c == ',') && !isalpha(configBuf[configPos])) {
            return COMMA;
        }
        else if ((c == '-') && !isalpha(configBuf[configPos])) {
            return DASH;
        }

        /*
         * Numbers are returned immediately ...
         */
        if (isdigit(c)) {
            int base;

            if (c == '0')
                if ((configBuf[configPos] == 'x') ||
                    (configBuf[configPos] == 'X')) {
                    base = 16;
                    xf86_lex_val.numType = PARSE_HEX;
                }
                else {
                    base = 8;
                    xf86_lex_val.numType = PARSE_OCTAL;
                }
            else {
                base = 10;
                xf86_lex_val.numType = PARSE_DECIMAL;
            }

            configRBuf[0] = c;
            i = 1;
            while (isdigit(c = configBuf[configPos++]) ||
                   (c == '.') || (c == 'x') || (c == 'X') ||
                   ((base == 16) && (((c >= 'a') && (c <= 'f')) ||
                                     ((c >= 'A') && (c <= 'F')))))
                configRBuf[i++] = c;
            configPos--;        /* GJA -- one too far */
            configRBuf[i] = '\0';
            xf86_lex_val.num = strtoul(configRBuf, NULL, 0);
            xf86_lex_val.realnum = atof(configRBuf);
            return NUMBER;
        }

        /*
         * All Strings START with a \" ...
         */
        else if (c == '\"') {
            i = -1;
            do {
                configRBuf[++i] = (c = configBuf[configPos++]);
            }
            while ((c != '\"') && (c != '\n') && (c != '\r') && (c != '\0'));
            configRBuf[i] = '\0';
            xf86_lex_val.str = malloc(strlen(configRBuf) + 1);
            strcpy(xf86_lex_val.str, configRBuf);        /* private copy ! */
            return STRING;
        }

        /*
         * ... and now we MUST have a valid token.  The search is
         * handled later along with the pushed tokens.
         */
        else {
            configRBuf[0] = c;
            i = 0;
            do {
                configRBuf[++i] = (c = configBuf[configPos++]);
            }
            while ((c != ' ') && (c != '\t') && (c != '\n') && (c != '\r') &&
                   (c != '\0') && (c != '#'));
            --configPos;
            configRBuf[i] = '\0';
            i = 0;
        }

    }
    else {

        /*
         * Here we deal with pushed tokens. Reinitialize pushToken again. If
         * the pushed token was NUMBER || STRING return them again ...
         */
        int temp = pushToken;

        pushToken = LOCK_TOKEN;

        if (temp == COMMA || temp == DASH)
            return temp;
        if (temp == NUMBER || temp == STRING)
            return temp;
    }

    /*
     * Joop, at last we have to lookup the token ...
     */
    if (tab) {
        i = 0;
        while (tab[i].token != -1)
            if (xf86nameCompare(configRBuf, tab[i].name) == 0)
                return tab[i].token;
            else
                i++;
    }

    return ERROR_TOKEN;         /* Error catcher */
}

int
xf86getSubToken(char **comment)
{
    int token;

    for (;;) {
        token = xf86getToken(NULL);
        if (token == COMMENT) {
            if (comment)
                *comment = xf86addComment(*comment, xf86_lex_val.str);
        }
        else
            return token;
    }
 /*NOTREACHED*/}

int
xf86getSubTokenWithTab(char **comment, xf86ConfigSymTabRec * tab)
{
    int token;

    for (;;) {
        token = xf86getToken(tab);
        if (token == COMMENT) {
            if (comment)
                *comment = xf86addComment(*comment, xf86_lex_val.str);
        }
        else
            return token;
    }
 /*NOTREACHED*/}

void
xf86unGetToken(int token)
{
    pushToken = token;
}

char *
xf86tokenString(void)
{
    return configRBuf;
}

int
xf86pathIsAbsolute(const char *path)
{
    if (path && path[0] == '/')
        return 1;
    return 0;
}

/* A path is "safe" if it is relative and if it contains no ".." elements. */
int
xf86pathIsSafe(const char *path)
{
    if (xf86pathIsAbsolute(path))
        return 0;

    /* Compare with ".." */
    if (!strcmp(path, ".."))
        return 0;

    /* Look for leading "../" */
    if (!strncmp(path, "../", 3))
        return 0;

    /* Look for trailing "/.." */
    if ((strlen(path) > 3) && !strcmp(path + strlen(path) - 3, "/.."))
        return 0;

    /* Look for "/../" */
    if (strstr(path, "/../"))
        return 0;

    return 1;
}

/*
 * This function substitutes the following escape sequences:
 *
 *    %A    cmdline argument as an absolute path (must be absolute to match)
 *    %R    cmdline argument as a relative path
 *    %S    cmdline argument as a "safe" path (relative, and no ".." elements)
 *    %X    default config file name ("xorg.conf")
 *    %H    hostname
 *    %E    config file environment ($XORGCONFIG) as an absolute path
 *    %F    config file environment ($XORGCONFIG) as a relative path
 *    %G    config file environment ($XORGCONFIG) as a safe path
 *    %P    projroot
 *    %C    sysconfdir
 *    %D    datadir
 *    %%    %
 */

#ifndef XCONFIGFILE
#define XCONFIGFILE	"xorg.conf"
#endif
#ifndef XCONFIGDIR
#define XCONFIGDIR	"xorg.conf.d"
#endif
#ifndef XCONFIGSUFFIX
#define XCONFIGSUFFIX	".conf"
#endif
#ifndef PROJECTROOT
#define PROJECTROOT	"/usr/X11R6"
#endif
#ifndef SYSCONFDIR
#define SYSCONFDIR	PROJECTROOT "/etc"
#endif
#ifndef DATADIR
#define DATADIR		PROJECTROOT "/share"
#endif
#ifndef XCONFENV
#define XCONFENV	"XORGCONFIG"
#endif

#define BAIL_OUT		do {									\
							free(result);				\
							return NULL;						\
						} while (0)

#define CHECK_LENGTH	do {									\
							if (l > PATH_MAX) {					\
								BAIL_OUT;						\
							}									\
						} while (0)

#define APPEND_STR(s)	do {									\
							if (strlen(s) + l > PATH_MAX) {		\
								BAIL_OUT;						\
							} else {							\
								strcpy(result + l, s);			\
								l += strlen(s);					\
							}									\
						} while (0)

static char *
DoSubstitution(const char *template, const char *cmdline, const char *projroot,
               int *cmdlineUsed, int *envUsed, const char *XConfigFile)
{
    char *result;
    int i, l;
    static const char *env = NULL;
    static char *hostname = NULL;

    if (!template)
        return NULL;

    if (cmdlineUsed)
        *cmdlineUsed = 0;
    if (envUsed)
        *envUsed = 0;

    result = malloc(PATH_MAX + 1);
    l = 0;
    for (i = 0; template[i]; i++) {
        if (template[i] != '%') {
            result[l++] = template[i];
            CHECK_LENGTH;
        }
        else {
            switch (template[++i]) {
            case 'A':
                if (cmdline && xf86pathIsAbsolute(cmdline)) {
                    APPEND_STR(cmdline);
                    if (cmdlineUsed)
                        *cmdlineUsed = 1;
                }
                else
                    BAIL_OUT;
                break;
            case 'R':
                if (cmdline && !xf86pathIsAbsolute(cmdline)) {
                    APPEND_STR(cmdline);
                    if (cmdlineUsed)
                        *cmdlineUsed = 1;
                }
                else
                    BAIL_OUT;
                break;
            case 'S':
                if (cmdline && xf86pathIsSafe(cmdline)) {
                    APPEND_STR(cmdline);
                    if (cmdlineUsed)
                        *cmdlineUsed = 1;
                }
                else
                    BAIL_OUT;
                break;
            case 'X':
                APPEND_STR(XConfigFile);
                break;
            case 'H':
                if (!hostname) {
                    if ((hostname = malloc(MAXHOSTNAMELEN + 1))) {
                        if (gethostname(hostname, MAXHOSTNAMELEN) == 0) {
                            hostname[MAXHOSTNAMELEN] = '\0';
                        }
                        else {
                            free(hostname);
                            hostname = NULL;
                        }
                    }
                }
                if (hostname)
                    APPEND_STR(hostname);
                break;
            case 'E':
                if (!env)
                    env = getenv(XCONFENV);
                if (env && xf86pathIsAbsolute(env)) {
                    APPEND_STR(env);
                    if (envUsed)
                        *envUsed = 1;
                }
                else
                    BAIL_OUT;
                break;
            case 'F':
                if (!env)
                    env = getenv(XCONFENV);
                if (env && !xf86pathIsAbsolute(env)) {
                    APPEND_STR(env);
                    if (envUsed)
                        *envUsed = 1;
                }
                else
                    BAIL_OUT;
                break;
            case 'G':
                if (!env)
                    env = getenv(XCONFENV);
                if (env && xf86pathIsSafe(env)) {
                    APPEND_STR(env);
                    if (envUsed)
                        *envUsed = 1;
                }
                else
                    BAIL_OUT;
                break;
            case 'P':
                if (projroot && xf86pathIsAbsolute(projroot))
                    APPEND_STR(projroot);
                else
                    BAIL_OUT;
                break;
            case 'C':
                APPEND_STR(SYSCONFDIR);
                break;
            case 'D':
                APPEND_STR(DATADIR);
                break;
            case '%':
                result[l++] = '%';
                CHECK_LENGTH;
                break;
            default:
                fprintf(stderr, "invalid escape %%%c found in path template\n",
                        template[i]);
                BAIL_OUT;
                break;
            }
        }
    }
#ifdef DEBUG
    fprintf(stderr, "Converted `%s' to `%s'\n", template, result);
#endif
    return result;
}

/*
 * Given some searching parameters, locate and open the xorg config file.
 */
static char *
OpenConfigFile(const char *path, const char *cmdline, const char *projroot,
               const char *confname)
{
    char *filepath = NULL;
    char *pathcopy;
    const char *template;
    int cmdlineUsed = 0;
    FILE *file = NULL;

    pathcopy = strdup(path);
    for (template = strtok(pathcopy, ","); template && !file;
         template = strtok(NULL, ",")) {
        filepath = DoSubstitution(template, cmdline, projroot,
                                  &cmdlineUsed, NULL, confname);
        if (!filepath)
            continue;
        if (cmdline && !cmdlineUsed) {
            free(filepath);
            filepath = NULL;
            continue;
        }
        file = fopen(filepath, "r");
        if (!file) {
            free(filepath);
            filepath = NULL;
        }
    }

    free(pathcopy);
    if (file) {
        configFiles[numFiles].file = file;
        configFiles[numFiles].path = strdup(filepath);
        numFiles++;
    }
    return filepath;
}

/*
 * Match non-hidden files in the xorg config directory with a .conf
 * suffix. This filter is passed to scandir(3).
 */
static int
ConfigFilter(const struct dirent *de)
{
    const char *name = de->d_name;
    size_t len;
    size_t suflen = strlen(XCONFIGSUFFIX);

    if (!name || name[0] == '.')
        return 0;
    len = strlen(name);
    if (len <= suflen)
        return 0;
    if (strcmp(&name[len - suflen], XCONFIGSUFFIX) != 0)
        return 0;
    return 1;
}

static Bool
AddConfigDirFiles(const char *dirpath, struct dirent **list, int num)
{
    int i;
    Bool openedFile = FALSE;
    Bool warnOnce = FALSE;

    for (i = 0; i < num; i++) {
        char *path;
        FILE *file;

        if (numFiles >= CONFIG_MAX_FILES) {
            if (!warnOnce) {
                ErrorF("Maximum number of configuration " "files opened\n");
                warnOnce = TRUE;
            }
            continue;
        }

        path = malloc(PATH_MAX + 1);
        snprintf(path, PATH_MAX + 1, "%s/%s", dirpath, list[i]->d_name);
        file = fopen(path, "r");
        if (!file) {
            free(path);
            continue;
        }
        openedFile = TRUE;

        configFiles[numFiles].file = file;
        configFiles[numFiles].path = path;
        numFiles++;
    }

    return openedFile;
}

/*
 * Given some searching parameters, locate and open the xorg config
 * directory. The directory does not need to contain config files.
 */
static char *
OpenConfigDir(const char *path, const char *cmdline, const char *projroot,
              const char *confname)
{
    char *dirpath = NULL, *pathcopy;
    const char *template;
    Bool found = FALSE;
    int cmdlineUsed = 0;

    pathcopy = strdup(path);
    for (template = strtok(pathcopy, ","); template && !found;
         template = strtok(NULL, ",")) {
        struct dirent **list = NULL;
        int num;

        dirpath = DoSubstitution(template, cmdline, projroot,
                                 &cmdlineUsed, NULL, confname);
        if (!dirpath)
            continue;
        if (cmdline && !cmdlineUsed) {
            free(dirpath);
            dirpath = NULL;
            continue;
        }

        /* match files named *.conf */
        num = scandir(dirpath, &list, ConfigFilter, alphasort);
        if (num < 0) {
            list = NULL;
            num = 0;
        }
        found = AddConfigDirFiles(dirpath, list, num);
        if (!found) {
            free(dirpath);
            dirpath = NULL;
        }
        while (num--)
            free(list[num]);
        free(list);
    }

    free(pathcopy);
    return dirpath;
}

/*
 * xf86initConfigFiles -- Setup global variables and buffers.
 */
void
xf86initConfigFiles(void)
{
    curFileIndex = 0;
    configPos = 0;
    configLineNo = 0;
    pushToken = LOCK_TOKEN;

    configBuf = malloc(CONFIG_BUF_LEN);
    configRBuf = malloc(CONFIG_BUF_LEN);
    configBuf[0] = '\0';        /* sanity ... */
}

/*
 * xf86openConfigFile --
 *
 * This function take a config file search path (optional), a command-line
 * specified file name (optional) and the ProjectRoot path (optional) and
 * locates and opens a config file based on that information.  If a
 * command-line file name is specified, then this function fails if none
 * of the located files.
 *
 * The return value is a pointer to the actual name of the file that was
 * opened.  When no file is found, the return value is NULL. The caller should
 * free() the returned value.
 *
 * The escape sequences allowed in the search path are defined above.
 *
 */

#ifndef DEFAULT_CONF_PATH
#define DEFAULT_CONF_PATH	"/etc/X11/%S," \
							"%P/etc/X11/%S," \
							"/etc/X11/%G," \
							"%P/etc/X11/%G," \
							"/etc/X11/%X-%M," \
							"/etc/X11/%X," \
							"/etc/%X," \
							"%P/etc/X11/%X.%H," \
							"%P/etc/X11/%X-%M," \
							"%P/etc/X11/%X," \
							"%P/lib/X11/%X.%H," \
							"%P/lib/X11/%X-%M," \
							"%P/lib/X11/%X"
#endif

char *
xf86openConfigFile(const char *path, const char *cmdline, const char *projroot)
{
    if (!path || !path[0])
        path = DEFAULT_CONF_PATH;
    if (!projroot || !projroot[0])
        projroot = PROJECTROOT;

    /* Search for a config file */
    return OpenConfigFile(path, cmdline, projroot, XCONFIGFILE);
}

/*
 * xf86openConfigDirFiles --
 *
 * This function take a config directory search path (optional), a
 * command-line specified directory name (optional) and the ProjectRoot path
 * (optional) and locates and opens a config directory based on that
 * information.  If a command-line name is specified, then this function
 * fails if it is not found.
 *
 * The return value is a pointer to the actual name of the direcoty that was
 * opened.  When no directory is found, the return value is NULL. The caller
 * should free() the returned value.
 *
 * The escape sequences allowed in the search path are defined above.
 *
 */
char *
xf86openConfigDirFiles(const char *path, const char *cmdline,
                       const char *projroot)
{
    if (!path || !path[0])
        path = DEFAULT_CONF_PATH;
    if (!projroot || !projroot[0])
        projroot = PROJECTROOT;

    /* Search for the multiconf directory */
    return OpenConfigDir(path, cmdline, projroot, XCONFIGDIR);
}

void
xf86closeConfigFile(void)
{
    int i;

    free(configRBuf);
    configRBuf = NULL;
    free(configBuf);
    configBuf = NULL;

    if (numFiles == 0) {
        builtinConfig = NULL;
        builtinIndex = 0;
    }
    for (i = 0; i < numFiles; i++) {
        fclose(configFiles[i].file);
        configFiles[i].file = NULL;
        free(configFiles[i].path);
        configFiles[i].path = NULL;
    }
    numFiles = 0;
}

void
xf86setBuiltinConfig(const char *config[])
{
    builtinConfig = config;
}

void
xf86parseError(const char *format, ...)
{
    va_list ap;
    const char *filename = numFiles ? configFiles[curFileIndex].path
        : "<builtin configuration>";

    ErrorF("Parse error on line %d of section %s in file %s\n\t",
           configLineNo, configSection, filename);
    va_start(ap, format);
    VErrorF(format, ap);
    va_end(ap);

    ErrorF("\n");
}

void
xf86validationError(const char *format, ...)
{
    va_list ap;
    const char *filename = numFiles ? configFiles[curFileIndex].path
        : "<builtin configuration>";

    ErrorF("Data incomplete in file %s\n\t", filename);
    va_start(ap, format);
    VErrorF(format, ap);
    va_end(ap);

    ErrorF("\n");
}

void
xf86setSection(const char *section)
{
    free(configSection);
    configSection = strdup(section);
}

/*
 * xf86getToken --
 *  Lookup a string if it is actually a token in disguise.
 */
int
xf86getStringToken(xf86ConfigSymTabRec * tab)
{
    return StringToToken(xf86_lex_val.str, tab);
}

static int
StringToToken(const char *str, xf86ConfigSymTabRec * tab)
{
    int i;

    for (i = 0; tab[i].token != -1; i++) {
        if (!xf86nameCompare(tab[i].name, str))
            return tab[i].token;
    }
    return ERROR_TOKEN;
}

/*
 * Compare two names.  The characters '_', ' ', and '\t' are ignored
 * in the comparison.
 */
int
xf86nameCompare(const char *s1, const char *s2)
{
    char c1, c2;

    if (!s1 || *s1 == 0) {
        if (!s2 || *s2 == 0)
            return 0;
        else
            return 1;
    }

    while (*s1 == '_' || *s1 == ' ' || *s1 == '\t')
        s1++;
    while (*s2 == '_' || *s2 == ' ' || *s2 == '\t')
        s2++;
    c1 = (isupper(*s1) ? tolower(*s1) : *s1);
    c2 = (isupper(*s2) ? tolower(*s2) : *s2);
    while (c1 == c2) {
        if (c1 == '\0')
            return 0;
        s1++;
        s2++;
        while (*s1 == '_' || *s1 == ' ' || *s1 == '\t')
            s1++;
        while (*s2 == '_' || *s2 == ' ' || *s2 == '\t')
            s2++;
        c1 = (isupper(*s1) ? tolower(*s1) : *s1);
        c2 = (isupper(*s2) ? tolower(*s2) : *s2);
    }
    return c1 - c2;
}

char *
xf86addComment(char *cur, const char *add)
{
    char *str;
    const char *cstr;
    int len, curlen, iscomment, hasnewline = 0, insnewline, endnewline;

    if (add == NULL || add[0] == '\0')
        return cur;

    if (cur) {
        curlen = strlen(cur);
        if (curlen)
            hasnewline = cur[curlen - 1] == '\n';
        eol_seen = 0;
    }
    else
        curlen = 0;

    cstr = add;
    iscomment = 0;
    while (*cstr) {
        if (*cstr != ' ' && *cstr != '\t')
            break;
        ++cstr;
    }
    iscomment = (*cstr == '#');

    len = strlen(add);
    endnewline = add[len - 1] == '\n';

    insnewline = eol_seen || (curlen && !hasnewline);
    if (insnewline)
        len++;
    if (!iscomment)
        len++;
    if (!endnewline)
        len++;

    /* Allocate + 1 char for '\0' terminator. */
    str = realloc(cur, curlen + len + 1);
    if (!str)
        return cur;

    cur = str;

    if (insnewline)
        cur[curlen++] = '\n';
    if (!iscomment)
        cur[curlen++] = '#';
    strcpy(cur + curlen, add);
    if (!endnewline)
        strcat(cur, "\n");

    return cur;
}

Bool
xf86getBoolValue(Bool *val, const char *str)
{
    if (!val || !str)
        return FALSE;
    if (*str == '\0') {
        *val = TRUE;
    }
    else {
        if (xf86nameCompare(str, "1") == 0)
            *val = TRUE;
        else if (xf86nameCompare(str, "on") == 0)
            *val = TRUE;
        else if (xf86nameCompare(str, "true") == 0)
            *val = TRUE;
        else if (xf86nameCompare(str, "yes") == 0)
            *val = TRUE;
        else if (xf86nameCompare(str, "0") == 0)
            *val = FALSE;
        else if (xf86nameCompare(str, "off") == 0)
            *val = FALSE;
        else if (xf86nameCompare(str, "false") == 0)
            *val = FALSE;
        else if (xf86nameCompare(str, "no") == 0)
            *val = FALSE;
        else
            return FALSE;
    }
    return TRUE;
}
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1 1
a1 1
/* 
d3 1
a3 1
 * 
d5 1
a5 1
 * copy of this software and associated documentation files (the "Software"), 
d10 1
a10 1
 * 
d13 1
a13 1
 * 
d21 1
a21 1
 * 
d25 1
a25 1
 * 
d244 1
a244 1
/* 
d254 1
a254 1
    /* 
d269 1
a269 1
        /* 
d271 1
a271 1
         * whitespaces are skipped. 
d347 1
a347 1
        /* 
d382 1
a382 1
        /* 
d397 1
a397 1
        /* 
d417 1
a417 1
        /* 
d431 1
a431 1
    /* 
d1021 1
a1021 1
/* 
d1043 1
a1043 1
/* 
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d106 1
a106 1
LexRec val;
d335 1
a335 1
            val.str = configRBuf;
d357 1
a357 1
                    val.numType = PARSE_HEX;
d361 1
a361 1
                    val.numType = PARSE_OCTAL;
d365 1
a365 1
                val.numType = PARSE_DECIMAL;
d377 2
a378 2
            val.num = strtoul(configRBuf, NULL, 0);
            val.realnum = atof(configRBuf);
d392 2
a393 2
            val.str = malloc(strlen(configRBuf) + 1);
            strcpy(val.str, configRBuf);        /* private copy ! */
d455 1
a455 1
                *comment = xf86addComment(*comment, val.str);
d471 1
a471 1
                *comment = xf86addComment(*comment, val.str);
d823 1
a823 1
    char *dirpath, *pathcopy;
d1028 1
a1028 1
    return StringToToken(val.str, tab);
d1081 1
a1081 1
xf86addComment(char *cur, char *add)
d1084 1
d1099 1
a1099 1
    str = add;
d1101 2
a1102 2
    while (*str) {
        if (*str != ' ' && *str != '\t')
d1104 1
a1104 1
        ++str;
d1106 1
a1106 1
    iscomment = (*str == '#');
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a53 2
/* View/edit this file with tab stops set to 4 */

@


1.6
log
@Update to xserver 1.11.2
@
text
@a53 1

d77 1
a77 1
#endif /* _POSIX_SOURCE */
d81 1
a81 1
#endif /* !MAXHOSTNAMELEN */
d92 1
a92 1
static int StringToToken (char *, xf86ConfigSymTabRec *);
d95 2
a96 2
	FILE *file;
	char *path;
d100 6
a105 8
static int configPos = 0;		/* current readers position */
static int configLineNo = 0;	/* linenumber */
static char *configBuf, *configRBuf;	/* buffer for lines */
static char *configPath;		/* path to config file */
static char *configDirPath;		/* path to config dir */
static char *configSection = NULL;	/* name of current section being parsed */
static int numFiles = 0;		/* number of config files */
static int curFileIndex = 0;		/* index of current config file */
d107 1
a107 1
static int eol_seen = 0;		/* private state to handle comments */
d121 1
a121 1
static char*
d124 116
a239 79
	static int configBufLen = CONFIG_BUF_LEN;
	char *tmpConfigBuf, *tmpConfigRBuf;
	int c, i, pos = 0, eolFound = 0;
	char *ret = NULL;

	/*
	 * reallocate the string if it was grown last time (i.e., is no
	 * longer CONFIG_BUF_LEN); we malloc the new strings first, so
	 * that if either of the mallocs fail, we can fall back on the
	 * existing buffer allocations
	 */

	if (configBufLen != CONFIG_BUF_LEN) {

		tmpConfigBuf = malloc(CONFIG_BUF_LEN);
		tmpConfigRBuf = malloc(CONFIG_BUF_LEN);

		if (!tmpConfigBuf || !tmpConfigRBuf) {

			/*
			 * at least one of the mallocs failed; keep the old buffers
			 * and free any partial allocations
			 */

			free(tmpConfigBuf);
			free(tmpConfigRBuf);

		} else {

			/*
			 * malloc succeeded; free the old buffers and use the new
			 * buffers
			 */

			configBufLen = CONFIG_BUF_LEN;

			free(configBuf);
			free(configRBuf);

			configBuf = tmpConfigBuf;
			configRBuf = tmpConfigRBuf;
		}
	}

	/* read in another block of chars */

	do {
		ret = fgets(configBuf + pos, configBufLen - pos - 1,
			    configFiles[curFileIndex].file);

		if (!ret) {
			/*
			 * if the file doesn't end in a newline, add one
			 * and trigger another read
			 */
			if (pos != 0) {
				strcpy(&configBuf[pos], "\n");
				ret = configBuf;
			} else
				break;
		}

		/* search for EOL in the new block of chars */

		for (i = pos; i < (configBufLen - 1); i++) {
			c = configBuf[i];

			if (c == '\0') break;

			if ((c == '\n') || (c == '\r')) {
				eolFound = 1;
				break;
			}
		}

		/*
		 * if we didn't find EOL, then grow the string and
		 * read in more
		 */
d241 1
a241 1
		if (!eolFound) {
d243 1
a243 32
			tmpConfigBuf = realloc(configBuf, configBufLen + CONFIG_BUF_LEN);
			tmpConfigRBuf = realloc(configRBuf, configBufLen + CONFIG_BUF_LEN);

			if (!tmpConfigBuf || !tmpConfigRBuf) {

				/*
				 * at least one of the reallocations failed; use the
				 * new allocation that succeeded, but we have to
				 * fallback to the previous configBufLen size and use
				 * the string we have, even though we don't have an
				 * EOL
				 */

				if (tmpConfigBuf) configBuf = tmpConfigBuf;
				if (tmpConfigRBuf) configRBuf = tmpConfigRBuf;

				break;

			} else {

				/* reallocation succeeded */

				configBuf = tmpConfigBuf;
				configRBuf = tmpConfigRBuf;
				pos = i;
				configBufLen += CONFIG_BUF_LEN;
			}
		}

	} while (!eolFound);

	return ret;
d252 1
a252 1
xf86getToken (xf86ConfigSymTabRec * tab)
d254 1
a254 124
	int c, i;

	/* 
	 * First check whether pushToken has a different value than LOCK_TOKEN.
	 * In this case rBuf[] contains a valid STRING/TOKEN/NUMBER. But in the
	 * oth * case the next token must be read from the input.
	 */
	if (pushToken == EOF_TOKEN)
		return EOF_TOKEN;
	else if (pushToken == LOCK_TOKEN)
	{
		/*
		 * eol_seen is only set for the first token after a newline.
		 */
		eol_seen = 0;

		c = configBuf[configPos];

		/* 
		 * Get start of next Token. EOF is handled,
		 * whitespaces are skipped. 
		 */

again:
		if (!c)
		{
			char *ret;
			if (numFiles > 0)
				ret = xf86getNextLine();
			else {
				if (builtinConfig[builtinIndex] == NULL)
					ret = NULL;
				else {
					ret = strncpy(configBuf, builtinConfig[builtinIndex],
							CONFIG_BUF_LEN);
					builtinIndex++;
				}
			}
			if (ret == NULL)
			{
				/*
				 * if necessary, move to the next file and
				 * read the first line
				 */
				if (curFileIndex + 1 < numFiles) {
					curFileIndex++;
					configLineNo = 0;
					goto again;
				}
				else
					return pushToken = EOF_TOKEN;
			}
			configLineNo++;
			configPos = 0;
			eol_seen = 1;
		}

		i = 0;
		for (;;) {
			c = configBuf[configPos++];
			configRBuf[i++] = c;
			switch (c) {
				case ' ':
				case '\t':
				case '\r':
					continue;
				case '\n':
					i = 0;
					continue;
			}
			break;
		}
		if (c == '\0')
			goto again;

		if (c == '#')
		{
			do
			{
				configRBuf[i++] = (c = configBuf[configPos++]);
			}
			while ((c != '\n') && (c != '\r') && (c != '\0'));
			configRBuf[i] = '\0';
			/* XXX no private copy.
			 * Use xf86addComment when setting a comment.
			 */
			val.str = configRBuf;
			return COMMENT;
		}

		/* GJA -- handle '-' and ','  * Be careful: "-hsync" is a keyword. */
		else if ((c == ',') && !isalpha (configBuf[configPos]))
		{
			return COMMA;
		}
		else if ((c == '-') && !isalpha (configBuf[configPos]))
		{
			return DASH;
		}

		/* 
		 * Numbers are returned immediately ...
		 */
		if (isdigit (c))
		{
			int base;

			if (c == '0')
				if ((configBuf[configPos] == 'x') ||
					(configBuf[configPos] == 'X'))
                                {
					base = 16;
                                        val.numType = PARSE_HEX;
                                }
				else
                                {
					base = 8;
                                        val.numType = PARSE_OCTAL;
                                }
			else
                        {
				base = 10;
                                val.numType = PARSE_DECIMAL;
                        }
d256 188
a443 78
			configRBuf[0] = c;
			i = 1;
			while (isdigit (c = configBuf[configPos++]) ||
				   (c == '.') || (c == 'x') || (c == 'X') ||
				   ((base == 16) && (((c >= 'a') && (c <= 'f')) ||
									 ((c >= 'A') && (c <= 'F')))))
				configRBuf[i++] = c;
			configPos--;		/* GJA -- one too far */
			configRBuf[i] = '\0';
			val.num = strtoul (configRBuf, NULL, 0);
			val.realnum = atof (configRBuf);
			return NUMBER;
		}

		/* 
		 * All Strings START with a \" ...
		 */
		else if (c == '\"')
		{
			i = -1;
			do
			{
				configRBuf[++i] = (c = configBuf[configPos++]);
			}
			while ((c != '\"') && (c != '\n') && (c != '\r') && (c != '\0'));
			configRBuf[i] = '\0';
			val.str = malloc (strlen (configRBuf) + 1);
			strcpy (val.str, configRBuf);	/* private copy ! */
			return STRING;
		}

		/* 
		 * ... and now we MUST have a valid token.  The search is
		 * handled later along with the pushed tokens.
		 */
		else
		{
			configRBuf[0] = c;
			i = 0;
			do
			{
				configRBuf[++i] = (c = configBuf[configPos++]);
			}
			while ((c != ' ') && (c != '\t') && (c != '\n') && (c != '\r') && (c != '\0') && (c != '#'));
			--configPos;
			configRBuf[i] = '\0';
			i = 0;
		}

	}
	else
	{

		/* 
		 * Here we deal with pushed tokens. Reinitialize pushToken again. If
		 * the pushed token was NUMBER || STRING return them again ...
		 */
		int temp = pushToken;
		pushToken = LOCK_TOKEN;

		if (temp == COMMA || temp == DASH)
			return temp;
		if (temp == NUMBER || temp == STRING)
			return temp;
	}

	/* 
	 * Joop, at last we have to lookup the token ...
	 */
	if (tab)
	{
		i = 0;
		while (tab[i].token != -1)
			if (xf86nameCompare (configRBuf, tab[i].name) == 0)
				return tab[i].token;
			else
				i++;
	}
d445 1
a445 1
	return ERROR_TOKEN;		/* Error catcher */
d449 1
a449 1
xf86getSubToken (char **comment)
d451 1
a451 1
	int token;
d453 10
a462 11
	for (;;) {
		token = xf86getToken(NULL);
		if (token == COMMENT) {
			if (comment)
				*comment = xf86addComment(*comment, val.str);
		}
		else
			return token;
	}
	/*NOTREACHED*/
}
d465 1
a465 1
xf86getSubTokenWithTab (char **comment, xf86ConfigSymTabRec *tab)
d467 1
a467 1
	int token;
d469 10
a478 11
	for (;;) {
		token = xf86getToken(tab);
		if (token == COMMENT) {
			if (comment)
				*comment = xf86addComment(*comment, val.str);
		}
		else
			return token;
	}
	/*NOTREACHED*/
}
d481 1
a481 1
xf86unGetToken (int token)
d483 1
a483 1
	pushToken = token;
d487 1
a487 1
xf86tokenString (void)
d489 1
a489 1
	return configRBuf;
d495 3
a497 3
	if (path && path[0] == '/')
		return 1;
	return 0;
d504 2
a505 2
	if (xf86pathIsAbsolute(path))
		return 0;
d507 15
a521 15
	/* Compare with ".." */
	if (!strcmp(path, ".."))
		return 0;

	/* Look for leading "../" */
	if (!strncmp(path, "../", 3))
		return 0;

	/* Look for trailing "/.." */
	if ((strlen(path) > 3) && !strcmp(path + strlen(path) - 3, "/.."))
		return 0;

	/* Look for "/../" */
	if (strstr(path, "/../"))
		return 0;
d523 1
a523 1
	return 1;
d587 1
a587 2
				int *cmdlineUsed, int *envUsed,
				const char *XConfigFile)
d589 124
a712 116
	char *result;
	int i, l;
	static const char *env = NULL;
	static char *hostname = NULL;

	if (!template)
		return NULL;

	if (cmdlineUsed)
		*cmdlineUsed = 0;
	if (envUsed)
		*envUsed = 0;

	result = malloc(PATH_MAX + 1);
	l = 0;
	for (i = 0; template[i]; i++) {
		if (template[i] != '%') {
			result[l++] = template[i];
			CHECK_LENGTH;
		} else {
			switch (template[++i]) {
			case 'A':
				if (cmdline && xf86pathIsAbsolute(cmdline)) {
					APPEND_STR(cmdline);
					if (cmdlineUsed)
						*cmdlineUsed = 1;
				} else
					BAIL_OUT;
				break;
			case 'R':
				if (cmdline && !xf86pathIsAbsolute(cmdline)) {
					APPEND_STR(cmdline);
					if (cmdlineUsed)
						*cmdlineUsed = 1;
				} else 
					BAIL_OUT;
				break;
			case 'S':
				if (cmdline && xf86pathIsSafe(cmdline)) {
					APPEND_STR(cmdline);
					if (cmdlineUsed)
						*cmdlineUsed = 1;
				} else 
					BAIL_OUT;
				break;
			case 'X':
				APPEND_STR(XConfigFile);
				break;
			case 'H':
				if (!hostname) {
					if ((hostname = malloc(MAXHOSTNAMELEN + 1))) {
						if (gethostname(hostname, MAXHOSTNAMELEN) == 0) {
							hostname[MAXHOSTNAMELEN] = '\0';
						} else {
							free(hostname);
							hostname = NULL;
						}
					}
				}
				if (hostname)
					APPEND_STR(hostname);
				break;
			case 'E':
				if (!env)
					env = getenv(XCONFENV);
				if (env && xf86pathIsAbsolute(env)) {
					APPEND_STR(env);
					if (envUsed)
						*envUsed = 1;
				} else
					BAIL_OUT;
				break;
			case 'F':
				if (!env)
					env = getenv(XCONFENV);
				if (env && !xf86pathIsAbsolute(env)) {
					APPEND_STR(env);
					if (envUsed)
						*envUsed = 1;
				} else
					BAIL_OUT;
				break;
			case 'G':
				if (!env)
					env = getenv(XCONFENV);
				if (env && xf86pathIsSafe(env)) {
					APPEND_STR(env);
					if (envUsed)
						*envUsed = 1;
				} else
					BAIL_OUT;
				break;
			case 'P':
				if (projroot && xf86pathIsAbsolute(projroot))
					APPEND_STR(projroot);
				else
					BAIL_OUT;
				break;
			case 'C':
				APPEND_STR(SYSCONFDIR);
				break;
			case 'D':
				APPEND_STR(DATADIR);
				break;
			case '%':
				result[l++] = '%';
				CHECK_LENGTH;
				break;
			default:
				fprintf(stderr, "invalid escape %%%c found in path template\n",
						template[i]);
				BAIL_OUT;
				break;
			}
		}
	}
d714 1
a714 1
	fprintf(stderr, "Converted `%s' to `%s'\n", template, result);
d716 1
a716 1
	return result;
d724 1
a724 1
	       const char *confname)
d726 32
a757 32
	char *filepath = NULL;
	char *pathcopy;
	const char *template;
	int cmdlineUsed = 0;
	FILE *file = NULL;

	pathcopy = strdup(path);
	for (template = strtok(pathcopy, ","); template && !file;
	     template = strtok(NULL, ",")) {
		filepath = DoSubstitution(template, cmdline, projroot,
					  &cmdlineUsed, NULL, confname);
		if (!filepath)
			continue;
		if (cmdline && !cmdlineUsed) {
			free(filepath);
			filepath = NULL;
			continue;
		}
		file = fopen(filepath, "r");
		if (!file) {
			free(filepath);
			filepath = NULL;
		}
	}

	free(pathcopy);
	if (file) {
		configFiles[numFiles].file = file;
		configFiles[numFiles].path = strdup(filepath);
		numFiles++;
	}
	return filepath;
d767 12
a778 12
	const char *name = de->d_name;
	size_t len;
	size_t suflen = strlen(XCONFIGSUFFIX);

	if (!name || name[0] == '.')
		return 0;
	len = strlen(name);
	if(len <= suflen)
		return 0;
	if (strcmp(&name[len-suflen], XCONFIGSUFFIX) != 0)
		return 0;
	return 1;
d784 29
a812 33
	int i;
	Bool openedFile = FALSE;
	Bool warnOnce = FALSE;

	for (i = 0; i < num; i++) {
		char *path;
		FILE *file;

		if (numFiles >= CONFIG_MAX_FILES) {
			if (!warnOnce) {
				ErrorF("Maximum number of configuration "
				       "files opened\n");
				warnOnce = TRUE;
			}
			free(list[i]);
			continue;
		}

		path = malloc(PATH_MAX + 1);
		snprintf(path, PATH_MAX + 1, "%s/%s", dirpath,
			 list[i]->d_name);
		free(list[i]);
		file = fopen(path, "r");
		if (!file) {
			free(path);
			continue;
		}
		openedFile = TRUE;

		configFiles[numFiles].file = file;
		configFiles[numFiles].path = path;
		numFiles++;
	}
d814 1
a814 1
	return openedFile;
d823 1
a823 1
	      const char *confname)
d825 36
a860 30
	char *dirpath, *pathcopy;
	const char *template;
	Bool found = FALSE;
	int cmdlineUsed = 0;

	pathcopy = strdup(path);
	for (template = strtok(pathcopy, ","); template && !found;
	     template = strtok(NULL, ",")) {
		struct dirent **list = NULL;
		int num;

		dirpath = DoSubstitution(template, cmdline, projroot,
					 &cmdlineUsed, NULL, confname);
		if (!dirpath)
			continue;
		if (cmdline && !cmdlineUsed) {
			free(dirpath);
			dirpath = NULL;
			continue;
		}

		/* match files named *.conf */
		num = scandir(dirpath, &list, ConfigFilter, alphasort);
		found = AddConfigDirFiles(dirpath, list, num);
		if (!found) {
			free(dirpath);
			dirpath = NULL;
			free(list);
		}
	}
d862 2
a863 2
	free(pathcopy);
	return dirpath;
d872 8
a879 8
	curFileIndex = 0;
	configPos = 0;
	configLineNo = 0;
	pushToken = LOCK_TOKEN;

	configBuf = malloc(CONFIG_BUF_LEN);
	configRBuf = malloc(CONFIG_BUF_LEN);
	configBuf[0] = '\0';	/* sanity ... */
d892 2
a893 1
 * opened.  When no file is found, the return value is NULL.
d915 1
a915 1
const char *
d918 7
a924 8
	if (!path || !path[0])
		path = DEFAULT_CONF_PATH;
	if (!projroot || !projroot[0])
		projroot = PROJECTROOT;

	/* Search for a config file */
	configPath = OpenConfigFile(path, cmdline, projroot, XCONFIGFILE);
	return configPath;
d937 2
a938 1
 * opened.  When no directory is found, the return value is NULL.
d943 1
a943 1
const char *
d945 1
a945 1
		       const char *projroot)
d947 7
a953 8
	if (!path || !path[0])
		path = DEFAULT_CONF_PATH;
	if (!projroot || !projroot[0])
		projroot = PROJECTROOT;

	/* Search for the multiconf directory */
	configDirPath = OpenConfigDir(path, cmdline, projroot, XCONFIGDIR);
	return configDirPath;
d957 1
a957 1
xf86closeConfigFile (void)
d959 1
a959 1
	int i;
d961 16
a976 20
	free (configPath);
	configPath = NULL;
	free (configDirPath);
	configDirPath = NULL;
	free (configRBuf);
	configRBuf = NULL;
	free (configBuf);
	configBuf = NULL;

	if (numFiles == 0) {
		builtinConfig = NULL;
		builtinIndex = 0;
	}
	for (i = 0; i < numFiles; i++) {
		fclose(configFiles[i].file);
		configFiles[i].file = NULL;
		free(configFiles[i].path);
		configFiles[i].path = NULL;
	}
	numFiles = 0;
d982 1
a982 1
	builtinConfig = config;
d986 1
a986 1
xf86parseError (char *format,...)
d988 9
a996 9
	va_list ap;
	char *filename = numFiles ? configFiles[curFileIndex].path :
			 "<builtin configuration>";

	ErrorF ("Parse error on line %d of section %s in file %s\n\t",
		 configLineNo, configSection, filename);
	va_start (ap, format);
	VErrorF (format, ap);
	va_end (ap);
d998 1
a998 1
	ErrorF ("\n");
d1002 1
a1002 1
xf86validationError (char *format,...)
d1004 8
a1011 8
	va_list ap;
	char *filename = numFiles ? configFiles[curFileIndex].path :
			 "<builtin configuration>";

	ErrorF ("Data incomplete in file %s\n\t", filename);
	va_start (ap, format);
	VErrorF (format, ap);
	va_end (ap);
d1013 1
a1013 1
	ErrorF ("\n");
d1017 1
a1017 1
xf86setSection (char *section)
d1019 2
a1020 2
	free(configSection);
	configSection = strdup(section);
d1028 1
a1028 1
xf86getStringToken (xf86ConfigSymTabRec * tab)
d1030 1
a1030 1
	return StringToToken (val.str, tab);
d1034 1
a1034 1
StringToToken (char *str, xf86ConfigSymTabRec * tab)
d1036 1
a1036 1
	int i;
d1038 5
a1042 6
	for (i = 0; tab[i].token != -1; i++)
	{
		if (!xf86nameCompare (tab[i].name, str))
			return tab[i].token;
	}
	return ERROR_TOKEN;
a1044 1

d1050 1
a1050 1
xf86nameCompare (const char *s1, const char *s2)
d1052 1
a1052 1
	char c1, c2;
d1054 26
a1079 27
	if (!s1 || *s1 == 0) {
		if (!s2 || *s2 == 0)
			return 0;
		else
			return 1;
		}

	while (*s1 == '_' || *s1 == ' ' || *s1 == '\t')
		s1++;
	while (*s2 == '_' || *s2 == ' ' || *s2 == '\t')
		s2++;
	c1 = (isupper (*s1) ? tolower (*s1) : *s1);
	c2 = (isupper (*s2) ? tolower (*s2) : *s2);
	while (c1 == c2)
	{
		if (c1 == '\0')
			return 0;
		s1++;
		s2++;
		while (*s1 == '_' || *s1 == ' ' || *s1 == '\t')
			s1++;
		while (*s2 == '_' || *s2 == ' ' || *s2 == '\t')
			s2++;
		c1 = (isupper (*s1) ? tolower (*s1) : *s1);
		c2 = (isupper (*s2) ? tolower (*s2) : *s2);
	}
	return c1 - c2;
d1085 2
a1086 2
	char *str;
	int len, curlen, iscomment, hasnewline = 0, endnewline;
d1088 2
a1089 2
	if (add == NULL || add[0] == '\0')
		return cur;
d1091 43
a1133 34
	if (cur) {
		curlen = strlen(cur);
		if (curlen)
		    hasnewline = cur[curlen - 1] == '\n';
		eol_seen = 0;
	}
	else
		curlen = 0;

	str = add;
	iscomment = 0;
	while (*str) {
	    if (*str != ' ' && *str != '\t')
		break;
	    ++str;
	}
	iscomment = (*str == '#');

	len = strlen(add);
	endnewline = add[len - 1] == '\n';
	len +=  1 + iscomment + (!hasnewline) + (!endnewline) + eol_seen;

	if ((str = realloc(cur, len + curlen)) == NULL)
		return cur;

	cur = str;

	if (eol_seen || (curlen && !hasnewline))
		cur[curlen++] = '\n';
	if (!iscomment)
		cur[curlen++] = '#';
	strcpy(cur + curlen, add);
	if (!endnewline)
		strcat(cur, "\n");
d1135 1
a1135 1
	return cur;
d1141 26
a1166 25
	if (!val || !str)
		return FALSE;
	if (*str == '\0') {
		*val = TRUE;
	} else {
		if (xf86nameCompare(str, "1") == 0)
			*val = TRUE;
		else if (xf86nameCompare(str, "on") == 0)
			*val = TRUE;
		else if (xf86nameCompare(str, "true") == 0)
			*val = TRUE;
		else if (xf86nameCompare(str, "yes") == 0)
			*val = TRUE;
		else if (xf86nameCompare(str, "0") == 0)
			*val = FALSE;
		else if (xf86nameCompare(str, "off") == 0)
			*val = FALSE;
		else if (xf86nameCompare(str, "false") == 0)
			*val = FALSE;
		else if (xf86nameCompare(str, "no") == 0)
			*val = FALSE;
		else
			return FALSE;
	}
	return TRUE;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a79 8
#if !defined(PATH_MAX)
#if defined(MAXPATHLEN)
#define PATH_MAX MAXPATHLEN
#else
#define PATH_MAX 1024
#endif /* MAXPATHLEN */
#endif /* !PATH_MAX */

d84 3
a112 47
/* 
 * xf86strToUL --
 *
 *  A portable, but restricted, version of strtoul().  It only understands
 *  hex, octal, and decimal.  But it's good enough for our needs.
 */
static unsigned int
xf86strToUL (char *str)
{
	int base = 10;
	char *p = str;
	unsigned int tot = 0;

	if (*p == '0')
	{
		p++;
		if ((*p == 'x') || (*p == 'X'))
		{
			p++;
			base = 16;
		}
		else
			base = 8;
	}
	while (*p)
	{
		if ((*p >= '0') && (*p <= ((base == 8) ? '7' : '9')))
		{
			tot = tot * base + (*p - '0');
		}
		else if ((base == 16) && (*p >= 'a') && (*p <= 'f'))
		{
			tot = tot * base + 10 + (*p - 'a');
		}
		else if ((base == 16) && (*p >= 'A') && (*p <= 'F'))
		{
			tot = tot * base + 10 + (*p - 'A');
		}
		else
		{
			return tot;
		}
		p++;
	}
	return tot;
}

d385 1
a385 1
			val.num = xf86strToUL (configRBuf);
a551 1
 *    %M    config file format version number
a575 5
/* xorg.conf is based on XF86Config version 4.   If we ever break
   compatibility of the xorg.conf syntax, we'll bump this version number. */
#ifndef CONFIG_FILE_VERSION
#define CONFIG_FILE_VERSION	4
#endif
a605 1
	static char majorvers[3] = "";
a705 7
			case 'M':
				if (!majorvers[0]) {
					snprintf(majorvers, sizeof(majorvers),
						 "%d", CONFIG_FILE_VERSION);
				}
				APPEND_STR(majorvers);
				break;
d1027 1
a1027 2
	configSection = malloc(strlen (section) + 1);
	strcpy (configSection, section);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d158 1
a158 1
			return (tot);
d162 1
a162 1
	return (tot);
d292 1
a292 1
	return (ret);
d311 1
a311 1
		return (EOF_TOKEN);
d353 1
a353 1
					return (pushToken = EOF_TOKEN);
d390 1
a390 1
			return (COMMENT);
d439 1
a439 1
			return (NUMBER);
d456 1
a456 1
			return (STRING);
d489 1
a489 1
			return (temp);
d491 1
a491 1
			return (temp);
d502 1
a502 1
				return (tab[i].token);
d507 1
a507 1
	return (ERROR_TOKEN);		/* Error catcher */
d522 1
a522 1
			return (token);
d539 1
a539 1
			return (token);
d604 1
a604 1
 *    %M    major version number
d629 4
a632 11
#define XFREE86CFGFILE "XF86Config"
#ifndef XF86_VERSION_MAJOR
#ifdef XVERSION
#if XVERSION > 40000000
#define XF86_VERSION_MAJOR	(XVERSION / 10000000)
#else
#define XF86_VERSION_MAJOR	(XVERSION / 1000)
#endif
#else
#define XF86_VERSION_MAJOR	4
#endif
d767 2
a768 5
					if (XF86_VERSION_MAJOR < 0 || XF86_VERSION_MAJOR > 99) {
						fprintf(stderr, "XF86_VERSION_MAJOR is out of range\n");
						BAIL_OUT;
					} else
						sprintf(majorvers, "%d", XF86_VERSION_MAJOR);
d822 1
d839 1
a839 1
	size_t len = strlen(name);
d842 4
a845 1
	if (!name || name[0] == '.' || len <= suflen)
d927 1
a927 2
			if (list)
				free(list);
d931 1
d991 1
a991 1
	/* Search for a config file or a fallback */
a992 3
	if (!configPath)
		configPath = OpenConfigFile(path, cmdline, projroot,
					    XFREE86CFGFILE);
d1092 1
a1092 2
	if (configSection)
		free(configSection);
d1117 1
a1117 1
	return (ERROR_TOKEN);
d1132 1
a1132 1
			return (0);
d1134 1
a1134 1
			return (1);
d1146 1
a1146 1
			return (0);
d1156 1
a1156 1
	return (c1 - c2);
d1166 1
a1166 1
		return (cur);
d1191 1
a1191 1
		return (cur);
d1203 1
a1203 1
	return (cur);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d65 2
d69 1
d96 1
d100 4
a103 1
static FILE *configFile = NULL;
d110 1
d112 2
d168 1
a168 1
 *  read from the configFile FILE stream until we encounter a new
d193 2
a194 2
		tmpConfigBuf = xf86confmalloc(CONFIG_BUF_LEN);
		tmpConfigRBuf = xf86confmalloc(CONFIG_BUF_LEN);
d203 2
a204 2
			xf86conffree(tmpConfigBuf);
			xf86conffree(tmpConfigRBuf);
d215 2
a216 2
			xf86conffree(configBuf);
			xf86conffree(configRBuf);
d226 2
a227 1
		ret = fgets(configBuf + pos, configBufLen - pos - 1, configFile);
d229 11
a239 1
		if (!ret) break;
d261 2
a262 2
			tmpConfigBuf = xf86confrealloc(configBuf, configBufLen + CONFIG_BUF_LEN);
			tmpConfigRBuf = xf86confrealloc(configRBuf, configBufLen + CONFIG_BUF_LEN);
d330 1
a330 1
			if (configFile)
d343 11
a353 1
				return (pushToken = EOF_TOKEN);
d454 1
a454 1
			val.str = xf86confmalloc (strlen (configRBuf) + 1);
d602 2
d611 6
d620 6
d643 1
a643 1
							xf86conffree(result);				\
d664 2
a665 1
				int *cmdlineUsed, int *envUsed, char *XConfigFile)
d681 1
a681 1
	result = xf86confmalloc(PATH_MAX + 1);
d718 1
a718 1
					if ((hostname = xf86confmalloc(MAXHOSTNAMELEN + 1))) {
d722 1
a722 1
							xf86conffree(hostname);
d766 6
d800 158
a957 1
/* 
d970 1
a970 1
 *  
d992 4
a995 3
	char *pathcopy;
	const char *template;
	int cmdlineUsed = 0;
d997 7
a1003 4
	configFile = NULL;
	configPos = 0;		/* current readers position */
	configLineNo = 0;	/* linenumber */
	pushToken = LOCK_TOKEN;
d1005 19
a1025 2
	pathcopy = xf86confmalloc(strlen(path) + 1);
	strcpy(pathcopy, path);
d1029 3
a1031 56
	template = strtok(pathcopy, ",");

	/* First, search for a config file. */
	while (template && !configFile) {
		if ((configPath = DoSubstitution(template, cmdline, projroot,
						 &cmdlineUsed, NULL,
						 XCONFIGFILE))) {
			if ((configFile = fopen(configPath, "r")) != 0) {
				if (cmdline && !cmdlineUsed) {
					fclose(configFile);
					configFile = NULL;
				}
			}
		}
		if (configPath && !configFile) {
			xf86conffree(configPath);
			configPath = NULL;
		}
		template = strtok(NULL, ",");
	}
	
	/* Then search for fallback */
	if (!configFile) {
	    strcpy(pathcopy, path);
	    template = strtok(pathcopy, ",");

	    while (template && !configFile) {
		if ((configPath = DoSubstitution(template, cmdline, projroot,
						 &cmdlineUsed, NULL,
						 XFREE86CFGFILE))) {
		    if ((configFile = fopen(configPath, "r")) != 0) {
			if (cmdline && !cmdlineUsed) {
			    fclose(configFile);
			    configFile = NULL;
			}
		    }
		}
		if (configPath && !configFile) {
		    xf86conffree(configPath);
		    configPath = NULL;
		}
		template = strtok(NULL, ",");
	    }
	}
	
	xf86conffree(pathcopy);
	if (!configFile) {

		return NULL;
	}

	configBuf = xf86confmalloc (CONFIG_BUF_LEN);
	configRBuf = xf86confmalloc (CONFIG_BUF_LEN);
	configBuf[0] = '\0';		/* sanity ... */

	return configPath;
d1037 3
a1039 1
	xf86conffree (configPath);
d1041 3
a1043 1
	xf86conffree (configRBuf);
d1045 1
a1045 1
	xf86conffree (configBuf);
d1048 1
a1048 4
	if (configFile) {
		fclose (configFile);
		configFile = NULL;
	} else {
d1052 7
a1064 5
	configPath = xf86configStrdup("<builtin configuration>");
	configBuf = xf86confmalloc (CONFIG_BUF_LEN);
	configRBuf = xf86confmalloc (CONFIG_BUF_LEN);
	configBuf[0] = '\0';		/* sanity ... */

d1071 2
d1075 1
a1075 1
		 configLineNo, configSection, configPath);
d1087 2
d1090 1
a1090 1
	ErrorF ("Data incomplete in file %s\n\t", configPath);
d1102 2
a1103 2
		xf86conffree(configSection);
	configSection = xf86confmalloc(strlen (section) + 1);
d1135 1
a1135 1
_X_EXPORT int
d1200 1
a1200 1
	if ((str = xf86confrealloc(cur, len + curlen)) == NULL)
d1214 30
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a68 1
#if !defined(X_NOT_POSIX)
d76 1
a76 1
#endif /* !X_NOT_POSIX */
d438 1
a438 1
				configRBuf[++i] = (c = configBuf[configPos++]);;
@


1.1
log
@Initial revision
@
text
@a1 1
 * 
d67 1
a108 4
#ifdef __UNIXOS2__
extern char *__XOS2RedirRoot(char *path);
#endif

d115 1
a115 1
unsigned int
d383 1
d385 2
d388 1
d390 2
d393 1
d395 2
a530 4
#ifdef __UNIXOS2__
	if (path && (path[0] == '\\' || (path[1] == ':')))
		return 1;
#endif
a570 1
 *    %D    $HOME
a573 1
 *    %&    UNIXOS2 only: prepend X11ROOT env var
d624 1
a624 1
	static const char *env = NULL, *home = NULL;
a626 3
#ifdef __UNIXOS2__
	static char *x11root = NULL;
#endif
a714 8
			case 'D':
				if (!home)
					home = getenv("HOME");
				if (home && xf86pathIsAbsolute(home))
					APPEND_STR(home);
				else
					BAIL_OUT;
				break;
a734 10
#ifdef __UNIXOS2__
			case '&':
				if (!x11root)
					x11root = getenv("X11ROOT");
				if (x11root)
					APPEND_STR(x11root);
				else
					BAIL_OUT;
				break;
#endif
a902 14
xf86parseWarning (char *format,...)
{
	va_list ap;

	ErrorF ("Parse warning on line %d of section %s in file %s\n\t",
		 configLineNo, configSection, configPath);
	va_start (ap, format);
	VErrorF (format, ap);
	va_end (ap);

	ErrorF ("\n");
}

void
d952 1
a952 1
int
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 1
d109 4
d119 1
a119 1
static unsigned int
d526 4
d574 1
d628 3
d747 10
d916 14
@

