head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.6
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.05.29.12.02.38;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	s0SI41sEunLdyFfd;

1.6
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright (c) 2009 Dan Nicholson
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <string.h>
#include "os.h"
#include "xf86Parser.h"
#include "xf86tokens.h"
#include "Configint.h"


static
xf86ConfigSymTabRec InputClassTab[] = {
    {ENDSECTION, "endsection"},
    {IDENTIFIER, "identifier"},
    {OPTION, "option"},
    {DRIVER, "driver"},
    {MATCH_PRODUCT, "matchproduct"},
    {MATCH_VENDOR, "matchvendor"},
    {MATCH_DEVICE_PATH, "matchdevicepath"},
    {MATCH_OS, "matchos"},
    {MATCH_PNPID, "matchpnpid"},
    {MATCH_USBID, "matchusbid"},
    {MATCH_DRIVER, "matchdriver"},
    {MATCH_TAG, "matchtag"},
    {MATCH_LAYOUT, "matchlayout"},
    {MATCH_IS_KEYBOARD, "matchiskeyboard"},
    {MATCH_IS_POINTER, "matchispointer"},
    {MATCH_IS_JOYSTICK, "matchisjoystick"},
    {MATCH_IS_TABLET, "matchistablet"},
    {MATCH_IS_TOUCHPAD, "matchistouchpad"},
    {MATCH_IS_TOUCHSCREEN, "matchistouchscreen"},
    {-1, ""},
};

static void
xf86freeInputClassList(XF86ConfInputClassPtr ptr)
{
    XF86ConfInputClassPtr prev;

    while (ptr) {
        xf86MatchGroup *group, *next;
        char **list;

        TestFree(ptr->identifier);
        TestFree(ptr->driver);

        xorg_list_for_each_entry_safe(group, next, &ptr->match_product, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_vendor, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_device, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_os, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_pnpid, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_usbid, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_driver, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_tag, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_layout, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }

        TestFree(ptr->comment);
        xf86optionListFree(ptr->option_lst);

        prev = ptr;
        ptr = ptr->list.next;
        free(prev);
    }
}

#define CLEANUP xf86freeInputClassList

#define TOKEN_SEP "|"

static void
add_group_entry(struct xorg_list *head, char **values)
{
    xf86MatchGroup *group;

    group = malloc(sizeof(*group));
    if (group) {
        group->values = values;
        xorg_list_add(&group->entry, head);
    }
}

XF86ConfInputClassPtr
xf86parseInputClassSection(void)
{
    int has_ident = FALSE;
    int token;

    parsePrologue(XF86ConfInputClassPtr, XF86ConfInputClassRec)

        /* Initialize MatchGroup lists */
        xorg_list_init(&ptr->match_product);
    xorg_list_init(&ptr->match_vendor);
    xorg_list_init(&ptr->match_device);
    xorg_list_init(&ptr->match_os);
    xorg_list_init(&ptr->match_pnpid);
    xorg_list_init(&ptr->match_usbid);
    xorg_list_init(&ptr->match_driver);
    xorg_list_init(&ptr->match_tag);
    xorg_list_init(&ptr->match_layout);

    while ((token = xf86getToken(InputClassTab)) != ENDSECTION) {
        switch (token) {
        case COMMENT:
            ptr->comment = xf86addComment(ptr->comment, xf86_lex_val.str);
            break;
        case IDENTIFIER:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "Identifier");
            if (has_ident == TRUE)
                Error(MULTIPLE_MSG, "Identifier");
            ptr->identifier = xf86_lex_val.str;
            has_ident = TRUE;
            break;
        case DRIVER:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "Driver");
            if (strcmp(xf86_lex_val.str, "keyboard") == 0) {
                ptr->driver = strdup("kbd");
                free(xf86_lex_val.str);
            }
            else
                ptr->driver = xf86_lex_val.str;
            break;
        case OPTION:
            ptr->option_lst = xf86parseOption(ptr->option_lst);
            break;
        case MATCH_PRODUCT:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "MatchProduct");
            add_group_entry(&ptr->match_product,
                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP));
            free(xf86_lex_val.str);
            break;
        case MATCH_VENDOR:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "MatchVendor");
            add_group_entry(&ptr->match_vendor,
                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP));
            free(xf86_lex_val.str);
            break;
        case MATCH_DEVICE_PATH:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "MatchDevicePath");
            add_group_entry(&ptr->match_device,
                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP));
            free(xf86_lex_val.str);
            break;
        case MATCH_OS:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "MatchOS");
            add_group_entry(&ptr->match_os, xstrtokenize(xf86_lex_val.str, TOKEN_SEP));
            free(xf86_lex_val.str);
            break;
        case MATCH_PNPID:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "MatchPnPID");
            add_group_entry(&ptr->match_pnpid,
                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP));
            free(xf86_lex_val.str);
            break;
        case MATCH_USBID:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "MatchUSBID");
            add_group_entry(&ptr->match_usbid,
                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP));
            free(xf86_lex_val.str);
            break;
        case MATCH_DRIVER:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "MatchDriver");
            add_group_entry(&ptr->match_driver,
                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP));
            free(xf86_lex_val.str);
            break;
        case MATCH_TAG:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "MatchTag");
            add_group_entry(&ptr->match_tag, xstrtokenize(xf86_lex_val.str, TOKEN_SEP));
            free(xf86_lex_val.str);
            break;
        case MATCH_LAYOUT:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "MatchLayout");
            add_group_entry(&ptr->match_layout,
                            xstrtokenize(xf86_lex_val.str, TOKEN_SEP));
            free(xf86_lex_val.str);
            break;
        case MATCH_IS_KEYBOARD:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "MatchIsKeyboard");
            ptr->is_keyboard.set = xf86getBoolValue(&ptr->is_keyboard.val,
                                                    xf86_lex_val.str);
            free(xf86_lex_val.str);
            if (!ptr->is_keyboard.set)
                Error(BOOL_MSG, "MatchIsKeyboard");
            break;
        case MATCH_IS_POINTER:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "MatchIsPointer");
            ptr->is_pointer.set = xf86getBoolValue(&ptr->is_pointer.val,
                                                   xf86_lex_val.str);
            free(xf86_lex_val.str);
            if (!ptr->is_pointer.set)
                Error(BOOL_MSG, "MatchIsPointer");
            break;
        case MATCH_IS_JOYSTICK:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "MatchIsJoystick");
            ptr->is_joystick.set = xf86getBoolValue(&ptr->is_joystick.val,
                                                    xf86_lex_val.str);
            free(xf86_lex_val.str);
            if (!ptr->is_joystick.set)
                Error(BOOL_MSG, "MatchIsJoystick");
            break;
        case MATCH_IS_TABLET:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "MatchIsTablet");
            ptr->is_tablet.set = xf86getBoolValue(&ptr->is_tablet.val, xf86_lex_val.str);
            free(xf86_lex_val.str);
            if (!ptr->is_tablet.set)
                Error(BOOL_MSG, "MatchIsTablet");
            break;
        case MATCH_IS_TOUCHPAD:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "MatchIsTouchpad");
            ptr->is_touchpad.set = xf86getBoolValue(&ptr->is_touchpad.val,
                                                    xf86_lex_val.str);
            free(xf86_lex_val.str);
            if (!ptr->is_touchpad.set)
                Error(BOOL_MSG, "MatchIsTouchpad");
            break;
        case MATCH_IS_TOUCHSCREEN:
            if (xf86getSubToken(&(ptr->comment)) != STRING)
                Error(QUOTE_MSG, "MatchIsTouchscreen");
            ptr->is_touchscreen.set = xf86getBoolValue(&ptr->is_touchscreen.val,
                                                       xf86_lex_val.str);
            free(xf86_lex_val.str);
            if (!ptr->is_touchscreen.set)
                Error(BOOL_MSG, "MatchIsTouchscreen");
            break;
        case EOF_TOKEN:
            Error(UNEXPECTED_EOF_MSG);
            break;
        default:
            Error(INVALID_KEYWORD_MSG, xf86tokenString());
            break;
        }
    }

    if (!has_ident)
        Error(NO_IDENT_MSG);

#ifdef DEBUG
    printf("InputClass section parsed\n");
#endif

    return ptr;
}

void
xf86printInputClassSection(FILE * cf, XF86ConfInputClassPtr ptr)
{
    const xf86MatchGroup *group;
    char *const *cur;

    while (ptr) {
        fprintf(cf, "Section \"InputClass\"\n");
        if (ptr->comment)
            fprintf(cf, "%s", ptr->comment);
        if (ptr->identifier)
            fprintf(cf, "\tIdentifier      \"%s\"\n", ptr->identifier);
        if (ptr->driver)
            fprintf(cf, "\tDriver          \"%s\"\n", ptr->driver);

        xorg_list_for_each_entry(group, &ptr->match_product, entry) {
            fprintf(cf, "\tMatchProduct    \"");
            for (cur = group->values; *cur; cur++)
                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
                        *cur);
            fprintf(cf, "\"\n");
        }
        xorg_list_for_each_entry(group, &ptr->match_vendor, entry) {
            fprintf(cf, "\tMatchVendor     \"");
            for (cur = group->values; *cur; cur++)
                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
                        *cur);
            fprintf(cf, "\"\n");
        }
        xorg_list_for_each_entry(group, &ptr->match_device, entry) {
            fprintf(cf, "\tMatchDevicePath \"");
            for (cur = group->values; *cur; cur++)
                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
                        *cur);
            fprintf(cf, "\"\n");
        }
        xorg_list_for_each_entry(group, &ptr->match_os, entry) {
            fprintf(cf, "\tMatchOS         \"");
            for (cur = group->values; *cur; cur++)
                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
                        *cur);
            fprintf(cf, "\"\n");
        }
        xorg_list_for_each_entry(group, &ptr->match_pnpid, entry) {
            fprintf(cf, "\tMatchPnPID      \"");
            for (cur = group->values; *cur; cur++)
                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
                        *cur);
            fprintf(cf, "\"\n");
        }
        xorg_list_for_each_entry(group, &ptr->match_usbid, entry) {
            fprintf(cf, "\tMatchUSBID      \"");
            for (cur = group->values; *cur; cur++)
                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
                        *cur);
            fprintf(cf, "\"\n");
        }
        xorg_list_for_each_entry(group, &ptr->match_driver, entry) {
            fprintf(cf, "\tMatchDriver     \"");
            for (cur = group->values; *cur; cur++)
                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
                        *cur);
            fprintf(cf, "\"\n");
        }
        xorg_list_for_each_entry(group, &ptr->match_tag, entry) {
            fprintf(cf, "\tMatchTag        \"");
            for (cur = group->values; *cur; cur++)
                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
                        *cur);
            fprintf(cf, "\"\n");
        }
        xorg_list_for_each_entry(group, &ptr->match_layout, entry) {
            fprintf(cf, "\tMatchLayout     \"");
            for (cur = group->values; *cur; cur++)
                fprintf(cf, "%s%s", cur == group->values ? "" : TOKEN_SEP,
                        *cur);
            fprintf(cf, "\"\n");
        }

        if (ptr->is_keyboard.set)
            fprintf(cf, "\tIsKeyboard      \"%s\"\n",
                    ptr->is_keyboard.val ? "yes" : "no");
        if (ptr->is_pointer.set)
            fprintf(cf, "\tIsPointer       \"%s\"\n",
                    ptr->is_pointer.val ? "yes" : "no");
        if (ptr->is_joystick.set)
            fprintf(cf, "\tIsJoystick      \"%s\"\n",
                    ptr->is_joystick.val ? "yes" : "no");
        if (ptr->is_tablet.set)
            fprintf(cf, "\tIsTablet        \"%s\"\n",
                    ptr->is_tablet.val ? "yes" : "no");
        if (ptr->is_touchpad.set)
            fprintf(cf, "\tIsTouchpad      \"%s\"\n",
                    ptr->is_touchpad.val ? "yes" : "no");
        if (ptr->is_touchscreen.set)
            fprintf(cf, "\tIsTouchscreen   \"%s\"\n",
                    ptr->is_touchscreen.val ? "yes" : "no");
        xf86printOptionList(cf, ptr->option_lst, 1);
        fprintf(cf, "EndSection\n\n");
        ptr = ptr->list.next;
    }
}
@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d61 76
a430 76
    }
}

void
xf86freeInputClassList(XF86ConfInputClassPtr ptr)
{
    XF86ConfInputClassPtr prev;

    while (ptr) {
        xf86MatchGroup *group, *next;
        char **list;

        TestFree(ptr->identifier);
        TestFree(ptr->driver);

        xorg_list_for_each_entry_safe(group, next, &ptr->match_product, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_vendor, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_device, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_os, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_pnpid, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_usbid, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_driver, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_tag, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }
        xorg_list_for_each_entry_safe(group, next, &ptr->match_layout, entry) {
            xorg_list_del(&group->entry);
            for (list = group->values; *list; list++)
                free(*list);
            free(group);
        }

        TestFree(ptr->comment);
        xf86optionListFree(ptr->option_lst);

        prev = ptr;
        ptr = ptr->list.next;
        free(prev);
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a35 1
extern LexRec val;
d99 1
a99 1
            ptr->comment = xf86addComment(ptr->comment, val.str);
d106 1
a106 1
            ptr->identifier = val.str;
d112 1
a112 1
            if (strcmp(val.str, "keyboard") == 0) {
d114 1
a114 1
                free(val.str);
d117 1
a117 1
                ptr->driver = val.str;
d126 2
a127 2
                            xstrtokenize(val.str, TOKEN_SEP));
            free(val.str);
d133 2
a134 2
                            xstrtokenize(val.str, TOKEN_SEP));
            free(val.str);
d140 2
a141 2
                            xstrtokenize(val.str, TOKEN_SEP));
            free(val.str);
d146 2
a147 2
            add_group_entry(&ptr->match_os, xstrtokenize(val.str, TOKEN_SEP));
            free(val.str);
d153 2
a154 2
                            xstrtokenize(val.str, TOKEN_SEP));
            free(val.str);
d160 2
a161 2
                            xstrtokenize(val.str, TOKEN_SEP));
            free(val.str);
d167 2
a168 2
                            xstrtokenize(val.str, TOKEN_SEP));
            free(val.str);
d173 2
a174 2
            add_group_entry(&ptr->match_tag, xstrtokenize(val.str, TOKEN_SEP));
            free(val.str);
d180 2
a181 2
                            xstrtokenize(val.str, TOKEN_SEP));
            free(val.str);
d187 2
a188 2
                                                    val.str);
            free(val.str);
d196 2
a197 2
                                                   val.str);
            free(val.str);
d205 2
a206 2
                                                    val.str);
            free(val.str);
d213 2
a214 2
            ptr->is_tablet.set = xf86getBoolValue(&ptr->is_tablet.val, val.str);
            free(val.str);
d222 2
a223 2
                                                    val.str);
            free(val.str);
d231 2
a232 2
                                                       val.str);
            free(val.str);
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a25 2
/* View/edit this file with tab stops set to 4 */

@


1.3
log
@Update to xserver 1.11.2
@
text
@d41 1
a41 2
xf86ConfigSymTabRec InputClassTab[] =
{
d69 1
a69 1
add_group_entry(struct list *head, char **values)
d76 1
a76 1
        list_add(&group->entry, head);
d88 10
a97 10
    /* Initialize MatchGroup lists */
    list_init(&ptr->match_product);
    list_init(&ptr->match_vendor);
    list_init(&ptr->match_device);
    list_init(&ptr->match_os);
    list_init(&ptr->match_pnpid);
    list_init(&ptr->match_usbid);
    list_init(&ptr->match_driver);
    list_init(&ptr->match_tag);
    list_init(&ptr->match_layout);
d130 1
d137 1
d144 1
d149 2
a150 2
            add_group_entry(&ptr->match_os,
                            xstrtokenize(val.str, TOKEN_SEP));
d157 1
d164 1
d171 1
d176 2
a177 2
            add_group_entry(&ptr->match_tag,
                            xstrtokenize(val.str, TOKEN_SEP));
d184 1
d191 1
d200 1
d209 1
d216 2
a217 2
            ptr->is_tablet.set = xf86getBoolValue(&ptr->is_tablet.val,
                                                  val.str);
d226 1
d235 1
d240 1
a240 1
            Error(UNEXPECTED_EOF_MSG, NULL);
d243 1
a243 1
            Error(INVALID_KEYWORD_MSG, xf86tokenString ());
d249 1
a249 1
        Error(NO_IDENT_MSG, NULL);
d259 1
a259 1
xf86printInputClassSection (FILE * cf, XF86ConfInputClassPtr ptr)
d262 1
a262 1
    char * const *cur;
d273 1
a273 1
        list_for_each_entry(group, &ptr->match_product, entry) {
d280 1
a280 1
        list_for_each_entry(group, &ptr->match_vendor, entry) {
d287 1
a287 1
        list_for_each_entry(group, &ptr->match_device, entry) {
d294 1
a294 1
        list_for_each_entry(group, &ptr->match_os, entry) {
d301 1
a301 1
        list_for_each_entry(group, &ptr->match_pnpid, entry) {
d308 1
a308 1
        list_for_each_entry(group, &ptr->match_usbid, entry) {
d315 1
a315 1
        list_for_each_entry(group, &ptr->match_driver, entry) {
d322 1
a322 1
        list_for_each_entry(group, &ptr->match_tag, entry) {
d329 1
a329 1
        list_for_each_entry(group, &ptr->match_layout, entry) {
d362 1
a362 1
xf86freeInputClassList (XF86ConfInputClassPtr ptr)
d373 2
a374 2
        list_for_each_entry_safe(group, next, &ptr->match_product, entry) {
            list_del(&group->entry);
d379 2
a380 2
        list_for_each_entry_safe(group, next, &ptr->match_vendor, entry) {
            list_del(&group->entry);
d385 2
a386 2
        list_for_each_entry_safe(group, next, &ptr->match_device, entry) {
            list_del(&group->entry);
d391 2
a392 2
        list_for_each_entry_safe(group, next, &ptr->match_os, entry) {
            list_del(&group->entry);
d397 2
a398 2
        list_for_each_entry_safe(group, next, &ptr->match_pnpid, entry) {
            list_del(&group->entry);
d403 2
a404 2
        list_for_each_entry_safe(group, next, &ptr->match_usbid, entry) {
            list_del(&group->entry);
d409 2
a410 2
        list_for_each_entry_safe(group, next, &ptr->match_driver, entry) {
            list_del(&group->entry);
d415 2
a416 2
        list_for_each_entry_safe(group, next, &ptr->match_tag, entry) {
            list_del(&group->entry);
d421 2
a422 2
        list_for_each_entry_safe(group, next, &ptr->match_layout, entry) {
            list_del(&group->entry);
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d55 1
d98 1
d174 6
d318 7
d405 6
@


1.1
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d50 4
d68 12
d88 10
d114 4
a117 2
            if (strcmp(val.str, "keyboard") == 0)
                ptr->driver = "kbd";
d127 2
a128 1
            ptr->match_product = xstrtokenize(val.str, TOKEN_SEP);
d133 2
a134 1
            ptr->match_vendor = xstrtokenize(val.str, TOKEN_SEP);
d139 26
a164 1
            ptr->match_device = xstrtokenize(val.str, TOKEN_SEP);
d169 2
a170 1
            ptr->match_tag = xstrtokenize(val.str, TOKEN_SEP);
d242 2
a243 1
    char **list;
d253 2
a254 1
        if (ptr->match_product) {
d256 3
a258 4
            for (list = ptr->match_product; *list; list++)
                fprintf(cf, "%s%s",
                        list == ptr->match_product ? "" : TOKEN_SEP,
                        *list);
d261 1
a261 1
        if (ptr->match_vendor) {
d263 3
a265 4
            for (list = ptr->match_vendor; *list; list++)
                fprintf(cf, "%s%s",
                        list == ptr->match_vendor ? "" : TOKEN_SEP,
                        *list);
d268 1
a268 1
        if (ptr->match_device) {
d270 10
a279 4
            for (list = ptr->match_device; *list; list++)
                fprintf(cf, "%s%s",
                        list == ptr->match_device ? "" : TOKEN_SEP,
                        *list);
d282 5
a286 6
        if (ptr->match_tag) {
            fprintf(cf, "\tMatchTag \"");
            for (list = ptr->match_tag; *list; list++)
                fprintf(cf, "%s%s",
                        list == ptr->match_tag ? "" : TOKEN_SEP,
                        *list);
d289 22
a338 1
    char **list;
d341 3
d346 4
a349 2
        if (ptr->match_product) {
            for (list = ptr->match_product; *list; list++)
d351 1
a351 1
            free(ptr->match_product);
d353 3
a355 2
        if (ptr->match_vendor) {
            for (list = ptr->match_vendor; *list; list++)
d357 1
a357 1
            free(ptr->match_vendor);
d359 3
a361 2
        if (ptr->match_device) {
            for (list = ptr->match_device; *list; list++)
d363 1
a363 1
            free(ptr->match_device);
d365 3
a367 2
        if (ptr->match_tag) {
            for (list = ptr->match_tag; *list; list++)
d369 1
a369 1
            free(ptr->match_tag);
d371 25
@

