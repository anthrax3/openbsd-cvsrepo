head	1.9;
access;
symbols
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2013.06.07.17.28.50;	author matthieu;	state dead;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.21.20.10.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.31;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.18.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.18.06;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@/*
 * Copyright (c) 1995  Jon Tombs
 * Copyright (c) 1995, 1996, 1999  XFree86 Inc
 * Copyright (c) 1999 - The XFree86 Project Inc.
 *
 * Written by Mark Vojkovich
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "dixstruct.h"
#include "dixevents.h"
#include "pixmapstr.h"
#include "extnsionst.h"
#include "colormapst.h"
#include "cursorstr.h"
#include "scrnintstr.h"
#include "servermd.h"
#include <X11/extensions/xf86dgaproto.h>
#include "swaprep.h"
#include "dgaproc.h"
#include "protocol-versions.h"

#include <string.h>

#include "modinit.h"

#define DGA_PROTOCOL_OLD_SUPPORT 1

static void XDGAResetProc(ExtensionEntry * extEntry);

static void DGAClientStateChange(CallbackListPtr *, pointer, pointer);

unsigned char DGAReqCode = 0;
int DGAErrorBase;
int DGAEventBase;

static DevPrivateKeyRec DGAScreenPrivateKeyRec;

#define DGAScreenPrivateKey (&DGAScreenPrivateKeyRec)
#define DGAScreenPrivateKeyRegistered (DGAScreenPrivateKeyRec.initialized)
static DevPrivateKeyRec DGAClientPrivateKeyRec;

#define DGAClientPrivateKey (&DGAClientPrivateKeyRec)
static int DGACallbackRefCount = 0;

/* This holds the client's version information */
typedef struct {
    int major;
    int minor;
} DGAPrivRec, *DGAPrivPtr;

#define DGA_GETCLIENT(idx) ((ClientPtr) \
    dixLookupPrivate(&screenInfo.screens[idx]->devPrivates, DGAScreenPrivateKey))
#define DGA_SETCLIENT(idx,p) \
    dixSetPrivate(&screenInfo.screens[idx]->devPrivates, DGAScreenPrivateKey, p)

#define DGA_GETPRIV(c) ((DGAPrivPtr) \
    dixLookupPrivate(&(c)->devPrivates, DGAClientPrivateKey))
#define DGA_SETPRIV(c,p) \
    dixSetPrivate(&(c)->devPrivates, DGAClientPrivateKey, p)

static void
XDGAResetProc(ExtensionEntry * extEntry)
{
    DeleteCallback(&ClientStateCallback, DGAClientStateChange, NULL);
    DGACallbackRefCount = 0;
}

static int
ProcXDGAQueryVersion(ClientPtr client)
{
    xXDGAQueryVersionReply rep;

    REQUEST_SIZE_MATCH(xXDGAQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_XDGA_MAJOR_VERSION;
    rep.minorVersion = SERVER_XDGA_MINOR_VERSION;

    WriteToClient(client, sizeof(xXDGAQueryVersionReply), (char *) &rep);
    return Success;
}

static int
ProcXDGAOpenFramebuffer(ClientPtr client)
{
    REQUEST(xXDGAOpenFramebufferReq);
    xXDGAOpenFramebufferReply rep;
    char *deviceName;
    int nameSize;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (!DGAAvailable(stuff->screen))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    REQUEST_SIZE_MATCH(xXDGAOpenFramebufferReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    if (!DGAOpenFramebuffer(stuff->screen, &deviceName,
                            (unsigned char **) (&rep.mem1),
                            (int *) &rep.size, (int *) &rep.offset,
                            (int *) &rep.extra)) {
        return BadAlloc;
    }

    nameSize = deviceName ? (strlen(deviceName) + 1) : 0;
    rep.length = bytes_to_int32(nameSize);

    WriteToClient(client, sizeof(xXDGAOpenFramebufferReply), (char *) &rep);
    if (rep.length)
        WriteToClient(client, nameSize, deviceName);

    return Success;
}

static int
ProcXDGACloseFramebuffer(ClientPtr client)
{
    REQUEST(xXDGACloseFramebufferReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (!DGAAvailable(stuff->screen))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    REQUEST_SIZE_MATCH(xXDGACloseFramebufferReq);

    DGACloseFramebuffer(stuff->screen);

    return Success;
}

static int
ProcXDGAQueryModes(ClientPtr client)
{
    int i, num, size;

    REQUEST(xXDGAQueryModesReq);
    xXDGAQueryModesReply rep;
    xXDGAModeInfo info;
    XDGAModePtr mode;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    REQUEST_SIZE_MATCH(xXDGAQueryModesReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.number = 0;
    rep.sequenceNumber = client->sequence;

    if (!DGAAvailable(stuff->screen)) {
        rep.number = 0;
        rep.length = 0;
        WriteToClient(client, sz_xXDGAQueryModesReply, (char *) &rep);
        return Success;
    }

    if (!(num = DGAGetModes(stuff->screen))) {
        WriteToClient(client, sz_xXDGAQueryModesReply, (char *) &rep);
        return Success;
    }

    if (!(mode = (XDGAModePtr) malloc(num * sizeof(XDGAModeRec))))
        return BadAlloc;

    for (i = 0; i < num; i++)
        DGAGetModeInfo(stuff->screen, mode + i, i + 1);

    size = num * sz_xXDGAModeInfo;
    for (i = 0; i < num; i++)
        size += pad_to_int32(strlen(mode[i].name) + 1); /* plus NULL */

    rep.number = num;
    rep.length = bytes_to_int32(size);

    WriteToClient(client, sz_xXDGAQueryModesReply, (char *) &rep);

    for (i = 0; i < num; i++) {
        size = strlen(mode[i].name) + 1;

        info.byte_order = mode[i].byteOrder;
        info.depth = mode[i].depth;
        info.num = mode[i].num;
        info.bpp = mode[i].bitsPerPixel;
        info.name_size = (size + 3) & ~3L;
        info.vsync_num = mode[i].VSync_num;
        info.vsync_den = mode[i].VSync_den;
        info.flags = mode[i].flags;
        info.image_width = mode[i].imageWidth;
        info.image_height = mode[i].imageHeight;
        info.pixmap_width = mode[i].pixmapWidth;
        info.pixmap_height = mode[i].pixmapHeight;
        info.bytes_per_scanline = mode[i].bytesPerScanline;
        info.red_mask = mode[i].red_mask;
        info.green_mask = mode[i].green_mask;
        info.blue_mask = mode[i].blue_mask;
        info.visual_class = mode[i].visualClass;
        info.viewport_width = mode[i].viewportWidth;
        info.viewport_height = mode[i].viewportHeight;
        info.viewport_xstep = mode[i].xViewportStep;
        info.viewport_ystep = mode[i].yViewportStep;
        info.viewport_xmax = mode[i].maxViewportX;
        info.viewport_ymax = mode[i].maxViewportY;
        info.viewport_flags = mode[i].viewportFlags;
        info.reserved1 = mode[i].reserved1;
        info.reserved2 = mode[i].reserved2;

        WriteToClient(client, sz_xXDGAModeInfo, (char *) (&info));
        WriteToClient(client, size, mode[i].name);
    }

    free(mode);

    return Success;
}

static void
DGAClientStateChange(CallbackListPtr *pcbl, pointer nulldata, pointer calldata)
{
    NewClientInfoRec *pci = (NewClientInfoRec *) calldata;
    ClientPtr client = NULL;
    int i;

    for (i = 0; i < screenInfo.numScreens; i++) {
        if (DGA_GETCLIENT(i) == pci->client) {
            client = pci->client;
            break;
        }
    }

    if (client &&
        ((client->clientState == ClientStateGone) ||
         (client->clientState == ClientStateRetained))) {
        XDGAModeRec mode;
        PixmapPtr pPix;

        DGA_SETCLIENT(i, NULL);
        DGASelectInput(i, NULL, 0);
        DGASetMode(i, 0, &mode, &pPix);

        if (--DGACallbackRefCount == 0)
            DeleteCallback(&ClientStateCallback, DGAClientStateChange, NULL);
    }
}

static int
ProcXDGASetMode(ClientPtr client)
{
    REQUEST(xXDGASetModeReq);
    xXDGASetModeReply rep;
    XDGAModeRec mode;
    xXDGAModeInfo info;
    PixmapPtr pPix;
    ClientPtr owner;
    int size;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;
    owner = DGA_GETCLIENT(stuff->screen);

    REQUEST_SIZE_MATCH(xXDGASetModeReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.offset = 0;
    rep.flags = 0;
    rep.sequenceNumber = client->sequence;

    if (!DGAAvailable(stuff->screen))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    if (owner && owner != client)
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    if (!stuff->mode) {
        if (owner) {
            if (--DGACallbackRefCount == 0)
                DeleteCallback(&ClientStateCallback, DGAClientStateChange,
                               NULL);
        }
        DGA_SETCLIENT(stuff->screen, NULL);
        DGASelectInput(stuff->screen, NULL, 0);
        DGASetMode(stuff->screen, 0, &mode, &pPix);
        WriteToClient(client, sz_xXDGASetModeReply, (char *) &rep);
        return Success;
    }

    if (Success != DGASetMode(stuff->screen, stuff->mode, &mode, &pPix))
        return BadValue;

    if (!owner) {
        if (DGACallbackRefCount++ == 0)
            AddCallback(&ClientStateCallback, DGAClientStateChange, NULL);
    }

    DGA_SETCLIENT(stuff->screen, client);

    if (pPix) {
        if (AddResource(stuff->pid, RT_PIXMAP, (pointer) (pPix))) {
            pPix->drawable.id = (int) stuff->pid;
            rep.flags = DGA_PIXMAP_AVAILABLE;
        }
    }

    size = strlen(mode.name) + 1;

    info.byte_order = mode.byteOrder;
    info.depth = mode.depth;
    info.num = mode.num;
    info.bpp = mode.bitsPerPixel;
    info.name_size = (size + 3) & ~3L;
    info.vsync_num = mode.VSync_num;
    info.vsync_den = mode.VSync_den;
    info.flags = mode.flags;
    info.image_width = mode.imageWidth;
    info.image_height = mode.imageHeight;
    info.pixmap_width = mode.pixmapWidth;
    info.pixmap_height = mode.pixmapHeight;
    info.bytes_per_scanline = mode.bytesPerScanline;
    info.red_mask = mode.red_mask;
    info.green_mask = mode.green_mask;
    info.blue_mask = mode.blue_mask;
    info.visual_class = mode.visualClass;
    info.viewport_width = mode.viewportWidth;
    info.viewport_height = mode.viewportHeight;
    info.viewport_xstep = mode.xViewportStep;
    info.viewport_ystep = mode.yViewportStep;
    info.viewport_xmax = mode.maxViewportX;
    info.viewport_ymax = mode.maxViewportY;
    info.viewport_flags = mode.viewportFlags;
    info.reserved1 = mode.reserved1;
    info.reserved2 = mode.reserved2;

    rep.length = bytes_to_int32(sz_xXDGAModeInfo + info.name_size);

    WriteToClient(client, sz_xXDGASetModeReply, (char *) &rep);
    WriteToClient(client, sz_xXDGAModeInfo, (char *) (&info));
    WriteToClient(client, size, mode.name);

    return Success;
}

static int
ProcXDGASetViewport(ClientPtr client)
{
    REQUEST(xXDGASetViewportReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGASetViewportReq);

    DGASetViewport(stuff->screen, stuff->x, stuff->y, stuff->flags);

    return Success;
}

static int
ProcXDGAInstallColormap(ClientPtr client)
{
    ColormapPtr cmap;
    int rc;

    REQUEST(xXDGAInstallColormapReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGAInstallColormapReq);

    rc = dixLookupResourceByType((pointer *) &cmap, stuff->cmap, RT_COLORMAP,
                                 client, DixInstallAccess);
    if (rc != Success)
        return rc;
    DGAInstallCmap(cmap);
    return Success;
}

static int
ProcXDGASelectInput(ClientPtr client)
{
    REQUEST(xXDGASelectInputReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGASelectInputReq);

    if (DGA_GETCLIENT(stuff->screen) == client)
        DGASelectInput(stuff->screen, client, stuff->mask);

    return Success;
}

static int
ProcXDGAFillRectangle(ClientPtr client)
{
    REQUEST(xXDGAFillRectangleReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGAFillRectangleReq);

    if (Success != DGAFillRect(stuff->screen, stuff->x, stuff->y,
                               stuff->width, stuff->height, stuff->color))
        return BadMatch;

    return Success;
}

static int
ProcXDGACopyArea(ClientPtr client)
{
    REQUEST(xXDGACopyAreaReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGACopyAreaReq);

    if (Success != DGABlitRect(stuff->screen, stuff->srcx, stuff->srcy,
                               stuff->width, stuff->height, stuff->dstx,
                               stuff->dsty))
        return BadMatch;

    return Success;
}

static int
ProcXDGACopyTransparentArea(ClientPtr client)
{
    REQUEST(xXDGACopyTransparentAreaReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGACopyTransparentAreaReq);

    if (Success != DGABlitTransRect(stuff->screen, stuff->srcx, stuff->srcy,
                                    stuff->width, stuff->height, stuff->dstx,
                                    stuff->dsty, stuff->key))
        return BadMatch;

    return Success;
}

static int
ProcXDGAGetViewportStatus(ClientPtr client)
{
    REQUEST(xXDGAGetViewportStatusReq);
    xXDGAGetViewportStatusReply rep;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGAGetViewportStatusReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    rep.status = DGAGetViewportStatus(stuff->screen);

    WriteToClient(client, sizeof(xXDGAGetViewportStatusReply), (char *) &rep);
    return Success;
}

static int
ProcXDGASync(ClientPtr client)
{
    REQUEST(xXDGASyncReq);
    xXDGASyncReply rep;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGASyncReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    DGASync(stuff->screen);

    WriteToClient(client, sizeof(xXDGASyncReply), (char *) &rep);
    return Success;
}

static int
ProcXDGASetClientVersion(ClientPtr client)
{
    REQUEST(xXDGASetClientVersionReq);

    DGAPrivPtr pPriv;

    REQUEST_SIZE_MATCH(xXDGASetClientVersionReq);
    if ((pPriv = DGA_GETPRIV(client)) == NULL) {
        pPriv = malloc(sizeof(DGAPrivRec));
        /* XXX Need to look into freeing this */
        if (!pPriv)
            return BadAlloc;
        DGA_SETPRIV(client, pPriv);
    }
    pPriv->major = stuff->major;
    pPriv->minor = stuff->minor;

    return Success;
}

static int
ProcXDGAChangePixmapMode(ClientPtr client)
{
    REQUEST(xXDGAChangePixmapModeReq);
    xXDGAChangePixmapModeReply rep;
    int x, y;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGAChangePixmapModeReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    x = stuff->x;
    y = stuff->y;

    if (!DGAChangePixmapMode(stuff->screen, &x, &y, stuff->flags))
        return BadMatch;

    rep.x = x;
    rep.y = y;
    WriteToClient(client, sizeof(xXDGAChangePixmapModeReply), (char *) &rep);

    return Success;
}

static int
ProcXDGACreateColormap(ClientPtr client)
{
    REQUEST(xXDGACreateColormapReq);
    int result;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGACreateColormapReq);

    if (!stuff->mode)
        return BadValue;

    result = DGACreateColormap(stuff->screen, client, stuff->id,
                               stuff->mode, stuff->alloc);
    if (result != Success)
        return result;

    return Success;
}

/*
 *
 * Support for the old DGA protocol, used to live in xf86dga.c
 *
 */

#ifdef DGA_PROTOCOL_OLD_SUPPORT

static int
ProcXF86DGAGetVideoLL(ClientPtr client)
{
    REQUEST(xXF86DGAGetVideoLLReq);
    xXF86DGAGetVideoLLReply rep;
    XDGAModeRec mode;
    int num, offset, flags;
    char *name;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    REQUEST_SIZE_MATCH(xXF86DGAGetVideoLLReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    if (!DGAAvailable(stuff->screen))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    if (!(num = DGAGetOldDGAMode(stuff->screen)))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    /* get the parameters for the mode that best matches */
    DGAGetModeInfo(stuff->screen, &mode, num);

    if (!DGAOpenFramebuffer(stuff->screen, &name,
                            (unsigned char **) (&rep.offset),
                            (int *) (&rep.bank_size), &offset, &flags))
        return BadAlloc;

    rep.offset += mode.offset;
    rep.width = mode.bytesPerScanline / (mode.bitsPerPixel >> 3);
    rep.ram_size = rep.bank_size >> 10;

    WriteToClient(client, SIZEOF(xXF86DGAGetVideoLLReply), (char *) &rep);
    return Success;
}

static int
ProcXF86DGADirectVideo(ClientPtr client)
{
    int num;
    PixmapPtr pix;
    XDGAModeRec mode;
    ClientPtr owner;

    REQUEST(xXF86DGADirectVideoReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;
    REQUEST_SIZE_MATCH(xXF86DGADirectVideoReq);

    if (!DGAAvailable(stuff->screen))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    owner = DGA_GETCLIENT(stuff->screen);

    if (owner && owner != client)
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    if (stuff->enable & XF86DGADirectGraphics) {
        if (!(num = DGAGetOldDGAMode(stuff->screen)))
            return DGAErrorBase + XF86DGANoDirectVideoMode;
    }
    else
        num = 0;

    if (Success != DGASetMode(stuff->screen, num, &mode, &pix))
        return DGAErrorBase + XF86DGAScreenNotActive;

    DGASetInputMode(stuff->screen,
                    (stuff->enable & XF86DGADirectKeyb) != 0,
                    (stuff->enable & XF86DGADirectMouse) != 0);

    /* We need to track the client and attach the teardown callback */
    if (stuff->enable &
        (XF86DGADirectGraphics | XF86DGADirectKeyb | XF86DGADirectMouse)) {
        if (!owner) {
            if (DGACallbackRefCount++ == 0)
                AddCallback(&ClientStateCallback, DGAClientStateChange, NULL);
        }

        DGA_SETCLIENT(stuff->screen, client);
    }
    else {
        if (owner) {
            if (--DGACallbackRefCount == 0)
                DeleteCallback(&ClientStateCallback, DGAClientStateChange,
                               NULL);
        }

        DGA_SETCLIENT(stuff->screen, NULL);
    }

    return Success;
}

static int
ProcXF86DGAGetViewPortSize(ClientPtr client)
{
    int num;
    XDGAModeRec mode;

    REQUEST(xXF86DGAGetViewPortSizeReq);
    xXF86DGAGetViewPortSizeReply rep;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    REQUEST_SIZE_MATCH(xXF86DGAGetViewPortSizeReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    if (!DGAAvailable(stuff->screen))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    if (!(num = DGAGetOldDGAMode(stuff->screen)))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    DGAGetModeInfo(stuff->screen, &mode, num);

    rep.width = mode.viewportWidth;
    rep.height = mode.viewportHeight;

    WriteToClient(client, SIZEOF(xXF86DGAGetViewPortSizeReply), (char *) &rep);
    return Success;
}

static int
ProcXF86DGASetViewPort(ClientPtr client)
{
    REQUEST(xXF86DGASetViewPortReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXF86DGASetViewPortReq);

    if (!DGAAvailable(stuff->screen))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    if (!DGAActive(stuff->screen))
        return DGAErrorBase + XF86DGADirectNotActivated;

    if (DGASetViewport(stuff->screen, stuff->x, stuff->y, DGA_FLIP_RETRACE)
        != Success)
        return DGAErrorBase + XF86DGADirectNotActivated;

    return Success;
}

static int
ProcXF86DGAGetVidPage(ClientPtr client)
{
    REQUEST(xXF86DGAGetVidPageReq);
    xXF86DGAGetVidPageReply rep;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    REQUEST_SIZE_MATCH(xXF86DGAGetVidPageReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.vpage = 0;              /* silently fail */

    WriteToClient(client, SIZEOF(xXF86DGAGetVidPageReply), (char *) &rep);
    return Success;
}

static int
ProcXF86DGASetVidPage(ClientPtr client)
{
    REQUEST(xXF86DGASetVidPageReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    REQUEST_SIZE_MATCH(xXF86DGASetVidPageReq);

    /* silently fail */

    return Success;
}

static int
ProcXF86DGAInstallColormap(ClientPtr client)
{
    ColormapPtr pcmp;
    int rc;

    REQUEST(xXF86DGAInstallColormapReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXF86DGAInstallColormapReq);

    if (!DGAActive(stuff->screen))
        return DGAErrorBase + XF86DGADirectNotActivated;

    rc = dixLookupResourceByType((pointer *) &pcmp, stuff->id, RT_COLORMAP,
                                 client, DixInstallAccess);
    if (rc == Success) {
        DGAInstallCmap(pcmp);
        return Success;
    }
    else {
        return rc;
    }
}

static int
ProcXF86DGAQueryDirectVideo(ClientPtr client)
{
    REQUEST(xXF86DGAQueryDirectVideoReq);
    xXF86DGAQueryDirectVideoReply rep;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    REQUEST_SIZE_MATCH(xXF86DGAQueryDirectVideoReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.flags = 0;

    if (DGAAvailable(stuff->screen))
        rep.flags = XF86DGADirectPresent;

    WriteToClient(client, SIZEOF(xXF86DGAQueryDirectVideoReply), (char *) &rep);
    return Success;
}

static int
ProcXF86DGAViewPortChanged(ClientPtr client)
{
    REQUEST(xXF86DGAViewPortChangedReq);
    xXF86DGAViewPortChangedReply rep;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXF86DGAViewPortChangedReq);

    if (!DGAActive(stuff->screen))
        return DGAErrorBase + XF86DGADirectNotActivated;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.result = 1;

    WriteToClient(client, SIZEOF(xXF86DGAViewPortChangedReply), (char *) &rep);
    return Success;
}

#endif                          /* DGA_PROTOCOL_OLD_SUPPORT */

static int
SProcXDGADispatch(ClientPtr client)
{
    return DGAErrorBase + XF86DGAClientNotLocal;
}

#if 0
#define DGA_REQ_DEBUG
#endif

#ifdef DGA_REQ_DEBUG
static char *dgaMinor[] = {
    "QueryVersion",
    "GetVideoLL",
    "DirectVideo",
    "GetViewPortSize",
    "SetViewPort",
    "GetVidPage",
    "SetVidPage",
    "InstallColormap",
    "QueryDirectVideo",
    "ViewPortChanged",
    "10",
    "11",
    "QueryModes",
    "SetMode",
    "SetViewport",
    "InstallColormap",
    "SelectInput",
    "FillRectangle",
    "CopyArea",
    "CopyTransparentArea",
    "GetViewportStatus",
    "Sync",
    "OpenFramebuffer",
    "CloseFramebuffer",
    "SetClientVersion",
    "ChangePixmapMode",
    "CreateColormap",
};
#endif

static int
ProcXDGADispatch(ClientPtr client)
{
    REQUEST(xReq);

    if (!LocalClient(client))
        return DGAErrorBase + XF86DGAClientNotLocal;

#ifdef DGA_REQ_DEBUG
    if (stuff->data <= X_XDGACreateColormap)
        fprintf(stderr, "    DGA %s\n", dgaMinor[stuff->data]);
#endif

    switch (stuff->data) {
        /*
         * DGA2 Protocol
         */
    case X_XDGAQueryVersion:
        return ProcXDGAQueryVersion(client);
    case X_XDGAQueryModes:
        return ProcXDGAQueryModes(client);
    case X_XDGASetMode:
        return ProcXDGASetMode(client);
    case X_XDGAOpenFramebuffer:
        return ProcXDGAOpenFramebuffer(client);
    case X_XDGACloseFramebuffer:
        return ProcXDGACloseFramebuffer(client);
    case X_XDGASetViewport:
        return ProcXDGASetViewport(client);
    case X_XDGAInstallColormap:
        return ProcXDGAInstallColormap(client);
    case X_XDGASelectInput:
        return ProcXDGASelectInput(client);
    case X_XDGAFillRectangle:
        return ProcXDGAFillRectangle(client);
    case X_XDGACopyArea:
        return ProcXDGACopyArea(client);
    case X_XDGACopyTransparentArea:
        return ProcXDGACopyTransparentArea(client);
    case X_XDGAGetViewportStatus:
        return ProcXDGAGetViewportStatus(client);
    case X_XDGASync:
        return ProcXDGASync(client);
    case X_XDGASetClientVersion:
        return ProcXDGASetClientVersion(client);
    case X_XDGAChangePixmapMode:
        return ProcXDGAChangePixmapMode(client);
    case X_XDGACreateColormap:
        return ProcXDGACreateColormap(client);
        /*
         * Old DGA Protocol
         */
#ifdef DGA_PROTOCOL_OLD_SUPPORT
    case X_XF86DGAGetVideoLL:
        return ProcXF86DGAGetVideoLL(client);
    case X_XF86DGADirectVideo:
        return ProcXF86DGADirectVideo(client);
    case X_XF86DGAGetViewPortSize:
        return ProcXF86DGAGetViewPortSize(client);
    case X_XF86DGASetViewPort:
        return ProcXF86DGASetViewPort(client);
    case X_XF86DGAGetVidPage:
        return ProcXF86DGAGetVidPage(client);
    case X_XF86DGASetVidPage:
        return ProcXF86DGASetVidPage(client);
    case X_XF86DGAInstallColormap:
        return ProcXF86DGAInstallColormap(client);
    case X_XF86DGAQueryDirectVideo:
        return ProcXF86DGAQueryDirectVideo(client);
    case X_XF86DGAViewPortChanged:
        return ProcXF86DGAViewPortChanged(client);
#endif                          /* DGA_PROTOCOL_OLD_SUPPORT */
    default:
        return BadRequest;
    }
}

void
XFree86DGARegister(INITARGS)
{
    XDGAEventBase = &DGAEventBase;
}

void
XFree86DGAExtensionInit(INITARGS)
{
    ExtensionEntry *extEntry;

    if (!dixRegisterPrivateKey(&DGAClientPrivateKeyRec, PRIVATE_CLIENT, 0))
        return;

    if (!dixRegisterPrivateKey(&DGAScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
        return;

    if ((extEntry = AddExtension(XF86DGANAME,
                                 XF86DGANumberEvents,
                                 XF86DGANumberErrors,
                                 ProcXDGADispatch,
                                 SProcXDGADispatch,
                                 XDGAResetProc, StandardMinorOpcode))) {
        int i;

        DGAReqCode = (unsigned char) extEntry->base;
        DGAErrorBase = extEntry->errorBase;
        DGAEventBase = extEntry->eventBase;
        for (i = KeyPress; i <= MotionNotify; i++)
            SetCriticalEvent(DGAEventBase + i);
    }
}
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@@


1.7
log
@Update to xserver 1.11.2
@
text
@a8 1

d35 1
d37 1
a37 3
static void XDGAResetProc(ExtensionEntry *extEntry);

static void DGAClientStateChange (CallbackListPtr*, pointer, pointer);
d44 1
d48 1
d54 2
a55 2
    int		major;
    int		minor;
a67 1

d69 1
a69 1
XDGAResetProc (ExtensionEntry *extEntry)
d71 2
a72 2
   DeleteCallback (&ClientStateCallback, DGAClientStateChange, NULL);
   DGACallbackRefCount = 0;
a74 1

d87 1
a87 1
    WriteToClient(client, sizeof(xXDGAQueryVersionReply), (char *)&rep);
a90 1

d110 5
a114 5
    if(!DGAOpenFramebuffer(stuff->screen, &deviceName,
			(unsigned char**)(&rep.mem1),
			(int*)&rep.size, (int*)&rep.offset, (int*)&rep.extra))
    {
	return BadAlloc;
d120 3
a122 3
    WriteToClient(client, sizeof(xXDGAOpenFramebufferReply), (char *)&rep);
    if(rep.length)
	WriteToClient(client, nameSize, deviceName);
a126 1

d149 1
d165 4
a168 4
	rep.number = 0;
	rep.length = 0;
	WriteToClient(client, sz_xXDGAQueryModesReply, (char*)&rep);
	return Success;
d171 3
a173 3
    if(!(num = DGAGetModes(stuff->screen))) {
	WriteToClient(client, sz_xXDGAQueryModesReply, (char*)&rep);
	return Success;
d176 2
a177 2
    if(!(mode = (XDGAModePtr)malloc(num * sizeof(XDGAModeRec))))
	return BadAlloc;
d179 2
a180 2
    for(i = 0; i < num; i++)
	DGAGetModeInfo(stuff->screen, mode + i, i + 1);
d183 2
a184 2
    for(i = 0; i < num; i++)
	size += pad_to_int32(strlen(mode[i].name) + 1);  /* plus NULL */
d189 1
a189 1
    WriteToClient(client, sz_xXDGAQueryModesReply, (char*)&rep);
d191 2
a192 2
    for(i = 0; i < num; i++) {
	size = strlen(mode[i].name) + 1;
d194 26
a219 26
	info.byte_order = mode[i].byteOrder;
	info.depth = mode[i].depth;
	info.num = mode[i].num;
	info.bpp = mode[i].bitsPerPixel;
	info.name_size = (size + 3) & ~3L;
	info.vsync_num = mode[i].VSync_num;
	info.vsync_den = mode[i].VSync_den;
	info.flags = mode[i].flags;
	info.image_width = mode[i].imageWidth;
	info.image_height = mode[i].imageHeight;
	info.pixmap_width = mode[i].pixmapWidth;
	info.pixmap_height = mode[i].pixmapHeight;
	info.bytes_per_scanline = mode[i].bytesPerScanline;
	info.red_mask = mode[i].red_mask;
	info.green_mask = mode[i].green_mask;
	info.blue_mask = mode[i].blue_mask;
	info.visual_class = mode[i].visualClass;
	info.viewport_width = mode[i].viewportWidth;
	info.viewport_height = mode[i].viewportHeight;
	info.viewport_xstep = mode[i].xViewportStep;
	info.viewport_ystep = mode[i].yViewportStep;
 	info.viewport_xmax = mode[i].maxViewportX;
	info.viewport_ymax = mode[i].maxViewportY;
	info.viewport_flags = mode[i].viewportFlags;
	info.reserved1 = mode[i].reserved1;
	info.reserved2 = mode[i].reserved2;
d221 2
a222 2
	WriteToClient(client, sz_xXDGAModeInfo, (char*)(&info));
	WriteToClient(client, size, mode[i].name);
a229 1

d231 3
a233 6
DGAClientStateChange (
    CallbackListPtr* pcbl,
    pointer nulldata,
    pointer calldata
){
    NewClientInfoRec* pci = (NewClientInfoRec*) calldata;
d237 16
a252 16
    for(i = 0; i < screenInfo.numScreens; i++) {
	if(DGA_GETCLIENT(i) == pci->client) {
	   client = pci->client;
	   break;
	}
    }

    if(client &&
      ((client->clientState == ClientStateGone) ||
       (client->clientState == ClientStateRetained))) {
	XDGAModeRec mode;
	PixmapPtr pPix;

	DGA_SETCLIENT(i, NULL);
	DGASelectInput(i, NULL, 0);
	DGASetMode(i, 0, &mode, &pPix);
d254 2
a255 2
	if(--DGACallbackRefCount == 0)
	    DeleteCallback(&ClientStateCallback, DGAClientStateChange, NULL);
d284 1
a284 1
    if(owner && owner != client)
d287 11
a297 10
    if(!stuff->mode) {
	if(owner) {
	  if(--DGACallbackRefCount == 0)
	    DeleteCallback(&ClientStateCallback, DGAClientStateChange, NULL);
	}
	DGA_SETCLIENT(stuff->screen, NULL);
	DGASelectInput(stuff->screen, NULL, 0);
	DGASetMode(stuff->screen, 0, &mode, &pPix);
	WriteToClient(client, sz_xXDGASetModeReply, (char*)&rep);
	return Success;
d300 2
a301 2
    if(Success != DGASetMode(stuff->screen, stuff->mode, &mode, &pPix))
	return BadValue;
d303 3
a305 3
    if(!owner) {
	if(DGACallbackRefCount++ == 0)
	   AddCallback (&ClientStateCallback, DGAClientStateChange, NULL);
d310 5
a314 5
    if(pPix) {
	if(AddResource(stuff->pid, RT_PIXMAP, (pointer)(pPix))) {
	    pPix->drawable.id = (int)stuff->pid;
	    rep.flags = DGA_PIXMAP_AVAILABLE;
	}
d348 2
a349 2
    WriteToClient(client, sz_xXDGASetModeReply, (char*)&rep);
    WriteToClient(client, sz_xXDGAModeInfo, (char*)(&info));
d363 1
a363 1
    if(DGA_GETCLIENT(stuff->screen) != client)
d378 1
d384 1
a384 1
    if(DGA_GETCLIENT(stuff->screen) != client)
d389 2
a390 2
    rc = dixLookupResourceByType((pointer *)&cmap, stuff->cmap, RT_COLORMAP,
				 client, DixInstallAccess);
a396 1

d405 1
a405 1
    if(DGA_GETCLIENT(stuff->screen) != client)
d410 2
a411 2
    if(DGA_GETCLIENT(stuff->screen) == client)
	DGASelectInput(stuff->screen, client, stuff->mask);
a415 1

d424 1
a424 1
    if(DGA_GETCLIENT(stuff->screen) != client)
d429 3
a431 3
    if(Success != DGAFillRect(stuff->screen, stuff->x, stuff->y,
			stuff->width, stuff->height, stuff->color))
	return BadMatch;
d444 1
a444 1
    if(DGA_GETCLIENT(stuff->screen) != client)
d449 4
a452 3
    if(Success != DGABlitRect(stuff->screen, stuff->srcx, stuff->srcy,
		stuff->width, stuff->height, stuff->dstx, stuff->dsty))
	return BadMatch;
a456 1

d465 1
a465 1
    if(DGA_GETCLIENT(stuff->screen) != client)
d470 4
a473 3
    if(Success != DGABlitTransRect(stuff->screen, stuff->srcx, stuff->srcy,
	stuff->width, stuff->height, stuff->dstx, stuff->dsty, stuff->key))
	return BadMatch;
a477 1

d487 1
a487 1
    if(DGA_GETCLIENT(stuff->screen) != client)
d497 1
a497 1
    WriteToClient(client, sizeof(xXDGAGetViewportStatusReply), (char *)&rep);
d510 1
a510 1
    if(DGA_GETCLIENT(stuff->screen) != client)
d520 1
a520 1
    WriteToClient(client, sizeof(xXDGASyncReply), (char *)&rep);
d533 5
a537 5
	pPriv = malloc(sizeof(DGAPrivRec));
	/* XXX Need to look into freeing this */
	if (!pPriv)
	    return BadAlloc;
	DGA_SETPRIV(client, pPriv);
d555 1
a555 1
    if(DGA_GETCLIENT(stuff->screen) != client)
d566 2
a567 2
    if(!DGAChangePixmapMode(stuff->screen, &x, &y, stuff->flags))
	return BadMatch;
d571 1
a571 1
    WriteToClient(client, sizeof(xXDGAChangePixmapModeReply), (char *)&rep);
a575 1

d585 1
a585 1
    if(DGA_GETCLIENT(stuff->screen) != client)
d590 2
a591 2
    if(!stuff->mode)
	return BadValue;
d594 3
a596 3
				stuff->mode, stuff->alloc);
    if(result != Success)
	return result;
a608 2


d619 1
a619 1
	return BadValue;
d626 2
a627 2
    if(!DGAAvailable(stuff->screen))
	return DGAErrorBase + XF86DGANoDirectVideoMode;
d629 2
a630 2
    if(!(num = DGAGetOldDGAMode(stuff->screen)))
	return DGAErrorBase + XF86DGANoDirectVideoMode;
d635 4
a638 4
    if(!DGAOpenFramebuffer(stuff->screen, &name,
			(unsigned char**)(&rep.offset),
			(int*)(&rep.bank_size), &offset, &flags))
	return BadAlloc;
d644 1
a644 1
    WriteToClient(client, SIZEOF(xXF86DGAGetVideoLLReply), (char *)&rep);
d655 1
d659 1
a659 1
	return BadValue;
d663 1
a663 1
	return DGAErrorBase + XF86DGANoDirectVideoMode;
d671 12
a682 11
	if(!(num = DGAGetOldDGAMode(stuff->screen)))
	    return DGAErrorBase + XF86DGANoDirectVideoMode;
    } else
	num = 0;

    if(Success != DGASetMode(stuff->screen, num, &mode, &pix))
	return DGAErrorBase + XF86DGAScreenNotActive;

    DGASetInputMode (stuff->screen,
		     (stuff->enable & XF86DGADirectKeyb) != 0,
		     (stuff->enable & XF86DGADirectMouse) != 0);
d686 14
a699 12
	(XF86DGADirectGraphics | XF86DGADirectKeyb | XF86DGADirectMouse)) {
	if (!owner) {
	    if (DGACallbackRefCount++ == 0)
		AddCallback (&ClientStateCallback, DGAClientStateChange, NULL);
	}

	DGA_SETCLIENT(stuff->screen, client);
    } else {
	if (owner) {
	    if (--DGACallbackRefCount == 0)
		DeleteCallback(&ClientStateCallback, DGAClientStateChange, NULL);
	}
d701 1
a701 1
	DGA_SETCLIENT(stuff->screen, NULL);
d712 1
d717 1
a717 1
	return BadValue;
d725 1
a725 1
	return DGAErrorBase + XF86DGANoDirectVideoMode;
d727 2
a728 2
    if(!(num = DGAGetOldDGAMode(stuff->screen)))
	return DGAErrorBase + XF86DGANoDirectVideoMode;
d735 1
a735 1
    WriteToClient(client, SIZEOF(xXF86DGAGetViewPortSizeReply), (char *)&rep);
d745 1
a745 1
	return BadValue;
d753 1
a753 1
	return DGAErrorBase + XF86DGANoDirectVideoMode;
d756 1
a756 1
	return DGAErrorBase + XF86DGADirectNotActivated;
d759 2
a760 2
		!= Success)
	return DGAErrorBase + XF86DGADirectNotActivated;
d772 1
a772 1
	return BadValue;
d778 1
a778 1
    rep.vpage = 0;  /* silently fail */
d780 1
a780 1
    WriteToClient(client, SIZEOF(xXF86DGAGetVidPageReply), (char *)&rep);
a783 1

d790 1
a790 1
	return BadValue;
a798 1

d804 1
d808 1
a808 1
	return BadValue;
d816 1
a816 1
	return DGAErrorBase + XF86DGADirectNotActivated;
d818 2
a819 2
    rc = dixLookupResourceByType((pointer *)&pcmp, stuff->id, RT_COLORMAP,
				 client, DixInstallAccess);
d821 1
a821 1
	DGAInstallCmap(pcmp);
d823 2
a824 1
    } else {
d836 1
a836 1
	return BadValue;
d845 1
a845 1
	rep.flags = XF86DGADirectPresent;
d847 1
a847 1
    WriteToClient(client, SIZEOF(xXF86DGAQueryDirectVideoReply), (char *)&rep);
d858 1
a858 1
	return BadValue;
d866 1
a866 1
	return DGAErrorBase + XF86DGADirectNotActivated;
d873 1
a873 1
    WriteToClient(client, SIZEOF(xXF86DGAViewPortChangedReply), (char *)&rep);
d877 1
a877 1
#endif /* DGA_PROTOCOL_OLD_SUPPORT */
d880 1
a880 1
SProcXDGADispatch (ClientPtr client)
d882 1
a882 1
   return DGAErrorBase + XF86DGAClientNotLocal;
d922 1
a922 1
ProcXDGADispatch (ClientPtr client)
d927 1
a927 1
	return DGAErrorBase + XF86DGAClientNotLocal;
d931 1
a931 1
	fprintf (stderr, "    DGA %s\n", dgaMinor[stuff->data]);
d934 4
a937 4
    switch (stuff->data){
    /*
     * DGA2 Protocol
     */
d939 1
a939 1
	return ProcXDGAQueryVersion(client);
d941 1
a941 1
	return ProcXDGAQueryModes(client);
d943 1
a943 1
	return ProcXDGASetMode(client);
d945 1
a945 1
	return ProcXDGAOpenFramebuffer(client);
d947 1
a947 1
	return ProcXDGACloseFramebuffer(client);
d949 1
a949 1
	return ProcXDGASetViewport(client);
d951 1
a951 1
	return ProcXDGAInstallColormap(client);
d953 1
a953 1
	return ProcXDGASelectInput(client);
d955 1
a955 1
	return ProcXDGAFillRectangle(client);
d957 1
a957 1
	return ProcXDGACopyArea(client);
d959 1
a959 1
	return ProcXDGACopyTransparentArea(client);
d961 1
a961 1
	return ProcXDGAGetViewportStatus(client);
d963 1
a963 1
	return ProcXDGASync(client);
d965 1
a965 1
	return ProcXDGASetClientVersion(client);
d967 1
a967 1
	return ProcXDGAChangePixmapMode(client);
d969 4
a972 4
	return ProcXDGACreateColormap(client);
    /*
     * Old DGA Protocol
     */
d975 1
a975 1
	return ProcXF86DGAGetVideoLL(client);
d977 1
a977 1
	return ProcXF86DGADirectVideo(client);
d979 1
a979 1
	return ProcXF86DGAGetViewPortSize(client);
d981 1
a981 1
	return ProcXF86DGASetViewPort(client);
d983 1
a983 1
	return ProcXF86DGAGetVidPage(client);
d985 1
a985 1
	return ProcXF86DGASetVidPage(client);
d987 1
a987 1
	return ProcXF86DGAInstallColormap(client);
d989 1
a989 1
	return ProcXF86DGAQueryDirectVideo(client);
d991 2
a992 2
	return ProcXF86DGAViewPortChanged(client);
#endif /* DGA_PROTOCOL_OLD_SUPPORT */
d994 1
a994 1
	return BadRequest;
d1001 1
a1001 1
  XDGAEventBase = &DGAEventBase;
d1007 1
a1007 1
    ExtensionEntry* extEntry;
d1010 1
a1010 1
	return;
d1013 1
a1013 1
	return;
d1016 12
a1027 13
				XF86DGANumberEvents,
				XF86DGANumberErrors,
				ProcXDGADispatch,
				SProcXDGADispatch,
				XDGAResetProc,
				StandardMinorOpcode))) {
	int i;

	DGAReqCode = (unsigned char)extEntry->base;
	DGAErrorBase = extEntry->errorBase;
	DGAEventBase = extEntry->eventBase;
	for (i = KeyPress; i <= MotionNotify; i++)
	    SetCriticalEvent (DGAEventBase + i);
@


1.6
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@a27 1
#include "xf86dgaext.h"
a35 18
static DISPATCH_PROC(ProcXDGADispatch);
static DISPATCH_PROC(SProcXDGADispatch);
static DISPATCH_PROC(ProcXDGAQueryVersion);
static DISPATCH_PROC(ProcXDGAQueryModes);
static DISPATCH_PROC(ProcXDGASetMode);
static DISPATCH_PROC(ProcXDGAOpenFramebuffer);
static DISPATCH_PROC(ProcXDGACloseFramebuffer);
static DISPATCH_PROC(ProcXDGASetViewport);
static DISPATCH_PROC(ProcXDGAInstallColormap);
static DISPATCH_PROC(ProcXDGASelectInput);
static DISPATCH_PROC(ProcXDGAFillRectangle);
static DISPATCH_PROC(ProcXDGACopyArea);
static DISPATCH_PROC(ProcXDGACopyTransparentArea);
static DISPATCH_PROC(ProcXDGAGetViewportStatus);
static DISPATCH_PROC(ProcXDGASync);
static DISPATCH_PROC(ProcXDGASetClientVersion);
static DISPATCH_PROC(ProcXDGAChangePixmapMode);
static DISPATCH_PROC(ProcXDGACreateColormap);
a68 30
void
XFree86DGAExtensionInit(INITARGS)
{
    ExtensionEntry* extEntry;

    if (!dixRegisterPrivateKey(&DGAClientPrivateKeyRec, PRIVATE_CLIENT, 0))
	return;

    if (!dixRegisterPrivateKey(&DGAScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
	return;

    if ((extEntry = AddExtension(XF86DGANAME,
				XF86DGANumberEvents,
				XF86DGANumberErrors,
				ProcXDGADispatch,
				SProcXDGADispatch,
				XDGAResetProc,
				StandardMinorOpcode))) {
	int i;

	DGAReqCode = (unsigned char)extEntry->base;
	DGAErrorBase = extEntry->errorBase;
	DGAEventBase = extEntry->eventBase;
	for (i = KeyPress; i <= MotionNotify; i++)
	    SetCriticalEvent (DGAEventBase + i);
    }
}



a616 9
static DISPATCH_PROC(ProcXF86DGADirectVideo);
static DISPATCH_PROC(ProcXF86DGAGetVidPage);
static DISPATCH_PROC(ProcXF86DGAGetVideoLL);
static DISPATCH_PROC(ProcXF86DGAGetViewPortSize);
static DISPATCH_PROC(ProcXF86DGASetVidPage);
static DISPATCH_PROC(ProcXF86DGASetViewPort);
static DISPATCH_PROC(ProcXF86DGAInstallColormap);
static DISPATCH_PROC(ProcXF86DGAQueryDirectVideo);
static DISPATCH_PROC(ProcXF86DGAViewPortChanged);
d1007 28
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d151 1
a151 1
    if (stuff->screen > screenInfo.numScreens)
d185 1
a185 1
    if (stuff->screen > screenInfo.numScreens)
d207 1
a207 1
    if (stuff->screen > screenInfo.numScreens)
d326 1
a326 1
    if (stuff->screen > screenInfo.numScreens)
d415 1
a415 1
    if (stuff->screen > screenInfo.numScreens)
d435 1
a435 1
    if (stuff->screen > screenInfo.numScreens)
d457 1
a457 1
    if (stuff->screen > screenInfo.numScreens)
d477 1
a477 1
    if (stuff->screen > screenInfo.numScreens)
d497 1
a497 1
    if (stuff->screen > screenInfo.numScreens)
d518 1
a518 1
    if (stuff->screen > screenInfo.numScreens)
d540 1
a540 1
    if (stuff->screen > screenInfo.numScreens)
d563 1
a563 1
    if (stuff->screen > screenInfo.numScreens)
d608 1
a608 1
    if (stuff->screen > screenInfo.numScreens)
d639 1
a639 1
    if (stuff->screen > screenInfo.numScreens)
d686 1
a686 1
    if (stuff->screen > screenInfo.numScreens)
d725 1
a725 1
    if (stuff->screen > screenInfo.numScreens)
d779 1
a779 1
    if (stuff->screen > screenInfo.numScreens)
d807 1
a807 1
    if (stuff->screen > screenInfo.numScreens)
d834 1
a834 1
    if (stuff->screen > screenInfo.numScreens)
d853 1
a853 1
    if (stuff->screen > screenInfo.numScreens)
d871 1
a871 1
    if (stuff->screen > screenInfo.numScreens)
d898 1
a898 1
    if (stuff->screen > screenInfo.numScreens)
d920 1
a920 1
    if (stuff->screen > screenInfo.numScreens)
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a59 2
static ClientPtr DGAClients[MAXSCREENS];

d64 5
a68 2
static int DGAClientPrivateKeyIndex;
static DevPrivateKey DGAClientPrivateKey = &DGAClientPrivateKeyIndex;
d77 5
d93 6
a107 3
	for(i = 0; i < MAXSCREENS; i++)
	     DGAClients[i] = NULL;

d139 1
a139 1
    return (client->noClientException);
d176 1
a176 1
    return (client->noClientException);
d195 1
a195 1
    return (client->noClientException);
d220 1
a220 1
	return (client->noClientException);
d225 1
a225 1
	return (client->noClientException);
d228 1
a228 1
    if(!(mode = (XDGAModePtr)xalloc(num * sizeof(XDGAModeRec))))
d277 1
a277 1
    xfree(mode);
d279 1
a279 1
    return (client->noClientException);
d294 1
a294 1
	if(DGAClients[i] == pci->client) {
d306 1
a306 1
	DGAClients[i] = NULL;
d323 1
d328 1
d340 1
a340 2
    if(DGAClients[stuff->screen] &&
      (DGAClients[stuff->screen] != client))
d344 1
a344 1
	if(DGAClients[stuff->screen]) {
d348 1
a348 1
	DGAClients[stuff->screen] = NULL;
d352 1
a352 1
	return (client->noClientException);
d358 1
a358 1
    if(!DGAClients[stuff->screen]) {
d363 1
a363 1
    DGAClients[stuff->screen] = client;
d407 1
a407 1
    return (client->noClientException);
d418 1
a418 1
    if(DGAClients[stuff->screen] != client)
d425 1
a425 1
    return (client->noClientException);
d438 1
a438 1
    if(DGAClients[stuff->screen] != client)
d445 4
a448 8
    if (rc == Success) {
        DGAInstallCmap(cmap);
        return (client->noClientException);
    } else {
        return (rc == BadValue) ? BadColor : rc;
    }

    return (client->noClientException);
d460 1
a460 1
    if(DGAClients[stuff->screen] != client)
d465 1
a465 1
    if(DGAClients[stuff->screen] == client)
d468 1
a468 1
    return (client->noClientException);
d480 1
a480 1
    if(DGAClients[stuff->screen] != client)
d489 1
a489 1
    return (client->noClientException);
d500 1
a500 1
    if(DGAClients[stuff->screen] != client)
d509 1
a509 1
    return (client->noClientException);
d521 1
a521 1
    if(DGAClients[stuff->screen] != client)
d530 1
a530 1
    return (client->noClientException);
d543 1
a543 1
    if(DGAClients[stuff->screen] != client)
d554 1
a554 1
    return (client->noClientException);
d566 1
a566 1
    if(DGAClients[stuff->screen] != client)
d577 1
a577 1
    return (client->noClientException);
d589 1
a589 1
	pPriv = xalloc(sizeof(DGAPrivRec));
d598 1
a598 1
    return (client->noClientException);
d611 1
a611 1
    if(DGAClients[stuff->screen] != client)
d629 1
a629 1
    return (client->noClientException);
d642 1
a642 1
    if(DGAClients[stuff->screen] != client)
d655 1
a655 1
    return (client->noClientException);
d695 1
a695 1
	return (DGAErrorBase + XF86DGANoDirectVideoMode);
d698 1
a698 1
	return (DGAErrorBase + XF86DGANoDirectVideoMode);
d713 1
a713 1
    return (client->noClientException);
d722 1
a726 1

d732 3
a734 2
    if (DGAClients[stuff->screen] &&
        (DGAClients[stuff->screen] != client))
d739 1
a739 1
	    return (DGAErrorBase + XF86DGANoDirectVideoMode);
d744 1
a744 1
	return (DGAErrorBase + XF86DGAScreenNotActive);
d753 1
a753 1
	if (!DGAClients[stuff->screen]) {
d758 1
a758 1
	DGAClients[stuff->screen] = client;
d760 1
a760 1
	if (DGAClients[stuff->screen]) {
d765 1
a765 1
	DGAClients[stuff->screen] = NULL;
d768 1
a768 1
    return (client->noClientException);
d788 1
a788 1
	return (DGAErrorBase + XF86DGANoDirectVideoMode);
d791 1
a791 1
	return (DGAErrorBase + XF86DGANoDirectVideoMode);
d799 1
a799 1
    return (client->noClientException);
d810 1
a810 1
    if (DGAClients[stuff->screen] != client)
d816 1
a816 1
	return (DGAErrorBase + XF86DGANoDirectVideoMode);
d825 1
a825 1
    return (client->noClientException);
d844 1
a844 1
    return (client->noClientException);
d860 1
a860 1
    return (client->noClientException);
d874 1
a874 1
    if (DGAClients[stuff->screen] != client)
d880 1
a880 1
	return (DGAErrorBase + XF86DGADirectNotActivated);
d886 1
a886 1
        return (client->noClientException);
d888 1
a888 1
        return (rc == BadValue) ? BadColor : rc;
d911 1
a911 1
    return (client->noClientException);
d923 1
a923 1
    if (DGAClients[stuff->screen] != client)
d929 1
a929 1
	return (DGAErrorBase + XF86DGADirectNotActivated);
d937 1
a937 1
    return (client->noClientException);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a13 2
#define NEED_REPLIES
#define NEED_EVENTS
d25 1
a25 3
#define _XF86DGA_SERVER_
#include <X11/extensions/xf86dga.h>
#include <X11/extensions/xf86dgastr.h>
d29 1
d126 2
a127 2
    rep.majorVersion = XDGA_MAJOR_VERSION;
    rep.minorVersion = XDGA_MINOR_VERSION;
d161 1
a161 1
    rep.length = (nameSize + 3) >> 2;
d227 1
a227 1
	size += (strlen(mode[i].name) + 4) & ~3L;  /* plus NULL */
d230 1
a230 1
    rep.length = size >> 2;
d391 1
a391 1
    rep.length = (sz_xXDGAModeInfo + info.name_size) >> 2;
d422 1
d433 3
a435 2
    cmap = (ColormapPtr)LookupIDByType(stuff->cmap, RT_COLORMAP);
    if (cmap) {
d439 1
a439 2
        client->errorValue = stuff->cmap;
        return (BadColor);
d861 1
d875 3
a877 2
    pcmp = (ColormapPtr  )LookupIDByType(stuff->id, RT_COLORMAP);
    if (pcmp) {
d881 1
a881 2
        client->errorValue = stuff->id;
        return (BadColor);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d2 6
a7 4
   Copyright (c) 1999 - The XFree86 Project Inc.

   Written by Mark Vojkovich
*/
d38 2
d69 2
a70 1
static DevPrivateKey DGAClientPrivateKey = &DGAClientPrivateKey;
d148 1
a148 1
    if (!DGAAvailable(stuff->screen)) 
d156 1
a156 1
    if(!DGAOpenFramebuffer(stuff->screen, &deviceName, 
d158 1
a158 1
			(int*)&rep.size, (int*)&rep.offset, (int*)&rep.extra)) 
d182 1
a182 1
    if (!DGAAvailable(stuff->screen)) 
d266 1
a266 1
	
d277 1
a277 1
static void 
d294 1
a294 1
    if(client && 
d329 1
a329 1
    if (!DGAAvailable(stuff->screen)) 
d332 1
a332 1
    if(DGAClients[stuff->screen] && 
d346 1
a346 1
    } 
d366 1
a366 1
   
d434 1
a434 1
   
d460 1
a460 1
   
d480 1
a480 1
   
d500 1
a500 1
   
d521 1
a521 1
   
d614 1
a614 1
	
d645 2
a646 2
   
    result = DGACreateColormap(stuff->screen, client, stuff->id, 
d654 281
a989 7
    
    /* divert old protocol */
#if 1
    if( (stuff->data <= X_XF86DGAViewPortChanged) && 
	(stuff->data >= X_XF86DGAGetVideoLL)) 
	return ProcXF86DGADispatch(client);
#endif
d992 3
d1027 23
d1058 1
a1058 1
  XDGAEventBase = &DGAEventBase; 
@


1.1
log
@Initial revision
@
text
@d65 1
a65 2
static int DGAGeneration = 0;
static int DGAClientPrivateIndex;
d74 5
a78 1
#define DGAPRIV(c) ((c)->devPrivates[DGAClientPrivateIndex].ptr)
a102 17

    /*
     * Allocate a client private index to hold the client's version
     * information.
     */
    if (DGAGeneration != serverGeneration) {
	DGAClientPrivateIndex = AllocateClientPrivateIndex();
	/*
	 * Allocate 0 length, and use the private to hold a pointer to
	 * our DGAPrivRec.
	 */
	if (!AllocateClientPrivate(DGAClientPrivateIndex, 0)) {
	    ErrorF("XFree86DGAExtensionInit: AllocateClientPrivate failed\n");
	    return;
	}
	DGAGeneration = serverGeneration;
    }
d579 1
a579 1
    if ((pPriv = DGAPRIV(client)) == NULL) {
d584 1
a584 1
	DGAPRIV(client) = pPriv;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
