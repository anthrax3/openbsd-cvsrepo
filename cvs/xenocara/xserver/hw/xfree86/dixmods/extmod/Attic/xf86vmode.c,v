head	1.8;
access;
symbols
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2013.06.07.17.28.50;	author matthieu;	state dead;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.31;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.18.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.18.08;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@
/*

Copyright 1995  Kaleb S. KEITHLEY

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL Kaleb S. KEITHLEY BE LIABLE FOR ANY CLAIM, DAMAGES 
OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Kaleb S. KEITHLEY 
shall not be used in advertising or otherwise to promote the sale, use 
or other dealings in this Software without prior written authorization
from Kaleb S. KEITHLEY

*/
/* THIS IS NOT AN X CONSORTIUM STANDARD OR AN X PROJECT TEAM SPECIFICATION */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "scrnintstr.h"
#include "servermd.h"
#include <X11/extensions/xf86vmproto.h>
#include "swaprep.h"
#include "xf86.h"
#include "vidmodeproc.h"
#include "globals.h"
#include "protocol-versions.h"

#define DEFAULT_XF86VIDMODE_VERBOSITY	3

static int VidModeErrorBase;
static DevPrivateKeyRec VidModeClientPrivateKeyRec;

#define VidModeClientPrivateKey (&VidModeClientPrivateKeyRec)

/* This holds the client's version information */
typedef struct {
    int major;
    int minor;
} VidModePrivRec, *VidModePrivPtr;

#define VM_GETPRIV(c) ((VidModePrivPtr) \
    dixLookupPrivate(&(c)->devPrivates, VidModeClientPrivateKey))
#define VM_SETPRIV(c,p) \
    dixSetPrivate(&(c)->devPrivates, VidModeClientPrivateKey, p)

#if 0
static unsigned char XF86VidModeReqCode = 0;
#endif

/* The XF86VIDMODE_EVENTS code is far from complete */

#ifdef XF86VIDMODE_EVENTS
static int XF86VidModeEventBase = 0;

static void SXF86VidModeNotifyEvent(xXF86VidModeNotifyEvent * /* from */ , xXF86VidModeNotifyEvent *    /* to */
    );

static RESTYPE EventType;       /* resource type for event masks */

typedef struct _XF86VidModeEvent *XF86VidModeEventPtr;

typedef struct _XF86VidModeEvent {
    XF86VidModeEventPtr next;
    ClientPtr client;
    ScreenPtr screen;
    XID resource;
    CARD32 mask;
} XF86VidModeEventRec;

static int XF86VidModeFreeEvents();

typedef struct _XF86VidModeScreenPrivate {
    XF86VidModeEventPtr events;
    Bool hasWindow;
} XF86VidModeScreenPrivateRec, *XF86VidModeScreenPrivatePtr;

static DevPrivateKeyRec ScreenPrivateKeyRec;

#define ScreenPrivateKey (&ScreenPrivateKeyRec)

#define GetScreenPrivate(s) ((ScreenSaverScreenPrivatePtr) \
    dixLookupPrivate(&(s)->devPrivates, ScreenPrivateKey))
#define SetScreenPrivate(s,v) \
    dixSetPrivate(&(s)->devPrivates, ScreenPrivateKey, v)
#define SetupScreen(s)  ScreenSaverScreenPrivatePtr pPriv = GetScreenPrivate(s)

#define New(t)  (malloc(sizeof (t)))
#endif

#ifdef DEBUG
#define DEBUG_P(x) ErrorF(x"\n");
#else
#define DEBUG_P(x) /**/
#endif
    static int
ClientMajorVersion(ClientPtr client)
{
    VidModePrivPtr pPriv;

    pPriv = VM_GETPRIV(client);
    if (!pPriv)
        return 0;
    else
        return pPriv->major;
}

#ifdef XF86VIDMODE_EVENTS
static void
CheckScreenPrivate(pScreen)
ScreenPtr
 pScreen;
{
    SetupScreen(pScreen);

    if (!pPriv)
        return;
    if (!pPriv->events && !pPriv->hasWindow) {
        free(pPriv);
        SetScreenPrivate(pScreen, NULL);
    }
}

static XF86VidModeScreenPrivatePtr
MakeScreenPrivate(pScreen)
ScreenPtr
 pScreen;
{
    SetupScreen(pScreen);

    if (pPriv)
        return pPriv;
    pPriv = New(XF86VidModeScreenPrivateRec);
    if (!pPriv)
        return 0;
    pPriv->events = 0;
    pPriv->hasWindow = FALSE;
    SetScreenPrivate(pScreen, pPriv);
    return pPriv;
}

static unsigned long
getEventMask(ScreenPtr pScreen, ClientPtr client)
{
    SetupScreen(pScreen);
    XF86VidModeEventPtr pEv;

    if (!pPriv)
        return 0;
    for (pEv = pPriv->events; pEv; pEv = pEv->next)
        if (pEv->client == client)
            return pEv->mask;
    return 0;
}

static Bool
setEventMask(ScreenPtr pScreen, ClientPtr client, unsigned long mask)
{
    SetupScreen(pScreen);
    XF86VidModeEventPtr pEv, *pPrev;

    if (getEventMask(pScreen, client) == mask)
        return TRUE;
    if (!pPriv) {
        pPriv = MakeScreenPrivate(pScreen);
        if (!pPriv)
            return FALSE;
    }
    for (pPrev = &pPriv->events; pEv = *pPrev; pPrev = &pEv->next)
        if (pEv->client == client)
            break;
    if (mask == 0) {
        *pPrev = pEv->next;
        free(pEv);
        CheckScreenPrivate(pScreen);
    }
    else {
        if (!pEv) {
            pEv = New(ScreenSaverEventRec);
            if (!pEv) {
                CheckScreenPrivate(pScreen);
                return FALSE;
            }
            *pPrev = pEv;
            pEv->next = NULL;
            pEv->client = client;
            pEv->screen = pScreen;
            pEv->resource = FakeClientID(client->index);
        }
        pEv->mask = mask;
    }
    return TRUE;
}

static int
XF86VidModeFreeEvents(pointer value, XID id)
{
    XF86VidModeEventPtr pOld = (XF86VidModeEventPtr) value;
    ScreenPtr pScreen = pOld->screen;

    SetupScreen(pScreen);
    XF86VidModeEventPtr pEv, *pPrev;

    if (!pPriv)
        return TRUE;
    for (pPrev = &pPriv->events; pEv = *pPrev; pPrev = &pEv->next)
        if (pEv == pOld)
            break;
    if (!pEv)
        return TRUE;
    *pPrev = pEv->next;
    free(pEv);
    CheckScreenPrivate(pScreen);
    return TRUE;
}

static void
SendXF86VidModeNotify(ScreenPtr pScreen, int state, Bool forced)
{
    XF86VidModeScreenPrivatePtr pPriv;
    XF86VidModeEventPtr pEv;
    unsigned long mask;
    xXF86VidModeNotifyEvent ev;
    int kind;

    UpdateCurrentTimeIf();
    mask = XF86VidModeNotifyMask;
    pScreen = screenInfo.screens[pScreen->myNum];
    pPriv = GetScreenPrivate(pScreen);
    if (!pPriv)
        return;
    kind = XF86VidModeModeChange;
    for (pEv = pPriv->events; pEv; pEv = pEv->next) {
        if (!(pEv->mask & mask))
            continue;
        ev.type = XF86VidModeNotify + XF86VidModeEventBase;
        ev.state = state;
        ev.timestamp = currentTime.milliseconds;
        ev.root = pScreen->root->drawable.id;
        ev.kind = kind;
        ev.forced = forced;
        WriteEventsToClient(pEv->client, 1, (xEvent *) &ev);
}} static void

SXF86VidModeNotifyEvent(xXF86VidModeNotifyEvent * from,
                        xXF86VidModeNotifyEvent * to)
{
    to->type = from->type;
    to->state = from->state;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->timestamp, to->timestamp);
    cpswapl(from->root, to->root);
    to->kind = from->kind;
    to->forced = from->forced;
}
#endif

static int
ProcXF86VidModeQueryVersion(ClientPtr client)
{
    xXF86VidModeQueryVersionReply rep;

    DEBUG_P("XF86VidModeQueryVersion");

    REQUEST_SIZE_MATCH(xXF86VidModeQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_XF86VIDMODE_MAJOR_VERSION;
    rep.minorVersion = SERVER_XF86VIDMODE_MINOR_VERSION;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.majorVersion);
        swaps(&rep.minorVersion);
    }
    WriteToClient(client, sizeof(xXF86VidModeQueryVersionReply), (char *) &rep);
    return Success;
}

static int
ProcXF86VidModeGetModeLine(ClientPtr client)
{
    REQUEST(xXF86VidModeGetModeLineReq);
    xXF86VidModeGetModeLineReply rep;
    xXF86OldVidModeGetModeLineReply oldrep;
    pointer mode;
    int dotClock;
    int ver;

    DEBUG_P("XF86VidModeGetModeline");

    ver = ClientMajorVersion(client);
    REQUEST_SIZE_MATCH(xXF86VidModeGetModeLineReq);
    rep.type = X_Reply;
    if (ver < 2) {
        rep.length = bytes_to_int32(SIZEOF(xXF86OldVidModeGetModeLineReply) -
                                    SIZEOF(xGenericReply));
    }
    else {
        rep.length = bytes_to_int32(SIZEOF(xXF86VidModeGetModeLineReply) -
                                    SIZEOF(xGenericReply));
    }
    rep.sequenceNumber = client->sequence;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (!VidModeGetCurrentModeline(stuff->screen, &mode, &dotClock))
        return BadValue;

    rep.dotclock = dotClock;
    rep.hdisplay = VidModeGetModeValue(mode, VIDMODE_H_DISPLAY);
    rep.hsyncstart = VidModeGetModeValue(mode, VIDMODE_H_SYNCSTART);
    rep.hsyncend = VidModeGetModeValue(mode, VIDMODE_H_SYNCEND);
    rep.htotal = VidModeGetModeValue(mode, VIDMODE_H_TOTAL);
    rep.hskew = VidModeGetModeValue(mode, VIDMODE_H_SKEW);
    rep.vdisplay = VidModeGetModeValue(mode, VIDMODE_V_DISPLAY);
    rep.vsyncstart = VidModeGetModeValue(mode, VIDMODE_V_SYNCSTART);
    rep.vsyncend = VidModeGetModeValue(mode, VIDMODE_V_SYNCEND);
    rep.vtotal = VidModeGetModeValue(mode, VIDMODE_V_TOTAL);
    rep.flags = VidModeGetModeValue(mode, VIDMODE_FLAGS);

    if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY) {
        ErrorF("GetModeLine - scrn: %d clock: %ld\n",
               stuff->screen, (unsigned long) rep.dotclock);
        ErrorF("GetModeLine - hdsp: %d hbeg: %d hend: %d httl: %d\n",
               rep.hdisplay, rep.hsyncstart, rep.hsyncend, rep.htotal);
        ErrorF("              vdsp: %d vbeg: %d vend: %d vttl: %d flags: %ld\n",
               rep.vdisplay, rep.vsyncstart, rep.vsyncend,
               rep.vtotal, (unsigned long) rep.flags);
    }

    /*
     * Older servers sometimes had server privates that the VidMode 
     * extention made available. So to be compatiable pretend that
     * there are no server privates to pass to the client
     */
    rep.privsize = 0;

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.dotclock);
        swaps(&rep.hdisplay);
        swaps(&rep.hsyncstart);
        swaps(&rep.hsyncend);
        swaps(&rep.htotal);
        swaps(&rep.hskew);
        swaps(&rep.vdisplay);
        swaps(&rep.vsyncstart);
        swaps(&rep.vsyncend);
        swaps(&rep.vtotal);
        swapl(&rep.flags);
        swapl(&rep.privsize);
    }
    if (ver < 2) {
        oldrep.type = rep.type;
        oldrep.sequenceNumber = rep.sequenceNumber;
        oldrep.length = rep.length;
        oldrep.dotclock = rep.dotclock;
        oldrep.hdisplay = rep.hdisplay;
        oldrep.hsyncstart = rep.hsyncstart;
        oldrep.hsyncend = rep.hsyncend;
        oldrep.htotal = rep.htotal;
        oldrep.vdisplay = rep.vdisplay;
        oldrep.vsyncstart = rep.vsyncstart;
        oldrep.vsyncend = rep.vsyncend;
        oldrep.vtotal = rep.vtotal;
        oldrep.flags = rep.flags;
        oldrep.privsize = rep.privsize;
        WriteToClient(client, sizeof(xXF86OldVidModeGetModeLineReply),
                      (char *) &oldrep);
    }
    else {
        WriteToClient(client, sizeof(xXF86VidModeGetModeLineReply),
                      (char *) &rep);
    }
    return Success;
}

static int
ProcXF86VidModeGetAllModeLines(ClientPtr client)
{
    REQUEST(xXF86VidModeGetAllModeLinesReq);
    xXF86VidModeGetAllModeLinesReply rep;
    xXF86VidModeModeInfo mdinf;
    xXF86OldVidModeModeInfo oldmdinf;
    pointer mode;
    int modecount, dotClock;
    int ver;

    DEBUG_P("XF86VidModeGetAllModelines");

    REQUEST_SIZE_MATCH(xXF86VidModeGetAllModeLinesReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    ver = ClientMajorVersion(client);

    modecount = VidModeGetNumOfModes(stuff->screen);
    if (modecount < 1)
        return VidModeErrorBase + XF86VidModeExtensionDisabled;

    if (!VidModeGetFirstModeline(stuff->screen, &mode, &dotClock))
        return BadValue;

    rep.type = X_Reply;
    rep.length = SIZEOF(xXF86VidModeGetAllModeLinesReply) -
        SIZEOF(xGenericReply);
    if (ver < 2)
        rep.length += modecount * sizeof(xXF86OldVidModeModeInfo);
    else
        rep.length += modecount * sizeof(xXF86VidModeModeInfo);
    rep.length >>= 2;
    rep.sequenceNumber = client->sequence;
    rep.modecount = modecount;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.modecount);
    }
    WriteToClient(client, sizeof(xXF86VidModeGetAllModeLinesReply),
                  (char *) &rep);

    do {
        mdinf.dotclock = dotClock;
        mdinf.hdisplay = VidModeGetModeValue(mode, VIDMODE_H_DISPLAY);
        mdinf.hsyncstart = VidModeGetModeValue(mode, VIDMODE_H_SYNCSTART);
        mdinf.hsyncend = VidModeGetModeValue(mode, VIDMODE_H_SYNCEND);
        mdinf.htotal = VidModeGetModeValue(mode, VIDMODE_H_TOTAL);
        mdinf.hskew = VidModeGetModeValue(mode, VIDMODE_H_SKEW);
        mdinf.vdisplay = VidModeGetModeValue(mode, VIDMODE_V_DISPLAY);
        mdinf.vsyncstart = VidModeGetModeValue(mode, VIDMODE_V_SYNCSTART);
        mdinf.vsyncend = VidModeGetModeValue(mode, VIDMODE_V_SYNCEND);
        mdinf.vtotal = VidModeGetModeValue(mode, VIDMODE_V_TOTAL);
        mdinf.flags = VidModeGetModeValue(mode, VIDMODE_FLAGS);
        mdinf.privsize = 0;
        if (client->swapped) {
            swapl(&mdinf.dotclock);
            swaps(&mdinf.hdisplay);
            swaps(&mdinf.hsyncstart);
            swaps(&mdinf.hsyncend);
            swaps(&mdinf.htotal);
            swapl(&mdinf.hskew);
            swaps(&mdinf.vdisplay);
            swaps(&mdinf.vsyncstart);
            swaps(&mdinf.vsyncend);
            swaps(&mdinf.vtotal);
            swapl(&mdinf.flags);
            swapl(&mdinf.privsize);
        }
        if (ver < 2) {
            oldmdinf.dotclock = mdinf.dotclock;
            oldmdinf.hdisplay = mdinf.hdisplay;
            oldmdinf.hsyncstart = mdinf.hsyncstart;
            oldmdinf.hsyncend = mdinf.hsyncend;
            oldmdinf.htotal = mdinf.htotal;
            oldmdinf.vdisplay = mdinf.vdisplay;
            oldmdinf.vsyncstart = mdinf.vsyncstart;
            oldmdinf.vsyncend = mdinf.vsyncend;
            oldmdinf.vtotal = mdinf.vtotal;
            oldmdinf.flags = mdinf.flags;
            oldmdinf.privsize = mdinf.privsize;
            WriteToClient(client, sizeof(xXF86OldVidModeModeInfo),
                          (char *) &oldmdinf);
        }
        else {
            WriteToClient(client, sizeof(xXF86VidModeModeInfo),
                          (char *) &mdinf);
        }

    } while (VidModeGetNextModeline(stuff->screen, &mode, &dotClock));

    return Success;
}

#define MODEMATCH(mode,stuff)	  \
     (VidModeGetModeValue(mode, VIDMODE_H_DISPLAY)  == stuff->hdisplay \
     && VidModeGetModeValue(mode, VIDMODE_H_SYNCSTART)  == stuff->hsyncstart \
     && VidModeGetModeValue(mode, VIDMODE_H_SYNCEND)  == stuff->hsyncend \
     && VidModeGetModeValue(mode, VIDMODE_H_TOTAL)  == stuff->htotal \
     && VidModeGetModeValue(mode, VIDMODE_V_DISPLAY)  == stuff->vdisplay \
     && VidModeGetModeValue(mode, VIDMODE_V_SYNCSTART)  == stuff->vsyncstart \
     && VidModeGetModeValue(mode, VIDMODE_V_SYNCEND)  == stuff->vsyncend \
     && VidModeGetModeValue(mode, VIDMODE_V_TOTAL)  == stuff->vtotal \
     && VidModeGetModeValue(mode, VIDMODE_FLAGS)  == stuff->flags )

static int
ProcXF86VidModeAddModeLine(ClientPtr client)
{
    REQUEST(xXF86VidModeAddModeLineReq);
    xXF86OldVidModeAddModeLineReq *oldstuff =
        (xXF86OldVidModeAddModeLineReq *) client->requestBuffer;
    xXF86VidModeAddModeLineReq newstuff;
    pointer mode;
    int len;
    int dotClock;
    int ver;

    DEBUG_P("XF86VidModeAddModeline");

    ver = ClientMajorVersion(client);
    if (ver < 2) {
        /* convert from old format */
        stuff = &newstuff;
        stuff->length = oldstuff->length;
        stuff->screen = oldstuff->screen;
        stuff->dotclock = oldstuff->dotclock;
        stuff->hdisplay = oldstuff->hdisplay;
        stuff->hsyncstart = oldstuff->hsyncstart;
        stuff->hsyncend = oldstuff->hsyncend;
        stuff->htotal = oldstuff->htotal;
        stuff->hskew = 0;
        stuff->vdisplay = oldstuff->vdisplay;
        stuff->vsyncstart = oldstuff->vsyncstart;
        stuff->vsyncend = oldstuff->vsyncend;
        stuff->vtotal = oldstuff->vtotal;
        stuff->flags = oldstuff->flags;
        stuff->privsize = oldstuff->privsize;
        stuff->after_dotclock = oldstuff->after_dotclock;
        stuff->after_hdisplay = oldstuff->after_hdisplay;
        stuff->after_hsyncstart = oldstuff->after_hsyncstart;
        stuff->after_hsyncend = oldstuff->after_hsyncend;
        stuff->after_htotal = oldstuff->after_htotal;
        stuff->after_hskew = 0;
        stuff->after_vdisplay = oldstuff->after_vdisplay;
        stuff->after_vsyncstart = oldstuff->after_vsyncstart;
        stuff->after_vsyncend = oldstuff->after_vsyncend;
        stuff->after_vtotal = oldstuff->after_vtotal;
        stuff->after_flags = oldstuff->after_flags;
    }
    if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY) {
        ErrorF("AddModeLine - scrn: %d clock: %ld\n",
               (int) stuff->screen, (unsigned long) stuff->dotclock);
        ErrorF("AddModeLine - hdsp: %d hbeg: %d hend: %d httl: %d\n",
               stuff->hdisplay, stuff->hsyncstart,
               stuff->hsyncend, stuff->htotal);
        ErrorF("              vdsp: %d vbeg: %d vend: %d vttl: %d flags: %ld\n",
               stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend,
               stuff->vtotal, (unsigned long) stuff->flags);
        ErrorF("      after - scrn: %d clock: %ld\n",
               (int) stuff->screen, (unsigned long) stuff->after_dotclock);
        ErrorF("              hdsp: %d hbeg: %d hend: %d httl: %d\n",
               stuff->after_hdisplay, stuff->after_hsyncstart,
               stuff->after_hsyncend, stuff->after_htotal);
        ErrorF("              vdsp: %d vbeg: %d vend: %d vttl: %d flags: %ld\n",
               stuff->after_vdisplay, stuff->after_vsyncstart,
               stuff->after_vsyncend, stuff->after_vtotal,
               (unsigned long) stuff->after_flags);
    }

    if (ver < 2) {
        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeAddModeLineReq);
        len =
            client->req_len -
            bytes_to_int32(sizeof(xXF86OldVidModeAddModeLineReq));
    }
    else {
        REQUEST_AT_LEAST_SIZE(xXF86VidModeAddModeLineReq);
        len =
            client->req_len -
            bytes_to_int32(sizeof(xXF86VidModeAddModeLineReq));
    }
    if (len != stuff->privsize)
        return BadLength;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (stuff->hsyncstart < stuff->hdisplay ||
        stuff->hsyncend < stuff->hsyncstart ||
        stuff->htotal < stuff->hsyncend ||
        stuff->vsyncstart < stuff->vdisplay ||
        stuff->vsyncend < stuff->vsyncstart || stuff->vtotal < stuff->vsyncend)
        return BadValue;

    if (stuff->after_hsyncstart < stuff->after_hdisplay ||
        stuff->after_hsyncend < stuff->after_hsyncstart ||
        stuff->after_htotal < stuff->after_hsyncend ||
        stuff->after_vsyncstart < stuff->after_vdisplay ||
        stuff->after_vsyncend < stuff->after_vsyncstart ||
        stuff->after_vtotal < stuff->after_vsyncend)
        return BadValue;

    if (stuff->after_htotal != 0 || stuff->after_vtotal != 0) {
        Bool found = FALSE;

        if (VidModeGetFirstModeline(stuff->screen, &mode, &dotClock)) {
            do {
                if ((VidModeGetDotClock(stuff->screen, stuff->dotclock)
                     == dotClock) && MODEMATCH(mode, stuff)) {
                    found = TRUE;
                    break;
                }
            } while (VidModeGetNextModeline(stuff->screen, &mode, &dotClock));
        }
        if (!found)
            return BadValue;
    }

    mode = VidModeCreateMode();
    if (mode == NULL)
        return BadValue;

    VidModeSetModeValue(mode, VIDMODE_CLOCK, stuff->dotclock);
    VidModeSetModeValue(mode, VIDMODE_H_DISPLAY, stuff->hdisplay);
    VidModeSetModeValue(mode, VIDMODE_H_SYNCSTART, stuff->hsyncstart);
    VidModeSetModeValue(mode, VIDMODE_H_SYNCEND, stuff->hsyncend);
    VidModeSetModeValue(mode, VIDMODE_H_TOTAL, stuff->htotal);
    VidModeSetModeValue(mode, VIDMODE_H_SKEW, stuff->hskew);
    VidModeSetModeValue(mode, VIDMODE_V_DISPLAY, stuff->vdisplay);
    VidModeSetModeValue(mode, VIDMODE_V_SYNCSTART, stuff->vsyncstart);
    VidModeSetModeValue(mode, VIDMODE_V_SYNCEND, stuff->vsyncend);
    VidModeSetModeValue(mode, VIDMODE_V_TOTAL, stuff->vtotal);
    VidModeSetModeValue(mode, VIDMODE_FLAGS, stuff->flags);

    if (stuff->privsize)
        ErrorF("AddModeLine - Privates in request have been ignored\n");

    /* Check that the mode is consistent with the monitor specs */
    switch (VidModeCheckModeForMonitor(stuff->screen, mode)) {
    case MODE_OK:
        break;
    case MODE_HSYNC:
    case MODE_H_ILLEGAL:
        free(mode);
        return VidModeErrorBase + XF86VidModeBadHTimings;
    case MODE_VSYNC:
    case MODE_V_ILLEGAL:
        free(mode);
        return VidModeErrorBase + XF86VidModeBadVTimings;
    default:
        free(mode);
        return VidModeErrorBase + XF86VidModeModeUnsuitable;
    }

    /* Check that the driver is happy with the mode */
    if (VidModeCheckModeForDriver(stuff->screen, mode) != MODE_OK) {
        free(mode);
        return VidModeErrorBase + XF86VidModeModeUnsuitable;
    }

    VidModeSetCrtcForMode(stuff->screen, mode);

    VidModeAddModeline(stuff->screen, mode);

    if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY)
        ErrorF("AddModeLine - Succeeded\n");
    return Success;
}

static int
ProcXF86VidModeDeleteModeLine(ClientPtr client)
{
    REQUEST(xXF86VidModeDeleteModeLineReq);
    xXF86OldVidModeDeleteModeLineReq *oldstuff =
        (xXF86OldVidModeDeleteModeLineReq *) client->requestBuffer;
    xXF86VidModeDeleteModeLineReq newstuff;
    pointer mode;
    int len, dotClock;
    int ver;

    DEBUG_P("XF86VidModeDeleteModeline");

    ver = ClientMajorVersion(client);
    if (ver < 2) {
        /* convert from old format */
        stuff = &newstuff;
        stuff->length = oldstuff->length;
        stuff->screen = oldstuff->screen;
        stuff->dotclock = oldstuff->dotclock;
        stuff->hdisplay = oldstuff->hdisplay;
        stuff->hsyncstart = oldstuff->hsyncstart;
        stuff->hsyncend = oldstuff->hsyncend;
        stuff->htotal = oldstuff->htotal;
        stuff->hskew = 0;
        stuff->vdisplay = oldstuff->vdisplay;
        stuff->vsyncstart = oldstuff->vsyncstart;
        stuff->vsyncend = oldstuff->vsyncend;
        stuff->vtotal = oldstuff->vtotal;
        stuff->flags = oldstuff->flags;
        stuff->privsize = oldstuff->privsize;
    }
    if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY) {
        ErrorF("DeleteModeLine - scrn: %d clock: %ld\n",
               (int) stuff->screen, (unsigned long) stuff->dotclock);
        ErrorF("                 hdsp: %d hbeg: %d hend: %d httl: %d\n",
               stuff->hdisplay, stuff->hsyncstart,
               stuff->hsyncend, stuff->htotal);
        ErrorF
            ("                 vdsp: %d vbeg: %d vend: %d vttl: %d flags: %ld\n",
             stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend, stuff->vtotal,
             (unsigned long) stuff->flags);
    }

    if (ver < 2) {
        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeDeleteModeLineReq);
        len =
            client->req_len -
            bytes_to_int32(sizeof(xXF86OldVidModeDeleteModeLineReq));
    }
    else {
        REQUEST_AT_LEAST_SIZE(xXF86VidModeDeleteModeLineReq);
        len =
            client->req_len -
            bytes_to_int32(sizeof(xXF86VidModeDeleteModeLineReq));
    }
    if (len != stuff->privsize) {
        if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY) {
            ErrorF("req_len = %ld, sizeof(Req) = %d, privsize = %ld, "
                   "len = %d, length = %d\n",
                   (unsigned long) client->req_len,
                   (int) sizeof(xXF86VidModeDeleteModeLineReq) >> 2,
                   (unsigned long) stuff->privsize, len, stuff->length);
        }
        return BadLength;
    }

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (!VidModeGetCurrentModeline(stuff->screen, &mode, &dotClock))
        return BadValue;

    if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY) {
        ErrorF("Checking against clock: %d (%d)\n",
               VidModeGetModeValue(mode, VIDMODE_CLOCK), dotClock);
        ErrorF("                 hdsp: %d hbeg: %d hend: %d httl: %d\n",
               VidModeGetModeValue(mode, VIDMODE_H_DISPLAY),
               VidModeGetModeValue(mode, VIDMODE_H_SYNCSTART),
               VidModeGetModeValue(mode, VIDMODE_H_SYNCEND),
               VidModeGetModeValue(mode, VIDMODE_H_TOTAL));
        ErrorF
            ("                 vdsp: %d vbeg: %d vend: %d vttl: %d flags: %d\n",
             VidModeGetModeValue(mode, VIDMODE_V_DISPLAY),
             VidModeGetModeValue(mode, VIDMODE_V_SYNCSTART),
             VidModeGetModeValue(mode, VIDMODE_V_SYNCEND),
             VidModeGetModeValue(mode, VIDMODE_V_TOTAL),
             VidModeGetModeValue(mode, VIDMODE_FLAGS));
    }
    if ((VidModeGetDotClock(stuff->screen, stuff->dotclock) == dotClock) &&
        MODEMATCH(mode, stuff))
        return BadValue;

    if (!VidModeGetFirstModeline(stuff->screen, &mode, &dotClock))
        return BadValue;

    do {
        if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY) {
            ErrorF("Checking against clock: %d (%d)\n",
                   VidModeGetModeValue(mode, VIDMODE_CLOCK), dotClock);
            ErrorF("                 hdsp: %d hbeg: %d hend: %d httl: %d\n",
                   VidModeGetModeValue(mode, VIDMODE_H_DISPLAY),
                   VidModeGetModeValue(mode, VIDMODE_H_SYNCSTART),
                   VidModeGetModeValue(mode, VIDMODE_H_SYNCEND),
                   VidModeGetModeValue(mode, VIDMODE_H_TOTAL));
            ErrorF
                ("                 vdsp: %d vbeg: %d vend: %d vttl: %d flags: %d\n",
                 VidModeGetModeValue(mode, VIDMODE_V_DISPLAY),
                 VidModeGetModeValue(mode, VIDMODE_V_SYNCSTART),
                 VidModeGetModeValue(mode, VIDMODE_V_SYNCEND),
                 VidModeGetModeValue(mode, VIDMODE_V_TOTAL),
                 VidModeGetModeValue(mode, VIDMODE_FLAGS));
        }
        if ((VidModeGetDotClock(stuff->screen, stuff->dotclock) == dotClock) &&
            MODEMATCH(mode, stuff)) {
            VidModeDeleteModeline(stuff->screen, mode);
            if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY)
                ErrorF("DeleteModeLine - Succeeded\n");
            return Success;
        }
    } while (VidModeGetNextModeline(stuff->screen, &mode, &dotClock));

    return BadValue;
}

static int
ProcXF86VidModeModModeLine(ClientPtr client)
{
    REQUEST(xXF86VidModeModModeLineReq);
    xXF86OldVidModeModModeLineReq *oldstuff =
        (xXF86OldVidModeModModeLineReq *) client->requestBuffer;
    xXF86VidModeModModeLineReq newstuff;
    pointer mode, modetmp;
    int len, dotClock;
    int ver;

    DEBUG_P("XF86VidModeModModeline");

    ver = ClientMajorVersion(client);
    if (ver < 2) {
        /* convert from old format */
        stuff = &newstuff;
        stuff->length = oldstuff->length;
        stuff->screen = oldstuff->screen;
        stuff->hdisplay = oldstuff->hdisplay;
        stuff->hsyncstart = oldstuff->hsyncstart;
        stuff->hsyncend = oldstuff->hsyncend;
        stuff->htotal = oldstuff->htotal;
        stuff->hskew = 0;
        stuff->vdisplay = oldstuff->vdisplay;
        stuff->vsyncstart = oldstuff->vsyncstart;
        stuff->vsyncend = oldstuff->vsyncend;
        stuff->vtotal = oldstuff->vtotal;
        stuff->flags = oldstuff->flags;
        stuff->privsize = oldstuff->privsize;
    }
    if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY) {
        ErrorF("ModModeLine - scrn: %d hdsp: %d hbeg: %d hend: %d httl: %d\n",
               (int) stuff->screen, stuff->hdisplay, stuff->hsyncstart,
               stuff->hsyncend, stuff->htotal);
        ErrorF("              vdsp: %d vbeg: %d vend: %d vttl: %d flags: %ld\n",
               stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend,
               stuff->vtotal, (unsigned long) stuff->flags);
    }

    if (ver < 2) {
        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeModModeLineReq);
        len =
            client->req_len -
            bytes_to_int32(sizeof(xXF86OldVidModeModModeLineReq));
    }
    else {
        REQUEST_AT_LEAST_SIZE(xXF86VidModeModModeLineReq);
        len =
            client->req_len -
            bytes_to_int32(sizeof(xXF86VidModeModModeLineReq));
    }
    if (len != stuff->privsize)
        return BadLength;

    if (stuff->hsyncstart < stuff->hdisplay ||
        stuff->hsyncend < stuff->hsyncstart ||
        stuff->htotal < stuff->hsyncend ||
        stuff->vsyncstart < stuff->vdisplay ||
        stuff->vsyncend < stuff->vsyncstart || stuff->vtotal < stuff->vsyncend)
        return BadValue;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (!VidModeGetCurrentModeline(stuff->screen, &mode, &dotClock))
        return BadValue;

    modetmp = VidModeCreateMode();
    VidModeCopyMode(mode, modetmp);

    VidModeSetModeValue(modetmp, VIDMODE_H_DISPLAY, stuff->hdisplay);
    VidModeSetModeValue(modetmp, VIDMODE_H_SYNCSTART, stuff->hsyncstart);
    VidModeSetModeValue(modetmp, VIDMODE_H_SYNCEND, stuff->hsyncend);
    VidModeSetModeValue(modetmp, VIDMODE_H_TOTAL, stuff->htotal);
    VidModeSetModeValue(modetmp, VIDMODE_H_SKEW, stuff->hskew);
    VidModeSetModeValue(modetmp, VIDMODE_V_DISPLAY, stuff->vdisplay);
    VidModeSetModeValue(modetmp, VIDMODE_V_SYNCSTART, stuff->vsyncstart);
    VidModeSetModeValue(modetmp, VIDMODE_V_SYNCEND, stuff->vsyncend);
    VidModeSetModeValue(modetmp, VIDMODE_V_TOTAL, stuff->vtotal);
    VidModeSetModeValue(modetmp, VIDMODE_FLAGS, stuff->flags);

    if (stuff->privsize)
        ErrorF("ModModeLine - Privates in request have been ignored\n");

    /* Check that the mode is consistent with the monitor specs */
    switch (VidModeCheckModeForMonitor(stuff->screen, modetmp)) {
    case MODE_OK:
        break;
    case MODE_HSYNC:
    case MODE_H_ILLEGAL:
        free(modetmp);
        return VidModeErrorBase + XF86VidModeBadHTimings;
    case MODE_VSYNC:
    case MODE_V_ILLEGAL:
        free(modetmp);
        return VidModeErrorBase + XF86VidModeBadVTimings;
    default:
        free(modetmp);
        return VidModeErrorBase + XF86VidModeModeUnsuitable;
    }

    /* Check that the driver is happy with the mode */
    if (VidModeCheckModeForDriver(stuff->screen, modetmp) != MODE_OK) {
        free(modetmp);
        return VidModeErrorBase + XF86VidModeModeUnsuitable;
    }
    free(modetmp);

    VidModeSetModeValue(mode, VIDMODE_H_DISPLAY, stuff->hdisplay);
    VidModeSetModeValue(mode, VIDMODE_H_SYNCSTART, stuff->hsyncstart);
    VidModeSetModeValue(mode, VIDMODE_H_SYNCEND, stuff->hsyncend);
    VidModeSetModeValue(mode, VIDMODE_H_TOTAL, stuff->htotal);
    VidModeSetModeValue(mode, VIDMODE_H_SKEW, stuff->hskew);
    VidModeSetModeValue(mode, VIDMODE_V_DISPLAY, stuff->vdisplay);
    VidModeSetModeValue(mode, VIDMODE_V_SYNCSTART, stuff->vsyncstart);
    VidModeSetModeValue(mode, VIDMODE_V_SYNCEND, stuff->vsyncend);
    VidModeSetModeValue(mode, VIDMODE_V_TOTAL, stuff->vtotal);
    VidModeSetModeValue(mode, VIDMODE_FLAGS, stuff->flags);

    VidModeSetCrtcForMode(stuff->screen, mode);
    VidModeSwitchMode(stuff->screen, mode);

    if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY)
        ErrorF("ModModeLine - Succeeded\n");
    return Success;
}

static int
ProcXF86VidModeValidateModeLine(ClientPtr client)
{
    REQUEST(xXF86VidModeValidateModeLineReq);
    xXF86OldVidModeValidateModeLineReq *oldstuff =
        (xXF86OldVidModeValidateModeLineReq *) client->requestBuffer;
    xXF86VidModeValidateModeLineReq newstuff;
    xXF86VidModeValidateModeLineReply rep;
    pointer mode, modetmp = NULL;
    int len, status, dotClock;
    int ver;

    DEBUG_P("XF86VidModeValidateModeline");

    ver = ClientMajorVersion(client);
    if (ver < 2) {
        /* convert from old format */
        stuff = &newstuff;
        stuff->length = oldstuff->length;
        stuff->screen = oldstuff->screen;
        stuff->dotclock = oldstuff->dotclock;
        stuff->hdisplay = oldstuff->hdisplay;
        stuff->hsyncstart = oldstuff->hsyncstart;
        stuff->hsyncend = oldstuff->hsyncend;
        stuff->htotal = oldstuff->htotal;
        stuff->hskew = 0;
        stuff->vdisplay = oldstuff->vdisplay;
        stuff->vsyncstart = oldstuff->vsyncstart;
        stuff->vsyncend = oldstuff->vsyncend;
        stuff->vtotal = oldstuff->vtotal;
        stuff->flags = oldstuff->flags;
        stuff->privsize = oldstuff->privsize;
    }
    if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY) {
        ErrorF("ValidateModeLine - scrn: %d clock: %ld\n",
               (int) stuff->screen, (unsigned long) stuff->dotclock);
        ErrorF("                   hdsp: %d hbeg: %d hend: %d httl: %d\n",
               stuff->hdisplay, stuff->hsyncstart,
               stuff->hsyncend, stuff->htotal);
        ErrorF
            ("                   vdsp: %d vbeg: %d vend: %d vttl: %d flags: %ld\n",
             stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend, stuff->vtotal,
             (unsigned long) stuff->flags);
    }

    if (ver < 2) {
        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeValidateModeLineReq);
        len = client->req_len -
            bytes_to_int32(sizeof(xXF86OldVidModeValidateModeLineReq));
    }
    else {
        REQUEST_AT_LEAST_SIZE(xXF86VidModeValidateModeLineReq);
        len =
            client->req_len -
            bytes_to_int32(sizeof(xXF86VidModeValidateModeLineReq));
    }
    if (len != stuff->privsize)
        return BadLength;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    status = MODE_OK;

    if (stuff->hsyncstart < stuff->hdisplay ||
        stuff->hsyncend < stuff->hsyncstart ||
        stuff->htotal < stuff->hsyncend ||
        stuff->vsyncstart < stuff->vdisplay ||
        stuff->vsyncend < stuff->vsyncstart ||
        stuff->vtotal < stuff->vsyncend) {
        status = MODE_BAD;
        goto status_reply;
    }

    if (!VidModeGetCurrentModeline(stuff->screen, &mode, &dotClock))
        return BadValue;

    modetmp = VidModeCreateMode();
    VidModeCopyMode(mode, modetmp);

    VidModeSetModeValue(modetmp, VIDMODE_H_DISPLAY, stuff->hdisplay);
    VidModeSetModeValue(modetmp, VIDMODE_H_SYNCSTART, stuff->hsyncstart);
    VidModeSetModeValue(modetmp, VIDMODE_H_SYNCEND, stuff->hsyncend);
    VidModeSetModeValue(modetmp, VIDMODE_H_TOTAL, stuff->htotal);
    VidModeSetModeValue(modetmp, VIDMODE_H_SKEW, stuff->hskew);
    VidModeSetModeValue(modetmp, VIDMODE_V_DISPLAY, stuff->vdisplay);
    VidModeSetModeValue(modetmp, VIDMODE_V_SYNCSTART, stuff->vsyncstart);
    VidModeSetModeValue(modetmp, VIDMODE_V_SYNCEND, stuff->vsyncend);
    VidModeSetModeValue(modetmp, VIDMODE_V_TOTAL, stuff->vtotal);
    VidModeSetModeValue(modetmp, VIDMODE_FLAGS, stuff->flags);
    if (stuff->privsize)
        ErrorF("ValidateModeLine - Privates in request have been ignored\n");

    /* Check that the mode is consistent with the monitor specs */
    if ((status =
         VidModeCheckModeForMonitor(stuff->screen, modetmp)) != MODE_OK)
        goto status_reply;

    /* Check that the driver is happy with the mode */
    status = VidModeCheckModeForDriver(stuff->screen, modetmp);

 status_reply:
    free(modetmp);

    rep.type = X_Reply;
    rep.length = bytes_to_int32(SIZEOF(xXF86VidModeValidateModeLineReply)
                                - SIZEOF(xGenericReply));
    rep.sequenceNumber = client->sequence;
    rep.status = status;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.status);
    }
    WriteToClient(client, sizeof(xXF86VidModeValidateModeLineReply),
                  (char *) &rep);
    if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY)
        ErrorF("ValidateModeLine - Succeeded (status = %d)\n", status);
    return Success;
}

static int
ProcXF86VidModeSwitchMode(ClientPtr client)
{
    REQUEST(xXF86VidModeSwitchModeReq);

    DEBUG_P("XF86VidModeSwitchMode");

    REQUEST_SIZE_MATCH(xXF86VidModeSwitchModeReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    VidModeZoomViewport(stuff->screen, (short) stuff->zoom);

    return Success;
}

static int
ProcXF86VidModeSwitchToMode(ClientPtr client)
{
    REQUEST(xXF86VidModeSwitchToModeReq);
    xXF86OldVidModeSwitchToModeReq *oldstuff =
        (xXF86OldVidModeSwitchToModeReq *) client->requestBuffer;
    xXF86VidModeSwitchToModeReq newstuff;
    pointer mode;
    int len, dotClock;
    int ver;

    DEBUG_P("XF86VidModeSwitchToMode");

    ver = ClientMajorVersion(client);
    if (ver < 2) {
        /* convert from old format */
        stuff = &newstuff;
        stuff->length = oldstuff->length;
        stuff->screen = oldstuff->screen;
        stuff->dotclock = oldstuff->dotclock;
        stuff->hdisplay = oldstuff->hdisplay;
        stuff->hsyncstart = oldstuff->hsyncstart;
        stuff->hsyncend = oldstuff->hsyncend;
        stuff->htotal = oldstuff->htotal;
        stuff->hskew = 0;
        stuff->vdisplay = oldstuff->vdisplay;
        stuff->vsyncstart = oldstuff->vsyncstart;
        stuff->vsyncend = oldstuff->vsyncend;
        stuff->vtotal = oldstuff->vtotal;
        stuff->flags = oldstuff->flags;
        stuff->privsize = oldstuff->privsize;
    }
    if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY) {
        ErrorF("SwitchToMode - scrn: %d clock: %ld\n",
               (int) stuff->screen, (unsigned long) stuff->dotclock);
        ErrorF("               hdsp: %d hbeg: %d hend: %d httl: %d\n",
               stuff->hdisplay, stuff->hsyncstart,
               stuff->hsyncend, stuff->htotal);
        ErrorF
            ("               vdsp: %d vbeg: %d vend: %d vttl: %d flags: %ld\n",
             stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend, stuff->vtotal,
             (unsigned long) stuff->flags);
    }

    if (ver < 2) {
        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeSwitchToModeReq);
        len =
            client->req_len -
            bytes_to_int32(sizeof(xXF86OldVidModeSwitchToModeReq));
    }
    else {
        REQUEST_AT_LEAST_SIZE(xXF86VidModeSwitchToModeReq);
        len =
            client->req_len -
            bytes_to_int32(sizeof(xXF86VidModeSwitchToModeReq));
    }
    if (len != stuff->privsize)
        return BadLength;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (!VidModeGetCurrentModeline(stuff->screen, &mode, &dotClock))
        return BadValue;

    if ((VidModeGetDotClock(stuff->screen, stuff->dotclock) == dotClock)
        && MODEMATCH(mode, stuff))
        return Success;

    if (!VidModeGetFirstModeline(stuff->screen, &mode, &dotClock))
        return BadValue;

    do {
        if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY) {
            ErrorF("Checking against clock: %d (%d)\n",
                   VidModeGetModeValue(mode, VIDMODE_CLOCK), dotClock);
            ErrorF("                 hdsp: %d hbeg: %d hend: %d httl: %d\n",
                   VidModeGetModeValue(mode, VIDMODE_H_DISPLAY),
                   VidModeGetModeValue(mode, VIDMODE_H_SYNCSTART),
                   VidModeGetModeValue(mode, VIDMODE_H_SYNCEND),
                   VidModeGetModeValue(mode, VIDMODE_H_TOTAL));
            ErrorF
                ("                 vdsp: %d vbeg: %d vend: %d vttl: %d flags: %d\n",
                 VidModeGetModeValue(mode, VIDMODE_V_DISPLAY),
                 VidModeGetModeValue(mode, VIDMODE_V_SYNCSTART),
                 VidModeGetModeValue(mode, VIDMODE_V_SYNCEND),
                 VidModeGetModeValue(mode, VIDMODE_V_TOTAL),
                 VidModeGetModeValue(mode, VIDMODE_FLAGS));
        }
        if ((VidModeGetDotClock(stuff->screen, stuff->dotclock) == dotClock) &&
            MODEMATCH(mode, stuff)) {

            if (!VidModeSwitchMode(stuff->screen, mode))
                return BadValue;

            if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY)
                ErrorF("SwitchToMode - Succeeded\n");
            return Success;
        }
    } while (VidModeGetNextModeline(stuff->screen, &mode, &dotClock));

    return BadValue;
}

static int
ProcXF86VidModeLockModeSwitch(ClientPtr client)
{
    REQUEST(xXF86VidModeLockModeSwitchReq);

    REQUEST_SIZE_MATCH(xXF86VidModeLockModeSwitchReq);

    DEBUG_P("XF86VidModeLockModeSwitch");

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (!VidModeLockZoom(stuff->screen, (short) stuff->lock))
        return VidModeErrorBase + XF86VidModeZoomLocked;

    return Success;
}

static int
ProcXF86VidModeGetMonitor(ClientPtr client)
{
    REQUEST(xXF86VidModeGetMonitorReq);
    xXF86VidModeGetMonitorReply rep;
    CARD32 *hsyncdata, *vsyncdata;
    int i, nHsync, nVrefresh;
    pointer monitor;

    DEBUG_P("XF86VidModeGetMonitor");

    REQUEST_SIZE_MATCH(xXF86VidModeGetMonitorReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (!VidModeGetMonitor(stuff->screen, &monitor))
        return BadValue;

    nHsync = VidModeGetMonitorValue(monitor, VIDMODE_MON_NHSYNC, 0).i;
    nVrefresh = VidModeGetMonitorValue(monitor, VIDMODE_MON_NVREFRESH, 0).i;

    rep.type = X_Reply;
    if ((char *) (VidModeGetMonitorValue(monitor, VIDMODE_MON_VENDOR, 0)).ptr)
        rep.vendorLength = strlen((char *) (VidModeGetMonitorValue(monitor,
                                                                   VIDMODE_MON_VENDOR,
                                                                   0)).ptr);
    else
        rep.vendorLength = 0;
    if ((char *) (VidModeGetMonitorValue(monitor, VIDMODE_MON_MODEL, 0)).ptr)
        rep.modelLength = strlen((char *) (VidModeGetMonitorValue(monitor,
                                                                  VIDMODE_MON_MODEL,
                                                                  0)).ptr);
    else
        rep.modelLength = 0;
    rep.length =
        bytes_to_int32(SIZEOF(xXF86VidModeGetMonitorReply) -
                       SIZEOF(xGenericReply) + (nHsync +
                                                nVrefresh) * sizeof(CARD32) +
                       pad_to_int32(rep.vendorLength) +
                       pad_to_int32(rep.modelLength));
    rep.sequenceNumber = client->sequence;
    rep.nhsync = nHsync;
    rep.nvsync = nVrefresh;
    hsyncdata = malloc(nHsync * sizeof(CARD32));
    if (!hsyncdata) {
        return BadAlloc;
    }
    vsyncdata = malloc(nVrefresh * sizeof(CARD32));

    if (!vsyncdata) {
        free(hsyncdata);
        return BadAlloc;
    }

    for (i = 0; i < nHsync; i++) {
        hsyncdata[i] = (unsigned short) (VidModeGetMonitorValue(monitor,
                                                                VIDMODE_MON_HSYNC_LO,
                                                                i)).f |
            (unsigned
             short) (VidModeGetMonitorValue(monitor, VIDMODE_MON_HSYNC_HI,
                                            i)).f << 16;
    }
    for (i = 0; i < nVrefresh; i++) {
        vsyncdata[i] = (unsigned short) (VidModeGetMonitorValue(monitor,
                                                                VIDMODE_MON_VREFRESH_LO,
                                                                i)).f |
            (unsigned
             short) (VidModeGetMonitorValue(monitor, VIDMODE_MON_VREFRESH_HI,
                                            i)).f << 16;
    }

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
    }
    WriteToClient(client, SIZEOF(xXF86VidModeGetMonitorReply), (char *) &rep);
    client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
    WriteSwappedDataToClient(client, nHsync * sizeof(CARD32), hsyncdata);
    WriteSwappedDataToClient(client, nVrefresh * sizeof(CARD32), vsyncdata);
    if (rep.vendorLength)
        WriteToClient(client, rep.vendorLength,
                      (char
                       *) (VidModeGetMonitorValue(monitor, VIDMODE_MON_VENDOR,
                                                  0)).ptr);
    if (rep.modelLength)
        WriteToClient(client, rep.modelLength,
                      (char
                       *) (VidModeGetMonitorValue(monitor, VIDMODE_MON_MODEL,
                                                  0)).ptr);

    free(hsyncdata);
    free(vsyncdata);

    return Success;
}

static int
ProcXF86VidModeGetViewPort(ClientPtr client)
{
    REQUEST(xXF86VidModeGetViewPortReq);
    xXF86VidModeGetViewPortReply rep;
    int x, y;

    DEBUG_P("XF86VidModeGetViewPort");

    REQUEST_SIZE_MATCH(xXF86VidModeGetViewPortReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    VidModeGetViewPort(stuff->screen, &x, &y);
    rep.x = x;
    rep.y = y;

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.x);
        swapl(&rep.y);
    }
    WriteToClient(client, SIZEOF(xXF86VidModeGetViewPortReply), (char *) &rep);
    return Success;
}

static int
ProcXF86VidModeSetViewPort(ClientPtr client)
{
    REQUEST(xXF86VidModeSetViewPortReq);

    DEBUG_P("XF86VidModeSetViewPort");

    REQUEST_SIZE_MATCH(xXF86VidModeSetViewPortReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (!VidModeSetViewPort(stuff->screen, stuff->x, stuff->y))
        return BadValue;

    return Success;
}

static int
ProcXF86VidModeGetDotClocks(ClientPtr client)
{
    REQUEST(xXF86VidModeGetDotClocksReq);
    xXF86VidModeGetDotClocksReply rep;
    int n;
    int numClocks;
    CARD32 dotclock;
    int *Clocks = NULL;
    Bool ClockProg;

    DEBUG_P("XF86VidModeGetDotClocks");

    REQUEST_SIZE_MATCH(xXF86VidModeGetDotClocksReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    numClocks = VidModeGetNumOfClocks(stuff->screen, &ClockProg);

    rep.type = X_Reply;
    rep.length = bytes_to_int32(SIZEOF(xXF86VidModeGetDotClocksReply)
                                - SIZEOF(xGenericReply) + numClocks);
    rep.sequenceNumber = client->sequence;
    rep.clocks = numClocks;
    rep.maxclocks = MAXCLOCKS;
    rep.flags = 0;

    if (!ClockProg) {
        Clocks = malloc(numClocks * sizeof(int));
        if (!Clocks)
            return BadValue;
        if (!VidModeGetClocks(stuff->screen, Clocks)) {
            free(Clocks);
            return BadValue;
        }
    }
    if (ClockProg) {
        rep.flags |= CLKFLAG_PROGRAMABLE;
    }
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.clocks);
        swapl(&rep.maxclocks);
        swapl(&rep.flags);
    }
    WriteToClient(client, sizeof(xXF86VidModeGetDotClocksReply), (char *) &rep);
    if (!ClockProg) {
        for (n = 0; n < numClocks; n++) {
            dotclock = *Clocks++;
            if (client->swapped) {
                WriteSwappedDataToClient(client, 4, (char *) &dotclock);
            }
            else {
                WriteToClient(client, 4, (char *) &dotclock);
            }
        }
    }

    free(Clocks);
    return Success;
}

static int
ProcXF86VidModeSetGamma(ClientPtr client)
{
    REQUEST(xXF86VidModeSetGammaReq);

    DEBUG_P("XF86VidModeSetGamma");

    REQUEST_SIZE_MATCH(xXF86VidModeSetGammaReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (!VidModeSetGamma(stuff->screen, ((float) stuff->red) / 10000.,
                         ((float) stuff->green) / 10000.,
                         ((float) stuff->blue) / 10000.))
        return BadValue;

    return Success;
}

static int
ProcXF86VidModeGetGamma(ClientPtr client)
{
    REQUEST(xXF86VidModeGetGammaReq);
    xXF86VidModeGetGammaReply rep;
    float red, green, blue;

    DEBUG_P("XF86VidModeGetGamma");

    REQUEST_SIZE_MATCH(xXF86VidModeGetGammaReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    if (!VidModeGetGamma(stuff->screen, &red, &green, &blue))
        return BadValue;
    rep.red = (CARD32) (red * 10000.);
    rep.green = (CARD32) (green * 10000.);
    rep.blue = (CARD32) (blue * 10000.);
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.red);
        swapl(&rep.green);
        swapl(&rep.blue);
    }
    WriteToClient(client, sizeof(xXF86VidModeGetGammaReply), (char *) &rep);

    return Success;
}

static int
ProcXF86VidModeSetGammaRamp(ClientPtr client)
{
    CARD16 *r, *g, *b;
    int length;

    REQUEST(xXF86VidModeSetGammaRampReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (stuff->size != VidModeGetGammaRampSize(stuff->screen))
        return BadValue;

    length = (stuff->size + 1) & ~1;

    REQUEST_FIXED_SIZE(xXF86VidModeSetGammaRampReq, length * 6);

    r = (CARD16 *) &stuff[1];
    g = r + length;
    b = g + length;

    if (!VidModeSetGammaRamp(stuff->screen, stuff->size, r, g, b))
        return BadValue;

    return Success;
}

static int
ProcXF86VidModeGetGammaRamp(ClientPtr client)
{
    CARD16 *ramp = NULL;
    int length;
    size_t ramplen = 0;
    xXF86VidModeGetGammaRampReply rep;

    REQUEST(xXF86VidModeGetGammaRampReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (stuff->size != VidModeGetGammaRampSize(stuff->screen))
        return BadValue;

    REQUEST_SIZE_MATCH(xXF86VidModeGetGammaRampReq);

    length = (stuff->size + 1) & ~1;

    if (stuff->size) {
        ramplen = length * 3 * sizeof(CARD16);
        if (!(ramp = malloc(ramplen)))
            return BadAlloc;

        if (!VidModeGetGammaRamp(stuff->screen, stuff->size,
                                 ramp, ramp + length, ramp + (length * 2))) {
            free(ramp);
            return BadValue;
        }
    }
    rep.type = X_Reply;
    rep.length = (length >> 1) * 3;
    rep.sequenceNumber = client->sequence;
    rep.size = stuff->size;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.size);
        SwapShorts((short *) ramp, length * 3);
    }
    WriteToClient(client, sizeof(xXF86VidModeGetGammaRampReply), (char *) &rep);

    if (stuff->size) {
        WriteToClient(client, ramplen, (char *) ramp);
        free(ramp);
    }

    return Success;
}

static int
ProcXF86VidModeGetGammaRampSize(ClientPtr client)
{
    xXF86VidModeGetGammaRampSizeReply rep;

    REQUEST(xXF86VidModeGetGammaRampSizeReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    REQUEST_SIZE_MATCH(xXF86VidModeGetGammaRampSizeReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.size = VidModeGetGammaRampSize(stuff->screen);
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.size);
    }
    WriteToClient(client, sizeof(xXF86VidModeGetGammaRampSizeReply),
                  (char *) &rep);

    return Success;
}

static int
ProcXF86VidModeGetPermissions(ClientPtr client)
{
    xXF86VidModeGetPermissionsReply rep;

    REQUEST(xXF86VidModeGetPermissionsReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    REQUEST_SIZE_MATCH(xXF86VidModeGetPermissionsReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.permissions = XF86VM_READ_PERMISSION;
    if (xf86GetVidModeEnabled() &&
        (xf86GetVidModeAllowNonLocal() || LocalClient(client))) {
        rep.permissions |= XF86VM_WRITE_PERMISSION;
    }
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.permissions);
    }
    WriteToClient(client, sizeof(xXF86VidModeGetPermissionsReply),
                  (char *) &rep);

    return Success;
}

static int
ProcXF86VidModeSetClientVersion(ClientPtr client)
{
    REQUEST(xXF86VidModeSetClientVersionReq);

    VidModePrivPtr pPriv;

    DEBUG_P("XF86VidModeSetClientVersion");

    REQUEST_SIZE_MATCH(xXF86VidModeSetClientVersionReq);

    if ((pPriv = VM_GETPRIV(client)) == NULL) {
        pPriv = malloc(sizeof(VidModePrivRec));
        if (!pPriv)
            return BadAlloc;
        VM_SETPRIV(client, pPriv);
    }
    pPriv->major = stuff->major;

    pPriv->minor = stuff->minor;

    return Success;
}

static int
ProcXF86VidModeDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_XF86VidModeQueryVersion:
        return ProcXF86VidModeQueryVersion(client);
    case X_XF86VidModeGetModeLine:
        return ProcXF86VidModeGetModeLine(client);
    case X_XF86VidModeGetMonitor:
        return ProcXF86VidModeGetMonitor(client);
    case X_XF86VidModeGetAllModeLines:
        return ProcXF86VidModeGetAllModeLines(client);
    case X_XF86VidModeValidateModeLine:
        return ProcXF86VidModeValidateModeLine(client);
    case X_XF86VidModeGetViewPort:
        return ProcXF86VidModeGetViewPort(client);
    case X_XF86VidModeGetDotClocks:
        return ProcXF86VidModeGetDotClocks(client);
    case X_XF86VidModeSetClientVersion:
        return ProcXF86VidModeSetClientVersion(client);
    case X_XF86VidModeGetGamma:
        return ProcXF86VidModeGetGamma(client);
    case X_XF86VidModeGetGammaRamp:
        return ProcXF86VidModeGetGammaRamp(client);
    case X_XF86VidModeGetGammaRampSize:
        return ProcXF86VidModeGetGammaRampSize(client);
    case X_XF86VidModeGetPermissions:
        return ProcXF86VidModeGetPermissions(client);
    default:
        if (!xf86GetVidModeEnabled())
            return VidModeErrorBase + XF86VidModeExtensionDisabled;
        if (xf86GetVidModeAllowNonLocal() || LocalClient(client)) {
            switch (stuff->data) {
            case X_XF86VidModeAddModeLine:
                return ProcXF86VidModeAddModeLine(client);
            case X_XF86VidModeDeleteModeLine:
                return ProcXF86VidModeDeleteModeLine(client);
            case X_XF86VidModeModModeLine:
                return ProcXF86VidModeModModeLine(client);
            case X_XF86VidModeSwitchMode:
                return ProcXF86VidModeSwitchMode(client);
            case X_XF86VidModeSwitchToMode:
                return ProcXF86VidModeSwitchToMode(client);
            case X_XF86VidModeLockModeSwitch:
                return ProcXF86VidModeLockModeSwitch(client);
            case X_XF86VidModeSetViewPort:
                return ProcXF86VidModeSetViewPort(client);
            case X_XF86VidModeSetGamma:
                return ProcXF86VidModeSetGamma(client);
            case X_XF86VidModeSetGammaRamp:
                return ProcXF86VidModeSetGammaRamp(client);
            default:
                return BadRequest;
            }
        }
        else
            return VidModeErrorBase + XF86VidModeClientNotLocal;
    }
}

static int
SProcXF86VidModeQueryVersion(ClientPtr client)
{
    REQUEST(xXF86VidModeQueryVersionReq);
    swaps(&stuff->length);
    return ProcXF86VidModeQueryVersion(client);
}

static int
SProcXF86VidModeGetModeLine(ClientPtr client)
{
    REQUEST(xXF86VidModeGetModeLineReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86VidModeGetModeLineReq);
    swaps(&stuff->screen);
    return ProcXF86VidModeGetModeLine(client);
}

static int
SProcXF86VidModeGetAllModeLines(ClientPtr client)
{
    REQUEST(xXF86VidModeGetAllModeLinesReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86VidModeGetAllModeLinesReq);
    swaps(&stuff->screen);
    return ProcXF86VidModeGetAllModeLines(client);
}

static int
SProcXF86VidModeAddModeLine(ClientPtr client)
{
    xXF86OldVidModeAddModeLineReq *oldstuff =
        (xXF86OldVidModeAddModeLineReq *) client->requestBuffer;
    int ver;

    REQUEST(xXF86VidModeAddModeLineReq);
    ver = ClientMajorVersion(client);
    if (ver < 2) {
        swaps(&oldstuff->length);
        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeAddModeLineReq);
        swapl(&oldstuff->screen);
        swaps(&oldstuff->hdisplay);
        swaps(&oldstuff->hsyncstart);
        swaps(&oldstuff->hsyncend);
        swaps(&oldstuff->htotal);
        swaps(&oldstuff->vdisplay);
        swaps(&oldstuff->vsyncstart);
        swaps(&oldstuff->vsyncend);
        swaps(&oldstuff->vtotal);
        swapl(&oldstuff->flags);
        swapl(&oldstuff->privsize);
        SwapRestL(oldstuff);
    }
    else {
        swaps(&stuff->length);
        REQUEST_AT_LEAST_SIZE(xXF86VidModeAddModeLineReq);
        swapl(&stuff->screen);
        swaps(&stuff->hdisplay);
        swaps(&stuff->hsyncstart);
        swaps(&stuff->hsyncend);
        swaps(&stuff->htotal);
        swaps(&stuff->hskew);
        swaps(&stuff->vdisplay);
        swaps(&stuff->vsyncstart);
        swaps(&stuff->vsyncend);
        swaps(&stuff->vtotal);
        swapl(&stuff->flags);
        swapl(&stuff->privsize);
        SwapRestL(stuff);
    }
    return ProcXF86VidModeAddModeLine(client);
}

static int
SProcXF86VidModeDeleteModeLine(ClientPtr client)
{
    xXF86OldVidModeDeleteModeLineReq *oldstuff =
        (xXF86OldVidModeDeleteModeLineReq *) client->requestBuffer;
    int ver;

    REQUEST(xXF86VidModeDeleteModeLineReq);
    ver = ClientMajorVersion(client);
    if (ver < 2) {
        swaps(&oldstuff->length);
        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeDeleteModeLineReq);
        swapl(&oldstuff->screen);
        swaps(&oldstuff->hdisplay);
        swaps(&oldstuff->hsyncstart);
        swaps(&oldstuff->hsyncend);
        swaps(&oldstuff->htotal);
        swaps(&oldstuff->vdisplay);
        swaps(&oldstuff->vsyncstart);
        swaps(&oldstuff->vsyncend);
        swaps(&oldstuff->vtotal);
        swapl(&oldstuff->flags);
        swapl(&oldstuff->privsize);
        SwapRestL(oldstuff);
    }
    else {
        swaps(&stuff->length);
        REQUEST_AT_LEAST_SIZE(xXF86VidModeDeleteModeLineReq);
        swapl(&stuff->screen);
        swaps(&stuff->hdisplay);
        swaps(&stuff->hsyncstart);
        swaps(&stuff->hsyncend);
        swaps(&stuff->htotal);
        swaps(&stuff->hskew);
        swaps(&stuff->vdisplay);
        swaps(&stuff->vsyncstart);
        swaps(&stuff->vsyncend);
        swaps(&stuff->vtotal);
        swapl(&stuff->flags);
        swapl(&stuff->privsize);
        SwapRestL(stuff);
    }
    return ProcXF86VidModeDeleteModeLine(client);
}

static int
SProcXF86VidModeModModeLine(ClientPtr client)
{
    xXF86OldVidModeModModeLineReq *oldstuff =
        (xXF86OldVidModeModModeLineReq *) client->requestBuffer;
    int ver;

    REQUEST(xXF86VidModeModModeLineReq);
    ver = ClientMajorVersion(client);
    if (ver < 2) {
        swaps(&oldstuff->length);
        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeModModeLineReq);
        swapl(&oldstuff->screen);
        swaps(&oldstuff->hdisplay);
        swaps(&oldstuff->hsyncstart);
        swaps(&oldstuff->hsyncend);
        swaps(&oldstuff->htotal);
        swaps(&oldstuff->vdisplay);
        swaps(&oldstuff->vsyncstart);
        swaps(&oldstuff->vsyncend);
        swaps(&oldstuff->vtotal);
        swapl(&oldstuff->flags);
        swapl(&oldstuff->privsize);
        SwapRestL(oldstuff);
    }
    else {
        swaps(&stuff->length);
        REQUEST_AT_LEAST_SIZE(xXF86VidModeModModeLineReq);
        swapl(&stuff->screen);
        swaps(&stuff->hdisplay);
        swaps(&stuff->hsyncstart);
        swaps(&stuff->hsyncend);
        swaps(&stuff->htotal);
        swaps(&stuff->hskew);
        swaps(&stuff->vdisplay);
        swaps(&stuff->vsyncstart);
        swaps(&stuff->vsyncend);
        swaps(&stuff->vtotal);
        swapl(&stuff->flags);
        swapl(&stuff->privsize);
        SwapRestL(stuff);
    }
    return ProcXF86VidModeModModeLine(client);
}

static int
SProcXF86VidModeValidateModeLine(ClientPtr client)
{
    xXF86OldVidModeValidateModeLineReq *oldstuff =
        (xXF86OldVidModeValidateModeLineReq *) client->requestBuffer;
    int ver;

    REQUEST(xXF86VidModeValidateModeLineReq);
    ver = ClientMajorVersion(client);
    if (ver < 2) {
        swaps(&oldstuff->length);
        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeValidateModeLineReq);
        swapl(&oldstuff->screen);
        swaps(&oldstuff->hdisplay);
        swaps(&oldstuff->hsyncstart);
        swaps(&oldstuff->hsyncend);
        swaps(&oldstuff->htotal);
        swaps(&oldstuff->vdisplay);
        swaps(&oldstuff->vsyncstart);
        swaps(&oldstuff->vsyncend);
        swaps(&oldstuff->vtotal);
        swapl(&oldstuff->flags);
        swapl(&oldstuff->privsize);
        SwapRestL(oldstuff);
    }
    else {
        swaps(&stuff->length);
        REQUEST_AT_LEAST_SIZE(xXF86VidModeValidateModeLineReq);
        swapl(&stuff->screen);
        swaps(&stuff->hdisplay);
        swaps(&stuff->hsyncstart);
        swaps(&stuff->hsyncend);
        swaps(&stuff->htotal);
        swaps(&stuff->hskew);
        swaps(&stuff->vdisplay);
        swaps(&stuff->vsyncstart);
        swaps(&stuff->vsyncend);
        swaps(&stuff->vtotal);
        swapl(&stuff->flags);
        swapl(&stuff->privsize);
        SwapRestL(stuff);
    }
    return ProcXF86VidModeValidateModeLine(client);
}

static int
SProcXF86VidModeSwitchMode(ClientPtr client)
{
    REQUEST(xXF86VidModeSwitchModeReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86VidModeSwitchModeReq);
    swaps(&stuff->screen);
    swaps(&stuff->zoom);
    return ProcXF86VidModeSwitchMode(client);
}

static int
SProcXF86VidModeSwitchToMode(ClientPtr client)
{
    REQUEST(xXF86VidModeSwitchToModeReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86VidModeSwitchToModeReq);
    swapl(&stuff->screen);
    return ProcXF86VidModeSwitchToMode(client);
}

static int
SProcXF86VidModeLockModeSwitch(ClientPtr client)
{
    REQUEST(xXF86VidModeLockModeSwitchReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86VidModeLockModeSwitchReq);
    swaps(&stuff->screen);
    swaps(&stuff->lock);
    return ProcXF86VidModeLockModeSwitch(client);
}

static int
SProcXF86VidModeGetMonitor(ClientPtr client)
{
    REQUEST(xXF86VidModeGetMonitorReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86VidModeGetMonitorReq);
    swaps(&stuff->screen);
    return ProcXF86VidModeGetMonitor(client);
}

static int
SProcXF86VidModeGetViewPort(ClientPtr client)
{
    REQUEST(xXF86VidModeGetViewPortReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86VidModeGetViewPortReq);
    swaps(&stuff->screen);
    return ProcXF86VidModeGetViewPort(client);
}

static int
SProcXF86VidModeSetViewPort(ClientPtr client)
{
    REQUEST(xXF86VidModeSetViewPortReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86VidModeSetViewPortReq);
    swaps(&stuff->screen);
    swapl(&stuff->x);
    swapl(&stuff->y);
    return ProcXF86VidModeSetViewPort(client);
}

static int
SProcXF86VidModeGetDotClocks(ClientPtr client)
{
    REQUEST(xXF86VidModeGetDotClocksReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86VidModeGetDotClocksReq);
    swaps(&stuff->screen);
    return ProcXF86VidModeGetDotClocks(client);
}

static int
SProcXF86VidModeSetClientVersion(ClientPtr client)
{
    REQUEST(xXF86VidModeSetClientVersionReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86VidModeSetClientVersionReq);
    swaps(&stuff->major);
    swaps(&stuff->minor);
    return ProcXF86VidModeSetClientVersion(client);
}

static int
SProcXF86VidModeSetGamma(ClientPtr client)
{
    REQUEST(xXF86VidModeSetGammaReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86VidModeSetGammaReq);
    swaps(&stuff->screen);
    swapl(&stuff->red);
    swapl(&stuff->green);
    swapl(&stuff->blue);
    return ProcXF86VidModeSetGamma(client);
}

static int
SProcXF86VidModeGetGamma(ClientPtr client)
{
    REQUEST(xXF86VidModeGetGammaReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86VidModeGetGammaReq);
    swaps(&stuff->screen);
    return ProcXF86VidModeGetGamma(client);
}

static int
SProcXF86VidModeSetGammaRamp(ClientPtr client)
{
    int length;

    REQUEST(xXF86VidModeSetGammaRampReq);
    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xXF86VidModeSetGammaRampReq);
    swaps(&stuff->size);
    swaps(&stuff->screen);
    length = ((stuff->size + 1) & ~1) * 6;
    REQUEST_FIXED_SIZE(xXF86VidModeSetGammaRampReq, length);
    SwapRestS(stuff);
    return ProcXF86VidModeSetGammaRamp(client);
}

static int
SProcXF86VidModeGetGammaRamp(ClientPtr client)
{
    REQUEST(xXF86VidModeGetGammaRampReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86VidModeGetGammaRampReq);
    swaps(&stuff->size);
    swaps(&stuff->screen);
    return ProcXF86VidModeGetGammaRamp(client);
}

static int
SProcXF86VidModeGetGammaRampSize(ClientPtr client)
{
    REQUEST(xXF86VidModeGetGammaRampSizeReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86VidModeGetGammaRampSizeReq);
    swaps(&stuff->screen);
    return ProcXF86VidModeGetGammaRampSize(client);
}

static int
SProcXF86VidModeGetPermissions(ClientPtr client)
{
    REQUEST(xXF86VidModeGetPermissionsReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86VidModeGetPermissionsReq);
    swaps(&stuff->screen);
    return ProcXF86VidModeGetPermissions(client);
}

static int
SProcXF86VidModeDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_XF86VidModeQueryVersion:
        return SProcXF86VidModeQueryVersion(client);
    case X_XF86VidModeGetModeLine:
        return SProcXF86VidModeGetModeLine(client);
    case X_XF86VidModeGetMonitor:
        return SProcXF86VidModeGetMonitor(client);
    case X_XF86VidModeGetAllModeLines:
        return SProcXF86VidModeGetAllModeLines(client);
    case X_XF86VidModeGetViewPort:
        return SProcXF86VidModeGetViewPort(client);
    case X_XF86VidModeValidateModeLine:
        return SProcXF86VidModeValidateModeLine(client);
    case X_XF86VidModeGetDotClocks:
        return SProcXF86VidModeGetDotClocks(client);
    case X_XF86VidModeSetClientVersion:
        return SProcXF86VidModeSetClientVersion(client);
    case X_XF86VidModeGetGamma:
        return SProcXF86VidModeGetGamma(client);
    case X_XF86VidModeGetGammaRamp:
        return SProcXF86VidModeGetGammaRamp(client);
    case X_XF86VidModeGetGammaRampSize:
        return SProcXF86VidModeGetGammaRampSize(client);
    case X_XF86VidModeGetPermissions:
        return SProcXF86VidModeGetPermissions(client);
    default:
        if (!xf86GetVidModeEnabled())
            return VidModeErrorBase + XF86VidModeExtensionDisabled;
        if (xf86GetVidModeAllowNonLocal() || LocalClient(client)) {
            switch (stuff->data) {
            case X_XF86VidModeAddModeLine:
                return SProcXF86VidModeAddModeLine(client);
            case X_XF86VidModeDeleteModeLine:
                return SProcXF86VidModeDeleteModeLine(client);
            case X_XF86VidModeModModeLine:
                return SProcXF86VidModeModModeLine(client);
            case X_XF86VidModeSwitchMode:
                return SProcXF86VidModeSwitchMode(client);
            case X_XF86VidModeSwitchToMode:
                return SProcXF86VidModeSwitchToMode(client);
            case X_XF86VidModeLockModeSwitch:
                return SProcXF86VidModeLockModeSwitch(client);
            case X_XF86VidModeSetViewPort:
                return SProcXF86VidModeSetViewPort(client);
            case X_XF86VidModeSetGamma:
                return SProcXF86VidModeSetGamma(client);
            case X_XF86VidModeSetGammaRamp:
                return SProcXF86VidModeSetGammaRamp(client);
            default:
                return BadRequest;
            }
        }
        else
            return VidModeErrorBase + XF86VidModeClientNotLocal;
    }
}

void
XFree86VidModeExtensionInit(void)
{
    ExtensionEntry *extEntry;
    ScreenPtr pScreen;
    int i;
    Bool enabled = FALSE;

    DEBUG_P("XFree86VidModeExtensionInit");

    if (!dixRegisterPrivateKey(&VidModeClientPrivateKeyRec, PRIVATE_CLIENT, 0))
        return;
#ifdef XF86VIDMODE_EVENTS
    if (!dixRegisterPrivateKey(&ScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
        return;
#endif

#ifdef XF86VIDMODE_EVENTS
    EventType = CreateNewResourceType(XF86VidModeFreeEvents, "VidModeEvent");
#endif

    for (i = 0; i < screenInfo.numScreens; i++) {
        pScreen = screenInfo.screens[i];
        if (VidModeExtensionInit(pScreen))
            enabled = TRUE;
    }
    /* This means that the DDX doesn't want the vidmode extension enabled */
    if (!enabled)
        return;

    if (
#ifdef XF86VIDMODE_EVENTS
           EventType &&
#endif
           (extEntry = AddExtension(XF86VIDMODENAME,
                                    XF86VidModeNumberEvents,
                                    XF86VidModeNumberErrors,
                                    ProcXF86VidModeDispatch,
                                    SProcXF86VidModeDispatch,
                                    NULL, StandardMinorOpcode))) {
#if 0
        XF86VidModeReqCode = (unsigned char) extEntry->base;
#endif
        VidModeErrorBase = extEntry->errorBase;
#ifdef XF86VIDMODE_EVENTS
        XF86VidModeEventBase = extEntry->eventBase;
        EventSwapVector[XF86VidModeEventBase] =
            (EventSwapPtr) SXF86VidModeNotifyEvent;
#endif
    }
}
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@@


1.6
log
@Update to xserver 1.11.2
@
text
@d55 1
d60 2
a61 2
    int		major;
    int		minor;
a68 1

d78 2
a79 4
static void SXF86VidModeNotifyEvent();
    xXF86VidModeNotifyEvent * /* from */,
    xXF86VidModeNotifyEvent * /* to */
);
d81 1
a81 1
static RESTYPE EventType;	/* resource type for event masks */
d86 5
a90 5
    XF86VidModeEventPtr	next;
    ClientPtr		client;
    ScreenPtr		screen;
    XID			resource;
    CARD32		mask;
d96 2
a97 2
    XF86VidModeEventPtr	events;
    Bool		hasWindow;
d101 1
d114 1
a114 1
# define DEBUG_P(x) ErrorF(x"\n");
d116 1
a116 1
# define DEBUG_P(x) /**/
d118 1
a118 2

static int
d125 1
a125 1
	return 0;
d127 1
a127 1
	return pPriv->major;
d132 3
a134 2
CheckScreenPrivate (pScreen)
    ScreenPtr	pScreen;
d136 1
a136 1
    SetupScreen (pScreen);
d139 1
a139 1
	return;
d141 2
a142 2
	free(pPriv);
	SetScreenPrivate (pScreen, NULL);
d145 1
a145 1
    
d147 3
a149 2
MakeScreenPrivate (pScreen)
    ScreenPtr	pScreen;
d151 1
a151 1
    SetupScreen (pScreen);
d154 2
a155 2
	return pPriv;
    pPriv = New (XF86VidModeScreenPrivateRec);
d157 1
a157 1
	return 0;
d160 1
a160 1
    SetScreenPrivate (pScreen, pPriv);
d165 1
a165 1
getEventMask (ScreenPtr pScreen, ClientPtr client)
d171 1
a171 1
	return 0;
d173 2
a174 2
	if (pEv->client == client)
	    return pEv->mask;
d179 1
a179 1
setEventMask (ScreenPtr pScreen, ClientPtr client, unsigned long mask)
d184 2
a185 2
    if (getEventMask (pScreen, client) == mask)
	return TRUE;
d187 3
a189 3
	pPriv = MakeScreenPrivate (pScreen);
	if (!pPriv)
	    return FALSE;
d192 2
a193 2
	if (pEv->client == client)
	    break;
d195 18
a212 17
	*pPrev = pEv->next;
	free(pEv);
	CheckScreenPrivate (pScreen);
    } else {
	if (!pEv) {
	    pEv = New (ScreenSaverEventRec);
	    if (!pEv) {
		CheckScreenPrivate (pScreen);
		return FALSE;
	    }
	    *pPrev = pEv;
	    pEv->next = NULL;
	    pEv->client = client;
	    pEv->screen = pScreen;
	    pEv->resource = FakeClientID (client->index);
	}
	pEv->mask = mask;
d220 1
a220 1
    XF86VidModeEventPtr	pOld = (XF86VidModeEventPtr)value;
d222 3
a224 2
    SetupScreen (pScreen);
    XF86VidModeEventPtr	pEv, *pPrev;
d227 1
a227 1
	return TRUE;
d229 2
a230 2
	if (pEv == pOld)
	    break;
d232 1
a232 1
	return TRUE;
d235 1
a235 1
    CheckScreenPrivate (pScreen);
d242 5
a246 5
    XF86VidModeScreenPrivatePtr	pPriv;
    XF86VidModeEventPtr		pEv;
    unsigned long		mask;
    xXF86VidModeNotifyEvent	ev;
    int				kind;
d248 1
a248 1
    UpdateCurrentTimeIf ();
d253 1
a253 1
	return;
d255 11
a265 13
    for (pEv = pPriv->events; pEv; pEv = pEv->next)
    {
	if (!(pEv->mask & mask))
	    continue;
	ev.type = XF86VidModeNotify + XF86VidModeEventBase;
	ev.state = state;
	ev.timestamp = currentTime.milliseconds;
	ev.root = pScreen->root->drawable.id;
	ev.kind = kind;
	ev.forced = forced;
	WriteEventsToClient (pEv->client, 1, (xEvent *) &ev);
    }
}
d267 2
a268 3
static void
SXF86VidModeNotifyEvent(xXF86VidModeNotifyEvent *from,
			xXF86VidModeNotifyEvent *to)
d272 3
a274 3
    cpswaps (from->sequenceNumber, to->sequenceNumber);
    cpswapl (from->timestamp, to->timestamp);    
    cpswapl (from->root, to->root);    
d279 1
a279 1
	
a283 1
    register int n;
d294 4
a297 4
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    	swaps(&rep.majorVersion, n);
    	swaps(&rep.minorVersion, n);
d299 1
a299 1
    WriteToClient(client, sizeof(xXF86VidModeQueryVersionReply), (char *)&rep);
a309 1
    register int n;
d319 6
a324 5
	rep.length = bytes_to_int32(SIZEOF(xXF86OldVidModeGetModeLineReply) -
			SIZEOF(xGenericReply));
    } else {
	rep.length = bytes_to_int32(SIZEOF(xXF86VidModeGetModeLineReply) -
			SIZEOF(xGenericReply));
d328 1
a328 1
    if(stuff->screen >= screenInfo.numScreens)
d332 1
a332 1
	return BadValue;
d347 7
a353 8
	ErrorF("GetModeLine - scrn: %d clock: %ld\n",
	       stuff->screen, (unsigned long)rep.dotclock);
	ErrorF("GetModeLine - hdsp: %d hbeg: %d hend: %d httl: %d\n",
	       rep.hdisplay, rep.hsyncstart,
	       rep.hsyncend, rep.htotal);
	ErrorF("              vdsp: %d vbeg: %d vend: %d vttl: %d flags: %ld\n",
	       rep.vdisplay, rep.vsyncstart, rep.vsyncend,
	       rep.vtotal, (unsigned long)rep.flags);
d355 1
a355 1
    
d364 14
a377 14
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.dotclock, n);
    	swaps(&rep.hdisplay, n);
    	swaps(&rep.hsyncstart, n);
    	swaps(&rep.hsyncend, n);
    	swaps(&rep.htotal, n);
    	swaps(&rep.hskew, n);
    	swaps(&rep.vdisplay, n);
    	swaps(&rep.vsyncstart, n);
    	swaps(&rep.vsyncend, n);
    	swaps(&rep.vtotal, n);
	swapl(&rep.flags, n);
	swapl(&rep.privsize, n);
d380 20
a399 19
	oldrep.type = rep.type;
	oldrep.sequenceNumber = rep.sequenceNumber;
	oldrep.length = rep.length;
	oldrep.dotclock = rep.dotclock;
	oldrep.hdisplay = rep.hdisplay;
	oldrep.hsyncstart = rep.hsyncstart;
	oldrep.hsyncend = rep.hsyncend;
	oldrep.htotal = rep.htotal;
	oldrep.vdisplay = rep.vdisplay;
	oldrep.vsyncstart = rep.vsyncstart;
	oldrep.vsyncend = rep.vsyncend;
	oldrep.vtotal = rep.vtotal;
	oldrep.flags = rep.flags;
	oldrep.privsize = rep.privsize;
	WriteToClient(client, sizeof(xXF86OldVidModeGetModeLineReply),
			(char *)&oldrep);
    } else {
	WriteToClient(client, sizeof(xXF86VidModeGetModeLineReply),
			(char *)&rep);
a412 1
    register int n;
d419 1
a419 1
    if(stuff->screen >= screenInfo.numScreens)
d426 1
a426 1
      return VidModeErrorBase + XF86VidModeExtensionDisabled;
d429 2
a430 2
	return BadValue;
    
d433 1
a433 1
		 SIZEOF(xGenericReply);
d435 1
a435 1
	rep.length += modecount * sizeof(xXF86OldVidModeModeInfo);
d437 1
a437 1
	rep.length += modecount * sizeof(xXF86VidModeModeInfo);
d442 3
a444 3
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.modecount, n);
d446 2
a447 1
    WriteToClient(client, sizeof(xXF86VidModeGetAllModeLinesReply), (char *)&rep);
d450 12
a461 12
	mdinf.dotclock = dotClock;
	mdinf.hdisplay = VidModeGetModeValue(mode, VIDMODE_H_DISPLAY);
	mdinf.hsyncstart = VidModeGetModeValue(mode, VIDMODE_H_SYNCSTART);
	mdinf.hsyncend = VidModeGetModeValue(mode, VIDMODE_H_SYNCEND);
	mdinf.htotal = VidModeGetModeValue(mode, VIDMODE_H_TOTAL);
	mdinf.hskew = VidModeGetModeValue(mode, VIDMODE_H_SKEW);
	mdinf.vdisplay = VidModeGetModeValue(mode, VIDMODE_V_DISPLAY);
	mdinf.vsyncstart = VidModeGetModeValue(mode, VIDMODE_V_SYNCSTART);
	mdinf.vsyncend = VidModeGetModeValue(mode, VIDMODE_V_SYNCEND);
	mdinf.vtotal = VidModeGetModeValue(mode, VIDMODE_V_TOTAL);
	mdinf.flags = VidModeGetModeValue(mode, VIDMODE_FLAGS);
	mdinf.privsize = 0;
d463 25
a487 25
	    swapl(&mdinf.dotclock, n);
    	    swaps(&mdinf.hdisplay, n);
    	    swaps(&mdinf.hsyncstart, n);
    	    swaps(&mdinf.hsyncend, n);
    	    swaps(&mdinf.htotal, n);
    	    swaps(&mdinf.hskew, n);
    	    swaps(&mdinf.vdisplay, n);
    	    swaps(&mdinf.vsyncstart, n);
    	    swaps(&mdinf.vsyncend, n);
    	    swaps(&mdinf.vtotal, n);
	    swapl(&mdinf.flags, n);
	    swapl(&mdinf.privsize, n);
	}
	if (ver < 2) {
	    oldmdinf.dotclock = mdinf.dotclock;
	    oldmdinf.hdisplay = mdinf.hdisplay;
	    oldmdinf.hsyncstart = mdinf.hsyncstart;
	    oldmdinf.hsyncend = mdinf.hsyncend;
	    oldmdinf.htotal = mdinf.htotal;
	    oldmdinf.vdisplay = mdinf.vdisplay;
	    oldmdinf.vsyncstart = mdinf.vsyncstart;
	    oldmdinf.vsyncend = mdinf.vsyncend;
	    oldmdinf.vtotal = mdinf.vtotal;
	    oldmdinf.flags = mdinf.flags;
	    oldmdinf.privsize = mdinf.privsize;
d489 6
a494 4
			  (char *)&oldmdinf);
	} else {
            WriteToClient(client, sizeof(xXF86VidModeModeInfo), (char *)&mdinf);
	}
d496 1
a496 1
   } while (VidModeGetNextModeline(stuff->screen, &mode, &dotClock));
d517 1
a517 1
			(xXF86OldVidModeAddModeLineReq *)client->requestBuffer;
d528 27
a554 27
	/* convert from old format */
	stuff = &newstuff;
	stuff->length = oldstuff->length;
	stuff->screen = oldstuff->screen;
	stuff->dotclock = oldstuff->dotclock;
	stuff->hdisplay = oldstuff->hdisplay;
	stuff->hsyncstart = oldstuff->hsyncstart;
	stuff->hsyncend = oldstuff->hsyncend;
	stuff->htotal = oldstuff->htotal;
	stuff->hskew = 0;
	stuff->vdisplay = oldstuff->vdisplay;
	stuff->vsyncstart = oldstuff->vsyncstart;
	stuff->vsyncend = oldstuff->vsyncend;
	stuff->vtotal = oldstuff->vtotal;
	stuff->flags = oldstuff->flags;
	stuff->privsize = oldstuff->privsize;
	stuff->after_dotclock = oldstuff->after_dotclock;
	stuff->after_hdisplay = oldstuff->after_hdisplay;
	stuff->after_hsyncstart = oldstuff->after_hsyncstart;
	stuff->after_hsyncend = oldstuff->after_hsyncend;
	stuff->after_htotal = oldstuff->after_htotal;
	stuff->after_hskew = 0;
	stuff->after_vdisplay = oldstuff->after_vdisplay;
	stuff->after_vsyncstart = oldstuff->after_vsyncstart;
	stuff->after_vsyncend = oldstuff->after_vsyncend;
	stuff->after_vtotal = oldstuff->after_vtotal;
	stuff->after_flags = oldstuff->after_flags;
d557 17
a573 17
	ErrorF("AddModeLine - scrn: %d clock: %ld\n",
		(int)stuff->screen, (unsigned long)stuff->dotclock);
	ErrorF("AddModeLine - hdsp: %d hbeg: %d hend: %d httl: %d\n",
		stuff->hdisplay, stuff->hsyncstart,
		stuff->hsyncend, stuff->htotal);
	ErrorF("              vdsp: %d vbeg: %d vend: %d vttl: %d flags: %ld\n",
		stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend,
		stuff->vtotal, (unsigned long)stuff->flags);
	ErrorF("      after - scrn: %d clock: %ld\n",
		(int)stuff->screen, (unsigned long)stuff->after_dotclock);
	ErrorF("              hdsp: %d hbeg: %d hend: %d httl: %d\n",
		stuff->after_hdisplay, stuff->after_hsyncstart,
		stuff->after_hsyncend, stuff->after_htotal);
	ErrorF("              vdsp: %d vbeg: %d vend: %d vttl: %d flags: %ld\n",
		stuff->after_vdisplay, stuff->after_vsyncstart,
		stuff->after_vsyncend, stuff->after_vtotal,
		(unsigned long)stuff->after_flags);
d577 10
a586 5
	REQUEST_AT_LEAST_SIZE(xXF86OldVidModeAddModeLineReq);
	len = client->req_len - bytes_to_int32(sizeof(xXF86OldVidModeAddModeLineReq));
    } else {
	REQUEST_AT_LEAST_SIZE(xXF86VidModeAddModeLineReq);
	len = client->req_len - bytes_to_int32(sizeof(xXF86VidModeAddModeLineReq));
d589 4
a592 1
	return BadLength;
d594 5
a598 1
    if(stuff->screen >= screenInfo.numScreens)
d601 7
a607 15
    if (stuff->hsyncstart < stuff->hdisplay   ||
	stuff->hsyncend   < stuff->hsyncstart ||
	stuff->htotal     < stuff->hsyncend   ||
	stuff->vsyncstart < stuff->vdisplay   ||
	stuff->vsyncend   < stuff->vsyncstart ||
	stuff->vtotal     < stuff->vsyncend)
	return BadValue;

    if (stuff->after_hsyncstart < stuff->after_hdisplay   ||
	stuff->after_hsyncend   < stuff->after_hsyncstart ||
	stuff->after_htotal     < stuff->after_hsyncend   ||
	stuff->after_vsyncstart < stuff->after_vdisplay   ||
	stuff->after_vsyncend   < stuff->after_vsyncstart ||
	stuff->after_vtotal     < stuff->after_vsyncend)
	return BadValue;
d610 13
a622 12
	Bool found = FALSE;
	if (VidModeGetFirstModeline(stuff->screen, &mode, &dotClock)) {
	    do {
		if ((VidModeGetDotClock(stuff->screen, stuff->dotclock)
			== dotClock) && MODEMATCH(mode, stuff)) {
		    found = TRUE;
		    break;
		}
	    } while (VidModeGetNextModeline(stuff->screen, &mode, &dotClock));
	}
	if (!found)
	    return BadValue;
a624 1

d627 1
a627 1
	return BadValue;
d631 1
a631 1
    VidModeSetModeValue(mode, VIDMODE_H_SYNCSTART, stuff->hsyncstart); 
d636 1
a636 1
    VidModeSetModeValue(mode, VIDMODE_V_SYNCSTART, stuff->vsyncstart); 
d642 1
a642 1
	ErrorF("AddModeLine - Privates in request have been ignored\n");
d646 13
a658 13
    	case MODE_OK:
	    break;
	case MODE_HSYNC:
	case MODE_H_ILLEGAL:
	    free(mode);
	    return VidModeErrorBase + XF86VidModeBadHTimings;
	case MODE_VSYNC:
	case MODE_V_ILLEGAL:
	    free(mode);
	    return VidModeErrorBase + XF86VidModeBadVTimings;
	default:
	    free(mode);
	    return VidModeErrorBase + XF86VidModeModeUnsuitable;
d663 2
a664 2
	free(mode);
	return VidModeErrorBase + XF86VidModeModeUnsuitable;
d668 1
a668 1
    
d670 1
a670 1
    
d672 1
a672 1
	ErrorF("AddModeLine - Succeeded\n");
d681 1
a681 1
		(xXF86OldVidModeDeleteModeLineReq *)client->requestBuffer;
d691 16
a706 16
	/* convert from old format */
	stuff = &newstuff;
	stuff->length = oldstuff->length;
	stuff->screen = oldstuff->screen;
	stuff->dotclock = oldstuff->dotclock;
	stuff->hdisplay = oldstuff->hdisplay;
	stuff->hsyncstart = oldstuff->hsyncstart;
	stuff->hsyncend = oldstuff->hsyncend;
	stuff->htotal = oldstuff->htotal;
	stuff->hskew = 0;
	stuff->vdisplay = oldstuff->vdisplay;
	stuff->vsyncstart = oldstuff->vsyncstart;
	stuff->vsyncend = oldstuff->vsyncend;
	stuff->vtotal = oldstuff->vtotal;
	stuff->flags = oldstuff->flags;
	stuff->privsize = oldstuff->privsize;
d709 9
a717 8
	ErrorF("DeleteModeLine - scrn: %d clock: %ld\n",
		(int)stuff->screen, (unsigned long)stuff->dotclock);
	ErrorF("                 hdsp: %d hbeg: %d hend: %d httl: %d\n",
		stuff->hdisplay, stuff->hsyncstart,
		stuff->hsyncend, stuff->htotal);
	ErrorF("                 vdsp: %d vbeg: %d vend: %d vttl: %d flags: %ld\n",
		stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend,
		stuff->vtotal, (unsigned long)stuff->flags);
d721 10
a730 5
	REQUEST_AT_LEAST_SIZE(xXF86OldVidModeDeleteModeLineReq);
	len = client->req_len - bytes_to_int32(sizeof(xXF86OldVidModeDeleteModeLineReq));
    } else {
	REQUEST_AT_LEAST_SIZE(xXF86VidModeDeleteModeLineReq);
	len = client->req_len - bytes_to_int32(sizeof(xXF86VidModeDeleteModeLineReq));
d733 8
a740 8
	if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY) {
	    ErrorF("req_len = %ld, sizeof(Req) = %d, privsize = %ld, "
		   "len = %d, length = %d\n",
		    (unsigned long)client->req_len,
		    (int)sizeof(xXF86VidModeDeleteModeLineReq)>>2,
		    (unsigned long)stuff->privsize, len, stuff->length);
	}
	return BadLength;
d743 1
a743 1
    if(stuff->screen >= screenInfo.numScreens)
d747 1
a747 1
	return BadValue;
d750 14
a763 13
	ErrorF("Checking against clock: %d (%d)\n",
		VidModeGetModeValue(mode, VIDMODE_CLOCK), dotClock);
	ErrorF("                 hdsp: %d hbeg: %d hend: %d httl: %d\n",
	       VidModeGetModeValue(mode, VIDMODE_H_DISPLAY),
	       VidModeGetModeValue(mode, VIDMODE_H_SYNCSTART),
	       VidModeGetModeValue(mode, VIDMODE_H_SYNCEND),
	       VidModeGetModeValue(mode, VIDMODE_H_TOTAL));
	ErrorF("                 vdsp: %d vbeg: %d vend: %d vttl: %d flags: %d\n",
	       VidModeGetModeValue(mode, VIDMODE_V_DISPLAY),
	       VidModeGetModeValue(mode, VIDMODE_V_SYNCSTART),
	       VidModeGetModeValue(mode, VIDMODE_V_SYNCEND),
	       VidModeGetModeValue(mode, VIDMODE_V_TOTAL),
	       VidModeGetModeValue(mode, VIDMODE_FLAGS));
d766 2
a767 2
	    MODEMATCH(mode, stuff))
	return BadValue;
d770 1
a770 1
	return BadValue;
d772 24
a795 23
     do {
	if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY) {
	    ErrorF("Checking against clock: %d (%d)\n",
		 VidModeGetModeValue(mode, VIDMODE_CLOCK), dotClock);
	    ErrorF("                 hdsp: %d hbeg: %d hend: %d httl: %d\n",
		 VidModeGetModeValue(mode, VIDMODE_H_DISPLAY),
		 VidModeGetModeValue(mode, VIDMODE_H_SYNCSTART),
		 VidModeGetModeValue(mode, VIDMODE_H_SYNCEND),
		 VidModeGetModeValue(mode, VIDMODE_H_TOTAL));
	    ErrorF("                 vdsp: %d vbeg: %d vend: %d vttl: %d flags: %d\n",
		 VidModeGetModeValue(mode, VIDMODE_V_DISPLAY),
		 VidModeGetModeValue(mode, VIDMODE_V_SYNCSTART),
		 VidModeGetModeValue(mode, VIDMODE_V_SYNCEND),
		 VidModeGetModeValue(mode, VIDMODE_V_TOTAL),
		 VidModeGetModeValue(mode, VIDMODE_FLAGS));
	}
	if ((VidModeGetDotClock(stuff->screen, stuff->dotclock) == dotClock) &&
		MODEMATCH(mode, stuff)) {
	    VidModeDeleteModeline(stuff->screen, mode);
	    if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY)
		ErrorF("DeleteModeLine - Succeeded\n");
	    return Success;
	}
d806 1
a806 1
			(xXF86OldVidModeModModeLineReq *)client->requestBuffer;
d815 16
a830 16
    if (ver < 2 ) {
	/* convert from old format */
	stuff = &newstuff;
	stuff->length = oldstuff->length;
	stuff->screen = oldstuff->screen;
	stuff->hdisplay = oldstuff->hdisplay;
	stuff->hsyncstart = oldstuff->hsyncstart;
	stuff->hsyncend = oldstuff->hsyncend;
	stuff->htotal = oldstuff->htotal;
	stuff->hskew = 0;
	stuff->vdisplay = oldstuff->vdisplay;
	stuff->vsyncstart = oldstuff->vsyncstart;
	stuff->vsyncend = oldstuff->vsyncend;
	stuff->vtotal = oldstuff->vtotal;
	stuff->flags = oldstuff->flags;
	stuff->privsize = oldstuff->privsize;
d833 6
a838 6
	ErrorF("ModModeLine - scrn: %d hdsp: %d hbeg: %d hend: %d httl: %d\n",
		(int)stuff->screen, stuff->hdisplay, stuff->hsyncstart,
		stuff->hsyncend, stuff->htotal);
	ErrorF("              vdsp: %d vbeg: %d vend: %d vttl: %d flags: %ld\n",
		stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend,
		stuff->vtotal, (unsigned long)stuff->flags);
d842 10
a851 5
	REQUEST_AT_LEAST_SIZE(xXF86OldVidModeModModeLineReq);
	len = client->req_len - bytes_to_int32(sizeof(xXF86OldVidModeModModeLineReq));
    } else {
	REQUEST_AT_LEAST_SIZE(xXF86VidModeModModeLineReq);
	len = client->req_len - bytes_to_int32(sizeof(xXF86VidModeModModeLineReq));
d854 1
a854 1
	return BadLength;
d856 6
a861 7
    if (stuff->hsyncstart < stuff->hdisplay   ||
	stuff->hsyncend   < stuff->hsyncstart ||
	stuff->htotal     < stuff->hsyncend   ||
	stuff->vsyncstart < stuff->vdisplay   ||
	stuff->vsyncend   < stuff->vsyncstart ||
	stuff->vtotal     < stuff->vsyncend)
	return BadValue;
d863 1
a863 1
    if(stuff->screen >= screenInfo.numScreens)
d867 1
a867 1
	return BadValue;
d873 1
a873 1
    VidModeSetModeValue(modetmp, VIDMODE_H_SYNCSTART, stuff->hsyncstart); 
d878 1
a878 1
    VidModeSetModeValue(modetmp, VIDMODE_V_SYNCSTART, stuff->vsyncstart); 
d884 1
a884 1
	ErrorF("ModModeLine - Privates in request have been ignored\n");
d888 13
a900 13
    	case MODE_OK:
	    break;
	case MODE_HSYNC:
	case MODE_H_ILLEGAL:
	    free(modetmp);
	    return VidModeErrorBase + XF86VidModeBadHTimings;
	case MODE_VSYNC:
	case MODE_V_ILLEGAL:
	    free(modetmp);
	    return VidModeErrorBase + XF86VidModeBadVTimings;
	default:
	    free(modetmp);
	    return VidModeErrorBase + XF86VidModeModeUnsuitable;
d905 2
a906 2
	free(modetmp);
	return VidModeErrorBase + XF86VidModeModeUnsuitable;
d911 1
a911 1
    VidModeSetModeValue(mode, VIDMODE_H_SYNCSTART, stuff->hsyncstart); 
d916 1
a916 1
    VidModeSetModeValue(mode, VIDMODE_V_SYNCSTART, stuff->vsyncstart); 
d925 1
a925 1
	ErrorF("ModModeLine - Succeeded\n");
d934 1
a934 1
		(xXF86OldVidModeValidateModeLineReq *)client->requestBuffer;
d945 16
a960 16
	/* convert from old format */
	stuff = &newstuff;
	stuff->length = oldstuff->length;
	stuff->screen = oldstuff->screen;
	stuff->dotclock = oldstuff->dotclock;
	stuff->hdisplay = oldstuff->hdisplay;
	stuff->hsyncstart = oldstuff->hsyncstart;
	stuff->hsyncend = oldstuff->hsyncend;
	stuff->htotal = oldstuff->htotal;
	stuff->hskew = 0;
	stuff->vdisplay = oldstuff->vdisplay;
	stuff->vsyncstart = oldstuff->vsyncstart;
	stuff->vsyncend = oldstuff->vsyncend;
	stuff->vtotal = oldstuff->vtotal;
	stuff->flags = oldstuff->flags;
	stuff->privsize = oldstuff->privsize;
d963 9
a971 8
	ErrorF("ValidateModeLine - scrn: %d clock: %ld\n",
		(int)stuff->screen, (unsigned long)stuff->dotclock);
	ErrorF("                   hdsp: %d hbeg: %d hend: %d httl: %d\n",
		stuff->hdisplay, stuff->hsyncstart,
		stuff->hsyncend, stuff->htotal);
	ErrorF("                   vdsp: %d vbeg: %d vend: %d vttl: %d flags: %ld\n",
		stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend,
		stuff->vtotal, (unsigned long)stuff->flags);
d975 9
a983 6
	REQUEST_AT_LEAST_SIZE(xXF86OldVidModeValidateModeLineReq);
	len = client->req_len -
			bytes_to_int32(sizeof(xXF86OldVidModeValidateModeLineReq));
    } else {
	REQUEST_AT_LEAST_SIZE(xXF86VidModeValidateModeLineReq);
	len = client->req_len - bytes_to_int32(sizeof(xXF86VidModeValidateModeLineReq));
d986 1
a986 1
	return BadLength;
d988 1
a988 1
    if(stuff->screen >= screenInfo.numScreens)
d993 8
a1000 9
    if (stuff->hsyncstart < stuff->hdisplay   ||
	stuff->hsyncend   < stuff->hsyncstart ||
	stuff->htotal     < stuff->hsyncend   ||
	stuff->vsyncstart < stuff->vdisplay   ||
	stuff->vsyncend   < stuff->vsyncstart ||
	stuff->vtotal     < stuff->vsyncend)
    {
	status = MODE_BAD;
	goto status_reply;
d1004 1
a1004 1
	return BadValue;
d1010 1
a1010 1
    VidModeSetModeValue(modetmp, VIDMODE_H_SYNCSTART, stuff->hsyncstart); 
d1015 1
a1015 1
    VidModeSetModeValue(modetmp, VIDMODE_V_SYNCSTART, stuff->vsyncstart); 
d1020 1
a1020 1
	ErrorF("ValidateModeLine - Privates in request have been ignored\n");
d1023 3
a1025 2
    if ((status = VidModeCheckModeForMonitor(stuff->screen, modetmp)) != MODE_OK)
	goto status_reply;
d1030 1
a1030 1
status_reply:
d1035 1
a1035 1
			 - SIZEOF(xGenericReply));
d1039 3
a1041 4
        register int n;
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.status, n);
d1043 2
a1044 1
    WriteToClient(client, sizeof(xXF86VidModeValidateModeLineReply), (char *)&rep);
d1046 1
a1046 1
	ErrorF("ValidateModeLine - Succeeded (status = %d)\n", status);
d1059 1
a1059 1
    if(stuff->screen >= screenInfo.numScreens)
d1062 1
a1062 1
    VidModeZoomViewport(stuff->screen, (short)stuff->zoom);
d1072 1
a1072 1
		(xXF86OldVidModeSwitchToModeReq *)client->requestBuffer;
d1082 16
a1097 16
	/* convert from old format */
	stuff = &newstuff;
	stuff->length = oldstuff->length;
	stuff->screen = oldstuff->screen;
	stuff->dotclock = oldstuff->dotclock;
	stuff->hdisplay = oldstuff->hdisplay;
	stuff->hsyncstart = oldstuff->hsyncstart;
	stuff->hsyncend = oldstuff->hsyncend;
	stuff->htotal = oldstuff->htotal;
	stuff->hskew = 0;
	stuff->vdisplay = oldstuff->vdisplay;
	stuff->vsyncstart = oldstuff->vsyncstart;
	stuff->vsyncend = oldstuff->vsyncend;
	stuff->vtotal = oldstuff->vtotal;
	stuff->flags = oldstuff->flags;
	stuff->privsize = oldstuff->privsize;
d1100 9
a1108 8
	ErrorF("SwitchToMode - scrn: %d clock: %ld\n",
		(int)stuff->screen, (unsigned long)stuff->dotclock);
	ErrorF("               hdsp: %d hbeg: %d hend: %d httl: %d\n",
		stuff->hdisplay, stuff->hsyncstart,
		stuff->hsyncend, stuff->htotal);
	ErrorF("               vdsp: %d vbeg: %d vend: %d vttl: %d flags: %ld\n",
		stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend,
		stuff->vtotal, (unsigned long)stuff->flags);
d1112 10
a1121 5
	REQUEST_AT_LEAST_SIZE(xXF86OldVidModeSwitchToModeReq);
	len = client->req_len - bytes_to_int32(sizeof(xXF86OldVidModeSwitchToModeReq));
    } else {
	REQUEST_AT_LEAST_SIZE(xXF86VidModeSwitchToModeReq);
	len = client->req_len - bytes_to_int32(sizeof(xXF86VidModeSwitchToModeReq));
d1124 1
a1124 1
	return BadLength;
d1126 1
a1126 1
    if(stuff->screen >= screenInfo.numScreens)
d1130 1
a1130 1
	return BadValue;
d1133 2
a1134 2
	    && MODEMATCH(mode, stuff))
	return Success;
d1137 1
a1137 1
	return BadValue;
d1140 26
a1165 25
	if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY) {
	    ErrorF("Checking against clock: %d (%d)\n",
		 VidModeGetModeValue(mode, VIDMODE_CLOCK), dotClock);
	    ErrorF("                 hdsp: %d hbeg: %d hend: %d httl: %d\n",
		 VidModeGetModeValue(mode, VIDMODE_H_DISPLAY),
		 VidModeGetModeValue(mode, VIDMODE_H_SYNCSTART),
		 VidModeGetModeValue(mode, VIDMODE_H_SYNCEND),
		 VidModeGetModeValue(mode, VIDMODE_H_TOTAL));
	    ErrorF("                 vdsp: %d vbeg: %d vend: %d vttl: %d flags: %d\n",
		 VidModeGetModeValue(mode, VIDMODE_V_DISPLAY),
		 VidModeGetModeValue(mode, VIDMODE_V_SYNCSTART),
		 VidModeGetModeValue(mode, VIDMODE_V_SYNCEND),
		 VidModeGetModeValue(mode, VIDMODE_V_TOTAL),
		 VidModeGetModeValue(mode, VIDMODE_FLAGS));
	}
	if ((VidModeGetDotClock(stuff->screen, stuff->dotclock) == dotClock) &&
		MODEMATCH(mode, stuff)) {

	    if (!VidModeSwitchMode(stuff->screen, mode))
		return BadValue;

	    if (xf86GetVerbosity() > DEFAULT_XF86VIDMODE_VERBOSITY)
		ErrorF("SwitchToMode - Succeeded\n");
	    return Success;
	}
d1180 1
a1180 1
    if(stuff->screen >= screenInfo.numScreens)
d1183 2
a1184 2
    if (!VidModeLockZoom(stuff->screen, (short)stuff->lock))
	return VidModeErrorBase + XF86VidModeZoomLocked;
a1193 1
    register int n;
d1197 1
a1197 1
    
d1202 1
a1202 1
    if(stuff->screen >= screenInfo.numScreens)
d1206 1
a1206 1
	return BadValue;
d1210 1
a1210 1
    
d1212 4
a1215 3
    if ((char *)(VidModeGetMonitorValue(monitor, VIDMODE_MON_VENDOR, 0)).ptr)
	rep.vendorLength = strlen((char *)(VidModeGetMonitorValue(monitor,
				  VIDMODE_MON_VENDOR, 0)).ptr);
d1217 5
a1221 4
	rep.vendorLength = 0;
    if ((char *)(VidModeGetMonitorValue(monitor, VIDMODE_MON_MODEL, 0)).ptr)
	rep.modelLength = strlen((char *)(VidModeGetMonitorValue(monitor,
				  VIDMODE_MON_MODEL, 0)).ptr);
d1223 7
a1229 5
	rep.modelLength = 0;
    rep.length = bytes_to_int32(SIZEOF(xXF86VidModeGetMonitorReply) - SIZEOF(xGenericReply) +
		  (nHsync + nVrefresh) * sizeof(CARD32) +
	          pad_to_int32(rep.vendorLength) +
		  pad_to_int32(rep.modelLength));
d1235 1
a1235 1
	return BadAlloc;
d1237 1
a1238 1
    vsyncdata = malloc(nVrefresh * sizeof(CARD32));
d1240 2
a1241 2
	free(hsyncdata);
	return BadAlloc;
d1245 6
a1250 4
	hsyncdata[i] = (unsigned short)(VidModeGetMonitorValue(monitor,
			     VIDMODE_MON_HSYNC_LO, i)).f |
		       (unsigned short)(VidModeGetMonitorValue(monitor,
			     VIDMODE_MON_HSYNC_HI, i)).f << 16;
d1253 6
a1258 4
	vsyncdata[i] = (unsigned short)(VidModeGetMonitorValue(monitor,
			     VIDMODE_MON_VREFRESH_LO, i)).f |
		       (unsigned short)(VidModeGetMonitorValue(monitor,
			     VIDMODE_MON_VREFRESH_HI, i)).f << 16;
a1259 1
    
d1262 2
a1263 2
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
d1265 1
a1265 1
    WriteToClient(client, SIZEOF(xXF86VidModeGetMonitorReply), (char *)&rep);
d1267 2
a1268 4
    WriteSwappedDataToClient(client, nHsync * sizeof(CARD32),
			     hsyncdata);
    WriteSwappedDataToClient(client, nVrefresh * sizeof(CARD32),
			     vsyncdata);
d1270 4
a1273 1
	WriteToClient(client, rep.vendorLength, (char *)(VidModeGetMonitorValue(monitor, VIDMODE_MON_VENDOR, 0)).ptr);
d1275 4
a1278 1
	WriteToClient(client, rep.modelLength, (char *)(VidModeGetMonitorValue(monitor, VIDMODE_MON_MODEL, 0)).ptr);
d1291 1
a1291 1
    int x, y, n;
d1297 1
a1297 1
    if(stuff->screen >= screenInfo.numScreens)
d1309 4
a1312 4
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.x, n);
	swapl(&rep.y, n);
d1314 1
a1314 1
    WriteToClient(client, SIZEOF(xXF86VidModeGetViewPortReply), (char *)&rep);
d1327 1
a1327 1
    if(stuff->screen >= screenInfo.numScreens)
d1331 1
a1331 1
	return BadValue;
d1341 1
a1341 1
    register int n;
d1351 1
a1351 1
    if(stuff->screen >= screenInfo.numScreens)
d1358 1
a1358 1
		    - SIZEOF(xGenericReply) + numClocks);
d1365 7
a1371 7
	Clocks = malloc(numClocks * sizeof(int));
	if (!Clocks)
	    return BadValue;
	if (!VidModeGetClocks(stuff->screen, Clocks)) {
	    free(Clocks);
	    return BadValue;
	}
a1372 1

d1374 1
a1374 1
    	rep.flags |= CLKFLAG_PROGRAMABLE;
d1377 5
a1381 5
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.clocks, n);
	swapl(&rep.maxclocks, n);
	swapl(&rep.flags, n);
d1383 1
a1383 1
    WriteToClient(client, sizeof(xXF86VidModeGetDotClocksReply), (char *)&rep);
d1385 9
a1393 8
	for (n = 0; n < numClocks; n++) {
    	    dotclock = *Clocks++;
	    if (client->swapped) {
		WriteSwappedDataToClient(client, 4, (char *)&dotclock);
	    } else {
		WriteToClient(client, 4, (char *)&dotclock);
	    }
	}
d1409 1
a1409 1
    if(stuff->screen >= screenInfo.numScreens)
d1412 4
a1415 3
    if (!VidModeSetGamma(stuff->screen, ((float)stuff->red)/10000.,
		((float)stuff->green)/10000., ((float)stuff->blue)/10000.))
	return BadValue;
a1424 1
    register int n;
d1431 1
a1431 1
    if(stuff->screen >= screenInfo.numScreens)
d1438 4
a1441 4
	return BadValue;
    rep.red = (CARD32)(red * 10000.);
    rep.green = (CARD32)(green * 10000.);
    rep.blue = (CARD32)(blue * 10000.);
d1443 5
a1447 5
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    	swapl(&rep.red, n);
    	swapl(&rep.green, n);
    	swapl(&rep.blue, n);
d1449 2
a1450 1
    WriteToClient(client, sizeof(xXF86VidModeGetGammaReply), (char *)&rep);
d1459 1
d1462 2
a1463 2
    if(stuff->screen >= screenInfo.numScreens)
	return BadValue;
d1465 2
a1466 2
    if(stuff->size != VidModeGetGammaRampSize(stuff->screen))
	return BadValue;
d1472 1
a1472 1
    r = (CARD16*)&stuff[1];
d1486 1
a1486 1
    int n, length;
d1489 1
d1492 1
a1492 1
    if(stuff->screen >= screenInfo.numScreens)
d1495 1
a1495 1
    if(stuff->size != VidModeGetGammaRampSize(stuff->screen))
d1502 8
a1509 8
    if(stuff->size) {
	ramplen = length * 3 * sizeof(CARD16);
	if (!(ramp = malloc(ramplen)))
	    return BadAlloc;
   
        if (!VidModeGetGammaRamp(stuff->screen, stuff->size, 
		ramp, ramp + length, ramp + (length * 2))) {
	    free(ramp);
d1511 1
a1511 1
	}
a1512 1

d1517 5
a1521 5
    if(client->swapped) {
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swaps(&rep.size, n);
	SwapShorts((short*)ramp, length * 3);
d1523 1
a1523 1
    WriteToClient(client, sizeof(xXF86VidModeGetGammaRampReply), (char *)&rep);
d1525 2
a1526 2
    if(stuff->size) {
	WriteToClient(client, ramplen, (char*)ramp);
a1532 1

d1537 1
a1537 1
    int n;
d1540 1
a1540 1
    if(stuff->screen >= screenInfo.numScreens)
d1548 5
a1552 5
    rep.size = VidModeGetGammaRampSize(stuff->screen); 
    if(client->swapped) {
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swaps(&rep.size, n);
d1554 2
a1555 1
    WriteToClient(client,sizeof(xXF86VidModeGetGammaRampSizeReply),(char*)&rep);
d1564 1
a1564 1
    int n;
d1567 1
a1567 1
    if(stuff->screen >= screenInfo.numScreens)
d1577 2
a1578 2
	(xf86GetVidModeAllowNonLocal() || LocalClient (client))) {
	rep.permissions |= XF86VM_WRITE_PERMISSION;
d1580 4
a1583 4
    if(client->swapped) {
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swapl(&rep.permissions, n);
d1585 2
a1586 1
    WriteToClient(client,sizeof(xXF86VidModeGetPermissionsReply),(char*)&rep);
a1590 1

d1603 4
a1606 4
	pPriv = malloc(sizeof(VidModePrivRec));
	if (!pPriv)
	    return BadAlloc;
	VM_SETPRIV(client, pPriv);
d1609 1
d1611 1
a1611 1
    
d1619 1
a1619 2
    switch (stuff->data)
    {
d1621 1
a1621 1
	return ProcXF86VidModeQueryVersion(client);
d1623 1
a1623 1
	return ProcXF86VidModeGetModeLine(client);
d1625 1
a1625 1
	return ProcXF86VidModeGetMonitor(client);
d1627 1
a1627 1
	return ProcXF86VidModeGetAllModeLines(client);
d1629 1
a1629 1
	return ProcXF86VidModeValidateModeLine(client);
d1631 1
a1631 1
	return ProcXF86VidModeGetViewPort(client);
d1633 1
a1633 1
	return ProcXF86VidModeGetDotClocks(client);
d1635 1
a1635 1
	return ProcXF86VidModeSetClientVersion(client);
d1637 1
a1637 1
	return ProcXF86VidModeGetGamma(client);
d1639 1
a1639 1
	return ProcXF86VidModeGetGammaRamp(client);
d1641 1
a1641 1
	return ProcXF86VidModeGetGammaRampSize(client);
d1643 1
a1643 1
	return ProcXF86VidModeGetPermissions(client);
d1645 28
a1672 27
	if (!xf86GetVidModeEnabled())
	    return VidModeErrorBase + XF86VidModeExtensionDisabled;
	if (xf86GetVidModeAllowNonLocal() || LocalClient (client)) {
	    switch (stuff->data) {
	    case X_XF86VidModeAddModeLine:
		return ProcXF86VidModeAddModeLine(client);
	    case X_XF86VidModeDeleteModeLine:
		return ProcXF86VidModeDeleteModeLine(client);
	    case X_XF86VidModeModModeLine:
		return ProcXF86VidModeModModeLine(client);
	    case X_XF86VidModeSwitchMode:
		return ProcXF86VidModeSwitchMode(client);
	    case X_XF86VidModeSwitchToMode:
		return ProcXF86VidModeSwitchToMode(client);
	    case X_XF86VidModeLockModeSwitch:
		return ProcXF86VidModeLockModeSwitch(client);
	    case X_XF86VidModeSetViewPort:
		return ProcXF86VidModeSetViewPort(client);
	    case X_XF86VidModeSetGamma:
		return ProcXF86VidModeSetGamma(client);
	    case X_XF86VidModeSetGammaRamp:
		return ProcXF86VidModeSetGammaRamp(client);
	    default:
		return BadRequest;
	    }
	} else
	    return VidModeErrorBase + XF86VidModeClientNotLocal;
a1678 1
    register int n;
d1680 1
a1680 1
    swaps(&stuff->length, n);
a1686 1
    register int n;
d1688 1
a1688 1
    swaps(&stuff->length, n);
d1690 1
a1690 1
    swaps(&stuff->screen, n);
a1696 1
    register int n;
d1698 1
a1698 1
    swaps(&stuff->length, n);
d1700 1
a1700 1
    swaps(&stuff->screen, n);
d1708 1
a1708 1
			(xXF86OldVidModeAddModeLineReq *)client->requestBuffer;
d1710 1
a1710 2
    register int n;
    
d1714 31
a1744 30
	swaps(&oldstuff->length, n);
	REQUEST_AT_LEAST_SIZE(xXF86OldVidModeAddModeLineReq);
	swapl(&oldstuff->screen, n);
	swaps(&oldstuff->hdisplay, n);
	swaps(&oldstuff->hsyncstart, n);
	swaps(&oldstuff->hsyncend, n);
	swaps(&oldstuff->htotal, n);
	swaps(&oldstuff->vdisplay, n);
	swaps(&oldstuff->vsyncstart, n);
	swaps(&oldstuff->vsyncend, n);
	swaps(&oldstuff->vtotal, n);
	swapl(&oldstuff->flags, n);
	swapl(&oldstuff->privsize, n);
	SwapRestL(oldstuff);
    } else {
	swaps(&stuff->length, n);
	REQUEST_AT_LEAST_SIZE(xXF86VidModeAddModeLineReq);
	swapl(&stuff->screen, n);
	swaps(&stuff->hdisplay, n);
	swaps(&stuff->hsyncstart, n);
	swaps(&stuff->hsyncend, n);
	swaps(&stuff->htotal, n);
	swaps(&stuff->hskew, n);
	swaps(&stuff->vdisplay, n);
	swaps(&stuff->vsyncstart, n);
	swaps(&stuff->vsyncend, n);
	swaps(&stuff->vtotal, n);
	swapl(&stuff->flags, n);
	swapl(&stuff->privsize, n);
	SwapRestL(stuff);
d1753 1
a1753 1
		(xXF86OldVidModeDeleteModeLineReq *)client->requestBuffer;
a1754 1
    register int n;
d1759 31
a1789 30
	swaps(&oldstuff->length, n);
	REQUEST_AT_LEAST_SIZE(xXF86OldVidModeDeleteModeLineReq);
	swapl(&oldstuff->screen, n);
	swaps(&oldstuff->hdisplay, n);
	swaps(&oldstuff->hsyncstart, n);
	swaps(&oldstuff->hsyncend, n);
	swaps(&oldstuff->htotal, n);
	swaps(&oldstuff->vdisplay, n);
	swaps(&oldstuff->vsyncstart, n);
	swaps(&oldstuff->vsyncend, n);
	swaps(&oldstuff->vtotal, n);
	swapl(&oldstuff->flags, n);
	swapl(&oldstuff->privsize, n);
	SwapRestL(oldstuff);
    } else {
	swaps(&stuff->length, n);
	REQUEST_AT_LEAST_SIZE(xXF86VidModeDeleteModeLineReq);
	swapl(&stuff->screen, n);
	swaps(&stuff->hdisplay, n);
	swaps(&stuff->hsyncstart, n);
	swaps(&stuff->hsyncend, n);
	swaps(&stuff->htotal, n);
	swaps(&stuff->hskew, n);
	swaps(&stuff->vdisplay, n);
	swaps(&stuff->vsyncstart, n);
	swaps(&stuff->vsyncend, n);
	swaps(&stuff->vtotal, n);
	swapl(&stuff->flags, n);
	swapl(&stuff->privsize, n);
	SwapRestL(stuff);
d1798 1
a1798 1
		(xXF86OldVidModeModModeLineReq *)client->requestBuffer;
a1799 1
    register int n;
d1804 31
a1834 30
	swaps(&oldstuff->length, n);
	REQUEST_AT_LEAST_SIZE(xXF86OldVidModeModModeLineReq);
	swapl(&oldstuff->screen, n);
	swaps(&oldstuff->hdisplay, n);
	swaps(&oldstuff->hsyncstart, n);
	swaps(&oldstuff->hsyncend, n);
	swaps(&oldstuff->htotal, n);
	swaps(&oldstuff->vdisplay, n);
	swaps(&oldstuff->vsyncstart, n);
	swaps(&oldstuff->vsyncend, n);
	swaps(&oldstuff->vtotal, n);
	swapl(&oldstuff->flags, n);
	swapl(&oldstuff->privsize, n);
	SwapRestL(oldstuff);
    } else {
	swaps(&stuff->length, n);
	REQUEST_AT_LEAST_SIZE(xXF86VidModeModModeLineReq);
	swapl(&stuff->screen, n);
	swaps(&stuff->hdisplay, n);
	swaps(&stuff->hsyncstart, n);
	swaps(&stuff->hsyncend, n);
	swaps(&stuff->htotal, n);
	swaps(&stuff->hskew, n);
	swaps(&stuff->vdisplay, n);
	swaps(&stuff->vsyncstart, n);
	swaps(&stuff->vsyncend, n);
	swaps(&stuff->vtotal, n);
	swapl(&stuff->flags, n);
	swapl(&stuff->privsize, n);
	SwapRestL(stuff);      
d1843 1
a1843 1
		(xXF86OldVidModeValidateModeLineReq *)client->requestBuffer;
a1844 1
    register int n;
d1849 31
a1879 30
	swaps(&oldstuff->length, n);
	REQUEST_AT_LEAST_SIZE(xXF86OldVidModeValidateModeLineReq);
	swapl(&oldstuff->screen, n);
	swaps(&oldstuff->hdisplay, n);
	swaps(&oldstuff->hsyncstart, n);
	swaps(&oldstuff->hsyncend, n);
	swaps(&oldstuff->htotal, n);
	swaps(&oldstuff->vdisplay, n);
	swaps(&oldstuff->vsyncstart, n);
	swaps(&oldstuff->vsyncend, n);
	swaps(&oldstuff->vtotal, n);
	swapl(&oldstuff->flags, n);
	swapl(&oldstuff->privsize, n);
	SwapRestL(oldstuff);
    } else {
	swaps(&stuff->length, n);
	REQUEST_AT_LEAST_SIZE(xXF86VidModeValidateModeLineReq);
	swapl(&stuff->screen, n);
	swaps(&stuff->hdisplay, n);
	swaps(&stuff->hsyncstart, n);
	swaps(&stuff->hsyncend, n);
	swaps(&stuff->htotal, n);
	swaps(&stuff->hskew, n);
	swaps(&stuff->vdisplay, n);
	swaps(&stuff->vsyncstart, n);
	swaps(&stuff->vsyncend, n);
	swaps(&stuff->vtotal, n);
	swapl(&stuff->flags, n);
	swapl(&stuff->privsize, n);
	SwapRestL(stuff);
a1886 1
    register int n;
d1888 1
a1888 1
    swaps(&stuff->length, n);
d1890 2
a1891 2
    swaps(&stuff->screen, n);
    swaps(&stuff->zoom, n);
a1897 1
    register int n;
d1899 1
a1899 1
    swaps(&stuff->length, n);
d1901 1
a1901 1
    swaps(&stuff->screen, n);
a1907 1
    register int n;
d1909 1
a1909 1
    swaps(&stuff->length, n);
d1911 2
a1912 2
    swaps(&stuff->screen, n);
    swaps(&stuff->lock, n);
a1918 1
    register int n;
d1920 1
a1920 1
    swaps(&stuff->length, n);
d1922 1
a1922 1
    swaps(&stuff->screen, n);
a1928 1
    register int n;
d1930 1
a1930 1
    swaps(&stuff->length, n);
d1932 1
a1932 1
    swaps(&stuff->screen, n);
a1938 1
    register int n;
d1940 1
a1940 1
    swaps(&stuff->length, n);
d1942 3
a1944 3
    swaps(&stuff->screen, n);
    swapl(&stuff->x, n);
    swapl(&stuff->y, n);
a1950 1
    register int n;
d1952 1
a1952 1
    swaps(&stuff->length, n);
d1954 1
a1954 1
    swaps(&stuff->screen, n);
a1960 1
    register int n;
d1962 1
a1962 1
    swaps(&stuff->length, n);
d1964 2
a1965 2
    swaps(&stuff->major, n);
    swaps(&stuff->minor, n);
a1971 1
    register int n;
d1973 1
a1973 1
    swaps(&stuff->length, n);
d1975 4
a1978 4
    swaps(&stuff->screen, n);
    swapl(&stuff->red, n);
    swapl(&stuff->green, n);
    swapl(&stuff->blue, n);
a1984 1
    register int n;
d1986 1
a1986 1
    swaps(&stuff->length, n);
d1988 1
a1988 1
    swaps(&stuff->screen, n);
d1995 2
a1996 1
    int length, n;
d1998 1
a1998 1
    swaps(&stuff->length, n);
d2000 2
a2001 2
    swaps(&stuff->size, n);
    swaps(&stuff->screen, n);
a2010 1
    int n;
d2012 1
a2012 1
    swaps(&stuff->length, n);
d2014 2
a2015 2
    swaps(&stuff->size, n);
    swaps(&stuff->screen, n);
d2021 1
a2021 2
{   
    int n;
d2023 1
a2023 1
    swaps(&stuff->length, n);
d2025 1
a2025 1
    swaps(&stuff->screen, n);
d2031 1
a2031 2
{   
    int n;
d2033 1
a2033 1
    swaps(&stuff->length, n);
d2035 1
a2035 1
    swaps(&stuff->screen, n);
a2038 1

d2043 1
a2043 2
    switch (stuff->data)
    {
d2045 1
a2045 1
	return SProcXF86VidModeQueryVersion(client);
d2047 1
a2047 1
	return SProcXF86VidModeGetModeLine(client);
d2049 1
a2049 1
	return SProcXF86VidModeGetMonitor(client);
d2051 1
a2051 1
	return SProcXF86VidModeGetAllModeLines(client);
d2053 1
a2053 1
	return SProcXF86VidModeGetViewPort(client);
d2055 1
a2055 1
	return SProcXF86VidModeValidateModeLine(client);
d2057 1
a2057 1
	return SProcXF86VidModeGetDotClocks(client);
d2059 1
a2059 1
	return SProcXF86VidModeSetClientVersion(client);
d2061 1
a2061 1
	return SProcXF86VidModeGetGamma(client);
d2063 1
a2063 1
	return SProcXF86VidModeGetGammaRamp(client);
d2065 1
a2065 1
	return SProcXF86VidModeGetGammaRampSize(client);
d2067 1
a2067 1
	return SProcXF86VidModeGetPermissions(client);
d2069 28
a2096 27
	if (!xf86GetVidModeEnabled())
	    return VidModeErrorBase + XF86VidModeExtensionDisabled;
	if (xf86GetVidModeAllowNonLocal() || LocalClient(client)) {
	    switch (stuff->data) {
	    case X_XF86VidModeAddModeLine:
		return SProcXF86VidModeAddModeLine(client);
	    case X_XF86VidModeDeleteModeLine:
		return SProcXF86VidModeDeleteModeLine(client);
	    case X_XF86VidModeModModeLine:
		return SProcXF86VidModeModModeLine(client);
	    case X_XF86VidModeSwitchMode:
		return SProcXF86VidModeSwitchMode(client);
	    case X_XF86VidModeSwitchToMode:
		return SProcXF86VidModeSwitchToMode(client);
	    case X_XF86VidModeLockModeSwitch:
		return SProcXF86VidModeLockModeSwitch(client);
	    case X_XF86VidModeSetViewPort:
		return SProcXF86VidModeSetViewPort(client);
	    case X_XF86VidModeSetGamma:
		return SProcXF86VidModeSetGamma(client);
	    case X_XF86VidModeSetGammaRamp:
		return SProcXF86VidModeSetGammaRamp(client);
	    default:
		return BadRequest;
	    }
	} else
	    return VidModeErrorBase + XF86VidModeClientNotLocal;
d2103 1
a2103 1
    ExtensionEntry* extEntry;
d2105 2
a2106 2
    int		    i;
    Bool	    enabled = FALSE;
d2111 1
a2111 1
	return;
d2114 1
a2114 1
	return;
d2121 1
a2121 1
    for(i = 0; i < screenInfo.numScreens; i++) {
d2123 2
a2124 2
	if (VidModeExtensionInit(pScreen))
	    enabled = TRUE;
d2128 1
a2128 1
	return;
d2132 1
a2132 1
        EventType &&
d2134 6
a2139 7
	(extEntry = AddExtension(XF86VIDMODENAME,
				XF86VidModeNumberEvents,
				XF86VidModeNumberErrors,
				ProcXF86VidModeDispatch,
				SProcXF86VidModeDispatch,
				NULL,
				StandardMinorOpcode))) {
d2141 1
a2141 1
	XF86VidModeReqCode = (unsigned char)extEntry->base;
d2143 1
a2143 1
	VidModeErrorBase = extEntry->errorBase;
d2145 3
a2147 2
	XF86VidModeEventBase = extEntry->eventBase;
	EventSwapVector[XF86VidModeEventBase] = (EventSwapPtr)SXF86VidModeNotifyEvent;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a67 42
static DISPATCH_PROC(ProcXF86VidModeDispatch);
static DISPATCH_PROC(ProcXF86VidModeGetAllModeLines);
static DISPATCH_PROC(ProcXF86VidModeGetModeLine);
static DISPATCH_PROC(ProcXF86VidModeGetMonitor);
static DISPATCH_PROC(ProcXF86VidModeLockModeSwitch);
static DISPATCH_PROC(ProcXF86VidModeAddModeLine);
static DISPATCH_PROC(ProcXF86VidModeDeleteModeLine);
static DISPATCH_PROC(ProcXF86VidModeModModeLine);
static DISPATCH_PROC(ProcXF86VidModeValidateModeLine);
static DISPATCH_PROC(ProcXF86VidModeQueryVersion);
static DISPATCH_PROC(ProcXF86VidModeSwitchMode);
static DISPATCH_PROC(ProcXF86VidModeSwitchToMode);
static DISPATCH_PROC(ProcXF86VidModeGetViewPort);
static DISPATCH_PROC(ProcXF86VidModeSetViewPort);
static DISPATCH_PROC(ProcXF86VidModeGetDotClocks);
static DISPATCH_PROC(ProcXF86VidModeSetGamma);
static DISPATCH_PROC(ProcXF86VidModeGetGamma);
static DISPATCH_PROC(ProcXF86VidModeSetClientVersion);
static DISPATCH_PROC(ProcXF86VidModeGetGammaRamp);
static DISPATCH_PROC(ProcXF86VidModeSetGammaRamp);
static DISPATCH_PROC(ProcXF86VidModeGetGammaRampSize);
static DISPATCH_PROC(SProcXF86VidModeDispatch);
static DISPATCH_PROC(SProcXF86VidModeGetAllModeLines);
static DISPATCH_PROC(SProcXF86VidModeGetModeLine);
static DISPATCH_PROC(SProcXF86VidModeGetMonitor);
static DISPATCH_PROC(SProcXF86VidModeLockModeSwitch);
static DISPATCH_PROC(SProcXF86VidModeAddModeLine);
static DISPATCH_PROC(SProcXF86VidModeDeleteModeLine);
static DISPATCH_PROC(SProcXF86VidModeModModeLine);
static DISPATCH_PROC(SProcXF86VidModeValidateModeLine);
static DISPATCH_PROC(SProcXF86VidModeQueryVersion);
static DISPATCH_PROC(SProcXF86VidModeSwitchMode);
static DISPATCH_PROC(SProcXF86VidModeSwitchToMode);
static DISPATCH_PROC(SProcXF86VidModeGetViewPort);
static DISPATCH_PROC(SProcXF86VidModeSetViewPort);
static DISPATCH_PROC(SProcXF86VidModeGetDotClocks);
static DISPATCH_PROC(SProcXF86VidModeSetGamma);
static DISPATCH_PROC(SProcXF86VidModeGetGamma);
static DISPATCH_PROC(SProcXF86VidModeSetClientVersion);
static DISPATCH_PROC(SProcXF86VidModeGetGammaRamp);
static DISPATCH_PROC(SProcXF86VidModeSetGammaRamp);
static DISPATCH_PROC(SProcXF86VidModeGetGammaRampSize);
a119 52
void
XFree86VidModeExtensionInit(void)
{
    ExtensionEntry* extEntry;
    ScreenPtr pScreen;
    int		    i;
    Bool	    enabled = FALSE;

    DEBUG_P("XFree86VidModeExtensionInit");

    if (!dixRegisterPrivateKey(&VidModeClientPrivateKeyRec, PRIVATE_CLIENT, 0))
	return;
#ifdef XF86VIDMODE_EVENTS
    if (!dixRegisterPrivateKey(&ScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
	return;
#endif

#ifdef XF86VIDMODE_EVENTS
    EventType = CreateNewResourceType(XF86VidModeFreeEvents, "VidModeEvent");
#endif

    for(i = 0; i < screenInfo.numScreens; i++) {
        pScreen = screenInfo.screens[i];
	if (VidModeExtensionInit(pScreen))
	    enabled = TRUE;
    }
    /* This means that the DDX doesn't want the vidmode extension enabled */
    if (!enabled)
	return;

    if (
#ifdef XF86VIDMODE_EVENTS
        EventType &&
#endif
	(extEntry = AddExtension(XF86VIDMODENAME,
				XF86VidModeNumberEvents,
				XF86VidModeNumberErrors,
				ProcXF86VidModeDispatch,
				SProcXF86VidModeDispatch,
				NULL,
				StandardMinorOpcode))) {
#if 0
	XF86VidModeReqCode = (unsigned char)extEntry->base;
#endif
	VidModeErrorBase = extEntry->errorBase;
#ifdef XF86VIDMODE_EVENTS
	XF86VidModeEventBase = extEntry->eventBase;
	EventSwapVector[XF86VidModeEventBase] = (EventSwapPtr)SXF86VidModeNotifyEvent;
#endif
    }
}

d2073 52
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d54 2
a55 2
static int VidModeClientPrivateKeyIndex;
static DevPrivateKey VidModeClientPrivateKey = &VidModeClientPrivateKeyIndex;
d144 2
a145 2
static int ScreenPrivateKeyIndex;
static DevPrivateKey ScreenPrivateKey = &ScreenPrivateKeyIndex;
d153 1
a153 1
#define New(t)  (xalloc (sizeof (t)))
d172 7
a186 3
#ifdef XF86VIDMODE_EVENTS
	SetScreenPrivate (pScreen, NULL);
#endif
d236 1
a236 1
	xfree (pPriv);
d290 1
a290 1
	xfree (pEv);
d326 1
a326 1
    xfree (pEv);
a337 1
    ClientPtr			client;
a348 3
	client = pEv->client;
	if (client->clientGone)
	    continue;
a352 1
	ev.sequenceNumber = client->sequence;
d354 1
a354 1
	ev.root = WindowTable[pScreen->myNum]->drawable.id;
d357 1
a357 1
	WriteEventsToClient (client, 1, (xEvent *) &ev);
d396 1
a396 1
    return (client->noClientException);
d497 1
a497 1
    return (client->noClientException);
d523 1
a523 1
      return (VidModeErrorBase + XF86VidModeExtensionDisabled);
d592 1
a592 1
    return (client->noClientException);
d740 1
a740 1
	    xfree(mode);
d744 1
a744 1
	    xfree(mode);
d747 1
a747 1
	    xfree(mode);
d753 1
a753 1
	xfree(mode);
d763 1
a763 1
    return client->noClientException;
d876 1
a876 1
	    return(client->noClientException);
d970 1
a970 1
	    xfree(modetmp);
d974 1
a974 1
	    xfree(modetmp);
d977 1
a977 1
	    xfree(modetmp);
d983 1
a983 1
	xfree(modetmp);
d986 1
a986 1
    xfree(modetmp);
d1004 1
a1004 1
    return(client->noClientException);
d1105 1
a1105 2
    if(modetmp)
      xfree(modetmp);
d1121 1
a1121 1
    return(client->noClientException);
d1138 1
a1138 1
    return (client->noClientException);
d1202 1
a1202 1
	return (client->noClientException);
d1231 1
a1231 1
	    return(client->noClientException);
d1253 1
a1253 1
    return (client->noClientException);
d1297 1
a1297 1
    hsyncdata = xalloc(nHsync * sizeof(CARD32));
d1302 1
a1302 1
    vsyncdata = xalloc(nVrefresh * sizeof(CARD32));
d1304 1
a1304 1
	xfree(hsyncdata);
d1337 2
a1338 2
    xfree(hsyncdata);
    xfree(vsyncdata);
d1340 1
a1340 1
    return (client->noClientException);
d1372 1
a1372 1
    return (client->noClientException);
d1390 1
a1390 1
    return (client->noClientException);
d1422 1
a1422 1
	Clocks = xalloc(numClocks * sizeof(int));
d1426 1
a1426 1
	    xfree(Clocks);
d1453 2
a1454 2
    xfree(Clocks);
    return (client->noClientException);
d1473 1
a1473 1
    return (client->noClientException);
d1507 1
a1507 1
    return (client->noClientException);
d1534 1
a1534 1
    return (client->noClientException);
d1558 1
a1558 1
	if (!(ramp = xalloc(ramplen)))
d1563 1
a1563 1
	    xfree(ramp);
d1582 1
a1582 1
        xfree(ramp);
d1585 1
a1585 1
    return (client->noClientException);
d1612 1
a1612 1
    return (client->noClientException);
d1642 1
a1642 1
    return (client->noClientException);
d1658 1
a1658 1
	pPriv = xalloc(sizeof(VidModePrivRec));
d1666 1
a1666 1
    return (client->noClientException);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a36 2
#define NEED_REPLIES
#define NEED_EVENTS
d44 1
a44 2
#define _XF86VIDMODE_SERVER_
#include <X11/extensions/xf86vmstr.h>
d49 1
d173 1
a173 1
    EventType = CreateNewResourceType(XF86VidModeFreeEvents);
d388 2
a389 2
    rep.majorVersion = XF86VIDMODE_MAJOR_VERSION;
    rep.minorVersion = XF86VIDMODE_MINOR_VERSION;
d417 2
a418 2
	rep.length = (SIZEOF(xXF86OldVidModeGetModeLineReply) -
			SIZEOF(xGenericReply)) >> 2;
d420 2
a421 2
	rep.length = (SIZEOF(xXF86VidModeGetModeLineReply) -
			SIZEOF(xGenericReply)) >> 2;
d673 1
a673 1
	len = client->req_len - (sizeof(xXF86OldVidModeAddModeLineReq) >> 2);
d676 1
a676 1
	len = client->req_len - (sizeof(xXF86VidModeAddModeLineReq) >> 2);
d812 1
a812 1
	len = client->req_len - (sizeof(xXF86OldVidModeDeleteModeLineReq) >> 2);
d815 1
a815 1
	len = client->req_len - (sizeof(xXF86VidModeDeleteModeLineReq) >> 2);
d926 1
a926 1
	len = client->req_len - (sizeof(xXF86OldVidModeModModeLineReq) >> 2);
d929 1
a929 1
	len = client->req_len - (sizeof(xXF86VidModeModModeLineReq) >> 2);
d1055 1
a1055 1
			(sizeof(xXF86OldVidModeValidateModeLineReq) >> 2);
d1058 1
a1058 1
	len = client->req_len - (sizeof(xXF86VidModeValidateModeLineReq) >> 2);
d1110 2
a1111 2
    rep.length = (SIZEOF(xXF86VidModeValidateModeLineReply)
   			 - SIZEOF(xGenericReply)) >> 2;
d1188 1
a1188 1
	len = client->req_len - (sizeof(xXF86OldVidModeSwitchToModeReq) >> 2);
d1191 1
a1191 1
	len = client->req_len - (sizeof(xXF86VidModeSwitchToModeReq) >> 2);
d1292 1
a1292 1
    rep.length = (SIZEOF(xXF86VidModeGetMonitorReply) - SIZEOF(xGenericReply) +
d1294 2
a1295 2
	          ((rep.vendorLength + 3) & ~3) +
		  ((rep.modelLength + 3) & ~3)) >> 2;
d1416 2
a1417 2
    rep.length = (SIZEOF(xXF86VidModeGetDotClocksReply)
		    - SIZEOF(xGenericReply) + numClocks) >> 2;
d1543 2
a1544 2
    int n, length, i;
    size_t ramplen;
d1578 1
a1578 1
	SwapShorts(ramp, length * 3);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d51 1
d56 2
a57 1
static DevPrivateKey VidModeClientPrivateKey = &VidModeClientPrivateKey;
a69 4
static void XF86VidModeResetProc(
    ExtensionEntry* /* extEntry */
);

a126 2
extern WindowPtr *WindowTable;

d145 3
a147 2
   
static DevPrivateKey ScreenPrivateKey = &ScreenPrivateKey;
d199 1
a199 1
				XF86VidModeResetProc,
a211 7
/*ARGSUSED*/
static void
XF86VidModeResetProc (extEntry)
    ExtensionEntry* extEntry;
{
}

d1546 1
d1561 2
a1562 1
        if(!(ramp = xalloc(length * 3 * sizeof(CARD16))))
d1580 1
a1580 2
	for(i = 0; i < length * 3; i++)
	    swaps(&ramp[i],n);
d1585 1
a1585 1
	WriteToClient(client, rep.length << 2, (char*)ramp);
a2065 1
    CARD16 *ramp;
d2074 1
a2074 5
    ramp = (CARD16*)&stuff[1];
    while(length--) {
	swaps(ramp, n);
	ramp++;
    }
@


1.1
log
@Initial revision
@
text
@d55 1
a55 2
static int VidModeGeneration = 0;
static int VidModeClientPrivateIndex;
d63 4
a66 1
#define VMPRIV(c) ((c)->devPrivates[VidModeClientPrivateIndex].ptr)
d150 1
a150 1
static int ScreenPrivateIndex;
d152 4
a155 2
#define GetScreenPrivate(s) ((ScreenSaverScreenPrivatePtr)(s)->devPrivates[ScreenPrivateIndex].ptr)
#define SetScreenPrivate(s,v) ((s)->devPrivates[ScreenPrivateIndex].ptr = (pointer) v);
a178 1
    ScreenPrivateIndex = AllocateScreenPrivateIndex ();
a192 18
    /*
     * Allocate a client private index to hold the client's version
     * information.
     */
    if (VidModeGeneration != serverGeneration) {
	VidModeClientPrivateIndex = AllocateClientPrivateIndex();
	/*
	 * Allocate 0 length, and use the private to hold a pointer to our
	 * VidModePrivRec.
	 */
	if (!AllocateClientPrivate(VidModeClientPrivateIndex, 0)) {
	    ErrorF("XFree86VidModeExtensionInit: "
		   "AllocateClientPrivate failed\n");
	    return;
	}
	VidModeGeneration = serverGeneration;
    }

d195 1
a195 1
        EventType && ScreenPrivateIndex != -1 &&
d227 1
a227 1
    pPriv = VMPRIV(client);
d1311 1
a1311 1
    hsyncdata = ALLOCATE_LOCAL(nHsync * sizeof(CARD32));
d1316 1
a1316 1
    vsyncdata = ALLOCATE_LOCAL(nVrefresh * sizeof(CARD32));
d1318 1
a1318 1
	DEALLOCATE_LOCAL(hsyncdata);
d1351 2
a1352 2
    DEALLOCATE_LOCAL(hsyncdata);
    DEALLOCATE_LOCAL(vsyncdata);
d1436 1
a1436 1
	Clocks = ALLOCATE_LOCAL(numClocks * sizeof(int));
d1440 1
a1440 1
	    DEALLOCATE_LOCAL(Clocks);
d1467 1
a1467 1
    DEALLOCATE_LOCAL(Clocks);
d1670 1
a1670 1
    if ((pPriv = VMPRIV(client)) == NULL) {
d1674 1
a1674 1
	VMPRIV(client) = pPriv;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
