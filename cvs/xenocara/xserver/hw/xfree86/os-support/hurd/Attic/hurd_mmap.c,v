head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.8
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.1.2.0.14
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.09.16.19.10.23;	author matthieu;	state dead;
branches;
next	1.4;
commitid	Te1daavkBLskZ8gc;

1.4
date	2014.05.02.19.27.49;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.21.20.10.47;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.26;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright 1997 by UCHIYAMA Yasushi
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of UCHIYAMA Yasushi not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  UCHIYAMA Yasushi makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
 *
 * UCHIYAMA YASUSHI DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL UCHIYAMA YASUSHI BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 */
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include<mach.h>
#include<device/device.h>
#include<mach/machine/mach_i386.h>
#include <hurd.h>

#include <X11/X.h>

#include "xf86.h"
#include "xf86Priv.h"
#include "xf86_OSlib.h"

#define BIOS_SIZE 0x20000

int
xf86ReadBIOS(unsigned long Base, unsigned long Offset, unsigned char *Buf,
             int Len)
{
    mach_port_t device, mem_dev;
    memory_object_t mem_obj;
    vm_address_t addr = (vm_address_t) 0;       /* serach starting address */
    kern_return_t err;

    err = get_privileged_ports(NULL, &device);
    if (err) {
        errno = err;
        FatalError("xf86ReadBIOS() can't get_privileged_ports. (%s)\n",
                   strerror(errno));
    }
    err = device_open(device, D_READ | D_WRITE, "mem", &mem_dev);
    mach_port_deallocate(mach_task_self(), device);
    if (err) {
        errno = err;
        FatalError("xf86ReadBIOS() can't device_open. (%s)\n", strerror(errno));
    }
    err =
        device_map(mem_dev, VM_PROT_READ | VM_PROT_WRITE, Base, BIOS_SIZE,
                   &mem_obj, 0);
    if (err) {
        errno = err;
        FatalError("xf86ReadBIOS() can't device_map. (%s)\n", strerror(errno));
    }
    err = vm_map(mach_task_self(),
                 &addr,
                 BIOS_SIZE,
                 0,
                 TRUE,
                 mem_obj,
                 Base,
                 FALSE,
                 VM_PROT_READ | VM_PROT_WRITE,
                 VM_PROT_READ | VM_PROT_WRITE, VM_INHERIT_SHARE);
    mach_port_deallocate(mach_task_self(), mem_obj);
    if (err) {
        errno = err;
        FatalError("xf86ReadBIOS() can't vm_map. (%s)\n", strerror(errno));
    }

    memcpy(Buf, (void *) ((int) addr + Offset), Len);

    err = vm_deallocate(mach_task_self(), addr, BIOS_SIZE);
    if (err) {
        errno = err;
        FatalError("xf86ReadBIOS() can't vm_deallocate. (%s)\n",
                   strerror(errno));
    }

    return Len;
}
@


1.4
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d30 1
@


1.2
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d39 3
a41 2
int 
xf86ReadBIOS(unsigned long Base,unsigned long Offset,unsigned char *Buf,int Len)
d43 1
a43 1
    mach_port_t device,mem_dev;
d45 1
a45 1
    vm_address_t addr = (vm_address_t)0; /* serach starting address */
d48 5
a52 6

    err = get_privileged_ports (NULL, &device);
    if( err )
    {
	errno = err;
	FatalError("xf86ReadBIOS() can't get_privileged_ports. (%s)\n",strerror(errno));
d54 5
a58 6
    err = device_open(device,D_READ|D_WRITE,"mem",&mem_dev);
    mach_port_deallocate (mach_task_self (), device);
    if( err )
    {
	errno = err;
	FatalError("xf86ReadBIOS() can't device_open. (%s)\n",strerror(errno));
d60 6
a65 5
    err = device_map(mem_dev,VM_PROT_READ|VM_PROT_WRITE, Base , BIOS_SIZE ,&mem_obj,0);
    if( err )
    {
	errno = err;
	FatalError("xf86ReadBIOS() can't device_map. (%s)\n",strerror(errno));
d68 13
a80 15
		 &addr,
		 BIOS_SIZE,
		 0,
		 TRUE,
		 mem_obj,
		 Base,
		 FALSE,
		 VM_PROT_READ|VM_PROT_WRITE,
		 VM_PROT_READ|VM_PROT_WRITE,
		 VM_INHERIT_SHARE);
    mach_port_deallocate(mach_task_self(),mem_obj);
    if( err )
    {
	errno = err;
	FatalError("xf86ReadBIOS() can't vm_map. (%s)\n",strerror(errno));
d83 2
a84 2
    memcpy(Buf,(void*)((int)addr + Offset), Len);
    
d86 4
a89 4
    if( err )
    {
	errno = err;
	FatalError("xf86ReadBIOS() can't vm_deallocate. (%s)\n",strerror(errno));
d91 1
a91 1
    
@


1.1
log
@Initial revision
@
text
@a22 1
/* $XFree86$ */
d42 2
a43 2
    mach_port_t device,iopl_dev;
    memory_object_t iopl_mem;
d54 1
a54 1
    err = device_open(device,D_READ|D_WRITE,"iopl",&iopl_dev);
d61 1
a61 1
    err = device_map(iopl_dev,VM_PROT_READ|VM_PROT_WRITE, Base , BIOS_SIZE ,&iopl_mem,0);
d72 1
a72 1
		 iopl_mem,
d78 1
a78 1
    mach_port_deallocate(mach_task_self(),iopl_mem);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d23 1
@

