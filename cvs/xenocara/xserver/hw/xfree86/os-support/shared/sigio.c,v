head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.8.0.10
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.8
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.8
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.6
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.1
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	7pAEtF6Y5EgemkuY;

1.9
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.13.21.47.56;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.29.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.26;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.12.13.21.14.08;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@/* sigio.c -- Support for SIGIO handler installation and removal
 * Created: Thu Jun  3 15:39:18 1999 by faith@@precisioninsight.com
 *
 * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors: Rickard E. (Rik) Faith <faith@@valinux.com>
 */
/*
 * Copyright (c) 2002 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/X.h>
#include "xf86.h"
#include "xf86Priv.h"
#include "xf86_OSlib.h"
#include "inputstr.h"

#ifdef HAVE_STROPTS_H
#include <stropts.h>
#endif

#ifdef MAXDEVICES
/* MAXDEVICES represents the maximimum number of input devices usable
 * at the same time plus one entry for DRM support.
 */
#define MAX_FUNCS   (MAXDEVICES + 1)
#else
#define MAX_FUNCS 16
#endif

typedef struct _xf86SigIOFunc {
    void (*f) (int, void *);
    int fd;
    void *closure;
} Xf86SigIOFunc;

static Xf86SigIOFunc xf86SigIOFuncs[MAX_FUNCS];
static int xf86SigIOMax;
static int xf86SigIOMaxFd;
static fd_set xf86SigIOMask;

/*
 * SIGIO gives no way of discovering which fd signalled, select
 * to discover
 */
static void
xf86SIGIO(int sig)
{
    int i;
    fd_set ready;
    struct timeval to;
    int save_errno = errno;     /* do not clobber the global errno */
    int r;

    inSignalContext = TRUE;

    ready = xf86SigIOMask;
    to.tv_sec = 0;
    to.tv_usec = 0;
    SYSCALL(r = select(xf86SigIOMaxFd, &ready, 0, 0, &to));
    for (i = 0; r > 0 && i < xf86SigIOMax; i++)
        if (xf86SigIOFuncs[i].f && FD_ISSET(xf86SigIOFuncs[i].fd, &ready)) {
            (*xf86SigIOFuncs[i].f) (xf86SigIOFuncs[i].fd,
                                    xf86SigIOFuncs[i].closure);
            r--;
        }
    if (r > 0) {
        xf86Msg(X_ERROR, "SIGIO %d descriptors not handled\n", r);
    }
    /* restore global errno */
    errno = save_errno;

    inSignalContext = FALSE;
}

static int
xf86IsPipe(int fd)
{
    struct stat buf;

    if (fstat(fd, &buf) < 0)
        return 0;
    return S_ISFIFO(buf.st_mode);
}

int
xf86InstallSIGIOHandler(int fd, void (*f) (int, void *), void *closure)
{
    struct sigaction sa;
    struct sigaction osa;
    int i;
    int installed = FALSE;

    if (!xf86Info.useSIGIO)
        return 0;

    for (i = 0; i < MAX_FUNCS; i++) {
        if (!xf86SigIOFuncs[i].f) {
            if (xf86IsPipe(fd))
                return 0;
            OsBlockSIGIO();
#ifdef O_ASYNC
            if (fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_ASYNC) == -1) {
                xf86Msg(X_WARNING, "fcntl(%d, O_ASYNC): %s\n",
                        fd, strerror(errno));
            }
            else {
                if (fcntl(fd, F_SETOWN, getpid()) == -1) {
                    xf86Msg(X_WARNING, "fcntl(%d, F_SETOWN): %s\n",
                            fd, strerror(errno));
                }
                else {
                    installed = TRUE;
                }
            }
#endif
#ifdef I_SETSIG                 /* System V Streams - used on Solaris for input devices */
            if (!installed && isastream(fd)) {
                if (ioctl(fd, I_SETSIG, S_INPUT | S_ERROR | S_HANGUP) == -1) {
                    xf86Msg(X_WARNING, "fcntl(%d, I_SETSIG): %s\n",
                            fd, strerror(errno));
                }
                else {
                    installed = TRUE;
                }
            }
#endif
            if (!installed) {
                OsReleaseSIGIO();
                return 0;
            }
            sigemptyset(&sa.sa_mask);
            sigaddset(&sa.sa_mask, SIGIO);
            sa.sa_flags = SA_RESTART;
            sa.sa_handler = xf86SIGIO;
            sigaction(SIGIO, &sa, &osa);
            xf86SigIOFuncs[i].fd = fd;
            xf86SigIOFuncs[i].closure = closure;
            xf86SigIOFuncs[i].f = f;
            if (i >= xf86SigIOMax)
                xf86SigIOMax = i + 1;
            if (fd >= xf86SigIOMaxFd)
                xf86SigIOMaxFd = fd + 1;
            FD_SET(fd, &xf86SigIOMask);
            OsReleaseSIGIO();
            return 1;
        }
        /* Allow overwriting of the closure and callback */
        else if (xf86SigIOFuncs[i].fd == fd) {
            xf86SigIOFuncs[i].closure = closure;
            xf86SigIOFuncs[i].f = f;
            return 1;
        }
    }
    return 0;
}

int
xf86RemoveSIGIOHandler(int fd)
{
    struct sigaction sa;
    struct sigaction osa;
    int i;
    int max;
    int maxfd;
    int ret;

    if (!xf86Info.useSIGIO)
        return 0;

    max = 0;
    maxfd = -1;
    ret = 0;
    for (i = 0; i < MAX_FUNCS; i++) {
        if (xf86SigIOFuncs[i].f) {
            if (xf86SigIOFuncs[i].fd == fd) {
                xf86SigIOFuncs[i].f = 0;
                xf86SigIOFuncs[i].fd = 0;
                xf86SigIOFuncs[i].closure = 0;
                FD_CLR(fd, &xf86SigIOMask);
                ret = 1;
            }
            else {
                max = i + 1;
                if (xf86SigIOFuncs[i].fd >= maxfd)
                    maxfd = xf86SigIOFuncs[i].fd + 1;
            }
        }
    }
    if (ret) {
#ifdef O_ASYNC
        fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) & ~O_ASYNC);
#endif
#ifdef I_SETSIG
        if (isastream(fd)) {
            if (ioctl(fd, I_SETSIG, 0) == -1) {
                xf86Msg(X_WARNING, "fcntl(%d, I_SETSIG, 0): %s\n",
                        fd, strerror(errno));
            }
        }
#endif
        xf86SigIOMax = max;
        xf86SigIOMaxFd = maxfd;
        if (!max) {
            sigemptyset(&sa.sa_mask);
            sigaddset(&sa.sa_mask, SIGIO);
            sa.sa_flags = 0;
            sa.sa_handler = SIG_IGN;
            sigaction(SIGIO, &sa, &osa);
        }
    }
    return ret;
}

int
xf86BlockSIGIO(void)
{
    return OsBlockSIGIO();
}

void
xf86UnblockSIGIO(int wasset)
{
    OsReleaseSIGIO();
}

void
xf86AssertBlockedSIGIO(char *where)
{
    sigset_t set, old;

    sigemptyset(&set);
    sigprocmask(SIG_BLOCK, &set, &old);
    if (!sigismember(&old, SIGIO))
        xf86Msg(X_ERROR, "SIGIO not blocked at %s\n", where);
}

/* XXX This is a quick hack for the benefit of xf86SetSilkenMouse() */

int
xf86SIGIOSupported(void)
{
    return 1;
}
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d181 1
a181 1
            sa.sa_flags = 0;
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d13 1
a13 1
 * 
d17 1
a17 1
 * 
d25 1
a25 1
 * 
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d102 2
d119 2
a138 1
    int blocked;
d148 1
a148 1
            blocked = xf86BlockSIGIO();
d176 1
a176 1
                xf86UnblockSIGIO(blocked);
d192 1
a192 1
            xf86UnblockSIGIO(blocked);
d265 1
a265 8
    sigset_t set, old;
    int ret;

    sigemptyset(&set);
    sigaddset(&set, SIGIO);
    sigprocmask(SIG_BLOCK, &set, &old);
    ret = sigismember(&old, SIGIO);
    return ret;
d271 1
a271 7
    sigset_t set;

    if (!wasset) {
        sigemptyset(&set);
        sigaddset(&set, SIGIO);
        sigprocmask(SIG_UNBLOCK, &set, NULL);
    }
@


1.6
log
@Update to xserver 1.11.2
@
text
@d59 5
a63 5
# include <X11/X.h>
# include "xf86.h"
# include "xf86Priv.h"
# include "xf86_OSlib.h"
# include "inputstr.h"
d66 1
a66 1
# include <stropts.h>
d73 1
a73 1
# define MAX_FUNCS   (MAXDEVICES + 1)
d75 1
a75 1
# define MAX_FUNCS 16
d79 3
a81 3
    void    (*f) (int, void *);
    int	    fd;
    void    *closure;
d84 4
a87 4
static Xf86SigIOFunc	xf86SigIOFuncs[MAX_FUNCS];
static int		xf86SigIOMax;
static int		xf86SigIOMaxFd;
static fd_set		xf86SigIOMask;
d94 1
a94 1
xf86SIGIO (int sig)
d96 5
a100 5
    int	    i;
    fd_set  ready;
    struct timeval  to;
    int save_errno = errno;	/* do not clobber the global errno */
    int	    r;
d105 1
a105 1
    SYSCALL (r = select (xf86SigIOMaxFd, &ready, 0, 0, &to));
d107 5
a111 6
	if (xf86SigIOFuncs[i].f && FD_ISSET (xf86SigIOFuncs[i].fd, &ready))
	{
	    (*xf86SigIOFuncs[i].f)(xf86SigIOFuncs[i].fd,
				   xf86SigIOFuncs[i].closure);
	    r--;
	}
d113 1
a113 1
      xf86Msg(X_ERROR, "SIGIO %d descriptors not handled\n", r);
d120 1
a120 1
xf86IsPipe (int fd)
d122 4
a125 4
    struct stat	buf;
    
    if (fstat (fd, &buf) < 0)
	return 0;
d130 1
a130 1
xf86InstallSIGIOHandler(int fd, void (*f)(int, void *), void *closure)
d134 1
a134 1
    int	i;
d139 1
a139 1
	return 0;
d141 5
a145 7
    for (i = 0; i < MAX_FUNCS; i++)
    {
	if (!xf86SigIOFuncs[i].f)
	{
	    if (xf86IsPipe (fd))
		return 0;
	    blocked = xf86BlockSIGIO();
d147 51
a197 49
	    if (fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_ASYNC) == -1) {
		xf86Msg(X_WARNING, "fcntl(%d, O_ASYNC): %s\n",
			fd, strerror(errno));
	    } else {
		if (fcntl(fd, F_SETOWN, getpid()) == -1) {
		    xf86Msg(X_WARNING, "fcntl(%d, F_SETOWN): %s\n",
			    fd, strerror(errno));
		} else {
		    installed = TRUE;
		}
	    }
#endif
#ifdef I_SETSIG /* System V Streams - used on Solaris for input devices */
	    if (!installed && isastream(fd)) {
		if (ioctl(fd, I_SETSIG, S_INPUT | S_ERROR | S_HANGUP) == -1) {
		    xf86Msg(X_WARNING, "fcntl(%d, I_SETSIG): %s\n",
			    fd, strerror(errno));
		} else {
		    installed = TRUE;
		}
	    }
#endif
	    if (!installed) {
		xf86UnblockSIGIO(blocked);
		return 0;
	    }
	    sigemptyset(&sa.sa_mask);
	    sigaddset(&sa.sa_mask, SIGIO);
	    sa.sa_flags   = 0;
	    sa.sa_handler = xf86SIGIO;
	    sigaction(SIGIO, &sa, &osa);
	    xf86SigIOFuncs[i].fd = fd;
	    xf86SigIOFuncs[i].closure = closure;
	    xf86SigIOFuncs[i].f = f;
	    if (i >= xf86SigIOMax)
		xf86SigIOMax = i+1;
	    if (fd >= xf86SigIOMaxFd)
		xf86SigIOMaxFd = fd + 1;
	    FD_SET (fd, &xf86SigIOMask);
	    xf86UnblockSIGIO(blocked);
	    return 1;
	}
 	/* Allow overwriting of the closure and callback */
 	else if (xf86SigIOFuncs[i].fd == fd)
 	{
 	    xf86SigIOFuncs[i].closure = closure;
 	    xf86SigIOFuncs[i].f = f;
 	    return 1;
 	}
d207 1
a207 1
    int	i;
d213 1
a213 1
	return 0;
d218 15
a232 19
    for (i = 0; i < MAX_FUNCS; i++)
    {
	if (xf86SigIOFuncs[i].f)
	{
	    if (xf86SigIOFuncs[i].fd == fd)
	    {
		xf86SigIOFuncs[i].f = 0;
		xf86SigIOFuncs[i].fd = 0;
		xf86SigIOFuncs[i].closure = 0;
		FD_CLR (fd, &xf86SigIOMask);
		ret = 1;
	    }
	    else
	    {
		max = i + 1;
		if (xf86SigIOFuncs[i].fd >= maxfd)
		    maxfd = xf86SigIOFuncs[i].fd + 1;
	    }
	}
d234 1
a234 2
    if (ret)
    {
d236 1
a236 1
	fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) & ~O_ASYNC);
d239 16
a254 17
	if (isastream(fd)) {
	    if (ioctl(fd, I_SETSIG, 0) == -1) {
		xf86Msg(X_WARNING, "fcntl(%d, I_SETSIG, 0): %s\n",
			fd, strerror(errno));
	    }
	}
#endif
	xf86SigIOMax = max;
	xf86SigIOMaxFd = maxfd;
	if (!max)
	{
	    sigemptyset(&sa.sa_mask);
	    sigaddset(&sa.sa_mask, SIGIO);
	    sa.sa_flags   = 0;
	    sa.sa_handler = SIG_IGN;
	    sigaction(SIGIO, &sa, &osa);
	}
d260 1
a260 1
xf86BlockSIGIO (void)
d262 8
a269 8
    sigset_t	set, old;
    int		ret;
    
    sigemptyset (&set);
    sigaddset (&set, SIGIO);
    sigprocmask (SIG_BLOCK, &set, &old);
    ret = sigismember (&old, SIGIO);
    return ret; 
d273 1
a273 1
xf86UnblockSIGIO (int wasset)
d275 1
a275 1
    sigset_t	set;
d277 4
a280 5
    if (!wasset)
    {
	sigemptyset (&set);
	sigaddset (&set, SIGIO);
	sigprocmask (SIG_UNBLOCK, &set, NULL);
d285 1
a285 1
xf86AssertBlockedSIGIO (char *where)
d287 1
a287 1
    sigset_t	set, old;
d289 4
a292 4
    sigemptyset (&set);
    sigprocmask (SIG_BLOCK, &set, &old);
    if (!sigismember (&old, SIGIO))
	xf86Msg (X_ERROR, "SIGIO not blocked at %s\n", where);
d298 1
a298 1
xf86SIGIOSupported (void)
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a0 1

a66 8
#endif

/*
 * Linux libc5 defines FASYNC, but not O_ASYNC.  Don't know if it is
 * functional or not.
 */
#if defined(FASYNC) && !defined(O_ASYNC)
#  define O_ASYNC FASYNC
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d66 4
d78 2
a79 2
#ifdef MAX_DEVICES
/* MAX_DEVICES represents the maximimum number of input devices usable
d82 1
a82 1
# define MAX_FUNCS   (MAX_DEVICES + 1)
d139 1
a139 1
_X_EXPORT int
d146 4
d158 1
d160 1
a160 1
		xf86Msg(X_WARNING, "fcntl(%d, O_ASYNC): %s\n", 
d162 17
a178 2
		xf86UnblockSIGIO(blocked);
		return 0;
d180 2
a181 3
	    if (fcntl(fd, F_SETOWN, getpid()) == -1) {
		xf86Msg(X_WARNING, "fcntl(%d, F_SETOWN): %s\n", 
			fd, strerror(errno));
d212 1
a212 1
_X_EXPORT int
d222 3
d250 1
d252 9
d275 1
a275 1
_X_EXPORT int
d288 1
a288 1
_X_EXPORT void
@


1.3
log
@Merge xserver 1.4.0.90. This includes fixes for some of the regressions
introduced by xserver 1.4, such as the keyboad caps/num-lock leds updates.
Tested by many.
@
text
@d232 1
a232 1
	    sa.sa_handler = SIG_DFL;
@


1.2
log
@OpenBSD local modifications:
- privilege separation
- some snprintf/strlc{at,py} conversions
- support for more architectures
- signal handler fixes
- default mouse wheel support in config tools
- sunmouse protocol
@
text
@a248 3
#ifdef DEBUG
    ErrorF("%i = xf86BlockSIGIO()\n",ret);
#endif
a255 3
#ifdef DEBUG
    ErrorF("xf86UnblockSIGIO(%i)\n",wasset);
#endif
@


1.1
log
@Initial revision
@
text
@d104 1
d121 2
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4.0.90
@
text
@d246 3
d256 3
@

