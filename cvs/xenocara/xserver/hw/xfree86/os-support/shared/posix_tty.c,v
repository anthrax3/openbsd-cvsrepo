head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.12
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.10
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.8
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.6
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.6
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.8
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.6
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.10.08.22.40.43;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.08;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.19.04.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.29.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.26;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.20;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright 1993-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of the XFree86 Project shall
 * not be used in advertising or otherwise to promote the sale, use or other
 * dealings in this Software without prior written authorization from the
 * XFree86 Project.
 */
/*
 *
 * Copyright (c) 1997  Metro Link Incorporated
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of the Metro Link shall not be
 * used in advertising or otherwise to promote the sale, use or other dealings
 * in this Software without prior written authorization from Metro Link.
 *
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/X.h>
#include "xf86.h"
#include "xf86Priv.h"
#include "xf86_OSlib.h"

static int
GetBaud(int baudrate)
{
#ifdef B300
    if (baudrate == 300)
        return B300;
#endif
#ifdef B1200
    if (baudrate == 1200)
        return B1200;
#endif
#ifdef B2400
    if (baudrate == 2400)
        return B2400;
#endif
#ifdef B4800
    if (baudrate == 4800)
        return B4800;
#endif
#ifdef B9600
    if (baudrate == 9600)
        return B9600;
#endif
#ifdef B19200
    if (baudrate == 19200)
        return B19200;
#endif
#ifdef B38400
    if (baudrate == 38400)
        return B38400;
#endif
#ifdef B57600
    if (baudrate == 57600)
        return B57600;
#endif
#ifdef B115200
    if (baudrate == 115200)
        return B115200;
#endif
#ifdef B230400
    if (baudrate == 230400)
        return B230400;
#endif
#ifdef B460800
    if (baudrate == 460800)
        return B460800;
#endif
    return 0;
}

int
xf86OpenSerial(XF86OptionPtr options)
{
    struct termios t;
    int fd, i;
    char *dev;

    dev = xf86SetStrOption(options, "Device", NULL);
    if (!dev) {
        xf86Msg(X_ERROR, "xf86OpenSerial: No Device specified.\n");
        return -1;
    }

    fd = xf86CheckIntOption(options, "fd", -1);

    if (fd == -1)
#ifndef X_PRIVSEP
        SYSCALL(fd = open(dev, O_RDWR | O_NONBLOCK));
#else
        fd = priv_open_device(dev);
#endif

    if (fd == -1) {
        xf86Msg(X_ERROR,
                "xf86OpenSerial: Cannot open device %s\n\t%s.\n",
                dev, strerror(errno));
        free(dev);
        return -1;
    }

    if (!isatty(fd)) {
        /* Allow non-tty devices to be opened. */
        free(dev);
        return fd;
    }

    /* set up default port parameters */
    SYSCALL(tcgetattr(fd, &t));
    t.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR
                   | IGNCR | ICRNL | IXON);
    t.c_oflag &= ~OPOST;
    t.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
    t.c_cflag &= ~(CSIZE | PARENB);
    t.c_cflag |= CS8 | CLOCAL;

    cfsetispeed(&t, B9600);
    cfsetospeed(&t, B9600);
    t.c_cc[VMIN] = 1;
    t.c_cc[VTIME] = 0;

    SYSCALL(tcsetattr(fd, TCSANOW, &t));

    if (xf86SetSerial(fd, options) == -1) {
        SYSCALL(close(fd));
        free(dev);
        return -1;
    }

    SYSCALL(i = fcntl(fd, F_GETFL, 0));
    if (i == -1) {
        SYSCALL(close(fd));
        free(dev);
        return -1;
    }
    i &= ~O_NONBLOCK;
    SYSCALL(i = fcntl(fd, F_SETFL, i));
    if (i == -1) {
        SYSCALL(close(fd));
        free(dev);
        return -1;
    }
    free(dev);
    return fd;
}

int
xf86SetSerial(int fd, XF86OptionPtr options)
{
    struct termios t;
    int val;
    const char *s;
    int baud, r;

    if (fd < 0)
        return -1;

    /* Don't try to set parameters for non-tty devices. */
    if (!isatty(fd))
        return 0;

    SYSCALL(tcgetattr(fd, &t));

    if ((val = xf86SetIntOption(options, "BaudRate", 0))) {
        if ((baud = GetBaud(val))) {
            cfsetispeed(&t, baud);
            cfsetospeed(&t, baud);
        }
        else {
            xf86Msg(X_ERROR, "Invalid Option BaudRate value: %d\n", val);
            return -1;
        }
    }

    if ((val = xf86SetIntOption(options, "StopBits", 0))) {
        switch (val) {
        case 1:
            t.c_cflag &= ~(CSTOPB);
            break;
        case 2:
            t.c_cflag |= CSTOPB;
            break;
        default:
            xf86Msg(X_ERROR, "Invalid Option StopBits value: %d\n", val);
            return -1;
            break;
        }
    }

    if ((val = xf86SetIntOption(options, "DataBits", 0))) {
        switch (val) {
        case 5:
            t.c_cflag &= ~(CSIZE);
            t.c_cflag |= CS5;
            break;
        case 6:
            t.c_cflag &= ~(CSIZE);
            t.c_cflag |= CS6;
            break;
        case 7:
            t.c_cflag &= ~(CSIZE);
            t.c_cflag |= CS7;
            break;
        case 8:
            t.c_cflag &= ~(CSIZE);
            t.c_cflag |= CS8;
            break;
        default:
            xf86Msg(X_ERROR, "Invalid Option DataBits value: %d\n", val);
            return -1;
            break;
        }
    }

    if ((s = xf86SetStrOption(options, "Parity", NULL))) {
        if (xf86NameCmp(s, "Odd") == 0) {
            t.c_cflag |= PARENB | PARODD;
        }
        else if (xf86NameCmp(s, "Even") == 0) {
            t.c_cflag |= PARENB;
            t.c_cflag &= ~(PARODD);
        }
        else if (xf86NameCmp(s, "None") == 0) {
            t.c_cflag &= ~(PARENB);
        }
        else {
            xf86Msg(X_ERROR, "Invalid Option Parity value: %s\n", s);
            return -1;
        }
    }

    if ((val = xf86SetIntOption(options, "Vmin", -1)) != -1) {
        t.c_cc[VMIN] = val;
    }
    if ((val = xf86SetIntOption(options, "Vtime", -1)) != -1) {
        t.c_cc[VTIME] = val;
    }

    if ((s = xf86SetStrOption(options, "FlowControl", NULL))) {
        xf86MarkOptionUsedByName(options, "FlowControl");
        if (xf86NameCmp(s, "Xoff") == 0) {
            t.c_iflag |= IXOFF;
        }
        else if (xf86NameCmp(s, "Xon") == 0) {
            t.c_iflag |= IXON;
        }
        else if (xf86NameCmp(s, "XonXoff") == 0) {
            t.c_iflag |= IXON | IXOFF;
        }
        else if (xf86NameCmp(s, "None") == 0) {
            t.c_iflag &= ~(IXON | IXOFF);
        }
        else {
            xf86Msg(X_ERROR, "Invalid Option FlowControl value: %s\n", s);
            return -1;
        }
    }

    if ((xf86SetBoolOption(options, "ClearDTR", FALSE))) {
#ifdef CLEARDTR_SUPPORT
#if defined(TIOCMBIC)
        val = TIOCM_DTR;
        SYSCALL(ioctl(fd, TIOCMBIC, &val));
#else
        SYSCALL(ioctl(fd, TIOCCDTR, NULL));
#endif
#else
        xf86Msg(X_WARNING, "Option ClearDTR not supported on this OS\n");
        return -1;
#endif
        xf86MarkOptionUsedByName(options, "ClearDTR");
    }

    if ((xf86SetBoolOption(options, "ClearRTS", FALSE))) {
        xf86Msg(X_WARNING, "Option ClearRTS not supported on this OS\n");
        return -1;
        xf86MarkOptionUsedByName(options, "ClearRTS");
    }

    SYSCALL(r = tcsetattr(fd, TCSANOW, &t));
    return r;
}

int
xf86SetSerialSpeed(int fd, int speed)
{
    struct termios t;
    int baud, r;

    if (fd < 0)
        return -1;

    /* Don't try to set parameters for non-tty devices. */
    if (!isatty(fd))
        return 0;

    SYSCALL(tcgetattr(fd, &t));

    if ((baud = GetBaud(speed))) {
        cfsetispeed(&t, baud);
        cfsetospeed(&t, baud);
    }
    else {
        xf86Msg(X_ERROR, "Invalid Option BaudRate value: %d\n", speed);
        return -1;
    }

    SYSCALL(r = tcsetattr(fd, TCSANOW, &t));
    return r;
}

int
xf86ReadSerial(int fd, void *buf, int count)
{
    int r;
    int i;

    SYSCALL(r = read(fd, buf, count));
    DebugF("ReadingSerial: 0x%x", (unsigned char) *(((unsigned char *) buf)));
    for (i = 1; i < r; i++)
        DebugF(", 0x%x", (unsigned char) *(((unsigned char *) buf) + i));
    DebugF("\n");
    return r;
}

int
xf86WriteSerial(int fd, const void *buf, int count)
{
    int r;
    int i;

    DebugF("WritingSerial: 0x%x", (unsigned char) *(((unsigned char *) buf)));
    for (i = 1; i < count; i++)
        DebugF(", 0x%x", (unsigned char) *(((unsigned char *) buf) + i));
    DebugF("\n");
    SYSCALL(r = write(fd, buf, count));
    return r;
}

int
xf86CloseSerial(int fd)
{
    int r;

    SYSCALL(r = close(fd));
    return r;
}

int
xf86WaitForInput(int fd, int timeout)
{
    fd_set readfds;
    struct timeval to;
    int r;

    FD_ZERO(&readfds);

    if (fd >= 0) {
        FD_SET(fd, &readfds);
    }

    to.tv_sec = timeout / 1000000;
    to.tv_usec = timeout % 1000000;

    if (fd >= 0) {
        SYSCALL(r = select(FD_SETSIZE, &readfds, NULL, NULL, &to));
    }
    else {
        SYSCALL(r = select(FD_SETSIZE, NULL, NULL, NULL, &to));
    }
    xf86ErrorFVerb(9, "select returned %d\n", r);
    return r;
}

int
xf86SerialSendBreak(int fd, int duration)
{
    int r;

    SYSCALL(r = tcsendbreak(fd, duration));
    return r;

}

int
xf86FlushInput(int fd)
{
    fd_set fds;
    struct timeval timeout;
    /* this needs to be big enough to flush an evdev event. */
    char c[256];

    DebugF("FlushingSerial\n");
    if (tcflush(fd, TCIFLUSH) == 0)
        return 0;

    timeout.tv_sec = 0;
    timeout.tv_usec = 0;
    FD_ZERO(&fds);
    FD_SET(fd, &fds);
    while (select(FD_SETSIZE, &fds, NULL, NULL, &timeout) > 0) {
        if (read(fd, &c, sizeof(c)) < 1)
            return 0;
        FD_ZERO(&fds);
        FD_SET(fd, &fds);
    }
    return 0;
}

static struct states {
    int xf;
    int os;
} modemStates[] = {
#ifdef TIOCM_LE
    {
    XF86_M_LE, TIOCM_LE},
#endif
#ifdef TIOCM_DTR
    {
    XF86_M_DTR, TIOCM_DTR},
#endif
#ifdef TIOCM_RTS
    {
    XF86_M_RTS, TIOCM_RTS},
#endif
#ifdef TIOCM_ST
    {
    XF86_M_ST, TIOCM_ST},
#endif
#ifdef TIOCM_SR
    {
    XF86_M_SR, TIOCM_SR},
#endif
#ifdef TIOCM_CTS
    {
    XF86_M_CTS, TIOCM_CTS},
#endif
#ifdef TIOCM_CAR
    {
    XF86_M_CAR, TIOCM_CAR},
#elif defined(TIOCM_CD)
    {
    XF86_M_CAR, TIOCM_CD},
#endif
#ifdef TIOCM_RNG
    {
    XF86_M_RNG, TIOCM_RNG},
#elif defined(TIOCM_RI)
    {
    XF86_M_CAR, TIOCM_RI},
#endif
#ifdef TIOCM_DSR
    {
    XF86_M_DSR, TIOCM_DSR},
#endif
};

static int numStates = sizeof(modemStates) / sizeof(modemStates[0]);

static int
xf2osState(int state)
{
    int i;
    int ret = 0;

    for (i = 0; i < numStates; i++)
        if (state & modemStates[i].xf)
            ret |= modemStates[i].os;
    return ret;
}

static int
os2xfState(int state)
{
    int i;
    int ret = 0;

    for (i = 0; i < numStates; i++)
        if (state & modemStates[i].os)
            ret |= modemStates[i].xf;
    return ret;
}

static int
getOsStateMask(void)
{
    int i;
    int ret = 0;

    for (i = 0; i < numStates; i++)
        ret |= modemStates[i].os;
    return ret;
}

static int osStateMask = 0;

int
xf86SetSerialModemState(int fd, int state)
{
    int ret;
    int s;

    if (fd < 0)
        return -1;

    /* Don't try to set parameters for non-tty devices. */
    if (!isatty(fd))
        return 0;

#ifndef TIOCMGET
    return -1;
#else
    if (!osStateMask)
        osStateMask = getOsStateMask();

    state = xf2osState(state);
    SYSCALL((ret = ioctl(fd, TIOCMGET, &s)));
    if (ret < 0)
        return -1;
    s &= ~osStateMask;
    s |= state;
    SYSCALL((ret = ioctl(fd, TIOCMSET, &s)));
    if (ret < 0)
        return -1;
    else
        return 0;
#endif
}

int
xf86GetSerialModemState(int fd)
{
    int ret;
    int s;

    if (fd < 0)
        return -1;

    /* Don't try to set parameters for non-tty devices. */
    if (!isatty(fd))
        return 0;

#ifndef TIOCMGET
    return -1;
#else
    SYSCALL((ret = ioctl(fd, TIOCMGET, &s)));
    if (ret < 0)
        return -1;
    return os2xfState(s);
#endif
}

int
xf86SerialModemSetBits(int fd, int bits)
{
    int ret;
    int s;

    if (fd < 0)
        return -1;

    /* Don't try to set parameters for non-tty devices. */
    if (!isatty(fd))
        return 0;

#ifndef TIOCMGET
    return -1;
#else
    s = xf2osState(bits);
    SYSCALL((ret = ioctl(fd, TIOCMBIS, &s)));
    return ret;
#endif
}

int
xf86SerialModemClearBits(int fd, int bits)
{
    int ret;
    int s;

    if (fd < 0)
        return -1;

    /* Don't try to set parameters for non-tty devices. */
    if (!isatty(fd))
        return 0;

#ifndef TIOCMGET
    return -1;
#else
    s = xf2osState(bits);
    SYSCALL((ret = ioctl(fd, TIOCMBIC, &s)));
    return ret;
#endif
}
@


1.10
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d64 2
a65 3

static int 
GetBaud (int baudrate)
d121 1
a121 1
    dev = xf86SetStrOption (options, "Device", NULL);
d123 1
a123 1
        xf86Msg (X_ERROR, "xf86OpenSerial: No Device specified.\n");
d126 4
d131 1
a131 1
    SYSCALL (fd = open (dev, O_RDWR | O_NONBLOCK));
d133 1
a133 1
    fd = priv_open_device (dev);
d135 1
d137 3
a139 3
        xf86Msg (X_ERROR,
                 "xf86OpenSerial: Cannot open device %s\n\t%s.\n",
                 dev, strerror (errno));
d144 1
a144 1
    if (!isatty (fd)) {
d151 3
a153 3
    SYSCALL (tcgetattr (fd, &t));
    t.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR
                   |IGNCR|ICRNL|IXON);
d155 6
a160 6
    t.c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
    t.c_cflag &= ~(CSIZE|PARENB);
    t.c_cflag |= CS8|CLOCAL;
    
    cfsetispeed (&t, B9600);
    cfsetospeed (&t, B9600);
d164 1
a164 1
    SYSCALL (tcsetattr (fd, TCSANOW, &t));
d166 2
a167 2
    if (xf86SetSerial (fd, options) == -1) {
        SYSCALL (close (fd));
d172 1
a172 1
    SYSCALL (i = fcntl (fd, F_GETFL, 0));
d174 1
a174 1
        SYSCALL (close (fd));
d179 1
a179 1
    SYSCALL (i = fcntl (fd, F_SETFL, i));
d181 1
a181 1
        SYSCALL (close (fd));
@


1.9
log
@Fix bad merge that changed an fcntl() into a priv_open_device().
Should fix mouse re-open after VT-switch
@
text
@d65 2
a66 2
static int
GetBaud(int baudrate)
d122 1
a122 1
    dev = xf86SetStrOption(options, "Device", NULL);
d124 1
a124 1
        xf86Msg(X_ERROR, "xf86OpenSerial: No Device specified.\n");
a126 1

d128 1
a128 1
    SYSCALL(fd = open(dev, O_RDWR | O_NONBLOCK));
d133 3
a135 3
        xf86Msg(X_ERROR,
                "xf86OpenSerial: Cannot open device %s\n\t%s.\n",
                dev, strerror(errno));
d140 1
a140 1
    if (!isatty(fd)) {
d147 3
a149 3
    SYSCALL(tcgetattr(fd, &t));
    t.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR
                   | IGNCR | ICRNL | IXON);
d151 6
a156 6
    t.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
    t.c_cflag &= ~(CSIZE | PARENB);
    t.c_cflag |= CS8 | CLOCAL;

    cfsetispeed(&t, B9600);
    cfsetospeed(&t, B9600);
d160 1
a160 1
    SYSCALL(tcsetattr(fd, TCSANOW, &t));
d162 2
a163 2
    if (xf86SetSerial(fd, options) == -1) {
        SYSCALL(close(fd));
d168 1
a168 1
    SYSCALL(i = fcntl(fd, F_GETFL, 0));
d170 1
a170 1
        SYSCALL(close(fd));
d175 1
a175 1
    SYSCALL(i = fcntl(fd, F_SETFL, i));
d177 1
a177 1
        SYSCALL(close(fd));
d428 2
a429 1
    char c[4];
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d131 1
a131 1
        fd = priv_open_device (dev);
a168 1
#ifndef X_PRIVSEP
a169 3
#else
    fd = priv_open_device (dev);
#endif
@


1.7
log
@Update to xserver 1.11.2
@
text
@a63 3
#ifdef X_PRIVSEP
extern int priv_open_device(const char *);
#endif
d65 2
a66 2
static int 
GetBaud (int baudrate)
d69 2
a70 2
	if (baudrate == 300)
		return B300;
d73 2
a74 2
	if (baudrate == 1200)
		return B1200;
d77 2
a78 2
	if (baudrate == 2400)
		return B2400;
d81 2
a82 2
	if (baudrate == 4800)
		return B4800;
d85 2
a86 2
	if (baudrate == 9600)
		return B9600;
d89 2
a90 2
	if (baudrate == 19200)
		return B19200;
d93 2
a94 2
	if (baudrate == 38400)
		return B38400;
d97 2
a98 2
	if (baudrate == 57600)
		return B57600;
d101 2
a102 2
	if (baudrate == 115200)
		return B115200;
d105 2
a106 2
	if (baudrate == 230400)
		return B230400;
d109 2
a110 2
	if (baudrate == 460800)
		return B460800;
d112 1
a112 1
	return 0;
d116 1
a116 1
xf86OpenSerial (pointer options)
d118 50
a167 3
	struct termios t;
	int fd, i;
	char *dev;
a168 6
	dev = xf86SetStrOption (options, "Device", NULL);
	if (!dev)
	{
		xf86Msg (X_ERROR, "xf86OpenSerial: No Device specified.\n");
		return -1;
	}
d170 1
a170 1
	SYSCALL (fd = open (dev, O_RDWR | O_NONBLOCK));
d172 1
a172 1
	fd = priv_open_device (dev);
d174 127
a300 194
	if (fd == -1)
	{
		xf86Msg (X_ERROR,
			 "xf86OpenSerial: Cannot open device %s\n\t%s.\n",
			 dev, strerror (errno));
		free(dev);
		return -1;
	}

	if (!isatty (fd))
	{
		/* Allow non-tty devices to be opened. */
		free(dev);
		return fd;
	}

	/* set up default port parameters */
	SYSCALL (tcgetattr (fd, &t));
	t.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR\
						|IGNCR|ICRNL|IXON);
	t.c_oflag &= ~OPOST;
	t.c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
	t.c_cflag &= ~(CSIZE|PARENB);
	t.c_cflag |= CS8|CLOCAL;

	cfsetispeed (&t, B9600);
	cfsetospeed (&t, B9600);
	t.c_cc[VMIN] = 1;
	t.c_cc[VTIME] = 0;

	SYSCALL (tcsetattr (fd, TCSANOW, &t));

	if (xf86SetSerial (fd, options) == -1)
	{
		SYSCALL (close (fd));
		free(dev);
		return -1;
	}

	SYSCALL (i = fcntl (fd, F_GETFL, 0));
	if (i == -1)
	{
		SYSCALL (close (fd));
		free(dev);
		return -1;
	}
	i &= ~O_NONBLOCK;
	SYSCALL (i = fcntl (fd, F_SETFL, i));
	if (i == -1)
	{
		SYSCALL (close (fd));
		free(dev);
		return -1;
	}
	free(dev);
	return fd;
}

int
xf86SetSerial (int fd, pointer options)
{
	struct termios t;
	int val;
	const char *s;
	int baud, r;

	if (fd < 0)
		return -1;

	/* Don't try to set parameters for non-tty devices. */
	if (!isatty(fd))
		return 0;

	SYSCALL (tcgetattr (fd, &t));

	if ((val = xf86SetIntOption (options, "BaudRate", 0)))
	{
		if ((baud = GetBaud (val)))
		{
			cfsetispeed (&t, baud);
			cfsetospeed (&t, baud);
		}
		else
		{
			xf86Msg (X_ERROR,
				 "Invalid Option BaudRate value: %d\n", val);
			return -1;
		}
	}

	if ((val = xf86SetIntOption (options, "StopBits", 0)))
	{
		switch (val)
		{
		case 1:
			t.c_cflag &= ~(CSTOPB);
			break;
		case 2:
			t.c_cflag |= CSTOPB;
			break;
		default:
			xf86Msg (X_ERROR,
				 "Invalid Option StopBits value: %d\n", val);
			return -1;
			break;
		}
	}

	if ((val = xf86SetIntOption (options, "DataBits", 0)))
	{
		switch (val)
		{
		case 5:
			t.c_cflag &= ~(CSIZE);
			t.c_cflag |= CS5;
			break;
		case 6:
			t.c_cflag &= ~(CSIZE);
			t.c_cflag |= CS6;
			break;
		case 7:
			t.c_cflag &= ~(CSIZE);
			t.c_cflag |= CS7;
			break;
		case 8:
			t.c_cflag &= ~(CSIZE);
			t.c_cflag |= CS8;
			break;
		default:
			xf86Msg (X_ERROR,
				 "Invalid Option DataBits value: %d\n", val);
			return -1;
			break;
		}
	}

	if ((s = xf86SetStrOption (options, "Parity", NULL)))
	{
		if (xf86NameCmp (s, "Odd") == 0)
		{
			t.c_cflag |= PARENB | PARODD;
		}
		else if (xf86NameCmp (s, "Even") == 0)
		{
			t.c_cflag |= PARENB;
			t.c_cflag &= ~(PARODD);
		}
		else if (xf86NameCmp (s, "None") == 0)
		{
			t.c_cflag &= ~(PARENB);
		}
		else
		{
			xf86Msg (X_ERROR, "Invalid Option Parity value: %s\n",
				 s);
			return -1;
		}
	}

	if ((val = xf86SetIntOption (options, "Vmin", -1)) != -1)
	{
		t.c_cc[VMIN] = val;
	}
	if ((val = xf86SetIntOption (options, "Vtime", -1)) != -1)
	{
		t.c_cc[VTIME] = val;
	}

	if ((s = xf86SetStrOption (options, "FlowControl", NULL)))
	{
		xf86MarkOptionUsedByName (options, "FlowControl");
		if (xf86NameCmp (s, "Xoff") == 0)
		{
			t.c_iflag |= IXOFF;
		}
		else if (xf86NameCmp (s, "Xon") == 0)
		{
			t.c_iflag |= IXON;
		}
		else if (xf86NameCmp (s, "XonXoff") == 0)
		{
			t.c_iflag |= IXON|IXOFF;
		}
		else if (xf86NameCmp (s, "None") == 0)
		{
			t.c_iflag &= ~(IXON | IXOFF);
		}
		else
		{
			xf86Msg (X_ERROR,
				 "Invalid Option FlowControl value: %s\n", s);
			return -1;
		}
	}
d302 1
a302 2
	if ((xf86SetBoolOption (options, "ClearDTR", FALSE)))
	{
d304 6
a309 6
# if defined(TIOCMBIC)
		val = TIOCM_DTR;
		SYSCALL (ioctl(fd, TIOCMBIC, &val));
# else
		SYSCALL (ioctl(fd, TIOCCDTR, NULL));
# endif
d311 2
a312 3
		xf86Msg (X_WARNING,
			 "Option ClearDTR not supported on this OS\n");
			return -1;
d314 2
a315 2
		xf86MarkOptionUsedByName (options, "ClearDTR");
	}
d317 5
a321 7
	if ((xf86SetBoolOption (options, "ClearRTS", FALSE)))
	{
		xf86Msg (X_WARNING,
			 "Option ClearRTS not supported on this OS\n");
			return -1;
		xf86MarkOptionUsedByName (options, "ClearRTS");
	}
d323 2
a324 2
	SYSCALL (r = tcsetattr (fd, TCSANOW, &t));
	return r;
d328 1
a328 1
xf86SetSerialSpeed (int fd, int speed)
d330 2
a331 2
	struct termios t;
	int baud, r;
d333 2
a334 2
	if (fd < 0)
		return -1;
d336 3
a338 3
	/* Don't try to set parameters for non-tty devices. */
	if (!isatty(fd))
		return 0;
d340 1
a340 1
	SYSCALL (tcgetattr (fd, &t));
d342 8
a349 11
	if ((baud = GetBaud (speed)))
	{
		cfsetispeed (&t, baud);
		cfsetospeed (&t, baud);
	}
	else
	{
		xf86Msg (X_ERROR,
			 "Invalid Option BaudRate value: %d\n", speed);
		return -1;
	}
d351 2
a352 2
	SYSCALL (r = tcsetattr (fd, TCSANOW, &t));
	return r;
d356 1
a356 1
xf86ReadSerial (int fd, void *buf, int count)
d358 2
a359 2
	int r;
	int i;
d361 6
a366 7
	SYSCALL (r = read (fd, buf, count));
	DebugF("ReadingSerial: 0x%x",
	       (unsigned char)*(((unsigned char *)buf)));
	for (i = 1; i < r; i++)
	    DebugF(", 0x%x",(unsigned char)*(((unsigned char *)buf) + i));
	DebugF("\n");
	return r;
d370 1
a370 1
xf86WriteSerial (int fd, const void *buf, int count)
d372 2
a373 2
	int r;
	int i;
d375 6
a380 6
	DebugF("WritingSerial: 0x%x",(unsigned char)*(((unsigned char *)buf)));
	for (i = 1; i < count; i++)
	    DebugF(", 0x%x",(unsigned char)*(((unsigned char *)buf) + i));
	DebugF("\n");
	SYSCALL (r = write (fd, buf, count));
	return r;
d384 1
a384 1
xf86CloseSerial (int fd)
d386 1
a386 1
	int r;
d388 2
a389 2
	SYSCALL (r = close (fd));
	return r;
d393 1
a393 1
xf86WaitForInput (int fd, int timeout)
d395 3
a397 3
	fd_set readfds;
	struct timeval to;
	int r;
d399 1
a399 1
	FD_ZERO(&readfds);
d401 3
a403 6
	if (fd >= 0) {
	    FD_SET(fd, &readfds);
	}
	
	to.tv_sec = timeout / 1000000;
	to.tv_usec = timeout % 1000000;
d405 11
a415 8
	if (fd >= 0) {
	    SYSCALL (r = select (FD_SETSIZE, &readfds, NULL, NULL, &to));
	}
	else {
	    SYSCALL (r = select (FD_SETSIZE, NULL, NULL, NULL, &to));
	}
	xf86ErrorFVerb (9,"select returned %d\n", r);
	return r;
d419 1
a419 1
xf86SerialSendBreak (int fd, int duration)
d421 4
a424 1
	int r;
a425 3
	SYSCALL (r = tcsendbreak (fd, duration));
	return r;
	
d431 19
a449 19
	fd_set fds;
	struct timeval timeout;
	char c[4];

	DebugF("FlushingSerial\n");
	if (tcflush(fd, TCIFLUSH) == 0)
		return 0;

	timeout.tv_sec = 0;
	timeout.tv_usec = 0;
	FD_ZERO(&fds);
	FD_SET(fd, &fds);
	while (select(FD_SETSIZE, &fds, NULL, NULL, &timeout) > 0) {
		if (read(fd, &c, sizeof(c)) < 1)
		    return 0;
		FD_ZERO(&fds);
		FD_SET(fd, &fds);
	}
	return 0;
d453 2
a454 2
	int xf;
	int os;
d457 2
a458 1
	{ XF86_M_LE, TIOCM_LE },
d461 2
a462 1
	{ XF86_M_DTR, TIOCM_DTR },
d465 2
a466 1
	{ XF86_M_RTS, TIOCM_RTS },
d469 2
a470 1
	{ XF86_M_ST, TIOCM_ST },
d473 2
a474 1
	{ XF86_M_SR, TIOCM_SR },
d477 2
a478 1
	{ XF86_M_CTS, TIOCM_CTS },
d481 2
a482 1
	{ XF86_M_CAR, TIOCM_CAR },
d484 2
a485 1
	{ XF86_M_CAR, TIOCM_CD },
d488 2
a489 1
	{ XF86_M_RNG, TIOCM_RNG },
d491 2
a492 1
	{ XF86_M_CAR, TIOCM_RI },
d495 2
a496 1
	{ XF86_M_DSR, TIOCM_DSR },
d505 2
a506 2
	int i;
	int ret = 0;
d508 4
a511 4
	for (i = 0; i < numStates; i++)
		if (state & modemStates[i].xf)
			ret |= modemStates[i].os;
	return ret;
d517 2
a518 2
	int i;
	int ret = 0;
d520 4
a523 4
	for (i = 0; i < numStates; i++)
		if (state & modemStates[i].os)
			ret |= modemStates[i].xf;
	return ret;
d529 6
a534 5
	int i;
	int ret = 0;
	for (i = 0; i < numStates; i++)
		ret |= modemStates[i].os;
	return ret;
d542 2
a543 2
	int ret;
	int s;
d545 2
a546 2
	if (fd < 0)
		return -1;
d548 3
a550 3
	/* Don't try to set parameters for non-tty devices. */
	if (!isatty(fd))
		return 0;
d553 1
a553 1
	return -1;
d555 2
a556 2
	if (!osStateMask)
		osStateMask = getOsStateMask();
d558 11
a568 11
	state = xf2osState(state);
	SYSCALL((ret = ioctl(fd, TIOCMGET, &s)));
	if (ret < 0)
		return -1;
	s &= ~osStateMask;
	s |= state;
	SYSCALL((ret = ioctl(fd, TIOCMSET, &s)));
	if (ret < 0)
		return -1;
	else
		return 0;
d575 2
a576 2
	int ret;
	int s;
d578 2
a579 2
	if (fd < 0)
		return -1;
d581 3
a583 3
	/* Don't try to set parameters for non-tty devices. */
	if (!isatty(fd))
		return 0;
d586 1
a586 1
	return -1;
d588 4
a591 4
	SYSCALL((ret = ioctl(fd, TIOCMGET, &s)));
	if (ret < 0)
		return -1;
	return os2xfState(s);
d598 2
a599 2
	int ret;
	int s;
d601 2
a602 2
	if (fd < 0)
		return -1;
d604 3
a606 3
	/* Don't try to set parameters for non-tty devices. */
	if (!isatty(fd))
		return 0;
d609 1
a609 1
	return -1;
d611 3
a613 3
	s = xf2osState(bits);
	SYSCALL((ret = ioctl(fd, TIOCMBIS, &s)));
	return ret;
d620 2
a621 2
	int ret;
	int s;
d623 2
a624 2
	if (fd < 0)
		return -1;
d626 3
a628 3
	/* Don't try to set parameters for non-tty devices. */
	if (!isatty(fd))
		return 0;
d631 1
a631 1
	return -1;
d633 3
a635 3
	s = xf2osState(bits);
	SYSCALL((ret = ioctl(fd, TIOCMBIC, &s)));
	return ret;
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d414 1
a414 1
	    ErrorF(", 0x%x",(unsigned char)*(((unsigned char *)buf) + i));
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d115 1
a115 1
	return (0);
d129 1
a129 1
		return (-1);
d141 2
a142 2
		xfree(dev);
		return (-1);
d148 2
a149 2
		xfree(dev);
		return (fd);
d171 2
a172 2
		xfree(dev);
		return (-1);
d179 2
a180 2
		xfree(dev);
		return (-1);
d187 2
a188 2
		xfree(dev);
		return (-1);
d190 2
a191 2
	xfree(dev);
	return (fd);
d222 1
a222 1
			return (-1);
d239 1
a239 1
			return (-1);
d267 1
a267 1
			return (-1);
d291 1
a291 1
			return (-1);
d327 1
a327 1
			return (-1);
d343 1
a343 1
			return (-1);
a349 4
#ifdef CLEARRTS_SUPPORT
		val = TIOCM_RTS;
		SYSCALL (ioctl(fd, TIOCMBIC, &val));
#else
d352 1
a352 2
			return (-1);
#endif
d357 1
a357 1
	return (r);
d384 1
a384 1
		return (-1);
d388 1
a388 1
	return (r);
d403 1
a403 1
	return (r);
d417 1
a417 1
	return (r);
d426 1
a426 1
	return (r);
d452 1
a452 1
	return (r);
d461 1
a461 1
	return (r);
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d118 1
a118 1
_X_EXPORT int
a146 1
#if 1
a149 9
#else
		xf86Msg (X_WARNING,
			 "xf86OpenSerial: Specified device %s is not a tty\n",
			 dev);
		SYSCALL (close (fd));
		errno = EINVAL;
		xfree(dev);
		return (-1);
#endif
d194 1
a194 1
_X_EXPORT int
d365 1
a365 1
_X_EXPORT int
d396 1
a396 1
_X_EXPORT int
a399 1
#ifdef DEBUG
d401 1
a401 1
#endif
d403 1
a403 2
#ifdef DEBUG
	ErrorF("ReadingSerial: 0x%x",
d406 2
a407 3
	    ErrorF(", 0x%x",(unsigned char)*(((unsigned char *)buf) + i));
	ErrorF("\n");
#endif
d411 1
a411 1
_X_EXPORT int
a414 1
#ifdef DEBUG
d417 1
a417 1
	ErrorF("WritingSerial: 0x%x",(unsigned char)*(((unsigned char *)buf)));
d420 1
a420 2
	ErrorF("\n");
#endif
d425 1
a425 1
_X_EXPORT int
d434 1
a434 1
_X_EXPORT int
d460 1
a460 1
_X_EXPORT int
d470 1
a470 1
_X_EXPORT int
d477 1
a477 3
#ifdef DEBUG
	ErrorF("FlushingSerial\n");
#endif
d569 1
a569 1
_X_EXPORT int
d602 1
a602 1
_X_EXPORT int
d625 1
a625 1
_X_EXPORT int
d647 1
a647 1
_X_EXPORT int
@


1.3
log
@merge xserver 1.4, 1st pass
@
text
@a120 3
#ifdef Lynx
	struct sgttyb ms_sgtty;
#endif
a161 6
#ifdef Lynx
	/* LynxOS does not assert DTR without this */
	ioctl (fd, TIOCGETP, (char *) &ms_sgtty);
	ioctl (fd, TIOCSDTR, (char *) &ms_sgtty);
#endif

d344 1
a344 1
# if !defined(Lynx) || defined(TIOCMBIC)
@


1.2
log
@OpenBSD local modifications:
- privilege separation
- some snprintf/strlc{at,py} conversions
- support for more architectures
- signal handler fixes
- default mouse wheel support in config tools
- sunmouse protocol
@
text
@a54 2
/* $XConsortium: posix_tty.c /main/7 1996/10/19 18:07:47 kaleb $ */

@


1.1
log
@Initial revision
@
text
@d66 4
d136 1
a136 1

d138 3
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d55 2
@

