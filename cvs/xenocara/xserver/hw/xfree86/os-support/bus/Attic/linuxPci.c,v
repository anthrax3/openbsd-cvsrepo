head	1.6;
access;
symbols
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.06.10.13.21.25;	author matthieu;	state dead;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.27;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.21;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.21;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.28;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@/*
 * Copyright 1998 by Concurrent Computer Corporation
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Concurrent Computer
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior
 * permission.  Concurrent Computer Corporation makes no representations
 * about the suitability of this software for any purpose.  It is
 * provided "as is" without express or implied warranty.
 *
 * CONCURRENT COMPUTER CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD
 * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CONCURRENT COMPUTER CORPORATION BE
 * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 *
 * Copyright 1998 by Metro Link Incorporated
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Metro Link
 * Incorporated not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior
 * permission.  Metro Link Incorporated makes no representations
 * about the suitability of this software for any purpose.  It is
 * provided "as is" without express or implied warranty.
 *
 * METRO LINK INCORPORATED DISCLAIMS ALL WARRANTIES WITH REGARD
 * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL METRO LINK INCORPORATED BE
 * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <stdio.h>
#include "xf86_OSlib.h"
#include "Pci.h"

static const struct pci_id_match match_host_bridge = {
    PCI_MATCH_ANY, PCI_MATCH_ANY, PCI_MATCH_ANY, PCI_MATCH_ANY,
    (PCI_CLASS_BRIDGE << 16) | (PCI_SUBCLASS_BRIDGE_HOST << 8),
    0x0000ffff00, 0
};

#define MAX_DOMAINS 257
static pointer DomainMmappedIO[MAX_DOMAINS];

void
linuxPciInit(void)
{
    memset(DomainMmappedIO, 0, sizeof(DomainMmappedIO));
}

/**
 * \bug
 * The generation of the procfs file name for the domain != 0 case may not be 
 * correct.
 */
static int
linuxPciOpenFile(struct pci_device *dev, Bool write)
{
    static struct pci_device *last_dev = NULL;
    static int	fd = -1,is_write = 0;
    char		file[64];
    struct stat	ignored;
    static int is26 = -1;

    if (dev == NULL) {
	return -1;
    }

    if (is26 == -1) {
	is26 = (stat("/sys/bus/pci", &ignored) < 0) ? 0 : 1;
    }
	
    if (fd == -1 || (write && (!is_write)) || (last_dev != dev)) {
	if (fd != -1) {
	    close(fd);
	    fd = -1;
	}

	if (is26) {
	    sprintf(file,"/sys/bus/pci/devices/%04u:%02x:%02x.%01x/config",
		    dev->domain, dev->bus, dev->dev, dev->func);
	} else {
	    if (dev->domain == 0) {
		sprintf(file,"/proc/bus/pci/%02x", dev->bus);
		if (stat(file, &ignored) < 0) {
		    sprintf(file, "/proc/bus/pci/0000:%02x/%02x.%1x",
			    dev->bus, dev->dev, dev->func);
		} else {
		    sprintf(file, "/proc/bus/pci/%02x/%02x.%1x",
			    dev->bus, dev->dev, dev->func);
		}
	    } else {
		sprintf(file,"/proc/bus/pci/%02x%02x", dev->domain, dev->bus);
		if (stat(file, &ignored) < 0) {
		    sprintf(file, "/proc/bus/pci/%04x:%04x/%02x.%1x",
			    dev->domain, dev->bus, dev->dev, dev->func);
		} else {
		    sprintf(file, "/proc/bus/pci/%02x%02x/%02x.%1x",
			    dev->domain, dev->bus, dev->dev, dev->func);
		}
	    }
	}

	if (write) {
	    fd = open(file,O_RDWR);
	    if (fd != -1) is_write = TRUE;
	} else {
	    switch (is_write) {
	    case TRUE:
		fd = open(file,O_RDWR);
		if (fd > -1)
		    break;
	    default:
		fd = open(file,O_RDONLY);
		is_write = FALSE;
	    }
	}

	last_dev = dev;
    }

    return fd;
}

/*
 * Compiling the following simply requires the presence of <linux/pci.c>.
 * Actually running this is another matter altogether...
 *
 * This scheme requires that the kernel allow mmap()'ing of a host bridge's I/O
 * and memory spaces through its /proc/bus/pci/BUS/DFN entry.  Which one is
 * determined by a prior ioctl().
 *
 * For the sparc64 port, this means 2.4.12 or later.  For ppc, this
 * functionality is almost, but not quite there yet.  Alpha and other kernel
 * ports to multi-domain architectures still need to implement this.
 *
 * This scheme is also predicated on the use of an IOADDRESS compatible type to
 * designate I/O addresses.  Although IOADDRESS is defined as an unsigned
 * integral type, it is actually the virtual address of, i.e. a pointer to, the
 * I/O port to access.  And so, the inX/outX macros in "compiler.h" need to be
 * #define'd appropriately (as is done on SPARC's).
 *
 * Another requirement to port this scheme to another multi-domain architecture
 * is to add the appropriate entries in the pciControllerSizes array below.
 *
 * TO DO:  Address the deleterious reaction some host bridges have to master
 *         aborts.  This is already done for secondary PCI buses, but not yet
 *         for accesses to primary buses (except for the SPARC port, where
 *         master aborts are avoided during PCI scans).
 */

#include <linux/pci.h>

#ifndef PCIIOC_BASE		/* Ioctls for /proc/bus/pci/X/Y nodes. */
#define PCIIOC_BASE		('P' << 24 | 'C' << 16 | 'I' << 8)

/* Get controller for PCI device. */
#define PCIIOC_CONTROLLER	(PCIIOC_BASE | 0x00)
/* Set mmap state to I/O space. */
#define PCIIOC_MMAP_IS_IO	(PCIIOC_BASE | 0x01)
/* Set mmap state to MEM space. */
#define PCIIOC_MMAP_IS_MEM	(PCIIOC_BASE | 0x02)
/* Enable/disable write-combining. */
#define PCIIOC_WRITE_COMBINE	(PCIIOC_BASE | 0x03)

#endif

/* This probably shouldn't be Linux-specific */
static struct pci_device *
get_parent_bridge(struct pci_device *dev)
{
    struct pci_id_match bridge_match = {
	PCI_MATCH_ANY, PCI_MATCH_ANY, PCI_MATCH_ANY, PCI_MATCH_ANY,
	(PCI_CLASS_BRIDGE << 16) | (PCI_SUBCLASS_BRIDGE_PCI << 8),
	0
    };
    struct pci_device *bridge;
    struct pci_device_iterator *iter;

    if (dev == NULL) {
	return NULL;
    }

    iter = pci_id_match_iterator_create(& bridge_match);
    if (iter == NULL) {
	return NULL;
    }

    while ((bridge = pci_device_next(iter)) != NULL) {
	if (bridge->domain == dev->domain) {
	    const struct pci_bridge_info *info = 
		pci_device_get_bridge_info(bridge);

	    if (info != NULL) {
		if (info->secondary_bus == dev->bus) {
		    break;
		}
	    }
	}
    }

    pci_iterator_destroy(iter);

    return bridge;
}

/*
 * This is ugly, but until I can extract this information from the kernel,
 * it'll have to do.  The default I/O space size is 64K, and 4G for memory.
 * Anything else needs to go in this table.  (PowerPC folk take note.)
 *
 * Note that Linux/SPARC userland is 32-bit, so 4G overflows to zero here.
 *
 * Please keep this table in ascending vendor/device order.
 */
static const struct pciSizes {
    unsigned short vendor, device;
    unsigned long io_size, mem_size;
} pciControllerSizes[] = {
    {
	PCI_VENDOR_SUN, PCI_CHIP_PSYCHO,
	1U << 16, 1U << 31
    },
    {
	PCI_VENDOR_SUN, PCI_CHIP_SCHIZO,
	1U << 24, 1U << 31	/* ??? */
    },
    {
	PCI_VENDOR_SUN, PCI_CHIP_SABRE,
	1U << 24, (unsigned long)(1ULL << 32)
    },
    {
	PCI_VENDOR_SUN, PCI_CHIP_HUMMINGBIRD,
	1U << 24, (unsigned long)(1ULL << 32)
    }
};
#define NUM_SIZES (sizeof(pciControllerSizes) / sizeof(pciControllerSizes[0]))

static const struct pciSizes *
linuxGetSizesStruct(const struct pci_device *dev)
{
    static const struct pciSizes default_size = {
	0, 0, 1U << 16, (unsigned long)(1ULL << 32)
    };
    int          i;

    /* Look up vendor/device */
    if (dev != NULL) {
	for (i = 0;  i < NUM_SIZES;  i++) {
	    if ((dev->vendor_id == pciControllerSizes[i].vendor)
		&& (dev->device_id == pciControllerSizes[i].device)) {
		return & pciControllerSizes[i];
	    }
	}
    }

    /* Default to 64KB I/O and 4GB memory. */
    return & default_size;
}

static __inline__ unsigned long
linuxGetIOSize(const struct pci_device *dev)
{
    const struct pciSizes * const sizes = linuxGetSizesStruct(dev);
    return sizes->io_size;
}

static pointer
linuxMapPci(int ScreenNum, int Flags, struct pci_device *dev,
	    ADDRESS Base, unsigned long Size, int mmap_ioctl)
{
    /* Align to page boundary */
    const ADDRESS realBase = Base & ~(getpagesize() - 1);
    const ADDRESS Offset = Base - realBase;

    do {
	unsigned char *result;
	int fd, mmapflags, prot;

	xf86InitVidMem();

	/* If dev is NULL, linuxPciOpenFile will return -1, and this routine
	 * will fail gracefully.
	 */
        prot = ((Flags & VIDMEM_READONLY) == 0);
        if (((fd = linuxPciOpenFile(dev, prot)) < 0) ||
	    (ioctl(fd, mmap_ioctl, 0) < 0))
	    break;

/* Note:  IA-64 doesn't compile this and doesn't need to */
#ifdef __ia64__

# ifndef  MAP_WRITECOMBINED
#  define MAP_WRITECOMBINED 0x00010000
# endif
# ifndef  MAP_NONCACHED
#  define MAP_NONCACHED     0x00020000
# endif

	if (Flags & VIDMEM_FRAMEBUFFER)
	    mmapflags = MAP_SHARED | MAP_WRITECOMBINED;
	else
	    mmapflags = MAP_SHARED | MAP_NONCACHED;

#else /* !__ia64__ */

	mmapflags = (Flags & VIDMEM_FRAMEBUFFER) / VIDMEM_FRAMEBUFFER;

	if (ioctl(fd, PCIIOC_WRITE_COMBINE, mmapflags) < 0)
	    break;

	mmapflags = MAP_SHARED;

#endif /* ?__ia64__ */


	if (Flags & VIDMEM_READONLY)
	    prot = PROT_READ;
	else
	    prot = PROT_READ | PROT_WRITE;

	result = mmap(NULL, Size + Offset, prot, mmapflags, fd, realBase);

	if (!result || ((pointer)result == MAP_FAILED))
	    return NULL;

	xf86MakeNewMapping(ScreenNum, Flags, realBase, Size + Offset, result);

	return result + Offset;
    } while (0);

    if (mmap_ioctl == PCIIOC_MMAP_IS_MEM)
	return xf86MapVidMem(ScreenNum, Flags, Base, Size);

    return NULL;
}

static int
linuxOpenLegacy(struct pci_device *dev, char *name)
{
    static const char PREFIX[] = "/sys/class/pci_bus/%04x:%02x/%s";
    char path[sizeof(PREFIX) + 10];
    int fd = -1;

    while (dev != NULL) {
	snprintf(path, sizeof(path) - 1, PREFIX, dev->domain, dev->bus, name);
	fd = open(path, O_RDWR);
	if (fd >= 0) {
	    return fd;
	}

	dev = get_parent_bridge(dev);
    }

    return fd;
}

/*
 * xf86MapDomainMemory - memory map PCI domain memory
 *
 * This routine maps the memory region in the domain specified by Tag and
 * returns a pointer to it.  The pointer is saved for future use if it's in
 * the legacy ISA memory space (memory in a domain between 0 and 1MB).
 */
pointer
xf86MapDomainMemory(int ScreenNum, int Flags, struct pci_device *dev,
		    ADDRESS Base, unsigned long Size)
{
    int fd = -1;
    pointer addr;

    /*
     * We use /proc/bus/pci on non-legacy addresses or if the Linux sysfs
     * legacy_mem interface is unavailable.
     */
    if ((Base > 1024*1024) || ((fd = linuxOpenLegacy(dev, "legacy_mem")) < 0))
	return linuxMapPci(ScreenNum, Flags, dev, Base, Size,
			   PCIIOC_MMAP_IS_MEM);
    else
	addr = mmap(NULL, Size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, Base);

    if (fd >= 0)
	close(fd);
    if (addr == NULL || addr == MAP_FAILED) {
	perror("mmap failure");
	FatalError("xf86MapDomainMem():  mmap() failure\n");
    }
    return addr;
}

/**
 * Map I/O space in this domain
 *
 * Each domain has a legacy ISA I/O space.  This routine will try to
 * map it using the Linux sysfs legacy_io interface.  If that fails,
 * it'll fall back to using /proc/bus/pci.
 *
 * If the legacy_io interface \b does exist, the file descriptor (\c fd below)
 * will be saved in the \c DomainMmappedIO array in the upper bits of the
 * pointer.  Callers will do I/O with small port numbers (<64k values), so
 * the platform I/O code can extract the port number and the \c fd, \c lseek
 * to the port number in the legacy_io file, and issue the read or write.
 *
 * This has no means of returning failure, so all errors are fatal
 */
IOADDRESS
xf86MapLegacyIO(struct pci_device *dev)
{
    const int domain = dev->domain;
    struct pci_device *bridge = get_parent_bridge(dev);
    int fd;

    if (domain >= MAX_DOMAINS)
	FatalError("xf86MapLegacyIO():  domain out of range\n");

    if (DomainMmappedIO[domain] == NULL) {
	/* Permanently map all of I/O space */
	fd = linuxOpenLegacy(bridge, "legacy_io");
	if (fd < 0) {
	    DomainMmappedIO[domain] = linuxMapPci(-1, VIDMEM_MMIO, bridge,
						  0, linuxGetIOSize(bridge),
						  PCIIOC_MMAP_IS_IO);
	}
	else { /* legacy_io file exists, encode fd */
	    DomainMmappedIO[domain] = (pointer)(intptr_t)(fd << 24);
	}
    }

    return (IOADDRESS)DomainMmappedIO[domain];
}

@


1.5
log
@Update to xserver 1.11.2
@
text
@@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a51 3
#include "compiler.h"
#include "xf86.h"
#include "xf86Priv.h"
a53 1
#include <dirent.h>
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a58 23
/*
 * linux platform specific PCI access functions -- using /proc/bus/pci
 * needs kernel version 2.2.x
 */
static ADDRESS linuxTransAddrBusToHost(PCITAG tag, PciAddrType type, ADDRESS addr);
#if defined(__powerpc__)
static ADDRESS linuxPpcBusAddrToHostAddr(PCITAG, PciAddrType, ADDRESS);
#endif

static pciBusFuncs_t linuxFuncs0 = {
#if defined(__powerpc__)
/* pciAddrBusToHost */	linuxPpcBusAddrToHostAddr,
#else
/* linuxTransAddrBusToHost is busted on sparc64 but the PCI rework tree
 * makes it all moot, so we kludge it for now */
#if defined(__sparc__)
/* pciAddrBusToHost */  pciAddrNOOP,
#else
/* pciAddrBusToHost */	linuxTransAddrBusToHost,
#endif /* __sparc64__ */
#endif
};

a70 2
    struct stat st;

a71 7

    if (-1 == stat("/proc/bus/pci", &st)) {
	/* when using this as default for all linux architectures,
	   we'll need a fallback for 2.0 kernels here */
	return;
    }
    pciBusFuncs	   = &linuxFuncs0;
a148 47
 * This function will convert a BAR address into a host address
 * suitable for passing into the mmap function of a /proc/bus
 * device.
 */
ADDRESS linuxTransAddrBusToHost(PCITAG tag, PciAddrType type, ADDRESS addr)
{
    ADDRESS ret = xf86GetOSOffsetFromPCI(tag, PCI_MEM|PCI_IO, addr);

    if (ret)
	return ret;

    /*
     * if it is not a BAR address, it must be legacy, (or wrong)
     * return it as is..
     */
    return addr;
}


#if defined(__powerpc__)

#ifndef __NR_pciconfig_iobase
#define __NR_pciconfig_iobase   200
#endif

static ADDRESS
linuxPpcBusAddrToHostAddr(PCITAG tag, PciAddrType type, ADDRESS addr)
{
    if (type == PCI_MEM)
    {
	ADDRESS membase = syscall(__NR_pciconfig_iobase, 1,
		    PCI_BUS_FROM_TAG(tag), PCI_DFN_FROM_TAG(tag));
	return (addr + membase);
    }
    else if (type == PCI_IO)
    {
	ADDRESS iobase = syscall(__NR_pciconfig_iobase, 2,
		    PCI_BUS_FROM_TAG(tag), PCI_DFN_FROM_TAG(tag));
	return (addr + iobase);
    }
    else return addr;
}

#endif /* __powerpc__ */


/*
d388 1
a388 1
_X_EXPORT pointer
d448 1
a448 1
	    DomainMmappedIO[domain] = (pointer)(fd << 24);
a452 55
}

resPtr
xf86AccResFromOS(resPtr pRes)
{
    struct pci_device *dev;
    struct pci_device_iterator *iter;
    resRange      range;

    iter = pci_id_match_iterator_create(& match_host_bridge);
    while ((dev = pci_device_next(iter)) != NULL) {
	const int domain = dev->domain;
	const struct pciSizes * const sizes = linuxGetSizesStruct(dev);

	/*
	 * At minimum, the top and bottom resources must be claimed, so
	 * that resources that are (or appear to be) unallocated can be
	 * relocated.
	 */
	RANGE(range, 0x00000000u, 0x0009ffffu,
	      RANGE_TYPE(ResExcMemBlock, domain));
	pRes = xf86AddResToList(pRes, &range, -1);
	RANGE(range, 0x000c0000u, 0x000effffu,
	      RANGE_TYPE(ResExcMemBlock, domain));
	pRes = xf86AddResToList(pRes, &range, -1);
	RANGE(range, 0x000f0000u, 0x000fffffu,
	      RANGE_TYPE(ResExcMemBlock, domain));
	pRes = xf86AddResToList(pRes, &range, -1);

	RANGE(range, (ADDRESS)(sizes->mem_size - 1), 
	      (ADDRESS)(sizes->mem_size - 1),
	      RANGE_TYPE(ResExcMemBlock, domain));
	pRes = xf86AddResToList(pRes, &range, -1);

	RANGE(range, 0x00000000u, 0x00000000u,
	      RANGE_TYPE(ResExcIoBlock, domain));
	pRes = xf86AddResToList(pRes, &range, -1);
	RANGE(range, (IOADDRESS)(sizes->io_size - 1), 
	      (IOADDRESS)(sizes->io_size - 1),
	      RANGE_TYPE(ResExcIoBlock, domain));
	pRes = xf86AddResToList(pRes, &range, -1);

	/* FIXME: The old code reserved domain 0 for a special purpose.  The
	 * FIXME: new code just uses whatever domains the kernel tells it,
	 * FIXME: but there is no way to get a domain < 0.  What should
	 * FIXME: happen here?
	 *
	if (domain <= 0)
	  break;
	 */
    }

    pci_iterator_destroy(iter);

    return pRes;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a81 10
static pciBusInfo_t linuxPci0 = {
/* configMech  */	PCI_CFG_MECH_OTHER,
/* numDevices  */	32,
/* secondary   */	FALSE,
/* primary_bus */	0,
/* funcs       */	&linuxFuncs0,
/* pciBusPriv  */	NULL,
/* bridge      */	NULL
};

a87 1
#ifndef INCLUDE_XF86_NO_DOMAIN
a89 1
#endif
d94 1
a94 1
	struct stat st;
d96 1
a96 3
#ifndef INCLUDE_XF86_NO_DOMAIN
    (void) memset(DomainMmappedIO, 0, sizeof(DomainMmappedIO));
#endif
d98 6
a103 8
	if ((xf86Info.pciFlags == PCIForceNone) ||
	    (-1 == stat("/proc/bus/pci", &st))) {
		/* when using this as default for all linux architectures,
		   we'll need a fallback for 2.0 kernels here */
		return;
	}
	pciNumBuses    = 1;
	pciBusInfo[0]  = &linuxPci0;
a225 1
#ifndef INCLUDE_XF86_NO_DOMAIN
a588 1
#endif /* !INCLUDE_XF86_NO_DOMAIN */
@


1.1
log
@Initial revision
@
text
@a62 3
static CARD32 linuxPciCfgRead(PCITAG tag, int off);
static void linuxPciCfgWrite(PCITAG, int off, CARD32 val);
static void linuxPciCfgSetBits(PCITAG tag, int off, CARD32 mask, CARD32 bits);
a65 1
static ADDRESS linuxPpcHostAddrToBusAddr(PCITAG, PciAddrType, ADDRESS);
a67 7
static CARD8 linuxPciCfgReadByte(PCITAG tag, int off);
static void linuxPciCfgWriteByte(PCITAG tag, int off, CARD8 val);
static CARD16 linuxPciCfgReadWord(PCITAG tag, int off);
static void linuxPciCfgWriteWord(PCITAG tag, int off, CARD16 val);
static int linuxPciHandleBIOS(PCITAG Tag, int basereg, unsigned char *buf, int len);
static Bool linuxDomainSupport(void);

a68 3
/* pciReadLong      */	linuxPciCfgRead,
/* pciWriteLong     */	linuxPciCfgWrite,
/* pciSetBitsLong   */	linuxPciCfgSetBits,
a69 1
/* pciAddrHostToBus */	linuxPpcHostAddrToBusAddr,
a71 1
/* pciAddrHostToBus */	pciAddrNOOP,
a79 10

/* pciControlBridge */		NULL,
/* pciGetBridgeBuses */		NULL,
/* pciGetBridgeResources */	NULL,

/* pciReadByte */	linuxPciCfgReadByte,
/* pciWriteByte */	linuxPciCfgWriteByte,

/* pciReadWord */	linuxPciCfgReadWord,
/* pciWriteWord */	linuxPciCfgWriteWord,
d92 5
a96 2
/* from lnx_pci.c. */
extern int lnxPciInit(void);
d98 4
a101 1
static Bool	domain_support = FALSE;
d104 1
a104 1
linuxPciInit()
d107 5
a117 3
#ifndef INCLUDE_XF86_NO_DOMAIN
	domain_support = linuxDomainSupport();
#endif
a119 4
	pciFindFirstFP = pciGenFindFirst;
	pciFindNextFP  = pciGenFindNext;
	pciSetOSBIOSPtr(linuxPciHandleBIOS);
        xf86MaxPciDevs = lnxPciInit();
d122 5
d128 1
a128 1
linuxPciOpenFile(PCITAG tag, Bool write)
d130 13
a142 16
	static int	ldomain, lbus,ldev,lfunc,fd = -1,is_write = 0;
	int		domain, bus, dev, func;
	char		file[64];
	struct stat	ignored;
	static int is26 = -1;

	domain = PCI_DOM_FROM_TAG(tag);
	bus  = PCI_BUS_NO_DOMAIN(PCI_BUS_FROM_TAG(tag));
	dev  = PCI_DEV_FROM_TAG(tag);
	func = PCI_FUNC_FROM_TAG(tag);
	if (is26 == -1) {
		if (stat("/sys/bus/pci",&ignored) < 0)
			is26 = 0;
		else
			is26 = 1;
	}
d144 18
a161 8
	if (!domain_support && domain > 0)
	    return -1;

	if (fd == -1 || (write && (!is_write)) || domain != ldomain
	    || bus != lbus || dev != ldev || func != lfunc) {
		if (fd != -1) {
			close(fd);
			fd = -1;
d163 8
a170 27
		if (is26)
			sprintf(file,"/sys/bus/pci/devices/%04x:%02x:%02x.%01x/config",
				domain, bus, dev, func);
		else {
			if (bus < 256) {
				sprintf(file, "/proc/bus/pci/%04x:%02x", domain, bus);
				if (stat(file, &ignored) < 0) {
					if (domain == 0) 
						sprintf(file, "/proc/bus/pci/%02x/%02x.%1x",
							bus, dev, func);
					else
						goto bail;
				} else
					sprintf(file, "/proc/bus/pci/%04x:%02x/%02x.%1x",
						domain, bus, dev, func);
			} else {
				sprintf(file, "/proc/bus/pci/%04x:%04x", domain, bus);
				if (stat(file, &ignored) < 0) {
					if (domain == 0)
						sprintf(file, "/proc/bus/pci/%04x/%02x.%1x",
							bus, dev, func);
					else
						goto bail;
				} else
					sprintf(file, "/proc/bus/pci/%04x:%04x/%02x.%1x",
						domain, bus, dev, func);
			}
d172 1
a172 17
		if (write) {
		    fd = open(file,O_RDWR);
		    if (fd != -1) is_write = TRUE;
		} else switch (is_write) {
			case TRUE:
			    fd = open(file,O_RDWR);
			    if (fd > -1)
				break;
			default:
			    fd = open(file,O_RDONLY);
			    is_write = FALSE;
		}
	bail:
		ldomain = domain;
		lbus  = bus;
		ldev  = dev;
		lfunc = func;
a173 2
	return fd;
}
d175 13
a187 9
static CARD32
linuxPciCfgRead(PCITAG tag, int off)
{
	int	fd;
	CARD32	val = 0xffffffff;

	if (-1 != (fd = linuxPciOpenFile(tag,FALSE))) {
		lseek(fd,off,SEEK_SET);
		read(fd,&val,4);
a188 2
	return PCI_CPU(val);
}
d190 2
a191 4
static void
linuxPciCfgWrite(PCITAG tag, int off, CARD32 val)
{
	int	fd;
d193 1
a193 22
	if (-1 != (fd = linuxPciOpenFile(tag,TRUE))) {
		lseek(fd,off,SEEK_SET);
		val = PCI_CPU(val);
		write(fd,&val,4);
	}
}

static void
linuxPciCfgSetBits(PCITAG tag, int off, CARD32 mask, CARD32 bits)
{
	int	fd;
	CARD32	val = 0xffffffff;

	if (-1 != (fd = linuxPciOpenFile(tag,TRUE))) {
		lseek(fd,off,SEEK_SET);
		read(fd,&val,4);
		val = PCI_CPU(val);
		val = (val & ~mask) | (bits & mask);
		val = PCI_CPU(val);
		lseek(fd,off,SEEK_SET);
		write(fd,&val,4);
	}
a239 18
static ADDRESS
linuxPpcHostAddrToBusAddr(PCITAG tag, PciAddrType type, ADDRESS addr)
{
    if (type == PCI_MEM)
    {
	ADDRESS membase = syscall(__NR_pciconfig_iobase, 1,
		    PCI_BUS_FROM_TAG(tag), PCI_DFN_FROM_TAG(tag));
	return (addr - membase);
    }
    else if (type == PCI_IO)
    {
	ADDRESS iobase = syscall(__NR_pciconfig_iobase, 2,
		    PCI_BUS_FROM_TAG(tag), PCI_DFN_FROM_TAG(tag));
	return (addr - iobase);
    }
    else return addr;
}

a241 51
static CARD8
linuxPciCfgReadByte(PCITAG tag, int off)
{
	int	fd;
	CARD8	val = 0xff;

	if (-1 != (fd = linuxPciOpenFile(tag,FALSE))) {
		lseek(fd,off,SEEK_SET);
		read(fd,&val,1);
	}

	return val;
}

static void
linuxPciCfgWriteByte(PCITAG tag, int off, CARD8 val)
{
	int	fd;

	if (-1 != (fd = linuxPciOpenFile(tag,TRUE))) {
		lseek(fd,off,SEEK_SET);
		write(fd, &val, 1);
	}
}

static CARD16
linuxPciCfgReadWord(PCITAG tag, int off)
{
	int	fd;
	CARD16	val = 0xff;

	if (-1 != (fd = linuxPciOpenFile(tag,FALSE))) {
		lseek(fd, off, SEEK_SET);
		read(fd, &val, 2);
	}

	return PCI_CPU16(val);
}

static void
linuxPciCfgWriteWord(PCITAG tag, int off, CARD16 val)
{
	int	fd;

	if (-1 != (fd = linuxPciOpenFile(tag,TRUE))) {
		lseek(fd, off, SEEK_SET);
		val = PCI_CPU16(val);
		write(fd, &val, 2);
	}
}

d288 2
a289 2
static pciConfigPtr
xf86GetPciHostConfigFromTag(PCITAG Tag)
d291 21
a311 2
    int bus = PCI_BUS_FROM_TAG(Tag);
    pciBusInfo_t *pBusInfo;
d313 6
a318 4
    while ((bus < pciNumBuses) && (pBusInfo = pciBusInfo[bus])) {
	if (bus == pBusInfo->primary_bus)
	    return pBusInfo->bridge;
	bus = pBusInfo->primary_bus;
d321 3
a323 1
    return NULL;	/* Bad data */
d359 1
a359 1
linuxGetSizesStruct(PCITAG Tag)
a363 1
    pciConfigPtr pPCI;
d366 2
a367 3
    /* Find host bridge */
    if ((pPCI = xf86GetPciHostConfigFromTag(Tag))) {
	/* Look up vendor/device */
d369 2
a370 2
	    if ((pPCI->pci_vendor == pciControllerSizes[i].vendor)
		&& (pPCI->pci_device == pciControllerSizes[i].device)) {
d381 1
a381 1
linuxGetIOSize(PCITAG Tag)
d383 1
a383 1
    const struct pciSizes * const sizes = linuxGetSizesStruct(Tag);
a386 58
static __inline__ void
linuxGetSizes(PCITAG Tag, unsigned long *io_size, unsigned long *mem_size)
{
    const struct pciSizes * const sizes = linuxGetSizesStruct(Tag);

    *io_size  = sizes->io_size;
    *mem_size = sizes->mem_size;
}

static Bool
linuxDomainSupport(void)
{
    DIR *dir;
    struct dirent *dirent;
    char *end;

    if (!(dir = opendir("/proc/bus/pci")))
       return FALSE;
    while (1) {
	if (!(dirent = readdir(dir)))
	    return FALSE;
	strtol(dirent->d_name,&end,16);
	/* entry of the form xx or xxxx : x=[0..f] no domain */
	if (*end == '\0')
	    return FALSE;
	else if (*end == ':') {
	    /* ':' found immediately after: verify for xxxx:xx or xxxx:xxxx */
	    strtol(end + 1,&end,16);
	    if (*end == '\0')
		return TRUE;
	}
    }
    return FALSE;
} 

_X_EXPORT int
xf86GetPciDomain(PCITAG Tag)
{
    pciConfigPtr pPCI;
    int fd, result;

    pPCI = xf86GetPciHostConfigFromTag(Tag);

    if (pPCI && (result = PCI_DOM_FROM_BUS(pPCI->busnum)))
	return result;

    if (!pPCI || pPCI->fakeDevice)
	return 1;		/* Domain 0 is reserved */

    if ((fd = linuxPciOpenFile(pPCI ? pPCI->tag : 0,FALSE)) < 0)
	return 0;

    if ((result = ioctl(fd, PCIIOC_CONTROLLER, 0)) < 0)
	return 0;

    return result + 1;		/* Domain 0 is reserved */
}

d388 1
a388 1
linuxMapPci(int ScreenNum, int Flags, PCITAG Tag,
d391 4
a395 1
	pciConfigPtr pPCI;
a396 1
	ADDRESS realBase, Offset;
d401 5
a405 1
	if (((fd = linuxPciOpenFile(Tag ,FALSE)) < 0) ||
a434 3
	/* Align to page boundary */
	realBase = Base & ~(getpagesize() - 1);
	Offset = Base - realBase;
a456 3
#define MAX_DOMAINS 257
static pointer DomainMmappedIO[MAX_DOMAINS];

d458 1
a458 1
linuxOpenLegacy(PCITAG Tag, char *name)
d460 3
a462 18
#define PREFIX "/sys/class/pci_bus/%04x:%02x/%s"
    char *path;
    int domain, bus;
    pciBusInfo_t *pBusInfo;
    pciConfigPtr bridge = NULL;
    int fd;

    path = xalloc(strlen(PREFIX) + strlen(name));
    if (!path)
	return -1;

    for (;;) {
	domain = xf86GetPciDomain(Tag);
	bus = PCI_BUS_NO_DOMAIN(PCI_BUS_FROM_TAG(Tag));

	/* Domain 0 is reserved -- see xf86GetPciDomain() */
	if ((domain <= 0) || (domain >= MAX_DOMAINS))
	    FatalError("linuxOpenLegacy():  domain out of range\n");
d464 2
a465 1
	sprintf(path, PREFIX, domain - 1, bus, name);
a467 1
	    xfree(path);
d471 1
a471 8
	pBusInfo = pciBusInfo[bus];
	if (!pBusInfo || (bridge == pBusInfo->bridge) ||
		!(bridge = pBusInfo->bridge)) {
	    xfree(path);
	    return -1;
	}

	Tag = bridge->tag;
a473 1
    xfree(path);
d485 1
a485 1
xf86MapDomainMemory(int ScreenNum, int Flags, PCITAG Tag,
d488 1
a488 2
    int domain = xf86GetPciDomain(Tag);
    int fd;
d495 2
a496 2
    if (Base > 1024*1024)
	return linuxMapPci(ScreenNum, Flags, Tag, Base, Size,
d498 2
d501 3
a503 7
    if ((fd = linuxOpenLegacy(Tag, "legacy_mem")) < 0)
	return linuxMapPci(ScreenNum, Flags, Tag, Base, Size,
			   PCIIOC_MMAP_IS_MEM);

    addr = mmap(NULL, Size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, Base);
    if (addr == MAP_FAILED) {
	close (fd);
a506 1
    close(fd);
d510 2
a511 2
/*
 * xf86MapDomainIO - map I/O space in this domain
d517 2
a518 2
 * If the legacy_io interface *does* exist, the file descriptor (fd below)
 * will be saved in the DomainMmappedIO array in the upper bits of the
d520 2
a521 2
 * the platform I/O code can extract the port number and the fd, lseek to
 * the port number in the legacy_io file, and issue the read or write.
d525 2
a526 3
_X_EXPORT IOADDRESS
xf86MapDomainIO(int ScreenNum, int Flags, PCITAG Tag,
		IOADDRESS Base, unsigned long Size)
d528 2
a529 1
    int domain = xf86GetPciDomain(Tag);
d532 2
a533 2
    if ((domain <= 0) || (domain >= MAX_DOMAINS))
	FatalError("xf86MapDomainIO():  domain out of range\n");
d535 6
a540 7
    if (DomainMmappedIO[domain])
	return (IOADDRESS)DomainMmappedIO[domain] + Base;

    /* Permanently map all of I/O space */
    if ((fd = linuxOpenLegacy(Tag, "legacy_io")) < 0) {
	    DomainMmappedIO[domain] = linuxMapPci(ScreenNum, Flags, Tag,
						  0, linuxGetIOSize(Tag),
a541 103
	    /* ia64 can't mmap legacy IO port space */
	    if (!DomainMmappedIO[domain])
		return Base;
    }
    else { /* legacy_io file exists, encode fd */
	DomainMmappedIO[domain] = (pointer)(fd << 24);
    }

    return (IOADDRESS)DomainMmappedIO[domain] + Base;
}

/*
 * xf86ReadDomainMemory - copy from domain memory into a caller supplied buffer
 */
_X_EXPORT int
xf86ReadDomainMemory(PCITAG Tag, ADDRESS Base, int Len, unsigned char *Buf)
{
    unsigned char *ptr, *src;
    ADDRESS offset;
    unsigned long size;
    int len, pagemask = getpagesize() - 1;

    unsigned int i, dom, bus, dev, func;
    unsigned int fd;
    char file[256];
    struct stat st;

    dom  = PCI_DOM_FROM_TAG(Tag);
    bus  = PCI_BUS_NO_DOMAIN(PCI_BUS_FROM_TAG(Tag));
    dev  = PCI_DEV_FROM_TAG(Tag);
    func = PCI_FUNC_FROM_TAG(Tag);
    sprintf(file, "/sys/devices/pci%04x:%02x/%04x:%02x:%02x.%1x/rom",
	    dom, bus, dom, bus, dev, func);

    /*
     * If the caller wants the ROM and the sysfs rom interface exists,
     * try to use it instead of reading it from /proc/bus/pci.
     */
    if (((Base & 0xfffff) == 0xC0000) && (stat(file, &st) == 0)) {
        if ((fd = open(file, O_RDWR)))
            Base = 0x0;

	/* enable the ROM first */
	write(fd, "1", 2);
	lseek(fd, 0, SEEK_SET);

        /* copy the ROM until we hit Len, EOF or read error */
        for (i = 0; i < Len && read(fd, Buf, 1) > 0; Buf++, i++)
            ;

	write(fd, "0", 2);
	close(fd);

	return Len;
    }

    /* Ensure page boundaries */
    offset = Base & ~pagemask;
    size = ((Base + Len + pagemask) & ~pagemask) - offset;

    ptr = xf86MapDomainMemory(-1, VIDMEM_READONLY, Tag, offset, size);

    if (!ptr)
	return -1;

    /* Using memcpy() here can hang the system */
    src = ptr + (Base - offset);
    for (len = Len;  len-- > 0;)
	*Buf++ = *src++;

    xf86UnMapVidMem(-1, ptr, size);

    return Len;
}

resPtr
xf86BusAccWindowsFromOS(void)
{
    pciConfigPtr  *ppPCI, pPCI;
    resPtr        pRes = NULL;
    resRange      range;
    unsigned long io_size, mem_size;
    int           domain;

    if ((ppPCI = xf86scanpci(0))) {
	for (;  (pPCI = *ppPCI);  ppPCI++) {
	    if ((pPCI->pci_base_class != PCI_CLASS_BRIDGE) ||
		(pPCI->pci_sub_class  != PCI_SUBCLASS_BRIDGE_HOST))
		continue;

	    domain = xf86GetPciDomain(pPCI->tag);
	    linuxGetSizes(pPCI->tag, &io_size, &mem_size);

	    RANGE(range, 0, (ADDRESS)(mem_size - 1),
		  RANGE_TYPE(ResExcMemBlock, domain));
	    pRes = xf86AddResToList(pRes, &range, -1);

	    RANGE(range, 0, (IOADDRESS)(io_size - 1),
		  RANGE_TYPE(ResExcIoBlock, domain));
	    pRes = xf86AddResToList(pRes, &range, -1);

	    if (domain <= 0)
		break;
d543 2
a544 33
    }

    return pRes;
}

resPtr
xf86PciBusAccWindowsFromOS(void)
{
    pciConfigPtr  *ppPCI, pPCI;
    resPtr        pRes = NULL;
    resRange      range;
    unsigned long io_size, mem_size;
    int           domain;

    if ((ppPCI = xf86scanpci(0))) {
	for (;  (pPCI = *ppPCI);  ppPCI++) {
	    if ((pPCI->pci_base_class != PCI_CLASS_BRIDGE) ||
		(pPCI->pci_sub_class  != PCI_SUBCLASS_BRIDGE_HOST))
		continue;

	    domain = xf86GetPciDomain(pPCI->tag);
	    linuxGetSizes(pPCI->tag, &io_size, &mem_size);

	    RANGE(range, 0, (ADDRESS)(mem_size - 1),
		  RANGE_TYPE(ResExcMemBlock, domain));
	    pRes = xf86AddResToList(pRes, &range, -1);

	    RANGE(range, 0, (IOADDRESS)(io_size - 1),
		  RANGE_TYPE(ResExcIoBlock, domain));
	    pRes = xf86AddResToList(pRes, &range, -1);

	    if (domain <= 0)
		break;
d548 1
a548 1
    return pRes;
a550 1

d554 2
a555 1
    pciConfigPtr  *ppPCI, pPCI;
a556 2
    unsigned long io_size, mem_size;
    int           domain;
d558 42
a599 34
    if ((ppPCI = xf86scanpci(0))) {
	for (;  (pPCI = *ppPCI);  ppPCI++) {
	    if ((pPCI->pci_base_class != PCI_CLASS_BRIDGE) ||
		(pPCI->pci_sub_class  != PCI_SUBCLASS_BRIDGE_HOST))
		continue;

	    domain = xf86GetPciDomain(pPCI->tag);
	    linuxGetSizes(pPCI->tag, &io_size, &mem_size);

	    /*
	     * At minimum, the top and bottom resources must be claimed, so
	     * that resources that are (or appear to be) unallocated can be
	     * relocated.
	     */
	    RANGE(range, 0x00000000u, 0x0009ffffu,
		  RANGE_TYPE(ResExcMemBlock, domain));
	    pRes = xf86AddResToList(pRes, &range, -1);
	    RANGE(range, 0x000c0000u, 0x000effffu,
		  RANGE_TYPE(ResExcMemBlock, domain));
	    pRes = xf86AddResToList(pRes, &range, -1);
	    RANGE(range, 0x000f0000u, 0x000fffffu,
		  RANGE_TYPE(ResExcMemBlock, domain));
	    pRes = xf86AddResToList(pRes, &range, -1);

	    RANGE(range, (ADDRESS)(mem_size - 1), (ADDRESS)(mem_size - 1),
		  RANGE_TYPE(ResExcMemBlock, domain));
	    pRes = xf86AddResToList(pRes, &range, -1);

	    RANGE(range, 0x00000000u, 0x00000000u,
		  RANGE_TYPE(ResExcIoBlock, domain));
	    pRes = xf86AddResToList(pRes, &range, -1);
	    RANGE(range, (IOADDRESS)(io_size - 1), (IOADDRESS)(io_size - 1),
		  RANGE_TYPE(ResExcIoBlock, domain));
	    pRes = xf86AddResToList(pRes, &range, -1);
d601 1
a601 4
	    if (domain <= 0)
		break;
	}
    }
a606 144

int linuxPciHandleBIOS(PCITAG Tag, int basereg, unsigned char *buf, int len)
{
  unsigned int dom, bus, dev, func;
  unsigned int fd;
  char file[256];
  struct stat st;
  int ret;
  int sofar = 0;

  dom  = PCI_DOM_FROM_TAG(Tag);
  bus  = PCI_BUS_NO_DOMAIN(PCI_BUS_FROM_TAG(Tag));
  dev  = PCI_DEV_FROM_TAG(Tag);
  func = PCI_FUNC_FROM_TAG(Tag);
  sprintf(file, "/sys/bus/pci/devices/%04x:%02x:%02x.%1x/rom",
	  dom, bus, dev, func);

  if (stat(file, &st) == 0)
  {
    if ((fd = open(file, O_RDWR)))
      basereg = 0x0;
    
    /* enable the ROM first */
    write(fd, "1", 2);
    lseek(fd, 0, SEEK_SET);
    do {
        /* copy the ROM until we hit Len, EOF or read error */
    	ret = read(fd, buf+sofar, len-sofar);
    	if (ret <= 0)
		break;
	sofar += ret;
    } while (sofar < len);
    
    write(fd, "0", 2);
    close(fd);
    if (sofar < len)
    	xf86MsgVerb(X_INFO, 3, "Attempted to read BIOS %dKB from %s: got %dKB\n", len/1024, file, sofar/1024);
    return sofar;
  }
  return 0;
}

#ifdef __ia64__
static PCITAG ia64linuxPciFindFirst(void);
static PCITAG ia64linuxPciFindNext(void);

void   
ia64linuxPciInit()
{
    struct stat st;

    linuxPciInit();
	   
    if (!stat("/proc/sgi_sn/licenseID", &st) && pciNumBuses) {
       /* Be a little paranoid here and only use this code for Altix systems.
	* It is generic, so it should work on any system, but depends on
	* /proc/bus/pci entries for each domain/bus combination. Altix is
	* guaranteed a recent enough kernel to have them.
	*/
       pciFindFirstFP = ia64linuxPciFindFirst;
       pciFindNextFP  = ia64linuxPciFindNext;
    }
}

static DIR *busdomdir;
static DIR *devdir;
	       
static PCITAG
ia64linuxPciFindFirst(void)
{   
       busdomdir = opendir("/proc/bus/pci");
       devdir = NULL;

       return ia64linuxPciFindNext();
}   

static struct dirent *getnextbus(int *domain, int *bus)
{
    struct dirent *entry;
    int dombus;

    for (;;) {
	entry = readdir(busdomdir);
	if (entry == NULL) {
	    *domain = 0;
	    *bus = 0;
	    closedir(busdomdir);
	    return NULL;
	}
	if (sscanf(entry->d_name, "%04x:%02x", domain, bus) != 2)
	    continue;
	dombus = PCI_MAKE_BUS(*domain, *bus);

	if (pciNumBuses <= dombus)
	    pciNumBuses = dombus + 1;
	if (!pciBusInfo[dombus]) {
	    pciBusInfo[dombus] = xnfalloc(sizeof(pciBusInfo_t));
	    *pciBusInfo[dombus] = *pciBusInfo[0];
	}

	return entry;
    }
}

static PCITAG
ia64linuxPciFindNext(void)
{
    struct dirent *entry;
    char file[40];
    static int bus, dev, func, domain;
    PCITAG pciDeviceTag;
    CARD32 devid;

    for (;;) {
	if (devdir == NULL) {
	    entry = getnextbus(&domain, &bus);
	    if (!entry)
		return PCI_NOT_FOUND;
	    snprintf(file, 40, "/proc/bus/pci/%s", entry->d_name);
	    devdir = opendir(file);
	    if (!devdir)
		return PCI_NOT_FOUND;

	}

	entry = readdir(devdir);

	if (entry == NULL) {
	    closedir(devdir);
	    devdir = NULL;
	    continue;
	}

	if (sscanf(entry->d_name, "%02x . %01x", &dev, &func) == 2) {
	    pciDeviceTag = PCI_MAKE_TAG(PCI_MAKE_BUS(domain, bus), dev, func);
	    devid = pciReadLong(pciDeviceTag, PCI_ID_REG);
	    if ((devid & pciDevidMask) == pciDevid)
		/* Yes - Return it.  Otherwise, next device */
		return pciDeviceTag;
	}
    }
}
#endif

@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d547 1
a547 1
	return result + 1;
d573 1
a573 2
       prot = ((Flags & VIDMEM_READONLY) == 0);
       if (((fd = linuxPciOpenFile(Tag, prot)) < 0) ||
d660 1
a660 1
	pBusInfo = pciBusInfo[PCI_BUS_FROM_TAG(Tag)];
d686 1
a686 1
    int fd = -1;
d693 2
a694 2
    if (Base >= 1024*1024)
	addr = linuxMapPci(ScreenNum, Flags, Tag, Base, Size,
d696 3
a698 2
    else if ((fd = linuxOpenLegacy(Tag, "legacy_mem")) < 0)
	addr = linuxMapPci(ScreenNum, Flags, Tag, Base, Size,
a699 2
    else
	addr = mmap(NULL, Size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, Base);
d701 3
a703 3
    if (fd >= 0)
	close(fd);
    if (addr == NULL || addr == MAP_FAILED) {
d707 1
d775 2
a776 2
    sprintf(file, "/sys/bus/pci/devices/%04x:%02x:%02x.%1x/rom",
	    dom, bus, dev, func);
a789 2
    len = min(Len, st.st_size);

d791 1
a791 1
        for (; len && (size = read(fd, Buf, len)) > 0 ; Buf+=size, len-=size)
d1074 1
a1074 57
	    CARD32 tmp;
	    int sec_bus, pri_bus;
	    unsigned char base_class, sub_class;

	    int pciBusNum = PCI_MAKE_BUS(domain, bus);
	    pciDeviceTag = PCI_MAKE_TAG(pciBusNum, dev, func);

	    /*
	     * Before checking for a specific devid, look for enabled
	     * PCI to PCI bridge devices.  If one is found, create and
	     * initialize a bus info record (if one does not already exist).
	     */
	    tmp = pciReadLong(pciDeviceTag, PCI_CLASS_REG);
	    base_class = PCI_CLASS_EXTRACT(tmp);
	    sub_class = PCI_SUBCLASS_EXTRACT(tmp);
	    if ((base_class == PCI_CLASS_BRIDGE) &&
		((sub_class == PCI_SUBCLASS_BRIDGE_PCI) ||
		 (sub_class == PCI_SUBCLASS_BRIDGE_CARDBUS))) {
		tmp = pciReadLong(pciDeviceTag, PCI_PCI_BRIDGE_BUS_REG);
		sec_bus = PCI_SECONDARY_BUS_EXTRACT(tmp, pciDeviceTag);
		pri_bus = PCI_PRIMARY_BUS_EXTRACT(tmp, pciDeviceTag);
#ifdef DEBUGPCI
		ErrorF("ia64linuxPciFindNext: pri_bus %d sec_bus %d\n",
		       pri_bus, sec_bus);
#endif
		if (pciBusNum != pri_bus) {
		    /* Some bridges do not implement the primary bus register */
		    if ((PCI_BUS_NO_DOMAIN(pri_bus) != 0) ||
			(sub_class != PCI_SUBCLASS_BRIDGE_CARDBUS))
			xf86Msg(X_WARNING,
				"ia64linuxPciFindNext:  primary bus mismatch on PCI"
				" bridge 0x%08lx (0x%02x, 0x%02x)\n",
				pciDeviceTag, pciBusNum, pri_bus);
		    pri_bus = pciBusNum;
	        }
		if ((pri_bus < sec_bus) && (sec_bus < pciMaxBusNum) &&
		    pciBusInfo[pri_bus]) {
		    /*
		     * Found a secondary PCI bus
		     */
		    if (!pciBusInfo[sec_bus]) {
			pciBusInfo[sec_bus] = xnfalloc(sizeof(pciBusInfo_t));

			/* Copy parents settings... */
			*pciBusInfo[sec_bus] = *pciBusInfo[pri_bus];
		    }

		    /* ...but not everything same as parent */
		    pciBusInfo[sec_bus]->primary_bus = pri_bus;
		    pciBusInfo[sec_bus]->secondary = TRUE;
		    pciBusInfo[sec_bus]->numDevices = 32;

		    if (pciNumBuses <= sec_bus)
			pciNumBuses = sec_bus + 1;
		}
	    }

@

