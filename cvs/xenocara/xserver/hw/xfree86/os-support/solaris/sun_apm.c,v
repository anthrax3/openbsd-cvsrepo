head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.17.57.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.17.57.34;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/* Based on hw/xfree86/os-support/bsd/bsd_apm.c which bore no explicit
 * copyright notice, so is covered by the following notice:
 *
 * Copyright (C) 1994-2003 The XFree86 Project, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of the XFree86 Project shall
 * not be used in advertising or otherwise to promote the sale, use or other
 * dealings in this Software without prior written authorization from the
 * XFree86 Project.
 */

/* Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/X.h>
#include "os.h"
#include "xf86.h"
#include "xf86Priv.h"
#define XF86_OS_PRIVS
#include "xf86_OSproc.h"
#include "xf86_OSlib.h"

#ifndef PLEASE_FIX_THIS
#define APM_STANDBY_REQ 0xa01
#define APM_SUSPEND_REQ 0xa02
#define APM_NORMAL_RESUME 0xa03
#define APM_CRIT_RESUME 0xa04
#define APM_BATTERY_LOW 0xa05
#define APM_POWER_CHANGE 0xa06
#define APM_UPDATE_TIME 0xa07
#define APM_CRIT_SUSPEND_REQ 0xa08
#define APM_USER_STANDBY_REQ 0xa09
#define APM_USER_SUSPEND_REQ 0xa0a
#define APM_SYS_STANDBY_RESUME 0xa0b
#define APM_IOC_NEXTEVENT 0xa0c
#define APM_IOC_RESUME 0xa0d
#define APM_IOC_SUSPEND 0xa0e
#define APM_IOC_STANDBY 0xa0f
#endif

typedef struct apm_event_info {
    int type;
} apm_event_info;

/*
 This may be replaced with a better device name
 very soon...
*/
#define APM_DEVICE "/dev/srn"
#define APM_DEVICE1 "/dev/apm"

static void *APMihPtr = NULL;
static void sunCloseAPM(void);

static struct {
    u_int apmBsd;
    pmEvent xf86;
} sunToXF86Array[] = {
    {APM_STANDBY_REQ, XF86_APM_SYS_STANDBY},
    {APM_SUSPEND_REQ, XF86_APM_SYS_SUSPEND},
    {APM_NORMAL_RESUME, XF86_APM_NORMAL_RESUME},
    {APM_CRIT_RESUME, XF86_APM_CRITICAL_RESUME},
    {APM_BATTERY_LOW, XF86_APM_LOW_BATTERY},
    {APM_POWER_CHANGE, XF86_APM_POWER_STATUS_CHANGE},
    {APM_UPDATE_TIME, XF86_APM_UPDATE_TIME},
    {APM_CRIT_SUSPEND_REQ, XF86_APM_CRITICAL_SUSPEND},
    {APM_USER_STANDBY_REQ, XF86_APM_USER_STANDBY},
    {APM_USER_SUSPEND_REQ, XF86_APM_USER_SUSPEND},
    {APM_SYS_STANDBY_RESUME, XF86_APM_STANDBY_RESUME},
#ifdef APM_CAPABILITY_CHANGE
    {APM_CAPABILITY_CHANGE, XF86_APM_CAPABILITY_CHANGED},
#endif
};

#define numApmEvents (sizeof(sunToXF86Array) / sizeof(sunToXF86Array[0]))

static pmEvent
sunToXF86(int type)
{
    int i;

    for (i = 0; i < numApmEvents; i++) {
        if (type == sunToXF86Array[i].apmBsd) {
            return sunToXF86Array[i].xf86;
        }
    }
    return XF86_APM_UNKNOWN;
}

/*
 * APM events can be requested direclty from /dev/apm
 */
static int
sunPMGetEventFromOS(int fd, pmEvent * events, int num)
{
    struct apm_event_info sunEvent;
    int i;

    for (i = 0; i < num; i++) {

        if (ioctl(fd, APM_IOC_NEXTEVENT, &sunEvent) < 0) {
            if (errno != EAGAIN) {
                xf86Msg(X_WARNING, "sunPMGetEventFromOS: APM_IOC_NEXTEVENT"
                        " %s\n", strerror(errno));
            }
            break;
        }
        events[i] = sunToXF86(sunEvent.type);
    }
    xf86Msg(X_WARNING, "Got some events\n");
    return i;
}

static pmWait
sunPMConfirmEventToOs(int fd, pmEvent event)
{
    switch (event) {
/* XXX: NOT CURRENTLY RETURNED FROM OS */
    case XF86_APM_SYS_STANDBY:
    case XF86_APM_USER_STANDBY:
        if (ioctl(fd, APM_IOC_STANDBY, NULL) == 0)
            return PM_WAIT;     /* should we stop the Xserver in standby, too? */
        else
            return PM_NONE;
    case XF86_APM_SYS_SUSPEND:
    case XF86_APM_CRITICAL_SUSPEND:
    case XF86_APM_USER_SUSPEND:
        xf86Msg(X_WARNING, "Got SUSPENDED\n");
        if (ioctl(fd, APM_IOC_SUSPEND, NULL) == 0)
            return PM_CONTINUE;
        else {
            xf86Msg(X_WARNING, "sunPMConfirmEventToOs: APM_IOC_SUSPEND"
                    " %s\n", strerror(errno));
            return PM_FAILED;
        }
    case XF86_APM_STANDBY_RESUME:
    case XF86_APM_NORMAL_RESUME:
    case XF86_APM_CRITICAL_RESUME:
    case XF86_APM_STANDBY_FAILED:
    case XF86_APM_SUSPEND_FAILED:
        xf86Msg(X_WARNING, "Got RESUME\n");
        if (ioctl(fd, APM_IOC_RESUME, NULL) == 0)
            return PM_CONTINUE;
        else {
            xf86Msg(X_WARNING, "sunPMConfirmEventToOs: APM_IOC_RESUME"
                    " %s\n", strerror(errno));
            return PM_FAILED;
        }
    default:
        return PM_NONE;
    }
}

PMClose
xf86OSPMOpen(void)
{
    int fd;

    if (APMihPtr || !xf86Info.pmFlag) {
        return NULL;
    }

    if ((fd = open(APM_DEVICE, O_RDWR)) == -1) {
        if ((fd = open(APM_DEVICE1, O_RDWR)) == -1) {
            return NULL;
        }
    }
    xf86PMGetEventFromOs = sunPMGetEventFromOS;
    xf86PMConfirmEventToOs = sunPMConfirmEventToOs;
    APMihPtr = xf86AddGeneralHandler(fd, xf86HandlePMEvents, NULL);
    return sunCloseAPM;
}

static void
sunCloseAPM(void)
{
    int fd;

    if (APMihPtr) {
        fd = xf86RemoveGeneralHandler(APMihPtr);
        close(fd);
        APMihPtr = NULL;
    }
}
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d132 1
a132 1
 * APM events can be requested direclty from /dev/apm 
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d93 1
a93 1
static pointer APMihPtr = NULL;
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d100 11
a110 12
    {
    APM_STANDBY_REQ, XF86_APM_SYS_STANDBY}, {
    APM_SUSPEND_REQ, XF86_APM_SYS_SUSPEND}, {
    APM_NORMAL_RESUME, XF86_APM_NORMAL_RESUME}, {
    APM_CRIT_RESUME, XF86_APM_CRITICAL_RESUME}, {
    APM_BATTERY_LOW, XF86_APM_LOW_BATTERY}, {
    APM_POWER_CHANGE, XF86_APM_POWER_STATUS_CHANGE}, {
    APM_UPDATE_TIME, XF86_APM_UPDATE_TIME}, {
    APM_CRIT_SUSPEND_REQ, XF86_APM_CRITICAL_SUSPEND}, {
    APM_USER_STANDBY_REQ, XF86_APM_USER_STANDBY}, {
    APM_USER_SUSPEND_REQ, XF86_APM_USER_SUSPEND}, {
    APM_SYS_STANDBY_RESUME, XF86_APM_STANDBY_RESUME},
d112 1
a112 2
    {
    APM_CAPABILITY_CHANGE, XF86_APM_CAPABILITY_CHANGED},
@


1.4
log
@Update to xserver 1.11.2
@
text
@d82 2
a83 3
typedef struct apm_event_info 
{
	int	type;
d99 13
a111 12
} sunToXF86Array [] = {
    { APM_STANDBY_REQ, XF86_APM_SYS_STANDBY },
    { APM_SUSPEND_REQ, XF86_APM_SYS_SUSPEND },
    { APM_NORMAL_RESUME, XF86_APM_NORMAL_RESUME },
    { APM_CRIT_RESUME, XF86_APM_CRITICAL_RESUME },
    { APM_BATTERY_LOW, XF86_APM_LOW_BATTERY },
    { APM_POWER_CHANGE, XF86_APM_POWER_STATUS_CHANGE },
    { APM_UPDATE_TIME, XF86_APM_UPDATE_TIME },
    { APM_CRIT_SUSPEND_REQ, XF86_APM_CRITICAL_SUSPEND },
    { APM_USER_STANDBY_REQ, XF86_APM_USER_STANDBY },
    { APM_USER_SUSPEND_REQ, XF86_APM_USER_SUSPEND },
    { APM_SYS_STANDBY_RESUME, XF86_APM_STANDBY_RESUME },
d113 2
a114 1
    { APM_CAPABILITY_CHANGE, XF86_APM_CAPABILITY_CHANGED },
d126 3
a128 3
	if (type == sunToXF86Array[i].apmBsd) {
	    return sunToXF86Array[i].xf86;
	}
d136 2
a137 2
static int 
sunPMGetEventFromOS(int fd, pmEvent *events, int num)
d143 9
a151 9
	
	if (ioctl(fd, APM_IOC_NEXTEVENT, &sunEvent) < 0) {
	    if (errno != EAGAIN) {
		xf86Msg(X_WARNING, "sunPMGetEventFromOS: APM_IOC_NEXTEVENT"
			" %s\n", strerror(errno));
	    }
	    break;
	}
	events[i] = sunToXF86(sunEvent.type);
d162 4
a165 4
      case XF86_APM_SYS_STANDBY:
      case XF86_APM_USER_STANDBY:
        if (ioctl( fd, APM_IOC_STANDBY, NULL ) == 0)
            return PM_WAIT;  /* should we stop the Xserver in standby, too? */
d168 5
a172 5
      case XF86_APM_SYS_SUSPEND:
      case XF86_APM_CRITICAL_SUSPEND:
      case XF86_APM_USER_SUSPEND:
	    xf86Msg(X_WARNING, "Got SUSPENDED\n");
        if (ioctl( fd, APM_IOC_SUSPEND, NULL ) == 0)
d175 2
a176 2
	    xf86Msg(X_WARNING, "sunPMConfirmEventToOs: APM_IOC_SUSPEND"
		" %s\n", strerror(errno));
d178 8
a185 8
	}
      case XF86_APM_STANDBY_RESUME:
      case XF86_APM_NORMAL_RESUME:
      case XF86_APM_CRITICAL_RESUME:
      case XF86_APM_STANDBY_FAILED:
      case XF86_APM_SUSPEND_FAILED:
	    xf86Msg(X_WARNING, "Got RESUME\n");
        if (ioctl( fd, APM_IOC_RESUME, NULL ) == 0)
d188 2
a189 2
	    xf86Msg(X_WARNING, "sunPMConfirmEventToOs: APM_IOC_RESUME"
		" %s\n", strerror(errno));
d191 3
a193 3
	}
      default:
	return PM_NONE;
d203 1
a203 1
	return NULL;
d207 3
a209 3
    	if ((fd = open(APM_DEVICE1, O_RDWR)) == -1) {
		return NULL;
	}
d223 3
a225 3
	fd = xf86RemoveGeneralHandler(APMihPtr);
	close(fd);
	APMihPtr = NULL;
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d30 1
a30 1
/* Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d33 5
a37 8
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, and/or sell copies of the Software, and to permit persons
 * to whom the Software is furnished to do so, provided that the above
 * copyright notice(s) and this permission notice appear in all copies of
 * the Software and that both the above copyright notice(s) and this
 * permission notice appear in supporting documentation.
d39 3
a41 9
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d43 7
a49 4
 * Except as contained in this notice, the name of a copyright holder
 * shall not be used in advertising or otherwise to promote the sale, use
 * or other dealings in this Software without prior written authorization
 * of the copyright holder.
d212 1
a212 1
    APMihPtr = xf86AddInputHandler(fd, xf86HandlePMEvents, NULL);
d222 1
a222 1
	fd = xf86RemoveInputHandler(APMihPtr);
@


1.1
log
@Initial revision
@
text
@d152 1
a152 1
			" errno = %d\n", errno);
d181 1
a181 1
		" errno = %d\n", errno);
d194 1
a194 1
		" errno = %d\n", errno);
@


1.1.1.1
log
@xserver 1.4
@
text
@@
