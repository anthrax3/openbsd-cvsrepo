head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.8
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.6
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.10
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.27;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.43;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany
 * Copyright 1993 by David Wexelblat <dwex@@goblin.org>
 * Copyright 1999 by David Holland <davidh@@iquest.net>
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the names of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 *
 */
/* Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <sys/types.h>          /* get __x86 definition if not set by compiler */

#if defined(__i386__) || defined(__i386) || defined(__x86)
#define _NEED_SYSI86
#endif
#include "xf86.h"
#include "xf86Priv.h"
#include "xf86_OSlib.h"
#include "xf86OSpriv.h"
#include <sys/mman.h>

/***************************************************************************/
/* Video Memory Mapping section 					   */
/***************************************************************************/

_X_HIDDEN void
xf86OSInitVidMem(VidMemInfoPtr pVidMem)
{
    pVidMem->initialised = TRUE;
}

/***************************************************************************/
/* I/O Permissions section						   */
/***************************************************************************/

#if defined(__i386__) || defined(__i386) || defined(__x86)
static Bool ExtendedEnabled = FALSE;
#endif

Bool
xf86EnableIO(void)
{
#if defined(__i386__) || defined(__i386) || defined(__x86)
    if (ExtendedEnabled)
        return TRUE;

    if (sysi86(SI86V86, V86SC_IOPL, PS_IOPL) < 0) {
        xf86Msg(X_WARNING, "xf86EnableIOPorts: Failed to set IOPL for I/O\n");
        return FALSE;
    }
    ExtendedEnabled = TRUE;
#endif                          /* i386 */
    return TRUE;
}

void
xf86DisableIO(void)
{
#if defined(__i386__) || defined(__i386) || defined(__x86)
    if (!ExtendedEnabled)
        return;

    sysi86(SI86V86, V86SC_IOPL, 0);

    ExtendedEnabled = FALSE;
#endif                          /* i386 */
}
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a65 91
static char *apertureDevName = NULL;
static int apertureDevFD_ro = -1;
static int apertureDevFD_rw = -1;

static Bool
solOpenAperture(void)
{
    if (apertureDevName == NULL) {
        apertureDevName = "/dev/xsvc";
        if ((apertureDevFD_rw = open(apertureDevName, O_RDWR)) < 0) {
            xf86MsgVerb(X_WARNING, 0,
                        "solOpenAperture: failed to open %s (%s)\n",
                        apertureDevName, strerror(errno));
            apertureDevName = "/dev/fbs/aperture";
            apertureDevFD_rw = open(apertureDevName, O_RDWR);
        }
        apertureDevFD_ro = open(apertureDevName, O_RDONLY);

        if ((apertureDevFD_rw < 0) || (apertureDevFD_ro < 0)) {
            xf86MsgVerb(X_WARNING, 0,
                        "solOpenAperture: failed to open %s (%s)\n",
                        apertureDevName, strerror(errno));
            xf86MsgVerb(X_WARNING, 0,
                        "solOpenAperture: either /dev/fbs/aperture"
                        " or /dev/xsvc required\n");

            apertureDevName = NULL;

            if (apertureDevFD_rw >= 0) {
                close(apertureDevFD_rw);
            }
            apertureDevFD_rw = -1;

            if (apertureDevFD_ro >= 0) {
                close(apertureDevFD_ro);
            }
            apertureDevFD_ro = -1;

            return FALSE;
        }
    }
    return TRUE;
}

static void *
solMapVidMem(int ScreenNum, unsigned long Base, unsigned long Size, int Flags)
{
    void *base;
    int fd;
    int prot;

    if (Flags & VIDMEM_READONLY) {
        fd = apertureDevFD_ro;
        prot = PROT_READ;
    }
    else {
        fd = apertureDevFD_rw;
        prot = PROT_READ | PROT_WRITE;
    }

    if (fd < 0) {
        xf86DrvMsg(ScreenNum, X_ERROR,
                   "solMapVidMem: failed to open %s (%s)\n",
                   apertureDevName, strerror(errno));
        return NULL;
    }

    base = mmap(NULL, Size, prot, MAP_SHARED, fd, (off_t) Base);

    if (base == MAP_FAILED) {
        xf86DrvMsg(ScreenNum, X_ERROR,
                   "solMapVidMem: failed to mmap %s (0x%08lx,0x%lx) (%s)\n",
                   apertureDevName, Base, Size, strerror(errno));
        return NULL;
    }

    return base;
}

/* ARGSUSED */
static void
solUnMapVidMem(int ScreenNum, void *Base, unsigned long Size)
{
    if (munmap(Base, Size) != 0) {
        xf86DrvMsgVerb(ScreenNum, X_WARNING, 0,
                       "solUnMapVidMem: failed to unmap %s"
                       " (0x%p,0x%lx) (%s)\n",
                       apertureDevName, Base, Size, strerror(errno));
    }
}

a68 9
    pVidMem->linearSupported = solOpenAperture();
    if (pVidMem->linearSupported) {
        pVidMem->mapMem = solMapVidMem;
        pVidMem->unmapMem = solUnMapVidMem;
    }
    else {
        xf86MsgVerb(X_WARNING, 0,
                    "xf86OSInitVidMem: linear memory access disabled\n");
    }
a69 40
}

/*
 * Read BIOS via mmap()ing physical memory.
 */
int
xf86ReadBIOS(unsigned long Base, unsigned long Offset, unsigned char *Buf,
             int Len)
{
    unsigned char *ptr;
    int psize;
    int mlen;

    psize = getpagesize();
    Offset += Base & (psize - 1);
    Base &= ~(psize - 1);
    mlen = (Offset + Len + psize - 1) & ~(psize - 1);

    if (solOpenAperture() == FALSE) {
        xf86Msg(X_WARNING,
                "xf86ReadBIOS: Failed to open aperture to read BIOS\n");
        return -1;
    }

    ptr = (unsigned char *) mmap(NULL, mlen, PROT_READ,
                                 MAP_SHARED, apertureDevFD_ro, (off_t) Base);
    if (ptr == MAP_FAILED) {
        xf86Msg(X_WARNING, "xf86ReadBIOS: %s mmap failed [0x%08lx, 0x%04x]\n",
                apertureDevName, Base, mlen);
        return -1;
    }

    (void) memcpy(Buf, (void *) (ptr + Offset), Len);
    if (munmap((caddr_t) ptr, mlen) != 0) {
        xf86MsgVerb(X_WARNING, 0,
                    "xf86ReadBIOS: failed to unmap %s (0x%p,0x%x) (%s)\n",
                    apertureDevName, ptr, mlen, strerror(errno));
    }

    return Len;
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d110 1
a110 1
static pointer
d113 1
a113 1
    pointer base;
d147 1
a147 1
solUnMapVidMem(int ScreenNum, pointer Base, unsigned long Size)
@


1.5
log
@Update to xserver 1.11.2
@
text
@d51 1
a51 1
#include <sys/types.h> /* get __x86 definition if not set by compiler */
d54 1
a54 1
# define _NEED_SYSI86
d73 30
a102 35
    if (apertureDevName == NULL)
    {
	apertureDevName = "/dev/xsvc";
	if ((apertureDevFD_rw = open(apertureDevName, O_RDWR)) < 0)
	{
	    xf86MsgVerb(X_WARNING, 0,
			"solOpenAperture: failed to open %s (%s)\n",
			apertureDevName, strerror(errno));
	    apertureDevName = "/dev/fbs/aperture";
	    apertureDevFD_rw = open(apertureDevName, O_RDWR);
	}
	apertureDevFD_ro = open(apertureDevName, O_RDONLY);

	if ((apertureDevFD_rw < 0) || (apertureDevFD_ro < 0))
	{
	    xf86MsgVerb(X_WARNING, 0,
			"solOpenAperture: failed to open %s (%s)\n",
			apertureDevName, strerror(errno));
	    xf86MsgVerb(X_WARNING, 0,
			"solOpenAperture: either /dev/fbs/aperture"
			" or /dev/xsvc required\n");

	    apertureDevName = NULL;

	    if (apertureDevFD_rw >= 0)
	    {
		close(apertureDevFD_rw);
	    }
	    apertureDevFD_rw = -1;

	    if (apertureDevFD_ro >= 0)
	    {
		close(apertureDevFD_ro);
	    }
	    apertureDevFD_ro = -1;
d104 2
a105 2
	    return FALSE;
	}
d117 14
a130 17
    if (Flags & VIDMEM_READONLY)
    {
	fd = apertureDevFD_ro;
	prot = PROT_READ;
    }
    else
    {
	fd = apertureDevFD_rw;
	prot = PROT_READ | PROT_WRITE;
    }

    if (fd < 0)
    {
	xf86DrvMsg(ScreenNum, X_ERROR,
		   "solMapVidMem: failed to open %s (%s)\n",
		   apertureDevName, strerror(errno));
	return NULL;
d133 1
a133 1
    base = mmap(NULL, Size, prot, MAP_SHARED, fd, (off_t)Base);
d137 3
a139 3
		   "solMapVidMem: failed to mmap %s (0x%08lx,0x%lx) (%s)\n",
		   apertureDevName, Base, Size, strerror(errno));
	return NULL;
d150 4
a153 5
	xf86DrvMsgVerb(ScreenNum, X_WARNING, 0,
		       "solUnMapVidMem: failed to unmap %s"
		       " (0x%p,0x%lx) (%s)\n",
		       apertureDevName, Base, Size,
		       strerror(errno));
d162 6
a167 5
	pVidMem->mapMem = solMapVidMem;
	pVidMem->unmapMem = solUnMapVidMem;
    } else {
	xf86MsgVerb(X_WARNING, 0,
		    "xf86OSInitVidMem: linear memory access disabled\n");
d177 1
a177 1
	     int Len)
d188 19
a206 21
    if (solOpenAperture() == FALSE)
    {
	xf86Msg(X_WARNING,
		"xf86ReadBIOS: Failed to open aperture to read BIOS\n");
	return -1;
    }

    ptr = (unsigned char *)mmap(NULL, mlen, PROT_READ,
				MAP_SHARED, apertureDevFD_ro, (off_t)Base);
    if (ptr == MAP_FAILED)
    {
	xf86Msg(X_WARNING, "xf86ReadBIOS: %s mmap failed [0x%08lx, 0x%04x]\n",
		apertureDevName, Base, mlen);
	return -1;
    }

    (void)memcpy(Buf, (void *)(ptr + Offset), Len);
    if (munmap((caddr_t)ptr, mlen) != 0) {
	xf86MsgVerb(X_WARNING, 0,
		    "xf86ReadBIOS: failed to unmap %s (0x%p,0x%x) (%s)\n",
		    apertureDevName, ptr, mlen, strerror(errno));
a211 1

d225 1
a225 1
	return TRUE;
d228 2
a229 2
	xf86Msg(X_WARNING, "xf86EnableIOPorts: Failed to set IOPL for I/O\n");
	return FALSE;
d232 1
a232 1
#endif /* i386 */
d240 2
a241 2
    if(!ExtendedEnabled)
	return;
d246 1
a246 1
#endif /* i386 */
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d25 1
a25 1
/* Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
d160 1
a160 1
		       " (0x%08lx,0x%lx) (%s)\n",
d215 1
a215 2
		    "solUnMapVidMem: failed to unmap %s"
		    " (0x%08lx,0x%lx) (%s)\n",
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d28 5
a32 8
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, and/or sell copies of the Software, and to permit persons
 * to whom the Software is furnished to do so, provided that the above
 * copyright notice(s) and this permission notice appear in all copies of
 * the Software and that both the above copyright notice(s) and this
 * permission notice appear in supporting documentation.
d34 3
a36 9
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d38 7
a44 4
 * Except as contained in this notice, the name of a copyright holder
 * shall not be used in advertising or otherwise to promote the sale, use
 * or other dealings in this Software without prior written authorization
 * of the copyright holder.
d183 1
a183 1
_X_EXPORT int
d232 1
a232 1
_X_EXPORT Bool
d248 1
a248 1
_X_EXPORT void
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d4 1
d25 27
d60 1
a60 1
#define _NEED_SYSI86
d65 2
a66 4

#ifndef MAP_FAILED
#define MAP_FAILED ((void *)-1)
#endif
d72 3
a74 1
char *apertureDevName = NULL;
d76 2
a77 2
_X_EXPORT Bool
xf86LinearVidMem(void)
d79 2
a80 5
	int	mmapFd;

	if (apertureDevName)
	    return TRUE;

d82 1
a82 1
	if ((mmapFd = open(apertureDevName, O_RDWR)) < 0)
d84 3
d88 22
a109 1
	    if((mmapFd = open(apertureDevName, O_RDWR)) < 0)
d111 1
a111 10
		xf86MsgVerb(X_WARNING, 0,
		    "xf86LinearVidMem: failed to open %s (%s)\n",
		    apertureDevName, strerror(errno));
		xf86MsgVerb(X_WARNING, 0,
		    "xf86LinearVidMem: either /dev/fbs/aperture or /dev/xsvc"
		    " device driver required\n");
		xf86MsgVerb(X_WARNING, 0,
		    "xf86LinearVidMem: linear memory access disabled\n");
		apertureDevName = NULL;
		return FALSE;
d113 3
d117 2
a118 2
	close(mmapFd);
	return TRUE;
d121 2
a122 2
_X_EXPORT pointer
xf86MapVidMem(int ScreenNum, int Flags, unsigned long Base, unsigned long Size)
d124 31
a154 38
	pointer base;
	int fd;
	char vtname[20];

	/*
	 * Solaris 2.1 x86 SVR4 (10/27/93)
	 * The server must treat the virtual terminal device file as the
	 * standard SVR4 /dev/pmem.
	 *
	 * Using the /dev/vtXX device as /dev/pmem only works for the
	 * A0000-FFFFF region - If we wish you mmap the linear aperture
	 * it requires a device driver.
	 *
	 * So what we'll do is use /dev/vtXX for the A0000-FFFFF stuff, and
	 * try to use the /dev/fbs/aperture or /dev/xsvc driver if the server
	 * tries to mmap anything > FFFFF.  Its very very unlikely that the
	 * server will try to mmap anything below FFFFF that can't be handled
	 * by /dev/vtXX.
	 *
	 * DWH - 2/23/94
	 * DWH - 1/31/99 (Gee has it really been 5 years?)
	 *
	 * Solaris 2.8 7/26/99
	 * Use /dev/xsvc for everything
	 *
	 * DWH - 7/26/99 - Solaris8/dev/xsvc changes
	 *
	 * TSI - 2001.09 - SPARC changes
	 */

#if defined(__i386__) && !defined(__SOL8__)
	if(Base < 0xFFFFF)
		sprintf(vtname, "/dev/vt%02d", xf86Info.vtno);
	else
#endif
	{
		if (!xf86LinearVidMem())
			FatalError("xf86MapVidMem:  no aperture device\n");
d156 2
a157 2
		strcpy(vtname, apertureDevName);
	}
d159 12
a170 13
	fd = open(vtname, (Flags & VIDMEM_READONLY) ? O_RDONLY : O_RDWR);
	if (fd < 0)
		FatalError("xf86MapVidMem: failed to open %s (%s)\n",
			   vtname, strerror(errno));

	base = mmap(NULL, Size,
		    (Flags & VIDMEM_READONLY) ?
			PROT_READ : (PROT_READ | PROT_WRITE),
		     MAP_SHARED, fd, (off_t)Base);
	close(fd);
	if (base == MAP_FAILED)
		FatalError("xf86MapVidMem:  mmap failure:  %s\n",
			   strerror(errno));
d172 12
a183 1
	return(base);
d186 6
a191 3
/* ARGSUSED */
_X_EXPORT void
xf86UnMapVidMem(int ScreenNum, pointer Base, unsigned long Size)
d193 34
a226 1
	munmap(Base, Size);
d229 1
d242 2
a243 2
	if (ExtendedEnabled)
		return TRUE;
d245 5
a249 5
	if (sysi86(SI86V86, V86SC_IOPL, PS_IOPL) < 0) {
		xf86Msg(X_WARNING,"xf86EnableIOPorts: Failed to set IOPL for I/O\n");
		return FALSE;
	}
	ExtendedEnabled = TRUE;
d251 1
a251 1
	return TRUE;
d258 2
a259 2
	if(!ExtendedEnabled)
		return;
d261 1
a261 1
	sysi86(SI86V86, V86SC_IOPL, 0);
d263 1
a263 1
	ExtendedEnabled = FALSE;
a265 54


/***************************************************************************/
/* Interrupt Handling section						   */
/***************************************************************************/

_X_EXPORT Bool xf86DisableInterrupts(void)
{
#if defined(__i386__) || defined(__i386) || defined(__x86)
	if (!ExtendedEnabled && (sysi86(SI86V86, V86SC_IOPL, PS_IOPL) < 0))
		return FALSE;

#ifdef __GNUC__
	__asm__ __volatile__("cli");
#else
	asm("cli");
#endif /* __GNUC__ */

	if (!ExtendedEnabled)
		sysi86(SI86V86, V86SC_IOPL, 0);
#endif /* i386 */

	return TRUE;
}

_X_EXPORT void xf86EnableInterrupts(void)
{
#if defined(__i386__) || defined(__i386) || defined(__x86)
	if (!ExtendedEnabled && (sysi86(SI86V86, V86SC_IOPL, PS_IOPL) < 0))
		return;

#ifdef __GNUC__
	__asm__ __volatile__("sti");
#else
	asm("sti");
#endif /* __GNUC__ */

	if (!ExtendedEnabled)
		sysi86(SI86V86, V86SC_IOPL, 0);
#endif /* i386 */
}

_X_EXPORT void
xf86MapReadSideEffects(int ScreenNum, int Flags, pointer Base,
	unsigned long Size)
{
}

_X_EXPORT Bool
xf86CheckMTRR(int ScreenNum)
{
	return FALSE;
}

@


1.1
log
@Initial revision
@
text
@d31 1
a31 1
#if defined(i386) || defined(__x86)
d111 1
a111 1
#if defined(i386) && !defined(__SOL8__)
d151 1
a151 1
#if defined(i386) || defined(__x86)
d158 1
a158 1
#if defined(i386) || defined(__x86)
d174 1
a174 1
#if defined(i386) || defined(__x86)
d191 1
a191 1
#if defined(i386) || defined(__x86)
d210 1
a210 1
#if defined(i386) || defined(__x86)
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
